
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -D SYSTEM=2 -D C256_SKU=2 -D UARTSUPPORT= -D UNITTEST=0 -D TRACE_LEVEL=0 --long-address --flat -b --m65816 --intel-hex -o basic816_1A0000.hex --list=basic816_1A0000.lst --labels=basic816_1A0000.lbl src\basic816.s
; Tue May 11 19:24:24 2021

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=2					SYSTEM=2
=2					C256_SKU=2
=					UARTSUPPORT=
=0					UNITTEST=0
=0					TRACE_LEVEL=0

;******  Processing input file: src\basic816.s


;******  Processing file: src\constants.s

=2					SYSTEM_C256 = 2         ; C256 Foenix
=1					SYSTEM_C64 = 1          ; Commodore 64 with SuperCPU
=$03					CHAR_CTRL_C = $03       ; CTRL-C: used as a program interrupt key
=$07					CHAR_BELL = $07         ; Ring the console bell
=$08					CHAR_BS = $08           ; Backspace
=$09					CHAR_TAB = $09          ; TAB
=$0a					CHAR_LF = $0A           ; Linefeed
=$0d					CHAR_CR = $0D           ; Carriage Return
=$0f					CHAR_INS = $0F          ; Insert
=$1b					CHAR_ESC = $1B          ; Escape
=$22					CHAR_DQUOTE = $22       ; Double quote
=$20					CHAR_SP = $20           ; Space
=$7f					CHAR_DEL = $7F          ; Delete
=5					ARGUMENT_SIZE = 5       ; Number of bytes in an argument
=8					VAR_NAME_SIZE = 8       ; Maximum number of characters in a variable name
=0					TYPE_INTEGER = 0        ; 32-bit integer
=1					TYPE_FLOAT = 1          ; Single-precision floating point
=2					TYPE_STRING = 2         ; ASCII string
=$80					TYPE_ARR_INTEGER = $80  ; Array of 32-bit integers
=$81					TYPE_ARR_FLOAT = $81    ; Array of 32-bit floats
=$82					TYPE_ARR_STRING = $82   ; Array of strings
=$7f					TYPE_BINDING = $7F      ; A variable name binding
=$ff					TYPE_NAV = $FF          ; Not-A-Value
=0					ERR_OK = 0              ; No error
=1					ERR_BREAK = 1           ; The user pressed an interrupt key
=2					ERR_SYNTAX = 2          ; A syntax error was found on the current line
=3					ERR_MEMORY = 3          ; Out of memory
=4					ERR_TYPE = 4            ; Type mismatch error
=5					ERR_NOTFOUND = 5        ; Variable not found error
=6					ERR_NOLINE = 6          ; Line number not found
=7					ERR_STACKUNDER = 7      ; Stack underflow error
=8					ERR_STACKOVER = 8       ; Stack overflow error
=9					ERR_RANGE = 9           ; Out-of-range error
=10					ERR_ARGUMENT = 10       ; Bad argument error
=11					ERR_NOFILE = 11         ; File not found error
=12					ERR_NAN = 12            ; Floating point math resulted in something that is not a number
=13					ERR_OVERFLOW = 13       ; Math operation overflowed
=14					ERR_UNDERFLOW = 14      ; Math operation underflowed
=15					ERR_DIV0 = 15           ; Math operation involved a division by zero
=16					ERR_DIRECTORY = 16      ; Error reading the directory
=17					ERR_LOAD = 17           ; Could not load file
=18					ERR_SAVE = 18           ; Could not save a file
=19					ERR_DELETE = 19         ; Could not delete a file
=20					ERR_FILENOTFOUND = 20   ; Could not find the file
=21					ERR_DIRNOTWRITE = 21    ; Could not update the directory entry
=22					ERR_NOTCOPIED = 22      ; Could not copy the file
=23					ERR_DOMAIN = 23         ; Mathematical functions domain error

;******  Return to file: src\basic816.s


;******  Processing file: src\memorymap.s


;******  Processing file: src\C256/mmap_c256.s

=1					SYS_C256_FMX = 1        ; System SKU for C256 Foenix FMX
=2					SYS_C256_USER = 2       ; System SKU for C256 Foenix User

;******  Processing file: src\C256/page_00_inc.s

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				unused_0000      = $000000 ;12 Bytes unused
=$000008				OPL2_ADDY_PTR_LO = $000008  ; THis Points towards the Instruments Database
=$000009				OPL2_ADDY_PTR_MD = $000009
=$00000a				OPL2_ADDY_PTR_HI = $00000A
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;1 Byte Color of next character to be printed to the screen.
=$00001f				COLORPOS         = $00001F ;3 Byte address of cursor's position in the color matrix
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$000026				OPL2_OPERATOR    = $000026 ;
=$000027				OPL2_CHANNEL     = $000027 ;
=$000028				OPL2_REG_REGION  = $000028 ; Offset to the Group of Registers
=$00002a				OPL2_REG_OFFSET  = $00002A ; 2 Bytes (16Bits)
=$00002c				OPL2_IND_ADDY_LL = $00002C ; 2 Bytes Reserved (Only need 3)
=$00002e				OPL2_IND_ADDY_HL = $00002E ; 2 Bytes Reserved (Only need 3)
=$000030				OPL2_NOTE        = $000030 ; 1 Byte
=$000031				OPL2_OCTAVE      = $000031 ; 1 Byte
=$000032				OPL2_PARAMETER0  = $000032 ; 1 Byte - Key On/Feedback
=$000033				OPL2_PARAMETER1  = $000033 ; 1 Byte
=$000034				OPL2_PARAMETER2  = $000034 ; 1 Byte
=$000035				OPL2_PARAMETER3  = $000035 ; 1 Byte
=$000036				OPL2_LOOP        = $000036 ;
=$000036				OPL2_BLOCK       = $000036
=$000038				SDCARD_FILE_PTR  = $000038 ; 3 Bytes Pointer to Filename to open
=$00003c				SDCARD_BYTE_NUM  = $00003C ; 2Bytes
=$00003f				SDCARD_PRSNT_MNT = $00003F ; 1 Byte, Indicate that the SDCard is Present and that it is Mounted
=$000040				BM_CLEAR_SCRN_X  = $000040
=$000042				BM_CLEAR_SCRN_Y  = $000042
=$000040				RAD_STARTLINE    = $000040 ; 1 Byte
=$000041				RAD_PATTERN_IDX  = $000041 ; 1 Byte
=$000042				RAD_LINE         = $000042 ; 1 Byte
=$000043				RAD_LINENUMBER   = $000043 ; 1 Byte
=$000044				RAD_CHANNEL_NUM  = $000044 ; 1 Byte
=$000045				RAD_ISLASTCHAN   = $000045 ; 1 Byte
=$000046				RAD_Y_POINTER    = $000046 ; 2 Bytes
=$000048				RAD_TICK         = $000048
=$00004a				RAD_CHANNEL_DATA = $00004A ; 2 Bytes
=$00004c				RAD_CHANNE_EFFCT = $00004C
=$00004d				RAD_TEMP         = $00004D
=$000050				RAD_ADDR         = $000050 ; 3 bytes to avoid OPL2 errors.
=$000053				RAD_PATTRN       = $000053 ; 1 bytes - offset to patter
=$000054				RAD_PTN_DEST     = $000054 ; 3 bytes - where to write the pattern data
=$000057				RAD_CHANNEL      = $000057 ; 2 bytes - 0 to 8
=$000059				RAD_LAST_NOTE    = $000059 ; 1 if this is the last note
=$00005a				RAD_LINE_PTR     = $00005A ; 2 bytes - offset to memory location
=$000040				BMP_X_SIZE       = $000040 ; 2 Bytes
=$000042				BMP_Y_SIZE       = $000042 ; 2 Bytes
=$000044				BMP_PRSE_SRC_PTR = $000044 ; 3 Bytes
=$000048				BMP_PRSE_DST_PTR = $000048 ; 3 Bytes
=$00004c				BMP_COLOR_PALET  = $00004C ; 2 Bytes
=$00004e				SCRN_X_STRIDE    = $00004E ; 2 Bytes, Basically How many Pixel Accross in Bitmap Mode
=$000050				BMP_FILE_SIZE    = $000050 ; 4 Bytes
=$000054				BMP_POSITION_X   = $000054 ; 2 Bytes Where, the BMP will be position on the X Axis
=$000056				BMP_POSITION_Y   = $000056 ; 2 Bytes Where, the BMP will be position on the Y Axis
=$000058				BMP_PALET_CHOICE = $000058 ;
=$0000e0				MOUSE_PTR        = $0000E0
=$0000e1				MOUSE_POS_X_LO   = $0000E1
=$0000e2				MOUSE_POS_X_HI   = $0000E2
=$0000e3				MOUSE_POS_Y_LO   = $0000E3
=$0000e4				MOUSE_POS_Y_HI   = $0000E4
=$0000f0				USER_TEMP        = $0000F0 ;32 Bytes Temp space for user programs
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000110				DIVIDER_0        = $000110 ;0 Byte  Unsigned divider
=$000110				D0_OPERAND_A     = $000110 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$000112				D0_OPERAND_B     = $000112 ;2 Bytes Divider 0 Divisor ex B in A/B
=$000114				D0_RESULT        = $000114 ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D0_REMAINDER     = $000116 ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000118				DIVIDER_1        = $000118 ;0 Byte  Signed divider
=$000118				D1_OPERAND_A     = $000118 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$00011a				D1_OPERAND_B     = $00011A ;2 Bytes Divider 1 Divisor ex B in A/B
=$00011c				D1_RESULT        = $00011C ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$00011e				D1_REMAINDER     = $00011E ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$000120				ADDER_SIGNED_32  = $000120 ; The 32 Bit Adders takes 12Byte that are NOT RAM Location
=$000140				INT_CONTROLLER   = $000140 ; $000140...$00015F Interrupt Controller
=$000160				TIMER_CONTROLLER = $000160 ; $000160...$00017F Timer0/Timer1/Timer2 Block
=$000160				TIMER_CTRL_REGLL = $000160 ;
=$000161				TIMER_CTRL_REGLH = $000161 ;
=$000162				TIMER_CTRL_REGHL = $000162 ;
=$000163				TIMER_CTRL_REGHH = $000163 ;
=$000240				CPU_REGISTERS    = $000240 ; Byte
=$000240				CPUPC            = $000240 ;2 Bytes Program Counter (PC)
=$000242				CPUPBR           = $000242 ;2 Bytes Program Bank Register (K)
=$000244				CPUA             = $000244 ;2 Bytes Accumulator (A)
=$000246				CPUX             = $000246 ;2 Bytes X Register (X)
=$000248				CPUY             = $000248 ;2 Bytes Y Register (Y)
=$00024a				CPUSTACK         = $00024A ;2 Bytes Stack Pointer (S)
=$00024c				CPUDP            = $00024C ;2 Bytes Direct Page Register (D)
=$00024e				CPUDBR           = $00024E ;1 Byte  Data Bank Register (B)
=$00024f				CPUFLAGS         = $00024F ;1 Byte  Flags (P)
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$000300				FDC_DRIVE        = $000300 ;1 byte - The number of the selected drive
=$000301				FDC_HEAD         = $000301 ;1 byte - The head number (0 or 1)
=$000302				FDC_CYLINDER     = $000302 ;1 byte - The cylinder number
=$000303				FDC_SECTOR       = $000303 ;1 byte - The sector number
=$000304				FDC_SECTOR_SIZE  = $000304 ;1 byte - The sector size code (2 = 512)
=$000305				FDC_SECPERTRK    = $000305 ;1 byte - The number of sectors per track (18 for 1.44 MB floppy)
=$000306				FDC_ST0          = $000306 ;1 byte - Status Register 0
=$000307				FDC_ST1          = $000307 ;1 byte - Status Register 1
=$000308				FDC_ST2          = $000308 ;1 byte - Status Register 2
=$000309				FDC_ST3          = $000309 ;1 byte - Status Register 3
=$00030a				FDC_PCN          = $00030A ;1 byte - Present Cylinder Number
=$00030b				FDC_STATUS       = $00030B ;1 byte - Status of what we think is going on with the FDC:
=$00030c				DIVIDEND         = $00030C ;4 bytes - Dividend for 32-bit division
=$000310				DIVISOR          = $000310 ;4 bytes - Divisor for 32-bit division
=$000314				REMAINDER        = $000314 ;4 bytes - Remainder for 32-bit division
=$000320				SDOS_VARIABLES   = $000320
=$000320				BIOS_STATUS      = $000320      ; 1 byte - Status of any BIOS operation
=$000321				BIOS_DEV         = $000321      ; 1 byte - Block device number for block operations
=$000322				BIOS_LBA         = $000322      ; 4 bytes - Address of block to read/write (this is the physical block, w/o reference to partition)
=$000326				BIOS_BUFF_PTR    = $000326      ; 4 bytes - 24-bit pointer to memory for read/write operations
=$00032a				BIOS_FIFO_COUNT  = $00032A      ; 2 bytes - The number of bytes read on the last block read
=$00032e				DOS_STATUS       = $00032E      ; 1 byte - The error code describing any error with file access
=$000330				DOS_CLUS_ID      = $000330      ; 4 bytes - The cluster desired for a DOS operation
=$000338				DOS_DIR_PTR      = $000338      ; 4 bytes - Pointer to a directory entry (assumed to be within DOS_SECTOR)
=$00033c				DOS_BUFF_PTR     = $00033C      ; 4 bytes - A pointer for DOS cluster read/write operations
=$000340				DOS_FD_PTR       = $000340      ; 4 bytes - A pointer to a file descriptor
=$000344				DOS_FAT_LBA      = $000344      ; 4 bytes - The LBA for a sector of the FAT we need to read/write
=$000348				DOS_TEMP         = $000348      ; 4 bytes - Temporary storage for DOS operations
=$00034c				DOS_FILE_SIZE    = $00034C      ; 4 bytes - The size of a file
=$000350				DOS_SRC_PTR      = $000350      ; 4 bytes - Pointer for transferring data
=$000354				DOS_DST_PTR      = $000354      ; 4 bytes - Pointer for transferring data
=$000358				DOS_END_PTR      = $000358      ; 4 bytes - Pointer to the last byte to save
=$00035c				DOS_RUN_PTR      = $00035C      ; 4 bytes - Pointer for starting a loaded program
=$000360				DOS_RUN_PARAM    = $000360      ; 4 bytes - Pointer to the ASCIIZ string for arguments in loading a program
=$000364				DOS_STR1_PTR     = $000364      ; 4 bytes - pointer to a string
=$000368				DOS_STR2_PTR     = $000368      ; 4 bytes - pointer to a string
=$00036b				DOS_SCRATCH      = $00036B      ; 4 bytes - general purpose short term storage
=$000400				DOS_PATH_BUFF    = $000400      ; 256 bytes - A buffer for path names
=$000500				FDC_PARAMETERS   = $000500      ; 16 bytes - a buffer of parameter data for the FDC
=$000510				FDC_RESULTS      = $000510      ; 16 bytes - Buffer for results of FDC commands
=$000530				FDC_PARAM_NUM    = $000530      ; 1 byte - The number of parameters to send to the FDC (including command)
=$000532				FDC_RESULT_NUM   = $000532      ; 1 byte - The number of results expected
=$000533				FDC_EXPECT_DAT   = $000533      ; 1 byte - 0 = the command expects no data, otherwise expects data
=$000534				FDC_CMD_RETRY    = $000534      ; 1 byte - a retry counter for commands
=$000700				CURRUART         = $000700 ; 3-bytes: the base address of the current UART
=$000703				CHAN_OUT         = $000703 ; 1-byte: the number of the current output channel (for PUTC, etc.)
=$000704				CHAN_IN          = $000704 ; 1-byte: the number of the current input channel (for GETCH, etc.)
=$000705				TIMERFLAGS       = $000705 ; 1-byte: flags to indicate that one of the timer interupts has triggered
=$80					TIMER0TRIGGER    = $80
=$40					TIMER1TRIGGER    = $40
=$20					TIMER2TRIGGER    = $20
=$000f00				KEY_BUFFER       = $000F00 ; 64 Bytes keyboard buffer
=$0080					KEY_BUFFER_SIZE  = $0080   ;128 Bytes (constant) keyboard buffer length
=$000f7f				KEY_BUFFER_END   = $000F7F ;  1 Byte  Last byte of keyboard buffer
=$000f83				KEY_BUFFER_CMD   = $000F83 ;  1 Byte  Indicates the Command Process Status
=$000f84				COMMAND_SIZE_STR = $000F84 ;  1 Byte
=$000f86				COMMAND_COMP_TMP = $000F86 ;  2 Bytes
=$000f87				KEYBOARD_SC_FLG  = $000F87 ;  1 Bytes that indicate the Status of Left Shift, Left CTRL, Left ALT, Right Shift
=$000f88				KEYBOARD_SC_TMP  = $000F88 ;  1 Byte, Interrupt Save Scan Code while Processing
=$000f89				KEYBOARD_LOCKS   = $000F89 ;  1 Byte, the status of the various lock keys
=$000f8a				KEYFLAG          = $000F8A ;  1 Byte, flag to indicate if CTRL-C has been pressed
=$000f8b				KEY_BUFFER_RPOS  = $000F8B ;  2 Byte, position of the character to read from the KEY_BUFFER
=$000f8d				KEY_BUFFER_WPOS  = $000F8D ;  2 Byte, position of the character to write to the KEY_BUFFER
=$001000				KERNEL_JMP_BEGIN = $001000 ; Reserved for the Kernel jump table
=$001fff				KERNEL_JMP_END   = $001FFF
=$002000				TEST_BEGIN       = $002000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/int_math_defs.s

=$000100				UNSIGNED_MULT_A_LO  = $000100
=$000101				UNSIGNED_MULT_A_HI  = $000101
=$000102				UNSIGNED_MULT_B_LO  = $000102
=$000103				UNSIGNED_MULT_B_HI  = $000103
=$000104				UNSIGNED_MULT_AL_LO = $000104
=$000105				UNSIGNED_MULT_AL_HI = $000105
=$000106				UNSIGNED_MULT_AH_LO = $000106
=$000107				UNSIGNED_MULT_AH_HI = $000107
=$000108				SIGNED_MULT_A_LO    = $000108
=$000109				SIGNED_MULT_A_HI    = $000109
=$00010a				SIGNED_MULT_B_LO    = $00010A
=$00010b				SIGNED_MULT_B_HI    = $00010B
=$00010c				SIGNED_MULT_AL_LO   = $00010C
=$00010d				SIGNED_MULT_AL_HI   = $00010D
=$00010e				SIGNED_MULT_AH_LO   = $00010E
=$00010f				SIGNED_MULT_AH_HI   = $00010F
=$000110				UNSIGNED_DIV_DEM_LO = $000110
=$000111				UNSIGNED_DIV_DEM_HI = $000111
=$000112				UNSIGNED_DIV_NUM_LO = $000112
=$000113				UNSIGNED_DIV_NUM_HI = $000113
=$000114				UNSIGNED_DIV_QUO_LO = $000114
=$000115				UNSIGNED_DIV_QUO_HI = $000115
=$000116				UNSIGNED_DIV_REM_LO = $000116
=$000117				UNSIGNED_DIV_REM_HI = $000117
=$000118				SIGNED_DIV_DEM_LO   = $000118
=$000119				SIGNED_DIV_DEM_HI   = $000119
=$00011a				SIGNED_DIV_NUM_LO   = $00011A
=$00011b				SIGNED_DIV_NUM_HI   = $00011B
=$00011c				SIGNED_DIV_QUO_LO   = $00011C
=$00011d				SIGNED_DIV_QUO_HI   = $00011D
=$00011e				SIGNED_DIV_REM_LO   = $00011E
=$00011f				SIGNED_DIV_REM_HI   = $00011F
=$000120				ADDER32_A_LL        = $000120
=$000121				ADDER32_A_LH        = $000121
=$000122				ADDER32_A_HL        = $000122
=$000123				ADDER32_A_HH        = $000123
=$000124				ADDER32_B_LL        = $000124
=$000125				ADDER32_B_LH        = $000125
=$000126				ADDER32_B_HL        = $000126
=$000127				ADDER32_B_HH        = $000127
=$000128				ADDER32_R_LL        = $000128
=$000129				ADDER32_R_LH        = $000129
=$00012a				ADDER32_R_HL        = $00012A
=$00012b				ADDER32_R_HH        = $00012B
=$af1400				SIGNED32_MULT_A     = $AF1400
=$af1404				SIGNED32_MULT_B     = $AF1404
=$af1408				SIGNED32_MULT_OUT   = $AF1408

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/vicky_def.s

=$af0000				MASTER_CTRL_REG_L	      = $AF0000
=$01					Mstr_Ctrl_Text_Mode_En  = $01       ; Enable the Text Mode
=$02					Mstr_Ctrl_Text_Overlay  = $02       ; Enable the Overlay of the text mode on top of Graphic Mode (the Background Color is ignored)
=$04					Mstr_Ctrl_Graph_Mode_En = $04       ; Enable the Graphic Mode
=$08					Mstr_Ctrl_Bitmap_En     = $08       ; Enable the Bitmap Module In Vicky
=$10					Mstr_Ctrl_TileMap_En    = $10       ; Enable the Tile Module in Vicky
=$20					Mstr_Ctrl_Sprite_En     = $20       ; Enable the Sprite Module in Vicky
=$40					Mstr_Ctrl_GAMMA_En      = $40       ; this Enable the GAMMA correction - The Analog and DVI have different color value, the GAMMA is great to correct the difference
=$80					Mstr_Ctrl_Disable_Vid   = $80       ; This will disable the Scanning of the Video hence giving 100% bandwith to the CPU
=$af0001				MASTER_CTRL_REG_H       = $AF0001
=$01					Mstr_Ctrl_Video_Mode0   = $01       ; 0 - 640x480 (Clock @ 25.175Mhz), 1 - 800x600 (Clock @ 40Mhz)
=$02					Mstr_Ctrl_Video_Mode1   = $02       ; 0 - No Pixel Doubling, 1- Pixel Doubling (Reduce the Pixel Resolution by 2)
=$af0002				GAMMA_CTRL_REG          = $AF0002
=$01					GAMMA_Ctrl_Input        = $01 ; 0 = DipSwitch Chooses GAMMA on/off , 1- Software Control
=$02					GAMMA_Ctrl_Soft         = $02 ; 0 = GAMMA Table is not Applied, 1 = GAMMA Table is Applied
=$08					GAMMA_DP_SW_VAL         = $08 ; READ ONLY - Actual DIP Switch Value
=$10					HIRES_DP_SW_VAL         = $10 ; READ ONLY - 0 = Hi-Res on BOOT ON, 1 = Hi-Res on BOOT OFF
=$af0003				VKY_RESERVED_01         = $AF0003
=$01					Border_Ctrl_Enable      = $01
=$af0004				BORDER_CTRL_REG         = $AF0004 ; Bit[0] - Enable (1 by default)  Bit[4..6]: X Scroll Offset ( Will scroll Left) (Acceptable Value: 0..7)
=$af0005				BORDER_COLOR_B          = $AF0005
=$af0006				BORDER_COLOR_G          = $AF0006
=$af0007				BORDER_COLOR_R          = $AF0007
=$af0008				BORDER_X_SIZE           = $AF0008; X-  Values: 0 - 32 (Default: 32)
=$af0009				BORDER_Y_SIZE           = $AF0009; Y- Values 0 -32 (Default: 32)
=$af000d				BACKGROUND_COLOR_B      = $AF000D ; When in Graphic Mode, if a pixel is "0" then the Background pixel is chosen
=$af000e				BACKGROUND_COLOR_G      = $AF000E
=$af000f				BACKGROUND_COLOR_R      = $AF000F ;
=$af0010				VKY_TXT_CURSOR_CTRL_REG = $AF0010   ;[0]  Enable Text Mode
=$01					Vky_Cursor_Enable       = $01
=$02					Vky_Cursor_Flash_Rate0  = $02       ; 00 - 1/Sec, 01 - 2/Sec, 10 - 4/Sec, 11 - 5/Sec
=$04					Vky_Cursor_Flash_Rate1  = $04
=$08					Vky_Cursor_FONT_Page0   = $08       ; Pick Font Page 0 or Font Page 1
=$10					Vky_Cursor_FONT_Page1   = $10       ; Pick Font Page 0 or Font Page 1
=$af0011				VKY_TXT_START_ADD_PTR   = $AF0011   ; This is an offset to change the Starting address of the Text Mode Buffer (in x)
=$af0012				VKY_TXT_CURSOR_CHAR_REG = $AF0012
=$af0013				VKY_TXT_CURSOR_COLR_REG = $AF0013
=$af0014				VKY_TXT_CURSOR_X_REG_L  = $AF0014
=$af0015				VKY_TXT_CURSOR_X_REG_H  = $AF0015
=$af0016				VKY_TXT_CURSOR_Y_REG_L  = $AF0016
=$af0017				VKY_TXT_CURSOR_Y_REG_H  = $AF0017
=$af001b				VKY_LINE_IRQ_CTRL_REG   = $AF001B ;[0] - Enable Line 0, [1] -Enable Line 1
=$af001c				VKY_LINE0_CMP_VALUE_LO  = $AF001C ;Write Only [7:0]
=$af001d				VKY_LINE0_CMP_VALUE_HI  = $AF001D ;Write Only [3:0]
=$af001e				VKY_LINE1_CMP_VALUE_LO  = $AF001E ;Write Only [7:0]
=$af001f				VKY_LINE1_CMP_VALUE_HI  = $AF001F ;Write Only [3:0]
=$af001c				VKY_INFO_CHIP_NUM_L     = $AF001C   ; VErsion
=$af001d				VKY_INFO_CHIP_NUM_H     = $AF001D   ; Version
=$af001e				VKY_INFO_CHIP_VER_L     = $AF001E   ; Sub-Version
=$af001f				VKY_INFO_CHIP_VER_H     = $AF001F   ; Sub-Version
=$af0500				MOUSE_PTR_GRAP0_START    = $AF0500 ; 16 x 16 = 256 Pixels (Grey Scale) 0 = Transparent, 1 = Black , 255 = White
=$af05ff				MOUSE_PTR_GRAP0_END      = $AF05FF ; Pointer 0
=$af0600				MOUSE_PTR_GRAP1_START    = $AF0600 ;
=$af06ff				MOUSE_PTR_GRAP1_END      = $AF06FF ; Pointer 1
=$af0700				MOUSE_PTR_CTRL_REG_L    = $AF0700 ; Bit[0] Enable, Bit[1] = 0  ( 0 = Pointer0, 1 = Pointer1)
=$af0701				MOUSE_PTR_CTRL_REG_H    = $AF0701 ;
=$af0702				MOUSE_PTR_X_POS_L       = $AF0702 ; X Position (0 - 639) (Can only read now) Writing will have no effect
=$af0703				MOUSE_PTR_X_POS_H       = $AF0703 ;
=$af0704				MOUSE_PTR_Y_POS_L       = $AF0704 ; Y Position (0 - 479) (Can only read now) Writing will have no effect
=$af0705				MOUSE_PTR_Y_POS_H       = $AF0705 ;
=$af0706				MOUSE_PTR_BYTE0         = $AF0706 ; Byte 0 of Mouse Packet (you must write 3 Bytes)
=$af0707				MOUSE_PTR_BYTE1         = $AF0707 ; Byte 1 of Mouse Packet (if you don't, then )
=$af0708				MOUSE_PTR_BYTE2         = $AF0708 ; Byte 2 of Mouse Packet (state Machine will be jammed in 1 state)
=$af070b				C256F_MODEL_MAJOR       = $AF070B ;
=$af070c				C256F_MODEL_MINOR       = $AF070C ;
=$af070d				FPGA_DOR                = $AF070D ;
=$af070e				FPGA_MOR                = $AF070E ;
=$af070f				FPGA_YOR                = $AF070F ;
=$af0900				VMEM2CPU_CTRL_REG      = $AF0900  ;
=$01					VMEM2CPU_Clear_FIFO    = $01        ; Setting this to 1 will flush (Reset) the FIFO, clear it after to return to normal function
=$02					VMEM2CPU_Intterupt     = $02        ; This is not implemented because there is not enough Interrupt line on the FMX
=$af0901				VMEM2CPU_Data_Port     = $AF0901    ; This is a Byte Port of the data that you have requested. (Output of the FIFO)
=$af0902				VMEM2CPU_Fifo_Count_LO = $AF0902    ; FIFO Count Lo (number of byte in the FIFO) FIFO Count is 10bits, Count_Bit0 to Count_Bit7 of Count
=$af0903				VMEM2CPU_Fifo_Count_HI = $AF0903    ; FIFO Count Hi, Bit 0 = Count_Bit8, Bit 1 = Count_Bit9
=$80					VMEM2CPU_Fifo_Empty    = $80        ; Bit 7 of VMEM2CPU_Fifo_Count_HI, when 1, the FIFO is empty.
=$af1f40				FG_CHAR_LUT_PTR         = $AF1F40
=$af1f80				BG_CHAR_LUT_PTR		    = $AF1F80
=$af2000				GRPH_LUT0_PTR		    = $AF2000
=$af2400				GRPH_LUT1_PTR		    = $AF2400
=$af2800				GRPH_LUT2_PTR		    = $AF2800
=$af2c00				GRPH_LUT3_PTR		    = $AF2C00
=$af3000				GRPH_LUT4_PTR		    = $AF3000
=$af3400				GRPH_LUT5_PTR		    = $AF3400
=$af3800				GRPH_LUT6_PTR		    = $AF3800
=$af3c00				GRPH_LUT7_PTR		    = $AF3C00
=$af4000				GAMMA_B_LUT_PTR		    = $AF4000
=$af4100				GAMMA_G_LUT_PTR		    = $AF4100
=$af4200				GAMMA_R_LUT_PTR		    = $AF4200
=$af8000				FONT_MEMORY_BANK0       = $AF8000     ;$AF8000 - $AF87FF
=$afa000				CS_TEXT_MEM_PTR         = $AFA000
=$afc000				CS_COLOR_MEM_PTR        = $AFC000

;******  Processing file: src\C256/VKYII_CFP9553_BITMAP_def.s

=$01					BM_Enable             = $01
=$00					BM_LUT0               = $00 ;
=$02					BM_LUT1               = $02 ;
=$04					BM_LUT2               = $04 ;
=$06					BM_LUT3               = $06 ;
=$08					BM_LUT4               = $08 ;
=$0a					BM_LUT5               = $0A ;
=$0c					BM_LUT6               = $0C ;
=$0e					BM_LUT7               = $0E ;
=$af0100				BM0_CONTROL_REG     = $AF0100
=$af0101				BM0_START_ADDY_L    = $AF0101
=$af0102				BM0_START_ADDY_M    = $AF0102
=$af0103				BM0_START_ADDY_H    = $AF0103
=$af0104				BM0_X_OFFSET        = $AF0104   ; Not Implemented
=$af0105				BM0_Y_OFFSET        = $AF0105   ; Not Implemented
=$af0106				BM0_RESERVED_6      = $AF0106
=$af0107				BM0_RESERVED_7      = $AF0107
=$af0108				BM1_CONTROL_REG     = $AF0108
=$af0109				BM1_START_ADDY_L    = $AF0109
=$af010a				BM1_START_ADDY_M    = $AF010A
=$af010b				BM1_START_ADDY_H    = $AF010B
=$af010c				BM1_X_OFFSET        = $AF010C   ; Not Implemented
=$af010d				BM1_Y_OFFSET        = $AF010D   ; Not Implemented
=$af010e				BM1_RESERVED_6      = $AF010E
=$af010f				BM1_RESERVED_7      = $AF010F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_TILEMAP_def.s

=$01					TILE_Enable             = $01
=0					TILEMAP_CONTROL         = 0             ; Offset to a tile map's control register
=1					TILEMAP_START_ADDY      = 1             ; Offset to a tile map's address
=4					TILEMAP_TOTAL_X         = 4             ; Offset to a tile map's width
=6					TILEMAP_TOTAL_Y         = 6             ; Offset to a tile map's height
=8					TILEMAP_WINDOW_X        = 8             ; Offset to a tile map's X position
=10					TILEMAP_WINDOW_Y        = 10            ; Offset to a tile map's Y position
=1					TILEMAP_VISIBLE         = 1             ; Tile map is visible flag
=$af0200				TL0_CONTROL_REG         = $AF0200       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0201				TL0_START_ADDY_L        = $AF0201       ; Not USed right now - Starting Address to where is the MAP
=$af0202				TL0_START_ADDY_M        = $AF0202
=$af0203				TL0_START_ADDY_H        = $AF0203
=$af0204				TL0_TOTAL_X_SIZE_L      = $AF0204       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0205				TL0_TOTAL_X_SIZE_H      = $AF0205
=$af0206				TL0_TOTAL_Y_SIZE_L      = $AF0206       ; Size of the Map in Y Tile Count [9:0]
=$af0207				TL0_TOTAL_Y_SIZE_H      = $AF0207
=$af0208				TL0_WINDOW_X_POS_L      = $AF0208       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0209				TL0_WINDOW_X_POS_H      = $AF0209       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af020a				TL0_WINDOW_Y_POS_L      = $AF020A       ; Top Left Corner Position of the TileMAp Window in Y
=$af020b				TL0_WINDOW_Y_POS_H      = $AF020B       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af020c				TL1_CONTROL_REG         = $AF020C       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af020d				TL1_START_ADDY_L        = $AF020D       ; Not USed right now - Starting Address to where is the MAP
=$af020e				TL1_START_ADDY_M        = $AF020E
=$af020f				TL1_START_ADDY_H        = $AF020F
=$af0210				TL1_TOTAL_X_SIZE_L      = $AF0210       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0211				TL1_TOTAL_X_SIZE_H      = $AF0211
=$af0212				TL1_TOTAL_Y_SIZE_L      = $AF0212       ; Size of the Map in Y Tile Count [9:0]
=$af0213				TL1_TOTAL_Y_SIZE_H      = $AF0213
=$af0214				TL1_WINDOW_X_POS_L      = $AF0214       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0215				TL1_WINDOW_X_POS_H      = $AF0215       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0216				TL1_WINDOW_Y_POS_L      = $AF0216       ; Top Left Corner Position of the TileMAp Window in Y
=$af0217				TL1_WINDOW_Y_POS_H      = $AF0217       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0218				TL2_CONTROL_REG         = $AF0218       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0219				TL2_START_ADDY_L        = $AF0219       ; Not USed right now - Starting Address to where is the MAP
=$af021a				TL2_START_ADDY_M        = $AF021A
=$af021b				TL2_START_ADDY_H        = $AF021B
=$af021c				TL2_TOTAL_X_SIZE_L      = $AF021C       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af021d				TL2_TOTAL_X_SIZE_H      = $AF021D
=$af021e				TL2_TOTAL_Y_SIZE_L      = $AF021E       ; Size of the Map in Y Tile Count [9:0]
=$af021f				TL2_TOTAL_Y_SIZE_H      = $AF021F
=$af0220				TL2_WINDOW_X_POS_L      = $AF0220       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0221				TL2_WINDOW_X_POS_H      = $AF0221       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0222				TL2_WINDOW_Y_POS_L      = $AF0222       ; Top Left Corner Position of the TileMAp Window in Y
=$af0223				TL2_WINDOW_Y_POS_H      = $AF0223       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0224				TL3_CONTROL_REG         = $AF0224       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0225				TL3_START_ADDY_L        = $AF0225       ; Not USed right now - Starting Address to where is the MAP
=$af0226				TL3_START_ADDY_M        = $AF0226
=$af0227				TL3_START_ADDY_H        = $AF0227
=$af0228				TL3_TOTAL_X_SIZE_L      = $AF0228       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0229				TL3_TOTAL_X_SIZE_H      = $AF0229
=$af022a				TL3_TOTAL_Y_SIZE_L      = $AF022A       ; Size of the Map in Y Tile Count [9:0]
=$af022b				TL3_TOTAL_Y_SIZE_H      = $AF022B
=$af022c				TL3_WINDOW_X_POS_L      = $AF022C       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af022d				TL3_WINDOW_X_POS_H      = $AF022D       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af022e				TL3_WINDOW_Y_POS_L      = $AF022E       ; Top Left Corner Position of the TileMAp Window in Y
=$af022f				TL3_WINDOW_Y_POS_H      = $AF022F       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0280				TILESET0_ADDY_L         = $AF0280   ; Pointer to Tileset 0 [21:0]
=$af0281				TILESET0_ADDY_M         = $AF0281
=$af0282				TILESET0_ADDY_H         = $AF0282
=$af0283				TILESET0_ADDY_CFG       = $AF0283   ; [3] - TileStride256x256 [2:0] LUT
=2					TILESET_ADDY_H          = 2             ; Offset to high byte of tile set address
=3					TILESET_ADDY_CFG        = 3             ; Offset to the tile set address configuration
=$08					TILESET_SQUARE_256      = $08
=$af0284				TILESET1_ADDY_L         = $AF0284
=$af0285				TILESET1_ADDY_M         = $AF0285
=$af0286				TILESET1_ADDY_H         = $AF0286
=$af0287				TILESET1_ADDY_CFG       = $AF0287
=$af0288				TILESET2_ADDY_L         = $AF0288
=$af0289				TILESET2_ADDY_M         = $AF0289
=$af028a				TILESET2_ADDY_H         = $AF028A
=$af028b				TILESET2_ADDY_CFG       = $AF028B
=$af028c				TILESET3_ADDY_L         = $AF028C
=$af028d				TILESET3_ADDY_M         = $AF028D
=$af028e				TILESET3_ADDY_H         = $AF028E
=$af028f				TILESET3_ADDY_CFG       = $AF028F
=$af0290				TILESET4_ADDY_L         = $AF0290
=$af0291				TILESET4_ADDY_M         = $AF0291
=$af0292				TILESET4_ADDY_H         = $AF0292
=$af0293				TILESET4_ADDY_CFG       = $AF0293
=$af0294				TILESET5_ADDY_L         = $AF0294
=$af0295				TILESET5_ADDY_M         = $AF0295
=$af0296				TILESET5_ADDY_H         = $AF0296
=$af0297				TILESET5_ADDY_CFG       = $AF0297
=$af0298				TILESET6_ADDY_L         = $AF0298
=$af0299				TILESET6_ADDY_M         = $AF0299
=$af029a				TILESET6_ADDY_H         = $AF029A
=$af029b				TILESET6_ADDY_CFG       = $AF029B
=$af029c				TILESET7_ADDY_L         = $AF029C
=$af029d				TILESET7_ADDY_M         = $AF029D
=$af029e				TILESET7_ADDY_H         = $AF029E
=$af029f				TILESET7_ADDY_CFG       = $AF029F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SDMA_def.s

=$af0420				SDMA_CTRL_REG0           = $AF0420
=$01					SDMA_CTRL0_Enable        = $01
=$02					SDMA_CTRL0_1D_2D         = $02     ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					SDMA_CTRL0_TRF_Fill      = $04     ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					SDMA_CTRL0_Int_Enable    = $08     ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					SDMA_CTRL0_SysRAM_Src    = $10     ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					SDMA_CTRL0_SysRAM_Dst    = $20     ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$00					SDMA_XFER_SRAM2SRAM = $00           ; SRAM -> SRAM transfer
=$10					SDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					SDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$30					SDMA_XFER_SRAMIO = $30              ; SRAM <-> IO transfer (see: SDMA_CONTROL_REG1 for config and direction)
=$40					SDMA_CTLR0_RSVD          = $40      ; Reserved
=$80					SDMA_CTRL0_Start_TRF     = $80      ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$af0421				SDMA_CTRL_REG1           = $AF0421  ; Write Only - Byte to Write in the Fill Function
=$01					SDMA_CTRL1_IO_Src		 = $01		; 1 = Source is an IO Address (ADC, SuperIO, IDE)
=$02					SDMA_CTRL1_IO_Src16		 = $02		; 0 = Src 8Bits Transfer / 1= 16Bits Transfer
=$04					SDMA_CTRL1_IO_Dst		 = $04		; 1 = Destination is an IO Address (DAC, SuperIO, IDE)
=$08					SDMA_CTRL1_IO_Dst16      = $08      ; 0 = Dst 8bits Transfer / 1= 16bits
=$af0422				SDMA_SRC_ADDY_L         = $AF0422   ; Pointer to the Source of the Data to be stransfered
=$af0423				SDMA_SRC_ADDY_M         = $AF0423   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0424				SDMA_SRC_ADDY_H         = $AF0424
=$af0425				SDMA_DST_ADDY_L         = $AF0425   ; Destination Pointer within CPU's video memory Range
=$af0426				SDMA_DST_ADDY_M         = $AF0426   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0427				SDMA_DST_ADDY_H         = $AF0427
=$af0428				SDMA_SIZE_L             = $AF0428   ; Maximum Value: $40:0000 (4Megs)
=$af0429				SDMA_SIZE_M             = $AF0429
=$af042a				SDMA_SIZE_H             = $AF042A
=$af042b				SDMA_IGNORED            = $AF042B
=$af0428				SDMA_X_SIZE_L           = $AF0428   ; Maximum Value: 65535
=$af0429				SDMA_X_SIZE_H           = $AF0429
=$af042a				SDMA_Y_SIZE_L           = $AF042A   ; Maximum Value: 65535
=$af042b				SDMA_Y_SIZE_H           = $AF042B
=$af042c				SDMA_SRC_STRIDE_L       = $AF042C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042d				SDMA_SRC_STRIDE_H       = $AF042D   ;
=$af042e				SDMA_DST_STRIDE_L       = $AF042E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042f				SDMA_DST_STRIDE_H       = $AF042F   ;
=$af0430				SDMA_BYTE_2_WRITE       = $AF0430   ; Write Only - Byte to Write in the Fill Function
=$af0430				SDMA_STATUS_REG         = $AF0430   ; Read only
=$01					SDMA_STAT_Size_Err       = $01      ; If Set to 1, Overall Size is Invalid
=$02					SDMA_STAT_Dst_Add_Err    = $02      ; If Set to 1, Destination Address Invalid
=$04					SDMA_STAT_Src_Add_Err    = $04      ; If Set to 1, Source Address Invalid
=$08					SDMA_STAT_TimeOut_Err    = $08      ; will be set to 1 if a Timeout occur when transfering between data from and to VRAM

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_VDMA_def.s

=$af0400				VDMA_CONTROL_REG        = $AF0400
=$01					VDMA_CTRL_Enable        = $01
=$02					VDMA_CTRL_1D_2D         = $02       ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					VDMA_CTRL_TRF_Fill      = $04       ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					VDMA_CTRL_Int_Enable    = $08       ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					VDMA_CTRL_SysRAM_Src    = $10       ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					VDMA_CTRL_SysRAM_Dst    = $20       ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$80					VDMA_CTRL_Start_TRF     = $80       ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$00					VDMA_XFER_VRAM2VRAM = $00           ; VRAM -> VRAM transfer
=$10					VDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					VDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$af0401				VDMA_BYTE_2_WRITE       = $AF0401   ; Write Only - Byte to Write in the Fill Function
=$af0401				VDMA_STATUS_REG         = $AF0401   ; Read only
=$01					VDMA_STAT_Size_Err      = $01       ; If Set to 1, Overall Size is Invalid
=$02					VDMA_STAT_Dst_Add_Err   = $02       ; If Set to 1, Destination Address Invalid
=$04					VDMA_STAT_Src_Add_Err   = $04       ; If Set to 1, Source Address Invalid
=$80					VDMA_STAT_VDMA_IPS      = $80       ; If Set to 1, VDMA Transfer in Progress (this Inhibit CPU Access to Mem)
=$af0402				VDMA_SRC_ADDY_L         = $AF0402   ; Pointer to the Source of the Data to be stransfered
=$af0403				VDMA_SRC_ADDY_M         = $AF0403   ; This needs to be within Vicky's Range ($00_0000 - $3F_0000)
=$af0404				VDMA_SRC_ADDY_H         = $AF0404
=$af0405				VDMA_DST_ADDY_L         = $AF0405   ; Destination Pointer within Vicky's video memory Range
=$af0406				VDMA_DST_ADDY_M         = $AF0406   ; ($00_0000 - $3F_0000)
=$af0407				VDMA_DST_ADDY_H         = $AF0407
=$af0408				VDMA_SIZE_L             = $AF0408   ; Maximum Value: $40:0000 (4Megs)
=$af0409				VDMA_SIZE_M             = $AF0409
=$af040a				VDMA_SIZE_H             = $AF040A
=$af040b				VDMA_IGNORED            = $AF040B
=$af0408				VDMA_X_SIZE_L           = $AF0408   ; Maximum Value: 65535
=$af0409				VDMA_X_SIZE_H           = $AF0409
=$af040a				VDMA_Y_SIZE_L           = $AF040A   ; Maximum Value: 65535
=$af040b				VDMA_Y_SIZE_H           = $AF040B
=$af040c				VDMA_SRC_STRIDE_L       = $AF040C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040d				VDMA_SRC_STRIDE_H       = $AF040D   ;
=$af040e				VDMA_DST_STRIDE_L       = $AF040E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040f				VDMA_DST_STRIDE_H       = $AF040F   ;

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SPRITE_def.s

=$01					SPRITE_Enable             = $01
=$00					SPRITE_LUT0               = $00 ; This is the LUT that the Sprite will use
=$02					SPRITE_LUT1               = $02
=$04					SPRITE_LUT2               = $04 ; Only 4 LUT for Now, So this bit is not used.
=$06					SPRITE_LUT3               = $06 ; Only 4 LUT for Now, So this bit is not used.
=$08					SPRITE_LUT4               = $08 ; Only 4 LUT for Now, So this bit is not used.
=$0a					SPRITE_LUT5               = $0A ; Only 4 LUT for Now, So this bit is not used.
=$0c					SPRITE_LUT6               = $0C ; Only 4 LUT for Now, So this bit is not used.
=$0e					SPRITE_LUT7               = $0E ; Only 4 LUT for Now, So this bit is not used.
=$00					SPRITE_DEPTH0             = $00
=$10					SPRITE_DEPTH1             = $10
=$20					SPRITE_DEPTH2             = $20
=$30					SPRITE_DEPTH3             = $30
=$40					SPRITE_DEPTH4             = $40
=$50					SPRITE_DEPTH5             = $50
=$60					SPRITE_DEPTH6             = $60
=$af0c00				SP00_CONTROL_REG        = $AF0C00
=$af0c01				SP00_ADDY_PTR_L         = $AF0C01
=$af0c02				SP00_ADDY_PTR_M         = $AF0C02
=$af0c03				SP00_ADDY_PTR_H         = $AF0C03
=$af0c04				SP00_X_POS_L            = $AF0C04
=$af0c05				SP00_X_POS_H            = $AF0C05
=$af0c06				SP00_Y_POS_L            = $AF0C06
=$af0c07				SP00_Y_POS_H            = $AF0C07
=$af0c08				SP01_CONTROL_REG        = $AF0C08
=$af0c09				SP01_ADDY_PTR_L         = $AF0C09
=$af0c0a				SP01_ADDY_PTR_M         = $AF0C0A
=$af0c0b				SP01_ADDY_PTR_H         = $AF0C0B
=$af0c0c				SP01_X_POS_L            = $AF0C0C
=$af0c0d				SP01_X_POS_H            = $AF0C0D
=$af0c0e				SP01_Y_POS_L            = $AF0C0E
=$af0c0f				SP01_Y_POS_H            = $AF0C0F
=$af0c10				SP02_CONTROL_REG        = $AF0C10
=$af0c11				SP02_ADDY_PTR_L         = $AF0C11
=$af0c12				SP02_ADDY_PTR_M         = $AF0C12
=$af0c13				SP02_ADDY_PTR_H         = $AF0C13
=$af0c14				SP02_X_POS_L            = $AF0C14
=$af0c15				SP02_X_POS_H            = $AF0C15
=$af0c16				SP02_Y_POS_L            = $AF0C16
=$af0c17				SP02_Y_POS_H            = $AF0C17
=$af0c18				SP03_CONTROL_REG        = $AF0C18
=$af0c19				SP03_ADDY_PTR_L         = $AF0C19
=$af0c1a				SP03_ADDY_PTR_M         = $AF0C1A
=$af0c1b				SP03_ADDY_PTR_H         = $AF0C1B
=$af0c1c				SP03_X_POS_L            = $AF0C1C
=$af0c1d				SP03_X_POS_H            = $AF0C1D
=$af0c1e				SP03_Y_POS_L            = $AF0C1E
=$af0c1f				SP03_Y_POS_H            = $AF0C1F
=$af0c20				SP04_CONTROL_REG        = $AF0C20
=$af0c21				SP04_ADDY_PTR_L         = $AF0C21
=$af0c22				SP04_ADDY_PTR_M         = $AF0C22
=$af0c23				SP04_ADDY_PTR_H         = $AF0C23
=$af0c24				SP04_X_POS_L            = $AF0C24
=$af0c25				SP04_X_POS_H            = $AF0C25
=$af0c26				SP04_Y_POS_L            = $AF0C26
=$af0c27				SP04_Y_POS_H            = $AF0C27
=$af0c28				SP05_CONTROL_REG        = $AF0C28
=$af0c29				SP05_ADDY_PTR_L         = $AF0C29
=$af0c2a				SP05_ADDY_PTR_M         = $AF0C2A
=$af0c2b				SP05_ADDY_PTR_H         = $AF0C2B
=$af0c2c				SP05_X_POS_L            = $AF0C2C
=$af0c2d				SP05_X_POS_H            = $AF0C2D
=$af0c2e				SP05_Y_POS_L            = $AF0C2E
=$af0c2f				SP05_Y_POS_H            = $AF0C2F
=$af0c30				SP06_CONTROL_REG        = $AF0C30
=$af0c31				SP06_ADDY_PTR_L         = $AF0C31
=$af0c32				SP06_ADDY_PTR_M         = $AF0C32
=$af0c33				SP06_ADDY_PTR_H         = $AF0C33
=$af0c34				SP06_X_POS_L            = $AF0C34
=$af0c35				SP06_X_POS_H            = $AF0C35
=$af0c36				SP06_Y_POS_L            = $AF0C36
=$af0c37				SP06_Y_POS_H            = $AF0C37
=$af0c38				SP07_CONTROL_REG        = $AF0C38
=$af0c39				SP07_ADDY_PTR_L         = $AF0C39
=$af0c3a				SP07_ADDY_PTR_M         = $AF0C3A
=$af0c3b				SP07_ADDY_PTR_H         = $AF0C3B
=$af0c3c				SP07_X_POS_L            = $AF0C3C
=$af0c3d				SP07_X_POS_H            = $AF0C3D
=$af0c3e				SP07_Y_POS_L            = $AF0C3E
=$af0c3f				SP07_Y_POS_H            = $AF0C3F
=$af0c40				SP08_CONTROL_REG        = $AF0C40
=$af0c41				SP08_ADDY_PTR_L         = $AF0C41
=$af0c42				SP08_ADDY_PTR_M         = $AF0C42
=$af0c43				SP08_ADDY_PTR_H         = $AF0C43
=$af0c44				SP08_X_POS_L            = $AF0C44
=$af0c45				SP08_X_POS_H            = $AF0C45
=$af0c46				SP08_Y_POS_L            = $AF0C46
=$af0c47				SP08_Y_POS_H            = $AF0C47
=$af0c48				SP09_CONTROL_REG        = $AF0C48
=$af0c49				SP09_ADDY_PTR_L         = $AF0C49
=$af0c4a				SP09_ADDY_PTR_M         = $AF0C4A
=$af0c4b				SP09_ADDY_PTR_H         = $AF0C4B
=$af0c4c				SP09_X_POS_L            = $AF0C4C
=$af0c4d				SP09_X_POS_H            = $AF0C4D
=$af0c4e				SP09_Y_POS_L            = $AF0C4E
=$af0c4f				SP09_Y_POS_H            = $AF0C4F
=$af0c50				SP10_CONTROL_REG        = $AF0C50
=$af0c51				SP10_ADDY_PTR_L         = $AF0C51
=$af0c52				SP10_ADDY_PTR_M         = $AF0C52
=$af0c53				SP10_ADDY_PTR_H         = $AF0C53
=$af0c54				SP10_X_POS_L            = $AF0C54
=$af0c55				SP10_X_POS_H            = $AF0C55
=$af0c56				SP10_Y_POS_L            = $AF0C56
=$af0c57				SP10_Y_POS_H            = $AF0C57
=$af0c58				SP11_CONTROL_REG        = $AF0C58
=$af0c59				SP11_ADDY_PTR_L         = $AF0C59
=$af0c5a				SP11_ADDY_PTR_M         = $AF0C5A
=$af0c5b				SP11_ADDY_PTR_H         = $AF0C5B
=$af0c5c				SP11_X_POS_L            = $AF0C5C
=$af0c5d				SP11_X_POS_H            = $AF0C5D
=$af0c5e				SP11_Y_POS_L            = $AF0C5E
=$af0c5f				SP11_Y_POS_H            = $AF0C5F
=$af0c60				SP12_CONTROL_REG        = $AF0C60
=$af0c61				SP12_ADDY_PTR_L         = $AF0C61
=$af0c62				SP12_ADDY_PTR_M         = $AF0C62
=$af0c63				SP12_ADDY_PTR_H         = $AF0C63
=$af0c64				SP12_X_POS_L            = $AF0C64
=$af0c65				SP12_X_POS_H            = $AF0C65
=$af0c66				SP12_Y_POS_L            = $AF0C66
=$af0c67				SP12_Y_POS_H            = $AF0C67
=$af0c68				SP13_CONTROL_REG        = $AF0C68
=$af0c69				SP13_ADDY_PTR_L         = $AF0C69
=$af0c6a				SP13_ADDY_PTR_M         = $AF0C6A
=$af0c6b				SP13_ADDY_PTR_H         = $AF0C6B
=$af0c6c				SP13_X_POS_L            = $AF0C6C
=$af0c6d				SP13_X_POS_H            = $AF0C6D
=$af0c6e				SP13_Y_POS_L            = $AF0C6E
=$af0c6f				SP13_Y_POS_H            = $AF0C6F
=$af0c70				SP14_CONTROL_REG        = $AF0C70
=$af0c71				SP14_ADDY_PTR_L         = $AF0C71
=$af0c72				SP14_ADDY_PTR_M         = $AF0C72
=$af0c73				SP14_ADDY_PTR_H         = $AF0C73
=$af0c74				SP14_X_POS_L            = $AF0C74
=$af0c75				SP14_X_POS_H            = $AF0C75
=$af0c76				SP14_Y_POS_L            = $AF0C76
=$af0c77				SP14_Y_POS_H            = $AF0C77
=$af0c78				SP15_CONTROL_REG        = $AF0C78
=$af0c79				SP15_ADDY_PTR_L         = $AF0C79
=$af0c7a				SP15_ADDY_PTR_M         = $AF0C7A
=$af0c7b				SP15_ADDY_PTR_H         = $AF0C7B
=$af0c7c				SP15_X_POS_L            = $AF0C7C
=$af0c7d				SP15_X_POS_H            = $AF0C7D
=$af0c7e				SP15_Y_POS_L            = $AF0C7E
=$af0c7f				SP15_Y_POS_H            = $AF0C7F
=$af0c80				SP16_CONTROL_REG        = $AF0C80
=$af0c81				SP16_ADDY_PTR_L         = $AF0C81
=$af0c82				SP16_ADDY_PTR_M         = $AF0C82
=$af0c83				SP16_ADDY_PTR_H         = $AF0C83
=$af0c84				SP16_X_POS_L            = $AF0C84
=$af0c85				SP16_X_POS_H            = $AF0C85
=$af0c86				SP16_Y_POS_L            = $AF0C86
=$af0c87				SP16_Y_POS_H            = $AF0C87
=$af0c88				SP17_CONTROL_REG        = $AF0C88
=$af0c89				SP17_ADDY_PTR_L         = $AF0C89
=$af0c8a				SP17_ADDY_PTR_M         = $AF0C8A
=$af0c8b				SP17_ADDY_PTR_H         = $AF0C8B
=$af0c8c				SP17_X_POS_L            = $AF0C8C
=$af0c8d				SP17_X_POS_H            = $AF0C8D
=$af0c8e				SP17_Y_POS_L            = $AF0C8E
=$af0c8f				SP17_Y_POS_H            = $AF0C8F
=$af0c90				SP18_CONTROL_REG        = $AF0C90
=$af0c91				SP18_ADDY_PTR_L         = $AF0C91
=$af0c92				SP18_ADDY_PTR_M         = $AF0C92
=$af0c93				SP18_ADDY_PTR_H         = $AF0C93
=$af0c94				SP18_X_POS_L            = $AF0C94
=$af0c95				SP18_X_POS_H            = $AF0C95
=$af0c96				SP18_Y_POS_L            = $AF0C96
=$af0c97				SP18_Y_POS_H            = $AF0C97
=$af0c98				SP19_CONTROL_REG        = $AF0C98
=$af0c99				SP19_ADDY_PTR_L         = $AF0C99
=$af0c9a				SP19_ADDY_PTR_M         = $AF0C9A
=$af0c9b				SP19_ADDY_PTR_H         = $AF0C9B
=$af0c9c				SP19_X_POS_L            = $AF0C9C
=$af0c9d				SP19_X_POS_H            = $AF0C9D
=$af0c9e				SP19_Y_POS_L            = $AF0C9E
=$af0c9f				SP19_Y_POS_H            = $AF0C9F
=$af0ca0				SP20_CONTROL_REG        = $AF0CA0
=$af0ca1				SP20_ADDY_PTR_L         = $AF0CA1
=$af0ca2				SP20_ADDY_PTR_M         = $AF0CA2
=$af0ca3				SP20_ADDY_PTR_H         = $AF0CA3
=$af0ca4				SP20_X_POS_L            = $AF0CA4
=$af0ca5				SP20_X_POS_H            = $AF0CA5
=$af0ca6				SP20_Y_POS_L            = $AF0CA6
=$af0ca7				SP20_Y_POS_H            = $AF0CA7
=$af0ca8				SP21_CONTROL_REG        = $AF0CA8
=$af0ca9				SP21_ADDY_PTR_L         = $AF0CA9
=$af0caa				SP21_ADDY_PTR_M         = $AF0CAA
=$af0cab				SP21_ADDY_PTR_H         = $AF0CAB
=$af0cac				SP21_X_POS_L            = $AF0CAC
=$af0cad				SP21_X_POS_H            = $AF0CAD
=$af0cae				SP21_Y_POS_L            = $AF0CAE
=$af0caf				SP21_Y_POS_H            = $AF0CAF
=$af0cb0				SP22_CONTROL_REG        = $AF0CB0
=$af0cb1				SP22_ADDY_PTR_L         = $AF0CB1
=$af0cb2				SP22_ADDY_PTR_M         = $AF0CB2
=$af0cb3				SP22_ADDY_PTR_H         = $AF0CB3
=$af0cb4				SP22_X_POS_L            = $AF0CB4
=$af0cb5				SP22_X_POS_H            = $AF0CB5
=$af0cb6				SP22_Y_POS_L            = $AF0CB6
=$af0cb7				SP22_Y_POS_H            = $AF0CB7
=$af0cb8				SP23_CONTROL_REG        = $AF0CB8
=$af0cb9				SP23_ADDY_PTR_L         = $AF0CB9
=$af0cba				SP23_ADDY_PTR_M         = $AF0CBA
=$af0cbb				SP23_ADDY_PTR_H         = $AF0CBB
=$af0cbc				SP23_X_POS_L            = $AF0CBC
=$af0cbd				SP23_X_POS_H            = $AF0CBD
=$af0cbe				SP23_Y_POS_L            = $AF0CBE
=$af0cbf				SP23_Y_POS_H            = $AF0CBF
=$af0cc0				SP24_CONTROL_REG        = $AF0CC0
=$af0cc1				SP24_ADDY_PTR_L         = $AF0CC1
=$af0cc2				SP24_ADDY_PTR_M         = $AF0CC2
=$af0cc3				SP24_ADDY_PTR_H         = $AF0CC3
=$af0cc4				SP24_X_POS_L            = $AF0CC4
=$af0cc5				SP24_X_POS_H            = $AF0CC5
=$af0cc6				SP24_Y_POS_L            = $AF0CC6
=$af0cc7				SP24_Y_POS_H            = $AF0CC7
=$af0cc8				SP25_CONTROL_REG        = $AF0CC8
=$af0cc9				SP25_ADDY_PTR_L         = $AF0CC9
=$af0cca				SP25_ADDY_PTR_M         = $AF0CCA
=$af0ccb				SP25_ADDY_PTR_H         = $AF0CCB
=$af0ccc				SP25_X_POS_L            = $AF0CCC
=$af0ccd				SP25_X_POS_H            = $AF0CCD
=$af0cce				SP25_Y_POS_L            = $AF0CCE
=$af0ccf				SP25_Y_POS_H            = $AF0CCF
=$af0cd0				SP26_CONTROL_REG        = $AF0CD0
=$af0cd1				SP26_ADDY_PTR_L         = $AF0CD1
=$af0cd2				SP26_ADDY_PTR_M         = $AF0CD2
=$af0cd3				SP26_ADDY_PTR_H         = $AF0CD3
=$af0cd4				SP26_X_POS_L            = $AF0CD4
=$af0cd5				SP26_X_POS_H            = $AF0CD5
=$af0cd6				SP26_Y_POS_L            = $AF0CD6
=$af0cd7				SP26_Y_POS_H            = $AF0CD7
=$af0cd8				SP27_CONTROL_REG        = $AF0CD8
=$af0cd9				SP27_ADDY_PTR_L         = $AF0CD9
=$af0cda				SP27_ADDY_PTR_M         = $AF0CDA
=$af0cdb				SP27_ADDY_PTR_H         = $AF0CDB
=$af0cdc				SP27_X_POS_L            = $AF0CDC
=$af0cdd				SP27_X_POS_H            = $AF0CDD
=$af0cde				SP27_Y_POS_L            = $AF0CDE
=$af0cdf				SP27_Y_POS_H            = $AF0CDF
=$af0ce0				SP28_CONTROL_REG        = $AF0CE0
=$af0ce1				SP28_ADDY_PTR_L         = $AF0CE1
=$af0ce2				SP28_ADDY_PTR_M         = $AF0CE2
=$af0ce3				SP28_ADDY_PTR_H         = $AF0CE3
=$af0ce4				SP28_X_POS_L            = $AF0CE4
=$af0ce5				SP28_X_POS_H            = $AF0CE5
=$af0ce6				SP28_Y_POS_L            = $AF0CE6
=$af0ce7				SP28_Y_POS_H            = $AF0CE7
=$af0ce8				SP29_CONTROL_REG        = $AF0CE8
=$af0ce9				SP29_ADDY_PTR_L         = $AF0CE9
=$af0cea				SP29_ADDY_PTR_M         = $AF0CEA
=$af0ceb				SP29_ADDY_PTR_H         = $AF0CEB
=$af0cec				SP29_X_POS_L            = $AF0CEC
=$af0ced				SP29_X_POS_H            = $AF0CED
=$af0cee				SP29_Y_POS_L            = $AF0CEE
=$af0cef				SP29_Y_POS_H            = $AF0CEF
=$af0cf0				SP30_CONTROL_REG        = $AF0CF0
=$af0cf1				SP30_ADDY_PTR_L         = $AF0CF1
=$af0cf2				SP30_ADDY_PTR_M         = $AF0CF2
=$af0cf3				SP30_ADDY_PTR_H         = $AF0CF3
=$af0cf4				SP30_X_POS_L            = $AF0CF4
=$af0cf5				SP30_X_POS_H            = $AF0CF5
=$af0cf6				SP30_Y_POS_L            = $AF0CF6
=$af0cf7				SP30_Y_POS_H            = $AF0CF7
=$af0cf8				SP31_CONTROL_REG        = $AF0CF8
=$af0cf9				SP31_ADDY_PTR_L         = $AF0CF9
=$af0cfa				SP31_ADDY_PTR_M         = $AF0CFA
=$af0cfb				SP31_ADDY_PTR_H         = $AF0CFB
=$af0cfc				SP31_X_POS_L            = $AF0CFC
=$af0cfd				SP31_X_POS_H            = $AF0CFD
=$af0cfe				SP31_Y_POS_L            = $AF0CFE
=$af0cff				SP31_Y_POS_H            = $AF0CFF
=$af0d00				SP32_CONTROL_REG        = $AF0D00
=$af0d01				SP32_ADDY_PTR_L         = $AF0D01
=$af0d02				SP32_ADDY_PTR_M         = $AF0D02
=$af0d03				SP32_ADDY_PTR_H         = $AF0D03
=$af0d04				SP32_X_POS_L            = $AF0D04
=$af0d05				SP32_X_POS_H            = $AF0D05
=$af0d06				SP32_Y_POS_L            = $AF0D06
=$af0d07				SP32_Y_POS_H            = $AF0D07
=$af0d08				SP33_CONTROL_REG        = $AF0D08
=$af0d09				SP33_ADDY_PTR_L         = $AF0D09
=$af0d0a				SP33_ADDY_PTR_M         = $AF0D0A
=$af0d0b				SP33_ADDY_PTR_H         = $AF0D0B
=$af0d0c				SP33_X_POS_L            = $AF0D0C
=$af0d0d				SP33_X_POS_H            = $AF0D0D
=$af0d0e				SP33_Y_POS_L            = $AF0D0E
=$af0d0f				SP33_Y_POS_H            = $AF0D0F
=$af0d10				SP34_CONTROL_REG        = $AF0D10
=$af0d11				SP34_ADDY_PTR_L         = $AF0D11
=$af0d12				SP34_ADDY_PTR_M         = $AF0D12
=$af0d13				SP34_ADDY_PTR_H         = $AF0D13
=$af0d14				SP34_X_POS_L            = $AF0D14
=$af0d15				SP34_X_POS_H            = $AF0D15
=$af0d16				SP34_Y_POS_L            = $AF0D16
=$af0d17				SP34_Y_POS_H            = $AF0D17
=$af0d18				SP35_CONTROL_REG        = $AF0D18
=$af0d19				SP35_ADDY_PTR_L         = $AF0D19
=$af0d1a				SP35_ADDY_PTR_M         = $AF0D1A
=$af0d1b				SP35_ADDY_PTR_H         = $AF0D1B
=$af0d1c				SP35_X_POS_L            = $AF0D1C
=$af0d1d				SP35_X_POS_H            = $AF0D1D
=$af0d1e				SP35_Y_POS_L            = $AF0D1E
=$af0d1f				SP35_Y_POS_H            = $AF0D1F
=$af0d20				SP36_CONTROL_REG        = $AF0D20
=$af0d21				SP36_ADDY_PTR_L         = $AF0D21
=$af0d22				SP36_ADDY_PTR_M         = $AF0D22
=$af0d23				SP36_ADDY_PTR_H         = $AF0D23
=$af0d24				SP36_X_POS_L            = $AF0D24
=$af0d25				SP36_X_POS_H            = $AF0D25
=$af0d26				SP36_Y_POS_L            = $AF0D26
=$af0d27				SP36_Y_POS_H            = $AF0D27
=$af0d28				SP37_CONTROL_REG        = $AF0D28
=$af0d29				SP37_ADDY_PTR_L         = $AF0D29
=$af0d2a				SP37_ADDY_PTR_M         = $AF0D2A
=$af0d2b				SP37_ADDY_PTR_H         = $AF0D2B
=$af0d2c				SP37_X_POS_L            = $AF0D2C
=$af0d2d				SP37_X_POS_H            = $AF0D2D
=$af0d2e				SP37_Y_POS_L            = $AF0D2E
=$af0d2f				SP37_Y_POS_H            = $AF0D2F
=$af0d30				SP38_CONTROL_REG        = $AF0D30
=$af0d31				SP38_ADDY_PTR_L         = $AF0D31
=$af0d32				SP38_ADDY_PTR_M         = $AF0D32
=$af0d33				SP38_ADDY_PTR_H         = $AF0D33
=$af0d34				SP38_X_POS_L            = $AF0D34
=$af0d35				SP38_X_POS_H            = $AF0D35
=$af0d36				SP38_Y_POS_L            = $AF0D36
=$af0d37				SP38_Y_POS_H            = $AF0D37
=$af0d38				SP39_CONTROL_REG        = $AF0D38
=$af0d39				SP39_ADDY_PTR_L         = $AF0D39
=$af0d3a				SP39_ADDY_PTR_M         = $AF0D3A
=$af0d3b				SP39_ADDY_PTR_H         = $AF0D3B
=$af0d3c				SP39_X_POS_L            = $AF0D3C
=$af0d3d				SP39_X_POS_H            = $AF0D3D
=$af0d3e				SP39_Y_POS_L            = $AF0D3E
=$af0d3f				SP39_Y_POS_H            = $AF0D3F
=$af0d40				SP40_CONTROL_REG        = $AF0D40
=$af0d41				SP40_ADDY_PTR_L         = $AF0D41
=$af0d42				SP40_ADDY_PTR_M         = $AF0D42
=$af0d43				SP40_ADDY_PTR_H         = $AF0D43
=$af0d44				SP40_X_POS_L            = $AF0D44
=$af0d45				SP40_X_POS_H            = $AF0D45
=$af0d46				SP40_Y_POS_L            = $AF0D46
=$af0d47				SP40_Y_POS_H            = $AF0D47
=$af0d48				SP41_CONTROL_REG        = $AF0D48
=$af0d49				SP41_ADDY_PTR_L         = $AF0D49
=$af0d4a				SP41_ADDY_PTR_M         = $AF0D4A
=$af0d4b				SP41_ADDY_PTR_H         = $AF0D4B
=$af0d4c				SP41_X_POS_L            = $AF0D4C
=$af0d4d				SP41_X_POS_H            = $AF0D4D
=$af0d4e				SP41_Y_POS_L            = $AF0D4E
=$af0d4f				SP41_Y_POS_H            = $AF0D4F
=$af0d50				SP42_CONTROL_REG        = $AF0D50
=$af0d51				SP42_ADDY_PTR_L         = $AF0D51
=$af0d52				SP42_ADDY_PTR_M         = $AF0D52
=$af0d53				SP42_ADDY_PTR_H         = $AF0D53
=$af0d54				SP42_X_POS_L            = $AF0D54
=$af0d55				SP42_X_POS_H            = $AF0D55
=$af0d56				SP42_Y_POS_L            = $AF0D56
=$af0d57				SP42_Y_POS_H            = $AF0D57
=$af0d58				SP43_CONTROL_REG        = $AF0D58
=$af0d59				SP43_ADDY_PTR_L         = $AF0D59
=$af0d5a				SP43_ADDY_PTR_M         = $AF0D5A
=$af0d5b				SP43_ADDY_PTR_H         = $AF0D5B
=$af0d5c				SP43_X_POS_L            = $AF0D5C
=$af0d5d				SP43_X_POS_H            = $AF0D5D
=$af0d5e				SP43_Y_POS_L            = $AF0D5E
=$af0d5f				SP43_Y_POS_H            = $AF0D5F
=$af0d60				SP44_CONTROL_REG        = $AF0D60
=$af0d61				SP44_ADDY_PTR_L         = $AF0D61
=$af0d62				SP44_ADDY_PTR_M         = $AF0D62
=$af0d63				SP44_ADDY_PTR_H         = $AF0D63
=$af0d64				SP44_X_POS_L            = $AF0D64
=$af0d65				SP44_X_POS_H            = $AF0D65
=$af0d66				SP44_Y_POS_L            = $AF0D66
=$af0d67				SP44_Y_POS_H            = $AF0D67
=$af0d68				SP45_CONTROL_REG        = $AF0D68
=$af0d69				SP45_ADDY_PTR_L         = $AF0D69
=$af0d6a				SP45_ADDY_PTR_M         = $AF0D6A
=$af0d6b				SP45_ADDY_PTR_H         = $AF0D6B
=$af0d6c				SP45_X_POS_L            = $AF0D6C
=$af0d6d				SP45_X_POS_H            = $AF0D6D
=$af0d6e				SP45_Y_POS_L            = $AF0D6E
=$af0d6f				SP45_Y_POS_H            = $AF0D6F
=$af0d70				SP46_CONTROL_REG        = $AF0D70
=$af0d71				SP46_ADDY_PTR_L         = $AF0D71
=$af0d72				SP46_ADDY_PTR_M         = $AF0D72
=$af0d73				SP46_ADDY_PTR_H         = $AF0D73
=$af0d74				SP46_X_POS_L            = $AF0D74
=$af0d75				SP46_X_POS_H            = $AF0D75
=$af0d76				SP46_Y_POS_L            = $AF0D76
=$af0d77				SP46_Y_POS_H            = $AF0D77
=$af0d78				SP47_CONTROL_REG        = $AF0D78
=$af0d79				SP47_ADDY_PTR_L         = $AF0D79
=$af0d7a				SP47_ADDY_PTR_M         = $AF0D7A
=$af0d7b				SP47_ADDY_PTR_H         = $AF0D7B
=$af0d7c				SP47_X_POS_L            = $AF0D7C
=$af0d7d				SP47_X_POS_H            = $AF0D7D
=$af0d7e				SP47_Y_POS_L            = $AF0D7E
=$af0d7f				SP47_Y_POS_H            = $AF0D7F
=$af0d80				SP48_CONTROL_REG        = $AF0D80
=$af0d81				SP48_ADDY_PTR_L         = $AF0D81
=$af0d82				SP48_ADDY_PTR_M         = $AF0D82
=$af0d83				SP48_ADDY_PTR_H         = $AF0D83
=$af0d84				SP48_X_POS_L            = $AF0D84
=$af0d85				SP48_X_POS_H            = $AF0D85
=$af0d86				SP48_Y_POS_L            = $AF0D86
=$af0d87				SP48_Y_POS_H            = $AF0D87
=$af0d88				SP49_CONTROL_REG        = $AF0D88
=$af0d89				SP49_ADDY_PTR_L         = $AF0D89
=$af0d8a				SP49_ADDY_PTR_M         = $AF0D8A
=$af0d8b				SP49_ADDY_PTR_H         = $AF0D8B
=$af0d8c				SP49_X_POS_L            = $AF0D8C
=$af0d8d				SP49_X_POS_H            = $AF0D8D
=$af0d8e				SP49_Y_POS_L            = $AF0D8E
=$af0d8f				SP49_Y_POS_H            = $AF0D8F
=$af0d90				SP50_CONTROL_REG        = $AF0D90
=$af0d91				SP50_ADDY_PTR_L         = $AF0D91
=$af0d92				SP50_ADDY_PTR_M         = $AF0D92
=$af0d93				SP50_ADDY_PTR_H         = $AF0D93
=$af0d94				SP50_X_POS_L            = $AF0D94
=$af0d95				SP50_X_POS_H            = $AF0D95
=$af0d96				SP50_Y_POS_L            = $AF0D96
=$af0d97				SP50_Y_POS_H            = $AF0D97
=$af0d98				SP51_CONTROL_REG        = $AF0D98
=$af0d99				SP51_ADDY_PTR_L         = $AF0D99
=$af0d9a				SP51_ADDY_PTR_M         = $AF0D9A
=$af0d9b				SP51_ADDY_PTR_H         = $AF0D9B
=$af0d9c				SP51_X_POS_L            = $AF0D9C
=$af0d9d				SP51_X_POS_H            = $AF0D9D
=$af0d9e				SP51_Y_POS_L            = $AF0D9E
=$af0d9f				SP51_Y_POS_H            = $AF0D9F
=$af0da0				SP52_CONTROL_REG        = $AF0DA0
=$af0da1				SP52_ADDY_PTR_L         = $AF0DA1
=$af0da2				SP52_ADDY_PTR_M         = $AF0DA2
=$af0da3				SP52_ADDY_PTR_H         = $AF0DA3
=$af0da4				SP52_X_POS_L            = $AF0DA4
=$af0da5				SP52_X_POS_H            = $AF0DA5
=$af0da6				SP52_Y_POS_L            = $AF0DA6
=$af0da7				SP52_Y_POS_H            = $AF0DA7
=$af0da8				SP53_CONTROL_REG        = $AF0DA8
=$af0da9				SP53_ADDY_PTR_L         = $AF0DA9
=$af0daa				SP53_ADDY_PTR_M         = $AF0DAA
=$af0dab				SP53_ADDY_PTR_H         = $AF0DAB
=$af0dac				SP53_X_POS_L            = $AF0DAC
=$af0dad				SP53_X_POS_H            = $AF0DAD
=$af0dae				SP53_Y_POS_L            = $AF0DAE
=$af0daf				SP53_Y_POS_H            = $AF0DAF
=$af0db0				SP54_CONTROL_REG        = $AF0DB0
=$af0db1				SP54_ADDY_PTR_L         = $AF0DB1
=$af0db2				SP54_ADDY_PTR_M         = $AF0DB2
=$af0db3				SP54_ADDY_PTR_H         = $AF0DB3
=$af0db4				SP54_X_POS_L            = $AF0DB4
=$af0db5				SP54_X_POS_H            = $AF0DB5
=$af0db6				SP54_Y_POS_L            = $AF0DB6
=$af0db7				SP54_Y_POS_H            = $AF0DB7
=$af0db8				SP55_CONTROL_REG        = $AF0DB8
=$af0db9				SP55_ADDY_PTR_L         = $AF0DB9
=$af0dba				SP55_ADDY_PTR_M         = $AF0DBA
=$af0dbb				SP55_ADDY_PTR_H         = $AF0DBB
=$af0dbc				SP55_X_POS_L            = $AF0DBC
=$af0dbd				SP55_X_POS_H            = $AF0DBD
=$af0dbe				SP55_Y_POS_L            = $AF0DBE
=$af0dbf				SP55_Y_POS_H            = $AF0DBF
=$af0dc0				SP56_CONTROL_REG        = $AF0DC0
=$af0dc1				SP56_ADDY_PTR_L         = $AF0DC1
=$af0dc2				SP56_ADDY_PTR_M         = $AF0DC2
=$af0dc3				SP56_ADDY_PTR_H         = $AF0DC3
=$af0dc4				SP56_X_POS_L            = $AF0DC4
=$af0dc5				SP56_X_POS_H            = $AF0DC5
=$af0dc6				SP56_Y_POS_L            = $AF0DC6
=$af0dc7				SP56_Y_POS_H            = $AF0DC7
=$af0dc8				SP57_CONTROL_REG        = $AF0DC8
=$af0dc9				SP57_ADDY_PTR_L         = $AF0DC9
=$af0dca				SP57_ADDY_PTR_M         = $AF0DCA
=$af0dcb				SP57_ADDY_PTR_H         = $AF0DCB
=$af0dcc				SP57_X_POS_L            = $AF0DCC
=$af0dcd				SP57_X_POS_H            = $AF0DCD
=$af0dce				SP57_Y_POS_L            = $AF0DCE
=$af0dcf				SP57_Y_POS_H            = $AF0DCF
=$af0dd0				SP58_CONTROL_REG        = $AF0DD0
=$af0dd1				SP58_ADDY_PTR_L         = $AF0DD1
=$af0dd2				SP58_ADDY_PTR_M         = $AF0DD2
=$af0dd3				SP58_ADDY_PTR_H         = $AF0DD3
=$af0dd4				SP58_X_POS_L            = $AF0DD4
=$af0dd5				SP58_X_POS_H            = $AF0DD5
=$af0dd6				SP58_Y_POS_L            = $AF0DD6
=$af0dd7				SP58_Y_POS_H            = $AF0DD7
=$af0dd8				SP59_CONTROL_REG        = $AF0DD8
=$af0dd9				SP59_ADDY_PTR_L         = $AF0DD9
=$af0dda				SP59_ADDY_PTR_M         = $AF0DDA
=$af0ddb				SP59_ADDY_PTR_H         = $AF0DDB
=$af0ddc				SP59_X_POS_L            = $AF0DDC
=$af0ddd				SP59_X_POS_H            = $AF0DDD
=$af0dde				SP59_Y_POS_L            = $AF0DDE
=$af0ddf				SP59_Y_POS_H            = $AF0DDF
=$af0de0				SP60_CONTROL_REG        = $AF0DE0
=$af0de1				SP60_ADDY_PTR_L         = $AF0DE1
=$af0de2				SP60_ADDY_PTR_M         = $AF0DE2
=$af0de3				SP60_ADDY_PTR_H         = $AF0DE3
=$af0de4				SP60_X_POS_L            = $AF0DE4
=$af0de5				SP60_X_POS_H            = $AF0DE5
=$af0de6				SP60_Y_POS_L            = $AF0DE6
=$af0de7				SP60_Y_POS_H            = $AF0DE7
=$af0de8				SP61_CONTROL_REG        = $AF0DE8
=$af0de9				SP61_ADDY_PTR_L         = $AF0DE9
=$af0dea				SP61_ADDY_PTR_M         = $AF0DEA
=$af0deb				SP61_ADDY_PTR_H         = $AF0DEB
=$af0dec				SP61_X_POS_L            = $AF0DEC
=$af0ded				SP61_X_POS_H            = $AF0DED
=$af0dee				SP61_Y_POS_L            = $AF0DEE
=$af0def				SP61_Y_POS_H            = $AF0DEF
=$af0df0				SP62_CONTROL_REG        = $AF0DF0
=$af0df1				SP62_ADDY_PTR_L         = $AF0DF1
=$af0df2				SP62_ADDY_PTR_M         = $AF0DF2
=$af0df3				SP62_ADDY_PTR_H         = $AF0DF3
=$af0df4				SP62_X_POS_L            = $AF0DF4
=$af0df5				SP62_X_POS_H            = $AF0DF5
=$af0df6				SP62_Y_POS_L            = $AF0DF6
=$af0df7				SP62_Y_POS_H            = $AF0DF7
=$af0df8				SP63_CONTROL_REG        = $AF0DF8
=$af0df9				SP63_ADDY_PTR_L         = $AF0DF9
=$af0dfa				SP63_ADDY_PTR_M         = $AF0DFA
=$af0dfb				SP63_ADDY_PTR_H         = $AF0DFB
=$af0dfc				SP63_X_POS_L            = $AF0DFC
=$af0dfd				SP63_X_POS_H            = $AF0DFD
=$af0dfe				SP63_Y_POS_L            = $AF0DFE
=$af0dff				SP63_Y_POS_H            = $AF0DFF

;******  Return to file: src\C256/vicky_def.s


;******  Return to file: src\C256/mmap_c256.s

=$00					BASIC_BANK = $00            ; Memory bank for default purposes
=$004c00				IOBUF = $004C00             ; A buffer for I/O operations
=$004d00				ARRIDXBUF = $004D00         ; The array index buffer used for array references
=$004e00				TEMPBUF = $004E00           ; Temporary buffer for string processing, etc.
=$004f00				INPUTBUF = $004F00          ; Starting address of the line input buffer (one page)
=$005000				RETURN_BOT = $005000        ; Starting address of the return stack
=$005fff				RETURN_TOP = $005FFF        ; Ending address of the return stack
=$006000				ARGUMENT_BOT = $006000      ; Starting address of the argument stack
=$006fff				ARGUMENT_TOP = $006FFF      ; Ending address of the argument stack
=$007000				OPERATOR_BOT = $007000      ; Starting address of the operator stack
=$007fff				OPERATOR_TOP = $007FFF      ; Ending address of the operator stack
=$b00000				VRAM = $B00000              ; Start of video RAM
=$010000				LOADBLOCK = $010000         ; File loading will start here
=$360000				BASIC_BOT := $360000         ; Starting point for BASIC programs
=$37ffff				HEAP_TOP := $37FFFF          ; Starting point of the heap
=$160000				BASIC_BOT := $160000         ; Starting point for BASIC programs
=$17ffff				HEAP_TOP := $17FFFF          ; Starting point of the heap

;******  Return to file: src\memorymap.s

=$00ffe6				VBRK = $00FFE6          ; Vector for the native-mode BRK vector
=$1ad000				DATA_BLOCK = *
=$000800				GLOBAL_VARS = *
>0800					BIP         .dword ?    ; Pointer to the current byte in the current BASIC program
>0804					BIPPREV     .dword ?    ; Pointer to the previous bytein the current BASIC program
>0808					INDEX       .dword ?    ; A temporary pointer
>080c					SCRATCH     .dword ?    ; A temporary scratch variable
>0810					SCRATCH2    .dword ?    ; A temporary scratch variable
>0814					            .word  ?	; Need a few more bits for BCD conversion
>0816					STRPTR      .dword ?    ; A temporary pointer for strings
>081a					CURLINE     .dword ?    ; Pointer to the current input line needing tokenization
>081e					CURTOKLEN   .byte ?     ; Length of the text of the current token
>081f					ARGUMENTSP  .word ?     ; Pointer to the top of the argument stack
>0821					OPERATORSP  .word ?     ; Pointer to the top of the operator stack
>0823					ARGUMENT1   .dword ?    ; Argument 1 for expression calculations
>0827					ARGTYPE1    .byte ?     ; Type code for argument 1 (integer, float, string)
>0828					SIGN1       .byte ?     ; Temporary sign marker for argument 1
>0829					ARGUMENT2   .dword ?    ; Argument 2 for expression calculations
>082d					ARGTYPE2    .byte ?     ; Type code for argument 2 (integer, float, string)
>082e					SIGN2       .byte ?     ; Temporary sign marker for argument 1
>082f					JMP16PTR    .word ?     ; Pointer for 16-bit indirect jumps (within BASIC816's code base)
>0831					GOSUBDEPTH  .word ?     ; Number of GOSUBs on the stack
>0833					RETURNSP    .word ?     ; Pointer to the top of the return stack
>0835					SKIPNEST    .byte ?     ; Flag to indicate if token seeking should respect nesting (MSB set if so)
>0836					NESTING     .byte ?     ; Counter of the depth of lexical nesting for FOR/NEXT, DO/LOOP
>0837					TARGETTOK   .byte ?     ; When searching for a token, TARGETTOK is the token to find
>0838					DATABIP     .dword ?    ; Pointer to the next data element for READ statements
>083c					DATALINE    .dword ?    ; Pointer to the current line for a DATA statement
>0840					SAVEBIP     .dword ?    ; Spot to save BIP temporarily
>0844					SAVELINE    .dword ?    ; Spot to save CURLINE temporarily
=$000848				MONITOR_VARS = *
>0848					MCMDADDR    .long ?     ;3 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
>084b					MCMP_TEXT   .long ?     ;3 Bytes Address of symbol being evaluated for COMPARE routine
>084e					MCMP_LEN    .word ?     ;2 Bytes Length of symbol being evaluated for COMPARE routine
>0850					MCMD        .long ?     ;3 Bytes Address of the current command/function string
>0853					MCMD_LEN    .word ?     ;2 Bytes Length of the current command/function string
>0855					MARG1       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command
>0859					MARG2       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>085d					MARG3       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0861					MARG4       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0865					MARG5       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0869					MARG6       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>086d					MARG7       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0871					MARG8       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0875					MARG9       .dword ?    ;4 Bytes First command argument.
>0879					MARG_LEN    .byte ?     ;1 Byte count of the number of arguments passed
>087a					MCURSOR     .dword ?    ;4 Bytes Pointer to the current memory location for disassembly, memory dump, etc.
>087e					MLINEBUF    .fill 17    ;17 Byte buffer for dumping memory (TODO: could be moved to a general string scratch area)
>088f					MCOUNT      .long ?     ;2 Byte counter
>0892					MTEMP       .dword ?    ;4 Bytes of temporary space
>0896					MCPUSTAT    .byte ?     ;1 Byte to represent what the disassembler thinks the processor MX bits are
>0897					MADDR_MODE  .byte ?     ;1 Byte address mode found by the assembler
>0898					MPARSEDNUM  .dword ?    ;4 Bytes to store a parsed number
>089c					MMNEMONIC   .word ?     ;2 Byte address of mnemonic found by the assembler
>089e					MTEMPPTR    .dword ?    ;4 Byte temporary pointer
>08a2					MJUMPINST   .byte ?     ;1 Byte JSL opcode
>08a3					MJUMPADDR   .long ?     ;3 Byte address for JSL
=$000823				MANTISSA1 = ARGUMENT1
=$000826				EXPONENT1 = ARGUMENT1+3

;******  Return to file: src\basic816.s


;******  Processing file: src\macros.s


;******  Return to file: src\basic816.s

.1a0000	5c 14 89 1a	jmp $1a8914	COLDBOOT        JML START               ; Entry point to boot up BASIC from scratch
.1a0004	5c 26 6f 1a	jmp $1a6f26	MONITOR         JML IMONITOR            ; Entry point to the machine language monitor
.1a0008	5c c0 26 1a	jmp $1a26c0	READLINE        JML IREADLINE           ; Wait for the user to enter a line of text (for programming input)
.1a000c	5c 49 02 1a	jmp $1a0249	SCRCOPYLINE     JML ISCRCPYLINE         ; Copy the line on the screen the user just input to INPUTBUF
.1a0010	5c 58 00 1a	jmp $1a0058	INPUTLINE       JML IINPUTLINE          ; Read a single line of text from the user, and copy it to TEMPBUF (for INPUT statement)
.1a0014	5c b8 00 1a	jmp $1a00b8	GETKEY          JML IGETKEY             ; Wait for a keypress by the user and return the ASCII code in A
.1a0018	5c 5e 03 1a	jmp $1a035e	PRINTC          JML IPRINTC             ; Print the character in A to the console
.1a001c	5c ed 01 1a	jmp $1a01ed	SHOWCURSOR      JML ISHOWCURSOR         ; Set cursor visibility: A=0, hide... A<>0, show.
.1a0020	5c 08 02 1a	jmp $1a0208	CURSORXY        JML ICURSORXY           ; Set the position of the cursor to (X, Y)
.1a0024	5c 0f 02 1a	jmp $1a020f	CLSCREEN        JML ICLSCREEN           ; Clear the screen

;******  Processing file: src\bios.s


;******  Processing file: src\membuffers.s

>08a6					OBUFFER     .long ?     ; Pointer to the current text memory buffer for output
>08a9					OBUFFSIZE   .word ?     ; Maximum size of output text memory buffer
>08ab					OBUFFIDX    .word ?     ; Index into the current output buffer
>08ad					IBUFFER     .long ?     ; Pointer to the current text memory buffer for input
>08b0					IBUFFSIZE   .word ?     ; Number of bytes written to the buffer
>08b2					IBUFFIDX    .word ?     ; Index into the current input buffer (next available character)
.1a0028					OBUFF_PUTC
.1a0028	0b		phd		                PHD
.1a0029	08		php		                PHP
.1a002a	08		php		            PHP
.1a002b	c2 20		rep #$20	            REP #$20
.1a002d	48		pha		            PHA
.1a002e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0031	5b		tcd		            TCD
.1a0032	68		pla		            PLA
.1a0033	28		plp		            PLP
.1a0034	e2 20		sep #$20	            SEP #$20
.1a0036	85 b5		sta $08b5	                STA SAVE_A
.1a0038	c2 20		rep #$20	            REP #$20
.1a003a	a5 a6		lda $08a6	                LDA OBUFFER
.1a003c	d0 06		bne $1a0044	                BNE has_buffer
.1a003e	e2 20		sep #$20	            SEP #$20
.1a0040	a5 a8		lda $08a8	                LDA OBUFFER+2
.1a0042	f0 11		beq $1a0055	                BEQ done
.1a0044					has_buffer
.1a0044	c2 10		rep #$10	            REP #$10
.1a0046	a4 ab		ldy $08ab	                LDY OBUFFIDX        ; Check to make sure there is room
.1a0048	c4 a9		cpy $08a9	                CPY OBUFFSIZE
.1a004a	f0 09		beq $1a0055	                BEQ done            ; If not, exit silently
.1a004c	e2 20		sep #$20	            SEP #$20
.1a004e	a5 b5		lda $08b5	                LDA SAVE_A
.1a0050	97 a6		sta [$08a6],y	                STA [OBUFFER],Y     ; Write the character to the buffer
.1a0052	c8		iny		                INY                 ; Increment the index
.1a0053	84 ab		sty $08ab	                STY OBUFFIDX
.1a0055	28		plp		done            PLP
.1a0056	2b		pld		                PLD
.1a0057	60		rts		            RTS

;******  Return to file: src\bios.s


;******  Processing file: src\C256/io_c256.s


;******  Processing file: src\C256/kernel_c256.s

=$00104c				FK_GETCHW           = $00104c ; Get a character from the input channel. Waits until data received. A=0 and Carry=1 if no data is wating
=$001018				FK_PUTC             = $001018 ; Print a character to the currently selected channel
=$00101c				FK_PUTS             = $00101C ; Print a string to the currently selected channel
=$001080				FK_PRINTAH          = $001080 ; Prints hex value in A. Printed value is 2 wide if M flag is 1, 4 wide if M=0
=$001084				FK_LOCATE           = $001084 ; Reposition the cursor to row Y column X
=$001078				FK_IPRINTH          = $001078 ; Print a HEX string
=$00103c				FK_SETOUT           = $00103c ; Select an output channel
=$00112c				FK_SETSIZES         = $00112C ; Set the text screen size variables based on the border and screen resolution.
=$0010f0				FK_OPEN             = $0010F0 ; open a file for reading/writing/creating
=$0010f4				FK_CREATE           = $0010F4 ; create a new file
=$0010f8				FK_CLOSE            = $0010F8 ; close a file (make sure last cluster is written)
=$0010fc				FK_WRITE            = $0010FC ; write the current cluster to the file
=$001100				FK_READ             = $001100 ; read the next cluster from the file
=$001104				FK_DELETE           = $001104 ; delete a file / directory
=$001108				FK_DIROPEN          = $001108 ; open a directory and seek the first directory entry
=$00110c				FK_DIRNEXT          = $00110C ; seek to the next directory of an open directory
=$001110				FK_DIRREAD          = $001110 ; Read the directory entry for the specified file
=$001114				FK_DIRWRITE         = $001114 ; Write any changes in the current directory cluster back to the drive
=$001118				FK_LOAD             = $001118 ; load a binary file into memory, supports multiple file formats
=$00111c				FK_SAVE             = $00111C ; Save memory to a binary file
=$001124				FK_RUN              = $001124 ; Load and run an executable binary file
=$001130				FK_COPY             = $001130 ; Copy a file
=$001120				FK_CMDBLOCK         = $001120 ; Send a command to a block device
=$00113c				FK_TESTBREAK        = $00113C ; Check if BREAK was pressed recently by the user (C is set if true, clear if false)
=0					CHAN_CONSOLE = 0
=1					CHAN_COM1 = 1
=2					CHAN_COM2 = 2

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/RTC_inc.s

=$af0800				RTC_SEC       = $AF0800 ;Seconds Register
=$af0801				RTC_SEC_ALARM = $AF0801 ;Seconds Alarm Register
=$af0802				RTC_MIN       = $AF0802 ;Minutes Register
=$af0803				RTC_MIN_ALARM = $AF0803 ;Minutes Alarm Register
=$af0804				RTC_HRS       = $AF0804 ;Hours Register
=$af0805				RTC_HRS_ALARM = $AF0805 ;Hours Alarm Register
=$af0806				RTC_DAY       = $AF0806 ;Day Register
=$af0807				RTC_DAY_ALARM = $AF0807 ;Day Alarm Register
=$af0808				RTC_DOW       = $AF0808 ;Day of Week Register
=$af0809				RTC_MONTH     = $AF0809 ;Month Register
=$af080a				RTC_YEAR      = $AF080A ;Year Register
=$af080b				RTC_RATES     = $AF080B ;Rates Register
=$af080c				RTC_ENABLE    = $AF080C ;Enables Register
=$af080d				RTC_FLAGS     = $AF080D ;Flags Register
=$af080e				RTC_CTRL      = $AF080E ;Control Register
=$af080f				RTC_CENTURY   = $AF080F ;Century Register

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/keyboard.s


;******  Processing file: src\C256/keyboard_def.s

=$af1064				STATUS_PORT 	        =	$AF1064
=$af1060				KBD_OUT_BUF 	        =	$AF1060
=$af1060				KBD_INPT_BUF	        = $AF1060
=$af1064				KBD_CMD_BUF		        = $AF1064
=$af1060				KBD_DATA_BUF	        = $AF1060
=$af1060				PORT_A			          =	$AF1060
=$af1061				PORT_B			          =	$AF1061
=$01					OUT_BUF_FULL  =	$01
=$02					INPT_BUF_FULL	=	$02
=$04					SYS_FLAG		  =	$04
=$08					CMD_DATA		  =	$08
=$10					KEYBD_INH     =	$10
=$20					TRANS_TMOUT	  =	$20
=$40					RCV_TMOUT		  =	$40
=$80					PARITY_EVEN		=	$80
=$10					INH_KEYBOARD	=	$10
=$ae					KBD_ENA			  =	$AE
=$ad					KBD_DIS			  =	$AD
=$f1					KB_MENU			  =	$F1
=$f4					KB_ENABLE		  =	$F4
=$f7					KB_MAKEBREAK  =	$F7
=$fe					KB_ECHO			  =	$FE
=$ff					KB_RESET		  =	$FF
=$ed					KB_LED_CMD		=	$ED
=$aa					KB_OK			    =	$AA
=$fa					KB_ACK			  =	$FA
=$ff					KB_OVERRUN		=	$FF
=$fe					KB_RESEND		  =	$FE
=$f0					KB_BREAK		  =	$F0
=$10					KB_FA			    =	$10
=$20					KB_FE			    =	$20
=$40					KB_PR_LED		  =	$40
=$01					KB_SCROLL_LOCK      = $01
=$02					KB_NUM_LOCK         = $02
=$04					KB_CAPS_LOCK        = $04
=2					ANSI_IN_INS = 2     ; ANSI input code for INSERT
=3					ANSI_IN_DEL = 3     ; ANSI input code for DELETE

;******  Return to file: src\C256/keyboard.s

.1a0058					IINPUTLINE
.1a0058	08		php		                PHP
.1a0059	c2 10		rep #$10	            REP #$10
.1a005b	e2 20		sep #$20	            SEP #$20
.1a005d	a9 01		lda #$01	                LDA #1              ; Show the cursor
.1a005f	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a0062	a2 00 00	ldx #$0000	                LDX #0
.1a0065	a9 00		lda #$00	                LDA #0
.1a0067	9f 00 4c 00	sta $004c00,x	zero_loop       STA @lIOBUF,X
.1a006b	e8		inx		                INX
.1a006c	e0 00 01	cpx #$0100	                CPX #$100
.1a006f	d0 f6		bne $1a0067	                BNE zero_loop
.1a0071	a2 00 00	ldx #$0000	                LDX #0
.1a0074					getchar
.1a0074	20 14 00	jsr $1a0014	            JSR GETKEY
.1a0077	c9 0d		cmp #$0d	                CMP #CHAR_CR        ; Got a CR?
.1a0079	d0 03		bne $1a007e	                BNE not_cr
.1a007b	4c b1 00	jmp $1a00b1	                JMP endofline       ; Yes: we're done
.1a007e					not_cr
.1a007e	c9 08		cmp #$08	not_right       CMP #CHAR_BS        ; Is it a backspace?
.1a0080	d0 1a		bne $1a009c	                BNE not_bs
.1a0082	e0 00 00	cpx #$0000	                CPX #0              ; Are we at the beginning of the line?
.1a0085	f0 ed		beq $1a0074	                BEQ getchar         ; yes: ignore the backspace
.1a0087	da		phx		                PHX                 ; Save the cursor position
.1a0088	bf 01 4c 00	lda $004c01,x	clr_loop        LDA @lIOBUF+1,X     ; Get the character above
.1a008c	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the current position
.1a0090	f0 06		beq $1a0098	                BEQ done_clr        ; If we copied a NUL, we're done copying
.1a0092	e8		inx		                INX                 ; Otherwise, keep copying down
.1a0093	e0 ff 00	cpx #$00ff	                CPX #$FF            ; Until we're at the end of the buffer
.1a0096	d0 f0		bne $1a0088	                BNE clr_loop
.1a0098	fa		plx		done_clr        PLX                 ; Restore the cursor position
.1a0099	ca		dex		                DEX                 ; No: move the cursor left
.1a009a	80 0e		bra $1a00aa	                BRA print_bs        ; And print the backspace
.1a009c	c9 20		cmp #$20	not_bs          CMP #$20            ; Is it in range 00 -- 1F?
.1a009e	90 d4		bcc $1a0074	                BLT getchar         ; Yes: ignore it
.1a00a0	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the input buffer
.1a00a4	e8		inx		                INX                 ; Move the cursor forward
.1a00a5					echo
.1a00a5	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00a8	80 ca		bra $1a0074	                BRA getchar         ; And get another...
.1a00aa	a9 08		lda #$08	print_bs        LDA #CHAR_BS        ; Backspace character...
.1a00ac	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00af	80 c3		bra $1a0074	                BRA getchar         ; And get another...
.1a00b1	a9 00		lda #$00	endofline       LDA #0              ; Hide the cursor
.1a00b3	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a00b6	28		plp		                PLP
.1a00b7	60		rts		            RTS
.1a00b8					IGETKEY
.1a00b8	da		phx		                PHX
.1a00b9	5a		phy		                PHY
.1a00ba	8b		phb		                PHB
.1a00bb	0b		phd		                PHD
.1a00bc	08		php		                PHP
.1a00bd	22 4c 10 00	jsl $00104c	                JSL FK_GETCHW
.1a00c1	28		plp		                PLP
.1a00c2	2b		pld		                PLD
.1a00c3	ab		plb		                PLB
.1a00c4	7a		ply		                PLY
.1a00c5	fa		plx		                PLX
.1a00c6	60		rts		            RTS
=0					GK_ST_INIT = 0      ; GETKEYE state: initial
=1					GK_ST_ESC = 1       ; GETKEYE state: ESC seen
=2					GK_ST_CSI = 2       ; GETKEYE state: CSI "ESC[" seen
=3					GK_ST_CODE = 3      ; GETKEYE state: We're at the command code in the sequence
=4					GK_ST_MODS = 4      ; GETKEYE state: We're at the modifier code in the sequence
.1a00c7					SEND_ANSI
.1a00c7	08		php		                PHP
.1a00c8	e2 30		sep #$30	            SEP #$30
.1a00ca	48		pha		                PHA
.1a00cb	a9 1b		lda #$1b	                LDA #CHAR_ESC           ; Print ESC
.1a00cd	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00d0	a9 5b		lda #$5b	                LDA #'['                ; Print [
.1a00d2	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00d5	68		pla		                PLA                     ; Print the command code
.1a00d6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00d9	28		plp		                PLP
.1a00da	60		rts		            RTS
.1a00db					GETKEYE
.1a00db	0b		phd		                PHD
.1a00dc	8b		phb		                PHB
.1a00dd	08		php		                PHP
.1a00de	08		php		            PHP
.1a00df	e2 20		sep #$20	            SEP #$20
.1a00e1	48		pha		            PHA
.1a00e2	a9 00		lda #$00	            LDA #0
.1a00e4	48		pha		            PHA
.1a00e5	ab		plb		            PLB
.1a00e6	68		pla		            PLA
.1a00e7	28		plp		            PLP
.1a00e8	08		php		            PHP
.1a00e9	c2 20		rep #$20	            REP #$20
.1a00eb	48		pha		            PHA
.1a00ec	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a00ef	5b		tcd		            TCD
.1a00f0	68		pla		            PLA
.1a00f1	28		plp		            PLP
.1a00f2					locals
>0001					l_character     .byte ?                 ; The character returned by the input stream
>0002					l_state         .byte ?                 ; Current state of the input parser
>0003					l_code          .byte ?                 ; Code number for any escaped input sequence
>0004					l_modifiers     .byte ?                 ; Modifier bit field for any escaped input sequence
.1a00f2	c2 20		rep #$20	            REP #$20
.1a00f4	3b		tsc		            TSC
.1a00f5	38		sec		            SEC
.1a00f6	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.1a00f9	1b		tcs		            TCS
.1a00fa	e2 20		sep #$20	            SEP #$20
.1a00fc	a9 00		lda #$00	get_reset       LDA #0                  ; Initialize state, code, and modifiers
.1a00fe	83 02		sta $02,s	                STA l_state
.1a0100	83 03		sta $03,s	                STA l_code
.1a0102	83 04		sta $04,s	                STA l_modifiers
.1a0104					loop
.1a0104	20 14 00	jsr $1a0014	            JSR GETKEY
.1a0107	c9 00		cmp #$00	                CMP #0                  ; Is it 0?
.1a0109	f0 f9		beq $1a0104	                BEQ loop                ; Yes: keep waiting
.1a010b	83 01		sta $01,s	                STA l_character         ; Save the character
.1a010d	a3 02		lda $02,s	                LDA l_state             ; What is the current state?
.1a010f	d0 35		bne $1a0146	                BNE chk_st_esc
.1a0111	a3 01		lda $01,s	                LDA l_character         ; Get the character back
.1a0113	c9 08		cmp #$08	                CMP #CHAR_BS            ; Is it a backspace?
.1a0115	d0 0a		bne $1a0121	                BNE not_bs
.1a0117	20 18 00	jsr $1a0018	            JSR PRINTC
.1a011a	a9 50		lda #$50	                LDA #'P'
.1a011c	20 c7 00	jsr $1a00c7	            JSR SEND_ANSI
.1a011f	80 e3		bra $1a0104	                BRA loop                ; And keep waiting for a keypress
.1a0121	c9 0d		cmp #$0d	not_bs          CMP #CHAR_CR            ; Is it a carriage return?
.1a0123	f0 0a		beq $1a012f	                BEQ send                ; Yes: print and return it
.1a0125	c9 1b		cmp #$1b	                CMP #CHAR_ESC           ; Is it ESC?
.1a0127	d0 06		bne $1a012f	                BNE send                ; No: just print it out
.1a0129	a9 01		lda #$01	                LDA #GK_ST_ESC          ; Yes: move to the ESC state
.1a012b	83 02		sta $02,s	                STA l_state
.1a012d	80 d5		bra $1a0104	                BRA loop                ; And get the next character in the sequence
.1a012f					send
.1a012f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a0132	a3 01		lda $01,s	done            LDA l_character         ; Save the character so we can return it
.1a0134	85 0c		sta $080c	                STA SCRATCH
.1a0136	c2 20		rep #$20	            REP #$20
.1a0138	3b		tsc		            TSC
.1a0139	18		clc		            CLC
.1a013a	69 04 00	adc #$0004	            ADC #SIZE(locals)
.1a013d	1b		tcs		            TCS
.1a013e	e2 20		sep #$20	            SEP #$20
.1a0140	a5 0c		lda $080c	                LDA SCRATCH             ; Restore the character we're returning
.1a0142	28		plp		                PLP
.1a0143	2b		pld		                PLD
.1a0144	ab		plb		                PLB
.1a0145	60		rts		            RTS
.1a0146	c9 01		cmp #$01	chk_st_esc      CMP #GK_ST_ESC          ; Are we in the ESC state?
.1a0148	d0 10		bne $1a015a	                BNE chk_st_csi          ; No: check to see if we're in CSI state
.1a014a	a3 01		lda $01,s	                LDA l_character         ; Get the character
.1a014c	c9 5b		cmp #$5b	                CMP #'['                ; Is it "["?
.1a014e	f0 03		beq $1a0153	                BEQ go_st_csi           ; Yes: go to the CSI state
.1a0150	82 a9 ff	brl $1a00fc	                BRL get_reset           ; Reset the state machine and keep reading characters
.1a0153	a9 02		lda #$02	go_st_csi       LDA #GK_ST_CSI          ; Yes: move to the CSI state
.1a0155	83 02		sta $02,s	                STA l_state
.1a0157	82 aa ff	brl $1a0104	                BRL loop
.1a015a	c9 02		cmp #$02	chk_st_csi      CMP #GK_ST_CSI          ; Are we in the CSI state?
.1a015c	d0 29		bne $1a0187	                BNE chk_st_code         ; No: check to see if we're in the code state
.1a015e	a3 01		lda $01,s	                LDA l_character         ; Check the character
.1a0160	c9 41		cmp #$41	                CMP #'A'                ; Is it in 'A'..'D'?
.1a0162	90 0c		bcc $1a0170	                BLT not_letter
.1a0164	c9 45		cmp #$45	                CMP #'D'+1
.1a0166	b0 08		bcs $1a0170	                BGE not_letter
.1a0168	a3 01		lda $01,s	                LDA l_character         ; Yes: it's a cursor key, send the sequence to the screen
.1a016a	20 c7 00	jsr $1a00c7	            JSR SEND_ANSI
.1a016d	82 8c ff	brl $1a00fc	                BRL get_reset           ; Reset the state machine and keep reading characters
.1a0170	c9 30		cmp #$30	not_letter      CMP #'0'                ; Is it in range '0'..'9'?
.1a0172	90 10		bcc $1a0184	                BLT not_csi_digit
.1a0174	c9 3a		cmp #$3a	                CMP #'9'+1
.1a0176	b0 0c		bcs $1a0184	                BGE not_csi_digit       ; No: handle it being invalid
.1a0178	38		sec		                SEC                     ; Yes: convert to a value
.1a0179	e9 30		sbc #$30	                SBC #'0'
.1a017b	83 03		sta $03,s	                STA l_code              ; And save it to the code variable
.1a017d	a9 03		lda #$03	                LDA #GK_ST_CODE         ; Move to the CODE state
.1a017f	83 02		sta $02,s	                STA l_state
.1a0181	82 80 ff	brl $1a0104	                BRL loop
.1a0184	82 75 ff	brl $1a00fc	not_csi_digit   BRL get_reset           ; Bad sequence: reset and keep reading characters
.1a0187	c9 03		cmp #$03	chk_st_code     CMP #GK_ST_CODE         ; Is it the  state?
.1a0189	d0 a7		bne $1a0132	                BNE done
.1a018b	a3 01		lda $01,s	                LDA l_character         ; Check the character
.1a018d	c9 30		cmp #$30	                CMP #'0'                ; Is it in the range '0'..'9'
.1a018f	90 1b		bcc $1a01ac	                BLT not_digits_2
.1a0191	c9 3a		cmp #$3a	                CMP #'9'+1
.1a0193	b0 17		bcs $1a01ac	                BGE not_digits_2
.1a0195	a3 03		lda $03,s	                LDA l_code              ; Multiply l_code by 2
.1a0197	0a		asl a		                ASL A
.1a0198	85 0c		sta $080c	                STA SCRATCH
.1a019a	0a		asl a		                ASL A                   ; Multiply l_code by 8
.1a019b	0a		asl a		                ASL A
.1a019c	18		clc		                CLC
.1a019d	65 0c		adc $080c	                ADC SCRATCH             ; Add to get l_code * 10
.1a019f	a3 01		lda $01,s	                LDA l_character         ; Convert the digit to a number
.1a01a1	38		sec		                SEC
.1a01a2	e9 30		sbc #$30	                SBC #'0'
.1a01a4	18		clc		                CLC                     ; And add to l_code
.1a01a5	65 0c		adc $080c	                ADC SCRATCH
.1a01a7	83 03		sta $03,s	                STA l_code
.1a01a9	82 58 ff	brl $1a0104	                BRL loop                ; And keep processing the sequence
.1a01ac					not_digits_2
.1a01ac	c9 7e		cmp #$7e	not_semi        CMP #'~'                ; No: Is it the tilda?
.1a01ae	f0 03		beq $1a01b3	                BEQ end_sequence        ; Yes: we've gotten the end of the sequence
.1a01b0	82 49 ff	brl $1a00fc	                BRL get_reset           ; No: we've got a bad sequence... for now just reset and keep looping
.1a01b3	a3 03		lda $03,s	end_sequence    LDA l_code              ; Get the code
.1a01b5	c9 02		cmp #$02	                CMP #ANSI_IN_INS        ; Is it INSERT?
.1a01b7	f0 07		beq $1a01c0	                BEQ do_ins              ; Yes: process the insert
.1a01b9	c9 03		cmp #$03	                CMP #ANSI_IN_DEL        ; Is it DELETE?
.1a01bb	f0 07		beq $1a01c4	                BEQ do_del              ; Yes: process the delete
.1a01bd	82 3c ff	brl $1a00fc	                BRL get_reset           ; Code is not one we handle, just return
.1a01c0	a9 40		lda #$40	do_ins          LDA #'@'                ; Send the ANSI ICH command
.1a01c2	80 02		bra $1a01c6	                BRA snd_ansi
.1a01c4	a9 50		lda #$50	do_del          LDA #'P'                ; Send the ANSI DCH command
.1a01c6					snd_ansi
.1a01c6	20 c7 00	jsr $1a00c7	            JSR SEND_ANSI
.1a01c9	82 30 ff	brl $1a00fc	                BRL get_reset           ; Reset and keep getting characters

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/screen.s

.1a01cc					ENSURETEXT
.1a01cc	08		php		            PHP
.1a01cd	e2 20		sep #$20	            SEP #$20
.1a01cf	af 00 00 af	lda $af0000	            LDA @l MASTER_CTRL_REG_L            ; Get the current display mode
.1a01d3	89 3c		bit #$3c	            BIT #Mstr_Ctrl_Graph_Mode_En | Mstr_Ctrl_Bitmap_En | Mstr_Ctrl_TileMap_En | Mstr_Ctrl_Sprite_En
.1a01d5	f0 08		beq $1a01df	            BEQ textonly                        ; If not, make sure text is enabled
.1a01d7					overlay
.1a01d7	09 03		ora #$03	            ORA #Mstr_Ctrl_Text_Mode_En | Mstr_Ctrl_Text_Overlay
.1a01d9	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.1a01dd	80 0c		bra $1a01eb	            BRA done
.1a01df					textonly
.1a01df	09 01		ora #$01	            ORA #Mstr_Ctrl_Text_Mode_En
.1a01e1	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.1a01e5	a9 00		lda #$00	            LDA #CHAN_CONSOLE                   ; Make sure we're writing to the main screen
.1a01e7	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.1a01eb	28		plp		done        PLP
.1a01ec	60		rts		            RTS
.1a01ed					ISHOWCURSOR
.1a01ed	08		php		            PHP
.1a01ee	e2 20		sep #$20	            SEP #$20
.1a01f0	c9 00		cmp #$00	            CMP #0
.1a01f2	f0 08		beq $1a01fc	            BEQ hide
.1a01f4	af 10 00 af	lda $af0010	show        LDA @lVKY_TXT_CURSOR_CTRL_REG
.1a01f8	09 01		ora #$01	            ORA #Vky_Cursor_Enable
.1a01fa	80 06		bra $1a0202	            BRA setit
.1a01fc	af 10 00 af	lda $af0010	hide        LDA @lVKY_TXT_CURSOR_CTRL_REG
.1a0200	29 fe		and #$fe	            AND #~Vky_Cursor_Enable
.1a0202	8f 10 00 af	sta $af0010	setit       STA @lVKY_TXT_CURSOR_CTRL_REG
.1a0206	28		plp		            PLP
.1a0207	60		rts		            RTS
.1a0208					ICURSORXY
.1a0208	08		php		            PHP
.1a0209	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.1a020d	28		plp		            PLP
.1a020e	60		rts		            RTS
.1a020f					ICLSCREEN
.1a020f	48		pha		            PHA
.1a0210	da		phx		            PHX
.1a0211	5a		phy		            PHY
.1a0212	0b		phd		            PHD
.1a0213	08		php		            PHP
.1a0214	e2 20		sep #$20	            SEP #$20
.1a0216	c2 10		rep #$10	            REP #$10
.1a0218	a2 00 00	ldx #$0000	            LDX #0
.1a021b	a9 20		lda #$20	loop        LDA #$20
.1a021d	9f 00 a0 af	sta $afa000,x	            STA @lCS_TEXT_MEM_PTR,X     ; Write a space in the text cell
.1a0221	af 1e 00 00	lda $00001e	            LDA @lCURCOLOR
.1a0225	9f 00 c0 af	sta $afc000,x	            STA @lCS_COLOR_MEM_PTR,X    ; Set the color to green on black
.1a0229	e8		inx		            INX                         ; Move to the next character cell
.1a022a	e0 00 20	cpx #$2000	            CPX #$2000
.1a022d	d0 ec		bne $1a021b	            BNE loop
.1a022f	08		php		            PHP
.1a0230	c2 20		rep #$20	            REP #$20
.1a0232	48		pha		            PHA
.1a0233	a9 00 00	lda #$0000	            LDA #0
.1a0236	5b		tcd		            TCD
.1a0237	68		pla		            PLA
.1a0238	28		plp		            PLP
.1a0239	a2 00 00	ldx #$0000	            LDX #0                      ; Set cursor to upper-left corner
.1a023c	a0 00 00	ldy #$0000	            LDY #0
.1a023f	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.1a0243	28		plp		            PLP
.1a0244	2b		pld		            PLD
.1a0245	7a		ply		            PLY
.1a0246	fa		plx		            PLX
.1a0247	68		pla		            PLA
.1a0248	60		rts		            RTS
.1a0249					ISCRCPYLINE
.1a0249	da		phx		            PHX
.1a024a	5a		phy		            PHY
.1a024b	0b		phd		            PHD
.1a024c	08		php		            PHP
.1a024d	08		php		            PHP
.1a024e	c2 20		rep #$20	            REP #$20
.1a0250	48		pha		            PHA
.1a0251	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0254	5b		tcd		            TCD
.1a0255	68		pla		            PLA
.1a0256	28		plp		            PLP
.1a0257	c2 30		rep #$30	            REP #$30
.1a0259	af 0c 00 00	lda $00000c	            LDA @lSCREENBEGIN       ; Set INDEX to the first byte of the text screen
.1a025d	85 08		sta $0808	            STA INDEX
.1a025f	e2 20		sep #$20	            SEP #$20
.1a0261	af 0e 00 00	lda $00000e	            LDA @lSCREENBEGIN+2
.1a0265	c2 20		rep #$20	            REP #$20
.1a0267	29 ff 00	and #$00ff	            AND #$00FF
.1a026a	85 0a		sta $080a	            STA INDEX+2
.1a026c	af 11 00 00	lda $000011	            LDA @lCOLS_PER_LINE     ; Calculate the offset to the current line
.1a0270	8f 08 01 00	sta $000108	            STA @lM1_OPERAND_A
.1a0274	af 1c 00 00	lda $00001c	            LDA @lCURSORY
.1a0278	3a		dec a		            DEC A
.1a0279	8f 0a 01 00	sta $00010a	            STA @lM1_OPERAND_B
.1a027d	18		clc		            CLC                     ; And add it to INDEX
.1a027e	a5 08		lda $0808	            LDA INDEX
.1a0280	6f 0c 01 00	adc $00010c	            ADC @lM1_RESULT
.1a0284	85 08		sta $0808	            STA INDEX
.1a0286	a5 0a		lda $080a	            LDA INDEX+2
.1a0288	69 00 00	adc #$0000	            ADC #0
.1a028b	85 0a		sta $080a	            STA INDEX+2
.1a028d	e2 20		sep #$20	            SEP #$20
.1a028f	af 0f 00 00	lda $00000f	            LDA @lCOLS_VISIBLE
.1a0293	85 8f		sta $088f	            STA MCOUNT
.1a0295	a0 00 00	ldy #$0000	            LDY #0
.1a0298	a2 00 00	ldx #$0000	            LDX #0
.1a029b	b7 08		lda [$0808],y	copy_loop   LDA [INDEX],Y           ; Copy a byte from the screen to the input buffer
.1a029d	9f 00 4f 00	sta $004f00,x	            STA @lINPUTBUF,X
.1a02a1	e8		inx		            INX
.1a02a2	c8		iny		            INY
.1a02a3	c4 8f		cpy $088f	            CPY MCOUNT
.1a02a5	d0 f4		bne $1a029b	            BNE copy_loop
.1a02a7	ca		dex		            DEX
.1a02a8	bf 00 4f 00	lda $004f00,x	trim_loop   LDA @lINPUTBUF,X        ; Replace spaces at the end with NULLs
.1a02ac	c9 20		cmp #$20	            CMP #CHAR_SP
.1a02ae	d0 09		bne $1a02b9	            BNE done
.1a02b0	a9 00		lda #$00	            LDA #0
.1a02b2	9f 00 4f 00	sta $004f00,x	            STA @lINPUTBUF,X
.1a02b6	ca		dex		            DEX
.1a02b7	10 ef		bpl $1a02a8	            BPL trim_loop
.1a02b9	28		plp		done        PLP
.1a02ba	2b		pld		            PLD
.1a02bb	7a		ply		            PLY
.1a02bc	fa		plx		            PLX
.1a02bd	60		rts		            RTS

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/gabe_defs.s

=$afe880				GABE_MSTR_CTRL      = $AFE880
=$01					GABE_CTRL_PWR_LED   = $01     ; Controls the LED in the Front of the case (Next to the reset button)
=$02					GABE_CTRL_SDC_LED   = $02     ; Controls the LED in the Front of the Case (Next to SDCard)
=$04					GABE_CTRL_STS_LED0  = $04     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$08					GABE_CTRL_STS_LED1  = $08     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$10					GABE_CTRL_BUZZER    = $10     ; Controls the Buzzer
=$80					GABE_CTRL_WRM_RST   = $80     ; Warm Reset (needs to Setup other registers)
=$afe881				GABE_LED_FLASH_CTRL = $AFE881  ; Flashing LED Control
=$01					GABE_LED0_FLASH_CTRL = $01     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$02					GABE_LED1_FLASH_CTRL = $02     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED1 to manually control)
=$10					GABE_LD0_FLASH_FRQ0   = $10     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$20					GABE_LD0_FLASH_FRQ1   = $20     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$40					GABE_LD1_FLASH_FRQ0   = $40     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$80					GABE_LD1_FLASH_FRQ1   = $80     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$afe882				GABE_RST_AUTH0      = $AFE882 ; Must Contain the BYTE $AD for Reset to Activate
=$afe883				GABE_RST_AUTH1      = $AFE883 ; Must Contain the BYTE $DE for Reset to Activate
=$afe884				GABE_RNG_DAT_LO     = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_DAT_HI     = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe884				GABE_RNG_SEED_LO    = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_SEED_HI    = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe886				GABE_RNG_STAT       = $AFE886 ;
=$80					GABE_RNG_LFSR_DONE  = $80     ; indicates that Output = SEED Database
=$afe886				GABE_RNG_CTRL       = $AFE886 ;
=$01					GABE_RNG_CTRL_EN    = $01     ; Enable the LFSR BLOCK_LEN
=$02					GABE_RNG_CTRL_DV    = $02     ; After Setting the Seed Value, Toggle that Bit for it be registered
=$afe887				GABE_SYS_STAT       = $AFE887 ;
=$01					GABE_SYS_STAT_MID0  = $01     ; Machine ID -- LSB
=$02					GABE_SYS_STAT_MID1  = $02     ; Machine ID --
=$04					GABE_SYS_STAT_MID2  = $04     ; Machine ID -- MSB
=$10					GABE_SYS_STAT_EXP   = $10     ; if Zero, there is an Expansion Card Preset
=$40					GABE_SYS_STAT_CPUA  = $40     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$80					GABE_SYS_STAT_CPUX  = $80     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$afe88a				GABE_SUBVERSION_LO  = $AFE88A
=$afe88b				GABE_SUBVERSION_HI  = $AFE88B
=$afe88c				GABE_VERSION_LO     = $AFE88C
=$afe88d				GABE_VERSION_HI     = $AFE88D
=$afe88e				GABE_MODEL_LO       = $AFE88E
=$afe88f				GABE_MODEL_HI       = $AFE88F

;******  Return to file: src\C256/io_c256.s

=32					BORDER_WIDTH = 32               ; The width of the border (when it is on)
=72					TEXT_COLS_WB = 72               ; Number of columns of text with the border enabled
=52					TEXT_ROWS_WB = 52               ; Number of rows of text with the border enabled
=80					TEXT_COLS_WOB = 80              ; Number of columns of text with no border enabled
=60					TEXT_ROWS_WOB = 60              ; Number of rows of text with no border enabled
.1a02be					INITIO
.1a02be	e2 20		sep #$20	            SEP #$20
.1a02c0	a2 00 00	ldx #$0000	            LDX #0              ; Clear all the sprite control shadow registers
.1a02c3	a9 00		lda #$00	            LDA #0
.1a02c5	9f 18 f0 1a	sta $1af018,x	sp_loop     STA GS_SP_CONTROL,X
.1a02c9	e8		inx		            INX
.1a02ca	e0 40 00	cpx #$0040	            CPX #SP_MAX
.1a02cd	d0 f6		bne $1a02c5	            BNE sp_loop
.1a02cf	a9 80		lda #$80	            LDA #DEV_SCREEN
.1a02d1	8f b4 08 00	sta $0008b4	            STA @lBCONSOLE
.1a02d5	e2 20		sep #$20	            SEP #$20
.1a02d7	a9 00		lda #$00	            LDA #0                  ; Clear the lock key flags
.1a02d9	8f 89 0f 00	sta $000f89	            STA @lKEYBOARD_LOCKS
.1a02dd	a9 00		lda #$00	            LDA #0
.1a02df	8f 00 02 af	sta $af0200	            STA @l TL0_CONTROL_REG
.1a02e3	8f 0c 02 af	sta $af020c	            STA @l TL1_CONTROL_REG
.1a02e7	8f 18 02 af	sta $af0218	            STA @l TL2_CONTROL_REG
.1a02eb	8f 24 02 af	sta $af0224	            STA @l TL3_CONTROL_REG
.1a02ef					done
.1a02ef	60		rts		            RTS
.1a02f0					SCREEN_PUTC
.1a02f0	08		php		            PHP
.1a02f1	e2 20		sep #$20	            SEP #$20
.1a02f3	48		pha		            PHA
.1a02f4	48		pha		            PHA
.1a02f5	a9 00		lda #$00	            LDA #CHAN_CONSOLE       ; Switch to the console device
.1a02f7	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.1a02fb	68		pla		            PLA
.1a02fc	22 18 10 00	jsl $001018	            JSL FK_PUTC
.1a0300	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.1a0304	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.1a0306	d0 f8		bne $1a0300	            BNE loop                ; Yes: wait until it's released
.1a0308	68		pla		            PLA
.1a0309	28		plp		            PLP
.1a030a	60		rts		            RTS
.1a030b					UART_PUTC
.1a030b	08		php		            PHP
.1a030c	e2 20		sep #$20	            SEP #$20
.1a030e	48		pha		            PHA
.1a030f	48		pha		            PHA
.1a0310	a9 01		lda #$01	            LDA #CHAN_COM1          ; Switch to COM1
.1a0312	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.1a0316	68		pla		            PLA
.1a0317	22 18 10 00	jsl $001018	            JSL FK_PUTC
.1a031b	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.1a031f	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.1a0321	d0 f8		bne $1a031b	            BNE loop                ; Yes: wait until it's released
.1a0323	68		pla		            PLA
.1a0324	28		plp		            PLP
.1a0325	60		rts		            RTS
.1a0326					PRINTCR
.1a0326	08		php		            PHP
.1a0327	c2 20		rep #$20	            REP #$20
.1a0329	48		pha		            PHA
.1a032a	e2 20		sep #$20	            SEP #$20
.1a032c	a9 0d		lda #$0d	            LDA #CHAR_CR
.1a032e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a0331	c2 20		rep #$20	            REP #$20
.1a0333	68		pla		            PLA
.1a0334	28		plp		            PLP
.1a0335	60		rts		            RTS
.1a0336					PRINTH
.1a0336	08		php		            PHP
.1a0337	22 78 10 00	jsl $001078	            JSL FK_IPRINTH
.1a033b	28		plp		            PLP
.1a033c	60		rts		            RTS

;******  Return to file: src\bios.s

=10					LINES_PER_PAGE = 10     ; The number of lines to print on a page before pausing
=$80					DEV_SCREEN = $80        ; Use the screen and keyboard for the console device
=$40					DEV_UART = $40          ; Use UART for console device
=$20					DEV_BUFFER = $20        ; Use the current text memory buffer for output or input
>08b4					BCONSOLE    .byte ?     ; Device for BASIC console
>08b5					SAVE_A      .byte ?     ; Save spot for the A register
>08b6					LINECOUNT   .byte ?     ; Counter for new lines to support pagination
.1a033d					PAGINATE
.1a033d	08		php		            PHP
.1a033e	0b		phd		            PHD
.1a033f	08		php		            PHP
.1a0340	c2 20		rep #$20	            REP #$20
.1a0342	48		pha		            PHA
.1a0343	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0346	5b		tcd		            TCD
.1a0347	68		pla		            PLA
.1a0348	28		plp		            PLP
.1a0349	e2 20		sep #$20	            SEP #$20
.1a034b	a5 b6		lda $08b6	            LDA LINECOUNT           ; Check the line count
.1a034d	1a		inc a		            INC A
.1a034e	85 b6		sta $08b6	            STA LINECOUNT
.1a0350	cf 13 00 00	cmp $000013	            CMP @l LINES_VISIBLE
.1a0354	90 05		bcc $1a035b	            BLT done                ; If < limit, just return
.1a0356	20 14 00	jsr $1a0014	            JSR GETKEY
.1a0359	64 b6		stz $08b6	            STZ LINECOUNT           ; And reset the line count
.1a035b	2b		pld		done        PLD
.1a035c	28		plp		            PLP
.1a035d	60		rts		            RTS
.1a035e					IPRINTC
.1a035e	da		phx		            PHX
.1a035f	5a		phy		            PHY
.1a0360	0b		phd		            PHD
.1a0361	08		php		            PHP
.1a0362	08		php		            PHP
.1a0363	c2 20		rep #$20	            REP #$20
.1a0365	48		pha		            PHA
.1a0366	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0369	5b		tcd		            TCD
.1a036a	68		pla		            PLA
.1a036b	28		plp		            PLP
.1a036c	e2 20		sep #$20	            SEP #$20
.1a036e	c2 10		rep #$10	            REP #$10
.1a0370	8f b5 08 00	sta $0008b5	            STA @lSAVE_A
.1a0374	af b4 08 00	lda $0008b4	chk_out     LDA @lBCONSOLE      ; Check to see if we should send to an output buffer
.1a0378	29 20		and #$20	            AND #DEV_BUFFER
.1a037a	f0 07		beq $1a0383	            BEQ check_scrn      ; No... move on to the hardware screen
.1a037c	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.1a0380	20 28 00	jsr $1a0028	            JSR OBUFF_PUTC
.1a0383	af b4 08 00	lda $0008b4	check_scrn  LDA @lBCONSOLE
.1a0387	29 80		and #$80	            AND #DEV_SCREEN     ; Check to see if the screen is selected
.1a0389	f0 07		beq $1a0392	            BEQ send_uart
.1a038b	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.1a038f	20 f0 02	jsr $1a02f0	            JSR SCREEN_PUTC
.1a0392	af b4 08 00	lda $0008b4	send_uart   LDA @lBCONSOLE
.1a0396	29 40		and #$40	            AND #DEV_UART       ; Check to see if the UART is active
.1a0398	f0 14		beq $1a03ae	            BEQ done
.1a039a	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.1a039e	20 0b 03	jsr $1a030b	            JSR UART_PUTC
.1a03a1	af b5 08 00	lda $0008b5	            LDA @lSAVE_A        ; If sending a CR to the serial port
.1a03a5	c9 0d		cmp #$0d	            CMP #CHAR_CR
.1a03a7	d0 05		bne $1a03ae	            BNE done
.1a03a9	a9 0a		lda #$0a	            LDA #CHAR_LF        ; Send a linefeed after
.1a03ab	20 0b 03	jsr $1a030b	            JSR UART_PUTC
.1a03ae	28		plp		done        PLP
.1a03af	2b		pld		            PLD
.1a03b0	7a		ply		            PLY
.1a03b1	fa		plx		            PLX
.1a03b2	60		rts		            RTS
.1a03b3					PRINTS
.1a03b3	08		php		            PHP
.1a03b4	e2 20		sep #$20	            SEP #$20
.1a03b6	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.1a03b9	f0 06		beq $1a03c1	            BEQ done
.1a03bb	20 18 00	jsr $1a0018	            JSR PRINTC
.1a03be	e8		inx		            INX
.1a03bf	80 f5		bra $1a03b6	            BRA loop
.1a03c1	28		plp		done        PLP
.1a03c2	60		rts		            RTS
.1a03c3					PRHEXW
.1a03c3	08		php		            PHP
.1a03c4	c2 20		rep #$20	            REP #$20
.1a03c6	48		pha		            PHA
.1a03c7	48		pha		            PHA
.1a03c8	4a		lsr a		            LSR A
.1a03c9	4a		lsr a		            LSR A
.1a03ca	4a		lsr a		            LSR A
.1a03cb	4a		lsr a		            LSR A
.1a03cc	4a		lsr a		            LSR A
.1a03cd	4a		lsr a		            LSR A
.1a03ce	4a		lsr a		            LSR A
.1a03cf	4a		lsr a		            LSR A
.1a03d0	20 dd 03	jsr $1a03dd	            JSR PRHEXB
.1a03d3	68		pla		            PLA
.1a03d4	29 ff 00	and #$00ff	            AND #$00FF
.1a03d7	20 dd 03	jsr $1a03dd	            JSR PRHEXB
.1a03da	68		pla		            PLA
.1a03db	28		plp		            PLP
.1a03dc	60		rts		            RTS
.1a03dd					PRHEXB
.1a03dd	08		php		            PHP
.1a03de	c2 20		rep #$20	            REP #$20
.1a03e0	48		pha		            PHA
.1a03e1	e2 20		sep #$20	            SEP #$20
.1a03e3	48		pha		            PHA
.1a03e4	4a		lsr a		            LSR A
.1a03e5	4a		lsr a		            LSR A
.1a03e6	4a		lsr a		            LSR A
.1a03e7	4a		lsr a		            LSR A
.1a03e8	20 f4 03	jsr $1a03f4	            JSR PRHEXN
.1a03eb	68		pla		            PLA
.1a03ec	20 f4 03	jsr $1a03f4	            JSR PRHEXN
.1a03ef	c2 20		rep #$20	            REP #$20
.1a03f1	68		pla		            PLA
.1a03f2	28		plp		            PLP
.1a03f3	60		rts		            RTS
.1a03f4					PRHEXN
.1a03f4	08		php		            PHP
.1a03f5	c2 30		rep #$30	            REP #$30
.1a03f7	da		phx		            PHX
.1a03f8	29 0f 00	and #$000f	            AND #$000F
.1a03fb	aa		tax		            TAX
.1a03fc	bf 00 d0 1a	lda $1ad000,x	            LDA @lHEXDIGITS,X
.1a0400	20 18 00	jsr $1a0018	            JSR PRINTC
.1a0403	fa		plx		            PLX
.1a0404	28		plp		            PLP
.1a0405	60		rts		            RTS
>1ad000	30 31 32 33 34 35 36 37		HEXDIGITS   .text "0123456789ABCDEF"
>1ad008	38 39 41 42 43 44 45 46

;******  Return to file: src\basic816.s


;******  Processing file: src\utilities.s

.1a0406					PRTRACE
.1a0406	08		php		            PHP
.1a0407	c2 30		rep #$30	            REP #$30
.1a0409	48		pha		            PHA
.1a040a	da		phx		            PHX
.1a040b	5a		phy		            PHY
.1a040c	8b		phb		            PHB
.1a040d	0b		phd		            PHD
.1a040e	c2 30		rep #$30	            REP #$30
.1a0410	a3 0b		lda $0b,s	            LDA 11,S        ; Get the return address
.1a0412	18		clc		calc_addr   CLC
.1a0413	69 03 00	adc #$0003	            ADC #3          ; Add 3 to skip over the following branch
.1a0416	aa		tax		            TAX
.1a0417	e2 20		sep #$20	            SEP #$20
.1a0419	a9 1a		lda #$1a	            LDA #`PRTRACE
.1a041b	48		pha		            PHA
.1a041c	ab		plb		            PLB
.1a041d	bd 00 00	lda $0000,x	pr_loop     LDA #0,B,X
.1a0420	f0 06		beq $1a0428	            BEQ done
.1a0422	20 f0 02	jsr $1a02f0	            JSR SCREEN_PUTC
.1a0425	e8		inx		            INX
.1a0426	80 f5		bra $1a041d	            BRA pr_loop
.1a0428					done
.1a0428	c2 30		rep #$30	            REP #$30
.1a042a	2b		pld		            PLD
.1a042b	ab		plb		            PLB
.1a042c	7a		ply		            PLY
.1a042d	fa		plx		            PLX
.1a042e	68		pla		            PLA
.1a042f	28		plp		            PLP
.1a0430	60		rts		            RTS
.1a0431					ISALPHA
.1a0431	08		php		            PHP
.1a0432	e2 20		sep #$20	            SEP #$20
.1a0434	c9 5b		cmp #$5b	            CMP #'Z'+1
.1a0436	b0 04		bcs $1a043c	            BGE not_upper
.1a0438	c9 41		cmp #$41	            CMP #'A'
.1a043a	b0 0b		bcs $1a0447	            BGE is_alpha
.1a043c	c9 7b		cmp #$7b	not_upper   CMP #'z'+1
.1a043e	b0 04		bcs $1a0444	            BGE not_alpha
.1a0440	c9 61		cmp #$61	            CMP #'a'
.1a0442	b0 03		bcs $1a0447	            BGE is_alpha
.1a0444					not_alpha
.1a0444	28		plp		            PLP
.1a0445	18		clc		            CLC
.1a0446	60		rts		            RTS
.1a0447					is_alpha
.1a0447	28		plp		            PLP
.1a0448	38		sec		            SEC
.1a0449	60		rts		            RTS
.1a044a					ISNUMERAL
.1a044a	08		php		            PHP
.1a044b	e2 20		sep #$20	            SEP #$20
.1a044d	c9 3a		cmp #$3a	            CMP #'9'+1
.1a044f	b0 04		bcs $1a0455	            BGE ret_false
.1a0451	c9 30		cmp #$30	            CMP #'0'
.1a0453	b0 03		bcs $1a0458	            BGE ret_true
.1a0455	28		plp		ret_false   PLP
.1a0456	18		clc		            CLC
.1a0457	60		rts		            RTS
.1a0458	28		plp		ret_true    PLP
.1a0459	38		sec		            SEC
.1a045a	60		rts		            RTS
.1a045b					ISHEX
.1a045b	08		php		            PHP
.1a045c	e2 20		sep #$20	            SEP #$20
.1a045e	c9 3a		cmp #$3a	            CMP #'9'+1
.1a0460	b0 04		bcs $1a0466	            BGE chk_lca2f
.1a0462	c9 30		cmp #$30	            CMP #'0'
.1a0464	b0 13		bcs $1a0479	            BGE ret_true
.1a0466	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.1a0468	b0 04		bcs $1a046e	            BGE chk_uca2f
.1a046a	c9 61		cmp #$61	            CMP #'a'
.1a046c	b0 0b		bcs $1a0479	            BGE ret_true
.1a046e	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.1a0470	b0 04		bcs $1a0476	            BGE ret_false
.1a0472	c9 41		cmp #$41	            CMP #'A'
.1a0474	b0 03		bcs $1a0479	            BGE ret_true
.1a0476	28		plp		ret_false   PLP
.1a0477	18		clc		            CLC
.1a0478	60		rts		            RTS
.1a0479	28		plp		ret_true    PLP
.1a047a	38		sec		            SEC
.1a047b	60		rts		            RTS
.1a047c					HEX2BIN
.1a047c	08		php		            PHP
.1a047d	e2 20		sep #$20	            SEP #$20
.1a047f	c9 3a		cmp #$3a	            CMP #'9'+1          ; Check to see if '0'..'9'
.1a0481	b0 04		bcs $1a0487	            BGE chk_lca2f
.1a0483	c9 30		cmp #$30	            CMP #'0'
.1a0485	b0 12		bcs $1a0499	            BGE conv_09         ; Yes: convert it
.1a0487	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.1a0489	b0 04		bcs $1a048f	            BGE chk_uca2f
.1a048b	c9 61		cmp #$61	            CMP #'a'
.1a048d	b0 0f		bcs $1a049e	            BGE conv_lcaf
.1a048f	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.1a0491	b0 04		bcs $1a0497	            BGE done
.1a0493	c9 41		cmp #$41	            CMP #'A'
.1a0495	b0 09		bcs $1a04a0	            BGE conv_ucaf
.1a0497	28		plp		done        PLP
.1a0498	60		rts		            RTS
.1a0499	38		sec		conv_09     SEC                 ; Convert digits '0'..'9'
.1a049a	e9 30		sbc #$30	            SBC #'0'
.1a049c	80 f9		bra $1a0497	            BRA done
.1a049e	29 df		and #$df	conv_lcaf   AND #%11011111      ; Convert to upper case
.1a04a0	38		sec		conv_ucaf   SEC
.1a04a1	e9 37		sbc #$37	            SBC #'A'-10         ; Convert 'A'..'F'
.1a04a3	80 f2		bra $1a0497	            BRA done
.1a04a5					TOUPPERA
.1a04a5	08		php		            PHP
.1a04a6	e2 20		sep #$20	            SEP #$20
.1a04a8	c9 7b		cmp #$7b	            CMP #'z'+1
.1a04aa	b0 06		bcs $1a04b2	            BCS done
.1a04ac	c9 61		cmp #$61	            CMP #'a'
.1a04ae	90 02		bcc $1a04b2	            BCC done
.1a04b0	29 df		and #$df	            AND #%11011111
.1a04b2	28		plp		done        PLP
.1a04b3	60		rts		            RTS
.1a04b4					TOUPPER
.1a04b4	08		php		            PHP
.1a04b5	e2 20		sep #$20	            SEP #$20
.1a04b7	c2 10		rep #$10	            REP #$10
.1a04b9	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.1a04bc	f0 09		beq $1a04c7	            BEQ done
.1a04be	20 a5 04	jsr $1a04a5	            JSR TOUPPERA
.1a04c1	9d 00 00	sta $0000,x	            STA #0,B,X
.1a04c4	e8		inx		continue    INX
.1a04c5	80 f2		bra $1a04b9	            BRA loop
.1a04c7	28		plp		done        PLP
.1a04c8	60		rts		            RTS
.1a04c9					MULINT10
.1a04c9	08		php		                PHP
.1a04ca	0b		phd		                PHD
.1a04cb	08		php		            PHP
.1a04cc	c2 20		rep #$20	            REP #$20
.1a04ce	48		pha		            PHA
.1a04cf	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a04d2	5b		tcd		            TCD
.1a04d3	68		pla		            PLA
.1a04d4	28		plp		            PLP
.1a04d5	c2 20		rep #$20	            REP #$20
.1a04d7	48		pha		                PHA
.1a04d8	06 23		asl $0823	                ASL ARGUMENT1           ; 7 -- 20 -- 74
.1a04da	26 25		rol $0825	                ROL ARGUMENT1+2         ; 7
.1a04dc	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.1a04de	85 0c		sta $080c	                STA SCRATCH             ; 4
.1a04e0	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.1a04e2	85 0e		sta $080e	                STA SCRATCH+2           ; 4
.1a04e4	06 0c		asl $080c	                ASL SCRATCH             ; 7 -- 28
.1a04e6	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.1a04e8	06 0c		asl $080c	                ASL SCRATCH             ; 7
.1a04ea	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.1a04ec	18		clc		                CLC                     ; 2 -- 26
.1a04ed	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.1a04ef	65 0c		adc $080c	                ADC SCRATCH             ; 4
.1a04f1	85 23		sta $0823	                STA ARGUMENT1           ; 4
.1a04f3	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.1a04f5	65 0e		adc $080e	                ADC SCRATCH+2           ; 4
.1a04f7	85 25		sta $0825	                STA ARGUMENT1+2         ; 4
.1a04f9	68		pla		                PLA
.1a04fa	2b		pld		                PLD
.1a04fb	28		plp		                PLP
.1a04fc	60		rts		            RTS
.1a04fd					DIVINT10
.1a04fd	08		php		                PHP
.1a04fe	0b		phd		                PHD
.1a04ff	08		php		            PHP
.1a0500	c2 20		rep #$20	            REP #$20
.1a0502	48		pha		            PHA
.1a0503	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0506	5b		tcd		            TCD
.1a0507	68		pla		            PLA
.1a0508	28		plp		            PLP
.1a0509	c2 20		rep #$20	            REP #$20
.1a050b	a5 23		lda $0823	                LDA ARGUMENT1
.1a050d	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.1a0511	a9 0a 00	lda #$000a	                LDA #10
.1a0514	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.1a0518	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.1a051c	85 23		sta $0823	                STA ARGUMENT1
.1a051e	64 25		stz $0825	                STZ ARGUMENT1+2
.1a0520	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.1a0524	85 29		sta $0829	                STA ARGUMENT2
.1a0526	64 2b		stz $082b	                STZ ARGUMENT2+2
.1a0528	e2 20		sep #$20	            SEP #$20
.1a052a	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a052c	85 27		sta $0827	                STA ARGTYPE1
.1a052e	85 2d		sta $082d	                STA ARGTYPE2
.1a0530	2b		pld		                PLD
.1a0531	28		plp		                PLP
.1a0532	60		rts		            RTS
.1a0533					DIVINT100
.1a0533	08		php		                PHP
.1a0534	0b		phd		                PHD
.1a0535	08		php		            PHP
.1a0536	c2 20		rep #$20	            REP #$20
.1a0538	48		pha		            PHA
.1a0539	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a053c	5b		tcd		            TCD
.1a053d	68		pla		            PLA
.1a053e	28		plp		            PLP
.1a053f	c2 20		rep #$20	            REP #$20
.1a0541	a5 23		lda $0823	                LDA ARGUMENT1
.1a0543	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.1a0547	a9 64 00	lda #$0064	                LDA #100
.1a054a	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.1a054e	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.1a0552	85 23		sta $0823	                STA ARGUMENT1
.1a0554	64 25		stz $0825	                STZ ARGUMENT1+2
.1a0556	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.1a055a	85 29		sta $0829	                STA ARGUMENT2
.1a055c	64 2b		stz $082b	                STZ ARGUMENT2+2
.1a055e	e2 20		sep #$20	            SEP #$20
.1a0560	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a0562	85 27		sta $0827	                STA ARGTYPE1
.1a0564	85 2d		sta $082d	                STA ARGTYPE2
.1a0566	2b		pld		                PLD
.1a0567	28		plp		                PLP
.1a0568	60		rts		            RTS
.1a0569					IS_ARG1_Z
.1a0569	08		php		                PHP
.1a056a	c2 20		rep #$20	            REP #$20
.1a056c	a5 23		lda $0823	                LDA ARGUMENT1
.1a056e	d0 08		bne $1a0578	                BNE return_false
.1a0570	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a0572	d0 04		bne $1a0578	                BNE return_false
.1a0574	28		plp		return_true     PLP
.1a0575	e2 02		sep #$02	                SEP #$02        ; Set Z
.1a0577	60		rts		            RTS
.1a0578	28		plp		return_false    PLP
.1a0579	c2 02		rep #$02	                REP #$02        ; Clear Z
.1a057b	60		rts		            RTS
.1a057c					SET_TRUE
.1a057c	08		php		                PHP
.1a057d	c2 30		rep #$30	            REP #$30
.1a057f	a9 ff ff	lda #$ffff	                LDA #$FFFF
.1a0582	85 23		sta $0823	                STA ARGUMENT1
.1a0584	85 25		sta $0825	                STA ARGUMENT1+2
.1a0586	e2 20		sep #$20	            SEP #$20
.1a0588	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a058a	85 27		sta $0827	                STA ARGTYPE1
.1a058c	28		plp		                PLP
.1a058d	60		rts		            RTS
.1a058e					SET_FALSE
.1a058e	08		php		                PHP
.1a058f	c2 30		rep #$30	            REP #$30
.1a0591	a9 00 00	lda #$0000	                LDA #0
.1a0594	85 23		sta $0823	                STA ARGUMENT1
.1a0596	85 25		sta $0825	                STA ARGUMENT1+2
.1a0598	e2 20		sep #$20	            SEP #$20
.1a059a	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a059c	85 27		sta $0827	                STA ARGTYPE1
.1a059e	28		plp		                PLP
.1a059f	60		rts		            RTS
.1a05a0					ASS_ARG1_INT
.1a05a0	08		php		                PHP
.1a05a1	e2 20		sep #$20	            SEP #$20
.1a05a3	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.1a05a5	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a05a7	f0 07		beq $1a05b0	                BEQ done                ; If so: just return
.1a05a9	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.1a05ab	d0 05		bne $1a05b2	                BNE TYPE_ERR            ; If not: throw an error
.1a05ad	20 ac 5a	jsr $1a5aac	            JSR FTOI
.1a05b0	28		plp		done            PLP
.1a05b1	60		rts		            RTS
.1a05b2					TYPE_ERR
.1a05b2	08		php		            PHP
.1a05b3	c2 20		rep #$20	            REP #$20
.1a05b5	48		pha		            PHA
.1a05b6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a05b9	5b		tcd		            TCD
.1a05ba	68		pla		            PLA
.1a05bb	28		plp		            PLP
.1a05bc	e2 20		sep #$20	            SEP #$20
.1a05be	a9 04		lda #$04	            LDA #ERR_TYPE
.1a05c0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a05c4	c2 20		rep #$20	            REP #$20
.1a05c6	29 ff 00	and #$00ff	            AND #$00FF
.1a05c9	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a05cc	e2 20		sep #$20	            SEP #$20
.1a05ce	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a05d1					ASS_ARG2_INT
.1a05d1	08		php		                PHP
.1a05d2	e2 20		sep #$20	            SEP #$20
.1a05d4	a5 2d		lda $082d	                LDA ARGTYPE2                ; Verify that the type is INTEGER
.1a05d6	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a05d8	f0 37		beq $1a0611	                BEQ done                    ; If so: just return
.1a05da	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; Check if it's a float
.1a05dc	d0 35		bne $1a0613	                BNE TYPE_ERR                ; If not: throw an error
.1a05de	c2 20		rep #$20	            REP #$20
.1a05e0	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a05e2	48		pha		            PHA
.1a05e3	a5 23		lda $0823	            LDA ARGUMENT1
.1a05e5	48		pha		            PHA
.1a05e6	c2 20		rep #$20	            REP #$20
.1a05e8	a5 29		lda $0829	            LDA ARGUMENT2
.1a05ea	85 23		sta $0823	            STA ARGUMENT1
.1a05ec	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a05ee	85 25		sta $0825	            STA ARGUMENT1+2
.1a05f0	e2 20		sep #$20	            SEP #$20
.1a05f2	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.1a05f4	85 27		sta $0827	            STA ARGTYPE1
.1a05f6	20 ac 5a	jsr $1a5aac	            JSR FTOI
.1a05f9	c2 20		rep #$20	            REP #$20
.1a05fb	a5 23		lda $0823	            LDA ARGUMENT1
.1a05fd	85 29		sta $0829	            STA ARGUMENT2
.1a05ff	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a0601	85 2b		sta $082b	            STA ARGUMENT2+2
.1a0603	e2 20		sep #$20	            SEP #$20
.1a0605	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a0607	85 2d		sta $082d	            STA ARGTYPE2
.1a0609	c2 20		rep #$20	            REP #$20
.1a060b	68		pla		            PLA
.1a060c	85 23		sta $0823	            STA ARGUMENT1
.1a060e	68		pla		            PLA
.1a060f	85 25		sta $0825	            STA ARGUMENT1+2
.1a0611	28		plp		done            PLP
.1a0612	60		rts		            RTS
.1a0613					TYPE_ERR
.1a0613	08		php		            PHP
.1a0614	c2 20		rep #$20	            REP #$20
.1a0616	48		pha		            PHA
.1a0617	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a061a	5b		tcd		            TCD
.1a061b	68		pla		            PLA
.1a061c	28		plp		            PLP
.1a061d	e2 20		sep #$20	            SEP #$20
.1a061f	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0621	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0625	c2 20		rep #$20	            REP #$20
.1a0627	29 ff 00	and #$00ff	            AND #$00FF
.1a062a	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a062d	e2 20		sep #$20	            SEP #$20
.1a062f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0632					ASS_ARG1_STR
.1a0632	08		php		                PHP
.1a0633	e2 20		sep #$20	            SEP #$20
.1a0635	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is STRING
.1a0637	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a0639	d0 02		bne $1a063d	                BNE TYPE_ERR
.1a063b	28		plp		                PLP
.1a063c	60		rts		            RTS
.1a063d					TYPE_ERR
.1a063d	08		php		            PHP
.1a063e	c2 20		rep #$20	            REP #$20
.1a0640	48		pha		            PHA
.1a0641	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0644	5b		tcd		            TCD
.1a0645	68		pla		            PLA
.1a0646	28		plp		            PLP
.1a0647	e2 20		sep #$20	            SEP #$20
.1a0649	a9 04		lda #$04	            LDA #ERR_TYPE
.1a064b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a064f	c2 20		rep #$20	            REP #$20
.1a0651	29 ff 00	and #$00ff	            AND #$00FF
.1a0654	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a0657	e2 20		sep #$20	            SEP #$20
.1a0659	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a065c					ASS_ARG1_INT16
.1a065c	08		php		                PHP
.1a065d	e2 20		sep #$20	            SEP #$20
.1a065f	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.1a0661	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a0663	f0 07		beq $1a066c	                BEQ check_range         ; If so: check the range
.1a0665	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.1a0667	d0 0b		bne $1a0674	                BNE TYPE_ERR            ; If not: throw an error
.1a0669	20 ac 5a	jsr $1a5aac	            JSR FTOI
.1a066c					check_range
.1a066c	c2 20		rep #$20	            REP #$20
.1a066e	a5 25		lda $0825	                LDA ARGUMENT1+2         ; Validate it is 16-bit
.1a0670	d0 21		bne $1a0693	                BNE range_err
.1a0672	28		plp		                PLP
.1a0673	60		rts		            RTS
.1a0674					TYPE_ERR
.1a0674	08		php		            PHP
.1a0675	c2 20		rep #$20	            REP #$20
.1a0677	48		pha		            PHA
.1a0678	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a067b	5b		tcd		            TCD
.1a067c	68		pla		            PLA
.1a067d	28		plp		            PLP
.1a067e	e2 20		sep #$20	            SEP #$20
.1a0680	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0682	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0686	c2 20		rep #$20	            REP #$20
.1a0688	29 ff 00	and #$00ff	            AND #$00FF
.1a068b	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a068e	e2 20		sep #$20	            SEP #$20
.1a0690	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0693					RANGE_ERR
.1a0693	08		php		            PHP
.1a0694	c2 20		rep #$20	            REP #$20
.1a0696	48		pha		            PHA
.1a0697	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a069a	5b		tcd		            TCD
.1a069b	68		pla		            PLA
.1a069c	28		plp		            PLP
.1a069d	e2 20		sep #$20	            SEP #$20
.1a069f	a9 09		lda #$09	            LDA #ERR_RANGE
.1a06a1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a06a5	c2 20		rep #$20	            REP #$20
.1a06a7	29 ff 00	and #$00ff	            AND #$00FF
.1a06aa	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a06ad	e2 20		sep #$20	            SEP #$20
.1a06af	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a06b2					ASS_ARG1_BYTE
.1a06b2	08		php		                PHP
.1a06b3	e2 20		sep #$20	            SEP #$20
.1a06b5	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.1a06b7	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a06b9	f0 07		beq $1a06c2	                BEQ check_range         ; If so: check the range
.1a06bb	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.1a06bd	d0 11		bne $1a06d0	                BNE TYPE_ERR            ; If not: throw an error
.1a06bf	20 ac 5a	jsr $1a5aac	            JSR FTOI
.1a06c2	a5 26		lda $0826	check_range     LDA ARGUMENT1+3         ; Validate that the value is in byte range
.1a06c4	d0 29		bne $1a06ef	                BNE RANGE_ERR           ; If not... throw a range error
.1a06c6	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a06c8	d0 25		bne $1a06ef	                BNE RANGE_ERR
.1a06ca	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a06cc	d0 21		bne $1a06ef	                BNE RANGE_ERR
.1a06ce	28		plp		                PLP
.1a06cf	60		rts		            RTS
.1a06d0					TYPE_ERR
.1a06d0	08		php		            PHP
.1a06d1	c2 20		rep #$20	            REP #$20
.1a06d3	48		pha		            PHA
.1a06d4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a06d7	5b		tcd		            TCD
.1a06d8	68		pla		            PLA
.1a06d9	28		plp		            PLP
.1a06da	e2 20		sep #$20	            SEP #$20
.1a06dc	a9 04		lda #$04	            LDA #ERR_TYPE
.1a06de	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a06e2	c2 20		rep #$20	            REP #$20
.1a06e4	29 ff 00	and #$00ff	            AND #$00FF
.1a06e7	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a06ea	e2 20		sep #$20	            SEP #$20
.1a06ec	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a06ef					RANGE_ERR
.1a06ef	08		php		            PHP
.1a06f0	c2 20		rep #$20	            REP #$20
.1a06f2	48		pha		            PHA
.1a06f3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a06f6	5b		tcd		            TCD
.1a06f7	68		pla		            PLA
.1a06f8	28		plp		            PLP
.1a06f9	e2 20		sep #$20	            SEP #$20
.1a06fb	a9 09		lda #$09	            LDA #ERR_RANGE
.1a06fd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0701	c2 20		rep #$20	            REP #$20
.1a0703	29 ff 00	and #$00ff	            AND #$00FF
.1a0706	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a0709	e2 20		sep #$20	            SEP #$20
.1a070b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a070e					ASS_ARG1_FLOAT
.1a070e	08		php		                PHP
.1a070f	e2 20		sep #$20	            SEP #$20
.1a0711	a5 27		lda $0827	                LDA ARGTYPE1            ; Check the type
.1a0713	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.1a0715	f0 26		beq $1a073d	                BEQ done                ; Then we're done
.1a0717	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.1a0719	f0 1f		beq $1a073a	                BEQ cast                ; Then cast it to float
.1a071b					type_err
.1a071b	08		php		            PHP
.1a071c	c2 20		rep #$20	            REP #$20
.1a071e	48		pha		            PHA
.1a071f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0722	5b		tcd		            TCD
.1a0723	68		pla		            PLA
.1a0724	28		plp		            PLP
.1a0725	e2 20		sep #$20	            SEP #$20
.1a0727	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0729	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a072d	c2 20		rep #$20	            REP #$20
.1a072f	29 ff 00	and #$00ff	            AND #$00FF
.1a0732	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a0735	e2 20		sep #$20	            SEP #$20
.1a0737	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a073a					cast
.1a073a	20 a6 5a	jsr $1a5aa6	            JSR ITOF
.1a073d	28		plp		done            PLP
.1a073e	60		rts		            RTS
.1a073f					ASS_ARG2_FLOAT
.1a073f	08		php		                PHP
.1a0740	e2 20		sep #$20	            SEP #$20
.1a0742	a5 2d		lda $082d	                LDA ARGTYPE2            ; Check the type
.1a0744	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.1a0746	f0 26		beq $1a076e	                BEQ done                ; Then we're done
.1a0748	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.1a074a	f0 1f		beq $1a076b	                BEQ cast                ; Then cast it to float
.1a074c					type_err
.1a074c	08		php		            PHP
.1a074d	c2 20		rep #$20	            REP #$20
.1a074f	48		pha		            PHA
.1a0750	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0753	5b		tcd		            TCD
.1a0754	68		pla		            PLA
.1a0755	28		plp		            PLP
.1a0756	e2 20		sep #$20	            SEP #$20
.1a0758	a9 04		lda #$04	            LDA #ERR_TYPE
.1a075a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a075e	c2 20		rep #$20	            REP #$20
.1a0760	29 ff 00	and #$00ff	            AND #$00FF
.1a0763	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a0766	e2 20		sep #$20	            SEP #$20
.1a0768	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a076b					cast
.1a076b	20 70 07	jsr $1a0770	            JSR CAST_ARG2_FLOAT
.1a076e	28		plp		done            PLP
.1a076f	60		rts		            RTS
.1a0770					CAST_ARG2_FLOAT
.1a0770	c2 20		rep #$20	            REP #$20
.1a0772	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a0774	48		pha		            PHA
.1a0775	a5 23		lda $0823	            LDA ARGUMENT1
.1a0777	48		pha		            PHA
.1a0778	c2 20		rep #$20	            REP #$20
.1a077a	a5 29		lda $0829	            LDA ARGUMENT2
.1a077c	85 23		sta $0823	            STA ARGUMENT1
.1a077e	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a0780	85 25		sta $0825	            STA ARGUMENT1+2
.1a0782	e2 20		sep #$20	            SEP #$20
.1a0784	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a0786	85 27		sta $0827	            STA ARGTYPE1
.1a0788	20 a6 5a	jsr $1a5aa6	            JSR ITOF
.1a078b	c2 20		rep #$20	            REP #$20
.1a078d	a5 23		lda $0823	            LDA ARGUMENT1
.1a078f	85 29		sta $0829	            STA ARGUMENT2
.1a0791	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a0793	85 2b		sta $082b	            STA ARGUMENT2+2
.1a0795	e2 20		sep #$20	            SEP #$20
.1a0797	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.1a0799	85 2d		sta $082d	            STA ARGTYPE2
.1a079b	c2 20		rep #$20	            REP #$20
.1a079d	68		pla		            PLA
.1a079e	85 23		sta $0823	            STA ARGUMENT1
.1a07a0	68		pla		            PLA
.1a07a1	85 25		sta $0825	            STA ARGUMENT1+2
.1a07a3	60		rts		            RTS
.1a07a4					ASS_ARGS_NUM
.1a07a4	08		php		                PHP
.1a07a5	e2 20		sep #$20	            SEP #$20
.1a07a7	a5 27		lda $0827	                LDA ARGTYPE1                ; Check ARGUMENT1
.1a07a9	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a07ab	f0 23		beq $1a07d0	                BEQ arg1_int
.1a07ad	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.1a07af	f0 2e		beq $1a07df	                BEQ arg1_float
.1a07b1					type_err
.1a07b1	08		php		            PHP
.1a07b2	c2 20		rep #$20	            REP #$20
.1a07b4	48		pha		            PHA
.1a07b5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a07b8	5b		tcd		            TCD
.1a07b9	68		pla		            PLA
.1a07ba	28		plp		            PLP
.1a07bb	e2 20		sep #$20	            SEP #$20
.1a07bd	a9 04		lda #$04	            LDA #ERR_TYPE
.1a07bf	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a07c3	c2 20		rep #$20	            REP #$20
.1a07c5	29 ff 00	and #$00ff	            AND #$00FF
.1a07c8	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a07cb	e2 20		sep #$20	            SEP #$20
.1a07cd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a07d0	a5 2d		lda $082d	arg1_int        LDA ARGTYPE2                ; Check argument 2
.1a07d2	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If integer, we're done
.1a07d4	f0 16		beq $1a07ec	                BEQ done
.1a07d6	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If not float, throw an error
.1a07d8	d0 d7		bne $1a07b1	                BNE type_err
.1a07da	20 a6 5a	jsr $1a5aa6	            JSR ITOF
.1a07dd	80 0d		bra $1a07ec	                BRA done
.1a07df	a5 2d		lda $082d	arg1_float      LDA ARGTYPE2                ; Check argument 2
.1a07e1	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If it's float
.1a07e3	f0 07		beq $1a07ec	                BEQ done                    ; Then we're done
.1a07e5	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If it's not integer
.1a07e7	d0 c8		bne $1a07b1	                BNE type_err                ; Thrown an error
.1a07e9	20 70 07	jsr $1a0770	            JSR CAST_ARG2_FLOAT
.1a07ec					done
.1a07ec	e2 20		sep #$20	            SEP #$20
.1a07ee	a5 27		lda $0827	                LDA ARGTYPE1                ; Return the type code in A
.1a07f0	28		plp		                PLP
.1a07f1	60		rts		            RTS
.1a07f2					ASS_ARGS_NUMSTR
.1a07f2	08		php		                PHP
.1a07f3	e2 20		sep #$20	            SEP #$20
.1a07f5	a5 27		lda $0827	                LDA ARGTYPE1                ; Check to see if ARGUMENT1 is a string
.1a07f7	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a07f9	d0 25		bne $1a0820	                BNE numbers
.1a07fb	a5 2d		lda $082d	                LDA ARGTYPE2                ; If ARGUMENT1 is a string, make sure ARGUMENT2 is
.1a07fd	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a07ff	f0 24		beq $1a0825	                BEQ done
.1a0801					TYPE_ERR
.1a0801	08		php		            PHP
.1a0802	c2 20		rep #$20	            REP #$20
.1a0804	48		pha		            PHA
.1a0805	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0808	5b		tcd		            TCD
.1a0809	68		pla		            PLA
.1a080a	28		plp		            PLP
.1a080b	e2 20		sep #$20	            SEP #$20
.1a080d	a9 04		lda #$04	            LDA #ERR_TYPE
.1a080f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0813	c2 20		rep #$20	            REP #$20
.1a0815	29 ff 00	and #$00ff	            AND #$00FF
.1a0818	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a081b	e2 20		sep #$20	            SEP #$20
.1a081d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0820					numbers
.1a0820	20 a4 07	jsr $1a07a4	            JSR ASS_ARGS_NUM
.1a0823	a5 27		lda $0827	                LDA ARGTYPE1                ; Make sure A is the type
.1a0825	28		plp		done            PLP
.1a0826	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\tokens.s

.0000					TOKEN
>0000					precedence  .byte ?
>0001					length      .byte ?
>0002					name        .word <>?
>0004					eval        .word <>?
>0006					arity       .word <>?
.1a0827					PARSEINT
.1a0827	08		php		            PHP
.1a0828	0b		phd		            PHD
.1a0829	08		php		            PHP
.1a082a	c2 20		rep #$20	            REP #$20
.1a082c	48		pha		            PHA
.1a082d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0830	5b		tcd		            TCD
.1a0831	68		pla		            PLA
.1a0832	28		plp		            PLP
.1a0833	c2 30		rep #$30	            REP #$30
.1a0835	64 23		stz $0823	            STZ ARGUMENT1       ; Default to Not-a-value
.1a0837	64 25		stz $0825	            STZ ARGUMENT1+2
.1a0839	e2 20		sep #$20	            SEP #$20
.1a083b	64 27		stz $0827	            STZ ARGTYPE1
.1a083d	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it starts with '$'
.1a083f	c9 26		cmp #$26	            CMP #'&'
.1a0841	f0 44		beq $1a0887	            BEQ check_hex       ; Yes: parse it as a hexadecimal number
.1a0843					loop
.1a0843	e2 20		sep #$20	            SEP #$20
.1a0845	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.1a0847	20 4a 04	jsr $1a044a	            JSR ISNUMERAL
.1a084a	90 76		bcc $1a08c2	            BCC done            ; No, we're done parsing
.1a084c	20 c9 04	jsr $1a04c9	            JSR MULINT10
.1a084f	38		sec		            SEC                 ; Convert the ASCII code to a number
.1a0850	e9 30		sbc #$30	            SBC #'0'
.1a0852	c2 20		rep #$20	            REP #$20
.1a0854	29 ff 00	and #$00ff	            AND #$00FF
.1a0857	18		clc		            CLC
.1a0858	65 23		adc $0823	            ADC ARGUMENT1
.1a085a	85 23		sta $0823	            STA ARGUMENT1
.1a085c	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a085e	69 00 00	adc #$0000	            ADC #0
.1a0861	85 25		sta $0825	            STA ARGUMENT1+2
.1a0863	20 67 20	jsr $1a2067	            JSR INCBIP
.1a0866	80 db		bra $1a0843	            BRA loop            ; And try to process it
.1a0868					syntaxerr
.1a0868	08		php		            PHP
.1a0869	c2 20		rep #$20	            REP #$20
.1a086b	48		pha		            PHA
.1a086c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a086f	5b		tcd		            TCD
.1a0870	68		pla		            PLA
.1a0871	28		plp		            PLP
.1a0872	e2 20		sep #$20	            SEP #$20
.1a0874	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a0876	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a087a	c2 20		rep #$20	            REP #$20
.1a087c	29 ff 00	and #$00ff	            AND #$00FF
.1a087f	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a0882	e2 20		sep #$20	            SEP #$20
.1a0884	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0887					check_hex
.1a0887	20 67 20	jsr $1a2067	            JSR INCBIP
.1a088a	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.1a088c	c9 48		cmp #$48	            CMP #'H'            ; Is it 'H'?
.1a088e	f0 04		beq $1a0894	            BEQ parse_hex       ; Yes: skip it and parse hex
.1a0890	c9 68		cmp #$68	            CMP #'h'            ; Is it 'h'?
.1a0892	d0 d4		bne $1a0868	            BNE syntaxerr       ; No: throw an error
.1a0894					parse_hex
.1a0894	20 67 20	jsr $1a2067	            JSR INCBIP
.1a0897					hexloop
.1a0897	e2 20		sep #$20	            SEP #$20
.1a0899	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.1a089b	20 5b 04	jsr $1a045b	            JSR ISHEX
.1a089e	90 22		bcc $1a08c2	            BCC done            ; No, we're done parsing
.1a08a0	20 7c 04	jsr $1a047c	            JSR HEX2BIN
.1a08a3	c2 20		rep #$20	            REP #$20
.1a08a5	06 23		asl $0823	            ASL ARGUMENT1
.1a08a7	26 25		rol $0825	            ROL ARGUMENT1+2
.1a08a9	06 23		asl $0823	            ASL ARGUMENT1
.1a08ab	26 25		rol $0825	            ROL ARGUMENT1+2
.1a08ad	06 23		asl $0823	            ASL ARGUMENT1
.1a08af	26 25		rol $0825	            ROL ARGUMENT1+2
.1a08b1	06 23		asl $0823	            ASL ARGUMENT1
.1a08b3	26 25		rol $0825	            ROL ARGUMENT1+2
.1a08b5	29 ff 00	and #$00ff	            AND #$00FF          ; Add binary number to ARGUMENT1
.1a08b8	18		clc		            CLC
.1a08b9	65 23		adc $0823	            ADC ARGUMENT1
.1a08bb	85 23		sta $0823	            STA ARGUMENT1
.1a08bd	20 67 20	jsr $1a2067	            JSR INCBIP
.1a08c0	80 d5		bra $1a0897	            BRA hexloop         ; And try to process it
.1a08c2	2b		pld		done        PLD
.1a08c3	28		plp		            PLP
.1a08c4	60		rts		            RTS
.1a08c5					PREVCHAR
.1a08c5	08		php		            PHP
.1a08c6	c2 30		rep #$30	            REP #$30
.1a08c8	a5 04		lda $0804	            LDA BIPPREV
.1a08ca	f0 1c		beq $1a08e8	            BEQ ret_false
.1a08cc	38		sec		            SEC
.1a08cd	a5 04		lda $0804	            LDA BIPPREV
.1a08cf	e5 1a		sbc $081a	            SBC CURLINE
.1a08d1	a8		tay		            TAY
.1a08d2	e2 20		sep #$20	            SEP #$20
.1a08d4	b7 1a		lda [$081a],y	loop        LDA [CURLINE],Y
.1a08d6	f0 10		beq $1a08e8	            BEQ ret_false
.1a08d8	c9 20		cmp #$20	            CMP #CHAR_SP
.1a08da	f0 06		beq $1a08e2	            BEQ go_back
.1a08dc	c9 09		cmp #$09	            CMP #CHAR_TAB
.1a08de	f0 02		beq $1a08e2	            BEQ go_back
.1a08e0	28		plp		            PLP
.1a08e1	60		rts		            RTS
.1a08e2	88		dey		go_back     DEY
.1a08e3	c0 ff ff	cpy #$ffff	            CPY #$FFFF
.1a08e6	d0 ec		bne $1a08d4	            BNE loop
.1a08e8					ret_false
.1a08e8	a9 00		lda #$00	            LDA #0
.1a08ea	60		rts		            RTS
.1a08eb					TOKENIZE
.1a08eb	08		php		            PHP
.1a08ec	0b		phd		            PHD
.1a08ed	08		php		            PHP
.1a08ee	c2 20		rep #$20	            REP #$20
.1a08f0	48		pha		            PHA
.1a08f1	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a08f4	5b		tcd		            TCD
.1a08f5	68		pla		            PLA
.1a08f6	28		plp		            PLP
.1a08f7	c2 30		rep #$30	            REP #$30
.1a08f9	a5 1a		lda $081a	            LDA CURLINE
.1a08fb	85 00		sta $0800	            STA BIP
.1a08fd	e2 20		sep #$20	            SEP #$20
.1a08ff	a5 1c		lda $081c	            LDA CURLINE+2
.1a0901	85 02		sta $0802	            STA BIP+2
.1a0903	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a0906	a7 00		lda [$0800]	            LDA [BIP]               ; Do we have a numeral?
.1a0908	20 4a 04	jsr $1a044a	            JSR ISNUMERAL
.1a090b	90 0c		bcc $1a0919	            BCC mv_curline          ; No: adjust CURLINE and tokenize
.1a090d	20 27 08	jsr $1a0827	            JSR PARSEINT
.1a0910	c2 20		rep #$20	            REP #$20
.1a0912	a5 23		lda $0823	            LDA ARGUMENT1
.1a0914	85 d7		sta $08d7	            STA LINENUM
.1a0916	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a0919					mv_curline
.1a0919	c2 20		rep #$20	            REP #$20
.1a091b	a5 00		lda $0800	            LDA BIP
.1a091d	85 1a		sta $081a	            STA CURLINE
.1a091f	e2 20		sep #$20	            SEP #$20
.1a0921	a5 02		lda $0802	            LDA BIP+2
.1a0923	85 1c		sta $081c	            STA CURLINE+2
.1a0925	20 39 09	jsr $1a0939	            JSR FINDREM
.1a0928	e2 20		sep #$20	            SEP #$20
.1a092a					loop
.1a092a	20 aa 09	jsr $1a09aa	            JSR TKFINDTOKEN
.1a092d	c9 00		cmp #$00	            CMP #0                  ; Did we find a token?
.1a092f	f0 05		beq $1a0936	            BEQ done                ; No: return
.1a0931	20 58 0b	jsr $1a0b58	            JSR TKWRITE
.1a0934	80 f4		bra $1a092a	            BRA loop                ; And try again
.1a0936	2b		pld		done        PLD
.1a0937	28		plp		            PLP
.1a0938	60		rts		            RTS
.1a0939					FINDREM
.1a0939	08		php		            PHP
.1a093a	c2 20		rep #$20	            REP #$20
.1a093c	a5 1a		lda $081a	            LDA CURLINE             ; Point BIP to the beginning of the line
.1a093e	85 00		sta $0800	            STA BIP
.1a0940	a5 1c		lda $081c	            LDA CURLINE+2
.1a0942	85 02		sta $0802	            STA BIP+2
.1a0944	a2 00 00	ldx #$0000	            LDX #0                  ; X will be a flag that we're at the beginning
.1a0947	e2 20		sep #$20	            SEP #$20
.1a0949	a0 00 00	ldy #$0000	loop        LDY #0
.1a094c	e0 00 00	cpx #$0000	            CPX #0                  ; If we are at the first space on the line
.1a094f	f0 0d		beq $1a095e	            BEQ skip_delim          ; ... skip looking for a delimiter
.1a0951	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a0953	f0 53		beq $1a09a8	            BEQ done                ; Is it null? Then we're done
.1a0955	c9 3a		cmp #$3a	            CMP #':'                ; Is it ":"
.1a0957	f0 04		beq $1a095d	            BEQ found_delim         ; Yes: we might have a REM... look for E
.1a0959	c9 20		cmp #$20	            CMP #CHAR_SP
.1a095b	d0 33		bne $1a0990	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a095d	c8		iny		found_delim INY
.1a095e	b7 00		lda [$0800],y	skip_delim  LDA [BIP],Y             ; Get the first character
.1a0960	f0 46		beq $1a09a8	            BEQ done                ; Is it null? Then we're done
.1a0962	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.1a0964	f0 10		beq $1a0976	            BEQ found_R             ; Yes: we might have a REM... look for E
.1a0966	c9 72		cmp #$72	            CMP #'r'
.1a0968	d0 26		bne $1a0990	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a096a	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a096c	f0 3a		beq $1a09a8	            BEQ done                ; Is it null? Then we're done
.1a096e	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.1a0970	f0 04		beq $1a0976	            BEQ found_R             ; Yes: we might have a REM... look for E
.1a0972	c9 72		cmp #$72	            CMP #'r'
.1a0974	d0 1a		bne $1a0990	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a0976	c8		iny		found_R     INY
.1a0977	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a0979	f0 2d		beq $1a09a8	            BEQ done                ; Is it null? Then we're done
.1a097b	c9 45		cmp #$45	            CMP #'E'                ; Is it "E"
.1a097d	f0 04		beq $1a0983	            BEQ found_E             ; Yes: we might have a REM... look for M
.1a097f	c9 65		cmp #$65	            CMP #'e'
.1a0981	d0 0d		bne $1a0990	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a0983	c8		iny		found_E     INY
.1a0984	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a0986	f0 20		beq $1a09a8	            BEQ done                ; Is it null? Then we're done
.1a0988	c9 4d		cmp #$4d	            CMP #'M'                ; Is it "E"
.1a098a	f0 0a		beq $1a0996	            BEQ found_REM           ; Yes: we might have a REM... look for M
.1a098c	c9 6d		cmp #$6d	            CMP #'m'
.1a098e	f0 06		beq $1a0996	            BEQ found_REM
.1a0990	e8		inx		next_pos    INX                     ; Indicate we're no longer at the first position
.1a0991	20 67 20	jsr $1a2067	            JSR INCBIP
.1a0994	80 b3		bra $1a0949	            BRA loop
.1a0996	a7 00		lda [$0800]	found_REM   LDA [BIP]               ; Get the current character
.1a0998	c9 3a		cmp #$3a	            CMP #':'                ; Is it the delimiter?
.1a099a	d0 03		bne $1a099f	            BNE ret_REM             ; No: go ahead and return REM at that location
.1a099c	20 67 20	jsr $1a2067	            JSR INCBIP
.1a099f	a9 03		lda #$03	ret_REM     LDA #3
.1a09a1	85 1e		sta $081e	            STA CURTOKLEN           ; Set the size
.1a09a3	a9 91		lda #$91	            LDA #TOK_REM            ; And the token to write
.1a09a5	20 58 0b	jsr $1a0b58	            JSR TKWRITE
.1a09a8	28		plp		done        PLP
.1a09a9	60		rts		            RTS
.1a09aa					TKFINDTOKEN
.1a09aa	08		php		            PHP
.1a09ab	0b		phd		            PHD
.1a09ac	08		php		            PHP
.1a09ad	c2 20		rep #$20	            REP #$20
.1a09af	48		pha		            PHA
.1a09b0	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a09b3	5b		tcd		            TCD
.1a09b4	68		pla		            PLA
.1a09b5	28		plp		            PLP
.1a09b6	e2 20		sep #$20	            SEP #$20
.1a09b8	a9 7f		lda #$7f	            LDA #$7F                ; Start off looking for any size token
.1a09ba	85 1e		sta $081e	            STA CURTOKLEN
.1a09bc					next_size
.1a09bc	c2 10		rep #$10	            REP #$10
.1a09be	20 0d 0b	jsr $1a0b0d	            JSR TKNEXTBIG
.1a09c1	a5 1e		lda $081e	            LDA CURTOKLEN           ; Are there any keywords left?
.1a09c3	d0 03		bne $1a09c8	            BNE else
.1a09c5	4c 4d 0a	jmp $1a0a4d	            JMP done                ; No: return to caller
.1a09c8					else
.1a09c8	c2 20		rep #$20	            REP #$20
.1a09ca	a5 1a		lda $081a	            LDA CURLINE
.1a09cc	85 00		sta $0800	            STA BIP
.1a09ce	e2 20		sep #$20	            SEP #$20
.1a09d0	a5 1c		lda $081c	            LDA CURLINE+2
.1a09d2	85 02		sta $0802	            STA BIP+2
.1a09d4	c2 20		rep #$20	            REP #$20
.1a09d6	64 04		stz $0804	            STZ BIPPREV             ; Clear BIPPREV (point to the previous character)
.1a09d8	64 06		stz $0806	            STZ BIPPREV+2
.1a09da					check_len
.1a09da	e2 30		sep #$30	            SEP #$30
.1a09dc	a0 00		ldy #$00	            LDY #0
.1a09de	b7 00		lda [$0800],y	nul_scan    LDA [BIP],Y
.1a09e0	f0 da		beq $1a09bc	            BEQ next_size
.1a09e2	c9 91		cmp #$91	            CMP #TOK_REM            ; Tokenization stops at REMarks too
.1a09e4	f0 d6		beq $1a09bc	            BEQ next_size
.1a09e6	c8		iny		            INY
.1a09e7	c4 1e		cpy $081e	            CPY CURTOKLEN
.1a09e9	90 f3		bcc $1a09de	            BCC nul_scan
.1a09eb	c2 10		rep #$10	            REP #$10
.1a09ed	a7 00		lda [$0800]	            LDA [BIP]               ; Check the current character
.1a09ef	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.1a09f1	d0 05		bne $1a09f8	            BNE chk_keyword         ; No: check to see if we are at the start of a possible keyword
.1a09f3	20 6f 0a	jsr $1a0a6f	            JSR SKIPQUOTED
.1a09f6	80 28		bra $1a0a20	            BRA go_next             ; And move on to the next character
.1a09f8	a5 1e		lda $081e	chk_keyword LDA CURTOKLEN           ; If the token length is <=2
.1a09fa	c9 03		cmp #$03	            CMP #3
.1a09fc	90 19		bcc $1a0a17	            BLT try_match           ; ... we don't need a delimiter, go ahead and convert it
.1a09fe	c2 20		rep #$20	            REP #$20
.1a0a00	a5 00		lda $0800	            LDA BIP                 ; Check to see if we're at the start of the line
.1a0a02	c5 1a		cmp $081a	            CMP CURLINE
.1a0a04	d0 08		bne $1a0a0e	            BNE chk_delim           ; No: we need to check for a delimiters
.1a0a06	e2 20		sep #$20	            SEP #$20
.1a0a08	a5 02		lda $0802	            LDA BIP+2
.1a0a0a	c5 1c		cmp $081c	            CMP CURLINE+2
.1a0a0c	f0 09		beq $1a0a17	            BEQ try_match           ; Yes: this can be a keyword
.1a0a0e					chk_delim
.1a0a0e	e2 20		sep #$20	            SEP #$20
.1a0a10	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.1a0a12	20 ef 4f	jsr $1a4fef	            JSR ISVARCHAR
.1a0a15	b0 09		bcs $1a0a20	            BCS go_next             ; Yes: we can't start a keyword here
.1a0a17					try_match
.1a0a17	e2 20		sep #$20	            SEP #$20
.1a0a19	20 7f 0a	jsr $1a0a7f	            JSR TKMATCH
.1a0a1c	c9 00		cmp #$00	            CMP #0                  ; Did we get one?
.1a0a1e	d0 11		bne $1a0a31	            BNE found               ; Yes: return it
.1a0a20					go_next
.1a0a20	c2 20		rep #$20	            REP #$20
.1a0a22	a5 00		lda $0800	            LDA BIP                 ; Update BIPPREV as the point to the previous character
.1a0a24	85 04		sta $0804	            STA BIPPREV
.1a0a26	e2 20		sep #$20	            SEP #$20
.1a0a28	a5 02		lda $0802	            LDA BIP+2
.1a0a2a	85 06		sta $0806	            STA BIPPREV+2
.1a0a2c	20 67 20	jsr $1a2067	            JSR INCBIP
.1a0a2f	80 a9		bra $1a09da	            BRA check_len           ; And try there
.1a0a31					found
.1a0a31	c9 81		cmp #$81	            CMP #TOK_MINUS          ; Found a token... is it minus?
.1a0a33	d0 18		bne $1a0a4d	            BNE done                ; Nope: go ahead and return it
.1a0a35	20 c5 08	jsr $1a08c5	            JSR PREVCHAR
.1a0a38	c9 00		cmp #$00	            CMP #0                  ; Did we get anything?
.1a0a3a	f0 14		beq $1a0a50	            BEQ syntax              ; No: line cannot start with minus... throw error
.1a0a3c	89 80		bit #$80	            BIT #$80                ; Is it a token?
.1a0a3e	10 0b		bpl $1a0a4b	            BPL binaryminus         ; No: leave token unchanged
.1a0a40	20 f9 0b	jsr $1a0bf9	            JSR TOKTYPE
.1a0a43	c9 30		cmp #$30	            CMP #TOK_TY_FUNC        ; Is it a function?
.1a0a45	f0 04		beq $1a0a4b	            BEQ binaryminus         ; Yes: then this should be a binary minus operator
.1a0a47	a9 af		lda #$af	            LDA #TOK_NEGATIVE       ; Otherwise: this should be a unary minus (negation)
.1a0a49	80 02		bra $1a0a4d	            BRA done
.1a0a4b	a9 81		lda #$81	binaryminus LDA #TOK_MINUS          ; It's data... so token should be for binary minus
.1a0a4d					done
.1a0a4d	2b		pld		            PLD
.1a0a4e	28		plp		            PLP
.1a0a4f	60		rts		            RTS
.1a0a50					syntax
.1a0a50	08		php		            PHP
.1a0a51	c2 20		rep #$20	            REP #$20
.1a0a53	48		pha		            PHA
.1a0a54	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0a57	5b		tcd		            TCD
.1a0a58	68		pla		            PLA
.1a0a59	28		plp		            PLP
.1a0a5a	e2 20		sep #$20	            SEP #$20
.1a0a5c	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a0a5e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0a62	c2 20		rep #$20	            REP #$20
.1a0a64	29 ff 00	and #$00ff	            AND #$00FF
.1a0a67	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a0a6a	e2 20		sep #$20	            SEP #$20
.1a0a6c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0a6f					SKIPQUOTED
.1a0a6f	08		php		            PHP
.1a0a70	e2 20		sep #$20	            SEP #$20
.1a0a72					loop
.1a0a72	20 67 20	jsr $1a2067	            JSR INCBIP
.1a0a75	a7 00		lda [$0800]	            LDA [BIP]
.1a0a77	f0 04		beq $1a0a7d	            BEQ done                ; If EOL, just return
.1a0a79	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.1a0a7b	d0 f5		bne $1a0a72	            BNE loop                ; No: keep skipping
.1a0a7d	28		plp		done        PLP
.1a0a7e	60		rts		            RTS
.1a0a7f					TKMATCH
.1a0a7f	da		phx		            PHX
.1a0a80	5a		phy		            PHY
.1a0a81	08		php		            PHP
.1a0a82	0b		phd		            PHD
.1a0a83	08		php		            PHP
.1a0a84	c2 20		rep #$20	            REP #$20
.1a0a86	48		pha		            PHA
.1a0a87	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0a8a	5b		tcd		            TCD
.1a0a8b	68		pla		            PLA
.1a0a8c	28		plp		            PLP
.1a0a8d	c2 20		rep #$20	            REP #$20
.1a0a8f	a5 04		lda $0804	            LDA BIPPREV
.1a0a91	d0 0a		bne $1a0a9d	            BNE check_prev
.1a0a93	e2 20		sep #$20	            SEP #$20
.1a0a95	a5 04		lda $0804	            LDA BIPPREV
.1a0a97	d0 04		bne $1a0a9d	            BNE check_prev
.1a0a99	a9 00		lda #$00	            LDA #0
.1a0a9b	80 0a		bra $1a0aa7	            BRA save_delim
.1a0a9d					check_prev
.1a0a9d	e2 20		sep #$20	            SEP #$20
.1a0a9f	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.1a0aa1	20 ef 4f	jsr $1a4fef	            JSR ISVARCHAR
.1a0aa4	a9 00		lda #$00	            LDA #0
.1a0aa6	2a		rol a		            ROL A
.1a0aa7	85 28		sta $0828	save_delim  STA SIGN1               ; SIGN1 := 1 if it is a variable name character
.1a0aa9	c2 30		rep #$30	            REP #$30
.1a0aab	a9 4d 0c	lda #$0c4d	            LDA #<>TOKENS           ; Set INDEX to point to the first token record
.1a0aae	85 08		sta $0808	            STA INDEX
.1a0ab0	e2 20		sep #$20	            SEP #$20
.1a0ab2	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0ab4	85 0a		sta $080a	            STA INDEX+2
.1a0ab6	a2 80 00	ldx #$0080	            LDX #$80                ; Set the initial token ID
.1a0ab9					token_loop
.1a0ab9	e2 20		sep #$20	            SEP #$20
.1a0abb	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.1a0abe	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the current token
.1a0ac0	f0 31		beq $1a0af3	            BEQ no_match            ; Is it 0? We're out of tokens... no match found
.1a0ac2	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it the same as the size of the window?
.1a0ac4	d0 32		bne $1a0af8	            BNE next_token          ; No: try the next token
.1a0ac6	c2 30		rep #$30	            REP #$30
.1a0ac8	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.1a0acb	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the pointer to the token's name
.1a0acd	85 0c		sta $080c	            STA SCRATCH             ; Set SCRATCH to point to the token's name
.1a0acf	e2 20		sep #$20	            SEP #$20
.1a0ad1	a9 1a		lda #$1a	            LDA #`DATA_BLOCK
.1a0ad3	85 0e		sta $080e	            STA SCRATCH+2
.1a0ad5	a5 28		lda $0828	            LDA SIGN1               ; Is previous character a variable name character?
.1a0ad7	f0 07		beq $1a0ae0	            BEQ cmp_keyword         ; No: we can check for this token
.1a0ad9	a7 0c		lda [$080c]	            LDA [SCRATCH]           ; Get the token's first character
.1a0adb	20 ef 4f	jsr $1a4fef	            JSR ISVARCHAR
.1a0ade	b0 18		bcs $1a0af8	            BCS next_token          ; Yes: skip this token
.1a0ae0					cmp_keyword
.1a0ae0	e2 10		sep #$10	            SEP #$10
.1a0ae2	a0 00		ldy #$00	            LDY #0
.1a0ae4	b7 00		lda [$0800],y	cmp_loop    LDA [BIP],Y             ; Get the character in the window
.1a0ae6	20 a5 04	jsr $1a04a5	            JSR TOUPPERA
.1a0ae9	d7 0c		cmp [$080c],y	            CMP [SCRATCH],Y         ; Compare to the character in the token
.1a0aeb	d0 0b		bne $1a0af8	            BNE next_token          ; If they don't match, try the next token
.1a0aed	c8		iny		            INY                     ; Move to the next character in the window
.1a0aee	c4 1e		cpy $081e	            CPY CURTOKLEN           ; Have we checked the whole window?
.1a0af0	90 f2		bcc $1a0ae4	            BCC cmp_loop            ; No: check this next character
.1a0af2	8a		txa		            TXA                     ; Move the token ID to A
.1a0af3	2b		pld		no_match    PLD
.1a0af4	28		plp		            PLP
.1a0af5	7a		ply		            PLY
.1a0af6	fa		plx		            PLX
.1a0af7	60		rts		            RTS
.1a0af8					next_token
.1a0af8	c2 30		rep #$30	            REP #$30
.1a0afa	18		clc		            CLC
.1a0afb	a5 08		lda $0808	            LDA INDEX
.1a0afd	69 08 00	adc #$0008	            ADC #size(TOKEN)
.1a0b00	85 08		sta $0808	            STA INDEX
.1a0b02	e2 20		sep #$20	            SEP #$20
.1a0b04	a5 0a		lda $080a	            LDA INDEX+2
.1a0b06	69 00		adc #$00	            ADC #0
.1a0b08	85 0a		sta $080a	            STA INDEX+2
.1a0b0a	e8		inx		            INX                     ; Increment the token ID
.1a0b0b	80 ac		bra $1a0ab9	            BRA token_loop          ; And check that token
.1a0b0d					TKNEXTBIG
.1a0b0d	08		php		            PHP
.1a0b0e	0b		phd		            PHD
.1a0b0f	8b		phb		            PHB
.1a0b10	08		php		            PHP
.1a0b11	c2 20		rep #$20	            REP #$20
.1a0b13	48		pha		            PHA
.1a0b14	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0b17	5b		tcd		            TCD
.1a0b18	68		pla		            PLA
.1a0b19	28		plp		            PLP
.1a0b1a	c2 30		rep #$30	            REP #$30
.1a0b1c	a9 4d 0c	lda #$0c4d	            LDA #<>TOKENS
.1a0b1f	85 08		sta $0808	            STA INDEX
.1a0b21	a9 1a 00	lda #$001a	            LDA #`TOKENS
.1a0b24	85 0a		sta $080a	            STA INDEX+2
.1a0b26	64 0c		stz $080c	            STZ SCRATCH             ; Clear SCRATCH
.1a0b28					loop
.1a0b28	e2 20		sep #$20	            SEP #$20
.1a0b2a	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.1a0b2d	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the token
.1a0b2f	f0 1d		beq $1a0b4e	            BEQ done                ; If length is 0, we're done
.1a0b31	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it >= CURTOKLEN?
.1a0b33	b0 06		bcs $1a0b3b	            BGE skip                ; Yes: skip to the next token
.1a0b35	c5 0c		cmp $080c	            CMP SCRATCH             ; No: is it < SCRATCH?
.1a0b37	90 02		bcc $1a0b3b	            BLT skip                ; Yes: skip to the next token
.1a0b39	85 0c		sta $080c	            STA SCRATCH             ; No: it's our new longest token!
.1a0b3b					skip
.1a0b3b	c2 20		rep #$20	            REP #$20
.1a0b3d	18		clc		            CLC
.1a0b3e	a5 08		lda $0808	            LDA INDEX
.1a0b40	69 08 00	adc #$0008	            ADC #size(TOKEN)
.1a0b43	85 08		sta $0808	            STA INDEX
.1a0b45	a5 0a		lda $080a	            LDA INDEX+2
.1a0b47	69 00 00	adc #$0000	            ADC #0
.1a0b4a	85 0a		sta $080a	            STA INDEX+2
.1a0b4c	80 da		bra $1a0b28	            BRA loop                ; And go around for another pass
.1a0b4e					done
.1a0b4e	e2 20		sep #$20	            SEP #$20
.1a0b50	a5 0c		lda $080c	            LDA SCRATCH
.1a0b52	85 1e		sta $081e	            STA CURTOKLEN
.1a0b54	ab		plb		            PLB
.1a0b55	2b		pld		            PLD
.1a0b56	28		plp		            PLP
.1a0b57	60		rts		            RTS
.1a0b58					TKWRITE
.1a0b58	08		php		            PHP
.1a0b59	0b		phd		            PHD
.1a0b5a	08		php		            PHP
.1a0b5b	c2 20		rep #$20	            REP #$20
.1a0b5d	48		pha		            PHA
.1a0b5e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0b61	5b		tcd		            TCD
.1a0b62	68		pla		            PLA
.1a0b63	28		plp		            PLP
.1a0b64	e2 20		sep #$20	            SEP #$20
.1a0b66	87 00		sta [$0800]	            STA [BIP]               ; Write the token to the line
.1a0b68	c2 20		rep #$20	            REP #$20
.1a0b6a	18		clc		            CLC
.1a0b6b	a5 00		lda $0800	            LDA BIP
.1a0b6d	69 01 00	adc #$0001	            ADC #1
.1a0b70	85 08		sta $0808	            STA INDEX
.1a0b72	a5 02		lda $0802	            LDA BIP+2
.1a0b74	69 00 00	adc #$0000	            ADC #0
.1a0b77	85 0a		sta $080a	            STA INDEX+2
.1a0b79	e2 10		sep #$10	            SEP #$10
.1a0b7b	a4 1e		ldy $081e	            LDY CURTOKLEN           ; Y will be the number of characters to move down
.1a0b7d	88		dey		            DEY
.1a0b7e					copy_down
.1a0b7e	e2 20		sep #$20	            SEP #$20
.1a0b80	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the byte to move down
.1a0b82	87 08		sta [$0808]	            STA [INDEX]             ; Move it down
.1a0b84	f0 13		beq $1a0b99	            BEQ done                ; We've reached the end of the line
.1a0b86	c2 20		rep #$20	            REP #$20
.1a0b88	18		clc		            CLC
.1a0b89	a5 08		lda $0808	            LDA INDEX
.1a0b8b	69 01 00	adc #$0001	            ADC #1
.1a0b8e	85 08		sta $0808	            STA INDEX
.1a0b90	a5 0a		lda $080a	            LDA INDEX+2
.1a0b92	69 00 00	adc #$0000	            ADC #0
.1a0b95	85 0a		sta $080a	            STA INDEX+2
.1a0b97	80 e5		bra $1a0b7e	            BRA copy_down
.1a0b99	2b		pld		done        PLD
.1a0b9a	28		plp		            PLP
.1a0b9b	60		rts		            RTS
.1a0b9c					GETTOKREC
.1a0b9c	08		php		            PHP
.1a0b9d	c2 30		rep #$30	            REP #$30
.1a0b9f	29 7f 00	and #$007f	            AND #$007F
.1a0ba2	0a		asl a		            ASL A
.1a0ba3	0a		asl a		            ASL A
.1a0ba4	0a		asl a		            ASL A
.1a0ba5	18		clc		            CLC
.1a0ba6	69 4d 0c	adc #$0c4d	            ADC #<>TOKENS
.1a0ba9	aa		tax		            TAX                         ; X is now the data bank relative address of the token record
.1a0baa	28		plp		            PLP
.1a0bab	60		rts		            RTS
.1a0bac					TOKPRECED
.1a0bac	08		php		            PHP
.1a0bad	8b		phb		            PHB
.1a0bae	0b		phd		            PHD
.1a0baf	08		php		            PHP
.1a0bb0	c2 20		rep #$20	            REP #$20
.1a0bb2	48		pha		            PHA
.1a0bb3	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0bb6	5b		tcd		            TCD
.1a0bb7	68		pla		            PLA
.1a0bb8	28		plp		            PLP
.1a0bb9	08		php		            PHP
.1a0bba	e2 20		sep #$20	            SEP #$20
.1a0bbc	48		pha		            PHA
.1a0bbd	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0bbf	48		pha		            PHA
.1a0bc0	ab		plb		            PLB
.1a0bc1	68		pla		            PLA
.1a0bc2	28		plp		            PLP
.1a0bc3	e2 20		sep #$20	            SEP #$20
.1a0bc5	c2 10		rep #$10	            REP #$10
.1a0bc7	20 9c 0b	jsr $1a0b9c	            JSR GETTOKREC
.1a0bca	bd 00 00	lda $1a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.1a0bcd	c2 20		rep #$20	            REP #$20
.1a0bcf	29 0f 00	and #$000f	            AND #$000F                  ; Mask off the type code
.1a0bd2	2b		pld		            PLD
.1a0bd3	ab		plb		            PLB
.1a0bd4	28		plp		            PLP
.1a0bd5	60		rts		            RTS
.1a0bd6					TOKEVAL
.1a0bd6	08		php		            PHP
.1a0bd7	8b		phb		            PHB
.1a0bd8	0b		phd		            PHD
.1a0bd9	08		php		            PHP
.1a0bda	c2 20		rep #$20	            REP #$20
.1a0bdc	48		pha		            PHA
.1a0bdd	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0be0	5b		tcd		            TCD
.1a0be1	68		pla		            PLA
.1a0be2	28		plp		            PLP
.1a0be3	08		php		            PHP
.1a0be4	e2 20		sep #$20	            SEP #$20
.1a0be6	48		pha		            PHA
.1a0be7	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0be9	48		pha		            PHA
.1a0bea	ab		plb		            PLB
.1a0beb	68		pla		            PLA
.1a0bec	28		plp		            PLP
.1a0bed	c2 30		rep #$30	            REP #$30
.1a0bef	20 9c 0b	jsr $1a0b9c	            JSR GETTOKREC
.1a0bf2	bd 04 00	lda $1a0004,x	            LDA #TOKEN.eval,B,X         ; Get the address of the evaluation function
.1a0bf5	2b		pld		            PLD
.1a0bf6	ab		plb		            PLB
.1a0bf7	28		plp		            PLP
.1a0bf8	60		rts		            RTS
.1a0bf9					TOKTYPE
.1a0bf9	08		php		            PHP
.1a0bfa	8b		phb		            PHB
.1a0bfb	0b		phd		            PHD
.1a0bfc	08		php		            PHP
.1a0bfd	c2 20		rep #$20	            REP #$20
.1a0bff	48		pha		            PHA
.1a0c00	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0c03	5b		tcd		            TCD
.1a0c04	68		pla		            PLA
.1a0c05	28		plp		            PLP
.1a0c06	08		php		            PHP
.1a0c07	e2 20		sep #$20	            SEP #$20
.1a0c09	48		pha		            PHA
.1a0c0a	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0c0c	48		pha		            PHA
.1a0c0d	ab		plb		            PLB
.1a0c0e	68		pla		            PLA
.1a0c0f	28		plp		            PLP
.1a0c10	e2 20		sep #$20	            SEP #$20
.1a0c12	c2 10		rep #$10	            REP #$10
.1a0c14	20 9c 0b	jsr $1a0b9c	            JSR GETTOKREC
.1a0c17	bd 00 00	lda $1a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.1a0c1a	c2 20		rep #$20	            REP #$20
.1a0c1c	29 f0 00	and #$00f0	            AND #$00F0                  ; Mask off the type code
.1a0c1f	2b		pld		            PLD
.1a0c20	ab		plb		            PLB
.1a0c21	28		plp		            PLP
.1a0c22	60		rts		            RTS
.1a0c23					TOKARITY
.1a0c23	08		php		            PHP
.1a0c24	8b		phb		            PHB
.1a0c25	0b		phd		            PHD
.1a0c26	08		php		            PHP
.1a0c27	c2 20		rep #$20	            REP #$20
.1a0c29	48		pha		            PHA
.1a0c2a	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0c2d	5b		tcd		            TCD
.1a0c2e	68		pla		            PLA
.1a0c2f	28		plp		            PLP
.1a0c30	08		php		            PHP
.1a0c31	e2 20		sep #$20	            SEP #$20
.1a0c33	48		pha		            PHA
.1a0c34	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0c36	48		pha		            PHA
.1a0c37	ab		plb		            PLB
.1a0c38	68		pla		            PLA
.1a0c39	28		plp		            PLP
.1a0c3a	e2 20		sep #$20	            SEP #$20
.1a0c3c	c2 10		rep #$10	            REP #$10
.1a0c3e	20 9c 0b	jsr $1a0b9c	            JSR GETTOKREC
.1a0c41	bd 06 00	lda $1a0006,x	            LDA #TOKEN.arity,B,X        ; Get the arity
.1a0c44	c2 20		rep #$20	            REP #$20
.1a0c46	29 ff 00	and #$00ff	            AND #$00FF
.1a0c49	2b		pld		            PLD
.1a0c4a	ab		plb		            PLB
.1a0c4b	28		plp		            PLP
.1a0c4c	60		rts		            RTS
=$00					TOK_EOL = $00
=$01					TOK_FUNC_OPEN = $01     ; A pseudo-token to push to the operator stack to mark
=$00					TOK_TY_OP = $00         ; The token is an operator
=$10					TOK_TY_CMD = $10        ; The token is a command (e.g. RUN, LIST, etc.)
=$20					TOK_TY_STMNT = $20      ; The token is a statement (e.g. INPUT, PRINT, DIM, etc.)
=$30					TOK_TY_FUNC = $30       ; The token is a function (e.g. SIN, COS, TAB, etc.)
=$40					TOK_TY_PUNCT = $40      ; The token is a punctuation mark (e.g. "(", ")")
=$50					TOK_TY_BYWRD = $50      ; The token is a by-word (e.g. STEP, TO, WEND, etc.)
.1a0c4d					TOKENS
=$80					TOK_PLUS = $80
>1ad010	2b 00				TOKEN_TEXT  .null "+"
>1a0c4d	03				precedence  .byte TOK_TY_OP | 3
>1a0c4e	01				length      .byte len("+")
>1a0c4f	10 d0				name        .word <>TOKEN_TEXT
>1a0c51	2d 27				eval        .word <>OP_PLUS
>1a0c53	02 00				arity       .word <>2
=$81					TOK_MINUS = $81
>1ad012	2d 00				TOKEN_TEXT  .null "-"
>1a0c55	03				precedence  .byte TOK_TY_OP | 3
>1a0c56	01				length      .byte len("-")
>1a0c57	12 d0				name        .word <>TOKEN_TEXT
>1a0c59	6d 27				eval        .word <>OP_MINUS
>1a0c5b	02 00				arity       .word <>2
=$82					TOK_MULT = $82
>1ad014	2a 00				TOKEN_TEXT  .null "*"
>1a0c5d	02				precedence  .byte TOK_TY_OP | 2
>1a0c5e	01				length      .byte len("*")
>1a0c5f	14 d0				name        .word <>TOKEN_TEXT
>1a0c61	a4 27				eval        .word <>OP_MULTIPLY
>1a0c63	02 00				arity       .word <>2
=$83					TOK_DIVIDE = $83
>1ad016	2f 00				TOKEN_TEXT  .null "/"
>1a0c65	02				precedence  .byte TOK_TY_OP | 2
>1a0c66	01				length      .byte len("/")
>1a0c67	16 d0				name        .word <>TOKEN_TEXT
>1a0c69	db 27				eval        .word <>OP_DIVIDE
>1a0c6b	02 00				arity       .word <>2
=$84					TOK_MOD = $84
>1ad018	4d 4f 44 00			TOKEN_TEXT  .null "MOD"
>1a0c6d	02				precedence  .byte TOK_TY_OP | 2
>1a0c6e	03				length      .byte len("MOD")
>1a0c6f	18 d0				name        .word <>TOKEN_TEXT
>1a0c71	e5 27				eval        .word <>OP_MOD
>1a0c73	02 00				arity       .word <>2
>1ad01c	5e 00				TOKEN_TEXT  .null "^"
>1a0c75	00				precedence  .byte TOK_TY_OP | 0
>1a0c76	01				length      .byte len("^")
>1a0c77	1c d0				name        .word <>TOKEN_TEXT
>1a0c79	f8 27				eval        .word <>OP_POW
>1a0c7b	02 00				arity       .word <>2
=$86					TOK_LE = $86
>1ad01e	3c 3d 00			TOKEN_TEXT  .null "<="
>1a0c7d	04				precedence  .byte TOK_TY_OP | 4
>1a0c7e	02				length      .byte len("<=")
>1a0c7f	1e d0				name        .word <>TOKEN_TEXT
>1a0c81	b6 29				eval        .word <>OP_LTE
>1a0c83	02 00				arity       .word <>2
=$87					TOK_GE = $87
>1ad021	3e 3d 00			TOKEN_TEXT  .null ">="
>1a0c85	04				precedence  .byte TOK_TY_OP | 4
>1a0c86	02				length      .byte len(">=")
>1a0c87	21 d0				name        .word <>TOKEN_TEXT
>1a0c89	76 29				eval        .word <>OP_GTE
>1a0c8b	02 00				arity       .word <>2
=$88					TOK_NE = $88
>1ad024	3c 3e 00			TOKEN_TEXT  .null "<>"
>1a0c8d	04				precedence  .byte TOK_TY_OP | 4
>1a0c8e	02				length      .byte len("<>")
>1a0c8f	24 d0				name        .word <>TOKEN_TEXT
>1a0c91	36 29				eval        .word <>OP_NE
>1a0c93	02 00				arity       .word <>2
>1ad027	3c 00				TOKEN_TEXT  .null "<"
>1a0c95	04				precedence  .byte TOK_TY_OP | 4
>1a0c96	01				length      .byte len("<")
>1a0c97	27 d0				name        .word <>TOKEN_TEXT
>1a0c99	76 28				eval        .word <>OP_LT
>1a0c9b	02 00				arity       .word <>2
=$8a					TOK_EQ = $8A
>1ad029	3d 00				TOKEN_TEXT  .null "="
>1a0c9d	04				precedence  .byte TOK_TY_OP | 4
>1a0c9e	01				length      .byte len("=")
>1a0c9f	29 d0				name        .word <>TOKEN_TEXT
>1a0ca1	f6 28				eval        .word <>OP_EQ
>1a0ca3	02 00				arity       .word <>2
>1ad02b	3e 00				TOKEN_TEXT  .null ">"
>1a0ca5	04				precedence  .byte TOK_TY_OP | 4
>1a0ca6	01				length      .byte len(">")
>1a0ca7	2b d0				name        .word <>TOKEN_TEXT
>1a0ca9	b6 28				eval        .word <>OP_GT
>1a0cab	02 00				arity       .word <>2
>1ad02d	4e 4f 54 00			TOKEN_TEXT  .null "NOT"
>1a0cad	05				precedence  .byte TOK_TY_OP | 5
>1a0cae	03				length      .byte len("NOT")
>1a0caf	2d d0				name        .word <>TOKEN_TEXT
>1a0cb1	60 28				eval        .word <>OP_NOT
>1a0cb3	01 00				arity       .word <>1
>1ad031	41 4e 44 00			TOKEN_TEXT  .null "AND"
>1a0cb5	06				precedence  .byte TOK_TY_OP | 6
>1a0cb6	03				length      .byte len("AND")
>1a0cb7	31 d0				name        .word <>TOKEN_TEXT
>1a0cb9	32 28				eval        .word <>OP_AND
>1a0cbb	02 00				arity       .word <>2
>1ad035	4f 52 00			TOKEN_TEXT  .null "OR"
>1a0cbd	07				precedence  .byte TOK_TY_OP | 7
>1a0cbe	02				length      .byte len("OR")
>1a0cbf	35 d0				name        .word <>TOKEN_TEXT
>1a0cc1	49 28				eval        .word <>OP_OR
>1a0cc3	02 00				arity       .word <>2
=$8f					TOK_LPAREN = $8F
>1ad038	28 00				TOKEN_TEXT  .null "("
>1a0cc5	ff				precedence  .byte TOK_TY_PUNCT | $FF
>1a0cc6	01				length      .byte len("(")
>1a0cc7	38 d0				name        .word <>TOKEN_TEXT
>1a0cc9	00 00				eval        .word <>0
>1a0ccb	00 00				arity       .word <>0
=$90					TOK_RPAREN = $90
>1ad03a	29 00				TOKEN_TEXT  .null ")"
>1a0ccd	40				precedence  .byte TOK_TY_PUNCT | 0
>1a0cce	01				length      .byte len(")")
>1a0ccf	3a d0				name        .word <>TOKEN_TEXT
>1a0cd1	00 00				eval        .word <>0
>1a0cd3	00 00				arity       .word <>0
=$91					TOK_REM = $91
>1ad03c	52 45 4d 00			TOKEN_TEXT  .null "REM"
>1a0cd5	20				precedence  .byte TOK_TY_STMNT | 0
>1a0cd6	03				length      .byte len("REM")
>1a0cd7	3c d0				name        .word <>TOKEN_TEXT
>1a0cd9	7c 40				eval        .word <>S_REM
>1a0cdb	00 00				arity       .word <>0
=$92					TOK_PRINT = $92
>1ad040	50 52 49 4e 54 00		TOKEN_TEXT  .null "PRINT"
>1a0cdd	20				precedence  .byte TOK_TY_STMNT | 0
>1a0cde	05				length      .byte len("PRINT")
>1a0cdf	40 d0				name        .word <>TOKEN_TEXT
>1a0ce1	81 44				eval        .word <>S_PRINT
>1a0ce3	00 00				arity       .word <>0
=$93					TOK_LET = $93
>1ad046	4c 45 54 00			TOKEN_TEXT  .null "LET"
>1a0ce5	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ce6	03				length      .byte len("LET")
>1a0ce7	46 d0				name        .word <>TOKEN_TEXT
>1a0ce9	cc 43				eval        .word <>S_LET
>1a0ceb	00 00				arity       .word <>0
>1ad04a	47 4f 54 4f 00			TOKEN_TEXT  .null "GOTO"
>1a0ced	20				precedence  .byte TOK_TY_STMNT | 0
>1a0cee	04				length      .byte len("GOTO")
>1a0cef	4a d0				name        .word <>TOKEN_TEXT
>1a0cf1	6c 43				eval        .word <>S_GOTO
>1a0cf3	00 00				arity       .word <>0
=$95					TOK_END = $95
>1ad04f	45 4e 44 00			TOKEN_TEXT  .null "END"
>1a0cf5	20				precedence  .byte TOK_TY_STMNT | 0
>1a0cf6	03				length      .byte len("END")
>1a0cf7	4f d0				name        .word <>TOKEN_TEXT
>1a0cf9	63 43				eval        .word <>S_END
>1a0cfb	00 00				arity       .word <>0
>1ad053	49 46 00			TOKEN_TEXT  .null "IF"
>1a0cfd	20				precedence  .byte TOK_TY_STMNT | 0
>1a0cfe	02				length      .byte len("IF")
>1a0cff	53 d0				name        .word <>TOKEN_TEXT
>1a0d01	fb 42				eval        .word <>S_IF
>1a0d03	00 00				arity       .word <>0
=$97					TOK_THEN = $97
>1ad056	54 48 45 4e 00			TOKEN_TEXT  .null "THEN"
>1a0d05	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0d06	04				length      .byte len("THEN")
>1a0d07	56 d0				name        .word <>TOKEN_TEXT
>1a0d09	00 00				eval        .word <>0
>1a0d0b	00 00				arity       .word <>0
>1ad05b	45 4c 53 45 00			TOKEN_TEXT  .null "ELSE"
>1a0d0d	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0d0e	04				length      .byte len("ELSE")
>1a0d0f	5b d0				name        .word <>TOKEN_TEXT
>1a0d11	00 00				eval        .word <>0
>1a0d13	00 00				arity       .word <>0
>1ad060	47 4f 53 55 42 00		TOKEN_TEXT  .null "GOSUB"
>1a0d15	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d16	05				length      .byte len("GOSUB")
>1a0d17	60 d0				name        .word <>TOKEN_TEXT
>1a0d19	3e 42				eval        .word <>S_GOSUB
>1a0d1b	00 00				arity       .word <>0
>1ad066	52 45 54 55 52 4e 00		TOKEN_TEXT  .null "RETURN"
>1a0d1d	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d1e	06				length      .byte len("RETURN")
>1a0d1f	66 d0				name        .word <>TOKEN_TEXT
>1a0d21	b7 42				eval        .word <>S_RETURN
>1a0d23	00 00				arity       .word <>0
=$9b					TOK_FOR = $9B
>1ad06d	46 4f 52 00			TOKEN_TEXT  .null "FOR"
>1a0d25	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d26	03				length      .byte len("FOR")
>1a0d27	6d d0				name        .word <>TOKEN_TEXT
>1a0d29	93 40				eval        .word <>S_FOR
>1a0d2b	00 00				arity       .word <>0
=$9c					TOK_TO = $9C
>1ad071	54 4f 00			TOKEN_TEXT  .null "TO"
>1a0d2d	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0d2e	02				length      .byte len("TO")
>1a0d2f	71 d0				name        .word <>TOKEN_TEXT
>1a0d31	00 00				eval        .word <>0
>1a0d33	00 00				arity       .word <>0
=$9d					TOK_STEP = $9D
>1ad074	53 54 45 50 00			TOKEN_TEXT  .null "STEP"
>1a0d35	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0d36	04				length      .byte len("STEP")
>1a0d37	74 d0				name        .word <>TOKEN_TEXT
>1a0d39	00 00				eval        .word <>0
>1a0d3b	00 00				arity       .word <>0
=$9e					TOK_NEXT = $9E
>1ad079	4e 45 58 54 00			TOKEN_TEXT  .null "NEXT"
>1a0d3d	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d3e	04				length      .byte len("NEXT")
>1a0d3f	79 d0				name        .word <>TOKEN_TEXT
>1a0d41	87 41				eval        .word <>S_NEXT
>1a0d43	00 00				arity       .word <>0
=$9f					TOK_DO = $9F
>1ad07e	44 4f 00			TOKEN_TEXT  .null "DO"
>1a0d45	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d46	02				length      .byte len("DO")
>1a0d47	7e d0				name        .word <>TOKEN_TEXT
>1a0d49	8d 40				eval        .word <>S_DO
>1a0d4b	00 00				arity       .word <>0
=$a0					TOK_LOOP = $A0
>1ad081	4c 4f 4f 50 00			TOKEN_TEXT  .null "LOOP"
>1a0d4d	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d4e	04				length      .byte len("LOOP")
>1a0d4f	81 d0				name        .word <>TOKEN_TEXT
>1a0d51	90 40				eval        .word <>S_LOOP
>1a0d53	00 00				arity       .word <>0
>1ad086	57 48 49 4c 45 00		TOKEN_TEXT  .null "WHILE"
>1a0d55	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0d56	05				length      .byte len("WHILE")
>1a0d57	86 d0				name        .word <>TOKEN_TEXT
>1a0d59	00 00				eval        .word <>0
>1a0d5b	00 00				arity       .word <>0
>1ad08c	55 4e 54 49 4c 00		TOKEN_TEXT  .null "UNTIL"
>1a0d5d	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0d5e	05				length      .byte len("UNTIL")
>1a0d5f	8c d0				name        .word <>TOKEN_TEXT
>1a0d61	00 00				eval        .word <>0
>1a0d63	00 00				arity       .word <>0
>1ad092	45 58 49 54 00			TOKEN_TEXT  .null "EXIT"
>1a0d65	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d66	04				length      .byte len("EXIT")
>1a0d67	92 d0				name        .word <>TOKEN_TEXT
>1a0d69	8a 40				eval        .word <>S_EXIT
>1a0d6b	00 00				arity       .word <>0
>1ad097	43 4c 52 00			TOKEN_TEXT  .null "CLR"
>1a0d6d	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d6e	03				length      .byte len("CLR")
>1a0d6f	97 d0				name        .word <>TOKEN_TEXT
>1a0d71	c2 43				eval        .word <>S_CLR
>1a0d73	00 00				arity       .word <>0
>1ad09b	53 54 4f 50 00			TOKEN_TEXT  .null "STOP"
>1a0d75	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d76	04				length      .byte len("STOP")
>1a0d77	9b d0				name        .word <>TOKEN_TEXT
>1a0d79	5d 40				eval        .word <>S_STOP
>1a0d7b	00 00				arity       .word <>0
>1ad0a0	50 4f 4b 45 00			TOKEN_TEXT  .null "POKE"
>1a0d7d	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d7e	04				length      .byte len("POKE")
>1a0d7f	a0 d0				name        .word <>TOKEN_TEXT
>1a0d81	ed 3f				eval        .word <>S_POKE
>1a0d83	00 00				arity       .word <>0
>1ad0a5	50 4f 4b 45 57 00		TOKEN_TEXT  .null "POKEW"
>1a0d85	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d86	05				length      .byte len("POKEW")
>1a0d87	a5 d0				name        .word <>TOKEN_TEXT
>1a0d89	83 3f				eval        .word <>S_POKEW
>1a0d8b	00 00				arity       .word <>0
>1ad0ab	50 4f 4b 45 4c 00		TOKEN_TEXT  .null "POKEL"
>1a0d8d	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d8e	05				length      .byte len("POKEL")
>1a0d8f	ab d0				name        .word <>TOKEN_TEXT
>1a0d91	10 3f				eval        .word <>S_POKEL
>1a0d93	00 00				arity       .word <>0
>1ad0b1	43 4c 53 00			TOKEN_TEXT  .null "CLS"
>1a0d95	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d96	03				length      .byte len("CLS")
>1a0d97	b1 d0				name        .word <>TOKEN_TEXT
>1a0d99	0c 3f				eval        .word <>S_CLS
>1a0d9b	00 00				arity       .word <>0
>1ad0b5	52 45 41 44 00			TOKEN_TEXT  .null "READ"
>1a0d9d	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d9e	04				length      .byte len("READ")
>1a0d9f	b5 d0				name        .word <>TOKEN_TEXT
>1a0da1	ed 3d				eval        .word <>S_READ
>1a0da3	00 00				arity       .word <>0
=$ab					TOK_DATA = $AB
>1ad0ba	44 41 54 41 00			TOKEN_TEXT  .null "DATA"
>1a0da5	20				precedence  .byte TOK_TY_STMNT | 0
>1a0da6	04				length      .byte len("DATA")
>1a0da7	ba d0				name        .word <>TOKEN_TEXT
>1a0da9	ff 3e				eval        .word <>S_DATA
>1a0dab	00 00				arity       .word <>0
>1ad0bf	52 45 53 54 4f 52 45 00		TOKEN_TEXT  .null "RESTORE"
>1a0dad	20				precedence  .byte TOK_TY_STMNT | 0
>1a0dae	07				length      .byte len("RESTORE")
>1a0daf	bf d0				name        .word <>TOKEN_TEXT
>1a0db1	03 3f				eval        .word <>S_RESTORE
>1a0db3	00 00				arity       .word <>0
>1ad0c7	44 49 4d 00			TOKEN_TEXT  .null "DIM"
>1a0db5	20				precedence  .byte TOK_TY_STMNT | 0
>1a0db6	03				length      .byte len("DIM")
>1a0db7	c7 d0				name        .word <>TOKEN_TEXT
>1a0db9	40 3d				eval        .word <>S_DIM
>1a0dbb	00 00				arity       .word <>0
>1ad0cb	43 41 4c 4c 00			TOKEN_TEXT  .null "CALL"
>1a0dbd	20				precedence  .byte TOK_TY_STMNT | 0
>1a0dbe	04				length      .byte len("CALL")
>1a0dbf	cb d0				name        .word <>TOKEN_TEXT
>1a0dc1	a9 3c				eval        .word <>S_CALL
>1a0dc3	00 00				arity       .word <>0
=$af					TOK_NEGATIVE = $AF
>1ad0d0	2d 00				TOKEN_TEXT  .null "-"
>1a0dc5	00				precedence  .byte TOK_TY_OP | 0
>1a0dc6	01				length      .byte len("-")
>1a0dc7	d0 d0				name        .word <>TOKEN_TEXT
>1a0dc9	f6 29				eval        .word <>OP_NEGATIVE
>1a0dcb	01 00				arity       .word <>1
>1ad0d2	4c 45 4e 00			TOKEN_TEXT  .null "LEN"
>1a0dcd	30				precedence  .byte TOK_TY_FUNC | 0
>1a0dce	03				length      .byte len("LEN")
>1a0dcf	d2 d0				name        .word <>TOKEN_TEXT
>1a0dd1	75 4a				eval        .word <>FN_LEN
>1a0dd3	00 00				arity       .word <>0
>1ad0d6	50 45 45 4b 00			TOKEN_TEXT  .null "PEEK"
>1a0dd5	30				precedence  .byte TOK_TY_FUNC | 0
>1a0dd6	04				length      .byte len("PEEK")
>1a0dd7	d6 d0				name        .word <>TOKEN_TEXT
>1a0dd9	c5 4a				eval        .word <>FN_PEEK
>1a0ddb	00 00				arity       .word <>0
>1ad0db	50 45 45 4b 57 00		TOKEN_TEXT  .null "PEEKW"
>1a0ddd	30				precedence  .byte TOK_TY_FUNC | 0
>1a0dde	05				length      .byte len("PEEKW")
>1a0ddf	db d0				name        .word <>TOKEN_TEXT
>1a0de1	77 4b				eval        .word <>FN_PEEKW
>1a0de3	00 00				arity       .word <>0
>1ad0e1	50 45 45 4b 4c 00		TOKEN_TEXT  .null "PEEKL"
>1a0de5	30				precedence  .byte TOK_TY_FUNC | 0
>1a0de6	05				length      .byte len("PEEKL")
>1a0de7	e1 d0				name        .word <>TOKEN_TEXT
>1a0de9	29 4b				eval        .word <>FN_PEEKL
>1a0deb	00 00				arity       .word <>0
>1ad0e7	43 48 52 24 00			TOKEN_TEXT  .null "CHR$"
>1a0ded	30				precedence  .byte TOK_TY_FUNC | 0
>1a0dee	04				length      .byte len("CHR$")
>1a0def	e7 d0				name        .word <>TOKEN_TEXT
>1a0df1	b6 4b				eval        .word <>FN_CHR
>1a0df3	00 00				arity       .word <>0
>1ad0ec	41 53 43 00			TOKEN_TEXT  .null "ASC"
>1a0df5	30				precedence  .byte TOK_TY_FUNC | 0
>1a0df6	03				length      .byte len("ASC")
>1a0df7	ec d0				name        .word <>TOKEN_TEXT
>1a0df9	0b 4c				eval        .word <>FN_ASC
>1a0dfb	00 00				arity       .word <>0
>1ad0f0	53 50 43 00			TOKEN_TEXT  .null "SPC"
>1a0dfd	30				precedence  .byte TOK_TY_FUNC | 0
>1a0dfe	03				length      .byte len("SPC")
>1a0dff	f0 d0				name        .word <>TOKEN_TEXT
>1a0e01	50 4c				eval        .word <>FN_SPC
>1a0e03	00 00				arity       .word <>0
>1ad0f4	54 41 42 00			TOKEN_TEXT  .null "TAB"
>1a0e05	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e06	03				length      .byte len("TAB")
>1a0e07	f4 d0				name        .word <>TOKEN_TEXT
>1a0e09	d9 4c				eval        .word <>FN_TAB
>1a0e0b	00 00				arity       .word <>0
>1ad0f8	41 42 53 00			TOKEN_TEXT  .null "ABS"
>1a0e0d	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e0e	03				length      .byte len("ABS")
>1a0e0f	f8 d0				name        .word <>TOKEN_TEXT
>1a0e11	62 4d				eval        .word <>FN_ABS
>1a0e13	00 00				arity       .word <>0
>1ad0fc	53 47 4e 00			TOKEN_TEXT  .null "SGN"
>1a0e15	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e16	03				length      .byte len("SGN")
>1a0e17	fc d0				name        .word <>TOKEN_TEXT
>1a0e19	c4 4d				eval        .word <>FN_SGN
>1a0e1b	00 00				arity       .word <>0
>1ad100	48 45 58 24 00			TOKEN_TEXT  .null "HEX$"
>1a0e1d	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e1e	04				length      .byte len("HEX$")
>1a0e1f	00 d1				name        .word <>TOKEN_TEXT
>1a0e21	e7 49				eval        .word <>FN_HEX
>1a0e23	00 00				arity       .word <>0
>1ad105	44 45 43 00			TOKEN_TEXT  .null "DEC"
>1a0e25	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e26	03				length      .byte len("DEC")
>1a0e27	05 d1				name        .word <>TOKEN_TEXT
>1a0e29	86 49				eval        .word <>FN_DEC
>1a0e2b	00 00				arity       .word <>0
>1ad109	53 54 52 24 00			TOKEN_TEXT  .null "STR$"
>1a0e2d	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e2e	04				length      .byte len("STR$")
>1a0e2f	09 d1				name        .word <>TOKEN_TEXT
>1a0e31	38 49				eval        .word <>FN_STR
>1a0e33	00 00				arity       .word <>0
>1ad10e	56 41 4c 00			TOKEN_TEXT  .null "VAL"
>1a0e35	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e36	03				length      .byte len("VAL")
>1a0e37	0e d1				name        .word <>TOKEN_TEXT
>1a0e39	e2 48				eval        .word <>FN_VAL
>1a0e3b	00 00				arity       .word <>0
>1ad112	4c 45 46 54 24 00		TOKEN_TEXT  .null "LEFT$"
>1a0e3d	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e3e	05				length      .byte len("LEFT$")
>1a0e3f	12 d1				name        .word <>TOKEN_TEXT
>1a0e41	19 48				eval        .word <>FN_LEFT
>1a0e43	00 00				arity       .word <>0
>1ad118	52 49 47 48 54 24 00		TOKEN_TEXT  .null "RIGHT$"
>1a0e45	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e46	06				length      .byte len("RIGHT$")
>1a0e47	18 d1				name        .word <>TOKEN_TEXT
>1a0e49	38 47				eval        .word <>FN_RIGHT
>1a0e4b	00 00				arity       .word <>0
>1ad11f	4d 49 44 24 00			TOKEN_TEXT  .null "MID$"
>1a0e4d	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e4e	04				length      .byte len("MID$")
>1a0e4f	1f d1				name        .word <>TOKEN_TEXT
>1a0e51	83 46				eval        .word <>FN_MID
>1a0e53	00 00				arity       .word <>0
>1ad124	52 55 4e 00			TOKEN_TEXT  .null "RUN"
>1a0e55	10				precedence  .byte TOK_TY_CMD | 0
>1a0e56	03				length      .byte len("RUN")
>1a0e57	24 d1				name        .word <>TOKEN_TEXT
>1a0e59	2b 4f				eval        .word <>CMD_RUN
>1a0e5b	00 00				arity       .word <>0
>1ad128	4e 45 57 00			TOKEN_TEXT  .null "NEW"
>1a0e5d	10				precedence  .byte TOK_TY_CMD | 0
>1a0e5e	03				length      .byte len("NEW")
>1a0e5f	28 d1				name        .word <>TOKEN_TEXT
>1a0e61	f6 4e				eval        .word <>CMD_NEW
>1a0e63	00 00				arity       .word <>0
>1ad12c	4c 4f 41 44 00			TOKEN_TEXT  .null "LOAD"
>1a0e65	10				precedence  .byte TOK_TY_CMD | 0
>1a0e66	04				length      .byte len("LOAD")
>1a0e67	2c d1				name        .word <>TOKEN_TEXT
>1a0e69	ff 6a				eval        .word <>CMD_LOAD
>1a0e6b	00 00				arity       .word <>0
>1ad131	4c 49 53 54 00			TOKEN_TEXT  .null "LIST"
>1a0e6d	10				precedence  .byte TOK_TY_CMD | 0
>1a0e6e	04				length      .byte len("LIST")
>1a0e6f	31 d1				name        .word <>TOKEN_TEXT
>1a0e71	42 4f				eval        .word <>CMD_LIST
>1a0e73	00 00				arity       .word <>0
>1ad136	44 49 52 00			TOKEN_TEXT  .null "DIR"
>1a0e75	10				precedence  .byte TOK_TY_CMD | 0
>1a0e76	03				length      .byte len("DIR")
>1a0e77	36 d1				name        .word <>TOKEN_TEXT
>1a0e79	26 68				eval        .word <>CMD_DIR
>1a0e7b	00 00				arity       .word <>0
>1ad13a	42 4c 4f 41 44 00		TOKEN_TEXT  .null "BLOAD"
>1a0e7d	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e7e	05				length      .byte len("BLOAD")
>1a0e7f	3a d1				name        .word <>TOKEN_TEXT
>1a0e81	d1 69				eval        .word <>S_BLOAD
>1a0e83	00 00				arity       .word <>0
>1ad140	42 52 55 4e 00			TOKEN_TEXT  .null "BRUN"
>1a0e85	10				precedence  .byte TOK_TY_CMD | 0
>1a0e86	04				length      .byte len("BRUN")
>1a0e87	40 d1				name        .word <>TOKEN_TEXT
>1a0e89	ac 6a				eval        .word <>CMD_BRUN
>1a0e8b	00 00				arity       .word <>0
>1ad145	42 53 41 56 45 00		TOKEN_TEXT  .null "BSAVE"
>1a0e8d	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e8e	05				length      .byte len("BSAVE")
>1a0e8f	45 d1				name        .word <>TOKEN_TEXT
>1a0e91	b8 6b				eval        .word <>S_BSAVE
>1a0e93	00 00				arity       .word <>0
>1ad14b	44 45 4c 00			TOKEN_TEXT  .null "DEL"
>1a0e95	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e96	03				length      .byte len("DEL")
>1a0e97	4b d1				name        .word <>TOKEN_TEXT
>1a0e99	d7 6c				eval        .word <>S_DEL
>1a0e9b	00 00				arity       .word <>0
>1ad14f	53 41 56 45 00			TOKEN_TEXT  .null "SAVE"
>1a0e9d	10				precedence  .byte TOK_TY_CMD | 0
>1a0e9e	04				length      .byte len("SAVE")
>1a0e9f	4f d1				name        .word <>TOKEN_TEXT
>1a0ea1	44 6c				eval        .word <>CMD_SAVE
>1a0ea3	00 00				arity       .word <>0
>1ad154	52 45 4e 41 4d 45 00		TOKEN_TEXT  .null "RENAME"
>1a0ea5	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ea6	06				length      .byte len("RENAME")
>1a0ea7	54 d1				name        .word <>TOKEN_TEXT
>1a0ea9	4d 6d				eval        .word <>S_RENAME
>1a0eab	00 00				arity       .word <>0
>1ad15b	43 4f 50 59 00			TOKEN_TEXT  .null "COPY"
>1a0ead	20				precedence  .byte TOK_TY_STMNT | 0
>1a0eae	04				length      .byte len("COPY")
>1a0eaf	5b d1				name        .word <>TOKEN_TEXT
>1a0eb1	71 6e				eval        .word <>S_COPY
>1a0eb3	00 00				arity       .word <>0
>1ad160	4d 4f 4e 49 54 4f 52 00		TOKEN_TEXT  .null "MONITOR"
>1a0eb5	10				precedence  .byte TOK_TY_CMD | 0
>1a0eb6	07				length      .byte len("MONITOR")
>1a0eb7	60 d1				name        .word <>TOKEN_TEXT
>1a0eb9	f3 4e				eval        .word <>CMD_MONITOR
>1a0ebb	00 00				arity       .word <>0
>1ad168	47 45 54 00			TOKEN_TEXT  .null "GET"
>1a0ebd	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ebe	03				length      .byte len("GET")
>1a0ebf	68 d1				name        .word <>TOKEN_TEXT
>1a0ec1	37 3c				eval        .word <>S_GET
>1a0ec3	00 00				arity       .word <>0
>1ad16c	49 4e 50 55 54 00		TOKEN_TEXT  .null "INPUT"
>1a0ec5	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ec6	05				length      .byte len("INPUT")
>1a0ec7	6c d1				name        .word <>TOKEN_TEXT
>1a0ec9	47 3b				eval        .word <>S_INPUT
>1a0ecb	00 00				arity       .word <>0
>1ad172	53 45 54 42 4f 52 44 45		TOKEN_TEXT  .null "SETBORDER"
>1ad17a	52 00
>1a0ecd	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ece	09				length      .byte len("SETBORDER")
>1a0ecf	72 d1				name        .word <>TOKEN_TEXT
>1a0ed1	b5 2b				eval        .word <>S_SETBORDER
>1a0ed3	00 00				arity       .word <>0
>1ad17c	54 45 58 54 43 4f 4c 4f		TOKEN_TEXT  .null "TEXTCOLOR"
>1ad184	52 00
>1a0ed5	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ed6	09				length      .byte len("TEXTCOLOR")
>1a0ed7	7c d1				name        .word <>TOKEN_TEXT
>1a0ed9	42 2b				eval        .word <>S_TEXTCOLOR
>1a0edb	00 00				arity       .word <>0
>1ad186	53 45 54 42 47 43 4f 4c		TOKEN_TEXT  .null "SETBGCOLOR"
>1ad18e	4f 52 00
>1a0edd	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ede	0a				length      .byte len("SETBGCOLOR")
>1a0edf	86 d1				name        .word <>TOKEN_TEXT
>1a0ee1	72 2b				eval        .word <>S_SETBGCOLOR
>1a0ee3	00 00				arity       .word <>0
>1ad191	53 45 54 44 41 54 45 00		TOKEN_TEXT  .null "SETDATE"
>1a0ee5	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ee6	07				length      .byte len("SETDATE")
>1a0ee7	91 d1				name        .word <>TOKEN_TEXT
>1a0ee9	af 2a				eval        .word <>S_SETDATE
>1a0eeb	00 00				arity       .word <>0
>1ad199	47 45 54 44 41 54 45 24		TOKEN_TEXT  .null "GETDATE$"
>1ad1a1	00
>1a0eed	30				precedence  .byte TOK_TY_FUNC | 0
>1a0eee	08				length      .byte len("GETDATE$")
>1a0eef	99 d1				name        .word <>TOKEN_TEXT
>1a0ef1	5e 45				eval        .word <>F_GETDATE
>1a0ef3	00 00				arity       .word <>0
>1ad1a2	53 45 54 54 49 4d 45 00		TOKEN_TEXT  .null "SETTIME"
>1a0ef5	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ef6	07				length      .byte len("SETTIME")
>1a0ef7	a2 d1				name        .word <>TOKEN_TEXT
>1a0ef9	44 2a				eval        .word <>S_SETTIME
>1a0efb	00 00				arity       .word <>0
>1ad1aa	47 45 54 54 49 4d 45 24		TOKEN_TEXT  .null "GETTIME$"
>1ad1b2	00
>1a0efd	30				precedence  .byte TOK_TY_FUNC | 0
>1a0efe	08				length      .byte len("GETTIME$")
>1a0eff	aa d1				name        .word <>TOKEN_TEXT
>1a0f01	c8 45				eval        .word <>F_GETTIME
>1a0f03	00 00				arity       .word <>0
>1ad1b3	47 52 41 50 48 49 43 53		TOKEN_TEXT  .null "GRAPHICS"
>1ad1bb	00
>1a0f05	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f06	08				length      .byte len("GRAPHICS")
>1a0f07	b3 d1				name        .word <>TOKEN_TEXT
>1a0f09	fa 2c				eval        .word <>S_GRAPHICS
>1a0f0b	00 00				arity       .word <>0
>1ad1bc	53 45 54 43 4f 4c 4f 52		TOKEN_TEXT  .null "SETCOLOR"
>1ad1c4	00
>1a0f0d	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f0e	08				length      .byte len("SETCOLOR")
>1a0f0f	bc d1				name        .word <>TOKEN_TEXT
>1a0f11	2e 2c				eval        .word <>S_SETCOLOR
>1a0f13	00 00				arity       .word <>0
>1ad1c5	42 49 54 4d 41 50 00		TOKEN_TEXT  .null "BITMAP"
>1a0f15	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f16	06				length      .byte len("BITMAP")
>1a0f17	c5 d1				name        .word <>TOKEN_TEXT
>1a0f19	34 2e				eval        .word <>S_BITMAP
>1a0f1b	00 00				arity       .word <>0
>1ad1cc	43 4c 52 42 49 54 4d 41		TOKEN_TEXT  .null "CLRBITMAP"
>1ad1d4	50 00
>1a0f1d	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f1e	09				length      .byte len("CLRBITMAP")
>1a0f1f	cc d1				name        .word <>TOKEN_TEXT
>1a0f21	3c 2f				eval        .word <>S_CLRBITMAP
>1a0f23	00 00				arity       .word <>0
>1ad1d6	50 4c 4f 54 00			TOKEN_TEXT  .null "PLOT"
>1a0f25	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f26	04				length      .byte len("PLOT")
>1a0f27	d6 d1				name        .word <>TOKEN_TEXT
>1a0f29	4c 30				eval        .word <>S_PLOT
>1a0f2b	00 00				arity       .word <>0
>1ad1db	4c 49 4e 45 00			TOKEN_TEXT  .null "LINE"
>1a0f2d	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f2e	04				length      .byte len("LINE")
>1a0f2f	db d1				name        .word <>TOKEN_TEXT
>1a0f31	bd 30				eval        .word <>S_LINE
>1a0f33	00 00				arity       .word <>0
>1ad1e0	46 49 4c 4c 00			TOKEN_TEXT  .null "FILL"
>1a0f35	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f36	04				length      .byte len("FILL")
>1a0f37	e0 d1				name        .word <>TOKEN_TEXT
>1a0f39	56 31				eval        .word <>S_FILL
>1a0f3b	00 00				arity       .word <>0
>1ad1e5	53 50 52 49 54 45 00		TOKEN_TEXT  .null "SPRITE"
>1a0f3d	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f3e	06				length      .byte len("SPRITE")
>1a0f3f	e5 d1				name        .word <>TOKEN_TEXT
>1a0f41	92 32				eval        .word <>S_SPRITE
>1a0f43	00 00				arity       .word <>0
>1ad1ec	53 50 52 49 54 45 41 54		TOKEN_TEXT  .null "SPRITEAT"
>1ad1f4	00
>1a0f45	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f46	08				length      .byte len("SPRITEAT")
>1a0f47	ec d1				name        .word <>TOKEN_TEXT
>1a0f49	30 33				eval        .word <>S_SPRITEAT
>1a0f4b	00 00				arity       .word <>0
>1ad1f5	53 50 52 49 54 45 53 48		TOKEN_TEXT  .null "SPRITESHOW"
>1ad1fd	4f 57 00
>1a0f4d	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f4e	0a				length      .byte len("SPRITESHOW")
>1a0f4f	f5 d1				name        .word <>TOKEN_TEXT
>1a0f51	7e 33				eval        .word <>S_SPRITESHOW
>1a0f53	00 00				arity       .word <>0
>1ad200	54 49 4c 45 53 45 54 00		TOKEN_TEXT  .null "TILESET"
>1a0f55	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f56	07				length      .byte len("TILESET")
>1a0f57	00 d2				name        .word <>TOKEN_TEXT
>1a0f59	b5 34				eval        .word <>S_TILESET
>1a0f5b	00 00				arity       .word <>0
>1ad208	54 49 4c 45 4d 41 50 00		TOKEN_TEXT  .null "TILEMAP"
>1a0f5d	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f5e	07				length      .byte len("TILEMAP")
>1a0f5f	08 d2				name        .word <>TOKEN_TEXT
>1a0f61	33 35				eval        .word <>S_TILEMAP
>1a0f63	00 00				arity       .word <>0
>1ad210	54 49 4c 45 53 48 4f 57		TOKEN_TEXT  .null "TILESHOW"
>1ad218	00
>1a0f65	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f66	08				length      .byte len("TILESHOW")
>1a0f67	10 d2				name        .word <>TOKEN_TEXT
>1a0f69	a5 35				eval        .word <>S_TILESHOW
>1a0f6b	00 00				arity       .word <>0
>1ad219	54 49 4c 45 41 54 00		TOKEN_TEXT  .null "TILEAT"
>1a0f6d	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f6e	06				length      .byte len("TILEAT")
>1a0f6f	19 d2				name        .word <>TOKEN_TEXT
>1a0f71	e2 35				eval        .word <>S_TILEAT
>1a0f73	00 00				arity       .word <>0
>1ad220	4d 45 4d 43 4f 50 59 00		TOKEN_TEXT  .null "MEMCOPY"
>1a0f75	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f76	07				length      .byte len("MEMCOPY")
>1a0f77	20 d2				name        .word <>TOKEN_TEXT
>1a0f79	12 39				eval        .word <>S_MEMCOPY
>1a0f7b	00 00				arity       .word <>0
=$e6					TOK_LINEAR = $E6
>1ad228	4c 49 4e 45 41 52 00		TOKEN_TEXT  .null "LINEAR"
>1a0f7d	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0f7e	06				length      .byte len("LINEAR")
>1a0f7f	28 d2				name        .word <>TOKEN_TEXT
>1a0f81	00 00				eval        .word <>0
>1a0f83	00 00				arity       .word <>0
=$e7					TOK_RECT = $E7
>1ad22f	52 45 43 54 00			TOKEN_TEXT  .null "RECT"
>1a0f85	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0f86	04				length      .byte len("RECT")
>1a0f87	2f d2				name        .word <>TOKEN_TEXT
>1a0f89	00 00				eval        .word <>0
>1a0f8b	00 00				arity       .word <>0
>1ad234	4c 4f 43 41 54 45 00		TOKEN_TEXT  .null "LOCATE"
>1a0f8d	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f8e	06				length      .byte len("LOCATE")
>1a0f8f	34 d2				name        .word <>TOKEN_TEXT
>1a0f91	27 3b				eval        .word <>S_LOCATE
>1a0f93	00 00				arity       .word <>0
>1ad23b	49 4e 54 00			TOKEN_TEXT  .null "INT"
>1a0f95	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f96	03				length      .byte len("INT")
>1a0f97	3b d2				name        .word <>TOKEN_TEXT
>1a0f99	1a 4e				eval        .word <>FN_INT
>1a0f9b	00 00				arity       .word <>0
>1ad23f	52 4e 44 00			TOKEN_TEXT  .null "RND"
>1a0f9d	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f9e	03				length      .byte len("RND")
>1a0f9f	3f d2				name        .word <>TOKEN_TEXT
>1a0fa1	2d 46				eval        .word <>FN_RND
>1a0fa3	00 00				arity       .word <>0
>1ad243	53 49 4e 00			TOKEN_TEXT  .null "SIN"
>1a0fa5	30				precedence  .byte TOK_TY_FUNC | 0
>1a0fa6	03				length      .byte len("SIN")
>1a0fa7	43 d2				name        .word <>TOKEN_TEXT
>1a0fa9	2d 4e				eval        .word <>FN_SIN
>1a0fab	00 00				arity       .word <>0
>1ad247	43 4f 53 00			TOKEN_TEXT  .null "COS"
>1a0fad	30				precedence  .byte TOK_TY_FUNC | 0
>1a0fae	03				length      .byte len("COS")
>1a0faf	47 d2				name        .word <>TOKEN_TEXT
>1a0fb1	43 4e				eval        .word <>FN_COS
>1a0fb3	00 00				arity       .word <>0
>1ad24b	54 41 4e 00			TOKEN_TEXT  .null "TAN"
>1a0fb5	30				precedence  .byte TOK_TY_FUNC | 0
>1a0fb6	03				length      .byte len("TAN")
>1a0fb7	4b d2				name        .word <>TOKEN_TEXT
>1a0fb9	59 4e				eval        .word <>FN_TAN
>1a0fbb	00 00				arity       .word <>0
>1ad24f	4c 4e 00			TOKEN_TEXT  .null "LN"
>1a0fbd	30				precedence  .byte TOK_TY_FUNC | 0
>1a0fbe	02				length      .byte len("LN")
>1a0fbf	4f d2				name        .word <>TOKEN_TEXT
>1a0fc1	6f 4e				eval        .word <>FN_LN
>1a0fc3	00 00				arity       .word <>0
>1ad252	41 43 4f 53 00			TOKEN_TEXT  .null "ACOS"
>1a0fc5	30				precedence  .byte TOK_TY_FUNC | 0
>1a0fc6	04				length      .byte len("ACOS")
>1a0fc7	52 d2				name        .word <>TOKEN_TEXT
>1a0fc9	85 4e				eval        .word <>FN_ACOS
>1a0fcb	00 00				arity       .word <>0
>1ad257	41 53 49 4e 00			TOKEN_TEXT  .null "ASIN"
>1a0fcd	30				precedence  .byte TOK_TY_FUNC | 0
>1a0fce	04				length      .byte len("ASIN")
>1a0fcf	57 d2				name        .word <>TOKEN_TEXT
>1a0fd1	9b 4e				eval        .word <>FN_ASIN
>1a0fd3	00 00				arity       .word <>0
>1ad25c	41 54 41 4e 00			TOKEN_TEXT  .null "ATAN"
>1a0fd5	30				precedence  .byte TOK_TY_FUNC | 0
>1a0fd6	04				length      .byte len("ATAN")
>1a0fd7	5c d2				name        .word <>TOKEN_TEXT
>1a0fd9	b1 4e				eval        .word <>FN_ATAN
>1a0fdb	00 00				arity       .word <>0
>1ad261	45 58 50 00			TOKEN_TEXT  .null "EXP"
>1a0fdd	30				precedence  .byte TOK_TY_FUNC | 0
>1a0fde	03				length      .byte len("EXP")
>1a0fdf	61 d2				name        .word <>TOKEN_TEXT
>1a0fe1	c7 4e				eval        .word <>FN_EXP
>1a0fe3	00 00				arity       .word <>0
>1ad265	53 51 52 00			TOKEN_TEXT  .null "SQR"
>1a0fe5	30				precedence  .byte TOK_TY_FUNC | 0
>1a0fe6	03				length      .byte len("SQR")
>1a0fe7	65 d2				name        .word <>TOKEN_TEXT
>1a0fe9	dd 4e				eval        .word <>FN_SQR
>1a0feb	00 00				arity       .word <>0
>1a0fed	00 00 00 00 00 00 00 00		            .word 0, 0, 0, 0

;******  Return to file: src\basic816.s


;******  Processing file: src\heap.s

>08b7					ALLOCATED   .long ?     ; Pointer to the most recently allocated object
>08ba					HEAP        .long ?     ; Pointer to the top of the heap (next empty byte)
>08bd					FREED       .long ?     ; Pointer to a linked list of freed heap objects
>08c0					CURRBLOCK   .long ?     ; Pointer to the current heap allocated block
>08c3					CURRHEADER  .long ?     ; Pointer to the header of the current block
>08c6					CURREND     .long ?     ; Pointer to the byte immediately after the current block
>08c9					CURRFREED   .long ?     ; Pointer to the current freed block
>08cc					FREEDEND    .long ?     ; Pointer to the byte immediately after the current freed block
>08cf					LASTFREED   .long ?     ;
.0000					HEAPOBJ
>0000					TYPE        .byte ?     ; Code for the type of object allocated
>0001					COUNT       .byte ?     ; Number of references to the heap object
>0002					NEXT        .long ?     ; Pointer to the next object in the list (used when freed)
>0005					END         .long ?     ; Pointer to the next byte after the block
.1a0ff5					INITHEAP
.1a0ff5	08		php		            PHP
.1a0ff6	0b		phd		            PHD
.1a0ff7	08		php		            PHP
.1a0ff8	c2 20		rep #$20	            REP #$20
.1a0ffa	48		pha		            PHA
.1a0ffb	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0ffe	5b		tcd		            TCD
.1a0fff	68		pla		            PLA
.1a1000	28		plp		            PLP
.1a1001	c2 30		rep #$30	            REP #$30
.1a1003	a9 ff ff	lda #$ffff	            LDA #<>HEAP_TOP         ; Set the HEAP to the top
.1a1006	85 ba		sta $08ba	            STA HEAP
.1a1008	e2 20		sep #$20	            SEP #$20
.1a100a	a9 17		lda #$17	            LDA #`HEAP_TOP
.1a100c	85 bc		sta $08bc	            STA HEAP+2
.1a100e	c2 20		rep #$20	            REP #$20
.1a1010	64 b7		stz $08b7	            STZ ALLOCATED           ; And clear the pointer to the allocated objects
.1a1012	64 bd		stz $08bd	            STZ FREED               ; as well as the list of freed objects
.1a1014	e2 20		sep #$20	            SEP #$20
.1a1016	64 b9		stz $08b9	            STZ ALLOCATED+2
.1a1018	64 bf		stz $08bf	            STZ FREED+2
.1a101a	2b		pld		            PLD
.1a101b	28		plp		            PLP
.1a101c	60		rts		            RTS
.1a101d					ALLOC
.1a101d	5a		phy		            PHY
.1a101e	08		php		            PHP
.1a101f	e2 20		sep #$20	            SEP #$20
.1a1021	85 ea		sta $08ea	            STA TOFINDTYPE      ; Save the type of the block to TOFINDTYPE
.1a1023	c2 10		rep #$10	            REP #$10
.1a1025	86 8f		stx $088f	            STX MCOUNT           ; And the length of the block needed to MCOUNT
.1a1027	c2 20		rep #$20	            REP #$20
.1a1029	a5 0e		lda $080e	            LDA SCRATCH+2
.1a102b	48		pha		            PHA
.1a102c	a5 0c		lda $080c	            LDA SCRATCH
.1a102e	48		pha		            PHA
.1a102f	a5 12		lda $0812	            LDA SCRATCH2+2
.1a1031	48		pha		            PHA
.1a1032	a5 10		lda $0810	            LDA SCRATCH2
.1a1034	48		pha		            PHA
.1a1035	20 cd 10	jsr $1a10cd	            JSR ALLOCFREED
.1a1038	b0 03		bcs $1a103d	            BCS done            ; Return, if we got something back
.1a103a	20 51 10	jsr $1a1051	            JSR ALLOCHEAP
.1a103d					done
.1a103d	20 59 12	jsr $1a1259	            JSR HEAP_GETHED
.1a1040	c2 20		rep #$20	            REP #$20
.1a1042	68		pla		            PLA
.1a1043	85 10		sta $0810	            STA SCRATCH2
.1a1045	68		pla		            PLA
.1a1046	85 12		sta $0812	            STA SCRATCH2+2
.1a1048	68		pla		            PLA
.1a1049	85 0c		sta $080c	            STA SCRATCH
.1a104b	68		pla		            PLA
.1a104c	85 0e		sta $080e	            STA SCRATCH+2
.1a104e	28		plp		            PLP
.1a104f	7a		ply		            PLY
.1a1050	60		rts		            RTS
.1a1051					ALLOCHEAP
.1a1051	08		php		            PHP
.1a1052	0b		phd		            PHD
.1a1053	08		php		            PHP
.1a1054	c2 20		rep #$20	            REP #$20
.1a1056	48		pha		            PHA
.1a1057	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a105a	5b		tcd		            TCD
.1a105b	68		pla		            PLA
.1a105c	28		plp		            PLP
.1a105d	e2 20		sep #$20	            SEP #$20
.1a105f	a6 8f		ldx $088f	            LDX MCOUNT
.1a1061	ca		dex		            DEX
.1a1062	86 0c		stx $080c	            STX SCRATCH             ; SCRATCH := size - 1
.1a1064	e8		inx		            INX
.1a1065	c2 30		rep #$30	            REP #$30
.1a1067	38		sec		            SEC
.1a1068	a5 ba		lda $08ba	            LDA HEAP
.1a106a	e5 0c		sbc $080c	            SBC SCRATCH
.1a106c	85 c0		sta $08c0	            STA CURRBLOCK
.1a106e	e2 20		sep #$20	            SEP #$20
.1a1070	a5 bc		lda $08bc	            LDA HEAP+2
.1a1072	e9 00		sbc #$00	            SBC #0
.1a1074	85 c2		sta $08c2	            STA CURRBLOCK+2
.1a1076	20 59 12	jsr $1a1259	            JSR HEAP_GETHED
.1a1079	e2 20		sep #$20	            SEP #$20
.1a107b	a5 ea		lda $08ea	            LDA TOFINDTYPE
.1a107d	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE       ; Set the type of the object
.1a1080	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1082	a9 00		lda #$00	            LDA #0                  ; Set the count to zero
.1a1084	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.1a1087	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1089	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a108c	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a108e	c2 20		rep #$20	            REP #$20
.1a1090	a9 00 00	lda #$0000	            LDA #0
.1a1093	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1095	c2 20		rep #$20	            REP #$20
.1a1097	18		clc		            CLC
.1a1098	a5 ba		lda $08ba	            LDA HEAP
.1a109a	69 01 00	adc #$0001	            ADC #1
.1a109d	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; To get the address of the next byte
.1a10a0	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y      ; after the block
.1a10a2	e2 20		sep #$20	            SEP #$20
.1a10a4	c8		iny		            INY
.1a10a5	c8		iny		            INY
.1a10a6	a5 bc		lda $08bc	            LDA HEAP+2
.1a10a8	69 00		adc #$00	            ADC #0
.1a10aa	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a10ac	c2 20		rep #$20	            REP #$20
.1a10ae	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a10b0	85 b7		sta $08b7	            STA ALLOCATED
.1a10b2	e2 20		sep #$20	            SEP #$20
.1a10b4	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a10b6	85 b9		sta $08b9	            STA ALLOCATED+2
.1a10b8	c2 20		rep #$20	            REP #$20
.1a10ba	38		sec		            SEC                     ; Move the HEAP pointer to the first free byte under the header
.1a10bb	a5 c3		lda $08c3	            LDA CURRHEADER
.1a10bd	e9 01 00	sbc #$0001	            SBC #1
.1a10c0	85 ba		sta $08ba	            STA HEAP
.1a10c2	e2 20		sep #$20	            SEP #$20
.1a10c4	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a10c6	e9 00		sbc #$00	            SBC #0
.1a10c8	85 bc		sta $08bc	            STA HEAP+2
.1a10ca	2b		pld		            PLD
.1a10cb	28		plp		            PLP
.1a10cc	60		rts		            RTS
.1a10cd					ALLOCFREED
.1a10cd	08		php		            PHP
.1a10ce	0b		phd		            PHD
.1a10cf	08		php		            PHP
.1a10d0	c2 20		rep #$20	            REP #$20
.1a10d2	48		pha		            PHA
.1a10d3	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a10d6	5b		tcd		            TCD
.1a10d7	68		pla		            PLA
.1a10d8	28		plp		            PLP
.1a10d9	c2 30		rep #$30	            REP #$30
.1a10db	c2 20		rep #$20	            REP #$20
.1a10dd	a5 bd		lda $08bd	            LDA FREED
.1a10df	85 c9		sta $08c9	            STA CURRFREED
.1a10e1	e2 20		sep #$20	            SEP #$20
.1a10e3	a5 bf		lda $08bf	            LDA FREED+2
.1a10e5	85 cb		sta $08cb	            STA CURRFREED+2
.1a10e7	a5 c9		lda $08c9	loop        LDA CURRFREED           ; Has anything been freed?
.1a10e9	d0 17		bne $1a1102	            BNE has_block           ; Yes: check to see if there's a big enough block
.1a10eb	e2 20		sep #$20	            SEP #$20
.1a10ed	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a10ef	d0 11		bne $1a1102	            BNE has_block           ; Yes: check to see if there's a big enough block
.1a10f1	c2 20		rep #$20	            REP #$20
.1a10f3	a9 00 00	lda #$0000	            LDA #<>0
.1a10f6	85 cf		sta $08cf	            STA LASTFREED
.1a10f8	e2 20		sep #$20	            SEP #$20
.1a10fa	a9 00		lda #$00	            LDA #`0
.1a10fc	85 d1		sta $08d1	            STA LASTFREED+2
.1a10fe	2b		pld		ret_false   PLD                     ; Return that we didn't find anything
.1a10ff	28		plp		            PLP
.1a1100	18		clc		            CLC
.1a1101	60		rts		            RTS
.1a1102					has_block
.1a1102	c2 20		rep #$20	            REP #$20
.1a1104	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.1a1107	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1109	85 cc		sta $08cc	            STA FREEDEND
.1a110b	e2 20		sep #$20	            SEP #$20
.1a110d	c8		iny		            INY
.1a110e	c8		iny		            INY
.1a110f	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1111	85 ce		sta $08ce	            STA FREEDEND+2
.1a1113	c2 20		rep #$20	            REP #$20
.1a1115	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required
.1a1116	a5 c9		lda $08c9	            LDA CURRFREED
.1a1118	65 8f		adc $088f	            ADC MCOUNT
.1a111a	85 0c		sta $080c	            STA SCRATCH
.1a111c	e2 20		sep #$20	            SEP #$20
.1a111e	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a1120	69 00		adc #$00	            ADC #0
.1a1122	85 0e		sta $080e	            STA SCRATCH+2
.1a1124	c2 20		rep #$20	            REP #$20
.1a1126	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required + size of header
.1a1127	a5 0c		lda $080c	            LDA SCRATCH                 ; (that is, it's a pointer to the byte immediately after the block desired)
.1a1129	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)
.1a112c	85 0c		sta $080c	            STA SCRATCH
.1a112e	e2 20		sep #$20	            SEP #$20
.1a1130	a5 0e		lda $080e	            LDA SCRATCH+2
.1a1132	69 00		adc #$00	            ADC #0
.1a1134	85 0e		sta $080e	            STA SCRATCH+2
.1a1136	c2 20		rep #$20	            REP #$20
.1a1138	a5 0c		lda $080c	            LDA SCRATCH                 ; Is SCRATCH == FREEDEND?
.1a113a	c5 cc		cmp $08cc	            CMP FREEDEND
.1a113c	d0 28		bne $1a1166	            BNE not_exact               ; No: check if this block is bigger than needed
.1a113e	e2 20		sep #$20	            SEP #$20
.1a1140	a5 0e		lda $080e	            LDA SCRATCH+2
.1a1142	c5 ce		cmp $08ce	            CMP FREEDEND+2
.1a1144	d0 20		bne $1a1166	            BNE not_exact
.1a1146	c2 20		rep #$20	            REP #$20
.1a1148	a5 cf		lda $08cf	            LDA LASTFREED               ; LASTFREED == 0?
.1a114a	d0 5d		bne $1a11a9	            BNE adj_last1               ; No: point LASTFREED->NEXT to skip this block
.1a114c	e2 20		sep #$20	            SEP #$20
.1a114e	a5 d1		lda $08d1	            LDA LASTFREED+2
.1a1150	d0 57		bne $1a11a9	            BNE adj_last1
.1a1152	c2 20		rep #$20	            REP #$20
.1a1154	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1157	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1159	85 bd		sta $08bd	            STA FREED
.1a115b	e2 20		sep #$20	            SEP #$20
.1a115d	c8		iny		            INY
.1a115e	c8		iny		            INY
.1a115f	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1161	85 bf		sta $08bf	            STA FREED+2
.1a1163	4c 0a 12	jmp $1a120a	            JMP init_block              ; And return CURRFREED as our reallocated memory
.1a1166					not_exact
.1a1166	c2 20		rep #$20	            REP #$20
.1a1168	a5 0c		lda $080c	            LDA SCRATCH                 ; Add a buffer to the room needed
.1a116a	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)          ; So we have room to track the memory still freed
.1a116d	85 10		sta $0810	            STA SCRATCH2
.1a116f	e2 20		sep #$20	            SEP #$20
.1a1171	a5 0e		lda $080e	            LDA SCRATCH+2
.1a1173	69 00		adc #$00	            ADC #0
.1a1175	85 12		sta $0812	            STA SCRATCH2+2
.1a1177	e2 20		sep #$20	            SEP #$20
.1a1179	a5 c6		lda $08c6	            LDA CURREND                 ; Is CURREND > SCRATCH2
.1a117b	c5 10		cmp $0810	            CMP SCRATCH2
.1a117d	b0 3e		bcs $1a11bd	            BGE has_room                ; Yes: there is room in this block to allocate some memory
.1a117f	90 08		bcc $1a1189	            BLT try_next
.1a1181	c2 20		rep #$20	            REP #$20
.1a1183	a5 c6		lda $08c6	            LDA CURREND
.1a1185	c5 10		cmp $0810	            CMP SCRATCH2
.1a1187	b0 34		bcs $1a11bd	            BGE has_room
.1a1189					try_next
.1a1189	c2 20		rep #$20	            REP #$20
.1a118b	a5 c9		lda $08c9	            LDA CURRFREED
.1a118d	85 cf		sta $08cf	            STA LASTFREED
.1a118f	e2 20		sep #$20	            SEP #$20
.1a1191	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a1193	85 d1		sta $08d1	            STA LASTFREED+2
.1a1195	c2 20		rep #$20	            REP #$20
.1a1197	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a119a	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.1a119c	85 c9		sta $08c9	            STA CURRFREED
.1a119e	e2 20		sep #$20	            SEP #$20
.1a11a0	c8		iny		            INY
.1a11a1	c8		iny		            INY
.1a11a2	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.1a11a4	85 cb		sta $08cb	            STA CURRFREED+2
.1a11a6	4c e7 10	jmp $1a10e7	            JMP loop                                    ; And try the next header
.1a11a9					adj_last1
.1a11a9	c2 20		rep #$20	            REP #$20
.1a11ab	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := CURRFREED->NEXT
.1a11ae	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a11b0	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.1a11b2	e2 20		sep #$20	            SEP #$20
.1a11b4	c8		iny		            INY
.1a11b5	c8		iny		            INY
.1a11b6	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a11b8	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.1a11ba	4c 0a 12	jmp $1a120a	            JMP init_block              ; And get CURRFREED ready to return
.1a11bd					has_room
.1a11bd	c2 20		rep #$20	            REP #$20
.1a11bf	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END            ; SCRATCH->END := CURRFREED->END
.1a11c2	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a11c4	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a11c6	e2 20		sep #$20	            SEP #$20
.1a11c8	c8		iny		            INY
.1a11c9	c8		iny		            INY
.1a11ca	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a11cc	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a11ce	c2 20		rep #$20	            REP #$20
.1a11d0	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; CURREND->NEXT := CURRFREED->NEXT
.1a11d3	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a11d5	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a11d7	e2 20		sep #$20	            SEP #$20
.1a11d9	c8		iny		            INY
.1a11da	c8		iny		            INY
.1a11db	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a11dd	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a11df	c2 20		rep #$20	            REP #$20
.1a11e1	a5 cf		lda $08cf	            LDA LASTFREED               ; Is this the first object we've examined?
.1a11e3	d0 14		bne $1a11f9	            BNE adj_last2               ; No: we'll need to adjust the previously examined block
.1a11e5	e2 20		sep #$20	            SEP #$20
.1a11e7	a5 cf		lda $08cf	            LDA LASTFREED
.1a11e9	d0 0e		bne $1a11f9	            BNE adj_last2
.1a11eb	c2 20		rep #$20	            REP #$20
.1a11ed	a5 0c		lda $080c	            LDA SCRATCH
.1a11ef	85 bd		sta $08bd	            STA FREED
.1a11f1	e2 20		sep #$20	            SEP #$20
.1a11f3	a5 0e		lda $080e	            LDA SCRATCH+2
.1a11f5	85 bf		sta $08bf	            STA FREED+2
.1a11f7	80 11		bra $1a120a	            BRA init_block              ; ... and return the block we've sliced off
.1a11f9					adj_last2
.1a11f9	c2 20		rep #$20	            REP #$20
.1a11fb	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := SCRATCH
.1a11fe	a5 0c		lda $080c	            LDA SCRATCH                 ; (point the previous freed block to the newly sliced
.1a1200	97 cf		sta [$08cf],y	            STA [LASTFREED],Y           ;  off part of the current block)
.1a1202	e2 20		sep #$20	            SEP #$20
.1a1204	c8		iny		            INY
.1a1205	c8		iny		            INY
.1a1206	a5 0e		lda $080e	            LDA SCRATCH+2
.1a1208	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.1a120a					init_block
.1a120a	c2 20		rep #$20	            REP #$20
.1a120c	a5 c9		lda $08c9	            LDA CURRFREED
.1a120e	85 c3		sta $08c3	            STA CURRHEADER
.1a1210	e2 20		sep #$20	            SEP #$20
.1a1212	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a1214	85 c5		sta $08c5	            STA CURRHEADER+2
.1a1216	c2 20		rep #$20	            REP #$20
.1a1218	a5 c3		lda $08c3	            LDA CURRHEADER
.1a121a	85 b7		sta $08b7	            STA ALLOCATED
.1a121c	e2 20		sep #$20	            SEP #$20
.1a121e	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1220	85 b9		sta $08b9	            STA ALLOCATED+2
.1a1222	c2 20		rep #$20	            REP #$20
.1a1224	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; Set CURRHEADER->END to the byte after the block
.1a1227	a5 0c		lda $080c	            LDA SCRATCH
.1a1229	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a122b	e2 20		sep #$20	            SEP #$20
.1a122d	c8		iny		            INY
.1a122e	c8		iny		            INY
.1a122f	a5 0e		lda $080e	            LDA SCRATCH+2
.1a1231	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1233	c2 20		rep #$20	            REP #$20
.1a1235	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Set CURRHEADER->NEXT to NULL
.1a1238	a9 00 00	lda #$0000	            LDA #0
.1a123b	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a123d	e2 20		sep #$20	            SEP #$20
.1a123f	c8		iny		            INY
.1a1240	c8		iny		            INY
.1a1241	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1243	e2 20		sep #$20	            SEP #$20
.1a1245	a5 ea		lda $08ea	            LDA TOFINDTYPE          ; Get the type code back
.1a1247	e2 20		sep #$20	            SEP #$20
.1a1249	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE
.1a124c	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a124e	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT      ; Set its reference count to 0
.1a1251	a9 00		lda #$00	            LDA #0
.1a1253	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1255	2b		pld		done        PLD
.1a1256	28		plp		            PLP
.1a1257	38		sec		            SEC
.1a1258	60		rts		            RTS
.1a1259					HEAP_GETHED
.1a1259	08		php		            PHP
.1a125a	c2 20		rep #$20	            REP #$20
.1a125c	38		sec		            SEC
.1a125d	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a125f	e9 08 00	sbc #$0008	            SBC #size(HEAPOBJ)
.1a1262	85 c3		sta $08c3	            STA CURRHEADER
.1a1264	e2 20		sep #$20	            SEP #$20
.1a1266	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a1268	e9 00		sbc #$00	            SBC #0
.1a126a	85 c5		sta $08c5	            STA CURRHEADER+2
.1a126c	28		plp		            PLP
.1a126d	60		rts		            RTS
.1a126e					HEAP_ADDREF
.1a126e	08		php		            PHP
.1a126f	e2 20		sep #$20	            SEP #$20
.1a1271	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1273	f0 04		beq $1a1279	            BEQ chk_null
.1a1275	c9 18		cmp #$18	            CMP #`(HEAP_TOP + 1)
.1a1277	b0 12		bcs $1a128b	            BGE out_of_bnds
.1a1279					chk_null
.1a1279	c2 20		rep #$20	            REP #$20
.1a127b	a5 c3		lda $08c3	            LDA CURRHEADER
.1a127d	f0 0c		beq $1a128b	            BEQ out_of_bnds
.1a127f					is_ok
.1a127f	e2 20		sep #$20	            SEP #$20
.1a1281	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.1a1284	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1286	1a		inc a		            INC A
.1a1287	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1289	28		plp		            PLP
.1a128a	60		rts		            RTS
.1a128b	00		brk #		out_of_bnds BRK
.1a128c	ea		nop		            NOP
.1a128d					HEAP_REMREF
.1a128d	08		php		            PHP
.1a128e	e2 20		sep #$20	            SEP #$20
.1a1290	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1292	f0 04		beq $1a1298	            BEQ chk_null
.1a1294	c9 18		cmp #$18	            CMP #`(HEAP_TOP + 1)
.1a1296	b0 17		bcs $1a12af	            BGE out_of_bnds
.1a1298					chk_null
.1a1298	c2 20		rep #$20	            REP #$20
.1a129a	a5 c3		lda $08c3	            LDA CURRHEADER
.1a129c	f0 11		beq $1a12af	            BEQ out_of_bnds
.1a129e	e2 20		sep #$20	            SEP #$20
.1a12a0	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT  ; Decrement the reference count
.1a12a3	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a12a5	3a		dec a		            DEC A
.1a12a6	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12a8	d0 03		bne $1a12ad	            BNE done            ; If it's still >0, we are done
.1a12aa	20 b1 12	jsr $1a12b1	            JSR HEAP_FREE
.1a12ad	28		plp		done        PLP
.1a12ae	60		rts		            RTS
.1a12af	00		brk #		out_of_bnds BRK
.1a12b0	ea		nop		            NOP
.1a12b1					HEAP_FREE
.1a12b1	08		php		            PHP
.1a12b2	c2 20		rep #$20	            REP #$20
.1a12b4	a5 bd		lda $08bd	            LDA FREED           ; Check to see if blocks are already on the freed list
.1a12b6	d0 21		bne $1a12d9	            BNE has_objects
.1a12b8	e2 20		sep #$20	            SEP #$20
.1a12ba	a5 bf		lda $08bf	            LDA FREED+2
.1a12bc	d0 1b		bne $1a12d9	            BNE has_objects
.1a12be	a5 c5		lda $08c5	            LDA CURRHEADER+2    ; No: this block is the first one
.1a12c0	85 bf		sta $08bf	            STA FREED+2         ; Just make it the freed list
.1a12c2	c2 20		rep #$20	            REP #$20
.1a12c4	a5 c3		lda $08c3	            LDA CURRHEADER
.1a12c6	85 bd		sta $08bd	            STA FREED
.1a12c8	a9 00 00	lda #$0000	            LDA #0
.1a12cb	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT   ; And clear its next link
.1a12ce	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12d0	c8		iny		            INY
.1a12d1	c8		iny		            INY
.1a12d2	e2 20		sep #$20	            SEP #$20
.1a12d4	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12d6	4c 98 13	jmp $1a1398	            JMP done
.1a12d9					has_objects
.1a12d9	e2 20		sep #$20	            SEP #$20
.1a12db	a5 bf		lda $08bf	            LDA FREED+2
.1a12dd	c5 c5		cmp $08c5	            CMP CURRHEADER+2
.1a12df	90 28		bcc $1a1309	            BLT start_scan
.1a12e1	c2 20		rep #$20	            REP #$20
.1a12e3	a5 bd		lda $08bd	            LDA FREED
.1a12e5	c5 c3		cmp $08c3	            CMP CURRHEADER
.1a12e7	90 20		bcc $1a1309	            BLT start_scan
.1a12e9					ins_first
.1a12e9	c2 20		rep #$20	            REP #$20
.1a12eb	a5 bd		lda $08bd	            LDA FREED               ; CURRHEADER->NEXT := FREED
.1a12ed	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a12f0	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12f2	e2 20		sep #$20	            SEP #$20
.1a12f4	c8		iny		            INY
.1a12f5	c8		iny		            INY
.1a12f6	a5 bf		lda $08bf	            LDA FREED+2
.1a12f8	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12fa	c2 20		rep #$20	            REP #$20
.1a12fc	a5 c3		lda $08c3	            LDA CURRHEADER
.1a12fe	85 bd		sta $08bd	            STA FREED
.1a1300	e2 20		sep #$20	            SEP #$20
.1a1302	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1304	85 bf		sta $08bf	            STA FREED+2
.1a1306	4c 98 13	jmp $1a1398	            JMP done
.1a1309					start_scan
.1a1309	c2 20		rep #$20	            REP #$20
.1a130b	a5 bd		lda $08bd	            LDA FREED
.1a130d	85 08		sta $0808	            STA INDEX
.1a130f	e2 20		sep #$20	            SEP #$20
.1a1311	a5 bf		lda $08bf	            LDA FREED+2
.1a1313	85 0a		sta $080a	            STA INDEX+2
.1a1315					loop
.1a1315	e2 20		sep #$20	            SEP #$20
.1a1317	a0 04 00	ldy #$0004	            LDY #HEAPOBJ.NEXT+2
.1a131a	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a131c	c5 c8		cmp $08c8	            CMP CURREND+2
.1a131e	90 32		bcc $1a1352	            BLT go_next             ; No: check the next spot
.1a1320	d0 0b		bne $1a132d	            BNE ins_next
.1a1322	c2 20		rep #$20	            REP #$20
.1a1324	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1327	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a1329	c5 c6		cmp $08c6	            CMP CURREND
.1a132b	90 25		bcc $1a1352	            BLT go_next             ; No: check the next spot
.1a132d					ins_next
.1a132d	c2 20		rep #$20	            REP #$20
.1a132f	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := INDEX->NEXT
.1a1332	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a1334	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1336	e2 20		sep #$20	            SEP #$20
.1a1338	c8		iny		            INY
.1a1339	c8		iny		            INY
.1a133a	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a133c	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a133e	c2 20		rep #$20	            REP #$20
.1a1340	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.1a1342	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1345	97 08		sta [$0808],y	            STA [INDEX],Y
.1a1347	e2 20		sep #$20	            SEP #$20
.1a1349	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a134b	c8		iny		            INY
.1a134c	c8		iny		            INY
.1a134d	97 08		sta [$0808],y	            STA [INDEX],Y
.1a134f	4c 98 13	jmp $1a1398	            JMP done
.1a1352					go_next
.1a1352	c2 20		rep #$20	            REP #$20
.1a1354	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Is INDEX->NEXT = 0
.1a1357	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a1359	d0 08		bne $1a1363	            BNE not_at_end          ; No: load up the next object
.1a135b	e2 20		sep #$20	            SEP #$20
.1a135d	c8		iny		            INY
.1a135e	c8		iny		            INY
.1a135f	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a1361	f0 19		beq $1a137c	            BEQ at_end
.1a1363					not_at_end
.1a1363	c2 20		rep #$20	            REP #$20
.1a1365	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; INDEX := INDEX->NEXT
.1a1368	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a136a	85 0c		sta $080c	            STA SCRATCH
.1a136c	e2 20		sep #$20	            SEP #$20
.1a136e	c8		iny		            INY
.1a136f	c8		iny		            INY
.1a1370	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a1372	85 0a		sta $080a	            STA INDEX+2
.1a1374	c2 20		rep #$20	            REP #$20
.1a1376	a5 0c		lda $080c	            LDA SCRATCH
.1a1378	85 08		sta $0808	            STA INDEX
.1a137a	80 99		bra $1a1315	            BRA loop
.1a137c					at_end
.1a137c	c2 20		rep #$20	            REP #$20
.1a137e	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.1a1380	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1383	97 08		sta [$0808],y	            STA [INDEX],Y
.1a1385	e2 20		sep #$20	            SEP #$20
.1a1387	c8		iny		            INY
.1a1388	c8		iny		            INY
.1a1389	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a138b	97 08		sta [$0808],y	            STA [INDEX],Y
.1a138d	a9 00		lda #$00	            LDA #0                  ; CURRHEADER->NEXT := 0
.1a138f	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1391	c2 20		rep #$20	            REP #$20
.1a1393	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1396	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1398					done
.1a1398	20 9d 13	jsr $1a139d	            JSR COALLESCE
.1a139b	28		plp		            PLP
.1a139c	60		rts		            RTS
.1a139d					COALLESCE
.1a139d	08		php		            PHP
.1a139e	c2 20		rep #$20	            REP #$20
.1a13a0	a5 bd		lda $08bd	            LDA FREED
.1a13a2	85 c3		sta $08c3	            STA CURRHEADER
.1a13a4	e2 20		sep #$20	            SEP #$20
.1a13a6	a5 bf		lda $08bf	            LDA FREED+2
.1a13a8	85 c5		sta $08c5	            STA CURRHEADER+2
.1a13aa					next_head
.1a13aa	c2 20		rep #$20	            REP #$20
.1a13ac	a5 c3		lda $08c3	            LDA CURRHEADER          ; Is CURRHEADER == 0?
.1a13ae	d0 09		bne $1a13b9	            BNE check_next          ; No: check if NEXT is contiguous
.1a13b0	e2 20		sep #$20	            SEP #$20
.1a13b2	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a13b4	d0 03		bne $1a13b9	            BNE check_next
.1a13b6	4c 40 14	jmp $1a1440	            JMP done                ; Yes: we're done
.1a13b9					check_next
.1a13b9	c2 20		rep #$20	            REP #$20
.1a13bb	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a13be	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a13c0	85 0c		sta $080c	            STA SCRATCH
.1a13c2	e2 20		sep #$20	            SEP #$20
.1a13c4	c8		iny		            INY
.1a13c5	c8		iny		            INY
.1a13c6	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a13c8	85 0e		sta $080e	            STA SCRATCH+2
.1a13ca	c2 20		rep #$20	            REP #$20
.1a13cc	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.1a13cf	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a13d1	85 10		sta $0810	            STA SCRATCH2
.1a13d3	e2 20		sep #$20	            SEP #$20
.1a13d5	c8		iny		            INY
.1a13d6	c8		iny		            INY
.1a13d7	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a13d9	85 12		sta $0812	            STA SCRATCH2+2
.1a13db	c2 20		rep #$20	            REP #$20
.1a13dd	a5 0c		lda $080c	            LDA SCRATCH
.1a13df	c5 10		cmp $0810	            CMP SCRATCH2            ; Is CURRHEADER->END = CURRHEADER->NEXT?
.1a13e1	d0 08		bne $1a13eb	            BNE go_next             ; No: go to the next block
.1a13e3	e2 20		sep #$20	            SEP #$20
.1a13e5	a5 0e		lda $080e	            LDA SCRATCH+2
.1a13e7	c5 12		cmp $0812	            CMP SCRATCH2+2
.1a13e9	f0 1f		beq $1a140a	            BEQ combine             ; Yes: combine the two blocks
.1a13eb					go_next
.1a13eb	c2 20		rep #$20	            REP #$20
.1a13ed	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a13f0	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a13f2	85 0c		sta $080c	            STA SCRATCH
.1a13f4	e2 20		sep #$20	            SEP #$20
.1a13f6	c8		iny		            INY
.1a13f7	c8		iny		            INY
.1a13f8	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a13fa	85 0e		sta $080e	            STA SCRATCH+2
.1a13fc	c2 20		rep #$20	            REP #$20
.1a13fe	a5 0c		lda $080c	            LDA SCRATCH
.1a1400	85 c3		sta $08c3	            STA CURRHEADER
.1a1402	e2 20		sep #$20	            SEP #$20
.1a1404	a5 0e		lda $080e	            LDA SCRATCH+2
.1a1406	85 c5		sta $08c5	            STA CURRHEADER+2
.1a1408	80 a0		bra $1a13aa	            BRA next_head                               ; And loop back to next_head
.1a140a					combine
.1a140a	c2 20		rep #$20	            REP #$20
.1a140c	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a140f	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1411	85 0c		sta $080c	            STA SCRATCH
.1a1413	e2 20		sep #$20	            SEP #$20
.1a1415	c8		iny		            INY
.1a1416	c8		iny		            INY
.1a1417	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1419	85 0e		sta $080e	            STA SCRATCH+2
.1a141b	c2 20		rep #$20	            REP #$20
.1a141d	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := SCRATCH->NEXT
.1a1420	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a1422	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1424	e2 20		sep #$20	            SEP #$20
.1a1426	c8		iny		            INY
.1a1427	c8		iny		            INY
.1a1428	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a142a	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a142c	c2 20		rep #$20	            REP #$20
.1a142e	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END       ; CURRHEADER->END := SCRATCH->END
.1a1431	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a1433	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1435	e2 20		sep #$20	            SEP #$20
.1a1437	c8		iny		            INY
.1a1438	c8		iny		            INY
.1a1439	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a143b	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a143d	4c b9 13	jmp $1a13b9	            JMP check_next          ; And loop back to check_next
.1a1440	28		plp		done        PLP
.1a1441	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\strings.s

.1a1442					CLRTMPSTR
.1a1442	08		php		            PHP
.1a1443	c2 20		rep #$20	            REP #$20
.1a1445	64 16		stz $0816	            STZ STRPTR
.1a1447	64 18		stz $0818	            STZ STRPTR+2
.1a1449	28		plp		            PLP
.1a144a	60		rts		            RTS
.1a144b					TEMPSTRING
.1a144b	08		php		            PHP
.1a144c	c2 30		rep #$30	            REP #$30
.1a144e	a5 16		lda $0816	            LDA STRPTR          ; Is STRPTR == 0?
.1a1450	d0 16		bne $1a1468	            BNE add_256         ; No: add 256 to it
.1a1452	a5 18		lda $0818	            LDA STRPTR+2
.1a1454	d0 12		bne $1a1468	            BNE add_256
.1a1456	e2 20		sep #$20	            SEP #$20
.1a1458	64 16		stz $0816	            STZ STRPTR
.1a145a	a5 e2		lda $08e2	            LDA NEXTVAR+1
.1a145c	1a		inc a		            INC A
.1a145d	1a		inc a		            INC A
.1a145e	85 17		sta $0817	            STA STRPTR+1
.1a1460	a5 e3		lda $08e3	            LDA NEXTVAR+2
.1a1462	85 18		sta $0818	            STA STRPTR+2
.1a1464	64 19		stz $0819	            STZ STRPTR+3
.1a1466	80 07		bra $1a146f	            BRA chk_room
.1a1468					add_256
.1a1468	c2 20		rep #$20	            REP #$20
.1a146a	a5 17		lda $0817	            LDA STRPTR+1        ; There was already a temporary string...
.1a146c	1a		inc a		            INC A               ; Leave 256 bytes for it
.1a146d	85 17		sta $0817	            STA STRPTR+1
.1a146f					chk_room
.1a146f	c2 20		rep #$20	            REP #$20
.1a1471	a5 bb		lda $08bb	            LDA HEAP+1          ; Check to make sure that STRPTR and HEAP haven't touched
.1a1473	3a		dec a		            DEC A
.1a1474	c5 17		cmp $0817	            CMP STRPTR+1
.1a1476	f0 02		beq $1a147a	            BEQ no_room         ; If they have, throw an error
.1a1478	b0 1f		bcs $1a1499	            BGE done
.1a147a					no_room
.1a147a	08		php		            PHP
.1a147b	c2 20		rep #$20	            REP #$20
.1a147d	48		pha		            PHA
.1a147e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1481	5b		tcd		            TCD
.1a1482	68		pla		            PLA
.1a1483	28		plp		            PLP
.1a1484	e2 20		sep #$20	            SEP #$20
.1a1486	a9 03		lda #$03	            LDA #ERR_MEMORY
.1a1488	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a148c	c2 20		rep #$20	            REP #$20
.1a148e	29 ff 00	and #$00ff	            AND #$00FF
.1a1491	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a1494	e2 20		sep #$20	            SEP #$20
.1a1496	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1499	28		plp		done        PLP
.1a149a	60		rts		            RTS
.1a149b					ITOS_DIGIT
.1a149b	c9 00		cmp #$00	            CMP #0          ; Is it 0?
.1a149d	d0 05		bne $1a14a4	            BNE add_digit   ; No: go ahead and add it
.1a149f	c0 01 00	cpy #$0001	            CPY #1          ; Are we on the first digit?
.1a14a2	f0 05		beq $1a14a9	            BEQ done        ; Yes: ignore this leading 0
.1a14a4	09 30		ora #$30	add_digit   ORA #$30        ; Convert it to ASCII
.1a14a6	97 16		sta [$0816],y	            STA [STRPTR],Y  ; Save it to the string
.1a14a8	c8		iny		            INY             ; And point to the next location
.1a14a9					done
.1a14a9	60		rts		            RTS
.1a14aa					ITOS
.1a14aa	08		php		            PHP
.1a14ab	c2 30		rep #$30	            REP #$30
.1a14ad	64 0c		stz $080c	            STZ SCRATCH         ; Use scratch to store if negative
.1a14af	a5 25		lda $0825	            LDA ARGUMENT1+2     ; Check to see if the number is negative
.1a14b1	10 1a		bpl $1a14cd	            BPL start_cnvt
.1a14b3	18		clc		            CLC                 ; Yes: make ARGUMENT1 positive
.1a14b4	a5 23		lda $0823	            LDA ARGUMENT1
.1a14b6	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a14b9	69 01 00	adc #$0001	            ADC #1
.1a14bc	85 23		sta $0823	            STA ARGUMENT1
.1a14be	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a14c0	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a14c3	69 00 00	adc #$0000	            ADC #0
.1a14c6	85 25		sta $0825	            STA ARGUMENT1+2
.1a14c8	a9 ff ff	lda #$ffff	            LDA #$FFFF          ; Record that the number was negative
.1a14cb	85 0c		sta $080c	            STA SCRATCH
.1a14cd					start_cnvt
.1a14cd	64 10		stz $0810	            STZ SCRATCH2        ; SCRATCH2 will be our BCD version of the number
.1a14cf	64 12		stz $0812	            STZ SCRATCH2+2
.1a14d1	64 14		stz $0814	            STZ SCRATCH2+4
.1a14d3	a2 1f 00	ldx #$001f	            LDX #31
.1a14d6	f8		sed		            SED                 ; Yes, we're really using BCD mode
.1a14d7	06 23		asl $0823	shift_loop  ASL ARGUMENT1       ; Shift ARGUMENT1 left one bit
.1a14d9	26 25		rol $0825	            ROL ARGUMENT1+2
.1a14db	a5 10		lda $0810	            LDA SCRATCH2        ; SCRATCH2 := SCRATCH2 + SCRATCH2 + Carry
.1a14dd	65 10		adc $0810	            ADC SCRATCH2
.1a14df	85 10		sta $0810	            STA SCRATCH2
.1a14e1	a5 12		lda $0812	            LDA SCRATCH2+2
.1a14e3	65 12		adc $0812	            ADC SCRATCH2+2
.1a14e5	85 12		sta $0812	            STA SCRATCH2+2
.1a14e7	a5 14		lda $0814	            LDA SCRATCH2+4
.1a14e9	65 14		adc $0814	            ADC SCRATCH2+4
.1a14eb	85 14		sta $0814	            STA SCRATCH2+4
.1a14ed	ca		dex		            DEX
.1a14ee	10 e7		bpl $1a14d7	            BPL shift_loop      ; Loop through all 32 bits of ARGUMENT1
.1a14f0	d8		cld		            CLD                 ; Switch back out of BCD mode
.1a14f1	e2 20		sep #$20	            SEP #$20
.1a14f3	20 4b 14	jsr $1a144b	            JSR TEMPSTRING
.1a14f6	a0 00 00	ldy #$0000	            LDY #0              ; Y will be index into the temporary string
.1a14f9	a5 0c		lda $080c	            LDA SCRATCH         ; Check to see if the number was negative
.1a14fb	f0 04		beq $1a1501	            BEQ is_pos          ; No: write a leading space
.1a14fd	a9 2d		lda #$2d	            LDA #'-'            ; If negative, write the minus sign
.1a14ff	80 02		bra $1a1503	            BRA wr_lead
.1a1501	a9 20		lda #$20	is_pos      LDA #CHAR_SP        ; Write a leading space
.1a1503	97 16		sta [$0816],y	wr_lead     STA [STRPTR],Y
.1a1505	c8		iny		            INY
.1a1506	a2 05 00	ldx #$0005	            LDX #5
.1a1509	b5 10		lda $0810,x	ascii_loop  LDA SCRATCH2,X
.1a150b	29 f0		and #$f0	            AND #$F0
.1a150d	4a		lsr a		            LSR A
.1a150e	4a		lsr a		            LSR A
.1a150f	4a		lsr a		            LSR A
.1a1510	4a		lsr a		            LSR A
.1a1511	20 9b 14	jsr $1a149b	            JSR ITOS_DIGIT
.1a1514	b5 10		lda $0810,x	            LDA SCRATCH2,X
.1a1516	29 0f		and #$0f	            AND #$0F
.1a1518	20 9b 14	jsr $1a149b	            JSR ITOS_DIGIT
.1a151b	ca		dex		            DEX
.1a151c	10 eb		bpl $1a1509	            BPL ascii_loop
.1a151e	c0 01 00	cpy #$0001	            CPY #1              ; Did we write anything?
.1a1521	d0 0c		bne $1a152f	            BNE null_term       ; Yes: add a NULL to terminate
.1a1523	a9 20		lda #$20	            LDA #' '            ; No: write a " 0" to the string
.1a1525	87 16		sta [$0816]	            STA [STRPTR]
.1a1527	a0 01 00	ldy #$0001	            LDY #1
.1a152a	a9 30		lda #$30	            LDA #'0'
.1a152c	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a152e	c8		iny		            INY
.1a152f	a9 00		lda #$00	null_term   LDA #0
.1a1531	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And terminate the string
.1a1533	28		plp		done        PLP
.1a1534	60		rts		            RTS
.1a1535	00		brk #		fault       BRK
.1a1536	ea		nop		            NOP
.1a1537					STRLEN
.1a1537	08		php		            PHP
.1a1538	e2 20		sep #$20	            SEP #$20
.1a153a	c2 10		rep #$10	            REP #$10
.1a153c	a0 00 00	ldy #$0000	            LDY #0
.1a153f	bd 00 00	lda $1a0000,x	loop        LDA #0,B,X
.1a1542	f0 04		beq $1a1548	            BEQ done
.1a1544	e8		inx		            INX
.1a1545	c8		iny		            INY
.1a1546	80 f7		bra $1a153f	            BRA loop
.1a1548	28		plp		done        PLP
.1a1549	60		rts		            RTS
.1a154a					STRCMP
.1a154a	08		php		            PHP
.1a154b	0b		phd		            PHD
.1a154c	08		php		            PHP
.1a154d	c2 20		rep #$20	            REP #$20
.1a154f	48		pha		            PHA
.1a1550	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1553	5b		tcd		            TCD
.1a1554	68		pla		            PLA
.1a1555	28		plp		            PLP
.1a1556	e2 20		sep #$20	            SEP #$20
.1a1558	c2 10		rep #$10	            REP #$10
.1a155a	a0 00 00	ldy #$0000	            LDY #0
.1a155d	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Check if the character 1 is 0
.1a155f	d0 04		bne $1a1565	            BNE comp_mag            ; If not, check the magnitudes
.1a1561	b7 29		lda [$0829],y	            LDA [ARGUMENT2],Y       ; If so, check if the character 2 is 0
.1a1563	f0 25		beq $1a158a	            BEQ are_equal           ; If so, the strings are equal
.1a1565	b7 23		lda [$0823],y	comp_mag    LDA [ARGUMENT1],Y       ; Otherwise, get character 1 again
.1a1567	d7 29		cmp [$0829],y	            CMP [ARGUMENT2],Y       ; And compare it to character 2
.1a1569	90 12		bcc $1a157d	            BLT is_less             ; Check if character 1 < character 2
.1a156b	d0 03		bne $1a1570	            BNE is_greater          ; Check if character 1 > character 2
.1a156d	c8		iny		            INY                     ; Equal so far... so go to the next pair of characters
.1a156e	80 ed		bra $1a155d	            BRA loop
.1a1570					is_greater
.1a1570	c2 20		rep #$20	            REP #$20
.1a1572	a9 01 00	lda #$0001	            LDA #1                  ; So return 1
.1a1575	85 23		sta $0823	            STA ARGUMENT1
.1a1577	e2 20		sep #$20	            SEP #$20
.1a1579	64 25		stz $0825	            STZ ARGUMENT1+2
.1a157b	80 15		bra $1a1592	            BRA done
.1a157d					is_less
.1a157d	c2 20		rep #$20	            REP #$20
.1a157f	a9 ff ff	lda #$ffff	            LDA #$FFFF              ; So return -1
.1a1582	85 23		sta $0823	            STA ARGUMENT1
.1a1584	e2 20		sep #$20	            SEP #$20
.1a1586	85 25		sta $0825	            STA ARGUMENT1+2
.1a1588	80 08		bra $1a1592	            BRA done
.1a158a					are_equal
.1a158a	c2 20		rep #$20	            REP #$20
.1a158c	64 23		stz $0823	            STZ ARGUMENT1           ; So return 0
.1a158e	e2 20		sep #$20	            SEP #$20
.1a1590	64 25		stz $0825	            STZ ARGUMENT1+2
.1a1592					done
.1a1592	e2 20		sep #$20	            SEP #$20
.1a1594	a9 00		lda #$00	            LDA #TYPE_INTEGER
.1a1596	85 27		sta $0827	            STA ARGTYPE1
.1a1598	2b		pld		            PLD
.1a1599	28		plp		            PLP
.1a159a	60		rts		            RTS
.1a159b					STRCONCAT
.1a159b	08		php		            PHP
.1a159c	0b		phd		            PHD
.1a159d	8b		phb		            PHB
.1a159e	08		php		            PHP
.1a159f	c2 20		rep #$20	            REP #$20
.1a15a1	48		pha		            PHA
.1a15a2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a15a5	5b		tcd		            TCD
.1a15a6	68		pla		            PLA
.1a15a7	28		plp		            PLP
.1a15a8	e2 20		sep #$20	            SEP #$20
.1a15aa	c2 10		rep #$10	            REP #$10
.1a15ac	08		php		            PHP
.1a15ad	c2 20		rep #$20	            REP #$20
.1a15af	48		pha		            PHA
.1a15b0	e2 20		sep #$20	            SEP #$20
.1a15b2	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a15b4	48		pha		            PHA
.1a15b5	ab		plb		            PLB
.1a15b6	c2 20		rep #$20	            REP #$20
.1a15b8	68		pla		            PLA
.1a15b9	28		plp		            PLP
.1a15ba	a6 23		ldx $0823	            LDX ARGUMENT1
.1a15bc	20 37 15	jsr $1a1537	            JSR STRLEN
.1a15bf	84 0c		sty $080c	            STY SCRATCH
.1a15c1	08		php		            PHP
.1a15c2	c2 20		rep #$20	            REP #$20
.1a15c4	48		pha		            PHA
.1a15c5	e2 20		sep #$20	            SEP #$20
.1a15c7	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a15c9	48		pha		            PHA
.1a15ca	ab		plb		            PLB
.1a15cb	c2 20		rep #$20	            REP #$20
.1a15cd	68		pla		            PLA
.1a15ce	28		plp		            PLP
.1a15cf	a6 29		ldx $0829	            LDX ARGUMENT2
.1a15d1	20 37 15	jsr $1a1537	            JSR STRLEN
.1a15d4	c2 20		rep #$20	            REP #$20
.1a15d6	98		tya		            TYA
.1a15d7	38		sec		            SEC                     ; X := LEN(ARGUMENT1) + LEN(ARGUMENT2) + 1
.1a15d8	65 0c		adc $080c	            ADC SCRATCH
.1a15da	aa		tax		            TAX
.1a15db	e2 20		sep #$20	            SEP #$20
.1a15dd	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set type to STRING
.1a15df	20 1d 10	jsr $1a101d	            JSR ALLOC
.1a15e2	c2 20		rep #$20	            REP #$20
.1a15e4	a5 b7		lda $08b7	            LDA ALLOCATED           ; INDEX := pointer to the string
.1a15e6	85 08		sta $0808	            STA INDEX
.1a15e8	e2 20		sep #$20	            SEP #$20
.1a15ea	a5 b9		lda $08b9	            LDA ALLOCATED+2
.1a15ec	85 0a		sta $080a	            STA INDEX+2
.1a15ee	a0 00 00	ldy #$0000	            LDY #0                  ; Set the target index to the beginning
.1a15f1	08		php		            PHP
.1a15f2	c2 20		rep #$20	            REP #$20
.1a15f4	48		pha		            PHA
.1a15f5	e2 20		sep #$20	            SEP #$20
.1a15f7	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a15f9	48		pha		            PHA
.1a15fa	ab		plb		            PLB
.1a15fb	c2 20		rep #$20	            REP #$20
.1a15fd	68		pla		            PLA
.1a15fe	28		plp		            PLP
.1a15ff	a6 23		ldx $0823	            LDX ARGUMENT1
.1a1601	bd 00 00	lda $1a0000,x	loop1       LDA #0,B,X              ; Get the Xth byte of ARGUMENT1
.1a1604	f0 06		beq $1a160c	            BEQ copy_2              ; Is it null? Yes: move on to the next string
.1a1606	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.1a1608	e8		inx		            INX                     ; Point to the next characters
.1a1609	c8		iny		            INY
.1a160a	80 f5		bra $1a1601	            BRA loop1               ; And do again
.1a160c					copy_2
.1a160c	e2 20		sep #$20	            SEP #$20
.1a160e	08		php		            PHP
.1a160f	c2 20		rep #$20	            REP #$20
.1a1611	48		pha		            PHA
.1a1612	e2 20		sep #$20	            SEP #$20
.1a1614	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a1616	48		pha		            PHA
.1a1617	ab		plb		            PLB
.1a1618	c2 20		rep #$20	            REP #$20
.1a161a	68		pla		            PLA
.1a161b	28		plp		            PLP
.1a161c	a6 29		ldx $0829	            LDX ARGUMENT2
.1a161e	bd 00 00	lda $1a0000,x	loop2       LDA #0,B,X              ; Get the Xth byte of ARGUMENT2
.1a1621	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.1a1623	f0 04		beq $1a1629	            BEQ terminate           ; Is it null? Yes: move on to the next string
.1a1625	e8		inx		            INX                     ; Point to the next characters
.1a1626	c8		iny		            INY
.1a1627	80 f5		bra $1a161e	            BRA loop2               ; And do again
.1a1629					terminate
.1a1629	c2 20		rep #$20	            REP #$20
.1a162b	a5 08		lda $0808	            LDA INDEX               ; Set ARGUMENT1 to the new string
.1a162d	85 23		sta $0823	            STA ARGUMENT1
.1a162f	e2 20		sep #$20	            SEP #$20
.1a1631	a5 0a		lda $080a	            LDA INDEX+2
.1a1633	85 25		sta $0825	            STA ARGUMENT1+2
.1a1635	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set ARGUMENT1's type to STRING
.1a1637	85 27		sta $0827	            STA ARGTYPE1
.1a1639	ab		plb		            PLB
.1a163a	2b		pld		            PLD
.1a163b	28		plp		            PLP
.1a163c	60		rts		            RTS
.1a163d					STRCPY
.1a163d	da		phx		            PHX
.1a163e	5a		phy		            PHY
.1a163f	08		php		            PHP
.1a1640	0b		phd		            PHD
.1a1641	8b		phb		            PHB
.1a1642	08		php		            PHP
.1a1643	c2 20		rep #$20	            REP #$20
.1a1645	48		pha		            PHA
.1a1646	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1649	5b		tcd		            TCD
.1a164a	68		pla		            PLA
.1a164b	28		plp		            PLP
.1a164c	c2 20		rep #$20	            REP #$20
.1a164e	a5 0a		lda $080a	            LDA INDEX+2
.1a1650	48		pha		            PHA
.1a1651	a5 08		lda $0808	            LDA INDEX
.1a1653	48		pha		            PHA
.1a1654	c2 30		rep #$30	            REP #$30
.1a1656	08		php		            PHP
.1a1657	c2 20		rep #$20	            REP #$20
.1a1659	48		pha		            PHA
.1a165a	e2 20		sep #$20	            SEP #$20
.1a165c	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a165e	48		pha		            PHA
.1a165f	ab		plb		            PLB
.1a1660	c2 20		rep #$20	            REP #$20
.1a1662	68		pla		            PLA
.1a1663	28		plp		            PLP
.1a1664	a6 23		ldx $0823	            LDX ARGUMENT1
.1a1666	20 37 15	jsr $1a1537	            JSR STRLEN
.1a1669	98		tya		            TYA
.1a166a	aa		tax		            TAX
.1a166b	e8		inx		            INX                     ; Put length of string (plus NUL) in X
.1a166c	e2 20		sep #$20	            SEP #$20
.1a166e	a9 02		lda #$02	            LDA #TYPE_STRING
.1a1670	20 1d 10	jsr $1a101d	            JSR ALLOC
.1a1673	c2 20		rep #$20	            REP #$20
.1a1675	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a1677	85 08		sta $0808	            STA INDEX
.1a1679	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a167b	85 0a		sta $080a	            STA INDEX+2
.1a167d	a0 00 00	ldy #$0000	            LDY #0
.1a1680	e2 20		sep #$20	            SEP #$20
.1a1682	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Copy the data to the allocated string
.1a1684	97 08		sta [$0808],y	            STA [INDEX],Y
.1a1686	f0 03		beq $1a168b	            BEQ ret_copy
.1a1688	c8		iny		            INY
.1a1689	80 f7		bra $1a1682	            BRA loop
.1a168b					ret_copy
.1a168b	c2 20		rep #$20	            REP #$20
.1a168d	a5 08		lda $0808	            LDA INDEX
.1a168f	85 23		sta $0823	            STA ARGUMENT1
.1a1691	a5 0a		lda $080a	            LDA INDEX+2
.1a1693	85 25		sta $0825	            STA ARGUMENT1+2
.1a1695	c2 20		rep #$20	            REP #$20
.1a1697	68		pla		            PLA
.1a1698	85 08		sta $0808	            STA INDEX
.1a169a	68		pla		            PLA
.1a169b	85 0a		sta $080a	            STA INDEX+2
.1a169d	ab		plb		            PLB
.1a169e	2b		pld		            PLD
.1a169f	28		plp		            PLP
.1a16a0	7a		ply		            PLY
.1a16a1	fa		plx		            PLX
.1a16a2	60		rts		            RTS
.1a16a3					STRSUBSTR
.1a16a3	08		php		            PHP
.1a16a4	e2 20		sep #$20	            SEP #$20
.1a16a6	c2 10		rep #$10	            REP #$10
.1a16a8	a0 00 00	ldy #$0000	            LDY #0
.1a16ab	b7 23		lda [$0823],y	count_loop  LDA [ARGUMENT1],Y
.1a16ad	f0 05		beq $1a16b4	            BEQ counted
.1a16af	c8		iny		            INY
.1a16b0	80 f9		bra $1a16ab	            BRA count_loop
.1a16b2	84 92		sty $0892	            STY MTEMP               ; MTEMP := length of the source string
.1a16b4					counted
.1a16b4	c2 30		rep #$30	            REP #$30
.1a16b6	c4 29		cpy $0829	            CPY ARGUMENT2           ; length of string <= index?
.1a16b8	90 13		bcc $1a16cd	            BLT ret_empty           ; Yes: return empty string
.1a16ba	f0 11		beq $1a16cd	            BEQ ret_empty
.1a16bc	a5 8f		lda $088f	            LDA MCOUNT              ; Is the desired count <= 0?
.1a16be	30 0d		bmi $1a16cd	            BMI ret_empty
.1a16c0	f0 0b		beq $1a16cd	            BEQ ret_empty           ; Yes: return the empty string
.1a16c2	c4 8f		cpy $088f	            CPY MCOUNT              ; Is the desired length < the length of the source?
.1a16c4	b0 12		bcs $1a16d8	            BGE do_slice            ; Yes: go ahead and get the substring
.1a16c6	a5 29		lda $0829	            LDA ARGUMENT2           ; Is INDEX == 0?
.1a16c8	d0 0e		bne $1a16d8	            BNE do_slice            ; No: do a slice
.1a16ca	4c 21 17	jmp $1a1721	            JMP done                ; Yes: just return the source string
.1a16cd					ret_empty
.1a16cd	20 4b 14	jsr $1a144b	            JSR TEMPSTRING
.1a16d0	e2 20		sep #$20	            SEP #$20
.1a16d2	a9 00		lda #$00	            LDA #0
.1a16d4	87 16		sta [$0816]	            STA [STRPTR]
.1a16d6	80 39		bra $1a1711	            BRA finish_copy
.1a16d8					do_slice
.1a16d8	20 4b 14	jsr $1a144b	            JSR TEMPSTRING
.1a16db	c2 30		rep #$30	            REP #$30
.1a16dd	18		clc		            CLC                     ; ARGUMENT1 := ARGUMENT1 + index
.1a16de	a5 23		lda $0823	            LDA ARGUMENT1
.1a16e0	65 29		adc $0829	            ADC ARGUMENT2
.1a16e2	85 23		sta $0823	            STA ARGUMENT1
.1a16e4	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a16e6	69 00 00	adc #$0000	            ADC #0
.1a16e9	85 25		sta $0825	            STA ARGUMENT1+2
.1a16eb	a0 00 00	ldy #$0000	            LDY #0
.1a16ee					copy_loop
.1a16ee	e2 20		sep #$20	            SEP #$20
.1a16f0	a7 23		lda [$0823]	            LDA [ARGUMENT1]         ; Copy a character from the substring to the temporary string
.1a16f2	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a16f4	f0 1b		beq $1a1711	            BEQ finish_copy         ; If it is a NULL, we're done
.1a16f6	c2 20		rep #$20	            REP #$20
.1a16f8	18		clc		            CLC                     ; Move to the next character
.1a16f9	a5 23		lda $0823	            LDA ARGUMENT1
.1a16fb	69 01 00	adc #$0001	            ADC #1
.1a16fe	85 23		sta $0823	            STA ARGUMENT1
.1a1700	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a1702	69 00 00	adc #$0000	            ADC #0
.1a1705	85 25		sta $0825	            STA ARGUMENT1+2
.1a1707	c8		iny		            INY
.1a1708	c4 8f		cpy $088f	            CPY MCOUNT              ; Have we reached the limit to copy?
.1a170a	d0 e2		bne $1a16ee	            BNE copy_loop           ; No: copy the next byte
.1a170c	a9 00 00	lda #$0000	            LDA #0                  ; Null terminate string
.1a170f	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a1711					finish_copy
.1a1711	c2 20		rep #$20	            REP #$20
.1a1713	a5 16		lda $0816	            LDA STRPTR
.1a1715	85 23		sta $0823	            STA ARGUMENT1
.1a1717	a5 18		lda $0818	            LDA STRPTR+2
.1a1719	85 25		sta $0825	            STA ARGUMENT1+2
.1a171b	e2 20		sep #$20	            SEP #$20
.1a171d	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a171f	85 27		sta $0827	            STA ARGTYPE1
.1a1721					done
.1a1721	28		plp		            PLP
.1a1722	60		rts		            RTS
.1a1723					OP_STR_LT
.1a1723	08		php		            PHP
.1a1724	c2 30		rep #$30	            REP #$30
.1a1726	20 4a 15	jsr $1a154a	            JSR STRCMP
.1a1729	a5 23		lda $0823	            LDA ARGUMENT1
.1a172b	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.1a172e	d0 05		bne $1a1735	            BNE ret_false               ; No: return false
.1a1730					ret_true
.1a1730	20 7c 05	jsr $1a057c	            JSR SET_TRUE
.1a1733	80 03		bra $1a1738	            BRA done
.1a1735					ret_false
.1a1735	20 8e 05	jsr $1a058e	            JSR SET_FALSE
.1a1738	28		plp		done        PLP
.1a1739	60		rts		            RTS
.1a173a					OP_STR_GT
.1a173a	08		php		            PHP
.1a173b	c2 30		rep #$30	            REP #$30
.1a173d	20 4a 15	jsr $1a154a	            JSR STRCMP
.1a1740	a5 23		lda $0823	            LDA ARGUMENT1
.1a1742	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.1a1745	d0 05		bne $1a174c	            BNE ret_false               ; No: return false
.1a1747					ret_true
.1a1747	20 7c 05	jsr $1a057c	            JSR SET_TRUE
.1a174a	80 03		bra $1a174f	            BRA done
.1a174c					ret_false
.1a174c	20 8e 05	jsr $1a058e	            JSR SET_FALSE
.1a174f	28		plp		done        PLP
.1a1750	60		rts		            RTS
.1a1751					OP_STR_EQ
.1a1751	08		php		            PHP
.1a1752	c2 30		rep #$30	            REP #$30
.1a1754	20 4a 15	jsr $1a154a	            JSR STRCMP
.1a1757	a5 23		lda $0823	            LDA ARGUMENT1
.1a1759	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.1a175c	d0 05		bne $1a1763	            BNE ret_false               ; No: return false
.1a175e					ret_true
.1a175e	20 7c 05	jsr $1a057c	            JSR SET_TRUE
.1a1761	80 03		bra $1a1766	            BRA done
.1a1763					ret_false
.1a1763	20 8e 05	jsr $1a058e	            JSR SET_FALSE
.1a1766	28		plp		done        PLP
.1a1767	60		rts		            RTS
.1a1768					OP_STR_NE
.1a1768	08		php		            PHP
.1a1769	c2 30		rep #$30	            REP #$30
.1a176b	20 4a 15	jsr $1a154a	            JSR STRCMP
.1a176e	a5 23		lda $0823	            LDA ARGUMENT1
.1a1770	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.1a1773	f0 05		beq $1a177a	            BEQ ret_false               ; Yes: return false
.1a1775					ret_true
.1a1775	20 7c 05	jsr $1a057c	            JSR SET_TRUE
.1a1778	80 03		bra $1a177d	            BRA done
.1a177a					ret_false
.1a177a	20 8e 05	jsr $1a058e	            JSR SET_FALSE
.1a177d	28		plp		done        PLP
.1a177e	60		rts		            RTS
.1a177f					OP_STR_GTE
.1a177f	08		php		            PHP
.1a1780	c2 30		rep #$30	            REP #$30
.1a1782	20 4a 15	jsr $1a154a	            JSR STRCMP
.1a1785	a5 23		lda $0823	            LDA ARGUMENT1
.1a1787	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.1a178a	f0 05		beq $1a1791	            BEQ ret_false               ; Yes: return false
.1a178c					ret_true
.1a178c	20 7c 05	jsr $1a057c	            JSR SET_TRUE
.1a178f	80 03		bra $1a1794	            BRA done
.1a1791					ret_false
.1a1791	20 8e 05	jsr $1a058e	            JSR SET_FALSE
.1a1794	28		plp		done        PLP
.1a1795	60		rts		            RTS
.1a1796					OP_STR_LTE
.1a1796	08		php		            PHP
.1a1797	c2 30		rep #$30	            REP #$30
.1a1799	20 4a 15	jsr $1a154a	            JSR STRCMP
.1a179c	a5 23		lda $0823	            LDA ARGUMENT1
.1a179e	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.1a17a1	f0 05		beq $1a17a8	            BEQ ret_false               ; Yes: return false
.1a17a3					ret_true
.1a17a3	20 7c 05	jsr $1a057c	            JSR SET_TRUE
.1a17a6	80 03		bra $1a17ab	            BRA done
.1a17a8					ret_false
.1a17a8	20 8e 05	jsr $1a058e	            JSR SET_FALSE
.1a17ab	28		plp		done        PLP
.1a17ac	60		rts		            RTS
.1a17ad					STR_NORMAL
.1a17ad	08		php		            PHP
.1a17ae	e2 20		sep #$20	            SEP #$20
.1a17b0	a5 27		lda $0827	            LDA ARGTYPE1            ; Is it a string?
.1a17b2	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a17b4	d0 1d		bne $1a17d3	            BNE done                ; No: return it
.1a17b6	a5 23		lda $0823	            LDA ARGUMENT1           ; Is it a null pointer?
.1a17b8	d0 19		bne $1a17d3	            BNE done
.1a17ba	a5 24		lda $0824	            LDA ARGUMENT1+1
.1a17bc	d0 15		bne $1a17d3	            BNE done
.1a17be	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a17c0	d0 11		bne $1a17d3	            BNE done                ; No: return it
.1a17c2	20 4b 14	jsr $1a144b	            JSR TEMPSTRING
.1a17c5	a9 00		lda #$00	            LDA #0
.1a17c7	87 16		sta [$0816]	            STA [STRPTR]            ; Make it empty
.1a17c9	c2 20		rep #$20	            REP #$20
.1a17cb	a5 16		lda $0816	            LDA STRPTR
.1a17cd	85 23		sta $0823	            STA ARGUMENT1
.1a17cf	a5 18		lda $0818	            LDA STRPTR+2
.1a17d1	85 25		sta $0825	            STA ARGUMENT1+2
.1a17d3	28		plp		done        PLP
.1a17d4	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\listing.s

.1a17d5					LISTPROG
.1a17d5	48		pha		            PHA
.1a17d6	5a		phy		            PHY
.1a17d7	0b		phd		            PHD
.1a17d8	08		php		            PHP
.1a17d9	08		php		            PHP
.1a17da	c2 20		rep #$20	            REP #$20
.1a17dc	48		pha		            PHA
.1a17dd	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a17e0	5b		tcd		            TCD
.1a17e1	68		pla		            PLA
.1a17e2	28		plp		            PLP
.1a17e3	c2 30		rep #$30	            REP #$30
.1a17e5	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.1a17e8	85 00		sta $0800	            STA BIP
.1a17ea	85 1a		sta $081a	            STA CURLINE
.1a17ec	a9 16 00	lda #$0016	            LDA #`BASIC_BOT
.1a17ef	85 02		sta $0802	            STA BIP+2
.1a17f1	85 1c		sta $081c	            STA CURLINE+2
.1a17f3	22 3c 11 00	jsl $00113c	list_loop   JSL FK_TESTBREAK
.1a17f7	b0 20		bcs $1a1819	            BCS throw_break     ; If C: user pressed an interrupt key, stop the listing
.1a17f9	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.1a17fc	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.1a17fe	f0 0f		beq $1a180f	            BEQ done
.1a1800	c5 55		cmp $0855	            CMP MARG1
.1a1802	90 10		bcc $1a1814	            BLT skip_line
.1a1804	c5 59		cmp $0859	            CMP MARG2
.1a1806	f0 02		beq $1a180a	            BEQ print_line
.1a1808	b0 05		bcs $1a180f	            BGE done
.1a180a					print_line
.1a180a	20 38 18	jsr $1a1838	            JSR LISTLINE
.1a180d	80 e4		bra $1a17f3	            BRA list_loop
.1a180f	28		plp		done        PLP
.1a1810	2b		pld		            PLD
.1a1811	7a		ply		            PLY
.1a1812	68		pla		            PLA
.1a1813	60		rts		            RTS
.1a1814					skip_line
.1a1814	20 44 21	jsr $1a2144	            JSR NEXTLINE
.1a1817	80 da		bra $1a17f3	            BRA list_loop           ; And try again
.1a1819					throw_break
.1a1819	08		php		            PHP
.1a181a	c2 20		rep #$20	            REP #$20
.1a181c	48		pha		            PHA
.1a181d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1820	5b		tcd		            TCD
.1a1821	68		pla		            PLA
.1a1822	28		plp		            PLP
.1a1823	e2 20		sep #$20	            SEP #$20
.1a1825	a9 01		lda #$01	            LDA #ERR_BREAK
.1a1827	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a182b	c2 20		rep #$20	            REP #$20
.1a182d	29 ff 00	and #$00ff	            AND #$00FF
.1a1830	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a1833	e2 20		sep #$20	            SEP #$20
.1a1835	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1838					LISTLINE
.1a1838	08		php		            PHP
.1a1839	c2 30		rep #$30	            REP #$30
.1a183b	85 23		sta $0823	            STA ARGUMENT1
.1a183d	64 25		stz $0825	            STZ ARGUMENT1+2
.1a183f	20 aa 14	jsr $1a14aa	            JSR ITOS
.1a1842	a5 16		lda $0816	            LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.1a1844	1a		inc a		            INC A
.1a1845	85 23		sta $0823	            STA ARGUMENT1
.1a1847	a5 18		lda $0818	            LDA STRPTR+2
.1a1849	85 25		sta $0825	            STA ARGUMENT1+2
.1a184b	20 fd 44	jsr $1a44fd	            JSR PR_STRING
.1a184e	18		clc		            CLC                 ; Move the BIP to the first byte of the line
.1a184f	a5 1a		lda $081a	            LDA CURLINE
.1a1851	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a1854	85 00		sta $0800	            STA BIP
.1a1856	a5 1c		lda $081c	            LDA CURLINE+2
.1a1858	69 00 00	adc #$0000	            ADC #0
.1a185b	85 02		sta $0802	            STA BIP+2
.1a185d	e2 20		sep #$20	            SEP #$20
.1a185f	a9 20		lda #$20	            LDA #CHAR_SP
.1a1861	20 18 00	jsr $1a0018	            JSR PRINTC
.1a1864	c2 20		rep #$20	            REP #$20
.1a1866					loop
.1a1866	20 77 18	jsr $1a1877	            JSR LISTBYTE
.1a1869	90 fb		bcc $1a1866	            BCC loop
.1a186b	e2 20		sep #$20	            SEP #$20
.1a186d	a9 0d		lda #$0d	            LDA #CHAR_CR
.1a186f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a1872	20 44 21	jsr $1a2144	            JSR NEXTLINE
.1a1875	28		plp		            PLP
.1a1876	60		rts		            RTS
.1a1877					LISTBYTE
.1a1877	08		php		            PHP
.1a1878	0b		phd		            PHD
.1a1879	8b		phb		            PHB
.1a187a	08		php		            PHP
.1a187b	c2 20		rep #$20	            REP #$20
.1a187d	48		pha		            PHA
.1a187e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1881	5b		tcd		            TCD
.1a1882	68		pla		            PLA
.1a1883	28		plp		            PLP
.1a1884	08		php		            PHP
.1a1885	e2 20		sep #$20	            SEP #$20
.1a1887	48		pha		            PHA
.1a1888	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a188a	48		pha		            PHA
.1a188b	ab		plb		            PLB
.1a188c	68		pla		            PLA
.1a188d	28		plp		            PLP
.1a188e	e2 20		sep #$20	            SEP #$20
.1a1890	c2 10		rep #$10	            REP #$10
.1a1892	a7 00		lda [$0800]	            LDA [BIP]           ; Get the current byte
.1a1894	f0 3a		beq $1a18d0	            BEQ end_of_line     ; If it's 0, return with C set
.1a1896	30 05		bmi $1a189d	            BMI is_token        ; If it's 0x80 - 0xFF, it's a token
.1a1898	20 18 00	jsr $1a0018	            JSR PRINTC
.1a189b	80 29		bra $1a18c6	            BRA done            ; And return
.1a189d					is_token
.1a189d	c2 20		rep #$20	            REP #$20
.1a189f	29 7f 00	and #$007f	            AND #$007F          ; Compute the index of the token
.1a18a2	0a		asl a		            ASL A               ; In the token table
.1a18a3	0a		asl a		            ASL A
.1a18a4	0a		asl a		            ASL A
.1a18a5	18		clc		            CLC
.1a18a6	69 4d 0c	adc #$0c4d	            ADC #<>TOKENS       ; Set INDEX to the address of the token
.1a18a9	85 08		sta $0808	            STA INDEX
.1a18ab	a9 1a 00	lda #$001a	            LDA #`TOKENS
.1a18ae	69 00 00	adc #$0000	            ADC #0
.1a18b1	85 0a		sta $080a	            STA INDEX+2
.1a18b3					pr_default
.1a18b3	08		php		            PHP
.1a18b4	e2 20		sep #$20	            SEP #$20
.1a18b6	48		pha		            PHA
.1a18b7	a9 1a		lda #$1a	            LDA #`TOKENS
.1a18b9	48		pha		            PHA
.1a18ba	ab		plb		            PLB
.1a18bb	68		pla		            PLA
.1a18bc	28		plp		            PLP
.1a18bd	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.1a18c0	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a18c2	aa		tax		            TAX
.1a18c3	20 b3 03	jsr $1a03b3	            JSR PRINTS
.1a18c6					done
.1a18c6	c2 20		rep #$20	            REP #$20
.1a18c8	20 67 20	jsr $1a2067	            JSR INCBIP
.1a18cb	ab		plb		            PLB
.1a18cc	2b		pld		            PLD
.1a18cd	28		plp		            PLP
.1a18ce	18		clc		            CLC
.1a18cf	60		rts		            RTS
.1a18d0	ab		plb		end_of_line PLB
.1a18d1	2b		pld		            PLD
.1a18d2	28		plp		            PLP
.1a18d3	38		sec		            SEC
.1a18d4	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\eval.s

.1a18d5					INITEVALSP
.1a18d5	08		php		            PHP
.1a18d6	c2 20		rep #$20	            REP #$20
.1a18d8	a9 ff 6f	lda #$6fff	            LDA #ARGUMENT_TOP
.1a18db	85 1f		sta $081f	            STA ARGUMENTSP
.1a18dd	a9 ff 7f	lda #$7fff	            LDA #OPERATOR_TOP
.1a18e0	85 21		sta $0821	            STA OPERATORSP
.1a18e2	a9 ff ff	lda #$ffff	            LDA #$FFFF
.1a18e5	85 23		sta $0823	            STA ARGUMENT1
.1a18e7	85 25		sta $0825	            STA ARGUMENT1+2
.1a18e9	85 29		sta $0829	            STA ARGUMENT2
.1a18eb	85 2b		sta $082b	            STA ARGUMENT2+2
.1a18ed	e2 20		sep #$20	            SEP #$20
.1a18ef	85 27		sta $0827	            STA ARGTYPE1
.1a18f1	85 2d		sta $082d	            STA ARGTYPE2
.1a18f3	28		plp		            PLP
.1a18f4	60		rts		            RTS
.1a18f5					PHARGUMENT
.1a18f5	08		php		            PHP
.1a18f6	0b		phd		            PHD
.1a18f7	8b		phb		            PHB
.1a18f8	08		php		            PHP
.1a18f9	c2 20		rep #$20	            REP #$20
.1a18fb	48		pha		            PHA
.1a18fc	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a18ff	5b		tcd		            TCD
.1a1900	68		pla		            PLA
.1a1901	28		plp		            PLP
.1a1902	08		php		            PHP
.1a1903	e2 20		sep #$20	            SEP #$20
.1a1905	48		pha		            PHA
.1a1906	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1908	48		pha		            PHA
.1a1909	ab		plb		            PLB
.1a190a	68		pla		            PLA
.1a190b	28		plp		            PLP
.1a190c	c2 30		rep #$30	            REP #$30
.1a190e	5a		phy		            PHY
.1a190f	a4 1f		ldy $081f	            LDY ARGUMENTSP
.1a1911	bd 00 00	lda $0000,x	            LDA #0,B,X
.1a1914	99 00 00	sta $0000,y	            STA #0,B,Y
.1a1917	bd 02 00	lda $0002,x	            LDA #2,B,X
.1a191a	99 02 00	sta $0002,y	            STA #2,B,Y
.1a191d	e2 20		sep #$20	            SEP #$20
.1a191f	bd 04 00	lda $0004,x	            LDA #4,B,X
.1a1922	99 04 00	sta $0004,y	            STA #4,B,Y
.1a1925	c2 20		rep #$20	            REP #$20
.1a1927	38		sec		            SEC
.1a1928	98		tya		            TYA
.1a1929	e9 05 00	sbc #$0005	            SBC #ARGUMENT_SIZE
.1a192c	85 1f		sta $081f	            STA ARGUMENTSP
.1a192e	7a		ply		            PLY
.1a192f	ab		plb		            PLB
.1a1930	2b		pld		            PLD
.1a1931	28		plp		            PLP
.1a1932	60		rts		            RTS
.1a1933					PLARGUMENT
.1a1933	08		php		            PHP
.1a1934	0b		phd		            PHD
.1a1935	8b		phb		            PHB
.1a1936	08		php		            PHP
.1a1937	c2 20		rep #$20	            REP #$20
.1a1939	48		pha		            PHA
.1a193a	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a193d	5b		tcd		            TCD
.1a193e	68		pla		            PLA
.1a193f	28		plp		            PLP
.1a1940	08		php		            PHP
.1a1941	e2 20		sep #$20	            SEP #$20
.1a1943	48		pha		            PHA
.1a1944	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1946	48		pha		            PHA
.1a1947	ab		plb		            PLB
.1a1948	68		pla		            PLA
.1a1949	28		plp		            PLP
.1a194a	c2 30		rep #$30	            REP #$30
.1a194c	5a		phy		            PHY
.1a194d	18		clc		            CLC
.1a194e	a5 1f		lda $081f	            LDA ARGUMENTSP
.1a1950	69 05 00	adc #$0005	            ADC #ARGUMENT_SIZE
.1a1953	85 1f		sta $081f	            STA ARGUMENTSP
.1a1955	a8		tay		            TAY
.1a1956	b9 00 00	lda $0000,y	            LDA #0,B,Y
.1a1959	9d 00 00	sta $0000,x	            STA #0,B,X
.1a195c	b9 02 00	lda $0002,y	            LDA #2,B,Y
.1a195f	9d 02 00	sta $0002,x	            STA #2,B,X
.1a1962	e2 20		sep #$20	            SEP #$20
.1a1964	b9 04 00	lda $0004,y	            LDA #4,B,Y
.1a1967	9d 04 00	sta $0004,x	            STA #4,B,X
.1a196a	bd 00 00	lda $0000,x	            LDA #0,B,X
.1a196d	7a		ply		            PLY
.1a196e	ab		plb		            PLB
.1a196f	2b		pld		            PLD
.1a1970	28		plp		            PLP
.1a1971	60		rts		            RTS
.1a1972					PHOPERATOR
.1a1972	08		php		            PHP
.1a1973	0b		phd		            PHD
.1a1974	8b		phb		            PHB
.1a1975	08		php		            PHP
.1a1976	c2 20		rep #$20	            REP #$20
.1a1978	48		pha		            PHA
.1a1979	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a197c	5b		tcd		            TCD
.1a197d	68		pla		            PLA
.1a197e	28		plp		            PLP
.1a197f	08		php		            PHP
.1a1980	e2 20		sep #$20	            SEP #$20
.1a1982	48		pha		            PHA
.1a1983	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1985	48		pha		            PHA
.1a1986	ab		plb		            PLB
.1a1987	68		pla		            PLA
.1a1988	28		plp		            PLP
.1a1989	e2 20		sep #$20	            SEP #$20
.1a198b	c2 10		rep #$10	            REP #$10
.1a198d	5a		phy		            PHY
.1a198e	a4 21		ldy $0821	            LDY OPERATORSP
.1a1990	99 00 00	sta $0000,y	            STA #0,B,Y
.1a1993	88		dey		            DEY
.1a1994	84 21		sty $0821	            STY OPERATORSP
.1a1996	7a		ply		done        PLY
.1a1997	ab		plb		            PLB
.1a1998	2b		pld		            PLD
.1a1999	28		plp		            PLP
.1a199a	60		rts		            RTS
.1a199b					PLOPERATOR
.1a199b	08		php		            PHP
.1a199c	0b		phd		            PHD
.1a199d	8b		phb		            PHB
.1a199e	08		php		            PHP
.1a199f	c2 20		rep #$20	            REP #$20
.1a19a1	48		pha		            PHA
.1a19a2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a19a5	5b		tcd		            TCD
.1a19a6	68		pla		            PLA
.1a19a7	28		plp		            PLP
.1a19a8	08		php		            PHP
.1a19a9	e2 20		sep #$20	            SEP #$20
.1a19ab	48		pha		            PHA
.1a19ac	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a19ae	48		pha		            PHA
.1a19af	ab		plb		            PLB
.1a19b0	68		pla		            PLA
.1a19b1	28		plp		            PLP
.1a19b2	e2 20		sep #$20	            SEP #$20
.1a19b4	c2 10		rep #$10	            REP #$10
.1a19b6	5a		phy		            PHY
.1a19b7	a4 21		ldy $0821	            LDY OPERATORSP
.1a19b9	c8		iny		            INY
.1a19ba	84 21		sty $0821	            STY OPERATORSP
.1a19bc	b9 00 00	lda $0000,y	            LDA #0,B,Y
.1a19bf	c2 20		rep #$20	            REP #$20
.1a19c1	29 ff 00	and #$00ff	            AND #$00FF
.1a19c4	7a		ply		            PLY
.1a19c5	ab		plb		            PLB
.1a19c6	2b		pld		            PLD
.1a19c7	28		plp		            PLP
.1a19c8	60		rts		            RTS
.1a19c9					OPENPARAMS
.1a19c9	08		php		            PHP
.1a19ca	e2 20		sep #$20	            SEP #$20
.1a19cc	a9 01		lda #$01	            LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.1a19ce	20 72 19	jsr $1a1972	            JSR PHOPERATOR
.1a19d1	28		plp		            PLP
.1a19d2	60		rts		            RTS
.1a19d3					CLOSEPARAMS
.1a19d3	5a		phy		            PHY
.1a19d4	08		php		            PHP
.1a19d5	8b		phb		            PHB
.1a19d6	08		php		            PHP
.1a19d7	e2 20		sep #$20	            SEP #$20
.1a19d9	48		pha		            PHA
.1a19da	a9 00		lda #$00	            LDA #0
.1a19dc	48		pha		            PHA
.1a19dd	ab		plb		            PLB
.1a19de	68		pla		            PLA
.1a19df	28		plp		            PLP
.1a19e0	e2 20		sep #$20	            SEP #$20
.1a19e2	a4 21		ldy $0821	            LDY OPERATORSP      ; Peek at the top operator
.1a19e4	b9 01 00	lda $0001,y	            LDA #1,B,Y
.1a19e7	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the marker for the start of a parameter list
.1a19e9	d0 08		bne $1a19f3	            BNE error           ; No: there's a problem
.1a19eb	c2 20		rep #$20	            REP #$20
.1a19ed	e6 21		inc $0821	            INC OPERATORSP      ; Yes: remove it from the operator stack.
.1a19ef	ab		plb		            PLB
.1a19f0	28		plp		            PLP
.1a19f1	7a		ply		            PLY
.1a19f2	60		rts		            RTS
.1a19f3					error
.1a19f3	08		php		            PHP
.1a19f4	c2 20		rep #$20	            REP #$20
.1a19f6	48		pha		            PHA
.1a19f7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a19fa	5b		tcd		            TCD
.1a19fb	68		pla		            PLA
.1a19fc	28		plp		            PLP
.1a19fd	e2 20		sep #$20	            SEP #$20
.1a19ff	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1a01	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1a05	c2 20		rep #$20	            REP #$20
.1a1a07	29 ff 00	and #$00ff	            AND #$00FF
.1a1a0a	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a1a0d	e2 20		sep #$20	            SEP #$20
.1a1a0f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1a12					OPHIGHPREC
.1a1a12	48		pha		            PHA
.1a1a13	08		php		            PHP
.1a1a14	0b		phd		            PHD
.1a1a15	8b		phb		            PHB
.1a1a16	08		php		            PHP
.1a1a17	c2 20		rep #$20	            REP #$20
.1a1a19	48		pha		            PHA
.1a1a1a	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1a1d	5b		tcd		            TCD
.1a1a1e	68		pla		            PLA
.1a1a1f	28		plp		            PLP
.1a1a20	08		php		            PHP
.1a1a21	e2 20		sep #$20	            SEP #$20
.1a1a23	48		pha		            PHA
.1a1a24	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1a26	48		pha		            PHA
.1a1a27	ab		plb		            PLB
.1a1a28	68		pla		            PLA
.1a1a29	28		plp		            PLP
.1a1a2a	e2 20		sep #$20	            SEP #$20
.1a1a2c	a4 21		ldy $0821	            LDY OPERATORSP
.1a1a2e	c0 ff 7f	cpy #$7fff	            CPY #OPERATOR_TOP       ; Is the stack empty?
.1a1a31	f0 11		beq $1a1a44	            BEQ is_false            ; Yes: return false
.1a1a33	20 ac 0b	jsr $1a0bac	            JSR TOKPRECED
.1a1a36	85 0c		sta $080c	            STA SCRATCH             ; Save it for later comparison
.1a1a38	b9 01 00	lda $0001,y	            LDA #1,B,Y              ; Get the operator at the top of the stack
.1a1a3b	20 ac 0b	jsr $1a0bac	            JSR TOKPRECED
.1a1a3e	c5 0c		cmp $080c	            CMP SCRATCH             ; Compare the priorities (0 = highest priority)
.1a1a40	f0 02		beq $1a1a44	            BEQ is_false            ; A = SCRATCH, return false
.1a1a42	90 08		bcc $1a1a4c	            BCC is_true             ; A < SCRATCH (A is higher priority), return false
.1a1a44					is_false
.1a1a44	c2 20		rep #$20	            REP #$20
.1a1a46	ab		plb		            PLB
.1a1a47	2b		pld		            PLD
.1a1a48	28		plp		            PLP
.1a1a49	68		pla		            PLA
.1a1a4a	18		clc		            CLC
.1a1a4b	60		rts		            RTS
.1a1a4c					is_true
.1a1a4c	c2 20		rep #$20	            REP #$20
.1a1a4e	ab		plb		            PLB                     ; A > SCRATCH (A is lower priority), return true
.1a1a4f	2b		pld		            PLD
.1a1a50	28		plp		            PLP
.1a1a51	68		pla		            PLA
.1a1a52	38		sec		            SEC
.1a1a53	60		rts		            RTS
.1a1a54					EVALNUMBER
.1a1a54	4c 27 08	jmp $1a0827	            JMP PARSEINT
.1a1a57					ARR_GETIDX
.1a1a57	08		php		            PHP
.1a1a58	e2 20		sep #$20	            SEP #$20
.1a1a5a	a9 00		lda #$00	            LDA #0
.1a1a5c	8f 00 4d 00	sta $004d00	            STA @lARRIDXBUF     ; Set the dimension to 0
.1a1a60	a2 01 00	ldx #$0001	            LDX #1
.1a1a63					eval_index
.1a1a63	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a1a66	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a1a69	c2 20		rep #$20	            REP #$20
.1a1a6b	a5 23		lda $0823	            LDA ARGUMENT1       ; Save the index to the array index buffer
.1a1a6d	9f 00 4d 00	sta $004d00,x	            STA @l ARRIDXBUF,X
.1a1a71	e2 20		sep #$20	            SEP #$20
.1a1a73	af 00 4d 00	lda $004d00	            LDA @l ARRIDXBUF    ; Increment the index count
.1a1a77	1a		inc a		            INC A
.1a1a78	30 3e		bmi $1a1ab8	            BMI arg_err         ; If more than 127 dimensions, throw a range error
.1a1a7a	8f 00 4d 00	sta $004d00	            STA @l ARRIDXBUF
.1a1a7e	e8		inx		            INX
.1a1a7f	e8		inx		            INX
.1a1a80	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a1a83	e2 20		sep #$20	            SEP #$20
.1a1a85	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.1a1a87	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it ")"
.1a1a89	f0 09		beq $1a1a94	            BEQ clean_op        ; Yes: cleanup the argument stack
.1a1a8b	c9 2c		cmp #$2c	            CMP #','            ; Is it a comma?
.1a1a8d	d0 0a		bne $1a1a99	            BNE syntax_err      ; No: throw a syntax error
.1a1a8f					skip_comma
.1a1a8f	20 67 20	jsr $1a2067	            JSR INCBIP
.1a1a92	80 cf		bra $1a1a63	            BRA eval_index      ; And grab the next index
.1a1a94					clean_op
.1a1a94	20 67 20	jsr $1a2067	            JSR INCBIP
.1a1a97	28		plp		            PLP
.1a1a98	60		rts		            RTS
.1a1a99					syntax_err
.1a1a99	08		php		            PHP
.1a1a9a	c2 20		rep #$20	            REP #$20
.1a1a9c	48		pha		            PHA
.1a1a9d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1aa0	5b		tcd		            TCD
.1a1aa1	68		pla		            PLA
.1a1aa2	28		plp		            PLP
.1a1aa3	e2 20		sep #$20	            SEP #$20
.1a1aa5	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1aa7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1aab	c2 20		rep #$20	            REP #$20
.1a1aad	29 ff 00	and #$00ff	            AND #$00FF
.1a1ab0	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a1ab3	e2 20		sep #$20	            SEP #$20
.1a1ab5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1ab8					arg_err
.1a1ab8	08		php		            PHP
.1a1ab9	c2 20		rep #$20	            REP #$20
.1a1abb	48		pha		            PHA
.1a1abc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1abf	5b		tcd		            TCD
.1a1ac0	68		pla		            PLA
.1a1ac1	28		plp		            PLP
.1a1ac2	e2 20		sep #$20	            SEP #$20
.1a1ac4	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a1ac6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1aca	c2 20		rep #$20	            REP #$20
.1a1acc	29 ff 00	and #$00ff	            AND #$00FF
.1a1acf	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a1ad2	e2 20		sep #$20	            SEP #$20
.1a1ad4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1ad7					EVALREF
.1a1ad7	08		php		            PHP
.1a1ad8					get_name
.1a1ad8	20 c2 52	jsr $1a52c2	            JSR VAR_FINDNAME
.1a1adb	90 47		bcc $1a1b24	            BCC syntax_err      ; If we didn't find a name, thrown an error
.1a1add	e2 20		sep #$20	            SEP #$20
.1a1adf	a5 ea		lda $08ea	            LDA TOFINDTYPE      ; Check the type of the variable
.1a1ae1	29 80		and #$80	            AND #$80            ; Is it an array?
.1a1ae3	d0 06		bne $1a1aeb	            BNE is_array        ; Yes: look for the indexes
.1a1ae5	20 c3 50	jsr $1a50c3	            JSR VAR_REF
.1a1ae8	4c 22 1b	jmp $1a1b22	            JMP done
.1a1aeb					is_array
.1a1aeb	20 35 50	jsr $1a5035	            JSR VAR_FIND
.1a1aee	90 53		bcc $1a1b43	            BCC notfound
.1a1af0	c2 20		rep #$20	            REP #$20
.1a1af2	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a1af4	48		pha		            PHA
.1a1af5	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a1af7	48		pha		            PHA
.1a1af8	a0 09 00	ldy #$0009	            LDY #BINDING.VALUE
.1a1afb	b7 08		lda [$0808],y	            LDA [INDEX],Y       ; Save the pointer to the array to CURRBLOCK
.1a1afd	85 c0		sta $08c0	            STA CURRBLOCK
.1a1aff	e2 20		sep #$20	            SEP #$20
.1a1b01	c8		iny		            INY
.1a1b02	c8		iny		            INY
.1a1b03	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a1b05	85 c2		sta $08c2	            STA CURRBLOCK+2
.1a1b07	e2 20		sep #$20	            SEP #$20
.1a1b09	a9 8f		lda #$8f	            LDA #TOK_LPAREN
.1a1b0b	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a1b0e	20 c9 19	jsr $1a19c9	            JSR OPENPARAMS
.1a1b11					            PHARRIDX
.1a1b11	20 57 1a	jsr $1a1a57	            JSR ARR_GETIDX
.1a1b14	20 99 67	jsr $1a6799	            JSR ARR_REF
.1a1b17					            PLARRIDX
.1a1b17	20 d3 19	jsr $1a19d3	            JSR CLOSEPARAMS
.1a1b1a	c2 20		rep #$20	            REP #$20
.1a1b1c	68		pla		            PLA
.1a1b1d	85 c2		sta $08c2	            STA CURRBLOCK+2
.1a1b1f	68		pla		            PLA
.1a1b20	85 c0		sta $08c0	            STA CURRBLOCK
.1a1b22	28		plp		done        PLP
.1a1b23	60		rts		            RTS
.1a1b24					syntax_err
.1a1b24	08		php		            PHP
.1a1b25	c2 20		rep #$20	            REP #$20
.1a1b27	48		pha		            PHA
.1a1b28	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1b2b	5b		tcd		            TCD
.1a1b2c	68		pla		            PLA
.1a1b2d	28		plp		            PLP
.1a1b2e	e2 20		sep #$20	            SEP #$20
.1a1b30	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1b32	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1b36	c2 20		rep #$20	            REP #$20
.1a1b38	29 ff 00	and #$00ff	            AND #$00FF
.1a1b3b	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a1b3e	e2 20		sep #$20	            SEP #$20
.1a1b40	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1b43					notfound
.1a1b43	08		php		            PHP
.1a1b44	c2 20		rep #$20	            REP #$20
.1a1b46	48		pha		            PHA
.1a1b47	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1b4a	5b		tcd		            TCD
.1a1b4b	68		pla		            PLA
.1a1b4c	28		plp		            PLP
.1a1b4d	e2 20		sep #$20	            SEP #$20
.1a1b4f	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a1b51	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1b55	c2 20		rep #$20	            REP #$20
.1a1b57	29 ff 00	and #$00ff	            AND #$00FF
.1a1b5a	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a1b5d	e2 20		sep #$20	            SEP #$20
.1a1b5f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1b62					EVALSTRING
.1a1b62	08		php		            PHP
.1a1b63	0b		phd		            PHD
.1a1b64	08		php		            PHP
.1a1b65	c2 20		rep #$20	            REP #$20
.1a1b67	48		pha		            PHA
.1a1b68	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1b6b	5b		tcd		            TCD
.1a1b6c	68		pla		            PLA
.1a1b6d	28		plp		            PLP
.1a1b6e	e2 20		sep #$20	            SEP #$20
.1a1b70	c2 10		rep #$10	            REP #$10
.1a1b72	20 67 20	jsr $1a2067	            JSR INCBIP
.1a1b75	a0 00 00	ldy #$0000	            LDY #0              ; Ywill be our length counter
.1a1b78	b7 00		lda [$0800],y	count_loop  LDA [BIP],Y         ; Get the character
.1a1b7a	f0 24		beq $1a1ba0	            BEQ error           ; If it's end-of-line, throw an error
.1a1b7c	c9 22		cmp #$22	            CMP #CHAR_DQUOTE    ; Is it the ending double-quote?
.1a1b7e	f0 03		beq $1a1b83	            BEQ found_end       ; Yes: Y should be the length
.1a1b80	c8		iny		            INY
.1a1b81	80 f5		bra $1a1b78	            BRA count_loop
.1a1b83	84 0c		sty $080c	found_end   STY SCRATCH         ; Save the length to SCRATCH
.1a1b85	e2 20		sep #$20	            SEP #$20
.1a1b87	a9 02		lda #$02	            LDA #TYPE_STRING    ; Set the type to allocate to STRING
.1a1b89	a6 0c		ldx $080c	            LDX SCRATCH         ; And the length to the length of the string literal
.1a1b8b	e8		inx		            INX
.1a1b8c	20 4b 14	jsr $1a144b	            JSR TEMPSTRING
.1a1b8f	a0 00 00	ldy #$0000	            LDY #0
.1a1b92	c4 0c		cpy $080c	copy_loop   CPY SCRATCH         ; Have we copied all the characters?
.1a1b94	f0 29		beq $1a1bbf	            BEQ done            ; Yes: we're done
.1a1b96	a7 00		lda [$0800]	            LDA [BIP]           ; No: get the next character
.1a1b98	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And copy it to the allocated string
.1a1b9a	c8		iny		            INY
.1a1b9b	20 67 20	jsr $1a2067	            JSR INCBIP
.1a1b9e	80 f2		bra $1a1b92	            BRA copy_loop       ; And try the next character
.1a1ba0					error
.1a1ba0	08		php		            PHP
.1a1ba1	c2 20		rep #$20	            REP #$20
.1a1ba3	48		pha		            PHA
.1a1ba4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1ba7	5b		tcd		            TCD
.1a1ba8	68		pla		            PLA
.1a1ba9	28		plp		            PLP
.1a1baa	e2 20		sep #$20	            SEP #$20
.1a1bac	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1bae	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1bb2	c2 20		rep #$20	            REP #$20
.1a1bb4	29 ff 00	and #$00ff	            AND #$00FF
.1a1bb7	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a1bba	e2 20		sep #$20	            SEP #$20
.1a1bbc	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1bbf	a9 00		lda #$00	done        LDA #0
.1a1bc1	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a1bc3	c2 20		rep #$20	            REP #$20
.1a1bc5	a5 16		lda $0816	            LDA STRPTR
.1a1bc7	85 23		sta $0823	            STA ARGUMENT1
.1a1bc9	a5 18		lda $0818	            LDA STRPTR+2
.1a1bcb	85 25		sta $0825	            STA ARGUMENT1+2
.1a1bcd	a9 02 00	lda #$0002	            LDA #TYPE_STRING    ; And set the type of ARGUMENT1 to string
.1a1bd0	85 27		sta $0827	            STA ARGTYPE1
.1a1bd2	20 67 20	jsr $1a2067	            JSR INCBIP
.1a1bd5	2b		pld		            PLD
.1a1bd6	28		plp		            PLP
.1a1bd7	60		rts		            RTS
.1a1bd8					EVAL_FUNC
.1a1bd8	08		php		            PHP
.1a1bd9	e2 20		sep #$20	            SEP #$20
.1a1bdb	a7 00		lda [$0800]	            LDA [BIP]           ; Get the token
.1a1bdd	c2 20		rep #$20	            REP #$20
.1a1bdf	29 ff 00	and #$00ff	            AND #$00FF
.1a1be2	20 d6 0b	jsr $1a0bd6	            JSR TOKEVAL
.1a1be5	85 2f		sta $082f	            STA JMP16PTR
.1a1be7	20 c9 19	jsr $1a19c9	            JSR OPENPARAMS
.1a1bea	08		php		            PHP
.1a1beb	e2 20		sep #$20	            SEP #$20
.1a1bed	48		pha		            PHA
.1a1bee	a9 00		lda #$00	            LDA #0
.1a1bf0	48		pha		            PHA
.1a1bf1	ab		plb		            PLB
.1a1bf2	68		pla		            PLA
.1a1bf3	28		plp		            PLP
.1a1bf4	20 fc 1b	jsr $1a1bfc	            JSR OPSTUB
.1a1bf7	20 d3 19	jsr $1a19d3	            JSR CLOSEPARAMS
.1a1bfa	28		plp		            PLP
.1a1bfb	60		rts		            RTS
.1a1bfc					OPSTUB
.1a1bfc	20 67 20	jsr $1a2067	            JSR INCBIP
.1a1bff	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.1a1c02					PROCESSOP
.1a1c02	48		pha		            PHA
.1a1c03	08		php		            PHP
.1a1c04	0b		phd		            PHD
.1a1c05	8b		phb		            PHB
.1a1c06	08		php		            PHP
.1a1c07	c2 20		rep #$20	            REP #$20
.1a1c09	48		pha		            PHA
.1a1c0a	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1c0d	5b		tcd		            TCD
.1a1c0e	68		pla		            PLA
.1a1c0f	28		plp		            PLP
.1a1c10	c2 30		rep #$30	            REP #$30
.1a1c12	20 9b 19	jsr $1a199b	            JSR PLOPERATOR
.1a1c15	89 80 00	bit #$0080	            BIT #$80            ; Check if it's really a token
.1a1c18	f0 37		beq $1a1c51	            BEQ bad_token       ; No: it's a bad token
.1a1c1a	48		pha		            PHA
.1a1c1b	20 d6 0b	jsr $1a0bd6	            JSR TOKEVAL
.1a1c1e	85 2f		sta $082f	            STA JMP16PTR
.1a1c20	68		pla		            PLA
.1a1c21	20 23 0c	jsr $1a0c23	            JSR TOKARITY
.1a1c24	c9 01 00	cmp #$0001	            CMP #1              ; Check the operator's arity
.1a1c27	f0 08		beq $1a1c31	            BEQ pull_arg1       ; If it's 1 just pull one argument from the stack
.1a1c29	c2 30		rep #$30	            REP #$30
.1a1c2b	a2 29 08	ldx #$0829	            LDX #<>ARGUMENT2    ; Pull argument 2 from the stack
.1a1c2e	20 33 19	jsr $1a1933	            JSR PLARGUMENT
.1a1c31					pull_arg1
.1a1c31	c2 30		rep #$30	            REP #$30
.1a1c33	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Pull argument 1 from the stack
.1a1c36	20 33 19	jsr $1a1933	            JSR PLARGUMENT
.1a1c39	08		php		            PHP
.1a1c3a	e2 20		sep #$20	            SEP #$20
.1a1c3c	48		pha		            PHA
.1a1c3d	a9 00		lda #$00	            LDA #0
.1a1c3f	48		pha		            PHA
.1a1c40	ab		plb		            PLB
.1a1c41	68		pla		            PLA
.1a1c42	28		plp		            PLP
.1a1c43	20 53 1c	jsr $1a1c53	            JSR OPSTUB
.1a1c46	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Get return result in argument 1
.1a1c49	20 f5 18	jsr $1a18f5	            JSR PHARGUMENT
.1a1c4c	ab		plb		            PLB
.1a1c4d	2b		pld		            PLD
.1a1c4e	28		plp		            PLP
.1a1c4f	68		pla		            PLA
.1a1c50	60		rts		            RTS
.1a1c51	00		brk #		bad_token   BRK
.1a1c52	ea		nop		            NOP
.1a1c53	6c 2f 08	jmp ($082f)	OPSTUB      JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.1a1c56					EVALEXPR
.1a1c56	08		php		            PHP
.1a1c57	08		php		            PHP
.1a1c58	c2 20		rep #$20	            REP #$20
.1a1c5a	48		pha		            PHA
.1a1c5b	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1c5e	5b		tcd		            TCD
.1a1c5f	68		pla		            PLA
.1a1c60	28		plp		            PLP
.1a1c61	08		php		            PHP
.1a1c62	e2 20		sep #$20	            SEP #$20
.1a1c64	48		pha		            PHA
.1a1c65	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1c67	48		pha		            PHA
.1a1c68	ab		plb		            PLB
.1a1c69	68		pla		            PLA
.1a1c6a	28		plp		            PLP
.1a1c6b	c2 10		rep #$10	            REP #$10
.1a1c6d	da		phx		            PHX
.1a1c6e					get_char
.1a1c6e	e2 20		sep #$20	            SEP #$20
.1a1c70	a7 00		lda [$0800]	            LDA [BIP]           ; Get the character
.1a1c72	d0 03		bne $1a1c77	            BNE else1
.1a1c74	4c 19 1d	jmp $1a1d19	            JMP proc_stack      ; Handle end of line, if we see it
.1a1c77	30 33		bmi $1a1cac	else1       BMI is_token        ; If MSB is set, it's a token
.1a1c79	c9 20		cmp #$20	            CMP #' '            ; Is it a space?
.1a1c7b	d0 03		bne $1a1c80	            BNE else2
.1a1c7d	4c 13 1d	jmp $1a1d13	            JMP next_char       ; Yes: Skip to the next character
.1a1c80	c9 3a		cmp #$3a	else2       CMP #'9'+1          ; Check to see if we have digits
.1a1c82	b0 04		bcs $1a1c88	            BCS else3           ; No: treat as the end of the line
.1a1c84	c9 30		cmp #$30	            CMP #'0'
.1a1c86	b0 56		bcs $1a1cde	            BCS is_digit
.1a1c88	c9 26		cmp #$26	else3       CMP #'&'            ; Check for a hexadecimal prefix
.1a1c8a	f0 52		beq $1a1cde	            BEQ is_digit
.1a1c8c	c9 22		cmp #$22	            CMP #'"'            ; Is it a double-quote?
.1a1c8e	d0 03		bne $1a1c93	            BNE else4
.1a1c90	4c 2c 1d	jmp $1a1d2c	            JMP is_string       ; Yes: process the string
.1a1c93	c9 5b		cmp #$5b	else4       CMP #'Z'+1          ; Check to see if we have upper case alphabetics
.1a1c95	b0 07		bcs $1a1c9e	            BCS check_lc        ; No: check for lower case
.1a1c97	c9 41		cmp #$41	            CMP #'A'
.1a1c99	90 03		bcc $1a1c9e	            BCC check_lc
.1a1c9b	4c 38 1d	jmp $1a1d38	            JMP is_alpha
.1a1c9e	c9 7b		cmp #$7b	check_lc    CMP #'z'+1          ; Check to see if we have lower case alphabetics
.1a1ca0	b0 07		bcs $1a1ca9	            BCS else5           ; No: treat as the end of the line
.1a1ca2	c9 61		cmp #$61	            CMP #'a'
.1a1ca4	90 03		bcc $1a1ca9	            BCC else5
.1a1ca6	4c 38 1d	jmp $1a1d38	            JMP is_alpha
.1a1ca9	4c 19 1d	jmp $1a1d19	else5       JMP proc_stack
.1a1cac	c9 8f		cmp #$8f	is_token    CMP #TOK_LPAREN     ; Is it an LPAREN
.1a1cae	f0 40		beq $1a1cf0	            BEQ is_lparen       ; Yes: handle the LPAREN
.1a1cb0	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it an RPAREN?
.1a1cb2	f0 41		beq $1a1cf5	            BEQ is_rparen       ; Yes: handle the RPAREN
.1a1cb4	20 f9 0b	jsr $1a0bf9	            JSR TOKTYPE
.1a1cb7	c9 30		cmp #$30	            CMP #TOK_TY_FUNC    ; Is it a function?
.1a1cb9	d0 0c		bne $1a1cc7	            BNE chk_op          ; No: check if it's an operator
.1a1cbb	20 d8 1b	jsr $1a1bd8	            JSR EVAL_FUNC
.1a1cbe	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.1a1cc1	20 f5 18	jsr $1a18f5	            JSR PHARGUMENT
.1a1cc4	4c 6e 1c	jmp $1a1c6e	            JMP get_char
.1a1cc7	c9 00		cmp #$00	chk_op      CMP #TOK_TY_OP      ; Is it an operator?
.1a1cc9	d0 4e		bne $1a1d19	            BNE proc_stack      ; No: we're finished processing
.1a1ccb	a7 00		lda [$0800]	            LDA [BIP]           ; Yes: Get the token back
.1a1ccd	a6 21		ldx $0821	chk_prec    LDX OPERATORSP      ; Is the operator stack empty?
.1a1ccf	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.1a1cd2	f0 05		beq $1a1cd9	            BEQ push_op         ; Yes: push the operator
.1a1cd4	20 12 1a	jsr $1a1a12	            JSR OPHIGHPREC
.1a1cd7	b0 12		bcs $1a1ceb	            BCS process1        ; No: we should process the top operator
.1a1cd9					push_op
.1a1cd9	20 72 19	jsr $1a1972	            JSR PHOPERATOR
.1a1cdc	80 35		bra $1a1d13	            BRA next_char       ; And go to the next character
.1a1cde					is_digit
.1a1cde	c2 20		rep #$20	            REP #$20
.1a1ce0	20 e4 58	jsr $1a58e4	            JSR PARSENUM
.1a1ce3	a2 23 08	ldx #$0823	got_number  LDX #<>ARGUMENT1
.1a1ce6	20 f5 18	jsr $1a18f5	            JSR PHARGUMENT
.1a1ce9	80 83		bra $1a1c6e	            BRA get_char
.1a1ceb					process1
.1a1ceb	20 02 1c	jsr $1a1c02	            JSR PROCESSOP
.1a1cee	80 dd		bra $1a1ccd	            BRA chk_prec        ; And check what to do with the current operator
.1a1cf0					is_lparen
.1a1cf0	20 72 19	jsr $1a1972	            JSR PHOPERATOR
.1a1cf3	80 1e		bra $1a1d13	            BRA next_char
.1a1cf5					is_rparen
.1a1cf5	e2 20		sep #$20	            SEP #$20
.1a1cf7	a4 21		ldy $0821	            LDY OPERATORSP      ; Is the operator stack empty?
.1a1cf9	c0 ff 7f	cpy #$7fff	            CPY #<>OPERATOR_TOP
.1a1cfc	f0 46		beq $1a1d44	            BEQ done            ; Yes: we're done evaluating things
.1a1cfe	a4 21		ldy $0821	paren_loop  LDY OPERATORSP      ; Peek at the top operator
.1a1d00	b9 01 00	lda $0001,y	            LDA #1,B,Y
.1a1d03	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the LPAREN of a function?
.1a1d05	f0 3d		beq $1a1d44	            BEQ done            ; Yes: treat it as an empty stack
.1a1d07	c9 8f		cmp #$8f	            CMP #TOK_LPAREN     ; Is it an LPAREN?
.1a1d09	f0 05		beq $1a1d10	            BEQ done_rparen     ; Yes: we're finished processing
.1a1d0b	20 02 1c	jsr $1a1c02	            JSR PROCESSOP
.1a1d0e	80 ee		bra $1a1cfe	            BRA paren_loop
.1a1d10					done_rparen
.1a1d10	20 9b 19	jsr $1a199b	            JSR PLOPERATOR
.1a1d13					next_char
.1a1d13	20 67 20	jsr $1a2067	            JSR INCBIP
.1a1d16	4c 6e 1c	jmp $1a1c6e	            JMP get_char
.1a1d19					proc_stack
.1a1d19	a6 21		ldx $0821	            LDX OPERATORSP      ; Is the operator stack empty?
.1a1d1b	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.1a1d1e	b0 24		bcs $1a1d44	            BGE done            ; Yes: return to the caller
.1a1d20	bd 01 00	lda $0001,x	            LDA #1,B,X
.1a1d23	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is top operator a function open?
.1a1d25	f0 1d		beq $1a1d44	            BEQ done            ; Yes: treat as end of expression
.1a1d27	20 02 1c	jsr $1a1c02	            JSR PROCESSOP
.1a1d2a	80 ed		bra $1a1d19	            BRA proc_stack
.1a1d2c					is_string
.1a1d2c	20 62 1b	jsr $1a1b62	            JSR EVALSTRING
.1a1d2f	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.1a1d32	20 f5 18	jsr $1a18f5	            JSR PHARGUMENT
.1a1d35	4c 6e 1c	jmp $1a1c6e	            JMP get_char
.1a1d38					is_alpha
.1a1d38	20 d7 1a	jsr $1a1ad7	            JSR EVALREF
.1a1d3b	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.1a1d3e	20 f5 18	jsr $1a18f5	            JSR PHARGUMENT
.1a1d41	4c 6e 1c	jmp $1a1c6e	            JMP get_char
.1a1d44	a2 23 08	ldx #$0823	done        LDX #<>ARGUMENT1    ; Make sure the result is off the stack
.1a1d47	20 33 19	jsr $1a1933	            JSR PLARGUMENT
.1a1d4a					real_done
.1a1d4a	fa		plx		            PLX
.1a1d4b	28		plp		            PLP
.1a1d4c	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\returnstack.s

.1a1d4d					INITRETURN
.1a1d4d	08		php		                PHP
.1a1d4e	0b		phd		                PHD
.1a1d4f	8b		phb		                PHB
.1a1d50	08		php		            PHP
.1a1d51	e2 20		sep #$20	            SEP #$20
.1a1d53	48		pha		            PHA
.1a1d54	a9 00		lda #$00	            LDA #0
.1a1d56	48		pha		            PHA
.1a1d57	ab		plb		            PLB
.1a1d58	68		pla		            PLA
.1a1d59	28		plp		            PLP
.1a1d5a	08		php		            PHP
.1a1d5b	c2 20		rep #$20	            REP #$20
.1a1d5d	48		pha		            PHA
.1a1d5e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1d61	5b		tcd		            TCD
.1a1d62	68		pla		            PLA
.1a1d63	28		plp		            PLP
.1a1d64	c2 30		rep #$30	            REP #$30
.1a1d66	a9 fd 5f	lda #$5ffd	                LDA #RETURN_TOP-2
.1a1d69	85 33		sta $0833	                STA RETURNSP
.1a1d6b	ab		plb		                PLB
.1a1d6c	2b		pld		                PLD
.1a1d6d	28		plp		                PLP
.1a1d6e	60		rts		            RTS
.1a1d6f					PHRETURN
.1a1d6f	08		php		                PHP
.1a1d70	0b		phd		                PHD
.1a1d71	08		php		            PHP
.1a1d72	c2 20		rep #$20	            REP #$20
.1a1d74	48		pha		            PHA
.1a1d75	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1d78	5b		tcd		            TCD
.1a1d79	68		pla		            PLA
.1a1d7a	28		plp		            PLP
.1a1d7b	c2 30		rep #$30	            REP #$30
.1a1d7d	92 33		sta ($0833)	                STA (RETURNSP)
.1a1d7f	c6 33		dec $0833	                DEC RETURNSP
.1a1d81	c6 33		dec $0833	                DEC RETURNSP
.1a1d83	2b		pld		                PLD
.1a1d84	28		plp		                PLP
.1a1d85	60		rts		            RTS
.1a1d86					PHRETURNB
.1a1d86	08		php		                PHP
.1a1d87	c2 30		rep #$30	            REP #$30
.1a1d89	29 ff 00	and #$00ff	                AND #$00FF
.1a1d8c	20 6f 1d	jsr $1a1d6f	            JSR PHRETURN
.1a1d8f	28		plp		                PLP
.1a1d90	60		rts		            RTS
.1a1d91					PLRETURN
.1a1d91	08		php		                PHP
.1a1d92	0b		phd		                PHD
.1a1d93	08		php		            PHP
.1a1d94	c2 20		rep #$20	            REP #$20
.1a1d96	48		pha		            PHA
.1a1d97	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1d9a	5b		tcd		            TCD
.1a1d9b	68		pla		            PLA
.1a1d9c	28		plp		            PLP
.1a1d9d	c2 30		rep #$30	            REP #$30
.1a1d9f	e6 33		inc $0833	                INC RETURNSP
.1a1da1	e6 33		inc $0833	                INC RETURNSP
.1a1da3	b2 33		lda ($0833)	                LDA (RETURNSP)
.1a1da5	2b		pld		                PLD
.1a1da6	28		plp		                PLP
.1a1da7	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\interpreter.s

=$80					ST_RUNNING = $80            ; The interpreter is running a full program
=$00					ST_INTERACT = $00           ; The interpreter is in interactive mode
>08d2					STATE       .byte ?         ; The state of the interpreter ()
>08d3					ERROR_NUM   .byte ?         ; The type of the error
>08d4					HANDLEERR   .long ?         ; Pointer to the error handler
>08d7					LINENUM     .word ?         ; The current line number
>08d9					LASTLINE    .long ?         ; Pointer to the next free space over the BASIC program
>08dc					EXECACTION  .byte ?         ; The action the exection routines should take to get their next statement
=0					LINE_LINK = 0               ; Offset to the link to the next line
=2					LINE_NUMBER = 2             ; Offset to the line number
=4					LINE_TOKENS = 4             ; Offset to the first token
=6					LINE_MINLEN = 6             ; Minimum length of a line
=0					EXEC_CONT = 0               ; Continue advancing the current line
=1					EXEC_STOP = 1               ; Stop execution of the program
=2					EXEC_GOTO = 2               ; Transfer execution to a new CURLINE that is already set
=3					EXEC_RETURN = 3             ; Transfer execution back to a line that was on the stack
.1a1da8					SET_ERRERL
.1a1da8	8b		phb		                PHB
.1a1da9	0b		phd		                PHD
.1a1daa	08		php		                PHP
.1a1dab	08		php		            PHP
.1a1dac	c2 20		rep #$20	            REP #$20
.1a1dae	48		pha		            PHA
.1a1daf	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1db2	5b		tcd		            TCD
.1a1db3	68		pla		            PLA
.1a1db4	28		plp		            PLP
.1a1db5	08		php		            PHP
.1a1db6	e2 20		sep #$20	            SEP #$20
.1a1db8	48		pha		            PHA
.1a1db9	a9 00		lda #$00	            LDA #BASIC_BANK
.1a1dbb	48		pha		            PHA
.1a1dbc	ab		plb		            PLB
.1a1dbd	68		pla		            PLA
.1a1dbe	28		plp		            PLP
.1a1dbf	c2 20		rep #$20	            REP #$20
.1a1dc1	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.1a1dc3	a9 00 00	lda #$0000	                LDA #0
.1a1dc6	85 25		sta $0825	                STA ARGUMENT1+2
.1a1dc8	e2 20		sep #$20	            SEP #$20
.1a1dca	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a1dcc	85 27		sta $0827	                STA ARGTYPE1
.1a1dce	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.1a1dd0	a9 1a		lda #$1a	                LDA #`err_name
.1a1dd2	85 e9		sta $08e9	                STA TOFIND+2
.1a1dd4	c2 20		rep #$20	            REP #$20
.1a1dd6	a9 02 1e	lda #$1e02	                LDA #<>err_name
.1a1dd9	85 e7		sta $08e7	                STA TOFIND
.1a1ddb	20 25 52	jsr $1a5225	            JSR VAR_SET
.1a1dde	c2 20		rep #$20	            REP #$20
.1a1de0	a5 d7		lda $08d7	                LDA LINENUM
.1a1de2	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.1a1de4	a5 d9		lda $08d9	                LDA LINENUM+2
.1a1de6	85 25		sta $0825	                STA ARGUMENT1+2
.1a1de8	e2 20		sep #$20	            SEP #$20
.1a1dea	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a1dec	85 27		sta $0827	                STA ARGTYPE1
.1a1dee	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.1a1df0	a9 1a		lda #$1a	                LDA #`erl_name
.1a1df2	85 e9		sta $08e9	                STA TOFIND+2
.1a1df4	c2 20		rep #$20	            REP #$20
.1a1df6	a9 06 1e	lda #$1e06	                LDA #<>erl_name
.1a1df9	85 e7		sta $08e7	                STA TOFIND
.1a1dfb	20 25 52	jsr $1a5225	            JSR VAR_SET
.1a1dfe	28		plp		                PLP
.1a1dff	2b		pld		                PLD
.1a1e00	ab		plb		                PLB
.1a1e01	60		rts		            RTS
>1a1e02	45 52 52 00			err_name        .null "ERR"
>1a1e06	45 52 4c 00			erl_name        .null "ERL"
.1a1e0a					ON_ERROR
.1a1e0a	e2 20		sep #$20	            SEP #$20
.1a1e0c	c2 10		rep #$10	            REP #$10
.1a1e0e	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a1e11	af d3 08 00	lda $0008d3	            LDA @lERROR_NUM         ; Calculate index to the error message pointer
.1a1e15	0a		asl a		            ASL A
.1a1e16	c2 20		rep #$20	            REP #$20
.1a1e18	29 ff 00	and #$00ff	            AND #$00FF
.1a1e1b	a8		tay		            TAY
.1a1e1c	08		php		            PHP
.1a1e1d	e2 20		sep #$20	            SEP #$20
.1a1e1f	48		pha		            PHA
.1a1e20	a9 1a		lda #$1a	            LDA #`ERRORMSG
.1a1e22	48		pha		            PHA
.1a1e23	ab		plb		            PLB
.1a1e24	68		pla		            PLA
.1a1e25	28		plp		            PLP
.1a1e26	be 5c 1e	ldx $1a1e5c,y	            LDX ERRORMSG,Y
.1a1e29	20 b3 03	jsr $1a03b3	            JSR PRINTS
.1a1e2c	c2 20		rep #$20	            REP #$20
.1a1e2e	a5 d7		lda $08d7	            LDA LINENUM
.1a1e30	f0 27		beq $1a1e59	            BEQ skip_at
.1a1e32	a2 8c 1e	ldx #$1e8c	            LDX #<>MSG_AT           ; If so... print " AT "
.1a1e35	20 b3 03	jsr $1a03b3	            JSR PRINTS
.1a1e38	08		php		            PHP
.1a1e39	e2 20		sep #$20	            SEP #$20
.1a1e3b	48		pha		            PHA
.1a1e3c	a9 00		lda #$00	            LDA #BASIC_BANK
.1a1e3e	48		pha		            PHA
.1a1e3f	ab		plb		            PLB
.1a1e40	68		pla		            PLA
.1a1e41	28		plp		            PLP
.1a1e42	c2 20		rep #$20	            REP #$20
.1a1e44	af d7 08 00	lda $0008d7	            LDA @lLINENUM           ; ... and then the line number
.1a1e48	8f 23 08 00	sta $000823	            STA @lARGUMENT1
.1a1e4c	a9 00 00	lda #$0000	            LDA #0
.1a1e4f	8f 25 08 00	sta $000825	            STA @lARGUMENT1+2
.1a1e53	20 1b 45	jsr $1a451b	            JSR PR_INTEGER
.1a1e56	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a1e59					skip_at
.1a1e59	4c 0a 27	jmp $1a270a	            JMP INTERACT
>1a1e5c	90 1e				ERRORMSG    .word <>MSG_OK
>1a1e5e	93 1e				            .word <>MSG_BREAK
>1a1e60	99 1e				            .word <>MSG_SYNTAX
>1a1e62	a6 1e				            .word <>MSG_MEMORY
>1a1e64	b4 1e				            .word <>MSG_TYPE
>1a1e66	c2 1e				            .word <>MSG_NOTFND
>1a1e68	d5 1e				            .word <>MSG_NOLINE
>1a1e6a	eb 1e				            .word <>MSG_UNDFLOW
>1a1e6c	fb 1e				            .word <>MSG_OVRFLOW
>1a1e6e	0a 1f				            .word <>MSG_RANGE
>1a1e70	17 1f				            .word <>MSG_ARG
>1a1e72	28 1f				            .word <>MSG_NOFILE
>1a1e74	37 1f				            .word <>MSG_NAN
>1a1e76	44 1f				            .word <>MSG_OVERFLOW
>1a1e78	52 1f				            .word <>MSG_UNDERFLOW
>1a1e7a	61 1f				            .word <>MSG_DIV0
>1a1e7c	72 1f				            .word <>MSG_DIRECTORY
>1a1e7e	8b 1f				            .word <>MSG_LOAD
>1a1e80	9f 1f				            .word <>MSG_SAVE
>1a1e82	b3 1f				            .word <>MSG_DELETE
>1a1e84	c9 1f				            .word <>MSG_FILENOTFND
>1a1e86	dd 1f				            .word <>MSG_DIRNOTWRITE
>1a1e88	f8 1f				            .word <>MSG_NOTCOPIED
>1a1e8a	10 20				            .word <>MSG_DOMAIN
>1a1e8c	20 61 74 00			MSG_AT          .null " at"
>1a1e90	4f 4b 00			MSG_OK          .null "OK"
>1a1e93	42 72 65 61 6b 00		MSG_BREAK       .null "Break"
>1a1e99	53 79 6e 74 61 78 20 65		MSG_SYNTAX      .null "Syntax error"
>1a1ea1	72 72 6f 72 00
>1a1ea6	4f 75 74 20 6f 66 20 6d		MSG_MEMORY      .null "Out of memory"
>1a1eae	65 6d 6f 72 79 00
>1a1eb4	54 79 70 65 20 6d 69 73		MSG_TYPE        .null "Type mismatch"
>1a1ebc	6d 61 74 63 68 00
>1a1ec2	56 61 72 69 61 62 6c 65		MSG_NOTFND      .null "Variable not found"
>1a1eca	20 6e 6f 74 20 66 6f 75 6e 64 00
>1a1ed5	4c 69 6e 65 20 6e 75 6d		MSG_NOLINE      .null "Line number not found"
>1a1edd	62 65 72 20 6e 6f 74 20 66 6f 75 6e 64 00
>1a1eeb	53 74 61 63 6b 20 75 6e		MSG_UNDFLOW     .null "Stack underflow"
>1a1ef3	64 65 72 66 6c 6f 77 00
>1a1efb	53 74 61 63 6b 20 6f 76		MSG_OVRFLOW     .null "Stack overflow"
>1a1f03	65 72 66 6c 6f 77 00
>1a1f0a	4f 75 74 20 6f 66 20 72		MSG_RANGE       .null "Out of range"
>1a1f12	61 6e 67 65 00
>1a1f17	49 6c 6c 65 67 61 6c 20		MSG_ARG         .null "Illegal argument"
>1a1f1f	61 72 67 75 6d 65 6e 74 00
>1a1f28	46 69 6c 65 20 6e 6f 74		MSG_NOFILE      .null "File not found"
>1a1f30	20 66 6f 75 6e 64 00
>1a1f37	4e 6f 74 20 61 20 6e 75		MSG_NAN         .null "Not a number"
>1a1f3f	6d 62 65 72 00
>1a1f44	4d 61 74 68 20 6f 76 65		MSG_OVERFLOW    .null "Math overflow"
>1a1f4c	72 66 6c 6f 77 00
>1a1f52	4d 61 74 68 20 75 6e 64		MSG_UNDERFLOW   .null "Math underflow"
>1a1f5a	65 72 66 6c 6f 77 00
>1a1f61	44 69 76 69 73 69 6f 6e		MSG_DIV0        .null "Division by zero"
>1a1f69	20 62 79 20 7a 65 72 6f 00
>1a1f72	55 6e 61 62 6c 65 20 74		MSG_DIRECTORY   .null "Unable to read directory"
>1a1f7a	6f 20 72 65 61 64 20 64 69 72 65 63 74 6f 72 79
>1a1f8a	00
>1a1f8b	55 6e 61 62 6c 65 20 74		MSG_LOAD        .null "Unable to load file"
>1a1f93	6f 20 6c 6f 61 64 20 66 69 6c 65 00
>1a1f9f	55 6e 61 62 6c 65 20 74		MSG_SAVE        .null "Unable to save file"
>1a1fa7	6f 20 73 61 76 65 20 66 69 6c 65 00
>1a1fb3	55 6e 61 62 6c 65 20 74		MSG_DELETE      .null "Unable to delete file"
>1a1fbb	6f 20 64 65 6c 65 74 65 20 66 69 6c 65 00
>1a1fc9	43 6f 75 6c 64 20 6e 6f		MSG_FILENOTFND  .null "Could not find file"
>1a1fd1	74 20 66 69 6e 64 20 66 69 6c 65 00
>1a1fdd	43 6f 75 6c 64 20 6e 6f		MSG_DIRNOTWRITE .null "Could not update directory"
>1a1fe5	74 20 75 70 64 61 74 65 20 64 69 72 65 63 74 6f
>1a1ff5	72 79 00
>1a1ff8	43 6f 75 6c 64 20 6e 6f		MSG_NOTCOPIED   .null "Could not copy the file"
>1a2000	74 20 63 6f 70 79 20 74 68 65 20 66 69 6c 65 00
>1a2010	41 72 67 75 6d 65 6e 74		MSG_DOMAIN      .null "Argument outside domain"
>1a2018	20 6f 75 74 73 69 64 65 20 64 6f 6d 61 69 6e 00
.1a2028					SETINTERACT
.1a2028	08		php		            PHP
.1a2029	0b		phd		            PHD
.1a202a	08		php		            PHP
.1a202b	c2 20		rep #$20	            REP #$20
.1a202d	48		pha		            PHA
.1a202e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2031	5b		tcd		            TCD
.1a2032	68		pla		            PLA
.1a2033	28		plp		            PLP
.1a2034	e2 20		sep #$20	            SEP #$20
.1a2036	a9 00		lda #$00	            LDA #ST_INTERACT
.1a2038	85 d2		sta $08d2	            STA STATE
.1a203a	2b		pld		            PLD
.1a203b	28		plp		            PLP
.1a203c	60		rts		            RTS
.1a203d					CLRINTERP
.1a203d	0b		phd		            PHD
.1a203e	08		php		            PHP
.1a203f	08		php		            PHP
.1a2040	c2 20		rep #$20	            REP #$20
.1a2042	48		pha		            PHA
.1a2043	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2046	5b		tcd		            TCD
.1a2047	68		pla		            PLA
.1a2048	28		plp		            PLP
.1a2049	08		php		            PHP
.1a204a	c2 20		rep #$20	            REP #$20
.1a204c	a9 0a 1e	lda #$1e0a	            LDA #<>ON_ERROR
.1a204f	8f d4 08 00	sta $0008d4	            STA @lHANDLEERR
.1a2053	e2 20		sep #$20	            SEP #$20
.1a2055	a9 1a		lda #$1a	            LDA #`ON_ERROR
.1a2057	8f d6 08 00	sta $0008d6	            STA @lHANDLEERR+2
.1a205b	28		plp		            PLP
.1a205c	20 c2 43	jsr $1a43c2	            JSR S_CLR
.1a205f	20 03 3f	jsr $1a3f03	            JSR S_RESTORE
.1a2062	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the depth of the GOSUB stack
.1a2064	28		plp		            PLP
.1a2065	2b		pld		            PLD
.1a2066	60		rts		            RTS
.1a2067					INCBIP
.1a2067	08		php		            PHP
.1a2068	0b		phd		            PHD
.1a2069	08		php		            PHP
.1a206a	c2 20		rep #$20	            REP #$20
.1a206c	48		pha		            PHA
.1a206d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2070	5b		tcd		            TCD
.1a2071	68		pla		            PLA
.1a2072	28		plp		            PLP
.1a2073	c2 20		rep #$20	            REP #$20
.1a2075	18		clc		            CLC
.1a2076	a5 00		lda $0800	            LDA BIP
.1a2078	69 01 00	adc #$0001	            ADC #1
.1a207b	85 00		sta $0800	            STA BIP
.1a207d	e2 20		sep #$20	            SEP #$20
.1a207f	a5 02		lda $0802	            LDA BIP+2
.1a2081	69 00		adc #$00	            ADC #0
.1a2083	85 02		sta $0802	            STA BIP+2
.1a2085	2b		pld		            PLD
.1a2086	28		plp		            PLP
.1a2087	60		rts		            RTS
.1a2088					SKIPWS
.1a2088	08		php		            PHP
.1a2089	0b		phd		            PHD
.1a208a	08		php		            PHP
.1a208b	c2 20		rep #$20	            REP #$20
.1a208d	48		pha		            PHA
.1a208e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2091	5b		tcd		            TCD
.1a2092	68		pla		            PLA
.1a2093	28		plp		            PLP
.1a2094	e2 20		sep #$20	            SEP #$20
.1a2096	a7 00		lda [$0800]	loop        LDA [BIP]
.1a2098	f0 0f		beq $1a20a9	            BEQ done            ; If character is 0, we've reached the end of the line
.1a209a	c9 20		cmp #$20	            CMP #CHAR_SP        ; Skip if it's a space
.1a209c	f0 06		beq $1a20a4	            BEQ skip_char
.1a209e	c9 09		cmp #$09	            CMP #CHAR_TAB       ; Skip if it's a TAB
.1a20a0	f0 02		beq $1a20a4	            BEQ skip_char
.1a20a2	80 05		bra $1a20a9	            BRA done            ; Otherwise, we're done and BIP points to a non-whitespace
.1a20a4					skip_char
.1a20a4	20 67 20	jsr $1a2067	            JSR INCBIP
.1a20a7	80 ed		bra $1a2096	            BRA loop
.1a20a9	2b		pld		done        PLD
.1a20aa	28		plp		            PLP
.1a20ab	60		rts		            RTS
.1a20ac					SKIPSTMT
.1a20ac	08		php		            PHP
.1a20ad	e2 20		sep #$20	            SEP #$20
.1a20af	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the current character
.1a20b1	f0 09		beq $1a20bc	            BEQ done            ; Is it EOL? Yes, we're done
.1a20b3	c9 3a		cmp #$3a	            CMP #':'            ; Is it a colon?
.1a20b5	f0 05		beq $1a20bc	            BEQ done            ; Yes, we're done
.1a20b7	20 67 20	jsr $1a2067	            JSR INCBIP
.1a20ba	80 f3		bra $1a20af	            BRA loop            ; and check it...
.1a20bc	28		plp		done        PLP
.1a20bd	60		rts		            RTS
.1a20be					SKIPTOTOK
.1a20be	08		php		            PHP
.1a20bf	e2 20		sep #$20	            SEP #$20
.1a20c1	64 36		stz $0836	            STZ NESTING
.1a20c3	a7 00		lda [$0800]	loop        LDA [BIP]           ; Get the character
.1a20c5	f0 19		beq $1a20e0	            BEQ end_of_line     ; EOL? Yes: move to the next line
.1a20c7	c5 37		cmp $0837	            CMP TARGETTOK       ; Is it the one we want?
.1a20c9	f0 2c		beq $1a20f7	            BEQ check_depth     ; Yes: check the depth
.1a20cb	c9 9b		cmp #$9b	            CMP #TOK_FOR        ; Is it a FOR?
.1a20cd	f0 1e		beq $1a20ed	            BEQ inc_nesting     ; Yes: increment NESTING
.1a20cf	c9 9f		cmp #$9f	            CMP #TOK_DO         ; Is it a DO?
.1a20d1	f0 1a		beq $1a20ed	            BEQ inc_nesting     ; Yes: increment NESTING
.1a20d3	c9 9e		cmp #$9e	            CMP #TOK_NEXT       ; Is it a NEXT?
.1a20d5	f0 1a		beq $1a20f1	            BEQ dec_nesting     ; Yes: decrement NESTING
.1a20d7	c9 a0		cmp #$a0	            CMP #TOK_LOOP       ; Is it a LOOP?
.1a20d9	f0 16		beq $1a20f1	            BEQ dec_nesting     ; Yes: decrement NESTING
.1a20db					incloop
.1a20db	20 67 20	jsr $1a2067	            JSR INCBIP
.1a20de	80 e3		bra $1a20c3	            BRA loop            ; and keep scanning
.1a20e0					end_of_line
.1a20e0	20 44 21	jsr $1a2144	            JSR NEXTLINE
.1a20e3	c2 20		rep #$20	            REP #$20
.1a20e5	a5 d7		lda $08d7	            LDA LINENUM         ; Check the line number
.1a20e7	f0 1d		beq $1a2106	            BEQ syntax_err1     ; If it's zero, we reached the end of the program
.1a20e9	e2 20		sep #$20	            SEP #$20
.1a20eb	80 d6		bra $1a20c3	            BRA loop            ; And keep scanning
.1a20ed					inc_nesting
.1a20ed	e6 36		inc $0836	            INC NESTING         ; Track that we have entered a lexical scope for a FOR/DO
.1a20ef	80 ea		bra $1a20db	            BRA incloop
.1a20f1					dec_nesting
.1a20f1	c6 36		dec $0836	            DEC NESTING         ; Track that we have left a lexical scope for a FOR/DO
.1a20f3	30 30		bmi $1a2125	            BMI syntax_err2     ; If the depth goes <0, throw a syntax error
.1a20f5	80 e4		bra $1a20db	            BRA incloop
.1a20f7					check_depth
.1a20f7	a5 35		lda $0835	            LDA SKIPNEST        ; Check to see if nesting matters
.1a20f9	30 06		bmi $1a2101	            BMI found           ; No: just return that we found the token
.1a20fb	a5 36		lda $0836	            LDA NESTING         ; Get the nesting depth
.1a20fd	f0 02		beq $1a2101	            BEQ found           ; If it's zero, we found our token
.1a20ff	80 da		bra $1a20db	            BRA incloop         ; Otherwise: it's a token for an enclosed FOR/DO, keep scanning
.1a2101					found
.1a2101	20 67 20	jsr $1a2067	            JSR INCBIP
.1a2104	28		plp		            PLP
.1a2105	60		rts		            RTS
.1a2106					syntax_err1
.1a2106	08		php		            PHP
.1a2107	c2 20		rep #$20	            REP #$20
.1a2109	48		pha		            PHA
.1a210a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a210d	5b		tcd		            TCD
.1a210e	68		pla		            PLA
.1a210f	28		plp		            PLP
.1a2110	e2 20		sep #$20	            SEP #$20
.1a2112	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a2114	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2118	c2 20		rep #$20	            REP #$20
.1a211a	29 ff 00	and #$00ff	            AND #$00FF
.1a211d	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a2120	e2 20		sep #$20	            SEP #$20
.1a2122	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2125					syntax_err2
.1a2125	08		php		            PHP
.1a2126	c2 20		rep #$20	            REP #$20
.1a2128	48		pha		            PHA
.1a2129	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a212c	5b		tcd		            TCD
.1a212d	68		pla		            PLA
.1a212e	28		plp		            PLP
.1a212f	e2 20		sep #$20	            SEP #$20
.1a2131	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a2133	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2137	c2 20		rep #$20	            REP #$20
.1a2139	29 ff 00	and #$00ff	            AND #$00FF
.1a213c	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a213f	e2 20		sep #$20	            SEP #$20
.1a2141	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2144					NEXTLINE
.1a2144	08		php		            PHP
.1a2145	c2 30		rep #$30	            REP #$30
.1a2147	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a214a	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the offset to the next line
.1a214c	85 0c		sta $080c	            STA SCRATCH
.1a214e	18		clc		            CLC                 ; Compute the new CURLINE
.1a214f	a5 1a		lda $081a	            LDA CURLINE         ; CURLINE := [CURLINE].LINE_LINK
.1a2151	65 0c		adc $080c	            ADC SCRATCH
.1a2153	85 1a		sta $081a	            STA CURLINE
.1a2155	a5 1c		lda $081c	            LDA CURLINE+2
.1a2157	69 00 00	adc #$0000	            ADC #0
.1a215a	85 1c		sta $081c	            STA CURLINE+2
.1a215c	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the LINENUM to the new current line's number
.1a215f	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; LINENUM := [CURLINE].LINE_NUMBER
.1a2161	85 d7		sta $08d7	            STA LINENUM
.1a2163	18		clc		            CLC                 ; Point BIP to the first character of the line
.1a2164	a5 1a		lda $081a	            LDA CURLINE         ; BIP := CURLINE + LINE_TOKENS
.1a2166	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a2169	85 00		sta $0800	            STA BIP
.1a216b	a5 1c		lda $081c	            LDA CURLINE+2
.1a216d	69 00 00	adc #$0000	            ADC #0
.1a2170	85 02		sta $0802	            STA BIP+2
.1a2172	28		plp		            PLP
.1a2173	60		rts		            RTS
.1a2174					EXPECT_TOK
.1a2174	08		php		            PHP
.1a2175	e2 20		sep #$20	            SEP #$20
.1a2177	48		pha		            PHA
.1a2178	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a217b	68		pla		            PLA
.1a217c	e2 20		sep #$20	            SEP #$20
.1a217e	c7 00		cmp [$0800]	            CMP [BIP]           ; Check the character at BIP
.1a2180	d0 08		bne $1a218a	            BNE syntax_err      ; Throw a syntax error
.1a2182	20 67 20	jsr $1a2067	            JSR INCBIP
.1a2185	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a2188	28		plp		            PLP
.1a2189	60		rts		            RTS
.1a218a					syntax_err
.1a218a	08		php		            PHP
.1a218b	c2 20		rep #$20	            REP #$20
.1a218d	48		pha		            PHA
.1a218e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2191	5b		tcd		            TCD
.1a2192	68		pla		            PLA
.1a2193	28		plp		            PLP
.1a2194	e2 20		sep #$20	            SEP #$20
.1a2196	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a2198	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a219c	c2 20		rep #$20	            REP #$20
.1a219e	29 ff 00	and #$00ff	            AND #$00FF
.1a21a1	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a21a4	e2 20		sep #$20	            SEP #$20
.1a21a6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a21a9					OPT_TOK
.1a21a9	08		php		            PHP
.1a21aa	e2 20		sep #$20	            SEP #$20
.1a21ac	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a21af	e2 20		sep #$20	            SEP #$20
.1a21b1	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the character at BIP
.1a21b3	f0 10		beq $1a21c5	            BEQ ret_false       ; If end-of-line, return false
.1a21b5	c9 3a		cmp #$3a	            CMP #':'
.1a21b7	f0 0c		beq $1a21c5	            BEQ ret_false       ; If colon, return false
.1a21b9	c5 37		cmp $0837	            CMP TARGETTOK
.1a21bb	f0 05		beq $1a21c2	            BEQ ret_true        ; If matches, return true
.1a21bd	20 67 20	jsr $1a2067	            JSR INCBIP
.1a21c0	80 ef		bra $1a21b1	            BRA loop
.1a21c2	28		plp		ret_true    PLP
.1a21c3	38		sec		            SEC
.1a21c4	60		rts		            RTS
.1a21c5	28		plp		ret_false   PLP
.1a21c6	18		clc		            CLC
.1a21c7	60		rts		            RTS
.1a21c8					PEEK_TOK
.1a21c8	5a		phy		            PHY
.1a21c9	08		php		            PHP
.1a21ca	e2 20		sep #$20	            SEP #$20
.1a21cc	a0 00 00	ldy #$0000	            LDY #0
.1a21cf	b7 00		lda [$0800],y	loop        LDA [BIP],Y
.1a21d1	f0 0d		beq $1a21e0	            BEQ done
.1a21d3	c9 3a		cmp #$3a	            CMP #':'
.1a21d5	f0 07		beq $1a21de	            BEQ ret_null
.1a21d7	c9 20		cmp #$20	            CMP #CHAR_SP
.1a21d9	d0 05		bne $1a21e0	            BNE done
.1a21db	c8		iny		            INY
.1a21dc	80 f1		bra $1a21cf	            BRA loop
.1a21de	a9 00		lda #$00	ret_null    LDA #0
.1a21e0	28		plp		done        PLP
.1a21e1	7a		ply		            PLY
.1a21e2	60		rts		            RTS
.1a21e3					EXECSTMT
.1a21e3	08		php		            PHP
.1a21e4	0b		phd		            PHD
.1a21e5	8b		phb		            PHB
.1a21e6	08		php		            PHP
.1a21e7	c2 20		rep #$20	            REP #$20
.1a21e9	48		pha		            PHA
.1a21ea	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a21ed	5b		tcd		            TCD
.1a21ee	68		pla		            PLA
.1a21ef	28		plp		            PLP
.1a21f0	20 d5 18	jsr $1a18d5	            JSR INITEVALSP
.1a21f3	e2 20		sep #$20	            SEP #$20
.1a21f5	a9 00		lda #$00	            LDA #EXEC_CONT      ; This will tell EXECLINE and EXECPROG to procede in a
.1a21f7	85 dc		sta $08dc	            STA EXECACTION      ; linear fashion through the program
.1a21f9	22 3c 11 00	jsl $00113c	check_break JSL FK_TESTBREAK
.1a21fd	b0 4b		bcs $1a224a	            BCS throw_break     ; If C: user pressed an interrupt key, stop the program
.1a21ff	a7 00		lda [$0800]	            LDA [BIP]           ; If we happen to have a colon, just skip over it.
.1a2201	c9 3a		cmp #$3a	            CMP #':'            ; This can happen with FOR/NEXT
.1a2203	d0 03		bne $1a2208	            BNE eat_ws
.1a2205	20 67 20	jsr $1a2067	            JSR INCBIP
.1a2208					eat_ws
.1a2208	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a220b	a7 00		lda [$0800]	            LDA [BIP]
.1a220d	d0 03		bne $1a2212	            BNE else
.1a220f	4c 94 22	jmp $1a2294	            JMP done            ; If the current byte is 0, we're at the end of the line, just return
.1a2212					else
.1a2212	20 31 04	jsr $1a0431	            JSR ISALPHA
.1a2215	b0 52		bcs $1a2269	            BCS is_variable     ; Yes: we may have a LET statement
.1a2217	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it's any other non-token
.1a2219	10 10		bpl $1a222b	            BPL error           ; Yes: it's a syntax error
.1a221b	20 f9 0b	jsr $1a0bf9	            JSR TOKTYPE
.1a221e	85 0c		sta $080c	            STA SCRATCH         ; Save the type for later
.1a2220	c9 20		cmp #$20	            CMP #TOK_TY_STMNT   ; Is it a statement?
.1a2222	d0 03		bne $1a2227	            BNE else2
.1a2224	4c 82 22	jmp $1a2282	            JMP ok_to_exec      ; Yes: it's ok to try to execute it
.1a2227	a5 d2		lda $08d2	else2       LDA STATE           ; Check to see if we're in interactive mode
.1a2229	f0 51		beq $1a227c	            BEQ is_interact
.1a222b					error
.1a222b	08		php		            PHP
.1a222c	c2 20		rep #$20	            REP #$20
.1a222e	48		pha		            PHA
.1a222f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2232	5b		tcd		            TCD
.1a2233	68		pla		            PLA
.1a2234	28		plp		            PLP
.1a2235	e2 20		sep #$20	            SEP #$20
.1a2237	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a2239	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a223d	c2 20		rep #$20	            REP #$20
.1a223f	29 ff 00	and #$00ff	            AND #$00FF
.1a2242	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a2245	e2 20		sep #$20	            SEP #$20
.1a2247	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a224a					throw_break
.1a224a	08		php		            PHP
.1a224b	c2 20		rep #$20	            REP #$20
.1a224d	48		pha		            PHA
.1a224e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2251	5b		tcd		            TCD
.1a2252	68		pla		            PLA
.1a2253	28		plp		            PLP
.1a2254	e2 20		sep #$20	            SEP #$20
.1a2256	a9 01		lda #$01	            LDA #ERR_BREAK
.1a2258	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a225c	c2 20		rep #$20	            REP #$20
.1a225e	29 ff 00	and #$00ff	            AND #$00FF
.1a2261	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a2264	e2 20		sep #$20	            SEP #$20
.1a2266	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2269					is_variable
.1a2269	20 cc 43	jsr $1a43cc	            JSR S_LET
.1a226c	4c 94 22	jmp $1a2294	            JMP done
.1a226f					STSTUB
.1a226f	08		php		            PHP
.1a2270	e2 20		sep #$20	            SEP #$20
.1a2272	48		pha		            PHA
.1a2273	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a2275	48		pha		            PHA
.1a2276	ab		plb		            PLB
.1a2277	68		pla		            PLA
.1a2278	28		plp		            PLP
.1a2279	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.1a227c	a5 0c		lda $080c	is_interact LDA SCRATCH         ; Get the token type
.1a227e	c9 10		cmp #$10	            CMP #TOK_TY_CMD     ; Is it a command?
.1a2280	d0 a9		bne $1a222b	            BNE error           ; If not, it's an error
.1a2282					ok_to_exec
.1a2282	a7 00		lda [$0800]	            LDA [BIP]           ; Get the original token again
.1a2284	20 d6 0b	jsr $1a0bd6	            JSR TOKEVAL
.1a2287	c2 20		rep #$20	            REP #$20
.1a2289	85 2f		sta $082f	            STA JMP16PTR        ; Store it in the jump pointer
.1a228b	20 d5 18	jsr $1a18d5	            JSR INITEVALSP
.1a228e	20 67 20	jsr $1a2067	            JSR INCBIP
.1a2291	20 6f 22	jsr $1a226f	            JSR STSTUB
.1a2294	ab		plb		done        PLB
.1a2295	2b		pld		            PLD
.1a2296	28		plp		            PLP
.1a2297	60		rts		            RTS
.1a2298					EXECCMD
.1a2298	08		php		            PHP
.1a2299	58		cli		            CLI
.1a229a	20 28 20	jsr $1a2028	            JSR SETINTERACT
.1a229d	20 4d 1d	jsr $1a1d4d	            JSR INITRETURN
.1a22a0	e2 20		sep #$20	            SEP #$20
.1a22a2	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.1a22a5	c2 20		rep #$20	            REP #$20
.1a22a7	a5 1a		lda $081a	            LDA CURLINE         ; Set the BASIC Instruction Pointer to the first byte of the line
.1a22a9	85 00		sta $0800	            STA BIP
.1a22ab	a5 1c		lda $081c	            LDA CURLINE+2
.1a22ad	85 02		sta $0802	            STA BIP+2
.1a22af	4c d9 22	jmp $1a22d9	            JMP exec_loop
.1a22b2	08		php		EXECLINE    PHP
.1a22b3	c2 20		rep #$20	            REP #$20
.1a22b5	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER            ; Set the current line number
.1a22b8	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.1a22ba	85 d7		sta $08d7	            STA LINENUM
.1a22bc	20 42 14	jsr $1a1442	            JSR CLRTMPSTR
.1a22bf	e2 20		sep #$20	            SEP #$20
.1a22c1	a5 dc		lda $08dc	            LDA EXECACTION              ; If the last EXEC action was RETURN
.1a22c3	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; BIP has already been set, so...
.1a22c5	f0 12		beq $1a22d9	            BEQ exec_loop               ; Skip over setting the BIP to the beginning of the line
.1a22c7	c2 20		rep #$20	            REP #$20
.1a22c9	18		clc		            CLC                         ; Set the BASIC Instruction Pointer to the first byte of the line
.1a22ca	a5 1a		lda $081a	            LDA CURLINE
.1a22cc	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a22cf	85 00		sta $0800	            STA BIP
.1a22d1	e2 20		sep #$20	            SEP #$20
.1a22d3	a5 1c		lda $081c	            LDA CURLINE+2
.1a22d5	69 00		adc #$00	            ADC #0
.1a22d7	85 02		sta $0802	            STA BIP+2
.1a22d9					exec_loop
.1a22d9	c2 20		rep #$20	            REP #$20
.1a22db	20 e3 21	jsr $1a21e3	            JSR EXECSTMT
.1a22de	e2 20		sep #$20	            SEP #$20
.1a22e0	a5 dc		lda $08dc	            LDA EXECACTION
.1a22e2	c9 03		cmp #$03	            CMP #EXEC_RETURN
.1a22e4	f0 f3		beq $1a22d9	            BEQ exec_loop
.1a22e6	c9 00		cmp #$00	            CMP #EXEC_CONT              ; If it's not EXEC_CONT, exit to the caller
.1a22e8	d0 31		bne $1a231b	            BNE exec_done
.1a22ea	e2 20		sep #$20	            SEP #$20
.1a22ec	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a22ef	a7 00		lda [$0800]	            LDA [BIP]                   ; Get the current character in the line
.1a22f1	f0 28		beq $1a231b	            BEQ exec_done               ; If it's NULL, we're done
.1a22f3	c9 3a		cmp #$3a	            CMP #':'                    ; If it's colon, we have more statements
.1a22f5	f0 1f		beq $1a2316	            BEQ skip_loop               ; Skip over it and try to execute the next one
.1a22f7	08		php		            PHP
.1a22f8	c2 20		rep #$20	            REP #$20
.1a22fa	48		pha		            PHA
.1a22fb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a22fe	5b		tcd		            TCD
.1a22ff	68		pla		            PLA
.1a2300	28		plp		            PLP
.1a2301	e2 20		sep #$20	            SEP #$20
.1a2303	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a2305	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2309	c2 20		rep #$20	            REP #$20
.1a230b	29 ff 00	and #$00ff	            AND #$00FF
.1a230e	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a2311	e2 20		sep #$20	            SEP #$20
.1a2313	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2316					skip_loop
.1a2316	20 67 20	jsr $1a2067	            JSR INCBIP
.1a2319	80 be		bra $1a22d9	            BRA exec_loop               ; And try to execute another statement
.1a231b					exec_done
.1a231b	28		plp		            PLP
.1a231c	60		rts		            RTS
.1a231d					EXECPROGRAM
.1a231d	08		php		            PHP
.1a231e	58		cli		            CLI
.1a231f	e2 20		sep #$20	            SEP #$20
.1a2321	a9 80		lda #$80	            LDA #ST_RUNNING
.1a2323	85 d2		sta $08d2	            STA STATE
.1a2325	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.1a2328	20 4d 1d	jsr $1a1d4d	            JSR INITRETURN
.1a232b	c2 30		rep #$30	            REP #$30
.1a232d	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the count of GOSUBs
.1a232f	a0 02 00	ldy #$0002	exec_loop   LDY #LINE_NUMBER
.1a2332	b7 1a		lda [$081a],y	            LDA [CURLINE],Y             ; Get the line number of the current line
.1a2334	f0 29		beq $1a235f	            BEQ done                    ; If it's 0, we are finished running code (implicit END)
.1a2336	20 b2 22	jsr $1a22b2	            JSR EXECLINE
.1a2339	e2 20		sep #$20	            SEP #$20
.1a233b	a5 dc		lda $08dc	            LDA EXECACTION              ; Check the EXECACTION from the last line
.1a233d	c9 01		cmp #$01	            CMP #EXEC_STOP              ; Stop execution of the program?
.1a233f	f0 1e		beq $1a235f	            BEQ done
.1a2341	c9 02		cmp #$02	            CMP #EXEC_GOTO              ; Transfer execution to a new CURLINE that is already set
.1a2343	f0 ea		beq $1a232f	            BEQ exec_loop
.1a2345	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; Transfer execution to the CURLINE and BIP that is already set
.1a2347	f0 e6		beq $1a232f	            BEQ exec_loop
.1a2349	c2 20		rep #$20	            REP #$20
.1a234b	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a234e	18		clc		            CLC
.1a234f	a5 1a		lda $081a	            LDA CURLINE
.1a2351	77 1a		adc [$081a],y	            ADC [CURLINE],Y
.1a2353	85 1a		sta $081a	            STA CURLINE
.1a2355	e2 20		sep #$20	            SEP #$20
.1a2357	a5 1c		lda $081c	            LDA CURLINE+2
.1a2359	69 00		adc #$00	            ADC #0
.1a235b	85 1c		sta $081c	            STA CURLINE+2
.1a235d	80 d0		bra $1a232f	            BRA exec_loop               ; And try to execute that line
.1a235f					done
.1a235f	e2 20		sep #$20	            SEP #$20
.1a2361	a9 00		lda #$00	            LDA #ST_INTERACT            ; Set interpreter state to RUNNING
.1a2363	85 d2		sta $08d2	            STA STATE
.1a2365	28		plp		            PLP
.1a2366	60		rts		            RTS
.1a2367					FINDLINE
.1a2367	08		php		            PHP
.1a2368	c2 30		rep #$30	            REP #$30
.1a236a	c2 20		rep #$20	            REP #$20
.1a236c	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT            ; INDEX points to the first line of the program
.1a236f	85 08		sta $0808	            STA INDEX
.1a2371	a9 16 00	lda #$0016	            LDA #`BASIC_BOT
.1a2374	85 0a		sta $080a	            STA INDEX+2
.1a2376	c2 20		rep #$20	            REP #$20
.1a2378	a0 02 00	ldy #$0002	check_nmbrs LDY #LINE_NUMBER            ; Get the number of the possible target line
.1a237b	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a237d	f0 31		beq $1a23b0	            BEQ ret_false               ; If new line number is 0, we got to the
.1a237f	c5 23		cmp $0823	            CMP ARGUMENT1               ; Compare it to the target line number
.1a2381	f0 1e		beq $1a23a1	            BEQ found
.1a2383	b0 2b		bcs $1a23b0	            BGE ret_false               ; If the line number > target line number, the line is not present
.1a2385					next_line
.1a2385	c2 20		rep #$20	            REP #$20
.1a2387	a0 00 00	ldy #$0000	            LDY #LINE_LINK              ; INDEX := INDEX + [INDEX].LINK
.1a238a	18		clc		            CLC
.1a238b	a5 08		lda $0808	            LDA INDEX
.1a238d	77 08		adc [$0808],y	            ADC [INDEX],Y
.1a238f	85 0c		sta $080c	            STA SCRATCH
.1a2391	e2 20		sep #$20	            SEP #$20
.1a2393	a5 0a		lda $080a	            LDA INDEX+2
.1a2395	69 00		adc #$00	            ADC #0
.1a2397	85 0a		sta $080a	            STA INDEX+2
.1a2399	c2 20		rep #$20	            REP #$20
.1a239b	a5 0c		lda $080c	            LDA SCRATCH
.1a239d	85 08		sta $0808	            STA INDEX
.1a239f	80 d7		bra $1a2378	            BRA check_nmbrs             ; And go back to check the new line INDEX is pointing to
.1a23a1					found
.1a23a1	c2 20		rep #$20	            REP #$20
.1a23a3	a5 08		lda $0808	            LDA INDEX
.1a23a5	85 1a		sta $081a	            STA CURLINE
.1a23a7	e2 20		sep #$20	            SEP #$20
.1a23a9	a5 0a		lda $080a	            LDA INDEX+2
.1a23ab	85 1c		sta $081c	            STA CURLINE+2
.1a23ad	28		plp		ret_true    PLP                         ; Return true to indicate we've found the line
.1a23ae	38		sec		            SEC
.1a23af	60		rts		            RTS
.1a23b0	28		plp		ret_false   PLP
.1a23b1	18		clc		            CLC
.1a23b2	60		rts		            RTS
.1a23b3					MVPROGDN
.1a23b3	08		php		            PHP
.1a23b4					mvd_loop
.1a23b4	e2 20		sep #$20	            SEP #$20
.1a23b6	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.1a23b8	87 08		sta [$0808]	            STA [INDEX]
.1a23ba	c2 20		rep #$20	            REP #$20
.1a23bc	a5 0c		lda $080c	            LDA SCRATCH
.1a23be	c5 00		cmp $0800	            CMP BIP
.1a23c0	d0 08		bne $1a23ca	            BNE increment
.1a23c2	e2 20		sep #$20	            SEP #$20
.1a23c4	a5 0e		lda $080e	            LDA SCRATCH+2
.1a23c6	c5 02		cmp $0802	            CMP BIP+2
.1a23c8	f0 26		beq $1a23f0	            BEQ done            ; Yes: return
.1a23ca					increment
.1a23ca	c2 20		rep #$20	            REP #$20
.1a23cc	18		clc		            CLC
.1a23cd	a5 0c		lda $080c	            LDA SCRATCH
.1a23cf	69 01 00	adc #$0001	            ADC #1
.1a23d2	85 0c		sta $080c	            STA SCRATCH
.1a23d4	e2 20		sep #$20	            SEP #$20
.1a23d6	a5 0e		lda $080e	            LDA SCRATCH+2
.1a23d8	69 00		adc #$00	            ADC #0
.1a23da	85 0e		sta $080e	            STA SCRATCH+2
.1a23dc	c2 20		rep #$20	            REP #$20
.1a23de	18		clc		            CLC
.1a23df	a5 08		lda $0808	            LDA INDEX
.1a23e1	69 01 00	adc #$0001	            ADC #1
.1a23e4	85 08		sta $0808	            STA INDEX
.1a23e6	e2 20		sep #$20	            SEP #$20
.1a23e8	a5 0a		lda $080a	            LDA INDEX+2
.1a23ea	69 00		adc #$00	            ADC #0
.1a23ec	85 0a		sta $080a	            STA INDEX+2
.1a23ee	80 c4		bra $1a23b4	            BRA mvd_loop        ; And try again
.1a23f0	28		plp		done        PLP
.1a23f1	60		rts		            RTS
.1a23f2					MVPROGUP
.1a23f2	08		php		            PHP
.1a23f3					mvu_loop
.1a23f3	e2 20		sep #$20	            SEP #$20
.1a23f5	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.1a23f7	87 08		sta [$0808]	            STA [INDEX]
.1a23f9	c2 20		rep #$20	            REP #$20
.1a23fb	a5 0c		lda $080c	            LDA SCRATCH
.1a23fd	c5 00		cmp $0800	            CMP BIP
.1a23ff	d0 06		bne $1a2407	            BNE decrement
.1a2401	a5 0e		lda $080e	            LDA SCRATCH+2
.1a2403	c5 02		cmp $0802	            CMP BIP+2
.1a2405	f0 26		beq $1a242d	            BEQ done            ; Yes: return
.1a2407					decrement
.1a2407	c2 20		rep #$20	            REP #$20
.1a2409	38		sec		            SEC
.1a240a	a5 0c		lda $080c	            LDA SCRATCH
.1a240c	e9 01 00	sbc #$0001	            SBC #1
.1a240f	85 0c		sta $080c	            STA SCRATCH
.1a2411	e2 20		sep #$20	            SEP #$20
.1a2413	a5 0e		lda $080e	            LDA SCRATCH+2
.1a2415	e9 00		sbc #$00	            SBC #0
.1a2417	85 0e		sta $080e	            STA SCRATCH+2
.1a2419	c2 20		rep #$20	            REP #$20
.1a241b	38		sec		            SEC
.1a241c	a5 08		lda $0808	            LDA INDEX
.1a241e	e9 01 00	sbc #$0001	            SBC #1
.1a2421	85 08		sta $0808	            STA INDEX
.1a2423	e2 20		sep #$20	            SEP #$20
.1a2425	a5 0a		lda $080a	            LDA INDEX+2
.1a2427	e9 00		sbc #$00	            SBC #0
.1a2429	85 0a		sta $080a	            STA INDEX+2
.1a242b	80 c6		bra $1a23f3	            BRA mvu_loop        ; And try again
.1a242d	28		plp		done        PLP
.1a242e	60		rts		            RTS
.1a242f					DELLINE
.1a242f	08		php		            PHP
.1a2430	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; SCRATCH := INDEX + [INDEX].LINK (address of the following line)
.1a2433	c2 20		rep #$20	            REP #$20
.1a2435	18		clc		            CLC
.1a2436	a5 08		lda $0808	            LDA INDEX
.1a2438	77 08		adc [$0808],y	            ADC [INDEX],Y
.1a243a	85 0c		sta $080c	            STA SCRATCH
.1a243c	e2 20		sep #$20	            SEP #$20
.1a243e	a5 0a		lda $080a	            LDA INDEX+2
.1a2440	69 00		adc #$00	            ADC #0
.1a2442	85 0e		sta $080e	            STA SCRATCH+2
.1a2444	c2 20		rep #$20	            REP #$20
.1a2446	18		clc		            CLC
.1a2447	a5 d9		lda $08d9	            LDA LASTLINE
.1a2449	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a244c	85 00		sta $0800	            STA BIP
.1a244e	e2 20		sep #$20	            SEP #$20
.1a2450	a5 db		lda $08db	            LDA LASTLINE+2
.1a2452	69 00		adc #$00	            ADC #0
.1a2454	85 02		sta $0802	            STA BIP+2
.1a2456	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; LASTLINE := LASTLINE - [INDEX].LINK
.1a2459	c2 20		rep #$20	            REP #$20
.1a245b	38		sec		            SEC
.1a245c	a5 d9		lda $08d9	            LDA LASTLINE
.1a245e	f7 08		sbc [$0808],y	            SBC [INDEX],Y
.1a2460	85 d9		sta $08d9	            STA LASTLINE
.1a2462	e2 20		sep #$20	            SEP #$20
.1a2464	a5 db		lda $08db	            LDA LASTLINE+2
.1a2466	e9 00		sbc #$00	            SBC #0
.1a2468	85 db		sta $08db	            STA LASTLINE+2
.1a246a	20 b3 23	jsr $1a23b3	            JSR MVPROGDN
.1a246d					done
.1a246d	20 c2 43	jsr $1a43c2	            JSR S_CLR
.1a2470	28		plp		            PLP
.1a2471	60		rts		            RTS
.1a2472					APPLINE
.1a2472	08		php		            PHP
.1a2473	08		php		            PHP
.1a2474	c2 20		rep #$20	            REP #$20
.1a2476	48		pha		            PHA
.1a2477	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a247a	5b		tcd		            TCD
.1a247b	68		pla		            PLA
.1a247c	28		plp		            PLP
.1a247d	c2 30		rep #$30	            REP #$30
.1a247f	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the line number of the new line
.1a2482	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.1a2484	18		clc		            CLC                 ; Point INDEX to the position to store the tokens
.1a2485	a5 d9		lda $08d9	            LDA LASTLINE
.1a2487	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a248a	85 08		sta $0808	            STA INDEX
.1a248c	e2 20		sep #$20	            SEP #$20
.1a248e	a5 db		lda $08db	            LDA LASTLINE+2
.1a2490	69 00		adc #$00	            ADC #0
.1a2492	85 0a		sta $080a	            STA INDEX+2
.1a2494	e2 20		sep #$20	            SEP #$20
.1a2496	a0 00 00	ldy #$0000	            LDY #0
.1a2499	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Copy the tokenized line to its place in the code
.1a249b	97 08		sta [$0808],y	            STA [INDEX],Y
.1a249d	f0 03		beq $1a24a2	            BEQ copy_done
.1a249f	c8		iny		            INY
.1a24a0	80 f7		bra $1a2499	            BRA copy_loop
.1a24a2					copy_done
.1a24a2	c2 20		rep #$20	            REP #$20
.1a24a4	98		tya		            TYA
.1a24a5	18		clc		            CLC
.1a24a6	69 05 00	adc #$0005	            ADC #LINE_TOKENS+1
.1a24a9	85 0c		sta $080c	            STA SCRATCH
.1a24ab	c2 20		rep #$20	            REP #$20
.1a24ad	a0 00 00	ldy #$0000	            LDY #LINE_LINK      ; Set link to the offset to the next line
.1a24b0	a5 0c		lda $080c	            LDA SCRATCH
.1a24b2	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.1a24b4	c2 20		rep #$20	            REP #$20
.1a24b6	18		clc		            CLC
.1a24b7	a5 d9		lda $08d9	            LDA LASTLINE
.1a24b9	65 0c		adc $080c	            ADC SCRATCH
.1a24bb	85 0c		sta $080c	            STA SCRATCH
.1a24bd	e2 20		sep #$20	            SEP #$20
.1a24bf	a5 db		lda $08db	            LDA LASTLINE+2
.1a24c1	69 00		adc #$00	            ADC #0
.1a24c3	85 db		sta $08db	            STA LASTLINE+2
.1a24c5	c2 20		rep #$20	            REP #$20
.1a24c7	a5 0c		lda $080c	            LDA SCRATCH
.1a24c9	85 d9		sta $08d9	            STA LASTLINE
.1a24cb	c2 20		rep #$20	            REP #$20
.1a24cd	a0 00 00	ldy #$0000	            LDY #0
.1a24d0	a9 00 00	lda #$0000	            LDA #0
.1a24d3	97 d9		sta [$08d9],y	blank_loop  STA [LASTLINE],Y    ; Set the "line" after the last line to nulls
.1a24d5	c8		iny		            INY
.1a24d6	c0 05 00	cpy #$0005	            CPY #LINE_TOKENS+1
.1a24d9	d0 f8		bne $1a24d3	            BNE blank_loop
.1a24db	20 c2 43	jsr $1a43c2	            JSR S_CLR
.1a24de	28		plp		            PLP
.1a24df	60		rts		            RTS
.1a24e0					FINDINSPT
.1a24e0	0b		phd		            PHD
.1a24e1	08		php		            PHP
.1a24e2	08		php		            PHP
.1a24e3	c2 20		rep #$20	            REP #$20
.1a24e5	48		pha		            PHA
.1a24e6	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a24e9	5b		tcd		            TCD
.1a24ea	68		pla		            PLA
.1a24eb	28		plp		            PLP
.1a24ec	c2 30		rep #$30	            REP #$30
.1a24ee	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.1a24f1	85 08		sta $0808	            STA INDEX
.1a24f3	a9 16 00	lda #$0016	            LDA #`BASIC_BOT
.1a24f6	85 0a		sta $080a	            STA INDEX+2
.1a24f8	a0 02 00	ldy #$0002	loop        LDY #LINE_NUMBER
.1a24fb	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a24fd	f0 1d		beq $1a251c	            BEQ found_end           ; Got to end without finding it
.1a24ff	c5 d7		cmp $08d7	            CMP LINENUM
.1a2501	f0 25		beq $1a2528	            BEQ found_line          ; LINENUM = [INDEX].LINE_NUMBER: return we found the exact line
.1a2503	b0 1d		bcs $1a2522	            BGE found_spot          ; LINENUM > [INDEX].LINE_NUMBER: return we found spot to insert
.1a2505	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a2508	18		clc		            CLC                     ; Move INDEX to the next line
.1a2509	a5 08		lda $0808	            LDA INDEX
.1a250b	77 08		adc [$0808],y	            ADC [INDEX],Y
.1a250d	85 0c		sta $080c	            STA SCRATCH
.1a250f	a5 0a		lda $080a	            LDA INDEX+2
.1a2511	69 00 00	adc #$0000	            ADC #0
.1a2514	85 0a		sta $080a	            STA INDEX+2
.1a2516	a5 0c		lda $080c	            LDA SCRATCH
.1a2518	85 08		sta $0808	            STA INDEX
.1a251a	80 dc		bra $1a24f8	            BRA loop                ; And check that line
.1a251c	a9 00 00	lda #$0000	found_end   LDA #0                  ; Return that we reached the end of the program
.1a251f	28		plp		            PLP
.1a2520	2b		pld		            PLD
.1a2521	60		rts		            RTS
.1a2522	a9 01 00	lda #$0001	found_spot  LDA #1                  ; Return that we the found the spot to insert the line
.1a2525	28		plp		            PLP                     ; But that it wasn't already there
.1a2526	2b		pld		            PLD
.1a2527	60		rts		            RTS
.1a2528	a9 02 00	lda #$0002	found_line  LDA #2                  ; Return that we found the line
.1a252b	28		plp		            PLP
.1a252c	2b		pld		            PLD
.1a252d	60		rts		            RTS
.1a252e					INSLINE
.1a252e	08		php		            PHP
.1a252f	c2 30		rep #$30	            REP #$30
.1a2531	a9 05 00	lda #$0005	            LDA #LINE_TOKENS+1  ; Set SCRATCH2 to the size of the line header with the end-of-line
.1a2534	85 10		sta $0810	            STA SCRATCH2
.1a2536	a0 00 00	ldy #$0000	            LDY #0
.1a2539					count_loop
.1a2539	e2 20		sep #$20	            SEP #$20
.1a253b	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the byte of the line
.1a253d	f0 07		beq $1a2546	            BEQ shift_prog      ; If it's end-of-line, SCRATCH2 is the length
.1a253f	c2 20		rep #$20	            REP #$20
.1a2541	e6 10		inc $0810	            INC SCRATCH2
.1a2543	c8		iny		            INY
.1a2544	80 f3		bra $1a2539	            BRA count_loop      ; Count and continue
.1a2546					shift_prog
.1a2546	c2 20		rep #$20	            REP #$20
.1a2548	a5 08		lda $0808	            LDA INDEX           ; BIP = the address of the first byte for the new line
.1a254a	85 00		sta $0800	            STA BIP
.1a254c	a5 0a		lda $080a	            LDA INDEX+2
.1a254e	85 02		sta $0802	            STA BIP+2
.1a2550	18		clc		            CLC                 ; SCRATCH = address of highest byte to copy
.1a2551	a5 d9		lda $08d9	            LDA LASTLINE
.1a2553	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a2556	85 0c		sta $080c	            STA SCRATCH
.1a2558	a5 db		lda $08db	            LDA LASTLINE+2
.1a255a	69 00 00	adc #$0000	            ADC #0
.1a255d	85 0e		sta $080e	            STA SCRATCH+2
.1a255f	18		clc		            CLC                 ; Adjust LASTLINE to its new position after the insert
.1a2560	a5 d9		lda $08d9	            LDA LASTLINE
.1a2562	65 10		adc $0810	            ADC SCRATCH2
.1a2564	85 d9		sta $08d9	            STA LASTLINE
.1a2566	a5 db		lda $08db	            LDA LASTLINE+2
.1a2568	69 00 00	adc #$0000	            ADC #0
.1a256b	85 db		sta $08db	            STA LASTLINE+2
.1a256d	18		clc		            CLC                 ; INDEX = address of the highest location to copy into
.1a256e	a5 d9		lda $08d9	            LDA LASTLINE
.1a2570	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a2573	85 08		sta $0808	            STA INDEX
.1a2575	a5 db		lda $08db	            LDA LASTLINE+2
.1a2577	69 00 00	adc #$0000	            ADC #0
.1a257a	85 0a		sta $080a	            STA INDEX+2
.1a257c	20 f2 23	jsr $1a23f2	            JSR MVPROGUP
.1a257f	c2 20		rep #$20	            REP #$20
.1a2581	a5 10		lda $0810	            LDA SCRATCH2
.1a2583	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a2586	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINK_LINK = length of the new line
.1a2588	a5 d7		lda $08d7	            LDA LINENUM
.1a258a	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.1a258d	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINE_NUMBER = number of the new line
.1a258f	18		clc		            CLC                 ; Point BIP to the first byte of the new line
.1a2590	a5 00		lda $0800	            LDA BIP
.1a2592	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a2595	85 00		sta $0800	            STA BIP
.1a2597	a5 02		lda $0802	            LDA BIP+2
.1a2599	69 00 00	adc #$0000	            ADC #0
.1a259c	85 02		sta $0802	            STA BIP+2
.1a259e	a0 00 00	ldy #$0000	            LDY #0
.1a25a1	e2 20		sep #$20	            SEP #$20
.1a25a3	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Get the byte of the tokenized line
.1a25a5	97 00		sta [$0800],y	            STA [BIP],Y         ; Copy it to its correct location in the program
.1a25a7	f0 03		beq $1a25ac	            BEQ done            ; If it was end-of-line byte, we're done
.1a25a9	c8		iny		            INY
.1a25aa	80 f7		bra $1a25a3	            BRA copy_loop       ; Otherwise, continue with the next
.1a25ac					done
.1a25ac	20 c2 43	jsr $1a43c2	            JSR S_CLR
.1a25af	28		plp		            PLP
.1a25b0	60		rts		            RTS
.1a25b1					ADDLINE
.1a25b1	08		php		            PHP
.1a25b2	c2 30		rep #$30	            REP #$30
.1a25b4	85 d7		sta $08d7	            STA LINENUM
.1a25b6	20 e0 24	jsr $1a24e0	            JSR FINDINSPT
.1a25b9	c9 00 00	cmp #$0000	            CMP #0
.1a25bc	f0 2c		beq $1a25ea	            BEQ do_append       ; End-of-program found, add the line to the end
.1a25be	c9 01 00	cmp #$0001	            CMP #1
.1a25c1	f0 22		beq $1a25e5	            BEQ do_insert       ; Spot was found: insertion required
.1a25c3	c2 20		rep #$20	            REP #$20
.1a25c5	a5 08		lda $0808	            LDA INDEX
.1a25c7	48		pha		            PHA
.1a25c8	a5 0a		lda $080a	            LDA INDEX+2
.1a25ca	48		pha		            PHA
.1a25cb	20 2f 24	jsr $1a242f	            JSR DELLINE
.1a25ce	68		pla		            PLA
.1a25cf	85 0a		sta $080a	            STA INDEX+2
.1a25d1	68		pla		            PLA
.1a25d2	85 08		sta $0808	            STA INDEX
.1a25d4	a5 1a		lda $081a	            LDA CURLINE         ; Check to see if there is any non-whitespace on the line
.1a25d6	85 00		sta $0800	            STA BIP
.1a25d8	a5 1c		lda $081c	            LDA CURLINE+2
.1a25da	85 02		sta $0802	            STA BIP+2
.1a25dc	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a25df	e2 20		sep #$20	            SEP #$20
.1a25e1	a7 00		lda [$0800]	            LDA [BIP]
.1a25e3	f0 0a		beq $1a25ef	            BEQ done            ; If not, we're done
.1a25e5					do_insert
.1a25e5	20 2e 25	jsr $1a252e	            JSR INSLINE
.1a25e8	80 05		bra $1a25ef	            BRA done
.1a25ea	a5 d7		lda $08d7	do_append   LDA LINENUM
.1a25ec	20 72 24	jsr $1a2472	            JSR APPLINE
.1a25ef	28		plp		done        PLP
.1a25f0	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\repl.s

="#"					CHAR_DIR = '#'
="|"					CHAR_BRUN = '|'
.1a25f1					EXPANDLINE
.1a25f1	0b		phd		                PHD
.1a25f2	08		php		                PHP
.1a25f3	08		php		            PHP
.1a25f4	c2 20		rep #$20	            REP #$20
.1a25f6	48		pha		            PHA
.1a25f7	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a25fa	5b		tcd		            TCD
.1a25fb	68		pla		            PLA
.1a25fc	28		plp		            PLP
.1a25fd	e2 20		sep #$20	            SEP #$20
.1a25ff	c2 10		rep #$10	            REP #$10
.1a2601	a2 00 00	ldx #$0000	                LDX #0
.1a2604	bd 00 4f	lda $4f00,x	count_loop      LDA INPUTBUF,X              ; Count the number of characters in the input
.1a2607	f0 03		beq $1a260c	                BEQ save_size
.1a2609	e8		inx		                INX
.1a260a	80 f8		bra $1a2604	                BRA count_loop
.1a260c	86 0c		stx $080c	save_size       STX SCRATCH                 ; Save the size in SCRATCH
.1a260e	c2 30		rep #$30	            REP #$30
.1a2610	8a		txa		                TXA
.1a2611	c9 02 00	cmp #$0002	                CMP #2                      ; Are there arguments?
.1a2614	90 12		bcc $1a2628	                BLT start_copy              ; No: just replace the whole string
.1a2616	3a		dec a		                DEC A
.1a2617	18		clc		                CLC
.1a2618	69 00 4f	adc #$4f00	                ADC #<>INPUTBUF
.1a261b	aa		tax		                TAX                         ; X <-- INPUTBUF + len(INPUTBUF) - 1
.1a261c	18		clc		                CLC                         ; Y <-- INPUTBUF + len(INPUTBUF) - 1 + len(substitution)
.1a261d	65 8f		adc $088f	                ADC MCOUNT
.1a261f	a8		tay		                TAY
.1a2620	a5 0c		lda $080c	                LDA SCRATCH
.1a2622	3a		dec a		                DEC A
.1a2623	8b		phb		                PHB
.1a2624	44 00 00	mvp #$00,#$00	                MVP #`INPUTBUF,#`INPUTBUF   ; Make room for the substitition
.1a2627	ab		plb		                PLB
.1a2628					start_copy
.1a2628	c2 20		rep #$20	            REP #$20
.1a262a	a6 55		ldx $0855	                LDX MARG1                   ; Source is data to copy
.1a262c	a0 00 4f	ldy #$4f00	                LDY #<>INPUTBUF             ; Destination is input buffer
.1a262f	a5 8f		lda $088f	                LDA MCOUNT                  ; Number of bytes to copy
.1a2631	8b		phb		                PHB
.1a2632	54 00 1a	mvn #$1a,#$00	                MVN #`EXPANDLINE,#`INPUTBUF ; Copy the data
.1a2635	ab		plb		                PLB
.1a2636	e2 20		sep #$20	            SEP #$20
.1a2638	a5 0c		lda $080c	                LDA SCRATCH                 ; Check again to see if we need quotes
.1a263a	c9 02		cmp #$02	                CMP #2
.1a263c	90 18		bcc $1a2656	                BLT done
.1a263e	a6 8f		ldx $088f	                LDX MCOUNT                  ; If so, add a quote mark here
.1a2640	a9 22		lda #$22	                LDA #CHAR_DQUOTE
.1a2642	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a2645	e8		inx		skip_to_end     INX                         ; Move to the end of the input string
.1a2646	bd 00 4f	lda $4f00,x	                LDA INPUTBUF,X
.1a2649	d0 fa		bne $1a2645	                BNE skip_to_end
.1a264b	a9 22		lda #$22	                LDA #CHAR_DQUOTE            ; Add the quote to the end of the string
.1a264d	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a2650	a9 00		lda #$00	                LDA #0                      ; And terminate with a NULL
.1a2652	e8		inx		                INX
.1a2653	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a2656	28		plp		done            PLP
.1a2657	2b		pld		                PLD
.1a2658	60		rts		            RTS
.1a2659					PREPROCESS
.1a2659	da		phx		                PHX
.1a265a	5a		phy		                PHY
.1a265b	8b		phb		                PHB
.1a265c	0b		phd		                PHD
.1a265d	08		php		                PHP
.1a265e	08		php		            PHP
.1a265f	c2 20		rep #$20	            REP #$20
.1a2661	48		pha		            PHA
.1a2662	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a2665	5b		tcd		            TCD
.1a2666	68		pla		            PLA
.1a2667	28		plp		            PLP
.1a2668	e2 20		sep #$20	            SEP #$20
.1a266a	c2 10		rep #$10	            REP #$10
.1a266c	ad 00 4f	lda $4f00	                LDA INPUTBUF            ; Check the first character
.1a266f	c9 23		cmp #$23	                CMP #CHAR_DIR           ; Is it the DIR character?
.1a2671	f0 0a		beq $1a267d	                BEQ expand_dir          ; Yes: expand the DIR command into place
.1a2673	c9 7c		cmp #$7c	                CMP #CHAR_BRUN          ; Is it the BRUN character?
.1a2675	f0 17		beq $1a268e	                BEQ expand_brun         ; Yes: expand the BRUN command into place
.1a2677	28		plp		done            PLP
.1a2678	2b		pld		                PLD
.1a2679	ab		plb		                PLB
.1a267a	7a		ply		                PLY
.1a267b	fa		plx		                PLX
.1a267c	60		rts		            RTS
.1a267d					expand_dir
.1a267d	c2 20		rep #$20	            REP #$20
.1a267f	a9 03 00	lda #$0003	                LDA #3                  ; Set size of substitution value
.1a2682	85 8f		sta $088f	                STA MCOUNT
.1a2684	a9 9f 26	lda #$269f	                LDA #<>dir_text         ; Set pointer to substitution value
.1a2687	85 55		sta $0855	                STA MARG1
.1a2689	20 f1 25	jsr $1a25f1	            JSR EXPANDLINE
.1a268c	80 e9		bra $1a2677	                BRA done
.1a268e					expand_brun
.1a268e	c2 20		rep #$20	            REP #$20
.1a2690	a9 04 00	lda #$0004	                LDA #4                  ; Set size of substitution value
.1a2693	85 8f		sta $088f	                STA MCOUNT
.1a2695	a9 a3 26	lda #$26a3	                LDA #<>brun_text        ; Set pointer to substitution value
.1a2698	85 55		sta $0855	                STA MARG1
.1a269a	20 f1 25	jsr $1a25f1	            JSR EXPANDLINE
.1a269d	80 d8		bra $1a2677	                BRA done
>1a269f	44 49 52 00			dir_text        .null "DIR"             ; Expansion of the DIR character
>1a26a3	42 52 55 4e 00			brun_text       .null "BRUN"            ; Expansion of the BRUN character
.1a26a8					PRREADY
.1a26a8	8b		phb		                PHB
.1a26a9	08		php		                PHP
.1a26aa	20 cc 01	jsr $1a01cc	            JSR ENSURETEXT
.1a26ad	08		php		            PHP
.1a26ae	e2 20		sep #$20	            SEP #$20
.1a26b0	48		pha		            PHA
.1a26b1	a9 1a		lda #$1a	            LDA #`MPROMPT
.1a26b3	48		pha		            PHA
.1a26b4	ab		plb		            PLB
.1a26b5	68		pla		            PLA
.1a26b6	28		plp		            PLP
.1a26b7	a2 69 d2	ldx #$d269	                LDX #<>MPROMPT
.1a26ba	20 b3 03	jsr $1a03b3	            JSR PRINTS
.1a26bd	28		plp		                PLP
.1a26be	ab		plb		                PLB
.1a26bf	60		rts		            RTS
.1a26c0					IREADLINE
.1a26c0	08		php		                PHP
.1a26c1	e2 30		sep #$30	            SEP #$30
.1a26c3	a9 01		lda #$01	                LDA #1
.1a26c5	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a26c8					read_loop
.1a26c8	20 db 00	jsr $1a00db	            JSR GETKEYE
.1a26cb	c9 00		cmp #$00	                CMP #0
.1a26cd	f0 f9		beq $1a26c8	                BEQ read_loop
.1a26cf	c9 0d		cmp #$0d	                CMP #CHAR_CR
.1a26d1	f0 02		beq $1a26d5	                BEQ done
.1a26d3	80 f3		bra $1a26c8	                BRA read_loop
.1a26d5	28		plp		done            PLP
.1a26d6	60		rts		            RTS
.1a26d7					PROCESS
.1a26d7	0b		phd		                PHD
.1a26d8	08		php		                PHP
.1a26d9	08		php		            PHP
.1a26da	c2 20		rep #$20	            REP #$20
.1a26dc	48		pha		            PHA
.1a26dd	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a26e0	5b		tcd		            TCD
.1a26e1	68		pla		            PLA
.1a26e2	28		plp		            PLP
.1a26e3	c2 30		rep #$30	            REP #$30
.1a26e5	64 d7		stz $08d7	                STZ LINENUM
.1a26e7	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF         ; Attempt to tokenize the line that was read
.1a26ea	85 1a		sta $081a	                STA CURLINE
.1a26ec	a9 00 00	lda #$0000	                LDA #`CURLINE
.1a26ef	85 1c		sta $081c	                STA CURLINE+2
.1a26f1	20 eb 08	jsr $1a08eb	            JSR TOKENIZE
.1a26f4	c2 20		rep #$20	            REP #$20
.1a26f6	a5 d7		lda $08d7	                LDA LINENUM             ; Did we get a line number?
.1a26f8	d0 05		bne $1a26ff	                BNE update_line         ; Yes: attempt to add it to the program
.1a26fa	20 98 22	jsr $1a2298	            JSR EXECCMD
.1a26fd	80 07		bra $1a2706	                BRA done
.1a26ff					update_line
.1a26ff	20 b1 25	jsr $1a25b1	            JSR ADDLINE
.1a2702	28		plp		no_prompt       PLP
.1a2703	2b		pld		                PLD
.1a2704	38		sec		                SEC
.1a2705	60		rts		            RTS
.1a2706	28		plp		done            PLP
.1a2707	2b		pld		                PLD
.1a2708	18		clc		                CLC
.1a2709	60		rts		            RTS
.1a270a					INTERACT
.1a270a	c2 30		rep #$30	            REP #$30
.1a270c	a2 ff fe	ldx #$feff	                LDX #<>STACK_END
.1a270f	9a		txs		                TXS
.1a2710					ready_loop
.1a2710	20 a8 26	jsr $1a26a8	            JSR PRREADY
.1a2713					no_ready_loop
.1a2713	20 08 00	jsr $1a0008	            JSR READLINE
.1a2716	20 0c 00	jsr $1a000c	            JSR SCRCOPYLINE
.1a2719	22 3c 11 00	jsl $00113c	                JSL FK_TESTBREAK    ; Make sure the BREAK bit is cleared.
.1a271d	a9 00 00	lda #$0000	                LDA #0              ; Hide the cursor
.1a2720	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a2723	20 59 26	jsr $1a2659	            JSR PREPROCESS
.1a2726	20 d7 26	jsr $1a26d7	            JSR PROCESS
.1a2729	b0 e8		bcs $1a2713	                BCS no_ready_loop
.1a272b	80 e3		bra $1a2710	                BRA ready_loop
>1ad269	0d 52 45 41 44 59 0d 00		MPROMPT         .null 13,"READY",13

;******  Return to file: src\basic816.s


;******  Processing file: src\operators.s

.1a272d					OP_PLUS
.1a272d	08		php		            PHP
.1a272e	e2 20		sep #$20	            SEP #$20
.1a2730	20 f2 07	jsr $1a07f2	            JSR ASS_ARGS_NUMSTR
.1a2733	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a2735	f0 2c		beq $1a2763	            BEQ is_integer
.1a2737	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2739	f0 2d		beq $1a2768	            BEQ is_float
.1a273b	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a273d	f0 1f		beq $1a275e	            BEQ is_string
.1a273f					type_error
.1a273f	08		php		            PHP
.1a2740	c2 20		rep #$20	            REP #$20
.1a2742	48		pha		            PHA
.1a2743	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2746	5b		tcd		            TCD
.1a2747	68		pla		            PLA
.1a2748	28		plp		            PLP
.1a2749	e2 20		sep #$20	            SEP #$20
.1a274b	a9 04		lda #$04	            LDA #ERR_TYPE
.1a274d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2751	c2 20		rep #$20	            REP #$20
.1a2753	29 ff 00	and #$00ff	            AND #$00FF
.1a2756	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a2759	e2 20		sep #$20	            SEP #$20
.1a275b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a275e					is_string
.1a275e	20 9b 15	jsr $1a159b	            JSR STRCONCAT
.1a2761	80 08		bra $1a276b	            BRA done
.1a2763					is_integer
.1a2763	20 14 53	jsr $1a5314	            JSR OP_INT_ADD
.1a2766	80 03		bra $1a276b	            BRA done
.1a2768					is_float
.1a2768	20 83 55	jsr $1a5583	            JSR OP_FP_ADD
.1a276b	28		plp		done        PLP
.1a276c	60		rts		            RTS
.1a276d					OP_MINUS
.1a276d	08		php		            PHP
.1a276e	e2 20		sep #$20	            SEP #$20
.1a2770	20 a4 07	jsr $1a07a4	            JSR ASS_ARGS_NUM
.1a2773	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a2775	f0 23		beq $1a279a	            BEQ is_integer
.1a2777	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2779	f0 24		beq $1a279f	            BEQ is_float
.1a277b					type_error
.1a277b	08		php		            PHP
.1a277c	c2 20		rep #$20	            REP #$20
.1a277e	48		pha		            PHA
.1a277f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2782	5b		tcd		            TCD
.1a2783	68		pla		            PLA
.1a2784	28		plp		            PLP
.1a2785	e2 20		sep #$20	            SEP #$20
.1a2787	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2789	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a278d	c2 20		rep #$20	            REP #$20
.1a278f	29 ff 00	and #$00ff	            AND #$00FF
.1a2792	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a2795	e2 20		sep #$20	            SEP #$20
.1a2797	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a279a					is_integer
.1a279a	20 26 53	jsr $1a5326	            JSR OP_INT_SUB
.1a279d	80 03		bra $1a27a2	            BRA done
.1a279f					is_float
.1a279f	20 78 55	jsr $1a5578	            JSR OP_FP_SUB
.1a27a2	28		plp		done        PLP
.1a27a3	60		rts		            RTS
.1a27a4					OP_MULTIPLY
.1a27a4	08		php		            PHP
.1a27a5	e2 20		sep #$20	            SEP #$20
.1a27a7	20 a4 07	jsr $1a07a4	            JSR ASS_ARGS_NUM
.1a27aa	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a27ac	f0 23		beq $1a27d1	            BEQ is_integer
.1a27ae	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a27b0	f0 24		beq $1a27d6	            BEQ is_float
.1a27b2					type_error
.1a27b2	08		php		            PHP
.1a27b3	c2 20		rep #$20	            REP #$20
.1a27b5	48		pha		            PHA
.1a27b6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a27b9	5b		tcd		            TCD
.1a27ba	68		pla		            PLA
.1a27bb	28		plp		            PLP
.1a27bc	e2 20		sep #$20	            SEP #$20
.1a27be	a9 04		lda #$04	            LDA #ERR_TYPE
.1a27c0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a27c4	c2 20		rep #$20	            REP #$20
.1a27c6	29 ff 00	and #$00ff	            AND #$00FF
.1a27c9	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a27cc	e2 20		sep #$20	            SEP #$20
.1a27ce	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a27d1					is_integer
.1a27d1	20 38 53	jsr $1a5338	            JSR OP_INT_MUL
.1a27d4	80 03		bra $1a27d9	            BRA done
.1a27d6					is_float
.1a27d6	20 19 56	jsr $1a5619	            JSR OP_FP_MUL
.1a27d9	28		plp		done        PLP
.1a27da	60		rts		            RTS
.1a27db					OP_DIVIDE
.1a27db	20 0e 07	jsr $1a070e	            JSR ASS_ARG1_FLOAT
.1a27de	20 3f 07	jsr $1a073f	            JSR ASS_ARG2_FLOAT
.1a27e1	20 ce 55	jsr $1a55ce	            JSR OP_FP_DIV
.1a27e4	60		rts		            RTS
.1a27e5					OP_MOD
.1a27e5	a5 23		lda $0823	            LDA ARGUMENT1
.1a27e7	8f 1a 01 00	sta $00011a	            STA @lD1_OPERAND_B
.1a27eb	a5 29		lda $0829	            LDA ARGUMENT2
.1a27ed	8f 18 01 00	sta $000118	            STA @lD1_OPERAND_A
.1a27f1	af 1e 01 00	lda $00011e	            LDA @lD1_REMAINDER
.1a27f5	85 23		sta $0823	            STA ARGUMENT1
.1a27f7	60		rts		            RTS
.1a27f8					OP_POW
.1a27f8	08		php		            PHP
.1a27f9	c2 30		rep #$30	            REP #$30
.1a27fb	48		pha		            PHA
.1a27fc	20 0e 07	jsr $1a070e	            JSR ASS_ARG1_FLOAT
.1a27ff	a5 2d		lda $082d	            LDA ARGTYPE2
.1a2801	c9 00 00	cmp #$0000	            CMP #TYPE_INTEGER
.1a2804	d0 0d		bne $1a2813	            BNE flt_exp
.1a2806	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a2808	d0 09		bne $1a2813	            BNE flt_exp
.1a280a	da		phx		            PHX
.1a280b	a6 29		ldx $0829	            LDX ARGUMENT2
.1a280d	20 ec 62	jsr $1a62ec	            JSR Q_FP_POW_INT
.1a2810	fa		plx		            PLX
.1a2811	80 1c		bra $1a282f	            BRA done
.1a2813					flt_exp
.1a2813	20 3f 07	jsr $1a073f	            JSR ASS_ARG2_FLOAT
.1a2816	c2 20		rep #$20	            REP #$20
.1a2818	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a281a	48		pha		            PHA
.1a281b	a5 29		lda $0829	            LDA ARGUMENT2
.1a281d	48		pha		            PHA
.1a281e	20 77 61	jsr $1a6177	            JSR FP_LN
.1a2821	c2 20		rep #$20	            REP #$20
.1a2823	68		pla		            PLA
.1a2824	85 29		sta $0829	            STA ARGUMENT2
.1a2826	68		pla		            PLA
.1a2827	85 2b		sta $082b	            STA ARGUMENT2+2
.1a2829	20 19 56	jsr $1a5619	            JSR OP_FP_MUL
.1a282c	20 56 63	jsr $1a6356	            JSR FP_EXP
.1a282f	68		pla		done        PLA
.1a2830	28		plp		            PLP
.1a2831	60		rts		            RTS
.1a2832					OP_AND
.1a2832	08		php		            PHP
.1a2833	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a2836	20 d1 05	jsr $1a05d1	            JSR ASS_ARG2_INT
.1a2839	c2 20		rep #$20	            REP #$20
.1a283b	a5 23		lda $0823	            LDA ARGUMENT1
.1a283d	25 29		and $0829	            AND ARGUMENT2
.1a283f	85 23		sta $0823	            STA ARGUMENT1
.1a2841	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a2843	25 2b		and $082b	            AND ARGUMENT2+2
.1a2845	85 25		sta $0825	            STA ARGUMENT1+2
.1a2847	28		plp		            PLP
.1a2848	60		rts		            RTS
.1a2849					OP_OR
.1a2849	08		php		            PHP
.1a284a	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a284d	20 d1 05	jsr $1a05d1	            JSR ASS_ARG2_INT
.1a2850	c2 20		rep #$20	            REP #$20
.1a2852	a5 23		lda $0823	            LDA ARGUMENT1
.1a2854	05 29		ora $0829	            ORA ARGUMENT2
.1a2856	85 23		sta $0823	            STA ARGUMENT1
.1a2858	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a285a	05 2b		ora $082b	            ORA ARGUMENT2+2
.1a285c	85 25		sta $0825	            STA ARGUMENT1+2
.1a285e	28		plp		done        PLP
.1a285f	60		rts		            RTS
.1a2860					OP_NOT
.1a2860	08		php		            PHP
.1a2861	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a2864	c2 20		rep #$20	            REP #$20
.1a2866	a5 23		lda $0823	            LDA ARGUMENT1
.1a2868	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a286b	85 23		sta $0823	            STA ARGUMENT1
.1a286d	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a286f	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a2872	85 25		sta $0825	            STA ARGUMENT1+2
.1a2874	28		plp		done        PLP
.1a2875	60		rts		            RTS
.1a2876					OP_LT
.1a2876	08		php		            PHP
.1a2877	e2 20		sep #$20	            SEP #$20
.1a2879	20 f2 07	jsr $1a07f2	            JSR ASS_ARGS_NUMSTR
.1a287c	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a287e	f0 2c		beq $1a28ac	            BEQ is_integer
.1a2880	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2882	f0 2d		beq $1a28b1	            BEQ is_float
.1a2884	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a2886	f0 1f		beq $1a28a7	            BEQ is_string
.1a2888					type_error
.1a2888	08		php		            PHP
.1a2889	c2 20		rep #$20	            REP #$20
.1a288b	48		pha		            PHA
.1a288c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a288f	5b		tcd		            TCD
.1a2890	68		pla		            PLA
.1a2891	28		plp		            PLP
.1a2892	e2 20		sep #$20	            SEP #$20
.1a2894	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2896	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a289a	c2 20		rep #$20	            REP #$20
.1a289c	29 ff 00	and #$00ff	            AND #$00FF
.1a289f	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a28a2	e2 20		sep #$20	            SEP #$20
.1a28a4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a28a7					is_string
.1a28a7	20 23 17	jsr $1a1723	            JSR OP_STR_LT
.1a28aa	80 08		bra $1a28b4	            BRA done
.1a28ac					is_integer
.1a28ac	20 39 54	jsr $1a5439	            JSR OP_INT_LT
.1a28af	80 03		bra $1a28b4	            BRA done
.1a28b1					is_float
.1a28b1	20 ae 5b	jsr $1a5bae	            JSR OP_FP_LT
.1a28b4	28		plp		done        PLP
.1a28b5	60		rts		            RTS
.1a28b6					OP_GT
.1a28b6	08		php		            PHP
.1a28b7	e2 20		sep #$20	            SEP #$20
.1a28b9	20 f2 07	jsr $1a07f2	            JSR ASS_ARGS_NUMSTR
.1a28bc	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a28be	f0 2c		beq $1a28ec	            BEQ is_integer
.1a28c0	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a28c2	f0 2d		beq $1a28f1	            BEQ is_float
.1a28c4	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a28c6	f0 1f		beq $1a28e7	            BEQ is_string
.1a28c8					type_error
.1a28c8	08		php		            PHP
.1a28c9	c2 20		rep #$20	            REP #$20
.1a28cb	48		pha		            PHA
.1a28cc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a28cf	5b		tcd		            TCD
.1a28d0	68		pla		            PLA
.1a28d1	28		plp		            PLP
.1a28d2	e2 20		sep #$20	            SEP #$20
.1a28d4	a9 04		lda #$04	            LDA #ERR_TYPE
.1a28d6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a28da	c2 20		rep #$20	            REP #$20
.1a28dc	29 ff 00	and #$00ff	            AND #$00FF
.1a28df	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a28e2	e2 20		sep #$20	            SEP #$20
.1a28e4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a28e7					is_string
.1a28e7	20 3a 17	jsr $1a173a	            JSR OP_STR_GT
.1a28ea	80 08		bra $1a28f4	            BRA done
.1a28ec					is_integer
.1a28ec	20 5a 54	jsr $1a545a	            JSR OP_INT_GT
.1a28ef	80 03		bra $1a28f4	            BRA done
.1a28f1					is_float
.1a28f1	20 c3 5b	jsr $1a5bc3	            JSR OP_FP_GT
.1a28f4	28		plp		done        PLP
.1a28f5	60		rts		            RTS
.1a28f6					OP_EQ
.1a28f6	08		php		            PHP
.1a28f7	e2 20		sep #$20	            SEP #$20
.1a28f9	20 f2 07	jsr $1a07f2	            JSR ASS_ARGS_NUMSTR
.1a28fc	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a28fe	f0 2c		beq $1a292c	            BEQ is_integer
.1a2900	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2902	f0 2d		beq $1a2931	            BEQ is_float
.1a2904	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a2906	f0 1f		beq $1a2927	            BEQ is_string
.1a2908					type_error
.1a2908	08		php		            PHP
.1a2909	c2 20		rep #$20	            REP #$20
.1a290b	48		pha		            PHA
.1a290c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a290f	5b		tcd		            TCD
.1a2910	68		pla		            PLA
.1a2911	28		plp		            PLP
.1a2912	e2 20		sep #$20	            SEP #$20
.1a2914	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2916	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a291a	c2 20		rep #$20	            REP #$20
.1a291c	29 ff 00	and #$00ff	            AND #$00FF
.1a291f	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a2922	e2 20		sep #$20	            SEP #$20
.1a2924	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2927					is_string
.1a2927	20 51 17	jsr $1a1751	            JSR OP_STR_EQ
.1a292a	80 08		bra $1a2934	            BRA done
.1a292c					is_integer
.1a292c	20 87 54	jsr $1a5487	            JSR OP_INT_EQ
.1a292f	80 03		bra $1a2934	            BRA done
.1a2931					is_float
.1a2931	20 d8 5b	jsr $1a5bd8	            JSR OP_FP_EQ
.1a2934	28		plp		done        PLP
.1a2935	60		rts		            RTS
.1a2936					OP_NE
.1a2936	08		php		            PHP
.1a2937	e2 20		sep #$20	            SEP #$20
.1a2939	20 f2 07	jsr $1a07f2	            JSR ASS_ARGS_NUMSTR
.1a293c	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a293e	f0 2c		beq $1a296c	            BEQ is_integer
.1a2940	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2942	f0 2d		beq $1a2971	            BEQ is_float
.1a2944	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a2946	f0 1f		beq $1a2967	            BEQ is_string
.1a2948					type_error
.1a2948	08		php		            PHP
.1a2949	c2 20		rep #$20	            REP #$20
.1a294b	48		pha		            PHA
.1a294c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a294f	5b		tcd		            TCD
.1a2950	68		pla		            PLA
.1a2951	28		plp		            PLP
.1a2952	e2 20		sep #$20	            SEP #$20
.1a2954	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2956	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a295a	c2 20		rep #$20	            REP #$20
.1a295c	29 ff 00	and #$00ff	            AND #$00FF
.1a295f	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a2962	e2 20		sep #$20	            SEP #$20
.1a2964	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2967					is_string
.1a2967	20 68 17	jsr $1a1768	            JSR OP_STR_NE
.1a296a	80 08		bra $1a2974	            BRA done
.1a296c					is_integer
.1a296c	20 a5 54	jsr $1a54a5	            JSR OP_INT_NE
.1a296f	80 03		bra $1a2974	            BRA done
.1a2971					is_float
.1a2971	20 17 5c	jsr $1a5c17	            JSR OP_FP_NE
.1a2974	28		plp		done        PLP
.1a2975	60		rts		            RTS
.1a2976					OP_GTE
.1a2976	08		php		            PHP
.1a2977	e2 20		sep #$20	            SEP #$20
.1a2979	20 f2 07	jsr $1a07f2	            JSR ASS_ARGS_NUMSTR
.1a297c	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a297e	f0 2c		beq $1a29ac	            BEQ is_integer
.1a2980	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2982	f0 2d		beq $1a29b1	            BEQ is_float
.1a2984	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a2986	f0 1f		beq $1a29a7	            BEQ is_string
.1a2988					type_error
.1a2988	08		php		            PHP
.1a2989	c2 20		rep #$20	            REP #$20
.1a298b	48		pha		            PHA
.1a298c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a298f	5b		tcd		            TCD
.1a2990	68		pla		            PLA
.1a2991	28		plp		            PLP
.1a2992	e2 20		sep #$20	            SEP #$20
.1a2994	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2996	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a299a	c2 20		rep #$20	            REP #$20
.1a299c	29 ff 00	and #$00ff	            AND #$00FF
.1a299f	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a29a2	e2 20		sep #$20	            SEP #$20
.1a29a4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a29a7					is_string
.1a29a7	20 7f 17	jsr $1a177f	            JSR OP_STR_GTE
.1a29aa	80 08		bra $1a29b4	            BRA done
.1a29ac					is_integer
.1a29ac	20 c3 54	jsr $1a54c3	            JSR OP_INT_GTE
.1a29af	80 03		bra $1a29b4	            BRA done
.1a29b1					is_float
.1a29b1	20 02 5c	jsr $1a5c02	            JSR OP_FP_GTE
.1a29b4	28		plp		done        PLP
.1a29b5	60		rts		            RTS
.1a29b6					OP_LTE
.1a29b6	08		php		            PHP
.1a29b7	e2 20		sep #$20	            SEP #$20
.1a29b9	20 f2 07	jsr $1a07f2	            JSR ASS_ARGS_NUMSTR
.1a29bc	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a29be	f0 2c		beq $1a29ec	            BEQ is_integer
.1a29c0	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a29c2	f0 2d		beq $1a29f1	            BEQ is_float
.1a29c4	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a29c6	f0 1f		beq $1a29e7	            BEQ is_string
.1a29c8					type_error
.1a29c8	08		php		            PHP
.1a29c9	c2 20		rep #$20	            REP #$20
.1a29cb	48		pha		            PHA
.1a29cc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a29cf	5b		tcd		            TCD
.1a29d0	68		pla		            PLA
.1a29d1	28		plp		            PLP
.1a29d2	e2 20		sep #$20	            SEP #$20
.1a29d4	a9 04		lda #$04	            LDA #ERR_TYPE
.1a29d6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a29da	c2 20		rep #$20	            REP #$20
.1a29dc	29 ff 00	and #$00ff	            AND #$00FF
.1a29df	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a29e2	e2 20		sep #$20	            SEP #$20
.1a29e4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a29e7					is_string
.1a29e7	20 96 17	jsr $1a1796	            JSR OP_STR_LTE
.1a29ea	80 08		bra $1a29f4	            BRA done
.1a29ec					is_integer
.1a29ec	20 f0 54	jsr $1a54f0	            JSR OP_INT_LTE
.1a29ef	80 03		bra $1a29f4	            BRA done
.1a29f1					is_float
.1a29f1	20 ed 5b	jsr $1a5bed	            JSR OP_FP_LTE
.1a29f4	28		plp		done        PLP
.1a29f5	60		rts		            RTS
.1a29f6					OP_NEGATIVE
.1a29f6	08		php		                PHP
.1a29f7	e2 20		sep #$20	            SEP #$20
.1a29f9	a5 27		lda $0827	                LDA ARGTYPE1                ; Check the type of the argument
.1a29fb	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a29fd	f0 2d		beq $1a2a2c	                BEQ int_negate              ; If integer: negate the integer
.1a29ff	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.1a2a01	f0 1f		beq $1a2a22	                BEQ float_negate            ; If floating point: negate the floating point
.1a2a03					type_error
.1a2a03	08		php		            PHP
.1a2a04	c2 20		rep #$20	            REP #$20
.1a2a06	48		pha		            PHA
.1a2a07	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2a0a	5b		tcd		            TCD
.1a2a0b	68		pla		            PLA
.1a2a0c	28		plp		            PLP
.1a2a0d	e2 20		sep #$20	            SEP #$20
.1a2a0f	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2a11	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2a15	c2 20		rep #$20	            REP #$20
.1a2a17	29 ff 00	and #$00ff	            AND #$00FF
.1a2a1a	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a2a1d	e2 20		sep #$20	            SEP #$20
.1a2a1f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2a22					float_negate
.1a2a22	e2 20		sep #$20	            SEP #$20
.1a2a24	a5 26		lda $0826	                LDA ARGUMENT1+3             ; Flip the sign bit of the floating point number
.1a2a26	49 80		eor #$80	                EOR #$80
.1a2a28	85 26		sta $0826	                STA ARGUMENT1+3
.1a2a2a	80 16		bra $1a2a42	                BRA done
.1a2a2c					int_negate
.1a2a2c	c2 20		rep #$20	            REP #$20
.1a2a2e	a5 23		lda $0823	                LDA ARGUMENT1               ; Invert ARGUMENT1
.1a2a30	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a2a33	85 23		sta $0823	                STA ARGUMENT1
.1a2a35	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a2a37	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a2a3a	85 25		sta $0825	                STA ARGUMENT1+2
.1a2a3c	e6 23		inc $0823	                INC ARGUMENT1               ; And increment to get two's complement
.1a2a3e	d0 02		bne $1a2a42	                BNE done
.1a2a40	e6 25		inc $0825	                INC ARGUMENT1+2
.1a2a42					done
.1a2a42	28		plp		                PLP
.1a2a43	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\statements.s


;******  Processing file: src\C256/statements_c256.s

=0					GR_LUT_BLUE = 0
=1					GR_LUT_GREEN = 1
=2					GR_LUT_RED = 2
=3					GR_LUT_ALPHA = 3
=640					GR_DEFAULT_COLS = 640               ; Default number of columns in the display
=480					GR_DEFAULT_ROWS = 480               ; Default number of rows in the display
=8					GR_MAX_LUT = 8                      ; The number of LUTs Vicky supports
=64					SP_MAX = 64                         ; The number of sprites Vicky supports
=8					SP_REG_SIZE = 8                     ; The number of bytes in a sprite's register block
=0					SP_CONTROL = 0                      ; Offset of the control regsiter for a sprite
=1					SP_ADDR = 1                         ; Offset of the pixmap address for a sprite
=4					SP_X_COORD = 4                      ; Offset of the X coordinate for a sprite
=6					SP_Y_COORD = 6                      ; Offset of the Y coordinate for a sprite
=12					TILEMAP_REG_SIZE = 12               ; The number of bytes in a tile map's register set
=4					TILESET_REG_SIZE = 4                ; The number of bytes in a tile set's register set
=2					BM_MAX = 2                          ; Maximum number of bitmaps we support
=$0040					MAX_VRAM_VICKY = $0040              ; Upper limit (exclusive) bank address for VRAM in Vicky address space
=$00f0					MAX_VRAM_CPU = $00F0                ; Upper limit (exclusive) bank address for VRAM in CPU address space
=$00b0					MIN_VRAM_CPU = $00B0                ; Lower limit (inclusive) bank address for VRAM in CPU address space
>1af000					GR_BM0_ADDR     .dword ?            ; Address of bitmap 0 (from CPU's perspective)
>1af004					GR_BM1_ADDR     .dword ?            ; Address of bitmap 1 (from CPU's perspective)
>1af008					GR_BM0_VRAM     .dword ?            ; Address of bitmap 0 (relative to start of VRAM)
>1af00c					GR_BM1_VRAM     .dword ?            ; Address of bitmap 1 (relative to start of VRAM)
>1af010					GR_MAX_COLS     .word ?             ; Width the display in pixels
>1af012					GR_MAX_ROWS     .word ?             ; Height of the display in pixels
>1af014					GR_TOTAL_PIXELS .word ?             ; Total number of pixels in the display
>1af016					GR_TEMP         .word ?             ; A temporary word for graphics commands
>1af018					GS_SP_CONTROL   .fill SP_MAX        ; Shadow registers for the sprite controls
.1a2a44					S_SETTIME
.1a2a44	08		php		                PHP
.1a2a45	e2 20		sep #$20	            SEP #$20
.1a2a47	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2a4a	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2a4d	20 fd 04	jsr $1a04fd	            JSR DIVINT10
.1a2a50	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2a52	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2a53	0a		asl a		                ASL A
.1a2a54	0a		asl a		                ASL A
.1a2a55	0a		asl a		                ASL A
.1a2a56	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2a58	48		pha		                PHA
.1a2a59	a9 2c		lda #$2c	                LDA #','
.1a2a5b	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a2a5e	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2a61	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2a64	20 fd 04	jsr $1a04fd	            JSR DIVINT10
.1a2a67	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2a69	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2a6a	0a		asl a		                ASL A
.1a2a6b	0a		asl a		                ASL A
.1a2a6c	0a		asl a		                ASL A
.1a2a6d	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2a6f	48		pha		                PHA
.1a2a70	a9 2c		lda #$2c	                LDA #','
.1a2a72	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a2a75	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2a78	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2a7b	20 fd 04	jsr $1a04fd	            JSR DIVINT10
.1a2a7e	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2a80	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2a81	0a		asl a		                ASL A
.1a2a82	0a		asl a		                ASL A
.1a2a83	0a		asl a		                ASL A
.1a2a84	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2a86	48		pha		                PHA
.1a2a87	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a2a8b	09 0c		ora #$0c	                ORA #%00001100
.1a2a8d	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2a91	68		pla		                PLA                     ; And seconds to the RTC
.1a2a92	8f 00 08 af	sta $af0800	                STA @lRTC_SEC
.1a2a96	68		pla		                PLA                     ; Minutes...
.1a2a97	8f 02 08 af	sta $af0802	                STA @lRTC_MIN
.1a2a9b	68		pla		                PLA                     ; Save the hour...
.1a2a9c	8f 04 08 af	sta $af0804	                STA @lRTC_HRS
.1a2aa0	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a2aa4	29 f7		and #$f7	                AND #%11110111
.1a2aa6	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2aaa	20 ac 20	jsr $1a20ac	            JSR SKIPSTMT
.1a2aad	28		plp		                PLP
.1a2aae	60		rts		            RTS
.1a2aaf					S_SETDATE
.1a2aaf	08		php		                PHP
.1a2ab0	e2 20		sep #$20	            SEP #$20
.1a2ab2	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2ab5	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2ab8	20 fd 04	jsr $1a04fd	            JSR DIVINT10
.1a2abb	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2abd	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2abe	0a		asl a		                ASL A
.1a2abf	0a		asl a		                ASL A
.1a2ac0	0a		asl a		                ASL A
.1a2ac1	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2ac3	48		pha		                PHA
.1a2ac4	a9 2c		lda #$2c	                LDA #','
.1a2ac6	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a2ac9	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2acc	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2acf	20 fd 04	jsr $1a04fd	            JSR DIVINT10
.1a2ad2	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2ad4	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2ad5	0a		asl a		                ASL A
.1a2ad6	0a		asl a		                ASL A
.1a2ad7	0a		asl a		                ASL A
.1a2ad8	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2ada	48		pha		                PHA
.1a2adb	a9 2c		lda #$2c	                LDA #','
.1a2add	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a2ae0	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2ae3	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a2ae6	20 33 05	jsr $1a0533	            JSR DIVINT100
.1a2ae9	c2 20		rep #$20	            REP #$20
.1a2aeb	a5 23		lda $0823	                LDA ARGUMENT1           ; Get the century
.1a2aed	85 92		sta $0892	                STA MTEMP               ; Save it in MTEMP
.1a2aef	a5 29		lda $0829	                LDA ARGUMENT2           ; Separate the 10s from the 1s digits
.1a2af1	85 23		sta $0823	                STA ARGUMENT1
.1a2af3	20 fd 04	jsr $1a04fd	            JSR DIVINT10
.1a2af6	e2 20		sep #$20	            SEP #$20
.1a2af8	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2afa	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2afb	0a		asl a		                ASL A
.1a2afc	0a		asl a		                ASL A
.1a2afd	0a		asl a		                ASL A
.1a2afe	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2b00	48		pha		                PHA                     ; Save the 10s and 1s in BCD
.1a2b01	c2 20		rep #$20	            REP #$20
.1a2b03	a5 92		lda $0892	                LDA MTEMP               ; Separate the 100s from the 1000s digits
.1a2b05	85 23		sta $0823	                STA ARGUMENT1
.1a2b07	20 fd 04	jsr $1a04fd	            JSR DIVINT10
.1a2b0a	e2 20		sep #$20	            SEP #$20
.1a2b0c	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2b0e	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2b0f	0a		asl a		                ASL A
.1a2b10	0a		asl a		                ASL A
.1a2b11	0a		asl a		                ASL A
.1a2b12	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2b14	48		pha		                PHA                     ; Save the 100s and 1000s in BCD
.1a2b15	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a2b19	09 0c		ora #$0c	                ORA #%00001100
.1a2b1b	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2b1f	68		pla		                PLA                     ; Set the century
.1a2b20	8f 0f 08 af	sta $af080f	                STA @lRTC_CENTURY
.1a2b24	68		pla		                PLA                     ; And year to the RTC
.1a2b25	8f 0a 08 af	sta $af080a	                STA @lRTC_YEAR
.1a2b29	68		pla		                PLA                     ; Month...
.1a2b2a	8f 09 08 af	sta $af0809	                STA @lRTC_MONTH
.1a2b2e	68		pla		                PLA                     ; Save the day...
.1a2b2f	8f 06 08 af	sta $af0806	                STA @lRTC_DAY
.1a2b33	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a2b37	29 f7		and #$f7	                AND #%11110111
.1a2b39	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2b3d	20 ac 20	jsr $1a20ac	            JSR SKIPSTMT
.1a2b40	28		plp		                PLP
.1a2b41	60		rts		            RTS
.1a2b42					S_TEXTCOLOR
.1a2b42	08		php		                PHP
.1a2b43					locals
>0001					L_FOREGROUND    .byte ?
.1a2b43	e2 20		sep #$20	            SEP #$20
.1a2b45	48		pha		            PHA
.1a2b46	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2b49	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2b4c	e2 20		sep #$20	            SEP #$20
.1a2b4e	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the foreground position
.1a2b50	29 0f		and #$0f	                AND #$0F
.1a2b52	0a		asl a		                ASL A
.1a2b53	0a		asl a		                ASL A
.1a2b54	0a		asl a		                ASL A
.1a2b55	0a		asl a		                ASL A
.1a2b56	83 01		sta $01,s	                STA L_FOREGROUND    ; Save the foreground color
.1a2b58	a9 2c		lda #$2c	                LDA #','
.1a2b5a	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a2b5d	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2b60	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2b63	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the background position
.1a2b65	29 0f		and #$0f	                AND #$0F
.1a2b67	03 01		ora $01,s	                ORA L_FOREGROUND    ; Add in the foreground
.1a2b69	8f 1e 00 00	sta $00001e	                STA @lCURCOLOR      ; And save the new color combination
.1a2b6d	e2 20		sep #$20	            SEP #$20
.1a2b6f	68		pla		            PLA
.1a2b70	28		plp		                PLP
.1a2b71	60		rts		            RTS
.1a2b72					S_SETBGCOLOR
.1a2b72	08		php		                PHP
.1a2b73					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.1a2b73	c2 20		rep #$20	            REP #$20
.1a2b75	f4 00 00	pea #$0000	            PEA #0
.1a2b78	e2 20		sep #$20	            SEP #$20
.1a2b7a	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2b7d	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2b80	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.1a2b82	83 01		sta $01,s	                STA L_RED
.1a2b84	a9 2c		lda #$2c	                LDA #','
.1a2b86	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a2b89	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2b8c	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2b8f	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.1a2b91	83 02		sta $02,s	                STA L_GREEN
.1a2b93	a9 2c		lda #$2c	                LDA #','
.1a2b95	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a2b98	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2b9b	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2b9e	a5 23		lda $0823	                LDA ARGUMENT1               ; And set the actual color
.1a2ba0	8f 0d 00 af	sta $af000d	                STA @lBACKGROUND_COLOR_B
.1a2ba4	a3 02		lda $02,s	                LDA L_GREEN
.1a2ba6	8f 0e 00 af	sta $af000e	                STA @lBACKGROUND_COLOR_G
.1a2baa	a3 01		lda $01,s	                LDA L_RED
.1a2bac	8f 0f 00 af	sta $af000f	                STA @lBACKGROUND_COLOR_R
.1a2bb0	c2 20		rep #$20	            REP #$20
.1a2bb2	68		pla		            PLA
.1a2bb3	28		plp		                PLP
.1a2bb4	60		rts		            RTS
.1a2bb5					S_SETBORDER
.1a2bb5	08		php		                PHP
.1a2bb6					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.1a2bb6	c2 20		rep #$20	            REP #$20
.1a2bb8	f4 00 00	pea #$0000	            PEA #0
.1a2bbb	e2 20		sep #$20	            SEP #$20
.1a2bbd	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2bc0	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a2bc3	a5 23		lda $0823	                LDA ARGUMENT1
.1a2bc5	f0 16		beq $1a2bdd	                BEQ hide_border
.1a2bc7	a9 01		lda #$01	                LDA #Border_Ctrl_Enable     ; Enable the border
.1a2bc9	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.1a2bcd	a9 20		lda #$20	                LDA #BORDER_WIDTH           ; Set the border width
.1a2bcf	8f 08 00 af	sta $af0008	                STA BORDER_X_SIZE
.1a2bd3	8f 09 00 af	sta $af0009	                STA BORDER_Y_SIZE
.1a2bd7	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.1a2bdb	80 0a		bra $1a2be7	                BRA get_color
.1a2bdd	a9 00		lda #$00	hide_border     LDA #0                      ; Hide the border
.1a2bdf	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.1a2be3	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.1a2be7	a9 2c		lda #$2c	get_color       LDA #','
.1a2be9	85 37		sta $0837	                STA TARGETTOK
.1a2beb	20 a9 21	jsr $1a21a9	            JSR OPT_TOK
.1a2bee	90 39		bcc $1a2c29	                BCC done                    ; No: we're done
.1a2bf0	20 67 20	jsr $1a2067	            JSR INCBIP
.1a2bf3	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2bf6	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2bf9	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.1a2bfb	83 01		sta $01,s	                STA L_RED
.1a2bfd	a9 2c		lda #$2c	                LDA #','
.1a2bff	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a2c02	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2c05	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2c08	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.1a2c0a	83 02		sta $02,s	                STA L_GREEN
.1a2c0c	a9 2c		lda #$2c	                LDA #','
.1a2c0e	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a2c11	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2c14	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2c17	a5 23		lda $0823	                LDA ARGUMENT1
.1a2c19	8f 05 00 af	sta $af0005	                STA @lBORDER_COLOR_B        ; Set the border color
.1a2c1d	a3 02		lda $02,s	                LDA L_GREEN
.1a2c1f	8f 06 00 af	sta $af0006	                STA @lBORDER_COLOR_G
.1a2c23	a3 01		lda $01,s	                LDA L_RED
.1a2c25	8f 07 00 af	sta $af0007	                STA @lBORDER_COLOR_R
.1a2c29					done
.1a2c29	c2 20		rep #$20	            REP #$20
.1a2c2b	68		pla		            PLA
.1a2c2c	28		plp		                PLP
.1a2c2d	60		rts		            RTS
.1a2c2e					S_SETCOLOR
.1a2c2e	08		php		                PHP
.1a2c2f					locals
>0001					L_LUT           .byte ?
>0002					L_COLOR         .byte ?
>0003					L_RED           .byte ?
>0004					L_GREEN         .byte ?
>0005					L_BLUE          .byte ?
.1a2c2f	c2 20		rep #$20	            REP #$20
.1a2c31	3b		tsc		            TSC
.1a2c32	38		sec		            SEC
.1a2c33	e9 05 00	sbc #$0005	            SBC #SIZE(locals)
.1a2c36	1b		tcs		            TCS
.1a2c37	e2 20		sep #$20	            SEP #$20
.1a2c39	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2c3c	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2c3f	a5 23		lda $0823	                LDA ARGUMENT1
.1a2c41	c9 0a		cmp #$0a	                CMP #10             ; And in range
.1a2c43	90 1f		bcc $1a2c64	                BLT save_lut
.1a2c45					bad_argument
.1a2c45	08		php		            PHP
.1a2c46	c2 20		rep #$20	            REP #$20
.1a2c48	48		pha		            PHA
.1a2c49	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2c4c	5b		tcd		            TCD
.1a2c4d	68		pla		            PLA
.1a2c4e	28		plp		            PLP
.1a2c4f	e2 20		sep #$20	            SEP #$20
.1a2c51	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a2c53	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2c57	c2 20		rep #$20	            REP #$20
.1a2c59	29 ff 00	and #$00ff	            AND #$00FF
.1a2c5c	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a2c5f	e2 20		sep #$20	            SEP #$20
.1a2c61	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2c64	83 01		sta $01,s	save_lut        STA L_LUT           ; Save as LUT
.1a2c66	a9 2c		lda #$2c	                LDA #','
.1a2c68	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a2c6b	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2c6e	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2c71	a5 23		lda $0823	                LDA ARGUMENT1
.1a2c73	83 02		sta $02,s	                STA L_COLOR         ; Save as COLOR
.1a2c75	a9 2c		lda #$2c	                LDA #','
.1a2c77	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a2c7a	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2c7d	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2c80	a5 23		lda $0823	                LDA ARGUMENT1
.1a2c82	83 03		sta $03,s	                STA L_RED           ; Save as RED
.1a2c84	a9 2c		lda #$2c	                LDA #','
.1a2c86	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a2c89	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2c8c	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2c8f	a5 23		lda $0823	                LDA ARGUMENT1
.1a2c91	83 04		sta $04,s	                STA L_GREEN         ; Save it as GREEN
.1a2c93	a9 2c		lda #$2c	                LDA #','
.1a2c95	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a2c98	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2c9b	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2c9e	a5 23		lda $0823	                LDA ARGUMENT1
.1a2ca0	83 05		sta $05,s	                STA L_BLUE          ; Save it as BLUE
.1a2ca2	a9 af		lda #$af	                LDA #`GRPH_LUT0_PTR ; Get the bank Vicky is in (should always be $AF)
.1a2ca4	85 a0		sta $08a0	                STA MTEMPPTR+2      ; MTEMPPTR will be our pointer to the LUT entry
.1a2ca6	a3 01		lda $01,s	                LDA L_LUT           ; Compute the offset to the LUT address
.1a2ca8	0a		asl a		                ASL A
.1a2ca9	c2 20		rep #$20	            REP #$20
.1a2cab	29 ff 00	and #$00ff	                AND #$00FF
.1a2cae	aa		tax		                TAX                 ; Put it in X
.1a2caf	bf e6 2c 1a	lda $1a2ce6,x	                LDA @llut_address,X ; Get the address of the LUT
.1a2cb3	85 9e		sta $089e	                STA MTEMPPTR        ; Put it in MTEMPPTR
.1a2cb5	e2 20		sep #$20	            SEP #$20
.1a2cb7	a3 02		lda $02,s	                LDA L_COLOR         ; color index *= 4
.1a2cb9	c2 20		rep #$20	            REP #$20
.1a2cbb	29 ff 00	and #$00ff	                AND #$00FF
.1a2cbe	0a		asl a		                ASL A               ; Since each color has four bytes of data
.1a2cbf	0a		asl a		                ASL A
.1a2cc0	18		clc		                CLC                 ; Add the color offset to MTEMPPTR
.1a2cc1	65 9e		adc $089e	                ADC MTEMPPTR
.1a2cc3	85 9e		sta $089e	                STA MTEMPPTR
.1a2cc5	e2 20		sep #$20	            SEP #$20
.1a2cc7	a0 02 00	ldy #$0002	                LDY #GR_LUT_RED
.1a2cca	a3 03		lda $03,s	                LDA L_RED
.1a2ccc	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the red component to the color entry
.1a2cce	a0 01 00	ldy #$0001	                LDY #GR_LUT_GREEN
.1a2cd1	a3 04		lda $04,s	                LDA L_GREEN
.1a2cd3	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the green component to the color entry
.1a2cd5	a0 00 00	ldy #$0000	                LDY #GR_LUT_BLUE
.1a2cd8	a3 05		lda $05,s	                LDA L_BLUE
.1a2cda	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the blue component to the color entry
.1a2cdc					done
.1a2cdc	c2 20		rep #$20	            REP #$20
.1a2cde	3b		tsc		            TSC
.1a2cdf	18		clc		            CLC
.1a2ce0	69 05 00	adc #$0005	            ADC #SIZE(locals)
.1a2ce3	1b		tcs		            TCS
.1a2ce4	28		plp		                PLP
.1a2ce5	60		rts		            RTS
>1a2ce6	00 20				lut_address     .word <>GRPH_LUT0_PTR
>1a2ce8	00 24				                .word <>GRPH_LUT1_PTR
>1a2cea	00 28				                .word <>GRPH_LUT2_PTR
>1a2cec	00 2c				                .word <>GRPH_LUT3_PTR
>1a2cee	00 30				                .word <>GRPH_LUT4_PTR
>1a2cf0	00 34				                .word <>GRPH_LUT5_PTR
>1a2cf2	00 38				                .word <>GRPH_LUT6_PTR
>1a2cf4	00 3c				                .word <>GRPH_LUT7_PTR
>1a2cf6	40 1f				                .word <>FG_CHAR_LUT_PTR
>1a2cf8	80 1f				                .word <>BG_CHAR_LUT_PTR
.1a2cfa					S_GRAPHICS
.1a2cfa	da		phx		                PHX
.1a2cfb	5a		phy		                PHY
.1a2cfc	08		php		                PHP
.1a2cfd	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2d00	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a2d03	c2 20		rep #$20	            REP #$20
.1a2d05	a5 23		lda $0823	                LDA ARGUMENT1               ; Check to see if we're setting mode to 800x600 or 400x300
.1a2d07	89 00 01	bit #$0100	                BIT #$0100
.1a2d0a	d0 17		bne $1a2d23	                BNE set_mode                ; Yes: go ahead and set it
.1a2d0c	af 00 00 af	lda $af0000	                LDA @l MASTER_CTRL_REG_L    ; Otherwise, check to see if we're already in 800x600 or 400x300
.1a2d10	89 00 01	bit #$0100	                BIT #$0100
.1a2d13	f0 0e		beq $1a2d23	                BEQ set_mode                ; No: just go ahead and set the mode
.1a2d15	e2 20		sep #$20	            SEP #$20
.1a2d17	a9 00		lda #$00	                LDA #0                      ; Yes: toggle back to 640x480...
.1a2d19	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.1a2d1d	a9 01		lda #$01	                LDA #1                      ; And back to 800x600....
.1a2d1f	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.1a2d23					set_mode
.1a2d23	c2 20		rep #$20	            REP #$20
.1a2d25	a5 23		lda $0823	                LDA ARGUMENT1
.1a2d27	8f 00 00 af	sta $af0000	                STA @l MASTER_CTRL_REG_L    ; Set the graphics mode
.1a2d2b	e2 20		sep #$20	            SEP #$20
.1a2d2d	a5 24		lda $0824	                LDA ARGUMENT1+1             ; Get the screen size bits
.1a2d2f	c2 20		rep #$20	            REP #$20
.1a2d31	29 03 00	and #$0003	                AND #$0003
.1a2d34	0a		asl a		                ASL A                       ; Multiply by two to get the index
.1a2d35	aa		tax		                TAX                         ; X is index into the size tables
.1a2d36	c2 20		rep #$20	            REP #$20
.1a2d38	bf 81 2d 1a	lda $1a2d81,x	                LDA gr_columns,X            ; Set the columns
.1a2d3c	8f 10 f0 1a	sta $1af010	                STA @lGR_MAX_COLS
.1a2d40	bf 89 2d 1a	lda $1a2d89,x	                LDA gr_rows,X               ; Set the rows
.1a2d44	8f 12 f0 1a	sta $1af012	                STA @lGR_MAX_ROWS
.1a2d48	af 10 f0 1a	lda $1af010	                LDA @lGR_MAX_COLS           ; Get the current columns
.1a2d4c	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.1a2d50	af 12 f0 1a	lda $1af012	                LDA @lGR_MAX_ROWS           ; Get the current rows
.1a2d54	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B
.1a2d58	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT             ; Multiply them to get the total pixels
.1a2d5c	8f 14 f0 1a	sta $1af014	                STA @lGR_TOTAL_PIXELS
.1a2d60	e2 20		sep #$20	            SEP #$20
.1a2d62	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.1a2d66	8f 16 f0 1a	sta $1af016	                STA @lGR_TOTAL_PIXELS+2
.1a2d6a	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.1a2d6e					reset_cursor
.1a2d6e	c2 20		rep #$20	            REP #$20
.1a2d70	af 1a 00 00	lda $00001a	                LDA @lCURSORX
.1a2d74	aa		tax		                TAX
.1a2d75	af 1c 00 00	lda $00001c	                LDA @lCURSORY
.1a2d79	a8		tay		                TAY
.1a2d7a	20 20 00	jsr $1a0020	            JSR CURSORXY
.1a2d7d	28		plp		                PLP
.1a2d7e	7a		ply		                PLY
.1a2d7f	fa		plx		                PLX
.1a2d80	60		rts		            RTS
>1a2d81	80 02 20 03 40 01 90 01		gr_columns      .word 640,800,320,400
>1a2d89	e0 01 58 02 f0 00 2c 01		gr_rows         .word 480,600,240,300
>1a2d91	50 00 64 00 28 00 32 00		col_count       .word 80,100,40,50
>1a2d99	3c 00 4b 00 1e 00 32 00		row_count       .word 60,75,30,50
>1a2da1	48 00 5c 00 20 00 2a 00		colb_count      .word 72,92,32,42
>1a2da9	34 00 43 00 16 00 34 00		rowb_count      .word 52,67,22,52
.1a2db1					BITMAP_SRAM
.1a2db1	da		phx		                PHX
.1a2db2	08		php		                PHP
.1a2db3	c2 30		rep #$30	            REP #$30
.1a2db5	c9 02 00	cmp #$0002	                CMP #BM_MAX
.1a2db8	b0 1c		bcs $1a2dd6	                BGE range_err           ; Make sure it's within range
.1a2dba	0a		asl a		                ASL A
.1a2dbb	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.1a2dbc	aa		tax		                TAX
.1a2dbd	bf 00 f0 1a	lda $1af000,x	                LDA @l GR_BM0_ADDR,X    ; Get the low 16-bits of the address
.1a2dc1	85 9e		sta $089e	                STA MTEMPPTR
.1a2dc3	bf 02 f0 1a	lda $1af002,x	                LDA @l GR_BM0_ADDR+2,X  ; Get the high bits of the address
.1a2dc7	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a2dc9	c9 f0 00	cmp #$00f0	                CMP #MAX_VRAM_CPU       ; Check to make sure address is within VRAM
.1a2dcc	b0 08		bcs $1a2dd6	                BGE range_err
.1a2dce	c9 b0 00	cmp #$00b0	                CMP #MIN_VRAM_CPU
.1a2dd1	90 03		bcc $1a2dd6	                BLT range_err
.1a2dd3	28		plp		                PLP
.1a2dd4	fa		plx		                PLX
.1a2dd5	60		rts		            RTS
.1a2dd6					range_err
.1a2dd6	08		php		            PHP
.1a2dd7	c2 20		rep #$20	            REP #$20
.1a2dd9	48		pha		            PHA
.1a2dda	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2ddd	5b		tcd		            TCD
.1a2dde	68		pla		            PLA
.1a2ddf	28		plp		            PLP
.1a2de0	e2 20		sep #$20	            SEP #$20
.1a2de2	a9 09		lda #$09	            LDA #ERR_RANGE
.1a2de4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2de8	c2 20		rep #$20	            REP #$20
.1a2dea	29 ff 00	and #$00ff	            AND #$00FF
.1a2ded	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a2df0	e2 20		sep #$20	            SEP #$20
.1a2df2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2df5					BITMAP_VRAM
.1a2df5	da		phx		                PHX
.1a2df6	08		php		                PHP
.1a2df7	c2 30		rep #$30	            REP #$30
.1a2df9	c9 02 00	cmp #$0002	                CMP #BM_MAX
.1a2dfc	b0 17		bcs $1a2e15	                BGE range_err           ; Make sure it's within range
.1a2dfe	0a		asl a		                ASL A
.1a2dff	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.1a2e00	aa		tax		                TAX
.1a2e01	bf 08 f0 1a	lda $1af008,x	                LDA @l GR_BM0_VRAM,X    ; Get the low 16-bits of the address
.1a2e05	85 9e		sta $089e	                STA MTEMPPTR
.1a2e07	bf 0a f0 1a	lda $1af00a,x	                LDA @l GR_BM0_VRAM+2,X  ; Get the high bits of the address
.1a2e0b	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a2e0d	c9 40 00	cmp #$0040	                CMP #MAX_VRAM_VICKY     ; Check to make sure the address is from $00:0000 - $3F:FFFF
.1a2e10	b0 03		bcs $1a2e15	                BGE range_err           ; If not, throw a range error
.1a2e12	28		plp		                PLP
.1a2e13	fa		plx		                PLX
.1a2e14	60		rts		            RTS
.1a2e15					range_err
.1a2e15	08		php		            PHP
.1a2e16	c2 20		rep #$20	            REP #$20
.1a2e18	48		pha		            PHA
.1a2e19	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2e1c	5b		tcd		            TCD
.1a2e1d	68		pla		            PLA
.1a2e1e	28		plp		            PLP
.1a2e1f	e2 20		sep #$20	            SEP #$20
.1a2e21	a9 09		lda #$09	            LDA #ERR_RANGE
.1a2e23	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2e27	c2 20		rep #$20	            REP #$20
.1a2e29	29 ff 00	and #$00ff	            AND #$00FF
.1a2e2c	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a2e2f	e2 20		sep #$20	            SEP #$20
.1a2e31	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2e34					S_BITMAP
.1a2e34	08		php		                PHP
.1a2e35					locals
>0001					L_PLANE         .word ?
>0003					L_VISIBLE       .byte ?
>0004					L_ADDRESS       .dword ?
.1a2e35	c2 30		rep #$30	            REP #$30
.1a2e37	3b		tsc		                TSC                         ; Allocate space for the locals on the stack
.1a2e38	38		sec		                SEC
.1a2e39	e9 07 00	sbc #$0007	                SBC #SIZE(locals)
.1a2e3c	1b		tcs		                TCS
.1a2e3d	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2e40	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2e43	c2 20		rep #$20	            REP #$20
.1a2e45	a5 23		lda $0823	                LDA ARGUMENT1               ; Make sure it's in range
.1a2e47	c9 02 00	cmp #$0002	                CMP #BM_MAX
.1a2e4a	b0 59		bcs $1a2ea5	                BGE range_err               ; If not, throw an error
.1a2e4c	83 01		sta $01,s	                STA L_PLANE                 ; If so, save it to MARG1
.1a2e4e	e2 20		sep #$20	            SEP #$20
.1a2e50	a9 2c		lda #$2c	                LDA #','
.1a2e52	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a2e55	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2e58	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2e5b	a5 23		lda $0823	                LDA ARGUMENT1
.1a2e5d	83 03		sta $03,s	                STA L_VISIBLE
.1a2e5f	a9 2c		lda #$2c	                LDA #','
.1a2e61	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a2e64	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2e67	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2e6a	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the number back
.1a2e6c	0a		asl a		                ASL A                       ; Multiply by 8 to get the offset to the registers
.1a2e6d	0a		asl a		                ASL A
.1a2e6e	0a		asl a		                ASL A
.1a2e6f	aa		tax		                TAX                         ; And save that offset to X
.1a2e70	a3 03		lda $03,s	                LDA L_VISIBLE               ; Check the visible flag
.1a2e72	d0 05		bne $1a2e79	                BNE is_visible              ; If <> 0, it's visible
.1a2e74	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the LUT #
.1a2e76	0a		asl a		                ASL A                       ; Shift it into position for the register
.1a2e77	80 04		bra $1a2e7d	                BRA wr_bm_reg               ; And go to write it
.1a2e79	a5 23		lda $0823	is_visible      LDA ARGUMENT1               ; Get the LUT #
.1a2e7b	38		sec		                SEC
.1a2e7c	2a		rol a		                ROL A                       ; And shift it into position, and set enable bit
.1a2e7d	9f 00 01 af	sta $af0100,x	wr_bm_reg       STA @l BM0_CONTROL_REG,X    ; Write to the bitmap control register
.1a2e81	c2 20		rep #$20	            REP #$20
.1a2e83	a9 2c 00	lda #$002c	                LDA #','
.1a2e86	85 37		sta $0837	                STA TARGETTOK
.1a2e88	20 a9 21	jsr $1a21a9	            JSR OPT_TOK
.1a2e8b	b0 37		bcs $1a2ec4	                BCS get_address             ; Yes: parse the address
.1a2e8d	c2 20		rep #$20	            REP #$20
.1a2e8f	08		php		            PHP
.1a2e90	c2 20		rep #$20	            REP #$20
.1a2e92	a9 00 00	lda #$0000	            LDA #<>VRAM
.1a2e95	85 23		sta $0823	            STA ARGUMENT1
.1a2e97	a9 b0 00	lda #$00b0	            LDA #(VRAM >> 16)
.1a2e9a	85 25		sta $0825	            STA ARGUMENT1+2
.1a2e9c	e2 20		sep #$20	            SEP #$20
.1a2e9e	a9 00		lda #$00	            LDA #TYPE_INTEGER
.1a2ea0	85 27		sta $0827	            STA ARGUMENT1+4
.1a2ea2	28		plp		            PLP
.1a2ea3	80 27		bra $1a2ecc	                BRA set_address
.1a2ea5					range_err
.1a2ea5	08		php		            PHP
.1a2ea6	c2 20		rep #$20	            REP #$20
.1a2ea8	48		pha		            PHA
.1a2ea9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2eac	5b		tcd		            TCD
.1a2ead	68		pla		            PLA
.1a2eae	28		plp		            PLP
.1a2eaf	e2 20		sep #$20	            SEP #$20
.1a2eb1	a9 09		lda #$09	            LDA #ERR_RANGE
.1a2eb3	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2eb7	c2 20		rep #$20	            REP #$20
.1a2eb9	29 ff 00	and #$00ff	            AND #$00FF
.1a2ebc	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a2ebf	e2 20		sep #$20	            SEP #$20
.1a2ec1	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2ec4					get_address
.1a2ec4	c2 20		rep #$20	            REP #$20
.1a2ec6	20 67 20	jsr $1a2067	            JSR INCBIP
.1a2ec9	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2ecc					set_address
.1a2ecc	c2 20		rep #$20	            REP #$20
.1a2ece	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.1a2ed0	0a		asl a		                ASL A                       ; Multiply by four to get the offset to the address variable
.1a2ed1	0a		asl a		                ASL A
.1a2ed2	aa		tax		                TAX                         ; And put it in X
.1a2ed3	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the CPU-space address
.1a2ed5	9f 00 f0 1a	sta $1af000,x	                STA @l GR_BM0_ADDR,X        ; And save it to the correct GR_BM?_ADDR variable
.1a2ed9	9f 08 f0 1a	sta $1af008,x	                STA @l GR_BM0_VRAM,X
.1a2edd	83 04		sta $04,s	                STA L_ADDRESS               ; And L_ADDRESS, temporarily
.1a2edf	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a2ee1	9f 02 f0 1a	sta $1af002,x	                STA @l GR_BM0_ADDR+2,X
.1a2ee5	38		sec		                SEC
.1a2ee6	e9 b0 00	sbc #$00b0	                SBC #`VRAM                  ; Rebase the upper half of the address to Vicky memory space
.1a2ee9	9f 0a f0 1a	sta $1af00a,x	                STA @l GR_BM0_VRAM+2,X
.1a2eed	83 06		sta $06,s	                STA L_ADDRESS+2             ; And to L_ADDRESS
.1a2eef	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.1a2ef1	0a		asl a		                ASL A                       ; Multiply by eight to get the offset to the registers
.1a2ef2	0a		asl a		                ASL A
.1a2ef3	0a		asl a		                ASL A
.1a2ef4	aa		tax		                TAX                         ; And put it in X
.1a2ef5	e2 20		sep #$20	            SEP #$20
.1a2ef7	a3 04		lda $04,s	                LDA L_ADDRESS               ; Get the address in Vicky space...
.1a2ef9	9f 01 01 af	sta $af0101,x	                STA @l BM0_START_ADDY_L,X   ; Save it to the Vicky registers
.1a2efd	a3 05		lda $05,s	                LDA L_ADDRESS+1
.1a2eff	9f 02 01 af	sta $af0102,x	                STA @l BM0_START_ADDY_M,X
.1a2f03	a3 06		lda $06,s	                LDA L_ADDRESS+2
.1a2f05	9f 03 01 af	sta $af0103,x	                STA @l BM0_START_ADDY_H,X
.1a2f09	a9 00		lda #$00	                LDA #0                      ; Default offset to (0, 0)
.1a2f0b	9f 04 01 af	sta $af0104,x	                STA @l BM0_X_OFFSET,X
.1a2f0f	9f 05 01 af	sta $af0105,x	                STA @l BM0_Y_OFFSET,X
.1a2f13	c2 30		rep #$30	            REP #$30
.1a2f15	3b		tsc		                TSC                         ; Remove the space for the locals from the stack
.1a2f16	18		clc		                CLC
.1a2f17	69 07 00	adc #$0007	                ADC #SIZE(locals)
.1a2f1a	1b		tcs		                TCS
.1a2f1b	28		plp		                PLP
.1a2f1c	60		rts		            RTS
.1a2f1d					bad_address
.1a2f1d	08		php		            PHP
.1a2f1e	c2 20		rep #$20	            REP #$20
.1a2f20	48		pha		            PHA
.1a2f21	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2f24	5b		tcd		            TCD
.1a2f25	68		pla		            PLA
.1a2f26	28		plp		            PLP
.1a2f27	e2 20		sep #$20	            SEP #$20
.1a2f29	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a2f2b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2f2f	c2 20		rep #$20	            REP #$20
.1a2f31	29 ff 00	and #$00ff	            AND #$00FF
.1a2f34	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a2f37	e2 20		sep #$20	            SEP #$20
.1a2f39	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2f3c					S_CLRBITMAP
.1a2f3c	08		php		                PHP
.1a2f3d	c2 20		rep #$20	            REP #$20
.1a2f3f	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a2f42	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a2f45	a5 23		lda $0823	                LDA ARGUMENT1
.1a2f47	20 f5 2d	jsr $1a2df5	            JSR BITMAP_VRAM
.1a2f4a	c2 20		rep #$20	            REP #$20
.1a2f4c	a5 9e		lda $089e	                LDA MTEMPPTR                ; Set the start address and the # of pixels to write
.1a2f4e	8f 05 04 af	sta $af0405	                STA @lVDMA_DST_ADDY_L
.1a2f52	af 14 f0 1a	lda $1af014	                LDA @lGR_TOTAL_PIXELS       ; Set the size
.1a2f56	8f 08 04 af	sta $af0408	                STA @lVDMA_SIZE_L
.1a2f5a	e2 20		sep #$20	            SEP #$20
.1a2f5c	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.1a2f5e	8f 07 04 af	sta $af0407	                STA @lVDMA_DST_ADDY_H
.1a2f62	af 16 f0 1a	lda $1af016	                LDA @lGR_TOTAL_PIXELS+2
.1a2f66	8f 0a 04 af	sta $af040a	                STA @lVDMA_SIZE_H
.1a2f6a	a9 00		lda #$00	                LDA #0                      ; Set the color to write
.1a2f6c	8f 01 04 af	sta $af0401	                STA @lVDMA_BYTE_2_WRITE
.1a2f70	a9 85		lda #$85	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_Start_TRF
.1a2f72	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.1a2f76	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.1a2f7a	30 fa		bmi $1a2f76	                BMI wait
.1a2f7c	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.1a2f7e	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.1a2f82	28		plp		done            PLP
.1a2f83	60		rts		            RTS
=$000855				COLOR = MARG1
=$000859				X0 = MARG2
=$00085d				Y0 = MARG3
=$000861				X1 = MARG4
=$000865				Y1 = MARG5
=$000869				DX = MARG6
=$00086d				DY = MARG7
=$000871				ERR = MARG8
=$000875				ERR2 = MARG9
>08dd					SX      .word ?
>08df					SY      .word ?
.1a2f84					PLOT
.1a2f84	08		php		                PHP
.1a2f85	c2 20		rep #$20	            REP #$20
.1a2f87	a5 5d		lda $085d	                LDA Y0                      ; Get the row
.1a2f89	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.1a2f8d	af 10 f0 1a	lda $1af010	                LDA @lGR_MAX_COLS
.1a2f91	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B          ; Multiply by the number of columns in the pixmap
.1a2f95	18		clc		                CLC                         ; Add the column
.1a2f96	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT
.1a2f9a	65 59		adc $0859	                ADC X0
.1a2f9c	85 0c		sta $080c	                STA SCRATCH
.1a2f9e	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.1a2fa2	69 00 00	adc #$0000	                ADC #0
.1a2fa5	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH is offset of pixel in the pixmap
.1a2fa7	18		clc		                CLC                         ; Add the address of the first pixel
.1a2fa8	a5 0c		lda $080c	                LDA SCRATCH
.1a2faa	65 9e		adc $089e	                ADC MTEMPPTR
.1a2fac	85 0c		sta $080c	                STA SCRATCH
.1a2fae	a5 0e		lda $080e	                LDA SCRATCH+2
.1a2fb0	65 a0		adc $08a0	                ADC MTEMPPTR+2
.1a2fb2	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH := pixmap + pixel offset
.1a2fb4	e2 20		sep #$20	            SEP #$20
.1a2fb6	a5 55		lda $0855	                LDA COLOR                   ; Get the color
.1a2fb8	87 0c		sta [$080c]	                STA [SCRATCH]               ; And write the color to the pixel
.1a2fba	28		plp		                PLP
.1a2fbb	60		rts		            RTS
.1a2fbc					LINE
.1a2fbc	c2 20		rep #$20	            REP #$20
.1a2fbe	a9 01 00	lda #$0001	                LDA #1                      ; Assume SX = 1
.1a2fc1	85 dd		sta $08dd	                STA SX
.1a2fc3	38		sec		                SEC                         ; DX := ABS(X1 - X0)
.1a2fc4	a5 61		lda $0861	                LDA X1
.1a2fc6	e5 59		sbc $0859	                SBC X0
.1a2fc8	85 69		sta $0869	                STA DX
.1a2fca	10 0b		bpl $1a2fd7	                BPL abs_Y                   ; If DX < 0 {
.1a2fcc	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DX := -DX
.1a2fcf	1a		inc a		                INC A
.1a2fd0	85 69		sta $0869	                STA DX
.1a2fd2	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SX := -1
.1a2fd5	85 dd		sta $08dd	                STA SX                      ; }
.1a2fd7	a9 01 00	lda #$0001	abs_Y           LDA #1                      ; Assume SY = 1
.1a2fda	85 df		sta $08df	                STA SY
.1a2fdc	38		sec		                SEC                         ; DY := ABS(Y1 - Y0)
.1a2fdd	a5 65		lda $0865	                LDA Y1
.1a2fdf	e5 5d		sbc $085d	                SBC Y0
.1a2fe1	85 6d		sta $086d	                STA DY
.1a2fe3	10 0b		bpl $1a2ff0	                BPL calc_ERR                ; If DY < 0 {
.1a2fe5	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DY := -DY
.1a2fe8	1a		inc a		                INC A
.1a2fe9	85 6d		sta $086d	                STA DY
.1a2feb	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SY := -1
.1a2fee	85 df		sta $08df	                STA SY                      ; }
.1a2ff0	a5 6d		lda $086d	calc_ERR        LDA DY                      ; (DY < DX)
.1a2ff2	c5 69		cmp $0869	                CMP DX
.1a2ff4	b0 04		bcs $1a2ffa	                BGE else
.1a2ff6	a5 69		lda $0869	                LDA DX                      ; TRUE CASE: ERR := DX
.1a2ff8	80 06		bra $1a3000	                BRA shiftERR
.1a2ffa	a5 6d		lda $086d	else            LDA DY                      ; FALSE CASE: ERR := -DY
.1a2ffc	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a2fff	1a		inc a		                INC A
.1a3000	48		pha		shiftERR        PHA
.1a3001	0a		asl a		                ASL A
.1a3002	68		pla		                PLA
.1a3003	6a		ror a		                ROR A                       ; ERR := ERR / 2
.1a3004	85 71		sta $0871	                STA ERR
.1a3006					loop
.1a3006	20 84 2f	jsr $1a2f84	            JSR PLOT
.1a3009	a5 59		lda $0859	                LDA X0                      ; break if X0=X1 and Y0=Y1
.1a300b	c5 61		cmp $0861	                CMP X1
.1a300d	d0 06		bne $1a3015	                BNE calc_ERR2
.1a300f	a5 5d		lda $085d	                LDA Y0
.1a3011	c5 65		cmp $0865	                CMP Y1
.1a3013	f0 36		beq $1a304b	                BEQ done
.1a3015	a5 71		lda $0871	calc_ERR2       LDA ERR                     ; ERR2 := ERR
.1a3017	85 75		sta $0875	                STA ERR2
.1a3019	a5 69		lda $0869	                LDA DX                      ; if (ERR2 > -DX) {
.1a301b	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a301e	1a		inc a		                INC A
.1a301f	c5 75		cmp $0875	                CMP ERR2
.1a3021	10 10		bpl $1a3033	                BPL check_DY
.1a3023	f0 0e		beq $1a3033	                BEQ check_DY
.1a3025	38		sec		                SEC                         ; ERR -= DY
.1a3026	a5 71		lda $0871	                LDA ERR
.1a3028	e5 6d		sbc $086d	                SBC DY
.1a302a	85 71		sta $0871	                STA ERR
.1a302c	18		clc		                CLC                         ; X0 += SX
.1a302d	a5 59		lda $0859	                LDA X0
.1a302f	65 dd		adc $08dd	                ADC SX
.1a3031	85 59		sta $0859	                STA X0                      ; }
.1a3033	a5 75		lda $0875	check_DY        LDA ERR2                    ; if (ERR2 < DY) {
.1a3035	c5 6d		cmp $086d	                CMP DY
.1a3037	10 cd		bpl $1a3006	                BPL loop
.1a3039	f0 cb		beq $1a3006	                BEQ loop
.1a303b	18		clc		                CLC                         ; ERR += DX
.1a303c	a5 71		lda $0871	                LDA ERR
.1a303e	65 69		adc $0869	                ADC DX
.1a3040	85 71		sta $0871	                STA ERR
.1a3042	18		clc		                CLC                         ; Y0 += SY
.1a3043	a5 5d		lda $085d	                LDA Y0
.1a3045	65 df		adc $08df	                ADC SY
.1a3047	85 5d		sta $085d	                STA Y0                      ; }
.1a3049	80 bb		bra $1a3006	                BRA loop                    ; }
.1a304b					done
.1a304b	60		rts		            RTS
.1a304c					S_PLOT
.1a304c	08		php		                PHP
.1a304d					locals
>0001					L_PLANE         .word ?
>0003					L_X             .word ?
>0005					L_Y             .word ?
.1a304d	c2 20		rep #$20	            REP #$20
.1a304f	3b		tsc		            TSC
.1a3050	38		sec		            SEC
.1a3051	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.1a3054	1b		tcs		            TCS
.1a3055	08		php		            PHP
.1a3056	c2 20		rep #$20	            REP #$20
.1a3058	48		pha		            PHA
.1a3059	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a305c	5b		tcd		            TCD
.1a305d	68		pla		            PLA
.1a305e	28		plp		            PLP
.1a305f	08		php		            PHP
.1a3060	e2 20		sep #$20	            SEP #$20
.1a3062	48		pha		            PHA
.1a3063	a9 00		lda #$00	            LDA #0
.1a3065	48		pha		            PHA
.1a3066	ab		plb		            PLB
.1a3067	68		pla		            PLA
.1a3068	28		plp		            PLP
.1a3069	c2 30		rep #$30	            REP #$30
.1a306b	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a306e	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a3071	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.1a3073	a9 2c 00	lda #$002c	                LDA #','
.1a3076	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a3079	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a307c	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a307f	a5 23		lda $0823	                LDA ARGUMENT1
.1a3081	83 03		sta $03,s	                STA L_X                     ; Save it to X
.1a3083	a9 2c 00	lda #$002c	                LDA #','
.1a3086	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a3089	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a308c	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a308f	a5 23		lda $0823	                LDA ARGUMENT1
.1a3091	83 05		sta $05,s	                STA L_Y                     ; Save it to Y
.1a3093	a9 2c 00	lda #$002c	                LDA #','
.1a3096	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a3099	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a309c	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a309f	a5 23		lda $0823	                LDA ARGUMENT1
.1a30a1	85 55		sta $0855	                STA COLOR                   ; Save it to MARG1
.1a30a3	a3 03		lda $03,s	                LDA L_X                     ; Set the (X0, Y0) coordinates
.1a30a5	85 59		sta $0859	                STA X0
.1a30a7	a3 05		lda $05,s	                LDA L_Y
.1a30a9	85 5d		sta $085d	                STA Y0
.1a30ab	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.1a30ad	20 b1 2d	jsr $1a2db1	            JSR BITMAP_SRAM
.1a30b0	20 84 2f	jsr $1a2f84	            JSR PLOT
.1a30b3	c2 20		rep #$20	            REP #$20
.1a30b5	3b		tsc		            TSC
.1a30b6	18		clc		            CLC
.1a30b7	69 06 00	adc #$0006	            ADC #SIZE(locals)
.1a30ba	1b		tcs		            TCS
.1a30bb	28		plp		                PLP
.1a30bc	60		rts		            RTS
.1a30bd					S_LINE
.1a30bd	08		php		                PHP
.1a30be					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
.1a30be	c2 20		rep #$20	            REP #$20
.1a30c0	3b		tsc		            TSC
.1a30c1	38		sec		            SEC
.1a30c2	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.1a30c5	1b		tcs		            TCS
.1a30c6	08		php		            PHP
.1a30c7	c2 20		rep #$20	            REP #$20
.1a30c9	48		pha		            PHA
.1a30ca	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a30cd	5b		tcd		            TCD
.1a30ce	68		pla		            PLA
.1a30cf	28		plp		            PLP
.1a30d0	08		php		            PHP
.1a30d1	e2 20		sep #$20	            SEP #$20
.1a30d3	48		pha		            PHA
.1a30d4	a9 00		lda #$00	            LDA #0
.1a30d6	48		pha		            PHA
.1a30d7	ab		plb		            PLB
.1a30d8	68		pla		            PLA
.1a30d9	28		plp		            PLP
.1a30da	c2 30		rep #$30	            REP #$30
.1a30dc	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a30df	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a30e2	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.1a30e4	a9 2c 00	lda #$002c	                LDA #','
.1a30e7	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a30ea	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a30ed	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a30f0	a5 23		lda $0823	                LDA ARGUMENT1
.1a30f2	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.1a30f4	a9 2c 00	lda #$002c	                LDA #','
.1a30f7	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a30fa	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a30fd	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a3100	a5 23		lda $0823	                LDA ARGUMENT1
.1a3102	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.1a3104	a9 2c 00	lda #$002c	                LDA #','
.1a3107	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a310a	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a310d	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a3110	a5 23		lda $0823	                LDA ARGUMENT1
.1a3112	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.1a3114	a9 2c 00	lda #$002c	                LDA #','
.1a3117	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a311a	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a311d	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a3120	a5 23		lda $0823	                LDA ARGUMENT1
.1a3122	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.1a3124	a9 2c 00	lda #$002c	                LDA #','
.1a3127	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a312a	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a312d	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a3130	a5 23		lda $0823	                LDA ARGUMENT1
.1a3132	85 55		sta $0855	                STA COLOR                   ; Save it to COLOR
.1a3134	a3 03		lda $03,s	                LDA L_X0                    ; Set the (X0, Y0) coordinates
.1a3136	85 59		sta $0859	                STA X0
.1a3138	a3 05		lda $05,s	                LDA L_Y0
.1a313a	85 5d		sta $085d	                STA Y0
.1a313c	a3 07		lda $07,s	                LDA L_X1                    ; Set the (X1, Y1) coordinates
.1a313e	85 61		sta $0861	                STA X1
.1a3140	a3 09		lda $09,s	                LDA L_Y1
.1a3142	85 65		sta $0865	                STA Y1
.1a3144	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.1a3146	20 b1 2d	jsr $1a2db1	            JSR BITMAP_SRAM
.1a3149	20 bc 2f	jsr $1a2fbc	            JSR LINE
.1a314c					done
.1a314c	c2 20		rep #$20	            REP #$20
.1a314e	3b		tsc		            TSC
.1a314f	18		clc		            CLC
.1a3150	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.1a3153	1b		tcs		            TCS
.1a3154	28		plp		                PLP
.1a3155	60		rts		            RTS
.1a3156					S_FILL
.1a3156	08		php		                PHP
.1a3157					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
>000b					L_COLOR         .word ?
.1a3157	c2 20		rep #$20	            REP #$20
.1a3159	3b		tsc		            TSC
.1a315a	38		sec		            SEC
.1a315b	e9 0c 00	sbc #$000c	            SBC #SIZE(locals)
.1a315e	1b		tcs		            TCS
.1a315f	08		php		            PHP
.1a3160	c2 20		rep #$20	            REP #$20
.1a3162	48		pha		            PHA
.1a3163	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3166	5b		tcd		            TCD
.1a3167	68		pla		            PLA
.1a3168	28		plp		            PLP
.1a3169	08		php		            PHP
.1a316a	e2 20		sep #$20	            SEP #$20
.1a316c	48		pha		            PHA
.1a316d	a9 00		lda #$00	            LDA #0
.1a316f	48		pha		            PHA
.1a3170	ab		plb		            PLB
.1a3171	68		pla		            PLA
.1a3172	28		plp		            PLP
.1a3173	c2 30		rep #$30	            REP #$30
.1a3175	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3178	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a317b	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.1a317d	a9 2c 00	lda #$002c	                LDA #','
.1a3180	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a3183	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3186	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a3189	a5 23		lda $0823	                LDA ARGUMENT1
.1a318b	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.1a318d	a9 2c 00	lda #$002c	                LDA #','
.1a3190	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a3193	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3196	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a3199	a5 23		lda $0823	                LDA ARGUMENT1
.1a319b	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.1a319d	a9 2c 00	lda #$002c	                LDA #','
.1a31a0	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a31a3	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a31a6	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a31a9	a5 23		lda $0823	                LDA ARGUMENT1
.1a31ab	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.1a31ad	a9 2c 00	lda #$002c	                LDA #','
.1a31b0	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a31b3	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a31b6	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a31b9	a5 23		lda $0823	                LDA ARGUMENT1
.1a31bb	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.1a31bd	a9 2c 00	lda #$002c	                LDA #','
.1a31c0	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a31c3	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a31c6	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a31c9	a5 23		lda $0823	                LDA ARGUMENT1
.1a31cb	83 0b		sta $0b,s	                STA L_COLOR                 ; Save it to COLOR
.1a31cd	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.1a31cf	20 f5 2d	jsr $1a2df5	            JSR BITMAP_VRAM
.1a31d2	a9 07 00	lda #$0007	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_1D_2D
.1a31d5	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a31d9	c2 20		rep #$20	            REP #$20
.1a31db	a3 05		lda $05,s	                LDA L_Y0                    ; Get the row
.1a31dd	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.1a31e1	af 10 f0 1a	lda $1af010	                LDA @l GR_MAX_COLS
.1a31e5	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B         ; Multiply by the number of columns in the pixmap
.1a31e9	18		clc		                CLC                         ; Add the column
.1a31ea	af 04 01 00	lda $000104	                LDA @l M0_RESULT
.1a31ee	63 03		adc $03,s	                ADC L_X0
.1a31f0	85 0c		sta $080c	                STA SCRATCH
.1a31f2	e2 20		sep #$20	            SEP #$20
.1a31f4	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.1a31f8	69 00		adc #$00	                ADC #0
.1a31fa	85 0e		sta $080e	                STA SCRATCH+2
.1a31fc	c2 20		rep #$20	            REP #$20
.1a31fe	18		clc		                CLC                         ; Set the destination address
.1a31ff	a5 9e		lda $089e	                LDA MTEMPPTR
.1a3201	65 0c		adc $080c	                ADC SCRATCH
.1a3203	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.1a3207	e2 20		sep #$20	            SEP #$20
.1a3209	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.1a320b	65 0e		adc $080e	                ADC SCRATCH+2
.1a320d	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H
.1a3211	c2 20		rep #$20	            REP #$20
.1a3213	38		sec		                SEC                         ; Set the width of the FILL operation
.1a3214	a3 07		lda $07,s	                LDA L_X1
.1a3216	e3 03		sbc $03,s	                SBC L_X0
.1a3218	85 0c		sta $080c	                STA SCRATCH
.1a321a	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.1a321e	38		sec		                SEC
.1a321f	af 10 f0 1a	lda $1af010	                LDA @l GR_MAX_COLS
.1a3223	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L    ; And the destination stride
.1a3227	38		sec		                SEC                         ; Set the height of the FILL operation
.1a3228	a3 09		lda $09,s	                LDA L_Y1
.1a322a	e3 05		sbc $05,s	                SBC L_Y0
.1a322c	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.1a3230	e2 20		sep #$20	            SEP #$20
.1a3232	a3 0b		lda $0b,s	                LDA L_COLOR                 ; Set the color to write
.1a3234	8f 01 04 af	sta $af0401	                STA @l VDMA_BYTE_2_WRITE
.1a3238	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.1a323c	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF
.1a323e	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a3242	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.1a3246	30 fa		bmi $1a3242	                BMI wait
.1a3248	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.1a324a	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a324e					done
.1a324e	c2 20		rep #$20	            REP #$20
.1a3250	3b		tsc		            TSC
.1a3251	18		clc		            CLC
.1a3252	69 0c 00	adc #$000c	            ADC #SIZE(locals)
.1a3255	1b		tcs		            TCS
.1a3256	28		plp		                PLP
.1a3257	60		rts		            RTS
.1a3258					SPADDR
.1a3258	08		php		                PHP
.1a3259	c2 20		rep #$20	            REP #$20
.1a325b	c9 40 00	cmp #$0040	                CMP #SP_MAX
.1a325e	b0 13		bcs $1a3273	                BGE error
.1a3260	0a		asl a		                ASL A                       ; Multiply it by 8 (the size of s sprite block)
.1a3261	0a		asl a		                ASL A
.1a3262	0a		asl a		                ASL A
.1a3263	18		clc		                CLC                         ; Add it to the address of the first
.1a3264	69 00 0c	adc #$0c00	                ADC #<>SP00_CONTROL_REG     ; sprite block
.1a3267	85 9e		sta $089e	                STA MTEMPPTR
.1a3269	a9 af 00	lda #$00af	                LDA #`SP00_CONTROL_REG
.1a326c	69 00 00	adc #$0000	                ADC #0
.1a326f	85 a0		sta $08a0	                STA MTEMPPTR+2              ; And save that to MTEMPPTR
.1a3271	28		plp		                PLP
.1a3272	60		rts		            RTS
.1a3273					error
.1a3273	08		php		            PHP
.1a3274	c2 20		rep #$20	            REP #$20
.1a3276	48		pha		            PHA
.1a3277	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a327a	5b		tcd		            TCD
.1a327b	68		pla		            PLA
.1a327c	28		plp		            PLP
.1a327d	e2 20		sep #$20	            SEP #$20
.1a327f	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3281	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3285	c2 20		rep #$20	            REP #$20
.1a3287	29 ff 00	and #$00ff	            AND #$00FF
.1a328a	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a328d	e2 20		sep #$20	            SEP #$20
.1a328f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3292					S_SPRITE
.1a3292	08		php		                PHP
.1a3293					locals
>0001					L_SPRITE        .word ?
>0003					L_LUT           .byte ?
.1a3293	c2 20		rep #$20	            REP #$20
.1a3295	3b		tsc		            TSC
.1a3296	38		sec		            SEC
.1a3297	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.1a329a	1b		tcs		            TCS
.1a329b	c2 30		rep #$30	            REP #$30
.1a329d	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a32a0	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a32a3	a5 23		lda $0823	                LDA ARGUMENT1
.1a32a5	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.1a32a7	a9 2c 00	lda #$002c	                LDA #','
.1a32aa	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a32ad	e2 20		sep #$20	            SEP #$20
.1a32af	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a32b2	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a32b5	a5 23		lda $0823	                LDA ARGUMENT1
.1a32b7	c9 08		cmp #$08	                CMP #GR_MAX_LUT             ; Check that it's in range
.1a32b9	b0 56		bcs $1a3311	                BGE error                   ; If not: throw an error
.1a32bb	83 03		sta $03,s	                STA L_LUT                   ; Save it as lut
.1a32bd	a9 2c		lda #$2c	                LDA #','
.1a32bf	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a32c2	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a32c5	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a32c8	c2 20		rep #$20	            REP #$20
.1a32ca	38		sec		                SEC                         ; Adjust address to be in Vicky's space
.1a32cb	a5 23		lda $0823	                LDA ARGUMENT1
.1a32cd	e9 00 00	sbc #$0000	                SBC #<>VRAM
.1a32d0	85 23		sta $0823	                STA ARGUMENT1
.1a32d2	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a32d4	e9 b0 00	sbc #$00b0	                SBC #`VRAM
.1a32d7	85 25		sta $0825	                STA ARGUMENT1+2
.1a32d9	30 36		bmi $1a3311	                BMI error                   ; If negative, throw an error
.1a32db	c2 20		rep #$20	            REP #$20
.1a32dd	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a32df	aa		tax		                TAX
.1a32e0	20 58 32	jsr $1a3258	            JSR SPADDR
.1a32e3	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the lower word of the address
.1a32e5	a0 01 00	ldy #$0001	                LDY #SP_ADDR
.1a32e8	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a32ea	e2 20		sep #$20	            SEP #$20
.1a32ec	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a32ee	c8		iny		                INY
.1a32ef	c8		iny		                INY
.1a32f0	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save the upper byte of the address
.1a32f2	bf 18 f0 1a	lda $1af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the sprite control register
.1a32f6	29 f1		and #$f1	                AND #%11110001              ; Filter off the current LUT
.1a32f8	85 0c		sta $080c	                STA SCRATCH
.1a32fa	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT back
.1a32fc	0a		asl a		                ASL A                       ; Sift it into the LUT position
.1a32fd	29 0e		and #$0e	                AND #%00001110              ; Make sure we don't have anything wrong there
.1a32ff	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with what's in the sprite's control
.1a3301	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the register's bits
.1a3303	9f 18 f0 1a	sta $1af018,x	                STA @l GS_SP_CONTROL,X      ; And the shadow register
.1a3307					done
.1a3307	c2 20		rep #$20	            REP #$20
.1a3309	3b		tsc		            TSC
.1a330a	18		clc		            CLC
.1a330b	69 03 00	adc #$0003	            ADC #SIZE(locals)
.1a330e	1b		tcs		            TCS
.1a330f	28		plp		                PLP
.1a3310	60		rts		            RTS
.1a3311					error
.1a3311	08		php		            PHP
.1a3312	c2 20		rep #$20	            REP #$20
.1a3314	48		pha		            PHA
.1a3315	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3318	5b		tcd		            TCD
.1a3319	68		pla		            PLA
.1a331a	28		plp		            PLP
.1a331b	e2 20		sep #$20	            SEP #$20
.1a331d	a9 09		lda #$09	            LDA #ERR_RANGE
.1a331f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3323	c2 20		rep #$20	            REP #$20
.1a3325	29 ff 00	and #$00ff	            AND #$00FF
.1a3328	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a332b	e2 20		sep #$20	            SEP #$20
.1a332d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3330					S_SPRITEAT
.1a3330	08		php		                PHP
.1a3331					locals
>0001					L_SPRITE        .word ?
>0003					L_X             .word ?
.1a3331	c2 20		rep #$20	            REP #$20
.1a3333	3b		tsc		            TSC
.1a3334	38		sec		            SEC
.1a3335	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.1a3338	1b		tcs		            TCS
.1a3339	c2 30		rep #$30	            REP #$30
.1a333b	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a333e	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a3341	a5 23		lda $0823	                LDA ARGUMENT1
.1a3343	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.1a3345	a9 2c 00	lda #$002c	                LDA #','
.1a3348	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a334b	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a334e	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a3351	a5 23		lda $0823	                LDA ARGUMENT1
.1a3353	83 03		sta $03,s	                STA L_X                     ; Save it as X
.1a3355	a9 2c 00	lda #$002c	                LDA #','
.1a3358	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a335b	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a335e	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a3361	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a3363	20 58 32	jsr $1a3258	            JSR SPADDR
.1a3366	a3 03		lda $03,s	                LDA L_X                     ; Get the X coordinate
.1a3368	a0 04 00	ldy #$0004	                LDY #SP_X_COORD             ; Save the X coordinate for the sprite
.1a336b	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a336d	a5 23		lda $0823	                LDA ARGUMENT1
.1a336f	a0 06 00	ldy #$0006	                LDY #SP_Y_COORD             ; Save the Y coordinate for the sprite
.1a3372	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3374					done
.1a3374	c2 20		rep #$20	            REP #$20
.1a3376	3b		tsc		            TSC
.1a3377	18		clc		            CLC
.1a3378	69 04 00	adc #$0004	            ADC #SIZE(locals)
.1a337b	1b		tcs		            TCS
.1a337c	28		plp		                PLP
.1a337d	60		rts		            RTS
.1a337e					S_SPRITESHOW
.1a337e	08		php		                PHP
.1a337f					locals
>0001					L_SPRITE        .word ?
>0003					L_VISIBLE       .byte ?
.1a337f	c2 20		rep #$20	            REP #$20
.1a3381	3b		tsc		            TSC
.1a3382	38		sec		            SEC
.1a3383	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.1a3386	1b		tcs		            TCS
.1a3387	c2 30		rep #$30	            REP #$30
.1a3389	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a338c	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a338f	a5 23		lda $0823	                LDA ARGUMENT1
.1a3391	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.1a3393	a9 2c 00	lda #$002c	                LDA #','
.1a3396	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a3399	e2 20		sep #$20	            SEP #$20
.1a339b	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a339e	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a33a1	a5 23		lda $0823	                LDA ARGUMENT1
.1a33a3	d0 04		bne $1a33a9	                BNE is_visible
.1a33a5	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 0 (not visible)
.1a33a7	80 04		bra $1a33ad	                BRA chk_layer
.1a33a9	a9 01		lda #$01	is_visible      LDA #1
.1a33ab	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 1 (visible)
.1a33ad	a9 2c		lda #$2c	chk_layer       LDA #','
.1a33af	85 37		sta $0837	                STA TARGETTOK
.1a33b1	20 a9 21	jsr $1a21a9	            JSR OPT_TOK
.1a33b4	b0 20		bcs $1a33d6	                BCS get_layer               ; Yes: get the layer
.1a33b6					no_layer
.1a33b6	c2 30		rep #$30	            REP #$30
.1a33b8	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a33ba	aa		tax		                TAX
.1a33bb	20 58 32	jsr $1a3258	            JSR SPADDR
.1a33be	e2 20		sep #$20	            SEP #$20
.1a33c0	bf 18 f0 1a	lda $1af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.1a33c4	29 fe		and #$fe	                AND #$FE                    ; Filter out the enable bit
.1a33c6	85 0c		sta $080c	                STA SCRATCH
.1a33c8	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.1a33ca	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.1a33cc	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.1a33ce	9f 18 f0 1a	sta $1af018,x	                STA @l GS_SP_CONTROL,X      ; And save it
.1a33d2	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; ... and to Vicky
.1a33d4	80 36		bra $1a340c	                BRA done
.1a33d6					get_layer
.1a33d6	c2 30		rep #$30	            REP #$30
.1a33d8	20 67 20	jsr $1a2067	            JSR INCBIP
.1a33db	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a33de	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a33e1	a5 23		lda $0823	                LDA ARGUMENT1
.1a33e3	c9 08 00	cmp #$0008	                CMP #8                      ; Make sure it's in range
.1a33e6	b0 2e		bcs $1a3416	                BGE error                   ; If not, throw an out of range error
.1a33e8	0a		asl a		                ASL A                       ; If it's ok... shift it into position
.1a33e9	0a		asl a		                ASL A
.1a33ea	0a		asl a		                ASL A
.1a33eb	0a		asl a		                ASL A
.1a33ec	85 0c		sta $080c	                STA SCRATCH                 ; And save it in SCRATCH
.1a33ee	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a33f0	aa		tax		                TAX
.1a33f1	20 58 32	jsr $1a3258	            JSR SPADDR
.1a33f4	e2 20		sep #$20	            SEP #$20
.1a33f6	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.1a33f8	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.1a33fa	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.1a33fc	85 0c		sta $080c	                STA SCRATCH
.1a33fe	bf 18 f0 1a	lda $1af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.1a3402	29 8e		and #$8e	                AND #%10001110              ; Filter out the enable and layer bits
.1a3404	05 0c		ora $080c	                ORA SCRATCH                 ; Combine with the provided layer and enable
.1a3406	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the bits in Vicky
.1a3408	9f 18 f0 1a	sta $1af018,x	                STA @l GS_SP_CONTROL,X      ; And to the shadow registers
.1a340c					done
.1a340c	c2 20		rep #$20	            REP #$20
.1a340e	3b		tsc		            TSC
.1a340f	18		clc		            CLC
.1a3410	69 03 00	adc #$0003	            ADC #SIZE(locals)
.1a3413	1b		tcs		            TCS
.1a3414	28		plp		                PLP
.1a3415	60		rts		            RTS
.1a3416					error
.1a3416	08		php		            PHP
.1a3417	c2 20		rep #$20	            REP #$20
.1a3419	48		pha		            PHA
.1a341a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a341d	5b		tcd		            TCD
.1a341e	68		pla		            PLA
.1a341f	28		plp		            PLP
.1a3420	e2 20		sep #$20	            SEP #$20
.1a3422	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3424	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3428	c2 20		rep #$20	            REP #$20
.1a342a	29 ff 00	and #$00ff	            AND #$00FF
.1a342d	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a3430	e2 20		sep #$20	            SEP #$20
.1a3432	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3435					TILESET_ADDR
.1a3435	08		php		                PHP
.1a3436	c2 20		rep #$20	            REP #$20
.1a3438	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.1a343b	b0 19		bcs $1a3456	                BGE out_of_range            ; If not, throw a range error
.1a343d	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.1a3440	a9 04 00	lda #$0004	                LDA #TILESET_REG_SIZE       ; Multiply it by the number of bytes in a tile set register set
.1a3443	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.1a3446	18		clc		                CLC                         ; Add to TILESET0_ADDY_L to get the final address
.1a3447	ad 04 01	lda $0104	                LDA @w M0_RESULT
.1a344a	69 80 02	adc #$0280	                ADC #<>TILESET0_ADDY_L
.1a344d	85 9e		sta $089e	                STA MTEMPPTR
.1a344f	a9 af 00	lda #$00af	                LDA #`TILESET0_ADDY_L
.1a3452	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a3454	28		plp		                PLP
.1a3455	60		rts		            RTS
.1a3456					out_of_range
.1a3456	08		php		            PHP
.1a3457	c2 20		rep #$20	            REP #$20
.1a3459	48		pha		            PHA
.1a345a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a345d	5b		tcd		            TCD
.1a345e	68		pla		            PLA
.1a345f	28		plp		            PLP
.1a3460	e2 20		sep #$20	            SEP #$20
.1a3462	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3464	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3468	c2 20		rep #$20	            REP #$20
.1a346a	29 ff 00	and #$00ff	            AND #$00FF
.1a346d	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a3470	e2 20		sep #$20	            SEP #$20
.1a3472	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3475					TILEMAP_ADDR
.1a3475	08		php		                PHP
.1a3476	c2 20		rep #$20	            REP #$20
.1a3478	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.1a347b	b0 19		bcs $1a3496	                BGE out_of_range            ; If not, throw a range error
.1a347d	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.1a3480	a9 0c 00	lda #$000c	                LDA #TILEMAP_REG_SIZE       ; Multiply it by the number of bytes in a tile map register set
.1a3483	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.1a3486	18		clc		                CLC
.1a3487	ad 04 01	lda $0104	                LDA @w M0_RESULT            ; Add to TL0_CONTROL_REG to get the final address
.1a348a	69 00 02	adc #$0200	                ADC #<>TL0_CONTROL_REG
.1a348d	85 9e		sta $089e	                STA MTEMPPTR
.1a348f	a9 af 00	lda #$00af	                LDA #`TL0_CONTROL_REG
.1a3492	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a3494	28		plp		                PLP
.1a3495	60		rts		            RTS
.1a3496					out_of_range
.1a3496	08		php		            PHP
.1a3497	c2 20		rep #$20	            REP #$20
.1a3499	48		pha		            PHA
.1a349a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a349d	5b		tcd		            TCD
.1a349e	68		pla		            PLA
.1a349f	28		plp		            PLP
.1a34a0	e2 20		sep #$20	            SEP #$20
.1a34a2	a9 09		lda #$09	            LDA #ERR_RANGE
.1a34a4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a34a8	c2 20		rep #$20	            REP #$20
.1a34aa	29 ff 00	and #$00ff	            AND #$00FF
.1a34ad	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a34b0	e2 20		sep #$20	            SEP #$20
.1a34b2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a34b5					S_TILESET
.1a34b5	08		php		                PHP
.1a34b6					locals
>0001					L_TILENUM       .word ?
>0003					L_LUT           .word ?
>0005					L_IS_SQUARE     .word ?
.1a34b6	c2 20		rep #$20	            REP #$20
.1a34b8	3b		tsc		            TSC
.1a34b9	38		sec		            SEC
.1a34ba	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.1a34bd	1b		tcs		            TCS
.1a34be	c2 20		rep #$20	            REP #$20
.1a34c0	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a34c3	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a34c6	a5 23		lda $0823	                LDA ARGUMENT1
.1a34c8	83 01		sta $01,s	                STA L_TILENUM               ; Save it as the tile set/map number
.1a34ca	a9 2c 00	lda #$002c	                LDA #','
.1a34cd	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a34d0	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a34d3	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a34d6	a5 23		lda $0823	                LDA ARGUMENT1
.1a34d8	83 03		sta $03,s	                STA L_LUT                   ; Save it as LUT
.1a34da	a9 2c 00	lda #$002c	                LDA #','
.1a34dd	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a34e0	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a34e3	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a34e6	a5 23		lda $0823	                LDA ARGUMENT1
.1a34e8	83 05		sta $05,s	                STA L_IS_SQUARE             ; Save it as IS_SQUARE
.1a34ea	a9 2c 00	lda #$002c	                LDA #','
.1a34ed	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a34f0	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a34f3	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a34f6	a3 01		lda $01,s	                LDA L_TILENUM
.1a34f8	20 35 34	jsr $1a3435	            JSR TILESET_ADDR
.1a34fb	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the bitmap address - the address of the start of VRAM
.1a34fd	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And save it to the registers
.1a34ff	e2 20		sep #$20	            SEP #$20
.1a3501	38		sec		                SEC
.1a3502	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3504	e9 b0		sbc #$b0	                SBC #`VRAM
.1a3506	a0 02 00	ldy #$0002	                LDY #TILESET_ADDY_H
.1a3509	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a350b	a3 05		lda $05,s	                LDA L_IS_SQUARE             ; Check if is_square == 0?
.1a350d	d0 0d		bne $1a351c	                BNE is_square
.1a350f					not_square
.1a350f	e2 20		sep #$20	            SEP #$20
.1a3511	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.1a3513	29 07		and #$07	                AND #$07                    ; Force it to be in range
.1a3515	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.1a3518	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.1a351a	80 0d		bra $1a3529	                BRA done
.1a351c					is_square
.1a351c	e2 20		sep #$20	            SEP #$20
.1a351e	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.1a3520	29 07		and #$07	                AND #$07                    ; Force it to be in range
.1a3522	09 08		ora #$08	                ORA #TILESET_SQUARE_256     ; Turn on the 256x256 flag
.1a3524	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.1a3527	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.1a3529					done
.1a3529	c2 20		rep #$20	            REP #$20
.1a352b	3b		tsc		            TSC
.1a352c	18		clc		            CLC
.1a352d	69 06 00	adc #$0006	            ADC #SIZE(locals)
.1a3530	1b		tcs		            TCS
.1a3531	28		plp		                PLP
.1a3532	60		rts		            RTS
.1a3533					S_TILEMAP
.1a3533	08		php		                PHP
.1a3534					locals
>0001					L_TILENUM       .word ?
>0003					L_WIDTH         .word ?
>0005					L_HEIGHT        .word ?
.1a3534	c2 20		rep #$20	            REP #$20
.1a3536	3b		tsc		            TSC
.1a3537	38		sec		            SEC
.1a3538	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.1a353b	1b		tcs		            TCS
.1a353c	c2 20		rep #$20	            REP #$20
.1a353e	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3541	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a3544	a5 23		lda $0823	                LDA ARGUMENT1
.1a3546	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.1a3548	a9 2c 00	lda #$002c	                LDA #','
.1a354b	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a354e	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3551	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a3554	a5 23		lda $0823	                LDA ARGUMENT1
.1a3556	83 03		sta $03,s	                STA L_WIDTH                 ; Save it as WIDTH
.1a3558	a9 2c 00	lda #$002c	                LDA #','
.1a355b	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a355e	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3561	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a3564	a5 23		lda $0823	                LDA ARGUMENT1
.1a3566	83 05		sta $05,s	                STA L_HEIGHT                ; Save it as HEIGHT
.1a3568	a9 2c 00	lda #$002c	                LDA #','
.1a356b	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a356e	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3571	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a3574	a3 01		lda $01,s	                LDA L_TILENUM
.1a3576	20 75 34	jsr $1a3475	            JSR TILEMAP_ADDR
.1a3579	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the map address - the address of the start of VRAM
.1a357b	a0 01 00	ldy #$0001	                LDY #TILEMAP_START_ADDY
.1a357e	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; And save it to the registers
.1a3580	e2 20		sep #$20	            SEP #$20
.1a3582	38		sec		                SEC
.1a3583	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3585	e9 b0		sbc #$b0	                SBC #`VRAM
.1a3587	c8		iny		                INY
.1a3588	c8		iny		                INY
.1a3589	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a358b	c2 20		rep #$20	            REP #$20
.1a358d	a3 03		lda $03,s	                LDA L_WIDTH                 ; Set the width
.1a358f	a0 04 00	ldy #$0004	                LDY #TILEMAP_TOTAL_X
.1a3592	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3594	a3 05		lda $05,s	                LDA L_HEIGHT                ; Set the height
.1a3596	a0 06 00	ldy #$0006	                LDY #TILEMAP_TOTAL_Y
.1a3599	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a359b					done
.1a359b	c2 20		rep #$20	            REP #$20
.1a359d	3b		tsc		            TSC
.1a359e	18		clc		            CLC
.1a359f	69 06 00	adc #$0006	            ADC #SIZE(locals)
.1a35a2	1b		tcs		            TCS
.1a35a3	28		plp		                PLP
.1a35a4	60		rts		            RTS
.1a35a5					S_TILESHOW
.1a35a5	08		php		                PHP
.1a35a6					locals
>0001					L_TILENUM       .word ?
.1a35a6	c2 20		rep #$20	            REP #$20
.1a35a8	f4 00 00	pea #$0000	            PEA #0
.1a35ab	c2 20		rep #$20	            REP #$20
.1a35ad	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a35b0	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a35b3	a5 23		lda $0823	                LDA ARGUMENT1
.1a35b5	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.1a35b7	a9 2c 00	lda #$002c	                LDA #','
.1a35ba	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a35bd	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a35c0	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a35c3	a3 01		lda $01,s	                LDA L_TILENUM
.1a35c5	20 75 34	jsr $1a3475	            JSR TILEMAP_ADDR
.1a35c8	a5 23		lda $0823	                LDA ARGUMENT1               ; CHeck the visible parameter
.1a35ca	d0 06		bne $1a35d2	                BNE is_visible              ; If it's <> 0, make it visible
.1a35cc	e2 20		sep #$20	            SEP #$20
.1a35ce	a9 00		lda #$00	                LDA #0                      ; Control value for invisible
.1a35d0	80 04		bra $1a35d6	                BRA set_control
.1a35d2					is_visible
.1a35d2	e2 20		sep #$20	            SEP #$20
.1a35d4	a9 01		lda #$01	                LDA #TILEMAP_VISIBLE        ; Control value for visible
.1a35d6					set_control
.1a35d6	e2 20		sep #$20	            SEP #$20
.1a35d8	a0 00 00	ldy #$0000	                LDY #TILEMAP_CONTROL        ; Set the control register
.1a35db	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a35dd					done
.1a35dd	c2 20		rep #$20	            REP #$20
.1a35df	68		pla		            PLA
.1a35e0	28		plp		                PLP
.1a35e1	60		rts		            RTS
.1a35e2					S_TILEAT
.1a35e2	08		php		                PHP
.1a35e3					locals
>0001					L_TILENUM       .word ?
>0003					L_X             .word ?
.1a35e3	c2 20		rep #$20	            REP #$20
.1a35e5	3b		tsc		            TSC
.1a35e6	38		sec		            SEC
.1a35e7	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.1a35ea	1b		tcs		            TCS
.1a35eb	c2 20		rep #$20	            REP #$20
.1a35ed	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a35f0	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a35f3	a5 23		lda $0823	                LDA ARGUMENT1
.1a35f5	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.1a35f7	a9 2c 00	lda #$002c	                LDA #','
.1a35fa	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a35fd	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3600	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a3603	a5 23		lda $0823	                LDA ARGUMENT1
.1a3605	83 03		sta $03,s	                STA L_X                     ; Save as X
.1a3607	a9 2c 00	lda #$002c	                LDA #','
.1a360a	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a360d	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3610	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a3613	a3 01		lda $01,s	                LDA L_TILENUM
.1a3615	20 75 34	jsr $1a3475	            JSR TILEMAP_ADDR
.1a3618	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the Y position
.1a361a	a0 0a 00	ldy #$000a	                LDY #TILEMAP_WINDOW_Y
.1a361d	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a361f	a3 03		lda $03,s	                LDA L_X                     ; Set the X position
.1a3621	a0 08 00	ldy #$0008	                LDY #TILEMAP_WINDOW_X
.1a3624	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3626					done
.1a3626	c2 20		rep #$20	            REP #$20
.1a3628	3b		tsc		            TSC
.1a3629	18		clc		            CLC
.1a362a	69 04 00	adc #$0004	            ADC #SIZE(locals)
.1a362d	1b		tcs		            TCS
.1a362e	28		plp		                PLP
.1a362f	60		rts		            RTS
=0					DMA_LINEAR = 0                              ; Memory to copy is a continguous, linear range
=1					DMA_RECT = 1                                ; Memory to copy is a rectangular block
.0000					DMA_BLOCK
>0000					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>0001					ADDR            .long ?                     ; The starting address for the data to transfer
>0004					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>0007					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>0009					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>000b					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
=$01					DMA_SRC_2D = $01                            ; Source transfer should be 2D
=$02					DMA_DST_2D = $02                            ; Destination transfer should be 2D
=$10					DMA_SRC_SRAM = $10                          ; Flag indicating that the source is in SRAM ($00:0000 - $3F:FFFF)
=$20					DMA_DST_SRAM = $20                          ; Flag indicating that the destination is in SRAM ($00:0000 - $3F:FFFF)
>1af058					DMA_BLOCKS      .byte ?                     ; What blocks are involved
.1af059					DMA_SRC
>1af059					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>1af05a					ADDR            .long ?                     ; The starting address for the data to transfer
>1af05d					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>1af060					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>1af062					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>1af064					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.1af066					DMA_DEST
>1af066					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>1af067					ADDR            .long ?                     ; The starting address for the data to transfer
>1af06a					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>1af06d					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>1af06f					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>1af071					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.1a3630					DO_DMA
.1a3630	0b		phd		                PHD
.1a3631	08		php		                PHP
.1a3632	08		php		            PHP
.1a3633	c2 20		rep #$20	            REP #$20
.1a3635	48		pha		            PHA
.1a3636	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a3639	5b		tcd		            TCD
.1a363a	68		pla		            PLA
.1a363b	28		plp		            PLP
.1a363c	e2 20		sep #$20	            SEP #$20
.1a363e	a9 00		lda #$00	                LDA #0
.1a3640	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS           ; Set mode to something neutral
.1a3644	af 5c f0 1a	lda $1af05c	                LDA @l DMA_SRC.ADDR+2       ; Check the bank
.1a3648	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.1a364a	b0 1c		bcs $1a3668	                BGE src_vram                ; Yes: leave the DMA_BLOCK bit alone
.1a364c	8f 24 04 af	sta $af0424	src_sram        STA @l SDMA_SRC_ADDY_H      ; Set the SDMA source address
.1a3650	af 5b f0 1a	lda $1af05b	                LDA @l DMA_SRC.ADDR+1
.1a3654	8f 23 04 af	sta $af0423	                STA @l SDMA_SRC_ADDY_M
.1a3658	af 5a f0 1a	lda $1af05a	                LDA @l DMA_SRC.ADDR
.1a365c	8f 22 04 af	sta $af0422	                STA @l SDMA_SRC_ADDY_L
.1a3660	a9 10		lda #$10	                LDA #DMA_SRC_SRAM           ; Set the SRAM source block bit
.1a3662	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a3666	80 17		bra $1a367f	                BRA src_mode
.1a3668	38		sec		src_vram        SEC                         ; Convert to VRAM relative address
.1a3669	e9 b0		sbc #$b0	                SBC #`VRAM
.1a366b	8f 04 04 af	sta $af0404	                STA @l VDMA_SRC_ADDY_H      ; Set the VDMA source address
.1a366f	af 5b f0 1a	lda $1af05b	                LDA @l DMA_SRC.ADDR+1
.1a3673	8f 03 04 af	sta $af0403	                STA @l VDMA_SRC_ADDY_M
.1a3677	af 5a f0 1a	lda $1af05a	                LDA @l DMA_SRC.ADDR
.1a367b	8f 02 04 af	sta $af0402	                STA @l VDMA_SRC_ADDY_L
.1a367f	af 59 f0 1a	lda $1af059	src_mode        LDA @l DMA_SRC.MODE         ; Determine if source is 1D or 2D
.1a3683	d0 3c		bne $1a36c1	                BNE src_2d
.1a3685	af 58 f0 1a	lda $1af058	src_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.1a3689	f0 1b		beq $1a36a6	                BEQ src_1d_vram
.1a368b	af 5d f0 1a	lda $1af05d	src_1d_sram     LDA @l DMA_SRC.SIZE         ; It's SRAM, so set the SDMA size
.1a368f	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.1a3693	af 5e f0 1a	lda $1af05e	                LDA @l DMA_SRC.SIZE+1
.1a3697	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_M
.1a369b	af 5f f0 1a	lda $1af05f	                LDA @l DMA_SRC.SIZE+2
.1a369f	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.1a36a3	82 8b 00	brl $1a3731	                BRL set_dst                 ; Go to set up the destination
.1a36a6	af 5d f0 1a	lda $1af05d	src_1d_vram     LDA @l DMA_SRC.SIZE         ; It's VRAM, so set the VDMA size
.1a36aa	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.1a36ae	af 5e f0 1a	lda $1af05e	                LDA @l DMA_SRC.SIZE+1
.1a36b2	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_M
.1a36b6	af 5f f0 1a	lda $1af05f	                LDA @l DMA_SRC.SIZE+2
.1a36ba	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.1a36be	82 70 00	brl $1a3731	                BRL set_dst                 ; Go to set up the destination
.1a36c1	af 58 f0 1a	lda $1af058	src_2d          LDA @l DMA_BLOCKS
.1a36c5	09 01		ora #$01	                ORA #DMA_SRC_2D             ; Set the bit to make the source a 2D transfer
.1a36c7	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a36cb	89 10		bit #$10	                BIT #DMA_SRC_SRAM           ; Are we writing to SRAM
.1a36cd	f0 32		beq $1a3701	                BEQ src_2d_vram             ; No: set the 2d values in the VRAM source
.1a36cf	af 60 f0 1a	lda $1af060	src_2d_sram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.1a36d3	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.1a36d7	af 61 f0 1a	lda $1af061	                LDA @l DMA_SRC.WIDTH+1
.1a36db	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.1a36df	af 62 f0 1a	lda $1af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.1a36e3	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.1a36e7	af 63 f0 1a	lda $1af063	                LDA @l DMA_SRC.HEIGHT+1
.1a36eb	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.1a36ef	af 64 f0 1a	lda $1af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.1a36f3	8f 2c 04 af	sta $af042c	                STA @l SDMA_SRC_STRIDE_L
.1a36f7	af 65 f0 1a	lda $1af065	                LDA @l DMA_SRC.STRIDE+1
.1a36fb	8f 2d 04 af	sta $af042d	                STA @l SDMA_SRC_STRIDE_L+1
.1a36ff	80 30		bra $1a3731	                BRA set_dst
.1a3701	af 60 f0 1a	lda $1af060	src_2d_vram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.1a3705	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.1a3709	af 61 f0 1a	lda $1af061	                LDA @l DMA_SRC.WIDTH+1
.1a370d	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.1a3711	af 62 f0 1a	lda $1af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.1a3715	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.1a3719	af 63 f0 1a	lda $1af063	                LDA @l DMA_SRC.HEIGHT+1
.1a371d	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.1a3721	af 64 f0 1a	lda $1af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.1a3725	8f 0c 04 af	sta $af040c	                STA @l VDMA_SRC_STRIDE_L
.1a3729	af 65 f0 1a	lda $1af065	                LDA @l DMA_SRC.STRIDE+1
.1a372d	8f 0d 04 af	sta $af040d	                STA @l VDMA_SRC_STRIDE_L+1
.1a3731					set_dst
.1a3731	e2 20		sep #$20	            SEP #$20
.1a3733	af 69 f0 1a	lda $1af069	                LDA @l DMA_DEST.ADDR+2      ; Check the bank
.1a3737	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.1a3739	b0 20		bcs $1a375b	                BGE dst_vram                ; Yes: leave the DMA_BLOCK bit alone
.1a373b	8f 27 04 af	sta $af0427	dst_sram        STA @l SDMA_DST_ADDY_H      ; Set the SDMA destination address
.1a373f	af 68 f0 1a	lda $1af068	                LDA @l DMA_DEST.ADDR+1
.1a3743	8f 26 04 af	sta $af0426	                STA @l SDMA_DST_ADDY_M
.1a3747	af 67 f0 1a	lda $1af067	                LDA @l DMA_DEST.ADDR
.1a374b	8f 25 04 af	sta $af0425	                STA @l SDMA_DST_ADDY_L
.1a374f	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS
.1a3753	09 20		ora #$20	                ORA #DMA_DST_SRAM           ; Set the bit to indicate the destination is SRAM
.1a3755	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a3759	80 17		bra $1a3772	                BRA dst_mode
.1a375b	38		sec		dst_vram        SEC                         ; Convert to VRAM relative address
.1a375c	e9 b0		sbc #$b0	                SBC #`VRAM
.1a375e	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H      ; Set the VDMA destination address
.1a3762	af 68 f0 1a	lda $1af068	                LDA @l DMA_DEST.ADDR+1
.1a3766	8f 06 04 af	sta $af0406	                STA @l VDMA_DST_ADDY_M
.1a376a	af 67 f0 1a	lda $1af067	                LDA @l DMA_DEST.ADDR
.1a376e	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.1a3772	af 66 f0 1a	lda $1af066	dst_mode        LDA @l DMA_DEST.MODE
.1a3776	d0 3e		bne $1a37b6	                BNE dst_2d                  ; If 2D, set up the 2D destination parameters
.1a3778	af 58 f0 1a	lda $1af058	dst_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.1a377c	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Is the destination SRAM?
.1a377e	f0 1b		beq $1a379b	                BEQ dst_1d_vram
.1a3780	af 6a f0 1a	lda $1af06a	dst_1d_sram     LDA @l DMA_DEST.SIZE
.1a3784	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.1a3788	af 6b f0 1a	lda $1af06b	                LDA @l DMA_DEST.SIZE+1
.1a378c	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_L+1
.1a3790	af 6c f0 1a	lda $1af06c	                LDA @l DMA_DEST.SIZE+2
.1a3794	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.1a3798	82 8b 00	brl $1a3826	                BRL start_xfer
.1a379b	af 6a f0 1a	lda $1af06a	dst_1d_vram     LDA @l DMA_DEST.SIZE
.1a379f	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.1a37a3	af 6b f0 1a	lda $1af06b	                LDA @l DMA_DEST.SIZE+1
.1a37a7	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_L+1
.1a37ab	af 6c f0 1a	lda $1af06c	                LDA @l DMA_DEST.SIZE+2
.1a37af	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.1a37b3	82 70 00	brl $1a3826	                BRL start_xfer
.1a37b6	af 58 f0 1a	lda $1af058	dst_2d          LDA @l DMA_BLOCKS
.1a37ba	09 02		ora #$02	                ORA #DMA_DST_2D             ; Set the bit to make the source a 2D transfer
.1a37bc	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a37c0	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Are we writing to the SRAM?
.1a37c2	f0 32		beq $1a37f6	                BEQ dst_2d_vram             ; No: set the 2D parameters for VRAM
.1a37c4	af 6d f0 1a	lda $1af06d	dst_2d_sram     LDA @l DMA_DEST.WIDTH       ; Set the SRAM width
.1a37c8	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.1a37cc	af 6e f0 1a	lda $1af06e	                LDA @L DMA_DEST.WIDTH+1
.1a37d0	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.1a37d4	af 6f f0 1a	lda $1af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the SRAM height
.1a37d8	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.1a37dc	af 70 f0 1a	lda $1af070	                LDA @L DMA_DEST.HEIGHT+1
.1a37e0	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.1a37e4	af 71 f0 1a	lda $1af071	                LDA @l DMA_DEST.STRIDE      ; Set the SRAM stride
.1a37e8	8f 2e 04 af	sta $af042e	                STA @l SDMA_DST_STRIDE_L
.1a37ec	af 72 f0 1a	lda $1af072	                LDA @L DMA_DEST.STRIDE+1
.1a37f0	8f 2f 04 af	sta $af042f	                STA @l SDMA_DST_STRIDE_L+1
.1a37f4	80 30		bra $1a3826	                BRA start_xfer
.1a37f6	af 6d f0 1a	lda $1af06d	dst_2d_vram     LDA @l DMA_DEST.WIDTH       ; Set the VRAM width
.1a37fa	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.1a37fe	af 6e f0 1a	lda $1af06e	                LDA @L DMA_DEST.WIDTH+1
.1a3802	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.1a3806	af 6f f0 1a	lda $1af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the VRAM height
.1a380a	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.1a380e	af 70 f0 1a	lda $1af070	                LDA @L DMA_DEST.HEIGHT+1
.1a3812	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.1a3816	af 71 f0 1a	lda $1af071	                LDA @l DMA_DEST.STRIDE      ; Set the VRAM stride
.1a381a	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L
.1a381e	af 72 f0 1a	lda $1af072	                LDA @L DMA_DEST.STRIDE+1
.1a3822	8f 0f 04 af	sta $af040f	                STA @l VDMA_DST_STRIDE_L+1
.1a3826	af 58 f0 1a	lda $1af058	start_xfer      LDA @l DMA_BLOCKS
.1a382a	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.1a382c	f0 43		beq $1a3871	                BEQ start_vdma_only
.1a382e	c9 10		cmp #$10	                CMP #DMA_SRC_SRAM
.1a3830	f0 76		beq $1a38a8	                BEQ start_s2v
.1a3832	c9 20		cmp #$20	                CMP #DMA_DST_SRAM
.1a3834	d0 03		bne $1a3839	                BNE start_sdma_only
.1a3836	82 8a 00	brl $1a38c3	                BRL start_v2s
.1a3839					start_sdma_only
.1a3839	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.1a383d	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.1a383f	f0 23		beq $1a3864	                BEQ sdma_1d_only            ; Source and Destination 1D...
.1a3841	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.1a3843	f0 23		beq $1a3868	                BEQ sdma_2d_only            ; Source and Destination 2D
.1a3845	08		php		            PHP
.1a3846	c2 20		rep #$20	            REP #$20
.1a3848	48		pha		            PHA
.1a3849	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a384c	5b		tcd		            TCD
.1a384d	68		pla		            PLA
.1a384e	28		plp		            PLP
.1a384f	e2 20		sep #$20	            SEP #$20
.1a3851	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a3853	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3857	c2 20		rep #$20	            REP #$20
.1a3859	29 ff 00	and #$00ff	            AND #$00FF
.1a385c	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a385f	e2 20		sep #$20	            SEP #$20
.1a3861	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3864	a9 01		lda #$01	sdma_1d_only    LDA #SDMA_CTRL0_Enable      ; Set the bits for 1D, SRAM->SRAM
.1a3866	80 02		bra $1a386a	                BRA sdma_set_ctrl
.1a3868	a9 03		lda #$03	sdma_2d_only    LDA #SDMA_CTRL0_Enable | SDMA_CTRL0_1D_2D
.1a386a	8f 20 04 af	sta $af0420	sdma_set_ctrl   STA @l SDMA_CTRL_REG0
.1a386e	82 7d 00	brl $1a38ee	                BRL trig_sdma               ; And trigger the SDMA
.1a3871					start_vdma_only
.1a3871	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.1a3875	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.1a3877	f0 23		beq $1a389c	                BEQ vdma_1d_only            ; Source and Destination 1D...
.1a3879	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.1a387b	f0 23		beq $1a38a0	                BEQ vdma_2d_only            ; Source and Destination 2D...
.1a387d	08		php		            PHP
.1a387e	c2 20		rep #$20	            REP #$20
.1a3880	48		pha		            PHA
.1a3881	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3884	5b		tcd		            TCD
.1a3885	68		pla		            PLA
.1a3886	28		plp		            PLP
.1a3887	e2 20		sep #$20	            SEP #$20
.1a3889	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a388b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a388f	c2 20		rep #$20	            REP #$20
.1a3891	29 ff 00	and #$00ff	            AND #$00FF
.1a3894	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a3897	e2 20		sep #$20	            SEP #$20
.1a3899	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a389c	a9 01		lda #$01	vdma_1d_only    LDA #VDMA_CTRL_Enable       ; Set the bits for 1D, VRAM->VRAM
.1a389e	80 02		bra $1a38a2	                BRA vdma_set_ctrl
.1a38a0	a9 03		lda #$03	vdma_2d_only    LDA #VDMA_CTRL_Enable | VDMA_CTRL_1D_2D
.1a38a2	8f 00 04 af	sta $af0400	vdma_set_ctrl   STA @l VDMA_CONTROL_REG
.1a38a6	80 34		bra $1a38dc	                BRA trig_vdma               ; And trigger the VDMA
.1a38a8					start_s2v
.1a38a8	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.1a38ac	29 01		and #$01	                AND #DMA_SRC_2D
.1a38ae	0a		asl a		                ASL A
.1a38af	09 11		ora #$11	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Src
.1a38b1	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a38b5	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.1a38b9	29 02		and #$02	                AND #DMA_DST_2D
.1a38bb	09 11		ora #$11	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Src
.1a38bd	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a38c1	80 19		bra $1a38dc	                BRA trig_vdma               ; And trigger the VDMA
.1a38c3					start_v2s
.1a38c3	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.1a38c7	29 02		and #$02	                AND #DMA_DST_2D
.1a38c9	09 21		ora #$21	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Dst
.1a38cb	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a38cf	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.1a38d3	29 01		and #$01	                AND #DMA_SRC_2D
.1a38d5	0a		asl a		                ASL A
.1a38d6	09 21		ora #$21	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Dst
.1a38d8	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a38dc					trig_vdma
.1a38dc	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.1a38e0	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF    ; Trigger the VDMA
.1a38e2	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a38e6	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Check if we need SDMA
.1a38ea	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.1a38ec	f0 0f		beq $1a38fd	                BEQ wait_vdma               ; No: wait for VDMA to complete
.1a38ee					trig_sdma
.1a38ee	af 20 04 af	lda $af0420	                LDA @l SDMA_CTRL_REG0
.1a38f2	09 80		ora #$80	                ORA #SDMA_CTRL0_Start_TRF   ; Trigger the SDMA
.1a38f4	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a38f8	ea		nop		                NOP                         ; When the transfer is started the CPU will be put on Hold (RDYn)...
.1a38f9	ea		nop		                NOP                         ; Before it actually gets to stop it will execute a couple more instructions
.1a38fa	ea		nop		                NOP                         ; From that point on, the CPU is halted (keep that in mind)
.1a38fb	ea		nop		                NOP                         ; No IRQ will be processed either during that time
.1a38fc	ea		nop		                NOP
.1a38fd	af 01 04 af	lda $af0401	wait_vdma       LDA @l VDMA_STATUS_REG      ; Check the VDMA status
.1a3901	89 80		bit #$80	                BIT #VDMA_STAT_VDMA_IPS     ; If the transfer is still in process...
.1a3903	d0 f8		bne $1a38fd	                BNE wait_vdma               ; Wait until it stops.
.1a3905	a9 00		lda #$00	                LDA #$00                    ; Clear the TRF bits
.1a3907	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a390b	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a390f	28		plp		                PLP
.1a3910	2b		pld		                PLD
.1a3911	60		rts		            RTS
.1a3912					S_MEMCOPY
.1a3912	0b		phd		                PHD
.1a3913	08		php		                PHP
.1a3914	e2 20		sep #$20	            SEP #$20
.1a3916	c2 10		rep #$10	            REP #$10
.1a3918	a9 00		lda #$00	                LDA #0
.1a391a	a2 00 00	ldx #$0000	                LDX #0
.1a391d	8f 59 f0 1a	sta $1af059	clr_loop        STA @l DMA_SRC
.1a3921	e8		inx		                INX
.1a3922	e0 1a 00	cpx #$001a	                CPX #SIZE(DMA_BLOCK) * 2
.1a3925	d0 f6		bne $1a391d	                BNE clr_loop
.1a3927	20 c8 21	jsr $1a21c8	            JSR PEEK_TOK
.1a392a	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.1a392c	f0 23		beq $1a3951	                BEQ src_linear                      ; Yes: go to process a linear source
.1a392e	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.1a3930	f0 5e		beq $1a3990	                BEQ src_rect                        ; Yes: go to process a rectangular source
.1a3932					syntax_err
.1a3932	08		php		            PHP
.1a3933	c2 20		rep #$20	            REP #$20
.1a3935	48		pha		            PHA
.1a3936	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3939	5b		tcd		            TCD
.1a393a	68		pla		            PLA
.1a393b	28		plp		            PLP
.1a393c	e2 20		sep #$20	            SEP #$20
.1a393e	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3940	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3944	c2 20		rep #$20	            REP #$20
.1a3946	29 ff 00	and #$00ff	            AND #$00FF
.1a3949	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a394c	e2 20		sep #$20	            SEP #$20
.1a394e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3951					src_linear
.1a3951	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a3954	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3957	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a395a	c2 20		rep #$20	            REP #$20
.1a395c	a5 23		lda $0823	            LDA ARGUMENT1
.1a395e	8f 5a f0 1a	sta $1af05a	            STA DMA_SRC.ADDR
.1a3962	e2 20		sep #$20	            SEP #$20
.1a3964	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3966	8f 5c f0 1a	sta $1af05c	            STA DMA_SRC.ADDR+2
.1a396a	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a396c	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a396f	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3972	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a3975	c2 20		rep #$20	            REP #$20
.1a3977	a5 23		lda $0823	            LDA ARGUMENT1
.1a3979	8f 5d f0 1a	sta $1af05d	            STA DMA_SRC.SIZE
.1a397d	e2 20		sep #$20	            SEP #$20
.1a397f	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3981	8f 5f f0 1a	sta $1af05f	            STA DMA_SRC.SIZE+2
.1a3985	e2 20		sep #$20	            SEP #$20
.1a3987	a9 00		lda #$00	            LDA #<DMA_LINEAR
.1a3989	8f 59 f0 1a	sta $1af059	            STA DMA_SRC.MODE
.1a398d	82 74 00	brl $1a3a04	                BRL process_to
.1a3990					src_rect
.1a3990	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a3993	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3996	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a3999	c2 20		rep #$20	            REP #$20
.1a399b	a5 23		lda $0823	            LDA ARGUMENT1
.1a399d	8f 5a f0 1a	sta $1af05a	            STA DMA_SRC.ADDR
.1a39a1	e2 20		sep #$20	            SEP #$20
.1a39a3	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a39a5	8f 5c f0 1a	sta $1af05c	            STA DMA_SRC.ADDR+2
.1a39a9	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a39ab	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a39ae	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a39b1	20 5c 06	jsr $1a065c	            JSR ASS_ARG1_INT16
.1a39b4	c2 20		rep #$20	            REP #$20
.1a39b6	a5 23		lda $0823	            LDA ARGUMENT1
.1a39b8	8f 60 f0 1a	sta $1af060	            STA DMA_SRC.WIDTH
.1a39bc	8d 00 01	sta $0100	            STA M0_OPERAND_A
.1a39bf	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a39c2	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a39c5	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a39c8	20 5c 06	jsr $1a065c	            JSR ASS_ARG1_INT16
.1a39cb	c2 20		rep #$20	            REP #$20
.1a39cd	a5 23		lda $0823	            LDA ARGUMENT1
.1a39cf	8f 62 f0 1a	sta $1af062	            STA DMA_SRC.HEIGHT
.1a39d3	8d 02 01	sta $0102	            STA M0_OPERAND_B
.1a39d6	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a39d9	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a39dc	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a39df	20 5c 06	jsr $1a065c	            JSR ASS_ARG1_INT16
.1a39e2	c2 20		rep #$20	            REP #$20
.1a39e4	a5 23		lda $0823	            LDA ARGUMENT1
.1a39e6	8f 64 f0 1a	sta $1af064	            STA DMA_SRC.STRIDE
.1a39ea	c2 20		rep #$20	            REP #$20
.1a39ec	ad 04 01	lda $0104	            LDA M0_RESULT
.1a39ef	8f 5d f0 1a	sta $1af05d	            STA DMA_SRC.SIZE
.1a39f3	e2 20		sep #$20	            SEP #$20
.1a39f5	ad 06 01	lda $0106	            LDA M0_RESULT+2
.1a39f8	8f 5f f0 1a	sta $1af05f	            STA DMA_SRC.SIZE+2
.1a39fc	e2 20		sep #$20	            SEP #$20
.1a39fe	a9 01		lda #$01	            LDA #<DMA_RECT
.1a3a00	8f 59 f0 1a	sta $1af059	            STA DMA_SRC.MODE
.1a3a04					process_to
.1a3a04	e2 20		sep #$20	            SEP #$20
.1a3a06	a9 9c		lda #$9c	                LDA #TOK_TO
.1a3a08	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a3a0b	20 c8 21	jsr $1a21c8	            JSR PEEK_TOK
.1a3a0e	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.1a3a10	f0 23		beq $1a3a35	                BEQ dest_linear                     ; Yes: go to process a linear destination
.1a3a12	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.1a3a14	f0 5e		beq $1a3a74	                BEQ dest_rect                       ; Yes: go to process a rectangular source
.1a3a16					syntax_err2
.1a3a16	08		php		            PHP
.1a3a17	c2 20		rep #$20	            REP #$20
.1a3a19	48		pha		            PHA
.1a3a1a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3a1d	5b		tcd		            TCD
.1a3a1e	68		pla		            PLA
.1a3a1f	28		plp		            PLP
.1a3a20	e2 20		sep #$20	            SEP #$20
.1a3a22	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3a24	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3a28	c2 20		rep #$20	            REP #$20
.1a3a2a	29 ff 00	and #$00ff	            AND #$00FF
.1a3a2d	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a3a30	e2 20		sep #$20	            SEP #$20
.1a3a32	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3a35					dest_linear
.1a3a35	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a3a38	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3a3b	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a3a3e	c2 20		rep #$20	            REP #$20
.1a3a40	a5 23		lda $0823	            LDA ARGUMENT1
.1a3a42	8f 67 f0 1a	sta $1af067	            STA DMA_DEST.ADDR
.1a3a46	e2 20		sep #$20	            SEP #$20
.1a3a48	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3a4a	8f 69 f0 1a	sta $1af069	            STA DMA_DEST.ADDR+2
.1a3a4e	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a3a50	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a3a53	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3a56	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a3a59	c2 20		rep #$20	            REP #$20
.1a3a5b	a5 23		lda $0823	            LDA ARGUMENT1
.1a3a5d	8f 6a f0 1a	sta $1af06a	            STA DMA_DEST.SIZE
.1a3a61	e2 20		sep #$20	            SEP #$20
.1a3a63	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3a65	8f 6c f0 1a	sta $1af06c	            STA DMA_DEST.SIZE+2
.1a3a69	e2 20		sep #$20	            SEP #$20
.1a3a6b	a9 00		lda #$00	            LDA #<DMA_LINEAR
.1a3a6d	8f 66 f0 1a	sta $1af066	            STA DMA_DEST.MODE
.1a3a71	82 74 00	brl $1a3ae8	                BRL verify
.1a3a74					dest_rect
.1a3a74	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a3a77	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3a7a	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a3a7d	c2 20		rep #$20	            REP #$20
.1a3a7f	a5 23		lda $0823	            LDA ARGUMENT1
.1a3a81	8f 67 f0 1a	sta $1af067	            STA DMA_DEST.ADDR
.1a3a85	e2 20		sep #$20	            SEP #$20
.1a3a87	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3a89	8f 69 f0 1a	sta $1af069	            STA DMA_DEST.ADDR+2
.1a3a8d	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a3a8f	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a3a92	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3a95	20 5c 06	jsr $1a065c	            JSR ASS_ARG1_INT16
.1a3a98	c2 20		rep #$20	            REP #$20
.1a3a9a	a5 23		lda $0823	            LDA ARGUMENT1
.1a3a9c	8f 6d f0 1a	sta $1af06d	            STA DMA_DEST.WIDTH
.1a3aa0	8d 00 01	sta $0100	            STA M0_OPERAND_A
.1a3aa3	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a3aa6	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a3aa9	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3aac	20 5c 06	jsr $1a065c	            JSR ASS_ARG1_INT16
.1a3aaf	c2 20		rep #$20	            REP #$20
.1a3ab1	a5 23		lda $0823	            LDA ARGUMENT1
.1a3ab3	8f 6f f0 1a	sta $1af06f	            STA DMA_DEST.HEIGHT
.1a3ab7	8d 02 01	sta $0102	            STA M0_OPERAND_B
.1a3aba	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a3abd	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a3ac0	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3ac3	20 5c 06	jsr $1a065c	            JSR ASS_ARG1_INT16
.1a3ac6	c2 20		rep #$20	            REP #$20
.1a3ac8	a5 23		lda $0823	            LDA ARGUMENT1
.1a3aca	8f 71 f0 1a	sta $1af071	            STA DMA_DEST.STRIDE
.1a3ace	c2 20		rep #$20	            REP #$20
.1a3ad0	ad 04 01	lda $0104	            LDA M0_RESULT
.1a3ad3	8f 6a f0 1a	sta $1af06a	            STA DMA_DEST.SIZE
.1a3ad7	e2 20		sep #$20	            SEP #$20
.1a3ad9	ad 06 01	lda $0106	            LDA M0_RESULT+2
.1a3adc	8f 6c f0 1a	sta $1af06c	            STA DMA_DEST.SIZE+2
.1a3ae0	e2 20		sep #$20	            SEP #$20
.1a3ae2	a9 01		lda #$01	            LDA #<DMA_RECT
.1a3ae4	8f 66 f0 1a	sta $1af066	            STA DMA_DEST.MODE
.1a3ae8					verify
.1a3ae8	c2 20		rep #$20	            REP #$20
.1a3aea	af 5d f0 1a	lda $1af05d	                LDA @l DMA_SRC.SIZE
.1a3aee	cf 6a f0 1a	cmp $1af06a	                CMP @l DMA_DEST.SIZE
.1a3af2	d0 14		bne $1a3b08	                BNE size_err
.1a3af4	e2 20		sep #$20	            SEP #$20
.1a3af6	af 5f f0 1a	lda $1af05f	                LDA @l DMA_SRC.SIZE+2
.1a3afa	cf 6c f0 1a	cmp $1af06c	                CMP @l DMA_DEST.SIZE+2
.1a3afe	d0 08		bne $1a3b08	                BNE size_err
.1a3b00	c2 20		rep #$20	            REP #$20
.1a3b02	20 30 36	jsr $1a3630	            JSR DO_DMA
.1a3b05	28		plp		                PLP
.1a3b06	2b		pld		                PLD
.1a3b07	60		rts		            RTS
.1a3b08					size_err
.1a3b08	08		php		            PHP
.1a3b09	c2 20		rep #$20	            REP #$20
.1a3b0b	48		pha		            PHA
.1a3b0c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3b0f	5b		tcd		            TCD
.1a3b10	68		pla		            PLA
.1a3b11	28		plp		            PLP
.1a3b12	e2 20		sep #$20	            SEP #$20
.1a3b14	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a3b16	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3b1a	c2 20		rep #$20	            REP #$20
.1a3b1c	29 ff 00	and #$00ff	            AND #$00FF
.1a3b1f	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a3b22	e2 20		sep #$20	            SEP #$20
.1a3b24	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3b27					S_LOCATE
.1a3b27	08		php		                PHP
.1a3b28	c2 30		rep #$30	            REP #$30
.1a3b2a	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3b2d	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a3b30	a5 23		lda $0823	                LDA ARGUMENT1
.1a3b32	48		pha		                PHA                         ; Save it for later
.1a3b33	a9 2c 00	lda #$002c	                LDA #','                    ; Check for the comma separator
.1a3b36	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a3b39	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3b3c	20 b2 06	jsr $1a06b2	            JSR ASS_ARG1_BYTE
.1a3b3f	a4 23		ldy $0823	                LDY ARGUMENT1               ; Set Y to the row
.1a3b41	fa		plx		                PLX                         ; Set X to the column
.1a3b42	20 20 00	jsr $1a0020	            JSR CURSORXY
.1a3b45	28		plp		                PLP
.1a3b46	60		rts		            RTS

;******  Return to file: src\statements.s

.1a3b47					S_INPUT
.1a3b47	08		php		                PHP
.1a3b48					varloop
.1a3b48	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a3b4b	e2 20		sep #$20	            SEP #$20
.1a3b4d	a7 00		lda [$0800]	                LDA [BIP]
.1a3b4f	d0 03		bne $1a3b54	                BNE check_colon
.1a3b51	4c ef 3b	jmp $1a3bef	                JMP done            ; If EOL, we're done
.1a3b54	c9 3a		cmp #$3a	check_colon     CMP #':'
.1a3b56	d0 03		bne $1a3b5b	                BNE check_string
.1a3b58	4c ef 3b	jmp $1a3bef	                JMP done            ; If colon, we're done
.1a3b5b	c9 22		cmp #$22	check_string    CMP #CHAR_DQUOTE    ; Is it the start of a string?
.1a3b5d	d0 0b		bne $1a3b6a	                BNE check_var       ; No: then it should be a variable name
.1a3b5f	20 62 1b	jsr $1a1b62	            JSR EVALSTRING
.1a3b62	20 fd 44	jsr $1a44fd	            JSR PR_STRING
.1a3b65	a9 3b		lda #$3b	                LDA #';'            ; Look for a semicolon
.1a3b67	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a3b6a					check_var
.1a3b6a	20 31 04	jsr $1a0431	            JSR ISALPHA
.1a3b6d	90 44		bcc $1a3bb3	                BCC syntax_err      ; No: it's a syntax error
.1a3b6f	20 c2 52	jsr $1a52c2	            JSR VAR_FINDNAME
.1a3b72	90 3f		bcc $1a3bb3	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3b74	a9 3f		lda #$3f	                LDA #"?"            ; Print a "? " to follow
.1a3b76	20 18 00	jsr $1a0018	            JSR PRINTC
.1a3b79	a9 20		lda #$20	                LDA #CHAR_SP
.1a3b7b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a3b7e	20 10 00	jsr $1a0010	            JSR INPUTLINE
.1a3b81	e2 20		sep #$20	            SEP #$20
.1a3b83	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Check the type of the variable
.1a3b85	c9 02		cmp #$02	                CMP #TYPE_STRING    ; If it's a string...
.1a3b87	f0 49		beq $1a3bd2	                BEQ in_string       ; ... go to copy the string data
.1a3b89	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; If it's an integer...
.1a3b8b	d0 03		bne $1a3b90	                BNE chk_float
.1a3b8d	82 84 00	brl $1a3c14	                BRL in_integer      ; ... go to parse the integer
.1a3b90	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT     ; If it's a float...
.1a3b92	f0 5d		beq $1a3bf1	                BEQ in_float        ; ... go to parse the float
.1a3b94	08		php		            PHP
.1a3b95	c2 20		rep #$20	            REP #$20
.1a3b97	48		pha		            PHA
.1a3b98	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3b9b	5b		tcd		            TCD
.1a3b9c	68		pla		            PLA
.1a3b9d	28		plp		            PLP
.1a3b9e	e2 20		sep #$20	            SEP #$20
.1a3ba0	a9 04		lda #$04	            LDA #ERR_TYPE
.1a3ba2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3ba6	c2 20		rep #$20	            REP #$20
.1a3ba8	29 ff 00	and #$00ff	            AND #$00FF
.1a3bab	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a3bae	e2 20		sep #$20	            SEP #$20
.1a3bb0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3bb3					syntax_err
.1a3bb3	08		php		            PHP
.1a3bb4	c2 20		rep #$20	            REP #$20
.1a3bb6	48		pha		            PHA
.1a3bb7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3bba	5b		tcd		            TCD
.1a3bbb	68		pla		            PLA
.1a3bbc	28		plp		            PLP
.1a3bbd	e2 20		sep #$20	            SEP #$20
.1a3bbf	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3bc1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3bc5	c2 20		rep #$20	            REP #$20
.1a3bc7	29 ff 00	and #$00ff	            AND #$00FF
.1a3bca	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a3bcd	e2 20		sep #$20	            SEP #$20
.1a3bcf	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3bd2					in_string
.1a3bd2	c2 20		rep #$20	            REP #$20
.1a3bd4	a9 00 4c	lda #$4c00	                LDA #<>IOBUF
.1a3bd7	85 23		sta $0823	                STA ARGUMENT1
.1a3bd9	a9 00 00	lda #$0000	                LDA #`IOBUF
.1a3bdc	85 25		sta $0825	                STA ARGUMENT1+2
.1a3bde	e2 20		sep #$20	            SEP #$20
.1a3be0	a9 02		lda #$02	                LDA #TYPE_STRING
.1a3be2	85 27		sta $0827	                STA ARGTYPE1
.1a3be4					save_input
.1a3be4	c2 20		rep #$20	            REP #$20
.1a3be6	20 25 52	jsr $1a5225	            JSR VAR_SET
.1a3be9	a9 0d 00	lda #$000d	                LDA #CHAR_CR        ; Print a newline
.1a3bec	20 18 00	jsr $1a0018	            JSR PRINTC
.1a3bef	28		plp		done            PLP
.1a3bf0	60		rts		            RTS
.1a3bf1					in_float
.1a3bf1	c2 20		rep #$20	            REP #$20
.1a3bf3	a5 00		lda $0800	                LDA BIP             ; Save the BIP for later use
.1a3bf5	85 40		sta $0840	                STA SAVEBIP
.1a3bf7	a5 02		lda $0802	                LDA BIP+2
.1a3bf9	85 42		sta $0842	                STA SAVEBIP+2
.1a3bfb	a9 00 4c	lda #$4c00	                LDA #<>IOBUF        ; Point to the line that was just input
.1a3bfe	85 00		sta $0800	                STA BIP
.1a3c00	a9 00 00	lda #$0000	                LDA #`IOBUF
.1a3c03	85 02		sta $0802	                STA BIP+2
.1a3c05	20 e4 58	jsr $1a58e4	            JSR PARSENUM
.1a3c08	c2 20		rep #$20	            REP #$20
.1a3c0a	a5 40		lda $0840	                LDA SAVEBIP         ; Restore the BIP
.1a3c0c	85 00		sta $0800	                STA BIP
.1a3c0e	a5 42		lda $0842	                LDA SAVEBIP+2
.1a3c10	85 02		sta $0802	                STA BIP+2
.1a3c12	80 d0		bra $1a3be4	                BRA save_input
.1a3c14					in_integer
.1a3c14	c2 20		rep #$20	            REP #$20
.1a3c16	a5 00		lda $0800	                LDA BIP             ; Save the BIP for later use
.1a3c18	85 40		sta $0840	                STA SAVEBIP
.1a3c1a	a5 02		lda $0802	                LDA BIP+2
.1a3c1c	85 42		sta $0842	                STA SAVEBIP+2
.1a3c1e	a9 00 4c	lda #$4c00	                LDA #<>IOBUF        ; Point to the line that was just input
.1a3c21	85 00		sta $0800	                STA BIP
.1a3c23	a9 00 00	lda #$0000	                LDA #`IOBUF
.1a3c26	85 02		sta $0802	                STA BIP+2
.1a3c28	20 27 08	jsr $1a0827	            JSR PARSEINT
.1a3c2b	c2 20		rep #$20	            REP #$20
.1a3c2d	a5 40		lda $0840	                LDA SAVEBIP         ; Restore the BIP
.1a3c2f	85 00		sta $0800	                STA BIP
.1a3c31	a5 42		lda $0842	                LDA SAVEBIP+2
.1a3c33	85 02		sta $0802	                STA BIP+2
.1a3c35	80 ad		bra $1a3be4	                BRA save_input
.1a3c37					S_GET
.1a3c37	08		php		                PHP
.1a3c38					varloop
.1a3c38	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a3c3b	e2 20		sep #$20	            SEP #$20
.1a3c3d	a7 00		lda [$0800]	                LDA [BIP]
.1a3c3f	f0 47		beq $1a3c88	                BEQ done            ; If EOL, we're done
.1a3c41	c9 3a		cmp #$3a	                CMP #':'
.1a3c43	f0 43		beq $1a3c88	                BEQ done            ; If colon, we're done
.1a3c45	20 31 04	jsr $1a0431	            JSR ISALPHA
.1a3c48	90 40		bcc $1a3c8a	                BCC syntax_err      ; No: it's a syntax error
.1a3c4a	20 c2 52	jsr $1a52c2	            JSR VAR_FINDNAME
.1a3c4d	90 3b		bcc $1a3c8a	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3c4f	20 4b 14	jsr $1a144b	            JSR TEMPSTRING
.1a3c52	20 14 00	jsr $1a0014	            JSR GETKEY
.1a3c55	e2 20		sep #$20	            SEP #$20
.1a3c57	a0 00 00	ldy #$0000	                LDY #0
.1a3c5a	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a3c5c	a9 00		lda #$00	                LDA #0
.1a3c5e	c8		iny		                INY
.1a3c5f	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a3c61	c2 20		rep #$20	            REP #$20
.1a3c63	a5 16		lda $0816	                LDA STRPTR
.1a3c65	85 23		sta $0823	                STA ARGUMENT1
.1a3c67	a5 18		lda $0818	                LDA STRPTR+2
.1a3c69	85 25		sta $0825	                STA ARGUMENT1+2
.1a3c6b	e2 20		sep #$20	            SEP #$20
.1a3c6d	a9 02		lda #$02	                LDA #TYPE_STRING
.1a3c6f	85 27		sta $0827	                STA ARGTYPE1
.1a3c71	20 25 52	jsr $1a5225	            JSR VAR_SET
.1a3c74	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a3c77	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.1a3c79	f0 0d		beq $1a3c88	                BEQ done            ; EOL? We're done
.1a3c7b	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.1a3c7d	f0 09		beq $1a3c88	                BEQ done
.1a3c7f	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.1a3c81	d0 07		bne $1a3c8a	                BNE syntax_err      ; Nope: syntax error
.1a3c83	20 67 20	jsr $1a2067	            JSR INCBIP
.1a3c86	80 b0		bra $1a3c38	                BRA varloop
.1a3c88	28		plp		done            PLP
.1a3c89	60		rts		            RTS
.1a3c8a					syntax_err
.1a3c8a	08		php		            PHP
.1a3c8b	c2 20		rep #$20	            REP #$20
.1a3c8d	48		pha		            PHA
.1a3c8e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3c91	5b		tcd		            TCD
.1a3c92	68		pla		            PLA
.1a3c93	28		plp		            PLP
.1a3c94	e2 20		sep #$20	            SEP #$20
.1a3c96	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3c98	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3c9c	c2 20		rep #$20	            REP #$20
.1a3c9e	29 ff 00	and #$00ff	            AND #$00FF
.1a3ca1	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a3ca4	e2 20		sep #$20	            SEP #$20
.1a3ca6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3ca9					S_CALL
.1a3ca9	08		php		                PHP
.1a3caa	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3cad	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a3cb0	e2 20		sep #$20	            SEP #$20
.1a3cb2	a9 5c		lda #$5c	                LDA #$5C            ; Set the opcode for JML
.1a3cb4	85 a2		sta $08a2	                STA MJUMPINST
.1a3cb6	c2 20		rep #$20	            REP #$20
.1a3cb8	a5 23		lda $0823	                LDA ARGUMENT1
.1a3cba	85 a3		sta $08a3	                STA MJUMPADDR
.1a3cbc	e2 20		sep #$20	            SEP #$20
.1a3cbe	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3cc0	85 a5		sta $08a5	                STA MJUMPADDR+2
.1a3cc2	e2 20		sep #$20	            SEP #$20
.1a3cc4	a9 2c		lda #$2c	                LDA #','
.1a3cc6	85 37		sta $0837	                STA TARGETTOK
.1a3cc8	20 a9 21	jsr $1a21a9	            JSR OPT_TOK
.1a3ccb	90 41		bcc $1a3d0e	                BCC launch          ; Not present... go ahead and launch
.1a3ccd	20 67 20	jsr $1a2067	            JSR INCBIP
.1a3cd0	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3cd3	20 5c 06	jsr $1a065c	            JSR ASS_ARG1_INT16
.1a3cd6	c2 20		rep #$20	            REP #$20
.1a3cd8	a5 23		lda $0823	                LDA ARGUMENT1
.1a3cda	85 55		sta $0855	                STA MARG1           ; Save it to MARG1
.1a3cdc	e2 20		sep #$20	            SEP #$20
.1a3cde	a9 2c		lda #$2c	                LDA #','
.1a3ce0	85 37		sta $0837	                STA TARGETTOK
.1a3ce2	20 a9 21	jsr $1a21a9	            JSR OPT_TOK
.1a3ce5	90 27		bcc $1a3d0e	                BCC launch          ; Not present... go ahead and launch
.1a3ce7	20 67 20	jsr $1a2067	            JSR INCBIP
.1a3cea	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3ced	20 5c 06	jsr $1a065c	            JSR ASS_ARG1_INT16
.1a3cf0	c2 20		rep #$20	            REP #$20
.1a3cf2	a5 23		lda $0823	                LDA ARGUMENT1
.1a3cf4	85 59		sta $0859	                STA MARG2           ; Save it to MARG2
.1a3cf6	e2 20		sep #$20	            SEP #$20
.1a3cf8	a9 2c		lda #$2c	                LDA #','
.1a3cfa	85 37		sta $0837	                STA TARGETTOK
.1a3cfc	20 a9 21	jsr $1a21a9	            JSR OPT_TOK
.1a3cff	90 0d		bcc $1a3d0e	                BCC launch          ; Not present... go ahead and launch
.1a3d01	20 67 20	jsr $1a2067	            JSR INCBIP
.1a3d04	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3d07	20 5c 06	jsr $1a065c	            JSR ASS_ARG1_INT16
.1a3d0a	c2 20		rep #$20	            REP #$20
.1a3d0c	a4 23		ldy $0823	                LDY ARGUMENT1
.1a3d0e	a6 59		ldx $0859	launch          LDX MARG2
.1a3d10	a5 55		lda $0855	                LDA MARG1
.1a3d12	0b		phd		                PHD
.1a3d13	8b		phb		                PHB
.1a3d14	08		php		                PHP
.1a3d15	22 a2 08 00	jsl $0008a2	                JSL MJUMPINST       ; Call the subroutine indicated
.1a3d19	28		plp		                PLP
.1a3d1a	ab		plb		                PLB
.1a3d1b	2b		pld		                PLD
.1a3d1c	20 ac 20	jsr $1a20ac	            JSR SKIPSTMT
.1a3d1f	28		plp		                PLP
.1a3d20	60		rts		            RTS
.1a3d21					type_err
.1a3d21	08		php		            PHP
.1a3d22	c2 20		rep #$20	            REP #$20
.1a3d24	48		pha		            PHA
.1a3d25	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3d28	5b		tcd		            TCD
.1a3d29	68		pla		            PLA
.1a3d2a	28		plp		            PLP
.1a3d2b	e2 20		sep #$20	            SEP #$20
.1a3d2d	a9 04		lda #$04	            LDA #ERR_TYPE
.1a3d2f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3d33	c2 20		rep #$20	            REP #$20
.1a3d35	29 ff 00	and #$00ff	            AND #$00FF
.1a3d38	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a3d3b	e2 20		sep #$20	            SEP #$20
.1a3d3d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3d40					S_DIM
.1a3d40	08		php		                PHP
.1a3d41	e2 20		sep #$20	            SEP #$20
.1a3d43	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a3d46	20 c2 52	jsr $1a52c2	            JSR VAR_FINDNAME
.1a3d49	90 64		bcc $1a3daf	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3d4b	a9 8f		lda #$8f	                LDA #TOK_LPAREN     ; Verify we have a left parenthesis
.1a3d4d	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a3d50	a9 01		lda #$01	                LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.1a3d52	20 72 19	jsr $1a1972	            JSR PHOPERATOR
.1a3d55	a2 01 00	ldx #$0001	                LDX #1
.1a3d58	a9 00		lda #$00	                LDA #0
.1a3d5a	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF     ; Set the dimension count to 0
.1a3d5e					dim_loop
.1a3d5e	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3d61	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a3d64	c2 20		rep #$20	            REP #$20
.1a3d66	a5 23		lda $0823	                LDA ARGUMENT1
.1a3d68	9f 00 4d 00	sta $004d00,x	                STA @lARRIDXBUF,X   ; And store it in the buffer
.1a3d6c	e2 20		sep #$20	            SEP #$20
.1a3d6e	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF     ; Add to the dimension count
.1a3d72	1a		inc a		                INC A
.1a3d73	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF
.1a3d77	30 55		bmi $1a3dce	                BMI overflow        ; If > 127 throw an error
.1a3d79	e8		inx		                INX
.1a3d7a	e8		inx		                INX
.1a3d7b	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a3d7e	a7 00		lda [$0800]	                LDA [BIP]           ; Check the character
.1a3d80	c9 2c		cmp #$2c	                CMP #','            ; Is it a comma?
.1a3d82	f0 25		beq $1a3da9	                BEQ skip_comma      ; Yes: get the next dimension
.1a3d84	c9 90		cmp #$90	                CMP #TOK_RPAREN     ; No: is it a ")"?
.1a3d86	d0 27		bne $1a3daf	                BNE syntax_err      ; No: throw a syntax error
.1a3d88	20 67 20	jsr $1a2067	            JSR INCBIP
.1a3d8b	20 40 65	jsr $1a6540	            JSR ARR_ALLOC
.1a3d8e	c2 20		rep #$20	            REP #$20
.1a3d90	a5 c0		lda $08c0	                LDA CURRBLOCK       ; Set up the pointer to the array
.1a3d92	85 23		sta $0823	                STA ARGUMENT1
.1a3d94	e2 20		sep #$20	            SEP #$20
.1a3d96	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a3d98	85 25		sta $0825	                STA ARGUMENT1+2
.1a3d9a	64 26		stz $0826	                STZ ARGUMENT1+3
.1a3d9c	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Get the type of the values
.1a3d9e	09 80		ora #$80	                ORA #$80            ; Make sure we change the type to array
.1a3da0	85 ea		sta $08ea	                STA TOFINDTYPE      ; And save it back for searching
.1a3da2	85 27		sta $0827	                STA ARGTYPE1        ; And for the value to set
.1a3da4	20 25 52	jsr $1a5225	            JSR VAR_SET
.1a3da7	28		plp		                PLP
.1a3da8	60		rts		            RTS
.1a3da9					skip_comma
.1a3da9	20 67 20	jsr $1a2067	            JSR INCBIP
.1a3dac	4c 5e 3d	jmp $1a3d5e	                JMP dim_loop
.1a3daf					syntax_err
.1a3daf	08		php		            PHP
.1a3db0	c2 20		rep #$20	            REP #$20
.1a3db2	48		pha		            PHA
.1a3db3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3db6	5b		tcd		            TCD
.1a3db7	68		pla		            PLA
.1a3db8	28		plp		            PLP
.1a3db9	e2 20		sep #$20	            SEP #$20
.1a3dbb	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3dbd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3dc1	c2 20		rep #$20	            REP #$20
.1a3dc3	29 ff 00	and #$00ff	            AND #$00FF
.1a3dc6	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a3dc9	e2 20		sep #$20	            SEP #$20
.1a3dcb	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3dce					overflow
.1a3dce	08		php		            PHP
.1a3dcf	c2 20		rep #$20	            REP #$20
.1a3dd1	48		pha		            PHA
.1a3dd2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3dd5	5b		tcd		            TCD
.1a3dd6	68		pla		            PLA
.1a3dd7	28		plp		            PLP
.1a3dd8	e2 20		sep #$20	            SEP #$20
.1a3dda	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a3ddc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3de0	c2 20		rep #$20	            REP #$20
.1a3de2	29 ff 00	and #$00ff	            AND #$00FF
.1a3de5	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a3de8	e2 20		sep #$20	            SEP #$20
.1a3dea	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3ded					S_READ
.1a3ded	08		php		                PHP
.1a3dee					varloop
.1a3dee	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a3df1	e2 20		sep #$20	            SEP #$20
.1a3df3	a7 00		lda [$0800]	                LDA [BIP]
.1a3df5	f0 28		beq $1a3e1f	                BEQ done            ; If EOL, we're done
.1a3df7	c9 3a		cmp #$3a	                CMP #':'
.1a3df9	f0 24		beq $1a3e1f	                BEQ done            ; If colon, we're done
.1a3dfb	20 31 04	jsr $1a0431	            JSR ISALPHA
.1a3dfe	90 21		bcc $1a3e21	                BCC syntax_err      ; No: it's a syntax error
.1a3e00	20 c2 52	jsr $1a52c2	            JSR VAR_FINDNAME
.1a3e03	90 1c		bcc $1a3e21	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3e05	20 40 3e	jsr $1a3e40	            JSR NEXTDATA
.1a3e08	20 25 52	jsr $1a5225	            JSR VAR_SET
.1a3e0b	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a3e0e	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.1a3e10	f0 0d		beq $1a3e1f	                BEQ done            ; EOL? We're done
.1a3e12	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.1a3e14	f0 09		beq $1a3e1f	                BEQ done
.1a3e16	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.1a3e18	d0 07		bne $1a3e21	                BNE syntax_err      ; Nope: syntax error
.1a3e1a	20 67 20	jsr $1a2067	            JSR INCBIP
.1a3e1d	80 cf		bra $1a3dee	                BRA varloop
.1a3e1f	28		plp		done            PLP
.1a3e20	60		rts		            RTS
.1a3e21					syntax_err
.1a3e21	08		php		            PHP
.1a3e22	c2 20		rep #$20	            REP #$20
.1a3e24	48		pha		            PHA
.1a3e25	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3e28	5b		tcd		            TCD
.1a3e29	68		pla		            PLA
.1a3e2a	28		plp		            PLP
.1a3e2b	e2 20		sep #$20	            SEP #$20
.1a3e2d	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3e2f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3e33	c2 20		rep #$20	            REP #$20
.1a3e35	29 ff 00	and #$00ff	            AND #$00FF
.1a3e38	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a3e3b	e2 20		sep #$20	            SEP #$20
.1a3e3d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3e40					NEXTDATA
.1a3e40	08		php		                PHP
.1a3e41	a5 02		lda $0802	                LDA BIP+2           ; Save BIP
.1a3e43	85 42		sta $0842	                STA SAVEBIP+2
.1a3e45	a5 00		lda $0800	                LDA BIP
.1a3e47	85 40		sta $0840	                STA SAVEBIP
.1a3e49	a5 1c		lda $081c	                LDA CURLINE+2       ; Save CURLINE
.1a3e4b	85 46		sta $0846	                STA SAVELINE+2
.1a3e4d	a5 1a		lda $081a	                LDA CURLINE
.1a3e4f	85 44		sta $0844	                STA SAVELINE
.1a3e51	c2 20		rep #$20	            REP #$20
.1a3e53	a5 3a		lda $083a	                LDA DATABIP+2
.1a3e55	d0 04		bne $1a3e5b	                BNE data_set
.1a3e57	a5 38		lda $0838	                LDA DATABIP
.1a3e59	f0 4e		beq $1a3ea9	                BEQ scan_start      ; No: scan for a DATA statement
.1a3e5b	a5 38		lda $0838	data_set        LDA DATABIP         ; Move BIP to the DATA statement
.1a3e5d	85 00		sta $0800	                STA BIP
.1a3e5f	a5 3a		lda $083a	                LDA DATABIP+2
.1a3e61	85 02		sta $0802	                STA BIP+2
.1a3e63	a5 3c		lda $083c	                LDA DATALINE        ; Set CURLINE from DATALINE
.1a3e65	85 1a		sta $081a	                STA CURLINE
.1a3e67	a5 3e		lda $083e	                LDA DATALINE+2
.1a3e69	85 1c		sta $081c	                STA CURLINE+2
.1a3e6b	e2 20		sep #$20	            SEP #$20
.1a3e6d	a7 00		lda [$0800]	                LDA [BIP]           ; Check character at BIP
.1a3e6f	f0 53		beq $1a3ec4	                BEQ scan_DATA       ; EOL? scan for a DATA statement
.1a3e71	c9 3a		cmp #$3a	                CMP #':'            ; Colon?
.1a3e73	f0 4f		beq $1a3ec4	                BEQ scan_DATA       ; ... scan for a DATA statement
.1a3e75	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.1a3e77	d0 03		bne $1a3e7c	                BNE skip_parse      ; No: skip leading WS and try to parse
.1a3e79	20 67 20	jsr $1a2067	            JSR INCBIP
.1a3e7c					skip_parse
.1a3e7c	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a3e7f	a7 00		lda [$0800]	                LDA [BIP]
.1a3e81	c9 22		cmp #$22	                CMP #CHAR_DQUOTE    ; Is it a quote?
.1a3e83	f0 4e		beq $1a3ed3	                BEQ read_string     ; Yes: process the string
.1a3e85	20 4a 04	jsr $1a044a	            JSR ISNUMERAL
.1a3e88	b0 4e		bcs $1a3ed8	                BCS read_number     ; Yes: process the number
.1a3e8a					syntax_err
.1a3e8a	08		php		            PHP
.1a3e8b	c2 20		rep #$20	            REP #$20
.1a3e8d	48		pha		            PHA
.1a3e8e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3e91	5b		tcd		            TCD
.1a3e92	68		pla		            PLA
.1a3e93	28		plp		            PLP
.1a3e94	e2 20		sep #$20	            SEP #$20
.1a3e96	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3e98	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3e9c	c2 20		rep #$20	            REP #$20
.1a3e9e	29 ff 00	and #$00ff	            AND #$00FF
.1a3ea1	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a3ea4	e2 20		sep #$20	            SEP #$20
.1a3ea6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3ea9					scan_start
.1a3ea9	c2 20		rep #$20	            REP #$20
.1a3eab	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT    ; Point CURLINE to the first line
.1a3eae	85 1a		sta $081a	                STA CURLINE
.1a3eb0	a9 16 00	lda #$0016	                LDA #`BASIC_BOT
.1a3eb3	85 1c		sta $081c	                STA CURLINE+2
.1a3eb5	18		clc		                CLC
.1a3eb6	a5 1a		lda $081a	                LDA CURLINE         ; Point BIP to the first possible token
.1a3eb8	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.1a3ebb	85 00		sta $0800	                STA BIP
.1a3ebd	a5 1c		lda $081c	                LDA CURLINE+2
.1a3ebf	69 00 00	adc #$0000	                ADC #0
.1a3ec2	85 02		sta $0802	                STA BIP+2
.1a3ec4					scan_data
.1a3ec4	e2 20		sep #$20	            SEP #$20
.1a3ec6	a9 80		lda #$80	                LDA #$80            ; We don't want to process nesting
.1a3ec8	85 35		sta $0835	                STA SKIPNEST
.1a3eca	a9 ab		lda #$ab	                LDA #TOK_DATA       ; We're looking for a DATA token
.1a3ecc	85 37		sta $0837	                STA TARGETTOK
.1a3ece	20 be 20	jsr $1a20be	            JSR SKIPTOTOK
.1a3ed1	80 a9		bra $1a3e7c	                BRA skip_parse
.1a3ed3					read_string
.1a3ed3	20 62 1b	jsr $1a1b62	            JSR EVALSTRING
.1a3ed6	80 03		bra $1a3edb	                BRA done
.1a3ed8					read_number
.1a3ed8	20 54 1a	jsr $1a1a54	            JSR EVALNUMBER
.1a3edb					done
.1a3edb	c2 20		rep #$20	            REP #$20
.1a3edd	a5 00		lda $0800	                LDA BIP             ; Save BIP to DATABIP
.1a3edf	85 38		sta $0838	                STA DATABIP
.1a3ee1	a5 02		lda $0802	                LDA BIP+2
.1a3ee3	85 3a		sta $083a	                STA DATABIP+2
.1a3ee5	a5 1a		lda $081a	                LDA CURLINE         ; Save CURLINE to DATALINE
.1a3ee7	85 3c		sta $083c	                STA DATALINE
.1a3ee9	a5 1c		lda $081c	                LDA CURLINE+2
.1a3eeb	85 3e		sta $083e	                STA DATALINE+2
.1a3eed	a5 44		lda $0844	                LDA SAVELINE        ; Restore CURLINE
.1a3eef	85 1a		sta $081a	                STA CURLINE
.1a3ef1	a5 46		lda $0846	                LDA SAVELINE+2
.1a3ef3	85 1c		sta $081c	                STA CURLINE+2
.1a3ef5	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.1a3ef7	85 00		sta $0800	                STA BIP
.1a3ef9	a5 42		lda $0842	                LDA SAVEBIP+2
.1a3efb	85 02		sta $0802	                STA BIP+2
.1a3efd	28		plp		                PLP
.1a3efe	60		rts		            RTS
.1a3eff					S_DATA
.1a3eff	20 ac 20	jsr $1a20ac	            JSR SKIPSTMT
.1a3f02	60		rts		            RTS
.1a3f03					S_RESTORE
.1a3f03	64 38		stz $0838	                STZ DATABIP         ; Just set DATABIP to 0
.1a3f05	64 3a		stz $083a	                STZ DATABIP+2       ; The next READ will move it to the first DATA
.1a3f07	64 3c		stz $083c	                STZ DATALINE        ; Set DATALINE to 0
.1a3f09	64 3e		stz $083e	                STZ DATALINE+2
.1a3f0b	60		rts		            RTS
.1a3f0c					S_CLS
.1a3f0c	20 24 00	jsr $1a0024	            JSR CLSCREEN
.1a3f0f	60		rts		            RTS
.1a3f10					S_POKEL
.1a3f10	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3f13	c2 20		rep #$20	            REP #$20
.1a3f15	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.1a3f17	48		pha		                PHA
.1a3f18	a5 23		lda $0823	                LDA ARGUMENT1
.1a3f1a	48		pha		                PHA
.1a3f1b	e2 20		sep #$20	            SEP #$20
.1a3f1d	a7 00		lda [$0800]	                LDA [BIP]
.1a3f1f	c9 2c		cmp #$2c	                CMP #','
.1a3f21	d0 22		bne $1a3f45	                BNE syntax_err
.1a3f23	20 67 20	jsr $1a2067	            JSR INCBIP
.1a3f26	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3f29	c2 20		rep #$20	            REP #$20
.1a3f2b	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a3f2d	d0 35		bne $1a3f64	                BNE range_err
.1a3f2f	68		pla		                PLA                 ; Pull the target address from the stack
.1a3f30	85 08		sta $0808	                STA INDEX           ; and into INDEX
.1a3f32	68		pla		                PLA
.1a3f33	85 0a		sta $080a	                STA INDEX+2
.1a3f35	c2 20		rep #$20	            REP #$20
.1a3f37	a5 23		lda $0823	                LDA ARGUMENT1
.1a3f39	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.1a3f3b	e2 20		sep #$20	            SEP #$20
.1a3f3d	a0 02 00	ldy #$0002	                LDY #2
.1a3f40	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3f42	97 08		sta [$0808],y	                STA [INDEX],Y
.1a3f44	60		rts		            RTS
.1a3f45					syntax_err
.1a3f45	08		php		            PHP
.1a3f46	c2 20		rep #$20	            REP #$20
.1a3f48	48		pha		            PHA
.1a3f49	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3f4c	5b		tcd		            TCD
.1a3f4d	68		pla		            PLA
.1a3f4e	28		plp		            PLP
.1a3f4f	e2 20		sep #$20	            SEP #$20
.1a3f51	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3f53	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3f57	c2 20		rep #$20	            REP #$20
.1a3f59	29 ff 00	and #$00ff	            AND #$00FF
.1a3f5c	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a3f5f	e2 20		sep #$20	            SEP #$20
.1a3f61	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3f64					range_err
.1a3f64	08		php		            PHP
.1a3f65	c2 20		rep #$20	            REP #$20
.1a3f67	48		pha		            PHA
.1a3f68	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3f6b	5b		tcd		            TCD
.1a3f6c	68		pla		            PLA
.1a3f6d	28		plp		            PLP
.1a3f6e	e2 20		sep #$20	            SEP #$20
.1a3f70	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3f72	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3f76	c2 20		rep #$20	            REP #$20
.1a3f78	29 ff 00	and #$00ff	            AND #$00FF
.1a3f7b	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a3f7e	e2 20		sep #$20	            SEP #$20
.1a3f80	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3f83					S_POKEW
.1a3f83	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3f86	c2 20		rep #$20	            REP #$20
.1a3f88	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.1a3f8a	48		pha		                PHA
.1a3f8b	a5 23		lda $0823	                LDA ARGUMENT1
.1a3f8d	48		pha		                PHA
.1a3f8e	e2 20		sep #$20	            SEP #$20
.1a3f90	a7 00		lda [$0800]	                LDA [BIP]
.1a3f92	c9 2c		cmp #$2c	                CMP #','
.1a3f94	d0 19		bne $1a3faf	                BNE syntax_err
.1a3f96	20 67 20	jsr $1a2067	            JSR INCBIP
.1a3f99	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3f9c	c2 20		rep #$20	            REP #$20
.1a3f9e	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3fa0	d0 2c		bne $1a3fce	                BNE range_err
.1a3fa2	68		pla		                PLA                 ; Pull the target address from the stack
.1a3fa3	85 08		sta $0808	                STA INDEX           ; and into INDEX
.1a3fa5	68		pla		                PLA
.1a3fa6	85 0a		sta $080a	                STA INDEX+2
.1a3fa8	c2 20		rep #$20	            REP #$20
.1a3faa	a5 23		lda $0823	                LDA ARGUMENT1
.1a3fac	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.1a3fae	60		rts		            RTS
.1a3faf					syntax_err
.1a3faf	08		php		            PHP
.1a3fb0	c2 20		rep #$20	            REP #$20
.1a3fb2	48		pha		            PHA
.1a3fb3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3fb6	5b		tcd		            TCD
.1a3fb7	68		pla		            PLA
.1a3fb8	28		plp		            PLP
.1a3fb9	e2 20		sep #$20	            SEP #$20
.1a3fbb	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3fbd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3fc1	c2 20		rep #$20	            REP #$20
.1a3fc3	29 ff 00	and #$00ff	            AND #$00FF
.1a3fc6	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a3fc9	e2 20		sep #$20	            SEP #$20
.1a3fcb	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3fce					range_err
.1a3fce	08		php		            PHP
.1a3fcf	c2 20		rep #$20	            REP #$20
.1a3fd1	48		pha		            PHA
.1a3fd2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3fd5	5b		tcd		            TCD
.1a3fd6	68		pla		            PLA
.1a3fd7	28		plp		            PLP
.1a3fd8	e2 20		sep #$20	            SEP #$20
.1a3fda	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3fdc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3fe0	c2 20		rep #$20	            REP #$20
.1a3fe2	29 ff 00	and #$00ff	            AND #$00FF
.1a3fe5	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a3fe8	e2 20		sep #$20	            SEP #$20
.1a3fea	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3fed					S_POKE
.1a3fed	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a3ff0	c2 20		rep #$20	            REP #$20
.1a3ff2	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.1a3ff4	48		pha		                PHA
.1a3ff5	a5 23		lda $0823	                LDA ARGUMENT1
.1a3ff7	48		pha		                PHA
.1a3ff8	e2 20		sep #$20	            SEP #$20
.1a3ffa	a7 00		lda [$0800]	                LDA [BIP]
.1a3ffc	c9 2c		cmp #$2c	                CMP #','
.1a3ffe	d0 1f		bne $1a401f	                BNE syntax_err
.1a4000	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4003	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4006	e2 20		sep #$20	            SEP #$20
.1a4008	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Make sure the value is from 0 - 255
.1a400a	d0 32		bne $1a403e	                BNE range_err
.1a400c	c2 20		rep #$20	            REP #$20
.1a400e	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4010	d0 2c		bne $1a403e	                BNE range_err
.1a4012	68		pla		                PLA                 ; Pull the target address from the stack
.1a4013	85 08		sta $0808	                STA INDEX           ; and into INDEX
.1a4015	68		pla		                PLA
.1a4016	85 0a		sta $080a	                STA INDEX+2
.1a4018	e2 20		sep #$20	            SEP #$20
.1a401a	a5 23		lda $0823	                LDA ARGUMENT1
.1a401c	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.1a401e	60		rts		            RTS
.1a401f					syntax_err
.1a401f	08		php		            PHP
.1a4020	c2 20		rep #$20	            REP #$20
.1a4022	48		pha		            PHA
.1a4023	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4026	5b		tcd		            TCD
.1a4027	68		pla		            PLA
.1a4028	28		plp		            PLP
.1a4029	e2 20		sep #$20	            SEP #$20
.1a402b	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a402d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4031	c2 20		rep #$20	            REP #$20
.1a4033	29 ff 00	and #$00ff	            AND #$00FF
.1a4036	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4039	e2 20		sep #$20	            SEP #$20
.1a403b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a403e					range_err
.1a403e	08		php		            PHP
.1a403f	c2 20		rep #$20	            REP #$20
.1a4041	48		pha		            PHA
.1a4042	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4045	5b		tcd		            TCD
.1a4046	68		pla		            PLA
.1a4047	28		plp		            PLP
.1a4048	e2 20		sep #$20	            SEP #$20
.1a404a	a9 09		lda #$09	            LDA #ERR_RANGE
.1a404c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4050	c2 20		rep #$20	            REP #$20
.1a4052	29 ff 00	and #$00ff	            AND #$00FF
.1a4055	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4058	e2 20		sep #$20	            SEP #$20
.1a405a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a405d					S_STOP
.1a405d	08		php		            PHP
.1a405e	c2 20		rep #$20	            REP #$20
.1a4060	48		pha		            PHA
.1a4061	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4064	5b		tcd		            TCD
.1a4065	68		pla		            PLA
.1a4066	28		plp		            PLP
.1a4067	e2 20		sep #$20	            SEP #$20
.1a4069	a9 01		lda #$01	            LDA #ERR_BREAK
.1a406b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a406f	c2 20		rep #$20	            REP #$20
.1a4071	29 ff 00	and #$00ff	            AND #$00FF
.1a4074	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4077	e2 20		sep #$20	            SEP #$20
.1a4079	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a407c					S_REM
.1a407c	08		php		                PHP
.1a407d	e2 20		sep #$20	            SEP #$20
.1a407f	a7 00		lda [$0800]	rem_loop        LDA [BIP]
.1a4081	f0 05		beq $1a4088	                BEQ done
.1a4083	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4086	80 f7		bra $1a407f	                BRA rem_loop
.1a4088	28		plp		done            PLP
.1a4089	60		rts		            RTS
.1a408a					S_EXIT
.1a408a	08		php		                PHP
.1a408b	28		plp		                PLP
.1a408c	60		rts		            RTS
.1a408d					S_DO
.1a408d	08		php		                PHP
.1a408e	28		plp		                PLP
.1a408f	60		rts		            RTS
.0000					DO_RECORD
>0000					BIP             .dword  ?
>0004					CURLINE         .dword  ?
.1a4090					S_LOOP
.1a4090	08		php		                PHP
.1a4091	28		plp		                PLP
.1a4092	60		rts		            RTS
.1a4093					S_FOR
.1a4093	08		php		                PHP
.1a4094	c2 20		rep #$20	            REP #$20
.1a4096	a5 1c		lda $081c	                LDA CURLINE+2
.1a4098	20 6f 1d	jsr $1a1d6f	            JSR PHRETURN
.1a409b	a5 1a		lda $081a	                LDA CURLINE
.1a409d	20 6f 1d	jsr $1a1d6f	            JSR PHRETURN
.1a40a0	a5 02		lda $0802	                LDA BIP+2           ; Save current BIP
.1a40a2	48		pha		                PHA
.1a40a3	a5 00		lda $0800	                LDA BIP
.1a40a5	48		pha		                PHA
.1a40a6	20 ac 20	jsr $1a20ac	            JSR SKIPSTMT
.1a40a9	a5 02		lda $0802	                LDA BIP+2           ; Save the BIP for the next statement to the RETURN stack
.1a40ab	20 6f 1d	jsr $1a1d6f	            JSR PHRETURN
.1a40ae	a5 00		lda $0800	                LDA BIP
.1a40b0	20 6f 1d	jsr $1a1d6f	            JSR PHRETURN
.1a40b3	68		pla		                PLA                 ; Restore the original BIP
.1a40b4	85 00		sta $0800	                STA BIP
.1a40b6	68		pla		                PLA
.1a40b7	85 02		sta $0802	                STA BIP+2
.1a40b9	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a40bc					get_name
.1a40bc	20 c2 52	jsr $1a52c2	            JSR VAR_FINDNAME
.1a40bf	b0 1f		bcs $1a40e0	                BCS push_name       ; If we didn't find a name, thrown an error
.1a40c1	08		php		            PHP
.1a40c2	c2 20		rep #$20	            REP #$20
.1a40c4	48		pha		            PHA
.1a40c5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a40c8	5b		tcd		            TCD
.1a40c9	68		pla		            PLA
.1a40ca	28		plp		            PLP
.1a40cb	e2 20		sep #$20	            SEP #$20
.1a40cd	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a40cf	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a40d3	c2 20		rep #$20	            REP #$20
.1a40d5	29 ff 00	and #$00ff	            AND #$00FF
.1a40d8	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a40db	e2 20		sep #$20	            SEP #$20
.1a40dd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a40e0					push_name
.1a40e0	e2 20		sep #$20	            SEP #$20
.1a40e2	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; To the return stack
.1a40e4	20 86 1d	jsr $1a1d86	            JSR PHRETURNB
.1a40e7	a5 e9		lda $08e9	                LDA TOFIND+2
.1a40e9	20 86 1d	jsr $1a1d86	            JSR PHRETURNB
.1a40ec	c2 20		rep #$20	            REP #$20
.1a40ee	a5 e7		lda $08e7	                LDA TOFIND
.1a40f0	20 6f 1d	jsr $1a1d6f	            JSR PHRETURN
.1a40f3					else
.1a40f3	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a40f6	e2 20		sep #$20	            SEP #$20
.1a40f8	a7 00		lda [$0800]	                LDA [BIP]
.1a40fa	c9 8a		cmp #$8a	                CMP #TOK_EQ
.1a40fc	d0 6a		bne $1a4168	                BNE syntax_err      ; If not found: signal an syntax error
.1a40fe	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Verify type of variable
.1a4100	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; Is it integer?
.1a4102	f0 04		beq $1a4108	                BEQ process_initial ; Yes: it's ok
.1a4104	c9 01		cmp #$01	                CMP #TYPE_FLOAT     ; Is it floating point?
.1a4106	f0 00		beq $1a4108	                BEQ process_initial ; Yes: it's ok
.1a4108					process_initial
.1a4108	20 67 20	jsr $1a2067	            JSR INCBIP
.1a410b	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a410e	20 25 52	jsr $1a5225	            JSR VAR_SET
.1a4111	e2 20		sep #$20	            SEP #$20
.1a4113	a9 9c		lda #$9c	                LDA #TOK_TO         ; Expect the next token to be TO
.1a4115	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4118	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a411b	c2 20		rep #$20	            REP #$20
.1a411d	a5 27		lda $0827	                LDA ARGTYPE1
.1a411f	20 6f 1d	jsr $1a1d6f	            JSR PHRETURN
.1a4122	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4124	20 6f 1d	jsr $1a1d6f	            JSR PHRETURN
.1a4127	a5 23		lda $0823	                LDA ARGUMENT1
.1a4129	20 6f 1d	jsr $1a1d6f	            JSR PHRETURN
.1a412c	e2 20		sep #$20	            SEP #$20
.1a412e	a9 9d		lda #$9d	                LDA #TOK_STEP
.1a4130	85 37		sta $0837	                STA TARGETTOK
.1a4132	20 a9 21	jsr $1a21a9	            JSR OPT_TOK
.1a4135	90 1b		bcc $1a4152	                BCC default_inc     ; Not found: set a default increment of 1
.1a4137	20 67 20	jsr $1a2067	            JSR INCBIP
.1a413a	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a413d	e2 20		sep #$20	            SEP #$20
.1a413f	a5 27		lda $0827	                LDA ARGTYPE1        ; Push the result as the increment
.1a4141	20 6f 1d	jsr $1a1d6f	            JSR PHRETURN
.1a4144	c2 20		rep #$20	            REP #$20
.1a4146	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4148	20 6f 1d	jsr $1a1d6f	            JSR PHRETURN
.1a414b	a5 23		lda $0823	                LDA ARGUMENT1
.1a414d	20 6f 1d	jsr $1a1d6f	            JSR PHRETURN
.1a4150	80 14		bra $1a4166	                BRA done
.1a4152					default_inc
.1a4152	c2 20		rep #$20	            REP #$20
.1a4154	a9 00 00	lda #$0000	                LDA #TYPE_INTEGER
.1a4157	20 6f 1d	jsr $1a1d6f	            JSR PHRETURN
.1a415a	a9 00 00	lda #$0000	                LDA #0
.1a415d	20 6f 1d	jsr $1a1d6f	            JSR PHRETURN
.1a4160	a9 01 00	lda #$0001	                LDA #1
.1a4163	20 6f 1d	jsr $1a1d6f	            JSR PHRETURN
.1a4166	28		plp		done            PLP
.1a4167	60		rts		            RTS
.1a4168					syntax_err
.1a4168	08		php		            PHP
.1a4169	c2 20		rep #$20	            REP #$20
.1a416b	48		pha		            PHA
.1a416c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a416f	5b		tcd		            TCD
.1a4170	68		pla		            PLA
.1a4171	28		plp		            PLP
.1a4172	e2 20		sep #$20	            SEP #$20
.1a4174	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4176	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a417a	c2 20		rep #$20	            REP #$20
.1a417c	29 ff 00	and #$00ff	            AND #$00FF
.1a417f	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4182	e2 20		sep #$20	            SEP #$20
.1a4184	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.0000					FOR_RECORD
>0000					INCREMENT       .dword  ?
>0004					INCTYPE         .word   ?
>0006					FINAL           .dword  ?
>000a					FINALTYPE       .word   ?
>000c					VARIBLE         .dword  ?
>0010					VARTYPE         .word   ?
>0012					BIP             .dword  ?
>0016					CURLINE         .dword  ?
.1a4187					S_NEXT
.1a4187	08		php		                PHP
.1a4188	8b		phb		                PHB
.1a4189	08		php		            PHP
.1a418a	e2 20		sep #$20	            SEP #$20
.1a418c	48		pha		            PHA
.1a418d	a9 00		lda #$00	            LDA #0
.1a418f	48		pha		            PHA
.1a4190	ab		plb		            PLB
.1a4191	68		pla		            PLA
.1a4192	28		plp		            PLP
.1a4193	08		php		            PHP
.1a4194	c2 20		rep #$20	            REP #$20
.1a4196	48		pha		            PHA
.1a4197	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a419a	5b		tcd		            TCD
.1a419b	68		pla		            PLA
.1a419c	28		plp		            PLP
.1a419d	c2 30		rep #$30	            REP #$30
.1a419f	a4 33		ldy $0833	                LDY RETURNSP                    ; Y := pointer to first byte of the FOR record
.1a41a1	c8		iny		                INY                             ; RETURNSP points to the first free slot, so move up 2 bytes
.1a41a2	c8		iny		                INY
.1a41a3	c2 20		rep #$20	            REP #$20
.1a41a5	b9 0c 00	lda $000c,y	                LDA #FOR_RECORD.VARIBLE,B,Y     ; TOFIND := FOR_RECORD.VARIABLE
.1a41a8	85 e7		sta $08e7	                STA TOFIND
.1a41aa	b9 0e 00	lda $000e,y	                LDA #FOR_RECORD.VARIBLE+2,B,Y
.1a41ad	e2 20		sep #$20	            SEP #$20
.1a41af	85 e9		sta $08e9	                STA TOFIND+2
.1a41b1	b9 10 00	lda $0010,y	                LDA #FOR_RECORD.VARTYPE,B,Y
.1a41b4	85 ea		sta $08ea	                STA TOFINDTYPE
.1a41b6	c2 20		rep #$20	            REP #$20
.1a41b8	5a		phy		                PHY
.1a41b9	20 c3 50	jsr $1a50c3	            JSR VAR_REF
.1a41bc	7a		ply		                PLY
.1a41bd	c2 20		rep #$20	            REP #$20
.1a41bf	b9 00 00	lda $0000,y	                LDA #FOR_RECORD.INCREMENT,B,Y   ; ARGUMENT2 := FOR_RECORD.INCREMENT
.1a41c2	85 29		sta $0829	                STA ARGUMENT2
.1a41c4	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y
.1a41c7	85 2b		sta $082b	                STA ARGUMENT2+2
.1a41c9	e2 20		sep #$20	            SEP #$20
.1a41cb	b9 04 00	lda $0004,y	                LDA #FOR_RECORD.INCTYPE,B,Y
.1a41ce	85 2d		sta $082d	                STA ARGTYPE2
.1a41d0	c2 20		rep #$20	            REP #$20
.1a41d2	5a		phy		                PHY
.1a41d3	20 2d 27	jsr $1a272d	            JSR OP_PLUS
.1a41d6	20 25 52	jsr $1a5225	            JSR VAR_SET
.1a41d9	7a		ply		                PLY
.1a41da	c2 20		rep #$20	            REP #$20
.1a41dc	b9 06 00	lda $0006,y	                LDA #FOR_RECORD.FINAL,B,Y       ; ARGUMENT2 := FOR_RECORD.FINAL
.1a41df	85 29		sta $0829	                STA ARGUMENT2
.1a41e1	b9 08 00	lda $0008,y	                LDA #FOR_RECORD.FINAL+2,B,Y
.1a41e4	85 2b		sta $082b	                STA ARGUMENT2+2
.1a41e6	e2 20		sep #$20	            SEP #$20
.1a41e8	b9 0a 00	lda $000a,y	                LDA #FOR_RECORD.FINALTYPE,B,Y
.1a41eb	85 2d		sta $082d	                STA ARGTYPE2
.1a41ed	c2 20		rep #$20	            REP #$20
.1a41ef	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y ; Check the increment's sign
.1a41f2	30 0a		bmi $1a41fe	                BMI going_down
.1a41f4					going_up
.1a41f4	20 b6 29	jsr $1a29b6	            JSR OP_LTE
.1a41f7	20 69 05	jsr $1a0569	            JSR IS_ARG1_Z
.1a41fa	f0 28		beq $1a4224	                BEQ end_loop                    ; No: end the loop
.1a41fc	80 08		bra $1a4206	                BRA loop_back                   ; Yes: loop back
.1a41fe					going_down
.1a41fe	20 76 29	jsr $1a2976	            JSR OP_GTE
.1a4201	20 69 05	jsr $1a0569	            JSR IS_ARG1_Z
.1a4204	f0 1e		beq $1a4224	                BEQ end_loop                    ; No: end the loop
.1a4206					loop_back
.1a4206	c2 20		rep #$20	            REP #$20
.1a4208	b9 12 00	lda $0012,y	                LDA #FOR_RECORD.BIP,B,Y
.1a420b	85 00		sta $0800	                STA BIP
.1a420d	b9 14 00	lda $0014,y	                LDA #FOR_RECORD.BIP+2,B,Y
.1a4210	85 02		sta $0802	                STA BIP+2
.1a4212	b9 16 00	lda $0016,y	                LDA #FOR_RECORD.CURLINE,B,Y     ; CURLINE := FOR_RECORD.CURLINE
.1a4215	85 1a		sta $081a	                STA CURLINE
.1a4217	b9 18 00	lda $0018,y	                LDA #FOR_RECORD.CURLINE+2,B,Y
.1a421a	85 1c		sta $081c	                STA CURLINE+2
.1a421c	e2 20		sep #$20	            SEP #$20
.1a421e	a9 03		lda #$03	                LDA #EXEC_RETURN
.1a4220	85 dc		sta $08dc	                STA EXECACTION
.1a4222	80 17		bra $1a423b	                BRA done
.1a4224					end_loop
.1a4224	a2 23 08	ldx #$0823	                LDX #ARGUMENT1
.1a4227	20 33 19	jsr $1a1933	            JSR PLARGUMENT
.1a422a	c2 20		rep #$20	            REP #$20
.1a422c	18		clc		                CLC
.1a422d	a5 33		lda $0833	                LDA RETURNSP
.1a422f	69 1a 00	adc #$001a	                ADC #size(FOR_RECORD)           ; Move pointer by number of bytes in a FOR record
.1a4232	85 33		sta $0833	                STA RETURNSP
.1a4234	a5 35		lda $0835	                LDA RETURNSP+2
.1a4236	69 00 00	adc #$0000	                ADC #0
.1a4239	85 35		sta $0835	                STA RETURNSP+2
.1a423b	ab		plb		done            PLB
.1a423c	28		plp		                PLP
.1a423d	60		rts		            RTS
.1a423e					S_GOSUB
.1a423e	08		php		                PHP
.1a423f	a5 1a		lda $081a	                LDA CURLINE                 ; Save the current line for later
.1a4241	48		pha		                PHA
.1a4242	a5 1c		lda $081c	                LDA CURLINE+2
.1a4244	48		pha		                PHA
.1a4245	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a4248	20 27 08	jsr $1a0827	            JSR PARSEINT
.1a424b	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.1a424d	f0 26		beq $1a4275	                BEQ syntax_err              ; If 0, no number was found... syntax error
.1a424f	20 67 23	jsr $1a2367	            JSR FINDLINE
.1a4252	90 42		bcc $1a4296	                BCC not_found               ; If not found... LINE NOT FOUND error
.1a4254	e2 20		sep #$20	            SEP #$20
.1a4256	a9 02		lda #$02	                LDA #EXEC_GOTO
.1a4258	85 dc		sta $08dc	                STA EXECACTION
.1a425a	20 ac 20	jsr $1a20ac	            JSR SKIPSTMT
.1a425d	c2 20		rep #$20	            REP #$20
.1a425f	68		pla		                PLA                         ; Save the old value of CURLINE to the RETURN stack
.1a4260	20 6f 1d	jsr $1a1d6f	            JSR PHRETURN
.1a4263	68		pla		                PLA
.1a4264	20 6f 1d	jsr $1a1d6f	            JSR PHRETURN
.1a4267	a5 02		lda $0802	                LDA BIP+2                   ; Save the BASIC Instruction Pointer to the RETURN stack
.1a4269	20 6f 1d	jsr $1a1d6f	            JSR PHRETURN
.1a426c	a5 00		lda $0800	                LDA BIP
.1a426e	20 6f 1d	jsr $1a1d6f	            JSR PHRETURN
.1a4271	e6 31		inc $0831	                INC GOSUBDEPTH              ; Increase the count of GOSUBs on the stack
.1a4273	28		plp		                PLP
.1a4274	60		rts		            RTS
.1a4275	68		pla		syntax_err      PLA
.1a4276	68		pla		                PLA
.1a4277	08		php		            PHP
.1a4278	c2 20		rep #$20	            REP #$20
.1a427a	48		pha		            PHA
.1a427b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a427e	5b		tcd		            TCD
.1a427f	68		pla		            PLA
.1a4280	28		plp		            PLP
.1a4281	e2 20		sep #$20	            SEP #$20
.1a4283	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4285	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4289	c2 20		rep #$20	            REP #$20
.1a428b	29 ff 00	and #$00ff	            AND #$00FF
.1a428e	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4291	e2 20		sep #$20	            SEP #$20
.1a4293	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4296	68		pla		not_found       PLA
.1a4297	68		pla		                PLA
.1a4298	08		php		            PHP
.1a4299	c2 20		rep #$20	            REP #$20
.1a429b	48		pha		            PHA
.1a429c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a429f	5b		tcd		            TCD
.1a42a0	68		pla		            PLA
.1a42a1	28		plp		            PLP
.1a42a2	e2 20		sep #$20	            SEP #$20
.1a42a4	a9 06		lda #$06	            LDA #ERR_NOLINE
.1a42a6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a42aa	c2 20		rep #$20	            REP #$20
.1a42ac	29 ff 00	and #$00ff	            AND #$00FF
.1a42af	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a42b2	e2 20		sep #$20	            SEP #$20
.1a42b4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a42b7					S_RETURN
.1a42b7	08		php		                PHP
.1a42b8	c2 30		rep #$30	            REP #$30
.1a42ba	a5 31		lda $0831	                LDA GOSUBDEPTH              ; Check that there is at least on GOSUB on the stack
.1a42bc	f0 1e		beq $1a42dc	                BEQ underflow               ; No? It's a stack underflow error
.1a42be	20 91 1d	jsr $1a1d91	            JSR PLRETURN
.1a42c1	85 00		sta $0800	                STA BIP
.1a42c3	20 91 1d	jsr $1a1d91	            JSR PLRETURN
.1a42c6	85 02		sta $0802	                STA BIP+2
.1a42c8	20 91 1d	jsr $1a1d91	            JSR PLRETURN
.1a42cb	85 1a		sta $081a	                STA CURLINE
.1a42cd	20 91 1d	jsr $1a1d91	            JSR PLRETURN
.1a42d0	85 1c		sta $081c	                STA CURLINE+2
.1a42d2	c6 31		dec $0831	                DEC GOSUBDEPTH              ; Indicate we've popped that GOSUB off the stack
.1a42d4	e2 20		sep #$20	            SEP #$20
.1a42d6	a9 03		lda #$03	                LDA #EXEC_RETURN
.1a42d8	85 dc		sta $08dc	                STA EXECACTION
.1a42da	28		plp		                PLP
.1a42db	60		rts		            RTS
.1a42dc					underflow
.1a42dc	08		php		            PHP
.1a42dd	c2 20		rep #$20	            REP #$20
.1a42df	48		pha		            PHA
.1a42e0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a42e3	5b		tcd		            TCD
.1a42e4	68		pla		            PLA
.1a42e5	28		plp		            PLP
.1a42e6	e2 20		sep #$20	            SEP #$20
.1a42e8	a9 07		lda #$07	            LDA #ERR_STACKUNDER
.1a42ea	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a42ee	c2 20		rep #$20	            REP #$20
.1a42f0	29 ff 00	and #$00ff	            AND #$00FF
.1a42f3	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a42f6	e2 20		sep #$20	            SEP #$20
.1a42f8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a42fb					S_IF
.1a42fb	08		php		                PHP
.1a42fc	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a42ff	20 69 05	jsr $1a0569	            JSR IS_ARG1_Z
.1a4302	f0 1c		beq $1a4320	                BEQ is_false                ; If so, handle the FALSE case
.1a4304	e2 20		sep #$20	            SEP #$20
.1a4306	a9 97		lda #$97	                LDA #TOK_THEN               ; Verify that the next token is THEN and eat it
.1a4308	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a430b	20 27 08	jsr $1a0827	            JSR PARSEINT
.1a430e	20 69 05	jsr $1a0569	            JSR IS_ARG1_Z
.1a4311	f0 12		beq $1a4325	                BEQ syntax_err              ; If not, we have a syntax error
.1a4313	20 67 23	jsr $1a2367	            JSR FINDLINE
.1a4316	90 2c		bcc $1a4344	                BCC not_found               ; If not found... LINE NOT FOUND error
.1a4318	e2 20		sep #$20	            SEP #$20
.1a431a	a9 02		lda #$02	                LDA #EXEC_GOTO
.1a431c	85 dc		sta $08dc	                STA EXECACTION
.1a431e	80 03		bra $1a4323	                BRA done
.1a4320					is_false
.1a4320	20 ac 20	jsr $1a20ac	            JSR SKIPSTMT
.1a4323	28		plp		done            PLP
.1a4324	60		rts		            RTS
.1a4325					syntax_err
.1a4325	08		php		            PHP
.1a4326	c2 20		rep #$20	            REP #$20
.1a4328	48		pha		            PHA
.1a4329	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a432c	5b		tcd		            TCD
.1a432d	68		pla		            PLA
.1a432e	28		plp		            PLP
.1a432f	e2 20		sep #$20	            SEP #$20
.1a4331	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4333	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4337	c2 20		rep #$20	            REP #$20
.1a4339	29 ff 00	and #$00ff	            AND #$00FF
.1a433c	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a433f	e2 20		sep #$20	            SEP #$20
.1a4341	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4344					not_found
.1a4344	08		php		            PHP
.1a4345	c2 20		rep #$20	            REP #$20
.1a4347	48		pha		            PHA
.1a4348	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a434b	5b		tcd		            TCD
.1a434c	68		pla		            PLA
.1a434d	28		plp		            PLP
.1a434e	e2 20		sep #$20	            SEP #$20
.1a4350	a9 06		lda #$06	            LDA #ERR_NOLINE
.1a4352	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4356	c2 20		rep #$20	            REP #$20
.1a4358	29 ff 00	and #$00ff	            AND #$00FF
.1a435b	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a435e	e2 20		sep #$20	            SEP #$20
.1a4360	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4363					S_END
.1a4363	08		php		                PHP
.1a4364	e2 20		sep #$20	            SEP #$20
.1a4366	a9 01		lda #$01	                LDA #EXEC_STOP
.1a4368	85 dc		sta $08dc	                STA EXECACTION
.1a436a	28		plp		                PLP
.1a436b	60		rts		            RTS
.1a436c					S_GOTO
.1a436c	08		php		                PHP
.1a436d	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a4370	20 27 08	jsr $1a0827	            JSR PARSEINT
.1a4373	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.1a4375	f0 0d		beq $1a4384	                BEQ syntax_err              ; If 0, no number was found... syntax error
.1a4377	20 67 23	jsr $1a2367	            JSR FINDLINE
.1a437a	90 27		bcc $1a43a3	                BCC not_found               ; If not found... LINE NOT FOUND error
.1a437c	e2 20		sep #$20	            SEP #$20
.1a437e	a9 02		lda #$02	                LDA #EXEC_GOTO
.1a4380	85 dc		sta $08dc	                STA EXECACTION
.1a4382	28		plp		                PLP
.1a4383	60		rts		            RTS
.1a4384					syntax_err
.1a4384	08		php		            PHP
.1a4385	c2 20		rep #$20	            REP #$20
.1a4387	48		pha		            PHA
.1a4388	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a438b	5b		tcd		            TCD
.1a438c	68		pla		            PLA
.1a438d	28		plp		            PLP
.1a438e	e2 20		sep #$20	            SEP #$20
.1a4390	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4392	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4396	c2 20		rep #$20	            REP #$20
.1a4398	29 ff 00	and #$00ff	            AND #$00FF
.1a439b	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a439e	e2 20		sep #$20	            SEP #$20
.1a43a0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a43a3					not_found
.1a43a3	08		php		            PHP
.1a43a4	c2 20		rep #$20	            REP #$20
.1a43a6	48		pha		            PHA
.1a43a7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a43aa	5b		tcd		            TCD
.1a43ab	68		pla		            PLA
.1a43ac	28		plp		            PLP
.1a43ad	e2 20		sep #$20	            SEP #$20
.1a43af	a9 06		lda #$06	            LDA #ERR_NOLINE
.1a43b1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a43b5	c2 20		rep #$20	            REP #$20
.1a43b7	29 ff 00	and #$00ff	            AND #$00FF
.1a43ba	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a43bd	e2 20		sep #$20	            SEP #$20
.1a43bf	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a43c2					S_CLR
.1a43c2	20 d5 18	jsr $1a18d5	            JSR INITEVALSP
.1a43c5	20 f5 0f	jsr $1a0ff5	            JSR INITHEAP
.1a43c8	20 c2 4f	jsr $1a4fc2	            JSR INITVARS
.1a43cb	60		rts		            RTS
.1a43cc					S_LET
.1a43cc	08		php		                PHP
.1a43cd	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.1a43cf	10 03		bpl $1a43d4	                BPL get_name        ; If it's not a token, try to find the variable name
.1a43d1	20 67 20	jsr $1a2067	            JSR INCBIP
.1a43d4					get_name
.1a43d4	20 c2 52	jsr $1a52c2	            JSR VAR_FINDNAME
.1a43d7	b0 03		bcs $1a43dc	                BCS check_array     ; If we didn't find a name, thrown an error
.1a43d9	4c 43 44	jmp $1a4443	                JMP syntax_err
.1a43dc					check_array
.1a43dc	e2 20		sep #$20	            SEP #$20
.1a43de	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Save the variable name for later
.1a43e0	48		pha		                PHA                 ; (it will get over-written by variable references)
.1a43e1	a5 e9		lda $08e9	                LDA TOFIND+2
.1a43e3	48		pha		                PHA
.1a43e4	a5 e8		lda $08e8	                LDA TOFIND+1
.1a43e6	48		pha		                PHA
.1a43e7	a5 e7		lda $08e7	                LDA TOFIND
.1a43e9	48		pha		                PHA
.1a43ea	20 c8 21	jsr $1a21c8	            JSR PEEK_TOK
.1a43ed	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it a "("
.1a43ef	d0 0e		bne $1a43ff	                BNE get_value       ; No: it's a scalar assignment, look for the "="
.1a43f1	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a43f3	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a43f6	a9 00		lda #$00	                LDA #0
.1a43f8	8f 00 4d 00	sta $004d00	                STA @l ARRIDXBUF    ; Blank out the array index buffer
.1a43fc	20 57 1a	jsr $1a1a57	            JSR ARR_GETIDX
.1a43ff					get_value
.1a43ff	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a4402	e2 20		sep #$20	            SEP #$20
.1a4404	a7 00		lda [$0800]	                LDA [BIP]
.1a4406	c9 8a		cmp #$8a	                CMP #TOK_EQ
.1a4408	f0 03		beq $1a440d	                BEQ found_eq        ; If not found: signal an syntax error
.1a440a	4c 43 44	jmp $1a4443	                JMP syntax_err
.1a440d					found_eq
.1a440d	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4410	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4413	68		pla		                PLA                 ; Restore the variable name
.1a4414	85 e7		sta $08e7	                STA TOFIND
.1a4416	68		pla		                PLA
.1a4417	85 e8		sta $08e8	                STA TOFIND+1
.1a4419	68		pla		                PLA
.1a441a	85 e9		sta $08e9	                STA TOFIND+2
.1a441c	68		pla		                PLA
.1a441d	85 ea		sta $08ea	                STA TOFINDTYPE
.1a441f	29 80		and #$80	                AND #$80            ; Is it an array we're setting?
.1a4421	f0 1b		beq $1a443e	                BEQ set_scalar      ; No: do a scalar variable set
.1a4423	20 35 50	jsr $1a5035	            JSR VAR_FIND
.1a4426	90 3a		bcc $1a4462	                BCC notfound_err
.1a4428	c2 20		rep #$20	            REP #$20
.1a442a	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.1a442d	b7 08		lda [$0808],y	                LDA [INDEX],Y       ; Save the pointer to the array to CURRBLOCK
.1a442f	85 c0		sta $08c0	                STA CURRBLOCK
.1a4431	e2 20		sep #$20	            SEP #$20
.1a4433	c8		iny		                INY
.1a4434	c8		iny		                INY
.1a4435	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a4437	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a4439	20 2c 67	jsr $1a672c	            JSR ARR_SET
.1a443c	80 03		bra $1a4441	                BRA done            ; and we're finished!
.1a443e					set_scalar
.1a443e	20 25 52	jsr $1a5225	            JSR VAR_SET
.1a4441					done
.1a4441	28		plp		                PLP
.1a4442	60		rts		            RTS
.1a4443					syntax_err
.1a4443	08		php		            PHP
.1a4444	c2 20		rep #$20	            REP #$20
.1a4446	48		pha		            PHA
.1a4447	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a444a	5b		tcd		            TCD
.1a444b	68		pla		            PLA
.1a444c	28		plp		            PLP
.1a444d	e2 20		sep #$20	            SEP #$20
.1a444f	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4451	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4455	c2 20		rep #$20	            REP #$20
.1a4457	29 ff 00	and #$00ff	            AND #$00FF
.1a445a	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a445d	e2 20		sep #$20	            SEP #$20
.1a445f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4462					notfound_err
.1a4462	08		php		            PHP
.1a4463	c2 20		rep #$20	            REP #$20
.1a4465	48		pha		            PHA
.1a4466	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4469	5b		tcd		            TCD
.1a446a	68		pla		            PLA
.1a446b	28		plp		            PLP
.1a446c	e2 20		sep #$20	            SEP #$20
.1a446e	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a4470	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4474	c2 20		rep #$20	            REP #$20
.1a4476	29 ff 00	and #$00ff	            AND #$00FF
.1a4479	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a447c	e2 20		sep #$20	            SEP #$20
.1a447e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4481					S_PRINT
.1a4481	08		php		                PHP
.1a4482	e2 20		sep #$20	            SEP #$20
.1a4484	20 c8 21	jsr $1a21c8	            JSR PEEK_TOK
.1a4487	c9 00		cmp #$00	                CMP #0              ; Is it EOL or :?
.1a4489	f0 6d		beq $1a44f8	                BEQ pr_nl_exit      ; Yes: just print return
.1a448b					pr_loop
.1a448b	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a448e	e2 20		sep #$20	            SEP #$20
.1a4490	a5 27		lda $0827	                LDA ARGTYPE1        ; Get the type of the result
.1a4492	c9 ff		cmp #$ff	                CMP #TYPE_NAV       ; Is is NAV?
.1a4494	f0 1b		beq $1a44b1	                BEQ check_nl        ; Yes: we are probably just printing a newline
.1a4496	c9 02		cmp #$02	                CMP #TYPE_STRING    ; Is it a string?
.1a4498	d0 05		bne $1a449f	                BNE check_int       ; No: check to see if it's an integer
.1a449a	20 fd 44	jsr $1a44fd	            JSR PR_STRING
.1a449d	80 12		bra $1a44b1	                BRA check_nl
.1a449f	c9 00		cmp #$00	check_int       CMP #TYPE_INTEGER   ; Is it an integer?
.1a44a1	d0 05		bne $1a44a8	                BNE check_float     ; No: check to see if it is a float
.1a44a3	20 1b 45	jsr $1a451b	            JSR PR_INTEGER
.1a44a6	80 09		bra $1a44b1	                BRA check_nl
.1a44a8	c9 01		cmp #$01	check_float     CMP #TYPE_FLOAT     ; Is it a float?
.1a44aa	d0 4f		bne $1a44fb	                BNE done            ; No: just quit
.1a44ac	20 2e 45	jsr $1a452e	            JSR PR_FLOAT
.1a44af	80 00		bra $1a44b1	                BRA check_nl
.1a44b1					check_nl
.1a44b1	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a44b4	a7 00		lda [$0800]	                LDA [BIP]
.1a44b6	f0 40		beq $1a44f8	                BEQ pr_nl_exit      ; If it's nul, print a newline and return
.1a44b8	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.1a44ba	f0 3c		beq $1a44f8	                BEQ pr_nl_exit      ; print a newline and return
.1a44bc	c9 2c		cmp #$2c	                CMP #','            ; If it's a comma
.1a44be	f0 23		beq $1a44e3	                BEQ pr_comma        ; Print a TAB and try another expression
.1a44c0	c9 3b		cmp #$3b	                CMP #';'            ; If it's a semicolon...
.1a44c2	f0 24		beq $1a44e8	                BEQ is_more         ; Print nothing, and try another expression
.1a44c4	08		php		            PHP
.1a44c5	c2 20		rep #$20	            REP #$20
.1a44c7	48		pha		            PHA
.1a44c8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a44cb	5b		tcd		            TCD
.1a44cc	68		pla		            PLA
.1a44cd	28		plp		            PLP
.1a44ce	e2 20		sep #$20	            SEP #$20
.1a44d0	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a44d2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a44d6	c2 20		rep #$20	            REP #$20
.1a44d8	29 ff 00	and #$00ff	            AND #$00FF
.1a44db	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a44de	e2 20		sep #$20	            SEP #$20
.1a44e0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a44e3	a9 09		lda #$09	pr_comma        LDA #CHAR_TAB       ; Print a TAB
.1a44e5	20 18 00	jsr $1a0018	            JSR PRINTC
.1a44e8					is_more
.1a44e8	20 67 20	jsr $1a2067	            JSR INCBIP
.1a44eb	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a44ee	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.1a44f0	f0 09		beq $1a44fb	                BEQ done            ; If it's NULL, return without printing a newline
.1a44f2	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.1a44f4	f0 05		beq $1a44fb	                BEQ done            ; ... return without printing a newline
.1a44f6	80 93		bra $1a448b	                BRA pr_loop         ; Otherwise, we should have another expression, try to handle it
.1a44f8					pr_nl_exit
.1a44f8	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a44fb	28		plp		done            PLP
.1a44fc	60		rts		            RTS
.1a44fd					PR_STRING
.1a44fd	08		php		                PHP
.1a44fe	8b		phb		                PHB
.1a44ff	08		php		            PHP
.1a4500	c2 20		rep #$20	            REP #$20
.1a4502	48		pha		            PHA
.1a4503	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a4506	5b		tcd		            TCD
.1a4507	68		pla		            PLA
.1a4508	28		plp		            PLP
.1a4509	e2 20		sep #$20	            SEP #$20
.1a450b	a0 00 00	ldy #$0000	start_print     LDY #0
.1a450e	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y
.1a4510	f0 06		beq $1a4518	                BEQ done
.1a4512	20 18 00	jsr $1a0018	            JSR PRINTC
.1a4515	c8		iny		                INY
.1a4516	80 f6		bra $1a450e	                BRA loop
.1a4518	ab		plb		done            PLB
.1a4519	28		plp		                PLP
.1a451a	60		rts		            RTS
.1a451b					PR_INTEGER
.1a451b	08		php		                PHP
.1a451c	c2 20		rep #$20	            REP #$20
.1a451e	20 aa 14	jsr $1a14aa	            JSR ITOS
.1a4521	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.1a4523	85 23		sta $0823	                STA ARGUMENT1
.1a4525	a5 18		lda $0818	                LDA STRPTR+2
.1a4527	85 25		sta $0825	                STA ARGUMENT1+2
.1a4529	20 fd 44	jsr $1a44fd	            JSR PR_STRING
.1a452c	28		plp		                PLP
.1a452d	60		rts		            RTS
.1a452e					PR_FLOAT
.1a452e	08		php		                PHP
.1a452f	20 8b 5c	jsr $1a5c8b	            JSR FTOS
.1a4532	c2 20		rep #$20	            REP #$20
.1a4534	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.1a4536	85 23		sta $0823	                STA ARGUMENT1
.1a4538	a5 18		lda $0818	                LDA STRPTR+2
.1a453a	85 25		sta $0825	                STA ARGUMENT1+2
.1a453c	20 fd 44	jsr $1a44fd	            JSR PR_STRING
.1a453f	28		plp		                PLP
.1a4540	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\functions.s


;******  Processing file: src\C256/functions_c256.s

.1a4541					BCD2STR
.1a4541	08		php		            PHP
.1a4542	e2 20		sep #$20	            SEP #$20
.1a4544	85 b5		sta $08b5	            STA SAVE_A
.1a4546	4a		lsr a		            LSR A
.1a4547	4a		lsr a		            LSR A
.1a4548	4a		lsr a		            LSR A
.1a4549	4a		lsr a		            LSR A
.1a454a	29 0f		and #$0f	            AND #$0F
.1a454c	18		clc		            CLC
.1a454d	69 30		adc #$30	            ADC #'0'
.1a454f	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a4551	c8		iny		            INY
.1a4552	a5 b5		lda $08b5	            LDA SAVE_A
.1a4554	29 0f		and #$0f	            AND #$0F
.1a4556	18		clc		            CLC
.1a4557	69 30		adc #$30	            ADC #'0'
.1a4559	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a455b	c8		iny		            INY
.1a455c	28		plp		            PLP
.1a455d	60		rts		            RTS
.1a455e					F_GETDATE
.1a455e	e2 20		sep #$20	            SEP #$20
.1a4560	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4562	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4565	08		php		            PHP
.1a4566	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4569	e2 20		sep #$20	            SEP #$20
.1a456b	c2 10		rep #$10	            REP #$10
.1a456d	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a4571	09 08		ora #$08	            ORA #%00001000
.1a4573	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a4577	20 4b 14	jsr $1a144b	            JSR TEMPSTRING
.1a457a	a0 00 00	ldy #$0000	            LDY #0
.1a457d	af 06 08 af	lda $af0806	            LDA @lRTC_DAY           ; Write the day of the month
.1a4581	20 41 45	jsr $1a4541	            JSR BCD2STR
.1a4584	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.1a4586	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a4588	c8		iny		            INY
.1a4589	af 09 08 af	lda $af0809	            LDA @lRTC_MONTH         ; Write the month
.1a458d	20 41 45	jsr $1a4541	            JSR BCD2STR
.1a4590	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.1a4592	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a4594	c8		iny		            INY
.1a4595	af 0f 08 af	lda $af080f	            LDA @lRTC_CENTURY       ; Write the year
.1a4599	20 41 45	jsr $1a4541	            JSR BCD2STR
.1a459c	af 0a 08 af	lda $af080a	            LDA @lRTC_YEAR          ; Write the year
.1a45a0	20 41 45	jsr $1a4541	            JSR BCD2STR
.1a45a3	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.1a45a5	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a45a7	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a45ab	29 f7		and #$f7	            AND #%11110111
.1a45ad	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a45b1	c2 20		rep #$20	            REP #$20
.1a45b3	a5 16		lda $0816	            LDA STRPTR
.1a45b5	85 23		sta $0823	            STA ARGUMENT1
.1a45b7	a5 18		lda $0818	            LDA STRPTR+2
.1a45b9	85 25		sta $0825	            STA ARGUMENT1+2
.1a45bb	e2 20		sep #$20	            SEP #$20
.1a45bd	a9 02		lda #$02	            LDA #TYPE_STRING
.1a45bf	85 27		sta $0827	            STA ARGTYPE1
.1a45c1	28		plp		            PLP
.1a45c2	e2 20		sep #$20	            SEP #$20
.1a45c4	20 67 20	jsr $1a2067	            JSR INCBIP
.1a45c7	60		rts		            RTS
.1a45c8					F_GETTIME
.1a45c8	e2 20		sep #$20	            SEP #$20
.1a45ca	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a45cc	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a45cf	08		php		            PHP
.1a45d0	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a45d3	e2 20		sep #$20	            SEP #$20
.1a45d5	c2 10		rep #$10	            REP #$10
.1a45d7	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a45db	09 08		ora #$08	            ORA #%00001000
.1a45dd	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a45e1	20 4b 14	jsr $1a144b	            JSR TEMPSTRING
.1a45e4	a0 00 00	ldy #$0000	            LDY #0
.1a45e7	af 04 08 af	lda $af0804	            LDA @lRTC_HRS           ; Write the hour
.1a45eb	29 7f		and #$7f	            AND #$7F                ; Trim out the AM/PM indicator
.1a45ed	20 41 45	jsr $1a4541	            JSR BCD2STR
.1a45f0	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.1a45f2	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a45f4	c8		iny		            INY
.1a45f5	af 02 08 af	lda $af0802	            LDA @lRTC_MIN           ; Write the minute
.1a45f9	20 41 45	jsr $1a4541	            JSR BCD2STR
.1a45fc	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.1a45fe	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a4600	c8		iny		            INY
.1a4601	af 00 08 af	lda $af0800	            LDA @lRTC_SEC           ; Write the second
.1a4605	20 41 45	jsr $1a4541	            JSR BCD2STR
.1a4608	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.1a460a	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a460c	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a4610	29 f7		and #$f7	            AND #%11110111
.1a4612	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a4616	c2 20		rep #$20	            REP #$20
.1a4618	a5 16		lda $0816	            LDA STRPTR
.1a461a	85 23		sta $0823	            STA ARGUMENT1
.1a461c	a5 18		lda $0818	            LDA STRPTR+2
.1a461e	85 25		sta $0825	            STA ARGUMENT1+2
.1a4620	e2 20		sep #$20	            SEP #$20
.1a4622	a9 02		lda #$02	            LDA #TYPE_STRING
.1a4624	85 27		sta $0827	            STA ARGTYPE1
.1a4626	28		plp		            PLP
.1a4627	e2 20		sep #$20	            SEP #$20
.1a4629	20 67 20	jsr $1a2067	            JSR INCBIP
.1a462c	60		rts		            RTS
.1a462d					FN_RND
.1a462d	e2 20		sep #$20	            SEP #$20
.1a462f	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4631	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4634	08		php		            PHP
.1a4635	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4638	e2 20		sep #$20	            SEP #$20
.1a463a	a9 01		lda #$01	            LDA #TYPE_FLOAT             ; We'll return a floating point number
.1a463c	85 27		sta $0827	            STA ARGTYPE1
.1a463e	a9 03		lda #$03	            LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.1a4640	8f 00 e2 af	sta $afe200	            STA @l FP_MATH_CTRL0        ; Expect fixed point numbers
.1a4644	a9 01		lda #$01	            LDA #FP_OUT_DIV             ; Set us to do a division
.1a4646	8f 01 e2 af	sta $afe201	            STA @l FP_MATH_CTRL1
.1a464a	c2 30		rep #$30	            REP #$30
.1a464c	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get a random 16-bits
.1a4650	8f 08 e2 af	sta $afe208	            STA @l FP_MATH_INPUT0_LL    ; Send them to the FP unit
.1a4654	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get another random 16-bits
.1a4658	29 ff 7f	and #$7fff	            AND #$7FFF                  ; Make sure it's positive
.1a465b	8f 0a e2 af	sta $afe20a	            STA @l FP_MATH_INPUT0_LL+2  ; Send them to the FP unit
.1a465f	a9 ff ff	lda #$ffff	            LDA #$FFFF                  ; Get the maximum value
.1a4662	8f 0c e2 af	sta $afe20c	            STA @l FP_MATH_INPUT1_LL    ; Send it to the FP unit
.1a4666	a9 ff 7f	lda #$7fff	            LDA #$7FFF
.1a4669	8f 0e e2 af	sta $afe20e	            STA @l FP_MATH_INPUT1_LL+2
.1a466d	ea		nop		            NOP
.1a466e	ea		nop		            NOP
.1a466f	ea		nop		            NOP
.1a4670	af 08 e2 af	lda $afe208	            LDA @l FP_MATH_OUTPUT_FP_LL     ; Get the normalized result
.1a4674	85 23		sta $0823	            STA ARGUMENT1
.1a4676	af 0a e2 af	lda $afe20a	            LDA @l FP_MATH_OUTPUT_FP_LL+2
.1a467a	85 25		sta $0825	            STA ARGUMENT1+2
.1a467c	28		plp		            PLP
.1a467d	e2 20		sep #$20	            SEP #$20
.1a467f	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4682	60		rts		            RTS

;******  Return to file: src\functions.s

.1a4683					FN_MID
.1a4683	e2 20		sep #$20	            SEP #$20
.1a4685	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4687	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a468a	08		php		                PHP
.1a468b	c2 30		rep #$30	            REP #$30
.1a468d	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4690	20 32 06	jsr $1a0632	            JSR ASS_ARG1_STR
.1a4693					save_string
.1a4693	c2 20		rep #$20	            REP #$20
.1a4695	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.1a4697	48		pha		                PHA
.1a4698	a5 23		lda $0823	                LDA ARGUMENT1
.1a469a	48		pha		                PHA
.1a469b	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a469e	e2 20		sep #$20	            SEP #$20
.1a46a0	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a46a2	c9 2c		cmp #$2c	                CMP #','
.1a46a4	f0 03		beq $1a46a9	                BEQ skip_comma1
.1a46a6	4c fa 46	jmp $1a46fa	                JMP syntax_err
.1a46a9					skip_comma1
.1a46a9	20 67 20	jsr $1a2067	            JSR INCBIP
.1a46ac	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a46af	20 5c 06	jsr $1a065c	            JSR ASS_ARG1_INT16
.1a46b2	c2 20		rep #$20	            REP #$20
.1a46b4	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the index
.1a46b6	48		pha		                PHA
.1a46b7	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a46ba	e2 20		sep #$20	            SEP #$20
.1a46bc	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a46be	c9 2c		cmp #$2c	                CMP #','
.1a46c0	f0 03		beq $1a46c5	                BEQ skip_comma2
.1a46c2	4c fa 46	jmp $1a46fa	                JMP syntax_err
.1a46c5					skip_comma2
.1a46c5	20 67 20	jsr $1a2067	            JSR INCBIP
.1a46c8	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a46cb	20 5c 06	jsr $1a065c	            JSR ASS_ARG1_INT16
.1a46ce	c2 20		rep #$20	            REP #$20
.1a46d0	a5 23		lda $0823	            LDA ARGUMENT1
.1a46d2	85 8f		sta $088f	            STA MCOUNT
.1a46d4	e2 20		sep #$20	            SEP #$20
.1a46d6	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a46d8	85 91		sta $0891	            STA MCOUNT+2
.1a46da	c2 20		rep #$20	            REP #$20
.1a46dc	68		pla		                PLA                         ; Restore index
.1a46dd	85 29		sta $0829	                STA ARGUMENT2               ; ... to ARGUMENT2
.1a46df	a9 00 00	lda #$0000	                LDA #0
.1a46e2	85 2b		sta $082b	                STA ARGUMENT2+2
.1a46e4	68		pla		                PLA                         ; Restore string
.1a46e5	85 23		sta $0823	                STA ARGUMENT1               ; ... to ARGUMENT1
.1a46e7	68		pla		                PLA
.1a46e8	85 25		sta $0825	                STA ARGUMENT1+2
.1a46ea	e2 20		sep #$20	            SEP #$20
.1a46ec	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a46ee	85 27		sta $0827	            STA ARGTYPE1
.1a46f0	20 a3 16	jsr $1a16a3	            JSR STRSUBSTR
.1a46f3					done
.1a46f3	e2 20		sep #$20	            SEP #$20
.1a46f5	20 67 20	jsr $1a2067	            JSR INCBIP
.1a46f8	28		plp		                PLP
.1a46f9	60		rts		            RTS
.1a46fa					syntax_err
.1a46fa	08		php		            PHP
.1a46fb	c2 20		rep #$20	            REP #$20
.1a46fd	48		pha		            PHA
.1a46fe	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4701	5b		tcd		            TCD
.1a4702	68		pla		            PLA
.1a4703	28		plp		            PLP
.1a4704	e2 20		sep #$20	            SEP #$20
.1a4706	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4708	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a470c	c2 20		rep #$20	            REP #$20
.1a470e	29 ff 00	and #$00ff	            AND #$00FF
.1a4711	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4714	e2 20		sep #$20	            SEP #$20
.1a4716	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4719					range_err
.1a4719	08		php		            PHP
.1a471a	c2 20		rep #$20	            REP #$20
.1a471c	48		pha		            PHA
.1a471d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4720	5b		tcd		            TCD
.1a4721	68		pla		            PLA
.1a4722	28		plp		            PLP
.1a4723	e2 20		sep #$20	            SEP #$20
.1a4725	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4727	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a472b	c2 20		rep #$20	            REP #$20
.1a472d	29 ff 00	and #$00ff	            AND #$00FF
.1a4730	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4733	e2 20		sep #$20	            SEP #$20
.1a4735	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4738					FN_RIGHT
.1a4738	e2 20		sep #$20	            SEP #$20
.1a473a	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a473c	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a473f	08		php		                PHP
.1a4740	c2 30		rep #$30	            REP #$30
.1a4742	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4745	e2 20		sep #$20	            SEP #$20
.1a4747	a5 27		lda $0827	                LDA ARGTYPE1
.1a4749	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a474b	f0 03		beq $1a4750	                BEQ save_string
.1a474d	4c bc 47	jmp $1a47bc	                JMP type_mismatch           ; Type mismatch if it's not a string
.1a4750					save_string
.1a4750	c2 20		rep #$20	            REP #$20
.1a4752	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.1a4754	48		pha		                PHA
.1a4755	a5 23		lda $0823	                LDA ARGUMENT1
.1a4757	48		pha		                PHA
.1a4758	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a475b	e2 20		sep #$20	            SEP #$20
.1a475d	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a475f	c9 2c		cmp #$2c	                CMP #','
.1a4761	f0 03		beq $1a4766	                BEQ skip_comma
.1a4763	4c db 47	jmp $1a47db	                JMP syntax_err
.1a4766					skip_comma
.1a4766	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4769	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a476c	e2 20		sep #$20	            SEP #$20
.1a476e	a5 27		lda $0827	                LDA ARGTYPE1
.1a4770	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4772	d0 48		bne $1a47bc	                BNE type_mismatch           ; Type mismatch if it's not an integer
.1a4774	c2 20		rep #$20	            REP #$20
.1a4776	a5 23		lda $0823	            LDA ARGUMENT1
.1a4778	85 8f		sta $088f	            STA MCOUNT
.1a477a	c2 20		rep #$20	            REP #$20
.1a477c	68		pla		                PLA                         ; Recover the string pointer
.1a477d	85 23		sta $0823	                STA ARGUMENT1
.1a477f	68		pla		                PLA
.1a4780	85 25		sta $0825	                STA ARGUMENT1+2
.1a4782	e2 20		sep #$20	            SEP #$20
.1a4784	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a4786	85 27		sta $0827	            STA ARGTYPE1
.1a4788	e2 20		sep #$20	            SEP #$20
.1a478a	a0 00 00	ldy #$0000	                LDY #0
.1a478d	b7 23		lda [$0823],y	count_loop      LDA [ARGUMENT1],Y
.1a478f	f0 03		beq $1a4794	                BEQ count_done
.1a4791	c8		iny		                INY
.1a4792	80 f9		bra $1a478d	                BRA count_loop
.1a4794					count_done
.1a4794	c2 20		rep #$20	            REP #$20
.1a4796	98		tya		                TYA                         ; ARGUMENT2 := LENGTH - MCOUNT
.1a4797	38		sec		                SEC
.1a4798	e5 8f		sbc $088f	                SBC MCOUNT
.1a479a	30 09		bmi $1a47a5	                BMI index0                  ; if ARGUMENT2 < 0, set ARGUMENT2 := 0
.1a479c	85 29		sta $0829	                STA ARGUMENT2
.1a479e	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT2[23..16] := 0
.1a47a1	85 2b		sta $082b	                STA ARGUMENT2+2
.1a47a3	80 07		bra $1a47ac	                BRA slice
.1a47a5	a9 00 00	lda #$0000	index0          LDA #0                      ; 0 is the floor for the index
.1a47a8	85 29		sta $0829	                STA ARGUMENT2
.1a47aa	85 2b		sta $082b	                STA ARGUMENT2+2
.1a47ac					slice
.1a47ac	e2 20		sep #$20	            SEP #$20
.1a47ae	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a47b0	85 2d		sta $082d	            STA ARGTYPE2
.1a47b2	20 a3 16	jsr $1a16a3	            JSR STRSUBSTR
.1a47b5					done
.1a47b5	e2 20		sep #$20	            SEP #$20
.1a47b7	20 67 20	jsr $1a2067	            JSR INCBIP
.1a47ba	28		plp		                PLP
.1a47bb	60		rts		            RTS
.1a47bc					type_mismatch
.1a47bc	08		php		            PHP
.1a47bd	c2 20		rep #$20	            REP #$20
.1a47bf	48		pha		            PHA
.1a47c0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a47c3	5b		tcd		            TCD
.1a47c4	68		pla		            PLA
.1a47c5	28		plp		            PLP
.1a47c6	e2 20		sep #$20	            SEP #$20
.1a47c8	a9 04		lda #$04	            LDA #ERR_TYPE
.1a47ca	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a47ce	c2 20		rep #$20	            REP #$20
.1a47d0	29 ff 00	and #$00ff	            AND #$00FF
.1a47d3	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a47d6	e2 20		sep #$20	            SEP #$20
.1a47d8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a47db					syntax_err
.1a47db	08		php		            PHP
.1a47dc	c2 20		rep #$20	            REP #$20
.1a47de	48		pha		            PHA
.1a47df	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a47e2	5b		tcd		            TCD
.1a47e3	68		pla		            PLA
.1a47e4	28		plp		            PLP
.1a47e5	e2 20		sep #$20	            SEP #$20
.1a47e7	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a47e9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a47ed	c2 20		rep #$20	            REP #$20
.1a47ef	29 ff 00	and #$00ff	            AND #$00FF
.1a47f2	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a47f5	e2 20		sep #$20	            SEP #$20
.1a47f7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a47fa					range_err
.1a47fa	08		php		            PHP
.1a47fb	c2 20		rep #$20	            REP #$20
.1a47fd	48		pha		            PHA
.1a47fe	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4801	5b		tcd		            TCD
.1a4802	68		pla		            PLA
.1a4803	28		plp		            PLP
.1a4804	e2 20		sep #$20	            SEP #$20
.1a4806	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4808	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a480c	c2 20		rep #$20	            REP #$20
.1a480e	29 ff 00	and #$00ff	            AND #$00FF
.1a4811	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4814	e2 20		sep #$20	            SEP #$20
.1a4816	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4819					FN_LEFT
.1a4819	e2 20		sep #$20	            SEP #$20
.1a481b	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a481d	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4820	08		php		                PHP
.1a4821	c2 30		rep #$30	            REP #$30
.1a4823	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4826	e2 20		sep #$20	            SEP #$20
.1a4828	a5 27		lda $0827	                LDA ARGTYPE1
.1a482a	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a482c	f0 03		beq $1a4831	                BEQ save_string
.1a482e	4c 85 48	jmp $1a4885	                JMP type_mismatch           ; Type mismatch if it's not a string
.1a4831					save_string
.1a4831	c2 20		rep #$20	            REP #$20
.1a4833	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.1a4835	48		pha		                PHA
.1a4836	a5 23		lda $0823	                LDA ARGUMENT1
.1a4838	48		pha		                PHA
.1a4839	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a483c	e2 20		sep #$20	            SEP #$20
.1a483e	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a4840	c9 2c		cmp #$2c	                CMP #','
.1a4842	f0 03		beq $1a4847	                BEQ skip_comma
.1a4844	4c a4 48	jmp $1a48a4	                JMP syntax_err
.1a4847					skip_comma
.1a4847	20 67 20	jsr $1a2067	            JSR INCBIP
.1a484a	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a484d	e2 20		sep #$20	            SEP #$20
.1a484f	a5 27		lda $0827	                LDA ARGTYPE1
.1a4851	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4853	d0 30		bne $1a4885	                BNE type_mismatch           ; Type mismatch if it's not an integer
.1a4855	c2 20		rep #$20	            REP #$20
.1a4857	a5 23		lda $0823	            LDA ARGUMENT1
.1a4859	85 8f		sta $088f	            STA MCOUNT
.1a485b	c2 20		rep #$20	            REP #$20
.1a485d	a9 00 00	lda #$0000	            LDA #<>0
.1a4860	85 29		sta $0829	            STA ARGUMENT2
.1a4862	a9 00 00	lda #$0000	            LDA #(0 >> 16)
.1a4865	85 2b		sta $082b	            STA ARGUMENT2+2
.1a4867	e2 20		sep #$20	            SEP #$20
.1a4869	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a486b	85 2d		sta $082d	            STA ARGTYPE2
.1a486d	c2 20		rep #$20	            REP #$20
.1a486f	68		pla		                PLA                         ; Recover the string pointer
.1a4870	85 23		sta $0823	                STA ARGUMENT1
.1a4872	68		pla		                PLA
.1a4873	85 25		sta $0825	                STA ARGUMENT1+2
.1a4875	e2 20		sep #$20	            SEP #$20
.1a4877	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a4879	85 27		sta $0827	            STA ARGTYPE1
.1a487b	20 a3 16	jsr $1a16a3	            JSR STRSUBSTR
.1a487e					done
.1a487e	e2 20		sep #$20	            SEP #$20
.1a4880	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4883	28		plp		                PLP
.1a4884	60		rts		            RTS
.1a4885					type_mismatch
.1a4885	08		php		            PHP
.1a4886	c2 20		rep #$20	            REP #$20
.1a4888	48		pha		            PHA
.1a4889	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a488c	5b		tcd		            TCD
.1a488d	68		pla		            PLA
.1a488e	28		plp		            PLP
.1a488f	e2 20		sep #$20	            SEP #$20
.1a4891	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4893	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4897	c2 20		rep #$20	            REP #$20
.1a4899	29 ff 00	and #$00ff	            AND #$00FF
.1a489c	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a489f	e2 20		sep #$20	            SEP #$20
.1a48a1	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a48a4					syntax_err
.1a48a4	08		php		            PHP
.1a48a5	c2 20		rep #$20	            REP #$20
.1a48a7	48		pha		            PHA
.1a48a8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a48ab	5b		tcd		            TCD
.1a48ac	68		pla		            PLA
.1a48ad	28		plp		            PLP
.1a48ae	e2 20		sep #$20	            SEP #$20
.1a48b0	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a48b2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a48b6	c2 20		rep #$20	            REP #$20
.1a48b8	29 ff 00	and #$00ff	            AND #$00FF
.1a48bb	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a48be	e2 20		sep #$20	            SEP #$20
.1a48c0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a48c3					range_err
.1a48c3	08		php		            PHP
.1a48c4	c2 20		rep #$20	            REP #$20
.1a48c6	48		pha		            PHA
.1a48c7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a48ca	5b		tcd		            TCD
.1a48cb	68		pla		            PLA
.1a48cc	28		plp		            PLP
.1a48cd	e2 20		sep #$20	            SEP #$20
.1a48cf	a9 09		lda #$09	            LDA #ERR_RANGE
.1a48d1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a48d5	c2 20		rep #$20	            REP #$20
.1a48d7	29 ff 00	and #$00ff	            AND #$00FF
.1a48da	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a48dd	e2 20		sep #$20	            SEP #$20
.1a48df	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a48e2					FN_VAL
.1a48e2	e2 20		sep #$20	            SEP #$20
.1a48e4	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a48e6	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a48e9	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a48ec	c2 10		rep #$10	            REP #$10
.1a48ee	e2 20		sep #$20	            SEP #$20
.1a48f0	a5 27		lda $0827	                LDA ARGTYPE1
.1a48f2	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a48f4	d0 23		bne $1a4919	                BNE type_mismatch
.1a48f6	c2 20		rep #$20	            REP #$20
.1a48f8	a5 00		lda $0800	                LDA BIP             ; preserve BIP for later
.1a48fa	85 40		sta $0840	                STA SAVEBIP
.1a48fc	a5 02		lda $0802	                LDA BIP+2
.1a48fe	85 42		sta $0842	                STA SAVEBIP+2
.1a4900	a5 23		lda $0823	                LDA ARGUMENT1       ; Temporarily point BIP to the string to parse
.1a4902	85 00		sta $0800	                STA BIP
.1a4904	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4906	85 02		sta $0802	                STA BIP+2
.1a4908	20 27 08	jsr $1a0827	            JSR PARSEINT
.1a490b	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.1a490d	85 00		sta $0800	                STA BIP
.1a490f	a5 42		lda $0842	                LDA SAVEBIP+2
.1a4911	85 02		sta $0802	                STA BIP+2
.1a4913	e2 20		sep #$20	            SEP #$20
.1a4915	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4918	60		rts		            RTS
.1a4919					type_mismatch
.1a4919	08		php		            PHP
.1a491a	c2 20		rep #$20	            REP #$20
.1a491c	48		pha		            PHA
.1a491d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4920	5b		tcd		            TCD
.1a4921	68		pla		            PLA
.1a4922	28		plp		            PLP
.1a4923	e2 20		sep #$20	            SEP #$20
.1a4925	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4927	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a492b	c2 20		rep #$20	            REP #$20
.1a492d	29 ff 00	and #$00ff	            AND #$00FF
.1a4930	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4933	e2 20		sep #$20	            SEP #$20
.1a4935	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4938					FN_STR
.1a4938	e2 20		sep #$20	            SEP #$20
.1a493a	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a493c	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a493f	08		php		                PHP
.1a4940	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4943	c2 10		rep #$10	            REP #$10
.1a4945	e2 20		sep #$20	            SEP #$20
.1a4947	a5 27		lda $0827	                LDA ARGTYPE1
.1a4949	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a494b	d0 1a		bne $1a4967	                BNE type_mismatch
.1a494d	20 aa 14	jsr $1a14aa	            JSR ITOS
.1a4950	c2 20		rep #$20	            REP #$20
.1a4952	a5 16		lda $0816	                LDA STRPTR          ; Prepare the return result
.1a4954	85 23		sta $0823	                STA ARGUMENT1
.1a4956	a5 18		lda $0818	                LDA STRPTR+2
.1a4958	85 25		sta $0825	                STA ARGUMENT1+2
.1a495a	e2 20		sep #$20	            SEP #$20
.1a495c	a9 02		lda #$02	                LDA #TYPE_STRING
.1a495e	85 27		sta $0827	                STA ARGTYPE1
.1a4960	28		plp		                PLP
.1a4961	e2 20		sep #$20	            SEP #$20
.1a4963	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4966	60		rts		            RTS
.1a4967					type_mismatch
.1a4967	08		php		            PHP
.1a4968	c2 20		rep #$20	            REP #$20
.1a496a	48		pha		            PHA
.1a496b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a496e	5b		tcd		            TCD
.1a496f	68		pla		            PLA
.1a4970	28		plp		            PLP
.1a4971	e2 20		sep #$20	            SEP #$20
.1a4973	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4975	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4979	c2 20		rep #$20	            REP #$20
.1a497b	29 ff 00	and #$00ff	            AND #$00FF
.1a497e	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4981	e2 20		sep #$20	            SEP #$20
.1a4983	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4986					FN_DEC
.1a4986	e2 20		sep #$20	            SEP #$20
.1a4988	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a498a	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a498d	08		php		                PHP
.1a498e	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4991	20 32 06	jsr $1a0632	            JSR ASS_ARG1_STR
.1a4994	c2 20		rep #$20	            REP #$20
.1a4996	64 0c		stz $080c	                STZ SCRATCH
.1a4998	64 0e		stz $080e	                STZ SCRATCH+2
.1a499a	e2 30		sep #$30	            SEP #$30
.1a499c	a0 00		ldy #$00	                LDY #0
.1a499e	b7 23		lda [$0823],y	skip_loop       LDA [ARGUMENT1],Y
.1a49a0	c9 20		cmp #$20	                CMP #CHAR_SP
.1a49a2	f0 04		beq $1a49a8	                BEQ skip_char
.1a49a4	c9 24		cmp #$24	                CMP #'$'
.1a49a6	d0 03		bne $1a49ab	                BNE loop
.1a49a8	c8		iny		skip_char       INY
.1a49a9	80 f3		bra $1a499e	                BRA skip_loop
.1a49ab	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y   ; Check the character
.1a49ad	20 5b 04	jsr $1a045b	            JSR ISHEX
.1a49b0	90 1e		bcc $1a49d0	                BCC ret_result      ; No: return what we have so far
.1a49b2	c2 20		rep #$20	            REP #$20
.1a49b4	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a49b6	26 0e		rol $080e	                ROL SCRATCH+2
.1a49b8	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a49ba	26 0e		rol $080e	                ROL SCRATCH+2
.1a49bc	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a49be	26 0e		rol $080e	                ROL SCRATCH+2
.1a49c0	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a49c2	26 0e		rol $080e	                ROL SCRATCH+2
.1a49c4	e2 20		sep #$20	            SEP #$20
.1a49c6	20 7c 04	jsr $1a047c	            JSR HEX2BIN
.1a49c9	05 0c		ora $080c	                ORA SCRATCH
.1a49cb	85 0c		sta $080c	                STA SCRATCH         ; And add it to the result
.1a49cd	c8		iny		                INY
.1a49ce	80 db		bra $1a49ab	                BRA loop            ; And try the next character
.1a49d0					ret_result
.1a49d0	c2 20		rep #$20	            REP #$20
.1a49d2	a5 0c		lda $080c	                LDA SCRATCH         ; Return the result
.1a49d4	85 23		sta $0823	                STA ARGUMENT1
.1a49d6	a5 0e		lda $080e	                LDA SCRATCH+2
.1a49d8	85 25		sta $0825	                STA ARGUMENT1+2
.1a49da	e2 20		sep #$20	            SEP #$20
.1a49dc	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a49de	85 27		sta $0827	                STA ARGTYPE1
.1a49e0	28		plp		                PLP
.1a49e1	e2 20		sep #$20	            SEP #$20
.1a49e3	20 67 20	jsr $1a2067	            JSR INCBIP
.1a49e6	60		rts		            RTS
.1a49e7					FN_HEX
.1a49e7	e2 20		sep #$20	            SEP #$20
.1a49e9	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a49eb	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a49ee	08		php		                PHP
.1a49ef	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a49f2	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a49f5	20 4b 14	jsr $1a144b	            JSR TEMPSTRING
.1a49f8	e2 30		sep #$30	            SEP #$30
.1a49fa	a0 ff		ldy #$ff	                LDY #$FF            ; Terminate the string
.1a49fc	a9 00		lda #$00	                LDA #0
.1a49fe	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4a00	88		dey		                DEY
.1a4a01	a5 23		lda $0823	loop            LDA ARGUMENT1       ; Write the low digit
.1a4a03	29 0f		and #$0f	                AND #$0F
.1a4a05	aa		tax		                TAX
.1a4a06	bf 00 d0 1a	lda $1ad000,x	                LDA @lHEXDIGITS,X
.1a4a0a	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4a0c	88		dey		                DEY
.1a4a0d	a5 23		lda $0823	                LDA ARGUMENT1       ; Write the high digit
.1a4a0f	29 f0		and #$f0	                AND #$F0
.1a4a11	4a		lsr a		                LSR A
.1a4a12	4a		lsr a		                LSR A
.1a4a13	4a		lsr a		                LSR A
.1a4a14	4a		lsr a		                LSR A
.1a4a15	aa		tax		                TAX
.1a4a16	bf 00 d0 1a	lda $1ad000,x	                LDA @lHEXDIGITS,X
.1a4a1a	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4a1c	88		dey		                DEY
.1a4a1d	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Shift value by one byte
.1a4a1f	85 23		sta $0823	                STA ARGUMENT1
.1a4a21	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4a23	85 24		sta $0824	                STA ARGUMENT1+1
.1a4a25	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a4a27	85 25		sta $0825	                STA ARGUMENT1+2
.1a4a29	a9 00		lda #$00	                LDA #0
.1a4a2b	85 26		sta $0826	                STA ARGUMENT1+3
.1a4a2d	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the argument 0?
.1a4a2f	d0 d0		bne $1a4a01	                BNE loop            ; No: keep converting
.1a4a31	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a4a33	d0 cc		bne $1a4a01	                BNE loop
.1a4a35	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4a37	d0 c8		bne $1a4a01	                BNE loop
.1a4a39	98		tya		                TYA                 ; Get the index of the first free char
.1a4a3a	38		sec		                SEC                 ; Add 1 to get to the first character of the string
.1a4a3b	65 16		adc $0816	                ADC STRPTR          ; And add the whole thing to the temp string pointer
.1a4a3d	85 23		sta $0823	                STA ARGUMENT1       ; And return it as the result
.1a4a3f	a5 17		lda $0817	                LDA STRPTR+1
.1a4a41	85 24		sta $0824	                STA ARGUMENT1+1
.1a4a43	a5 18		lda $0818	                LDA STRPTR+2
.1a4a45	85 25		sta $0825	                STA ARGUMENT1+2
.1a4a47	a5 19		lda $0819	                LDA STRPTR+3
.1a4a49	85 26		sta $0826	                STA ARGUMENT1+3
.1a4a4b	a9 02		lda #$02	                LDA #TYPE_STRING    ; And make the type STRING
.1a4a4d	85 27		sta $0827	                STA ARGTYPE1
.1a4a4f	28		plp		                PLP
.1a4a50	e2 20		sep #$20	            SEP #$20
.1a4a52	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4a55	60		rts		            RTS
.1a4a56					type_mismatch
.1a4a56	08		php		            PHP
.1a4a57	c2 20		rep #$20	            REP #$20
.1a4a59	48		pha		            PHA
.1a4a5a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4a5d	5b		tcd		            TCD
.1a4a5e	68		pla		            PLA
.1a4a5f	28		plp		            PLP
.1a4a60	e2 20		sep #$20	            SEP #$20
.1a4a62	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4a64	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4a68	c2 20		rep #$20	            REP #$20
.1a4a6a	29 ff 00	and #$00ff	            AND #$00FF
.1a4a6d	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4a70	e2 20		sep #$20	            SEP #$20
.1a4a72	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4a75					FN_LEN
.1a4a75	e2 20		sep #$20	            SEP #$20
.1a4a77	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4a79	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4a7c	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4a7f	e2 20		sep #$20	            SEP #$20
.1a4a81	a5 27		lda $0827	                LDA ARGTYPE1
.1a4a83	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4a85	d0 1f		bne $1a4aa6	                BNE type_mismatch
.1a4a87	8b		phb		                PHB                 ; Set the data bank to the data bank of the string
.1a4a88	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4a8a	48		pha		                PHA
.1a4a8b	ab		plb		                PLB
.1a4a8c	c2 10		rep #$10	            REP #$10
.1a4a8e	a6 23		ldx $0823	                LDX ARGUMENT1       ; And point X to the string data
.1a4a90	20 37 15	jsr $1a1537	            JSR STRLEN
.1a4a93	ab		plb		                PLB                 ; Restore the old data bank
.1a4a94	84 23		sty $0823	                STY ARGUMENT1       ; Save the length to ARGUMENT1
.1a4a96	c2 20		rep #$20	            REP #$20
.1a4a98	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4a9a	e2 20		sep #$20	            SEP #$20
.1a4a9c	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the type to INTEGER
.1a4a9e	85 27		sta $0827	                STA ARGTYPE1
.1a4aa0	e2 20		sep #$20	            SEP #$20
.1a4aa2	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4aa5	60		rts		            RTS
.1a4aa6					type_mismatch
.1a4aa6	08		php		            PHP
.1a4aa7	c2 20		rep #$20	            REP #$20
.1a4aa9	48		pha		            PHA
.1a4aaa	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4aad	5b		tcd		            TCD
.1a4aae	68		pla		            PLA
.1a4aaf	28		plp		            PLP
.1a4ab0	e2 20		sep #$20	            SEP #$20
.1a4ab2	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4ab4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4ab8	c2 20		rep #$20	            REP #$20
.1a4aba	29 ff 00	and #$00ff	            AND #$00FF
.1a4abd	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4ac0	e2 20		sep #$20	            SEP #$20
.1a4ac2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4ac5					FN_PEEK
.1a4ac5	e2 20		sep #$20	            SEP #$20
.1a4ac7	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4ac9	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4acc	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4acf	e2 20		sep #$20	            SEP #$20
.1a4ad1	a5 27		lda $0827	                LDA ARGTYPE1
.1a4ad3	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4ad5	d0 33		bne $1a4b0a	                BNE type_mismatch
.1a4ad7	a5 25		lda $0825	                LDA ARGUMENT1+2                     ; Check to see if the request is to video memory
.1a4ad9	c9 b0		cmp #$b0	                CMP #`VRAM
.1a4adb	90 1b		bcc $1a4af8	                BLT simple_peek                     ; No: just do an ordinary PEEK
.1a4add	c9 f0		cmp #$f0	                CMP #$F0
.1a4adf	b0 17		bcs $1a4af8	                BGE simple_peek
.1a4ae1	e2 20		sep #$20	            SEP #$20
.1a4ae3	a7 23		lda [$0823]	                LDA [ARGUMENT1]                     ; Request the data from VRAM
.1a4ae5	c2 20		rep #$20	            REP #$20
.1a4ae7	af 02 09 af	lda $af0902	wait_vram       LDA @l VMEM2CPU_Fifo_Count_LO       ; Wait for the Vicky FIFO to have a byte in it
.1a4aeb	89 00 80	bit #$8000	                BIT #$8000
.1a4aee	d0 f7		bne $1a4ae7	                BNE wait_vram
.1a4af0	e2 20		sep #$20	            SEP #$20
.1a4af2	af 01 09 af	lda $af0901	                LDA @l VMEM2CPU_Data_Port           ; Fetch the byte from the Vicky FIFO
.1a4af6	80 04		bra $1a4afc	                BRA save_result                     ; And return it
.1a4af8					simple_peek
.1a4af8	e2 20		sep #$20	            SEP #$20
.1a4afa	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.1a4afc	85 23		sta $0823	save_result     STA ARGUMENT1
.1a4afe	64 24		stz $0824	                STZ ARGUMENT1+1
.1a4b00	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4b02	64 30		stz $0830	                STZ ARGUMENT1+13
.1a4b04	e2 20		sep #$20	            SEP #$20
.1a4b06	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4b09	60		rts		            RTS
.1a4b0a					type_mismatch
.1a4b0a	08		php		            PHP
.1a4b0b	c2 20		rep #$20	            REP #$20
.1a4b0d	48		pha		            PHA
.1a4b0e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4b11	5b		tcd		            TCD
.1a4b12	68		pla		            PLA
.1a4b13	28		plp		            PLP
.1a4b14	e2 20		sep #$20	            SEP #$20
.1a4b16	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4b18	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4b1c	c2 20		rep #$20	            REP #$20
.1a4b1e	29 ff 00	and #$00ff	            AND #$00FF
.1a4b21	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4b24	e2 20		sep #$20	            SEP #$20
.1a4b26	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4b29					FN_PEEKL
.1a4b29	e2 20		sep #$20	            SEP #$20
.1a4b2b	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4b2d	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4b30	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4b33	e2 20		sep #$20	            SEP #$20
.1a4b35	a5 27		lda $0827	                LDA ARGTYPE1
.1a4b37	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4b39	d0 1d		bne $1a4b58	                BNE type_mismatch
.1a4b3b	c2 20		rep #$20	            REP #$20
.1a4b3d	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.1a4b3f	85 0c		sta $080c	                STA SCRATCH
.1a4b41	e2 20		sep #$20	            SEP #$20
.1a4b43	a0 02 00	ldy #$0002	                LDY #2
.1a4b46	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y
.1a4b48	85 25		sta $0825	                STA ARGUMENT1+2
.1a4b4a	64 26		stz $0826	                STZ ARGUMENT1+3
.1a4b4c	c2 20		rep #$20	            REP #$20
.1a4b4e	a5 0c		lda $080c	                LDA SCRATCH
.1a4b50	85 23		sta $0823	                STA ARGUMENT1
.1a4b52	e2 20		sep #$20	            SEP #$20
.1a4b54	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4b57	60		rts		            RTS
.1a4b58					type_mismatch
.1a4b58	08		php		            PHP
.1a4b59	c2 20		rep #$20	            REP #$20
.1a4b5b	48		pha		            PHA
.1a4b5c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4b5f	5b		tcd		            TCD
.1a4b60	68		pla		            PLA
.1a4b61	28		plp		            PLP
.1a4b62	e2 20		sep #$20	            SEP #$20
.1a4b64	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4b66	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4b6a	c2 20		rep #$20	            REP #$20
.1a4b6c	29 ff 00	and #$00ff	            AND #$00FF
.1a4b6f	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4b72	e2 20		sep #$20	            SEP #$20
.1a4b74	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4b77					FN_PEEKW
.1a4b77	e2 20		sep #$20	            SEP #$20
.1a4b79	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4b7b	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4b7e	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4b81	e2 20		sep #$20	            SEP #$20
.1a4b83	a5 27		lda $0827	                LDA ARGTYPE1
.1a4b85	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4b87	d0 0e		bne $1a4b97	                BNE type_mismatch
.1a4b89	c2 20		rep #$20	            REP #$20
.1a4b8b	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.1a4b8d	85 23		sta $0823	                STA ARGUMENT1
.1a4b8f	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4b91	e2 20		sep #$20	            SEP #$20
.1a4b93	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4b96	60		rts		            RTS
.1a4b97					type_mismatch
.1a4b97	08		php		            PHP
.1a4b98	c2 20		rep #$20	            REP #$20
.1a4b9a	48		pha		            PHA
.1a4b9b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4b9e	5b		tcd		            TCD
.1a4b9f	68		pla		            PLA
.1a4ba0	28		plp		            PLP
.1a4ba1	e2 20		sep #$20	            SEP #$20
.1a4ba3	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4ba5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4ba9	c2 20		rep #$20	            REP #$20
.1a4bab	29 ff 00	and #$00ff	            AND #$00FF
.1a4bae	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4bb1	e2 20		sep #$20	            SEP #$20
.1a4bb3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4bb6					FN_CHR
.1a4bb6	e2 20		sep #$20	            SEP #$20
.1a4bb8	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4bba	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4bbd	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4bc0	e2 20		sep #$20	            SEP #$20
.1a4bc2	a5 27		lda $0827	                LDA ARGTYPE1
.1a4bc4	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4bc6	d0 24		bne $1a4bec	                BNE type_mismatch
.1a4bc8	20 4b 14	jsr $1a144b	            JSR TEMPSTRING
.1a4bcb	a5 23		lda $0823	                LDA ARGUMENT1       ; Get the numberic value
.1a4bcd	87 16		sta [$0816]	                STA [STRPTR]        ; And save it as the first character
.1a4bcf	a9 00		lda #$00	                LDA #0              ; Null terminate the string
.1a4bd1	a0 01 00	ldy #$0001	                LDY #1
.1a4bd4	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4bd6	c2 20		rep #$20	            REP #$20
.1a4bd8	a5 16		lda $0816	                LDA STRPTR
.1a4bda	85 23		sta $0823	                STA ARGUMENT1
.1a4bdc	a5 18		lda $0818	                LDA STRPTR+2
.1a4bde	85 25		sta $0825	                STA ARGUMENT1+2
.1a4be0	e2 20		sep #$20	            SEP #$20
.1a4be2	a9 02		lda #$02	                LDA #TYPE_STRING
.1a4be4	85 27		sta $0827	                STA ARGTYPE1
.1a4be6	e2 20		sep #$20	            SEP #$20
.1a4be8	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4beb	60		rts		            RTS
.1a4bec					type_mismatch
.1a4bec	08		php		            PHP
.1a4bed	c2 20		rep #$20	            REP #$20
.1a4bef	48		pha		            PHA
.1a4bf0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4bf3	5b		tcd		            TCD
.1a4bf4	68		pla		            PLA
.1a4bf5	28		plp		            PLP
.1a4bf6	e2 20		sep #$20	            SEP #$20
.1a4bf8	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4bfa	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4bfe	c2 20		rep #$20	            REP #$20
.1a4c00	29 ff 00	and #$00ff	            AND #$00FF
.1a4c03	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4c06	e2 20		sep #$20	            SEP #$20
.1a4c08	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4c0b					FN_ASC
.1a4c0b	e2 20		sep #$20	            SEP #$20
.1a4c0d	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4c0f	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4c12	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4c15	e2 20		sep #$20	            SEP #$20
.1a4c17	a5 27		lda $0827	                LDA ARGTYPE1
.1a4c19	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4c1b	d0 14		bne $1a4c31	                BNE type_mismatch
.1a4c1d	a7 23		lda [$0823]	                LDA [ARGUMENT1]     ; Get the character
.1a4c1f	85 23		sta $0823	                STA ARGUMENT1       ; Save its code to ARGUMENT1
.1a4c21	64 24		stz $0824	                STZ ARGUMENT1+1
.1a4c23	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4c25	64 26		stz $0826	                STZ ARGUMENT1+3
.1a4c27	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the return type to integer
.1a4c29	85 27		sta $0827	                STA ARGTYPE1
.1a4c2b	e2 20		sep #$20	            SEP #$20
.1a4c2d	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4c30	60		rts		            RTS
.1a4c31					type_mismatch
.1a4c31	08		php		            PHP
.1a4c32	c2 20		rep #$20	            REP #$20
.1a4c34	48		pha		            PHA
.1a4c35	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4c38	5b		tcd		            TCD
.1a4c39	68		pla		            PLA
.1a4c3a	28		plp		            PLP
.1a4c3b	e2 20		sep #$20	            SEP #$20
.1a4c3d	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4c3f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4c43	c2 20		rep #$20	            REP #$20
.1a4c45	29 ff 00	and #$00ff	            AND #$00FF
.1a4c48	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4c4b	e2 20		sep #$20	            SEP #$20
.1a4c4d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4c50					FN_SPC
.1a4c50	e2 20		sep #$20	            SEP #$20
.1a4c52	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4c54	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4c57	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4c5a	e2 20		sep #$20	            SEP #$20
.1a4c5c	a5 27		lda $0827	                LDA ARGTYPE1
.1a4c5e	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4c60	d0 39		bne $1a4c9b	                BNE type_mismatch
.1a4c62	e2 20		sep #$20	            SEP #$20
.1a4c64	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.1a4c66	d0 52		bne $1a4cba	                BNE err_limit
.1a4c68	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4c6a	d0 4e		bne $1a4cba	                BNE err_limit
.1a4c6c	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a4c6e	d0 4a		bne $1a4cba	                BNE err_limit
.1a4c70	c2 10		rep #$10	            REP #$10
.1a4c72	20 4b 14	jsr $1a144b	            JSR TEMPSTRING
.1a4c75	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.1a4c77	e2 20		sep #$20	            SEP #$20
.1a4c79	a9 00		lda #$00	                LDA #0
.1a4c7b	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.1a4c7d	88		dey		                DEY
.1a4c7e	30 07		bmi $1a4c87	                BMI done
.1a4c80	a9 20		lda #$20	                LDA #CHAR_SP
.1a4c82	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.1a4c84	88		dey		                DEY
.1a4c85	10 fb		bpl $1a4c82	                BPL loop            ; And keep writing until we're done
.1a4c87	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.1a4c89	85 27		sta $0827	                STA ARGTYPE1
.1a4c8b	c2 20		rep #$20	            REP #$20
.1a4c8d	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.1a4c8f	85 23		sta $0823	                STA ARGUMENT1
.1a4c91	a5 18		lda $0818	                LDA STRPTR+2
.1a4c93	85 25		sta $0825	                STA ARGUMENT1+2
.1a4c95	e2 20		sep #$20	            SEP #$20
.1a4c97	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4c9a	60		rts		            RTS
.1a4c9b					type_mismatch
.1a4c9b	08		php		            PHP
.1a4c9c	c2 20		rep #$20	            REP #$20
.1a4c9e	48		pha		            PHA
.1a4c9f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4ca2	5b		tcd		            TCD
.1a4ca3	68		pla		            PLA
.1a4ca4	28		plp		            PLP
.1a4ca5	e2 20		sep #$20	            SEP #$20
.1a4ca7	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4ca9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4cad	c2 20		rep #$20	            REP #$20
.1a4caf	29 ff 00	and #$00ff	            AND #$00FF
.1a4cb2	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4cb5	e2 20		sep #$20	            SEP #$20
.1a4cb7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4cba					err_limit
.1a4cba	08		php		            PHP
.1a4cbb	c2 20		rep #$20	            REP #$20
.1a4cbd	48		pha		            PHA
.1a4cbe	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4cc1	5b		tcd		            TCD
.1a4cc2	68		pla		            PLA
.1a4cc3	28		plp		            PLP
.1a4cc4	e2 20		sep #$20	            SEP #$20
.1a4cc6	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4cc8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4ccc	c2 20		rep #$20	            REP #$20
.1a4cce	29 ff 00	and #$00ff	            AND #$00FF
.1a4cd1	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4cd4	e2 20		sep #$20	            SEP #$20
.1a4cd6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4cd9					FN_TAB
.1a4cd9	e2 20		sep #$20	            SEP #$20
.1a4cdb	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4cdd	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4ce0	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4ce3	e2 20		sep #$20	            SEP #$20
.1a4ce5	a5 27		lda $0827	                LDA ARGTYPE1
.1a4ce7	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4ce9	d0 39		bne $1a4d24	                BNE type_mismatch
.1a4ceb	e2 20		sep #$20	            SEP #$20
.1a4ced	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.1a4cef	d0 52		bne $1a4d43	                BNE err_limit
.1a4cf1	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4cf3	d0 4e		bne $1a4d43	                BNE err_limit
.1a4cf5	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a4cf7	d0 4a		bne $1a4d43	                BNE err_limit
.1a4cf9	c2 10		rep #$10	            REP #$10
.1a4cfb	20 4b 14	jsr $1a144b	            JSR TEMPSTRING
.1a4cfe	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.1a4d00	e2 20		sep #$20	            SEP #$20
.1a4d02	a9 00		lda #$00	                LDA #0
.1a4d04	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.1a4d06	88		dey		                DEY
.1a4d07	30 07		bmi $1a4d10	                BMI done
.1a4d09	a9 09		lda #$09	                LDA #CHAR_TAB
.1a4d0b	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.1a4d0d	88		dey		                DEY
.1a4d0e	10 fb		bpl $1a4d0b	                BPL loop            ; And keep writing until we're done
.1a4d10	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.1a4d12	85 27		sta $0827	                STA ARGTYPE1
.1a4d14	c2 20		rep #$20	            REP #$20
.1a4d16	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.1a4d18	85 23		sta $0823	                STA ARGUMENT1
.1a4d1a	a5 18		lda $0818	                LDA STRPTR+2
.1a4d1c	85 25		sta $0825	                STA ARGUMENT1+2
.1a4d1e	e2 20		sep #$20	            SEP #$20
.1a4d20	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4d23	60		rts		            RTS
.1a4d24					type_mismatch
.1a4d24	08		php		            PHP
.1a4d25	c2 20		rep #$20	            REP #$20
.1a4d27	48		pha		            PHA
.1a4d28	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4d2b	5b		tcd		            TCD
.1a4d2c	68		pla		            PLA
.1a4d2d	28		plp		            PLP
.1a4d2e	e2 20		sep #$20	            SEP #$20
.1a4d30	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4d32	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4d36	c2 20		rep #$20	            REP #$20
.1a4d38	29 ff 00	and #$00ff	            AND #$00FF
.1a4d3b	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4d3e	e2 20		sep #$20	            SEP #$20
.1a4d40	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4d43					err_limit
.1a4d43	08		php		            PHP
.1a4d44	c2 20		rep #$20	            REP #$20
.1a4d46	48		pha		            PHA
.1a4d47	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4d4a	5b		tcd		            TCD
.1a4d4b	68		pla		            PLA
.1a4d4c	28		plp		            PLP
.1a4d4d	e2 20		sep #$20	            SEP #$20
.1a4d4f	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4d51	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4d55	c2 20		rep #$20	            REP #$20
.1a4d57	29 ff 00	and #$00ff	            AND #$00FF
.1a4d5a	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4d5d	e2 20		sep #$20	            SEP #$20
.1a4d5f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4d62					FN_ABS
.1a4d62	e2 20		sep #$20	            SEP #$20
.1a4d64	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4d66	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4d69	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4d6c	e2 20		sep #$20	            SEP #$20
.1a4d6e	a5 27		lda $0827	                LDA ARGTYPE1        ; Check the type
.1a4d70	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4d72	f0 23		beq $1a4d97	                BEQ abs_int         ; If integer, get the absolute value of the integer
.1a4d74	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.1a4d76	f0 3e		beq $1a4db6	                BEQ abs_float       ; If float, get the absolute value of the float
.1a4d78					type_err
.1a4d78	08		php		            PHP
.1a4d79	c2 20		rep #$20	            REP #$20
.1a4d7b	48		pha		            PHA
.1a4d7c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4d7f	5b		tcd		            TCD
.1a4d80	68		pla		            PLA
.1a4d81	28		plp		            PLP
.1a4d82	e2 20		sep #$20	            SEP #$20
.1a4d84	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4d86	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4d8a	c2 20		rep #$20	            REP #$20
.1a4d8c	29 ff 00	and #$00ff	            AND #$00FF
.1a4d8f	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4d92	e2 20		sep #$20	            SEP #$20
.1a4d94	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4d97					abs_int
.1a4d97	c2 20		rep #$20	            REP #$20
.1a4d99	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Is it positive already?
.1a4d9b	10 21		bpl $1a4dbe	                BPL done            ; Yes: we don't need to do anythign further
.1a4d9d	49 ff ff	eor #$ffff	                EOR #$FFFF          ; Otherwise, take the two's compliment
.1a4da0	85 25		sta $0825	                STA ARGUMENT1+2     ; Of ARGUMENT1
.1a4da2	a5 23		lda $0823	                LDA ARGUMENT1
.1a4da4	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a4da7	18		clc		                CLC
.1a4da8	69 01 00	adc #$0001	                ADC #1
.1a4dab	85 23		sta $0823	                STA ARGUMENT1       ; And save it back to ARGUMENT1
.1a4dad	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4daf	69 00 00	adc #$0000	                ADC #0
.1a4db2	85 25		sta $0825	                STA ARGUMENT1+2
.1a4db4	80 08		bra $1a4dbe	                BRA done
.1a4db6					abs_float
.1a4db6	e2 20		sep #$20	            SEP #$20
.1a4db8	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Just clear the sign bit
.1a4dba	29 7f		and #$7f	                AND #$7F
.1a4dbc	85 26		sta $0826	                STA ARGUMENT1+3
.1a4dbe					done
.1a4dbe	e2 20		sep #$20	            SEP #$20
.1a4dc0	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4dc3	60		rts		            RTS
.1a4dc4					FN_SGN
.1a4dc4	e2 20		sep #$20	            SEP #$20
.1a4dc6	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4dc8	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4dcb	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4dce	e2 20		sep #$20	            SEP #$20
.1a4dd0	a5 27		lda $0827	                LDA ARGTYPE1
.1a4dd2	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4dd4	d0 25		bne $1a4dfb	                BNE type_mismatch
.1a4dd6	c2 20		rep #$20	            REP #$20
.1a4dd8	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4dda	30 12		bmi $1a4dee	                BMI is_negative     ; Negative: return -1
.1a4ddc	d0 04		bne $1a4de2	                BNE is_positive     ; Is it not 0? Then return 1
.1a4dde	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the lower word 0?
.1a4de0	f0 13		beq $1a4df5	                BEQ done            ; Yes: the whole thing is zero: return 0
.1a4de2	a9 00 00	lda #$0000	is_positive     LDA #0              ; It's positive: return 1
.1a4de5	85 25		sta $0825	                STA ARGUMENT1+2
.1a4de7	a9 01 00	lda #$0001	                LDA #1
.1a4dea	85 23		sta $0823	                STA ARGUMENT1
.1a4dec	80 07		bra $1a4df5	                BRA done
.1a4dee	a9 ff ff	lda #$ffff	is_negative     LDA #$FFFF          ; It's negative: return -1
.1a4df1	85 25		sta $0825	                STA ARGUMENT1+2
.1a4df3	85 23		sta $0823	                STA ARGUMENT1
.1a4df5					done
.1a4df5	e2 20		sep #$20	            SEP #$20
.1a4df7	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4dfa	60		rts		            RTS
.1a4dfb					type_mismatch
.1a4dfb	08		php		            PHP
.1a4dfc	c2 20		rep #$20	            REP #$20
.1a4dfe	48		pha		            PHA
.1a4dff	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4e02	5b		tcd		            TCD
.1a4e03	68		pla		            PLA
.1a4e04	28		plp		            PLP
.1a4e05	e2 20		sep #$20	            SEP #$20
.1a4e07	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4e09	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4e0d	c2 20		rep #$20	            REP #$20
.1a4e0f	29 ff 00	and #$00ff	            AND #$00FF
.1a4e12	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4e15	e2 20		sep #$20	            SEP #$20
.1a4e17	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4e1a					FN_INT
.1a4e1a	e2 20		sep #$20	            SEP #$20
.1a4e1c	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4e1e	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4e21	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4e24	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a4e27					done
.1a4e27	e2 20		sep #$20	            SEP #$20
.1a4e29	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4e2c	60		rts		            RTS
.1a4e2d					FN_SIN
.1a4e2d	e2 20		sep #$20	            SEP #$20
.1a4e2f	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4e31	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4e34	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4e37	20 0e 07	jsr $1a070e	            JSR ASS_ARG1_FLOAT
.1a4e3a	20 eb 60	jsr $1a60eb	            JSR FP_SIN
.1a4e3d					done
.1a4e3d	e2 20		sep #$20	            SEP #$20
.1a4e3f	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4e42	60		rts		            RTS
.1a4e43					FN_COS
.1a4e43	e2 20		sep #$20	            SEP #$20
.1a4e45	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4e47	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4e4a	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4e4d	20 0e 07	jsr $1a070e	            JSR ASS_ARG1_FLOAT
.1a4e50	20 1a 61	jsr $1a611a	            JSR FP_COS
.1a4e53					done
.1a4e53	e2 20		sep #$20	            SEP #$20
.1a4e55	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4e58	60		rts		            RTS
.1a4e59					FN_TAN
.1a4e59	e2 20		sep #$20	            SEP #$20
.1a4e5b	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4e5d	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4e60	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4e63	20 0e 07	jsr $1a070e	            JSR ASS_ARG1_FLOAT
.1a4e66	20 49 61	jsr $1a6149	            JSR FP_TAN
.1a4e69					done
.1a4e69	e2 20		sep #$20	            SEP #$20
.1a4e6b	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4e6e	60		rts		            RTS
.1a4e6f					FN_LN
.1a4e6f	e2 20		sep #$20	            SEP #$20
.1a4e71	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4e73	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4e76	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4e79	20 0e 07	jsr $1a070e	            JSR ASS_ARG1_FLOAT
.1a4e7c	20 77 61	jsr $1a6177	            JSR FP_LN
.1a4e7f					done
.1a4e7f	e2 20		sep #$20	            SEP #$20
.1a4e81	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4e84	60		rts		            RTS
.1a4e85					FN_ACOS
.1a4e85	e2 20		sep #$20	            SEP #$20
.1a4e87	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4e89	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4e8c	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4e8f	20 0e 07	jsr $1a070e	            JSR ASS_ARG1_FLOAT
.1a4e92	20 a0 62	jsr $1a62a0	            JSR FP_ACOS
.1a4e95					done
.1a4e95	e2 20		sep #$20	            SEP #$20
.1a4e97	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4e9a	60		rts		            RTS
.1a4e9b					FN_ASIN
.1a4e9b	e2 20		sep #$20	            SEP #$20
.1a4e9d	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4e9f	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4ea2	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4ea5	20 0e 07	jsr $1a070e	            JSR ASS_ARG1_FLOAT
.1a4ea8	20 76 62	jsr $1a6276	            JSR FP_ASIN
.1a4eab					done
.1a4eab	e2 20		sep #$20	            SEP #$20
.1a4ead	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4eb0	60		rts		            RTS
.1a4eb1					FN_ATAN
.1a4eb1	e2 20		sep #$20	            SEP #$20
.1a4eb3	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4eb5	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4eb8	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4ebb	20 0e 07	jsr $1a070e	            JSR ASS_ARG1_FLOAT
.1a4ebe	20 c2 62	jsr $1a62c2	            JSR FP_ATAN
.1a4ec1					done
.1a4ec1	e2 20		sep #$20	            SEP #$20
.1a4ec3	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4ec6	60		rts		            RTS
.1a4ec7					FN_EXP
.1a4ec7	e2 20		sep #$20	            SEP #$20
.1a4ec9	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4ecb	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4ece	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4ed1	20 0e 07	jsr $1a070e	            JSR ASS_ARG1_FLOAT
.1a4ed4	20 56 63	jsr $1a6356	            JSR FP_EXP
.1a4ed7					done
.1a4ed7	e2 20		sep #$20	            SEP #$20
.1a4ed9	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4edc	60		rts		            RTS
.1a4edd					FN_SQR
.1a4edd	e2 20		sep #$20	            SEP #$20
.1a4edf	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4ee1	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4ee4	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a4ee7	20 0e 07	jsr $1a070e	            JSR ASS_ARG1_FLOAT
.1a4eea	20 d8 63	jsr $1a63d8	            JSR FP_SQR
.1a4eed					done
.1a4eed	e2 20		sep #$20	            SEP #$20
.1a4eef	20 67 20	jsr $1a2067	            JSR INCBIP
.1a4ef2	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\commands.s

.1a4ef3	00		brk #		CMD_MONITOR     BRK
.1a4ef4	ea		nop		                NOP
.1a4ef5	60		rts		            RTS
.1a4ef6					CMD_NEW
.1a4ef6	08		php		                PHP
.1a4ef7	0b		phd		                PHD
.1a4ef8	08		php		            PHP
.1a4ef9	c2 20		rep #$20	            REP #$20
.1a4efb	48		pha		            PHA
.1a4efc	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a4eff	5b		tcd		            TCD
.1a4f00	68		pla		            PLA
.1a4f01	28		plp		            PLP
.1a4f02	c2 30		rep #$30	            REP #$30
.1a4f04	c2 20		rep #$20	            REP #$20
.1a4f06	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.1a4f09	85 d9		sta $08d9	            STA LASTLINE
.1a4f0b	e2 20		sep #$20	            SEP #$20
.1a4f0d	a9 16		lda #$16	            LDA #`BASIC_BOT
.1a4f0f	85 db		sta $08db	            STA LASTLINE+2
.1a4f11	c2 30		rep #$30	            REP #$30
.1a4f13	a9 00 00	lda #$0000	                LDA #0
.1a4f16	a0 00 00	ldy #$0000	                LDY #LINE_LINK
.1a4f19	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.1a4f1b	a0 02 00	ldy #$0002	                LDY #LINE_NUMBER
.1a4f1e	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.1a4f20	a0 04 00	ldy #$0004	                LDY #LINE_TOKENS
.1a4f23	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.1a4f25	20 3d 20	jsr $1a203d	            JSR CLRINTERP
.1a4f28	2b		pld		                PLD
.1a4f29	28		plp		                PLP
.1a4f2a	60		rts		            RTS
.1a4f2b					CMD_RUN
.1a4f2b	8b		phb		                PHB
.1a4f2c	08		php		                PHP
.1a4f2d	c2 20		rep #$20	            REP #$20
.1a4f2f	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT            ; Point to the first line of the program
.1a4f32	85 1a		sta $081a	                STA CURLINE
.1a4f34	a9 16 00	lda #$0016	                LDA #`BASIC_BOT
.1a4f37	85 1c		sta $081c	                STA CURLINE + 2
.1a4f39	20 3d 20	jsr $1a203d	            JSR CLRINTERP
.1a4f3c	20 1d 23	jsr $1a231d	            JSR EXECPROGRAM
.1a4f3f	28		plp		                PLP
.1a4f40	ab		plb		                PLB
.1a4f41	60		rts		            RTS
.1a4f42					CMD_LIST
.1a4f42	08		php		                PHP
.1a4f43	c2 20		rep #$20	            REP #$20
.1a4f45	64 55		stz $0855	                STZ MARG1               ; MARG1 is starting line number, default 0
.1a4f47	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.1a4f4a	85 59		sta $0859	                STA MARG2               ; MARG2 is ending line number, default MAXINT
.1a4f4c	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a4f4f	20 c8 21	jsr $1a21c8	            JSR PEEK_TOK
.1a4f52	29 ff 00	and #$00ff	                AND #$00FF
.1a4f55	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.1a4f58	f0 2c		beq $1a4f86	                BEQ call_list           ; ... just list with the defaults
.1a4f5a	c9 81 00	cmp #$0081	                CMP #TOK_MINUS          ; If just "- ###"...
.1a4f5d	f0 1a		beq $1a4f79	                BEQ parse_endline       ; ... try to parse the end line number
.1a4f5f	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a4f62	20 27 08	jsr $1a0827	            JSR PARSEINT
.1a4f65	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG1
.1a4f67	85 55		sta $0855	                STA MARG1
.1a4f69	20 c8 21	jsr $1a21c8	            JSR PEEK_TOK
.1a4f6c	29 ff 00	and #$00ff	                AND #$00FF
.1a4f6f	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.1a4f72	f0 12		beq $1a4f86	                BEQ call_list           ; ... just list with the defaults
.1a4f74	c9 81 00	cmp #$0081	                CMP #TOK_MINUS
.1a4f77	d0 2a		bne $1a4fa3	                BNE error               ; At this point, if not '-', it's a syntax error
.1a4f79					parse_endline
.1a4f79	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a4f7c	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a4f7f	20 27 08	jsr $1a0827	            JSR PARSEINT
.1a4f82	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG2
.1a4f84	85 59		sta $0859	                STA MARG2
.1a4f86	a5 1c		lda $081c	call_list       LDA CURLINE+2           ; Save CURLINE
.1a4f88	48		pha		                PHA
.1a4f89	a5 1a		lda $081a	                LDA CURLINE
.1a4f8b	48		pha		                PHA
.1a4f8c	a5 02		lda $0802	                LDA BIP+2               ; Save BIP
.1a4f8e	48		pha		                PHA
.1a4f8f	a5 00		lda $0800	                LDA BIP
.1a4f91	48		pha		                PHA
.1a4f92	20 d5 17	jsr $1a17d5	            JSR LISTPROG
.1a4f95	68		pla		                PLA
.1a4f96	85 00		sta $0800	                STA BIP
.1a4f98	68		pla		                PLA
.1a4f99	85 02		sta $0802	                STA BIP+2
.1a4f9b	68		pla		                PLA
.1a4f9c	85 1a		sta $081a	                STA CURLINE
.1a4f9e	68		pla		                PLA
.1a4f9f	85 1c		sta $081c	                STA CURLINE+2
.1a4fa1	28		plp		                PLP
.1a4fa2	60		rts		            RTS
.1a4fa3					error
.1a4fa3	08		php		            PHP
.1a4fa4	c2 20		rep #$20	            REP #$20
.1a4fa6	48		pha		            PHA
.1a4fa7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4faa	5b		tcd		            TCD
.1a4fab	68		pla		            PLA
.1a4fac	28		plp		            PLP
.1a4fad	e2 20		sep #$20	            SEP #$20
.1a4faf	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4fb1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4fb5	c2 20		rep #$20	            REP #$20
.1a4fb7	29 ff 00	and #$00ff	            AND #$00FF
.1a4fba	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a4fbd	e2 20		sep #$20	            SEP #$20
.1a4fbf	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]

;******  Return to file: src\basic816.s


;******  Processing file: src\variables.s

>08e1					NEXTVAR         .long ?         ; Pointer to the the next available byte for variable bindings
>08e4					VARIABLES       .long ?         ; Pointer to the most recently allocated variable
>08e7					TOFIND          .long ?         ; Pointer to the variable name to find
>08ea					TOFINDTYPE      .byte ?         ; The type to find
.0000					BINDING
>0000					TYPE            .fill 1                 ; The type of the data stored in the variable
>0001					NAME            .fill VAR_NAME_SIZE     ; The name of the variable
>0009					VALUE           .fill 4                 ; The data stored in the variable
>000d					NEXT            .fill 3                 ; The pointer to the next allocated variable of this type
.1a4fc2					INITVARS
.1a4fc2	08		php		                PHP
.1a4fc3	08		php		            PHP
.1a4fc4	c2 20		rep #$20	            REP #$20
.1a4fc6	48		pha		            PHA
.1a4fc7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4fca	5b		tcd		            TCD
.1a4fcb	68		pla		            PLA
.1a4fcc	28		plp		            PLP
.1a4fcd	c2 20		rep #$20	            REP #$20
.1a4fcf	64 e4		stz $08e4	                STZ VARIABLES           ; Clear the pointer to the variables
.1a4fd1	64 e7		stz $08e7	                STZ TOFIND
.1a4fd3	e2 20		sep #$20	            SEP #$20
.1a4fd5	64 e6		stz $08e6	                STZ VARIABLES+2
.1a4fd7	64 e9		stz $08e9	                STZ TOFIND+2
.1a4fd9	64 ea		stz $08ea	                STZ TOFINDTYPE
.1a4fdb	c2 20		rep #$20	            REP #$20
.1a4fdd	38		sec		                SEC                     ; Compute the position of the first variable
.1a4fde	a5 d9		lda $08d9	                LDA LASTLINE
.1a4fe0	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.1a4fe3	85 e1		sta $08e1	                STA NEXTVAR
.1a4fe5	e2 20		sep #$20	            SEP #$20
.1a4fe7	a5 db		lda $08db	                LDA LASTLINE+2
.1a4fe9	69 00		adc #$00	                ADC #0
.1a4feb	85 e3		sta $08e3	                STA NEXTVAR+2
.1a4fed	28		plp		                PLP
.1a4fee	60		rts		            RTS
.1a4fef					ISVARCHAR
.1a4fef	c9 5f		cmp #$5f	                CMP #'_'            ; Check if it's an underscore
.1a4ff1	f0 1a		beq $1a500d	                BEQ return_true     ; Yes: return true
.1a4ff3	c9 3a		cmp #$3a	                CMP #'9'+1          ; Check if its in [0-9]
.1a4ff5	b0 04		bcs $1a4ffb	                BGE else1           ; No: check something else
.1a4ff7	c9 30		cmp #$30	                CMP #'0'
.1a4ff9	b0 12		bcs $1a500d	                BGE return_true     ; Yes: return true
.1a4ffb	c9 5b		cmp #$5b	else1           CMP #'Z'+1          ; Check if its in [A-Z]
.1a4ffd	b0 04		bcs $1a5003	                BGE not_upper       ; No: check lower case
.1a4fff	c9 41		cmp #$41	                CMP #'A'
.1a5001	b0 0a		bcs $1a500d	                BGE return_true     ; Yes: return true
.1a5003	c9 7b		cmp #$7b	not_upper       CMP #'z'+1          ; Check if its in [a-z]
.1a5005	b0 04		bcs $1a500b	                BGE return_false    ; No: return false
.1a5007	c9 61		cmp #$61	                CMP #'a'
.1a5009	b0 02		bcs $1a500d	                BGE return_true     ; Yes: return true
.1a500b	18		clc		return_false    CLC
.1a500c	60		rts		            RTS
.1a500d	38		sec		return_true     SEC
.1a500e	60		rts		            RTS
.1a500f					VARNAMECMP
.1a500f	08		php		                PHP
.1a5010	e2 20		sep #$20	            SEP #$20
.1a5012	c2 10		rep #$10	            REP #$10
.1a5014	a0 00 00	ldy #$0000	                LDY #0
.1a5017	b7 0c		lda [$080c],y	cmp_loop        LDA [SCRATCH],Y         ; Check the character in the variable name
.1a5019	f0 0a		beq $1a5025	                BEQ is_end
.1a501b	d7 e7		cmp [$08e7],y	                CMP [TOFIND],Y          ; Compare the character to the one TOFIND
.1a501d	d0 13		bne $1a5032	                BNE return_false        ; Not equal? Then this is not a match
.1a501f	c8		iny		                INY
.1a5020	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.1a5023	d0 f2		bne $1a5017	                BNE cmp_loop
.1a5025	b7 e7		lda [$08e7],y	is_end          LDA [TOFIND],Y          ; Check the character in the name to find
.1a5027	20 a5 04	jsr $1a04a5	            JSR TOUPPERA
.1a502a	20 ef 4f	jsr $1a4fef	            JSR ISVARCHAR
.1a502d	b0 03		bcs $1a5032	                BCS return_false        ; YES: we do not have a match
.1a502f					return_true
.1a502f	28		plp		                PLP
.1a5030	38		sec		                SEC
.1a5031	60		rts		            RTS
.1a5032					return_false
.1a5032	28		plp		                PLP
.1a5033	18		clc		                CLC
.1a5034	60		rts		            RTS
.1a5035					VAR_FIND
.1a5035	08		php		                PHP
.1a5036	e2 20		sep #$20	            SEP #$20
.1a5038	c2 10		rep #$10	            REP #$10
.1a503a	a0 00 00	ldy #$0000	                LDY #0
.1a503d	a2 00 00	ldx #$0000	                LDX #0
.1a5040	b7 e7		lda [$08e7],y	upper_loop      LDA [TOFIND],Y          ; Get a character
.1a5042	f0 0b		beq $1a504f	                BEQ done_upper
.1a5044	20 a5 04	jsr $1a04a5	            JSR TOUPPERA
.1a5047	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; And save it to the temp
.1a504b	c8		iny		                INY
.1a504c	e8		inx		                INX
.1a504d	80 f1		bra $1a5040	                BRA upper_loop          ; Go back for another
.1a504f	a9 00		lda #$00	done_upper      LDA #0
.1a5051	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; NULL terminate the temporary string
.1a5055	c2 20		rep #$20	            REP #$20
.1a5057	a9 00 4e	lda #$4e00	                LDA #<>TEMPBUF          ; Make the temporary string the string
.1a505a	85 e7		sta $08e7	                STA TOFIND              ; the variable name to find
.1a505c	e2 20		sep #$20	            SEP #$20
.1a505e	a9 00		lda #$00	                LDA #`TEMPBUF
.1a5060	85 e9		sta $08e9	                STA TOFIND+2
.1a5062	c2 20		rep #$20	            REP #$20
.1a5064	a5 e4		lda $08e4	                LDA VARIABLES           ; Point INDEX to the first variable to check
.1a5066	85 08		sta $0808	                STA INDEX
.1a5068	d0 06		bne $1a5070	                BNE set_index_h         ; If the low word is not 0, copy the high byte
.1a506a	e2 20		sep #$20	            SEP #$20
.1a506c	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a506e	f0 4d		beq $1a50bd	                BEQ not_found           ; If it is, we have no variables yet.
.1a5070					set_index_h
.1a5070	e2 20		sep #$20	            SEP #$20
.1a5072	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a5074	85 0a		sta $080a	                STA INDEX+2
.1a5076	a5 ea		lda $08ea	check_binding   LDA TOFINDTYPE
.1a5078	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Get the type of the variable
.1a507b	d7 08		cmp [$0808],y	                CMP [INDEX],Y
.1a507d	d0 17		bne $1a5096	                BNE check_next          ; If it's not a match, check the next binding
.1a507f	c2 20		rep #$20	            REP #$20
.1a5081	18		clc		                CLC
.1a5082	a5 08		lda $0808	                LDA INDEX
.1a5084	69 01 00	adc #$0001	                ADC #BINDING.NAME
.1a5087	85 0c		sta $080c	                STA SCRATCH
.1a5089	e2 20		sep #$20	            SEP #$20
.1a508b	a5 0a		lda $080a	                LDA INDEX+2
.1a508d	69 00		adc #$00	                ADC #0
.1a508f	85 0e		sta $080e	                STA SCRATCH+2
.1a5091	20 0f 50	jsr $1a500f	            JSR VARNAMECMP
.1a5094	b0 2a		bcs $1a50c0	                BCS found               ; If they match, return that we've found the variable
.1a5096	a0 0d 00	ldy #$000d	check_next      LDY #BINDING.NEXT       ; SCRATCH := [INDEX].NEXT
.1a5099	c2 20		rep #$20	            REP #$20
.1a509b	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a509d	85 0c		sta $080c	                STA SCRATCH
.1a509f	c8		iny		                INY
.1a50a0	c8		iny		                INY
.1a50a1	e2 20		sep #$20	            SEP #$20
.1a50a3	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a50a5	85 0e		sta $080e	                STA SCRATCH+2
.1a50a7	d0 06		bne $1a50af	                BNE set_index           ; If SCRATCH == 0, the variable wasn't found
.1a50a9	c2 20		rep #$20	            REP #$20
.1a50ab	a5 0c		lda $080c	                LDA SCRATCH
.1a50ad	f0 0e		beq $1a50bd	                BEQ not_found
.1a50af					set_index
.1a50af	c2 20		rep #$20	            REP #$20
.1a50b1	a5 0c		lda $080c	                LDA SCRATCH
.1a50b3	85 08		sta $0808	                STA INDEX
.1a50b5	e2 20		sep #$20	            SEP #$20
.1a50b7	a5 0e		lda $080e	                LDA SCRATCH+2
.1a50b9	85 0a		sta $080a	                STA INDEX+2
.1a50bb	80 b9		bra $1a5076	                BRA check_binding       ; And check this next variable for a match
.1a50bd					not_found
.1a50bd	28		plp		                PLP
.1a50be	18		clc		                CLC
.1a50bf	60		rts		            RTS
.1a50c0					found
.1a50c0	28		plp		                PLP
.1a50c1	38		sec		                SEC
.1a50c2	60		rts		            RTS
.1a50c3					VAR_REF
.1a50c3	08		php		                PHP
.1a50c4	20 35 50	jsr $1a5035	            JSR VAR_FIND
.1a50c7	b0 1f		bcs $1a50e8	                BCS found
.1a50c9	08		php		            PHP
.1a50ca	c2 20		rep #$20	            REP #$20
.1a50cc	48		pha		            PHA
.1a50cd	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a50d0	5b		tcd		            TCD
.1a50d1	68		pla		            PLA
.1a50d2	28		plp		            PLP
.1a50d3	e2 20		sep #$20	            SEP #$20
.1a50d5	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a50d7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a50db	c2 20		rep #$20	            REP #$20
.1a50dd	29 ff 00	and #$00ff	            AND #$00FF
.1a50e0	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a50e3	e2 20		sep #$20	            SEP #$20
.1a50e5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a50e8					found
.1a50e8	c2 30		rep #$30	            REP #$30
.1a50ea	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.1a50ed	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a50ef	85 23		sta $0823	                STA ARGUMENT1
.1a50f1	c8		iny		                INY
.1a50f2	c8		iny		                INY
.1a50f3	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a50f5	85 25		sta $0825	                STA ARGUMENT1+2
.1a50f7	e2 20		sep #$20	            SEP #$20
.1a50f9	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE
.1a50fc	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a50fe	85 27		sta $0827	                STA ARGTYPE1
.1a5100	28		plp		done            PLP
.1a5101	60		rts		            RTS
.1a5102					VAR_ALLOC
.1a5102	08		php		                PHP
.1a5103	c2 20		rep #$20	            REP #$20
.1a5105	18		clc		                CLC                     ; Compute extent of the binding
.1a5106	a5 e1		lda $08e1	                LDA NEXTVAR
.1a5108	69 10 00	adc #$0010	                ADC #size(BINDING)
.1a510b	85 08		sta $0808	                STA INDEX
.1a510d	e2 20		sep #$20	            SEP #$20
.1a510f	a5 e3		lda $08e3	                LDA NEXTVAR+2
.1a5111	69 00		adc #$00	                ADC #0
.1a5113	85 0a		sta $080a	                STA INDEX+2
.1a5115	c5 bc		cmp $08bc	                CMP HEAP+2              ; Check to see if HEAP > INDEX
.1a5117	90 27		bcc $1a5140	                BLT has_room
.1a5119	c2 20		rep #$20	            REP #$20
.1a511b	a5 08		lda $0808	                LDA INDEX
.1a511d	c5 ba		cmp $08ba	                CMP HEAP
.1a511f	90 1f		bcc $1a5140	                BLT has_room
.1a5121	08		php		            PHP
.1a5122	c2 20		rep #$20	            REP #$20
.1a5124	48		pha		            PHA
.1a5125	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5128	5b		tcd		            TCD
.1a5129	68		pla		            PLA
.1a512a	28		plp		            PLP
.1a512b	e2 20		sep #$20	            SEP #$20
.1a512d	a9 09		lda #$09	            LDA #ERR_RANGE
.1a512f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5133	c2 20		rep #$20	            REP #$20
.1a5135	29 ff 00	and #$00ff	            AND #$00FF
.1a5138	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a513b	e2 20		sep #$20	            SEP #$20
.1a513d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5140					has_room
.1a5140	c2 20		rep #$20	            REP #$20
.1a5142	a5 e1		lda $08e1	                LDA NEXTVAR             ; Yes: we can allocate the variable
.1a5144	85 c0		sta $08c0	                STA CURRBLOCK           ; Point CURRBLOCK to it
.1a5146	e2 20		sep #$20	            SEP #$20
.1a5148	a5 e3		lda $08e3	                LDA NEXTVAR+2
.1a514a	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a514c	c2 20		rep #$20	            REP #$20
.1a514e	a5 08		lda $0808	                LDA INDEX               ; And point NEXTVAR to the next possible spot
.1a5150	85 e1		sta $08e1	                STA NEXTVAR
.1a5152	e2 20		sep #$20	            SEP #$20
.1a5154	a5 0a		lda $080a	                LDA INDEX+2
.1a5156	85 e3		sta $08e3	                STA NEXTVAR+2
.1a5158	28		plp		                PLP
.1a5159	60		rts		            RTS
.1a515a					VAR_CREATE
.1a515a	08		php		                PHP
.1a515b	e2 20		sep #$20	            SEP #$20
.1a515d	a5 27		lda $0827	                LDA ARGTYPE1            ; Validate that our types match
.1a515f	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.1a5161	f0 33		beq $1a5196	                BEQ chk_string          ; If so: check to see if it's a string
.1a5163	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable type
.1a5165	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's INTEGER
.1a5167	d0 05		bne $1a516e	                BNE chk_float
.1a5169	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a516c	80 2f		bra $1a519d	                BRA alloc_binding       ; And bind the variable
.1a516e	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; If it's FLOAT
.1a5170	d0 05		bne $1a5177	                BNE type_error
.1a5172	20 0e 07	jsr $1a070e	            JSR ASS_ARG1_FLOAT
.1a5175	80 26		bra $1a519d	                BRA alloc_binding       ; And bind the variable
.1a5177					type_error
.1a5177	08		php		            PHP
.1a5178	c2 20		rep #$20	            REP #$20
.1a517a	48		pha		            PHA
.1a517b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a517e	5b		tcd		            TCD
.1a517f	68		pla		            PLA
.1a5180	28		plp		            PLP
.1a5181	e2 20		sep #$20	            SEP #$20
.1a5183	a9 04		lda #$04	            LDA #ERR_TYPE
.1a5185	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5189	c2 20		rep #$20	            REP #$20
.1a518b	29 ff 00	and #$00ff	            AND #$00FF
.1a518e	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a5191	e2 20		sep #$20	            SEP #$20
.1a5193	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5196	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING        ; Is it a string?
.1a5198	d0 03		bne $1a519d	                BNE alloc_binding       ; No: just go ahead and bind it
.1a519a	20 3d 16	jsr $1a163d	            JSR STRCPY
.1a519d					alloc_binding
.1a519d	c2 10		rep #$10	            REP #$10
.1a519f	20 02 51	jsr $1a5102	            JSR VAR_ALLOC
.1a51a2	c2 30		rep #$30	            REP #$30
.1a51a4	18		clc		                CLC
.1a51a5	a5 c0		lda $08c0	                LDA CURRBLOCK
.1a51a7	69 01 00	adc #$0001	                ADC #BINDING.NAME
.1a51aa	85 08		sta $0808	                STA INDEX
.1a51ac	e2 20		sep #$20	            SEP #$20
.1a51ae	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a51b0	69 00		adc #$00	                ADC #0
.1a51b2	85 0a		sta $080a	                STA INDEX+2
.1a51b4	a0 00 00	ldy #$0000	                LDY #0                  ; Ensure that the name field is blank
.1a51b7	a9 00		lda #$00	                LDA #0
.1a51b9	97 08		sta [$0808],y	blank_loop      STA [INDEX],Y
.1a51bb	c8		iny		                INY
.1a51bc	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.1a51bf	d0 f8		bne $1a51b9	                BNE blank_loop
.1a51c1	a0 00 00	ldy #$0000	                LDY #0
.1a51c4	b7 e7		lda [$08e7],y	name_loop       LDA [TOFIND],Y          ; Copy TOFIND to the NAME field
.1a51c6	f0 10		beq $1a51d8	                BEQ set_type
.1a51c8	20 a5 04	jsr $1a04a5	            JSR TOUPPERA
.1a51cb	20 ef 4f	jsr $1a4fef	            JSR ISVARCHAR
.1a51ce	90 08		bcc $1a51d8	                BCC set_type
.1a51d0	97 08		sta [$0808],y	                STA [INDEX],Y
.1a51d2	c8		iny		                INY
.1a51d3	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.1a51d6	d0 ec		bne $1a51c4	                BNE name_loop
.1a51d8					set_type
.1a51d8	c2 20		rep #$20	            REP #$20
.1a51da	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE      ; Copy the value to the variable
.1a51dd	a5 23		lda $0823	                LDA ARGUMENT1
.1a51df	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a51e1	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a51e3	c8		iny		                INY
.1a51e4	c8		iny		                INY
.1a51e5	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a51e7	a5 e4		lda $08e4	                LDA VARIABLES           ; Point NEXT to the current top of variables
.1a51e9	a0 0d 00	ldy #$000d	                LDY #BINDING.NEXT
.1a51ec	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a51ee	c8		iny		                INY
.1a51ef	c8		iny		                INY
.1a51f0	e2 20		sep #$20	            SEP #$20
.1a51f2	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a51f4	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a51f6	c2 20		rep #$20	            REP #$20
.1a51f8	a5 c0		lda $08c0	                LDA CURRBLOCK
.1a51fa	85 e4		sta $08e4	                STA VARIABLES
.1a51fc	e2 20		sep #$20	            SEP #$20
.1a51fe	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a5200	85 e6		sta $08e6	                STA VARIABLES+2
.1a5202	e2 20		sep #$20	            SEP #$20
.1a5204	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Set the type of the variable
.1a5207	a5 27		lda $0827	                LDA ARGTYPE1
.1a5209	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a520b	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is it a string?
.1a520d	f0 02		beq $1a5211	                BEQ set_ref             ; Yes: add a reference count to it
.1a520f	28		plp		done            PLP
.1a5210	60		rts		            RTS
.1a5211					set_ref
.1a5211	c2 20		rep #$20	            REP #$20
.1a5213	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the a heap allocated value
.1a5215	85 c0		sta $08c0	                STA CURRBLOCK
.1a5217	e2 20		sep #$20	            SEP #$20
.1a5219	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a521b	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a521d	20 59 12	jsr $1a1259	            JSR HEAP_GETHED
.1a5220	20 6e 12	jsr $1a126e	            JSR HEAP_ADDREF
.1a5223	80 ea		bra $1a520f	                BRA done
.1a5225					VAR_SET
.1a5225	08		php		                PHP
.1a5226	c2 30		rep #$30	            REP #$30
.1a5228	a5 e4		lda $08e4	                LDA VARIABLES          ; If VARIABLES = 0, use VAR_CREATE
.1a522a	d0 06		bne $1a5232	                BNE use_find
.1a522c	e2 20		sep #$20	            SEP #$20
.1a522e	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a5230	f0 05		beq $1a5237	                BEQ use_create
.1a5232					use_find
.1a5232	20 35 50	jsr $1a5035	            JSR VAR_FIND
.1a5235	b0 05		bcs $1a523c	                BCS found
.1a5237					use_create
.1a5237	20 5a 51	jsr $1a515a	            JSR VAR_CREATE
.1a523a	80 4e		bra $1a528a	                BRA done
.1a523c					found
.1a523c	e2 20		sep #$20	            SEP #$20
.1a523e	a5 27		lda $0827	                LDA ARGTYPE1            ; Do the types match?
.1a5240	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.1a5242	f0 33		beq $1a5277	                BEQ chk_string          ; Yes: check to see if it's string
.1a5244	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable
.1a5246	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; Is it INTEGER?
.1a5248	d0 05		bne $1a524f	                BNE chk_float
.1a524a	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a524d	80 2c		bra $1a527b	                BRA set_val
.1a524f	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; Is it FLOAT?
.1a5251	d0 05		bne $1a5258	                BNE type_error          ; No: throw an error
.1a5253	20 0e 07	jsr $1a070e	            JSR ASS_ARG1_FLOAT
.1a5256	80 23		bra $1a527b	                BRA set_val
.1a5258					type_error
.1a5258	08		php		            PHP
.1a5259	c2 20		rep #$20	            REP #$20
.1a525b	48		pha		            PHA
.1a525c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a525f	5b		tcd		            TCD
.1a5260	68		pla		            PLA
.1a5261	28		plp		            PLP
.1a5262	e2 20		sep #$20	            SEP #$20
.1a5264	a9 04		lda #$04	            LDA #ERR_TYPE
.1a5266	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a526a	c2 20		rep #$20	            REP #$20
.1a526c	29 ff 00	and #$00ff	            AND #$00FF
.1a526f	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a5272	e2 20		sep #$20	            SEP #$20
.1a5274	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5277	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING
.1a5279	f0 11		beq $1a528c	                BEQ set_string          ; Yes: set the string value of the variable
.1a527b					set_val
.1a527b	c2 30		rep #$30	            REP #$30
.1a527d	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.1a5280	a5 23		lda $0823	                LDA ARGUMENT1
.1a5282	97 08		sta [$0808],y	                STA [INDEX],Y
.1a5284	c8		iny		                INY
.1a5285	c8		iny		                INY
.1a5286	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5288	97 08		sta [$0808],y	                STA [INDEX],Y
.1a528a					done
.1a528a	28		plp		                PLP
.1a528b	60		rts		            RTS
.1a528c					set_string
.1a528c	20 3d 16	jsr $1a163d	            JSR STRCPY
.1a528f	a0 09 00	ldy #$0009	set_ref         LDY #BINDING.VALUE      ; Set CURRBLOCK to the current string value
.1a5292	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a5294	85 c0		sta $08c0	                STA CURRBLOCK
.1a5296	c8		iny		                INY
.1a5297	c8		iny		                INY
.1a5298	e2 20		sep #$20	            SEP #$20
.1a529a	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a529c	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a529e	20 59 12	jsr $1a1259	            JSR HEAP_GETHED
.1a52a1	20 8d 12	jsr $1a128d	            JSR HEAP_REMREF
.1a52a4	e2 20		sep #$20	            SEP #$20
.1a52a6	a5 27		lda $0827	                LDA ARGTYPE1
.1a52a8	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is the new value a string?
.1a52aa	f0 02		beq $1a52ae	                BEQ add_ref             ; Yes: add a reference to it
.1a52ac	80 cd		bra $1a527b	                BRA set_val             ; No: go back to set the value... this probably shouldn't happen
.1a52ae					add_ref
.1a52ae	c2 20		rep #$20	            REP #$20
.1a52b0	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the new string value
.1a52b2	85 c0		sta $08c0	                STA CURRBLOCK
.1a52b4	e2 20		sep #$20	            SEP #$20
.1a52b6	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a52b8	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a52ba	20 59 12	jsr $1a1259	            JSR HEAP_GETHED
.1a52bd	20 6e 12	jsr $1a126e	            JSR HEAP_ADDREF
.1a52c0	80 b9		bra $1a527b	                BRA set_val
.1a52c2					VAR_FINDNAME
.1a52c2	08		php		                PHP
.1a52c3	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a52c6	e2 20		sep #$20	            SEP #$20
.1a52c8	a7 00		lda [$0800]	                LDA [BIP]           ; Get the first character
.1a52ca	20 31 04	jsr $1a0431	            JSR ISALPHA
.1a52cd	90 42		bcc $1a5311	                BCC not_found
.1a52cf	c2 20		rep #$20	            REP #$20
.1a52d1	a5 00		lda $0800	                LDA BIP
.1a52d3	85 e7		sta $08e7	                STA TOFIND
.1a52d5	e2 20		sep #$20	            SEP #$20
.1a52d7	a5 02		lda $0802	                LDA BIP+2
.1a52d9	85 e9		sta $08e9	                STA TOFIND+2
.1a52db					loop
.1a52db	20 67 20	jsr $1a2067	            JSR INCBIP
.1a52de	a7 00		lda [$0800]	                LDA [BIP]
.1a52e0	f0 0d		beq $1a52ef	                BEQ is_float        ; If it's EOL, the variable is a float
.1a52e2	c9 24		cmp #$24	                CMP #'$'            ; If it's $, the variable is a string
.1a52e4	f0 14		beq $1a52fa	                BEQ is_string
.1a52e6	c9 25		cmp #$25	                CMP #'%'            ; If it's %, the variable is an integer
.1a52e8	f0 09		beq $1a52f3	                BEQ is_integer
.1a52ea	20 ef 4f	jsr $1a4fef	            JSR ISVARCHAR
.1a52ed	b0 ec		bcs $1a52db	                BCS loop            ; Check the next one
.1a52ef	a9 01		lda #$01	is_float        LDA #TYPE_FLOAT     ; Otherwise it's a float
.1a52f1	80 0c		bra $1a52ff	                BRA set_type
.1a52f3					is_integer
.1a52f3	20 67 20	jsr $1a2067	            JSR INCBIP
.1a52f6	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a52f8	80 05		bra $1a52ff	                BRA set_type
.1a52fa					is_string
.1a52fa	20 67 20	jsr $1a2067	            JSR INCBIP
.1a52fd	a9 02		lda #$02	                LDA #TYPE_STRING
.1a52ff	85 ea		sta $08ea	set_type        STA TOFINDTYPE
.1a5301	20 c8 21	jsr $1a21c8	            JSR PEEK_TOK
.1a5304	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it "("?
.1a5306	d0 06		bne $1a530e	                BNE done            ; No: we're done... it's just a scalar variable
.1a5308	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Yes: this is an array reference
.1a530a	09 80		ora #$80	                ORA #$80            ; ... turn on the "Array of..." bit
.1a530c	85 ea		sta $08ea	                STA TOFINDTYPE
.1a530e					done
.1a530e	28		plp		                PLP
.1a530f	38		sec		                SEC
.1a5310	60		rts		            RTS
.1a5311	28		plp		not_found       PLP
.1a5312	18		clc		                CLC
.1a5313	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\integers.s

.1a5314					OP_INT_ADD
.1a5314	08		php		            PHP
.1a5315	c2 20		rep #$20	            REP #$20
.1a5317	18		clc		            CLC
.1a5318	a5 23		lda $0823	            LDA ARGUMENT1
.1a531a	65 29		adc $0829	            ADC ARGUMENT2
.1a531c	85 23		sta $0823	            STA ARGUMENT1
.1a531e	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5320	65 2b		adc $082b	            ADC ARGUMENT2+2
.1a5322	85 25		sta $0825	            STA ARGUMENT1+2
.1a5324	28		plp		            PLP
.1a5325	60		rts		            RTS
.1a5326					OP_INT_SUB
.1a5326	08		php		            PHP
.1a5327	c2 20		rep #$20	            REP #$20
.1a5329	38		sec		            SEC
.1a532a	a5 23		lda $0823	            LDA ARGUMENT1
.1a532c	e5 29		sbc $0829	            SBC ARGUMENT2
.1a532e	85 23		sta $0823	            STA ARGUMENT1
.1a5330	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5332	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.1a5334	85 25		sta $0825	            STA ARGUMENT1+2
.1a5336	28		plp		            PLP
.1a5337	60		rts		            RTS
.1a5338					OP_INT_MUL
.1a5338	08		php		            PHP
.1a5339					locals
>0001					L_SIGN      .word ?
>0003					L_RESULT    .dword ?
>0007					            .dword ?
.1a5339	c2 20		rep #$20	            REP #$20
.1a533b	3b		tsc		            TSC
.1a533c	38		sec		            SEC
.1a533d	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.1a5340	1b		tcs		            TCS
.1a5341	c2 30		rep #$30	            REP #$30
.1a5343	a9 00 00	lda #$0000	            LDA #0                  ; Start by assuming positive numbers
.1a5346	83 01		sta $01,s	            STA L_SIGN
.1a5348	83 03		sta $03,s	            STA L_RESULT            ; Clear result
.1a534a	83 05		sta $05,s	            STA L_RESULT+2
.1a534c	83 07		sta $07,s	            STA L_RESULT+4
.1a534e	83 09		sta $09,s	            STA L_RESULT+6
.1a5350	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Ensure ARGUMENT1 is positive
.1a5352	10 18		bpl $1a536c	            BPL chk_sign2
.1a5354	a9 00 80	lda #$8000	            LDA #$8000              ; Record that ARGUMENT1 is negative
.1a5357	83 01		sta $01,s	            STA L_SIGN
.1a5359	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Take the two's complement of ARGUMENT1
.1a535b	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a535e	85 25		sta $0825	            STA ARGUMENT1+2
.1a5360	a5 23		lda $0823	            LDA ARGUMENT1
.1a5362	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a5365	1a		inc a		            INC A
.1a5366	85 23		sta $0823	            STA ARGUMENT1
.1a5368	d0 02		bne $1a536c	            BNE chk_sign2
.1a536a	e6 25		inc $0825	            INC ARGUMENT1+2
.1a536c	a5 2b		lda $082b	chk_sign2   LDA ARGUMENT2+2         ; Ensure ARGUMENT2 is positive
.1a536e	10 1a		bpl $1a538a	            BPL chk_over
.1a5370	a3 01		lda $01,s	            LDA L_SIGN              ; Flip the sign
.1a5372	49 00 80	eor #$8000	            EOR #$8000
.1a5375	83 01		sta $01,s	            STA L_SIGN
.1a5377	a5 2b		lda $082b	            LDA ARGUMENT2+2         ; Take the two's complement of ARGUMENT2
.1a5379	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a537c	85 2b		sta $082b	            STA ARGUMENT2+2
.1a537e	a5 29		lda $0829	            LDA ARGUMENT2
.1a5380	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a5383	1a		inc a		            INC A
.1a5384	85 29		sta $0829	            STA ARGUMENT2
.1a5386	d0 02		bne $1a538a	            BNE chk_over
.1a5388	e6 2b		inc $082b	            INC ARGUMENT2+2
.1a538a					chk_over
.1a538a	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a538c	f0 04		beq $1a5392	            BEQ do_mult
.1a538e	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a5390	d0 5a		bne $1a53ec	            BNE overflow
.1a5392					do_mult
.1a5392	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*D
.1a5394	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.1a5398	a5 29		lda $0829	            LDA ARGUMENT2
.1a539a	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.1a539e	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.1a53a2	83 03		sta $03,s	            STA L_RESULT
.1a53a4	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.1a53a8	83 05		sta $05,s	            STA L_RESULT+2
.1a53aa	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Calculate A*D << 16 + B*D
.1a53ac	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.1a53b0	a5 29		lda $0829	            LDA ARGUMENT2
.1a53b2	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.1a53b6	18		clc		            CLC
.1a53b7	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.1a53bb	63 05		adc $05,s	            ADC L_RESULT+2
.1a53bd	83 05		sta $05,s	            STA L_RESULT+2
.1a53bf	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.1a53c3	63 07		adc $07,s	            ADC L_RESULT+4
.1a53c5	83 07		sta $07,s	            STA L_RESULT+4
.1a53c7	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*C << 16 + A*D << 16 + B*D
.1a53c9	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.1a53cd	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a53cf	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.1a53d3	18		clc		            CLC
.1a53d4	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.1a53d8	63 05		adc $05,s	            ADC L_RESULT+2
.1a53da	83 05		sta $05,s	            STA L_RESULT+2
.1a53dc	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.1a53e0	63 07		adc $07,s	            ADC L_RESULT+4
.1a53e2	83 07		sta $07,s	            STA L_RESULT+4
.1a53e4	a3 07		lda $07,s	            LDA L_RESULT+4
.1a53e6	f0 23		beq $1a540b	            BEQ no_overflow
.1a53e8	a3 09		lda $09,s	            LDA L_RESULT+6
.1a53ea	f0 1f		beq $1a540b	            BEQ no_overflow
.1a53ec					overflow
.1a53ec	08		php		            PHP
.1a53ed	c2 20		rep #$20	            REP #$20
.1a53ef	48		pha		            PHA
.1a53f0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a53f3	5b		tcd		            TCD
.1a53f4	68		pla		            PLA
.1a53f5	28		plp		            PLP
.1a53f6	e2 20		sep #$20	            SEP #$20
.1a53f8	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.1a53fa	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a53fe	c2 20		rep #$20	            REP #$20
.1a5400	29 ff 00	and #$00ff	            AND #$00FF
.1a5403	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a5406	e2 20		sep #$20	            SEP #$20
.1a5408	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a540b					no_overflow
.1a540b	c2 30		rep #$30	            REP #$30
.1a540d	a3 01		lda $01,s	            LDA L_SIGN              ; Check the sign
.1a540f	10 16		bpl $1a5427	            BPL ret_result          ; If positive: just return the result
.1a5411	a3 05		lda $05,s	            LDA L_RESULT+2          ; Compute the two's complement of the result
.1a5413	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a5416	83 05		sta $05,s	            STA L_RESULT+2
.1a5418	a3 03		lda $03,s	            LDA L_RESULT
.1a541a	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a541d	1a		inc a		            INC A
.1a541e	83 03		sta $03,s	            STA L_RESULT
.1a5420	d0 05		bne $1a5427	            BNE ret_result
.1a5422	a3 05		lda $05,s	            LDA L_RESULT+2
.1a5424	1a		inc a		            INC A
.1a5425	83 05		sta $05,s	            STA L_RESULT+2
.1a5427					ret_result
.1a5427	a3 03		lda $03,s	            LDA L_RESULT
.1a5429	85 23		sta $0823	            STA ARGUMENT1
.1a542b	a3 05		lda $05,s	            LDA L_RESULT+2
.1a542d	85 25		sta $0825	            STA ARGUMENT1+2
.1a542f	c2 20		rep #$20	            REP #$20
.1a5431	3b		tsc		            TSC
.1a5432	18		clc		            CLC
.1a5433	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.1a5436	1b		tcs		            TCS
.1a5437	28		plp		            PLP
.1a5438	60		rts		            RTS
.1a5439					OP_INT_LT
.1a5439	08		php		            PHP
.1a543a	c2 20		rep #$20	            REP #$20
.1a543c	a5 23		lda $0823	            LDA ARGUMENT1
.1a543e	c5 29		cmp $0829	            CMP ARGUMENT2
.1a5440	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5442	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.1a5444	50 03		bvc $1a5449	            BVC skip_eor
.1a5446	49 00 80	eor #$8000	            EOR #$8000
.1a5449	30 06		bmi $1a5451	skip_eor    BMI ret_true
.1a544b	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a544d	64 25		stz $0825	            STZ ARGUMENT1+2
.1a544f	80 07		bra $1a5458	            BRA done
.1a5451	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a5454	85 23		sta $0823	            STA ARGUMENT1
.1a5456	85 25		sta $0825	            STA ARGUMENT1+2
.1a5458	28		plp		done        PLP
.1a5459	60		rts		            RTS
.1a545a					OP_INT_GT
.1a545a	08		php		            PHP
.1a545b	c2 20		rep #$20	            REP #$20
.1a545d	a5 23		lda $0823	            LDA ARGUMENT1
.1a545f	c5 29		cmp $0829	            CMP ARGUMENT2
.1a5461	d0 0c		bne $1a546f	            BNE test_fully
.1a5463	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5465	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.1a5467	d0 06		bne $1a546f	            BNE test_fully
.1a5469	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a546b	64 25		stz $0825	            STZ ARGUMENT1+2
.1a546d	80 16		bra $1a5485	            BRA done
.1a546f	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.1a5471	c5 23		cmp $0823	            CMP ARGUMENT1
.1a5473	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a5475	e5 25		sbc $0825	            SBC ARGUMENT1+2
.1a5477	50 03		bvc $1a547c	            BVC skip_eor
.1a5479	49 00 80	eor #$8000	            EOR #$8000
.1a547c	10 eb		bpl $1a5469	skip_eor    BPL ret_false
.1a547e	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a5481	85 23		sta $0823	            STA ARGUMENT1
.1a5483	85 25		sta $0825	            STA ARGUMENT1+2
.1a5485	28		plp		done        PLP
.1a5486	60		rts		            RTS
.1a5487					OP_INT_EQ
.1a5487	08		php		            PHP
.1a5488	c2 20		rep #$20	            REP #$20
.1a548a	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a548c	c5 25		cmp $0825	            CMP ARGUMENT1+2
.1a548e	d0 0f		bne $1a549f	            BNE ret_false
.1a5490	a5 29		lda $0829	            LDA ARGUMENT2
.1a5492	c5 23		cmp $0823	            CMP ARGUMENT1
.1a5494	d0 09		bne $1a549f	            BNE ret_false
.1a5496	a9 ff ff	lda #$ffff	            LDA #$FFFF
.1a5499	85 23		sta $0823	            STA ARGUMENT1
.1a549b	85 25		sta $0825	            STA ARGUMENT1+2
.1a549d	80 04		bra $1a54a3	            BRA done
.1a549f	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a54a1	64 25		stz $0825	            STZ ARGUMENT1+2
.1a54a3	28		plp		done        PLP
.1a54a4	60		rts		            RTS
.1a54a5					OP_INT_NE
.1a54a5	08		php		            PHP
.1a54a6	c2 20		rep #$20	            REP #$20
.1a54a8	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a54aa	c5 25		cmp $0825	            CMP ARGUMENT1+2
.1a54ac	d0 0c		bne $1a54ba	            BNE ret_true
.1a54ae	a5 29		lda $0829	            LDA ARGUMENT2
.1a54b0	c5 23		cmp $0823	            CMP ARGUMENT1
.1a54b2	d0 06		bne $1a54ba	            BNE ret_true
.1a54b4	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a54b6	64 25		stz $0825	            STZ ARGUMENT1+2
.1a54b8	80 07		bra $1a54c1	            BRA done
.1a54ba	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a54bd	85 23		sta $0823	            STA ARGUMENT1
.1a54bf	85 25		sta $0825	            STA ARGUMENT1+2
.1a54c1	28		plp		done        PLP
.1a54c2	60		rts		            RTS
.1a54c3					OP_INT_GTE
.1a54c3	08		php		            PHP
.1a54c4	c2 20		rep #$20	            REP #$20
.1a54c6	a5 23		lda $0823	            LDA ARGUMENT1
.1a54c8	c5 29		cmp $0829	            CMP ARGUMENT2
.1a54ca	d0 0f		bne $1a54db	            BNE test_fully
.1a54cc	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a54ce	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.1a54d0	d0 09		bne $1a54db	            BNE test_fully
.1a54d2	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a54d5	85 23		sta $0823	            STA ARGUMENT1
.1a54d7	85 25		sta $0825	            STA ARGUMENT1+2
.1a54d9	80 13		bra $1a54ee	            BRA done
.1a54db	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.1a54dd	c5 23		cmp $0823	            CMP ARGUMENT1
.1a54df	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a54e1	e5 25		sbc $0825	            SBC ARGUMENT1+2
.1a54e3	50 03		bvc $1a54e8	            BVC skip_eor
.1a54e5	49 00 80	eor #$8000	            EOR #$8000
.1a54e8	30 e8		bmi $1a54d2	skip_eor    BMI ret_true
.1a54ea	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a54ec	64 25		stz $0825	            STZ ARGUMENT1+2
.1a54ee	28		plp		done        PLP
.1a54ef	60		rts		            RTS
.1a54f0					OP_INT_LTE
.1a54f0	08		php		            PHP
.1a54f1	c2 20		rep #$20	            REP #$20
.1a54f3	a5 23		lda $0823	            LDA ARGUMENT1
.1a54f5	c5 29		cmp $0829	            CMP ARGUMENT2
.1a54f7	d0 0f		bne $1a5508	            BNE test_fully
.1a54f9	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a54fb	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.1a54fd	d0 09		bne $1a5508	            BNE test_fully
.1a54ff	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a5502	85 23		sta $0823	            STA ARGUMENT1
.1a5504	85 25		sta $0825	            STA ARGUMENT1+2
.1a5506	80 13		bra $1a551b	            BRA done
.1a5508	a5 23		lda $0823	test_fully  LDA ARGUMENT1
.1a550a	c5 29		cmp $0829	            CMP ARGUMENT2
.1a550c	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a550e	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.1a5510	50 03		bvc $1a5515	            BVC skip_eor
.1a5512	49 00 80	eor #$8000	            EOR #$8000
.1a5515	30 e8		bmi $1a54ff	skip_eor    BMI ret_true
.1a5517	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a5519	64 25		stz $0825	            STZ ARGUMENT1+2
.1a551b	28		plp		done        PLP
.1a551c	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\floats.s


;******  Processing file: src\C256/floats.s


;******  Processing file: src\C256/fp_math_defs.s

=$afe200				FP_MATH_CTRL0 = $AFE200         ; Read/write
=$08					FP_MATH_CTRL0_ADD = $08         ; 0: Substraction - 1: Addition
=$01					FP_CTRL0_CONV_0 = %00000001     ; Input 0 should be converted from 24.12 fixed point to floating point
=$02					FP_CTRL0_CONV_1 = %00000010     ; Input 1 should be converted from 24.12 fixed point to floating point
=$00					FP_ADD_IN0_MUX0 = %00000000     ; Adder input #0 is the output of MUX0
=$10					FP_ADD_IN0_MUX1 = %00010000     ; Adder input #0 is the output of MUX1
=$20					FP_ADD_IN0_MULT = %00100000     ; Adder input #0 is the output of the multiplier
=$30					FP_ADD_IN0_DIV  = %00110000     ; Adder input #0 is the output of the divider
=$00					FP_ADD_IN1_MUX0 = %00000000     ; Adder input #1 is the output of MUX0
=$40					FP_ADD_IN1_MUX1 = %01000000     ; Adder input #1 is the output of MUX1
=$80					FP_ADD_IN1_MULT = %10000000     ; Adder input #1 is the output of the multiplier
=$c0					FP_ADD_IN1_DIV  = %11000000     ; Adder input #1 is the output of the divider
=$afe201				FP_MATH_CTRL1 = $AFE201
=$00					FP_OUT_MULT = %00000000         ; Output is from the multiplier
=$01					FP_OUT_DIV  = %00000001         ; Output is from the divider
=$02					FP_OUT_ADD  = %00000010         ; Output is from the adder/subtracter
=$03					FP_OUT_ONE  = %00000011         ; Output is the constant '1.0'
=$afe202				FP_MATH_CTRL2 = $AFE202         ; Not Used - Reserved
=$afe203				FP_MATH_CTRL3 = $AFE203         ; Not Used - Reserved
=$afe204				FP_MATH_MULT_STAT = $AFE204     ; Status of the multiplier
=$01					FP_MULT_STAT_NAN  = $01         ; (NAN) Not a Number Status
=$02					FP_MULT_STAT_OVF  = $02         ; Overflow
=$04					FP_MULT_STAT_UDF  = $04         ; Underflow
=$08					FP_MULT_STAT_ZERO = $08         ; Zero
=$afe205				FP_MATH_DIV_STAT  = $AFE205     ; Status of the divider
=$01					FP_DIV_STAT_NAN       = $01     ; Not a number Status
=$02					FP_DIV_STAT_OVF       = $02     ; Overflow
=$04					FP_DIV_STAT_UDF       = $04     ; Underflow
=$08					FP_DIV_STAT_ZERO      = $08     ; Zero
=$10					FP_DIV_STAT_DIVBYZERO = $10     ; Division by Zero
=$afe206				FP_MATH_ADD_STAT  = $AFE206     ; Status of the adder/subtracter
=$01					FP_ADD_STAT_NAN  = $01          ; Not a number Status
=$02					FP_ADD_STAT_OVF  = $02          ; Overflow
=$04					FP_ADD_STAT_UDF  = $04          ; Underflow
=$08					FP_ADD_STAT_ZERO = $08          ; Zero
=$afe207				FP_MATH_CONV_STAT = $AFE207     ; Status of the fixed <=> float converters
=$01					FP_CONV_STAT_NAN  = $01         ; Not a number Status
=$02					FP_CONV_STAT_OVF  = $02         ; Overflow
=$04					FP_CONV_STAT_UDF  = $04         ; Underflow
=$afe208				FP_MATH_INPUT0_LL = $AFE208
=$afe209				FP_MATH_INPUT0_LH = $AFE209
=$afe20a				FP_MATH_INPUT0_HL = $AFE20A
=$afe20b				FP_MATH_INPUT0_HH = $AFE20B
=$afe20c				FP_MATH_INPUT1_LL = $AFE20C
=$afe20d				FP_MATH_INPUT1_LH = $AFE20D
=$afe20e				FP_MATH_INPUT1_HL = $AFE20E
=$afe20f				FP_MATH_INPUT1_HH = $AFE20F
=$afe208				FP_MATH_OUTPUT_FP_LL = $AFE208
=$afe209				FP_MATH_OUTPUT_FP_LH = $AFE209
=$afe20a				FP_MATH_OUTPUT_FP_HL = $AFE20A
=$afe20b				FP_MATH_OUTPUT_FP_HH = $AFE20B
=$afe20c				FP_MATH_OUTPUT_FIXED_LL = $AFE20C
=$afe20d				FP_MATH_OUTPUT_FIXED_LH = $AFE20D
=$afe20e				FP_MATH_OUTPUT_FIXED_HL = $AFE20E
=$afe20f				FP_MATH_OUTPUT_FIXED_HH = $AFE20F

;******  Return to file: src\C256/floats.s


;******  Processing file: src\C256/math_cop.s

.1a551d					UINT_DIV_A_X
.1a551d	08		php		                    PHP
.1a551e	c2 20		rep #$20	            REP #$20
.1a5520	8f 12 01 00	sta $000112	                    STA @l UNSIGNED_DIV_NUM_LO
.1a5524	8a		txa		                    TXA
.1a5525	8f 10 01 00	sta $000110	                    STA @l UNSIGNED_DIV_DEM_LO
.1a5529	af 16 01 00	lda $000116	                    LDA @l UNSIGNED_DIV_REM_LO
.1a552d	aa		tax		                    TAX
.1a552e	af 14 01 00	lda $000114	                    LDA @l UNSIGNED_DIV_QUO_LO
.1a5532	28		plp		                    PLP
.1a5533	60		rts		            RTS

;******  Return to file: src\C256/floats.s

.1a5534					FIXINT_TO_FP
.1a5534	08		php		                    PHP
.1a5535	e2 20		sep #$20	            SEP #$20
.1a5537	a9 03		lda #$03	                    LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.1a5539	8f 00 e2 af	sta $afe200	                    STA @l FP_MATH_CTRL0
.1a553d	a9 00		lda #$00	                    LDA #FP_OUT_MULT
.1a553f	8f 01 e2 af	sta $afe201	                    STA @l FP_MATH_CTRL1
.1a5543	c2 20		rep #$20	            REP #$20
.1a5545	a5 23		lda $0823	                    LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a5547	8f 08 e2 af	sta $afe208	                    STA @l FP_MATH_INPUT0_LL
.1a554b	a5 25		lda $0825	                    LDA ARGUMENT1+2
.1a554d	8f 0a e2 af	sta $afe20a	                    STA @l FP_MATH_INPUT0_HL
.1a5551	a9 00 00	lda #$0000	                    LDA #0
.1a5554	8f 0c e2 af	sta $afe20c	                    STA @l FP_MATH_INPUT1_LL    ; ARGUMENT2 = 0100 0000 = 4096 in 20:12
.1a5558	a9 00 01	lda #$0100	                    LDA #$0100
.1a555b	8f 0e e2 af	sta $afe20e	                    STA @l FP_MATH_INPUT1_HL
.1a555f	ea		nop		                    NOP
.1a5560	ea		nop		                    NOP
.1a5561	ea		nop		                    NOP
.1a5562	ea		nop		                    NOP
.1a5563	ea		nop		                    NOP
.1a5564	ea		nop		                    NOP
.1a5565	af 08 e2 af	lda $afe208	                    LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.1a5569	85 23		sta $0823	                    STA ARGUMENT1
.1a556b	af 0a e2 af	lda $afe20a	                    LDA @l FP_MATH_OUTPUT_FP_HL
.1a556f	85 25		sta $0825	                    STA ARGUMENT1+2
.1a5571	a9 01 00	lda #$0001	                    LDA #TYPE_FLOAT
.1a5574	85 27		sta $0827	                    STA ARGTYPE1
.1a5576	28		plp		                    PLP
.1a5577	60		rts		            RTS
.1a5578	08		php		OP_FP_SUB       PHP
.1a5579	e2 20		sep #$20	            SEP #$20
.1a557b	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a557d	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a5581	80 09		bra $1a558c	                BRA FP_ADD_SUB
.1a5583	08		php		OP_FP_ADD       PHP
.1a5584	e2 20		sep #$20	            SEP #$20
.1a5586	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a5588	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a558c	a9 02		lda #$02	FP_ADD_SUB      LDA #FP_OUT_ADD
.1a558e	8f 01 e2 af	sta $afe201	                STA @lFP_MATH_CTRL1
.1a5592	c2 20		rep #$20	            REP #$20
.1a5594	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a5596	8f 08 e2 af	sta $afe208	                STA @lFP_MATH_INPUT0_LL
.1a559a	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a559c	8f 0a e2 af	sta $afe20a	                STA @lFP_MATH_INPUT0_HL
.1a55a0	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.1a55a2	8f 0c e2 af	sta $afe20c	                STA @lFP_MATH_INPUT1_LL
.1a55a6	a5 2b		lda $082b	                LDA ARGUMENT2+2
.1a55a8	8f 0e e2 af	sta $afe20e	                STA @lFP_MATH_INPUT1_HL
.1a55ac	ea		nop		                NOP
.1a55ad	ea		nop		                NOP
.1a55ae	ea		nop		                NOP
.1a55af	e2 20		sep #$20	            SEP #$20
.1a55b1	af 06 e2 af	lda $afe206	                LDA @lFP_MATH_ADD_STAT      ; Check the status of the addition
.1a55b5	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.1a55b7	d0 10		bne $1a55c9	                BNE fp_add_error            ; If an issue was raise, process the math error
.1a55b9	c2 20		rep #$20	            REP #$20
.1a55bb	af 08 e2 af	lda $afe208	                LDA @lFP_MATH_OUTPUT_FP_LL  ; Retrieve the results into ARGUMENT1
.1a55bf	85 23		sta $0823	                STA ARGUMENT1
.1a55c1	af 0a e2 af	lda $afe20a	                LDA @lFP_MATH_OUTPUT_FP_HL
.1a55c5	85 25		sta $0825	                STA ARGUMENT1+2
.1a55c7	28		plp		fp_add_done     PLP
.1a55c8	60		rts		            RTS
.1a55c9					fp_add_error
.1a55c9	20 64 56	jsr $1a5664	            JSR FP_MATH_ERROR
.1a55cc	80 f9		bra $1a55c7	                BRA fp_add_done
.1a55ce	08		php		OP_FP_DIV       PHP
.1a55cf	e2 20		sep #$20	            SEP #$20
.1a55d1	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a55d3	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a55d7	a9 00		lda #$00	                LDA #0
.1a55d9	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a55dd	c2 20		rep #$20	            REP #$20
.1a55df	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a55e1	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a55e5	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a55e7	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a55eb	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.1a55ed	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a55f1	a5 2b		lda $082b	                LDA ARGUMENT2+2
.1a55f3	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a55f7	ea		nop		                NOP
.1a55f8	ea		nop		                NOP
.1a55f9	ea		nop		                NOP
.1a55fa	e2 20		sep #$20	            SEP #$20
.1a55fc	af 05 e2 af	lda $afe205	                LDA @l FP_MATH_DIV_STAT     ; Check the status of the addition
.1a5600	29 17		and #$17	                AND #%00010111              ; Filter out the ZERO status
.1a5602	d0 10		bne $1a5614	                BNE fp_div_error            ; If an issue was raise, process the math error
.1a5604	c2 20		rep #$20	            REP #$20
.1a5606	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.1a560a	85 23		sta $0823	                STA ARGUMENT1
.1a560c	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5610	85 25		sta $0825	                STA ARGUMENT1+2
.1a5612	28		plp		fp_div_done     PLP
.1a5613	60		rts		            RTS
.1a5614					fp_div_error
.1a5614	20 64 56	jsr $1a5664	            JSR FP_MATH_ERROR
.1a5617	80 f9		bra $1a5612	                BRA fp_div_done
.1a5619	08		php		OP_FP_MUL       PHP
.1a561a	e2 20		sep #$20	            SEP #$20
.1a561c	a9 00		lda #$00	                LDA #FP_OUT_MULT
.1a561e	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5622	a9 00		lda #$00	                LDA #0
.1a5624	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a5628	c2 20		rep #$20	            REP #$20
.1a562a	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a562c	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5630	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5632	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5636	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.1a5638	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a563c	a5 2b		lda $082b	                LDA ARGUMENT2+2
.1a563e	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5642	ea		nop		                NOP
.1a5643	ea		nop		                NOP
.1a5644	ea		nop		                NOP
.1a5645	e2 20		sep #$20	            SEP #$20
.1a5647	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT    ; Check the status of the addition
.1a564b	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.1a564d	d0 10		bne $1a565f	                BNE fp_mul_error            ; If an issue was raise, process the math error
.1a564f	c2 20		rep #$20	            REP #$20
.1a5651	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.1a5655	85 23		sta $0823	                STA ARGUMENT1
.1a5657	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a565b	85 25		sta $0825	                STA ARGUMENT1+2
.1a565d	28		plp		fp_mul_done     PLP
.1a565e	60		rts		            RTS
.1a565f					fp_mul_error
.1a565f	20 64 56	jsr $1a5664	            JSR FP_MATH_ERROR
.1a5662	80 f9		bra $1a565d	                BRA fp_mul_done
.1a5664					FP_MATH_ERROR
.1a5664	e2 20		sep #$20	            SEP #$20
.1a5666	89 01		bit #$01	                BIT #FP_ADD_STAT_NAN        ; Is there a NaN condition?
.1a5668	f0 20		beq $1a568a	                BEQ check_over              ; No: check for overflow
.1a566a	00		brk #		                BRK
.1a566b	08		php		            PHP
.1a566c	c2 20		rep #$20	            REP #$20
.1a566e	48		pha		            PHA
.1a566f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5672	5b		tcd		            TCD
.1a5673	68		pla		            PLA
.1a5674	28		plp		            PLP
.1a5675	e2 20		sep #$20	            SEP #$20
.1a5677	a9 0c		lda #$0c	            LDA #ERR_NAN
.1a5679	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a567d	c2 20		rep #$20	            REP #$20
.1a567f	29 ff 00	and #$00ff	            AND #$00FF
.1a5682	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a5685	e2 20		sep #$20	            SEP #$20
.1a5687	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a568a	89 02		bit #$02	check_over      BIT #FP_ADD_STAT_OVF        ; Is ther an overflow condition?
.1a568c	f0 1f		beq $1a56ad	                BEQ check_under             ; No: check for underflow
.1a568e	08		php		            PHP
.1a568f	c2 20		rep #$20	            REP #$20
.1a5691	48		pha		            PHA
.1a5692	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5695	5b		tcd		            TCD
.1a5696	68		pla		            PLA
.1a5697	28		plp		            PLP
.1a5698	e2 20		sep #$20	            SEP #$20
.1a569a	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.1a569c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a56a0	c2 20		rep #$20	            REP #$20
.1a56a2	29 ff 00	and #$00ff	            AND #$00FF
.1a56a5	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a56a8	e2 20		sep #$20	            SEP #$20
.1a56aa	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a56ad	89 04		bit #$04	check_under     BIT #FP_ADD_STAT_UDF        ; Is there an underflow condition?
.1a56af	f0 1f		beq $1a56d0	                BEQ done                    ; No: we should just return... this probably shouldn't happen
.1a56b1	08		php		            PHP
.1a56b2	c2 20		rep #$20	            REP #$20
.1a56b4	48		pha		            PHA
.1a56b5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a56b8	5b		tcd		            TCD
.1a56b9	68		pla		            PLA
.1a56ba	28		plp		            PLP
.1a56bb	e2 20		sep #$20	            SEP #$20
.1a56bd	a9 0e		lda #$0e	            LDA #ERR_UNDERFLOW
.1a56bf	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a56c3	c2 20		rep #$20	            REP #$20
.1a56c5	29 ff 00	and #$00ff	            AND #$00FF
.1a56c8	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a56cb	e2 20		sep #$20	            SEP #$20
.1a56cd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a56d0					done
.1a56d0	60		rts		            RTS
.1a56d1					FP_MUL10
.1a56d1	08		php		                PHP
.1a56d2	e2 20		sep #$20	            SEP #$20
.1a56d4	a9 00		lda #$00	                LDA #FP_OUT_MULT                ; Set for multiplication
.1a56d6	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a56da	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1            ; Input 1 is fixed point
.1a56dc	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a56e0	c2 20		rep #$20	            REP #$20
.1a56e2	a9 00 a0	lda #$a000	                LDA #$A000                      ; 10 is one factor
.1a56e5	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a56e9	a9 00 00	lda #$0000	                LDA #0
.1a56ec	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a56f0	a5 23		lda $0823	                LDA ARGUMENT1                   ; N is the other
.1a56f2	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a56f6	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a56f8	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a56fc	ea		nop		                NOP
.1a56fd	ea		nop		                NOP
.1a56fe	ea		nop		                NOP
.1a56ff	e2 20		sep #$20	            SEP #$20
.1a5701	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT        ; Check the status
.1a5705	89 07		bit #$07	                BIT #FP_MULT_STAT_NAN | FP_MULT_STAT_OVF | FP_MULT_STAT_UDF
.1a5707	f0 01		beq $1a570a	                BEQ ret_result
.1a5709	00		brk #		                BRK                             ; There was an error...
.1a570a					ret_result
.1a570a	c2 20		rep #$20	            REP #$20
.1a570c	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL     ; Save result back
.1a5710	85 23		sta $0823	                STA ARGUMENT1
.1a5712	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5716	85 25		sta $0825	                STA ARGUMENT1+2
.1a5718	28		plp		                PLP
.1a5719	60		rts		            RTS
.1a571a					FP_DIV10
.1a571a	08		php		                PHP
.1a571b	e2 20		sep #$20	            SEP #$20
.1a571d	a9 01		lda #$01	                LDA #FP_OUT_DIV             ; Set for multiplication
.1a571f	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5723	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1        ; Input 1 is fixed point
.1a5725	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5729	c2 20		rep #$20	            REP #$20
.1a572b	a9 00 a0	lda #$a000	                LDA #$A000                  ; 10 is one factor
.1a572e	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5732	a9 00 00	lda #$0000	                LDA #0
.1a5735	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5739	a5 23		lda $0823	                LDA ARGUMENT1               ; N is the other
.1a573b	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a573f	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5741	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5745	ea		nop		                NOP
.1a5746	ea		nop		                NOP
.1a5747	ea		nop		                NOP
.1a5748	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Save result back
.1a574c	85 23		sta $0823	                STA ARGUMENT1
.1a574e	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5752	85 25		sta $0825	                STA ARGUMENT1+2
.1a5754	28		plp		                PLP
.1a5755	60		rts		            RTS

;******  Return to file: src\floats.s

.1a5756					FARG1EQ0
.1a5756	08		php		                PHP
.1a5757	c2 20		rep #$20	            REP #$20
.1a5759	a5 23		lda $0823	                LDA ARGUMENT1
.1a575b	d0 0a		bne $1a5767	                BNE return_false
.1a575d	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a575f	29 ff 7f	and #$7fff	                AND #$7FFF              ; Mask off the sign bit
.1a5762	d0 03		bne $1a5767	                BNE return_false
.1a5764	28		plp		return_true     PLP
.1a5765	38		sec		                SEC
.1a5766	60		rts		            RTS
.1a5767	28		plp		return_false    PLP
.1a5768	18		clc		                CLC
.1a5769	60		rts		            RTS
.1a576a					SHIFTDEC
.1a576a	08		php		                PHP
.1a576b	e2 20		sep #$20	            SEP #$20
.1a576d	38		sec		                SEC                     ; Convert '0'..'9' to it's number
.1a576e	e9 30		sbc #$30	                SBC #'0'
.1a5770	20 c9 04	jsr $1a04c9	            JSR MULINT10
.1a5773	c2 20		rep #$20	            REP #$20
.1a5775	29 ff 00	and #$00ff	                AND #$00FF              ; Add the number to ARGUMENT1
.1a5778	18		clc		                CLC
.1a5779	65 23		adc $0823	                ADC ARGUMENT1
.1a577b	85 23		sta $0823	                STA ARGUMENT1
.1a577d	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a577f	69 00 00	adc #$0000	                ADC #0
.1a5782	85 25		sta $0825	                STA ARGUMENT1+2
.1a5784	28		plp		                PLP
.1a5785	60		rts		            RTS
.1a5786					SHIFTHEX
.1a5786	08		php		                PHP
.1a5787	e2 20		sep #$20	            SEP #$20
.1a5789	c9 30		cmp #$30	                CMP #'0'                ; Process 0-9
.1a578b	90 04		bcc $1a5791	                BLT not_09
.1a578d	c9 3a		cmp #$3a	                CMP #'9'+1
.1a578f	90 1c		bcc $1a57ad	                BLT is_09
.1a5791	c9 61		cmp #$61	not_09          CMP #'a'                ; Process lowercase A-F
.1a5793	90 04		bcc $1a5799	                BLT not_lc
.1a5795	c9 67		cmp #$67	                CMP #'f'+1
.1a5797	90 0a		bcc $1a57a3	                BLT is_lc
.1a5799	c9 41		cmp #$41	not_lc          CMP #'A'                ; Process uppercase A-F
.1a579b	90 04		bcc $1a57a1	                BLT not_uc
.1a579d	c9 47		cmp #$47	                CMP #'F'+1
.1a579f	90 07		bcc $1a57a8	                BLT is_uc
.1a57a1	80 31		bra $1a57d4	not_uc          BRA done                ; Just return if we couldn't convert... this shouldn't happen
.1a57a3	38		sec		is_lc           SEC                     ; Convert 'a'-'f' to the actual number
.1a57a4	e9 57		sbc #$57	                SBC #'a'-10
.1a57a6	80 08		bra $1a57b0	                BRA shift
.1a57a8	38		sec		is_uc           SEC                     ; Convert 'A'-'F' to the actual number
.1a57a9	e9 37		sbc #$37	                SBC #'A'-10
.1a57ab	80 03		bra $1a57b0	                BRA shift
.1a57ad	38		sec		is_09           SEC                     ; Convert '0'-'9' to the actual number
.1a57ae	e9 30		sbc #$30	                SBC #'0'
.1a57b0					shift
.1a57b0	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a57b2	26 24		rol $0824	                ROL ARGUMENT1+1
.1a57b4	26 25		rol $0825	                ROL ARGUMENT1+2
.1a57b6	26 26		rol $0826	                ROL ARGUMENT1+3
.1a57b8	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a57ba	26 24		rol $0824	                ROL ARGUMENT1+1
.1a57bc	26 25		rol $0825	                ROL ARGUMENT1+2
.1a57be	26 26		rol $0826	                ROL ARGUMENT1+3
.1a57c0	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a57c2	26 24		rol $0824	                ROL ARGUMENT1+1
.1a57c4	26 25		rol $0825	                ROL ARGUMENT1+2
.1a57c6	26 26		rol $0826	                ROL ARGUMENT1+3
.1a57c8	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a57ca	26 24		rol $0824	                ROL ARGUMENT1+1
.1a57cc	26 25		rol $0825	                ROL ARGUMENT1+2
.1a57ce	26 26		rol $0826	                ROL ARGUMENT1+3
.1a57d0	05 23		ora $0823	                ORA ARGUMENT1           ; Add the number to it
.1a57d2	85 23		sta $0823	                STA ARGUMENT1
.1a57d4	28		plp		done            PLP
.1a57d5	60		rts		            RTS
.1a57d6					SHIFTBIN
.1a57d6	08		php		                PHP
.1a57d7	e2 20		sep #$20	            SEP #$20
.1a57d9	c9 30		cmp #$30	                CMP #'0'                ; If the character is '0'...
.1a57db	f0 06		beq $1a57e3	                BEQ shift_0             ; Shift a 0 onto ARGUMENT1
.1a57dd	c9 31		cmp #$31	                CMP #'1'                ; If the character is '1'...
.1a57df	f0 0a		beq $1a57eb	                BEQ shift_1             ; Shift a 1 onto ARGUMENT1
.1a57e1	80 0f		bra $1a57f2	                BRA done
.1a57e3					shift_0
.1a57e3	c2 20		rep #$20	            REP #$20
.1a57e5	06 23		asl $0823	                ASL ARGUMENT1
.1a57e7	26 25		rol $0825	                ROL ARGUMENT1+2
.1a57e9	80 07		bra $1a57f2	                BRA done
.1a57eb					shift_1
.1a57eb	c2 20		rep #$20	            REP #$20
.1a57ed	38		sec		                SEC
.1a57ee	26 23		rol $0823	                ROL ARGUMENT1
.1a57f0	26 25		rol $0825	                ROL ARGUMENT1+2
.1a57f2	28		plp		done            PLP
.1a57f3	60		rts		            RTS
.1a57f4					FP_POW10
.1a57f4	08		php		                PHP
.1a57f5	e2 30		sep #$30	            SEP #$30
.1a57f7	a5 61		lda $0861	                LDA MARG4
.1a57f9	f0 0d		beq $1a5808	                BEQ return_1
.1a57fb	aa		tax		                TAX
.1a57fc	a5 69		lda $0869	                LDA MARG6
.1a57fe	d0 15		bne $1a5815	                BNE do_div
.1a5800	a9 00		lda #$00	                LDA #FP_OUT_MULT                    ; We'll multiply
.1a5802	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5806	80 15		bra $1a581d	                BRA start_loop
.1a5808					return_1
.1a5808	e2 20		sep #$20	            SEP #$20
.1a580a	a9 03		lda #$03	                LDA #FP_OUT_ONE                     ; We want to return a 1.0
.1a580c	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5810	ea		nop		                NOP
.1a5811	ea		nop		                NOP
.1a5812	ea		nop		                NOP
.1a5813	80 62		bra $1a5877	                BRA ret_result                      ; And return the result
.1a5815					do_div
.1a5815	e2 20		sep #$20	            SEP #$20
.1a5817	a9 01		lda #$01	                LDA #FP_OUT_DIV                     ; We'll divide
.1a5819	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a581d					start_loop
.1a581d	e2 20		sep #$20	            SEP #$20
.1a581f	a9 43		lda #$43	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.1a5821	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.1a5825	c2 20		rep #$20	            REP #$20
.1a5827	a9 00 10	lda #$1000	                LDA #$1000                          ; Input 0 = 1.0
.1a582a	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a582e	a9 00 00	lda #$0000	                LDA #0
.1a5831	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5835					loop
.1a5835	c2 20		rep #$20	            REP #$20
.1a5837	a9 00 a0	lda #$a000	                LDA #$A000                          ; Input 1 = 10.0
.1a583a	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a583e	a9 00 00	lda #$0000	                LDA #0
.1a5841	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5845	ea		nop		                NOP                                 ; Wait for the operation to complete
.1a5846	ea		nop		                NOP
.1a5847	ea		nop		                NOP
.1a5848	ca		dex		                DEX                                 ; Count down
.1a5849	f0 2c		beq $1a5877	                BEQ ret_result                      ; If 0, then we're done
.1a584b	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; SCRATCH <-- Result
.1a584f	8f 0c 08 00	sta $00080c	                STA @l SCRATCH
.1a5853	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5857	8f 0e 08 00	sta $00080e	                STA @l SCRATCH+2
.1a585b	e2 20		sep #$20	            SEP #$20
.1a585d	a9 42		lda #$42	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_1
.1a585f	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.1a5863	c2 20		rep #$20	            REP #$20
.1a5865	af 0c 08 00	lda $00080c	                LDA @l SCRATCH                      ; Input 0 <-- SCRATCH
.1a5869	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a586d	af 0e 08 00	lda $00080e	                LDA @l SCRATCH+2
.1a5871	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5875	80 be		bra $1a5835	                BRA loop
.1a5877					ret_result
.1a5877	c2 20		rep #$20	            REP #$20
.1a5879	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; Return the result
.1a587d	85 23		sta $0823	                STA ARGUMENT1
.1a587f	af 0a e2 af	lda $afe20a	                LDA FP_MATH_OUTPUT_FP_HL
.1a5883	85 25		sta $0825	                STA ARGUMENT1+2
.1a5885	e2 20		sep #$20	            SEP #$20
.1a5887	a9 01		lda #$01	                LDA #TYPE_FLOAT
.1a5889	85 27		sta $0827	                STA ARGTYPE1
.1a588b	28		plp		done            PLP
.1a588c	60		rts		            RTS
.1a588d					PACKFLOAT
.1a588d	08		php		                PHP
.1a588e	c2 20		rep #$20	            REP #$20
.1a5890	a5 5d		lda $085d	            LDA MARG3
.1a5892	85 23		sta $0823	            STA ARGUMENT1
.1a5894	a5 5f		lda $085f	            LDA MARG3+2
.1a5896	85 25		sta $0825	            STA ARGUMENT1+2
.1a5898	20 a6 5a	jsr $1a5aa6	            JSR ITOF
.1a589b	c2 20		rep #$20	            REP #$20
.1a589d	a5 23		lda $0823	            LDA ARGUMENT1
.1a589f	85 29		sta $0829	            STA ARGUMENT2
.1a58a1	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a58a3	85 2b		sta $082b	            STA ARGUMENT2+2
.1a58a5	c2 20		rep #$20	            REP #$20
.1a58a7	a5 59		lda $0859	            LDA MARG2
.1a58a9	85 23		sta $0823	            STA ARGUMENT1
.1a58ab	a5 5b		lda $085b	            LDA MARG2+2
.1a58ad	85 25		sta $0825	            STA ARGUMENT1+2
.1a58af	20 ce 55	jsr $1a55ce	            JSR OP_FP_DIV
.1a58b2	c2 20		rep #$20	            REP #$20
.1a58b4	a5 55		lda $0855	            LDA MARG1
.1a58b6	85 29		sta $0829	            STA ARGUMENT2
.1a58b8	a5 57		lda $0857	            LDA MARG1+2
.1a58ba	85 2b		sta $082b	            STA ARGUMENT2+2
.1a58bc	20 83 55	jsr $1a5583	            JSR OP_FP_ADD
.1a58bf	c2 20		rep #$20	            REP #$20
.1a58c1	a5 23		lda $0823	            LDA ARGUMENT1
.1a58c3	85 29		sta $0829	            STA ARGUMENT2
.1a58c5	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a58c7	85 2b		sta $082b	            STA ARGUMENT2+2
.1a58c9	20 f4 57	jsr $1a57f4	            JSR FP_POW10
.1a58cc	20 19 56	jsr $1a5619	            JSR OP_FP_MUL
.1a58cf	c2 20		rep #$20	            REP #$20
.1a58d1	a5 65		lda $0865	                LDA MARG5                       ; Check to see if the float should be negative
.1a58d3	f0 07		beq $1a58dc	                BEQ set_float_type              ; If not, just set the type
.1a58d5	a5 25		lda $0825	                LDA ARGUMENT1+2                 ; If so, set the sign bit
.1a58d7	09 00 80	ora #$8000	                ORA #$8000
.1a58da	85 25		sta $0825	                STA ARGUMENT1+2
.1a58dc					set_float_type
.1a58dc	e2 20		sep #$20	            SEP #$20
.1a58de	a9 01		lda #$01	                LDA #TYPE_FLOAT                 ; Set the type to float... ready for returning!
.1a58e0	85 27		sta $0827	                STA ARGTYPE1
.1a58e2	28		plp		                PLP
.1a58e3	60		rts		            RTS
.1a58e4					PARSENUM
.1a58e4	5a		phy		                PHY
.1a58e5	08		php		                PHP
.1a58e6	c2 30		rep #$30	            REP #$30
.1a58e8	64 23		stz $0823	                STZ ARGUMENT1       ; This will be the accumulator for building the number
.1a58ea	64 25		stz $0825	                STZ ARGUMENT1+2
.1a58ec	64 55		stz $0855	                STZ MARG1           ; This will be the integer portion of the mantissa for floats
.1a58ee	64 57		stz $0857	                STZ MARG1+2
.1a58f0	64 65		stz $0865	                STZ MARG5           ; MARG5 will be the negative flag for the number
.1a58f2	64 59		stz $0859	                STZ MARG2           ; This will be the denominator of the fractional part of the mantissa
.1a58f4	64 5b		stz $085b	                STZ MARG2+2
.1a58f6	a9 01 00	lda #$0001	                LDA #1
.1a58f9	85 5d		sta $085d	                STA MARG3           ; This will be the divisor of the fractional part of the mantissa
.1a58fb	64 5f		stz $085f	                STZ MARG3+2
.1a58fd	64 61		stz $0861	                STZ MARG4           ; This will be the exponent of a float
.1a58ff	64 63		stz $0863	                STZ MARG4+2
.1a5901	64 69		stz $0869	                STZ MARG6           ; MARG6 will be the negative flag for the exponent
.1a5903					s0
.1a5903	e2 20		sep #$20	            SEP #$20
.1a5905	a0 00 00	ldy #$0000	                LDY #0
.1a5908	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the first byte
.1a590a	c9 2b		cmp #$2b	                CMP #'+'
.1a590c	f0 33		beq $1a5941	                BEQ s1_drop         ; '+' --> S1, drop
.1a590e	c9 2d		cmp #$2d	                CMP #'-'
.1a5910	f0 2b		beq $1a593d	                BEQ s1_negative     ; Flag that the number is negative
.1a5912	c9 26		cmp #$26	                CMP #'&'
.1a5914	f0 3a		beq $1a5950	                BEQ s2_drop         ; '&' --> S2, drop
.1a5916	20 4a 04	jsr $1a044a	            JSR ISNUMERAL
.1a5919	90 03		bcc $1a591e	                BCC syntax_err
.1a591b	82 ac 00	brl $1a59ca	                BRL s7_shift        ; '0'-'9' --> S7, emit
.1a591e					syntax_err
.1a591e	08		php		            PHP
.1a591f	c2 20		rep #$20	            REP #$20
.1a5921	48		pha		            PHA
.1a5922	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5925	5b		tcd		            TCD
.1a5926	68		pla		            PLA
.1a5927	28		plp		            PLP
.1a5928	e2 20		sep #$20	            SEP #$20
.1a592a	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a592c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5930	c2 20		rep #$20	            REP #$20
.1a5932	29 ff 00	and #$00ff	            AND #$00FF
.1a5935	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a5938	e2 20		sep #$20	            SEP #$20
.1a593a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a593d	a9 01		lda #$01	s1_negative     LDA #1              ; Set the negative flag for the mantissa
.1a593f	85 65		sta $0865	                STA MARG5
.1a5941	c8		iny		s1_drop         INY                 ; Drop the character...
.1a5942	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next
.1a5944	c9 26		cmp #$26	                CMP #'&'
.1a5946	f0 08		beq $1a5950	                BEQ s2_drop         ; '&' --> S2, drop the '&'
.1a5948	20 4a 04	jsr $1a044a	            JSR ISNUMERAL
.1a594b	90 d1		bcc $1a591e	                BCC syntax_err
.1a594d	82 7a 00	brl $1a59ca	                BRL s7_shift        ; '0'-'9' --> S7, shift
.1a5950	c8		iny		s2_drop         INY                 ; Drop the character
.1a5951	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.1a5953	c9 68		cmp #$68	                CMP #'h'
.1a5955	f0 0e		beq $1a5965	                BEQ s3_drop         ; 'h', 'H' --> S3, drop
.1a5957	c9 48		cmp #$48	                CMP #'H'
.1a5959	f0 0a		beq $1a5965	                BEQ s3_drop
.1a595b	c9 62		cmp #$62	                CMP #'b'
.1a595d	f0 4c		beq $1a59ab	                BEQ s5_drop         ; 'b', 'B' --> S5, drop
.1a595f	c9 42		cmp #$42	                CMP #'B'
.1a5961	f0 48		beq $1a59ab	                BEQ s5_drop
.1a5963	80 b9		bra $1a591e	                BRA syntax_err
.1a5965	c8		iny		s3_drop         INY                 ; Drop the character
.1a5966	b7 00		lda [$0800],y	s3              LDA [BIP],Y         ; Get the next character
.1a5968	20 5b 04	jsr $1a045b	            JSR ISHEX
.1a596b	b0 02		bcs $1a596f	                BCS s4_shift
.1a596d	80 af		bra $1a591e	                BRA syntax_err
.1a596f					s4_shift
.1a596f	20 86 57	jsr $1a5786	            JSR SHIFTHEX
.1a5972	c8		iny		                INY
.1a5973	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.1a5975	20 5b 04	jsr $1a045b	            JSR ISHEX
.1a5978	b0 f5		bcs $1a596f	                BCS s4_shift        ; '0'-'9','A'-'F' --> S4, shift
.1a597a					ret_integer
.1a597a	e2 20		sep #$20	            SEP #$20
.1a597c	a5 65		lda $0865	                LDA MARG5           ; check if the number should be negative
.1a597e	f0 11		beq $1a5991	                BEQ set_int_type    ; If not, just set the type and return
.1a5980	c2 20		rep #$20	            REP #$20
.1a5982	38		sec		                SEC                 ; If so, negate it
.1a5983	a9 00 00	lda #$0000	                LDA #0
.1a5986	e5 23		sbc $0823	                SBC ARGUMENT1
.1a5988	85 23		sta $0823	                STA ARGUMENT1
.1a598a	a9 00 00	lda #$0000	                LDA #0
.1a598d	e5 25		sbc $0825	                SBC ARGUMENT1+2
.1a598f	85 25		sta $0825	                STA ARGUMENT1+2
.1a5991					set_int_type
.1a5991	e2 20		sep #$20	            SEP #$20
.1a5993	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; Return an integer
.1a5995	85 27		sta $0827	                STA ARGTYPE1
.1a5997					stop
.1a5997	c2 20		rep #$20	            REP #$20
.1a5999	18		clc		                CLC
.1a599a	98		tya		                TYA
.1a599b	65 00		adc $0800	                ADC BIP
.1a599d	85 00		sta $0800	                STA BIP
.1a599f	a5 02		lda $0802	                LDA BIP+2
.1a59a1	69 00 00	adc #$0000	                ADC #0
.1a59a4	85 02		sta $0802	                STA BIP+2
.1a59a6	e2 20		sep #$20	            SEP #$20
.1a59a8	28		plp		                PLP
.1a59a9	7a		ply		                PLY
.1a59aa	60		rts		            RTS
.1a59ab	c8		iny		s5_drop         INY                     ; Drop the character
.1a59ac	b7 00		lda [$0800],y	s5              LDA [BIP],Y             ; Get the next character
.1a59ae	c9 30		cmp #$30	                CMP #'0'
.1a59b0	f0 07		beq $1a59b9	                BEQ s6_shift            ; '0', '1' --> S6, shift
.1a59b2	c9 31		cmp #$31	                CMP #'1'
.1a59b4	f0 03		beq $1a59b9	                BEQ s6_shift
.1a59b6	82 65 ff	brl $1a591e	                BRL syntax_err
.1a59b9					s6_shift
.1a59b9	20 d6 57	jsr $1a57d6	            JSR SHIFTBIN
.1a59bc	c8		iny		                INY
.1a59bd	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a59bf	c9 30		cmp #$30	                CMP #'0'                ; '0', '1' --> S6, shift
.1a59c1	f0 f6		beq $1a59b9	                BEQ s6_shift
.1a59c3	c9 31		cmp #$31	                CMP #'1'
.1a59c5	f0 f2		beq $1a59b9	                BEQ s6_shift
.1a59c7	82 b0 ff	brl $1a597a	                BRL ret_integer         ; Return integer
.1a59ca					s7_shift
.1a59ca	20 6a 57	jsr $1a576a	            JSR SHIFTDEC
.1a59cd	c8		iny		                INY
.1a59ce	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a59d0	c9 2e		cmp #$2e	                CMP #'.'                ; '.' --> S8, drop and preserve mantissa
.1a59d2	f0 08		beq $1a59dc	                BEQ s8_mantissa
.1a59d4	20 4a 04	jsr $1a044a	            JSR ISNUMERAL
.1a59d7	b0 f1		bcs $1a59ca	                BCS s7_shift
.1a59d9	82 9e ff	brl $1a597a	                BRL ret_integer         ; Return integer
.1a59dc					s8_mantissa
.1a59dc	c2 20		rep #$20	            REP #$20
.1a59de	20 a6 5a	jsr $1a5aa6	            JSR ITOF
.1a59e1	c2 20		rep #$20	            REP #$20
.1a59e3	a5 23		lda $0823	            LDA ARGUMENT1
.1a59e5	85 55		sta $0855	            STA MARG1
.1a59e7	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a59e9	85 57		sta $0857	            STA MARG1+2
.1a59eb	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the decimal
.1a59ed	64 25		stz $0825	                STZ ARGUMENT1+2
.1a59ef	e2 20		sep #$20	            SEP #$20
.1a59f1	80 36		bra $1a5a29	                BRA s8_drop
.1a59f3					s8_shift
.1a59f3	20 6a 57	jsr $1a576a	            JSR SHIFTDEC
.1a59f6	c2 20		rep #$20	            REP #$20
.1a59f8	a5 5f		lda $085f	                LDA MARG3+2             ; high 16 bits
.1a59fa	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.1a59fe	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.1a5a01	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.1a5a05	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to high 16 bits of MARG3
.1a5a09	85 5f		sta $085f	                STA MARG3+2
.1a5a0b	a5 5d		lda $085d	                LDA MARG3
.1a5a0d	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.1a5a11	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.1a5a14	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.1a5a18	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to MARG3
.1a5a1c	85 5d		sta $085d	                STA MARG3
.1a5a1e	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.1a5a22	18		clc		                CLC
.1a5a23	65 5f		adc $085f	                ADC MARG3+2
.1a5a25	85 5f		sta $085f	                STA MARG3+2
.1a5a27	e2 20		sep #$20	            SEP #$20
.1a5a29					s8_drop
.1a5a29	c8		iny		                INY
.1a5a2a	b7 00		lda [$0800],y	                LDA [BIP],Y
.1a5a2c	c9 65		cmp #$65	                CMP #'e'                ; 'E' --> S9, drop
.1a5a2e	f0 24		beq $1a5a54	                BEQ s9_drop
.1a5a30	c9 45		cmp #$45	                CMP #'E'
.1a5a32	f0 20		beq $1a5a54	                BEQ s9_drop
.1a5a34	20 4a 04	jsr $1a044a	            JSR ISNUMERAL
.1a5a37	b0 ba		bcs $1a59f3	                BCS s8_shift
.1a5a39	c2 20		rep #$20	            REP #$20
.1a5a3b	20 a6 5a	jsr $1a5aa6	            JSR ITOF
.1a5a3e	c2 20		rep #$20	            REP #$20
.1a5a40	a5 23		lda $0823	            LDA ARGUMENT1
.1a5a42	85 59		sta $0859	            STA MARG2
.1a5a44	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5a46	85 5b		sta $085b	            STA MARG2+2
.1a5a48	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.1a5a4a	64 25		stz $0825	                STZ ARGUMENT1+2
.1a5a4c	20 8d 58	jsr $1a588d	            JSR PACKFLOAT
.1a5a4f	e2 20		sep #$20	            SEP #$20
.1a5a51	82 43 ff	brl $1a5997	                BRL stop
.1a5a54					s9_drop
.1a5a54	c2 20		rep #$20	            REP #$20
.1a5a56	20 a6 5a	jsr $1a5aa6	            JSR ITOF
.1a5a59	c2 20		rep #$20	            REP #$20
.1a5a5b	a5 23		lda $0823	            LDA ARGUMENT1
.1a5a5d	85 59		sta $0859	            STA MARG2
.1a5a5f	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5a61	85 5b		sta $085b	            STA MARG2+2
.1a5a63	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.1a5a65	64 25		stz $0825	                STZ ARGUMENT1+2
.1a5a67	e2 20		sep #$20	            SEP #$20
.1a5a69	c8		iny		                INY
.1a5a6a	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5a6c	c9 2b		cmp #$2b	                CMP #'+'
.1a5a6e	f0 10		beq $1a5a80	                BEQ s10_drop            ; '+' --> S10, drop
.1a5a70	c9 2d		cmp #$2d	                CMP #'-'
.1a5a72	f0 08		beq $1a5a7c	                BEQ s10_setneg          ; '-' --> S10, set exponent is negative
.1a5a74	20 4a 04	jsr $1a044a	            JSR ISNUMERAL
.1a5a77	b0 12		bcs $1a5a8b	                BCS S11_shift           ; '0'-'9' --> S11, shift
.1a5a79	82 a2 fe	brl $1a591e	                BRL syntax_err
.1a5a7c					s10_setneg
.1a5a7c	a9 01		lda #$01	                LDA #1                  ; Set that the exponent should be negative
.1a5a7e	85 69		sta $0869	                STA MARG6
.1a5a80					s10_drop
.1a5a80	c8		iny		                INY
.1a5a81	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5a83	20 4a 04	jsr $1a044a	            JSR ISNUMERAL
.1a5a86	b0 03		bcs $1a5a8b	                BCS s11_shift
.1a5a88	82 93 fe	brl $1a591e	                BRL syntax_err
.1a5a8b					s11_shift
.1a5a8b	20 6a 57	jsr $1a576a	            JSR SHIFTDEC
.1a5a8e	c8		iny		                INY
.1a5a8f	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5a91	20 4a 04	jsr $1a044a	            JSR ISNUMERAL
.1a5a94	b0 f5		bcs $1a5a8b	                BCS s11_shift
.1a5a96	c2 20		rep #$20	            REP #$20
.1a5a98	a5 23		lda $0823	            LDA ARGUMENT1
.1a5a9a	85 61		sta $0861	            STA MARG4
.1a5a9c	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5a9e	85 63		sta $0863	            STA MARG4+2
.1a5aa0	20 8d 58	jsr $1a588d	            JSR PACKFLOAT
.1a5aa3	82 f1 fe	brl $1a5997	                BRL stop
.1a5aa6					ITOF
.1a5aa6	08		php		                PHP
.1a5aa7	20 34 55	jsr $1a5534	            JSR FIXINT_TO_FP
.1a5aaa	28		plp		done            PLP
.1a5aab	60		rts		            RTS
.1a5aac					FTOI
.1a5aac	08		php		                PHP
.1a5aad					LOCALS
>0001					l_sign          .byte ?
>0002					l_exponent      .byte ?
>0003					l_mantissa      .dword ?
.1a5aad	c2 20		rep #$20	            REP #$20
.1a5aaf	a9 a3 5d	lda #$5da3	                LDA #<>FP_1_0
.1a5ab2	85 29		sta $0829	                STA ARGUMENT2
.1a5ab4	a9 1a 00	lda #$001a	                LDA #(FP_1_0 >> 16)
.1a5ab7	85 2b		sta $082b	                STA ARGUMENT2+2
.1a5ab9	e2 20		sep #$20	            SEP #$20
.1a5abb	a9 01		lda #$01	                LDA #TYPE_FLOAT
.1a5abd	85 2d		sta $082d	                STA ARGTYPE2
.1a5abf	c2 20		rep #$20	            REP #$20
.1a5ac1	20 7f 5b	jsr $1a5b7f	            JSR FP_COMPARE
.1a5ac4	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a5ac7	d0 0c		bne $1a5ad5	                BNE alloc_locals        ; No: get ready to do the full conversion
.1a5ac9	a9 00 00	lda #$0000	                LDA #0
.1a5acc	8d 23 08	sta $0823	                STA @w ARGUMENT1        ; Yes: Return 0
.1a5acf	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.1a5ad2	82 a1 00	brl $1a5b76	                BRL done
.1a5ad5	f4 00 00	pea #$0000	alloc_locals    PEA #0                  ; Reserve space for the locals
.1a5ad8	f4 00 00	pea #$0000	                PEA #0
.1a5adb	f4 00 00	pea #$0000	                PEA #0
.1a5ade	e2 20		sep #$20	            SEP #$20
.1a5ae0	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3      ; Preserve the sign bit
.1a5ae3	29 80		and #$80	                AND #$80
.1a5ae5	83 01		sta $01,s	                STA l_sign
.1a5ae7	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2      ; Preserve the exponent
.1a5aea	2a		rol a		                ROL A
.1a5aeb	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3
.1a5aee	2a		rol a		                ROL A
.1a5aef	83 02		sta $02,s	                STA l_exponent
.1a5af1	a9 00		lda #$00	save_mantissa   LDA #0                  ; Save the mantissa (with the implied 1)
.1a5af3	83 06		sta $06,s	                STA l_mantissa+3
.1a5af5	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2
.1a5af8	09 80		ora #$80	                ORA #$80
.1a5afa	83 05		sta $05,s	                STA l_mantissa+2
.1a5afc	ad 24 08	lda $0824	                LDA @w ARGUMENT1+1
.1a5aff	83 04		sta $04,s	                STA l_mantissa+1
.1a5b01	ad 23 08	lda $0823	                LDA @w ARGUMENT1
.1a5b04	83 03		sta $03,s	                STA l_mantissa
.1a5b06	a3 02		lda $02,s	                LDA l_exponent
.1a5b08	c9 96		cmp #$96	loop            CMP #150
.1a5b0a	f0 3a		beq $1a5b46	                BEQ adj_sign
.1a5b0c	90 1f		bcc $1a5b2d	                BLT shift_right
.1a5b0e	08		php		            PHP
.1a5b0f	c2 20		rep #$20	            REP #$20
.1a5b11	48		pha		            PHA
.1a5b12	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5b15	5b		tcd		            TCD
.1a5b16	68		pla		            PLA
.1a5b17	28		plp		            PLP
.1a5b18	e2 20		sep #$20	            SEP #$20
.1a5b1a	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.1a5b1c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5b20	c2 20		rep #$20	            REP #$20
.1a5b22	29 ff 00	and #$00ff	            AND #$00FF
.1a5b25	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a5b28	e2 20		sep #$20	            SEP #$20
.1a5b2a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5b2d					shift_right
.1a5b2d	c2 20		rep #$20	            REP #$20
.1a5b2f	a3 05		lda $05,s	                LDA l_mantissa+2
.1a5b31	4a		lsr a		                LSR A
.1a5b32	83 05		sta $05,s	                STA l_mantissa+2
.1a5b34	a3 03		lda $03,s	                LDA l_mantissa
.1a5b36	6a		ror a		                ROR A
.1a5b37	83 03		sta $03,s	                STA l_mantissa
.1a5b39	e2 20		sep #$20	            SEP #$20
.1a5b3b	a3 02		lda $02,s	                LDA l_exponent
.1a5b3d	1a		inc a		                INC A
.1a5b3e	83 02		sta $02,s	                STA l_exponent
.1a5b40	c9 96		cmp #$96	                CMP #150
.1a5b42	f0 02		beq $1a5b46	                BEQ adj_sign
.1a5b44	80 e7		bra $1a5b2d	                BRA shift_right
.1a5b46	a3 01		lda $01,s	adj_sign        LDA l_sign
.1a5b48	f0 1b		beq $1a5b65	                BEQ ret_positive
.1a5b4a	c2 20		rep #$20	            REP #$20
.1a5b4c	a3 03		lda $03,s	                LDA l_mantissa
.1a5b4e	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a5b51	18		clc		                CLC
.1a5b52	69 01 00	adc #$0001	                ADC #1
.1a5b55	8d 23 08	sta $0823	                STA @w ARGUMENT1
.1a5b58	a3 05		lda $05,s	                LDA l_mantissa+2
.1a5b5a	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a5b5d	69 00 00	adc #$0000	                ADC #0
.1a5b60	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.1a5b63	80 0c		bra $1a5b71	                BRA clean
.1a5b65					ret_positive
.1a5b65	c2 20		rep #$20	            REP #$20
.1a5b67	a3 03		lda $03,s	                LDA l_mantissa
.1a5b69	8d 23 08	sta $0823	                STA @w ARGUMENT1
.1a5b6c	a3 05		lda $05,s	                LDA l_mantissa+2
.1a5b6e	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.1a5b71					clean
.1a5b71	c2 20		rep #$20	            REP #$20
.1a5b73	68		pla		                PLA                     ; Clean up the locals
.1a5b74	68		pla		                PLA
.1a5b75	68		pla		                PLA
.1a5b76					done
.1a5b76	e2 20		sep #$20	            SEP #$20
.1a5b78	a9 00		lda #$00	                LDA #TYPE_INTEGER       ; Set the return type to integer
.1a5b7a	8d 27 08	sta $0827	                STA @w ARGTYPE1
.1a5b7d	28		plp		                PLP
.1a5b7e	60		rts		            RTS
.1a5b7f					FP_COMPARE
.1a5b7f	da		phx		                PHX
.1a5b80	08		php		                PHP
.1a5b81	c2 20		rep #$20	            REP #$20
.1a5b83	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save ARGUMENT1 so we don't destroy it
.1a5b85	48		pha		                PHA
.1a5b86	a5 23		lda $0823	                LDA ARGUMENT1
.1a5b88	48		pha		                PHA
.1a5b89	20 78 55	jsr $1a5578	            JSR OP_FP_SUB
.1a5b8c	20 56 57	jsr $1a5756	            JSR FARG1EQ0
.1a5b8f	b0 11		bcs $1a5ba2	                BCS are_equal
.1a5b91	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Check the high word
.1a5b93	89 00 80	bit #$8000	                BIT #$8000
.1a5b96	d0 05		bne $1a5b9d	                BNE is_lt                   ; ARGUMENT1 < ARGUMENT2
.1a5b98	a9 01 00	lda #$0001	is_gt           LDA #1                      ; ARGUMENT1 > ARGUMENT2: return 1
.1a5b9b	80 08		bra $1a5ba5	                BRA ret_result
.1a5b9d	a9 ff ff	lda #$ffff	is_lt           LDA #$FFFF                  ; ARGUMENT1 > ARGUMENT2: return -1
.1a5ba0	80 03		bra $1a5ba5	                BRA ret_result
.1a5ba2	a9 00 00	lda #$0000	are_equal       LDA #0                      ; Equal: return 0
.1a5ba5	fa		plx		ret_result      PLX                         ; Restore ARGUMENT1
.1a5ba6	86 23		stx $0823	                STX ARGUMENT1
.1a5ba8	fa		plx		                PLX
.1a5ba9	86 25		stx $0825	                STX ARGUMENT1+2
.1a5bab	28		plp		                PLP
.1a5bac	fa		plx		                PLX
.1a5bad	60		rts		            RTS
.1a5bae					OP_FP_LT
.1a5bae	08		php		                PHP
.1a5baf	c2 30		rep #$30	            REP #$30
.1a5bb1	20 7f 5b	jsr $1a5b7f	            JSR FP_COMPARE
.1a5bb4	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a5bb7	d0 05		bne $1a5bbe	                BNE ret_false
.1a5bb9	20 7c 05	jsr $1a057c	            JSR SET_TRUE
.1a5bbc	80 03		bra $1a5bc1	                BRA done
.1a5bbe					ret_false
.1a5bbe	20 8e 05	jsr $1a058e	            JSR SET_FALSE
.1a5bc1	28		plp		done            PLP
.1a5bc2	60		rts		            RTS
.1a5bc3					OP_FP_GT
.1a5bc3	08		php		                PHP
.1a5bc4	c2 30		rep #$30	            REP #$30
.1a5bc6	20 7f 5b	jsr $1a5b7f	            JSR FP_COMPARE
.1a5bc9	c9 01 00	cmp #$0001	                CMP #1
.1a5bcc	d0 05		bne $1a5bd3	                BNE ret_false
.1a5bce	20 7c 05	jsr $1a057c	            JSR SET_TRUE
.1a5bd1	80 03		bra $1a5bd6	                BRA done
.1a5bd3					ret_false
.1a5bd3	20 8e 05	jsr $1a058e	            JSR SET_FALSE
.1a5bd6	28		plp		done            PLP
.1a5bd7	60		rts		            RTS
.1a5bd8					OP_FP_EQ
.1a5bd8	08		php		                PHP
.1a5bd9	c2 30		rep #$30	            REP #$30
.1a5bdb	20 7f 5b	jsr $1a5b7f	            JSR FP_COMPARE
.1a5bde	c9 00 00	cmp #$0000	                CMP #0
.1a5be1	d0 05		bne $1a5be8	                BNE ret_false
.1a5be3	20 7c 05	jsr $1a057c	            JSR SET_TRUE
.1a5be6	80 03		bra $1a5beb	                BRA done
.1a5be8					ret_false
.1a5be8	20 8e 05	jsr $1a058e	            JSR SET_FALSE
.1a5beb	28		plp		done            PLP
.1a5bec	60		rts		            RTS
.1a5bed					OP_FP_LTE
.1a5bed	08		php		                PHP
.1a5bee	c2 30		rep #$30	            REP #$30
.1a5bf0	20 7f 5b	jsr $1a5b7f	            JSR FP_COMPARE
.1a5bf3	c9 01 00	cmp #$0001	                CMP #1
.1a5bf6	f0 05		beq $1a5bfd	                BEQ ret_false
.1a5bf8	20 7c 05	jsr $1a057c	            JSR SET_TRUE
.1a5bfb	80 03		bra $1a5c00	                BRA done
.1a5bfd					ret_false
.1a5bfd	20 8e 05	jsr $1a058e	            JSR SET_FALSE
.1a5c00	28		plp		done            PLP
.1a5c01	60		rts		            RTS
.1a5c02					OP_FP_GTE
.1a5c02	08		php		                PHP
.1a5c03	c2 30		rep #$30	            REP #$30
.1a5c05	20 7f 5b	jsr $1a5b7f	            JSR FP_COMPARE
.1a5c08	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a5c0b	f0 05		beq $1a5c12	                BEQ ret_false
.1a5c0d	20 7c 05	jsr $1a057c	            JSR SET_TRUE
.1a5c10	80 03		bra $1a5c15	                BRA done
.1a5c12					ret_false
.1a5c12	20 8e 05	jsr $1a058e	            JSR SET_FALSE
.1a5c15	28		plp		done            PLP
.1a5c16	60		rts		            RTS
.1a5c17					OP_FP_NE
.1a5c17	08		php		                PHP
.1a5c18	c2 30		rep #$30	            REP #$30
.1a5c1a	20 7f 5b	jsr $1a5b7f	            JSR FP_COMPARE
.1a5c1d	c9 00 00	cmp #$0000	                CMP #0
.1a5c20	f0 05		beq $1a5c27	                BEQ ret_false
.1a5c22	20 7c 05	jsr $1a057c	            JSR SET_TRUE
.1a5c25	80 03		bra $1a5c2a	                BRA done
.1a5c27					ret_false
.1a5c27	20 8e 05	jsr $1a058e	            JSR SET_FALSE
.1a5c2a	28		plp		done            PLP
.1a5c2b	60		rts		            RTS
.1a5c2c					STREMIT
.1a5c2c	08		php		                PHP
.1a5c2d	e2 20		sep #$20	            SEP #$20
.1a5c2f	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Append the character
.1a5c31	c8		iny		                INY                         ; Advance the character pointer in Y
.1a5c32	a9 00		lda #$00	                LDA #0                      ; And add the NULL
.1a5c34	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.1a5c36	28		plp		                PLP
.1a5c37	60		rts		            RTS
.1a5c38					STREMITB
.1a5c38	da		phx		                PHX
.1a5c39	08		php		                PHP
.1a5c3a	e2 20		sep #$20	            SEP #$20
.1a5c3c	c9 80		cmp #$80	                CMP #$80
.1a5c3e	90 0a		bcc $1a5c4a	                BLT emit_digits
.1a5c40	48		pha		                PHA
.1a5c41	a9 2d		lda #$2d	                LDA #'-'                    ; Print a minus sign
.1a5c43	20 2c 5c	jsr $1a5c2c	            JSR STREMIT
.1a5c46	68		pla		                PLA
.1a5c47	49 ff		eor #$ff	                EOR #$FF                    ; And negate it
.1a5c49	1a		inc a		                INC A
.1a5c4a					emit_digits
.1a5c4a	c2 30		rep #$30	            REP #$30
.1a5c4c	29 ff 00	and #$00ff	                AND #$00FF
.1a5c4f	c9 64 00	cmp #$0064	                CMP #100
.1a5c52	90 0e		bcc $1a5c62	                BLT chk_tens
.1a5c54	a2 64 00	ldx #$0064	                LDX #100
.1a5c57	20 1d 55	jsr $1a551d	            JSR UINT_DIV_A_X
.1a5c5a	18		clc		                CLC
.1a5c5b	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.1a5c5e	20 2c 5c	jsr $1a5c2c	            JSR STREMIT
.1a5c61	8a		txa		                TXA                         ; Put the remainder in A
.1a5c62					chk_tens
.1a5c62	a2 0a 00	ldx #$000a	                LDX #10
.1a5c65	20 1d 55	jsr $1a551d	            JSR UINT_DIV_A_X
.1a5c68	18		clc		                CLC
.1a5c69	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.1a5c6c	20 2c 5c	jsr $1a5c2c	            JSR STREMIT
.1a5c6f	8a		txa		                TXA                         ; Put the remainder in A
.1a5c70					ones_digit
.1a5c70	18		clc		                CLC
.1a5c71	69 30 00	adc #$0030	                ADC #'0'                    ; Convert it to ASCII
.1a5c74	20 2c 5c	jsr $1a5c2c	            JSR STREMIT
.1a5c77	28		plp		                PLP
.1a5c78	fa		plx		                PLX
.1a5c79	60		rts		            RTS
.1a5c7a					STRFINDEND
.1a5c7a	08		php		                PHP
.1a5c7b	e2 20		sep #$20	            SEP #$20
.1a5c7d	c2 10		rep #$10	            REP #$10
.1a5c7f	a0 00 00	ldy #$0000	                LDY #0
.1a5c82	b7 23		lda [$0823],y	find_end        LDA [ARGUMENT1],Y           ; Scan to the end of the string
.1a5c84	f0 03		beq $1a5c89	                BEQ done
.1a5c86	c8		iny		                INY
.1a5c87	80 f9		bra $1a5c82	                BRA find_end
.1a5c89	28		plp		done            PLP
.1a5c8a	60		rts		            RTS
=6					FP_D = 6        ; Number of mantissa digits
.1a5c8b					FTOS
.1a5c8b	08		php		                PHP
.1a5c8c	e2 20		sep #$20	            SEP #$20
.1a5c8e	c2 10		rep #$10	            REP #$10
.1a5c90	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be the negative flag
.1a5c93	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be K
.1a5c96	f4 00 00	pea #$0000	                PEA #0                      ; This spot will be for the exponents
>0001					L_NEGATIVE      .word ?
>0003					L_K             .word ?
>0005					L_X1            .byte ?                     ; The binary exponent
>0006					L_EXP           .byte ?                     ; The decimal exponent
.1a5c99	20 56 57	jsr $1a5756	            JSR FARG1EQ0
.1a5c9c	90 19		bcc $1a5cb7	                BCC chk_negative
.1a5c9e	20 4b 14	jsr $1a144b	            JSR TEMPSTRING
.1a5ca1	e2 20		sep #$20	            SEP #$20
.1a5ca3	a0 00 00	ldy #$0000	                LDY #0
.1a5ca6	a9 20		lda #$20	                LDA #' '
.1a5ca8	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a5caa	c8		iny		                INY
.1a5cab	a9 30		lda #$30	                LDA #'0'                    ; Return a "0"
.1a5cad	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a5caf	c8		iny		                INY
.1a5cb0	a9 00		lda #$00	                LDA #0
.1a5cb2	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a5cb4	82 ce 00	brl $1a5d85	                BRL ret_result
.1a5cb7					chk_negative
.1a5cb7	e2 20		sep #$20	            SEP #$20
.1a5cb9	a5 26		lda $0826	                LDA ARGUMENT1+3             ; If N is negative, output a minus sign and negate N
.1a5cbb	10 08		bpl $1a5cc5	                BPL not_negative
.1a5cbd	29 7f		and #$7f	                AND #$7F                    ; Negate the number
.1a5cbf	85 26		sta $0826	                STA ARGUMENT1+3
.1a5cc1	a9 01		lda #$01	                LDA #1
.1a5cc3	83 01		sta $01,s	                STA L_NEGATIVE              ; Set IsNegative to a TRUE value
.1a5cc5					not_negative
.1a5cc5	c2 20		rep #$20	            REP #$20
.1a5cc7	a9 00 00	lda #$0000	                LDA #0                      ; Initialize K to 0, K is a 1-byte signed integer. (SCRATCH is K)
.1a5cca	83 03		sta $03,s	                STA L_K                     ; We're using a word here for convenience
.1a5ccc	c2 20		rep #$20	            REP #$20
.1a5cce	af 9f 5d 1a	lda $1a5d9f	            LDA ten_d_1
.1a5cd2	85 29		sta $0829	            STA ARGUMENT2
.1a5cd4	af a1 5d 1a	lda $1a5da1	            LDA ten_d_1+2
.1a5cd8	85 2b		sta $082b	            STA ARGUMENT2+2
.1a5cda	20 7f 5b	jsr $1a5b7f	            JSR FP_COMPARE
.1a5cdd	89 00 80	bit #$8000	                BIT #$8000                  ; Is N < 10^(D-1)?
.1a5ce0	d0 12		bne $1a5cf4	                BNE shift_up
.1a5ce2					shift_down
.1a5ce2	20 1a 57	jsr $1a571a	            JSR FP_DIV10
.1a5ce5	a3 03		lda $03,s	                LDA L_K
.1a5ce7	1a		inc a		                INC A
.1a5ce8	83 03		sta $03,s	                STA L_K                     ; Increment K
.1a5cea	20 7f 5b	jsr $1a5b7f	            JSR FP_COMPARE
.1a5ced	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N < 10^(D-1)?
.1a5cf0	f0 12		beq $1a5d04	                BEQ do_digits               ; Yes: we're ready to process digits
.1a5cf2	80 ee		bra $1a5ce2	                BRA shift_down              ; No: keep dividing
.1a5cf4					shift_up
.1a5cf4	20 d1 56	jsr $1a56d1	            JSR FP_MUL10
.1a5cf7	a3 03		lda $03,s	                LDA L_K
.1a5cf9	3a		dec a		                DEC A
.1a5cfa	83 03		sta $03,s	                STA L_K                     ; Decrement K
.1a5cfc	20 7f 5b	jsr $1a5b7f	            JSR FP_COMPARE
.1a5cff	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N >= 10 ^ (D-1)?
.1a5d02	f0 f0		beq $1a5cf4	                BEQ shift_up                ; No: keep multiplying
.1a5d04					do_digits
.1a5d04	e2 30		sep #$30	            SEP #$30
.1a5d06	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5d08	0a		asl a		                ASL A
.1a5d09	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a5d0b	2a		rol a		                ROL A
.1a5d0c	83 05		sta $05,s	                STA L_X1
.1a5d0e	38		sec		                SEC
.1a5d0f	a9 96		lda #$96	                LDA #150                    ; X := 150 - X1
.1a5d11	e3 05		sbc $05,s	                SBC L_X1
.1a5d13	aa		tax		                TAX
.1a5d14	f0 0f		beq $1a5d25	                BEQ emit_digits             ; If X = 0, just emit the digits
.1a5d16	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Set the implied '1' MSB of the mantissa
.1a5d18	09 80		ora #$80	                ORA #$80
.1a5d1a	85 25		sta $0825	                STA ARGUMENT1+2
.1a5d1c	46 25		lsr $0825	shift_r         LSR ARGUMENT1+2             ; Shift the mantissa right
.1a5d1e	66 24		ror $0824	                ROR ARGUMENT1+1
.1a5d20	66 23		ror $0823	                ROR ARGUMENT1
.1a5d22	ca		dex		                DEX
.1a5d23	d0 f7		bne $1a5d1c	                BNE shift_r                 ; Until X = 0
.1a5d25					emit_digits
.1a5d25	c2 10		rep #$10	            REP #$10
.1a5d27	e2 20		sep #$20	            SEP #$20
.1a5d29	64 26		stz $0826	                STZ ARGUMENT1+3             ; Blank out the MSB
.1a5d2b	a9 00		lda #$00	                LDA #TYPE_INTEGER           ; Make it an integer
.1a5d2d	85 27		sta $0827	                STA ARGTYPE1
.1a5d2f	a3 01		lda $01,s	                LDA L_NEGATIVE              ; Check IsNegative
.1a5d31	f0 11		beq $1a5d44	                BEQ get_raw_digits          ; If FALSE, just convert the raw digits
.1a5d33	c2 20		rep #$20	            REP #$20
.1a5d35	38		sec		                SEC                         ; Make the raw integer negative
.1a5d36	a9 00 00	lda #$0000	                LDA #0
.1a5d39	e5 23		sbc $0823	                SBC ARGUMENT1
.1a5d3b	85 23		sta $0823	                STA ARGUMENT1
.1a5d3d	a9 00 00	lda #$0000	                LDA #0
.1a5d40	e5 25		sbc $0825	                SBC ARGUMENT1+2
.1a5d42	85 25		sta $0825	                STA ARGUMENT1+2
.1a5d44					get_raw_digits
.1a5d44	20 aa 14	jsr $1a14aa	            JSR ITOS
.1a5d47	c2 20		rep #$20	            REP #$20
.1a5d49	a5 16		lda $0816	            LDA STRPTR
.1a5d4b	85 23		sta $0823	            STA ARGUMENT1
.1a5d4d	a5 18		lda $0818	            LDA STRPTR+2
.1a5d4f	85 25		sta $0825	            STA ARGUMENT1+2
.1a5d51	20 7a 5c	jsr $1a5c7a	            JSR STRFINDEND
.1a5d54	e2 20		sep #$20	            SEP #$20
.1a5d56	c8		iny		                INY                         ; Move the NULL up one byte
.1a5d57	a9 00		lda #$00	                LDA #0
.1a5d59	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.1a5d5b	88		dey		insert_loop     DEY                         ; Move to the character before the one we just moved
.1a5d5c	88		dey		                DEY
.1a5d5d	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y           ; Get the character
.1a5d5f	c8		iny		                INY                         ; Move to the next space
.1a5d60	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Store the character here
.1a5d62	c0 02 00	cpy #$0002	                CPY #2                      ; Check to see if we just moved the 2nd character
.1a5d65	d0 f4		bne $1a5d5b	                BNE insert_loop             ; If not, keep moving the characters
.1a5d67	a9 2e		lda #$2e	                LDA #'.'                    ; Insert the '.' in the space we openned
.1a5d69	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.1a5d6b	e2 20		sep #$20	            SEP #$20
.1a5d6d	18		clc		                CLC                         ; Compute the exponent
.1a5d6e	a3 03		lda $03,s	                LDA L_K
.1a5d70	69 05		adc #$05	                ADC #(FP_D - 1)
.1a5d72	83 06		sta $06,s	                STA L_EXP
.1a5d74	f0 19		beq $1a5d8f	                BEQ done                    ; If it's 0, just return the number
.1a5d76	20 7a 5c	jsr $1a5c7a	            JSR STRFINDEND
.1a5d79	a9 45		lda #$45	                LDA #'E'                    ; Append the "E"
.1a5d7b	20 2c 5c	jsr $1a5c2c	            JSR STREMIT
.1a5d7e	a3 06		lda $06,s	                LDA L_EXP
.1a5d80	20 38 5c	jsr $1a5c38	            JSR STREMITB
.1a5d83	80 0a		bra $1a5d8f	                BRA done                    ; TODO: reformat integer... add E and exponent...
.1a5d85					ret_result
.1a5d85	c2 20		rep #$20	            REP #$20
.1a5d87	a5 16		lda $0816	                LDA STRPTR                  ; Return the temporary string we've assembled
.1a5d89	85 23		sta $0823	                STA ARGUMENT1
.1a5d8b	a5 18		lda $0818	                LDA STRPTR+2
.1a5d8d	85 25		sta $0825	                STA ARGUMENT1+2
.1a5d8f					done
.1a5d8f	e2 20		sep #$20	            SEP #$20
.1a5d91	a9 02		lda #$02	                LDA #TYPE_STRING
.1a5d93	85 27		sta $0827	                STA ARGTYPE1
.1a5d95	c2 20		rep #$20	            REP #$20
.1a5d97	3b		tsc		                TSC                         ; Remove the locals from the stack
.1a5d98	18		clc		                CLC
.1a5d99	69 06 00	adc #$0006	                ADC #6
.1a5d9c	1b		tcs		                TCS
.1a5d9d	28		plp		                PLP
.1a5d9e	60		rts		            RTS
>1a5d9f	00 50 c3 47			ten_d_1         .dword $47c35000            ; 10^(FP_D-1), where FP_D=5
>1a5da3	00 00 80 3f			FP_1_0          .dword $3f800000    ; Floating point constant: 1.0
>1a5da7	f3 04 b5 3f			FP_SQR_2_0      .dword $3fb504f3    ; Floating point constant: sqrt(2.0)
>1a5dab	f3 04 35 3f			FP_SQR_0_5      .dword $3f3504f3    ; Floating point constant: sqrt(0.2)

;******  Return to file: src\basic816.s


;******  Processing file: src\transcendentals.s

.1a5daf					Q_POLY_HR
.1a5daf	e2 20		sep #$20	            SEP #$20
.1a5db1	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a5db3	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5db7	c2 20		rep #$20	            REP #$20
.1a5db9	bd 00 00	lda $0000,x	                LDA 0,X
.1a5dbc	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5dc0	bd 02 00	lda $0002,x	                LDA 2,X
.1a5dc3	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5dc7	88		dey		                DEY             ; (Y-1) more coefficients.
.1a5dc8	e8		inx		loop            INX             ; point to the next coefficient
.1a5dc9	e8		inx		                INX
.1a5dca	e8		inx		                INX
.1a5dcb	e8		inx		                INX
.1a5dcc	e2 20		sep #$20	            SEP #$20
.1a5dce	a9 00		lda #$00	                LDA #FP_OUT_MULT
.1a5dd0	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5dd4	c2 20		rep #$20	            REP #$20
.1a5dd6	af 23 08 00	lda $000823	                LDA @l ARGUMENT1
.1a5dda	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5dde	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a5de2	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5de6	ea		nop		                NOP
.1a5de7	ea		nop		                NOP
.1a5de8	ea		nop		                NOP
.1a5de9	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5ded	48		pha		                PHA
.1a5dee	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5df2	8f 0a e2 af	sta $afe20a	                STA FP_MATH_INPUT0_HL
.1a5df6	68		pla		                PLA
.1a5df7	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5dfb	e2 20		sep #$20	            SEP #$20
.1a5dfd	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a5dff	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5e03	c2 20		rep #$20	            REP #$20
.1a5e05	bd 00 00	lda $0000,x	                LDA 0,X
.1a5e08	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5e0c	bd 02 00	lda $0002,x	                LDA 2,X
.1a5e0f	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5e13	ea		nop		                NOP
.1a5e14	ea		nop		                NOP
.1a5e15	ea		nop		                NOP
.1a5e16	88		dey		                DEY
.1a5e17	f0 14		beq $1a5e2d	                BEQ done
.1a5e19	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5e1d	48		pha		                PHA
.1a5e1e	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5e22	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5e26	68		pla		                PLA
.1a5e27	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5e2b	80 9b		bra $1a5dc8	                BRA loop
.1a5e2d	af 08 e2 af	lda $afe208	done            LDA @l FP_MATH_OUTPUT_FP_LL
.1a5e31	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.1a5e35	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5e39	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.1a5e3d	60		rts		                RTS
.1a5e3e					Q_SQ
.1a5e3e	e2 20		sep #$20	            SEP #$20
.1a5e40	a9 00		lda #$00	                LDA #0
.1a5e42	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5e46	a9 00		lda #$00	                LDA #FP_OUT_MULT
.1a5e48	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5e4c	c2 20		rep #$20	            REP #$20
.1a5e4e	a5 23		lda $0823	                LDA ARGUMENT1
.1a5e50	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5e54	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5e58	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a5e5c	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5e60	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5e64	ea		nop		                NOP
.1a5e65	ea		nop		                NOP
.1a5e66	ea		nop		                NOP
.1a5e67	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5e6b	85 23		sta $0823	                STA ARGUMENT1
.1a5e6d	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5e71	85 25		sta $0825	                STA ARGUMENT1+2
.1a5e73	60		rts		                RTS
.1a5e74					Q_INV
.1a5e74	e2 20		sep #$20	            SEP #$20
.1a5e76	a9 00		lda #$00	                LDA #0
.1a5e78	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5e7c	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a5e7e	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5e82	c2 20		rep #$20	            REP #$20
.1a5e84	a5 23		lda $0823	                LDA ARGUMENT1
.1a5e86	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5e8a	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a5e8e	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5e92	af c8 64 1a	lda $1a64c8	                LDA @l fp_one
.1a5e96	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5e9a	af ca 64 1a	lda $1a64ca	                LDA @l fp_one+2
.1a5e9e	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5ea2	ea		nop		                NOP
.1a5ea3	ea		nop		                NOP
.1a5ea4	ea		nop		                NOP
.1a5ea5	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5ea9	85 23		sta $0823	                STA ARGUMENT1
.1a5eab	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5eaf	85 25		sta $0825	                STA ARGUMENT1+2
.1a5eb1	60		rts		                RTS
.1a5eb2					Q_FP_SCALE
.1a5eb2	a2 00 00	ldx #$0000	                LDX #0
.1a5eb5	a5 23		lda $0823	loop            LDA ARGUMENT1
.1a5eb7	c5 29		cmp $0829	                CMP ARGUMENT2
.1a5eb9	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5ebb	e5 2b		sbc $082b	                SBC ARGUMENT2+2
.1a5ebd	90 1e		bcc $1a5edd	                BCC done
.1a5ebf	a5 23		lda $0823	                LDA ARGUMENT1
.1a5ec1	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5ec5	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5ec7	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5ecb	ea		nop		                NOP
.1a5ecc	ea		nop		                NOP
.1a5ecd	ea		nop		                NOP
.1a5ece	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5ed2	85 23		sta $0823	                STA ARGUMENT1
.1a5ed4	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5ed8	85 25		sta $0825	                STA ARGUMENT1+2
.1a5eda	e8		inx		                INX
.1a5edb	80 d8		bra $1a5eb5	                BRA loop
.1a5edd					done
.1a5edd	60		rts		            RTS
.1a5ede					Q_FP_SCALE_TAU
.1a5ede	e2 20		sep #$20	            SEP #$20
.1a5ee0	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a5ee2	10 09		bpl $1a5eed	                BPL notneg
.1a5ee4	29 7f		and #$7f	                AND #$7F
.1a5ee6	85 26		sta $0826	                STA ARGUMENT1+3
.1a5ee8	a9 01		lda #$01	                LDA #1
.1a5eea	48		pha		                PHA
.1a5eeb	80 03		bra $1a5ef0	                BRA compute
.1a5eed	a9 00		lda #$00	notneg          LDA #0          ; not negative, so push 0.
.1a5eef	48		pha		                PHA
.1a5ef0	a9 40		lda #$40	compute         LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a5ef2	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5ef6	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a5ef8	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5efc	c2 30		rep #$30	            REP #$30
.1a5efe	af 30 65 1a	lda $1a6530	                LDA @l twopi
.1a5f02	85 29		sta $0829	                STA ARGUMENT2
.1a5f04	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5f08	af 32 65 1a	lda $1a6532	                LDA @l twopi+2
.1a5f0c	85 2b		sta $082b	                STA ARGUMENT2+2
.1a5f0e	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5f12	20 b2 5e	jsr $1a5eb2	            JSR Q_FP_SCALE
.1a5f15	e2 20		sep #$20	            SEP #$20
.1a5f17	68		pla		                PLA
.1a5f18	c2 20		rep #$20	            REP #$20
.1a5f1a	f0 1e		beq $1a5f3a	                BEQ done
.1a5f1c	a5 23		lda $0823	                LDA ARGUMENT1
.1a5f1e	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5f22	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5f24	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5f28	ea		nop		                NOP
.1a5f29	ea		nop		                NOP
.1a5f2a	ea		nop		                NOP
.1a5f2b	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5f2f	85 23		sta $0823	                STA ARGUMENT1
.1a5f31	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5f35	29 ff 7f	and #$7fff	                AND #$7fff
.1a5f38	85 25		sta $0825	                STA ARGUMENT1+2
.1a5f3a					done
.1a5f3a	60		rts		            RTS
.1a5f3b					Q_FP_NORM_ANGLE
.1a5f3b	5a		phy		                PHY
.1a5f3c	a2 00 00	ldx #$0000	                LDX #0
.1a5f3f	a0 00 00	ldy #$0000	                LDY #0
.1a5f42	a5 23		lda $0823	loop            LDA ARGUMENT1
.1a5f44	df 34 65 1a	cmp $1a6534,x	                CMP @l onepi,x
.1a5f48	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5f4a	ff 36 65 1a	sbc $1a6536,x	                SBC @l onepi+2,x
.1a5f4e	90 2c		bcc $1a5f7c	                BCC less
.1a5f50	bf 30 65 1a	lda $1a6530,x	                LDA @l twopi,x
.1a5f54	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5f58	bf 32 65 1a	lda $1a6532,x	                LDA @l twopi+2,x
.1a5f5c	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5f60	a5 23		lda $0823	                LDA ARGUMENT1
.1a5f62	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5f66	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5f68	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5f6c	ea		nop		                NOP
.1a5f6d	ea		nop		                NOP
.1a5f6e	ea		nop		                NOP
.1a5f6f	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5f73	85 23		sta $0823	                STA ARGUMENT1
.1a5f75	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5f79	85 25		sta $0825	                STA ARGUMENT1+2
.1a5f7b	38		sec		                SEC             ; set carry to indicate a reflection
.1a5f7c	98		tya		less            TYA             ; carry already cleared if we branched
.1a5f7d	2a		rol a		                ROL             ; shift carry into flags...
.1a5f7e	a8		tay		                TAY             ; and store back into y
.1a5f7f	e8		inx		                INX             ; next set of values
.1a5f80	e8		inx		                INX
.1a5f81	e8		inx		                INX
.1a5f82	e8		inx		                INX
.1a5f83	e0 0c 00	cpx #$000c	                CPX #12         ; check if we have already looked at 3
.1a5f86	d0 ba		bne $1a5f42	                BNE loop
.1a5f88	98		tya		                TYA             ; copy Y to X, as that's what we have
.1a5f89	aa		tax		                TAX
.1a5f8a	7a		ply		                PLY
.1a5f8b	60		rts		            RTS
.1a5f8c					Q_FP_COS
.1a5f8c	08		php		                PHP
.1a5f8d	c2 30		rep #$30	            REP #$30
.1a5f8f	48		pha		                PHA
.1a5f90	da		phx		                PHX
.1a5f91	20 3e 5e	jsr $1a5e3e	            JSR Q_SQ
.1a5f94	8b		phb		                PHB
.1a5f95	e2 20		sep #$20	            SEP #$20
.1a5f97	a9 1a		lda #$1a	                LDA #`cos_coeff
.1a5f99	48		pha		                PHA
.1a5f9a	ab		plb		                PLB
.1a5f9b	c2 20		rep #$20	            REP #$20
.1a5f9d	a2 70 64	ldx #$6470	                LDX #<>cos_coeff
.1a5fa0	5a		phy		                PHY
.1a5fa1	a0 05 00	ldy #$0005	                LDY #5
.1a5fa4	20 af 5d	jsr $1a5daf	            JSR Q_POLY_HR
.1a5fa7	7a		ply		                PLY
.1a5fa8	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.1a5fab	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.1a5faf	ab		plb		                PLB
.1a5fb0	fa		plx		                PLX
.1a5fb1	68		pla		                PLA
.1a5fb2	28		plp		                PLP
.1a5fb3	60		rts		            RTS
.1a5fb4					Q_FP_SIN
.1a5fb4	08		php		                PHP
.1a5fb5	c2 30		rep #$30	            REP #$30
.1a5fb7	48		pha		                PHA
.1a5fb8	da		phx		                PHX
.1a5fb9	a5 23		lda $0823	                LDA ARGUMENT1
.1a5fbb	85 29		sta $0829	                STA ARGUMENT2
.1a5fbd	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5fbf	85 2b		sta $082b	                STA ARGUMENT2+2
.1a5fc1	20 3e 5e	jsr $1a5e3e	            JSR Q_SQ
.1a5fc4	8b		phb		                PHB
.1a5fc5	e2 20		sep #$20	            SEP #$20
.1a5fc7	a9 1a		lda #$1a	                LDA #`sin_coeff
.1a5fc9	48		pha		                PHA
.1a5fca	ab		plb		                PLB
.1a5fcb	c2 20		rep #$20	            REP #$20
.1a5fcd	a2 84 64	ldx #$6484	                LDX #<>sin_coeff
.1a5fd0	5a		phy		                PHY
.1a5fd1	a0 05 00	ldy #$0005	                LDY #5
.1a5fd4	20 af 5d	jsr $1a5daf	            JSR Q_POLY_HR
.1a5fd7	7a		ply		                PLY
.1a5fd8	ab		plb		                PLB
.1a5fd9	20 19 56	jsr $1a5619	            JSR OP_FP_MUL
.1a5fdc	fa		plx		                PLX
.1a5fdd	68		pla		                PLA
.1a5fde	28		plp		                PLP
.1a5fdf	60		rts		            RTS
.1a5fe0					Q_FP_TAN
.1a5fe0	08		php		                PHP
.1a5fe1	c2 30		rep #$30	            REP #$30
.1a5fe3	48		pha		                PHA
.1a5fe4	da		phx		                PHX
.1a5fe5	a5 23		lda $0823	                LDA ARGUMENT1
.1a5fe7	85 29		sta $0829	                STA ARGUMENT2
.1a5fe9	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5feb	85 2b		sta $082b	                STA ARGUMENT2+2
.1a5fed	20 3e 5e	jsr $1a5e3e	            JSR Q_SQ
.1a5ff0	8b		phb		                PHB
.1a5ff1	e2 20		sep #$20	            SEP #$20
.1a5ff3	a9 1a		lda #$1a	                LDA #`tan_coeff
.1a5ff5	48		pha		                PHA
.1a5ff6	ab		plb		                PLB
.1a5ff7	c2 20		rep #$20	            REP #$20
.1a5ff9	a2 98 64	ldx #$6498	                LDX #<>tan_coeff
.1a5ffc	5a		phy		                PHY
.1a5ffd	a0 05 00	ldy #$0005	                LDY #5
.1a6000	20 af 5d	jsr $1a5daf	            JSR Q_POLY_HR
.1a6003	7a		ply		                PLY
.1a6004	ab		plb		                PLB
.1a6005	20 19 56	jsr $1a5619	            JSR OP_FP_MUL
.1a6008	fa		plx		                PLX
.1a6009	68		pla		                PLA
.1a600a	28		plp		                PLP
.1a600b	60		rts		            RTS
.1a600c					Q_FP_LN
.1a600c	08		php		                PHP
.1a600d	c2 30		rep #$30	            REP #$30
.1a600f	48		pha		                PHA
.1a6010	da		phx		                PHX
.1a6011	e2 20		sep #$20	            SEP #$20
.1a6013	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a6015	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a6019	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a601b	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a601f	c2 20		rep #$20	            REP #$20
.1a6021	a5 23		lda $0823	                LDA ARGUMENT1
.1a6023	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a6027	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6029	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a602d	af c8 64 1a	lda $1a64c8	                LDA @l fp_one
.1a6031	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a6035	af ca 64 1a	lda $1a64ca	                LDA @l fp_one+2
.1a6039	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a603d	ea		nop		                NOP
.1a603e	ea		nop		                NOP
.1a603f	ea		nop		                NOP
.1a6040	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a6044	85 0c		sta $080c	                STA SCRATCH
.1a6046	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a604a	85 0e		sta $080e	                STA SCRATCH+2
.1a604c	e2 20		sep #$20	            SEP #$20
.1a604e	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a6050	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a6054	c2 20		rep #$20	            REP #$20
.1a6056	ea		nop		                NOP
.1a6057	ea		nop		                NOP
.1a6058	ea		nop		                NOP
.1a6059	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a605d	85 10		sta $0810	                STA SCRATCH2
.1a605f	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a6063	85 12		sta $0812	                STA SCRATCH2+2
.1a6065	e2 20		sep #$20	            SEP #$20
.1a6067	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a6069	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a606d	c2 20		rep #$20	            REP #$20
.1a606f	a5 0c		lda $080c	                LDA SCRATCH
.1a6071	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a6075	a5 0e		lda $080e	                LDA SCRATCH+2
.1a6077	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a607b	a5 10		lda $0810	                LDA SCRATCH2
.1a607d	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a6081	a5 12		lda $0812	                LDA SCRATCH2+2
.1a6083	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a6087	ea		nop		                NOP
.1a6088	ea		nop		                NOP
.1a6089	ea		nop		                NOP
.1a608a	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a608e	85 23		sta $0823	                STA ARGUMENT1
.1a6090	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a6094	85 25		sta $0825	                STA ARGUMENT1+2
.1a6096	e2 20		sep #$20	            SEP #$20
.1a6098	a9 08		lda #$08	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX0
.1a609a	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a609e	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a60a0	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a60a4	c2 20		rep #$20	            REP #$20
.1a60a6	a5 23		lda $0823	                LDA ARGUMENT1
.1a60a8	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a60ac	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a60ae	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a60b2	ea		nop		                NOP
.1a60b3	ea		nop		                NOP
.1a60b4	ea		nop		                NOP
.1a60b5	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a60b9	85 29		sta $0829	                STA ARGUMENT2
.1a60bb	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a60bf	85 2b		sta $082b	                STA ARGUMENT2+2
.1a60c1	20 3e 5e	jsr $1a5e3e	            JSR Q_SQ
.1a60c4	8b		phb		                PHB
.1a60c5	e2 20		sep #$20	            SEP #$20
.1a60c7	a9 1a		lda #$1a	                LDA #`ln_coeff
.1a60c9	48		pha		                PHA
.1a60ca	ab		plb		                PLB
.1a60cb	c2 20		rep #$20	            REP #$20
.1a60cd	a2 ac 64	ldx #$64ac	                LDX #<>ln_coeff
.1a60d0	5a		phy		                PHY
.1a60d1	a0 08 00	ldy #$0008	                LDY #8
.1a60d4	20 af 5d	jsr $1a5daf	            JSR Q_POLY_HR
.1a60d7	7a		ply		                PLY
.1a60d8	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.1a60db	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.1a60df	8f 2d 08 00	sta $00082d	                STA @l ARGTYPE2
.1a60e3	20 19 56	jsr $1a5619	            JSR OP_FP_MUL
.1a60e6	ab		plb		                PLB
.1a60e7	fa		plx		                PLX
.1a60e8	68		pla		                PLA
.1a60e9	28		plp		                PLP
.1a60ea	60		rts		            RTS
.1a60eb					FP_SIN
.1a60eb	08		php		                PHP
.1a60ec	c2 30		rep #$30	            REP #$30
.1a60ee	48		pha		                PHA
.1a60ef	da		phx		                PHX
.1a60f0	20 de 5e	jsr $1a5ede	            JSR Q_FP_SCALE_TAU
.1a60f3	20 3b 5f	jsr $1a5f3b	            JSR Q_FP_NORM_ANGLE
.1a60f6	da		phx		                PHX
.1a60f7	8a		txa		                TXA
.1a60f8	29 01 00	and #$0001	                AND #1
.1a60fb	d0 05		bne $1a6102	                BNE do_cos
.1a60fd	20 b4 5f	jsr $1a5fb4	            JSR Q_FP_SIN
.1a6100	80 03		bra $1a6105	                BRA maybe_neg
.1a6102					do_cos
.1a6102	20 8c 5f	jsr $1a5f8c	            JSR Q_FP_COS
.1a6105	fa		plx		maybe_neg       PLX
.1a6106	8a		txa		                TXA
.1a6107	29 04 00	and #$0004	                AND #4
.1a610a	f0 0a		beq $1a6116	                BEQ done
.1a610c	e2 20		sep #$20	            SEP #$20
.1a610e	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a6110	09 80		ora #$80	                ORA #$80
.1a6112	85 26		sta $0826	                STA ARGUMENT1+3
.1a6114	c2 20		rep #$20	            REP #$20
.1a6116	fa		plx		done            PLX
.1a6117	68		pla		                PLA
.1a6118	28		plp		                PLP
.1a6119	60		rts		            RTS
.1a611a					FP_COS
.1a611a	08		php		                PHP
.1a611b	c2 30		rep #$30	            REP #$30
.1a611d	48		pha		                PHA
.1a611e	da		phx		                PHX
.1a611f	20 de 5e	jsr $1a5ede	            JSR Q_FP_SCALE_TAU
.1a6122	20 3b 5f	jsr $1a5f3b	            JSR Q_FP_NORM_ANGLE
.1a6125	da		phx		                PHX
.1a6126	8a		txa		                TXA
.1a6127	29 01 00	and #$0001	                AND #1
.1a612a	d0 05		bne $1a6131	                BNE do_sin
.1a612c	20 8c 5f	jsr $1a5f8c	            JSR Q_FP_COS
.1a612f	80 03		bra $1a6134	                BRA maybe_neg
.1a6131					do_sin
.1a6131	20 b4 5f	jsr $1a5fb4	            JSR Q_FP_SIN
.1a6134	fa		plx		maybe_neg       PLX
.1a6135	8a		txa		                TXA
.1a6136	29 02 00	and #$0002	                AND #2
.1a6139	f0 0a		beq $1a6145	                BEQ done
.1a613b	e2 20		sep #$20	            SEP #$20
.1a613d	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a613f	09 80		ora #$80	                ORA #$80
.1a6141	85 26		sta $0826	                STA ARGUMENT1+3
.1a6143	c2 20		rep #$20	            REP #$20
.1a6145	fa		plx		done            PLX
.1a6146	68		pla		                PLA
.1a6147	28		plp		                PLP
.1a6148	60		rts		            RTS
.1a6149					FP_TAN
.1a6149	08		php		                PHP
.1a614a	c2 30		rep #$30	            REP #$30
.1a614c	48		pha		                PHA
.1a614d	da		phx		                PHX
.1a614e	20 de 5e	jsr $1a5ede	            JSR Q_FP_SCALE_TAU
.1a6151	20 3b 5f	jsr $1a5f3b	            JSR Q_FP_NORM_ANGLE
.1a6154	20 e0 5f	jsr $1a5fe0	            JSR Q_FP_TAN
.1a6157	8a		txa		                TXA
.1a6158	29 01 00	and #$0001	                AND #1
.1a615b	f0 03		beq $1a6160	                BEQ no_inv
.1a615d	20 74 5e	jsr $1a5e74	            JSR Q_INV
.1a6160	8a		txa		no_inv          TXA
.1a6161	e2 20		sep #$20	            SEP #$20
.1a6163	4a		lsr a		                LSR
.1a6164	4a		lsr a		                LSR
.1a6165	69 00		adc #$00	                ADC #0
.1a6167	29 01		and #$01	                AND #1
.1a6169	f0 06		beq $1a6171	                BEQ no_neg
.1a616b	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a616d	09 80		ora #$80	                ORA #$80
.1a616f	85 26		sta $0826	                STA ARGUMENT1+3
.1a6171					no_neg
.1a6171	c2 20		rep #$20	            REP #$20
.1a6173	fa		plx		                PLX
.1a6174	68		pla		                PLA
.1a6175	28		plp		                PLP
.1a6176	60		rts		            RTS
.1a6177					FP_LN
.1a6177	08		php		                PHP
.1a6178	c2 30		rep #$30	            REP #$30
.1a617a	48		pha		                PHA
.1a617b	da		phx		                PHX
.1a617c	5a		phy		                PHY
.1a617d	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a617f	10 1f		bpl $1a61a0	                BPL arg_ok
.1a6181	08		php		            PHP
.1a6182	c2 20		rep #$20	            REP #$20
.1a6184	48		pha		            PHA
.1a6185	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6188	5b		tcd		            TCD
.1a6189	68		pla		            PLA
.1a618a	28		plp		            PLP
.1a618b	e2 20		sep #$20	            SEP #$20
.1a618d	a9 17		lda #$17	            LDA #ERR_DOMAIN
.1a618f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6193	c2 20		rep #$20	            REP #$20
.1a6195	29 ff 00	and #$00ff	            AND #$00FF
.1a6198	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a619b	e2 20		sep #$20	            SEP #$20
.1a619d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a61a0					arg_ok
.1a61a0	c2 30		rep #$30	            REP #$30
.1a61a2	a5 23		lda $0823	                LDA ARGUMENT1
.1a61a4	cf c8 64 1a	cmp $1a64c8	                CMP @l fp_one
.1a61a8	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a61aa	cf ca 64 1a	cmp $1a64ca	                CMP @l fp_one+2
.1a61ae	b0 04		bcs $1a61b4	                BCS gtone
.1a61b0	20 74 5e	jsr $1a5e74	            JSR Q_INV
.1a61b3	18		clc		                CLC
.1a61b4	a9 00 00	lda #$0000	gtone           LDA #0
.1a61b7	a8		tay		                TAY
.1a61b8	2a		rol a		                ROL             ; Rotate Carry into A; 0 means negate
.1a61b9	48		pha		                PHA
.1a61ba	e2 20		sep #$20	            SEP #$20
.1a61bc	a9 00		lda #$00	                LDA #0
.1a61be	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a61c2	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a61c4	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a61c8	c2 20		rep #$20	            REP #$20
.1a61ca	af 20 65 1a	lda $1a6520	                LDA @l eexp64
.1a61ce	85 29		sta $0829	                STA ARGUMENT2
.1a61d0	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a61d4	af 22 65 1a	lda $1a6522	                LDA @l eexp64+2
.1a61d8	85 2b		sta $082b	                STA ARGUMENT2+2
.1a61da	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a61de	20 b2 5e	jsr $1a5eb2	            JSR Q_FP_SCALE
.1a61e1	8a		txa		                TXA
.1a61e2	f0 07		beq $1a61eb	                BEQ chk16
.1a61e4	0a		asl a		                ASL             ; multiply counter by 64
.1a61e5	0a		asl a		                ASL
.1a61e6	0a		asl a		                ASL
.1a61e7	0a		asl a		                ASL
.1a61e8	0a		asl a		                ASL
.1a61e9	0a		asl a		                ASL
.1a61ea	a8		tay		                TAY
.1a61eb	af 24 65 1a	lda $1a6524	chk16           LDA @l eexp16
.1a61ef	85 29		sta $0829	                STA ARGUMENT2
.1a61f1	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a61f5	af 26 65 1a	lda $1a6526	                LDA @l eexp16+2
.1a61f9	85 2b		sta $082b	                STA ARGUMENT2+2
.1a61fb	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a61ff	20 b2 5e	jsr $1a5eb2	            JSR Q_FP_SCALE
.1a6202	8a		txa		                TXA
.1a6203	f0 0b		beq $1a6210	                BEQ chk04
.1a6205	0a		asl a		                ASL             ; multiply counter by 16
.1a6206	0a		asl a		                ASL
.1a6207	0a		asl a		                ASL
.1a6208	0a		asl a		                ASL
.1a6209	85 29		sta $0829	                STA ARGUMENT2   ; and add into total
.1a620b	18		clc		                CLC
.1a620c	98		tya		                TYA
.1a620d	65 29		adc $0829	                ADC ARGUMENT2
.1a620f	a8		tay		                TAY
.1a6210	af 28 65 1a	lda $1a6528	chk04           LDA @l eexp04
.1a6214	85 29		sta $0829	                STA ARGUMENT2
.1a6216	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a621a	af 2a 65 1a	lda $1a652a	                LDA @l eexp04+2
.1a621e	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6220	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a6224	20 b2 5e	jsr $1a5eb2	            JSR Q_FP_SCALE
.1a6227	8a		txa		                TXA
.1a6228	f0 09		beq $1a6233	                BEQ chk01
.1a622a	0a		asl a		                ASL             ;multiply counter by 4
.1a622b	0a		asl a		                ASL
.1a622c	85 29		sta $0829	                STA ARGUMENT2   ;and add to total
.1a622e	18		clc		                CLC
.1a622f	98		tya		                TYA
.1a6230	65 29		adc $0829	                ADC ARGUMENT2
.1a6232	a8		tay		                TAY
.1a6233	af 2c 65 1a	lda $1a652c	chk01           LDA @l eexp01
.1a6237	85 29		sta $0829	                STA ARGUMENT2
.1a6239	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a623d	af 2e 65 1a	lda $1a652e	                LDA @l eexp01+2
.1a6241	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6243	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a6247	20 b2 5e	jsr $1a5eb2	            JSR Q_FP_SCALE
.1a624a	86 29		stx $0829	                STX ARGUMENT2   ; add counter to total
.1a624c	18		clc		                CLC
.1a624d	98		tya		                TYA
.1a624e	65 29		adc $0829	                ADC ARGUMENT2
.1a6250	a8		tay		                TAY
.1a6251	20 0c 60	jsr $1a600c	            JSR Q_FP_LN
.1a6254	a5 23		lda $0823	                LDA ARGUMENT1
.1a6256	85 29		sta $0829	                STA ARGUMENT2
.1a6258	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a625a	85 2b		sta $082b	                STA ARGUMENT2+2
.1a625c	98		tya		                TYA
.1a625d	85 23		sta $0823	                STA ARGUMENT1
.1a625f	64 25		stz $0825	                STZ ARGUMENT1+2
.1a6261	20 a6 5a	jsr $1a5aa6	            JSR ITOF
.1a6264	20 83 55	jsr $1a5583	            JSR OP_FP_ADD
.1a6267	68		pla		                PLA
.1a6268	d0 07		bne $1a6271	                BNE done
.1a626a	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a626c	09 00 80	ora #$8000	                ORA #$8000
.1a626f	85 25		sta $0825	                STA ARGUMENT1+2
.1a6271	7a		ply		done            PLY
.1a6272	fa		plx		                PLX
.1a6273	68		pla		                PLA
.1a6274	28		plp		                PLP
.1a6275	60		rts		            RTS
.1a6276					FP_ASIN
.1a6276	08		php		                PHP
.1a6277	c2 30		rep #$30	            REP #$30
.1a6279	48		pha		                PHA
.1a627a	da		phx		                PHX
.1a627b	a5 23		lda $0823	                LDA ARGUMENT1
.1a627d	85 29		sta $0829	                STA ARGUMENT2
.1a627f	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6281	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6283	20 3e 5e	jsr $1a5e3e	            JSR Q_SQ
.1a6286	8b		phb		                PHB
.1a6287	e2 20		sep #$20	            SEP #$20
.1a6289	a9 1a		lda #$1a	                LDA #`asin_coeff
.1a628b	48		pha		                PHA
.1a628c	ab		plb		                PLB
.1a628d	c2 20		rep #$20	            REP #$20
.1a628f	a2 d0 64	ldx #$64d0	                LDX #<>asin_coeff
.1a6292	a0 05 00	ldy #$0005	                LDY #5
.1a6295	20 af 5d	jsr $1a5daf	            JSR Q_POLY_HR
.1a6298	ab		plb		                PLB
.1a6299	20 19 56	jsr $1a5619	            JSR OP_FP_MUL
.1a629c	fa		plx		                PLX
.1a629d	68		pla		                PLA
.1a629e	28		plp		                PLP
.1a629f	60		rts		            RTS
.1a62a0					FP_ACOS
.1a62a0	08		php		                PHP
.1a62a1	c2 30		rep #$30	            REP #$30
.1a62a3	48		pha		                PHA
.1a62a4	da		phx		                PHX
.1a62a5	20 76 62	jsr $1a6276	            JSR FP_ASIN
.1a62a8	af 38 65 1a	lda $1a6538	                LDA @l halfpi
.1a62ac	85 29		sta $0829	                STA ARGUMENT2
.1a62ae	af 3a 65 1a	lda $1a653a	                LDA @l halfpi+2
.1a62b2	85 2b		sta $082b	                STA ARGUMENT2+2
.1a62b4	20 78 55	jsr $1a5578	            JSR OP_FP_SUB
.1a62b7	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a62b9	49 00 80	eor #$8000	                EOR #$8000
.1a62bc	85 25		sta $0825	                STA ARGUMENT1+2
.1a62be	fa		plx		                PLX
.1a62bf	68		pla		                PLA
.1a62c0	28		plp		                PLP
.1a62c1	60		rts		            RTS
.1a62c2					FP_ATAN
.1a62c2	08		php		                PHP
.1a62c3	c2 30		rep #$30	            REP #$30
.1a62c5	48		pha		                PHA
.1a62c6	da		phx		                PHX
.1a62c7	a5 23		lda $0823	                LDA ARGUMENT1
.1a62c9	85 29		sta $0829	                STA ARGUMENT2
.1a62cb	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a62cd	85 2b		sta $082b	                STA ARGUMENT2+2
.1a62cf	20 3e 5e	jsr $1a5e3e	            JSR Q_SQ
.1a62d2	8b		phb		                PHB
.1a62d3	e2 20		sep #$20	            SEP #$20
.1a62d5	a9 1a		lda #$1a	                LDA #`atan_coeff
.1a62d7	48		pha		                PHA
.1a62d8	ab		plb		                PLB
.1a62d9	c2 20		rep #$20	            REP #$20
.1a62db	a2 e4 64	ldx #$64e4	                LDX #<>atan_coeff
.1a62de	a0 05 00	ldy #$0005	                LDY #5
.1a62e1	20 af 5d	jsr $1a5daf	            JSR Q_POLY_HR
.1a62e4	ab		plb		                PLB
.1a62e5	20 19 56	jsr $1a5619	            JSR OP_FP_MUL
.1a62e8	fa		plx		                PLX
.1a62e9	68		pla		                PLA
.1a62ea	28		plp		                PLP
.1a62eb	60		rts		            RTS
.1a62ec					Q_FP_POW_INT
.1a62ec	c2 20		rep #$20	            REP #$20
.1a62ee	a5 23		lda $0823	            LDA ARGUMENT1
.1a62f0	85 29		sta $0829	            STA ARGUMENT2
.1a62f2	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a62f4	85 2b		sta $082b	            STA ARGUMENT2+2
.1a62f6	c2 20		rep #$20	            REP #$20
.1a62f8	af c8 64 1a	lda $1a64c8	            LDA @l fp_one
.1a62fc	85 23		sta $0823	            STA ARGUMENT1
.1a62fe	af ca 64 1a	lda $1a64ca	            LDA @l fp_one+2
.1a6302	85 25		sta $0825	            STA ARGUMENT1+2
.1a6304	8a		txa		loop            TXA
.1a6305	f0 30		beq $1a6337	                BEQ done
.1a6307	4a		lsr a		                LSR
.1a6308	aa		tax		                TAX
.1a6309	90 03		bcc $1a630e	                BCC next
.1a630b	20 19 56	jsr $1a5619	            JSR OP_FP_MUL
.1a630e					next
.1a630e	c2 20		rep #$20	            REP #$20
.1a6310	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6312	48		pha		            PHA
.1a6313	a5 23		lda $0823	            LDA ARGUMENT1
.1a6315	48		pha		            PHA
.1a6316	c2 20		rep #$20	            REP #$20
.1a6318	a5 29		lda $0829	            LDA ARGUMENT2
.1a631a	85 23		sta $0823	            STA ARGUMENT1
.1a631c	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a631e	85 25		sta $0825	            STA ARGUMENT1+2
.1a6320	20 3e 5e	jsr $1a5e3e	            JSR Q_SQ
.1a6323	c2 20		rep #$20	            REP #$20
.1a6325	a5 23		lda $0823	            LDA ARGUMENT1
.1a6327	85 29		sta $0829	            STA ARGUMENT2
.1a6329	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a632b	85 2b		sta $082b	            STA ARGUMENT2+2
.1a632d	c2 20		rep #$20	            REP #$20
.1a632f	68		pla		            PLA
.1a6330	85 23		sta $0823	            STA ARGUMENT1
.1a6332	68		pla		            PLA
.1a6333	85 25		sta $0825	            STA ARGUMENT1+2
.1a6335	80 cd		bra $1a6304	                BRA loop
.1a6337					done
.1a6337	60		rts		            RTS
.1a6338					Q_FP_EXP
.1a6338	08		php		                PHP
.1a6339	c2 30		rep #$30	            REP #$30
.1a633b	48		pha		                PHA
.1a633c	da		phx		                PHX
.1a633d	8b		phb		                PHB
.1a633e	e2 20		sep #$20	            SEP #$20
.1a6340	a9 1a		lda #$1a	                LDA #`exp_coeff
.1a6342	48		pha		                PHA
.1a6343	ab		plb		                PLB
.1a6344	c2 20		rep #$20	            REP #$20
.1a6346	a2 f8 64	ldx #$64f8	                LDX #<>exp_coeff
.1a6349	5a		phy		                PHY
.1a634a	a0 0a 00	ldy #$000a	                LDY #10
.1a634d	20 af 5d	jsr $1a5daf	            JSR Q_POLY_HR
.1a6350	7a		ply		                PLY
.1a6351	ab		plb		                PLB
.1a6352	fa		plx		                PLX
.1a6353	68		pla		                PLA
.1a6354	28		plp		                PLP
.1a6355	60		rts		            RTS
.1a6356					FP_EXP
.1a6356	08		php		                PHP
.1a6357	c2 30		rep #$30	            REP #$30
.1a6359	48		pha		                PHA
.1a635a	da		phx		                PHX
.1a635b	5a		phy		                PHY
.1a635c	a5 23		lda $0823	                LDA ARGUMENT1   ; special case for x==0
.1a635e	05 25		ora $0825	                ORA ARGUMENT1+2
.1a6360	d0 10		bne $1a6372	                BNE notzero
.1a6362	c2 20		rep #$20	            REP #$20
.1a6364	af c8 64 1a	lda $1a64c8	            LDA @l fp_one
.1a6368	85 23		sta $0823	            STA ARGUMENT1
.1a636a	af ca 64 1a	lda $1a64ca	            LDA @l fp_one+2
.1a636e	85 25		sta $0825	            STA ARGUMENT1+2
.1a6370	80 61		bra $1a63d3	                BRA done
.1a6372	a5 25		lda $0825	notzero         LDA ARGUMENT1+2 ; check if negative
.1a6374	29 00 80	and #$8000	                AND #$8000
.1a6377	a8		tay		                TAY             ; Y != 0 -> arg was negative
.1a6378	f0 07		beq $1a6381	                BEQ notneg
.1a637a	a5 25		lda $0825	                LDA ARGUMENT1+2 ; negate x
.1a637c	29 ff 7f	and #$7fff	                AND #$7FFF
.1a637f	85 25		sta $0825	                STA ARGUMENT1+2
.1a6381					notneg
.1a6381	c2 20		rep #$20	            REP #$20
.1a6383	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6385	48		pha		            PHA
.1a6386	a5 23		lda $0823	            LDA ARGUMENT1
.1a6388	48		pha		            PHA
.1a6389	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a638c	a6 23		ldx $0823	                LDX ARGUMENT1              ; INT(x) now in ARGUMENT1; low 16 bits into X
.1a638e	20 0e 07	jsr $1a070e	            JSR ASS_ARG1_FLOAT
.1a6391	c2 20		rep #$20	            REP #$20
.1a6393	a5 23		lda $0823	            LDA ARGUMENT1
.1a6395	85 29		sta $0829	            STA ARGUMENT2
.1a6397	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6399	85 2b		sta $082b	            STA ARGUMENT2+2
.1a639b	c2 20		rep #$20	            REP #$20
.1a639d	68		pla		            PLA
.1a639e	85 23		sta $0823	            STA ARGUMENT1
.1a63a0	68		pla		            PLA
.1a63a1	85 25		sta $0825	            STA ARGUMENT1+2
.1a63a3	20 78 55	jsr $1a5578	            JSR OP_FP_SUB
.1a63a6	20 38 63	jsr $1a6338	            JSR Q_FP_EXP
.1a63a9	c2 20		rep #$20	            REP #$20
.1a63ab	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a63ad	48		pha		            PHA
.1a63ae	a5 23		lda $0823	            LDA ARGUMENT1
.1a63b0	48		pha		            PHA
.1a63b1	c2 20		rep #$20	            REP #$20
.1a63b3	af 2c 65 1a	lda $1a652c	            LDA @leexp01
.1a63b7	85 23		sta $0823	            STA ARGUMENT1
.1a63b9	af 2e 65 1a	lda $1a652e	            LDA @leexp01+2
.1a63bd	85 25		sta $0825	            STA ARGUMENT1+2
.1a63bf	20 ec 62	jsr $1a62ec	            JSR Q_FP_POW_INT
.1a63c2	c2 20		rep #$20	            REP #$20
.1a63c4	68		pla		            PLA
.1a63c5	85 29		sta $0829	            STA ARGUMENT2
.1a63c7	68		pla		            PLA
.1a63c8	85 2b		sta $082b	            STA ARGUMENT2+2
.1a63ca	20 19 56	jsr $1a5619	            JSR OP_FP_MUL
.1a63cd	98		tya		                TYA
.1a63ce	f0 03		beq $1a63d3	                BEQ done
.1a63d0	20 74 5e	jsr $1a5e74	            JSR Q_INV
.1a63d3	7a		ply		done            PLY
.1a63d4	fa		plx		                PLX
.1a63d5	68		pla		                PLA
.1a63d6	28		plp		                PLP
.1a63d7	60		rts		            RTS
.1a63d8					FP_SQR
.1a63d8	08		php		                PHP
.1a63d9	c2 30		rep #$30	            REP #$30
.1a63db	48		pha		                PHA
.1a63dc	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a63de	10 1f		bpl $1a63ff	                BPL arg_ok
.1a63e0	08		php		            PHP
.1a63e1	c2 20		rep #$20	            REP #$20
.1a63e3	48		pha		            PHA
.1a63e4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a63e7	5b		tcd		            TCD
.1a63e8	68		pla		            PLA
.1a63e9	28		plp		            PLP
.1a63ea	e2 20		sep #$20	            SEP #$20
.1a63ec	a9 17		lda #$17	            LDA #ERR_DOMAIN
.1a63ee	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a63f2	c2 20		rep #$20	            REP #$20
.1a63f4	29 ff 00	and #$00ff	            AND #$00FF
.1a63f7	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a63fa	e2 20		sep #$20	            SEP #$20
.1a63fc	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a63ff					arg_ok
.1a63ff	c2 30		rep #$30	            REP #$30
.1a6401	05 23		ora $0823	                ORA ARGUMENT1
.1a6403	f0 68		beq $1a646d	                BEQ done
.1a6405	c2 20		rep #$20	            REP #$20
.1a6407	af cc 64 1a	lda $1a64cc	            LDA @l fp_two
.1a640b	85 29		sta $0829	            STA ARGUMENT2
.1a640d	af ce 64 1a	lda $1a64ce	            LDA @l fp_two+2
.1a6411	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6413	e2 20		sep #$20	            SEP #$20
.1a6415	a9 01		lda #$01	                LDA #TYPE_FLOAT
.1a6417	85 2d		sta $082d	                STA ARGTYPE2
.1a6419	c2 20		rep #$20	            REP #$20
.1a641b	c2 20		rep #$20	            REP #$20
.1a641d	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a641f	48		pha		            PHA
.1a6420	a5 23		lda $0823	            LDA ARGUMENT1
.1a6422	48		pha		            PHA
.1a6423					loop
.1a6423	20 ce 55	jsr $1a55ce	            JSR OP_FP_DIV
.1a6426	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6428	c5 2b		cmp $082b	                CMP ARGUMENT2+2
.1a642a	d0 09		bne $1a6435	                BNE more
.1a642c	a5 23		lda $0823	                LDA ARGUMENT1
.1a642e	45 29		eor $0829	                EOR ARGUMENT2
.1a6430	29 f8 ff	and #$fff8	                AND #$FFF8
.1a6433	f0 30		beq $1a6465	                BEQ exitloop
.1a6435					more
.1a6435	20 83 55	jsr $1a5583	            JSR OP_FP_ADD
.1a6438	c2 20		rep #$20	            REP #$20
.1a643a	af cc 64 1a	lda $1a64cc	            LDA @l fp_two
.1a643e	85 29		sta $0829	            STA ARGUMENT2
.1a6440	af ce 64 1a	lda $1a64ce	            LDA @l fp_two+2
.1a6444	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6446	20 ce 55	jsr $1a55ce	            JSR OP_FP_DIV
.1a6449	c2 20		rep #$20	            REP #$20
.1a644b	a5 23		lda $0823	            LDA ARGUMENT1
.1a644d	85 29		sta $0829	            STA ARGUMENT2
.1a644f	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6451	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6453	c2 20		rep #$20	            REP #$20
.1a6455	68		pla		            PLA
.1a6456	85 23		sta $0823	            STA ARGUMENT1
.1a6458	68		pla		            PLA
.1a6459	85 25		sta $0825	            STA ARGUMENT1+2
.1a645b	c2 20		rep #$20	            REP #$20
.1a645d	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a645f	48		pha		            PHA
.1a6460	a5 23		lda $0823	            LDA ARGUMENT1
.1a6462	48		pha		            PHA
.1a6463	80 be		bra $1a6423	                BRA loop
.1a6465					exitloop
.1a6465	c2 20		rep #$20	            REP #$20
.1a6467	68		pla		            PLA
.1a6468	85 29		sta $0829	            STA ARGUMENT2
.1a646a	68		pla		            PLA
.1a646b	85 2b		sta $082b	            STA ARGUMENT2+2
.1a646d	68		pla		done            PLA
.1a646e	28		plp		                PLP
.1a646f	60		rts		            RTS
.1a6470					cos_coeff
>1a6470	01 0d d0 37			                .dword $37D00D01
>1a6474	61 0b b6 ba			                .dword $BAB60B61
>1a6478	ab aa 2a 3d			                .dword $3D2AAAAB
>1a647c	00 00 00 bf			                .dword $BF000000
>1a6480	00 00 80 3f			                .dword $3F800000
.1a6484					sin_coeff
>1a6484	1d ef 38 36			                .dword $3638EF1D
>1a6488	01 0d 50 b9			                .dword $B9500D01
>1a648c	89 88 08 3c			                .dword $3C088889
>1a6490	ab aa 2a be			                .dword $BE2AAAAB
>1a6494	00 00 80 3f			                .dword $3F800000
.1a6498					tan_coeff
>1a6498	a4 27 b3 3c			                .dword $3CB327A4
>1a649c	d1 0d 5d 3d			                .dword $3D5D0DD1
>1a64a0	89 88 08 3e			                .dword $3E088889
>1a64a4	ab aa aa 3e			                .dword $3EAAAAAB
>1a64a8	00 00 80 3f			                .dword $3F800000
.1a64ac					ln_coeff
>1a64ac	89 88 88 3d			                .dword $3D888889
>1a64b0	d9 89 9d 3d			                .dword $3D9D89D9
>1a64b4	8c 2e ba 3d			                .dword $3DBA2E8C
>1a64b8	39 8e e3 3d			                .dword $3DE38E39
>1a64bc	25 49 12 3e			                .dword $3E124925
>1a64c0	cd cc 4c 3e			                .dword $3E4CCCCD
>1a64c4	ab aa aa 3e			                .dword $3EAAAAAB
>1a64c8	00 00 80 3f			fp_one          .dword $3F800000
>1a64cc	00 00 00 40			fp_two          .dword $40000000
.1a64d0					asin_coeff
>1a64d0	8e e3 f8 3c			                .dword $3CF8E38E
>1a64d4	6e db 36 3d			                .dword $3D36DB6E
>1a64d8	9a 99 99 3d			                .dword $3D99999A
>1a64dc	ab aa 2a 3e			                .dword $3E2AAAAB
>1a64e0	00 00 80 3f			                .dword $3F800000
.1a64e4					atan_coeff
>1a64e4	39 8e e3 3d			                .dword $3DE38E39
>1a64e8	25 49 12 be			                .dword $BE124925
>1a64ec	cd cc 4c 3e			                .dword $3E4CCCCD
>1a64f0	ab aa aa be			                .dword $BEAAAAAB
>1a64f4	00 00 80 3f			                .dword $3F800000
.1a64f8					exp_coeff
>1a64f8	1d ef 38 36			        .dword $3638EF1D
>1a64fc	01 0d d0 37			        .dword $37D00D01
>1a6500	01 0d 50 39			        .dword $39500D01
>1a6504	61 0b b6 3a			        .dword $3AB60B61
>1a6508	89 88 08 3c			        .dword $3C088889
>1a650c	ab aa 2a 3d			        .dword $3D2AAAAB
>1a6510	ab aa 2a 3e			        .dword $3E2AAAAB
>1a6514	00 00 00 3f			        .dword $3F000000
>1a6518	00 00 80 3f			        .dword $3F800000
>1a651c	00 00 80 3f			        .dword $3F800000
>1a6520	c1 2c a1 6d			eexp64          .dword $6DA12CC1
>1a6524	5f 97 07 4b			eexp16          .dword $4B07975F
>1a6528	81 64 5a 42			eexp04          .dword $425A6481
>1a652c	54 f8 2d 40			eexp01          .dword $402DF854
>1a6530	db 0f c9 40			twopi           .dword $40C90FDB
>1a6534	db 0f 49 40			onepi           .dword $40490FDB
>1a6538	db 0f c9 3f			halfpi          .dword $3FC90FDB
>1a653c	db 0f 49 3f			quarterpi       .dword $3F490FDB

;******  Return to file: src\basic816.s


;******  Processing file: src\arrays.s

.1a6540					ARR_ALLOC
.1a6540	08		php		                PHP
.1a6541	20 59 12	jsr $1a1259	            JSR HEAP_GETHED
.1a6544	c2 20		rep #$20	            REP #$20
.1a6546	a9 01 00	lda #$0001	                LDA #1                      ; ARGUMENT1 := 1
.1a6549	85 23		sta $0823	                STA ARGUMENT1
.1a654b	a9 00 00	lda #$0000	                LDA #0
.1a654e	85 25		sta $0825	                STA ARGUMENT1+2
.1a6550	e2 20		sep #$20	            SEP #$20
.1a6552	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.1a6556	c2 20		rep #$20	            REP #$20
.1a6558	29 ff 00	and #$00ff	                AND #$00FF
.1a655b	85 8f		sta $088f	                STA MCOUNT                  ; Save it to MCOUNT for later
.1a655d	a8		tay		                TAY                         ; Y := number of dimensions
.1a655e	a2 01 00	ldx #$0001	                LDX #1                      ; X := index to size 0
.1a6561					size_loop
.1a6561	c2 20		rep #$20	            REP #$20
.1a6563	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X           ; ARGUMENT2 := Ith dimension
.1a6567	85 29		sta $0829	                STA ARGUMENT2
.1a6569	a9 00 00	lda #$0000	                LDA #0
.1a656c	85 2b		sta $082b	                STA ARGUMENT2+2
.1a656e	e2 20		sep #$20	            SEP #$20
.1a6570	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a6572	85 2d		sta $082d	                STA ARGTYPE2
.1a6574	c2 20		rep #$20	            REP #$20
.1a6576	20 a4 27	jsr $1a27a4	            JSR OP_MULTIPLY
.1a6579	e8		inx		                INX
.1a657a	e8		inx		                INX
.1a657b	88		dey		                DEY
.1a657c	d0 e3		bne $1a6561	                BNE size_loop               ; If there are more dimensions, take the next one
.1a657e	c2 20		rep #$20	            REP #$20
.1a6580	a9 04 00	lda #$0004	                LDA #ARGUMENT_SIZE-1        ; Size of a data item (don't include the type code)
.1a6583	85 29		sta $0829	                STA ARGUMENT2
.1a6585	a9 00 00	lda #$0000	                LDA #0
.1a6588	85 2b		sta $082b	                STA ARGUMENT2+2
.1a658a	20 a4 27	jsr $1a27a4	            JSR OP_MULTIPLY
.1a658d	e2 20		sep #$20	            SEP #$20
.1a658f	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF             ; SCRATCH := N * 2
.1a6593	85 0c		sta $080c	                STA SCRATCH
.1a6595	a9 00		lda #$00	                LDA #0
.1a6597	85 0d		sta $080d	                STA SCRATCH+1
.1a6599	c2 20		rep #$20	            REP #$20
.1a659b	06 0c		asl $080c	                ASL SCRATCH
.1a659d	38		sec		                SEC                         ; ARGUMENT1 := size of the complete block
.1a659e	a5 23		lda $0823	                LDA ARGUMENT1
.1a65a0	65 0c		adc $080c	                ADC SCRATCH                 ; Size of data area + N*2 + 1 (in carry)
.1a65a2	85 23		sta $0823	                STA ARGUMENT1
.1a65a4	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a65a6	69 00 00	adc #$0000	                ADC #0
.1a65a9	85 25		sta $0825	                STA ARGUMENT1+2
.1a65ab	d0 29		bne $1a65d6	                BNE too_big                 ; size > 16-bit? Yes: throw an error
.1a65ad	e2 20		sep #$20	            SEP #$20
.1a65af	a5 ea		lda $08ea	                LDA TOFINDTYPE              ; Get the type
.1a65b1	09 80		ora #$80	                ORA #$80                    ; Flip the flag to make it an array of that type
.1a65b3	a6 23		ldx $0823	                LDX ARGUMENT1               ; Get the computed size
.1a65b5	20 1d 10	jsr $1a101d	            JSR ALLOC
.1a65b8	e2 20		sep #$20	            SEP #$20
.1a65ba	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.1a65be	87 c0		sta [$08c0]	                STA [CURRBLOCK]             ; Write the number of dimensions to the array's preamble
.1a65c0	a0 01 00	ldy #$0001	                LDY #1
.1a65c3	a2 00 00	ldx #$0000	                LDX #0
.1a65c6					copy_loop
.1a65c6	e2 20		sep #$20	            SEP #$20
.1a65c8	bf 01 4d 00	lda $004d01,x	                LDA @lARRIDXBUF+1,X         ; ARGUMENT2 := Ith dimension
.1a65cc	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y           ; And write the dimension to the array's preamble
.1a65ce	e4 8f		cpx $088f	                CPX MCOUNT                  ; Have we written the last byte?
.1a65d0	f0 23		beq $1a65f5	                BEQ null_array              ; Yes: clear the array
.1a65d2	e8		inx		                INX                         ; No: move to the next byte
.1a65d3	c8		iny		                INY
.1a65d4	80 f0		bra $1a65c6	                BRA copy_loop
.1a65d6					too_big
.1a65d6	08		php		            PHP
.1a65d7	c2 20		rep #$20	            REP #$20
.1a65d9	48		pha		            PHA
.1a65da	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a65dd	5b		tcd		            TCD
.1a65de	68		pla		            PLA
.1a65df	28		plp		            PLP
.1a65e0	e2 20		sep #$20	            SEP #$20
.1a65e2	a9 09		lda #$09	            LDA #ERR_RANGE
.1a65e4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a65e8	c2 20		rep #$20	            REP #$20
.1a65ea	29 ff 00	and #$00ff	            AND #$00FF
.1a65ed	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a65f0	e2 20		sep #$20	            SEP #$20
.1a65f2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a65f5					null_array
.1a65f5	e2 20		sep #$20	            SEP #$20
.1a65f7	38		sec		                SEC                         ; INDEX := pointer to first value
.1a65f8	a5 c0		lda $08c0	                LDA CURRBLOCK
.1a65fa	67 c0		adc [$08c0]	                ADC [CURRBLOCK]
.1a65fc	85 08		sta $0808	                STA INDEX
.1a65fe	a5 c1		lda $08c1	                LDA CURRBLOCK+1
.1a6600	69 00		adc #$00	                ADC #0
.1a6602	85 09		sta $0809	                STA INDEX+1
.1a6604	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a6606	69 00		adc #$00	                ADC #0
.1a6608	85 0a		sta $080a	                STA INDEX+2
.1a660a	64 0b		stz $080b	                STZ INDEX+3
.1a660c	c2 20		rep #$20	            REP #$20
.1a660e	a0 05 00	ldy #$0005	                LDY #HEAPOBJ.END            ; SCRATCH := pointer the the first byte after the array
.1a6611	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a6613	85 0c		sta $080c	                STA SCRATCH
.1a6615	e2 20		sep #$20	            SEP #$20
.1a6617	c8		iny		                INY
.1a6618	c8		iny		                INY
.1a6619	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a661b	85 0e		sta $080e	                STA SCRATCH+2
.1a661d	64 0f		stz $080f	                STZ SCRATCH+3
.1a661f					clr_loop
.1a661f	e2 20		sep #$20	            SEP #$20
.1a6621	a9 00		lda #$00	                LDA #0
.1a6623	87 08		sta [$0808]	                STA [INDEX]                 ; Clear the byte
.1a6625	c2 20		rep #$20	            REP #$20
.1a6627	18		clc		                CLC                         ; Increment INDEX
.1a6628	a5 08		lda $0808	                LDA INDEX
.1a662a	69 01 00	adc #$0001	                ADC #1
.1a662d	85 08		sta $0808	                STA INDEX
.1a662f	a5 0a		lda $080a	                LDA INDEX+2
.1a6631	69 00 00	adc #$0000	                ADC #0
.1a6634	85 0a		sta $080a	                STA INDEX+2
.1a6636	c5 0e		cmp $080e	                CMP SCRATCH+2               ; INDEX == SCRATCH?
.1a6638	d0 e5		bne $1a661f	                BNE clr_loop                ; No: write to this next byte
.1a663a	a5 08		lda $0808	                LDA INDEX
.1a663c	c5 0c		cmp $080c	                CMP SCRATCH
.1a663e	d0 df		bne $1a661f	                BNE clr_loop
.1a6640					done
.1a6640	28		plp		                PLP
.1a6641	60		rts		            RTS
.1a6642					ARR_CELL
.1a6642	08		php		                PHP
.1a6643	c2 20		rep #$20	            REP #$20
.1a6645	64 08		stz $0808	                STZ INDEX               ; INDEX := 0
.1a6647	64 0a		stz $080a	                STZ INDEX+2
.1a6649	e2 20		sep #$20	            SEP #$20
.1a664b	af 00 4d 00	lda $004d00	                LDA @l ARRIDXBUF        ; MCOUNT := N (number of dimensions)
.1a664f	85 8f		sta $088f	                STA MCOUNT
.1a6651	64 90		stz $0890	                STZ MCOUNT+1
.1a6653	a2 01 00	ldx #$0001	                LDX #1                  ; X := index to dimension 0
.1a6656	e2 20		sep #$20	            SEP #$20
.1a6658	a7 c0		lda [$08c0]	                LDA [CURRBLOCK]         ; Make sure the dimensions of the array
.1a665a	c5 8f		cmp $088f	                CMP MCOUNT              ; ... match those requested
.1a665c	f0 22		beq $1a6680	                BEQ dims_match          ; Yes: the dimensions match
.1a665e	a6 8f		ldx $088f	                LDX MCOUNT
.1a6660	00		brk #		                BRK
.1a6661					arg_err
.1a6661	08		php		            PHP
.1a6662	c2 20		rep #$20	            REP #$20
.1a6664	48		pha		            PHA
.1a6665	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6668	5b		tcd		            TCD
.1a6669	68		pla		            PLA
.1a666a	28		plp		            PLP
.1a666b	e2 20		sep #$20	            SEP #$20
.1a666d	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a666f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6673	c2 20		rep #$20	            REP #$20
.1a6675	29 ff 00	and #$00ff	            AND #$00FF
.1a6678	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a667b	e2 20		sep #$20	            SEP #$20
.1a667d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6680	c9 01		cmp #$01	dims_match      CMP #1                  ; Check to see if this array is one dimensional
.1a6682	f0 3a		beq $1a66be	                BEQ add_last            ; If so, just add the index of the cell to INDEX
.1a6684	a0 01 00	ldy #$0001	                LDY #1
.1a6687					index_loop
.1a6687	e2 20		sep #$20	            SEP #$20
.1a6689	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; ARGUMENT1 := I_j
.1a668d	85 23		sta $0823	                STA ARGUMENT1
.1a668f	64 24		stz $0824	                STZ ARGUMENT1+1
.1a6691	64 25		stz $0825	                STZ ARGUMENT1+2
.1a6693	64 26		stz $0826	                STZ ARGUMENT1+3
.1a6695	b7 c0		lda [$08c0],y	                LDA [CURRBLOCK],Y       ; ARGUMENT2 := D_j
.1a6697	85 29		sta $0829	                STA ARGUMENT2
.1a6699	64 2a		stz $082a	                STZ ARGUMENT2+1
.1a669b	64 2b		stz $082b	                STZ ARGUMENT2+2
.1a669d	64 2c		stz $082c	                STZ ARGUMENT2+3
.1a669f	a5 23		lda $0823	                LDA ARGUMENT1
.1a66a1	c5 29		cmp $0829	                CMP ARGUMENT2           ; Is I_j >= D_j
.1a66a3	b0 68		bcs $1a670d	                BGE range_err           ; Yes: throw an out-of-range error
.1a66a5	20 a4 27	jsr $1a27a4	            JSR OP_MULTIPLY
.1a66a8	c2 20		rep #$20	            REP #$20
.1a66aa	18		clc		                CLC                     ; INDEX := INDEX + ARGUMENT1
.1a66ab	a5 08		lda $0808	                LDA INDEX
.1a66ad	65 23		adc $0823	                ADC ARGUMENT1
.1a66af	85 08		sta $0808	                STA INDEX
.1a66b1	a5 0a		lda $080a	                LDA INDEX+2
.1a66b3	65 25		adc $0825	                ADC ARGUMENT1+2
.1a66b5	85 0a		sta $080a	                STA INDEX+2
.1a66b7	e8		inx		                INX
.1a66b8	e8		inx		                INX
.1a66b9	c8		iny		                INY
.1a66ba	c4 8f		cpy $088f	                CPY MCOUNT              ; Are we on the last index?
.1a66bc	d0 c9		bne $1a6687	                BNE index_loop          ; No: move to the next index and try again
.1a66be					add_last
.1a66be	e2 20		sep #$20	            SEP #$20
.1a66c0	18		clc		                CLC
.1a66c1	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; INDEX := INDEX + I_(n-1)
.1a66c5	85 90		sta $0890	                STA MCOUNT+1
.1a66c7	65 08		adc $0808	                ADC INDEX
.1a66c9	85 08		sta $0808	                STA INDEX
.1a66cb	a5 09		lda $0809	                LDA INDEX+1
.1a66cd	69 00		adc #$00	                ADC #0
.1a66cf	85 09		sta $0809	                STA INDEX+1
.1a66d1	c2 20		rep #$20	            REP #$20
.1a66d3	a5 0a		lda $080a	                LDA INDEX+2
.1a66d5	69 00 00	adc #$0000	                ADC #0
.1a66d8	85 0a		sta $080a	                STA INDEX+2
.1a66da	c2 20		rep #$20	            REP #$20
.1a66dc	06 08		asl $0808	                ASL INDEX               ; INDEX := INDEX * 4 (size of a value)
.1a66de	26 0a		rol $080a	                ROL INDEX+2
.1a66e0	06 08		asl $0808	                ASL INDEX
.1a66e2	26 0a		rol $080a	                ROL INDEX+2
.1a66e4	e2 20		sep #$20	            SEP #$20
.1a66e6	38		sec		                SEC
.1a66e7	a5 08		lda $0808	                LDA INDEX
.1a66e9	65 8f		adc $088f	                ADC MCOUNT
.1a66eb	85 08		sta $0808	                STA INDEX
.1a66ed	a5 09		lda $0809	                LDA INDEX+1
.1a66ef	69 00		adc #$00	                ADC #0
.1a66f1	85 09		sta $0809	                STA INDEX+1
.1a66f3	c2 20		rep #$20	            REP #$20
.1a66f5	a5 0a		lda $080a	                LDA INDEX+2
.1a66f7	69 00 00	adc #$0000	                ADC #0
.1a66fa	85 0a		sta $080a	                STA INDEX+2
.1a66fc	18		clc		                CLC                     ; INDEX := INDEX + CURRBLOCK (point to the address desired)
.1a66fd	a5 08		lda $0808	                LDA INDEX
.1a66ff	65 c0		adc $08c0	                ADC CURRBLOCK
.1a6701	85 08		sta $0808	                STA INDEX
.1a6703	e2 20		sep #$20	            SEP #$20
.1a6705	a5 0a		lda $080a	                LDA INDEX+2
.1a6707	65 c2		adc $08c2	                ADC CURRBLOCK+2
.1a6709	85 0a		sta $080a	                STA INDEX+2
.1a670b	28		plp		                PLP
.1a670c	60		rts		            RTS
.1a670d					range_err
.1a670d	08		php		            PHP
.1a670e	c2 20		rep #$20	            REP #$20
.1a6710	48		pha		            PHA
.1a6711	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6714	5b		tcd		            TCD
.1a6715	68		pla		            PLA
.1a6716	28		plp		            PLP
.1a6717	e2 20		sep #$20	            SEP #$20
.1a6719	a9 09		lda #$09	            LDA #ERR_RANGE
.1a671b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a671f	c2 20		rep #$20	            REP #$20
.1a6721	29 ff 00	and #$00ff	            AND #$00FF
.1a6724	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a6727	e2 20		sep #$20	            SEP #$20
.1a6729	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a672c					ARR_SET
.1a672c	08		php		                PHP
.1a672d	20 59 12	jsr $1a1259	            JSR HEAP_GETHED
.1a6730	e2 20		sep #$20	            SEP #$20
.1a6732	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.1a6735	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a6737	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.1a6739	c9 02		cmp #$02	                CMP #TYPE_STRING    ; Is it a string array?
.1a673b	d0 05		bne $1a6742	                BNE chk_integer
.1a673d	20 32 06	jsr $1a0632	            JSR ASS_ARG1_STR
.1a6740	80 10		bra $1a6752	                BRA save_type
.1a6742	c9 00		cmp #$00	chk_integer     CMP #TYPE_INTEGER   ; Is it an integer array?
.1a6744	d0 05		bne $1a674b	                BNE chk_float
.1a6746	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a6749	80 07		bra $1a6752	                BRA save_type
.1a674b	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT     ; Is it an float array?
.1a674d	d0 2b		bne $1a677a	                BNE type_mismatch   ; No: throw a type mismatch error... something strange...
.1a674f	20 0e 07	jsr $1a070e	            JSR ASS_ARG1_FLOAT
.1a6752	a5 27		lda $0827	save_type       LDA ARGTYPE1        ; Save the type
.1a6754	48		pha		                PHA
.1a6755	c2 20		rep #$20	            REP #$20
.1a6757	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Save ARGUMENT1
.1a6759	48		pha		                PHA
.1a675a	a5 23		lda $0823	                LDA ARGUMENT1
.1a675c	48		pha		                PHA
.1a675d	20 42 66	jsr $1a6642	            JSR ARR_CELL
.1a6760	68		pla		                PLA                 ; Restore ARGUMENT1
.1a6761	85 23		sta $0823	                STA ARGUMENT1
.1a6763	68		pla		                PLA
.1a6764	85 25		sta $0825	                STA ARGUMENT1+2
.1a6766	e2 20		sep #$20	            SEP #$20
.1a6768	68		pla		                PLA
.1a6769	85 27		sta $0827	                STA ARGTYPE1
.1a676b	c2 20		rep #$20	            REP #$20
.1a676d	a5 23		lda $0823	                LDA ARGUMENT1       ; Set the value in the cell
.1a676f	87 08		sta [$0808]	                STA [INDEX]
.1a6771	a0 02 00	ldy #$0002	                LDY #2
.1a6774	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6776	97 08		sta [$0808],y	                STA [INDEX],Y
.1a6778	28		plp		                PLP
.1a6779	60		rts		            RTS
.1a677a					type_mismatch
.1a677a	08		php		            PHP
.1a677b	c2 20		rep #$20	            REP #$20
.1a677d	48		pha		            PHA
.1a677e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6781	5b		tcd		            TCD
.1a6782	68		pla		            PLA
.1a6783	28		plp		            PLP
.1a6784	e2 20		sep #$20	            SEP #$20
.1a6786	a9 04		lda #$04	            LDA #ERR_TYPE
.1a6788	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a678c	c2 20		rep #$20	            REP #$20
.1a678e	29 ff 00	and #$00ff	            AND #$00FF
.1a6791	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a6794	e2 20		sep #$20	            SEP #$20
.1a6796	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6799					ARR_REF
.1a6799	08		php		                PHP
.1a679a	20 59 12	jsr $1a1259	            JSR HEAP_GETHED
.1a679d	f4 00 00	pea #$0000	                PEA #0              ; Make room on the stack that ARR_CELL expects
.1a67a0	f4 00 00	pea #$0000	                PEA #0
.1a67a3	e2 20		sep #$20	            SEP #$20
.1a67a5	48		pha		                PHA
.1a67a6	20 42 66	jsr $1a6642	            JSR ARR_CELL
.1a67a9	e2 20		sep #$20	            SEP #$20
.1a67ab	68		pla		                PLA
.1a67ac	c2 20		rep #$20	            REP #$20
.1a67ae	68		pla		                PLA
.1a67af	68		pla		                PLA
.1a67b0	c2 20		rep #$20	            REP #$20
.1a67b2	a7 08		lda [$0808]	                LDA [INDEX]         ; Get the value in the cell
.1a67b4	85 23		sta $0823	                STA ARGUMENT1
.1a67b6	a0 02 00	ldy #$0002	                LDY #2
.1a67b9	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a67bb	85 25		sta $0825	                STA ARGUMENT1+2
.1a67bd	e2 20		sep #$20	            SEP #$20
.1a67bf	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.1a67c2	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a67c4	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.1a67c6	85 27		sta $0827	                STA ARGTYPE1        ; Set the type of the return value
.1a67c8	20 ad 17	jsr $1a17ad	            JSR STR_NORMAL
.1a67cb	28		plp		                PLP
.1a67cc	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\dos.s

.0000					DIRENTRY
>0000					SHORTNAME               .fill 11        ; $00 - The short name of the file (8 name, 3 extension)
>000b					ATTRIBUTE               .byte ?         ; $0B - The attribute bits
>000c					IGNORED1                .word ?         ; $0C - Unused (by us) bytes
>000e					CREATE_TIME             .word ?         ; $0E - Creation time
>0010					CREATE_DATE             .word ?         ; $10 - Creation date
>0012					ACCESS_DATE             .word ?         ; $12 - Last access date
>0014					CLUSTER_H               .word ?         ; $14 - High word of the first cluster #
>0016					MODIFIED_TIME           .word ?         ; $16 - Last modified time
>0018					MODIFIED_DATE           .word ?         ; $18 - Last modified date
>001a					CLUSTER_L               .word ?         ; $1A - Low word of the first cluster #
>001c					SIZE                    .dword ?        ; $1C - The size of the file (in bytes)
=$01					DOS_ATTR_RO = $01                       ; File is read-only
=$02					DOS_ATTR_HIDDEN = $02                   ; File is hidden
=$04					DOS_ATTR_SYSTEM = $04                   ; File is a system file
=$08					DOS_ATTR_VOLUME = $08                   ; Entry is the volume label
=$10					DOS_ATTR_DIR = $10                      ; Entry is a directory
=$20					DOS_ATTR_ARCH = $20                     ; Entry has changed since last backup
=$0f					DOS_ATTR_LONGNAME = $0F                 ; Entry is the long file name
=$e5					DOS_DIR_ENT_UNUSED = $E5                ; Marker for an unused directory entry
.0000					FILEDESC
>0000					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>0001					DEV                 .byte ?             ; The ID of the device holding the file
>0002					PATH                .dword ?            ; Pointer to a NULL terminated path string
>0006					CLUSTER             .dword ?            ; The current cluster of the file.
>000a					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>000e					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>0012					FILESIZE            .dword ?            ; The size of the file
>0016					CREATE_DATE         .word ?             ; The creation date of the file
>0018					CREATE_TIME         .word ?             ; The creation time of the file
>001a					MODIFIED_DATE       .word ?             ; The modification date of the file
>001c					MODIFIED_TIME       .word ?             ; The modification time of the file
=$01					FD_STAT_READ = $01                      ; The file is readable
=$02					FD_STAT_WRITE = $02                     ; The file is writable
=$40					FD_STAT_OPEN = $40                      ; The file is open
=$60					FD_STAT_ERROR = $60                     ; The file is in an error condition
=$80					FD_STAT_EOF = $80                       ; The file cursor is at the end of the file
>1af073					CLUSTER_BUFF    .fill 512           ; A buffer for cluster read/write operations
.1af273					FD_IN
>1af273					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>1af274					DEV                 .byte ?             ; The ID of the device holding the file
>1af275					PATH                .dword ?            ; Pointer to a NULL terminated path string
>1af279					CLUSTER             .dword ?            ; The current cluster of the file.
>1af27d					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>1af281					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>1af285					FILESIZE            .dword ?            ; The size of the file
>1af289					CREATE_DATE         .word ?             ; The creation date of the file
>1af28b					CREATE_TIME         .word ?             ; The creation time of the file
>1af28d					MODIFIED_DATE       .word ?             ; The modification date of the file
>1af28f					MODIFIED_TIME       .word ?             ; The modification time of the file
.1a67cd					PR_FILESIZE
.1a67cd	da		phx		                PHX
.1a67ce	0b		phd		                PHD
.1a67cf	08		php		                PHP
.1a67d0	08		php		            PHP
.1a67d1	c2 20		rep #$20	            REP #$20
.1a67d3	48		pha		            PHA
.1a67d4	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a67d7	5b		tcd		            TCD
.1a67d8	68		pla		            PLA
.1a67d9	28		plp		            PLP
.1a67da	c2 30		rep #$30	            REP #$30
.1a67dc	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a67de	89 f0 ff	bit #$fff0	                BIT #$FFF0              ; Check to see if the amount is in MB range
.1a67e1	d0 29		bne $1a680c	                BNE pr_mb               ; If so, print it in MBs
.1a67e3	89 0f 00	bit #$000f	                BIT #$000F              ; Check to see if the amount is in KB range
.1a67e6	d0 0c		bne $1a67f4	                BNE pr_kb
.1a67e8	a5 23		lda $0823	                LDA ARGUMENT1
.1a67ea	89 00 fc	bit #$fc00	                BIT #$FC00
.1a67ed	d0 05		bne $1a67f4	                BNE pr_kb               ; If so, print it in KBs
.1a67ef					pr_regular
.1a67ef	20 1b 45	jsr $1a451b	            JSR PR_INTEGER
.1a67f2	80 2e		bra $1a6822	                BRA done
.1a67f4	a2 0a 00	ldx #$000a	pr_kb           LDX #10                 ; Shift so the amount in KB is in ARGUMENT1
.1a67f7	46 25		lsr $0825	kb_shift        LSR ARGUMENT1+2
.1a67f9	66 23		ror $0823	                ROR ARGUMENT1
.1a67fb	ca		dex		                DEX
.1a67fc	d0 f9		bne $1a67f7	                BNE kb_shift
.1a67fe	20 1b 45	jsr $1a451b	            JSR PR_INTEGER
.1a6801	e2 20		sep #$20	            SEP #$20
.1a6803	a9 4b		lda #$4b	                LDA #'K'
.1a6805	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6808	c2 20		rep #$20	            REP #$20
.1a680a	80 16		bra $1a6822	                BRA done
.1a680c	a2 14 00	ldx #$0014	pr_mb           LDX #20                 ; Shift so the amount in MB is in ARGUMENT1
.1a680f	46 25		lsr $0825	mb_shift        LSR ARGUMENT1+2
.1a6811	66 23		ror $0823	                ROR ARGUMENT1
.1a6813	ca		dex		                DEX
.1a6814	d0 f9		bne $1a680f	                BNE mb_shift
.1a6816	20 1b 45	jsr $1a451b	            JSR PR_INTEGER
.1a6819	e2 20		sep #$20	            SEP #$20
.1a681b	a9 4d		lda #$4d	                LDA #'M'
.1a681d	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6820	c2 20		rep #$20	            REP #$20
.1a6822	28		plp		done            PLP
.1a6823	2b		pld		                PLD
.1a6824	fa		plx		                PLX
.1a6825	60		rts		            RTS
.1a6826					CMD_DIR
.1a6826	0b		phd		                PHD
.1a6827	08		php		                PHP
.1a6828	c2 30		rep #$30	            REP #$30
.1a682a	a9 00 00	lda #$0000	                LDA #0                      ; Zero out the pagination line count
.1a682d	8f b6 08 00	sta $0008b6	                STA @l LINECOUNT
.1a6831	8f b8 08 00	sta $0008b8	                STA @l LINECOUNT+2
.1a6835	e2 20		sep #$20	            SEP #$20
.1a6837	20 c8 21	jsr $1a21c8	            JSR PEEK_TOK
.1a683a	c9 00		cmp #$00	                CMP #0
.1a683c	f0 08		beq $1a6846	                BEQ set_null                ; If none provided, set the path to empty
.1a683e	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a6841	20 32 06	jsr $1a0632	            JSR ASS_ARG1_STR
.1a6844	80 11		bra $1a6857	                BRA set_fd
.1a6846					set_null
.1a6846	c2 20		rep #$20	            REP #$20
.1a6848	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT1 to the NULL string
.1a684b	85 23		sta $0823	                STA ARGUMENT1
.1a684d	85 25		sta $0825	                STA ARGUMENT1+2
.1a684f	e2 20		sep #$20	            SEP #$20
.1a6851	a9 02		lda #$02	                LDA #TYPE_STRING
.1a6853	85 27		sta $0827	                STA ARGTYPE1
.1a6855	c2 20		rep #$20	            REP #$20
.1a6857					set_fd
.1a6857	20 87 69	jsr $1a6987	            JSR SETFILEDESC
.1a685a	22 08 11 00	jsl $001108	                JSL FK_DIROPEN              ; Open up the directory
.1a685e	b0 22		bcs $1a6882	                BCS pr_first
.1a6860	20 38 6a	jsr $1a6a38	            JSR SET_DOSSTAT
.1a6863	08		php		            PHP
.1a6864	c2 20		rep #$20	            REP #$20
.1a6866	48		pha		            PHA
.1a6867	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a686a	5b		tcd		            TCD
.1a686b	68		pla		            PLA
.1a686c	28		plp		            PLP
.1a686d	e2 20		sep #$20	            SEP #$20
.1a686f	a9 10		lda #$10	            LDA #ERR_DIRECTORY
.1a6871	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6875	c2 20		rep #$20	            REP #$20
.1a6877	29 ff 00	and #$00ff	            AND #$00FF
.1a687a	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a687d	e2 20		sep #$20	            SEP #$20
.1a687f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6882					pr_first
.1a6882	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a6885					pr_entry
.1a6885	08		php		            PHP
.1a6886	c2 20		rep #$20	            REP #$20
.1a6888	48		pha		            PHA
.1a6889	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.1a688c	5b		tcd		            TCD
.1a688d	68		pla		            PLA
.1a688e	28		plp		            PLP
.1a688f	e2 20		sep #$20	            SEP #$20
.1a6891	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Start with the file name
.1a6894	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the initial character of the name
.1a6896	d0 03		bne $1a689b	                BNE chk_unused
.1a6898	82 a9 00	brl $1a6944	                BRL done                    ; If it's NULL, we're done
.1a689b	c9 e5		cmp #$e5	chk_unused      CMP #DOS_DIR_ENT_UNUSED     ; Is it the unusued code?
.1a689d	d0 03		bne $1a68a2	                BNE chk_attributes
.1a689f	82 96 00	brl $1a6938	                BRL next_entry              ; Yes: go to the next entry
.1a68a2	a0 0b 00	ldy #$000b	chk_attributes  LDY #DIRENTRY.ATTRIBUTE
.1a68a5	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute byte
.1a68a7	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.1a68a9	f0 03		beq $1a68ae	                BEQ chk_hidden
.1a68ab	82 a9 00	brl $1a6957	                BRL pr_volume               ; Print the volume label
.1a68ae	89 02		bit #$02	chk_hidden      BIT #DOS_ATTR_HIDDEN        ; Is it a hidden file?
.1a68b0	f0 03		beq $1a68b5	                BEQ chk_long
.1a68b2	82 83 00	brl $1a6938	                BRL next_entry              ; Yes: go to the next entry
.1a68b5	29 0f		and #$0f	chk_long        AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.1a68b7	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.1a68b9	d0 03		bne $1a68be	                BNE get_short_name
.1a68bb	82 7a 00	brl $1a6938	                BRL next_entry              ; Yes: go to the next entry
.1a68be	a0 00 00	ldy #$0000	get_short_name  LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.1a68c1	b7 18		lda [$0338],y	pr_name_loop    LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.1a68c3	20 18 00	jsr $1a0018	            JSR PRINTC
.1a68c6	c8		iny		                INY                         ; Move to the next character
.1a68c7	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.1a68ca	d0 f5		bne $1a68c1	                BNE pr_name_loop            ; No: print this new character
.1a68cc	a9 20		lda #$20	                LDA #' '                    ; Print the separator
.1a68ce	20 18 00	jsr $1a0018	            JSR PRINTC
.1a68d1	a0 08 00	ldy #$0008	                LDY #DIRENTRY.SHORTNAME+8   ; Move to the first of the extension characters
.1a68d4	b7 18		lda [$0338],y	pr_ext_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.1a68d6	20 18 00	jsr $1a0018	                JSR PRINTC                  ; Otherwise: print it.
.1a68d9	c8		iny		                INY                         ; Move to the next character
.1a68da	c0 0b 00	cpy #$000b	                CPY #DIRENTRY.SHORTNAME+11  ; Are we at the end of the extension portion?
.1a68dd	d0 f5		bne $1a68d4	                BNE pr_ext_loop             ; No: print this new character
.1a68df	a9 09		lda #$09	pr_tab1         LDA #CHAR_TAB               ; Print a TAB
.1a68e1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a68e4	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.1a68e7	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.1a68e9	89 10		bit #$10	                BIT #DOS_ATTR_DIR           ; Is it a directory?
.1a68eb	d0 1e		bne $1a690b	                BNE pr_attr                 ; Yes: skip printing a file size
.1a68ed	c2 20		rep #$20	            REP #$20
.1a68ef	a0 1c 00	ldy #$001c	                LDY #DIRENTRY.SIZE
.1a68f2	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the file size
.1a68f4	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.1a68f8	c8		iny		                INY
.1a68f9	c8		iny		                INY
.1a68fa	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y
.1a68fc	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.1a6900	e2 20		sep #$20	            SEP #$20
.1a6902	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a6904	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.1a6908	20 cd 67	jsr $1a67cd	            JSR PR_FILESIZE
.1a690b	a9 09		lda #$09	pr_attr         LDA #CHAR_TAB               ; Print a TAB
.1a690d	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6910	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.1a6913	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.1a6915	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.1a6917	d0 1c		bne $1a6935	                BNE end_entry               ; Yes: we're done printing this entry
.1a6919	89 01		bit #$01	chk_read        BIT #DOS_ATTR_RO            ; Is it a read-only file?
.1a691b	f0 05		beq $1a6922	                BEQ chk_system
.1a691d	a9 52		lda #$52	                LDA #'R'                    ; Yes: print an R
.1a691f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6922	89 04		bit #$04	chk_system      BIT #DOS_ATTR_SYSTEM        ; Is it System file?
.1a6924	f0 05		beq $1a692b	                BEQ chk_directory
.1a6926	a9 53		lda #$53	                LDA #'S'                    ; Yes: print an S
.1a6928	20 18 00	jsr $1a0018	            JSR PRINTC
.1a692b	89 10		bit #$10	chk_directory   BIT #DOS_ATTR_DIR           ; Is it a directory?
.1a692d	f0 05		beq $1a6934	                BEQ pr_tab2
.1a692f	a9 44		lda #$44	                LDA #'D'                    ; Yes: print a D
.1a6931	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6934	ea		nop		pr_tab2         NOP
.1a6935					end_entry
.1a6935	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a6938					next_entry
.1a6938	20 3d 03	jsr $1a033d	            JSR PAGINATE
.1a693b	22 0c 11 00	jsl $00110c	                JSL FK_DIRNEXT
.1a693f	90 03		bcc $1a6944	                BCC done
.1a6941	82 41 ff	brl $1a6885	                BRL pr_entry
.1a6944					done
.1a6944	20 38 6a	jsr $1a6a38	            JSR SET_DOSSTAT
.1a6947	08		php		            PHP
.1a6948	c2 20		rep #$20	            REP #$20
.1a694a	48		pha		            PHA
.1a694b	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a694e	5b		tcd		            TCD
.1a694f	68		pla		            PLA
.1a6950	28		plp		            PLP
.1a6951	20 ac 20	jsr $1a20ac	            JSR SKIPSTMT
.1a6954	28		plp		                PLP
.1a6955	2b		pld		                PLD
.1a6956	60		rts		            RTS
.1a6957					pr_volume
.1a6957	08		php		            PHP
.1a6958	c2 20		rep #$20	            REP #$20
.1a695a	48		pha		            PHA
.1a695b	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.1a695e	5b		tcd		            TCD
.1a695f	68		pla		            PLA
.1a6960	28		plp		            PLP
.1a6961	e2 20		sep #$20	            SEP #$20
.1a6963	29 0f		and #$0f	                AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.1a6965	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.1a6967	f0 cf		beq $1a6938	                BEQ next_entry              ; Yes: skip it
.1a6969	a9 5b		lda #$5b	pr_lbracket     LDA #'['
.1a696b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a696e	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.1a6971	b7 18		lda [$0338],y	pr_vol_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.1a6973	c9 20		cmp #$20	                CMP #CHAR_SP                ; Is it a blank?
.1a6975	f0 09		beq $1a6980	                BEQ pr_rbracket             ; Yes: end the name and print the dot
.1a6977	20 18 00	jsr $1a0018	            JSR PRINTC
.1a697a	c8		iny		                INY                         ; Move to the next character
.1a697b	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.1a697e	d0 f1		bne $1a6971	                BNE pr_vol_loop             ; No: print this new character
.1a6980	a9 5d		lda #$5d	pr_rbracket     LDA #']'                    ; Print a close bracket
.1a6982	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6985	80 ae		bra $1a6935	                BRA end_entry               ; And try to get the next entry
.1a6987					SETFILEDESC
.1a6987	0b		phd		                PHD
.1a6988	08		php		                PHP
.1a6989	08		php		            PHP
.1a698a	c2 20		rep #$20	            REP #$20
.1a698c	48		pha		            PHA
.1a698d	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.1a6990	5b		tcd		            TCD
.1a6991	68		pla		            PLA
.1a6992	28		plp		            PLP
.1a6993	c2 30		rep #$30	            REP #$30
.1a6995	a9 73 f2	lda #$f273	                LDA #<>FD_IN            ; Point to the file descriptor
.1a6998	85 20		sta $0340	                STA DOS_FD_PTR
.1a699a	a9 1a 00	lda #$001a	                LDA #`FD_IN
.1a699d	85 22		sta $0342	                STA DOS_FD_PTR+2
.1a699f	a0 00 00	ldy #$0000	                LDY #0                  ; Fille the file descriptor with 0
.1a69a2	e2 20		sep #$20	            SEP #$20
.1a69a4	a9 00		lda #$00	                LDA #0
.1a69a6	97 20		sta [$0340],y	zero_loop       STA [DOS_FD_PTR],Y
.1a69a8	c8		iny		                INY
.1a69a9	c0 1e 00	cpy #$001e	                CPY #SIZE(FILEDESC)
.1a69ac	d0 f8		bne $1a69a6	                BNE zero_loop
.1a69ae	c2 20		rep #$20	            REP #$20
.1a69b0	a9 73 f0	lda #$f073	                LDA #<>CLUSTER_BUFF     ; Point to the cluster buffer
.1a69b3	8f 81 f2 1a	sta $1af281	                STA @l FD_IN.BUFFER
.1a69b7	a9 1a 00	lda #$001a	                LDA #`CLUSTER_BUFF
.1a69ba	8f 83 f2 1a	sta $1af283	                STA @l FD_IN.BUFFER+2
.1a69be	af 23 08 00	lda $000823	                LDA @l ARGUMENT1        ; Point the file desriptor to the path
.1a69c2	8f 75 f2 1a	sta $1af275	                STA @l FD_IN.PATH
.1a69c6	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a69ca	8f 77 f2 1a	sta $1af277	                STA @l FD_IN.PATH+2
.1a69ce	28		plp		                PLP
.1a69cf	2b		pld		                PLD
.1a69d0	60		rts		            RTS
.1a69d1					S_BLOAD
.1a69d1	08		php		                PHP
.1a69d2	c2 30		rep #$30	            REP #$30
.1a69d4	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a69d7	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a69da	20 32 06	jsr $1a0632	            JSR ASS_ARG1_STR
.1a69dd	20 87 69	jsr $1a6987	            JSR SETFILEDESC
.1a69e0	e2 20		sep #$20	            SEP #$20
.1a69e2	a9 2c		lda #$2c	                LDA #','
.1a69e4	85 37		sta $0837	                STA TARGETTOK
.1a69e6	20 a9 21	jsr $1a21a9	            JSR OPT_TOK
.1a69e9	b0 0f		bcs $1a69fa	                BCS get_dest
.1a69eb	c2 20		rep #$20	            REP #$20
.1a69ed	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set destination address to something "safe"
.1a69f0	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a69f4	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a69f8	80 17		bra $1a6a11	                BRA do_load
.1a69fa					get_dest
.1a69fa	20 67 20	jsr $1a2067	            JSR INCBIP
.1a69fd	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a6a00	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a6a03	c2 20		rep #$20	            REP #$20
.1a6a05	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the destination address
.1a6a07	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a6a0b	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6a0d	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a6a11	22 18 11 00	jsl $001118	do_load         JSL FK_LOAD                 ; Attempt to load the file
.1a6a15	b0 1f		bcs $1a6a36	                BCS done
.1a6a17	08		php		            PHP
.1a6a18	c2 20		rep #$20	            REP #$20
.1a6a1a	48		pha		            PHA
.1a6a1b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6a1e	5b		tcd		            TCD
.1a6a1f	68		pla		            PLA
.1a6a20	28		plp		            PLP
.1a6a21	e2 20		sep #$20	            SEP #$20
.1a6a23	a9 11		lda #$11	            LDA #ERR_LOAD
.1a6a25	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6a29	c2 20		rep #$20	            REP #$20
.1a6a2b	29 ff 00	and #$00ff	            AND #$00FF
.1a6a2e	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a6a31	e2 20		sep #$20	            SEP #$20
.1a6a33	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6a36	28		plp		done            PLP
.1a6a37	60		rts		            RTS
.1a6a38					SET_DOSSTAT
.1a6a38	8b		phb		                PHB
.1a6a39	0b		phd		                PHD
.1a6a3a	08		php		                PHP
.1a6a3b	08		php		            PHP
.1a6a3c	c2 20		rep #$20	            REP #$20
.1a6a3e	48		pha		            PHA
.1a6a3f	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6a42	5b		tcd		            TCD
.1a6a43	68		pla		            PLA
.1a6a44	28		plp		            PLP
.1a6a45	08		php		            PHP
.1a6a46	e2 20		sep #$20	            SEP #$20
.1a6a48	48		pha		            PHA
.1a6a49	a9 00		lda #$00	            LDA #BASIC_BANK
.1a6a4b	48		pha		            PHA
.1a6a4c	ab		plb		            PLB
.1a6a4d	68		pla		            PLA
.1a6a4e	28		plp		            PLP
.1a6a4f	e2 20		sep #$20	            SEP #$20
.1a6a51	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS           ; Get the DOS status code
.1a6a55	85 23		sta $0823	                STA ARGUMENT1
.1a6a57	a9 00		lda #$00	                LDA #0
.1a6a59	85 24		sta $0824	                STA ARGUMENT1+1
.1a6a5b	85 25		sta $0825	                STA ARGUMENT1+2
.1a6a5d	85 26		sta $0826	                STA ARGUMENT1+3
.1a6a5f	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a6a61	85 27		sta $0827	                STA ARGTYPE1
.1a6a63	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (DOSSTAT)
.1a6a65	a9 1a		lda #$1a	                LDA #`dosstat_name
.1a6a67	85 e9		sta $08e9	                STA TOFIND+2
.1a6a69	c2 20		rep #$20	            REP #$20
.1a6a6b	a9 9b 6a	lda #$6a9b	                LDA #<>dosstat_name
.1a6a6e	85 e7		sta $08e7	                STA TOFIND
.1a6a70	20 25 52	jsr $1a5225	            JSR VAR_SET
.1a6a73	e2 20		sep #$20	            SEP #$20
.1a6a75	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS          ; Get the BIOS status code
.1a6a79	85 23		sta $0823	                STA ARGUMENT1
.1a6a7b	a9 00		lda #$00	                LDA #0
.1a6a7d	85 24		sta $0824	                STA ARGUMENT1+1
.1a6a7f	85 25		sta $0825	                STA ARGUMENT1+2
.1a6a81	85 26		sta $0826	                STA ARGUMENT1+3
.1a6a83	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a6a85	85 27		sta $0827	                STA ARGTYPE1
.1a6a87	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BIOSSTAT)
.1a6a89	a9 1a		lda #$1a	                LDA #`biosstat_name
.1a6a8b	85 e9		sta $08e9	                STA TOFIND+2
.1a6a8d	c2 20		rep #$20	            REP #$20
.1a6a8f	a9 a3 6a	lda #$6aa3	                LDA #<>biosstat_name
.1a6a92	85 e7		sta $08e7	                STA TOFIND
.1a6a94	20 25 52	jsr $1a5225	            JSR VAR_SET
.1a6a97	28		plp		                PLP
.1a6a98	2b		pld		                PLD
.1a6a99	ab		plb		                PLB
.1a6a9a	60		rts		            RTS
>1a6a9b	44 4f 53 53 54 41 54 00		dosstat_name    .null "DOSSTAT"
>1a6aa3	42 49 4f 53 53 54 41 54		biosstat_name   .null "BIOSSTAT"
>1a6aab	00
.1a6aac					CMD_BRUN
.1a6aac	08		php		                PHP
.1a6aad	c2 30		rep #$30	            REP #$30
.1a6aaf	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a6ab2	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a6ab5	20 32 06	jsr $1a0632	            JSR ASS_ARG1_STR
.1a6ab8	a5 23		lda $0823	                LDA ARGUMENT1
.1a6aba	8f 60 03 00	sta $000360	                STA @l DOS_RUN_PARAM
.1a6abe	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6ac0	8f 62 03 00	sta $000362	                STA @l DOS_RUN_PARAM+2
.1a6ac4	a9 ff ff	lda #$ffff	                LDA #$FFFF
.1a6ac7	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a6acb	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a6acf	22 24 11 00	jsl $001124	                JSL FK_RUN                  ; Attempt to run the file
.1a6ad3	b0 25		bcs $1a6afa	                BCS done                    ; If we got it: try to execute it
.1a6ad5	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a6ad8	20 38 6a	jsr $1a6a38	            JSR SET_DOSSTAT
.1a6adb	08		php		            PHP
.1a6adc	c2 20		rep #$20	            REP #$20
.1a6ade	48		pha		            PHA
.1a6adf	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6ae2	5b		tcd		            TCD
.1a6ae3	68		pla		            PLA
.1a6ae4	28		plp		            PLP
.1a6ae5	e2 20		sep #$20	            SEP #$20
.1a6ae7	a9 11		lda #$11	            LDA #ERR_LOAD
.1a6ae9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6aed	c2 20		rep #$20	            REP #$20
.1a6aef	29 ff 00	and #$00ff	            AND #$00FF
.1a6af2	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a6af5	e2 20		sep #$20	            SEP #$20
.1a6af7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6afa					done
.1a6afa	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a6afd	28		plp		                PLP
.1a6afe	60		rts		            RTS
.1a6aff					CMD_LOAD
.1a6aff	08		php		                PHP
.1a6b00	c2 30		rep #$30	            REP #$30
.1a6b02	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a6b05	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a6b08	20 32 06	jsr $1a0632	            JSR ASS_ARG1_STR
.1a6b0b	20 87 69	jsr $1a6987	            JSR SETFILEDESC
.1a6b0e	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.1a6b11	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a6b15	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.1a6b18	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2        ; Set the destination address
.1a6b1c	20 f6 4e	jsr $1a4ef6	            JSR CMD_NEW
.1a6b1f	22 18 11 00	jsl $001118	                JSL FK_LOAD                 ; Attempt to load the file
.1a6b23	b0 22		bcs $1a6b47	                BCS start_tokenize          ; If we got it: start tokenizing
.1a6b25	20 38 6a	jsr $1a6a38	            JSR SET_DOSSTAT
.1a6b28	08		php		            PHP
.1a6b29	c2 20		rep #$20	            REP #$20
.1a6b2b	48		pha		            PHA
.1a6b2c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6b2f	5b		tcd		            TCD
.1a6b30	68		pla		            PLA
.1a6b31	28		plp		            PLP
.1a6b32	e2 20		sep #$20	            SEP #$20
.1a6b34	a9 11		lda #$11	            LDA #ERR_LOAD
.1a6b36	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6b3a	c2 20		rep #$20	            REP #$20
.1a6b3c	29 ff 00	and #$00ff	            AND #$00FF
.1a6b3f	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a6b42	e2 20		sep #$20	            SEP #$20
.1a6b44	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6b47					start_tokenize
.1a6b47	20 38 6a	jsr $1a6a38	            JSR SET_DOSSTAT
.1a6b4a	c2 20		rep #$20	            REP #$20
.1a6b4c	a2 12 00	ldx #$0012	                LDX #FILEDESC.FILESIZE
.1a6b4f	18		clc		                CLC                         ; Set MTEMP to point to the byte after the file
.1a6b50	bf 73 f2 1a	lda $1af273,x	                LDA FD_IN,X
.1a6b54	69 00 00	adc #$0000	                ADC #<>LOADBLOCK
.1a6b57	85 92		sta $0892	                STA MTEMP
.1a6b59	bf 75 f2 1a	lda $1af275,x	                LDA FD_IN+2,X
.1a6b5d	69 01 00	adc #$0001	                ADC #`LOADBLOCK
.1a6b60	85 94		sta $0894	                STA MTEMP+2
.1a6b62	e2 20		sep #$20	            SEP #$20
.1a6b64	a9 00		lda #$00	                LDA #0
.1a6b66	87 92		sta [$0892]	                STA [MTEMP]                 ; Write a NULL right after the file
.1a6b68	c2 20		rep #$20	            REP #$20
.1a6b6a	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK            ; Set MCURSOR to the begining of the loaded data
.1a6b6d	85 7a		sta $087a	                STA MCURSOR
.1a6b6f	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.1a6b72	85 7c		sta $087c	                STA MCURSOR+2
.1a6b74	a2 00 00	ldx #$0000	copy_line       LDX #0
.1a6b77					copy_char
.1a6b77	e2 20		sep #$20	            SEP #$20
.1a6b79	a7 7a		lda [$087a]	                LDA [MCURSOR]
.1a6b7b	f0 2a		beq $1a6ba7	                BEQ clean_up                ; If the character is 0, we're done
.1a6b7d	c9 0d		cmp #$0d	                CMP #CHAR_CR                ; If it is new line...
.1a6b7f	f0 12		beq $1a6b93	                BEQ do_process              ; ... we want to process the line
.1a6b81	c9 0a		cmp #$0a	                CMP #CHAR_LF                ; If it is a line feed...
.1a6b83	f0 04		beq $1a6b89	                BEQ next_char               ; ... we want to skip it
.1a6b85	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X              ; Otherwise, copy the character to the input buffer
.1a6b88	e8		inx		                INX
.1a6b89					next_char
.1a6b89	c2 20		rep #$20	            REP #$20
.1a6b8b	e6 7a		inc $087a	                INC MCURSOR                 ; Advance the input cursor
.1a6b8d	d0 e8		bne $1a6b77	                BNE copy_char
.1a6b8f	e6 7c		inc $087c	                INC MCURSOR+2
.1a6b91	80 e4		bra $1a6b77	                BRA copy_char
.1a6b93					do_process
.1a6b93	e2 20		sep #$20	            SEP #$20
.1a6b95	a9 00		lda #$00	                LDA #0                      ; Put a 0 at the end of the input buffer
.1a6b97	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a6b9a	20 d7 26	jsr $1a26d7	            JSR PROCESS
.1a6b9d	c2 20		rep #$20	            REP #$20
.1a6b9f	e6 7a		inc $087a	                INC MCURSOR                 ; Try again with the next line
.1a6ba1	d0 d1		bne $1a6b74	                BNE copy_line
.1a6ba3	e6 7c		inc $087c	                INC MCURSOR+2
.1a6ba5	80 cd		bra $1a6b74	                BRA copy_line
.1a6ba7	e0 00 00	cpx #$0000	clean_up        CPX #0                      ; Is there data in the INPUTBUF?
.1a6baa	f0 0a		beq $1a6bb6	                BEQ done                    ; No: just return
.1a6bac	e2 20		sep #$20	            SEP #$20
.1a6bae	a9 00		lda #$00	                LDA #0                      ; Make sure there is a trailing NULL
.1a6bb0	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a6bb3	20 d7 26	jsr $1a26d7	            JSR PROCESS
.1a6bb6	28		plp		done            PLP
.1a6bb7	60		rts		            RTS
.1a6bb8					S_BSAVE
.1a6bb8	08		php		                PHP
.1a6bb9	c2 30		rep #$30	            REP #$30
.1a6bbb	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a6bbe	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a6bc1	20 32 06	jsr $1a0632	            JSR ASS_ARG1_STR
.1a6bc4	20 87 69	jsr $1a6987	            JSR SETFILEDESC
.1a6bc7	e2 20		sep #$20	            SEP #$20
.1a6bc9	a9 2c		lda #$2c	                LDA #','
.1a6bcb	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a6bce	c2 20		rep #$20	            REP #$20
.1a6bd0	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a6bd3	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a6bd6	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_SRC_PTR
.1a6bd8	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.1a6bdc	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6bde	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.1a6be2	e2 20		sep #$20	            SEP #$20
.1a6be4	a9 2c		lda #$2c	                LDA #','
.1a6be6	c2 20		rep #$20	            REP #$20
.1a6be8	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a6beb	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a6bee	20 a0 05	jsr $1a05a0	            JSR ASS_ARG1_INT
.1a6bf1	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_END_PTR
.1a6bf3	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.1a6bf7	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6bf9	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.1a6bfd	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                 ; Attempt to save the memory to file.
.1a6c01	b0 22		bcs $1a6c25	                BCS done
.1a6c03	20 38 6a	jsr $1a6a38	            JSR SET_DOSSTAT
.1a6c06	08		php		            PHP
.1a6c07	c2 20		rep #$20	            REP #$20
.1a6c09	48		pha		            PHA
.1a6c0a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6c0d	5b		tcd		            TCD
.1a6c0e	68		pla		            PLA
.1a6c0f	28		plp		            PLP
.1a6c10	e2 20		sep #$20	            SEP #$20
.1a6c12	a9 12		lda #$12	            LDA #ERR_SAVE
.1a6c14	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6c18	c2 20		rep #$20	            REP #$20
.1a6c1a	29 ff 00	and #$00ff	            AND #$00FF
.1a6c1d	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a6c20	e2 20		sep #$20	            SEP #$20
.1a6c22	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6c25					done
.1a6c25	20 38 6a	jsr $1a6a38	            JSR SET_DOSSTAT
.1a6c28	28		plp		                PLP
.1a6c29	60		rts		            RTS
.1a6c2a					COPY2PATHBUF
.1a6c2a	da		phx		                PHX
.1a6c2b	5a		phy		                PHY
.1a6c2c	08		php		                PHP
.1a6c2d	a2 00 00	ldx #$0000	                LDX #0
.1a6c30	a0 00 00	ldy #$0000	                LDY #0
.1a6c33	e2 20		sep #$20	            SEP #$20
.1a6c35	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y           ; Copy the path to the DOS_PATH_BUFF
.1a6c37	9d 00 04	sta $0400,x	                STA DOS_PATH_BUFF,X
.1a6c3a	f0 04		beq $1a6c40	                BEQ done
.1a6c3c	e8		inx		                INX
.1a6c3d	c8		iny		                INY
.1a6c3e	80 f5		bra $1a6c35	                BRA loop
.1a6c40	28		plp		done            PLP
.1a6c41	7a		ply		                PLY
.1a6c42	fa		plx		                PLX
.1a6c43	60		rts		            RTS
.1a6c44					CMD_SAVE
.1a6c44	08		php		                PHP
.1a6c45	c2 30		rep #$30	            REP #$30
.1a6c47	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a6c4a	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a6c4d	20 32 06	jsr $1a0632	            JSR ASS_ARG1_STR
.1a6c50	20 87 69	jsr $1a6987	            JSR SETFILEDESC
.1a6c53	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.1a6c56	85 a6		sta $08a6	                STA OBUFFER
.1a6c58	e2 20		sep #$20	            SEP #$20
.1a6c5a	a9 01		lda #$01	                LDA #`LOADBLOCK
.1a6c5c	85 a8		sta $08a8	                STA OBUFFER+2
.1a6c5e	a9 20		lda #$20	                LDA #DEV_BUFFER             ; Set up output for the buffer
.1a6c60	85 b4		sta $08b4	                STA BCONSOLE
.1a6c62	c2 20		rep #$20	            REP #$20
.1a6c64	a9 00 00	lda #$0000	                LDA #0
.1a6c67	85 ab		sta $08ab	                STA OBUFFIDX
.1a6c69	a9 ff ff	lda #$ffff	                LDA #$FFFF
.1a6c6c	85 a9		sta $08a9	                STA OBUFFSIZE
.1a6c6e	c2 20		rep #$20	            REP #$20
.1a6c70	a9 00 00	lda #$0000	                LDA #0                      ; Set start line number to 0
.1a6c73	85 55		sta $0855	                STA MARG1
.1a6c75	85 57		sta $0857	                STA MARG1+2
.1a6c77	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set end line number to MAXINT
.1a6c7a	85 59		sta $0859	                STA MARG2
.1a6c7c	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.1a6c7f	85 5b		sta $085b	                STA MARG2+2
.1a6c81	20 d5 17	jsr $1a17d5	            JSR LISTPROG
.1a6c84	e2 20		sep #$20	            SEP #$20
.1a6c86	a9 80		lda #$80	                LDA #DEV_SCREEN             ; Restore output to the screen
.1a6c88	85 b4		sta $08b4	                STA BCONSOLE
.1a6c8a	c2 20		rep #$20	            REP #$20
.1a6c8c	c6 ab		dec $08ab	                DEC OBUFFIDX                ; OBUFFIDX points to the next free byte... so pull it in one
.1a6c8e	18		clc		                CLC                         ; Set the range of memory to save
.1a6c8f	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.1a6c92	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.1a6c96	65 ab		adc $08ab	                ADC OBUFFIDX
.1a6c98	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.1a6c9c	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.1a6c9f	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.1a6ca3	69 00 00	adc #$0000	                ADC #0
.1a6ca6	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.1a6caa	22 1c 11 00	jsl $00111c	do_save         JSL FK_SAVE                 ; Attempt to save the file
.1a6cae	b0 22		bcs $1a6cd2	                BCS done
.1a6cb0	20 38 6a	jsr $1a6a38	            JSR SET_DOSSTAT
.1a6cb3	08		php		            PHP
.1a6cb4	c2 20		rep #$20	            REP #$20
.1a6cb6	48		pha		            PHA
.1a6cb7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6cba	5b		tcd		            TCD
.1a6cbb	68		pla		            PLA
.1a6cbc	28		plp		            PLP
.1a6cbd	e2 20		sep #$20	            SEP #$20
.1a6cbf	a9 12		lda #$12	            LDA #ERR_SAVE
.1a6cc1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6cc5	c2 20		rep #$20	            REP #$20
.1a6cc7	29 ff 00	and #$00ff	            AND #$00FF
.1a6cca	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a6ccd	e2 20		sep #$20	            SEP #$20
.1a6ccf	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6cd2					done
.1a6cd2	20 38 6a	jsr $1a6a38	            JSR SET_DOSSTAT
.1a6cd5	28		plp		                PLP
.1a6cd6	60		rts		            RTS
.1a6cd7					S_DEL
.1a6cd7	08		php		                PHP
.1a6cd8	c2 30		rep #$30	            REP #$30
.1a6cda	20 88 20	jsr $1a2088	            JSR SKIPWS
.1a6cdd	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a6ce0	20 32 06	jsr $1a0632	            JSR ASS_ARG1_STR
.1a6ce3	20 2a 6c	jsr $1a6c2a	            JSR COPY2PATHBUF
.1a6ce6	22 04 11 00	jsl $001104	path_loaded     JSL FK_DELETE               ; Try to delete the file
.1a6cea	b0 22		bcs $1a6d0e	                BCS done
.1a6cec	20 38 6a	jsr $1a6a38	            JSR SET_DOSSTAT
.1a6cef	08		php		            PHP
.1a6cf0	c2 20		rep #$20	            REP #$20
.1a6cf2	48		pha		            PHA
.1a6cf3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6cf6	5b		tcd		            TCD
.1a6cf7	68		pla		            PLA
.1a6cf8	28		plp		            PLP
.1a6cf9	e2 20		sep #$20	            SEP #$20
.1a6cfb	a9 13		lda #$13	            LDA #ERR_DELETE
.1a6cfd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6d01	c2 20		rep #$20	            REP #$20
.1a6d03	29 ff 00	and #$00ff	            AND #$00FF
.1a6d06	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a6d09	e2 20		sep #$20	            SEP #$20
.1a6d0b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6d0e					done
.1a6d0e	20 38 6a	jsr $1a6a38	            JSR SET_DOSSTAT
.1a6d11	28		plp		                PLP
.1a6d12	60		rts		            RTS
.1a6d13					VALIDFILECHAR
.1a6d13	da		phx		                PHX
.1a6d14	08		php		                PHP
.1a6d15	e2 20		sep #$20	            SEP #$20
.1a6d17	c9 61		cmp #$61	                CMP #'a'                    ; Is it lower case?
.1a6d19	90 08		bcc $1a6d23	                BLT chk_space
.1a6d1b	c9 7b		cmp #$7b	                CMP #'z'+1
.1a6d1d	b0 04		bcs $1a6d23	                BGE chk_space
.1a6d1f	29 df		and #$df	                AND #%11011111              ; Yes: convert to upper case
.1a6d21	80 13		bra $1a6d36	                BRA ret_valid
.1a6d23	c9 20		cmp #$20	chk_space       CMP #CHAR_SP            ; Is it a control code?
.1a6d25	90 13		bcc $1a6d3a	                BLT is_invalid          ; Yes: it's invalid
.1a6d27	a2 00 00	ldx #$0000	                LDX #0                  ; See if it's in the list of invalids
.1a6d2a	df 3e 6d 1a	cmp $1a6d3e,x	loop            CMP invalid_chars,X
.1a6d2e	f0 0a		beq $1a6d3a	                BEQ is_invalid
.1a6d30	e8		inx		                INX
.1a6d31	e0 0f 00	cpx #$000f	                CPX #15                 ; # of invalid characters
.1a6d34	d0 f4		bne $1a6d2a	                BNE loop
.1a6d36	28		plp		ret_valid       PLP
.1a6d37	38		sec		                SEC
.1a6d38	fa		plx		                PLX
.1a6d39	6b		rtl		                RTL
.1a6d3a	28		plp		is_invalid      PLP
.1a6d3b	18		clc		                CLC
.1a6d3c	fa		plx		                PLX
.1a6d3d	6b		rtl		                RTL
>1a6d3e	2a 2b 2c 2f 3a 3b 3c 3d		invalid_chars   .text "*+,/:;<=>?\[]|",CHAR_DQUOTE
>1a6d46	3e 3f 5c 5b 5d 7c 22
.1a6d4d					S_RENAME
.1a6d4d	08		php		                PHP
.1a6d4e	08		php		            PHP
.1a6d4f	c2 20		rep #$20	            REP #$20
.1a6d51	48		pha		            PHA
.1a6d52	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6d55	5b		tcd		            TCD
.1a6d56	68		pla		            PLA
.1a6d57	28		plp		            PLP
.1a6d58	c2 30		rep #$30	            REP #$30
.1a6d5a	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a6d5d	20 32 06	jsr $1a0632	            JSR ASS_ARG1_STR
.1a6d60	20 2a 6c	jsr $1a6c2a	            JSR COPY2PATHBUF
.1a6d63	22 10 11 00	jsl $001110	                JSL FK_DIRREAD              ; Try to read the file
.1a6d67	b0 22		bcs $1a6d8b	                BCS get_new_name            ; If ok: get the new name
.1a6d69	20 38 6a	jsr $1a6a38	            JSR SET_DOSSTAT
.1a6d6c	08		php		            PHP
.1a6d6d	c2 20		rep #$20	            REP #$20
.1a6d6f	48		pha		            PHA
.1a6d70	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6d73	5b		tcd		            TCD
.1a6d74	68		pla		            PLA
.1a6d75	28		plp		            PLP
.1a6d76	e2 20		sep #$20	            SEP #$20
.1a6d78	a9 14		lda #$14	            LDA #ERR_FILENOTFOUND
.1a6d7a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6d7e	c2 20		rep #$20	            REP #$20
.1a6d80	29 ff 00	and #$00ff	            AND #$00FF
.1a6d83	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a6d86	e2 20		sep #$20	            SEP #$20
.1a6d88	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6d8b					get_new_name
.1a6d8b	e2 20		sep #$20	            SEP #$20
.1a6d8d	a9 2c		lda #$2c	                LDA #','
.1a6d8f	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a6d92	c2 20		rep #$20	            REP #$20
.1a6d94	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a6d97	20 32 06	jsr $1a0632	            JSR ASS_ARG1_STR
.1a6d9a	ad 38 03	lda $0338	                LDA DOS_DIR_PTR
.1a6d9d	85 08		sta $0808	                STA INDEX
.1a6d9f	ad 3a 03	lda $033a	                LDA DOS_DIR_PTR+2
.1a6da2	85 0a		sta $080a	                STA INDEX+2
.1a6da4	e2 20		sep #$20	            SEP #$20
.1a6da6	a2 00 00	ldx #$0000	                LDX #0
.1a6da9	a9 20		lda #$20	                LDA #CHAR_SP                ; We'll use MLINEBUFF as temporary name storage
.1a6dab	95 7e		sta $087e,x	blank_loop      STA MLINEBUF,X              ; Fill it with blanks
.1a6dad	e8		inx		                INX
.1a6dae	e0 0b 00	cpx #$000b	                CPX #11
.1a6db1	d0 f8		bne $1a6dab	                BNE blank_loop
.1a6db3	a2 00 00	ldx #$0000	                LDX #0
.1a6db6	a0 00 00	ldy #$0000	                LDY #0
.1a6db9	b7 23		lda [$0823],y	name_loop       LDA [ARGUMENT1],Y           ; Get the character of the new name
.1a6dbb	f0 76		beq $1a6e33	                BEQ copy_short_name         ; If end-of-string: copy what we have
.1a6dbd	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.1a6dbf	f0 39		beq $1a6dfa	                BEQ skip_dot                ; Yes: move on to the extension characters
.1a6dc1	22 13 6d 1a	jsl $1a6d13	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.1a6dc5	b0 1f		bcs $1a6de6	                BCS save_nm_char
.1a6dc7	08		php		            PHP
.1a6dc8	c2 20		rep #$20	            REP #$20
.1a6dca	48		pha		            PHA
.1a6dcb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6dce	5b		tcd		            TCD
.1a6dcf	68		pla		            PLA
.1a6dd0	28		plp		            PLP
.1a6dd1	e2 20		sep #$20	            SEP #$20
.1a6dd3	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a6dd5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6dd9	c2 20		rep #$20	            REP #$20
.1a6ddb	29 ff 00	and #$00ff	            AND #$00FF
.1a6dde	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a6de1	e2 20		sep #$20	            SEP #$20
.1a6de3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6de6	95 7e		sta $087e,x	save_nm_char    STA MLINEBUF,X              ; Otherwise: copy it
.1a6de8	c8		iny		                INY
.1a6de9	e8		inx		                INX
.1a6dea	c0 08 00	cpy #$0008	                CPY #8
.1a6ded	d0 ca		bne $1a6db9	                BNE name_loop
.1a6def	b7 23		lda [$0823],y	eat_name        LDA [ARGUMENT1],Y           ; Get the character
.1a6df1	f0 40		beq $1a6e33	                BEQ copy_short_name         ; If null, we're done with the short name
.1a6df3	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.1a6df5	f0 03		beq $1a6dfa	                BEQ skip_dot                ; Yes: skip over it
.1a6df7	c8		iny		                INY                         ; No: try again with the the next character
.1a6df8	80 f5		bra $1a6def	                BRA eat_name
.1a6dfa	c8		iny		skip_dot        INY                         ; Character at Y is '.', so skip over it
.1a6dfb	a2 08 00	ldx #$0008	do_ext          LDX #8
.1a6dfe	b7 23		lda [$0823],y	ext_loop        LDA [ARGUMENT1],Y           ; Get the character of the new extension
.1a6e00	f0 31		beq $1a6e33	                BEQ copy_short_name         ; If end-of-string: copy what we have
.1a6e02	22 13 6d 1a	jsl $1a6d13	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.1a6e06	b0 22		bcs $1a6e2a	                BCS save_ext_char
.1a6e08	20 38 6a	jsr $1a6a38	            JSR SET_DOSSTAT
.1a6e0b	08		php		            PHP
.1a6e0c	c2 20		rep #$20	            REP #$20
.1a6e0e	48		pha		            PHA
.1a6e0f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6e12	5b		tcd		            TCD
.1a6e13	68		pla		            PLA
.1a6e14	28		plp		            PLP
.1a6e15	e2 20		sep #$20	            SEP #$20
.1a6e17	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a6e19	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6e1d	c2 20		rep #$20	            REP #$20
.1a6e1f	29 ff 00	and #$00ff	            AND #$00FF
.1a6e22	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a6e25	e2 20		sep #$20	            SEP #$20
.1a6e27	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6e2a	95 7e		sta $087e,x	save_ext_char   STA MLINEBUF,X              ; Otherwise: copy it
.1a6e2c	c8		iny		                INY
.1a6e2d	e8		inx		                INX
.1a6e2e	c0 0c 00	cpy #$000c	                CPY #12
.1a6e31	d0 cb		bne $1a6dfe	                BNE ext_loop
.1a6e33	a2 00 00	ldx #$0000	copy_short_name LDX #0                      ; Copy the short name we built to the directory entry
.1a6e36	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME
.1a6e39	b5 7e		lda $087e,x	copy_loop       LDA MLINEBUF,X
.1a6e3b	97 08		sta [$0808],y	                STA [INDEX],Y
.1a6e3d	e8		inx		                INX
.1a6e3e	c8		iny		                INY
.1a6e3f	c0 0b 00	cpy #$000b	                CPY #11
.1a6e42	d0 f5		bne $1a6e39	                BNE copy_loop
.1a6e44	22 14 11 00	jsl $001114	                JSL FK_DIRWRITE             ; Write the directory entry back
.1a6e48	b0 22		bcs $1a6e6c	                BCS done
.1a6e4a	20 38 6a	jsr $1a6a38	            JSR SET_DOSSTAT
.1a6e4d	08		php		            PHP
.1a6e4e	c2 20		rep #$20	            REP #$20
.1a6e50	48		pha		            PHA
.1a6e51	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6e54	5b		tcd		            TCD
.1a6e55	68		pla		            PLA
.1a6e56	28		plp		            PLP
.1a6e57	e2 20		sep #$20	            SEP #$20
.1a6e59	a9 15		lda #$15	            LDA #ERR_DIRNOTWRITE
.1a6e5b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6e5f	c2 20		rep #$20	            REP #$20
.1a6e61	29 ff 00	and #$00ff	            AND #$00FF
.1a6e64	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a6e67	e2 20		sep #$20	            SEP #$20
.1a6e69	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6e6c					done
.1a6e6c	20 38 6a	jsr $1a6a38	            JSR SET_DOSSTAT
.1a6e6f	28		plp		                PLP
.1a6e70	60		rts		            RTS
.1a6e71					S_COPY
.1a6e71	08		php		                PHP
.1a6e72	08		php		            PHP
.1a6e73	c2 20		rep #$20	            REP #$20
.1a6e75	48		pha		            PHA
.1a6e76	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6e79	5b		tcd		            TCD
.1a6e7a	68		pla		            PLA
.1a6e7b	28		plp		            PLP
.1a6e7c	c2 30		rep #$30	            REP #$30
.1a6e7e	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a6e81	20 32 06	jsr $1a0632	            JSR ASS_ARG1_STR
.1a6e84	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.1a6e86	8f 64 03 00	sta $000364	                STA @l DOS_STR1_PTR
.1a6e8a	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6e8c	8f 66 03 00	sta $000366	                STA @l DOS_STR1_PTR+2
.1a6e90	e2 20		sep #$20	            SEP #$20
.1a6e92	a9 2c		lda #$2c	                LDA #','
.1a6e94	20 74 21	jsr $1a2174	            JSR EXPECT_TOK
.1a6e97	c2 20		rep #$20	            REP #$20
.1a6e99	20 56 1c	jsr $1a1c56	            JSR EVALEXPR
.1a6e9c	20 32 06	jsr $1a0632	            JSR ASS_ARG1_STR
.1a6e9f	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.1a6ea1	8f 68 03 00	sta $000368	                STA @l DOS_STR2_PTR
.1a6ea5	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6ea7	8f 6a 03 00	sta $00036a	                STA @l DOS_STR2_PTR+2
.1a6eab	22 30 11 00	jsl $001130	                JSL FK_COPY                 ; Attempt to copy the file
.1a6eaf	b0 1f		bcs $1a6ed0	                BCS done
.1a6eb1	08		php		            PHP
.1a6eb2	c2 20		rep #$20	            REP #$20
.1a6eb4	48		pha		            PHA
.1a6eb5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6eb8	5b		tcd		            TCD
.1a6eb9	68		pla		            PLA
.1a6eba	28		plp		            PLP
.1a6ebb	e2 20		sep #$20	            SEP #$20
.1a6ebd	a9 16		lda #$16	            LDA #ERR_NOTCOPIED
.1a6ebf	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6ec3	c2 20		rep #$20	            REP #$20
.1a6ec5	29 ff 00	and #$00ff	            AND #$00FF
.1a6ec8	20 a8 1d	jsr $1a1da8	            JSR SET_ERRERL
.1a6ecb	e2 20		sep #$20	            SEP #$20
.1a6ecd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6ed0	28		plp		done            PLP
.1a6ed1	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\monitor.s

.1a6ed2	5c 8f 88 1a	jmp $1a888f	MRETURN         JML IMRETURN
.1a6ed6	5c e0 86 1a	jmp $1a86e0	MPARSE          JML IMPARSE
.1a6eda	5c 90 88 1a	jmp $1a8890	MPARSE1         JML IMPARSE1
.1a6ede	5c 0c 78 1a	jmp $1a780c	MEXECUTE        JML IMEXECUTE
.1a6ee2	5c 69 78 1a	jmp $1a7869	MASSEMBLE       JML IMASSEMBLE
.1a6ee6	5c 9c 77 1a	jmp $1a779c	MRMODIFY        JML IMRMODIFY
.1a6eea	5c 22 77 1a	jmp $1a7722	MCOMPARE        JML IMCOMPARE
.1a6eee	5c 9f 7c 1a	jmp $1a7c9f	MDISASSEMBLE    JML IMDISASSEMBLE
.1a6ef2	5c 8d 73 1a	jmp $1a738d	MFILL           JML IMFILL
.1a6ef6	5c ba 76 1a	jmp $1a76ba	MGO             JML IMGO
.1a6efa	5c 75 76 1a	jmp $1a7675	MJUMP           JML IMJUMP
.1a6efe	5c ff 75 1a	jmp $1a75ff	MHUNT           JML IMHUNT
.1a6f02	5c 9e 87 1a	jmp $1a879e	MLOAD           JML IMLOAD
.1a6f06	5c 9b 74 1a	jmp $1a749b	MMEMORY         JML IMMEMORY
.1a6f0a	5c eb 72 1a	jmp $1a72eb	MREGISTERS      JML IMREGISTERS
.1a6f0e	5c 19 88 1a	jmp $1a8819	MSAVE           JML IMSAVE
.1a6f12	5c c9 73 1a	jmp $1a73c9	MTRANSFER       JML IMTRANSFER
.1a6f16	5c 92 88 1a	jmp $1a8892	MVERIFY         JML IMVERIFY
.1a6f1a	5c 8b 88 1a	jmp $1a888b	MEXIT           JML IMEXIT
.1a6f1e	5c b8 75 1a	jmp $1a75b8	MMODIFY         JML IMMODIFY
.1a6f22	5c 93 88 1a	jmp $1a8893	MDOS            JML IMDOS
.1a6f26	18		clc		IMONITOR        CLC                 ; clear the carry flag
.1a6f27	fb		xce		                XCE                 ; move carry to emulation flags
.1a6f28	58		cli		                CLI                 ; Re-enable interrupts
.1a6f29	5c 2d 6f 1a	jmp $1a6f2d	                JML IMREADY
.1a6f2d					IMREADY
.1a6f2d	c2 30		rep #$30	            REP #$30
.1a6f2f	22 eb 72 1a	jsl $1a72eb	                JSL IMREGISTERS
.1a6f33					ready_loop
.1a6f33	20 08 00	jsr $1a0008	            JSR READLINE
.1a6f36	20 0c 00	jsr $1a000c	            JSR SCRCOPYLINE
.1a6f39	8b		phb		                PHB
.1a6f3a	e2 20		sep #$20	            SEP #$20
.1a6f3c	a9 00		lda #$00	                LDA #`INPUTBUF
.1a6f3e	48		pha		                PHA
.1a6f3f	ab		plb		                PLB
.1a6f40	a2 00 4f	ldx #$4f00	                LDX #<>INPUTBUF
.1a6f43	20 b4 04	jsr $1a04b4	            JSR TOUPPER
.1a6f46	ab		plb		                PLB
.1a6f47	22 d6 6e 1a	jsl $1a6ed6	                JSL MPARSE          ; Parse the command
.1a6f4b	22 de 6e 1a	jsl $1a6ede	                JSL MEXECUTE        ; And execute the parsed command
.1a6f4f	80 e2		bra $1a6f33	                BRA ready_loop
.1a6f51					IMHELP
.1a6f51	08		php		                PHP
.1a6f52	8b		phb		                PHB
.1a6f53	e2 20		sep #$20	            SEP #$20
.1a6f55	a9 1a		lda #$1a	                LDA #`help_text
.1a6f57	48		pha		                PHA
.1a6f58	ab		plb		                PLB
.1a6f59	c2 10		rep #$10	            REP #$10
.1a6f5b	a2 64 6f	ldx #$6f64	                LDX #<>help_text
.1a6f5e	20 b3 03	jsr $1a03b3	            JSR PRINTS
.1a6f61	ab		plb		                PLB
.1a6f62	28		plp		                PLP
.1a6f63	6b		rtl		                RTL
>1a6f64	41 20 3c 73 74 61 72 74		help_text       .text "A <start> <assembly>",CHAR_CR
>1a6f6c	3e 20 3c 61 73 73 65 6d 62 6c 79 3e 0d
>1a6f79	20 20 41 73 73 65 6d 62		                .text "  Assemble a program",CHAR_CR,CHAR_CR
>1a6f81	6c 65 20 61 20 70 72 6f 67 72 61 6d 0d 0d
>1a6f8f	43 20 3c 73 74 61 72 74		                .text "C <start1> <start2> [len (1 if blank)]",CHAR_CR
>1a6f97	31 3e 20 3c 73 74 61 72 74 32 3e 20 5b 6c 65 6e
>1a6fa7	20 28 31 20 69 66 20 62 6c 61 6e 6b 29 5d 0d
>1a6fb6	20 20 43 6f 6d 70 61 72		                .text "  Compare to sections of memory",CHAR_CR,CHAR_CR
>1a6fbe	65 20 74 6f 20 73 65 63 74 69 6f 6e 73 20 6f 66
>1a6fce	20 6d 65 6d 6f 72 79 0d 0d
>1a6fd7	44 20 3c 73 74 61 72 74		                .text "D <start> [end]",CHAR_CR
>1a6fdf	3e 20 5b 65 6e 64 5d 0d
>1a6fe7	20 20 44 69 73 61 73 73		                .text "  Disassemble a program",CHAR_CR,CHAR_CR
>1a6fef	65 6d 62 6c 65 20 61 20 70 72 6f 67 72 61 6d 0d
>1a6fff	0d
>1a7000	46 20 3c 73 74 61 72 74		                .text "F <start> <end> <byte>",CHAR_CR
>1a7008	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 0d
>1a7017	20 20 46 69 6c 6c 20 61		                .text "  Fill a block of memory with a byte",CHAR_CR,CHAR_CR
>1a701f	20 62 6c 6f 63 6b 20 6f 66 20 6d 65 6d 6f 72 79
>1a702f	20 77 69 74 68 20 61 20 62 79 74 65 0d 0d
>1a703d	47 20 5b 61 64 64 72 65		                .text "G [address]",CHAR_CR
>1a7045	73 73 5d 0d
>1a7049	20 20 53 74 61 72 74 20		                .text "  Start execution at a location",CHAR_CR,CHAR_CR
>1a7051	65 78 65 63 75 74 69 6f 6e 20 61 74 20 61 20 6c
>1a7061	6f 63 61 74 69 6f 6e 0d 0d
>1a706a	4a 20 5b 61 64 64 72 65		                .text "J [address] - Jump to a location in memory",CHAR_CR
>1a7072	73 73 5d 20 2d 20 4a 75 6d 70 20 74 6f 20 61 20
>1a7082	6c 6f 63 61 74 69 6f 6e 20 69 6e 20 6d 65 6d 6f
>1a7092	72 79 0d
>1a7095	20 20 4a 75 6d 70 20 74		                .text "  Jump to a location in memory",CHAR_CR,CHAR_CR
>1a709d	6f 20 61 20 6c 6f 63 61 74 69 6f 6e 20 69 6e 20
>1a70ad	6d 65 6d 6f 72 79 0d 0d
>1a70b5	48 20 3c 73 74 61 72 74		                .text "H <start> <end> <byte> [byte]..",CHAR_CR
>1a70bd	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 20 5b
>1a70cd	62 79 74 65 5d 2e 2e 0d
>1a70d5	20 20 48 75 6e 74 20 66		                .text "  Hunt for values in memory",CHAR_CR,CHAR_CR
>1a70dd	6f 72 20 76 61 6c 75 65 73 20 69 6e 20 6d 65 6d
>1a70ed	6f 72 79 0d 0d
>1a70f2	4c 20 20 20 20 20 4c 4f		                .text "L     LOAD         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," [destination]",CHAR_CR
>1a70fa	41 44 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>1a710a	22 20 5b 64 65 73 74 69 6e 61 74 69 6f 6e 5d 0d
>1a711a	4d 20 3c 73 74 61 72 74		                .text "M <start> [end]",CHAR_CR
>1a7122	3e 20 5b 65 6e 64 5d 0d
>1a712a	20 20 44 75 6d 70 20 74		                .text "  Dump the value in memory",CHAR_CR,CHAR_CR
>1a7132	68 65 20 76 61 6c 75 65 20 69 6e 20 6d 65 6d 6f
>1a7142	72 79 0d 0d
>1a7146	52 20 2d 20 44 69 73 70		                .text "R - Display the values of the registers",CHAR_CR,CHAR_CR
>1a714e	6c 61 79 20 74 68 65 20 76 61 6c 75 65 73 20 6f
>1a715e	66 20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d
>1a716e	0d
>1a716f	3b 20 3c 50 43 3e 20 3c		                .text "; <PC> <A> <X> <Y> <SP> <DBR> <DP> <NVMXDIZC>",CHAR_CR
>1a7177	41 3e 20 3c 58 3e 20 3c 59 3e 20 3c 53 50 3e 20
>1a7187	3c 44 42 52 3e 20 3c 44 50 3e 20 3c 4e 56 4d 58
>1a7197	44 49 5a 43 3e 0d
>1a719d	20 20 43 68 61 6e 67 65		                .text "  Change the contents of the registers",CHAR_CR,CHAR_CR
>1a71a5	20 74 68 65 20 63 6f 6e 74 65 6e 74 73 20 6f 66
>1a71b5	20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d 0d
>1a71c5	53 20 20 20 20 20 53 41		                .text "S     SAVE         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," <start> <end>",CHAR_CR
>1a71cd	56 45 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>1a71dd	22 20 3c 73 74 61 72 74 3e 20 3c 65 6e 64 3e 0d
>1a71ed	54 20 3c 73 74 61 72 74		                .text "T <start> <end> <destination>",CHAR_CR
>1a71f5	3e 20 3c 65 6e 64 3e 20 3c 64 65 73 74 69 6e 61
>1a7205	74 69 6f 6e 3e 0d
>1a720b	20 20 54 72 61 6e 73 66		                .text "  Transfer (copy) data within memory",CHAR_CR,CHAR_CR
>1a7213	65 72 20 28 63 6f 70 79 29 20 64 61 74 61 20 77
>1a7223	69 74 68 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>1a7231	57 20 3c 62 79 74 65 3e		                .text "W <byte>",CHAR_CR
>1a7239	0d
>1a723a	20 20 53 65 74 20 74 68		                .text "  Set the register width flags for the disassembler",CHAR_CR,CHAR_CR
>1a7242	65 20 72 65 67 69 73 74 65 72 20 77 69 64 74 68
>1a7252	20 66 6c 61 67 73 20 66 6f 72 20 74 68 65 20 64
>1a7262	69 73 61 73 73 65 6d 62 6c 65 72 0d 0d
>1a726f	58 20 2d 20 52 65 74 75		                .text "X - Return to BASIC",CHAR_CR,CHAR_CR
>1a7277	72 6e 20 74 6f 20 42 41 53 49 43 0d 0d
>1a7284	3e 20 3c 73 74 61 72 74		                .text "> <start> <byte> [byte]...",CHAR_CR
>1a728c	3e 20 3c 62 79 74 65 3e 20 5b 62 79 74 65 5d 2e
>1a729c	2e 2e 0d
>1a729f	20 20 45 64 69 74 20 64		                .text "  Edit data in memory",CHAR_CR,CHAR_CR
>1a72a7	61 74 61 20 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>1a72b6	3f 20 2d 20 44 69 73 70		                .null "? - Display a short help screen",CHAR_CR,CHAR_CR
>1a72be	6c 61 79 20 61 20 73 68 6f 72 74 20 68 65 6c 70
>1a72ce	20 73 63 72 65 65 6e 0d 0d 00
.1a72d8					IMWIDTH
.1a72d8	08		php		                PHP
.1a72d9	08		php		            PHP
.1a72da	c2 20		rep #$20	            REP #$20
.1a72dc	48		pha		            PHA
.1a72dd	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a72e0	5b		tcd		            TCD
.1a72e1	68		pla		            PLA
.1a72e2	28		plp		            PLP
.1a72e3	e2 20		sep #$20	            SEP #$20
.1a72e5	a5 0d		lda $0855	                LDA MARG1
.1a72e7	85 4e		sta $0896	                STA MCPUSTAT
.1a72e9	28		plp		                PLP
.1a72ea	6b		rtl		                RTL
.1a72eb					IMREGISTERS
.1a72eb	20 cc 01	jsr $1a01cc	            JSR ENSURETEXT
.1a72ee	08		php		            PHP
.1a72ef	e2 20		sep #$20	            SEP #$20
.1a72f1	48		pha		            PHA
.1a72f2	a9 1a		lda #$1a	            LDA #`mregisters_msg
.1a72f4	48		pha		            PHA
.1a72f5	ab		plb		            PLB
.1a72f6	68		pla		            PLA
.1a72f7	28		plp		            PLP
.1a72f8	a2 d0 88	ldx #$88d0	                LDX #<>mregisters_msg
.1a72fb	20 b3 03	jsr $1a03b3	            JSR PRINTS
.1a72fe	e2 20		sep #$20	            SEP #$20
.1a7300	a9 3b		lda #$3b	                LDA #';'
.1a7302	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7305	a9 20		lda #$20	                LDA #' '
.1a7307	20 18 00	jsr $1a0018	            JSR PRINTC
.1a730a	c2 30		rep #$30	            REP #$30
.1a730c	08		php		            PHP
.1a730d	e2 20		sep #$20	            SEP #$20
.1a730f	48		pha		            PHA
.1a7310	a9 00		lda #$00	            LDA #$0
.1a7312	48		pha		            PHA
.1a7313	ab		plb		            PLB
.1a7314	68		pla		            PLA
.1a7315	28		plp		            PLP
.1a7316	a0 03 00	ldy #$0003	                LDY #3
.1a7319	a2 42 02	ldx #$0242	                LDX #CPUPC+2
.1a731c	20 36 03	jsr $1a0336	            JSR PRINTH
.1a731f	c2 20		rep #$20	            REP #$20
.1a7321	a9 20 00	lda #$0020	                LDA #' '
.1a7324	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7327	af 44 02 00	lda $000244	                LDA @lCPUA
.1a732b	20 c3 03	jsr $1a03c3	            JSR PRHEXW
.1a732e	a9 20 00	lda #$0020	                LDA #' '
.1a7331	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7334	af 46 02 00	lda $000246	                LDA @lCPUX
.1a7338	20 c3 03	jsr $1a03c3	            JSR PRHEXW
.1a733b	a9 20 00	lda #$0020	                LDA #' '
.1a733e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7341	af 48 02 00	lda $000248	                LDA @lCPUY
.1a7345	20 c3 03	jsr $1a03c3	            JSR PRHEXW
.1a7348	a9 20 00	lda #$0020	                LDA #' '
.1a734b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a734e	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK
.1a7352	20 c3 03	jsr $1a03c3	            JSR PRHEXW
.1a7355	a9 20 00	lda #$0020	                LDA #' '
.1a7358	20 18 00	jsr $1a0018	            JSR PRINTC
.1a735b	af 4e 02 00	lda $00024e	                LDA @lCPUDBR
.1a735f	20 dd 03	jsr $1a03dd	            JSR PRHEXB
.1a7362	a9 20 00	lda #$0020	                LDA #' '
.1a7365	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7368	a9 20 00	lda #$0020	                LDA #' '
.1a736b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a736e	af 4c 02 00	lda $00024c	                LDA @lCPUDP
.1a7372	20 c3 03	jsr $1a03c3	            JSR PRHEXW
.1a7375	a9 20 00	lda #$0020	                LDA #' '
.1a7378	20 18 00	jsr $1a0018	            JSR PRINTC
.1a737b	08		php		                PHP
.1a737c	e2 20		sep #$20	            SEP #$20
.1a737e	ad 4f 02	lda $024f	                LDA CPUFLAGS
.1a7381	22 e9 85 1a	jsl $1a85e9	                JSL MPRINTB
.1a7385	28		plp		                PLP
.1a7386	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a7389	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a738c	6b		rtl		                RTL
.1a738d					IMFILL
.1a738d	08		php		                PHP                 ; Save the caller's context
.1a738e	0b		phd		                PHD
.1a738f	08		php		            PHP
.1a7390	c2 20		rep #$20	            REP #$20
.1a7392	48		pha		            PHA
.1a7393	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7396	5b		tcd		            TCD
.1a7397	68		pla		            PLA
.1a7398	28		plp		            PLP
.1a7399					do_copy
.1a7399	e2 20		sep #$20	            SEP #$20
.1a739b	a5 15		lda $085d	                LDA MARG3
.1a739d	87 0d		sta [$0855]	                STA [MARG1]
.1a739f	e2 20		sep #$20	            SEP #$20
.1a73a1	a5 0f		lda $0857	                LDA MARG1+2
.1a73a3	c5 13		cmp $085b	                CMP MARG2+2
.1a73a5	d0 0e		bne $1a73b5	                BNE go_next         ; No: we haven't reached end address yet
.1a73a7	c2 20		rep #$20	            REP #$20
.1a73a9	a5 0d		lda $0855	                LDA MARG1
.1a73ab	c5 11		cmp $0859	                CMP MARG2           ; Are they equal?
.1a73ad	d0 06		bne $1a73b5	                BNE go_next         ; No: we haven't reached end address yet
.1a73af	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a73b2	2b		pld		                PLD                 ; Restore the caller's context
.1a73b3	28		plp		                PLP
.1a73b4	6b		rtl		                RTL
.1a73b5					go_next
.1a73b5	c2 20		rep #$20	            REP #$20
.1a73b7	18		clc		                CLC
.1a73b8	a5 0d		lda $0855	                LDA MARG1
.1a73ba	69 01 00	adc #$0001	                ADC #1
.1a73bd	85 0d		sta $0855	                STA MARG1
.1a73bf	e2 20		sep #$20	            SEP #$20
.1a73c1	a5 0e		lda $0856	                LDA MARG1+1
.1a73c3	69 00		adc #$00	                ADC #0
.1a73c5	85 0e		sta $0856	                STA MARG1+1
.1a73c7	80 d0		bra $1a7399	                BRA do_copy
.1a73c9					IMTRANSFER
.1a73c9	08		php		                PHP
.1a73ca	0b		phd		                PHD
.1a73cb	08		php		            PHP
.1a73cc	c2 20		rep #$20	            REP #$20
.1a73ce	48		pha		            PHA
.1a73cf	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a73d2	5b		tcd		            TCD
.1a73d3	68		pla		            PLA
.1a73d4	28		plp		            PLP
.1a73d5	e2 20		sep #$20	            SEP #$20
.1a73d7	a5 0f		lda $0857	                LDA MARG1+2
.1a73d9	c5 17		cmp $085f	                CMP MARG3+2
.1a73db	90 45		bcc $1a7422	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.1a73dd	c2 20		rep #$20	            REP #$20
.1a73df	a5 0d		lda $0855	                LDA MARG1
.1a73e1	c5 15		cmp $085d	                CMP MARG3
.1a73e3	90 3d		bcc $1a7422	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.1a73e5					copy_byte_down
.1a73e5	e2 20		sep #$20	            SEP #$20
.1a73e7	a7 0d		lda [$0855]	                LDA [MARG1]         ; Copy the byte
.1a73e9	87 15		sta [$085d]	                STA [MARG3]
.1a73eb	a5 0f		lda $0857	                LDA MARG1+2         ; Are the source's current and end bank bytes equal?
.1a73ed	c5 13		cmp $085b	                CMP MARG2+2
.1a73ef	d0 0b		bne $1a73fc	                BNE inc_pointers    ; No: we're not done yet
.1a73f1	c2 20		rep #$20	            REP #$20
.1a73f3	a5 0d		lda $0855	                LDA MARG1           ; Are the rest of the bits equal?
.1a73f5	c5 11		cmp $0859	                CMP MARG2
.1a73f7	d0 03		bne $1a73fc	                BNE inc_pointers    ; No: we're not done yet
.1a73f9	4c 80 74	jmp $1a7480	                JMP done            ; Yes: we've copied the last byte, exit
.1a73fc					inc_pointers
.1a73fc	c2 20		rep #$20	            REP #$20
.1a73fe	18		clc		                CLC
.1a73ff	a5 0d		lda $0855	                LDA MARG1
.1a7401	69 01 00	adc #$0001	                ADC #1
.1a7404	85 0d		sta $0855	                STA MARG1
.1a7406	e2 20		sep #$20	            SEP #$20
.1a7408	a5 0e		lda $0856	                LDA MARG1+1
.1a740a	69 00		adc #$00	                ADC #0
.1a740c	85 0e		sta $0856	                STA MARG1+1
.1a740e	c2 20		rep #$20	            REP #$20
.1a7410	18		clc		                CLC
.1a7411	a5 15		lda $085d	                LDA MARG3
.1a7413	69 01 00	adc #$0001	                ADC #1
.1a7416	85 15		sta $085d	                STA MARG3
.1a7418	e2 20		sep #$20	            SEP #$20
.1a741a	a5 16		lda $085e	                LDA MARG3+1
.1a741c	69 00		adc #$00	                ADC #0
.1a741e	85 16		sta $085e	                STA MARG3+1
.1a7420	80 c3		bra $1a73e5	                BRA copy_byte_down  ; And copy that next byte over
.1a7422					copy_up
.1a7422	c2 20		rep #$20	            REP #$20
.1a7424	38		sec		                SEC
.1a7425	a5 11		lda $0859	                LDA MARG2
.1a7427	e5 0d		sbc $0855	                SBC MARG1
.1a7429	85 19		sta $0861	                STA MARG4
.1a742b	e2 20		sep #$20	            SEP #$20
.1a742d	a5 13		lda $085b	                LDA MARG2+2
.1a742f	e5 0f		sbc $0857	                SBC MARG1+2
.1a7431	85 1b		sta $0863	                STA MARG4+2
.1a7433	c2 20		rep #$20	            REP #$20
.1a7435	18		clc		                CLC
.1a7436	a5 19		lda $0861	                LDA MARG4
.1a7438	65 15		adc $085d	                ADC MARG3
.1a743a	85 15		sta $085d	                STA MARG3
.1a743c	e2 20		sep #$20	            SEP #$20
.1a743e	a5 1b		lda $0863	                LDA MARG4+2
.1a7440	65 17		adc $085f	                ADC MARG3+2
.1a7442	85 17		sta $085f	                STA MARG3+2
.1a7444					copy_byte_up
.1a7444	e2 20		sep #$20	            SEP #$20
.1a7446	a7 11		lda [$0859]	                LDA [MARG2]
.1a7448	87 15		sta [$085d]	                STA [MARG3]
.1a744a	a5 13		lda $085b	                LDA MARG2+2         ; Are the source's current and start bank bytes equal?
.1a744c	c5 0f		cmp $0857	                CMP MARG1+2
.1a744e	d0 0a		bne $1a745a	                BNE dec_pointers    ; No: we're not done yet
.1a7450	c2 20		rep #$20	            REP #$20
.1a7452	a5 11		lda $0859	                LDA MARG2           ; Are the rest of the bits equal?
.1a7454	c5 0d		cmp $0855	                CMP MARG1
.1a7456	d0 02		bne $1a745a	                BNE dec_pointers    ; No: we're not done yet
.1a7458	80 26		bra $1a7480	                BRA done            ; Yes: we've copied the last byte, exit
.1a745a					dec_pointers
.1a745a	c2 20		rep #$20	            REP #$20
.1a745c	38		sec		                SEC
.1a745d	a5 11		lda $0859	                LDA MARG2
.1a745f	e9 01 00	sbc #$0001	                SBC #1
.1a7462	85 11		sta $0859	                STA MARG2
.1a7464	e2 20		sep #$20	            SEP #$20
.1a7466	a5 12		lda $085a	                LDA MARG2+1
.1a7468	e9 00		sbc #$00	                SBC #0
.1a746a	85 12		sta $085a	                STA MARG2+1
.1a746c	c2 20		rep #$20	            REP #$20
.1a746e	38		sec		                SEC                 ; Decrement the current destination pointer (MARG3)
.1a746f	a5 15		lda $085d	                LDA MARG3
.1a7471	e9 01 00	sbc #$0001	                SBC #1
.1a7474	85 15		sta $085d	                STA MARG3
.1a7476	e2 20		sep #$20	            SEP #$20
.1a7478	a5 16		lda $085e	                LDA MARG3+1
.1a747a	e9 00		sbc #$00	                SBC #0
.1a747c	85 16		sta $085e	                STA MARG3+1
.1a747e	80 c4		bra $1a7444	                BRA copy_byte_up    ; And copy that next byte
.1a7480					done
.1a7480	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a7483	2b		pld		                PLD
.1a7484	28		plp		                PLP
.1a7485	6b		rtl		                RTL
.1a7486					IS_PRINTABLE
.1a7486	08		php		                PHP
.1a7487	e2 20		sep #$20	            SEP #$20
.1a7489	c9 21		cmp #$21	                CMP #33
.1a748b	90 0b		bcc $1a7498	                BLT not_printable   ; 0 .. 31 are not printable
.1a748d	c9 7f		cmp #$7f	                CMP #127
.1a748f	90 04		bcc $1a7495	                BLT printable       ; 32 .. 126 are printable
.1a7491	c9 a0		cmp #$a0	                CMP #160
.1a7493	90 03		bcc $1a7498	                BLT not_printable   ; 127 .. 159 are not printable (assuming Latin-1)
.1a7495	28		plp		printable       PLP
.1a7496	38		sec		                SEC
.1a7497	6b		rtl		                RTL
.1a7498	28		plp		not_printable   PLP
.1a7499	18		clc		                CLC
.1a749a	6b		rtl		                RTL
=256					MMEMDUMPSIZE = 256  ; Default number of bytes to dump
=8					MMEMROWSIZE = 8    ; Number of bytes to dump per-row
.1a749b					IMMEMORY
.1a749b	08		php		                PHP
.1a749c	8b		phb		                PHB
.1a749d	0b		phd		                PHD
.1a749e	08		php		            PHP
.1a749f	c2 20		rep #$20	            REP #$20
.1a74a1	48		pha		            PHA
.1a74a2	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a74a5	5b		tcd		            TCD
.1a74a6	68		pla		            PLA
.1a74a7	28		plp		            PLP
.1a74a8	e2 20		sep #$20	            SEP #$20
.1a74aa	a9 00		lda #$00	                LDA #0              ; Clear the pagination line counter
.1a74ac	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT
.1a74b0	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.1a74b2	c9 02		cmp #$02	                CMP #2
.1a74b4	b0 16		bcs $1a74cc	                BGE set_cursor      ; 2>= arguments? Use them as-is
.1a74b6	c9 01		cmp #$01	                CMP #1
.1a74b8	90 20		bcc $1a74da	                BLT no_args         ; No arguments passed? Use defaults
.1a74ba	c2 20		rep #$20	            REP #$20
.1a74bc	18		clc		                CLC
.1a74bd	a5 0d		lda $0855	                LDA MARG1
.1a74bf	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a74c2	85 11		sta $0859	                STA MARG2
.1a74c4	e2 20		sep #$20	            SEP #$20
.1a74c6	a5 0f		lda $0857	                LDA MARG1+2
.1a74c8	69 00		adc #$00	                ADC #0
.1a74ca	85 13		sta $085b	                STA MARG2+2
.1a74cc					set_cursor
.1a74cc	c2 20		rep #$20	            REP #$20
.1a74ce	a5 0d		lda $0855	                LDA MARG1
.1a74d0	85 32		sta $087a	                STA MCURSOR
.1a74d2	e2 20		sep #$20	            SEP #$20
.1a74d4	a5 0f		lda $0857	                LDA MARG1+2
.1a74d6	85 34		sta $087c	                STA MCURSOR+2
.1a74d8	80 12		bra $1a74ec	                BRA dump_line
.1a74da					no_args
.1a74da	c2 20		rep #$20	            REP #$20
.1a74dc	18		clc		                CLC
.1a74dd	a5 32		lda $087a	                LDA MCURSOR
.1a74df	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a74e2	85 11		sta $0859	                STA MARG2
.1a74e4	e2 20		sep #$20	            SEP #$20
.1a74e6	a5 34		lda $087c	                LDA MCURSOR+2
.1a74e8	69 00		adc #$00	                ADC #0
.1a74ea	85 13		sta $085b	                STA MARG2+2
.1a74ec					dump_line
.1a74ec	e2 20		sep #$20	            SEP #$20
.1a74ee	a0 00 00	ldy #$0000	                LDY #0
.1a74f1	c2 20		rep #$20	            REP #$20
.1a74f3	a5 32		lda $087a	                LDA MCURSOR             ; NOTE: the use of MARG4 here is a temporary
.1a74f5	85 19		sta $0861	                STA MARG4               ; hack. the copy_loop instruction does not
.1a74f7	e2 20		sep #$20	            SEP #$20
.1a74f9	a5 34		lda $087c	                LDA MCURSOR+2
.1a74fb	85 1b		sta $0863	                STA MARG4+2
.1a74fd	e2 20		sep #$20	            SEP #$20
.1a74ff	a7 19		lda [$0861]	copy_loop       LDA [MARG4]             ; TODO: Should be LDA [MCURSOR],Y, which doesn't seem to be working
.1a7501	22 86 74 1a	jsl $1a7486	                JSL IS_PRINTABLE        ; Is it printable?
.1a7505	b0 02		bcs $1a7509	                BCS buffer_char         ; Yes: go ahead and add it to the line buffer
.1a7507	a9 3f		lda #$3f	                LDA #'?'                ; No: replace it with dot
.1a7509	99 7e 08	sta $087e,y	buffer_char     STA #MLINEBUF,B,Y
.1a750c	c2 20		rep #$20	            REP #$20
.1a750e	18		clc		                CLC
.1a750f	a5 19		lda $0861	                LDA MARG4
.1a7511	69 01 00	adc #$0001	                ADC #1
.1a7514	85 19		sta $0861	                STA MARG4
.1a7516	e2 20		sep #$20	            SEP #$20
.1a7518	a5 1b		lda $0863	                LDA MARG4+2
.1a751a	69 00		adc #$00	                ADC #0
.1a751c	85 1b		sta $0863	                STA MARG4+2
.1a751e	c8		iny		                INY
.1a751f	c0 08 00	cpy #$0008	                CPY #MMEMROWSIZE
.1a7522	90 db		bcc $1a74ff	                BLT copy_loop
.1a7524	a9 00		lda #$00	                LDA #0
.1a7526	99 7e 08	sta $087e,y	                STA #MLINEBUF,B,Y
.1a7529	a9 3e		lda #$3e	                LDA #'>'
.1a752b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a752e	a9 20		lda #$20	                LDA #' '
.1a7530	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7533	e2 20		sep #$20	            SEP #$20
.1a7535	a5 34		lda $087c	                LDA MCURSOR+2
.1a7537	20 dd 03	jsr $1a03dd	            JSR PRHEXB
.1a753a	a9 3a		lda #$3a	                LDA #':'                ; then a colon
.1a753c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a753f	c2 20		rep #$20	            REP #$20
.1a7541	a5 32		lda $087a	                LDA MCURSOR
.1a7543	20 c3 03	jsr $1a03c3	            JSR PRHEXW
.1a7546	c2 20		rep #$20	            REP #$20
.1a7548	a9 08 00	lda #$0008	                LDA #MMEMROWSIZE
.1a754b	85 47		sta $088f	                STA MCOUNT
.1a754d					prhex_loop
.1a754d	e2 20		sep #$20	            SEP #$20
.1a754f	a9 20		lda #$20	                LDA #' '
.1a7551	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7554	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a7556	20 dd 03	jsr $1a03dd	            JSR PRHEXB
.1a7559	22 c8 85 1a	jsl $1a85c8	                JSL M_INC_CURSOR        ; Point MCURSOR to the next byte
.1a755d					check_line
.1a755d	e2 20		sep #$20	            SEP #$20
.1a755f	c6 47		dec $088f	                DEC MCOUNT              ; Count down the number of bytes on the row
.1a7561	d0 ea		bne $1a754d	                BNE prhex_loop          ; If we're not at zero, keep looping over the bytes
.1a7563	a9 20		lda #$20	                LDA #' '
.1a7565	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7568	a9 20		lda #$20	                LDA #' '
.1a756a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a756d	08		php		            PHP
.1a756e	e2 20		sep #$20	            SEP #$20
.1a7570	48		pha		            PHA
.1a7571	a9 00		lda #$00	            LDA #`MLINEBUF
.1a7573	48		pha		            PHA
.1a7574	ab		plb		            PLB
.1a7575	68		pla		            PLA
.1a7576	28		plp		            PLP
.1a7577	a2 7e 08	ldx #$087e	                LDX #MLINEBUF
.1a757a	20 b3 03	jsr $1a03b3	            JSR PRINTS
.1a757d	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a7580	20 3d 03	jsr $1a033d	            JSR PAGINATE
.1a7583	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.1a7585	c5 13		cmp $085b	                CMP MARG2+2
.1a7587	90 0f		bcc $1a7598	                BLT continue            ; No: continue
.1a7589	c2 20		rep #$20	            REP #$20
.1a758b	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.1a758d	c5 11		cmp $0859	                CMP MARG2
.1a758f	90 07		bcc $1a7598	                BLT continue            ; Nope... keep going
.1a7591					done
.1a7591	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a7594	2b		pld		                PLD
.1a7595	ab		plb		                PLB
.1a7596	28		plp		                PLP
.1a7597	6b		rtl		                RTL
.1a7598	4c ec 74	jmp $1a74ec	continue        JMP dump_line
.1a759b					M_COPY_ARGB
.1a759b	08		php		                PHP
.1a759c	8d 92 08	sta $0892	                STA MTEMP
.1a759f	e2 20		sep #$20	            SEP #$20
.1a75a1	bd 00 00	lda $0000,x	loop            LDA #0,B,X
.1a75a4	99 00 00	sta $0000,y	                STA #0,B,Y      ; Copy the byte
.1a75a7	ad 92 08	lda $0892	                LDA MTEMP       ; Check the count of characters remaining
.1a75aa	f0 0a		beq $1a75b6	                BEQ done        ; If it's 0, we're done
.1a75ac	c8		iny		                INY             ; Point to the next destination byte
.1a75ad	e8		inx		                INX             ; Point to the next source byte (skip three bytes)
.1a75ae	e8		inx		                INX
.1a75af	e8		inx		                INX
.1a75b0	e8		inx		                INX
.1a75b1	ce 92 08	dec $0892	                DEC MTEMP       ; Count down and see if we're done
.1a75b4	80 eb		bra $1a75a1	                BRA loop
.1a75b6	28		plp		done            PLP
.1a75b7	6b		rtl		                RTL
.1a75b8					IMMODIFY
.1a75b8	08		php		                PHP
.1a75b9	0b		phd		                PHD
.1a75ba	8b		phb		                PHB
.1a75bb	08		php		            PHP
.1a75bc	c2 20		rep #$20	            REP #$20
.1a75be	48		pha		            PHA
.1a75bf	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a75c2	5b		tcd		            TCD
.1a75c3	68		pla		            PLA
.1a75c4	28		plp		            PLP
.1a75c5	08		php		            PHP
.1a75c6	e2 20		sep #$20	            SEP #$20
.1a75c8	48		pha		            PHA
.1a75c9	a9 00		lda #$00	            LDA #0
.1a75cb	48		pha		            PHA
.1a75cc	ab		plb		            PLB
.1a75cd	68		pla		            PLA
.1a75ce	28		plp		            PLP
.1a75cf	c2 30		rep #$30	            REP #$30
.1a75d1	a5 0d		lda $0855	                LDA MARG1           ; Set MCURSOR to MARG1
.1a75d3	85 32		sta $087a	                STA MCURSOR
.1a75d5	a5 0f		lda $0857	                LDA MARG1+2
.1a75d7	85 34		sta $087c	                STA MCURSOR+2
.1a75d9	e2 20		sep #$20	            SEP #$20
.1a75db	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.1a75dd	3a		dec a		                DEC A               ; (MARG_LEN - 1)
.1a75de	85 47		sta $088f	                STA MCOUNT
.1a75e0	a2 59 08	ldx #$0859	                LDX #<>MARG2        ; Copy MCOUNT bytes from MARG2..MARG9
.1a75e3	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF     ; to MLINEBUF
.1a75e6	22 9b 75 1a	jsl $1a759b	                JSL M_COPY_ARGB
.1a75ea	a0 00 00	ldy #$0000	                LDY #0
.1a75ed	b9 7e 08	lda $087e,y	loop            LDA MLINEBUF,Y      ; Copy the byte from the buffer
.1a75f0	87 32		sta [$087a]	                STA [MCURSOR]       ; To the address indicated by MCURSOR
.1a75f2	22 c8 85 1a	jsl $1a85c8	                JSL M_INC_CURSOR    ; Advance the cursor
.1a75f6	c8		iny		                INY                 ; Go to the next buffered byte
.1a75f7	c4 47		cpy $088f	                CPY MCOUNT          ; Did we just write the last one?
.1a75f9	d0 f2		bne $1a75ed	                BNE loop            ; No: continue writing
.1a75fb	ab		plb		                PLB
.1a75fc	2b		pld		                PLD
.1a75fd	28		plp		                PLP
.1a75fe	6b		rtl		                RTL
.1a75ff					IMHUNT
.1a75ff	08		php		                PHP
.1a7600	0b		phd		                PHD
.1a7601	8b		phb		                PHB
.1a7602	08		php		            PHP
.1a7603	c2 20		rep #$20	            REP #$20
.1a7605	48		pha		            PHA
.1a7606	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7609	5b		tcd		            TCD
.1a760a	68		pla		            PLA
.1a760b	28		plp		            PLP
.1a760c	08		php		            PHP
.1a760d	e2 20		sep #$20	            SEP #$20
.1a760f	48		pha		            PHA
.1a7610	a9 00		lda #$00	            LDA #0
.1a7612	48		pha		            PHA
.1a7613	ab		plb		            PLB
.1a7614	68		pla		            PLA
.1a7615	28		plp		            PLP
.1a7616	e2 20		sep #$20	            SEP #$20
.1a7618	c2 10		rep #$10	            REP #$10
.1a761a	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.1a761c	3a		dec a		                DEC A               ; (MARG_LEN - 2)
.1a761d	3a		dec a		                DEC A
.1a761e	85 47		sta $088f	                STA MCOUNT
.1a7620	a2 5d 08	ldx #$085d	                LDX #<>MARG3
.1a7623	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF
.1a7626	22 9b 75 1a	jsl $1a759b	                JSL M_COPY_ARGB
.1a762a	c2 20		rep #$20	            REP #$20
.1a762c	a5 0d		lda $0855	                LDA MARG1           ; Copy starting address to MCURSOR
.1a762e	85 32		sta $087a	                STA MCURSOR
.1a7630	a5 0f		lda $0857	                LDA MARG1+2
.1a7632	85 34		sta $087c	                STA MCURSOR+2
.1a7634					outer_loop
.1a7634	c2 20		rep #$20	            REP #$20
.1a7636	a5 34		lda $087c	                LDA MCURSOR+2      ; If MCURSOR < MARG2, we're not done yet
.1a7638	c5 13		cmp $085b	                CMP MARG2+2
.1a763a	d0 06		bne $1a7642	                BNE not_done
.1a763c	a5 32		lda $087a	                LDA MCURSOR
.1a763e	c5 11		cmp $0859	                CMP MARG2
.1a7640	f0 2c		beq $1a766e	                BEQ done            ; MCURSOR = MARG2: we're done
.1a7642					not_done
.1a7642	e2 20		sep #$20	            SEP #$20
.1a7644	a0 00 00	ldy #$0000	                LDY #0
.1a7647	b7 32		lda [$087a],y	cmp_loop        LDA [MCURSOR],Y     ; Get the byte from the memory to check
.1a7649	d9 7e 08	cmp $087e,y	                CMP MLINEBUF,Y      ; Compare it against our pattern
.1a764c	d0 1a		bne $1a7668	                BNE advance         ; If not equal, we need to move on
.1a764e	c8		iny		                INY                 ; Otherwise do we have more bytes to check?
.1a764f	c4 47		cpy $088f	                CPY MCOUNT
.1a7651	d0 f4		bne $1a7647	                BNE cmp_loop        ; No: check more
.1a7653	c2 20		rep #$20	            REP #$20
.1a7655	a5 32		lda $087a	                LDA MCURSOR         ; Print the address
.1a7657	85 4a		sta $0892	                STA MTEMP
.1a7659	a5 34		lda $087c	                LDA MCURSOR+2
.1a765b	85 4c		sta $0894	                STA MTEMP+2
.1a765d	22 72 80 1a	jsl $1a8072	                JSL M_PR_ADDR
.1a7661	e2 20		sep #$20	            SEP #$20
.1a7663	a9 20		lda #$20	                LDA #' '
.1a7665	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7668	22 c8 85 1a	jsl $1a85c8	advance         JSL M_INC_CURSOR    ; Move MCURSOR forward by one
.1a766c	80 c6		bra $1a7634	                BRA outer_loop      ; And try to compare that to the pattern
.1a766e					done
.1a766e	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a7671	ab		plb		                PLB
.1a7672	2b		pld		                PLD
.1a7673	28		plp		                PLP
.1a7674	6b		rtl		                RTL
.1a7675					IMJUMP
.1a7675	08		php		            PHP
.1a7676	c2 20		rep #$20	            REP #$20
.1a7678	48		pha		            PHA
.1a7679	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a767c	5b		tcd		            TCD
.1a767d	68		pla		            PLA
.1a767e	28		plp		            PLP
.1a767f	e2 20		sep #$20	            SEP #$20
.1a7681	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.1a7683	f0 0e		beq $1a7693	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.1a7685	c2 30		rep #$30	            REP #$30
.1a7687	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.1a7689	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.1a768d	a5 0f		lda $0857	                LDA MARG1+2
.1a768f	8f 42 02 00	sta $000242	                STA @lCPUPBR
.1a7693	af 46 02 00	lda $000246	MJUMPRESTORE    LDA @lCPUX          ; Restore X and Y
.1a7697	aa		tax		                TAX
.1a7698	af 48 02 00	lda $000248	                LDA @lCPUY
.1a769c	a8		tay		                TAY
.1a769d	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.1a76a1	1b		tcs		                TCS
.1a76a2	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.1a76a6	5b		tcd		                TCD
.1a76a7	e2 20		sep #$20	            SEP #$20
.1a76a9	a9 1a		lda #$1a	                LDA #`MJUMPSTART
.1a76ab	48		pha		                PHA
.1a76ac	a9 76		lda #$76	                LDA #>MJUMPSTART
.1a76ae	48		pha		                PHA
.1a76af	a9 b5		lda #$b5	                LDA #<MJUMPSTART
.1a76b1	48		pha		                PHA
.1a76b2	4c ec 76	jmp $1a76ec	                JMP MGOSTACK        ; And push remaining registers and restart execution
.1a76b5	ea		nop		MJUMPSTART      NOP                 ; RTL increments PC pulled from stack, NOP leaves space for that
.1a76b6	5c 04 00 1a	jmp $1a0004	                JML MONITOR
.1a76ba					IMGO
.1a76ba	08		php		            PHP
.1a76bb	c2 20		rep #$20	            REP #$20
.1a76bd	48		pha		            PHA
.1a76be	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a76c1	5b		tcd		            TCD
.1a76c2	68		pla		            PLA
.1a76c3	28		plp		            PLP
.1a76c4	e2 20		sep #$20	            SEP #$20
.1a76c6	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.1a76c8	f0 c9		beq $1a7693	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.1a76ca	c2 30		rep #$30	            REP #$30
.1a76cc	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.1a76ce	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.1a76d2	a5 0f		lda $0857	                LDA MARG1+2
.1a76d4	8f 42 02 00	sta $000242	                STA @lCPUPBR
.1a76d8	af 46 02 00	lda $000246	MGORESTORE      LDA @lCPUX          ; Restore X and Y
.1a76dc	aa		tax		                TAX
.1a76dd	af 48 02 00	lda $000248	                LDA @lCPUY
.1a76e1	a8		tay		                TAY
.1a76e2	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.1a76e6	1b		tcs		                TCS
.1a76e7	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.1a76eb	5b		tcd		                TCD
.1a76ec					MGOSTACK
.1a76ec	e2 20		sep #$20	            SEP #$20
.1a76ee	af 4e 02 00	lda $00024e	                LDA @lCPUDBR        ; Restore the data bank register
.1a76f2	48		pha		                PHA
.1a76f3	ab		plb		                PLB
.1a76f4	a9 5c		lda #$5c	                LDA #$5C            ; Save the JSL opcode
.1a76f6	8f a2 08 00	sta $0008a2	                STA @lMJUMPINST
.1a76fa	af 42 02 00	lda $000242	                LDA @lCPUPBR        ; Write PBR
.1a76fe	8f a5 08 00	sta $0008a5	                STA @lMJUMPADDR+2
.1a7702	af 41 02 00	lda $000241	                LDA @lCPUPC+1       ; Write PCH
.1a7706	8f a4 08 00	sta $0008a4	                STA @lMJUMPADDR+1
.1a770a	af 40 02 00	lda $000240	                LDA @lCPUPC         ; Write PCL
.1a770e	8f a3 08 00	sta $0008a3	                STA @lMJUMPADDR
.1a7712	af 4f 02 00	lda $00024f	                LDA @lCPUFLAGS      ; Push processor status
.1a7716	48		pha		                PHA
.1a7717	c2 20		rep #$20	            REP #$20
.1a7719	af 44 02 00	lda $000244	                LDA @lCPUA          ; Restore A
.1a771d	28		plp		                PLP                 ; And the status register
.1a771e	5c a2 08 00	jmp $0008a2	                JML MJUMPINST       ; And jump to the target address
.1a7722					IMCOMPARE
.1a7722	08		php		                PHP
.1a7723	0b		phd		                PHD
.1a7724	8b		phb		                PHB
.1a7725	08		php		            PHP
.1a7726	e2 20		sep #$20	            SEP #$20
.1a7728	48		pha		            PHA
.1a7729	a9 1a		lda #$1a	            LDA #`MERRARGS
.1a772b	48		pha		            PHA
.1a772c	ab		plb		            PLB
.1a772d	68		pla		            PLA
.1a772e	28		plp		            PLP
.1a772f	08		php		            PHP
.1a7730	c2 20		rep #$20	            REP #$20
.1a7732	48		pha		            PHA
.1a7733	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a7736	5b		tcd		            TCD
.1a7737	68		pla		            PLA
.1a7738	28		plp		            PLP
.1a7739	c2 10		rep #$10	            REP #$10
.1a773b	e2 20		sep #$20	            SEP #$20
.1a773d	a5 31		lda $0879	                LDA MARG_LEN                ; Check the number of arguments provided
.1a773f	c9 02		cmp #$02	                CMP #2
.1a7741	f0 0c		beq $1a774f	                BEQ default_len             ; If 2: set MCOUNT to default of 1
.1a7743	c9 03		cmp #$03	                CMP #3
.1a7745	d0 11		bne $1a7758	                BNE bad_arguments           ; Otherwise, if not 3: print an error
.1a7747	c2 20		rep #$20	            REP #$20
.1a7749	a5 15		lda $085d	                LDA MARG3                   ; If 3: set MCOUNT to MARG3
.1a774b	85 47		sta $088f	                STA MCOUNT
.1a774d	80 11		bra $1a7760	                BRA compare
.1a774f					default_len
.1a774f	c2 20		rep #$20	            REP #$20
.1a7751	a9 01 00	lda #$0001	                LDA #1                      ; No length was provided, set MCOUNT to 1
.1a7754	85 47		sta $088f	                STA MCOUNT
.1a7756	80 08		bra $1a7760	                BRA compare
.1a7758	a2 94 88	ldx #$8894	bad_arguments   LDX #<>MERRARGS             ; The wrong number of arguments was provided
.1a775b	20 b3 03	jsr $1a03b3	            JSR PRINTS
.1a775e	80 35		bra $1a7795	                BRA done
.1a7760	a5 0d		lda $0855	compare         LDA MARG1                   ; Set MTEMP to MARG1
.1a7762	85 4a		sta $0892	                STA MTEMP
.1a7764	a5 0f		lda $0857	                LDA MARG1+2
.1a7766	85 4c		sta $0894	                STA MTEMP+2
.1a7768	a0 00 00	ldy #$0000	                LDY #0
.1a776b					loop
.1a776b	e2 20		sep #$20	            SEP #$20
.1a776d	a7 4a		lda [$0892]	                LDA [MTEMP]                 ; Compare the byte at MTEMP
.1a776f	d7 11		cmp [$0859],y	                CMP [MARG2],Y               ; To the Yth byte from MARG2
.1a7771	f0 09		beq $1a777c	                BEQ continue                ; If they're the same, keep going
.1a7773	22 72 80 1a	jsl $1a8072	mismatch        JSL M_PR_ADDR               ; If they're different, print MTEMP
.1a7777	a9 20		lda #$20	                LDA #' '
.1a7779	20 18 00	jsr $1a0018	            JSR PRINTC
.1a777c					continue
.1a777c	c2 20		rep #$20	            REP #$20
.1a777e	18		clc		                CLC                         ; Either way, increment MTEMP
.1a777f	a5 4a		lda $0892	                LDA MTEMP
.1a7781	69 01 00	adc #$0001	                ADC #1
.1a7784	85 4a		sta $0892	                STA MTEMP
.1a7786	a5 4c		lda $0894	                LDA MTEMP+2
.1a7788	69 00 00	adc #$0000	                ADC #0
.1a778b	85 4c		sta $0894	                STA MTEMP+2
.1a778d	c8		iny		                INY                         ; Increment Y
.1a778e	c4 47		cpy $088f	                CPY MCOUNT                  ; Try again unless we've checked MCOUNT bytes
.1a7790	d0 d9		bne $1a776b	                BNE loop
.1a7792	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a7795					done
.1a7795	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a7798	ab		plb		                PLB
.1a7799	2b		pld		                PLD
.1a779a	28		plp		                PLP
.1a779b	6b		rtl		                RTL
.1a779c					IMRMODIFY
.1a779c	08		php		                PHP
.1a779d	0b		phd		                PHD
.1a779e	8b		phb		                PHB
.1a779f	08		php		            PHP
.1a77a0	e2 20		sep #$20	            SEP #$20
.1a77a2	48		pha		            PHA
.1a77a3	a9 00		lda #$00	            LDA #0
.1a77a5	48		pha		            PHA
.1a77a6	ab		plb		            PLB
.1a77a7	68		pla		            PLA
.1a77a8	28		plp		            PLP
.1a77a9	08		php		            PHP
.1a77aa	c2 20		rep #$20	            REP #$20
.1a77ac	48		pha		            PHA
.1a77ad	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a77b0	5b		tcd		            TCD
.1a77b1	68		pla		            PLA
.1a77b2	28		plp		            PLP
.1a77b3	e2 20		sep #$20	            SEP #$20
.1a77b5	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.1a77b7	f0 4f		beq $1a7808	                BEQ done            ; 0? Just quit
.1a77b9	a6 0d		ldx $0855	                LDX MARG1           ; Set the PC and PBR
.1a77bb	8e 40 02	stx $0240	                STX #CPUPC,B
.1a77be	a6 0f		ldx $0857	                LDX MARG1+2
.1a77c0	8e 42 02	stx $0242	                STX #CPUPBR,B
.1a77c3	c9 01		cmp #$01	                CMP #1              ; Check the number of arguments
.1a77c5	f0 41		beq $1a7808	                BEQ done            ; 1? Just quit
.1a77c7	a6 11		ldx $0859	                LDX MARG2           ; Set A
.1a77c9	8e 44 02	stx $0244	                STX #CPUA,B
.1a77cc	c9 02		cmp #$02	                CMP #2              ; Check the number of arguments
.1a77ce	f0 38		beq $1a7808	                BEQ done            ; 2? Just quit
.1a77d0	a6 15		ldx $085d	                LDX MARG3           ; Set X
.1a77d2	8e 46 02	stx $0246	                STX #CPUX,B
.1a77d5	c9 03		cmp #$03	                CMP #3              ; Check the number of arguments
.1a77d7	f0 2f		beq $1a7808	                BEQ done            ; 3? Just quit
.1a77d9	a6 19		ldx $0861	                LDX MARG4           ; Set Y
.1a77db	8e 48 02	stx $0248	                STX #CPUY,B
.1a77de	c9 04		cmp #$04	                CMP #4              ; Check the number of arguments
.1a77e0	f0 26		beq $1a7808	                BEQ done            ; 4? Just quit
.1a77e2	a6 1d		ldx $0865	                LDX MARG5           ; Set SP
.1a77e4	8e 4a 02	stx $024a	                STX #CPUSTACK,B
.1a77e7	c9 05		cmp #$05	                CMP #5              ; Check the number of arguments
.1a77e9	f0 1d		beq $1a7808	                BEQ done            ; 5? Just quit
.1a77eb	e2 10		sep #$10	            SEP #$10
.1a77ed	a6 21		ldx $0869	                LDX MARG6           ; Set DBR
.1a77ef	8e 4e 02	stx $024e	                STX #CPUDBR,B
.1a77f2	c9 06		cmp #$06	                CMP #6              ; Check the number of arguments
.1a77f4	f0 12		beq $1a7808	                BEQ done            ; 6? Just quit
.1a77f6	c2 10		rep #$10	            REP #$10
.1a77f8	a6 25		ldx $086d	                LDX MARG7           ; Set DP
.1a77fa	8e 4c 02	stx $024c	                STX #CPUDP,B
.1a77fd	c9 07		cmp #$07	                CMP #7              ; Check the number of arguments
.1a77ff	f0 07		beq $1a7808	                BEQ done            ; 7? Just quit
.1a7801	e2 10		sep #$10	            SEP #$10
.1a7803	a6 29		ldx $0871	                LDX MARG8           ; Set flags
.1a7805	8e 4f 02	stx $024f	                STX #CPUFLAGS,B
.1a7808	ab		plb		done            PLB
.1a7809	2b		pld		                PLD
.1a780a	28		plp		                PLP
.1a780b	6b		rtl		                RTL
.1a780c					IMEXECUTE
.1a780c	08		php		                PHP
.1a780d	0b		phd		                PHD
.1a780e	8b		phb		                PHB
.1a780f	08		php		            PHP
.1a7810	c2 20		rep #$20	            REP #$20
.1a7812	48		pha		            PHA
.1a7813	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7816	5b		tcd		            TCD
.1a7817	68		pla		            PLA
.1a7818	28		plp		            PLP
.1a7819	e2 20		sep #$20	            SEP #$20
.1a781b	c2 10		rep #$10	            REP #$10
.1a781d	a2 00 00	ldx #$0000	                LDX #0
.1a7820	bf 01 89 1a	lda $1a8901,x	loop            LDA @lMCOMMANDS,X
.1a7824	f0 18		beq $1a783e	                BEQ done
.1a7826	c7 08		cmp [$0850]	                CMP [MCMD]
.1a7828	f0 03		beq $1a782d	                BEQ found
.1a782a	e8		inx		                INX
.1a782b	80 f3		bra $1a7820	                BRA loop
.1a782d					found
.1a782d	c2 20		rep #$20	            REP #$20
.1a782f	8a		txa		                TXA
.1a7830	0a		asl a		                ASL A
.1a7831	aa		tax		                TAX
.1a7832	bf 42 78 1a	lda $1a7842,x	                LDA dispatch,X
.1a7836	8f 2f 08 00	sta $00082f	                STA @lJMP16PTR
.1a783a	22 66 78 1a	jsl $1a7866	                JSL MDOCMD
.1a783e	ab		plb		done            PLB
.1a783f	2b		pld		                PLD
.1a7840	28		plp		                PLP
.1a7841	6b		rtl		                RTL
>1a7842	e2 6e				dispatch        .word <>MASSEMBLE
>1a7844	ea 6e				                .word <>MCOMPARE
>1a7846	ee 6e				                .word <>MDISASSEMBLE
>1a7848	f2 6e				                .word <>MFILL
>1a784a	f6 6e				                .word <>MGO
>1a784c	fa 6e				                .word <>MJUMP
>1a784e	fe 6e				                .word <>MHUNT
>1a7850	02 6f				                .word <>MLOAD
>1a7852	06 6f				                .word <>MMEMORY
>1a7854	0a 6f				                .word <>MREGISTERS
>1a7856	e6 6e				                .word <>MRMODIFY
>1a7858	0e 6f				                .word <>MSAVE
>1a785a	12 6f				                .word <>MTRANSFER
>1a785c	16 6f				                .word <>MVERIFY
>1a785e	d8 72				                .word <>IMWIDTH
>1a7860	1a 6f				                .word <>MEXIT
>1a7862	1e 6f				                .word <>MMODIFY
>1a7864	51 6f				                .word <>IMHELP
.1a7866					MDOCMD
.1a7866	6c 2f 08	jmp ($082f)	                JMP (JMP16PTR)

;******  Processing file: src\assembler.s

=0					ADDR_DP_IND_X = 0       ; (dd,X)
=1					ADDR_DP = 1             ; dd
=2					ADDR_IMM = 2            ; #dd
=3					ADDR_ABS = 3            ; dddd
=4					ADDR_DP_IND_Y = 4       ; (dd),Y
=5					ADDR_DP_X = 5           ; dd,X
=6					ADDR_ABS_Y = 6          ; dddd,Y
=7					ADDR_ABS_X = 7          ; dddd,X
=8					ADDR_ACC = 8            ; A
=9					ADDR_SP_R = 9           ; #d,S
=10					ADDR_DP_LONG = 10       ; [dd]
=11					ADDR_ABS_LONG = 11      ; dddddd
=12					ADDR_SP_R_Y = 12        ; #dd,S,Y
=13					ADDR_DP_Y_LONG = 13     ; [dd],Y
=14					ADDR_ABS_X_LONG = 14    ; dddddd,X
=15					ADDR_DP_IND = 15        ; (dd)
=16					ADDR_ABS_X_ID = 16      ; (dddd,X)
=17					ADDR_DP_Y = 17          ; dd,Y
=18					ADDR_PC_REL = 18        ; PC relative
=19					ADDR_IMPLIED = 19       ; Implied (no operand)
=20					ADDR_XYC = 20           ; #dd, #dd
=21					ADDR_ABS_IND = 21       ; (dddd)
=22					ADDR_PC_REL_LONG = 22   ; PC relative ()
=23					ADDR_ABS_IND_LONG = 23  ; [dddd]
=$80					OP_M_EFFECT = $80       ; Flag to indicate instruction is modified by M
=$40					OP_X_EFFECT = $40       ; Flag to indicate instruction is modified by X
.1a7869					IMASSEMBLE
.1a7869	08		php		                PHP
.1a786a	8b		phb		                PHB
.1a786b	0b		phd		                PHD
.1a786c	08		php		            PHP
.1a786d	c2 20		rep #$20	            REP #$20
.1a786f	48		pha		            PHA
.1a7870	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7873	5b		tcd		            TCD
.1a7874	68		pla		            PLA
.1a7875	28		plp		            PLP
.1a7876	e2 20		sep #$20	            SEP #$20
.1a7878	a5 31		lda $0879	                LDA MARG_LEN            ; Do we have at least 2 arguments?
.1a787a	c9 02		cmp #$02	                CMP #2
.1a787c	b0 03		bcs $1a7881	                BGE has_args            ; Yes: try to assemble the line
.1a787e	4c 0f 7a	jmp $1a7a0f	                JMP done                ; No: just return
.1a7881					has_args
.1a7881	c2 20		rep #$20	            REP #$20
.1a7883	a5 0d		lda $0855	                LDA MARG1               ; Set the monitor cursor to the address
.1a7885	85 32		sta $087a	                STA MCURSOR
.1a7887	a5 0f		lda $0857	                LDA MARG1+2
.1a7889	85 34		sta $087c	                STA MCURSOR+2
.1a788b	c2 20		rep #$20	            REP #$20
.1a788d	22 11 7c 1a	jsl $1a7c11	                JSL AS_FIND_MNEMO       ; Find the address of the mnemonic
.1a7891	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a7894	f0 10		beq $1a78a6	                BEQ bad_mnemonic        ; If not found, print bad mnemonic error message
.1a7896	85 54		sta $089c	                STA MMNEMONIC
.1a7898	e2 20		sep #$20	            SEP #$20
.1a789a	a5 31		lda $0879	                LDA MARG_LEN            ; Check the number of arguments passed
.1a789c	c9 03		cmp #$03	                CMP #3                  ; Were all three arguments provided?
.1a789e	f0 36		beq $1a78d6	                BEQ get_operand         ; Yes: parse the operand
.1a78a0	a9 13		lda #$13	                LDA #ADDR_IMPLIED       ; No: assume address mode is implied
.1a78a2	85 4f		sta $0897	                STA MADDR_MODE
.1a78a4	80 4c		bra $1a78f2	                BRA get_opcode
.1a78a6					bad_mnemonic
.1a78a6	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a78a9	08		php		            PHP
.1a78aa	e2 20		sep #$20	            SEP #$20
.1a78ac	48		pha		            PHA
.1a78ad	a9 1a		lda #$1a	            LDA #`MERRBADMNEMO
.1a78af	48		pha		            PHA
.1a78b0	ab		plb		            PLB
.1a78b1	68		pla		            PLA
.1a78b2	28		plp		            PLP
.1a78b3	c2 10		rep #$10	            REP #$10
.1a78b5	a2 46 7a	ldx #$7a46	                LDX #<>MERRBADMNEMO
.1a78b8	20 b3 03	jsr $1a03b3	            JSR PRINTS
.1a78bb	4c 0f 7a	jmp $1a7a0f	                JMP done
.1a78be					bad_operand
.1a78be	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a78c1	08		php		            PHP
.1a78c2	e2 20		sep #$20	            SEP #$20
.1a78c4	48		pha		            PHA
.1a78c5	a9 1a		lda #$1a	            LDA #`MERRBADOPER
.1a78c7	48		pha		            PHA
.1a78c8	ab		plb		            PLB
.1a78c9	68		pla		            PLA
.1a78ca	28		plp		            PLP
.1a78cb	c2 10		rep #$10	            REP #$10
.1a78cd	a2 55 7a	ldx #$7a55	                LDX #<>MERRBADOPER
.1a78d0	20 b3 03	jsr $1a03b3	            JSR PRINTS
.1a78d3	4c 0f 7a	jmp $1a7a0f	                JMP done
.1a78d6					get_operand
.1a78d6	e2 20		sep #$20	            SEP #$20
.1a78d8	22 47 7c 1a	jsl $1a7c47	                JSL AS_FIND_MODE        ; Find the addressing mode of the operand
.1a78dc	c9 ff		cmp #$ff	compare         CMP #$FF
.1a78de	f0 de		beq $1a78be	                BEQ bad_operand         ; If not found, print bad operand error message
.1a78e0	85 4f		sta $0897	                STA MADDR_MODE
.1a78e2	c9 03		cmp #$03	                CMP #ADDR_ABS           ; If mode is absolute or absolute long...
.1a78e4	f0 62		beq $1a7948	                BEQ check_for_pcrel     ; Check to see if the mnemonic is one of the branches
.1a78e6	c9 0b		cmp #$0b	                CMP #ADDR_ABS_LONG
.1a78e8	f0 5e		beq $1a7948	                BEQ check_for_pcrel
.1a78ea	c9 13		cmp #$13	                CMP #ADDR_IMPLIED       ; If mode is implied or accumulator, get the opcode
.1a78ec	f0 04		beq $1a78f2	                BEQ get_opcode
.1a78ee	c9 08		cmp #$08	                CMP #ADDR_ACC
.1a78f0	f0 00		beq $1a78f2	                BEQ get_opcode
.1a78f2	22 3f 7b 1a	jsl $1a7b3f	get_opcode      JSL AS_FIND_OPCODE      ; Find the opcode matching the two
.1a78f6	b0 03		bcs $1a78fb	                BCS save_opcode
.1a78f8	4c d8 79	jmp $1a79d8	                JMP bad_mode            ; If opcode not found, print bad address mode error message
.1a78fb	87 32		sta [$087a]	save_opcode     STA [MCURSOR]           ; Write the opcode to the address
.1a78fd	22 c8 85 1a	jsl $1a85c8	                JSL M_INC_CURSOR        ; And point to the next byte
.1a7901	08		php		            PHP
.1a7902	e2 20		sep #$20	            SEP #$20
.1a7904	48		pha		            PHA
.1a7905	a9 00		lda #$00	            LDA #0
.1a7907	48		pha		            PHA
.1a7908	ab		plb		            PLB
.1a7909	68		pla		            PLA
.1a790a	28		plp		            PLP
.1a790b	c2 20		rep #$20	            REP #$20
.1a790d	a5 32		lda $087a	                LDA MCURSOR             ; Make MTEMPPTR a pointer to the machine code we're assembling
.1a790f	85 56		sta $089e	                STA MTEMPPTR
.1a7911	a5 34		lda $087c	                LDA MCURSOR+2
.1a7913	85 58		sta $08a0	                STA MTEMPPTR+2
.1a7915	e2 20		sep #$20	            SEP #$20
.1a7917	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check the address mode again
.1a7919	c9 12		cmp #$12	                CMP #ADDR_PC_REL        ; If it's PC relative
.1a791b	f0 6c		beq $1a7989	                BEQ compute_rel         ; Convert the address to an offset
.1a791d	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.1a791f	f0 68		beq $1a7989	                BEQ compute_rel
.1a7921	c9 14		cmp #$14	                CMP #ADDR_XYC           ; MVP/MVN addressing mode?
.1a7923	f0 7c		beq $1a79a1	                BEQ emit_2
.1a7925	29 3f		and #$3f	                AND #%00111111          ; Filter out the mode bits
.1a7927	c9 02		cmp #$02	                CMP #ADDR_IMM           ; Is it immediate?
.1a7929	d0 03		bne $1a792e	                BNE fixed_length        ; Yes: emit it as an immediate (variable length)
.1a792b	4c 06 7a	jmp $1a7a06	                JMP emit_imm
.1a792e					fixed_length
.1a792e	c2 20		rep #$20	            REP #$20
.1a7930	29 ff 00	and #$00ff	                AND #$00FF
.1a7933	aa		tax		                TAX
.1a7934	e2 20		sep #$20	            SEP #$20
.1a7936	bf 0e 85 1a	lda $1a850e,x	get_length      LDA ADDR_LENGTH,X       ; Get the number of bytes in the addressing mode
.1a793a	c9 03		cmp #$03	                CMP #$03
.1a793c	f0 57		beq $1a7995	                BEQ emit_3
.1a793e	c9 02		cmp #$02	                CMP #$02
.1a7940	f0 5f		beq $1a79a1	                BEQ emit_2
.1a7942	c9 01		cmp #$01	                CMP #$01
.1a7944	f0 67		beq $1a79ad	                BEQ emit_1
.1a7946	80 71		bra $1a79b9	                BRA next_line
.1a7948					check_for_pcrel
.1a7948	c2 20		rep #$20	            REP #$20
.1a794a	a5 54		lda $089c	                LDA MMNEMONIC
.1a794c	c9 86 81	cmp #$8186	                CMP #<>MN_BRA
.1a794f	f0 26		beq $1a7977	                BEQ is_pcrel
.1a7951	c9 ea 81	cmp #$81ea	                CMP #<>MN_BRL
.1a7954	f0 2a		beq $1a7980	                BEQ is_pcrel_long
.1a7956	c9 6a 81	cmp #$816a	                CMP #<>MN_BCC
.1a7959	f0 1c		beq $1a7977	                BEQ is_pcrel
.1a795b	c9 6e 81	cmp #$816e	                CMP #<>MN_BCS
.1a795e	f0 17		beq $1a7977	                BEQ is_pcrel
.1a7960	c9 76 81	cmp #$8176	                CMP #<>MN_BEQ
.1a7963	f0 12		beq $1a7977	                BEQ is_pcrel
.1a7965	c9 5e 81	cmp #$815e	                CMP #<>MN_BMI
.1a7968	f0 0d		beq $1a7977	                BEQ is_pcrel
.1a796a	c9 72 81	cmp #$8172	                CMP #<>MN_BNE
.1a796d	f0 08		beq $1a7977	                BEQ is_pcrel
.1a796f	c9 5a 81	cmp #$815a	                CMP #<>MN_BPL
.1a7972	f0 03		beq $1a7977	                BEQ is_pcrel
.1a7974	4c f2 78	jmp $1a78f2	                JMP get_opcode
.1a7977					is_pcrel
.1a7977	e2 20		sep #$20	            SEP #$20
.1a7979	a9 12		lda #$12	                LDA #ADDR_PC_REL
.1a797b	85 4f		sta $0897	                STA MADDR_MODE
.1a797d	4c f2 78	jmp $1a78f2	                JMP get_opcode
.1a7980					is_pcrel_long
.1a7980	e2 20		sep #$20	            SEP #$20
.1a7982	a9 16		lda #$16	                LDA #ADDR_PC_REL_LONG
.1a7984	85 4f		sta $0897	                STA MADDR_MODE
.1a7986	4c f2 78	jmp $1a78f2	                JMP get_opcode
.1a7989	22 82 7a 1a	jsl $1a7a82	compute_rel     JSL AS_PC_OFFSET        ; Try to compute the offset
.1a798d	90 60		bcc $1a79ef	                BCC bad_offset          ; If failed, it's a bad offset operand
.1a798f	c9 02		cmp #$02	emit_rel        CMP #$02                ; If the offset is two bytes
.1a7991	f0 0e		beq $1a79a1	                BEQ emit_2              ; Emit those two bytes
.1a7993	80 18		bra $1a79ad	                BRA emit_1              ; Otherwise emit just the one
.1a7995	a0 02 00	ldy #$0002	emit_3          LDY #2                  ; Write bank byte of operand
.1a7998	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.1a799b	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.1a799d	22 c8 85 1a	jsl $1a85c8	                JSL M_INC_CURSOR
.1a79a1	a0 01 00	ldy #$0001	emit_2          LDY #1                  ; Write high byte of operand
.1a79a4	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.1a79a7	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.1a79a9	22 c8 85 1a	jsl $1a85c8	                JSL M_INC_CURSOR
.1a79ad	a0 00 00	ldy #$0000	emit_1          LDY #0                  ; Write low byte of operand
.1a79b0	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.1a79b3	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.1a79b5	22 c8 85 1a	jsl $1a85c8	                JSL M_INC_CURSOR
.1a79b9					next_line
.1a79b9	e2 20		sep #$20	            SEP #$20
.1a79bb	a9 41		lda #$41	                LDA #'A'
.1a79bd	20 18 00	jsr $1a0018	            JSR PRINTC
.1a79c0	a9 20		lda #$20	                LDA #' '
.1a79c2	20 18 00	jsr $1a0018	            JSR PRINTC
.1a79c5	a6 32		ldx $087a	                LDX MCURSOR
.1a79c7	86 4a		stx $0892	                STX MTEMP
.1a79c9	a6 34		ldx $087c	                LDX MCURSOR+2
.1a79cb	86 4c		stx $0894	                STX MTEMP+2
.1a79cd	22 72 80 1a	jsl $1a8072	                JSL M_PR_ADDR
.1a79d1	a9 20		lda #$20	                LDA #' '
.1a79d3	20 18 00	jsr $1a0018	            JSR PRINTC
.1a79d6	80 37		bra $1a7a0f	                BRA done
.1a79d8					bad_mode
.1a79d8	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a79db	08		php		            PHP
.1a79dc	e2 20		sep #$20	            SEP #$20
.1a79de	48		pha		            PHA
.1a79df	a9 1a		lda #$1a	            LDA #`MERRBADMODE
.1a79e1	48		pha		            PHA
.1a79e2	ab		plb		            PLB
.1a79e3	68		pla		            PLA
.1a79e4	28		plp		            PLP
.1a79e5	c2 10		rep #$10	            REP #$10
.1a79e7	a2 13 7a	ldx #$7a13	                LDX #<>MERRBADMODE
.1a79ea	20 b3 03	jsr $1a03b3	            JSR PRINTS
.1a79ed	80 20		bra $1a7a0f	                BRA done
.1a79ef					bad_offset
.1a79ef	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a79f2	08		php		            PHP
.1a79f3	e2 20		sep #$20	            SEP #$20
.1a79f5	48		pha		            PHA
.1a79f6	a9 1a		lda #$1a	            LDA #`MERRBADOFFSET
.1a79f8	48		pha		            PHA
.1a79f9	ab		plb		            PLB
.1a79fa	68		pla		            PLA
.1a79fb	28		plp		            PLP
.1a79fc	c2 10		rep #$10	            REP #$10
.1a79fe	a2 63 7a	ldx #$7a63	                LDX #<>MERRBADOFFSET
.1a7a01	20 b3 03	jsr $1a03b3	            JSR PRINTS
.1a7a04	80 09		bra $1a7a0f	                BRA done
.1a7a06	a5 4f		lda $0897	emit_imm        LDA MADDR_MODE          ; Check to see if long immediate was used
.1a7a08	29 c0		and #$c0	                AND #%11000000
.1a7a0a	d0 95		bne $1a79a1	                BNE emit_2              ; Yes: emit two bytes
.1a7a0c	4c ad 79	jmp $1a79ad	                JMP emit_1              ; No: emit one byte
.1a7a0f	2b		pld		done            PLD
.1a7a10	ab		plb		                PLB
.1a7a11	28		plp		                PLP
.1a7a12	6b		rtl		                RTL
>1a7a13	41 64 64 72 65 73 73 69		MERRBADMODE     .null "Addressing mode not defined for that instruction.",CHAR_CR
>1a7a1b	6e 67 20 6d 6f 64 65 20 6e 6f 74 20 64 65 66 69
>1a7a2b	6e 65 64 20 66 6f 72 20 74 68 61 74 20 69 6e 73
>1a7a3b	74 72 75 63 74 69 6f 6e 2e 0d 00
>1a7a46	42 61 64 20 6d 6e 65 6d		MERRBADMNEMO    .null "Bad mnemonic.",CHAR_CR
>1a7a4e	6f 6e 69 63 2e 0d 00
>1a7a55	42 61 64 20 6f 70 65 72		MERRBADOPER     .null "Bad operand.",CHAR_CR
>1a7a5d	61 6e 64 2e 0d 00
>1a7a63	52 65 6c 61 74 69 76 65		MERRBADOFFSET   .null "Relative offset is too large.",CHAR_CR
>1a7a6b	20 6f 66 66 73 65 74 20 69 73 20 74 6f 6f 20 6c
>1a7a7b	61 72 67 65 2e 0d 00
.1a7a82					AS_PC_OFFSET
.1a7a82	08		php		                PHP
.1a7a83	0b		phd		                PHD
.1a7a84	08		php		            PHP
.1a7a85	c2 20		rep #$20	            REP #$20
.1a7a87	48		pha		            PHA
.1a7a88	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7a8b	5b		tcd		            TCD
.1a7a8c	68		pla		            PLA
.1a7a8d	28		plp		            PLP
.1a7a8e	e2 20		sep #$20	            SEP #$20
.1a7a90	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check to see if it 1 byte or 2 byte relative
.1a7a92	c9 12		cmp #$12	                CMP #ADDR_PC_REL
.1a7a94	f0 0a		beq $1a7aa0	                BEQ is_short
.1a7a96	c2 20		rep #$20	            REP #$20
.1a7a98	18		clc		                CLC                     ; Branch is long. Compute where MCURSOR will be
.1a7a99	a5 32		lda $087a	                LDA MCURSOR             ; with two branch offset bytes
.1a7a9b	69 02 00	adc #$0002	                ADC #2
.1a7a9e	80 08		bra $1a7aa8	                BRA compute_cursor
.1a7aa0					is_short
.1a7aa0	c2 20		rep #$20	            REP #$20
.1a7aa2	18		clc		                CLC                     ; Branch is short. Computer where MCURSOR will be
.1a7aa3	a5 32		lda $087a	                LDA MCURSOR             ; with one branch offset byte
.1a7aa5	69 01 00	adc #$0001	                ADC #1
.1a7aa8	85 4a		sta $0892	compute_cursor  STA MTEMP
.1a7aaa	a5 34		lda $087c	                LDA MCURSOR+2
.1a7aac	69 00 00	adc #$0000	                ADC #0
.1a7aaf	85 4c		sta $0894	                STA MTEMP+2
.1a7ab1	38		sec		                SEC                     ; MPARSEDNUM = MPARSEDNUM - MTEMP (MCURSOR after the instruction)
.1a7ab2	a5 50		lda $0898	                LDA MPARSEDNUM
.1a7ab4	e5 4a		sbc $0892	                SBC MTEMP
.1a7ab6	85 50		sta $0898	                STA MPARSEDNUM
.1a7ab8	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a7aba	e5 4c		sbc $0894	                SBC MTEMP+2
.1a7abc	85 52		sta $089a	                STA MPARSEDNUM+2
.1a7abe	e2 20		sep #$20	            SEP #$20
.1a7ac0	a5 4f		lda $0897	                LDA MADDR_MODE
.1a7ac2	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.1a7ac4	f0 1e		beq $1a7ae4	                BEQ check_long
.1a7ac6	a5 50		lda $0898	                LDA MPARSEDNUM          ; Short offset... check if it's negative
.1a7ac8	30 0c		bmi $1a7ad6	                BMI check_short_neg
.1a7aca	a5 51		lda $0899	                LDA MPARSEDNUM+1        ; Positive short offset... upper two bytes
.1a7acc	d0 2a		bne $1a7af8	                BNE failure             ; Must be 0 or it's an overflow
.1a7ace	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a7ad0	d0 26		bne $1a7af8	                BNE failure
.1a7ad2	a9 01		lda #$01	                LDA #1                  ; Short offset is 1 byte
.1a7ad4	80 26		bra $1a7afc	                BRA success
.1a7ad6	a5 51		lda $0899	check_short_neg LDA MPARSEDNUM+1        ; Negative short offset... upper two bytes
.1a7ad8	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's an  overflow
.1a7ada	d0 1c		bne $1a7af8	                BNE failure
.1a7adc	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a7ade	c9 ff		cmp #$ff	                CMP #$FF
.1a7ae0	d0 16		bne $1a7af8	                BNE failure
.1a7ae2	80 18		bra $1a7afc	                BRA success
.1a7ae4	a5 51		lda $0899	check_long      LDA MPARSEDNUM+1        ; Long offset... check if it's negative
.1a7ae6	30 06		bmi $1a7aee	                BMI check_long_neg
.1a7ae8	a5 52		lda $089a	                LDA MPARSEDNUM+2        ; Positive long offset... upper byte
.1a7aea	d0 0c		bne $1a7af8	                BNE failure             ; Must be 0 or it's an overflow
.1a7aec	80 0e		bra $1a7afc	                BRA success
.1a7aee	a5 52		lda $089a	check_long_neg  LDA MPARSEDNUM+2        ; Negative offset... upper two bytes
.1a7af0	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's and overflow
.1a7af2	d0 04		bne $1a7af8	                BNE failure
.1a7af4	a9 02		lda #$02	                LDA #2                  ; Long offset is 2 bytes
.1a7af6	80 04		bra $1a7afc	                BRA success
.1a7af8	2b		pld		failure         PLD
.1a7af9	28		plp		                PLP
.1a7afa	18		clc		                CLC
.1a7afb	6b		rtl		                RTL
.1a7afc	2b		pld		success         PLD
.1a7afd	28		plp		                PLP
.1a7afe	38		sec		                SEC
.1a7aff	6b		rtl		                RTL
.1a7b00					AS_SHIFT_HEX
.1a7b00	08		php		                PHP
.1a7b01	0b		phd		                PHD
.1a7b02	c2 10		rep #$10	            REP #$10
.1a7b04	da		phx		                PHX
.1a7b05	08		php		            PHP
.1a7b06	c2 20		rep #$20	            REP #$20
.1a7b08	48		pha		            PHA
.1a7b09	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7b0c	5b		tcd		            TCD
.1a7b0d	68		pla		            PLA
.1a7b0e	28		plp		            PLP
.1a7b0f	e2 20		sep #$20	            SEP #$20
.1a7b11	a2 00 00	ldx #$0000	                LDX #0
.1a7b14	df 00 d0 1a	cmp $1ad000,x	seek_loop       CMP @lHEXDIGITS,X   ; Check the passed character against the hex digits
.1a7b18	f0 08		beq $1a7b22	                BEQ found
.1a7b1a	e8		inx		                INX                 ; Go to the next hex digit
.1a7b1b	e0 10 00	cpx #$0010	                CPX #$10            ; Are we out of digits?
.1a7b1e	f0 1b		beq $1a7b3b	                BEQ done            ; Yes... just return
.1a7b20	80 f2		bra $1a7b14	                BRA seek_loop
.1a7b22					found
.1a7b22	c2 20		rep #$20	            REP #$20
.1a7b24	06 50		asl $0898	                ASL MPARSEDNUM
.1a7b26	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7b28	06 50		asl $0898	                ASL MPARSEDNUM
.1a7b2a	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7b2c	06 50		asl $0898	                ASL MPARSEDNUM
.1a7b2e	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7b30	06 50		asl $0898	                ASL MPARSEDNUM
.1a7b32	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7b34	e2 20		sep #$20	            SEP #$20
.1a7b36	8a		txa		                TXA
.1a7b37	05 50		ora $0898	                ORA MPARSEDNUM
.1a7b39	85 50		sta $0898	                STA MPARSEDNUM
.1a7b3b	fa		plx		done            PLX
.1a7b3c	2b		pld		                PLD
.1a7b3d	28		plp		                PLP
.1a7b3e	6b		rtl		                RTL
.1a7b3f					AS_FIND_OPCODE
.1a7b3f	0b		phd		                PHD
.1a7b40	8b		phb		                PHB
.1a7b41	08		php		            PHP
.1a7b42	c2 20		rep #$20	            REP #$20
.1a7b44	48		pha		            PHA
.1a7b45	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7b48	5b		tcd		            TCD
.1a7b49	68		pla		            PLA
.1a7b4a	28		plp		            PLP
.1a7b4b	08		php		            PHP
.1a7b4c	e2 20		sep #$20	            SEP #$20
.1a7b4e	48		pha		            PHA
.1a7b4f	a9 1a		lda #$1a	            LDA #`MNEMONIC_TAB
.1a7b51	48		pha		            PHA
.1a7b52	ab		plb		            PLB
.1a7b53	68		pla		            PLA
.1a7b54	28		plp		            PLP
.1a7b55	e2 20		sep #$20	            SEP #$20
.1a7b57	a5 4f		lda $0897	                LDA MADDR_MODE
.1a7b59	29 3f		and #$3f	                AND #%00111111
.1a7b5b	85 4a		sta $0892	                STA MTEMP
.1a7b5d	c2 30		rep #$30	            REP #$30
.1a7b5f	a2 00 00	ldx #$0000	                LDX #0
.1a7b62	a0 00 00	ldy #$0000	                LDY #0
.1a7b65	bd 0c 82	lda $1a820c,x	mnemonic_loop   LDA MNEMONIC_TAB,X      ; Get the mnemonic from the opcode table
.1a7b68	f0 1b		beq $1a7b85	                BEQ not_found           ; If it's 0, we did not find the mnemonic
.1a7b6a	c5 54		cmp $089c	                CMP MMNEMONIC           ; Does it match the passed mnemonic?
.1a7b6c	d0 0d		bne $1a7b7b	                BNE next_opcode         ; No: go to the next opcode
.1a7b6e					check_mode
.1a7b6e	e2 20		sep #$20	            SEP #$20
.1a7b70	b9 0e 84	lda $1a840e,y	                LDA ADDRESS_TAB,Y       ; Get the corresponding address mode
.1a7b73	29 3f		and #$3f	                AND #%00111111          ; Filter out effect bits
.1a7b75	c5 4a		cmp $0892	                CMP MTEMP
.1a7b77	f0 07		beq $1a7b80	                BEQ found               ; Yes: we found the opcode
.1a7b79	c2 20		rep #$20	            REP #$20
.1a7b7b	e8		inx		next_opcode     INX                     ; Point to the next mnemonic in the table
.1a7b7c	e8		inx		                INX
.1a7b7d	c8		iny		                INY
.1a7b7e	80 e5		bra $1a7b65	                BRA mnemonic_loop       ; And check it
.1a7b80	98		tya		found           TYA
.1a7b81	38		sec		                SEC                     ; Set carry to show success
.1a7b82	ab		plb		                PLB
.1a7b83	2b		pld		                PLD
.1a7b84	6b		rtl		                RTL
.1a7b85	18		clc		not_found       CLC                     ; Clear carry to show failure
.1a7b86	ab		plb		                PLB
.1a7b87	2b		pld		                PLD
.1a7b88	6b		rtl		                RTL
.1a7b89					AS_STR_MATCH
.1a7b89	08		php		                PHP
.1a7b8a	0b		phd		                PHD
.1a7b8b	08		php		            PHP
.1a7b8c	c2 20		rep #$20	            REP #$20
.1a7b8e	48		pha		            PHA
.1a7b8f	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7b92	5b		tcd		            TCD
.1a7b93	68		pla		            PLA
.1a7b94	28		plp		            PLP
.1a7b95	e2 20		sep #$20	            SEP #$20
.1a7b97	c2 10		rep #$10	            REP #$10
.1a7b99	a0 00 00	ldy #$0000	                LDY #0
.1a7b9c	64 50		stz $0898	                STZ MPARSEDNUM      ; Set parsed number to 0 in anticipation of
.1a7b9e	64 52		stz $089a	                STZ MPARSEDNUM+2    ; hex digits in the pattern
.1a7ba0	b7 03		lda [$084b],y	match_loop      LDA [MCMP_TEXT],Y   ; Get the pattern character
.1a7ba2	f0 11		beq $1a7bb5	                BEQ nul_check       ; If at end of pattern, check for end of test string
.1a7ba4	c9 64		cmp #$64	                CMP #'d'            ; Is it a digit?
.1a7ba6	f0 19		beq $1a7bc1	                BEQ check_digit     ; Yes: do special check for hex digit
.1a7ba8	48		pha		compare         PHA
.1a7ba9	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.1a7bab	85 4a		sta $0892	                STA MTEMP
.1a7bad	68		pla		                PLA
.1a7bae	c5 4a		cmp $0892	                CMP MTEMP           ; Does it match the character to test?
.1a7bb0	d0 0b		bne $1a7bbd	                BNE return_false    ; No: return fail
.1a7bb2	c8		iny		next_char       INY                 ; Yes: test the next character
.1a7bb3	80 eb		bra $1a7ba0	                BRA match_loop
.1a7bb5	b7 36		lda [$087e],y	nul_check       LDA [MLINEBUF],Y    ; Check to see that we're at the end of the test string
.1a7bb7	d0 04		bne $1a7bbd	                BNE return_false    ; If not: return false
.1a7bb9	2b		pld		return_true     PLD
.1a7bba	28		plp		                PLP                 ; Return true
.1a7bbb	38		sec		                SEC
.1a7bbc	6b		rtl		                RTL
.1a7bbd	2b		pld		return_false    PLD
.1a7bbe	28		plp		                PLP                 ; Return false
.1a7bbf	18		clc		                CLC
.1a7bc0	6b		rtl		                RTL
.1a7bc1					check_digit
.1a7bc1	e2 20		sep #$20	            SEP #$20
.1a7bc3	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.1a7bc5	c9 3a		cmp #$3a	                CMP #'9'+1
.1a7bc7	b0 04		bcs $1a7bcd	                BCS check_AF
.1a7bc9	c9 30		cmp #$30	                CMP #'0'
.1a7bcb	b0 14		bcs $1a7be1	                BCS shift_digit     ; character is in [0..9]
.1a7bcd	c9 47		cmp #$47	check_AF        CMP #'F'+1
.1a7bcf	b0 04		bcs $1a7bd5	                BCS check_lc        ; check lower case
.1a7bd1	c9 41		cmp #$41	                CMP #'A'
.1a7bd3	b0 0c		bcs $1a7be1	                BCS shift_digit     ; character is in [A..F]
.1a7bd5	c9 67		cmp #$67	check_lc        CMP #'f'+1
.1a7bd7	b0 e4		bcs $1a7bbd	                BCS return_false    ; check lower case
.1a7bd9	c9 61		cmp #$61	                CMP #'a'
.1a7bdb	b0 02		bcs $1a7bdf	                BCS to_upcase       ; character is in [A..F]
.1a7bdd	80 de		bra $1a7bbd	                BRA return_false    ; No match found... return false
.1a7bdf	29 df		and #$df	to_upcase       AND #%11011111      ; Convert lower case to upper case
.1a7be1	22 00 7b 1a	jsl $1a7b00	shift_digit     JSL AS_SHIFT_HEX    ; Shift the digit into MPARSEDNUM
.1a7be5	80 cb		bra $1a7bb2	                BRA next_char       ; And check the next character
.1a7be7					AS_MCMP_NEXT
.1a7be7	0b		phd		                PHD
.1a7be8	08		php		            PHP
.1a7be9	c2 20		rep #$20	            REP #$20
.1a7beb	48		pha		            PHA
.1a7bec	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7bef	5b		tcd		            TCD
.1a7bf0	68		pla		            PLA
.1a7bf1	28		plp		            PLP
.1a7bf2	a0 00 00	ldy #$0000	                LDY #0
.1a7bf5	e2 20		sep #$20	            SEP #$20
.1a7bf7	b7 03		lda [$084b],y	loop            LDA [MCMP_TEXT],Y   ; Check to see if we have gotten to the NUL
.1a7bf9	f0 03		beq $1a7bfe	                BEQ found_nul
.1a7bfb	c8		iny		                INY
.1a7bfc	80 f9		bra $1a7bf7	                BRA loop
.1a7bfe					found_nul
.1a7bfe	c2 20		rep #$20	            REP #$20
.1a7c00	c8		iny		                INY                 ; Got to NUL... point to next byte
.1a7c01	5a		phy		                PHY
.1a7c02	68		pla		                PLA                 ; And add that index to MCMP_TEXT pointer
.1a7c03	18		clc		                CLC
.1a7c04	65 03		adc $084b	                ADC MCMP_TEXT
.1a7c06	85 03		sta $084b	                STA MCMP_TEXT
.1a7c08	a5 05		lda $084d	                LDA MCMP_TEXT+2
.1a7c0a	69 00 00	adc #$0000	                ADC #0
.1a7c0d	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7c0f	2b		pld		                PLD
.1a7c10	6b		rtl		                RTL
.1a7c11					AS_FIND_MNEMO
.1a7c11	0b		phd		                PHD
.1a7c12	08		php		            PHP
.1a7c13	c2 20		rep #$20	            REP #$20
.1a7c15	48		pha		            PHA
.1a7c16	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7c19	5b		tcd		            TCD
.1a7c1a	68		pla		            PLA
.1a7c1b	28		plp		            PLP
.1a7c1c	c2 20		rep #$20	            REP #$20
.1a7c1e	a5 11		lda $0859	                LDA MARG2                   ; Point MLINEBUF to the text
.1a7c20	85 36		sta $087e	                STA MLINEBUF
.1a7c22	a5 13		lda $085b	                LDA MARG2+2
.1a7c24	85 38		sta $0880	                STA MLINEBUF+2
.1a7c26	a9 9a 80	lda #$809a	                LDA #<>MNEMONICS_TAB        ; Point to the first mnemonic
.1a7c29	85 03		sta $084b	                STA MCMP_TEXT
.1a7c2b	a9 1a 00	lda #$001a	                LDA #`MNEMONICS_TAB
.1a7c2e	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7c30	22 89 7b 1a	jsl $1a7b89	match_loop      JSL AS_STR_MATCH            ; Check to see if the text matches the mnemonic
.1a7c34	b0 0d		bcs $1a7c43	                BCS found_mnemonic          ; If so: return that we found it
.1a7c36	22 e7 7b 1a	jsl $1a7be7	                JSL AS_MCMP_NEXT            ; Point to the next mnemonic
.1a7c3a	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Check to see if it's NUL
.1a7c3c	d0 f2		bne $1a7c30	                BNE match_loop              ; If not, check this next mnemonic
.1a7c3e	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Otherwise, return -1
.1a7c41	80 02		bra $1a7c45	                BRA done
.1a7c43	a5 03		lda $084b	found_mnemonic  LDA MCMP_TEXT               ; Found it: return the address
.1a7c45	2b		pld		done            PLD
.1a7c46	6b		rtl		                RTL
.1a7c47					AS_FIND_MODE
.1a7c47	08		php		                PHP
.1a7c48	0b		phd		                PHD
.1a7c49	08		php		            PHP
.1a7c4a	c2 20		rep #$20	            REP #$20
.1a7c4c	48		pha		            PHA
.1a7c4d	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7c50	5b		tcd		            TCD
.1a7c51	68		pla		            PLA
.1a7c52	28		plp		            PLP
.1a7c53	c2 30		rep #$30	            REP #$30
.1a7c55	a5 15		lda $085d	                LDA MARG3                   ; Point MLINEBUF to the operand
.1a7c57	85 36		sta $087e	                STA MLINEBUF
.1a7c59	a5 17		lda $085f	                LDA MARG3+2
.1a7c5b	85 38		sta $0880	                STA MLINEBUF+2
.1a7c5d	a9 26 85	lda #$8526	                LDA #<>ADDR_PATTERNS        ; Point to the first address mode pattern to check
.1a7c60	85 03		sta $084b	                STA MCMP_TEXT
.1a7c62	a9 1a 00	lda #$001a	                LDA #`ADDR_PATTERNS
.1a7c65	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7c67	22 89 7b 1a	jsl $1a7b89	match_loop      JSL AS_STR_MATCH            ; Check to see if the pattern matches the operand
.1a7c6b	b0 22		bcs $1a7c8f	                BCS is_match                ; Yes: Find address mode code
.1a7c6d	22 e7 7b 1a	jsl $1a7be7	                JSL AS_MCMP_NEXT            ; Point to the address mode
.1a7c71	c2 20		rep #$20	            REP #$20
.1a7c73	18		clc		                CLC                         ; Point to the first byte of the next pattern
.1a7c74	a5 03		lda $084b	                LDA MCMP_TEXT
.1a7c76	69 01 00	adc #$0001	                ADC #1
.1a7c79	85 03		sta $084b	                STA MCMP_TEXT
.1a7c7b	a5 05		lda $084d	                LDA MCMP_TEXT+2
.1a7c7d	69 00 00	adc #$0000	                ADC #0
.1a7c80	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7c82	e2 20		sep #$20	            SEP #$20
.1a7c84	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Is the first byte 0?
.1a7c86	d0 df		bne $1a7c67	                BNE match_loop              ; No: check this next pattern
.1a7c88	c2 20		rep #$20	            REP #$20
.1a7c8a	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Yes: we didn't find a matching pattern, return -1
.1a7c8d	80 0d		bra $1a7c9c	                BRA done
.1a7c8f	22 e7 7b 1a	jsl $1a7be7	is_match        JSL AS_MCMP_NEXT            ; Point to the address mode
.1a7c93	e2 20		sep #$20	            SEP #$20
.1a7c95	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Get the corresponding address mode code (a byte)
.1a7c97	c2 20		rep #$20	            REP #$20
.1a7c99	29 ff 00	and #$00ff	                AND #$00FF
.1a7c9c	2b		pld		done            PLD
.1a7c9d	28		plp		                PLP
.1a7c9e	6b		rtl		                RTL
.1a7c9f					IMDISASSEMBLE
.1a7c9f	08		php		                PHP
.1a7ca0	8b		phb		                PHB
.1a7ca1	0b		phd		                PHD
.1a7ca2	08		php		            PHP
.1a7ca3	c2 20		rep #$20	            REP #$20
.1a7ca5	48		pha		            PHA
.1a7ca6	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7ca9	5b		tcd		            TCD
.1a7caa	68		pla		            PLA
.1a7cab	28		plp		            PLP
.1a7cac	e2 20		sep #$20	            SEP #$20
.1a7cae	a9 00		lda #$00	                LDA #0
.1a7cb0	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT     ; Clear the pagination line counter
.1a7cb4	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.1a7cb6	c9 02		cmp #$02	                CMP #2
.1a7cb8	b0 16		bcs $1a7cd0	                BGE set_cursor      ; 2>= arguments? Use them as-is
.1a7cba	c9 01		cmp #$01	                CMP #1
.1a7cbc	90 20		bcc $1a7cde	                BLT no_args         ; No arguments passed? Use defaults
.1a7cbe	c2 20		rep #$20	            REP #$20
.1a7cc0	18		clc		                CLC
.1a7cc1	a5 0d		lda $0855	                LDA MARG1
.1a7cc3	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a7cc6	85 11		sta $0859	                STA MARG2
.1a7cc8	e2 20		sep #$20	            SEP #$20
.1a7cca	a5 0f		lda $0857	                LDA MARG1+2
.1a7ccc	69 00		adc #$00	                ADC #0
.1a7cce	85 13		sta $085b	                STA MARG2+2
.1a7cd0					set_cursor
.1a7cd0	c2 20		rep #$20	            REP #$20
.1a7cd2	a5 0d		lda $0855	                LDA MARG1
.1a7cd4	85 32		sta $087a	                STA MCURSOR
.1a7cd6	e2 20		sep #$20	            SEP #$20
.1a7cd8	a5 0f		lda $0857	                LDA MARG1+2
.1a7cda	85 34		sta $087c	                STA MCURSOR+2
.1a7cdc	80 12		bra $1a7cf0	                BRA dasm_loop
.1a7cde					no_args
.1a7cde	c2 20		rep #$20	            REP #$20
.1a7ce0	18		clc		                CLC
.1a7ce1	a5 32		lda $087a	                LDA MCURSOR
.1a7ce3	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a7ce6	85 11		sta $0859	                STA MARG2
.1a7ce8	e2 20		sep #$20	            SEP #$20
.1a7cea	a5 34		lda $087c	                LDA MCURSOR+2
.1a7cec	69 00		adc #$00	                ADC #0
.1a7cee	85 13		sta $085b	                STA MARG2+2
.1a7cf0	22 0b 7d 1a	jsl $1a7d0b	dasm_loop       JSL DS_PR_LINE
.1a7cf4	e2 20		sep #$20	            SEP #$20
.1a7cf6	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.1a7cf8	c5 13		cmp $085b	                CMP MARG2+2
.1a7cfa	90 f4		bcc $1a7cf0	                BLT dasm_loop           ; No: continue
.1a7cfc	c2 20		rep #$20	            REP #$20
.1a7cfe	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.1a7d00	c5 11		cmp $0859	                CMP MARG2
.1a7d02	90 ec		bcc $1a7cf0	                BLT dasm_loop           ; Nope... keep going
.1a7d04					done
.1a7d04	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a7d07	2b		pld		                PLD
.1a7d08	ab		plb		                PLB
.1a7d09	28		plp		                PLP
.1a7d0a	6b		rtl		                RTL
.1a7d0b					DS_PR_LINE
.1a7d0b	08		php		                PHP
.1a7d0c	0b		phd		                PHD
.1a7d0d	e2 20		sep #$20	            SEP #$20
.1a7d0f	a9 41		lda #$41	                LDA #'A'
.1a7d11	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d14	a9 20		lda #$20	                LDA #' '
.1a7d16	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d19	08		php		            PHP
.1a7d1a	c2 20		rep #$20	            REP #$20
.1a7d1c	48		pha		            PHA
.1a7d1d	a9 7a 08	lda #$087a	            LDA #MCURSOR
.1a7d20	5b		tcd		            TCD
.1a7d21	68		pla		            PLA
.1a7d22	28		plp		            PLP
.1a7d23	c2 20		rep #$20	            REP #$20
.1a7d25	a5 00		lda $087a	                LDA MCURSOR
.1a7d27	85 18		sta $0892	                STA MTEMP
.1a7d29	e2 20		sep #$20	            SEP #$20
.1a7d2b	a5 02		lda $087c	                LDA MCURSOR+2
.1a7d2d	85 1a		sta $0894	                STA MTEMP+2
.1a7d2f	22 72 80 1a	jsl $1a8072	                JSL M_PR_ADDR
.1a7d33	a9 20		lda #$20	                LDA #' '
.1a7d35	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d38	c2 20		rep #$20	            REP #$20
.1a7d3a	18		clc		                CLC
.1a7d3b	a5 00		lda $087a	                LDA MCURSOR
.1a7d3d	69 01 00	adc #$0001	                ADC #1
.1a7d40	85 18		sta $0892	                STA MTEMP
.1a7d42	e2 20		sep #$20	            SEP #$20
.1a7d44	a5 02		lda $087c	                LDA MCURSOR+2
.1a7d46	69 00		adc #$00	                ADC #0
.1a7d48	85 1a		sta $0894	                STA MTEMP+2
.1a7d4a	e2 20		sep #$20	            SEP #$20
.1a7d4c	c2 10		rep #$10	            REP #$10
.1a7d4e	a7 00		lda [$087a]	                LDA [MCURSOR]           ; Get the mnemonic
.1a7d50	c9 c2		cmp #$c2	                CMP #$C2                ; Is it REP?
.1a7d52	d0 0b		bne $1a7d5f	                BNE check_sep           ; No: check to see if it is SEP
.1a7d54	48		pha		handle_rep      PHA
.1a7d55	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.1a7d57	49 ff		eor #$ff	                EOR #$FF                ; Invert the bits
.1a7d59	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Mask off the bits in the CPUSTAT
.1a7d5d	80 0b		bra $1a7d6a	                BRA save_stat
.1a7d5f	c9 e2		cmp #$e2	check_sep       CMP #$E2                ; Is it SEP?
.1a7d61	d0 0c		bne $1a7d6f	                BNE get_op_index        ; No: process the instruction regularly
.1a7d63	48		pha		handle_sep      PHA
.1a7d64	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.1a7d66	0f 96 08 00	ora $000896	                ORA @lMCPUSTAT          ; Activate the bits in the CPUSTAT
.1a7d6a	8f 96 08 00	sta $000896	save_stat       STA @lMCPUSTAT          ; And save it back
.1a7d6e	68		pla		                PLA
.1a7d6f					get_op_index
.1a7d6f	c2 20		rep #$20	            REP #$20
.1a7d71	29 ff 00	and #$00ff	                AND #$00FF
.1a7d74	0a		asl a		                ASL A
.1a7d75	aa		tax		                TAX                     ; Get the index into the mnemonic lookup table
.1a7d76	bf 0c 82 1a	lda $1a820c,x	                LDA @lMNEMONIC_TAB,X    ; Get the mnemonic
.1a7d7a	aa		tax		                TAX
.1a7d7b	22 ec 7f 1a	jsl $1a7fec	                JSL DS_PR_MNEMONIC      ; And print it
.1a7d7f	e2 20		sep #$20	            SEP #$20
.1a7d81	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a7d83	aa		tax		                TAX
.1a7d84	bf 0e 84 1a	lda $1a840e,x	pr_operand      LDA @lADDRESS_TAB,X     ; Get the addressing mode for the instruction
.1a7d88	22 c8 85 1a	jsl $1a85c8	                JSL M_INC_CURSOR        ; Advance the cursor to the next byte
.1a7d8c	22 99 7d 1a	jsl $1a7d99	                JSL DS_PR_OPERAND       ; And print the correct operand
.1a7d90	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a7d93	20 3d 03	jsr $1a033d	            JSR PAGINATE
.1a7d96	2b		pld		                PLD
.1a7d97	28		plp		                PLP
.1a7d98	6b		rtl		                RTL
.1a7d99					DS_PR_OPERAND
.1a7d99	08		php		                PHP
.1a7d9a	e2 20		sep #$20	            SEP #$20
.1a7d9c	48		pha		                PHA             ; Save the address mode so we can get to the M and X flags
.1a7d9d	29 3f		and #$3f	                AND #%00111111  ; Filter out the mode flags
.1a7d9f	0a		asl a		                ASL A           ; Compute the index to the table
.1a7da0	c2 10		rep #$10	            REP #$10
.1a7da2	aa		tax		                TAX
.1a7da3	68		pla		                PLA             ; Restore A
.1a7da4	7c a7 7d	jmp ($1a7da7,x)	                JMP (dispatch,X)
>1a7da7	d7 7d				dispatch        .word <>is_dp_ind_x
>1a7da9	f2 7d				                .word <>is_dp
>1a7dab	f9 7d				                .word <>is_imm
>1a7dad	1e 7e				                .word <>is_abs
>1a7daf	25 7e				                .word <>is_dp_ind_y
>1a7db1	40 7e				                .word <>is_dp_x
>1a7db3	62 7e				                .word <>is_abs_y
>1a7db5	73 7e				                .word <>is_abs_x
>1a7db7	b0 7e				                .word <>is_accumulator
>1a7db9	b8 7e				                .word <>is_stack_r
>1a7dbb	c9 7e				                .word <>is_dp_long
>1a7dbd	da 7e				                .word <>is_abs_long
>1a7dbf	e1 7e				                .word <>is_stack_r_y
>1a7dc1	06 7f				                .word <>is_dp_y_long
>1a7dc3	33 7f				                .word <>is_abs_x_long
>1a7dc5	9f 7e				                .word <>is_dp_ind
>1a7dc7	84 7e				                .word <>is_abs_x_id
>1a7dc9	51 7e				                .word <>is_dp_y
>1a7dcb	26 7f				                .word <>is_pc_rel
>1a7dcd	30 7f				                .word <>is_implied
>1a7dcf	44 7f				                .word <>is_xyc
>1a7dd1	73 7f				                .word <>is_abs_ind
>1a7dd3	21 7f				                .word <>is_pc_rel_long
>1a7dd5	84 7f				                .word <>is_abs_ind_long
.1a7dd7	a9 28		lda #$28	is_dp_ind_x     LDA #'('                ; Print (dd,X)
.1a7dd9	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ddc	22 9b 7f 1a	jsl $1a7f9b	                JSL DS_PR_OPERAND1      ; Print dd
.1a7de0	a9 2c		lda #$2c	                LDA #','
.1a7de2	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7de5	a9 58		lda #$58	                LDA #'X'
.1a7de7	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7dea	a9 29		lda #$29	                LDA #')'
.1a7dec	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7def	4c 95 7f	jmp $1a7f95	                JMP done_1
.1a7df2	22 9b 7f 1a	jsl $1a7f9b	is_dp           JSL DS_PR_OPERAND1      ; Print dd
.1a7df6	4c 95 7f	jmp $1a7f95	                JMP done_1
.1a7df9					is_imm
.1a7df9	e2 20		sep #$20	            SEP #$20
.1a7dfb	48		pha		                PHA
.1a7dfc	a9 23		lda #$23	                LDA #'#'
.1a7dfe	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e01	68		pla		                PLA
.1a7e02	29 c0		and #$c0	                AND #%11000000          ; Filter so we just look at the mode bits
.1a7e04	c9 00		cmp #$00	                CMP #$00                ; Are any set to check?
.1a7e06	f0 0f		beq $1a7e17	                BEQ is_imm_short        ; No: treat it as a short always
.1a7e08	4a		lsr a		                LSR A                   ; Move the flag bits right by 2 to match
.1a7e09	4a		lsr a		                LSR A                   ; the positions of the bits in the CPU status register
.1a7e0a	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Otherwise, filter the mode bit we care about
.1a7e0e	d0 07		bne $1a7e17	                BNE is_imm_short        ; If it is set, immediate operation is short
.1a7e10	22 a5 7f 1a	jsl $1a7fa5	                JSL DS_PR_OPERAND2      ; Print dddd
.1a7e14	4c 95 7f	jmp $1a7f95	                JMP done_1
.1a7e17	22 9b 7f 1a	jsl $1a7f9b	is_imm_short    JSL DS_PR_OPERAND1      ; Print dd
.1a7e1b	4c 95 7f	jmp $1a7f95	                JMP done_1
.1a7e1e	22 a5 7f 1a	jsl $1a7fa5	is_abs          JSL DS_PR_OPERAND2      ; Print dddd
.1a7e22	4c 95 7f	jmp $1a7f95	                JMP done_1
.1a7e25	a9 28		lda #$28	is_dp_ind_y     LDA #'('                ; Print (dd),Y
.1a7e27	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e2a	22 9b 7f 1a	jsl $1a7f9b	                JSL DS_PR_OPERAND1      ; Print dd
.1a7e2e	a9 29		lda #$29	                LDA #')'
.1a7e30	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e33	a9 2c		lda #$2c	                LDA #','
.1a7e35	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e38	a9 59		lda #$59	                LDA #'Y'
.1a7e3a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e3d	4c 95 7f	jmp $1a7f95	                JMP done_1
.1a7e40	22 9b 7f 1a	jsl $1a7f9b	is_dp_x         JSL DS_PR_OPERAND1      ; Print dd,X
.1a7e44	a9 2c		lda #$2c	                LDA #','
.1a7e46	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e49	a9 58		lda #$58	                LDA #'X'
.1a7e4b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e4e	4c 95 7f	jmp $1a7f95	                JMP done_1
.1a7e51	22 9b 7f 1a	jsl $1a7f9b	is_dp_y         JSL DS_PR_OPERAND1      ; Print dd,Y
.1a7e55	a9 2c		lda #$2c	                LDA #','
.1a7e57	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e5a	a9 59		lda #$59	                LDA #'Y'
.1a7e5c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e5f	4c 95 7f	jmp $1a7f95	                JMP done_1
.1a7e62	22 a5 7f 1a	jsl $1a7fa5	is_abs_y        JSL DS_PR_OPERAND2      ; Print dddd,Y
.1a7e66	a9 2c		lda #$2c	                LDA #','
.1a7e68	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e6b	a9 59		lda #$59	                LDA #'Y'
.1a7e6d	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e70	4c 95 7f	jmp $1a7f95	                JMP done_1
.1a7e73	22 a5 7f 1a	jsl $1a7fa5	is_abs_x        JSL DS_PR_OPERAND2      ; Print dddd,X
.1a7e77	a9 2c		lda #$2c	                LDA #','
.1a7e79	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e7c	a9 58		lda #$58	                LDA #'X'
.1a7e7e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e81	4c 95 7f	jmp $1a7f95	                JMP done_1
.1a7e84	a9 28		lda #$28	is_abs_x_id     LDA #'('
.1a7e86	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e89	22 a5 7f 1a	jsl $1a7fa5	                JSL DS_PR_OPERAND2      ; Print (dddd,X)
.1a7e8d	a9 2c		lda #$2c	                LDA #','
.1a7e8f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e92	a9 58		lda #$58	                LDA #'X'
.1a7e94	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e97	a9 29		lda #$29	                LDA #')'
.1a7e99	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e9c	4c 95 7f	jmp $1a7f95	                JMP done_1
.1a7e9f	a9 28		lda #$28	is_dp_ind       LDA #'('
.1a7ea1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ea4	22 9b 7f 1a	jsl $1a7f9b	                JSL DS_PR_OPERAND1      ; Print (dd)
.1a7ea8	a9 29		lda #$29	                LDA #')'
.1a7eaa	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ead	4c 95 7f	jmp $1a7f95	                JMP done_1
.1a7eb0	a9 41		lda #$41	is_accumulator  LDA #'A'                ; Print A
.1a7eb2	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7eb5	4c 99 7f	jmp $1a7f99	                JMP done
.1a7eb8	22 9b 7f 1a	jsl $1a7f9b	is_stack_r      JSL DS_PR_OPERAND1      ; Print dd,S
.1a7ebc	a9 2c		lda #$2c	                LDA #','
.1a7ebe	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ec1	a9 53		lda #$53	                LDA #'S'
.1a7ec3	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ec6	4c 95 7f	jmp $1a7f95	                JMP done_1
.1a7ec9	a9 5b		lda #$5b	is_dp_long      LDA #'['                ; [dd]
.1a7ecb	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ece	22 9b 7f 1a	jsl $1a7f9b	                JSL DS_PR_OPERAND1      ; Print dd
.1a7ed2	a9 5d		lda #$5d	                LDA #']'
.1a7ed4	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ed7	4c 95 7f	jmp $1a7f95	                JMP done_1
.1a7eda	22 b3 7f 1a	jsl $1a7fb3	is_abs_long     JSL DS_PR_OPERAND3      ; Print dddddd
.1a7ede	4c 99 7f	jmp $1a7f99	                JMP done
.1a7ee1	a9 28		lda #$28	is_stack_r_y    LDA #'('                ; (dd,S),Y
.1a7ee3	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ee6	22 9b 7f 1a	jsl $1a7f9b	                JSL DS_PR_OPERAND1      ; Print dd
.1a7eea	a9 2c		lda #$2c	                LDA #','
.1a7eec	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7eef	a9 53		lda #$53	                LDA #'S'
.1a7ef1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ef4	a9 29		lda #$29	                LDA #')'
.1a7ef6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ef9	a9 2c		lda #$2c	                LDA #','
.1a7efb	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7efe	a9 59		lda #$59	                LDA #'Y'
.1a7f00	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f03	4c 95 7f	jmp $1a7f95	                JMP done_1
.1a7f06	a9 5b		lda #$5b	is_dp_y_long    LDA #'['                ; [dd],Y
.1a7f08	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f0b	22 9b 7f 1a	jsl $1a7f9b	                JSL DS_PR_OPERAND1      ; Print dd
.1a7f0f	a9 5d		lda #$5d	                LDA #']'
.1a7f11	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f14	a9 2c		lda #$2c	                LDA #','
.1a7f16	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f19	a9 59		lda #$59	                LDA #'Y'
.1a7f1b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f1e	4c 95 7f	jmp $1a7f95	                JMP done_1
.1a7f21	a0 02 00	ldy #$0002	is_pc_rel_long  LDY #2
.1a7f24	80 03		bra $1a7f29	                BRA do_pcrel
.1a7f26	a0 01 00	ldy #$0001	is_pc_rel       LDY #1
.1a7f29	22 19 80 1a	jsl $1a8019	do_pcrel        JSL DS_PR_PCREL
.1a7f2d	4c 99 7f	jmp $1a7f99	                JMP done
.1a7f30	4c 99 7f	jmp $1a7f99	is_implied      JMP done
.1a7f33	22 b3 7f 1a	jsl $1a7fb3	is_abs_x_long   JSL DS_PR_OPERAND3      ; Print dddddd
.1a7f37	a9 2c		lda #$2c	                LDA #','
.1a7f39	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f3c	a9 58		lda #$58	                LDA #'X'
.1a7f3e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f41	4c 99 7f	jmp $1a7f99	                JMP done
.1a7f44	a9 23		lda #$23	is_xyc          LDA #'#'
.1a7f46	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f49	8b		phb		                PHB                     ; Make sure the databank is pointed to our number
.1a7f4a	a5 02		lda $087c	                LDA MCURSOR+2
.1a7f4c	48		pha		                PHA
.1a7f4d	ab		plb		                PLB
.1a7f4e	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.1a7f50	e8		inx		                INX
.1a7f51	a0 01 00	ldy #$0001	                LDY #1
.1a7f54	22 36 03 1a	jsl $1a0336	                JSL PRINTH
.1a7f58	a9 2c		lda #$2c	                LDA #','
.1a7f5a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f5d	a9 23		lda #$23	                LDA #'#'
.1a7f5f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f62	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.1a7f64	a0 01 00	ldy #$0001	                LDY #1
.1a7f67	22 36 03 1a	jsl $1a0336	                JSL PRINTH
.1a7f6b	ab		plb		                PLB                     ; Get our old data bank back
.1a7f6c	22 c8 85 1a	jsl $1a85c8	                JSL M_INC_CURSOR
.1a7f70	4c 95 7f	jmp $1a7f95	                JMP done_1
.1a7f73	a9 28		lda #$28	is_abs_ind      LDA #'('
.1a7f75	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f78	22 a5 7f 1a	jsl $1a7fa5	                JSL DS_PR_OPERAND2      ; Print (dddd)
.1a7f7c	a9 29		lda #$29	                LDA #')'
.1a7f7e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f81	4c 95 7f	jmp $1a7f95	                JMP done_1
.1a7f84	a9 5b		lda #$5b	is_abs_ind_long LDA #'['
.1a7f86	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f89	22 a5 7f 1a	jsl $1a7fa5	                JSL DS_PR_OPERAND2      ; Print [dddd]
.1a7f8d	a9 5d		lda #$5d	                LDA #']'
.1a7f8f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f92	4c 95 7f	jmp $1a7f95	                JMP done_1
.1a7f95	22 c8 85 1a	jsl $1a85c8	done_1          JSL M_INC_CURSOR    ; Skip over a single byte operand
.1a7f99	28		plp		done            PLP
.1a7f9a	6b		rtl		                RTL
.1a7f9b					DS_PR_OPERAND1
.1a7f9b	08		php		                PHP
.1a7f9c	e2 20		sep #$20	            SEP #$20
.1a7f9e	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a7fa0	20 dd 03	jsr $1a03dd	            JSR PRHEXB
.1a7fa3	28		plp		                PLP
.1a7fa4	6b		rtl		                RTL
.1a7fa5					DS_PR_OPERAND2
.1a7fa5	08		php		                PHP
.1a7fa6	c2 30		rep #$30	            REP #$30
.1a7fa8	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a7faa	20 c3 03	jsr $1a03c3	            JSR PRHEXW
.1a7fad	22 c8 85 1a	jsl $1a85c8	                JSL M_INC_CURSOR
.1a7fb1	28		plp		                PLP
.1a7fb2	6b		rtl		                RTL
.1a7fb3					DS_PR_OPERAND3
.1a7fb3	08		php		                PHP
.1a7fb4	8b		phb		                PHB
.1a7fb5	0b		phd		                PHD
.1a7fb6	c2 30		rep #$30	            REP #$30
.1a7fb8	5a		phy		                PHY
.1a7fb9	08		php		            PHP
.1a7fba	c2 20		rep #$20	            REP #$20
.1a7fbc	48		pha		            PHA
.1a7fbd	a9 7a 08	lda #$087a	            LDA #MCURSOR
.1a7fc0	5b		tcd		            TCD
.1a7fc1	68		pla		            PLA
.1a7fc2	28		plp		            PLP
.1a7fc3	08		php		            PHP
.1a7fc4	e2 20		sep #$20	            SEP #$20
.1a7fc6	48		pha		            PHA
.1a7fc7	a9 00		lda #$00	            LDA #`MTEMP
.1a7fc9	48		pha		            PHA
.1a7fca	ab		plb		            PLB
.1a7fcb	68		pla		            PLA
.1a7fcc	28		plp		            PLP
.1a7fcd	e2 20		sep #$20	            SEP #$20
.1a7fcf	a0 00 00	ldy #$0000	                LDY #0
.1a7fd2	a7 00		lda [$087a]	copy_loop       LDA [MCURSOR]       ; Copy the address pointed to by MCURSOR
.1a7fd4	99 92 08	sta $0892,y	                STA MTEMP,Y         ; to MTEMP
.1a7fd7	22 c8 85 1a	jsl $1a85c8	                JSL M_INC_CURSOR
.1a7fdb	c8		iny		                INY
.1a7fdc	c0 03 00	cpy #$0003	                CPY #3
.1a7fdf	d0 f1		bne $1a7fd2	                BNE copy_loop
.1a7fe1	22 72 80 1a	jsl $1a8072	                JSL M_PR_ADDR       ; Print the address
.1a7fe5	c2 30		rep #$30	            REP #$30
.1a7fe7	7a		ply		                PLY
.1a7fe8	2b		pld		                PLD
.1a7fe9	ab		plb		                PLB
.1a7fea	28		plp		                PLP
.1a7feb	6b		rtl		                RTL
.1a7fec					DS_PR_MNEMONIC
.1a7fec	08		php		                PHP
.1a7fed	8b		phb		                PHB
.1a7fee	e2 20		sep #$20	            SEP #$20
.1a7ff0	c2 10		rep #$10	            REP #$10
.1a7ff2	08		php		            PHP
.1a7ff3	e2 20		sep #$20	            SEP #$20
.1a7ff5	48		pha		            PHA
.1a7ff6	a9 1a		lda #$1a	            LDA #`MN_ORA
.1a7ff8	48		pha		            PHA
.1a7ff9	ab		plb		            PLB
.1a7ffa	68		pla		            PLA
.1a7ffb	28		plp		            PLP
.1a7ffc	bd 00 00	lda $1a0000,x	                LDA #0,B,X
.1a7fff	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8002	e8		inx		                INX
.1a8003	bd 00 00	lda $1a0000,x	                LDA #0,B,X
.1a8006	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8009	e8		inx		                INX
.1a800a	bd 00 00	lda $1a0000,x	                LDA #0,B,X
.1a800d	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8010	e8		inx		                INX
.1a8011	a9 20		lda #$20	                LDA #' '            ; Print a space
.1a8013	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8016	ab		plb		                PLB
.1a8017	28		plp		                PLP
.1a8018	6b		rtl		                RTL
.1a8019					DS_PR_PCREL
.1a8019	08		php		                PHP
.1a801a	0b		phd		                PHD
.1a801b	08		php		            PHP
.1a801c	c2 20		rep #$20	            REP #$20
.1a801e	48		pha		            PHA
.1a801f	a9 7a 08	lda #$087a	            LDA #MCURSOR
.1a8022	5b		tcd		            TCD
.1a8023	68		pla		            PLA
.1a8024	28		plp		            PLP
.1a8025	e2 20		sep #$20	            SEP #$20
.1a8027	c0 02 00	cpy #$0002	                CPY #2
.1a802a	f0 14		beq $1a8040	                BEQ offset_2
.1a802c	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a802e	85 18		sta $0892	                STA MTEMP
.1a8030	30 06		bmi $1a8038	                BMI is_negative
.1a8032	64 19		stz $0893	                STZ MTEMP+1
.1a8034	64 1a		stz $0894	                STZ MTEMP+2
.1a8036	80 1e		bra $1a8056	                BRA add_offset
.1a8038	a9 ff		lda #$ff	is_negative     LDA #$FF
.1a803a	85 19		sta $0893	                STA MTEMP+1
.1a803c	85 1a		sta $0894	                STA MTEMP+2
.1a803e	80 16		bra $1a8056	                BRA add_offset
.1a8040	a7 00		lda [$087a]	offset_2        LDA [MCURSOR]
.1a8042	85 18		sta $0892	                STA MTEMP
.1a8044	22 c8 85 1a	jsl $1a85c8	                JSL M_INC_CURSOR
.1a8048	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a804a	85 19		sta $0893	                STA MTEMP+1
.1a804c	30 04		bmi $1a8052	                BMI is_negative2
.1a804e	64 1a		stz $0894	                STZ MTEMP+2
.1a8050	80 04		bra $1a8056	                BRA add_offset
.1a8052	a9 ff		lda #$ff	is_negative2    LDA #$FF
.1a8054	85 1a		sta $0894	                STA MTEMP+2
.1a8056					add_offset
.1a8056	c2 20		rep #$20	            REP #$20
.1a8058	38		sec		                SEC             ; Add 1 to the offset
.1a8059	a5 00		lda $087a	                LDA MCURSOR
.1a805b	65 18		adc $0892	                ADC MTEMP
.1a805d	85 18		sta $0892	                STA MTEMP
.1a805f	e2 20		sep #$20	            SEP #$20
.1a8061	a5 02		lda $087c	                LDA MCURSOR+2
.1a8063	65 1a		adc $0894	                ADC MTEMP+2
.1a8065	85 1a		sta $0894	                STA MTEMP+2
.1a8067	22 72 80 1a	jsl $1a8072	                JSL M_PR_ADDR
.1a806b	22 c8 85 1a	jsl $1a85c8	                JSL M_INC_CURSOR
.1a806f	2b		pld		                PLD
.1a8070	28		plp		                PLP
.1a8071	6b		rtl		                RTL
.1a8072					M_PR_ADDR
.1a8072	08		php		                PHP
.1a8073	0b		phd		                PHD
.1a8074	c2 20		rep #$20	            REP #$20
.1a8076	48		pha		                PHA
.1a8077	08		php		            PHP
.1a8078	c2 20		rep #$20	            REP #$20
.1a807a	48		pha		            PHA
.1a807b	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a807e	5b		tcd		            TCD
.1a807f	68		pla		            PLA
.1a8080	28		plp		            PLP
.1a8081	e2 20		sep #$20	            SEP #$20
.1a8083	a5 4c		lda $0894	                LDA MTEMP+2     ; Print the bank byte of the address
.1a8085	20 dd 03	jsr $1a03dd	            JSR PRHEXB
.1a8088	e2 20		sep #$20	            SEP #$20
.1a808a	a9 3a		lda #$3a	                LDA #':'
.1a808c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a808f	c2 20		rep #$20	            REP #$20
.1a8091	a5 4a		lda $0892	                LDA MTEMP       ; Print the lower 16-bits of the address
.1a8093	20 c3 03	jsr $1a03c3	            JSR PRHEXW
.1a8096	68		pla		                PLA
.1a8097	2b		pld		                PLD
.1a8098	28		plp		                PLP
.1a8099	6b		rtl		                RTL
.1a809a					MNEMONICS_TAB
.1a809a					MN_ORA
>1a809a	4f 52 41 00			            .null "ORA"
.1a809e					MN_AND
>1a809e	41 4e 44 00			            .null "AND"
.1a80a2					MN_EOR
>1a80a2	45 4f 52 00			            .null "EOR"
.1a80a6					MN_ADC
>1a80a6	41 44 43 00			            .null "ADC"
.1a80aa					MN_STA
>1a80aa	53 54 41 00			            .null "STA"
.1a80ae					MN_LDA
>1a80ae	4c 44 41 00			            .null "LDA"
.1a80b2					MN_CMP
>1a80b2	43 4d 50 00			            .null "CMP"
.1a80b6					MN_SBC
>1a80b6	53 42 43 00			            .null "SBC"
.1a80ba					MN_ASL
>1a80ba	41 53 4c 00			            .null "ASL"
.1a80be					MN_ROL
>1a80be	52 4f 4c 00			            .null "ROL"
.1a80c2					MN_LSR
>1a80c2	4c 53 52 00			            .null "LSR"
.1a80c6					MN_ROR
>1a80c6	52 4f 52 00			            .null "ROR"
.1a80ca					MN_STX
>1a80ca	53 54 58 00			            .null "STX"
.1a80ce					MN_LDX
>1a80ce	4c 44 58 00			            .null "LDX"
.1a80d2					MN_DEC
>1a80d2	44 45 43 00			            .null "DEC"
.1a80d6					MN_INC
>1a80d6	49 4e 43 00			            .null "INC"
.1a80da					MN_BIT
>1a80da	42 49 54 00			            .null "BIT"
.1a80de					MN_JMP
>1a80de	4a 4d 50 00			            .null "JMP"
.1a80e2					MN_STY
>1a80e2	53 54 59 00			            .null "STY"
.1a80e6					MN_LDY
>1a80e6	4c 44 59 00			            .null "LDY"
.1a80ea					MN_CPY
>1a80ea	43 50 59 00			            .null "CPY"
.1a80ee					MN_CPX
>1a80ee	43 50 58 00			            .null "CPX"
.1a80f2					MN_BRK
>1a80f2	42 52 4b 00			            .null "BRK"
.1a80f6					MN_JSR
>1a80f6	4a 53 52 00			            .null "JSR"
.1a80fa					MN_RTI
>1a80fa	52 54 49 00			            .null "RTI"
.1a80fe					MN_RTS
>1a80fe	52 54 53 00			            .null "RTS"
.1a8102					MN_PHP
>1a8102	50 48 50 00			            .null "PHP"
.1a8106					MN_PLP
>1a8106	50 4c 50 00			            .null "PLP"
.1a810a					MN_PHA
>1a810a	50 48 41 00			            .null "PHA"
.1a810e					MN_PLA
>1a810e	50 4c 41 00			            .null "PLA"
.1a8112					MN_DEY
>1a8112	44 45 59 00			            .null "DEY"
.1a8116					MN_TAY
>1a8116	54 41 59 00			            .null "TAY"
.1a811a					MN_INY
>1a811a	49 4e 59 00			            .null "INY"
.1a811e					MN_INX
>1a811e	49 4e 58 00			            .null "INX"
.1a8122					MN_CLC
>1a8122	43 4c 43 00			            .null "CLC"
.1a8126					MN_SEC
>1a8126	53 45 43 00			            .null "SEC"
.1a812a					MN_CLI
>1a812a	43 4c 49 00			            .null "CLI"
.1a812e					MN_SEI
>1a812e	53 45 49 00			            .null "SEI"
.1a8132					MN_TYA
>1a8132	54 59 41 00			            .null "TYA"
.1a8136					MN_CLV
>1a8136	43 4c 56 00			            .null "CLV"
.1a813a					MN_CLD
>1a813a	43 4c 44 00			            .null "CLD"
.1a813e					MN_SED
>1a813e	53 45 44 00			            .null "SED"
.1a8142					MN_TXA
>1a8142	54 58 41 00			            .null "TXA"
.1a8146					MN_TXS
>1a8146	54 58 53 00			            .null "TXS"
.1a814a					MN_TAX
>1a814a	54 41 58 00			            .null "TAX"
.1a814e					MN_TSX
>1a814e	54 53 58 00			            .null "TSX"
.1a8152					MN_DEX
>1a8152	44 45 58 00			            .null "DEX"
.1a8156					MN_NOP
>1a8156	4e 4f 50 00			            .null "NOP"
.1a815a					MN_BPL
>1a815a	42 50 4c 00			            .null "BPL"
.1a815e					MN_BMI
>1a815e	42 4d 49 00			            .null "BMI"
.1a8162					MN_BVC
>1a8162	42 56 43 00			            .null "BVC"
.1a8166					MN_BVS
>1a8166	42 56 53 00			            .null "BVS"
.1a816a					MN_BCC
>1a816a	42 43 43 00			            .null "BCC"
.1a816e					MN_BCS
>1a816e	42 43 53 00			            .null "BCS"
.1a8172					MN_BNE
>1a8172	42 4e 45 00			            .null "BNE"
.1a8176					MN_BEQ
>1a8176	42 45 51 00			            .null "BEQ"
.1a817a					MN_TSB
>1a817a	54 53 42 00			            .null "TSB"
.1a817e					MN_TRB
>1a817e	54 52 42 00			            .null "TRB"
.1a8182					MN_STZ
>1a8182	53 54 5a 00			            .null "STZ"
.1a8186					MN_BRA
>1a8186	42 52 41 00			            .null "BRA"
.1a818a					MN_PHY
>1a818a	50 48 59 00			            .null "PHY"
.1a818e					MN_PLY
>1a818e	50 4c 59 00			            .null "PLY"
.1a8192					MN_PHX
>1a8192	50 48 58 00			            .null "PHX"
.1a8196					MN_PLX
>1a8196	50 4c 58 00			            .null "PLX"
.1a819a					MN_PHD
>1a819a	50 48 44 00			            .null "PHD"
.1a819e					MN_PLD
>1a819e	50 4c 44 00			            .null "PLD"
.1a81a2					MN_PHK
>1a81a2	50 48 4b 00			            .null "PHK"
.1a81a6					MN_RTL
>1a81a6	52 54 4c 00			            .null "RTL"
.1a81aa					MN_PHB
>1a81aa	50 48 42 00			            .null "PHB"
.1a81ae					MN_PLB
>1a81ae	50 4c 42 00			            .null "PLB"
.1a81b2					MN_WAI
>1a81b2	57 41 49 00			            .null "WAI"
.1a81b6					MN_XBA
>1a81b6	58 42 41 00			            .null "XBA"
.1a81ba					MN_TCS
>1a81ba	54 43 53 00			            .null "TCS"
.1a81be					MN_TSC
>1a81be	54 53 43 00			            .null "TSC"
.1a81c2					MN_TCD
>1a81c2	54 43 44 00			            .null "TCD"
.1a81c6					MN_TDC
>1a81c6	54 44 43 00			            .null "TDC"
.1a81ca					MN_TXY
>1a81ca	54 58 59 00			            .null "TXY"
.1a81ce					MN_TYX
>1a81ce	54 59 58 00			            .null "TYX"
.1a81d2					MN_STP
>1a81d2	53 54 50 00			            .null "STP"
.1a81d6					MN_XCE
>1a81d6	58 43 45 00			            .null "XCE"
.1a81da					MN_COP
>1a81da	43 4f 50 00			            .null "COP"
.1a81de					MN_JSL
>1a81de	4a 53 4c 00			            .null "JSL"
.1a81e2					MN_WDM
>1a81e2	57 44 4d 00			            .null "WDM"
.1a81e6					MN_PER
>1a81e6	50 45 52 00			            .null "PER"
.1a81ea					MN_BRL
>1a81ea	42 52 4c 00			            .null "BRL"
.1a81ee					MN_REP
>1a81ee	52 45 50 00			            .null "REP"
.1a81f2					MN_SEP
>1a81f2	53 45 50 00			            .null "SEP"
.1a81f6					MN_MVP
>1a81f6	4d 56 50 00			            .null "MVP"
.1a81fa					MN_MVN
>1a81fa	4d 56 4e 00			            .null "MVN"
.1a81fe					MN_PEI
>1a81fe	50 45 49 00			            .null "PEI"
.1a8202					MN_PEA
>1a8202	50 45 41 00			            .null "PEA"
.1a8206					MN_JML
>1a8206	4a 4d 4c 00			            .null "JML"
>1a820a	00 00				            .byte 0, 0
>1a820c	f2 80 9a 80 da 81 9a 80		MNEMONIC_TAB    .word <>MN_BRK, <>MN_ORA, <>MN_COP, <>MN_ORA, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 0x
>1a8214	7a 81 9a 80 ba 80 9a 80
>1a821c	02 81 9a 80 ba 80 9a 81		                .word <>MN_PHP, <>MN_ORA, <>MN_ASL, <>MN_PHD, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>1a8224	7a 81 9a 80 ba 80 9a 80
>1a822c	5a 81 9a 80 9a 80 9a 80		                .word <>MN_BPL, <>MN_ORA, <>MN_ORA, <>MN_ORA, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 1x
>1a8234	7e 81 9a 80 ba 80 9a 80
>1a823c	22 81 9a 80 d6 80 ba 81		                .word <>MN_CLC, <>MN_ORA, <>MN_INC, <>MN_TCS, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>1a8244	7e 81 9a 80 ba 80 9a 80
>1a824c	f6 80 9e 80 de 81 9e 80		                .word <>MN_JSR, <>MN_AND, <>MN_JSL, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 2x
>1a8254	da 80 9e 80 be 80 9e 80
>1a825c	06 81 9e 80 be 80 9e 81		                .word <>MN_PLP, <>MN_AND, <>MN_ROL, <>MN_PLD, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>1a8264	da 80 9e 80 be 80 9e 80
>1a826c	5e 81 9e 80 9e 80 9e 80		                .word <>MN_BMI, <>MN_AND, <>MN_AND, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 3x
>1a8274	da 80 9e 80 be 80 9e 80
>1a827c	26 81 9e 80 d2 80 be 81		                .word <>MN_SEC, <>MN_AND, <>MN_DEC, <>MN_TSC, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>1a8284	da 80 9e 80 be 80 9e 80
>1a828c	fa 80 a2 80 e2 81 a2 80		                .word <>MN_RTI, <>MN_EOR, <>MN_WDM, <>MN_EOR, <>MN_MVP, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 4x
>1a8294	f6 81 a2 80 c2 80 a2 80
>1a829c	0a 81 a2 80 c2 80 a2 81		                .word <>MN_PHA, <>MN_EOR, <>MN_LSR, <>MN_PHK, <>MN_JMP, <>MN_EOR, <>MN_LSR, <>MN_EOR
>1a82a4	de 80 a2 80 c2 80 a2 80
>1a82ac	62 81 a2 80 a2 80 a2 80		                .word <>MN_BVC, <>MN_EOR, <>MN_EOR, <>MN_EOR, <>MN_MVN, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 5x
>1a82b4	fa 81 a2 80 c2 80 a2 80
>1a82bc	2a 81 a2 80 8a 81 c2 81		                .word <>MN_CLI, <>MN_EOR, <>MN_PHY, <>MN_TCD, <>MN_JML, <>MN_EOR, <>MN_LSR, <>MN_EOR
>1a82c4	06 82 a2 80 c2 80 a2 80
>1a82cc	fe 80 a6 80 e6 81 a6 80		                .word <>MN_RTS, <>MN_ADC, <>MN_PER, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 6x
>1a82d4	82 81 a6 80 c6 80 a6 80
>1a82dc	0e 81 a6 80 c6 80 a6 81		                .word <>MN_PLA, <>MN_ADC, <>MN_ROR, <>MN_RTL, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>1a82e4	de 80 a6 80 c6 80 a6 80
>1a82ec	66 81 a6 80 a6 80 a6 80		                .word <>MN_BVS, <>MN_ADC, <>MN_ADC, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 7x
>1a82f4	82 81 a6 80 c6 80 a6 80
>1a82fc	2e 81 a6 80 8e 81 c6 81		                .word <>MN_SEI, <>MN_ADC, <>MN_PLY, <>MN_TDC, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>1a8304	de 80 a6 80 c6 80 a6 80
>1a830c	86 81 aa 80 ea 81 aa 80		                .word <>MN_BRA, <>MN_STA, <>MN_BRL, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 8x
>1a8314	e2 80 aa 80 ca 80 aa 80
>1a831c	12 81 da 80 42 81 aa 81		                .word <>MN_DEY, <>MN_BIT, <>MN_TXA, <>MN_PHB, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA
>1a8324	e2 80 aa 80 ca 80 aa 80
>1a832c	6a 81 aa 80 aa 80 aa 80		                .word <>MN_BCC, <>MN_STA, <>MN_STA, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 9x
>1a8334	e2 80 aa 80 ca 80 aa 80
>1a833c	32 81 aa 80 46 81 ca 81		                .word <>MN_TYA, <>MN_STA, <>MN_TXS, <>MN_TXY, <>MN_STZ, <>MN_STA, <>MN_STZ, <>MN_STA
>1a8344	82 81 aa 80 82 81 aa 80
>1a834c	e6 80 ae 80 ce 80 ae 80		                .word <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Ax
>1a8354	e6 80 ae 80 ce 80 ae 80
>1a835c	16 81 ae 80 4a 81 ae 81		                .word <>MN_TAY, <>MN_LDA, <>MN_TAX, <>MN_PLB, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>1a8364	e6 80 ae 80 ce 80 ae 80
>1a836c	6e 81 ae 80 ae 80 ae 80		                .word <>MN_BCS, <>MN_LDA, <>MN_LDA, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Bx
>1a8374	e6 80 ae 80 ce 80 ae 80
>1a837c	36 81 ae 80 4e 81 ce 81		                .word <>MN_CLV, <>MN_LDA, <>MN_TSX, <>MN_TYX, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>1a8384	e6 80 ae 80 ce 80 ae 80
>1a838c	ea 80 b2 80 ee 81 b2 80		                .word <>MN_CPY, <>MN_CMP, <>MN_REP, <>MN_CMP, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Cx
>1a8394	ea 80 b2 80 d2 80 b2 80
>1a839c	1a 81 b2 80 52 81 b2 81		                .word <>MN_INY, <>MN_CMP, <>MN_DEX, <>MN_WAI, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP
>1a83a4	ea 80 b2 80 d2 80 b2 80
>1a83ac	72 81 b2 80 b2 80 b2 80		                .word <>MN_BNE, <>MN_CMP, <>MN_CMP, <>MN_CMP, <>MN_PEI, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Dx
>1a83b4	fe 81 b2 80 d2 80 b2 80
>1a83bc	3a 81 b2 80 92 81 d2 81		                .word <>MN_CLD, <>MN_CMP, <>MN_PHX, <>MN_STP, <>MN_JML, <>MN_CMP, <>MN_DEC, <>MN_CMP
>1a83c4	06 82 b2 80 d2 80 b2 80
>1a83cc	ee 80 b6 80 f2 81 b6 80		                .word <>MN_CPX, <>MN_SBC, <>MN_SEP, <>MN_SBC, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Ex
>1a83d4	ee 80 b6 80 d6 80 b6 80
>1a83dc	1e 81 b6 80 56 81 b6 81		                .word <>MN_INX, <>MN_SBC, <>MN_NOP, <>MN_XBA, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC
>1a83e4	ee 80 b6 80 d6 80 b6 80
>1a83ec	76 81 b6 80 b6 80 b6 80		                .word <>MN_BEQ, <>MN_SBC, <>MN_SBC, <>MN_SBC, <>MN_PEA, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Fx
>1a83f4	02 82 b6 80 d6 80 b6 80
>1a83fc	3e 81 b6 80 96 81 d6 81		                .word <>MN_SED, <>MN_SBC, <>MN_PLX, <>MN_XCE, <>MN_JSR, <>MN_SBC, <>MN_INC, <>MN_SBC
>1a8404	f6 80 b6 80 d6 80 b6 80
>1a840c	00 00				                .word 0
>1a840e	13 00 02 09			ADDRESS_TAB     .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R                  ; 0x
>1a8412	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8416	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a841a	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a841e	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 1x
>1a8422	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8426	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>1a842a	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a842e	03 00 0b 09			                .byte ADDR_ABS, ADDR_DP_IND_X, ADDR_ABS_LONG, ADDR_SP_R                 ; 2x
>1a8432	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8436	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a843a	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a843e	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 3x
>1a8442	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8446	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>1a844a	07 07 07 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a844e	13 00 13 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMPLIED, ADDR_SP_R              ; 4x
>1a8452	14 01 01 0a			                .byte ADDR_XYC, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8456	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a845a	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a845e	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 5x
>1a8462	14 05 05 0d			                .byte ADDR_XYC, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8466	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a846a	0b 07 07 0b			                .byte ADDR_ABS_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_LONG
>1a846e	13 00 16 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R          ; 6x
>1a8472	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8476	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a847a	15 03 03 0b			                .byte ADDR_ABS_IND, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a847e	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 7x
>1a8482	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8486	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a848a	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a848e	12 00 16 09			                .byte ADDR_PC_REL, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R           ; 8x
>1a8492	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8496	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a849a	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a849e	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 9x
>1a84a2	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>1a84a6	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a84aa	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a84ae	82 00 42 09			                .byte ADDR_IMM | OP_M_EFFECT, ADDR_DP_IND_X, ADDR_IMM | OP_X_EFFECT, ADDR_SP_R  ; Ax
>1a84b2	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a84b6	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a84ba	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a84be	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Bx
>1a84c2	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>1a84c6	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a84ca	07 07 06 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_Y, ADDR_ABS_X_LONG
>1a84ce	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Cx
>1a84d2	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a84d6	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a84da	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a84de	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Dx
>1a84e2	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a84e6	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a84ea	17 07 07 0e			                .byte ADDR_ABS_IND_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a84ee	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Ex
>1a84f2	01 01 01 0f			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_IND
>1a84f6	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a84fa	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a84fe	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Fx
>1a8502	03 05 05 0d			                .byte ADDR_ABS, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8506	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a850a	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a850e	01 01 01 02 01 01 02 02		ADDR_LENGTH     .byte 1, 1, 1, 2, 1, 1, 2, 2, 0, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 0, 2, 2, 2, 2
>1a8516	00 01 01 03 01 01 03 01 02 01 01 00 02 02 02 02
.1a8526					ADDR_PATTERNS
>1a8526	41 00				            .null "A"
>1a8528	08				            .byte ADDR_ACC
>1a8529	64 64 3a 64 64 64 64 2c		            .null "dd:dddd,X"
>1a8531	58 00
>1a8533	0e				            .byte ADDR_ABS_X_LONG
>1a8534	64 64 3a 64 64 64 64 00		            .null "dd:dddd"
>1a853c	0b				            .byte ADDR_ABS_LONG
>1a853d	64 64 64 64 2c 58 00		            .null "dddd,X"
>1a8544	07				            .byte ADDR_ABS_X
>1a8545	64 64 64 64 2c 59 00		            .null "dddd,Y"
>1a854c	06				            .byte ADDR_ABS_Y
>1a854d	64 64 64 64 00			            .null "dddd"
>1a8552	03				            .byte ADDR_ABS
>1a8553	64 64 2c 58 00			            .null "dd,X"
>1a8558	05				            .byte ADDR_DP_X
>1a8559	64 64 2c 59 00			            .null "dd,Y"
>1a855e	11				            .byte ADDR_DP_Y
>1a855f	64 64 2c 53 00			            .null "dd,S"
>1a8564	09				            .byte ADDR_SP_R
>1a8565	64 64 00			            .null "dd"
>1a8568	01				            .byte ADDR_DP
>1a8569	23 64 64 64 64 00		            .null "#dddd"
>1a856f	c2				            .byte ADDR_IMM | OP_M_EFFECT | OP_X_EFFECT
>1a8570	23 64 64 2c 23 64 64 00		            .null "#dd,#dd"
>1a8578	14				            .byte ADDR_XYC
>1a8579	23 64 64 00			            .null "#dd"
>1a857d	02				            .byte ADDR_IMM
>1a857e	28 64 64 2c 53 29 2c 59		            .null "(dd,S),Y"
>1a8586	00
>1a8587	0c				            .byte ADDR_SP_R_Y
>1a8588	28 64 64 64 64 2c 58 29		            .null "(dddd,X)"
>1a8590	00
>1a8591	10				            .byte ADDR_ABS_X_ID
>1a8592	28 64 64 64 64 29 00		            .null "(dddd)"
>1a8599	10				            .byte ADDR_ABS_X_ID
>1a859a	28 64 64 2c 58 29 00		            .null "(dd,X)"
>1a85a1	00				            .byte ADDR_DP_IND_X
>1a85a2	28 64 64 29 2c 59 00		            .null "(dd),Y"
>1a85a9	04				            .byte ADDR_DP_IND_Y
>1a85aa	28 64 64 29 00			            .null "(dd)"
>1a85af	0f				            .byte ADDR_DP_IND
>1a85b0	5b 64 64 64 64 5d 00		            .null "[dddd]"
>1a85b7	17				            .byte ADDR_ABS_IND_LONG
>1a85b8	5b 64 64 5d 2c 59 00		            .null "[dd],Y"
>1a85bf	0d				            .byte ADDR_DP_Y_LONG
>1a85c0	5b 64 64 5d 00			            .null "[dd]"
>1a85c5	0a				            .byte ADDR_DP_LONG
>1a85c6	00 00				                .byte 0, 0

;******  Return to file: src\monitor.s

.1a85c8					M_INC_CURSOR
.1a85c8	08		php		                PHP
.1a85c9	c2 20		rep #$20	            REP #$20
.1a85cb	48		pha		                PHA
.1a85cc	18		clc		                CLC
.1a85cd	af 7a 08 00	lda $00087a	                LDA MCURSOR
.1a85d1	69 01 00	adc #$0001	                ADC #1
.1a85d4	8f 7a 08 00	sta $00087a	                STA MCURSOR
.1a85d8	e2 20		sep #$20	            SEP #$20
.1a85da	af 7c 08 00	lda $00087c	                LDA MCURSOR+2
.1a85de	69 00		adc #$00	                ADC #0
.1a85e0	8f 7c 08 00	sta $00087c	                STA MCURSOR+2
.1a85e4	c2 20		rep #$20	            REP #$20
.1a85e6	68		pla		                PLA
.1a85e7	28		plp		                PLP
.1a85e8	6b		rtl		                RTL
.1a85e9					MPRINTB
.1a85e9	08		php		                PHP
.1a85ea	c2 10		rep #$10	            REP #$10
.1a85ec	e2 20		sep #$20	            SEP #$20
.1a85ee	da		phx		                PHX
.1a85ef	a2 08 00	ldx #$0008	                LDX #8          ; Set number of bits to print to 8
.1a85f2	0a		asl a		loop            ASL A           ; Shift MSB to C
.1a85f3	b0 08		bcs $1a85fd	                BCS is_one
.1a85f5	48		pha		                PHA             ; Save value to print
.1a85f6	a9 30		lda #$30	                LDA #'0'        ; Print '0'
.1a85f8	20 18 00	jsr $1a0018	            JSR PRINTC
.1a85fb	80 06		bra $1a8603	                BRA continue
.1a85fd	48		pha		is_one          PHA             ; Save value to print
.1a85fe	a9 31		lda #$31	                LDA #'1'        ; Print '1'
.1a8600	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8603	68		pla		continue        PLA
.1a8604	ca		dex		                DEX             ; Count down the bits to shift
.1a8605	d0 eb		bne $1a85f2	                BNE loop        ; And try the next one if there is one
.1a8607	fa		plx		                PLX             ; Otherwise, return
.1a8608	28		plp		                PLP
.1a8609	6b		rtl		                RTL
.1a860a					MSKIPWS
.1a860a	08		php		            PHP
.1a860b	c2 20		rep #$20	            REP #$20
.1a860d	48		pha		            PHA
.1a860e	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a8611	5b		tcd		            TCD
.1a8612	68		pla		            PLA
.1a8613	28		plp		            PLP
.1a8614	e2 20		sep #$20	            SEP #$20
.1a8616	a7 32		lda [$087a]	loop            LDA [MCURSOR]       ; Check the current character
.1a8618	f0 0a		beq $1a8624	                BEQ done            ; If NULL, we're done
.1a861a	c9 20		cmp #$20	                CMP #' '            ; Is it a space?
.1a861c	d0 06		bne $1a8624	                BNE done            ; No: we're done
.1a861e	22 c8 85 1a	jsl $1a85c8	                JSL M_INC_CURSOR    ; Yes, try the next one
.1a8622	80 f2		bra $1a8616	                BRA loop
.1a8624	6b		rtl		done            RTL
.1a8625					MPARSESTR
.1a8625	08		php		                PHP
.1a8626	08		php		            PHP
.1a8627	c2 20		rep #$20	            REP #$20
.1a8629	48		pha		            PHA
.1a862a	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a862d	5b		tcd		            TCD
.1a862e	68		pla		            PLA
.1a862f	28		plp		            PLP
.1a8630	22 c8 85 1a	jsl $1a85c8	                JSL M_INC_CURSOR                ; Point to the first character of the name
.1a8634	22 0a 86 1a	jsl $1a860a	                JSL MSKIPWS                     ; Skip white space
.1a8638	c2 30		rep #$30	            REP #$30
.1a863a	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.1a863c	c2 20		rep #$20	            REP #$20
.1a863e	29 ff 00	and #$00ff	                AND #$00FF
.1a8641	0a		asl a		                ASL A                           ; multiply it by forfour
.1a8642	0a		asl a		                ASL A
.1a8643	aa		tax		                TAX                             ; ... to get the index to the argument
.1a8644	a5 32		lda $087a	                LDA MCURSOR                     ; Set the argument to the address of the first byte
.1a8646	95 0d		sta $0855,x	                STA MARG1,X
.1a8648	a5 34		lda $087c	                LDA MCURSOR+2
.1a864a	95 0f		sta $0857,x	                STA MARG1+2,X
.1a864c	e2 20		sep #$20	            SEP #$20
.1a864e	a7 32		lda [$087a]	loop            LDA [MCURSOR]                   ; Scan to the closing double quote
.1a8650	f0 14		beq $1a8666	                BEQ done                        ; If NULL... treat it as a closed argument
.1a8652	c9 22		cmp #$22	                CMP #CHAR_DQUOTE
.1a8654	f0 06		beq $1a865c	                BEQ close_string
.1a8656	22 c8 85 1a	jsl $1a85c8	                JSL M_INC_CURSOR
.1a865a	80 f2		bra $1a864e	                BRA loop
.1a865c	a9 00		lda #$00	close_string    LDA #0                          ; Write a NULL to close the string
.1a865e	87 32		sta [$087a]	                STA [MCURSOR]
.1a8660	22 c8 85 1a	jsl $1a85c8	                JSL M_INC_CURSOR                ; And point to the next byte
.1a8664	e6 31		inc $0879	                INC MARG_LEN
.1a8666	28		plp		done            PLP
.1a8667	6b		rtl		                RTL
.1a8668					MPARSEARG
.1a8668	08		php		            PHP
.1a8669	c2 20		rep #$20	            REP #$20
.1a866b	48		pha		            PHA
.1a866c	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a866f	5b		tcd		            TCD
.1a8670	68		pla		            PLA
.1a8671	28		plp		            PLP
.1a8672	e2 20		sep #$20	            SEP #$20
.1a8674	64 4a		stz $0892	                STZ MTEMP                       ; Use MTEMP as a flag for having processed digits
.1a8676	c2 20		rep #$20	            REP #$20
.1a8678	64 50		stz $0898	                STZ MPARSEDNUM                  ; Clear the parsed number
.1a867a	64 52		stz $089a	                STZ MPARSEDNUM+2
.1a867c					pa_loop
.1a867c	e2 20		sep #$20	            SEP #$20
.1a867e	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Get the current character
.1a8680	c9 3a		cmp #$3a	                CMP #":"
.1a8682	f0 0d		beq $1a8691	                BEQ pa_next_char                ; Ignore any colons
.1a8684	20 5b 04	jsr $1a045b	            JSR ISHEX
.1a8687	90 0e		bcc $1a8697	                BCC finished_arg                ; No? We're done with this argument
.1a8689	22 00 7b 1a	jsl $1a7b00	                JSL AS_SHIFT_HEX                ; Yes: shift it onto MPARSEDNUM
.1a868d	a9 01		lda #$01	                LDA #1                          ; Flag that we've processed a character
.1a868f	85 4a		sta $0892	                STA MTEMP
.1a8691	22 c8 85 1a	jsl $1a85c8	pa_next_char    JSL M_INC_CURSOR                ; And try the next character
.1a8695	80 e5		bra $1a867c	                BRA pa_loop
.1a8697	a5 4a		lda $0892	finished_arg    LDA MTEMP                       ; Check to see if we've processed any characters
.1a8699	f0 16		beq $1a86b1	                BEQ done                        ; No: we're done
.1a869b	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.1a869d	c2 20		rep #$20	            REP #$20
.1a869f	29 ff 00	and #$00ff	                AND #$00FF
.1a86a2	0a		asl a		                ASL A                           ; multiply it by forfour
.1a86a3	0a		asl a		                ASL A
.1a86a4	aa		tax		                TAX                             ; ... to get the index to the argument
.1a86a5	a5 50		lda $0898	                LDA MPARSEDNUM                  ; Copy the value to the argument slot
.1a86a7	95 0d		sta $0855,x	                STA MARG1,X
.1a86a9	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a86ab	95 0f		sta $0857,x	                STA MARG1+2,X
.1a86ad	e2 20		sep #$20	            SEP #$20
.1a86af	e6 31		inc $0879	                INC MARG_LEN                    ; And bump up the argument count
.1a86b1	6b		rtl		done            RTL
.1a86b2					MPARSEALLARG
.1a86b2	e2 20		sep #$20	            SEP #$20
.1a86b4	64 31		stz $0879	                STZ MARG_LEN                    ; Set the arg count to 0
.1a86b6	22 0a 86 1a	jsl $1a860a	parse_arg       JSL MSKIPWS                     ; Otherwise, skip white space
.1a86ba	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Check the current character
.1a86bc	f0 21		beq $1a86df	                BEQ done                        ; If it is NULL, we're done
.1a86be	c9 22		cmp #$22	                CMP #CHAR_DQUOTE                ; Is it a double-quote?
.1a86c0	d0 06		bne $1a86c8	                BNE regular_arg
.1a86c2	22 25 86 1a	jsl $1a8625	                JSL MPARSESTR                   ; Yes: parse it as a string argument
.1a86c6	80 0a		bra $1a86d2	                BRA check_rest
.1a86c8	22 68 86 1a	jsl $1a8668	regular_arg     JSL MPARSEARG                   ; Attempt to parse the argument
.1a86cc	a5 31		lda $0879	                LDA MARG_LEN                    ; Check how many arguments we've processed
.1a86ce	c9 09		cmp #$09	                CMP #9
.1a86d0	b0 0d		bcs $1a86df	                BGE done                        ; If >=9, then we're done
.1a86d2	a7 32		lda [$087a]	check_rest      LDA [MCURSOR]                   ; Check the current character
.1a86d4	f0 09		beq $1a86df	                BEQ done                        ; If EOL: we're done
.1a86d6	c9 20		cmp #$20	                CMP #' '
.1a86d8	f0 dc		beq $1a86b6	                BEQ parse_arg                   ; If space: try to process another argument
.1a86da	20 5b 04	jsr $1a045b	            JSR ISHEX
.1a86dd	b0 d7		bcs $1a86b6	                BCS parse_arg                   ; If hex digit: try to process another argument
.1a86df	6b		rtl		done            RTL
.1a86e0					IMPARSE
.1a86e0	08		php		                PHP
.1a86e1	0b		phd		                PHD
.1a86e2	08		php		            PHP
.1a86e3	c2 20		rep #$20	            REP #$20
.1a86e5	48		pha		            PHA
.1a86e6	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a86e9	5b		tcd		            TCD
.1a86ea	68		pla		            PLA
.1a86eb	28		plp		            PLP
.1a86ec	c2 10		rep #$10	            REP #$10
.1a86ee	e2 20		sep #$20	            SEP #$20
.1a86f0	a2 31 00	ldx #$0031	                LDX #MARG_LEN - MONITOR_VARS    ; Clear the monitor command line parameters
.1a86f3	74 00		stz $0848,x	clear_command   STZ MONITOR_VARS,X
.1a86f5	ca		dex		                DEX
.1a86f6	d0 fb		bne $1a86f3	                BNE clear_command
.1a86f8	a9 00		lda #$00	                LDA #`INPUTBUF                  ; Point the command parser to the input buffer
.1a86fa	85 02		sta $084a	                STA MCMDADDR+2
.1a86fc	85 34		sta $087c	                STA MCURSOR+2                   ; And point MCURSOR there too
.1a86fe	c2 20		rep #$20	            REP #$20
.1a8700	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF
.1a8703	85 00		sta $0848	                STA MCMDADDR
.1a8705	85 32		sta $087a	                STA MCURSOR
.1a8707	e2 20		sep #$20	            SEP #$20
.1a8709	22 0a 86 1a	jsl $1a860a	                JSL MSKIPWS                     ; Skip to the first letter of the command
.1a870d	c9 00		cmp #$00	                CMP #0                          ; Is the current character a NULL?
.1a870f	f0 38		beq $1a8749	                BEQ done                        ; Yes: there's no command here
.1a8711	c2 20		rep #$20	            REP #$20
.1a8713	a5 32		lda $087a	                LDA MCURSOR
.1a8715	85 08		sta $0850	                STA MCMD
.1a8717	e2 20		sep #$20	            SEP #$20
.1a8719	a5 34		lda $087c	                LDA MCURSOR+2
.1a871b	85 0a		sta $0852	                STA MCMD+2
.1a871d	a2 01 00	ldx #$0001	                LDX #1
.1a8720	22 c8 85 1a	jsl $1a85c8	cmd_loop        JSL M_INC_CURSOR                ; Move to the next character
.1a8724	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; What is that character?
.1a8726	d0 06		bne $1a872e	                BNE cmd_space                   ; If not NULL: check for a space
.1a8728	86 0b		stx $0853	no_arguments    STX MCMD_LEN                    ; If NULL: Save the length of the command
.1a872a	64 31		stz $0879	                STZ MARG_LEN                    ; ... And the fact there are no arguments
.1a872c	80 1b		bra $1a8749	                BRA done                        ; ... And return
.1a872e	c9 20		cmp #$20	cmd_space       CMP #' '                        ; Is it a space?
.1a8730	f0 03		beq $1a8735	                BEQ found_cmd                   ; Yes: save the length
.1a8732	e8		inx		                INX                             ; No: go to the next character
.1a8733	80 eb		bra $1a8720	                BRA cmd_loop
.1a8735	86 0b		stx $0853	found_cmd       STX MCMD_LEN                    ; Save the length of the command
.1a8737	a9 00		lda #$00	                LDA #0
.1a8739	87 32		sta [$087a]	                STA [MCURSOR]                   ; Write a NULL to the end of the command
.1a873b	22 c8 85 1a	jsl $1a85c8	                JSL M_INC_CURSOR                ; And skip to the next character
.1a873f	a7 08		lda [$0850]	                LDA [MCMD]                      ; Check the command
.1a8741	c9 41		cmp #$41	                CMP #'A'
.1a8743	f0 07		beq $1a874c	                BEQ parse_asm                   ; If 'A', parse the line for the assemble command
.1a8745	22 b2 86 1a	jsl $1a86b2	                JSL MPARSEALLARG
.1a8749	2b		pld		done            PLD
.1a874a	28		plp		                PLP
.1a874b	6b		rtl		                RTL
.1a874c	22 0a 86 1a	jsl $1a860a	parse_asm       JSL MSKIPWS                     ; Skip to the first letter of the address
.1a8750	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a8752	f0 f5		beq $1a8749	                BEQ done                        ; Exit if we got the end-of-line
.1a8754	22 68 86 1a	jsl $1a8668	                JSL MPARSEARG                   ; Parse the first argument as the target address
.1a8758	22 0a 86 1a	jsl $1a860a	                JSL MSKIPWS                     ; Skip to the first letter of the mnemonic
.1a875c	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a875e	f0 e9		beq $1a8749	                BEQ done                        ; Exit if we got the end-of-line
.1a8760	c2 20		rep #$20	            REP #$20
.1a8762	a5 32		lda $087a	                LDA MCURSOR                     ; Save pointer to the start of the mnemonic
.1a8764	85 11		sta $0859	                STA MARG2
.1a8766	e2 20		sep #$20	            SEP #$20
.1a8768	a5 34		lda $087c	                LDA MCURSOR+2
.1a876a	85 13		sta $085b	                STA MARG2+2
.1a876c	22 c8 85 1a	jsl $1a85c8	asm_find_sp     JSL M_INC_CURSOR                ; Find the space at the end of the mnemonic
.1a8770	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a8772	f0 26		beq $1a879a	                BEQ asm_no_operand              ; If EOL: we have an instruction but no operand
.1a8774	c9 20		cmp #$20	                CMP #' '
.1a8776	d0 f4		bne $1a876c	                BNE asm_find_sp
.1a8778	a9 00		lda #$00	                LDA #0
.1a877a	87 32		sta [$087a]	                STA [MCURSOR]                   ; Null terminate the mnemonic
.1a877c	e6 31		inc $0879	                INC MARG_LEN                    ; Count the mnemonic as an argument
.1a877e	22 c8 85 1a	jsl $1a85c8	                JSL M_INC_CURSOR
.1a8782	22 0a 86 1a	jsl $1a860a	                JSL MSKIPWS                     ; Skip to the addressing mode
.1a8786	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a8788	f0 bf		beq $1a8749	                BEQ done                        ; If EOL: we're done
.1a878a	c2 20		rep #$20	            REP #$20
.1a878c	a5 32		lda $087a	                LDA MCURSOR                     ; Set the pointer to the addressing mode
.1a878e	85 15		sta $085d	                STA MARG3
.1a8790	e2 20		sep #$20	            SEP #$20
.1a8792	a5 34		lda $087c	                LDA MCURSOR+2
.1a8794	85 17		sta $085f	                STA MARG3+2
.1a8796	e6 31		inc $0879	                INC MARG_LEN                    ; And count it as the second argument
.1a8798	80 af		bra $1a8749	                BRA done                        ; and return
.1a879a	e6 31		inc $0879	asm_no_operand  INC MARG_LEN                    ; Increment the argument count
.1a879c	80 ab		bra $1a8749	                BRA done                        ; And quit
.1a879e					IMLOAD
.1a879e	08		php		                PHP
.1a879f	c2 10		rep #$10	            REP #$10
.1a87a1	e2 20		sep #$20	            SEP #$20
.1a87a3	a5 31		lda $0879	                LDA MARG_LEN
.1a87a5	d0 0f		bne $1a87b6	                BNE get_arguments
.1a87a7	a2 94 88	ldx #$8894	bad_arguments   LDX #<>MERRARGS                 ; Print bad arguments error
.1a87aa	a9 1a		lda #$1a	                LDA #`MERRARGS
.1a87ac	48		pha		                PHA
.1a87ad	ab		plb		                PLB
.1a87ae	20 b3 03	jsr $1a03b3	            JSR PRINTS
.1a87b1	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a87b4	80 61		bra $1a8817	                BRA done
.1a87b6					get_arguments
.1a87b6	c2 20		rep #$20	            REP #$20
.1a87b8	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.1a87ba	8f 23 08 00	sta $000823	                STA ARGUMENT1
.1a87be	a5 0f		lda $0857	                LDA MARG1+2
.1a87c0	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.1a87c4	20 87 69	jsr $1a6987	            JSR SETFILEDESC
.1a87c7	e2 20		sep #$20	            SEP #$20
.1a87c9	a5 31		lda $0879	                LDA MARG_LEN
.1a87cb	c9 01		cmp #$01	                CMP #1
.1a87cd	d0 0f		bne $1a87de	                BNE get_dest
.1a87cf	c2 20		rep #$20	            REP #$20
.1a87d1	a9 ff ff	lda #$ffff	                LDA #$FFFF                      ; Destination address not provided...
.1a87d4	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR              ; ... set it to something sane
.1a87d8	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a87dc	80 0e		bra $1a87ec	                BRA try_load
.1a87de					get_dest
.1a87de	c2 20		rep #$20	            REP #$20
.1a87e0	a5 11		lda $0859	                LDA MARG2                       ; Set the destination address from the arguments
.1a87e2	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a87e6	a5 13		lda $085b	                LDA MARG2+2
.1a87e8	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a87ec	22 18 11 00	jsl $001118	try_load        JSL FK_LOAD                     ; Try to load the file
.1a87f0	b0 25		bcs $1a8817	                BCS done
.1a87f2					error
.1a87f2	e2 20		sep #$20	            SEP #$20
.1a87f4	a2 ba 88	ldx #$88ba	                LDX #<>MCANTLOAD                ; Print bad arguments error
.1a87f7	a9 1a		lda #$1a	                LDA #`MCANTLOAD
.1a87f9	48		pha		                PHA
.1a87fa	ab		plb		                PLB
.1a87fb	20 b3 03	jsr $1a03b3	            JSR PRINTS
.1a87fe	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.1a8802	20 dd 03	jsr $1a03dd	            JSR PRHEXB
.1a8805	a9 20		lda #$20	                LDA #' '
.1a8807	20 18 00	jsr $1a0018	            JSR PRINTC
.1a880a	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.1a880e	20 dd 03	jsr $1a03dd	            JSR PRHEXB
.1a8811	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a8814	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a8817	28		plp		done            PLP
.1a8818	6b		rtl		                RTL
.1a8819					IMSAVE
.1a8819	8b		phb		                PHB
.1a881a	08		php		                PHP
.1a881b	c2 10		rep #$10	            REP #$10
.1a881d	e2 20		sep #$20	            SEP #$20
.1a881f	a5 31		lda $0879	                LDA MARG_LEN
.1a8821	c9 03		cmp #$03	                CMP #3
.1a8823	f0 0f		beq $1a8834	                BEQ get_arguments
.1a8825	a2 94 88	ldx #$8894	                LDX #<>MERRARGS                 ; Print bad arguments error
.1a8828	a9 1a		lda #$1a	                LDA #`MERRARGS
.1a882a	48		pha		                PHA
.1a882b	ab		plb		                PLB
.1a882c	20 b3 03	jsr $1a03b3	            JSR PRINTS
.1a882f	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a8832	80 54		bra $1a8888	                BRA done
.1a8834					get_arguments
.1a8834	c2 20		rep #$20	            REP #$20
.1a8836	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.1a8838	8f 23 08 00	sta $000823	                STA ARGUMENT1
.1a883c	a5 0f		lda $0857	                LDA MARG1+2
.1a883e	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.1a8842	20 87 69	jsr $1a6987	            JSR SETFILEDESC
.1a8845	a5 11		lda $0859	                LDA MARG2                       ; Set the starting address
.1a8847	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.1a884b	a5 13		lda $085b	                LDA MARG2+2
.1a884d	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.1a8851	a5 15		lda $085d	                LDA MARG3                       ; Set the ending address
.1a8853	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.1a8857	a5 17		lda $085f	                LDA MARG3+2
.1a8859	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.1a885d	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                     ; Save the data
.1a8861	b0 25		bcs $1a8888	                BCS done
.1a8863					error
.1a8863	e2 20		sep #$20	            SEP #$20
.1a8865	a2 a4 88	ldx #$88a4	                LDX #<>MCANTSAVE                ; Print bad arguments error
.1a8868	a9 1a		lda #$1a	                LDA #`MCANTSAVE
.1a886a	48		pha		                PHA
.1a886b	ab		plb		                PLB
.1a886c	20 b3 03	jsr $1a03b3	            JSR PRINTS
.1a886f	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.1a8873	20 dd 03	jsr $1a03dd	            JSR PRHEXB
.1a8876	a9 20		lda #$20	                LDA #' '
.1a8878	20 18 00	jsr $1a0018	            JSR PRINTC
.1a887b	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.1a887f	20 dd 03	jsr $1a03dd	            JSR PRHEXB
.1a8882	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a8885	20 26 03	jsr $1a0326	            JSR PRINTCR
.1a8888	28		plp		done            PLP
.1a8889	ab		plb		                PLB
.1a888a	6b		rtl		                RTL
.1a888b	5c 0a 27 1a	jmp $1a270a	IMEXIT          JML INTERACT
.1a888f	6b		rtl		IMRETURN        RTL ; Handle RETURN key (ie: execute command)
.1a8890	00		brk #		IMPARSE1        BRK ; Parse one word on the current command line
.1a8891	00		brk #		IMASSEMBLEA     BRK ; Assemble a line of text.
.1a8892	00		brk #		IMVERIFY        BRK ; Verify memory and file on disk
.1a8893	00		brk #		IMDOS           BRK ; Execute DOS command
.1a8894					MMESSAGES
>1a8894	42 61 64 20 61 72 67 75		MERRARGS        .null "Bad arguments",CHAR_CR,CHAR_CR
>1a889c	6d 65 6e 74 73 0d 0d 00
>1a88a4	55 6e 61 62 6c 65 20 74		MCANTSAVE       .null "Unable to save file: "
>1a88ac	6f 20 73 61 76 65 20 66 69 6c 65 3a 20 00
>1a88ba	55 6e 61 62 6c 65 20 74		MCANTLOAD       .null "Unable to load file: "
>1a88c2	6f 20 6c 6f 61 64 20 66 69 6c 65 3a 20 00
>1a88d0	0d 20 20 50 43 20 20 20		mregisters_msg  .null $0D,"  PC     A    X    Y    SP   DBR DP   NVMXDIZC",CHAR_CR
>1a88d8	20 20 41 20 20 20 20 58 20 20 20 20 59 20 20 20
>1a88e8	20 53 50 20 20 20 44 42 52 20 44 50 20 20 20 4e
>1a88f8	56 4d 58 44 49 5a 43 0d 00
>1a8901	41 43 44 46 47 4a 48 4c		MCOMMANDS       .null "ACDFGJHLMR;STVWX>?"
>1a8909	4d 52 3b 53 54 56 57 58 3e 3f 00

;******  Return to file: src\basic816.s

.1a8914	18		clc		START       CLC                 ; Go to native mode
.1a8915	fb		xce		            XCE
.1a8916	08		php		            PHP
.1a8917	c2 20		rep #$20	            REP #$20
.1a8919	48		pha		            PHA
.1a891a	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a891d	5b		tcd		            TCD
.1a891e	68		pla		            PLA
.1a891f	28		plp		            PLP
.1a8920	08		php		            PHP
.1a8921	e2 20		sep #$20	            SEP #$20
.1a8923	48		pha		            PHA
.1a8924	a9 00		lda #$00	            LDA #BASIC_BANK
.1a8926	48		pha		            PHA
.1a8927	ab		plb		            PLB
.1a8928	68		pla		            PLA
.1a8929	28		plp		            PLP
.1a892a	c2 30		rep #$30	            REP #$30
.1a892c	20 53 89	jsr $1a8953	            JSR INITBASIC
.1a892f	a9 ff fe	lda #$feff	            LDA #STACK_END      ; Set the system stack
.1a8932	1b		tcs		            TCS
.1a8933	08		php		            PHP
.1a8934	e2 20		sep #$20	            SEP #$20
.1a8936	48		pha		            PHA
.1a8937	a9 1a		lda #$1a	            LDA #`GREET
.1a8939	48		pha		            PHA
.1a893a	ab		plb		            PLB
.1a893b	68		pla		            PLA
.1a893c	28		plp		            PLP
.1a893d	a2 71 d2	ldx #$d271	            LDX #<>GREET
.1a8940	20 b3 03	jsr $1a03b3	            JSR PRINTS
.1a8943	08		php		            PHP
.1a8944	e2 20		sep #$20	            SEP #$20
.1a8946	48		pha		            PHA
.1a8947	a9 00		lda #$00	            LDA #BASIC_BANK
.1a8949	48		pha		            PHA
.1a894a	ab		plb		            PLB
.1a894b	68		pla		            PLA
.1a894c	28		plp		            PLP
.1a894d	4c 0a 27	jmp $1a270a	            JMP INTERACT        ; Start accepting input from the user
.1a8950	4c 50 89	jmp $1a8950	WAIT        JMP WAIT
.1a8953					INITBASIC
.1a8953	08		php		            PHP
.1a8954	20 be 02	jsr $1a02be	            JSR INITIO
.1a8957	20 f6 4e	jsr $1a4ef6	            JSR CMD_NEW
.1a895a	28		plp		            PLP
.1a895b	60		rts		            RTS
>1ad271	43 32 35 36 20 46 6f 65		GREET       .text "C256 Foenix BASIC816 "
>1ad279	6e 69 78 20 42 41 53 49 43 38 31 36 20

;******  Processing file: src\version.s

>1ad286	76 30 2e 32 2e 30 2d 61		.text "v0.2.0-alpha+350"
>1ad28e	6c 70 68 61 2b 33 35 30

;******  Return to file: src\basic816.s

>1ad296	0d 00				            .byte 13,0

;******  End of listing
