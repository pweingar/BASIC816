
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -D SYSTEM=2 -D C256_SKU=2 -D UARTSUPPORT= -D UNITTEST=0 -D TRACE_LEVEL=0 --long-address --flat -b --m65816 --intel-hex -o basic816_1A0000.hex --list=basic816_1A0000.lst --labels=basic816_1A0000.lbl src\basic816.s
; Thu May 13 15:55:31 2021

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=2					SYSTEM=2
=2					C256_SKU=2
=					UARTSUPPORT=
=0					UNITTEST=0
=0					TRACE_LEVEL=0

;******  Processing input file: src\basic816.s


;******  Processing file: src\constants.s

=2					SYSTEM_C256 = 2         ; C256 Foenix
=1					SYSTEM_C64 = 1          ; Commodore 64 with SuperCPU
=$03					CHAR_CTRL_C = $03       ; CTRL-C: used as a program interrupt key
=$07					CHAR_BELL = $07         ; Ring the console bell
=$08					CHAR_BS = $08           ; Backspace
=$09					CHAR_TAB = $09          ; TAB
=$0a					CHAR_LF = $0A           ; Linefeed
=$0d					CHAR_CR = $0D           ; Carriage Return
=$0f					CHAR_INS = $0F          ; Insert
=$1b					CHAR_ESC = $1B          ; Escape
=$22					CHAR_DQUOTE = $22       ; Double quote
=$20					CHAR_SP = $20           ; Space
=$7f					CHAR_DEL = $7F          ; Delete
=5					ARGUMENT_SIZE = 5       ; Number of bytes in an argument
=8					VAR_NAME_SIZE = 8       ; Maximum number of characters in a variable name
=0					TYPE_INTEGER = 0        ; 32-bit integer
=1					TYPE_FLOAT = 1          ; Single-precision floating point
=2					TYPE_STRING = 2         ; ASCII string
=$80					TYPE_ARR_INTEGER = $80  ; Array of 32-bit integers
=$81					TYPE_ARR_FLOAT = $81    ; Array of 32-bit floats
=$82					TYPE_ARR_STRING = $82   ; Array of strings
=$7f					TYPE_BINDING = $7F      ; A variable name binding
=$ff					TYPE_NAV = $FF          ; Not-A-Value
=0					ERR_OK = 0              ; No error
=1					ERR_BREAK = 1           ; The user pressed an interrupt key
=2					ERR_SYNTAX = 2          ; A syntax error was found on the current line
=3					ERR_MEMORY = 3          ; Out of memory
=4					ERR_TYPE = 4            ; Type mismatch error
=5					ERR_NOTFOUND = 5        ; Variable not found error
=6					ERR_NOLINE = 6          ; Line number not found
=7					ERR_STACKUNDER = 7      ; Stack underflow error
=8					ERR_STACKOVER = 8       ; Stack overflow error
=9					ERR_RANGE = 9           ; Out-of-range error
=10					ERR_ARGUMENT = 10       ; Bad argument error
=11					ERR_NOFILE = 11         ; File not found error
=12					ERR_NAN = 12            ; Floating point math resulted in something that is not a number
=13					ERR_OVERFLOW = 13       ; Math operation overflowed
=14					ERR_UNDERFLOW = 14      ; Math operation underflowed
=15					ERR_DIV0 = 15           ; Math operation involved a division by zero
=16					ERR_DIRECTORY = 16      ; Error reading the directory
=17					ERR_LOAD = 17           ; Could not load file
=18					ERR_SAVE = 18           ; Could not save a file
=19					ERR_DELETE = 19         ; Could not delete a file
=20					ERR_FILENOTFOUND = 20   ; Could not find the file
=21					ERR_DIRNOTWRITE = 21    ; Could not update the directory entry
=22					ERR_NOTCOPIED = 22      ; Could not copy the file
=23					ERR_DOMAIN = 23         ; Mathematical functions domain error

;******  Return to file: src\basic816.s


;******  Processing file: src\memorymap.s


;******  Processing file: src\C256/mmap_c256.s

=1					SYS_C256_FMX = 1        ; System SKU for C256 Foenix FMX
=2					SYS_C256_USER = 2       ; System SKU for C256 Foenix User

;******  Processing file: src\C256/page_00_inc.s

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				unused_0000      = $000000 ;12 Bytes unused
=$000008				OPL2_ADDY_PTR_LO = $000008  ; THis Points towards the Instruments Database
=$000009				OPL2_ADDY_PTR_MD = $000009
=$00000a				OPL2_ADDY_PTR_HI = $00000A
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;1 Byte Color of next character to be printed to the screen.
=$00001f				COLORPOS         = $00001F ;3 Byte address of cursor's position in the color matrix
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$000026				OPL2_OPERATOR    = $000026 ;
=$000027				OPL2_CHANNEL     = $000027 ;
=$000028				OPL2_REG_REGION  = $000028 ; Offset to the Group of Registers
=$00002a				OPL2_REG_OFFSET  = $00002A ; 2 Bytes (16Bits)
=$00002c				OPL2_IND_ADDY_LL = $00002C ; 2 Bytes Reserved (Only need 3)
=$00002e				OPL2_IND_ADDY_HL = $00002E ; 2 Bytes Reserved (Only need 3)
=$000030				OPL2_NOTE        = $000030 ; 1 Byte
=$000031				OPL2_OCTAVE      = $000031 ; 1 Byte
=$000032				OPL2_PARAMETER0  = $000032 ; 1 Byte - Key On/Feedback
=$000033				OPL2_PARAMETER1  = $000033 ; 1 Byte
=$000034				OPL2_PARAMETER2  = $000034 ; 1 Byte
=$000035				OPL2_PARAMETER3  = $000035 ; 1 Byte
=$000036				OPL2_LOOP        = $000036 ;
=$000036				OPL2_BLOCK       = $000036
=$000038				SDCARD_FILE_PTR  = $000038 ; 3 Bytes Pointer to Filename to open
=$00003c				SDCARD_BYTE_NUM  = $00003C ; 2Bytes
=$00003f				SDCARD_PRSNT_MNT = $00003F ; 1 Byte, Indicate that the SDCard is Present and that it is Mounted
=$000040				BM_CLEAR_SCRN_X  = $000040
=$000042				BM_CLEAR_SCRN_Y  = $000042
=$000040				RAD_STARTLINE    = $000040 ; 1 Byte
=$000041				RAD_PATTERN_IDX  = $000041 ; 1 Byte
=$000042				RAD_LINE         = $000042 ; 1 Byte
=$000043				RAD_LINENUMBER   = $000043 ; 1 Byte
=$000044				RAD_CHANNEL_NUM  = $000044 ; 1 Byte
=$000045				RAD_ISLASTCHAN   = $000045 ; 1 Byte
=$000046				RAD_Y_POINTER    = $000046 ; 2 Bytes
=$000048				RAD_TICK         = $000048
=$00004a				RAD_CHANNEL_DATA = $00004A ; 2 Bytes
=$00004c				RAD_CHANNE_EFFCT = $00004C
=$00004d				RAD_TEMP         = $00004D
=$000050				RAD_ADDR         = $000050 ; 3 bytes to avoid OPL2 errors.
=$000053				RAD_PATTRN       = $000053 ; 1 bytes - offset to patter
=$000054				RAD_PTN_DEST     = $000054 ; 3 bytes - where to write the pattern data
=$000057				RAD_CHANNEL      = $000057 ; 2 bytes - 0 to 8
=$000059				RAD_LAST_NOTE    = $000059 ; 1 if this is the last note
=$00005a				RAD_LINE_PTR     = $00005A ; 2 bytes - offset to memory location
=$000040				BMP_X_SIZE       = $000040 ; 2 Bytes
=$000042				BMP_Y_SIZE       = $000042 ; 2 Bytes
=$000044				BMP_PRSE_SRC_PTR = $000044 ; 3 Bytes
=$000048				BMP_PRSE_DST_PTR = $000048 ; 3 Bytes
=$00004c				BMP_COLOR_PALET  = $00004C ; 2 Bytes
=$00004e				SCRN_X_STRIDE    = $00004E ; 2 Bytes, Basically How many Pixel Accross in Bitmap Mode
=$000050				BMP_FILE_SIZE    = $000050 ; 4 Bytes
=$000054				BMP_POSITION_X   = $000054 ; 2 Bytes Where, the BMP will be position on the X Axis
=$000056				BMP_POSITION_Y   = $000056 ; 2 Bytes Where, the BMP will be position on the Y Axis
=$000058				BMP_PALET_CHOICE = $000058 ;
=$0000e0				MOUSE_PTR        = $0000E0
=$0000e1				MOUSE_POS_X_LO   = $0000E1
=$0000e2				MOUSE_POS_X_HI   = $0000E2
=$0000e3				MOUSE_POS_Y_LO   = $0000E3
=$0000e4				MOUSE_POS_Y_HI   = $0000E4
=$0000f0				USER_TEMP        = $0000F0 ;32 Bytes Temp space for user programs
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000110				DIVIDER_0        = $000110 ;0 Byte  Unsigned divider
=$000110				D0_OPERAND_A     = $000110 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$000112				D0_OPERAND_B     = $000112 ;2 Bytes Divider 0 Divisor ex B in A/B
=$000114				D0_RESULT        = $000114 ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D0_REMAINDER     = $000116 ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000118				DIVIDER_1        = $000118 ;0 Byte  Signed divider
=$000118				D1_OPERAND_A     = $000118 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$00011a				D1_OPERAND_B     = $00011A ;2 Bytes Divider 1 Divisor ex B in A/B
=$00011c				D1_RESULT        = $00011C ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$00011e				D1_REMAINDER     = $00011E ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$000120				ADDER_SIGNED_32  = $000120 ; The 32 Bit Adders takes 12Byte that are NOT RAM Location
=$000140				INT_CONTROLLER   = $000140 ; $000140...$00015F Interrupt Controller
=$000160				TIMER_CONTROLLER = $000160 ; $000160...$00017F Timer0/Timer1/Timer2 Block
=$000160				TIMER_CTRL_REGLL = $000160 ;
=$000161				TIMER_CTRL_REGLH = $000161 ;
=$000162				TIMER_CTRL_REGHL = $000162 ;
=$000163				TIMER_CTRL_REGHH = $000163 ;
=$000240				CPU_REGISTERS    = $000240 ; Byte
=$000240				CPUPC            = $000240 ;2 Bytes Program Counter (PC)
=$000242				CPUPBR           = $000242 ;2 Bytes Program Bank Register (K)
=$000244				CPUA             = $000244 ;2 Bytes Accumulator (A)
=$000246				CPUX             = $000246 ;2 Bytes X Register (X)
=$000248				CPUY             = $000248 ;2 Bytes Y Register (Y)
=$00024a				CPUSTACK         = $00024A ;2 Bytes Stack Pointer (S)
=$00024c				CPUDP            = $00024C ;2 Bytes Direct Page Register (D)
=$00024e				CPUDBR           = $00024E ;1 Byte  Data Bank Register (B)
=$00024f				CPUFLAGS         = $00024F ;1 Byte  Flags (P)
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$000300				FDC_DRIVE        = $000300 ;1 byte - The number of the selected drive
=$000301				FDC_HEAD         = $000301 ;1 byte - The head number (0 or 1)
=$000302				FDC_CYLINDER     = $000302 ;1 byte - The cylinder number
=$000303				FDC_SECTOR       = $000303 ;1 byte - The sector number
=$000304				FDC_SECTOR_SIZE  = $000304 ;1 byte - The sector size code (2 = 512)
=$000305				FDC_SECPERTRK    = $000305 ;1 byte - The number of sectors per track (18 for 1.44 MB floppy)
=$000306				FDC_ST0          = $000306 ;1 byte - Status Register 0
=$000307				FDC_ST1          = $000307 ;1 byte - Status Register 1
=$000308				FDC_ST2          = $000308 ;1 byte - Status Register 2
=$000309				FDC_ST3          = $000309 ;1 byte - Status Register 3
=$00030a				FDC_PCN          = $00030A ;1 byte - Present Cylinder Number
=$00030b				FDC_STATUS       = $00030B ;1 byte - Status of what we think is going on with the FDC:
=$00030c				DIVIDEND         = $00030C ;4 bytes - Dividend for 32-bit division
=$000310				DIVISOR          = $000310 ;4 bytes - Divisor for 32-bit division
=$000314				REMAINDER        = $000314 ;4 bytes - Remainder for 32-bit division
=$000320				SDOS_VARIABLES   = $000320
=$000320				BIOS_STATUS      = $000320      ; 1 byte - Status of any BIOS operation
=$000321				BIOS_DEV         = $000321      ; 1 byte - Block device number for block operations
=$000322				BIOS_LBA         = $000322      ; 4 bytes - Address of block to read/write (this is the physical block, w/o reference to partition)
=$000326				BIOS_BUFF_PTR    = $000326      ; 4 bytes - 24-bit pointer to memory for read/write operations
=$00032a				BIOS_FIFO_COUNT  = $00032A      ; 2 bytes - The number of bytes read on the last block read
=$00032e				DOS_STATUS       = $00032E      ; 1 byte - The error code describing any error with file access
=$000330				DOS_CLUS_ID      = $000330      ; 4 bytes - The cluster desired for a DOS operation
=$000338				DOS_DIR_PTR      = $000338      ; 4 bytes - Pointer to a directory entry (assumed to be within DOS_SECTOR)
=$00033c				DOS_BUFF_PTR     = $00033C      ; 4 bytes - A pointer for DOS cluster read/write operations
=$000340				DOS_FD_PTR       = $000340      ; 4 bytes - A pointer to a file descriptor
=$000344				DOS_FAT_LBA      = $000344      ; 4 bytes - The LBA for a sector of the FAT we need to read/write
=$000348				DOS_TEMP         = $000348      ; 4 bytes - Temporary storage for DOS operations
=$00034c				DOS_FILE_SIZE    = $00034C      ; 4 bytes - The size of a file
=$000350				DOS_SRC_PTR      = $000350      ; 4 bytes - Pointer for transferring data
=$000354				DOS_DST_PTR      = $000354      ; 4 bytes - Pointer for transferring data
=$000358				DOS_END_PTR      = $000358      ; 4 bytes - Pointer to the last byte to save
=$00035c				DOS_RUN_PTR      = $00035C      ; 4 bytes - Pointer for starting a loaded program
=$000360				DOS_RUN_PARAM    = $000360      ; 4 bytes - Pointer to the ASCIIZ string for arguments in loading a program
=$000364				DOS_STR1_PTR     = $000364      ; 4 bytes - pointer to a string
=$000368				DOS_STR2_PTR     = $000368      ; 4 bytes - pointer to a string
=$00036b				DOS_SCRATCH      = $00036B      ; 4 bytes - general purpose short term storage
=$000400				DOS_PATH_BUFF    = $000400      ; 256 bytes - A buffer for path names
=$000500				FDC_PARAMETERS   = $000500      ; 16 bytes - a buffer of parameter data for the FDC
=$000510				FDC_RESULTS      = $000510      ; 16 bytes - Buffer for results of FDC commands
=$000530				FDC_PARAM_NUM    = $000530      ; 1 byte - The number of parameters to send to the FDC (including command)
=$000532				FDC_RESULT_NUM   = $000532      ; 1 byte - The number of results expected
=$000533				FDC_EXPECT_DAT   = $000533      ; 1 byte - 0 = the command expects no data, otherwise expects data
=$000534				FDC_CMD_RETRY    = $000534      ; 1 byte - a retry counter for commands
=$000700				CURRUART         = $000700 ; 3-bytes: the base address of the current UART
=$000703				CHAN_OUT         = $000703 ; 1-byte: the number of the current output channel (for PUTC, etc.)
=$000704				CHAN_IN          = $000704 ; 1-byte: the number of the current input channel (for GETCH, etc.)
=$000705				TIMERFLAGS       = $000705 ; 1-byte: flags to indicate that one of the timer interupts has triggered
=$80					TIMER0TRIGGER    = $80
=$40					TIMER1TRIGGER    = $40
=$20					TIMER2TRIGGER    = $20
=$000f00				KEY_BUFFER       = $000F00 ; 64 Bytes keyboard buffer
=$0080					KEY_BUFFER_SIZE  = $0080   ;128 Bytes (constant) keyboard buffer length
=$000f7f				KEY_BUFFER_END   = $000F7F ;  1 Byte  Last byte of keyboard buffer
=$000f83				KEY_BUFFER_CMD   = $000F83 ;  1 Byte  Indicates the Command Process Status
=$000f84				COMMAND_SIZE_STR = $000F84 ;  1 Byte
=$000f86				COMMAND_COMP_TMP = $000F86 ;  2 Bytes
=$000f87				KEYBOARD_SC_FLG  = $000F87 ;  1 Bytes that indicate the Status of Left Shift, Left CTRL, Left ALT, Right Shift
=$000f88				KEYBOARD_SC_TMP  = $000F88 ;  1 Byte, Interrupt Save Scan Code while Processing
=$000f89				KEYBOARD_LOCKS   = $000F89 ;  1 Byte, the status of the various lock keys
=$000f8a				KEYFLAG          = $000F8A ;  1 Byte, flag to indicate if CTRL-C has been pressed
=$000f8b				KEY_BUFFER_RPOS  = $000F8B ;  2 Byte, position of the character to read from the KEY_BUFFER
=$000f8d				KEY_BUFFER_WPOS  = $000F8D ;  2 Byte, position of the character to write to the KEY_BUFFER
=$001000				KERNEL_JMP_BEGIN = $001000 ; Reserved for the Kernel jump table
=$001fff				KERNEL_JMP_END   = $001FFF
=$002000				TEST_BEGIN       = $002000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/int_math_defs.s

=$000100				UNSIGNED_MULT_A_LO  = $000100
=$000101				UNSIGNED_MULT_A_HI  = $000101
=$000102				UNSIGNED_MULT_B_LO  = $000102
=$000103				UNSIGNED_MULT_B_HI  = $000103
=$000104				UNSIGNED_MULT_AL_LO = $000104
=$000105				UNSIGNED_MULT_AL_HI = $000105
=$000106				UNSIGNED_MULT_AH_LO = $000106
=$000107				UNSIGNED_MULT_AH_HI = $000107
=$000108				SIGNED_MULT_A_LO    = $000108
=$000109				SIGNED_MULT_A_HI    = $000109
=$00010a				SIGNED_MULT_B_LO    = $00010A
=$00010b				SIGNED_MULT_B_HI    = $00010B
=$00010c				SIGNED_MULT_AL_LO   = $00010C
=$00010d				SIGNED_MULT_AL_HI   = $00010D
=$00010e				SIGNED_MULT_AH_LO   = $00010E
=$00010f				SIGNED_MULT_AH_HI   = $00010F
=$000110				UNSIGNED_DIV_DEM_LO = $000110
=$000111				UNSIGNED_DIV_DEM_HI = $000111
=$000112				UNSIGNED_DIV_NUM_LO = $000112
=$000113				UNSIGNED_DIV_NUM_HI = $000113
=$000114				UNSIGNED_DIV_QUO_LO = $000114
=$000115				UNSIGNED_DIV_QUO_HI = $000115
=$000116				UNSIGNED_DIV_REM_LO = $000116
=$000117				UNSIGNED_DIV_REM_HI = $000117
=$000118				SIGNED_DIV_DEM_LO   = $000118
=$000119				SIGNED_DIV_DEM_HI   = $000119
=$00011a				SIGNED_DIV_NUM_LO   = $00011A
=$00011b				SIGNED_DIV_NUM_HI   = $00011B
=$00011c				SIGNED_DIV_QUO_LO   = $00011C
=$00011d				SIGNED_DIV_QUO_HI   = $00011D
=$00011e				SIGNED_DIV_REM_LO   = $00011E
=$00011f				SIGNED_DIV_REM_HI   = $00011F
=$000120				ADDER32_A_LL        = $000120
=$000121				ADDER32_A_LH        = $000121
=$000122				ADDER32_A_HL        = $000122
=$000123				ADDER32_A_HH        = $000123
=$000124				ADDER32_B_LL        = $000124
=$000125				ADDER32_B_LH        = $000125
=$000126				ADDER32_B_HL        = $000126
=$000127				ADDER32_B_HH        = $000127
=$000128				ADDER32_R_LL        = $000128
=$000129				ADDER32_R_LH        = $000129
=$00012a				ADDER32_R_HL        = $00012A
=$00012b				ADDER32_R_HH        = $00012B
=$af1400				SIGNED32_MULT_A     = $AF1400
=$af1404				SIGNED32_MULT_B     = $AF1404
=$af1408				SIGNED32_MULT_OUT   = $AF1408

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/vicky_def.s

=$af0000				MASTER_CTRL_REG_L	      = $AF0000
=$01					Mstr_Ctrl_Text_Mode_En  = $01       ; Enable the Text Mode
=$02					Mstr_Ctrl_Text_Overlay  = $02       ; Enable the Overlay of the text mode on top of Graphic Mode (the Background Color is ignored)
=$04					Mstr_Ctrl_Graph_Mode_En = $04       ; Enable the Graphic Mode
=$08					Mstr_Ctrl_Bitmap_En     = $08       ; Enable the Bitmap Module In Vicky
=$10					Mstr_Ctrl_TileMap_En    = $10       ; Enable the Tile Module in Vicky
=$20					Mstr_Ctrl_Sprite_En     = $20       ; Enable the Sprite Module in Vicky
=$40					Mstr_Ctrl_GAMMA_En      = $40       ; this Enable the GAMMA correction - The Analog and DVI have different color value, the GAMMA is great to correct the difference
=$80					Mstr_Ctrl_Disable_Vid   = $80       ; This will disable the Scanning of the Video hence giving 100% bandwith to the CPU
=$af0001				MASTER_CTRL_REG_H       = $AF0001
=$01					Mstr_Ctrl_Video_Mode0   = $01       ; 0 - 640x480 (Clock @ 25.175Mhz), 1 - 800x600 (Clock @ 40Mhz)
=$02					Mstr_Ctrl_Video_Mode1   = $02       ; 0 - No Pixel Doubling, 1- Pixel Doubling (Reduce the Pixel Resolution by 2)
=$af0002				GAMMA_CTRL_REG          = $AF0002
=$01					GAMMA_Ctrl_Input        = $01 ; 0 = DipSwitch Chooses GAMMA on/off , 1- Software Control
=$02					GAMMA_Ctrl_Soft         = $02 ; 0 = GAMMA Table is not Applied, 1 = GAMMA Table is Applied
=$08					GAMMA_DP_SW_VAL         = $08 ; READ ONLY - Actual DIP Switch Value
=$10					HIRES_DP_SW_VAL         = $10 ; READ ONLY - 0 = Hi-Res on BOOT ON, 1 = Hi-Res on BOOT OFF
=$af0003				VKY_RESERVED_01         = $AF0003
=$01					Border_Ctrl_Enable      = $01
=$af0004				BORDER_CTRL_REG         = $AF0004 ; Bit[0] - Enable (1 by default)  Bit[4..6]: X Scroll Offset ( Will scroll Left) (Acceptable Value: 0..7)
=$af0005				BORDER_COLOR_B          = $AF0005
=$af0006				BORDER_COLOR_G          = $AF0006
=$af0007				BORDER_COLOR_R          = $AF0007
=$af0008				BORDER_X_SIZE           = $AF0008; X-  Values: 0 - 32 (Default: 32)
=$af0009				BORDER_Y_SIZE           = $AF0009; Y- Values 0 -32 (Default: 32)
=$af000d				BACKGROUND_COLOR_B      = $AF000D ; When in Graphic Mode, if a pixel is "0" then the Background pixel is chosen
=$af000e				BACKGROUND_COLOR_G      = $AF000E
=$af000f				BACKGROUND_COLOR_R      = $AF000F ;
=$af0010				VKY_TXT_CURSOR_CTRL_REG = $AF0010   ;[0]  Enable Text Mode
=$01					Vky_Cursor_Enable       = $01
=$02					Vky_Cursor_Flash_Rate0  = $02       ; 00 - 1/Sec, 01 - 2/Sec, 10 - 4/Sec, 11 - 5/Sec
=$04					Vky_Cursor_Flash_Rate1  = $04
=$08					Vky_Cursor_FONT_Page0   = $08       ; Pick Font Page 0 or Font Page 1
=$10					Vky_Cursor_FONT_Page1   = $10       ; Pick Font Page 0 or Font Page 1
=$af0011				VKY_TXT_START_ADD_PTR   = $AF0011   ; This is an offset to change the Starting address of the Text Mode Buffer (in x)
=$af0012				VKY_TXT_CURSOR_CHAR_REG = $AF0012
=$af0013				VKY_TXT_CURSOR_COLR_REG = $AF0013
=$af0014				VKY_TXT_CURSOR_X_REG_L  = $AF0014
=$af0015				VKY_TXT_CURSOR_X_REG_H  = $AF0015
=$af0016				VKY_TXT_CURSOR_Y_REG_L  = $AF0016
=$af0017				VKY_TXT_CURSOR_Y_REG_H  = $AF0017
=$af001b				VKY_LINE_IRQ_CTRL_REG   = $AF001B ;[0] - Enable Line 0, [1] -Enable Line 1
=$af001c				VKY_LINE0_CMP_VALUE_LO  = $AF001C ;Write Only [7:0]
=$af001d				VKY_LINE0_CMP_VALUE_HI  = $AF001D ;Write Only [3:0]
=$af001e				VKY_LINE1_CMP_VALUE_LO  = $AF001E ;Write Only [7:0]
=$af001f				VKY_LINE1_CMP_VALUE_HI  = $AF001F ;Write Only [3:0]
=$af001c				VKY_INFO_CHIP_NUM_L     = $AF001C   ; VErsion
=$af001d				VKY_INFO_CHIP_NUM_H     = $AF001D   ; Version
=$af001e				VKY_INFO_CHIP_VER_L     = $AF001E   ; Sub-Version
=$af001f				VKY_INFO_CHIP_VER_H     = $AF001F   ; Sub-Version
=$af0500				MOUSE_PTR_GRAP0_START    = $AF0500 ; 16 x 16 = 256 Pixels (Grey Scale) 0 = Transparent, 1 = Black , 255 = White
=$af05ff				MOUSE_PTR_GRAP0_END      = $AF05FF ; Pointer 0
=$af0600				MOUSE_PTR_GRAP1_START    = $AF0600 ;
=$af06ff				MOUSE_PTR_GRAP1_END      = $AF06FF ; Pointer 1
=$af0700				MOUSE_PTR_CTRL_REG_L    = $AF0700 ; Bit[0] Enable, Bit[1] = 0  ( 0 = Pointer0, 1 = Pointer1)
=$af0701				MOUSE_PTR_CTRL_REG_H    = $AF0701 ;
=$af0702				MOUSE_PTR_X_POS_L       = $AF0702 ; X Position (0 - 639) (Can only read now) Writing will have no effect
=$af0703				MOUSE_PTR_X_POS_H       = $AF0703 ;
=$af0704				MOUSE_PTR_Y_POS_L       = $AF0704 ; Y Position (0 - 479) (Can only read now) Writing will have no effect
=$af0705				MOUSE_PTR_Y_POS_H       = $AF0705 ;
=$af0706				MOUSE_PTR_BYTE0         = $AF0706 ; Byte 0 of Mouse Packet (you must write 3 Bytes)
=$af0707				MOUSE_PTR_BYTE1         = $AF0707 ; Byte 1 of Mouse Packet (if you don't, then )
=$af0708				MOUSE_PTR_BYTE2         = $AF0708 ; Byte 2 of Mouse Packet (state Machine will be jammed in 1 state)
=$af070b				C256F_MODEL_MAJOR       = $AF070B ;
=$af070c				C256F_MODEL_MINOR       = $AF070C ;
=$af070d				FPGA_DOR                = $AF070D ;
=$af070e				FPGA_MOR                = $AF070E ;
=$af070f				FPGA_YOR                = $AF070F ;
=$af0900				VMEM2CPU_CTRL_REG      = $AF0900  ;
=$01					VMEM2CPU_Clear_FIFO    = $01        ; Setting this to 1 will flush (Reset) the FIFO, clear it after to return to normal function
=$02					VMEM2CPU_Intterupt     = $02        ; This is not implemented because there is not enough Interrupt line on the FMX
=$af0901				VMEM2CPU_Data_Port     = $AF0901    ; This is a Byte Port of the data that you have requested. (Output of the FIFO)
=$af0902				VMEM2CPU_Fifo_Count_LO = $AF0902    ; FIFO Count Lo (number of byte in the FIFO) FIFO Count is 10bits, Count_Bit0 to Count_Bit7 of Count
=$af0903				VMEM2CPU_Fifo_Count_HI = $AF0903    ; FIFO Count Hi, Bit 0 = Count_Bit8, Bit 1 = Count_Bit9
=$80					VMEM2CPU_Fifo_Empty    = $80        ; Bit 7 of VMEM2CPU_Fifo_Count_HI, when 1, the FIFO is empty.
=$af1f40				FG_CHAR_LUT_PTR         = $AF1F40
=$af1f80				BG_CHAR_LUT_PTR		    = $AF1F80
=$af2000				GRPH_LUT0_PTR		    = $AF2000
=$af2400				GRPH_LUT1_PTR		    = $AF2400
=$af2800				GRPH_LUT2_PTR		    = $AF2800
=$af2c00				GRPH_LUT3_PTR		    = $AF2C00
=$af3000				GRPH_LUT4_PTR		    = $AF3000
=$af3400				GRPH_LUT5_PTR		    = $AF3400
=$af3800				GRPH_LUT6_PTR		    = $AF3800
=$af3c00				GRPH_LUT7_PTR		    = $AF3C00
=$af4000				GAMMA_B_LUT_PTR		    = $AF4000
=$af4100				GAMMA_G_LUT_PTR		    = $AF4100
=$af4200				GAMMA_R_LUT_PTR		    = $AF4200
=$af8000				FONT_MEMORY_BANK0       = $AF8000     ;$AF8000 - $AF87FF
=$afa000				CS_TEXT_MEM_PTR         = $AFA000
=$afc000				CS_COLOR_MEM_PTR        = $AFC000

;******  Processing file: src\C256/VKYII_CFP9553_BITMAP_def.s

=$01					BM_Enable             = $01
=$00					BM_LUT0               = $00 ;
=$02					BM_LUT1               = $02 ;
=$04					BM_LUT2               = $04 ;
=$06					BM_LUT3               = $06 ;
=$08					BM_LUT4               = $08 ;
=$0a					BM_LUT5               = $0A ;
=$0c					BM_LUT6               = $0C ;
=$0e					BM_LUT7               = $0E ;
=$af0100				BM0_CONTROL_REG     = $AF0100
=$af0101				BM0_START_ADDY_L    = $AF0101
=$af0102				BM0_START_ADDY_M    = $AF0102
=$af0103				BM0_START_ADDY_H    = $AF0103
=$af0104				BM0_X_OFFSET        = $AF0104   ; Not Implemented
=$af0105				BM0_Y_OFFSET        = $AF0105   ; Not Implemented
=$af0106				BM0_RESERVED_6      = $AF0106
=$af0107				BM0_RESERVED_7      = $AF0107
=$af0108				BM1_CONTROL_REG     = $AF0108
=$af0109				BM1_START_ADDY_L    = $AF0109
=$af010a				BM1_START_ADDY_M    = $AF010A
=$af010b				BM1_START_ADDY_H    = $AF010B
=$af010c				BM1_X_OFFSET        = $AF010C   ; Not Implemented
=$af010d				BM1_Y_OFFSET        = $AF010D   ; Not Implemented
=$af010e				BM1_RESERVED_6      = $AF010E
=$af010f				BM1_RESERVED_7      = $AF010F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_TILEMAP_def.s

=$01					TILE_Enable             = $01
=0					TILEMAP_CONTROL         = 0             ; Offset to a tile map's control register
=1					TILEMAP_START_ADDY      = 1             ; Offset to a tile map's address
=4					TILEMAP_TOTAL_X         = 4             ; Offset to a tile map's width
=6					TILEMAP_TOTAL_Y         = 6             ; Offset to a tile map's height
=8					TILEMAP_WINDOW_X        = 8             ; Offset to a tile map's X position
=10					TILEMAP_WINDOW_Y        = 10            ; Offset to a tile map's Y position
=1					TILEMAP_VISIBLE         = 1             ; Tile map is visible flag
=$af0200				TL0_CONTROL_REG         = $AF0200       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0201				TL0_START_ADDY_L        = $AF0201       ; Not USed right now - Starting Address to where is the MAP
=$af0202				TL0_START_ADDY_M        = $AF0202
=$af0203				TL0_START_ADDY_H        = $AF0203
=$af0204				TL0_TOTAL_X_SIZE_L      = $AF0204       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0205				TL0_TOTAL_X_SIZE_H      = $AF0205
=$af0206				TL0_TOTAL_Y_SIZE_L      = $AF0206       ; Size of the Map in Y Tile Count [9:0]
=$af0207				TL0_TOTAL_Y_SIZE_H      = $AF0207
=$af0208				TL0_WINDOW_X_POS_L      = $AF0208       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0209				TL0_WINDOW_X_POS_H      = $AF0209       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af020a				TL0_WINDOW_Y_POS_L      = $AF020A       ; Top Left Corner Position of the TileMAp Window in Y
=$af020b				TL0_WINDOW_Y_POS_H      = $AF020B       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af020c				TL1_CONTROL_REG         = $AF020C       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af020d				TL1_START_ADDY_L        = $AF020D       ; Not USed right now - Starting Address to where is the MAP
=$af020e				TL1_START_ADDY_M        = $AF020E
=$af020f				TL1_START_ADDY_H        = $AF020F
=$af0210				TL1_TOTAL_X_SIZE_L      = $AF0210       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0211				TL1_TOTAL_X_SIZE_H      = $AF0211
=$af0212				TL1_TOTAL_Y_SIZE_L      = $AF0212       ; Size of the Map in Y Tile Count [9:0]
=$af0213				TL1_TOTAL_Y_SIZE_H      = $AF0213
=$af0214				TL1_WINDOW_X_POS_L      = $AF0214       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0215				TL1_WINDOW_X_POS_H      = $AF0215       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0216				TL1_WINDOW_Y_POS_L      = $AF0216       ; Top Left Corner Position of the TileMAp Window in Y
=$af0217				TL1_WINDOW_Y_POS_H      = $AF0217       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0218				TL2_CONTROL_REG         = $AF0218       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0219				TL2_START_ADDY_L        = $AF0219       ; Not USed right now - Starting Address to where is the MAP
=$af021a				TL2_START_ADDY_M        = $AF021A
=$af021b				TL2_START_ADDY_H        = $AF021B
=$af021c				TL2_TOTAL_X_SIZE_L      = $AF021C       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af021d				TL2_TOTAL_X_SIZE_H      = $AF021D
=$af021e				TL2_TOTAL_Y_SIZE_L      = $AF021E       ; Size of the Map in Y Tile Count [9:0]
=$af021f				TL2_TOTAL_Y_SIZE_H      = $AF021F
=$af0220				TL2_WINDOW_X_POS_L      = $AF0220       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0221				TL2_WINDOW_X_POS_H      = $AF0221       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0222				TL2_WINDOW_Y_POS_L      = $AF0222       ; Top Left Corner Position of the TileMAp Window in Y
=$af0223				TL2_WINDOW_Y_POS_H      = $AF0223       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0224				TL3_CONTROL_REG         = $AF0224       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0225				TL3_START_ADDY_L        = $AF0225       ; Not USed right now - Starting Address to where is the MAP
=$af0226				TL3_START_ADDY_M        = $AF0226
=$af0227				TL3_START_ADDY_H        = $AF0227
=$af0228				TL3_TOTAL_X_SIZE_L      = $AF0228       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0229				TL3_TOTAL_X_SIZE_H      = $AF0229
=$af022a				TL3_TOTAL_Y_SIZE_L      = $AF022A       ; Size of the Map in Y Tile Count [9:0]
=$af022b				TL3_TOTAL_Y_SIZE_H      = $AF022B
=$af022c				TL3_WINDOW_X_POS_L      = $AF022C       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af022d				TL3_WINDOW_X_POS_H      = $AF022D       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af022e				TL3_WINDOW_Y_POS_L      = $AF022E       ; Top Left Corner Position of the TileMAp Window in Y
=$af022f				TL3_WINDOW_Y_POS_H      = $AF022F       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0280				TILESET0_ADDY_L         = $AF0280   ; Pointer to Tileset 0 [21:0]
=$af0281				TILESET0_ADDY_M         = $AF0281
=$af0282				TILESET0_ADDY_H         = $AF0282
=$af0283				TILESET0_ADDY_CFG       = $AF0283   ; [3] - TileStride256x256 [2:0] LUT
=2					TILESET_ADDY_H          = 2             ; Offset to high byte of tile set address
=3					TILESET_ADDY_CFG        = 3             ; Offset to the tile set address configuration
=$08					TILESET_SQUARE_256      = $08
=$af0284				TILESET1_ADDY_L         = $AF0284
=$af0285				TILESET1_ADDY_M         = $AF0285
=$af0286				TILESET1_ADDY_H         = $AF0286
=$af0287				TILESET1_ADDY_CFG       = $AF0287
=$af0288				TILESET2_ADDY_L         = $AF0288
=$af0289				TILESET2_ADDY_M         = $AF0289
=$af028a				TILESET2_ADDY_H         = $AF028A
=$af028b				TILESET2_ADDY_CFG       = $AF028B
=$af028c				TILESET3_ADDY_L         = $AF028C
=$af028d				TILESET3_ADDY_M         = $AF028D
=$af028e				TILESET3_ADDY_H         = $AF028E
=$af028f				TILESET3_ADDY_CFG       = $AF028F
=$af0290				TILESET4_ADDY_L         = $AF0290
=$af0291				TILESET4_ADDY_M         = $AF0291
=$af0292				TILESET4_ADDY_H         = $AF0292
=$af0293				TILESET4_ADDY_CFG       = $AF0293
=$af0294				TILESET5_ADDY_L         = $AF0294
=$af0295				TILESET5_ADDY_M         = $AF0295
=$af0296				TILESET5_ADDY_H         = $AF0296
=$af0297				TILESET5_ADDY_CFG       = $AF0297
=$af0298				TILESET6_ADDY_L         = $AF0298
=$af0299				TILESET6_ADDY_M         = $AF0299
=$af029a				TILESET6_ADDY_H         = $AF029A
=$af029b				TILESET6_ADDY_CFG       = $AF029B
=$af029c				TILESET7_ADDY_L         = $AF029C
=$af029d				TILESET7_ADDY_M         = $AF029D
=$af029e				TILESET7_ADDY_H         = $AF029E
=$af029f				TILESET7_ADDY_CFG       = $AF029F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SDMA_def.s

=$af0420				SDMA_CTRL_REG0           = $AF0420
=$01					SDMA_CTRL0_Enable        = $01
=$02					SDMA_CTRL0_1D_2D         = $02     ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					SDMA_CTRL0_TRF_Fill      = $04     ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					SDMA_CTRL0_Int_Enable    = $08     ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					SDMA_CTRL0_SysRAM_Src    = $10     ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					SDMA_CTRL0_SysRAM_Dst    = $20     ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$00					SDMA_XFER_SRAM2SRAM = $00           ; SRAM -> SRAM transfer
=$10					SDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					SDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$30					SDMA_XFER_SRAMIO = $30              ; SRAM <-> IO transfer (see: SDMA_CONTROL_REG1 for config and direction)
=$40					SDMA_CTLR0_RSVD          = $40      ; Reserved
=$80					SDMA_CTRL0_Start_TRF     = $80      ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$af0421				SDMA_CTRL_REG1           = $AF0421  ; Write Only - Byte to Write in the Fill Function
=$01					SDMA_CTRL1_IO_Src		 = $01		; 1 = Source is an IO Address (ADC, SuperIO, IDE)
=$02					SDMA_CTRL1_IO_Src16		 = $02		; 0 = Src 8Bits Transfer / 1= 16Bits Transfer
=$04					SDMA_CTRL1_IO_Dst		 = $04		; 1 = Destination is an IO Address (DAC, SuperIO, IDE)
=$08					SDMA_CTRL1_IO_Dst16      = $08      ; 0 = Dst 8bits Transfer / 1= 16bits
=$af0422				SDMA_SRC_ADDY_L         = $AF0422   ; Pointer to the Source of the Data to be stransfered
=$af0423				SDMA_SRC_ADDY_M         = $AF0423   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0424				SDMA_SRC_ADDY_H         = $AF0424
=$af0425				SDMA_DST_ADDY_L         = $AF0425   ; Destination Pointer within CPU's video memory Range
=$af0426				SDMA_DST_ADDY_M         = $AF0426   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0427				SDMA_DST_ADDY_H         = $AF0427
=$af0428				SDMA_SIZE_L             = $AF0428   ; Maximum Value: $40:0000 (4Megs)
=$af0429				SDMA_SIZE_M             = $AF0429
=$af042a				SDMA_SIZE_H             = $AF042A
=$af042b				SDMA_IGNORED            = $AF042B
=$af0428				SDMA_X_SIZE_L           = $AF0428   ; Maximum Value: 65535
=$af0429				SDMA_X_SIZE_H           = $AF0429
=$af042a				SDMA_Y_SIZE_L           = $AF042A   ; Maximum Value: 65535
=$af042b				SDMA_Y_SIZE_H           = $AF042B
=$af042c				SDMA_SRC_STRIDE_L       = $AF042C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042d				SDMA_SRC_STRIDE_H       = $AF042D   ;
=$af042e				SDMA_DST_STRIDE_L       = $AF042E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042f				SDMA_DST_STRIDE_H       = $AF042F   ;
=$af0430				SDMA_BYTE_2_WRITE       = $AF0430   ; Write Only - Byte to Write in the Fill Function
=$af0430				SDMA_STATUS_REG         = $AF0430   ; Read only
=$01					SDMA_STAT_Size_Err       = $01      ; If Set to 1, Overall Size is Invalid
=$02					SDMA_STAT_Dst_Add_Err    = $02      ; If Set to 1, Destination Address Invalid
=$04					SDMA_STAT_Src_Add_Err    = $04      ; If Set to 1, Source Address Invalid
=$08					SDMA_STAT_TimeOut_Err    = $08      ; will be set to 1 if a Timeout occur when transfering between data from and to VRAM

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_VDMA_def.s

=$af0400				VDMA_CONTROL_REG        = $AF0400
=$01					VDMA_CTRL_Enable        = $01
=$02					VDMA_CTRL_1D_2D         = $02       ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					VDMA_CTRL_TRF_Fill      = $04       ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					VDMA_CTRL_Int_Enable    = $08       ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					VDMA_CTRL_SysRAM_Src    = $10       ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					VDMA_CTRL_SysRAM_Dst    = $20       ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$80					VDMA_CTRL_Start_TRF     = $80       ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$00					VDMA_XFER_VRAM2VRAM = $00           ; VRAM -> VRAM transfer
=$10					VDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					VDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$af0401				VDMA_BYTE_2_WRITE       = $AF0401   ; Write Only - Byte to Write in the Fill Function
=$af0401				VDMA_STATUS_REG         = $AF0401   ; Read only
=$01					VDMA_STAT_Size_Err      = $01       ; If Set to 1, Overall Size is Invalid
=$02					VDMA_STAT_Dst_Add_Err   = $02       ; If Set to 1, Destination Address Invalid
=$04					VDMA_STAT_Src_Add_Err   = $04       ; If Set to 1, Source Address Invalid
=$80					VDMA_STAT_VDMA_IPS      = $80       ; If Set to 1, VDMA Transfer in Progress (this Inhibit CPU Access to Mem)
=$af0402				VDMA_SRC_ADDY_L         = $AF0402   ; Pointer to the Source of the Data to be stransfered
=$af0403				VDMA_SRC_ADDY_M         = $AF0403   ; This needs to be within Vicky's Range ($00_0000 - $3F_0000)
=$af0404				VDMA_SRC_ADDY_H         = $AF0404
=$af0405				VDMA_DST_ADDY_L         = $AF0405   ; Destination Pointer within Vicky's video memory Range
=$af0406				VDMA_DST_ADDY_M         = $AF0406   ; ($00_0000 - $3F_0000)
=$af0407				VDMA_DST_ADDY_H         = $AF0407
=$af0408				VDMA_SIZE_L             = $AF0408   ; Maximum Value: $40:0000 (4Megs)
=$af0409				VDMA_SIZE_M             = $AF0409
=$af040a				VDMA_SIZE_H             = $AF040A
=$af040b				VDMA_IGNORED            = $AF040B
=$af0408				VDMA_X_SIZE_L           = $AF0408   ; Maximum Value: 65535
=$af0409				VDMA_X_SIZE_H           = $AF0409
=$af040a				VDMA_Y_SIZE_L           = $AF040A   ; Maximum Value: 65535
=$af040b				VDMA_Y_SIZE_H           = $AF040B
=$af040c				VDMA_SRC_STRIDE_L       = $AF040C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040d				VDMA_SRC_STRIDE_H       = $AF040D   ;
=$af040e				VDMA_DST_STRIDE_L       = $AF040E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040f				VDMA_DST_STRIDE_H       = $AF040F   ;

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SPRITE_def.s

=$01					SPRITE_Enable             = $01
=$00					SPRITE_LUT0               = $00 ; This is the LUT that the Sprite will use
=$02					SPRITE_LUT1               = $02
=$04					SPRITE_LUT2               = $04 ; Only 4 LUT for Now, So this bit is not used.
=$06					SPRITE_LUT3               = $06 ; Only 4 LUT for Now, So this bit is not used.
=$08					SPRITE_LUT4               = $08 ; Only 4 LUT for Now, So this bit is not used.
=$0a					SPRITE_LUT5               = $0A ; Only 4 LUT for Now, So this bit is not used.
=$0c					SPRITE_LUT6               = $0C ; Only 4 LUT for Now, So this bit is not used.
=$0e					SPRITE_LUT7               = $0E ; Only 4 LUT for Now, So this bit is not used.
=$00					SPRITE_DEPTH0             = $00
=$10					SPRITE_DEPTH1             = $10
=$20					SPRITE_DEPTH2             = $20
=$30					SPRITE_DEPTH3             = $30
=$40					SPRITE_DEPTH4             = $40
=$50					SPRITE_DEPTH5             = $50
=$60					SPRITE_DEPTH6             = $60
=$af0c00				SP00_CONTROL_REG        = $AF0C00
=$af0c01				SP00_ADDY_PTR_L         = $AF0C01
=$af0c02				SP00_ADDY_PTR_M         = $AF0C02
=$af0c03				SP00_ADDY_PTR_H         = $AF0C03
=$af0c04				SP00_X_POS_L            = $AF0C04
=$af0c05				SP00_X_POS_H            = $AF0C05
=$af0c06				SP00_Y_POS_L            = $AF0C06
=$af0c07				SP00_Y_POS_H            = $AF0C07
=$af0c08				SP01_CONTROL_REG        = $AF0C08
=$af0c09				SP01_ADDY_PTR_L         = $AF0C09
=$af0c0a				SP01_ADDY_PTR_M         = $AF0C0A
=$af0c0b				SP01_ADDY_PTR_H         = $AF0C0B
=$af0c0c				SP01_X_POS_L            = $AF0C0C
=$af0c0d				SP01_X_POS_H            = $AF0C0D
=$af0c0e				SP01_Y_POS_L            = $AF0C0E
=$af0c0f				SP01_Y_POS_H            = $AF0C0F
=$af0c10				SP02_CONTROL_REG        = $AF0C10
=$af0c11				SP02_ADDY_PTR_L         = $AF0C11
=$af0c12				SP02_ADDY_PTR_M         = $AF0C12
=$af0c13				SP02_ADDY_PTR_H         = $AF0C13
=$af0c14				SP02_X_POS_L            = $AF0C14
=$af0c15				SP02_X_POS_H            = $AF0C15
=$af0c16				SP02_Y_POS_L            = $AF0C16
=$af0c17				SP02_Y_POS_H            = $AF0C17
=$af0c18				SP03_CONTROL_REG        = $AF0C18
=$af0c19				SP03_ADDY_PTR_L         = $AF0C19
=$af0c1a				SP03_ADDY_PTR_M         = $AF0C1A
=$af0c1b				SP03_ADDY_PTR_H         = $AF0C1B
=$af0c1c				SP03_X_POS_L            = $AF0C1C
=$af0c1d				SP03_X_POS_H            = $AF0C1D
=$af0c1e				SP03_Y_POS_L            = $AF0C1E
=$af0c1f				SP03_Y_POS_H            = $AF0C1F
=$af0c20				SP04_CONTROL_REG        = $AF0C20
=$af0c21				SP04_ADDY_PTR_L         = $AF0C21
=$af0c22				SP04_ADDY_PTR_M         = $AF0C22
=$af0c23				SP04_ADDY_PTR_H         = $AF0C23
=$af0c24				SP04_X_POS_L            = $AF0C24
=$af0c25				SP04_X_POS_H            = $AF0C25
=$af0c26				SP04_Y_POS_L            = $AF0C26
=$af0c27				SP04_Y_POS_H            = $AF0C27
=$af0c28				SP05_CONTROL_REG        = $AF0C28
=$af0c29				SP05_ADDY_PTR_L         = $AF0C29
=$af0c2a				SP05_ADDY_PTR_M         = $AF0C2A
=$af0c2b				SP05_ADDY_PTR_H         = $AF0C2B
=$af0c2c				SP05_X_POS_L            = $AF0C2C
=$af0c2d				SP05_X_POS_H            = $AF0C2D
=$af0c2e				SP05_Y_POS_L            = $AF0C2E
=$af0c2f				SP05_Y_POS_H            = $AF0C2F
=$af0c30				SP06_CONTROL_REG        = $AF0C30
=$af0c31				SP06_ADDY_PTR_L         = $AF0C31
=$af0c32				SP06_ADDY_PTR_M         = $AF0C32
=$af0c33				SP06_ADDY_PTR_H         = $AF0C33
=$af0c34				SP06_X_POS_L            = $AF0C34
=$af0c35				SP06_X_POS_H            = $AF0C35
=$af0c36				SP06_Y_POS_L            = $AF0C36
=$af0c37				SP06_Y_POS_H            = $AF0C37
=$af0c38				SP07_CONTROL_REG        = $AF0C38
=$af0c39				SP07_ADDY_PTR_L         = $AF0C39
=$af0c3a				SP07_ADDY_PTR_M         = $AF0C3A
=$af0c3b				SP07_ADDY_PTR_H         = $AF0C3B
=$af0c3c				SP07_X_POS_L            = $AF0C3C
=$af0c3d				SP07_X_POS_H            = $AF0C3D
=$af0c3e				SP07_Y_POS_L            = $AF0C3E
=$af0c3f				SP07_Y_POS_H            = $AF0C3F
=$af0c40				SP08_CONTROL_REG        = $AF0C40
=$af0c41				SP08_ADDY_PTR_L         = $AF0C41
=$af0c42				SP08_ADDY_PTR_M         = $AF0C42
=$af0c43				SP08_ADDY_PTR_H         = $AF0C43
=$af0c44				SP08_X_POS_L            = $AF0C44
=$af0c45				SP08_X_POS_H            = $AF0C45
=$af0c46				SP08_Y_POS_L            = $AF0C46
=$af0c47				SP08_Y_POS_H            = $AF0C47
=$af0c48				SP09_CONTROL_REG        = $AF0C48
=$af0c49				SP09_ADDY_PTR_L         = $AF0C49
=$af0c4a				SP09_ADDY_PTR_M         = $AF0C4A
=$af0c4b				SP09_ADDY_PTR_H         = $AF0C4B
=$af0c4c				SP09_X_POS_L            = $AF0C4C
=$af0c4d				SP09_X_POS_H            = $AF0C4D
=$af0c4e				SP09_Y_POS_L            = $AF0C4E
=$af0c4f				SP09_Y_POS_H            = $AF0C4F
=$af0c50				SP10_CONTROL_REG        = $AF0C50
=$af0c51				SP10_ADDY_PTR_L         = $AF0C51
=$af0c52				SP10_ADDY_PTR_M         = $AF0C52
=$af0c53				SP10_ADDY_PTR_H         = $AF0C53
=$af0c54				SP10_X_POS_L            = $AF0C54
=$af0c55				SP10_X_POS_H            = $AF0C55
=$af0c56				SP10_Y_POS_L            = $AF0C56
=$af0c57				SP10_Y_POS_H            = $AF0C57
=$af0c58				SP11_CONTROL_REG        = $AF0C58
=$af0c59				SP11_ADDY_PTR_L         = $AF0C59
=$af0c5a				SP11_ADDY_PTR_M         = $AF0C5A
=$af0c5b				SP11_ADDY_PTR_H         = $AF0C5B
=$af0c5c				SP11_X_POS_L            = $AF0C5C
=$af0c5d				SP11_X_POS_H            = $AF0C5D
=$af0c5e				SP11_Y_POS_L            = $AF0C5E
=$af0c5f				SP11_Y_POS_H            = $AF0C5F
=$af0c60				SP12_CONTROL_REG        = $AF0C60
=$af0c61				SP12_ADDY_PTR_L         = $AF0C61
=$af0c62				SP12_ADDY_PTR_M         = $AF0C62
=$af0c63				SP12_ADDY_PTR_H         = $AF0C63
=$af0c64				SP12_X_POS_L            = $AF0C64
=$af0c65				SP12_X_POS_H            = $AF0C65
=$af0c66				SP12_Y_POS_L            = $AF0C66
=$af0c67				SP12_Y_POS_H            = $AF0C67
=$af0c68				SP13_CONTROL_REG        = $AF0C68
=$af0c69				SP13_ADDY_PTR_L         = $AF0C69
=$af0c6a				SP13_ADDY_PTR_M         = $AF0C6A
=$af0c6b				SP13_ADDY_PTR_H         = $AF0C6B
=$af0c6c				SP13_X_POS_L            = $AF0C6C
=$af0c6d				SP13_X_POS_H            = $AF0C6D
=$af0c6e				SP13_Y_POS_L            = $AF0C6E
=$af0c6f				SP13_Y_POS_H            = $AF0C6F
=$af0c70				SP14_CONTROL_REG        = $AF0C70
=$af0c71				SP14_ADDY_PTR_L         = $AF0C71
=$af0c72				SP14_ADDY_PTR_M         = $AF0C72
=$af0c73				SP14_ADDY_PTR_H         = $AF0C73
=$af0c74				SP14_X_POS_L            = $AF0C74
=$af0c75				SP14_X_POS_H            = $AF0C75
=$af0c76				SP14_Y_POS_L            = $AF0C76
=$af0c77				SP14_Y_POS_H            = $AF0C77
=$af0c78				SP15_CONTROL_REG        = $AF0C78
=$af0c79				SP15_ADDY_PTR_L         = $AF0C79
=$af0c7a				SP15_ADDY_PTR_M         = $AF0C7A
=$af0c7b				SP15_ADDY_PTR_H         = $AF0C7B
=$af0c7c				SP15_X_POS_L            = $AF0C7C
=$af0c7d				SP15_X_POS_H            = $AF0C7D
=$af0c7e				SP15_Y_POS_L            = $AF0C7E
=$af0c7f				SP15_Y_POS_H            = $AF0C7F
=$af0c80				SP16_CONTROL_REG        = $AF0C80
=$af0c81				SP16_ADDY_PTR_L         = $AF0C81
=$af0c82				SP16_ADDY_PTR_M         = $AF0C82
=$af0c83				SP16_ADDY_PTR_H         = $AF0C83
=$af0c84				SP16_X_POS_L            = $AF0C84
=$af0c85				SP16_X_POS_H            = $AF0C85
=$af0c86				SP16_Y_POS_L            = $AF0C86
=$af0c87				SP16_Y_POS_H            = $AF0C87
=$af0c88				SP17_CONTROL_REG        = $AF0C88
=$af0c89				SP17_ADDY_PTR_L         = $AF0C89
=$af0c8a				SP17_ADDY_PTR_M         = $AF0C8A
=$af0c8b				SP17_ADDY_PTR_H         = $AF0C8B
=$af0c8c				SP17_X_POS_L            = $AF0C8C
=$af0c8d				SP17_X_POS_H            = $AF0C8D
=$af0c8e				SP17_Y_POS_L            = $AF0C8E
=$af0c8f				SP17_Y_POS_H            = $AF0C8F
=$af0c90				SP18_CONTROL_REG        = $AF0C90
=$af0c91				SP18_ADDY_PTR_L         = $AF0C91
=$af0c92				SP18_ADDY_PTR_M         = $AF0C92
=$af0c93				SP18_ADDY_PTR_H         = $AF0C93
=$af0c94				SP18_X_POS_L            = $AF0C94
=$af0c95				SP18_X_POS_H            = $AF0C95
=$af0c96				SP18_Y_POS_L            = $AF0C96
=$af0c97				SP18_Y_POS_H            = $AF0C97
=$af0c98				SP19_CONTROL_REG        = $AF0C98
=$af0c99				SP19_ADDY_PTR_L         = $AF0C99
=$af0c9a				SP19_ADDY_PTR_M         = $AF0C9A
=$af0c9b				SP19_ADDY_PTR_H         = $AF0C9B
=$af0c9c				SP19_X_POS_L            = $AF0C9C
=$af0c9d				SP19_X_POS_H            = $AF0C9D
=$af0c9e				SP19_Y_POS_L            = $AF0C9E
=$af0c9f				SP19_Y_POS_H            = $AF0C9F
=$af0ca0				SP20_CONTROL_REG        = $AF0CA0
=$af0ca1				SP20_ADDY_PTR_L         = $AF0CA1
=$af0ca2				SP20_ADDY_PTR_M         = $AF0CA2
=$af0ca3				SP20_ADDY_PTR_H         = $AF0CA3
=$af0ca4				SP20_X_POS_L            = $AF0CA4
=$af0ca5				SP20_X_POS_H            = $AF0CA5
=$af0ca6				SP20_Y_POS_L            = $AF0CA6
=$af0ca7				SP20_Y_POS_H            = $AF0CA7
=$af0ca8				SP21_CONTROL_REG        = $AF0CA8
=$af0ca9				SP21_ADDY_PTR_L         = $AF0CA9
=$af0caa				SP21_ADDY_PTR_M         = $AF0CAA
=$af0cab				SP21_ADDY_PTR_H         = $AF0CAB
=$af0cac				SP21_X_POS_L            = $AF0CAC
=$af0cad				SP21_X_POS_H            = $AF0CAD
=$af0cae				SP21_Y_POS_L            = $AF0CAE
=$af0caf				SP21_Y_POS_H            = $AF0CAF
=$af0cb0				SP22_CONTROL_REG        = $AF0CB0
=$af0cb1				SP22_ADDY_PTR_L         = $AF0CB1
=$af0cb2				SP22_ADDY_PTR_M         = $AF0CB2
=$af0cb3				SP22_ADDY_PTR_H         = $AF0CB3
=$af0cb4				SP22_X_POS_L            = $AF0CB4
=$af0cb5				SP22_X_POS_H            = $AF0CB5
=$af0cb6				SP22_Y_POS_L            = $AF0CB6
=$af0cb7				SP22_Y_POS_H            = $AF0CB7
=$af0cb8				SP23_CONTROL_REG        = $AF0CB8
=$af0cb9				SP23_ADDY_PTR_L         = $AF0CB9
=$af0cba				SP23_ADDY_PTR_M         = $AF0CBA
=$af0cbb				SP23_ADDY_PTR_H         = $AF0CBB
=$af0cbc				SP23_X_POS_L            = $AF0CBC
=$af0cbd				SP23_X_POS_H            = $AF0CBD
=$af0cbe				SP23_Y_POS_L            = $AF0CBE
=$af0cbf				SP23_Y_POS_H            = $AF0CBF
=$af0cc0				SP24_CONTROL_REG        = $AF0CC0
=$af0cc1				SP24_ADDY_PTR_L         = $AF0CC1
=$af0cc2				SP24_ADDY_PTR_M         = $AF0CC2
=$af0cc3				SP24_ADDY_PTR_H         = $AF0CC3
=$af0cc4				SP24_X_POS_L            = $AF0CC4
=$af0cc5				SP24_X_POS_H            = $AF0CC5
=$af0cc6				SP24_Y_POS_L            = $AF0CC6
=$af0cc7				SP24_Y_POS_H            = $AF0CC7
=$af0cc8				SP25_CONTROL_REG        = $AF0CC8
=$af0cc9				SP25_ADDY_PTR_L         = $AF0CC9
=$af0cca				SP25_ADDY_PTR_M         = $AF0CCA
=$af0ccb				SP25_ADDY_PTR_H         = $AF0CCB
=$af0ccc				SP25_X_POS_L            = $AF0CCC
=$af0ccd				SP25_X_POS_H            = $AF0CCD
=$af0cce				SP25_Y_POS_L            = $AF0CCE
=$af0ccf				SP25_Y_POS_H            = $AF0CCF
=$af0cd0				SP26_CONTROL_REG        = $AF0CD0
=$af0cd1				SP26_ADDY_PTR_L         = $AF0CD1
=$af0cd2				SP26_ADDY_PTR_M         = $AF0CD2
=$af0cd3				SP26_ADDY_PTR_H         = $AF0CD3
=$af0cd4				SP26_X_POS_L            = $AF0CD4
=$af0cd5				SP26_X_POS_H            = $AF0CD5
=$af0cd6				SP26_Y_POS_L            = $AF0CD6
=$af0cd7				SP26_Y_POS_H            = $AF0CD7
=$af0cd8				SP27_CONTROL_REG        = $AF0CD8
=$af0cd9				SP27_ADDY_PTR_L         = $AF0CD9
=$af0cda				SP27_ADDY_PTR_M         = $AF0CDA
=$af0cdb				SP27_ADDY_PTR_H         = $AF0CDB
=$af0cdc				SP27_X_POS_L            = $AF0CDC
=$af0cdd				SP27_X_POS_H            = $AF0CDD
=$af0cde				SP27_Y_POS_L            = $AF0CDE
=$af0cdf				SP27_Y_POS_H            = $AF0CDF
=$af0ce0				SP28_CONTROL_REG        = $AF0CE0
=$af0ce1				SP28_ADDY_PTR_L         = $AF0CE1
=$af0ce2				SP28_ADDY_PTR_M         = $AF0CE2
=$af0ce3				SP28_ADDY_PTR_H         = $AF0CE3
=$af0ce4				SP28_X_POS_L            = $AF0CE4
=$af0ce5				SP28_X_POS_H            = $AF0CE5
=$af0ce6				SP28_Y_POS_L            = $AF0CE6
=$af0ce7				SP28_Y_POS_H            = $AF0CE7
=$af0ce8				SP29_CONTROL_REG        = $AF0CE8
=$af0ce9				SP29_ADDY_PTR_L         = $AF0CE9
=$af0cea				SP29_ADDY_PTR_M         = $AF0CEA
=$af0ceb				SP29_ADDY_PTR_H         = $AF0CEB
=$af0cec				SP29_X_POS_L            = $AF0CEC
=$af0ced				SP29_X_POS_H            = $AF0CED
=$af0cee				SP29_Y_POS_L            = $AF0CEE
=$af0cef				SP29_Y_POS_H            = $AF0CEF
=$af0cf0				SP30_CONTROL_REG        = $AF0CF0
=$af0cf1				SP30_ADDY_PTR_L         = $AF0CF1
=$af0cf2				SP30_ADDY_PTR_M         = $AF0CF2
=$af0cf3				SP30_ADDY_PTR_H         = $AF0CF3
=$af0cf4				SP30_X_POS_L            = $AF0CF4
=$af0cf5				SP30_X_POS_H            = $AF0CF5
=$af0cf6				SP30_Y_POS_L            = $AF0CF6
=$af0cf7				SP30_Y_POS_H            = $AF0CF7
=$af0cf8				SP31_CONTROL_REG        = $AF0CF8
=$af0cf9				SP31_ADDY_PTR_L         = $AF0CF9
=$af0cfa				SP31_ADDY_PTR_M         = $AF0CFA
=$af0cfb				SP31_ADDY_PTR_H         = $AF0CFB
=$af0cfc				SP31_X_POS_L            = $AF0CFC
=$af0cfd				SP31_X_POS_H            = $AF0CFD
=$af0cfe				SP31_Y_POS_L            = $AF0CFE
=$af0cff				SP31_Y_POS_H            = $AF0CFF
=$af0d00				SP32_CONTROL_REG        = $AF0D00
=$af0d01				SP32_ADDY_PTR_L         = $AF0D01
=$af0d02				SP32_ADDY_PTR_M         = $AF0D02
=$af0d03				SP32_ADDY_PTR_H         = $AF0D03
=$af0d04				SP32_X_POS_L            = $AF0D04
=$af0d05				SP32_X_POS_H            = $AF0D05
=$af0d06				SP32_Y_POS_L            = $AF0D06
=$af0d07				SP32_Y_POS_H            = $AF0D07
=$af0d08				SP33_CONTROL_REG        = $AF0D08
=$af0d09				SP33_ADDY_PTR_L         = $AF0D09
=$af0d0a				SP33_ADDY_PTR_M         = $AF0D0A
=$af0d0b				SP33_ADDY_PTR_H         = $AF0D0B
=$af0d0c				SP33_X_POS_L            = $AF0D0C
=$af0d0d				SP33_X_POS_H            = $AF0D0D
=$af0d0e				SP33_Y_POS_L            = $AF0D0E
=$af0d0f				SP33_Y_POS_H            = $AF0D0F
=$af0d10				SP34_CONTROL_REG        = $AF0D10
=$af0d11				SP34_ADDY_PTR_L         = $AF0D11
=$af0d12				SP34_ADDY_PTR_M         = $AF0D12
=$af0d13				SP34_ADDY_PTR_H         = $AF0D13
=$af0d14				SP34_X_POS_L            = $AF0D14
=$af0d15				SP34_X_POS_H            = $AF0D15
=$af0d16				SP34_Y_POS_L            = $AF0D16
=$af0d17				SP34_Y_POS_H            = $AF0D17
=$af0d18				SP35_CONTROL_REG        = $AF0D18
=$af0d19				SP35_ADDY_PTR_L         = $AF0D19
=$af0d1a				SP35_ADDY_PTR_M         = $AF0D1A
=$af0d1b				SP35_ADDY_PTR_H         = $AF0D1B
=$af0d1c				SP35_X_POS_L            = $AF0D1C
=$af0d1d				SP35_X_POS_H            = $AF0D1D
=$af0d1e				SP35_Y_POS_L            = $AF0D1E
=$af0d1f				SP35_Y_POS_H            = $AF0D1F
=$af0d20				SP36_CONTROL_REG        = $AF0D20
=$af0d21				SP36_ADDY_PTR_L         = $AF0D21
=$af0d22				SP36_ADDY_PTR_M         = $AF0D22
=$af0d23				SP36_ADDY_PTR_H         = $AF0D23
=$af0d24				SP36_X_POS_L            = $AF0D24
=$af0d25				SP36_X_POS_H            = $AF0D25
=$af0d26				SP36_Y_POS_L            = $AF0D26
=$af0d27				SP36_Y_POS_H            = $AF0D27
=$af0d28				SP37_CONTROL_REG        = $AF0D28
=$af0d29				SP37_ADDY_PTR_L         = $AF0D29
=$af0d2a				SP37_ADDY_PTR_M         = $AF0D2A
=$af0d2b				SP37_ADDY_PTR_H         = $AF0D2B
=$af0d2c				SP37_X_POS_L            = $AF0D2C
=$af0d2d				SP37_X_POS_H            = $AF0D2D
=$af0d2e				SP37_Y_POS_L            = $AF0D2E
=$af0d2f				SP37_Y_POS_H            = $AF0D2F
=$af0d30				SP38_CONTROL_REG        = $AF0D30
=$af0d31				SP38_ADDY_PTR_L         = $AF0D31
=$af0d32				SP38_ADDY_PTR_M         = $AF0D32
=$af0d33				SP38_ADDY_PTR_H         = $AF0D33
=$af0d34				SP38_X_POS_L            = $AF0D34
=$af0d35				SP38_X_POS_H            = $AF0D35
=$af0d36				SP38_Y_POS_L            = $AF0D36
=$af0d37				SP38_Y_POS_H            = $AF0D37
=$af0d38				SP39_CONTROL_REG        = $AF0D38
=$af0d39				SP39_ADDY_PTR_L         = $AF0D39
=$af0d3a				SP39_ADDY_PTR_M         = $AF0D3A
=$af0d3b				SP39_ADDY_PTR_H         = $AF0D3B
=$af0d3c				SP39_X_POS_L            = $AF0D3C
=$af0d3d				SP39_X_POS_H            = $AF0D3D
=$af0d3e				SP39_Y_POS_L            = $AF0D3E
=$af0d3f				SP39_Y_POS_H            = $AF0D3F
=$af0d40				SP40_CONTROL_REG        = $AF0D40
=$af0d41				SP40_ADDY_PTR_L         = $AF0D41
=$af0d42				SP40_ADDY_PTR_M         = $AF0D42
=$af0d43				SP40_ADDY_PTR_H         = $AF0D43
=$af0d44				SP40_X_POS_L            = $AF0D44
=$af0d45				SP40_X_POS_H            = $AF0D45
=$af0d46				SP40_Y_POS_L            = $AF0D46
=$af0d47				SP40_Y_POS_H            = $AF0D47
=$af0d48				SP41_CONTROL_REG        = $AF0D48
=$af0d49				SP41_ADDY_PTR_L         = $AF0D49
=$af0d4a				SP41_ADDY_PTR_M         = $AF0D4A
=$af0d4b				SP41_ADDY_PTR_H         = $AF0D4B
=$af0d4c				SP41_X_POS_L            = $AF0D4C
=$af0d4d				SP41_X_POS_H            = $AF0D4D
=$af0d4e				SP41_Y_POS_L            = $AF0D4E
=$af0d4f				SP41_Y_POS_H            = $AF0D4F
=$af0d50				SP42_CONTROL_REG        = $AF0D50
=$af0d51				SP42_ADDY_PTR_L         = $AF0D51
=$af0d52				SP42_ADDY_PTR_M         = $AF0D52
=$af0d53				SP42_ADDY_PTR_H         = $AF0D53
=$af0d54				SP42_X_POS_L            = $AF0D54
=$af0d55				SP42_X_POS_H            = $AF0D55
=$af0d56				SP42_Y_POS_L            = $AF0D56
=$af0d57				SP42_Y_POS_H            = $AF0D57
=$af0d58				SP43_CONTROL_REG        = $AF0D58
=$af0d59				SP43_ADDY_PTR_L         = $AF0D59
=$af0d5a				SP43_ADDY_PTR_M         = $AF0D5A
=$af0d5b				SP43_ADDY_PTR_H         = $AF0D5B
=$af0d5c				SP43_X_POS_L            = $AF0D5C
=$af0d5d				SP43_X_POS_H            = $AF0D5D
=$af0d5e				SP43_Y_POS_L            = $AF0D5E
=$af0d5f				SP43_Y_POS_H            = $AF0D5F
=$af0d60				SP44_CONTROL_REG        = $AF0D60
=$af0d61				SP44_ADDY_PTR_L         = $AF0D61
=$af0d62				SP44_ADDY_PTR_M         = $AF0D62
=$af0d63				SP44_ADDY_PTR_H         = $AF0D63
=$af0d64				SP44_X_POS_L            = $AF0D64
=$af0d65				SP44_X_POS_H            = $AF0D65
=$af0d66				SP44_Y_POS_L            = $AF0D66
=$af0d67				SP44_Y_POS_H            = $AF0D67
=$af0d68				SP45_CONTROL_REG        = $AF0D68
=$af0d69				SP45_ADDY_PTR_L         = $AF0D69
=$af0d6a				SP45_ADDY_PTR_M         = $AF0D6A
=$af0d6b				SP45_ADDY_PTR_H         = $AF0D6B
=$af0d6c				SP45_X_POS_L            = $AF0D6C
=$af0d6d				SP45_X_POS_H            = $AF0D6D
=$af0d6e				SP45_Y_POS_L            = $AF0D6E
=$af0d6f				SP45_Y_POS_H            = $AF0D6F
=$af0d70				SP46_CONTROL_REG        = $AF0D70
=$af0d71				SP46_ADDY_PTR_L         = $AF0D71
=$af0d72				SP46_ADDY_PTR_M         = $AF0D72
=$af0d73				SP46_ADDY_PTR_H         = $AF0D73
=$af0d74				SP46_X_POS_L            = $AF0D74
=$af0d75				SP46_X_POS_H            = $AF0D75
=$af0d76				SP46_Y_POS_L            = $AF0D76
=$af0d77				SP46_Y_POS_H            = $AF0D77
=$af0d78				SP47_CONTROL_REG        = $AF0D78
=$af0d79				SP47_ADDY_PTR_L         = $AF0D79
=$af0d7a				SP47_ADDY_PTR_M         = $AF0D7A
=$af0d7b				SP47_ADDY_PTR_H         = $AF0D7B
=$af0d7c				SP47_X_POS_L            = $AF0D7C
=$af0d7d				SP47_X_POS_H            = $AF0D7D
=$af0d7e				SP47_Y_POS_L            = $AF0D7E
=$af0d7f				SP47_Y_POS_H            = $AF0D7F
=$af0d80				SP48_CONTROL_REG        = $AF0D80
=$af0d81				SP48_ADDY_PTR_L         = $AF0D81
=$af0d82				SP48_ADDY_PTR_M         = $AF0D82
=$af0d83				SP48_ADDY_PTR_H         = $AF0D83
=$af0d84				SP48_X_POS_L            = $AF0D84
=$af0d85				SP48_X_POS_H            = $AF0D85
=$af0d86				SP48_Y_POS_L            = $AF0D86
=$af0d87				SP48_Y_POS_H            = $AF0D87
=$af0d88				SP49_CONTROL_REG        = $AF0D88
=$af0d89				SP49_ADDY_PTR_L         = $AF0D89
=$af0d8a				SP49_ADDY_PTR_M         = $AF0D8A
=$af0d8b				SP49_ADDY_PTR_H         = $AF0D8B
=$af0d8c				SP49_X_POS_L            = $AF0D8C
=$af0d8d				SP49_X_POS_H            = $AF0D8D
=$af0d8e				SP49_Y_POS_L            = $AF0D8E
=$af0d8f				SP49_Y_POS_H            = $AF0D8F
=$af0d90				SP50_CONTROL_REG        = $AF0D90
=$af0d91				SP50_ADDY_PTR_L         = $AF0D91
=$af0d92				SP50_ADDY_PTR_M         = $AF0D92
=$af0d93				SP50_ADDY_PTR_H         = $AF0D93
=$af0d94				SP50_X_POS_L            = $AF0D94
=$af0d95				SP50_X_POS_H            = $AF0D95
=$af0d96				SP50_Y_POS_L            = $AF0D96
=$af0d97				SP50_Y_POS_H            = $AF0D97
=$af0d98				SP51_CONTROL_REG        = $AF0D98
=$af0d99				SP51_ADDY_PTR_L         = $AF0D99
=$af0d9a				SP51_ADDY_PTR_M         = $AF0D9A
=$af0d9b				SP51_ADDY_PTR_H         = $AF0D9B
=$af0d9c				SP51_X_POS_L            = $AF0D9C
=$af0d9d				SP51_X_POS_H            = $AF0D9D
=$af0d9e				SP51_Y_POS_L            = $AF0D9E
=$af0d9f				SP51_Y_POS_H            = $AF0D9F
=$af0da0				SP52_CONTROL_REG        = $AF0DA0
=$af0da1				SP52_ADDY_PTR_L         = $AF0DA1
=$af0da2				SP52_ADDY_PTR_M         = $AF0DA2
=$af0da3				SP52_ADDY_PTR_H         = $AF0DA3
=$af0da4				SP52_X_POS_L            = $AF0DA4
=$af0da5				SP52_X_POS_H            = $AF0DA5
=$af0da6				SP52_Y_POS_L            = $AF0DA6
=$af0da7				SP52_Y_POS_H            = $AF0DA7
=$af0da8				SP53_CONTROL_REG        = $AF0DA8
=$af0da9				SP53_ADDY_PTR_L         = $AF0DA9
=$af0daa				SP53_ADDY_PTR_M         = $AF0DAA
=$af0dab				SP53_ADDY_PTR_H         = $AF0DAB
=$af0dac				SP53_X_POS_L            = $AF0DAC
=$af0dad				SP53_X_POS_H            = $AF0DAD
=$af0dae				SP53_Y_POS_L            = $AF0DAE
=$af0daf				SP53_Y_POS_H            = $AF0DAF
=$af0db0				SP54_CONTROL_REG        = $AF0DB0
=$af0db1				SP54_ADDY_PTR_L         = $AF0DB1
=$af0db2				SP54_ADDY_PTR_M         = $AF0DB2
=$af0db3				SP54_ADDY_PTR_H         = $AF0DB3
=$af0db4				SP54_X_POS_L            = $AF0DB4
=$af0db5				SP54_X_POS_H            = $AF0DB5
=$af0db6				SP54_Y_POS_L            = $AF0DB6
=$af0db7				SP54_Y_POS_H            = $AF0DB7
=$af0db8				SP55_CONTROL_REG        = $AF0DB8
=$af0db9				SP55_ADDY_PTR_L         = $AF0DB9
=$af0dba				SP55_ADDY_PTR_M         = $AF0DBA
=$af0dbb				SP55_ADDY_PTR_H         = $AF0DBB
=$af0dbc				SP55_X_POS_L            = $AF0DBC
=$af0dbd				SP55_X_POS_H            = $AF0DBD
=$af0dbe				SP55_Y_POS_L            = $AF0DBE
=$af0dbf				SP55_Y_POS_H            = $AF0DBF
=$af0dc0				SP56_CONTROL_REG        = $AF0DC0
=$af0dc1				SP56_ADDY_PTR_L         = $AF0DC1
=$af0dc2				SP56_ADDY_PTR_M         = $AF0DC2
=$af0dc3				SP56_ADDY_PTR_H         = $AF0DC3
=$af0dc4				SP56_X_POS_L            = $AF0DC4
=$af0dc5				SP56_X_POS_H            = $AF0DC5
=$af0dc6				SP56_Y_POS_L            = $AF0DC6
=$af0dc7				SP56_Y_POS_H            = $AF0DC7
=$af0dc8				SP57_CONTROL_REG        = $AF0DC8
=$af0dc9				SP57_ADDY_PTR_L         = $AF0DC9
=$af0dca				SP57_ADDY_PTR_M         = $AF0DCA
=$af0dcb				SP57_ADDY_PTR_H         = $AF0DCB
=$af0dcc				SP57_X_POS_L            = $AF0DCC
=$af0dcd				SP57_X_POS_H            = $AF0DCD
=$af0dce				SP57_Y_POS_L            = $AF0DCE
=$af0dcf				SP57_Y_POS_H            = $AF0DCF
=$af0dd0				SP58_CONTROL_REG        = $AF0DD0
=$af0dd1				SP58_ADDY_PTR_L         = $AF0DD1
=$af0dd2				SP58_ADDY_PTR_M         = $AF0DD2
=$af0dd3				SP58_ADDY_PTR_H         = $AF0DD3
=$af0dd4				SP58_X_POS_L            = $AF0DD4
=$af0dd5				SP58_X_POS_H            = $AF0DD5
=$af0dd6				SP58_Y_POS_L            = $AF0DD6
=$af0dd7				SP58_Y_POS_H            = $AF0DD7
=$af0dd8				SP59_CONTROL_REG        = $AF0DD8
=$af0dd9				SP59_ADDY_PTR_L         = $AF0DD9
=$af0dda				SP59_ADDY_PTR_M         = $AF0DDA
=$af0ddb				SP59_ADDY_PTR_H         = $AF0DDB
=$af0ddc				SP59_X_POS_L            = $AF0DDC
=$af0ddd				SP59_X_POS_H            = $AF0DDD
=$af0dde				SP59_Y_POS_L            = $AF0DDE
=$af0ddf				SP59_Y_POS_H            = $AF0DDF
=$af0de0				SP60_CONTROL_REG        = $AF0DE0
=$af0de1				SP60_ADDY_PTR_L         = $AF0DE1
=$af0de2				SP60_ADDY_PTR_M         = $AF0DE2
=$af0de3				SP60_ADDY_PTR_H         = $AF0DE3
=$af0de4				SP60_X_POS_L            = $AF0DE4
=$af0de5				SP60_X_POS_H            = $AF0DE5
=$af0de6				SP60_Y_POS_L            = $AF0DE6
=$af0de7				SP60_Y_POS_H            = $AF0DE7
=$af0de8				SP61_CONTROL_REG        = $AF0DE8
=$af0de9				SP61_ADDY_PTR_L         = $AF0DE9
=$af0dea				SP61_ADDY_PTR_M         = $AF0DEA
=$af0deb				SP61_ADDY_PTR_H         = $AF0DEB
=$af0dec				SP61_X_POS_L            = $AF0DEC
=$af0ded				SP61_X_POS_H            = $AF0DED
=$af0dee				SP61_Y_POS_L            = $AF0DEE
=$af0def				SP61_Y_POS_H            = $AF0DEF
=$af0df0				SP62_CONTROL_REG        = $AF0DF0
=$af0df1				SP62_ADDY_PTR_L         = $AF0DF1
=$af0df2				SP62_ADDY_PTR_M         = $AF0DF2
=$af0df3				SP62_ADDY_PTR_H         = $AF0DF3
=$af0df4				SP62_X_POS_L            = $AF0DF4
=$af0df5				SP62_X_POS_H            = $AF0DF5
=$af0df6				SP62_Y_POS_L            = $AF0DF6
=$af0df7				SP62_Y_POS_H            = $AF0DF7
=$af0df8				SP63_CONTROL_REG        = $AF0DF8
=$af0df9				SP63_ADDY_PTR_L         = $AF0DF9
=$af0dfa				SP63_ADDY_PTR_M         = $AF0DFA
=$af0dfb				SP63_ADDY_PTR_H         = $AF0DFB
=$af0dfc				SP63_X_POS_L            = $AF0DFC
=$af0dfd				SP63_X_POS_H            = $AF0DFD
=$af0dfe				SP63_Y_POS_L            = $AF0DFE
=$af0dff				SP63_Y_POS_H            = $AF0DFF

;******  Return to file: src\C256/vicky_def.s


;******  Return to file: src\C256/mmap_c256.s

=$00					BASIC_BANK = $00            ; Memory bank for default purposes
=$004c00				IOBUF = $004C00             ; A buffer for I/O operations
=$004d00				ARRIDXBUF = $004D00         ; The array index buffer used for array references
=$004e00				TEMPBUF = $004E00           ; Temporary buffer for string processing, etc.
=$004f00				INPUTBUF = $004F00          ; Starting address of the line input buffer (one page)
=$005000				RETURN_BOT = $005000        ; Starting address of the return stack
=$005fff				RETURN_TOP = $005FFF        ; Ending address of the return stack
=$006000				ARGUMENT_BOT = $006000      ; Starting address of the argument stack
=$006fff				ARGUMENT_TOP = $006FFF      ; Ending address of the argument stack
=$007000				OPERATOR_BOT = $007000      ; Starting address of the operator stack
=$007fff				OPERATOR_TOP = $007FFF      ; Ending address of the operator stack
=$b00000				VRAM = $B00000              ; Start of video RAM
=$010000				LOADBLOCK = $010000         ; File loading will start here
=$360000				BASIC_BOT := $360000         ; Starting point for BASIC programs
=$37ffff				HEAP_TOP := $37FFFF          ; Starting point of the heap
=$160000				BASIC_BOT := $160000         ; Starting point for BASIC programs
=$17ffff				HEAP_TOP := $17FFFF          ; Starting point of the heap

;******  Return to file: src\memorymap.s

=$00ffe6				VBRK = $00FFE6          ; Vector for the native-mode BRK vector
=$1ad000				DATA_BLOCK = *
=$000800				GLOBAL_VARS = *
>0800					BIP         .dword ?    ; Pointer to the current byte in the current BASIC program
>0804					BIPPREV     .dword ?    ; Pointer to the previous bytein the current BASIC program
>0808					INDEX       .dword ?    ; A temporary pointer
>080c					SCRATCH     .dword ?    ; A temporary scratch variable
>0810					SCRATCH2    .dword ?    ; A temporary scratch variable
>0814					            .word  ?	; Need a few more bits for BCD conversion
>0816					STRPTR      .dword ?    ; A temporary pointer for strings
>081a					CURLINE     .dword ?    ; Pointer to the current input line needing tokenization
>081e					CURTOKLEN   .byte ?     ; Length of the text of the current token
>081f					ARGUMENTSP  .word ?     ; Pointer to the top of the argument stack
>0821					OPERATORSP  .word ?     ; Pointer to the top of the operator stack
>0823					ARGUMENT1   .dword ?    ; Argument 1 for expression calculations
>0827					ARGTYPE1    .byte ?     ; Type code for argument 1 (integer, float, string)
>0828					SIGN1       .byte ?     ; Temporary sign marker for argument 1
>0829					ARGUMENT2   .dword ?    ; Argument 2 for expression calculations
>082d					ARGTYPE2    .byte ?     ; Type code for argument 2 (integer, float, string)
>082e					SIGN2       .byte ?     ; Temporary sign marker for argument 1
>082f					JMP16PTR    .word ?     ; Pointer for 16-bit indirect jumps (within BASIC816's code base)
>0831					GOSUBDEPTH  .word ?     ; Number of GOSUBs on the stack
>0833					RETURNSP    .word ?     ; Pointer to the top of the return stack
>0835					SKIPNEST    .byte ?     ; Flag to indicate if token seeking should respect nesting (MSB set if so)
>0836					NESTING     .byte ?     ; Counter of the depth of lexical nesting for FOR/NEXT, DO/LOOP
>0837					TARGETTOK   .byte ?     ; When searching for a token, TARGETTOK is the token to find
>0838					DATABIP     .dword ?    ; Pointer to the next data element for READ statements
>083c					DATALINE    .dword ?    ; Pointer to the current line for a DATA statement
>0840					SAVEBIP     .dword ?    ; Spot to save BIP temporarily
>0844					SAVELINE    .dword ?    ; Spot to save CURLINE temporarily
=$000848				MONITOR_VARS = *
>0848					MCMDADDR    .long ?     ;3 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
>084b					MCMP_TEXT   .long ?     ;3 Bytes Address of symbol being evaluated for COMPARE routine
>084e					MCMP_LEN    .word ?     ;2 Bytes Length of symbol being evaluated for COMPARE routine
>0850					MCMD        .long ?     ;3 Bytes Address of the current command/function string
>0853					MCMD_LEN    .word ?     ;2 Bytes Length of the current command/function string
>0855					MARG1       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command
>0859					MARG2       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>085d					MARG3       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0861					MARG4       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0865					MARG5       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0869					MARG6       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>086d					MARG7       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0871					MARG8       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0875					MARG9       .dword ?    ;4 Bytes First command argument.
>0879					MARG_LEN    .byte ?     ;1 Byte count of the number of arguments passed
>087a					MCURSOR     .dword ?    ;4 Bytes Pointer to the current memory location for disassembly, memory dump, etc.
>087e					MLINEBUF    .fill 17    ;17 Byte buffer for dumping memory (TODO: could be moved to a general string scratch area)
>088f					MCOUNT      .long ?     ;2 Byte counter
>0892					MTEMP       .dword ?    ;4 Bytes of temporary space
>0896					MCPUSTAT    .byte ?     ;1 Byte to represent what the disassembler thinks the processor MX bits are
>0897					MADDR_MODE  .byte ?     ;1 Byte address mode found by the assembler
>0898					MPARSEDNUM  .dword ?    ;4 Bytes to store a parsed number
>089c					MMNEMONIC   .word ?     ;2 Byte address of mnemonic found by the assembler
>089e					MTEMPPTR    .dword ?    ;4 Byte temporary pointer
>08a2					MJUMPINST   .byte ?     ;1 Byte JSL opcode
>08a3					MJUMPADDR   .long ?     ;3 Byte address for JSL
=$000823				MANTISSA1 = ARGUMENT1
=$000826				EXPONENT1 = ARGUMENT1+3

;******  Return to file: src\basic816.s


;******  Processing file: src\macros.s


;******  Return to file: src\basic816.s

.1a0000	5c 8a 89 1a	jmp $1a898a	COLDBOOT        JML START               ; Entry point to boot up BASIC from scratch
.1a0004	5c 9c 6f 1a	jmp $1a6f9c	MONITOR         JML IMONITOR            ; Entry point to the machine language monitor
.1a0008	5c 36 27 1a	jmp $1a2736	READLINE        JML IREADLINE           ; Wait for the user to enter a line of text (for programming input)
.1a000c	5c ba 02 1a	jmp $1a02ba	SCRCOPYLINE     JML ISCRCPYLINE         ; Copy the line on the screen the user just input to INPUTBUF
.1a0010	5c 58 00 1a	jmp $1a0058	INPUTLINE       JML IINPUTLINE          ; Read a single line of text from the user, and copy it to TEMPBUF (for INPUT statement)
.1a0014	5c b8 00 1a	jmp $1a00b8	GETKEY          JML IGETKEY             ; Wait for a keypress by the user and return the ASCII code in A
.1a0018	5c d4 03 1a	jmp $1a03d4	PRINTC          JML IPRINTC             ; Print the character in A to the console
.1a001c	5c 5e 02 1a	jmp $1a025e	SHOWCURSOR      JML ISHOWCURSOR         ; Set cursor visibility: A=0, hide... A<>0, show.
.1a0020	5c 79 02 1a	jmp $1a0279	CURSORXY        JML ICURSORXY           ; Set the position of the cursor to (X, Y)
.1a0024	5c 80 02 1a	jmp $1a0280	CLSCREEN        JML ICLSCREEN           ; Clear the screen

;******  Processing file: src\bios.s


;******  Processing file: src\membuffers.s

>08a6					OBUFFER     .long ?     ; Pointer to the current text memory buffer for output
>08a9					OBUFFSIZE   .word ?     ; Maximum size of output text memory buffer
>08ab					OBUFFIDX    .word ?     ; Index into the current output buffer
>08ad					IBUFFER     .long ?     ; Pointer to the current text memory buffer for input
>08b0					IBUFFSIZE   .word ?     ; Number of bytes written to the buffer
>08b2					IBUFFIDX    .word ?     ; Index into the current input buffer (next available character)
.1a0028					OBUFF_PUTC
.1a0028	0b		phd		                PHD
.1a0029	08		php		                PHP
.1a002a	08		php		            PHP
.1a002b	c2 20		rep #$20	            REP #$20
.1a002d	48		pha		            PHA
.1a002e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0031	5b		tcd		            TCD
.1a0032	68		pla		            PLA
.1a0033	28		plp		            PLP
.1a0034	e2 20		sep #$20	            SEP #$20
.1a0036	85 b5		sta $08b5	                STA SAVE_A
.1a0038	c2 20		rep #$20	            REP #$20
.1a003a	a5 a6		lda $08a6	                LDA OBUFFER
.1a003c	d0 06		bne $1a0044	                BNE has_buffer
.1a003e	e2 20		sep #$20	            SEP #$20
.1a0040	a5 a8		lda $08a8	                LDA OBUFFER+2
.1a0042	f0 11		beq $1a0055	                BEQ done
.1a0044					has_buffer
.1a0044	c2 10		rep #$10	            REP #$10
.1a0046	a4 ab		ldy $08ab	                LDY OBUFFIDX        ; Check to make sure there is room
.1a0048	c4 a9		cpy $08a9	                CPY OBUFFSIZE
.1a004a	f0 09		beq $1a0055	                BEQ done            ; If not, exit silently
.1a004c	e2 20		sep #$20	            SEP #$20
.1a004e	a5 b5		lda $08b5	                LDA SAVE_A
.1a0050	97 a6		sta [$08a6],y	                STA [OBUFFER],Y     ; Write the character to the buffer
.1a0052	c8		iny		                INY                 ; Increment the index
.1a0053	84 ab		sty $08ab	                STY OBUFFIDX
.1a0055	28		plp		done            PLP
.1a0056	2b		pld		                PLD
.1a0057	60		rts		            RTS

;******  Return to file: src\bios.s


;******  Processing file: src\C256/io_c256.s


;******  Processing file: src\C256/kernel_c256.s

=$00104c				FK_GETCHW           = $00104c ; Get a character from the input channel. Waits until data received. A=0 and Carry=1 if no data is wating
=$001018				FK_PUTC             = $001018 ; Print a character to the currently selected channel
=$00101c				FK_PUTS             = $00101C ; Print a string to the currently selected channel
=$001080				FK_PRINTAH          = $001080 ; Prints hex value in A. Printed value is 2 wide if M flag is 1, 4 wide if M=0
=$001084				FK_LOCATE           = $001084 ; Reposition the cursor to row Y column X
=$001078				FK_IPRINTH          = $001078 ; Print a HEX string
=$00103c				FK_SETOUT           = $00103c ; Select an output channel
=$00112c				FK_SETSIZES         = $00112C ; Set the text screen size variables based on the border and screen resolution.
=$0010f0				FK_OPEN             = $0010F0 ; open a file for reading/writing/creating
=$0010f4				FK_CREATE           = $0010F4 ; create a new file
=$0010f8				FK_CLOSE            = $0010F8 ; close a file (make sure last cluster is written)
=$0010fc				FK_WRITE            = $0010FC ; write the current cluster to the file
=$001100				FK_READ             = $001100 ; read the next cluster from the file
=$001104				FK_DELETE           = $001104 ; delete a file / directory
=$001108				FK_DIROPEN          = $001108 ; open a directory and seek the first directory entry
=$00110c				FK_DIRNEXT          = $00110C ; seek to the next directory of an open directory
=$001110				FK_DIRREAD          = $001110 ; Read the directory entry for the specified file
=$001114				FK_DIRWRITE         = $001114 ; Write any changes in the current directory cluster back to the drive
=$001118				FK_LOAD             = $001118 ; load a binary file into memory, supports multiple file formats
=$00111c				FK_SAVE             = $00111C ; Save memory to a binary file
=$001124				FK_RUN              = $001124 ; Load and run an executable binary file
=$001130				FK_COPY             = $001130 ; Copy a file
=$001120				FK_CMDBLOCK         = $001120 ; Send a command to a block device
=$00113c				FK_TESTBREAK        = $00113C ; Check if BREAK was pressed recently by the user (C is set if true, clear if false)
=0					CHAN_CONSOLE = 0
=1					CHAN_COM1 = 1
=2					CHAN_COM2 = 2

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/RTC_inc.s

=$af0800				RTC_SEC       = $AF0800 ;Seconds Register
=$af0801				RTC_SEC_ALARM = $AF0801 ;Seconds Alarm Register
=$af0802				RTC_MIN       = $AF0802 ;Minutes Register
=$af0803				RTC_MIN_ALARM = $AF0803 ;Minutes Alarm Register
=$af0804				RTC_HRS       = $AF0804 ;Hours Register
=$af0805				RTC_HRS_ALARM = $AF0805 ;Hours Alarm Register
=$af0806				RTC_DAY       = $AF0806 ;Day Register
=$af0807				RTC_DAY_ALARM = $AF0807 ;Day Alarm Register
=$af0808				RTC_DOW       = $AF0808 ;Day of Week Register
=$af0809				RTC_MONTH     = $AF0809 ;Month Register
=$af080a				RTC_YEAR      = $AF080A ;Year Register
=$af080b				RTC_RATES     = $AF080B ;Rates Register
=$af080c				RTC_ENABLE    = $AF080C ;Enables Register
=$af080d				RTC_FLAGS     = $AF080D ;Flags Register
=$af080e				RTC_CTRL      = $AF080E ;Control Register
=$af080f				RTC_CENTURY   = $AF080F ;Century Register

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/keyboard.s


;******  Processing file: src\C256/keyboard_def.s

=$af1064				STATUS_PORT 	        =	$AF1064
=$af1060				KBD_OUT_BUF 	        =	$AF1060
=$af1060				KBD_INPT_BUF	        = $AF1060
=$af1064				KBD_CMD_BUF		        = $AF1064
=$af1060				KBD_DATA_BUF	        = $AF1060
=$af1060				PORT_A			          =	$AF1060
=$af1061				PORT_B			          =	$AF1061
=$01					OUT_BUF_FULL  =	$01
=$02					INPT_BUF_FULL	=	$02
=$04					SYS_FLAG		  =	$04
=$08					CMD_DATA		  =	$08
=$10					KEYBD_INH     =	$10
=$20					TRANS_TMOUT	  =	$20
=$40					RCV_TMOUT		  =	$40
=$80					PARITY_EVEN		=	$80
=$10					INH_KEYBOARD	=	$10
=$ae					KBD_ENA			  =	$AE
=$ad					KBD_DIS			  =	$AD
=$f1					KB_MENU			  =	$F1
=$f4					KB_ENABLE		  =	$F4
=$f7					KB_MAKEBREAK  =	$F7
=$fe					KB_ECHO			  =	$FE
=$ff					KB_RESET		  =	$FF
=$ed					KB_LED_CMD		=	$ED
=$aa					KB_OK			    =	$AA
=$fa					KB_ACK			  =	$FA
=$ff					KB_OVERRUN		=	$FF
=$fe					KB_RESEND		  =	$FE
=$f0					KB_BREAK		  =	$F0
=$10					KB_FA			    =	$10
=$20					KB_FE			    =	$20
=$40					KB_PR_LED		  =	$40
=$01					KB_SCROLL_LOCK      = $01
=$02					KB_NUM_LOCK         = $02
=$04					KB_CAPS_LOCK        = $04
=2					ANSI_IN_INS = 2     ; ANSI input code for INSERT
=3					ANSI_IN_DEL = 3     ; ANSI input code for DELETE
=24					ANSI_IN_F12 = 24    ; ANSI input code for F12
=8					ANSI_IN_CTRL = 8    ; ANSI input modifier flag for CTRL

;******  Return to file: src\C256/keyboard.s

.1a0058					IINPUTLINE
.1a0058	08		php		                PHP
.1a0059	c2 10		rep #$10	            REP #$10
.1a005b	e2 20		sep #$20	            SEP #$20
.1a005d	a9 01		lda #$01	                LDA #1              ; Show the cursor
.1a005f	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a0062	a2 00 00	ldx #$0000	                LDX #0
.1a0065	a9 00		lda #$00	                LDA #0
.1a0067	9f 00 4c 00	sta $004c00,x	zero_loop       STA @lIOBUF,X
.1a006b	e8		inx		                INX
.1a006c	e0 00 01	cpx #$0100	                CPX #$100
.1a006f	d0 f6		bne $1a0067	                BNE zero_loop
.1a0071	a2 00 00	ldx #$0000	                LDX #0
.1a0074					getchar
.1a0074	20 14 00	jsr $1a0014	            JSR GETKEY
.1a0077	c9 0d		cmp #$0d	                CMP #CHAR_CR        ; Got a CR?
.1a0079	d0 03		bne $1a007e	                BNE not_cr
.1a007b	4c b1 00	jmp $1a00b1	                JMP endofline       ; Yes: we're done
.1a007e					not_cr
.1a007e	c9 08		cmp #$08	not_right       CMP #CHAR_BS        ; Is it a backspace?
.1a0080	d0 1a		bne $1a009c	                BNE not_bs
.1a0082	e0 00 00	cpx #$0000	                CPX #0              ; Are we at the beginning of the line?
.1a0085	f0 ed		beq $1a0074	                BEQ getchar         ; yes: ignore the backspace
.1a0087	da		phx		                PHX                 ; Save the cursor position
.1a0088	bf 01 4c 00	lda $004c01,x	clr_loop        LDA @lIOBUF+1,X     ; Get the character above
.1a008c	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the current position
.1a0090	f0 06		beq $1a0098	                BEQ done_clr        ; If we copied a NUL, we're done copying
.1a0092	e8		inx		                INX                 ; Otherwise, keep copying down
.1a0093	e0 ff 00	cpx #$00ff	                CPX #$FF            ; Until we're at the end of the buffer
.1a0096	d0 f0		bne $1a0088	                BNE clr_loop
.1a0098	fa		plx		done_clr        PLX                 ; Restore the cursor position
.1a0099	ca		dex		                DEX                 ; No: move the cursor left
.1a009a	80 0e		bra $1a00aa	                BRA print_bs        ; And print the backspace
.1a009c	c9 20		cmp #$20	not_bs          CMP #$20            ; Is it in range 00 -- 1F?
.1a009e	90 d4		bcc $1a0074	                BLT getchar         ; Yes: ignore it
.1a00a0	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the input buffer
.1a00a4	e8		inx		                INX                 ; Move the cursor forward
.1a00a5					echo
.1a00a5	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00a8	80 ca		bra $1a0074	                BRA getchar         ; And get another...
.1a00aa	a9 08		lda #$08	print_bs        LDA #CHAR_BS        ; Backspace character...
.1a00ac	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00af	80 c3		bra $1a0074	                BRA getchar         ; And get another...
.1a00b1	a9 00		lda #$00	endofline       LDA #0              ; Hide the cursor
.1a00b3	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a00b6	28		plp		                PLP
.1a00b7	60		rts		            RTS
.1a00b8					IGETKEY
.1a00b8	da		phx		                PHX
.1a00b9	5a		phy		                PHY
.1a00ba	8b		phb		                PHB
.1a00bb	0b		phd		                PHD
.1a00bc	08		php		                PHP
.1a00bd	22 4c 10 00	jsl $00104c	                JSL FK_GETCHW
.1a00c1	28		plp		                PLP
.1a00c2	2b		pld		                PLD
.1a00c3	ab		plb		                PLB
.1a00c4	7a		ply		                PLY
.1a00c5	fa		plx		                PLX
.1a00c6	60		rts		            RTS
=0					GK_ST_INIT = 0      ; GETKEYE state: initial
=1					GK_ST_ESC = 1       ; GETKEYE state: ESC seen
=2					GK_ST_CSI = 2       ; GETKEYE state: CSI "ESC[" seen
=3					GK_ST_CODE = 3      ; GETKEYE state: We're at the command code in the sequence
=4					GK_ST_MODS = 4      ; GETKEYE state: We're at the modifier code in the sequence
.1a00c7					SEND_ANSI
.1a00c7	08		php		                PHP
.1a00c8	e2 30		sep #$30	            SEP #$30
.1a00ca	48		pha		                PHA
.1a00cb	a9 1b		lda #$1b	                LDA #CHAR_ESC           ; Print ESC
.1a00cd	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00d0	a9 5b		lda #$5b	                LDA #'['                ; Print [
.1a00d2	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00d5	68		pla		                PLA                     ; Print the command code
.1a00d6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00d9	28		plp		                PLP
.1a00da	60		rts		            RTS
.1a00db					GETKEYE
.1a00db	0b		phd		                PHD
.1a00dc	8b		phb		                PHB
.1a00dd	08		php		                PHP
.1a00de	08		php		            PHP
.1a00df	e2 20		sep #$20	            SEP #$20
.1a00e1	48		pha		            PHA
.1a00e2	a9 00		lda #$00	            LDA #0
.1a00e4	48		pha		            PHA
.1a00e5	ab		plb		            PLB
.1a00e6	68		pla		            PLA
.1a00e7	28		plp		            PLP
.1a00e8	08		php		            PHP
.1a00e9	c2 20		rep #$20	            REP #$20
.1a00eb	48		pha		            PHA
.1a00ec	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a00ef	5b		tcd		            TCD
.1a00f0	68		pla		            PLA
.1a00f1	28		plp		            PLP
.1a00f2					locals
>0001					l_character     .byte ?                 ; The character returned by the input stream
>0002					l_state         .byte ?                 ; Current state of the input parser
>0003					l_code          .byte ?                 ; Code number for any escaped input sequence
>0004					l_modifiers     .byte ?                 ; Modifier bit field for any escaped input sequence
.1a00f2	c2 20		rep #$20	            REP #$20
.1a00f4	3b		tsc		            TSC
.1a00f5	38		sec		            SEC
.1a00f6	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.1a00f9	1b		tcs		            TCS
.1a00fa	e2 20		sep #$20	            SEP #$20
.1a00fc	a9 00		lda #$00	get_reset       LDA #0                  ; Initialize state, code, and modifiers
.1a00fe	83 02		sta $02,s	                STA l_state
.1a0100	83 03		sta $03,s	                STA l_code
.1a0102	83 04		sta $04,s	                STA l_modifiers
.1a0104					loop
.1a0104	20 14 00	jsr $1a0014	            JSR GETKEY
.1a0107	c9 00		cmp #$00	                CMP #0                  ; Is it 0?
.1a0109	f0 f9		beq $1a0104	                BEQ loop                ; Yes: keep waiting
.1a010b	83 01		sta $01,s	                STA l_character         ; Save the character
.1a010d	a3 02		lda $02,s	                LDA l_state             ; What is the current state?
.1a010f	d0 35		bne $1a0146	                BNE chk_st_esc
.1a0111	a3 01		lda $01,s	                LDA l_character         ; Get the character back
.1a0113	c9 08		cmp #$08	                CMP #CHAR_BS            ; Is it a backspace?
.1a0115	d0 0a		bne $1a0121	                BNE not_bs
.1a0117	20 18 00	jsr $1a0018	            JSR PRINTC
.1a011a	a9 50		lda #$50	                LDA #'P'
.1a011c	20 c7 00	jsr $1a00c7	            JSR SEND_ANSI
.1a011f	80 e3		bra $1a0104	                BRA loop                ; And keep waiting for a keypress
.1a0121	c9 0d		cmp #$0d	not_bs          CMP #CHAR_CR            ; Is it a carriage return?
.1a0123	f0 0a		beq $1a012f	                BEQ send                ; Yes: print and return it
.1a0125	c9 1b		cmp #$1b	                CMP #CHAR_ESC           ; Is it ESC?
.1a0127	d0 06		bne $1a012f	                BNE send                ; No: just print it out
.1a0129	a9 01		lda #$01	                LDA #GK_ST_ESC          ; Yes: move to the ESC state
.1a012b	83 02		sta $02,s	                STA l_state
.1a012d	80 d5		bra $1a0104	                BRA loop                ; And get the next character in the sequence
.1a012f					send
.1a012f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a0132	a3 01		lda $01,s	done            LDA l_character         ; Save the character so we can return it
.1a0134	85 0c		sta $080c	                STA SCRATCH
.1a0136	c2 20		rep #$20	            REP #$20
.1a0138	3b		tsc		            TSC
.1a0139	18		clc		            CLC
.1a013a	69 04 00	adc #$0004	            ADC #SIZE(locals)
.1a013d	1b		tcs		            TCS
.1a013e	e2 20		sep #$20	            SEP #$20
.1a0140	a5 0c		lda $080c	                LDA SCRATCH             ; Restore the character we're returning
.1a0142	28		plp		                PLP
.1a0143	2b		pld		                PLD
.1a0144	ab		plb		                PLB
.1a0145	60		rts		            RTS
.1a0146	c9 01		cmp #$01	chk_st_esc      CMP #GK_ST_ESC          ; Are we in the ESC state?
.1a0148	d0 10		bne $1a015a	                BNE chk_st_csi          ; No: check to see if we're in CSI state
.1a014a	a3 01		lda $01,s	                LDA l_character         ; Get the character
.1a014c	c9 5b		cmp #$5b	                CMP #'['                ; Is it "["?
.1a014e	f0 03		beq $1a0153	                BEQ go_st_csi           ; Yes: go to the CSI state
.1a0150	82 a9 ff	brl $1a00fc	                BRL get_reset           ; Reset the state machine and keep reading characters
.1a0153	a9 02		lda #$02	go_st_csi       LDA #GK_ST_CSI          ; Yes: move to the CSI state
.1a0155	83 02		sta $02,s	                STA l_state
.1a0157	82 aa ff	brl $1a0104	                BRL loop
.1a015a	c9 02		cmp #$02	chk_st_csi      CMP #GK_ST_CSI          ; Are we in the CSI state?
.1a015c	d0 29		bne $1a0187	                BNE chk_st_code         ; No: check to see if we're in the code state
.1a015e	a3 01		lda $01,s	                LDA l_character         ; Check the character
.1a0160	c9 41		cmp #$41	                CMP #'A'                ; Is it in 'A'..'D'?
.1a0162	90 0c		bcc $1a0170	                BLT not_letter
.1a0164	c9 45		cmp #$45	                CMP #'D'+1
.1a0166	b0 08		bcs $1a0170	                BGE not_letter
.1a0168	a3 01		lda $01,s	                LDA l_character         ; Yes: it's a cursor key, send the sequence to the screen
.1a016a	20 c7 00	jsr $1a00c7	            JSR SEND_ANSI
.1a016d	82 8c ff	brl $1a00fc	                BRL get_reset           ; Reset the state machine and keep reading characters
.1a0170	c9 30		cmp #$30	not_letter      CMP #'0'                ; Is it in range '0'..'9'?
.1a0172	90 10		bcc $1a0184	                BLT not_csi_digit
.1a0174	c9 3a		cmp #$3a	                CMP #'9'+1
.1a0176	b0 0c		bcs $1a0184	                BGE not_csi_digit       ; No: handle it being invalid
.1a0178	38		sec		                SEC                     ; Yes: convert to a value
.1a0179	e9 30		sbc #$30	                SBC #'0'
.1a017b	83 03		sta $03,s	                STA l_code              ; And save it to the code variable
.1a017d	a9 03		lda #$03	                LDA #GK_ST_CODE         ; Move to the CODE state
.1a017f	83 02		sta $02,s	                STA l_state
.1a0181	82 80 ff	brl $1a0104	                BRL loop
.1a0184	82 75 ff	brl $1a00fc	not_csi_digit   BRL get_reset           ; Bad sequence: reset and keep reading characters
.1a0187	c9 03		cmp #$03	chk_st_code     CMP #GK_ST_CODE         ; Is it the CODE state?
.1a0189	d0 41		bne $1a01cc	                BNE chk_st_mods         ; No: check to see if it's MODIFIERS
.1a018b	a3 01		lda $01,s	                LDA l_character         ; Check the character
.1a018d	c9 30		cmp #$30	                CMP #'0'                ; Is it in the range '0'..'9'
.1a018f	90 29		bcc $1a01ba	                BLT not_digits_2
.1a0191	c9 3a		cmp #$3a	                CMP #'9'+1
.1a0193	b0 25		bcs $1a01ba	                BGE not_digits_2
.1a0195	a3 03		lda $03,s	                LDA l_code              ; Multiply l_code by 2
.1a0197	8f 00 01 00	sta $000100	                STA @l UNSIGNED_MULT_A_LO
.1a019b	a9 00		lda #$00	                LDA #0
.1a019d	8f 01 01 00	sta $000101	                STA @l UNSIGNED_MULT_A_HI
.1a01a1	8f 03 01 00	sta $000103	                STA @l UNSIGNED_MULT_B_HI
.1a01a5	a9 0a		lda #$0a	                LDA #10
.1a01a7	8f 02 01 00	sta $000102	                STA @l UNSIGNED_MULT_B_LO
.1a01ab	a3 01		lda $01,s	                LDA l_character         ; Convert the digit to a number
.1a01ad	38		sec		                SEC
.1a01ae	e9 30		sbc #$30	                SBC #'0'
.1a01b0	18		clc		                CLC                     ; And add to l_code
.1a01b1	6f 04 01 00	adc $000104	                ADC @l UNSIGNED_MULT_AL_LO
.1a01b5	83 03		sta $03,s	                STA l_code
.1a01b7	82 4a ff	brl $1a0104	                BRL loop                ; And keep processing the sequence
.1a01ba	c9 3b		cmp #$3b	not_digits_2    CMP #';'                ; Is it the semicolon?
.1a01bc	d0 07		bne $1a01c5	                BNE not_semi
.1a01be	a9 04		lda #$04	                LDA #GK_ST_MODS         ; Yes: Move to the MODIFIERS state
.1a01c0	83 02		sta $02,s	                STA l_state
.1a01c2	82 3f ff	brl $1a0104	                BRL loop
.1a01c5	c9 7e		cmp #$7e	not_semi        CMP #'~'                ; No: Is it the tilda?
.1a01c7	f0 40		beq $1a0209	                BEQ end_sequence        ; Yes: we've gotten the end of the sequence
.1a01c9	82 30 ff	brl $1a00fc	                BRL get_reset           ; No: we've got a bad sequence... for now just reset and keep looping
.1a01cc	c9 04		cmp #$04	chk_st_mods     CMP #GK_ST_MODS         ; Are we in the MODIFIERS state?
.1a01ce	f0 03		beq $1a01d3	                BEQ do_mods
.1a01d0	82 5f ff	brl $1a0132	                BRL done                ; No: we're done
.1a01d3	a3 01		lda $01,s	do_mods         LDA l_character         ; Check the character
.1a01d5	c9 30		cmp #$30	                CMP #'0'                ; Is it in the range '0'..'9'
.1a01d7	90 29		bcc $1a0202	                BLT not_digits_3
.1a01d9	c9 3a		cmp #$3a	                CMP #'9'+1
.1a01db	b0 25		bcs $1a0202	                BGE not_digits_3
.1a01dd	a3 04		lda $04,s	                LDA l_modifiers         ; Multiply l_modifiers by 2
.1a01df	8f 00 01 00	sta $000100	                STA @l UNSIGNED_MULT_A_LO
.1a01e3	a9 00		lda #$00	                LDA #0
.1a01e5	8f 01 01 00	sta $000101	                STA @l UNSIGNED_MULT_A_HI
.1a01e9	8f 03 01 00	sta $000103	                STA @l UNSIGNED_MULT_B_HI
.1a01ed	a9 0a		lda #$0a	                LDA #10
.1a01ef	8f 02 01 00	sta $000102	                STA @l UNSIGNED_MULT_B_LO
.1a01f3	a3 01		lda $01,s	                LDA l_character         ; Convert the digit to a number
.1a01f5	38		sec		                SEC
.1a01f6	e9 30		sbc #$30	                SBC #'0'
.1a01f8	18		clc		                CLC                     ; And add to l_modifiers
.1a01f9	6f 04 01 00	adc $000104	                ADC @l UNSIGNED_MULT_AL_LO
.1a01fd	83 04		sta $04,s	                STA l_modifiers
.1a01ff	82 02 ff	brl $1a0104	                BRL loop                ; And keep processing the sequence
.1a0202	c9 7e		cmp #$7e	not_digits_3    CMP #'~'                ; No: Is it the tilda?
.1a0204	f0 03		beq $1a0209	                BEQ end_sequence        ; Yes: we've gotten the end of the sequence
.1a0206	82 f3 fe	brl $1a00fc	                BRL get_reset           ; No: we've got a bad sequence... for now just reset and keep looping
.1a0209	a3 03		lda $03,s	end_sequence    LDA l_code              ; Get the code
.1a020b	c9 02		cmp #$02	                CMP #ANSI_IN_INS        ; Is it INSERT?
.1a020d	f0 0b		beq $1a021a	                BEQ do_ins              ; Yes: process the insert
.1a020f	c9 03		cmp #$03	                CMP #ANSI_IN_DEL        ; Is it DELETE?
.1a0211	f0 0b		beq $1a021e	                BEQ do_del              ; Yes: process the delete
.1a0213	c9 18		cmp #$18	                CMP #ANSI_IN_F12        ; Is it F12?
.1a0215	f0 0f		beq $1a0226	                BEQ do_f12              ; Yes: process the F12 key
.1a0217	82 e2 fe	brl $1a00fc	                BRL get_reset           ; Code is not one we handle, just return
.1a021a	a9 40		lda #$40	do_ins          LDA #'@'                ; Send the ANSI ICH command
.1a021c	80 02		bra $1a0220	                BRA snd_ansi
.1a021e	a9 50		lda #$50	do_del          LDA #'P'                ; Send the ANSI DCH command
.1a0220					snd_ansi
.1a0220	20 c7 00	jsr $1a00c7	            JSR SEND_ANSI
.1a0223	82 d6 fe	brl $1a00fc	                BRL get_reset           ; Reset and keep getting characters
.1a0226	a5 d2		lda $08d2	do_f12          LDA STATE               ; Check the state
.1a0228	d0 10		bne $1a023a	                BNE skip_f12            ; If we're running, ignore the F12
.1a022a	a3 04		lda $04,s	                LDA l_modifiers         ; Check to make sure it's CTRL-F12
.1a022c	c9 08		cmp #$08	                CMP #ANSI_IN_CTRL       ; Modifier flag for CTRL
.1a022e	d0 0a		bne $1a023a	                BNE skip_f12
.1a0230	a9 1b		lda #$1b	                LDA #CHAR_ESC           ; Send ESC_ (APC) to show the credits
.1a0232	20 18 00	jsr $1a0018	            JSR PRINTC
.1a0235	a9 5f		lda #$5f	                LDA #'_'
.1a0237	20 18 00	jsr $1a0018	            JSR PRINTC
.1a023a	82 bf fe	brl $1a00fc	skip_f12        BRL get_reset           ; And reset the state machine

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/screen.s

.1a023d					ENSURETEXT
.1a023d	08		php		            PHP
.1a023e	e2 20		sep #$20	            SEP #$20
.1a0240	af 00 00 af	lda $af0000	            LDA @l MASTER_CTRL_REG_L            ; Get the current display mode
.1a0244	89 3c		bit #$3c	            BIT #Mstr_Ctrl_Graph_Mode_En | Mstr_Ctrl_Bitmap_En | Mstr_Ctrl_TileMap_En | Mstr_Ctrl_Sprite_En
.1a0246	f0 08		beq $1a0250	            BEQ textonly                        ; If not, make sure text is enabled
.1a0248					overlay
.1a0248	09 03		ora #$03	            ORA #Mstr_Ctrl_Text_Mode_En | Mstr_Ctrl_Text_Overlay
.1a024a	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.1a024e	80 0c		bra $1a025c	            BRA done
.1a0250					textonly
.1a0250	09 01		ora #$01	            ORA #Mstr_Ctrl_Text_Mode_En
.1a0252	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.1a0256	a9 00		lda #$00	            LDA #CHAN_CONSOLE                   ; Make sure we're writing to the main screen
.1a0258	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.1a025c	28		plp		done        PLP
.1a025d	60		rts		            RTS
.1a025e					ISHOWCURSOR
.1a025e	08		php		            PHP
.1a025f	e2 20		sep #$20	            SEP #$20
.1a0261	c9 00		cmp #$00	            CMP #0
.1a0263	f0 08		beq $1a026d	            BEQ hide
.1a0265	af 10 00 af	lda $af0010	show        LDA @lVKY_TXT_CURSOR_CTRL_REG
.1a0269	09 01		ora #$01	            ORA #Vky_Cursor_Enable
.1a026b	80 06		bra $1a0273	            BRA setit
.1a026d	af 10 00 af	lda $af0010	hide        LDA @lVKY_TXT_CURSOR_CTRL_REG
.1a0271	29 fe		and #$fe	            AND #~Vky_Cursor_Enable
.1a0273	8f 10 00 af	sta $af0010	setit       STA @lVKY_TXT_CURSOR_CTRL_REG
.1a0277	28		plp		            PLP
.1a0278	60		rts		            RTS
.1a0279					ICURSORXY
.1a0279	08		php		            PHP
.1a027a	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.1a027e	28		plp		            PLP
.1a027f	60		rts		            RTS
.1a0280					ICLSCREEN
.1a0280	48		pha		            PHA
.1a0281	da		phx		            PHX
.1a0282	5a		phy		            PHY
.1a0283	0b		phd		            PHD
.1a0284	08		php		            PHP
.1a0285	e2 20		sep #$20	            SEP #$20
.1a0287	c2 10		rep #$10	            REP #$10
.1a0289	a2 00 00	ldx #$0000	            LDX #0
.1a028c	a9 20		lda #$20	loop        LDA #$20
.1a028e	9f 00 a0 af	sta $afa000,x	            STA @lCS_TEXT_MEM_PTR,X     ; Write a space in the text cell
.1a0292	af 1e 00 00	lda $00001e	            LDA @lCURCOLOR
.1a0296	9f 00 c0 af	sta $afc000,x	            STA @lCS_COLOR_MEM_PTR,X    ; Set the color to green on black
.1a029a	e8		inx		            INX                         ; Move to the next character cell
.1a029b	e0 00 20	cpx #$2000	            CPX #$2000
.1a029e	d0 ec		bne $1a028c	            BNE loop
.1a02a0	08		php		            PHP
.1a02a1	c2 20		rep #$20	            REP #$20
.1a02a3	48		pha		            PHA
.1a02a4	a9 00 00	lda #$0000	            LDA #0
.1a02a7	5b		tcd		            TCD
.1a02a8	68		pla		            PLA
.1a02a9	28		plp		            PLP
.1a02aa	a2 00 00	ldx #$0000	            LDX #0                      ; Set cursor to upper-left corner
.1a02ad	a0 00 00	ldy #$0000	            LDY #0
.1a02b0	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.1a02b4	28		plp		            PLP
.1a02b5	2b		pld		            PLD
.1a02b6	7a		ply		            PLY
.1a02b7	fa		plx		            PLX
.1a02b8	68		pla		            PLA
.1a02b9	60		rts		            RTS
.1a02ba					ISCRCPYLINE
.1a02ba	da		phx		            PHX
.1a02bb	5a		phy		            PHY
.1a02bc	0b		phd		            PHD
.1a02bd	08		php		            PHP
.1a02be	08		php		            PHP
.1a02bf	c2 20		rep #$20	            REP #$20
.1a02c1	48		pha		            PHA
.1a02c2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a02c5	5b		tcd		            TCD
.1a02c6	68		pla		            PLA
.1a02c7	28		plp		            PLP
.1a02c8	c2 30		rep #$30	            REP #$30
.1a02ca	af 0c 00 00	lda $00000c	            LDA @l SCREENBEGIN      ; Set INDEX to the first byte of the text screen
.1a02ce	85 08		sta $0808	            STA INDEX
.1a02d0	e2 20		sep #$20	            SEP #$20
.1a02d2	af 0e 00 00	lda $00000e	            LDA @l SCREENBEGIN+2
.1a02d6	c2 20		rep #$20	            REP #$20
.1a02d8	29 ff 00	and #$00ff	            AND #$00FF
.1a02db	85 0a		sta $080a	            STA INDEX+2
.1a02dd	af 11 00 00	lda $000011	            LDA @l COLS_PER_LINE    ; Calculate the offset to the current line
.1a02e1	8f 08 01 00	sta $000108	            STA @l M1_OPERAND_A
.1a02e5	af 1c 00 00	lda $00001c	            LDA @l CURSORY
.1a02e9	3a		dec a		            DEC A
.1a02ea	8f 0a 01 00	sta $00010a	            STA @l M1_OPERAND_B
.1a02ee	18		clc		            CLC                     ; And add it to INDEX
.1a02ef	a5 08		lda $0808	            LDA INDEX
.1a02f1	6f 0c 01 00	adc $00010c	            ADC @l M1_RESULT
.1a02f5	85 08		sta $0808	            STA INDEX
.1a02f7	a5 0a		lda $080a	            LDA INDEX+2
.1a02f9	69 00 00	adc #$0000	            ADC #0
.1a02fc	85 0a		sta $080a	            STA INDEX+2
.1a02fe	e2 20		sep #$20	            SEP #$20
.1a0300	af 0f 00 00	lda $00000f	            LDA @l COLS_VISIBLE
.1a0304	85 8f		sta $088f	            STA MCOUNT
.1a0306	a0 00 00	ldy #$0000	            LDY #0
.1a0309	a2 00 00	ldx #$0000	            LDX #0
.1a030c	b7 08		lda [$0808],y	copy_loop   LDA [INDEX],Y           ; Copy a byte from the screen to the input buffer
.1a030e	9f 00 4f 00	sta $004f00,x	            STA @l INPUTBUF,X
.1a0312	e8		inx		            INX
.1a0313	c8		iny		            INY
.1a0314	c4 8f		cpy $088f	            CPY MCOUNT
.1a0316	d0 f4		bne $1a030c	            BNE copy_loop
.1a0318	af 0f 00 00	lda $00000f	            LDA @l COLS_VISIBLE     ; Starting from the end of the line...
.1a031c	3a		dec a		            DEC A
.1a031d	aa		tax		            TAX
.1a031e	bf 00 4f 00	lda $004f00,x	trim_loop   LDA @l INPUTBUF,X       ; Replace spaces at the end with NULLs
.1a0322	c9 20		cmp #$20	            CMP #CHAR_SP
.1a0324	d0 09		bne $1a032f	            BNE done
.1a0326	a9 00		lda #$00	            LDA #0
.1a0328	9f 00 4f 00	sta $004f00,x	            STA @l INPUTBUF,X
.1a032c	ca		dex		            DEX
.1a032d	10 ef		bpl $1a031e	            BPL trim_loop
.1a032f	28		plp		done        PLP
.1a0330	2b		pld		            PLD
.1a0331	7a		ply		            PLY
.1a0332	fa		plx		            PLX
.1a0333	60		rts		            RTS

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/gabe_defs.s

=$afe880				GABE_MSTR_CTRL      = $AFE880
=$01					GABE_CTRL_PWR_LED   = $01     ; Controls the LED in the Front of the case (Next to the reset button)
=$02					GABE_CTRL_SDC_LED   = $02     ; Controls the LED in the Front of the Case (Next to SDCard)
=$04					GABE_CTRL_STS_LED0  = $04     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$08					GABE_CTRL_STS_LED1  = $08     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$10					GABE_CTRL_BUZZER    = $10     ; Controls the Buzzer
=$80					GABE_CTRL_WRM_RST   = $80     ; Warm Reset (needs to Setup other registers)
=$afe881				GABE_LED_FLASH_CTRL = $AFE881  ; Flashing LED Control
=$01					GABE_LED0_FLASH_CTRL = $01     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$02					GABE_LED1_FLASH_CTRL = $02     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED1 to manually control)
=$10					GABE_LD0_FLASH_FRQ0   = $10     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$20					GABE_LD0_FLASH_FRQ1   = $20     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$40					GABE_LD1_FLASH_FRQ0   = $40     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$80					GABE_LD1_FLASH_FRQ1   = $80     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$afe882				GABE_RST_AUTH0      = $AFE882 ; Must Contain the BYTE $AD for Reset to Activate
=$afe883				GABE_RST_AUTH1      = $AFE883 ; Must Contain the BYTE $DE for Reset to Activate
=$afe884				GABE_RNG_DAT_LO     = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_DAT_HI     = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe884				GABE_RNG_SEED_LO    = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_SEED_HI    = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe886				GABE_RNG_STAT       = $AFE886 ;
=$80					GABE_RNG_LFSR_DONE  = $80     ; indicates that Output = SEED Database
=$afe886				GABE_RNG_CTRL       = $AFE886 ;
=$01					GABE_RNG_CTRL_EN    = $01     ; Enable the LFSR BLOCK_LEN
=$02					GABE_RNG_CTRL_DV    = $02     ; After Setting the Seed Value, Toggle that Bit for it be registered
=$afe887				GABE_SYS_STAT       = $AFE887 ;
=$01					GABE_SYS_STAT_MID0  = $01     ; Machine ID -- LSB
=$02					GABE_SYS_STAT_MID1  = $02     ; Machine ID --
=$04					GABE_SYS_STAT_MID2  = $04     ; Machine ID -- MSB
=$10					GABE_SYS_STAT_EXP   = $10     ; if Zero, there is an Expansion Card Preset
=$40					GABE_SYS_STAT_CPUA  = $40     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$80					GABE_SYS_STAT_CPUX  = $80     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$afe88a				GABE_SUBVERSION_LO  = $AFE88A
=$afe88b				GABE_SUBVERSION_HI  = $AFE88B
=$afe88c				GABE_VERSION_LO     = $AFE88C
=$afe88d				GABE_VERSION_HI     = $AFE88D
=$afe88e				GABE_MODEL_LO       = $AFE88E
=$afe88f				GABE_MODEL_HI       = $AFE88F

;******  Return to file: src\C256/io_c256.s

=32					BORDER_WIDTH = 32               ; The width of the border (when it is on)
=72					TEXT_COLS_WB = 72               ; Number of columns of text with the border enabled
=52					TEXT_ROWS_WB = 52               ; Number of rows of text with the border enabled
=80					TEXT_COLS_WOB = 80              ; Number of columns of text with no border enabled
=60					TEXT_ROWS_WOB = 60              ; Number of rows of text with no border enabled
.1a0334					INITIO
.1a0334	e2 20		sep #$20	            SEP #$20
.1a0336	a2 00 00	ldx #$0000	            LDX #0              ; Clear all the sprite control shadow registers
.1a0339	a9 00		lda #$00	            LDA #0
.1a033b	9f 18 f0 1a	sta $1af018,x	sp_loop     STA GS_SP_CONTROL,X
.1a033f	e8		inx		            INX
.1a0340	e0 40 00	cpx #$0040	            CPX #SP_MAX
.1a0343	d0 f6		bne $1a033b	            BNE sp_loop
.1a0345	a9 80		lda #$80	            LDA #DEV_SCREEN
.1a0347	8f b4 08 00	sta $0008b4	            STA @lBCONSOLE
.1a034b	e2 20		sep #$20	            SEP #$20
.1a034d	a9 00		lda #$00	            LDA #0                  ; Clear the lock key flags
.1a034f	8f 89 0f 00	sta $000f89	            STA @lKEYBOARD_LOCKS
.1a0353	a9 00		lda #$00	            LDA #0
.1a0355	8f 00 02 af	sta $af0200	            STA @l TL0_CONTROL_REG
.1a0359	8f 0c 02 af	sta $af020c	            STA @l TL1_CONTROL_REG
.1a035d	8f 18 02 af	sta $af0218	            STA @l TL2_CONTROL_REG
.1a0361	8f 24 02 af	sta $af0224	            STA @l TL3_CONTROL_REG
.1a0365					done
.1a0365	60		rts		            RTS
.1a0366					SCREEN_PUTC
.1a0366	08		php		            PHP
.1a0367	e2 20		sep #$20	            SEP #$20
.1a0369	48		pha		            PHA
.1a036a	48		pha		            PHA
.1a036b	a9 00		lda #$00	            LDA #CHAN_CONSOLE       ; Switch to the console device
.1a036d	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.1a0371	68		pla		            PLA
.1a0372	22 18 10 00	jsl $001018	            JSL FK_PUTC
.1a0376	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.1a037a	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.1a037c	d0 f8		bne $1a0376	            BNE loop                ; Yes: wait until it's released
.1a037e	68		pla		            PLA
.1a037f	28		plp		            PLP
.1a0380	60		rts		            RTS
.1a0381					UART_PUTC
.1a0381	08		php		            PHP
.1a0382	e2 20		sep #$20	            SEP #$20
.1a0384	48		pha		            PHA
.1a0385	48		pha		            PHA
.1a0386	a9 01		lda #$01	            LDA #CHAN_COM1          ; Switch to COM1
.1a0388	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.1a038c	68		pla		            PLA
.1a038d	22 18 10 00	jsl $001018	            JSL FK_PUTC
.1a0391	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.1a0395	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.1a0397	d0 f8		bne $1a0391	            BNE loop                ; Yes: wait until it's released
.1a0399	68		pla		            PLA
.1a039a	28		plp		            PLP
.1a039b	60		rts		            RTS
.1a039c					PRINTCR
.1a039c	08		php		            PHP
.1a039d	c2 20		rep #$20	            REP #$20
.1a039f	48		pha		            PHA
.1a03a0	e2 20		sep #$20	            SEP #$20
.1a03a2	a9 0d		lda #$0d	            LDA #CHAR_CR
.1a03a4	20 18 00	jsr $1a0018	            JSR PRINTC
.1a03a7	c2 20		rep #$20	            REP #$20
.1a03a9	68		pla		            PLA
.1a03aa	28		plp		            PLP
.1a03ab	60		rts		            RTS
.1a03ac					PRINTH
.1a03ac	08		php		            PHP
.1a03ad	22 78 10 00	jsl $001078	            JSL FK_IPRINTH
.1a03b1	28		plp		            PLP
.1a03b2	60		rts		            RTS

;******  Return to file: src\bios.s

=10					LINES_PER_PAGE = 10     ; The number of lines to print on a page before pausing
=$80					DEV_SCREEN = $80        ; Use the screen and keyboard for the console device
=$40					DEV_UART = $40          ; Use UART for console device
=$20					DEV_BUFFER = $20        ; Use the current text memory buffer for output or input
>08b4					BCONSOLE    .byte ?     ; Device for BASIC console
>08b5					SAVE_A      .byte ?     ; Save spot for the A register
>08b6					LINECOUNT   .byte ?     ; Counter for new lines to support pagination
.1a03b3					PAGINATE
.1a03b3	08		php		            PHP
.1a03b4	0b		phd		            PHD
.1a03b5	08		php		            PHP
.1a03b6	c2 20		rep #$20	            REP #$20
.1a03b8	48		pha		            PHA
.1a03b9	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a03bc	5b		tcd		            TCD
.1a03bd	68		pla		            PLA
.1a03be	28		plp		            PLP
.1a03bf	e2 20		sep #$20	            SEP #$20
.1a03c1	a5 b6		lda $08b6	            LDA LINECOUNT           ; Check the line count
.1a03c3	1a		inc a		            INC A
.1a03c4	85 b6		sta $08b6	            STA LINECOUNT
.1a03c6	cf 13 00 00	cmp $000013	            CMP @l LINES_VISIBLE
.1a03ca	90 05		bcc $1a03d1	            BLT done                ; If < limit, just return
.1a03cc	20 14 00	jsr $1a0014	            JSR GETKEY
.1a03cf	64 b6		stz $08b6	            STZ LINECOUNT           ; And reset the line count
.1a03d1	2b		pld		done        PLD
.1a03d2	28		plp		            PLP
.1a03d3	60		rts		            RTS
.1a03d4					IPRINTC
.1a03d4	da		phx		            PHX
.1a03d5	5a		phy		            PHY
.1a03d6	0b		phd		            PHD
.1a03d7	08		php		            PHP
.1a03d8	08		php		            PHP
.1a03d9	c2 20		rep #$20	            REP #$20
.1a03db	48		pha		            PHA
.1a03dc	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a03df	5b		tcd		            TCD
.1a03e0	68		pla		            PLA
.1a03e1	28		plp		            PLP
.1a03e2	e2 20		sep #$20	            SEP #$20
.1a03e4	c2 10		rep #$10	            REP #$10
.1a03e6	8f b5 08 00	sta $0008b5	            STA @lSAVE_A
.1a03ea	af b4 08 00	lda $0008b4	chk_out     LDA @lBCONSOLE      ; Check to see if we should send to an output buffer
.1a03ee	29 20		and #$20	            AND #DEV_BUFFER
.1a03f0	f0 07		beq $1a03f9	            BEQ check_scrn      ; No... move on to the hardware screen
.1a03f2	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.1a03f6	20 28 00	jsr $1a0028	            JSR OBUFF_PUTC
.1a03f9	af b4 08 00	lda $0008b4	check_scrn  LDA @lBCONSOLE
.1a03fd	29 80		and #$80	            AND #DEV_SCREEN     ; Check to see if the screen is selected
.1a03ff	f0 07		beq $1a0408	            BEQ send_uart
.1a0401	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.1a0405	20 66 03	jsr $1a0366	            JSR SCREEN_PUTC
.1a0408	af b4 08 00	lda $0008b4	send_uart   LDA @lBCONSOLE
.1a040c	29 40		and #$40	            AND #DEV_UART       ; Check to see if the UART is active
.1a040e	f0 14		beq $1a0424	            BEQ done
.1a0410	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.1a0414	20 81 03	jsr $1a0381	            JSR UART_PUTC
.1a0417	af b5 08 00	lda $0008b5	            LDA @lSAVE_A        ; If sending a CR to the serial port
.1a041b	c9 0d		cmp #$0d	            CMP #CHAR_CR
.1a041d	d0 05		bne $1a0424	            BNE done
.1a041f	a9 0a		lda #$0a	            LDA #CHAR_LF        ; Send a linefeed after
.1a0421	20 81 03	jsr $1a0381	            JSR UART_PUTC
.1a0424	28		plp		done        PLP
.1a0425	2b		pld		            PLD
.1a0426	7a		ply		            PLY
.1a0427	fa		plx		            PLX
.1a0428	60		rts		            RTS
.1a0429					PRINTS
.1a0429	08		php		            PHP
.1a042a	e2 20		sep #$20	            SEP #$20
.1a042c	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.1a042f	f0 06		beq $1a0437	            BEQ done
.1a0431	20 18 00	jsr $1a0018	            JSR PRINTC
.1a0434	e8		inx		            INX
.1a0435	80 f5		bra $1a042c	            BRA loop
.1a0437	28		plp		done        PLP
.1a0438	60		rts		            RTS
.1a0439					PRHEXW
.1a0439	08		php		            PHP
.1a043a	c2 20		rep #$20	            REP #$20
.1a043c	48		pha		            PHA
.1a043d	48		pha		            PHA
.1a043e	4a		lsr a		            LSR A
.1a043f	4a		lsr a		            LSR A
.1a0440	4a		lsr a		            LSR A
.1a0441	4a		lsr a		            LSR A
.1a0442	4a		lsr a		            LSR A
.1a0443	4a		lsr a		            LSR A
.1a0444	4a		lsr a		            LSR A
.1a0445	4a		lsr a		            LSR A
.1a0446	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a0449	68		pla		            PLA
.1a044a	29 ff 00	and #$00ff	            AND #$00FF
.1a044d	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a0450	68		pla		            PLA
.1a0451	28		plp		            PLP
.1a0452	60		rts		            RTS
.1a0453					PRHEXB
.1a0453	08		php		            PHP
.1a0454	c2 20		rep #$20	            REP #$20
.1a0456	48		pha		            PHA
.1a0457	e2 20		sep #$20	            SEP #$20
.1a0459	48		pha		            PHA
.1a045a	4a		lsr a		            LSR A
.1a045b	4a		lsr a		            LSR A
.1a045c	4a		lsr a		            LSR A
.1a045d	4a		lsr a		            LSR A
.1a045e	20 6a 04	jsr $1a046a	            JSR PRHEXN
.1a0461	68		pla		            PLA
.1a0462	20 6a 04	jsr $1a046a	            JSR PRHEXN
.1a0465	c2 20		rep #$20	            REP #$20
.1a0467	68		pla		            PLA
.1a0468	28		plp		            PLP
.1a0469	60		rts		            RTS
.1a046a					PRHEXN
.1a046a	08		php		            PHP
.1a046b	c2 30		rep #$30	            REP #$30
.1a046d	da		phx		            PHX
.1a046e	29 0f 00	and #$000f	            AND #$000F
.1a0471	aa		tax		            TAX
.1a0472	bf 00 d0 1a	lda $1ad000,x	            LDA @lHEXDIGITS,X
.1a0476	20 18 00	jsr $1a0018	            JSR PRINTC
.1a0479	fa		plx		            PLX
.1a047a	28		plp		            PLP
.1a047b	60		rts		            RTS
>1ad000	30 31 32 33 34 35 36 37		HEXDIGITS   .text "0123456789ABCDEF"
>1ad008	38 39 41 42 43 44 45 46

;******  Return to file: src\basic816.s


;******  Processing file: src\utilities.s

.1a047c					PRTRACE
.1a047c	08		php		            PHP
.1a047d	c2 30		rep #$30	            REP #$30
.1a047f	48		pha		            PHA
.1a0480	da		phx		            PHX
.1a0481	5a		phy		            PHY
.1a0482	8b		phb		            PHB
.1a0483	0b		phd		            PHD
.1a0484	c2 30		rep #$30	            REP #$30
.1a0486	a3 0b		lda $0b,s	            LDA 11,S        ; Get the return address
.1a0488	18		clc		calc_addr   CLC
.1a0489	69 03 00	adc #$0003	            ADC #3          ; Add 3 to skip over the following branch
.1a048c	aa		tax		            TAX
.1a048d	e2 20		sep #$20	            SEP #$20
.1a048f	a9 1a		lda #$1a	            LDA #`PRTRACE
.1a0491	48		pha		            PHA
.1a0492	ab		plb		            PLB
.1a0493	bd 00 00	lda $0000,x	pr_loop     LDA #0,B,X
.1a0496	f0 06		beq $1a049e	            BEQ done
.1a0498	20 66 03	jsr $1a0366	            JSR SCREEN_PUTC
.1a049b	e8		inx		            INX
.1a049c	80 f5		bra $1a0493	            BRA pr_loop
.1a049e					done
.1a049e	c2 30		rep #$30	            REP #$30
.1a04a0	2b		pld		            PLD
.1a04a1	ab		plb		            PLB
.1a04a2	7a		ply		            PLY
.1a04a3	fa		plx		            PLX
.1a04a4	68		pla		            PLA
.1a04a5	28		plp		            PLP
.1a04a6	60		rts		            RTS
.1a04a7					ISALPHA
.1a04a7	08		php		            PHP
.1a04a8	e2 20		sep #$20	            SEP #$20
.1a04aa	c9 5b		cmp #$5b	            CMP #'Z'+1
.1a04ac	b0 04		bcs $1a04b2	            BGE not_upper
.1a04ae	c9 41		cmp #$41	            CMP #'A'
.1a04b0	b0 0b		bcs $1a04bd	            BGE is_alpha
.1a04b2	c9 7b		cmp #$7b	not_upper   CMP #'z'+1
.1a04b4	b0 04		bcs $1a04ba	            BGE not_alpha
.1a04b6	c9 61		cmp #$61	            CMP #'a'
.1a04b8	b0 03		bcs $1a04bd	            BGE is_alpha
.1a04ba					not_alpha
.1a04ba	28		plp		            PLP
.1a04bb	18		clc		            CLC
.1a04bc	60		rts		            RTS
.1a04bd					is_alpha
.1a04bd	28		plp		            PLP
.1a04be	38		sec		            SEC
.1a04bf	60		rts		            RTS
.1a04c0					ISNUMERAL
.1a04c0	08		php		            PHP
.1a04c1	e2 20		sep #$20	            SEP #$20
.1a04c3	c9 3a		cmp #$3a	            CMP #'9'+1
.1a04c5	b0 04		bcs $1a04cb	            BGE ret_false
.1a04c7	c9 30		cmp #$30	            CMP #'0'
.1a04c9	b0 03		bcs $1a04ce	            BGE ret_true
.1a04cb	28		plp		ret_false   PLP
.1a04cc	18		clc		            CLC
.1a04cd	60		rts		            RTS
.1a04ce	28		plp		ret_true    PLP
.1a04cf	38		sec		            SEC
.1a04d0	60		rts		            RTS
.1a04d1					ISHEX
.1a04d1	08		php		            PHP
.1a04d2	e2 20		sep #$20	            SEP #$20
.1a04d4	c9 3a		cmp #$3a	            CMP #'9'+1
.1a04d6	b0 04		bcs $1a04dc	            BGE chk_lca2f
.1a04d8	c9 30		cmp #$30	            CMP #'0'
.1a04da	b0 13		bcs $1a04ef	            BGE ret_true
.1a04dc	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.1a04de	b0 04		bcs $1a04e4	            BGE chk_uca2f
.1a04e0	c9 61		cmp #$61	            CMP #'a'
.1a04e2	b0 0b		bcs $1a04ef	            BGE ret_true
.1a04e4	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.1a04e6	b0 04		bcs $1a04ec	            BGE ret_false
.1a04e8	c9 41		cmp #$41	            CMP #'A'
.1a04ea	b0 03		bcs $1a04ef	            BGE ret_true
.1a04ec	28		plp		ret_false   PLP
.1a04ed	18		clc		            CLC
.1a04ee	60		rts		            RTS
.1a04ef	28		plp		ret_true    PLP
.1a04f0	38		sec		            SEC
.1a04f1	60		rts		            RTS
.1a04f2					HEX2BIN
.1a04f2	08		php		            PHP
.1a04f3	e2 20		sep #$20	            SEP #$20
.1a04f5	c9 3a		cmp #$3a	            CMP #'9'+1          ; Check to see if '0'..'9'
.1a04f7	b0 04		bcs $1a04fd	            BGE chk_lca2f
.1a04f9	c9 30		cmp #$30	            CMP #'0'
.1a04fb	b0 12		bcs $1a050f	            BGE conv_09         ; Yes: convert it
.1a04fd	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.1a04ff	b0 04		bcs $1a0505	            BGE chk_uca2f
.1a0501	c9 61		cmp #$61	            CMP #'a'
.1a0503	b0 0f		bcs $1a0514	            BGE conv_lcaf
.1a0505	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.1a0507	b0 04		bcs $1a050d	            BGE done
.1a0509	c9 41		cmp #$41	            CMP #'A'
.1a050b	b0 09		bcs $1a0516	            BGE conv_ucaf
.1a050d	28		plp		done        PLP
.1a050e	60		rts		            RTS
.1a050f	38		sec		conv_09     SEC                 ; Convert digits '0'..'9'
.1a0510	e9 30		sbc #$30	            SBC #'0'
.1a0512	80 f9		bra $1a050d	            BRA done
.1a0514	29 df		and #$df	conv_lcaf   AND #%11011111      ; Convert to upper case
.1a0516	38		sec		conv_ucaf   SEC
.1a0517	e9 37		sbc #$37	            SBC #'A'-10         ; Convert 'A'..'F'
.1a0519	80 f2		bra $1a050d	            BRA done
.1a051b					TOUPPERA
.1a051b	08		php		            PHP
.1a051c	e2 20		sep #$20	            SEP #$20
.1a051e	c9 7b		cmp #$7b	            CMP #'z'+1
.1a0520	b0 06		bcs $1a0528	            BCS done
.1a0522	c9 61		cmp #$61	            CMP #'a'
.1a0524	90 02		bcc $1a0528	            BCC done
.1a0526	29 df		and #$df	            AND #%11011111
.1a0528	28		plp		done        PLP
.1a0529	60		rts		            RTS
.1a052a					TOUPPER
.1a052a	08		php		            PHP
.1a052b	e2 20		sep #$20	            SEP #$20
.1a052d	c2 10		rep #$10	            REP #$10
.1a052f	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.1a0532	f0 09		beq $1a053d	            BEQ done
.1a0534	20 1b 05	jsr $1a051b	            JSR TOUPPERA
.1a0537	9d 00 00	sta $0000,x	            STA #0,B,X
.1a053a	e8		inx		continue    INX
.1a053b	80 f2		bra $1a052f	            BRA loop
.1a053d	28		plp		done        PLP
.1a053e	60		rts		            RTS
.1a053f					MULINT10
.1a053f	08		php		                PHP
.1a0540	0b		phd		                PHD
.1a0541	08		php		            PHP
.1a0542	c2 20		rep #$20	            REP #$20
.1a0544	48		pha		            PHA
.1a0545	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0548	5b		tcd		            TCD
.1a0549	68		pla		            PLA
.1a054a	28		plp		            PLP
.1a054b	c2 20		rep #$20	            REP #$20
.1a054d	48		pha		                PHA
.1a054e	06 23		asl $0823	                ASL ARGUMENT1           ; 7 -- 20 -- 74
.1a0550	26 25		rol $0825	                ROL ARGUMENT1+2         ; 7
.1a0552	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.1a0554	85 0c		sta $080c	                STA SCRATCH             ; 4
.1a0556	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.1a0558	85 0e		sta $080e	                STA SCRATCH+2           ; 4
.1a055a	06 0c		asl $080c	                ASL SCRATCH             ; 7 -- 28
.1a055c	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.1a055e	06 0c		asl $080c	                ASL SCRATCH             ; 7
.1a0560	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.1a0562	18		clc		                CLC                     ; 2 -- 26
.1a0563	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.1a0565	65 0c		adc $080c	                ADC SCRATCH             ; 4
.1a0567	85 23		sta $0823	                STA ARGUMENT1           ; 4
.1a0569	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.1a056b	65 0e		adc $080e	                ADC SCRATCH+2           ; 4
.1a056d	85 25		sta $0825	                STA ARGUMENT1+2         ; 4
.1a056f	68		pla		                PLA
.1a0570	2b		pld		                PLD
.1a0571	28		plp		                PLP
.1a0572	60		rts		            RTS
.1a0573					DIVINT10
.1a0573	08		php		                PHP
.1a0574	0b		phd		                PHD
.1a0575	08		php		            PHP
.1a0576	c2 20		rep #$20	            REP #$20
.1a0578	48		pha		            PHA
.1a0579	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a057c	5b		tcd		            TCD
.1a057d	68		pla		            PLA
.1a057e	28		plp		            PLP
.1a057f	c2 20		rep #$20	            REP #$20
.1a0581	a5 23		lda $0823	                LDA ARGUMENT1
.1a0583	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.1a0587	a9 0a 00	lda #$000a	                LDA #10
.1a058a	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.1a058e	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.1a0592	85 23		sta $0823	                STA ARGUMENT1
.1a0594	64 25		stz $0825	                STZ ARGUMENT1+2
.1a0596	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.1a059a	85 29		sta $0829	                STA ARGUMENT2
.1a059c	64 2b		stz $082b	                STZ ARGUMENT2+2
.1a059e	e2 20		sep #$20	            SEP #$20
.1a05a0	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a05a2	85 27		sta $0827	                STA ARGTYPE1
.1a05a4	85 2d		sta $082d	                STA ARGTYPE2
.1a05a6	2b		pld		                PLD
.1a05a7	28		plp		                PLP
.1a05a8	60		rts		            RTS
.1a05a9					DIVINT100
.1a05a9	08		php		                PHP
.1a05aa	0b		phd		                PHD
.1a05ab	08		php		            PHP
.1a05ac	c2 20		rep #$20	            REP #$20
.1a05ae	48		pha		            PHA
.1a05af	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a05b2	5b		tcd		            TCD
.1a05b3	68		pla		            PLA
.1a05b4	28		plp		            PLP
.1a05b5	c2 20		rep #$20	            REP #$20
.1a05b7	a5 23		lda $0823	                LDA ARGUMENT1
.1a05b9	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.1a05bd	a9 64 00	lda #$0064	                LDA #100
.1a05c0	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.1a05c4	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.1a05c8	85 23		sta $0823	                STA ARGUMENT1
.1a05ca	64 25		stz $0825	                STZ ARGUMENT1+2
.1a05cc	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.1a05d0	85 29		sta $0829	                STA ARGUMENT2
.1a05d2	64 2b		stz $082b	                STZ ARGUMENT2+2
.1a05d4	e2 20		sep #$20	            SEP #$20
.1a05d6	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a05d8	85 27		sta $0827	                STA ARGTYPE1
.1a05da	85 2d		sta $082d	                STA ARGTYPE2
.1a05dc	2b		pld		                PLD
.1a05dd	28		plp		                PLP
.1a05de	60		rts		            RTS
.1a05df					IS_ARG1_Z
.1a05df	08		php		                PHP
.1a05e0	c2 20		rep #$20	            REP #$20
.1a05e2	a5 23		lda $0823	                LDA ARGUMENT1
.1a05e4	d0 08		bne $1a05ee	                BNE return_false
.1a05e6	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a05e8	d0 04		bne $1a05ee	                BNE return_false
.1a05ea	28		plp		return_true     PLP
.1a05eb	e2 02		sep #$02	                SEP #$02        ; Set Z
.1a05ed	60		rts		            RTS
.1a05ee	28		plp		return_false    PLP
.1a05ef	c2 02		rep #$02	                REP #$02        ; Clear Z
.1a05f1	60		rts		            RTS
.1a05f2					SET_TRUE
.1a05f2	08		php		                PHP
.1a05f3	c2 30		rep #$30	            REP #$30
.1a05f5	a9 ff ff	lda #$ffff	                LDA #$FFFF
.1a05f8	85 23		sta $0823	                STA ARGUMENT1
.1a05fa	85 25		sta $0825	                STA ARGUMENT1+2
.1a05fc	e2 20		sep #$20	            SEP #$20
.1a05fe	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a0600	85 27		sta $0827	                STA ARGTYPE1
.1a0602	28		plp		                PLP
.1a0603	60		rts		            RTS
.1a0604					SET_FALSE
.1a0604	08		php		                PHP
.1a0605	c2 30		rep #$30	            REP #$30
.1a0607	a9 00 00	lda #$0000	                LDA #0
.1a060a	85 23		sta $0823	                STA ARGUMENT1
.1a060c	85 25		sta $0825	                STA ARGUMENT1+2
.1a060e	e2 20		sep #$20	            SEP #$20
.1a0610	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a0612	85 27		sta $0827	                STA ARGTYPE1
.1a0614	28		plp		                PLP
.1a0615	60		rts		            RTS
.1a0616					ASS_ARG1_INT
.1a0616	08		php		                PHP
.1a0617	e2 20		sep #$20	            SEP #$20
.1a0619	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.1a061b	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a061d	f0 07		beq $1a0626	                BEQ done                ; If so: just return
.1a061f	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.1a0621	d0 05		bne $1a0628	                BNE TYPE_ERR            ; If not: throw an error
.1a0623	20 22 5b	jsr $1a5b22	            JSR FTOI
.1a0626	28		plp		done            PLP
.1a0627	60		rts		            RTS
.1a0628					TYPE_ERR
.1a0628	08		php		            PHP
.1a0629	c2 20		rep #$20	            REP #$20
.1a062b	48		pha		            PHA
.1a062c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a062f	5b		tcd		            TCD
.1a0630	68		pla		            PLA
.1a0631	28		plp		            PLP
.1a0632	e2 20		sep #$20	            SEP #$20
.1a0634	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0636	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a063a	c2 20		rep #$20	            REP #$20
.1a063c	29 ff 00	and #$00ff	            AND #$00FF
.1a063f	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a0642	e2 20		sep #$20	            SEP #$20
.1a0644	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0647					ASS_ARG2_INT
.1a0647	08		php		                PHP
.1a0648	e2 20		sep #$20	            SEP #$20
.1a064a	a5 2d		lda $082d	                LDA ARGTYPE2                ; Verify that the type is INTEGER
.1a064c	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a064e	f0 37		beq $1a0687	                BEQ done                    ; If so: just return
.1a0650	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; Check if it's a float
.1a0652	d0 35		bne $1a0689	                BNE TYPE_ERR                ; If not: throw an error
.1a0654	c2 20		rep #$20	            REP #$20
.1a0656	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a0658	48		pha		            PHA
.1a0659	a5 23		lda $0823	            LDA ARGUMENT1
.1a065b	48		pha		            PHA
.1a065c	c2 20		rep #$20	            REP #$20
.1a065e	a5 29		lda $0829	            LDA ARGUMENT2
.1a0660	85 23		sta $0823	            STA ARGUMENT1
.1a0662	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a0664	85 25		sta $0825	            STA ARGUMENT1+2
.1a0666	e2 20		sep #$20	            SEP #$20
.1a0668	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.1a066a	85 27		sta $0827	            STA ARGTYPE1
.1a066c	20 22 5b	jsr $1a5b22	            JSR FTOI
.1a066f	c2 20		rep #$20	            REP #$20
.1a0671	a5 23		lda $0823	            LDA ARGUMENT1
.1a0673	85 29		sta $0829	            STA ARGUMENT2
.1a0675	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a0677	85 2b		sta $082b	            STA ARGUMENT2+2
.1a0679	e2 20		sep #$20	            SEP #$20
.1a067b	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a067d	85 2d		sta $082d	            STA ARGTYPE2
.1a067f	c2 20		rep #$20	            REP #$20
.1a0681	68		pla		            PLA
.1a0682	85 23		sta $0823	            STA ARGUMENT1
.1a0684	68		pla		            PLA
.1a0685	85 25		sta $0825	            STA ARGUMENT1+2
.1a0687	28		plp		done            PLP
.1a0688	60		rts		            RTS
.1a0689					TYPE_ERR
.1a0689	08		php		            PHP
.1a068a	c2 20		rep #$20	            REP #$20
.1a068c	48		pha		            PHA
.1a068d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0690	5b		tcd		            TCD
.1a0691	68		pla		            PLA
.1a0692	28		plp		            PLP
.1a0693	e2 20		sep #$20	            SEP #$20
.1a0695	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0697	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a069b	c2 20		rep #$20	            REP #$20
.1a069d	29 ff 00	and #$00ff	            AND #$00FF
.1a06a0	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a06a3	e2 20		sep #$20	            SEP #$20
.1a06a5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a06a8					ASS_ARG1_STR
.1a06a8	08		php		                PHP
.1a06a9	e2 20		sep #$20	            SEP #$20
.1a06ab	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is STRING
.1a06ad	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a06af	d0 02		bne $1a06b3	                BNE TYPE_ERR
.1a06b1	28		plp		                PLP
.1a06b2	60		rts		            RTS
.1a06b3					TYPE_ERR
.1a06b3	08		php		            PHP
.1a06b4	c2 20		rep #$20	            REP #$20
.1a06b6	48		pha		            PHA
.1a06b7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a06ba	5b		tcd		            TCD
.1a06bb	68		pla		            PLA
.1a06bc	28		plp		            PLP
.1a06bd	e2 20		sep #$20	            SEP #$20
.1a06bf	a9 04		lda #$04	            LDA #ERR_TYPE
.1a06c1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a06c5	c2 20		rep #$20	            REP #$20
.1a06c7	29 ff 00	and #$00ff	            AND #$00FF
.1a06ca	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a06cd	e2 20		sep #$20	            SEP #$20
.1a06cf	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a06d2					ASS_ARG1_INT16
.1a06d2	08		php		                PHP
.1a06d3	e2 20		sep #$20	            SEP #$20
.1a06d5	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.1a06d7	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a06d9	f0 07		beq $1a06e2	                BEQ check_range         ; If so: check the range
.1a06db	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.1a06dd	d0 0b		bne $1a06ea	                BNE TYPE_ERR            ; If not: throw an error
.1a06df	20 22 5b	jsr $1a5b22	            JSR FTOI
.1a06e2					check_range
.1a06e2	c2 20		rep #$20	            REP #$20
.1a06e4	a5 25		lda $0825	                LDA ARGUMENT1+2         ; Validate it is 16-bit
.1a06e6	d0 21		bne $1a0709	                BNE range_err
.1a06e8	28		plp		                PLP
.1a06e9	60		rts		            RTS
.1a06ea					TYPE_ERR
.1a06ea	08		php		            PHP
.1a06eb	c2 20		rep #$20	            REP #$20
.1a06ed	48		pha		            PHA
.1a06ee	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a06f1	5b		tcd		            TCD
.1a06f2	68		pla		            PLA
.1a06f3	28		plp		            PLP
.1a06f4	e2 20		sep #$20	            SEP #$20
.1a06f6	a9 04		lda #$04	            LDA #ERR_TYPE
.1a06f8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a06fc	c2 20		rep #$20	            REP #$20
.1a06fe	29 ff 00	and #$00ff	            AND #$00FF
.1a0701	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a0704	e2 20		sep #$20	            SEP #$20
.1a0706	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0709					RANGE_ERR
.1a0709	08		php		            PHP
.1a070a	c2 20		rep #$20	            REP #$20
.1a070c	48		pha		            PHA
.1a070d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0710	5b		tcd		            TCD
.1a0711	68		pla		            PLA
.1a0712	28		plp		            PLP
.1a0713	e2 20		sep #$20	            SEP #$20
.1a0715	a9 09		lda #$09	            LDA #ERR_RANGE
.1a0717	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a071b	c2 20		rep #$20	            REP #$20
.1a071d	29 ff 00	and #$00ff	            AND #$00FF
.1a0720	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a0723	e2 20		sep #$20	            SEP #$20
.1a0725	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0728					ASS_ARG1_BYTE
.1a0728	08		php		                PHP
.1a0729	e2 20		sep #$20	            SEP #$20
.1a072b	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.1a072d	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a072f	f0 07		beq $1a0738	                BEQ check_range         ; If so: check the range
.1a0731	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.1a0733	d0 11		bne $1a0746	                BNE TYPE_ERR            ; If not: throw an error
.1a0735	20 22 5b	jsr $1a5b22	            JSR FTOI
.1a0738	a5 26		lda $0826	check_range     LDA ARGUMENT1+3         ; Validate that the value is in byte range
.1a073a	d0 29		bne $1a0765	                BNE RANGE_ERR           ; If not... throw a range error
.1a073c	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a073e	d0 25		bne $1a0765	                BNE RANGE_ERR
.1a0740	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a0742	d0 21		bne $1a0765	                BNE RANGE_ERR
.1a0744	28		plp		                PLP
.1a0745	60		rts		            RTS
.1a0746					TYPE_ERR
.1a0746	08		php		            PHP
.1a0747	c2 20		rep #$20	            REP #$20
.1a0749	48		pha		            PHA
.1a074a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a074d	5b		tcd		            TCD
.1a074e	68		pla		            PLA
.1a074f	28		plp		            PLP
.1a0750	e2 20		sep #$20	            SEP #$20
.1a0752	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0754	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0758	c2 20		rep #$20	            REP #$20
.1a075a	29 ff 00	and #$00ff	            AND #$00FF
.1a075d	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a0760	e2 20		sep #$20	            SEP #$20
.1a0762	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0765					RANGE_ERR
.1a0765	08		php		            PHP
.1a0766	c2 20		rep #$20	            REP #$20
.1a0768	48		pha		            PHA
.1a0769	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a076c	5b		tcd		            TCD
.1a076d	68		pla		            PLA
.1a076e	28		plp		            PLP
.1a076f	e2 20		sep #$20	            SEP #$20
.1a0771	a9 09		lda #$09	            LDA #ERR_RANGE
.1a0773	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0777	c2 20		rep #$20	            REP #$20
.1a0779	29 ff 00	and #$00ff	            AND #$00FF
.1a077c	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a077f	e2 20		sep #$20	            SEP #$20
.1a0781	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0784					ASS_ARG1_FLOAT
.1a0784	08		php		                PHP
.1a0785	e2 20		sep #$20	            SEP #$20
.1a0787	a5 27		lda $0827	                LDA ARGTYPE1            ; Check the type
.1a0789	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.1a078b	f0 26		beq $1a07b3	                BEQ done                ; Then we're done
.1a078d	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.1a078f	f0 1f		beq $1a07b0	                BEQ cast                ; Then cast it to float
.1a0791					type_err
.1a0791	08		php		            PHP
.1a0792	c2 20		rep #$20	            REP #$20
.1a0794	48		pha		            PHA
.1a0795	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0798	5b		tcd		            TCD
.1a0799	68		pla		            PLA
.1a079a	28		plp		            PLP
.1a079b	e2 20		sep #$20	            SEP #$20
.1a079d	a9 04		lda #$04	            LDA #ERR_TYPE
.1a079f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a07a3	c2 20		rep #$20	            REP #$20
.1a07a5	29 ff 00	and #$00ff	            AND #$00FF
.1a07a8	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a07ab	e2 20		sep #$20	            SEP #$20
.1a07ad	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a07b0					cast
.1a07b0	20 1c 5b	jsr $1a5b1c	            JSR ITOF
.1a07b3	28		plp		done            PLP
.1a07b4	60		rts		            RTS
.1a07b5					ASS_ARG2_FLOAT
.1a07b5	08		php		                PHP
.1a07b6	e2 20		sep #$20	            SEP #$20
.1a07b8	a5 2d		lda $082d	                LDA ARGTYPE2            ; Check the type
.1a07ba	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.1a07bc	f0 26		beq $1a07e4	                BEQ done                ; Then we're done
.1a07be	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.1a07c0	f0 1f		beq $1a07e1	                BEQ cast                ; Then cast it to float
.1a07c2					type_err
.1a07c2	08		php		            PHP
.1a07c3	c2 20		rep #$20	            REP #$20
.1a07c5	48		pha		            PHA
.1a07c6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a07c9	5b		tcd		            TCD
.1a07ca	68		pla		            PLA
.1a07cb	28		plp		            PLP
.1a07cc	e2 20		sep #$20	            SEP #$20
.1a07ce	a9 04		lda #$04	            LDA #ERR_TYPE
.1a07d0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a07d4	c2 20		rep #$20	            REP #$20
.1a07d6	29 ff 00	and #$00ff	            AND #$00FF
.1a07d9	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a07dc	e2 20		sep #$20	            SEP #$20
.1a07de	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a07e1					cast
.1a07e1	20 e6 07	jsr $1a07e6	            JSR CAST_ARG2_FLOAT
.1a07e4	28		plp		done            PLP
.1a07e5	60		rts		            RTS
.1a07e6					CAST_ARG2_FLOAT
.1a07e6	c2 20		rep #$20	            REP #$20
.1a07e8	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a07ea	48		pha		            PHA
.1a07eb	a5 23		lda $0823	            LDA ARGUMENT1
.1a07ed	48		pha		            PHA
.1a07ee	c2 20		rep #$20	            REP #$20
.1a07f0	a5 29		lda $0829	            LDA ARGUMENT2
.1a07f2	85 23		sta $0823	            STA ARGUMENT1
.1a07f4	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a07f6	85 25		sta $0825	            STA ARGUMENT1+2
.1a07f8	e2 20		sep #$20	            SEP #$20
.1a07fa	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a07fc	85 27		sta $0827	            STA ARGTYPE1
.1a07fe	20 1c 5b	jsr $1a5b1c	            JSR ITOF
.1a0801	c2 20		rep #$20	            REP #$20
.1a0803	a5 23		lda $0823	            LDA ARGUMENT1
.1a0805	85 29		sta $0829	            STA ARGUMENT2
.1a0807	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a0809	85 2b		sta $082b	            STA ARGUMENT2+2
.1a080b	e2 20		sep #$20	            SEP #$20
.1a080d	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.1a080f	85 2d		sta $082d	            STA ARGTYPE2
.1a0811	c2 20		rep #$20	            REP #$20
.1a0813	68		pla		            PLA
.1a0814	85 23		sta $0823	            STA ARGUMENT1
.1a0816	68		pla		            PLA
.1a0817	85 25		sta $0825	            STA ARGUMENT1+2
.1a0819	60		rts		            RTS
.1a081a					ASS_ARGS_NUM
.1a081a	08		php		                PHP
.1a081b	e2 20		sep #$20	            SEP #$20
.1a081d	a5 27		lda $0827	                LDA ARGTYPE1                ; Check ARGUMENT1
.1a081f	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a0821	f0 23		beq $1a0846	                BEQ arg1_int
.1a0823	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.1a0825	f0 2e		beq $1a0855	                BEQ arg1_float
.1a0827					type_err
.1a0827	08		php		            PHP
.1a0828	c2 20		rep #$20	            REP #$20
.1a082a	48		pha		            PHA
.1a082b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a082e	5b		tcd		            TCD
.1a082f	68		pla		            PLA
.1a0830	28		plp		            PLP
.1a0831	e2 20		sep #$20	            SEP #$20
.1a0833	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0835	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0839	c2 20		rep #$20	            REP #$20
.1a083b	29 ff 00	and #$00ff	            AND #$00FF
.1a083e	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a0841	e2 20		sep #$20	            SEP #$20
.1a0843	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0846	a5 2d		lda $082d	arg1_int        LDA ARGTYPE2                ; Check argument 2
.1a0848	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If integer, we're done
.1a084a	f0 16		beq $1a0862	                BEQ done
.1a084c	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If not float, throw an error
.1a084e	d0 d7		bne $1a0827	                BNE type_err
.1a0850	20 1c 5b	jsr $1a5b1c	            JSR ITOF
.1a0853	80 0d		bra $1a0862	                BRA done
.1a0855	a5 2d		lda $082d	arg1_float      LDA ARGTYPE2                ; Check argument 2
.1a0857	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If it's float
.1a0859	f0 07		beq $1a0862	                BEQ done                    ; Then we're done
.1a085b	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If it's not integer
.1a085d	d0 c8		bne $1a0827	                BNE type_err                ; Thrown an error
.1a085f	20 e6 07	jsr $1a07e6	            JSR CAST_ARG2_FLOAT
.1a0862					done
.1a0862	e2 20		sep #$20	            SEP #$20
.1a0864	a5 27		lda $0827	                LDA ARGTYPE1                ; Return the type code in A
.1a0866	28		plp		                PLP
.1a0867	60		rts		            RTS
.1a0868					ASS_ARGS_NUMSTR
.1a0868	08		php		                PHP
.1a0869	e2 20		sep #$20	            SEP #$20
.1a086b	a5 27		lda $0827	                LDA ARGTYPE1                ; Check to see if ARGUMENT1 is a string
.1a086d	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a086f	d0 25		bne $1a0896	                BNE numbers
.1a0871	a5 2d		lda $082d	                LDA ARGTYPE2                ; If ARGUMENT1 is a string, make sure ARGUMENT2 is
.1a0873	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a0875	f0 24		beq $1a089b	                BEQ done
.1a0877					TYPE_ERR
.1a0877	08		php		            PHP
.1a0878	c2 20		rep #$20	            REP #$20
.1a087a	48		pha		            PHA
.1a087b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a087e	5b		tcd		            TCD
.1a087f	68		pla		            PLA
.1a0880	28		plp		            PLP
.1a0881	e2 20		sep #$20	            SEP #$20
.1a0883	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0885	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0889	c2 20		rep #$20	            REP #$20
.1a088b	29 ff 00	and #$00ff	            AND #$00FF
.1a088e	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a0891	e2 20		sep #$20	            SEP #$20
.1a0893	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0896					numbers
.1a0896	20 1a 08	jsr $1a081a	            JSR ASS_ARGS_NUM
.1a0899	a5 27		lda $0827	                LDA ARGTYPE1                ; Make sure A is the type
.1a089b	28		plp		done            PLP
.1a089c	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\tokens.s

.0000					TOKEN
>0000					precedence  .byte ?
>0001					length      .byte ?
>0002					name        .word <>?
>0004					eval        .word <>?
>0006					arity       .word <>?
.1a089d					PARSEINT
.1a089d	08		php		            PHP
.1a089e	0b		phd		            PHD
.1a089f	08		php		            PHP
.1a08a0	c2 20		rep #$20	            REP #$20
.1a08a2	48		pha		            PHA
.1a08a3	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a08a6	5b		tcd		            TCD
.1a08a7	68		pla		            PLA
.1a08a8	28		plp		            PLP
.1a08a9	c2 30		rep #$30	            REP #$30
.1a08ab	64 23		stz $0823	            STZ ARGUMENT1       ; Default to Not-a-value
.1a08ad	64 25		stz $0825	            STZ ARGUMENT1+2
.1a08af	e2 20		sep #$20	            SEP #$20
.1a08b1	64 27		stz $0827	            STZ ARGTYPE1
.1a08b3	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it starts with '$'
.1a08b5	c9 26		cmp #$26	            CMP #'&'
.1a08b7	f0 44		beq $1a08fd	            BEQ check_hex       ; Yes: parse it as a hexadecimal number
.1a08b9					loop
.1a08b9	e2 20		sep #$20	            SEP #$20
.1a08bb	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.1a08bd	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a08c0	90 76		bcc $1a0938	            BCC done            ; No, we're done parsing
.1a08c2	20 3f 05	jsr $1a053f	            JSR MULINT10
.1a08c5	38		sec		            SEC                 ; Convert the ASCII code to a number
.1a08c6	e9 30		sbc #$30	            SBC #'0'
.1a08c8	c2 20		rep #$20	            REP #$20
.1a08ca	29 ff 00	and #$00ff	            AND #$00FF
.1a08cd	18		clc		            CLC
.1a08ce	65 23		adc $0823	            ADC ARGUMENT1
.1a08d0	85 23		sta $0823	            STA ARGUMENT1
.1a08d2	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a08d4	69 00 00	adc #$0000	            ADC #0
.1a08d7	85 25		sta $0825	            STA ARGUMENT1+2
.1a08d9	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a08dc	80 db		bra $1a08b9	            BRA loop            ; And try to process it
.1a08de					syntaxerr
.1a08de	08		php		            PHP
.1a08df	c2 20		rep #$20	            REP #$20
.1a08e1	48		pha		            PHA
.1a08e2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a08e5	5b		tcd		            TCD
.1a08e6	68		pla		            PLA
.1a08e7	28		plp		            PLP
.1a08e8	e2 20		sep #$20	            SEP #$20
.1a08ea	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a08ec	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a08f0	c2 20		rep #$20	            REP #$20
.1a08f2	29 ff 00	and #$00ff	            AND #$00FF
.1a08f5	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a08f8	e2 20		sep #$20	            SEP #$20
.1a08fa	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a08fd					check_hex
.1a08fd	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a0900	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.1a0902	c9 48		cmp #$48	            CMP #'H'            ; Is it 'H'?
.1a0904	f0 04		beq $1a090a	            BEQ parse_hex       ; Yes: skip it and parse hex
.1a0906	c9 68		cmp #$68	            CMP #'h'            ; Is it 'h'?
.1a0908	d0 d4		bne $1a08de	            BNE syntaxerr       ; No: throw an error
.1a090a					parse_hex
.1a090a	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a090d					hexloop
.1a090d	e2 20		sep #$20	            SEP #$20
.1a090f	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.1a0911	20 d1 04	jsr $1a04d1	            JSR ISHEX
.1a0914	90 22		bcc $1a0938	            BCC done            ; No, we're done parsing
.1a0916	20 f2 04	jsr $1a04f2	            JSR HEX2BIN
.1a0919	c2 20		rep #$20	            REP #$20
.1a091b	06 23		asl $0823	            ASL ARGUMENT1
.1a091d	26 25		rol $0825	            ROL ARGUMENT1+2
.1a091f	06 23		asl $0823	            ASL ARGUMENT1
.1a0921	26 25		rol $0825	            ROL ARGUMENT1+2
.1a0923	06 23		asl $0823	            ASL ARGUMENT1
.1a0925	26 25		rol $0825	            ROL ARGUMENT1+2
.1a0927	06 23		asl $0823	            ASL ARGUMENT1
.1a0929	26 25		rol $0825	            ROL ARGUMENT1+2
.1a092b	29 ff 00	and #$00ff	            AND #$00FF          ; Add binary number to ARGUMENT1
.1a092e	18		clc		            CLC
.1a092f	65 23		adc $0823	            ADC ARGUMENT1
.1a0931	85 23		sta $0823	            STA ARGUMENT1
.1a0933	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a0936	80 d5		bra $1a090d	            BRA hexloop         ; And try to process it
.1a0938	2b		pld		done        PLD
.1a0939	28		plp		            PLP
.1a093a	60		rts		            RTS
.1a093b					PREVCHAR
.1a093b	08		php		            PHP
.1a093c	c2 30		rep #$30	            REP #$30
.1a093e	a5 04		lda $0804	            LDA BIPPREV
.1a0940	f0 1c		beq $1a095e	            BEQ ret_false
.1a0942	38		sec		            SEC
.1a0943	a5 04		lda $0804	            LDA BIPPREV
.1a0945	e5 1a		sbc $081a	            SBC CURLINE
.1a0947	a8		tay		            TAY
.1a0948	e2 20		sep #$20	            SEP #$20
.1a094a	b7 1a		lda [$081a],y	loop        LDA [CURLINE],Y
.1a094c	f0 10		beq $1a095e	            BEQ ret_false
.1a094e	c9 20		cmp #$20	            CMP #CHAR_SP
.1a0950	f0 06		beq $1a0958	            BEQ go_back
.1a0952	c9 09		cmp #$09	            CMP #CHAR_TAB
.1a0954	f0 02		beq $1a0958	            BEQ go_back
.1a0956	28		plp		            PLP
.1a0957	60		rts		            RTS
.1a0958	88		dey		go_back     DEY
.1a0959	c0 ff ff	cpy #$ffff	            CPY #$FFFF
.1a095c	d0 ec		bne $1a094a	            BNE loop
.1a095e					ret_false
.1a095e	a9 00		lda #$00	            LDA #0
.1a0960	60		rts		            RTS
.1a0961					TOKENIZE
.1a0961	08		php		            PHP
.1a0962	0b		phd		            PHD
.1a0963	08		php		            PHP
.1a0964	c2 20		rep #$20	            REP #$20
.1a0966	48		pha		            PHA
.1a0967	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a096a	5b		tcd		            TCD
.1a096b	68		pla		            PLA
.1a096c	28		plp		            PLP
.1a096d	c2 30		rep #$30	            REP #$30
.1a096f	a5 1a		lda $081a	            LDA CURLINE
.1a0971	85 00		sta $0800	            STA BIP
.1a0973	e2 20		sep #$20	            SEP #$20
.1a0975	a5 1c		lda $081c	            LDA CURLINE+2
.1a0977	85 02		sta $0802	            STA BIP+2
.1a0979	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a097c	a7 00		lda [$0800]	            LDA [BIP]               ; Do we have a numeral?
.1a097e	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a0981	90 0c		bcc $1a098f	            BCC mv_curline          ; No: adjust CURLINE and tokenize
.1a0983	20 9d 08	jsr $1a089d	            JSR PARSEINT
.1a0986	c2 20		rep #$20	            REP #$20
.1a0988	a5 23		lda $0823	            LDA ARGUMENT1
.1a098a	85 d7		sta $08d7	            STA LINENUM
.1a098c	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a098f					mv_curline
.1a098f	c2 20		rep #$20	            REP #$20
.1a0991	a5 00		lda $0800	            LDA BIP
.1a0993	85 1a		sta $081a	            STA CURLINE
.1a0995	e2 20		sep #$20	            SEP #$20
.1a0997	a5 02		lda $0802	            LDA BIP+2
.1a0999	85 1c		sta $081c	            STA CURLINE+2
.1a099b	20 af 09	jsr $1a09af	            JSR FINDREM
.1a099e	e2 20		sep #$20	            SEP #$20
.1a09a0					loop
.1a09a0	20 20 0a	jsr $1a0a20	            JSR TKFINDTOKEN
.1a09a3	c9 00		cmp #$00	            CMP #0                  ; Did we find a token?
.1a09a5	f0 05		beq $1a09ac	            BEQ done                ; No: return
.1a09a7	20 ce 0b	jsr $1a0bce	            JSR TKWRITE
.1a09aa	80 f4		bra $1a09a0	            BRA loop                ; And try again
.1a09ac	2b		pld		done        PLD
.1a09ad	28		plp		            PLP
.1a09ae	60		rts		            RTS
.1a09af					FINDREM
.1a09af	08		php		            PHP
.1a09b0	c2 20		rep #$20	            REP #$20
.1a09b2	a5 1a		lda $081a	            LDA CURLINE             ; Point BIP to the beginning of the line
.1a09b4	85 00		sta $0800	            STA BIP
.1a09b6	a5 1c		lda $081c	            LDA CURLINE+2
.1a09b8	85 02		sta $0802	            STA BIP+2
.1a09ba	a2 00 00	ldx #$0000	            LDX #0                  ; X will be a flag that we're at the beginning
.1a09bd	e2 20		sep #$20	            SEP #$20
.1a09bf	a0 00 00	ldy #$0000	loop        LDY #0
.1a09c2	e0 00 00	cpx #$0000	            CPX #0                  ; If we are at the first space on the line
.1a09c5	f0 0d		beq $1a09d4	            BEQ skip_delim          ; ... skip looking for a delimiter
.1a09c7	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a09c9	f0 53		beq $1a0a1e	            BEQ done                ; Is it null? Then we're done
.1a09cb	c9 3a		cmp #$3a	            CMP #':'                ; Is it ":"
.1a09cd	f0 04		beq $1a09d3	            BEQ found_delim         ; Yes: we might have a REM... look for E
.1a09cf	c9 20		cmp #$20	            CMP #CHAR_SP
.1a09d1	d0 33		bne $1a0a06	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a09d3	c8		iny		found_delim INY
.1a09d4	b7 00		lda [$0800],y	skip_delim  LDA [BIP],Y             ; Get the first character
.1a09d6	f0 46		beq $1a0a1e	            BEQ done                ; Is it null? Then we're done
.1a09d8	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.1a09da	f0 10		beq $1a09ec	            BEQ found_R             ; Yes: we might have a REM... look for E
.1a09dc	c9 72		cmp #$72	            CMP #'r'
.1a09de	d0 26		bne $1a0a06	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a09e0	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a09e2	f0 3a		beq $1a0a1e	            BEQ done                ; Is it null? Then we're done
.1a09e4	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.1a09e6	f0 04		beq $1a09ec	            BEQ found_R             ; Yes: we might have a REM... look for E
.1a09e8	c9 72		cmp #$72	            CMP #'r'
.1a09ea	d0 1a		bne $1a0a06	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a09ec	c8		iny		found_R     INY
.1a09ed	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a09ef	f0 2d		beq $1a0a1e	            BEQ done                ; Is it null? Then we're done
.1a09f1	c9 45		cmp #$45	            CMP #'E'                ; Is it "E"
.1a09f3	f0 04		beq $1a09f9	            BEQ found_E             ; Yes: we might have a REM... look for M
.1a09f5	c9 65		cmp #$65	            CMP #'e'
.1a09f7	d0 0d		bne $1a0a06	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a09f9	c8		iny		found_E     INY
.1a09fa	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a09fc	f0 20		beq $1a0a1e	            BEQ done                ; Is it null? Then we're done
.1a09fe	c9 4d		cmp #$4d	            CMP #'M'                ; Is it "E"
.1a0a00	f0 0a		beq $1a0a0c	            BEQ found_REM           ; Yes: we might have a REM... look for M
.1a0a02	c9 6d		cmp #$6d	            CMP #'m'
.1a0a04	f0 06		beq $1a0a0c	            BEQ found_REM
.1a0a06	e8		inx		next_pos    INX                     ; Indicate we're no longer at the first position
.1a0a07	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a0a0a	80 b3		bra $1a09bf	            BRA loop
.1a0a0c	a7 00		lda [$0800]	found_REM   LDA [BIP]               ; Get the current character
.1a0a0e	c9 3a		cmp #$3a	            CMP #':'                ; Is it the delimiter?
.1a0a10	d0 03		bne $1a0a15	            BNE ret_REM             ; No: go ahead and return REM at that location
.1a0a12	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a0a15	a9 03		lda #$03	ret_REM     LDA #3
.1a0a17	85 1e		sta $081e	            STA CURTOKLEN           ; Set the size
.1a0a19	a9 91		lda #$91	            LDA #TOK_REM            ; And the token to write
.1a0a1b	20 ce 0b	jsr $1a0bce	            JSR TKWRITE
.1a0a1e	28		plp		done        PLP
.1a0a1f	60		rts		            RTS
.1a0a20					TKFINDTOKEN
.1a0a20	08		php		            PHP
.1a0a21	0b		phd		            PHD
.1a0a22	08		php		            PHP
.1a0a23	c2 20		rep #$20	            REP #$20
.1a0a25	48		pha		            PHA
.1a0a26	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0a29	5b		tcd		            TCD
.1a0a2a	68		pla		            PLA
.1a0a2b	28		plp		            PLP
.1a0a2c	e2 20		sep #$20	            SEP #$20
.1a0a2e	a9 7f		lda #$7f	            LDA #$7F                ; Start off looking for any size token
.1a0a30	85 1e		sta $081e	            STA CURTOKLEN
.1a0a32					next_size
.1a0a32	c2 10		rep #$10	            REP #$10
.1a0a34	20 83 0b	jsr $1a0b83	            JSR TKNEXTBIG
.1a0a37	a5 1e		lda $081e	            LDA CURTOKLEN           ; Are there any keywords left?
.1a0a39	d0 03		bne $1a0a3e	            BNE else
.1a0a3b	4c c3 0a	jmp $1a0ac3	            JMP done                ; No: return to caller
.1a0a3e					else
.1a0a3e	c2 20		rep #$20	            REP #$20
.1a0a40	a5 1a		lda $081a	            LDA CURLINE
.1a0a42	85 00		sta $0800	            STA BIP
.1a0a44	e2 20		sep #$20	            SEP #$20
.1a0a46	a5 1c		lda $081c	            LDA CURLINE+2
.1a0a48	85 02		sta $0802	            STA BIP+2
.1a0a4a	c2 20		rep #$20	            REP #$20
.1a0a4c	64 04		stz $0804	            STZ BIPPREV             ; Clear BIPPREV (point to the previous character)
.1a0a4e	64 06		stz $0806	            STZ BIPPREV+2
.1a0a50					check_len
.1a0a50	e2 30		sep #$30	            SEP #$30
.1a0a52	a0 00		ldy #$00	            LDY #0
.1a0a54	b7 00		lda [$0800],y	nul_scan    LDA [BIP],Y
.1a0a56	f0 da		beq $1a0a32	            BEQ next_size
.1a0a58	c9 91		cmp #$91	            CMP #TOK_REM            ; Tokenization stops at REMarks too
.1a0a5a	f0 d6		beq $1a0a32	            BEQ next_size
.1a0a5c	c8		iny		            INY
.1a0a5d	c4 1e		cpy $081e	            CPY CURTOKLEN
.1a0a5f	90 f3		bcc $1a0a54	            BCC nul_scan
.1a0a61	c2 10		rep #$10	            REP #$10
.1a0a63	a7 00		lda [$0800]	            LDA [BIP]               ; Check the current character
.1a0a65	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.1a0a67	d0 05		bne $1a0a6e	            BNE chk_keyword         ; No: check to see if we are at the start of a possible keyword
.1a0a69	20 e5 0a	jsr $1a0ae5	            JSR SKIPQUOTED
.1a0a6c	80 28		bra $1a0a96	            BRA go_next             ; And move on to the next character
.1a0a6e	a5 1e		lda $081e	chk_keyword LDA CURTOKLEN           ; If the token length is <=2
.1a0a70	c9 03		cmp #$03	            CMP #3
.1a0a72	90 19		bcc $1a0a8d	            BLT try_match           ; ... we don't need a delimiter, go ahead and convert it
.1a0a74	c2 20		rep #$20	            REP #$20
.1a0a76	a5 00		lda $0800	            LDA BIP                 ; Check to see if we're at the start of the line
.1a0a78	c5 1a		cmp $081a	            CMP CURLINE
.1a0a7a	d0 08		bne $1a0a84	            BNE chk_delim           ; No: we need to check for a delimiters
.1a0a7c	e2 20		sep #$20	            SEP #$20
.1a0a7e	a5 02		lda $0802	            LDA BIP+2
.1a0a80	c5 1c		cmp $081c	            CMP CURLINE+2
.1a0a82	f0 09		beq $1a0a8d	            BEQ try_match           ; Yes: this can be a keyword
.1a0a84					chk_delim
.1a0a84	e2 20		sep #$20	            SEP #$20
.1a0a86	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.1a0a88	20 65 50	jsr $1a5065	            JSR ISVARCHAR
.1a0a8b	b0 09		bcs $1a0a96	            BCS go_next             ; Yes: we can't start a keyword here
.1a0a8d					try_match
.1a0a8d	e2 20		sep #$20	            SEP #$20
.1a0a8f	20 f5 0a	jsr $1a0af5	            JSR TKMATCH
.1a0a92	c9 00		cmp #$00	            CMP #0                  ; Did we get one?
.1a0a94	d0 11		bne $1a0aa7	            BNE found               ; Yes: return it
.1a0a96					go_next
.1a0a96	c2 20		rep #$20	            REP #$20
.1a0a98	a5 00		lda $0800	            LDA BIP                 ; Update BIPPREV as the point to the previous character
.1a0a9a	85 04		sta $0804	            STA BIPPREV
.1a0a9c	e2 20		sep #$20	            SEP #$20
.1a0a9e	a5 02		lda $0802	            LDA BIP+2
.1a0aa0	85 06		sta $0806	            STA BIPPREV+2
.1a0aa2	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a0aa5	80 a9		bra $1a0a50	            BRA check_len           ; And try there
.1a0aa7					found
.1a0aa7	c9 81		cmp #$81	            CMP #TOK_MINUS          ; Found a token... is it minus?
.1a0aa9	d0 18		bne $1a0ac3	            BNE done                ; Nope: go ahead and return it
.1a0aab	20 3b 09	jsr $1a093b	            JSR PREVCHAR
.1a0aae	c9 00		cmp #$00	            CMP #0                  ; Did we get anything?
.1a0ab0	f0 14		beq $1a0ac6	            BEQ syntax              ; No: line cannot start with minus... throw error
.1a0ab2	89 80		bit #$80	            BIT #$80                ; Is it a token?
.1a0ab4	10 0b		bpl $1a0ac1	            BPL binaryminus         ; No: leave token unchanged
.1a0ab6	20 6f 0c	jsr $1a0c6f	            JSR TOKTYPE
.1a0ab9	c9 30		cmp #$30	            CMP #TOK_TY_FUNC        ; Is it a function?
.1a0abb	f0 04		beq $1a0ac1	            BEQ binaryminus         ; Yes: then this should be a binary minus operator
.1a0abd	a9 af		lda #$af	            LDA #TOK_NEGATIVE       ; Otherwise: this should be a unary minus (negation)
.1a0abf	80 02		bra $1a0ac3	            BRA done
.1a0ac1	a9 81		lda #$81	binaryminus LDA #TOK_MINUS          ; It's data... so token should be for binary minus
.1a0ac3					done
.1a0ac3	2b		pld		            PLD
.1a0ac4	28		plp		            PLP
.1a0ac5	60		rts		            RTS
.1a0ac6					syntax
.1a0ac6	08		php		            PHP
.1a0ac7	c2 20		rep #$20	            REP #$20
.1a0ac9	48		pha		            PHA
.1a0aca	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0acd	5b		tcd		            TCD
.1a0ace	68		pla		            PLA
.1a0acf	28		plp		            PLP
.1a0ad0	e2 20		sep #$20	            SEP #$20
.1a0ad2	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a0ad4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0ad8	c2 20		rep #$20	            REP #$20
.1a0ada	29 ff 00	and #$00ff	            AND #$00FF
.1a0add	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a0ae0	e2 20		sep #$20	            SEP #$20
.1a0ae2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0ae5					SKIPQUOTED
.1a0ae5	08		php		            PHP
.1a0ae6	e2 20		sep #$20	            SEP #$20
.1a0ae8					loop
.1a0ae8	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a0aeb	a7 00		lda [$0800]	            LDA [BIP]
.1a0aed	f0 04		beq $1a0af3	            BEQ done                ; If EOL, just return
.1a0aef	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.1a0af1	d0 f5		bne $1a0ae8	            BNE loop                ; No: keep skipping
.1a0af3	28		plp		done        PLP
.1a0af4	60		rts		            RTS
.1a0af5					TKMATCH
.1a0af5	da		phx		            PHX
.1a0af6	5a		phy		            PHY
.1a0af7	08		php		            PHP
.1a0af8	0b		phd		            PHD
.1a0af9	08		php		            PHP
.1a0afa	c2 20		rep #$20	            REP #$20
.1a0afc	48		pha		            PHA
.1a0afd	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0b00	5b		tcd		            TCD
.1a0b01	68		pla		            PLA
.1a0b02	28		plp		            PLP
.1a0b03	c2 20		rep #$20	            REP #$20
.1a0b05	a5 04		lda $0804	            LDA BIPPREV
.1a0b07	d0 0a		bne $1a0b13	            BNE check_prev
.1a0b09	e2 20		sep #$20	            SEP #$20
.1a0b0b	a5 04		lda $0804	            LDA BIPPREV
.1a0b0d	d0 04		bne $1a0b13	            BNE check_prev
.1a0b0f	a9 00		lda #$00	            LDA #0
.1a0b11	80 0a		bra $1a0b1d	            BRA save_delim
.1a0b13					check_prev
.1a0b13	e2 20		sep #$20	            SEP #$20
.1a0b15	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.1a0b17	20 65 50	jsr $1a5065	            JSR ISVARCHAR
.1a0b1a	a9 00		lda #$00	            LDA #0
.1a0b1c	2a		rol a		            ROL A
.1a0b1d	85 28		sta $0828	save_delim  STA SIGN1               ; SIGN1 := 1 if it is a variable name character
.1a0b1f	c2 30		rep #$30	            REP #$30
.1a0b21	a9 c3 0c	lda #$0cc3	            LDA #<>TOKENS           ; Set INDEX to point to the first token record
.1a0b24	85 08		sta $0808	            STA INDEX
.1a0b26	e2 20		sep #$20	            SEP #$20
.1a0b28	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0b2a	85 0a		sta $080a	            STA INDEX+2
.1a0b2c	a2 80 00	ldx #$0080	            LDX #$80                ; Set the initial token ID
.1a0b2f					token_loop
.1a0b2f	e2 20		sep #$20	            SEP #$20
.1a0b31	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.1a0b34	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the current token
.1a0b36	f0 31		beq $1a0b69	            BEQ no_match            ; Is it 0? We're out of tokens... no match found
.1a0b38	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it the same as the size of the window?
.1a0b3a	d0 32		bne $1a0b6e	            BNE next_token          ; No: try the next token
.1a0b3c	c2 30		rep #$30	            REP #$30
.1a0b3e	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.1a0b41	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the pointer to the token's name
.1a0b43	85 0c		sta $080c	            STA SCRATCH             ; Set SCRATCH to point to the token's name
.1a0b45	e2 20		sep #$20	            SEP #$20
.1a0b47	a9 1a		lda #$1a	            LDA #`DATA_BLOCK
.1a0b49	85 0e		sta $080e	            STA SCRATCH+2
.1a0b4b	a5 28		lda $0828	            LDA SIGN1               ; Is previous character a variable name character?
.1a0b4d	f0 07		beq $1a0b56	            BEQ cmp_keyword         ; No: we can check for this token
.1a0b4f	a7 0c		lda [$080c]	            LDA [SCRATCH]           ; Get the token's first character
.1a0b51	20 65 50	jsr $1a5065	            JSR ISVARCHAR
.1a0b54	b0 18		bcs $1a0b6e	            BCS next_token          ; Yes: skip this token
.1a0b56					cmp_keyword
.1a0b56	e2 10		sep #$10	            SEP #$10
.1a0b58	a0 00		ldy #$00	            LDY #0
.1a0b5a	b7 00		lda [$0800],y	cmp_loop    LDA [BIP],Y             ; Get the character in the window
.1a0b5c	20 1b 05	jsr $1a051b	            JSR TOUPPERA
.1a0b5f	d7 0c		cmp [$080c],y	            CMP [SCRATCH],Y         ; Compare to the character in the token
.1a0b61	d0 0b		bne $1a0b6e	            BNE next_token          ; If they don't match, try the next token
.1a0b63	c8		iny		            INY                     ; Move to the next character in the window
.1a0b64	c4 1e		cpy $081e	            CPY CURTOKLEN           ; Have we checked the whole window?
.1a0b66	90 f2		bcc $1a0b5a	            BCC cmp_loop            ; No: check this next character
.1a0b68	8a		txa		            TXA                     ; Move the token ID to A
.1a0b69	2b		pld		no_match    PLD
.1a0b6a	28		plp		            PLP
.1a0b6b	7a		ply		            PLY
.1a0b6c	fa		plx		            PLX
.1a0b6d	60		rts		            RTS
.1a0b6e					next_token
.1a0b6e	c2 30		rep #$30	            REP #$30
.1a0b70	18		clc		            CLC
.1a0b71	a5 08		lda $0808	            LDA INDEX
.1a0b73	69 08 00	adc #$0008	            ADC #size(TOKEN)
.1a0b76	85 08		sta $0808	            STA INDEX
.1a0b78	e2 20		sep #$20	            SEP #$20
.1a0b7a	a5 0a		lda $080a	            LDA INDEX+2
.1a0b7c	69 00		adc #$00	            ADC #0
.1a0b7e	85 0a		sta $080a	            STA INDEX+2
.1a0b80	e8		inx		            INX                     ; Increment the token ID
.1a0b81	80 ac		bra $1a0b2f	            BRA token_loop          ; And check that token
.1a0b83					TKNEXTBIG
.1a0b83	08		php		            PHP
.1a0b84	0b		phd		            PHD
.1a0b85	8b		phb		            PHB
.1a0b86	08		php		            PHP
.1a0b87	c2 20		rep #$20	            REP #$20
.1a0b89	48		pha		            PHA
.1a0b8a	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0b8d	5b		tcd		            TCD
.1a0b8e	68		pla		            PLA
.1a0b8f	28		plp		            PLP
.1a0b90	c2 30		rep #$30	            REP #$30
.1a0b92	a9 c3 0c	lda #$0cc3	            LDA #<>TOKENS
.1a0b95	85 08		sta $0808	            STA INDEX
.1a0b97	a9 1a 00	lda #$001a	            LDA #`TOKENS
.1a0b9a	85 0a		sta $080a	            STA INDEX+2
.1a0b9c	64 0c		stz $080c	            STZ SCRATCH             ; Clear SCRATCH
.1a0b9e					loop
.1a0b9e	e2 20		sep #$20	            SEP #$20
.1a0ba0	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.1a0ba3	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the token
.1a0ba5	f0 1d		beq $1a0bc4	            BEQ done                ; If length is 0, we're done
.1a0ba7	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it >= CURTOKLEN?
.1a0ba9	b0 06		bcs $1a0bb1	            BGE skip                ; Yes: skip to the next token
.1a0bab	c5 0c		cmp $080c	            CMP SCRATCH             ; No: is it < SCRATCH?
.1a0bad	90 02		bcc $1a0bb1	            BLT skip                ; Yes: skip to the next token
.1a0baf	85 0c		sta $080c	            STA SCRATCH             ; No: it's our new longest token!
.1a0bb1					skip
.1a0bb1	c2 20		rep #$20	            REP #$20
.1a0bb3	18		clc		            CLC
.1a0bb4	a5 08		lda $0808	            LDA INDEX
.1a0bb6	69 08 00	adc #$0008	            ADC #size(TOKEN)
.1a0bb9	85 08		sta $0808	            STA INDEX
.1a0bbb	a5 0a		lda $080a	            LDA INDEX+2
.1a0bbd	69 00 00	adc #$0000	            ADC #0
.1a0bc0	85 0a		sta $080a	            STA INDEX+2
.1a0bc2	80 da		bra $1a0b9e	            BRA loop                ; And go around for another pass
.1a0bc4					done
.1a0bc4	e2 20		sep #$20	            SEP #$20
.1a0bc6	a5 0c		lda $080c	            LDA SCRATCH
.1a0bc8	85 1e		sta $081e	            STA CURTOKLEN
.1a0bca	ab		plb		            PLB
.1a0bcb	2b		pld		            PLD
.1a0bcc	28		plp		            PLP
.1a0bcd	60		rts		            RTS
.1a0bce					TKWRITE
.1a0bce	08		php		            PHP
.1a0bcf	0b		phd		            PHD
.1a0bd0	08		php		            PHP
.1a0bd1	c2 20		rep #$20	            REP #$20
.1a0bd3	48		pha		            PHA
.1a0bd4	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0bd7	5b		tcd		            TCD
.1a0bd8	68		pla		            PLA
.1a0bd9	28		plp		            PLP
.1a0bda	e2 20		sep #$20	            SEP #$20
.1a0bdc	87 00		sta [$0800]	            STA [BIP]               ; Write the token to the line
.1a0bde	c2 20		rep #$20	            REP #$20
.1a0be0	18		clc		            CLC
.1a0be1	a5 00		lda $0800	            LDA BIP
.1a0be3	69 01 00	adc #$0001	            ADC #1
.1a0be6	85 08		sta $0808	            STA INDEX
.1a0be8	a5 02		lda $0802	            LDA BIP+2
.1a0bea	69 00 00	adc #$0000	            ADC #0
.1a0bed	85 0a		sta $080a	            STA INDEX+2
.1a0bef	e2 10		sep #$10	            SEP #$10
.1a0bf1	a4 1e		ldy $081e	            LDY CURTOKLEN           ; Y will be the number of characters to move down
.1a0bf3	88		dey		            DEY
.1a0bf4					copy_down
.1a0bf4	e2 20		sep #$20	            SEP #$20
.1a0bf6	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the byte to move down
.1a0bf8	87 08		sta [$0808]	            STA [INDEX]             ; Move it down
.1a0bfa	f0 13		beq $1a0c0f	            BEQ done                ; We've reached the end of the line
.1a0bfc	c2 20		rep #$20	            REP #$20
.1a0bfe	18		clc		            CLC
.1a0bff	a5 08		lda $0808	            LDA INDEX
.1a0c01	69 01 00	adc #$0001	            ADC #1
.1a0c04	85 08		sta $0808	            STA INDEX
.1a0c06	a5 0a		lda $080a	            LDA INDEX+2
.1a0c08	69 00 00	adc #$0000	            ADC #0
.1a0c0b	85 0a		sta $080a	            STA INDEX+2
.1a0c0d	80 e5		bra $1a0bf4	            BRA copy_down
.1a0c0f	2b		pld		done        PLD
.1a0c10	28		plp		            PLP
.1a0c11	60		rts		            RTS
.1a0c12					GETTOKREC
.1a0c12	08		php		            PHP
.1a0c13	c2 30		rep #$30	            REP #$30
.1a0c15	29 7f 00	and #$007f	            AND #$007F
.1a0c18	0a		asl a		            ASL A
.1a0c19	0a		asl a		            ASL A
.1a0c1a	0a		asl a		            ASL A
.1a0c1b	18		clc		            CLC
.1a0c1c	69 c3 0c	adc #$0cc3	            ADC #<>TOKENS
.1a0c1f	aa		tax		            TAX                         ; X is now the data bank relative address of the token record
.1a0c20	28		plp		            PLP
.1a0c21	60		rts		            RTS
.1a0c22					TOKPRECED
.1a0c22	08		php		            PHP
.1a0c23	8b		phb		            PHB
.1a0c24	0b		phd		            PHD
.1a0c25	08		php		            PHP
.1a0c26	c2 20		rep #$20	            REP #$20
.1a0c28	48		pha		            PHA
.1a0c29	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0c2c	5b		tcd		            TCD
.1a0c2d	68		pla		            PLA
.1a0c2e	28		plp		            PLP
.1a0c2f	08		php		            PHP
.1a0c30	e2 20		sep #$20	            SEP #$20
.1a0c32	48		pha		            PHA
.1a0c33	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0c35	48		pha		            PHA
.1a0c36	ab		plb		            PLB
.1a0c37	68		pla		            PLA
.1a0c38	28		plp		            PLP
.1a0c39	e2 20		sep #$20	            SEP #$20
.1a0c3b	c2 10		rep #$10	            REP #$10
.1a0c3d	20 12 0c	jsr $1a0c12	            JSR GETTOKREC
.1a0c40	bd 00 00	lda $1a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.1a0c43	c2 20		rep #$20	            REP #$20
.1a0c45	29 0f 00	and #$000f	            AND #$000F                  ; Mask off the type code
.1a0c48	2b		pld		            PLD
.1a0c49	ab		plb		            PLB
.1a0c4a	28		plp		            PLP
.1a0c4b	60		rts		            RTS
.1a0c4c					TOKEVAL
.1a0c4c	08		php		            PHP
.1a0c4d	8b		phb		            PHB
.1a0c4e	0b		phd		            PHD
.1a0c4f	08		php		            PHP
.1a0c50	c2 20		rep #$20	            REP #$20
.1a0c52	48		pha		            PHA
.1a0c53	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0c56	5b		tcd		            TCD
.1a0c57	68		pla		            PLA
.1a0c58	28		plp		            PLP
.1a0c59	08		php		            PHP
.1a0c5a	e2 20		sep #$20	            SEP #$20
.1a0c5c	48		pha		            PHA
.1a0c5d	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0c5f	48		pha		            PHA
.1a0c60	ab		plb		            PLB
.1a0c61	68		pla		            PLA
.1a0c62	28		plp		            PLP
.1a0c63	c2 30		rep #$30	            REP #$30
.1a0c65	20 12 0c	jsr $1a0c12	            JSR GETTOKREC
.1a0c68	bd 04 00	lda $1a0004,x	            LDA #TOKEN.eval,B,X         ; Get the address of the evaluation function
.1a0c6b	2b		pld		            PLD
.1a0c6c	ab		plb		            PLB
.1a0c6d	28		plp		            PLP
.1a0c6e	60		rts		            RTS
.1a0c6f					TOKTYPE
.1a0c6f	08		php		            PHP
.1a0c70	8b		phb		            PHB
.1a0c71	0b		phd		            PHD
.1a0c72	08		php		            PHP
.1a0c73	c2 20		rep #$20	            REP #$20
.1a0c75	48		pha		            PHA
.1a0c76	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0c79	5b		tcd		            TCD
.1a0c7a	68		pla		            PLA
.1a0c7b	28		plp		            PLP
.1a0c7c	08		php		            PHP
.1a0c7d	e2 20		sep #$20	            SEP #$20
.1a0c7f	48		pha		            PHA
.1a0c80	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0c82	48		pha		            PHA
.1a0c83	ab		plb		            PLB
.1a0c84	68		pla		            PLA
.1a0c85	28		plp		            PLP
.1a0c86	e2 20		sep #$20	            SEP #$20
.1a0c88	c2 10		rep #$10	            REP #$10
.1a0c8a	20 12 0c	jsr $1a0c12	            JSR GETTOKREC
.1a0c8d	bd 00 00	lda $1a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.1a0c90	c2 20		rep #$20	            REP #$20
.1a0c92	29 f0 00	and #$00f0	            AND #$00F0                  ; Mask off the type code
.1a0c95	2b		pld		            PLD
.1a0c96	ab		plb		            PLB
.1a0c97	28		plp		            PLP
.1a0c98	60		rts		            RTS
.1a0c99					TOKARITY
.1a0c99	08		php		            PHP
.1a0c9a	8b		phb		            PHB
.1a0c9b	0b		phd		            PHD
.1a0c9c	08		php		            PHP
.1a0c9d	c2 20		rep #$20	            REP #$20
.1a0c9f	48		pha		            PHA
.1a0ca0	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0ca3	5b		tcd		            TCD
.1a0ca4	68		pla		            PLA
.1a0ca5	28		plp		            PLP
.1a0ca6	08		php		            PHP
.1a0ca7	e2 20		sep #$20	            SEP #$20
.1a0ca9	48		pha		            PHA
.1a0caa	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0cac	48		pha		            PHA
.1a0cad	ab		plb		            PLB
.1a0cae	68		pla		            PLA
.1a0caf	28		plp		            PLP
.1a0cb0	e2 20		sep #$20	            SEP #$20
.1a0cb2	c2 10		rep #$10	            REP #$10
.1a0cb4	20 12 0c	jsr $1a0c12	            JSR GETTOKREC
.1a0cb7	bd 06 00	lda $1a0006,x	            LDA #TOKEN.arity,B,X        ; Get the arity
.1a0cba	c2 20		rep #$20	            REP #$20
.1a0cbc	29 ff 00	and #$00ff	            AND #$00FF
.1a0cbf	2b		pld		            PLD
.1a0cc0	ab		plb		            PLB
.1a0cc1	28		plp		            PLP
.1a0cc2	60		rts		            RTS
=$00					TOK_EOL = $00
=$01					TOK_FUNC_OPEN = $01     ; A pseudo-token to push to the operator stack to mark
=$00					TOK_TY_OP = $00         ; The token is an operator
=$10					TOK_TY_CMD = $10        ; The token is a command (e.g. RUN, LIST, etc.)
=$20					TOK_TY_STMNT = $20      ; The token is a statement (e.g. INPUT, PRINT, DIM, etc.)
=$30					TOK_TY_FUNC = $30       ; The token is a function (e.g. SIN, COS, TAB, etc.)
=$40					TOK_TY_PUNCT = $40      ; The token is a punctuation mark (e.g. "(", ")")
=$50					TOK_TY_BYWRD = $50      ; The token is a by-word (e.g. STEP, TO, WEND, etc.)
.1a0cc3					TOKENS
=$80					TOK_PLUS = $80
>1ad010	2b 00				TOKEN_TEXT  .null "+"
>1a0cc3	03				precedence  .byte TOK_TY_OP | 3
>1a0cc4	01				length      .byte len("+")
>1a0cc5	10 d0				name        .word <>TOKEN_TEXT
>1a0cc7	a3 27				eval        .word <>OP_PLUS
>1a0cc9	02 00				arity       .word <>2
=$81					TOK_MINUS = $81
>1ad012	2d 00				TOKEN_TEXT  .null "-"
>1a0ccb	03				precedence  .byte TOK_TY_OP | 3
>1a0ccc	01				length      .byte len("-")
>1a0ccd	12 d0				name        .word <>TOKEN_TEXT
>1a0ccf	e3 27				eval        .word <>OP_MINUS
>1a0cd1	02 00				arity       .word <>2
=$82					TOK_MULT = $82
>1ad014	2a 00				TOKEN_TEXT  .null "*"
>1a0cd3	02				precedence  .byte TOK_TY_OP | 2
>1a0cd4	01				length      .byte len("*")
>1a0cd5	14 d0				name        .word <>TOKEN_TEXT
>1a0cd7	1a 28				eval        .word <>OP_MULTIPLY
>1a0cd9	02 00				arity       .word <>2
=$83					TOK_DIVIDE = $83
>1ad016	2f 00				TOKEN_TEXT  .null "/"
>1a0cdb	02				precedence  .byte TOK_TY_OP | 2
>1a0cdc	01				length      .byte len("/")
>1a0cdd	16 d0				name        .word <>TOKEN_TEXT
>1a0cdf	51 28				eval        .word <>OP_DIVIDE
>1a0ce1	02 00				arity       .word <>2
=$84					TOK_MOD = $84
>1ad018	4d 4f 44 00			TOKEN_TEXT  .null "MOD"
>1a0ce3	02				precedence  .byte TOK_TY_OP | 2
>1a0ce4	03				length      .byte len("MOD")
>1a0ce5	18 d0				name        .word <>TOKEN_TEXT
>1a0ce7	5b 28				eval        .word <>OP_MOD
>1a0ce9	02 00				arity       .word <>2
>1ad01c	5e 00				TOKEN_TEXT  .null "^"
>1a0ceb	00				precedence  .byte TOK_TY_OP | 0
>1a0cec	01				length      .byte len("^")
>1a0ced	1c d0				name        .word <>TOKEN_TEXT
>1a0cef	6e 28				eval        .word <>OP_POW
>1a0cf1	02 00				arity       .word <>2
=$86					TOK_LE = $86
>1ad01e	3c 3d 00			TOKEN_TEXT  .null "<="
>1a0cf3	04				precedence  .byte TOK_TY_OP | 4
>1a0cf4	02				length      .byte len("<=")
>1a0cf5	1e d0				name        .word <>TOKEN_TEXT
>1a0cf7	2c 2a				eval        .word <>OP_LTE
>1a0cf9	02 00				arity       .word <>2
=$87					TOK_GE = $87
>1ad021	3e 3d 00			TOKEN_TEXT  .null ">="
>1a0cfb	04				precedence  .byte TOK_TY_OP | 4
>1a0cfc	02				length      .byte len(">=")
>1a0cfd	21 d0				name        .word <>TOKEN_TEXT
>1a0cff	ec 29				eval        .word <>OP_GTE
>1a0d01	02 00				arity       .word <>2
=$88					TOK_NE = $88
>1ad024	3c 3e 00			TOKEN_TEXT  .null "<>"
>1a0d03	04				precedence  .byte TOK_TY_OP | 4
>1a0d04	02				length      .byte len("<>")
>1a0d05	24 d0				name        .word <>TOKEN_TEXT
>1a0d07	ac 29				eval        .word <>OP_NE
>1a0d09	02 00				arity       .word <>2
>1ad027	3c 00				TOKEN_TEXT  .null "<"
>1a0d0b	04				precedence  .byte TOK_TY_OP | 4
>1a0d0c	01				length      .byte len("<")
>1a0d0d	27 d0				name        .word <>TOKEN_TEXT
>1a0d0f	ec 28				eval        .word <>OP_LT
>1a0d11	02 00				arity       .word <>2
=$8a					TOK_EQ = $8A
>1ad029	3d 00				TOKEN_TEXT  .null "="
>1a0d13	04				precedence  .byte TOK_TY_OP | 4
>1a0d14	01				length      .byte len("=")
>1a0d15	29 d0				name        .word <>TOKEN_TEXT
>1a0d17	6c 29				eval        .word <>OP_EQ
>1a0d19	02 00				arity       .word <>2
>1ad02b	3e 00				TOKEN_TEXT  .null ">"
>1a0d1b	04				precedence  .byte TOK_TY_OP | 4
>1a0d1c	01				length      .byte len(">")
>1a0d1d	2b d0				name        .word <>TOKEN_TEXT
>1a0d1f	2c 29				eval        .word <>OP_GT
>1a0d21	02 00				arity       .word <>2
>1ad02d	4e 4f 54 00			TOKEN_TEXT  .null "NOT"
>1a0d23	05				precedence  .byte TOK_TY_OP | 5
>1a0d24	03				length      .byte len("NOT")
>1a0d25	2d d0				name        .word <>TOKEN_TEXT
>1a0d27	d6 28				eval        .word <>OP_NOT
>1a0d29	01 00				arity       .word <>1
>1ad031	41 4e 44 00			TOKEN_TEXT  .null "AND"
>1a0d2b	06				precedence  .byte TOK_TY_OP | 6
>1a0d2c	03				length      .byte len("AND")
>1a0d2d	31 d0				name        .word <>TOKEN_TEXT
>1a0d2f	a8 28				eval        .word <>OP_AND
>1a0d31	02 00				arity       .word <>2
>1ad035	4f 52 00			TOKEN_TEXT  .null "OR"
>1a0d33	07				precedence  .byte TOK_TY_OP | 7
>1a0d34	02				length      .byte len("OR")
>1a0d35	35 d0				name        .word <>TOKEN_TEXT
>1a0d37	bf 28				eval        .word <>OP_OR
>1a0d39	02 00				arity       .word <>2
=$8f					TOK_LPAREN = $8F
>1ad038	28 00				TOKEN_TEXT  .null "("
>1a0d3b	ff				precedence  .byte TOK_TY_PUNCT | $FF
>1a0d3c	01				length      .byte len("(")
>1a0d3d	38 d0				name        .word <>TOKEN_TEXT
>1a0d3f	00 00				eval        .word <>0
>1a0d41	00 00				arity       .word <>0
=$90					TOK_RPAREN = $90
>1ad03a	29 00				TOKEN_TEXT  .null ")"
>1a0d43	40				precedence  .byte TOK_TY_PUNCT | 0
>1a0d44	01				length      .byte len(")")
>1a0d45	3a d0				name        .word <>TOKEN_TEXT
>1a0d47	00 00				eval        .word <>0
>1a0d49	00 00				arity       .word <>0
=$91					TOK_REM = $91
>1ad03c	52 45 4d 00			TOKEN_TEXT  .null "REM"
>1a0d4b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d4c	03				length      .byte len("REM")
>1a0d4d	3c d0				name        .word <>TOKEN_TEXT
>1a0d4f	f2 40				eval        .word <>S_REM
>1a0d51	00 00				arity       .word <>0
=$92					TOK_PRINT = $92
>1ad040	50 52 49 4e 54 00		TOKEN_TEXT  .null "PRINT"
>1a0d53	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d54	05				length      .byte len("PRINT")
>1a0d55	40 d0				name        .word <>TOKEN_TEXT
>1a0d57	f7 44				eval        .word <>S_PRINT
>1a0d59	00 00				arity       .word <>0
=$93					TOK_LET = $93
>1ad046	4c 45 54 00			TOKEN_TEXT  .null "LET"
>1a0d5b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d5c	03				length      .byte len("LET")
>1a0d5d	46 d0				name        .word <>TOKEN_TEXT
>1a0d5f	42 44				eval        .word <>S_LET
>1a0d61	00 00				arity       .word <>0
>1ad04a	47 4f 54 4f 00			TOKEN_TEXT  .null "GOTO"
>1a0d63	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d64	04				length      .byte len("GOTO")
>1a0d65	4a d0				name        .word <>TOKEN_TEXT
>1a0d67	e2 43				eval        .word <>S_GOTO
>1a0d69	00 00				arity       .word <>0
=$95					TOK_END = $95
>1ad04f	45 4e 44 00			TOKEN_TEXT  .null "END"
>1a0d6b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d6c	03				length      .byte len("END")
>1a0d6d	4f d0				name        .word <>TOKEN_TEXT
>1a0d6f	d9 43				eval        .word <>S_END
>1a0d71	00 00				arity       .word <>0
>1ad053	49 46 00			TOKEN_TEXT  .null "IF"
>1a0d73	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d74	02				length      .byte len("IF")
>1a0d75	53 d0				name        .word <>TOKEN_TEXT
>1a0d77	71 43				eval        .word <>S_IF
>1a0d79	00 00				arity       .word <>0
=$97					TOK_THEN = $97
>1ad056	54 48 45 4e 00			TOKEN_TEXT  .null "THEN"
>1a0d7b	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0d7c	04				length      .byte len("THEN")
>1a0d7d	56 d0				name        .word <>TOKEN_TEXT
>1a0d7f	00 00				eval        .word <>0
>1a0d81	00 00				arity       .word <>0
>1ad05b	45 4c 53 45 00			TOKEN_TEXT  .null "ELSE"
>1a0d83	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0d84	04				length      .byte len("ELSE")
>1a0d85	5b d0				name        .word <>TOKEN_TEXT
>1a0d87	00 00				eval        .word <>0
>1a0d89	00 00				arity       .word <>0
>1ad060	47 4f 53 55 42 00		TOKEN_TEXT  .null "GOSUB"
>1a0d8b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d8c	05				length      .byte len("GOSUB")
>1a0d8d	60 d0				name        .word <>TOKEN_TEXT
>1a0d8f	b4 42				eval        .word <>S_GOSUB
>1a0d91	00 00				arity       .word <>0
>1ad066	52 45 54 55 52 4e 00		TOKEN_TEXT  .null "RETURN"
>1a0d93	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d94	06				length      .byte len("RETURN")
>1a0d95	66 d0				name        .word <>TOKEN_TEXT
>1a0d97	2d 43				eval        .word <>S_RETURN
>1a0d99	00 00				arity       .word <>0
=$9b					TOK_FOR = $9B
>1ad06d	46 4f 52 00			TOKEN_TEXT  .null "FOR"
>1a0d9b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d9c	03				length      .byte len("FOR")
>1a0d9d	6d d0				name        .word <>TOKEN_TEXT
>1a0d9f	09 41				eval        .word <>S_FOR
>1a0da1	00 00				arity       .word <>0
=$9c					TOK_TO = $9C
>1ad071	54 4f 00			TOKEN_TEXT  .null "TO"
>1a0da3	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0da4	02				length      .byte len("TO")
>1a0da5	71 d0				name        .word <>TOKEN_TEXT
>1a0da7	00 00				eval        .word <>0
>1a0da9	00 00				arity       .word <>0
=$9d					TOK_STEP = $9D
>1ad074	53 54 45 50 00			TOKEN_TEXT  .null "STEP"
>1a0dab	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0dac	04				length      .byte len("STEP")
>1a0dad	74 d0				name        .word <>TOKEN_TEXT
>1a0daf	00 00				eval        .word <>0
>1a0db1	00 00				arity       .word <>0
=$9e					TOK_NEXT = $9E
>1ad079	4e 45 58 54 00			TOKEN_TEXT  .null "NEXT"
>1a0db3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0db4	04				length      .byte len("NEXT")
>1a0db5	79 d0				name        .word <>TOKEN_TEXT
>1a0db7	fd 41				eval        .word <>S_NEXT
>1a0db9	00 00				arity       .word <>0
=$9f					TOK_DO = $9F
>1ad07e	44 4f 00			TOKEN_TEXT  .null "DO"
>1a0dbb	20				precedence  .byte TOK_TY_STMNT | 0
>1a0dbc	02				length      .byte len("DO")
>1a0dbd	7e d0				name        .word <>TOKEN_TEXT
>1a0dbf	03 41				eval        .word <>S_DO
>1a0dc1	00 00				arity       .word <>0
=$a0					TOK_LOOP = $A0
>1ad081	4c 4f 4f 50 00			TOKEN_TEXT  .null "LOOP"
>1a0dc3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0dc4	04				length      .byte len("LOOP")
>1a0dc5	81 d0				name        .word <>TOKEN_TEXT
>1a0dc7	06 41				eval        .word <>S_LOOP
>1a0dc9	00 00				arity       .word <>0
>1ad086	57 48 49 4c 45 00		TOKEN_TEXT  .null "WHILE"
>1a0dcb	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0dcc	05				length      .byte len("WHILE")
>1a0dcd	86 d0				name        .word <>TOKEN_TEXT
>1a0dcf	00 00				eval        .word <>0
>1a0dd1	00 00				arity       .word <>0
>1ad08c	55 4e 54 49 4c 00		TOKEN_TEXT  .null "UNTIL"
>1a0dd3	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0dd4	05				length      .byte len("UNTIL")
>1a0dd5	8c d0				name        .word <>TOKEN_TEXT
>1a0dd7	00 00				eval        .word <>0
>1a0dd9	00 00				arity       .word <>0
>1ad092	45 58 49 54 00			TOKEN_TEXT  .null "EXIT"
>1a0ddb	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ddc	04				length      .byte len("EXIT")
>1a0ddd	92 d0				name        .word <>TOKEN_TEXT
>1a0ddf	00 41				eval        .word <>S_EXIT
>1a0de1	00 00				arity       .word <>0
>1ad097	43 4c 52 00			TOKEN_TEXT  .null "CLR"
>1a0de3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0de4	03				length      .byte len("CLR")
>1a0de5	97 d0				name        .word <>TOKEN_TEXT
>1a0de7	38 44				eval        .word <>S_CLR
>1a0de9	00 00				arity       .word <>0
>1ad09b	53 54 4f 50 00			TOKEN_TEXT  .null "STOP"
>1a0deb	20				precedence  .byte TOK_TY_STMNT | 0
>1a0dec	04				length      .byte len("STOP")
>1a0ded	9b d0				name        .word <>TOKEN_TEXT
>1a0def	d3 40				eval        .word <>S_STOP
>1a0df1	00 00				arity       .word <>0
>1ad0a0	50 4f 4b 45 00			TOKEN_TEXT  .null "POKE"
>1a0df3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0df4	04				length      .byte len("POKE")
>1a0df5	a0 d0				name        .word <>TOKEN_TEXT
>1a0df7	63 40				eval        .word <>S_POKE
>1a0df9	00 00				arity       .word <>0
>1ad0a5	50 4f 4b 45 57 00		TOKEN_TEXT  .null "POKEW"
>1a0dfb	20				precedence  .byte TOK_TY_STMNT | 0
>1a0dfc	05				length      .byte len("POKEW")
>1a0dfd	a5 d0				name        .word <>TOKEN_TEXT
>1a0dff	f9 3f				eval        .word <>S_POKEW
>1a0e01	00 00				arity       .word <>0
>1ad0ab	50 4f 4b 45 4c 00		TOKEN_TEXT  .null "POKEL"
>1a0e03	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e04	05				length      .byte len("POKEL")
>1a0e05	ab d0				name        .word <>TOKEN_TEXT
>1a0e07	86 3f				eval        .word <>S_POKEL
>1a0e09	00 00				arity       .word <>0
>1ad0b1	43 4c 53 00			TOKEN_TEXT  .null "CLS"
>1a0e0b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e0c	03				length      .byte len("CLS")
>1a0e0d	b1 d0				name        .word <>TOKEN_TEXT
>1a0e0f	82 3f				eval        .word <>S_CLS
>1a0e11	00 00				arity       .word <>0
>1ad0b5	52 45 41 44 00			TOKEN_TEXT  .null "READ"
>1a0e13	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e14	04				length      .byte len("READ")
>1a0e15	b5 d0				name        .word <>TOKEN_TEXT
>1a0e17	63 3e				eval        .word <>S_READ
>1a0e19	00 00				arity       .word <>0
=$ab					TOK_DATA = $AB
>1ad0ba	44 41 54 41 00			TOKEN_TEXT  .null "DATA"
>1a0e1b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e1c	04				length      .byte len("DATA")
>1a0e1d	ba d0				name        .word <>TOKEN_TEXT
>1a0e1f	75 3f				eval        .word <>S_DATA
>1a0e21	00 00				arity       .word <>0
>1ad0bf	52 45 53 54 4f 52 45 00		TOKEN_TEXT  .null "RESTORE"
>1a0e23	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e24	07				length      .byte len("RESTORE")
>1a0e25	bf d0				name        .word <>TOKEN_TEXT
>1a0e27	79 3f				eval        .word <>S_RESTORE
>1a0e29	00 00				arity       .word <>0
>1ad0c7	44 49 4d 00			TOKEN_TEXT  .null "DIM"
>1a0e2b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e2c	03				length      .byte len("DIM")
>1a0e2d	c7 d0				name        .word <>TOKEN_TEXT
>1a0e2f	b6 3d				eval        .word <>S_DIM
>1a0e31	00 00				arity       .word <>0
>1ad0cb	43 41 4c 4c 00			TOKEN_TEXT  .null "CALL"
>1a0e33	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e34	04				length      .byte len("CALL")
>1a0e35	cb d0				name        .word <>TOKEN_TEXT
>1a0e37	1f 3d				eval        .word <>S_CALL
>1a0e39	00 00				arity       .word <>0
=$af					TOK_NEGATIVE = $AF
>1ad0d0	2d 00				TOKEN_TEXT  .null "-"
>1a0e3b	00				precedence  .byte TOK_TY_OP | 0
>1a0e3c	01				length      .byte len("-")
>1a0e3d	d0 d0				name        .word <>TOKEN_TEXT
>1a0e3f	6c 2a				eval        .word <>OP_NEGATIVE
>1a0e41	01 00				arity       .word <>1
>1ad0d2	4c 45 4e 00			TOKEN_TEXT  .null "LEN"
>1a0e43	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e44	03				length      .byte len("LEN")
>1a0e45	d2 d0				name        .word <>TOKEN_TEXT
>1a0e47	eb 4a				eval        .word <>FN_LEN
>1a0e49	00 00				arity       .word <>0
>1ad0d6	50 45 45 4b 00			TOKEN_TEXT  .null "PEEK"
>1a0e4b	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e4c	04				length      .byte len("PEEK")
>1a0e4d	d6 d0				name        .word <>TOKEN_TEXT
>1a0e4f	3b 4b				eval        .word <>FN_PEEK
>1a0e51	00 00				arity       .word <>0
>1ad0db	50 45 45 4b 57 00		TOKEN_TEXT  .null "PEEKW"
>1a0e53	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e54	05				length      .byte len("PEEKW")
>1a0e55	db d0				name        .word <>TOKEN_TEXT
>1a0e57	ed 4b				eval        .word <>FN_PEEKW
>1a0e59	00 00				arity       .word <>0
>1ad0e1	50 45 45 4b 4c 00		TOKEN_TEXT  .null "PEEKL"
>1a0e5b	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e5c	05				length      .byte len("PEEKL")
>1a0e5d	e1 d0				name        .word <>TOKEN_TEXT
>1a0e5f	9f 4b				eval        .word <>FN_PEEKL
>1a0e61	00 00				arity       .word <>0
>1ad0e7	43 48 52 24 00			TOKEN_TEXT  .null "CHR$"
>1a0e63	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e64	04				length      .byte len("CHR$")
>1a0e65	e7 d0				name        .word <>TOKEN_TEXT
>1a0e67	2c 4c				eval        .word <>FN_CHR
>1a0e69	00 00				arity       .word <>0
>1ad0ec	41 53 43 00			TOKEN_TEXT  .null "ASC"
>1a0e6b	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e6c	03				length      .byte len("ASC")
>1a0e6d	ec d0				name        .word <>TOKEN_TEXT
>1a0e6f	81 4c				eval        .word <>FN_ASC
>1a0e71	00 00				arity       .word <>0
>1ad0f0	53 50 43 00			TOKEN_TEXT  .null "SPC"
>1a0e73	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e74	03				length      .byte len("SPC")
>1a0e75	f0 d0				name        .word <>TOKEN_TEXT
>1a0e77	c6 4c				eval        .word <>FN_SPC
>1a0e79	00 00				arity       .word <>0
>1ad0f4	54 41 42 00			TOKEN_TEXT  .null "TAB"
>1a0e7b	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e7c	03				length      .byte len("TAB")
>1a0e7d	f4 d0				name        .word <>TOKEN_TEXT
>1a0e7f	4f 4d				eval        .word <>FN_TAB
>1a0e81	00 00				arity       .word <>0
>1ad0f8	41 42 53 00			TOKEN_TEXT  .null "ABS"
>1a0e83	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e84	03				length      .byte len("ABS")
>1a0e85	f8 d0				name        .word <>TOKEN_TEXT
>1a0e87	d8 4d				eval        .word <>FN_ABS
>1a0e89	00 00				arity       .word <>0
>1ad0fc	53 47 4e 00			TOKEN_TEXT  .null "SGN"
>1a0e8b	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e8c	03				length      .byte len("SGN")
>1a0e8d	fc d0				name        .word <>TOKEN_TEXT
>1a0e8f	3a 4e				eval        .word <>FN_SGN
>1a0e91	00 00				arity       .word <>0
>1ad100	48 45 58 24 00			TOKEN_TEXT  .null "HEX$"
>1a0e93	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e94	04				length      .byte len("HEX$")
>1a0e95	00 d1				name        .word <>TOKEN_TEXT
>1a0e97	5d 4a				eval        .word <>FN_HEX
>1a0e99	00 00				arity       .word <>0
>1ad105	44 45 43 00			TOKEN_TEXT  .null "DEC"
>1a0e9b	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e9c	03				length      .byte len("DEC")
>1a0e9d	05 d1				name        .word <>TOKEN_TEXT
>1a0e9f	fc 49				eval        .word <>FN_DEC
>1a0ea1	00 00				arity       .word <>0
>1ad109	53 54 52 24 00			TOKEN_TEXT  .null "STR$"
>1a0ea3	30				precedence  .byte TOK_TY_FUNC | 0
>1a0ea4	04				length      .byte len("STR$")
>1a0ea5	09 d1				name        .word <>TOKEN_TEXT
>1a0ea7	ae 49				eval        .word <>FN_STR
>1a0ea9	00 00				arity       .word <>0
>1ad10e	56 41 4c 00			TOKEN_TEXT  .null "VAL"
>1a0eab	30				precedence  .byte TOK_TY_FUNC | 0
>1a0eac	03				length      .byte len("VAL")
>1a0ead	0e d1				name        .word <>TOKEN_TEXT
>1a0eaf	58 49				eval        .word <>FN_VAL
>1a0eb1	00 00				arity       .word <>0
>1ad112	4c 45 46 54 24 00		TOKEN_TEXT  .null "LEFT$"
>1a0eb3	30				precedence  .byte TOK_TY_FUNC | 0
>1a0eb4	05				length      .byte len("LEFT$")
>1a0eb5	12 d1				name        .word <>TOKEN_TEXT
>1a0eb7	8f 48				eval        .word <>FN_LEFT
>1a0eb9	00 00				arity       .word <>0
>1ad118	52 49 47 48 54 24 00		TOKEN_TEXT  .null "RIGHT$"
>1a0ebb	30				precedence  .byte TOK_TY_FUNC | 0
>1a0ebc	06				length      .byte len("RIGHT$")
>1a0ebd	18 d1				name        .word <>TOKEN_TEXT
>1a0ebf	ae 47				eval        .word <>FN_RIGHT
>1a0ec1	00 00				arity       .word <>0
>1ad11f	4d 49 44 24 00			TOKEN_TEXT  .null "MID$"
>1a0ec3	30				precedence  .byte TOK_TY_FUNC | 0
>1a0ec4	04				length      .byte len("MID$")
>1a0ec5	1f d1				name        .word <>TOKEN_TEXT
>1a0ec7	f9 46				eval        .word <>FN_MID
>1a0ec9	00 00				arity       .word <>0
>1ad124	52 55 4e 00			TOKEN_TEXT  .null "RUN"
>1a0ecb	10				precedence  .byte TOK_TY_CMD | 0
>1a0ecc	03				length      .byte len("RUN")
>1a0ecd	24 d1				name        .word <>TOKEN_TEXT
>1a0ecf	a1 4f				eval        .word <>CMD_RUN
>1a0ed1	00 00				arity       .word <>0
>1ad128	4e 45 57 00			TOKEN_TEXT  .null "NEW"
>1a0ed3	10				precedence  .byte TOK_TY_CMD | 0
>1a0ed4	03				length      .byte len("NEW")
>1a0ed5	28 d1				name        .word <>TOKEN_TEXT
>1a0ed7	6c 4f				eval        .word <>CMD_NEW
>1a0ed9	00 00				arity       .word <>0
>1ad12c	4c 4f 41 44 00			TOKEN_TEXT  .null "LOAD"
>1a0edb	10				precedence  .byte TOK_TY_CMD | 0
>1a0edc	04				length      .byte len("LOAD")
>1a0edd	2c d1				name        .word <>TOKEN_TEXT
>1a0edf	75 6b				eval        .word <>CMD_LOAD
>1a0ee1	00 00				arity       .word <>0
>1ad131	4c 49 53 54 00			TOKEN_TEXT  .null "LIST"
>1a0ee3	10				precedence  .byte TOK_TY_CMD | 0
>1a0ee4	04				length      .byte len("LIST")
>1a0ee5	31 d1				name        .word <>TOKEN_TEXT
>1a0ee7	b8 4f				eval        .word <>CMD_LIST
>1a0ee9	00 00				arity       .word <>0
>1ad136	44 49 52 00			TOKEN_TEXT  .null "DIR"
>1a0eeb	10				precedence  .byte TOK_TY_CMD | 0
>1a0eec	03				length      .byte len("DIR")
>1a0eed	36 d1				name        .word <>TOKEN_TEXT
>1a0eef	9c 68				eval        .word <>CMD_DIR
>1a0ef1	00 00				arity       .word <>0
>1ad13a	42 4c 4f 41 44 00		TOKEN_TEXT  .null "BLOAD"
>1a0ef3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ef4	05				length      .byte len("BLOAD")
>1a0ef5	3a d1				name        .word <>TOKEN_TEXT
>1a0ef7	47 6a				eval        .word <>S_BLOAD
>1a0ef9	00 00				arity       .word <>0
>1ad140	42 52 55 4e 00			TOKEN_TEXT  .null "BRUN"
>1a0efb	10				precedence  .byte TOK_TY_CMD | 0
>1a0efc	04				length      .byte len("BRUN")
>1a0efd	40 d1				name        .word <>TOKEN_TEXT
>1a0eff	22 6b				eval        .word <>CMD_BRUN
>1a0f01	00 00				arity       .word <>0
>1ad145	42 53 41 56 45 00		TOKEN_TEXT  .null "BSAVE"
>1a0f03	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f04	05				length      .byte len("BSAVE")
>1a0f05	45 d1				name        .word <>TOKEN_TEXT
>1a0f07	2e 6c				eval        .word <>S_BSAVE
>1a0f09	00 00				arity       .word <>0
>1ad14b	44 45 4c 00			TOKEN_TEXT  .null "DEL"
>1a0f0b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f0c	03				length      .byte len("DEL")
>1a0f0d	4b d1				name        .word <>TOKEN_TEXT
>1a0f0f	4d 6d				eval        .word <>S_DEL
>1a0f11	00 00				arity       .word <>0
>1ad14f	53 41 56 45 00			TOKEN_TEXT  .null "SAVE"
>1a0f13	10				precedence  .byte TOK_TY_CMD | 0
>1a0f14	04				length      .byte len("SAVE")
>1a0f15	4f d1				name        .word <>TOKEN_TEXT
>1a0f17	ba 6c				eval        .word <>CMD_SAVE
>1a0f19	00 00				arity       .word <>0
>1ad154	52 45 4e 41 4d 45 00		TOKEN_TEXT  .null "RENAME"
>1a0f1b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f1c	06				length      .byte len("RENAME")
>1a0f1d	54 d1				name        .word <>TOKEN_TEXT
>1a0f1f	c3 6d				eval        .word <>S_RENAME
>1a0f21	00 00				arity       .word <>0
>1ad15b	43 4f 50 59 00			TOKEN_TEXT  .null "COPY"
>1a0f23	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f24	04				length      .byte len("COPY")
>1a0f25	5b d1				name        .word <>TOKEN_TEXT
>1a0f27	e7 6e				eval        .word <>S_COPY
>1a0f29	00 00				arity       .word <>0
>1ad160	4d 4f 4e 49 54 4f 52 00		TOKEN_TEXT  .null "MONITOR"
>1a0f2b	10				precedence  .byte TOK_TY_CMD | 0
>1a0f2c	07				length      .byte len("MONITOR")
>1a0f2d	60 d1				name        .word <>TOKEN_TEXT
>1a0f2f	69 4f				eval        .word <>CMD_MONITOR
>1a0f31	00 00				arity       .word <>0
>1ad168	47 45 54 00			TOKEN_TEXT  .null "GET"
>1a0f33	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f34	03				length      .byte len("GET")
>1a0f35	68 d1				name        .word <>TOKEN_TEXT
>1a0f37	ad 3c				eval        .word <>S_GET
>1a0f39	00 00				arity       .word <>0
>1ad16c	49 4e 50 55 54 00		TOKEN_TEXT  .null "INPUT"
>1a0f3b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f3c	05				length      .byte len("INPUT")
>1a0f3d	6c d1				name        .word <>TOKEN_TEXT
>1a0f3f	bd 3b				eval        .word <>S_INPUT
>1a0f41	00 00				arity       .word <>0
>1ad172	53 45 54 42 4f 52 44 45		TOKEN_TEXT  .null "SETBORDER"
>1ad17a	52 00
>1a0f43	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f44	09				length      .byte len("SETBORDER")
>1a0f45	72 d1				name        .word <>TOKEN_TEXT
>1a0f47	2b 2c				eval        .word <>S_SETBORDER
>1a0f49	00 00				arity       .word <>0
>1ad17c	54 45 58 54 43 4f 4c 4f		TOKEN_TEXT  .null "TEXTCOLOR"
>1ad184	52 00
>1a0f4b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f4c	09				length      .byte len("TEXTCOLOR")
>1a0f4d	7c d1				name        .word <>TOKEN_TEXT
>1a0f4f	b8 2b				eval        .word <>S_TEXTCOLOR
>1a0f51	00 00				arity       .word <>0
>1ad186	53 45 54 42 47 43 4f 4c		TOKEN_TEXT  .null "SETBGCOLOR"
>1ad18e	4f 52 00
>1a0f53	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f54	0a				length      .byte len("SETBGCOLOR")
>1a0f55	86 d1				name        .word <>TOKEN_TEXT
>1a0f57	e8 2b				eval        .word <>S_SETBGCOLOR
>1a0f59	00 00				arity       .word <>0
>1ad191	53 45 54 44 41 54 45 00		TOKEN_TEXT  .null "SETDATE"
>1a0f5b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f5c	07				length      .byte len("SETDATE")
>1a0f5d	91 d1				name        .word <>TOKEN_TEXT
>1a0f5f	25 2b				eval        .word <>S_SETDATE
>1a0f61	00 00				arity       .word <>0
>1ad199	47 45 54 44 41 54 45 24		TOKEN_TEXT  .null "GETDATE$"
>1ad1a1	00
>1a0f63	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f64	08				length      .byte len("GETDATE$")
>1a0f65	99 d1				name        .word <>TOKEN_TEXT
>1a0f67	d4 45				eval        .word <>F_GETDATE
>1a0f69	00 00				arity       .word <>0
>1ad1a2	53 45 54 54 49 4d 45 00		TOKEN_TEXT  .null "SETTIME"
>1a0f6b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f6c	07				length      .byte len("SETTIME")
>1a0f6d	a2 d1				name        .word <>TOKEN_TEXT
>1a0f6f	ba 2a				eval        .word <>S_SETTIME
>1a0f71	00 00				arity       .word <>0
>1ad1aa	47 45 54 54 49 4d 45 24		TOKEN_TEXT  .null "GETTIME$"
>1ad1b2	00
>1a0f73	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f74	08				length      .byte len("GETTIME$")
>1a0f75	aa d1				name        .word <>TOKEN_TEXT
>1a0f77	3e 46				eval        .word <>F_GETTIME
>1a0f79	00 00				arity       .word <>0
>1ad1b3	47 52 41 50 48 49 43 53		TOKEN_TEXT  .null "GRAPHICS"
>1ad1bb	00
>1a0f7b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f7c	08				length      .byte len("GRAPHICS")
>1a0f7d	b3 d1				name        .word <>TOKEN_TEXT
>1a0f7f	70 2d				eval        .word <>S_GRAPHICS
>1a0f81	00 00				arity       .word <>0
>1ad1bc	53 45 54 43 4f 4c 4f 52		TOKEN_TEXT  .null "SETCOLOR"
>1ad1c4	00
>1a0f83	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f84	08				length      .byte len("SETCOLOR")
>1a0f85	bc d1				name        .word <>TOKEN_TEXT
>1a0f87	a4 2c				eval        .word <>S_SETCOLOR
>1a0f89	00 00				arity       .word <>0
>1ad1c5	42 49 54 4d 41 50 00		TOKEN_TEXT  .null "BITMAP"
>1a0f8b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f8c	06				length      .byte len("BITMAP")
>1a0f8d	c5 d1				name        .word <>TOKEN_TEXT
>1a0f8f	aa 2e				eval        .word <>S_BITMAP
>1a0f91	00 00				arity       .word <>0
>1ad1cc	43 4c 52 42 49 54 4d 41		TOKEN_TEXT  .null "CLRBITMAP"
>1ad1d4	50 00
>1a0f93	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f94	09				length      .byte len("CLRBITMAP")
>1a0f95	cc d1				name        .word <>TOKEN_TEXT
>1a0f97	b2 2f				eval        .word <>S_CLRBITMAP
>1a0f99	00 00				arity       .word <>0
>1ad1d6	50 4c 4f 54 00			TOKEN_TEXT  .null "PLOT"
>1a0f9b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f9c	04				length      .byte len("PLOT")
>1a0f9d	d6 d1				name        .word <>TOKEN_TEXT
>1a0f9f	c2 30				eval        .word <>S_PLOT
>1a0fa1	00 00				arity       .word <>0
>1ad1db	4c 49 4e 45 00			TOKEN_TEXT  .null "LINE"
>1a0fa3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fa4	04				length      .byte len("LINE")
>1a0fa5	db d1				name        .word <>TOKEN_TEXT
>1a0fa7	33 31				eval        .word <>S_LINE
>1a0fa9	00 00				arity       .word <>0
>1ad1e0	46 49 4c 4c 00			TOKEN_TEXT  .null "FILL"
>1a0fab	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fac	04				length      .byte len("FILL")
>1a0fad	e0 d1				name        .word <>TOKEN_TEXT
>1a0faf	cc 31				eval        .word <>S_FILL
>1a0fb1	00 00				arity       .word <>0
>1ad1e5	53 50 52 49 54 45 00		TOKEN_TEXT  .null "SPRITE"
>1a0fb3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fb4	06				length      .byte len("SPRITE")
>1a0fb5	e5 d1				name        .word <>TOKEN_TEXT
>1a0fb7	08 33				eval        .word <>S_SPRITE
>1a0fb9	00 00				arity       .word <>0
>1ad1ec	53 50 52 49 54 45 41 54		TOKEN_TEXT  .null "SPRITEAT"
>1ad1f4	00
>1a0fbb	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fbc	08				length      .byte len("SPRITEAT")
>1a0fbd	ec d1				name        .word <>TOKEN_TEXT
>1a0fbf	a6 33				eval        .word <>S_SPRITEAT
>1a0fc1	00 00				arity       .word <>0
>1ad1f5	53 50 52 49 54 45 53 48		TOKEN_TEXT  .null "SPRITESHOW"
>1ad1fd	4f 57 00
>1a0fc3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fc4	0a				length      .byte len("SPRITESHOW")
>1a0fc5	f5 d1				name        .word <>TOKEN_TEXT
>1a0fc7	f4 33				eval        .word <>S_SPRITESHOW
>1a0fc9	00 00				arity       .word <>0
>1ad200	54 49 4c 45 53 45 54 00		TOKEN_TEXT  .null "TILESET"
>1a0fcb	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fcc	07				length      .byte len("TILESET")
>1a0fcd	00 d2				name        .word <>TOKEN_TEXT
>1a0fcf	2b 35				eval        .word <>S_TILESET
>1a0fd1	00 00				arity       .word <>0
>1ad208	54 49 4c 45 4d 41 50 00		TOKEN_TEXT  .null "TILEMAP"
>1a0fd3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fd4	07				length      .byte len("TILEMAP")
>1a0fd5	08 d2				name        .word <>TOKEN_TEXT
>1a0fd7	a9 35				eval        .word <>S_TILEMAP
>1a0fd9	00 00				arity       .word <>0
>1ad210	54 49 4c 45 53 48 4f 57		TOKEN_TEXT  .null "TILESHOW"
>1ad218	00
>1a0fdb	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fdc	08				length      .byte len("TILESHOW")
>1a0fdd	10 d2				name        .word <>TOKEN_TEXT
>1a0fdf	1b 36				eval        .word <>S_TILESHOW
>1a0fe1	00 00				arity       .word <>0
>1ad219	54 49 4c 45 41 54 00		TOKEN_TEXT  .null "TILEAT"
>1a0fe3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fe4	06				length      .byte len("TILEAT")
>1a0fe5	19 d2				name        .word <>TOKEN_TEXT
>1a0fe7	58 36				eval        .word <>S_TILEAT
>1a0fe9	00 00				arity       .word <>0
>1ad220	4d 45 4d 43 4f 50 59 00		TOKEN_TEXT  .null "MEMCOPY"
>1a0feb	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fec	07				length      .byte len("MEMCOPY")
>1a0fed	20 d2				name        .word <>TOKEN_TEXT
>1a0fef	88 39				eval        .word <>S_MEMCOPY
>1a0ff1	00 00				arity       .word <>0
=$e6					TOK_LINEAR = $E6
>1ad228	4c 49 4e 45 41 52 00		TOKEN_TEXT  .null "LINEAR"
>1a0ff3	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0ff4	06				length      .byte len("LINEAR")
>1a0ff5	28 d2				name        .word <>TOKEN_TEXT
>1a0ff7	00 00				eval        .word <>0
>1a0ff9	00 00				arity       .word <>0
=$e7					TOK_RECT = $E7
>1ad22f	52 45 43 54 00			TOKEN_TEXT  .null "RECT"
>1a0ffb	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0ffc	04				length      .byte len("RECT")
>1a0ffd	2f d2				name        .word <>TOKEN_TEXT
>1a0fff	00 00				eval        .word <>0
>1a1001	00 00				arity       .word <>0
>1ad234	4c 4f 43 41 54 45 00		TOKEN_TEXT  .null "LOCATE"
>1a1003	20				precedence  .byte TOK_TY_STMNT | 0
>1a1004	06				length      .byte len("LOCATE")
>1a1005	34 d2				name        .word <>TOKEN_TEXT
>1a1007	9d 3b				eval        .word <>S_LOCATE
>1a1009	00 00				arity       .word <>0
>1ad23b	49 4e 54 00			TOKEN_TEXT  .null "INT"
>1a100b	30				precedence  .byte TOK_TY_FUNC | 0
>1a100c	03				length      .byte len("INT")
>1a100d	3b d2				name        .word <>TOKEN_TEXT
>1a100f	90 4e				eval        .word <>FN_INT
>1a1011	00 00				arity       .word <>0
>1ad23f	52 4e 44 00			TOKEN_TEXT  .null "RND"
>1a1013	30				precedence  .byte TOK_TY_FUNC | 0
>1a1014	03				length      .byte len("RND")
>1a1015	3f d2				name        .word <>TOKEN_TEXT
>1a1017	a3 46				eval        .word <>FN_RND
>1a1019	00 00				arity       .word <>0
>1ad243	53 49 4e 00			TOKEN_TEXT  .null "SIN"
>1a101b	30				precedence  .byte TOK_TY_FUNC | 0
>1a101c	03				length      .byte len("SIN")
>1a101d	43 d2				name        .word <>TOKEN_TEXT
>1a101f	a3 4e				eval        .word <>FN_SIN
>1a1021	00 00				arity       .word <>0
>1ad247	43 4f 53 00			TOKEN_TEXT  .null "COS"
>1a1023	30				precedence  .byte TOK_TY_FUNC | 0
>1a1024	03				length      .byte len("COS")
>1a1025	47 d2				name        .word <>TOKEN_TEXT
>1a1027	b9 4e				eval        .word <>FN_COS
>1a1029	00 00				arity       .word <>0
>1ad24b	54 41 4e 00			TOKEN_TEXT  .null "TAN"
>1a102b	30				precedence  .byte TOK_TY_FUNC | 0
>1a102c	03				length      .byte len("TAN")
>1a102d	4b d2				name        .word <>TOKEN_TEXT
>1a102f	cf 4e				eval        .word <>FN_TAN
>1a1031	00 00				arity       .word <>0
>1ad24f	4c 4e 00			TOKEN_TEXT  .null "LN"
>1a1033	30				precedence  .byte TOK_TY_FUNC | 0
>1a1034	02				length      .byte len("LN")
>1a1035	4f d2				name        .word <>TOKEN_TEXT
>1a1037	e5 4e				eval        .word <>FN_LN
>1a1039	00 00				arity       .word <>0
>1ad252	41 43 4f 53 00			TOKEN_TEXT  .null "ACOS"
>1a103b	30				precedence  .byte TOK_TY_FUNC | 0
>1a103c	04				length      .byte len("ACOS")
>1a103d	52 d2				name        .word <>TOKEN_TEXT
>1a103f	fb 4e				eval        .word <>FN_ACOS
>1a1041	00 00				arity       .word <>0
>1ad257	41 53 49 4e 00			TOKEN_TEXT  .null "ASIN"
>1a1043	30				precedence  .byte TOK_TY_FUNC | 0
>1a1044	04				length      .byte len("ASIN")
>1a1045	57 d2				name        .word <>TOKEN_TEXT
>1a1047	11 4f				eval        .word <>FN_ASIN
>1a1049	00 00				arity       .word <>0
>1ad25c	41 54 41 4e 00			TOKEN_TEXT  .null "ATAN"
>1a104b	30				precedence  .byte TOK_TY_FUNC | 0
>1a104c	04				length      .byte len("ATAN")
>1a104d	5c d2				name        .word <>TOKEN_TEXT
>1a104f	27 4f				eval        .word <>FN_ATAN
>1a1051	00 00				arity       .word <>0
>1ad261	45 58 50 00			TOKEN_TEXT  .null "EXP"
>1a1053	30				precedence  .byte TOK_TY_FUNC | 0
>1a1054	03				length      .byte len("EXP")
>1a1055	61 d2				name        .word <>TOKEN_TEXT
>1a1057	3d 4f				eval        .word <>FN_EXP
>1a1059	00 00				arity       .word <>0
>1ad265	53 51 52 00			TOKEN_TEXT  .null "SQR"
>1a105b	30				precedence  .byte TOK_TY_FUNC | 0
>1a105c	03				length      .byte len("SQR")
>1a105d	65 d2				name        .word <>TOKEN_TEXT
>1a105f	53 4f				eval        .word <>FN_SQR
>1a1061	00 00				arity       .word <>0
>1a1063	00 00 00 00 00 00 00 00		            .word 0, 0, 0, 0

;******  Return to file: src\basic816.s


;******  Processing file: src\heap.s

>08b7					ALLOCATED   .long ?     ; Pointer to the most recently allocated object
>08ba					HEAP        .long ?     ; Pointer to the top of the heap (next empty byte)
>08bd					FREED       .long ?     ; Pointer to a linked list of freed heap objects
>08c0					CURRBLOCK   .long ?     ; Pointer to the current heap allocated block
>08c3					CURRHEADER  .long ?     ; Pointer to the header of the current block
>08c6					CURREND     .long ?     ; Pointer to the byte immediately after the current block
>08c9					CURRFREED   .long ?     ; Pointer to the current freed block
>08cc					FREEDEND    .long ?     ; Pointer to the byte immediately after the current freed block
>08cf					LASTFREED   .long ?     ;
.0000					HEAPOBJ
>0000					TYPE        .byte ?     ; Code for the type of object allocated
>0001					COUNT       .byte ?     ; Number of references to the heap object
>0002					NEXT        .long ?     ; Pointer to the next object in the list (used when freed)
>0005					END         .long ?     ; Pointer to the next byte after the block
.1a106b					INITHEAP
.1a106b	08		php		            PHP
.1a106c	0b		phd		            PHD
.1a106d	08		php		            PHP
.1a106e	c2 20		rep #$20	            REP #$20
.1a1070	48		pha		            PHA
.1a1071	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1074	5b		tcd		            TCD
.1a1075	68		pla		            PLA
.1a1076	28		plp		            PLP
.1a1077	c2 30		rep #$30	            REP #$30
.1a1079	a9 ff ff	lda #$ffff	            LDA #<>HEAP_TOP         ; Set the HEAP to the top
.1a107c	85 ba		sta $08ba	            STA HEAP
.1a107e	e2 20		sep #$20	            SEP #$20
.1a1080	a9 17		lda #$17	            LDA #`HEAP_TOP
.1a1082	85 bc		sta $08bc	            STA HEAP+2
.1a1084	c2 20		rep #$20	            REP #$20
.1a1086	64 b7		stz $08b7	            STZ ALLOCATED           ; And clear the pointer to the allocated objects
.1a1088	64 bd		stz $08bd	            STZ FREED               ; as well as the list of freed objects
.1a108a	e2 20		sep #$20	            SEP #$20
.1a108c	64 b9		stz $08b9	            STZ ALLOCATED+2
.1a108e	64 bf		stz $08bf	            STZ FREED+2
.1a1090	2b		pld		            PLD
.1a1091	28		plp		            PLP
.1a1092	60		rts		            RTS
.1a1093					ALLOC
.1a1093	5a		phy		            PHY
.1a1094	08		php		            PHP
.1a1095	e2 20		sep #$20	            SEP #$20
.1a1097	85 ea		sta $08ea	            STA TOFINDTYPE      ; Save the type of the block to TOFINDTYPE
.1a1099	c2 10		rep #$10	            REP #$10
.1a109b	86 8f		stx $088f	            STX MCOUNT           ; And the length of the block needed to MCOUNT
.1a109d	c2 20		rep #$20	            REP #$20
.1a109f	a5 0e		lda $080e	            LDA SCRATCH+2
.1a10a1	48		pha		            PHA
.1a10a2	a5 0c		lda $080c	            LDA SCRATCH
.1a10a4	48		pha		            PHA
.1a10a5	a5 12		lda $0812	            LDA SCRATCH2+2
.1a10a7	48		pha		            PHA
.1a10a8	a5 10		lda $0810	            LDA SCRATCH2
.1a10aa	48		pha		            PHA
.1a10ab	20 43 11	jsr $1a1143	            JSR ALLOCFREED
.1a10ae	b0 03		bcs $1a10b3	            BCS done            ; Return, if we got something back
.1a10b0	20 c7 10	jsr $1a10c7	            JSR ALLOCHEAP
.1a10b3					done
.1a10b3	20 cf 12	jsr $1a12cf	            JSR HEAP_GETHED
.1a10b6	c2 20		rep #$20	            REP #$20
.1a10b8	68		pla		            PLA
.1a10b9	85 10		sta $0810	            STA SCRATCH2
.1a10bb	68		pla		            PLA
.1a10bc	85 12		sta $0812	            STA SCRATCH2+2
.1a10be	68		pla		            PLA
.1a10bf	85 0c		sta $080c	            STA SCRATCH
.1a10c1	68		pla		            PLA
.1a10c2	85 0e		sta $080e	            STA SCRATCH+2
.1a10c4	28		plp		            PLP
.1a10c5	7a		ply		            PLY
.1a10c6	60		rts		            RTS
.1a10c7					ALLOCHEAP
.1a10c7	08		php		            PHP
.1a10c8	0b		phd		            PHD
.1a10c9	08		php		            PHP
.1a10ca	c2 20		rep #$20	            REP #$20
.1a10cc	48		pha		            PHA
.1a10cd	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a10d0	5b		tcd		            TCD
.1a10d1	68		pla		            PLA
.1a10d2	28		plp		            PLP
.1a10d3	e2 20		sep #$20	            SEP #$20
.1a10d5	a6 8f		ldx $088f	            LDX MCOUNT
.1a10d7	ca		dex		            DEX
.1a10d8	86 0c		stx $080c	            STX SCRATCH             ; SCRATCH := size - 1
.1a10da	e8		inx		            INX
.1a10db	c2 30		rep #$30	            REP #$30
.1a10dd	38		sec		            SEC
.1a10de	a5 ba		lda $08ba	            LDA HEAP
.1a10e0	e5 0c		sbc $080c	            SBC SCRATCH
.1a10e2	85 c0		sta $08c0	            STA CURRBLOCK
.1a10e4	e2 20		sep #$20	            SEP #$20
.1a10e6	a5 bc		lda $08bc	            LDA HEAP+2
.1a10e8	e9 00		sbc #$00	            SBC #0
.1a10ea	85 c2		sta $08c2	            STA CURRBLOCK+2
.1a10ec	20 cf 12	jsr $1a12cf	            JSR HEAP_GETHED
.1a10ef	e2 20		sep #$20	            SEP #$20
.1a10f1	a5 ea		lda $08ea	            LDA TOFINDTYPE
.1a10f3	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE       ; Set the type of the object
.1a10f6	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a10f8	a9 00		lda #$00	            LDA #0                  ; Set the count to zero
.1a10fa	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.1a10fd	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a10ff	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1102	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1104	c2 20		rep #$20	            REP #$20
.1a1106	a9 00 00	lda #$0000	            LDA #0
.1a1109	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a110b	c2 20		rep #$20	            REP #$20
.1a110d	18		clc		            CLC
.1a110e	a5 ba		lda $08ba	            LDA HEAP
.1a1110	69 01 00	adc #$0001	            ADC #1
.1a1113	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; To get the address of the next byte
.1a1116	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y      ; after the block
.1a1118	e2 20		sep #$20	            SEP #$20
.1a111a	c8		iny		            INY
.1a111b	c8		iny		            INY
.1a111c	a5 bc		lda $08bc	            LDA HEAP+2
.1a111e	69 00		adc #$00	            ADC #0
.1a1120	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1122	c2 20		rep #$20	            REP #$20
.1a1124	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a1126	85 b7		sta $08b7	            STA ALLOCATED
.1a1128	e2 20		sep #$20	            SEP #$20
.1a112a	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a112c	85 b9		sta $08b9	            STA ALLOCATED+2
.1a112e	c2 20		rep #$20	            REP #$20
.1a1130	38		sec		            SEC                     ; Move the HEAP pointer to the first free byte under the header
.1a1131	a5 c3		lda $08c3	            LDA CURRHEADER
.1a1133	e9 01 00	sbc #$0001	            SBC #1
.1a1136	85 ba		sta $08ba	            STA HEAP
.1a1138	e2 20		sep #$20	            SEP #$20
.1a113a	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a113c	e9 00		sbc #$00	            SBC #0
.1a113e	85 bc		sta $08bc	            STA HEAP+2
.1a1140	2b		pld		            PLD
.1a1141	28		plp		            PLP
.1a1142	60		rts		            RTS
.1a1143					ALLOCFREED
.1a1143	08		php		            PHP
.1a1144	0b		phd		            PHD
.1a1145	08		php		            PHP
.1a1146	c2 20		rep #$20	            REP #$20
.1a1148	48		pha		            PHA
.1a1149	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a114c	5b		tcd		            TCD
.1a114d	68		pla		            PLA
.1a114e	28		plp		            PLP
.1a114f	c2 30		rep #$30	            REP #$30
.1a1151	c2 20		rep #$20	            REP #$20
.1a1153	a5 bd		lda $08bd	            LDA FREED
.1a1155	85 c9		sta $08c9	            STA CURRFREED
.1a1157	e2 20		sep #$20	            SEP #$20
.1a1159	a5 bf		lda $08bf	            LDA FREED+2
.1a115b	85 cb		sta $08cb	            STA CURRFREED+2
.1a115d	a5 c9		lda $08c9	loop        LDA CURRFREED           ; Has anything been freed?
.1a115f	d0 17		bne $1a1178	            BNE has_block           ; Yes: check to see if there's a big enough block
.1a1161	e2 20		sep #$20	            SEP #$20
.1a1163	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a1165	d0 11		bne $1a1178	            BNE has_block           ; Yes: check to see if there's a big enough block
.1a1167	c2 20		rep #$20	            REP #$20
.1a1169	a9 00 00	lda #$0000	            LDA #<>0
.1a116c	85 cf		sta $08cf	            STA LASTFREED
.1a116e	e2 20		sep #$20	            SEP #$20
.1a1170	a9 00		lda #$00	            LDA #`0
.1a1172	85 d1		sta $08d1	            STA LASTFREED+2
.1a1174	2b		pld		ret_false   PLD                     ; Return that we didn't find anything
.1a1175	28		plp		            PLP
.1a1176	18		clc		            CLC
.1a1177	60		rts		            RTS
.1a1178					has_block
.1a1178	c2 20		rep #$20	            REP #$20
.1a117a	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.1a117d	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a117f	85 cc		sta $08cc	            STA FREEDEND
.1a1181	e2 20		sep #$20	            SEP #$20
.1a1183	c8		iny		            INY
.1a1184	c8		iny		            INY
.1a1185	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1187	85 ce		sta $08ce	            STA FREEDEND+2
.1a1189	c2 20		rep #$20	            REP #$20
.1a118b	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required
.1a118c	a5 c9		lda $08c9	            LDA CURRFREED
.1a118e	65 8f		adc $088f	            ADC MCOUNT
.1a1190	85 0c		sta $080c	            STA SCRATCH
.1a1192	e2 20		sep #$20	            SEP #$20
.1a1194	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a1196	69 00		adc #$00	            ADC #0
.1a1198	85 0e		sta $080e	            STA SCRATCH+2
.1a119a	c2 20		rep #$20	            REP #$20
.1a119c	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required + size of header
.1a119d	a5 0c		lda $080c	            LDA SCRATCH                 ; (that is, it's a pointer to the byte immediately after the block desired)
.1a119f	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)
.1a11a2	85 0c		sta $080c	            STA SCRATCH
.1a11a4	e2 20		sep #$20	            SEP #$20
.1a11a6	a5 0e		lda $080e	            LDA SCRATCH+2
.1a11a8	69 00		adc #$00	            ADC #0
.1a11aa	85 0e		sta $080e	            STA SCRATCH+2
.1a11ac	c2 20		rep #$20	            REP #$20
.1a11ae	a5 0c		lda $080c	            LDA SCRATCH                 ; Is SCRATCH == FREEDEND?
.1a11b0	c5 cc		cmp $08cc	            CMP FREEDEND
.1a11b2	d0 28		bne $1a11dc	            BNE not_exact               ; No: check if this block is bigger than needed
.1a11b4	e2 20		sep #$20	            SEP #$20
.1a11b6	a5 0e		lda $080e	            LDA SCRATCH+2
.1a11b8	c5 ce		cmp $08ce	            CMP FREEDEND+2
.1a11ba	d0 20		bne $1a11dc	            BNE not_exact
.1a11bc	c2 20		rep #$20	            REP #$20
.1a11be	a5 cf		lda $08cf	            LDA LASTFREED               ; LASTFREED == 0?
.1a11c0	d0 5d		bne $1a121f	            BNE adj_last1               ; No: point LASTFREED->NEXT to skip this block
.1a11c2	e2 20		sep #$20	            SEP #$20
.1a11c4	a5 d1		lda $08d1	            LDA LASTFREED+2
.1a11c6	d0 57		bne $1a121f	            BNE adj_last1
.1a11c8	c2 20		rep #$20	            REP #$20
.1a11ca	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a11cd	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a11cf	85 bd		sta $08bd	            STA FREED
.1a11d1	e2 20		sep #$20	            SEP #$20
.1a11d3	c8		iny		            INY
.1a11d4	c8		iny		            INY
.1a11d5	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a11d7	85 bf		sta $08bf	            STA FREED+2
.1a11d9	4c 80 12	jmp $1a1280	            JMP init_block              ; And return CURRFREED as our reallocated memory
.1a11dc					not_exact
.1a11dc	c2 20		rep #$20	            REP #$20
.1a11de	a5 0c		lda $080c	            LDA SCRATCH                 ; Add a buffer to the room needed
.1a11e0	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)          ; So we have room to track the memory still freed
.1a11e3	85 10		sta $0810	            STA SCRATCH2
.1a11e5	e2 20		sep #$20	            SEP #$20
.1a11e7	a5 0e		lda $080e	            LDA SCRATCH+2
.1a11e9	69 00		adc #$00	            ADC #0
.1a11eb	85 12		sta $0812	            STA SCRATCH2+2
.1a11ed	e2 20		sep #$20	            SEP #$20
.1a11ef	a5 c6		lda $08c6	            LDA CURREND                 ; Is CURREND > SCRATCH2
.1a11f1	c5 10		cmp $0810	            CMP SCRATCH2
.1a11f3	b0 3e		bcs $1a1233	            BGE has_room                ; Yes: there is room in this block to allocate some memory
.1a11f5	90 08		bcc $1a11ff	            BLT try_next
.1a11f7	c2 20		rep #$20	            REP #$20
.1a11f9	a5 c6		lda $08c6	            LDA CURREND
.1a11fb	c5 10		cmp $0810	            CMP SCRATCH2
.1a11fd	b0 34		bcs $1a1233	            BGE has_room
.1a11ff					try_next
.1a11ff	c2 20		rep #$20	            REP #$20
.1a1201	a5 c9		lda $08c9	            LDA CURRFREED
.1a1203	85 cf		sta $08cf	            STA LASTFREED
.1a1205	e2 20		sep #$20	            SEP #$20
.1a1207	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a1209	85 d1		sta $08d1	            STA LASTFREED+2
.1a120b	c2 20		rep #$20	            REP #$20
.1a120d	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1210	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.1a1212	85 c9		sta $08c9	            STA CURRFREED
.1a1214	e2 20		sep #$20	            SEP #$20
.1a1216	c8		iny		            INY
.1a1217	c8		iny		            INY
.1a1218	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.1a121a	85 cb		sta $08cb	            STA CURRFREED+2
.1a121c	4c 5d 11	jmp $1a115d	            JMP loop                                    ; And try the next header
.1a121f					adj_last1
.1a121f	c2 20		rep #$20	            REP #$20
.1a1221	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := CURRFREED->NEXT
.1a1224	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1226	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.1a1228	e2 20		sep #$20	            SEP #$20
.1a122a	c8		iny		            INY
.1a122b	c8		iny		            INY
.1a122c	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a122e	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.1a1230	4c 80 12	jmp $1a1280	            JMP init_block              ; And get CURRFREED ready to return
.1a1233					has_room
.1a1233	c2 20		rep #$20	            REP #$20
.1a1235	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END            ; SCRATCH->END := CURRFREED->END
.1a1238	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a123a	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a123c	e2 20		sep #$20	            SEP #$20
.1a123e	c8		iny		            INY
.1a123f	c8		iny		            INY
.1a1240	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1242	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a1244	c2 20		rep #$20	            REP #$20
.1a1246	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; CURREND->NEXT := CURRFREED->NEXT
.1a1249	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a124b	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a124d	e2 20		sep #$20	            SEP #$20
.1a124f	c8		iny		            INY
.1a1250	c8		iny		            INY
.1a1251	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1253	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a1255	c2 20		rep #$20	            REP #$20
.1a1257	a5 cf		lda $08cf	            LDA LASTFREED               ; Is this the first object we've examined?
.1a1259	d0 14		bne $1a126f	            BNE adj_last2               ; No: we'll need to adjust the previously examined block
.1a125b	e2 20		sep #$20	            SEP #$20
.1a125d	a5 cf		lda $08cf	            LDA LASTFREED
.1a125f	d0 0e		bne $1a126f	            BNE adj_last2
.1a1261	c2 20		rep #$20	            REP #$20
.1a1263	a5 0c		lda $080c	            LDA SCRATCH
.1a1265	85 bd		sta $08bd	            STA FREED
.1a1267	e2 20		sep #$20	            SEP #$20
.1a1269	a5 0e		lda $080e	            LDA SCRATCH+2
.1a126b	85 bf		sta $08bf	            STA FREED+2
.1a126d	80 11		bra $1a1280	            BRA init_block              ; ... and return the block we've sliced off
.1a126f					adj_last2
.1a126f	c2 20		rep #$20	            REP #$20
.1a1271	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := SCRATCH
.1a1274	a5 0c		lda $080c	            LDA SCRATCH                 ; (point the previous freed block to the newly sliced
.1a1276	97 cf		sta [$08cf],y	            STA [LASTFREED],Y           ;  off part of the current block)
.1a1278	e2 20		sep #$20	            SEP #$20
.1a127a	c8		iny		            INY
.1a127b	c8		iny		            INY
.1a127c	a5 0e		lda $080e	            LDA SCRATCH+2
.1a127e	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.1a1280					init_block
.1a1280	c2 20		rep #$20	            REP #$20
.1a1282	a5 c9		lda $08c9	            LDA CURRFREED
.1a1284	85 c3		sta $08c3	            STA CURRHEADER
.1a1286	e2 20		sep #$20	            SEP #$20
.1a1288	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a128a	85 c5		sta $08c5	            STA CURRHEADER+2
.1a128c	c2 20		rep #$20	            REP #$20
.1a128e	a5 c3		lda $08c3	            LDA CURRHEADER
.1a1290	85 b7		sta $08b7	            STA ALLOCATED
.1a1292	e2 20		sep #$20	            SEP #$20
.1a1294	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1296	85 b9		sta $08b9	            STA ALLOCATED+2
.1a1298	c2 20		rep #$20	            REP #$20
.1a129a	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; Set CURRHEADER->END to the byte after the block
.1a129d	a5 0c		lda $080c	            LDA SCRATCH
.1a129f	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12a1	e2 20		sep #$20	            SEP #$20
.1a12a3	c8		iny		            INY
.1a12a4	c8		iny		            INY
.1a12a5	a5 0e		lda $080e	            LDA SCRATCH+2
.1a12a7	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12a9	c2 20		rep #$20	            REP #$20
.1a12ab	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Set CURRHEADER->NEXT to NULL
.1a12ae	a9 00 00	lda #$0000	            LDA #0
.1a12b1	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12b3	e2 20		sep #$20	            SEP #$20
.1a12b5	c8		iny		            INY
.1a12b6	c8		iny		            INY
.1a12b7	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12b9	e2 20		sep #$20	            SEP #$20
.1a12bb	a5 ea		lda $08ea	            LDA TOFINDTYPE          ; Get the type code back
.1a12bd	e2 20		sep #$20	            SEP #$20
.1a12bf	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE
.1a12c2	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12c4	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT      ; Set its reference count to 0
.1a12c7	a9 00		lda #$00	            LDA #0
.1a12c9	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12cb	2b		pld		done        PLD
.1a12cc	28		plp		            PLP
.1a12cd	38		sec		            SEC
.1a12ce	60		rts		            RTS
.1a12cf					HEAP_GETHED
.1a12cf	08		php		            PHP
.1a12d0	c2 20		rep #$20	            REP #$20
.1a12d2	38		sec		            SEC
.1a12d3	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a12d5	e9 08 00	sbc #$0008	            SBC #size(HEAPOBJ)
.1a12d8	85 c3		sta $08c3	            STA CURRHEADER
.1a12da	e2 20		sep #$20	            SEP #$20
.1a12dc	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a12de	e9 00		sbc #$00	            SBC #0
.1a12e0	85 c5		sta $08c5	            STA CURRHEADER+2
.1a12e2	28		plp		            PLP
.1a12e3	60		rts		            RTS
.1a12e4					HEAP_ADDREF
.1a12e4	08		php		            PHP
.1a12e5	e2 20		sep #$20	            SEP #$20
.1a12e7	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a12e9	f0 04		beq $1a12ef	            BEQ chk_null
.1a12eb	c9 18		cmp #$18	            CMP #`(HEAP_TOP + 1)
.1a12ed	b0 12		bcs $1a1301	            BGE out_of_bnds
.1a12ef					chk_null
.1a12ef	c2 20		rep #$20	            REP #$20
.1a12f1	a5 c3		lda $08c3	            LDA CURRHEADER
.1a12f3	f0 0c		beq $1a1301	            BEQ out_of_bnds
.1a12f5					is_ok
.1a12f5	e2 20		sep #$20	            SEP #$20
.1a12f7	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.1a12fa	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a12fc	1a		inc a		            INC A
.1a12fd	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12ff	28		plp		            PLP
.1a1300	60		rts		            RTS
.1a1301	00		brk #		out_of_bnds BRK
.1a1302	ea		nop		            NOP
.1a1303					HEAP_REMREF
.1a1303	08		php		            PHP
.1a1304	e2 20		sep #$20	            SEP #$20
.1a1306	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1308	f0 04		beq $1a130e	            BEQ chk_null
.1a130a	c9 18		cmp #$18	            CMP #`(HEAP_TOP + 1)
.1a130c	b0 17		bcs $1a1325	            BGE out_of_bnds
.1a130e					chk_null
.1a130e	c2 20		rep #$20	            REP #$20
.1a1310	a5 c3		lda $08c3	            LDA CURRHEADER
.1a1312	f0 11		beq $1a1325	            BEQ out_of_bnds
.1a1314	e2 20		sep #$20	            SEP #$20
.1a1316	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT  ; Decrement the reference count
.1a1319	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a131b	3a		dec a		            DEC A
.1a131c	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a131e	d0 03		bne $1a1323	            BNE done            ; If it's still >0, we are done
.1a1320	20 27 13	jsr $1a1327	            JSR HEAP_FREE
.1a1323	28		plp		done        PLP
.1a1324	60		rts		            RTS
.1a1325	00		brk #		out_of_bnds BRK
.1a1326	ea		nop		            NOP
.1a1327					HEAP_FREE
.1a1327	08		php		            PHP
.1a1328	c2 20		rep #$20	            REP #$20
.1a132a	a5 bd		lda $08bd	            LDA FREED           ; Check to see if blocks are already on the freed list
.1a132c	d0 21		bne $1a134f	            BNE has_objects
.1a132e	e2 20		sep #$20	            SEP #$20
.1a1330	a5 bf		lda $08bf	            LDA FREED+2
.1a1332	d0 1b		bne $1a134f	            BNE has_objects
.1a1334	a5 c5		lda $08c5	            LDA CURRHEADER+2    ; No: this block is the first one
.1a1336	85 bf		sta $08bf	            STA FREED+2         ; Just make it the freed list
.1a1338	c2 20		rep #$20	            REP #$20
.1a133a	a5 c3		lda $08c3	            LDA CURRHEADER
.1a133c	85 bd		sta $08bd	            STA FREED
.1a133e	a9 00 00	lda #$0000	            LDA #0
.1a1341	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT   ; And clear its next link
.1a1344	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1346	c8		iny		            INY
.1a1347	c8		iny		            INY
.1a1348	e2 20		sep #$20	            SEP #$20
.1a134a	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a134c	4c 0e 14	jmp $1a140e	            JMP done
.1a134f					has_objects
.1a134f	e2 20		sep #$20	            SEP #$20
.1a1351	a5 bf		lda $08bf	            LDA FREED+2
.1a1353	c5 c5		cmp $08c5	            CMP CURRHEADER+2
.1a1355	90 28		bcc $1a137f	            BLT start_scan
.1a1357	c2 20		rep #$20	            REP #$20
.1a1359	a5 bd		lda $08bd	            LDA FREED
.1a135b	c5 c3		cmp $08c3	            CMP CURRHEADER
.1a135d	90 20		bcc $1a137f	            BLT start_scan
.1a135f					ins_first
.1a135f	c2 20		rep #$20	            REP #$20
.1a1361	a5 bd		lda $08bd	            LDA FREED               ; CURRHEADER->NEXT := FREED
.1a1363	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1366	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1368	e2 20		sep #$20	            SEP #$20
.1a136a	c8		iny		            INY
.1a136b	c8		iny		            INY
.1a136c	a5 bf		lda $08bf	            LDA FREED+2
.1a136e	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1370	c2 20		rep #$20	            REP #$20
.1a1372	a5 c3		lda $08c3	            LDA CURRHEADER
.1a1374	85 bd		sta $08bd	            STA FREED
.1a1376	e2 20		sep #$20	            SEP #$20
.1a1378	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a137a	85 bf		sta $08bf	            STA FREED+2
.1a137c	4c 0e 14	jmp $1a140e	            JMP done
.1a137f					start_scan
.1a137f	c2 20		rep #$20	            REP #$20
.1a1381	a5 bd		lda $08bd	            LDA FREED
.1a1383	85 08		sta $0808	            STA INDEX
.1a1385	e2 20		sep #$20	            SEP #$20
.1a1387	a5 bf		lda $08bf	            LDA FREED+2
.1a1389	85 0a		sta $080a	            STA INDEX+2
.1a138b					loop
.1a138b	e2 20		sep #$20	            SEP #$20
.1a138d	a0 04 00	ldy #$0004	            LDY #HEAPOBJ.NEXT+2
.1a1390	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a1392	c5 c8		cmp $08c8	            CMP CURREND+2
.1a1394	90 32		bcc $1a13c8	            BLT go_next             ; No: check the next spot
.1a1396	d0 0b		bne $1a13a3	            BNE ins_next
.1a1398	c2 20		rep #$20	            REP #$20
.1a139a	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a139d	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a139f	c5 c6		cmp $08c6	            CMP CURREND
.1a13a1	90 25		bcc $1a13c8	            BLT go_next             ; No: check the next spot
.1a13a3					ins_next
.1a13a3	c2 20		rep #$20	            REP #$20
.1a13a5	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := INDEX->NEXT
.1a13a8	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a13aa	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a13ac	e2 20		sep #$20	            SEP #$20
.1a13ae	c8		iny		            INY
.1a13af	c8		iny		            INY
.1a13b0	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a13b2	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a13b4	c2 20		rep #$20	            REP #$20
.1a13b6	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.1a13b8	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a13bb	97 08		sta [$0808],y	            STA [INDEX],Y
.1a13bd	e2 20		sep #$20	            SEP #$20
.1a13bf	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a13c1	c8		iny		            INY
.1a13c2	c8		iny		            INY
.1a13c3	97 08		sta [$0808],y	            STA [INDEX],Y
.1a13c5	4c 0e 14	jmp $1a140e	            JMP done
.1a13c8					go_next
.1a13c8	c2 20		rep #$20	            REP #$20
.1a13ca	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Is INDEX->NEXT = 0
.1a13cd	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a13cf	d0 08		bne $1a13d9	            BNE not_at_end          ; No: load up the next object
.1a13d1	e2 20		sep #$20	            SEP #$20
.1a13d3	c8		iny		            INY
.1a13d4	c8		iny		            INY
.1a13d5	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a13d7	f0 19		beq $1a13f2	            BEQ at_end
.1a13d9					not_at_end
.1a13d9	c2 20		rep #$20	            REP #$20
.1a13db	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; INDEX := INDEX->NEXT
.1a13de	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a13e0	85 0c		sta $080c	            STA SCRATCH
.1a13e2	e2 20		sep #$20	            SEP #$20
.1a13e4	c8		iny		            INY
.1a13e5	c8		iny		            INY
.1a13e6	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a13e8	85 0a		sta $080a	            STA INDEX+2
.1a13ea	c2 20		rep #$20	            REP #$20
.1a13ec	a5 0c		lda $080c	            LDA SCRATCH
.1a13ee	85 08		sta $0808	            STA INDEX
.1a13f0	80 99		bra $1a138b	            BRA loop
.1a13f2					at_end
.1a13f2	c2 20		rep #$20	            REP #$20
.1a13f4	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.1a13f6	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a13f9	97 08		sta [$0808],y	            STA [INDEX],Y
.1a13fb	e2 20		sep #$20	            SEP #$20
.1a13fd	c8		iny		            INY
.1a13fe	c8		iny		            INY
.1a13ff	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1401	97 08		sta [$0808],y	            STA [INDEX],Y
.1a1403	a9 00		lda #$00	            LDA #0                  ; CURRHEADER->NEXT := 0
.1a1405	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1407	c2 20		rep #$20	            REP #$20
.1a1409	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a140c	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a140e					done
.1a140e	20 13 14	jsr $1a1413	            JSR COALLESCE
.1a1411	28		plp		            PLP
.1a1412	60		rts		            RTS
.1a1413					COALLESCE
.1a1413	08		php		            PHP
.1a1414	c2 20		rep #$20	            REP #$20
.1a1416	a5 bd		lda $08bd	            LDA FREED
.1a1418	85 c3		sta $08c3	            STA CURRHEADER
.1a141a	e2 20		sep #$20	            SEP #$20
.1a141c	a5 bf		lda $08bf	            LDA FREED+2
.1a141e	85 c5		sta $08c5	            STA CURRHEADER+2
.1a1420					next_head
.1a1420	c2 20		rep #$20	            REP #$20
.1a1422	a5 c3		lda $08c3	            LDA CURRHEADER          ; Is CURRHEADER == 0?
.1a1424	d0 09		bne $1a142f	            BNE check_next          ; No: check if NEXT is contiguous
.1a1426	e2 20		sep #$20	            SEP #$20
.1a1428	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a142a	d0 03		bne $1a142f	            BNE check_next
.1a142c	4c b6 14	jmp $1a14b6	            JMP done                ; Yes: we're done
.1a142f					check_next
.1a142f	c2 20		rep #$20	            REP #$20
.1a1431	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1434	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1436	85 0c		sta $080c	            STA SCRATCH
.1a1438	e2 20		sep #$20	            SEP #$20
.1a143a	c8		iny		            INY
.1a143b	c8		iny		            INY
.1a143c	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a143e	85 0e		sta $080e	            STA SCRATCH+2
.1a1440	c2 20		rep #$20	            REP #$20
.1a1442	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.1a1445	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1447	85 10		sta $0810	            STA SCRATCH2
.1a1449	e2 20		sep #$20	            SEP #$20
.1a144b	c8		iny		            INY
.1a144c	c8		iny		            INY
.1a144d	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a144f	85 12		sta $0812	            STA SCRATCH2+2
.1a1451	c2 20		rep #$20	            REP #$20
.1a1453	a5 0c		lda $080c	            LDA SCRATCH
.1a1455	c5 10		cmp $0810	            CMP SCRATCH2            ; Is CURRHEADER->END = CURRHEADER->NEXT?
.1a1457	d0 08		bne $1a1461	            BNE go_next             ; No: go to the next block
.1a1459	e2 20		sep #$20	            SEP #$20
.1a145b	a5 0e		lda $080e	            LDA SCRATCH+2
.1a145d	c5 12		cmp $0812	            CMP SCRATCH2+2
.1a145f	f0 1f		beq $1a1480	            BEQ combine             ; Yes: combine the two blocks
.1a1461					go_next
.1a1461	c2 20		rep #$20	            REP #$20
.1a1463	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1466	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1468	85 0c		sta $080c	            STA SCRATCH
.1a146a	e2 20		sep #$20	            SEP #$20
.1a146c	c8		iny		            INY
.1a146d	c8		iny		            INY
.1a146e	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1470	85 0e		sta $080e	            STA SCRATCH+2
.1a1472	c2 20		rep #$20	            REP #$20
.1a1474	a5 0c		lda $080c	            LDA SCRATCH
.1a1476	85 c3		sta $08c3	            STA CURRHEADER
.1a1478	e2 20		sep #$20	            SEP #$20
.1a147a	a5 0e		lda $080e	            LDA SCRATCH+2
.1a147c	85 c5		sta $08c5	            STA CURRHEADER+2
.1a147e	80 a0		bra $1a1420	            BRA next_head                               ; And loop back to next_head
.1a1480					combine
.1a1480	c2 20		rep #$20	            REP #$20
.1a1482	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1485	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1487	85 0c		sta $080c	            STA SCRATCH
.1a1489	e2 20		sep #$20	            SEP #$20
.1a148b	c8		iny		            INY
.1a148c	c8		iny		            INY
.1a148d	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a148f	85 0e		sta $080e	            STA SCRATCH+2
.1a1491	c2 20		rep #$20	            REP #$20
.1a1493	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := SCRATCH->NEXT
.1a1496	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a1498	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a149a	e2 20		sep #$20	            SEP #$20
.1a149c	c8		iny		            INY
.1a149d	c8		iny		            INY
.1a149e	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a14a0	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a14a2	c2 20		rep #$20	            REP #$20
.1a14a4	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END       ; CURRHEADER->END := SCRATCH->END
.1a14a7	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a14a9	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a14ab	e2 20		sep #$20	            SEP #$20
.1a14ad	c8		iny		            INY
.1a14ae	c8		iny		            INY
.1a14af	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a14b1	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a14b3	4c 2f 14	jmp $1a142f	            JMP check_next          ; And loop back to check_next
.1a14b6	28		plp		done        PLP
.1a14b7	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\strings.s

.1a14b8					CLRTMPSTR
.1a14b8	08		php		            PHP
.1a14b9	c2 20		rep #$20	            REP #$20
.1a14bb	64 16		stz $0816	            STZ STRPTR
.1a14bd	64 18		stz $0818	            STZ STRPTR+2
.1a14bf	28		plp		            PLP
.1a14c0	60		rts		            RTS
.1a14c1					TEMPSTRING
.1a14c1	08		php		            PHP
.1a14c2	c2 30		rep #$30	            REP #$30
.1a14c4	a5 16		lda $0816	            LDA STRPTR          ; Is STRPTR == 0?
.1a14c6	d0 16		bne $1a14de	            BNE add_256         ; No: add 256 to it
.1a14c8	a5 18		lda $0818	            LDA STRPTR+2
.1a14ca	d0 12		bne $1a14de	            BNE add_256
.1a14cc	e2 20		sep #$20	            SEP #$20
.1a14ce	64 16		stz $0816	            STZ STRPTR
.1a14d0	a5 e2		lda $08e2	            LDA NEXTVAR+1
.1a14d2	1a		inc a		            INC A
.1a14d3	1a		inc a		            INC A
.1a14d4	85 17		sta $0817	            STA STRPTR+1
.1a14d6	a5 e3		lda $08e3	            LDA NEXTVAR+2
.1a14d8	85 18		sta $0818	            STA STRPTR+2
.1a14da	64 19		stz $0819	            STZ STRPTR+3
.1a14dc	80 07		bra $1a14e5	            BRA chk_room
.1a14de					add_256
.1a14de	c2 20		rep #$20	            REP #$20
.1a14e0	a5 17		lda $0817	            LDA STRPTR+1        ; There was already a temporary string...
.1a14e2	1a		inc a		            INC A               ; Leave 256 bytes for it
.1a14e3	85 17		sta $0817	            STA STRPTR+1
.1a14e5					chk_room
.1a14e5	c2 20		rep #$20	            REP #$20
.1a14e7	a5 bb		lda $08bb	            LDA HEAP+1          ; Check to make sure that STRPTR and HEAP haven't touched
.1a14e9	3a		dec a		            DEC A
.1a14ea	c5 17		cmp $0817	            CMP STRPTR+1
.1a14ec	f0 02		beq $1a14f0	            BEQ no_room         ; If they have, throw an error
.1a14ee	b0 1f		bcs $1a150f	            BGE done
.1a14f0					no_room
.1a14f0	08		php		            PHP
.1a14f1	c2 20		rep #$20	            REP #$20
.1a14f3	48		pha		            PHA
.1a14f4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a14f7	5b		tcd		            TCD
.1a14f8	68		pla		            PLA
.1a14f9	28		plp		            PLP
.1a14fa	e2 20		sep #$20	            SEP #$20
.1a14fc	a9 03		lda #$03	            LDA #ERR_MEMORY
.1a14fe	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1502	c2 20		rep #$20	            REP #$20
.1a1504	29 ff 00	and #$00ff	            AND #$00FF
.1a1507	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a150a	e2 20		sep #$20	            SEP #$20
.1a150c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a150f	28		plp		done        PLP
.1a1510	60		rts		            RTS
.1a1511					ITOS_DIGIT
.1a1511	c9 00		cmp #$00	            CMP #0          ; Is it 0?
.1a1513	d0 05		bne $1a151a	            BNE add_digit   ; No: go ahead and add it
.1a1515	c0 01 00	cpy #$0001	            CPY #1          ; Are we on the first digit?
.1a1518	f0 05		beq $1a151f	            BEQ done        ; Yes: ignore this leading 0
.1a151a	09 30		ora #$30	add_digit   ORA #$30        ; Convert it to ASCII
.1a151c	97 16		sta [$0816],y	            STA [STRPTR],Y  ; Save it to the string
.1a151e	c8		iny		            INY             ; And point to the next location
.1a151f					done
.1a151f	60		rts		            RTS
.1a1520					ITOS
.1a1520	08		php		            PHP
.1a1521	c2 30		rep #$30	            REP #$30
.1a1523	64 0c		stz $080c	            STZ SCRATCH         ; Use scratch to store if negative
.1a1525	a5 25		lda $0825	            LDA ARGUMENT1+2     ; Check to see if the number is negative
.1a1527	10 1a		bpl $1a1543	            BPL start_cnvt
.1a1529	18		clc		            CLC                 ; Yes: make ARGUMENT1 positive
.1a152a	a5 23		lda $0823	            LDA ARGUMENT1
.1a152c	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a152f	69 01 00	adc #$0001	            ADC #1
.1a1532	85 23		sta $0823	            STA ARGUMENT1
.1a1534	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a1536	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a1539	69 00 00	adc #$0000	            ADC #0
.1a153c	85 25		sta $0825	            STA ARGUMENT1+2
.1a153e	a9 ff ff	lda #$ffff	            LDA #$FFFF          ; Record that the number was negative
.1a1541	85 0c		sta $080c	            STA SCRATCH
.1a1543					start_cnvt
.1a1543	64 10		stz $0810	            STZ SCRATCH2        ; SCRATCH2 will be our BCD version of the number
.1a1545	64 12		stz $0812	            STZ SCRATCH2+2
.1a1547	64 14		stz $0814	            STZ SCRATCH2+4
.1a1549	a2 1f 00	ldx #$001f	            LDX #31
.1a154c	f8		sed		            SED                 ; Yes, we're really using BCD mode
.1a154d	06 23		asl $0823	shift_loop  ASL ARGUMENT1       ; Shift ARGUMENT1 left one bit
.1a154f	26 25		rol $0825	            ROL ARGUMENT1+2
.1a1551	a5 10		lda $0810	            LDA SCRATCH2        ; SCRATCH2 := SCRATCH2 + SCRATCH2 + Carry
.1a1553	65 10		adc $0810	            ADC SCRATCH2
.1a1555	85 10		sta $0810	            STA SCRATCH2
.1a1557	a5 12		lda $0812	            LDA SCRATCH2+2
.1a1559	65 12		adc $0812	            ADC SCRATCH2+2
.1a155b	85 12		sta $0812	            STA SCRATCH2+2
.1a155d	a5 14		lda $0814	            LDA SCRATCH2+4
.1a155f	65 14		adc $0814	            ADC SCRATCH2+4
.1a1561	85 14		sta $0814	            STA SCRATCH2+4
.1a1563	ca		dex		            DEX
.1a1564	10 e7		bpl $1a154d	            BPL shift_loop      ; Loop through all 32 bits of ARGUMENT1
.1a1566	d8		cld		            CLD                 ; Switch back out of BCD mode
.1a1567	e2 20		sep #$20	            SEP #$20
.1a1569	20 c1 14	jsr $1a14c1	            JSR TEMPSTRING
.1a156c	a0 00 00	ldy #$0000	            LDY #0              ; Y will be index into the temporary string
.1a156f	a5 0c		lda $080c	            LDA SCRATCH         ; Check to see if the number was negative
.1a1571	f0 04		beq $1a1577	            BEQ is_pos          ; No: write a leading space
.1a1573	a9 2d		lda #$2d	            LDA #'-'            ; If negative, write the minus sign
.1a1575	80 02		bra $1a1579	            BRA wr_lead
.1a1577	a9 20		lda #$20	is_pos      LDA #CHAR_SP        ; Write a leading space
.1a1579	97 16		sta [$0816],y	wr_lead     STA [STRPTR],Y
.1a157b	c8		iny		            INY
.1a157c	a2 05 00	ldx #$0005	            LDX #5
.1a157f	b5 10		lda $0810,x	ascii_loop  LDA SCRATCH2,X
.1a1581	29 f0		and #$f0	            AND #$F0
.1a1583	4a		lsr a		            LSR A
.1a1584	4a		lsr a		            LSR A
.1a1585	4a		lsr a		            LSR A
.1a1586	4a		lsr a		            LSR A
.1a1587	20 11 15	jsr $1a1511	            JSR ITOS_DIGIT
.1a158a	b5 10		lda $0810,x	            LDA SCRATCH2,X
.1a158c	29 0f		and #$0f	            AND #$0F
.1a158e	20 11 15	jsr $1a1511	            JSR ITOS_DIGIT
.1a1591	ca		dex		            DEX
.1a1592	10 eb		bpl $1a157f	            BPL ascii_loop
.1a1594	c0 01 00	cpy #$0001	            CPY #1              ; Did we write anything?
.1a1597	d0 0c		bne $1a15a5	            BNE null_term       ; Yes: add a NULL to terminate
.1a1599	a9 20		lda #$20	            LDA #' '            ; No: write a " 0" to the string
.1a159b	87 16		sta [$0816]	            STA [STRPTR]
.1a159d	a0 01 00	ldy #$0001	            LDY #1
.1a15a0	a9 30		lda #$30	            LDA #'0'
.1a15a2	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a15a4	c8		iny		            INY
.1a15a5	a9 00		lda #$00	null_term   LDA #0
.1a15a7	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And terminate the string
.1a15a9	28		plp		done        PLP
.1a15aa	60		rts		            RTS
.1a15ab	00		brk #		fault       BRK
.1a15ac	ea		nop		            NOP
.1a15ad					STRLEN
.1a15ad	08		php		            PHP
.1a15ae	e2 20		sep #$20	            SEP #$20
.1a15b0	c2 10		rep #$10	            REP #$10
.1a15b2	a0 00 00	ldy #$0000	            LDY #0
.1a15b5	bd 00 00	lda $1a0000,x	loop        LDA #0,B,X
.1a15b8	f0 04		beq $1a15be	            BEQ done
.1a15ba	e8		inx		            INX
.1a15bb	c8		iny		            INY
.1a15bc	80 f7		bra $1a15b5	            BRA loop
.1a15be	28		plp		done        PLP
.1a15bf	60		rts		            RTS
.1a15c0					STRCMP
.1a15c0	08		php		            PHP
.1a15c1	0b		phd		            PHD
.1a15c2	08		php		            PHP
.1a15c3	c2 20		rep #$20	            REP #$20
.1a15c5	48		pha		            PHA
.1a15c6	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a15c9	5b		tcd		            TCD
.1a15ca	68		pla		            PLA
.1a15cb	28		plp		            PLP
.1a15cc	e2 20		sep #$20	            SEP #$20
.1a15ce	c2 10		rep #$10	            REP #$10
.1a15d0	a0 00 00	ldy #$0000	            LDY #0
.1a15d3	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Check if the character 1 is 0
.1a15d5	d0 04		bne $1a15db	            BNE comp_mag            ; If not, check the magnitudes
.1a15d7	b7 29		lda [$0829],y	            LDA [ARGUMENT2],Y       ; If so, check if the character 2 is 0
.1a15d9	f0 25		beq $1a1600	            BEQ are_equal           ; If so, the strings are equal
.1a15db	b7 23		lda [$0823],y	comp_mag    LDA [ARGUMENT1],Y       ; Otherwise, get character 1 again
.1a15dd	d7 29		cmp [$0829],y	            CMP [ARGUMENT2],Y       ; And compare it to character 2
.1a15df	90 12		bcc $1a15f3	            BLT is_less             ; Check if character 1 < character 2
.1a15e1	d0 03		bne $1a15e6	            BNE is_greater          ; Check if character 1 > character 2
.1a15e3	c8		iny		            INY                     ; Equal so far... so go to the next pair of characters
.1a15e4	80 ed		bra $1a15d3	            BRA loop
.1a15e6					is_greater
.1a15e6	c2 20		rep #$20	            REP #$20
.1a15e8	a9 01 00	lda #$0001	            LDA #1                  ; So return 1
.1a15eb	85 23		sta $0823	            STA ARGUMENT1
.1a15ed	e2 20		sep #$20	            SEP #$20
.1a15ef	64 25		stz $0825	            STZ ARGUMENT1+2
.1a15f1	80 15		bra $1a1608	            BRA done
.1a15f3					is_less
.1a15f3	c2 20		rep #$20	            REP #$20
.1a15f5	a9 ff ff	lda #$ffff	            LDA #$FFFF              ; So return -1
.1a15f8	85 23		sta $0823	            STA ARGUMENT1
.1a15fa	e2 20		sep #$20	            SEP #$20
.1a15fc	85 25		sta $0825	            STA ARGUMENT1+2
.1a15fe	80 08		bra $1a1608	            BRA done
.1a1600					are_equal
.1a1600	c2 20		rep #$20	            REP #$20
.1a1602	64 23		stz $0823	            STZ ARGUMENT1           ; So return 0
.1a1604	e2 20		sep #$20	            SEP #$20
.1a1606	64 25		stz $0825	            STZ ARGUMENT1+2
.1a1608					done
.1a1608	e2 20		sep #$20	            SEP #$20
.1a160a	a9 00		lda #$00	            LDA #TYPE_INTEGER
.1a160c	85 27		sta $0827	            STA ARGTYPE1
.1a160e	2b		pld		            PLD
.1a160f	28		plp		            PLP
.1a1610	60		rts		            RTS
.1a1611					STRCONCAT
.1a1611	08		php		            PHP
.1a1612	0b		phd		            PHD
.1a1613	8b		phb		            PHB
.1a1614	08		php		            PHP
.1a1615	c2 20		rep #$20	            REP #$20
.1a1617	48		pha		            PHA
.1a1618	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a161b	5b		tcd		            TCD
.1a161c	68		pla		            PLA
.1a161d	28		plp		            PLP
.1a161e	e2 20		sep #$20	            SEP #$20
.1a1620	c2 10		rep #$10	            REP #$10
.1a1622	08		php		            PHP
.1a1623	c2 20		rep #$20	            REP #$20
.1a1625	48		pha		            PHA
.1a1626	e2 20		sep #$20	            SEP #$20
.1a1628	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a162a	48		pha		            PHA
.1a162b	ab		plb		            PLB
.1a162c	c2 20		rep #$20	            REP #$20
.1a162e	68		pla		            PLA
.1a162f	28		plp		            PLP
.1a1630	a6 23		ldx $0823	            LDX ARGUMENT1
.1a1632	20 ad 15	jsr $1a15ad	            JSR STRLEN
.1a1635	84 0c		sty $080c	            STY SCRATCH
.1a1637	08		php		            PHP
.1a1638	c2 20		rep #$20	            REP #$20
.1a163a	48		pha		            PHA
.1a163b	e2 20		sep #$20	            SEP #$20
.1a163d	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a163f	48		pha		            PHA
.1a1640	ab		plb		            PLB
.1a1641	c2 20		rep #$20	            REP #$20
.1a1643	68		pla		            PLA
.1a1644	28		plp		            PLP
.1a1645	a6 29		ldx $0829	            LDX ARGUMENT2
.1a1647	20 ad 15	jsr $1a15ad	            JSR STRLEN
.1a164a	c2 20		rep #$20	            REP #$20
.1a164c	98		tya		            TYA
.1a164d	38		sec		            SEC                     ; X := LEN(ARGUMENT1) + LEN(ARGUMENT2) + 1
.1a164e	65 0c		adc $080c	            ADC SCRATCH
.1a1650	aa		tax		            TAX
.1a1651	e2 20		sep #$20	            SEP #$20
.1a1653	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set type to STRING
.1a1655	20 93 10	jsr $1a1093	            JSR ALLOC
.1a1658	c2 20		rep #$20	            REP #$20
.1a165a	a5 b7		lda $08b7	            LDA ALLOCATED           ; INDEX := pointer to the string
.1a165c	85 08		sta $0808	            STA INDEX
.1a165e	e2 20		sep #$20	            SEP #$20
.1a1660	a5 b9		lda $08b9	            LDA ALLOCATED+2
.1a1662	85 0a		sta $080a	            STA INDEX+2
.1a1664	a0 00 00	ldy #$0000	            LDY #0                  ; Set the target index to the beginning
.1a1667	08		php		            PHP
.1a1668	c2 20		rep #$20	            REP #$20
.1a166a	48		pha		            PHA
.1a166b	e2 20		sep #$20	            SEP #$20
.1a166d	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a166f	48		pha		            PHA
.1a1670	ab		plb		            PLB
.1a1671	c2 20		rep #$20	            REP #$20
.1a1673	68		pla		            PLA
.1a1674	28		plp		            PLP
.1a1675	a6 23		ldx $0823	            LDX ARGUMENT1
.1a1677	bd 00 00	lda $1a0000,x	loop1       LDA #0,B,X              ; Get the Xth byte of ARGUMENT1
.1a167a	f0 06		beq $1a1682	            BEQ copy_2              ; Is it null? Yes: move on to the next string
.1a167c	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.1a167e	e8		inx		            INX                     ; Point to the next characters
.1a167f	c8		iny		            INY
.1a1680	80 f5		bra $1a1677	            BRA loop1               ; And do again
.1a1682					copy_2
.1a1682	e2 20		sep #$20	            SEP #$20
.1a1684	08		php		            PHP
.1a1685	c2 20		rep #$20	            REP #$20
.1a1687	48		pha		            PHA
.1a1688	e2 20		sep #$20	            SEP #$20
.1a168a	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a168c	48		pha		            PHA
.1a168d	ab		plb		            PLB
.1a168e	c2 20		rep #$20	            REP #$20
.1a1690	68		pla		            PLA
.1a1691	28		plp		            PLP
.1a1692	a6 29		ldx $0829	            LDX ARGUMENT2
.1a1694	bd 00 00	lda $1a0000,x	loop2       LDA #0,B,X              ; Get the Xth byte of ARGUMENT2
.1a1697	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.1a1699	f0 04		beq $1a169f	            BEQ terminate           ; Is it null? Yes: move on to the next string
.1a169b	e8		inx		            INX                     ; Point to the next characters
.1a169c	c8		iny		            INY
.1a169d	80 f5		bra $1a1694	            BRA loop2               ; And do again
.1a169f					terminate
.1a169f	c2 20		rep #$20	            REP #$20
.1a16a1	a5 08		lda $0808	            LDA INDEX               ; Set ARGUMENT1 to the new string
.1a16a3	85 23		sta $0823	            STA ARGUMENT1
.1a16a5	e2 20		sep #$20	            SEP #$20
.1a16a7	a5 0a		lda $080a	            LDA INDEX+2
.1a16a9	85 25		sta $0825	            STA ARGUMENT1+2
.1a16ab	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set ARGUMENT1's type to STRING
.1a16ad	85 27		sta $0827	            STA ARGTYPE1
.1a16af	ab		plb		            PLB
.1a16b0	2b		pld		            PLD
.1a16b1	28		plp		            PLP
.1a16b2	60		rts		            RTS
.1a16b3					STRCPY
.1a16b3	da		phx		            PHX
.1a16b4	5a		phy		            PHY
.1a16b5	08		php		            PHP
.1a16b6	0b		phd		            PHD
.1a16b7	8b		phb		            PHB
.1a16b8	08		php		            PHP
.1a16b9	c2 20		rep #$20	            REP #$20
.1a16bb	48		pha		            PHA
.1a16bc	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a16bf	5b		tcd		            TCD
.1a16c0	68		pla		            PLA
.1a16c1	28		plp		            PLP
.1a16c2	c2 20		rep #$20	            REP #$20
.1a16c4	a5 0a		lda $080a	            LDA INDEX+2
.1a16c6	48		pha		            PHA
.1a16c7	a5 08		lda $0808	            LDA INDEX
.1a16c9	48		pha		            PHA
.1a16ca	c2 30		rep #$30	            REP #$30
.1a16cc	08		php		            PHP
.1a16cd	c2 20		rep #$20	            REP #$20
.1a16cf	48		pha		            PHA
.1a16d0	e2 20		sep #$20	            SEP #$20
.1a16d2	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a16d4	48		pha		            PHA
.1a16d5	ab		plb		            PLB
.1a16d6	c2 20		rep #$20	            REP #$20
.1a16d8	68		pla		            PLA
.1a16d9	28		plp		            PLP
.1a16da	a6 23		ldx $0823	            LDX ARGUMENT1
.1a16dc	20 ad 15	jsr $1a15ad	            JSR STRLEN
.1a16df	98		tya		            TYA
.1a16e0	aa		tax		            TAX
.1a16e1	e8		inx		            INX                     ; Put length of string (plus NUL) in X
.1a16e2	e2 20		sep #$20	            SEP #$20
.1a16e4	a9 02		lda #$02	            LDA #TYPE_STRING
.1a16e6	20 93 10	jsr $1a1093	            JSR ALLOC
.1a16e9	c2 20		rep #$20	            REP #$20
.1a16eb	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a16ed	85 08		sta $0808	            STA INDEX
.1a16ef	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a16f1	85 0a		sta $080a	            STA INDEX+2
.1a16f3	a0 00 00	ldy #$0000	            LDY #0
.1a16f6	e2 20		sep #$20	            SEP #$20
.1a16f8	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Copy the data to the allocated string
.1a16fa	97 08		sta [$0808],y	            STA [INDEX],Y
.1a16fc	f0 03		beq $1a1701	            BEQ ret_copy
.1a16fe	c8		iny		            INY
.1a16ff	80 f7		bra $1a16f8	            BRA loop
.1a1701					ret_copy
.1a1701	c2 20		rep #$20	            REP #$20
.1a1703	a5 08		lda $0808	            LDA INDEX
.1a1705	85 23		sta $0823	            STA ARGUMENT1
.1a1707	a5 0a		lda $080a	            LDA INDEX+2
.1a1709	85 25		sta $0825	            STA ARGUMENT1+2
.1a170b	c2 20		rep #$20	            REP #$20
.1a170d	68		pla		            PLA
.1a170e	85 08		sta $0808	            STA INDEX
.1a1710	68		pla		            PLA
.1a1711	85 0a		sta $080a	            STA INDEX+2
.1a1713	ab		plb		            PLB
.1a1714	2b		pld		            PLD
.1a1715	28		plp		            PLP
.1a1716	7a		ply		            PLY
.1a1717	fa		plx		            PLX
.1a1718	60		rts		            RTS
.1a1719					STRSUBSTR
.1a1719	08		php		            PHP
.1a171a	e2 20		sep #$20	            SEP #$20
.1a171c	c2 10		rep #$10	            REP #$10
.1a171e	a0 00 00	ldy #$0000	            LDY #0
.1a1721	b7 23		lda [$0823],y	count_loop  LDA [ARGUMENT1],Y
.1a1723	f0 05		beq $1a172a	            BEQ counted
.1a1725	c8		iny		            INY
.1a1726	80 f9		bra $1a1721	            BRA count_loop
.1a1728	84 92		sty $0892	            STY MTEMP               ; MTEMP := length of the source string
.1a172a					counted
.1a172a	c2 30		rep #$30	            REP #$30
.1a172c	c4 29		cpy $0829	            CPY ARGUMENT2           ; length of string <= index?
.1a172e	90 13		bcc $1a1743	            BLT ret_empty           ; Yes: return empty string
.1a1730	f0 11		beq $1a1743	            BEQ ret_empty
.1a1732	a5 8f		lda $088f	            LDA MCOUNT              ; Is the desired count <= 0?
.1a1734	30 0d		bmi $1a1743	            BMI ret_empty
.1a1736	f0 0b		beq $1a1743	            BEQ ret_empty           ; Yes: return the empty string
.1a1738	c4 8f		cpy $088f	            CPY MCOUNT              ; Is the desired length < the length of the source?
.1a173a	b0 12		bcs $1a174e	            BGE do_slice            ; Yes: go ahead and get the substring
.1a173c	a5 29		lda $0829	            LDA ARGUMENT2           ; Is INDEX == 0?
.1a173e	d0 0e		bne $1a174e	            BNE do_slice            ; No: do a slice
.1a1740	4c 97 17	jmp $1a1797	            JMP done                ; Yes: just return the source string
.1a1743					ret_empty
.1a1743	20 c1 14	jsr $1a14c1	            JSR TEMPSTRING
.1a1746	e2 20		sep #$20	            SEP #$20
.1a1748	a9 00		lda #$00	            LDA #0
.1a174a	87 16		sta [$0816]	            STA [STRPTR]
.1a174c	80 39		bra $1a1787	            BRA finish_copy
.1a174e					do_slice
.1a174e	20 c1 14	jsr $1a14c1	            JSR TEMPSTRING
.1a1751	c2 30		rep #$30	            REP #$30
.1a1753	18		clc		            CLC                     ; ARGUMENT1 := ARGUMENT1 + index
.1a1754	a5 23		lda $0823	            LDA ARGUMENT1
.1a1756	65 29		adc $0829	            ADC ARGUMENT2
.1a1758	85 23		sta $0823	            STA ARGUMENT1
.1a175a	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a175c	69 00 00	adc #$0000	            ADC #0
.1a175f	85 25		sta $0825	            STA ARGUMENT1+2
.1a1761	a0 00 00	ldy #$0000	            LDY #0
.1a1764					copy_loop
.1a1764	e2 20		sep #$20	            SEP #$20
.1a1766	a7 23		lda [$0823]	            LDA [ARGUMENT1]         ; Copy a character from the substring to the temporary string
.1a1768	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a176a	f0 1b		beq $1a1787	            BEQ finish_copy         ; If it is a NULL, we're done
.1a176c	c2 20		rep #$20	            REP #$20
.1a176e	18		clc		            CLC                     ; Move to the next character
.1a176f	a5 23		lda $0823	            LDA ARGUMENT1
.1a1771	69 01 00	adc #$0001	            ADC #1
.1a1774	85 23		sta $0823	            STA ARGUMENT1
.1a1776	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a1778	69 00 00	adc #$0000	            ADC #0
.1a177b	85 25		sta $0825	            STA ARGUMENT1+2
.1a177d	c8		iny		            INY
.1a177e	c4 8f		cpy $088f	            CPY MCOUNT              ; Have we reached the limit to copy?
.1a1780	d0 e2		bne $1a1764	            BNE copy_loop           ; No: copy the next byte
.1a1782	a9 00 00	lda #$0000	            LDA #0                  ; Null terminate string
.1a1785	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a1787					finish_copy
.1a1787	c2 20		rep #$20	            REP #$20
.1a1789	a5 16		lda $0816	            LDA STRPTR
.1a178b	85 23		sta $0823	            STA ARGUMENT1
.1a178d	a5 18		lda $0818	            LDA STRPTR+2
.1a178f	85 25		sta $0825	            STA ARGUMENT1+2
.1a1791	e2 20		sep #$20	            SEP #$20
.1a1793	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a1795	85 27		sta $0827	            STA ARGTYPE1
.1a1797					done
.1a1797	28		plp		            PLP
.1a1798	60		rts		            RTS
.1a1799					OP_STR_LT
.1a1799	08		php		            PHP
.1a179a	c2 30		rep #$30	            REP #$30
.1a179c	20 c0 15	jsr $1a15c0	            JSR STRCMP
.1a179f	a5 23		lda $0823	            LDA ARGUMENT1
.1a17a1	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.1a17a4	d0 05		bne $1a17ab	            BNE ret_false               ; No: return false
.1a17a6					ret_true
.1a17a6	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a17a9	80 03		bra $1a17ae	            BRA done
.1a17ab					ret_false
.1a17ab	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a17ae	28		plp		done        PLP
.1a17af	60		rts		            RTS
.1a17b0					OP_STR_GT
.1a17b0	08		php		            PHP
.1a17b1	c2 30		rep #$30	            REP #$30
.1a17b3	20 c0 15	jsr $1a15c0	            JSR STRCMP
.1a17b6	a5 23		lda $0823	            LDA ARGUMENT1
.1a17b8	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.1a17bb	d0 05		bne $1a17c2	            BNE ret_false               ; No: return false
.1a17bd					ret_true
.1a17bd	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a17c0	80 03		bra $1a17c5	            BRA done
.1a17c2					ret_false
.1a17c2	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a17c5	28		plp		done        PLP
.1a17c6	60		rts		            RTS
.1a17c7					OP_STR_EQ
.1a17c7	08		php		            PHP
.1a17c8	c2 30		rep #$30	            REP #$30
.1a17ca	20 c0 15	jsr $1a15c0	            JSR STRCMP
.1a17cd	a5 23		lda $0823	            LDA ARGUMENT1
.1a17cf	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.1a17d2	d0 05		bne $1a17d9	            BNE ret_false               ; No: return false
.1a17d4					ret_true
.1a17d4	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a17d7	80 03		bra $1a17dc	            BRA done
.1a17d9					ret_false
.1a17d9	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a17dc	28		plp		done        PLP
.1a17dd	60		rts		            RTS
.1a17de					OP_STR_NE
.1a17de	08		php		            PHP
.1a17df	c2 30		rep #$30	            REP #$30
.1a17e1	20 c0 15	jsr $1a15c0	            JSR STRCMP
.1a17e4	a5 23		lda $0823	            LDA ARGUMENT1
.1a17e6	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.1a17e9	f0 05		beq $1a17f0	            BEQ ret_false               ; Yes: return false
.1a17eb					ret_true
.1a17eb	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a17ee	80 03		bra $1a17f3	            BRA done
.1a17f0					ret_false
.1a17f0	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a17f3	28		plp		done        PLP
.1a17f4	60		rts		            RTS
.1a17f5					OP_STR_GTE
.1a17f5	08		php		            PHP
.1a17f6	c2 30		rep #$30	            REP #$30
.1a17f8	20 c0 15	jsr $1a15c0	            JSR STRCMP
.1a17fb	a5 23		lda $0823	            LDA ARGUMENT1
.1a17fd	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.1a1800	f0 05		beq $1a1807	            BEQ ret_false               ; Yes: return false
.1a1802					ret_true
.1a1802	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a1805	80 03		bra $1a180a	            BRA done
.1a1807					ret_false
.1a1807	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a180a	28		plp		done        PLP
.1a180b	60		rts		            RTS
.1a180c					OP_STR_LTE
.1a180c	08		php		            PHP
.1a180d	c2 30		rep #$30	            REP #$30
.1a180f	20 c0 15	jsr $1a15c0	            JSR STRCMP
.1a1812	a5 23		lda $0823	            LDA ARGUMENT1
.1a1814	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.1a1817	f0 05		beq $1a181e	            BEQ ret_false               ; Yes: return false
.1a1819					ret_true
.1a1819	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a181c	80 03		bra $1a1821	            BRA done
.1a181e					ret_false
.1a181e	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a1821	28		plp		done        PLP
.1a1822	60		rts		            RTS
.1a1823					STR_NORMAL
.1a1823	08		php		            PHP
.1a1824	e2 20		sep #$20	            SEP #$20
.1a1826	a5 27		lda $0827	            LDA ARGTYPE1            ; Is it a string?
.1a1828	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a182a	d0 1d		bne $1a1849	            BNE done                ; No: return it
.1a182c	a5 23		lda $0823	            LDA ARGUMENT1           ; Is it a null pointer?
.1a182e	d0 19		bne $1a1849	            BNE done
.1a1830	a5 24		lda $0824	            LDA ARGUMENT1+1
.1a1832	d0 15		bne $1a1849	            BNE done
.1a1834	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a1836	d0 11		bne $1a1849	            BNE done                ; No: return it
.1a1838	20 c1 14	jsr $1a14c1	            JSR TEMPSTRING
.1a183b	a9 00		lda #$00	            LDA #0
.1a183d	87 16		sta [$0816]	            STA [STRPTR]            ; Make it empty
.1a183f	c2 20		rep #$20	            REP #$20
.1a1841	a5 16		lda $0816	            LDA STRPTR
.1a1843	85 23		sta $0823	            STA ARGUMENT1
.1a1845	a5 18		lda $0818	            LDA STRPTR+2
.1a1847	85 25		sta $0825	            STA ARGUMENT1+2
.1a1849	28		plp		done        PLP
.1a184a	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\listing.s

.1a184b					LISTPROG
.1a184b	48		pha		            PHA
.1a184c	5a		phy		            PHY
.1a184d	0b		phd		            PHD
.1a184e	08		php		            PHP
.1a184f	08		php		            PHP
.1a1850	c2 20		rep #$20	            REP #$20
.1a1852	48		pha		            PHA
.1a1853	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1856	5b		tcd		            TCD
.1a1857	68		pla		            PLA
.1a1858	28		plp		            PLP
.1a1859	c2 30		rep #$30	            REP #$30
.1a185b	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.1a185e	85 00		sta $0800	            STA BIP
.1a1860	85 1a		sta $081a	            STA CURLINE
.1a1862	a9 16 00	lda #$0016	            LDA #`BASIC_BOT
.1a1865	85 02		sta $0802	            STA BIP+2
.1a1867	85 1c		sta $081c	            STA CURLINE+2
.1a1869	22 3c 11 00	jsl $00113c	list_loop   JSL FK_TESTBREAK
.1a186d	b0 20		bcs $1a188f	            BCS throw_break     ; If C: user pressed an interrupt key, stop the listing
.1a186f	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.1a1872	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.1a1874	f0 0f		beq $1a1885	            BEQ done
.1a1876	c5 55		cmp $0855	            CMP MARG1
.1a1878	90 10		bcc $1a188a	            BLT skip_line
.1a187a	c5 59		cmp $0859	            CMP MARG2
.1a187c	f0 02		beq $1a1880	            BEQ print_line
.1a187e	b0 05		bcs $1a1885	            BGE done
.1a1880					print_line
.1a1880	20 ae 18	jsr $1a18ae	            JSR LISTLINE
.1a1883	80 e4		bra $1a1869	            BRA list_loop
.1a1885	28		plp		done        PLP
.1a1886	2b		pld		            PLD
.1a1887	7a		ply		            PLY
.1a1888	68		pla		            PLA
.1a1889	60		rts		            RTS
.1a188a					skip_line
.1a188a	20 ba 21	jsr $1a21ba	            JSR NEXTLINE
.1a188d	80 da		bra $1a1869	            BRA list_loop           ; And try again
.1a188f					throw_break
.1a188f	08		php		            PHP
.1a1890	c2 20		rep #$20	            REP #$20
.1a1892	48		pha		            PHA
.1a1893	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1896	5b		tcd		            TCD
.1a1897	68		pla		            PLA
.1a1898	28		plp		            PLP
.1a1899	e2 20		sep #$20	            SEP #$20
.1a189b	a9 01		lda #$01	            LDA #ERR_BREAK
.1a189d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a18a1	c2 20		rep #$20	            REP #$20
.1a18a3	29 ff 00	and #$00ff	            AND #$00FF
.1a18a6	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a18a9	e2 20		sep #$20	            SEP #$20
.1a18ab	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a18ae					LISTLINE
.1a18ae	08		php		            PHP
.1a18af	c2 30		rep #$30	            REP #$30
.1a18b1	85 23		sta $0823	            STA ARGUMENT1
.1a18b3	64 25		stz $0825	            STZ ARGUMENT1+2
.1a18b5	20 20 15	jsr $1a1520	            JSR ITOS
.1a18b8	a5 16		lda $0816	            LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.1a18ba	1a		inc a		            INC A
.1a18bb	85 23		sta $0823	            STA ARGUMENT1
.1a18bd	a5 18		lda $0818	            LDA STRPTR+2
.1a18bf	85 25		sta $0825	            STA ARGUMENT1+2
.1a18c1	20 73 45	jsr $1a4573	            JSR PR_STRING
.1a18c4	18		clc		            CLC                 ; Move the BIP to the first byte of the line
.1a18c5	a5 1a		lda $081a	            LDA CURLINE
.1a18c7	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a18ca	85 00		sta $0800	            STA BIP
.1a18cc	a5 1c		lda $081c	            LDA CURLINE+2
.1a18ce	69 00 00	adc #$0000	            ADC #0
.1a18d1	85 02		sta $0802	            STA BIP+2
.1a18d3	e2 20		sep #$20	            SEP #$20
.1a18d5	a9 20		lda #$20	            LDA #CHAR_SP
.1a18d7	20 18 00	jsr $1a0018	            JSR PRINTC
.1a18da	c2 20		rep #$20	            REP #$20
.1a18dc					loop
.1a18dc	20 ed 18	jsr $1a18ed	            JSR LISTBYTE
.1a18df	90 fb		bcc $1a18dc	            BCC loop
.1a18e1	e2 20		sep #$20	            SEP #$20
.1a18e3	a9 0d		lda #$0d	            LDA #CHAR_CR
.1a18e5	20 18 00	jsr $1a0018	            JSR PRINTC
.1a18e8	20 ba 21	jsr $1a21ba	            JSR NEXTLINE
.1a18eb	28		plp		            PLP
.1a18ec	60		rts		            RTS
.1a18ed					LISTBYTE
.1a18ed	08		php		            PHP
.1a18ee	0b		phd		            PHD
.1a18ef	8b		phb		            PHB
.1a18f0	08		php		            PHP
.1a18f1	c2 20		rep #$20	            REP #$20
.1a18f3	48		pha		            PHA
.1a18f4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a18f7	5b		tcd		            TCD
.1a18f8	68		pla		            PLA
.1a18f9	28		plp		            PLP
.1a18fa	08		php		            PHP
.1a18fb	e2 20		sep #$20	            SEP #$20
.1a18fd	48		pha		            PHA
.1a18fe	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1900	48		pha		            PHA
.1a1901	ab		plb		            PLB
.1a1902	68		pla		            PLA
.1a1903	28		plp		            PLP
.1a1904	e2 20		sep #$20	            SEP #$20
.1a1906	c2 10		rep #$10	            REP #$10
.1a1908	a7 00		lda [$0800]	            LDA [BIP]           ; Get the current byte
.1a190a	f0 3a		beq $1a1946	            BEQ end_of_line     ; If it's 0, return with C set
.1a190c	30 05		bmi $1a1913	            BMI is_token        ; If it's 0x80 - 0xFF, it's a token
.1a190e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a1911	80 29		bra $1a193c	            BRA done            ; And return
.1a1913					is_token
.1a1913	c2 20		rep #$20	            REP #$20
.1a1915	29 7f 00	and #$007f	            AND #$007F          ; Compute the index of the token
.1a1918	0a		asl a		            ASL A               ; In the token table
.1a1919	0a		asl a		            ASL A
.1a191a	0a		asl a		            ASL A
.1a191b	18		clc		            CLC
.1a191c	69 c3 0c	adc #$0cc3	            ADC #<>TOKENS       ; Set INDEX to the address of the token
.1a191f	85 08		sta $0808	            STA INDEX
.1a1921	a9 1a 00	lda #$001a	            LDA #`TOKENS
.1a1924	69 00 00	adc #$0000	            ADC #0
.1a1927	85 0a		sta $080a	            STA INDEX+2
.1a1929					pr_default
.1a1929	08		php		            PHP
.1a192a	e2 20		sep #$20	            SEP #$20
.1a192c	48		pha		            PHA
.1a192d	a9 1a		lda #$1a	            LDA #`TOKENS
.1a192f	48		pha		            PHA
.1a1930	ab		plb		            PLB
.1a1931	68		pla		            PLA
.1a1932	28		plp		            PLP
.1a1933	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.1a1936	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a1938	aa		tax		            TAX
.1a1939	20 29 04	jsr $1a0429	            JSR PRINTS
.1a193c					done
.1a193c	c2 20		rep #$20	            REP #$20
.1a193e	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a1941	ab		plb		            PLB
.1a1942	2b		pld		            PLD
.1a1943	28		plp		            PLP
.1a1944	18		clc		            CLC
.1a1945	60		rts		            RTS
.1a1946	ab		plb		end_of_line PLB
.1a1947	2b		pld		            PLD
.1a1948	28		plp		            PLP
.1a1949	38		sec		            SEC
.1a194a	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\eval.s

.1a194b					INITEVALSP
.1a194b	08		php		            PHP
.1a194c	c2 20		rep #$20	            REP #$20
.1a194e	a9 ff 6f	lda #$6fff	            LDA #ARGUMENT_TOP
.1a1951	85 1f		sta $081f	            STA ARGUMENTSP
.1a1953	a9 ff 7f	lda #$7fff	            LDA #OPERATOR_TOP
.1a1956	85 21		sta $0821	            STA OPERATORSP
.1a1958	a9 ff ff	lda #$ffff	            LDA #$FFFF
.1a195b	85 23		sta $0823	            STA ARGUMENT1
.1a195d	85 25		sta $0825	            STA ARGUMENT1+2
.1a195f	85 29		sta $0829	            STA ARGUMENT2
.1a1961	85 2b		sta $082b	            STA ARGUMENT2+2
.1a1963	e2 20		sep #$20	            SEP #$20
.1a1965	85 27		sta $0827	            STA ARGTYPE1
.1a1967	85 2d		sta $082d	            STA ARGTYPE2
.1a1969	28		plp		            PLP
.1a196a	60		rts		            RTS
.1a196b					PHARGUMENT
.1a196b	08		php		            PHP
.1a196c	0b		phd		            PHD
.1a196d	8b		phb		            PHB
.1a196e	08		php		            PHP
.1a196f	c2 20		rep #$20	            REP #$20
.1a1971	48		pha		            PHA
.1a1972	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1975	5b		tcd		            TCD
.1a1976	68		pla		            PLA
.1a1977	28		plp		            PLP
.1a1978	08		php		            PHP
.1a1979	e2 20		sep #$20	            SEP #$20
.1a197b	48		pha		            PHA
.1a197c	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a197e	48		pha		            PHA
.1a197f	ab		plb		            PLB
.1a1980	68		pla		            PLA
.1a1981	28		plp		            PLP
.1a1982	c2 30		rep #$30	            REP #$30
.1a1984	5a		phy		            PHY
.1a1985	a4 1f		ldy $081f	            LDY ARGUMENTSP
.1a1987	bd 00 00	lda $0000,x	            LDA #0,B,X
.1a198a	99 00 00	sta $0000,y	            STA #0,B,Y
.1a198d	bd 02 00	lda $0002,x	            LDA #2,B,X
.1a1990	99 02 00	sta $0002,y	            STA #2,B,Y
.1a1993	e2 20		sep #$20	            SEP #$20
.1a1995	bd 04 00	lda $0004,x	            LDA #4,B,X
.1a1998	99 04 00	sta $0004,y	            STA #4,B,Y
.1a199b	c2 20		rep #$20	            REP #$20
.1a199d	38		sec		            SEC
.1a199e	98		tya		            TYA
.1a199f	e9 05 00	sbc #$0005	            SBC #ARGUMENT_SIZE
.1a19a2	85 1f		sta $081f	            STA ARGUMENTSP
.1a19a4	7a		ply		            PLY
.1a19a5	ab		plb		            PLB
.1a19a6	2b		pld		            PLD
.1a19a7	28		plp		            PLP
.1a19a8	60		rts		            RTS
.1a19a9					PLARGUMENT
.1a19a9	08		php		            PHP
.1a19aa	0b		phd		            PHD
.1a19ab	8b		phb		            PHB
.1a19ac	08		php		            PHP
.1a19ad	c2 20		rep #$20	            REP #$20
.1a19af	48		pha		            PHA
.1a19b0	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a19b3	5b		tcd		            TCD
.1a19b4	68		pla		            PLA
.1a19b5	28		plp		            PLP
.1a19b6	08		php		            PHP
.1a19b7	e2 20		sep #$20	            SEP #$20
.1a19b9	48		pha		            PHA
.1a19ba	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a19bc	48		pha		            PHA
.1a19bd	ab		plb		            PLB
.1a19be	68		pla		            PLA
.1a19bf	28		plp		            PLP
.1a19c0	c2 30		rep #$30	            REP #$30
.1a19c2	5a		phy		            PHY
.1a19c3	18		clc		            CLC
.1a19c4	a5 1f		lda $081f	            LDA ARGUMENTSP
.1a19c6	69 05 00	adc #$0005	            ADC #ARGUMENT_SIZE
.1a19c9	85 1f		sta $081f	            STA ARGUMENTSP
.1a19cb	a8		tay		            TAY
.1a19cc	b9 00 00	lda $0000,y	            LDA #0,B,Y
.1a19cf	9d 00 00	sta $0000,x	            STA #0,B,X
.1a19d2	b9 02 00	lda $0002,y	            LDA #2,B,Y
.1a19d5	9d 02 00	sta $0002,x	            STA #2,B,X
.1a19d8	e2 20		sep #$20	            SEP #$20
.1a19da	b9 04 00	lda $0004,y	            LDA #4,B,Y
.1a19dd	9d 04 00	sta $0004,x	            STA #4,B,X
.1a19e0	bd 00 00	lda $0000,x	            LDA #0,B,X
.1a19e3	7a		ply		            PLY
.1a19e4	ab		plb		            PLB
.1a19e5	2b		pld		            PLD
.1a19e6	28		plp		            PLP
.1a19e7	60		rts		            RTS
.1a19e8					PHOPERATOR
.1a19e8	08		php		            PHP
.1a19e9	0b		phd		            PHD
.1a19ea	8b		phb		            PHB
.1a19eb	08		php		            PHP
.1a19ec	c2 20		rep #$20	            REP #$20
.1a19ee	48		pha		            PHA
.1a19ef	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a19f2	5b		tcd		            TCD
.1a19f3	68		pla		            PLA
.1a19f4	28		plp		            PLP
.1a19f5	08		php		            PHP
.1a19f6	e2 20		sep #$20	            SEP #$20
.1a19f8	48		pha		            PHA
.1a19f9	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a19fb	48		pha		            PHA
.1a19fc	ab		plb		            PLB
.1a19fd	68		pla		            PLA
.1a19fe	28		plp		            PLP
.1a19ff	e2 20		sep #$20	            SEP #$20
.1a1a01	c2 10		rep #$10	            REP #$10
.1a1a03	5a		phy		            PHY
.1a1a04	a4 21		ldy $0821	            LDY OPERATORSP
.1a1a06	99 00 00	sta $0000,y	            STA #0,B,Y
.1a1a09	88		dey		            DEY
.1a1a0a	84 21		sty $0821	            STY OPERATORSP
.1a1a0c	7a		ply		done        PLY
.1a1a0d	ab		plb		            PLB
.1a1a0e	2b		pld		            PLD
.1a1a0f	28		plp		            PLP
.1a1a10	60		rts		            RTS
.1a1a11					PLOPERATOR
.1a1a11	08		php		            PHP
.1a1a12	0b		phd		            PHD
.1a1a13	8b		phb		            PHB
.1a1a14	08		php		            PHP
.1a1a15	c2 20		rep #$20	            REP #$20
.1a1a17	48		pha		            PHA
.1a1a18	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1a1b	5b		tcd		            TCD
.1a1a1c	68		pla		            PLA
.1a1a1d	28		plp		            PLP
.1a1a1e	08		php		            PHP
.1a1a1f	e2 20		sep #$20	            SEP #$20
.1a1a21	48		pha		            PHA
.1a1a22	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1a24	48		pha		            PHA
.1a1a25	ab		plb		            PLB
.1a1a26	68		pla		            PLA
.1a1a27	28		plp		            PLP
.1a1a28	e2 20		sep #$20	            SEP #$20
.1a1a2a	c2 10		rep #$10	            REP #$10
.1a1a2c	5a		phy		            PHY
.1a1a2d	a4 21		ldy $0821	            LDY OPERATORSP
.1a1a2f	c8		iny		            INY
.1a1a30	84 21		sty $0821	            STY OPERATORSP
.1a1a32	b9 00 00	lda $0000,y	            LDA #0,B,Y
.1a1a35	c2 20		rep #$20	            REP #$20
.1a1a37	29 ff 00	and #$00ff	            AND #$00FF
.1a1a3a	7a		ply		            PLY
.1a1a3b	ab		plb		            PLB
.1a1a3c	2b		pld		            PLD
.1a1a3d	28		plp		            PLP
.1a1a3e	60		rts		            RTS
.1a1a3f					OPENPARAMS
.1a1a3f	08		php		            PHP
.1a1a40	e2 20		sep #$20	            SEP #$20
.1a1a42	a9 01		lda #$01	            LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.1a1a44	20 e8 19	jsr $1a19e8	            JSR PHOPERATOR
.1a1a47	28		plp		            PLP
.1a1a48	60		rts		            RTS
.1a1a49					CLOSEPARAMS
.1a1a49	5a		phy		            PHY
.1a1a4a	08		php		            PHP
.1a1a4b	8b		phb		            PHB
.1a1a4c	08		php		            PHP
.1a1a4d	e2 20		sep #$20	            SEP #$20
.1a1a4f	48		pha		            PHA
.1a1a50	a9 00		lda #$00	            LDA #0
.1a1a52	48		pha		            PHA
.1a1a53	ab		plb		            PLB
.1a1a54	68		pla		            PLA
.1a1a55	28		plp		            PLP
.1a1a56	e2 20		sep #$20	            SEP #$20
.1a1a58	a4 21		ldy $0821	            LDY OPERATORSP      ; Peek at the top operator
.1a1a5a	b9 01 00	lda $0001,y	            LDA #1,B,Y
.1a1a5d	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the marker for the start of a parameter list
.1a1a5f	d0 08		bne $1a1a69	            BNE error           ; No: there's a problem
.1a1a61	c2 20		rep #$20	            REP #$20
.1a1a63	e6 21		inc $0821	            INC OPERATORSP      ; Yes: remove it from the operator stack.
.1a1a65	ab		plb		            PLB
.1a1a66	28		plp		            PLP
.1a1a67	7a		ply		            PLY
.1a1a68	60		rts		            RTS
.1a1a69					error
.1a1a69	08		php		            PHP
.1a1a6a	c2 20		rep #$20	            REP #$20
.1a1a6c	48		pha		            PHA
.1a1a6d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1a70	5b		tcd		            TCD
.1a1a71	68		pla		            PLA
.1a1a72	28		plp		            PLP
.1a1a73	e2 20		sep #$20	            SEP #$20
.1a1a75	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1a77	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1a7b	c2 20		rep #$20	            REP #$20
.1a1a7d	29 ff 00	and #$00ff	            AND #$00FF
.1a1a80	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a1a83	e2 20		sep #$20	            SEP #$20
.1a1a85	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1a88					OPHIGHPREC
.1a1a88	48		pha		            PHA
.1a1a89	08		php		            PHP
.1a1a8a	0b		phd		            PHD
.1a1a8b	8b		phb		            PHB
.1a1a8c	08		php		            PHP
.1a1a8d	c2 20		rep #$20	            REP #$20
.1a1a8f	48		pha		            PHA
.1a1a90	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1a93	5b		tcd		            TCD
.1a1a94	68		pla		            PLA
.1a1a95	28		plp		            PLP
.1a1a96	08		php		            PHP
.1a1a97	e2 20		sep #$20	            SEP #$20
.1a1a99	48		pha		            PHA
.1a1a9a	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1a9c	48		pha		            PHA
.1a1a9d	ab		plb		            PLB
.1a1a9e	68		pla		            PLA
.1a1a9f	28		plp		            PLP
.1a1aa0	e2 20		sep #$20	            SEP #$20
.1a1aa2	a4 21		ldy $0821	            LDY OPERATORSP
.1a1aa4	c0 ff 7f	cpy #$7fff	            CPY #OPERATOR_TOP       ; Is the stack empty?
.1a1aa7	f0 11		beq $1a1aba	            BEQ is_false            ; Yes: return false
.1a1aa9	20 22 0c	jsr $1a0c22	            JSR TOKPRECED
.1a1aac	85 0c		sta $080c	            STA SCRATCH             ; Save it for later comparison
.1a1aae	b9 01 00	lda $0001,y	            LDA #1,B,Y              ; Get the operator at the top of the stack
.1a1ab1	20 22 0c	jsr $1a0c22	            JSR TOKPRECED
.1a1ab4	c5 0c		cmp $080c	            CMP SCRATCH             ; Compare the priorities (0 = highest priority)
.1a1ab6	f0 02		beq $1a1aba	            BEQ is_false            ; A = SCRATCH, return false
.1a1ab8	90 08		bcc $1a1ac2	            BCC is_true             ; A < SCRATCH (A is higher priority), return false
.1a1aba					is_false
.1a1aba	c2 20		rep #$20	            REP #$20
.1a1abc	ab		plb		            PLB
.1a1abd	2b		pld		            PLD
.1a1abe	28		plp		            PLP
.1a1abf	68		pla		            PLA
.1a1ac0	18		clc		            CLC
.1a1ac1	60		rts		            RTS
.1a1ac2					is_true
.1a1ac2	c2 20		rep #$20	            REP #$20
.1a1ac4	ab		plb		            PLB                     ; A > SCRATCH (A is lower priority), return true
.1a1ac5	2b		pld		            PLD
.1a1ac6	28		plp		            PLP
.1a1ac7	68		pla		            PLA
.1a1ac8	38		sec		            SEC
.1a1ac9	60		rts		            RTS
.1a1aca					EVALNUMBER
.1a1aca	4c 9d 08	jmp $1a089d	            JMP PARSEINT
.1a1acd					ARR_GETIDX
.1a1acd	08		php		            PHP
.1a1ace	e2 20		sep #$20	            SEP #$20
.1a1ad0	a9 00		lda #$00	            LDA #0
.1a1ad2	8f 00 4d 00	sta $004d00	            STA @lARRIDXBUF     ; Set the dimension to 0
.1a1ad6	a2 01 00	ldx #$0001	            LDX #1
.1a1ad9					eval_index
.1a1ad9	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a1adc	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a1adf	c2 20		rep #$20	            REP #$20
.1a1ae1	a5 23		lda $0823	            LDA ARGUMENT1       ; Save the index to the array index buffer
.1a1ae3	9f 00 4d 00	sta $004d00,x	            STA @l ARRIDXBUF,X
.1a1ae7	e2 20		sep #$20	            SEP #$20
.1a1ae9	af 00 4d 00	lda $004d00	            LDA @l ARRIDXBUF    ; Increment the index count
.1a1aed	1a		inc a		            INC A
.1a1aee	30 3e		bmi $1a1b2e	            BMI arg_err         ; If more than 127 dimensions, throw a range error
.1a1af0	8f 00 4d 00	sta $004d00	            STA @l ARRIDXBUF
.1a1af4	e8		inx		            INX
.1a1af5	e8		inx		            INX
.1a1af6	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a1af9	e2 20		sep #$20	            SEP #$20
.1a1afb	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.1a1afd	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it ")"
.1a1aff	f0 09		beq $1a1b0a	            BEQ clean_op        ; Yes: cleanup the argument stack
.1a1b01	c9 2c		cmp #$2c	            CMP #','            ; Is it a comma?
.1a1b03	d0 0a		bne $1a1b0f	            BNE syntax_err      ; No: throw a syntax error
.1a1b05					skip_comma
.1a1b05	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a1b08	80 cf		bra $1a1ad9	            BRA eval_index      ; And grab the next index
.1a1b0a					clean_op
.1a1b0a	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a1b0d	28		plp		            PLP
.1a1b0e	60		rts		            RTS
.1a1b0f					syntax_err
.1a1b0f	08		php		            PHP
.1a1b10	c2 20		rep #$20	            REP #$20
.1a1b12	48		pha		            PHA
.1a1b13	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1b16	5b		tcd		            TCD
.1a1b17	68		pla		            PLA
.1a1b18	28		plp		            PLP
.1a1b19	e2 20		sep #$20	            SEP #$20
.1a1b1b	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1b1d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1b21	c2 20		rep #$20	            REP #$20
.1a1b23	29 ff 00	and #$00ff	            AND #$00FF
.1a1b26	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a1b29	e2 20		sep #$20	            SEP #$20
.1a1b2b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1b2e					arg_err
.1a1b2e	08		php		            PHP
.1a1b2f	c2 20		rep #$20	            REP #$20
.1a1b31	48		pha		            PHA
.1a1b32	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1b35	5b		tcd		            TCD
.1a1b36	68		pla		            PLA
.1a1b37	28		plp		            PLP
.1a1b38	e2 20		sep #$20	            SEP #$20
.1a1b3a	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a1b3c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1b40	c2 20		rep #$20	            REP #$20
.1a1b42	29 ff 00	and #$00ff	            AND #$00FF
.1a1b45	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a1b48	e2 20		sep #$20	            SEP #$20
.1a1b4a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1b4d					EVALREF
.1a1b4d	08		php		            PHP
.1a1b4e					get_name
.1a1b4e	20 38 53	jsr $1a5338	            JSR VAR_FINDNAME
.1a1b51	90 47		bcc $1a1b9a	            BCC syntax_err      ; If we didn't find a name, thrown an error
.1a1b53	e2 20		sep #$20	            SEP #$20
.1a1b55	a5 ea		lda $08ea	            LDA TOFINDTYPE      ; Check the type of the variable
.1a1b57	29 80		and #$80	            AND #$80            ; Is it an array?
.1a1b59	d0 06		bne $1a1b61	            BNE is_array        ; Yes: look for the indexes
.1a1b5b	20 39 51	jsr $1a5139	            JSR VAR_REF
.1a1b5e	4c 98 1b	jmp $1a1b98	            JMP done
.1a1b61					is_array
.1a1b61	20 ab 50	jsr $1a50ab	            JSR VAR_FIND
.1a1b64	90 53		bcc $1a1bb9	            BCC notfound
.1a1b66	c2 20		rep #$20	            REP #$20
.1a1b68	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a1b6a	48		pha		            PHA
.1a1b6b	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a1b6d	48		pha		            PHA
.1a1b6e	a0 09 00	ldy #$0009	            LDY #BINDING.VALUE
.1a1b71	b7 08		lda [$0808],y	            LDA [INDEX],Y       ; Save the pointer to the array to CURRBLOCK
.1a1b73	85 c0		sta $08c0	            STA CURRBLOCK
.1a1b75	e2 20		sep #$20	            SEP #$20
.1a1b77	c8		iny		            INY
.1a1b78	c8		iny		            INY
.1a1b79	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a1b7b	85 c2		sta $08c2	            STA CURRBLOCK+2
.1a1b7d	e2 20		sep #$20	            SEP #$20
.1a1b7f	a9 8f		lda #$8f	            LDA #TOK_LPAREN
.1a1b81	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a1b84	20 3f 1a	jsr $1a1a3f	            JSR OPENPARAMS
.1a1b87					            PHARRIDX
.1a1b87	20 cd 1a	jsr $1a1acd	            JSR ARR_GETIDX
.1a1b8a	20 0f 68	jsr $1a680f	            JSR ARR_REF
.1a1b8d					            PLARRIDX
.1a1b8d	20 49 1a	jsr $1a1a49	            JSR CLOSEPARAMS
.1a1b90	c2 20		rep #$20	            REP #$20
.1a1b92	68		pla		            PLA
.1a1b93	85 c2		sta $08c2	            STA CURRBLOCK+2
.1a1b95	68		pla		            PLA
.1a1b96	85 c0		sta $08c0	            STA CURRBLOCK
.1a1b98	28		plp		done        PLP
.1a1b99	60		rts		            RTS
.1a1b9a					syntax_err
.1a1b9a	08		php		            PHP
.1a1b9b	c2 20		rep #$20	            REP #$20
.1a1b9d	48		pha		            PHA
.1a1b9e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1ba1	5b		tcd		            TCD
.1a1ba2	68		pla		            PLA
.1a1ba3	28		plp		            PLP
.1a1ba4	e2 20		sep #$20	            SEP #$20
.1a1ba6	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1ba8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1bac	c2 20		rep #$20	            REP #$20
.1a1bae	29 ff 00	and #$00ff	            AND #$00FF
.1a1bb1	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a1bb4	e2 20		sep #$20	            SEP #$20
.1a1bb6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1bb9					notfound
.1a1bb9	08		php		            PHP
.1a1bba	c2 20		rep #$20	            REP #$20
.1a1bbc	48		pha		            PHA
.1a1bbd	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1bc0	5b		tcd		            TCD
.1a1bc1	68		pla		            PLA
.1a1bc2	28		plp		            PLP
.1a1bc3	e2 20		sep #$20	            SEP #$20
.1a1bc5	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a1bc7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1bcb	c2 20		rep #$20	            REP #$20
.1a1bcd	29 ff 00	and #$00ff	            AND #$00FF
.1a1bd0	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a1bd3	e2 20		sep #$20	            SEP #$20
.1a1bd5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1bd8					EVALSTRING
.1a1bd8	08		php		            PHP
.1a1bd9	0b		phd		            PHD
.1a1bda	08		php		            PHP
.1a1bdb	c2 20		rep #$20	            REP #$20
.1a1bdd	48		pha		            PHA
.1a1bde	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1be1	5b		tcd		            TCD
.1a1be2	68		pla		            PLA
.1a1be3	28		plp		            PLP
.1a1be4	e2 20		sep #$20	            SEP #$20
.1a1be6	c2 10		rep #$10	            REP #$10
.1a1be8	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a1beb	a0 00 00	ldy #$0000	            LDY #0              ; Ywill be our length counter
.1a1bee	b7 00		lda [$0800],y	count_loop  LDA [BIP],Y         ; Get the character
.1a1bf0	f0 24		beq $1a1c16	            BEQ error           ; If it's end-of-line, throw an error
.1a1bf2	c9 22		cmp #$22	            CMP #CHAR_DQUOTE    ; Is it the ending double-quote?
.1a1bf4	f0 03		beq $1a1bf9	            BEQ found_end       ; Yes: Y should be the length
.1a1bf6	c8		iny		            INY
.1a1bf7	80 f5		bra $1a1bee	            BRA count_loop
.1a1bf9	84 0c		sty $080c	found_end   STY SCRATCH         ; Save the length to SCRATCH
.1a1bfb	e2 20		sep #$20	            SEP #$20
.1a1bfd	a9 02		lda #$02	            LDA #TYPE_STRING    ; Set the type to allocate to STRING
.1a1bff	a6 0c		ldx $080c	            LDX SCRATCH         ; And the length to the length of the string literal
.1a1c01	e8		inx		            INX
.1a1c02	20 c1 14	jsr $1a14c1	            JSR TEMPSTRING
.1a1c05	a0 00 00	ldy #$0000	            LDY #0
.1a1c08	c4 0c		cpy $080c	copy_loop   CPY SCRATCH         ; Have we copied all the characters?
.1a1c0a	f0 29		beq $1a1c35	            BEQ done            ; Yes: we're done
.1a1c0c	a7 00		lda [$0800]	            LDA [BIP]           ; No: get the next character
.1a1c0e	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And copy it to the allocated string
.1a1c10	c8		iny		            INY
.1a1c11	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a1c14	80 f2		bra $1a1c08	            BRA copy_loop       ; And try the next character
.1a1c16					error
.1a1c16	08		php		            PHP
.1a1c17	c2 20		rep #$20	            REP #$20
.1a1c19	48		pha		            PHA
.1a1c1a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1c1d	5b		tcd		            TCD
.1a1c1e	68		pla		            PLA
.1a1c1f	28		plp		            PLP
.1a1c20	e2 20		sep #$20	            SEP #$20
.1a1c22	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1c24	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1c28	c2 20		rep #$20	            REP #$20
.1a1c2a	29 ff 00	and #$00ff	            AND #$00FF
.1a1c2d	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a1c30	e2 20		sep #$20	            SEP #$20
.1a1c32	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1c35	a9 00		lda #$00	done        LDA #0
.1a1c37	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a1c39	c2 20		rep #$20	            REP #$20
.1a1c3b	a5 16		lda $0816	            LDA STRPTR
.1a1c3d	85 23		sta $0823	            STA ARGUMENT1
.1a1c3f	a5 18		lda $0818	            LDA STRPTR+2
.1a1c41	85 25		sta $0825	            STA ARGUMENT1+2
.1a1c43	a9 02 00	lda #$0002	            LDA #TYPE_STRING    ; And set the type of ARGUMENT1 to string
.1a1c46	85 27		sta $0827	            STA ARGTYPE1
.1a1c48	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a1c4b	2b		pld		            PLD
.1a1c4c	28		plp		            PLP
.1a1c4d	60		rts		            RTS
.1a1c4e					EVAL_FUNC
.1a1c4e	08		php		            PHP
.1a1c4f	e2 20		sep #$20	            SEP #$20
.1a1c51	a7 00		lda [$0800]	            LDA [BIP]           ; Get the token
.1a1c53	c2 20		rep #$20	            REP #$20
.1a1c55	29 ff 00	and #$00ff	            AND #$00FF
.1a1c58	20 4c 0c	jsr $1a0c4c	            JSR TOKEVAL
.1a1c5b	85 2f		sta $082f	            STA JMP16PTR
.1a1c5d	20 3f 1a	jsr $1a1a3f	            JSR OPENPARAMS
.1a1c60	08		php		            PHP
.1a1c61	e2 20		sep #$20	            SEP #$20
.1a1c63	48		pha		            PHA
.1a1c64	a9 00		lda #$00	            LDA #0
.1a1c66	48		pha		            PHA
.1a1c67	ab		plb		            PLB
.1a1c68	68		pla		            PLA
.1a1c69	28		plp		            PLP
.1a1c6a	20 72 1c	jsr $1a1c72	            JSR OPSTUB
.1a1c6d	20 49 1a	jsr $1a1a49	            JSR CLOSEPARAMS
.1a1c70	28		plp		            PLP
.1a1c71	60		rts		            RTS
.1a1c72					OPSTUB
.1a1c72	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a1c75	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.1a1c78					PROCESSOP
.1a1c78	48		pha		            PHA
.1a1c79	08		php		            PHP
.1a1c7a	0b		phd		            PHD
.1a1c7b	8b		phb		            PHB
.1a1c7c	08		php		            PHP
.1a1c7d	c2 20		rep #$20	            REP #$20
.1a1c7f	48		pha		            PHA
.1a1c80	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1c83	5b		tcd		            TCD
.1a1c84	68		pla		            PLA
.1a1c85	28		plp		            PLP
.1a1c86	c2 30		rep #$30	            REP #$30
.1a1c88	20 11 1a	jsr $1a1a11	            JSR PLOPERATOR
.1a1c8b	89 80 00	bit #$0080	            BIT #$80            ; Check if it's really a token
.1a1c8e	f0 37		beq $1a1cc7	            BEQ bad_token       ; No: it's a bad token
.1a1c90	48		pha		            PHA
.1a1c91	20 4c 0c	jsr $1a0c4c	            JSR TOKEVAL
.1a1c94	85 2f		sta $082f	            STA JMP16PTR
.1a1c96	68		pla		            PLA
.1a1c97	20 99 0c	jsr $1a0c99	            JSR TOKARITY
.1a1c9a	c9 01 00	cmp #$0001	            CMP #1              ; Check the operator's arity
.1a1c9d	f0 08		beq $1a1ca7	            BEQ pull_arg1       ; If it's 1 just pull one argument from the stack
.1a1c9f	c2 30		rep #$30	            REP #$30
.1a1ca1	a2 29 08	ldx #$0829	            LDX #<>ARGUMENT2    ; Pull argument 2 from the stack
.1a1ca4	20 a9 19	jsr $1a19a9	            JSR PLARGUMENT
.1a1ca7					pull_arg1
.1a1ca7	c2 30		rep #$30	            REP #$30
.1a1ca9	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Pull argument 1 from the stack
.1a1cac	20 a9 19	jsr $1a19a9	            JSR PLARGUMENT
.1a1caf	08		php		            PHP
.1a1cb0	e2 20		sep #$20	            SEP #$20
.1a1cb2	48		pha		            PHA
.1a1cb3	a9 00		lda #$00	            LDA #0
.1a1cb5	48		pha		            PHA
.1a1cb6	ab		plb		            PLB
.1a1cb7	68		pla		            PLA
.1a1cb8	28		plp		            PLP
.1a1cb9	20 c9 1c	jsr $1a1cc9	            JSR OPSTUB
.1a1cbc	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Get return result in argument 1
.1a1cbf	20 6b 19	jsr $1a196b	            JSR PHARGUMENT
.1a1cc2	ab		plb		            PLB
.1a1cc3	2b		pld		            PLD
.1a1cc4	28		plp		            PLP
.1a1cc5	68		pla		            PLA
.1a1cc6	60		rts		            RTS
.1a1cc7	00		brk #		bad_token   BRK
.1a1cc8	ea		nop		            NOP
.1a1cc9	6c 2f 08	jmp ($082f)	OPSTUB      JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.1a1ccc					EVALEXPR
.1a1ccc	08		php		            PHP
.1a1ccd	08		php		            PHP
.1a1cce	c2 20		rep #$20	            REP #$20
.1a1cd0	48		pha		            PHA
.1a1cd1	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1cd4	5b		tcd		            TCD
.1a1cd5	68		pla		            PLA
.1a1cd6	28		plp		            PLP
.1a1cd7	08		php		            PHP
.1a1cd8	e2 20		sep #$20	            SEP #$20
.1a1cda	48		pha		            PHA
.1a1cdb	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1cdd	48		pha		            PHA
.1a1cde	ab		plb		            PLB
.1a1cdf	68		pla		            PLA
.1a1ce0	28		plp		            PLP
.1a1ce1	c2 10		rep #$10	            REP #$10
.1a1ce3	da		phx		            PHX
.1a1ce4					get_char
.1a1ce4	e2 20		sep #$20	            SEP #$20
.1a1ce6	a7 00		lda [$0800]	            LDA [BIP]           ; Get the character
.1a1ce8	d0 03		bne $1a1ced	            BNE else1
.1a1cea	4c 8f 1d	jmp $1a1d8f	            JMP proc_stack      ; Handle end of line, if we see it
.1a1ced	30 33		bmi $1a1d22	else1       BMI is_token        ; If MSB is set, it's a token
.1a1cef	c9 20		cmp #$20	            CMP #' '            ; Is it a space?
.1a1cf1	d0 03		bne $1a1cf6	            BNE else2
.1a1cf3	4c 89 1d	jmp $1a1d89	            JMP next_char       ; Yes: Skip to the next character
.1a1cf6	c9 3a		cmp #$3a	else2       CMP #'9'+1          ; Check to see if we have digits
.1a1cf8	b0 04		bcs $1a1cfe	            BCS else3           ; No: treat as the end of the line
.1a1cfa	c9 30		cmp #$30	            CMP #'0'
.1a1cfc	b0 56		bcs $1a1d54	            BCS is_digit
.1a1cfe	c9 26		cmp #$26	else3       CMP #'&'            ; Check for a hexadecimal prefix
.1a1d00	f0 52		beq $1a1d54	            BEQ is_digit
.1a1d02	c9 22		cmp #$22	            CMP #'"'            ; Is it a double-quote?
.1a1d04	d0 03		bne $1a1d09	            BNE else4
.1a1d06	4c a2 1d	jmp $1a1da2	            JMP is_string       ; Yes: process the string
.1a1d09	c9 5b		cmp #$5b	else4       CMP #'Z'+1          ; Check to see if we have upper case alphabetics
.1a1d0b	b0 07		bcs $1a1d14	            BCS check_lc        ; No: check for lower case
.1a1d0d	c9 41		cmp #$41	            CMP #'A'
.1a1d0f	90 03		bcc $1a1d14	            BCC check_lc
.1a1d11	4c ae 1d	jmp $1a1dae	            JMP is_alpha
.1a1d14	c9 7b		cmp #$7b	check_lc    CMP #'z'+1          ; Check to see if we have lower case alphabetics
.1a1d16	b0 07		bcs $1a1d1f	            BCS else5           ; No: treat as the end of the line
.1a1d18	c9 61		cmp #$61	            CMP #'a'
.1a1d1a	90 03		bcc $1a1d1f	            BCC else5
.1a1d1c	4c ae 1d	jmp $1a1dae	            JMP is_alpha
.1a1d1f	4c 8f 1d	jmp $1a1d8f	else5       JMP proc_stack
.1a1d22	c9 8f		cmp #$8f	is_token    CMP #TOK_LPAREN     ; Is it an LPAREN
.1a1d24	f0 40		beq $1a1d66	            BEQ is_lparen       ; Yes: handle the LPAREN
.1a1d26	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it an RPAREN?
.1a1d28	f0 41		beq $1a1d6b	            BEQ is_rparen       ; Yes: handle the RPAREN
.1a1d2a	20 6f 0c	jsr $1a0c6f	            JSR TOKTYPE
.1a1d2d	c9 30		cmp #$30	            CMP #TOK_TY_FUNC    ; Is it a function?
.1a1d2f	d0 0c		bne $1a1d3d	            BNE chk_op          ; No: check if it's an operator
.1a1d31	20 4e 1c	jsr $1a1c4e	            JSR EVAL_FUNC
.1a1d34	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.1a1d37	20 6b 19	jsr $1a196b	            JSR PHARGUMENT
.1a1d3a	4c e4 1c	jmp $1a1ce4	            JMP get_char
.1a1d3d	c9 00		cmp #$00	chk_op      CMP #TOK_TY_OP      ; Is it an operator?
.1a1d3f	d0 4e		bne $1a1d8f	            BNE proc_stack      ; No: we're finished processing
.1a1d41	a7 00		lda [$0800]	            LDA [BIP]           ; Yes: Get the token back
.1a1d43	a6 21		ldx $0821	chk_prec    LDX OPERATORSP      ; Is the operator stack empty?
.1a1d45	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.1a1d48	f0 05		beq $1a1d4f	            BEQ push_op         ; Yes: push the operator
.1a1d4a	20 88 1a	jsr $1a1a88	            JSR OPHIGHPREC
.1a1d4d	b0 12		bcs $1a1d61	            BCS process1        ; No: we should process the top operator
.1a1d4f					push_op
.1a1d4f	20 e8 19	jsr $1a19e8	            JSR PHOPERATOR
.1a1d52	80 35		bra $1a1d89	            BRA next_char       ; And go to the next character
.1a1d54					is_digit
.1a1d54	c2 20		rep #$20	            REP #$20
.1a1d56	20 5a 59	jsr $1a595a	            JSR PARSENUM
.1a1d59	a2 23 08	ldx #$0823	got_number  LDX #<>ARGUMENT1
.1a1d5c	20 6b 19	jsr $1a196b	            JSR PHARGUMENT
.1a1d5f	80 83		bra $1a1ce4	            BRA get_char
.1a1d61					process1
.1a1d61	20 78 1c	jsr $1a1c78	            JSR PROCESSOP
.1a1d64	80 dd		bra $1a1d43	            BRA chk_prec        ; And check what to do with the current operator
.1a1d66					is_lparen
.1a1d66	20 e8 19	jsr $1a19e8	            JSR PHOPERATOR
.1a1d69	80 1e		bra $1a1d89	            BRA next_char
.1a1d6b					is_rparen
.1a1d6b	e2 20		sep #$20	            SEP #$20
.1a1d6d	a4 21		ldy $0821	            LDY OPERATORSP      ; Is the operator stack empty?
.1a1d6f	c0 ff 7f	cpy #$7fff	            CPY #<>OPERATOR_TOP
.1a1d72	f0 46		beq $1a1dba	            BEQ done            ; Yes: we're done evaluating things
.1a1d74	a4 21		ldy $0821	paren_loop  LDY OPERATORSP      ; Peek at the top operator
.1a1d76	b9 01 00	lda $0001,y	            LDA #1,B,Y
.1a1d79	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the LPAREN of a function?
.1a1d7b	f0 3d		beq $1a1dba	            BEQ done            ; Yes: treat it as an empty stack
.1a1d7d	c9 8f		cmp #$8f	            CMP #TOK_LPAREN     ; Is it an LPAREN?
.1a1d7f	f0 05		beq $1a1d86	            BEQ done_rparen     ; Yes: we're finished processing
.1a1d81	20 78 1c	jsr $1a1c78	            JSR PROCESSOP
.1a1d84	80 ee		bra $1a1d74	            BRA paren_loop
.1a1d86					done_rparen
.1a1d86	20 11 1a	jsr $1a1a11	            JSR PLOPERATOR
.1a1d89					next_char
.1a1d89	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a1d8c	4c e4 1c	jmp $1a1ce4	            JMP get_char
.1a1d8f					proc_stack
.1a1d8f	a6 21		ldx $0821	            LDX OPERATORSP      ; Is the operator stack empty?
.1a1d91	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.1a1d94	b0 24		bcs $1a1dba	            BGE done            ; Yes: return to the caller
.1a1d96	bd 01 00	lda $0001,x	            LDA #1,B,X
.1a1d99	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is top operator a function open?
.1a1d9b	f0 1d		beq $1a1dba	            BEQ done            ; Yes: treat as end of expression
.1a1d9d	20 78 1c	jsr $1a1c78	            JSR PROCESSOP
.1a1da0	80 ed		bra $1a1d8f	            BRA proc_stack
.1a1da2					is_string
.1a1da2	20 d8 1b	jsr $1a1bd8	            JSR EVALSTRING
.1a1da5	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.1a1da8	20 6b 19	jsr $1a196b	            JSR PHARGUMENT
.1a1dab	4c e4 1c	jmp $1a1ce4	            JMP get_char
.1a1dae					is_alpha
.1a1dae	20 4d 1b	jsr $1a1b4d	            JSR EVALREF
.1a1db1	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.1a1db4	20 6b 19	jsr $1a196b	            JSR PHARGUMENT
.1a1db7	4c e4 1c	jmp $1a1ce4	            JMP get_char
.1a1dba	a2 23 08	ldx #$0823	done        LDX #<>ARGUMENT1    ; Make sure the result is off the stack
.1a1dbd	20 a9 19	jsr $1a19a9	            JSR PLARGUMENT
.1a1dc0					real_done
.1a1dc0	fa		plx		            PLX
.1a1dc1	28		plp		            PLP
.1a1dc2	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\returnstack.s

.1a1dc3					INITRETURN
.1a1dc3	08		php		                PHP
.1a1dc4	0b		phd		                PHD
.1a1dc5	8b		phb		                PHB
.1a1dc6	08		php		            PHP
.1a1dc7	e2 20		sep #$20	            SEP #$20
.1a1dc9	48		pha		            PHA
.1a1dca	a9 00		lda #$00	            LDA #0
.1a1dcc	48		pha		            PHA
.1a1dcd	ab		plb		            PLB
.1a1dce	68		pla		            PLA
.1a1dcf	28		plp		            PLP
.1a1dd0	08		php		            PHP
.1a1dd1	c2 20		rep #$20	            REP #$20
.1a1dd3	48		pha		            PHA
.1a1dd4	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1dd7	5b		tcd		            TCD
.1a1dd8	68		pla		            PLA
.1a1dd9	28		plp		            PLP
.1a1dda	c2 30		rep #$30	            REP #$30
.1a1ddc	a9 fd 5f	lda #$5ffd	                LDA #RETURN_TOP-2
.1a1ddf	85 33		sta $0833	                STA RETURNSP
.1a1de1	ab		plb		                PLB
.1a1de2	2b		pld		                PLD
.1a1de3	28		plp		                PLP
.1a1de4	60		rts		            RTS
.1a1de5					PHRETURN
.1a1de5	08		php		                PHP
.1a1de6	0b		phd		                PHD
.1a1de7	08		php		            PHP
.1a1de8	c2 20		rep #$20	            REP #$20
.1a1dea	48		pha		            PHA
.1a1deb	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1dee	5b		tcd		            TCD
.1a1def	68		pla		            PLA
.1a1df0	28		plp		            PLP
.1a1df1	c2 30		rep #$30	            REP #$30
.1a1df3	92 33		sta ($0833)	                STA (RETURNSP)
.1a1df5	c6 33		dec $0833	                DEC RETURNSP
.1a1df7	c6 33		dec $0833	                DEC RETURNSP
.1a1df9	2b		pld		                PLD
.1a1dfa	28		plp		                PLP
.1a1dfb	60		rts		            RTS
.1a1dfc					PHRETURNB
.1a1dfc	08		php		                PHP
.1a1dfd	c2 30		rep #$30	            REP #$30
.1a1dff	29 ff 00	and #$00ff	                AND #$00FF
.1a1e02	20 e5 1d	jsr $1a1de5	            JSR PHRETURN
.1a1e05	28		plp		                PLP
.1a1e06	60		rts		            RTS
.1a1e07					PLRETURN
.1a1e07	08		php		                PHP
.1a1e08	0b		phd		                PHD
.1a1e09	08		php		            PHP
.1a1e0a	c2 20		rep #$20	            REP #$20
.1a1e0c	48		pha		            PHA
.1a1e0d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1e10	5b		tcd		            TCD
.1a1e11	68		pla		            PLA
.1a1e12	28		plp		            PLP
.1a1e13	c2 30		rep #$30	            REP #$30
.1a1e15	e6 33		inc $0833	                INC RETURNSP
.1a1e17	e6 33		inc $0833	                INC RETURNSP
.1a1e19	b2 33		lda ($0833)	                LDA (RETURNSP)
.1a1e1b	2b		pld		                PLD
.1a1e1c	28		plp		                PLP
.1a1e1d	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\interpreter.s

=$80					ST_RUNNING = $80            ; The interpreter is running a full program
=$00					ST_INTERACT = $00           ; The interpreter is in interactive mode
>08d2					STATE       .byte ?         ; The state of the interpreter ()
>08d3					ERROR_NUM   .byte ?         ; The type of the error
>08d4					HANDLEERR   .long ?         ; Pointer to the error handler
>08d7					LINENUM     .word ?         ; The current line number
>08d9					LASTLINE    .long ?         ; Pointer to the next free space over the BASIC program
>08dc					EXECACTION  .byte ?         ; The action the exection routines should take to get their next statement
=0					LINE_LINK = 0               ; Offset to the link to the next line
=2					LINE_NUMBER = 2             ; Offset to the line number
=4					LINE_TOKENS = 4             ; Offset to the first token
=6					LINE_MINLEN = 6             ; Minimum length of a line
=0					EXEC_CONT = 0               ; Continue advancing the current line
=1					EXEC_STOP = 1               ; Stop execution of the program
=2					EXEC_GOTO = 2               ; Transfer execution to a new CURLINE that is already set
=3					EXEC_RETURN = 3             ; Transfer execution back to a line that was on the stack
.1a1e1e					SET_ERRERL
.1a1e1e	8b		phb		                PHB
.1a1e1f	0b		phd		                PHD
.1a1e20	08		php		                PHP
.1a1e21	08		php		            PHP
.1a1e22	c2 20		rep #$20	            REP #$20
.1a1e24	48		pha		            PHA
.1a1e25	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1e28	5b		tcd		            TCD
.1a1e29	68		pla		            PLA
.1a1e2a	28		plp		            PLP
.1a1e2b	08		php		            PHP
.1a1e2c	e2 20		sep #$20	            SEP #$20
.1a1e2e	48		pha		            PHA
.1a1e2f	a9 00		lda #$00	            LDA #BASIC_BANK
.1a1e31	48		pha		            PHA
.1a1e32	ab		plb		            PLB
.1a1e33	68		pla		            PLA
.1a1e34	28		plp		            PLP
.1a1e35	c2 20		rep #$20	            REP #$20
.1a1e37	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.1a1e39	a9 00 00	lda #$0000	                LDA #0
.1a1e3c	85 25		sta $0825	                STA ARGUMENT1+2
.1a1e3e	e2 20		sep #$20	            SEP #$20
.1a1e40	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a1e42	85 27		sta $0827	                STA ARGTYPE1
.1a1e44	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.1a1e46	a9 1a		lda #$1a	                LDA #`err_name
.1a1e48	85 e9		sta $08e9	                STA TOFIND+2
.1a1e4a	c2 20		rep #$20	            REP #$20
.1a1e4c	a9 78 1e	lda #$1e78	                LDA #<>err_name
.1a1e4f	85 e7		sta $08e7	                STA TOFIND
.1a1e51	20 9b 52	jsr $1a529b	            JSR VAR_SET
.1a1e54	c2 20		rep #$20	            REP #$20
.1a1e56	a5 d7		lda $08d7	                LDA LINENUM
.1a1e58	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.1a1e5a	a5 d9		lda $08d9	                LDA LINENUM+2
.1a1e5c	85 25		sta $0825	                STA ARGUMENT1+2
.1a1e5e	e2 20		sep #$20	            SEP #$20
.1a1e60	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a1e62	85 27		sta $0827	                STA ARGTYPE1
.1a1e64	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.1a1e66	a9 1a		lda #$1a	                LDA #`erl_name
.1a1e68	85 e9		sta $08e9	                STA TOFIND+2
.1a1e6a	c2 20		rep #$20	            REP #$20
.1a1e6c	a9 7c 1e	lda #$1e7c	                LDA #<>erl_name
.1a1e6f	85 e7		sta $08e7	                STA TOFIND
.1a1e71	20 9b 52	jsr $1a529b	            JSR VAR_SET
.1a1e74	28		plp		                PLP
.1a1e75	2b		pld		                PLD
.1a1e76	ab		plb		                PLB
.1a1e77	60		rts		            RTS
>1a1e78	45 52 52 00			err_name        .null "ERR"
>1a1e7c	45 52 4c 00			erl_name        .null "ERL"
.1a1e80					ON_ERROR
.1a1e80	e2 20		sep #$20	            SEP #$20
.1a1e82	c2 10		rep #$10	            REP #$10
.1a1e84	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a1e87	af d3 08 00	lda $0008d3	            LDA @lERROR_NUM         ; Calculate index to the error message pointer
.1a1e8b	0a		asl a		            ASL A
.1a1e8c	c2 20		rep #$20	            REP #$20
.1a1e8e	29 ff 00	and #$00ff	            AND #$00FF
.1a1e91	a8		tay		            TAY
.1a1e92	08		php		            PHP
.1a1e93	e2 20		sep #$20	            SEP #$20
.1a1e95	48		pha		            PHA
.1a1e96	a9 1a		lda #$1a	            LDA #`ERRORMSG
.1a1e98	48		pha		            PHA
.1a1e99	ab		plb		            PLB
.1a1e9a	68		pla		            PLA
.1a1e9b	28		plp		            PLP
.1a1e9c	be d2 1e	ldx $1a1ed2,y	            LDX ERRORMSG,Y
.1a1e9f	20 29 04	jsr $1a0429	            JSR PRINTS
.1a1ea2	c2 20		rep #$20	            REP #$20
.1a1ea4	a5 d7		lda $08d7	            LDA LINENUM
.1a1ea6	f0 27		beq $1a1ecf	            BEQ skip_at
.1a1ea8	a2 02 1f	ldx #$1f02	            LDX #<>MSG_AT           ; If so... print " AT "
.1a1eab	20 29 04	jsr $1a0429	            JSR PRINTS
.1a1eae	08		php		            PHP
.1a1eaf	e2 20		sep #$20	            SEP #$20
.1a1eb1	48		pha		            PHA
.1a1eb2	a9 00		lda #$00	            LDA #BASIC_BANK
.1a1eb4	48		pha		            PHA
.1a1eb5	ab		plb		            PLB
.1a1eb6	68		pla		            PLA
.1a1eb7	28		plp		            PLP
.1a1eb8	c2 20		rep #$20	            REP #$20
.1a1eba	af d7 08 00	lda $0008d7	            LDA @lLINENUM           ; ... and then the line number
.1a1ebe	8f 23 08 00	sta $000823	            STA @lARGUMENT1
.1a1ec2	a9 00 00	lda #$0000	            LDA #0
.1a1ec5	8f 25 08 00	sta $000825	            STA @lARGUMENT1+2
.1a1ec9	20 91 45	jsr $1a4591	            JSR PR_INTEGER
.1a1ecc	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a1ecf					skip_at
.1a1ecf	4c 80 27	jmp $1a2780	            JMP INTERACT
>1a1ed2	06 1f				ERRORMSG    .word <>MSG_OK
>1a1ed4	09 1f				            .word <>MSG_BREAK
>1a1ed6	0f 1f				            .word <>MSG_SYNTAX
>1a1ed8	1c 1f				            .word <>MSG_MEMORY
>1a1eda	2a 1f				            .word <>MSG_TYPE
>1a1edc	38 1f				            .word <>MSG_NOTFND
>1a1ede	4b 1f				            .word <>MSG_NOLINE
>1a1ee0	61 1f				            .word <>MSG_UNDFLOW
>1a1ee2	71 1f				            .word <>MSG_OVRFLOW
>1a1ee4	80 1f				            .word <>MSG_RANGE
>1a1ee6	8d 1f				            .word <>MSG_ARG
>1a1ee8	9e 1f				            .word <>MSG_NOFILE
>1a1eea	ad 1f				            .word <>MSG_NAN
>1a1eec	ba 1f				            .word <>MSG_OVERFLOW
>1a1eee	c8 1f				            .word <>MSG_UNDERFLOW
>1a1ef0	d7 1f				            .word <>MSG_DIV0
>1a1ef2	e8 1f				            .word <>MSG_DIRECTORY
>1a1ef4	01 20				            .word <>MSG_LOAD
>1a1ef6	15 20				            .word <>MSG_SAVE
>1a1ef8	29 20				            .word <>MSG_DELETE
>1a1efa	3f 20				            .word <>MSG_FILENOTFND
>1a1efc	53 20				            .word <>MSG_DIRNOTWRITE
>1a1efe	6e 20				            .word <>MSG_NOTCOPIED
>1a1f00	86 20				            .word <>MSG_DOMAIN
>1a1f02	20 61 74 00			MSG_AT          .null " at"
>1a1f06	4f 4b 00			MSG_OK          .null "OK"
>1a1f09	42 72 65 61 6b 00		MSG_BREAK       .null "Break"
>1a1f0f	53 79 6e 74 61 78 20 65		MSG_SYNTAX      .null "Syntax error"
>1a1f17	72 72 6f 72 00
>1a1f1c	4f 75 74 20 6f 66 20 6d		MSG_MEMORY      .null "Out of memory"
>1a1f24	65 6d 6f 72 79 00
>1a1f2a	54 79 70 65 20 6d 69 73		MSG_TYPE        .null "Type mismatch"
>1a1f32	6d 61 74 63 68 00
>1a1f38	56 61 72 69 61 62 6c 65		MSG_NOTFND      .null "Variable not found"
>1a1f40	20 6e 6f 74 20 66 6f 75 6e 64 00
>1a1f4b	4c 69 6e 65 20 6e 75 6d		MSG_NOLINE      .null "Line number not found"
>1a1f53	62 65 72 20 6e 6f 74 20 66 6f 75 6e 64 00
>1a1f61	53 74 61 63 6b 20 75 6e		MSG_UNDFLOW     .null "Stack underflow"
>1a1f69	64 65 72 66 6c 6f 77 00
>1a1f71	53 74 61 63 6b 20 6f 76		MSG_OVRFLOW     .null "Stack overflow"
>1a1f79	65 72 66 6c 6f 77 00
>1a1f80	4f 75 74 20 6f 66 20 72		MSG_RANGE       .null "Out of range"
>1a1f88	61 6e 67 65 00
>1a1f8d	49 6c 6c 65 67 61 6c 20		MSG_ARG         .null "Illegal argument"
>1a1f95	61 72 67 75 6d 65 6e 74 00
>1a1f9e	46 69 6c 65 20 6e 6f 74		MSG_NOFILE      .null "File not found"
>1a1fa6	20 66 6f 75 6e 64 00
>1a1fad	4e 6f 74 20 61 20 6e 75		MSG_NAN         .null "Not a number"
>1a1fb5	6d 62 65 72 00
>1a1fba	4d 61 74 68 20 6f 76 65		MSG_OVERFLOW    .null "Math overflow"
>1a1fc2	72 66 6c 6f 77 00
>1a1fc8	4d 61 74 68 20 75 6e 64		MSG_UNDERFLOW   .null "Math underflow"
>1a1fd0	65 72 66 6c 6f 77 00
>1a1fd7	44 69 76 69 73 69 6f 6e		MSG_DIV0        .null "Division by zero"
>1a1fdf	20 62 79 20 7a 65 72 6f 00
>1a1fe8	55 6e 61 62 6c 65 20 74		MSG_DIRECTORY   .null "Unable to read directory"
>1a1ff0	6f 20 72 65 61 64 20 64 69 72 65 63 74 6f 72 79
>1a2000	00
>1a2001	55 6e 61 62 6c 65 20 74		MSG_LOAD        .null "Unable to load file"
>1a2009	6f 20 6c 6f 61 64 20 66 69 6c 65 00
>1a2015	55 6e 61 62 6c 65 20 74		MSG_SAVE        .null "Unable to save file"
>1a201d	6f 20 73 61 76 65 20 66 69 6c 65 00
>1a2029	55 6e 61 62 6c 65 20 74		MSG_DELETE      .null "Unable to delete file"
>1a2031	6f 20 64 65 6c 65 74 65 20 66 69 6c 65 00
>1a203f	43 6f 75 6c 64 20 6e 6f		MSG_FILENOTFND  .null "Could not find file"
>1a2047	74 20 66 69 6e 64 20 66 69 6c 65 00
>1a2053	43 6f 75 6c 64 20 6e 6f		MSG_DIRNOTWRITE .null "Could not update directory"
>1a205b	74 20 75 70 64 61 74 65 20 64 69 72 65 63 74 6f
>1a206b	72 79 00
>1a206e	43 6f 75 6c 64 20 6e 6f		MSG_NOTCOPIED   .null "Could not copy the file"
>1a2076	74 20 63 6f 70 79 20 74 68 65 20 66 69 6c 65 00
>1a2086	41 72 67 75 6d 65 6e 74		MSG_DOMAIN      .null "Argument outside domain"
>1a208e	20 6f 75 74 73 69 64 65 20 64 6f 6d 61 69 6e 00
.1a209e					SETINTERACT
.1a209e	08		php		            PHP
.1a209f	0b		phd		            PHD
.1a20a0	08		php		            PHP
.1a20a1	c2 20		rep #$20	            REP #$20
.1a20a3	48		pha		            PHA
.1a20a4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a20a7	5b		tcd		            TCD
.1a20a8	68		pla		            PLA
.1a20a9	28		plp		            PLP
.1a20aa	e2 20		sep #$20	            SEP #$20
.1a20ac	a9 00		lda #$00	            LDA #ST_INTERACT
.1a20ae	85 d2		sta $08d2	            STA STATE
.1a20b0	2b		pld		            PLD
.1a20b1	28		plp		            PLP
.1a20b2	60		rts		            RTS
.1a20b3					CLRINTERP
.1a20b3	0b		phd		            PHD
.1a20b4	08		php		            PHP
.1a20b5	08		php		            PHP
.1a20b6	c2 20		rep #$20	            REP #$20
.1a20b8	48		pha		            PHA
.1a20b9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a20bc	5b		tcd		            TCD
.1a20bd	68		pla		            PLA
.1a20be	28		plp		            PLP
.1a20bf	08		php		            PHP
.1a20c0	c2 20		rep #$20	            REP #$20
.1a20c2	a9 80 1e	lda #$1e80	            LDA #<>ON_ERROR
.1a20c5	8f d4 08 00	sta $0008d4	            STA @lHANDLEERR
.1a20c9	e2 20		sep #$20	            SEP #$20
.1a20cb	a9 1a		lda #$1a	            LDA #`ON_ERROR
.1a20cd	8f d6 08 00	sta $0008d6	            STA @lHANDLEERR+2
.1a20d1	28		plp		            PLP
.1a20d2	20 38 44	jsr $1a4438	            JSR S_CLR
.1a20d5	20 79 3f	jsr $1a3f79	            JSR S_RESTORE
.1a20d8	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the depth of the GOSUB stack
.1a20da	28		plp		            PLP
.1a20db	2b		pld		            PLD
.1a20dc	60		rts		            RTS
.1a20dd					INCBIP
.1a20dd	08		php		            PHP
.1a20de	0b		phd		            PHD
.1a20df	08		php		            PHP
.1a20e0	c2 20		rep #$20	            REP #$20
.1a20e2	48		pha		            PHA
.1a20e3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a20e6	5b		tcd		            TCD
.1a20e7	68		pla		            PLA
.1a20e8	28		plp		            PLP
.1a20e9	c2 20		rep #$20	            REP #$20
.1a20eb	18		clc		            CLC
.1a20ec	a5 00		lda $0800	            LDA BIP
.1a20ee	69 01 00	adc #$0001	            ADC #1
.1a20f1	85 00		sta $0800	            STA BIP
.1a20f3	e2 20		sep #$20	            SEP #$20
.1a20f5	a5 02		lda $0802	            LDA BIP+2
.1a20f7	69 00		adc #$00	            ADC #0
.1a20f9	85 02		sta $0802	            STA BIP+2
.1a20fb	2b		pld		            PLD
.1a20fc	28		plp		            PLP
.1a20fd	60		rts		            RTS
.1a20fe					SKIPWS
.1a20fe	08		php		            PHP
.1a20ff	0b		phd		            PHD
.1a2100	08		php		            PHP
.1a2101	c2 20		rep #$20	            REP #$20
.1a2103	48		pha		            PHA
.1a2104	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2107	5b		tcd		            TCD
.1a2108	68		pla		            PLA
.1a2109	28		plp		            PLP
.1a210a	e2 20		sep #$20	            SEP #$20
.1a210c	a7 00		lda [$0800]	loop        LDA [BIP]
.1a210e	f0 0f		beq $1a211f	            BEQ done            ; If character is 0, we've reached the end of the line
.1a2110	c9 20		cmp #$20	            CMP #CHAR_SP        ; Skip if it's a space
.1a2112	f0 06		beq $1a211a	            BEQ skip_char
.1a2114	c9 09		cmp #$09	            CMP #CHAR_TAB       ; Skip if it's a TAB
.1a2116	f0 02		beq $1a211a	            BEQ skip_char
.1a2118	80 05		bra $1a211f	            BRA done            ; Otherwise, we're done and BIP points to a non-whitespace
.1a211a					skip_char
.1a211a	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a211d	80 ed		bra $1a210c	            BRA loop
.1a211f	2b		pld		done        PLD
.1a2120	28		plp		            PLP
.1a2121	60		rts		            RTS
.1a2122					SKIPSTMT
.1a2122	08		php		            PHP
.1a2123	e2 20		sep #$20	            SEP #$20
.1a2125	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the current character
.1a2127	f0 09		beq $1a2132	            BEQ done            ; Is it EOL? Yes, we're done
.1a2129	c9 3a		cmp #$3a	            CMP #':'            ; Is it a colon?
.1a212b	f0 05		beq $1a2132	            BEQ done            ; Yes, we're done
.1a212d	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a2130	80 f3		bra $1a2125	            BRA loop            ; and check it...
.1a2132	28		plp		done        PLP
.1a2133	60		rts		            RTS
.1a2134					SKIPTOTOK
.1a2134	08		php		            PHP
.1a2135	e2 20		sep #$20	            SEP #$20
.1a2137	64 36		stz $0836	            STZ NESTING
.1a2139	a7 00		lda [$0800]	loop        LDA [BIP]           ; Get the character
.1a213b	f0 19		beq $1a2156	            BEQ end_of_line     ; EOL? Yes: move to the next line
.1a213d	c5 37		cmp $0837	            CMP TARGETTOK       ; Is it the one we want?
.1a213f	f0 2c		beq $1a216d	            BEQ check_depth     ; Yes: check the depth
.1a2141	c9 9b		cmp #$9b	            CMP #TOK_FOR        ; Is it a FOR?
.1a2143	f0 1e		beq $1a2163	            BEQ inc_nesting     ; Yes: increment NESTING
.1a2145	c9 9f		cmp #$9f	            CMP #TOK_DO         ; Is it a DO?
.1a2147	f0 1a		beq $1a2163	            BEQ inc_nesting     ; Yes: increment NESTING
.1a2149	c9 9e		cmp #$9e	            CMP #TOK_NEXT       ; Is it a NEXT?
.1a214b	f0 1a		beq $1a2167	            BEQ dec_nesting     ; Yes: decrement NESTING
.1a214d	c9 a0		cmp #$a0	            CMP #TOK_LOOP       ; Is it a LOOP?
.1a214f	f0 16		beq $1a2167	            BEQ dec_nesting     ; Yes: decrement NESTING
.1a2151					incloop
.1a2151	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a2154	80 e3		bra $1a2139	            BRA loop            ; and keep scanning
.1a2156					end_of_line
.1a2156	20 ba 21	jsr $1a21ba	            JSR NEXTLINE
.1a2159	c2 20		rep #$20	            REP #$20
.1a215b	a5 d7		lda $08d7	            LDA LINENUM         ; Check the line number
.1a215d	f0 1d		beq $1a217c	            BEQ syntax_err1     ; If it's zero, we reached the end of the program
.1a215f	e2 20		sep #$20	            SEP #$20
.1a2161	80 d6		bra $1a2139	            BRA loop            ; And keep scanning
.1a2163					inc_nesting
.1a2163	e6 36		inc $0836	            INC NESTING         ; Track that we have entered a lexical scope for a FOR/DO
.1a2165	80 ea		bra $1a2151	            BRA incloop
.1a2167					dec_nesting
.1a2167	c6 36		dec $0836	            DEC NESTING         ; Track that we have left a lexical scope for a FOR/DO
.1a2169	30 30		bmi $1a219b	            BMI syntax_err2     ; If the depth goes <0, throw a syntax error
.1a216b	80 e4		bra $1a2151	            BRA incloop
.1a216d					check_depth
.1a216d	a5 35		lda $0835	            LDA SKIPNEST        ; Check to see if nesting matters
.1a216f	30 06		bmi $1a2177	            BMI found           ; No: just return that we found the token
.1a2171	a5 36		lda $0836	            LDA NESTING         ; Get the nesting depth
.1a2173	f0 02		beq $1a2177	            BEQ found           ; If it's zero, we found our token
.1a2175	80 da		bra $1a2151	            BRA incloop         ; Otherwise: it's a token for an enclosed FOR/DO, keep scanning
.1a2177					found
.1a2177	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a217a	28		plp		            PLP
.1a217b	60		rts		            RTS
.1a217c					syntax_err1
.1a217c	08		php		            PHP
.1a217d	c2 20		rep #$20	            REP #$20
.1a217f	48		pha		            PHA
.1a2180	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2183	5b		tcd		            TCD
.1a2184	68		pla		            PLA
.1a2185	28		plp		            PLP
.1a2186	e2 20		sep #$20	            SEP #$20
.1a2188	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a218a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a218e	c2 20		rep #$20	            REP #$20
.1a2190	29 ff 00	and #$00ff	            AND #$00FF
.1a2193	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a2196	e2 20		sep #$20	            SEP #$20
.1a2198	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a219b					syntax_err2
.1a219b	08		php		            PHP
.1a219c	c2 20		rep #$20	            REP #$20
.1a219e	48		pha		            PHA
.1a219f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a21a2	5b		tcd		            TCD
.1a21a3	68		pla		            PLA
.1a21a4	28		plp		            PLP
.1a21a5	e2 20		sep #$20	            SEP #$20
.1a21a7	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a21a9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a21ad	c2 20		rep #$20	            REP #$20
.1a21af	29 ff 00	and #$00ff	            AND #$00FF
.1a21b2	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a21b5	e2 20		sep #$20	            SEP #$20
.1a21b7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a21ba					NEXTLINE
.1a21ba	08		php		            PHP
.1a21bb	c2 30		rep #$30	            REP #$30
.1a21bd	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a21c0	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the offset to the next line
.1a21c2	85 0c		sta $080c	            STA SCRATCH
.1a21c4	18		clc		            CLC                 ; Compute the new CURLINE
.1a21c5	a5 1a		lda $081a	            LDA CURLINE         ; CURLINE := [CURLINE].LINE_LINK
.1a21c7	65 0c		adc $080c	            ADC SCRATCH
.1a21c9	85 1a		sta $081a	            STA CURLINE
.1a21cb	a5 1c		lda $081c	            LDA CURLINE+2
.1a21cd	69 00 00	adc #$0000	            ADC #0
.1a21d0	85 1c		sta $081c	            STA CURLINE+2
.1a21d2	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the LINENUM to the new current line's number
.1a21d5	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; LINENUM := [CURLINE].LINE_NUMBER
.1a21d7	85 d7		sta $08d7	            STA LINENUM
.1a21d9	18		clc		            CLC                 ; Point BIP to the first character of the line
.1a21da	a5 1a		lda $081a	            LDA CURLINE         ; BIP := CURLINE + LINE_TOKENS
.1a21dc	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a21df	85 00		sta $0800	            STA BIP
.1a21e1	a5 1c		lda $081c	            LDA CURLINE+2
.1a21e3	69 00 00	adc #$0000	            ADC #0
.1a21e6	85 02		sta $0802	            STA BIP+2
.1a21e8	28		plp		            PLP
.1a21e9	60		rts		            RTS
.1a21ea					EXPECT_TOK
.1a21ea	08		php		            PHP
.1a21eb	e2 20		sep #$20	            SEP #$20
.1a21ed	48		pha		            PHA
.1a21ee	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a21f1	68		pla		            PLA
.1a21f2	e2 20		sep #$20	            SEP #$20
.1a21f4	c7 00		cmp [$0800]	            CMP [BIP]           ; Check the character at BIP
.1a21f6	d0 08		bne $1a2200	            BNE syntax_err      ; Throw a syntax error
.1a21f8	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a21fb	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a21fe	28		plp		            PLP
.1a21ff	60		rts		            RTS
.1a2200					syntax_err
.1a2200	08		php		            PHP
.1a2201	c2 20		rep #$20	            REP #$20
.1a2203	48		pha		            PHA
.1a2204	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2207	5b		tcd		            TCD
.1a2208	68		pla		            PLA
.1a2209	28		plp		            PLP
.1a220a	e2 20		sep #$20	            SEP #$20
.1a220c	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a220e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2212	c2 20		rep #$20	            REP #$20
.1a2214	29 ff 00	and #$00ff	            AND #$00FF
.1a2217	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a221a	e2 20		sep #$20	            SEP #$20
.1a221c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a221f					OPT_TOK
.1a221f	08		php		            PHP
.1a2220	e2 20		sep #$20	            SEP #$20
.1a2222	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a2225	e2 20		sep #$20	            SEP #$20
.1a2227	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the character at BIP
.1a2229	f0 10		beq $1a223b	            BEQ ret_false       ; If end-of-line, return false
.1a222b	c9 3a		cmp #$3a	            CMP #':'
.1a222d	f0 0c		beq $1a223b	            BEQ ret_false       ; If colon, return false
.1a222f	c5 37		cmp $0837	            CMP TARGETTOK
.1a2231	f0 05		beq $1a2238	            BEQ ret_true        ; If matches, return true
.1a2233	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a2236	80 ef		bra $1a2227	            BRA loop
.1a2238	28		plp		ret_true    PLP
.1a2239	38		sec		            SEC
.1a223a	60		rts		            RTS
.1a223b	28		plp		ret_false   PLP
.1a223c	18		clc		            CLC
.1a223d	60		rts		            RTS
.1a223e					PEEK_TOK
.1a223e	5a		phy		            PHY
.1a223f	08		php		            PHP
.1a2240	e2 20		sep #$20	            SEP #$20
.1a2242	a0 00 00	ldy #$0000	            LDY #0
.1a2245	b7 00		lda [$0800],y	loop        LDA [BIP],Y
.1a2247	f0 0d		beq $1a2256	            BEQ done
.1a2249	c9 3a		cmp #$3a	            CMP #':'
.1a224b	f0 07		beq $1a2254	            BEQ ret_null
.1a224d	c9 20		cmp #$20	            CMP #CHAR_SP
.1a224f	d0 05		bne $1a2256	            BNE done
.1a2251	c8		iny		            INY
.1a2252	80 f1		bra $1a2245	            BRA loop
.1a2254	a9 00		lda #$00	ret_null    LDA #0
.1a2256	28		plp		done        PLP
.1a2257	7a		ply		            PLY
.1a2258	60		rts		            RTS
.1a2259					EXECSTMT
.1a2259	08		php		            PHP
.1a225a	0b		phd		            PHD
.1a225b	8b		phb		            PHB
.1a225c	08		php		            PHP
.1a225d	c2 20		rep #$20	            REP #$20
.1a225f	48		pha		            PHA
.1a2260	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2263	5b		tcd		            TCD
.1a2264	68		pla		            PLA
.1a2265	28		plp		            PLP
.1a2266	20 4b 19	jsr $1a194b	            JSR INITEVALSP
.1a2269	e2 20		sep #$20	            SEP #$20
.1a226b	a9 00		lda #$00	            LDA #EXEC_CONT      ; This will tell EXECLINE and EXECPROG to procede in a
.1a226d	85 dc		sta $08dc	            STA EXECACTION      ; linear fashion through the program
.1a226f	22 3c 11 00	jsl $00113c	check_break JSL FK_TESTBREAK
.1a2273	b0 4b		bcs $1a22c0	            BCS throw_break     ; If C: user pressed an interrupt key, stop the program
.1a2275	a7 00		lda [$0800]	            LDA [BIP]           ; If we happen to have a colon, just skip over it.
.1a2277	c9 3a		cmp #$3a	            CMP #':'            ; This can happen with FOR/NEXT
.1a2279	d0 03		bne $1a227e	            BNE eat_ws
.1a227b	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a227e					eat_ws
.1a227e	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a2281	a7 00		lda [$0800]	            LDA [BIP]
.1a2283	d0 03		bne $1a2288	            BNE else
.1a2285	4c 0a 23	jmp $1a230a	            JMP done            ; If the current byte is 0, we're at the end of the line, just return
.1a2288					else
.1a2288	20 a7 04	jsr $1a04a7	            JSR ISALPHA
.1a228b	b0 52		bcs $1a22df	            BCS is_variable     ; Yes: we may have a LET statement
.1a228d	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it's any other non-token
.1a228f	10 10		bpl $1a22a1	            BPL error           ; Yes: it's a syntax error
.1a2291	20 6f 0c	jsr $1a0c6f	            JSR TOKTYPE
.1a2294	85 0c		sta $080c	            STA SCRATCH         ; Save the type for later
.1a2296	c9 20		cmp #$20	            CMP #TOK_TY_STMNT   ; Is it a statement?
.1a2298	d0 03		bne $1a229d	            BNE else2
.1a229a	4c f8 22	jmp $1a22f8	            JMP ok_to_exec      ; Yes: it's ok to try to execute it
.1a229d	a5 d2		lda $08d2	else2       LDA STATE           ; Check to see if we're in interactive mode
.1a229f	f0 51		beq $1a22f2	            BEQ is_interact
.1a22a1					error
.1a22a1	08		php		            PHP
.1a22a2	c2 20		rep #$20	            REP #$20
.1a22a4	48		pha		            PHA
.1a22a5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a22a8	5b		tcd		            TCD
.1a22a9	68		pla		            PLA
.1a22aa	28		plp		            PLP
.1a22ab	e2 20		sep #$20	            SEP #$20
.1a22ad	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a22af	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a22b3	c2 20		rep #$20	            REP #$20
.1a22b5	29 ff 00	and #$00ff	            AND #$00FF
.1a22b8	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a22bb	e2 20		sep #$20	            SEP #$20
.1a22bd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a22c0					throw_break
.1a22c0	08		php		            PHP
.1a22c1	c2 20		rep #$20	            REP #$20
.1a22c3	48		pha		            PHA
.1a22c4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a22c7	5b		tcd		            TCD
.1a22c8	68		pla		            PLA
.1a22c9	28		plp		            PLP
.1a22ca	e2 20		sep #$20	            SEP #$20
.1a22cc	a9 01		lda #$01	            LDA #ERR_BREAK
.1a22ce	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a22d2	c2 20		rep #$20	            REP #$20
.1a22d4	29 ff 00	and #$00ff	            AND #$00FF
.1a22d7	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a22da	e2 20		sep #$20	            SEP #$20
.1a22dc	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a22df					is_variable
.1a22df	20 42 44	jsr $1a4442	            JSR S_LET
.1a22e2	4c 0a 23	jmp $1a230a	            JMP done
.1a22e5					STSTUB
.1a22e5	08		php		            PHP
.1a22e6	e2 20		sep #$20	            SEP #$20
.1a22e8	48		pha		            PHA
.1a22e9	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a22eb	48		pha		            PHA
.1a22ec	ab		plb		            PLB
.1a22ed	68		pla		            PLA
.1a22ee	28		plp		            PLP
.1a22ef	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.1a22f2	a5 0c		lda $080c	is_interact LDA SCRATCH         ; Get the token type
.1a22f4	c9 10		cmp #$10	            CMP #TOK_TY_CMD     ; Is it a command?
.1a22f6	d0 a9		bne $1a22a1	            BNE error           ; If not, it's an error
.1a22f8					ok_to_exec
.1a22f8	a7 00		lda [$0800]	            LDA [BIP]           ; Get the original token again
.1a22fa	20 4c 0c	jsr $1a0c4c	            JSR TOKEVAL
.1a22fd	c2 20		rep #$20	            REP #$20
.1a22ff	85 2f		sta $082f	            STA JMP16PTR        ; Store it in the jump pointer
.1a2301	20 4b 19	jsr $1a194b	            JSR INITEVALSP
.1a2304	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a2307	20 e5 22	jsr $1a22e5	            JSR STSTUB
.1a230a	ab		plb		done        PLB
.1a230b	2b		pld		            PLD
.1a230c	28		plp		            PLP
.1a230d	60		rts		            RTS
.1a230e					EXECCMD
.1a230e	08		php		            PHP
.1a230f	58		cli		            CLI
.1a2310	20 9e 20	jsr $1a209e	            JSR SETINTERACT
.1a2313	20 c3 1d	jsr $1a1dc3	            JSR INITRETURN
.1a2316	e2 20		sep #$20	            SEP #$20
.1a2318	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.1a231b	c2 20		rep #$20	            REP #$20
.1a231d	a5 1a		lda $081a	            LDA CURLINE         ; Set the BASIC Instruction Pointer to the first byte of the line
.1a231f	85 00		sta $0800	            STA BIP
.1a2321	a5 1c		lda $081c	            LDA CURLINE+2
.1a2323	85 02		sta $0802	            STA BIP+2
.1a2325	4c 4f 23	jmp $1a234f	            JMP exec_loop
.1a2328	08		php		EXECLINE    PHP
.1a2329	c2 20		rep #$20	            REP #$20
.1a232b	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER            ; Set the current line number
.1a232e	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.1a2330	85 d7		sta $08d7	            STA LINENUM
.1a2332	20 b8 14	jsr $1a14b8	            JSR CLRTMPSTR
.1a2335	e2 20		sep #$20	            SEP #$20
.1a2337	a5 dc		lda $08dc	            LDA EXECACTION              ; If the last EXEC action was RETURN
.1a2339	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; BIP has already been set, so...
.1a233b	f0 12		beq $1a234f	            BEQ exec_loop               ; Skip over setting the BIP to the beginning of the line
.1a233d	c2 20		rep #$20	            REP #$20
.1a233f	18		clc		            CLC                         ; Set the BASIC Instruction Pointer to the first byte of the line
.1a2340	a5 1a		lda $081a	            LDA CURLINE
.1a2342	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a2345	85 00		sta $0800	            STA BIP
.1a2347	e2 20		sep #$20	            SEP #$20
.1a2349	a5 1c		lda $081c	            LDA CURLINE+2
.1a234b	69 00		adc #$00	            ADC #0
.1a234d	85 02		sta $0802	            STA BIP+2
.1a234f					exec_loop
.1a234f	c2 20		rep #$20	            REP #$20
.1a2351	20 59 22	jsr $1a2259	            JSR EXECSTMT
.1a2354	e2 20		sep #$20	            SEP #$20
.1a2356	a5 dc		lda $08dc	            LDA EXECACTION
.1a2358	c9 03		cmp #$03	            CMP #EXEC_RETURN
.1a235a	f0 f3		beq $1a234f	            BEQ exec_loop
.1a235c	c9 00		cmp #$00	            CMP #EXEC_CONT              ; If it's not EXEC_CONT, exit to the caller
.1a235e	d0 31		bne $1a2391	            BNE exec_done
.1a2360	e2 20		sep #$20	            SEP #$20
.1a2362	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a2365	a7 00		lda [$0800]	            LDA [BIP]                   ; Get the current character in the line
.1a2367	f0 28		beq $1a2391	            BEQ exec_done               ; If it's NULL, we're done
.1a2369	c9 3a		cmp #$3a	            CMP #':'                    ; If it's colon, we have more statements
.1a236b	f0 1f		beq $1a238c	            BEQ skip_loop               ; Skip over it and try to execute the next one
.1a236d	08		php		            PHP
.1a236e	c2 20		rep #$20	            REP #$20
.1a2370	48		pha		            PHA
.1a2371	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2374	5b		tcd		            TCD
.1a2375	68		pla		            PLA
.1a2376	28		plp		            PLP
.1a2377	e2 20		sep #$20	            SEP #$20
.1a2379	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a237b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a237f	c2 20		rep #$20	            REP #$20
.1a2381	29 ff 00	and #$00ff	            AND #$00FF
.1a2384	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a2387	e2 20		sep #$20	            SEP #$20
.1a2389	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a238c					skip_loop
.1a238c	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a238f	80 be		bra $1a234f	            BRA exec_loop               ; And try to execute another statement
.1a2391					exec_done
.1a2391	28		plp		            PLP
.1a2392	60		rts		            RTS
.1a2393					EXECPROGRAM
.1a2393	08		php		            PHP
.1a2394	58		cli		            CLI
.1a2395	e2 20		sep #$20	            SEP #$20
.1a2397	a9 80		lda #$80	            LDA #ST_RUNNING
.1a2399	85 d2		sta $08d2	            STA STATE
.1a239b	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.1a239e	20 c3 1d	jsr $1a1dc3	            JSR INITRETURN
.1a23a1	c2 30		rep #$30	            REP #$30
.1a23a3	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the count of GOSUBs
.1a23a5	a0 02 00	ldy #$0002	exec_loop   LDY #LINE_NUMBER
.1a23a8	b7 1a		lda [$081a],y	            LDA [CURLINE],Y             ; Get the line number of the current line
.1a23aa	f0 29		beq $1a23d5	            BEQ done                    ; If it's 0, we are finished running code (implicit END)
.1a23ac	20 28 23	jsr $1a2328	            JSR EXECLINE
.1a23af	e2 20		sep #$20	            SEP #$20
.1a23b1	a5 dc		lda $08dc	            LDA EXECACTION              ; Check the EXECACTION from the last line
.1a23b3	c9 01		cmp #$01	            CMP #EXEC_STOP              ; Stop execution of the program?
.1a23b5	f0 1e		beq $1a23d5	            BEQ done
.1a23b7	c9 02		cmp #$02	            CMP #EXEC_GOTO              ; Transfer execution to a new CURLINE that is already set
.1a23b9	f0 ea		beq $1a23a5	            BEQ exec_loop
.1a23bb	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; Transfer execution to the CURLINE and BIP that is already set
.1a23bd	f0 e6		beq $1a23a5	            BEQ exec_loop
.1a23bf	c2 20		rep #$20	            REP #$20
.1a23c1	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a23c4	18		clc		            CLC
.1a23c5	a5 1a		lda $081a	            LDA CURLINE
.1a23c7	77 1a		adc [$081a],y	            ADC [CURLINE],Y
.1a23c9	85 1a		sta $081a	            STA CURLINE
.1a23cb	e2 20		sep #$20	            SEP #$20
.1a23cd	a5 1c		lda $081c	            LDA CURLINE+2
.1a23cf	69 00		adc #$00	            ADC #0
.1a23d1	85 1c		sta $081c	            STA CURLINE+2
.1a23d3	80 d0		bra $1a23a5	            BRA exec_loop               ; And try to execute that line
.1a23d5					done
.1a23d5	e2 20		sep #$20	            SEP #$20
.1a23d7	a9 00		lda #$00	            LDA #ST_INTERACT            ; Set interpreter state to RUNNING
.1a23d9	85 d2		sta $08d2	            STA STATE
.1a23db	28		plp		            PLP
.1a23dc	60		rts		            RTS
.1a23dd					FINDLINE
.1a23dd	08		php		            PHP
.1a23de	c2 30		rep #$30	            REP #$30
.1a23e0	c2 20		rep #$20	            REP #$20
.1a23e2	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT            ; INDEX points to the first line of the program
.1a23e5	85 08		sta $0808	            STA INDEX
.1a23e7	a9 16 00	lda #$0016	            LDA #`BASIC_BOT
.1a23ea	85 0a		sta $080a	            STA INDEX+2
.1a23ec	c2 20		rep #$20	            REP #$20
.1a23ee	a0 02 00	ldy #$0002	check_nmbrs LDY #LINE_NUMBER            ; Get the number of the possible target line
.1a23f1	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a23f3	f0 31		beq $1a2426	            BEQ ret_false               ; If new line number is 0, we got to the
.1a23f5	c5 23		cmp $0823	            CMP ARGUMENT1               ; Compare it to the target line number
.1a23f7	f0 1e		beq $1a2417	            BEQ found
.1a23f9	b0 2b		bcs $1a2426	            BGE ret_false               ; If the line number > target line number, the line is not present
.1a23fb					next_line
.1a23fb	c2 20		rep #$20	            REP #$20
.1a23fd	a0 00 00	ldy #$0000	            LDY #LINE_LINK              ; INDEX := INDEX + [INDEX].LINK
.1a2400	18		clc		            CLC
.1a2401	a5 08		lda $0808	            LDA INDEX
.1a2403	77 08		adc [$0808],y	            ADC [INDEX],Y
.1a2405	85 0c		sta $080c	            STA SCRATCH
.1a2407	e2 20		sep #$20	            SEP #$20
.1a2409	a5 0a		lda $080a	            LDA INDEX+2
.1a240b	69 00		adc #$00	            ADC #0
.1a240d	85 0a		sta $080a	            STA INDEX+2
.1a240f	c2 20		rep #$20	            REP #$20
.1a2411	a5 0c		lda $080c	            LDA SCRATCH
.1a2413	85 08		sta $0808	            STA INDEX
.1a2415	80 d7		bra $1a23ee	            BRA check_nmbrs             ; And go back to check the new line INDEX is pointing to
.1a2417					found
.1a2417	c2 20		rep #$20	            REP #$20
.1a2419	a5 08		lda $0808	            LDA INDEX
.1a241b	85 1a		sta $081a	            STA CURLINE
.1a241d	e2 20		sep #$20	            SEP #$20
.1a241f	a5 0a		lda $080a	            LDA INDEX+2
.1a2421	85 1c		sta $081c	            STA CURLINE+2
.1a2423	28		plp		ret_true    PLP                         ; Return true to indicate we've found the line
.1a2424	38		sec		            SEC
.1a2425	60		rts		            RTS
.1a2426	28		plp		ret_false   PLP
.1a2427	18		clc		            CLC
.1a2428	60		rts		            RTS
.1a2429					MVPROGDN
.1a2429	08		php		            PHP
.1a242a					mvd_loop
.1a242a	e2 20		sep #$20	            SEP #$20
.1a242c	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.1a242e	87 08		sta [$0808]	            STA [INDEX]
.1a2430	c2 20		rep #$20	            REP #$20
.1a2432	a5 0c		lda $080c	            LDA SCRATCH
.1a2434	c5 00		cmp $0800	            CMP BIP
.1a2436	d0 08		bne $1a2440	            BNE increment
.1a2438	e2 20		sep #$20	            SEP #$20
.1a243a	a5 0e		lda $080e	            LDA SCRATCH+2
.1a243c	c5 02		cmp $0802	            CMP BIP+2
.1a243e	f0 26		beq $1a2466	            BEQ done            ; Yes: return
.1a2440					increment
.1a2440	c2 20		rep #$20	            REP #$20
.1a2442	18		clc		            CLC
.1a2443	a5 0c		lda $080c	            LDA SCRATCH
.1a2445	69 01 00	adc #$0001	            ADC #1
.1a2448	85 0c		sta $080c	            STA SCRATCH
.1a244a	e2 20		sep #$20	            SEP #$20
.1a244c	a5 0e		lda $080e	            LDA SCRATCH+2
.1a244e	69 00		adc #$00	            ADC #0
.1a2450	85 0e		sta $080e	            STA SCRATCH+2
.1a2452	c2 20		rep #$20	            REP #$20
.1a2454	18		clc		            CLC
.1a2455	a5 08		lda $0808	            LDA INDEX
.1a2457	69 01 00	adc #$0001	            ADC #1
.1a245a	85 08		sta $0808	            STA INDEX
.1a245c	e2 20		sep #$20	            SEP #$20
.1a245e	a5 0a		lda $080a	            LDA INDEX+2
.1a2460	69 00		adc #$00	            ADC #0
.1a2462	85 0a		sta $080a	            STA INDEX+2
.1a2464	80 c4		bra $1a242a	            BRA mvd_loop        ; And try again
.1a2466	28		plp		done        PLP
.1a2467	60		rts		            RTS
.1a2468					MVPROGUP
.1a2468	08		php		            PHP
.1a2469					mvu_loop
.1a2469	e2 20		sep #$20	            SEP #$20
.1a246b	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.1a246d	87 08		sta [$0808]	            STA [INDEX]
.1a246f	c2 20		rep #$20	            REP #$20
.1a2471	a5 0c		lda $080c	            LDA SCRATCH
.1a2473	c5 00		cmp $0800	            CMP BIP
.1a2475	d0 06		bne $1a247d	            BNE decrement
.1a2477	a5 0e		lda $080e	            LDA SCRATCH+2
.1a2479	c5 02		cmp $0802	            CMP BIP+2
.1a247b	f0 26		beq $1a24a3	            BEQ done            ; Yes: return
.1a247d					decrement
.1a247d	c2 20		rep #$20	            REP #$20
.1a247f	38		sec		            SEC
.1a2480	a5 0c		lda $080c	            LDA SCRATCH
.1a2482	e9 01 00	sbc #$0001	            SBC #1
.1a2485	85 0c		sta $080c	            STA SCRATCH
.1a2487	e2 20		sep #$20	            SEP #$20
.1a2489	a5 0e		lda $080e	            LDA SCRATCH+2
.1a248b	e9 00		sbc #$00	            SBC #0
.1a248d	85 0e		sta $080e	            STA SCRATCH+2
.1a248f	c2 20		rep #$20	            REP #$20
.1a2491	38		sec		            SEC
.1a2492	a5 08		lda $0808	            LDA INDEX
.1a2494	e9 01 00	sbc #$0001	            SBC #1
.1a2497	85 08		sta $0808	            STA INDEX
.1a2499	e2 20		sep #$20	            SEP #$20
.1a249b	a5 0a		lda $080a	            LDA INDEX+2
.1a249d	e9 00		sbc #$00	            SBC #0
.1a249f	85 0a		sta $080a	            STA INDEX+2
.1a24a1	80 c6		bra $1a2469	            BRA mvu_loop        ; And try again
.1a24a3	28		plp		done        PLP
.1a24a4	60		rts		            RTS
.1a24a5					DELLINE
.1a24a5	08		php		            PHP
.1a24a6	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; SCRATCH := INDEX + [INDEX].LINK (address of the following line)
.1a24a9	c2 20		rep #$20	            REP #$20
.1a24ab	18		clc		            CLC
.1a24ac	a5 08		lda $0808	            LDA INDEX
.1a24ae	77 08		adc [$0808],y	            ADC [INDEX],Y
.1a24b0	85 0c		sta $080c	            STA SCRATCH
.1a24b2	e2 20		sep #$20	            SEP #$20
.1a24b4	a5 0a		lda $080a	            LDA INDEX+2
.1a24b6	69 00		adc #$00	            ADC #0
.1a24b8	85 0e		sta $080e	            STA SCRATCH+2
.1a24ba	c2 20		rep #$20	            REP #$20
.1a24bc	18		clc		            CLC
.1a24bd	a5 d9		lda $08d9	            LDA LASTLINE
.1a24bf	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a24c2	85 00		sta $0800	            STA BIP
.1a24c4	e2 20		sep #$20	            SEP #$20
.1a24c6	a5 db		lda $08db	            LDA LASTLINE+2
.1a24c8	69 00		adc #$00	            ADC #0
.1a24ca	85 02		sta $0802	            STA BIP+2
.1a24cc	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; LASTLINE := LASTLINE - [INDEX].LINK
.1a24cf	c2 20		rep #$20	            REP #$20
.1a24d1	38		sec		            SEC
.1a24d2	a5 d9		lda $08d9	            LDA LASTLINE
.1a24d4	f7 08		sbc [$0808],y	            SBC [INDEX],Y
.1a24d6	85 d9		sta $08d9	            STA LASTLINE
.1a24d8	e2 20		sep #$20	            SEP #$20
.1a24da	a5 db		lda $08db	            LDA LASTLINE+2
.1a24dc	e9 00		sbc #$00	            SBC #0
.1a24de	85 db		sta $08db	            STA LASTLINE+2
.1a24e0	20 29 24	jsr $1a2429	            JSR MVPROGDN
.1a24e3					done
.1a24e3	20 38 44	jsr $1a4438	            JSR S_CLR
.1a24e6	28		plp		            PLP
.1a24e7	60		rts		            RTS
.1a24e8					APPLINE
.1a24e8	08		php		            PHP
.1a24e9	08		php		            PHP
.1a24ea	c2 20		rep #$20	            REP #$20
.1a24ec	48		pha		            PHA
.1a24ed	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a24f0	5b		tcd		            TCD
.1a24f1	68		pla		            PLA
.1a24f2	28		plp		            PLP
.1a24f3	c2 30		rep #$30	            REP #$30
.1a24f5	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the line number of the new line
.1a24f8	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.1a24fa	18		clc		            CLC                 ; Point INDEX to the position to store the tokens
.1a24fb	a5 d9		lda $08d9	            LDA LASTLINE
.1a24fd	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a2500	85 08		sta $0808	            STA INDEX
.1a2502	e2 20		sep #$20	            SEP #$20
.1a2504	a5 db		lda $08db	            LDA LASTLINE+2
.1a2506	69 00		adc #$00	            ADC #0
.1a2508	85 0a		sta $080a	            STA INDEX+2
.1a250a	e2 20		sep #$20	            SEP #$20
.1a250c	a0 00 00	ldy #$0000	            LDY #0
.1a250f	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Copy the tokenized line to its place in the code
.1a2511	97 08		sta [$0808],y	            STA [INDEX],Y
.1a2513	f0 03		beq $1a2518	            BEQ copy_done
.1a2515	c8		iny		            INY
.1a2516	80 f7		bra $1a250f	            BRA copy_loop
.1a2518					copy_done
.1a2518	c2 20		rep #$20	            REP #$20
.1a251a	98		tya		            TYA
.1a251b	18		clc		            CLC
.1a251c	69 05 00	adc #$0005	            ADC #LINE_TOKENS+1
.1a251f	85 0c		sta $080c	            STA SCRATCH
.1a2521	c2 20		rep #$20	            REP #$20
.1a2523	a0 00 00	ldy #$0000	            LDY #LINE_LINK      ; Set link to the offset to the next line
.1a2526	a5 0c		lda $080c	            LDA SCRATCH
.1a2528	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.1a252a	c2 20		rep #$20	            REP #$20
.1a252c	18		clc		            CLC
.1a252d	a5 d9		lda $08d9	            LDA LASTLINE
.1a252f	65 0c		adc $080c	            ADC SCRATCH
.1a2531	85 0c		sta $080c	            STA SCRATCH
.1a2533	e2 20		sep #$20	            SEP #$20
.1a2535	a5 db		lda $08db	            LDA LASTLINE+2
.1a2537	69 00		adc #$00	            ADC #0
.1a2539	85 db		sta $08db	            STA LASTLINE+2
.1a253b	c2 20		rep #$20	            REP #$20
.1a253d	a5 0c		lda $080c	            LDA SCRATCH
.1a253f	85 d9		sta $08d9	            STA LASTLINE
.1a2541	c2 20		rep #$20	            REP #$20
.1a2543	a0 00 00	ldy #$0000	            LDY #0
.1a2546	a9 00 00	lda #$0000	            LDA #0
.1a2549	97 d9		sta [$08d9],y	blank_loop  STA [LASTLINE],Y    ; Set the "line" after the last line to nulls
.1a254b	c8		iny		            INY
.1a254c	c0 05 00	cpy #$0005	            CPY #LINE_TOKENS+1
.1a254f	d0 f8		bne $1a2549	            BNE blank_loop
.1a2551	20 38 44	jsr $1a4438	            JSR S_CLR
.1a2554	28		plp		            PLP
.1a2555	60		rts		            RTS
.1a2556					FINDINSPT
.1a2556	0b		phd		            PHD
.1a2557	08		php		            PHP
.1a2558	08		php		            PHP
.1a2559	c2 20		rep #$20	            REP #$20
.1a255b	48		pha		            PHA
.1a255c	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a255f	5b		tcd		            TCD
.1a2560	68		pla		            PLA
.1a2561	28		plp		            PLP
.1a2562	c2 30		rep #$30	            REP #$30
.1a2564	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.1a2567	85 08		sta $0808	            STA INDEX
.1a2569	a9 16 00	lda #$0016	            LDA #`BASIC_BOT
.1a256c	85 0a		sta $080a	            STA INDEX+2
.1a256e	a0 02 00	ldy #$0002	loop        LDY #LINE_NUMBER
.1a2571	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a2573	f0 1d		beq $1a2592	            BEQ found_end           ; Got to end without finding it
.1a2575	c5 d7		cmp $08d7	            CMP LINENUM
.1a2577	f0 25		beq $1a259e	            BEQ found_line          ; LINENUM = [INDEX].LINE_NUMBER: return we found the exact line
.1a2579	b0 1d		bcs $1a2598	            BGE found_spot          ; LINENUM > [INDEX].LINE_NUMBER: return we found spot to insert
.1a257b	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a257e	18		clc		            CLC                     ; Move INDEX to the next line
.1a257f	a5 08		lda $0808	            LDA INDEX
.1a2581	77 08		adc [$0808],y	            ADC [INDEX],Y
.1a2583	85 0c		sta $080c	            STA SCRATCH
.1a2585	a5 0a		lda $080a	            LDA INDEX+2
.1a2587	69 00 00	adc #$0000	            ADC #0
.1a258a	85 0a		sta $080a	            STA INDEX+2
.1a258c	a5 0c		lda $080c	            LDA SCRATCH
.1a258e	85 08		sta $0808	            STA INDEX
.1a2590	80 dc		bra $1a256e	            BRA loop                ; And check that line
.1a2592	a9 00 00	lda #$0000	found_end   LDA #0                  ; Return that we reached the end of the program
.1a2595	28		plp		            PLP
.1a2596	2b		pld		            PLD
.1a2597	60		rts		            RTS
.1a2598	a9 01 00	lda #$0001	found_spot  LDA #1                  ; Return that we the found the spot to insert the line
.1a259b	28		plp		            PLP                     ; But that it wasn't already there
.1a259c	2b		pld		            PLD
.1a259d	60		rts		            RTS
.1a259e	a9 02 00	lda #$0002	found_line  LDA #2                  ; Return that we found the line
.1a25a1	28		plp		            PLP
.1a25a2	2b		pld		            PLD
.1a25a3	60		rts		            RTS
.1a25a4					INSLINE
.1a25a4	08		php		            PHP
.1a25a5	c2 30		rep #$30	            REP #$30
.1a25a7	a9 05 00	lda #$0005	            LDA #LINE_TOKENS+1  ; Set SCRATCH2 to the size of the line header with the end-of-line
.1a25aa	85 10		sta $0810	            STA SCRATCH2
.1a25ac	a0 00 00	ldy #$0000	            LDY #0
.1a25af					count_loop
.1a25af	e2 20		sep #$20	            SEP #$20
.1a25b1	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the byte of the line
.1a25b3	f0 07		beq $1a25bc	            BEQ shift_prog      ; If it's end-of-line, SCRATCH2 is the length
.1a25b5	c2 20		rep #$20	            REP #$20
.1a25b7	e6 10		inc $0810	            INC SCRATCH2
.1a25b9	c8		iny		            INY
.1a25ba	80 f3		bra $1a25af	            BRA count_loop      ; Count and continue
.1a25bc					shift_prog
.1a25bc	c2 20		rep #$20	            REP #$20
.1a25be	a5 08		lda $0808	            LDA INDEX           ; BIP = the address of the first byte for the new line
.1a25c0	85 00		sta $0800	            STA BIP
.1a25c2	a5 0a		lda $080a	            LDA INDEX+2
.1a25c4	85 02		sta $0802	            STA BIP+2
.1a25c6	18		clc		            CLC                 ; SCRATCH = address of highest byte to copy
.1a25c7	a5 d9		lda $08d9	            LDA LASTLINE
.1a25c9	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a25cc	85 0c		sta $080c	            STA SCRATCH
.1a25ce	a5 db		lda $08db	            LDA LASTLINE+2
.1a25d0	69 00 00	adc #$0000	            ADC #0
.1a25d3	85 0e		sta $080e	            STA SCRATCH+2
.1a25d5	18		clc		            CLC                 ; Adjust LASTLINE to its new position after the insert
.1a25d6	a5 d9		lda $08d9	            LDA LASTLINE
.1a25d8	65 10		adc $0810	            ADC SCRATCH2
.1a25da	85 d9		sta $08d9	            STA LASTLINE
.1a25dc	a5 db		lda $08db	            LDA LASTLINE+2
.1a25de	69 00 00	adc #$0000	            ADC #0
.1a25e1	85 db		sta $08db	            STA LASTLINE+2
.1a25e3	18		clc		            CLC                 ; INDEX = address of the highest location to copy into
.1a25e4	a5 d9		lda $08d9	            LDA LASTLINE
.1a25e6	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a25e9	85 08		sta $0808	            STA INDEX
.1a25eb	a5 db		lda $08db	            LDA LASTLINE+2
.1a25ed	69 00 00	adc #$0000	            ADC #0
.1a25f0	85 0a		sta $080a	            STA INDEX+2
.1a25f2	20 68 24	jsr $1a2468	            JSR MVPROGUP
.1a25f5	c2 20		rep #$20	            REP #$20
.1a25f7	a5 10		lda $0810	            LDA SCRATCH2
.1a25f9	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a25fc	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINK_LINK = length of the new line
.1a25fe	a5 d7		lda $08d7	            LDA LINENUM
.1a2600	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.1a2603	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINE_NUMBER = number of the new line
.1a2605	18		clc		            CLC                 ; Point BIP to the first byte of the new line
.1a2606	a5 00		lda $0800	            LDA BIP
.1a2608	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a260b	85 00		sta $0800	            STA BIP
.1a260d	a5 02		lda $0802	            LDA BIP+2
.1a260f	69 00 00	adc #$0000	            ADC #0
.1a2612	85 02		sta $0802	            STA BIP+2
.1a2614	a0 00 00	ldy #$0000	            LDY #0
.1a2617	e2 20		sep #$20	            SEP #$20
.1a2619	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Get the byte of the tokenized line
.1a261b	97 00		sta [$0800],y	            STA [BIP],Y         ; Copy it to its correct location in the program
.1a261d	f0 03		beq $1a2622	            BEQ done            ; If it was end-of-line byte, we're done
.1a261f	c8		iny		            INY
.1a2620	80 f7		bra $1a2619	            BRA copy_loop       ; Otherwise, continue with the next
.1a2622					done
.1a2622	20 38 44	jsr $1a4438	            JSR S_CLR
.1a2625	28		plp		            PLP
.1a2626	60		rts		            RTS
.1a2627					ADDLINE
.1a2627	08		php		            PHP
.1a2628	c2 30		rep #$30	            REP #$30
.1a262a	85 d7		sta $08d7	            STA LINENUM
.1a262c	20 56 25	jsr $1a2556	            JSR FINDINSPT
.1a262f	c9 00 00	cmp #$0000	            CMP #0
.1a2632	f0 2c		beq $1a2660	            BEQ do_append       ; End-of-program found, add the line to the end
.1a2634	c9 01 00	cmp #$0001	            CMP #1
.1a2637	f0 22		beq $1a265b	            BEQ do_insert       ; Spot was found: insertion required
.1a2639	c2 20		rep #$20	            REP #$20
.1a263b	a5 08		lda $0808	            LDA INDEX
.1a263d	48		pha		            PHA
.1a263e	a5 0a		lda $080a	            LDA INDEX+2
.1a2640	48		pha		            PHA
.1a2641	20 a5 24	jsr $1a24a5	            JSR DELLINE
.1a2644	68		pla		            PLA
.1a2645	85 0a		sta $080a	            STA INDEX+2
.1a2647	68		pla		            PLA
.1a2648	85 08		sta $0808	            STA INDEX
.1a264a	a5 1a		lda $081a	            LDA CURLINE         ; Check to see if there is any non-whitespace on the line
.1a264c	85 00		sta $0800	            STA BIP
.1a264e	a5 1c		lda $081c	            LDA CURLINE+2
.1a2650	85 02		sta $0802	            STA BIP+2
.1a2652	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a2655	e2 20		sep #$20	            SEP #$20
.1a2657	a7 00		lda [$0800]	            LDA [BIP]
.1a2659	f0 0a		beq $1a2665	            BEQ done            ; If not, we're done
.1a265b					do_insert
.1a265b	20 a4 25	jsr $1a25a4	            JSR INSLINE
.1a265e	80 05		bra $1a2665	            BRA done
.1a2660	a5 d7		lda $08d7	do_append   LDA LINENUM
.1a2662	20 e8 24	jsr $1a24e8	            JSR APPLINE
.1a2665	28		plp		done        PLP
.1a2666	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\repl.s

="#"					CHAR_DIR = '#'
="|"					CHAR_BRUN = '|'
.1a2667					EXPANDLINE
.1a2667	0b		phd		                PHD
.1a2668	08		php		                PHP
.1a2669	08		php		            PHP
.1a266a	c2 20		rep #$20	            REP #$20
.1a266c	48		pha		            PHA
.1a266d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a2670	5b		tcd		            TCD
.1a2671	68		pla		            PLA
.1a2672	28		plp		            PLP
.1a2673	e2 20		sep #$20	            SEP #$20
.1a2675	c2 10		rep #$10	            REP #$10
.1a2677	a2 00 00	ldx #$0000	                LDX #0
.1a267a	bd 00 4f	lda $4f00,x	count_loop      LDA INPUTBUF,X              ; Count the number of characters in the input
.1a267d	f0 03		beq $1a2682	                BEQ save_size
.1a267f	e8		inx		                INX
.1a2680	80 f8		bra $1a267a	                BRA count_loop
.1a2682	86 0c		stx $080c	save_size       STX SCRATCH                 ; Save the size in SCRATCH
.1a2684	c2 30		rep #$30	            REP #$30
.1a2686	8a		txa		                TXA
.1a2687	c9 02 00	cmp #$0002	                CMP #2                      ; Are there arguments?
.1a268a	90 12		bcc $1a269e	                BLT start_copy              ; No: just replace the whole string
.1a268c	3a		dec a		                DEC A
.1a268d	18		clc		                CLC
.1a268e	69 00 4f	adc #$4f00	                ADC #<>INPUTBUF
.1a2691	aa		tax		                TAX                         ; X <-- INPUTBUF + len(INPUTBUF) - 1
.1a2692	18		clc		                CLC                         ; Y <-- INPUTBUF + len(INPUTBUF) - 1 + len(substitution)
.1a2693	65 8f		adc $088f	                ADC MCOUNT
.1a2695	a8		tay		                TAY
.1a2696	a5 0c		lda $080c	                LDA SCRATCH
.1a2698	3a		dec a		                DEC A
.1a2699	8b		phb		                PHB
.1a269a	44 00 00	mvp #$00,#$00	                MVP #`INPUTBUF,#`INPUTBUF   ; Make room for the substitition
.1a269d	ab		plb		                PLB
.1a269e					start_copy
.1a269e	c2 20		rep #$20	            REP #$20
.1a26a0	a6 55		ldx $0855	                LDX MARG1                   ; Source is data to copy
.1a26a2	a0 00 4f	ldy #$4f00	                LDY #<>INPUTBUF             ; Destination is input buffer
.1a26a5	a5 8f		lda $088f	                LDA MCOUNT                  ; Number of bytes to copy
.1a26a7	8b		phb		                PHB
.1a26a8	54 00 1a	mvn #$1a,#$00	                MVN #`EXPANDLINE,#`INPUTBUF ; Copy the data
.1a26ab	ab		plb		                PLB
.1a26ac	e2 20		sep #$20	            SEP #$20
.1a26ae	a5 0c		lda $080c	                LDA SCRATCH                 ; Check again to see if we need quotes
.1a26b0	c9 02		cmp #$02	                CMP #2
.1a26b2	90 18		bcc $1a26cc	                BLT done
.1a26b4	a6 8f		ldx $088f	                LDX MCOUNT                  ; If so, add a quote mark here
.1a26b6	a9 22		lda #$22	                LDA #CHAR_DQUOTE
.1a26b8	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a26bb	e8		inx		skip_to_end     INX                         ; Move to the end of the input string
.1a26bc	bd 00 4f	lda $4f00,x	                LDA INPUTBUF,X
.1a26bf	d0 fa		bne $1a26bb	                BNE skip_to_end
.1a26c1	a9 22		lda #$22	                LDA #CHAR_DQUOTE            ; Add the quote to the end of the string
.1a26c3	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a26c6	a9 00		lda #$00	                LDA #0                      ; And terminate with a NULL
.1a26c8	e8		inx		                INX
.1a26c9	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a26cc	28		plp		done            PLP
.1a26cd	2b		pld		                PLD
.1a26ce	60		rts		            RTS
.1a26cf					PREPROCESS
.1a26cf	da		phx		                PHX
.1a26d0	5a		phy		                PHY
.1a26d1	8b		phb		                PHB
.1a26d2	0b		phd		                PHD
.1a26d3	08		php		                PHP
.1a26d4	08		php		            PHP
.1a26d5	c2 20		rep #$20	            REP #$20
.1a26d7	48		pha		            PHA
.1a26d8	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a26db	5b		tcd		            TCD
.1a26dc	68		pla		            PLA
.1a26dd	28		plp		            PLP
.1a26de	e2 20		sep #$20	            SEP #$20
.1a26e0	c2 10		rep #$10	            REP #$10
.1a26e2	ad 00 4f	lda $4f00	                LDA INPUTBUF            ; Check the first character
.1a26e5	c9 23		cmp #$23	                CMP #CHAR_DIR           ; Is it the DIR character?
.1a26e7	f0 0a		beq $1a26f3	                BEQ expand_dir          ; Yes: expand the DIR command into place
.1a26e9	c9 7c		cmp #$7c	                CMP #CHAR_BRUN          ; Is it the BRUN character?
.1a26eb	f0 17		beq $1a2704	                BEQ expand_brun         ; Yes: expand the BRUN command into place
.1a26ed	28		plp		done            PLP
.1a26ee	2b		pld		                PLD
.1a26ef	ab		plb		                PLB
.1a26f0	7a		ply		                PLY
.1a26f1	fa		plx		                PLX
.1a26f2	60		rts		            RTS
.1a26f3					expand_dir
.1a26f3	c2 20		rep #$20	            REP #$20
.1a26f5	a9 03 00	lda #$0003	                LDA #3                  ; Set size of substitution value
.1a26f8	85 8f		sta $088f	                STA MCOUNT
.1a26fa	a9 15 27	lda #$2715	                LDA #<>dir_text         ; Set pointer to substitution value
.1a26fd	85 55		sta $0855	                STA MARG1
.1a26ff	20 67 26	jsr $1a2667	            JSR EXPANDLINE
.1a2702	80 e9		bra $1a26ed	                BRA done
.1a2704					expand_brun
.1a2704	c2 20		rep #$20	            REP #$20
.1a2706	a9 04 00	lda #$0004	                LDA #4                  ; Set size of substitution value
.1a2709	85 8f		sta $088f	                STA MCOUNT
.1a270b	a9 19 27	lda #$2719	                LDA #<>brun_text        ; Set pointer to substitution value
.1a270e	85 55		sta $0855	                STA MARG1
.1a2710	20 67 26	jsr $1a2667	            JSR EXPANDLINE
.1a2713	80 d8		bra $1a26ed	                BRA done
>1a2715	44 49 52 00			dir_text        .null "DIR"             ; Expansion of the DIR character
>1a2719	42 52 55 4e 00			brun_text       .null "BRUN"            ; Expansion of the BRUN character
.1a271e					PRREADY
.1a271e	8b		phb		                PHB
.1a271f	08		php		                PHP
.1a2720	20 3d 02	jsr $1a023d	            JSR ENSURETEXT
.1a2723	08		php		            PHP
.1a2724	e2 20		sep #$20	            SEP #$20
.1a2726	48		pha		            PHA
.1a2727	a9 1a		lda #$1a	            LDA #`MPROMPT
.1a2729	48		pha		            PHA
.1a272a	ab		plb		            PLB
.1a272b	68		pla		            PLA
.1a272c	28		plp		            PLP
.1a272d	a2 69 d2	ldx #$d269	                LDX #<>MPROMPT
.1a2730	20 29 04	jsr $1a0429	            JSR PRINTS
.1a2733	28		plp		                PLP
.1a2734	ab		plb		                PLB
.1a2735	60		rts		            RTS
.1a2736					IREADLINE
.1a2736	08		php		                PHP
.1a2737	e2 30		sep #$30	            SEP #$30
.1a2739	a9 01		lda #$01	                LDA #1
.1a273b	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a273e					read_loop
.1a273e	20 db 00	jsr $1a00db	            JSR GETKEYE
.1a2741	c9 00		cmp #$00	                CMP #0
.1a2743	f0 f9		beq $1a273e	                BEQ read_loop
.1a2745	c9 0d		cmp #$0d	                CMP #CHAR_CR
.1a2747	f0 02		beq $1a274b	                BEQ done
.1a2749	80 f3		bra $1a273e	                BRA read_loop
.1a274b	28		plp		done            PLP
.1a274c	60		rts		            RTS
.1a274d					PROCESS
.1a274d	0b		phd		                PHD
.1a274e	08		php		                PHP
.1a274f	08		php		            PHP
.1a2750	c2 20		rep #$20	            REP #$20
.1a2752	48		pha		            PHA
.1a2753	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a2756	5b		tcd		            TCD
.1a2757	68		pla		            PLA
.1a2758	28		plp		            PLP
.1a2759	c2 30		rep #$30	            REP #$30
.1a275b	64 d7		stz $08d7	                STZ LINENUM
.1a275d	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF         ; Attempt to tokenize the line that was read
.1a2760	85 1a		sta $081a	                STA CURLINE
.1a2762	a9 00 00	lda #$0000	                LDA #`CURLINE
.1a2765	85 1c		sta $081c	                STA CURLINE+2
.1a2767	20 61 09	jsr $1a0961	            JSR TOKENIZE
.1a276a	c2 20		rep #$20	            REP #$20
.1a276c	a5 d7		lda $08d7	                LDA LINENUM             ; Did we get a line number?
.1a276e	d0 05		bne $1a2775	                BNE update_line         ; Yes: attempt to add it to the program
.1a2770	20 0e 23	jsr $1a230e	            JSR EXECCMD
.1a2773	80 07		bra $1a277c	                BRA done
.1a2775					update_line
.1a2775	20 27 26	jsr $1a2627	            JSR ADDLINE
.1a2778	28		plp		no_prompt       PLP
.1a2779	2b		pld		                PLD
.1a277a	38		sec		                SEC
.1a277b	60		rts		            RTS
.1a277c	28		plp		done            PLP
.1a277d	2b		pld		                PLD
.1a277e	18		clc		                CLC
.1a277f	60		rts		            RTS
.1a2780					INTERACT
.1a2780	c2 30		rep #$30	            REP #$30
.1a2782	a2 ff fe	ldx #$feff	                LDX #<>STACK_END
.1a2785	9a		txs		                TXS
.1a2786					ready_loop
.1a2786	20 1e 27	jsr $1a271e	            JSR PRREADY
.1a2789					no_ready_loop
.1a2789	20 08 00	jsr $1a0008	            JSR READLINE
.1a278c	20 0c 00	jsr $1a000c	            JSR SCRCOPYLINE
.1a278f	22 3c 11 00	jsl $00113c	                JSL FK_TESTBREAK    ; Make sure the BREAK bit is cleared.
.1a2793	a9 00 00	lda #$0000	                LDA #0              ; Hide the cursor
.1a2796	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a2799	20 cf 26	jsr $1a26cf	            JSR PREPROCESS
.1a279c	20 4d 27	jsr $1a274d	            JSR PROCESS
.1a279f	b0 e8		bcs $1a2789	                BCS no_ready_loop
.1a27a1	80 e3		bra $1a2786	                BRA ready_loop
>1ad269	0d 52 45 41 44 59 0d 00		MPROMPT         .null 13,"READY",13

;******  Return to file: src\basic816.s


;******  Processing file: src\operators.s

.1a27a3					OP_PLUS
.1a27a3	08		php		            PHP
.1a27a4	e2 20		sep #$20	            SEP #$20
.1a27a6	20 68 08	jsr $1a0868	            JSR ASS_ARGS_NUMSTR
.1a27a9	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a27ab	f0 2c		beq $1a27d9	            BEQ is_integer
.1a27ad	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a27af	f0 2d		beq $1a27de	            BEQ is_float
.1a27b1	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a27b3	f0 1f		beq $1a27d4	            BEQ is_string
.1a27b5					type_error
.1a27b5	08		php		            PHP
.1a27b6	c2 20		rep #$20	            REP #$20
.1a27b8	48		pha		            PHA
.1a27b9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a27bc	5b		tcd		            TCD
.1a27bd	68		pla		            PLA
.1a27be	28		plp		            PLP
.1a27bf	e2 20		sep #$20	            SEP #$20
.1a27c1	a9 04		lda #$04	            LDA #ERR_TYPE
.1a27c3	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a27c7	c2 20		rep #$20	            REP #$20
.1a27c9	29 ff 00	and #$00ff	            AND #$00FF
.1a27cc	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a27cf	e2 20		sep #$20	            SEP #$20
.1a27d1	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a27d4					is_string
.1a27d4	20 11 16	jsr $1a1611	            JSR STRCONCAT
.1a27d7	80 08		bra $1a27e1	            BRA done
.1a27d9					is_integer
.1a27d9	20 8a 53	jsr $1a538a	            JSR OP_INT_ADD
.1a27dc	80 03		bra $1a27e1	            BRA done
.1a27de					is_float
.1a27de	20 f9 55	jsr $1a55f9	            JSR OP_FP_ADD
.1a27e1	28		plp		done        PLP
.1a27e2	60		rts		            RTS
.1a27e3					OP_MINUS
.1a27e3	08		php		            PHP
.1a27e4	e2 20		sep #$20	            SEP #$20
.1a27e6	20 1a 08	jsr $1a081a	            JSR ASS_ARGS_NUM
.1a27e9	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a27eb	f0 23		beq $1a2810	            BEQ is_integer
.1a27ed	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a27ef	f0 24		beq $1a2815	            BEQ is_float
.1a27f1					type_error
.1a27f1	08		php		            PHP
.1a27f2	c2 20		rep #$20	            REP #$20
.1a27f4	48		pha		            PHA
.1a27f5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a27f8	5b		tcd		            TCD
.1a27f9	68		pla		            PLA
.1a27fa	28		plp		            PLP
.1a27fb	e2 20		sep #$20	            SEP #$20
.1a27fd	a9 04		lda #$04	            LDA #ERR_TYPE
.1a27ff	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2803	c2 20		rep #$20	            REP #$20
.1a2805	29 ff 00	and #$00ff	            AND #$00FF
.1a2808	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a280b	e2 20		sep #$20	            SEP #$20
.1a280d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2810					is_integer
.1a2810	20 9c 53	jsr $1a539c	            JSR OP_INT_SUB
.1a2813	80 03		bra $1a2818	            BRA done
.1a2815					is_float
.1a2815	20 ee 55	jsr $1a55ee	            JSR OP_FP_SUB
.1a2818	28		plp		done        PLP
.1a2819	60		rts		            RTS
.1a281a					OP_MULTIPLY
.1a281a	08		php		            PHP
.1a281b	e2 20		sep #$20	            SEP #$20
.1a281d	20 1a 08	jsr $1a081a	            JSR ASS_ARGS_NUM
.1a2820	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a2822	f0 23		beq $1a2847	            BEQ is_integer
.1a2824	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2826	f0 24		beq $1a284c	            BEQ is_float
.1a2828					type_error
.1a2828	08		php		            PHP
.1a2829	c2 20		rep #$20	            REP #$20
.1a282b	48		pha		            PHA
.1a282c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a282f	5b		tcd		            TCD
.1a2830	68		pla		            PLA
.1a2831	28		plp		            PLP
.1a2832	e2 20		sep #$20	            SEP #$20
.1a2834	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2836	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a283a	c2 20		rep #$20	            REP #$20
.1a283c	29 ff 00	and #$00ff	            AND #$00FF
.1a283f	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a2842	e2 20		sep #$20	            SEP #$20
.1a2844	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2847					is_integer
.1a2847	20 ae 53	jsr $1a53ae	            JSR OP_INT_MUL
.1a284a	80 03		bra $1a284f	            BRA done
.1a284c					is_float
.1a284c	20 8f 56	jsr $1a568f	            JSR OP_FP_MUL
.1a284f	28		plp		done        PLP
.1a2850	60		rts		            RTS
.1a2851					OP_DIVIDE
.1a2851	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a2854	20 b5 07	jsr $1a07b5	            JSR ASS_ARG2_FLOAT
.1a2857	20 44 56	jsr $1a5644	            JSR OP_FP_DIV
.1a285a	60		rts		            RTS
.1a285b					OP_MOD
.1a285b	a5 23		lda $0823	            LDA ARGUMENT1
.1a285d	8f 1a 01 00	sta $00011a	            STA @lD1_OPERAND_B
.1a2861	a5 29		lda $0829	            LDA ARGUMENT2
.1a2863	8f 18 01 00	sta $000118	            STA @lD1_OPERAND_A
.1a2867	af 1e 01 00	lda $00011e	            LDA @lD1_REMAINDER
.1a286b	85 23		sta $0823	            STA ARGUMENT1
.1a286d	60		rts		            RTS
.1a286e					OP_POW
.1a286e	08		php		            PHP
.1a286f	c2 30		rep #$30	            REP #$30
.1a2871	48		pha		            PHA
.1a2872	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a2875	a5 2d		lda $082d	            LDA ARGTYPE2
.1a2877	c9 00 00	cmp #$0000	            CMP #TYPE_INTEGER
.1a287a	d0 0d		bne $1a2889	            BNE flt_exp
.1a287c	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a287e	d0 09		bne $1a2889	            BNE flt_exp
.1a2880	da		phx		            PHX
.1a2881	a6 29		ldx $0829	            LDX ARGUMENT2
.1a2883	20 62 63	jsr $1a6362	            JSR Q_FP_POW_INT
.1a2886	fa		plx		            PLX
.1a2887	80 1c		bra $1a28a5	            BRA done
.1a2889					flt_exp
.1a2889	20 b5 07	jsr $1a07b5	            JSR ASS_ARG2_FLOAT
.1a288c	c2 20		rep #$20	            REP #$20
.1a288e	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a2890	48		pha		            PHA
.1a2891	a5 29		lda $0829	            LDA ARGUMENT2
.1a2893	48		pha		            PHA
.1a2894	20 ed 61	jsr $1a61ed	            JSR FP_LN
.1a2897	c2 20		rep #$20	            REP #$20
.1a2899	68		pla		            PLA
.1a289a	85 29		sta $0829	            STA ARGUMENT2
.1a289c	68		pla		            PLA
.1a289d	85 2b		sta $082b	            STA ARGUMENT2+2
.1a289f	20 8f 56	jsr $1a568f	            JSR OP_FP_MUL
.1a28a2	20 cc 63	jsr $1a63cc	            JSR FP_EXP
.1a28a5	68		pla		done        PLA
.1a28a6	28		plp		            PLP
.1a28a7	60		rts		            RTS
.1a28a8					OP_AND
.1a28a8	08		php		            PHP
.1a28a9	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a28ac	20 47 06	jsr $1a0647	            JSR ASS_ARG2_INT
.1a28af	c2 20		rep #$20	            REP #$20
.1a28b1	a5 23		lda $0823	            LDA ARGUMENT1
.1a28b3	25 29		and $0829	            AND ARGUMENT2
.1a28b5	85 23		sta $0823	            STA ARGUMENT1
.1a28b7	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a28b9	25 2b		and $082b	            AND ARGUMENT2+2
.1a28bb	85 25		sta $0825	            STA ARGUMENT1+2
.1a28bd	28		plp		            PLP
.1a28be	60		rts		            RTS
.1a28bf					OP_OR
.1a28bf	08		php		            PHP
.1a28c0	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a28c3	20 47 06	jsr $1a0647	            JSR ASS_ARG2_INT
.1a28c6	c2 20		rep #$20	            REP #$20
.1a28c8	a5 23		lda $0823	            LDA ARGUMENT1
.1a28ca	05 29		ora $0829	            ORA ARGUMENT2
.1a28cc	85 23		sta $0823	            STA ARGUMENT1
.1a28ce	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a28d0	05 2b		ora $082b	            ORA ARGUMENT2+2
.1a28d2	85 25		sta $0825	            STA ARGUMENT1+2
.1a28d4	28		plp		done        PLP
.1a28d5	60		rts		            RTS
.1a28d6					OP_NOT
.1a28d6	08		php		            PHP
.1a28d7	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a28da	c2 20		rep #$20	            REP #$20
.1a28dc	a5 23		lda $0823	            LDA ARGUMENT1
.1a28de	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a28e1	85 23		sta $0823	            STA ARGUMENT1
.1a28e3	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a28e5	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a28e8	85 25		sta $0825	            STA ARGUMENT1+2
.1a28ea	28		plp		done        PLP
.1a28eb	60		rts		            RTS
.1a28ec					OP_LT
.1a28ec	08		php		            PHP
.1a28ed	e2 20		sep #$20	            SEP #$20
.1a28ef	20 68 08	jsr $1a0868	            JSR ASS_ARGS_NUMSTR
.1a28f2	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a28f4	f0 2c		beq $1a2922	            BEQ is_integer
.1a28f6	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a28f8	f0 2d		beq $1a2927	            BEQ is_float
.1a28fa	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a28fc	f0 1f		beq $1a291d	            BEQ is_string
.1a28fe					type_error
.1a28fe	08		php		            PHP
.1a28ff	c2 20		rep #$20	            REP #$20
.1a2901	48		pha		            PHA
.1a2902	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2905	5b		tcd		            TCD
.1a2906	68		pla		            PLA
.1a2907	28		plp		            PLP
.1a2908	e2 20		sep #$20	            SEP #$20
.1a290a	a9 04		lda #$04	            LDA #ERR_TYPE
.1a290c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2910	c2 20		rep #$20	            REP #$20
.1a2912	29 ff 00	and #$00ff	            AND #$00FF
.1a2915	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a2918	e2 20		sep #$20	            SEP #$20
.1a291a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a291d					is_string
.1a291d	20 99 17	jsr $1a1799	            JSR OP_STR_LT
.1a2920	80 08		bra $1a292a	            BRA done
.1a2922					is_integer
.1a2922	20 af 54	jsr $1a54af	            JSR OP_INT_LT
.1a2925	80 03		bra $1a292a	            BRA done
.1a2927					is_float
.1a2927	20 24 5c	jsr $1a5c24	            JSR OP_FP_LT
.1a292a	28		plp		done        PLP
.1a292b	60		rts		            RTS
.1a292c					OP_GT
.1a292c	08		php		            PHP
.1a292d	e2 20		sep #$20	            SEP #$20
.1a292f	20 68 08	jsr $1a0868	            JSR ASS_ARGS_NUMSTR
.1a2932	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a2934	f0 2c		beq $1a2962	            BEQ is_integer
.1a2936	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2938	f0 2d		beq $1a2967	            BEQ is_float
.1a293a	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a293c	f0 1f		beq $1a295d	            BEQ is_string
.1a293e					type_error
.1a293e	08		php		            PHP
.1a293f	c2 20		rep #$20	            REP #$20
.1a2941	48		pha		            PHA
.1a2942	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2945	5b		tcd		            TCD
.1a2946	68		pla		            PLA
.1a2947	28		plp		            PLP
.1a2948	e2 20		sep #$20	            SEP #$20
.1a294a	a9 04		lda #$04	            LDA #ERR_TYPE
.1a294c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2950	c2 20		rep #$20	            REP #$20
.1a2952	29 ff 00	and #$00ff	            AND #$00FF
.1a2955	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a2958	e2 20		sep #$20	            SEP #$20
.1a295a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a295d					is_string
.1a295d	20 b0 17	jsr $1a17b0	            JSR OP_STR_GT
.1a2960	80 08		bra $1a296a	            BRA done
.1a2962					is_integer
.1a2962	20 d0 54	jsr $1a54d0	            JSR OP_INT_GT
.1a2965	80 03		bra $1a296a	            BRA done
.1a2967					is_float
.1a2967	20 39 5c	jsr $1a5c39	            JSR OP_FP_GT
.1a296a	28		plp		done        PLP
.1a296b	60		rts		            RTS
.1a296c					OP_EQ
.1a296c	08		php		            PHP
.1a296d	e2 20		sep #$20	            SEP #$20
.1a296f	20 68 08	jsr $1a0868	            JSR ASS_ARGS_NUMSTR
.1a2972	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a2974	f0 2c		beq $1a29a2	            BEQ is_integer
.1a2976	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2978	f0 2d		beq $1a29a7	            BEQ is_float
.1a297a	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a297c	f0 1f		beq $1a299d	            BEQ is_string
.1a297e					type_error
.1a297e	08		php		            PHP
.1a297f	c2 20		rep #$20	            REP #$20
.1a2981	48		pha		            PHA
.1a2982	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2985	5b		tcd		            TCD
.1a2986	68		pla		            PLA
.1a2987	28		plp		            PLP
.1a2988	e2 20		sep #$20	            SEP #$20
.1a298a	a9 04		lda #$04	            LDA #ERR_TYPE
.1a298c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2990	c2 20		rep #$20	            REP #$20
.1a2992	29 ff 00	and #$00ff	            AND #$00FF
.1a2995	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a2998	e2 20		sep #$20	            SEP #$20
.1a299a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a299d					is_string
.1a299d	20 c7 17	jsr $1a17c7	            JSR OP_STR_EQ
.1a29a0	80 08		bra $1a29aa	            BRA done
.1a29a2					is_integer
.1a29a2	20 fd 54	jsr $1a54fd	            JSR OP_INT_EQ
.1a29a5	80 03		bra $1a29aa	            BRA done
.1a29a7					is_float
.1a29a7	20 4e 5c	jsr $1a5c4e	            JSR OP_FP_EQ
.1a29aa	28		plp		done        PLP
.1a29ab	60		rts		            RTS
.1a29ac					OP_NE
.1a29ac	08		php		            PHP
.1a29ad	e2 20		sep #$20	            SEP #$20
.1a29af	20 68 08	jsr $1a0868	            JSR ASS_ARGS_NUMSTR
.1a29b2	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a29b4	f0 2c		beq $1a29e2	            BEQ is_integer
.1a29b6	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a29b8	f0 2d		beq $1a29e7	            BEQ is_float
.1a29ba	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a29bc	f0 1f		beq $1a29dd	            BEQ is_string
.1a29be					type_error
.1a29be	08		php		            PHP
.1a29bf	c2 20		rep #$20	            REP #$20
.1a29c1	48		pha		            PHA
.1a29c2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a29c5	5b		tcd		            TCD
.1a29c6	68		pla		            PLA
.1a29c7	28		plp		            PLP
.1a29c8	e2 20		sep #$20	            SEP #$20
.1a29ca	a9 04		lda #$04	            LDA #ERR_TYPE
.1a29cc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a29d0	c2 20		rep #$20	            REP #$20
.1a29d2	29 ff 00	and #$00ff	            AND #$00FF
.1a29d5	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a29d8	e2 20		sep #$20	            SEP #$20
.1a29da	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a29dd					is_string
.1a29dd	20 de 17	jsr $1a17de	            JSR OP_STR_NE
.1a29e0	80 08		bra $1a29ea	            BRA done
.1a29e2					is_integer
.1a29e2	20 1b 55	jsr $1a551b	            JSR OP_INT_NE
.1a29e5	80 03		bra $1a29ea	            BRA done
.1a29e7					is_float
.1a29e7	20 8d 5c	jsr $1a5c8d	            JSR OP_FP_NE
.1a29ea	28		plp		done        PLP
.1a29eb	60		rts		            RTS
.1a29ec					OP_GTE
.1a29ec	08		php		            PHP
.1a29ed	e2 20		sep #$20	            SEP #$20
.1a29ef	20 68 08	jsr $1a0868	            JSR ASS_ARGS_NUMSTR
.1a29f2	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a29f4	f0 2c		beq $1a2a22	            BEQ is_integer
.1a29f6	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a29f8	f0 2d		beq $1a2a27	            BEQ is_float
.1a29fa	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a29fc	f0 1f		beq $1a2a1d	            BEQ is_string
.1a29fe					type_error
.1a29fe	08		php		            PHP
.1a29ff	c2 20		rep #$20	            REP #$20
.1a2a01	48		pha		            PHA
.1a2a02	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2a05	5b		tcd		            TCD
.1a2a06	68		pla		            PLA
.1a2a07	28		plp		            PLP
.1a2a08	e2 20		sep #$20	            SEP #$20
.1a2a0a	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2a0c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2a10	c2 20		rep #$20	            REP #$20
.1a2a12	29 ff 00	and #$00ff	            AND #$00FF
.1a2a15	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a2a18	e2 20		sep #$20	            SEP #$20
.1a2a1a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2a1d					is_string
.1a2a1d	20 f5 17	jsr $1a17f5	            JSR OP_STR_GTE
.1a2a20	80 08		bra $1a2a2a	            BRA done
.1a2a22					is_integer
.1a2a22	20 39 55	jsr $1a5539	            JSR OP_INT_GTE
.1a2a25	80 03		bra $1a2a2a	            BRA done
.1a2a27					is_float
.1a2a27	20 78 5c	jsr $1a5c78	            JSR OP_FP_GTE
.1a2a2a	28		plp		done        PLP
.1a2a2b	60		rts		            RTS
.1a2a2c					OP_LTE
.1a2a2c	08		php		            PHP
.1a2a2d	e2 20		sep #$20	            SEP #$20
.1a2a2f	20 68 08	jsr $1a0868	            JSR ASS_ARGS_NUMSTR
.1a2a32	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a2a34	f0 2c		beq $1a2a62	            BEQ is_integer
.1a2a36	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2a38	f0 2d		beq $1a2a67	            BEQ is_float
.1a2a3a	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a2a3c	f0 1f		beq $1a2a5d	            BEQ is_string
.1a2a3e					type_error
.1a2a3e	08		php		            PHP
.1a2a3f	c2 20		rep #$20	            REP #$20
.1a2a41	48		pha		            PHA
.1a2a42	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2a45	5b		tcd		            TCD
.1a2a46	68		pla		            PLA
.1a2a47	28		plp		            PLP
.1a2a48	e2 20		sep #$20	            SEP #$20
.1a2a4a	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2a4c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2a50	c2 20		rep #$20	            REP #$20
.1a2a52	29 ff 00	and #$00ff	            AND #$00FF
.1a2a55	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a2a58	e2 20		sep #$20	            SEP #$20
.1a2a5a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2a5d					is_string
.1a2a5d	20 0c 18	jsr $1a180c	            JSR OP_STR_LTE
.1a2a60	80 08		bra $1a2a6a	            BRA done
.1a2a62					is_integer
.1a2a62	20 66 55	jsr $1a5566	            JSR OP_INT_LTE
.1a2a65	80 03		bra $1a2a6a	            BRA done
.1a2a67					is_float
.1a2a67	20 63 5c	jsr $1a5c63	            JSR OP_FP_LTE
.1a2a6a	28		plp		done        PLP
.1a2a6b	60		rts		            RTS
.1a2a6c					OP_NEGATIVE
.1a2a6c	08		php		                PHP
.1a2a6d	e2 20		sep #$20	            SEP #$20
.1a2a6f	a5 27		lda $0827	                LDA ARGTYPE1                ; Check the type of the argument
.1a2a71	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a2a73	f0 2d		beq $1a2aa2	                BEQ int_negate              ; If integer: negate the integer
.1a2a75	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.1a2a77	f0 1f		beq $1a2a98	                BEQ float_negate            ; If floating point: negate the floating point
.1a2a79					type_error
.1a2a79	08		php		            PHP
.1a2a7a	c2 20		rep #$20	            REP #$20
.1a2a7c	48		pha		            PHA
.1a2a7d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2a80	5b		tcd		            TCD
.1a2a81	68		pla		            PLA
.1a2a82	28		plp		            PLP
.1a2a83	e2 20		sep #$20	            SEP #$20
.1a2a85	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2a87	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2a8b	c2 20		rep #$20	            REP #$20
.1a2a8d	29 ff 00	and #$00ff	            AND #$00FF
.1a2a90	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a2a93	e2 20		sep #$20	            SEP #$20
.1a2a95	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2a98					float_negate
.1a2a98	e2 20		sep #$20	            SEP #$20
.1a2a9a	a5 26		lda $0826	                LDA ARGUMENT1+3             ; Flip the sign bit of the floating point number
.1a2a9c	49 80		eor #$80	                EOR #$80
.1a2a9e	85 26		sta $0826	                STA ARGUMENT1+3
.1a2aa0	80 16		bra $1a2ab8	                BRA done
.1a2aa2					int_negate
.1a2aa2	c2 20		rep #$20	            REP #$20
.1a2aa4	a5 23		lda $0823	                LDA ARGUMENT1               ; Invert ARGUMENT1
.1a2aa6	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a2aa9	85 23		sta $0823	                STA ARGUMENT1
.1a2aab	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a2aad	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a2ab0	85 25		sta $0825	                STA ARGUMENT1+2
.1a2ab2	e6 23		inc $0823	                INC ARGUMENT1               ; And increment to get two's complement
.1a2ab4	d0 02		bne $1a2ab8	                BNE done
.1a2ab6	e6 25		inc $0825	                INC ARGUMENT1+2
.1a2ab8					done
.1a2ab8	28		plp		                PLP
.1a2ab9	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\statements.s


;******  Processing file: src\C256/statements_c256.s

=0					GR_LUT_BLUE = 0
=1					GR_LUT_GREEN = 1
=2					GR_LUT_RED = 2
=3					GR_LUT_ALPHA = 3
=640					GR_DEFAULT_COLS = 640               ; Default number of columns in the display
=480					GR_DEFAULT_ROWS = 480               ; Default number of rows in the display
=8					GR_MAX_LUT = 8                      ; The number of LUTs Vicky supports
=64					SP_MAX = 64                         ; The number of sprites Vicky supports
=8					SP_REG_SIZE = 8                     ; The number of bytes in a sprite's register block
=0					SP_CONTROL = 0                      ; Offset of the control regsiter for a sprite
=1					SP_ADDR = 1                         ; Offset of the pixmap address for a sprite
=4					SP_X_COORD = 4                      ; Offset of the X coordinate for a sprite
=6					SP_Y_COORD = 6                      ; Offset of the Y coordinate for a sprite
=12					TILEMAP_REG_SIZE = 12               ; The number of bytes in a tile map's register set
=4					TILESET_REG_SIZE = 4                ; The number of bytes in a tile set's register set
=2					BM_MAX = 2                          ; Maximum number of bitmaps we support
=$0040					MAX_VRAM_VICKY = $0040              ; Upper limit (exclusive) bank address for VRAM in Vicky address space
=$00f0					MAX_VRAM_CPU = $00F0                ; Upper limit (exclusive) bank address for VRAM in CPU address space
=$00b0					MIN_VRAM_CPU = $00B0                ; Lower limit (inclusive) bank address for VRAM in CPU address space
>1af000					GR_BM0_ADDR     .dword ?            ; Address of bitmap 0 (from CPU's perspective)
>1af004					GR_BM1_ADDR     .dword ?            ; Address of bitmap 1 (from CPU's perspective)
>1af008					GR_BM0_VRAM     .dword ?            ; Address of bitmap 0 (relative to start of VRAM)
>1af00c					GR_BM1_VRAM     .dword ?            ; Address of bitmap 1 (relative to start of VRAM)
>1af010					GR_MAX_COLS     .word ?             ; Width the display in pixels
>1af012					GR_MAX_ROWS     .word ?             ; Height of the display in pixels
>1af014					GR_TOTAL_PIXELS .word ?             ; Total number of pixels in the display
>1af016					GR_TEMP         .word ?             ; A temporary word for graphics commands
>1af018					GS_SP_CONTROL   .fill SP_MAX        ; Shadow registers for the sprite controls
.1a2aba					S_SETTIME
.1a2aba	08		php		                PHP
.1a2abb	e2 20		sep #$20	            SEP #$20
.1a2abd	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2ac0	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2ac3	20 73 05	jsr $1a0573	            JSR DIVINT10
.1a2ac6	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2ac8	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2ac9	0a		asl a		                ASL A
.1a2aca	0a		asl a		                ASL A
.1a2acb	0a		asl a		                ASL A
.1a2acc	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2ace	48		pha		                PHA
.1a2acf	a9 2c		lda #$2c	                LDA #','
.1a2ad1	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a2ad4	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2ad7	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2ada	20 73 05	jsr $1a0573	            JSR DIVINT10
.1a2add	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2adf	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2ae0	0a		asl a		                ASL A
.1a2ae1	0a		asl a		                ASL A
.1a2ae2	0a		asl a		                ASL A
.1a2ae3	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2ae5	48		pha		                PHA
.1a2ae6	a9 2c		lda #$2c	                LDA #','
.1a2ae8	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a2aeb	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2aee	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2af1	20 73 05	jsr $1a0573	            JSR DIVINT10
.1a2af4	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2af6	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2af7	0a		asl a		                ASL A
.1a2af8	0a		asl a		                ASL A
.1a2af9	0a		asl a		                ASL A
.1a2afa	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2afc	48		pha		                PHA
.1a2afd	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a2b01	09 0c		ora #$0c	                ORA #%00001100
.1a2b03	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2b07	68		pla		                PLA                     ; And seconds to the RTC
.1a2b08	8f 00 08 af	sta $af0800	                STA @lRTC_SEC
.1a2b0c	68		pla		                PLA                     ; Minutes...
.1a2b0d	8f 02 08 af	sta $af0802	                STA @lRTC_MIN
.1a2b11	68		pla		                PLA                     ; Save the hour...
.1a2b12	8f 04 08 af	sta $af0804	                STA @lRTC_HRS
.1a2b16	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a2b1a	29 f7		and #$f7	                AND #%11110111
.1a2b1c	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2b20	20 22 21	jsr $1a2122	            JSR SKIPSTMT
.1a2b23	28		plp		                PLP
.1a2b24	60		rts		            RTS
.1a2b25					S_SETDATE
.1a2b25	08		php		                PHP
.1a2b26	e2 20		sep #$20	            SEP #$20
.1a2b28	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2b2b	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2b2e	20 73 05	jsr $1a0573	            JSR DIVINT10
.1a2b31	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2b33	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2b34	0a		asl a		                ASL A
.1a2b35	0a		asl a		                ASL A
.1a2b36	0a		asl a		                ASL A
.1a2b37	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2b39	48		pha		                PHA
.1a2b3a	a9 2c		lda #$2c	                LDA #','
.1a2b3c	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a2b3f	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2b42	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2b45	20 73 05	jsr $1a0573	            JSR DIVINT10
.1a2b48	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2b4a	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2b4b	0a		asl a		                ASL A
.1a2b4c	0a		asl a		                ASL A
.1a2b4d	0a		asl a		                ASL A
.1a2b4e	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2b50	48		pha		                PHA
.1a2b51	a9 2c		lda #$2c	                LDA #','
.1a2b53	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a2b56	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2b59	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a2b5c	20 a9 05	jsr $1a05a9	            JSR DIVINT100
.1a2b5f	c2 20		rep #$20	            REP #$20
.1a2b61	a5 23		lda $0823	                LDA ARGUMENT1           ; Get the century
.1a2b63	85 92		sta $0892	                STA MTEMP               ; Save it in MTEMP
.1a2b65	a5 29		lda $0829	                LDA ARGUMENT2           ; Separate the 10s from the 1s digits
.1a2b67	85 23		sta $0823	                STA ARGUMENT1
.1a2b69	20 73 05	jsr $1a0573	            JSR DIVINT10
.1a2b6c	e2 20		sep #$20	            SEP #$20
.1a2b6e	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2b70	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2b71	0a		asl a		                ASL A
.1a2b72	0a		asl a		                ASL A
.1a2b73	0a		asl a		                ASL A
.1a2b74	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2b76	48		pha		                PHA                     ; Save the 10s and 1s in BCD
.1a2b77	c2 20		rep #$20	            REP #$20
.1a2b79	a5 92		lda $0892	                LDA MTEMP               ; Separate the 100s from the 1000s digits
.1a2b7b	85 23		sta $0823	                STA ARGUMENT1
.1a2b7d	20 73 05	jsr $1a0573	            JSR DIVINT10
.1a2b80	e2 20		sep #$20	            SEP #$20
.1a2b82	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2b84	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2b85	0a		asl a		                ASL A
.1a2b86	0a		asl a		                ASL A
.1a2b87	0a		asl a		                ASL A
.1a2b88	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2b8a	48		pha		                PHA                     ; Save the 100s and 1000s in BCD
.1a2b8b	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a2b8f	09 0c		ora #$0c	                ORA #%00001100
.1a2b91	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2b95	68		pla		                PLA                     ; Set the century
.1a2b96	8f 0f 08 af	sta $af080f	                STA @lRTC_CENTURY
.1a2b9a	68		pla		                PLA                     ; And year to the RTC
.1a2b9b	8f 0a 08 af	sta $af080a	                STA @lRTC_YEAR
.1a2b9f	68		pla		                PLA                     ; Month...
.1a2ba0	8f 09 08 af	sta $af0809	                STA @lRTC_MONTH
.1a2ba4	68		pla		                PLA                     ; Save the day...
.1a2ba5	8f 06 08 af	sta $af0806	                STA @lRTC_DAY
.1a2ba9	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a2bad	29 f7		and #$f7	                AND #%11110111
.1a2baf	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2bb3	20 22 21	jsr $1a2122	            JSR SKIPSTMT
.1a2bb6	28		plp		                PLP
.1a2bb7	60		rts		            RTS
.1a2bb8					S_TEXTCOLOR
.1a2bb8	08		php		                PHP
.1a2bb9					locals
>0001					L_FOREGROUND    .byte ?
.1a2bb9	e2 20		sep #$20	            SEP #$20
.1a2bbb	48		pha		            PHA
.1a2bbc	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2bbf	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2bc2	e2 20		sep #$20	            SEP #$20
.1a2bc4	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the foreground position
.1a2bc6	29 0f		and #$0f	                AND #$0F
.1a2bc8	0a		asl a		                ASL A
.1a2bc9	0a		asl a		                ASL A
.1a2bca	0a		asl a		                ASL A
.1a2bcb	0a		asl a		                ASL A
.1a2bcc	83 01		sta $01,s	                STA L_FOREGROUND    ; Save the foreground color
.1a2bce	a9 2c		lda #$2c	                LDA #','
.1a2bd0	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a2bd3	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2bd6	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2bd9	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the background position
.1a2bdb	29 0f		and #$0f	                AND #$0F
.1a2bdd	03 01		ora $01,s	                ORA L_FOREGROUND    ; Add in the foreground
.1a2bdf	8f 1e 00 00	sta $00001e	                STA @lCURCOLOR      ; And save the new color combination
.1a2be3	e2 20		sep #$20	            SEP #$20
.1a2be5	68		pla		            PLA
.1a2be6	28		plp		                PLP
.1a2be7	60		rts		            RTS
.1a2be8					S_SETBGCOLOR
.1a2be8	08		php		                PHP
.1a2be9					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.1a2be9	c2 20		rep #$20	            REP #$20
.1a2beb	f4 00 00	pea #$0000	            PEA #0
.1a2bee	e2 20		sep #$20	            SEP #$20
.1a2bf0	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2bf3	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2bf6	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.1a2bf8	83 01		sta $01,s	                STA L_RED
.1a2bfa	a9 2c		lda #$2c	                LDA #','
.1a2bfc	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a2bff	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2c02	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2c05	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.1a2c07	83 02		sta $02,s	                STA L_GREEN
.1a2c09	a9 2c		lda #$2c	                LDA #','
.1a2c0b	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a2c0e	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2c11	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2c14	a5 23		lda $0823	                LDA ARGUMENT1               ; And set the actual color
.1a2c16	8f 0d 00 af	sta $af000d	                STA @lBACKGROUND_COLOR_B
.1a2c1a	a3 02		lda $02,s	                LDA L_GREEN
.1a2c1c	8f 0e 00 af	sta $af000e	                STA @lBACKGROUND_COLOR_G
.1a2c20	a3 01		lda $01,s	                LDA L_RED
.1a2c22	8f 0f 00 af	sta $af000f	                STA @lBACKGROUND_COLOR_R
.1a2c26	c2 20		rep #$20	            REP #$20
.1a2c28	68		pla		            PLA
.1a2c29	28		plp		                PLP
.1a2c2a	60		rts		            RTS
.1a2c2b					S_SETBORDER
.1a2c2b	08		php		                PHP
.1a2c2c					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.1a2c2c	c2 20		rep #$20	            REP #$20
.1a2c2e	f4 00 00	pea #$0000	            PEA #0
.1a2c31	e2 20		sep #$20	            SEP #$20
.1a2c33	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2c36	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a2c39	a5 23		lda $0823	                LDA ARGUMENT1
.1a2c3b	f0 16		beq $1a2c53	                BEQ hide_border
.1a2c3d	a9 01		lda #$01	                LDA #Border_Ctrl_Enable     ; Enable the border
.1a2c3f	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.1a2c43	a9 20		lda #$20	                LDA #BORDER_WIDTH           ; Set the border width
.1a2c45	8f 08 00 af	sta $af0008	                STA BORDER_X_SIZE
.1a2c49	8f 09 00 af	sta $af0009	                STA BORDER_Y_SIZE
.1a2c4d	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.1a2c51	80 0a		bra $1a2c5d	                BRA get_color
.1a2c53	a9 00		lda #$00	hide_border     LDA #0                      ; Hide the border
.1a2c55	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.1a2c59	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.1a2c5d	a9 2c		lda #$2c	get_color       LDA #','
.1a2c5f	85 37		sta $0837	                STA TARGETTOK
.1a2c61	20 1f 22	jsr $1a221f	            JSR OPT_TOK
.1a2c64	90 39		bcc $1a2c9f	                BCC done                    ; No: we're done
.1a2c66	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a2c69	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2c6c	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2c6f	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.1a2c71	83 01		sta $01,s	                STA L_RED
.1a2c73	a9 2c		lda #$2c	                LDA #','
.1a2c75	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a2c78	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2c7b	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2c7e	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.1a2c80	83 02		sta $02,s	                STA L_GREEN
.1a2c82	a9 2c		lda #$2c	                LDA #','
.1a2c84	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a2c87	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2c8a	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2c8d	a5 23		lda $0823	                LDA ARGUMENT1
.1a2c8f	8f 05 00 af	sta $af0005	                STA @lBORDER_COLOR_B        ; Set the border color
.1a2c93	a3 02		lda $02,s	                LDA L_GREEN
.1a2c95	8f 06 00 af	sta $af0006	                STA @lBORDER_COLOR_G
.1a2c99	a3 01		lda $01,s	                LDA L_RED
.1a2c9b	8f 07 00 af	sta $af0007	                STA @lBORDER_COLOR_R
.1a2c9f					done
.1a2c9f	c2 20		rep #$20	            REP #$20
.1a2ca1	68		pla		            PLA
.1a2ca2	28		plp		                PLP
.1a2ca3	60		rts		            RTS
.1a2ca4					S_SETCOLOR
.1a2ca4	08		php		                PHP
.1a2ca5					locals
>0001					L_LUT           .byte ?
>0002					L_COLOR         .byte ?
>0003					L_RED           .byte ?
>0004					L_GREEN         .byte ?
>0005					L_BLUE          .byte ?
.1a2ca5	c2 20		rep #$20	            REP #$20
.1a2ca7	3b		tsc		            TSC
.1a2ca8	38		sec		            SEC
.1a2ca9	e9 05 00	sbc #$0005	            SBC #SIZE(locals)
.1a2cac	1b		tcs		            TCS
.1a2cad	e2 20		sep #$20	            SEP #$20
.1a2caf	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2cb2	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2cb5	a5 23		lda $0823	                LDA ARGUMENT1
.1a2cb7	c9 0a		cmp #$0a	                CMP #10             ; And in range
.1a2cb9	90 1f		bcc $1a2cda	                BLT save_lut
.1a2cbb					bad_argument
.1a2cbb	08		php		            PHP
.1a2cbc	c2 20		rep #$20	            REP #$20
.1a2cbe	48		pha		            PHA
.1a2cbf	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2cc2	5b		tcd		            TCD
.1a2cc3	68		pla		            PLA
.1a2cc4	28		plp		            PLP
.1a2cc5	e2 20		sep #$20	            SEP #$20
.1a2cc7	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a2cc9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2ccd	c2 20		rep #$20	            REP #$20
.1a2ccf	29 ff 00	and #$00ff	            AND #$00FF
.1a2cd2	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a2cd5	e2 20		sep #$20	            SEP #$20
.1a2cd7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2cda	83 01		sta $01,s	save_lut        STA L_LUT           ; Save as LUT
.1a2cdc	a9 2c		lda #$2c	                LDA #','
.1a2cde	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a2ce1	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2ce4	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2ce7	a5 23		lda $0823	                LDA ARGUMENT1
.1a2ce9	83 02		sta $02,s	                STA L_COLOR         ; Save as COLOR
.1a2ceb	a9 2c		lda #$2c	                LDA #','
.1a2ced	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a2cf0	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2cf3	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2cf6	a5 23		lda $0823	                LDA ARGUMENT1
.1a2cf8	83 03		sta $03,s	                STA L_RED           ; Save as RED
.1a2cfa	a9 2c		lda #$2c	                LDA #','
.1a2cfc	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a2cff	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2d02	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2d05	a5 23		lda $0823	                LDA ARGUMENT1
.1a2d07	83 04		sta $04,s	                STA L_GREEN         ; Save it as GREEN
.1a2d09	a9 2c		lda #$2c	                LDA #','
.1a2d0b	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a2d0e	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2d11	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2d14	a5 23		lda $0823	                LDA ARGUMENT1
.1a2d16	83 05		sta $05,s	                STA L_BLUE          ; Save it as BLUE
.1a2d18	a9 af		lda #$af	                LDA #`GRPH_LUT0_PTR ; Get the bank Vicky is in (should always be $AF)
.1a2d1a	85 a0		sta $08a0	                STA MTEMPPTR+2      ; MTEMPPTR will be our pointer to the LUT entry
.1a2d1c	a3 01		lda $01,s	                LDA L_LUT           ; Compute the offset to the LUT address
.1a2d1e	0a		asl a		                ASL A
.1a2d1f	c2 20		rep #$20	            REP #$20
.1a2d21	29 ff 00	and #$00ff	                AND #$00FF
.1a2d24	aa		tax		                TAX                 ; Put it in X
.1a2d25	bf 5c 2d 1a	lda $1a2d5c,x	                LDA @llut_address,X ; Get the address of the LUT
.1a2d29	85 9e		sta $089e	                STA MTEMPPTR        ; Put it in MTEMPPTR
.1a2d2b	e2 20		sep #$20	            SEP #$20
.1a2d2d	a3 02		lda $02,s	                LDA L_COLOR         ; color index *= 4
.1a2d2f	c2 20		rep #$20	            REP #$20
.1a2d31	29 ff 00	and #$00ff	                AND #$00FF
.1a2d34	0a		asl a		                ASL A               ; Since each color has four bytes of data
.1a2d35	0a		asl a		                ASL A
.1a2d36	18		clc		                CLC                 ; Add the color offset to MTEMPPTR
.1a2d37	65 9e		adc $089e	                ADC MTEMPPTR
.1a2d39	85 9e		sta $089e	                STA MTEMPPTR
.1a2d3b	e2 20		sep #$20	            SEP #$20
.1a2d3d	a0 02 00	ldy #$0002	                LDY #GR_LUT_RED
.1a2d40	a3 03		lda $03,s	                LDA L_RED
.1a2d42	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the red component to the color entry
.1a2d44	a0 01 00	ldy #$0001	                LDY #GR_LUT_GREEN
.1a2d47	a3 04		lda $04,s	                LDA L_GREEN
.1a2d49	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the green component to the color entry
.1a2d4b	a0 00 00	ldy #$0000	                LDY #GR_LUT_BLUE
.1a2d4e	a3 05		lda $05,s	                LDA L_BLUE
.1a2d50	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the blue component to the color entry
.1a2d52					done
.1a2d52	c2 20		rep #$20	            REP #$20
.1a2d54	3b		tsc		            TSC
.1a2d55	18		clc		            CLC
.1a2d56	69 05 00	adc #$0005	            ADC #SIZE(locals)
.1a2d59	1b		tcs		            TCS
.1a2d5a	28		plp		                PLP
.1a2d5b	60		rts		            RTS
>1a2d5c	00 20				lut_address     .word <>GRPH_LUT0_PTR
>1a2d5e	00 24				                .word <>GRPH_LUT1_PTR
>1a2d60	00 28				                .word <>GRPH_LUT2_PTR
>1a2d62	00 2c				                .word <>GRPH_LUT3_PTR
>1a2d64	00 30				                .word <>GRPH_LUT4_PTR
>1a2d66	00 34				                .word <>GRPH_LUT5_PTR
>1a2d68	00 38				                .word <>GRPH_LUT6_PTR
>1a2d6a	00 3c				                .word <>GRPH_LUT7_PTR
>1a2d6c	40 1f				                .word <>FG_CHAR_LUT_PTR
>1a2d6e	80 1f				                .word <>BG_CHAR_LUT_PTR
.1a2d70					S_GRAPHICS
.1a2d70	da		phx		                PHX
.1a2d71	5a		phy		                PHY
.1a2d72	08		php		                PHP
.1a2d73	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2d76	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a2d79	c2 20		rep #$20	            REP #$20
.1a2d7b	a5 23		lda $0823	                LDA ARGUMENT1               ; Check to see if we're setting mode to 800x600 or 400x300
.1a2d7d	89 00 01	bit #$0100	                BIT #$0100
.1a2d80	d0 17		bne $1a2d99	                BNE set_mode                ; Yes: go ahead and set it
.1a2d82	af 00 00 af	lda $af0000	                LDA @l MASTER_CTRL_REG_L    ; Otherwise, check to see if we're already in 800x600 or 400x300
.1a2d86	89 00 01	bit #$0100	                BIT #$0100
.1a2d89	f0 0e		beq $1a2d99	                BEQ set_mode                ; No: just go ahead and set the mode
.1a2d8b	e2 20		sep #$20	            SEP #$20
.1a2d8d	a9 00		lda #$00	                LDA #0                      ; Yes: toggle back to 640x480...
.1a2d8f	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.1a2d93	a9 01		lda #$01	                LDA #1                      ; And back to 800x600....
.1a2d95	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.1a2d99					set_mode
.1a2d99	c2 20		rep #$20	            REP #$20
.1a2d9b	a5 23		lda $0823	                LDA ARGUMENT1
.1a2d9d	8f 00 00 af	sta $af0000	                STA @l MASTER_CTRL_REG_L    ; Set the graphics mode
.1a2da1	e2 20		sep #$20	            SEP #$20
.1a2da3	a5 24		lda $0824	                LDA ARGUMENT1+1             ; Get the screen size bits
.1a2da5	c2 20		rep #$20	            REP #$20
.1a2da7	29 03 00	and #$0003	                AND #$0003
.1a2daa	0a		asl a		                ASL A                       ; Multiply by two to get the index
.1a2dab	aa		tax		                TAX                         ; X is index into the size tables
.1a2dac	c2 20		rep #$20	            REP #$20
.1a2dae	bf f7 2d 1a	lda $1a2df7,x	                LDA gr_columns,X            ; Set the columns
.1a2db2	8f 10 f0 1a	sta $1af010	                STA @lGR_MAX_COLS
.1a2db6	bf ff 2d 1a	lda $1a2dff,x	                LDA gr_rows,X               ; Set the rows
.1a2dba	8f 12 f0 1a	sta $1af012	                STA @lGR_MAX_ROWS
.1a2dbe	af 10 f0 1a	lda $1af010	                LDA @lGR_MAX_COLS           ; Get the current columns
.1a2dc2	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.1a2dc6	af 12 f0 1a	lda $1af012	                LDA @lGR_MAX_ROWS           ; Get the current rows
.1a2dca	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B
.1a2dce	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT             ; Multiply them to get the total pixels
.1a2dd2	8f 14 f0 1a	sta $1af014	                STA @lGR_TOTAL_PIXELS
.1a2dd6	e2 20		sep #$20	            SEP #$20
.1a2dd8	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.1a2ddc	8f 16 f0 1a	sta $1af016	                STA @lGR_TOTAL_PIXELS+2
.1a2de0	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.1a2de4					reset_cursor
.1a2de4	c2 20		rep #$20	            REP #$20
.1a2de6	af 1a 00 00	lda $00001a	                LDA @lCURSORX
.1a2dea	aa		tax		                TAX
.1a2deb	af 1c 00 00	lda $00001c	                LDA @lCURSORY
.1a2def	a8		tay		                TAY
.1a2df0	20 20 00	jsr $1a0020	            JSR CURSORXY
.1a2df3	28		plp		                PLP
.1a2df4	7a		ply		                PLY
.1a2df5	fa		plx		                PLX
.1a2df6	60		rts		            RTS
>1a2df7	80 02 20 03 40 01 90 01		gr_columns      .word 640,800,320,400
>1a2dff	e0 01 58 02 f0 00 2c 01		gr_rows         .word 480,600,240,300
>1a2e07	50 00 64 00 28 00 32 00		col_count       .word 80,100,40,50
>1a2e0f	3c 00 4b 00 1e 00 32 00		row_count       .word 60,75,30,50
>1a2e17	48 00 5c 00 20 00 2a 00		colb_count      .word 72,92,32,42
>1a2e1f	34 00 43 00 16 00 34 00		rowb_count      .word 52,67,22,52
.1a2e27					BITMAP_SRAM
.1a2e27	da		phx		                PHX
.1a2e28	08		php		                PHP
.1a2e29	c2 30		rep #$30	            REP #$30
.1a2e2b	c9 02 00	cmp #$0002	                CMP #BM_MAX
.1a2e2e	b0 1c		bcs $1a2e4c	                BGE range_err           ; Make sure it's within range
.1a2e30	0a		asl a		                ASL A
.1a2e31	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.1a2e32	aa		tax		                TAX
.1a2e33	bf 00 f0 1a	lda $1af000,x	                LDA @l GR_BM0_ADDR,X    ; Get the low 16-bits of the address
.1a2e37	85 9e		sta $089e	                STA MTEMPPTR
.1a2e39	bf 02 f0 1a	lda $1af002,x	                LDA @l GR_BM0_ADDR+2,X  ; Get the high bits of the address
.1a2e3d	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a2e3f	c9 f0 00	cmp #$00f0	                CMP #MAX_VRAM_CPU       ; Check to make sure address is within VRAM
.1a2e42	b0 08		bcs $1a2e4c	                BGE range_err
.1a2e44	c9 b0 00	cmp #$00b0	                CMP #MIN_VRAM_CPU
.1a2e47	90 03		bcc $1a2e4c	                BLT range_err
.1a2e49	28		plp		                PLP
.1a2e4a	fa		plx		                PLX
.1a2e4b	60		rts		            RTS
.1a2e4c					range_err
.1a2e4c	08		php		            PHP
.1a2e4d	c2 20		rep #$20	            REP #$20
.1a2e4f	48		pha		            PHA
.1a2e50	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2e53	5b		tcd		            TCD
.1a2e54	68		pla		            PLA
.1a2e55	28		plp		            PLP
.1a2e56	e2 20		sep #$20	            SEP #$20
.1a2e58	a9 09		lda #$09	            LDA #ERR_RANGE
.1a2e5a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2e5e	c2 20		rep #$20	            REP #$20
.1a2e60	29 ff 00	and #$00ff	            AND #$00FF
.1a2e63	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a2e66	e2 20		sep #$20	            SEP #$20
.1a2e68	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2e6b					BITMAP_VRAM
.1a2e6b	da		phx		                PHX
.1a2e6c	08		php		                PHP
.1a2e6d	c2 30		rep #$30	            REP #$30
.1a2e6f	c9 02 00	cmp #$0002	                CMP #BM_MAX
.1a2e72	b0 17		bcs $1a2e8b	                BGE range_err           ; Make sure it's within range
.1a2e74	0a		asl a		                ASL A
.1a2e75	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.1a2e76	aa		tax		                TAX
.1a2e77	bf 08 f0 1a	lda $1af008,x	                LDA @l GR_BM0_VRAM,X    ; Get the low 16-bits of the address
.1a2e7b	85 9e		sta $089e	                STA MTEMPPTR
.1a2e7d	bf 0a f0 1a	lda $1af00a,x	                LDA @l GR_BM0_VRAM+2,X  ; Get the high bits of the address
.1a2e81	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a2e83	c9 40 00	cmp #$0040	                CMP #MAX_VRAM_VICKY     ; Check to make sure the address is from $00:0000 - $3F:FFFF
.1a2e86	b0 03		bcs $1a2e8b	                BGE range_err           ; If not, throw a range error
.1a2e88	28		plp		                PLP
.1a2e89	fa		plx		                PLX
.1a2e8a	60		rts		            RTS
.1a2e8b					range_err
.1a2e8b	08		php		            PHP
.1a2e8c	c2 20		rep #$20	            REP #$20
.1a2e8e	48		pha		            PHA
.1a2e8f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2e92	5b		tcd		            TCD
.1a2e93	68		pla		            PLA
.1a2e94	28		plp		            PLP
.1a2e95	e2 20		sep #$20	            SEP #$20
.1a2e97	a9 09		lda #$09	            LDA #ERR_RANGE
.1a2e99	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2e9d	c2 20		rep #$20	            REP #$20
.1a2e9f	29 ff 00	and #$00ff	            AND #$00FF
.1a2ea2	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a2ea5	e2 20		sep #$20	            SEP #$20
.1a2ea7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2eaa					S_BITMAP
.1a2eaa	08		php		                PHP
.1a2eab					locals
>0001					L_PLANE         .word ?
>0003					L_VISIBLE       .byte ?
>0004					L_ADDRESS       .dword ?
.1a2eab	c2 30		rep #$30	            REP #$30
.1a2ead	3b		tsc		                TSC                         ; Allocate space for the locals on the stack
.1a2eae	38		sec		                SEC
.1a2eaf	e9 07 00	sbc #$0007	                SBC #SIZE(locals)
.1a2eb2	1b		tcs		                TCS
.1a2eb3	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2eb6	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2eb9	c2 20		rep #$20	            REP #$20
.1a2ebb	a5 23		lda $0823	                LDA ARGUMENT1               ; Make sure it's in range
.1a2ebd	c9 02 00	cmp #$0002	                CMP #BM_MAX
.1a2ec0	b0 59		bcs $1a2f1b	                BGE range_err               ; If not, throw an error
.1a2ec2	83 01		sta $01,s	                STA L_PLANE                 ; If so, save it to MARG1
.1a2ec4	e2 20		sep #$20	            SEP #$20
.1a2ec6	a9 2c		lda #$2c	                LDA #','
.1a2ec8	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a2ecb	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2ece	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2ed1	a5 23		lda $0823	                LDA ARGUMENT1
.1a2ed3	83 03		sta $03,s	                STA L_VISIBLE
.1a2ed5	a9 2c		lda #$2c	                LDA #','
.1a2ed7	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a2eda	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2edd	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2ee0	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the number back
.1a2ee2	0a		asl a		                ASL A                       ; Multiply by 8 to get the offset to the registers
.1a2ee3	0a		asl a		                ASL A
.1a2ee4	0a		asl a		                ASL A
.1a2ee5	aa		tax		                TAX                         ; And save that offset to X
.1a2ee6	a3 03		lda $03,s	                LDA L_VISIBLE               ; Check the visible flag
.1a2ee8	d0 05		bne $1a2eef	                BNE is_visible              ; If <> 0, it's visible
.1a2eea	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the LUT #
.1a2eec	0a		asl a		                ASL A                       ; Shift it into position for the register
.1a2eed	80 04		bra $1a2ef3	                BRA wr_bm_reg               ; And go to write it
.1a2eef	a5 23		lda $0823	is_visible      LDA ARGUMENT1               ; Get the LUT #
.1a2ef1	38		sec		                SEC
.1a2ef2	2a		rol a		                ROL A                       ; And shift it into position, and set enable bit
.1a2ef3	9f 00 01 af	sta $af0100,x	wr_bm_reg       STA @l BM0_CONTROL_REG,X    ; Write to the bitmap control register
.1a2ef7	c2 20		rep #$20	            REP #$20
.1a2ef9	a9 2c 00	lda #$002c	                LDA #','
.1a2efc	85 37		sta $0837	                STA TARGETTOK
.1a2efe	20 1f 22	jsr $1a221f	            JSR OPT_TOK
.1a2f01	b0 37		bcs $1a2f3a	                BCS get_address             ; Yes: parse the address
.1a2f03	c2 20		rep #$20	            REP #$20
.1a2f05	08		php		            PHP
.1a2f06	c2 20		rep #$20	            REP #$20
.1a2f08	a9 00 00	lda #$0000	            LDA #<>VRAM
.1a2f0b	85 23		sta $0823	            STA ARGUMENT1
.1a2f0d	a9 b0 00	lda #$00b0	            LDA #(VRAM >> 16)
.1a2f10	85 25		sta $0825	            STA ARGUMENT1+2
.1a2f12	e2 20		sep #$20	            SEP #$20
.1a2f14	a9 00		lda #$00	            LDA #TYPE_INTEGER
.1a2f16	85 27		sta $0827	            STA ARGUMENT1+4
.1a2f18	28		plp		            PLP
.1a2f19	80 27		bra $1a2f42	                BRA set_address
.1a2f1b					range_err
.1a2f1b	08		php		            PHP
.1a2f1c	c2 20		rep #$20	            REP #$20
.1a2f1e	48		pha		            PHA
.1a2f1f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2f22	5b		tcd		            TCD
.1a2f23	68		pla		            PLA
.1a2f24	28		plp		            PLP
.1a2f25	e2 20		sep #$20	            SEP #$20
.1a2f27	a9 09		lda #$09	            LDA #ERR_RANGE
.1a2f29	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2f2d	c2 20		rep #$20	            REP #$20
.1a2f2f	29 ff 00	and #$00ff	            AND #$00FF
.1a2f32	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a2f35	e2 20		sep #$20	            SEP #$20
.1a2f37	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2f3a					get_address
.1a2f3a	c2 20		rep #$20	            REP #$20
.1a2f3c	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a2f3f	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2f42					set_address
.1a2f42	c2 20		rep #$20	            REP #$20
.1a2f44	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.1a2f46	0a		asl a		                ASL A                       ; Multiply by four to get the offset to the address variable
.1a2f47	0a		asl a		                ASL A
.1a2f48	aa		tax		                TAX                         ; And put it in X
.1a2f49	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the CPU-space address
.1a2f4b	9f 00 f0 1a	sta $1af000,x	                STA @l GR_BM0_ADDR,X        ; And save it to the correct GR_BM?_ADDR variable
.1a2f4f	9f 08 f0 1a	sta $1af008,x	                STA @l GR_BM0_VRAM,X
.1a2f53	83 04		sta $04,s	                STA L_ADDRESS               ; And L_ADDRESS, temporarily
.1a2f55	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a2f57	9f 02 f0 1a	sta $1af002,x	                STA @l GR_BM0_ADDR+2,X
.1a2f5b	38		sec		                SEC
.1a2f5c	e9 b0 00	sbc #$00b0	                SBC #`VRAM                  ; Rebase the upper half of the address to Vicky memory space
.1a2f5f	9f 0a f0 1a	sta $1af00a,x	                STA @l GR_BM0_VRAM+2,X
.1a2f63	83 06		sta $06,s	                STA L_ADDRESS+2             ; And to L_ADDRESS
.1a2f65	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.1a2f67	0a		asl a		                ASL A                       ; Multiply by eight to get the offset to the registers
.1a2f68	0a		asl a		                ASL A
.1a2f69	0a		asl a		                ASL A
.1a2f6a	aa		tax		                TAX                         ; And put it in X
.1a2f6b	e2 20		sep #$20	            SEP #$20
.1a2f6d	a3 04		lda $04,s	                LDA L_ADDRESS               ; Get the address in Vicky space...
.1a2f6f	9f 01 01 af	sta $af0101,x	                STA @l BM0_START_ADDY_L,X   ; Save it to the Vicky registers
.1a2f73	a3 05		lda $05,s	                LDA L_ADDRESS+1
.1a2f75	9f 02 01 af	sta $af0102,x	                STA @l BM0_START_ADDY_M,X
.1a2f79	a3 06		lda $06,s	                LDA L_ADDRESS+2
.1a2f7b	9f 03 01 af	sta $af0103,x	                STA @l BM0_START_ADDY_H,X
.1a2f7f	a9 00		lda #$00	                LDA #0                      ; Default offset to (0, 0)
.1a2f81	9f 04 01 af	sta $af0104,x	                STA @l BM0_X_OFFSET,X
.1a2f85	9f 05 01 af	sta $af0105,x	                STA @l BM0_Y_OFFSET,X
.1a2f89	c2 30		rep #$30	            REP #$30
.1a2f8b	3b		tsc		                TSC                         ; Remove the space for the locals from the stack
.1a2f8c	18		clc		                CLC
.1a2f8d	69 07 00	adc #$0007	                ADC #SIZE(locals)
.1a2f90	1b		tcs		                TCS
.1a2f91	28		plp		                PLP
.1a2f92	60		rts		            RTS
.1a2f93					bad_address
.1a2f93	08		php		            PHP
.1a2f94	c2 20		rep #$20	            REP #$20
.1a2f96	48		pha		            PHA
.1a2f97	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2f9a	5b		tcd		            TCD
.1a2f9b	68		pla		            PLA
.1a2f9c	28		plp		            PLP
.1a2f9d	e2 20		sep #$20	            SEP #$20
.1a2f9f	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a2fa1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2fa5	c2 20		rep #$20	            REP #$20
.1a2fa7	29 ff 00	and #$00ff	            AND #$00FF
.1a2faa	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a2fad	e2 20		sep #$20	            SEP #$20
.1a2faf	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2fb2					S_CLRBITMAP
.1a2fb2	08		php		                PHP
.1a2fb3	c2 20		rep #$20	            REP #$20
.1a2fb5	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a2fb8	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2fbb	a5 23		lda $0823	                LDA ARGUMENT1
.1a2fbd	20 6b 2e	jsr $1a2e6b	            JSR BITMAP_VRAM
.1a2fc0	c2 20		rep #$20	            REP #$20
.1a2fc2	a5 9e		lda $089e	                LDA MTEMPPTR                ; Set the start address and the # of pixels to write
.1a2fc4	8f 05 04 af	sta $af0405	                STA @lVDMA_DST_ADDY_L
.1a2fc8	af 14 f0 1a	lda $1af014	                LDA @lGR_TOTAL_PIXELS       ; Set the size
.1a2fcc	8f 08 04 af	sta $af0408	                STA @lVDMA_SIZE_L
.1a2fd0	e2 20		sep #$20	            SEP #$20
.1a2fd2	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.1a2fd4	8f 07 04 af	sta $af0407	                STA @lVDMA_DST_ADDY_H
.1a2fd8	af 16 f0 1a	lda $1af016	                LDA @lGR_TOTAL_PIXELS+2
.1a2fdc	8f 0a 04 af	sta $af040a	                STA @lVDMA_SIZE_H
.1a2fe0	a9 00		lda #$00	                LDA #0                      ; Set the color to write
.1a2fe2	8f 01 04 af	sta $af0401	                STA @lVDMA_BYTE_2_WRITE
.1a2fe6	a9 85		lda #$85	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_Start_TRF
.1a2fe8	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.1a2fec	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.1a2ff0	30 fa		bmi $1a2fec	                BMI wait
.1a2ff2	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.1a2ff4	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.1a2ff8	28		plp		done            PLP
.1a2ff9	60		rts		            RTS
=$000855				COLOR = MARG1
=$000859				X0 = MARG2
=$00085d				Y0 = MARG3
=$000861				X1 = MARG4
=$000865				Y1 = MARG5
=$000869				DX = MARG6
=$00086d				DY = MARG7
=$000871				ERR = MARG8
=$000875				ERR2 = MARG9
>08dd					SX      .word ?
>08df					SY      .word ?
.1a2ffa					PLOT
.1a2ffa	08		php		                PHP
.1a2ffb	c2 20		rep #$20	            REP #$20
.1a2ffd	a5 5d		lda $085d	                LDA Y0                      ; Get the row
.1a2fff	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.1a3003	af 10 f0 1a	lda $1af010	                LDA @lGR_MAX_COLS
.1a3007	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B          ; Multiply by the number of columns in the pixmap
.1a300b	18		clc		                CLC                         ; Add the column
.1a300c	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT
.1a3010	65 59		adc $0859	                ADC X0
.1a3012	85 0c		sta $080c	                STA SCRATCH
.1a3014	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.1a3018	69 00 00	adc #$0000	                ADC #0
.1a301b	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH is offset of pixel in the pixmap
.1a301d	18		clc		                CLC                         ; Add the address of the first pixel
.1a301e	a5 0c		lda $080c	                LDA SCRATCH
.1a3020	65 9e		adc $089e	                ADC MTEMPPTR
.1a3022	85 0c		sta $080c	                STA SCRATCH
.1a3024	a5 0e		lda $080e	                LDA SCRATCH+2
.1a3026	65 a0		adc $08a0	                ADC MTEMPPTR+2
.1a3028	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH := pixmap + pixel offset
.1a302a	e2 20		sep #$20	            SEP #$20
.1a302c	a5 55		lda $0855	                LDA COLOR                   ; Get the color
.1a302e	87 0c		sta [$080c]	                STA [SCRATCH]               ; And write the color to the pixel
.1a3030	28		plp		                PLP
.1a3031	60		rts		            RTS
.1a3032					LINE
.1a3032	c2 20		rep #$20	            REP #$20
.1a3034	a9 01 00	lda #$0001	                LDA #1                      ; Assume SX = 1
.1a3037	85 dd		sta $08dd	                STA SX
.1a3039	38		sec		                SEC                         ; DX := ABS(X1 - X0)
.1a303a	a5 61		lda $0861	                LDA X1
.1a303c	e5 59		sbc $0859	                SBC X0
.1a303e	85 69		sta $0869	                STA DX
.1a3040	10 0b		bpl $1a304d	                BPL abs_Y                   ; If DX < 0 {
.1a3042	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DX := -DX
.1a3045	1a		inc a		                INC A
.1a3046	85 69		sta $0869	                STA DX
.1a3048	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SX := -1
.1a304b	85 dd		sta $08dd	                STA SX                      ; }
.1a304d	a9 01 00	lda #$0001	abs_Y           LDA #1                      ; Assume SY = 1
.1a3050	85 df		sta $08df	                STA SY
.1a3052	38		sec		                SEC                         ; DY := ABS(Y1 - Y0)
.1a3053	a5 65		lda $0865	                LDA Y1
.1a3055	e5 5d		sbc $085d	                SBC Y0
.1a3057	85 6d		sta $086d	                STA DY
.1a3059	10 0b		bpl $1a3066	                BPL calc_ERR                ; If DY < 0 {
.1a305b	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DY := -DY
.1a305e	1a		inc a		                INC A
.1a305f	85 6d		sta $086d	                STA DY
.1a3061	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SY := -1
.1a3064	85 df		sta $08df	                STA SY                      ; }
.1a3066	a5 6d		lda $086d	calc_ERR        LDA DY                      ; (DY < DX)
.1a3068	c5 69		cmp $0869	                CMP DX
.1a306a	b0 04		bcs $1a3070	                BGE else
.1a306c	a5 69		lda $0869	                LDA DX                      ; TRUE CASE: ERR := DX
.1a306e	80 06		bra $1a3076	                BRA shiftERR
.1a3070	a5 6d		lda $086d	else            LDA DY                      ; FALSE CASE: ERR := -DY
.1a3072	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a3075	1a		inc a		                INC A
.1a3076	48		pha		shiftERR        PHA
.1a3077	0a		asl a		                ASL A
.1a3078	68		pla		                PLA
.1a3079	6a		ror a		                ROR A                       ; ERR := ERR / 2
.1a307a	85 71		sta $0871	                STA ERR
.1a307c					loop
.1a307c	20 fa 2f	jsr $1a2ffa	            JSR PLOT
.1a307f	a5 59		lda $0859	                LDA X0                      ; break if X0=X1 and Y0=Y1
.1a3081	c5 61		cmp $0861	                CMP X1
.1a3083	d0 06		bne $1a308b	                BNE calc_ERR2
.1a3085	a5 5d		lda $085d	                LDA Y0
.1a3087	c5 65		cmp $0865	                CMP Y1
.1a3089	f0 36		beq $1a30c1	                BEQ done
.1a308b	a5 71		lda $0871	calc_ERR2       LDA ERR                     ; ERR2 := ERR
.1a308d	85 75		sta $0875	                STA ERR2
.1a308f	a5 69		lda $0869	                LDA DX                      ; if (ERR2 > -DX) {
.1a3091	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a3094	1a		inc a		                INC A
.1a3095	c5 75		cmp $0875	                CMP ERR2
.1a3097	10 10		bpl $1a30a9	                BPL check_DY
.1a3099	f0 0e		beq $1a30a9	                BEQ check_DY
.1a309b	38		sec		                SEC                         ; ERR -= DY
.1a309c	a5 71		lda $0871	                LDA ERR
.1a309e	e5 6d		sbc $086d	                SBC DY
.1a30a0	85 71		sta $0871	                STA ERR
.1a30a2	18		clc		                CLC                         ; X0 += SX
.1a30a3	a5 59		lda $0859	                LDA X0
.1a30a5	65 dd		adc $08dd	                ADC SX
.1a30a7	85 59		sta $0859	                STA X0                      ; }
.1a30a9	a5 75		lda $0875	check_DY        LDA ERR2                    ; if (ERR2 < DY) {
.1a30ab	c5 6d		cmp $086d	                CMP DY
.1a30ad	10 cd		bpl $1a307c	                BPL loop
.1a30af	f0 cb		beq $1a307c	                BEQ loop
.1a30b1	18		clc		                CLC                         ; ERR += DX
.1a30b2	a5 71		lda $0871	                LDA ERR
.1a30b4	65 69		adc $0869	                ADC DX
.1a30b6	85 71		sta $0871	                STA ERR
.1a30b8	18		clc		                CLC                         ; Y0 += SY
.1a30b9	a5 5d		lda $085d	                LDA Y0
.1a30bb	65 df		adc $08df	                ADC SY
.1a30bd	85 5d		sta $085d	                STA Y0                      ; }
.1a30bf	80 bb		bra $1a307c	                BRA loop                    ; }
.1a30c1					done
.1a30c1	60		rts		            RTS
.1a30c2					S_PLOT
.1a30c2	08		php		                PHP
.1a30c3					locals
>0001					L_PLANE         .word ?
>0003					L_X             .word ?
>0005					L_Y             .word ?
.1a30c3	c2 20		rep #$20	            REP #$20
.1a30c5	3b		tsc		            TSC
.1a30c6	38		sec		            SEC
.1a30c7	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.1a30ca	1b		tcs		            TCS
.1a30cb	08		php		            PHP
.1a30cc	c2 20		rep #$20	            REP #$20
.1a30ce	48		pha		            PHA
.1a30cf	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a30d2	5b		tcd		            TCD
.1a30d3	68		pla		            PLA
.1a30d4	28		plp		            PLP
.1a30d5	08		php		            PHP
.1a30d6	e2 20		sep #$20	            SEP #$20
.1a30d8	48		pha		            PHA
.1a30d9	a9 00		lda #$00	            LDA #0
.1a30db	48		pha		            PHA
.1a30dc	ab		plb		            PLB
.1a30dd	68		pla		            PLA
.1a30de	28		plp		            PLP
.1a30df	c2 30		rep #$30	            REP #$30
.1a30e1	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a30e4	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a30e7	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.1a30e9	a9 2c 00	lda #$002c	                LDA #','
.1a30ec	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a30ef	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a30f2	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a30f5	a5 23		lda $0823	                LDA ARGUMENT1
.1a30f7	83 03		sta $03,s	                STA L_X                     ; Save it to X
.1a30f9	a9 2c 00	lda #$002c	                LDA #','
.1a30fc	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a30ff	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3102	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3105	a5 23		lda $0823	                LDA ARGUMENT1
.1a3107	83 05		sta $05,s	                STA L_Y                     ; Save it to Y
.1a3109	a9 2c 00	lda #$002c	                LDA #','
.1a310c	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a310f	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3112	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a3115	a5 23		lda $0823	                LDA ARGUMENT1
.1a3117	85 55		sta $0855	                STA COLOR                   ; Save it to MARG1
.1a3119	a3 03		lda $03,s	                LDA L_X                     ; Set the (X0, Y0) coordinates
.1a311b	85 59		sta $0859	                STA X0
.1a311d	a3 05		lda $05,s	                LDA L_Y
.1a311f	85 5d		sta $085d	                STA Y0
.1a3121	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.1a3123	20 27 2e	jsr $1a2e27	            JSR BITMAP_SRAM
.1a3126	20 fa 2f	jsr $1a2ffa	            JSR PLOT
.1a3129	c2 20		rep #$20	            REP #$20
.1a312b	3b		tsc		            TSC
.1a312c	18		clc		            CLC
.1a312d	69 06 00	adc #$0006	            ADC #SIZE(locals)
.1a3130	1b		tcs		            TCS
.1a3131	28		plp		                PLP
.1a3132	60		rts		            RTS
.1a3133					S_LINE
.1a3133	08		php		                PHP
.1a3134					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
.1a3134	c2 20		rep #$20	            REP #$20
.1a3136	3b		tsc		            TSC
.1a3137	38		sec		            SEC
.1a3138	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.1a313b	1b		tcs		            TCS
.1a313c	08		php		            PHP
.1a313d	c2 20		rep #$20	            REP #$20
.1a313f	48		pha		            PHA
.1a3140	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3143	5b		tcd		            TCD
.1a3144	68		pla		            PLA
.1a3145	28		plp		            PLP
.1a3146	08		php		            PHP
.1a3147	e2 20		sep #$20	            SEP #$20
.1a3149	48		pha		            PHA
.1a314a	a9 00		lda #$00	            LDA #0
.1a314c	48		pha		            PHA
.1a314d	ab		plb		            PLB
.1a314e	68		pla		            PLA
.1a314f	28		plp		            PLP
.1a3150	c2 30		rep #$30	            REP #$30
.1a3152	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3155	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a3158	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.1a315a	a9 2c 00	lda #$002c	                LDA #','
.1a315d	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3160	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3163	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3166	a5 23		lda $0823	                LDA ARGUMENT1
.1a3168	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.1a316a	a9 2c 00	lda #$002c	                LDA #','
.1a316d	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3170	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3173	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3176	a5 23		lda $0823	                LDA ARGUMENT1
.1a3178	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.1a317a	a9 2c 00	lda #$002c	                LDA #','
.1a317d	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3180	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3183	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3186	a5 23		lda $0823	                LDA ARGUMENT1
.1a3188	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.1a318a	a9 2c 00	lda #$002c	                LDA #','
.1a318d	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3190	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3193	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3196	a5 23		lda $0823	                LDA ARGUMENT1
.1a3198	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.1a319a	a9 2c 00	lda #$002c	                LDA #','
.1a319d	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a31a0	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a31a3	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a31a6	a5 23		lda $0823	                LDA ARGUMENT1
.1a31a8	85 55		sta $0855	                STA COLOR                   ; Save it to COLOR
.1a31aa	a3 03		lda $03,s	                LDA L_X0                    ; Set the (X0, Y0) coordinates
.1a31ac	85 59		sta $0859	                STA X0
.1a31ae	a3 05		lda $05,s	                LDA L_Y0
.1a31b0	85 5d		sta $085d	                STA Y0
.1a31b2	a3 07		lda $07,s	                LDA L_X1                    ; Set the (X1, Y1) coordinates
.1a31b4	85 61		sta $0861	                STA X1
.1a31b6	a3 09		lda $09,s	                LDA L_Y1
.1a31b8	85 65		sta $0865	                STA Y1
.1a31ba	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.1a31bc	20 27 2e	jsr $1a2e27	            JSR BITMAP_SRAM
.1a31bf	20 32 30	jsr $1a3032	            JSR LINE
.1a31c2					done
.1a31c2	c2 20		rep #$20	            REP #$20
.1a31c4	3b		tsc		            TSC
.1a31c5	18		clc		            CLC
.1a31c6	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.1a31c9	1b		tcs		            TCS
.1a31ca	28		plp		                PLP
.1a31cb	60		rts		            RTS
.1a31cc					S_FILL
.1a31cc	08		php		                PHP
.1a31cd					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
>000b					L_COLOR         .word ?
.1a31cd	c2 20		rep #$20	            REP #$20
.1a31cf	3b		tsc		            TSC
.1a31d0	38		sec		            SEC
.1a31d1	e9 0c 00	sbc #$000c	            SBC #SIZE(locals)
.1a31d4	1b		tcs		            TCS
.1a31d5	08		php		            PHP
.1a31d6	c2 20		rep #$20	            REP #$20
.1a31d8	48		pha		            PHA
.1a31d9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a31dc	5b		tcd		            TCD
.1a31dd	68		pla		            PLA
.1a31de	28		plp		            PLP
.1a31df	08		php		            PHP
.1a31e0	e2 20		sep #$20	            SEP #$20
.1a31e2	48		pha		            PHA
.1a31e3	a9 00		lda #$00	            LDA #0
.1a31e5	48		pha		            PHA
.1a31e6	ab		plb		            PLB
.1a31e7	68		pla		            PLA
.1a31e8	28		plp		            PLP
.1a31e9	c2 30		rep #$30	            REP #$30
.1a31eb	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a31ee	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a31f1	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.1a31f3	a9 2c 00	lda #$002c	                LDA #','
.1a31f6	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a31f9	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a31fc	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a31ff	a5 23		lda $0823	                LDA ARGUMENT1
.1a3201	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.1a3203	a9 2c 00	lda #$002c	                LDA #','
.1a3206	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3209	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a320c	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a320f	a5 23		lda $0823	                LDA ARGUMENT1
.1a3211	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.1a3213	a9 2c 00	lda #$002c	                LDA #','
.1a3216	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3219	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a321c	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a321f	a5 23		lda $0823	                LDA ARGUMENT1
.1a3221	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.1a3223	a9 2c 00	lda #$002c	                LDA #','
.1a3226	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3229	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a322c	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a322f	a5 23		lda $0823	                LDA ARGUMENT1
.1a3231	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.1a3233	a9 2c 00	lda #$002c	                LDA #','
.1a3236	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3239	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a323c	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a323f	a5 23		lda $0823	                LDA ARGUMENT1
.1a3241	83 0b		sta $0b,s	                STA L_COLOR                 ; Save it to COLOR
.1a3243	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.1a3245	20 6b 2e	jsr $1a2e6b	            JSR BITMAP_VRAM
.1a3248	a9 07 00	lda #$0007	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_1D_2D
.1a324b	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a324f	c2 20		rep #$20	            REP #$20
.1a3251	a3 05		lda $05,s	                LDA L_Y0                    ; Get the row
.1a3253	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.1a3257	af 10 f0 1a	lda $1af010	                LDA @l GR_MAX_COLS
.1a325b	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B         ; Multiply by the number of columns in the pixmap
.1a325f	18		clc		                CLC                         ; Add the column
.1a3260	af 04 01 00	lda $000104	                LDA @l M0_RESULT
.1a3264	63 03		adc $03,s	                ADC L_X0
.1a3266	85 0c		sta $080c	                STA SCRATCH
.1a3268	e2 20		sep #$20	            SEP #$20
.1a326a	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.1a326e	69 00		adc #$00	                ADC #0
.1a3270	85 0e		sta $080e	                STA SCRATCH+2
.1a3272	c2 20		rep #$20	            REP #$20
.1a3274	18		clc		                CLC                         ; Set the destination address
.1a3275	a5 9e		lda $089e	                LDA MTEMPPTR
.1a3277	65 0c		adc $080c	                ADC SCRATCH
.1a3279	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.1a327d	e2 20		sep #$20	            SEP #$20
.1a327f	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.1a3281	65 0e		adc $080e	                ADC SCRATCH+2
.1a3283	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H
.1a3287	c2 20		rep #$20	            REP #$20
.1a3289	38		sec		                SEC                         ; Set the width of the FILL operation
.1a328a	a3 07		lda $07,s	                LDA L_X1
.1a328c	e3 03		sbc $03,s	                SBC L_X0
.1a328e	85 0c		sta $080c	                STA SCRATCH
.1a3290	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.1a3294	38		sec		                SEC
.1a3295	af 10 f0 1a	lda $1af010	                LDA @l GR_MAX_COLS
.1a3299	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L    ; And the destination stride
.1a329d	38		sec		                SEC                         ; Set the height of the FILL operation
.1a329e	a3 09		lda $09,s	                LDA L_Y1
.1a32a0	e3 05		sbc $05,s	                SBC L_Y0
.1a32a2	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.1a32a6	e2 20		sep #$20	            SEP #$20
.1a32a8	a3 0b		lda $0b,s	                LDA L_COLOR                 ; Set the color to write
.1a32aa	8f 01 04 af	sta $af0401	                STA @l VDMA_BYTE_2_WRITE
.1a32ae	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.1a32b2	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF
.1a32b4	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a32b8	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.1a32bc	30 fa		bmi $1a32b8	                BMI wait
.1a32be	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.1a32c0	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a32c4					done
.1a32c4	c2 20		rep #$20	            REP #$20
.1a32c6	3b		tsc		            TSC
.1a32c7	18		clc		            CLC
.1a32c8	69 0c 00	adc #$000c	            ADC #SIZE(locals)
.1a32cb	1b		tcs		            TCS
.1a32cc	28		plp		                PLP
.1a32cd	60		rts		            RTS
.1a32ce					SPADDR
.1a32ce	08		php		                PHP
.1a32cf	c2 20		rep #$20	            REP #$20
.1a32d1	c9 40 00	cmp #$0040	                CMP #SP_MAX
.1a32d4	b0 13		bcs $1a32e9	                BGE error
.1a32d6	0a		asl a		                ASL A                       ; Multiply it by 8 (the size of s sprite block)
.1a32d7	0a		asl a		                ASL A
.1a32d8	0a		asl a		                ASL A
.1a32d9	18		clc		                CLC                         ; Add it to the address of the first
.1a32da	69 00 0c	adc #$0c00	                ADC #<>SP00_CONTROL_REG     ; sprite block
.1a32dd	85 9e		sta $089e	                STA MTEMPPTR
.1a32df	a9 af 00	lda #$00af	                LDA #`SP00_CONTROL_REG
.1a32e2	69 00 00	adc #$0000	                ADC #0
.1a32e5	85 a0		sta $08a0	                STA MTEMPPTR+2              ; And save that to MTEMPPTR
.1a32e7	28		plp		                PLP
.1a32e8	60		rts		            RTS
.1a32e9					error
.1a32e9	08		php		            PHP
.1a32ea	c2 20		rep #$20	            REP #$20
.1a32ec	48		pha		            PHA
.1a32ed	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a32f0	5b		tcd		            TCD
.1a32f1	68		pla		            PLA
.1a32f2	28		plp		            PLP
.1a32f3	e2 20		sep #$20	            SEP #$20
.1a32f5	a9 09		lda #$09	            LDA #ERR_RANGE
.1a32f7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a32fb	c2 20		rep #$20	            REP #$20
.1a32fd	29 ff 00	and #$00ff	            AND #$00FF
.1a3300	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a3303	e2 20		sep #$20	            SEP #$20
.1a3305	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3308					S_SPRITE
.1a3308	08		php		                PHP
.1a3309					locals
>0001					L_SPRITE        .word ?
>0003					L_LUT           .byte ?
.1a3309	c2 20		rep #$20	            REP #$20
.1a330b	3b		tsc		            TSC
.1a330c	38		sec		            SEC
.1a330d	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.1a3310	1b		tcs		            TCS
.1a3311	c2 30		rep #$30	            REP #$30
.1a3313	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3316	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a3319	a5 23		lda $0823	                LDA ARGUMENT1
.1a331b	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.1a331d	a9 2c 00	lda #$002c	                LDA #','
.1a3320	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3323	e2 20		sep #$20	            SEP #$20
.1a3325	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3328	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a332b	a5 23		lda $0823	                LDA ARGUMENT1
.1a332d	c9 08		cmp #$08	                CMP #GR_MAX_LUT             ; Check that it's in range
.1a332f	b0 56		bcs $1a3387	                BGE error                   ; If not: throw an error
.1a3331	83 03		sta $03,s	                STA L_LUT                   ; Save it as lut
.1a3333	a9 2c		lda #$2c	                LDA #','
.1a3335	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3338	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a333b	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a333e	c2 20		rep #$20	            REP #$20
.1a3340	38		sec		                SEC                         ; Adjust address to be in Vicky's space
.1a3341	a5 23		lda $0823	                LDA ARGUMENT1
.1a3343	e9 00 00	sbc #$0000	                SBC #<>VRAM
.1a3346	85 23		sta $0823	                STA ARGUMENT1
.1a3348	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a334a	e9 b0 00	sbc #$00b0	                SBC #`VRAM
.1a334d	85 25		sta $0825	                STA ARGUMENT1+2
.1a334f	30 36		bmi $1a3387	                BMI error                   ; If negative, throw an error
.1a3351	c2 20		rep #$20	            REP #$20
.1a3353	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a3355	aa		tax		                TAX
.1a3356	20 ce 32	jsr $1a32ce	            JSR SPADDR
.1a3359	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the lower word of the address
.1a335b	a0 01 00	ldy #$0001	                LDY #SP_ADDR
.1a335e	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3360	e2 20		sep #$20	            SEP #$20
.1a3362	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3364	c8		iny		                INY
.1a3365	c8		iny		                INY
.1a3366	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save the upper byte of the address
.1a3368	bf 18 f0 1a	lda $1af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the sprite control register
.1a336c	29 f1		and #$f1	                AND #%11110001              ; Filter off the current LUT
.1a336e	85 0c		sta $080c	                STA SCRATCH
.1a3370	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT back
.1a3372	0a		asl a		                ASL A                       ; Sift it into the LUT position
.1a3373	29 0e		and #$0e	                AND #%00001110              ; Make sure we don't have anything wrong there
.1a3375	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with what's in the sprite's control
.1a3377	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the register's bits
.1a3379	9f 18 f0 1a	sta $1af018,x	                STA @l GS_SP_CONTROL,X      ; And the shadow register
.1a337d					done
.1a337d	c2 20		rep #$20	            REP #$20
.1a337f	3b		tsc		            TSC
.1a3380	18		clc		            CLC
.1a3381	69 03 00	adc #$0003	            ADC #SIZE(locals)
.1a3384	1b		tcs		            TCS
.1a3385	28		plp		                PLP
.1a3386	60		rts		            RTS
.1a3387					error
.1a3387	08		php		            PHP
.1a3388	c2 20		rep #$20	            REP #$20
.1a338a	48		pha		            PHA
.1a338b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a338e	5b		tcd		            TCD
.1a338f	68		pla		            PLA
.1a3390	28		plp		            PLP
.1a3391	e2 20		sep #$20	            SEP #$20
.1a3393	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3395	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3399	c2 20		rep #$20	            REP #$20
.1a339b	29 ff 00	and #$00ff	            AND #$00FF
.1a339e	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a33a1	e2 20		sep #$20	            SEP #$20
.1a33a3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a33a6					S_SPRITEAT
.1a33a6	08		php		                PHP
.1a33a7					locals
>0001					L_SPRITE        .word ?
>0003					L_X             .word ?
.1a33a7	c2 20		rep #$20	            REP #$20
.1a33a9	3b		tsc		            TSC
.1a33aa	38		sec		            SEC
.1a33ab	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.1a33ae	1b		tcs		            TCS
.1a33af	c2 30		rep #$30	            REP #$30
.1a33b1	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a33b4	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a33b7	a5 23		lda $0823	                LDA ARGUMENT1
.1a33b9	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.1a33bb	a9 2c 00	lda #$002c	                LDA #','
.1a33be	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a33c1	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a33c4	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a33c7	a5 23		lda $0823	                LDA ARGUMENT1
.1a33c9	83 03		sta $03,s	                STA L_X                     ; Save it as X
.1a33cb	a9 2c 00	lda #$002c	                LDA #','
.1a33ce	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a33d1	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a33d4	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a33d7	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a33d9	20 ce 32	jsr $1a32ce	            JSR SPADDR
.1a33dc	a3 03		lda $03,s	                LDA L_X                     ; Get the X coordinate
.1a33de	a0 04 00	ldy #$0004	                LDY #SP_X_COORD             ; Save the X coordinate for the sprite
.1a33e1	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a33e3	a5 23		lda $0823	                LDA ARGUMENT1
.1a33e5	a0 06 00	ldy #$0006	                LDY #SP_Y_COORD             ; Save the Y coordinate for the sprite
.1a33e8	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a33ea					done
.1a33ea	c2 20		rep #$20	            REP #$20
.1a33ec	3b		tsc		            TSC
.1a33ed	18		clc		            CLC
.1a33ee	69 04 00	adc #$0004	            ADC #SIZE(locals)
.1a33f1	1b		tcs		            TCS
.1a33f2	28		plp		                PLP
.1a33f3	60		rts		            RTS
.1a33f4					S_SPRITESHOW
.1a33f4	08		php		                PHP
.1a33f5					locals
>0001					L_SPRITE        .word ?
>0003					L_VISIBLE       .byte ?
.1a33f5	c2 20		rep #$20	            REP #$20
.1a33f7	3b		tsc		            TSC
.1a33f8	38		sec		            SEC
.1a33f9	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.1a33fc	1b		tcs		            TCS
.1a33fd	c2 30		rep #$30	            REP #$30
.1a33ff	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3402	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a3405	a5 23		lda $0823	                LDA ARGUMENT1
.1a3407	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.1a3409	a9 2c 00	lda #$002c	                LDA #','
.1a340c	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a340f	e2 20		sep #$20	            SEP #$20
.1a3411	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3414	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3417	a5 23		lda $0823	                LDA ARGUMENT1
.1a3419	d0 04		bne $1a341f	                BNE is_visible
.1a341b	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 0 (not visible)
.1a341d	80 04		bra $1a3423	                BRA chk_layer
.1a341f	a9 01		lda #$01	is_visible      LDA #1
.1a3421	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 1 (visible)
.1a3423	a9 2c		lda #$2c	chk_layer       LDA #','
.1a3425	85 37		sta $0837	                STA TARGETTOK
.1a3427	20 1f 22	jsr $1a221f	            JSR OPT_TOK
.1a342a	b0 20		bcs $1a344c	                BCS get_layer               ; Yes: get the layer
.1a342c					no_layer
.1a342c	c2 30		rep #$30	            REP #$30
.1a342e	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a3430	aa		tax		                TAX
.1a3431	20 ce 32	jsr $1a32ce	            JSR SPADDR
.1a3434	e2 20		sep #$20	            SEP #$20
.1a3436	bf 18 f0 1a	lda $1af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.1a343a	29 fe		and #$fe	                AND #$FE                    ; Filter out the enable bit
.1a343c	85 0c		sta $080c	                STA SCRATCH
.1a343e	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.1a3440	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.1a3442	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.1a3444	9f 18 f0 1a	sta $1af018,x	                STA @l GS_SP_CONTROL,X      ; And save it
.1a3448	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; ... and to Vicky
.1a344a	80 36		bra $1a3482	                BRA done
.1a344c					get_layer
.1a344c	c2 30		rep #$30	            REP #$30
.1a344e	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a3451	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3454	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a3457	a5 23		lda $0823	                LDA ARGUMENT1
.1a3459	c9 08 00	cmp #$0008	                CMP #8                      ; Make sure it's in range
.1a345c	b0 2e		bcs $1a348c	                BGE error                   ; If not, throw an out of range error
.1a345e	0a		asl a		                ASL A                       ; If it's ok... shift it into position
.1a345f	0a		asl a		                ASL A
.1a3460	0a		asl a		                ASL A
.1a3461	0a		asl a		                ASL A
.1a3462	85 0c		sta $080c	                STA SCRATCH                 ; And save it in SCRATCH
.1a3464	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a3466	aa		tax		                TAX
.1a3467	20 ce 32	jsr $1a32ce	            JSR SPADDR
.1a346a	e2 20		sep #$20	            SEP #$20
.1a346c	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.1a346e	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.1a3470	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.1a3472	85 0c		sta $080c	                STA SCRATCH
.1a3474	bf 18 f0 1a	lda $1af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.1a3478	29 8e		and #$8e	                AND #%10001110              ; Filter out the enable and layer bits
.1a347a	05 0c		ora $080c	                ORA SCRATCH                 ; Combine with the provided layer and enable
.1a347c	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the bits in Vicky
.1a347e	9f 18 f0 1a	sta $1af018,x	                STA @l GS_SP_CONTROL,X      ; And to the shadow registers
.1a3482					done
.1a3482	c2 20		rep #$20	            REP #$20
.1a3484	3b		tsc		            TSC
.1a3485	18		clc		            CLC
.1a3486	69 03 00	adc #$0003	            ADC #SIZE(locals)
.1a3489	1b		tcs		            TCS
.1a348a	28		plp		                PLP
.1a348b	60		rts		            RTS
.1a348c					error
.1a348c	08		php		            PHP
.1a348d	c2 20		rep #$20	            REP #$20
.1a348f	48		pha		            PHA
.1a3490	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3493	5b		tcd		            TCD
.1a3494	68		pla		            PLA
.1a3495	28		plp		            PLP
.1a3496	e2 20		sep #$20	            SEP #$20
.1a3498	a9 09		lda #$09	            LDA #ERR_RANGE
.1a349a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a349e	c2 20		rep #$20	            REP #$20
.1a34a0	29 ff 00	and #$00ff	            AND #$00FF
.1a34a3	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a34a6	e2 20		sep #$20	            SEP #$20
.1a34a8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a34ab					TILESET_ADDR
.1a34ab	08		php		                PHP
.1a34ac	c2 20		rep #$20	            REP #$20
.1a34ae	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.1a34b1	b0 19		bcs $1a34cc	                BGE out_of_range            ; If not, throw a range error
.1a34b3	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.1a34b6	a9 04 00	lda #$0004	                LDA #TILESET_REG_SIZE       ; Multiply it by the number of bytes in a tile set register set
.1a34b9	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.1a34bc	18		clc		                CLC                         ; Add to TILESET0_ADDY_L to get the final address
.1a34bd	ad 04 01	lda $0104	                LDA @w M0_RESULT
.1a34c0	69 80 02	adc #$0280	                ADC #<>TILESET0_ADDY_L
.1a34c3	85 9e		sta $089e	                STA MTEMPPTR
.1a34c5	a9 af 00	lda #$00af	                LDA #`TILESET0_ADDY_L
.1a34c8	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a34ca	28		plp		                PLP
.1a34cb	60		rts		            RTS
.1a34cc					out_of_range
.1a34cc	08		php		            PHP
.1a34cd	c2 20		rep #$20	            REP #$20
.1a34cf	48		pha		            PHA
.1a34d0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a34d3	5b		tcd		            TCD
.1a34d4	68		pla		            PLA
.1a34d5	28		plp		            PLP
.1a34d6	e2 20		sep #$20	            SEP #$20
.1a34d8	a9 09		lda #$09	            LDA #ERR_RANGE
.1a34da	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a34de	c2 20		rep #$20	            REP #$20
.1a34e0	29 ff 00	and #$00ff	            AND #$00FF
.1a34e3	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a34e6	e2 20		sep #$20	            SEP #$20
.1a34e8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a34eb					TILEMAP_ADDR
.1a34eb	08		php		                PHP
.1a34ec	c2 20		rep #$20	            REP #$20
.1a34ee	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.1a34f1	b0 19		bcs $1a350c	                BGE out_of_range            ; If not, throw a range error
.1a34f3	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.1a34f6	a9 0c 00	lda #$000c	                LDA #TILEMAP_REG_SIZE       ; Multiply it by the number of bytes in a tile map register set
.1a34f9	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.1a34fc	18		clc		                CLC
.1a34fd	ad 04 01	lda $0104	                LDA @w M0_RESULT            ; Add to TL0_CONTROL_REG to get the final address
.1a3500	69 00 02	adc #$0200	                ADC #<>TL0_CONTROL_REG
.1a3503	85 9e		sta $089e	                STA MTEMPPTR
.1a3505	a9 af 00	lda #$00af	                LDA #`TL0_CONTROL_REG
.1a3508	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a350a	28		plp		                PLP
.1a350b	60		rts		            RTS
.1a350c					out_of_range
.1a350c	08		php		            PHP
.1a350d	c2 20		rep #$20	            REP #$20
.1a350f	48		pha		            PHA
.1a3510	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3513	5b		tcd		            TCD
.1a3514	68		pla		            PLA
.1a3515	28		plp		            PLP
.1a3516	e2 20		sep #$20	            SEP #$20
.1a3518	a9 09		lda #$09	            LDA #ERR_RANGE
.1a351a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a351e	c2 20		rep #$20	            REP #$20
.1a3520	29 ff 00	and #$00ff	            AND #$00FF
.1a3523	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a3526	e2 20		sep #$20	            SEP #$20
.1a3528	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a352b					S_TILESET
.1a352b	08		php		                PHP
.1a352c					locals
>0001					L_TILENUM       .word ?
>0003					L_LUT           .word ?
>0005					L_IS_SQUARE     .word ?
.1a352c	c2 20		rep #$20	            REP #$20
.1a352e	3b		tsc		            TSC
.1a352f	38		sec		            SEC
.1a3530	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.1a3533	1b		tcs		            TCS
.1a3534	c2 20		rep #$20	            REP #$20
.1a3536	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3539	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a353c	a5 23		lda $0823	                LDA ARGUMENT1
.1a353e	83 01		sta $01,s	                STA L_TILENUM               ; Save it as the tile set/map number
.1a3540	a9 2c 00	lda #$002c	                LDA #','
.1a3543	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3546	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3549	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a354c	a5 23		lda $0823	                LDA ARGUMENT1
.1a354e	83 03		sta $03,s	                STA L_LUT                   ; Save it as LUT
.1a3550	a9 2c 00	lda #$002c	                LDA #','
.1a3553	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3556	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3559	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a355c	a5 23		lda $0823	                LDA ARGUMENT1
.1a355e	83 05		sta $05,s	                STA L_IS_SQUARE             ; Save it as IS_SQUARE
.1a3560	a9 2c 00	lda #$002c	                LDA #','
.1a3563	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3566	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3569	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a356c	a3 01		lda $01,s	                LDA L_TILENUM
.1a356e	20 ab 34	jsr $1a34ab	            JSR TILESET_ADDR
.1a3571	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the bitmap address - the address of the start of VRAM
.1a3573	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And save it to the registers
.1a3575	e2 20		sep #$20	            SEP #$20
.1a3577	38		sec		                SEC
.1a3578	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a357a	e9 b0		sbc #$b0	                SBC #`VRAM
.1a357c	a0 02 00	ldy #$0002	                LDY #TILESET_ADDY_H
.1a357f	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3581	a3 05		lda $05,s	                LDA L_IS_SQUARE             ; Check if is_square == 0?
.1a3583	d0 0d		bne $1a3592	                BNE is_square
.1a3585					not_square
.1a3585	e2 20		sep #$20	            SEP #$20
.1a3587	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.1a3589	29 07		and #$07	                AND #$07                    ; Force it to be in range
.1a358b	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.1a358e	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.1a3590	80 0d		bra $1a359f	                BRA done
.1a3592					is_square
.1a3592	e2 20		sep #$20	            SEP #$20
.1a3594	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.1a3596	29 07		and #$07	                AND #$07                    ; Force it to be in range
.1a3598	09 08		ora #$08	                ORA #TILESET_SQUARE_256     ; Turn on the 256x256 flag
.1a359a	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.1a359d	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.1a359f					done
.1a359f	c2 20		rep #$20	            REP #$20
.1a35a1	3b		tsc		            TSC
.1a35a2	18		clc		            CLC
.1a35a3	69 06 00	adc #$0006	            ADC #SIZE(locals)
.1a35a6	1b		tcs		            TCS
.1a35a7	28		plp		                PLP
.1a35a8	60		rts		            RTS
.1a35a9					S_TILEMAP
.1a35a9	08		php		                PHP
.1a35aa					locals
>0001					L_TILENUM       .word ?
>0003					L_WIDTH         .word ?
>0005					L_HEIGHT        .word ?
.1a35aa	c2 20		rep #$20	            REP #$20
.1a35ac	3b		tsc		            TSC
.1a35ad	38		sec		            SEC
.1a35ae	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.1a35b1	1b		tcs		            TCS
.1a35b2	c2 20		rep #$20	            REP #$20
.1a35b4	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a35b7	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a35ba	a5 23		lda $0823	                LDA ARGUMENT1
.1a35bc	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.1a35be	a9 2c 00	lda #$002c	                LDA #','
.1a35c1	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a35c4	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a35c7	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a35ca	a5 23		lda $0823	                LDA ARGUMENT1
.1a35cc	83 03		sta $03,s	                STA L_WIDTH                 ; Save it as WIDTH
.1a35ce	a9 2c 00	lda #$002c	                LDA #','
.1a35d1	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a35d4	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a35d7	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a35da	a5 23		lda $0823	                LDA ARGUMENT1
.1a35dc	83 05		sta $05,s	                STA L_HEIGHT                ; Save it as HEIGHT
.1a35de	a9 2c 00	lda #$002c	                LDA #','
.1a35e1	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a35e4	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a35e7	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a35ea	a3 01		lda $01,s	                LDA L_TILENUM
.1a35ec	20 eb 34	jsr $1a34eb	            JSR TILEMAP_ADDR
.1a35ef	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the map address - the address of the start of VRAM
.1a35f1	a0 01 00	ldy #$0001	                LDY #TILEMAP_START_ADDY
.1a35f4	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; And save it to the registers
.1a35f6	e2 20		sep #$20	            SEP #$20
.1a35f8	38		sec		                SEC
.1a35f9	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a35fb	e9 b0		sbc #$b0	                SBC #`VRAM
.1a35fd	c8		iny		                INY
.1a35fe	c8		iny		                INY
.1a35ff	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3601	c2 20		rep #$20	            REP #$20
.1a3603	a3 03		lda $03,s	                LDA L_WIDTH                 ; Set the width
.1a3605	a0 04 00	ldy #$0004	                LDY #TILEMAP_TOTAL_X
.1a3608	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a360a	a3 05		lda $05,s	                LDA L_HEIGHT                ; Set the height
.1a360c	a0 06 00	ldy #$0006	                LDY #TILEMAP_TOTAL_Y
.1a360f	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3611					done
.1a3611	c2 20		rep #$20	            REP #$20
.1a3613	3b		tsc		            TSC
.1a3614	18		clc		            CLC
.1a3615	69 06 00	adc #$0006	            ADC #SIZE(locals)
.1a3618	1b		tcs		            TCS
.1a3619	28		plp		                PLP
.1a361a	60		rts		            RTS
.1a361b					S_TILESHOW
.1a361b	08		php		                PHP
.1a361c					locals
>0001					L_TILENUM       .word ?
.1a361c	c2 20		rep #$20	            REP #$20
.1a361e	f4 00 00	pea #$0000	            PEA #0
.1a3621	c2 20		rep #$20	            REP #$20
.1a3623	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3626	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a3629	a5 23		lda $0823	                LDA ARGUMENT1
.1a362b	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.1a362d	a9 2c 00	lda #$002c	                LDA #','
.1a3630	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3633	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3636	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3639	a3 01		lda $01,s	                LDA L_TILENUM
.1a363b	20 eb 34	jsr $1a34eb	            JSR TILEMAP_ADDR
.1a363e	a5 23		lda $0823	                LDA ARGUMENT1               ; CHeck the visible parameter
.1a3640	d0 06		bne $1a3648	                BNE is_visible              ; If it's <> 0, make it visible
.1a3642	e2 20		sep #$20	            SEP #$20
.1a3644	a9 00		lda #$00	                LDA #0                      ; Control value for invisible
.1a3646	80 04		bra $1a364c	                BRA set_control
.1a3648					is_visible
.1a3648	e2 20		sep #$20	            SEP #$20
.1a364a	a9 01		lda #$01	                LDA #TILEMAP_VISIBLE        ; Control value for visible
.1a364c					set_control
.1a364c	e2 20		sep #$20	            SEP #$20
.1a364e	a0 00 00	ldy #$0000	                LDY #TILEMAP_CONTROL        ; Set the control register
.1a3651	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3653					done
.1a3653	c2 20		rep #$20	            REP #$20
.1a3655	68		pla		            PLA
.1a3656	28		plp		                PLP
.1a3657	60		rts		            RTS
.1a3658					S_TILEAT
.1a3658	08		php		                PHP
.1a3659					locals
>0001					L_TILENUM       .word ?
>0003					L_X             .word ?
.1a3659	c2 20		rep #$20	            REP #$20
.1a365b	3b		tsc		            TSC
.1a365c	38		sec		            SEC
.1a365d	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.1a3660	1b		tcs		            TCS
.1a3661	c2 20		rep #$20	            REP #$20
.1a3663	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3666	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a3669	a5 23		lda $0823	                LDA ARGUMENT1
.1a366b	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.1a366d	a9 2c 00	lda #$002c	                LDA #','
.1a3670	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3673	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3676	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3679	a5 23		lda $0823	                LDA ARGUMENT1
.1a367b	83 03		sta $03,s	                STA L_X                     ; Save as X
.1a367d	a9 2c 00	lda #$002c	                LDA #','
.1a3680	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3683	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3686	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3689	a3 01		lda $01,s	                LDA L_TILENUM
.1a368b	20 eb 34	jsr $1a34eb	            JSR TILEMAP_ADDR
.1a368e	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the Y position
.1a3690	a0 0a 00	ldy #$000a	                LDY #TILEMAP_WINDOW_Y
.1a3693	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3695	a3 03		lda $03,s	                LDA L_X                     ; Set the X position
.1a3697	a0 08 00	ldy #$0008	                LDY #TILEMAP_WINDOW_X
.1a369a	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a369c					done
.1a369c	c2 20		rep #$20	            REP #$20
.1a369e	3b		tsc		            TSC
.1a369f	18		clc		            CLC
.1a36a0	69 04 00	adc #$0004	            ADC #SIZE(locals)
.1a36a3	1b		tcs		            TCS
.1a36a4	28		plp		                PLP
.1a36a5	60		rts		            RTS
=0					DMA_LINEAR = 0                              ; Memory to copy is a continguous, linear range
=1					DMA_RECT = 1                                ; Memory to copy is a rectangular block
.0000					DMA_BLOCK
>0000					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>0001					ADDR            .long ?                     ; The starting address for the data to transfer
>0004					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>0007					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>0009					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>000b					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
=$01					DMA_SRC_2D = $01                            ; Source transfer should be 2D
=$02					DMA_DST_2D = $02                            ; Destination transfer should be 2D
=$10					DMA_SRC_SRAM = $10                          ; Flag indicating that the source is in SRAM ($00:0000 - $3F:FFFF)
=$20					DMA_DST_SRAM = $20                          ; Flag indicating that the destination is in SRAM ($00:0000 - $3F:FFFF)
>1af058					DMA_BLOCKS      .byte ?                     ; What blocks are involved
.1af059					DMA_SRC
>1af059					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>1af05a					ADDR            .long ?                     ; The starting address for the data to transfer
>1af05d					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>1af060					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>1af062					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>1af064					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.1af066					DMA_DEST
>1af066					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>1af067					ADDR            .long ?                     ; The starting address for the data to transfer
>1af06a					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>1af06d					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>1af06f					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>1af071					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.1a36a6					DO_DMA
.1a36a6	0b		phd		                PHD
.1a36a7	08		php		                PHP
.1a36a8	08		php		            PHP
.1a36a9	c2 20		rep #$20	            REP #$20
.1a36ab	48		pha		            PHA
.1a36ac	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a36af	5b		tcd		            TCD
.1a36b0	68		pla		            PLA
.1a36b1	28		plp		            PLP
.1a36b2	e2 20		sep #$20	            SEP #$20
.1a36b4	a9 00		lda #$00	                LDA #0
.1a36b6	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS           ; Set mode to something neutral
.1a36ba	af 5c f0 1a	lda $1af05c	                LDA @l DMA_SRC.ADDR+2       ; Check the bank
.1a36be	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.1a36c0	b0 1c		bcs $1a36de	                BGE src_vram                ; Yes: leave the DMA_BLOCK bit alone
.1a36c2	8f 24 04 af	sta $af0424	src_sram        STA @l SDMA_SRC_ADDY_H      ; Set the SDMA source address
.1a36c6	af 5b f0 1a	lda $1af05b	                LDA @l DMA_SRC.ADDR+1
.1a36ca	8f 23 04 af	sta $af0423	                STA @l SDMA_SRC_ADDY_M
.1a36ce	af 5a f0 1a	lda $1af05a	                LDA @l DMA_SRC.ADDR
.1a36d2	8f 22 04 af	sta $af0422	                STA @l SDMA_SRC_ADDY_L
.1a36d6	a9 10		lda #$10	                LDA #DMA_SRC_SRAM           ; Set the SRAM source block bit
.1a36d8	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a36dc	80 17		bra $1a36f5	                BRA src_mode
.1a36de	38		sec		src_vram        SEC                         ; Convert to VRAM relative address
.1a36df	e9 b0		sbc #$b0	                SBC #`VRAM
.1a36e1	8f 04 04 af	sta $af0404	                STA @l VDMA_SRC_ADDY_H      ; Set the VDMA source address
.1a36e5	af 5b f0 1a	lda $1af05b	                LDA @l DMA_SRC.ADDR+1
.1a36e9	8f 03 04 af	sta $af0403	                STA @l VDMA_SRC_ADDY_M
.1a36ed	af 5a f0 1a	lda $1af05a	                LDA @l DMA_SRC.ADDR
.1a36f1	8f 02 04 af	sta $af0402	                STA @l VDMA_SRC_ADDY_L
.1a36f5	af 59 f0 1a	lda $1af059	src_mode        LDA @l DMA_SRC.MODE         ; Determine if source is 1D or 2D
.1a36f9	d0 3c		bne $1a3737	                BNE src_2d
.1a36fb	af 58 f0 1a	lda $1af058	src_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.1a36ff	f0 1b		beq $1a371c	                BEQ src_1d_vram
.1a3701	af 5d f0 1a	lda $1af05d	src_1d_sram     LDA @l DMA_SRC.SIZE         ; It's SRAM, so set the SDMA size
.1a3705	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.1a3709	af 5e f0 1a	lda $1af05e	                LDA @l DMA_SRC.SIZE+1
.1a370d	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_M
.1a3711	af 5f f0 1a	lda $1af05f	                LDA @l DMA_SRC.SIZE+2
.1a3715	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.1a3719	82 8b 00	brl $1a37a7	                BRL set_dst                 ; Go to set up the destination
.1a371c	af 5d f0 1a	lda $1af05d	src_1d_vram     LDA @l DMA_SRC.SIZE         ; It's VRAM, so set the VDMA size
.1a3720	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.1a3724	af 5e f0 1a	lda $1af05e	                LDA @l DMA_SRC.SIZE+1
.1a3728	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_M
.1a372c	af 5f f0 1a	lda $1af05f	                LDA @l DMA_SRC.SIZE+2
.1a3730	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.1a3734	82 70 00	brl $1a37a7	                BRL set_dst                 ; Go to set up the destination
.1a3737	af 58 f0 1a	lda $1af058	src_2d          LDA @l DMA_BLOCKS
.1a373b	09 01		ora #$01	                ORA #DMA_SRC_2D             ; Set the bit to make the source a 2D transfer
.1a373d	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a3741	89 10		bit #$10	                BIT #DMA_SRC_SRAM           ; Are we writing to SRAM
.1a3743	f0 32		beq $1a3777	                BEQ src_2d_vram             ; No: set the 2d values in the VRAM source
.1a3745	af 60 f0 1a	lda $1af060	src_2d_sram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.1a3749	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.1a374d	af 61 f0 1a	lda $1af061	                LDA @l DMA_SRC.WIDTH+1
.1a3751	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.1a3755	af 62 f0 1a	lda $1af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.1a3759	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.1a375d	af 63 f0 1a	lda $1af063	                LDA @l DMA_SRC.HEIGHT+1
.1a3761	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.1a3765	af 64 f0 1a	lda $1af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.1a3769	8f 2c 04 af	sta $af042c	                STA @l SDMA_SRC_STRIDE_L
.1a376d	af 65 f0 1a	lda $1af065	                LDA @l DMA_SRC.STRIDE+1
.1a3771	8f 2d 04 af	sta $af042d	                STA @l SDMA_SRC_STRIDE_L+1
.1a3775	80 30		bra $1a37a7	                BRA set_dst
.1a3777	af 60 f0 1a	lda $1af060	src_2d_vram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.1a377b	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.1a377f	af 61 f0 1a	lda $1af061	                LDA @l DMA_SRC.WIDTH+1
.1a3783	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.1a3787	af 62 f0 1a	lda $1af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.1a378b	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.1a378f	af 63 f0 1a	lda $1af063	                LDA @l DMA_SRC.HEIGHT+1
.1a3793	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.1a3797	af 64 f0 1a	lda $1af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.1a379b	8f 0c 04 af	sta $af040c	                STA @l VDMA_SRC_STRIDE_L
.1a379f	af 65 f0 1a	lda $1af065	                LDA @l DMA_SRC.STRIDE+1
.1a37a3	8f 0d 04 af	sta $af040d	                STA @l VDMA_SRC_STRIDE_L+1
.1a37a7					set_dst
.1a37a7	e2 20		sep #$20	            SEP #$20
.1a37a9	af 69 f0 1a	lda $1af069	                LDA @l DMA_DEST.ADDR+2      ; Check the bank
.1a37ad	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.1a37af	b0 20		bcs $1a37d1	                BGE dst_vram                ; Yes: leave the DMA_BLOCK bit alone
.1a37b1	8f 27 04 af	sta $af0427	dst_sram        STA @l SDMA_DST_ADDY_H      ; Set the SDMA destination address
.1a37b5	af 68 f0 1a	lda $1af068	                LDA @l DMA_DEST.ADDR+1
.1a37b9	8f 26 04 af	sta $af0426	                STA @l SDMA_DST_ADDY_M
.1a37bd	af 67 f0 1a	lda $1af067	                LDA @l DMA_DEST.ADDR
.1a37c1	8f 25 04 af	sta $af0425	                STA @l SDMA_DST_ADDY_L
.1a37c5	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS
.1a37c9	09 20		ora #$20	                ORA #DMA_DST_SRAM           ; Set the bit to indicate the destination is SRAM
.1a37cb	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a37cf	80 17		bra $1a37e8	                BRA dst_mode
.1a37d1	38		sec		dst_vram        SEC                         ; Convert to VRAM relative address
.1a37d2	e9 b0		sbc #$b0	                SBC #`VRAM
.1a37d4	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H      ; Set the VDMA destination address
.1a37d8	af 68 f0 1a	lda $1af068	                LDA @l DMA_DEST.ADDR+1
.1a37dc	8f 06 04 af	sta $af0406	                STA @l VDMA_DST_ADDY_M
.1a37e0	af 67 f0 1a	lda $1af067	                LDA @l DMA_DEST.ADDR
.1a37e4	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.1a37e8	af 66 f0 1a	lda $1af066	dst_mode        LDA @l DMA_DEST.MODE
.1a37ec	d0 3e		bne $1a382c	                BNE dst_2d                  ; If 2D, set up the 2D destination parameters
.1a37ee	af 58 f0 1a	lda $1af058	dst_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.1a37f2	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Is the destination SRAM?
.1a37f4	f0 1b		beq $1a3811	                BEQ dst_1d_vram
.1a37f6	af 6a f0 1a	lda $1af06a	dst_1d_sram     LDA @l DMA_DEST.SIZE
.1a37fa	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.1a37fe	af 6b f0 1a	lda $1af06b	                LDA @l DMA_DEST.SIZE+1
.1a3802	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_L+1
.1a3806	af 6c f0 1a	lda $1af06c	                LDA @l DMA_DEST.SIZE+2
.1a380a	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.1a380e	82 8b 00	brl $1a389c	                BRL start_xfer
.1a3811	af 6a f0 1a	lda $1af06a	dst_1d_vram     LDA @l DMA_DEST.SIZE
.1a3815	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.1a3819	af 6b f0 1a	lda $1af06b	                LDA @l DMA_DEST.SIZE+1
.1a381d	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_L+1
.1a3821	af 6c f0 1a	lda $1af06c	                LDA @l DMA_DEST.SIZE+2
.1a3825	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.1a3829	82 70 00	brl $1a389c	                BRL start_xfer
.1a382c	af 58 f0 1a	lda $1af058	dst_2d          LDA @l DMA_BLOCKS
.1a3830	09 02		ora #$02	                ORA #DMA_DST_2D             ; Set the bit to make the source a 2D transfer
.1a3832	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a3836	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Are we writing to the SRAM?
.1a3838	f0 32		beq $1a386c	                BEQ dst_2d_vram             ; No: set the 2D parameters for VRAM
.1a383a	af 6d f0 1a	lda $1af06d	dst_2d_sram     LDA @l DMA_DEST.WIDTH       ; Set the SRAM width
.1a383e	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.1a3842	af 6e f0 1a	lda $1af06e	                LDA @L DMA_DEST.WIDTH+1
.1a3846	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.1a384a	af 6f f0 1a	lda $1af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the SRAM height
.1a384e	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.1a3852	af 70 f0 1a	lda $1af070	                LDA @L DMA_DEST.HEIGHT+1
.1a3856	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.1a385a	af 71 f0 1a	lda $1af071	                LDA @l DMA_DEST.STRIDE      ; Set the SRAM stride
.1a385e	8f 2e 04 af	sta $af042e	                STA @l SDMA_DST_STRIDE_L
.1a3862	af 72 f0 1a	lda $1af072	                LDA @L DMA_DEST.STRIDE+1
.1a3866	8f 2f 04 af	sta $af042f	                STA @l SDMA_DST_STRIDE_L+1
.1a386a	80 30		bra $1a389c	                BRA start_xfer
.1a386c	af 6d f0 1a	lda $1af06d	dst_2d_vram     LDA @l DMA_DEST.WIDTH       ; Set the VRAM width
.1a3870	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.1a3874	af 6e f0 1a	lda $1af06e	                LDA @L DMA_DEST.WIDTH+1
.1a3878	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.1a387c	af 6f f0 1a	lda $1af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the VRAM height
.1a3880	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.1a3884	af 70 f0 1a	lda $1af070	                LDA @L DMA_DEST.HEIGHT+1
.1a3888	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.1a388c	af 71 f0 1a	lda $1af071	                LDA @l DMA_DEST.STRIDE      ; Set the VRAM stride
.1a3890	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L
.1a3894	af 72 f0 1a	lda $1af072	                LDA @L DMA_DEST.STRIDE+1
.1a3898	8f 0f 04 af	sta $af040f	                STA @l VDMA_DST_STRIDE_L+1
.1a389c	af 58 f0 1a	lda $1af058	start_xfer      LDA @l DMA_BLOCKS
.1a38a0	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.1a38a2	f0 43		beq $1a38e7	                BEQ start_vdma_only
.1a38a4	c9 10		cmp #$10	                CMP #DMA_SRC_SRAM
.1a38a6	f0 76		beq $1a391e	                BEQ start_s2v
.1a38a8	c9 20		cmp #$20	                CMP #DMA_DST_SRAM
.1a38aa	d0 03		bne $1a38af	                BNE start_sdma_only
.1a38ac	82 8a 00	brl $1a3939	                BRL start_v2s
.1a38af					start_sdma_only
.1a38af	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.1a38b3	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.1a38b5	f0 23		beq $1a38da	                BEQ sdma_1d_only            ; Source and Destination 1D...
.1a38b7	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.1a38b9	f0 23		beq $1a38de	                BEQ sdma_2d_only            ; Source and Destination 2D
.1a38bb	08		php		            PHP
.1a38bc	c2 20		rep #$20	            REP #$20
.1a38be	48		pha		            PHA
.1a38bf	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a38c2	5b		tcd		            TCD
.1a38c3	68		pla		            PLA
.1a38c4	28		plp		            PLP
.1a38c5	e2 20		sep #$20	            SEP #$20
.1a38c7	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a38c9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a38cd	c2 20		rep #$20	            REP #$20
.1a38cf	29 ff 00	and #$00ff	            AND #$00FF
.1a38d2	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a38d5	e2 20		sep #$20	            SEP #$20
.1a38d7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a38da	a9 01		lda #$01	sdma_1d_only    LDA #SDMA_CTRL0_Enable      ; Set the bits for 1D, SRAM->SRAM
.1a38dc	80 02		bra $1a38e0	                BRA sdma_set_ctrl
.1a38de	a9 03		lda #$03	sdma_2d_only    LDA #SDMA_CTRL0_Enable | SDMA_CTRL0_1D_2D
.1a38e0	8f 20 04 af	sta $af0420	sdma_set_ctrl   STA @l SDMA_CTRL_REG0
.1a38e4	82 7d 00	brl $1a3964	                BRL trig_sdma               ; And trigger the SDMA
.1a38e7					start_vdma_only
.1a38e7	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.1a38eb	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.1a38ed	f0 23		beq $1a3912	                BEQ vdma_1d_only            ; Source and Destination 1D...
.1a38ef	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.1a38f1	f0 23		beq $1a3916	                BEQ vdma_2d_only            ; Source and Destination 2D...
.1a38f3	08		php		            PHP
.1a38f4	c2 20		rep #$20	            REP #$20
.1a38f6	48		pha		            PHA
.1a38f7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a38fa	5b		tcd		            TCD
.1a38fb	68		pla		            PLA
.1a38fc	28		plp		            PLP
.1a38fd	e2 20		sep #$20	            SEP #$20
.1a38ff	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a3901	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3905	c2 20		rep #$20	            REP #$20
.1a3907	29 ff 00	and #$00ff	            AND #$00FF
.1a390a	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a390d	e2 20		sep #$20	            SEP #$20
.1a390f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3912	a9 01		lda #$01	vdma_1d_only    LDA #VDMA_CTRL_Enable       ; Set the bits for 1D, VRAM->VRAM
.1a3914	80 02		bra $1a3918	                BRA vdma_set_ctrl
.1a3916	a9 03		lda #$03	vdma_2d_only    LDA #VDMA_CTRL_Enable | VDMA_CTRL_1D_2D
.1a3918	8f 00 04 af	sta $af0400	vdma_set_ctrl   STA @l VDMA_CONTROL_REG
.1a391c	80 34		bra $1a3952	                BRA trig_vdma               ; And trigger the VDMA
.1a391e					start_s2v
.1a391e	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.1a3922	29 01		and #$01	                AND #DMA_SRC_2D
.1a3924	0a		asl a		                ASL A
.1a3925	09 11		ora #$11	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Src
.1a3927	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a392b	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.1a392f	29 02		and #$02	                AND #DMA_DST_2D
.1a3931	09 11		ora #$11	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Src
.1a3933	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a3937	80 19		bra $1a3952	                BRA trig_vdma               ; And trigger the VDMA
.1a3939					start_v2s
.1a3939	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.1a393d	29 02		and #$02	                AND #DMA_DST_2D
.1a393f	09 21		ora #$21	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Dst
.1a3941	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a3945	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.1a3949	29 01		and #$01	                AND #DMA_SRC_2D
.1a394b	0a		asl a		                ASL A
.1a394c	09 21		ora #$21	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Dst
.1a394e	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a3952					trig_vdma
.1a3952	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.1a3956	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF    ; Trigger the VDMA
.1a3958	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a395c	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Check if we need SDMA
.1a3960	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.1a3962	f0 0f		beq $1a3973	                BEQ wait_vdma               ; No: wait for VDMA to complete
.1a3964					trig_sdma
.1a3964	af 20 04 af	lda $af0420	                LDA @l SDMA_CTRL_REG0
.1a3968	09 80		ora #$80	                ORA #SDMA_CTRL0_Start_TRF   ; Trigger the SDMA
.1a396a	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a396e	ea		nop		                NOP                         ; When the transfer is started the CPU will be put on Hold (RDYn)...
.1a396f	ea		nop		                NOP                         ; Before it actually gets to stop it will execute a couple more instructions
.1a3970	ea		nop		                NOP                         ; From that point on, the CPU is halted (keep that in mind)
.1a3971	ea		nop		                NOP                         ; No IRQ will be processed either during that time
.1a3972	ea		nop		                NOP
.1a3973	af 01 04 af	lda $af0401	wait_vdma       LDA @l VDMA_STATUS_REG      ; Check the VDMA status
.1a3977	89 80		bit #$80	                BIT #VDMA_STAT_VDMA_IPS     ; If the transfer is still in process...
.1a3979	d0 f8		bne $1a3973	                BNE wait_vdma               ; Wait until it stops.
.1a397b	a9 00		lda #$00	                LDA #$00                    ; Clear the TRF bits
.1a397d	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a3981	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a3985	28		plp		                PLP
.1a3986	2b		pld		                PLD
.1a3987	60		rts		            RTS
.1a3988					S_MEMCOPY
.1a3988	0b		phd		                PHD
.1a3989	08		php		                PHP
.1a398a	e2 20		sep #$20	            SEP #$20
.1a398c	c2 10		rep #$10	            REP #$10
.1a398e	a9 00		lda #$00	                LDA #0
.1a3990	a2 00 00	ldx #$0000	                LDX #0
.1a3993	8f 59 f0 1a	sta $1af059	clr_loop        STA @l DMA_SRC
.1a3997	e8		inx		                INX
.1a3998	e0 1a 00	cpx #$001a	                CPX #SIZE(DMA_BLOCK) * 2
.1a399b	d0 f6		bne $1a3993	                BNE clr_loop
.1a399d	20 3e 22	jsr $1a223e	            JSR PEEK_TOK
.1a39a0	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.1a39a2	f0 23		beq $1a39c7	                BEQ src_linear                      ; Yes: go to process a linear source
.1a39a4	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.1a39a6	f0 5e		beq $1a3a06	                BEQ src_rect                        ; Yes: go to process a rectangular source
.1a39a8					syntax_err
.1a39a8	08		php		            PHP
.1a39a9	c2 20		rep #$20	            REP #$20
.1a39ab	48		pha		            PHA
.1a39ac	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a39af	5b		tcd		            TCD
.1a39b0	68		pla		            PLA
.1a39b1	28		plp		            PLP
.1a39b2	e2 20		sep #$20	            SEP #$20
.1a39b4	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a39b6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a39ba	c2 20		rep #$20	            REP #$20
.1a39bc	29 ff 00	and #$00ff	            AND #$00FF
.1a39bf	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a39c2	e2 20		sep #$20	            SEP #$20
.1a39c4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a39c7					src_linear
.1a39c7	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a39ca	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a39cd	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a39d0	c2 20		rep #$20	            REP #$20
.1a39d2	a5 23		lda $0823	            LDA ARGUMENT1
.1a39d4	8f 5a f0 1a	sta $1af05a	            STA DMA_SRC.ADDR
.1a39d8	e2 20		sep #$20	            SEP #$20
.1a39da	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a39dc	8f 5c f0 1a	sta $1af05c	            STA DMA_SRC.ADDR+2
.1a39e0	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a39e2	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a39e5	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a39e8	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a39eb	c2 20		rep #$20	            REP #$20
.1a39ed	a5 23		lda $0823	            LDA ARGUMENT1
.1a39ef	8f 5d f0 1a	sta $1af05d	            STA DMA_SRC.SIZE
.1a39f3	e2 20		sep #$20	            SEP #$20
.1a39f5	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a39f7	8f 5f f0 1a	sta $1af05f	            STA DMA_SRC.SIZE+2
.1a39fb	e2 20		sep #$20	            SEP #$20
.1a39fd	a9 00		lda #$00	            LDA #<DMA_LINEAR
.1a39ff	8f 59 f0 1a	sta $1af059	            STA DMA_SRC.MODE
.1a3a03	82 74 00	brl $1a3a7a	                BRL process_to
.1a3a06					src_rect
.1a3a06	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3a09	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3a0c	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3a0f	c2 20		rep #$20	            REP #$20
.1a3a11	a5 23		lda $0823	            LDA ARGUMENT1
.1a3a13	8f 5a f0 1a	sta $1af05a	            STA DMA_SRC.ADDR
.1a3a17	e2 20		sep #$20	            SEP #$20
.1a3a19	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3a1b	8f 5c f0 1a	sta $1af05c	            STA DMA_SRC.ADDR+2
.1a3a1f	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a3a21	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3a24	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3a27	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a3a2a	c2 20		rep #$20	            REP #$20
.1a3a2c	a5 23		lda $0823	            LDA ARGUMENT1
.1a3a2e	8f 60 f0 1a	sta $1af060	            STA DMA_SRC.WIDTH
.1a3a32	8d 00 01	sta $0100	            STA M0_OPERAND_A
.1a3a35	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a3a38	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3a3b	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3a3e	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a3a41	c2 20		rep #$20	            REP #$20
.1a3a43	a5 23		lda $0823	            LDA ARGUMENT1
.1a3a45	8f 62 f0 1a	sta $1af062	            STA DMA_SRC.HEIGHT
.1a3a49	8d 02 01	sta $0102	            STA M0_OPERAND_B
.1a3a4c	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a3a4f	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3a52	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3a55	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a3a58	c2 20		rep #$20	            REP #$20
.1a3a5a	a5 23		lda $0823	            LDA ARGUMENT1
.1a3a5c	8f 64 f0 1a	sta $1af064	            STA DMA_SRC.STRIDE
.1a3a60	c2 20		rep #$20	            REP #$20
.1a3a62	ad 04 01	lda $0104	            LDA M0_RESULT
.1a3a65	8f 5d f0 1a	sta $1af05d	            STA DMA_SRC.SIZE
.1a3a69	e2 20		sep #$20	            SEP #$20
.1a3a6b	ad 06 01	lda $0106	            LDA M0_RESULT+2
.1a3a6e	8f 5f f0 1a	sta $1af05f	            STA DMA_SRC.SIZE+2
.1a3a72	e2 20		sep #$20	            SEP #$20
.1a3a74	a9 01		lda #$01	            LDA #<DMA_RECT
.1a3a76	8f 59 f0 1a	sta $1af059	            STA DMA_SRC.MODE
.1a3a7a					process_to
.1a3a7a	e2 20		sep #$20	            SEP #$20
.1a3a7c	a9 9c		lda #$9c	                LDA #TOK_TO
.1a3a7e	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3a81	20 3e 22	jsr $1a223e	            JSR PEEK_TOK
.1a3a84	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.1a3a86	f0 23		beq $1a3aab	                BEQ dest_linear                     ; Yes: go to process a linear destination
.1a3a88	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.1a3a8a	f0 5e		beq $1a3aea	                BEQ dest_rect                       ; Yes: go to process a rectangular source
.1a3a8c					syntax_err2
.1a3a8c	08		php		            PHP
.1a3a8d	c2 20		rep #$20	            REP #$20
.1a3a8f	48		pha		            PHA
.1a3a90	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3a93	5b		tcd		            TCD
.1a3a94	68		pla		            PLA
.1a3a95	28		plp		            PLP
.1a3a96	e2 20		sep #$20	            SEP #$20
.1a3a98	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3a9a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3a9e	c2 20		rep #$20	            REP #$20
.1a3aa0	29 ff 00	and #$00ff	            AND #$00FF
.1a3aa3	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a3aa6	e2 20		sep #$20	            SEP #$20
.1a3aa8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3aab					dest_linear
.1a3aab	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3aae	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3ab1	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3ab4	c2 20		rep #$20	            REP #$20
.1a3ab6	a5 23		lda $0823	            LDA ARGUMENT1
.1a3ab8	8f 67 f0 1a	sta $1af067	            STA DMA_DEST.ADDR
.1a3abc	e2 20		sep #$20	            SEP #$20
.1a3abe	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3ac0	8f 69 f0 1a	sta $1af069	            STA DMA_DEST.ADDR+2
.1a3ac4	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a3ac6	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3ac9	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3acc	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3acf	c2 20		rep #$20	            REP #$20
.1a3ad1	a5 23		lda $0823	            LDA ARGUMENT1
.1a3ad3	8f 6a f0 1a	sta $1af06a	            STA DMA_DEST.SIZE
.1a3ad7	e2 20		sep #$20	            SEP #$20
.1a3ad9	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3adb	8f 6c f0 1a	sta $1af06c	            STA DMA_DEST.SIZE+2
.1a3adf	e2 20		sep #$20	            SEP #$20
.1a3ae1	a9 00		lda #$00	            LDA #<DMA_LINEAR
.1a3ae3	8f 66 f0 1a	sta $1af066	            STA DMA_DEST.MODE
.1a3ae7	82 74 00	brl $1a3b5e	                BRL verify
.1a3aea					dest_rect
.1a3aea	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3aed	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3af0	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3af3	c2 20		rep #$20	            REP #$20
.1a3af5	a5 23		lda $0823	            LDA ARGUMENT1
.1a3af7	8f 67 f0 1a	sta $1af067	            STA DMA_DEST.ADDR
.1a3afb	e2 20		sep #$20	            SEP #$20
.1a3afd	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3aff	8f 69 f0 1a	sta $1af069	            STA DMA_DEST.ADDR+2
.1a3b03	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a3b05	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3b08	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3b0b	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a3b0e	c2 20		rep #$20	            REP #$20
.1a3b10	a5 23		lda $0823	            LDA ARGUMENT1
.1a3b12	8f 6d f0 1a	sta $1af06d	            STA DMA_DEST.WIDTH
.1a3b16	8d 00 01	sta $0100	            STA M0_OPERAND_A
.1a3b19	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a3b1c	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3b1f	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3b22	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a3b25	c2 20		rep #$20	            REP #$20
.1a3b27	a5 23		lda $0823	            LDA ARGUMENT1
.1a3b29	8f 6f f0 1a	sta $1af06f	            STA DMA_DEST.HEIGHT
.1a3b2d	8d 02 01	sta $0102	            STA M0_OPERAND_B
.1a3b30	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a3b33	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3b36	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3b39	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a3b3c	c2 20		rep #$20	            REP #$20
.1a3b3e	a5 23		lda $0823	            LDA ARGUMENT1
.1a3b40	8f 71 f0 1a	sta $1af071	            STA DMA_DEST.STRIDE
.1a3b44	c2 20		rep #$20	            REP #$20
.1a3b46	ad 04 01	lda $0104	            LDA M0_RESULT
.1a3b49	8f 6a f0 1a	sta $1af06a	            STA DMA_DEST.SIZE
.1a3b4d	e2 20		sep #$20	            SEP #$20
.1a3b4f	ad 06 01	lda $0106	            LDA M0_RESULT+2
.1a3b52	8f 6c f0 1a	sta $1af06c	            STA DMA_DEST.SIZE+2
.1a3b56	e2 20		sep #$20	            SEP #$20
.1a3b58	a9 01		lda #$01	            LDA #<DMA_RECT
.1a3b5a	8f 66 f0 1a	sta $1af066	            STA DMA_DEST.MODE
.1a3b5e					verify
.1a3b5e	c2 20		rep #$20	            REP #$20
.1a3b60	af 5d f0 1a	lda $1af05d	                LDA @l DMA_SRC.SIZE
.1a3b64	cf 6a f0 1a	cmp $1af06a	                CMP @l DMA_DEST.SIZE
.1a3b68	d0 14		bne $1a3b7e	                BNE size_err
.1a3b6a	e2 20		sep #$20	            SEP #$20
.1a3b6c	af 5f f0 1a	lda $1af05f	                LDA @l DMA_SRC.SIZE+2
.1a3b70	cf 6c f0 1a	cmp $1af06c	                CMP @l DMA_DEST.SIZE+2
.1a3b74	d0 08		bne $1a3b7e	                BNE size_err
.1a3b76	c2 20		rep #$20	            REP #$20
.1a3b78	20 a6 36	jsr $1a36a6	            JSR DO_DMA
.1a3b7b	28		plp		                PLP
.1a3b7c	2b		pld		                PLD
.1a3b7d	60		rts		            RTS
.1a3b7e					size_err
.1a3b7e	08		php		            PHP
.1a3b7f	c2 20		rep #$20	            REP #$20
.1a3b81	48		pha		            PHA
.1a3b82	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3b85	5b		tcd		            TCD
.1a3b86	68		pla		            PLA
.1a3b87	28		plp		            PLP
.1a3b88	e2 20		sep #$20	            SEP #$20
.1a3b8a	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a3b8c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3b90	c2 20		rep #$20	            REP #$20
.1a3b92	29 ff 00	and #$00ff	            AND #$00FF
.1a3b95	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a3b98	e2 20		sep #$20	            SEP #$20
.1a3b9a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3b9d					S_LOCATE
.1a3b9d	08		php		                PHP
.1a3b9e	c2 30		rep #$30	            REP #$30
.1a3ba0	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3ba3	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a3ba6	a5 23		lda $0823	                LDA ARGUMENT1
.1a3ba8	48		pha		                PHA                         ; Save it for later
.1a3ba9	a9 2c 00	lda #$002c	                LDA #','                    ; Check for the comma separator
.1a3bac	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3baf	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3bb2	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a3bb5	a4 23		ldy $0823	                LDY ARGUMENT1               ; Set Y to the row
.1a3bb7	fa		plx		                PLX                         ; Set X to the column
.1a3bb8	20 20 00	jsr $1a0020	            JSR CURSORXY
.1a3bbb	28		plp		                PLP
.1a3bbc	60		rts		            RTS

;******  Return to file: src\statements.s

.1a3bbd					S_INPUT
.1a3bbd	08		php		                PHP
.1a3bbe					varloop
.1a3bbe	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a3bc1	e2 20		sep #$20	            SEP #$20
.1a3bc3	a7 00		lda [$0800]	                LDA [BIP]
.1a3bc5	d0 03		bne $1a3bca	                BNE check_colon
.1a3bc7	4c 65 3c	jmp $1a3c65	                JMP done            ; If EOL, we're done
.1a3bca	c9 3a		cmp #$3a	check_colon     CMP #':'
.1a3bcc	d0 03		bne $1a3bd1	                BNE check_string
.1a3bce	4c 65 3c	jmp $1a3c65	                JMP done            ; If colon, we're done
.1a3bd1	c9 22		cmp #$22	check_string    CMP #CHAR_DQUOTE    ; Is it the start of a string?
.1a3bd3	d0 0b		bne $1a3be0	                BNE check_var       ; No: then it should be a variable name
.1a3bd5	20 d8 1b	jsr $1a1bd8	            JSR EVALSTRING
.1a3bd8	20 73 45	jsr $1a4573	            JSR PR_STRING
.1a3bdb	a9 3b		lda #$3b	                LDA #';'            ; Look for a semicolon
.1a3bdd	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3be0					check_var
.1a3be0	20 a7 04	jsr $1a04a7	            JSR ISALPHA
.1a3be3	90 44		bcc $1a3c29	                BCC syntax_err      ; No: it's a syntax error
.1a3be5	20 38 53	jsr $1a5338	            JSR VAR_FINDNAME
.1a3be8	90 3f		bcc $1a3c29	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3bea	a9 3f		lda #$3f	                LDA #"?"            ; Print a "? " to follow
.1a3bec	20 18 00	jsr $1a0018	            JSR PRINTC
.1a3bef	a9 20		lda #$20	                LDA #CHAR_SP
.1a3bf1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a3bf4	20 10 00	jsr $1a0010	            JSR INPUTLINE
.1a3bf7	e2 20		sep #$20	            SEP #$20
.1a3bf9	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Check the type of the variable
.1a3bfb	c9 02		cmp #$02	                CMP #TYPE_STRING    ; If it's a string...
.1a3bfd	f0 49		beq $1a3c48	                BEQ in_string       ; ... go to copy the string data
.1a3bff	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; If it's an integer...
.1a3c01	d0 03		bne $1a3c06	                BNE chk_float
.1a3c03	82 84 00	brl $1a3c8a	                BRL in_integer      ; ... go to parse the integer
.1a3c06	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT     ; If it's a float...
.1a3c08	f0 5d		beq $1a3c67	                BEQ in_float        ; ... go to parse the float
.1a3c0a	08		php		            PHP
.1a3c0b	c2 20		rep #$20	            REP #$20
.1a3c0d	48		pha		            PHA
.1a3c0e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3c11	5b		tcd		            TCD
.1a3c12	68		pla		            PLA
.1a3c13	28		plp		            PLP
.1a3c14	e2 20		sep #$20	            SEP #$20
.1a3c16	a9 04		lda #$04	            LDA #ERR_TYPE
.1a3c18	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3c1c	c2 20		rep #$20	            REP #$20
.1a3c1e	29 ff 00	and #$00ff	            AND #$00FF
.1a3c21	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a3c24	e2 20		sep #$20	            SEP #$20
.1a3c26	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3c29					syntax_err
.1a3c29	08		php		            PHP
.1a3c2a	c2 20		rep #$20	            REP #$20
.1a3c2c	48		pha		            PHA
.1a3c2d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3c30	5b		tcd		            TCD
.1a3c31	68		pla		            PLA
.1a3c32	28		plp		            PLP
.1a3c33	e2 20		sep #$20	            SEP #$20
.1a3c35	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3c37	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3c3b	c2 20		rep #$20	            REP #$20
.1a3c3d	29 ff 00	and #$00ff	            AND #$00FF
.1a3c40	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a3c43	e2 20		sep #$20	            SEP #$20
.1a3c45	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3c48					in_string
.1a3c48	c2 20		rep #$20	            REP #$20
.1a3c4a	a9 00 4c	lda #$4c00	                LDA #<>IOBUF
.1a3c4d	85 23		sta $0823	                STA ARGUMENT1
.1a3c4f	a9 00 00	lda #$0000	                LDA #`IOBUF
.1a3c52	85 25		sta $0825	                STA ARGUMENT1+2
.1a3c54	e2 20		sep #$20	            SEP #$20
.1a3c56	a9 02		lda #$02	                LDA #TYPE_STRING
.1a3c58	85 27		sta $0827	                STA ARGTYPE1
.1a3c5a					save_input
.1a3c5a	c2 20		rep #$20	            REP #$20
.1a3c5c	20 9b 52	jsr $1a529b	            JSR VAR_SET
.1a3c5f	a9 0d 00	lda #$000d	                LDA #CHAR_CR        ; Print a newline
.1a3c62	20 18 00	jsr $1a0018	            JSR PRINTC
.1a3c65	28		plp		done            PLP
.1a3c66	60		rts		            RTS
.1a3c67					in_float
.1a3c67	c2 20		rep #$20	            REP #$20
.1a3c69	a5 00		lda $0800	                LDA BIP             ; Save the BIP for later use
.1a3c6b	85 40		sta $0840	                STA SAVEBIP
.1a3c6d	a5 02		lda $0802	                LDA BIP+2
.1a3c6f	85 42		sta $0842	                STA SAVEBIP+2
.1a3c71	a9 00 4c	lda #$4c00	                LDA #<>IOBUF        ; Point to the line that was just input
.1a3c74	85 00		sta $0800	                STA BIP
.1a3c76	a9 00 00	lda #$0000	                LDA #`IOBUF
.1a3c79	85 02		sta $0802	                STA BIP+2
.1a3c7b	20 5a 59	jsr $1a595a	            JSR PARSENUM
.1a3c7e	c2 20		rep #$20	            REP #$20
.1a3c80	a5 40		lda $0840	                LDA SAVEBIP         ; Restore the BIP
.1a3c82	85 00		sta $0800	                STA BIP
.1a3c84	a5 42		lda $0842	                LDA SAVEBIP+2
.1a3c86	85 02		sta $0802	                STA BIP+2
.1a3c88	80 d0		bra $1a3c5a	                BRA save_input
.1a3c8a					in_integer
.1a3c8a	c2 20		rep #$20	            REP #$20
.1a3c8c	a5 00		lda $0800	                LDA BIP             ; Save the BIP for later use
.1a3c8e	85 40		sta $0840	                STA SAVEBIP
.1a3c90	a5 02		lda $0802	                LDA BIP+2
.1a3c92	85 42		sta $0842	                STA SAVEBIP+2
.1a3c94	a9 00 4c	lda #$4c00	                LDA #<>IOBUF        ; Point to the line that was just input
.1a3c97	85 00		sta $0800	                STA BIP
.1a3c99	a9 00 00	lda #$0000	                LDA #`IOBUF
.1a3c9c	85 02		sta $0802	                STA BIP+2
.1a3c9e	20 9d 08	jsr $1a089d	            JSR PARSEINT
.1a3ca1	c2 20		rep #$20	            REP #$20
.1a3ca3	a5 40		lda $0840	                LDA SAVEBIP         ; Restore the BIP
.1a3ca5	85 00		sta $0800	                STA BIP
.1a3ca7	a5 42		lda $0842	                LDA SAVEBIP+2
.1a3ca9	85 02		sta $0802	                STA BIP+2
.1a3cab	80 ad		bra $1a3c5a	                BRA save_input
.1a3cad					S_GET
.1a3cad	08		php		                PHP
.1a3cae					varloop
.1a3cae	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a3cb1	e2 20		sep #$20	            SEP #$20
.1a3cb3	a7 00		lda [$0800]	                LDA [BIP]
.1a3cb5	f0 47		beq $1a3cfe	                BEQ done            ; If EOL, we're done
.1a3cb7	c9 3a		cmp #$3a	                CMP #':'
.1a3cb9	f0 43		beq $1a3cfe	                BEQ done            ; If colon, we're done
.1a3cbb	20 a7 04	jsr $1a04a7	            JSR ISALPHA
.1a3cbe	90 40		bcc $1a3d00	                BCC syntax_err      ; No: it's a syntax error
.1a3cc0	20 38 53	jsr $1a5338	            JSR VAR_FINDNAME
.1a3cc3	90 3b		bcc $1a3d00	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3cc5	20 c1 14	jsr $1a14c1	            JSR TEMPSTRING
.1a3cc8	20 14 00	jsr $1a0014	            JSR GETKEY
.1a3ccb	e2 20		sep #$20	            SEP #$20
.1a3ccd	a0 00 00	ldy #$0000	                LDY #0
.1a3cd0	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a3cd2	a9 00		lda #$00	                LDA #0
.1a3cd4	c8		iny		                INY
.1a3cd5	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a3cd7	c2 20		rep #$20	            REP #$20
.1a3cd9	a5 16		lda $0816	                LDA STRPTR
.1a3cdb	85 23		sta $0823	                STA ARGUMENT1
.1a3cdd	a5 18		lda $0818	                LDA STRPTR+2
.1a3cdf	85 25		sta $0825	                STA ARGUMENT1+2
.1a3ce1	e2 20		sep #$20	            SEP #$20
.1a3ce3	a9 02		lda #$02	                LDA #TYPE_STRING
.1a3ce5	85 27		sta $0827	                STA ARGTYPE1
.1a3ce7	20 9b 52	jsr $1a529b	            JSR VAR_SET
.1a3cea	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a3ced	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.1a3cef	f0 0d		beq $1a3cfe	                BEQ done            ; EOL? We're done
.1a3cf1	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.1a3cf3	f0 09		beq $1a3cfe	                BEQ done
.1a3cf5	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.1a3cf7	d0 07		bne $1a3d00	                BNE syntax_err      ; Nope: syntax error
.1a3cf9	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a3cfc	80 b0		bra $1a3cae	                BRA varloop
.1a3cfe	28		plp		done            PLP
.1a3cff	60		rts		            RTS
.1a3d00					syntax_err
.1a3d00	08		php		            PHP
.1a3d01	c2 20		rep #$20	            REP #$20
.1a3d03	48		pha		            PHA
.1a3d04	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3d07	5b		tcd		            TCD
.1a3d08	68		pla		            PLA
.1a3d09	28		plp		            PLP
.1a3d0a	e2 20		sep #$20	            SEP #$20
.1a3d0c	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3d0e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3d12	c2 20		rep #$20	            REP #$20
.1a3d14	29 ff 00	and #$00ff	            AND #$00FF
.1a3d17	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a3d1a	e2 20		sep #$20	            SEP #$20
.1a3d1c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3d1f					S_CALL
.1a3d1f	08		php		                PHP
.1a3d20	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3d23	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3d26	e2 20		sep #$20	            SEP #$20
.1a3d28	a9 5c		lda #$5c	                LDA #$5C            ; Set the opcode for JML
.1a3d2a	85 a2		sta $08a2	                STA MJUMPINST
.1a3d2c	c2 20		rep #$20	            REP #$20
.1a3d2e	a5 23		lda $0823	                LDA ARGUMENT1
.1a3d30	85 a3		sta $08a3	                STA MJUMPADDR
.1a3d32	e2 20		sep #$20	            SEP #$20
.1a3d34	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3d36	85 a5		sta $08a5	                STA MJUMPADDR+2
.1a3d38	e2 20		sep #$20	            SEP #$20
.1a3d3a	a9 2c		lda #$2c	                LDA #','
.1a3d3c	85 37		sta $0837	                STA TARGETTOK
.1a3d3e	20 1f 22	jsr $1a221f	            JSR OPT_TOK
.1a3d41	90 41		bcc $1a3d84	                BCC launch          ; Not present... go ahead and launch
.1a3d43	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a3d46	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3d49	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a3d4c	c2 20		rep #$20	            REP #$20
.1a3d4e	a5 23		lda $0823	                LDA ARGUMENT1
.1a3d50	85 55		sta $0855	                STA MARG1           ; Save it to MARG1
.1a3d52	e2 20		sep #$20	            SEP #$20
.1a3d54	a9 2c		lda #$2c	                LDA #','
.1a3d56	85 37		sta $0837	                STA TARGETTOK
.1a3d58	20 1f 22	jsr $1a221f	            JSR OPT_TOK
.1a3d5b	90 27		bcc $1a3d84	                BCC launch          ; Not present... go ahead and launch
.1a3d5d	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a3d60	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3d63	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a3d66	c2 20		rep #$20	            REP #$20
.1a3d68	a5 23		lda $0823	                LDA ARGUMENT1
.1a3d6a	85 59		sta $0859	                STA MARG2           ; Save it to MARG2
.1a3d6c	e2 20		sep #$20	            SEP #$20
.1a3d6e	a9 2c		lda #$2c	                LDA #','
.1a3d70	85 37		sta $0837	                STA TARGETTOK
.1a3d72	20 1f 22	jsr $1a221f	            JSR OPT_TOK
.1a3d75	90 0d		bcc $1a3d84	                BCC launch          ; Not present... go ahead and launch
.1a3d77	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a3d7a	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3d7d	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a3d80	c2 20		rep #$20	            REP #$20
.1a3d82	a4 23		ldy $0823	                LDY ARGUMENT1
.1a3d84	a6 59		ldx $0859	launch          LDX MARG2
.1a3d86	a5 55		lda $0855	                LDA MARG1
.1a3d88	0b		phd		                PHD
.1a3d89	8b		phb		                PHB
.1a3d8a	08		php		                PHP
.1a3d8b	22 a2 08 00	jsl $0008a2	                JSL MJUMPINST       ; Call the subroutine indicated
.1a3d8f	28		plp		                PLP
.1a3d90	ab		plb		                PLB
.1a3d91	2b		pld		                PLD
.1a3d92	20 22 21	jsr $1a2122	            JSR SKIPSTMT
.1a3d95	28		plp		                PLP
.1a3d96	60		rts		            RTS
.1a3d97					type_err
.1a3d97	08		php		            PHP
.1a3d98	c2 20		rep #$20	            REP #$20
.1a3d9a	48		pha		            PHA
.1a3d9b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3d9e	5b		tcd		            TCD
.1a3d9f	68		pla		            PLA
.1a3da0	28		plp		            PLP
.1a3da1	e2 20		sep #$20	            SEP #$20
.1a3da3	a9 04		lda #$04	            LDA #ERR_TYPE
.1a3da5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3da9	c2 20		rep #$20	            REP #$20
.1a3dab	29 ff 00	and #$00ff	            AND #$00FF
.1a3dae	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a3db1	e2 20		sep #$20	            SEP #$20
.1a3db3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3db6					S_DIM
.1a3db6	08		php		                PHP
.1a3db7	e2 20		sep #$20	            SEP #$20
.1a3db9	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a3dbc	20 38 53	jsr $1a5338	            JSR VAR_FINDNAME
.1a3dbf	90 64		bcc $1a3e25	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3dc1	a9 8f		lda #$8f	                LDA #TOK_LPAREN     ; Verify we have a left parenthesis
.1a3dc3	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a3dc6	a9 01		lda #$01	                LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.1a3dc8	20 e8 19	jsr $1a19e8	            JSR PHOPERATOR
.1a3dcb	a2 01 00	ldx #$0001	                LDX #1
.1a3dce	a9 00		lda #$00	                LDA #0
.1a3dd0	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF     ; Set the dimension count to 0
.1a3dd4					dim_loop
.1a3dd4	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3dd7	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3dda	c2 20		rep #$20	            REP #$20
.1a3ddc	a5 23		lda $0823	                LDA ARGUMENT1
.1a3dde	9f 00 4d 00	sta $004d00,x	                STA @lARRIDXBUF,X   ; And store it in the buffer
.1a3de2	e2 20		sep #$20	            SEP #$20
.1a3de4	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF     ; Add to the dimension count
.1a3de8	1a		inc a		                INC A
.1a3de9	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF
.1a3ded	30 55		bmi $1a3e44	                BMI overflow        ; If > 127 throw an error
.1a3def	e8		inx		                INX
.1a3df0	e8		inx		                INX
.1a3df1	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a3df4	a7 00		lda [$0800]	                LDA [BIP]           ; Check the character
.1a3df6	c9 2c		cmp #$2c	                CMP #','            ; Is it a comma?
.1a3df8	f0 25		beq $1a3e1f	                BEQ skip_comma      ; Yes: get the next dimension
.1a3dfa	c9 90		cmp #$90	                CMP #TOK_RPAREN     ; No: is it a ")"?
.1a3dfc	d0 27		bne $1a3e25	                BNE syntax_err      ; No: throw a syntax error
.1a3dfe	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a3e01	20 b6 65	jsr $1a65b6	            JSR ARR_ALLOC
.1a3e04	c2 20		rep #$20	            REP #$20
.1a3e06	a5 c0		lda $08c0	                LDA CURRBLOCK       ; Set up the pointer to the array
.1a3e08	85 23		sta $0823	                STA ARGUMENT1
.1a3e0a	e2 20		sep #$20	            SEP #$20
.1a3e0c	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a3e0e	85 25		sta $0825	                STA ARGUMENT1+2
.1a3e10	64 26		stz $0826	                STZ ARGUMENT1+3
.1a3e12	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Get the type of the values
.1a3e14	09 80		ora #$80	                ORA #$80            ; Make sure we change the type to array
.1a3e16	85 ea		sta $08ea	                STA TOFINDTYPE      ; And save it back for searching
.1a3e18	85 27		sta $0827	                STA ARGTYPE1        ; And for the value to set
.1a3e1a	20 9b 52	jsr $1a529b	            JSR VAR_SET
.1a3e1d	28		plp		                PLP
.1a3e1e	60		rts		            RTS
.1a3e1f					skip_comma
.1a3e1f	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a3e22	4c d4 3d	jmp $1a3dd4	                JMP dim_loop
.1a3e25					syntax_err
.1a3e25	08		php		            PHP
.1a3e26	c2 20		rep #$20	            REP #$20
.1a3e28	48		pha		            PHA
.1a3e29	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3e2c	5b		tcd		            TCD
.1a3e2d	68		pla		            PLA
.1a3e2e	28		plp		            PLP
.1a3e2f	e2 20		sep #$20	            SEP #$20
.1a3e31	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3e33	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3e37	c2 20		rep #$20	            REP #$20
.1a3e39	29 ff 00	and #$00ff	            AND #$00FF
.1a3e3c	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a3e3f	e2 20		sep #$20	            SEP #$20
.1a3e41	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3e44					overflow
.1a3e44	08		php		            PHP
.1a3e45	c2 20		rep #$20	            REP #$20
.1a3e47	48		pha		            PHA
.1a3e48	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3e4b	5b		tcd		            TCD
.1a3e4c	68		pla		            PLA
.1a3e4d	28		plp		            PLP
.1a3e4e	e2 20		sep #$20	            SEP #$20
.1a3e50	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a3e52	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3e56	c2 20		rep #$20	            REP #$20
.1a3e58	29 ff 00	and #$00ff	            AND #$00FF
.1a3e5b	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a3e5e	e2 20		sep #$20	            SEP #$20
.1a3e60	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3e63					S_READ
.1a3e63	08		php		                PHP
.1a3e64					varloop
.1a3e64	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a3e67	e2 20		sep #$20	            SEP #$20
.1a3e69	a7 00		lda [$0800]	                LDA [BIP]
.1a3e6b	f0 28		beq $1a3e95	                BEQ done            ; If EOL, we're done
.1a3e6d	c9 3a		cmp #$3a	                CMP #':'
.1a3e6f	f0 24		beq $1a3e95	                BEQ done            ; If colon, we're done
.1a3e71	20 a7 04	jsr $1a04a7	            JSR ISALPHA
.1a3e74	90 21		bcc $1a3e97	                BCC syntax_err      ; No: it's a syntax error
.1a3e76	20 38 53	jsr $1a5338	            JSR VAR_FINDNAME
.1a3e79	90 1c		bcc $1a3e97	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3e7b	20 b6 3e	jsr $1a3eb6	            JSR NEXTDATA
.1a3e7e	20 9b 52	jsr $1a529b	            JSR VAR_SET
.1a3e81	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a3e84	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.1a3e86	f0 0d		beq $1a3e95	                BEQ done            ; EOL? We're done
.1a3e88	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.1a3e8a	f0 09		beq $1a3e95	                BEQ done
.1a3e8c	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.1a3e8e	d0 07		bne $1a3e97	                BNE syntax_err      ; Nope: syntax error
.1a3e90	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a3e93	80 cf		bra $1a3e64	                BRA varloop
.1a3e95	28		plp		done            PLP
.1a3e96	60		rts		            RTS
.1a3e97					syntax_err
.1a3e97	08		php		            PHP
.1a3e98	c2 20		rep #$20	            REP #$20
.1a3e9a	48		pha		            PHA
.1a3e9b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3e9e	5b		tcd		            TCD
.1a3e9f	68		pla		            PLA
.1a3ea0	28		plp		            PLP
.1a3ea1	e2 20		sep #$20	            SEP #$20
.1a3ea3	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3ea5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3ea9	c2 20		rep #$20	            REP #$20
.1a3eab	29 ff 00	and #$00ff	            AND #$00FF
.1a3eae	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a3eb1	e2 20		sep #$20	            SEP #$20
.1a3eb3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3eb6					NEXTDATA
.1a3eb6	08		php		                PHP
.1a3eb7	a5 02		lda $0802	                LDA BIP+2           ; Save BIP
.1a3eb9	85 42		sta $0842	                STA SAVEBIP+2
.1a3ebb	a5 00		lda $0800	                LDA BIP
.1a3ebd	85 40		sta $0840	                STA SAVEBIP
.1a3ebf	a5 1c		lda $081c	                LDA CURLINE+2       ; Save CURLINE
.1a3ec1	85 46		sta $0846	                STA SAVELINE+2
.1a3ec3	a5 1a		lda $081a	                LDA CURLINE
.1a3ec5	85 44		sta $0844	                STA SAVELINE
.1a3ec7	c2 20		rep #$20	            REP #$20
.1a3ec9	a5 3a		lda $083a	                LDA DATABIP+2
.1a3ecb	d0 04		bne $1a3ed1	                BNE data_set
.1a3ecd	a5 38		lda $0838	                LDA DATABIP
.1a3ecf	f0 4e		beq $1a3f1f	                BEQ scan_start      ; No: scan for a DATA statement
.1a3ed1	a5 38		lda $0838	data_set        LDA DATABIP         ; Move BIP to the DATA statement
.1a3ed3	85 00		sta $0800	                STA BIP
.1a3ed5	a5 3a		lda $083a	                LDA DATABIP+2
.1a3ed7	85 02		sta $0802	                STA BIP+2
.1a3ed9	a5 3c		lda $083c	                LDA DATALINE        ; Set CURLINE from DATALINE
.1a3edb	85 1a		sta $081a	                STA CURLINE
.1a3edd	a5 3e		lda $083e	                LDA DATALINE+2
.1a3edf	85 1c		sta $081c	                STA CURLINE+2
.1a3ee1	e2 20		sep #$20	            SEP #$20
.1a3ee3	a7 00		lda [$0800]	                LDA [BIP]           ; Check character at BIP
.1a3ee5	f0 53		beq $1a3f3a	                BEQ scan_DATA       ; EOL? scan for a DATA statement
.1a3ee7	c9 3a		cmp #$3a	                CMP #':'            ; Colon?
.1a3ee9	f0 4f		beq $1a3f3a	                BEQ scan_DATA       ; ... scan for a DATA statement
.1a3eeb	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.1a3eed	d0 03		bne $1a3ef2	                BNE skip_parse      ; No: skip leading WS and try to parse
.1a3eef	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a3ef2					skip_parse
.1a3ef2	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a3ef5	a7 00		lda [$0800]	                LDA [BIP]
.1a3ef7	c9 22		cmp #$22	                CMP #CHAR_DQUOTE    ; Is it a quote?
.1a3ef9	f0 4e		beq $1a3f49	                BEQ read_string     ; Yes: process the string
.1a3efb	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a3efe	b0 4e		bcs $1a3f4e	                BCS read_number     ; Yes: process the number
.1a3f00					syntax_err
.1a3f00	08		php		            PHP
.1a3f01	c2 20		rep #$20	            REP #$20
.1a3f03	48		pha		            PHA
.1a3f04	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3f07	5b		tcd		            TCD
.1a3f08	68		pla		            PLA
.1a3f09	28		plp		            PLP
.1a3f0a	e2 20		sep #$20	            SEP #$20
.1a3f0c	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3f0e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3f12	c2 20		rep #$20	            REP #$20
.1a3f14	29 ff 00	and #$00ff	            AND #$00FF
.1a3f17	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a3f1a	e2 20		sep #$20	            SEP #$20
.1a3f1c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3f1f					scan_start
.1a3f1f	c2 20		rep #$20	            REP #$20
.1a3f21	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT    ; Point CURLINE to the first line
.1a3f24	85 1a		sta $081a	                STA CURLINE
.1a3f26	a9 16 00	lda #$0016	                LDA #`BASIC_BOT
.1a3f29	85 1c		sta $081c	                STA CURLINE+2
.1a3f2b	18		clc		                CLC
.1a3f2c	a5 1a		lda $081a	                LDA CURLINE         ; Point BIP to the first possible token
.1a3f2e	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.1a3f31	85 00		sta $0800	                STA BIP
.1a3f33	a5 1c		lda $081c	                LDA CURLINE+2
.1a3f35	69 00 00	adc #$0000	                ADC #0
.1a3f38	85 02		sta $0802	                STA BIP+2
.1a3f3a					scan_data
.1a3f3a	e2 20		sep #$20	            SEP #$20
.1a3f3c	a9 80		lda #$80	                LDA #$80            ; We don't want to process nesting
.1a3f3e	85 35		sta $0835	                STA SKIPNEST
.1a3f40	a9 ab		lda #$ab	                LDA #TOK_DATA       ; We're looking for a DATA token
.1a3f42	85 37		sta $0837	                STA TARGETTOK
.1a3f44	20 34 21	jsr $1a2134	            JSR SKIPTOTOK
.1a3f47	80 a9		bra $1a3ef2	                BRA skip_parse
.1a3f49					read_string
.1a3f49	20 d8 1b	jsr $1a1bd8	            JSR EVALSTRING
.1a3f4c	80 03		bra $1a3f51	                BRA done
.1a3f4e					read_number
.1a3f4e	20 ca 1a	jsr $1a1aca	            JSR EVALNUMBER
.1a3f51					done
.1a3f51	c2 20		rep #$20	            REP #$20
.1a3f53	a5 00		lda $0800	                LDA BIP             ; Save BIP to DATABIP
.1a3f55	85 38		sta $0838	                STA DATABIP
.1a3f57	a5 02		lda $0802	                LDA BIP+2
.1a3f59	85 3a		sta $083a	                STA DATABIP+2
.1a3f5b	a5 1a		lda $081a	                LDA CURLINE         ; Save CURLINE to DATALINE
.1a3f5d	85 3c		sta $083c	                STA DATALINE
.1a3f5f	a5 1c		lda $081c	                LDA CURLINE+2
.1a3f61	85 3e		sta $083e	                STA DATALINE+2
.1a3f63	a5 44		lda $0844	                LDA SAVELINE        ; Restore CURLINE
.1a3f65	85 1a		sta $081a	                STA CURLINE
.1a3f67	a5 46		lda $0846	                LDA SAVELINE+2
.1a3f69	85 1c		sta $081c	                STA CURLINE+2
.1a3f6b	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.1a3f6d	85 00		sta $0800	                STA BIP
.1a3f6f	a5 42		lda $0842	                LDA SAVEBIP+2
.1a3f71	85 02		sta $0802	                STA BIP+2
.1a3f73	28		plp		                PLP
.1a3f74	60		rts		            RTS
.1a3f75					S_DATA
.1a3f75	20 22 21	jsr $1a2122	            JSR SKIPSTMT
.1a3f78	60		rts		            RTS
.1a3f79					S_RESTORE
.1a3f79	64 38		stz $0838	                STZ DATABIP         ; Just set DATABIP to 0
.1a3f7b	64 3a		stz $083a	                STZ DATABIP+2       ; The next READ will move it to the first DATA
.1a3f7d	64 3c		stz $083c	                STZ DATALINE        ; Set DATALINE to 0
.1a3f7f	64 3e		stz $083e	                STZ DATALINE+2
.1a3f81	60		rts		            RTS
.1a3f82					S_CLS
.1a3f82	20 24 00	jsr $1a0024	            JSR CLSCREEN
.1a3f85	60		rts		            RTS
.1a3f86					S_POKEL
.1a3f86	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3f89	c2 20		rep #$20	            REP #$20
.1a3f8b	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.1a3f8d	48		pha		                PHA
.1a3f8e	a5 23		lda $0823	                LDA ARGUMENT1
.1a3f90	48		pha		                PHA
.1a3f91	e2 20		sep #$20	            SEP #$20
.1a3f93	a7 00		lda [$0800]	                LDA [BIP]
.1a3f95	c9 2c		cmp #$2c	                CMP #','
.1a3f97	d0 22		bne $1a3fbb	                BNE syntax_err
.1a3f99	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a3f9c	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3f9f	c2 20		rep #$20	            REP #$20
.1a3fa1	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a3fa3	d0 35		bne $1a3fda	                BNE range_err
.1a3fa5	68		pla		                PLA                 ; Pull the target address from the stack
.1a3fa6	85 08		sta $0808	                STA INDEX           ; and into INDEX
.1a3fa8	68		pla		                PLA
.1a3fa9	85 0a		sta $080a	                STA INDEX+2
.1a3fab	c2 20		rep #$20	            REP #$20
.1a3fad	a5 23		lda $0823	                LDA ARGUMENT1
.1a3faf	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.1a3fb1	e2 20		sep #$20	            SEP #$20
.1a3fb3	a0 02 00	ldy #$0002	                LDY #2
.1a3fb6	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3fb8	97 08		sta [$0808],y	                STA [INDEX],Y
.1a3fba	60		rts		            RTS
.1a3fbb					syntax_err
.1a3fbb	08		php		            PHP
.1a3fbc	c2 20		rep #$20	            REP #$20
.1a3fbe	48		pha		            PHA
.1a3fbf	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3fc2	5b		tcd		            TCD
.1a3fc3	68		pla		            PLA
.1a3fc4	28		plp		            PLP
.1a3fc5	e2 20		sep #$20	            SEP #$20
.1a3fc7	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3fc9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3fcd	c2 20		rep #$20	            REP #$20
.1a3fcf	29 ff 00	and #$00ff	            AND #$00FF
.1a3fd2	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a3fd5	e2 20		sep #$20	            SEP #$20
.1a3fd7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3fda					range_err
.1a3fda	08		php		            PHP
.1a3fdb	c2 20		rep #$20	            REP #$20
.1a3fdd	48		pha		            PHA
.1a3fde	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3fe1	5b		tcd		            TCD
.1a3fe2	68		pla		            PLA
.1a3fe3	28		plp		            PLP
.1a3fe4	e2 20		sep #$20	            SEP #$20
.1a3fe6	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3fe8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3fec	c2 20		rep #$20	            REP #$20
.1a3fee	29 ff 00	and #$00ff	            AND #$00FF
.1a3ff1	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a3ff4	e2 20		sep #$20	            SEP #$20
.1a3ff6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3ff9					S_POKEW
.1a3ff9	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a3ffc	c2 20		rep #$20	            REP #$20
.1a3ffe	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.1a4000	48		pha		                PHA
.1a4001	a5 23		lda $0823	                LDA ARGUMENT1
.1a4003	48		pha		                PHA
.1a4004	e2 20		sep #$20	            SEP #$20
.1a4006	a7 00		lda [$0800]	                LDA [BIP]
.1a4008	c9 2c		cmp #$2c	                CMP #','
.1a400a	d0 19		bne $1a4025	                BNE syntax_err
.1a400c	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a400f	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4012	c2 20		rep #$20	            REP #$20
.1a4014	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4016	d0 2c		bne $1a4044	                BNE range_err
.1a4018	68		pla		                PLA                 ; Pull the target address from the stack
.1a4019	85 08		sta $0808	                STA INDEX           ; and into INDEX
.1a401b	68		pla		                PLA
.1a401c	85 0a		sta $080a	                STA INDEX+2
.1a401e	c2 20		rep #$20	            REP #$20
.1a4020	a5 23		lda $0823	                LDA ARGUMENT1
.1a4022	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.1a4024	60		rts		            RTS
.1a4025					syntax_err
.1a4025	08		php		            PHP
.1a4026	c2 20		rep #$20	            REP #$20
.1a4028	48		pha		            PHA
.1a4029	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a402c	5b		tcd		            TCD
.1a402d	68		pla		            PLA
.1a402e	28		plp		            PLP
.1a402f	e2 20		sep #$20	            SEP #$20
.1a4031	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4033	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4037	c2 20		rep #$20	            REP #$20
.1a4039	29 ff 00	and #$00ff	            AND #$00FF
.1a403c	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a403f	e2 20		sep #$20	            SEP #$20
.1a4041	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4044					range_err
.1a4044	08		php		            PHP
.1a4045	c2 20		rep #$20	            REP #$20
.1a4047	48		pha		            PHA
.1a4048	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a404b	5b		tcd		            TCD
.1a404c	68		pla		            PLA
.1a404d	28		plp		            PLP
.1a404e	e2 20		sep #$20	            SEP #$20
.1a4050	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4052	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4056	c2 20		rep #$20	            REP #$20
.1a4058	29 ff 00	and #$00ff	            AND #$00FF
.1a405b	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a405e	e2 20		sep #$20	            SEP #$20
.1a4060	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4063					S_POKE
.1a4063	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4066	c2 20		rep #$20	            REP #$20
.1a4068	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.1a406a	48		pha		                PHA
.1a406b	a5 23		lda $0823	                LDA ARGUMENT1
.1a406d	48		pha		                PHA
.1a406e	e2 20		sep #$20	            SEP #$20
.1a4070	a7 00		lda [$0800]	                LDA [BIP]
.1a4072	c9 2c		cmp #$2c	                CMP #','
.1a4074	d0 1f		bne $1a4095	                BNE syntax_err
.1a4076	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4079	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a407c	e2 20		sep #$20	            SEP #$20
.1a407e	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Make sure the value is from 0 - 255
.1a4080	d0 32		bne $1a40b4	                BNE range_err
.1a4082	c2 20		rep #$20	            REP #$20
.1a4084	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4086	d0 2c		bne $1a40b4	                BNE range_err
.1a4088	68		pla		                PLA                 ; Pull the target address from the stack
.1a4089	85 08		sta $0808	                STA INDEX           ; and into INDEX
.1a408b	68		pla		                PLA
.1a408c	85 0a		sta $080a	                STA INDEX+2
.1a408e	e2 20		sep #$20	            SEP #$20
.1a4090	a5 23		lda $0823	                LDA ARGUMENT1
.1a4092	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.1a4094	60		rts		            RTS
.1a4095					syntax_err
.1a4095	08		php		            PHP
.1a4096	c2 20		rep #$20	            REP #$20
.1a4098	48		pha		            PHA
.1a4099	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a409c	5b		tcd		            TCD
.1a409d	68		pla		            PLA
.1a409e	28		plp		            PLP
.1a409f	e2 20		sep #$20	            SEP #$20
.1a40a1	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a40a3	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a40a7	c2 20		rep #$20	            REP #$20
.1a40a9	29 ff 00	and #$00ff	            AND #$00FF
.1a40ac	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a40af	e2 20		sep #$20	            SEP #$20
.1a40b1	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a40b4					range_err
.1a40b4	08		php		            PHP
.1a40b5	c2 20		rep #$20	            REP #$20
.1a40b7	48		pha		            PHA
.1a40b8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a40bb	5b		tcd		            TCD
.1a40bc	68		pla		            PLA
.1a40bd	28		plp		            PLP
.1a40be	e2 20		sep #$20	            SEP #$20
.1a40c0	a9 09		lda #$09	            LDA #ERR_RANGE
.1a40c2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a40c6	c2 20		rep #$20	            REP #$20
.1a40c8	29 ff 00	and #$00ff	            AND #$00FF
.1a40cb	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a40ce	e2 20		sep #$20	            SEP #$20
.1a40d0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a40d3					S_STOP
.1a40d3	08		php		            PHP
.1a40d4	c2 20		rep #$20	            REP #$20
.1a40d6	48		pha		            PHA
.1a40d7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a40da	5b		tcd		            TCD
.1a40db	68		pla		            PLA
.1a40dc	28		plp		            PLP
.1a40dd	e2 20		sep #$20	            SEP #$20
.1a40df	a9 01		lda #$01	            LDA #ERR_BREAK
.1a40e1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a40e5	c2 20		rep #$20	            REP #$20
.1a40e7	29 ff 00	and #$00ff	            AND #$00FF
.1a40ea	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a40ed	e2 20		sep #$20	            SEP #$20
.1a40ef	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a40f2					S_REM
.1a40f2	08		php		                PHP
.1a40f3	e2 20		sep #$20	            SEP #$20
.1a40f5	a7 00		lda [$0800]	rem_loop        LDA [BIP]
.1a40f7	f0 05		beq $1a40fe	                BEQ done
.1a40f9	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a40fc	80 f7		bra $1a40f5	                BRA rem_loop
.1a40fe	28		plp		done            PLP
.1a40ff	60		rts		            RTS
.1a4100					S_EXIT
.1a4100	08		php		                PHP
.1a4101	28		plp		                PLP
.1a4102	60		rts		            RTS
.1a4103					S_DO
.1a4103	08		php		                PHP
.1a4104	28		plp		                PLP
.1a4105	60		rts		            RTS
.0000					DO_RECORD
>0000					BIP             .dword  ?
>0004					CURLINE         .dword  ?
.1a4106					S_LOOP
.1a4106	08		php		                PHP
.1a4107	28		plp		                PLP
.1a4108	60		rts		            RTS
.1a4109					S_FOR
.1a4109	08		php		                PHP
.1a410a	c2 20		rep #$20	            REP #$20
.1a410c	a5 1c		lda $081c	                LDA CURLINE+2
.1a410e	20 e5 1d	jsr $1a1de5	            JSR PHRETURN
.1a4111	a5 1a		lda $081a	                LDA CURLINE
.1a4113	20 e5 1d	jsr $1a1de5	            JSR PHRETURN
.1a4116	a5 02		lda $0802	                LDA BIP+2           ; Save current BIP
.1a4118	48		pha		                PHA
.1a4119	a5 00		lda $0800	                LDA BIP
.1a411b	48		pha		                PHA
.1a411c	20 22 21	jsr $1a2122	            JSR SKIPSTMT
.1a411f	a5 02		lda $0802	                LDA BIP+2           ; Save the BIP for the next statement to the RETURN stack
.1a4121	20 e5 1d	jsr $1a1de5	            JSR PHRETURN
.1a4124	a5 00		lda $0800	                LDA BIP
.1a4126	20 e5 1d	jsr $1a1de5	            JSR PHRETURN
.1a4129	68		pla		                PLA                 ; Restore the original BIP
.1a412a	85 00		sta $0800	                STA BIP
.1a412c	68		pla		                PLA
.1a412d	85 02		sta $0802	                STA BIP+2
.1a412f	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a4132					get_name
.1a4132	20 38 53	jsr $1a5338	            JSR VAR_FINDNAME
.1a4135	b0 1f		bcs $1a4156	                BCS push_name       ; If we didn't find a name, thrown an error
.1a4137	08		php		            PHP
.1a4138	c2 20		rep #$20	            REP #$20
.1a413a	48		pha		            PHA
.1a413b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a413e	5b		tcd		            TCD
.1a413f	68		pla		            PLA
.1a4140	28		plp		            PLP
.1a4141	e2 20		sep #$20	            SEP #$20
.1a4143	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a4145	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4149	c2 20		rep #$20	            REP #$20
.1a414b	29 ff 00	and #$00ff	            AND #$00FF
.1a414e	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4151	e2 20		sep #$20	            SEP #$20
.1a4153	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4156					push_name
.1a4156	e2 20		sep #$20	            SEP #$20
.1a4158	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; To the return stack
.1a415a	20 fc 1d	jsr $1a1dfc	            JSR PHRETURNB
.1a415d	a5 e9		lda $08e9	                LDA TOFIND+2
.1a415f	20 fc 1d	jsr $1a1dfc	            JSR PHRETURNB
.1a4162	c2 20		rep #$20	            REP #$20
.1a4164	a5 e7		lda $08e7	                LDA TOFIND
.1a4166	20 e5 1d	jsr $1a1de5	            JSR PHRETURN
.1a4169					else
.1a4169	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a416c	e2 20		sep #$20	            SEP #$20
.1a416e	a7 00		lda [$0800]	                LDA [BIP]
.1a4170	c9 8a		cmp #$8a	                CMP #TOK_EQ
.1a4172	d0 6a		bne $1a41de	                BNE syntax_err      ; If not found: signal an syntax error
.1a4174	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Verify type of variable
.1a4176	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; Is it integer?
.1a4178	f0 04		beq $1a417e	                BEQ process_initial ; Yes: it's ok
.1a417a	c9 01		cmp #$01	                CMP #TYPE_FLOAT     ; Is it floating point?
.1a417c	f0 00		beq $1a417e	                BEQ process_initial ; Yes: it's ok
.1a417e					process_initial
.1a417e	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4181	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4184	20 9b 52	jsr $1a529b	            JSR VAR_SET
.1a4187	e2 20		sep #$20	            SEP #$20
.1a4189	a9 9c		lda #$9c	                LDA #TOK_TO         ; Expect the next token to be TO
.1a418b	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a418e	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4191	c2 20		rep #$20	            REP #$20
.1a4193	a5 27		lda $0827	                LDA ARGTYPE1
.1a4195	20 e5 1d	jsr $1a1de5	            JSR PHRETURN
.1a4198	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a419a	20 e5 1d	jsr $1a1de5	            JSR PHRETURN
.1a419d	a5 23		lda $0823	                LDA ARGUMENT1
.1a419f	20 e5 1d	jsr $1a1de5	            JSR PHRETURN
.1a41a2	e2 20		sep #$20	            SEP #$20
.1a41a4	a9 9d		lda #$9d	                LDA #TOK_STEP
.1a41a6	85 37		sta $0837	                STA TARGETTOK
.1a41a8	20 1f 22	jsr $1a221f	            JSR OPT_TOK
.1a41ab	90 1b		bcc $1a41c8	                BCC default_inc     ; Not found: set a default increment of 1
.1a41ad	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a41b0	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a41b3	e2 20		sep #$20	            SEP #$20
.1a41b5	a5 27		lda $0827	                LDA ARGTYPE1        ; Push the result as the increment
.1a41b7	20 e5 1d	jsr $1a1de5	            JSR PHRETURN
.1a41ba	c2 20		rep #$20	            REP #$20
.1a41bc	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a41be	20 e5 1d	jsr $1a1de5	            JSR PHRETURN
.1a41c1	a5 23		lda $0823	                LDA ARGUMENT1
.1a41c3	20 e5 1d	jsr $1a1de5	            JSR PHRETURN
.1a41c6	80 14		bra $1a41dc	                BRA done
.1a41c8					default_inc
.1a41c8	c2 20		rep #$20	            REP #$20
.1a41ca	a9 00 00	lda #$0000	                LDA #TYPE_INTEGER
.1a41cd	20 e5 1d	jsr $1a1de5	            JSR PHRETURN
.1a41d0	a9 00 00	lda #$0000	                LDA #0
.1a41d3	20 e5 1d	jsr $1a1de5	            JSR PHRETURN
.1a41d6	a9 01 00	lda #$0001	                LDA #1
.1a41d9	20 e5 1d	jsr $1a1de5	            JSR PHRETURN
.1a41dc	28		plp		done            PLP
.1a41dd	60		rts		            RTS
.1a41de					syntax_err
.1a41de	08		php		            PHP
.1a41df	c2 20		rep #$20	            REP #$20
.1a41e1	48		pha		            PHA
.1a41e2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a41e5	5b		tcd		            TCD
.1a41e6	68		pla		            PLA
.1a41e7	28		plp		            PLP
.1a41e8	e2 20		sep #$20	            SEP #$20
.1a41ea	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a41ec	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a41f0	c2 20		rep #$20	            REP #$20
.1a41f2	29 ff 00	and #$00ff	            AND #$00FF
.1a41f5	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a41f8	e2 20		sep #$20	            SEP #$20
.1a41fa	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.0000					FOR_RECORD
>0000					INCREMENT       .dword  ?
>0004					INCTYPE         .word   ?
>0006					FINAL           .dword  ?
>000a					FINALTYPE       .word   ?
>000c					VARIBLE         .dword  ?
>0010					VARTYPE         .word   ?
>0012					BIP             .dword  ?
>0016					CURLINE         .dword  ?
.1a41fd					S_NEXT
.1a41fd	08		php		                PHP
.1a41fe	8b		phb		                PHB
.1a41ff	08		php		            PHP
.1a4200	e2 20		sep #$20	            SEP #$20
.1a4202	48		pha		            PHA
.1a4203	a9 00		lda #$00	            LDA #0
.1a4205	48		pha		            PHA
.1a4206	ab		plb		            PLB
.1a4207	68		pla		            PLA
.1a4208	28		plp		            PLP
.1a4209	08		php		            PHP
.1a420a	c2 20		rep #$20	            REP #$20
.1a420c	48		pha		            PHA
.1a420d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a4210	5b		tcd		            TCD
.1a4211	68		pla		            PLA
.1a4212	28		plp		            PLP
.1a4213	c2 30		rep #$30	            REP #$30
.1a4215	a4 33		ldy $0833	                LDY RETURNSP                    ; Y := pointer to first byte of the FOR record
.1a4217	c8		iny		                INY                             ; RETURNSP points to the first free slot, so move up 2 bytes
.1a4218	c8		iny		                INY
.1a4219	c2 20		rep #$20	            REP #$20
.1a421b	b9 0c 00	lda $000c,y	                LDA #FOR_RECORD.VARIBLE,B,Y     ; TOFIND := FOR_RECORD.VARIABLE
.1a421e	85 e7		sta $08e7	                STA TOFIND
.1a4220	b9 0e 00	lda $000e,y	                LDA #FOR_RECORD.VARIBLE+2,B,Y
.1a4223	e2 20		sep #$20	            SEP #$20
.1a4225	85 e9		sta $08e9	                STA TOFIND+2
.1a4227	b9 10 00	lda $0010,y	                LDA #FOR_RECORD.VARTYPE,B,Y
.1a422a	85 ea		sta $08ea	                STA TOFINDTYPE
.1a422c	c2 20		rep #$20	            REP #$20
.1a422e	5a		phy		                PHY
.1a422f	20 39 51	jsr $1a5139	            JSR VAR_REF
.1a4232	7a		ply		                PLY
.1a4233	c2 20		rep #$20	            REP #$20
.1a4235	b9 00 00	lda $0000,y	                LDA #FOR_RECORD.INCREMENT,B,Y   ; ARGUMENT2 := FOR_RECORD.INCREMENT
.1a4238	85 29		sta $0829	                STA ARGUMENT2
.1a423a	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y
.1a423d	85 2b		sta $082b	                STA ARGUMENT2+2
.1a423f	e2 20		sep #$20	            SEP #$20
.1a4241	b9 04 00	lda $0004,y	                LDA #FOR_RECORD.INCTYPE,B,Y
.1a4244	85 2d		sta $082d	                STA ARGTYPE2
.1a4246	c2 20		rep #$20	            REP #$20
.1a4248	5a		phy		                PHY
.1a4249	20 a3 27	jsr $1a27a3	            JSR OP_PLUS
.1a424c	20 9b 52	jsr $1a529b	            JSR VAR_SET
.1a424f	7a		ply		                PLY
.1a4250	c2 20		rep #$20	            REP #$20
.1a4252	b9 06 00	lda $0006,y	                LDA #FOR_RECORD.FINAL,B,Y       ; ARGUMENT2 := FOR_RECORD.FINAL
.1a4255	85 29		sta $0829	                STA ARGUMENT2
.1a4257	b9 08 00	lda $0008,y	                LDA #FOR_RECORD.FINAL+2,B,Y
.1a425a	85 2b		sta $082b	                STA ARGUMENT2+2
.1a425c	e2 20		sep #$20	            SEP #$20
.1a425e	b9 0a 00	lda $000a,y	                LDA #FOR_RECORD.FINALTYPE,B,Y
.1a4261	85 2d		sta $082d	                STA ARGTYPE2
.1a4263	c2 20		rep #$20	            REP #$20
.1a4265	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y ; Check the increment's sign
.1a4268	30 0a		bmi $1a4274	                BMI going_down
.1a426a					going_up
.1a426a	20 2c 2a	jsr $1a2a2c	            JSR OP_LTE
.1a426d	20 df 05	jsr $1a05df	            JSR IS_ARG1_Z
.1a4270	f0 28		beq $1a429a	                BEQ end_loop                    ; No: end the loop
.1a4272	80 08		bra $1a427c	                BRA loop_back                   ; Yes: loop back
.1a4274					going_down
.1a4274	20 ec 29	jsr $1a29ec	            JSR OP_GTE
.1a4277	20 df 05	jsr $1a05df	            JSR IS_ARG1_Z
.1a427a	f0 1e		beq $1a429a	                BEQ end_loop                    ; No: end the loop
.1a427c					loop_back
.1a427c	c2 20		rep #$20	            REP #$20
.1a427e	b9 12 00	lda $0012,y	                LDA #FOR_RECORD.BIP,B,Y
.1a4281	85 00		sta $0800	                STA BIP
.1a4283	b9 14 00	lda $0014,y	                LDA #FOR_RECORD.BIP+2,B,Y
.1a4286	85 02		sta $0802	                STA BIP+2
.1a4288	b9 16 00	lda $0016,y	                LDA #FOR_RECORD.CURLINE,B,Y     ; CURLINE := FOR_RECORD.CURLINE
.1a428b	85 1a		sta $081a	                STA CURLINE
.1a428d	b9 18 00	lda $0018,y	                LDA #FOR_RECORD.CURLINE+2,B,Y
.1a4290	85 1c		sta $081c	                STA CURLINE+2
.1a4292	e2 20		sep #$20	            SEP #$20
.1a4294	a9 03		lda #$03	                LDA #EXEC_RETURN
.1a4296	85 dc		sta $08dc	                STA EXECACTION
.1a4298	80 17		bra $1a42b1	                BRA done
.1a429a					end_loop
.1a429a	a2 23 08	ldx #$0823	                LDX #ARGUMENT1
.1a429d	20 a9 19	jsr $1a19a9	            JSR PLARGUMENT
.1a42a0	c2 20		rep #$20	            REP #$20
.1a42a2	18		clc		                CLC
.1a42a3	a5 33		lda $0833	                LDA RETURNSP
.1a42a5	69 1a 00	adc #$001a	                ADC #size(FOR_RECORD)           ; Move pointer by number of bytes in a FOR record
.1a42a8	85 33		sta $0833	                STA RETURNSP
.1a42aa	a5 35		lda $0835	                LDA RETURNSP+2
.1a42ac	69 00 00	adc #$0000	                ADC #0
.1a42af	85 35		sta $0835	                STA RETURNSP+2
.1a42b1	ab		plb		done            PLB
.1a42b2	28		plp		                PLP
.1a42b3	60		rts		            RTS
.1a42b4					S_GOSUB
.1a42b4	08		php		                PHP
.1a42b5	a5 1a		lda $081a	                LDA CURLINE                 ; Save the current line for later
.1a42b7	48		pha		                PHA
.1a42b8	a5 1c		lda $081c	                LDA CURLINE+2
.1a42ba	48		pha		                PHA
.1a42bb	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a42be	20 9d 08	jsr $1a089d	            JSR PARSEINT
.1a42c1	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.1a42c3	f0 26		beq $1a42eb	                BEQ syntax_err              ; If 0, no number was found... syntax error
.1a42c5	20 dd 23	jsr $1a23dd	            JSR FINDLINE
.1a42c8	90 42		bcc $1a430c	                BCC not_found               ; If not found... LINE NOT FOUND error
.1a42ca	e2 20		sep #$20	            SEP #$20
.1a42cc	a9 02		lda #$02	                LDA #EXEC_GOTO
.1a42ce	85 dc		sta $08dc	                STA EXECACTION
.1a42d0	20 22 21	jsr $1a2122	            JSR SKIPSTMT
.1a42d3	c2 20		rep #$20	            REP #$20
.1a42d5	68		pla		                PLA                         ; Save the old value of CURLINE to the RETURN stack
.1a42d6	20 e5 1d	jsr $1a1de5	            JSR PHRETURN
.1a42d9	68		pla		                PLA
.1a42da	20 e5 1d	jsr $1a1de5	            JSR PHRETURN
.1a42dd	a5 02		lda $0802	                LDA BIP+2                   ; Save the BASIC Instruction Pointer to the RETURN stack
.1a42df	20 e5 1d	jsr $1a1de5	            JSR PHRETURN
.1a42e2	a5 00		lda $0800	                LDA BIP
.1a42e4	20 e5 1d	jsr $1a1de5	            JSR PHRETURN
.1a42e7	e6 31		inc $0831	                INC GOSUBDEPTH              ; Increase the count of GOSUBs on the stack
.1a42e9	28		plp		                PLP
.1a42ea	60		rts		            RTS
.1a42eb	68		pla		syntax_err      PLA
.1a42ec	68		pla		                PLA
.1a42ed	08		php		            PHP
.1a42ee	c2 20		rep #$20	            REP #$20
.1a42f0	48		pha		            PHA
.1a42f1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a42f4	5b		tcd		            TCD
.1a42f5	68		pla		            PLA
.1a42f6	28		plp		            PLP
.1a42f7	e2 20		sep #$20	            SEP #$20
.1a42f9	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a42fb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a42ff	c2 20		rep #$20	            REP #$20
.1a4301	29 ff 00	and #$00ff	            AND #$00FF
.1a4304	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4307	e2 20		sep #$20	            SEP #$20
.1a4309	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a430c	68		pla		not_found       PLA
.1a430d	68		pla		                PLA
.1a430e	08		php		            PHP
.1a430f	c2 20		rep #$20	            REP #$20
.1a4311	48		pha		            PHA
.1a4312	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4315	5b		tcd		            TCD
.1a4316	68		pla		            PLA
.1a4317	28		plp		            PLP
.1a4318	e2 20		sep #$20	            SEP #$20
.1a431a	a9 06		lda #$06	            LDA #ERR_NOLINE
.1a431c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4320	c2 20		rep #$20	            REP #$20
.1a4322	29 ff 00	and #$00ff	            AND #$00FF
.1a4325	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4328	e2 20		sep #$20	            SEP #$20
.1a432a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a432d					S_RETURN
.1a432d	08		php		                PHP
.1a432e	c2 30		rep #$30	            REP #$30
.1a4330	a5 31		lda $0831	                LDA GOSUBDEPTH              ; Check that there is at least on GOSUB on the stack
.1a4332	f0 1e		beq $1a4352	                BEQ underflow               ; No? It's a stack underflow error
.1a4334	20 07 1e	jsr $1a1e07	            JSR PLRETURN
.1a4337	85 00		sta $0800	                STA BIP
.1a4339	20 07 1e	jsr $1a1e07	            JSR PLRETURN
.1a433c	85 02		sta $0802	                STA BIP+2
.1a433e	20 07 1e	jsr $1a1e07	            JSR PLRETURN
.1a4341	85 1a		sta $081a	                STA CURLINE
.1a4343	20 07 1e	jsr $1a1e07	            JSR PLRETURN
.1a4346	85 1c		sta $081c	                STA CURLINE+2
.1a4348	c6 31		dec $0831	                DEC GOSUBDEPTH              ; Indicate we've popped that GOSUB off the stack
.1a434a	e2 20		sep #$20	            SEP #$20
.1a434c	a9 03		lda #$03	                LDA #EXEC_RETURN
.1a434e	85 dc		sta $08dc	                STA EXECACTION
.1a4350	28		plp		                PLP
.1a4351	60		rts		            RTS
.1a4352					underflow
.1a4352	08		php		            PHP
.1a4353	c2 20		rep #$20	            REP #$20
.1a4355	48		pha		            PHA
.1a4356	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4359	5b		tcd		            TCD
.1a435a	68		pla		            PLA
.1a435b	28		plp		            PLP
.1a435c	e2 20		sep #$20	            SEP #$20
.1a435e	a9 07		lda #$07	            LDA #ERR_STACKUNDER
.1a4360	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4364	c2 20		rep #$20	            REP #$20
.1a4366	29 ff 00	and #$00ff	            AND #$00FF
.1a4369	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a436c	e2 20		sep #$20	            SEP #$20
.1a436e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4371					S_IF
.1a4371	08		php		                PHP
.1a4372	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4375	20 df 05	jsr $1a05df	            JSR IS_ARG1_Z
.1a4378	f0 1c		beq $1a4396	                BEQ is_false                ; If so, handle the FALSE case
.1a437a	e2 20		sep #$20	            SEP #$20
.1a437c	a9 97		lda #$97	                LDA #TOK_THEN               ; Verify that the next token is THEN and eat it
.1a437e	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4381	20 9d 08	jsr $1a089d	            JSR PARSEINT
.1a4384	20 df 05	jsr $1a05df	            JSR IS_ARG1_Z
.1a4387	f0 12		beq $1a439b	                BEQ syntax_err              ; If not, we have a syntax error
.1a4389	20 dd 23	jsr $1a23dd	            JSR FINDLINE
.1a438c	90 2c		bcc $1a43ba	                BCC not_found               ; If not found... LINE NOT FOUND error
.1a438e	e2 20		sep #$20	            SEP #$20
.1a4390	a9 02		lda #$02	                LDA #EXEC_GOTO
.1a4392	85 dc		sta $08dc	                STA EXECACTION
.1a4394	80 03		bra $1a4399	                BRA done
.1a4396					is_false
.1a4396	20 22 21	jsr $1a2122	            JSR SKIPSTMT
.1a4399	28		plp		done            PLP
.1a439a	60		rts		            RTS
.1a439b					syntax_err
.1a439b	08		php		            PHP
.1a439c	c2 20		rep #$20	            REP #$20
.1a439e	48		pha		            PHA
.1a439f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a43a2	5b		tcd		            TCD
.1a43a3	68		pla		            PLA
.1a43a4	28		plp		            PLP
.1a43a5	e2 20		sep #$20	            SEP #$20
.1a43a7	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a43a9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a43ad	c2 20		rep #$20	            REP #$20
.1a43af	29 ff 00	and #$00ff	            AND #$00FF
.1a43b2	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a43b5	e2 20		sep #$20	            SEP #$20
.1a43b7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a43ba					not_found
.1a43ba	08		php		            PHP
.1a43bb	c2 20		rep #$20	            REP #$20
.1a43bd	48		pha		            PHA
.1a43be	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a43c1	5b		tcd		            TCD
.1a43c2	68		pla		            PLA
.1a43c3	28		plp		            PLP
.1a43c4	e2 20		sep #$20	            SEP #$20
.1a43c6	a9 06		lda #$06	            LDA #ERR_NOLINE
.1a43c8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a43cc	c2 20		rep #$20	            REP #$20
.1a43ce	29 ff 00	and #$00ff	            AND #$00FF
.1a43d1	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a43d4	e2 20		sep #$20	            SEP #$20
.1a43d6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a43d9					S_END
.1a43d9	08		php		                PHP
.1a43da	e2 20		sep #$20	            SEP #$20
.1a43dc	a9 01		lda #$01	                LDA #EXEC_STOP
.1a43de	85 dc		sta $08dc	                STA EXECACTION
.1a43e0	28		plp		                PLP
.1a43e1	60		rts		            RTS
.1a43e2					S_GOTO
.1a43e2	08		php		                PHP
.1a43e3	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a43e6	20 9d 08	jsr $1a089d	            JSR PARSEINT
.1a43e9	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.1a43eb	f0 0d		beq $1a43fa	                BEQ syntax_err              ; If 0, no number was found... syntax error
.1a43ed	20 dd 23	jsr $1a23dd	            JSR FINDLINE
.1a43f0	90 27		bcc $1a4419	                BCC not_found               ; If not found... LINE NOT FOUND error
.1a43f2	e2 20		sep #$20	            SEP #$20
.1a43f4	a9 02		lda #$02	                LDA #EXEC_GOTO
.1a43f6	85 dc		sta $08dc	                STA EXECACTION
.1a43f8	28		plp		                PLP
.1a43f9	60		rts		            RTS
.1a43fa					syntax_err
.1a43fa	08		php		            PHP
.1a43fb	c2 20		rep #$20	            REP #$20
.1a43fd	48		pha		            PHA
.1a43fe	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4401	5b		tcd		            TCD
.1a4402	68		pla		            PLA
.1a4403	28		plp		            PLP
.1a4404	e2 20		sep #$20	            SEP #$20
.1a4406	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4408	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a440c	c2 20		rep #$20	            REP #$20
.1a440e	29 ff 00	and #$00ff	            AND #$00FF
.1a4411	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4414	e2 20		sep #$20	            SEP #$20
.1a4416	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4419					not_found
.1a4419	08		php		            PHP
.1a441a	c2 20		rep #$20	            REP #$20
.1a441c	48		pha		            PHA
.1a441d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4420	5b		tcd		            TCD
.1a4421	68		pla		            PLA
.1a4422	28		plp		            PLP
.1a4423	e2 20		sep #$20	            SEP #$20
.1a4425	a9 06		lda #$06	            LDA #ERR_NOLINE
.1a4427	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a442b	c2 20		rep #$20	            REP #$20
.1a442d	29 ff 00	and #$00ff	            AND #$00FF
.1a4430	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4433	e2 20		sep #$20	            SEP #$20
.1a4435	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4438					S_CLR
.1a4438	20 4b 19	jsr $1a194b	            JSR INITEVALSP
.1a443b	20 6b 10	jsr $1a106b	            JSR INITHEAP
.1a443e	20 38 50	jsr $1a5038	            JSR INITVARS
.1a4441	60		rts		            RTS
.1a4442					S_LET
.1a4442	08		php		                PHP
.1a4443	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.1a4445	10 03		bpl $1a444a	                BPL get_name        ; If it's not a token, try to find the variable name
.1a4447	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a444a					get_name
.1a444a	20 38 53	jsr $1a5338	            JSR VAR_FINDNAME
.1a444d	b0 03		bcs $1a4452	                BCS check_array     ; If we didn't find a name, thrown an error
.1a444f	4c b9 44	jmp $1a44b9	                JMP syntax_err
.1a4452					check_array
.1a4452	e2 20		sep #$20	            SEP #$20
.1a4454	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Save the variable name for later
.1a4456	48		pha		                PHA                 ; (it will get over-written by variable references)
.1a4457	a5 e9		lda $08e9	                LDA TOFIND+2
.1a4459	48		pha		                PHA
.1a445a	a5 e8		lda $08e8	                LDA TOFIND+1
.1a445c	48		pha		                PHA
.1a445d	a5 e7		lda $08e7	                LDA TOFIND
.1a445f	48		pha		                PHA
.1a4460	20 3e 22	jsr $1a223e	            JSR PEEK_TOK
.1a4463	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it a "("
.1a4465	d0 0e		bne $1a4475	                BNE get_value       ; No: it's a scalar assignment, look for the "="
.1a4467	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4469	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a446c	a9 00		lda #$00	                LDA #0
.1a446e	8f 00 4d 00	sta $004d00	                STA @l ARRIDXBUF    ; Blank out the array index buffer
.1a4472	20 cd 1a	jsr $1a1acd	            JSR ARR_GETIDX
.1a4475					get_value
.1a4475	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a4478	e2 20		sep #$20	            SEP #$20
.1a447a	a7 00		lda [$0800]	                LDA [BIP]
.1a447c	c9 8a		cmp #$8a	                CMP #TOK_EQ
.1a447e	f0 03		beq $1a4483	                BEQ found_eq        ; If not found: signal an syntax error
.1a4480	4c b9 44	jmp $1a44b9	                JMP syntax_err
.1a4483					found_eq
.1a4483	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4486	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4489	68		pla		                PLA                 ; Restore the variable name
.1a448a	85 e7		sta $08e7	                STA TOFIND
.1a448c	68		pla		                PLA
.1a448d	85 e8		sta $08e8	                STA TOFIND+1
.1a448f	68		pla		                PLA
.1a4490	85 e9		sta $08e9	                STA TOFIND+2
.1a4492	68		pla		                PLA
.1a4493	85 ea		sta $08ea	                STA TOFINDTYPE
.1a4495	29 80		and #$80	                AND #$80            ; Is it an array we're setting?
.1a4497	f0 1b		beq $1a44b4	                BEQ set_scalar      ; No: do a scalar variable set
.1a4499	20 ab 50	jsr $1a50ab	            JSR VAR_FIND
.1a449c	90 3a		bcc $1a44d8	                BCC notfound_err
.1a449e	c2 20		rep #$20	            REP #$20
.1a44a0	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.1a44a3	b7 08		lda [$0808],y	                LDA [INDEX],Y       ; Save the pointer to the array to CURRBLOCK
.1a44a5	85 c0		sta $08c0	                STA CURRBLOCK
.1a44a7	e2 20		sep #$20	            SEP #$20
.1a44a9	c8		iny		                INY
.1a44aa	c8		iny		                INY
.1a44ab	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a44ad	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a44af	20 a2 67	jsr $1a67a2	            JSR ARR_SET
.1a44b2	80 03		bra $1a44b7	                BRA done            ; and we're finished!
.1a44b4					set_scalar
.1a44b4	20 9b 52	jsr $1a529b	            JSR VAR_SET
.1a44b7					done
.1a44b7	28		plp		                PLP
.1a44b8	60		rts		            RTS
.1a44b9					syntax_err
.1a44b9	08		php		            PHP
.1a44ba	c2 20		rep #$20	            REP #$20
.1a44bc	48		pha		            PHA
.1a44bd	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a44c0	5b		tcd		            TCD
.1a44c1	68		pla		            PLA
.1a44c2	28		plp		            PLP
.1a44c3	e2 20		sep #$20	            SEP #$20
.1a44c5	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a44c7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a44cb	c2 20		rep #$20	            REP #$20
.1a44cd	29 ff 00	and #$00ff	            AND #$00FF
.1a44d0	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a44d3	e2 20		sep #$20	            SEP #$20
.1a44d5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a44d8					notfound_err
.1a44d8	08		php		            PHP
.1a44d9	c2 20		rep #$20	            REP #$20
.1a44db	48		pha		            PHA
.1a44dc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a44df	5b		tcd		            TCD
.1a44e0	68		pla		            PLA
.1a44e1	28		plp		            PLP
.1a44e2	e2 20		sep #$20	            SEP #$20
.1a44e4	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a44e6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a44ea	c2 20		rep #$20	            REP #$20
.1a44ec	29 ff 00	and #$00ff	            AND #$00FF
.1a44ef	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a44f2	e2 20		sep #$20	            SEP #$20
.1a44f4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a44f7					S_PRINT
.1a44f7	08		php		                PHP
.1a44f8	e2 20		sep #$20	            SEP #$20
.1a44fa	20 3e 22	jsr $1a223e	            JSR PEEK_TOK
.1a44fd	c9 00		cmp #$00	                CMP #0              ; Is it EOL or :?
.1a44ff	f0 6d		beq $1a456e	                BEQ pr_nl_exit      ; Yes: just print return
.1a4501					pr_loop
.1a4501	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4504	e2 20		sep #$20	            SEP #$20
.1a4506	a5 27		lda $0827	                LDA ARGTYPE1        ; Get the type of the result
.1a4508	c9 ff		cmp #$ff	                CMP #TYPE_NAV       ; Is is NAV?
.1a450a	f0 1b		beq $1a4527	                BEQ check_nl        ; Yes: we are probably just printing a newline
.1a450c	c9 02		cmp #$02	                CMP #TYPE_STRING    ; Is it a string?
.1a450e	d0 05		bne $1a4515	                BNE check_int       ; No: check to see if it's an integer
.1a4510	20 73 45	jsr $1a4573	            JSR PR_STRING
.1a4513	80 12		bra $1a4527	                BRA check_nl
.1a4515	c9 00		cmp #$00	check_int       CMP #TYPE_INTEGER   ; Is it an integer?
.1a4517	d0 05		bne $1a451e	                BNE check_float     ; No: check to see if it is a float
.1a4519	20 91 45	jsr $1a4591	            JSR PR_INTEGER
.1a451c	80 09		bra $1a4527	                BRA check_nl
.1a451e	c9 01		cmp #$01	check_float     CMP #TYPE_FLOAT     ; Is it a float?
.1a4520	d0 4f		bne $1a4571	                BNE done            ; No: just quit
.1a4522	20 a4 45	jsr $1a45a4	            JSR PR_FLOAT
.1a4525	80 00		bra $1a4527	                BRA check_nl
.1a4527					check_nl
.1a4527	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a452a	a7 00		lda [$0800]	                LDA [BIP]
.1a452c	f0 40		beq $1a456e	                BEQ pr_nl_exit      ; If it's nul, print a newline and return
.1a452e	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.1a4530	f0 3c		beq $1a456e	                BEQ pr_nl_exit      ; print a newline and return
.1a4532	c9 2c		cmp #$2c	                CMP #','            ; If it's a comma
.1a4534	f0 23		beq $1a4559	                BEQ pr_comma        ; Print a TAB and try another expression
.1a4536	c9 3b		cmp #$3b	                CMP #';'            ; If it's a semicolon...
.1a4538	f0 24		beq $1a455e	                BEQ is_more         ; Print nothing, and try another expression
.1a453a	08		php		            PHP
.1a453b	c2 20		rep #$20	            REP #$20
.1a453d	48		pha		            PHA
.1a453e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4541	5b		tcd		            TCD
.1a4542	68		pla		            PLA
.1a4543	28		plp		            PLP
.1a4544	e2 20		sep #$20	            SEP #$20
.1a4546	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4548	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a454c	c2 20		rep #$20	            REP #$20
.1a454e	29 ff 00	and #$00ff	            AND #$00FF
.1a4551	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4554	e2 20		sep #$20	            SEP #$20
.1a4556	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4559	a9 09		lda #$09	pr_comma        LDA #CHAR_TAB       ; Print a TAB
.1a455b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a455e					is_more
.1a455e	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4561	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a4564	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.1a4566	f0 09		beq $1a4571	                BEQ done            ; If it's NULL, return without printing a newline
.1a4568	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.1a456a	f0 05		beq $1a4571	                BEQ done            ; ... return without printing a newline
.1a456c	80 93		bra $1a4501	                BRA pr_loop         ; Otherwise, we should have another expression, try to handle it
.1a456e					pr_nl_exit
.1a456e	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a4571	28		plp		done            PLP
.1a4572	60		rts		            RTS
.1a4573					PR_STRING
.1a4573	08		php		                PHP
.1a4574	8b		phb		                PHB
.1a4575	08		php		            PHP
.1a4576	c2 20		rep #$20	            REP #$20
.1a4578	48		pha		            PHA
.1a4579	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a457c	5b		tcd		            TCD
.1a457d	68		pla		            PLA
.1a457e	28		plp		            PLP
.1a457f	e2 20		sep #$20	            SEP #$20
.1a4581	a0 00 00	ldy #$0000	start_print     LDY #0
.1a4584	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y
.1a4586	f0 06		beq $1a458e	                BEQ done
.1a4588	20 18 00	jsr $1a0018	            JSR PRINTC
.1a458b	c8		iny		                INY
.1a458c	80 f6		bra $1a4584	                BRA loop
.1a458e	ab		plb		done            PLB
.1a458f	28		plp		                PLP
.1a4590	60		rts		            RTS
.1a4591					PR_INTEGER
.1a4591	08		php		                PHP
.1a4592	c2 20		rep #$20	            REP #$20
.1a4594	20 20 15	jsr $1a1520	            JSR ITOS
.1a4597	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.1a4599	85 23		sta $0823	                STA ARGUMENT1
.1a459b	a5 18		lda $0818	                LDA STRPTR+2
.1a459d	85 25		sta $0825	                STA ARGUMENT1+2
.1a459f	20 73 45	jsr $1a4573	            JSR PR_STRING
.1a45a2	28		plp		                PLP
.1a45a3	60		rts		            RTS
.1a45a4					PR_FLOAT
.1a45a4	08		php		                PHP
.1a45a5	20 01 5d	jsr $1a5d01	            JSR FTOS
.1a45a8	c2 20		rep #$20	            REP #$20
.1a45aa	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.1a45ac	85 23		sta $0823	                STA ARGUMENT1
.1a45ae	a5 18		lda $0818	                LDA STRPTR+2
.1a45b0	85 25		sta $0825	                STA ARGUMENT1+2
.1a45b2	20 73 45	jsr $1a4573	            JSR PR_STRING
.1a45b5	28		plp		                PLP
.1a45b6	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\functions.s


;******  Processing file: src\C256/functions_c256.s

.1a45b7					BCD2STR
.1a45b7	08		php		            PHP
.1a45b8	e2 20		sep #$20	            SEP #$20
.1a45ba	85 b5		sta $08b5	            STA SAVE_A
.1a45bc	4a		lsr a		            LSR A
.1a45bd	4a		lsr a		            LSR A
.1a45be	4a		lsr a		            LSR A
.1a45bf	4a		lsr a		            LSR A
.1a45c0	29 0f		and #$0f	            AND #$0F
.1a45c2	18		clc		            CLC
.1a45c3	69 30		adc #$30	            ADC #'0'
.1a45c5	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a45c7	c8		iny		            INY
.1a45c8	a5 b5		lda $08b5	            LDA SAVE_A
.1a45ca	29 0f		and #$0f	            AND #$0F
.1a45cc	18		clc		            CLC
.1a45cd	69 30		adc #$30	            ADC #'0'
.1a45cf	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a45d1	c8		iny		            INY
.1a45d2	28		plp		            PLP
.1a45d3	60		rts		            RTS
.1a45d4					F_GETDATE
.1a45d4	e2 20		sep #$20	            SEP #$20
.1a45d6	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a45d8	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a45db	08		php		            PHP
.1a45dc	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a45df	e2 20		sep #$20	            SEP #$20
.1a45e1	c2 10		rep #$10	            REP #$10
.1a45e3	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a45e7	09 08		ora #$08	            ORA #%00001000
.1a45e9	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a45ed	20 c1 14	jsr $1a14c1	            JSR TEMPSTRING
.1a45f0	a0 00 00	ldy #$0000	            LDY #0
.1a45f3	af 06 08 af	lda $af0806	            LDA @lRTC_DAY           ; Write the day of the month
.1a45f7	20 b7 45	jsr $1a45b7	            JSR BCD2STR
.1a45fa	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.1a45fc	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a45fe	c8		iny		            INY
.1a45ff	af 09 08 af	lda $af0809	            LDA @lRTC_MONTH         ; Write the month
.1a4603	20 b7 45	jsr $1a45b7	            JSR BCD2STR
.1a4606	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.1a4608	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a460a	c8		iny		            INY
.1a460b	af 0f 08 af	lda $af080f	            LDA @lRTC_CENTURY       ; Write the year
.1a460f	20 b7 45	jsr $1a45b7	            JSR BCD2STR
.1a4612	af 0a 08 af	lda $af080a	            LDA @lRTC_YEAR          ; Write the year
.1a4616	20 b7 45	jsr $1a45b7	            JSR BCD2STR
.1a4619	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.1a461b	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a461d	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a4621	29 f7		and #$f7	            AND #%11110111
.1a4623	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a4627	c2 20		rep #$20	            REP #$20
.1a4629	a5 16		lda $0816	            LDA STRPTR
.1a462b	85 23		sta $0823	            STA ARGUMENT1
.1a462d	a5 18		lda $0818	            LDA STRPTR+2
.1a462f	85 25		sta $0825	            STA ARGUMENT1+2
.1a4631	e2 20		sep #$20	            SEP #$20
.1a4633	a9 02		lda #$02	            LDA #TYPE_STRING
.1a4635	85 27		sta $0827	            STA ARGTYPE1
.1a4637	28		plp		            PLP
.1a4638	e2 20		sep #$20	            SEP #$20
.1a463a	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a463d	60		rts		            RTS
.1a463e					F_GETTIME
.1a463e	e2 20		sep #$20	            SEP #$20
.1a4640	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4642	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4645	08		php		            PHP
.1a4646	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4649	e2 20		sep #$20	            SEP #$20
.1a464b	c2 10		rep #$10	            REP #$10
.1a464d	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a4651	09 08		ora #$08	            ORA #%00001000
.1a4653	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a4657	20 c1 14	jsr $1a14c1	            JSR TEMPSTRING
.1a465a	a0 00 00	ldy #$0000	            LDY #0
.1a465d	af 04 08 af	lda $af0804	            LDA @lRTC_HRS           ; Write the hour
.1a4661	29 7f		and #$7f	            AND #$7F                ; Trim out the AM/PM indicator
.1a4663	20 b7 45	jsr $1a45b7	            JSR BCD2STR
.1a4666	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.1a4668	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a466a	c8		iny		            INY
.1a466b	af 02 08 af	lda $af0802	            LDA @lRTC_MIN           ; Write the minute
.1a466f	20 b7 45	jsr $1a45b7	            JSR BCD2STR
.1a4672	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.1a4674	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a4676	c8		iny		            INY
.1a4677	af 00 08 af	lda $af0800	            LDA @lRTC_SEC           ; Write the second
.1a467b	20 b7 45	jsr $1a45b7	            JSR BCD2STR
.1a467e	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.1a4680	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a4682	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a4686	29 f7		and #$f7	            AND #%11110111
.1a4688	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a468c	c2 20		rep #$20	            REP #$20
.1a468e	a5 16		lda $0816	            LDA STRPTR
.1a4690	85 23		sta $0823	            STA ARGUMENT1
.1a4692	a5 18		lda $0818	            LDA STRPTR+2
.1a4694	85 25		sta $0825	            STA ARGUMENT1+2
.1a4696	e2 20		sep #$20	            SEP #$20
.1a4698	a9 02		lda #$02	            LDA #TYPE_STRING
.1a469a	85 27		sta $0827	            STA ARGTYPE1
.1a469c	28		plp		            PLP
.1a469d	e2 20		sep #$20	            SEP #$20
.1a469f	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a46a2	60		rts		            RTS
.1a46a3					FN_RND
.1a46a3	e2 20		sep #$20	            SEP #$20
.1a46a5	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a46a7	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a46aa	08		php		            PHP
.1a46ab	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a46ae	e2 20		sep #$20	            SEP #$20
.1a46b0	a9 01		lda #$01	            LDA #TYPE_FLOAT             ; We'll return a floating point number
.1a46b2	85 27		sta $0827	            STA ARGTYPE1
.1a46b4	a9 03		lda #$03	            LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.1a46b6	8f 00 e2 af	sta $afe200	            STA @l FP_MATH_CTRL0        ; Expect fixed point numbers
.1a46ba	a9 01		lda #$01	            LDA #FP_OUT_DIV             ; Set us to do a division
.1a46bc	8f 01 e2 af	sta $afe201	            STA @l FP_MATH_CTRL1
.1a46c0	c2 30		rep #$30	            REP #$30
.1a46c2	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get a random 16-bits
.1a46c6	8f 08 e2 af	sta $afe208	            STA @l FP_MATH_INPUT0_LL    ; Send them to the FP unit
.1a46ca	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get another random 16-bits
.1a46ce	29 ff 7f	and #$7fff	            AND #$7FFF                  ; Make sure it's positive
.1a46d1	8f 0a e2 af	sta $afe20a	            STA @l FP_MATH_INPUT0_LL+2  ; Send them to the FP unit
.1a46d5	a9 ff ff	lda #$ffff	            LDA #$FFFF                  ; Get the maximum value
.1a46d8	8f 0c e2 af	sta $afe20c	            STA @l FP_MATH_INPUT1_LL    ; Send it to the FP unit
.1a46dc	a9 ff 7f	lda #$7fff	            LDA #$7FFF
.1a46df	8f 0e e2 af	sta $afe20e	            STA @l FP_MATH_INPUT1_LL+2
.1a46e3	ea		nop		            NOP
.1a46e4	ea		nop		            NOP
.1a46e5	ea		nop		            NOP
.1a46e6	af 08 e2 af	lda $afe208	            LDA @l FP_MATH_OUTPUT_FP_LL     ; Get the normalized result
.1a46ea	85 23		sta $0823	            STA ARGUMENT1
.1a46ec	af 0a e2 af	lda $afe20a	            LDA @l FP_MATH_OUTPUT_FP_LL+2
.1a46f0	85 25		sta $0825	            STA ARGUMENT1+2
.1a46f2	28		plp		            PLP
.1a46f3	e2 20		sep #$20	            SEP #$20
.1a46f5	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a46f8	60		rts		            RTS

;******  Return to file: src\functions.s

.1a46f9					FN_MID
.1a46f9	e2 20		sep #$20	            SEP #$20
.1a46fb	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a46fd	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4700	08		php		                PHP
.1a4701	c2 30		rep #$30	            REP #$30
.1a4703	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4706	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a4709					save_string
.1a4709	c2 20		rep #$20	            REP #$20
.1a470b	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.1a470d	48		pha		                PHA
.1a470e	a5 23		lda $0823	                LDA ARGUMENT1
.1a4710	48		pha		                PHA
.1a4711	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a4714	e2 20		sep #$20	            SEP #$20
.1a4716	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a4718	c9 2c		cmp #$2c	                CMP #','
.1a471a	f0 03		beq $1a471f	                BEQ skip_comma1
.1a471c	4c 70 47	jmp $1a4770	                JMP syntax_err
.1a471f					skip_comma1
.1a471f	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4722	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4725	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a4728	c2 20		rep #$20	            REP #$20
.1a472a	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the index
.1a472c	48		pha		                PHA
.1a472d	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a4730	e2 20		sep #$20	            SEP #$20
.1a4732	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a4734	c9 2c		cmp #$2c	                CMP #','
.1a4736	f0 03		beq $1a473b	                BEQ skip_comma2
.1a4738	4c 70 47	jmp $1a4770	                JMP syntax_err
.1a473b					skip_comma2
.1a473b	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a473e	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4741	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a4744	c2 20		rep #$20	            REP #$20
.1a4746	a5 23		lda $0823	            LDA ARGUMENT1
.1a4748	85 8f		sta $088f	            STA MCOUNT
.1a474a	e2 20		sep #$20	            SEP #$20
.1a474c	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a474e	85 91		sta $0891	            STA MCOUNT+2
.1a4750	c2 20		rep #$20	            REP #$20
.1a4752	68		pla		                PLA                         ; Restore index
.1a4753	85 29		sta $0829	                STA ARGUMENT2               ; ... to ARGUMENT2
.1a4755	a9 00 00	lda #$0000	                LDA #0
.1a4758	85 2b		sta $082b	                STA ARGUMENT2+2
.1a475a	68		pla		                PLA                         ; Restore string
.1a475b	85 23		sta $0823	                STA ARGUMENT1               ; ... to ARGUMENT1
.1a475d	68		pla		                PLA
.1a475e	85 25		sta $0825	                STA ARGUMENT1+2
.1a4760	e2 20		sep #$20	            SEP #$20
.1a4762	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a4764	85 27		sta $0827	            STA ARGTYPE1
.1a4766	20 19 17	jsr $1a1719	            JSR STRSUBSTR
.1a4769					done
.1a4769	e2 20		sep #$20	            SEP #$20
.1a476b	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a476e	28		plp		                PLP
.1a476f	60		rts		            RTS
.1a4770					syntax_err
.1a4770	08		php		            PHP
.1a4771	c2 20		rep #$20	            REP #$20
.1a4773	48		pha		            PHA
.1a4774	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4777	5b		tcd		            TCD
.1a4778	68		pla		            PLA
.1a4779	28		plp		            PLP
.1a477a	e2 20		sep #$20	            SEP #$20
.1a477c	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a477e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4782	c2 20		rep #$20	            REP #$20
.1a4784	29 ff 00	and #$00ff	            AND #$00FF
.1a4787	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a478a	e2 20		sep #$20	            SEP #$20
.1a478c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a478f					range_err
.1a478f	08		php		            PHP
.1a4790	c2 20		rep #$20	            REP #$20
.1a4792	48		pha		            PHA
.1a4793	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4796	5b		tcd		            TCD
.1a4797	68		pla		            PLA
.1a4798	28		plp		            PLP
.1a4799	e2 20		sep #$20	            SEP #$20
.1a479b	a9 09		lda #$09	            LDA #ERR_RANGE
.1a479d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a47a1	c2 20		rep #$20	            REP #$20
.1a47a3	29 ff 00	and #$00ff	            AND #$00FF
.1a47a6	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a47a9	e2 20		sep #$20	            SEP #$20
.1a47ab	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a47ae					FN_RIGHT
.1a47ae	e2 20		sep #$20	            SEP #$20
.1a47b0	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a47b2	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a47b5	08		php		                PHP
.1a47b6	c2 30		rep #$30	            REP #$30
.1a47b8	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a47bb	e2 20		sep #$20	            SEP #$20
.1a47bd	a5 27		lda $0827	                LDA ARGTYPE1
.1a47bf	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a47c1	f0 03		beq $1a47c6	                BEQ save_string
.1a47c3	4c 32 48	jmp $1a4832	                JMP type_mismatch           ; Type mismatch if it's not a string
.1a47c6					save_string
.1a47c6	c2 20		rep #$20	            REP #$20
.1a47c8	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.1a47ca	48		pha		                PHA
.1a47cb	a5 23		lda $0823	                LDA ARGUMENT1
.1a47cd	48		pha		                PHA
.1a47ce	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a47d1	e2 20		sep #$20	            SEP #$20
.1a47d3	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a47d5	c9 2c		cmp #$2c	                CMP #','
.1a47d7	f0 03		beq $1a47dc	                BEQ skip_comma
.1a47d9	4c 51 48	jmp $1a4851	                JMP syntax_err
.1a47dc					skip_comma
.1a47dc	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a47df	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a47e2	e2 20		sep #$20	            SEP #$20
.1a47e4	a5 27		lda $0827	                LDA ARGTYPE1
.1a47e6	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a47e8	d0 48		bne $1a4832	                BNE type_mismatch           ; Type mismatch if it's not an integer
.1a47ea	c2 20		rep #$20	            REP #$20
.1a47ec	a5 23		lda $0823	            LDA ARGUMENT1
.1a47ee	85 8f		sta $088f	            STA MCOUNT
.1a47f0	c2 20		rep #$20	            REP #$20
.1a47f2	68		pla		                PLA                         ; Recover the string pointer
.1a47f3	85 23		sta $0823	                STA ARGUMENT1
.1a47f5	68		pla		                PLA
.1a47f6	85 25		sta $0825	                STA ARGUMENT1+2
.1a47f8	e2 20		sep #$20	            SEP #$20
.1a47fa	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a47fc	85 27		sta $0827	            STA ARGTYPE1
.1a47fe	e2 20		sep #$20	            SEP #$20
.1a4800	a0 00 00	ldy #$0000	                LDY #0
.1a4803	b7 23		lda [$0823],y	count_loop      LDA [ARGUMENT1],Y
.1a4805	f0 03		beq $1a480a	                BEQ count_done
.1a4807	c8		iny		                INY
.1a4808	80 f9		bra $1a4803	                BRA count_loop
.1a480a					count_done
.1a480a	c2 20		rep #$20	            REP #$20
.1a480c	98		tya		                TYA                         ; ARGUMENT2 := LENGTH - MCOUNT
.1a480d	38		sec		                SEC
.1a480e	e5 8f		sbc $088f	                SBC MCOUNT
.1a4810	30 09		bmi $1a481b	                BMI index0                  ; if ARGUMENT2 < 0, set ARGUMENT2 := 0
.1a4812	85 29		sta $0829	                STA ARGUMENT2
.1a4814	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT2[23..16] := 0
.1a4817	85 2b		sta $082b	                STA ARGUMENT2+2
.1a4819	80 07		bra $1a4822	                BRA slice
.1a481b	a9 00 00	lda #$0000	index0          LDA #0                      ; 0 is the floor for the index
.1a481e	85 29		sta $0829	                STA ARGUMENT2
.1a4820	85 2b		sta $082b	                STA ARGUMENT2+2
.1a4822					slice
.1a4822	e2 20		sep #$20	            SEP #$20
.1a4824	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a4826	85 2d		sta $082d	            STA ARGTYPE2
.1a4828	20 19 17	jsr $1a1719	            JSR STRSUBSTR
.1a482b					done
.1a482b	e2 20		sep #$20	            SEP #$20
.1a482d	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4830	28		plp		                PLP
.1a4831	60		rts		            RTS
.1a4832					type_mismatch
.1a4832	08		php		            PHP
.1a4833	c2 20		rep #$20	            REP #$20
.1a4835	48		pha		            PHA
.1a4836	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4839	5b		tcd		            TCD
.1a483a	68		pla		            PLA
.1a483b	28		plp		            PLP
.1a483c	e2 20		sep #$20	            SEP #$20
.1a483e	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4840	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4844	c2 20		rep #$20	            REP #$20
.1a4846	29 ff 00	and #$00ff	            AND #$00FF
.1a4849	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a484c	e2 20		sep #$20	            SEP #$20
.1a484e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4851					syntax_err
.1a4851	08		php		            PHP
.1a4852	c2 20		rep #$20	            REP #$20
.1a4854	48		pha		            PHA
.1a4855	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4858	5b		tcd		            TCD
.1a4859	68		pla		            PLA
.1a485a	28		plp		            PLP
.1a485b	e2 20		sep #$20	            SEP #$20
.1a485d	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a485f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4863	c2 20		rep #$20	            REP #$20
.1a4865	29 ff 00	and #$00ff	            AND #$00FF
.1a4868	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a486b	e2 20		sep #$20	            SEP #$20
.1a486d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4870					range_err
.1a4870	08		php		            PHP
.1a4871	c2 20		rep #$20	            REP #$20
.1a4873	48		pha		            PHA
.1a4874	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4877	5b		tcd		            TCD
.1a4878	68		pla		            PLA
.1a4879	28		plp		            PLP
.1a487a	e2 20		sep #$20	            SEP #$20
.1a487c	a9 09		lda #$09	            LDA #ERR_RANGE
.1a487e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4882	c2 20		rep #$20	            REP #$20
.1a4884	29 ff 00	and #$00ff	            AND #$00FF
.1a4887	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a488a	e2 20		sep #$20	            SEP #$20
.1a488c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a488f					FN_LEFT
.1a488f	e2 20		sep #$20	            SEP #$20
.1a4891	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4893	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4896	08		php		                PHP
.1a4897	c2 30		rep #$30	            REP #$30
.1a4899	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a489c	e2 20		sep #$20	            SEP #$20
.1a489e	a5 27		lda $0827	                LDA ARGTYPE1
.1a48a0	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a48a2	f0 03		beq $1a48a7	                BEQ save_string
.1a48a4	4c fb 48	jmp $1a48fb	                JMP type_mismatch           ; Type mismatch if it's not a string
.1a48a7					save_string
.1a48a7	c2 20		rep #$20	            REP #$20
.1a48a9	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.1a48ab	48		pha		                PHA
.1a48ac	a5 23		lda $0823	                LDA ARGUMENT1
.1a48ae	48		pha		                PHA
.1a48af	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a48b2	e2 20		sep #$20	            SEP #$20
.1a48b4	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a48b6	c9 2c		cmp #$2c	                CMP #','
.1a48b8	f0 03		beq $1a48bd	                BEQ skip_comma
.1a48ba	4c 1a 49	jmp $1a491a	                JMP syntax_err
.1a48bd					skip_comma
.1a48bd	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a48c0	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a48c3	e2 20		sep #$20	            SEP #$20
.1a48c5	a5 27		lda $0827	                LDA ARGTYPE1
.1a48c7	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a48c9	d0 30		bne $1a48fb	                BNE type_mismatch           ; Type mismatch if it's not an integer
.1a48cb	c2 20		rep #$20	            REP #$20
.1a48cd	a5 23		lda $0823	            LDA ARGUMENT1
.1a48cf	85 8f		sta $088f	            STA MCOUNT
.1a48d1	c2 20		rep #$20	            REP #$20
.1a48d3	a9 00 00	lda #$0000	            LDA #<>0
.1a48d6	85 29		sta $0829	            STA ARGUMENT2
.1a48d8	a9 00 00	lda #$0000	            LDA #(0 >> 16)
.1a48db	85 2b		sta $082b	            STA ARGUMENT2+2
.1a48dd	e2 20		sep #$20	            SEP #$20
.1a48df	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a48e1	85 2d		sta $082d	            STA ARGTYPE2
.1a48e3	c2 20		rep #$20	            REP #$20
.1a48e5	68		pla		                PLA                         ; Recover the string pointer
.1a48e6	85 23		sta $0823	                STA ARGUMENT1
.1a48e8	68		pla		                PLA
.1a48e9	85 25		sta $0825	                STA ARGUMENT1+2
.1a48eb	e2 20		sep #$20	            SEP #$20
.1a48ed	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a48ef	85 27		sta $0827	            STA ARGTYPE1
.1a48f1	20 19 17	jsr $1a1719	            JSR STRSUBSTR
.1a48f4					done
.1a48f4	e2 20		sep #$20	            SEP #$20
.1a48f6	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a48f9	28		plp		                PLP
.1a48fa	60		rts		            RTS
.1a48fb					type_mismatch
.1a48fb	08		php		            PHP
.1a48fc	c2 20		rep #$20	            REP #$20
.1a48fe	48		pha		            PHA
.1a48ff	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4902	5b		tcd		            TCD
.1a4903	68		pla		            PLA
.1a4904	28		plp		            PLP
.1a4905	e2 20		sep #$20	            SEP #$20
.1a4907	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4909	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a490d	c2 20		rep #$20	            REP #$20
.1a490f	29 ff 00	and #$00ff	            AND #$00FF
.1a4912	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4915	e2 20		sep #$20	            SEP #$20
.1a4917	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a491a					syntax_err
.1a491a	08		php		            PHP
.1a491b	c2 20		rep #$20	            REP #$20
.1a491d	48		pha		            PHA
.1a491e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4921	5b		tcd		            TCD
.1a4922	68		pla		            PLA
.1a4923	28		plp		            PLP
.1a4924	e2 20		sep #$20	            SEP #$20
.1a4926	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4928	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a492c	c2 20		rep #$20	            REP #$20
.1a492e	29 ff 00	and #$00ff	            AND #$00FF
.1a4931	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4934	e2 20		sep #$20	            SEP #$20
.1a4936	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4939					range_err
.1a4939	08		php		            PHP
.1a493a	c2 20		rep #$20	            REP #$20
.1a493c	48		pha		            PHA
.1a493d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4940	5b		tcd		            TCD
.1a4941	68		pla		            PLA
.1a4942	28		plp		            PLP
.1a4943	e2 20		sep #$20	            SEP #$20
.1a4945	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4947	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a494b	c2 20		rep #$20	            REP #$20
.1a494d	29 ff 00	and #$00ff	            AND #$00FF
.1a4950	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4953	e2 20		sep #$20	            SEP #$20
.1a4955	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4958					FN_VAL
.1a4958	e2 20		sep #$20	            SEP #$20
.1a495a	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a495c	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a495f	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4962	c2 10		rep #$10	            REP #$10
.1a4964	e2 20		sep #$20	            SEP #$20
.1a4966	a5 27		lda $0827	                LDA ARGTYPE1
.1a4968	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a496a	d0 23		bne $1a498f	                BNE type_mismatch
.1a496c	c2 20		rep #$20	            REP #$20
.1a496e	a5 00		lda $0800	                LDA BIP             ; preserve BIP for later
.1a4970	85 40		sta $0840	                STA SAVEBIP
.1a4972	a5 02		lda $0802	                LDA BIP+2
.1a4974	85 42		sta $0842	                STA SAVEBIP+2
.1a4976	a5 23		lda $0823	                LDA ARGUMENT1       ; Temporarily point BIP to the string to parse
.1a4978	85 00		sta $0800	                STA BIP
.1a497a	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a497c	85 02		sta $0802	                STA BIP+2
.1a497e	20 9d 08	jsr $1a089d	            JSR PARSEINT
.1a4981	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.1a4983	85 00		sta $0800	                STA BIP
.1a4985	a5 42		lda $0842	                LDA SAVEBIP+2
.1a4987	85 02		sta $0802	                STA BIP+2
.1a4989	e2 20		sep #$20	            SEP #$20
.1a498b	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a498e	60		rts		            RTS
.1a498f					type_mismatch
.1a498f	08		php		            PHP
.1a4990	c2 20		rep #$20	            REP #$20
.1a4992	48		pha		            PHA
.1a4993	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4996	5b		tcd		            TCD
.1a4997	68		pla		            PLA
.1a4998	28		plp		            PLP
.1a4999	e2 20		sep #$20	            SEP #$20
.1a499b	a9 04		lda #$04	            LDA #ERR_TYPE
.1a499d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a49a1	c2 20		rep #$20	            REP #$20
.1a49a3	29 ff 00	and #$00ff	            AND #$00FF
.1a49a6	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a49a9	e2 20		sep #$20	            SEP #$20
.1a49ab	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a49ae					FN_STR
.1a49ae	e2 20		sep #$20	            SEP #$20
.1a49b0	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a49b2	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a49b5	08		php		                PHP
.1a49b6	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a49b9	c2 10		rep #$10	            REP #$10
.1a49bb	e2 20		sep #$20	            SEP #$20
.1a49bd	a5 27		lda $0827	                LDA ARGTYPE1
.1a49bf	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a49c1	d0 1a		bne $1a49dd	                BNE type_mismatch
.1a49c3	20 20 15	jsr $1a1520	            JSR ITOS
.1a49c6	c2 20		rep #$20	            REP #$20
.1a49c8	a5 16		lda $0816	                LDA STRPTR          ; Prepare the return result
.1a49ca	85 23		sta $0823	                STA ARGUMENT1
.1a49cc	a5 18		lda $0818	                LDA STRPTR+2
.1a49ce	85 25		sta $0825	                STA ARGUMENT1+2
.1a49d0	e2 20		sep #$20	            SEP #$20
.1a49d2	a9 02		lda #$02	                LDA #TYPE_STRING
.1a49d4	85 27		sta $0827	                STA ARGTYPE1
.1a49d6	28		plp		                PLP
.1a49d7	e2 20		sep #$20	            SEP #$20
.1a49d9	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a49dc	60		rts		            RTS
.1a49dd					type_mismatch
.1a49dd	08		php		            PHP
.1a49de	c2 20		rep #$20	            REP #$20
.1a49e0	48		pha		            PHA
.1a49e1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a49e4	5b		tcd		            TCD
.1a49e5	68		pla		            PLA
.1a49e6	28		plp		            PLP
.1a49e7	e2 20		sep #$20	            SEP #$20
.1a49e9	a9 04		lda #$04	            LDA #ERR_TYPE
.1a49eb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a49ef	c2 20		rep #$20	            REP #$20
.1a49f1	29 ff 00	and #$00ff	            AND #$00FF
.1a49f4	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a49f7	e2 20		sep #$20	            SEP #$20
.1a49f9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a49fc					FN_DEC
.1a49fc	e2 20		sep #$20	            SEP #$20
.1a49fe	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4a00	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4a03	08		php		                PHP
.1a4a04	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4a07	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a4a0a	c2 20		rep #$20	            REP #$20
.1a4a0c	64 0c		stz $080c	                STZ SCRATCH
.1a4a0e	64 0e		stz $080e	                STZ SCRATCH+2
.1a4a10	e2 30		sep #$30	            SEP #$30
.1a4a12	a0 00		ldy #$00	                LDY #0
.1a4a14	b7 23		lda [$0823],y	skip_loop       LDA [ARGUMENT1],Y
.1a4a16	c9 20		cmp #$20	                CMP #CHAR_SP
.1a4a18	f0 04		beq $1a4a1e	                BEQ skip_char
.1a4a1a	c9 24		cmp #$24	                CMP #'$'
.1a4a1c	d0 03		bne $1a4a21	                BNE loop
.1a4a1e	c8		iny		skip_char       INY
.1a4a1f	80 f3		bra $1a4a14	                BRA skip_loop
.1a4a21	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y   ; Check the character
.1a4a23	20 d1 04	jsr $1a04d1	            JSR ISHEX
.1a4a26	90 1e		bcc $1a4a46	                BCC ret_result      ; No: return what we have so far
.1a4a28	c2 20		rep #$20	            REP #$20
.1a4a2a	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a4a2c	26 0e		rol $080e	                ROL SCRATCH+2
.1a4a2e	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a4a30	26 0e		rol $080e	                ROL SCRATCH+2
.1a4a32	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a4a34	26 0e		rol $080e	                ROL SCRATCH+2
.1a4a36	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a4a38	26 0e		rol $080e	                ROL SCRATCH+2
.1a4a3a	e2 20		sep #$20	            SEP #$20
.1a4a3c	20 f2 04	jsr $1a04f2	            JSR HEX2BIN
.1a4a3f	05 0c		ora $080c	                ORA SCRATCH
.1a4a41	85 0c		sta $080c	                STA SCRATCH         ; And add it to the result
.1a4a43	c8		iny		                INY
.1a4a44	80 db		bra $1a4a21	                BRA loop            ; And try the next character
.1a4a46					ret_result
.1a4a46	c2 20		rep #$20	            REP #$20
.1a4a48	a5 0c		lda $080c	                LDA SCRATCH         ; Return the result
.1a4a4a	85 23		sta $0823	                STA ARGUMENT1
.1a4a4c	a5 0e		lda $080e	                LDA SCRATCH+2
.1a4a4e	85 25		sta $0825	                STA ARGUMENT1+2
.1a4a50	e2 20		sep #$20	            SEP #$20
.1a4a52	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a4a54	85 27		sta $0827	                STA ARGTYPE1
.1a4a56	28		plp		                PLP
.1a4a57	e2 20		sep #$20	            SEP #$20
.1a4a59	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4a5c	60		rts		            RTS
.1a4a5d					FN_HEX
.1a4a5d	e2 20		sep #$20	            SEP #$20
.1a4a5f	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4a61	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4a64	08		php		                PHP
.1a4a65	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4a68	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a4a6b	20 c1 14	jsr $1a14c1	            JSR TEMPSTRING
.1a4a6e	e2 30		sep #$30	            SEP #$30
.1a4a70	a0 ff		ldy #$ff	                LDY #$FF            ; Terminate the string
.1a4a72	a9 00		lda #$00	                LDA #0
.1a4a74	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4a76	88		dey		                DEY
.1a4a77	a5 23		lda $0823	loop            LDA ARGUMENT1       ; Write the low digit
.1a4a79	29 0f		and #$0f	                AND #$0F
.1a4a7b	aa		tax		                TAX
.1a4a7c	bf 00 d0 1a	lda $1ad000,x	                LDA @lHEXDIGITS,X
.1a4a80	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4a82	88		dey		                DEY
.1a4a83	a5 23		lda $0823	                LDA ARGUMENT1       ; Write the high digit
.1a4a85	29 f0		and #$f0	                AND #$F0
.1a4a87	4a		lsr a		                LSR A
.1a4a88	4a		lsr a		                LSR A
.1a4a89	4a		lsr a		                LSR A
.1a4a8a	4a		lsr a		                LSR A
.1a4a8b	aa		tax		                TAX
.1a4a8c	bf 00 d0 1a	lda $1ad000,x	                LDA @lHEXDIGITS,X
.1a4a90	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4a92	88		dey		                DEY
.1a4a93	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Shift value by one byte
.1a4a95	85 23		sta $0823	                STA ARGUMENT1
.1a4a97	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4a99	85 24		sta $0824	                STA ARGUMENT1+1
.1a4a9b	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a4a9d	85 25		sta $0825	                STA ARGUMENT1+2
.1a4a9f	a9 00		lda #$00	                LDA #0
.1a4aa1	85 26		sta $0826	                STA ARGUMENT1+3
.1a4aa3	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the argument 0?
.1a4aa5	d0 d0		bne $1a4a77	                BNE loop            ; No: keep converting
.1a4aa7	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a4aa9	d0 cc		bne $1a4a77	                BNE loop
.1a4aab	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4aad	d0 c8		bne $1a4a77	                BNE loop
.1a4aaf	98		tya		                TYA                 ; Get the index of the first free char
.1a4ab0	38		sec		                SEC                 ; Add 1 to get to the first character of the string
.1a4ab1	65 16		adc $0816	                ADC STRPTR          ; And add the whole thing to the temp string pointer
.1a4ab3	85 23		sta $0823	                STA ARGUMENT1       ; And return it as the result
.1a4ab5	a5 17		lda $0817	                LDA STRPTR+1
.1a4ab7	85 24		sta $0824	                STA ARGUMENT1+1
.1a4ab9	a5 18		lda $0818	                LDA STRPTR+2
.1a4abb	85 25		sta $0825	                STA ARGUMENT1+2
.1a4abd	a5 19		lda $0819	                LDA STRPTR+3
.1a4abf	85 26		sta $0826	                STA ARGUMENT1+3
.1a4ac1	a9 02		lda #$02	                LDA #TYPE_STRING    ; And make the type STRING
.1a4ac3	85 27		sta $0827	                STA ARGTYPE1
.1a4ac5	28		plp		                PLP
.1a4ac6	e2 20		sep #$20	            SEP #$20
.1a4ac8	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4acb	60		rts		            RTS
.1a4acc					type_mismatch
.1a4acc	08		php		            PHP
.1a4acd	c2 20		rep #$20	            REP #$20
.1a4acf	48		pha		            PHA
.1a4ad0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4ad3	5b		tcd		            TCD
.1a4ad4	68		pla		            PLA
.1a4ad5	28		plp		            PLP
.1a4ad6	e2 20		sep #$20	            SEP #$20
.1a4ad8	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4ada	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4ade	c2 20		rep #$20	            REP #$20
.1a4ae0	29 ff 00	and #$00ff	            AND #$00FF
.1a4ae3	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4ae6	e2 20		sep #$20	            SEP #$20
.1a4ae8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4aeb					FN_LEN
.1a4aeb	e2 20		sep #$20	            SEP #$20
.1a4aed	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4aef	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4af2	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4af5	e2 20		sep #$20	            SEP #$20
.1a4af7	a5 27		lda $0827	                LDA ARGTYPE1
.1a4af9	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4afb	d0 1f		bne $1a4b1c	                BNE type_mismatch
.1a4afd	8b		phb		                PHB                 ; Set the data bank to the data bank of the string
.1a4afe	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4b00	48		pha		                PHA
.1a4b01	ab		plb		                PLB
.1a4b02	c2 10		rep #$10	            REP #$10
.1a4b04	a6 23		ldx $0823	                LDX ARGUMENT1       ; And point X to the string data
.1a4b06	20 ad 15	jsr $1a15ad	            JSR STRLEN
.1a4b09	ab		plb		                PLB                 ; Restore the old data bank
.1a4b0a	84 23		sty $0823	                STY ARGUMENT1       ; Save the length to ARGUMENT1
.1a4b0c	c2 20		rep #$20	            REP #$20
.1a4b0e	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4b10	e2 20		sep #$20	            SEP #$20
.1a4b12	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the type to INTEGER
.1a4b14	85 27		sta $0827	                STA ARGTYPE1
.1a4b16	e2 20		sep #$20	            SEP #$20
.1a4b18	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4b1b	60		rts		            RTS
.1a4b1c					type_mismatch
.1a4b1c	08		php		            PHP
.1a4b1d	c2 20		rep #$20	            REP #$20
.1a4b1f	48		pha		            PHA
.1a4b20	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4b23	5b		tcd		            TCD
.1a4b24	68		pla		            PLA
.1a4b25	28		plp		            PLP
.1a4b26	e2 20		sep #$20	            SEP #$20
.1a4b28	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4b2a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4b2e	c2 20		rep #$20	            REP #$20
.1a4b30	29 ff 00	and #$00ff	            AND #$00FF
.1a4b33	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4b36	e2 20		sep #$20	            SEP #$20
.1a4b38	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4b3b					FN_PEEK
.1a4b3b	e2 20		sep #$20	            SEP #$20
.1a4b3d	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4b3f	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4b42	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4b45	e2 20		sep #$20	            SEP #$20
.1a4b47	a5 27		lda $0827	                LDA ARGTYPE1
.1a4b49	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4b4b	d0 33		bne $1a4b80	                BNE type_mismatch
.1a4b4d	a5 25		lda $0825	                LDA ARGUMENT1+2                     ; Check to see if the request is to video memory
.1a4b4f	c9 b0		cmp #$b0	                CMP #`VRAM
.1a4b51	90 1b		bcc $1a4b6e	                BLT simple_peek                     ; No: just do an ordinary PEEK
.1a4b53	c9 f0		cmp #$f0	                CMP #$F0
.1a4b55	b0 17		bcs $1a4b6e	                BGE simple_peek
.1a4b57	e2 20		sep #$20	            SEP #$20
.1a4b59	a7 23		lda [$0823]	                LDA [ARGUMENT1]                     ; Request the data from VRAM
.1a4b5b	c2 20		rep #$20	            REP #$20
.1a4b5d	af 02 09 af	lda $af0902	wait_vram       LDA @l VMEM2CPU_Fifo_Count_LO       ; Wait for the Vicky FIFO to have a byte in it
.1a4b61	89 00 80	bit #$8000	                BIT #$8000
.1a4b64	d0 f7		bne $1a4b5d	                BNE wait_vram
.1a4b66	e2 20		sep #$20	            SEP #$20
.1a4b68	af 01 09 af	lda $af0901	                LDA @l VMEM2CPU_Data_Port           ; Fetch the byte from the Vicky FIFO
.1a4b6c	80 04		bra $1a4b72	                BRA save_result                     ; And return it
.1a4b6e					simple_peek
.1a4b6e	e2 20		sep #$20	            SEP #$20
.1a4b70	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.1a4b72	85 23		sta $0823	save_result     STA ARGUMENT1
.1a4b74	64 24		stz $0824	                STZ ARGUMENT1+1
.1a4b76	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4b78	64 30		stz $0830	                STZ ARGUMENT1+13
.1a4b7a	e2 20		sep #$20	            SEP #$20
.1a4b7c	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4b7f	60		rts		            RTS
.1a4b80					type_mismatch
.1a4b80	08		php		            PHP
.1a4b81	c2 20		rep #$20	            REP #$20
.1a4b83	48		pha		            PHA
.1a4b84	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4b87	5b		tcd		            TCD
.1a4b88	68		pla		            PLA
.1a4b89	28		plp		            PLP
.1a4b8a	e2 20		sep #$20	            SEP #$20
.1a4b8c	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4b8e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4b92	c2 20		rep #$20	            REP #$20
.1a4b94	29 ff 00	and #$00ff	            AND #$00FF
.1a4b97	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4b9a	e2 20		sep #$20	            SEP #$20
.1a4b9c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4b9f					FN_PEEKL
.1a4b9f	e2 20		sep #$20	            SEP #$20
.1a4ba1	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4ba3	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4ba6	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4ba9	e2 20		sep #$20	            SEP #$20
.1a4bab	a5 27		lda $0827	                LDA ARGTYPE1
.1a4bad	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4baf	d0 1d		bne $1a4bce	                BNE type_mismatch
.1a4bb1	c2 20		rep #$20	            REP #$20
.1a4bb3	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.1a4bb5	85 0c		sta $080c	                STA SCRATCH
.1a4bb7	e2 20		sep #$20	            SEP #$20
.1a4bb9	a0 02 00	ldy #$0002	                LDY #2
.1a4bbc	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y
.1a4bbe	85 25		sta $0825	                STA ARGUMENT1+2
.1a4bc0	64 26		stz $0826	                STZ ARGUMENT1+3
.1a4bc2	c2 20		rep #$20	            REP #$20
.1a4bc4	a5 0c		lda $080c	                LDA SCRATCH
.1a4bc6	85 23		sta $0823	                STA ARGUMENT1
.1a4bc8	e2 20		sep #$20	            SEP #$20
.1a4bca	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4bcd	60		rts		            RTS
.1a4bce					type_mismatch
.1a4bce	08		php		            PHP
.1a4bcf	c2 20		rep #$20	            REP #$20
.1a4bd1	48		pha		            PHA
.1a4bd2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4bd5	5b		tcd		            TCD
.1a4bd6	68		pla		            PLA
.1a4bd7	28		plp		            PLP
.1a4bd8	e2 20		sep #$20	            SEP #$20
.1a4bda	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4bdc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4be0	c2 20		rep #$20	            REP #$20
.1a4be2	29 ff 00	and #$00ff	            AND #$00FF
.1a4be5	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4be8	e2 20		sep #$20	            SEP #$20
.1a4bea	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4bed					FN_PEEKW
.1a4bed	e2 20		sep #$20	            SEP #$20
.1a4bef	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4bf1	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4bf4	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4bf7	e2 20		sep #$20	            SEP #$20
.1a4bf9	a5 27		lda $0827	                LDA ARGTYPE1
.1a4bfb	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4bfd	d0 0e		bne $1a4c0d	                BNE type_mismatch
.1a4bff	c2 20		rep #$20	            REP #$20
.1a4c01	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.1a4c03	85 23		sta $0823	                STA ARGUMENT1
.1a4c05	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4c07	e2 20		sep #$20	            SEP #$20
.1a4c09	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4c0c	60		rts		            RTS
.1a4c0d					type_mismatch
.1a4c0d	08		php		            PHP
.1a4c0e	c2 20		rep #$20	            REP #$20
.1a4c10	48		pha		            PHA
.1a4c11	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4c14	5b		tcd		            TCD
.1a4c15	68		pla		            PLA
.1a4c16	28		plp		            PLP
.1a4c17	e2 20		sep #$20	            SEP #$20
.1a4c19	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4c1b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4c1f	c2 20		rep #$20	            REP #$20
.1a4c21	29 ff 00	and #$00ff	            AND #$00FF
.1a4c24	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4c27	e2 20		sep #$20	            SEP #$20
.1a4c29	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4c2c					FN_CHR
.1a4c2c	e2 20		sep #$20	            SEP #$20
.1a4c2e	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4c30	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4c33	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4c36	e2 20		sep #$20	            SEP #$20
.1a4c38	a5 27		lda $0827	                LDA ARGTYPE1
.1a4c3a	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4c3c	d0 24		bne $1a4c62	                BNE type_mismatch
.1a4c3e	20 c1 14	jsr $1a14c1	            JSR TEMPSTRING
.1a4c41	a5 23		lda $0823	                LDA ARGUMENT1       ; Get the numberic value
.1a4c43	87 16		sta [$0816]	                STA [STRPTR]        ; And save it as the first character
.1a4c45	a9 00		lda #$00	                LDA #0              ; Null terminate the string
.1a4c47	a0 01 00	ldy #$0001	                LDY #1
.1a4c4a	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4c4c	c2 20		rep #$20	            REP #$20
.1a4c4e	a5 16		lda $0816	                LDA STRPTR
.1a4c50	85 23		sta $0823	                STA ARGUMENT1
.1a4c52	a5 18		lda $0818	                LDA STRPTR+2
.1a4c54	85 25		sta $0825	                STA ARGUMENT1+2
.1a4c56	e2 20		sep #$20	            SEP #$20
.1a4c58	a9 02		lda #$02	                LDA #TYPE_STRING
.1a4c5a	85 27		sta $0827	                STA ARGTYPE1
.1a4c5c	e2 20		sep #$20	            SEP #$20
.1a4c5e	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4c61	60		rts		            RTS
.1a4c62					type_mismatch
.1a4c62	08		php		            PHP
.1a4c63	c2 20		rep #$20	            REP #$20
.1a4c65	48		pha		            PHA
.1a4c66	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4c69	5b		tcd		            TCD
.1a4c6a	68		pla		            PLA
.1a4c6b	28		plp		            PLP
.1a4c6c	e2 20		sep #$20	            SEP #$20
.1a4c6e	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4c70	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4c74	c2 20		rep #$20	            REP #$20
.1a4c76	29 ff 00	and #$00ff	            AND #$00FF
.1a4c79	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4c7c	e2 20		sep #$20	            SEP #$20
.1a4c7e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4c81					FN_ASC
.1a4c81	e2 20		sep #$20	            SEP #$20
.1a4c83	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4c85	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4c88	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4c8b	e2 20		sep #$20	            SEP #$20
.1a4c8d	a5 27		lda $0827	                LDA ARGTYPE1
.1a4c8f	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4c91	d0 14		bne $1a4ca7	                BNE type_mismatch
.1a4c93	a7 23		lda [$0823]	                LDA [ARGUMENT1]     ; Get the character
.1a4c95	85 23		sta $0823	                STA ARGUMENT1       ; Save its code to ARGUMENT1
.1a4c97	64 24		stz $0824	                STZ ARGUMENT1+1
.1a4c99	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4c9b	64 26		stz $0826	                STZ ARGUMENT1+3
.1a4c9d	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the return type to integer
.1a4c9f	85 27		sta $0827	                STA ARGTYPE1
.1a4ca1	e2 20		sep #$20	            SEP #$20
.1a4ca3	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4ca6	60		rts		            RTS
.1a4ca7					type_mismatch
.1a4ca7	08		php		            PHP
.1a4ca8	c2 20		rep #$20	            REP #$20
.1a4caa	48		pha		            PHA
.1a4cab	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4cae	5b		tcd		            TCD
.1a4caf	68		pla		            PLA
.1a4cb0	28		plp		            PLP
.1a4cb1	e2 20		sep #$20	            SEP #$20
.1a4cb3	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4cb5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4cb9	c2 20		rep #$20	            REP #$20
.1a4cbb	29 ff 00	and #$00ff	            AND #$00FF
.1a4cbe	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4cc1	e2 20		sep #$20	            SEP #$20
.1a4cc3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4cc6					FN_SPC
.1a4cc6	e2 20		sep #$20	            SEP #$20
.1a4cc8	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4cca	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4ccd	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4cd0	e2 20		sep #$20	            SEP #$20
.1a4cd2	a5 27		lda $0827	                LDA ARGTYPE1
.1a4cd4	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4cd6	d0 39		bne $1a4d11	                BNE type_mismatch
.1a4cd8	e2 20		sep #$20	            SEP #$20
.1a4cda	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.1a4cdc	d0 52		bne $1a4d30	                BNE err_limit
.1a4cde	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4ce0	d0 4e		bne $1a4d30	                BNE err_limit
.1a4ce2	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a4ce4	d0 4a		bne $1a4d30	                BNE err_limit
.1a4ce6	c2 10		rep #$10	            REP #$10
.1a4ce8	20 c1 14	jsr $1a14c1	            JSR TEMPSTRING
.1a4ceb	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.1a4ced	e2 20		sep #$20	            SEP #$20
.1a4cef	a9 00		lda #$00	                LDA #0
.1a4cf1	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.1a4cf3	88		dey		                DEY
.1a4cf4	30 07		bmi $1a4cfd	                BMI done
.1a4cf6	a9 20		lda #$20	                LDA #CHAR_SP
.1a4cf8	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.1a4cfa	88		dey		                DEY
.1a4cfb	10 fb		bpl $1a4cf8	                BPL loop            ; And keep writing until we're done
.1a4cfd	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.1a4cff	85 27		sta $0827	                STA ARGTYPE1
.1a4d01	c2 20		rep #$20	            REP #$20
.1a4d03	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.1a4d05	85 23		sta $0823	                STA ARGUMENT1
.1a4d07	a5 18		lda $0818	                LDA STRPTR+2
.1a4d09	85 25		sta $0825	                STA ARGUMENT1+2
.1a4d0b	e2 20		sep #$20	            SEP #$20
.1a4d0d	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4d10	60		rts		            RTS
.1a4d11					type_mismatch
.1a4d11	08		php		            PHP
.1a4d12	c2 20		rep #$20	            REP #$20
.1a4d14	48		pha		            PHA
.1a4d15	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4d18	5b		tcd		            TCD
.1a4d19	68		pla		            PLA
.1a4d1a	28		plp		            PLP
.1a4d1b	e2 20		sep #$20	            SEP #$20
.1a4d1d	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4d1f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4d23	c2 20		rep #$20	            REP #$20
.1a4d25	29 ff 00	and #$00ff	            AND #$00FF
.1a4d28	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4d2b	e2 20		sep #$20	            SEP #$20
.1a4d2d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4d30					err_limit
.1a4d30	08		php		            PHP
.1a4d31	c2 20		rep #$20	            REP #$20
.1a4d33	48		pha		            PHA
.1a4d34	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4d37	5b		tcd		            TCD
.1a4d38	68		pla		            PLA
.1a4d39	28		plp		            PLP
.1a4d3a	e2 20		sep #$20	            SEP #$20
.1a4d3c	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4d3e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4d42	c2 20		rep #$20	            REP #$20
.1a4d44	29 ff 00	and #$00ff	            AND #$00FF
.1a4d47	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4d4a	e2 20		sep #$20	            SEP #$20
.1a4d4c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4d4f					FN_TAB
.1a4d4f	e2 20		sep #$20	            SEP #$20
.1a4d51	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4d53	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4d56	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4d59	e2 20		sep #$20	            SEP #$20
.1a4d5b	a5 27		lda $0827	                LDA ARGTYPE1
.1a4d5d	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4d5f	d0 39		bne $1a4d9a	                BNE type_mismatch
.1a4d61	e2 20		sep #$20	            SEP #$20
.1a4d63	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.1a4d65	d0 52		bne $1a4db9	                BNE err_limit
.1a4d67	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4d69	d0 4e		bne $1a4db9	                BNE err_limit
.1a4d6b	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a4d6d	d0 4a		bne $1a4db9	                BNE err_limit
.1a4d6f	c2 10		rep #$10	            REP #$10
.1a4d71	20 c1 14	jsr $1a14c1	            JSR TEMPSTRING
.1a4d74	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.1a4d76	e2 20		sep #$20	            SEP #$20
.1a4d78	a9 00		lda #$00	                LDA #0
.1a4d7a	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.1a4d7c	88		dey		                DEY
.1a4d7d	30 07		bmi $1a4d86	                BMI done
.1a4d7f	a9 09		lda #$09	                LDA #CHAR_TAB
.1a4d81	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.1a4d83	88		dey		                DEY
.1a4d84	10 fb		bpl $1a4d81	                BPL loop            ; And keep writing until we're done
.1a4d86	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.1a4d88	85 27		sta $0827	                STA ARGTYPE1
.1a4d8a	c2 20		rep #$20	            REP #$20
.1a4d8c	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.1a4d8e	85 23		sta $0823	                STA ARGUMENT1
.1a4d90	a5 18		lda $0818	                LDA STRPTR+2
.1a4d92	85 25		sta $0825	                STA ARGUMENT1+2
.1a4d94	e2 20		sep #$20	            SEP #$20
.1a4d96	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4d99	60		rts		            RTS
.1a4d9a					type_mismatch
.1a4d9a	08		php		            PHP
.1a4d9b	c2 20		rep #$20	            REP #$20
.1a4d9d	48		pha		            PHA
.1a4d9e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4da1	5b		tcd		            TCD
.1a4da2	68		pla		            PLA
.1a4da3	28		plp		            PLP
.1a4da4	e2 20		sep #$20	            SEP #$20
.1a4da6	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4da8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4dac	c2 20		rep #$20	            REP #$20
.1a4dae	29 ff 00	and #$00ff	            AND #$00FF
.1a4db1	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4db4	e2 20		sep #$20	            SEP #$20
.1a4db6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4db9					err_limit
.1a4db9	08		php		            PHP
.1a4dba	c2 20		rep #$20	            REP #$20
.1a4dbc	48		pha		            PHA
.1a4dbd	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4dc0	5b		tcd		            TCD
.1a4dc1	68		pla		            PLA
.1a4dc2	28		plp		            PLP
.1a4dc3	e2 20		sep #$20	            SEP #$20
.1a4dc5	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4dc7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4dcb	c2 20		rep #$20	            REP #$20
.1a4dcd	29 ff 00	and #$00ff	            AND #$00FF
.1a4dd0	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4dd3	e2 20		sep #$20	            SEP #$20
.1a4dd5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4dd8					FN_ABS
.1a4dd8	e2 20		sep #$20	            SEP #$20
.1a4dda	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4ddc	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4ddf	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4de2	e2 20		sep #$20	            SEP #$20
.1a4de4	a5 27		lda $0827	                LDA ARGTYPE1        ; Check the type
.1a4de6	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4de8	f0 23		beq $1a4e0d	                BEQ abs_int         ; If integer, get the absolute value of the integer
.1a4dea	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.1a4dec	f0 3e		beq $1a4e2c	                BEQ abs_float       ; If float, get the absolute value of the float
.1a4dee					type_err
.1a4dee	08		php		            PHP
.1a4def	c2 20		rep #$20	            REP #$20
.1a4df1	48		pha		            PHA
.1a4df2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4df5	5b		tcd		            TCD
.1a4df6	68		pla		            PLA
.1a4df7	28		plp		            PLP
.1a4df8	e2 20		sep #$20	            SEP #$20
.1a4dfa	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4dfc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4e00	c2 20		rep #$20	            REP #$20
.1a4e02	29 ff 00	and #$00ff	            AND #$00FF
.1a4e05	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4e08	e2 20		sep #$20	            SEP #$20
.1a4e0a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4e0d					abs_int
.1a4e0d	c2 20		rep #$20	            REP #$20
.1a4e0f	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Is it positive already?
.1a4e11	10 21		bpl $1a4e34	                BPL done            ; Yes: we don't need to do anythign further
.1a4e13	49 ff ff	eor #$ffff	                EOR #$FFFF          ; Otherwise, take the two's compliment
.1a4e16	85 25		sta $0825	                STA ARGUMENT1+2     ; Of ARGUMENT1
.1a4e18	a5 23		lda $0823	                LDA ARGUMENT1
.1a4e1a	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a4e1d	18		clc		                CLC
.1a4e1e	69 01 00	adc #$0001	                ADC #1
.1a4e21	85 23		sta $0823	                STA ARGUMENT1       ; And save it back to ARGUMENT1
.1a4e23	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4e25	69 00 00	adc #$0000	                ADC #0
.1a4e28	85 25		sta $0825	                STA ARGUMENT1+2
.1a4e2a	80 08		bra $1a4e34	                BRA done
.1a4e2c					abs_float
.1a4e2c	e2 20		sep #$20	            SEP #$20
.1a4e2e	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Just clear the sign bit
.1a4e30	29 7f		and #$7f	                AND #$7F
.1a4e32	85 26		sta $0826	                STA ARGUMENT1+3
.1a4e34					done
.1a4e34	e2 20		sep #$20	            SEP #$20
.1a4e36	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4e39	60		rts		            RTS
.1a4e3a					FN_SGN
.1a4e3a	e2 20		sep #$20	            SEP #$20
.1a4e3c	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4e3e	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4e41	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4e44	e2 20		sep #$20	            SEP #$20
.1a4e46	a5 27		lda $0827	                LDA ARGTYPE1
.1a4e48	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4e4a	d0 25		bne $1a4e71	                BNE type_mismatch
.1a4e4c	c2 20		rep #$20	            REP #$20
.1a4e4e	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4e50	30 12		bmi $1a4e64	                BMI is_negative     ; Negative: return -1
.1a4e52	d0 04		bne $1a4e58	                BNE is_positive     ; Is it not 0? Then return 1
.1a4e54	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the lower word 0?
.1a4e56	f0 13		beq $1a4e6b	                BEQ done            ; Yes: the whole thing is zero: return 0
.1a4e58	a9 00 00	lda #$0000	is_positive     LDA #0              ; It's positive: return 1
.1a4e5b	85 25		sta $0825	                STA ARGUMENT1+2
.1a4e5d	a9 01 00	lda #$0001	                LDA #1
.1a4e60	85 23		sta $0823	                STA ARGUMENT1
.1a4e62	80 07		bra $1a4e6b	                BRA done
.1a4e64	a9 ff ff	lda #$ffff	is_negative     LDA #$FFFF          ; It's negative: return -1
.1a4e67	85 25		sta $0825	                STA ARGUMENT1+2
.1a4e69	85 23		sta $0823	                STA ARGUMENT1
.1a4e6b					done
.1a4e6b	e2 20		sep #$20	            SEP #$20
.1a4e6d	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4e70	60		rts		            RTS
.1a4e71					type_mismatch
.1a4e71	08		php		            PHP
.1a4e72	c2 20		rep #$20	            REP #$20
.1a4e74	48		pha		            PHA
.1a4e75	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4e78	5b		tcd		            TCD
.1a4e79	68		pla		            PLA
.1a4e7a	28		plp		            PLP
.1a4e7b	e2 20		sep #$20	            SEP #$20
.1a4e7d	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4e7f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4e83	c2 20		rep #$20	            REP #$20
.1a4e85	29 ff 00	and #$00ff	            AND #$00FF
.1a4e88	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a4e8b	e2 20		sep #$20	            SEP #$20
.1a4e8d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4e90					FN_INT
.1a4e90	e2 20		sep #$20	            SEP #$20
.1a4e92	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4e94	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4e97	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4e9a	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a4e9d					done
.1a4e9d	e2 20		sep #$20	            SEP #$20
.1a4e9f	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4ea2	60		rts		            RTS
.1a4ea3					FN_SIN
.1a4ea3	e2 20		sep #$20	            SEP #$20
.1a4ea5	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4ea7	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4eaa	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4ead	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a4eb0	20 61 61	jsr $1a6161	            JSR FP_SIN
.1a4eb3					done
.1a4eb3	e2 20		sep #$20	            SEP #$20
.1a4eb5	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4eb8	60		rts		            RTS
.1a4eb9					FN_COS
.1a4eb9	e2 20		sep #$20	            SEP #$20
.1a4ebb	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4ebd	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4ec0	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4ec3	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a4ec6	20 90 61	jsr $1a6190	            JSR FP_COS
.1a4ec9					done
.1a4ec9	e2 20		sep #$20	            SEP #$20
.1a4ecb	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4ece	60		rts		            RTS
.1a4ecf					FN_TAN
.1a4ecf	e2 20		sep #$20	            SEP #$20
.1a4ed1	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4ed3	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4ed6	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4ed9	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a4edc	20 bf 61	jsr $1a61bf	            JSR FP_TAN
.1a4edf					done
.1a4edf	e2 20		sep #$20	            SEP #$20
.1a4ee1	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4ee4	60		rts		            RTS
.1a4ee5					FN_LN
.1a4ee5	e2 20		sep #$20	            SEP #$20
.1a4ee7	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4ee9	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4eec	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4eef	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a4ef2	20 ed 61	jsr $1a61ed	            JSR FP_LN
.1a4ef5					done
.1a4ef5	e2 20		sep #$20	            SEP #$20
.1a4ef7	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4efa	60		rts		            RTS
.1a4efb					FN_ACOS
.1a4efb	e2 20		sep #$20	            SEP #$20
.1a4efd	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4eff	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4f02	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4f05	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a4f08	20 16 63	jsr $1a6316	            JSR FP_ACOS
.1a4f0b					done
.1a4f0b	e2 20		sep #$20	            SEP #$20
.1a4f0d	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4f10	60		rts		            RTS
.1a4f11					FN_ASIN
.1a4f11	e2 20		sep #$20	            SEP #$20
.1a4f13	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4f15	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4f18	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4f1b	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a4f1e	20 ec 62	jsr $1a62ec	            JSR FP_ASIN
.1a4f21					done
.1a4f21	e2 20		sep #$20	            SEP #$20
.1a4f23	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4f26	60		rts		            RTS
.1a4f27					FN_ATAN
.1a4f27	e2 20		sep #$20	            SEP #$20
.1a4f29	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4f2b	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4f2e	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4f31	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a4f34	20 38 63	jsr $1a6338	            JSR FP_ATAN
.1a4f37					done
.1a4f37	e2 20		sep #$20	            SEP #$20
.1a4f39	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4f3c	60		rts		            RTS
.1a4f3d					FN_EXP
.1a4f3d	e2 20		sep #$20	            SEP #$20
.1a4f3f	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4f41	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4f44	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4f47	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a4f4a	20 cc 63	jsr $1a63cc	            JSR FP_EXP
.1a4f4d					done
.1a4f4d	e2 20		sep #$20	            SEP #$20
.1a4f4f	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4f52	60		rts		            RTS
.1a4f53					FN_SQR
.1a4f53	e2 20		sep #$20	            SEP #$20
.1a4f55	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4f57	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4f5a	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a4f5d	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a4f60	20 4e 64	jsr $1a644e	            JSR FP_SQR
.1a4f63					done
.1a4f63	e2 20		sep #$20	            SEP #$20
.1a4f65	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a4f68	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\commands.s

.1a4f69	00		brk #		CMD_MONITOR     BRK
.1a4f6a	ea		nop		                NOP
.1a4f6b	60		rts		            RTS
.1a4f6c					CMD_NEW
.1a4f6c	08		php		                PHP
.1a4f6d	0b		phd		                PHD
.1a4f6e	08		php		            PHP
.1a4f6f	c2 20		rep #$20	            REP #$20
.1a4f71	48		pha		            PHA
.1a4f72	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a4f75	5b		tcd		            TCD
.1a4f76	68		pla		            PLA
.1a4f77	28		plp		            PLP
.1a4f78	c2 30		rep #$30	            REP #$30
.1a4f7a	c2 20		rep #$20	            REP #$20
.1a4f7c	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.1a4f7f	85 d9		sta $08d9	            STA LASTLINE
.1a4f81	e2 20		sep #$20	            SEP #$20
.1a4f83	a9 16		lda #$16	            LDA #`BASIC_BOT
.1a4f85	85 db		sta $08db	            STA LASTLINE+2
.1a4f87	c2 30		rep #$30	            REP #$30
.1a4f89	a9 00 00	lda #$0000	                LDA #0
.1a4f8c	a0 00 00	ldy #$0000	                LDY #LINE_LINK
.1a4f8f	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.1a4f91	a0 02 00	ldy #$0002	                LDY #LINE_NUMBER
.1a4f94	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.1a4f96	a0 04 00	ldy #$0004	                LDY #LINE_TOKENS
.1a4f99	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.1a4f9b	20 b3 20	jsr $1a20b3	            JSR CLRINTERP
.1a4f9e	2b		pld		                PLD
.1a4f9f	28		plp		                PLP
.1a4fa0	60		rts		            RTS
.1a4fa1					CMD_RUN
.1a4fa1	8b		phb		                PHB
.1a4fa2	08		php		                PHP
.1a4fa3	c2 20		rep #$20	            REP #$20
.1a4fa5	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT            ; Point to the first line of the program
.1a4fa8	85 1a		sta $081a	                STA CURLINE
.1a4faa	a9 16 00	lda #$0016	                LDA #`BASIC_BOT
.1a4fad	85 1c		sta $081c	                STA CURLINE + 2
.1a4faf	20 b3 20	jsr $1a20b3	            JSR CLRINTERP
.1a4fb2	20 93 23	jsr $1a2393	            JSR EXECPROGRAM
.1a4fb5	28		plp		                PLP
.1a4fb6	ab		plb		                PLB
.1a4fb7	60		rts		            RTS
.1a4fb8					CMD_LIST
.1a4fb8	08		php		                PHP
.1a4fb9	c2 20		rep #$20	            REP #$20
.1a4fbb	64 55		stz $0855	                STZ MARG1               ; MARG1 is starting line number, default 0
.1a4fbd	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.1a4fc0	85 59		sta $0859	                STA MARG2               ; MARG2 is ending line number, default MAXINT
.1a4fc2	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a4fc5	20 3e 22	jsr $1a223e	            JSR PEEK_TOK
.1a4fc8	29 ff 00	and #$00ff	                AND #$00FF
.1a4fcb	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.1a4fce	f0 2c		beq $1a4ffc	                BEQ call_list           ; ... just list with the defaults
.1a4fd0	c9 81 00	cmp #$0081	                CMP #TOK_MINUS          ; If just "- ###"...
.1a4fd3	f0 1a		beq $1a4fef	                BEQ parse_endline       ; ... try to parse the end line number
.1a4fd5	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a4fd8	20 9d 08	jsr $1a089d	            JSR PARSEINT
.1a4fdb	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG1
.1a4fdd	85 55		sta $0855	                STA MARG1
.1a4fdf	20 3e 22	jsr $1a223e	            JSR PEEK_TOK
.1a4fe2	29 ff 00	and #$00ff	                AND #$00FF
.1a4fe5	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.1a4fe8	f0 12		beq $1a4ffc	                BEQ call_list           ; ... just list with the defaults
.1a4fea	c9 81 00	cmp #$0081	                CMP #TOK_MINUS
.1a4fed	d0 2a		bne $1a5019	                BNE error               ; At this point, if not '-', it's a syntax error
.1a4fef					parse_endline
.1a4fef	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a4ff2	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a4ff5	20 9d 08	jsr $1a089d	            JSR PARSEINT
.1a4ff8	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG2
.1a4ffa	85 59		sta $0859	                STA MARG2
.1a4ffc	a5 1c		lda $081c	call_list       LDA CURLINE+2           ; Save CURLINE
.1a4ffe	48		pha		                PHA
.1a4fff	a5 1a		lda $081a	                LDA CURLINE
.1a5001	48		pha		                PHA
.1a5002	a5 02		lda $0802	                LDA BIP+2               ; Save BIP
.1a5004	48		pha		                PHA
.1a5005	a5 00		lda $0800	                LDA BIP
.1a5007	48		pha		                PHA
.1a5008	20 4b 18	jsr $1a184b	            JSR LISTPROG
.1a500b	68		pla		                PLA
.1a500c	85 00		sta $0800	                STA BIP
.1a500e	68		pla		                PLA
.1a500f	85 02		sta $0802	                STA BIP+2
.1a5011	68		pla		                PLA
.1a5012	85 1a		sta $081a	                STA CURLINE
.1a5014	68		pla		                PLA
.1a5015	85 1c		sta $081c	                STA CURLINE+2
.1a5017	28		plp		                PLP
.1a5018	60		rts		            RTS
.1a5019					error
.1a5019	08		php		            PHP
.1a501a	c2 20		rep #$20	            REP #$20
.1a501c	48		pha		            PHA
.1a501d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5020	5b		tcd		            TCD
.1a5021	68		pla		            PLA
.1a5022	28		plp		            PLP
.1a5023	e2 20		sep #$20	            SEP #$20
.1a5025	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a5027	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a502b	c2 20		rep #$20	            REP #$20
.1a502d	29 ff 00	and #$00ff	            AND #$00FF
.1a5030	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a5033	e2 20		sep #$20	            SEP #$20
.1a5035	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]

;******  Return to file: src\basic816.s


;******  Processing file: src\variables.s

>08e1					NEXTVAR         .long ?         ; Pointer to the the next available byte for variable bindings
>08e4					VARIABLES       .long ?         ; Pointer to the most recently allocated variable
>08e7					TOFIND          .long ?         ; Pointer to the variable name to find
>08ea					TOFINDTYPE      .byte ?         ; The type to find
.0000					BINDING
>0000					TYPE            .fill 1                 ; The type of the data stored in the variable
>0001					NAME            .fill VAR_NAME_SIZE     ; The name of the variable
>0009					VALUE           .fill 4                 ; The data stored in the variable
>000d					NEXT            .fill 3                 ; The pointer to the next allocated variable of this type
.1a5038					INITVARS
.1a5038	08		php		                PHP
.1a5039	08		php		            PHP
.1a503a	c2 20		rep #$20	            REP #$20
.1a503c	48		pha		            PHA
.1a503d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5040	5b		tcd		            TCD
.1a5041	68		pla		            PLA
.1a5042	28		plp		            PLP
.1a5043	c2 20		rep #$20	            REP #$20
.1a5045	64 e4		stz $08e4	                STZ VARIABLES           ; Clear the pointer to the variables
.1a5047	64 e7		stz $08e7	                STZ TOFIND
.1a5049	e2 20		sep #$20	            SEP #$20
.1a504b	64 e6		stz $08e6	                STZ VARIABLES+2
.1a504d	64 e9		stz $08e9	                STZ TOFIND+2
.1a504f	64 ea		stz $08ea	                STZ TOFINDTYPE
.1a5051	c2 20		rep #$20	            REP #$20
.1a5053	38		sec		                SEC                     ; Compute the position of the first variable
.1a5054	a5 d9		lda $08d9	                LDA LASTLINE
.1a5056	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.1a5059	85 e1		sta $08e1	                STA NEXTVAR
.1a505b	e2 20		sep #$20	            SEP #$20
.1a505d	a5 db		lda $08db	                LDA LASTLINE+2
.1a505f	69 00		adc #$00	                ADC #0
.1a5061	85 e3		sta $08e3	                STA NEXTVAR+2
.1a5063	28		plp		                PLP
.1a5064	60		rts		            RTS
.1a5065					ISVARCHAR
.1a5065	c9 5f		cmp #$5f	                CMP #'_'            ; Check if it's an underscore
.1a5067	f0 1a		beq $1a5083	                BEQ return_true     ; Yes: return true
.1a5069	c9 3a		cmp #$3a	                CMP #'9'+1          ; Check if its in [0-9]
.1a506b	b0 04		bcs $1a5071	                BGE else1           ; No: check something else
.1a506d	c9 30		cmp #$30	                CMP #'0'
.1a506f	b0 12		bcs $1a5083	                BGE return_true     ; Yes: return true
.1a5071	c9 5b		cmp #$5b	else1           CMP #'Z'+1          ; Check if its in [A-Z]
.1a5073	b0 04		bcs $1a5079	                BGE not_upper       ; No: check lower case
.1a5075	c9 41		cmp #$41	                CMP #'A'
.1a5077	b0 0a		bcs $1a5083	                BGE return_true     ; Yes: return true
.1a5079	c9 7b		cmp #$7b	not_upper       CMP #'z'+1          ; Check if its in [a-z]
.1a507b	b0 04		bcs $1a5081	                BGE return_false    ; No: return false
.1a507d	c9 61		cmp #$61	                CMP #'a'
.1a507f	b0 02		bcs $1a5083	                BGE return_true     ; Yes: return true
.1a5081	18		clc		return_false    CLC
.1a5082	60		rts		            RTS
.1a5083	38		sec		return_true     SEC
.1a5084	60		rts		            RTS
.1a5085					VARNAMECMP
.1a5085	08		php		                PHP
.1a5086	e2 20		sep #$20	            SEP #$20
.1a5088	c2 10		rep #$10	            REP #$10
.1a508a	a0 00 00	ldy #$0000	                LDY #0
.1a508d	b7 0c		lda [$080c],y	cmp_loop        LDA [SCRATCH],Y         ; Check the character in the variable name
.1a508f	f0 0a		beq $1a509b	                BEQ is_end
.1a5091	d7 e7		cmp [$08e7],y	                CMP [TOFIND],Y          ; Compare the character to the one TOFIND
.1a5093	d0 13		bne $1a50a8	                BNE return_false        ; Not equal? Then this is not a match
.1a5095	c8		iny		                INY
.1a5096	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.1a5099	d0 f2		bne $1a508d	                BNE cmp_loop
.1a509b	b7 e7		lda [$08e7],y	is_end          LDA [TOFIND],Y          ; Check the character in the name to find
.1a509d	20 1b 05	jsr $1a051b	            JSR TOUPPERA
.1a50a0	20 65 50	jsr $1a5065	            JSR ISVARCHAR
.1a50a3	b0 03		bcs $1a50a8	                BCS return_false        ; YES: we do not have a match
.1a50a5					return_true
.1a50a5	28		plp		                PLP
.1a50a6	38		sec		                SEC
.1a50a7	60		rts		            RTS
.1a50a8					return_false
.1a50a8	28		plp		                PLP
.1a50a9	18		clc		                CLC
.1a50aa	60		rts		            RTS
.1a50ab					VAR_FIND
.1a50ab	08		php		                PHP
.1a50ac	e2 20		sep #$20	            SEP #$20
.1a50ae	c2 10		rep #$10	            REP #$10
.1a50b0	a0 00 00	ldy #$0000	                LDY #0
.1a50b3	a2 00 00	ldx #$0000	                LDX #0
.1a50b6	b7 e7		lda [$08e7],y	upper_loop      LDA [TOFIND],Y          ; Get a character
.1a50b8	f0 0b		beq $1a50c5	                BEQ done_upper
.1a50ba	20 1b 05	jsr $1a051b	            JSR TOUPPERA
.1a50bd	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; And save it to the temp
.1a50c1	c8		iny		                INY
.1a50c2	e8		inx		                INX
.1a50c3	80 f1		bra $1a50b6	                BRA upper_loop          ; Go back for another
.1a50c5	a9 00		lda #$00	done_upper      LDA #0
.1a50c7	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; NULL terminate the temporary string
.1a50cb	c2 20		rep #$20	            REP #$20
.1a50cd	a9 00 4e	lda #$4e00	                LDA #<>TEMPBUF          ; Make the temporary string the string
.1a50d0	85 e7		sta $08e7	                STA TOFIND              ; the variable name to find
.1a50d2	e2 20		sep #$20	            SEP #$20
.1a50d4	a9 00		lda #$00	                LDA #`TEMPBUF
.1a50d6	85 e9		sta $08e9	                STA TOFIND+2
.1a50d8	c2 20		rep #$20	            REP #$20
.1a50da	a5 e4		lda $08e4	                LDA VARIABLES           ; Point INDEX to the first variable to check
.1a50dc	85 08		sta $0808	                STA INDEX
.1a50de	d0 06		bne $1a50e6	                BNE set_index_h         ; If the low word is not 0, copy the high byte
.1a50e0	e2 20		sep #$20	            SEP #$20
.1a50e2	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a50e4	f0 4d		beq $1a5133	                BEQ not_found           ; If it is, we have no variables yet.
.1a50e6					set_index_h
.1a50e6	e2 20		sep #$20	            SEP #$20
.1a50e8	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a50ea	85 0a		sta $080a	                STA INDEX+2
.1a50ec	a5 ea		lda $08ea	check_binding   LDA TOFINDTYPE
.1a50ee	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Get the type of the variable
.1a50f1	d7 08		cmp [$0808],y	                CMP [INDEX],Y
.1a50f3	d0 17		bne $1a510c	                BNE check_next          ; If it's not a match, check the next binding
.1a50f5	c2 20		rep #$20	            REP #$20
.1a50f7	18		clc		                CLC
.1a50f8	a5 08		lda $0808	                LDA INDEX
.1a50fa	69 01 00	adc #$0001	                ADC #BINDING.NAME
.1a50fd	85 0c		sta $080c	                STA SCRATCH
.1a50ff	e2 20		sep #$20	            SEP #$20
.1a5101	a5 0a		lda $080a	                LDA INDEX+2
.1a5103	69 00		adc #$00	                ADC #0
.1a5105	85 0e		sta $080e	                STA SCRATCH+2
.1a5107	20 85 50	jsr $1a5085	            JSR VARNAMECMP
.1a510a	b0 2a		bcs $1a5136	                BCS found               ; If they match, return that we've found the variable
.1a510c	a0 0d 00	ldy #$000d	check_next      LDY #BINDING.NEXT       ; SCRATCH := [INDEX].NEXT
.1a510f	c2 20		rep #$20	            REP #$20
.1a5111	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a5113	85 0c		sta $080c	                STA SCRATCH
.1a5115	c8		iny		                INY
.1a5116	c8		iny		                INY
.1a5117	e2 20		sep #$20	            SEP #$20
.1a5119	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a511b	85 0e		sta $080e	                STA SCRATCH+2
.1a511d	d0 06		bne $1a5125	                BNE set_index           ; If SCRATCH == 0, the variable wasn't found
.1a511f	c2 20		rep #$20	            REP #$20
.1a5121	a5 0c		lda $080c	                LDA SCRATCH
.1a5123	f0 0e		beq $1a5133	                BEQ not_found
.1a5125					set_index
.1a5125	c2 20		rep #$20	            REP #$20
.1a5127	a5 0c		lda $080c	                LDA SCRATCH
.1a5129	85 08		sta $0808	                STA INDEX
.1a512b	e2 20		sep #$20	            SEP #$20
.1a512d	a5 0e		lda $080e	                LDA SCRATCH+2
.1a512f	85 0a		sta $080a	                STA INDEX+2
.1a5131	80 b9		bra $1a50ec	                BRA check_binding       ; And check this next variable for a match
.1a5133					not_found
.1a5133	28		plp		                PLP
.1a5134	18		clc		                CLC
.1a5135	60		rts		            RTS
.1a5136					found
.1a5136	28		plp		                PLP
.1a5137	38		sec		                SEC
.1a5138	60		rts		            RTS
.1a5139					VAR_REF
.1a5139	08		php		                PHP
.1a513a	20 ab 50	jsr $1a50ab	            JSR VAR_FIND
.1a513d	b0 1f		bcs $1a515e	                BCS found
.1a513f	08		php		            PHP
.1a5140	c2 20		rep #$20	            REP #$20
.1a5142	48		pha		            PHA
.1a5143	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5146	5b		tcd		            TCD
.1a5147	68		pla		            PLA
.1a5148	28		plp		            PLP
.1a5149	e2 20		sep #$20	            SEP #$20
.1a514b	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a514d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5151	c2 20		rep #$20	            REP #$20
.1a5153	29 ff 00	and #$00ff	            AND #$00FF
.1a5156	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a5159	e2 20		sep #$20	            SEP #$20
.1a515b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a515e					found
.1a515e	c2 30		rep #$30	            REP #$30
.1a5160	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.1a5163	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a5165	85 23		sta $0823	                STA ARGUMENT1
.1a5167	c8		iny		                INY
.1a5168	c8		iny		                INY
.1a5169	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a516b	85 25		sta $0825	                STA ARGUMENT1+2
.1a516d	e2 20		sep #$20	            SEP #$20
.1a516f	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE
.1a5172	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a5174	85 27		sta $0827	                STA ARGTYPE1
.1a5176	28		plp		done            PLP
.1a5177	60		rts		            RTS
.1a5178					VAR_ALLOC
.1a5178	08		php		                PHP
.1a5179	c2 20		rep #$20	            REP #$20
.1a517b	18		clc		                CLC                     ; Compute extent of the binding
.1a517c	a5 e1		lda $08e1	                LDA NEXTVAR
.1a517e	69 10 00	adc #$0010	                ADC #size(BINDING)
.1a5181	85 08		sta $0808	                STA INDEX
.1a5183	e2 20		sep #$20	            SEP #$20
.1a5185	a5 e3		lda $08e3	                LDA NEXTVAR+2
.1a5187	69 00		adc #$00	                ADC #0
.1a5189	85 0a		sta $080a	                STA INDEX+2
.1a518b	c5 bc		cmp $08bc	                CMP HEAP+2              ; Check to see if HEAP > INDEX
.1a518d	90 27		bcc $1a51b6	                BLT has_room
.1a518f	c2 20		rep #$20	            REP #$20
.1a5191	a5 08		lda $0808	                LDA INDEX
.1a5193	c5 ba		cmp $08ba	                CMP HEAP
.1a5195	90 1f		bcc $1a51b6	                BLT has_room
.1a5197	08		php		            PHP
.1a5198	c2 20		rep #$20	            REP #$20
.1a519a	48		pha		            PHA
.1a519b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a519e	5b		tcd		            TCD
.1a519f	68		pla		            PLA
.1a51a0	28		plp		            PLP
.1a51a1	e2 20		sep #$20	            SEP #$20
.1a51a3	a9 09		lda #$09	            LDA #ERR_RANGE
.1a51a5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a51a9	c2 20		rep #$20	            REP #$20
.1a51ab	29 ff 00	and #$00ff	            AND #$00FF
.1a51ae	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a51b1	e2 20		sep #$20	            SEP #$20
.1a51b3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a51b6					has_room
.1a51b6	c2 20		rep #$20	            REP #$20
.1a51b8	a5 e1		lda $08e1	                LDA NEXTVAR             ; Yes: we can allocate the variable
.1a51ba	85 c0		sta $08c0	                STA CURRBLOCK           ; Point CURRBLOCK to it
.1a51bc	e2 20		sep #$20	            SEP #$20
.1a51be	a5 e3		lda $08e3	                LDA NEXTVAR+2
.1a51c0	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a51c2	c2 20		rep #$20	            REP #$20
.1a51c4	a5 08		lda $0808	                LDA INDEX               ; And point NEXTVAR to the next possible spot
.1a51c6	85 e1		sta $08e1	                STA NEXTVAR
.1a51c8	e2 20		sep #$20	            SEP #$20
.1a51ca	a5 0a		lda $080a	                LDA INDEX+2
.1a51cc	85 e3		sta $08e3	                STA NEXTVAR+2
.1a51ce	28		plp		                PLP
.1a51cf	60		rts		            RTS
.1a51d0					VAR_CREATE
.1a51d0	08		php		                PHP
.1a51d1	e2 20		sep #$20	            SEP #$20
.1a51d3	a5 27		lda $0827	                LDA ARGTYPE1            ; Validate that our types match
.1a51d5	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.1a51d7	f0 33		beq $1a520c	                BEQ chk_string          ; If so: check to see if it's a string
.1a51d9	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable type
.1a51db	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's INTEGER
.1a51dd	d0 05		bne $1a51e4	                BNE chk_float
.1a51df	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a51e2	80 2f		bra $1a5213	                BRA alloc_binding       ; And bind the variable
.1a51e4	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; If it's FLOAT
.1a51e6	d0 05		bne $1a51ed	                BNE type_error
.1a51e8	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a51eb	80 26		bra $1a5213	                BRA alloc_binding       ; And bind the variable
.1a51ed					type_error
.1a51ed	08		php		            PHP
.1a51ee	c2 20		rep #$20	            REP #$20
.1a51f0	48		pha		            PHA
.1a51f1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a51f4	5b		tcd		            TCD
.1a51f5	68		pla		            PLA
.1a51f6	28		plp		            PLP
.1a51f7	e2 20		sep #$20	            SEP #$20
.1a51f9	a9 04		lda #$04	            LDA #ERR_TYPE
.1a51fb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a51ff	c2 20		rep #$20	            REP #$20
.1a5201	29 ff 00	and #$00ff	            AND #$00FF
.1a5204	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a5207	e2 20		sep #$20	            SEP #$20
.1a5209	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a520c	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING        ; Is it a string?
.1a520e	d0 03		bne $1a5213	                BNE alloc_binding       ; No: just go ahead and bind it
.1a5210	20 b3 16	jsr $1a16b3	            JSR STRCPY
.1a5213					alloc_binding
.1a5213	c2 10		rep #$10	            REP #$10
.1a5215	20 78 51	jsr $1a5178	            JSR VAR_ALLOC
.1a5218	c2 30		rep #$30	            REP #$30
.1a521a	18		clc		                CLC
.1a521b	a5 c0		lda $08c0	                LDA CURRBLOCK
.1a521d	69 01 00	adc #$0001	                ADC #BINDING.NAME
.1a5220	85 08		sta $0808	                STA INDEX
.1a5222	e2 20		sep #$20	            SEP #$20
.1a5224	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a5226	69 00		adc #$00	                ADC #0
.1a5228	85 0a		sta $080a	                STA INDEX+2
.1a522a	a0 00 00	ldy #$0000	                LDY #0                  ; Ensure that the name field is blank
.1a522d	a9 00		lda #$00	                LDA #0
.1a522f	97 08		sta [$0808],y	blank_loop      STA [INDEX],Y
.1a5231	c8		iny		                INY
.1a5232	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.1a5235	d0 f8		bne $1a522f	                BNE blank_loop
.1a5237	a0 00 00	ldy #$0000	                LDY #0
.1a523a	b7 e7		lda [$08e7],y	name_loop       LDA [TOFIND],Y          ; Copy TOFIND to the NAME field
.1a523c	f0 10		beq $1a524e	                BEQ set_type
.1a523e	20 1b 05	jsr $1a051b	            JSR TOUPPERA
.1a5241	20 65 50	jsr $1a5065	            JSR ISVARCHAR
.1a5244	90 08		bcc $1a524e	                BCC set_type
.1a5246	97 08		sta [$0808],y	                STA [INDEX],Y
.1a5248	c8		iny		                INY
.1a5249	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.1a524c	d0 ec		bne $1a523a	                BNE name_loop
.1a524e					set_type
.1a524e	c2 20		rep #$20	            REP #$20
.1a5250	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE      ; Copy the value to the variable
.1a5253	a5 23		lda $0823	                LDA ARGUMENT1
.1a5255	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a5257	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5259	c8		iny		                INY
.1a525a	c8		iny		                INY
.1a525b	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a525d	a5 e4		lda $08e4	                LDA VARIABLES           ; Point NEXT to the current top of variables
.1a525f	a0 0d 00	ldy #$000d	                LDY #BINDING.NEXT
.1a5262	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a5264	c8		iny		                INY
.1a5265	c8		iny		                INY
.1a5266	e2 20		sep #$20	            SEP #$20
.1a5268	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a526a	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a526c	c2 20		rep #$20	            REP #$20
.1a526e	a5 c0		lda $08c0	                LDA CURRBLOCK
.1a5270	85 e4		sta $08e4	                STA VARIABLES
.1a5272	e2 20		sep #$20	            SEP #$20
.1a5274	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a5276	85 e6		sta $08e6	                STA VARIABLES+2
.1a5278	e2 20		sep #$20	            SEP #$20
.1a527a	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Set the type of the variable
.1a527d	a5 27		lda $0827	                LDA ARGTYPE1
.1a527f	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a5281	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is it a string?
.1a5283	f0 02		beq $1a5287	                BEQ set_ref             ; Yes: add a reference count to it
.1a5285	28		plp		done            PLP
.1a5286	60		rts		            RTS
.1a5287					set_ref
.1a5287	c2 20		rep #$20	            REP #$20
.1a5289	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the a heap allocated value
.1a528b	85 c0		sta $08c0	                STA CURRBLOCK
.1a528d	e2 20		sep #$20	            SEP #$20
.1a528f	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5291	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a5293	20 cf 12	jsr $1a12cf	            JSR HEAP_GETHED
.1a5296	20 e4 12	jsr $1a12e4	            JSR HEAP_ADDREF
.1a5299	80 ea		bra $1a5285	                BRA done
.1a529b					VAR_SET
.1a529b	08		php		                PHP
.1a529c	c2 30		rep #$30	            REP #$30
.1a529e	a5 e4		lda $08e4	                LDA VARIABLES          ; If VARIABLES = 0, use VAR_CREATE
.1a52a0	d0 06		bne $1a52a8	                BNE use_find
.1a52a2	e2 20		sep #$20	            SEP #$20
.1a52a4	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a52a6	f0 05		beq $1a52ad	                BEQ use_create
.1a52a8					use_find
.1a52a8	20 ab 50	jsr $1a50ab	            JSR VAR_FIND
.1a52ab	b0 05		bcs $1a52b2	                BCS found
.1a52ad					use_create
.1a52ad	20 d0 51	jsr $1a51d0	            JSR VAR_CREATE
.1a52b0	80 4e		bra $1a5300	                BRA done
.1a52b2					found
.1a52b2	e2 20		sep #$20	            SEP #$20
.1a52b4	a5 27		lda $0827	                LDA ARGTYPE1            ; Do the types match?
.1a52b6	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.1a52b8	f0 33		beq $1a52ed	                BEQ chk_string          ; Yes: check to see if it's string
.1a52ba	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable
.1a52bc	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; Is it INTEGER?
.1a52be	d0 05		bne $1a52c5	                BNE chk_float
.1a52c0	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a52c3	80 2c		bra $1a52f1	                BRA set_val
.1a52c5	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; Is it FLOAT?
.1a52c7	d0 05		bne $1a52ce	                BNE type_error          ; No: throw an error
.1a52c9	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a52cc	80 23		bra $1a52f1	                BRA set_val
.1a52ce					type_error
.1a52ce	08		php		            PHP
.1a52cf	c2 20		rep #$20	            REP #$20
.1a52d1	48		pha		            PHA
.1a52d2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a52d5	5b		tcd		            TCD
.1a52d6	68		pla		            PLA
.1a52d7	28		plp		            PLP
.1a52d8	e2 20		sep #$20	            SEP #$20
.1a52da	a9 04		lda #$04	            LDA #ERR_TYPE
.1a52dc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a52e0	c2 20		rep #$20	            REP #$20
.1a52e2	29 ff 00	and #$00ff	            AND #$00FF
.1a52e5	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a52e8	e2 20		sep #$20	            SEP #$20
.1a52ea	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a52ed	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING
.1a52ef	f0 11		beq $1a5302	                BEQ set_string          ; Yes: set the string value of the variable
.1a52f1					set_val
.1a52f1	c2 30		rep #$30	            REP #$30
.1a52f3	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.1a52f6	a5 23		lda $0823	                LDA ARGUMENT1
.1a52f8	97 08		sta [$0808],y	                STA [INDEX],Y
.1a52fa	c8		iny		                INY
.1a52fb	c8		iny		                INY
.1a52fc	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a52fe	97 08		sta [$0808],y	                STA [INDEX],Y
.1a5300					done
.1a5300	28		plp		                PLP
.1a5301	60		rts		            RTS
.1a5302					set_string
.1a5302	20 b3 16	jsr $1a16b3	            JSR STRCPY
.1a5305	a0 09 00	ldy #$0009	set_ref         LDY #BINDING.VALUE      ; Set CURRBLOCK to the current string value
.1a5308	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a530a	85 c0		sta $08c0	                STA CURRBLOCK
.1a530c	c8		iny		                INY
.1a530d	c8		iny		                INY
.1a530e	e2 20		sep #$20	            SEP #$20
.1a5310	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a5312	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a5314	20 cf 12	jsr $1a12cf	            JSR HEAP_GETHED
.1a5317	20 03 13	jsr $1a1303	            JSR HEAP_REMREF
.1a531a	e2 20		sep #$20	            SEP #$20
.1a531c	a5 27		lda $0827	                LDA ARGTYPE1
.1a531e	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is the new value a string?
.1a5320	f0 02		beq $1a5324	                BEQ add_ref             ; Yes: add a reference to it
.1a5322	80 cd		bra $1a52f1	                BRA set_val             ; No: go back to set the value... this probably shouldn't happen
.1a5324					add_ref
.1a5324	c2 20		rep #$20	            REP #$20
.1a5326	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the new string value
.1a5328	85 c0		sta $08c0	                STA CURRBLOCK
.1a532a	e2 20		sep #$20	            SEP #$20
.1a532c	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a532e	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a5330	20 cf 12	jsr $1a12cf	            JSR HEAP_GETHED
.1a5333	20 e4 12	jsr $1a12e4	            JSR HEAP_ADDREF
.1a5336	80 b9		bra $1a52f1	                BRA set_val
.1a5338					VAR_FINDNAME
.1a5338	08		php		                PHP
.1a5339	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a533c	e2 20		sep #$20	            SEP #$20
.1a533e	a7 00		lda [$0800]	                LDA [BIP]           ; Get the first character
.1a5340	20 a7 04	jsr $1a04a7	            JSR ISALPHA
.1a5343	90 42		bcc $1a5387	                BCC not_found
.1a5345	c2 20		rep #$20	            REP #$20
.1a5347	a5 00		lda $0800	                LDA BIP
.1a5349	85 e7		sta $08e7	                STA TOFIND
.1a534b	e2 20		sep #$20	            SEP #$20
.1a534d	a5 02		lda $0802	                LDA BIP+2
.1a534f	85 e9		sta $08e9	                STA TOFIND+2
.1a5351					loop
.1a5351	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a5354	a7 00		lda [$0800]	                LDA [BIP]
.1a5356	f0 0d		beq $1a5365	                BEQ is_float        ; If it's EOL, the variable is a float
.1a5358	c9 24		cmp #$24	                CMP #'$'            ; If it's $, the variable is a string
.1a535a	f0 14		beq $1a5370	                BEQ is_string
.1a535c	c9 25		cmp #$25	                CMP #'%'            ; If it's %, the variable is an integer
.1a535e	f0 09		beq $1a5369	                BEQ is_integer
.1a5360	20 65 50	jsr $1a5065	            JSR ISVARCHAR
.1a5363	b0 ec		bcs $1a5351	                BCS loop            ; Check the next one
.1a5365	a9 01		lda #$01	is_float        LDA #TYPE_FLOAT     ; Otherwise it's a float
.1a5367	80 0c		bra $1a5375	                BRA set_type
.1a5369					is_integer
.1a5369	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a536c	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a536e	80 05		bra $1a5375	                BRA set_type
.1a5370					is_string
.1a5370	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a5373	a9 02		lda #$02	                LDA #TYPE_STRING
.1a5375	85 ea		sta $08ea	set_type        STA TOFINDTYPE
.1a5377	20 3e 22	jsr $1a223e	            JSR PEEK_TOK
.1a537a	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it "("?
.1a537c	d0 06		bne $1a5384	                BNE done            ; No: we're done... it's just a scalar variable
.1a537e	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Yes: this is an array reference
.1a5380	09 80		ora #$80	                ORA #$80            ; ... turn on the "Array of..." bit
.1a5382	85 ea		sta $08ea	                STA TOFINDTYPE
.1a5384					done
.1a5384	28		plp		                PLP
.1a5385	38		sec		                SEC
.1a5386	60		rts		            RTS
.1a5387	28		plp		not_found       PLP
.1a5388	18		clc		                CLC
.1a5389	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\integers.s

.1a538a					OP_INT_ADD
.1a538a	08		php		            PHP
.1a538b	c2 20		rep #$20	            REP #$20
.1a538d	18		clc		            CLC
.1a538e	a5 23		lda $0823	            LDA ARGUMENT1
.1a5390	65 29		adc $0829	            ADC ARGUMENT2
.1a5392	85 23		sta $0823	            STA ARGUMENT1
.1a5394	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5396	65 2b		adc $082b	            ADC ARGUMENT2+2
.1a5398	85 25		sta $0825	            STA ARGUMENT1+2
.1a539a	28		plp		            PLP
.1a539b	60		rts		            RTS
.1a539c					OP_INT_SUB
.1a539c	08		php		            PHP
.1a539d	c2 20		rep #$20	            REP #$20
.1a539f	38		sec		            SEC
.1a53a0	a5 23		lda $0823	            LDA ARGUMENT1
.1a53a2	e5 29		sbc $0829	            SBC ARGUMENT2
.1a53a4	85 23		sta $0823	            STA ARGUMENT1
.1a53a6	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a53a8	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.1a53aa	85 25		sta $0825	            STA ARGUMENT1+2
.1a53ac	28		plp		            PLP
.1a53ad	60		rts		            RTS
.1a53ae					OP_INT_MUL
.1a53ae	08		php		            PHP
.1a53af					locals
>0001					L_SIGN      .word ?
>0003					L_RESULT    .dword ?
>0007					            .dword ?
.1a53af	c2 20		rep #$20	            REP #$20
.1a53b1	3b		tsc		            TSC
.1a53b2	38		sec		            SEC
.1a53b3	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.1a53b6	1b		tcs		            TCS
.1a53b7	c2 30		rep #$30	            REP #$30
.1a53b9	a9 00 00	lda #$0000	            LDA #0                  ; Start by assuming positive numbers
.1a53bc	83 01		sta $01,s	            STA L_SIGN
.1a53be	83 03		sta $03,s	            STA L_RESULT            ; Clear result
.1a53c0	83 05		sta $05,s	            STA L_RESULT+2
.1a53c2	83 07		sta $07,s	            STA L_RESULT+4
.1a53c4	83 09		sta $09,s	            STA L_RESULT+6
.1a53c6	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Ensure ARGUMENT1 is positive
.1a53c8	10 18		bpl $1a53e2	            BPL chk_sign2
.1a53ca	a9 00 80	lda #$8000	            LDA #$8000              ; Record that ARGUMENT1 is negative
.1a53cd	83 01		sta $01,s	            STA L_SIGN
.1a53cf	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Take the two's complement of ARGUMENT1
.1a53d1	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a53d4	85 25		sta $0825	            STA ARGUMENT1+2
.1a53d6	a5 23		lda $0823	            LDA ARGUMENT1
.1a53d8	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a53db	1a		inc a		            INC A
.1a53dc	85 23		sta $0823	            STA ARGUMENT1
.1a53de	d0 02		bne $1a53e2	            BNE chk_sign2
.1a53e0	e6 25		inc $0825	            INC ARGUMENT1+2
.1a53e2	a5 2b		lda $082b	chk_sign2   LDA ARGUMENT2+2         ; Ensure ARGUMENT2 is positive
.1a53e4	10 1a		bpl $1a5400	            BPL chk_over
.1a53e6	a3 01		lda $01,s	            LDA L_SIGN              ; Flip the sign
.1a53e8	49 00 80	eor #$8000	            EOR #$8000
.1a53eb	83 01		sta $01,s	            STA L_SIGN
.1a53ed	a5 2b		lda $082b	            LDA ARGUMENT2+2         ; Take the two's complement of ARGUMENT2
.1a53ef	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a53f2	85 2b		sta $082b	            STA ARGUMENT2+2
.1a53f4	a5 29		lda $0829	            LDA ARGUMENT2
.1a53f6	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a53f9	1a		inc a		            INC A
.1a53fa	85 29		sta $0829	            STA ARGUMENT2
.1a53fc	d0 02		bne $1a5400	            BNE chk_over
.1a53fe	e6 2b		inc $082b	            INC ARGUMENT2+2
.1a5400					chk_over
.1a5400	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5402	f0 04		beq $1a5408	            BEQ do_mult
.1a5404	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a5406	d0 5a		bne $1a5462	            BNE overflow
.1a5408					do_mult
.1a5408	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*D
.1a540a	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.1a540e	a5 29		lda $0829	            LDA ARGUMENT2
.1a5410	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.1a5414	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.1a5418	83 03		sta $03,s	            STA L_RESULT
.1a541a	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.1a541e	83 05		sta $05,s	            STA L_RESULT+2
.1a5420	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Calculate A*D << 16 + B*D
.1a5422	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.1a5426	a5 29		lda $0829	            LDA ARGUMENT2
.1a5428	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.1a542c	18		clc		            CLC
.1a542d	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.1a5431	63 05		adc $05,s	            ADC L_RESULT+2
.1a5433	83 05		sta $05,s	            STA L_RESULT+2
.1a5435	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.1a5439	63 07		adc $07,s	            ADC L_RESULT+4
.1a543b	83 07		sta $07,s	            STA L_RESULT+4
.1a543d	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*C << 16 + A*D << 16 + B*D
.1a543f	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.1a5443	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a5445	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.1a5449	18		clc		            CLC
.1a544a	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.1a544e	63 05		adc $05,s	            ADC L_RESULT+2
.1a5450	83 05		sta $05,s	            STA L_RESULT+2
.1a5452	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.1a5456	63 07		adc $07,s	            ADC L_RESULT+4
.1a5458	83 07		sta $07,s	            STA L_RESULT+4
.1a545a	a3 07		lda $07,s	            LDA L_RESULT+4
.1a545c	f0 23		beq $1a5481	            BEQ no_overflow
.1a545e	a3 09		lda $09,s	            LDA L_RESULT+6
.1a5460	f0 1f		beq $1a5481	            BEQ no_overflow
.1a5462					overflow
.1a5462	08		php		            PHP
.1a5463	c2 20		rep #$20	            REP #$20
.1a5465	48		pha		            PHA
.1a5466	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5469	5b		tcd		            TCD
.1a546a	68		pla		            PLA
.1a546b	28		plp		            PLP
.1a546c	e2 20		sep #$20	            SEP #$20
.1a546e	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.1a5470	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5474	c2 20		rep #$20	            REP #$20
.1a5476	29 ff 00	and #$00ff	            AND #$00FF
.1a5479	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a547c	e2 20		sep #$20	            SEP #$20
.1a547e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5481					no_overflow
.1a5481	c2 30		rep #$30	            REP #$30
.1a5483	a3 01		lda $01,s	            LDA L_SIGN              ; Check the sign
.1a5485	10 16		bpl $1a549d	            BPL ret_result          ; If positive: just return the result
.1a5487	a3 05		lda $05,s	            LDA L_RESULT+2          ; Compute the two's complement of the result
.1a5489	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a548c	83 05		sta $05,s	            STA L_RESULT+2
.1a548e	a3 03		lda $03,s	            LDA L_RESULT
.1a5490	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a5493	1a		inc a		            INC A
.1a5494	83 03		sta $03,s	            STA L_RESULT
.1a5496	d0 05		bne $1a549d	            BNE ret_result
.1a5498	a3 05		lda $05,s	            LDA L_RESULT+2
.1a549a	1a		inc a		            INC A
.1a549b	83 05		sta $05,s	            STA L_RESULT+2
.1a549d					ret_result
.1a549d	a3 03		lda $03,s	            LDA L_RESULT
.1a549f	85 23		sta $0823	            STA ARGUMENT1
.1a54a1	a3 05		lda $05,s	            LDA L_RESULT+2
.1a54a3	85 25		sta $0825	            STA ARGUMENT1+2
.1a54a5	c2 20		rep #$20	            REP #$20
.1a54a7	3b		tsc		            TSC
.1a54a8	18		clc		            CLC
.1a54a9	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.1a54ac	1b		tcs		            TCS
.1a54ad	28		plp		            PLP
.1a54ae	60		rts		            RTS
.1a54af					OP_INT_LT
.1a54af	08		php		            PHP
.1a54b0	c2 20		rep #$20	            REP #$20
.1a54b2	a5 23		lda $0823	            LDA ARGUMENT1
.1a54b4	c5 29		cmp $0829	            CMP ARGUMENT2
.1a54b6	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a54b8	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.1a54ba	50 03		bvc $1a54bf	            BVC skip_eor
.1a54bc	49 00 80	eor #$8000	            EOR #$8000
.1a54bf	30 06		bmi $1a54c7	skip_eor    BMI ret_true
.1a54c1	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a54c3	64 25		stz $0825	            STZ ARGUMENT1+2
.1a54c5	80 07		bra $1a54ce	            BRA done
.1a54c7	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a54ca	85 23		sta $0823	            STA ARGUMENT1
.1a54cc	85 25		sta $0825	            STA ARGUMENT1+2
.1a54ce	28		plp		done        PLP
.1a54cf	60		rts		            RTS
.1a54d0					OP_INT_GT
.1a54d0	08		php		            PHP
.1a54d1	c2 20		rep #$20	            REP #$20
.1a54d3	a5 23		lda $0823	            LDA ARGUMENT1
.1a54d5	c5 29		cmp $0829	            CMP ARGUMENT2
.1a54d7	d0 0c		bne $1a54e5	            BNE test_fully
.1a54d9	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a54db	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.1a54dd	d0 06		bne $1a54e5	            BNE test_fully
.1a54df	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a54e1	64 25		stz $0825	            STZ ARGUMENT1+2
.1a54e3	80 16		bra $1a54fb	            BRA done
.1a54e5	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.1a54e7	c5 23		cmp $0823	            CMP ARGUMENT1
.1a54e9	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a54eb	e5 25		sbc $0825	            SBC ARGUMENT1+2
.1a54ed	50 03		bvc $1a54f2	            BVC skip_eor
.1a54ef	49 00 80	eor #$8000	            EOR #$8000
.1a54f2	10 eb		bpl $1a54df	skip_eor    BPL ret_false
.1a54f4	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a54f7	85 23		sta $0823	            STA ARGUMENT1
.1a54f9	85 25		sta $0825	            STA ARGUMENT1+2
.1a54fb	28		plp		done        PLP
.1a54fc	60		rts		            RTS
.1a54fd					OP_INT_EQ
.1a54fd	08		php		            PHP
.1a54fe	c2 20		rep #$20	            REP #$20
.1a5500	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a5502	c5 25		cmp $0825	            CMP ARGUMENT1+2
.1a5504	d0 0f		bne $1a5515	            BNE ret_false
.1a5506	a5 29		lda $0829	            LDA ARGUMENT2
.1a5508	c5 23		cmp $0823	            CMP ARGUMENT1
.1a550a	d0 09		bne $1a5515	            BNE ret_false
.1a550c	a9 ff ff	lda #$ffff	            LDA #$FFFF
.1a550f	85 23		sta $0823	            STA ARGUMENT1
.1a5511	85 25		sta $0825	            STA ARGUMENT1+2
.1a5513	80 04		bra $1a5519	            BRA done
.1a5515	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a5517	64 25		stz $0825	            STZ ARGUMENT1+2
.1a5519	28		plp		done        PLP
.1a551a	60		rts		            RTS
.1a551b					OP_INT_NE
.1a551b	08		php		            PHP
.1a551c	c2 20		rep #$20	            REP #$20
.1a551e	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a5520	c5 25		cmp $0825	            CMP ARGUMENT1+2
.1a5522	d0 0c		bne $1a5530	            BNE ret_true
.1a5524	a5 29		lda $0829	            LDA ARGUMENT2
.1a5526	c5 23		cmp $0823	            CMP ARGUMENT1
.1a5528	d0 06		bne $1a5530	            BNE ret_true
.1a552a	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a552c	64 25		stz $0825	            STZ ARGUMENT1+2
.1a552e	80 07		bra $1a5537	            BRA done
.1a5530	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a5533	85 23		sta $0823	            STA ARGUMENT1
.1a5535	85 25		sta $0825	            STA ARGUMENT1+2
.1a5537	28		plp		done        PLP
.1a5538	60		rts		            RTS
.1a5539					OP_INT_GTE
.1a5539	08		php		            PHP
.1a553a	c2 20		rep #$20	            REP #$20
.1a553c	a5 23		lda $0823	            LDA ARGUMENT1
.1a553e	c5 29		cmp $0829	            CMP ARGUMENT2
.1a5540	d0 0f		bne $1a5551	            BNE test_fully
.1a5542	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5544	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.1a5546	d0 09		bne $1a5551	            BNE test_fully
.1a5548	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a554b	85 23		sta $0823	            STA ARGUMENT1
.1a554d	85 25		sta $0825	            STA ARGUMENT1+2
.1a554f	80 13		bra $1a5564	            BRA done
.1a5551	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.1a5553	c5 23		cmp $0823	            CMP ARGUMENT1
.1a5555	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a5557	e5 25		sbc $0825	            SBC ARGUMENT1+2
.1a5559	50 03		bvc $1a555e	            BVC skip_eor
.1a555b	49 00 80	eor #$8000	            EOR #$8000
.1a555e	30 e8		bmi $1a5548	skip_eor    BMI ret_true
.1a5560	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a5562	64 25		stz $0825	            STZ ARGUMENT1+2
.1a5564	28		plp		done        PLP
.1a5565	60		rts		            RTS
.1a5566					OP_INT_LTE
.1a5566	08		php		            PHP
.1a5567	c2 20		rep #$20	            REP #$20
.1a5569	a5 23		lda $0823	            LDA ARGUMENT1
.1a556b	c5 29		cmp $0829	            CMP ARGUMENT2
.1a556d	d0 0f		bne $1a557e	            BNE test_fully
.1a556f	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5571	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.1a5573	d0 09		bne $1a557e	            BNE test_fully
.1a5575	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a5578	85 23		sta $0823	            STA ARGUMENT1
.1a557a	85 25		sta $0825	            STA ARGUMENT1+2
.1a557c	80 13		bra $1a5591	            BRA done
.1a557e	a5 23		lda $0823	test_fully  LDA ARGUMENT1
.1a5580	c5 29		cmp $0829	            CMP ARGUMENT2
.1a5582	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5584	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.1a5586	50 03		bvc $1a558b	            BVC skip_eor
.1a5588	49 00 80	eor #$8000	            EOR #$8000
.1a558b	30 e8		bmi $1a5575	skip_eor    BMI ret_true
.1a558d	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a558f	64 25		stz $0825	            STZ ARGUMENT1+2
.1a5591	28		plp		done        PLP
.1a5592	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\floats.s


;******  Processing file: src\C256/floats.s


;******  Processing file: src\C256/fp_math_defs.s

=$afe200				FP_MATH_CTRL0 = $AFE200         ; Read/write
=$08					FP_MATH_CTRL0_ADD = $08         ; 0: Substraction - 1: Addition
=$01					FP_CTRL0_CONV_0 = %00000001     ; Input 0 should be converted from 24.12 fixed point to floating point
=$02					FP_CTRL0_CONV_1 = %00000010     ; Input 1 should be converted from 24.12 fixed point to floating point
=$00					FP_ADD_IN0_MUX0 = %00000000     ; Adder input #0 is the output of MUX0
=$10					FP_ADD_IN0_MUX1 = %00010000     ; Adder input #0 is the output of MUX1
=$20					FP_ADD_IN0_MULT = %00100000     ; Adder input #0 is the output of the multiplier
=$30					FP_ADD_IN0_DIV  = %00110000     ; Adder input #0 is the output of the divider
=$00					FP_ADD_IN1_MUX0 = %00000000     ; Adder input #1 is the output of MUX0
=$40					FP_ADD_IN1_MUX1 = %01000000     ; Adder input #1 is the output of MUX1
=$80					FP_ADD_IN1_MULT = %10000000     ; Adder input #1 is the output of the multiplier
=$c0					FP_ADD_IN1_DIV  = %11000000     ; Adder input #1 is the output of the divider
=$afe201				FP_MATH_CTRL1 = $AFE201
=$00					FP_OUT_MULT = %00000000         ; Output is from the multiplier
=$01					FP_OUT_DIV  = %00000001         ; Output is from the divider
=$02					FP_OUT_ADD  = %00000010         ; Output is from the adder/subtracter
=$03					FP_OUT_ONE  = %00000011         ; Output is the constant '1.0'
=$afe202				FP_MATH_CTRL2 = $AFE202         ; Not Used - Reserved
=$afe203				FP_MATH_CTRL3 = $AFE203         ; Not Used - Reserved
=$afe204				FP_MATH_MULT_STAT = $AFE204     ; Status of the multiplier
=$01					FP_MULT_STAT_NAN  = $01         ; (NAN) Not a Number Status
=$02					FP_MULT_STAT_OVF  = $02         ; Overflow
=$04					FP_MULT_STAT_UDF  = $04         ; Underflow
=$08					FP_MULT_STAT_ZERO = $08         ; Zero
=$afe205				FP_MATH_DIV_STAT  = $AFE205     ; Status of the divider
=$01					FP_DIV_STAT_NAN       = $01     ; Not a number Status
=$02					FP_DIV_STAT_OVF       = $02     ; Overflow
=$04					FP_DIV_STAT_UDF       = $04     ; Underflow
=$08					FP_DIV_STAT_ZERO      = $08     ; Zero
=$10					FP_DIV_STAT_DIVBYZERO = $10     ; Division by Zero
=$afe206				FP_MATH_ADD_STAT  = $AFE206     ; Status of the adder/subtracter
=$01					FP_ADD_STAT_NAN  = $01          ; Not a number Status
=$02					FP_ADD_STAT_OVF  = $02          ; Overflow
=$04					FP_ADD_STAT_UDF  = $04          ; Underflow
=$08					FP_ADD_STAT_ZERO = $08          ; Zero
=$afe207				FP_MATH_CONV_STAT = $AFE207     ; Status of the fixed <=> float converters
=$01					FP_CONV_STAT_NAN  = $01         ; Not a number Status
=$02					FP_CONV_STAT_OVF  = $02         ; Overflow
=$04					FP_CONV_STAT_UDF  = $04         ; Underflow
=$afe208				FP_MATH_INPUT0_LL = $AFE208
=$afe209				FP_MATH_INPUT0_LH = $AFE209
=$afe20a				FP_MATH_INPUT0_HL = $AFE20A
=$afe20b				FP_MATH_INPUT0_HH = $AFE20B
=$afe20c				FP_MATH_INPUT1_LL = $AFE20C
=$afe20d				FP_MATH_INPUT1_LH = $AFE20D
=$afe20e				FP_MATH_INPUT1_HL = $AFE20E
=$afe20f				FP_MATH_INPUT1_HH = $AFE20F
=$afe208				FP_MATH_OUTPUT_FP_LL = $AFE208
=$afe209				FP_MATH_OUTPUT_FP_LH = $AFE209
=$afe20a				FP_MATH_OUTPUT_FP_HL = $AFE20A
=$afe20b				FP_MATH_OUTPUT_FP_HH = $AFE20B
=$afe20c				FP_MATH_OUTPUT_FIXED_LL = $AFE20C
=$afe20d				FP_MATH_OUTPUT_FIXED_LH = $AFE20D
=$afe20e				FP_MATH_OUTPUT_FIXED_HL = $AFE20E
=$afe20f				FP_MATH_OUTPUT_FIXED_HH = $AFE20F

;******  Return to file: src\C256/floats.s


;******  Processing file: src\C256/math_cop.s

.1a5593					UINT_DIV_A_X
.1a5593	08		php		                    PHP
.1a5594	c2 20		rep #$20	            REP #$20
.1a5596	8f 12 01 00	sta $000112	                    STA @l UNSIGNED_DIV_NUM_LO
.1a559a	8a		txa		                    TXA
.1a559b	8f 10 01 00	sta $000110	                    STA @l UNSIGNED_DIV_DEM_LO
.1a559f	af 16 01 00	lda $000116	                    LDA @l UNSIGNED_DIV_REM_LO
.1a55a3	aa		tax		                    TAX
.1a55a4	af 14 01 00	lda $000114	                    LDA @l UNSIGNED_DIV_QUO_LO
.1a55a8	28		plp		                    PLP
.1a55a9	60		rts		            RTS

;******  Return to file: src\C256/floats.s

.1a55aa					FIXINT_TO_FP
.1a55aa	08		php		                    PHP
.1a55ab	e2 20		sep #$20	            SEP #$20
.1a55ad	a9 03		lda #$03	                    LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.1a55af	8f 00 e2 af	sta $afe200	                    STA @l FP_MATH_CTRL0
.1a55b3	a9 00		lda #$00	                    LDA #FP_OUT_MULT
.1a55b5	8f 01 e2 af	sta $afe201	                    STA @l FP_MATH_CTRL1
.1a55b9	c2 20		rep #$20	            REP #$20
.1a55bb	a5 23		lda $0823	                    LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a55bd	8f 08 e2 af	sta $afe208	                    STA @l FP_MATH_INPUT0_LL
.1a55c1	a5 25		lda $0825	                    LDA ARGUMENT1+2
.1a55c3	8f 0a e2 af	sta $afe20a	                    STA @l FP_MATH_INPUT0_HL
.1a55c7	a9 00 00	lda #$0000	                    LDA #0
.1a55ca	8f 0c e2 af	sta $afe20c	                    STA @l FP_MATH_INPUT1_LL    ; ARGUMENT2 = 0100 0000 = 4096 in 20:12
.1a55ce	a9 00 01	lda #$0100	                    LDA #$0100
.1a55d1	8f 0e e2 af	sta $afe20e	                    STA @l FP_MATH_INPUT1_HL
.1a55d5	ea		nop		                    NOP
.1a55d6	ea		nop		                    NOP
.1a55d7	ea		nop		                    NOP
.1a55d8	ea		nop		                    NOP
.1a55d9	ea		nop		                    NOP
.1a55da	ea		nop		                    NOP
.1a55db	af 08 e2 af	lda $afe208	                    LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.1a55df	85 23		sta $0823	                    STA ARGUMENT1
.1a55e1	af 0a e2 af	lda $afe20a	                    LDA @l FP_MATH_OUTPUT_FP_HL
.1a55e5	85 25		sta $0825	                    STA ARGUMENT1+2
.1a55e7	a9 01 00	lda #$0001	                    LDA #TYPE_FLOAT
.1a55ea	85 27		sta $0827	                    STA ARGTYPE1
.1a55ec	28		plp		                    PLP
.1a55ed	60		rts		            RTS
.1a55ee	08		php		OP_FP_SUB       PHP
.1a55ef	e2 20		sep #$20	            SEP #$20
.1a55f1	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a55f3	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a55f7	80 09		bra $1a5602	                BRA FP_ADD_SUB
.1a55f9	08		php		OP_FP_ADD       PHP
.1a55fa	e2 20		sep #$20	            SEP #$20
.1a55fc	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a55fe	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a5602	a9 02		lda #$02	FP_ADD_SUB      LDA #FP_OUT_ADD
.1a5604	8f 01 e2 af	sta $afe201	                STA @lFP_MATH_CTRL1
.1a5608	c2 20		rep #$20	            REP #$20
.1a560a	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a560c	8f 08 e2 af	sta $afe208	                STA @lFP_MATH_INPUT0_LL
.1a5610	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5612	8f 0a e2 af	sta $afe20a	                STA @lFP_MATH_INPUT0_HL
.1a5616	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.1a5618	8f 0c e2 af	sta $afe20c	                STA @lFP_MATH_INPUT1_LL
.1a561c	a5 2b		lda $082b	                LDA ARGUMENT2+2
.1a561e	8f 0e e2 af	sta $afe20e	                STA @lFP_MATH_INPUT1_HL
.1a5622	ea		nop		                NOP
.1a5623	ea		nop		                NOP
.1a5624	ea		nop		                NOP
.1a5625	e2 20		sep #$20	            SEP #$20
.1a5627	af 06 e2 af	lda $afe206	                LDA @lFP_MATH_ADD_STAT      ; Check the status of the addition
.1a562b	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.1a562d	d0 10		bne $1a563f	                BNE fp_add_error            ; If an issue was raise, process the math error
.1a562f	c2 20		rep #$20	            REP #$20
.1a5631	af 08 e2 af	lda $afe208	                LDA @lFP_MATH_OUTPUT_FP_LL  ; Retrieve the results into ARGUMENT1
.1a5635	85 23		sta $0823	                STA ARGUMENT1
.1a5637	af 0a e2 af	lda $afe20a	                LDA @lFP_MATH_OUTPUT_FP_HL
.1a563b	85 25		sta $0825	                STA ARGUMENT1+2
.1a563d	28		plp		fp_add_done     PLP
.1a563e	60		rts		            RTS
.1a563f					fp_add_error
.1a563f	20 da 56	jsr $1a56da	            JSR FP_MATH_ERROR
.1a5642	80 f9		bra $1a563d	                BRA fp_add_done
.1a5644	08		php		OP_FP_DIV       PHP
.1a5645	e2 20		sep #$20	            SEP #$20
.1a5647	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a5649	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a564d	a9 00		lda #$00	                LDA #0
.1a564f	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a5653	c2 20		rep #$20	            REP #$20
.1a5655	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a5657	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a565b	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a565d	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5661	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.1a5663	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5667	a5 2b		lda $082b	                LDA ARGUMENT2+2
.1a5669	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a566d	ea		nop		                NOP
.1a566e	ea		nop		                NOP
.1a566f	ea		nop		                NOP
.1a5670	e2 20		sep #$20	            SEP #$20
.1a5672	af 05 e2 af	lda $afe205	                LDA @l FP_MATH_DIV_STAT     ; Check the status of the addition
.1a5676	29 17		and #$17	                AND #%00010111              ; Filter out the ZERO status
.1a5678	d0 10		bne $1a568a	                BNE fp_div_error            ; If an issue was raise, process the math error
.1a567a	c2 20		rep #$20	            REP #$20
.1a567c	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.1a5680	85 23		sta $0823	                STA ARGUMENT1
.1a5682	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5686	85 25		sta $0825	                STA ARGUMENT1+2
.1a5688	28		plp		fp_div_done     PLP
.1a5689	60		rts		            RTS
.1a568a					fp_div_error
.1a568a	20 da 56	jsr $1a56da	            JSR FP_MATH_ERROR
.1a568d	80 f9		bra $1a5688	                BRA fp_div_done
.1a568f	08		php		OP_FP_MUL       PHP
.1a5690	e2 20		sep #$20	            SEP #$20
.1a5692	a9 00		lda #$00	                LDA #FP_OUT_MULT
.1a5694	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5698	a9 00		lda #$00	                LDA #0
.1a569a	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a569e	c2 20		rep #$20	            REP #$20
.1a56a0	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a56a2	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a56a6	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a56a8	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a56ac	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.1a56ae	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a56b2	a5 2b		lda $082b	                LDA ARGUMENT2+2
.1a56b4	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a56b8	ea		nop		                NOP
.1a56b9	ea		nop		                NOP
.1a56ba	ea		nop		                NOP
.1a56bb	e2 20		sep #$20	            SEP #$20
.1a56bd	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT    ; Check the status of the addition
.1a56c1	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.1a56c3	d0 10		bne $1a56d5	                BNE fp_mul_error            ; If an issue was raise, process the math error
.1a56c5	c2 20		rep #$20	            REP #$20
.1a56c7	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.1a56cb	85 23		sta $0823	                STA ARGUMENT1
.1a56cd	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a56d1	85 25		sta $0825	                STA ARGUMENT1+2
.1a56d3	28		plp		fp_mul_done     PLP
.1a56d4	60		rts		            RTS
.1a56d5					fp_mul_error
.1a56d5	20 da 56	jsr $1a56da	            JSR FP_MATH_ERROR
.1a56d8	80 f9		bra $1a56d3	                BRA fp_mul_done
.1a56da					FP_MATH_ERROR
.1a56da	e2 20		sep #$20	            SEP #$20
.1a56dc	89 01		bit #$01	                BIT #FP_ADD_STAT_NAN        ; Is there a NaN condition?
.1a56de	f0 20		beq $1a5700	                BEQ check_over              ; No: check for overflow
.1a56e0	00		brk #		                BRK
.1a56e1	08		php		            PHP
.1a56e2	c2 20		rep #$20	            REP #$20
.1a56e4	48		pha		            PHA
.1a56e5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a56e8	5b		tcd		            TCD
.1a56e9	68		pla		            PLA
.1a56ea	28		plp		            PLP
.1a56eb	e2 20		sep #$20	            SEP #$20
.1a56ed	a9 0c		lda #$0c	            LDA #ERR_NAN
.1a56ef	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a56f3	c2 20		rep #$20	            REP #$20
.1a56f5	29 ff 00	and #$00ff	            AND #$00FF
.1a56f8	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a56fb	e2 20		sep #$20	            SEP #$20
.1a56fd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5700	89 02		bit #$02	check_over      BIT #FP_ADD_STAT_OVF        ; Is ther an overflow condition?
.1a5702	f0 1f		beq $1a5723	                BEQ check_under             ; No: check for underflow
.1a5704	08		php		            PHP
.1a5705	c2 20		rep #$20	            REP #$20
.1a5707	48		pha		            PHA
.1a5708	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a570b	5b		tcd		            TCD
.1a570c	68		pla		            PLA
.1a570d	28		plp		            PLP
.1a570e	e2 20		sep #$20	            SEP #$20
.1a5710	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.1a5712	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5716	c2 20		rep #$20	            REP #$20
.1a5718	29 ff 00	and #$00ff	            AND #$00FF
.1a571b	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a571e	e2 20		sep #$20	            SEP #$20
.1a5720	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5723	89 04		bit #$04	check_under     BIT #FP_ADD_STAT_UDF        ; Is there an underflow condition?
.1a5725	f0 1f		beq $1a5746	                BEQ done                    ; No: we should just return... this probably shouldn't happen
.1a5727	08		php		            PHP
.1a5728	c2 20		rep #$20	            REP #$20
.1a572a	48		pha		            PHA
.1a572b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a572e	5b		tcd		            TCD
.1a572f	68		pla		            PLA
.1a5730	28		plp		            PLP
.1a5731	e2 20		sep #$20	            SEP #$20
.1a5733	a9 0e		lda #$0e	            LDA #ERR_UNDERFLOW
.1a5735	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5739	c2 20		rep #$20	            REP #$20
.1a573b	29 ff 00	and #$00ff	            AND #$00FF
.1a573e	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a5741	e2 20		sep #$20	            SEP #$20
.1a5743	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5746					done
.1a5746	60		rts		            RTS
.1a5747					FP_MUL10
.1a5747	08		php		                PHP
.1a5748	e2 20		sep #$20	            SEP #$20
.1a574a	a9 00		lda #$00	                LDA #FP_OUT_MULT                ; Set for multiplication
.1a574c	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5750	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1            ; Input 1 is fixed point
.1a5752	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5756	c2 20		rep #$20	            REP #$20
.1a5758	a9 00 a0	lda #$a000	                LDA #$A000                      ; 10 is one factor
.1a575b	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a575f	a9 00 00	lda #$0000	                LDA #0
.1a5762	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5766	a5 23		lda $0823	                LDA ARGUMENT1                   ; N is the other
.1a5768	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a576c	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a576e	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5772	ea		nop		                NOP
.1a5773	ea		nop		                NOP
.1a5774	ea		nop		                NOP
.1a5775	e2 20		sep #$20	            SEP #$20
.1a5777	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT        ; Check the status
.1a577b	89 07		bit #$07	                BIT #FP_MULT_STAT_NAN | FP_MULT_STAT_OVF | FP_MULT_STAT_UDF
.1a577d	f0 01		beq $1a5780	                BEQ ret_result
.1a577f	00		brk #		                BRK                             ; There was an error...
.1a5780					ret_result
.1a5780	c2 20		rep #$20	            REP #$20
.1a5782	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL     ; Save result back
.1a5786	85 23		sta $0823	                STA ARGUMENT1
.1a5788	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a578c	85 25		sta $0825	                STA ARGUMENT1+2
.1a578e	28		plp		                PLP
.1a578f	60		rts		            RTS
.1a5790					FP_DIV10
.1a5790	08		php		                PHP
.1a5791	e2 20		sep #$20	            SEP #$20
.1a5793	a9 01		lda #$01	                LDA #FP_OUT_DIV             ; Set for multiplication
.1a5795	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5799	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1        ; Input 1 is fixed point
.1a579b	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a579f	c2 20		rep #$20	            REP #$20
.1a57a1	a9 00 a0	lda #$a000	                LDA #$A000                  ; 10 is one factor
.1a57a4	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a57a8	a9 00 00	lda #$0000	                LDA #0
.1a57ab	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a57af	a5 23		lda $0823	                LDA ARGUMENT1               ; N is the other
.1a57b1	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a57b5	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a57b7	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a57bb	ea		nop		                NOP
.1a57bc	ea		nop		                NOP
.1a57bd	ea		nop		                NOP
.1a57be	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Save result back
.1a57c2	85 23		sta $0823	                STA ARGUMENT1
.1a57c4	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a57c8	85 25		sta $0825	                STA ARGUMENT1+2
.1a57ca	28		plp		                PLP
.1a57cb	60		rts		            RTS

;******  Return to file: src\floats.s

.1a57cc					FARG1EQ0
.1a57cc	08		php		                PHP
.1a57cd	c2 20		rep #$20	            REP #$20
.1a57cf	a5 23		lda $0823	                LDA ARGUMENT1
.1a57d1	d0 0a		bne $1a57dd	                BNE return_false
.1a57d3	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a57d5	29 ff 7f	and #$7fff	                AND #$7FFF              ; Mask off the sign bit
.1a57d8	d0 03		bne $1a57dd	                BNE return_false
.1a57da	28		plp		return_true     PLP
.1a57db	38		sec		                SEC
.1a57dc	60		rts		            RTS
.1a57dd	28		plp		return_false    PLP
.1a57de	18		clc		                CLC
.1a57df	60		rts		            RTS
.1a57e0					SHIFTDEC
.1a57e0	08		php		                PHP
.1a57e1	e2 20		sep #$20	            SEP #$20
.1a57e3	38		sec		                SEC                     ; Convert '0'..'9' to it's number
.1a57e4	e9 30		sbc #$30	                SBC #'0'
.1a57e6	20 3f 05	jsr $1a053f	            JSR MULINT10
.1a57e9	c2 20		rep #$20	            REP #$20
.1a57eb	29 ff 00	and #$00ff	                AND #$00FF              ; Add the number to ARGUMENT1
.1a57ee	18		clc		                CLC
.1a57ef	65 23		adc $0823	                ADC ARGUMENT1
.1a57f1	85 23		sta $0823	                STA ARGUMENT1
.1a57f3	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a57f5	69 00 00	adc #$0000	                ADC #0
.1a57f8	85 25		sta $0825	                STA ARGUMENT1+2
.1a57fa	28		plp		                PLP
.1a57fb	60		rts		            RTS
.1a57fc					SHIFTHEX
.1a57fc	08		php		                PHP
.1a57fd	e2 20		sep #$20	            SEP #$20
.1a57ff	c9 30		cmp #$30	                CMP #'0'                ; Process 0-9
.1a5801	90 04		bcc $1a5807	                BLT not_09
.1a5803	c9 3a		cmp #$3a	                CMP #'9'+1
.1a5805	90 1c		bcc $1a5823	                BLT is_09
.1a5807	c9 61		cmp #$61	not_09          CMP #'a'                ; Process lowercase A-F
.1a5809	90 04		bcc $1a580f	                BLT not_lc
.1a580b	c9 67		cmp #$67	                CMP #'f'+1
.1a580d	90 0a		bcc $1a5819	                BLT is_lc
.1a580f	c9 41		cmp #$41	not_lc          CMP #'A'                ; Process uppercase A-F
.1a5811	90 04		bcc $1a5817	                BLT not_uc
.1a5813	c9 47		cmp #$47	                CMP #'F'+1
.1a5815	90 07		bcc $1a581e	                BLT is_uc
.1a5817	80 31		bra $1a584a	not_uc          BRA done                ; Just return if we couldn't convert... this shouldn't happen
.1a5819	38		sec		is_lc           SEC                     ; Convert 'a'-'f' to the actual number
.1a581a	e9 57		sbc #$57	                SBC #'a'-10
.1a581c	80 08		bra $1a5826	                BRA shift
.1a581e	38		sec		is_uc           SEC                     ; Convert 'A'-'F' to the actual number
.1a581f	e9 37		sbc #$37	                SBC #'A'-10
.1a5821	80 03		bra $1a5826	                BRA shift
.1a5823	38		sec		is_09           SEC                     ; Convert '0'-'9' to the actual number
.1a5824	e9 30		sbc #$30	                SBC #'0'
.1a5826					shift
.1a5826	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a5828	26 24		rol $0824	                ROL ARGUMENT1+1
.1a582a	26 25		rol $0825	                ROL ARGUMENT1+2
.1a582c	26 26		rol $0826	                ROL ARGUMENT1+3
.1a582e	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a5830	26 24		rol $0824	                ROL ARGUMENT1+1
.1a5832	26 25		rol $0825	                ROL ARGUMENT1+2
.1a5834	26 26		rol $0826	                ROL ARGUMENT1+3
.1a5836	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a5838	26 24		rol $0824	                ROL ARGUMENT1+1
.1a583a	26 25		rol $0825	                ROL ARGUMENT1+2
.1a583c	26 26		rol $0826	                ROL ARGUMENT1+3
.1a583e	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a5840	26 24		rol $0824	                ROL ARGUMENT1+1
.1a5842	26 25		rol $0825	                ROL ARGUMENT1+2
.1a5844	26 26		rol $0826	                ROL ARGUMENT1+3
.1a5846	05 23		ora $0823	                ORA ARGUMENT1           ; Add the number to it
.1a5848	85 23		sta $0823	                STA ARGUMENT1
.1a584a	28		plp		done            PLP
.1a584b	60		rts		            RTS
.1a584c					SHIFTBIN
.1a584c	08		php		                PHP
.1a584d	e2 20		sep #$20	            SEP #$20
.1a584f	c9 30		cmp #$30	                CMP #'0'                ; If the character is '0'...
.1a5851	f0 06		beq $1a5859	                BEQ shift_0             ; Shift a 0 onto ARGUMENT1
.1a5853	c9 31		cmp #$31	                CMP #'1'                ; If the character is '1'...
.1a5855	f0 0a		beq $1a5861	                BEQ shift_1             ; Shift a 1 onto ARGUMENT1
.1a5857	80 0f		bra $1a5868	                BRA done
.1a5859					shift_0
.1a5859	c2 20		rep #$20	            REP #$20
.1a585b	06 23		asl $0823	                ASL ARGUMENT1
.1a585d	26 25		rol $0825	                ROL ARGUMENT1+2
.1a585f	80 07		bra $1a5868	                BRA done
.1a5861					shift_1
.1a5861	c2 20		rep #$20	            REP #$20
.1a5863	38		sec		                SEC
.1a5864	26 23		rol $0823	                ROL ARGUMENT1
.1a5866	26 25		rol $0825	                ROL ARGUMENT1+2
.1a5868	28		plp		done            PLP
.1a5869	60		rts		            RTS
.1a586a					FP_POW10
.1a586a	08		php		                PHP
.1a586b	e2 30		sep #$30	            SEP #$30
.1a586d	a5 61		lda $0861	                LDA MARG4
.1a586f	f0 0d		beq $1a587e	                BEQ return_1
.1a5871	aa		tax		                TAX
.1a5872	a5 69		lda $0869	                LDA MARG6
.1a5874	d0 15		bne $1a588b	                BNE do_div
.1a5876	a9 00		lda #$00	                LDA #FP_OUT_MULT                    ; We'll multiply
.1a5878	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a587c	80 15		bra $1a5893	                BRA start_loop
.1a587e					return_1
.1a587e	e2 20		sep #$20	            SEP #$20
.1a5880	a9 03		lda #$03	                LDA #FP_OUT_ONE                     ; We want to return a 1.0
.1a5882	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5886	ea		nop		                NOP
.1a5887	ea		nop		                NOP
.1a5888	ea		nop		                NOP
.1a5889	80 62		bra $1a58ed	                BRA ret_result                      ; And return the result
.1a588b					do_div
.1a588b	e2 20		sep #$20	            SEP #$20
.1a588d	a9 01		lda #$01	                LDA #FP_OUT_DIV                     ; We'll divide
.1a588f	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5893					start_loop
.1a5893	e2 20		sep #$20	            SEP #$20
.1a5895	a9 43		lda #$43	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.1a5897	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.1a589b	c2 20		rep #$20	            REP #$20
.1a589d	a9 00 10	lda #$1000	                LDA #$1000                          ; Input 0 = 1.0
.1a58a0	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a58a4	a9 00 00	lda #$0000	                LDA #0
.1a58a7	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a58ab					loop
.1a58ab	c2 20		rep #$20	            REP #$20
.1a58ad	a9 00 a0	lda #$a000	                LDA #$A000                          ; Input 1 = 10.0
.1a58b0	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a58b4	a9 00 00	lda #$0000	                LDA #0
.1a58b7	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a58bb	ea		nop		                NOP                                 ; Wait for the operation to complete
.1a58bc	ea		nop		                NOP
.1a58bd	ea		nop		                NOP
.1a58be	ca		dex		                DEX                                 ; Count down
.1a58bf	f0 2c		beq $1a58ed	                BEQ ret_result                      ; If 0, then we're done
.1a58c1	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; SCRATCH <-- Result
.1a58c5	8f 0c 08 00	sta $00080c	                STA @l SCRATCH
.1a58c9	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a58cd	8f 0e 08 00	sta $00080e	                STA @l SCRATCH+2
.1a58d1	e2 20		sep #$20	            SEP #$20
.1a58d3	a9 42		lda #$42	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_1
.1a58d5	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.1a58d9	c2 20		rep #$20	            REP #$20
.1a58db	af 0c 08 00	lda $00080c	                LDA @l SCRATCH                      ; Input 0 <-- SCRATCH
.1a58df	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a58e3	af 0e 08 00	lda $00080e	                LDA @l SCRATCH+2
.1a58e7	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a58eb	80 be		bra $1a58ab	                BRA loop
.1a58ed					ret_result
.1a58ed	c2 20		rep #$20	            REP #$20
.1a58ef	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; Return the result
.1a58f3	85 23		sta $0823	                STA ARGUMENT1
.1a58f5	af 0a e2 af	lda $afe20a	                LDA FP_MATH_OUTPUT_FP_HL
.1a58f9	85 25		sta $0825	                STA ARGUMENT1+2
.1a58fb	e2 20		sep #$20	            SEP #$20
.1a58fd	a9 01		lda #$01	                LDA #TYPE_FLOAT
.1a58ff	85 27		sta $0827	                STA ARGTYPE1
.1a5901	28		plp		done            PLP
.1a5902	60		rts		            RTS
.1a5903					PACKFLOAT
.1a5903	08		php		                PHP
.1a5904	c2 20		rep #$20	            REP #$20
.1a5906	a5 5d		lda $085d	            LDA MARG3
.1a5908	85 23		sta $0823	            STA ARGUMENT1
.1a590a	a5 5f		lda $085f	            LDA MARG3+2
.1a590c	85 25		sta $0825	            STA ARGUMENT1+2
.1a590e	20 1c 5b	jsr $1a5b1c	            JSR ITOF
.1a5911	c2 20		rep #$20	            REP #$20
.1a5913	a5 23		lda $0823	            LDA ARGUMENT1
.1a5915	85 29		sta $0829	            STA ARGUMENT2
.1a5917	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5919	85 2b		sta $082b	            STA ARGUMENT2+2
.1a591b	c2 20		rep #$20	            REP #$20
.1a591d	a5 59		lda $0859	            LDA MARG2
.1a591f	85 23		sta $0823	            STA ARGUMENT1
.1a5921	a5 5b		lda $085b	            LDA MARG2+2
.1a5923	85 25		sta $0825	            STA ARGUMENT1+2
.1a5925	20 44 56	jsr $1a5644	            JSR OP_FP_DIV
.1a5928	c2 20		rep #$20	            REP #$20
.1a592a	a5 55		lda $0855	            LDA MARG1
.1a592c	85 29		sta $0829	            STA ARGUMENT2
.1a592e	a5 57		lda $0857	            LDA MARG1+2
.1a5930	85 2b		sta $082b	            STA ARGUMENT2+2
.1a5932	20 f9 55	jsr $1a55f9	            JSR OP_FP_ADD
.1a5935	c2 20		rep #$20	            REP #$20
.1a5937	a5 23		lda $0823	            LDA ARGUMENT1
.1a5939	85 29		sta $0829	            STA ARGUMENT2
.1a593b	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a593d	85 2b		sta $082b	            STA ARGUMENT2+2
.1a593f	20 6a 58	jsr $1a586a	            JSR FP_POW10
.1a5942	20 8f 56	jsr $1a568f	            JSR OP_FP_MUL
.1a5945	c2 20		rep #$20	            REP #$20
.1a5947	a5 65		lda $0865	                LDA MARG5                       ; Check to see if the float should be negative
.1a5949	f0 07		beq $1a5952	                BEQ set_float_type              ; If not, just set the type
.1a594b	a5 25		lda $0825	                LDA ARGUMENT1+2                 ; If so, set the sign bit
.1a594d	09 00 80	ora #$8000	                ORA #$8000
.1a5950	85 25		sta $0825	                STA ARGUMENT1+2
.1a5952					set_float_type
.1a5952	e2 20		sep #$20	            SEP #$20
.1a5954	a9 01		lda #$01	                LDA #TYPE_FLOAT                 ; Set the type to float... ready for returning!
.1a5956	85 27		sta $0827	                STA ARGTYPE1
.1a5958	28		plp		                PLP
.1a5959	60		rts		            RTS
.1a595a					PARSENUM
.1a595a	5a		phy		                PHY
.1a595b	08		php		                PHP
.1a595c	c2 30		rep #$30	            REP #$30
.1a595e	64 23		stz $0823	                STZ ARGUMENT1       ; This will be the accumulator for building the number
.1a5960	64 25		stz $0825	                STZ ARGUMENT1+2
.1a5962	64 55		stz $0855	                STZ MARG1           ; This will be the integer portion of the mantissa for floats
.1a5964	64 57		stz $0857	                STZ MARG1+2
.1a5966	64 65		stz $0865	                STZ MARG5           ; MARG5 will be the negative flag for the number
.1a5968	64 59		stz $0859	                STZ MARG2           ; This will be the denominator of the fractional part of the mantissa
.1a596a	64 5b		stz $085b	                STZ MARG2+2
.1a596c	a9 01 00	lda #$0001	                LDA #1
.1a596f	85 5d		sta $085d	                STA MARG3           ; This will be the divisor of the fractional part of the mantissa
.1a5971	64 5f		stz $085f	                STZ MARG3+2
.1a5973	64 61		stz $0861	                STZ MARG4           ; This will be the exponent of a float
.1a5975	64 63		stz $0863	                STZ MARG4+2
.1a5977	64 69		stz $0869	                STZ MARG6           ; MARG6 will be the negative flag for the exponent
.1a5979					s0
.1a5979	e2 20		sep #$20	            SEP #$20
.1a597b	a0 00 00	ldy #$0000	                LDY #0
.1a597e	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the first byte
.1a5980	c9 2b		cmp #$2b	                CMP #'+'
.1a5982	f0 33		beq $1a59b7	                BEQ s1_drop         ; '+' --> S1, drop
.1a5984	c9 2d		cmp #$2d	                CMP #'-'
.1a5986	f0 2b		beq $1a59b3	                BEQ s1_negative     ; Flag that the number is negative
.1a5988	c9 26		cmp #$26	                CMP #'&'
.1a598a	f0 3a		beq $1a59c6	                BEQ s2_drop         ; '&' --> S2, drop
.1a598c	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a598f	90 03		bcc $1a5994	                BCC syntax_err
.1a5991	82 ac 00	brl $1a5a40	                BRL s7_shift        ; '0'-'9' --> S7, emit
.1a5994					syntax_err
.1a5994	08		php		            PHP
.1a5995	c2 20		rep #$20	            REP #$20
.1a5997	48		pha		            PHA
.1a5998	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a599b	5b		tcd		            TCD
.1a599c	68		pla		            PLA
.1a599d	28		plp		            PLP
.1a599e	e2 20		sep #$20	            SEP #$20
.1a59a0	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a59a2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a59a6	c2 20		rep #$20	            REP #$20
.1a59a8	29 ff 00	and #$00ff	            AND #$00FF
.1a59ab	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a59ae	e2 20		sep #$20	            SEP #$20
.1a59b0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a59b3	a9 01		lda #$01	s1_negative     LDA #1              ; Set the negative flag for the mantissa
.1a59b5	85 65		sta $0865	                STA MARG5
.1a59b7	c8		iny		s1_drop         INY                 ; Drop the character...
.1a59b8	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next
.1a59ba	c9 26		cmp #$26	                CMP #'&'
.1a59bc	f0 08		beq $1a59c6	                BEQ s2_drop         ; '&' --> S2, drop the '&'
.1a59be	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a59c1	90 d1		bcc $1a5994	                BCC syntax_err
.1a59c3	82 7a 00	brl $1a5a40	                BRL s7_shift        ; '0'-'9' --> S7, shift
.1a59c6	c8		iny		s2_drop         INY                 ; Drop the character
.1a59c7	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.1a59c9	c9 68		cmp #$68	                CMP #'h'
.1a59cb	f0 0e		beq $1a59db	                BEQ s3_drop         ; 'h', 'H' --> S3, drop
.1a59cd	c9 48		cmp #$48	                CMP #'H'
.1a59cf	f0 0a		beq $1a59db	                BEQ s3_drop
.1a59d1	c9 62		cmp #$62	                CMP #'b'
.1a59d3	f0 4c		beq $1a5a21	                BEQ s5_drop         ; 'b', 'B' --> S5, drop
.1a59d5	c9 42		cmp #$42	                CMP #'B'
.1a59d7	f0 48		beq $1a5a21	                BEQ s5_drop
.1a59d9	80 b9		bra $1a5994	                BRA syntax_err
.1a59db	c8		iny		s3_drop         INY                 ; Drop the character
.1a59dc	b7 00		lda [$0800],y	s3              LDA [BIP],Y         ; Get the next character
.1a59de	20 d1 04	jsr $1a04d1	            JSR ISHEX
.1a59e1	b0 02		bcs $1a59e5	                BCS s4_shift
.1a59e3	80 af		bra $1a5994	                BRA syntax_err
.1a59e5					s4_shift
.1a59e5	20 fc 57	jsr $1a57fc	            JSR SHIFTHEX
.1a59e8	c8		iny		                INY
.1a59e9	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.1a59eb	20 d1 04	jsr $1a04d1	            JSR ISHEX
.1a59ee	b0 f5		bcs $1a59e5	                BCS s4_shift        ; '0'-'9','A'-'F' --> S4, shift
.1a59f0					ret_integer
.1a59f0	e2 20		sep #$20	            SEP #$20
.1a59f2	a5 65		lda $0865	                LDA MARG5           ; check if the number should be negative
.1a59f4	f0 11		beq $1a5a07	                BEQ set_int_type    ; If not, just set the type and return
.1a59f6	c2 20		rep #$20	            REP #$20
.1a59f8	38		sec		                SEC                 ; If so, negate it
.1a59f9	a9 00 00	lda #$0000	                LDA #0
.1a59fc	e5 23		sbc $0823	                SBC ARGUMENT1
.1a59fe	85 23		sta $0823	                STA ARGUMENT1
.1a5a00	a9 00 00	lda #$0000	                LDA #0
.1a5a03	e5 25		sbc $0825	                SBC ARGUMENT1+2
.1a5a05	85 25		sta $0825	                STA ARGUMENT1+2
.1a5a07					set_int_type
.1a5a07	e2 20		sep #$20	            SEP #$20
.1a5a09	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; Return an integer
.1a5a0b	85 27		sta $0827	                STA ARGTYPE1
.1a5a0d					stop
.1a5a0d	c2 20		rep #$20	            REP #$20
.1a5a0f	18		clc		                CLC
.1a5a10	98		tya		                TYA
.1a5a11	65 00		adc $0800	                ADC BIP
.1a5a13	85 00		sta $0800	                STA BIP
.1a5a15	a5 02		lda $0802	                LDA BIP+2
.1a5a17	69 00 00	adc #$0000	                ADC #0
.1a5a1a	85 02		sta $0802	                STA BIP+2
.1a5a1c	e2 20		sep #$20	            SEP #$20
.1a5a1e	28		plp		                PLP
.1a5a1f	7a		ply		                PLY
.1a5a20	60		rts		            RTS
.1a5a21	c8		iny		s5_drop         INY                     ; Drop the character
.1a5a22	b7 00		lda [$0800],y	s5              LDA [BIP],Y             ; Get the next character
.1a5a24	c9 30		cmp #$30	                CMP #'0'
.1a5a26	f0 07		beq $1a5a2f	                BEQ s6_shift            ; '0', '1' --> S6, shift
.1a5a28	c9 31		cmp #$31	                CMP #'1'
.1a5a2a	f0 03		beq $1a5a2f	                BEQ s6_shift
.1a5a2c	82 65 ff	brl $1a5994	                BRL syntax_err
.1a5a2f					s6_shift
.1a5a2f	20 4c 58	jsr $1a584c	            JSR SHIFTBIN
.1a5a32	c8		iny		                INY
.1a5a33	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5a35	c9 30		cmp #$30	                CMP #'0'                ; '0', '1' --> S6, shift
.1a5a37	f0 f6		beq $1a5a2f	                BEQ s6_shift
.1a5a39	c9 31		cmp #$31	                CMP #'1'
.1a5a3b	f0 f2		beq $1a5a2f	                BEQ s6_shift
.1a5a3d	82 b0 ff	brl $1a59f0	                BRL ret_integer         ; Return integer
.1a5a40					s7_shift
.1a5a40	20 e0 57	jsr $1a57e0	            JSR SHIFTDEC
.1a5a43	c8		iny		                INY
.1a5a44	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5a46	c9 2e		cmp #$2e	                CMP #'.'                ; '.' --> S8, drop and preserve mantissa
.1a5a48	f0 08		beq $1a5a52	                BEQ s8_mantissa
.1a5a4a	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a5a4d	b0 f1		bcs $1a5a40	                BCS s7_shift
.1a5a4f	82 9e ff	brl $1a59f0	                BRL ret_integer         ; Return integer
.1a5a52					s8_mantissa
.1a5a52	c2 20		rep #$20	            REP #$20
.1a5a54	20 1c 5b	jsr $1a5b1c	            JSR ITOF
.1a5a57	c2 20		rep #$20	            REP #$20
.1a5a59	a5 23		lda $0823	            LDA ARGUMENT1
.1a5a5b	85 55		sta $0855	            STA MARG1
.1a5a5d	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5a5f	85 57		sta $0857	            STA MARG1+2
.1a5a61	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the decimal
.1a5a63	64 25		stz $0825	                STZ ARGUMENT1+2
.1a5a65	e2 20		sep #$20	            SEP #$20
.1a5a67	80 36		bra $1a5a9f	                BRA s8_drop
.1a5a69					s8_shift
.1a5a69	20 e0 57	jsr $1a57e0	            JSR SHIFTDEC
.1a5a6c	c2 20		rep #$20	            REP #$20
.1a5a6e	a5 5f		lda $085f	                LDA MARG3+2             ; high 16 bits
.1a5a70	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.1a5a74	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.1a5a77	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.1a5a7b	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to high 16 bits of MARG3
.1a5a7f	85 5f		sta $085f	                STA MARG3+2
.1a5a81	a5 5d		lda $085d	                LDA MARG3
.1a5a83	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.1a5a87	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.1a5a8a	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.1a5a8e	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to MARG3
.1a5a92	85 5d		sta $085d	                STA MARG3
.1a5a94	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.1a5a98	18		clc		                CLC
.1a5a99	65 5f		adc $085f	                ADC MARG3+2
.1a5a9b	85 5f		sta $085f	                STA MARG3+2
.1a5a9d	e2 20		sep #$20	            SEP #$20
.1a5a9f					s8_drop
.1a5a9f	c8		iny		                INY
.1a5aa0	b7 00		lda [$0800],y	                LDA [BIP],Y
.1a5aa2	c9 65		cmp #$65	                CMP #'e'                ; 'E' --> S9, drop
.1a5aa4	f0 24		beq $1a5aca	                BEQ s9_drop
.1a5aa6	c9 45		cmp #$45	                CMP #'E'
.1a5aa8	f0 20		beq $1a5aca	                BEQ s9_drop
.1a5aaa	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a5aad	b0 ba		bcs $1a5a69	                BCS s8_shift
.1a5aaf	c2 20		rep #$20	            REP #$20
.1a5ab1	20 1c 5b	jsr $1a5b1c	            JSR ITOF
.1a5ab4	c2 20		rep #$20	            REP #$20
.1a5ab6	a5 23		lda $0823	            LDA ARGUMENT1
.1a5ab8	85 59		sta $0859	            STA MARG2
.1a5aba	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5abc	85 5b		sta $085b	            STA MARG2+2
.1a5abe	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.1a5ac0	64 25		stz $0825	                STZ ARGUMENT1+2
.1a5ac2	20 03 59	jsr $1a5903	            JSR PACKFLOAT
.1a5ac5	e2 20		sep #$20	            SEP #$20
.1a5ac7	82 43 ff	brl $1a5a0d	                BRL stop
.1a5aca					s9_drop
.1a5aca	c2 20		rep #$20	            REP #$20
.1a5acc	20 1c 5b	jsr $1a5b1c	            JSR ITOF
.1a5acf	c2 20		rep #$20	            REP #$20
.1a5ad1	a5 23		lda $0823	            LDA ARGUMENT1
.1a5ad3	85 59		sta $0859	            STA MARG2
.1a5ad5	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5ad7	85 5b		sta $085b	            STA MARG2+2
.1a5ad9	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.1a5adb	64 25		stz $0825	                STZ ARGUMENT1+2
.1a5add	e2 20		sep #$20	            SEP #$20
.1a5adf	c8		iny		                INY
.1a5ae0	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5ae2	c9 2b		cmp #$2b	                CMP #'+'
.1a5ae4	f0 10		beq $1a5af6	                BEQ s10_drop            ; '+' --> S10, drop
.1a5ae6	c9 2d		cmp #$2d	                CMP #'-'
.1a5ae8	f0 08		beq $1a5af2	                BEQ s10_setneg          ; '-' --> S10, set exponent is negative
.1a5aea	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a5aed	b0 12		bcs $1a5b01	                BCS S11_shift           ; '0'-'9' --> S11, shift
.1a5aef	82 a2 fe	brl $1a5994	                BRL syntax_err
.1a5af2					s10_setneg
.1a5af2	a9 01		lda #$01	                LDA #1                  ; Set that the exponent should be negative
.1a5af4	85 69		sta $0869	                STA MARG6
.1a5af6					s10_drop
.1a5af6	c8		iny		                INY
.1a5af7	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5af9	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a5afc	b0 03		bcs $1a5b01	                BCS s11_shift
.1a5afe	82 93 fe	brl $1a5994	                BRL syntax_err
.1a5b01					s11_shift
.1a5b01	20 e0 57	jsr $1a57e0	            JSR SHIFTDEC
.1a5b04	c8		iny		                INY
.1a5b05	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5b07	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a5b0a	b0 f5		bcs $1a5b01	                BCS s11_shift
.1a5b0c	c2 20		rep #$20	            REP #$20
.1a5b0e	a5 23		lda $0823	            LDA ARGUMENT1
.1a5b10	85 61		sta $0861	            STA MARG4
.1a5b12	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5b14	85 63		sta $0863	            STA MARG4+2
.1a5b16	20 03 59	jsr $1a5903	            JSR PACKFLOAT
.1a5b19	82 f1 fe	brl $1a5a0d	                BRL stop
.1a5b1c					ITOF
.1a5b1c	08		php		                PHP
.1a5b1d	20 aa 55	jsr $1a55aa	            JSR FIXINT_TO_FP
.1a5b20	28		plp		done            PLP
.1a5b21	60		rts		            RTS
.1a5b22					FTOI
.1a5b22	08		php		                PHP
.1a5b23					LOCALS
>0001					l_sign          .byte ?
>0002					l_exponent      .byte ?
>0003					l_mantissa      .dword ?
.1a5b23	c2 20		rep #$20	            REP #$20
.1a5b25	a9 19 5e	lda #$5e19	                LDA #<>FP_1_0
.1a5b28	85 29		sta $0829	                STA ARGUMENT2
.1a5b2a	a9 1a 00	lda #$001a	                LDA #(FP_1_0 >> 16)
.1a5b2d	85 2b		sta $082b	                STA ARGUMENT2+2
.1a5b2f	e2 20		sep #$20	            SEP #$20
.1a5b31	a9 01		lda #$01	                LDA #TYPE_FLOAT
.1a5b33	85 2d		sta $082d	                STA ARGTYPE2
.1a5b35	c2 20		rep #$20	            REP #$20
.1a5b37	20 f5 5b	jsr $1a5bf5	            JSR FP_COMPARE
.1a5b3a	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a5b3d	d0 0c		bne $1a5b4b	                BNE alloc_locals        ; No: get ready to do the full conversion
.1a5b3f	a9 00 00	lda #$0000	                LDA #0
.1a5b42	8d 23 08	sta $0823	                STA @w ARGUMENT1        ; Yes: Return 0
.1a5b45	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.1a5b48	82 a1 00	brl $1a5bec	                BRL done
.1a5b4b	f4 00 00	pea #$0000	alloc_locals    PEA #0                  ; Reserve space for the locals
.1a5b4e	f4 00 00	pea #$0000	                PEA #0
.1a5b51	f4 00 00	pea #$0000	                PEA #0
.1a5b54	e2 20		sep #$20	            SEP #$20
.1a5b56	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3      ; Preserve the sign bit
.1a5b59	29 80		and #$80	                AND #$80
.1a5b5b	83 01		sta $01,s	                STA l_sign
.1a5b5d	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2      ; Preserve the exponent
.1a5b60	2a		rol a		                ROL A
.1a5b61	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3
.1a5b64	2a		rol a		                ROL A
.1a5b65	83 02		sta $02,s	                STA l_exponent
.1a5b67	a9 00		lda #$00	save_mantissa   LDA #0                  ; Save the mantissa (with the implied 1)
.1a5b69	83 06		sta $06,s	                STA l_mantissa+3
.1a5b6b	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2
.1a5b6e	09 80		ora #$80	                ORA #$80
.1a5b70	83 05		sta $05,s	                STA l_mantissa+2
.1a5b72	ad 24 08	lda $0824	                LDA @w ARGUMENT1+1
.1a5b75	83 04		sta $04,s	                STA l_mantissa+1
.1a5b77	ad 23 08	lda $0823	                LDA @w ARGUMENT1
.1a5b7a	83 03		sta $03,s	                STA l_mantissa
.1a5b7c	a3 02		lda $02,s	                LDA l_exponent
.1a5b7e	c9 96		cmp #$96	loop            CMP #150
.1a5b80	f0 3a		beq $1a5bbc	                BEQ adj_sign
.1a5b82	90 1f		bcc $1a5ba3	                BLT shift_right
.1a5b84	08		php		            PHP
.1a5b85	c2 20		rep #$20	            REP #$20
.1a5b87	48		pha		            PHA
.1a5b88	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5b8b	5b		tcd		            TCD
.1a5b8c	68		pla		            PLA
.1a5b8d	28		plp		            PLP
.1a5b8e	e2 20		sep #$20	            SEP #$20
.1a5b90	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.1a5b92	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5b96	c2 20		rep #$20	            REP #$20
.1a5b98	29 ff 00	and #$00ff	            AND #$00FF
.1a5b9b	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a5b9e	e2 20		sep #$20	            SEP #$20
.1a5ba0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5ba3					shift_right
.1a5ba3	c2 20		rep #$20	            REP #$20
.1a5ba5	a3 05		lda $05,s	                LDA l_mantissa+2
.1a5ba7	4a		lsr a		                LSR A
.1a5ba8	83 05		sta $05,s	                STA l_mantissa+2
.1a5baa	a3 03		lda $03,s	                LDA l_mantissa
.1a5bac	6a		ror a		                ROR A
.1a5bad	83 03		sta $03,s	                STA l_mantissa
.1a5baf	e2 20		sep #$20	            SEP #$20
.1a5bb1	a3 02		lda $02,s	                LDA l_exponent
.1a5bb3	1a		inc a		                INC A
.1a5bb4	83 02		sta $02,s	                STA l_exponent
.1a5bb6	c9 96		cmp #$96	                CMP #150
.1a5bb8	f0 02		beq $1a5bbc	                BEQ adj_sign
.1a5bba	80 e7		bra $1a5ba3	                BRA shift_right
.1a5bbc	a3 01		lda $01,s	adj_sign        LDA l_sign
.1a5bbe	f0 1b		beq $1a5bdb	                BEQ ret_positive
.1a5bc0	c2 20		rep #$20	            REP #$20
.1a5bc2	a3 03		lda $03,s	                LDA l_mantissa
.1a5bc4	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a5bc7	18		clc		                CLC
.1a5bc8	69 01 00	adc #$0001	                ADC #1
.1a5bcb	8d 23 08	sta $0823	                STA @w ARGUMENT1
.1a5bce	a3 05		lda $05,s	                LDA l_mantissa+2
.1a5bd0	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a5bd3	69 00 00	adc #$0000	                ADC #0
.1a5bd6	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.1a5bd9	80 0c		bra $1a5be7	                BRA clean
.1a5bdb					ret_positive
.1a5bdb	c2 20		rep #$20	            REP #$20
.1a5bdd	a3 03		lda $03,s	                LDA l_mantissa
.1a5bdf	8d 23 08	sta $0823	                STA @w ARGUMENT1
.1a5be2	a3 05		lda $05,s	                LDA l_mantissa+2
.1a5be4	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.1a5be7					clean
.1a5be7	c2 20		rep #$20	            REP #$20
.1a5be9	68		pla		                PLA                     ; Clean up the locals
.1a5bea	68		pla		                PLA
.1a5beb	68		pla		                PLA
.1a5bec					done
.1a5bec	e2 20		sep #$20	            SEP #$20
.1a5bee	a9 00		lda #$00	                LDA #TYPE_INTEGER       ; Set the return type to integer
.1a5bf0	8d 27 08	sta $0827	                STA @w ARGTYPE1
.1a5bf3	28		plp		                PLP
.1a5bf4	60		rts		            RTS
.1a5bf5					FP_COMPARE
.1a5bf5	da		phx		                PHX
.1a5bf6	08		php		                PHP
.1a5bf7	c2 20		rep #$20	            REP #$20
.1a5bf9	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save ARGUMENT1 so we don't destroy it
.1a5bfb	48		pha		                PHA
.1a5bfc	a5 23		lda $0823	                LDA ARGUMENT1
.1a5bfe	48		pha		                PHA
.1a5bff	20 ee 55	jsr $1a55ee	            JSR OP_FP_SUB
.1a5c02	20 cc 57	jsr $1a57cc	            JSR FARG1EQ0
.1a5c05	b0 11		bcs $1a5c18	                BCS are_equal
.1a5c07	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Check the high word
.1a5c09	89 00 80	bit #$8000	                BIT #$8000
.1a5c0c	d0 05		bne $1a5c13	                BNE is_lt                   ; ARGUMENT1 < ARGUMENT2
.1a5c0e	a9 01 00	lda #$0001	is_gt           LDA #1                      ; ARGUMENT1 > ARGUMENT2: return 1
.1a5c11	80 08		bra $1a5c1b	                BRA ret_result
.1a5c13	a9 ff ff	lda #$ffff	is_lt           LDA #$FFFF                  ; ARGUMENT1 > ARGUMENT2: return -1
.1a5c16	80 03		bra $1a5c1b	                BRA ret_result
.1a5c18	a9 00 00	lda #$0000	are_equal       LDA #0                      ; Equal: return 0
.1a5c1b	fa		plx		ret_result      PLX                         ; Restore ARGUMENT1
.1a5c1c	86 23		stx $0823	                STX ARGUMENT1
.1a5c1e	fa		plx		                PLX
.1a5c1f	86 25		stx $0825	                STX ARGUMENT1+2
.1a5c21	28		plp		                PLP
.1a5c22	fa		plx		                PLX
.1a5c23	60		rts		            RTS
.1a5c24					OP_FP_LT
.1a5c24	08		php		                PHP
.1a5c25	c2 30		rep #$30	            REP #$30
.1a5c27	20 f5 5b	jsr $1a5bf5	            JSR FP_COMPARE
.1a5c2a	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a5c2d	d0 05		bne $1a5c34	                BNE ret_false
.1a5c2f	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a5c32	80 03		bra $1a5c37	                BRA done
.1a5c34					ret_false
.1a5c34	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a5c37	28		plp		done            PLP
.1a5c38	60		rts		            RTS
.1a5c39					OP_FP_GT
.1a5c39	08		php		                PHP
.1a5c3a	c2 30		rep #$30	            REP #$30
.1a5c3c	20 f5 5b	jsr $1a5bf5	            JSR FP_COMPARE
.1a5c3f	c9 01 00	cmp #$0001	                CMP #1
.1a5c42	d0 05		bne $1a5c49	                BNE ret_false
.1a5c44	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a5c47	80 03		bra $1a5c4c	                BRA done
.1a5c49					ret_false
.1a5c49	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a5c4c	28		plp		done            PLP
.1a5c4d	60		rts		            RTS
.1a5c4e					OP_FP_EQ
.1a5c4e	08		php		                PHP
.1a5c4f	c2 30		rep #$30	            REP #$30
.1a5c51	20 f5 5b	jsr $1a5bf5	            JSR FP_COMPARE
.1a5c54	c9 00 00	cmp #$0000	                CMP #0
.1a5c57	d0 05		bne $1a5c5e	                BNE ret_false
.1a5c59	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a5c5c	80 03		bra $1a5c61	                BRA done
.1a5c5e					ret_false
.1a5c5e	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a5c61	28		plp		done            PLP
.1a5c62	60		rts		            RTS
.1a5c63					OP_FP_LTE
.1a5c63	08		php		                PHP
.1a5c64	c2 30		rep #$30	            REP #$30
.1a5c66	20 f5 5b	jsr $1a5bf5	            JSR FP_COMPARE
.1a5c69	c9 01 00	cmp #$0001	                CMP #1
.1a5c6c	f0 05		beq $1a5c73	                BEQ ret_false
.1a5c6e	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a5c71	80 03		bra $1a5c76	                BRA done
.1a5c73					ret_false
.1a5c73	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a5c76	28		plp		done            PLP
.1a5c77	60		rts		            RTS
.1a5c78					OP_FP_GTE
.1a5c78	08		php		                PHP
.1a5c79	c2 30		rep #$30	            REP #$30
.1a5c7b	20 f5 5b	jsr $1a5bf5	            JSR FP_COMPARE
.1a5c7e	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a5c81	f0 05		beq $1a5c88	                BEQ ret_false
.1a5c83	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a5c86	80 03		bra $1a5c8b	                BRA done
.1a5c88					ret_false
.1a5c88	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a5c8b	28		plp		done            PLP
.1a5c8c	60		rts		            RTS
.1a5c8d					OP_FP_NE
.1a5c8d	08		php		                PHP
.1a5c8e	c2 30		rep #$30	            REP #$30
.1a5c90	20 f5 5b	jsr $1a5bf5	            JSR FP_COMPARE
.1a5c93	c9 00 00	cmp #$0000	                CMP #0
.1a5c96	f0 05		beq $1a5c9d	                BEQ ret_false
.1a5c98	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a5c9b	80 03		bra $1a5ca0	                BRA done
.1a5c9d					ret_false
.1a5c9d	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a5ca0	28		plp		done            PLP
.1a5ca1	60		rts		            RTS
.1a5ca2					STREMIT
.1a5ca2	08		php		                PHP
.1a5ca3	e2 20		sep #$20	            SEP #$20
.1a5ca5	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Append the character
.1a5ca7	c8		iny		                INY                         ; Advance the character pointer in Y
.1a5ca8	a9 00		lda #$00	                LDA #0                      ; And add the NULL
.1a5caa	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.1a5cac	28		plp		                PLP
.1a5cad	60		rts		            RTS
.1a5cae					STREMITB
.1a5cae	da		phx		                PHX
.1a5caf	08		php		                PHP
.1a5cb0	e2 20		sep #$20	            SEP #$20
.1a5cb2	c9 80		cmp #$80	                CMP #$80
.1a5cb4	90 0a		bcc $1a5cc0	                BLT emit_digits
.1a5cb6	48		pha		                PHA
.1a5cb7	a9 2d		lda #$2d	                LDA #'-'                    ; Print a minus sign
.1a5cb9	20 a2 5c	jsr $1a5ca2	            JSR STREMIT
.1a5cbc	68		pla		                PLA
.1a5cbd	49 ff		eor #$ff	                EOR #$FF                    ; And negate it
.1a5cbf	1a		inc a		                INC A
.1a5cc0					emit_digits
.1a5cc0	c2 30		rep #$30	            REP #$30
.1a5cc2	29 ff 00	and #$00ff	                AND #$00FF
.1a5cc5	c9 64 00	cmp #$0064	                CMP #100
.1a5cc8	90 0e		bcc $1a5cd8	                BLT chk_tens
.1a5cca	a2 64 00	ldx #$0064	                LDX #100
.1a5ccd	20 93 55	jsr $1a5593	            JSR UINT_DIV_A_X
.1a5cd0	18		clc		                CLC
.1a5cd1	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.1a5cd4	20 a2 5c	jsr $1a5ca2	            JSR STREMIT
.1a5cd7	8a		txa		                TXA                         ; Put the remainder in A
.1a5cd8					chk_tens
.1a5cd8	a2 0a 00	ldx #$000a	                LDX #10
.1a5cdb	20 93 55	jsr $1a5593	            JSR UINT_DIV_A_X
.1a5cde	18		clc		                CLC
.1a5cdf	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.1a5ce2	20 a2 5c	jsr $1a5ca2	            JSR STREMIT
.1a5ce5	8a		txa		                TXA                         ; Put the remainder in A
.1a5ce6					ones_digit
.1a5ce6	18		clc		                CLC
.1a5ce7	69 30 00	adc #$0030	                ADC #'0'                    ; Convert it to ASCII
.1a5cea	20 a2 5c	jsr $1a5ca2	            JSR STREMIT
.1a5ced	28		plp		                PLP
.1a5cee	fa		plx		                PLX
.1a5cef	60		rts		            RTS
.1a5cf0					STRFINDEND
.1a5cf0	08		php		                PHP
.1a5cf1	e2 20		sep #$20	            SEP #$20
.1a5cf3	c2 10		rep #$10	            REP #$10
.1a5cf5	a0 00 00	ldy #$0000	                LDY #0
.1a5cf8	b7 23		lda [$0823],y	find_end        LDA [ARGUMENT1],Y           ; Scan to the end of the string
.1a5cfa	f0 03		beq $1a5cff	                BEQ done
.1a5cfc	c8		iny		                INY
.1a5cfd	80 f9		bra $1a5cf8	                BRA find_end
.1a5cff	28		plp		done            PLP
.1a5d00	60		rts		            RTS
=6					FP_D = 6        ; Number of mantissa digits
.1a5d01					FTOS
.1a5d01	08		php		                PHP
.1a5d02	e2 20		sep #$20	            SEP #$20
.1a5d04	c2 10		rep #$10	            REP #$10
.1a5d06	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be the negative flag
.1a5d09	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be K
.1a5d0c	f4 00 00	pea #$0000	                PEA #0                      ; This spot will be for the exponents
>0001					L_NEGATIVE      .word ?
>0003					L_K             .word ?
>0005					L_X1            .byte ?                     ; The binary exponent
>0006					L_EXP           .byte ?                     ; The decimal exponent
.1a5d0f	20 cc 57	jsr $1a57cc	            JSR FARG1EQ0
.1a5d12	90 19		bcc $1a5d2d	                BCC chk_negative
.1a5d14	20 c1 14	jsr $1a14c1	            JSR TEMPSTRING
.1a5d17	e2 20		sep #$20	            SEP #$20
.1a5d19	a0 00 00	ldy #$0000	                LDY #0
.1a5d1c	a9 20		lda #$20	                LDA #' '
.1a5d1e	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a5d20	c8		iny		                INY
.1a5d21	a9 30		lda #$30	                LDA #'0'                    ; Return a "0"
.1a5d23	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a5d25	c8		iny		                INY
.1a5d26	a9 00		lda #$00	                LDA #0
.1a5d28	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a5d2a	82 ce 00	brl $1a5dfb	                BRL ret_result
.1a5d2d					chk_negative
.1a5d2d	e2 20		sep #$20	            SEP #$20
.1a5d2f	a5 26		lda $0826	                LDA ARGUMENT1+3             ; If N is negative, output a minus sign and negate N
.1a5d31	10 08		bpl $1a5d3b	                BPL not_negative
.1a5d33	29 7f		and #$7f	                AND #$7F                    ; Negate the number
.1a5d35	85 26		sta $0826	                STA ARGUMENT1+3
.1a5d37	a9 01		lda #$01	                LDA #1
.1a5d39	83 01		sta $01,s	                STA L_NEGATIVE              ; Set IsNegative to a TRUE value
.1a5d3b					not_negative
.1a5d3b	c2 20		rep #$20	            REP #$20
.1a5d3d	a9 00 00	lda #$0000	                LDA #0                      ; Initialize K to 0, K is a 1-byte signed integer. (SCRATCH is K)
.1a5d40	83 03		sta $03,s	                STA L_K                     ; We're using a word here for convenience
.1a5d42	c2 20		rep #$20	            REP #$20
.1a5d44	af 15 5e 1a	lda $1a5e15	            LDA ten_d_1
.1a5d48	85 29		sta $0829	            STA ARGUMENT2
.1a5d4a	af 17 5e 1a	lda $1a5e17	            LDA ten_d_1+2
.1a5d4e	85 2b		sta $082b	            STA ARGUMENT2+2
.1a5d50	20 f5 5b	jsr $1a5bf5	            JSR FP_COMPARE
.1a5d53	89 00 80	bit #$8000	                BIT #$8000                  ; Is N < 10^(D-1)?
.1a5d56	d0 12		bne $1a5d6a	                BNE shift_up
.1a5d58					shift_down
.1a5d58	20 90 57	jsr $1a5790	            JSR FP_DIV10
.1a5d5b	a3 03		lda $03,s	                LDA L_K
.1a5d5d	1a		inc a		                INC A
.1a5d5e	83 03		sta $03,s	                STA L_K                     ; Increment K
.1a5d60	20 f5 5b	jsr $1a5bf5	            JSR FP_COMPARE
.1a5d63	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N < 10^(D-1)?
.1a5d66	f0 12		beq $1a5d7a	                BEQ do_digits               ; Yes: we're ready to process digits
.1a5d68	80 ee		bra $1a5d58	                BRA shift_down              ; No: keep dividing
.1a5d6a					shift_up
.1a5d6a	20 47 57	jsr $1a5747	            JSR FP_MUL10
.1a5d6d	a3 03		lda $03,s	                LDA L_K
.1a5d6f	3a		dec a		                DEC A
.1a5d70	83 03		sta $03,s	                STA L_K                     ; Decrement K
.1a5d72	20 f5 5b	jsr $1a5bf5	            JSR FP_COMPARE
.1a5d75	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N >= 10 ^ (D-1)?
.1a5d78	f0 f0		beq $1a5d6a	                BEQ shift_up                ; No: keep multiplying
.1a5d7a					do_digits
.1a5d7a	e2 30		sep #$30	            SEP #$30
.1a5d7c	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5d7e	0a		asl a		                ASL A
.1a5d7f	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a5d81	2a		rol a		                ROL A
.1a5d82	83 05		sta $05,s	                STA L_X1
.1a5d84	38		sec		                SEC
.1a5d85	a9 96		lda #$96	                LDA #150                    ; X := 150 - X1
.1a5d87	e3 05		sbc $05,s	                SBC L_X1
.1a5d89	aa		tax		                TAX
.1a5d8a	f0 0f		beq $1a5d9b	                BEQ emit_digits             ; If X = 0, just emit the digits
.1a5d8c	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Set the implied '1' MSB of the mantissa
.1a5d8e	09 80		ora #$80	                ORA #$80
.1a5d90	85 25		sta $0825	                STA ARGUMENT1+2
.1a5d92	46 25		lsr $0825	shift_r         LSR ARGUMENT1+2             ; Shift the mantissa right
.1a5d94	66 24		ror $0824	                ROR ARGUMENT1+1
.1a5d96	66 23		ror $0823	                ROR ARGUMENT1
.1a5d98	ca		dex		                DEX
.1a5d99	d0 f7		bne $1a5d92	                BNE shift_r                 ; Until X = 0
.1a5d9b					emit_digits
.1a5d9b	c2 10		rep #$10	            REP #$10
.1a5d9d	e2 20		sep #$20	            SEP #$20
.1a5d9f	64 26		stz $0826	                STZ ARGUMENT1+3             ; Blank out the MSB
.1a5da1	a9 00		lda #$00	                LDA #TYPE_INTEGER           ; Make it an integer
.1a5da3	85 27		sta $0827	                STA ARGTYPE1
.1a5da5	a3 01		lda $01,s	                LDA L_NEGATIVE              ; Check IsNegative
.1a5da7	f0 11		beq $1a5dba	                BEQ get_raw_digits          ; If FALSE, just convert the raw digits
.1a5da9	c2 20		rep #$20	            REP #$20
.1a5dab	38		sec		                SEC                         ; Make the raw integer negative
.1a5dac	a9 00 00	lda #$0000	                LDA #0
.1a5daf	e5 23		sbc $0823	                SBC ARGUMENT1
.1a5db1	85 23		sta $0823	                STA ARGUMENT1
.1a5db3	a9 00 00	lda #$0000	                LDA #0
.1a5db6	e5 25		sbc $0825	                SBC ARGUMENT1+2
.1a5db8	85 25		sta $0825	                STA ARGUMENT1+2
.1a5dba					get_raw_digits
.1a5dba	20 20 15	jsr $1a1520	            JSR ITOS
.1a5dbd	c2 20		rep #$20	            REP #$20
.1a5dbf	a5 16		lda $0816	            LDA STRPTR
.1a5dc1	85 23		sta $0823	            STA ARGUMENT1
.1a5dc3	a5 18		lda $0818	            LDA STRPTR+2
.1a5dc5	85 25		sta $0825	            STA ARGUMENT1+2
.1a5dc7	20 f0 5c	jsr $1a5cf0	            JSR STRFINDEND
.1a5dca	e2 20		sep #$20	            SEP #$20
.1a5dcc	c8		iny		                INY                         ; Move the NULL up one byte
.1a5dcd	a9 00		lda #$00	                LDA #0
.1a5dcf	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.1a5dd1	88		dey		insert_loop     DEY                         ; Move to the character before the one we just moved
.1a5dd2	88		dey		                DEY
.1a5dd3	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y           ; Get the character
.1a5dd5	c8		iny		                INY                         ; Move to the next space
.1a5dd6	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Store the character here
.1a5dd8	c0 02 00	cpy #$0002	                CPY #2                      ; Check to see if we just moved the 2nd character
.1a5ddb	d0 f4		bne $1a5dd1	                BNE insert_loop             ; If not, keep moving the characters
.1a5ddd	a9 2e		lda #$2e	                LDA #'.'                    ; Insert the '.' in the space we openned
.1a5ddf	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.1a5de1	e2 20		sep #$20	            SEP #$20
.1a5de3	18		clc		                CLC                         ; Compute the exponent
.1a5de4	a3 03		lda $03,s	                LDA L_K
.1a5de6	69 05		adc #$05	                ADC #(FP_D - 1)
.1a5de8	83 06		sta $06,s	                STA L_EXP
.1a5dea	f0 19		beq $1a5e05	                BEQ done                    ; If it's 0, just return the number
.1a5dec	20 f0 5c	jsr $1a5cf0	            JSR STRFINDEND
.1a5def	a9 45		lda #$45	                LDA #'E'                    ; Append the "E"
.1a5df1	20 a2 5c	jsr $1a5ca2	            JSR STREMIT
.1a5df4	a3 06		lda $06,s	                LDA L_EXP
.1a5df6	20 ae 5c	jsr $1a5cae	            JSR STREMITB
.1a5df9	80 0a		bra $1a5e05	                BRA done                    ; TODO: reformat integer... add E and exponent...
.1a5dfb					ret_result
.1a5dfb	c2 20		rep #$20	            REP #$20
.1a5dfd	a5 16		lda $0816	                LDA STRPTR                  ; Return the temporary string we've assembled
.1a5dff	85 23		sta $0823	                STA ARGUMENT1
.1a5e01	a5 18		lda $0818	                LDA STRPTR+2
.1a5e03	85 25		sta $0825	                STA ARGUMENT1+2
.1a5e05					done
.1a5e05	e2 20		sep #$20	            SEP #$20
.1a5e07	a9 02		lda #$02	                LDA #TYPE_STRING
.1a5e09	85 27		sta $0827	                STA ARGTYPE1
.1a5e0b	c2 20		rep #$20	            REP #$20
.1a5e0d	3b		tsc		                TSC                         ; Remove the locals from the stack
.1a5e0e	18		clc		                CLC
.1a5e0f	69 06 00	adc #$0006	                ADC #6
.1a5e12	1b		tcs		                TCS
.1a5e13	28		plp		                PLP
.1a5e14	60		rts		            RTS
>1a5e15	00 50 c3 47			ten_d_1         .dword $47c35000            ; 10^(FP_D-1), where FP_D=5
>1a5e19	00 00 80 3f			FP_1_0          .dword $3f800000    ; Floating point constant: 1.0
>1a5e1d	f3 04 b5 3f			FP_SQR_2_0      .dword $3fb504f3    ; Floating point constant: sqrt(2.0)
>1a5e21	f3 04 35 3f			FP_SQR_0_5      .dword $3f3504f3    ; Floating point constant: sqrt(0.2)

;******  Return to file: src\basic816.s


;******  Processing file: src\transcendentals.s

.1a5e25					Q_POLY_HR
.1a5e25	e2 20		sep #$20	            SEP #$20
.1a5e27	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a5e29	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5e2d	c2 20		rep #$20	            REP #$20
.1a5e2f	bd 00 00	lda $0000,x	                LDA 0,X
.1a5e32	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5e36	bd 02 00	lda $0002,x	                LDA 2,X
.1a5e39	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5e3d	88		dey		                DEY             ; (Y-1) more coefficients.
.1a5e3e	e8		inx		loop            INX             ; point to the next coefficient
.1a5e3f	e8		inx		                INX
.1a5e40	e8		inx		                INX
.1a5e41	e8		inx		                INX
.1a5e42	e2 20		sep #$20	            SEP #$20
.1a5e44	a9 00		lda #$00	                LDA #FP_OUT_MULT
.1a5e46	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5e4a	c2 20		rep #$20	            REP #$20
.1a5e4c	af 23 08 00	lda $000823	                LDA @l ARGUMENT1
.1a5e50	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5e54	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a5e58	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5e5c	ea		nop		                NOP
.1a5e5d	ea		nop		                NOP
.1a5e5e	ea		nop		                NOP
.1a5e5f	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5e63	48		pha		                PHA
.1a5e64	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5e68	8f 0a e2 af	sta $afe20a	                STA FP_MATH_INPUT0_HL
.1a5e6c	68		pla		                PLA
.1a5e6d	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5e71	e2 20		sep #$20	            SEP #$20
.1a5e73	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a5e75	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5e79	c2 20		rep #$20	            REP #$20
.1a5e7b	bd 00 00	lda $0000,x	                LDA 0,X
.1a5e7e	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5e82	bd 02 00	lda $0002,x	                LDA 2,X
.1a5e85	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5e89	ea		nop		                NOP
.1a5e8a	ea		nop		                NOP
.1a5e8b	ea		nop		                NOP
.1a5e8c	88		dey		                DEY
.1a5e8d	f0 14		beq $1a5ea3	                BEQ done
.1a5e8f	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5e93	48		pha		                PHA
.1a5e94	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5e98	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5e9c	68		pla		                PLA
.1a5e9d	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5ea1	80 9b		bra $1a5e3e	                BRA loop
.1a5ea3	af 08 e2 af	lda $afe208	done            LDA @l FP_MATH_OUTPUT_FP_LL
.1a5ea7	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.1a5eab	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5eaf	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.1a5eb3	60		rts		                RTS
.1a5eb4					Q_SQ
.1a5eb4	e2 20		sep #$20	            SEP #$20
.1a5eb6	a9 00		lda #$00	                LDA #0
.1a5eb8	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5ebc	a9 00		lda #$00	                LDA #FP_OUT_MULT
.1a5ebe	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5ec2	c2 20		rep #$20	            REP #$20
.1a5ec4	a5 23		lda $0823	                LDA ARGUMENT1
.1a5ec6	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5eca	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5ece	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a5ed2	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5ed6	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5eda	ea		nop		                NOP
.1a5edb	ea		nop		                NOP
.1a5edc	ea		nop		                NOP
.1a5edd	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5ee1	85 23		sta $0823	                STA ARGUMENT1
.1a5ee3	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5ee7	85 25		sta $0825	                STA ARGUMENT1+2
.1a5ee9	60		rts		                RTS
.1a5eea					Q_INV
.1a5eea	e2 20		sep #$20	            SEP #$20
.1a5eec	a9 00		lda #$00	                LDA #0
.1a5eee	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5ef2	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a5ef4	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5ef8	c2 20		rep #$20	            REP #$20
.1a5efa	a5 23		lda $0823	                LDA ARGUMENT1
.1a5efc	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5f00	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a5f04	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5f08	af 3e 65 1a	lda $1a653e	                LDA @l fp_one
.1a5f0c	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5f10	af 40 65 1a	lda $1a6540	                LDA @l fp_one+2
.1a5f14	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5f18	ea		nop		                NOP
.1a5f19	ea		nop		                NOP
.1a5f1a	ea		nop		                NOP
.1a5f1b	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5f1f	85 23		sta $0823	                STA ARGUMENT1
.1a5f21	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5f25	85 25		sta $0825	                STA ARGUMENT1+2
.1a5f27	60		rts		                RTS
.1a5f28					Q_FP_SCALE
.1a5f28	a2 00 00	ldx #$0000	                LDX #0
.1a5f2b	a5 23		lda $0823	loop            LDA ARGUMENT1
.1a5f2d	c5 29		cmp $0829	                CMP ARGUMENT2
.1a5f2f	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5f31	e5 2b		sbc $082b	                SBC ARGUMENT2+2
.1a5f33	90 1e		bcc $1a5f53	                BCC done
.1a5f35	a5 23		lda $0823	                LDA ARGUMENT1
.1a5f37	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5f3b	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5f3d	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5f41	ea		nop		                NOP
.1a5f42	ea		nop		                NOP
.1a5f43	ea		nop		                NOP
.1a5f44	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5f48	85 23		sta $0823	                STA ARGUMENT1
.1a5f4a	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5f4e	85 25		sta $0825	                STA ARGUMENT1+2
.1a5f50	e8		inx		                INX
.1a5f51	80 d8		bra $1a5f2b	                BRA loop
.1a5f53					done
.1a5f53	60		rts		            RTS
.1a5f54					Q_FP_SCALE_TAU
.1a5f54	e2 20		sep #$20	            SEP #$20
.1a5f56	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a5f58	10 09		bpl $1a5f63	                BPL notneg
.1a5f5a	29 7f		and #$7f	                AND #$7F
.1a5f5c	85 26		sta $0826	                STA ARGUMENT1+3
.1a5f5e	a9 01		lda #$01	                LDA #1
.1a5f60	48		pha		                PHA
.1a5f61	80 03		bra $1a5f66	                BRA compute
.1a5f63	a9 00		lda #$00	notneg          LDA #0          ; not negative, so push 0.
.1a5f65	48		pha		                PHA
.1a5f66	a9 40		lda #$40	compute         LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a5f68	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5f6c	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a5f6e	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5f72	c2 30		rep #$30	            REP #$30
.1a5f74	af a6 65 1a	lda $1a65a6	                LDA @l twopi
.1a5f78	85 29		sta $0829	                STA ARGUMENT2
.1a5f7a	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5f7e	af a8 65 1a	lda $1a65a8	                LDA @l twopi+2
.1a5f82	85 2b		sta $082b	                STA ARGUMENT2+2
.1a5f84	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5f88	20 28 5f	jsr $1a5f28	            JSR Q_FP_SCALE
.1a5f8b	e2 20		sep #$20	            SEP #$20
.1a5f8d	68		pla		                PLA
.1a5f8e	c2 20		rep #$20	            REP #$20
.1a5f90	f0 1e		beq $1a5fb0	                BEQ done
.1a5f92	a5 23		lda $0823	                LDA ARGUMENT1
.1a5f94	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5f98	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5f9a	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5f9e	ea		nop		                NOP
.1a5f9f	ea		nop		                NOP
.1a5fa0	ea		nop		                NOP
.1a5fa1	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5fa5	85 23		sta $0823	                STA ARGUMENT1
.1a5fa7	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5fab	29 ff 7f	and #$7fff	                AND #$7fff
.1a5fae	85 25		sta $0825	                STA ARGUMENT1+2
.1a5fb0					done
.1a5fb0	60		rts		            RTS
.1a5fb1					Q_FP_NORM_ANGLE
.1a5fb1	5a		phy		                PHY
.1a5fb2	a2 00 00	ldx #$0000	                LDX #0
.1a5fb5	a0 00 00	ldy #$0000	                LDY #0
.1a5fb8	a5 23		lda $0823	loop            LDA ARGUMENT1
.1a5fba	df aa 65 1a	cmp $1a65aa,x	                CMP @l onepi,x
.1a5fbe	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5fc0	ff ac 65 1a	sbc $1a65ac,x	                SBC @l onepi+2,x
.1a5fc4	90 2c		bcc $1a5ff2	                BCC less
.1a5fc6	bf a6 65 1a	lda $1a65a6,x	                LDA @l twopi,x
.1a5fca	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5fce	bf a8 65 1a	lda $1a65a8,x	                LDA @l twopi+2,x
.1a5fd2	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5fd6	a5 23		lda $0823	                LDA ARGUMENT1
.1a5fd8	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5fdc	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5fde	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5fe2	ea		nop		                NOP
.1a5fe3	ea		nop		                NOP
.1a5fe4	ea		nop		                NOP
.1a5fe5	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5fe9	85 23		sta $0823	                STA ARGUMENT1
.1a5feb	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5fef	85 25		sta $0825	                STA ARGUMENT1+2
.1a5ff1	38		sec		                SEC             ; set carry to indicate a reflection
.1a5ff2	98		tya		less            TYA             ; carry already cleared if we branched
.1a5ff3	2a		rol a		                ROL             ; shift carry into flags...
.1a5ff4	a8		tay		                TAY             ; and store back into y
.1a5ff5	e8		inx		                INX             ; next set of values
.1a5ff6	e8		inx		                INX
.1a5ff7	e8		inx		                INX
.1a5ff8	e8		inx		                INX
.1a5ff9	e0 0c 00	cpx #$000c	                CPX #12         ; check if we have already looked at 3
.1a5ffc	d0 ba		bne $1a5fb8	                BNE loop
.1a5ffe	98		tya		                TYA             ; copy Y to X, as that's what we have
.1a5fff	aa		tax		                TAX
.1a6000	7a		ply		                PLY
.1a6001	60		rts		            RTS
.1a6002					Q_FP_COS
.1a6002	08		php		                PHP
.1a6003	c2 30		rep #$30	            REP #$30
.1a6005	48		pha		                PHA
.1a6006	da		phx		                PHX
.1a6007	20 b4 5e	jsr $1a5eb4	            JSR Q_SQ
.1a600a	8b		phb		                PHB
.1a600b	e2 20		sep #$20	            SEP #$20
.1a600d	a9 1a		lda #$1a	                LDA #`cos_coeff
.1a600f	48		pha		                PHA
.1a6010	ab		plb		                PLB
.1a6011	c2 20		rep #$20	            REP #$20
.1a6013	a2 e6 64	ldx #$64e6	                LDX #<>cos_coeff
.1a6016	5a		phy		                PHY
.1a6017	a0 05 00	ldy #$0005	                LDY #5
.1a601a	20 25 5e	jsr $1a5e25	            JSR Q_POLY_HR
.1a601d	7a		ply		                PLY
.1a601e	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.1a6021	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.1a6025	ab		plb		                PLB
.1a6026	fa		plx		                PLX
.1a6027	68		pla		                PLA
.1a6028	28		plp		                PLP
.1a6029	60		rts		            RTS
.1a602a					Q_FP_SIN
.1a602a	08		php		                PHP
.1a602b	c2 30		rep #$30	            REP #$30
.1a602d	48		pha		                PHA
.1a602e	da		phx		                PHX
.1a602f	a5 23		lda $0823	                LDA ARGUMENT1
.1a6031	85 29		sta $0829	                STA ARGUMENT2
.1a6033	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6035	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6037	20 b4 5e	jsr $1a5eb4	            JSR Q_SQ
.1a603a	8b		phb		                PHB
.1a603b	e2 20		sep #$20	            SEP #$20
.1a603d	a9 1a		lda #$1a	                LDA #`sin_coeff
.1a603f	48		pha		                PHA
.1a6040	ab		plb		                PLB
.1a6041	c2 20		rep #$20	            REP #$20
.1a6043	a2 fa 64	ldx #$64fa	                LDX #<>sin_coeff
.1a6046	5a		phy		                PHY
.1a6047	a0 05 00	ldy #$0005	                LDY #5
.1a604a	20 25 5e	jsr $1a5e25	            JSR Q_POLY_HR
.1a604d	7a		ply		                PLY
.1a604e	ab		plb		                PLB
.1a604f	20 8f 56	jsr $1a568f	            JSR OP_FP_MUL
.1a6052	fa		plx		                PLX
.1a6053	68		pla		                PLA
.1a6054	28		plp		                PLP
.1a6055	60		rts		            RTS
.1a6056					Q_FP_TAN
.1a6056	08		php		                PHP
.1a6057	c2 30		rep #$30	            REP #$30
.1a6059	48		pha		                PHA
.1a605a	da		phx		                PHX
.1a605b	a5 23		lda $0823	                LDA ARGUMENT1
.1a605d	85 29		sta $0829	                STA ARGUMENT2
.1a605f	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6061	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6063	20 b4 5e	jsr $1a5eb4	            JSR Q_SQ
.1a6066	8b		phb		                PHB
.1a6067	e2 20		sep #$20	            SEP #$20
.1a6069	a9 1a		lda #$1a	                LDA #`tan_coeff
.1a606b	48		pha		                PHA
.1a606c	ab		plb		                PLB
.1a606d	c2 20		rep #$20	            REP #$20
.1a606f	a2 0e 65	ldx #$650e	                LDX #<>tan_coeff
.1a6072	5a		phy		                PHY
.1a6073	a0 05 00	ldy #$0005	                LDY #5
.1a6076	20 25 5e	jsr $1a5e25	            JSR Q_POLY_HR
.1a6079	7a		ply		                PLY
.1a607a	ab		plb		                PLB
.1a607b	20 8f 56	jsr $1a568f	            JSR OP_FP_MUL
.1a607e	fa		plx		                PLX
.1a607f	68		pla		                PLA
.1a6080	28		plp		                PLP
.1a6081	60		rts		            RTS
.1a6082					Q_FP_LN
.1a6082	08		php		                PHP
.1a6083	c2 30		rep #$30	            REP #$30
.1a6085	48		pha		                PHA
.1a6086	da		phx		                PHX
.1a6087	e2 20		sep #$20	            SEP #$20
.1a6089	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a608b	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a608f	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a6091	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a6095	c2 20		rep #$20	            REP #$20
.1a6097	a5 23		lda $0823	                LDA ARGUMENT1
.1a6099	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a609d	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a609f	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a60a3	af 3e 65 1a	lda $1a653e	                LDA @l fp_one
.1a60a7	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a60ab	af 40 65 1a	lda $1a6540	                LDA @l fp_one+2
.1a60af	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a60b3	ea		nop		                NOP
.1a60b4	ea		nop		                NOP
.1a60b5	ea		nop		                NOP
.1a60b6	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a60ba	85 0c		sta $080c	                STA SCRATCH
.1a60bc	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a60c0	85 0e		sta $080e	                STA SCRATCH+2
.1a60c2	e2 20		sep #$20	            SEP #$20
.1a60c4	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a60c6	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a60ca	c2 20		rep #$20	            REP #$20
.1a60cc	ea		nop		                NOP
.1a60cd	ea		nop		                NOP
.1a60ce	ea		nop		                NOP
.1a60cf	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a60d3	85 10		sta $0810	                STA SCRATCH2
.1a60d5	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a60d9	85 12		sta $0812	                STA SCRATCH2+2
.1a60db	e2 20		sep #$20	            SEP #$20
.1a60dd	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a60df	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a60e3	c2 20		rep #$20	            REP #$20
.1a60e5	a5 0c		lda $080c	                LDA SCRATCH
.1a60e7	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a60eb	a5 0e		lda $080e	                LDA SCRATCH+2
.1a60ed	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a60f1	a5 10		lda $0810	                LDA SCRATCH2
.1a60f3	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a60f7	a5 12		lda $0812	                LDA SCRATCH2+2
.1a60f9	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a60fd	ea		nop		                NOP
.1a60fe	ea		nop		                NOP
.1a60ff	ea		nop		                NOP
.1a6100	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a6104	85 23		sta $0823	                STA ARGUMENT1
.1a6106	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a610a	85 25		sta $0825	                STA ARGUMENT1+2
.1a610c	e2 20		sep #$20	            SEP #$20
.1a610e	a9 08		lda #$08	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX0
.1a6110	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a6114	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a6116	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a611a	c2 20		rep #$20	            REP #$20
.1a611c	a5 23		lda $0823	                LDA ARGUMENT1
.1a611e	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a6122	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6124	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a6128	ea		nop		                NOP
.1a6129	ea		nop		                NOP
.1a612a	ea		nop		                NOP
.1a612b	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a612f	85 29		sta $0829	                STA ARGUMENT2
.1a6131	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a6135	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6137	20 b4 5e	jsr $1a5eb4	            JSR Q_SQ
.1a613a	8b		phb		                PHB
.1a613b	e2 20		sep #$20	            SEP #$20
.1a613d	a9 1a		lda #$1a	                LDA #`ln_coeff
.1a613f	48		pha		                PHA
.1a6140	ab		plb		                PLB
.1a6141	c2 20		rep #$20	            REP #$20
.1a6143	a2 22 65	ldx #$6522	                LDX #<>ln_coeff
.1a6146	5a		phy		                PHY
.1a6147	a0 08 00	ldy #$0008	                LDY #8
.1a614a	20 25 5e	jsr $1a5e25	            JSR Q_POLY_HR
.1a614d	7a		ply		                PLY
.1a614e	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.1a6151	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.1a6155	8f 2d 08 00	sta $00082d	                STA @l ARGTYPE2
.1a6159	20 8f 56	jsr $1a568f	            JSR OP_FP_MUL
.1a615c	ab		plb		                PLB
.1a615d	fa		plx		                PLX
.1a615e	68		pla		                PLA
.1a615f	28		plp		                PLP
.1a6160	60		rts		            RTS
.1a6161					FP_SIN
.1a6161	08		php		                PHP
.1a6162	c2 30		rep #$30	            REP #$30
.1a6164	48		pha		                PHA
.1a6165	da		phx		                PHX
.1a6166	20 54 5f	jsr $1a5f54	            JSR Q_FP_SCALE_TAU
.1a6169	20 b1 5f	jsr $1a5fb1	            JSR Q_FP_NORM_ANGLE
.1a616c	da		phx		                PHX
.1a616d	8a		txa		                TXA
.1a616e	29 01 00	and #$0001	                AND #1
.1a6171	d0 05		bne $1a6178	                BNE do_cos
.1a6173	20 2a 60	jsr $1a602a	            JSR Q_FP_SIN
.1a6176	80 03		bra $1a617b	                BRA maybe_neg
.1a6178					do_cos
.1a6178	20 02 60	jsr $1a6002	            JSR Q_FP_COS
.1a617b	fa		plx		maybe_neg       PLX
.1a617c	8a		txa		                TXA
.1a617d	29 04 00	and #$0004	                AND #4
.1a6180	f0 0a		beq $1a618c	                BEQ done
.1a6182	e2 20		sep #$20	            SEP #$20
.1a6184	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a6186	09 80		ora #$80	                ORA #$80
.1a6188	85 26		sta $0826	                STA ARGUMENT1+3
.1a618a	c2 20		rep #$20	            REP #$20
.1a618c	fa		plx		done            PLX
.1a618d	68		pla		                PLA
.1a618e	28		plp		                PLP
.1a618f	60		rts		            RTS
.1a6190					FP_COS
.1a6190	08		php		                PHP
.1a6191	c2 30		rep #$30	            REP #$30
.1a6193	48		pha		                PHA
.1a6194	da		phx		                PHX
.1a6195	20 54 5f	jsr $1a5f54	            JSR Q_FP_SCALE_TAU
.1a6198	20 b1 5f	jsr $1a5fb1	            JSR Q_FP_NORM_ANGLE
.1a619b	da		phx		                PHX
.1a619c	8a		txa		                TXA
.1a619d	29 01 00	and #$0001	                AND #1
.1a61a0	d0 05		bne $1a61a7	                BNE do_sin
.1a61a2	20 02 60	jsr $1a6002	            JSR Q_FP_COS
.1a61a5	80 03		bra $1a61aa	                BRA maybe_neg
.1a61a7					do_sin
.1a61a7	20 2a 60	jsr $1a602a	            JSR Q_FP_SIN
.1a61aa	fa		plx		maybe_neg       PLX
.1a61ab	8a		txa		                TXA
.1a61ac	29 02 00	and #$0002	                AND #2
.1a61af	f0 0a		beq $1a61bb	                BEQ done
.1a61b1	e2 20		sep #$20	            SEP #$20
.1a61b3	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a61b5	09 80		ora #$80	                ORA #$80
.1a61b7	85 26		sta $0826	                STA ARGUMENT1+3
.1a61b9	c2 20		rep #$20	            REP #$20
.1a61bb	fa		plx		done            PLX
.1a61bc	68		pla		                PLA
.1a61bd	28		plp		                PLP
.1a61be	60		rts		            RTS
.1a61bf					FP_TAN
.1a61bf	08		php		                PHP
.1a61c0	c2 30		rep #$30	            REP #$30
.1a61c2	48		pha		                PHA
.1a61c3	da		phx		                PHX
.1a61c4	20 54 5f	jsr $1a5f54	            JSR Q_FP_SCALE_TAU
.1a61c7	20 b1 5f	jsr $1a5fb1	            JSR Q_FP_NORM_ANGLE
.1a61ca	20 56 60	jsr $1a6056	            JSR Q_FP_TAN
.1a61cd	8a		txa		                TXA
.1a61ce	29 01 00	and #$0001	                AND #1
.1a61d1	f0 03		beq $1a61d6	                BEQ no_inv
.1a61d3	20 ea 5e	jsr $1a5eea	            JSR Q_INV
.1a61d6	8a		txa		no_inv          TXA
.1a61d7	e2 20		sep #$20	            SEP #$20
.1a61d9	4a		lsr a		                LSR
.1a61da	4a		lsr a		                LSR
.1a61db	69 00		adc #$00	                ADC #0
.1a61dd	29 01		and #$01	                AND #1
.1a61df	f0 06		beq $1a61e7	                BEQ no_neg
.1a61e1	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a61e3	09 80		ora #$80	                ORA #$80
.1a61e5	85 26		sta $0826	                STA ARGUMENT1+3
.1a61e7					no_neg
.1a61e7	c2 20		rep #$20	            REP #$20
.1a61e9	fa		plx		                PLX
.1a61ea	68		pla		                PLA
.1a61eb	28		plp		                PLP
.1a61ec	60		rts		            RTS
.1a61ed					FP_LN
.1a61ed	08		php		                PHP
.1a61ee	c2 30		rep #$30	            REP #$30
.1a61f0	48		pha		                PHA
.1a61f1	da		phx		                PHX
.1a61f2	5a		phy		                PHY
.1a61f3	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a61f5	10 1f		bpl $1a6216	                BPL arg_ok
.1a61f7	08		php		            PHP
.1a61f8	c2 20		rep #$20	            REP #$20
.1a61fa	48		pha		            PHA
.1a61fb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a61fe	5b		tcd		            TCD
.1a61ff	68		pla		            PLA
.1a6200	28		plp		            PLP
.1a6201	e2 20		sep #$20	            SEP #$20
.1a6203	a9 17		lda #$17	            LDA #ERR_DOMAIN
.1a6205	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6209	c2 20		rep #$20	            REP #$20
.1a620b	29 ff 00	and #$00ff	            AND #$00FF
.1a620e	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a6211	e2 20		sep #$20	            SEP #$20
.1a6213	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6216					arg_ok
.1a6216	c2 30		rep #$30	            REP #$30
.1a6218	a5 23		lda $0823	                LDA ARGUMENT1
.1a621a	cf 3e 65 1a	cmp $1a653e	                CMP @l fp_one
.1a621e	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6220	cf 40 65 1a	cmp $1a6540	                CMP @l fp_one+2
.1a6224	b0 04		bcs $1a622a	                BCS gtone
.1a6226	20 ea 5e	jsr $1a5eea	            JSR Q_INV
.1a6229	18		clc		                CLC
.1a622a	a9 00 00	lda #$0000	gtone           LDA #0
.1a622d	a8		tay		                TAY
.1a622e	2a		rol a		                ROL             ; Rotate Carry into A; 0 means negate
.1a622f	48		pha		                PHA
.1a6230	e2 20		sep #$20	            SEP #$20
.1a6232	a9 00		lda #$00	                LDA #0
.1a6234	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a6238	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a623a	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a623e	c2 20		rep #$20	            REP #$20
.1a6240	af 96 65 1a	lda $1a6596	                LDA @l eexp64
.1a6244	85 29		sta $0829	                STA ARGUMENT2
.1a6246	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a624a	af 98 65 1a	lda $1a6598	                LDA @l eexp64+2
.1a624e	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6250	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a6254	20 28 5f	jsr $1a5f28	            JSR Q_FP_SCALE
.1a6257	8a		txa		                TXA
.1a6258	f0 07		beq $1a6261	                BEQ chk16
.1a625a	0a		asl a		                ASL             ; multiply counter by 64
.1a625b	0a		asl a		                ASL
.1a625c	0a		asl a		                ASL
.1a625d	0a		asl a		                ASL
.1a625e	0a		asl a		                ASL
.1a625f	0a		asl a		                ASL
.1a6260	a8		tay		                TAY
.1a6261	af 9a 65 1a	lda $1a659a	chk16           LDA @l eexp16
.1a6265	85 29		sta $0829	                STA ARGUMENT2
.1a6267	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a626b	af 9c 65 1a	lda $1a659c	                LDA @l eexp16+2
.1a626f	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6271	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a6275	20 28 5f	jsr $1a5f28	            JSR Q_FP_SCALE
.1a6278	8a		txa		                TXA
.1a6279	f0 0b		beq $1a6286	                BEQ chk04
.1a627b	0a		asl a		                ASL             ; multiply counter by 16
.1a627c	0a		asl a		                ASL
.1a627d	0a		asl a		                ASL
.1a627e	0a		asl a		                ASL
.1a627f	85 29		sta $0829	                STA ARGUMENT2   ; and add into total
.1a6281	18		clc		                CLC
.1a6282	98		tya		                TYA
.1a6283	65 29		adc $0829	                ADC ARGUMENT2
.1a6285	a8		tay		                TAY
.1a6286	af 9e 65 1a	lda $1a659e	chk04           LDA @l eexp04
.1a628a	85 29		sta $0829	                STA ARGUMENT2
.1a628c	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a6290	af a0 65 1a	lda $1a65a0	                LDA @l eexp04+2
.1a6294	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6296	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a629a	20 28 5f	jsr $1a5f28	            JSR Q_FP_SCALE
.1a629d	8a		txa		                TXA
.1a629e	f0 09		beq $1a62a9	                BEQ chk01
.1a62a0	0a		asl a		                ASL             ;multiply counter by 4
.1a62a1	0a		asl a		                ASL
.1a62a2	85 29		sta $0829	                STA ARGUMENT2   ;and add to total
.1a62a4	18		clc		                CLC
.1a62a5	98		tya		                TYA
.1a62a6	65 29		adc $0829	                ADC ARGUMENT2
.1a62a8	a8		tay		                TAY
.1a62a9	af a2 65 1a	lda $1a65a2	chk01           LDA @l eexp01
.1a62ad	85 29		sta $0829	                STA ARGUMENT2
.1a62af	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a62b3	af a4 65 1a	lda $1a65a4	                LDA @l eexp01+2
.1a62b7	85 2b		sta $082b	                STA ARGUMENT2+2
.1a62b9	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a62bd	20 28 5f	jsr $1a5f28	            JSR Q_FP_SCALE
.1a62c0	86 29		stx $0829	                STX ARGUMENT2   ; add counter to total
.1a62c2	18		clc		                CLC
.1a62c3	98		tya		                TYA
.1a62c4	65 29		adc $0829	                ADC ARGUMENT2
.1a62c6	a8		tay		                TAY
.1a62c7	20 82 60	jsr $1a6082	            JSR Q_FP_LN
.1a62ca	a5 23		lda $0823	                LDA ARGUMENT1
.1a62cc	85 29		sta $0829	                STA ARGUMENT2
.1a62ce	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a62d0	85 2b		sta $082b	                STA ARGUMENT2+2
.1a62d2	98		tya		                TYA
.1a62d3	85 23		sta $0823	                STA ARGUMENT1
.1a62d5	64 25		stz $0825	                STZ ARGUMENT1+2
.1a62d7	20 1c 5b	jsr $1a5b1c	            JSR ITOF
.1a62da	20 f9 55	jsr $1a55f9	            JSR OP_FP_ADD
.1a62dd	68		pla		                PLA
.1a62de	d0 07		bne $1a62e7	                BNE done
.1a62e0	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a62e2	09 00 80	ora #$8000	                ORA #$8000
.1a62e5	85 25		sta $0825	                STA ARGUMENT1+2
.1a62e7	7a		ply		done            PLY
.1a62e8	fa		plx		                PLX
.1a62e9	68		pla		                PLA
.1a62ea	28		plp		                PLP
.1a62eb	60		rts		            RTS
.1a62ec					FP_ASIN
.1a62ec	08		php		                PHP
.1a62ed	c2 30		rep #$30	            REP #$30
.1a62ef	48		pha		                PHA
.1a62f0	da		phx		                PHX
.1a62f1	a5 23		lda $0823	                LDA ARGUMENT1
.1a62f3	85 29		sta $0829	                STA ARGUMENT2
.1a62f5	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a62f7	85 2b		sta $082b	                STA ARGUMENT2+2
.1a62f9	20 b4 5e	jsr $1a5eb4	            JSR Q_SQ
.1a62fc	8b		phb		                PHB
.1a62fd	e2 20		sep #$20	            SEP #$20
.1a62ff	a9 1a		lda #$1a	                LDA #`asin_coeff
.1a6301	48		pha		                PHA
.1a6302	ab		plb		                PLB
.1a6303	c2 20		rep #$20	            REP #$20
.1a6305	a2 46 65	ldx #$6546	                LDX #<>asin_coeff
.1a6308	a0 05 00	ldy #$0005	                LDY #5
.1a630b	20 25 5e	jsr $1a5e25	            JSR Q_POLY_HR
.1a630e	ab		plb		                PLB
.1a630f	20 8f 56	jsr $1a568f	            JSR OP_FP_MUL
.1a6312	fa		plx		                PLX
.1a6313	68		pla		                PLA
.1a6314	28		plp		                PLP
.1a6315	60		rts		            RTS
.1a6316					FP_ACOS
.1a6316	08		php		                PHP
.1a6317	c2 30		rep #$30	            REP #$30
.1a6319	48		pha		                PHA
.1a631a	da		phx		                PHX
.1a631b	20 ec 62	jsr $1a62ec	            JSR FP_ASIN
.1a631e	af ae 65 1a	lda $1a65ae	                LDA @l halfpi
.1a6322	85 29		sta $0829	                STA ARGUMENT2
.1a6324	af b0 65 1a	lda $1a65b0	                LDA @l halfpi+2
.1a6328	85 2b		sta $082b	                STA ARGUMENT2+2
.1a632a	20 ee 55	jsr $1a55ee	            JSR OP_FP_SUB
.1a632d	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a632f	49 00 80	eor #$8000	                EOR #$8000
.1a6332	85 25		sta $0825	                STA ARGUMENT1+2
.1a6334	fa		plx		                PLX
.1a6335	68		pla		                PLA
.1a6336	28		plp		                PLP
.1a6337	60		rts		            RTS
.1a6338					FP_ATAN
.1a6338	08		php		                PHP
.1a6339	c2 30		rep #$30	            REP #$30
.1a633b	48		pha		                PHA
.1a633c	da		phx		                PHX
.1a633d	a5 23		lda $0823	                LDA ARGUMENT1
.1a633f	85 29		sta $0829	                STA ARGUMENT2
.1a6341	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6343	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6345	20 b4 5e	jsr $1a5eb4	            JSR Q_SQ
.1a6348	8b		phb		                PHB
.1a6349	e2 20		sep #$20	            SEP #$20
.1a634b	a9 1a		lda #$1a	                LDA #`atan_coeff
.1a634d	48		pha		                PHA
.1a634e	ab		plb		                PLB
.1a634f	c2 20		rep #$20	            REP #$20
.1a6351	a2 5a 65	ldx #$655a	                LDX #<>atan_coeff
.1a6354	a0 05 00	ldy #$0005	                LDY #5
.1a6357	20 25 5e	jsr $1a5e25	            JSR Q_POLY_HR
.1a635a	ab		plb		                PLB
.1a635b	20 8f 56	jsr $1a568f	            JSR OP_FP_MUL
.1a635e	fa		plx		                PLX
.1a635f	68		pla		                PLA
.1a6360	28		plp		                PLP
.1a6361	60		rts		            RTS
.1a6362					Q_FP_POW_INT
.1a6362	c2 20		rep #$20	            REP #$20
.1a6364	a5 23		lda $0823	            LDA ARGUMENT1
.1a6366	85 29		sta $0829	            STA ARGUMENT2
.1a6368	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a636a	85 2b		sta $082b	            STA ARGUMENT2+2
.1a636c	c2 20		rep #$20	            REP #$20
.1a636e	af 3e 65 1a	lda $1a653e	            LDA @l fp_one
.1a6372	85 23		sta $0823	            STA ARGUMENT1
.1a6374	af 40 65 1a	lda $1a6540	            LDA @l fp_one+2
.1a6378	85 25		sta $0825	            STA ARGUMENT1+2
.1a637a	8a		txa		loop            TXA
.1a637b	f0 30		beq $1a63ad	                BEQ done
.1a637d	4a		lsr a		                LSR
.1a637e	aa		tax		                TAX
.1a637f	90 03		bcc $1a6384	                BCC next
.1a6381	20 8f 56	jsr $1a568f	            JSR OP_FP_MUL
.1a6384					next
.1a6384	c2 20		rep #$20	            REP #$20
.1a6386	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6388	48		pha		            PHA
.1a6389	a5 23		lda $0823	            LDA ARGUMENT1
.1a638b	48		pha		            PHA
.1a638c	c2 20		rep #$20	            REP #$20
.1a638e	a5 29		lda $0829	            LDA ARGUMENT2
.1a6390	85 23		sta $0823	            STA ARGUMENT1
.1a6392	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a6394	85 25		sta $0825	            STA ARGUMENT1+2
.1a6396	20 b4 5e	jsr $1a5eb4	            JSR Q_SQ
.1a6399	c2 20		rep #$20	            REP #$20
.1a639b	a5 23		lda $0823	            LDA ARGUMENT1
.1a639d	85 29		sta $0829	            STA ARGUMENT2
.1a639f	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a63a1	85 2b		sta $082b	            STA ARGUMENT2+2
.1a63a3	c2 20		rep #$20	            REP #$20
.1a63a5	68		pla		            PLA
.1a63a6	85 23		sta $0823	            STA ARGUMENT1
.1a63a8	68		pla		            PLA
.1a63a9	85 25		sta $0825	            STA ARGUMENT1+2
.1a63ab	80 cd		bra $1a637a	                BRA loop
.1a63ad					done
.1a63ad	60		rts		            RTS
.1a63ae					Q_FP_EXP
.1a63ae	08		php		                PHP
.1a63af	c2 30		rep #$30	            REP #$30
.1a63b1	48		pha		                PHA
.1a63b2	da		phx		                PHX
.1a63b3	8b		phb		                PHB
.1a63b4	e2 20		sep #$20	            SEP #$20
.1a63b6	a9 1a		lda #$1a	                LDA #`exp_coeff
.1a63b8	48		pha		                PHA
.1a63b9	ab		plb		                PLB
.1a63ba	c2 20		rep #$20	            REP #$20
.1a63bc	a2 6e 65	ldx #$656e	                LDX #<>exp_coeff
.1a63bf	5a		phy		                PHY
.1a63c0	a0 0a 00	ldy #$000a	                LDY #10
.1a63c3	20 25 5e	jsr $1a5e25	            JSR Q_POLY_HR
.1a63c6	7a		ply		                PLY
.1a63c7	ab		plb		                PLB
.1a63c8	fa		plx		                PLX
.1a63c9	68		pla		                PLA
.1a63ca	28		plp		                PLP
.1a63cb	60		rts		            RTS
.1a63cc					FP_EXP
.1a63cc	08		php		                PHP
.1a63cd	c2 30		rep #$30	            REP #$30
.1a63cf	48		pha		                PHA
.1a63d0	da		phx		                PHX
.1a63d1	5a		phy		                PHY
.1a63d2	a5 23		lda $0823	                LDA ARGUMENT1   ; special case for x==0
.1a63d4	05 25		ora $0825	                ORA ARGUMENT1+2
.1a63d6	d0 10		bne $1a63e8	                BNE notzero
.1a63d8	c2 20		rep #$20	            REP #$20
.1a63da	af 3e 65 1a	lda $1a653e	            LDA @l fp_one
.1a63de	85 23		sta $0823	            STA ARGUMENT1
.1a63e0	af 40 65 1a	lda $1a6540	            LDA @l fp_one+2
.1a63e4	85 25		sta $0825	            STA ARGUMENT1+2
.1a63e6	80 61		bra $1a6449	                BRA done
.1a63e8	a5 25		lda $0825	notzero         LDA ARGUMENT1+2 ; check if negative
.1a63ea	29 00 80	and #$8000	                AND #$8000
.1a63ed	a8		tay		                TAY             ; Y != 0 -> arg was negative
.1a63ee	f0 07		beq $1a63f7	                BEQ notneg
.1a63f0	a5 25		lda $0825	                LDA ARGUMENT1+2 ; negate x
.1a63f2	29 ff 7f	and #$7fff	                AND #$7FFF
.1a63f5	85 25		sta $0825	                STA ARGUMENT1+2
.1a63f7					notneg
.1a63f7	c2 20		rep #$20	            REP #$20
.1a63f9	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a63fb	48		pha		            PHA
.1a63fc	a5 23		lda $0823	            LDA ARGUMENT1
.1a63fe	48		pha		            PHA
.1a63ff	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a6402	a6 23		ldx $0823	                LDX ARGUMENT1              ; INT(x) now in ARGUMENT1; low 16 bits into X
.1a6404	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a6407	c2 20		rep #$20	            REP #$20
.1a6409	a5 23		lda $0823	            LDA ARGUMENT1
.1a640b	85 29		sta $0829	            STA ARGUMENT2
.1a640d	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a640f	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6411	c2 20		rep #$20	            REP #$20
.1a6413	68		pla		            PLA
.1a6414	85 23		sta $0823	            STA ARGUMENT1
.1a6416	68		pla		            PLA
.1a6417	85 25		sta $0825	            STA ARGUMENT1+2
.1a6419	20 ee 55	jsr $1a55ee	            JSR OP_FP_SUB
.1a641c	20 ae 63	jsr $1a63ae	            JSR Q_FP_EXP
.1a641f	c2 20		rep #$20	            REP #$20
.1a6421	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6423	48		pha		            PHA
.1a6424	a5 23		lda $0823	            LDA ARGUMENT1
.1a6426	48		pha		            PHA
.1a6427	c2 20		rep #$20	            REP #$20
.1a6429	af a2 65 1a	lda $1a65a2	            LDA @leexp01
.1a642d	85 23		sta $0823	            STA ARGUMENT1
.1a642f	af a4 65 1a	lda $1a65a4	            LDA @leexp01+2
.1a6433	85 25		sta $0825	            STA ARGUMENT1+2
.1a6435	20 62 63	jsr $1a6362	            JSR Q_FP_POW_INT
.1a6438	c2 20		rep #$20	            REP #$20
.1a643a	68		pla		            PLA
.1a643b	85 29		sta $0829	            STA ARGUMENT2
.1a643d	68		pla		            PLA
.1a643e	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6440	20 8f 56	jsr $1a568f	            JSR OP_FP_MUL
.1a6443	98		tya		                TYA
.1a6444	f0 03		beq $1a6449	                BEQ done
.1a6446	20 ea 5e	jsr $1a5eea	            JSR Q_INV
.1a6449	7a		ply		done            PLY
.1a644a	fa		plx		                PLX
.1a644b	68		pla		                PLA
.1a644c	28		plp		                PLP
.1a644d	60		rts		            RTS
.1a644e					FP_SQR
.1a644e	08		php		                PHP
.1a644f	c2 30		rep #$30	            REP #$30
.1a6451	48		pha		                PHA
.1a6452	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6454	10 1f		bpl $1a6475	                BPL arg_ok
.1a6456	08		php		            PHP
.1a6457	c2 20		rep #$20	            REP #$20
.1a6459	48		pha		            PHA
.1a645a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a645d	5b		tcd		            TCD
.1a645e	68		pla		            PLA
.1a645f	28		plp		            PLP
.1a6460	e2 20		sep #$20	            SEP #$20
.1a6462	a9 17		lda #$17	            LDA #ERR_DOMAIN
.1a6464	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6468	c2 20		rep #$20	            REP #$20
.1a646a	29 ff 00	and #$00ff	            AND #$00FF
.1a646d	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a6470	e2 20		sep #$20	            SEP #$20
.1a6472	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6475					arg_ok
.1a6475	c2 30		rep #$30	            REP #$30
.1a6477	05 23		ora $0823	                ORA ARGUMENT1
.1a6479	f0 68		beq $1a64e3	                BEQ done
.1a647b	c2 20		rep #$20	            REP #$20
.1a647d	af 42 65 1a	lda $1a6542	            LDA @l fp_two
.1a6481	85 29		sta $0829	            STA ARGUMENT2
.1a6483	af 44 65 1a	lda $1a6544	            LDA @l fp_two+2
.1a6487	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6489	e2 20		sep #$20	            SEP #$20
.1a648b	a9 01		lda #$01	                LDA #TYPE_FLOAT
.1a648d	85 2d		sta $082d	                STA ARGTYPE2
.1a648f	c2 20		rep #$20	            REP #$20
.1a6491	c2 20		rep #$20	            REP #$20
.1a6493	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6495	48		pha		            PHA
.1a6496	a5 23		lda $0823	            LDA ARGUMENT1
.1a6498	48		pha		            PHA
.1a6499					loop
.1a6499	20 44 56	jsr $1a5644	            JSR OP_FP_DIV
.1a649c	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a649e	c5 2b		cmp $082b	                CMP ARGUMENT2+2
.1a64a0	d0 09		bne $1a64ab	                BNE more
.1a64a2	a5 23		lda $0823	                LDA ARGUMENT1
.1a64a4	45 29		eor $0829	                EOR ARGUMENT2
.1a64a6	29 f8 ff	and #$fff8	                AND #$FFF8
.1a64a9	f0 30		beq $1a64db	                BEQ exitloop
.1a64ab					more
.1a64ab	20 f9 55	jsr $1a55f9	            JSR OP_FP_ADD
.1a64ae	c2 20		rep #$20	            REP #$20
.1a64b0	af 42 65 1a	lda $1a6542	            LDA @l fp_two
.1a64b4	85 29		sta $0829	            STA ARGUMENT2
.1a64b6	af 44 65 1a	lda $1a6544	            LDA @l fp_two+2
.1a64ba	85 2b		sta $082b	            STA ARGUMENT2+2
.1a64bc	20 44 56	jsr $1a5644	            JSR OP_FP_DIV
.1a64bf	c2 20		rep #$20	            REP #$20
.1a64c1	a5 23		lda $0823	            LDA ARGUMENT1
.1a64c3	85 29		sta $0829	            STA ARGUMENT2
.1a64c5	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a64c7	85 2b		sta $082b	            STA ARGUMENT2+2
.1a64c9	c2 20		rep #$20	            REP #$20
.1a64cb	68		pla		            PLA
.1a64cc	85 23		sta $0823	            STA ARGUMENT1
.1a64ce	68		pla		            PLA
.1a64cf	85 25		sta $0825	            STA ARGUMENT1+2
.1a64d1	c2 20		rep #$20	            REP #$20
.1a64d3	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a64d5	48		pha		            PHA
.1a64d6	a5 23		lda $0823	            LDA ARGUMENT1
.1a64d8	48		pha		            PHA
.1a64d9	80 be		bra $1a6499	                BRA loop
.1a64db					exitloop
.1a64db	c2 20		rep #$20	            REP #$20
.1a64dd	68		pla		            PLA
.1a64de	85 29		sta $0829	            STA ARGUMENT2
.1a64e0	68		pla		            PLA
.1a64e1	85 2b		sta $082b	            STA ARGUMENT2+2
.1a64e3	68		pla		done            PLA
.1a64e4	28		plp		                PLP
.1a64e5	60		rts		            RTS
.1a64e6					cos_coeff
>1a64e6	01 0d d0 37			                .dword $37D00D01
>1a64ea	61 0b b6 ba			                .dword $BAB60B61
>1a64ee	ab aa 2a 3d			                .dword $3D2AAAAB
>1a64f2	00 00 00 bf			                .dword $BF000000
>1a64f6	00 00 80 3f			                .dword $3F800000
.1a64fa					sin_coeff
>1a64fa	1d ef 38 36			                .dword $3638EF1D
>1a64fe	01 0d 50 b9			                .dword $B9500D01
>1a6502	89 88 08 3c			                .dword $3C088889
>1a6506	ab aa 2a be			                .dword $BE2AAAAB
>1a650a	00 00 80 3f			                .dword $3F800000
.1a650e					tan_coeff
>1a650e	a4 27 b3 3c			                .dword $3CB327A4
>1a6512	d1 0d 5d 3d			                .dword $3D5D0DD1
>1a6516	89 88 08 3e			                .dword $3E088889
>1a651a	ab aa aa 3e			                .dword $3EAAAAAB
>1a651e	00 00 80 3f			                .dword $3F800000
.1a6522					ln_coeff
>1a6522	89 88 88 3d			                .dword $3D888889
>1a6526	d9 89 9d 3d			                .dword $3D9D89D9
>1a652a	8c 2e ba 3d			                .dword $3DBA2E8C
>1a652e	39 8e e3 3d			                .dword $3DE38E39
>1a6532	25 49 12 3e			                .dword $3E124925
>1a6536	cd cc 4c 3e			                .dword $3E4CCCCD
>1a653a	ab aa aa 3e			                .dword $3EAAAAAB
>1a653e	00 00 80 3f			fp_one          .dword $3F800000
>1a6542	00 00 00 40			fp_two          .dword $40000000
.1a6546					asin_coeff
>1a6546	8e e3 f8 3c			                .dword $3CF8E38E
>1a654a	6e db 36 3d			                .dword $3D36DB6E
>1a654e	9a 99 99 3d			                .dword $3D99999A
>1a6552	ab aa 2a 3e			                .dword $3E2AAAAB
>1a6556	00 00 80 3f			                .dword $3F800000
.1a655a					atan_coeff
>1a655a	39 8e e3 3d			                .dword $3DE38E39
>1a655e	25 49 12 be			                .dword $BE124925
>1a6562	cd cc 4c 3e			                .dword $3E4CCCCD
>1a6566	ab aa aa be			                .dword $BEAAAAAB
>1a656a	00 00 80 3f			                .dword $3F800000
.1a656e					exp_coeff
>1a656e	1d ef 38 36			        .dword $3638EF1D
>1a6572	01 0d d0 37			        .dword $37D00D01
>1a6576	01 0d 50 39			        .dword $39500D01
>1a657a	61 0b b6 3a			        .dword $3AB60B61
>1a657e	89 88 08 3c			        .dword $3C088889
>1a6582	ab aa 2a 3d			        .dword $3D2AAAAB
>1a6586	ab aa 2a 3e			        .dword $3E2AAAAB
>1a658a	00 00 00 3f			        .dword $3F000000
>1a658e	00 00 80 3f			        .dword $3F800000
>1a6592	00 00 80 3f			        .dword $3F800000
>1a6596	c1 2c a1 6d			eexp64          .dword $6DA12CC1
>1a659a	5f 97 07 4b			eexp16          .dword $4B07975F
>1a659e	81 64 5a 42			eexp04          .dword $425A6481
>1a65a2	54 f8 2d 40			eexp01          .dword $402DF854
>1a65a6	db 0f c9 40			twopi           .dword $40C90FDB
>1a65aa	db 0f 49 40			onepi           .dword $40490FDB
>1a65ae	db 0f c9 3f			halfpi          .dword $3FC90FDB
>1a65b2	db 0f 49 3f			quarterpi       .dword $3F490FDB

;******  Return to file: src\basic816.s


;******  Processing file: src\arrays.s

.1a65b6					ARR_ALLOC
.1a65b6	08		php		                PHP
.1a65b7	20 cf 12	jsr $1a12cf	            JSR HEAP_GETHED
.1a65ba	c2 20		rep #$20	            REP #$20
.1a65bc	a9 01 00	lda #$0001	                LDA #1                      ; ARGUMENT1 := 1
.1a65bf	85 23		sta $0823	                STA ARGUMENT1
.1a65c1	a9 00 00	lda #$0000	                LDA #0
.1a65c4	85 25		sta $0825	                STA ARGUMENT1+2
.1a65c6	e2 20		sep #$20	            SEP #$20
.1a65c8	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.1a65cc	c2 20		rep #$20	            REP #$20
.1a65ce	29 ff 00	and #$00ff	                AND #$00FF
.1a65d1	85 8f		sta $088f	                STA MCOUNT                  ; Save it to MCOUNT for later
.1a65d3	a8		tay		                TAY                         ; Y := number of dimensions
.1a65d4	a2 01 00	ldx #$0001	                LDX #1                      ; X := index to size 0
.1a65d7					size_loop
.1a65d7	c2 20		rep #$20	            REP #$20
.1a65d9	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X           ; ARGUMENT2 := Ith dimension
.1a65dd	85 29		sta $0829	                STA ARGUMENT2
.1a65df	a9 00 00	lda #$0000	                LDA #0
.1a65e2	85 2b		sta $082b	                STA ARGUMENT2+2
.1a65e4	e2 20		sep #$20	            SEP #$20
.1a65e6	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a65e8	85 2d		sta $082d	                STA ARGTYPE2
.1a65ea	c2 20		rep #$20	            REP #$20
.1a65ec	20 1a 28	jsr $1a281a	            JSR OP_MULTIPLY
.1a65ef	e8		inx		                INX
.1a65f0	e8		inx		                INX
.1a65f1	88		dey		                DEY
.1a65f2	d0 e3		bne $1a65d7	                BNE size_loop               ; If there are more dimensions, take the next one
.1a65f4	c2 20		rep #$20	            REP #$20
.1a65f6	a9 04 00	lda #$0004	                LDA #ARGUMENT_SIZE-1        ; Size of a data item (don't include the type code)
.1a65f9	85 29		sta $0829	                STA ARGUMENT2
.1a65fb	a9 00 00	lda #$0000	                LDA #0
.1a65fe	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6600	20 1a 28	jsr $1a281a	            JSR OP_MULTIPLY
.1a6603	e2 20		sep #$20	            SEP #$20
.1a6605	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF             ; SCRATCH := N * 2
.1a6609	85 0c		sta $080c	                STA SCRATCH
.1a660b	a9 00		lda #$00	                LDA #0
.1a660d	85 0d		sta $080d	                STA SCRATCH+1
.1a660f	c2 20		rep #$20	            REP #$20
.1a6611	06 0c		asl $080c	                ASL SCRATCH
.1a6613	38		sec		                SEC                         ; ARGUMENT1 := size of the complete block
.1a6614	a5 23		lda $0823	                LDA ARGUMENT1
.1a6616	65 0c		adc $080c	                ADC SCRATCH                 ; Size of data area + N*2 + 1 (in carry)
.1a6618	85 23		sta $0823	                STA ARGUMENT1
.1a661a	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a661c	69 00 00	adc #$0000	                ADC #0
.1a661f	85 25		sta $0825	                STA ARGUMENT1+2
.1a6621	d0 29		bne $1a664c	                BNE too_big                 ; size > 16-bit? Yes: throw an error
.1a6623	e2 20		sep #$20	            SEP #$20
.1a6625	a5 ea		lda $08ea	                LDA TOFINDTYPE              ; Get the type
.1a6627	09 80		ora #$80	                ORA #$80                    ; Flip the flag to make it an array of that type
.1a6629	a6 23		ldx $0823	                LDX ARGUMENT1               ; Get the computed size
.1a662b	20 93 10	jsr $1a1093	            JSR ALLOC
.1a662e	e2 20		sep #$20	            SEP #$20
.1a6630	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.1a6634	87 c0		sta [$08c0]	                STA [CURRBLOCK]             ; Write the number of dimensions to the array's preamble
.1a6636	a0 01 00	ldy #$0001	                LDY #1
.1a6639	a2 00 00	ldx #$0000	                LDX #0
.1a663c					copy_loop
.1a663c	e2 20		sep #$20	            SEP #$20
.1a663e	bf 01 4d 00	lda $004d01,x	                LDA @lARRIDXBUF+1,X         ; ARGUMENT2 := Ith dimension
.1a6642	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y           ; And write the dimension to the array's preamble
.1a6644	e4 8f		cpx $088f	                CPX MCOUNT                  ; Have we written the last byte?
.1a6646	f0 23		beq $1a666b	                BEQ null_array              ; Yes: clear the array
.1a6648	e8		inx		                INX                         ; No: move to the next byte
.1a6649	c8		iny		                INY
.1a664a	80 f0		bra $1a663c	                BRA copy_loop
.1a664c					too_big
.1a664c	08		php		            PHP
.1a664d	c2 20		rep #$20	            REP #$20
.1a664f	48		pha		            PHA
.1a6650	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6653	5b		tcd		            TCD
.1a6654	68		pla		            PLA
.1a6655	28		plp		            PLP
.1a6656	e2 20		sep #$20	            SEP #$20
.1a6658	a9 09		lda #$09	            LDA #ERR_RANGE
.1a665a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a665e	c2 20		rep #$20	            REP #$20
.1a6660	29 ff 00	and #$00ff	            AND #$00FF
.1a6663	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a6666	e2 20		sep #$20	            SEP #$20
.1a6668	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a666b					null_array
.1a666b	e2 20		sep #$20	            SEP #$20
.1a666d	38		sec		                SEC                         ; INDEX := pointer to first value
.1a666e	a5 c0		lda $08c0	                LDA CURRBLOCK
.1a6670	67 c0		adc [$08c0]	                ADC [CURRBLOCK]
.1a6672	85 08		sta $0808	                STA INDEX
.1a6674	a5 c1		lda $08c1	                LDA CURRBLOCK+1
.1a6676	69 00		adc #$00	                ADC #0
.1a6678	85 09		sta $0809	                STA INDEX+1
.1a667a	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a667c	69 00		adc #$00	                ADC #0
.1a667e	85 0a		sta $080a	                STA INDEX+2
.1a6680	64 0b		stz $080b	                STZ INDEX+3
.1a6682	c2 20		rep #$20	            REP #$20
.1a6684	a0 05 00	ldy #$0005	                LDY #HEAPOBJ.END            ; SCRATCH := pointer the the first byte after the array
.1a6687	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a6689	85 0c		sta $080c	                STA SCRATCH
.1a668b	e2 20		sep #$20	            SEP #$20
.1a668d	c8		iny		                INY
.1a668e	c8		iny		                INY
.1a668f	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a6691	85 0e		sta $080e	                STA SCRATCH+2
.1a6693	64 0f		stz $080f	                STZ SCRATCH+3
.1a6695					clr_loop
.1a6695	e2 20		sep #$20	            SEP #$20
.1a6697	a9 00		lda #$00	                LDA #0
.1a6699	87 08		sta [$0808]	                STA [INDEX]                 ; Clear the byte
.1a669b	c2 20		rep #$20	            REP #$20
.1a669d	18		clc		                CLC                         ; Increment INDEX
.1a669e	a5 08		lda $0808	                LDA INDEX
.1a66a0	69 01 00	adc #$0001	                ADC #1
.1a66a3	85 08		sta $0808	                STA INDEX
.1a66a5	a5 0a		lda $080a	                LDA INDEX+2
.1a66a7	69 00 00	adc #$0000	                ADC #0
.1a66aa	85 0a		sta $080a	                STA INDEX+2
.1a66ac	c5 0e		cmp $080e	                CMP SCRATCH+2               ; INDEX == SCRATCH?
.1a66ae	d0 e5		bne $1a6695	                BNE clr_loop                ; No: write to this next byte
.1a66b0	a5 08		lda $0808	                LDA INDEX
.1a66b2	c5 0c		cmp $080c	                CMP SCRATCH
.1a66b4	d0 df		bne $1a6695	                BNE clr_loop
.1a66b6					done
.1a66b6	28		plp		                PLP
.1a66b7	60		rts		            RTS
.1a66b8					ARR_CELL
.1a66b8	08		php		                PHP
.1a66b9	c2 20		rep #$20	            REP #$20
.1a66bb	64 08		stz $0808	                STZ INDEX               ; INDEX := 0
.1a66bd	64 0a		stz $080a	                STZ INDEX+2
.1a66bf	e2 20		sep #$20	            SEP #$20
.1a66c1	af 00 4d 00	lda $004d00	                LDA @l ARRIDXBUF        ; MCOUNT := N (number of dimensions)
.1a66c5	85 8f		sta $088f	                STA MCOUNT
.1a66c7	64 90		stz $0890	                STZ MCOUNT+1
.1a66c9	a2 01 00	ldx #$0001	                LDX #1                  ; X := index to dimension 0
.1a66cc	e2 20		sep #$20	            SEP #$20
.1a66ce	a7 c0		lda [$08c0]	                LDA [CURRBLOCK]         ; Make sure the dimensions of the array
.1a66d0	c5 8f		cmp $088f	                CMP MCOUNT              ; ... match those requested
.1a66d2	f0 22		beq $1a66f6	                BEQ dims_match          ; Yes: the dimensions match
.1a66d4	a6 8f		ldx $088f	                LDX MCOUNT
.1a66d6	00		brk #		                BRK
.1a66d7					arg_err
.1a66d7	08		php		            PHP
.1a66d8	c2 20		rep #$20	            REP #$20
.1a66da	48		pha		            PHA
.1a66db	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a66de	5b		tcd		            TCD
.1a66df	68		pla		            PLA
.1a66e0	28		plp		            PLP
.1a66e1	e2 20		sep #$20	            SEP #$20
.1a66e3	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a66e5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a66e9	c2 20		rep #$20	            REP #$20
.1a66eb	29 ff 00	and #$00ff	            AND #$00FF
.1a66ee	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a66f1	e2 20		sep #$20	            SEP #$20
.1a66f3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a66f6	c9 01		cmp #$01	dims_match      CMP #1                  ; Check to see if this array is one dimensional
.1a66f8	f0 3a		beq $1a6734	                BEQ add_last            ; If so, just add the index of the cell to INDEX
.1a66fa	a0 01 00	ldy #$0001	                LDY #1
.1a66fd					index_loop
.1a66fd	e2 20		sep #$20	            SEP #$20
.1a66ff	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; ARGUMENT1 := I_j
.1a6703	85 23		sta $0823	                STA ARGUMENT1
.1a6705	64 24		stz $0824	                STZ ARGUMENT1+1
.1a6707	64 25		stz $0825	                STZ ARGUMENT1+2
.1a6709	64 26		stz $0826	                STZ ARGUMENT1+3
.1a670b	b7 c0		lda [$08c0],y	                LDA [CURRBLOCK],Y       ; ARGUMENT2 := D_j
.1a670d	85 29		sta $0829	                STA ARGUMENT2
.1a670f	64 2a		stz $082a	                STZ ARGUMENT2+1
.1a6711	64 2b		stz $082b	                STZ ARGUMENT2+2
.1a6713	64 2c		stz $082c	                STZ ARGUMENT2+3
.1a6715	a5 23		lda $0823	                LDA ARGUMENT1
.1a6717	c5 29		cmp $0829	                CMP ARGUMENT2           ; Is I_j >= D_j
.1a6719	b0 68		bcs $1a6783	                BGE range_err           ; Yes: throw an out-of-range error
.1a671b	20 1a 28	jsr $1a281a	            JSR OP_MULTIPLY
.1a671e	c2 20		rep #$20	            REP #$20
.1a6720	18		clc		                CLC                     ; INDEX := INDEX + ARGUMENT1
.1a6721	a5 08		lda $0808	                LDA INDEX
.1a6723	65 23		adc $0823	                ADC ARGUMENT1
.1a6725	85 08		sta $0808	                STA INDEX
.1a6727	a5 0a		lda $080a	                LDA INDEX+2
.1a6729	65 25		adc $0825	                ADC ARGUMENT1+2
.1a672b	85 0a		sta $080a	                STA INDEX+2
.1a672d	e8		inx		                INX
.1a672e	e8		inx		                INX
.1a672f	c8		iny		                INY
.1a6730	c4 8f		cpy $088f	                CPY MCOUNT              ; Are we on the last index?
.1a6732	d0 c9		bne $1a66fd	                BNE index_loop          ; No: move to the next index and try again
.1a6734					add_last
.1a6734	e2 20		sep #$20	            SEP #$20
.1a6736	18		clc		                CLC
.1a6737	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; INDEX := INDEX + I_(n-1)
.1a673b	85 90		sta $0890	                STA MCOUNT+1
.1a673d	65 08		adc $0808	                ADC INDEX
.1a673f	85 08		sta $0808	                STA INDEX
.1a6741	a5 09		lda $0809	                LDA INDEX+1
.1a6743	69 00		adc #$00	                ADC #0
.1a6745	85 09		sta $0809	                STA INDEX+1
.1a6747	c2 20		rep #$20	            REP #$20
.1a6749	a5 0a		lda $080a	                LDA INDEX+2
.1a674b	69 00 00	adc #$0000	                ADC #0
.1a674e	85 0a		sta $080a	                STA INDEX+2
.1a6750	c2 20		rep #$20	            REP #$20
.1a6752	06 08		asl $0808	                ASL INDEX               ; INDEX := INDEX * 4 (size of a value)
.1a6754	26 0a		rol $080a	                ROL INDEX+2
.1a6756	06 08		asl $0808	                ASL INDEX
.1a6758	26 0a		rol $080a	                ROL INDEX+2
.1a675a	e2 20		sep #$20	            SEP #$20
.1a675c	38		sec		                SEC
.1a675d	a5 08		lda $0808	                LDA INDEX
.1a675f	65 8f		adc $088f	                ADC MCOUNT
.1a6761	85 08		sta $0808	                STA INDEX
.1a6763	a5 09		lda $0809	                LDA INDEX+1
.1a6765	69 00		adc #$00	                ADC #0
.1a6767	85 09		sta $0809	                STA INDEX+1
.1a6769	c2 20		rep #$20	            REP #$20
.1a676b	a5 0a		lda $080a	                LDA INDEX+2
.1a676d	69 00 00	adc #$0000	                ADC #0
.1a6770	85 0a		sta $080a	                STA INDEX+2
.1a6772	18		clc		                CLC                     ; INDEX := INDEX + CURRBLOCK (point to the address desired)
.1a6773	a5 08		lda $0808	                LDA INDEX
.1a6775	65 c0		adc $08c0	                ADC CURRBLOCK
.1a6777	85 08		sta $0808	                STA INDEX
.1a6779	e2 20		sep #$20	            SEP #$20
.1a677b	a5 0a		lda $080a	                LDA INDEX+2
.1a677d	65 c2		adc $08c2	                ADC CURRBLOCK+2
.1a677f	85 0a		sta $080a	                STA INDEX+2
.1a6781	28		plp		                PLP
.1a6782	60		rts		            RTS
.1a6783					range_err
.1a6783	08		php		            PHP
.1a6784	c2 20		rep #$20	            REP #$20
.1a6786	48		pha		            PHA
.1a6787	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a678a	5b		tcd		            TCD
.1a678b	68		pla		            PLA
.1a678c	28		plp		            PLP
.1a678d	e2 20		sep #$20	            SEP #$20
.1a678f	a9 09		lda #$09	            LDA #ERR_RANGE
.1a6791	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6795	c2 20		rep #$20	            REP #$20
.1a6797	29 ff 00	and #$00ff	            AND #$00FF
.1a679a	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a679d	e2 20		sep #$20	            SEP #$20
.1a679f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a67a2					ARR_SET
.1a67a2	08		php		                PHP
.1a67a3	20 cf 12	jsr $1a12cf	            JSR HEAP_GETHED
.1a67a6	e2 20		sep #$20	            SEP #$20
.1a67a8	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.1a67ab	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a67ad	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.1a67af	c9 02		cmp #$02	                CMP #TYPE_STRING    ; Is it a string array?
.1a67b1	d0 05		bne $1a67b8	                BNE chk_integer
.1a67b3	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a67b6	80 10		bra $1a67c8	                BRA save_type
.1a67b8	c9 00		cmp #$00	chk_integer     CMP #TYPE_INTEGER   ; Is it an integer array?
.1a67ba	d0 05		bne $1a67c1	                BNE chk_float
.1a67bc	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a67bf	80 07		bra $1a67c8	                BRA save_type
.1a67c1	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT     ; Is it an float array?
.1a67c3	d0 2b		bne $1a67f0	                BNE type_mismatch   ; No: throw a type mismatch error... something strange...
.1a67c5	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a67c8	a5 27		lda $0827	save_type       LDA ARGTYPE1        ; Save the type
.1a67ca	48		pha		                PHA
.1a67cb	c2 20		rep #$20	            REP #$20
.1a67cd	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Save ARGUMENT1
.1a67cf	48		pha		                PHA
.1a67d0	a5 23		lda $0823	                LDA ARGUMENT1
.1a67d2	48		pha		                PHA
.1a67d3	20 b8 66	jsr $1a66b8	            JSR ARR_CELL
.1a67d6	68		pla		                PLA                 ; Restore ARGUMENT1
.1a67d7	85 23		sta $0823	                STA ARGUMENT1
.1a67d9	68		pla		                PLA
.1a67da	85 25		sta $0825	                STA ARGUMENT1+2
.1a67dc	e2 20		sep #$20	            SEP #$20
.1a67de	68		pla		                PLA
.1a67df	85 27		sta $0827	                STA ARGTYPE1
.1a67e1	c2 20		rep #$20	            REP #$20
.1a67e3	a5 23		lda $0823	                LDA ARGUMENT1       ; Set the value in the cell
.1a67e5	87 08		sta [$0808]	                STA [INDEX]
.1a67e7	a0 02 00	ldy #$0002	                LDY #2
.1a67ea	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a67ec	97 08		sta [$0808],y	                STA [INDEX],Y
.1a67ee	28		plp		                PLP
.1a67ef	60		rts		            RTS
.1a67f0					type_mismatch
.1a67f0	08		php		            PHP
.1a67f1	c2 20		rep #$20	            REP #$20
.1a67f3	48		pha		            PHA
.1a67f4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a67f7	5b		tcd		            TCD
.1a67f8	68		pla		            PLA
.1a67f9	28		plp		            PLP
.1a67fa	e2 20		sep #$20	            SEP #$20
.1a67fc	a9 04		lda #$04	            LDA #ERR_TYPE
.1a67fe	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6802	c2 20		rep #$20	            REP #$20
.1a6804	29 ff 00	and #$00ff	            AND #$00FF
.1a6807	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a680a	e2 20		sep #$20	            SEP #$20
.1a680c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a680f					ARR_REF
.1a680f	08		php		                PHP
.1a6810	20 cf 12	jsr $1a12cf	            JSR HEAP_GETHED
.1a6813	f4 00 00	pea #$0000	                PEA #0              ; Make room on the stack that ARR_CELL expects
.1a6816	f4 00 00	pea #$0000	                PEA #0
.1a6819	e2 20		sep #$20	            SEP #$20
.1a681b	48		pha		                PHA
.1a681c	20 b8 66	jsr $1a66b8	            JSR ARR_CELL
.1a681f	e2 20		sep #$20	            SEP #$20
.1a6821	68		pla		                PLA
.1a6822	c2 20		rep #$20	            REP #$20
.1a6824	68		pla		                PLA
.1a6825	68		pla		                PLA
.1a6826	c2 20		rep #$20	            REP #$20
.1a6828	a7 08		lda [$0808]	                LDA [INDEX]         ; Get the value in the cell
.1a682a	85 23		sta $0823	                STA ARGUMENT1
.1a682c	a0 02 00	ldy #$0002	                LDY #2
.1a682f	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a6831	85 25		sta $0825	                STA ARGUMENT1+2
.1a6833	e2 20		sep #$20	            SEP #$20
.1a6835	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.1a6838	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a683a	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.1a683c	85 27		sta $0827	                STA ARGTYPE1        ; Set the type of the return value
.1a683e	20 23 18	jsr $1a1823	            JSR STR_NORMAL
.1a6841	28		plp		                PLP
.1a6842	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\dos.s

.0000					DIRENTRY
>0000					SHORTNAME               .fill 11        ; $00 - The short name of the file (8 name, 3 extension)
>000b					ATTRIBUTE               .byte ?         ; $0B - The attribute bits
>000c					IGNORED1                .word ?         ; $0C - Unused (by us) bytes
>000e					CREATE_TIME             .word ?         ; $0E - Creation time
>0010					CREATE_DATE             .word ?         ; $10 - Creation date
>0012					ACCESS_DATE             .word ?         ; $12 - Last access date
>0014					CLUSTER_H               .word ?         ; $14 - High word of the first cluster #
>0016					MODIFIED_TIME           .word ?         ; $16 - Last modified time
>0018					MODIFIED_DATE           .word ?         ; $18 - Last modified date
>001a					CLUSTER_L               .word ?         ; $1A - Low word of the first cluster #
>001c					SIZE                    .dword ?        ; $1C - The size of the file (in bytes)
=$01					DOS_ATTR_RO = $01                       ; File is read-only
=$02					DOS_ATTR_HIDDEN = $02                   ; File is hidden
=$04					DOS_ATTR_SYSTEM = $04                   ; File is a system file
=$08					DOS_ATTR_VOLUME = $08                   ; Entry is the volume label
=$10					DOS_ATTR_DIR = $10                      ; Entry is a directory
=$20					DOS_ATTR_ARCH = $20                     ; Entry has changed since last backup
=$0f					DOS_ATTR_LONGNAME = $0F                 ; Entry is the long file name
=$e5					DOS_DIR_ENT_UNUSED = $E5                ; Marker for an unused directory entry
.0000					FILEDESC
>0000					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>0001					DEV                 .byte ?             ; The ID of the device holding the file
>0002					PATH                .dword ?            ; Pointer to a NULL terminated path string
>0006					CLUSTER             .dword ?            ; The current cluster of the file.
>000a					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>000e					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>0012					FILESIZE            .dword ?            ; The size of the file
>0016					CREATE_DATE         .word ?             ; The creation date of the file
>0018					CREATE_TIME         .word ?             ; The creation time of the file
>001a					MODIFIED_DATE       .word ?             ; The modification date of the file
>001c					MODIFIED_TIME       .word ?             ; The modification time of the file
=$01					FD_STAT_READ = $01                      ; The file is readable
=$02					FD_STAT_WRITE = $02                     ; The file is writable
=$40					FD_STAT_OPEN = $40                      ; The file is open
=$60					FD_STAT_ERROR = $60                     ; The file is in an error condition
=$80					FD_STAT_EOF = $80                       ; The file cursor is at the end of the file
>1af073					CLUSTER_BUFF    .fill 512           ; A buffer for cluster read/write operations
.1af273					FD_IN
>1af273					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>1af274					DEV                 .byte ?             ; The ID of the device holding the file
>1af275					PATH                .dword ?            ; Pointer to a NULL terminated path string
>1af279					CLUSTER             .dword ?            ; The current cluster of the file.
>1af27d					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>1af281					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>1af285					FILESIZE            .dword ?            ; The size of the file
>1af289					CREATE_DATE         .word ?             ; The creation date of the file
>1af28b					CREATE_TIME         .word ?             ; The creation time of the file
>1af28d					MODIFIED_DATE       .word ?             ; The modification date of the file
>1af28f					MODIFIED_TIME       .word ?             ; The modification time of the file
.1a6843					PR_FILESIZE
.1a6843	da		phx		                PHX
.1a6844	0b		phd		                PHD
.1a6845	08		php		                PHP
.1a6846	08		php		            PHP
.1a6847	c2 20		rep #$20	            REP #$20
.1a6849	48		pha		            PHA
.1a684a	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a684d	5b		tcd		            TCD
.1a684e	68		pla		            PLA
.1a684f	28		plp		            PLP
.1a6850	c2 30		rep #$30	            REP #$30
.1a6852	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6854	89 f0 ff	bit #$fff0	                BIT #$FFF0              ; Check to see if the amount is in MB range
.1a6857	d0 29		bne $1a6882	                BNE pr_mb               ; If so, print it in MBs
.1a6859	89 0f 00	bit #$000f	                BIT #$000F              ; Check to see if the amount is in KB range
.1a685c	d0 0c		bne $1a686a	                BNE pr_kb
.1a685e	a5 23		lda $0823	                LDA ARGUMENT1
.1a6860	89 00 fc	bit #$fc00	                BIT #$FC00
.1a6863	d0 05		bne $1a686a	                BNE pr_kb               ; If so, print it in KBs
.1a6865					pr_regular
.1a6865	20 91 45	jsr $1a4591	            JSR PR_INTEGER
.1a6868	80 2e		bra $1a6898	                BRA done
.1a686a	a2 0a 00	ldx #$000a	pr_kb           LDX #10                 ; Shift so the amount in KB is in ARGUMENT1
.1a686d	46 25		lsr $0825	kb_shift        LSR ARGUMENT1+2
.1a686f	66 23		ror $0823	                ROR ARGUMENT1
.1a6871	ca		dex		                DEX
.1a6872	d0 f9		bne $1a686d	                BNE kb_shift
.1a6874	20 91 45	jsr $1a4591	            JSR PR_INTEGER
.1a6877	e2 20		sep #$20	            SEP #$20
.1a6879	a9 4b		lda #$4b	                LDA #'K'
.1a687b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a687e	c2 20		rep #$20	            REP #$20
.1a6880	80 16		bra $1a6898	                BRA done
.1a6882	a2 14 00	ldx #$0014	pr_mb           LDX #20                 ; Shift so the amount in MB is in ARGUMENT1
.1a6885	46 25		lsr $0825	mb_shift        LSR ARGUMENT1+2
.1a6887	66 23		ror $0823	                ROR ARGUMENT1
.1a6889	ca		dex		                DEX
.1a688a	d0 f9		bne $1a6885	                BNE mb_shift
.1a688c	20 91 45	jsr $1a4591	            JSR PR_INTEGER
.1a688f	e2 20		sep #$20	            SEP #$20
.1a6891	a9 4d		lda #$4d	                LDA #'M'
.1a6893	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6896	c2 20		rep #$20	            REP #$20
.1a6898	28		plp		done            PLP
.1a6899	2b		pld		                PLD
.1a689a	fa		plx		                PLX
.1a689b	60		rts		            RTS
.1a689c					CMD_DIR
.1a689c	0b		phd		                PHD
.1a689d	08		php		                PHP
.1a689e	c2 30		rep #$30	            REP #$30
.1a68a0	a9 00 00	lda #$0000	                LDA #0                      ; Zero out the pagination line count
.1a68a3	8f b6 08 00	sta $0008b6	                STA @l LINECOUNT
.1a68a7	8f b8 08 00	sta $0008b8	                STA @l LINECOUNT+2
.1a68ab	e2 20		sep #$20	            SEP #$20
.1a68ad	20 3e 22	jsr $1a223e	            JSR PEEK_TOK
.1a68b0	c9 00		cmp #$00	                CMP #0
.1a68b2	f0 08		beq $1a68bc	                BEQ set_null                ; If none provided, set the path to empty
.1a68b4	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a68b7	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a68ba	80 11		bra $1a68cd	                BRA set_fd
.1a68bc					set_null
.1a68bc	c2 20		rep #$20	            REP #$20
.1a68be	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT1 to the NULL string
.1a68c1	85 23		sta $0823	                STA ARGUMENT1
.1a68c3	85 25		sta $0825	                STA ARGUMENT1+2
.1a68c5	e2 20		sep #$20	            SEP #$20
.1a68c7	a9 02		lda #$02	                LDA #TYPE_STRING
.1a68c9	85 27		sta $0827	                STA ARGTYPE1
.1a68cb	c2 20		rep #$20	            REP #$20
.1a68cd					set_fd
.1a68cd	20 fd 69	jsr $1a69fd	            JSR SETFILEDESC
.1a68d0	22 08 11 00	jsl $001108	                JSL FK_DIROPEN              ; Open up the directory
.1a68d4	b0 22		bcs $1a68f8	                BCS pr_first
.1a68d6	20 ae 6a	jsr $1a6aae	            JSR SET_DOSSTAT
.1a68d9	08		php		            PHP
.1a68da	c2 20		rep #$20	            REP #$20
.1a68dc	48		pha		            PHA
.1a68dd	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a68e0	5b		tcd		            TCD
.1a68e1	68		pla		            PLA
.1a68e2	28		plp		            PLP
.1a68e3	e2 20		sep #$20	            SEP #$20
.1a68e5	a9 10		lda #$10	            LDA #ERR_DIRECTORY
.1a68e7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a68eb	c2 20		rep #$20	            REP #$20
.1a68ed	29 ff 00	and #$00ff	            AND #$00FF
.1a68f0	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a68f3	e2 20		sep #$20	            SEP #$20
.1a68f5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a68f8					pr_first
.1a68f8	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a68fb					pr_entry
.1a68fb	08		php		            PHP
.1a68fc	c2 20		rep #$20	            REP #$20
.1a68fe	48		pha		            PHA
.1a68ff	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.1a6902	5b		tcd		            TCD
.1a6903	68		pla		            PLA
.1a6904	28		plp		            PLP
.1a6905	e2 20		sep #$20	            SEP #$20
.1a6907	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Start with the file name
.1a690a	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the initial character of the name
.1a690c	d0 03		bne $1a6911	                BNE chk_unused
.1a690e	82 a9 00	brl $1a69ba	                BRL done                    ; If it's NULL, we're done
.1a6911	c9 e5		cmp #$e5	chk_unused      CMP #DOS_DIR_ENT_UNUSED     ; Is it the unusued code?
.1a6913	d0 03		bne $1a6918	                BNE chk_attributes
.1a6915	82 96 00	brl $1a69ae	                BRL next_entry              ; Yes: go to the next entry
.1a6918	a0 0b 00	ldy #$000b	chk_attributes  LDY #DIRENTRY.ATTRIBUTE
.1a691b	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute byte
.1a691d	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.1a691f	f0 03		beq $1a6924	                BEQ chk_hidden
.1a6921	82 a9 00	brl $1a69cd	                BRL pr_volume               ; Print the volume label
.1a6924	89 02		bit #$02	chk_hidden      BIT #DOS_ATTR_HIDDEN        ; Is it a hidden file?
.1a6926	f0 03		beq $1a692b	                BEQ chk_long
.1a6928	82 83 00	brl $1a69ae	                BRL next_entry              ; Yes: go to the next entry
.1a692b	29 0f		and #$0f	chk_long        AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.1a692d	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.1a692f	d0 03		bne $1a6934	                BNE get_short_name
.1a6931	82 7a 00	brl $1a69ae	                BRL next_entry              ; Yes: go to the next entry
.1a6934	a0 00 00	ldy #$0000	get_short_name  LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.1a6937	b7 18		lda [$0338],y	pr_name_loop    LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.1a6939	20 18 00	jsr $1a0018	            JSR PRINTC
.1a693c	c8		iny		                INY                         ; Move to the next character
.1a693d	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.1a6940	d0 f5		bne $1a6937	                BNE pr_name_loop            ; No: print this new character
.1a6942	a9 20		lda #$20	                LDA #' '                    ; Print the separator
.1a6944	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6947	a0 08 00	ldy #$0008	                LDY #DIRENTRY.SHORTNAME+8   ; Move to the first of the extension characters
.1a694a	b7 18		lda [$0338],y	pr_ext_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.1a694c	20 18 00	jsr $1a0018	                JSR PRINTC                  ; Otherwise: print it.
.1a694f	c8		iny		                INY                         ; Move to the next character
.1a6950	c0 0b 00	cpy #$000b	                CPY #DIRENTRY.SHORTNAME+11  ; Are we at the end of the extension portion?
.1a6953	d0 f5		bne $1a694a	                BNE pr_ext_loop             ; No: print this new character
.1a6955	a9 09		lda #$09	pr_tab1         LDA #CHAR_TAB               ; Print a TAB
.1a6957	20 18 00	jsr $1a0018	            JSR PRINTC
.1a695a	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.1a695d	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.1a695f	89 10		bit #$10	                BIT #DOS_ATTR_DIR           ; Is it a directory?
.1a6961	d0 1e		bne $1a6981	                BNE pr_attr                 ; Yes: skip printing a file size
.1a6963	c2 20		rep #$20	            REP #$20
.1a6965	a0 1c 00	ldy #$001c	                LDY #DIRENTRY.SIZE
.1a6968	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the file size
.1a696a	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.1a696e	c8		iny		                INY
.1a696f	c8		iny		                INY
.1a6970	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y
.1a6972	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.1a6976	e2 20		sep #$20	            SEP #$20
.1a6978	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a697a	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.1a697e	20 43 68	jsr $1a6843	            JSR PR_FILESIZE
.1a6981	a9 09		lda #$09	pr_attr         LDA #CHAR_TAB               ; Print a TAB
.1a6983	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6986	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.1a6989	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.1a698b	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.1a698d	d0 1c		bne $1a69ab	                BNE end_entry               ; Yes: we're done printing this entry
.1a698f	89 01		bit #$01	chk_read        BIT #DOS_ATTR_RO            ; Is it a read-only file?
.1a6991	f0 05		beq $1a6998	                BEQ chk_system
.1a6993	a9 52		lda #$52	                LDA #'R'                    ; Yes: print an R
.1a6995	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6998	89 04		bit #$04	chk_system      BIT #DOS_ATTR_SYSTEM        ; Is it System file?
.1a699a	f0 05		beq $1a69a1	                BEQ chk_directory
.1a699c	a9 53		lda #$53	                LDA #'S'                    ; Yes: print an S
.1a699e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a69a1	89 10		bit #$10	chk_directory   BIT #DOS_ATTR_DIR           ; Is it a directory?
.1a69a3	f0 05		beq $1a69aa	                BEQ pr_tab2
.1a69a5	a9 44		lda #$44	                LDA #'D'                    ; Yes: print a D
.1a69a7	20 18 00	jsr $1a0018	            JSR PRINTC
.1a69aa	ea		nop		pr_tab2         NOP
.1a69ab					end_entry
.1a69ab	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a69ae					next_entry
.1a69ae	20 b3 03	jsr $1a03b3	            JSR PAGINATE
.1a69b1	22 0c 11 00	jsl $00110c	                JSL FK_DIRNEXT
.1a69b5	90 03		bcc $1a69ba	                BCC done
.1a69b7	82 41 ff	brl $1a68fb	                BRL pr_entry
.1a69ba					done
.1a69ba	20 ae 6a	jsr $1a6aae	            JSR SET_DOSSTAT
.1a69bd	08		php		            PHP
.1a69be	c2 20		rep #$20	            REP #$20
.1a69c0	48		pha		            PHA
.1a69c1	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a69c4	5b		tcd		            TCD
.1a69c5	68		pla		            PLA
.1a69c6	28		plp		            PLP
.1a69c7	20 22 21	jsr $1a2122	            JSR SKIPSTMT
.1a69ca	28		plp		                PLP
.1a69cb	2b		pld		                PLD
.1a69cc	60		rts		            RTS
.1a69cd					pr_volume
.1a69cd	08		php		            PHP
.1a69ce	c2 20		rep #$20	            REP #$20
.1a69d0	48		pha		            PHA
.1a69d1	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.1a69d4	5b		tcd		            TCD
.1a69d5	68		pla		            PLA
.1a69d6	28		plp		            PLP
.1a69d7	e2 20		sep #$20	            SEP #$20
.1a69d9	29 0f		and #$0f	                AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.1a69db	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.1a69dd	f0 cf		beq $1a69ae	                BEQ next_entry              ; Yes: skip it
.1a69df	a9 5b		lda #$5b	pr_lbracket     LDA #'['
.1a69e1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a69e4	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.1a69e7	b7 18		lda [$0338],y	pr_vol_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.1a69e9	c9 20		cmp #$20	                CMP #CHAR_SP                ; Is it a blank?
.1a69eb	f0 09		beq $1a69f6	                BEQ pr_rbracket             ; Yes: end the name and print the dot
.1a69ed	20 18 00	jsr $1a0018	            JSR PRINTC
.1a69f0	c8		iny		                INY                         ; Move to the next character
.1a69f1	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.1a69f4	d0 f1		bne $1a69e7	                BNE pr_vol_loop             ; No: print this new character
.1a69f6	a9 5d		lda #$5d	pr_rbracket     LDA #']'                    ; Print a close bracket
.1a69f8	20 18 00	jsr $1a0018	            JSR PRINTC
.1a69fb	80 ae		bra $1a69ab	                BRA end_entry               ; And try to get the next entry
.1a69fd					SETFILEDESC
.1a69fd	0b		phd		                PHD
.1a69fe	08		php		                PHP
.1a69ff	08		php		            PHP
.1a6a00	c2 20		rep #$20	            REP #$20
.1a6a02	48		pha		            PHA
.1a6a03	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.1a6a06	5b		tcd		            TCD
.1a6a07	68		pla		            PLA
.1a6a08	28		plp		            PLP
.1a6a09	c2 30		rep #$30	            REP #$30
.1a6a0b	a9 73 f2	lda #$f273	                LDA #<>FD_IN            ; Point to the file descriptor
.1a6a0e	85 20		sta $0340	                STA DOS_FD_PTR
.1a6a10	a9 1a 00	lda #$001a	                LDA #`FD_IN
.1a6a13	85 22		sta $0342	                STA DOS_FD_PTR+2
.1a6a15	a0 00 00	ldy #$0000	                LDY #0                  ; Fille the file descriptor with 0
.1a6a18	e2 20		sep #$20	            SEP #$20
.1a6a1a	a9 00		lda #$00	                LDA #0
.1a6a1c	97 20		sta [$0340],y	zero_loop       STA [DOS_FD_PTR],Y
.1a6a1e	c8		iny		                INY
.1a6a1f	c0 1e 00	cpy #$001e	                CPY #SIZE(FILEDESC)
.1a6a22	d0 f8		bne $1a6a1c	                BNE zero_loop
.1a6a24	c2 20		rep #$20	            REP #$20
.1a6a26	a9 73 f0	lda #$f073	                LDA #<>CLUSTER_BUFF     ; Point to the cluster buffer
.1a6a29	8f 81 f2 1a	sta $1af281	                STA @l FD_IN.BUFFER
.1a6a2d	a9 1a 00	lda #$001a	                LDA #`CLUSTER_BUFF
.1a6a30	8f 83 f2 1a	sta $1af283	                STA @l FD_IN.BUFFER+2
.1a6a34	af 23 08 00	lda $000823	                LDA @l ARGUMENT1        ; Point the file desriptor to the path
.1a6a38	8f 75 f2 1a	sta $1af275	                STA @l FD_IN.PATH
.1a6a3c	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a6a40	8f 77 f2 1a	sta $1af277	                STA @l FD_IN.PATH+2
.1a6a44	28		plp		                PLP
.1a6a45	2b		pld		                PLD
.1a6a46	60		rts		            RTS
.1a6a47					S_BLOAD
.1a6a47	08		php		                PHP
.1a6a48	c2 30		rep #$30	            REP #$30
.1a6a4a	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a6a4d	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a6a50	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6a53	20 fd 69	jsr $1a69fd	            JSR SETFILEDESC
.1a6a56	e2 20		sep #$20	            SEP #$20
.1a6a58	a9 2c		lda #$2c	                LDA #','
.1a6a5a	85 37		sta $0837	                STA TARGETTOK
.1a6a5c	20 1f 22	jsr $1a221f	            JSR OPT_TOK
.1a6a5f	b0 0f		bcs $1a6a70	                BCS get_dest
.1a6a61	c2 20		rep #$20	            REP #$20
.1a6a63	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set destination address to something "safe"
.1a6a66	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a6a6a	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a6a6e	80 17		bra $1a6a87	                BRA do_load
.1a6a70					get_dest
.1a6a70	20 dd 20	jsr $1a20dd	            JSR INCBIP
.1a6a73	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a6a76	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a6a79	c2 20		rep #$20	            REP #$20
.1a6a7b	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the destination address
.1a6a7d	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a6a81	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6a83	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a6a87	22 18 11 00	jsl $001118	do_load         JSL FK_LOAD                 ; Attempt to load the file
.1a6a8b	b0 1f		bcs $1a6aac	                BCS done
.1a6a8d	08		php		            PHP
.1a6a8e	c2 20		rep #$20	            REP #$20
.1a6a90	48		pha		            PHA
.1a6a91	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6a94	5b		tcd		            TCD
.1a6a95	68		pla		            PLA
.1a6a96	28		plp		            PLP
.1a6a97	e2 20		sep #$20	            SEP #$20
.1a6a99	a9 11		lda #$11	            LDA #ERR_LOAD
.1a6a9b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6a9f	c2 20		rep #$20	            REP #$20
.1a6aa1	29 ff 00	and #$00ff	            AND #$00FF
.1a6aa4	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a6aa7	e2 20		sep #$20	            SEP #$20
.1a6aa9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6aac	28		plp		done            PLP
.1a6aad	60		rts		            RTS
.1a6aae					SET_DOSSTAT
.1a6aae	8b		phb		                PHB
.1a6aaf	0b		phd		                PHD
.1a6ab0	08		php		                PHP
.1a6ab1	08		php		            PHP
.1a6ab2	c2 20		rep #$20	            REP #$20
.1a6ab4	48		pha		            PHA
.1a6ab5	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6ab8	5b		tcd		            TCD
.1a6ab9	68		pla		            PLA
.1a6aba	28		plp		            PLP
.1a6abb	08		php		            PHP
.1a6abc	e2 20		sep #$20	            SEP #$20
.1a6abe	48		pha		            PHA
.1a6abf	a9 00		lda #$00	            LDA #BASIC_BANK
.1a6ac1	48		pha		            PHA
.1a6ac2	ab		plb		            PLB
.1a6ac3	68		pla		            PLA
.1a6ac4	28		plp		            PLP
.1a6ac5	e2 20		sep #$20	            SEP #$20
.1a6ac7	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS           ; Get the DOS status code
.1a6acb	85 23		sta $0823	                STA ARGUMENT1
.1a6acd	a9 00		lda #$00	                LDA #0
.1a6acf	85 24		sta $0824	                STA ARGUMENT1+1
.1a6ad1	85 25		sta $0825	                STA ARGUMENT1+2
.1a6ad3	85 26		sta $0826	                STA ARGUMENT1+3
.1a6ad5	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a6ad7	85 27		sta $0827	                STA ARGTYPE1
.1a6ad9	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (DOSSTAT)
.1a6adb	a9 1a		lda #$1a	                LDA #`dosstat_name
.1a6add	85 e9		sta $08e9	                STA TOFIND+2
.1a6adf	c2 20		rep #$20	            REP #$20
.1a6ae1	a9 11 6b	lda #$6b11	                LDA #<>dosstat_name
.1a6ae4	85 e7		sta $08e7	                STA TOFIND
.1a6ae6	20 9b 52	jsr $1a529b	            JSR VAR_SET
.1a6ae9	e2 20		sep #$20	            SEP #$20
.1a6aeb	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS          ; Get the BIOS status code
.1a6aef	85 23		sta $0823	                STA ARGUMENT1
.1a6af1	a9 00		lda #$00	                LDA #0
.1a6af3	85 24		sta $0824	                STA ARGUMENT1+1
.1a6af5	85 25		sta $0825	                STA ARGUMENT1+2
.1a6af7	85 26		sta $0826	                STA ARGUMENT1+3
.1a6af9	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a6afb	85 27		sta $0827	                STA ARGTYPE1
.1a6afd	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BIOSSTAT)
.1a6aff	a9 1a		lda #$1a	                LDA #`biosstat_name
.1a6b01	85 e9		sta $08e9	                STA TOFIND+2
.1a6b03	c2 20		rep #$20	            REP #$20
.1a6b05	a9 19 6b	lda #$6b19	                LDA #<>biosstat_name
.1a6b08	85 e7		sta $08e7	                STA TOFIND
.1a6b0a	20 9b 52	jsr $1a529b	            JSR VAR_SET
.1a6b0d	28		plp		                PLP
.1a6b0e	2b		pld		                PLD
.1a6b0f	ab		plb		                PLB
.1a6b10	60		rts		            RTS
>1a6b11	44 4f 53 53 54 41 54 00		dosstat_name    .null "DOSSTAT"
>1a6b19	42 49 4f 53 53 54 41 54		biosstat_name   .null "BIOSSTAT"
>1a6b21	00
.1a6b22					CMD_BRUN
.1a6b22	08		php		                PHP
.1a6b23	c2 30		rep #$30	            REP #$30
.1a6b25	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a6b28	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a6b2b	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6b2e	a5 23		lda $0823	                LDA ARGUMENT1
.1a6b30	8f 60 03 00	sta $000360	                STA @l DOS_RUN_PARAM
.1a6b34	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6b36	8f 62 03 00	sta $000362	                STA @l DOS_RUN_PARAM+2
.1a6b3a	a9 ff ff	lda #$ffff	                LDA #$FFFF
.1a6b3d	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a6b41	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a6b45	22 24 11 00	jsl $001124	                JSL FK_RUN                  ; Attempt to run the file
.1a6b49	b0 25		bcs $1a6b70	                BCS done                    ; If we got it: try to execute it
.1a6b4b	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a6b4e	20 ae 6a	jsr $1a6aae	            JSR SET_DOSSTAT
.1a6b51	08		php		            PHP
.1a6b52	c2 20		rep #$20	            REP #$20
.1a6b54	48		pha		            PHA
.1a6b55	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6b58	5b		tcd		            TCD
.1a6b59	68		pla		            PLA
.1a6b5a	28		plp		            PLP
.1a6b5b	e2 20		sep #$20	            SEP #$20
.1a6b5d	a9 11		lda #$11	            LDA #ERR_LOAD
.1a6b5f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6b63	c2 20		rep #$20	            REP #$20
.1a6b65	29 ff 00	and #$00ff	            AND #$00FF
.1a6b68	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a6b6b	e2 20		sep #$20	            SEP #$20
.1a6b6d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6b70					done
.1a6b70	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a6b73	28		plp		                PLP
.1a6b74	60		rts		            RTS
.1a6b75					CMD_LOAD
.1a6b75	08		php		                PHP
.1a6b76	c2 30		rep #$30	            REP #$30
.1a6b78	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a6b7b	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a6b7e	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6b81	20 fd 69	jsr $1a69fd	            JSR SETFILEDESC
.1a6b84	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.1a6b87	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a6b8b	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.1a6b8e	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2        ; Set the destination address
.1a6b92	20 6c 4f	jsr $1a4f6c	            JSR CMD_NEW
.1a6b95	22 18 11 00	jsl $001118	                JSL FK_LOAD                 ; Attempt to load the file
.1a6b99	b0 22		bcs $1a6bbd	                BCS start_tokenize          ; If we got it: start tokenizing
.1a6b9b	20 ae 6a	jsr $1a6aae	            JSR SET_DOSSTAT
.1a6b9e	08		php		            PHP
.1a6b9f	c2 20		rep #$20	            REP #$20
.1a6ba1	48		pha		            PHA
.1a6ba2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6ba5	5b		tcd		            TCD
.1a6ba6	68		pla		            PLA
.1a6ba7	28		plp		            PLP
.1a6ba8	e2 20		sep #$20	            SEP #$20
.1a6baa	a9 11		lda #$11	            LDA #ERR_LOAD
.1a6bac	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6bb0	c2 20		rep #$20	            REP #$20
.1a6bb2	29 ff 00	and #$00ff	            AND #$00FF
.1a6bb5	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a6bb8	e2 20		sep #$20	            SEP #$20
.1a6bba	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6bbd					start_tokenize
.1a6bbd	20 ae 6a	jsr $1a6aae	            JSR SET_DOSSTAT
.1a6bc0	c2 20		rep #$20	            REP #$20
.1a6bc2	a2 12 00	ldx #$0012	                LDX #FILEDESC.FILESIZE
.1a6bc5	18		clc		                CLC                         ; Set MTEMP to point to the byte after the file
.1a6bc6	bf 73 f2 1a	lda $1af273,x	                LDA FD_IN,X
.1a6bca	69 00 00	adc #$0000	                ADC #<>LOADBLOCK
.1a6bcd	85 92		sta $0892	                STA MTEMP
.1a6bcf	bf 75 f2 1a	lda $1af275,x	                LDA FD_IN+2,X
.1a6bd3	69 01 00	adc #$0001	                ADC #`LOADBLOCK
.1a6bd6	85 94		sta $0894	                STA MTEMP+2
.1a6bd8	e2 20		sep #$20	            SEP #$20
.1a6bda	a9 00		lda #$00	                LDA #0
.1a6bdc	87 92		sta [$0892]	                STA [MTEMP]                 ; Write a NULL right after the file
.1a6bde	c2 20		rep #$20	            REP #$20
.1a6be0	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK            ; Set MCURSOR to the begining of the loaded data
.1a6be3	85 7a		sta $087a	                STA MCURSOR
.1a6be5	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.1a6be8	85 7c		sta $087c	                STA MCURSOR+2
.1a6bea	a2 00 00	ldx #$0000	copy_line       LDX #0
.1a6bed					copy_char
.1a6bed	e2 20		sep #$20	            SEP #$20
.1a6bef	a7 7a		lda [$087a]	                LDA [MCURSOR]
.1a6bf1	f0 2a		beq $1a6c1d	                BEQ clean_up                ; If the character is 0, we're done
.1a6bf3	c9 0d		cmp #$0d	                CMP #CHAR_CR                ; If it is new line...
.1a6bf5	f0 12		beq $1a6c09	                BEQ do_process              ; ... we want to process the line
.1a6bf7	c9 0a		cmp #$0a	                CMP #CHAR_LF                ; If it is a line feed...
.1a6bf9	f0 04		beq $1a6bff	                BEQ next_char               ; ... we want to skip it
.1a6bfb	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X              ; Otherwise, copy the character to the input buffer
.1a6bfe	e8		inx		                INX
.1a6bff					next_char
.1a6bff	c2 20		rep #$20	            REP #$20
.1a6c01	e6 7a		inc $087a	                INC MCURSOR                 ; Advance the input cursor
.1a6c03	d0 e8		bne $1a6bed	                BNE copy_char
.1a6c05	e6 7c		inc $087c	                INC MCURSOR+2
.1a6c07	80 e4		bra $1a6bed	                BRA copy_char
.1a6c09					do_process
.1a6c09	e2 20		sep #$20	            SEP #$20
.1a6c0b	a9 00		lda #$00	                LDA #0                      ; Put a 0 at the end of the input buffer
.1a6c0d	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a6c10	20 4d 27	jsr $1a274d	            JSR PROCESS
.1a6c13	c2 20		rep #$20	            REP #$20
.1a6c15	e6 7a		inc $087a	                INC MCURSOR                 ; Try again with the next line
.1a6c17	d0 d1		bne $1a6bea	                BNE copy_line
.1a6c19	e6 7c		inc $087c	                INC MCURSOR+2
.1a6c1b	80 cd		bra $1a6bea	                BRA copy_line
.1a6c1d	e0 00 00	cpx #$0000	clean_up        CPX #0                      ; Is there data in the INPUTBUF?
.1a6c20	f0 0a		beq $1a6c2c	                BEQ done                    ; No: just return
.1a6c22	e2 20		sep #$20	            SEP #$20
.1a6c24	a9 00		lda #$00	                LDA #0                      ; Make sure there is a trailing NULL
.1a6c26	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a6c29	20 4d 27	jsr $1a274d	            JSR PROCESS
.1a6c2c	28		plp		done            PLP
.1a6c2d	60		rts		            RTS
.1a6c2e					S_BSAVE
.1a6c2e	08		php		                PHP
.1a6c2f	c2 30		rep #$30	            REP #$30
.1a6c31	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a6c34	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a6c37	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6c3a	20 fd 69	jsr $1a69fd	            JSR SETFILEDESC
.1a6c3d	e2 20		sep #$20	            SEP #$20
.1a6c3f	a9 2c		lda #$2c	                LDA #','
.1a6c41	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a6c44	c2 20		rep #$20	            REP #$20
.1a6c46	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a6c49	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a6c4c	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_SRC_PTR
.1a6c4e	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.1a6c52	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6c54	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.1a6c58	e2 20		sep #$20	            SEP #$20
.1a6c5a	a9 2c		lda #$2c	                LDA #','
.1a6c5c	c2 20		rep #$20	            REP #$20
.1a6c5e	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a6c61	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a6c64	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a6c67	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_END_PTR
.1a6c69	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.1a6c6d	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6c6f	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.1a6c73	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                 ; Attempt to save the memory to file.
.1a6c77	b0 22		bcs $1a6c9b	                BCS done
.1a6c79	20 ae 6a	jsr $1a6aae	            JSR SET_DOSSTAT
.1a6c7c	08		php		            PHP
.1a6c7d	c2 20		rep #$20	            REP #$20
.1a6c7f	48		pha		            PHA
.1a6c80	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6c83	5b		tcd		            TCD
.1a6c84	68		pla		            PLA
.1a6c85	28		plp		            PLP
.1a6c86	e2 20		sep #$20	            SEP #$20
.1a6c88	a9 12		lda #$12	            LDA #ERR_SAVE
.1a6c8a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6c8e	c2 20		rep #$20	            REP #$20
.1a6c90	29 ff 00	and #$00ff	            AND #$00FF
.1a6c93	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a6c96	e2 20		sep #$20	            SEP #$20
.1a6c98	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6c9b					done
.1a6c9b	20 ae 6a	jsr $1a6aae	            JSR SET_DOSSTAT
.1a6c9e	28		plp		                PLP
.1a6c9f	60		rts		            RTS
.1a6ca0					COPY2PATHBUF
.1a6ca0	da		phx		                PHX
.1a6ca1	5a		phy		                PHY
.1a6ca2	08		php		                PHP
.1a6ca3	a2 00 00	ldx #$0000	                LDX #0
.1a6ca6	a0 00 00	ldy #$0000	                LDY #0
.1a6ca9	e2 20		sep #$20	            SEP #$20
.1a6cab	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y           ; Copy the path to the DOS_PATH_BUFF
.1a6cad	9d 00 04	sta $0400,x	                STA DOS_PATH_BUFF,X
.1a6cb0	f0 04		beq $1a6cb6	                BEQ done
.1a6cb2	e8		inx		                INX
.1a6cb3	c8		iny		                INY
.1a6cb4	80 f5		bra $1a6cab	                BRA loop
.1a6cb6	28		plp		done            PLP
.1a6cb7	7a		ply		                PLY
.1a6cb8	fa		plx		                PLX
.1a6cb9	60		rts		            RTS
.1a6cba					CMD_SAVE
.1a6cba	08		php		                PHP
.1a6cbb	c2 30		rep #$30	            REP #$30
.1a6cbd	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a6cc0	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a6cc3	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6cc6	20 fd 69	jsr $1a69fd	            JSR SETFILEDESC
.1a6cc9	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.1a6ccc	85 a6		sta $08a6	                STA OBUFFER
.1a6cce	e2 20		sep #$20	            SEP #$20
.1a6cd0	a9 01		lda #$01	                LDA #`LOADBLOCK
.1a6cd2	85 a8		sta $08a8	                STA OBUFFER+2
.1a6cd4	a9 20		lda #$20	                LDA #DEV_BUFFER             ; Set up output for the buffer
.1a6cd6	85 b4		sta $08b4	                STA BCONSOLE
.1a6cd8	c2 20		rep #$20	            REP #$20
.1a6cda	a9 00 00	lda #$0000	                LDA #0
.1a6cdd	85 ab		sta $08ab	                STA OBUFFIDX
.1a6cdf	a9 ff ff	lda #$ffff	                LDA #$FFFF
.1a6ce2	85 a9		sta $08a9	                STA OBUFFSIZE
.1a6ce4	c2 20		rep #$20	            REP #$20
.1a6ce6	a9 00 00	lda #$0000	                LDA #0                      ; Set start line number to 0
.1a6ce9	85 55		sta $0855	                STA MARG1
.1a6ceb	85 57		sta $0857	                STA MARG1+2
.1a6ced	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set end line number to MAXINT
.1a6cf0	85 59		sta $0859	                STA MARG2
.1a6cf2	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.1a6cf5	85 5b		sta $085b	                STA MARG2+2
.1a6cf7	20 4b 18	jsr $1a184b	            JSR LISTPROG
.1a6cfa	e2 20		sep #$20	            SEP #$20
.1a6cfc	a9 80		lda #$80	                LDA #DEV_SCREEN             ; Restore output to the screen
.1a6cfe	85 b4		sta $08b4	                STA BCONSOLE
.1a6d00	c2 20		rep #$20	            REP #$20
.1a6d02	c6 ab		dec $08ab	                DEC OBUFFIDX                ; OBUFFIDX points to the next free byte... so pull it in one
.1a6d04	18		clc		                CLC                         ; Set the range of memory to save
.1a6d05	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.1a6d08	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.1a6d0c	65 ab		adc $08ab	                ADC OBUFFIDX
.1a6d0e	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.1a6d12	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.1a6d15	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.1a6d19	69 00 00	adc #$0000	                ADC #0
.1a6d1c	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.1a6d20	22 1c 11 00	jsl $00111c	do_save         JSL FK_SAVE                 ; Attempt to save the file
.1a6d24	b0 22		bcs $1a6d48	                BCS done
.1a6d26	20 ae 6a	jsr $1a6aae	            JSR SET_DOSSTAT
.1a6d29	08		php		            PHP
.1a6d2a	c2 20		rep #$20	            REP #$20
.1a6d2c	48		pha		            PHA
.1a6d2d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6d30	5b		tcd		            TCD
.1a6d31	68		pla		            PLA
.1a6d32	28		plp		            PLP
.1a6d33	e2 20		sep #$20	            SEP #$20
.1a6d35	a9 12		lda #$12	            LDA #ERR_SAVE
.1a6d37	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6d3b	c2 20		rep #$20	            REP #$20
.1a6d3d	29 ff 00	and #$00ff	            AND #$00FF
.1a6d40	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a6d43	e2 20		sep #$20	            SEP #$20
.1a6d45	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6d48					done
.1a6d48	20 ae 6a	jsr $1a6aae	            JSR SET_DOSSTAT
.1a6d4b	28		plp		                PLP
.1a6d4c	60		rts		            RTS
.1a6d4d					S_DEL
.1a6d4d	08		php		                PHP
.1a6d4e	c2 30		rep #$30	            REP #$30
.1a6d50	20 fe 20	jsr $1a20fe	            JSR SKIPWS
.1a6d53	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a6d56	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6d59	20 a0 6c	jsr $1a6ca0	            JSR COPY2PATHBUF
.1a6d5c	22 04 11 00	jsl $001104	path_loaded     JSL FK_DELETE               ; Try to delete the file
.1a6d60	b0 22		bcs $1a6d84	                BCS done
.1a6d62	20 ae 6a	jsr $1a6aae	            JSR SET_DOSSTAT
.1a6d65	08		php		            PHP
.1a6d66	c2 20		rep #$20	            REP #$20
.1a6d68	48		pha		            PHA
.1a6d69	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6d6c	5b		tcd		            TCD
.1a6d6d	68		pla		            PLA
.1a6d6e	28		plp		            PLP
.1a6d6f	e2 20		sep #$20	            SEP #$20
.1a6d71	a9 13		lda #$13	            LDA #ERR_DELETE
.1a6d73	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6d77	c2 20		rep #$20	            REP #$20
.1a6d79	29 ff 00	and #$00ff	            AND #$00FF
.1a6d7c	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a6d7f	e2 20		sep #$20	            SEP #$20
.1a6d81	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6d84					done
.1a6d84	20 ae 6a	jsr $1a6aae	            JSR SET_DOSSTAT
.1a6d87	28		plp		                PLP
.1a6d88	60		rts		            RTS
.1a6d89					VALIDFILECHAR
.1a6d89	da		phx		                PHX
.1a6d8a	08		php		                PHP
.1a6d8b	e2 20		sep #$20	            SEP #$20
.1a6d8d	c9 61		cmp #$61	                CMP #'a'                    ; Is it lower case?
.1a6d8f	90 08		bcc $1a6d99	                BLT chk_space
.1a6d91	c9 7b		cmp #$7b	                CMP #'z'+1
.1a6d93	b0 04		bcs $1a6d99	                BGE chk_space
.1a6d95	29 df		and #$df	                AND #%11011111              ; Yes: convert to upper case
.1a6d97	80 13		bra $1a6dac	                BRA ret_valid
.1a6d99	c9 20		cmp #$20	chk_space       CMP #CHAR_SP            ; Is it a control code?
.1a6d9b	90 13		bcc $1a6db0	                BLT is_invalid          ; Yes: it's invalid
.1a6d9d	a2 00 00	ldx #$0000	                LDX #0                  ; See if it's in the list of invalids
.1a6da0	df b4 6d 1a	cmp $1a6db4,x	loop            CMP invalid_chars,X
.1a6da4	f0 0a		beq $1a6db0	                BEQ is_invalid
.1a6da6	e8		inx		                INX
.1a6da7	e0 0f 00	cpx #$000f	                CPX #15                 ; # of invalid characters
.1a6daa	d0 f4		bne $1a6da0	                BNE loop
.1a6dac	28		plp		ret_valid       PLP
.1a6dad	38		sec		                SEC
.1a6dae	fa		plx		                PLX
.1a6daf	6b		rtl		                RTL
.1a6db0	28		plp		is_invalid      PLP
.1a6db1	18		clc		                CLC
.1a6db2	fa		plx		                PLX
.1a6db3	6b		rtl		                RTL
>1a6db4	2a 2b 2c 2f 3a 3b 3c 3d		invalid_chars   .text "*+,/:;<=>?\[]|",CHAR_DQUOTE
>1a6dbc	3e 3f 5c 5b 5d 7c 22
.1a6dc3					S_RENAME
.1a6dc3	08		php		                PHP
.1a6dc4	08		php		            PHP
.1a6dc5	c2 20		rep #$20	            REP #$20
.1a6dc7	48		pha		            PHA
.1a6dc8	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6dcb	5b		tcd		            TCD
.1a6dcc	68		pla		            PLA
.1a6dcd	28		plp		            PLP
.1a6dce	c2 30		rep #$30	            REP #$30
.1a6dd0	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a6dd3	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6dd6	20 a0 6c	jsr $1a6ca0	            JSR COPY2PATHBUF
.1a6dd9	22 10 11 00	jsl $001110	                JSL FK_DIRREAD              ; Try to read the file
.1a6ddd	b0 22		bcs $1a6e01	                BCS get_new_name            ; If ok: get the new name
.1a6ddf	20 ae 6a	jsr $1a6aae	            JSR SET_DOSSTAT
.1a6de2	08		php		            PHP
.1a6de3	c2 20		rep #$20	            REP #$20
.1a6de5	48		pha		            PHA
.1a6de6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6de9	5b		tcd		            TCD
.1a6dea	68		pla		            PLA
.1a6deb	28		plp		            PLP
.1a6dec	e2 20		sep #$20	            SEP #$20
.1a6dee	a9 14		lda #$14	            LDA #ERR_FILENOTFOUND
.1a6df0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6df4	c2 20		rep #$20	            REP #$20
.1a6df6	29 ff 00	and #$00ff	            AND #$00FF
.1a6df9	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a6dfc	e2 20		sep #$20	            SEP #$20
.1a6dfe	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6e01					get_new_name
.1a6e01	e2 20		sep #$20	            SEP #$20
.1a6e03	a9 2c		lda #$2c	                LDA #','
.1a6e05	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a6e08	c2 20		rep #$20	            REP #$20
.1a6e0a	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a6e0d	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6e10	ad 38 03	lda $0338	                LDA DOS_DIR_PTR
.1a6e13	85 08		sta $0808	                STA INDEX
.1a6e15	ad 3a 03	lda $033a	                LDA DOS_DIR_PTR+2
.1a6e18	85 0a		sta $080a	                STA INDEX+2
.1a6e1a	e2 20		sep #$20	            SEP #$20
.1a6e1c	a2 00 00	ldx #$0000	                LDX #0
.1a6e1f	a9 20		lda #$20	                LDA #CHAR_SP                ; We'll use MLINEBUFF as temporary name storage
.1a6e21	95 7e		sta $087e,x	blank_loop      STA MLINEBUF,X              ; Fill it with blanks
.1a6e23	e8		inx		                INX
.1a6e24	e0 0b 00	cpx #$000b	                CPX #11
.1a6e27	d0 f8		bne $1a6e21	                BNE blank_loop
.1a6e29	a2 00 00	ldx #$0000	                LDX #0
.1a6e2c	a0 00 00	ldy #$0000	                LDY #0
.1a6e2f	b7 23		lda [$0823],y	name_loop       LDA [ARGUMENT1],Y           ; Get the character of the new name
.1a6e31	f0 76		beq $1a6ea9	                BEQ copy_short_name         ; If end-of-string: copy what we have
.1a6e33	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.1a6e35	f0 39		beq $1a6e70	                BEQ skip_dot                ; Yes: move on to the extension characters
.1a6e37	22 89 6d 1a	jsl $1a6d89	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.1a6e3b	b0 1f		bcs $1a6e5c	                BCS save_nm_char
.1a6e3d	08		php		            PHP
.1a6e3e	c2 20		rep #$20	            REP #$20
.1a6e40	48		pha		            PHA
.1a6e41	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6e44	5b		tcd		            TCD
.1a6e45	68		pla		            PLA
.1a6e46	28		plp		            PLP
.1a6e47	e2 20		sep #$20	            SEP #$20
.1a6e49	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a6e4b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6e4f	c2 20		rep #$20	            REP #$20
.1a6e51	29 ff 00	and #$00ff	            AND #$00FF
.1a6e54	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a6e57	e2 20		sep #$20	            SEP #$20
.1a6e59	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6e5c	95 7e		sta $087e,x	save_nm_char    STA MLINEBUF,X              ; Otherwise: copy it
.1a6e5e	c8		iny		                INY
.1a6e5f	e8		inx		                INX
.1a6e60	c0 08 00	cpy #$0008	                CPY #8
.1a6e63	d0 ca		bne $1a6e2f	                BNE name_loop
.1a6e65	b7 23		lda [$0823],y	eat_name        LDA [ARGUMENT1],Y           ; Get the character
.1a6e67	f0 40		beq $1a6ea9	                BEQ copy_short_name         ; If null, we're done with the short name
.1a6e69	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.1a6e6b	f0 03		beq $1a6e70	                BEQ skip_dot                ; Yes: skip over it
.1a6e6d	c8		iny		                INY                         ; No: try again with the the next character
.1a6e6e	80 f5		bra $1a6e65	                BRA eat_name
.1a6e70	c8		iny		skip_dot        INY                         ; Character at Y is '.', so skip over it
.1a6e71	a2 08 00	ldx #$0008	do_ext          LDX #8
.1a6e74	b7 23		lda [$0823],y	ext_loop        LDA [ARGUMENT1],Y           ; Get the character of the new extension
.1a6e76	f0 31		beq $1a6ea9	                BEQ copy_short_name         ; If end-of-string: copy what we have
.1a6e78	22 89 6d 1a	jsl $1a6d89	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.1a6e7c	b0 22		bcs $1a6ea0	                BCS save_ext_char
.1a6e7e	20 ae 6a	jsr $1a6aae	            JSR SET_DOSSTAT
.1a6e81	08		php		            PHP
.1a6e82	c2 20		rep #$20	            REP #$20
.1a6e84	48		pha		            PHA
.1a6e85	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6e88	5b		tcd		            TCD
.1a6e89	68		pla		            PLA
.1a6e8a	28		plp		            PLP
.1a6e8b	e2 20		sep #$20	            SEP #$20
.1a6e8d	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a6e8f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6e93	c2 20		rep #$20	            REP #$20
.1a6e95	29 ff 00	and #$00ff	            AND #$00FF
.1a6e98	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a6e9b	e2 20		sep #$20	            SEP #$20
.1a6e9d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6ea0	95 7e		sta $087e,x	save_ext_char   STA MLINEBUF,X              ; Otherwise: copy it
.1a6ea2	c8		iny		                INY
.1a6ea3	e8		inx		                INX
.1a6ea4	c0 0c 00	cpy #$000c	                CPY #12
.1a6ea7	d0 cb		bne $1a6e74	                BNE ext_loop
.1a6ea9	a2 00 00	ldx #$0000	copy_short_name LDX #0                      ; Copy the short name we built to the directory entry
.1a6eac	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME
.1a6eaf	b5 7e		lda $087e,x	copy_loop       LDA MLINEBUF,X
.1a6eb1	97 08		sta [$0808],y	                STA [INDEX],Y
.1a6eb3	e8		inx		                INX
.1a6eb4	c8		iny		                INY
.1a6eb5	c0 0b 00	cpy #$000b	                CPY #11
.1a6eb8	d0 f5		bne $1a6eaf	                BNE copy_loop
.1a6eba	22 14 11 00	jsl $001114	                JSL FK_DIRWRITE             ; Write the directory entry back
.1a6ebe	b0 22		bcs $1a6ee2	                BCS done
.1a6ec0	20 ae 6a	jsr $1a6aae	            JSR SET_DOSSTAT
.1a6ec3	08		php		            PHP
.1a6ec4	c2 20		rep #$20	            REP #$20
.1a6ec6	48		pha		            PHA
.1a6ec7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6eca	5b		tcd		            TCD
.1a6ecb	68		pla		            PLA
.1a6ecc	28		plp		            PLP
.1a6ecd	e2 20		sep #$20	            SEP #$20
.1a6ecf	a9 15		lda #$15	            LDA #ERR_DIRNOTWRITE
.1a6ed1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6ed5	c2 20		rep #$20	            REP #$20
.1a6ed7	29 ff 00	and #$00ff	            AND #$00FF
.1a6eda	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a6edd	e2 20		sep #$20	            SEP #$20
.1a6edf	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6ee2					done
.1a6ee2	20 ae 6a	jsr $1a6aae	            JSR SET_DOSSTAT
.1a6ee5	28		plp		                PLP
.1a6ee6	60		rts		            RTS
.1a6ee7					S_COPY
.1a6ee7	08		php		                PHP
.1a6ee8	08		php		            PHP
.1a6ee9	c2 20		rep #$20	            REP #$20
.1a6eeb	48		pha		            PHA
.1a6eec	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6eef	5b		tcd		            TCD
.1a6ef0	68		pla		            PLA
.1a6ef1	28		plp		            PLP
.1a6ef2	c2 30		rep #$30	            REP #$30
.1a6ef4	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a6ef7	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6efa	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.1a6efc	8f 64 03 00	sta $000364	                STA @l DOS_STR1_PTR
.1a6f00	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6f02	8f 66 03 00	sta $000366	                STA @l DOS_STR1_PTR+2
.1a6f06	e2 20		sep #$20	            SEP #$20
.1a6f08	a9 2c		lda #$2c	                LDA #','
.1a6f0a	20 ea 21	jsr $1a21ea	            JSR EXPECT_TOK
.1a6f0d	c2 20		rep #$20	            REP #$20
.1a6f0f	20 cc 1c	jsr $1a1ccc	            JSR EVALEXPR
.1a6f12	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6f15	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.1a6f17	8f 68 03 00	sta $000368	                STA @l DOS_STR2_PTR
.1a6f1b	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6f1d	8f 6a 03 00	sta $00036a	                STA @l DOS_STR2_PTR+2
.1a6f21	22 30 11 00	jsl $001130	                JSL FK_COPY                 ; Attempt to copy the file
.1a6f25	b0 1f		bcs $1a6f46	                BCS done
.1a6f27	08		php		            PHP
.1a6f28	c2 20		rep #$20	            REP #$20
.1a6f2a	48		pha		            PHA
.1a6f2b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6f2e	5b		tcd		            TCD
.1a6f2f	68		pla		            PLA
.1a6f30	28		plp		            PLP
.1a6f31	e2 20		sep #$20	            SEP #$20
.1a6f33	a9 16		lda #$16	            LDA #ERR_NOTCOPIED
.1a6f35	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6f39	c2 20		rep #$20	            REP #$20
.1a6f3b	29 ff 00	and #$00ff	            AND #$00FF
.1a6f3e	20 1e 1e	jsr $1a1e1e	            JSR SET_ERRERL
.1a6f41	e2 20		sep #$20	            SEP #$20
.1a6f43	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6f46	28		plp		done            PLP
.1a6f47	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\monitor.s

.1a6f48	5c 05 89 1a	jmp $1a8905	MRETURN         JML IMRETURN
.1a6f4c	5c 56 87 1a	jmp $1a8756	MPARSE          JML IMPARSE
.1a6f50	5c 06 89 1a	jmp $1a8906	MPARSE1         JML IMPARSE1
.1a6f54	5c 82 78 1a	jmp $1a7882	MEXECUTE        JML IMEXECUTE
.1a6f58	5c df 78 1a	jmp $1a78df	MASSEMBLE       JML IMASSEMBLE
.1a6f5c	5c 12 78 1a	jmp $1a7812	MRMODIFY        JML IMRMODIFY
.1a6f60	5c 98 77 1a	jmp $1a7798	MCOMPARE        JML IMCOMPARE
.1a6f64	5c 15 7d 1a	jmp $1a7d15	MDISASSEMBLE    JML IMDISASSEMBLE
.1a6f68	5c 03 74 1a	jmp $1a7403	MFILL           JML IMFILL
.1a6f6c	5c 30 77 1a	jmp $1a7730	MGO             JML IMGO
.1a6f70	5c eb 76 1a	jmp $1a76eb	MJUMP           JML IMJUMP
.1a6f74	5c 75 76 1a	jmp $1a7675	MHUNT           JML IMHUNT
.1a6f78	5c 14 88 1a	jmp $1a8814	MLOAD           JML IMLOAD
.1a6f7c	5c 11 75 1a	jmp $1a7511	MMEMORY         JML IMMEMORY
.1a6f80	5c 61 73 1a	jmp $1a7361	MREGISTERS      JML IMREGISTERS
.1a6f84	5c 8f 88 1a	jmp $1a888f	MSAVE           JML IMSAVE
.1a6f88	5c 3f 74 1a	jmp $1a743f	MTRANSFER       JML IMTRANSFER
.1a6f8c	5c 08 89 1a	jmp $1a8908	MVERIFY         JML IMVERIFY
.1a6f90	5c 01 89 1a	jmp $1a8901	MEXIT           JML IMEXIT
.1a6f94	5c 2e 76 1a	jmp $1a762e	MMODIFY         JML IMMODIFY
.1a6f98	5c 09 89 1a	jmp $1a8909	MDOS            JML IMDOS
.1a6f9c	18		clc		IMONITOR        CLC                 ; clear the carry flag
.1a6f9d	fb		xce		                XCE                 ; move carry to emulation flags
.1a6f9e	58		cli		                CLI                 ; Re-enable interrupts
.1a6f9f	5c a3 6f 1a	jmp $1a6fa3	                JML IMREADY
.1a6fa3					IMREADY
.1a6fa3	c2 30		rep #$30	            REP #$30
.1a6fa5	22 61 73 1a	jsl $1a7361	                JSL IMREGISTERS
.1a6fa9					ready_loop
.1a6fa9	20 08 00	jsr $1a0008	            JSR READLINE
.1a6fac	20 0c 00	jsr $1a000c	            JSR SCRCOPYLINE
.1a6faf	8b		phb		                PHB
.1a6fb0	e2 20		sep #$20	            SEP #$20
.1a6fb2	a9 00		lda #$00	                LDA #`INPUTBUF
.1a6fb4	48		pha		                PHA
.1a6fb5	ab		plb		                PLB
.1a6fb6	a2 00 4f	ldx #$4f00	                LDX #<>INPUTBUF
.1a6fb9	20 2a 05	jsr $1a052a	            JSR TOUPPER
.1a6fbc	ab		plb		                PLB
.1a6fbd	22 4c 6f 1a	jsl $1a6f4c	                JSL MPARSE          ; Parse the command
.1a6fc1	22 54 6f 1a	jsl $1a6f54	                JSL MEXECUTE        ; And execute the parsed command
.1a6fc5	80 e2		bra $1a6fa9	                BRA ready_loop
.1a6fc7					IMHELP
.1a6fc7	08		php		                PHP
.1a6fc8	8b		phb		                PHB
.1a6fc9	e2 20		sep #$20	            SEP #$20
.1a6fcb	a9 1a		lda #$1a	                LDA #`help_text
.1a6fcd	48		pha		                PHA
.1a6fce	ab		plb		                PLB
.1a6fcf	c2 10		rep #$10	            REP #$10
.1a6fd1	a2 da 6f	ldx #$6fda	                LDX #<>help_text
.1a6fd4	20 29 04	jsr $1a0429	            JSR PRINTS
.1a6fd7	ab		plb		                PLB
.1a6fd8	28		plp		                PLP
.1a6fd9	6b		rtl		                RTL
>1a6fda	41 20 3c 73 74 61 72 74		help_text       .text "A <start> <assembly>",CHAR_CR
>1a6fe2	3e 20 3c 61 73 73 65 6d 62 6c 79 3e 0d
>1a6fef	20 20 41 73 73 65 6d 62		                .text "  Assemble a program",CHAR_CR,CHAR_CR
>1a6ff7	6c 65 20 61 20 70 72 6f 67 72 61 6d 0d 0d
>1a7005	43 20 3c 73 74 61 72 74		                .text "C <start1> <start2> [len (1 if blank)]",CHAR_CR
>1a700d	31 3e 20 3c 73 74 61 72 74 32 3e 20 5b 6c 65 6e
>1a701d	20 28 31 20 69 66 20 62 6c 61 6e 6b 29 5d 0d
>1a702c	20 20 43 6f 6d 70 61 72		                .text "  Compare to sections of memory",CHAR_CR,CHAR_CR
>1a7034	65 20 74 6f 20 73 65 63 74 69 6f 6e 73 20 6f 66
>1a7044	20 6d 65 6d 6f 72 79 0d 0d
>1a704d	44 20 3c 73 74 61 72 74		                .text "D <start> [end]",CHAR_CR
>1a7055	3e 20 5b 65 6e 64 5d 0d
>1a705d	20 20 44 69 73 61 73 73		                .text "  Disassemble a program",CHAR_CR,CHAR_CR
>1a7065	65 6d 62 6c 65 20 61 20 70 72 6f 67 72 61 6d 0d
>1a7075	0d
>1a7076	46 20 3c 73 74 61 72 74		                .text "F <start> <end> <byte>",CHAR_CR
>1a707e	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 0d
>1a708d	20 20 46 69 6c 6c 20 61		                .text "  Fill a block of memory with a byte",CHAR_CR,CHAR_CR
>1a7095	20 62 6c 6f 63 6b 20 6f 66 20 6d 65 6d 6f 72 79
>1a70a5	20 77 69 74 68 20 61 20 62 79 74 65 0d 0d
>1a70b3	47 20 5b 61 64 64 72 65		                .text "G [address]",CHAR_CR
>1a70bb	73 73 5d 0d
>1a70bf	20 20 53 74 61 72 74 20		                .text "  Start execution at a location",CHAR_CR,CHAR_CR
>1a70c7	65 78 65 63 75 74 69 6f 6e 20 61 74 20 61 20 6c
>1a70d7	6f 63 61 74 69 6f 6e 0d 0d
>1a70e0	4a 20 5b 61 64 64 72 65		                .text "J [address] - Jump to a location in memory",CHAR_CR
>1a70e8	73 73 5d 20 2d 20 4a 75 6d 70 20 74 6f 20 61 20
>1a70f8	6c 6f 63 61 74 69 6f 6e 20 69 6e 20 6d 65 6d 6f
>1a7108	72 79 0d
>1a710b	20 20 4a 75 6d 70 20 74		                .text "  Jump to a location in memory",CHAR_CR,CHAR_CR
>1a7113	6f 20 61 20 6c 6f 63 61 74 69 6f 6e 20 69 6e 20
>1a7123	6d 65 6d 6f 72 79 0d 0d
>1a712b	48 20 3c 73 74 61 72 74		                .text "H <start> <end> <byte> [byte]..",CHAR_CR
>1a7133	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 20 5b
>1a7143	62 79 74 65 5d 2e 2e 0d
>1a714b	20 20 48 75 6e 74 20 66		                .text "  Hunt for values in memory",CHAR_CR,CHAR_CR
>1a7153	6f 72 20 76 61 6c 75 65 73 20 69 6e 20 6d 65 6d
>1a7163	6f 72 79 0d 0d
>1a7168	4c 20 20 20 20 20 4c 4f		                .text "L     LOAD         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," [destination]",CHAR_CR
>1a7170	41 44 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>1a7180	22 20 5b 64 65 73 74 69 6e 61 74 69 6f 6e 5d 0d
>1a7190	4d 20 3c 73 74 61 72 74		                .text "M <start> [end]",CHAR_CR
>1a7198	3e 20 5b 65 6e 64 5d 0d
>1a71a0	20 20 44 75 6d 70 20 74		                .text "  Dump the value in memory",CHAR_CR,CHAR_CR
>1a71a8	68 65 20 76 61 6c 75 65 20 69 6e 20 6d 65 6d 6f
>1a71b8	72 79 0d 0d
>1a71bc	52 20 2d 20 44 69 73 70		                .text "R - Display the values of the registers",CHAR_CR,CHAR_CR
>1a71c4	6c 61 79 20 74 68 65 20 76 61 6c 75 65 73 20 6f
>1a71d4	66 20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d
>1a71e4	0d
>1a71e5	3b 20 3c 50 43 3e 20 3c		                .text "; <PC> <A> <X> <Y> <SP> <DBR> <DP> <NVMXDIZC>",CHAR_CR
>1a71ed	41 3e 20 3c 58 3e 20 3c 59 3e 20 3c 53 50 3e 20
>1a71fd	3c 44 42 52 3e 20 3c 44 50 3e 20 3c 4e 56 4d 58
>1a720d	44 49 5a 43 3e 0d
>1a7213	20 20 43 68 61 6e 67 65		                .text "  Change the contents of the registers",CHAR_CR,CHAR_CR
>1a721b	20 74 68 65 20 63 6f 6e 74 65 6e 74 73 20 6f 66
>1a722b	20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d 0d
>1a723b	53 20 20 20 20 20 53 41		                .text "S     SAVE         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," <start> <end>",CHAR_CR
>1a7243	56 45 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>1a7253	22 20 3c 73 74 61 72 74 3e 20 3c 65 6e 64 3e 0d
>1a7263	54 20 3c 73 74 61 72 74		                .text "T <start> <end> <destination>",CHAR_CR
>1a726b	3e 20 3c 65 6e 64 3e 20 3c 64 65 73 74 69 6e 61
>1a727b	74 69 6f 6e 3e 0d
>1a7281	20 20 54 72 61 6e 73 66		                .text "  Transfer (copy) data within memory",CHAR_CR,CHAR_CR
>1a7289	65 72 20 28 63 6f 70 79 29 20 64 61 74 61 20 77
>1a7299	69 74 68 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>1a72a7	57 20 3c 62 79 74 65 3e		                .text "W <byte>",CHAR_CR
>1a72af	0d
>1a72b0	20 20 53 65 74 20 74 68		                .text "  Set the register width flags for the disassembler",CHAR_CR,CHAR_CR
>1a72b8	65 20 72 65 67 69 73 74 65 72 20 77 69 64 74 68
>1a72c8	20 66 6c 61 67 73 20 66 6f 72 20 74 68 65 20 64
>1a72d8	69 73 61 73 73 65 6d 62 6c 65 72 0d 0d
>1a72e5	58 20 2d 20 52 65 74 75		                .text "X - Return to BASIC",CHAR_CR,CHAR_CR
>1a72ed	72 6e 20 74 6f 20 42 41 53 49 43 0d 0d
>1a72fa	3e 20 3c 73 74 61 72 74		                .text "> <start> <byte> [byte]...",CHAR_CR
>1a7302	3e 20 3c 62 79 74 65 3e 20 5b 62 79 74 65 5d 2e
>1a7312	2e 2e 0d
>1a7315	20 20 45 64 69 74 20 64		                .text "  Edit data in memory",CHAR_CR,CHAR_CR
>1a731d	61 74 61 20 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>1a732c	3f 20 2d 20 44 69 73 70		                .null "? - Display a short help screen",CHAR_CR,CHAR_CR
>1a7334	6c 61 79 20 61 20 73 68 6f 72 74 20 68 65 6c 70
>1a7344	20 73 63 72 65 65 6e 0d 0d 00
.1a734e					IMWIDTH
.1a734e	08		php		                PHP
.1a734f	08		php		            PHP
.1a7350	c2 20		rep #$20	            REP #$20
.1a7352	48		pha		            PHA
.1a7353	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7356	5b		tcd		            TCD
.1a7357	68		pla		            PLA
.1a7358	28		plp		            PLP
.1a7359	e2 20		sep #$20	            SEP #$20
.1a735b	a5 0d		lda $0855	                LDA MARG1
.1a735d	85 4e		sta $0896	                STA MCPUSTAT
.1a735f	28		plp		                PLP
.1a7360	6b		rtl		                RTL
.1a7361					IMREGISTERS
.1a7361	20 3d 02	jsr $1a023d	            JSR ENSURETEXT
.1a7364	08		php		            PHP
.1a7365	e2 20		sep #$20	            SEP #$20
.1a7367	48		pha		            PHA
.1a7368	a9 1a		lda #$1a	            LDA #`mregisters_msg
.1a736a	48		pha		            PHA
.1a736b	ab		plb		            PLB
.1a736c	68		pla		            PLA
.1a736d	28		plp		            PLP
.1a736e	a2 46 89	ldx #$8946	                LDX #<>mregisters_msg
.1a7371	20 29 04	jsr $1a0429	            JSR PRINTS
.1a7374	e2 20		sep #$20	            SEP #$20
.1a7376	a9 3b		lda #$3b	                LDA #';'
.1a7378	20 18 00	jsr $1a0018	            JSR PRINTC
.1a737b	a9 20		lda #$20	                LDA #' '
.1a737d	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7380	c2 30		rep #$30	            REP #$30
.1a7382	08		php		            PHP
.1a7383	e2 20		sep #$20	            SEP #$20
.1a7385	48		pha		            PHA
.1a7386	a9 00		lda #$00	            LDA #$0
.1a7388	48		pha		            PHA
.1a7389	ab		plb		            PLB
.1a738a	68		pla		            PLA
.1a738b	28		plp		            PLP
.1a738c	a0 03 00	ldy #$0003	                LDY #3
.1a738f	a2 42 02	ldx #$0242	                LDX #CPUPC+2
.1a7392	20 ac 03	jsr $1a03ac	            JSR PRINTH
.1a7395	c2 20		rep #$20	            REP #$20
.1a7397	a9 20 00	lda #$0020	                LDA #' '
.1a739a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a739d	af 44 02 00	lda $000244	                LDA @lCPUA
.1a73a1	20 39 04	jsr $1a0439	            JSR PRHEXW
.1a73a4	a9 20 00	lda #$0020	                LDA #' '
.1a73a7	20 18 00	jsr $1a0018	            JSR PRINTC
.1a73aa	af 46 02 00	lda $000246	                LDA @lCPUX
.1a73ae	20 39 04	jsr $1a0439	            JSR PRHEXW
.1a73b1	a9 20 00	lda #$0020	                LDA #' '
.1a73b4	20 18 00	jsr $1a0018	            JSR PRINTC
.1a73b7	af 48 02 00	lda $000248	                LDA @lCPUY
.1a73bb	20 39 04	jsr $1a0439	            JSR PRHEXW
.1a73be	a9 20 00	lda #$0020	                LDA #' '
.1a73c1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a73c4	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK
.1a73c8	20 39 04	jsr $1a0439	            JSR PRHEXW
.1a73cb	a9 20 00	lda #$0020	                LDA #' '
.1a73ce	20 18 00	jsr $1a0018	            JSR PRINTC
.1a73d1	af 4e 02 00	lda $00024e	                LDA @lCPUDBR
.1a73d5	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a73d8	a9 20 00	lda #$0020	                LDA #' '
.1a73db	20 18 00	jsr $1a0018	            JSR PRINTC
.1a73de	a9 20 00	lda #$0020	                LDA #' '
.1a73e1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a73e4	af 4c 02 00	lda $00024c	                LDA @lCPUDP
.1a73e8	20 39 04	jsr $1a0439	            JSR PRHEXW
.1a73eb	a9 20 00	lda #$0020	                LDA #' '
.1a73ee	20 18 00	jsr $1a0018	            JSR PRINTC
.1a73f1	08		php		                PHP
.1a73f2	e2 20		sep #$20	            SEP #$20
.1a73f4	ad 4f 02	lda $024f	                LDA CPUFLAGS
.1a73f7	22 5f 86 1a	jsl $1a865f	                JSL MPRINTB
.1a73fb	28		plp		                PLP
.1a73fc	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a73ff	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a7402	6b		rtl		                RTL
.1a7403					IMFILL
.1a7403	08		php		                PHP                 ; Save the caller's context
.1a7404	0b		phd		                PHD
.1a7405	08		php		            PHP
.1a7406	c2 20		rep #$20	            REP #$20
.1a7408	48		pha		            PHA
.1a7409	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a740c	5b		tcd		            TCD
.1a740d	68		pla		            PLA
.1a740e	28		plp		            PLP
.1a740f					do_copy
.1a740f	e2 20		sep #$20	            SEP #$20
.1a7411	a5 15		lda $085d	                LDA MARG3
.1a7413	87 0d		sta [$0855]	                STA [MARG1]
.1a7415	e2 20		sep #$20	            SEP #$20
.1a7417	a5 0f		lda $0857	                LDA MARG1+2
.1a7419	c5 13		cmp $085b	                CMP MARG2+2
.1a741b	d0 0e		bne $1a742b	                BNE go_next         ; No: we haven't reached end address yet
.1a741d	c2 20		rep #$20	            REP #$20
.1a741f	a5 0d		lda $0855	                LDA MARG1
.1a7421	c5 11		cmp $0859	                CMP MARG2           ; Are they equal?
.1a7423	d0 06		bne $1a742b	                BNE go_next         ; No: we haven't reached end address yet
.1a7425	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a7428	2b		pld		                PLD                 ; Restore the caller's context
.1a7429	28		plp		                PLP
.1a742a	6b		rtl		                RTL
.1a742b					go_next
.1a742b	c2 20		rep #$20	            REP #$20
.1a742d	18		clc		                CLC
.1a742e	a5 0d		lda $0855	                LDA MARG1
.1a7430	69 01 00	adc #$0001	                ADC #1
.1a7433	85 0d		sta $0855	                STA MARG1
.1a7435	e2 20		sep #$20	            SEP #$20
.1a7437	a5 0e		lda $0856	                LDA MARG1+1
.1a7439	69 00		adc #$00	                ADC #0
.1a743b	85 0e		sta $0856	                STA MARG1+1
.1a743d	80 d0		bra $1a740f	                BRA do_copy
.1a743f					IMTRANSFER
.1a743f	08		php		                PHP
.1a7440	0b		phd		                PHD
.1a7441	08		php		            PHP
.1a7442	c2 20		rep #$20	            REP #$20
.1a7444	48		pha		            PHA
.1a7445	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7448	5b		tcd		            TCD
.1a7449	68		pla		            PLA
.1a744a	28		plp		            PLP
.1a744b	e2 20		sep #$20	            SEP #$20
.1a744d	a5 0f		lda $0857	                LDA MARG1+2
.1a744f	c5 17		cmp $085f	                CMP MARG3+2
.1a7451	90 45		bcc $1a7498	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.1a7453	c2 20		rep #$20	            REP #$20
.1a7455	a5 0d		lda $0855	                LDA MARG1
.1a7457	c5 15		cmp $085d	                CMP MARG3
.1a7459	90 3d		bcc $1a7498	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.1a745b					copy_byte_down
.1a745b	e2 20		sep #$20	            SEP #$20
.1a745d	a7 0d		lda [$0855]	                LDA [MARG1]         ; Copy the byte
.1a745f	87 15		sta [$085d]	                STA [MARG3]
.1a7461	a5 0f		lda $0857	                LDA MARG1+2         ; Are the source's current and end bank bytes equal?
.1a7463	c5 13		cmp $085b	                CMP MARG2+2
.1a7465	d0 0b		bne $1a7472	                BNE inc_pointers    ; No: we're not done yet
.1a7467	c2 20		rep #$20	            REP #$20
.1a7469	a5 0d		lda $0855	                LDA MARG1           ; Are the rest of the bits equal?
.1a746b	c5 11		cmp $0859	                CMP MARG2
.1a746d	d0 03		bne $1a7472	                BNE inc_pointers    ; No: we're not done yet
.1a746f	4c f6 74	jmp $1a74f6	                JMP done            ; Yes: we've copied the last byte, exit
.1a7472					inc_pointers
.1a7472	c2 20		rep #$20	            REP #$20
.1a7474	18		clc		                CLC
.1a7475	a5 0d		lda $0855	                LDA MARG1
.1a7477	69 01 00	adc #$0001	                ADC #1
.1a747a	85 0d		sta $0855	                STA MARG1
.1a747c	e2 20		sep #$20	            SEP #$20
.1a747e	a5 0e		lda $0856	                LDA MARG1+1
.1a7480	69 00		adc #$00	                ADC #0
.1a7482	85 0e		sta $0856	                STA MARG1+1
.1a7484	c2 20		rep #$20	            REP #$20
.1a7486	18		clc		                CLC
.1a7487	a5 15		lda $085d	                LDA MARG3
.1a7489	69 01 00	adc #$0001	                ADC #1
.1a748c	85 15		sta $085d	                STA MARG3
.1a748e	e2 20		sep #$20	            SEP #$20
.1a7490	a5 16		lda $085e	                LDA MARG3+1
.1a7492	69 00		adc #$00	                ADC #0
.1a7494	85 16		sta $085e	                STA MARG3+1
.1a7496	80 c3		bra $1a745b	                BRA copy_byte_down  ; And copy that next byte over
.1a7498					copy_up
.1a7498	c2 20		rep #$20	            REP #$20
.1a749a	38		sec		                SEC
.1a749b	a5 11		lda $0859	                LDA MARG2
.1a749d	e5 0d		sbc $0855	                SBC MARG1
.1a749f	85 19		sta $0861	                STA MARG4
.1a74a1	e2 20		sep #$20	            SEP #$20
.1a74a3	a5 13		lda $085b	                LDA MARG2+2
.1a74a5	e5 0f		sbc $0857	                SBC MARG1+2
.1a74a7	85 1b		sta $0863	                STA MARG4+2
.1a74a9	c2 20		rep #$20	            REP #$20
.1a74ab	18		clc		                CLC
.1a74ac	a5 19		lda $0861	                LDA MARG4
.1a74ae	65 15		adc $085d	                ADC MARG3
.1a74b0	85 15		sta $085d	                STA MARG3
.1a74b2	e2 20		sep #$20	            SEP #$20
.1a74b4	a5 1b		lda $0863	                LDA MARG4+2
.1a74b6	65 17		adc $085f	                ADC MARG3+2
.1a74b8	85 17		sta $085f	                STA MARG3+2
.1a74ba					copy_byte_up
.1a74ba	e2 20		sep #$20	            SEP #$20
.1a74bc	a7 11		lda [$0859]	                LDA [MARG2]
.1a74be	87 15		sta [$085d]	                STA [MARG3]
.1a74c0	a5 13		lda $085b	                LDA MARG2+2         ; Are the source's current and start bank bytes equal?
.1a74c2	c5 0f		cmp $0857	                CMP MARG1+2
.1a74c4	d0 0a		bne $1a74d0	                BNE dec_pointers    ; No: we're not done yet
.1a74c6	c2 20		rep #$20	            REP #$20
.1a74c8	a5 11		lda $0859	                LDA MARG2           ; Are the rest of the bits equal?
.1a74ca	c5 0d		cmp $0855	                CMP MARG1
.1a74cc	d0 02		bne $1a74d0	                BNE dec_pointers    ; No: we're not done yet
.1a74ce	80 26		bra $1a74f6	                BRA done            ; Yes: we've copied the last byte, exit
.1a74d0					dec_pointers
.1a74d0	c2 20		rep #$20	            REP #$20
.1a74d2	38		sec		                SEC
.1a74d3	a5 11		lda $0859	                LDA MARG2
.1a74d5	e9 01 00	sbc #$0001	                SBC #1
.1a74d8	85 11		sta $0859	                STA MARG2
.1a74da	e2 20		sep #$20	            SEP #$20
.1a74dc	a5 12		lda $085a	                LDA MARG2+1
.1a74de	e9 00		sbc #$00	                SBC #0
.1a74e0	85 12		sta $085a	                STA MARG2+1
.1a74e2	c2 20		rep #$20	            REP #$20
.1a74e4	38		sec		                SEC                 ; Decrement the current destination pointer (MARG3)
.1a74e5	a5 15		lda $085d	                LDA MARG3
.1a74e7	e9 01 00	sbc #$0001	                SBC #1
.1a74ea	85 15		sta $085d	                STA MARG3
.1a74ec	e2 20		sep #$20	            SEP #$20
.1a74ee	a5 16		lda $085e	                LDA MARG3+1
.1a74f0	e9 00		sbc #$00	                SBC #0
.1a74f2	85 16		sta $085e	                STA MARG3+1
.1a74f4	80 c4		bra $1a74ba	                BRA copy_byte_up    ; And copy that next byte
.1a74f6					done
.1a74f6	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a74f9	2b		pld		                PLD
.1a74fa	28		plp		                PLP
.1a74fb	6b		rtl		                RTL
.1a74fc					IS_PRINTABLE
.1a74fc	08		php		                PHP
.1a74fd	e2 20		sep #$20	            SEP #$20
.1a74ff	c9 21		cmp #$21	                CMP #33
.1a7501	90 0b		bcc $1a750e	                BLT not_printable   ; 0 .. 31 are not printable
.1a7503	c9 7f		cmp #$7f	                CMP #127
.1a7505	90 04		bcc $1a750b	                BLT printable       ; 32 .. 126 are printable
.1a7507	c9 a0		cmp #$a0	                CMP #160
.1a7509	90 03		bcc $1a750e	                BLT not_printable   ; 127 .. 159 are not printable (assuming Latin-1)
.1a750b	28		plp		printable       PLP
.1a750c	38		sec		                SEC
.1a750d	6b		rtl		                RTL
.1a750e	28		plp		not_printable   PLP
.1a750f	18		clc		                CLC
.1a7510	6b		rtl		                RTL
=256					MMEMDUMPSIZE = 256  ; Default number of bytes to dump
=8					MMEMROWSIZE = 8    ; Number of bytes to dump per-row
.1a7511					IMMEMORY
.1a7511	08		php		                PHP
.1a7512	8b		phb		                PHB
.1a7513	0b		phd		                PHD
.1a7514	08		php		            PHP
.1a7515	c2 20		rep #$20	            REP #$20
.1a7517	48		pha		            PHA
.1a7518	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a751b	5b		tcd		            TCD
.1a751c	68		pla		            PLA
.1a751d	28		plp		            PLP
.1a751e	e2 20		sep #$20	            SEP #$20
.1a7520	a9 00		lda #$00	                LDA #0              ; Clear the pagination line counter
.1a7522	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT
.1a7526	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.1a7528	c9 02		cmp #$02	                CMP #2
.1a752a	b0 16		bcs $1a7542	                BGE set_cursor      ; 2>= arguments? Use them as-is
.1a752c	c9 01		cmp #$01	                CMP #1
.1a752e	90 20		bcc $1a7550	                BLT no_args         ; No arguments passed? Use defaults
.1a7530	c2 20		rep #$20	            REP #$20
.1a7532	18		clc		                CLC
.1a7533	a5 0d		lda $0855	                LDA MARG1
.1a7535	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a7538	85 11		sta $0859	                STA MARG2
.1a753a	e2 20		sep #$20	            SEP #$20
.1a753c	a5 0f		lda $0857	                LDA MARG1+2
.1a753e	69 00		adc #$00	                ADC #0
.1a7540	85 13		sta $085b	                STA MARG2+2
.1a7542					set_cursor
.1a7542	c2 20		rep #$20	            REP #$20
.1a7544	a5 0d		lda $0855	                LDA MARG1
.1a7546	85 32		sta $087a	                STA MCURSOR
.1a7548	e2 20		sep #$20	            SEP #$20
.1a754a	a5 0f		lda $0857	                LDA MARG1+2
.1a754c	85 34		sta $087c	                STA MCURSOR+2
.1a754e	80 12		bra $1a7562	                BRA dump_line
.1a7550					no_args
.1a7550	c2 20		rep #$20	            REP #$20
.1a7552	18		clc		                CLC
.1a7553	a5 32		lda $087a	                LDA MCURSOR
.1a7555	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a7558	85 11		sta $0859	                STA MARG2
.1a755a	e2 20		sep #$20	            SEP #$20
.1a755c	a5 34		lda $087c	                LDA MCURSOR+2
.1a755e	69 00		adc #$00	                ADC #0
.1a7560	85 13		sta $085b	                STA MARG2+2
.1a7562					dump_line
.1a7562	e2 20		sep #$20	            SEP #$20
.1a7564	a0 00 00	ldy #$0000	                LDY #0
.1a7567	c2 20		rep #$20	            REP #$20
.1a7569	a5 32		lda $087a	                LDA MCURSOR             ; NOTE: the use of MARG4 here is a temporary
.1a756b	85 19		sta $0861	                STA MARG4               ; hack. the copy_loop instruction does not
.1a756d	e2 20		sep #$20	            SEP #$20
.1a756f	a5 34		lda $087c	                LDA MCURSOR+2
.1a7571	85 1b		sta $0863	                STA MARG4+2
.1a7573	e2 20		sep #$20	            SEP #$20
.1a7575	a7 19		lda [$0861]	copy_loop       LDA [MARG4]             ; TODO: Should be LDA [MCURSOR],Y, which doesn't seem to be working
.1a7577	22 fc 74 1a	jsl $1a74fc	                JSL IS_PRINTABLE        ; Is it printable?
.1a757b	b0 02		bcs $1a757f	                BCS buffer_char         ; Yes: go ahead and add it to the line buffer
.1a757d	a9 3f		lda #$3f	                LDA #'?'                ; No: replace it with dot
.1a757f	99 7e 08	sta $087e,y	buffer_char     STA #MLINEBUF,B,Y
.1a7582	c2 20		rep #$20	            REP #$20
.1a7584	18		clc		                CLC
.1a7585	a5 19		lda $0861	                LDA MARG4
.1a7587	69 01 00	adc #$0001	                ADC #1
.1a758a	85 19		sta $0861	                STA MARG4
.1a758c	e2 20		sep #$20	            SEP #$20
.1a758e	a5 1b		lda $0863	                LDA MARG4+2
.1a7590	69 00		adc #$00	                ADC #0
.1a7592	85 1b		sta $0863	                STA MARG4+2
.1a7594	c8		iny		                INY
.1a7595	c0 08 00	cpy #$0008	                CPY #MMEMROWSIZE
.1a7598	90 db		bcc $1a7575	                BLT copy_loop
.1a759a	a9 00		lda #$00	                LDA #0
.1a759c	99 7e 08	sta $087e,y	                STA #MLINEBUF,B,Y
.1a759f	a9 3e		lda #$3e	                LDA #'>'
.1a75a1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a75a4	a9 20		lda #$20	                LDA #' '
.1a75a6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a75a9	e2 20		sep #$20	            SEP #$20
.1a75ab	a5 34		lda $087c	                LDA MCURSOR+2
.1a75ad	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a75b0	a9 3a		lda #$3a	                LDA #':'                ; then a colon
.1a75b2	20 18 00	jsr $1a0018	            JSR PRINTC
.1a75b5	c2 20		rep #$20	            REP #$20
.1a75b7	a5 32		lda $087a	                LDA MCURSOR
.1a75b9	20 39 04	jsr $1a0439	            JSR PRHEXW
.1a75bc	c2 20		rep #$20	            REP #$20
.1a75be	a9 08 00	lda #$0008	                LDA #MMEMROWSIZE
.1a75c1	85 47		sta $088f	                STA MCOUNT
.1a75c3					prhex_loop
.1a75c3	e2 20		sep #$20	            SEP #$20
.1a75c5	a9 20		lda #$20	                LDA #' '
.1a75c7	20 18 00	jsr $1a0018	            JSR PRINTC
.1a75ca	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a75cc	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a75cf	22 3e 86 1a	jsl $1a863e	                JSL M_INC_CURSOR        ; Point MCURSOR to the next byte
.1a75d3					check_line
.1a75d3	e2 20		sep #$20	            SEP #$20
.1a75d5	c6 47		dec $088f	                DEC MCOUNT              ; Count down the number of bytes on the row
.1a75d7	d0 ea		bne $1a75c3	                BNE prhex_loop          ; If we're not at zero, keep looping over the bytes
.1a75d9	a9 20		lda #$20	                LDA #' '
.1a75db	20 18 00	jsr $1a0018	            JSR PRINTC
.1a75de	a9 20		lda #$20	                LDA #' '
.1a75e0	20 18 00	jsr $1a0018	            JSR PRINTC
.1a75e3	08		php		            PHP
.1a75e4	e2 20		sep #$20	            SEP #$20
.1a75e6	48		pha		            PHA
.1a75e7	a9 00		lda #$00	            LDA #`MLINEBUF
.1a75e9	48		pha		            PHA
.1a75ea	ab		plb		            PLB
.1a75eb	68		pla		            PLA
.1a75ec	28		plp		            PLP
.1a75ed	a2 7e 08	ldx #$087e	                LDX #MLINEBUF
.1a75f0	20 29 04	jsr $1a0429	            JSR PRINTS
.1a75f3	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a75f6	20 b3 03	jsr $1a03b3	            JSR PAGINATE
.1a75f9	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.1a75fb	c5 13		cmp $085b	                CMP MARG2+2
.1a75fd	90 0f		bcc $1a760e	                BLT continue            ; No: continue
.1a75ff	c2 20		rep #$20	            REP #$20
.1a7601	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.1a7603	c5 11		cmp $0859	                CMP MARG2
.1a7605	90 07		bcc $1a760e	                BLT continue            ; Nope... keep going
.1a7607					done
.1a7607	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a760a	2b		pld		                PLD
.1a760b	ab		plb		                PLB
.1a760c	28		plp		                PLP
.1a760d	6b		rtl		                RTL
.1a760e	4c 62 75	jmp $1a7562	continue        JMP dump_line
.1a7611					M_COPY_ARGB
.1a7611	08		php		                PHP
.1a7612	8d 92 08	sta $0892	                STA MTEMP
.1a7615	e2 20		sep #$20	            SEP #$20
.1a7617	bd 00 00	lda $0000,x	loop            LDA #0,B,X
.1a761a	99 00 00	sta $0000,y	                STA #0,B,Y      ; Copy the byte
.1a761d	ad 92 08	lda $0892	                LDA MTEMP       ; Check the count of characters remaining
.1a7620	f0 0a		beq $1a762c	                BEQ done        ; If it's 0, we're done
.1a7622	c8		iny		                INY             ; Point to the next destination byte
.1a7623	e8		inx		                INX             ; Point to the next source byte (skip three bytes)
.1a7624	e8		inx		                INX
.1a7625	e8		inx		                INX
.1a7626	e8		inx		                INX
.1a7627	ce 92 08	dec $0892	                DEC MTEMP       ; Count down and see if we're done
.1a762a	80 eb		bra $1a7617	                BRA loop
.1a762c	28		plp		done            PLP
.1a762d	6b		rtl		                RTL
.1a762e					IMMODIFY
.1a762e	08		php		                PHP
.1a762f	0b		phd		                PHD
.1a7630	8b		phb		                PHB
.1a7631	08		php		            PHP
.1a7632	c2 20		rep #$20	            REP #$20
.1a7634	48		pha		            PHA
.1a7635	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7638	5b		tcd		            TCD
.1a7639	68		pla		            PLA
.1a763a	28		plp		            PLP
.1a763b	08		php		            PHP
.1a763c	e2 20		sep #$20	            SEP #$20
.1a763e	48		pha		            PHA
.1a763f	a9 00		lda #$00	            LDA #0
.1a7641	48		pha		            PHA
.1a7642	ab		plb		            PLB
.1a7643	68		pla		            PLA
.1a7644	28		plp		            PLP
.1a7645	c2 30		rep #$30	            REP #$30
.1a7647	a5 0d		lda $0855	                LDA MARG1           ; Set MCURSOR to MARG1
.1a7649	85 32		sta $087a	                STA MCURSOR
.1a764b	a5 0f		lda $0857	                LDA MARG1+2
.1a764d	85 34		sta $087c	                STA MCURSOR+2
.1a764f	e2 20		sep #$20	            SEP #$20
.1a7651	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.1a7653	3a		dec a		                DEC A               ; (MARG_LEN - 1)
.1a7654	85 47		sta $088f	                STA MCOUNT
.1a7656	a2 59 08	ldx #$0859	                LDX #<>MARG2        ; Copy MCOUNT bytes from MARG2..MARG9
.1a7659	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF     ; to MLINEBUF
.1a765c	22 11 76 1a	jsl $1a7611	                JSL M_COPY_ARGB
.1a7660	a0 00 00	ldy #$0000	                LDY #0
.1a7663	b9 7e 08	lda $087e,y	loop            LDA MLINEBUF,Y      ; Copy the byte from the buffer
.1a7666	87 32		sta [$087a]	                STA [MCURSOR]       ; To the address indicated by MCURSOR
.1a7668	22 3e 86 1a	jsl $1a863e	                JSL M_INC_CURSOR    ; Advance the cursor
.1a766c	c8		iny		                INY                 ; Go to the next buffered byte
.1a766d	c4 47		cpy $088f	                CPY MCOUNT          ; Did we just write the last one?
.1a766f	d0 f2		bne $1a7663	                BNE loop            ; No: continue writing
.1a7671	ab		plb		                PLB
.1a7672	2b		pld		                PLD
.1a7673	28		plp		                PLP
.1a7674	6b		rtl		                RTL
.1a7675					IMHUNT
.1a7675	08		php		                PHP
.1a7676	0b		phd		                PHD
.1a7677	8b		phb		                PHB
.1a7678	08		php		            PHP
.1a7679	c2 20		rep #$20	            REP #$20
.1a767b	48		pha		            PHA
.1a767c	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a767f	5b		tcd		            TCD
.1a7680	68		pla		            PLA
.1a7681	28		plp		            PLP
.1a7682	08		php		            PHP
.1a7683	e2 20		sep #$20	            SEP #$20
.1a7685	48		pha		            PHA
.1a7686	a9 00		lda #$00	            LDA #0
.1a7688	48		pha		            PHA
.1a7689	ab		plb		            PLB
.1a768a	68		pla		            PLA
.1a768b	28		plp		            PLP
.1a768c	e2 20		sep #$20	            SEP #$20
.1a768e	c2 10		rep #$10	            REP #$10
.1a7690	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.1a7692	3a		dec a		                DEC A               ; (MARG_LEN - 2)
.1a7693	3a		dec a		                DEC A
.1a7694	85 47		sta $088f	                STA MCOUNT
.1a7696	a2 5d 08	ldx #$085d	                LDX #<>MARG3
.1a7699	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF
.1a769c	22 11 76 1a	jsl $1a7611	                JSL M_COPY_ARGB
.1a76a0	c2 20		rep #$20	            REP #$20
.1a76a2	a5 0d		lda $0855	                LDA MARG1           ; Copy starting address to MCURSOR
.1a76a4	85 32		sta $087a	                STA MCURSOR
.1a76a6	a5 0f		lda $0857	                LDA MARG1+2
.1a76a8	85 34		sta $087c	                STA MCURSOR+2
.1a76aa					outer_loop
.1a76aa	c2 20		rep #$20	            REP #$20
.1a76ac	a5 34		lda $087c	                LDA MCURSOR+2      ; If MCURSOR < MARG2, we're not done yet
.1a76ae	c5 13		cmp $085b	                CMP MARG2+2
.1a76b0	d0 06		bne $1a76b8	                BNE not_done
.1a76b2	a5 32		lda $087a	                LDA MCURSOR
.1a76b4	c5 11		cmp $0859	                CMP MARG2
.1a76b6	f0 2c		beq $1a76e4	                BEQ done            ; MCURSOR = MARG2: we're done
.1a76b8					not_done
.1a76b8	e2 20		sep #$20	            SEP #$20
.1a76ba	a0 00 00	ldy #$0000	                LDY #0
.1a76bd	b7 32		lda [$087a],y	cmp_loop        LDA [MCURSOR],Y     ; Get the byte from the memory to check
.1a76bf	d9 7e 08	cmp $087e,y	                CMP MLINEBUF,Y      ; Compare it against our pattern
.1a76c2	d0 1a		bne $1a76de	                BNE advance         ; If not equal, we need to move on
.1a76c4	c8		iny		                INY                 ; Otherwise do we have more bytes to check?
.1a76c5	c4 47		cpy $088f	                CPY MCOUNT
.1a76c7	d0 f4		bne $1a76bd	                BNE cmp_loop        ; No: check more
.1a76c9	c2 20		rep #$20	            REP #$20
.1a76cb	a5 32		lda $087a	                LDA MCURSOR         ; Print the address
.1a76cd	85 4a		sta $0892	                STA MTEMP
.1a76cf	a5 34		lda $087c	                LDA MCURSOR+2
.1a76d1	85 4c		sta $0894	                STA MTEMP+2
.1a76d3	22 e8 80 1a	jsl $1a80e8	                JSL M_PR_ADDR
.1a76d7	e2 20		sep #$20	            SEP #$20
.1a76d9	a9 20		lda #$20	                LDA #' '
.1a76db	20 18 00	jsr $1a0018	            JSR PRINTC
.1a76de	22 3e 86 1a	jsl $1a863e	advance         JSL M_INC_CURSOR    ; Move MCURSOR forward by one
.1a76e2	80 c6		bra $1a76aa	                BRA outer_loop      ; And try to compare that to the pattern
.1a76e4					done
.1a76e4	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a76e7	ab		plb		                PLB
.1a76e8	2b		pld		                PLD
.1a76e9	28		plp		                PLP
.1a76ea	6b		rtl		                RTL
.1a76eb					IMJUMP
.1a76eb	08		php		            PHP
.1a76ec	c2 20		rep #$20	            REP #$20
.1a76ee	48		pha		            PHA
.1a76ef	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a76f2	5b		tcd		            TCD
.1a76f3	68		pla		            PLA
.1a76f4	28		plp		            PLP
.1a76f5	e2 20		sep #$20	            SEP #$20
.1a76f7	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.1a76f9	f0 0e		beq $1a7709	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.1a76fb	c2 30		rep #$30	            REP #$30
.1a76fd	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.1a76ff	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.1a7703	a5 0f		lda $0857	                LDA MARG1+2
.1a7705	8f 42 02 00	sta $000242	                STA @lCPUPBR
.1a7709	af 46 02 00	lda $000246	MJUMPRESTORE    LDA @lCPUX          ; Restore X and Y
.1a770d	aa		tax		                TAX
.1a770e	af 48 02 00	lda $000248	                LDA @lCPUY
.1a7712	a8		tay		                TAY
.1a7713	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.1a7717	1b		tcs		                TCS
.1a7718	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.1a771c	5b		tcd		                TCD
.1a771d	e2 20		sep #$20	            SEP #$20
.1a771f	a9 1a		lda #$1a	                LDA #`MJUMPSTART
.1a7721	48		pha		                PHA
.1a7722	a9 77		lda #$77	                LDA #>MJUMPSTART
.1a7724	48		pha		                PHA
.1a7725	a9 2b		lda #$2b	                LDA #<MJUMPSTART
.1a7727	48		pha		                PHA
.1a7728	4c 62 77	jmp $1a7762	                JMP MGOSTACK        ; And push remaining registers and restart execution
.1a772b	ea		nop		MJUMPSTART      NOP                 ; RTL increments PC pulled from stack, NOP leaves space for that
.1a772c	5c 04 00 1a	jmp $1a0004	                JML MONITOR
.1a7730					IMGO
.1a7730	08		php		            PHP
.1a7731	c2 20		rep #$20	            REP #$20
.1a7733	48		pha		            PHA
.1a7734	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a7737	5b		tcd		            TCD
.1a7738	68		pla		            PLA
.1a7739	28		plp		            PLP
.1a773a	e2 20		sep #$20	            SEP #$20
.1a773c	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.1a773e	f0 c9		beq $1a7709	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.1a7740	c2 30		rep #$30	            REP #$30
.1a7742	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.1a7744	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.1a7748	a5 0f		lda $0857	                LDA MARG1+2
.1a774a	8f 42 02 00	sta $000242	                STA @lCPUPBR
.1a774e	af 46 02 00	lda $000246	MGORESTORE      LDA @lCPUX          ; Restore X and Y
.1a7752	aa		tax		                TAX
.1a7753	af 48 02 00	lda $000248	                LDA @lCPUY
.1a7757	a8		tay		                TAY
.1a7758	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.1a775c	1b		tcs		                TCS
.1a775d	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.1a7761	5b		tcd		                TCD
.1a7762					MGOSTACK
.1a7762	e2 20		sep #$20	            SEP #$20
.1a7764	af 4e 02 00	lda $00024e	                LDA @lCPUDBR        ; Restore the data bank register
.1a7768	48		pha		                PHA
.1a7769	ab		plb		                PLB
.1a776a	a9 5c		lda #$5c	                LDA #$5C            ; Save the JSL opcode
.1a776c	8f a2 08 00	sta $0008a2	                STA @lMJUMPINST
.1a7770	af 42 02 00	lda $000242	                LDA @lCPUPBR        ; Write PBR
.1a7774	8f a5 08 00	sta $0008a5	                STA @lMJUMPADDR+2
.1a7778	af 41 02 00	lda $000241	                LDA @lCPUPC+1       ; Write PCH
.1a777c	8f a4 08 00	sta $0008a4	                STA @lMJUMPADDR+1
.1a7780	af 40 02 00	lda $000240	                LDA @lCPUPC         ; Write PCL
.1a7784	8f a3 08 00	sta $0008a3	                STA @lMJUMPADDR
.1a7788	af 4f 02 00	lda $00024f	                LDA @lCPUFLAGS      ; Push processor status
.1a778c	48		pha		                PHA
.1a778d	c2 20		rep #$20	            REP #$20
.1a778f	af 44 02 00	lda $000244	                LDA @lCPUA          ; Restore A
.1a7793	28		plp		                PLP                 ; And the status register
.1a7794	5c a2 08 00	jmp $0008a2	                JML MJUMPINST       ; And jump to the target address
.1a7798					IMCOMPARE
.1a7798	08		php		                PHP
.1a7799	0b		phd		                PHD
.1a779a	8b		phb		                PHB
.1a779b	08		php		            PHP
.1a779c	e2 20		sep #$20	            SEP #$20
.1a779e	48		pha		            PHA
.1a779f	a9 1a		lda #$1a	            LDA #`MERRARGS
.1a77a1	48		pha		            PHA
.1a77a2	ab		plb		            PLB
.1a77a3	68		pla		            PLA
.1a77a4	28		plp		            PLP
.1a77a5	08		php		            PHP
.1a77a6	c2 20		rep #$20	            REP #$20
.1a77a8	48		pha		            PHA
.1a77a9	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a77ac	5b		tcd		            TCD
.1a77ad	68		pla		            PLA
.1a77ae	28		plp		            PLP
.1a77af	c2 10		rep #$10	            REP #$10
.1a77b1	e2 20		sep #$20	            SEP #$20
.1a77b3	a5 31		lda $0879	                LDA MARG_LEN                ; Check the number of arguments provided
.1a77b5	c9 02		cmp #$02	                CMP #2
.1a77b7	f0 0c		beq $1a77c5	                BEQ default_len             ; If 2: set MCOUNT to default of 1
.1a77b9	c9 03		cmp #$03	                CMP #3
.1a77bb	d0 11		bne $1a77ce	                BNE bad_arguments           ; Otherwise, if not 3: print an error
.1a77bd	c2 20		rep #$20	            REP #$20
.1a77bf	a5 15		lda $085d	                LDA MARG3                   ; If 3: set MCOUNT to MARG3
.1a77c1	85 47		sta $088f	                STA MCOUNT
.1a77c3	80 11		bra $1a77d6	                BRA compare
.1a77c5					default_len
.1a77c5	c2 20		rep #$20	            REP #$20
.1a77c7	a9 01 00	lda #$0001	                LDA #1                      ; No length was provided, set MCOUNT to 1
.1a77ca	85 47		sta $088f	                STA MCOUNT
.1a77cc	80 08		bra $1a77d6	                BRA compare
.1a77ce	a2 0a 89	ldx #$890a	bad_arguments   LDX #<>MERRARGS             ; The wrong number of arguments was provided
.1a77d1	20 29 04	jsr $1a0429	            JSR PRINTS
.1a77d4	80 35		bra $1a780b	                BRA done
.1a77d6	a5 0d		lda $0855	compare         LDA MARG1                   ; Set MTEMP to MARG1
.1a77d8	85 4a		sta $0892	                STA MTEMP
.1a77da	a5 0f		lda $0857	                LDA MARG1+2
.1a77dc	85 4c		sta $0894	                STA MTEMP+2
.1a77de	a0 00 00	ldy #$0000	                LDY #0
.1a77e1					loop
.1a77e1	e2 20		sep #$20	            SEP #$20
.1a77e3	a7 4a		lda [$0892]	                LDA [MTEMP]                 ; Compare the byte at MTEMP
.1a77e5	d7 11		cmp [$0859],y	                CMP [MARG2],Y               ; To the Yth byte from MARG2
.1a77e7	f0 09		beq $1a77f2	                BEQ continue                ; If they're the same, keep going
.1a77e9	22 e8 80 1a	jsl $1a80e8	mismatch        JSL M_PR_ADDR               ; If they're different, print MTEMP
.1a77ed	a9 20		lda #$20	                LDA #' '
.1a77ef	20 18 00	jsr $1a0018	            JSR PRINTC
.1a77f2					continue
.1a77f2	c2 20		rep #$20	            REP #$20
.1a77f4	18		clc		                CLC                         ; Either way, increment MTEMP
.1a77f5	a5 4a		lda $0892	                LDA MTEMP
.1a77f7	69 01 00	adc #$0001	                ADC #1
.1a77fa	85 4a		sta $0892	                STA MTEMP
.1a77fc	a5 4c		lda $0894	                LDA MTEMP+2
.1a77fe	69 00 00	adc #$0000	                ADC #0
.1a7801	85 4c		sta $0894	                STA MTEMP+2
.1a7803	c8		iny		                INY                         ; Increment Y
.1a7804	c4 47		cpy $088f	                CPY MCOUNT                  ; Try again unless we've checked MCOUNT bytes
.1a7806	d0 d9		bne $1a77e1	                BNE loop
.1a7808	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a780b					done
.1a780b	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a780e	ab		plb		                PLB
.1a780f	2b		pld		                PLD
.1a7810	28		plp		                PLP
.1a7811	6b		rtl		                RTL
.1a7812					IMRMODIFY
.1a7812	08		php		                PHP
.1a7813	0b		phd		                PHD
.1a7814	8b		phb		                PHB
.1a7815	08		php		            PHP
.1a7816	e2 20		sep #$20	            SEP #$20
.1a7818	48		pha		            PHA
.1a7819	a9 00		lda #$00	            LDA #0
.1a781b	48		pha		            PHA
.1a781c	ab		plb		            PLB
.1a781d	68		pla		            PLA
.1a781e	28		plp		            PLP
.1a781f	08		php		            PHP
.1a7820	c2 20		rep #$20	            REP #$20
.1a7822	48		pha		            PHA
.1a7823	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a7826	5b		tcd		            TCD
.1a7827	68		pla		            PLA
.1a7828	28		plp		            PLP
.1a7829	e2 20		sep #$20	            SEP #$20
.1a782b	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.1a782d	f0 4f		beq $1a787e	                BEQ done            ; 0? Just quit
.1a782f	a6 0d		ldx $0855	                LDX MARG1           ; Set the PC and PBR
.1a7831	8e 40 02	stx $0240	                STX #CPUPC,B
.1a7834	a6 0f		ldx $0857	                LDX MARG1+2
.1a7836	8e 42 02	stx $0242	                STX #CPUPBR,B
.1a7839	c9 01		cmp #$01	                CMP #1              ; Check the number of arguments
.1a783b	f0 41		beq $1a787e	                BEQ done            ; 1? Just quit
.1a783d	a6 11		ldx $0859	                LDX MARG2           ; Set A
.1a783f	8e 44 02	stx $0244	                STX #CPUA,B
.1a7842	c9 02		cmp #$02	                CMP #2              ; Check the number of arguments
.1a7844	f0 38		beq $1a787e	                BEQ done            ; 2? Just quit
.1a7846	a6 15		ldx $085d	                LDX MARG3           ; Set X
.1a7848	8e 46 02	stx $0246	                STX #CPUX,B
.1a784b	c9 03		cmp #$03	                CMP #3              ; Check the number of arguments
.1a784d	f0 2f		beq $1a787e	                BEQ done            ; 3? Just quit
.1a784f	a6 19		ldx $0861	                LDX MARG4           ; Set Y
.1a7851	8e 48 02	stx $0248	                STX #CPUY,B
.1a7854	c9 04		cmp #$04	                CMP #4              ; Check the number of arguments
.1a7856	f0 26		beq $1a787e	                BEQ done            ; 4? Just quit
.1a7858	a6 1d		ldx $0865	                LDX MARG5           ; Set SP
.1a785a	8e 4a 02	stx $024a	                STX #CPUSTACK,B
.1a785d	c9 05		cmp #$05	                CMP #5              ; Check the number of arguments
.1a785f	f0 1d		beq $1a787e	                BEQ done            ; 5? Just quit
.1a7861	e2 10		sep #$10	            SEP #$10
.1a7863	a6 21		ldx $0869	                LDX MARG6           ; Set DBR
.1a7865	8e 4e 02	stx $024e	                STX #CPUDBR,B
.1a7868	c9 06		cmp #$06	                CMP #6              ; Check the number of arguments
.1a786a	f0 12		beq $1a787e	                BEQ done            ; 6? Just quit
.1a786c	c2 10		rep #$10	            REP #$10
.1a786e	a6 25		ldx $086d	                LDX MARG7           ; Set DP
.1a7870	8e 4c 02	stx $024c	                STX #CPUDP,B
.1a7873	c9 07		cmp #$07	                CMP #7              ; Check the number of arguments
.1a7875	f0 07		beq $1a787e	                BEQ done            ; 7? Just quit
.1a7877	e2 10		sep #$10	            SEP #$10
.1a7879	a6 29		ldx $0871	                LDX MARG8           ; Set flags
.1a787b	8e 4f 02	stx $024f	                STX #CPUFLAGS,B
.1a787e	ab		plb		done            PLB
.1a787f	2b		pld		                PLD
.1a7880	28		plp		                PLP
.1a7881	6b		rtl		                RTL
.1a7882					IMEXECUTE
.1a7882	08		php		                PHP
.1a7883	0b		phd		                PHD
.1a7884	8b		phb		                PHB
.1a7885	08		php		            PHP
.1a7886	c2 20		rep #$20	            REP #$20
.1a7888	48		pha		            PHA
.1a7889	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a788c	5b		tcd		            TCD
.1a788d	68		pla		            PLA
.1a788e	28		plp		            PLP
.1a788f	e2 20		sep #$20	            SEP #$20
.1a7891	c2 10		rep #$10	            REP #$10
.1a7893	a2 00 00	ldx #$0000	                LDX #0
.1a7896	bf 77 89 1a	lda $1a8977,x	loop            LDA @lMCOMMANDS,X
.1a789a	f0 18		beq $1a78b4	                BEQ done
.1a789c	c7 08		cmp [$0850]	                CMP [MCMD]
.1a789e	f0 03		beq $1a78a3	                BEQ found
.1a78a0	e8		inx		                INX
.1a78a1	80 f3		bra $1a7896	                BRA loop
.1a78a3					found
.1a78a3	c2 20		rep #$20	            REP #$20
.1a78a5	8a		txa		                TXA
.1a78a6	0a		asl a		                ASL A
.1a78a7	aa		tax		                TAX
.1a78a8	bf b8 78 1a	lda $1a78b8,x	                LDA dispatch,X
.1a78ac	8f 2f 08 00	sta $00082f	                STA @lJMP16PTR
.1a78b0	22 dc 78 1a	jsl $1a78dc	                JSL MDOCMD
.1a78b4	ab		plb		done            PLB
.1a78b5	2b		pld		                PLD
.1a78b6	28		plp		                PLP
.1a78b7	6b		rtl		                RTL
>1a78b8	58 6f				dispatch        .word <>MASSEMBLE
>1a78ba	60 6f				                .word <>MCOMPARE
>1a78bc	64 6f				                .word <>MDISASSEMBLE
>1a78be	68 6f				                .word <>MFILL
>1a78c0	6c 6f				                .word <>MGO
>1a78c2	70 6f				                .word <>MJUMP
>1a78c4	74 6f				                .word <>MHUNT
>1a78c6	78 6f				                .word <>MLOAD
>1a78c8	7c 6f				                .word <>MMEMORY
>1a78ca	80 6f				                .word <>MREGISTERS
>1a78cc	5c 6f				                .word <>MRMODIFY
>1a78ce	84 6f				                .word <>MSAVE
>1a78d0	88 6f				                .word <>MTRANSFER
>1a78d2	8c 6f				                .word <>MVERIFY
>1a78d4	4e 73				                .word <>IMWIDTH
>1a78d6	90 6f				                .word <>MEXIT
>1a78d8	94 6f				                .word <>MMODIFY
>1a78da	c7 6f				                .word <>IMHELP
.1a78dc					MDOCMD
.1a78dc	6c 2f 08	jmp ($082f)	                JMP (JMP16PTR)

;******  Processing file: src\assembler.s

=0					ADDR_DP_IND_X = 0       ; (dd,X)
=1					ADDR_DP = 1             ; dd
=2					ADDR_IMM = 2            ; #dd
=3					ADDR_ABS = 3            ; dddd
=4					ADDR_DP_IND_Y = 4       ; (dd),Y
=5					ADDR_DP_X = 5           ; dd,X
=6					ADDR_ABS_Y = 6          ; dddd,Y
=7					ADDR_ABS_X = 7          ; dddd,X
=8					ADDR_ACC = 8            ; A
=9					ADDR_SP_R = 9           ; #d,S
=10					ADDR_DP_LONG = 10       ; [dd]
=11					ADDR_ABS_LONG = 11      ; dddddd
=12					ADDR_SP_R_Y = 12        ; #dd,S,Y
=13					ADDR_DP_Y_LONG = 13     ; [dd],Y
=14					ADDR_ABS_X_LONG = 14    ; dddddd,X
=15					ADDR_DP_IND = 15        ; (dd)
=16					ADDR_ABS_X_ID = 16      ; (dddd,X)
=17					ADDR_DP_Y = 17          ; dd,Y
=18					ADDR_PC_REL = 18        ; PC relative
=19					ADDR_IMPLIED = 19       ; Implied (no operand)
=20					ADDR_XYC = 20           ; #dd, #dd
=21					ADDR_ABS_IND = 21       ; (dddd)
=22					ADDR_PC_REL_LONG = 22   ; PC relative ()
=23					ADDR_ABS_IND_LONG = 23  ; [dddd]
=$80					OP_M_EFFECT = $80       ; Flag to indicate instruction is modified by M
=$40					OP_X_EFFECT = $40       ; Flag to indicate instruction is modified by X
.1a78df					IMASSEMBLE
.1a78df	08		php		                PHP
.1a78e0	8b		phb		                PHB
.1a78e1	0b		phd		                PHD
.1a78e2	08		php		            PHP
.1a78e3	c2 20		rep #$20	            REP #$20
.1a78e5	48		pha		            PHA
.1a78e6	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a78e9	5b		tcd		            TCD
.1a78ea	68		pla		            PLA
.1a78eb	28		plp		            PLP
.1a78ec	e2 20		sep #$20	            SEP #$20
.1a78ee	a5 31		lda $0879	                LDA MARG_LEN            ; Do we have at least 2 arguments?
.1a78f0	c9 02		cmp #$02	                CMP #2
.1a78f2	b0 03		bcs $1a78f7	                BGE has_args            ; Yes: try to assemble the line
.1a78f4	4c 85 7a	jmp $1a7a85	                JMP done                ; No: just return
.1a78f7					has_args
.1a78f7	c2 20		rep #$20	            REP #$20
.1a78f9	a5 0d		lda $0855	                LDA MARG1               ; Set the monitor cursor to the address
.1a78fb	85 32		sta $087a	                STA MCURSOR
.1a78fd	a5 0f		lda $0857	                LDA MARG1+2
.1a78ff	85 34		sta $087c	                STA MCURSOR+2
.1a7901	c2 20		rep #$20	            REP #$20
.1a7903	22 87 7c 1a	jsl $1a7c87	                JSL AS_FIND_MNEMO       ; Find the address of the mnemonic
.1a7907	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a790a	f0 10		beq $1a791c	                BEQ bad_mnemonic        ; If not found, print bad mnemonic error message
.1a790c	85 54		sta $089c	                STA MMNEMONIC
.1a790e	e2 20		sep #$20	            SEP #$20
.1a7910	a5 31		lda $0879	                LDA MARG_LEN            ; Check the number of arguments passed
.1a7912	c9 03		cmp #$03	                CMP #3                  ; Were all three arguments provided?
.1a7914	f0 36		beq $1a794c	                BEQ get_operand         ; Yes: parse the operand
.1a7916	a9 13		lda #$13	                LDA #ADDR_IMPLIED       ; No: assume address mode is implied
.1a7918	85 4f		sta $0897	                STA MADDR_MODE
.1a791a	80 4c		bra $1a7968	                BRA get_opcode
.1a791c					bad_mnemonic
.1a791c	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a791f	08		php		            PHP
.1a7920	e2 20		sep #$20	            SEP #$20
.1a7922	48		pha		            PHA
.1a7923	a9 1a		lda #$1a	            LDA #`MERRBADMNEMO
.1a7925	48		pha		            PHA
.1a7926	ab		plb		            PLB
.1a7927	68		pla		            PLA
.1a7928	28		plp		            PLP
.1a7929	c2 10		rep #$10	            REP #$10
.1a792b	a2 bc 7a	ldx #$7abc	                LDX #<>MERRBADMNEMO
.1a792e	20 29 04	jsr $1a0429	            JSR PRINTS
.1a7931	4c 85 7a	jmp $1a7a85	                JMP done
.1a7934					bad_operand
.1a7934	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a7937	08		php		            PHP
.1a7938	e2 20		sep #$20	            SEP #$20
.1a793a	48		pha		            PHA
.1a793b	a9 1a		lda #$1a	            LDA #`MERRBADOPER
.1a793d	48		pha		            PHA
.1a793e	ab		plb		            PLB
.1a793f	68		pla		            PLA
.1a7940	28		plp		            PLP
.1a7941	c2 10		rep #$10	            REP #$10
.1a7943	a2 cb 7a	ldx #$7acb	                LDX #<>MERRBADOPER
.1a7946	20 29 04	jsr $1a0429	            JSR PRINTS
.1a7949	4c 85 7a	jmp $1a7a85	                JMP done
.1a794c					get_operand
.1a794c	e2 20		sep #$20	            SEP #$20
.1a794e	22 bd 7c 1a	jsl $1a7cbd	                JSL AS_FIND_MODE        ; Find the addressing mode of the operand
.1a7952	c9 ff		cmp #$ff	compare         CMP #$FF
.1a7954	f0 de		beq $1a7934	                BEQ bad_operand         ; If not found, print bad operand error message
.1a7956	85 4f		sta $0897	                STA MADDR_MODE
.1a7958	c9 03		cmp #$03	                CMP #ADDR_ABS           ; If mode is absolute or absolute long...
.1a795a	f0 62		beq $1a79be	                BEQ check_for_pcrel     ; Check to see if the mnemonic is one of the branches
.1a795c	c9 0b		cmp #$0b	                CMP #ADDR_ABS_LONG
.1a795e	f0 5e		beq $1a79be	                BEQ check_for_pcrel
.1a7960	c9 13		cmp #$13	                CMP #ADDR_IMPLIED       ; If mode is implied or accumulator, get the opcode
.1a7962	f0 04		beq $1a7968	                BEQ get_opcode
.1a7964	c9 08		cmp #$08	                CMP #ADDR_ACC
.1a7966	f0 00		beq $1a7968	                BEQ get_opcode
.1a7968	22 b5 7b 1a	jsl $1a7bb5	get_opcode      JSL AS_FIND_OPCODE      ; Find the opcode matching the two
.1a796c	b0 03		bcs $1a7971	                BCS save_opcode
.1a796e	4c 4e 7a	jmp $1a7a4e	                JMP bad_mode            ; If opcode not found, print bad address mode error message
.1a7971	87 32		sta [$087a]	save_opcode     STA [MCURSOR]           ; Write the opcode to the address
.1a7973	22 3e 86 1a	jsl $1a863e	                JSL M_INC_CURSOR        ; And point to the next byte
.1a7977	08		php		            PHP
.1a7978	e2 20		sep #$20	            SEP #$20
.1a797a	48		pha		            PHA
.1a797b	a9 00		lda #$00	            LDA #0
.1a797d	48		pha		            PHA
.1a797e	ab		plb		            PLB
.1a797f	68		pla		            PLA
.1a7980	28		plp		            PLP
.1a7981	c2 20		rep #$20	            REP #$20
.1a7983	a5 32		lda $087a	                LDA MCURSOR             ; Make MTEMPPTR a pointer to the machine code we're assembling
.1a7985	85 56		sta $089e	                STA MTEMPPTR
.1a7987	a5 34		lda $087c	                LDA MCURSOR+2
.1a7989	85 58		sta $08a0	                STA MTEMPPTR+2
.1a798b	e2 20		sep #$20	            SEP #$20
.1a798d	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check the address mode again
.1a798f	c9 12		cmp #$12	                CMP #ADDR_PC_REL        ; If it's PC relative
.1a7991	f0 6c		beq $1a79ff	                BEQ compute_rel         ; Convert the address to an offset
.1a7993	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.1a7995	f0 68		beq $1a79ff	                BEQ compute_rel
.1a7997	c9 14		cmp #$14	                CMP #ADDR_XYC           ; MVP/MVN addressing mode?
.1a7999	f0 7c		beq $1a7a17	                BEQ emit_2
.1a799b	29 3f		and #$3f	                AND #%00111111          ; Filter out the mode bits
.1a799d	c9 02		cmp #$02	                CMP #ADDR_IMM           ; Is it immediate?
.1a799f	d0 03		bne $1a79a4	                BNE fixed_length        ; Yes: emit it as an immediate (variable length)
.1a79a1	4c 7c 7a	jmp $1a7a7c	                JMP emit_imm
.1a79a4					fixed_length
.1a79a4	c2 20		rep #$20	            REP #$20
.1a79a6	29 ff 00	and #$00ff	                AND #$00FF
.1a79a9	aa		tax		                TAX
.1a79aa	e2 20		sep #$20	            SEP #$20
.1a79ac	bf 84 85 1a	lda $1a8584,x	get_length      LDA ADDR_LENGTH,X       ; Get the number of bytes in the addressing mode
.1a79b0	c9 03		cmp #$03	                CMP #$03
.1a79b2	f0 57		beq $1a7a0b	                BEQ emit_3
.1a79b4	c9 02		cmp #$02	                CMP #$02
.1a79b6	f0 5f		beq $1a7a17	                BEQ emit_2
.1a79b8	c9 01		cmp #$01	                CMP #$01
.1a79ba	f0 67		beq $1a7a23	                BEQ emit_1
.1a79bc	80 71		bra $1a7a2f	                BRA next_line
.1a79be					check_for_pcrel
.1a79be	c2 20		rep #$20	            REP #$20
.1a79c0	a5 54		lda $089c	                LDA MMNEMONIC
.1a79c2	c9 fc 81	cmp #$81fc	                CMP #<>MN_BRA
.1a79c5	f0 26		beq $1a79ed	                BEQ is_pcrel
.1a79c7	c9 60 82	cmp #$8260	                CMP #<>MN_BRL
.1a79ca	f0 2a		beq $1a79f6	                BEQ is_pcrel_long
.1a79cc	c9 e0 81	cmp #$81e0	                CMP #<>MN_BCC
.1a79cf	f0 1c		beq $1a79ed	                BEQ is_pcrel
.1a79d1	c9 e4 81	cmp #$81e4	                CMP #<>MN_BCS
.1a79d4	f0 17		beq $1a79ed	                BEQ is_pcrel
.1a79d6	c9 ec 81	cmp #$81ec	                CMP #<>MN_BEQ
.1a79d9	f0 12		beq $1a79ed	                BEQ is_pcrel
.1a79db	c9 d4 81	cmp #$81d4	                CMP #<>MN_BMI
.1a79de	f0 0d		beq $1a79ed	                BEQ is_pcrel
.1a79e0	c9 e8 81	cmp #$81e8	                CMP #<>MN_BNE
.1a79e3	f0 08		beq $1a79ed	                BEQ is_pcrel
.1a79e5	c9 d0 81	cmp #$81d0	                CMP #<>MN_BPL
.1a79e8	f0 03		beq $1a79ed	                BEQ is_pcrel
.1a79ea	4c 68 79	jmp $1a7968	                JMP get_opcode
.1a79ed					is_pcrel
.1a79ed	e2 20		sep #$20	            SEP #$20
.1a79ef	a9 12		lda #$12	                LDA #ADDR_PC_REL
.1a79f1	85 4f		sta $0897	                STA MADDR_MODE
.1a79f3	4c 68 79	jmp $1a7968	                JMP get_opcode
.1a79f6					is_pcrel_long
.1a79f6	e2 20		sep #$20	            SEP #$20
.1a79f8	a9 16		lda #$16	                LDA #ADDR_PC_REL_LONG
.1a79fa	85 4f		sta $0897	                STA MADDR_MODE
.1a79fc	4c 68 79	jmp $1a7968	                JMP get_opcode
.1a79ff	22 f8 7a 1a	jsl $1a7af8	compute_rel     JSL AS_PC_OFFSET        ; Try to compute the offset
.1a7a03	90 60		bcc $1a7a65	                BCC bad_offset          ; If failed, it's a bad offset operand
.1a7a05	c9 02		cmp #$02	emit_rel        CMP #$02                ; If the offset is two bytes
.1a7a07	f0 0e		beq $1a7a17	                BEQ emit_2              ; Emit those two bytes
.1a7a09	80 18		bra $1a7a23	                BRA emit_1              ; Otherwise emit just the one
.1a7a0b	a0 02 00	ldy #$0002	emit_3          LDY #2                  ; Write bank byte of operand
.1a7a0e	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.1a7a11	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.1a7a13	22 3e 86 1a	jsl $1a863e	                JSL M_INC_CURSOR
.1a7a17	a0 01 00	ldy #$0001	emit_2          LDY #1                  ; Write high byte of operand
.1a7a1a	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.1a7a1d	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.1a7a1f	22 3e 86 1a	jsl $1a863e	                JSL M_INC_CURSOR
.1a7a23	a0 00 00	ldy #$0000	emit_1          LDY #0                  ; Write low byte of operand
.1a7a26	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.1a7a29	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.1a7a2b	22 3e 86 1a	jsl $1a863e	                JSL M_INC_CURSOR
.1a7a2f					next_line
.1a7a2f	e2 20		sep #$20	            SEP #$20
.1a7a31	a9 41		lda #$41	                LDA #'A'
.1a7a33	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7a36	a9 20		lda #$20	                LDA #' '
.1a7a38	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7a3b	a6 32		ldx $087a	                LDX MCURSOR
.1a7a3d	86 4a		stx $0892	                STX MTEMP
.1a7a3f	a6 34		ldx $087c	                LDX MCURSOR+2
.1a7a41	86 4c		stx $0894	                STX MTEMP+2
.1a7a43	22 e8 80 1a	jsl $1a80e8	                JSL M_PR_ADDR
.1a7a47	a9 20		lda #$20	                LDA #' '
.1a7a49	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7a4c	80 37		bra $1a7a85	                BRA done
.1a7a4e					bad_mode
.1a7a4e	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a7a51	08		php		            PHP
.1a7a52	e2 20		sep #$20	            SEP #$20
.1a7a54	48		pha		            PHA
.1a7a55	a9 1a		lda #$1a	            LDA #`MERRBADMODE
.1a7a57	48		pha		            PHA
.1a7a58	ab		plb		            PLB
.1a7a59	68		pla		            PLA
.1a7a5a	28		plp		            PLP
.1a7a5b	c2 10		rep #$10	            REP #$10
.1a7a5d	a2 89 7a	ldx #$7a89	                LDX #<>MERRBADMODE
.1a7a60	20 29 04	jsr $1a0429	            JSR PRINTS
.1a7a63	80 20		bra $1a7a85	                BRA done
.1a7a65					bad_offset
.1a7a65	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a7a68	08		php		            PHP
.1a7a69	e2 20		sep #$20	            SEP #$20
.1a7a6b	48		pha		            PHA
.1a7a6c	a9 1a		lda #$1a	            LDA #`MERRBADOFFSET
.1a7a6e	48		pha		            PHA
.1a7a6f	ab		plb		            PLB
.1a7a70	68		pla		            PLA
.1a7a71	28		plp		            PLP
.1a7a72	c2 10		rep #$10	            REP #$10
.1a7a74	a2 d9 7a	ldx #$7ad9	                LDX #<>MERRBADOFFSET
.1a7a77	20 29 04	jsr $1a0429	            JSR PRINTS
.1a7a7a	80 09		bra $1a7a85	                BRA done
.1a7a7c	a5 4f		lda $0897	emit_imm        LDA MADDR_MODE          ; Check to see if long immediate was used
.1a7a7e	29 c0		and #$c0	                AND #%11000000
.1a7a80	d0 95		bne $1a7a17	                BNE emit_2              ; Yes: emit two bytes
.1a7a82	4c 23 7a	jmp $1a7a23	                JMP emit_1              ; No: emit one byte
.1a7a85	2b		pld		done            PLD
.1a7a86	ab		plb		                PLB
.1a7a87	28		plp		                PLP
.1a7a88	6b		rtl		                RTL
>1a7a89	41 64 64 72 65 73 73 69		MERRBADMODE     .null "Addressing mode not defined for that instruction.",CHAR_CR
>1a7a91	6e 67 20 6d 6f 64 65 20 6e 6f 74 20 64 65 66 69
>1a7aa1	6e 65 64 20 66 6f 72 20 74 68 61 74 20 69 6e 73
>1a7ab1	74 72 75 63 74 69 6f 6e 2e 0d 00
>1a7abc	42 61 64 20 6d 6e 65 6d		MERRBADMNEMO    .null "Bad mnemonic.",CHAR_CR
>1a7ac4	6f 6e 69 63 2e 0d 00
>1a7acb	42 61 64 20 6f 70 65 72		MERRBADOPER     .null "Bad operand.",CHAR_CR
>1a7ad3	61 6e 64 2e 0d 00
>1a7ad9	52 65 6c 61 74 69 76 65		MERRBADOFFSET   .null "Relative offset is too large.",CHAR_CR
>1a7ae1	20 6f 66 66 73 65 74 20 69 73 20 74 6f 6f 20 6c
>1a7af1	61 72 67 65 2e 0d 00
.1a7af8					AS_PC_OFFSET
.1a7af8	08		php		                PHP
.1a7af9	0b		phd		                PHD
.1a7afa	08		php		            PHP
.1a7afb	c2 20		rep #$20	            REP #$20
.1a7afd	48		pha		            PHA
.1a7afe	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7b01	5b		tcd		            TCD
.1a7b02	68		pla		            PLA
.1a7b03	28		plp		            PLP
.1a7b04	e2 20		sep #$20	            SEP #$20
.1a7b06	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check to see if it 1 byte or 2 byte relative
.1a7b08	c9 12		cmp #$12	                CMP #ADDR_PC_REL
.1a7b0a	f0 0a		beq $1a7b16	                BEQ is_short
.1a7b0c	c2 20		rep #$20	            REP #$20
.1a7b0e	18		clc		                CLC                     ; Branch is long. Compute where MCURSOR will be
.1a7b0f	a5 32		lda $087a	                LDA MCURSOR             ; with two branch offset bytes
.1a7b11	69 02 00	adc #$0002	                ADC #2
.1a7b14	80 08		bra $1a7b1e	                BRA compute_cursor
.1a7b16					is_short
.1a7b16	c2 20		rep #$20	            REP #$20
.1a7b18	18		clc		                CLC                     ; Branch is short. Computer where MCURSOR will be
.1a7b19	a5 32		lda $087a	                LDA MCURSOR             ; with one branch offset byte
.1a7b1b	69 01 00	adc #$0001	                ADC #1
.1a7b1e	85 4a		sta $0892	compute_cursor  STA MTEMP
.1a7b20	a5 34		lda $087c	                LDA MCURSOR+2
.1a7b22	69 00 00	adc #$0000	                ADC #0
.1a7b25	85 4c		sta $0894	                STA MTEMP+2
.1a7b27	38		sec		                SEC                     ; MPARSEDNUM = MPARSEDNUM - MTEMP (MCURSOR after the instruction)
.1a7b28	a5 50		lda $0898	                LDA MPARSEDNUM
.1a7b2a	e5 4a		sbc $0892	                SBC MTEMP
.1a7b2c	85 50		sta $0898	                STA MPARSEDNUM
.1a7b2e	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a7b30	e5 4c		sbc $0894	                SBC MTEMP+2
.1a7b32	85 52		sta $089a	                STA MPARSEDNUM+2
.1a7b34	e2 20		sep #$20	            SEP #$20
.1a7b36	a5 4f		lda $0897	                LDA MADDR_MODE
.1a7b38	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.1a7b3a	f0 1e		beq $1a7b5a	                BEQ check_long
.1a7b3c	a5 50		lda $0898	                LDA MPARSEDNUM          ; Short offset... check if it's negative
.1a7b3e	30 0c		bmi $1a7b4c	                BMI check_short_neg
.1a7b40	a5 51		lda $0899	                LDA MPARSEDNUM+1        ; Positive short offset... upper two bytes
.1a7b42	d0 2a		bne $1a7b6e	                BNE failure             ; Must be 0 or it's an overflow
.1a7b44	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a7b46	d0 26		bne $1a7b6e	                BNE failure
.1a7b48	a9 01		lda #$01	                LDA #1                  ; Short offset is 1 byte
.1a7b4a	80 26		bra $1a7b72	                BRA success
.1a7b4c	a5 51		lda $0899	check_short_neg LDA MPARSEDNUM+1        ; Negative short offset... upper two bytes
.1a7b4e	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's an  overflow
.1a7b50	d0 1c		bne $1a7b6e	                BNE failure
.1a7b52	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a7b54	c9 ff		cmp #$ff	                CMP #$FF
.1a7b56	d0 16		bne $1a7b6e	                BNE failure
.1a7b58	80 18		bra $1a7b72	                BRA success
.1a7b5a	a5 51		lda $0899	check_long      LDA MPARSEDNUM+1        ; Long offset... check if it's negative
.1a7b5c	30 06		bmi $1a7b64	                BMI check_long_neg
.1a7b5e	a5 52		lda $089a	                LDA MPARSEDNUM+2        ; Positive long offset... upper byte
.1a7b60	d0 0c		bne $1a7b6e	                BNE failure             ; Must be 0 or it's an overflow
.1a7b62	80 0e		bra $1a7b72	                BRA success
.1a7b64	a5 52		lda $089a	check_long_neg  LDA MPARSEDNUM+2        ; Negative offset... upper two bytes
.1a7b66	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's and overflow
.1a7b68	d0 04		bne $1a7b6e	                BNE failure
.1a7b6a	a9 02		lda #$02	                LDA #2                  ; Long offset is 2 bytes
.1a7b6c	80 04		bra $1a7b72	                BRA success
.1a7b6e	2b		pld		failure         PLD
.1a7b6f	28		plp		                PLP
.1a7b70	18		clc		                CLC
.1a7b71	6b		rtl		                RTL
.1a7b72	2b		pld		success         PLD
.1a7b73	28		plp		                PLP
.1a7b74	38		sec		                SEC
.1a7b75	6b		rtl		                RTL
.1a7b76					AS_SHIFT_HEX
.1a7b76	08		php		                PHP
.1a7b77	0b		phd		                PHD
.1a7b78	c2 10		rep #$10	            REP #$10
.1a7b7a	da		phx		                PHX
.1a7b7b	08		php		            PHP
.1a7b7c	c2 20		rep #$20	            REP #$20
.1a7b7e	48		pha		            PHA
.1a7b7f	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7b82	5b		tcd		            TCD
.1a7b83	68		pla		            PLA
.1a7b84	28		plp		            PLP
.1a7b85	e2 20		sep #$20	            SEP #$20
.1a7b87	a2 00 00	ldx #$0000	                LDX #0
.1a7b8a	df 00 d0 1a	cmp $1ad000,x	seek_loop       CMP @lHEXDIGITS,X   ; Check the passed character against the hex digits
.1a7b8e	f0 08		beq $1a7b98	                BEQ found
.1a7b90	e8		inx		                INX                 ; Go to the next hex digit
.1a7b91	e0 10 00	cpx #$0010	                CPX #$10            ; Are we out of digits?
.1a7b94	f0 1b		beq $1a7bb1	                BEQ done            ; Yes... just return
.1a7b96	80 f2		bra $1a7b8a	                BRA seek_loop
.1a7b98					found
.1a7b98	c2 20		rep #$20	            REP #$20
.1a7b9a	06 50		asl $0898	                ASL MPARSEDNUM
.1a7b9c	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7b9e	06 50		asl $0898	                ASL MPARSEDNUM
.1a7ba0	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7ba2	06 50		asl $0898	                ASL MPARSEDNUM
.1a7ba4	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7ba6	06 50		asl $0898	                ASL MPARSEDNUM
.1a7ba8	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7baa	e2 20		sep #$20	            SEP #$20
.1a7bac	8a		txa		                TXA
.1a7bad	05 50		ora $0898	                ORA MPARSEDNUM
.1a7baf	85 50		sta $0898	                STA MPARSEDNUM
.1a7bb1	fa		plx		done            PLX
.1a7bb2	2b		pld		                PLD
.1a7bb3	28		plp		                PLP
.1a7bb4	6b		rtl		                RTL
.1a7bb5					AS_FIND_OPCODE
.1a7bb5	0b		phd		                PHD
.1a7bb6	8b		phb		                PHB
.1a7bb7	08		php		            PHP
.1a7bb8	c2 20		rep #$20	            REP #$20
.1a7bba	48		pha		            PHA
.1a7bbb	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7bbe	5b		tcd		            TCD
.1a7bbf	68		pla		            PLA
.1a7bc0	28		plp		            PLP
.1a7bc1	08		php		            PHP
.1a7bc2	e2 20		sep #$20	            SEP #$20
.1a7bc4	48		pha		            PHA
.1a7bc5	a9 1a		lda #$1a	            LDA #`MNEMONIC_TAB
.1a7bc7	48		pha		            PHA
.1a7bc8	ab		plb		            PLB
.1a7bc9	68		pla		            PLA
.1a7bca	28		plp		            PLP
.1a7bcb	e2 20		sep #$20	            SEP #$20
.1a7bcd	a5 4f		lda $0897	                LDA MADDR_MODE
.1a7bcf	29 3f		and #$3f	                AND #%00111111
.1a7bd1	85 4a		sta $0892	                STA MTEMP
.1a7bd3	c2 30		rep #$30	            REP #$30
.1a7bd5	a2 00 00	ldx #$0000	                LDX #0
.1a7bd8	a0 00 00	ldy #$0000	                LDY #0
.1a7bdb	bd 82 82	lda $1a8282,x	mnemonic_loop   LDA MNEMONIC_TAB,X      ; Get the mnemonic from the opcode table
.1a7bde	f0 1b		beq $1a7bfb	                BEQ not_found           ; If it's 0, we did not find the mnemonic
.1a7be0	c5 54		cmp $089c	                CMP MMNEMONIC           ; Does it match the passed mnemonic?
.1a7be2	d0 0d		bne $1a7bf1	                BNE next_opcode         ; No: go to the next opcode
.1a7be4					check_mode
.1a7be4	e2 20		sep #$20	            SEP #$20
.1a7be6	b9 84 84	lda $1a8484,y	                LDA ADDRESS_TAB,Y       ; Get the corresponding address mode
.1a7be9	29 3f		and #$3f	                AND #%00111111          ; Filter out effect bits
.1a7beb	c5 4a		cmp $0892	                CMP MTEMP
.1a7bed	f0 07		beq $1a7bf6	                BEQ found               ; Yes: we found the opcode
.1a7bef	c2 20		rep #$20	            REP #$20
.1a7bf1	e8		inx		next_opcode     INX                     ; Point to the next mnemonic in the table
.1a7bf2	e8		inx		                INX
.1a7bf3	c8		iny		                INY
.1a7bf4	80 e5		bra $1a7bdb	                BRA mnemonic_loop       ; And check it
.1a7bf6	98		tya		found           TYA
.1a7bf7	38		sec		                SEC                     ; Set carry to show success
.1a7bf8	ab		plb		                PLB
.1a7bf9	2b		pld		                PLD
.1a7bfa	6b		rtl		                RTL
.1a7bfb	18		clc		not_found       CLC                     ; Clear carry to show failure
.1a7bfc	ab		plb		                PLB
.1a7bfd	2b		pld		                PLD
.1a7bfe	6b		rtl		                RTL
.1a7bff					AS_STR_MATCH
.1a7bff	08		php		                PHP
.1a7c00	0b		phd		                PHD
.1a7c01	08		php		            PHP
.1a7c02	c2 20		rep #$20	            REP #$20
.1a7c04	48		pha		            PHA
.1a7c05	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7c08	5b		tcd		            TCD
.1a7c09	68		pla		            PLA
.1a7c0a	28		plp		            PLP
.1a7c0b	e2 20		sep #$20	            SEP #$20
.1a7c0d	c2 10		rep #$10	            REP #$10
.1a7c0f	a0 00 00	ldy #$0000	                LDY #0
.1a7c12	64 50		stz $0898	                STZ MPARSEDNUM      ; Set parsed number to 0 in anticipation of
.1a7c14	64 52		stz $089a	                STZ MPARSEDNUM+2    ; hex digits in the pattern
.1a7c16	b7 03		lda [$084b],y	match_loop      LDA [MCMP_TEXT],Y   ; Get the pattern character
.1a7c18	f0 11		beq $1a7c2b	                BEQ nul_check       ; If at end of pattern, check for end of test string
.1a7c1a	c9 64		cmp #$64	                CMP #'d'            ; Is it a digit?
.1a7c1c	f0 19		beq $1a7c37	                BEQ check_digit     ; Yes: do special check for hex digit
.1a7c1e	48		pha		compare         PHA
.1a7c1f	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.1a7c21	85 4a		sta $0892	                STA MTEMP
.1a7c23	68		pla		                PLA
.1a7c24	c5 4a		cmp $0892	                CMP MTEMP           ; Does it match the character to test?
.1a7c26	d0 0b		bne $1a7c33	                BNE return_false    ; No: return fail
.1a7c28	c8		iny		next_char       INY                 ; Yes: test the next character
.1a7c29	80 eb		bra $1a7c16	                BRA match_loop
.1a7c2b	b7 36		lda [$087e],y	nul_check       LDA [MLINEBUF],Y    ; Check to see that we're at the end of the test string
.1a7c2d	d0 04		bne $1a7c33	                BNE return_false    ; If not: return false
.1a7c2f	2b		pld		return_true     PLD
.1a7c30	28		plp		                PLP                 ; Return true
.1a7c31	38		sec		                SEC
.1a7c32	6b		rtl		                RTL
.1a7c33	2b		pld		return_false    PLD
.1a7c34	28		plp		                PLP                 ; Return false
.1a7c35	18		clc		                CLC
.1a7c36	6b		rtl		                RTL
.1a7c37					check_digit
.1a7c37	e2 20		sep #$20	            SEP #$20
.1a7c39	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.1a7c3b	c9 3a		cmp #$3a	                CMP #'9'+1
.1a7c3d	b0 04		bcs $1a7c43	                BCS check_AF
.1a7c3f	c9 30		cmp #$30	                CMP #'0'
.1a7c41	b0 14		bcs $1a7c57	                BCS shift_digit     ; character is in [0..9]
.1a7c43	c9 47		cmp #$47	check_AF        CMP #'F'+1
.1a7c45	b0 04		bcs $1a7c4b	                BCS check_lc        ; check lower case
.1a7c47	c9 41		cmp #$41	                CMP #'A'
.1a7c49	b0 0c		bcs $1a7c57	                BCS shift_digit     ; character is in [A..F]
.1a7c4b	c9 67		cmp #$67	check_lc        CMP #'f'+1
.1a7c4d	b0 e4		bcs $1a7c33	                BCS return_false    ; check lower case
.1a7c4f	c9 61		cmp #$61	                CMP #'a'
.1a7c51	b0 02		bcs $1a7c55	                BCS to_upcase       ; character is in [A..F]
.1a7c53	80 de		bra $1a7c33	                BRA return_false    ; No match found... return false
.1a7c55	29 df		and #$df	to_upcase       AND #%11011111      ; Convert lower case to upper case
.1a7c57	22 76 7b 1a	jsl $1a7b76	shift_digit     JSL AS_SHIFT_HEX    ; Shift the digit into MPARSEDNUM
.1a7c5b	80 cb		bra $1a7c28	                BRA next_char       ; And check the next character
.1a7c5d					AS_MCMP_NEXT
.1a7c5d	0b		phd		                PHD
.1a7c5e	08		php		            PHP
.1a7c5f	c2 20		rep #$20	            REP #$20
.1a7c61	48		pha		            PHA
.1a7c62	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7c65	5b		tcd		            TCD
.1a7c66	68		pla		            PLA
.1a7c67	28		plp		            PLP
.1a7c68	a0 00 00	ldy #$0000	                LDY #0
.1a7c6b	e2 20		sep #$20	            SEP #$20
.1a7c6d	b7 03		lda [$084b],y	loop            LDA [MCMP_TEXT],Y   ; Check to see if we have gotten to the NUL
.1a7c6f	f0 03		beq $1a7c74	                BEQ found_nul
.1a7c71	c8		iny		                INY
.1a7c72	80 f9		bra $1a7c6d	                BRA loop
.1a7c74					found_nul
.1a7c74	c2 20		rep #$20	            REP #$20
.1a7c76	c8		iny		                INY                 ; Got to NUL... point to next byte
.1a7c77	5a		phy		                PHY
.1a7c78	68		pla		                PLA                 ; And add that index to MCMP_TEXT pointer
.1a7c79	18		clc		                CLC
.1a7c7a	65 03		adc $084b	                ADC MCMP_TEXT
.1a7c7c	85 03		sta $084b	                STA MCMP_TEXT
.1a7c7e	a5 05		lda $084d	                LDA MCMP_TEXT+2
.1a7c80	69 00 00	adc #$0000	                ADC #0
.1a7c83	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7c85	2b		pld		                PLD
.1a7c86	6b		rtl		                RTL
.1a7c87					AS_FIND_MNEMO
.1a7c87	0b		phd		                PHD
.1a7c88	08		php		            PHP
.1a7c89	c2 20		rep #$20	            REP #$20
.1a7c8b	48		pha		            PHA
.1a7c8c	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7c8f	5b		tcd		            TCD
.1a7c90	68		pla		            PLA
.1a7c91	28		plp		            PLP
.1a7c92	c2 20		rep #$20	            REP #$20
.1a7c94	a5 11		lda $0859	                LDA MARG2                   ; Point MLINEBUF to the text
.1a7c96	85 36		sta $087e	                STA MLINEBUF
.1a7c98	a5 13		lda $085b	                LDA MARG2+2
.1a7c9a	85 38		sta $0880	                STA MLINEBUF+2
.1a7c9c	a9 10 81	lda #$8110	                LDA #<>MNEMONICS_TAB        ; Point to the first mnemonic
.1a7c9f	85 03		sta $084b	                STA MCMP_TEXT
.1a7ca1	a9 1a 00	lda #$001a	                LDA #`MNEMONICS_TAB
.1a7ca4	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7ca6	22 ff 7b 1a	jsl $1a7bff	match_loop      JSL AS_STR_MATCH            ; Check to see if the text matches the mnemonic
.1a7caa	b0 0d		bcs $1a7cb9	                BCS found_mnemonic          ; If so: return that we found it
.1a7cac	22 5d 7c 1a	jsl $1a7c5d	                JSL AS_MCMP_NEXT            ; Point to the next mnemonic
.1a7cb0	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Check to see if it's NUL
.1a7cb2	d0 f2		bne $1a7ca6	                BNE match_loop              ; If not, check this next mnemonic
.1a7cb4	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Otherwise, return -1
.1a7cb7	80 02		bra $1a7cbb	                BRA done
.1a7cb9	a5 03		lda $084b	found_mnemonic  LDA MCMP_TEXT               ; Found it: return the address
.1a7cbb	2b		pld		done            PLD
.1a7cbc	6b		rtl		                RTL
.1a7cbd					AS_FIND_MODE
.1a7cbd	08		php		                PHP
.1a7cbe	0b		phd		                PHD
.1a7cbf	08		php		            PHP
.1a7cc0	c2 20		rep #$20	            REP #$20
.1a7cc2	48		pha		            PHA
.1a7cc3	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7cc6	5b		tcd		            TCD
.1a7cc7	68		pla		            PLA
.1a7cc8	28		plp		            PLP
.1a7cc9	c2 30		rep #$30	            REP #$30
.1a7ccb	a5 15		lda $085d	                LDA MARG3                   ; Point MLINEBUF to the operand
.1a7ccd	85 36		sta $087e	                STA MLINEBUF
.1a7ccf	a5 17		lda $085f	                LDA MARG3+2
.1a7cd1	85 38		sta $0880	                STA MLINEBUF+2
.1a7cd3	a9 9c 85	lda #$859c	                LDA #<>ADDR_PATTERNS        ; Point to the first address mode pattern to check
.1a7cd6	85 03		sta $084b	                STA MCMP_TEXT
.1a7cd8	a9 1a 00	lda #$001a	                LDA #`ADDR_PATTERNS
.1a7cdb	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7cdd	22 ff 7b 1a	jsl $1a7bff	match_loop      JSL AS_STR_MATCH            ; Check to see if the pattern matches the operand
.1a7ce1	b0 22		bcs $1a7d05	                BCS is_match                ; Yes: Find address mode code
.1a7ce3	22 5d 7c 1a	jsl $1a7c5d	                JSL AS_MCMP_NEXT            ; Point to the address mode
.1a7ce7	c2 20		rep #$20	            REP #$20
.1a7ce9	18		clc		                CLC                         ; Point to the first byte of the next pattern
.1a7cea	a5 03		lda $084b	                LDA MCMP_TEXT
.1a7cec	69 01 00	adc #$0001	                ADC #1
.1a7cef	85 03		sta $084b	                STA MCMP_TEXT
.1a7cf1	a5 05		lda $084d	                LDA MCMP_TEXT+2
.1a7cf3	69 00 00	adc #$0000	                ADC #0
.1a7cf6	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7cf8	e2 20		sep #$20	            SEP #$20
.1a7cfa	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Is the first byte 0?
.1a7cfc	d0 df		bne $1a7cdd	                BNE match_loop              ; No: check this next pattern
.1a7cfe	c2 20		rep #$20	            REP #$20
.1a7d00	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Yes: we didn't find a matching pattern, return -1
.1a7d03	80 0d		bra $1a7d12	                BRA done
.1a7d05	22 5d 7c 1a	jsl $1a7c5d	is_match        JSL AS_MCMP_NEXT            ; Point to the address mode
.1a7d09	e2 20		sep #$20	            SEP #$20
.1a7d0b	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Get the corresponding address mode code (a byte)
.1a7d0d	c2 20		rep #$20	            REP #$20
.1a7d0f	29 ff 00	and #$00ff	                AND #$00FF
.1a7d12	2b		pld		done            PLD
.1a7d13	28		plp		                PLP
.1a7d14	6b		rtl		                RTL
.1a7d15					IMDISASSEMBLE
.1a7d15	08		php		                PHP
.1a7d16	8b		phb		                PHB
.1a7d17	0b		phd		                PHD
.1a7d18	08		php		            PHP
.1a7d19	c2 20		rep #$20	            REP #$20
.1a7d1b	48		pha		            PHA
.1a7d1c	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7d1f	5b		tcd		            TCD
.1a7d20	68		pla		            PLA
.1a7d21	28		plp		            PLP
.1a7d22	e2 20		sep #$20	            SEP #$20
.1a7d24	a9 00		lda #$00	                LDA #0
.1a7d26	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT     ; Clear the pagination line counter
.1a7d2a	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.1a7d2c	c9 02		cmp #$02	                CMP #2
.1a7d2e	b0 16		bcs $1a7d46	                BGE set_cursor      ; 2>= arguments? Use them as-is
.1a7d30	c9 01		cmp #$01	                CMP #1
.1a7d32	90 20		bcc $1a7d54	                BLT no_args         ; No arguments passed? Use defaults
.1a7d34	c2 20		rep #$20	            REP #$20
.1a7d36	18		clc		                CLC
.1a7d37	a5 0d		lda $0855	                LDA MARG1
.1a7d39	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a7d3c	85 11		sta $0859	                STA MARG2
.1a7d3e	e2 20		sep #$20	            SEP #$20
.1a7d40	a5 0f		lda $0857	                LDA MARG1+2
.1a7d42	69 00		adc #$00	                ADC #0
.1a7d44	85 13		sta $085b	                STA MARG2+2
.1a7d46					set_cursor
.1a7d46	c2 20		rep #$20	            REP #$20
.1a7d48	a5 0d		lda $0855	                LDA MARG1
.1a7d4a	85 32		sta $087a	                STA MCURSOR
.1a7d4c	e2 20		sep #$20	            SEP #$20
.1a7d4e	a5 0f		lda $0857	                LDA MARG1+2
.1a7d50	85 34		sta $087c	                STA MCURSOR+2
.1a7d52	80 12		bra $1a7d66	                BRA dasm_loop
.1a7d54					no_args
.1a7d54	c2 20		rep #$20	            REP #$20
.1a7d56	18		clc		                CLC
.1a7d57	a5 32		lda $087a	                LDA MCURSOR
.1a7d59	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a7d5c	85 11		sta $0859	                STA MARG2
.1a7d5e	e2 20		sep #$20	            SEP #$20
.1a7d60	a5 34		lda $087c	                LDA MCURSOR+2
.1a7d62	69 00		adc #$00	                ADC #0
.1a7d64	85 13		sta $085b	                STA MARG2+2
.1a7d66	22 81 7d 1a	jsl $1a7d81	dasm_loop       JSL DS_PR_LINE
.1a7d6a	e2 20		sep #$20	            SEP #$20
.1a7d6c	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.1a7d6e	c5 13		cmp $085b	                CMP MARG2+2
.1a7d70	90 f4		bcc $1a7d66	                BLT dasm_loop           ; No: continue
.1a7d72	c2 20		rep #$20	            REP #$20
.1a7d74	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.1a7d76	c5 11		cmp $0859	                CMP MARG2
.1a7d78	90 ec		bcc $1a7d66	                BLT dasm_loop           ; Nope... keep going
.1a7d7a					done
.1a7d7a	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a7d7d	2b		pld		                PLD
.1a7d7e	ab		plb		                PLB
.1a7d7f	28		plp		                PLP
.1a7d80	6b		rtl		                RTL
.1a7d81					DS_PR_LINE
.1a7d81	08		php		                PHP
.1a7d82	0b		phd		                PHD
.1a7d83	e2 20		sep #$20	            SEP #$20
.1a7d85	a9 41		lda #$41	                LDA #'A'
.1a7d87	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d8a	a9 20		lda #$20	                LDA #' '
.1a7d8c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d8f	08		php		            PHP
.1a7d90	c2 20		rep #$20	            REP #$20
.1a7d92	48		pha		            PHA
.1a7d93	a9 7a 08	lda #$087a	            LDA #MCURSOR
.1a7d96	5b		tcd		            TCD
.1a7d97	68		pla		            PLA
.1a7d98	28		plp		            PLP
.1a7d99	c2 20		rep #$20	            REP #$20
.1a7d9b	a5 00		lda $087a	                LDA MCURSOR
.1a7d9d	85 18		sta $0892	                STA MTEMP
.1a7d9f	e2 20		sep #$20	            SEP #$20
.1a7da1	a5 02		lda $087c	                LDA MCURSOR+2
.1a7da3	85 1a		sta $0894	                STA MTEMP+2
.1a7da5	22 e8 80 1a	jsl $1a80e8	                JSL M_PR_ADDR
.1a7da9	a9 20		lda #$20	                LDA #' '
.1a7dab	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7dae	c2 20		rep #$20	            REP #$20
.1a7db0	18		clc		                CLC
.1a7db1	a5 00		lda $087a	                LDA MCURSOR
.1a7db3	69 01 00	adc #$0001	                ADC #1
.1a7db6	85 18		sta $0892	                STA MTEMP
.1a7db8	e2 20		sep #$20	            SEP #$20
.1a7dba	a5 02		lda $087c	                LDA MCURSOR+2
.1a7dbc	69 00		adc #$00	                ADC #0
.1a7dbe	85 1a		sta $0894	                STA MTEMP+2
.1a7dc0	e2 20		sep #$20	            SEP #$20
.1a7dc2	c2 10		rep #$10	            REP #$10
.1a7dc4	a7 00		lda [$087a]	                LDA [MCURSOR]           ; Get the mnemonic
.1a7dc6	c9 c2		cmp #$c2	                CMP #$C2                ; Is it REP?
.1a7dc8	d0 0b		bne $1a7dd5	                BNE check_sep           ; No: check to see if it is SEP
.1a7dca	48		pha		handle_rep      PHA
.1a7dcb	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.1a7dcd	49 ff		eor #$ff	                EOR #$FF                ; Invert the bits
.1a7dcf	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Mask off the bits in the CPUSTAT
.1a7dd3	80 0b		bra $1a7de0	                BRA save_stat
.1a7dd5	c9 e2		cmp #$e2	check_sep       CMP #$E2                ; Is it SEP?
.1a7dd7	d0 0c		bne $1a7de5	                BNE get_op_index        ; No: process the instruction regularly
.1a7dd9	48		pha		handle_sep      PHA
.1a7dda	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.1a7ddc	0f 96 08 00	ora $000896	                ORA @lMCPUSTAT          ; Activate the bits in the CPUSTAT
.1a7de0	8f 96 08 00	sta $000896	save_stat       STA @lMCPUSTAT          ; And save it back
.1a7de4	68		pla		                PLA
.1a7de5					get_op_index
.1a7de5	c2 20		rep #$20	            REP #$20
.1a7de7	29 ff 00	and #$00ff	                AND #$00FF
.1a7dea	0a		asl a		                ASL A
.1a7deb	aa		tax		                TAX                     ; Get the index into the mnemonic lookup table
.1a7dec	bf 82 82 1a	lda $1a8282,x	                LDA @lMNEMONIC_TAB,X    ; Get the mnemonic
.1a7df0	aa		tax		                TAX
.1a7df1	22 62 80 1a	jsl $1a8062	                JSL DS_PR_MNEMONIC      ; And print it
.1a7df5	e2 20		sep #$20	            SEP #$20
.1a7df7	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a7df9	aa		tax		                TAX
.1a7dfa	bf 84 84 1a	lda $1a8484,x	pr_operand      LDA @lADDRESS_TAB,X     ; Get the addressing mode for the instruction
.1a7dfe	22 3e 86 1a	jsl $1a863e	                JSL M_INC_CURSOR        ; Advance the cursor to the next byte
.1a7e02	22 0f 7e 1a	jsl $1a7e0f	                JSL DS_PR_OPERAND       ; And print the correct operand
.1a7e06	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a7e09	20 b3 03	jsr $1a03b3	            JSR PAGINATE
.1a7e0c	2b		pld		                PLD
.1a7e0d	28		plp		                PLP
.1a7e0e	6b		rtl		                RTL
.1a7e0f					DS_PR_OPERAND
.1a7e0f	08		php		                PHP
.1a7e10	e2 20		sep #$20	            SEP #$20
.1a7e12	48		pha		                PHA             ; Save the address mode so we can get to the M and X flags
.1a7e13	29 3f		and #$3f	                AND #%00111111  ; Filter out the mode flags
.1a7e15	0a		asl a		                ASL A           ; Compute the index to the table
.1a7e16	c2 10		rep #$10	            REP #$10
.1a7e18	aa		tax		                TAX
.1a7e19	68		pla		                PLA             ; Restore A
.1a7e1a	7c 1d 7e	jmp ($1a7e1d,x)	                JMP (dispatch,X)
>1a7e1d	4d 7e				dispatch        .word <>is_dp_ind_x
>1a7e1f	68 7e				                .word <>is_dp
>1a7e21	6f 7e				                .word <>is_imm
>1a7e23	94 7e				                .word <>is_abs
>1a7e25	9b 7e				                .word <>is_dp_ind_y
>1a7e27	b6 7e				                .word <>is_dp_x
>1a7e29	d8 7e				                .word <>is_abs_y
>1a7e2b	e9 7e				                .word <>is_abs_x
>1a7e2d	26 7f				                .word <>is_accumulator
>1a7e2f	2e 7f				                .word <>is_stack_r
>1a7e31	3f 7f				                .word <>is_dp_long
>1a7e33	50 7f				                .word <>is_abs_long
>1a7e35	57 7f				                .word <>is_stack_r_y
>1a7e37	7c 7f				                .word <>is_dp_y_long
>1a7e39	a9 7f				                .word <>is_abs_x_long
>1a7e3b	15 7f				                .word <>is_dp_ind
>1a7e3d	fa 7e				                .word <>is_abs_x_id
>1a7e3f	c7 7e				                .word <>is_dp_y
>1a7e41	9c 7f				                .word <>is_pc_rel
>1a7e43	a6 7f				                .word <>is_implied
>1a7e45	ba 7f				                .word <>is_xyc
>1a7e47	e9 7f				                .word <>is_abs_ind
>1a7e49	97 7f				                .word <>is_pc_rel_long
>1a7e4b	fa 7f				                .word <>is_abs_ind_long
.1a7e4d	a9 28		lda #$28	is_dp_ind_x     LDA #'('                ; Print (dd,X)
.1a7e4f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e52	22 11 80 1a	jsl $1a8011	                JSL DS_PR_OPERAND1      ; Print dd
.1a7e56	a9 2c		lda #$2c	                LDA #','
.1a7e58	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e5b	a9 58		lda #$58	                LDA #'X'
.1a7e5d	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e60	a9 29		lda #$29	                LDA #')'
.1a7e62	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e65	4c 0b 80	jmp $1a800b	                JMP done_1
.1a7e68	22 11 80 1a	jsl $1a8011	is_dp           JSL DS_PR_OPERAND1      ; Print dd
.1a7e6c	4c 0b 80	jmp $1a800b	                JMP done_1
.1a7e6f					is_imm
.1a7e6f	e2 20		sep #$20	            SEP #$20
.1a7e71	48		pha		                PHA
.1a7e72	a9 23		lda #$23	                LDA #'#'
.1a7e74	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e77	68		pla		                PLA
.1a7e78	29 c0		and #$c0	                AND #%11000000          ; Filter so we just look at the mode bits
.1a7e7a	c9 00		cmp #$00	                CMP #$00                ; Are any set to check?
.1a7e7c	f0 0f		beq $1a7e8d	                BEQ is_imm_short        ; No: treat it as a short always
.1a7e7e	4a		lsr a		                LSR A                   ; Move the flag bits right by 2 to match
.1a7e7f	4a		lsr a		                LSR A                   ; the positions of the bits in the CPU status register
.1a7e80	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Otherwise, filter the mode bit we care about
.1a7e84	d0 07		bne $1a7e8d	                BNE is_imm_short        ; If it is set, immediate operation is short
.1a7e86	22 1b 80 1a	jsl $1a801b	                JSL DS_PR_OPERAND2      ; Print dddd
.1a7e8a	4c 0b 80	jmp $1a800b	                JMP done_1
.1a7e8d	22 11 80 1a	jsl $1a8011	is_imm_short    JSL DS_PR_OPERAND1      ; Print dd
.1a7e91	4c 0b 80	jmp $1a800b	                JMP done_1
.1a7e94	22 1b 80 1a	jsl $1a801b	is_abs          JSL DS_PR_OPERAND2      ; Print dddd
.1a7e98	4c 0b 80	jmp $1a800b	                JMP done_1
.1a7e9b	a9 28		lda #$28	is_dp_ind_y     LDA #'('                ; Print (dd),Y
.1a7e9d	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ea0	22 11 80 1a	jsl $1a8011	                JSL DS_PR_OPERAND1      ; Print dd
.1a7ea4	a9 29		lda #$29	                LDA #')'
.1a7ea6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ea9	a9 2c		lda #$2c	                LDA #','
.1a7eab	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7eae	a9 59		lda #$59	                LDA #'Y'
.1a7eb0	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7eb3	4c 0b 80	jmp $1a800b	                JMP done_1
.1a7eb6	22 11 80 1a	jsl $1a8011	is_dp_x         JSL DS_PR_OPERAND1      ; Print dd,X
.1a7eba	a9 2c		lda #$2c	                LDA #','
.1a7ebc	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ebf	a9 58		lda #$58	                LDA #'X'
.1a7ec1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ec4	4c 0b 80	jmp $1a800b	                JMP done_1
.1a7ec7	22 11 80 1a	jsl $1a8011	is_dp_y         JSL DS_PR_OPERAND1      ; Print dd,Y
.1a7ecb	a9 2c		lda #$2c	                LDA #','
.1a7ecd	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ed0	a9 59		lda #$59	                LDA #'Y'
.1a7ed2	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ed5	4c 0b 80	jmp $1a800b	                JMP done_1
.1a7ed8	22 1b 80 1a	jsl $1a801b	is_abs_y        JSL DS_PR_OPERAND2      ; Print dddd,Y
.1a7edc	a9 2c		lda #$2c	                LDA #','
.1a7ede	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ee1	a9 59		lda #$59	                LDA #'Y'
.1a7ee3	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ee6	4c 0b 80	jmp $1a800b	                JMP done_1
.1a7ee9	22 1b 80 1a	jsl $1a801b	is_abs_x        JSL DS_PR_OPERAND2      ; Print dddd,X
.1a7eed	a9 2c		lda #$2c	                LDA #','
.1a7eef	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ef2	a9 58		lda #$58	                LDA #'X'
.1a7ef4	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ef7	4c 0b 80	jmp $1a800b	                JMP done_1
.1a7efa	a9 28		lda #$28	is_abs_x_id     LDA #'('
.1a7efc	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7eff	22 1b 80 1a	jsl $1a801b	                JSL DS_PR_OPERAND2      ; Print (dddd,X)
.1a7f03	a9 2c		lda #$2c	                LDA #','
.1a7f05	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f08	a9 58		lda #$58	                LDA #'X'
.1a7f0a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f0d	a9 29		lda #$29	                LDA #')'
.1a7f0f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f12	4c 0b 80	jmp $1a800b	                JMP done_1
.1a7f15	a9 28		lda #$28	is_dp_ind       LDA #'('
.1a7f17	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f1a	22 11 80 1a	jsl $1a8011	                JSL DS_PR_OPERAND1      ; Print (dd)
.1a7f1e	a9 29		lda #$29	                LDA #')'
.1a7f20	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f23	4c 0b 80	jmp $1a800b	                JMP done_1
.1a7f26	a9 41		lda #$41	is_accumulator  LDA #'A'                ; Print A
.1a7f28	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f2b	4c 0f 80	jmp $1a800f	                JMP done
.1a7f2e	22 11 80 1a	jsl $1a8011	is_stack_r      JSL DS_PR_OPERAND1      ; Print dd,S
.1a7f32	a9 2c		lda #$2c	                LDA #','
.1a7f34	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f37	a9 53		lda #$53	                LDA #'S'
.1a7f39	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f3c	4c 0b 80	jmp $1a800b	                JMP done_1
.1a7f3f	a9 5b		lda #$5b	is_dp_long      LDA #'['                ; [dd]
.1a7f41	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f44	22 11 80 1a	jsl $1a8011	                JSL DS_PR_OPERAND1      ; Print dd
.1a7f48	a9 5d		lda #$5d	                LDA #']'
.1a7f4a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f4d	4c 0b 80	jmp $1a800b	                JMP done_1
.1a7f50	22 29 80 1a	jsl $1a8029	is_abs_long     JSL DS_PR_OPERAND3      ; Print dddddd
.1a7f54	4c 0f 80	jmp $1a800f	                JMP done
.1a7f57	a9 28		lda #$28	is_stack_r_y    LDA #'('                ; (dd,S),Y
.1a7f59	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f5c	22 11 80 1a	jsl $1a8011	                JSL DS_PR_OPERAND1      ; Print dd
.1a7f60	a9 2c		lda #$2c	                LDA #','
.1a7f62	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f65	a9 53		lda #$53	                LDA #'S'
.1a7f67	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f6a	a9 29		lda #$29	                LDA #')'
.1a7f6c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f6f	a9 2c		lda #$2c	                LDA #','
.1a7f71	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f74	a9 59		lda #$59	                LDA #'Y'
.1a7f76	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f79	4c 0b 80	jmp $1a800b	                JMP done_1
.1a7f7c	a9 5b		lda #$5b	is_dp_y_long    LDA #'['                ; [dd],Y
.1a7f7e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f81	22 11 80 1a	jsl $1a8011	                JSL DS_PR_OPERAND1      ; Print dd
.1a7f85	a9 5d		lda #$5d	                LDA #']'
.1a7f87	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f8a	a9 2c		lda #$2c	                LDA #','
.1a7f8c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f8f	a9 59		lda #$59	                LDA #'Y'
.1a7f91	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f94	4c 0b 80	jmp $1a800b	                JMP done_1
.1a7f97	a0 02 00	ldy #$0002	is_pc_rel_long  LDY #2
.1a7f9a	80 03		bra $1a7f9f	                BRA do_pcrel
.1a7f9c	a0 01 00	ldy #$0001	is_pc_rel       LDY #1
.1a7f9f	22 8f 80 1a	jsl $1a808f	do_pcrel        JSL DS_PR_PCREL
.1a7fa3	4c 0f 80	jmp $1a800f	                JMP done
.1a7fa6	4c 0f 80	jmp $1a800f	is_implied      JMP done
.1a7fa9	22 29 80 1a	jsl $1a8029	is_abs_x_long   JSL DS_PR_OPERAND3      ; Print dddddd
.1a7fad	a9 2c		lda #$2c	                LDA #','
.1a7faf	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fb2	a9 58		lda #$58	                LDA #'X'
.1a7fb4	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fb7	4c 0f 80	jmp $1a800f	                JMP done
.1a7fba	a9 23		lda #$23	is_xyc          LDA #'#'
.1a7fbc	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fbf	8b		phb		                PHB                     ; Make sure the databank is pointed to our number
.1a7fc0	a5 02		lda $087c	                LDA MCURSOR+2
.1a7fc2	48		pha		                PHA
.1a7fc3	ab		plb		                PLB
.1a7fc4	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.1a7fc6	e8		inx		                INX
.1a7fc7	a0 01 00	ldy #$0001	                LDY #1
.1a7fca	22 ac 03 1a	jsl $1a03ac	                JSL PRINTH
.1a7fce	a9 2c		lda #$2c	                LDA #','
.1a7fd0	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fd3	a9 23		lda #$23	                LDA #'#'
.1a7fd5	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fd8	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.1a7fda	a0 01 00	ldy #$0001	                LDY #1
.1a7fdd	22 ac 03 1a	jsl $1a03ac	                JSL PRINTH
.1a7fe1	ab		plb		                PLB                     ; Get our old data bank back
.1a7fe2	22 3e 86 1a	jsl $1a863e	                JSL M_INC_CURSOR
.1a7fe6	4c 0b 80	jmp $1a800b	                JMP done_1
.1a7fe9	a9 28		lda #$28	is_abs_ind      LDA #'('
.1a7feb	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fee	22 1b 80 1a	jsl $1a801b	                JSL DS_PR_OPERAND2      ; Print (dddd)
.1a7ff2	a9 29		lda #$29	                LDA #')'
.1a7ff4	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ff7	4c 0b 80	jmp $1a800b	                JMP done_1
.1a7ffa	a9 5b		lda #$5b	is_abs_ind_long LDA #'['
.1a7ffc	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fff	22 1b 80 1a	jsl $1a801b	                JSL DS_PR_OPERAND2      ; Print [dddd]
.1a8003	a9 5d		lda #$5d	                LDA #']'
.1a8005	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8008	4c 0b 80	jmp $1a800b	                JMP done_1
.1a800b	22 3e 86 1a	jsl $1a863e	done_1          JSL M_INC_CURSOR    ; Skip over a single byte operand
.1a800f	28		plp		done            PLP
.1a8010	6b		rtl		                RTL
.1a8011					DS_PR_OPERAND1
.1a8011	08		php		                PHP
.1a8012	e2 20		sep #$20	            SEP #$20
.1a8014	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a8016	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a8019	28		plp		                PLP
.1a801a	6b		rtl		                RTL
.1a801b					DS_PR_OPERAND2
.1a801b	08		php		                PHP
.1a801c	c2 30		rep #$30	            REP #$30
.1a801e	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a8020	20 39 04	jsr $1a0439	            JSR PRHEXW
.1a8023	22 3e 86 1a	jsl $1a863e	                JSL M_INC_CURSOR
.1a8027	28		plp		                PLP
.1a8028	6b		rtl		                RTL
.1a8029					DS_PR_OPERAND3
.1a8029	08		php		                PHP
.1a802a	8b		phb		                PHB
.1a802b	0b		phd		                PHD
.1a802c	c2 30		rep #$30	            REP #$30
.1a802e	5a		phy		                PHY
.1a802f	08		php		            PHP
.1a8030	c2 20		rep #$20	            REP #$20
.1a8032	48		pha		            PHA
.1a8033	a9 7a 08	lda #$087a	            LDA #MCURSOR
.1a8036	5b		tcd		            TCD
.1a8037	68		pla		            PLA
.1a8038	28		plp		            PLP
.1a8039	08		php		            PHP
.1a803a	e2 20		sep #$20	            SEP #$20
.1a803c	48		pha		            PHA
.1a803d	a9 00		lda #$00	            LDA #`MTEMP
.1a803f	48		pha		            PHA
.1a8040	ab		plb		            PLB
.1a8041	68		pla		            PLA
.1a8042	28		plp		            PLP
.1a8043	e2 20		sep #$20	            SEP #$20
.1a8045	a0 00 00	ldy #$0000	                LDY #0
.1a8048	a7 00		lda [$087a]	copy_loop       LDA [MCURSOR]       ; Copy the address pointed to by MCURSOR
.1a804a	99 92 08	sta $0892,y	                STA MTEMP,Y         ; to MTEMP
.1a804d	22 3e 86 1a	jsl $1a863e	                JSL M_INC_CURSOR
.1a8051	c8		iny		                INY
.1a8052	c0 03 00	cpy #$0003	                CPY #3
.1a8055	d0 f1		bne $1a8048	                BNE copy_loop
.1a8057	22 e8 80 1a	jsl $1a80e8	                JSL M_PR_ADDR       ; Print the address
.1a805b	c2 30		rep #$30	            REP #$30
.1a805d	7a		ply		                PLY
.1a805e	2b		pld		                PLD
.1a805f	ab		plb		                PLB
.1a8060	28		plp		                PLP
.1a8061	6b		rtl		                RTL
.1a8062					DS_PR_MNEMONIC
.1a8062	08		php		                PHP
.1a8063	8b		phb		                PHB
.1a8064	e2 20		sep #$20	            SEP #$20
.1a8066	c2 10		rep #$10	            REP #$10
.1a8068	08		php		            PHP
.1a8069	e2 20		sep #$20	            SEP #$20
.1a806b	48		pha		            PHA
.1a806c	a9 1a		lda #$1a	            LDA #`MN_ORA
.1a806e	48		pha		            PHA
.1a806f	ab		plb		            PLB
.1a8070	68		pla		            PLA
.1a8071	28		plp		            PLP
.1a8072	bd 00 00	lda $1a0000,x	                LDA #0,B,X
.1a8075	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8078	e8		inx		                INX
.1a8079	bd 00 00	lda $1a0000,x	                LDA #0,B,X
.1a807c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a807f	e8		inx		                INX
.1a8080	bd 00 00	lda $1a0000,x	                LDA #0,B,X
.1a8083	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8086	e8		inx		                INX
.1a8087	a9 20		lda #$20	                LDA #' '            ; Print a space
.1a8089	20 18 00	jsr $1a0018	            JSR PRINTC
.1a808c	ab		plb		                PLB
.1a808d	28		plp		                PLP
.1a808e	6b		rtl		                RTL
.1a808f					DS_PR_PCREL
.1a808f	08		php		                PHP
.1a8090	0b		phd		                PHD
.1a8091	08		php		            PHP
.1a8092	c2 20		rep #$20	            REP #$20
.1a8094	48		pha		            PHA
.1a8095	a9 7a 08	lda #$087a	            LDA #MCURSOR
.1a8098	5b		tcd		            TCD
.1a8099	68		pla		            PLA
.1a809a	28		plp		            PLP
.1a809b	e2 20		sep #$20	            SEP #$20
.1a809d	c0 02 00	cpy #$0002	                CPY #2
.1a80a0	f0 14		beq $1a80b6	                BEQ offset_2
.1a80a2	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a80a4	85 18		sta $0892	                STA MTEMP
.1a80a6	30 06		bmi $1a80ae	                BMI is_negative
.1a80a8	64 19		stz $0893	                STZ MTEMP+1
.1a80aa	64 1a		stz $0894	                STZ MTEMP+2
.1a80ac	80 1e		bra $1a80cc	                BRA add_offset
.1a80ae	a9 ff		lda #$ff	is_negative     LDA #$FF
.1a80b0	85 19		sta $0893	                STA MTEMP+1
.1a80b2	85 1a		sta $0894	                STA MTEMP+2
.1a80b4	80 16		bra $1a80cc	                BRA add_offset
.1a80b6	a7 00		lda [$087a]	offset_2        LDA [MCURSOR]
.1a80b8	85 18		sta $0892	                STA MTEMP
.1a80ba	22 3e 86 1a	jsl $1a863e	                JSL M_INC_CURSOR
.1a80be	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a80c0	85 19		sta $0893	                STA MTEMP+1
.1a80c2	30 04		bmi $1a80c8	                BMI is_negative2
.1a80c4	64 1a		stz $0894	                STZ MTEMP+2
.1a80c6	80 04		bra $1a80cc	                BRA add_offset
.1a80c8	a9 ff		lda #$ff	is_negative2    LDA #$FF
.1a80ca	85 1a		sta $0894	                STA MTEMP+2
.1a80cc					add_offset
.1a80cc	c2 20		rep #$20	            REP #$20
.1a80ce	38		sec		                SEC             ; Add 1 to the offset
.1a80cf	a5 00		lda $087a	                LDA MCURSOR
.1a80d1	65 18		adc $0892	                ADC MTEMP
.1a80d3	85 18		sta $0892	                STA MTEMP
.1a80d5	e2 20		sep #$20	            SEP #$20
.1a80d7	a5 02		lda $087c	                LDA MCURSOR+2
.1a80d9	65 1a		adc $0894	                ADC MTEMP+2
.1a80db	85 1a		sta $0894	                STA MTEMP+2
.1a80dd	22 e8 80 1a	jsl $1a80e8	                JSL M_PR_ADDR
.1a80e1	22 3e 86 1a	jsl $1a863e	                JSL M_INC_CURSOR
.1a80e5	2b		pld		                PLD
.1a80e6	28		plp		                PLP
.1a80e7	6b		rtl		                RTL
.1a80e8					M_PR_ADDR
.1a80e8	08		php		                PHP
.1a80e9	0b		phd		                PHD
.1a80ea	c2 20		rep #$20	            REP #$20
.1a80ec	48		pha		                PHA
.1a80ed	08		php		            PHP
.1a80ee	c2 20		rep #$20	            REP #$20
.1a80f0	48		pha		            PHA
.1a80f1	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a80f4	5b		tcd		            TCD
.1a80f5	68		pla		            PLA
.1a80f6	28		plp		            PLP
.1a80f7	e2 20		sep #$20	            SEP #$20
.1a80f9	a5 4c		lda $0894	                LDA MTEMP+2     ; Print the bank byte of the address
.1a80fb	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a80fe	e2 20		sep #$20	            SEP #$20
.1a8100	a9 3a		lda #$3a	                LDA #':'
.1a8102	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8105	c2 20		rep #$20	            REP #$20
.1a8107	a5 4a		lda $0892	                LDA MTEMP       ; Print the lower 16-bits of the address
.1a8109	20 39 04	jsr $1a0439	            JSR PRHEXW
.1a810c	68		pla		                PLA
.1a810d	2b		pld		                PLD
.1a810e	28		plp		                PLP
.1a810f	6b		rtl		                RTL
.1a8110					MNEMONICS_TAB
.1a8110					MN_ORA
>1a8110	4f 52 41 00			            .null "ORA"
.1a8114					MN_AND
>1a8114	41 4e 44 00			            .null "AND"
.1a8118					MN_EOR
>1a8118	45 4f 52 00			            .null "EOR"
.1a811c					MN_ADC
>1a811c	41 44 43 00			            .null "ADC"
.1a8120					MN_STA
>1a8120	53 54 41 00			            .null "STA"
.1a8124					MN_LDA
>1a8124	4c 44 41 00			            .null "LDA"
.1a8128					MN_CMP
>1a8128	43 4d 50 00			            .null "CMP"
.1a812c					MN_SBC
>1a812c	53 42 43 00			            .null "SBC"
.1a8130					MN_ASL
>1a8130	41 53 4c 00			            .null "ASL"
.1a8134					MN_ROL
>1a8134	52 4f 4c 00			            .null "ROL"
.1a8138					MN_LSR
>1a8138	4c 53 52 00			            .null "LSR"
.1a813c					MN_ROR
>1a813c	52 4f 52 00			            .null "ROR"
.1a8140					MN_STX
>1a8140	53 54 58 00			            .null "STX"
.1a8144					MN_LDX
>1a8144	4c 44 58 00			            .null "LDX"
.1a8148					MN_DEC
>1a8148	44 45 43 00			            .null "DEC"
.1a814c					MN_INC
>1a814c	49 4e 43 00			            .null "INC"
.1a8150					MN_BIT
>1a8150	42 49 54 00			            .null "BIT"
.1a8154					MN_JMP
>1a8154	4a 4d 50 00			            .null "JMP"
.1a8158					MN_STY
>1a8158	53 54 59 00			            .null "STY"
.1a815c					MN_LDY
>1a815c	4c 44 59 00			            .null "LDY"
.1a8160					MN_CPY
>1a8160	43 50 59 00			            .null "CPY"
.1a8164					MN_CPX
>1a8164	43 50 58 00			            .null "CPX"
.1a8168					MN_BRK
>1a8168	42 52 4b 00			            .null "BRK"
.1a816c					MN_JSR
>1a816c	4a 53 52 00			            .null "JSR"
.1a8170					MN_RTI
>1a8170	52 54 49 00			            .null "RTI"
.1a8174					MN_RTS
>1a8174	52 54 53 00			            .null "RTS"
.1a8178					MN_PHP
>1a8178	50 48 50 00			            .null "PHP"
.1a817c					MN_PLP
>1a817c	50 4c 50 00			            .null "PLP"
.1a8180					MN_PHA
>1a8180	50 48 41 00			            .null "PHA"
.1a8184					MN_PLA
>1a8184	50 4c 41 00			            .null "PLA"
.1a8188					MN_DEY
>1a8188	44 45 59 00			            .null "DEY"
.1a818c					MN_TAY
>1a818c	54 41 59 00			            .null "TAY"
.1a8190					MN_INY
>1a8190	49 4e 59 00			            .null "INY"
.1a8194					MN_INX
>1a8194	49 4e 58 00			            .null "INX"
.1a8198					MN_CLC
>1a8198	43 4c 43 00			            .null "CLC"
.1a819c					MN_SEC
>1a819c	53 45 43 00			            .null "SEC"
.1a81a0					MN_CLI
>1a81a0	43 4c 49 00			            .null "CLI"
.1a81a4					MN_SEI
>1a81a4	53 45 49 00			            .null "SEI"
.1a81a8					MN_TYA
>1a81a8	54 59 41 00			            .null "TYA"
.1a81ac					MN_CLV
>1a81ac	43 4c 56 00			            .null "CLV"
.1a81b0					MN_CLD
>1a81b0	43 4c 44 00			            .null "CLD"
.1a81b4					MN_SED
>1a81b4	53 45 44 00			            .null "SED"
.1a81b8					MN_TXA
>1a81b8	54 58 41 00			            .null "TXA"
.1a81bc					MN_TXS
>1a81bc	54 58 53 00			            .null "TXS"
.1a81c0					MN_TAX
>1a81c0	54 41 58 00			            .null "TAX"
.1a81c4					MN_TSX
>1a81c4	54 53 58 00			            .null "TSX"
.1a81c8					MN_DEX
>1a81c8	44 45 58 00			            .null "DEX"
.1a81cc					MN_NOP
>1a81cc	4e 4f 50 00			            .null "NOP"
.1a81d0					MN_BPL
>1a81d0	42 50 4c 00			            .null "BPL"
.1a81d4					MN_BMI
>1a81d4	42 4d 49 00			            .null "BMI"
.1a81d8					MN_BVC
>1a81d8	42 56 43 00			            .null "BVC"
.1a81dc					MN_BVS
>1a81dc	42 56 53 00			            .null "BVS"
.1a81e0					MN_BCC
>1a81e0	42 43 43 00			            .null "BCC"
.1a81e4					MN_BCS
>1a81e4	42 43 53 00			            .null "BCS"
.1a81e8					MN_BNE
>1a81e8	42 4e 45 00			            .null "BNE"
.1a81ec					MN_BEQ
>1a81ec	42 45 51 00			            .null "BEQ"
.1a81f0					MN_TSB
>1a81f0	54 53 42 00			            .null "TSB"
.1a81f4					MN_TRB
>1a81f4	54 52 42 00			            .null "TRB"
.1a81f8					MN_STZ
>1a81f8	53 54 5a 00			            .null "STZ"
.1a81fc					MN_BRA
>1a81fc	42 52 41 00			            .null "BRA"
.1a8200					MN_PHY
>1a8200	50 48 59 00			            .null "PHY"
.1a8204					MN_PLY
>1a8204	50 4c 59 00			            .null "PLY"
.1a8208					MN_PHX
>1a8208	50 48 58 00			            .null "PHX"
.1a820c					MN_PLX
>1a820c	50 4c 58 00			            .null "PLX"
.1a8210					MN_PHD
>1a8210	50 48 44 00			            .null "PHD"
.1a8214					MN_PLD
>1a8214	50 4c 44 00			            .null "PLD"
.1a8218					MN_PHK
>1a8218	50 48 4b 00			            .null "PHK"
.1a821c					MN_RTL
>1a821c	52 54 4c 00			            .null "RTL"
.1a8220					MN_PHB
>1a8220	50 48 42 00			            .null "PHB"
.1a8224					MN_PLB
>1a8224	50 4c 42 00			            .null "PLB"
.1a8228					MN_WAI
>1a8228	57 41 49 00			            .null "WAI"
.1a822c					MN_XBA
>1a822c	58 42 41 00			            .null "XBA"
.1a8230					MN_TCS
>1a8230	54 43 53 00			            .null "TCS"
.1a8234					MN_TSC
>1a8234	54 53 43 00			            .null "TSC"
.1a8238					MN_TCD
>1a8238	54 43 44 00			            .null "TCD"
.1a823c					MN_TDC
>1a823c	54 44 43 00			            .null "TDC"
.1a8240					MN_TXY
>1a8240	54 58 59 00			            .null "TXY"
.1a8244					MN_TYX
>1a8244	54 59 58 00			            .null "TYX"
.1a8248					MN_STP
>1a8248	53 54 50 00			            .null "STP"
.1a824c					MN_XCE
>1a824c	58 43 45 00			            .null "XCE"
.1a8250					MN_COP
>1a8250	43 4f 50 00			            .null "COP"
.1a8254					MN_JSL
>1a8254	4a 53 4c 00			            .null "JSL"
.1a8258					MN_WDM
>1a8258	57 44 4d 00			            .null "WDM"
.1a825c					MN_PER
>1a825c	50 45 52 00			            .null "PER"
.1a8260					MN_BRL
>1a8260	42 52 4c 00			            .null "BRL"
.1a8264					MN_REP
>1a8264	52 45 50 00			            .null "REP"
.1a8268					MN_SEP
>1a8268	53 45 50 00			            .null "SEP"
.1a826c					MN_MVP
>1a826c	4d 56 50 00			            .null "MVP"
.1a8270					MN_MVN
>1a8270	4d 56 4e 00			            .null "MVN"
.1a8274					MN_PEI
>1a8274	50 45 49 00			            .null "PEI"
.1a8278					MN_PEA
>1a8278	50 45 41 00			            .null "PEA"
.1a827c					MN_JML
>1a827c	4a 4d 4c 00			            .null "JML"
>1a8280	00 00				            .byte 0, 0
>1a8282	68 81 10 81 50 82 10 81		MNEMONIC_TAB    .word <>MN_BRK, <>MN_ORA, <>MN_COP, <>MN_ORA, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 0x
>1a828a	f0 81 10 81 30 81 10 81
>1a8292	78 81 10 81 30 81 10 82		                .word <>MN_PHP, <>MN_ORA, <>MN_ASL, <>MN_PHD, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>1a829a	f0 81 10 81 30 81 10 81
>1a82a2	d0 81 10 81 10 81 10 81		                .word <>MN_BPL, <>MN_ORA, <>MN_ORA, <>MN_ORA, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 1x
>1a82aa	f4 81 10 81 30 81 10 81
>1a82b2	98 81 10 81 4c 81 30 82		                .word <>MN_CLC, <>MN_ORA, <>MN_INC, <>MN_TCS, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>1a82ba	f4 81 10 81 30 81 10 81
>1a82c2	6c 81 14 81 54 82 14 81		                .word <>MN_JSR, <>MN_AND, <>MN_JSL, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 2x
>1a82ca	50 81 14 81 34 81 14 81
>1a82d2	7c 81 14 81 34 81 14 82		                .word <>MN_PLP, <>MN_AND, <>MN_ROL, <>MN_PLD, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>1a82da	50 81 14 81 34 81 14 81
>1a82e2	d4 81 14 81 14 81 14 81		                .word <>MN_BMI, <>MN_AND, <>MN_AND, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 3x
>1a82ea	50 81 14 81 34 81 14 81
>1a82f2	9c 81 14 81 48 81 34 82		                .word <>MN_SEC, <>MN_AND, <>MN_DEC, <>MN_TSC, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>1a82fa	50 81 14 81 34 81 14 81
>1a8302	70 81 18 81 58 82 18 81		                .word <>MN_RTI, <>MN_EOR, <>MN_WDM, <>MN_EOR, <>MN_MVP, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 4x
>1a830a	6c 82 18 81 38 81 18 81
>1a8312	80 81 18 81 38 81 18 82		                .word <>MN_PHA, <>MN_EOR, <>MN_LSR, <>MN_PHK, <>MN_JMP, <>MN_EOR, <>MN_LSR, <>MN_EOR
>1a831a	54 81 18 81 38 81 18 81
>1a8322	d8 81 18 81 18 81 18 81		                .word <>MN_BVC, <>MN_EOR, <>MN_EOR, <>MN_EOR, <>MN_MVN, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 5x
>1a832a	70 82 18 81 38 81 18 81
>1a8332	a0 81 18 81 00 82 38 82		                .word <>MN_CLI, <>MN_EOR, <>MN_PHY, <>MN_TCD, <>MN_JML, <>MN_EOR, <>MN_LSR, <>MN_EOR
>1a833a	7c 82 18 81 38 81 18 81
>1a8342	74 81 1c 81 5c 82 1c 81		                .word <>MN_RTS, <>MN_ADC, <>MN_PER, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 6x
>1a834a	f8 81 1c 81 3c 81 1c 81
>1a8352	84 81 1c 81 3c 81 1c 82		                .word <>MN_PLA, <>MN_ADC, <>MN_ROR, <>MN_RTL, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>1a835a	54 81 1c 81 3c 81 1c 81
>1a8362	dc 81 1c 81 1c 81 1c 81		                .word <>MN_BVS, <>MN_ADC, <>MN_ADC, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 7x
>1a836a	f8 81 1c 81 3c 81 1c 81
>1a8372	a4 81 1c 81 04 82 3c 82		                .word <>MN_SEI, <>MN_ADC, <>MN_PLY, <>MN_TDC, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>1a837a	54 81 1c 81 3c 81 1c 81
>1a8382	fc 81 20 81 60 82 20 81		                .word <>MN_BRA, <>MN_STA, <>MN_BRL, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 8x
>1a838a	58 81 20 81 40 81 20 81
>1a8392	88 81 50 81 b8 81 20 82		                .word <>MN_DEY, <>MN_BIT, <>MN_TXA, <>MN_PHB, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA
>1a839a	58 81 20 81 40 81 20 81
>1a83a2	e0 81 20 81 20 81 20 81		                .word <>MN_BCC, <>MN_STA, <>MN_STA, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 9x
>1a83aa	58 81 20 81 40 81 20 81
>1a83b2	a8 81 20 81 bc 81 40 82		                .word <>MN_TYA, <>MN_STA, <>MN_TXS, <>MN_TXY, <>MN_STZ, <>MN_STA, <>MN_STZ, <>MN_STA
>1a83ba	f8 81 20 81 f8 81 20 81
>1a83c2	5c 81 24 81 44 81 24 81		                .word <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Ax
>1a83ca	5c 81 24 81 44 81 24 81
>1a83d2	8c 81 24 81 c0 81 24 82		                .word <>MN_TAY, <>MN_LDA, <>MN_TAX, <>MN_PLB, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>1a83da	5c 81 24 81 44 81 24 81
>1a83e2	e4 81 24 81 24 81 24 81		                .word <>MN_BCS, <>MN_LDA, <>MN_LDA, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Bx
>1a83ea	5c 81 24 81 44 81 24 81
>1a83f2	ac 81 24 81 c4 81 44 82		                .word <>MN_CLV, <>MN_LDA, <>MN_TSX, <>MN_TYX, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>1a83fa	5c 81 24 81 44 81 24 81
>1a8402	60 81 28 81 64 82 28 81		                .word <>MN_CPY, <>MN_CMP, <>MN_REP, <>MN_CMP, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Cx
>1a840a	60 81 28 81 48 81 28 81
>1a8412	90 81 28 81 c8 81 28 82		                .word <>MN_INY, <>MN_CMP, <>MN_DEX, <>MN_WAI, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP
>1a841a	60 81 28 81 48 81 28 81
>1a8422	e8 81 28 81 28 81 28 81		                .word <>MN_BNE, <>MN_CMP, <>MN_CMP, <>MN_CMP, <>MN_PEI, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Dx
>1a842a	74 82 28 81 48 81 28 81
>1a8432	b0 81 28 81 08 82 48 82		                .word <>MN_CLD, <>MN_CMP, <>MN_PHX, <>MN_STP, <>MN_JML, <>MN_CMP, <>MN_DEC, <>MN_CMP
>1a843a	7c 82 28 81 48 81 28 81
>1a8442	64 81 2c 81 68 82 2c 81		                .word <>MN_CPX, <>MN_SBC, <>MN_SEP, <>MN_SBC, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Ex
>1a844a	64 81 2c 81 4c 81 2c 81
>1a8452	94 81 2c 81 cc 81 2c 82		                .word <>MN_INX, <>MN_SBC, <>MN_NOP, <>MN_XBA, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC
>1a845a	64 81 2c 81 4c 81 2c 81
>1a8462	ec 81 2c 81 2c 81 2c 81		                .word <>MN_BEQ, <>MN_SBC, <>MN_SBC, <>MN_SBC, <>MN_PEA, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Fx
>1a846a	78 82 2c 81 4c 81 2c 81
>1a8472	b4 81 2c 81 0c 82 4c 82		                .word <>MN_SED, <>MN_SBC, <>MN_PLX, <>MN_XCE, <>MN_JSR, <>MN_SBC, <>MN_INC, <>MN_SBC
>1a847a	6c 81 2c 81 4c 81 2c 81
>1a8482	00 00				                .word 0
>1a8484	13 00 02 09			ADDRESS_TAB     .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R                  ; 0x
>1a8488	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a848c	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a8490	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8494	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 1x
>1a8498	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a849c	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>1a84a0	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a84a4	03 00 0b 09			                .byte ADDR_ABS, ADDR_DP_IND_X, ADDR_ABS_LONG, ADDR_SP_R                 ; 2x
>1a84a8	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a84ac	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a84b0	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a84b4	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 3x
>1a84b8	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a84bc	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>1a84c0	07 07 07 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a84c4	13 00 13 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMPLIED, ADDR_SP_R              ; 4x
>1a84c8	14 01 01 0a			                .byte ADDR_XYC, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a84cc	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a84d0	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a84d4	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 5x
>1a84d8	14 05 05 0d			                .byte ADDR_XYC, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a84dc	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a84e0	0b 07 07 0b			                .byte ADDR_ABS_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_LONG
>1a84e4	13 00 16 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R          ; 6x
>1a84e8	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a84ec	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a84f0	15 03 03 0b			                .byte ADDR_ABS_IND, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a84f4	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 7x
>1a84f8	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a84fc	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a8500	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a8504	12 00 16 09			                .byte ADDR_PC_REL, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R           ; 8x
>1a8508	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a850c	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a8510	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8514	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 9x
>1a8518	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>1a851c	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a8520	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a8524	82 00 42 09			                .byte ADDR_IMM | OP_M_EFFECT, ADDR_DP_IND_X, ADDR_IMM | OP_X_EFFECT, ADDR_SP_R  ; Ax
>1a8528	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a852c	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a8530	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8534	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Bx
>1a8538	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>1a853c	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a8540	07 07 06 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_Y, ADDR_ABS_X_LONG
>1a8544	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Cx
>1a8548	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a854c	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a8550	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8554	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Dx
>1a8558	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a855c	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a8560	17 07 07 0e			                .byte ADDR_ABS_IND_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a8564	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Ex
>1a8568	01 01 01 0f			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_IND
>1a856c	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a8570	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8574	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Fx
>1a8578	03 05 05 0d			                .byte ADDR_ABS, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a857c	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a8580	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a8584	01 01 01 02 01 01 02 02		ADDR_LENGTH     .byte 1, 1, 1, 2, 1, 1, 2, 2, 0, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 0, 2, 2, 2, 2
>1a858c	00 01 01 03 01 01 03 01 02 01 01 00 02 02 02 02
.1a859c					ADDR_PATTERNS
>1a859c	41 00				            .null "A"
>1a859e	08				            .byte ADDR_ACC
>1a859f	64 64 3a 64 64 64 64 2c		            .null "dd:dddd,X"
>1a85a7	58 00
>1a85a9	0e				            .byte ADDR_ABS_X_LONG
>1a85aa	64 64 3a 64 64 64 64 00		            .null "dd:dddd"
>1a85b2	0b				            .byte ADDR_ABS_LONG
>1a85b3	64 64 64 64 2c 58 00		            .null "dddd,X"
>1a85ba	07				            .byte ADDR_ABS_X
>1a85bb	64 64 64 64 2c 59 00		            .null "dddd,Y"
>1a85c2	06				            .byte ADDR_ABS_Y
>1a85c3	64 64 64 64 00			            .null "dddd"
>1a85c8	03				            .byte ADDR_ABS
>1a85c9	64 64 2c 58 00			            .null "dd,X"
>1a85ce	05				            .byte ADDR_DP_X
>1a85cf	64 64 2c 59 00			            .null "dd,Y"
>1a85d4	11				            .byte ADDR_DP_Y
>1a85d5	64 64 2c 53 00			            .null "dd,S"
>1a85da	09				            .byte ADDR_SP_R
>1a85db	64 64 00			            .null "dd"
>1a85de	01				            .byte ADDR_DP
>1a85df	23 64 64 64 64 00		            .null "#dddd"
>1a85e5	c2				            .byte ADDR_IMM | OP_M_EFFECT | OP_X_EFFECT
>1a85e6	23 64 64 2c 23 64 64 00		            .null "#dd,#dd"
>1a85ee	14				            .byte ADDR_XYC
>1a85ef	23 64 64 00			            .null "#dd"
>1a85f3	02				            .byte ADDR_IMM
>1a85f4	28 64 64 2c 53 29 2c 59		            .null "(dd,S),Y"
>1a85fc	00
>1a85fd	0c				            .byte ADDR_SP_R_Y
>1a85fe	28 64 64 64 64 2c 58 29		            .null "(dddd,X)"
>1a8606	00
>1a8607	10				            .byte ADDR_ABS_X_ID
>1a8608	28 64 64 64 64 29 00		            .null "(dddd)"
>1a860f	10				            .byte ADDR_ABS_X_ID
>1a8610	28 64 64 2c 58 29 00		            .null "(dd,X)"
>1a8617	00				            .byte ADDR_DP_IND_X
>1a8618	28 64 64 29 2c 59 00		            .null "(dd),Y"
>1a861f	04				            .byte ADDR_DP_IND_Y
>1a8620	28 64 64 29 00			            .null "(dd)"
>1a8625	0f				            .byte ADDR_DP_IND
>1a8626	5b 64 64 64 64 5d 00		            .null "[dddd]"
>1a862d	17				            .byte ADDR_ABS_IND_LONG
>1a862e	5b 64 64 5d 2c 59 00		            .null "[dd],Y"
>1a8635	0d				            .byte ADDR_DP_Y_LONG
>1a8636	5b 64 64 5d 00			            .null "[dd]"
>1a863b	0a				            .byte ADDR_DP_LONG
>1a863c	00 00				                .byte 0, 0

;******  Return to file: src\monitor.s

.1a863e					M_INC_CURSOR
.1a863e	08		php		                PHP
.1a863f	c2 20		rep #$20	            REP #$20
.1a8641	48		pha		                PHA
.1a8642	18		clc		                CLC
.1a8643	af 7a 08 00	lda $00087a	                LDA MCURSOR
.1a8647	69 01 00	adc #$0001	                ADC #1
.1a864a	8f 7a 08 00	sta $00087a	                STA MCURSOR
.1a864e	e2 20		sep #$20	            SEP #$20
.1a8650	af 7c 08 00	lda $00087c	                LDA MCURSOR+2
.1a8654	69 00		adc #$00	                ADC #0
.1a8656	8f 7c 08 00	sta $00087c	                STA MCURSOR+2
.1a865a	c2 20		rep #$20	            REP #$20
.1a865c	68		pla		                PLA
.1a865d	28		plp		                PLP
.1a865e	6b		rtl		                RTL
.1a865f					MPRINTB
.1a865f	08		php		                PHP
.1a8660	c2 10		rep #$10	            REP #$10
.1a8662	e2 20		sep #$20	            SEP #$20
.1a8664	da		phx		                PHX
.1a8665	a2 08 00	ldx #$0008	                LDX #8          ; Set number of bits to print to 8
.1a8668	0a		asl a		loop            ASL A           ; Shift MSB to C
.1a8669	b0 08		bcs $1a8673	                BCS is_one
.1a866b	48		pha		                PHA             ; Save value to print
.1a866c	a9 30		lda #$30	                LDA #'0'        ; Print '0'
.1a866e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8671	80 06		bra $1a8679	                BRA continue
.1a8673	48		pha		is_one          PHA             ; Save value to print
.1a8674	a9 31		lda #$31	                LDA #'1'        ; Print '1'
.1a8676	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8679	68		pla		continue        PLA
.1a867a	ca		dex		                DEX             ; Count down the bits to shift
.1a867b	d0 eb		bne $1a8668	                BNE loop        ; And try the next one if there is one
.1a867d	fa		plx		                PLX             ; Otherwise, return
.1a867e	28		plp		                PLP
.1a867f	6b		rtl		                RTL
.1a8680					MSKIPWS
.1a8680	08		php		            PHP
.1a8681	c2 20		rep #$20	            REP #$20
.1a8683	48		pha		            PHA
.1a8684	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a8687	5b		tcd		            TCD
.1a8688	68		pla		            PLA
.1a8689	28		plp		            PLP
.1a868a	e2 20		sep #$20	            SEP #$20
.1a868c	a7 32		lda [$087a]	loop            LDA [MCURSOR]       ; Check the current character
.1a868e	f0 0a		beq $1a869a	                BEQ done            ; If NULL, we're done
.1a8690	c9 20		cmp #$20	                CMP #' '            ; Is it a space?
.1a8692	d0 06		bne $1a869a	                BNE done            ; No: we're done
.1a8694	22 3e 86 1a	jsl $1a863e	                JSL M_INC_CURSOR    ; Yes, try the next one
.1a8698	80 f2		bra $1a868c	                BRA loop
.1a869a	6b		rtl		done            RTL
.1a869b					MPARSESTR
.1a869b	08		php		                PHP
.1a869c	08		php		            PHP
.1a869d	c2 20		rep #$20	            REP #$20
.1a869f	48		pha		            PHA
.1a86a0	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a86a3	5b		tcd		            TCD
.1a86a4	68		pla		            PLA
.1a86a5	28		plp		            PLP
.1a86a6	22 3e 86 1a	jsl $1a863e	                JSL M_INC_CURSOR                ; Point to the first character of the name
.1a86aa	22 80 86 1a	jsl $1a8680	                JSL MSKIPWS                     ; Skip white space
.1a86ae	c2 30		rep #$30	            REP #$30
.1a86b0	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.1a86b2	c2 20		rep #$20	            REP #$20
.1a86b4	29 ff 00	and #$00ff	                AND #$00FF
.1a86b7	0a		asl a		                ASL A                           ; multiply it by forfour
.1a86b8	0a		asl a		                ASL A
.1a86b9	aa		tax		                TAX                             ; ... to get the index to the argument
.1a86ba	a5 32		lda $087a	                LDA MCURSOR                     ; Set the argument to the address of the first byte
.1a86bc	95 0d		sta $0855,x	                STA MARG1,X
.1a86be	a5 34		lda $087c	                LDA MCURSOR+2
.1a86c0	95 0f		sta $0857,x	                STA MARG1+2,X
.1a86c2	e2 20		sep #$20	            SEP #$20
.1a86c4	a7 32		lda [$087a]	loop            LDA [MCURSOR]                   ; Scan to the closing double quote
.1a86c6	f0 14		beq $1a86dc	                BEQ done                        ; If NULL... treat it as a closed argument
.1a86c8	c9 22		cmp #$22	                CMP #CHAR_DQUOTE
.1a86ca	f0 06		beq $1a86d2	                BEQ close_string
.1a86cc	22 3e 86 1a	jsl $1a863e	                JSL M_INC_CURSOR
.1a86d0	80 f2		bra $1a86c4	                BRA loop
.1a86d2	a9 00		lda #$00	close_string    LDA #0                          ; Write a NULL to close the string
.1a86d4	87 32		sta [$087a]	                STA [MCURSOR]
.1a86d6	22 3e 86 1a	jsl $1a863e	                JSL M_INC_CURSOR                ; And point to the next byte
.1a86da	e6 31		inc $0879	                INC MARG_LEN
.1a86dc	28		plp		done            PLP
.1a86dd	6b		rtl		                RTL
.1a86de					MPARSEARG
.1a86de	08		php		            PHP
.1a86df	c2 20		rep #$20	            REP #$20
.1a86e1	48		pha		            PHA
.1a86e2	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a86e5	5b		tcd		            TCD
.1a86e6	68		pla		            PLA
.1a86e7	28		plp		            PLP
.1a86e8	e2 20		sep #$20	            SEP #$20
.1a86ea	64 4a		stz $0892	                STZ MTEMP                       ; Use MTEMP as a flag for having processed digits
.1a86ec	c2 20		rep #$20	            REP #$20
.1a86ee	64 50		stz $0898	                STZ MPARSEDNUM                  ; Clear the parsed number
.1a86f0	64 52		stz $089a	                STZ MPARSEDNUM+2
.1a86f2					pa_loop
.1a86f2	e2 20		sep #$20	            SEP #$20
.1a86f4	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Get the current character
.1a86f6	c9 3a		cmp #$3a	                CMP #":"
.1a86f8	f0 0d		beq $1a8707	                BEQ pa_next_char                ; Ignore any colons
.1a86fa	20 d1 04	jsr $1a04d1	            JSR ISHEX
.1a86fd	90 0e		bcc $1a870d	                BCC finished_arg                ; No? We're done with this argument
.1a86ff	22 76 7b 1a	jsl $1a7b76	                JSL AS_SHIFT_HEX                ; Yes: shift it onto MPARSEDNUM
.1a8703	a9 01		lda #$01	                LDA #1                          ; Flag that we've processed a character
.1a8705	85 4a		sta $0892	                STA MTEMP
.1a8707	22 3e 86 1a	jsl $1a863e	pa_next_char    JSL M_INC_CURSOR                ; And try the next character
.1a870b	80 e5		bra $1a86f2	                BRA pa_loop
.1a870d	a5 4a		lda $0892	finished_arg    LDA MTEMP                       ; Check to see if we've processed any characters
.1a870f	f0 16		beq $1a8727	                BEQ done                        ; No: we're done
.1a8711	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.1a8713	c2 20		rep #$20	            REP #$20
.1a8715	29 ff 00	and #$00ff	                AND #$00FF
.1a8718	0a		asl a		                ASL A                           ; multiply it by forfour
.1a8719	0a		asl a		                ASL A
.1a871a	aa		tax		                TAX                             ; ... to get the index to the argument
.1a871b	a5 50		lda $0898	                LDA MPARSEDNUM                  ; Copy the value to the argument slot
.1a871d	95 0d		sta $0855,x	                STA MARG1,X
.1a871f	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a8721	95 0f		sta $0857,x	                STA MARG1+2,X
.1a8723	e2 20		sep #$20	            SEP #$20
.1a8725	e6 31		inc $0879	                INC MARG_LEN                    ; And bump up the argument count
.1a8727	6b		rtl		done            RTL
.1a8728					MPARSEALLARG
.1a8728	e2 20		sep #$20	            SEP #$20
.1a872a	64 31		stz $0879	                STZ MARG_LEN                    ; Set the arg count to 0
.1a872c	22 80 86 1a	jsl $1a8680	parse_arg       JSL MSKIPWS                     ; Otherwise, skip white space
.1a8730	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Check the current character
.1a8732	f0 21		beq $1a8755	                BEQ done                        ; If it is NULL, we're done
.1a8734	c9 22		cmp #$22	                CMP #CHAR_DQUOTE                ; Is it a double-quote?
.1a8736	d0 06		bne $1a873e	                BNE regular_arg
.1a8738	22 9b 86 1a	jsl $1a869b	                JSL MPARSESTR                   ; Yes: parse it as a string argument
.1a873c	80 0a		bra $1a8748	                BRA check_rest
.1a873e	22 de 86 1a	jsl $1a86de	regular_arg     JSL MPARSEARG                   ; Attempt to parse the argument
.1a8742	a5 31		lda $0879	                LDA MARG_LEN                    ; Check how many arguments we've processed
.1a8744	c9 09		cmp #$09	                CMP #9
.1a8746	b0 0d		bcs $1a8755	                BGE done                        ; If >=9, then we're done
.1a8748	a7 32		lda [$087a]	check_rest      LDA [MCURSOR]                   ; Check the current character
.1a874a	f0 09		beq $1a8755	                BEQ done                        ; If EOL: we're done
.1a874c	c9 20		cmp #$20	                CMP #' '
.1a874e	f0 dc		beq $1a872c	                BEQ parse_arg                   ; If space: try to process another argument
.1a8750	20 d1 04	jsr $1a04d1	            JSR ISHEX
.1a8753	b0 d7		bcs $1a872c	                BCS parse_arg                   ; If hex digit: try to process another argument
.1a8755	6b		rtl		done            RTL
.1a8756					IMPARSE
.1a8756	08		php		                PHP
.1a8757	0b		phd		                PHD
.1a8758	08		php		            PHP
.1a8759	c2 20		rep #$20	            REP #$20
.1a875b	48		pha		            PHA
.1a875c	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a875f	5b		tcd		            TCD
.1a8760	68		pla		            PLA
.1a8761	28		plp		            PLP
.1a8762	c2 10		rep #$10	            REP #$10
.1a8764	e2 20		sep #$20	            SEP #$20
.1a8766	a2 31 00	ldx #$0031	                LDX #MARG_LEN - MONITOR_VARS    ; Clear the monitor command line parameters
.1a8769	74 00		stz $0848,x	clear_command   STZ MONITOR_VARS,X
.1a876b	ca		dex		                DEX
.1a876c	d0 fb		bne $1a8769	                BNE clear_command
.1a876e	a9 00		lda #$00	                LDA #`INPUTBUF                  ; Point the command parser to the input buffer
.1a8770	85 02		sta $084a	                STA MCMDADDR+2
.1a8772	85 34		sta $087c	                STA MCURSOR+2                   ; And point MCURSOR there too
.1a8774	c2 20		rep #$20	            REP #$20
.1a8776	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF
.1a8779	85 00		sta $0848	                STA MCMDADDR
.1a877b	85 32		sta $087a	                STA MCURSOR
.1a877d	e2 20		sep #$20	            SEP #$20
.1a877f	22 80 86 1a	jsl $1a8680	                JSL MSKIPWS                     ; Skip to the first letter of the command
.1a8783	c9 00		cmp #$00	                CMP #0                          ; Is the current character a NULL?
.1a8785	f0 38		beq $1a87bf	                BEQ done                        ; Yes: there's no command here
.1a8787	c2 20		rep #$20	            REP #$20
.1a8789	a5 32		lda $087a	                LDA MCURSOR
.1a878b	85 08		sta $0850	                STA MCMD
.1a878d	e2 20		sep #$20	            SEP #$20
.1a878f	a5 34		lda $087c	                LDA MCURSOR+2
.1a8791	85 0a		sta $0852	                STA MCMD+2
.1a8793	a2 01 00	ldx #$0001	                LDX #1
.1a8796	22 3e 86 1a	jsl $1a863e	cmd_loop        JSL M_INC_CURSOR                ; Move to the next character
.1a879a	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; What is that character?
.1a879c	d0 06		bne $1a87a4	                BNE cmd_space                   ; If not NULL: check for a space
.1a879e	86 0b		stx $0853	no_arguments    STX MCMD_LEN                    ; If NULL: Save the length of the command
.1a87a0	64 31		stz $0879	                STZ MARG_LEN                    ; ... And the fact there are no arguments
.1a87a2	80 1b		bra $1a87bf	                BRA done                        ; ... And return
.1a87a4	c9 20		cmp #$20	cmd_space       CMP #' '                        ; Is it a space?
.1a87a6	f0 03		beq $1a87ab	                BEQ found_cmd                   ; Yes: save the length
.1a87a8	e8		inx		                INX                             ; No: go to the next character
.1a87a9	80 eb		bra $1a8796	                BRA cmd_loop
.1a87ab	86 0b		stx $0853	found_cmd       STX MCMD_LEN                    ; Save the length of the command
.1a87ad	a9 00		lda #$00	                LDA #0
.1a87af	87 32		sta [$087a]	                STA [MCURSOR]                   ; Write a NULL to the end of the command
.1a87b1	22 3e 86 1a	jsl $1a863e	                JSL M_INC_CURSOR                ; And skip to the next character
.1a87b5	a7 08		lda [$0850]	                LDA [MCMD]                      ; Check the command
.1a87b7	c9 41		cmp #$41	                CMP #'A'
.1a87b9	f0 07		beq $1a87c2	                BEQ parse_asm                   ; If 'A', parse the line for the assemble command
.1a87bb	22 28 87 1a	jsl $1a8728	                JSL MPARSEALLARG
.1a87bf	2b		pld		done            PLD
.1a87c0	28		plp		                PLP
.1a87c1	6b		rtl		                RTL
.1a87c2	22 80 86 1a	jsl $1a8680	parse_asm       JSL MSKIPWS                     ; Skip to the first letter of the address
.1a87c6	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a87c8	f0 f5		beq $1a87bf	                BEQ done                        ; Exit if we got the end-of-line
.1a87ca	22 de 86 1a	jsl $1a86de	                JSL MPARSEARG                   ; Parse the first argument as the target address
.1a87ce	22 80 86 1a	jsl $1a8680	                JSL MSKIPWS                     ; Skip to the first letter of the mnemonic
.1a87d2	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a87d4	f0 e9		beq $1a87bf	                BEQ done                        ; Exit if we got the end-of-line
.1a87d6	c2 20		rep #$20	            REP #$20
.1a87d8	a5 32		lda $087a	                LDA MCURSOR                     ; Save pointer to the start of the mnemonic
.1a87da	85 11		sta $0859	                STA MARG2
.1a87dc	e2 20		sep #$20	            SEP #$20
.1a87de	a5 34		lda $087c	                LDA MCURSOR+2
.1a87e0	85 13		sta $085b	                STA MARG2+2
.1a87e2	22 3e 86 1a	jsl $1a863e	asm_find_sp     JSL M_INC_CURSOR                ; Find the space at the end of the mnemonic
.1a87e6	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a87e8	f0 26		beq $1a8810	                BEQ asm_no_operand              ; If EOL: we have an instruction but no operand
.1a87ea	c9 20		cmp #$20	                CMP #' '
.1a87ec	d0 f4		bne $1a87e2	                BNE asm_find_sp
.1a87ee	a9 00		lda #$00	                LDA #0
.1a87f0	87 32		sta [$087a]	                STA [MCURSOR]                   ; Null terminate the mnemonic
.1a87f2	e6 31		inc $0879	                INC MARG_LEN                    ; Count the mnemonic as an argument
.1a87f4	22 3e 86 1a	jsl $1a863e	                JSL M_INC_CURSOR
.1a87f8	22 80 86 1a	jsl $1a8680	                JSL MSKIPWS                     ; Skip to the addressing mode
.1a87fc	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a87fe	f0 bf		beq $1a87bf	                BEQ done                        ; If EOL: we're done
.1a8800	c2 20		rep #$20	            REP #$20
.1a8802	a5 32		lda $087a	                LDA MCURSOR                     ; Set the pointer to the addressing mode
.1a8804	85 15		sta $085d	                STA MARG3
.1a8806	e2 20		sep #$20	            SEP #$20
.1a8808	a5 34		lda $087c	                LDA MCURSOR+2
.1a880a	85 17		sta $085f	                STA MARG3+2
.1a880c	e6 31		inc $0879	                INC MARG_LEN                    ; And count it as the second argument
.1a880e	80 af		bra $1a87bf	                BRA done                        ; and return
.1a8810	e6 31		inc $0879	asm_no_operand  INC MARG_LEN                    ; Increment the argument count
.1a8812	80 ab		bra $1a87bf	                BRA done                        ; And quit
.1a8814					IMLOAD
.1a8814	08		php		                PHP
.1a8815	c2 10		rep #$10	            REP #$10
.1a8817	e2 20		sep #$20	            SEP #$20
.1a8819	a5 31		lda $0879	                LDA MARG_LEN
.1a881b	d0 0f		bne $1a882c	                BNE get_arguments
.1a881d	a2 0a 89	ldx #$890a	bad_arguments   LDX #<>MERRARGS                 ; Print bad arguments error
.1a8820	a9 1a		lda #$1a	                LDA #`MERRARGS
.1a8822	48		pha		                PHA
.1a8823	ab		plb		                PLB
.1a8824	20 29 04	jsr $1a0429	            JSR PRINTS
.1a8827	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a882a	80 61		bra $1a888d	                BRA done
.1a882c					get_arguments
.1a882c	c2 20		rep #$20	            REP #$20
.1a882e	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.1a8830	8f 23 08 00	sta $000823	                STA ARGUMENT1
.1a8834	a5 0f		lda $0857	                LDA MARG1+2
.1a8836	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.1a883a	20 fd 69	jsr $1a69fd	            JSR SETFILEDESC
.1a883d	e2 20		sep #$20	            SEP #$20
.1a883f	a5 31		lda $0879	                LDA MARG_LEN
.1a8841	c9 01		cmp #$01	                CMP #1
.1a8843	d0 0f		bne $1a8854	                BNE get_dest
.1a8845	c2 20		rep #$20	            REP #$20
.1a8847	a9 ff ff	lda #$ffff	                LDA #$FFFF                      ; Destination address not provided...
.1a884a	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR              ; ... set it to something sane
.1a884e	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a8852	80 0e		bra $1a8862	                BRA try_load
.1a8854					get_dest
.1a8854	c2 20		rep #$20	            REP #$20
.1a8856	a5 11		lda $0859	                LDA MARG2                       ; Set the destination address from the arguments
.1a8858	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a885c	a5 13		lda $085b	                LDA MARG2+2
.1a885e	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a8862	22 18 11 00	jsl $001118	try_load        JSL FK_LOAD                     ; Try to load the file
.1a8866	b0 25		bcs $1a888d	                BCS done
.1a8868					error
.1a8868	e2 20		sep #$20	            SEP #$20
.1a886a	a2 30 89	ldx #$8930	                LDX #<>MCANTLOAD                ; Print bad arguments error
.1a886d	a9 1a		lda #$1a	                LDA #`MCANTLOAD
.1a886f	48		pha		                PHA
.1a8870	ab		plb		                PLB
.1a8871	20 29 04	jsr $1a0429	            JSR PRINTS
.1a8874	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.1a8878	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a887b	a9 20		lda #$20	                LDA #' '
.1a887d	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8880	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.1a8884	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a8887	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a888a	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a888d	28		plp		done            PLP
.1a888e	6b		rtl		                RTL
.1a888f					IMSAVE
.1a888f	8b		phb		                PHB
.1a8890	08		php		                PHP
.1a8891	c2 10		rep #$10	            REP #$10
.1a8893	e2 20		sep #$20	            SEP #$20
.1a8895	a5 31		lda $0879	                LDA MARG_LEN
.1a8897	c9 03		cmp #$03	                CMP #3
.1a8899	f0 0f		beq $1a88aa	                BEQ get_arguments
.1a889b	a2 0a 89	ldx #$890a	                LDX #<>MERRARGS                 ; Print bad arguments error
.1a889e	a9 1a		lda #$1a	                LDA #`MERRARGS
.1a88a0	48		pha		                PHA
.1a88a1	ab		plb		                PLB
.1a88a2	20 29 04	jsr $1a0429	            JSR PRINTS
.1a88a5	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a88a8	80 54		bra $1a88fe	                BRA done
.1a88aa					get_arguments
.1a88aa	c2 20		rep #$20	            REP #$20
.1a88ac	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.1a88ae	8f 23 08 00	sta $000823	                STA ARGUMENT1
.1a88b2	a5 0f		lda $0857	                LDA MARG1+2
.1a88b4	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.1a88b8	20 fd 69	jsr $1a69fd	            JSR SETFILEDESC
.1a88bb	a5 11		lda $0859	                LDA MARG2                       ; Set the starting address
.1a88bd	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.1a88c1	a5 13		lda $085b	                LDA MARG2+2
.1a88c3	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.1a88c7	a5 15		lda $085d	                LDA MARG3                       ; Set the ending address
.1a88c9	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.1a88cd	a5 17		lda $085f	                LDA MARG3+2
.1a88cf	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.1a88d3	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                     ; Save the data
.1a88d7	b0 25		bcs $1a88fe	                BCS done
.1a88d9					error
.1a88d9	e2 20		sep #$20	            SEP #$20
.1a88db	a2 1a 89	ldx #$891a	                LDX #<>MCANTSAVE                ; Print bad arguments error
.1a88de	a9 1a		lda #$1a	                LDA #`MCANTSAVE
.1a88e0	48		pha		                PHA
.1a88e1	ab		plb		                PLB
.1a88e2	20 29 04	jsr $1a0429	            JSR PRINTS
.1a88e5	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.1a88e9	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a88ec	a9 20		lda #$20	                LDA #' '
.1a88ee	20 18 00	jsr $1a0018	            JSR PRINTC
.1a88f1	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.1a88f5	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a88f8	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a88fb	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a88fe	28		plp		done            PLP
.1a88ff	ab		plb		                PLB
.1a8900	6b		rtl		                RTL
.1a8901	5c 80 27 1a	jmp $1a2780	IMEXIT          JML INTERACT
.1a8905	6b		rtl		IMRETURN        RTL ; Handle RETURN key (ie: execute command)
.1a8906	00		brk #		IMPARSE1        BRK ; Parse one word on the current command line
.1a8907	00		brk #		IMASSEMBLEA     BRK ; Assemble a line of text.
.1a8908	00		brk #		IMVERIFY        BRK ; Verify memory and file on disk
.1a8909	00		brk #		IMDOS           BRK ; Execute DOS command
.1a890a					MMESSAGES
>1a890a	42 61 64 20 61 72 67 75		MERRARGS        .null "Bad arguments",CHAR_CR,CHAR_CR
>1a8912	6d 65 6e 74 73 0d 0d 00
>1a891a	55 6e 61 62 6c 65 20 74		MCANTSAVE       .null "Unable to save file: "
>1a8922	6f 20 73 61 76 65 20 66 69 6c 65 3a 20 00
>1a8930	55 6e 61 62 6c 65 20 74		MCANTLOAD       .null "Unable to load file: "
>1a8938	6f 20 6c 6f 61 64 20 66 69 6c 65 3a 20 00
>1a8946	0d 20 20 50 43 20 20 20		mregisters_msg  .null $0D,"  PC     A    X    Y    SP   DBR DP   NVMXDIZC",CHAR_CR
>1a894e	20 20 41 20 20 20 20 58 20 20 20 20 59 20 20 20
>1a895e	20 53 50 20 20 20 44 42 52 20 44 50 20 20 20 4e
>1a896e	56 4d 58 44 49 5a 43 0d 00
>1a8977	41 43 44 46 47 4a 48 4c		MCOMMANDS       .null "ACDFGJHLMR;STVWX>?"
>1a897f	4d 52 3b 53 54 56 57 58 3e 3f 00

;******  Return to file: src\basic816.s

.1a898a	18		clc		START       CLC                 ; Go to native mode
.1a898b	fb		xce		            XCE
.1a898c	08		php		            PHP
.1a898d	c2 20		rep #$20	            REP #$20
.1a898f	48		pha		            PHA
.1a8990	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a8993	5b		tcd		            TCD
.1a8994	68		pla		            PLA
.1a8995	28		plp		            PLP
.1a8996	08		php		            PHP
.1a8997	e2 20		sep #$20	            SEP #$20
.1a8999	48		pha		            PHA
.1a899a	a9 00		lda #$00	            LDA #BASIC_BANK
.1a899c	48		pha		            PHA
.1a899d	ab		plb		            PLB
.1a899e	68		pla		            PLA
.1a899f	28		plp		            PLP
.1a89a0	c2 30		rep #$30	            REP #$30
.1a89a2	20 c9 89	jsr $1a89c9	            JSR INITBASIC
.1a89a5	a9 ff fe	lda #$feff	            LDA #STACK_END      ; Set the system stack
.1a89a8	1b		tcs		            TCS
.1a89a9	08		php		            PHP
.1a89aa	e2 20		sep #$20	            SEP #$20
.1a89ac	48		pha		            PHA
.1a89ad	a9 1a		lda #$1a	            LDA #`GREET
.1a89af	48		pha		            PHA
.1a89b0	ab		plb		            PLB
.1a89b1	68		pla		            PLA
.1a89b2	28		plp		            PLP
.1a89b3	a2 71 d2	ldx #$d271	            LDX #<>GREET
.1a89b6	20 29 04	jsr $1a0429	            JSR PRINTS
.1a89b9	08		php		            PHP
.1a89ba	e2 20		sep #$20	            SEP #$20
.1a89bc	48		pha		            PHA
.1a89bd	a9 00		lda #$00	            LDA #BASIC_BANK
.1a89bf	48		pha		            PHA
.1a89c0	ab		plb		            PLB
.1a89c1	68		pla		            PLA
.1a89c2	28		plp		            PLP
.1a89c3	4c 80 27	jmp $1a2780	            JMP INTERACT        ; Start accepting input from the user
.1a89c6	4c c6 89	jmp $1a89c6	WAIT        JMP WAIT
.1a89c9					INITBASIC
.1a89c9	08		php		            PHP
.1a89ca	20 34 03	jsr $1a0334	            JSR INITIO
.1a89cd	20 6c 4f	jsr $1a4f6c	            JSR CMD_NEW
.1a89d0	28		plp		            PLP
.1a89d1	60		rts		            RTS
>1ad271	43 32 35 36 20 46 6f 65		GREET       .text "C256 Foenix BASIC816 "
>1ad279	6e 69 78 20 42 41 53 49 43 38 31 36 20

;******  Processing file: src\version.s

>1ad286	76 30 2e 32 2e 30 2d 61		.text "v0.2.0-alpha+386"
>1ad28e	6c 70 68 61 2b 33 38 36

;******  Return to file: src\basic816.s

>1ad296	0d 00				            .byte 13,0

;******  End of listing
