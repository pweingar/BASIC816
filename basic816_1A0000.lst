
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -D SYSTEM=2 -D C256_SKU=2 -D UARTSUPPORT= -D UNITTEST=0 -D TRACE_LEVEL=0 --long-address --flat -b --m65816 --intel-hex -o basic816_1A0000.hex --list=basic816_1A0000.lst --labels=basic816_1A0000.lbl src\basic816.s
; Mon May 17 14:28:13 2021

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=2					SYSTEM=2
=2					C256_SKU=2
=					UARTSUPPORT=
=0					UNITTEST=0
=0					TRACE_LEVEL=0

;******  Processing input file: src\basic816.s


;******  Processing file: src\constants.s

=2					SYSTEM_C256 = 2         ; C256 Foenix
=1					SYSTEM_C64 = 1          ; Commodore 64 with SuperCPU
=$03					CHAR_CTRL_C = $03       ; CTRL-C: used as a program interrupt key
=$07					CHAR_BELL = $07         ; Ring the console bell
=$08					CHAR_BS = $08           ; Backspace
=$09					CHAR_TAB = $09          ; TAB
=$0a					CHAR_LF = $0A           ; Linefeed
=$0d					CHAR_CR = $0D           ; Carriage Return
=$0f					CHAR_INS = $0F          ; Insert
=$1b					CHAR_ESC = $1B          ; Escape
=$22					CHAR_DQUOTE = $22       ; Double quote
=$20					CHAR_SP = $20           ; Space
=$7f					CHAR_DEL = $7F          ; Delete
=5					ARGUMENT_SIZE = 5       ; Number of bytes in an argument
=8					VAR_NAME_SIZE = 8       ; Maximum number of characters in a variable name
=0					TYPE_INTEGER = 0        ; 32-bit integer
=1					TYPE_FLOAT = 1          ; Single-precision floating point
=2					TYPE_STRING = 2         ; ASCII string
=$80					TYPE_ARR_INTEGER = $80  ; Array of 32-bit integers
=$81					TYPE_ARR_FLOAT = $81    ; Array of 32-bit floats
=$82					TYPE_ARR_STRING = $82   ; Array of strings
=$7f					TYPE_BINDING = $7F      ; A variable name binding
=$ff					TYPE_NAV = $FF          ; Not-A-Value
=0					ERR_OK = 0              ; No error
=1					ERR_BREAK = 1           ; The user pressed an interrupt key
=2					ERR_SYNTAX = 2          ; A syntax error was found on the current line
=3					ERR_MEMORY = 3          ; Out of memory
=4					ERR_TYPE = 4            ; Type mismatch error
=5					ERR_NOTFOUND = 5        ; Variable not found error
=6					ERR_NOLINE = 6          ; Line number not found
=7					ERR_STACKUNDER = 7      ; Stack underflow error
=8					ERR_STACKOVER = 8       ; Stack overflow error
=9					ERR_RANGE = 9           ; Out-of-range error
=10					ERR_ARGUMENT = 10       ; Bad argument error
=11					ERR_NOFILE = 11         ; File not found error
=12					ERR_NAN = 12            ; Floating point math resulted in something that is not a number
=13					ERR_OVERFLOW = 13       ; Math operation overflowed
=14					ERR_UNDERFLOW = 14      ; Math operation underflowed
=15					ERR_DIV0 = 15           ; Math operation involved a division by zero
=16					ERR_DIRECTORY = 16      ; Error reading the directory
=17					ERR_LOAD = 17           ; Could not load file
=18					ERR_SAVE = 18           ; Could not save a file
=19					ERR_DELETE = 19         ; Could not delete a file
=20					ERR_FILENOTFOUND = 20   ; Could not find the file
=21					ERR_DIRNOTWRITE = 21    ; Could not update the directory entry
=22					ERR_NOTCOPIED = 22      ; Could not copy the file
=23					ERR_DOMAIN = 23         ; Mathematical functions domain error

;******  Return to file: src\basic816.s


;******  Processing file: src\memorymap.s


;******  Processing file: src\C256/mmap_c256.s

=1					SYS_C256_FMX = 1        ; System SKU for C256 Foenix FMX
=2					SYS_C256_USER = 2       ; System SKU for C256 Foenix User

;******  Processing file: src\C256/page_00_inc.s

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				unused_0000      = $000000 ;12 Bytes unused
=$000008				OPL2_ADDY_PTR_LO = $000008  ; THis Points towards the Instruments Database
=$000009				OPL2_ADDY_PTR_MD = $000009
=$00000a				OPL2_ADDY_PTR_HI = $00000A
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;1 Byte Color of next character to be printed to the screen.
=$00001f				COLORPOS         = $00001F ;3 Byte address of cursor's position in the color matrix
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$000026				OPL2_OPERATOR    = $000026 ;
=$000027				OPL2_CHANNEL     = $000027 ;
=$000028				OPL2_REG_REGION  = $000028 ; Offset to the Group of Registers
=$00002a				OPL2_REG_OFFSET  = $00002A ; 2 Bytes (16Bits)
=$00002c				OPL2_IND_ADDY_LL = $00002C ; 2 Bytes Reserved (Only need 3)
=$00002e				OPL2_IND_ADDY_HL = $00002E ; 2 Bytes Reserved (Only need 3)
=$000030				OPL2_NOTE        = $000030 ; 1 Byte
=$000031				OPL2_OCTAVE      = $000031 ; 1 Byte
=$000032				OPL2_PARAMETER0  = $000032 ; 1 Byte - Key On/Feedback
=$000033				OPL2_PARAMETER1  = $000033 ; 1 Byte
=$000034				OPL2_PARAMETER2  = $000034 ; 1 Byte
=$000035				OPL2_PARAMETER3  = $000035 ; 1 Byte
=$000036				OPL2_LOOP        = $000036 ;
=$000036				OPL2_BLOCK       = $000036
=$000038				SDCARD_FILE_PTR  = $000038 ; 3 Bytes Pointer to Filename to open
=$00003c				SDCARD_BYTE_NUM  = $00003C ; 2Bytes
=$00003f				SDCARD_PRSNT_MNT = $00003F ; 1 Byte, Indicate that the SDCard is Present and that it is Mounted
=$000040				BM_CLEAR_SCRN_X  = $000040
=$000042				BM_CLEAR_SCRN_Y  = $000042
=$000040				RAD_STARTLINE    = $000040 ; 1 Byte
=$000041				RAD_PATTERN_IDX  = $000041 ; 1 Byte
=$000042				RAD_LINE         = $000042 ; 1 Byte
=$000043				RAD_LINENUMBER   = $000043 ; 1 Byte
=$000044				RAD_CHANNEL_NUM  = $000044 ; 1 Byte
=$000045				RAD_ISLASTCHAN   = $000045 ; 1 Byte
=$000046				RAD_Y_POINTER    = $000046 ; 2 Bytes
=$000048				RAD_TICK         = $000048
=$00004a				RAD_CHANNEL_DATA = $00004A ; 2 Bytes
=$00004c				RAD_CHANNE_EFFCT = $00004C
=$00004d				RAD_TEMP         = $00004D
=$000050				RAD_ADDR         = $000050 ; 3 bytes to avoid OPL2 errors.
=$000053				RAD_PATTRN       = $000053 ; 1 bytes - offset to patter
=$000054				RAD_PTN_DEST     = $000054 ; 3 bytes - where to write the pattern data
=$000057				RAD_CHANNEL      = $000057 ; 2 bytes - 0 to 8
=$000059				RAD_LAST_NOTE    = $000059 ; 1 if this is the last note
=$00005a				RAD_LINE_PTR     = $00005A ; 2 bytes - offset to memory location
=$000040				BMP_X_SIZE       = $000040 ; 2 Bytes
=$000042				BMP_Y_SIZE       = $000042 ; 2 Bytes
=$000044				BMP_PRSE_SRC_PTR = $000044 ; 3 Bytes
=$000048				BMP_PRSE_DST_PTR = $000048 ; 3 Bytes
=$00004c				BMP_COLOR_PALET  = $00004C ; 2 Bytes
=$00004e				SCRN_X_STRIDE    = $00004E ; 2 Bytes, Basically How many Pixel Accross in Bitmap Mode
=$000050				BMP_FILE_SIZE    = $000050 ; 4 Bytes
=$000054				BMP_POSITION_X   = $000054 ; 2 Bytes Where, the BMP will be position on the X Axis
=$000056				BMP_POSITION_Y   = $000056 ; 2 Bytes Where, the BMP will be position on the Y Axis
=$000058				BMP_PALET_CHOICE = $000058 ;
=$0000e0				MOUSE_PTR        = $0000E0
=$0000e1				MOUSE_POS_X_LO   = $0000E1
=$0000e2				MOUSE_POS_X_HI   = $0000E2
=$0000e3				MOUSE_POS_Y_LO   = $0000E3
=$0000e4				MOUSE_POS_Y_HI   = $0000E4
=$0000f0				USER_TEMP        = $0000F0 ;32 Bytes Temp space for user programs
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000110				DIVIDER_0        = $000110 ;0 Byte  Unsigned divider
=$000110				D0_OPERAND_A     = $000110 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$000112				D0_OPERAND_B     = $000112 ;2 Bytes Divider 0 Divisor ex B in A/B
=$000114				D0_RESULT        = $000114 ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D0_REMAINDER     = $000116 ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000118				DIVIDER_1        = $000118 ;0 Byte  Signed divider
=$000118				D1_OPERAND_A     = $000118 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$00011a				D1_OPERAND_B     = $00011A ;2 Bytes Divider 1 Divisor ex B in A/B
=$00011c				D1_RESULT        = $00011C ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$00011e				D1_REMAINDER     = $00011E ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$000120				ADDER_SIGNED_32  = $000120 ; The 32 Bit Adders takes 12Byte that are NOT RAM Location
=$000140				INT_CONTROLLER   = $000140 ; $000140...$00015F Interrupt Controller
=$000160				TIMER_CONTROLLER = $000160 ; $000160...$00017F Timer0/Timer1/Timer2 Block
=$000160				TIMER_CTRL_REGLL = $000160 ;
=$000161				TIMER_CTRL_REGLH = $000161 ;
=$000162				TIMER_CTRL_REGHL = $000162 ;
=$000163				TIMER_CTRL_REGHH = $000163 ;
=$000240				CPU_REGISTERS    = $000240 ; Byte
=$000240				CPUPC            = $000240 ;2 Bytes Program Counter (PC)
=$000242				CPUPBR           = $000242 ;2 Bytes Program Bank Register (K)
=$000244				CPUA             = $000244 ;2 Bytes Accumulator (A)
=$000246				CPUX             = $000246 ;2 Bytes X Register (X)
=$000248				CPUY             = $000248 ;2 Bytes Y Register (Y)
=$00024a				CPUSTACK         = $00024A ;2 Bytes Stack Pointer (S)
=$00024c				CPUDP            = $00024C ;2 Bytes Direct Page Register (D)
=$00024e				CPUDBR           = $00024E ;1 Byte  Data Bank Register (B)
=$00024f				CPUFLAGS         = $00024F ;1 Byte  Flags (P)
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$000300				FDC_DRIVE        = $000300 ;1 byte - The number of the selected drive
=$000301				FDC_HEAD         = $000301 ;1 byte - The head number (0 or 1)
=$000302				FDC_CYLINDER     = $000302 ;1 byte - The cylinder number
=$000303				FDC_SECTOR       = $000303 ;1 byte - The sector number
=$000304				FDC_SECTOR_SIZE  = $000304 ;1 byte - The sector size code (2 = 512)
=$000305				FDC_SECPERTRK    = $000305 ;1 byte - The number of sectors per track (18 for 1.44 MB floppy)
=$000306				FDC_ST0          = $000306 ;1 byte - Status Register 0
=$000307				FDC_ST1          = $000307 ;1 byte - Status Register 1
=$000308				FDC_ST2          = $000308 ;1 byte - Status Register 2
=$000309				FDC_ST3          = $000309 ;1 byte - Status Register 3
=$00030a				FDC_PCN          = $00030A ;1 byte - Present Cylinder Number
=$00030b				FDC_STATUS       = $00030B ;1 byte - Status of what we think is going on with the FDC:
=$00030c				DIVIDEND         = $00030C ;4 bytes - Dividend for 32-bit division
=$000310				DIVISOR          = $000310 ;4 bytes - Divisor for 32-bit division
=$000314				REMAINDER        = $000314 ;4 bytes - Remainder for 32-bit division
=$000320				SDOS_VARIABLES   = $000320
=$000320				BIOS_STATUS      = $000320      ; 1 byte - Status of any BIOS operation
=$000321				BIOS_DEV         = $000321      ; 1 byte - Block device number for block operations
=$000322				BIOS_LBA         = $000322      ; 4 bytes - Address of block to read/write (this is the physical block, w/o reference to partition)
=$000326				BIOS_BUFF_PTR    = $000326      ; 4 bytes - 24-bit pointer to memory for read/write operations
=$00032a				BIOS_FIFO_COUNT  = $00032A      ; 2 bytes - The number of bytes read on the last block read
=$00032e				DOS_STATUS       = $00032E      ; 1 byte - The error code describing any error with file access
=$000330				DOS_CLUS_ID      = $000330      ; 4 bytes - The cluster desired for a DOS operation
=$000338				DOS_DIR_PTR      = $000338      ; 4 bytes - Pointer to a directory entry (assumed to be within DOS_SECTOR)
=$00033c				DOS_BUFF_PTR     = $00033C      ; 4 bytes - A pointer for DOS cluster read/write operations
=$000340				DOS_FD_PTR       = $000340      ; 4 bytes - A pointer to a file descriptor
=$000344				DOS_FAT_LBA      = $000344      ; 4 bytes - The LBA for a sector of the FAT we need to read/write
=$000348				DOS_TEMP         = $000348      ; 4 bytes - Temporary storage for DOS operations
=$00034c				DOS_FILE_SIZE    = $00034C      ; 4 bytes - The size of a file
=$000350				DOS_SRC_PTR      = $000350      ; 4 bytes - Pointer for transferring data
=$000354				DOS_DST_PTR      = $000354      ; 4 bytes - Pointer for transferring data
=$000358				DOS_END_PTR      = $000358      ; 4 bytes - Pointer to the last byte to save
=$00035c				DOS_RUN_PTR      = $00035C      ; 4 bytes - Pointer for starting a loaded program
=$000360				DOS_RUN_PARAM    = $000360      ; 4 bytes - Pointer to the ASCIIZ string for arguments in loading a program
=$000364				DOS_STR1_PTR     = $000364      ; 4 bytes - pointer to a string
=$000368				DOS_STR2_PTR     = $000368      ; 4 bytes - pointer to a string
=$00036b				DOS_SCRATCH      = $00036B      ; 4 bytes - general purpose short term storage
=$000400				DOS_PATH_BUFF    = $000400      ; 256 bytes - A buffer for path names
=$000500				FDC_PARAMETERS   = $000500      ; 16 bytes - a buffer of parameter data for the FDC
=$000510				FDC_RESULTS      = $000510      ; 16 bytes - Buffer for results of FDC commands
=$000530				FDC_PARAM_NUM    = $000530      ; 1 byte - The number of parameters to send to the FDC (including command)
=$000532				FDC_RESULT_NUM   = $000532      ; 1 byte - The number of results expected
=$000533				FDC_EXPECT_DAT   = $000533      ; 1 byte - 0 = the command expects no data, otherwise expects data
=$000534				FDC_CMD_RETRY    = $000534      ; 1 byte - a retry counter for commands
=$000700				CURRUART         = $000700 ; 3-bytes: the base address of the current UART
=$000703				CHAN_OUT         = $000703 ; 1-byte: the number of the current output channel (for PUTC, etc.)
=$000704				CHAN_IN          = $000704 ; 1-byte: the number of the current input channel (for GETCH, etc.)
=$000705				TIMERFLAGS       = $000705 ; 1-byte: flags to indicate that one of the timer interupts has triggered
=$80					TIMER0TRIGGER    = $80
=$40					TIMER1TRIGGER    = $40
=$20					TIMER2TRIGGER    = $20
=$000f00				KEY_BUFFER       = $000F00 ; 64 Bytes keyboard buffer
=$0080					KEY_BUFFER_SIZE  = $0080   ;128 Bytes (constant) keyboard buffer length
=$000f7f				KEY_BUFFER_END   = $000F7F ;  1 Byte  Last byte of keyboard buffer
=$000f83				KEY_BUFFER_CMD   = $000F83 ;  1 Byte  Indicates the Command Process Status
=$000f84				COMMAND_SIZE_STR = $000F84 ;  1 Byte
=$000f86				COMMAND_COMP_TMP = $000F86 ;  2 Bytes
=$000f87				KEYBOARD_SC_FLG  = $000F87 ;  1 Bytes that indicate the Status of Left Shift, Left CTRL, Left ALT, Right Shift
=$000f88				KEYBOARD_SC_TMP  = $000F88 ;  1 Byte, Interrupt Save Scan Code while Processing
=$000f89				KEYBOARD_LOCKS   = $000F89 ;  1 Byte, the status of the various lock keys
=$000f8a				KEYFLAG          = $000F8A ;  1 Byte, flag to indicate if CTRL-C has been pressed
=$000f8b				KEY_BUFFER_RPOS  = $000F8B ;  2 Byte, position of the character to read from the KEY_BUFFER
=$000f8d				KEY_BUFFER_WPOS  = $000F8D ;  2 Byte, position of the character to write to the KEY_BUFFER
=$001000				KERNEL_JMP_BEGIN = $001000 ; Reserved for the Kernel jump table
=$001fff				KERNEL_JMP_END   = $001FFF
=$002000				TEST_BEGIN       = $002000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/int_math_defs.s

=$000100				UNSIGNED_MULT_A_LO  = $000100
=$000101				UNSIGNED_MULT_A_HI  = $000101
=$000102				UNSIGNED_MULT_B_LO  = $000102
=$000103				UNSIGNED_MULT_B_HI  = $000103
=$000104				UNSIGNED_MULT_AL_LO = $000104
=$000105				UNSIGNED_MULT_AL_HI = $000105
=$000106				UNSIGNED_MULT_AH_LO = $000106
=$000107				UNSIGNED_MULT_AH_HI = $000107
=$000108				SIGNED_MULT_A_LO    = $000108
=$000109				SIGNED_MULT_A_HI    = $000109
=$00010a				SIGNED_MULT_B_LO    = $00010A
=$00010b				SIGNED_MULT_B_HI    = $00010B
=$00010c				SIGNED_MULT_AL_LO   = $00010C
=$00010d				SIGNED_MULT_AL_HI   = $00010D
=$00010e				SIGNED_MULT_AH_LO   = $00010E
=$00010f				SIGNED_MULT_AH_HI   = $00010F
=$000110				UNSIGNED_DIV_DEM_LO = $000110
=$000111				UNSIGNED_DIV_DEM_HI = $000111
=$000112				UNSIGNED_DIV_NUM_LO = $000112
=$000113				UNSIGNED_DIV_NUM_HI = $000113
=$000114				UNSIGNED_DIV_QUO_LO = $000114
=$000115				UNSIGNED_DIV_QUO_HI = $000115
=$000116				UNSIGNED_DIV_REM_LO = $000116
=$000117				UNSIGNED_DIV_REM_HI = $000117
=$000118				SIGNED_DIV_DEM_LO   = $000118
=$000119				SIGNED_DIV_DEM_HI   = $000119
=$00011a				SIGNED_DIV_NUM_LO   = $00011A
=$00011b				SIGNED_DIV_NUM_HI   = $00011B
=$00011c				SIGNED_DIV_QUO_LO   = $00011C
=$00011d				SIGNED_DIV_QUO_HI   = $00011D
=$00011e				SIGNED_DIV_REM_LO   = $00011E
=$00011f				SIGNED_DIV_REM_HI   = $00011F
=$000120				ADDER32_A_LL        = $000120
=$000121				ADDER32_A_LH        = $000121
=$000122				ADDER32_A_HL        = $000122
=$000123				ADDER32_A_HH        = $000123
=$000124				ADDER32_B_LL        = $000124
=$000125				ADDER32_B_LH        = $000125
=$000126				ADDER32_B_HL        = $000126
=$000127				ADDER32_B_HH        = $000127
=$000128				ADDER32_R_LL        = $000128
=$000129				ADDER32_R_LH        = $000129
=$00012a				ADDER32_R_HL        = $00012A
=$00012b				ADDER32_R_HH        = $00012B
=$af1400				SIGNED32_MULT_A     = $AF1400
=$af1404				SIGNED32_MULT_B     = $AF1404
=$af1408				SIGNED32_MULT_OUT   = $AF1408

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/vicky_def.s

=$af0000				MASTER_CTRL_REG_L	      = $AF0000
=$01					Mstr_Ctrl_Text_Mode_En  = $01       ; Enable the Text Mode
=$02					Mstr_Ctrl_Text_Overlay  = $02       ; Enable the Overlay of the text mode on top of Graphic Mode (the Background Color is ignored)
=$04					Mstr_Ctrl_Graph_Mode_En = $04       ; Enable the Graphic Mode
=$08					Mstr_Ctrl_Bitmap_En     = $08       ; Enable the Bitmap Module In Vicky
=$10					Mstr_Ctrl_TileMap_En    = $10       ; Enable the Tile Module in Vicky
=$20					Mstr_Ctrl_Sprite_En     = $20       ; Enable the Sprite Module in Vicky
=$40					Mstr_Ctrl_GAMMA_En      = $40       ; this Enable the GAMMA correction - The Analog and DVI have different color value, the GAMMA is great to correct the difference
=$80					Mstr_Ctrl_Disable_Vid   = $80       ; This will disable the Scanning of the Video hence giving 100% bandwith to the CPU
=$af0001				MASTER_CTRL_REG_H       = $AF0001
=$01					Mstr_Ctrl_Video_Mode0   = $01       ; 0 - 640x480 (Clock @ 25.175Mhz), 1 - 800x600 (Clock @ 40Mhz)
=$02					Mstr_Ctrl_Video_Mode1   = $02       ; 0 - No Pixel Doubling, 1- Pixel Doubling (Reduce the Pixel Resolution by 2)
=$af0002				GAMMA_CTRL_REG          = $AF0002
=$01					GAMMA_Ctrl_Input        = $01 ; 0 = DipSwitch Chooses GAMMA on/off , 1- Software Control
=$02					GAMMA_Ctrl_Soft         = $02 ; 0 = GAMMA Table is not Applied, 1 = GAMMA Table is Applied
=$08					GAMMA_DP_SW_VAL         = $08 ; READ ONLY - Actual DIP Switch Value
=$10					HIRES_DP_SW_VAL         = $10 ; READ ONLY - 0 = Hi-Res on BOOT ON, 1 = Hi-Res on BOOT OFF
=$af0003				VKY_RESERVED_01         = $AF0003
=$01					Border_Ctrl_Enable      = $01
=$af0004				BORDER_CTRL_REG         = $AF0004 ; Bit[0] - Enable (1 by default)  Bit[4..6]: X Scroll Offset ( Will scroll Left) (Acceptable Value: 0..7)
=$af0005				BORDER_COLOR_B          = $AF0005
=$af0006				BORDER_COLOR_G          = $AF0006
=$af0007				BORDER_COLOR_R          = $AF0007
=$af0008				BORDER_X_SIZE           = $AF0008; X-  Values: 0 - 32 (Default: 32)
=$af0009				BORDER_Y_SIZE           = $AF0009; Y- Values 0 -32 (Default: 32)
=$af000d				BACKGROUND_COLOR_B      = $AF000D ; When in Graphic Mode, if a pixel is "0" then the Background pixel is chosen
=$af000e				BACKGROUND_COLOR_G      = $AF000E
=$af000f				BACKGROUND_COLOR_R      = $AF000F ;
=$af0010				VKY_TXT_CURSOR_CTRL_REG = $AF0010   ;[0]  Enable Text Mode
=$01					Vky_Cursor_Enable       = $01
=$02					Vky_Cursor_Flash_Rate0  = $02       ; 00 - 1/Sec, 01 - 2/Sec, 10 - 4/Sec, 11 - 5/Sec
=$04					Vky_Cursor_Flash_Rate1  = $04
=$08					Vky_Cursor_FONT_Page0   = $08       ; Pick Font Page 0 or Font Page 1
=$10					Vky_Cursor_FONT_Page1   = $10       ; Pick Font Page 0 or Font Page 1
=$af0011				VKY_TXT_START_ADD_PTR   = $AF0011   ; This is an offset to change the Starting address of the Text Mode Buffer (in x)
=$af0012				VKY_TXT_CURSOR_CHAR_REG = $AF0012
=$af0013				VKY_TXT_CURSOR_COLR_REG = $AF0013
=$af0014				VKY_TXT_CURSOR_X_REG_L  = $AF0014
=$af0015				VKY_TXT_CURSOR_X_REG_H  = $AF0015
=$af0016				VKY_TXT_CURSOR_Y_REG_L  = $AF0016
=$af0017				VKY_TXT_CURSOR_Y_REG_H  = $AF0017
=$af001b				VKY_LINE_IRQ_CTRL_REG   = $AF001B ;[0] - Enable Line 0, [1] -Enable Line 1
=$af001c				VKY_LINE0_CMP_VALUE_LO  = $AF001C ;Write Only [7:0]
=$af001d				VKY_LINE0_CMP_VALUE_HI  = $AF001D ;Write Only [3:0]
=$af001e				VKY_LINE1_CMP_VALUE_LO  = $AF001E ;Write Only [7:0]
=$af001f				VKY_LINE1_CMP_VALUE_HI  = $AF001F ;Write Only [3:0]
=$af001c				VKY_INFO_CHIP_NUM_L     = $AF001C   ; VErsion
=$af001d				VKY_INFO_CHIP_NUM_H     = $AF001D   ; Version
=$af001e				VKY_INFO_CHIP_VER_L     = $AF001E   ; Sub-Version
=$af001f				VKY_INFO_CHIP_VER_H     = $AF001F   ; Sub-Version
=$af0500				MOUSE_PTR_GRAP0_START    = $AF0500 ; 16 x 16 = 256 Pixels (Grey Scale) 0 = Transparent, 1 = Black , 255 = White
=$af05ff				MOUSE_PTR_GRAP0_END      = $AF05FF ; Pointer 0
=$af0600				MOUSE_PTR_GRAP1_START    = $AF0600 ;
=$af06ff				MOUSE_PTR_GRAP1_END      = $AF06FF ; Pointer 1
=$af0700				MOUSE_PTR_CTRL_REG_L    = $AF0700 ; Bit[0] Enable, Bit[1] = 0  ( 0 = Pointer0, 1 = Pointer1)
=$af0701				MOUSE_PTR_CTRL_REG_H    = $AF0701 ;
=$af0702				MOUSE_PTR_X_POS_L       = $AF0702 ; X Position (0 - 639) (Can only read now) Writing will have no effect
=$af0703				MOUSE_PTR_X_POS_H       = $AF0703 ;
=$af0704				MOUSE_PTR_Y_POS_L       = $AF0704 ; Y Position (0 - 479) (Can only read now) Writing will have no effect
=$af0705				MOUSE_PTR_Y_POS_H       = $AF0705 ;
=$af0706				MOUSE_PTR_BYTE0         = $AF0706 ; Byte 0 of Mouse Packet (you must write 3 Bytes)
=$af0707				MOUSE_PTR_BYTE1         = $AF0707 ; Byte 1 of Mouse Packet (if you don't, then )
=$af0708				MOUSE_PTR_BYTE2         = $AF0708 ; Byte 2 of Mouse Packet (state Machine will be jammed in 1 state)
=$af070b				C256F_MODEL_MAJOR       = $AF070B ;
=$af070c				C256F_MODEL_MINOR       = $AF070C ;
=$af070d				FPGA_DOR                = $AF070D ;
=$af070e				FPGA_MOR                = $AF070E ;
=$af070f				FPGA_YOR                = $AF070F ;
=$af0900				VMEM2CPU_CTRL_REG      = $AF0900  ;
=$01					VMEM2CPU_Clear_FIFO    = $01        ; Setting this to 1 will flush (Reset) the FIFO, clear it after to return to normal function
=$02					VMEM2CPU_Intterupt     = $02        ; This is not implemented because there is not enough Interrupt line on the FMX
=$af0901				VMEM2CPU_Data_Port     = $AF0901    ; This is a Byte Port of the data that you have requested. (Output of the FIFO)
=$af0902				VMEM2CPU_Fifo_Count_LO = $AF0902    ; FIFO Count Lo (number of byte in the FIFO) FIFO Count is 10bits, Count_Bit0 to Count_Bit7 of Count
=$af0903				VMEM2CPU_Fifo_Count_HI = $AF0903    ; FIFO Count Hi, Bit 0 = Count_Bit8, Bit 1 = Count_Bit9
=$80					VMEM2CPU_Fifo_Empty    = $80        ; Bit 7 of VMEM2CPU_Fifo_Count_HI, when 1, the FIFO is empty.
=$af1f40				FG_CHAR_LUT_PTR         = $AF1F40
=$af1f80				BG_CHAR_LUT_PTR		    = $AF1F80
=$af2000				GRPH_LUT0_PTR		    = $AF2000
=$af2400				GRPH_LUT1_PTR		    = $AF2400
=$af2800				GRPH_LUT2_PTR		    = $AF2800
=$af2c00				GRPH_LUT3_PTR		    = $AF2C00
=$af3000				GRPH_LUT4_PTR		    = $AF3000
=$af3400				GRPH_LUT5_PTR		    = $AF3400
=$af3800				GRPH_LUT6_PTR		    = $AF3800
=$af3c00				GRPH_LUT7_PTR		    = $AF3C00
=$af4000				GAMMA_B_LUT_PTR		    = $AF4000
=$af4100				GAMMA_G_LUT_PTR		    = $AF4100
=$af4200				GAMMA_R_LUT_PTR		    = $AF4200
=$af8000				FONT_MEMORY_BANK0       = $AF8000     ;$AF8000 - $AF87FF
=$afa000				CS_TEXT_MEM_PTR         = $AFA000
=$afc000				CS_COLOR_MEM_PTR        = $AFC000

;******  Processing file: src\C256/VKYII_CFP9553_BITMAP_def.s

=$01					BM_Enable             = $01
=$00					BM_LUT0               = $00 ;
=$02					BM_LUT1               = $02 ;
=$04					BM_LUT2               = $04 ;
=$06					BM_LUT3               = $06 ;
=$08					BM_LUT4               = $08 ;
=$0a					BM_LUT5               = $0A ;
=$0c					BM_LUT6               = $0C ;
=$0e					BM_LUT7               = $0E ;
=$af0100				BM0_CONTROL_REG     = $AF0100
=$af0101				BM0_START_ADDY_L    = $AF0101
=$af0102				BM0_START_ADDY_M    = $AF0102
=$af0103				BM0_START_ADDY_H    = $AF0103
=$af0104				BM0_X_OFFSET        = $AF0104   ; Not Implemented
=$af0105				BM0_Y_OFFSET        = $AF0105   ; Not Implemented
=$af0106				BM0_RESERVED_6      = $AF0106
=$af0107				BM0_RESERVED_7      = $AF0107
=$af0108				BM1_CONTROL_REG     = $AF0108
=$af0109				BM1_START_ADDY_L    = $AF0109
=$af010a				BM1_START_ADDY_M    = $AF010A
=$af010b				BM1_START_ADDY_H    = $AF010B
=$af010c				BM1_X_OFFSET        = $AF010C   ; Not Implemented
=$af010d				BM1_Y_OFFSET        = $AF010D   ; Not Implemented
=$af010e				BM1_RESERVED_6      = $AF010E
=$af010f				BM1_RESERVED_7      = $AF010F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_TILEMAP_def.s

=$01					TILE_Enable             = $01
=0					TILEMAP_CONTROL         = 0             ; Offset to a tile map's control register
=1					TILEMAP_START_ADDY      = 1             ; Offset to a tile map's address
=4					TILEMAP_TOTAL_X         = 4             ; Offset to a tile map's width
=6					TILEMAP_TOTAL_Y         = 6             ; Offset to a tile map's height
=8					TILEMAP_WINDOW_X        = 8             ; Offset to a tile map's X position
=10					TILEMAP_WINDOW_Y        = 10            ; Offset to a tile map's Y position
=1					TILEMAP_VISIBLE         = 1             ; Tile map is visible flag
=$af0200				TL0_CONTROL_REG         = $AF0200       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0201				TL0_START_ADDY_L        = $AF0201       ; Not USed right now - Starting Address to where is the MAP
=$af0202				TL0_START_ADDY_M        = $AF0202
=$af0203				TL0_START_ADDY_H        = $AF0203
=$af0204				TL0_TOTAL_X_SIZE_L      = $AF0204       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0205				TL0_TOTAL_X_SIZE_H      = $AF0205
=$af0206				TL0_TOTAL_Y_SIZE_L      = $AF0206       ; Size of the Map in Y Tile Count [9:0]
=$af0207				TL0_TOTAL_Y_SIZE_H      = $AF0207
=$af0208				TL0_WINDOW_X_POS_L      = $AF0208       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0209				TL0_WINDOW_X_POS_H      = $AF0209       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af020a				TL0_WINDOW_Y_POS_L      = $AF020A       ; Top Left Corner Position of the TileMAp Window in Y
=$af020b				TL0_WINDOW_Y_POS_H      = $AF020B       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af020c				TL1_CONTROL_REG         = $AF020C       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af020d				TL1_START_ADDY_L        = $AF020D       ; Not USed right now - Starting Address to where is the MAP
=$af020e				TL1_START_ADDY_M        = $AF020E
=$af020f				TL1_START_ADDY_H        = $AF020F
=$af0210				TL1_TOTAL_X_SIZE_L      = $AF0210       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0211				TL1_TOTAL_X_SIZE_H      = $AF0211
=$af0212				TL1_TOTAL_Y_SIZE_L      = $AF0212       ; Size of the Map in Y Tile Count [9:0]
=$af0213				TL1_TOTAL_Y_SIZE_H      = $AF0213
=$af0214				TL1_WINDOW_X_POS_L      = $AF0214       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0215				TL1_WINDOW_X_POS_H      = $AF0215       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0216				TL1_WINDOW_Y_POS_L      = $AF0216       ; Top Left Corner Position of the TileMAp Window in Y
=$af0217				TL1_WINDOW_Y_POS_H      = $AF0217       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0218				TL2_CONTROL_REG         = $AF0218       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0219				TL2_START_ADDY_L        = $AF0219       ; Not USed right now - Starting Address to where is the MAP
=$af021a				TL2_START_ADDY_M        = $AF021A
=$af021b				TL2_START_ADDY_H        = $AF021B
=$af021c				TL2_TOTAL_X_SIZE_L      = $AF021C       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af021d				TL2_TOTAL_X_SIZE_H      = $AF021D
=$af021e				TL2_TOTAL_Y_SIZE_L      = $AF021E       ; Size of the Map in Y Tile Count [9:0]
=$af021f				TL2_TOTAL_Y_SIZE_H      = $AF021F
=$af0220				TL2_WINDOW_X_POS_L      = $AF0220       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0221				TL2_WINDOW_X_POS_H      = $AF0221       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0222				TL2_WINDOW_Y_POS_L      = $AF0222       ; Top Left Corner Position of the TileMAp Window in Y
=$af0223				TL2_WINDOW_Y_POS_H      = $AF0223       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0224				TL3_CONTROL_REG         = $AF0224       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0225				TL3_START_ADDY_L        = $AF0225       ; Not USed right now - Starting Address to where is the MAP
=$af0226				TL3_START_ADDY_M        = $AF0226
=$af0227				TL3_START_ADDY_H        = $AF0227
=$af0228				TL3_TOTAL_X_SIZE_L      = $AF0228       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0229				TL3_TOTAL_X_SIZE_H      = $AF0229
=$af022a				TL3_TOTAL_Y_SIZE_L      = $AF022A       ; Size of the Map in Y Tile Count [9:0]
=$af022b				TL3_TOTAL_Y_SIZE_H      = $AF022B
=$af022c				TL3_WINDOW_X_POS_L      = $AF022C       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af022d				TL3_WINDOW_X_POS_H      = $AF022D       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af022e				TL3_WINDOW_Y_POS_L      = $AF022E       ; Top Left Corner Position of the TileMAp Window in Y
=$af022f				TL3_WINDOW_Y_POS_H      = $AF022F       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0280				TILESET0_ADDY_L         = $AF0280   ; Pointer to Tileset 0 [21:0]
=$af0281				TILESET0_ADDY_M         = $AF0281
=$af0282				TILESET0_ADDY_H         = $AF0282
=$af0283				TILESET0_ADDY_CFG       = $AF0283   ; [3] - TileStride256x256 [2:0] LUT
=2					TILESET_ADDY_H          = 2             ; Offset to high byte of tile set address
=3					TILESET_ADDY_CFG        = 3             ; Offset to the tile set address configuration
=$08					TILESET_SQUARE_256      = $08
=$af0284				TILESET1_ADDY_L         = $AF0284
=$af0285				TILESET1_ADDY_M         = $AF0285
=$af0286				TILESET1_ADDY_H         = $AF0286
=$af0287				TILESET1_ADDY_CFG       = $AF0287
=$af0288				TILESET2_ADDY_L         = $AF0288
=$af0289				TILESET2_ADDY_M         = $AF0289
=$af028a				TILESET2_ADDY_H         = $AF028A
=$af028b				TILESET2_ADDY_CFG       = $AF028B
=$af028c				TILESET3_ADDY_L         = $AF028C
=$af028d				TILESET3_ADDY_M         = $AF028D
=$af028e				TILESET3_ADDY_H         = $AF028E
=$af028f				TILESET3_ADDY_CFG       = $AF028F
=$af0290				TILESET4_ADDY_L         = $AF0290
=$af0291				TILESET4_ADDY_M         = $AF0291
=$af0292				TILESET4_ADDY_H         = $AF0292
=$af0293				TILESET4_ADDY_CFG       = $AF0293
=$af0294				TILESET5_ADDY_L         = $AF0294
=$af0295				TILESET5_ADDY_M         = $AF0295
=$af0296				TILESET5_ADDY_H         = $AF0296
=$af0297				TILESET5_ADDY_CFG       = $AF0297
=$af0298				TILESET6_ADDY_L         = $AF0298
=$af0299				TILESET6_ADDY_M         = $AF0299
=$af029a				TILESET6_ADDY_H         = $AF029A
=$af029b				TILESET6_ADDY_CFG       = $AF029B
=$af029c				TILESET7_ADDY_L         = $AF029C
=$af029d				TILESET7_ADDY_M         = $AF029D
=$af029e				TILESET7_ADDY_H         = $AF029E
=$af029f				TILESET7_ADDY_CFG       = $AF029F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SDMA_def.s

=$af0420				SDMA_CTRL_REG0           = $AF0420
=$01					SDMA_CTRL0_Enable        = $01
=$02					SDMA_CTRL0_1D_2D         = $02     ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					SDMA_CTRL0_TRF_Fill      = $04     ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					SDMA_CTRL0_Int_Enable    = $08     ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					SDMA_CTRL0_SysRAM_Src    = $10     ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					SDMA_CTRL0_SysRAM_Dst    = $20     ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$00					SDMA_XFER_SRAM2SRAM = $00           ; SRAM -> SRAM transfer
=$10					SDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					SDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$30					SDMA_XFER_SRAMIO = $30              ; SRAM <-> IO transfer (see: SDMA_CONTROL_REG1 for config and direction)
=$40					SDMA_CTLR0_RSVD          = $40      ; Reserved
=$80					SDMA_CTRL0_Start_TRF     = $80      ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$af0421				SDMA_CTRL_REG1           = $AF0421  ; Write Only - Byte to Write in the Fill Function
=$01					SDMA_CTRL1_IO_Src		 = $01		; 1 = Source is an IO Address (ADC, SuperIO, IDE)
=$02					SDMA_CTRL1_IO_Src16		 = $02		; 0 = Src 8Bits Transfer / 1= 16Bits Transfer
=$04					SDMA_CTRL1_IO_Dst		 = $04		; 1 = Destination is an IO Address (DAC, SuperIO, IDE)
=$08					SDMA_CTRL1_IO_Dst16      = $08      ; 0 = Dst 8bits Transfer / 1= 16bits
=$af0422				SDMA_SRC_ADDY_L         = $AF0422   ; Pointer to the Source of the Data to be stransfered
=$af0423				SDMA_SRC_ADDY_M         = $AF0423   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0424				SDMA_SRC_ADDY_H         = $AF0424
=$af0425				SDMA_DST_ADDY_L         = $AF0425   ; Destination Pointer within CPU's video memory Range
=$af0426				SDMA_DST_ADDY_M         = $AF0426   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0427				SDMA_DST_ADDY_H         = $AF0427
=$af0428				SDMA_SIZE_L             = $AF0428   ; Maximum Value: $40:0000 (4Megs)
=$af0429				SDMA_SIZE_M             = $AF0429
=$af042a				SDMA_SIZE_H             = $AF042A
=$af042b				SDMA_IGNORED            = $AF042B
=$af0428				SDMA_X_SIZE_L           = $AF0428   ; Maximum Value: 65535
=$af0429				SDMA_X_SIZE_H           = $AF0429
=$af042a				SDMA_Y_SIZE_L           = $AF042A   ; Maximum Value: 65535
=$af042b				SDMA_Y_SIZE_H           = $AF042B
=$af042c				SDMA_SRC_STRIDE_L       = $AF042C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042d				SDMA_SRC_STRIDE_H       = $AF042D   ;
=$af042e				SDMA_DST_STRIDE_L       = $AF042E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042f				SDMA_DST_STRIDE_H       = $AF042F   ;
=$af0430				SDMA_BYTE_2_WRITE       = $AF0430   ; Write Only - Byte to Write in the Fill Function
=$af0430				SDMA_STATUS_REG         = $AF0430   ; Read only
=$01					SDMA_STAT_Size_Err       = $01      ; If Set to 1, Overall Size is Invalid
=$02					SDMA_STAT_Dst_Add_Err    = $02      ; If Set to 1, Destination Address Invalid
=$04					SDMA_STAT_Src_Add_Err    = $04      ; If Set to 1, Source Address Invalid
=$08					SDMA_STAT_TimeOut_Err    = $08      ; will be set to 1 if a Timeout occur when transfering between data from and to VRAM

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_VDMA_def.s

=$af0400				VDMA_CONTROL_REG        = $AF0400
=$01					VDMA_CTRL_Enable        = $01
=$02					VDMA_CTRL_1D_2D         = $02       ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					VDMA_CTRL_TRF_Fill      = $04       ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					VDMA_CTRL_Int_Enable    = $08       ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					VDMA_CTRL_SysRAM_Src    = $10       ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					VDMA_CTRL_SysRAM_Dst    = $20       ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$80					VDMA_CTRL_Start_TRF     = $80       ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$00					VDMA_XFER_VRAM2VRAM = $00           ; VRAM -> VRAM transfer
=$10					VDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					VDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$af0401				VDMA_BYTE_2_WRITE       = $AF0401   ; Write Only - Byte to Write in the Fill Function
=$af0401				VDMA_STATUS_REG         = $AF0401   ; Read only
=$01					VDMA_STAT_Size_Err      = $01       ; If Set to 1, Overall Size is Invalid
=$02					VDMA_STAT_Dst_Add_Err   = $02       ; If Set to 1, Destination Address Invalid
=$04					VDMA_STAT_Src_Add_Err   = $04       ; If Set to 1, Source Address Invalid
=$80					VDMA_STAT_VDMA_IPS      = $80       ; If Set to 1, VDMA Transfer in Progress (this Inhibit CPU Access to Mem)
=$af0402				VDMA_SRC_ADDY_L         = $AF0402   ; Pointer to the Source of the Data to be stransfered
=$af0403				VDMA_SRC_ADDY_M         = $AF0403   ; This needs to be within Vicky's Range ($00_0000 - $3F_0000)
=$af0404				VDMA_SRC_ADDY_H         = $AF0404
=$af0405				VDMA_DST_ADDY_L         = $AF0405   ; Destination Pointer within Vicky's video memory Range
=$af0406				VDMA_DST_ADDY_M         = $AF0406   ; ($00_0000 - $3F_0000)
=$af0407				VDMA_DST_ADDY_H         = $AF0407
=$af0408				VDMA_SIZE_L             = $AF0408   ; Maximum Value: $40:0000 (4Megs)
=$af0409				VDMA_SIZE_M             = $AF0409
=$af040a				VDMA_SIZE_H             = $AF040A
=$af040b				VDMA_IGNORED            = $AF040B
=$af0408				VDMA_X_SIZE_L           = $AF0408   ; Maximum Value: 65535
=$af0409				VDMA_X_SIZE_H           = $AF0409
=$af040a				VDMA_Y_SIZE_L           = $AF040A   ; Maximum Value: 65535
=$af040b				VDMA_Y_SIZE_H           = $AF040B
=$af040c				VDMA_SRC_STRIDE_L       = $AF040C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040d				VDMA_SRC_STRIDE_H       = $AF040D   ;
=$af040e				VDMA_DST_STRIDE_L       = $AF040E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040f				VDMA_DST_STRIDE_H       = $AF040F   ;

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SPRITE_def.s

=$01					SPRITE_Enable             = $01
=$00					SPRITE_LUT0               = $00 ; This is the LUT that the Sprite will use
=$02					SPRITE_LUT1               = $02
=$04					SPRITE_LUT2               = $04 ; Only 4 LUT for Now, So this bit is not used.
=$06					SPRITE_LUT3               = $06 ; Only 4 LUT for Now, So this bit is not used.
=$08					SPRITE_LUT4               = $08 ; Only 4 LUT for Now, So this bit is not used.
=$0a					SPRITE_LUT5               = $0A ; Only 4 LUT for Now, So this bit is not used.
=$0c					SPRITE_LUT6               = $0C ; Only 4 LUT for Now, So this bit is not used.
=$0e					SPRITE_LUT7               = $0E ; Only 4 LUT for Now, So this bit is not used.
=$00					SPRITE_DEPTH0             = $00
=$10					SPRITE_DEPTH1             = $10
=$20					SPRITE_DEPTH2             = $20
=$30					SPRITE_DEPTH3             = $30
=$40					SPRITE_DEPTH4             = $40
=$50					SPRITE_DEPTH5             = $50
=$60					SPRITE_DEPTH6             = $60
=$af0c00				SP00_CONTROL_REG        = $AF0C00
=$af0c01				SP00_ADDY_PTR_L         = $AF0C01
=$af0c02				SP00_ADDY_PTR_M         = $AF0C02
=$af0c03				SP00_ADDY_PTR_H         = $AF0C03
=$af0c04				SP00_X_POS_L            = $AF0C04
=$af0c05				SP00_X_POS_H            = $AF0C05
=$af0c06				SP00_Y_POS_L            = $AF0C06
=$af0c07				SP00_Y_POS_H            = $AF0C07
=$af0c08				SP01_CONTROL_REG        = $AF0C08
=$af0c09				SP01_ADDY_PTR_L         = $AF0C09
=$af0c0a				SP01_ADDY_PTR_M         = $AF0C0A
=$af0c0b				SP01_ADDY_PTR_H         = $AF0C0B
=$af0c0c				SP01_X_POS_L            = $AF0C0C
=$af0c0d				SP01_X_POS_H            = $AF0C0D
=$af0c0e				SP01_Y_POS_L            = $AF0C0E
=$af0c0f				SP01_Y_POS_H            = $AF0C0F
=$af0c10				SP02_CONTROL_REG        = $AF0C10
=$af0c11				SP02_ADDY_PTR_L         = $AF0C11
=$af0c12				SP02_ADDY_PTR_M         = $AF0C12
=$af0c13				SP02_ADDY_PTR_H         = $AF0C13
=$af0c14				SP02_X_POS_L            = $AF0C14
=$af0c15				SP02_X_POS_H            = $AF0C15
=$af0c16				SP02_Y_POS_L            = $AF0C16
=$af0c17				SP02_Y_POS_H            = $AF0C17
=$af0c18				SP03_CONTROL_REG        = $AF0C18
=$af0c19				SP03_ADDY_PTR_L         = $AF0C19
=$af0c1a				SP03_ADDY_PTR_M         = $AF0C1A
=$af0c1b				SP03_ADDY_PTR_H         = $AF0C1B
=$af0c1c				SP03_X_POS_L            = $AF0C1C
=$af0c1d				SP03_X_POS_H            = $AF0C1D
=$af0c1e				SP03_Y_POS_L            = $AF0C1E
=$af0c1f				SP03_Y_POS_H            = $AF0C1F
=$af0c20				SP04_CONTROL_REG        = $AF0C20
=$af0c21				SP04_ADDY_PTR_L         = $AF0C21
=$af0c22				SP04_ADDY_PTR_M         = $AF0C22
=$af0c23				SP04_ADDY_PTR_H         = $AF0C23
=$af0c24				SP04_X_POS_L            = $AF0C24
=$af0c25				SP04_X_POS_H            = $AF0C25
=$af0c26				SP04_Y_POS_L            = $AF0C26
=$af0c27				SP04_Y_POS_H            = $AF0C27
=$af0c28				SP05_CONTROL_REG        = $AF0C28
=$af0c29				SP05_ADDY_PTR_L         = $AF0C29
=$af0c2a				SP05_ADDY_PTR_M         = $AF0C2A
=$af0c2b				SP05_ADDY_PTR_H         = $AF0C2B
=$af0c2c				SP05_X_POS_L            = $AF0C2C
=$af0c2d				SP05_X_POS_H            = $AF0C2D
=$af0c2e				SP05_Y_POS_L            = $AF0C2E
=$af0c2f				SP05_Y_POS_H            = $AF0C2F
=$af0c30				SP06_CONTROL_REG        = $AF0C30
=$af0c31				SP06_ADDY_PTR_L         = $AF0C31
=$af0c32				SP06_ADDY_PTR_M         = $AF0C32
=$af0c33				SP06_ADDY_PTR_H         = $AF0C33
=$af0c34				SP06_X_POS_L            = $AF0C34
=$af0c35				SP06_X_POS_H            = $AF0C35
=$af0c36				SP06_Y_POS_L            = $AF0C36
=$af0c37				SP06_Y_POS_H            = $AF0C37
=$af0c38				SP07_CONTROL_REG        = $AF0C38
=$af0c39				SP07_ADDY_PTR_L         = $AF0C39
=$af0c3a				SP07_ADDY_PTR_M         = $AF0C3A
=$af0c3b				SP07_ADDY_PTR_H         = $AF0C3B
=$af0c3c				SP07_X_POS_L            = $AF0C3C
=$af0c3d				SP07_X_POS_H            = $AF0C3D
=$af0c3e				SP07_Y_POS_L            = $AF0C3E
=$af0c3f				SP07_Y_POS_H            = $AF0C3F
=$af0c40				SP08_CONTROL_REG        = $AF0C40
=$af0c41				SP08_ADDY_PTR_L         = $AF0C41
=$af0c42				SP08_ADDY_PTR_M         = $AF0C42
=$af0c43				SP08_ADDY_PTR_H         = $AF0C43
=$af0c44				SP08_X_POS_L            = $AF0C44
=$af0c45				SP08_X_POS_H            = $AF0C45
=$af0c46				SP08_Y_POS_L            = $AF0C46
=$af0c47				SP08_Y_POS_H            = $AF0C47
=$af0c48				SP09_CONTROL_REG        = $AF0C48
=$af0c49				SP09_ADDY_PTR_L         = $AF0C49
=$af0c4a				SP09_ADDY_PTR_M         = $AF0C4A
=$af0c4b				SP09_ADDY_PTR_H         = $AF0C4B
=$af0c4c				SP09_X_POS_L            = $AF0C4C
=$af0c4d				SP09_X_POS_H            = $AF0C4D
=$af0c4e				SP09_Y_POS_L            = $AF0C4E
=$af0c4f				SP09_Y_POS_H            = $AF0C4F
=$af0c50				SP10_CONTROL_REG        = $AF0C50
=$af0c51				SP10_ADDY_PTR_L         = $AF0C51
=$af0c52				SP10_ADDY_PTR_M         = $AF0C52
=$af0c53				SP10_ADDY_PTR_H         = $AF0C53
=$af0c54				SP10_X_POS_L            = $AF0C54
=$af0c55				SP10_X_POS_H            = $AF0C55
=$af0c56				SP10_Y_POS_L            = $AF0C56
=$af0c57				SP10_Y_POS_H            = $AF0C57
=$af0c58				SP11_CONTROL_REG        = $AF0C58
=$af0c59				SP11_ADDY_PTR_L         = $AF0C59
=$af0c5a				SP11_ADDY_PTR_M         = $AF0C5A
=$af0c5b				SP11_ADDY_PTR_H         = $AF0C5B
=$af0c5c				SP11_X_POS_L            = $AF0C5C
=$af0c5d				SP11_X_POS_H            = $AF0C5D
=$af0c5e				SP11_Y_POS_L            = $AF0C5E
=$af0c5f				SP11_Y_POS_H            = $AF0C5F
=$af0c60				SP12_CONTROL_REG        = $AF0C60
=$af0c61				SP12_ADDY_PTR_L         = $AF0C61
=$af0c62				SP12_ADDY_PTR_M         = $AF0C62
=$af0c63				SP12_ADDY_PTR_H         = $AF0C63
=$af0c64				SP12_X_POS_L            = $AF0C64
=$af0c65				SP12_X_POS_H            = $AF0C65
=$af0c66				SP12_Y_POS_L            = $AF0C66
=$af0c67				SP12_Y_POS_H            = $AF0C67
=$af0c68				SP13_CONTROL_REG        = $AF0C68
=$af0c69				SP13_ADDY_PTR_L         = $AF0C69
=$af0c6a				SP13_ADDY_PTR_M         = $AF0C6A
=$af0c6b				SP13_ADDY_PTR_H         = $AF0C6B
=$af0c6c				SP13_X_POS_L            = $AF0C6C
=$af0c6d				SP13_X_POS_H            = $AF0C6D
=$af0c6e				SP13_Y_POS_L            = $AF0C6E
=$af0c6f				SP13_Y_POS_H            = $AF0C6F
=$af0c70				SP14_CONTROL_REG        = $AF0C70
=$af0c71				SP14_ADDY_PTR_L         = $AF0C71
=$af0c72				SP14_ADDY_PTR_M         = $AF0C72
=$af0c73				SP14_ADDY_PTR_H         = $AF0C73
=$af0c74				SP14_X_POS_L            = $AF0C74
=$af0c75				SP14_X_POS_H            = $AF0C75
=$af0c76				SP14_Y_POS_L            = $AF0C76
=$af0c77				SP14_Y_POS_H            = $AF0C77
=$af0c78				SP15_CONTROL_REG        = $AF0C78
=$af0c79				SP15_ADDY_PTR_L         = $AF0C79
=$af0c7a				SP15_ADDY_PTR_M         = $AF0C7A
=$af0c7b				SP15_ADDY_PTR_H         = $AF0C7B
=$af0c7c				SP15_X_POS_L            = $AF0C7C
=$af0c7d				SP15_X_POS_H            = $AF0C7D
=$af0c7e				SP15_Y_POS_L            = $AF0C7E
=$af0c7f				SP15_Y_POS_H            = $AF0C7F
=$af0c80				SP16_CONTROL_REG        = $AF0C80
=$af0c81				SP16_ADDY_PTR_L         = $AF0C81
=$af0c82				SP16_ADDY_PTR_M         = $AF0C82
=$af0c83				SP16_ADDY_PTR_H         = $AF0C83
=$af0c84				SP16_X_POS_L            = $AF0C84
=$af0c85				SP16_X_POS_H            = $AF0C85
=$af0c86				SP16_Y_POS_L            = $AF0C86
=$af0c87				SP16_Y_POS_H            = $AF0C87
=$af0c88				SP17_CONTROL_REG        = $AF0C88
=$af0c89				SP17_ADDY_PTR_L         = $AF0C89
=$af0c8a				SP17_ADDY_PTR_M         = $AF0C8A
=$af0c8b				SP17_ADDY_PTR_H         = $AF0C8B
=$af0c8c				SP17_X_POS_L            = $AF0C8C
=$af0c8d				SP17_X_POS_H            = $AF0C8D
=$af0c8e				SP17_Y_POS_L            = $AF0C8E
=$af0c8f				SP17_Y_POS_H            = $AF0C8F
=$af0c90				SP18_CONTROL_REG        = $AF0C90
=$af0c91				SP18_ADDY_PTR_L         = $AF0C91
=$af0c92				SP18_ADDY_PTR_M         = $AF0C92
=$af0c93				SP18_ADDY_PTR_H         = $AF0C93
=$af0c94				SP18_X_POS_L            = $AF0C94
=$af0c95				SP18_X_POS_H            = $AF0C95
=$af0c96				SP18_Y_POS_L            = $AF0C96
=$af0c97				SP18_Y_POS_H            = $AF0C97
=$af0c98				SP19_CONTROL_REG        = $AF0C98
=$af0c99				SP19_ADDY_PTR_L         = $AF0C99
=$af0c9a				SP19_ADDY_PTR_M         = $AF0C9A
=$af0c9b				SP19_ADDY_PTR_H         = $AF0C9B
=$af0c9c				SP19_X_POS_L            = $AF0C9C
=$af0c9d				SP19_X_POS_H            = $AF0C9D
=$af0c9e				SP19_Y_POS_L            = $AF0C9E
=$af0c9f				SP19_Y_POS_H            = $AF0C9F
=$af0ca0				SP20_CONTROL_REG        = $AF0CA0
=$af0ca1				SP20_ADDY_PTR_L         = $AF0CA1
=$af0ca2				SP20_ADDY_PTR_M         = $AF0CA2
=$af0ca3				SP20_ADDY_PTR_H         = $AF0CA3
=$af0ca4				SP20_X_POS_L            = $AF0CA4
=$af0ca5				SP20_X_POS_H            = $AF0CA5
=$af0ca6				SP20_Y_POS_L            = $AF0CA6
=$af0ca7				SP20_Y_POS_H            = $AF0CA7
=$af0ca8				SP21_CONTROL_REG        = $AF0CA8
=$af0ca9				SP21_ADDY_PTR_L         = $AF0CA9
=$af0caa				SP21_ADDY_PTR_M         = $AF0CAA
=$af0cab				SP21_ADDY_PTR_H         = $AF0CAB
=$af0cac				SP21_X_POS_L            = $AF0CAC
=$af0cad				SP21_X_POS_H            = $AF0CAD
=$af0cae				SP21_Y_POS_L            = $AF0CAE
=$af0caf				SP21_Y_POS_H            = $AF0CAF
=$af0cb0				SP22_CONTROL_REG        = $AF0CB0
=$af0cb1				SP22_ADDY_PTR_L         = $AF0CB1
=$af0cb2				SP22_ADDY_PTR_M         = $AF0CB2
=$af0cb3				SP22_ADDY_PTR_H         = $AF0CB3
=$af0cb4				SP22_X_POS_L            = $AF0CB4
=$af0cb5				SP22_X_POS_H            = $AF0CB5
=$af0cb6				SP22_Y_POS_L            = $AF0CB6
=$af0cb7				SP22_Y_POS_H            = $AF0CB7
=$af0cb8				SP23_CONTROL_REG        = $AF0CB8
=$af0cb9				SP23_ADDY_PTR_L         = $AF0CB9
=$af0cba				SP23_ADDY_PTR_M         = $AF0CBA
=$af0cbb				SP23_ADDY_PTR_H         = $AF0CBB
=$af0cbc				SP23_X_POS_L            = $AF0CBC
=$af0cbd				SP23_X_POS_H            = $AF0CBD
=$af0cbe				SP23_Y_POS_L            = $AF0CBE
=$af0cbf				SP23_Y_POS_H            = $AF0CBF
=$af0cc0				SP24_CONTROL_REG        = $AF0CC0
=$af0cc1				SP24_ADDY_PTR_L         = $AF0CC1
=$af0cc2				SP24_ADDY_PTR_M         = $AF0CC2
=$af0cc3				SP24_ADDY_PTR_H         = $AF0CC3
=$af0cc4				SP24_X_POS_L            = $AF0CC4
=$af0cc5				SP24_X_POS_H            = $AF0CC5
=$af0cc6				SP24_Y_POS_L            = $AF0CC6
=$af0cc7				SP24_Y_POS_H            = $AF0CC7
=$af0cc8				SP25_CONTROL_REG        = $AF0CC8
=$af0cc9				SP25_ADDY_PTR_L         = $AF0CC9
=$af0cca				SP25_ADDY_PTR_M         = $AF0CCA
=$af0ccb				SP25_ADDY_PTR_H         = $AF0CCB
=$af0ccc				SP25_X_POS_L            = $AF0CCC
=$af0ccd				SP25_X_POS_H            = $AF0CCD
=$af0cce				SP25_Y_POS_L            = $AF0CCE
=$af0ccf				SP25_Y_POS_H            = $AF0CCF
=$af0cd0				SP26_CONTROL_REG        = $AF0CD0
=$af0cd1				SP26_ADDY_PTR_L         = $AF0CD1
=$af0cd2				SP26_ADDY_PTR_M         = $AF0CD2
=$af0cd3				SP26_ADDY_PTR_H         = $AF0CD3
=$af0cd4				SP26_X_POS_L            = $AF0CD4
=$af0cd5				SP26_X_POS_H            = $AF0CD5
=$af0cd6				SP26_Y_POS_L            = $AF0CD6
=$af0cd7				SP26_Y_POS_H            = $AF0CD7
=$af0cd8				SP27_CONTROL_REG        = $AF0CD8
=$af0cd9				SP27_ADDY_PTR_L         = $AF0CD9
=$af0cda				SP27_ADDY_PTR_M         = $AF0CDA
=$af0cdb				SP27_ADDY_PTR_H         = $AF0CDB
=$af0cdc				SP27_X_POS_L            = $AF0CDC
=$af0cdd				SP27_X_POS_H            = $AF0CDD
=$af0cde				SP27_Y_POS_L            = $AF0CDE
=$af0cdf				SP27_Y_POS_H            = $AF0CDF
=$af0ce0				SP28_CONTROL_REG        = $AF0CE0
=$af0ce1				SP28_ADDY_PTR_L         = $AF0CE1
=$af0ce2				SP28_ADDY_PTR_M         = $AF0CE2
=$af0ce3				SP28_ADDY_PTR_H         = $AF0CE3
=$af0ce4				SP28_X_POS_L            = $AF0CE4
=$af0ce5				SP28_X_POS_H            = $AF0CE5
=$af0ce6				SP28_Y_POS_L            = $AF0CE6
=$af0ce7				SP28_Y_POS_H            = $AF0CE7
=$af0ce8				SP29_CONTROL_REG        = $AF0CE8
=$af0ce9				SP29_ADDY_PTR_L         = $AF0CE9
=$af0cea				SP29_ADDY_PTR_M         = $AF0CEA
=$af0ceb				SP29_ADDY_PTR_H         = $AF0CEB
=$af0cec				SP29_X_POS_L            = $AF0CEC
=$af0ced				SP29_X_POS_H            = $AF0CED
=$af0cee				SP29_Y_POS_L            = $AF0CEE
=$af0cef				SP29_Y_POS_H            = $AF0CEF
=$af0cf0				SP30_CONTROL_REG        = $AF0CF0
=$af0cf1				SP30_ADDY_PTR_L         = $AF0CF1
=$af0cf2				SP30_ADDY_PTR_M         = $AF0CF2
=$af0cf3				SP30_ADDY_PTR_H         = $AF0CF3
=$af0cf4				SP30_X_POS_L            = $AF0CF4
=$af0cf5				SP30_X_POS_H            = $AF0CF5
=$af0cf6				SP30_Y_POS_L            = $AF0CF6
=$af0cf7				SP30_Y_POS_H            = $AF0CF7
=$af0cf8				SP31_CONTROL_REG        = $AF0CF8
=$af0cf9				SP31_ADDY_PTR_L         = $AF0CF9
=$af0cfa				SP31_ADDY_PTR_M         = $AF0CFA
=$af0cfb				SP31_ADDY_PTR_H         = $AF0CFB
=$af0cfc				SP31_X_POS_L            = $AF0CFC
=$af0cfd				SP31_X_POS_H            = $AF0CFD
=$af0cfe				SP31_Y_POS_L            = $AF0CFE
=$af0cff				SP31_Y_POS_H            = $AF0CFF
=$af0d00				SP32_CONTROL_REG        = $AF0D00
=$af0d01				SP32_ADDY_PTR_L         = $AF0D01
=$af0d02				SP32_ADDY_PTR_M         = $AF0D02
=$af0d03				SP32_ADDY_PTR_H         = $AF0D03
=$af0d04				SP32_X_POS_L            = $AF0D04
=$af0d05				SP32_X_POS_H            = $AF0D05
=$af0d06				SP32_Y_POS_L            = $AF0D06
=$af0d07				SP32_Y_POS_H            = $AF0D07
=$af0d08				SP33_CONTROL_REG        = $AF0D08
=$af0d09				SP33_ADDY_PTR_L         = $AF0D09
=$af0d0a				SP33_ADDY_PTR_M         = $AF0D0A
=$af0d0b				SP33_ADDY_PTR_H         = $AF0D0B
=$af0d0c				SP33_X_POS_L            = $AF0D0C
=$af0d0d				SP33_X_POS_H            = $AF0D0D
=$af0d0e				SP33_Y_POS_L            = $AF0D0E
=$af0d0f				SP33_Y_POS_H            = $AF0D0F
=$af0d10				SP34_CONTROL_REG        = $AF0D10
=$af0d11				SP34_ADDY_PTR_L         = $AF0D11
=$af0d12				SP34_ADDY_PTR_M         = $AF0D12
=$af0d13				SP34_ADDY_PTR_H         = $AF0D13
=$af0d14				SP34_X_POS_L            = $AF0D14
=$af0d15				SP34_X_POS_H            = $AF0D15
=$af0d16				SP34_Y_POS_L            = $AF0D16
=$af0d17				SP34_Y_POS_H            = $AF0D17
=$af0d18				SP35_CONTROL_REG        = $AF0D18
=$af0d19				SP35_ADDY_PTR_L         = $AF0D19
=$af0d1a				SP35_ADDY_PTR_M         = $AF0D1A
=$af0d1b				SP35_ADDY_PTR_H         = $AF0D1B
=$af0d1c				SP35_X_POS_L            = $AF0D1C
=$af0d1d				SP35_X_POS_H            = $AF0D1D
=$af0d1e				SP35_Y_POS_L            = $AF0D1E
=$af0d1f				SP35_Y_POS_H            = $AF0D1F
=$af0d20				SP36_CONTROL_REG        = $AF0D20
=$af0d21				SP36_ADDY_PTR_L         = $AF0D21
=$af0d22				SP36_ADDY_PTR_M         = $AF0D22
=$af0d23				SP36_ADDY_PTR_H         = $AF0D23
=$af0d24				SP36_X_POS_L            = $AF0D24
=$af0d25				SP36_X_POS_H            = $AF0D25
=$af0d26				SP36_Y_POS_L            = $AF0D26
=$af0d27				SP36_Y_POS_H            = $AF0D27
=$af0d28				SP37_CONTROL_REG        = $AF0D28
=$af0d29				SP37_ADDY_PTR_L         = $AF0D29
=$af0d2a				SP37_ADDY_PTR_M         = $AF0D2A
=$af0d2b				SP37_ADDY_PTR_H         = $AF0D2B
=$af0d2c				SP37_X_POS_L            = $AF0D2C
=$af0d2d				SP37_X_POS_H            = $AF0D2D
=$af0d2e				SP37_Y_POS_L            = $AF0D2E
=$af0d2f				SP37_Y_POS_H            = $AF0D2F
=$af0d30				SP38_CONTROL_REG        = $AF0D30
=$af0d31				SP38_ADDY_PTR_L         = $AF0D31
=$af0d32				SP38_ADDY_PTR_M         = $AF0D32
=$af0d33				SP38_ADDY_PTR_H         = $AF0D33
=$af0d34				SP38_X_POS_L            = $AF0D34
=$af0d35				SP38_X_POS_H            = $AF0D35
=$af0d36				SP38_Y_POS_L            = $AF0D36
=$af0d37				SP38_Y_POS_H            = $AF0D37
=$af0d38				SP39_CONTROL_REG        = $AF0D38
=$af0d39				SP39_ADDY_PTR_L         = $AF0D39
=$af0d3a				SP39_ADDY_PTR_M         = $AF0D3A
=$af0d3b				SP39_ADDY_PTR_H         = $AF0D3B
=$af0d3c				SP39_X_POS_L            = $AF0D3C
=$af0d3d				SP39_X_POS_H            = $AF0D3D
=$af0d3e				SP39_Y_POS_L            = $AF0D3E
=$af0d3f				SP39_Y_POS_H            = $AF0D3F
=$af0d40				SP40_CONTROL_REG        = $AF0D40
=$af0d41				SP40_ADDY_PTR_L         = $AF0D41
=$af0d42				SP40_ADDY_PTR_M         = $AF0D42
=$af0d43				SP40_ADDY_PTR_H         = $AF0D43
=$af0d44				SP40_X_POS_L            = $AF0D44
=$af0d45				SP40_X_POS_H            = $AF0D45
=$af0d46				SP40_Y_POS_L            = $AF0D46
=$af0d47				SP40_Y_POS_H            = $AF0D47
=$af0d48				SP41_CONTROL_REG        = $AF0D48
=$af0d49				SP41_ADDY_PTR_L         = $AF0D49
=$af0d4a				SP41_ADDY_PTR_M         = $AF0D4A
=$af0d4b				SP41_ADDY_PTR_H         = $AF0D4B
=$af0d4c				SP41_X_POS_L            = $AF0D4C
=$af0d4d				SP41_X_POS_H            = $AF0D4D
=$af0d4e				SP41_Y_POS_L            = $AF0D4E
=$af0d4f				SP41_Y_POS_H            = $AF0D4F
=$af0d50				SP42_CONTROL_REG        = $AF0D50
=$af0d51				SP42_ADDY_PTR_L         = $AF0D51
=$af0d52				SP42_ADDY_PTR_M         = $AF0D52
=$af0d53				SP42_ADDY_PTR_H         = $AF0D53
=$af0d54				SP42_X_POS_L            = $AF0D54
=$af0d55				SP42_X_POS_H            = $AF0D55
=$af0d56				SP42_Y_POS_L            = $AF0D56
=$af0d57				SP42_Y_POS_H            = $AF0D57
=$af0d58				SP43_CONTROL_REG        = $AF0D58
=$af0d59				SP43_ADDY_PTR_L         = $AF0D59
=$af0d5a				SP43_ADDY_PTR_M         = $AF0D5A
=$af0d5b				SP43_ADDY_PTR_H         = $AF0D5B
=$af0d5c				SP43_X_POS_L            = $AF0D5C
=$af0d5d				SP43_X_POS_H            = $AF0D5D
=$af0d5e				SP43_Y_POS_L            = $AF0D5E
=$af0d5f				SP43_Y_POS_H            = $AF0D5F
=$af0d60				SP44_CONTROL_REG        = $AF0D60
=$af0d61				SP44_ADDY_PTR_L         = $AF0D61
=$af0d62				SP44_ADDY_PTR_M         = $AF0D62
=$af0d63				SP44_ADDY_PTR_H         = $AF0D63
=$af0d64				SP44_X_POS_L            = $AF0D64
=$af0d65				SP44_X_POS_H            = $AF0D65
=$af0d66				SP44_Y_POS_L            = $AF0D66
=$af0d67				SP44_Y_POS_H            = $AF0D67
=$af0d68				SP45_CONTROL_REG        = $AF0D68
=$af0d69				SP45_ADDY_PTR_L         = $AF0D69
=$af0d6a				SP45_ADDY_PTR_M         = $AF0D6A
=$af0d6b				SP45_ADDY_PTR_H         = $AF0D6B
=$af0d6c				SP45_X_POS_L            = $AF0D6C
=$af0d6d				SP45_X_POS_H            = $AF0D6D
=$af0d6e				SP45_Y_POS_L            = $AF0D6E
=$af0d6f				SP45_Y_POS_H            = $AF0D6F
=$af0d70				SP46_CONTROL_REG        = $AF0D70
=$af0d71				SP46_ADDY_PTR_L         = $AF0D71
=$af0d72				SP46_ADDY_PTR_M         = $AF0D72
=$af0d73				SP46_ADDY_PTR_H         = $AF0D73
=$af0d74				SP46_X_POS_L            = $AF0D74
=$af0d75				SP46_X_POS_H            = $AF0D75
=$af0d76				SP46_Y_POS_L            = $AF0D76
=$af0d77				SP46_Y_POS_H            = $AF0D77
=$af0d78				SP47_CONTROL_REG        = $AF0D78
=$af0d79				SP47_ADDY_PTR_L         = $AF0D79
=$af0d7a				SP47_ADDY_PTR_M         = $AF0D7A
=$af0d7b				SP47_ADDY_PTR_H         = $AF0D7B
=$af0d7c				SP47_X_POS_L            = $AF0D7C
=$af0d7d				SP47_X_POS_H            = $AF0D7D
=$af0d7e				SP47_Y_POS_L            = $AF0D7E
=$af0d7f				SP47_Y_POS_H            = $AF0D7F
=$af0d80				SP48_CONTROL_REG        = $AF0D80
=$af0d81				SP48_ADDY_PTR_L         = $AF0D81
=$af0d82				SP48_ADDY_PTR_M         = $AF0D82
=$af0d83				SP48_ADDY_PTR_H         = $AF0D83
=$af0d84				SP48_X_POS_L            = $AF0D84
=$af0d85				SP48_X_POS_H            = $AF0D85
=$af0d86				SP48_Y_POS_L            = $AF0D86
=$af0d87				SP48_Y_POS_H            = $AF0D87
=$af0d88				SP49_CONTROL_REG        = $AF0D88
=$af0d89				SP49_ADDY_PTR_L         = $AF0D89
=$af0d8a				SP49_ADDY_PTR_M         = $AF0D8A
=$af0d8b				SP49_ADDY_PTR_H         = $AF0D8B
=$af0d8c				SP49_X_POS_L            = $AF0D8C
=$af0d8d				SP49_X_POS_H            = $AF0D8D
=$af0d8e				SP49_Y_POS_L            = $AF0D8E
=$af0d8f				SP49_Y_POS_H            = $AF0D8F
=$af0d90				SP50_CONTROL_REG        = $AF0D90
=$af0d91				SP50_ADDY_PTR_L         = $AF0D91
=$af0d92				SP50_ADDY_PTR_M         = $AF0D92
=$af0d93				SP50_ADDY_PTR_H         = $AF0D93
=$af0d94				SP50_X_POS_L            = $AF0D94
=$af0d95				SP50_X_POS_H            = $AF0D95
=$af0d96				SP50_Y_POS_L            = $AF0D96
=$af0d97				SP50_Y_POS_H            = $AF0D97
=$af0d98				SP51_CONTROL_REG        = $AF0D98
=$af0d99				SP51_ADDY_PTR_L         = $AF0D99
=$af0d9a				SP51_ADDY_PTR_M         = $AF0D9A
=$af0d9b				SP51_ADDY_PTR_H         = $AF0D9B
=$af0d9c				SP51_X_POS_L            = $AF0D9C
=$af0d9d				SP51_X_POS_H            = $AF0D9D
=$af0d9e				SP51_Y_POS_L            = $AF0D9E
=$af0d9f				SP51_Y_POS_H            = $AF0D9F
=$af0da0				SP52_CONTROL_REG        = $AF0DA0
=$af0da1				SP52_ADDY_PTR_L         = $AF0DA1
=$af0da2				SP52_ADDY_PTR_M         = $AF0DA2
=$af0da3				SP52_ADDY_PTR_H         = $AF0DA3
=$af0da4				SP52_X_POS_L            = $AF0DA4
=$af0da5				SP52_X_POS_H            = $AF0DA5
=$af0da6				SP52_Y_POS_L            = $AF0DA6
=$af0da7				SP52_Y_POS_H            = $AF0DA7
=$af0da8				SP53_CONTROL_REG        = $AF0DA8
=$af0da9				SP53_ADDY_PTR_L         = $AF0DA9
=$af0daa				SP53_ADDY_PTR_M         = $AF0DAA
=$af0dab				SP53_ADDY_PTR_H         = $AF0DAB
=$af0dac				SP53_X_POS_L            = $AF0DAC
=$af0dad				SP53_X_POS_H            = $AF0DAD
=$af0dae				SP53_Y_POS_L            = $AF0DAE
=$af0daf				SP53_Y_POS_H            = $AF0DAF
=$af0db0				SP54_CONTROL_REG        = $AF0DB0
=$af0db1				SP54_ADDY_PTR_L         = $AF0DB1
=$af0db2				SP54_ADDY_PTR_M         = $AF0DB2
=$af0db3				SP54_ADDY_PTR_H         = $AF0DB3
=$af0db4				SP54_X_POS_L            = $AF0DB4
=$af0db5				SP54_X_POS_H            = $AF0DB5
=$af0db6				SP54_Y_POS_L            = $AF0DB6
=$af0db7				SP54_Y_POS_H            = $AF0DB7
=$af0db8				SP55_CONTROL_REG        = $AF0DB8
=$af0db9				SP55_ADDY_PTR_L         = $AF0DB9
=$af0dba				SP55_ADDY_PTR_M         = $AF0DBA
=$af0dbb				SP55_ADDY_PTR_H         = $AF0DBB
=$af0dbc				SP55_X_POS_L            = $AF0DBC
=$af0dbd				SP55_X_POS_H            = $AF0DBD
=$af0dbe				SP55_Y_POS_L            = $AF0DBE
=$af0dbf				SP55_Y_POS_H            = $AF0DBF
=$af0dc0				SP56_CONTROL_REG        = $AF0DC0
=$af0dc1				SP56_ADDY_PTR_L         = $AF0DC1
=$af0dc2				SP56_ADDY_PTR_M         = $AF0DC2
=$af0dc3				SP56_ADDY_PTR_H         = $AF0DC3
=$af0dc4				SP56_X_POS_L            = $AF0DC4
=$af0dc5				SP56_X_POS_H            = $AF0DC5
=$af0dc6				SP56_Y_POS_L            = $AF0DC6
=$af0dc7				SP56_Y_POS_H            = $AF0DC7
=$af0dc8				SP57_CONTROL_REG        = $AF0DC8
=$af0dc9				SP57_ADDY_PTR_L         = $AF0DC9
=$af0dca				SP57_ADDY_PTR_M         = $AF0DCA
=$af0dcb				SP57_ADDY_PTR_H         = $AF0DCB
=$af0dcc				SP57_X_POS_L            = $AF0DCC
=$af0dcd				SP57_X_POS_H            = $AF0DCD
=$af0dce				SP57_Y_POS_L            = $AF0DCE
=$af0dcf				SP57_Y_POS_H            = $AF0DCF
=$af0dd0				SP58_CONTROL_REG        = $AF0DD0
=$af0dd1				SP58_ADDY_PTR_L         = $AF0DD1
=$af0dd2				SP58_ADDY_PTR_M         = $AF0DD2
=$af0dd3				SP58_ADDY_PTR_H         = $AF0DD3
=$af0dd4				SP58_X_POS_L            = $AF0DD4
=$af0dd5				SP58_X_POS_H            = $AF0DD5
=$af0dd6				SP58_Y_POS_L            = $AF0DD6
=$af0dd7				SP58_Y_POS_H            = $AF0DD7
=$af0dd8				SP59_CONTROL_REG        = $AF0DD8
=$af0dd9				SP59_ADDY_PTR_L         = $AF0DD9
=$af0dda				SP59_ADDY_PTR_M         = $AF0DDA
=$af0ddb				SP59_ADDY_PTR_H         = $AF0DDB
=$af0ddc				SP59_X_POS_L            = $AF0DDC
=$af0ddd				SP59_X_POS_H            = $AF0DDD
=$af0dde				SP59_Y_POS_L            = $AF0DDE
=$af0ddf				SP59_Y_POS_H            = $AF0DDF
=$af0de0				SP60_CONTROL_REG        = $AF0DE0
=$af0de1				SP60_ADDY_PTR_L         = $AF0DE1
=$af0de2				SP60_ADDY_PTR_M         = $AF0DE2
=$af0de3				SP60_ADDY_PTR_H         = $AF0DE3
=$af0de4				SP60_X_POS_L            = $AF0DE4
=$af0de5				SP60_X_POS_H            = $AF0DE5
=$af0de6				SP60_Y_POS_L            = $AF0DE6
=$af0de7				SP60_Y_POS_H            = $AF0DE7
=$af0de8				SP61_CONTROL_REG        = $AF0DE8
=$af0de9				SP61_ADDY_PTR_L         = $AF0DE9
=$af0dea				SP61_ADDY_PTR_M         = $AF0DEA
=$af0deb				SP61_ADDY_PTR_H         = $AF0DEB
=$af0dec				SP61_X_POS_L            = $AF0DEC
=$af0ded				SP61_X_POS_H            = $AF0DED
=$af0dee				SP61_Y_POS_L            = $AF0DEE
=$af0def				SP61_Y_POS_H            = $AF0DEF
=$af0df0				SP62_CONTROL_REG        = $AF0DF0
=$af0df1				SP62_ADDY_PTR_L         = $AF0DF1
=$af0df2				SP62_ADDY_PTR_M         = $AF0DF2
=$af0df3				SP62_ADDY_PTR_H         = $AF0DF3
=$af0df4				SP62_X_POS_L            = $AF0DF4
=$af0df5				SP62_X_POS_H            = $AF0DF5
=$af0df6				SP62_Y_POS_L            = $AF0DF6
=$af0df7				SP62_Y_POS_H            = $AF0DF7
=$af0df8				SP63_CONTROL_REG        = $AF0DF8
=$af0df9				SP63_ADDY_PTR_L         = $AF0DF9
=$af0dfa				SP63_ADDY_PTR_M         = $AF0DFA
=$af0dfb				SP63_ADDY_PTR_H         = $AF0DFB
=$af0dfc				SP63_X_POS_L            = $AF0DFC
=$af0dfd				SP63_X_POS_H            = $AF0DFD
=$af0dfe				SP63_Y_POS_L            = $AF0DFE
=$af0dff				SP63_Y_POS_H            = $AF0DFF

;******  Return to file: src\C256/vicky_def.s


;******  Return to file: src\C256/mmap_c256.s

=$00					BASIC_BANK = $00            ; Memory bank for default purposes
=$004c00				IOBUF = $004C00             ; A buffer for I/O operations
=$004d00				ARRIDXBUF = $004D00         ; The array index buffer used for array references
=$004e00				TEMPBUF = $004E00           ; Temporary buffer for string processing, etc.
=$004f00				INPUTBUF = $004F00          ; Starting address of the line input buffer (one page)
=$005000				RETURN_BOT = $005000        ; Starting address of the return stack
=$005fff				RETURN_TOP = $005FFF        ; Ending address of the return stack
=$006000				ARGUMENT_BOT = $006000      ; Starting address of the argument stack
=$006fff				ARGUMENT_TOP = $006FFF      ; Ending address of the argument stack
=$007000				OPERATOR_BOT = $007000      ; Starting address of the operator stack
=$007fff				OPERATOR_TOP = $007FFF      ; Ending address of the operator stack
=$b00000				VRAM = $B00000              ; Start of video RAM
=$010000				LOADBLOCK = $010000         ; File loading will start here
=$360000				BASIC_BOT := $360000         ; Starting point for BASIC programs
=$37ffff				HEAP_TOP := $37FFFF          ; Starting point of the heap
=$160000				BASIC_BOT := $160000         ; Starting point for BASIC programs
=$17ffff				HEAP_TOP := $17FFFF          ; Starting point of the heap

;******  Return to file: src\memorymap.s

=$00ffe6				VBRK = $00FFE6          ; Vector for the native-mode BRK vector
=$1ad000				DATA_BLOCK = *
=$000800				GLOBAL_VARS = *
>0800					BIP         .dword ?    ; Pointer to the current byte in the current BASIC program
>0804					BIPPREV     .dword ?    ; Pointer to the previous bytein the current BASIC program
>0808					INDEX       .dword ?    ; A temporary pointer
>080c					SCRATCH     .dword ?    ; A temporary scratch variable
>0810					SCRATCH2    .dword ?    ; A temporary scratch variable
>0814					            .word  ?	; Need a few more bits for BCD conversion
>0816					STRPTR      .dword ?    ; A temporary pointer for strings
>081a					CURLINE     .dword ?    ; Pointer to the current input line needing tokenization
>081e					CURTOKLEN   .byte ?     ; Length of the text of the current token
>081f					ARGUMENTSP  .word ?     ; Pointer to the top of the argument stack
>0821					OPERATORSP  .word ?     ; Pointer to the top of the operator stack
>0823					ARGUMENT1   .dword ?    ; Argument 1 for expression calculations
>0827					ARGTYPE1    .byte ?     ; Type code for argument 1 (integer, float, string)
>0828					SIGN1       .byte ?     ; Temporary sign marker for argument 1
>0829					ARGUMENT2   .dword ?    ; Argument 2 for expression calculations
>082d					ARGTYPE2    .byte ?     ; Type code for argument 2 (integer, float, string)
>082e					SIGN2       .byte ?     ; Temporary sign marker for argument 1
>082f					JMP16PTR    .word ?     ; Pointer for 16-bit indirect jumps (within BASIC816's code base)
>0831					GOSUBDEPTH  .word ?     ; Number of GOSUBs on the stack
>0833					RETURNSP    .word ?     ; Pointer to the top of the return stack
>0835					SKIPNEST    .byte ?     ; Flag to indicate if token seeking should respect nesting (MSB set if so)
>0836					NESTING     .byte ?     ; Counter of the depth of lexical nesting for FOR/NEXT, DO/LOOP
>0837					TARGETTOK   .byte ?     ; When searching for a token, TARGETTOK is the token to find
>0838					DATABIP     .dword ?    ; Pointer to the next data element for READ statements
>083c					DATALINE    .dword ?    ; Pointer to the current line for a DATA statement
>0840					SAVEBIP     .dword ?    ; Spot to save BIP temporarily
>0844					SAVELINE    .dword ?    ; Spot to save CURLINE temporarily
=$000848				MONITOR_VARS = *
>0848					MCMDADDR    .long ?     ;3 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
>084b					MCMP_TEXT   .long ?     ;3 Bytes Address of symbol being evaluated for COMPARE routine
>084e					MCMP_LEN    .word ?     ;2 Bytes Length of symbol being evaluated for COMPARE routine
>0850					MCMD        .long ?     ;3 Bytes Address of the current command/function string
>0853					MCMD_LEN    .word ?     ;2 Bytes Length of the current command/function string
>0855					MARG1       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command
>0859					MARG2       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>085d					MARG3       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0861					MARG4       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0865					MARG5       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0869					MARG6       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>086d					MARG7       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0871					MARG8       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0875					MARG9       .dword ?    ;4 Bytes First command argument.
>0879					MARG_LEN    .byte ?     ;1 Byte count of the number of arguments passed
>087a					MCURSOR     .dword ?    ;4 Bytes Pointer to the current memory location for disassembly, memory dump, etc.
>087e					MLINEBUF    .fill 17    ;17 Byte buffer for dumping memory (TODO: could be moved to a general string scratch area)
>088f					MCOUNT      .long ?     ;2 Byte counter
>0892					MTEMP       .dword ?    ;4 Bytes of temporary space
>0896					MCPUSTAT    .byte ?     ;1 Byte to represent what the disassembler thinks the processor MX bits are
>0897					MADDR_MODE  .byte ?     ;1 Byte address mode found by the assembler
>0898					MPARSEDNUM  .dword ?    ;4 Bytes to store a parsed number
>089c					MMNEMONIC   .word ?     ;2 Byte address of mnemonic found by the assembler
>089e					MTEMPPTR    .dword ?    ;4 Byte temporary pointer
>08a2					MJUMPINST   .byte ?     ;1 Byte JSL opcode
>08a3					MJUMPADDR   .long ?     ;3 Byte address for JSL
=$000823				MANTISSA1 = ARGUMENT1
=$000826				EXPONENT1 = ARGUMENT1+3

;******  Return to file: src\basic816.s


;******  Processing file: src\macros.s


;******  Return to file: src\basic816.s

.1a0000	5c 72 8a 1a	jmp $1a8a72	COLDBOOT        JML START               ; Entry point to boot up BASIC from scratch
.1a0004	5c 84 70 1a	jmp $1a7084	MONITOR         JML IMONITOR            ; Entry point to the machine language monitor
.1a0008	5c 76 27 1a	jmp $1a2776	READLINE        JML IREADLINE           ; Wait for the user to enter a line of text (for programming input)
.1a000c	5c ba 02 1a	jmp $1a02ba	SCRCOPYLINE     JML ISCRCPYLINE         ; Copy the line on the screen the user just input to INPUTBUF
.1a0010	5c 58 00 1a	jmp $1a0058	INPUTLINE       JML IINPUTLINE          ; Read a single line of text from the user, and copy it to TEMPBUF (for INPUT statement)
.1a0014	5c b8 00 1a	jmp $1a00b8	GETKEY          JML IGETKEY             ; Wait for a keypress by the user and return the ASCII code in A
.1a0018	5c 0f 04 1a	jmp $1a040f	PRINTC          JML IPRINTC             ; Print the character in A to the console
.1a001c	5c 5e 02 1a	jmp $1a025e	SHOWCURSOR      JML ISHOWCURSOR         ; Set cursor visibility: A=0, hide... A<>0, show.
.1a0020	5c 79 02 1a	jmp $1a0279	CURSORXY        JML ICURSORXY           ; Set the position of the cursor to (X, Y)
.1a0024	5c 80 02 1a	jmp $1a0280	CLSCREEN        JML ICLSCREEN           ; Clear the screen

;******  Processing file: src\bios.s


;******  Processing file: src\membuffers.s

>08a6					OBUFFER     .long ?     ; Pointer to the current text memory buffer for output
>08a9					OBUFFSIZE   .word ?     ; Maximum size of output text memory buffer
>08ab					OBUFFIDX    .word ?     ; Index into the current output buffer
>08ad					IBUFFER     .long ?     ; Pointer to the current text memory buffer for input
>08b0					IBUFFSIZE   .word ?     ; Number of bytes written to the buffer
>08b2					IBUFFIDX    .word ?     ; Index into the current input buffer (next available character)
.1a0028					OBUFF_PUTC
.1a0028	0b		phd		                PHD
.1a0029	08		php		                PHP
.1a002a	08		php		            PHP
.1a002b	c2 20		rep #$20	            REP #$20
.1a002d	48		pha		            PHA
.1a002e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0031	5b		tcd		            TCD
.1a0032	68		pla		            PLA
.1a0033	28		plp		            PLP
.1a0034	e2 20		sep #$20	            SEP #$20
.1a0036	85 b5		sta $08b5	                STA SAVE_A
.1a0038	c2 20		rep #$20	            REP #$20
.1a003a	a5 a6		lda $08a6	                LDA OBUFFER
.1a003c	d0 06		bne $1a0044	                BNE has_buffer
.1a003e	e2 20		sep #$20	            SEP #$20
.1a0040	a5 a8		lda $08a8	                LDA OBUFFER+2
.1a0042	f0 11		beq $1a0055	                BEQ done
.1a0044					has_buffer
.1a0044	c2 10		rep #$10	            REP #$10
.1a0046	a4 ab		ldy $08ab	                LDY OBUFFIDX        ; Check to make sure there is room
.1a0048	c4 a9		cpy $08a9	                CPY OBUFFSIZE
.1a004a	f0 09		beq $1a0055	                BEQ done            ; If not, exit silently
.1a004c	e2 20		sep #$20	            SEP #$20
.1a004e	a5 b5		lda $08b5	                LDA SAVE_A
.1a0050	97 a6		sta [$08a6],y	                STA [OBUFFER],Y     ; Write the character to the buffer
.1a0052	c8		iny		                INY                 ; Increment the index
.1a0053	84 ab		sty $08ab	                STY OBUFFIDX
.1a0055	28		plp		done            PLP
.1a0056	2b		pld		                PLD
.1a0057	60		rts		            RTS

;******  Return to file: src\bios.s


;******  Processing file: src\C256/io_c256.s


;******  Processing file: src\C256/kernel_c256.s

=$00104c				FK_GETCHW           = $00104c ; Get a character from the input channel. Waits until data received. A=0 and Carry=1 if no data is wating
=$001018				FK_PUTC             = $001018 ; Print a character to the currently selected channel
=$00101c				FK_PUTS             = $00101C ; Print a string to the currently selected channel
=$001080				FK_PRINTAH          = $001080 ; Prints hex value in A. Printed value is 2 wide if M flag is 1, 4 wide if M=0
=$001084				FK_LOCATE           = $001084 ; Reposition the cursor to row Y column X
=$001078				FK_IPRINTH          = $001078 ; Print a HEX string
=$00103c				FK_SETOUT           = $00103c ; Select an output channel
=$00112c				FK_SETSIZES         = $00112C ; Set the text screen size variables based on the border and screen resolution.
=$0010f0				FK_OPEN             = $0010F0 ; open a file for reading/writing/creating
=$0010f4				FK_CREATE           = $0010F4 ; create a new file
=$0010f8				FK_CLOSE            = $0010F8 ; close a file (make sure last cluster is written)
=$0010fc				FK_WRITE            = $0010FC ; write the current cluster to the file
=$001100				FK_READ             = $001100 ; read the next cluster from the file
=$001104				FK_DELETE           = $001104 ; delete a file / directory
=$001108				FK_DIROPEN          = $001108 ; open a directory and seek the first directory entry
=$00110c				FK_DIRNEXT          = $00110C ; seek to the next directory of an open directory
=$001110				FK_DIRREAD          = $001110 ; Read the directory entry for the specified file
=$001114				FK_DIRWRITE         = $001114 ; Write any changes in the current directory cluster back to the drive
=$001118				FK_LOAD             = $001118 ; load a binary file into memory, supports multiple file formats
=$00111c				FK_SAVE             = $00111C ; Save memory to a binary file
=$001124				FK_RUN              = $001124 ; Load and run an executable binary file
=$001130				FK_COPY             = $001130 ; Copy a file
=$001120				FK_CMDBLOCK         = $001120 ; Send a command to a block device
=$00113c				FK_TESTBREAK        = $00113C ; Check if BREAK was pressed recently by the user (C is set if true, clear if false)
=$001028				FK_GETSCANCODE      = $001028 ; Get the next scancode from the keyboard (A = scancode, 0 if none available)
=$001144				FK_READVRAM         = $001144 ; Read a byte from video RAM at B:X
=0					CHAN_CONSOLE = 0
=1					CHAN_COM1 = 1
=2					CHAN_COM2 = 2

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/RTC_inc.s

=$af0800				RTC_SEC       = $AF0800 ;Seconds Register
=$af0801				RTC_SEC_ALARM = $AF0801 ;Seconds Alarm Register
=$af0802				RTC_MIN       = $AF0802 ;Minutes Register
=$af0803				RTC_MIN_ALARM = $AF0803 ;Minutes Alarm Register
=$af0804				RTC_HRS       = $AF0804 ;Hours Register
=$af0805				RTC_HRS_ALARM = $AF0805 ;Hours Alarm Register
=$af0806				RTC_DAY       = $AF0806 ;Day Register
=$af0807				RTC_DAY_ALARM = $AF0807 ;Day Alarm Register
=$af0808				RTC_DOW       = $AF0808 ;Day of Week Register
=$af0809				RTC_MONTH     = $AF0809 ;Month Register
=$af080a				RTC_YEAR      = $AF080A ;Year Register
=$af080b				RTC_RATES     = $AF080B ;Rates Register
=$af080c				RTC_ENABLE    = $AF080C ;Enables Register
=$af080d				RTC_FLAGS     = $AF080D ;Flags Register
=$af080e				RTC_CTRL      = $AF080E ;Control Register
=$af080f				RTC_CENTURY   = $AF080F ;Century Register

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/keyboard.s


;******  Processing file: src\C256/keyboard_def.s

=$af1064				STATUS_PORT 	        =	$AF1064
=$af1060				KBD_OUT_BUF 	        =	$AF1060
=$af1060				KBD_INPT_BUF	        = $AF1060
=$af1064				KBD_CMD_BUF		        = $AF1064
=$af1060				KBD_DATA_BUF	        = $AF1060
=$af1060				PORT_A			          =	$AF1060
=$af1061				PORT_B			          =	$AF1061
=$01					OUT_BUF_FULL  =	$01
=$02					INPT_BUF_FULL	=	$02
=$04					SYS_FLAG		  =	$04
=$08					CMD_DATA		  =	$08
=$10					KEYBD_INH     =	$10
=$20					TRANS_TMOUT	  =	$20
=$40					RCV_TMOUT		  =	$40
=$80					PARITY_EVEN		=	$80
=$10					INH_KEYBOARD	=	$10
=$ae					KBD_ENA			  =	$AE
=$ad					KBD_DIS			  =	$AD
=$f1					KB_MENU			  =	$F1
=$f4					KB_ENABLE		  =	$F4
=$f7					KB_MAKEBREAK  =	$F7
=$fe					KB_ECHO			  =	$FE
=$ff					KB_RESET		  =	$FF
=$ed					KB_LED_CMD		=	$ED
=$aa					KB_OK			    =	$AA
=$fa					KB_ACK			  =	$FA
=$ff					KB_OVERRUN		=	$FF
=$fe					KB_RESEND		  =	$FE
=$f0					KB_BREAK		  =	$F0
=$10					KB_FA			    =	$10
=$20					KB_FE			    =	$20
=$40					KB_PR_LED		  =	$40
=$01					KB_SCROLL_LOCK      = $01
=$02					KB_NUM_LOCK         = $02
=$04					KB_CAPS_LOCK        = $04
=2					ANSI_IN_INS = 2     ; ANSI input code for INSERT
=3					ANSI_IN_DEL = 3     ; ANSI input code for DELETE
=24					ANSI_IN_F12 = 24    ; ANSI input code for F12
=8					ANSI_IN_CTRL = 8    ; ANSI input modifier flag for CTRL

;******  Return to file: src\C256/keyboard.s

.1a0058					IINPUTLINE
.1a0058	08		php		                PHP
.1a0059	c2 10		rep #$10	            REP #$10
.1a005b	e2 20		sep #$20	            SEP #$20
.1a005d	a9 01		lda #$01	                LDA #1              ; Show the cursor
.1a005f	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a0062	a2 00 00	ldx #$0000	                LDX #0
.1a0065	a9 00		lda #$00	                LDA #0
.1a0067	9f 00 4c 00	sta $004c00,x	zero_loop       STA @lIOBUF,X
.1a006b	e8		inx		                INX
.1a006c	e0 00 01	cpx #$0100	                CPX #$100
.1a006f	d0 f6		bne $1a0067	                BNE zero_loop
.1a0071	a2 00 00	ldx #$0000	                LDX #0
.1a0074					getchar
.1a0074	20 14 00	jsr $1a0014	            JSR GETKEY
.1a0077	c9 0d		cmp #$0d	                CMP #CHAR_CR        ; Got a CR?
.1a0079	d0 03		bne $1a007e	                BNE not_cr
.1a007b	4c b1 00	jmp $1a00b1	                JMP endofline       ; Yes: we're done
.1a007e					not_cr
.1a007e	c9 08		cmp #$08	not_right       CMP #CHAR_BS        ; Is it a backspace?
.1a0080	d0 1a		bne $1a009c	                BNE not_bs
.1a0082	e0 00 00	cpx #$0000	                CPX #0              ; Are we at the beginning of the line?
.1a0085	f0 ed		beq $1a0074	                BEQ getchar         ; yes: ignore the backspace
.1a0087	da		phx		                PHX                 ; Save the cursor position
.1a0088	bf 01 4c 00	lda $004c01,x	clr_loop        LDA @lIOBUF+1,X     ; Get the character above
.1a008c	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the current position
.1a0090	f0 06		beq $1a0098	                BEQ done_clr        ; If we copied a NUL, we're done copying
.1a0092	e8		inx		                INX                 ; Otherwise, keep copying down
.1a0093	e0 ff 00	cpx #$00ff	                CPX #$FF            ; Until we're at the end of the buffer
.1a0096	d0 f0		bne $1a0088	                BNE clr_loop
.1a0098	fa		plx		done_clr        PLX                 ; Restore the cursor position
.1a0099	ca		dex		                DEX                 ; No: move the cursor left
.1a009a	80 0e		bra $1a00aa	                BRA print_bs        ; And print the backspace
.1a009c	c9 20		cmp #$20	not_bs          CMP #$20            ; Is it in range 00 -- 1F?
.1a009e	90 d4		bcc $1a0074	                BLT getchar         ; Yes: ignore it
.1a00a0	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the input buffer
.1a00a4	e8		inx		                INX                 ; Move the cursor forward
.1a00a5					echo
.1a00a5	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00a8	80 ca		bra $1a0074	                BRA getchar         ; And get another...
.1a00aa	a9 08		lda #$08	print_bs        LDA #CHAR_BS        ; Backspace character...
.1a00ac	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00af	80 c3		bra $1a0074	                BRA getchar         ; And get another...
.1a00b1	a9 00		lda #$00	endofline       LDA #0              ; Hide the cursor
.1a00b3	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a00b6	28		plp		                PLP
.1a00b7	60		rts		            RTS
.1a00b8					IGETKEY
.1a00b8	da		phx		                PHX
.1a00b9	5a		phy		                PHY
.1a00ba	8b		phb		                PHB
.1a00bb	0b		phd		                PHD
.1a00bc	08		php		                PHP
.1a00bd	22 4c 10 00	jsl $00104c	                JSL FK_GETCHW
.1a00c1	28		plp		                PLP
.1a00c2	2b		pld		                PLD
.1a00c3	ab		plb		                PLB
.1a00c4	7a		ply		                PLY
.1a00c5	fa		plx		                PLX
.1a00c6	60		rts		            RTS
=0					GK_ST_INIT = 0      ; GETKEYE state: initial
=1					GK_ST_ESC = 1       ; GETKEYE state: ESC seen
=2					GK_ST_CSI = 2       ; GETKEYE state: CSI "ESC[" seen
=3					GK_ST_CODE = 3      ; GETKEYE state: We're at the command code in the sequence
=4					GK_ST_MODS = 4      ; GETKEYE state: We're at the modifier code in the sequence
.1a00c7					SEND_ANSI
.1a00c7	08		php		                PHP
.1a00c8	e2 30		sep #$30	            SEP #$30
.1a00ca	48		pha		                PHA
.1a00cb	a9 1b		lda #$1b	                LDA #CHAR_ESC           ; Print ESC
.1a00cd	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00d0	a9 5b		lda #$5b	                LDA #'['                ; Print [
.1a00d2	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00d5	68		pla		                PLA                     ; Print the command code
.1a00d6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00d9	28		plp		                PLP
.1a00da	60		rts		            RTS
.1a00db					GETKEYE
.1a00db	0b		phd		                PHD
.1a00dc	8b		phb		                PHB
.1a00dd	08		php		                PHP
.1a00de	08		php		            PHP
.1a00df	e2 20		sep #$20	            SEP #$20
.1a00e1	48		pha		            PHA
.1a00e2	a9 00		lda #$00	            LDA #0
.1a00e4	48		pha		            PHA
.1a00e5	ab		plb		            PLB
.1a00e6	68		pla		            PLA
.1a00e7	28		plp		            PLP
.1a00e8	08		php		            PHP
.1a00e9	c2 20		rep #$20	            REP #$20
.1a00eb	48		pha		            PHA
.1a00ec	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a00ef	5b		tcd		            TCD
.1a00f0	68		pla		            PLA
.1a00f1	28		plp		            PLP
.1a00f2					locals
>0001					l_character     .byte ?                 ; The character returned by the input stream
>0002					l_state         .byte ?                 ; Current state of the input parser
>0003					l_code          .byte ?                 ; Code number for any escaped input sequence
>0004					l_modifiers     .byte ?                 ; Modifier bit field for any escaped input sequence
.1a00f2	c2 20		rep #$20	            REP #$20
.1a00f4	3b		tsc		            TSC
.1a00f5	38		sec		            SEC
.1a00f6	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.1a00f9	1b		tcs		            TCS
.1a00fa	e2 20		sep #$20	            SEP #$20
.1a00fc	a9 00		lda #$00	get_reset       LDA #0                  ; Initialize state, code, and modifiers
.1a00fe	83 02		sta $02,s	                STA l_state
.1a0100	83 03		sta $03,s	                STA l_code
.1a0102	83 04		sta $04,s	                STA l_modifiers
.1a0104					loop
.1a0104	20 14 00	jsr $1a0014	            JSR GETKEY
.1a0107	c9 00		cmp #$00	                CMP #0                  ; Is it 0?
.1a0109	f0 f9		beq $1a0104	                BEQ loop                ; Yes: keep waiting
.1a010b	83 01		sta $01,s	                STA l_character         ; Save the character
.1a010d	a3 02		lda $02,s	                LDA l_state             ; What is the current state?
.1a010f	d0 35		bne $1a0146	                BNE chk_st_esc
.1a0111	a3 01		lda $01,s	                LDA l_character         ; Get the character back
.1a0113	c9 08		cmp #$08	                CMP #CHAR_BS            ; Is it a backspace?
.1a0115	d0 0a		bne $1a0121	                BNE not_bs
.1a0117	20 18 00	jsr $1a0018	            JSR PRINTC
.1a011a	a9 50		lda #$50	                LDA #'P'
.1a011c	20 c7 00	jsr $1a00c7	            JSR SEND_ANSI
.1a011f	80 e3		bra $1a0104	                BRA loop                ; And keep waiting for a keypress
.1a0121	c9 0d		cmp #$0d	not_bs          CMP #CHAR_CR            ; Is it a carriage return?
.1a0123	f0 0a		beq $1a012f	                BEQ send                ; Yes: print and return it
.1a0125	c9 1b		cmp #$1b	                CMP #CHAR_ESC           ; Is it ESC?
.1a0127	d0 06		bne $1a012f	                BNE send                ; No: just print it out
.1a0129	a9 01		lda #$01	                LDA #GK_ST_ESC          ; Yes: move to the ESC state
.1a012b	83 02		sta $02,s	                STA l_state
.1a012d	80 d5		bra $1a0104	                BRA loop                ; And get the next character in the sequence
.1a012f					send
.1a012f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a0132	a3 01		lda $01,s	done            LDA l_character         ; Save the character so we can return it
.1a0134	85 0c		sta $080c	                STA SCRATCH
.1a0136	c2 20		rep #$20	            REP #$20
.1a0138	3b		tsc		            TSC
.1a0139	18		clc		            CLC
.1a013a	69 04 00	adc #$0004	            ADC #SIZE(locals)
.1a013d	1b		tcs		            TCS
.1a013e	e2 20		sep #$20	            SEP #$20
.1a0140	a5 0c		lda $080c	                LDA SCRATCH             ; Restore the character we're returning
.1a0142	28		plp		                PLP
.1a0143	2b		pld		                PLD
.1a0144	ab		plb		                PLB
.1a0145	60		rts		            RTS
.1a0146	c9 01		cmp #$01	chk_st_esc      CMP #GK_ST_ESC          ; Are we in the ESC state?
.1a0148	d0 10		bne $1a015a	                BNE chk_st_csi          ; No: check to see if we're in CSI state
.1a014a	a3 01		lda $01,s	                LDA l_character         ; Get the character
.1a014c	c9 5b		cmp #$5b	                CMP #'['                ; Is it "["?
.1a014e	f0 03		beq $1a0153	                BEQ go_st_csi           ; Yes: go to the CSI state
.1a0150	82 a9 ff	brl $1a00fc	                BRL get_reset           ; Reset the state machine and keep reading characters
.1a0153	a9 02		lda #$02	go_st_csi       LDA #GK_ST_CSI          ; Yes: move to the CSI state
.1a0155	83 02		sta $02,s	                STA l_state
.1a0157	82 aa ff	brl $1a0104	                BRL loop
.1a015a	c9 02		cmp #$02	chk_st_csi      CMP #GK_ST_CSI          ; Are we in the CSI state?
.1a015c	d0 29		bne $1a0187	                BNE chk_st_code         ; No: check to see if we're in the code state
.1a015e	a3 01		lda $01,s	                LDA l_character         ; Check the character
.1a0160	c9 41		cmp #$41	                CMP #'A'                ; Is it in 'A'..'D'?
.1a0162	90 0c		bcc $1a0170	                BLT not_letter
.1a0164	c9 45		cmp #$45	                CMP #'D'+1
.1a0166	b0 08		bcs $1a0170	                BGE not_letter
.1a0168	a3 01		lda $01,s	                LDA l_character         ; Yes: it's a cursor key, send the sequence to the screen
.1a016a	20 c7 00	jsr $1a00c7	            JSR SEND_ANSI
.1a016d	82 8c ff	brl $1a00fc	                BRL get_reset           ; Reset the state machine and keep reading characters
.1a0170	c9 30		cmp #$30	not_letter      CMP #'0'                ; Is it in range '0'..'9'?
.1a0172	90 10		bcc $1a0184	                BLT not_csi_digit
.1a0174	c9 3a		cmp #$3a	                CMP #'9'+1
.1a0176	b0 0c		bcs $1a0184	                BGE not_csi_digit       ; No: handle it being invalid
.1a0178	38		sec		                SEC                     ; Yes: convert to a value
.1a0179	e9 30		sbc #$30	                SBC #'0'
.1a017b	83 03		sta $03,s	                STA l_code              ; And save it to the code variable
.1a017d	a9 03		lda #$03	                LDA #GK_ST_CODE         ; Move to the CODE state
.1a017f	83 02		sta $02,s	                STA l_state
.1a0181	82 80 ff	brl $1a0104	                BRL loop
.1a0184	82 75 ff	brl $1a00fc	not_csi_digit   BRL get_reset           ; Bad sequence: reset and keep reading characters
.1a0187	c9 03		cmp #$03	chk_st_code     CMP #GK_ST_CODE         ; Is it the CODE state?
.1a0189	d0 41		bne $1a01cc	                BNE chk_st_mods         ; No: check to see if it's MODIFIERS
.1a018b	a3 01		lda $01,s	                LDA l_character         ; Check the character
.1a018d	c9 30		cmp #$30	                CMP #'0'                ; Is it in the range '0'..'9'
.1a018f	90 29		bcc $1a01ba	                BLT not_digits_2
.1a0191	c9 3a		cmp #$3a	                CMP #'9'+1
.1a0193	b0 25		bcs $1a01ba	                BGE not_digits_2
.1a0195	a3 03		lda $03,s	                LDA l_code              ; Multiply l_code by 2
.1a0197	8f 00 01 00	sta $000100	                STA @l UNSIGNED_MULT_A_LO
.1a019b	a9 00		lda #$00	                LDA #0
.1a019d	8f 01 01 00	sta $000101	                STA @l UNSIGNED_MULT_A_HI
.1a01a1	8f 03 01 00	sta $000103	                STA @l UNSIGNED_MULT_B_HI
.1a01a5	a9 0a		lda #$0a	                LDA #10
.1a01a7	8f 02 01 00	sta $000102	                STA @l UNSIGNED_MULT_B_LO
.1a01ab	a3 01		lda $01,s	                LDA l_character         ; Convert the digit to a number
.1a01ad	38		sec		                SEC
.1a01ae	e9 30		sbc #$30	                SBC #'0'
.1a01b0	18		clc		                CLC                     ; And add to l_code
.1a01b1	6f 04 01 00	adc $000104	                ADC @l UNSIGNED_MULT_AL_LO
.1a01b5	83 03		sta $03,s	                STA l_code
.1a01b7	82 4a ff	brl $1a0104	                BRL loop                ; And keep processing the sequence
.1a01ba	c9 3b		cmp #$3b	not_digits_2    CMP #';'                ; Is it the semicolon?
.1a01bc	d0 07		bne $1a01c5	                BNE not_semi
.1a01be	a9 04		lda #$04	                LDA #GK_ST_MODS         ; Yes: Move to the MODIFIERS state
.1a01c0	83 02		sta $02,s	                STA l_state
.1a01c2	82 3f ff	brl $1a0104	                BRL loop
.1a01c5	c9 7e		cmp #$7e	not_semi        CMP #'~'                ; No: Is it the tilda?
.1a01c7	f0 40		beq $1a0209	                BEQ end_sequence        ; Yes: we've gotten the end of the sequence
.1a01c9	82 30 ff	brl $1a00fc	                BRL get_reset           ; No: we've got a bad sequence... for now just reset and keep looping
.1a01cc	c9 04		cmp #$04	chk_st_mods     CMP #GK_ST_MODS         ; Are we in the MODIFIERS state?
.1a01ce	f0 03		beq $1a01d3	                BEQ do_mods
.1a01d0	82 5f ff	brl $1a0132	                BRL done                ; No: we're done
.1a01d3	a3 01		lda $01,s	do_mods         LDA l_character         ; Check the character
.1a01d5	c9 30		cmp #$30	                CMP #'0'                ; Is it in the range '0'..'9'
.1a01d7	90 29		bcc $1a0202	                BLT not_digits_3
.1a01d9	c9 3a		cmp #$3a	                CMP #'9'+1
.1a01db	b0 25		bcs $1a0202	                BGE not_digits_3
.1a01dd	a3 04		lda $04,s	                LDA l_modifiers         ; Multiply l_modifiers by 2
.1a01df	8f 00 01 00	sta $000100	                STA @l UNSIGNED_MULT_A_LO
.1a01e3	a9 00		lda #$00	                LDA #0
.1a01e5	8f 01 01 00	sta $000101	                STA @l UNSIGNED_MULT_A_HI
.1a01e9	8f 03 01 00	sta $000103	                STA @l UNSIGNED_MULT_B_HI
.1a01ed	a9 0a		lda #$0a	                LDA #10
.1a01ef	8f 02 01 00	sta $000102	                STA @l UNSIGNED_MULT_B_LO
.1a01f3	a3 01		lda $01,s	                LDA l_character         ; Convert the digit to a number
.1a01f5	38		sec		                SEC
.1a01f6	e9 30		sbc #$30	                SBC #'0'
.1a01f8	18		clc		                CLC                     ; And add to l_modifiers
.1a01f9	6f 04 01 00	adc $000104	                ADC @l UNSIGNED_MULT_AL_LO
.1a01fd	83 04		sta $04,s	                STA l_modifiers
.1a01ff	82 02 ff	brl $1a0104	                BRL loop                ; And keep processing the sequence
.1a0202	c9 7e		cmp #$7e	not_digits_3    CMP #'~'                ; No: Is it the tilda?
.1a0204	f0 03		beq $1a0209	                BEQ end_sequence        ; Yes: we've gotten the end of the sequence
.1a0206	82 f3 fe	brl $1a00fc	                BRL get_reset           ; No: we've got a bad sequence... for now just reset and keep looping
.1a0209	a3 03		lda $03,s	end_sequence    LDA l_code              ; Get the code
.1a020b	c9 02		cmp #$02	                CMP #ANSI_IN_INS        ; Is it INSERT?
.1a020d	f0 0b		beq $1a021a	                BEQ do_ins              ; Yes: process the insert
.1a020f	c9 03		cmp #$03	                CMP #ANSI_IN_DEL        ; Is it DELETE?
.1a0211	f0 0b		beq $1a021e	                BEQ do_del              ; Yes: process the delete
.1a0213	c9 18		cmp #$18	                CMP #ANSI_IN_F12        ; Is it F12?
.1a0215	f0 0f		beq $1a0226	                BEQ do_f12              ; Yes: process the F12 key
.1a0217	82 e2 fe	brl $1a00fc	                BRL get_reset           ; Code is not one we handle, just return
.1a021a	a9 40		lda #$40	do_ins          LDA #'@'                ; Send the ANSI ICH command
.1a021c	80 02		bra $1a0220	                BRA snd_ansi
.1a021e	a9 50		lda #$50	do_del          LDA #'P'                ; Send the ANSI DCH command
.1a0220					snd_ansi
.1a0220	20 c7 00	jsr $1a00c7	            JSR SEND_ANSI
.1a0223	82 d6 fe	brl $1a00fc	                BRL get_reset           ; Reset and keep getting characters
.1a0226	a5 d2		lda $08d2	do_f12          LDA STATE               ; Check the state
.1a0228	d0 10		bne $1a023a	                BNE skip_f12            ; If we're running, ignore the F12
.1a022a	a3 04		lda $04,s	                LDA l_modifiers         ; Check to make sure it's CTRL-F12
.1a022c	c9 08		cmp #$08	                CMP #ANSI_IN_CTRL       ; Modifier flag for CTRL
.1a022e	d0 0a		bne $1a023a	                BNE skip_f12
.1a0230	a9 1b		lda #$1b	                LDA #CHAR_ESC           ; Send ESC_ (APC) to show the credits
.1a0232	20 18 00	jsr $1a0018	            JSR PRINTC
.1a0235	a9 5f		lda #$5f	                LDA #'_'
.1a0237	20 18 00	jsr $1a0018	            JSR PRINTC
.1a023a	82 bf fe	brl $1a00fc	skip_f12        BRL get_reset           ; And reset the state machine

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/screen.s

.1a023d					ENSURETEXT
.1a023d	08		php		            PHP
.1a023e	e2 20		sep #$20	            SEP #$20
.1a0240	af 00 00 af	lda $af0000	            LDA @l MASTER_CTRL_REG_L            ; Get the current display mode
.1a0244	89 3c		bit #$3c	            BIT #Mstr_Ctrl_Graph_Mode_En | Mstr_Ctrl_Bitmap_En | Mstr_Ctrl_TileMap_En | Mstr_Ctrl_Sprite_En
.1a0246	f0 08		beq $1a0250	            BEQ textonly                        ; If not, make sure text is enabled
.1a0248					overlay
.1a0248	09 03		ora #$03	            ORA #Mstr_Ctrl_Text_Mode_En | Mstr_Ctrl_Text_Overlay
.1a024a	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.1a024e	80 0c		bra $1a025c	            BRA done
.1a0250					textonly
.1a0250	09 01		ora #$01	            ORA #Mstr_Ctrl_Text_Mode_En
.1a0252	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.1a0256	a9 00		lda #$00	            LDA #CHAN_CONSOLE                   ; Make sure we're writing to the main screen
.1a0258	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.1a025c	28		plp		done        PLP
.1a025d	60		rts		            RTS
.1a025e					ISHOWCURSOR
.1a025e	08		php		            PHP
.1a025f	e2 20		sep #$20	            SEP #$20
.1a0261	c9 00		cmp #$00	            CMP #0
.1a0263	f0 08		beq $1a026d	            BEQ hide
.1a0265	af 10 00 af	lda $af0010	show        LDA @lVKY_TXT_CURSOR_CTRL_REG
.1a0269	09 01		ora #$01	            ORA #Vky_Cursor_Enable
.1a026b	80 06		bra $1a0273	            BRA setit
.1a026d	af 10 00 af	lda $af0010	hide        LDA @lVKY_TXT_CURSOR_CTRL_REG
.1a0271	29 fe		and #$fe	            AND #~Vky_Cursor_Enable
.1a0273	8f 10 00 af	sta $af0010	setit       STA @lVKY_TXT_CURSOR_CTRL_REG
.1a0277	28		plp		            PLP
.1a0278	60		rts		            RTS
.1a0279					ICURSORXY
.1a0279	08		php		            PHP
.1a027a	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.1a027e	28		plp		            PLP
.1a027f	60		rts		            RTS
.1a0280					ICLSCREEN
.1a0280	48		pha		            PHA
.1a0281	da		phx		            PHX
.1a0282	5a		phy		            PHY
.1a0283	0b		phd		            PHD
.1a0284	08		php		            PHP
.1a0285	e2 20		sep #$20	            SEP #$20
.1a0287	c2 10		rep #$10	            REP #$10
.1a0289	a2 00 00	ldx #$0000	            LDX #0
.1a028c	a9 20		lda #$20	loop        LDA #$20
.1a028e	9f 00 a0 af	sta $afa000,x	            STA @lCS_TEXT_MEM_PTR,X     ; Write a space in the text cell
.1a0292	af 1e 00 00	lda $00001e	            LDA @lCURCOLOR
.1a0296	9f 00 c0 af	sta $afc000,x	            STA @lCS_COLOR_MEM_PTR,X    ; Set the color to green on black
.1a029a	e8		inx		            INX                         ; Move to the next character cell
.1a029b	e0 00 20	cpx #$2000	            CPX #$2000
.1a029e	d0 ec		bne $1a028c	            BNE loop
.1a02a0	08		php		            PHP
.1a02a1	c2 20		rep #$20	            REP #$20
.1a02a3	48		pha		            PHA
.1a02a4	a9 00 00	lda #$0000	            LDA #0
.1a02a7	5b		tcd		            TCD
.1a02a8	68		pla		            PLA
.1a02a9	28		plp		            PLP
.1a02aa	a2 00 00	ldx #$0000	            LDX #0                      ; Set cursor to upper-left corner
.1a02ad	a0 00 00	ldy #$0000	            LDY #0
.1a02b0	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.1a02b4	28		plp		            PLP
.1a02b5	2b		pld		            PLD
.1a02b6	7a		ply		            PLY
.1a02b7	fa		plx		            PLX
.1a02b8	68		pla		            PLA
.1a02b9	60		rts		            RTS
.1a02ba					ISCRCPYLINE
.1a02ba	da		phx		            PHX
.1a02bb	5a		phy		            PHY
.1a02bc	0b		phd		            PHD
.1a02bd	08		php		            PHP
.1a02be	08		php		            PHP
.1a02bf	c2 20		rep #$20	            REP #$20
.1a02c1	48		pha		            PHA
.1a02c2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a02c5	5b		tcd		            TCD
.1a02c6	68		pla		            PLA
.1a02c7	28		plp		            PLP
.1a02c8	c2 30		rep #$30	            REP #$30
.1a02ca	af 0c 00 00	lda $00000c	            LDA @l SCREENBEGIN      ; Set INDEX to the first byte of the text screen
.1a02ce	85 08		sta $0808	            STA INDEX
.1a02d0	e2 20		sep #$20	            SEP #$20
.1a02d2	af 0e 00 00	lda $00000e	            LDA @l SCREENBEGIN+2
.1a02d6	c2 20		rep #$20	            REP #$20
.1a02d8	29 ff 00	and #$00ff	            AND #$00FF
.1a02db	85 0a		sta $080a	            STA INDEX+2
.1a02dd	af 11 00 00	lda $000011	            LDA @l COLS_PER_LINE    ; Calculate the offset to the current line
.1a02e1	8f 08 01 00	sta $000108	            STA @l M1_OPERAND_A
.1a02e5	af 1c 00 00	lda $00001c	            LDA @l CURSORY
.1a02e9	3a		dec a		            DEC A
.1a02ea	8f 0a 01 00	sta $00010a	            STA @l M1_OPERAND_B
.1a02ee	18		clc		            CLC                     ; And add it to INDEX
.1a02ef	a5 08		lda $0808	            LDA INDEX
.1a02f1	6f 0c 01 00	adc $00010c	            ADC @l M1_RESULT
.1a02f5	85 08		sta $0808	            STA INDEX
.1a02f7	a5 0a		lda $080a	            LDA INDEX+2
.1a02f9	69 00 00	adc #$0000	            ADC #0
.1a02fc	85 0a		sta $080a	            STA INDEX+2
.1a02fe	e2 20		sep #$20	            SEP #$20
.1a0300	af 0f 00 00	lda $00000f	            LDA @l COLS_VISIBLE
.1a0304	85 8f		sta $088f	            STA MCOUNT
.1a0306	a0 00 00	ldy #$0000	            LDY #0
.1a0309	a2 00 00	ldx #$0000	            LDX #0
.1a030c	b7 08		lda [$0808],y	copy_loop   LDA [INDEX],Y           ; Copy a byte from the screen to the input buffer
.1a030e	9f 00 4f 00	sta $004f00,x	            STA @l INPUTBUF,X
.1a0312	e8		inx		            INX
.1a0313	c8		iny		            INY
.1a0314	c4 8f		cpy $088f	            CPY MCOUNT
.1a0316	d0 f4		bne $1a030c	            BNE copy_loop
.1a0318	af 0f 00 00	lda $00000f	            LDA @l COLS_VISIBLE     ; Starting from the end of the line...
.1a031c	3a		dec a		            DEC A
.1a031d	aa		tax		            TAX
.1a031e	bf 00 4f 00	lda $004f00,x	trim_loop   LDA @l INPUTBUF,X       ; Replace spaces at the end with NULLs
.1a0322	c9 20		cmp #$20	            CMP #CHAR_SP
.1a0324	d0 09		bne $1a032f	            BNE done
.1a0326	a9 00		lda #$00	            LDA #0
.1a0328	9f 00 4f 00	sta $004f00,x	            STA @l INPUTBUF,X
.1a032c	ca		dex		            DEX
.1a032d	10 ef		bpl $1a031e	            BPL trim_loop
.1a032f	28		plp		done        PLP
.1a0330	2b		pld		            PLD
.1a0331	7a		ply		            PLY
.1a0332	fa		plx		            PLX
.1a0333	60		rts		            RTS

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/gabe_defs.s

=$afe880				GABE_MSTR_CTRL      = $AFE880
=$01					GABE_CTRL_PWR_LED   = $01     ; Controls the LED in the Front of the case (Next to the reset button)
=$02					GABE_CTRL_SDC_LED   = $02     ; Controls the LED in the Front of the Case (Next to SDCard)
=$04					GABE_CTRL_STS_LED0  = $04     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$08					GABE_CTRL_STS_LED1  = $08     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$10					GABE_CTRL_BUZZER    = $10     ; Controls the Buzzer
=$80					GABE_CTRL_WRM_RST   = $80     ; Warm Reset (needs to Setup other registers)
=$afe881				GABE_LED_FLASH_CTRL = $AFE881  ; Flashing LED Control
=$01					GABE_LED0_FLASH_CTRL = $01     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$02					GABE_LED1_FLASH_CTRL = $02     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED1 to manually control)
=$10					GABE_LD0_FLASH_FRQ0   = $10     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$20					GABE_LD0_FLASH_FRQ1   = $20     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$40					GABE_LD1_FLASH_FRQ0   = $40     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$80					GABE_LD1_FLASH_FRQ1   = $80     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$afe882				GABE_RST_AUTH0      = $AFE882 ; Must Contain the BYTE $AD for Reset to Activate
=$afe883				GABE_RST_AUTH1      = $AFE883 ; Must Contain the BYTE $DE for Reset to Activate
=$afe884				GABE_RNG_DAT_LO     = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_DAT_HI     = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe884				GABE_RNG_SEED_LO    = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_SEED_HI    = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe886				GABE_RNG_STAT       = $AFE886 ;
=$80					GABE_RNG_LFSR_DONE  = $80     ; indicates that Output = SEED Database
=$afe886				GABE_RNG_CTRL       = $AFE886 ;
=$01					GABE_RNG_CTRL_EN    = $01     ; Enable the LFSR BLOCK_LEN
=$02					GABE_RNG_CTRL_DV    = $02     ; After Setting the Seed Value, Toggle that Bit for it be registered
=$afe887				GABE_SYS_STAT       = $AFE887 ;
=$01					GABE_SYS_STAT_MID0  = $01     ; Machine ID -- LSB
=$02					GABE_SYS_STAT_MID1  = $02     ; Machine ID --
=$04					GABE_SYS_STAT_MID2  = $04     ; Machine ID -- MSB
=$10					GABE_SYS_STAT_EXP   = $10     ; if Zero, there is an Expansion Card Preset
=$40					GABE_SYS_STAT_CPUA  = $40     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$80					GABE_SYS_STAT_CPUX  = $80     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$afe88a				GABE_SUBVERSION_LO  = $AFE88A
=$afe88b				GABE_SUBVERSION_HI  = $AFE88B
=$afe88c				GABE_VERSION_LO     = $AFE88C
=$afe88d				GABE_VERSION_HI     = $AFE88D
=$afe88e				GABE_MODEL_LO       = $AFE88E
=$afe88f				GABE_MODEL_HI       = $AFE88F

;******  Return to file: src\C256/io_c256.s

=32					BORDER_WIDTH = 32               ; The width of the border (when it is on)
=72					TEXT_COLS_WB = 72               ; Number of columns of text with the border enabled
=52					TEXT_ROWS_WB = 52               ; Number of rows of text with the border enabled
=80					TEXT_COLS_WOB = 80              ; Number of columns of text with no border enabled
=60					TEXT_ROWS_WOB = 60              ; Number of rows of text with no border enabled
.1a0334					INITIO
.1a0334	e2 20		sep #$20	            SEP #$20
.1a0336	20 69 03	jsr $1a0369	            JSR INITRNG
.1a0339	a2 00 00	ldx #$0000	            LDX #0              ; Clear all the sprite control shadow registers
.1a033c	a9 00		lda #$00	            LDA #0
.1a033e	9f 18 f0 1a	sta $1af018,x	sp_loop     STA GS_SP_CONTROL,X
.1a0342	e8		inx		            INX
.1a0343	e0 40 00	cpx #$0040	            CPX #SP_MAX
.1a0346	d0 f6		bne $1a033e	            BNE sp_loop
.1a0348	a9 80		lda #$80	            LDA #DEV_SCREEN
.1a034a	8f b4 08 00	sta $0008b4	            STA @lBCONSOLE
.1a034e	e2 20		sep #$20	            SEP #$20
.1a0350	a9 00		lda #$00	            LDA #0                  ; Clear the lock key flags
.1a0352	8f 89 0f 00	sta $000f89	            STA @lKEYBOARD_LOCKS
.1a0356	a9 00		lda #$00	            LDA #0
.1a0358	8f 00 02 af	sta $af0200	            STA @l TL0_CONTROL_REG
.1a035c	8f 0c 02 af	sta $af020c	            STA @l TL1_CONTROL_REG
.1a0360	8f 18 02 af	sta $af0218	            STA @l TL2_CONTROL_REG
.1a0364	8f 24 02 af	sta $af0224	            STA @l TL3_CONTROL_REG
.1a0368					done
.1a0368	60		rts		            RTS
.1a0369					INITRNG
.1a0369	08		php		            PHP
.1a036a	e2 20		sep #$20	            SEP #$20
.1a036c	af 0e 08 af	lda $af080e	            LDA @l RTC_CTRL         ; Pause updates to the clock registers
.1a0370	09 08		ora #$08	            ORA #%00001000
.1a0372	8f 0e 08 af	sta $af080e	            STA @l RTC_CTRL
.1a0376	af 00 08 af	lda $af0800	            LDA @l RTC_SEC          ; Set the random number generator seed
.1a037a	8f 84 e8 af	sta $afe884	            STA @l GABE_RNG_SEED_LO
.1a037e	af 02 08 af	lda $af0802	            LDA @l RTC_MIN
.1a0382	8f 85 e8 af	sta $afe885	            STA @l GABE_RNG_SEED_HI
.1a0386	a9 03		lda #$03	            LDA #GABE_RNG_CTRL_DV | GABE_RNG_CTRL_EN
.1a0388	8f 86 e8 af	sta $afe886	            STA @l GABE_RNG_CTRL    ; Load the seed into the RNG
.1a038c	af 0e 08 af	lda $af080e	            LDA @l RTC_CTRL         ; Re-enable updates to the clock registers
.1a0390	29 f7		and #$f7	            AND #%11110111
.1a0392	8f 0e 08 af	sta $af080e	            STA @l RTC_CTRL
.1a0396	ea		nop		            NOP                     ; Give the RNG some time... not sure if needed, really
.1a0397	ea		nop		            NOP
.1a0398	ea		nop		            NOP
.1a0399	a9 01		lda #$01	            LDA #GABE_RNG_CTRL_EN   ; Turn on the random number genertator
.1a039b	8f 86 e8 af	sta $afe886	            STA @l GABE_RNG_CTRL
.1a039f	28		plp		            PLP
.1a03a0	60		rts		            RTS
.1a03a1					SCREEN_PUTC
.1a03a1	08		php		            PHP
.1a03a2	e2 20		sep #$20	            SEP #$20
.1a03a4	48		pha		            PHA
.1a03a5	48		pha		            PHA
.1a03a6	a9 00		lda #$00	            LDA #CHAN_CONSOLE       ; Switch to the console device
.1a03a8	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.1a03ac	68		pla		            PLA
.1a03ad	22 18 10 00	jsl $001018	            JSL FK_PUTC
.1a03b1	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.1a03b5	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.1a03b7	d0 f8		bne $1a03b1	            BNE loop                ; Yes: wait until it's released
.1a03b9	68		pla		            PLA
.1a03ba	28		plp		            PLP
.1a03bb	60		rts		            RTS
.1a03bc					UART_PUTC
.1a03bc	08		php		            PHP
.1a03bd	e2 20		sep #$20	            SEP #$20
.1a03bf	48		pha		            PHA
.1a03c0	48		pha		            PHA
.1a03c1	a9 01		lda #$01	            LDA #CHAN_COM1          ; Switch to COM1
.1a03c3	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.1a03c7	68		pla		            PLA
.1a03c8	22 18 10 00	jsl $001018	            JSL FK_PUTC
.1a03cc	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.1a03d0	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.1a03d2	d0 f8		bne $1a03cc	            BNE loop                ; Yes: wait until it's released
.1a03d4	68		pla		            PLA
.1a03d5	28		plp		            PLP
.1a03d6	60		rts		            RTS
.1a03d7					PRINTCR
.1a03d7	08		php		            PHP
.1a03d8	c2 20		rep #$20	            REP #$20
.1a03da	48		pha		            PHA
.1a03db	e2 20		sep #$20	            SEP #$20
.1a03dd	a9 0d		lda #$0d	            LDA #CHAR_CR
.1a03df	20 18 00	jsr $1a0018	            JSR PRINTC
.1a03e2	c2 20		rep #$20	            REP #$20
.1a03e4	68		pla		            PLA
.1a03e5	28		plp		            PLP
.1a03e6	60		rts		            RTS
.1a03e7					PRINTH
.1a03e7	08		php		            PHP
.1a03e8	22 78 10 00	jsl $001078	            JSL FK_IPRINTH
.1a03ec	28		plp		            PLP
.1a03ed	60		rts		            RTS

;******  Return to file: src\bios.s

=10					LINES_PER_PAGE = 10     ; The number of lines to print on a page before pausing
=$80					DEV_SCREEN = $80        ; Use the screen and keyboard for the console device
=$40					DEV_UART = $40          ; Use UART for console device
=$20					DEV_BUFFER = $20        ; Use the current text memory buffer for output or input
>08b4					BCONSOLE    .byte ?     ; Device for BASIC console
>08b5					SAVE_A      .byte ?     ; Save spot for the A register
>08b6					LINECOUNT   .byte ?     ; Counter for new lines to support pagination
.1a03ee					PAGINATE
.1a03ee	08		php		            PHP
.1a03ef	0b		phd		            PHD
.1a03f0	08		php		            PHP
.1a03f1	c2 20		rep #$20	            REP #$20
.1a03f3	48		pha		            PHA
.1a03f4	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a03f7	5b		tcd		            TCD
.1a03f8	68		pla		            PLA
.1a03f9	28		plp		            PLP
.1a03fa	e2 20		sep #$20	            SEP #$20
.1a03fc	a5 b6		lda $08b6	            LDA LINECOUNT           ; Check the line count
.1a03fe	1a		inc a		            INC A
.1a03ff	85 b6		sta $08b6	            STA LINECOUNT
.1a0401	cf 13 00 00	cmp $000013	            CMP @l LINES_VISIBLE
.1a0405	90 05		bcc $1a040c	            BLT done                ; If < limit, just return
.1a0407	20 14 00	jsr $1a0014	            JSR GETKEY
.1a040a	64 b6		stz $08b6	            STZ LINECOUNT           ; And reset the line count
.1a040c	2b		pld		done        PLD
.1a040d	28		plp		            PLP
.1a040e	60		rts		            RTS
.1a040f					IPRINTC
.1a040f	da		phx		            PHX
.1a0410	5a		phy		            PHY
.1a0411	0b		phd		            PHD
.1a0412	08		php		            PHP
.1a0413	08		php		            PHP
.1a0414	c2 20		rep #$20	            REP #$20
.1a0416	48		pha		            PHA
.1a0417	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a041a	5b		tcd		            TCD
.1a041b	68		pla		            PLA
.1a041c	28		plp		            PLP
.1a041d	e2 20		sep #$20	            SEP #$20
.1a041f	c2 10		rep #$10	            REP #$10
.1a0421	8f b5 08 00	sta $0008b5	            STA @lSAVE_A
.1a0425	af b4 08 00	lda $0008b4	chk_out     LDA @lBCONSOLE      ; Check to see if we should send to an output buffer
.1a0429	29 20		and #$20	            AND #DEV_BUFFER
.1a042b	f0 07		beq $1a0434	            BEQ check_scrn      ; No... move on to the hardware screen
.1a042d	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.1a0431	20 28 00	jsr $1a0028	            JSR OBUFF_PUTC
.1a0434	af b4 08 00	lda $0008b4	check_scrn  LDA @lBCONSOLE
.1a0438	29 80		and #$80	            AND #DEV_SCREEN     ; Check to see if the screen is selected
.1a043a	f0 07		beq $1a0443	            BEQ send_uart
.1a043c	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.1a0440	20 a1 03	jsr $1a03a1	            JSR SCREEN_PUTC
.1a0443	af b4 08 00	lda $0008b4	send_uart   LDA @lBCONSOLE
.1a0447	29 40		and #$40	            AND #DEV_UART       ; Check to see if the UART is active
.1a0449	f0 14		beq $1a045f	            BEQ done
.1a044b	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.1a044f	20 bc 03	jsr $1a03bc	            JSR UART_PUTC
.1a0452	af b5 08 00	lda $0008b5	            LDA @lSAVE_A        ; If sending a CR to the serial port
.1a0456	c9 0d		cmp #$0d	            CMP #CHAR_CR
.1a0458	d0 05		bne $1a045f	            BNE done
.1a045a	a9 0a		lda #$0a	            LDA #CHAR_LF        ; Send a linefeed after
.1a045c	20 bc 03	jsr $1a03bc	            JSR UART_PUTC
.1a045f	28		plp		done        PLP
.1a0460	2b		pld		            PLD
.1a0461	7a		ply		            PLY
.1a0462	fa		plx		            PLX
.1a0463	60		rts		            RTS
.1a0464					PRINTS
.1a0464	08		php		            PHP
.1a0465	e2 20		sep #$20	            SEP #$20
.1a0467	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.1a046a	f0 06		beq $1a0472	            BEQ done
.1a046c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a046f	e8		inx		            INX
.1a0470	80 f5		bra $1a0467	            BRA loop
.1a0472	28		plp		done        PLP
.1a0473	60		rts		            RTS
.1a0474					PRHEXW
.1a0474	08		php		            PHP
.1a0475	c2 20		rep #$20	            REP #$20
.1a0477	48		pha		            PHA
.1a0478	48		pha		            PHA
.1a0479	4a		lsr a		            LSR A
.1a047a	4a		lsr a		            LSR A
.1a047b	4a		lsr a		            LSR A
.1a047c	4a		lsr a		            LSR A
.1a047d	4a		lsr a		            LSR A
.1a047e	4a		lsr a		            LSR A
.1a047f	4a		lsr a		            LSR A
.1a0480	4a		lsr a		            LSR A
.1a0481	20 8e 04	jsr $1a048e	            JSR PRHEXB
.1a0484	68		pla		            PLA
.1a0485	29 ff 00	and #$00ff	            AND #$00FF
.1a0488	20 8e 04	jsr $1a048e	            JSR PRHEXB
.1a048b	68		pla		            PLA
.1a048c	28		plp		            PLP
.1a048d	60		rts		            RTS
.1a048e					PRHEXB
.1a048e	08		php		            PHP
.1a048f	c2 20		rep #$20	            REP #$20
.1a0491	48		pha		            PHA
.1a0492	e2 20		sep #$20	            SEP #$20
.1a0494	48		pha		            PHA
.1a0495	4a		lsr a		            LSR A
.1a0496	4a		lsr a		            LSR A
.1a0497	4a		lsr a		            LSR A
.1a0498	4a		lsr a		            LSR A
.1a0499	20 a5 04	jsr $1a04a5	            JSR PRHEXN
.1a049c	68		pla		            PLA
.1a049d	20 a5 04	jsr $1a04a5	            JSR PRHEXN
.1a04a0	c2 20		rep #$20	            REP #$20
.1a04a2	68		pla		            PLA
.1a04a3	28		plp		            PLP
.1a04a4	60		rts		            RTS
.1a04a5					PRHEXN
.1a04a5	08		php		            PHP
.1a04a6	c2 30		rep #$30	            REP #$30
.1a04a8	da		phx		            PHX
.1a04a9	29 0f 00	and #$000f	            AND #$000F
.1a04ac	aa		tax		            TAX
.1a04ad	bf 00 d0 1a	lda $1ad000,x	            LDA @lHEXDIGITS,X
.1a04b1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a04b4	fa		plx		            PLX
.1a04b5	28		plp		            PLP
.1a04b6	60		rts		            RTS
>1ad000	30 31 32 33 34 35 36 37		HEXDIGITS   .text "0123456789ABCDEF"
>1ad008	38 39 41 42 43 44 45 46

;******  Return to file: src\basic816.s


;******  Processing file: src\utilities.s

.1a04b7					PRTRACE
.1a04b7	08		php		            PHP
.1a04b8	c2 30		rep #$30	            REP #$30
.1a04ba	48		pha		            PHA
.1a04bb	da		phx		            PHX
.1a04bc	5a		phy		            PHY
.1a04bd	8b		phb		            PHB
.1a04be	0b		phd		            PHD
.1a04bf	c2 30		rep #$30	            REP #$30
.1a04c1	a3 0b		lda $0b,s	            LDA 11,S        ; Get the return address
.1a04c3	18		clc		calc_addr   CLC
.1a04c4	69 03 00	adc #$0003	            ADC #3          ; Add 3 to skip over the following branch
.1a04c7	aa		tax		            TAX
.1a04c8	e2 20		sep #$20	            SEP #$20
.1a04ca	a9 1a		lda #$1a	            LDA #`PRTRACE
.1a04cc	48		pha		            PHA
.1a04cd	ab		plb		            PLB
.1a04ce	bd 00 00	lda $0000,x	pr_loop     LDA #0,B,X
.1a04d1	f0 06		beq $1a04d9	            BEQ done
.1a04d3	20 a1 03	jsr $1a03a1	            JSR SCREEN_PUTC
.1a04d6	e8		inx		            INX
.1a04d7	80 f5		bra $1a04ce	            BRA pr_loop
.1a04d9					done
.1a04d9	c2 30		rep #$30	            REP #$30
.1a04db	2b		pld		            PLD
.1a04dc	ab		plb		            PLB
.1a04dd	7a		ply		            PLY
.1a04de	fa		plx		            PLX
.1a04df	68		pla		            PLA
.1a04e0	28		plp		            PLP
.1a04e1	60		rts		            RTS
.1a04e2					ISALPHA
.1a04e2	08		php		            PHP
.1a04e3	e2 20		sep #$20	            SEP #$20
.1a04e5	c9 5b		cmp #$5b	            CMP #'Z'+1
.1a04e7	b0 04		bcs $1a04ed	            BGE not_upper
.1a04e9	c9 41		cmp #$41	            CMP #'A'
.1a04eb	b0 0b		bcs $1a04f8	            BGE is_alpha
.1a04ed	c9 7b		cmp #$7b	not_upper   CMP #'z'+1
.1a04ef	b0 04		bcs $1a04f5	            BGE not_alpha
.1a04f1	c9 61		cmp #$61	            CMP #'a'
.1a04f3	b0 03		bcs $1a04f8	            BGE is_alpha
.1a04f5					not_alpha
.1a04f5	28		plp		            PLP
.1a04f6	18		clc		            CLC
.1a04f7	60		rts		            RTS
.1a04f8					is_alpha
.1a04f8	28		plp		            PLP
.1a04f9	38		sec		            SEC
.1a04fa	60		rts		            RTS
.1a04fb					ISNUMERAL
.1a04fb	08		php		            PHP
.1a04fc	e2 20		sep #$20	            SEP #$20
.1a04fe	c9 3a		cmp #$3a	            CMP #'9'+1
.1a0500	b0 04		bcs $1a0506	            BGE ret_false
.1a0502	c9 30		cmp #$30	            CMP #'0'
.1a0504	b0 03		bcs $1a0509	            BGE ret_true
.1a0506	28		plp		ret_false   PLP
.1a0507	18		clc		            CLC
.1a0508	60		rts		            RTS
.1a0509	28		plp		ret_true    PLP
.1a050a	38		sec		            SEC
.1a050b	60		rts		            RTS
.1a050c					ISHEX
.1a050c	08		php		            PHP
.1a050d	e2 20		sep #$20	            SEP #$20
.1a050f	c9 3a		cmp #$3a	            CMP #'9'+1
.1a0511	b0 04		bcs $1a0517	            BGE chk_lca2f
.1a0513	c9 30		cmp #$30	            CMP #'0'
.1a0515	b0 13		bcs $1a052a	            BGE ret_true
.1a0517	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.1a0519	b0 04		bcs $1a051f	            BGE chk_uca2f
.1a051b	c9 61		cmp #$61	            CMP #'a'
.1a051d	b0 0b		bcs $1a052a	            BGE ret_true
.1a051f	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.1a0521	b0 04		bcs $1a0527	            BGE ret_false
.1a0523	c9 41		cmp #$41	            CMP #'A'
.1a0525	b0 03		bcs $1a052a	            BGE ret_true
.1a0527	28		plp		ret_false   PLP
.1a0528	18		clc		            CLC
.1a0529	60		rts		            RTS
.1a052a	28		plp		ret_true    PLP
.1a052b	38		sec		            SEC
.1a052c	60		rts		            RTS
.1a052d					HEX2BIN
.1a052d	08		php		            PHP
.1a052e	e2 20		sep #$20	            SEP #$20
.1a0530	c9 3a		cmp #$3a	            CMP #'9'+1          ; Check to see if '0'..'9'
.1a0532	b0 04		bcs $1a0538	            BGE chk_lca2f
.1a0534	c9 30		cmp #$30	            CMP #'0'
.1a0536	b0 12		bcs $1a054a	            BGE conv_09         ; Yes: convert it
.1a0538	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.1a053a	b0 04		bcs $1a0540	            BGE chk_uca2f
.1a053c	c9 61		cmp #$61	            CMP #'a'
.1a053e	b0 0f		bcs $1a054f	            BGE conv_lcaf
.1a0540	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.1a0542	b0 04		bcs $1a0548	            BGE done
.1a0544	c9 41		cmp #$41	            CMP #'A'
.1a0546	b0 09		bcs $1a0551	            BGE conv_ucaf
.1a0548	28		plp		done        PLP
.1a0549	60		rts		            RTS
.1a054a	38		sec		conv_09     SEC                 ; Convert digits '0'..'9'
.1a054b	e9 30		sbc #$30	            SBC #'0'
.1a054d	80 f9		bra $1a0548	            BRA done
.1a054f	29 df		and #$df	conv_lcaf   AND #%11011111      ; Convert to upper case
.1a0551	38		sec		conv_ucaf   SEC
.1a0552	e9 37		sbc #$37	            SBC #'A'-10         ; Convert 'A'..'F'
.1a0554	80 f2		bra $1a0548	            BRA done
.1a0556					TOUPPERA
.1a0556	08		php		            PHP
.1a0557	e2 20		sep #$20	            SEP #$20
.1a0559	c9 7b		cmp #$7b	            CMP #'z'+1
.1a055b	b0 06		bcs $1a0563	            BCS done
.1a055d	c9 61		cmp #$61	            CMP #'a'
.1a055f	90 02		bcc $1a0563	            BCC done
.1a0561	29 df		and #$df	            AND #%11011111
.1a0563	28		plp		done        PLP
.1a0564	60		rts		            RTS
.1a0565					TOUPPER
.1a0565	08		php		            PHP
.1a0566	e2 20		sep #$20	            SEP #$20
.1a0568	c2 10		rep #$10	            REP #$10
.1a056a	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.1a056d	f0 09		beq $1a0578	            BEQ done
.1a056f	20 56 05	jsr $1a0556	            JSR TOUPPERA
.1a0572	9d 00 00	sta $0000,x	            STA #0,B,X
.1a0575	e8		inx		continue    INX
.1a0576	80 f2		bra $1a056a	            BRA loop
.1a0578	28		plp		done        PLP
.1a0579	60		rts		            RTS
.1a057a					MULINT10
.1a057a	08		php		                PHP
.1a057b	0b		phd		                PHD
.1a057c	08		php		            PHP
.1a057d	c2 20		rep #$20	            REP #$20
.1a057f	48		pha		            PHA
.1a0580	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0583	5b		tcd		            TCD
.1a0584	68		pla		            PLA
.1a0585	28		plp		            PLP
.1a0586	c2 20		rep #$20	            REP #$20
.1a0588	48		pha		                PHA
.1a0589	06 23		asl $0823	                ASL ARGUMENT1           ; 7 -- 20 -- 74
.1a058b	26 25		rol $0825	                ROL ARGUMENT1+2         ; 7
.1a058d	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.1a058f	85 0c		sta $080c	                STA SCRATCH             ; 4
.1a0591	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.1a0593	85 0e		sta $080e	                STA SCRATCH+2           ; 4
.1a0595	06 0c		asl $080c	                ASL SCRATCH             ; 7 -- 28
.1a0597	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.1a0599	06 0c		asl $080c	                ASL SCRATCH             ; 7
.1a059b	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.1a059d	18		clc		                CLC                     ; 2 -- 26
.1a059e	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.1a05a0	65 0c		adc $080c	                ADC SCRATCH             ; 4
.1a05a2	85 23		sta $0823	                STA ARGUMENT1           ; 4
.1a05a4	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.1a05a6	65 0e		adc $080e	                ADC SCRATCH+2           ; 4
.1a05a8	85 25		sta $0825	                STA ARGUMENT1+2         ; 4
.1a05aa	68		pla		                PLA
.1a05ab	2b		pld		                PLD
.1a05ac	28		plp		                PLP
.1a05ad	60		rts		            RTS
.1a05ae					DIVINT10
.1a05ae	08		php		                PHP
.1a05af	0b		phd		                PHD
.1a05b0	08		php		            PHP
.1a05b1	c2 20		rep #$20	            REP #$20
.1a05b3	48		pha		            PHA
.1a05b4	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a05b7	5b		tcd		            TCD
.1a05b8	68		pla		            PLA
.1a05b9	28		plp		            PLP
.1a05ba	c2 20		rep #$20	            REP #$20
.1a05bc	a5 23		lda $0823	                LDA ARGUMENT1
.1a05be	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.1a05c2	a9 0a 00	lda #$000a	                LDA #10
.1a05c5	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.1a05c9	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.1a05cd	85 23		sta $0823	                STA ARGUMENT1
.1a05cf	64 25		stz $0825	                STZ ARGUMENT1+2
.1a05d1	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.1a05d5	85 29		sta $0829	                STA ARGUMENT2
.1a05d7	64 2b		stz $082b	                STZ ARGUMENT2+2
.1a05d9	e2 20		sep #$20	            SEP #$20
.1a05db	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a05dd	85 27		sta $0827	                STA ARGTYPE1
.1a05df	85 2d		sta $082d	                STA ARGTYPE2
.1a05e1	2b		pld		                PLD
.1a05e2	28		plp		                PLP
.1a05e3	60		rts		            RTS
.1a05e4					DIVINT100
.1a05e4	08		php		                PHP
.1a05e5	0b		phd		                PHD
.1a05e6	08		php		            PHP
.1a05e7	c2 20		rep #$20	            REP #$20
.1a05e9	48		pha		            PHA
.1a05ea	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a05ed	5b		tcd		            TCD
.1a05ee	68		pla		            PLA
.1a05ef	28		plp		            PLP
.1a05f0	c2 20		rep #$20	            REP #$20
.1a05f2	a5 23		lda $0823	                LDA ARGUMENT1
.1a05f4	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.1a05f8	a9 64 00	lda #$0064	                LDA #100
.1a05fb	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.1a05ff	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.1a0603	85 23		sta $0823	                STA ARGUMENT1
.1a0605	64 25		stz $0825	                STZ ARGUMENT1+2
.1a0607	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.1a060b	85 29		sta $0829	                STA ARGUMENT2
.1a060d	64 2b		stz $082b	                STZ ARGUMENT2+2
.1a060f	e2 20		sep #$20	            SEP #$20
.1a0611	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a0613	85 27		sta $0827	                STA ARGTYPE1
.1a0615	85 2d		sta $082d	                STA ARGTYPE2
.1a0617	2b		pld		                PLD
.1a0618	28		plp		                PLP
.1a0619	60		rts		            RTS
.1a061a					IS_ARG1_Z
.1a061a	08		php		                PHP
.1a061b	c2 20		rep #$20	            REP #$20
.1a061d	a5 23		lda $0823	                LDA ARGUMENT1
.1a061f	d0 08		bne $1a0629	                BNE return_false
.1a0621	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a0623	d0 04		bne $1a0629	                BNE return_false
.1a0625	28		plp		return_true     PLP
.1a0626	e2 02		sep #$02	                SEP #$02        ; Set Z
.1a0628	60		rts		            RTS
.1a0629	28		plp		return_false    PLP
.1a062a	c2 02		rep #$02	                REP #$02        ; Clear Z
.1a062c	60		rts		            RTS
.1a062d					SET_TRUE
.1a062d	08		php		                PHP
.1a062e	c2 30		rep #$30	            REP #$30
.1a0630	a9 ff ff	lda #$ffff	                LDA #$FFFF
.1a0633	85 23		sta $0823	                STA ARGUMENT1
.1a0635	85 25		sta $0825	                STA ARGUMENT1+2
.1a0637	e2 20		sep #$20	            SEP #$20
.1a0639	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a063b	85 27		sta $0827	                STA ARGTYPE1
.1a063d	28		plp		                PLP
.1a063e	60		rts		            RTS
.1a063f					SET_FALSE
.1a063f	08		php		                PHP
.1a0640	c2 30		rep #$30	            REP #$30
.1a0642	a9 00 00	lda #$0000	                LDA #0
.1a0645	85 23		sta $0823	                STA ARGUMENT1
.1a0647	85 25		sta $0825	                STA ARGUMENT1+2
.1a0649	e2 20		sep #$20	            SEP #$20
.1a064b	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a064d	85 27		sta $0827	                STA ARGTYPE1
.1a064f	28		plp		                PLP
.1a0650	60		rts		            RTS
.1a0651					ASS_ARG1_INT
.1a0651	08		php		                PHP
.1a0652	e2 20		sep #$20	            SEP #$20
.1a0654	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.1a0656	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a0658	f0 07		beq $1a0661	                BEQ done                ; If so: just return
.1a065a	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.1a065c	d0 05		bne $1a0663	                BNE TYPE_ERR            ; If not: throw an error
.1a065e	20 0a 5c	jsr $1a5c0a	            JSR FTOI
.1a0661	28		plp		done            PLP
.1a0662	60		rts		            RTS
.1a0663					TYPE_ERR
.1a0663	08		php		            PHP
.1a0664	c2 20		rep #$20	            REP #$20
.1a0666	48		pha		            PHA
.1a0667	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a066a	5b		tcd		            TCD
.1a066b	68		pla		            PLA
.1a066c	28		plp		            PLP
.1a066d	e2 20		sep #$20	            SEP #$20
.1a066f	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0671	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0675	c2 20		rep #$20	            REP #$20
.1a0677	29 ff 00	and #$00ff	            AND #$00FF
.1a067a	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a067d	e2 20		sep #$20	            SEP #$20
.1a067f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0682					ASS_ARG2_INT
.1a0682	08		php		                PHP
.1a0683	e2 20		sep #$20	            SEP #$20
.1a0685	a5 2d		lda $082d	                LDA ARGTYPE2                ; Verify that the type is INTEGER
.1a0687	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a0689	f0 37		beq $1a06c2	                BEQ done                    ; If so: just return
.1a068b	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; Check if it's a float
.1a068d	d0 35		bne $1a06c4	                BNE TYPE_ERR                ; If not: throw an error
.1a068f	c2 20		rep #$20	            REP #$20
.1a0691	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a0693	48		pha		            PHA
.1a0694	a5 23		lda $0823	            LDA ARGUMENT1
.1a0696	48		pha		            PHA
.1a0697	c2 20		rep #$20	            REP #$20
.1a0699	a5 29		lda $0829	            LDA ARGUMENT2
.1a069b	85 23		sta $0823	            STA ARGUMENT1
.1a069d	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a069f	85 25		sta $0825	            STA ARGUMENT1+2
.1a06a1	e2 20		sep #$20	            SEP #$20
.1a06a3	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.1a06a5	85 27		sta $0827	            STA ARGTYPE1
.1a06a7	20 0a 5c	jsr $1a5c0a	            JSR FTOI
.1a06aa	c2 20		rep #$20	            REP #$20
.1a06ac	a5 23		lda $0823	            LDA ARGUMENT1
.1a06ae	85 29		sta $0829	            STA ARGUMENT2
.1a06b0	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a06b2	85 2b		sta $082b	            STA ARGUMENT2+2
.1a06b4	e2 20		sep #$20	            SEP #$20
.1a06b6	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a06b8	85 2d		sta $082d	            STA ARGTYPE2
.1a06ba	c2 20		rep #$20	            REP #$20
.1a06bc	68		pla		            PLA
.1a06bd	85 23		sta $0823	            STA ARGUMENT1
.1a06bf	68		pla		            PLA
.1a06c0	85 25		sta $0825	            STA ARGUMENT1+2
.1a06c2	28		plp		done            PLP
.1a06c3	60		rts		            RTS
.1a06c4					TYPE_ERR
.1a06c4	08		php		            PHP
.1a06c5	c2 20		rep #$20	            REP #$20
.1a06c7	48		pha		            PHA
.1a06c8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a06cb	5b		tcd		            TCD
.1a06cc	68		pla		            PLA
.1a06cd	28		plp		            PLP
.1a06ce	e2 20		sep #$20	            SEP #$20
.1a06d0	a9 04		lda #$04	            LDA #ERR_TYPE
.1a06d2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a06d6	c2 20		rep #$20	            REP #$20
.1a06d8	29 ff 00	and #$00ff	            AND #$00FF
.1a06db	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a06de	e2 20		sep #$20	            SEP #$20
.1a06e0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a06e3					ASS_ARG1_STR
.1a06e3	08		php		                PHP
.1a06e4	e2 20		sep #$20	            SEP #$20
.1a06e6	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is STRING
.1a06e8	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a06ea	d0 02		bne $1a06ee	                BNE TYPE_ERR
.1a06ec	28		plp		                PLP
.1a06ed	60		rts		            RTS
.1a06ee					TYPE_ERR
.1a06ee	08		php		            PHP
.1a06ef	c2 20		rep #$20	            REP #$20
.1a06f1	48		pha		            PHA
.1a06f2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a06f5	5b		tcd		            TCD
.1a06f6	68		pla		            PLA
.1a06f7	28		plp		            PLP
.1a06f8	e2 20		sep #$20	            SEP #$20
.1a06fa	a9 04		lda #$04	            LDA #ERR_TYPE
.1a06fc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0700	c2 20		rep #$20	            REP #$20
.1a0702	29 ff 00	and #$00ff	            AND #$00FF
.1a0705	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a0708	e2 20		sep #$20	            SEP #$20
.1a070a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a070d					ASS_ARG1_INT16
.1a070d	08		php		                PHP
.1a070e	e2 20		sep #$20	            SEP #$20
.1a0710	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.1a0712	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a0714	f0 07		beq $1a071d	                BEQ check_range         ; If so: check the range
.1a0716	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.1a0718	d0 0b		bne $1a0725	                BNE TYPE_ERR            ; If not: throw an error
.1a071a	20 0a 5c	jsr $1a5c0a	            JSR FTOI
.1a071d					check_range
.1a071d	c2 20		rep #$20	            REP #$20
.1a071f	a5 25		lda $0825	                LDA ARGUMENT1+2         ; Validate it is 16-bit
.1a0721	d0 21		bne $1a0744	                BNE range_err
.1a0723	28		plp		                PLP
.1a0724	60		rts		            RTS
.1a0725					TYPE_ERR
.1a0725	08		php		            PHP
.1a0726	c2 20		rep #$20	            REP #$20
.1a0728	48		pha		            PHA
.1a0729	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a072c	5b		tcd		            TCD
.1a072d	68		pla		            PLA
.1a072e	28		plp		            PLP
.1a072f	e2 20		sep #$20	            SEP #$20
.1a0731	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0733	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0737	c2 20		rep #$20	            REP #$20
.1a0739	29 ff 00	and #$00ff	            AND #$00FF
.1a073c	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a073f	e2 20		sep #$20	            SEP #$20
.1a0741	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0744					RANGE_ERR
.1a0744	08		php		            PHP
.1a0745	c2 20		rep #$20	            REP #$20
.1a0747	48		pha		            PHA
.1a0748	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a074b	5b		tcd		            TCD
.1a074c	68		pla		            PLA
.1a074d	28		plp		            PLP
.1a074e	e2 20		sep #$20	            SEP #$20
.1a0750	a9 09		lda #$09	            LDA #ERR_RANGE
.1a0752	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0756	c2 20		rep #$20	            REP #$20
.1a0758	29 ff 00	and #$00ff	            AND #$00FF
.1a075b	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a075e	e2 20		sep #$20	            SEP #$20
.1a0760	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0763					ASS_ARG1_BYTE
.1a0763	08		php		                PHP
.1a0764	e2 20		sep #$20	            SEP #$20
.1a0766	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.1a0768	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a076a	f0 07		beq $1a0773	                BEQ check_range         ; If so: check the range
.1a076c	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.1a076e	d0 11		bne $1a0781	                BNE TYPE_ERR            ; If not: throw an error
.1a0770	20 0a 5c	jsr $1a5c0a	            JSR FTOI
.1a0773	a5 26		lda $0826	check_range     LDA ARGUMENT1+3         ; Validate that the value is in byte range
.1a0775	d0 29		bne $1a07a0	                BNE RANGE_ERR           ; If not... throw a range error
.1a0777	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a0779	d0 25		bne $1a07a0	                BNE RANGE_ERR
.1a077b	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a077d	d0 21		bne $1a07a0	                BNE RANGE_ERR
.1a077f	28		plp		                PLP
.1a0780	60		rts		            RTS
.1a0781					TYPE_ERR
.1a0781	08		php		            PHP
.1a0782	c2 20		rep #$20	            REP #$20
.1a0784	48		pha		            PHA
.1a0785	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0788	5b		tcd		            TCD
.1a0789	68		pla		            PLA
.1a078a	28		plp		            PLP
.1a078b	e2 20		sep #$20	            SEP #$20
.1a078d	a9 04		lda #$04	            LDA #ERR_TYPE
.1a078f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0793	c2 20		rep #$20	            REP #$20
.1a0795	29 ff 00	and #$00ff	            AND #$00FF
.1a0798	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a079b	e2 20		sep #$20	            SEP #$20
.1a079d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a07a0					RANGE_ERR
.1a07a0	08		php		            PHP
.1a07a1	c2 20		rep #$20	            REP #$20
.1a07a3	48		pha		            PHA
.1a07a4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a07a7	5b		tcd		            TCD
.1a07a8	68		pla		            PLA
.1a07a9	28		plp		            PLP
.1a07aa	e2 20		sep #$20	            SEP #$20
.1a07ac	a9 09		lda #$09	            LDA #ERR_RANGE
.1a07ae	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a07b2	c2 20		rep #$20	            REP #$20
.1a07b4	29 ff 00	and #$00ff	            AND #$00FF
.1a07b7	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a07ba	e2 20		sep #$20	            SEP #$20
.1a07bc	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a07bf					ASS_ARG1_FLOAT
.1a07bf	08		php		                PHP
.1a07c0	e2 20		sep #$20	            SEP #$20
.1a07c2	a5 27		lda $0827	                LDA ARGTYPE1            ; Check the type
.1a07c4	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.1a07c6	f0 26		beq $1a07ee	                BEQ done                ; Then we're done
.1a07c8	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.1a07ca	f0 1f		beq $1a07eb	                BEQ cast                ; Then cast it to float
.1a07cc					type_err
.1a07cc	08		php		            PHP
.1a07cd	c2 20		rep #$20	            REP #$20
.1a07cf	48		pha		            PHA
.1a07d0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a07d3	5b		tcd		            TCD
.1a07d4	68		pla		            PLA
.1a07d5	28		plp		            PLP
.1a07d6	e2 20		sep #$20	            SEP #$20
.1a07d8	a9 04		lda #$04	            LDA #ERR_TYPE
.1a07da	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a07de	c2 20		rep #$20	            REP #$20
.1a07e0	29 ff 00	and #$00ff	            AND #$00FF
.1a07e3	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a07e6	e2 20		sep #$20	            SEP #$20
.1a07e8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a07eb					cast
.1a07eb	20 04 5c	jsr $1a5c04	            JSR ITOF
.1a07ee	28		plp		done            PLP
.1a07ef	60		rts		            RTS
.1a07f0					ASS_ARG2_FLOAT
.1a07f0	08		php		                PHP
.1a07f1	e2 20		sep #$20	            SEP #$20
.1a07f3	a5 2d		lda $082d	                LDA ARGTYPE2            ; Check the type
.1a07f5	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.1a07f7	f0 26		beq $1a081f	                BEQ done                ; Then we're done
.1a07f9	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.1a07fb	f0 1f		beq $1a081c	                BEQ cast                ; Then cast it to float
.1a07fd					type_err
.1a07fd	08		php		            PHP
.1a07fe	c2 20		rep #$20	            REP #$20
.1a0800	48		pha		            PHA
.1a0801	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0804	5b		tcd		            TCD
.1a0805	68		pla		            PLA
.1a0806	28		plp		            PLP
.1a0807	e2 20		sep #$20	            SEP #$20
.1a0809	a9 04		lda #$04	            LDA #ERR_TYPE
.1a080b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a080f	c2 20		rep #$20	            REP #$20
.1a0811	29 ff 00	and #$00ff	            AND #$00FF
.1a0814	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a0817	e2 20		sep #$20	            SEP #$20
.1a0819	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a081c					cast
.1a081c	20 21 08	jsr $1a0821	            JSR CAST_ARG2_FLOAT
.1a081f	28		plp		done            PLP
.1a0820	60		rts		            RTS
.1a0821					CAST_ARG2_FLOAT
.1a0821	c2 20		rep #$20	            REP #$20
.1a0823	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a0825	48		pha		            PHA
.1a0826	a5 23		lda $0823	            LDA ARGUMENT1
.1a0828	48		pha		            PHA
.1a0829	c2 20		rep #$20	            REP #$20
.1a082b	a5 29		lda $0829	            LDA ARGUMENT2
.1a082d	85 23		sta $0823	            STA ARGUMENT1
.1a082f	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a0831	85 25		sta $0825	            STA ARGUMENT1+2
.1a0833	e2 20		sep #$20	            SEP #$20
.1a0835	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a0837	85 27		sta $0827	            STA ARGTYPE1
.1a0839	20 04 5c	jsr $1a5c04	            JSR ITOF
.1a083c	c2 20		rep #$20	            REP #$20
.1a083e	a5 23		lda $0823	            LDA ARGUMENT1
.1a0840	85 29		sta $0829	            STA ARGUMENT2
.1a0842	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a0844	85 2b		sta $082b	            STA ARGUMENT2+2
.1a0846	e2 20		sep #$20	            SEP #$20
.1a0848	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.1a084a	85 2d		sta $082d	            STA ARGTYPE2
.1a084c	c2 20		rep #$20	            REP #$20
.1a084e	68		pla		            PLA
.1a084f	85 23		sta $0823	            STA ARGUMENT1
.1a0851	68		pla		            PLA
.1a0852	85 25		sta $0825	            STA ARGUMENT1+2
.1a0854	60		rts		            RTS
.1a0855					ASS_ARGS_NUM
.1a0855	08		php		                PHP
.1a0856	e2 20		sep #$20	            SEP #$20
.1a0858	a5 27		lda $0827	                LDA ARGTYPE1                ; Check ARGUMENT1
.1a085a	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a085c	f0 23		beq $1a0881	                BEQ arg1_int
.1a085e	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.1a0860	f0 2e		beq $1a0890	                BEQ arg1_float
.1a0862					type_err
.1a0862	08		php		            PHP
.1a0863	c2 20		rep #$20	            REP #$20
.1a0865	48		pha		            PHA
.1a0866	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0869	5b		tcd		            TCD
.1a086a	68		pla		            PLA
.1a086b	28		plp		            PLP
.1a086c	e2 20		sep #$20	            SEP #$20
.1a086e	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0870	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0874	c2 20		rep #$20	            REP #$20
.1a0876	29 ff 00	and #$00ff	            AND #$00FF
.1a0879	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a087c	e2 20		sep #$20	            SEP #$20
.1a087e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0881	a5 2d		lda $082d	arg1_int        LDA ARGTYPE2                ; Check argument 2
.1a0883	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If integer, we're done
.1a0885	f0 16		beq $1a089d	                BEQ done
.1a0887	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If not float, throw an error
.1a0889	d0 d7		bne $1a0862	                BNE type_err
.1a088b	20 04 5c	jsr $1a5c04	            JSR ITOF
.1a088e	80 0d		bra $1a089d	                BRA done
.1a0890	a5 2d		lda $082d	arg1_float      LDA ARGTYPE2                ; Check argument 2
.1a0892	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If it's float
.1a0894	f0 07		beq $1a089d	                BEQ done                    ; Then we're done
.1a0896	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If it's not integer
.1a0898	d0 c8		bne $1a0862	                BNE type_err                ; Thrown an error
.1a089a	20 21 08	jsr $1a0821	            JSR CAST_ARG2_FLOAT
.1a089d					done
.1a089d	e2 20		sep #$20	            SEP #$20
.1a089f	a5 27		lda $0827	                LDA ARGTYPE1                ; Return the type code in A
.1a08a1	28		plp		                PLP
.1a08a2	60		rts		            RTS
.1a08a3					ASS_ARGS_NUMSTR
.1a08a3	08		php		                PHP
.1a08a4	e2 20		sep #$20	            SEP #$20
.1a08a6	a5 27		lda $0827	                LDA ARGTYPE1                ; Check to see if ARGUMENT1 is a string
.1a08a8	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a08aa	d0 25		bne $1a08d1	                BNE numbers
.1a08ac	a5 2d		lda $082d	                LDA ARGTYPE2                ; If ARGUMENT1 is a string, make sure ARGUMENT2 is
.1a08ae	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a08b0	f0 24		beq $1a08d6	                BEQ done
.1a08b2					TYPE_ERR
.1a08b2	08		php		            PHP
.1a08b3	c2 20		rep #$20	            REP #$20
.1a08b5	48		pha		            PHA
.1a08b6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a08b9	5b		tcd		            TCD
.1a08ba	68		pla		            PLA
.1a08bb	28		plp		            PLP
.1a08bc	e2 20		sep #$20	            SEP #$20
.1a08be	a9 04		lda #$04	            LDA #ERR_TYPE
.1a08c0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a08c4	c2 20		rep #$20	            REP #$20
.1a08c6	29 ff 00	and #$00ff	            AND #$00FF
.1a08c9	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a08cc	e2 20		sep #$20	            SEP #$20
.1a08ce	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a08d1					numbers
.1a08d1	20 55 08	jsr $1a0855	            JSR ASS_ARGS_NUM
.1a08d4	a5 27		lda $0827	                LDA ARGTYPE1                ; Make sure A is the type
.1a08d6	28		plp		done            PLP
.1a08d7	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\tokens.s

.0000					TOKEN
>0000					precedence  .byte ?
>0001					length      .byte ?
>0002					name        .word <>?
>0004					eval        .word <>?
>0006					arity       .word <>?
.1a08d8					PARSEINT
.1a08d8	08		php		            PHP
.1a08d9	0b		phd		            PHD
.1a08da	08		php		            PHP
.1a08db	c2 20		rep #$20	            REP #$20
.1a08dd	48		pha		            PHA
.1a08de	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a08e1	5b		tcd		            TCD
.1a08e2	68		pla		            PLA
.1a08e3	28		plp		            PLP
.1a08e4	c2 30		rep #$30	            REP #$30
.1a08e6	64 23		stz $0823	            STZ ARGUMENT1       ; Default to Not-a-value
.1a08e8	64 25		stz $0825	            STZ ARGUMENT1+2
.1a08ea	e2 20		sep #$20	            SEP #$20
.1a08ec	64 27		stz $0827	            STZ ARGTYPE1
.1a08ee	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it starts with '$'
.1a08f0	c9 26		cmp #$26	            CMP #'&'
.1a08f2	f0 44		beq $1a0938	            BEQ check_hex       ; Yes: parse it as a hexadecimal number
.1a08f4					loop
.1a08f4	e2 20		sep #$20	            SEP #$20
.1a08f6	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.1a08f8	20 fb 04	jsr $1a04fb	            JSR ISNUMERAL
.1a08fb	90 76		bcc $1a0973	            BCC done            ; No, we're done parsing
.1a08fd	20 7a 05	jsr $1a057a	            JSR MULINT10
.1a0900	38		sec		            SEC                 ; Convert the ASCII code to a number
.1a0901	e9 30		sbc #$30	            SBC #'0'
.1a0903	c2 20		rep #$20	            REP #$20
.1a0905	29 ff 00	and #$00ff	            AND #$00FF
.1a0908	18		clc		            CLC
.1a0909	65 23		adc $0823	            ADC ARGUMENT1
.1a090b	85 23		sta $0823	            STA ARGUMENT1
.1a090d	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a090f	69 00 00	adc #$0000	            ADC #0
.1a0912	85 25		sta $0825	            STA ARGUMENT1+2
.1a0914	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a0917	80 db		bra $1a08f4	            BRA loop            ; And try to process it
.1a0919					syntaxerr
.1a0919	08		php		            PHP
.1a091a	c2 20		rep #$20	            REP #$20
.1a091c	48		pha		            PHA
.1a091d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0920	5b		tcd		            TCD
.1a0921	68		pla		            PLA
.1a0922	28		plp		            PLP
.1a0923	e2 20		sep #$20	            SEP #$20
.1a0925	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a0927	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a092b	c2 20		rep #$20	            REP #$20
.1a092d	29 ff 00	and #$00ff	            AND #$00FF
.1a0930	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a0933	e2 20		sep #$20	            SEP #$20
.1a0935	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0938					check_hex
.1a0938	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a093b	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.1a093d	c9 48		cmp #$48	            CMP #'H'            ; Is it 'H'?
.1a093f	f0 04		beq $1a0945	            BEQ parse_hex       ; Yes: skip it and parse hex
.1a0941	c9 68		cmp #$68	            CMP #'h'            ; Is it 'h'?
.1a0943	d0 d4		bne $1a0919	            BNE syntaxerr       ; No: throw an error
.1a0945					parse_hex
.1a0945	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a0948					hexloop
.1a0948	e2 20		sep #$20	            SEP #$20
.1a094a	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.1a094c	20 0c 05	jsr $1a050c	            JSR ISHEX
.1a094f	90 22		bcc $1a0973	            BCC done            ; No, we're done parsing
.1a0951	20 2d 05	jsr $1a052d	            JSR HEX2BIN
.1a0954	c2 20		rep #$20	            REP #$20
.1a0956	06 23		asl $0823	            ASL ARGUMENT1
.1a0958	26 25		rol $0825	            ROL ARGUMENT1+2
.1a095a	06 23		asl $0823	            ASL ARGUMENT1
.1a095c	26 25		rol $0825	            ROL ARGUMENT1+2
.1a095e	06 23		asl $0823	            ASL ARGUMENT1
.1a0960	26 25		rol $0825	            ROL ARGUMENT1+2
.1a0962	06 23		asl $0823	            ASL ARGUMENT1
.1a0964	26 25		rol $0825	            ROL ARGUMENT1+2
.1a0966	29 ff 00	and #$00ff	            AND #$00FF          ; Add binary number to ARGUMENT1
.1a0969	18		clc		            CLC
.1a096a	65 23		adc $0823	            ADC ARGUMENT1
.1a096c	85 23		sta $0823	            STA ARGUMENT1
.1a096e	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a0971	80 d5		bra $1a0948	            BRA hexloop         ; And try to process it
.1a0973	2b		pld		done        PLD
.1a0974	28		plp		            PLP
.1a0975	60		rts		            RTS
.1a0976					PREVCHAR
.1a0976	08		php		            PHP
.1a0977	c2 30		rep #$30	            REP #$30
.1a0979	a5 04		lda $0804	            LDA BIPPREV
.1a097b	f0 1c		beq $1a0999	            BEQ ret_false
.1a097d	38		sec		            SEC
.1a097e	a5 04		lda $0804	            LDA BIPPREV
.1a0980	e5 1a		sbc $081a	            SBC CURLINE
.1a0982	a8		tay		            TAY
.1a0983	e2 20		sep #$20	            SEP #$20
.1a0985	b7 1a		lda [$081a],y	loop        LDA [CURLINE],Y
.1a0987	f0 10		beq $1a0999	            BEQ ret_false
.1a0989	c9 20		cmp #$20	            CMP #CHAR_SP
.1a098b	f0 06		beq $1a0993	            BEQ go_back
.1a098d	c9 09		cmp #$09	            CMP #CHAR_TAB
.1a098f	f0 02		beq $1a0993	            BEQ go_back
.1a0991	28		plp		            PLP
.1a0992	60		rts		            RTS
.1a0993	88		dey		go_back     DEY
.1a0994	c0 ff ff	cpy #$ffff	            CPY #$FFFF
.1a0997	d0 ec		bne $1a0985	            BNE loop
.1a0999					ret_false
.1a0999	a9 00		lda #$00	            LDA #0
.1a099b	60		rts		            RTS
.1a099c					TOKENIZE
.1a099c	08		php		            PHP
.1a099d	0b		phd		            PHD
.1a099e	08		php		            PHP
.1a099f	c2 20		rep #$20	            REP #$20
.1a09a1	48		pha		            PHA
.1a09a2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a09a5	5b		tcd		            TCD
.1a09a6	68		pla		            PLA
.1a09a7	28		plp		            PLP
.1a09a8	c2 30		rep #$30	            REP #$30
.1a09aa	a5 1a		lda $081a	            LDA CURLINE
.1a09ac	85 00		sta $0800	            STA BIP
.1a09ae	e2 20		sep #$20	            SEP #$20
.1a09b0	a5 1c		lda $081c	            LDA CURLINE+2
.1a09b2	85 02		sta $0802	            STA BIP+2
.1a09b4	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a09b7	a7 00		lda [$0800]	            LDA [BIP]               ; Do we have a numeral?
.1a09b9	20 fb 04	jsr $1a04fb	            JSR ISNUMERAL
.1a09bc	90 0c		bcc $1a09ca	            BCC mv_curline          ; No: adjust CURLINE and tokenize
.1a09be	20 d8 08	jsr $1a08d8	            JSR PARSEINT
.1a09c1	c2 20		rep #$20	            REP #$20
.1a09c3	a5 23		lda $0823	            LDA ARGUMENT1
.1a09c5	85 d7		sta $08d7	            STA LINENUM
.1a09c7	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a09ca					mv_curline
.1a09ca	c2 20		rep #$20	            REP #$20
.1a09cc	a5 00		lda $0800	            LDA BIP
.1a09ce	85 1a		sta $081a	            STA CURLINE
.1a09d0	e2 20		sep #$20	            SEP #$20
.1a09d2	a5 02		lda $0802	            LDA BIP+2
.1a09d4	85 1c		sta $081c	            STA CURLINE+2
.1a09d6	20 ea 09	jsr $1a09ea	            JSR FINDREM
.1a09d9	e2 20		sep #$20	            SEP #$20
.1a09db					loop
.1a09db	20 5b 0a	jsr $1a0a5b	            JSR TKFINDTOKEN
.1a09de	c9 00		cmp #$00	            CMP #0                  ; Did we find a token?
.1a09e0	f0 05		beq $1a09e7	            BEQ done                ; No: return
.1a09e2	20 06 0c	jsr $1a0c06	            JSR TKWRITE
.1a09e5	80 f4		bra $1a09db	            BRA loop                ; And try again
.1a09e7	2b		pld		done        PLD
.1a09e8	28		plp		            PLP
.1a09e9	60		rts		            RTS
.1a09ea					FINDREM
.1a09ea	08		php		            PHP
.1a09eb	c2 20		rep #$20	            REP #$20
.1a09ed	a5 1a		lda $081a	            LDA CURLINE             ; Point BIP to the beginning of the line
.1a09ef	85 00		sta $0800	            STA BIP
.1a09f1	a5 1c		lda $081c	            LDA CURLINE+2
.1a09f3	85 02		sta $0802	            STA BIP+2
.1a09f5	a2 00 00	ldx #$0000	            LDX #0                  ; X will be a flag that we're at the beginning
.1a09f8	e2 20		sep #$20	            SEP #$20
.1a09fa	a0 00 00	ldy #$0000	loop        LDY #0
.1a09fd	e0 00 00	cpx #$0000	            CPX #0                  ; If we are at the first space on the line
.1a0a00	f0 0d		beq $1a0a0f	            BEQ skip_delim          ; ... skip looking for a delimiter
.1a0a02	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a0a04	f0 53		beq $1a0a59	            BEQ done                ; Is it null? Then we're done
.1a0a06	c9 3a		cmp #$3a	            CMP #':'                ; Is it ":"
.1a0a08	f0 04		beq $1a0a0e	            BEQ found_delim         ; Yes: we might have a REM... look for E
.1a0a0a	c9 20		cmp #$20	            CMP #CHAR_SP
.1a0a0c	d0 33		bne $1a0a41	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a0a0e	c8		iny		found_delim INY
.1a0a0f	b7 00		lda [$0800],y	skip_delim  LDA [BIP],Y             ; Get the first character
.1a0a11	f0 46		beq $1a0a59	            BEQ done                ; Is it null? Then we're done
.1a0a13	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.1a0a15	f0 10		beq $1a0a27	            BEQ found_R             ; Yes: we might have a REM... look for E
.1a0a17	c9 72		cmp #$72	            CMP #'r'
.1a0a19	d0 26		bne $1a0a41	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a0a1b	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a0a1d	f0 3a		beq $1a0a59	            BEQ done                ; Is it null? Then we're done
.1a0a1f	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.1a0a21	f0 04		beq $1a0a27	            BEQ found_R             ; Yes: we might have a REM... look for E
.1a0a23	c9 72		cmp #$72	            CMP #'r'
.1a0a25	d0 1a		bne $1a0a41	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a0a27	c8		iny		found_R     INY
.1a0a28	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a0a2a	f0 2d		beq $1a0a59	            BEQ done                ; Is it null? Then we're done
.1a0a2c	c9 45		cmp #$45	            CMP #'E'                ; Is it "E"
.1a0a2e	f0 04		beq $1a0a34	            BEQ found_E             ; Yes: we might have a REM... look for M
.1a0a30	c9 65		cmp #$65	            CMP #'e'
.1a0a32	d0 0d		bne $1a0a41	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a0a34	c8		iny		found_E     INY
.1a0a35	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a0a37	f0 20		beq $1a0a59	            BEQ done                ; Is it null? Then we're done
.1a0a39	c9 4d		cmp #$4d	            CMP #'M'                ; Is it "E"
.1a0a3b	f0 0a		beq $1a0a47	            BEQ found_REM           ; Yes: we might have a REM... look for M
.1a0a3d	c9 6d		cmp #$6d	            CMP #'m'
.1a0a3f	f0 06		beq $1a0a47	            BEQ found_REM
.1a0a41	e8		inx		next_pos    INX                     ; Indicate we're no longer at the first position
.1a0a42	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a0a45	80 b3		bra $1a09fa	            BRA loop
.1a0a47	a7 00		lda [$0800]	found_REM   LDA [BIP]               ; Get the current character
.1a0a49	c9 3a		cmp #$3a	            CMP #':'                ; Is it the delimiter?
.1a0a4b	d0 03		bne $1a0a50	            BNE ret_REM             ; No: go ahead and return REM at that location
.1a0a4d	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a0a50	a9 03		lda #$03	ret_REM     LDA #3
.1a0a52	85 1e		sta $081e	            STA CURTOKLEN           ; Set the size
.1a0a54	a9 91		lda #$91	            LDA #TOK_REM            ; And the token to write
.1a0a56	20 06 0c	jsr $1a0c06	            JSR TKWRITE
.1a0a59	28		plp		done        PLP
.1a0a5a	60		rts		            RTS
.1a0a5b					TKFINDTOKEN
.1a0a5b	08		php		            PHP
.1a0a5c	0b		phd		            PHD
.1a0a5d	08		php		            PHP
.1a0a5e	c2 20		rep #$20	            REP #$20
.1a0a60	48		pha		            PHA
.1a0a61	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0a64	5b		tcd		            TCD
.1a0a65	68		pla		            PLA
.1a0a66	28		plp		            PLP
.1a0a67	e2 20		sep #$20	            SEP #$20
.1a0a69	a9 7f		lda #$7f	            LDA #$7F                ; Start off looking for any size token
.1a0a6b	85 1e		sta $081e	            STA CURTOKLEN
.1a0a6d					next_size
.1a0a6d	c2 10		rep #$10	            REP #$10
.1a0a6f	20 bb 0b	jsr $1a0bbb	            JSR TKNEXTBIG
.1a0a72	a5 1e		lda $081e	            LDA CURTOKLEN           ; Are there any keywords left?
.1a0a74	d0 03		bne $1a0a79	            BNE else
.1a0a76	4c fb 0a	jmp $1a0afb	            JMP done                ; No: return to caller
.1a0a79					else
.1a0a79	c2 20		rep #$20	            REP #$20
.1a0a7b	a5 1a		lda $081a	            LDA CURLINE
.1a0a7d	85 00		sta $0800	            STA BIP
.1a0a7f	e2 20		sep #$20	            SEP #$20
.1a0a81	a5 1c		lda $081c	            LDA CURLINE+2
.1a0a83	85 02		sta $0802	            STA BIP+2
.1a0a85	c2 20		rep #$20	            REP #$20
.1a0a87	64 04		stz $0804	            STZ BIPPREV             ; Clear BIPPREV (point to the previous character)
.1a0a89	64 06		stz $0806	            STZ BIPPREV+2
.1a0a8b					check_len
.1a0a8b	e2 30		sep #$30	            SEP #$30
.1a0a8d	a0 00		ldy #$00	            LDY #0
.1a0a8f	b7 00		lda [$0800],y	nul_scan    LDA [BIP],Y
.1a0a91	f0 da		beq $1a0a6d	            BEQ next_size
.1a0a93	c9 91		cmp #$91	            CMP #TOK_REM            ; Tokenization stops at REMarks too
.1a0a95	f0 d6		beq $1a0a6d	            BEQ next_size
.1a0a97	c8		iny		            INY
.1a0a98	c4 1e		cpy $081e	            CPY CURTOKLEN
.1a0a9a	90 f3		bcc $1a0a8f	            BCC nul_scan
.1a0a9c	c2 10		rep #$10	            REP #$10
.1a0a9e	a7 00		lda [$0800]	            LDA [BIP]               ; Check the current character
.1a0aa0	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.1a0aa2	d0 05		bne $1a0aa9	            BNE chk_keyword         ; No: check to see if we are at the start of a possible keyword
.1a0aa4	20 1d 0b	jsr $1a0b1d	            JSR SKIPQUOTED
.1a0aa7	80 28		bra $1a0ad1	            BRA go_next             ; And move on to the next character
.1a0aa9	a5 1e		lda $081e	chk_keyword LDA CURTOKLEN           ; If the token length is <=2
.1a0aab	c9 03		cmp #$03	            CMP #3
.1a0aad	90 19		bcc $1a0ac8	            BLT try_match           ; ... we don't need a delimiter, go ahead and convert it
.1a0aaf	c2 20		rep #$20	            REP #$20
.1a0ab1	a5 00		lda $0800	            LDA BIP                 ; Check to see if we're at the start of the line
.1a0ab3	c5 1a		cmp $081a	            CMP CURLINE
.1a0ab5	d0 08		bne $1a0abf	            BNE chk_delim           ; No: we need to check for a delimiters
.1a0ab7	e2 20		sep #$20	            SEP #$20
.1a0ab9	a5 02		lda $0802	            LDA BIP+2
.1a0abb	c5 1c		cmp $081c	            CMP CURLINE+2
.1a0abd	f0 09		beq $1a0ac8	            BEQ try_match           ; Yes: this can be a keyword
.1a0abf					chk_delim
.1a0abf	e2 20		sep #$20	            SEP #$20
.1a0ac1	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.1a0ac3	20 4d 51	jsr $1a514d	            JSR ISVARCHAR
.1a0ac6	b0 09		bcs $1a0ad1	            BCS go_next             ; Yes: we can't start a keyword here
.1a0ac8					try_match
.1a0ac8	e2 20		sep #$20	            SEP #$20
.1a0aca	20 2d 0b	jsr $1a0b2d	            JSR TKMATCH
.1a0acd	c9 00		cmp #$00	            CMP #0                  ; Did we get one?
.1a0acf	d0 11		bne $1a0ae2	            BNE found               ; Yes: return it
.1a0ad1					go_next
.1a0ad1	c2 20		rep #$20	            REP #$20
.1a0ad3	a5 00		lda $0800	            LDA BIP                 ; Update BIPPREV as the point to the previous character
.1a0ad5	85 04		sta $0804	            STA BIPPREV
.1a0ad7	e2 20		sep #$20	            SEP #$20
.1a0ad9	a5 02		lda $0802	            LDA BIP+2
.1a0adb	85 06		sta $0806	            STA BIPPREV+2
.1a0add	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a0ae0	80 a9		bra $1a0a8b	            BRA check_len           ; And try there
.1a0ae2					found
.1a0ae2	c9 81		cmp #$81	            CMP #TOK_MINUS          ; Found a token... is it minus?
.1a0ae4	d0 15		bne $1a0afb	            BNE done                ; Nope: go ahead and return it
.1a0ae6	20 76 09	jsr $1a0976	            JSR PREVCHAR
.1a0ae9	c9 00		cmp #$00	            CMP #0                  ; Did we get anything?
.1a0aeb	f0 11		beq $1a0afe	            BEQ syntax              ; No: line cannot start with minus... throw error
.1a0aed	89 80		bit #$80	            BIT #$80                ; Is it a token?
.1a0aef	f0 08		beq $1a0af9	            BEQ binaryminus         ; No: leave token unchanged
.1a0af1	c9 90		cmp #$90	            CMP #TOK_RPAREN         ; Is the token a right parenthesis?
.1a0af3	f0 04		beq $1a0af9	            BEQ binaryminus         ; Yes: then this should be a binary minus operator
.1a0af5	a9 af		lda #$af	            LDA #TOK_NEGATIVE       ; Otherwise: this should be a unary minus (negation)
.1a0af7	80 02		bra $1a0afb	            BRA done
.1a0af9	a9 81		lda #$81	binaryminus LDA #TOK_MINUS          ; It's data... so token should be for binary minus
.1a0afb					done
.1a0afb	2b		pld		            PLD
.1a0afc	28		plp		            PLP
.1a0afd	60		rts		            RTS
.1a0afe					syntax
.1a0afe	08		php		            PHP
.1a0aff	c2 20		rep #$20	            REP #$20
.1a0b01	48		pha		            PHA
.1a0b02	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0b05	5b		tcd		            TCD
.1a0b06	68		pla		            PLA
.1a0b07	28		plp		            PLP
.1a0b08	e2 20		sep #$20	            SEP #$20
.1a0b0a	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a0b0c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0b10	c2 20		rep #$20	            REP #$20
.1a0b12	29 ff 00	and #$00ff	            AND #$00FF
.1a0b15	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a0b18	e2 20		sep #$20	            SEP #$20
.1a0b1a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0b1d					SKIPQUOTED
.1a0b1d	08		php		            PHP
.1a0b1e	e2 20		sep #$20	            SEP #$20
.1a0b20					loop
.1a0b20	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a0b23	a7 00		lda [$0800]	            LDA [BIP]
.1a0b25	f0 04		beq $1a0b2b	            BEQ done                ; If EOL, just return
.1a0b27	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.1a0b29	d0 f5		bne $1a0b20	            BNE loop                ; No: keep skipping
.1a0b2b	28		plp		done        PLP
.1a0b2c	60		rts		            RTS
.1a0b2d					TKMATCH
.1a0b2d	da		phx		            PHX
.1a0b2e	5a		phy		            PHY
.1a0b2f	08		php		            PHP
.1a0b30	0b		phd		            PHD
.1a0b31	08		php		            PHP
.1a0b32	c2 20		rep #$20	            REP #$20
.1a0b34	48		pha		            PHA
.1a0b35	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0b38	5b		tcd		            TCD
.1a0b39	68		pla		            PLA
.1a0b3a	28		plp		            PLP
.1a0b3b	c2 20		rep #$20	            REP #$20
.1a0b3d	a5 04		lda $0804	            LDA BIPPREV
.1a0b3f	d0 0a		bne $1a0b4b	            BNE check_prev
.1a0b41	e2 20		sep #$20	            SEP #$20
.1a0b43	a5 04		lda $0804	            LDA BIPPREV
.1a0b45	d0 04		bne $1a0b4b	            BNE check_prev
.1a0b47	a9 00		lda #$00	            LDA #0
.1a0b49	80 0a		bra $1a0b55	            BRA save_delim
.1a0b4b					check_prev
.1a0b4b	e2 20		sep #$20	            SEP #$20
.1a0b4d	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.1a0b4f	20 4d 51	jsr $1a514d	            JSR ISVARCHAR
.1a0b52	a9 00		lda #$00	            LDA #0
.1a0b54	2a		rol a		            ROL A
.1a0b55	85 28		sta $0828	save_delim  STA SIGN1               ; SIGN1 := 1 if it is a variable name character
.1a0b57	c2 30		rep #$30	            REP #$30
.1a0b59	a9 fb 0c	lda #$0cfb	            LDA #<>TOKENS           ; Set INDEX to point to the first token record
.1a0b5c	85 08		sta $0808	            STA INDEX
.1a0b5e	e2 20		sep #$20	            SEP #$20
.1a0b60	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0b62	85 0a		sta $080a	            STA INDEX+2
.1a0b64	a2 80 00	ldx #$0080	            LDX #$80                ; Set the initial token ID
.1a0b67					token_loop
.1a0b67	e2 20		sep #$20	            SEP #$20
.1a0b69	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.1a0b6c	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the current token
.1a0b6e	f0 31		beq $1a0ba1	            BEQ no_match            ; Is it 0? We're out of tokens... no match found
.1a0b70	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it the same as the size of the window?
.1a0b72	d0 32		bne $1a0ba6	            BNE next_token          ; No: try the next token
.1a0b74	c2 30		rep #$30	            REP #$30
.1a0b76	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.1a0b79	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the pointer to the token's name
.1a0b7b	85 0c		sta $080c	            STA SCRATCH             ; Set SCRATCH to point to the token's name
.1a0b7d	e2 20		sep #$20	            SEP #$20
.1a0b7f	a9 1a		lda #$1a	            LDA #`DATA_BLOCK
.1a0b81	85 0e		sta $080e	            STA SCRATCH+2
.1a0b83	a5 28		lda $0828	            LDA SIGN1               ; Is previous character a variable name character?
.1a0b85	f0 07		beq $1a0b8e	            BEQ cmp_keyword         ; No: we can check for this token
.1a0b87	a7 0c		lda [$080c]	            LDA [SCRATCH]           ; Get the token's first character
.1a0b89	20 4d 51	jsr $1a514d	            JSR ISVARCHAR
.1a0b8c	b0 18		bcs $1a0ba6	            BCS next_token          ; Yes: skip this token
.1a0b8e					cmp_keyword
.1a0b8e	e2 10		sep #$10	            SEP #$10
.1a0b90	a0 00		ldy #$00	            LDY #0
.1a0b92	b7 00		lda [$0800],y	cmp_loop    LDA [BIP],Y             ; Get the character in the window
.1a0b94	20 56 05	jsr $1a0556	            JSR TOUPPERA
.1a0b97	d7 0c		cmp [$080c],y	            CMP [SCRATCH],Y         ; Compare to the character in the token
.1a0b99	d0 0b		bne $1a0ba6	            BNE next_token          ; If they don't match, try the next token
.1a0b9b	c8		iny		            INY                     ; Move to the next character in the window
.1a0b9c	c4 1e		cpy $081e	            CPY CURTOKLEN           ; Have we checked the whole window?
.1a0b9e	90 f2		bcc $1a0b92	            BCC cmp_loop            ; No: check this next character
.1a0ba0	8a		txa		            TXA                     ; Move the token ID to A
.1a0ba1	2b		pld		no_match    PLD
.1a0ba2	28		plp		            PLP
.1a0ba3	7a		ply		            PLY
.1a0ba4	fa		plx		            PLX
.1a0ba5	60		rts		            RTS
.1a0ba6					next_token
.1a0ba6	c2 30		rep #$30	            REP #$30
.1a0ba8	18		clc		            CLC
.1a0ba9	a5 08		lda $0808	            LDA INDEX
.1a0bab	69 08 00	adc #$0008	            ADC #size(TOKEN)
.1a0bae	85 08		sta $0808	            STA INDEX
.1a0bb0	e2 20		sep #$20	            SEP #$20
.1a0bb2	a5 0a		lda $080a	            LDA INDEX+2
.1a0bb4	69 00		adc #$00	            ADC #0
.1a0bb6	85 0a		sta $080a	            STA INDEX+2
.1a0bb8	e8		inx		            INX                     ; Increment the token ID
.1a0bb9	80 ac		bra $1a0b67	            BRA token_loop          ; And check that token
.1a0bbb					TKNEXTBIG
.1a0bbb	08		php		            PHP
.1a0bbc	0b		phd		            PHD
.1a0bbd	8b		phb		            PHB
.1a0bbe	08		php		            PHP
.1a0bbf	c2 20		rep #$20	            REP #$20
.1a0bc1	48		pha		            PHA
.1a0bc2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0bc5	5b		tcd		            TCD
.1a0bc6	68		pla		            PLA
.1a0bc7	28		plp		            PLP
.1a0bc8	c2 30		rep #$30	            REP #$30
.1a0bca	a9 fb 0c	lda #$0cfb	            LDA #<>TOKENS
.1a0bcd	85 08		sta $0808	            STA INDEX
.1a0bcf	a9 1a 00	lda #$001a	            LDA #`TOKENS
.1a0bd2	85 0a		sta $080a	            STA INDEX+2
.1a0bd4	64 0c		stz $080c	            STZ SCRATCH             ; Clear SCRATCH
.1a0bd6					loop
.1a0bd6	e2 20		sep #$20	            SEP #$20
.1a0bd8	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.1a0bdb	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the token
.1a0bdd	f0 1d		beq $1a0bfc	            BEQ done                ; If length is 0, we're done
.1a0bdf	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it >= CURTOKLEN?
.1a0be1	b0 06		bcs $1a0be9	            BGE skip                ; Yes: skip to the next token
.1a0be3	c5 0c		cmp $080c	            CMP SCRATCH             ; No: is it < SCRATCH?
.1a0be5	90 02		bcc $1a0be9	            BLT skip                ; Yes: skip to the next token
.1a0be7	85 0c		sta $080c	            STA SCRATCH             ; No: it's our new longest token!
.1a0be9					skip
.1a0be9	c2 20		rep #$20	            REP #$20
.1a0beb	18		clc		            CLC
.1a0bec	a5 08		lda $0808	            LDA INDEX
.1a0bee	69 08 00	adc #$0008	            ADC #size(TOKEN)
.1a0bf1	85 08		sta $0808	            STA INDEX
.1a0bf3	a5 0a		lda $080a	            LDA INDEX+2
.1a0bf5	69 00 00	adc #$0000	            ADC #0
.1a0bf8	85 0a		sta $080a	            STA INDEX+2
.1a0bfa	80 da		bra $1a0bd6	            BRA loop                ; And go around for another pass
.1a0bfc					done
.1a0bfc	e2 20		sep #$20	            SEP #$20
.1a0bfe	a5 0c		lda $080c	            LDA SCRATCH
.1a0c00	85 1e		sta $081e	            STA CURTOKLEN
.1a0c02	ab		plb		            PLB
.1a0c03	2b		pld		            PLD
.1a0c04	28		plp		            PLP
.1a0c05	60		rts		            RTS
.1a0c06					TKWRITE
.1a0c06	08		php		            PHP
.1a0c07	0b		phd		            PHD
.1a0c08	08		php		            PHP
.1a0c09	c2 20		rep #$20	            REP #$20
.1a0c0b	48		pha		            PHA
.1a0c0c	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0c0f	5b		tcd		            TCD
.1a0c10	68		pla		            PLA
.1a0c11	28		plp		            PLP
.1a0c12	e2 20		sep #$20	            SEP #$20
.1a0c14	87 00		sta [$0800]	            STA [BIP]               ; Write the token to the line
.1a0c16	c2 20		rep #$20	            REP #$20
.1a0c18	18		clc		            CLC
.1a0c19	a5 00		lda $0800	            LDA BIP
.1a0c1b	69 01 00	adc #$0001	            ADC #1
.1a0c1e	85 08		sta $0808	            STA INDEX
.1a0c20	a5 02		lda $0802	            LDA BIP+2
.1a0c22	69 00 00	adc #$0000	            ADC #0
.1a0c25	85 0a		sta $080a	            STA INDEX+2
.1a0c27	e2 10		sep #$10	            SEP #$10
.1a0c29	a4 1e		ldy $081e	            LDY CURTOKLEN           ; Y will be the number of characters to move down
.1a0c2b	88		dey		            DEY
.1a0c2c					copy_down
.1a0c2c	e2 20		sep #$20	            SEP #$20
.1a0c2e	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the byte to move down
.1a0c30	87 08		sta [$0808]	            STA [INDEX]             ; Move it down
.1a0c32	f0 13		beq $1a0c47	            BEQ done                ; We've reached the end of the line
.1a0c34	c2 20		rep #$20	            REP #$20
.1a0c36	18		clc		            CLC
.1a0c37	a5 08		lda $0808	            LDA INDEX
.1a0c39	69 01 00	adc #$0001	            ADC #1
.1a0c3c	85 08		sta $0808	            STA INDEX
.1a0c3e	a5 0a		lda $080a	            LDA INDEX+2
.1a0c40	69 00 00	adc #$0000	            ADC #0
.1a0c43	85 0a		sta $080a	            STA INDEX+2
.1a0c45	80 e5		bra $1a0c2c	            BRA copy_down
.1a0c47	2b		pld		done        PLD
.1a0c48	28		plp		            PLP
.1a0c49	60		rts		            RTS
.1a0c4a					GETTOKREC
.1a0c4a	08		php		            PHP
.1a0c4b	c2 30		rep #$30	            REP #$30
.1a0c4d	29 7f 00	and #$007f	            AND #$007F
.1a0c50	0a		asl a		            ASL A
.1a0c51	0a		asl a		            ASL A
.1a0c52	0a		asl a		            ASL A
.1a0c53	18		clc		            CLC
.1a0c54	69 fb 0c	adc #$0cfb	            ADC #<>TOKENS
.1a0c57	aa		tax		            TAX                         ; X is now the data bank relative address of the token record
.1a0c58	28		plp		            PLP
.1a0c59	60		rts		            RTS
.1a0c5a					TOKPRECED
.1a0c5a	08		php		            PHP
.1a0c5b	8b		phb		            PHB
.1a0c5c	0b		phd		            PHD
.1a0c5d	08		php		            PHP
.1a0c5e	c2 20		rep #$20	            REP #$20
.1a0c60	48		pha		            PHA
.1a0c61	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0c64	5b		tcd		            TCD
.1a0c65	68		pla		            PLA
.1a0c66	28		plp		            PLP
.1a0c67	08		php		            PHP
.1a0c68	e2 20		sep #$20	            SEP #$20
.1a0c6a	48		pha		            PHA
.1a0c6b	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0c6d	48		pha		            PHA
.1a0c6e	ab		plb		            PLB
.1a0c6f	68		pla		            PLA
.1a0c70	28		plp		            PLP
.1a0c71	e2 20		sep #$20	            SEP #$20
.1a0c73	c2 10		rep #$10	            REP #$10
.1a0c75	20 4a 0c	jsr $1a0c4a	            JSR GETTOKREC
.1a0c78	bd 00 00	lda $1a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.1a0c7b	c2 20		rep #$20	            REP #$20
.1a0c7d	29 0f 00	and #$000f	            AND #$000F                  ; Mask off the type code
.1a0c80	2b		pld		            PLD
.1a0c81	ab		plb		            PLB
.1a0c82	28		plp		            PLP
.1a0c83	60		rts		            RTS
.1a0c84					TOKEVAL
.1a0c84	08		php		            PHP
.1a0c85	8b		phb		            PHB
.1a0c86	0b		phd		            PHD
.1a0c87	08		php		            PHP
.1a0c88	c2 20		rep #$20	            REP #$20
.1a0c8a	48		pha		            PHA
.1a0c8b	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0c8e	5b		tcd		            TCD
.1a0c8f	68		pla		            PLA
.1a0c90	28		plp		            PLP
.1a0c91	08		php		            PHP
.1a0c92	e2 20		sep #$20	            SEP #$20
.1a0c94	48		pha		            PHA
.1a0c95	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0c97	48		pha		            PHA
.1a0c98	ab		plb		            PLB
.1a0c99	68		pla		            PLA
.1a0c9a	28		plp		            PLP
.1a0c9b	c2 30		rep #$30	            REP #$30
.1a0c9d	20 4a 0c	jsr $1a0c4a	            JSR GETTOKREC
.1a0ca0	bd 04 00	lda $1a0004,x	            LDA #TOKEN.eval,B,X         ; Get the address of the evaluation function
.1a0ca3	2b		pld		            PLD
.1a0ca4	ab		plb		            PLB
.1a0ca5	28		plp		            PLP
.1a0ca6	60		rts		            RTS
.1a0ca7					TOKTYPE
.1a0ca7	08		php		            PHP
.1a0ca8	8b		phb		            PHB
.1a0ca9	0b		phd		            PHD
.1a0caa	08		php		            PHP
.1a0cab	c2 20		rep #$20	            REP #$20
.1a0cad	48		pha		            PHA
.1a0cae	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0cb1	5b		tcd		            TCD
.1a0cb2	68		pla		            PLA
.1a0cb3	28		plp		            PLP
.1a0cb4	08		php		            PHP
.1a0cb5	e2 20		sep #$20	            SEP #$20
.1a0cb7	48		pha		            PHA
.1a0cb8	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0cba	48		pha		            PHA
.1a0cbb	ab		plb		            PLB
.1a0cbc	68		pla		            PLA
.1a0cbd	28		plp		            PLP
.1a0cbe	e2 20		sep #$20	            SEP #$20
.1a0cc0	c2 10		rep #$10	            REP #$10
.1a0cc2	20 4a 0c	jsr $1a0c4a	            JSR GETTOKREC
.1a0cc5	bd 00 00	lda $1a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.1a0cc8	c2 20		rep #$20	            REP #$20
.1a0cca	29 f0 00	and #$00f0	            AND #$00F0                  ; Mask off the type code
.1a0ccd	2b		pld		            PLD
.1a0cce	ab		plb		            PLB
.1a0ccf	28		plp		            PLP
.1a0cd0	60		rts		            RTS
.1a0cd1					TOKARITY
.1a0cd1	08		php		            PHP
.1a0cd2	8b		phb		            PHB
.1a0cd3	0b		phd		            PHD
.1a0cd4	08		php		            PHP
.1a0cd5	c2 20		rep #$20	            REP #$20
.1a0cd7	48		pha		            PHA
.1a0cd8	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0cdb	5b		tcd		            TCD
.1a0cdc	68		pla		            PLA
.1a0cdd	28		plp		            PLP
.1a0cde	08		php		            PHP
.1a0cdf	e2 20		sep #$20	            SEP #$20
.1a0ce1	48		pha		            PHA
.1a0ce2	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0ce4	48		pha		            PHA
.1a0ce5	ab		plb		            PLB
.1a0ce6	68		pla		            PLA
.1a0ce7	28		plp		            PLP
.1a0ce8	e2 20		sep #$20	            SEP #$20
.1a0cea	c2 10		rep #$10	            REP #$10
.1a0cec	20 4a 0c	jsr $1a0c4a	            JSR GETTOKREC
.1a0cef	bd 06 00	lda $1a0006,x	            LDA #TOKEN.arity,B,X        ; Get the arity
.1a0cf2	c2 20		rep #$20	            REP #$20
.1a0cf4	29 ff 00	and #$00ff	            AND #$00FF
.1a0cf7	2b		pld		            PLD
.1a0cf8	ab		plb		            PLB
.1a0cf9	28		plp		            PLP
.1a0cfa	60		rts		            RTS
=$00					TOK_EOL = $00
=$01					TOK_FUNC_OPEN = $01     ; A pseudo-token to push to the operator stack to mark
=$00					TOK_TY_OP = $00         ; The token is an operator
=$10					TOK_TY_CMD = $10        ; The token is a command (e.g. RUN, LIST, etc.)
=$20					TOK_TY_STMNT = $20      ; The token is a statement (e.g. INPUT, PRINT, DIM, etc.)
=$30					TOK_TY_FUNC = $30       ; The token is a function (e.g. SIN, COS, TAB, etc.)
=$40					TOK_TY_PUNCT = $40      ; The token is a punctuation mark (e.g. "(", ")")
=$50					TOK_TY_BYWRD = $50      ; The token is a by-word (e.g. STEP, TO, WEND, etc.)
.1a0cfb					TOKENS
=$80					TOK_PLUS = $80
>1ad010	2b 00				TOKEN_TEXT  .null "+"
>1a0cfb	03				precedence  .byte TOK_TY_OP | 3
>1a0cfc	01				length      .byte len("+")
>1a0cfd	10 d0				name        .word <>TOKEN_TEXT
>1a0cff	e3 27				eval        .word <>OP_PLUS
>1a0d01	02 00				arity       .word <>2
=$81					TOK_MINUS = $81
>1ad012	2d 00				TOKEN_TEXT  .null "-"
>1a0d03	03				precedence  .byte TOK_TY_OP | 3
>1a0d04	01				length      .byte len("-")
>1a0d05	12 d0				name        .word <>TOKEN_TEXT
>1a0d07	23 28				eval        .word <>OP_MINUS
>1a0d09	02 00				arity       .word <>2
=$82					TOK_MULT = $82
>1ad014	2a 00				TOKEN_TEXT  .null "*"
>1a0d0b	02				precedence  .byte TOK_TY_OP | 2
>1a0d0c	01				length      .byte len("*")
>1a0d0d	14 d0				name        .word <>TOKEN_TEXT
>1a0d0f	5a 28				eval        .word <>OP_MULTIPLY
>1a0d11	02 00				arity       .word <>2
=$83					TOK_DIVIDE = $83
>1ad016	2f 00				TOKEN_TEXT  .null "/"
>1a0d13	02				precedence  .byte TOK_TY_OP | 2
>1a0d14	01				length      .byte len("/")
>1a0d15	16 d0				name        .word <>TOKEN_TEXT
>1a0d17	91 28				eval        .word <>OP_DIVIDE
>1a0d19	02 00				arity       .word <>2
=$84					TOK_MOD = $84
>1ad018	4d 4f 44 00			TOKEN_TEXT  .null "MOD"
>1a0d1b	02				precedence  .byte TOK_TY_OP | 2
>1a0d1c	03				length      .byte len("MOD")
>1a0d1d	18 d0				name        .word <>TOKEN_TEXT
>1a0d1f	9b 28				eval        .word <>OP_MOD
>1a0d21	02 00				arity       .word <>2
>1ad01c	5e 00				TOKEN_TEXT  .null "^"
>1a0d23	00				precedence  .byte TOK_TY_OP | 0
>1a0d24	01				length      .byte len("^")
>1a0d25	1c d0				name        .word <>TOKEN_TEXT
>1a0d27	ae 28				eval        .word <>OP_POW
>1a0d29	02 00				arity       .word <>2
=$86					TOK_LE = $86
>1ad01e	3c 3d 00			TOKEN_TEXT  .null "<="
>1a0d2b	04				precedence  .byte TOK_TY_OP | 4
>1a0d2c	02				length      .byte len("<=")
>1a0d2d	1e d0				name        .word <>TOKEN_TEXT
>1a0d2f	6c 2a				eval        .word <>OP_LTE
>1a0d31	02 00				arity       .word <>2
=$87					TOK_GE = $87
>1ad021	3e 3d 00			TOKEN_TEXT  .null ">="
>1a0d33	04				precedence  .byte TOK_TY_OP | 4
>1a0d34	02				length      .byte len(">=")
>1a0d35	21 d0				name        .word <>TOKEN_TEXT
>1a0d37	2c 2a				eval        .word <>OP_GTE
>1a0d39	02 00				arity       .word <>2
=$88					TOK_NE = $88
>1ad024	3c 3e 00			TOKEN_TEXT  .null "<>"
>1a0d3b	04				precedence  .byte TOK_TY_OP | 4
>1a0d3c	02				length      .byte len("<>")
>1a0d3d	24 d0				name        .word <>TOKEN_TEXT
>1a0d3f	ec 29				eval        .word <>OP_NE
>1a0d41	02 00				arity       .word <>2
>1ad027	3c 00				TOKEN_TEXT  .null "<"
>1a0d43	04				precedence  .byte TOK_TY_OP | 4
>1a0d44	01				length      .byte len("<")
>1a0d45	27 d0				name        .word <>TOKEN_TEXT
>1a0d47	2c 29				eval        .word <>OP_LT
>1a0d49	02 00				arity       .word <>2
=$8a					TOK_EQ = $8A
>1ad029	3d 00				TOKEN_TEXT  .null "="
>1a0d4b	04				precedence  .byte TOK_TY_OP | 4
>1a0d4c	01				length      .byte len("=")
>1a0d4d	29 d0				name        .word <>TOKEN_TEXT
>1a0d4f	ac 29				eval        .word <>OP_EQ
>1a0d51	02 00				arity       .word <>2
>1ad02b	3e 00				TOKEN_TEXT  .null ">"
>1a0d53	04				precedence  .byte TOK_TY_OP | 4
>1a0d54	01				length      .byte len(">")
>1a0d55	2b d0				name        .word <>TOKEN_TEXT
>1a0d57	6c 29				eval        .word <>OP_GT
>1a0d59	02 00				arity       .word <>2
>1ad02d	4e 4f 54 00			TOKEN_TEXT  .null "NOT"
>1a0d5b	05				precedence  .byte TOK_TY_OP | 5
>1a0d5c	03				length      .byte len("NOT")
>1a0d5d	2d d0				name        .word <>TOKEN_TEXT
>1a0d5f	16 29				eval        .word <>OP_NOT
>1a0d61	01 00				arity       .word <>1
>1ad031	41 4e 44 00			TOKEN_TEXT  .null "AND"
>1a0d63	06				precedence  .byte TOK_TY_OP | 6
>1a0d64	03				length      .byte len("AND")
>1a0d65	31 d0				name        .word <>TOKEN_TEXT
>1a0d67	e8 28				eval        .word <>OP_AND
>1a0d69	02 00				arity       .word <>2
>1ad035	4f 52 00			TOKEN_TEXT  .null "OR"
>1a0d6b	07				precedence  .byte TOK_TY_OP | 7
>1a0d6c	02				length      .byte len("OR")
>1a0d6d	35 d0				name        .word <>TOKEN_TEXT
>1a0d6f	ff 28				eval        .word <>OP_OR
>1a0d71	02 00				arity       .word <>2
=$8f					TOK_LPAREN = $8F
>1ad038	28 00				TOKEN_TEXT  .null "("
>1a0d73	ff				precedence  .byte TOK_TY_PUNCT | $FF
>1a0d74	01				length      .byte len("(")
>1a0d75	38 d0				name        .word <>TOKEN_TEXT
>1a0d77	00 00				eval        .word <>0
>1a0d79	00 00				arity       .word <>0
=$90					TOK_RPAREN = $90
>1ad03a	29 00				TOKEN_TEXT  .null ")"
>1a0d7b	40				precedence  .byte TOK_TY_PUNCT | 0
>1a0d7c	01				length      .byte len(")")
>1a0d7d	3a d0				name        .word <>TOKEN_TEXT
>1a0d7f	00 00				eval        .word <>0
>1a0d81	00 00				arity       .word <>0
=$91					TOK_REM = $91
>1ad03c	52 45 4d 00			TOKEN_TEXT  .null "REM"
>1a0d83	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d84	03				length      .byte len("REM")
>1a0d85	3c d0				name        .word <>TOKEN_TEXT
>1a0d87	7f 41				eval        .word <>S_REM
>1a0d89	00 00				arity       .word <>0
=$92					TOK_PRINT = $92
>1ad040	50 52 49 4e 54 00		TOKEN_TEXT  .null "PRINT"
>1a0d8b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d8c	05				length      .byte len("PRINT")
>1a0d8d	40 d0				name        .word <>TOKEN_TEXT
>1a0d8f	84 45				eval        .word <>S_PRINT
>1a0d91	00 00				arity       .word <>0
=$93					TOK_LET = $93
>1ad046	4c 45 54 00			TOKEN_TEXT  .null "LET"
>1a0d93	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d94	03				length      .byte len("LET")
>1a0d95	46 d0				name        .word <>TOKEN_TEXT
>1a0d97	cf 44				eval        .word <>S_LET
>1a0d99	00 00				arity       .word <>0
>1ad04a	47 4f 54 4f 00			TOKEN_TEXT  .null "GOTO"
>1a0d9b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d9c	04				length      .byte len("GOTO")
>1a0d9d	4a d0				name        .word <>TOKEN_TEXT
>1a0d9f	6f 44				eval        .word <>S_GOTO
>1a0da1	00 00				arity       .word <>0
=$95					TOK_END = $95
>1ad04f	45 4e 44 00			TOKEN_TEXT  .null "END"
>1a0da3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0da4	03				length      .byte len("END")
>1a0da5	4f d0				name        .word <>TOKEN_TEXT
>1a0da7	66 44				eval        .word <>S_END
>1a0da9	00 00				arity       .word <>0
>1ad053	49 46 00			TOKEN_TEXT  .null "IF"
>1a0dab	20				precedence  .byte TOK_TY_STMNT | 0
>1a0dac	02				length      .byte len("IF")
>1a0dad	53 d0				name        .word <>TOKEN_TEXT
>1a0daf	fe 43				eval        .word <>S_IF
>1a0db1	00 00				arity       .word <>0
=$97					TOK_THEN = $97
>1ad056	54 48 45 4e 00			TOKEN_TEXT  .null "THEN"
>1a0db3	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0db4	04				length      .byte len("THEN")
>1a0db5	56 d0				name        .word <>TOKEN_TEXT
>1a0db7	00 00				eval        .word <>0
>1a0db9	00 00				arity       .word <>0
>1ad05b	45 4c 53 45 00			TOKEN_TEXT  .null "ELSE"
>1a0dbb	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0dbc	04				length      .byte len("ELSE")
>1a0dbd	5b d0				name        .word <>TOKEN_TEXT
>1a0dbf	00 00				eval        .word <>0
>1a0dc1	00 00				arity       .word <>0
>1ad060	47 4f 53 55 42 00		TOKEN_TEXT  .null "GOSUB"
>1a0dc3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0dc4	05				length      .byte len("GOSUB")
>1a0dc5	60 d0				name        .word <>TOKEN_TEXT
>1a0dc7	41 43				eval        .word <>S_GOSUB
>1a0dc9	00 00				arity       .word <>0
>1ad066	52 45 54 55 52 4e 00		TOKEN_TEXT  .null "RETURN"
>1a0dcb	20				precedence  .byte TOK_TY_STMNT | 0
>1a0dcc	06				length      .byte len("RETURN")
>1a0dcd	66 d0				name        .word <>TOKEN_TEXT
>1a0dcf	ba 43				eval        .word <>S_RETURN
>1a0dd1	00 00				arity       .word <>0
=$9b					TOK_FOR = $9B
>1ad06d	46 4f 52 00			TOKEN_TEXT  .null "FOR"
>1a0dd3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0dd4	03				length      .byte len("FOR")
>1a0dd5	6d d0				name        .word <>TOKEN_TEXT
>1a0dd7	96 41				eval        .word <>S_FOR
>1a0dd9	00 00				arity       .word <>0
=$9c					TOK_TO = $9C
>1ad071	54 4f 00			TOKEN_TEXT  .null "TO"
>1a0ddb	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0ddc	02				length      .byte len("TO")
>1a0ddd	71 d0				name        .word <>TOKEN_TEXT
>1a0ddf	00 00				eval        .word <>0
>1a0de1	00 00				arity       .word <>0
=$9d					TOK_STEP = $9D
>1ad074	53 54 45 50 00			TOKEN_TEXT  .null "STEP"
>1a0de3	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0de4	04				length      .byte len("STEP")
>1a0de5	74 d0				name        .word <>TOKEN_TEXT
>1a0de7	00 00				eval        .word <>0
>1a0de9	00 00				arity       .word <>0
=$9e					TOK_NEXT = $9E
>1ad079	4e 45 58 54 00			TOKEN_TEXT  .null "NEXT"
>1a0deb	20				precedence  .byte TOK_TY_STMNT | 0
>1a0dec	04				length      .byte len("NEXT")
>1a0ded	79 d0				name        .word <>TOKEN_TEXT
>1a0def	8a 42				eval        .word <>S_NEXT
>1a0df1	00 00				arity       .word <>0
=$9f					TOK_DO = $9F
>1ad07e	44 4f 00			TOKEN_TEXT  .null "DO"
>1a0df3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0df4	02				length      .byte len("DO")
>1a0df5	7e d0				name        .word <>TOKEN_TEXT
>1a0df7	90 41				eval        .word <>S_DO
>1a0df9	00 00				arity       .word <>0
=$a0					TOK_LOOP = $A0
>1ad081	4c 4f 4f 50 00			TOKEN_TEXT  .null "LOOP"
>1a0dfb	20				precedence  .byte TOK_TY_STMNT | 0
>1a0dfc	04				length      .byte len("LOOP")
>1a0dfd	81 d0				name        .word <>TOKEN_TEXT
>1a0dff	93 41				eval        .word <>S_LOOP
>1a0e01	00 00				arity       .word <>0
>1ad086	57 48 49 4c 45 00		TOKEN_TEXT  .null "WHILE"
>1a0e03	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0e04	05				length      .byte len("WHILE")
>1a0e05	86 d0				name        .word <>TOKEN_TEXT
>1a0e07	00 00				eval        .word <>0
>1a0e09	00 00				arity       .word <>0
>1ad08c	55 4e 54 49 4c 00		TOKEN_TEXT  .null "UNTIL"
>1a0e0b	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0e0c	05				length      .byte len("UNTIL")
>1a0e0d	8c d0				name        .word <>TOKEN_TEXT
>1a0e0f	00 00				eval        .word <>0
>1a0e11	00 00				arity       .word <>0
>1ad092	45 58 49 54 00			TOKEN_TEXT  .null "EXIT"
>1a0e13	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e14	04				length      .byte len("EXIT")
>1a0e15	92 d0				name        .word <>TOKEN_TEXT
>1a0e17	8d 41				eval        .word <>S_EXIT
>1a0e19	00 00				arity       .word <>0
>1ad097	43 4c 52 00			TOKEN_TEXT  .null "CLR"
>1a0e1b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e1c	03				length      .byte len("CLR")
>1a0e1d	97 d0				name        .word <>TOKEN_TEXT
>1a0e1f	c5 44				eval        .word <>S_CLR
>1a0e21	00 00				arity       .word <>0
>1ad09b	53 54 4f 50 00			TOKEN_TEXT  .null "STOP"
>1a0e23	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e24	04				length      .byte len("STOP")
>1a0e25	9b d0				name        .word <>TOKEN_TEXT
>1a0e27	60 41				eval        .word <>S_STOP
>1a0e29	00 00				arity       .word <>0
>1ad0a0	50 4f 4b 45 00			TOKEN_TEXT  .null "POKE"
>1a0e2b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e2c	04				length      .byte len("POKE")
>1a0e2d	a0 d0				name        .word <>TOKEN_TEXT
>1a0e2f	f0 40				eval        .word <>S_POKE
>1a0e31	00 00				arity       .word <>0
>1ad0a5	50 4f 4b 45 57 00		TOKEN_TEXT  .null "POKEW"
>1a0e33	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e34	05				length      .byte len("POKEW")
>1a0e35	a5 d0				name        .word <>TOKEN_TEXT
>1a0e37	86 40				eval        .word <>S_POKEW
>1a0e39	00 00				arity       .word <>0
>1ad0ab	50 4f 4b 45 4c 00		TOKEN_TEXT  .null "POKEL"
>1a0e3b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e3c	05				length      .byte len("POKEL")
>1a0e3d	ab d0				name        .word <>TOKEN_TEXT
>1a0e3f	13 40				eval        .word <>S_POKEL
>1a0e41	00 00				arity       .word <>0
>1ad0b1	43 4c 53 00			TOKEN_TEXT  .null "CLS"
>1a0e43	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e44	03				length      .byte len("CLS")
>1a0e45	b1 d0				name        .word <>TOKEN_TEXT
>1a0e47	0f 40				eval        .word <>S_CLS
>1a0e49	00 00				arity       .word <>0
>1ad0b5	52 45 41 44 00			TOKEN_TEXT  .null "READ"
>1a0e4b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e4c	04				length      .byte len("READ")
>1a0e4d	b5 d0				name        .word <>TOKEN_TEXT
>1a0e4f	f0 3e				eval        .word <>S_READ
>1a0e51	00 00				arity       .word <>0
=$ab					TOK_DATA = $AB
>1ad0ba	44 41 54 41 00			TOKEN_TEXT  .null "DATA"
>1a0e53	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e54	04				length      .byte len("DATA")
>1a0e55	ba d0				name        .word <>TOKEN_TEXT
>1a0e57	02 40				eval        .word <>S_DATA
>1a0e59	00 00				arity       .word <>0
>1ad0bf	52 45 53 54 4f 52 45 00		TOKEN_TEXT  .null "RESTORE"
>1a0e5b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e5c	07				length      .byte len("RESTORE")
>1a0e5d	bf d0				name        .word <>TOKEN_TEXT
>1a0e5f	06 40				eval        .word <>S_RESTORE
>1a0e61	00 00				arity       .word <>0
>1ad0c7	44 49 4d 00			TOKEN_TEXT  .null "DIM"
>1a0e63	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e64	03				length      .byte len("DIM")
>1a0e65	c7 d0				name        .word <>TOKEN_TEXT
>1a0e67	43 3e				eval        .word <>S_DIM
>1a0e69	00 00				arity       .word <>0
>1ad0cb	43 41 4c 4c 00			TOKEN_TEXT  .null "CALL"
>1a0e6b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e6c	04				length      .byte len("CALL")
>1a0e6d	cb d0				name        .word <>TOKEN_TEXT
>1a0e6f	ac 3d				eval        .word <>S_CALL
>1a0e71	00 00				arity       .word <>0
=$af					TOK_NEGATIVE = $AF
>1ad0d0	2d 00				TOKEN_TEXT  .null "-"
>1a0e73	00				precedence  .byte TOK_TY_OP | 0
>1a0e74	01				length      .byte len("-")
>1a0e75	d0 d0				name        .word <>TOKEN_TEXT
>1a0e77	ac 2a				eval        .word <>OP_NEGATIVE
>1a0e79	01 00				arity       .word <>1
>1ad0d2	4c 45 4e 00			TOKEN_TEXT  .null "LEN"
>1a0e7b	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e7c	03				length      .byte len("LEN")
>1a0e7d	d2 d0				name        .word <>TOKEN_TEXT
>1a0e7f	9c 4b				eval        .word <>FN_LEN
>1a0e81	00 00				arity       .word <>0
>1ad0d6	50 45 45 4b 00			TOKEN_TEXT  .null "PEEK"
>1a0e83	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e84	04				length      .byte len("PEEK")
>1a0e85	d6 d0				name        .word <>TOKEN_TEXT
>1a0e87	ec 4b				eval        .word <>FN_PEEK
>1a0e89	00 00				arity       .word <>0
>1ad0db	50 45 45 4b 57 00		TOKEN_TEXT  .null "PEEKW"
>1a0e8b	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e8c	05				length      .byte len("PEEKW")
>1a0e8d	db d0				name        .word <>TOKEN_TEXT
>1a0e8f	b5 4c				eval        .word <>FN_PEEKW
>1a0e91	00 00				arity       .word <>0
>1ad0e1	50 45 45 4b 4c 00		TOKEN_TEXT  .null "PEEKL"
>1a0e93	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e94	05				length      .byte len("PEEKL")
>1a0e95	e1 d0				name        .word <>TOKEN_TEXT
>1a0e97	42 4c				eval        .word <>FN_PEEKL
>1a0e99	00 00				arity       .word <>0
>1ad0e7	43 48 52 24 00			TOKEN_TEXT  .null "CHR$"
>1a0e9b	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e9c	04				length      .byte len("CHR$")
>1a0e9d	e7 d0				name        .word <>TOKEN_TEXT
>1a0e9f	14 4d				eval        .word <>FN_CHR
>1a0ea1	00 00				arity       .word <>0
>1ad0ec	41 53 43 00			TOKEN_TEXT  .null "ASC"
>1a0ea3	30				precedence  .byte TOK_TY_FUNC | 0
>1a0ea4	03				length      .byte len("ASC")
>1a0ea5	ec d0				name        .word <>TOKEN_TEXT
>1a0ea7	69 4d				eval        .word <>FN_ASC
>1a0ea9	00 00				arity       .word <>0
>1ad0f0	53 50 43 00			TOKEN_TEXT  .null "SPC"
>1a0eab	30				precedence  .byte TOK_TY_FUNC | 0
>1a0eac	03				length      .byte len("SPC")
>1a0ead	f0 d0				name        .word <>TOKEN_TEXT
>1a0eaf	ae 4d				eval        .word <>FN_SPC
>1a0eb1	00 00				arity       .word <>0
>1ad0f4	54 41 42 00			TOKEN_TEXT  .null "TAB"
>1a0eb3	30				precedence  .byte TOK_TY_FUNC | 0
>1a0eb4	03				length      .byte len("TAB")
>1a0eb5	f4 d0				name        .word <>TOKEN_TEXT
>1a0eb7	37 4e				eval        .word <>FN_TAB
>1a0eb9	00 00				arity       .word <>0
>1ad0f8	41 42 53 00			TOKEN_TEXT  .null "ABS"
>1a0ebb	30				precedence  .byte TOK_TY_FUNC | 0
>1a0ebc	03				length      .byte len("ABS")
>1a0ebd	f8 d0				name        .word <>TOKEN_TEXT
>1a0ebf	c0 4e				eval        .word <>FN_ABS
>1a0ec1	00 00				arity       .word <>0
>1ad0fc	53 47 4e 00			TOKEN_TEXT  .null "SGN"
>1a0ec3	30				precedence  .byte TOK_TY_FUNC | 0
>1a0ec4	03				length      .byte len("SGN")
>1a0ec5	fc d0				name        .word <>TOKEN_TEXT
>1a0ec7	22 4f				eval        .word <>FN_SGN
>1a0ec9	00 00				arity       .word <>0
>1ad100	48 45 58 24 00			TOKEN_TEXT  .null "HEX$"
>1a0ecb	30				precedence  .byte TOK_TY_FUNC | 0
>1a0ecc	04				length      .byte len("HEX$")
>1a0ecd	00 d1				name        .word <>TOKEN_TEXT
>1a0ecf	0e 4b				eval        .word <>FN_HEX
>1a0ed1	00 00				arity       .word <>0
>1ad105	44 45 43 00			TOKEN_TEXT  .null "DEC"
>1a0ed3	30				precedence  .byte TOK_TY_FUNC | 0
>1a0ed4	03				length      .byte len("DEC")
>1a0ed5	05 d1				name        .word <>TOKEN_TEXT
>1a0ed7	ad 4a				eval        .word <>FN_DEC
>1a0ed9	00 00				arity       .word <>0
>1ad109	53 54 52 24 00			TOKEN_TEXT  .null "STR$"
>1a0edb	30				precedence  .byte TOK_TY_FUNC | 0
>1a0edc	04				length      .byte len("STR$")
>1a0edd	09 d1				name        .word <>TOKEN_TEXT
>1a0edf	5f 4a				eval        .word <>FN_STR
>1a0ee1	00 00				arity       .word <>0
>1ad10e	56 41 4c 00			TOKEN_TEXT  .null "VAL"
>1a0ee3	30				precedence  .byte TOK_TY_FUNC | 0
>1a0ee4	03				length      .byte len("VAL")
>1a0ee5	0e d1				name        .word <>TOKEN_TEXT
>1a0ee7	09 4a				eval        .word <>FN_VAL
>1a0ee9	00 00				arity       .word <>0
>1ad112	4c 45 46 54 24 00		TOKEN_TEXT  .null "LEFT$"
>1a0eeb	30				precedence  .byte TOK_TY_FUNC | 0
>1a0eec	05				length      .byte len("LEFT$")
>1a0eed	12 d1				name        .word <>TOKEN_TEXT
>1a0eef	40 49				eval        .word <>FN_LEFT
>1a0ef1	00 00				arity       .word <>0
>1ad118	52 49 47 48 54 24 00		TOKEN_TEXT  .null "RIGHT$"
>1a0ef3	30				precedence  .byte TOK_TY_FUNC | 0
>1a0ef4	06				length      .byte len("RIGHT$")
>1a0ef5	18 d1				name        .word <>TOKEN_TEXT
>1a0ef7	5f 48				eval        .word <>FN_RIGHT
>1a0ef9	00 00				arity       .word <>0
>1ad11f	4d 49 44 24 00			TOKEN_TEXT  .null "MID$"
>1a0efb	30				precedence  .byte TOK_TY_FUNC | 0
>1a0efc	04				length      .byte len("MID$")
>1a0efd	1f d1				name        .word <>TOKEN_TEXT
>1a0eff	aa 47				eval        .word <>FN_MID
>1a0f01	00 00				arity       .word <>0
>1ad124	52 55 4e 00			TOKEN_TEXT  .null "RUN"
>1a0f03	10				precedence  .byte TOK_TY_CMD | 0
>1a0f04	03				length      .byte len("RUN")
>1a0f05	24 d1				name        .word <>TOKEN_TEXT
>1a0f07	89 50				eval        .word <>CMD_RUN
>1a0f09	00 00				arity       .word <>0
>1ad128	4e 45 57 00			TOKEN_TEXT  .null "NEW"
>1a0f0b	10				precedence  .byte TOK_TY_CMD | 0
>1a0f0c	03				length      .byte len("NEW")
>1a0f0d	28 d1				name        .word <>TOKEN_TEXT
>1a0f0f	54 50				eval        .word <>CMD_NEW
>1a0f11	00 00				arity       .word <>0
>1ad12c	4c 4f 41 44 00			TOKEN_TEXT  .null "LOAD"
>1a0f13	10				precedence  .byte TOK_TY_CMD | 0
>1a0f14	04				length      .byte len("LOAD")
>1a0f15	2c d1				name        .word <>TOKEN_TEXT
>1a0f17	5d 6c				eval        .word <>CMD_LOAD
>1a0f19	00 00				arity       .word <>0
>1ad131	4c 49 53 54 00			TOKEN_TEXT  .null "LIST"
>1a0f1b	10				precedence  .byte TOK_TY_CMD | 0
>1a0f1c	04				length      .byte len("LIST")
>1a0f1d	31 d1				name        .word <>TOKEN_TEXT
>1a0f1f	a0 50				eval        .word <>CMD_LIST
>1a0f21	00 00				arity       .word <>0
>1ad136	44 49 52 00			TOKEN_TEXT  .null "DIR"
>1a0f23	10				precedence  .byte TOK_TY_CMD | 0
>1a0f24	03				length      .byte len("DIR")
>1a0f25	36 d1				name        .word <>TOKEN_TEXT
>1a0f27	84 69				eval        .word <>CMD_DIR
>1a0f29	00 00				arity       .word <>0
>1ad13a	42 4c 4f 41 44 00		TOKEN_TEXT  .null "BLOAD"
>1a0f2b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f2c	05				length      .byte len("BLOAD")
>1a0f2d	3a d1				name        .word <>TOKEN_TEXT
>1a0f2f	2f 6b				eval        .word <>S_BLOAD
>1a0f31	00 00				arity       .word <>0
>1ad140	42 52 55 4e 00			TOKEN_TEXT  .null "BRUN"
>1a0f33	10				precedence  .byte TOK_TY_CMD | 0
>1a0f34	04				length      .byte len("BRUN")
>1a0f35	40 d1				name        .word <>TOKEN_TEXT
>1a0f37	0a 6c				eval        .word <>CMD_BRUN
>1a0f39	00 00				arity       .word <>0
>1ad145	42 53 41 56 45 00		TOKEN_TEXT  .null "BSAVE"
>1a0f3b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f3c	05				length      .byte len("BSAVE")
>1a0f3d	45 d1				name        .word <>TOKEN_TEXT
>1a0f3f	16 6d				eval        .word <>S_BSAVE
>1a0f41	00 00				arity       .word <>0
>1ad14b	44 45 4c 00			TOKEN_TEXT  .null "DEL"
>1a0f43	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f44	03				length      .byte len("DEL")
>1a0f45	4b d1				name        .word <>TOKEN_TEXT
>1a0f47	35 6e				eval        .word <>S_DEL
>1a0f49	00 00				arity       .word <>0
>1ad14f	53 41 56 45 00			TOKEN_TEXT  .null "SAVE"
>1a0f4b	10				precedence  .byte TOK_TY_CMD | 0
>1a0f4c	04				length      .byte len("SAVE")
>1a0f4d	4f d1				name        .word <>TOKEN_TEXT
>1a0f4f	a2 6d				eval        .word <>CMD_SAVE
>1a0f51	00 00				arity       .word <>0
>1ad154	52 45 4e 41 4d 45 00		TOKEN_TEXT  .null "RENAME"
>1a0f53	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f54	06				length      .byte len("RENAME")
>1a0f55	54 d1				name        .word <>TOKEN_TEXT
>1a0f57	ab 6e				eval        .word <>S_RENAME
>1a0f59	00 00				arity       .word <>0
>1ad15b	43 4f 50 59 00			TOKEN_TEXT  .null "COPY"
>1a0f5b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f5c	04				length      .byte len("COPY")
>1a0f5d	5b d1				name        .word <>TOKEN_TEXT
>1a0f5f	cf 6f				eval        .word <>S_COPY
>1a0f61	00 00				arity       .word <>0
>1ad160	4d 4f 4e 49 54 4f 52 00		TOKEN_TEXT  .null "MONITOR"
>1a0f63	10				precedence  .byte TOK_TY_CMD | 0
>1a0f64	07				length      .byte len("MONITOR")
>1a0f65	60 d1				name        .word <>TOKEN_TEXT
>1a0f67	51 50				eval        .word <>CMD_MONITOR
>1a0f69	00 00				arity       .word <>0
>1ad168	47 45 54 00			TOKEN_TEXT  .null "GET"
>1a0f6b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f6c	03				length      .byte len("GET")
>1a0f6d	68 d1				name        .word <>TOKEN_TEXT
>1a0f6f	3a 3d				eval        .word <>S_GET
>1a0f71	00 00				arity       .word <>0
>1ad16c	49 4e 50 55 54 00		TOKEN_TEXT  .null "INPUT"
>1a0f73	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f74	05				length      .byte len("INPUT")
>1a0f75	6c d1				name        .word <>TOKEN_TEXT
>1a0f77	4a 3c				eval        .word <>S_INPUT
>1a0f79	00 00				arity       .word <>0
>1ad172	53 45 54 42 4f 52 44 45		TOKEN_TEXT  .null "SETBORDER"
>1ad17a	52 00
>1a0f7b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f7c	09				length      .byte len("SETBORDER")
>1a0f7d	72 d1				name        .word <>TOKEN_TEXT
>1a0f7f	6b 2c				eval        .word <>S_SETBORDER
>1a0f81	00 00				arity       .word <>0
>1ad17c	54 45 58 54 43 4f 4c 4f		TOKEN_TEXT  .null "TEXTCOLOR"
>1ad184	52 00
>1a0f83	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f84	09				length      .byte len("TEXTCOLOR")
>1a0f85	7c d1				name        .word <>TOKEN_TEXT
>1a0f87	f8 2b				eval        .word <>S_TEXTCOLOR
>1a0f89	00 00				arity       .word <>0
>1ad186	53 45 54 42 47 43 4f 4c		TOKEN_TEXT  .null "SETBGCOLOR"
>1ad18e	4f 52 00
>1a0f8b	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f8c	0a				length      .byte len("SETBGCOLOR")
>1a0f8d	86 d1				name        .word <>TOKEN_TEXT
>1a0f8f	28 2c				eval        .word <>S_SETBGCOLOR
>1a0f91	00 00				arity       .word <>0
>1ad191	53 45 54 44 41 54 45 00		TOKEN_TEXT  .null "SETDATE"
>1a0f93	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f94	07				length      .byte len("SETDATE")
>1a0f95	91 d1				name        .word <>TOKEN_TEXT
>1a0f97	65 2b				eval        .word <>S_SETDATE
>1a0f99	00 00				arity       .word <>0
>1ad199	47 45 54 44 41 54 45 24		TOKEN_TEXT  .null "GETDATE$"
>1ad1a1	00
>1a0f9b	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f9c	08				length      .byte len("GETDATE$")
>1a0f9d	99 d1				name        .word <>TOKEN_TEXT
>1a0f9f	61 46				eval        .word <>F_GETDATE
>1a0fa1	00 00				arity       .word <>0
>1ad1a2	53 45 54 54 49 4d 45 00		TOKEN_TEXT  .null "SETTIME"
>1a0fa3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fa4	07				length      .byte len("SETTIME")
>1a0fa5	a2 d1				name        .word <>TOKEN_TEXT
>1a0fa7	fa 2a				eval        .word <>S_SETTIME
>1a0fa9	00 00				arity       .word <>0
>1ad1aa	47 45 54 54 49 4d 45 24		TOKEN_TEXT  .null "GETTIME$"
>1ad1b2	00
>1a0fab	30				precedence  .byte TOK_TY_FUNC | 0
>1a0fac	08				length      .byte len("GETTIME$")
>1a0fad	aa d1				name        .word <>TOKEN_TEXT
>1a0faf	cb 46				eval        .word <>F_GETTIME
>1a0fb1	00 00				arity       .word <>0
>1ad1b3	47 52 41 50 48 49 43 53		TOKEN_TEXT  .null "GRAPHICS"
>1ad1bb	00
>1a0fb3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fb4	08				length      .byte len("GRAPHICS")
>1a0fb5	b3 d1				name        .word <>TOKEN_TEXT
>1a0fb7	b0 2d				eval        .word <>S_GRAPHICS
>1a0fb9	00 00				arity       .word <>0
>1ad1bc	53 45 54 43 4f 4c 4f 52		TOKEN_TEXT  .null "SETCOLOR"
>1ad1c4	00
>1a0fbb	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fbc	08				length      .byte len("SETCOLOR")
>1a0fbd	bc d1				name        .word <>TOKEN_TEXT
>1a0fbf	e4 2c				eval        .word <>S_SETCOLOR
>1a0fc1	00 00				arity       .word <>0
>1ad1c5	42 49 54 4d 41 50 00		TOKEN_TEXT  .null "BITMAP"
>1a0fc3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fc4	06				length      .byte len("BITMAP")
>1a0fc5	c5 d1				name        .word <>TOKEN_TEXT
>1a0fc7	ea 2e				eval        .word <>S_BITMAP
>1a0fc9	00 00				arity       .word <>0
>1ad1cc	43 4c 52 42 49 54 4d 41		TOKEN_TEXT  .null "CLRBITMAP"
>1ad1d4	50 00
>1a0fcb	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fcc	09				length      .byte len("CLRBITMAP")
>1a0fcd	cc d1				name        .word <>TOKEN_TEXT
>1a0fcf	f2 2f				eval        .word <>S_CLRBITMAP
>1a0fd1	00 00				arity       .word <>0
>1ad1d6	50 4c 4f 54 00			TOKEN_TEXT  .null "PLOT"
>1a0fd3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fd4	04				length      .byte len("PLOT")
>1a0fd5	d6 d1				name        .word <>TOKEN_TEXT
>1a0fd7	4f 31				eval        .word <>S_PLOT
>1a0fd9	00 00				arity       .word <>0
>1ad1db	4c 49 4e 45 00			TOKEN_TEXT  .null "LINE"
>1a0fdb	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fdc	04				length      .byte len("LINE")
>1a0fdd	db d1				name        .word <>TOKEN_TEXT
>1a0fdf	c0 31				eval        .word <>S_LINE
>1a0fe1	00 00				arity       .word <>0
>1ad1e0	46 49 4c 4c 00			TOKEN_TEXT  .null "FILL"
>1a0fe3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fe4	04				length      .byte len("FILL")
>1a0fe5	e0 d1				name        .word <>TOKEN_TEXT
>1a0fe7	59 32				eval        .word <>S_FILL
>1a0fe9	00 00				arity       .word <>0
>1ad1e5	53 50 52 49 54 45 00		TOKEN_TEXT  .null "SPRITE"
>1a0feb	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fec	06				length      .byte len("SPRITE")
>1a0fed	e5 d1				name        .word <>TOKEN_TEXT
>1a0fef	95 33				eval        .word <>S_SPRITE
>1a0ff1	00 00				arity       .word <>0
>1ad1ec	53 50 52 49 54 45 41 54		TOKEN_TEXT  .null "SPRITEAT"
>1ad1f4	00
>1a0ff3	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ff4	08				length      .byte len("SPRITEAT")
>1a0ff5	ec d1				name        .word <>TOKEN_TEXT
>1a0ff7	33 34				eval        .word <>S_SPRITEAT
>1a0ff9	00 00				arity       .word <>0
>1ad1f5	53 50 52 49 54 45 53 48		TOKEN_TEXT  .null "SPRITESHOW"
>1ad1fd	4f 57 00
>1a0ffb	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ffc	0a				length      .byte len("SPRITESHOW")
>1a0ffd	f5 d1				name        .word <>TOKEN_TEXT
>1a0fff	81 34				eval        .word <>S_SPRITESHOW
>1a1001	00 00				arity       .word <>0
>1ad200	54 49 4c 45 53 45 54 00		TOKEN_TEXT  .null "TILESET"
>1a1003	20				precedence  .byte TOK_TY_STMNT | 0
>1a1004	07				length      .byte len("TILESET")
>1a1005	00 d2				name        .word <>TOKEN_TEXT
>1a1007	b8 35				eval        .word <>S_TILESET
>1a1009	00 00				arity       .word <>0
>1ad208	54 49 4c 45 4d 41 50 00		TOKEN_TEXT  .null "TILEMAP"
>1a100b	20				precedence  .byte TOK_TY_STMNT | 0
>1a100c	07				length      .byte len("TILEMAP")
>1a100d	08 d2				name        .word <>TOKEN_TEXT
>1a100f	36 36				eval        .word <>S_TILEMAP
>1a1011	00 00				arity       .word <>0
>1ad210	54 49 4c 45 53 48 4f 57		TOKEN_TEXT  .null "TILESHOW"
>1ad218	00
>1a1013	20				precedence  .byte TOK_TY_STMNT | 0
>1a1014	08				length      .byte len("TILESHOW")
>1a1015	10 d2				name        .word <>TOKEN_TEXT
>1a1017	a8 36				eval        .word <>S_TILESHOW
>1a1019	00 00				arity       .word <>0
>1ad219	54 49 4c 45 41 54 00		TOKEN_TEXT  .null "TILEAT"
>1a101b	20				precedence  .byte TOK_TY_STMNT | 0
>1a101c	06				length      .byte len("TILEAT")
>1a101d	19 d2				name        .word <>TOKEN_TEXT
>1a101f	e5 36				eval        .word <>S_TILEAT
>1a1021	00 00				arity       .word <>0
>1ad220	4d 45 4d 43 4f 50 59 00		TOKEN_TEXT  .null "MEMCOPY"
>1a1023	20				precedence  .byte TOK_TY_STMNT | 0
>1a1024	07				length      .byte len("MEMCOPY")
>1a1025	20 d2				name        .word <>TOKEN_TEXT
>1a1027	15 3a				eval        .word <>S_MEMCOPY
>1a1029	00 00				arity       .word <>0
=$e6					TOK_LINEAR = $E6
>1ad228	4c 49 4e 45 41 52 00		TOKEN_TEXT  .null "LINEAR"
>1a102b	50				precedence  .byte TOK_TY_BYWRD | 0
>1a102c	06				length      .byte len("LINEAR")
>1a102d	28 d2				name        .word <>TOKEN_TEXT
>1a102f	00 00				eval        .word <>0
>1a1031	00 00				arity       .word <>0
=$e7					TOK_RECT = $E7
>1ad22f	52 45 43 54 00			TOKEN_TEXT  .null "RECT"
>1a1033	50				precedence  .byte TOK_TY_BYWRD | 0
>1a1034	04				length      .byte len("RECT")
>1a1035	2f d2				name        .word <>TOKEN_TEXT
>1a1037	00 00				eval        .word <>0
>1a1039	00 00				arity       .word <>0
>1ad234	4c 4f 43 41 54 45 00		TOKEN_TEXT  .null "LOCATE"
>1a103b	20				precedence  .byte TOK_TY_STMNT | 0
>1a103c	06				length      .byte len("LOCATE")
>1a103d	34 d2				name        .word <>TOKEN_TEXT
>1a103f	2a 3c				eval        .word <>S_LOCATE
>1a1041	00 00				arity       .word <>0
>1ad23b	49 4e 54 00			TOKEN_TEXT  .null "INT"
>1a1043	30				precedence  .byte TOK_TY_FUNC | 0
>1a1044	03				length      .byte len("INT")
>1a1045	3b d2				name        .word <>TOKEN_TEXT
>1a1047	78 4f				eval        .word <>FN_INT
>1a1049	00 00				arity       .word <>0
>1ad23f	52 4e 44 00			TOKEN_TEXT  .null "RND"
>1a104b	30				precedence  .byte TOK_TY_FUNC | 0
>1a104c	03				length      .byte len("RND")
>1a104d	3f d2				name        .word <>TOKEN_TEXT
>1a104f	30 47				eval        .word <>FN_RND
>1a1051	00 00				arity       .word <>0
>1ad243	53 49 4e 00			TOKEN_TEXT  .null "SIN"
>1a1053	30				precedence  .byte TOK_TY_FUNC | 0
>1a1054	03				length      .byte len("SIN")
>1a1055	43 d2				name        .word <>TOKEN_TEXT
>1a1057	8b 4f				eval        .word <>FN_SIN
>1a1059	00 00				arity       .word <>0
>1ad247	43 4f 53 00			TOKEN_TEXT  .null "COS"
>1a105b	30				precedence  .byte TOK_TY_FUNC | 0
>1a105c	03				length      .byte len("COS")
>1a105d	47 d2				name        .word <>TOKEN_TEXT
>1a105f	a1 4f				eval        .word <>FN_COS
>1a1061	00 00				arity       .word <>0
>1ad24b	54 41 4e 00			TOKEN_TEXT  .null "TAN"
>1a1063	30				precedence  .byte TOK_TY_FUNC | 0
>1a1064	03				length      .byte len("TAN")
>1a1065	4b d2				name        .word <>TOKEN_TEXT
>1a1067	b7 4f				eval        .word <>FN_TAN
>1a1069	00 00				arity       .word <>0
>1ad24f	4c 4e 00			TOKEN_TEXT  .null "LN"
>1a106b	30				precedence  .byte TOK_TY_FUNC | 0
>1a106c	02				length      .byte len("LN")
>1a106d	4f d2				name        .word <>TOKEN_TEXT
>1a106f	cd 4f				eval        .word <>FN_LN
>1a1071	00 00				arity       .word <>0
>1ad252	41 43 4f 53 00			TOKEN_TEXT  .null "ACOS"
>1a1073	30				precedence  .byte TOK_TY_FUNC | 0
>1a1074	04				length      .byte len("ACOS")
>1a1075	52 d2				name        .word <>TOKEN_TEXT
>1a1077	e3 4f				eval        .word <>FN_ACOS
>1a1079	00 00				arity       .word <>0
>1ad257	41 53 49 4e 00			TOKEN_TEXT  .null "ASIN"
>1a107b	30				precedence  .byte TOK_TY_FUNC | 0
>1a107c	04				length      .byte len("ASIN")
>1a107d	57 d2				name        .word <>TOKEN_TEXT
>1a107f	f9 4f				eval        .word <>FN_ASIN
>1a1081	00 00				arity       .word <>0
>1ad25c	41 54 41 4e 00			TOKEN_TEXT  .null "ATAN"
>1a1083	30				precedence  .byte TOK_TY_FUNC | 0
>1a1084	04				length      .byte len("ATAN")
>1a1085	5c d2				name        .word <>TOKEN_TEXT
>1a1087	0f 50				eval        .word <>FN_ATAN
>1a1089	00 00				arity       .word <>0
>1ad261	45 58 50 00			TOKEN_TEXT  .null "EXP"
>1a108b	30				precedence  .byte TOK_TY_FUNC | 0
>1a108c	03				length      .byte len("EXP")
>1a108d	61 d2				name        .word <>TOKEN_TEXT
>1a108f	25 50				eval        .word <>FN_EXP
>1a1091	00 00				arity       .word <>0
>1ad265	53 51 52 00			TOKEN_TEXT  .null "SQR"
>1a1093	30				precedence  .byte TOK_TY_FUNC | 0
>1a1094	03				length      .byte len("SQR")
>1a1095	65 d2				name        .word <>TOKEN_TEXT
>1a1097	3b 50				eval        .word <>FN_SQR
>1a1099	00 00				arity       .word <>0
>1ad269	49 4e 4b 45 59 00		TOKEN_TEXT  .null "INKEY"
>1a109b	30				precedence  .byte TOK_TY_FUNC | 0
>1a109c	05				length      .byte len("INKEY")
>1a109d	69 d2				name        .word <>TOKEN_TEXT
>1a109f	86 47				eval        .word <>FN_INKEY
>1a10a1	00 00				arity       .word <>0
>1a10a3	00 00 00 00 00 00 00 00		            .word 0, 0, 0, 0

;******  Return to file: src\basic816.s


;******  Processing file: src\heap.s

>08b7					ALLOCATED   .long ?     ; Pointer to the most recently allocated object
>08ba					HEAP        .long ?     ; Pointer to the top of the heap (next empty byte)
>08bd					FREED       .long ?     ; Pointer to a linked list of freed heap objects
>08c0					CURRBLOCK   .long ?     ; Pointer to the current heap allocated block
>08c3					CURRHEADER  .long ?     ; Pointer to the header of the current block
>08c6					CURREND     .long ?     ; Pointer to the byte immediately after the current block
>08c9					CURRFREED   .long ?     ; Pointer to the current freed block
>08cc					FREEDEND    .long ?     ; Pointer to the byte immediately after the current freed block
>08cf					LASTFREED   .long ?     ;
.0000					HEAPOBJ
>0000					TYPE        .byte ?     ; Code for the type of object allocated
>0001					COUNT       .byte ?     ; Number of references to the heap object
>0002					NEXT        .long ?     ; Pointer to the next object in the list (used when freed)
>0005					END         .long ?     ; Pointer to the next byte after the block
.1a10ab					INITHEAP
.1a10ab	08		php		            PHP
.1a10ac	0b		phd		            PHD
.1a10ad	08		php		            PHP
.1a10ae	c2 20		rep #$20	            REP #$20
.1a10b0	48		pha		            PHA
.1a10b1	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a10b4	5b		tcd		            TCD
.1a10b5	68		pla		            PLA
.1a10b6	28		plp		            PLP
.1a10b7	c2 30		rep #$30	            REP #$30
.1a10b9	a9 ff ff	lda #$ffff	            LDA #<>HEAP_TOP         ; Set the HEAP to the top
.1a10bc	85 ba		sta $08ba	            STA HEAP
.1a10be	e2 20		sep #$20	            SEP #$20
.1a10c0	a9 17		lda #$17	            LDA #`HEAP_TOP
.1a10c2	85 bc		sta $08bc	            STA HEAP+2
.1a10c4	c2 20		rep #$20	            REP #$20
.1a10c6	64 b7		stz $08b7	            STZ ALLOCATED           ; And clear the pointer to the allocated objects
.1a10c8	64 bd		stz $08bd	            STZ FREED               ; as well as the list of freed objects
.1a10ca	e2 20		sep #$20	            SEP #$20
.1a10cc	64 b9		stz $08b9	            STZ ALLOCATED+2
.1a10ce	64 bf		stz $08bf	            STZ FREED+2
.1a10d0	2b		pld		            PLD
.1a10d1	28		plp		            PLP
.1a10d2	60		rts		            RTS
.1a10d3					ALLOC
.1a10d3	5a		phy		            PHY
.1a10d4	08		php		            PHP
.1a10d5	e2 20		sep #$20	            SEP #$20
.1a10d7	85 ea		sta $08ea	            STA TOFINDTYPE      ; Save the type of the block to TOFINDTYPE
.1a10d9	c2 10		rep #$10	            REP #$10
.1a10db	86 8f		stx $088f	            STX MCOUNT           ; And the length of the block needed to MCOUNT
.1a10dd	c2 20		rep #$20	            REP #$20
.1a10df	a5 0e		lda $080e	            LDA SCRATCH+2
.1a10e1	48		pha		            PHA
.1a10e2	a5 0c		lda $080c	            LDA SCRATCH
.1a10e4	48		pha		            PHA
.1a10e5	a5 12		lda $0812	            LDA SCRATCH2+2
.1a10e7	48		pha		            PHA
.1a10e8	a5 10		lda $0810	            LDA SCRATCH2
.1a10ea	48		pha		            PHA
.1a10eb	20 83 11	jsr $1a1183	            JSR ALLOCFREED
.1a10ee	b0 03		bcs $1a10f3	            BCS done            ; Return, if we got something back
.1a10f0	20 07 11	jsr $1a1107	            JSR ALLOCHEAP
.1a10f3					done
.1a10f3	20 0f 13	jsr $1a130f	            JSR HEAP_GETHED
.1a10f6	c2 20		rep #$20	            REP #$20
.1a10f8	68		pla		            PLA
.1a10f9	85 10		sta $0810	            STA SCRATCH2
.1a10fb	68		pla		            PLA
.1a10fc	85 12		sta $0812	            STA SCRATCH2+2
.1a10fe	68		pla		            PLA
.1a10ff	85 0c		sta $080c	            STA SCRATCH
.1a1101	68		pla		            PLA
.1a1102	85 0e		sta $080e	            STA SCRATCH+2
.1a1104	28		plp		            PLP
.1a1105	7a		ply		            PLY
.1a1106	60		rts		            RTS
.1a1107					ALLOCHEAP
.1a1107	08		php		            PHP
.1a1108	0b		phd		            PHD
.1a1109	08		php		            PHP
.1a110a	c2 20		rep #$20	            REP #$20
.1a110c	48		pha		            PHA
.1a110d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1110	5b		tcd		            TCD
.1a1111	68		pla		            PLA
.1a1112	28		plp		            PLP
.1a1113	e2 20		sep #$20	            SEP #$20
.1a1115	a6 8f		ldx $088f	            LDX MCOUNT
.1a1117	ca		dex		            DEX
.1a1118	86 0c		stx $080c	            STX SCRATCH             ; SCRATCH := size - 1
.1a111a	e8		inx		            INX
.1a111b	c2 30		rep #$30	            REP #$30
.1a111d	38		sec		            SEC
.1a111e	a5 ba		lda $08ba	            LDA HEAP
.1a1120	e5 0c		sbc $080c	            SBC SCRATCH
.1a1122	85 c0		sta $08c0	            STA CURRBLOCK
.1a1124	e2 20		sep #$20	            SEP #$20
.1a1126	a5 bc		lda $08bc	            LDA HEAP+2
.1a1128	e9 00		sbc #$00	            SBC #0
.1a112a	85 c2		sta $08c2	            STA CURRBLOCK+2
.1a112c	20 0f 13	jsr $1a130f	            JSR HEAP_GETHED
.1a112f	e2 20		sep #$20	            SEP #$20
.1a1131	a5 ea		lda $08ea	            LDA TOFINDTYPE
.1a1133	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE       ; Set the type of the object
.1a1136	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1138	a9 00		lda #$00	            LDA #0                  ; Set the count to zero
.1a113a	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.1a113d	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a113f	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1142	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1144	c2 20		rep #$20	            REP #$20
.1a1146	a9 00 00	lda #$0000	            LDA #0
.1a1149	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a114b	c2 20		rep #$20	            REP #$20
.1a114d	18		clc		            CLC
.1a114e	a5 ba		lda $08ba	            LDA HEAP
.1a1150	69 01 00	adc #$0001	            ADC #1
.1a1153	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; To get the address of the next byte
.1a1156	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y      ; after the block
.1a1158	e2 20		sep #$20	            SEP #$20
.1a115a	c8		iny		            INY
.1a115b	c8		iny		            INY
.1a115c	a5 bc		lda $08bc	            LDA HEAP+2
.1a115e	69 00		adc #$00	            ADC #0
.1a1160	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1162	c2 20		rep #$20	            REP #$20
.1a1164	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a1166	85 b7		sta $08b7	            STA ALLOCATED
.1a1168	e2 20		sep #$20	            SEP #$20
.1a116a	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a116c	85 b9		sta $08b9	            STA ALLOCATED+2
.1a116e	c2 20		rep #$20	            REP #$20
.1a1170	38		sec		            SEC                     ; Move the HEAP pointer to the first free byte under the header
.1a1171	a5 c3		lda $08c3	            LDA CURRHEADER
.1a1173	e9 01 00	sbc #$0001	            SBC #1
.1a1176	85 ba		sta $08ba	            STA HEAP
.1a1178	e2 20		sep #$20	            SEP #$20
.1a117a	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a117c	e9 00		sbc #$00	            SBC #0
.1a117e	85 bc		sta $08bc	            STA HEAP+2
.1a1180	2b		pld		            PLD
.1a1181	28		plp		            PLP
.1a1182	60		rts		            RTS
.1a1183					ALLOCFREED
.1a1183	08		php		            PHP
.1a1184	0b		phd		            PHD
.1a1185	08		php		            PHP
.1a1186	c2 20		rep #$20	            REP #$20
.1a1188	48		pha		            PHA
.1a1189	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a118c	5b		tcd		            TCD
.1a118d	68		pla		            PLA
.1a118e	28		plp		            PLP
.1a118f	c2 30		rep #$30	            REP #$30
.1a1191	c2 20		rep #$20	            REP #$20
.1a1193	a5 bd		lda $08bd	            LDA FREED
.1a1195	85 c9		sta $08c9	            STA CURRFREED
.1a1197	e2 20		sep #$20	            SEP #$20
.1a1199	a5 bf		lda $08bf	            LDA FREED+2
.1a119b	85 cb		sta $08cb	            STA CURRFREED+2
.1a119d	a5 c9		lda $08c9	loop        LDA CURRFREED           ; Has anything been freed?
.1a119f	d0 17		bne $1a11b8	            BNE has_block           ; Yes: check to see if there's a big enough block
.1a11a1	e2 20		sep #$20	            SEP #$20
.1a11a3	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a11a5	d0 11		bne $1a11b8	            BNE has_block           ; Yes: check to see if there's a big enough block
.1a11a7	c2 20		rep #$20	            REP #$20
.1a11a9	a9 00 00	lda #$0000	            LDA #<>0
.1a11ac	85 cf		sta $08cf	            STA LASTFREED
.1a11ae	e2 20		sep #$20	            SEP #$20
.1a11b0	a9 00		lda #$00	            LDA #`0
.1a11b2	85 d1		sta $08d1	            STA LASTFREED+2
.1a11b4	2b		pld		ret_false   PLD                     ; Return that we didn't find anything
.1a11b5	28		plp		            PLP
.1a11b6	18		clc		            CLC
.1a11b7	60		rts		            RTS
.1a11b8					has_block
.1a11b8	c2 20		rep #$20	            REP #$20
.1a11ba	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.1a11bd	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a11bf	85 cc		sta $08cc	            STA FREEDEND
.1a11c1	e2 20		sep #$20	            SEP #$20
.1a11c3	c8		iny		            INY
.1a11c4	c8		iny		            INY
.1a11c5	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a11c7	85 ce		sta $08ce	            STA FREEDEND+2
.1a11c9	c2 20		rep #$20	            REP #$20
.1a11cb	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required
.1a11cc	a5 c9		lda $08c9	            LDA CURRFREED
.1a11ce	65 8f		adc $088f	            ADC MCOUNT
.1a11d0	85 0c		sta $080c	            STA SCRATCH
.1a11d2	e2 20		sep #$20	            SEP #$20
.1a11d4	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a11d6	69 00		adc #$00	            ADC #0
.1a11d8	85 0e		sta $080e	            STA SCRATCH+2
.1a11da	c2 20		rep #$20	            REP #$20
.1a11dc	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required + size of header
.1a11dd	a5 0c		lda $080c	            LDA SCRATCH                 ; (that is, it's a pointer to the byte immediately after the block desired)
.1a11df	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)
.1a11e2	85 0c		sta $080c	            STA SCRATCH
.1a11e4	e2 20		sep #$20	            SEP #$20
.1a11e6	a5 0e		lda $080e	            LDA SCRATCH+2
.1a11e8	69 00		adc #$00	            ADC #0
.1a11ea	85 0e		sta $080e	            STA SCRATCH+2
.1a11ec	c2 20		rep #$20	            REP #$20
.1a11ee	a5 0c		lda $080c	            LDA SCRATCH                 ; Is SCRATCH == FREEDEND?
.1a11f0	c5 cc		cmp $08cc	            CMP FREEDEND
.1a11f2	d0 28		bne $1a121c	            BNE not_exact               ; No: check if this block is bigger than needed
.1a11f4	e2 20		sep #$20	            SEP #$20
.1a11f6	a5 0e		lda $080e	            LDA SCRATCH+2
.1a11f8	c5 ce		cmp $08ce	            CMP FREEDEND+2
.1a11fa	d0 20		bne $1a121c	            BNE not_exact
.1a11fc	c2 20		rep #$20	            REP #$20
.1a11fe	a5 cf		lda $08cf	            LDA LASTFREED               ; LASTFREED == 0?
.1a1200	d0 5d		bne $1a125f	            BNE adj_last1               ; No: point LASTFREED->NEXT to skip this block
.1a1202	e2 20		sep #$20	            SEP #$20
.1a1204	a5 d1		lda $08d1	            LDA LASTFREED+2
.1a1206	d0 57		bne $1a125f	            BNE adj_last1
.1a1208	c2 20		rep #$20	            REP #$20
.1a120a	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a120d	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a120f	85 bd		sta $08bd	            STA FREED
.1a1211	e2 20		sep #$20	            SEP #$20
.1a1213	c8		iny		            INY
.1a1214	c8		iny		            INY
.1a1215	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1217	85 bf		sta $08bf	            STA FREED+2
.1a1219	4c c0 12	jmp $1a12c0	            JMP init_block              ; And return CURRFREED as our reallocated memory
.1a121c					not_exact
.1a121c	c2 20		rep #$20	            REP #$20
.1a121e	a5 0c		lda $080c	            LDA SCRATCH                 ; Add a buffer to the room needed
.1a1220	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)          ; So we have room to track the memory still freed
.1a1223	85 10		sta $0810	            STA SCRATCH2
.1a1225	e2 20		sep #$20	            SEP #$20
.1a1227	a5 0e		lda $080e	            LDA SCRATCH+2
.1a1229	69 00		adc #$00	            ADC #0
.1a122b	85 12		sta $0812	            STA SCRATCH2+2
.1a122d	e2 20		sep #$20	            SEP #$20
.1a122f	a5 c6		lda $08c6	            LDA CURREND                 ; Is CURREND > SCRATCH2
.1a1231	c5 10		cmp $0810	            CMP SCRATCH2
.1a1233	b0 3e		bcs $1a1273	            BGE has_room                ; Yes: there is room in this block to allocate some memory
.1a1235	90 08		bcc $1a123f	            BLT try_next
.1a1237	c2 20		rep #$20	            REP #$20
.1a1239	a5 c6		lda $08c6	            LDA CURREND
.1a123b	c5 10		cmp $0810	            CMP SCRATCH2
.1a123d	b0 34		bcs $1a1273	            BGE has_room
.1a123f					try_next
.1a123f	c2 20		rep #$20	            REP #$20
.1a1241	a5 c9		lda $08c9	            LDA CURRFREED
.1a1243	85 cf		sta $08cf	            STA LASTFREED
.1a1245	e2 20		sep #$20	            SEP #$20
.1a1247	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a1249	85 d1		sta $08d1	            STA LASTFREED+2
.1a124b	c2 20		rep #$20	            REP #$20
.1a124d	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1250	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.1a1252	85 c9		sta $08c9	            STA CURRFREED
.1a1254	e2 20		sep #$20	            SEP #$20
.1a1256	c8		iny		            INY
.1a1257	c8		iny		            INY
.1a1258	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.1a125a	85 cb		sta $08cb	            STA CURRFREED+2
.1a125c	4c 9d 11	jmp $1a119d	            JMP loop                                    ; And try the next header
.1a125f					adj_last1
.1a125f	c2 20		rep #$20	            REP #$20
.1a1261	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := CURRFREED->NEXT
.1a1264	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1266	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.1a1268	e2 20		sep #$20	            SEP #$20
.1a126a	c8		iny		            INY
.1a126b	c8		iny		            INY
.1a126c	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a126e	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.1a1270	4c c0 12	jmp $1a12c0	            JMP init_block              ; And get CURRFREED ready to return
.1a1273					has_room
.1a1273	c2 20		rep #$20	            REP #$20
.1a1275	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END            ; SCRATCH->END := CURRFREED->END
.1a1278	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a127a	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a127c	e2 20		sep #$20	            SEP #$20
.1a127e	c8		iny		            INY
.1a127f	c8		iny		            INY
.1a1280	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1282	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a1284	c2 20		rep #$20	            REP #$20
.1a1286	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; CURREND->NEXT := CURRFREED->NEXT
.1a1289	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a128b	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a128d	e2 20		sep #$20	            SEP #$20
.1a128f	c8		iny		            INY
.1a1290	c8		iny		            INY
.1a1291	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1293	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a1295	c2 20		rep #$20	            REP #$20
.1a1297	a5 cf		lda $08cf	            LDA LASTFREED               ; Is this the first object we've examined?
.1a1299	d0 14		bne $1a12af	            BNE adj_last2               ; No: we'll need to adjust the previously examined block
.1a129b	e2 20		sep #$20	            SEP #$20
.1a129d	a5 cf		lda $08cf	            LDA LASTFREED
.1a129f	d0 0e		bne $1a12af	            BNE adj_last2
.1a12a1	c2 20		rep #$20	            REP #$20
.1a12a3	a5 0c		lda $080c	            LDA SCRATCH
.1a12a5	85 bd		sta $08bd	            STA FREED
.1a12a7	e2 20		sep #$20	            SEP #$20
.1a12a9	a5 0e		lda $080e	            LDA SCRATCH+2
.1a12ab	85 bf		sta $08bf	            STA FREED+2
.1a12ad	80 11		bra $1a12c0	            BRA init_block              ; ... and return the block we've sliced off
.1a12af					adj_last2
.1a12af	c2 20		rep #$20	            REP #$20
.1a12b1	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := SCRATCH
.1a12b4	a5 0c		lda $080c	            LDA SCRATCH                 ; (point the previous freed block to the newly sliced
.1a12b6	97 cf		sta [$08cf],y	            STA [LASTFREED],Y           ;  off part of the current block)
.1a12b8	e2 20		sep #$20	            SEP #$20
.1a12ba	c8		iny		            INY
.1a12bb	c8		iny		            INY
.1a12bc	a5 0e		lda $080e	            LDA SCRATCH+2
.1a12be	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.1a12c0					init_block
.1a12c0	c2 20		rep #$20	            REP #$20
.1a12c2	a5 c9		lda $08c9	            LDA CURRFREED
.1a12c4	85 c3		sta $08c3	            STA CURRHEADER
.1a12c6	e2 20		sep #$20	            SEP #$20
.1a12c8	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a12ca	85 c5		sta $08c5	            STA CURRHEADER+2
.1a12cc	c2 20		rep #$20	            REP #$20
.1a12ce	a5 c3		lda $08c3	            LDA CURRHEADER
.1a12d0	85 b7		sta $08b7	            STA ALLOCATED
.1a12d2	e2 20		sep #$20	            SEP #$20
.1a12d4	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a12d6	85 b9		sta $08b9	            STA ALLOCATED+2
.1a12d8	c2 20		rep #$20	            REP #$20
.1a12da	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; Set CURRHEADER->END to the byte after the block
.1a12dd	a5 0c		lda $080c	            LDA SCRATCH
.1a12df	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12e1	e2 20		sep #$20	            SEP #$20
.1a12e3	c8		iny		            INY
.1a12e4	c8		iny		            INY
.1a12e5	a5 0e		lda $080e	            LDA SCRATCH+2
.1a12e7	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12e9	c2 20		rep #$20	            REP #$20
.1a12eb	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Set CURRHEADER->NEXT to NULL
.1a12ee	a9 00 00	lda #$0000	            LDA #0
.1a12f1	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12f3	e2 20		sep #$20	            SEP #$20
.1a12f5	c8		iny		            INY
.1a12f6	c8		iny		            INY
.1a12f7	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12f9	e2 20		sep #$20	            SEP #$20
.1a12fb	a5 ea		lda $08ea	            LDA TOFINDTYPE          ; Get the type code back
.1a12fd	e2 20		sep #$20	            SEP #$20
.1a12ff	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE
.1a1302	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1304	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT      ; Set its reference count to 0
.1a1307	a9 00		lda #$00	            LDA #0
.1a1309	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a130b	2b		pld		done        PLD
.1a130c	28		plp		            PLP
.1a130d	38		sec		            SEC
.1a130e	60		rts		            RTS
.1a130f					HEAP_GETHED
.1a130f	08		php		            PHP
.1a1310	c2 20		rep #$20	            REP #$20
.1a1312	38		sec		            SEC
.1a1313	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a1315	e9 08 00	sbc #$0008	            SBC #size(HEAPOBJ)
.1a1318	85 c3		sta $08c3	            STA CURRHEADER
.1a131a	e2 20		sep #$20	            SEP #$20
.1a131c	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a131e	e9 00		sbc #$00	            SBC #0
.1a1320	85 c5		sta $08c5	            STA CURRHEADER+2
.1a1322	28		plp		            PLP
.1a1323	60		rts		            RTS
.1a1324					HEAP_ADDREF
.1a1324	08		php		            PHP
.1a1325	e2 20		sep #$20	            SEP #$20
.1a1327	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1329	f0 04		beq $1a132f	            BEQ chk_null
.1a132b	c9 18		cmp #$18	            CMP #`(HEAP_TOP + 1)
.1a132d	b0 12		bcs $1a1341	            BGE out_of_bnds
.1a132f					chk_null
.1a132f	c2 20		rep #$20	            REP #$20
.1a1331	a5 c3		lda $08c3	            LDA CURRHEADER
.1a1333	f0 0c		beq $1a1341	            BEQ out_of_bnds
.1a1335					is_ok
.1a1335	e2 20		sep #$20	            SEP #$20
.1a1337	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.1a133a	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a133c	1a		inc a		            INC A
.1a133d	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a133f	28		plp		            PLP
.1a1340	60		rts		            RTS
.1a1341	00		brk #		out_of_bnds BRK
.1a1342	ea		nop		            NOP
.1a1343					HEAP_REMREF
.1a1343	08		php		            PHP
.1a1344	e2 20		sep #$20	            SEP #$20
.1a1346	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1348	f0 04		beq $1a134e	            BEQ chk_null
.1a134a	c9 18		cmp #$18	            CMP #`(HEAP_TOP + 1)
.1a134c	b0 17		bcs $1a1365	            BGE out_of_bnds
.1a134e					chk_null
.1a134e	c2 20		rep #$20	            REP #$20
.1a1350	a5 c3		lda $08c3	            LDA CURRHEADER
.1a1352	f0 11		beq $1a1365	            BEQ out_of_bnds
.1a1354	e2 20		sep #$20	            SEP #$20
.1a1356	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT  ; Decrement the reference count
.1a1359	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a135b	3a		dec a		            DEC A
.1a135c	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a135e	d0 03		bne $1a1363	            BNE done            ; If it's still >0, we are done
.1a1360	20 67 13	jsr $1a1367	            JSR HEAP_FREE
.1a1363	28		plp		done        PLP
.1a1364	60		rts		            RTS
.1a1365	00		brk #		out_of_bnds BRK
.1a1366	ea		nop		            NOP
.1a1367					HEAP_FREE
.1a1367	08		php		            PHP
.1a1368	c2 20		rep #$20	            REP #$20
.1a136a	a5 bd		lda $08bd	            LDA FREED           ; Check to see if blocks are already on the freed list
.1a136c	d0 21		bne $1a138f	            BNE has_objects
.1a136e	e2 20		sep #$20	            SEP #$20
.1a1370	a5 bf		lda $08bf	            LDA FREED+2
.1a1372	d0 1b		bne $1a138f	            BNE has_objects
.1a1374	a5 c5		lda $08c5	            LDA CURRHEADER+2    ; No: this block is the first one
.1a1376	85 bf		sta $08bf	            STA FREED+2         ; Just make it the freed list
.1a1378	c2 20		rep #$20	            REP #$20
.1a137a	a5 c3		lda $08c3	            LDA CURRHEADER
.1a137c	85 bd		sta $08bd	            STA FREED
.1a137e	a9 00 00	lda #$0000	            LDA #0
.1a1381	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT   ; And clear its next link
.1a1384	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1386	c8		iny		            INY
.1a1387	c8		iny		            INY
.1a1388	e2 20		sep #$20	            SEP #$20
.1a138a	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a138c	4c 4e 14	jmp $1a144e	            JMP done
.1a138f					has_objects
.1a138f	e2 20		sep #$20	            SEP #$20
.1a1391	a5 bf		lda $08bf	            LDA FREED+2
.1a1393	c5 c5		cmp $08c5	            CMP CURRHEADER+2
.1a1395	90 28		bcc $1a13bf	            BLT start_scan
.1a1397	c2 20		rep #$20	            REP #$20
.1a1399	a5 bd		lda $08bd	            LDA FREED
.1a139b	c5 c3		cmp $08c3	            CMP CURRHEADER
.1a139d	90 20		bcc $1a13bf	            BLT start_scan
.1a139f					ins_first
.1a139f	c2 20		rep #$20	            REP #$20
.1a13a1	a5 bd		lda $08bd	            LDA FREED               ; CURRHEADER->NEXT := FREED
.1a13a3	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a13a6	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a13a8	e2 20		sep #$20	            SEP #$20
.1a13aa	c8		iny		            INY
.1a13ab	c8		iny		            INY
.1a13ac	a5 bf		lda $08bf	            LDA FREED+2
.1a13ae	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a13b0	c2 20		rep #$20	            REP #$20
.1a13b2	a5 c3		lda $08c3	            LDA CURRHEADER
.1a13b4	85 bd		sta $08bd	            STA FREED
.1a13b6	e2 20		sep #$20	            SEP #$20
.1a13b8	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a13ba	85 bf		sta $08bf	            STA FREED+2
.1a13bc	4c 4e 14	jmp $1a144e	            JMP done
.1a13bf					start_scan
.1a13bf	c2 20		rep #$20	            REP #$20
.1a13c1	a5 bd		lda $08bd	            LDA FREED
.1a13c3	85 08		sta $0808	            STA INDEX
.1a13c5	e2 20		sep #$20	            SEP #$20
.1a13c7	a5 bf		lda $08bf	            LDA FREED+2
.1a13c9	85 0a		sta $080a	            STA INDEX+2
.1a13cb					loop
.1a13cb	e2 20		sep #$20	            SEP #$20
.1a13cd	a0 04 00	ldy #$0004	            LDY #HEAPOBJ.NEXT+2
.1a13d0	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a13d2	c5 c8		cmp $08c8	            CMP CURREND+2
.1a13d4	90 32		bcc $1a1408	            BLT go_next             ; No: check the next spot
.1a13d6	d0 0b		bne $1a13e3	            BNE ins_next
.1a13d8	c2 20		rep #$20	            REP #$20
.1a13da	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a13dd	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a13df	c5 c6		cmp $08c6	            CMP CURREND
.1a13e1	90 25		bcc $1a1408	            BLT go_next             ; No: check the next spot
.1a13e3					ins_next
.1a13e3	c2 20		rep #$20	            REP #$20
.1a13e5	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := INDEX->NEXT
.1a13e8	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a13ea	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a13ec	e2 20		sep #$20	            SEP #$20
.1a13ee	c8		iny		            INY
.1a13ef	c8		iny		            INY
.1a13f0	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a13f2	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a13f4	c2 20		rep #$20	            REP #$20
.1a13f6	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.1a13f8	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a13fb	97 08		sta [$0808],y	            STA [INDEX],Y
.1a13fd	e2 20		sep #$20	            SEP #$20
.1a13ff	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1401	c8		iny		            INY
.1a1402	c8		iny		            INY
.1a1403	97 08		sta [$0808],y	            STA [INDEX],Y
.1a1405	4c 4e 14	jmp $1a144e	            JMP done
.1a1408					go_next
.1a1408	c2 20		rep #$20	            REP #$20
.1a140a	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Is INDEX->NEXT = 0
.1a140d	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a140f	d0 08		bne $1a1419	            BNE not_at_end          ; No: load up the next object
.1a1411	e2 20		sep #$20	            SEP #$20
.1a1413	c8		iny		            INY
.1a1414	c8		iny		            INY
.1a1415	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a1417	f0 19		beq $1a1432	            BEQ at_end
.1a1419					not_at_end
.1a1419	c2 20		rep #$20	            REP #$20
.1a141b	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; INDEX := INDEX->NEXT
.1a141e	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a1420	85 0c		sta $080c	            STA SCRATCH
.1a1422	e2 20		sep #$20	            SEP #$20
.1a1424	c8		iny		            INY
.1a1425	c8		iny		            INY
.1a1426	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a1428	85 0a		sta $080a	            STA INDEX+2
.1a142a	c2 20		rep #$20	            REP #$20
.1a142c	a5 0c		lda $080c	            LDA SCRATCH
.1a142e	85 08		sta $0808	            STA INDEX
.1a1430	80 99		bra $1a13cb	            BRA loop
.1a1432					at_end
.1a1432	c2 20		rep #$20	            REP #$20
.1a1434	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.1a1436	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1439	97 08		sta [$0808],y	            STA [INDEX],Y
.1a143b	e2 20		sep #$20	            SEP #$20
.1a143d	c8		iny		            INY
.1a143e	c8		iny		            INY
.1a143f	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1441	97 08		sta [$0808],y	            STA [INDEX],Y
.1a1443	a9 00		lda #$00	            LDA #0                  ; CURRHEADER->NEXT := 0
.1a1445	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1447	c2 20		rep #$20	            REP #$20
.1a1449	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a144c	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a144e					done
.1a144e	20 53 14	jsr $1a1453	            JSR COALLESCE
.1a1451	28		plp		            PLP
.1a1452	60		rts		            RTS
.1a1453					COALLESCE
.1a1453	08		php		            PHP
.1a1454	c2 20		rep #$20	            REP #$20
.1a1456	a5 bd		lda $08bd	            LDA FREED
.1a1458	85 c3		sta $08c3	            STA CURRHEADER
.1a145a	e2 20		sep #$20	            SEP #$20
.1a145c	a5 bf		lda $08bf	            LDA FREED+2
.1a145e	85 c5		sta $08c5	            STA CURRHEADER+2
.1a1460					next_head
.1a1460	c2 20		rep #$20	            REP #$20
.1a1462	a5 c3		lda $08c3	            LDA CURRHEADER          ; Is CURRHEADER == 0?
.1a1464	d0 09		bne $1a146f	            BNE check_next          ; No: check if NEXT is contiguous
.1a1466	e2 20		sep #$20	            SEP #$20
.1a1468	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a146a	d0 03		bne $1a146f	            BNE check_next
.1a146c	4c f6 14	jmp $1a14f6	            JMP done                ; Yes: we're done
.1a146f					check_next
.1a146f	c2 20		rep #$20	            REP #$20
.1a1471	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1474	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1476	85 0c		sta $080c	            STA SCRATCH
.1a1478	e2 20		sep #$20	            SEP #$20
.1a147a	c8		iny		            INY
.1a147b	c8		iny		            INY
.1a147c	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a147e	85 0e		sta $080e	            STA SCRATCH+2
.1a1480	c2 20		rep #$20	            REP #$20
.1a1482	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.1a1485	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1487	85 10		sta $0810	            STA SCRATCH2
.1a1489	e2 20		sep #$20	            SEP #$20
.1a148b	c8		iny		            INY
.1a148c	c8		iny		            INY
.1a148d	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a148f	85 12		sta $0812	            STA SCRATCH2+2
.1a1491	c2 20		rep #$20	            REP #$20
.1a1493	a5 0c		lda $080c	            LDA SCRATCH
.1a1495	c5 10		cmp $0810	            CMP SCRATCH2            ; Is CURRHEADER->END = CURRHEADER->NEXT?
.1a1497	d0 08		bne $1a14a1	            BNE go_next             ; No: go to the next block
.1a1499	e2 20		sep #$20	            SEP #$20
.1a149b	a5 0e		lda $080e	            LDA SCRATCH+2
.1a149d	c5 12		cmp $0812	            CMP SCRATCH2+2
.1a149f	f0 1f		beq $1a14c0	            BEQ combine             ; Yes: combine the two blocks
.1a14a1					go_next
.1a14a1	c2 20		rep #$20	            REP #$20
.1a14a3	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a14a6	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a14a8	85 0c		sta $080c	            STA SCRATCH
.1a14aa	e2 20		sep #$20	            SEP #$20
.1a14ac	c8		iny		            INY
.1a14ad	c8		iny		            INY
.1a14ae	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a14b0	85 0e		sta $080e	            STA SCRATCH+2
.1a14b2	c2 20		rep #$20	            REP #$20
.1a14b4	a5 0c		lda $080c	            LDA SCRATCH
.1a14b6	85 c3		sta $08c3	            STA CURRHEADER
.1a14b8	e2 20		sep #$20	            SEP #$20
.1a14ba	a5 0e		lda $080e	            LDA SCRATCH+2
.1a14bc	85 c5		sta $08c5	            STA CURRHEADER+2
.1a14be	80 a0		bra $1a1460	            BRA next_head                               ; And loop back to next_head
.1a14c0					combine
.1a14c0	c2 20		rep #$20	            REP #$20
.1a14c2	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a14c5	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a14c7	85 0c		sta $080c	            STA SCRATCH
.1a14c9	e2 20		sep #$20	            SEP #$20
.1a14cb	c8		iny		            INY
.1a14cc	c8		iny		            INY
.1a14cd	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a14cf	85 0e		sta $080e	            STA SCRATCH+2
.1a14d1	c2 20		rep #$20	            REP #$20
.1a14d3	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := SCRATCH->NEXT
.1a14d6	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a14d8	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a14da	e2 20		sep #$20	            SEP #$20
.1a14dc	c8		iny		            INY
.1a14dd	c8		iny		            INY
.1a14de	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a14e0	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a14e2	c2 20		rep #$20	            REP #$20
.1a14e4	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END       ; CURRHEADER->END := SCRATCH->END
.1a14e7	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a14e9	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a14eb	e2 20		sep #$20	            SEP #$20
.1a14ed	c8		iny		            INY
.1a14ee	c8		iny		            INY
.1a14ef	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a14f1	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a14f3	4c 6f 14	jmp $1a146f	            JMP check_next          ; And loop back to check_next
.1a14f6	28		plp		done        PLP
.1a14f7	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\strings.s

.1a14f8					CLRTMPSTR
.1a14f8	08		php		            PHP
.1a14f9	c2 20		rep #$20	            REP #$20
.1a14fb	64 16		stz $0816	            STZ STRPTR
.1a14fd	64 18		stz $0818	            STZ STRPTR+2
.1a14ff	28		plp		            PLP
.1a1500	60		rts		            RTS
.1a1501					TEMPSTRING
.1a1501	08		php		            PHP
.1a1502	c2 30		rep #$30	            REP #$30
.1a1504	a5 16		lda $0816	            LDA STRPTR          ; Is STRPTR == 0?
.1a1506	d0 16		bne $1a151e	            BNE add_256         ; No: add 256 to it
.1a1508	a5 18		lda $0818	            LDA STRPTR+2
.1a150a	d0 12		bne $1a151e	            BNE add_256
.1a150c	e2 20		sep #$20	            SEP #$20
.1a150e	64 16		stz $0816	            STZ STRPTR
.1a1510	a5 e2		lda $08e2	            LDA NEXTVAR+1
.1a1512	1a		inc a		            INC A
.1a1513	1a		inc a		            INC A
.1a1514	85 17		sta $0817	            STA STRPTR+1
.1a1516	a5 e3		lda $08e3	            LDA NEXTVAR+2
.1a1518	85 18		sta $0818	            STA STRPTR+2
.1a151a	64 19		stz $0819	            STZ STRPTR+3
.1a151c	80 07		bra $1a1525	            BRA chk_room
.1a151e					add_256
.1a151e	c2 20		rep #$20	            REP #$20
.1a1520	a5 17		lda $0817	            LDA STRPTR+1        ; There was already a temporary string...
.1a1522	1a		inc a		            INC A               ; Leave 256 bytes for it
.1a1523	85 17		sta $0817	            STA STRPTR+1
.1a1525					chk_room
.1a1525	c2 20		rep #$20	            REP #$20
.1a1527	a5 bb		lda $08bb	            LDA HEAP+1          ; Check to make sure that STRPTR and HEAP haven't touched
.1a1529	3a		dec a		            DEC A
.1a152a	c5 17		cmp $0817	            CMP STRPTR+1
.1a152c	f0 02		beq $1a1530	            BEQ no_room         ; If they have, throw an error
.1a152e	b0 1f		bcs $1a154f	            BGE done
.1a1530					no_room
.1a1530	08		php		            PHP
.1a1531	c2 20		rep #$20	            REP #$20
.1a1533	48		pha		            PHA
.1a1534	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1537	5b		tcd		            TCD
.1a1538	68		pla		            PLA
.1a1539	28		plp		            PLP
.1a153a	e2 20		sep #$20	            SEP #$20
.1a153c	a9 03		lda #$03	            LDA #ERR_MEMORY
.1a153e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1542	c2 20		rep #$20	            REP #$20
.1a1544	29 ff 00	and #$00ff	            AND #$00FF
.1a1547	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a154a	e2 20		sep #$20	            SEP #$20
.1a154c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a154f	28		plp		done        PLP
.1a1550	60		rts		            RTS
.1a1551					ITOS_DIGIT
.1a1551	c9 00		cmp #$00	            CMP #0          ; Is it 0?
.1a1553	d0 05		bne $1a155a	            BNE add_digit   ; No: go ahead and add it
.1a1555	c0 01 00	cpy #$0001	            CPY #1          ; Are we on the first digit?
.1a1558	f0 05		beq $1a155f	            BEQ done        ; Yes: ignore this leading 0
.1a155a	09 30		ora #$30	add_digit   ORA #$30        ; Convert it to ASCII
.1a155c	97 16		sta [$0816],y	            STA [STRPTR],Y  ; Save it to the string
.1a155e	c8		iny		            INY             ; And point to the next location
.1a155f					done
.1a155f	60		rts		            RTS
.1a1560					ITOS
.1a1560	08		php		            PHP
.1a1561	c2 30		rep #$30	            REP #$30
.1a1563	64 0c		stz $080c	            STZ SCRATCH         ; Use scratch to store if negative
.1a1565	a5 25		lda $0825	            LDA ARGUMENT1+2     ; Check to see if the number is negative
.1a1567	10 1a		bpl $1a1583	            BPL start_cnvt
.1a1569	18		clc		            CLC                 ; Yes: make ARGUMENT1 positive
.1a156a	a5 23		lda $0823	            LDA ARGUMENT1
.1a156c	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a156f	69 01 00	adc #$0001	            ADC #1
.1a1572	85 23		sta $0823	            STA ARGUMENT1
.1a1574	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a1576	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a1579	69 00 00	adc #$0000	            ADC #0
.1a157c	85 25		sta $0825	            STA ARGUMENT1+2
.1a157e	a9 ff ff	lda #$ffff	            LDA #$FFFF          ; Record that the number was negative
.1a1581	85 0c		sta $080c	            STA SCRATCH
.1a1583					start_cnvt
.1a1583	64 10		stz $0810	            STZ SCRATCH2        ; SCRATCH2 will be our BCD version of the number
.1a1585	64 12		stz $0812	            STZ SCRATCH2+2
.1a1587	64 14		stz $0814	            STZ SCRATCH2+4
.1a1589	a2 1f 00	ldx #$001f	            LDX #31
.1a158c	f8		sed		            SED                 ; Yes, we're really using BCD mode
.1a158d	06 23		asl $0823	shift_loop  ASL ARGUMENT1       ; Shift ARGUMENT1 left one bit
.1a158f	26 25		rol $0825	            ROL ARGUMENT1+2
.1a1591	a5 10		lda $0810	            LDA SCRATCH2        ; SCRATCH2 := SCRATCH2 + SCRATCH2 + Carry
.1a1593	65 10		adc $0810	            ADC SCRATCH2
.1a1595	85 10		sta $0810	            STA SCRATCH2
.1a1597	a5 12		lda $0812	            LDA SCRATCH2+2
.1a1599	65 12		adc $0812	            ADC SCRATCH2+2
.1a159b	85 12		sta $0812	            STA SCRATCH2+2
.1a159d	a5 14		lda $0814	            LDA SCRATCH2+4
.1a159f	65 14		adc $0814	            ADC SCRATCH2+4
.1a15a1	85 14		sta $0814	            STA SCRATCH2+4
.1a15a3	ca		dex		            DEX
.1a15a4	10 e7		bpl $1a158d	            BPL shift_loop      ; Loop through all 32 bits of ARGUMENT1
.1a15a6	d8		cld		            CLD                 ; Switch back out of BCD mode
.1a15a7	e2 20		sep #$20	            SEP #$20
.1a15a9	20 01 15	jsr $1a1501	            JSR TEMPSTRING
.1a15ac	a0 00 00	ldy #$0000	            LDY #0              ; Y will be index into the temporary string
.1a15af	a5 0c		lda $080c	            LDA SCRATCH         ; Check to see if the number was negative
.1a15b1	f0 04		beq $1a15b7	            BEQ is_pos          ; No: write a leading space
.1a15b3	a9 2d		lda #$2d	            LDA #'-'            ; If negative, write the minus sign
.1a15b5	80 02		bra $1a15b9	            BRA wr_lead
.1a15b7	a9 20		lda #$20	is_pos      LDA #CHAR_SP        ; Write a leading space
.1a15b9	97 16		sta [$0816],y	wr_lead     STA [STRPTR],Y
.1a15bb	c8		iny		            INY
.1a15bc	a2 05 00	ldx #$0005	            LDX #5
.1a15bf	b5 10		lda $0810,x	ascii_loop  LDA SCRATCH2,X
.1a15c1	29 f0		and #$f0	            AND #$F0
.1a15c3	4a		lsr a		            LSR A
.1a15c4	4a		lsr a		            LSR A
.1a15c5	4a		lsr a		            LSR A
.1a15c6	4a		lsr a		            LSR A
.1a15c7	20 51 15	jsr $1a1551	            JSR ITOS_DIGIT
.1a15ca	b5 10		lda $0810,x	            LDA SCRATCH2,X
.1a15cc	29 0f		and #$0f	            AND #$0F
.1a15ce	20 51 15	jsr $1a1551	            JSR ITOS_DIGIT
.1a15d1	ca		dex		            DEX
.1a15d2	10 eb		bpl $1a15bf	            BPL ascii_loop
.1a15d4	c0 01 00	cpy #$0001	            CPY #1              ; Did we write anything?
.1a15d7	d0 0c		bne $1a15e5	            BNE null_term       ; Yes: add a NULL to terminate
.1a15d9	a9 20		lda #$20	            LDA #' '            ; No: write a " 0" to the string
.1a15db	87 16		sta [$0816]	            STA [STRPTR]
.1a15dd	a0 01 00	ldy #$0001	            LDY #1
.1a15e0	a9 30		lda #$30	            LDA #'0'
.1a15e2	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a15e4	c8		iny		            INY
.1a15e5	a9 00		lda #$00	null_term   LDA #0
.1a15e7	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And terminate the string
.1a15e9	28		plp		done        PLP
.1a15ea	60		rts		            RTS
.1a15eb	00		brk #		fault       BRK
.1a15ec	ea		nop		            NOP
.1a15ed					STRLEN
.1a15ed	08		php		            PHP
.1a15ee	e2 20		sep #$20	            SEP #$20
.1a15f0	c2 10		rep #$10	            REP #$10
.1a15f2	a0 00 00	ldy #$0000	            LDY #0
.1a15f5	bd 00 00	lda $1a0000,x	loop        LDA #0,B,X
.1a15f8	f0 04		beq $1a15fe	            BEQ done
.1a15fa	e8		inx		            INX
.1a15fb	c8		iny		            INY
.1a15fc	80 f7		bra $1a15f5	            BRA loop
.1a15fe	28		plp		done        PLP
.1a15ff	60		rts		            RTS
.1a1600					STRCMP
.1a1600	08		php		            PHP
.1a1601	0b		phd		            PHD
.1a1602	08		php		            PHP
.1a1603	c2 20		rep #$20	            REP #$20
.1a1605	48		pha		            PHA
.1a1606	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1609	5b		tcd		            TCD
.1a160a	68		pla		            PLA
.1a160b	28		plp		            PLP
.1a160c	e2 20		sep #$20	            SEP #$20
.1a160e	c2 10		rep #$10	            REP #$10
.1a1610	a0 00 00	ldy #$0000	            LDY #0
.1a1613	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Check if the character 1 is 0
.1a1615	d0 04		bne $1a161b	            BNE comp_mag            ; If not, check the magnitudes
.1a1617	b7 29		lda [$0829],y	            LDA [ARGUMENT2],Y       ; If so, check if the character 2 is 0
.1a1619	f0 25		beq $1a1640	            BEQ are_equal           ; If so, the strings are equal
.1a161b	b7 23		lda [$0823],y	comp_mag    LDA [ARGUMENT1],Y       ; Otherwise, get character 1 again
.1a161d	d7 29		cmp [$0829],y	            CMP [ARGUMENT2],Y       ; And compare it to character 2
.1a161f	90 12		bcc $1a1633	            BLT is_less             ; Check if character 1 < character 2
.1a1621	d0 03		bne $1a1626	            BNE is_greater          ; Check if character 1 > character 2
.1a1623	c8		iny		            INY                     ; Equal so far... so go to the next pair of characters
.1a1624	80 ed		bra $1a1613	            BRA loop
.1a1626					is_greater
.1a1626	c2 20		rep #$20	            REP #$20
.1a1628	a9 01 00	lda #$0001	            LDA #1                  ; So return 1
.1a162b	85 23		sta $0823	            STA ARGUMENT1
.1a162d	e2 20		sep #$20	            SEP #$20
.1a162f	64 25		stz $0825	            STZ ARGUMENT1+2
.1a1631	80 15		bra $1a1648	            BRA done
.1a1633					is_less
.1a1633	c2 20		rep #$20	            REP #$20
.1a1635	a9 ff ff	lda #$ffff	            LDA #$FFFF              ; So return -1
.1a1638	85 23		sta $0823	            STA ARGUMENT1
.1a163a	e2 20		sep #$20	            SEP #$20
.1a163c	85 25		sta $0825	            STA ARGUMENT1+2
.1a163e	80 08		bra $1a1648	            BRA done
.1a1640					are_equal
.1a1640	c2 20		rep #$20	            REP #$20
.1a1642	64 23		stz $0823	            STZ ARGUMENT1           ; So return 0
.1a1644	e2 20		sep #$20	            SEP #$20
.1a1646	64 25		stz $0825	            STZ ARGUMENT1+2
.1a1648					done
.1a1648	e2 20		sep #$20	            SEP #$20
.1a164a	a9 00		lda #$00	            LDA #TYPE_INTEGER
.1a164c	85 27		sta $0827	            STA ARGTYPE1
.1a164e	2b		pld		            PLD
.1a164f	28		plp		            PLP
.1a1650	60		rts		            RTS
.1a1651					STRCONCAT
.1a1651	08		php		            PHP
.1a1652	0b		phd		            PHD
.1a1653	8b		phb		            PHB
.1a1654	08		php		            PHP
.1a1655	c2 20		rep #$20	            REP #$20
.1a1657	48		pha		            PHA
.1a1658	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a165b	5b		tcd		            TCD
.1a165c	68		pla		            PLA
.1a165d	28		plp		            PLP
.1a165e	e2 20		sep #$20	            SEP #$20
.1a1660	c2 10		rep #$10	            REP #$10
.1a1662	08		php		            PHP
.1a1663	c2 20		rep #$20	            REP #$20
.1a1665	48		pha		            PHA
.1a1666	e2 20		sep #$20	            SEP #$20
.1a1668	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a166a	48		pha		            PHA
.1a166b	ab		plb		            PLB
.1a166c	c2 20		rep #$20	            REP #$20
.1a166e	68		pla		            PLA
.1a166f	28		plp		            PLP
.1a1670	a6 23		ldx $0823	            LDX ARGUMENT1
.1a1672	20 ed 15	jsr $1a15ed	            JSR STRLEN
.1a1675	84 0c		sty $080c	            STY SCRATCH
.1a1677	08		php		            PHP
.1a1678	c2 20		rep #$20	            REP #$20
.1a167a	48		pha		            PHA
.1a167b	e2 20		sep #$20	            SEP #$20
.1a167d	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a167f	48		pha		            PHA
.1a1680	ab		plb		            PLB
.1a1681	c2 20		rep #$20	            REP #$20
.1a1683	68		pla		            PLA
.1a1684	28		plp		            PLP
.1a1685	a6 29		ldx $0829	            LDX ARGUMENT2
.1a1687	20 ed 15	jsr $1a15ed	            JSR STRLEN
.1a168a	c2 20		rep #$20	            REP #$20
.1a168c	98		tya		            TYA
.1a168d	38		sec		            SEC                     ; X := LEN(ARGUMENT1) + LEN(ARGUMENT2) + 1
.1a168e	65 0c		adc $080c	            ADC SCRATCH
.1a1690	aa		tax		            TAX
.1a1691	e2 20		sep #$20	            SEP #$20
.1a1693	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set type to STRING
.1a1695	20 d3 10	jsr $1a10d3	            JSR ALLOC
.1a1698	c2 20		rep #$20	            REP #$20
.1a169a	a5 b7		lda $08b7	            LDA ALLOCATED           ; INDEX := pointer to the string
.1a169c	85 08		sta $0808	            STA INDEX
.1a169e	e2 20		sep #$20	            SEP #$20
.1a16a0	a5 b9		lda $08b9	            LDA ALLOCATED+2
.1a16a2	85 0a		sta $080a	            STA INDEX+2
.1a16a4	a0 00 00	ldy #$0000	            LDY #0                  ; Set the target index to the beginning
.1a16a7	08		php		            PHP
.1a16a8	c2 20		rep #$20	            REP #$20
.1a16aa	48		pha		            PHA
.1a16ab	e2 20		sep #$20	            SEP #$20
.1a16ad	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a16af	48		pha		            PHA
.1a16b0	ab		plb		            PLB
.1a16b1	c2 20		rep #$20	            REP #$20
.1a16b3	68		pla		            PLA
.1a16b4	28		plp		            PLP
.1a16b5	a6 23		ldx $0823	            LDX ARGUMENT1
.1a16b7	bd 00 00	lda $1a0000,x	loop1       LDA #0,B,X              ; Get the Xth byte of ARGUMENT1
.1a16ba	f0 06		beq $1a16c2	            BEQ copy_2              ; Is it null? Yes: move on to the next string
.1a16bc	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.1a16be	e8		inx		            INX                     ; Point to the next characters
.1a16bf	c8		iny		            INY
.1a16c0	80 f5		bra $1a16b7	            BRA loop1               ; And do again
.1a16c2					copy_2
.1a16c2	e2 20		sep #$20	            SEP #$20
.1a16c4	08		php		            PHP
.1a16c5	c2 20		rep #$20	            REP #$20
.1a16c7	48		pha		            PHA
.1a16c8	e2 20		sep #$20	            SEP #$20
.1a16ca	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a16cc	48		pha		            PHA
.1a16cd	ab		plb		            PLB
.1a16ce	c2 20		rep #$20	            REP #$20
.1a16d0	68		pla		            PLA
.1a16d1	28		plp		            PLP
.1a16d2	a6 29		ldx $0829	            LDX ARGUMENT2
.1a16d4	bd 00 00	lda $1a0000,x	loop2       LDA #0,B,X              ; Get the Xth byte of ARGUMENT2
.1a16d7	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.1a16d9	f0 04		beq $1a16df	            BEQ terminate           ; Is it null? Yes: move on to the next string
.1a16db	e8		inx		            INX                     ; Point to the next characters
.1a16dc	c8		iny		            INY
.1a16dd	80 f5		bra $1a16d4	            BRA loop2               ; And do again
.1a16df					terminate
.1a16df	c2 20		rep #$20	            REP #$20
.1a16e1	a5 08		lda $0808	            LDA INDEX               ; Set ARGUMENT1 to the new string
.1a16e3	85 23		sta $0823	            STA ARGUMENT1
.1a16e5	e2 20		sep #$20	            SEP #$20
.1a16e7	a5 0a		lda $080a	            LDA INDEX+2
.1a16e9	85 25		sta $0825	            STA ARGUMENT1+2
.1a16eb	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set ARGUMENT1's type to STRING
.1a16ed	85 27		sta $0827	            STA ARGTYPE1
.1a16ef	ab		plb		            PLB
.1a16f0	2b		pld		            PLD
.1a16f1	28		plp		            PLP
.1a16f2	60		rts		            RTS
.1a16f3					STRCPY
.1a16f3	da		phx		            PHX
.1a16f4	5a		phy		            PHY
.1a16f5	08		php		            PHP
.1a16f6	0b		phd		            PHD
.1a16f7	8b		phb		            PHB
.1a16f8	08		php		            PHP
.1a16f9	c2 20		rep #$20	            REP #$20
.1a16fb	48		pha		            PHA
.1a16fc	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a16ff	5b		tcd		            TCD
.1a1700	68		pla		            PLA
.1a1701	28		plp		            PLP
.1a1702	c2 20		rep #$20	            REP #$20
.1a1704	a5 0a		lda $080a	            LDA INDEX+2
.1a1706	48		pha		            PHA
.1a1707	a5 08		lda $0808	            LDA INDEX
.1a1709	48		pha		            PHA
.1a170a	c2 30		rep #$30	            REP #$30
.1a170c	08		php		            PHP
.1a170d	c2 20		rep #$20	            REP #$20
.1a170f	48		pha		            PHA
.1a1710	e2 20		sep #$20	            SEP #$20
.1a1712	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a1714	48		pha		            PHA
.1a1715	ab		plb		            PLB
.1a1716	c2 20		rep #$20	            REP #$20
.1a1718	68		pla		            PLA
.1a1719	28		plp		            PLP
.1a171a	a6 23		ldx $0823	            LDX ARGUMENT1
.1a171c	20 ed 15	jsr $1a15ed	            JSR STRLEN
.1a171f	98		tya		            TYA
.1a1720	aa		tax		            TAX
.1a1721	e8		inx		            INX                     ; Put length of string (plus NUL) in X
.1a1722	e2 20		sep #$20	            SEP #$20
.1a1724	a9 02		lda #$02	            LDA #TYPE_STRING
.1a1726	20 d3 10	jsr $1a10d3	            JSR ALLOC
.1a1729	c2 20		rep #$20	            REP #$20
.1a172b	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a172d	85 08		sta $0808	            STA INDEX
.1a172f	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a1731	85 0a		sta $080a	            STA INDEX+2
.1a1733	a0 00 00	ldy #$0000	            LDY #0
.1a1736	e2 20		sep #$20	            SEP #$20
.1a1738	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Copy the data to the allocated string
.1a173a	97 08		sta [$0808],y	            STA [INDEX],Y
.1a173c	f0 03		beq $1a1741	            BEQ ret_copy
.1a173e	c8		iny		            INY
.1a173f	80 f7		bra $1a1738	            BRA loop
.1a1741					ret_copy
.1a1741	c2 20		rep #$20	            REP #$20
.1a1743	a5 08		lda $0808	            LDA INDEX
.1a1745	85 23		sta $0823	            STA ARGUMENT1
.1a1747	a5 0a		lda $080a	            LDA INDEX+2
.1a1749	85 25		sta $0825	            STA ARGUMENT1+2
.1a174b	c2 20		rep #$20	            REP #$20
.1a174d	68		pla		            PLA
.1a174e	85 08		sta $0808	            STA INDEX
.1a1750	68		pla		            PLA
.1a1751	85 0a		sta $080a	            STA INDEX+2
.1a1753	ab		plb		            PLB
.1a1754	2b		pld		            PLD
.1a1755	28		plp		            PLP
.1a1756	7a		ply		            PLY
.1a1757	fa		plx		            PLX
.1a1758	60		rts		            RTS
.1a1759					STRSUBSTR
.1a1759	08		php		            PHP
.1a175a	e2 20		sep #$20	            SEP #$20
.1a175c	c2 10		rep #$10	            REP #$10
.1a175e	a0 00 00	ldy #$0000	            LDY #0
.1a1761	b7 23		lda [$0823],y	count_loop  LDA [ARGUMENT1],Y
.1a1763	f0 05		beq $1a176a	            BEQ counted
.1a1765	c8		iny		            INY
.1a1766	80 f9		bra $1a1761	            BRA count_loop
.1a1768	84 92		sty $0892	            STY MTEMP               ; MTEMP := length of the source string
.1a176a					counted
.1a176a	c2 30		rep #$30	            REP #$30
.1a176c	c4 29		cpy $0829	            CPY ARGUMENT2           ; length of string <= index?
.1a176e	90 13		bcc $1a1783	            BLT ret_empty           ; Yes: return empty string
.1a1770	f0 11		beq $1a1783	            BEQ ret_empty
.1a1772	a5 8f		lda $088f	            LDA MCOUNT              ; Is the desired count <= 0?
.1a1774	30 0d		bmi $1a1783	            BMI ret_empty
.1a1776	f0 0b		beq $1a1783	            BEQ ret_empty           ; Yes: return the empty string
.1a1778	c4 8f		cpy $088f	            CPY MCOUNT              ; Is the desired length < the length of the source?
.1a177a	b0 12		bcs $1a178e	            BGE do_slice            ; Yes: go ahead and get the substring
.1a177c	a5 29		lda $0829	            LDA ARGUMENT2           ; Is INDEX == 0?
.1a177e	d0 0e		bne $1a178e	            BNE do_slice            ; No: do a slice
.1a1780	4c d7 17	jmp $1a17d7	            JMP done                ; Yes: just return the source string
.1a1783					ret_empty
.1a1783	20 01 15	jsr $1a1501	            JSR TEMPSTRING
.1a1786	e2 20		sep #$20	            SEP #$20
.1a1788	a9 00		lda #$00	            LDA #0
.1a178a	87 16		sta [$0816]	            STA [STRPTR]
.1a178c	80 39		bra $1a17c7	            BRA finish_copy
.1a178e					do_slice
.1a178e	20 01 15	jsr $1a1501	            JSR TEMPSTRING
.1a1791	c2 30		rep #$30	            REP #$30
.1a1793	18		clc		            CLC                     ; ARGUMENT1 := ARGUMENT1 + index
.1a1794	a5 23		lda $0823	            LDA ARGUMENT1
.1a1796	65 29		adc $0829	            ADC ARGUMENT2
.1a1798	85 23		sta $0823	            STA ARGUMENT1
.1a179a	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a179c	69 00 00	adc #$0000	            ADC #0
.1a179f	85 25		sta $0825	            STA ARGUMENT1+2
.1a17a1	a0 00 00	ldy #$0000	            LDY #0
.1a17a4					copy_loop
.1a17a4	e2 20		sep #$20	            SEP #$20
.1a17a6	a7 23		lda [$0823]	            LDA [ARGUMENT1]         ; Copy a character from the substring to the temporary string
.1a17a8	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a17aa	f0 1b		beq $1a17c7	            BEQ finish_copy         ; If it is a NULL, we're done
.1a17ac	c2 20		rep #$20	            REP #$20
.1a17ae	18		clc		            CLC                     ; Move to the next character
.1a17af	a5 23		lda $0823	            LDA ARGUMENT1
.1a17b1	69 01 00	adc #$0001	            ADC #1
.1a17b4	85 23		sta $0823	            STA ARGUMENT1
.1a17b6	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a17b8	69 00 00	adc #$0000	            ADC #0
.1a17bb	85 25		sta $0825	            STA ARGUMENT1+2
.1a17bd	c8		iny		            INY
.1a17be	c4 8f		cpy $088f	            CPY MCOUNT              ; Have we reached the limit to copy?
.1a17c0	d0 e2		bne $1a17a4	            BNE copy_loop           ; No: copy the next byte
.1a17c2	a9 00 00	lda #$0000	            LDA #0                  ; Null terminate string
.1a17c5	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a17c7					finish_copy
.1a17c7	c2 20		rep #$20	            REP #$20
.1a17c9	a5 16		lda $0816	            LDA STRPTR
.1a17cb	85 23		sta $0823	            STA ARGUMENT1
.1a17cd	a5 18		lda $0818	            LDA STRPTR+2
.1a17cf	85 25		sta $0825	            STA ARGUMENT1+2
.1a17d1	e2 20		sep #$20	            SEP #$20
.1a17d3	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a17d5	85 27		sta $0827	            STA ARGTYPE1
.1a17d7					done
.1a17d7	28		plp		            PLP
.1a17d8	60		rts		            RTS
.1a17d9					OP_STR_LT
.1a17d9	08		php		            PHP
.1a17da	c2 30		rep #$30	            REP #$30
.1a17dc	20 00 16	jsr $1a1600	            JSR STRCMP
.1a17df	a5 23		lda $0823	            LDA ARGUMENT1
.1a17e1	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.1a17e4	d0 05		bne $1a17eb	            BNE ret_false               ; No: return false
.1a17e6					ret_true
.1a17e6	20 2d 06	jsr $1a062d	            JSR SET_TRUE
.1a17e9	80 03		bra $1a17ee	            BRA done
.1a17eb					ret_false
.1a17eb	20 3f 06	jsr $1a063f	            JSR SET_FALSE
.1a17ee	28		plp		done        PLP
.1a17ef	60		rts		            RTS
.1a17f0					OP_STR_GT
.1a17f0	08		php		            PHP
.1a17f1	c2 30		rep #$30	            REP #$30
.1a17f3	20 00 16	jsr $1a1600	            JSR STRCMP
.1a17f6	a5 23		lda $0823	            LDA ARGUMENT1
.1a17f8	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.1a17fb	d0 05		bne $1a1802	            BNE ret_false               ; No: return false
.1a17fd					ret_true
.1a17fd	20 2d 06	jsr $1a062d	            JSR SET_TRUE
.1a1800	80 03		bra $1a1805	            BRA done
.1a1802					ret_false
.1a1802	20 3f 06	jsr $1a063f	            JSR SET_FALSE
.1a1805	28		plp		done        PLP
.1a1806	60		rts		            RTS
.1a1807					OP_STR_EQ
.1a1807	08		php		            PHP
.1a1808	c2 30		rep #$30	            REP #$30
.1a180a	20 00 16	jsr $1a1600	            JSR STRCMP
.1a180d	a5 23		lda $0823	            LDA ARGUMENT1
.1a180f	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.1a1812	d0 05		bne $1a1819	            BNE ret_false               ; No: return false
.1a1814					ret_true
.1a1814	20 2d 06	jsr $1a062d	            JSR SET_TRUE
.1a1817	80 03		bra $1a181c	            BRA done
.1a1819					ret_false
.1a1819	20 3f 06	jsr $1a063f	            JSR SET_FALSE
.1a181c	28		plp		done        PLP
.1a181d	60		rts		            RTS
.1a181e					OP_STR_NE
.1a181e	08		php		            PHP
.1a181f	c2 30		rep #$30	            REP #$30
.1a1821	20 00 16	jsr $1a1600	            JSR STRCMP
.1a1824	a5 23		lda $0823	            LDA ARGUMENT1
.1a1826	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.1a1829	f0 05		beq $1a1830	            BEQ ret_false               ; Yes: return false
.1a182b					ret_true
.1a182b	20 2d 06	jsr $1a062d	            JSR SET_TRUE
.1a182e	80 03		bra $1a1833	            BRA done
.1a1830					ret_false
.1a1830	20 3f 06	jsr $1a063f	            JSR SET_FALSE
.1a1833	28		plp		done        PLP
.1a1834	60		rts		            RTS
.1a1835					OP_STR_GTE
.1a1835	08		php		            PHP
.1a1836	c2 30		rep #$30	            REP #$30
.1a1838	20 00 16	jsr $1a1600	            JSR STRCMP
.1a183b	a5 23		lda $0823	            LDA ARGUMENT1
.1a183d	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.1a1840	f0 05		beq $1a1847	            BEQ ret_false               ; Yes: return false
.1a1842					ret_true
.1a1842	20 2d 06	jsr $1a062d	            JSR SET_TRUE
.1a1845	80 03		bra $1a184a	            BRA done
.1a1847					ret_false
.1a1847	20 3f 06	jsr $1a063f	            JSR SET_FALSE
.1a184a	28		plp		done        PLP
.1a184b	60		rts		            RTS
.1a184c					OP_STR_LTE
.1a184c	08		php		            PHP
.1a184d	c2 30		rep #$30	            REP #$30
.1a184f	20 00 16	jsr $1a1600	            JSR STRCMP
.1a1852	a5 23		lda $0823	            LDA ARGUMENT1
.1a1854	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.1a1857	f0 05		beq $1a185e	            BEQ ret_false               ; Yes: return false
.1a1859					ret_true
.1a1859	20 2d 06	jsr $1a062d	            JSR SET_TRUE
.1a185c	80 03		bra $1a1861	            BRA done
.1a185e					ret_false
.1a185e	20 3f 06	jsr $1a063f	            JSR SET_FALSE
.1a1861	28		plp		done        PLP
.1a1862	60		rts		            RTS
.1a1863					STR_NORMAL
.1a1863	08		php		            PHP
.1a1864	e2 20		sep #$20	            SEP #$20
.1a1866	a5 27		lda $0827	            LDA ARGTYPE1            ; Is it a string?
.1a1868	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a186a	d0 1d		bne $1a1889	            BNE done                ; No: return it
.1a186c	a5 23		lda $0823	            LDA ARGUMENT1           ; Is it a null pointer?
.1a186e	d0 19		bne $1a1889	            BNE done
.1a1870	a5 24		lda $0824	            LDA ARGUMENT1+1
.1a1872	d0 15		bne $1a1889	            BNE done
.1a1874	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a1876	d0 11		bne $1a1889	            BNE done                ; No: return it
.1a1878	20 01 15	jsr $1a1501	            JSR TEMPSTRING
.1a187b	a9 00		lda #$00	            LDA #0
.1a187d	87 16		sta [$0816]	            STA [STRPTR]            ; Make it empty
.1a187f	c2 20		rep #$20	            REP #$20
.1a1881	a5 16		lda $0816	            LDA STRPTR
.1a1883	85 23		sta $0823	            STA ARGUMENT1
.1a1885	a5 18		lda $0818	            LDA STRPTR+2
.1a1887	85 25		sta $0825	            STA ARGUMENT1+2
.1a1889	28		plp		done        PLP
.1a188a	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\listing.s

.1a188b					LISTPROG
.1a188b	48		pha		            PHA
.1a188c	5a		phy		            PHY
.1a188d	0b		phd		            PHD
.1a188e	08		php		            PHP
.1a188f	08		php		            PHP
.1a1890	c2 20		rep #$20	            REP #$20
.1a1892	48		pha		            PHA
.1a1893	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1896	5b		tcd		            TCD
.1a1897	68		pla		            PLA
.1a1898	28		plp		            PLP
.1a1899	c2 30		rep #$30	            REP #$30
.1a189b	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.1a189e	85 00		sta $0800	            STA BIP
.1a18a0	85 1a		sta $081a	            STA CURLINE
.1a18a2	a9 16 00	lda #$0016	            LDA #`BASIC_BOT
.1a18a5	85 02		sta $0802	            STA BIP+2
.1a18a7	85 1c		sta $081c	            STA CURLINE+2
.1a18a9	22 3c 11 00	jsl $00113c	list_loop   JSL FK_TESTBREAK
.1a18ad	b0 20		bcs $1a18cf	            BCS throw_break     ; If C: user pressed an interrupt key, stop the listing
.1a18af	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.1a18b2	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.1a18b4	f0 0f		beq $1a18c5	            BEQ done
.1a18b6	c5 55		cmp $0855	            CMP MARG1
.1a18b8	90 10		bcc $1a18ca	            BLT skip_line
.1a18ba	c5 59		cmp $0859	            CMP MARG2
.1a18bc	f0 02		beq $1a18c0	            BEQ print_line
.1a18be	b0 05		bcs $1a18c5	            BGE done
.1a18c0					print_line
.1a18c0	20 ee 18	jsr $1a18ee	            JSR LISTLINE
.1a18c3	80 e4		bra $1a18a9	            BRA list_loop
.1a18c5	28		plp		done        PLP
.1a18c6	2b		pld		            PLD
.1a18c7	7a		ply		            PLY
.1a18c8	68		pla		            PLA
.1a18c9	60		rts		            RTS
.1a18ca					skip_line
.1a18ca	20 fa 21	jsr $1a21fa	            JSR NEXTLINE
.1a18cd	80 da		bra $1a18a9	            BRA list_loop           ; And try again
.1a18cf					throw_break
.1a18cf	08		php		            PHP
.1a18d0	c2 20		rep #$20	            REP #$20
.1a18d2	48		pha		            PHA
.1a18d3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a18d6	5b		tcd		            TCD
.1a18d7	68		pla		            PLA
.1a18d8	28		plp		            PLP
.1a18d9	e2 20		sep #$20	            SEP #$20
.1a18db	a9 01		lda #$01	            LDA #ERR_BREAK
.1a18dd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a18e1	c2 20		rep #$20	            REP #$20
.1a18e3	29 ff 00	and #$00ff	            AND #$00FF
.1a18e6	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a18e9	e2 20		sep #$20	            SEP #$20
.1a18eb	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a18ee					LISTLINE
.1a18ee	08		php		            PHP
.1a18ef	c2 30		rep #$30	            REP #$30
.1a18f1	85 23		sta $0823	            STA ARGUMENT1
.1a18f3	64 25		stz $0825	            STZ ARGUMENT1+2
.1a18f5	20 60 15	jsr $1a1560	            JSR ITOS
.1a18f8	a5 16		lda $0816	            LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.1a18fa	1a		inc a		            INC A
.1a18fb	85 23		sta $0823	            STA ARGUMENT1
.1a18fd	a5 18		lda $0818	            LDA STRPTR+2
.1a18ff	85 25		sta $0825	            STA ARGUMENT1+2
.1a1901	20 00 46	jsr $1a4600	            JSR PR_STRING
.1a1904	18		clc		            CLC                 ; Move the BIP to the first byte of the line
.1a1905	a5 1a		lda $081a	            LDA CURLINE
.1a1907	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a190a	85 00		sta $0800	            STA BIP
.1a190c	a5 1c		lda $081c	            LDA CURLINE+2
.1a190e	69 00 00	adc #$0000	            ADC #0
.1a1911	85 02		sta $0802	            STA BIP+2
.1a1913	e2 20		sep #$20	            SEP #$20
.1a1915	a9 20		lda #$20	            LDA #CHAR_SP
.1a1917	20 18 00	jsr $1a0018	            JSR PRINTC
.1a191a	c2 20		rep #$20	            REP #$20
.1a191c					loop
.1a191c	20 2d 19	jsr $1a192d	            JSR LISTBYTE
.1a191f	90 fb		bcc $1a191c	            BCC loop
.1a1921	e2 20		sep #$20	            SEP #$20
.1a1923	a9 0d		lda #$0d	            LDA #CHAR_CR
.1a1925	20 18 00	jsr $1a0018	            JSR PRINTC
.1a1928	20 fa 21	jsr $1a21fa	            JSR NEXTLINE
.1a192b	28		plp		            PLP
.1a192c	60		rts		            RTS
.1a192d					LISTBYTE
.1a192d	08		php		            PHP
.1a192e	0b		phd		            PHD
.1a192f	8b		phb		            PHB
.1a1930	08		php		            PHP
.1a1931	c2 20		rep #$20	            REP #$20
.1a1933	48		pha		            PHA
.1a1934	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1937	5b		tcd		            TCD
.1a1938	68		pla		            PLA
.1a1939	28		plp		            PLP
.1a193a	08		php		            PHP
.1a193b	e2 20		sep #$20	            SEP #$20
.1a193d	48		pha		            PHA
.1a193e	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1940	48		pha		            PHA
.1a1941	ab		plb		            PLB
.1a1942	68		pla		            PLA
.1a1943	28		plp		            PLP
.1a1944	e2 20		sep #$20	            SEP #$20
.1a1946	c2 10		rep #$10	            REP #$10
.1a1948	a7 00		lda [$0800]	            LDA [BIP]           ; Get the current byte
.1a194a	f0 3a		beq $1a1986	            BEQ end_of_line     ; If it's 0, return with C set
.1a194c	30 05		bmi $1a1953	            BMI is_token        ; If it's 0x80 - 0xFF, it's a token
.1a194e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a1951	80 29		bra $1a197c	            BRA done            ; And return
.1a1953					is_token
.1a1953	c2 20		rep #$20	            REP #$20
.1a1955	29 7f 00	and #$007f	            AND #$007F          ; Compute the index of the token
.1a1958	0a		asl a		            ASL A               ; In the token table
.1a1959	0a		asl a		            ASL A
.1a195a	0a		asl a		            ASL A
.1a195b	18		clc		            CLC
.1a195c	69 fb 0c	adc #$0cfb	            ADC #<>TOKENS       ; Set INDEX to the address of the token
.1a195f	85 08		sta $0808	            STA INDEX
.1a1961	a9 1a 00	lda #$001a	            LDA #`TOKENS
.1a1964	69 00 00	adc #$0000	            ADC #0
.1a1967	85 0a		sta $080a	            STA INDEX+2
.1a1969					pr_default
.1a1969	08		php		            PHP
.1a196a	e2 20		sep #$20	            SEP #$20
.1a196c	48		pha		            PHA
.1a196d	a9 1a		lda #$1a	            LDA #`TOKENS
.1a196f	48		pha		            PHA
.1a1970	ab		plb		            PLB
.1a1971	68		pla		            PLA
.1a1972	28		plp		            PLP
.1a1973	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.1a1976	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a1978	aa		tax		            TAX
.1a1979	20 64 04	jsr $1a0464	            JSR PRINTS
.1a197c					done
.1a197c	c2 20		rep #$20	            REP #$20
.1a197e	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a1981	ab		plb		            PLB
.1a1982	2b		pld		            PLD
.1a1983	28		plp		            PLP
.1a1984	18		clc		            CLC
.1a1985	60		rts		            RTS
.1a1986	ab		plb		end_of_line PLB
.1a1987	2b		pld		            PLD
.1a1988	28		plp		            PLP
.1a1989	38		sec		            SEC
.1a198a	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\eval.s

.1a198b					INITEVALSP
.1a198b	08		php		            PHP
.1a198c	c2 20		rep #$20	            REP #$20
.1a198e	a9 ff 6f	lda #$6fff	            LDA #ARGUMENT_TOP
.1a1991	85 1f		sta $081f	            STA ARGUMENTSP
.1a1993	a9 ff 7f	lda #$7fff	            LDA #OPERATOR_TOP
.1a1996	85 21		sta $0821	            STA OPERATORSP
.1a1998	a9 ff ff	lda #$ffff	            LDA #$FFFF
.1a199b	85 23		sta $0823	            STA ARGUMENT1
.1a199d	85 25		sta $0825	            STA ARGUMENT1+2
.1a199f	85 29		sta $0829	            STA ARGUMENT2
.1a19a1	85 2b		sta $082b	            STA ARGUMENT2+2
.1a19a3	e2 20		sep #$20	            SEP #$20
.1a19a5	85 27		sta $0827	            STA ARGTYPE1
.1a19a7	85 2d		sta $082d	            STA ARGTYPE2
.1a19a9	28		plp		            PLP
.1a19aa	60		rts		            RTS
.1a19ab					PHARGUMENT
.1a19ab	08		php		            PHP
.1a19ac	0b		phd		            PHD
.1a19ad	8b		phb		            PHB
.1a19ae	08		php		            PHP
.1a19af	c2 20		rep #$20	            REP #$20
.1a19b1	48		pha		            PHA
.1a19b2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a19b5	5b		tcd		            TCD
.1a19b6	68		pla		            PLA
.1a19b7	28		plp		            PLP
.1a19b8	08		php		            PHP
.1a19b9	e2 20		sep #$20	            SEP #$20
.1a19bb	48		pha		            PHA
.1a19bc	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a19be	48		pha		            PHA
.1a19bf	ab		plb		            PLB
.1a19c0	68		pla		            PLA
.1a19c1	28		plp		            PLP
.1a19c2	c2 30		rep #$30	            REP #$30
.1a19c4	5a		phy		            PHY
.1a19c5	a4 1f		ldy $081f	            LDY ARGUMENTSP
.1a19c7	bd 00 00	lda $0000,x	            LDA #0,B,X
.1a19ca	99 00 00	sta $0000,y	            STA #0,B,Y
.1a19cd	bd 02 00	lda $0002,x	            LDA #2,B,X
.1a19d0	99 02 00	sta $0002,y	            STA #2,B,Y
.1a19d3	e2 20		sep #$20	            SEP #$20
.1a19d5	bd 04 00	lda $0004,x	            LDA #4,B,X
.1a19d8	99 04 00	sta $0004,y	            STA #4,B,Y
.1a19db	c2 20		rep #$20	            REP #$20
.1a19dd	38		sec		            SEC
.1a19de	98		tya		            TYA
.1a19df	e9 05 00	sbc #$0005	            SBC #ARGUMENT_SIZE
.1a19e2	85 1f		sta $081f	            STA ARGUMENTSP
.1a19e4	7a		ply		            PLY
.1a19e5	ab		plb		            PLB
.1a19e6	2b		pld		            PLD
.1a19e7	28		plp		            PLP
.1a19e8	60		rts		            RTS
.1a19e9					PLARGUMENT
.1a19e9	08		php		            PHP
.1a19ea	0b		phd		            PHD
.1a19eb	8b		phb		            PHB
.1a19ec	08		php		            PHP
.1a19ed	c2 20		rep #$20	            REP #$20
.1a19ef	48		pha		            PHA
.1a19f0	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a19f3	5b		tcd		            TCD
.1a19f4	68		pla		            PLA
.1a19f5	28		plp		            PLP
.1a19f6	08		php		            PHP
.1a19f7	e2 20		sep #$20	            SEP #$20
.1a19f9	48		pha		            PHA
.1a19fa	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a19fc	48		pha		            PHA
.1a19fd	ab		plb		            PLB
.1a19fe	68		pla		            PLA
.1a19ff	28		plp		            PLP
.1a1a00	c2 30		rep #$30	            REP #$30
.1a1a02	5a		phy		            PHY
.1a1a03	18		clc		            CLC
.1a1a04	a5 1f		lda $081f	            LDA ARGUMENTSP
.1a1a06	69 05 00	adc #$0005	            ADC #ARGUMENT_SIZE
.1a1a09	85 1f		sta $081f	            STA ARGUMENTSP
.1a1a0b	a8		tay		            TAY
.1a1a0c	b9 00 00	lda $0000,y	            LDA #0,B,Y
.1a1a0f	9d 00 00	sta $0000,x	            STA #0,B,X
.1a1a12	b9 02 00	lda $0002,y	            LDA #2,B,Y
.1a1a15	9d 02 00	sta $0002,x	            STA #2,B,X
.1a1a18	e2 20		sep #$20	            SEP #$20
.1a1a1a	b9 04 00	lda $0004,y	            LDA #4,B,Y
.1a1a1d	9d 04 00	sta $0004,x	            STA #4,B,X
.1a1a20	bd 00 00	lda $0000,x	            LDA #0,B,X
.1a1a23	7a		ply		            PLY
.1a1a24	ab		plb		            PLB
.1a1a25	2b		pld		            PLD
.1a1a26	28		plp		            PLP
.1a1a27	60		rts		            RTS
.1a1a28					PHOPERATOR
.1a1a28	08		php		            PHP
.1a1a29	0b		phd		            PHD
.1a1a2a	8b		phb		            PHB
.1a1a2b	08		php		            PHP
.1a1a2c	c2 20		rep #$20	            REP #$20
.1a1a2e	48		pha		            PHA
.1a1a2f	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1a32	5b		tcd		            TCD
.1a1a33	68		pla		            PLA
.1a1a34	28		plp		            PLP
.1a1a35	08		php		            PHP
.1a1a36	e2 20		sep #$20	            SEP #$20
.1a1a38	48		pha		            PHA
.1a1a39	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1a3b	48		pha		            PHA
.1a1a3c	ab		plb		            PLB
.1a1a3d	68		pla		            PLA
.1a1a3e	28		plp		            PLP
.1a1a3f	e2 20		sep #$20	            SEP #$20
.1a1a41	c2 10		rep #$10	            REP #$10
.1a1a43	5a		phy		            PHY
.1a1a44	a4 21		ldy $0821	            LDY OPERATORSP
.1a1a46	99 00 00	sta $0000,y	            STA #0,B,Y
.1a1a49	88		dey		            DEY
.1a1a4a	84 21		sty $0821	            STY OPERATORSP
.1a1a4c	7a		ply		done        PLY
.1a1a4d	ab		plb		            PLB
.1a1a4e	2b		pld		            PLD
.1a1a4f	28		plp		            PLP
.1a1a50	60		rts		            RTS
.1a1a51					PLOPERATOR
.1a1a51	08		php		            PHP
.1a1a52	0b		phd		            PHD
.1a1a53	8b		phb		            PHB
.1a1a54	08		php		            PHP
.1a1a55	c2 20		rep #$20	            REP #$20
.1a1a57	48		pha		            PHA
.1a1a58	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1a5b	5b		tcd		            TCD
.1a1a5c	68		pla		            PLA
.1a1a5d	28		plp		            PLP
.1a1a5e	08		php		            PHP
.1a1a5f	e2 20		sep #$20	            SEP #$20
.1a1a61	48		pha		            PHA
.1a1a62	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1a64	48		pha		            PHA
.1a1a65	ab		plb		            PLB
.1a1a66	68		pla		            PLA
.1a1a67	28		plp		            PLP
.1a1a68	e2 20		sep #$20	            SEP #$20
.1a1a6a	c2 10		rep #$10	            REP #$10
.1a1a6c	5a		phy		            PHY
.1a1a6d	a4 21		ldy $0821	            LDY OPERATORSP
.1a1a6f	c8		iny		            INY
.1a1a70	84 21		sty $0821	            STY OPERATORSP
.1a1a72	b9 00 00	lda $0000,y	            LDA #0,B,Y
.1a1a75	c2 20		rep #$20	            REP #$20
.1a1a77	29 ff 00	and #$00ff	            AND #$00FF
.1a1a7a	7a		ply		            PLY
.1a1a7b	ab		plb		            PLB
.1a1a7c	2b		pld		            PLD
.1a1a7d	28		plp		            PLP
.1a1a7e	60		rts		            RTS
.1a1a7f					OPENPARAMS
.1a1a7f	08		php		            PHP
.1a1a80	e2 20		sep #$20	            SEP #$20
.1a1a82	a9 01		lda #$01	            LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.1a1a84	20 28 1a	jsr $1a1a28	            JSR PHOPERATOR
.1a1a87	28		plp		            PLP
.1a1a88	60		rts		            RTS
.1a1a89					CLOSEPARAMS
.1a1a89	5a		phy		            PHY
.1a1a8a	08		php		            PHP
.1a1a8b	8b		phb		            PHB
.1a1a8c	08		php		            PHP
.1a1a8d	e2 20		sep #$20	            SEP #$20
.1a1a8f	48		pha		            PHA
.1a1a90	a9 00		lda #$00	            LDA #0
.1a1a92	48		pha		            PHA
.1a1a93	ab		plb		            PLB
.1a1a94	68		pla		            PLA
.1a1a95	28		plp		            PLP
.1a1a96	e2 20		sep #$20	            SEP #$20
.1a1a98	a4 21		ldy $0821	            LDY OPERATORSP      ; Peek at the top operator
.1a1a9a	b9 01 00	lda $0001,y	            LDA #1,B,Y
.1a1a9d	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the marker for the start of a parameter list
.1a1a9f	d0 08		bne $1a1aa9	            BNE error           ; No: there's a problem
.1a1aa1	c2 20		rep #$20	            REP #$20
.1a1aa3	e6 21		inc $0821	            INC OPERATORSP      ; Yes: remove it from the operator stack.
.1a1aa5	ab		plb		            PLB
.1a1aa6	28		plp		            PLP
.1a1aa7	7a		ply		            PLY
.1a1aa8	60		rts		            RTS
.1a1aa9					error
.1a1aa9	08		php		            PHP
.1a1aaa	c2 20		rep #$20	            REP #$20
.1a1aac	48		pha		            PHA
.1a1aad	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1ab0	5b		tcd		            TCD
.1a1ab1	68		pla		            PLA
.1a1ab2	28		plp		            PLP
.1a1ab3	e2 20		sep #$20	            SEP #$20
.1a1ab5	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1ab7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1abb	c2 20		rep #$20	            REP #$20
.1a1abd	29 ff 00	and #$00ff	            AND #$00FF
.1a1ac0	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a1ac3	e2 20		sep #$20	            SEP #$20
.1a1ac5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1ac8					OPHIGHPREC
.1a1ac8	48		pha		            PHA
.1a1ac9	08		php		            PHP
.1a1aca	0b		phd		            PHD
.1a1acb	8b		phb		            PHB
.1a1acc	08		php		            PHP
.1a1acd	c2 20		rep #$20	            REP #$20
.1a1acf	48		pha		            PHA
.1a1ad0	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1ad3	5b		tcd		            TCD
.1a1ad4	68		pla		            PLA
.1a1ad5	28		plp		            PLP
.1a1ad6	08		php		            PHP
.1a1ad7	e2 20		sep #$20	            SEP #$20
.1a1ad9	48		pha		            PHA
.1a1ada	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1adc	48		pha		            PHA
.1a1add	ab		plb		            PLB
.1a1ade	68		pla		            PLA
.1a1adf	28		plp		            PLP
.1a1ae0	e2 20		sep #$20	            SEP #$20
.1a1ae2	a4 21		ldy $0821	            LDY OPERATORSP
.1a1ae4	c0 ff 7f	cpy #$7fff	            CPY #OPERATOR_TOP       ; Is the stack empty?
.1a1ae7	f0 11		beq $1a1afa	            BEQ is_false            ; Yes: return false
.1a1ae9	20 5a 0c	jsr $1a0c5a	            JSR TOKPRECED
.1a1aec	85 0c		sta $080c	            STA SCRATCH             ; Save it for later comparison
.1a1aee	b9 01 00	lda $0001,y	            LDA #1,B,Y              ; Get the operator at the top of the stack
.1a1af1	20 5a 0c	jsr $1a0c5a	            JSR TOKPRECED
.1a1af4	c5 0c		cmp $080c	            CMP SCRATCH             ; Compare the priorities (0 = highest priority)
.1a1af6	f0 02		beq $1a1afa	            BEQ is_false            ; A = SCRATCH, return false
.1a1af8	90 08		bcc $1a1b02	            BCC is_true             ; A < SCRATCH (A is higher priority), return false
.1a1afa					is_false
.1a1afa	c2 20		rep #$20	            REP #$20
.1a1afc	ab		plb		            PLB
.1a1afd	2b		pld		            PLD
.1a1afe	28		plp		            PLP
.1a1aff	68		pla		            PLA
.1a1b00	18		clc		            CLC
.1a1b01	60		rts		            RTS
.1a1b02					is_true
.1a1b02	c2 20		rep #$20	            REP #$20
.1a1b04	ab		plb		            PLB                     ; A > SCRATCH (A is lower priority), return true
.1a1b05	2b		pld		            PLD
.1a1b06	28		plp		            PLP
.1a1b07	68		pla		            PLA
.1a1b08	38		sec		            SEC
.1a1b09	60		rts		            RTS
.1a1b0a					EVALNUMBER
.1a1b0a	4c d8 08	jmp $1a08d8	            JMP PARSEINT
.1a1b0d					ARR_GETIDX
.1a1b0d	08		php		            PHP
.1a1b0e	e2 20		sep #$20	            SEP #$20
.1a1b10	a9 00		lda #$00	            LDA #0
.1a1b12	8f 00 4d 00	sta $004d00	            STA @lARRIDXBUF     ; Set the dimension to 0
.1a1b16	a2 01 00	ldx #$0001	            LDX #1
.1a1b19					eval_index
.1a1b19	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a1b1c	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a1b1f	c2 20		rep #$20	            REP #$20
.1a1b21	a5 23		lda $0823	            LDA ARGUMENT1       ; Save the index to the array index buffer
.1a1b23	9f 00 4d 00	sta $004d00,x	            STA @l ARRIDXBUF,X
.1a1b27	e2 20		sep #$20	            SEP #$20
.1a1b29	af 00 4d 00	lda $004d00	            LDA @l ARRIDXBUF    ; Increment the index count
.1a1b2d	1a		inc a		            INC A
.1a1b2e	30 3e		bmi $1a1b6e	            BMI arg_err         ; If more than 127 dimensions, throw a range error
.1a1b30	8f 00 4d 00	sta $004d00	            STA @l ARRIDXBUF
.1a1b34	e8		inx		            INX
.1a1b35	e8		inx		            INX
.1a1b36	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a1b39	e2 20		sep #$20	            SEP #$20
.1a1b3b	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.1a1b3d	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it ")"
.1a1b3f	f0 09		beq $1a1b4a	            BEQ clean_op        ; Yes: cleanup the argument stack
.1a1b41	c9 2c		cmp #$2c	            CMP #','            ; Is it a comma?
.1a1b43	d0 0a		bne $1a1b4f	            BNE syntax_err      ; No: throw a syntax error
.1a1b45					skip_comma
.1a1b45	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a1b48	80 cf		bra $1a1b19	            BRA eval_index      ; And grab the next index
.1a1b4a					clean_op
.1a1b4a	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a1b4d	28		plp		            PLP
.1a1b4e	60		rts		            RTS
.1a1b4f					syntax_err
.1a1b4f	08		php		            PHP
.1a1b50	c2 20		rep #$20	            REP #$20
.1a1b52	48		pha		            PHA
.1a1b53	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1b56	5b		tcd		            TCD
.1a1b57	68		pla		            PLA
.1a1b58	28		plp		            PLP
.1a1b59	e2 20		sep #$20	            SEP #$20
.1a1b5b	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1b5d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1b61	c2 20		rep #$20	            REP #$20
.1a1b63	29 ff 00	and #$00ff	            AND #$00FF
.1a1b66	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a1b69	e2 20		sep #$20	            SEP #$20
.1a1b6b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1b6e					arg_err
.1a1b6e	08		php		            PHP
.1a1b6f	c2 20		rep #$20	            REP #$20
.1a1b71	48		pha		            PHA
.1a1b72	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1b75	5b		tcd		            TCD
.1a1b76	68		pla		            PLA
.1a1b77	28		plp		            PLP
.1a1b78	e2 20		sep #$20	            SEP #$20
.1a1b7a	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a1b7c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1b80	c2 20		rep #$20	            REP #$20
.1a1b82	29 ff 00	and #$00ff	            AND #$00FF
.1a1b85	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a1b88	e2 20		sep #$20	            SEP #$20
.1a1b8a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1b8d					EVALREF
.1a1b8d	08		php		            PHP
.1a1b8e					get_name
.1a1b8e	20 20 54	jsr $1a5420	            JSR VAR_FINDNAME
.1a1b91	90 47		bcc $1a1bda	            BCC syntax_err      ; If we didn't find a name, thrown an error
.1a1b93	e2 20		sep #$20	            SEP #$20
.1a1b95	a5 ea		lda $08ea	            LDA TOFINDTYPE      ; Check the type of the variable
.1a1b97	29 80		and #$80	            AND #$80            ; Is it an array?
.1a1b99	d0 06		bne $1a1ba1	            BNE is_array        ; Yes: look for the indexes
.1a1b9b	20 21 52	jsr $1a5221	            JSR VAR_REF
.1a1b9e	4c d8 1b	jmp $1a1bd8	            JMP done
.1a1ba1					is_array
.1a1ba1	20 93 51	jsr $1a5193	            JSR VAR_FIND
.1a1ba4	90 53		bcc $1a1bf9	            BCC notfound
.1a1ba6	c2 20		rep #$20	            REP #$20
.1a1ba8	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a1baa	48		pha		            PHA
.1a1bab	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a1bad	48		pha		            PHA
.1a1bae	a0 09 00	ldy #$0009	            LDY #BINDING.VALUE
.1a1bb1	b7 08		lda [$0808],y	            LDA [INDEX],Y       ; Save the pointer to the array to CURRBLOCK
.1a1bb3	85 c0		sta $08c0	            STA CURRBLOCK
.1a1bb5	e2 20		sep #$20	            SEP #$20
.1a1bb7	c8		iny		            INY
.1a1bb8	c8		iny		            INY
.1a1bb9	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a1bbb	85 c2		sta $08c2	            STA CURRBLOCK+2
.1a1bbd	e2 20		sep #$20	            SEP #$20
.1a1bbf	a9 8f		lda #$8f	            LDA #TOK_LPAREN
.1a1bc1	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a1bc4	20 7f 1a	jsr $1a1a7f	            JSR OPENPARAMS
.1a1bc7					            PHARRIDX
.1a1bc7	20 0d 1b	jsr $1a1b0d	            JSR ARR_GETIDX
.1a1bca	20 f7 68	jsr $1a68f7	            JSR ARR_REF
.1a1bcd					            PLARRIDX
.1a1bcd	20 89 1a	jsr $1a1a89	            JSR CLOSEPARAMS
.1a1bd0	c2 20		rep #$20	            REP #$20
.1a1bd2	68		pla		            PLA
.1a1bd3	85 c2		sta $08c2	            STA CURRBLOCK+2
.1a1bd5	68		pla		            PLA
.1a1bd6	85 c0		sta $08c0	            STA CURRBLOCK
.1a1bd8	28		plp		done        PLP
.1a1bd9	60		rts		            RTS
.1a1bda					syntax_err
.1a1bda	08		php		            PHP
.1a1bdb	c2 20		rep #$20	            REP #$20
.1a1bdd	48		pha		            PHA
.1a1bde	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1be1	5b		tcd		            TCD
.1a1be2	68		pla		            PLA
.1a1be3	28		plp		            PLP
.1a1be4	e2 20		sep #$20	            SEP #$20
.1a1be6	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1be8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1bec	c2 20		rep #$20	            REP #$20
.1a1bee	29 ff 00	and #$00ff	            AND #$00FF
.1a1bf1	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a1bf4	e2 20		sep #$20	            SEP #$20
.1a1bf6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1bf9					notfound
.1a1bf9	08		php		            PHP
.1a1bfa	c2 20		rep #$20	            REP #$20
.1a1bfc	48		pha		            PHA
.1a1bfd	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1c00	5b		tcd		            TCD
.1a1c01	68		pla		            PLA
.1a1c02	28		plp		            PLP
.1a1c03	e2 20		sep #$20	            SEP #$20
.1a1c05	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a1c07	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1c0b	c2 20		rep #$20	            REP #$20
.1a1c0d	29 ff 00	and #$00ff	            AND #$00FF
.1a1c10	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a1c13	e2 20		sep #$20	            SEP #$20
.1a1c15	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1c18					EVALSTRING
.1a1c18	08		php		            PHP
.1a1c19	0b		phd		            PHD
.1a1c1a	08		php		            PHP
.1a1c1b	c2 20		rep #$20	            REP #$20
.1a1c1d	48		pha		            PHA
.1a1c1e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1c21	5b		tcd		            TCD
.1a1c22	68		pla		            PLA
.1a1c23	28		plp		            PLP
.1a1c24	e2 20		sep #$20	            SEP #$20
.1a1c26	c2 10		rep #$10	            REP #$10
.1a1c28	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a1c2b	a0 00 00	ldy #$0000	            LDY #0              ; Ywill be our length counter
.1a1c2e	b7 00		lda [$0800],y	count_loop  LDA [BIP],Y         ; Get the character
.1a1c30	f0 24		beq $1a1c56	            BEQ error           ; If it's end-of-line, throw an error
.1a1c32	c9 22		cmp #$22	            CMP #CHAR_DQUOTE    ; Is it the ending double-quote?
.1a1c34	f0 03		beq $1a1c39	            BEQ found_end       ; Yes: Y should be the length
.1a1c36	c8		iny		            INY
.1a1c37	80 f5		bra $1a1c2e	            BRA count_loop
.1a1c39	84 0c		sty $080c	found_end   STY SCRATCH         ; Save the length to SCRATCH
.1a1c3b	e2 20		sep #$20	            SEP #$20
.1a1c3d	a9 02		lda #$02	            LDA #TYPE_STRING    ; Set the type to allocate to STRING
.1a1c3f	a6 0c		ldx $080c	            LDX SCRATCH         ; And the length to the length of the string literal
.1a1c41	e8		inx		            INX
.1a1c42	20 01 15	jsr $1a1501	            JSR TEMPSTRING
.1a1c45	a0 00 00	ldy #$0000	            LDY #0
.1a1c48	c4 0c		cpy $080c	copy_loop   CPY SCRATCH         ; Have we copied all the characters?
.1a1c4a	f0 29		beq $1a1c75	            BEQ done            ; Yes: we're done
.1a1c4c	a7 00		lda [$0800]	            LDA [BIP]           ; No: get the next character
.1a1c4e	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And copy it to the allocated string
.1a1c50	c8		iny		            INY
.1a1c51	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a1c54	80 f2		bra $1a1c48	            BRA copy_loop       ; And try the next character
.1a1c56					error
.1a1c56	08		php		            PHP
.1a1c57	c2 20		rep #$20	            REP #$20
.1a1c59	48		pha		            PHA
.1a1c5a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1c5d	5b		tcd		            TCD
.1a1c5e	68		pla		            PLA
.1a1c5f	28		plp		            PLP
.1a1c60	e2 20		sep #$20	            SEP #$20
.1a1c62	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1c64	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1c68	c2 20		rep #$20	            REP #$20
.1a1c6a	29 ff 00	and #$00ff	            AND #$00FF
.1a1c6d	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a1c70	e2 20		sep #$20	            SEP #$20
.1a1c72	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1c75	a9 00		lda #$00	done        LDA #0
.1a1c77	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a1c79	c2 20		rep #$20	            REP #$20
.1a1c7b	a5 16		lda $0816	            LDA STRPTR
.1a1c7d	85 23		sta $0823	            STA ARGUMENT1
.1a1c7f	a5 18		lda $0818	            LDA STRPTR+2
.1a1c81	85 25		sta $0825	            STA ARGUMENT1+2
.1a1c83	a9 02 00	lda #$0002	            LDA #TYPE_STRING    ; And set the type of ARGUMENT1 to string
.1a1c86	85 27		sta $0827	            STA ARGTYPE1
.1a1c88	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a1c8b	2b		pld		            PLD
.1a1c8c	28		plp		            PLP
.1a1c8d	60		rts		            RTS
.1a1c8e					EVAL_FUNC
.1a1c8e	08		php		            PHP
.1a1c8f	e2 20		sep #$20	            SEP #$20
.1a1c91	a7 00		lda [$0800]	            LDA [BIP]           ; Get the token
.1a1c93	c2 20		rep #$20	            REP #$20
.1a1c95	29 ff 00	and #$00ff	            AND #$00FF
.1a1c98	20 84 0c	jsr $1a0c84	            JSR TOKEVAL
.1a1c9b	85 2f		sta $082f	            STA JMP16PTR
.1a1c9d	20 7f 1a	jsr $1a1a7f	            JSR OPENPARAMS
.1a1ca0	08		php		            PHP
.1a1ca1	e2 20		sep #$20	            SEP #$20
.1a1ca3	48		pha		            PHA
.1a1ca4	a9 00		lda #$00	            LDA #0
.1a1ca6	48		pha		            PHA
.1a1ca7	ab		plb		            PLB
.1a1ca8	68		pla		            PLA
.1a1ca9	28		plp		            PLP
.1a1caa	20 b2 1c	jsr $1a1cb2	            JSR OPSTUB
.1a1cad	20 89 1a	jsr $1a1a89	            JSR CLOSEPARAMS
.1a1cb0	28		plp		            PLP
.1a1cb1	60		rts		            RTS
.1a1cb2					OPSTUB
.1a1cb2	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a1cb5	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.1a1cb8					PROCESSOP
.1a1cb8	48		pha		            PHA
.1a1cb9	08		php		            PHP
.1a1cba	0b		phd		            PHD
.1a1cbb	8b		phb		            PHB
.1a1cbc	08		php		            PHP
.1a1cbd	c2 20		rep #$20	            REP #$20
.1a1cbf	48		pha		            PHA
.1a1cc0	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1cc3	5b		tcd		            TCD
.1a1cc4	68		pla		            PLA
.1a1cc5	28		plp		            PLP
.1a1cc6	c2 30		rep #$30	            REP #$30
.1a1cc8	20 51 1a	jsr $1a1a51	            JSR PLOPERATOR
.1a1ccb	89 80 00	bit #$0080	            BIT #$80            ; Check if it's really a token
.1a1cce	f0 37		beq $1a1d07	            BEQ bad_token       ; No: it's a bad token
.1a1cd0	48		pha		            PHA
.1a1cd1	20 84 0c	jsr $1a0c84	            JSR TOKEVAL
.1a1cd4	85 2f		sta $082f	            STA JMP16PTR
.1a1cd6	68		pla		            PLA
.1a1cd7	20 d1 0c	jsr $1a0cd1	            JSR TOKARITY
.1a1cda	c9 01 00	cmp #$0001	            CMP #1              ; Check the operator's arity
.1a1cdd	f0 08		beq $1a1ce7	            BEQ pull_arg1       ; If it's 1 just pull one argument from the stack
.1a1cdf	c2 30		rep #$30	            REP #$30
.1a1ce1	a2 29 08	ldx #$0829	            LDX #<>ARGUMENT2    ; Pull argument 2 from the stack
.1a1ce4	20 e9 19	jsr $1a19e9	            JSR PLARGUMENT
.1a1ce7					pull_arg1
.1a1ce7	c2 30		rep #$30	            REP #$30
.1a1ce9	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Pull argument 1 from the stack
.1a1cec	20 e9 19	jsr $1a19e9	            JSR PLARGUMENT
.1a1cef	08		php		            PHP
.1a1cf0	e2 20		sep #$20	            SEP #$20
.1a1cf2	48		pha		            PHA
.1a1cf3	a9 00		lda #$00	            LDA #0
.1a1cf5	48		pha		            PHA
.1a1cf6	ab		plb		            PLB
.1a1cf7	68		pla		            PLA
.1a1cf8	28		plp		            PLP
.1a1cf9	20 09 1d	jsr $1a1d09	            JSR OPSTUB
.1a1cfc	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Get return result in argument 1
.1a1cff	20 ab 19	jsr $1a19ab	            JSR PHARGUMENT
.1a1d02	ab		plb		            PLB
.1a1d03	2b		pld		            PLD
.1a1d04	28		plp		            PLP
.1a1d05	68		pla		            PLA
.1a1d06	60		rts		            RTS
.1a1d07	00		brk #		bad_token   BRK
.1a1d08	ea		nop		            NOP
.1a1d09	6c 2f 08	jmp ($082f)	OPSTUB      JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.1a1d0c					EVALEXPR
.1a1d0c	08		php		            PHP
.1a1d0d	08		php		            PHP
.1a1d0e	c2 20		rep #$20	            REP #$20
.1a1d10	48		pha		            PHA
.1a1d11	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1d14	5b		tcd		            TCD
.1a1d15	68		pla		            PLA
.1a1d16	28		plp		            PLP
.1a1d17	08		php		            PHP
.1a1d18	e2 20		sep #$20	            SEP #$20
.1a1d1a	48		pha		            PHA
.1a1d1b	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1d1d	48		pha		            PHA
.1a1d1e	ab		plb		            PLB
.1a1d1f	68		pla		            PLA
.1a1d20	28		plp		            PLP
.1a1d21	c2 10		rep #$10	            REP #$10
.1a1d23	da		phx		            PHX
.1a1d24					get_char
.1a1d24	e2 20		sep #$20	            SEP #$20
.1a1d26	a7 00		lda [$0800]	            LDA [BIP]           ; Get the character
.1a1d28	d0 03		bne $1a1d2d	            BNE else1
.1a1d2a	4c cf 1d	jmp $1a1dcf	            JMP proc_stack      ; Handle end of line, if we see it
.1a1d2d	30 33		bmi $1a1d62	else1       BMI is_token        ; If MSB is set, it's a token
.1a1d2f	c9 20		cmp #$20	            CMP #' '            ; Is it a space?
.1a1d31	d0 03		bne $1a1d36	            BNE else2
.1a1d33	4c c9 1d	jmp $1a1dc9	            JMP next_char       ; Yes: Skip to the next character
.1a1d36	c9 3a		cmp #$3a	else2       CMP #'9'+1          ; Check to see if we have digits
.1a1d38	b0 04		bcs $1a1d3e	            BCS else3           ; No: treat as the end of the line
.1a1d3a	c9 30		cmp #$30	            CMP #'0'
.1a1d3c	b0 56		bcs $1a1d94	            BCS is_digit
.1a1d3e	c9 26		cmp #$26	else3       CMP #'&'            ; Check for a hexadecimal prefix
.1a1d40	f0 52		beq $1a1d94	            BEQ is_digit
.1a1d42	c9 22		cmp #$22	            CMP #'"'            ; Is it a double-quote?
.1a1d44	d0 03		bne $1a1d49	            BNE else4
.1a1d46	4c e2 1d	jmp $1a1de2	            JMP is_string       ; Yes: process the string
.1a1d49	c9 5b		cmp #$5b	else4       CMP #'Z'+1          ; Check to see if we have upper case alphabetics
.1a1d4b	b0 07		bcs $1a1d54	            BCS check_lc        ; No: check for lower case
.1a1d4d	c9 41		cmp #$41	            CMP #'A'
.1a1d4f	90 03		bcc $1a1d54	            BCC check_lc
.1a1d51	4c ee 1d	jmp $1a1dee	            JMP is_alpha
.1a1d54	c9 7b		cmp #$7b	check_lc    CMP #'z'+1          ; Check to see if we have lower case alphabetics
.1a1d56	b0 07		bcs $1a1d5f	            BCS else5           ; No: treat as the end of the line
.1a1d58	c9 61		cmp #$61	            CMP #'a'
.1a1d5a	90 03		bcc $1a1d5f	            BCC else5
.1a1d5c	4c ee 1d	jmp $1a1dee	            JMP is_alpha
.1a1d5f	4c cf 1d	jmp $1a1dcf	else5       JMP proc_stack
.1a1d62	c9 8f		cmp #$8f	is_token    CMP #TOK_LPAREN     ; Is it an LPAREN
.1a1d64	f0 40		beq $1a1da6	            BEQ is_lparen       ; Yes: handle the LPAREN
.1a1d66	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it an RPAREN?
.1a1d68	f0 41		beq $1a1dab	            BEQ is_rparen       ; Yes: handle the RPAREN
.1a1d6a	20 a7 0c	jsr $1a0ca7	            JSR TOKTYPE
.1a1d6d	c9 30		cmp #$30	            CMP #TOK_TY_FUNC    ; Is it a function?
.1a1d6f	d0 0c		bne $1a1d7d	            BNE chk_op          ; No: check if it's an operator
.1a1d71	20 8e 1c	jsr $1a1c8e	            JSR EVAL_FUNC
.1a1d74	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.1a1d77	20 ab 19	jsr $1a19ab	            JSR PHARGUMENT
.1a1d7a	4c 24 1d	jmp $1a1d24	            JMP get_char
.1a1d7d	c9 00		cmp #$00	chk_op      CMP #TOK_TY_OP      ; Is it an operator?
.1a1d7f	d0 4e		bne $1a1dcf	            BNE proc_stack      ; No: we're finished processing
.1a1d81	a7 00		lda [$0800]	            LDA [BIP]           ; Yes: Get the token back
.1a1d83	a6 21		ldx $0821	chk_prec    LDX OPERATORSP      ; Is the operator stack empty?
.1a1d85	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.1a1d88	f0 05		beq $1a1d8f	            BEQ push_op         ; Yes: push the operator
.1a1d8a	20 c8 1a	jsr $1a1ac8	            JSR OPHIGHPREC
.1a1d8d	b0 12		bcs $1a1da1	            BCS process1        ; No: we should process the top operator
.1a1d8f					push_op
.1a1d8f	20 28 1a	jsr $1a1a28	            JSR PHOPERATOR
.1a1d92	80 35		bra $1a1dc9	            BRA next_char       ; And go to the next character
.1a1d94					is_digit
.1a1d94	c2 20		rep #$20	            REP #$20
.1a1d96	20 42 5a	jsr $1a5a42	            JSR PARSENUM
.1a1d99	a2 23 08	ldx #$0823	got_number  LDX #<>ARGUMENT1
.1a1d9c	20 ab 19	jsr $1a19ab	            JSR PHARGUMENT
.1a1d9f	80 83		bra $1a1d24	            BRA get_char
.1a1da1					process1
.1a1da1	20 b8 1c	jsr $1a1cb8	            JSR PROCESSOP
.1a1da4	80 dd		bra $1a1d83	            BRA chk_prec        ; And check what to do with the current operator
.1a1da6					is_lparen
.1a1da6	20 28 1a	jsr $1a1a28	            JSR PHOPERATOR
.1a1da9	80 1e		bra $1a1dc9	            BRA next_char
.1a1dab					is_rparen
.1a1dab	e2 20		sep #$20	            SEP #$20
.1a1dad	a4 21		ldy $0821	            LDY OPERATORSP      ; Is the operator stack empty?
.1a1daf	c0 ff 7f	cpy #$7fff	            CPY #<>OPERATOR_TOP
.1a1db2	f0 46		beq $1a1dfa	            BEQ done            ; Yes: we're done evaluating things
.1a1db4	a4 21		ldy $0821	paren_loop  LDY OPERATORSP      ; Peek at the top operator
.1a1db6	b9 01 00	lda $0001,y	            LDA #1,B,Y
.1a1db9	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the LPAREN of a function?
.1a1dbb	f0 3d		beq $1a1dfa	            BEQ done            ; Yes: treat it as an empty stack
.1a1dbd	c9 8f		cmp #$8f	            CMP #TOK_LPAREN     ; Is it an LPAREN?
.1a1dbf	f0 05		beq $1a1dc6	            BEQ done_rparen     ; Yes: we're finished processing
.1a1dc1	20 b8 1c	jsr $1a1cb8	            JSR PROCESSOP
.1a1dc4	80 ee		bra $1a1db4	            BRA paren_loop
.1a1dc6					done_rparen
.1a1dc6	20 51 1a	jsr $1a1a51	            JSR PLOPERATOR
.1a1dc9					next_char
.1a1dc9	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a1dcc	4c 24 1d	jmp $1a1d24	            JMP get_char
.1a1dcf					proc_stack
.1a1dcf	a6 21		ldx $0821	            LDX OPERATORSP      ; Is the operator stack empty?
.1a1dd1	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.1a1dd4	b0 24		bcs $1a1dfa	            BGE done            ; Yes: return to the caller
.1a1dd6	bd 01 00	lda $0001,x	            LDA #1,B,X
.1a1dd9	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is top operator a function open?
.1a1ddb	f0 1d		beq $1a1dfa	            BEQ done            ; Yes: treat as end of expression
.1a1ddd	20 b8 1c	jsr $1a1cb8	            JSR PROCESSOP
.1a1de0	80 ed		bra $1a1dcf	            BRA proc_stack
.1a1de2					is_string
.1a1de2	20 18 1c	jsr $1a1c18	            JSR EVALSTRING
.1a1de5	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.1a1de8	20 ab 19	jsr $1a19ab	            JSR PHARGUMENT
.1a1deb	4c 24 1d	jmp $1a1d24	            JMP get_char
.1a1dee					is_alpha
.1a1dee	20 8d 1b	jsr $1a1b8d	            JSR EVALREF
.1a1df1	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.1a1df4	20 ab 19	jsr $1a19ab	            JSR PHARGUMENT
.1a1df7	4c 24 1d	jmp $1a1d24	            JMP get_char
.1a1dfa	a2 23 08	ldx #$0823	done        LDX #<>ARGUMENT1    ; Make sure the result is off the stack
.1a1dfd	20 e9 19	jsr $1a19e9	            JSR PLARGUMENT
.1a1e00					real_done
.1a1e00	fa		plx		            PLX
.1a1e01	28		plp		            PLP
.1a1e02	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\returnstack.s

.1a1e03					INITRETURN
.1a1e03	08		php		                PHP
.1a1e04	0b		phd		                PHD
.1a1e05	8b		phb		                PHB
.1a1e06	08		php		            PHP
.1a1e07	e2 20		sep #$20	            SEP #$20
.1a1e09	48		pha		            PHA
.1a1e0a	a9 00		lda #$00	            LDA #0
.1a1e0c	48		pha		            PHA
.1a1e0d	ab		plb		            PLB
.1a1e0e	68		pla		            PLA
.1a1e0f	28		plp		            PLP
.1a1e10	08		php		            PHP
.1a1e11	c2 20		rep #$20	            REP #$20
.1a1e13	48		pha		            PHA
.1a1e14	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1e17	5b		tcd		            TCD
.1a1e18	68		pla		            PLA
.1a1e19	28		plp		            PLP
.1a1e1a	c2 30		rep #$30	            REP #$30
.1a1e1c	a9 fd 5f	lda #$5ffd	                LDA #RETURN_TOP-2
.1a1e1f	85 33		sta $0833	                STA RETURNSP
.1a1e21	ab		plb		                PLB
.1a1e22	2b		pld		                PLD
.1a1e23	28		plp		                PLP
.1a1e24	60		rts		            RTS
.1a1e25					PHRETURN
.1a1e25	08		php		                PHP
.1a1e26	0b		phd		                PHD
.1a1e27	08		php		            PHP
.1a1e28	c2 20		rep #$20	            REP #$20
.1a1e2a	48		pha		            PHA
.1a1e2b	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1e2e	5b		tcd		            TCD
.1a1e2f	68		pla		            PLA
.1a1e30	28		plp		            PLP
.1a1e31	c2 30		rep #$30	            REP #$30
.1a1e33	92 33		sta ($0833)	                STA (RETURNSP)
.1a1e35	c6 33		dec $0833	                DEC RETURNSP
.1a1e37	c6 33		dec $0833	                DEC RETURNSP
.1a1e39	2b		pld		                PLD
.1a1e3a	28		plp		                PLP
.1a1e3b	60		rts		            RTS
.1a1e3c					PHRETURNB
.1a1e3c	08		php		                PHP
.1a1e3d	c2 30		rep #$30	            REP #$30
.1a1e3f	29 ff 00	and #$00ff	                AND #$00FF
.1a1e42	20 25 1e	jsr $1a1e25	            JSR PHRETURN
.1a1e45	28		plp		                PLP
.1a1e46	60		rts		            RTS
.1a1e47					PLRETURN
.1a1e47	08		php		                PHP
.1a1e48	0b		phd		                PHD
.1a1e49	08		php		            PHP
.1a1e4a	c2 20		rep #$20	            REP #$20
.1a1e4c	48		pha		            PHA
.1a1e4d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1e50	5b		tcd		            TCD
.1a1e51	68		pla		            PLA
.1a1e52	28		plp		            PLP
.1a1e53	c2 30		rep #$30	            REP #$30
.1a1e55	e6 33		inc $0833	                INC RETURNSP
.1a1e57	e6 33		inc $0833	                INC RETURNSP
.1a1e59	b2 33		lda ($0833)	                LDA (RETURNSP)
.1a1e5b	2b		pld		                PLD
.1a1e5c	28		plp		                PLP
.1a1e5d	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\interpreter.s

=$80					ST_RUNNING = $80            ; The interpreter is running a full program
=$00					ST_INTERACT = $00           ; The interpreter is in interactive mode
>08d2					STATE       .byte ?         ; The state of the interpreter ()
>08d3					ERROR_NUM   .byte ?         ; The type of the error
>08d4					HANDLEERR   .long ?         ; Pointer to the error handler
>08d7					LINENUM     .word ?         ; The current line number
>08d9					LASTLINE    .long ?         ; Pointer to the next free space over the BASIC program
>08dc					EXECACTION  .byte ?         ; The action the exection routines should take to get their next statement
=0					LINE_LINK = 0               ; Offset to the link to the next line
=2					LINE_NUMBER = 2             ; Offset to the line number
=4					LINE_TOKENS = 4             ; Offset to the first token
=6					LINE_MINLEN = 6             ; Minimum length of a line
=0					EXEC_CONT = 0               ; Continue advancing the current line
=1					EXEC_STOP = 1               ; Stop execution of the program
=2					EXEC_GOTO = 2               ; Transfer execution to a new CURLINE that is already set
=3					EXEC_RETURN = 3             ; Transfer execution back to a line that was on the stack
.1a1e5e					SET_ERRERL
.1a1e5e	8b		phb		                PHB
.1a1e5f	0b		phd		                PHD
.1a1e60	08		php		                PHP
.1a1e61	08		php		            PHP
.1a1e62	c2 20		rep #$20	            REP #$20
.1a1e64	48		pha		            PHA
.1a1e65	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1e68	5b		tcd		            TCD
.1a1e69	68		pla		            PLA
.1a1e6a	28		plp		            PLP
.1a1e6b	08		php		            PHP
.1a1e6c	e2 20		sep #$20	            SEP #$20
.1a1e6e	48		pha		            PHA
.1a1e6f	a9 00		lda #$00	            LDA #BASIC_BANK
.1a1e71	48		pha		            PHA
.1a1e72	ab		plb		            PLB
.1a1e73	68		pla		            PLA
.1a1e74	28		plp		            PLP
.1a1e75	c2 20		rep #$20	            REP #$20
.1a1e77	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.1a1e79	a9 00 00	lda #$0000	                LDA #0
.1a1e7c	85 25		sta $0825	                STA ARGUMENT1+2
.1a1e7e	e2 20		sep #$20	            SEP #$20
.1a1e80	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a1e82	85 27		sta $0827	                STA ARGTYPE1
.1a1e84	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.1a1e86	a9 1a		lda #$1a	                LDA #`err_name
.1a1e88	85 e9		sta $08e9	                STA TOFIND+2
.1a1e8a	c2 20		rep #$20	            REP #$20
.1a1e8c	a9 b8 1e	lda #$1eb8	                LDA #<>err_name
.1a1e8f	85 e7		sta $08e7	                STA TOFIND
.1a1e91	20 83 53	jsr $1a5383	            JSR VAR_SET
.1a1e94	c2 20		rep #$20	            REP #$20
.1a1e96	a5 d7		lda $08d7	                LDA LINENUM
.1a1e98	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.1a1e9a	a5 d9		lda $08d9	                LDA LINENUM+2
.1a1e9c	85 25		sta $0825	                STA ARGUMENT1+2
.1a1e9e	e2 20		sep #$20	            SEP #$20
.1a1ea0	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a1ea2	85 27		sta $0827	                STA ARGTYPE1
.1a1ea4	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.1a1ea6	a9 1a		lda #$1a	                LDA #`erl_name
.1a1ea8	85 e9		sta $08e9	                STA TOFIND+2
.1a1eaa	c2 20		rep #$20	            REP #$20
.1a1eac	a9 bc 1e	lda #$1ebc	                LDA #<>erl_name
.1a1eaf	85 e7		sta $08e7	                STA TOFIND
.1a1eb1	20 83 53	jsr $1a5383	            JSR VAR_SET
.1a1eb4	28		plp		                PLP
.1a1eb5	2b		pld		                PLD
.1a1eb6	ab		plb		                PLB
.1a1eb7	60		rts		            RTS
>1a1eb8	45 52 52 00			err_name        .null "ERR"
>1a1ebc	45 52 4c 00			erl_name        .null "ERL"
.1a1ec0					ON_ERROR
.1a1ec0	e2 20		sep #$20	            SEP #$20
.1a1ec2	c2 10		rep #$10	            REP #$10
.1a1ec4	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a1ec7	af d3 08 00	lda $0008d3	            LDA @lERROR_NUM         ; Calculate index to the error message pointer
.1a1ecb	0a		asl a		            ASL A
.1a1ecc	c2 20		rep #$20	            REP #$20
.1a1ece	29 ff 00	and #$00ff	            AND #$00FF
.1a1ed1	a8		tay		            TAY
.1a1ed2	08		php		            PHP
.1a1ed3	e2 20		sep #$20	            SEP #$20
.1a1ed5	48		pha		            PHA
.1a1ed6	a9 1a		lda #$1a	            LDA #`ERRORMSG
.1a1ed8	48		pha		            PHA
.1a1ed9	ab		plb		            PLB
.1a1eda	68		pla		            PLA
.1a1edb	28		plp		            PLP
.1a1edc	be 12 1f	ldx $1a1f12,y	            LDX ERRORMSG,Y
.1a1edf	20 64 04	jsr $1a0464	            JSR PRINTS
.1a1ee2	c2 20		rep #$20	            REP #$20
.1a1ee4	a5 d7		lda $08d7	            LDA LINENUM
.1a1ee6	f0 27		beq $1a1f0f	            BEQ skip_at
.1a1ee8	a2 42 1f	ldx #$1f42	            LDX #<>MSG_AT           ; If so... print " AT "
.1a1eeb	20 64 04	jsr $1a0464	            JSR PRINTS
.1a1eee	08		php		            PHP
.1a1eef	e2 20		sep #$20	            SEP #$20
.1a1ef1	48		pha		            PHA
.1a1ef2	a9 00		lda #$00	            LDA #BASIC_BANK
.1a1ef4	48		pha		            PHA
.1a1ef5	ab		plb		            PLB
.1a1ef6	68		pla		            PLA
.1a1ef7	28		plp		            PLP
.1a1ef8	c2 20		rep #$20	            REP #$20
.1a1efa	af d7 08 00	lda $0008d7	            LDA @lLINENUM           ; ... and then the line number
.1a1efe	8f 23 08 00	sta $000823	            STA @lARGUMENT1
.1a1f02	a9 00 00	lda #$0000	            LDA #0
.1a1f05	8f 25 08 00	sta $000825	            STA @lARGUMENT1+2
.1a1f09	20 1e 46	jsr $1a461e	            JSR PR_INTEGER
.1a1f0c	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a1f0f					skip_at
.1a1f0f	4c c0 27	jmp $1a27c0	            JMP INTERACT
>1a1f12	46 1f				ERRORMSG    .word <>MSG_OK
>1a1f14	49 1f				            .word <>MSG_BREAK
>1a1f16	4f 1f				            .word <>MSG_SYNTAX
>1a1f18	5c 1f				            .word <>MSG_MEMORY
>1a1f1a	6a 1f				            .word <>MSG_TYPE
>1a1f1c	78 1f				            .word <>MSG_NOTFND
>1a1f1e	8b 1f				            .word <>MSG_NOLINE
>1a1f20	a1 1f				            .word <>MSG_UNDFLOW
>1a1f22	b1 1f				            .word <>MSG_OVRFLOW
>1a1f24	c0 1f				            .word <>MSG_RANGE
>1a1f26	cd 1f				            .word <>MSG_ARG
>1a1f28	de 1f				            .word <>MSG_NOFILE
>1a1f2a	ed 1f				            .word <>MSG_NAN
>1a1f2c	fa 1f				            .word <>MSG_OVERFLOW
>1a1f2e	08 20				            .word <>MSG_UNDERFLOW
>1a1f30	17 20				            .word <>MSG_DIV0
>1a1f32	28 20				            .word <>MSG_DIRECTORY
>1a1f34	41 20				            .word <>MSG_LOAD
>1a1f36	55 20				            .word <>MSG_SAVE
>1a1f38	69 20				            .word <>MSG_DELETE
>1a1f3a	7f 20				            .word <>MSG_FILENOTFND
>1a1f3c	93 20				            .word <>MSG_DIRNOTWRITE
>1a1f3e	ae 20				            .word <>MSG_NOTCOPIED
>1a1f40	c6 20				            .word <>MSG_DOMAIN
>1a1f42	20 61 74 00			MSG_AT          .null " at"
>1a1f46	4f 4b 00			MSG_OK          .null "OK"
>1a1f49	42 72 65 61 6b 00		MSG_BREAK       .null "Break"
>1a1f4f	53 79 6e 74 61 78 20 65		MSG_SYNTAX      .null "Syntax error"
>1a1f57	72 72 6f 72 00
>1a1f5c	4f 75 74 20 6f 66 20 6d		MSG_MEMORY      .null "Out of memory"
>1a1f64	65 6d 6f 72 79 00
>1a1f6a	54 79 70 65 20 6d 69 73		MSG_TYPE        .null "Type mismatch"
>1a1f72	6d 61 74 63 68 00
>1a1f78	56 61 72 69 61 62 6c 65		MSG_NOTFND      .null "Variable not found"
>1a1f80	20 6e 6f 74 20 66 6f 75 6e 64 00
>1a1f8b	4c 69 6e 65 20 6e 75 6d		MSG_NOLINE      .null "Line number not found"
>1a1f93	62 65 72 20 6e 6f 74 20 66 6f 75 6e 64 00
>1a1fa1	53 74 61 63 6b 20 75 6e		MSG_UNDFLOW     .null "Stack underflow"
>1a1fa9	64 65 72 66 6c 6f 77 00
>1a1fb1	53 74 61 63 6b 20 6f 76		MSG_OVRFLOW     .null "Stack overflow"
>1a1fb9	65 72 66 6c 6f 77 00
>1a1fc0	4f 75 74 20 6f 66 20 72		MSG_RANGE       .null "Out of range"
>1a1fc8	61 6e 67 65 00
>1a1fcd	49 6c 6c 65 67 61 6c 20		MSG_ARG         .null "Illegal argument"
>1a1fd5	61 72 67 75 6d 65 6e 74 00
>1a1fde	46 69 6c 65 20 6e 6f 74		MSG_NOFILE      .null "File not found"
>1a1fe6	20 66 6f 75 6e 64 00
>1a1fed	4e 6f 74 20 61 20 6e 75		MSG_NAN         .null "Not a number"
>1a1ff5	6d 62 65 72 00
>1a1ffa	4d 61 74 68 20 6f 76 65		MSG_OVERFLOW    .null "Math overflow"
>1a2002	72 66 6c 6f 77 00
>1a2008	4d 61 74 68 20 75 6e 64		MSG_UNDERFLOW   .null "Math underflow"
>1a2010	65 72 66 6c 6f 77 00
>1a2017	44 69 76 69 73 69 6f 6e		MSG_DIV0        .null "Division by zero"
>1a201f	20 62 79 20 7a 65 72 6f 00
>1a2028	55 6e 61 62 6c 65 20 74		MSG_DIRECTORY   .null "Unable to read directory"
>1a2030	6f 20 72 65 61 64 20 64 69 72 65 63 74 6f 72 79
>1a2040	00
>1a2041	55 6e 61 62 6c 65 20 74		MSG_LOAD        .null "Unable to load file"
>1a2049	6f 20 6c 6f 61 64 20 66 69 6c 65 00
>1a2055	55 6e 61 62 6c 65 20 74		MSG_SAVE        .null "Unable to save file"
>1a205d	6f 20 73 61 76 65 20 66 69 6c 65 00
>1a2069	55 6e 61 62 6c 65 20 74		MSG_DELETE      .null "Unable to delete file"
>1a2071	6f 20 64 65 6c 65 74 65 20 66 69 6c 65 00
>1a207f	43 6f 75 6c 64 20 6e 6f		MSG_FILENOTFND  .null "Could not find file"
>1a2087	74 20 66 69 6e 64 20 66 69 6c 65 00
>1a2093	43 6f 75 6c 64 20 6e 6f		MSG_DIRNOTWRITE .null "Could not update directory"
>1a209b	74 20 75 70 64 61 74 65 20 64 69 72 65 63 74 6f
>1a20ab	72 79 00
>1a20ae	43 6f 75 6c 64 20 6e 6f		MSG_NOTCOPIED   .null "Could not copy the file"
>1a20b6	74 20 63 6f 70 79 20 74 68 65 20 66 69 6c 65 00
>1a20c6	41 72 67 75 6d 65 6e 74		MSG_DOMAIN      .null "Argument outside domain"
>1a20ce	20 6f 75 74 73 69 64 65 20 64 6f 6d 61 69 6e 00
.1a20de					SETINTERACT
.1a20de	08		php		            PHP
.1a20df	0b		phd		            PHD
.1a20e0	08		php		            PHP
.1a20e1	c2 20		rep #$20	            REP #$20
.1a20e3	48		pha		            PHA
.1a20e4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a20e7	5b		tcd		            TCD
.1a20e8	68		pla		            PLA
.1a20e9	28		plp		            PLP
.1a20ea	e2 20		sep #$20	            SEP #$20
.1a20ec	a9 00		lda #$00	            LDA #ST_INTERACT
.1a20ee	85 d2		sta $08d2	            STA STATE
.1a20f0	2b		pld		            PLD
.1a20f1	28		plp		            PLP
.1a20f2	60		rts		            RTS
.1a20f3					CLRINTERP
.1a20f3	0b		phd		            PHD
.1a20f4	08		php		            PHP
.1a20f5	08		php		            PHP
.1a20f6	c2 20		rep #$20	            REP #$20
.1a20f8	48		pha		            PHA
.1a20f9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a20fc	5b		tcd		            TCD
.1a20fd	68		pla		            PLA
.1a20fe	28		plp		            PLP
.1a20ff	08		php		            PHP
.1a2100	c2 20		rep #$20	            REP #$20
.1a2102	a9 c0 1e	lda #$1ec0	            LDA #<>ON_ERROR
.1a2105	8f d4 08 00	sta $0008d4	            STA @lHANDLEERR
.1a2109	e2 20		sep #$20	            SEP #$20
.1a210b	a9 1a		lda #$1a	            LDA #`ON_ERROR
.1a210d	8f d6 08 00	sta $0008d6	            STA @lHANDLEERR+2
.1a2111	28		plp		            PLP
.1a2112	20 c5 44	jsr $1a44c5	            JSR S_CLR
.1a2115	20 06 40	jsr $1a4006	            JSR S_RESTORE
.1a2118	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the depth of the GOSUB stack
.1a211a	28		plp		            PLP
.1a211b	2b		pld		            PLD
.1a211c	60		rts		            RTS
.1a211d					INCBIP
.1a211d	08		php		            PHP
.1a211e	0b		phd		            PHD
.1a211f	08		php		            PHP
.1a2120	c2 20		rep #$20	            REP #$20
.1a2122	48		pha		            PHA
.1a2123	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2126	5b		tcd		            TCD
.1a2127	68		pla		            PLA
.1a2128	28		plp		            PLP
.1a2129	c2 20		rep #$20	            REP #$20
.1a212b	18		clc		            CLC
.1a212c	a5 00		lda $0800	            LDA BIP
.1a212e	69 01 00	adc #$0001	            ADC #1
.1a2131	85 00		sta $0800	            STA BIP
.1a2133	e2 20		sep #$20	            SEP #$20
.1a2135	a5 02		lda $0802	            LDA BIP+2
.1a2137	69 00		adc #$00	            ADC #0
.1a2139	85 02		sta $0802	            STA BIP+2
.1a213b	2b		pld		            PLD
.1a213c	28		plp		            PLP
.1a213d	60		rts		            RTS
.1a213e					SKIPWS
.1a213e	08		php		            PHP
.1a213f	0b		phd		            PHD
.1a2140	08		php		            PHP
.1a2141	c2 20		rep #$20	            REP #$20
.1a2143	48		pha		            PHA
.1a2144	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2147	5b		tcd		            TCD
.1a2148	68		pla		            PLA
.1a2149	28		plp		            PLP
.1a214a	e2 20		sep #$20	            SEP #$20
.1a214c	a7 00		lda [$0800]	loop        LDA [BIP]
.1a214e	f0 0f		beq $1a215f	            BEQ done            ; If character is 0, we've reached the end of the line
.1a2150	c9 20		cmp #$20	            CMP #CHAR_SP        ; Skip if it's a space
.1a2152	f0 06		beq $1a215a	            BEQ skip_char
.1a2154	c9 09		cmp #$09	            CMP #CHAR_TAB       ; Skip if it's a TAB
.1a2156	f0 02		beq $1a215a	            BEQ skip_char
.1a2158	80 05		bra $1a215f	            BRA done            ; Otherwise, we're done and BIP points to a non-whitespace
.1a215a					skip_char
.1a215a	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a215d	80 ed		bra $1a214c	            BRA loop
.1a215f	2b		pld		done        PLD
.1a2160	28		plp		            PLP
.1a2161	60		rts		            RTS
.1a2162					SKIPSTMT
.1a2162	08		php		            PHP
.1a2163	e2 20		sep #$20	            SEP #$20
.1a2165	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the current character
.1a2167	f0 09		beq $1a2172	            BEQ done            ; Is it EOL? Yes, we're done
.1a2169	c9 3a		cmp #$3a	            CMP #':'            ; Is it a colon?
.1a216b	f0 05		beq $1a2172	            BEQ done            ; Yes, we're done
.1a216d	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a2170	80 f3		bra $1a2165	            BRA loop            ; and check it...
.1a2172	28		plp		done        PLP
.1a2173	60		rts		            RTS
.1a2174					SKIPTOTOK
.1a2174	08		php		            PHP
.1a2175	e2 20		sep #$20	            SEP #$20
.1a2177	64 36		stz $0836	            STZ NESTING
.1a2179	a7 00		lda [$0800]	loop        LDA [BIP]           ; Get the character
.1a217b	f0 19		beq $1a2196	            BEQ end_of_line     ; EOL? Yes: move to the next line
.1a217d	c5 37		cmp $0837	            CMP TARGETTOK       ; Is it the one we want?
.1a217f	f0 2c		beq $1a21ad	            BEQ check_depth     ; Yes: check the depth
.1a2181	c9 9b		cmp #$9b	            CMP #TOK_FOR        ; Is it a FOR?
.1a2183	f0 1e		beq $1a21a3	            BEQ inc_nesting     ; Yes: increment NESTING
.1a2185	c9 9f		cmp #$9f	            CMP #TOK_DO         ; Is it a DO?
.1a2187	f0 1a		beq $1a21a3	            BEQ inc_nesting     ; Yes: increment NESTING
.1a2189	c9 9e		cmp #$9e	            CMP #TOK_NEXT       ; Is it a NEXT?
.1a218b	f0 1a		beq $1a21a7	            BEQ dec_nesting     ; Yes: decrement NESTING
.1a218d	c9 a0		cmp #$a0	            CMP #TOK_LOOP       ; Is it a LOOP?
.1a218f	f0 16		beq $1a21a7	            BEQ dec_nesting     ; Yes: decrement NESTING
.1a2191					incloop
.1a2191	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a2194	80 e3		bra $1a2179	            BRA loop            ; and keep scanning
.1a2196					end_of_line
.1a2196	20 fa 21	jsr $1a21fa	            JSR NEXTLINE
.1a2199	c2 20		rep #$20	            REP #$20
.1a219b	a5 d7		lda $08d7	            LDA LINENUM         ; Check the line number
.1a219d	f0 1d		beq $1a21bc	            BEQ syntax_err1     ; If it's zero, we reached the end of the program
.1a219f	e2 20		sep #$20	            SEP #$20
.1a21a1	80 d6		bra $1a2179	            BRA loop            ; And keep scanning
.1a21a3					inc_nesting
.1a21a3	e6 36		inc $0836	            INC NESTING         ; Track that we have entered a lexical scope for a FOR/DO
.1a21a5	80 ea		bra $1a2191	            BRA incloop
.1a21a7					dec_nesting
.1a21a7	c6 36		dec $0836	            DEC NESTING         ; Track that we have left a lexical scope for a FOR/DO
.1a21a9	30 30		bmi $1a21db	            BMI syntax_err2     ; If the depth goes <0, throw a syntax error
.1a21ab	80 e4		bra $1a2191	            BRA incloop
.1a21ad					check_depth
.1a21ad	a5 35		lda $0835	            LDA SKIPNEST        ; Check to see if nesting matters
.1a21af	30 06		bmi $1a21b7	            BMI found           ; No: just return that we found the token
.1a21b1	a5 36		lda $0836	            LDA NESTING         ; Get the nesting depth
.1a21b3	f0 02		beq $1a21b7	            BEQ found           ; If it's zero, we found our token
.1a21b5	80 da		bra $1a2191	            BRA incloop         ; Otherwise: it's a token for an enclosed FOR/DO, keep scanning
.1a21b7					found
.1a21b7	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a21ba	28		plp		            PLP
.1a21bb	60		rts		            RTS
.1a21bc					syntax_err1
.1a21bc	08		php		            PHP
.1a21bd	c2 20		rep #$20	            REP #$20
.1a21bf	48		pha		            PHA
.1a21c0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a21c3	5b		tcd		            TCD
.1a21c4	68		pla		            PLA
.1a21c5	28		plp		            PLP
.1a21c6	e2 20		sep #$20	            SEP #$20
.1a21c8	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a21ca	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a21ce	c2 20		rep #$20	            REP #$20
.1a21d0	29 ff 00	and #$00ff	            AND #$00FF
.1a21d3	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a21d6	e2 20		sep #$20	            SEP #$20
.1a21d8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a21db					syntax_err2
.1a21db	08		php		            PHP
.1a21dc	c2 20		rep #$20	            REP #$20
.1a21de	48		pha		            PHA
.1a21df	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a21e2	5b		tcd		            TCD
.1a21e3	68		pla		            PLA
.1a21e4	28		plp		            PLP
.1a21e5	e2 20		sep #$20	            SEP #$20
.1a21e7	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a21e9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a21ed	c2 20		rep #$20	            REP #$20
.1a21ef	29 ff 00	and #$00ff	            AND #$00FF
.1a21f2	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a21f5	e2 20		sep #$20	            SEP #$20
.1a21f7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a21fa					NEXTLINE
.1a21fa	08		php		            PHP
.1a21fb	c2 30		rep #$30	            REP #$30
.1a21fd	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a2200	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the offset to the next line
.1a2202	85 0c		sta $080c	            STA SCRATCH
.1a2204	18		clc		            CLC                 ; Compute the new CURLINE
.1a2205	a5 1a		lda $081a	            LDA CURLINE         ; CURLINE := [CURLINE].LINE_LINK
.1a2207	65 0c		adc $080c	            ADC SCRATCH
.1a2209	85 1a		sta $081a	            STA CURLINE
.1a220b	a5 1c		lda $081c	            LDA CURLINE+2
.1a220d	69 00 00	adc #$0000	            ADC #0
.1a2210	85 1c		sta $081c	            STA CURLINE+2
.1a2212	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the LINENUM to the new current line's number
.1a2215	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; LINENUM := [CURLINE].LINE_NUMBER
.1a2217	85 d7		sta $08d7	            STA LINENUM
.1a2219	18		clc		            CLC                 ; Point BIP to the first character of the line
.1a221a	a5 1a		lda $081a	            LDA CURLINE         ; BIP := CURLINE + LINE_TOKENS
.1a221c	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a221f	85 00		sta $0800	            STA BIP
.1a2221	a5 1c		lda $081c	            LDA CURLINE+2
.1a2223	69 00 00	adc #$0000	            ADC #0
.1a2226	85 02		sta $0802	            STA BIP+2
.1a2228	28		plp		            PLP
.1a2229	60		rts		            RTS
.1a222a					EXPECT_TOK
.1a222a	08		php		            PHP
.1a222b	e2 20		sep #$20	            SEP #$20
.1a222d	48		pha		            PHA
.1a222e	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a2231	68		pla		            PLA
.1a2232	e2 20		sep #$20	            SEP #$20
.1a2234	c7 00		cmp [$0800]	            CMP [BIP]           ; Check the character at BIP
.1a2236	d0 08		bne $1a2240	            BNE syntax_err      ; Throw a syntax error
.1a2238	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a223b	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a223e	28		plp		            PLP
.1a223f	60		rts		            RTS
.1a2240					syntax_err
.1a2240	08		php		            PHP
.1a2241	c2 20		rep #$20	            REP #$20
.1a2243	48		pha		            PHA
.1a2244	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2247	5b		tcd		            TCD
.1a2248	68		pla		            PLA
.1a2249	28		plp		            PLP
.1a224a	e2 20		sep #$20	            SEP #$20
.1a224c	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a224e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2252	c2 20		rep #$20	            REP #$20
.1a2254	29 ff 00	and #$00ff	            AND #$00FF
.1a2257	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a225a	e2 20		sep #$20	            SEP #$20
.1a225c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a225f					OPT_TOK
.1a225f	08		php		            PHP
.1a2260	e2 20		sep #$20	            SEP #$20
.1a2262	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a2265	e2 20		sep #$20	            SEP #$20
.1a2267	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the character at BIP
.1a2269	f0 10		beq $1a227b	            BEQ ret_false       ; If end-of-line, return false
.1a226b	c9 3a		cmp #$3a	            CMP #':'
.1a226d	f0 0c		beq $1a227b	            BEQ ret_false       ; If colon, return false
.1a226f	c5 37		cmp $0837	            CMP TARGETTOK
.1a2271	f0 05		beq $1a2278	            BEQ ret_true        ; If matches, return true
.1a2273	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a2276	80 ef		bra $1a2267	            BRA loop
.1a2278	28		plp		ret_true    PLP
.1a2279	38		sec		            SEC
.1a227a	60		rts		            RTS
.1a227b	28		plp		ret_false   PLP
.1a227c	18		clc		            CLC
.1a227d	60		rts		            RTS
.1a227e					PEEK_TOK
.1a227e	5a		phy		            PHY
.1a227f	08		php		            PHP
.1a2280	e2 20		sep #$20	            SEP #$20
.1a2282	a0 00 00	ldy #$0000	            LDY #0
.1a2285	b7 00		lda [$0800],y	loop        LDA [BIP],Y
.1a2287	f0 0d		beq $1a2296	            BEQ done
.1a2289	c9 3a		cmp #$3a	            CMP #':'
.1a228b	f0 07		beq $1a2294	            BEQ ret_null
.1a228d	c9 20		cmp #$20	            CMP #CHAR_SP
.1a228f	d0 05		bne $1a2296	            BNE done
.1a2291	c8		iny		            INY
.1a2292	80 f1		bra $1a2285	            BRA loop
.1a2294	a9 00		lda #$00	ret_null    LDA #0
.1a2296	28		plp		done        PLP
.1a2297	7a		ply		            PLY
.1a2298	60		rts		            RTS
.1a2299					EXECSTMT
.1a2299	08		php		            PHP
.1a229a	0b		phd		            PHD
.1a229b	8b		phb		            PHB
.1a229c	08		php		            PHP
.1a229d	c2 20		rep #$20	            REP #$20
.1a229f	48		pha		            PHA
.1a22a0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a22a3	5b		tcd		            TCD
.1a22a4	68		pla		            PLA
.1a22a5	28		plp		            PLP
.1a22a6	20 f8 14	jsr $1a14f8	            JSR CLRTMPSTR
.1a22a9	20 8b 19	jsr $1a198b	            JSR INITEVALSP
.1a22ac	e2 20		sep #$20	            SEP #$20
.1a22ae	a9 00		lda #$00	            LDA #EXEC_CONT      ; This will tell EXECLINE and EXECPROG to procede in a
.1a22b0	85 dc		sta $08dc	            STA EXECACTION      ; linear fashion through the program
.1a22b2	22 3c 11 00	jsl $00113c	check_break JSL FK_TESTBREAK
.1a22b6	b0 4b		bcs $1a2303	            BCS throw_break     ; If C: user pressed an interrupt key, stop the program
.1a22b8	a7 00		lda [$0800]	            LDA [BIP]           ; If we happen to have a colon, just skip over it.
.1a22ba	c9 3a		cmp #$3a	            CMP #':'            ; This can happen with FOR/NEXT
.1a22bc	d0 03		bne $1a22c1	            BNE eat_ws
.1a22be	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a22c1					eat_ws
.1a22c1	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a22c4	a7 00		lda [$0800]	            LDA [BIP]
.1a22c6	d0 03		bne $1a22cb	            BNE else
.1a22c8	4c 4d 23	jmp $1a234d	            JMP done            ; If the current byte is 0, we're at the end of the line, just return
.1a22cb					else
.1a22cb	20 e2 04	jsr $1a04e2	            JSR ISALPHA
.1a22ce	b0 52		bcs $1a2322	            BCS is_variable     ; Yes: we may have a LET statement
.1a22d0	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it's any other non-token
.1a22d2	10 10		bpl $1a22e4	            BPL error           ; Yes: it's a syntax error
.1a22d4	20 a7 0c	jsr $1a0ca7	            JSR TOKTYPE
.1a22d7	85 0c		sta $080c	            STA SCRATCH         ; Save the type for later
.1a22d9	c9 20		cmp #$20	            CMP #TOK_TY_STMNT   ; Is it a statement?
.1a22db	d0 03		bne $1a22e0	            BNE else2
.1a22dd	4c 3b 23	jmp $1a233b	            JMP ok_to_exec      ; Yes: it's ok to try to execute it
.1a22e0	a5 d2		lda $08d2	else2       LDA STATE           ; Check to see if we're in interactive mode
.1a22e2	f0 51		beq $1a2335	            BEQ is_interact
.1a22e4					error
.1a22e4	08		php		            PHP
.1a22e5	c2 20		rep #$20	            REP #$20
.1a22e7	48		pha		            PHA
.1a22e8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a22eb	5b		tcd		            TCD
.1a22ec	68		pla		            PLA
.1a22ed	28		plp		            PLP
.1a22ee	e2 20		sep #$20	            SEP #$20
.1a22f0	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a22f2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a22f6	c2 20		rep #$20	            REP #$20
.1a22f8	29 ff 00	and #$00ff	            AND #$00FF
.1a22fb	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a22fe	e2 20		sep #$20	            SEP #$20
.1a2300	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2303					throw_break
.1a2303	08		php		            PHP
.1a2304	c2 20		rep #$20	            REP #$20
.1a2306	48		pha		            PHA
.1a2307	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a230a	5b		tcd		            TCD
.1a230b	68		pla		            PLA
.1a230c	28		plp		            PLP
.1a230d	e2 20		sep #$20	            SEP #$20
.1a230f	a9 01		lda #$01	            LDA #ERR_BREAK
.1a2311	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2315	c2 20		rep #$20	            REP #$20
.1a2317	29 ff 00	and #$00ff	            AND #$00FF
.1a231a	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a231d	e2 20		sep #$20	            SEP #$20
.1a231f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2322					is_variable
.1a2322	20 cf 44	jsr $1a44cf	            JSR S_LET
.1a2325	4c 4d 23	jmp $1a234d	            JMP done
.1a2328					STSTUB
.1a2328	08		php		            PHP
.1a2329	e2 20		sep #$20	            SEP #$20
.1a232b	48		pha		            PHA
.1a232c	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a232e	48		pha		            PHA
.1a232f	ab		plb		            PLB
.1a2330	68		pla		            PLA
.1a2331	28		plp		            PLP
.1a2332	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.1a2335	a5 0c		lda $080c	is_interact LDA SCRATCH         ; Get the token type
.1a2337	c9 10		cmp #$10	            CMP #TOK_TY_CMD     ; Is it a command?
.1a2339	d0 a9		bne $1a22e4	            BNE error           ; If not, it's an error
.1a233b					ok_to_exec
.1a233b	a7 00		lda [$0800]	            LDA [BIP]           ; Get the original token again
.1a233d	20 84 0c	jsr $1a0c84	            JSR TOKEVAL
.1a2340	c2 20		rep #$20	            REP #$20
.1a2342	85 2f		sta $082f	            STA JMP16PTR        ; Store it in the jump pointer
.1a2344	20 8b 19	jsr $1a198b	            JSR INITEVALSP
.1a2347	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a234a	20 28 23	jsr $1a2328	            JSR STSTUB
.1a234d	ab		plb		done        PLB
.1a234e	2b		pld		            PLD
.1a234f	28		plp		            PLP
.1a2350	60		rts		            RTS
.1a2351					EXECCMD
.1a2351	08		php		            PHP
.1a2352	58		cli		            CLI
.1a2353	20 de 20	jsr $1a20de	            JSR SETINTERACT
.1a2356	20 03 1e	jsr $1a1e03	            JSR INITRETURN
.1a2359	e2 20		sep #$20	            SEP #$20
.1a235b	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.1a235e	c2 20		rep #$20	            REP #$20
.1a2360	a5 1a		lda $081a	            LDA CURLINE         ; Set the BASIC Instruction Pointer to the first byte of the line
.1a2362	85 00		sta $0800	            STA BIP
.1a2364	a5 1c		lda $081c	            LDA CURLINE+2
.1a2366	85 02		sta $0802	            STA BIP+2
.1a2368	4c 8f 23	jmp $1a238f	            JMP exec_loop
.1a236b	08		php		EXECLINE    PHP
.1a236c	c2 20		rep #$20	            REP #$20
.1a236e	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER            ; Set the current line number
.1a2371	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.1a2373	85 d7		sta $08d7	            STA LINENUM
.1a2375	e2 20		sep #$20	            SEP #$20
.1a2377	a5 dc		lda $08dc	            LDA EXECACTION              ; If the last EXEC action was RETURN
.1a2379	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; BIP has already been set, so...
.1a237b	f0 12		beq $1a238f	            BEQ exec_loop               ; Skip over setting the BIP to the beginning of the line
.1a237d	c2 20		rep #$20	            REP #$20
.1a237f	18		clc		            CLC                         ; Set the BASIC Instruction Pointer to the first byte of the line
.1a2380	a5 1a		lda $081a	            LDA CURLINE
.1a2382	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a2385	85 00		sta $0800	            STA BIP
.1a2387	e2 20		sep #$20	            SEP #$20
.1a2389	a5 1c		lda $081c	            LDA CURLINE+2
.1a238b	69 00		adc #$00	            ADC #0
.1a238d	85 02		sta $0802	            STA BIP+2
.1a238f					exec_loop
.1a238f	c2 20		rep #$20	            REP #$20
.1a2391	20 99 22	jsr $1a2299	            JSR EXECSTMT
.1a2394	e2 20		sep #$20	            SEP #$20
.1a2396	a5 dc		lda $08dc	            LDA EXECACTION
.1a2398	c9 03		cmp #$03	            CMP #EXEC_RETURN
.1a239a	f0 f3		beq $1a238f	            BEQ exec_loop
.1a239c	c9 00		cmp #$00	            CMP #EXEC_CONT              ; If it's not EXEC_CONT, exit to the caller
.1a239e	d0 31		bne $1a23d1	            BNE exec_done
.1a23a0	e2 20		sep #$20	            SEP #$20
.1a23a2	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a23a5	a7 00		lda [$0800]	            LDA [BIP]                   ; Get the current character in the line
.1a23a7	f0 28		beq $1a23d1	            BEQ exec_done               ; If it's NULL, we're done
.1a23a9	c9 3a		cmp #$3a	            CMP #':'                    ; If it's colon, we have more statements
.1a23ab	f0 1f		beq $1a23cc	            BEQ skip_loop               ; Skip over it and try to execute the next one
.1a23ad	08		php		            PHP
.1a23ae	c2 20		rep #$20	            REP #$20
.1a23b0	48		pha		            PHA
.1a23b1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a23b4	5b		tcd		            TCD
.1a23b5	68		pla		            PLA
.1a23b6	28		plp		            PLP
.1a23b7	e2 20		sep #$20	            SEP #$20
.1a23b9	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a23bb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a23bf	c2 20		rep #$20	            REP #$20
.1a23c1	29 ff 00	and #$00ff	            AND #$00FF
.1a23c4	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a23c7	e2 20		sep #$20	            SEP #$20
.1a23c9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a23cc					skip_loop
.1a23cc	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a23cf	80 be		bra $1a238f	            BRA exec_loop               ; And try to execute another statement
.1a23d1					exec_done
.1a23d1	28		plp		            PLP
.1a23d2	60		rts		            RTS
.1a23d3					EXECPROGRAM
.1a23d3	08		php		            PHP
.1a23d4	58		cli		            CLI
.1a23d5	e2 20		sep #$20	            SEP #$20
.1a23d7	a9 80		lda #$80	            LDA #ST_RUNNING
.1a23d9	85 d2		sta $08d2	            STA STATE
.1a23db	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.1a23de	20 03 1e	jsr $1a1e03	            JSR INITRETURN
.1a23e1	c2 30		rep #$30	            REP #$30
.1a23e3	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the count of GOSUBs
.1a23e5	a0 02 00	ldy #$0002	exec_loop   LDY #LINE_NUMBER
.1a23e8	b7 1a		lda [$081a],y	            LDA [CURLINE],Y             ; Get the line number of the current line
.1a23ea	f0 29		beq $1a2415	            BEQ done                    ; If it's 0, we are finished running code (implicit END)
.1a23ec	20 6b 23	jsr $1a236b	            JSR EXECLINE
.1a23ef	e2 20		sep #$20	            SEP #$20
.1a23f1	a5 dc		lda $08dc	            LDA EXECACTION              ; Check the EXECACTION from the last line
.1a23f3	c9 01		cmp #$01	            CMP #EXEC_STOP              ; Stop execution of the program?
.1a23f5	f0 1e		beq $1a2415	            BEQ done
.1a23f7	c9 02		cmp #$02	            CMP #EXEC_GOTO              ; Transfer execution to a new CURLINE that is already set
.1a23f9	f0 ea		beq $1a23e5	            BEQ exec_loop
.1a23fb	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; Transfer execution to the CURLINE and BIP that is already set
.1a23fd	f0 e6		beq $1a23e5	            BEQ exec_loop
.1a23ff	c2 20		rep #$20	            REP #$20
.1a2401	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a2404	18		clc		            CLC
.1a2405	a5 1a		lda $081a	            LDA CURLINE
.1a2407	77 1a		adc [$081a],y	            ADC [CURLINE],Y
.1a2409	85 1a		sta $081a	            STA CURLINE
.1a240b	e2 20		sep #$20	            SEP #$20
.1a240d	a5 1c		lda $081c	            LDA CURLINE+2
.1a240f	69 00		adc #$00	            ADC #0
.1a2411	85 1c		sta $081c	            STA CURLINE+2
.1a2413	80 d0		bra $1a23e5	            BRA exec_loop               ; And try to execute that line
.1a2415					done
.1a2415	e2 20		sep #$20	            SEP #$20
.1a2417	a9 00		lda #$00	            LDA #ST_INTERACT            ; Set interpreter state to RUNNING
.1a2419	85 d2		sta $08d2	            STA STATE
.1a241b	28		plp		            PLP
.1a241c	60		rts		            RTS
.1a241d					FINDLINE
.1a241d	08		php		            PHP
.1a241e	c2 30		rep #$30	            REP #$30
.1a2420	c2 20		rep #$20	            REP #$20
.1a2422	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT            ; INDEX points to the first line of the program
.1a2425	85 08		sta $0808	            STA INDEX
.1a2427	a9 16 00	lda #$0016	            LDA #`BASIC_BOT
.1a242a	85 0a		sta $080a	            STA INDEX+2
.1a242c	c2 20		rep #$20	            REP #$20
.1a242e	a0 02 00	ldy #$0002	check_nmbrs LDY #LINE_NUMBER            ; Get the number of the possible target line
.1a2431	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a2433	f0 31		beq $1a2466	            BEQ ret_false               ; If new line number is 0, we got to the
.1a2435	c5 23		cmp $0823	            CMP ARGUMENT1               ; Compare it to the target line number
.1a2437	f0 1e		beq $1a2457	            BEQ found
.1a2439	b0 2b		bcs $1a2466	            BGE ret_false               ; If the line number > target line number, the line is not present
.1a243b					next_line
.1a243b	c2 20		rep #$20	            REP #$20
.1a243d	a0 00 00	ldy #$0000	            LDY #LINE_LINK              ; INDEX := INDEX + [INDEX].LINK
.1a2440	18		clc		            CLC
.1a2441	a5 08		lda $0808	            LDA INDEX
.1a2443	77 08		adc [$0808],y	            ADC [INDEX],Y
.1a2445	85 0c		sta $080c	            STA SCRATCH
.1a2447	e2 20		sep #$20	            SEP #$20
.1a2449	a5 0a		lda $080a	            LDA INDEX+2
.1a244b	69 00		adc #$00	            ADC #0
.1a244d	85 0a		sta $080a	            STA INDEX+2
.1a244f	c2 20		rep #$20	            REP #$20
.1a2451	a5 0c		lda $080c	            LDA SCRATCH
.1a2453	85 08		sta $0808	            STA INDEX
.1a2455	80 d7		bra $1a242e	            BRA check_nmbrs             ; And go back to check the new line INDEX is pointing to
.1a2457					found
.1a2457	c2 20		rep #$20	            REP #$20
.1a2459	a5 08		lda $0808	            LDA INDEX
.1a245b	85 1a		sta $081a	            STA CURLINE
.1a245d	e2 20		sep #$20	            SEP #$20
.1a245f	a5 0a		lda $080a	            LDA INDEX+2
.1a2461	85 1c		sta $081c	            STA CURLINE+2
.1a2463	28		plp		ret_true    PLP                         ; Return true to indicate we've found the line
.1a2464	38		sec		            SEC
.1a2465	60		rts		            RTS
.1a2466	28		plp		ret_false   PLP
.1a2467	18		clc		            CLC
.1a2468	60		rts		            RTS
.1a2469					MVPROGDN
.1a2469	08		php		            PHP
.1a246a					mvd_loop
.1a246a	e2 20		sep #$20	            SEP #$20
.1a246c	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.1a246e	87 08		sta [$0808]	            STA [INDEX]
.1a2470	c2 20		rep #$20	            REP #$20
.1a2472	a5 0c		lda $080c	            LDA SCRATCH
.1a2474	c5 00		cmp $0800	            CMP BIP
.1a2476	d0 08		bne $1a2480	            BNE increment
.1a2478	e2 20		sep #$20	            SEP #$20
.1a247a	a5 0e		lda $080e	            LDA SCRATCH+2
.1a247c	c5 02		cmp $0802	            CMP BIP+2
.1a247e	f0 26		beq $1a24a6	            BEQ done            ; Yes: return
.1a2480					increment
.1a2480	c2 20		rep #$20	            REP #$20
.1a2482	18		clc		            CLC
.1a2483	a5 0c		lda $080c	            LDA SCRATCH
.1a2485	69 01 00	adc #$0001	            ADC #1
.1a2488	85 0c		sta $080c	            STA SCRATCH
.1a248a	e2 20		sep #$20	            SEP #$20
.1a248c	a5 0e		lda $080e	            LDA SCRATCH+2
.1a248e	69 00		adc #$00	            ADC #0
.1a2490	85 0e		sta $080e	            STA SCRATCH+2
.1a2492	c2 20		rep #$20	            REP #$20
.1a2494	18		clc		            CLC
.1a2495	a5 08		lda $0808	            LDA INDEX
.1a2497	69 01 00	adc #$0001	            ADC #1
.1a249a	85 08		sta $0808	            STA INDEX
.1a249c	e2 20		sep #$20	            SEP #$20
.1a249e	a5 0a		lda $080a	            LDA INDEX+2
.1a24a0	69 00		adc #$00	            ADC #0
.1a24a2	85 0a		sta $080a	            STA INDEX+2
.1a24a4	80 c4		bra $1a246a	            BRA mvd_loop        ; And try again
.1a24a6	28		plp		done        PLP
.1a24a7	60		rts		            RTS
.1a24a8					MVPROGUP
.1a24a8	08		php		            PHP
.1a24a9					mvu_loop
.1a24a9	e2 20		sep #$20	            SEP #$20
.1a24ab	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.1a24ad	87 08		sta [$0808]	            STA [INDEX]
.1a24af	c2 20		rep #$20	            REP #$20
.1a24b1	a5 0c		lda $080c	            LDA SCRATCH
.1a24b3	c5 00		cmp $0800	            CMP BIP
.1a24b5	d0 06		bne $1a24bd	            BNE decrement
.1a24b7	a5 0e		lda $080e	            LDA SCRATCH+2
.1a24b9	c5 02		cmp $0802	            CMP BIP+2
.1a24bb	f0 26		beq $1a24e3	            BEQ done            ; Yes: return
.1a24bd					decrement
.1a24bd	c2 20		rep #$20	            REP #$20
.1a24bf	38		sec		            SEC
.1a24c0	a5 0c		lda $080c	            LDA SCRATCH
.1a24c2	e9 01 00	sbc #$0001	            SBC #1
.1a24c5	85 0c		sta $080c	            STA SCRATCH
.1a24c7	e2 20		sep #$20	            SEP #$20
.1a24c9	a5 0e		lda $080e	            LDA SCRATCH+2
.1a24cb	e9 00		sbc #$00	            SBC #0
.1a24cd	85 0e		sta $080e	            STA SCRATCH+2
.1a24cf	c2 20		rep #$20	            REP #$20
.1a24d1	38		sec		            SEC
.1a24d2	a5 08		lda $0808	            LDA INDEX
.1a24d4	e9 01 00	sbc #$0001	            SBC #1
.1a24d7	85 08		sta $0808	            STA INDEX
.1a24d9	e2 20		sep #$20	            SEP #$20
.1a24db	a5 0a		lda $080a	            LDA INDEX+2
.1a24dd	e9 00		sbc #$00	            SBC #0
.1a24df	85 0a		sta $080a	            STA INDEX+2
.1a24e1	80 c6		bra $1a24a9	            BRA mvu_loop        ; And try again
.1a24e3	28		plp		done        PLP
.1a24e4	60		rts		            RTS
.1a24e5					DELLINE
.1a24e5	08		php		            PHP
.1a24e6	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; SCRATCH := INDEX + [INDEX].LINK (address of the following line)
.1a24e9	c2 20		rep #$20	            REP #$20
.1a24eb	18		clc		            CLC
.1a24ec	a5 08		lda $0808	            LDA INDEX
.1a24ee	77 08		adc [$0808],y	            ADC [INDEX],Y
.1a24f0	85 0c		sta $080c	            STA SCRATCH
.1a24f2	e2 20		sep #$20	            SEP #$20
.1a24f4	a5 0a		lda $080a	            LDA INDEX+2
.1a24f6	69 00		adc #$00	            ADC #0
.1a24f8	85 0e		sta $080e	            STA SCRATCH+2
.1a24fa	c2 20		rep #$20	            REP #$20
.1a24fc	18		clc		            CLC
.1a24fd	a5 d9		lda $08d9	            LDA LASTLINE
.1a24ff	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a2502	85 00		sta $0800	            STA BIP
.1a2504	e2 20		sep #$20	            SEP #$20
.1a2506	a5 db		lda $08db	            LDA LASTLINE+2
.1a2508	69 00		adc #$00	            ADC #0
.1a250a	85 02		sta $0802	            STA BIP+2
.1a250c	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; LASTLINE := LASTLINE - [INDEX].LINK
.1a250f	c2 20		rep #$20	            REP #$20
.1a2511	38		sec		            SEC
.1a2512	a5 d9		lda $08d9	            LDA LASTLINE
.1a2514	f7 08		sbc [$0808],y	            SBC [INDEX],Y
.1a2516	85 d9		sta $08d9	            STA LASTLINE
.1a2518	e2 20		sep #$20	            SEP #$20
.1a251a	a5 db		lda $08db	            LDA LASTLINE+2
.1a251c	e9 00		sbc #$00	            SBC #0
.1a251e	85 db		sta $08db	            STA LASTLINE+2
.1a2520	20 69 24	jsr $1a2469	            JSR MVPROGDN
.1a2523					done
.1a2523	20 c5 44	jsr $1a44c5	            JSR S_CLR
.1a2526	28		plp		            PLP
.1a2527	60		rts		            RTS
.1a2528					APPLINE
.1a2528	08		php		            PHP
.1a2529	08		php		            PHP
.1a252a	c2 20		rep #$20	            REP #$20
.1a252c	48		pha		            PHA
.1a252d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a2530	5b		tcd		            TCD
.1a2531	68		pla		            PLA
.1a2532	28		plp		            PLP
.1a2533	c2 30		rep #$30	            REP #$30
.1a2535	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the line number of the new line
.1a2538	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.1a253a	18		clc		            CLC                 ; Point INDEX to the position to store the tokens
.1a253b	a5 d9		lda $08d9	            LDA LASTLINE
.1a253d	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a2540	85 08		sta $0808	            STA INDEX
.1a2542	e2 20		sep #$20	            SEP #$20
.1a2544	a5 db		lda $08db	            LDA LASTLINE+2
.1a2546	69 00		adc #$00	            ADC #0
.1a2548	85 0a		sta $080a	            STA INDEX+2
.1a254a	e2 20		sep #$20	            SEP #$20
.1a254c	a0 00 00	ldy #$0000	            LDY #0
.1a254f	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Copy the tokenized line to its place in the code
.1a2551	97 08		sta [$0808],y	            STA [INDEX],Y
.1a2553	f0 03		beq $1a2558	            BEQ copy_done
.1a2555	c8		iny		            INY
.1a2556	80 f7		bra $1a254f	            BRA copy_loop
.1a2558					copy_done
.1a2558	c2 20		rep #$20	            REP #$20
.1a255a	98		tya		            TYA
.1a255b	18		clc		            CLC
.1a255c	69 05 00	adc #$0005	            ADC #LINE_TOKENS+1
.1a255f	85 0c		sta $080c	            STA SCRATCH
.1a2561	c2 20		rep #$20	            REP #$20
.1a2563	a0 00 00	ldy #$0000	            LDY #LINE_LINK      ; Set link to the offset to the next line
.1a2566	a5 0c		lda $080c	            LDA SCRATCH
.1a2568	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.1a256a	c2 20		rep #$20	            REP #$20
.1a256c	18		clc		            CLC
.1a256d	a5 d9		lda $08d9	            LDA LASTLINE
.1a256f	65 0c		adc $080c	            ADC SCRATCH
.1a2571	85 0c		sta $080c	            STA SCRATCH
.1a2573	e2 20		sep #$20	            SEP #$20
.1a2575	a5 db		lda $08db	            LDA LASTLINE+2
.1a2577	69 00		adc #$00	            ADC #0
.1a2579	85 db		sta $08db	            STA LASTLINE+2
.1a257b	c2 20		rep #$20	            REP #$20
.1a257d	a5 0c		lda $080c	            LDA SCRATCH
.1a257f	85 d9		sta $08d9	            STA LASTLINE
.1a2581	c2 20		rep #$20	            REP #$20
.1a2583	a0 00 00	ldy #$0000	            LDY #0
.1a2586	a9 00 00	lda #$0000	            LDA #0
.1a2589	97 d9		sta [$08d9],y	blank_loop  STA [LASTLINE],Y    ; Set the "line" after the last line to nulls
.1a258b	c8		iny		            INY
.1a258c	c0 05 00	cpy #$0005	            CPY #LINE_TOKENS+1
.1a258f	d0 f8		bne $1a2589	            BNE blank_loop
.1a2591	20 c5 44	jsr $1a44c5	            JSR S_CLR
.1a2594	28		plp		            PLP
.1a2595	60		rts		            RTS
.1a2596					FINDINSPT
.1a2596	0b		phd		            PHD
.1a2597	08		php		            PHP
.1a2598	08		php		            PHP
.1a2599	c2 20		rep #$20	            REP #$20
.1a259b	48		pha		            PHA
.1a259c	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a259f	5b		tcd		            TCD
.1a25a0	68		pla		            PLA
.1a25a1	28		plp		            PLP
.1a25a2	c2 30		rep #$30	            REP #$30
.1a25a4	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.1a25a7	85 08		sta $0808	            STA INDEX
.1a25a9	a9 16 00	lda #$0016	            LDA #`BASIC_BOT
.1a25ac	85 0a		sta $080a	            STA INDEX+2
.1a25ae	a0 02 00	ldy #$0002	loop        LDY #LINE_NUMBER
.1a25b1	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a25b3	f0 1d		beq $1a25d2	            BEQ found_end           ; Got to end without finding it
.1a25b5	c5 d7		cmp $08d7	            CMP LINENUM
.1a25b7	f0 25		beq $1a25de	            BEQ found_line          ; LINENUM = [INDEX].LINE_NUMBER: return we found the exact line
.1a25b9	b0 1d		bcs $1a25d8	            BGE found_spot          ; LINENUM > [INDEX].LINE_NUMBER: return we found spot to insert
.1a25bb	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a25be	18		clc		            CLC                     ; Move INDEX to the next line
.1a25bf	a5 08		lda $0808	            LDA INDEX
.1a25c1	77 08		adc [$0808],y	            ADC [INDEX],Y
.1a25c3	85 0c		sta $080c	            STA SCRATCH
.1a25c5	a5 0a		lda $080a	            LDA INDEX+2
.1a25c7	69 00 00	adc #$0000	            ADC #0
.1a25ca	85 0a		sta $080a	            STA INDEX+2
.1a25cc	a5 0c		lda $080c	            LDA SCRATCH
.1a25ce	85 08		sta $0808	            STA INDEX
.1a25d0	80 dc		bra $1a25ae	            BRA loop                ; And check that line
.1a25d2	a9 00 00	lda #$0000	found_end   LDA #0                  ; Return that we reached the end of the program
.1a25d5	28		plp		            PLP
.1a25d6	2b		pld		            PLD
.1a25d7	60		rts		            RTS
.1a25d8	a9 01 00	lda #$0001	found_spot  LDA #1                  ; Return that we the found the spot to insert the line
.1a25db	28		plp		            PLP                     ; But that it wasn't already there
.1a25dc	2b		pld		            PLD
.1a25dd	60		rts		            RTS
.1a25de	a9 02 00	lda #$0002	found_line  LDA #2                  ; Return that we found the line
.1a25e1	28		plp		            PLP
.1a25e2	2b		pld		            PLD
.1a25e3	60		rts		            RTS
.1a25e4					INSLINE
.1a25e4	08		php		            PHP
.1a25e5	c2 30		rep #$30	            REP #$30
.1a25e7	a9 05 00	lda #$0005	            LDA #LINE_TOKENS+1  ; Set SCRATCH2 to the size of the line header with the end-of-line
.1a25ea	85 10		sta $0810	            STA SCRATCH2
.1a25ec	a0 00 00	ldy #$0000	            LDY #0
.1a25ef					count_loop
.1a25ef	e2 20		sep #$20	            SEP #$20
.1a25f1	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the byte of the line
.1a25f3	f0 07		beq $1a25fc	            BEQ shift_prog      ; If it's end-of-line, SCRATCH2 is the length
.1a25f5	c2 20		rep #$20	            REP #$20
.1a25f7	e6 10		inc $0810	            INC SCRATCH2
.1a25f9	c8		iny		            INY
.1a25fa	80 f3		bra $1a25ef	            BRA count_loop      ; Count and continue
.1a25fc					shift_prog
.1a25fc	c2 20		rep #$20	            REP #$20
.1a25fe	a5 08		lda $0808	            LDA INDEX           ; BIP = the address of the first byte for the new line
.1a2600	85 00		sta $0800	            STA BIP
.1a2602	a5 0a		lda $080a	            LDA INDEX+2
.1a2604	85 02		sta $0802	            STA BIP+2
.1a2606	18		clc		            CLC                 ; SCRATCH = address of highest byte to copy
.1a2607	a5 d9		lda $08d9	            LDA LASTLINE
.1a2609	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a260c	85 0c		sta $080c	            STA SCRATCH
.1a260e	a5 db		lda $08db	            LDA LASTLINE+2
.1a2610	69 00 00	adc #$0000	            ADC #0
.1a2613	85 0e		sta $080e	            STA SCRATCH+2
.1a2615	18		clc		            CLC                 ; Adjust LASTLINE to its new position after the insert
.1a2616	a5 d9		lda $08d9	            LDA LASTLINE
.1a2618	65 10		adc $0810	            ADC SCRATCH2
.1a261a	85 d9		sta $08d9	            STA LASTLINE
.1a261c	a5 db		lda $08db	            LDA LASTLINE+2
.1a261e	69 00 00	adc #$0000	            ADC #0
.1a2621	85 db		sta $08db	            STA LASTLINE+2
.1a2623	18		clc		            CLC                 ; INDEX = address of the highest location to copy into
.1a2624	a5 d9		lda $08d9	            LDA LASTLINE
.1a2626	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a2629	85 08		sta $0808	            STA INDEX
.1a262b	a5 db		lda $08db	            LDA LASTLINE+2
.1a262d	69 00 00	adc #$0000	            ADC #0
.1a2630	85 0a		sta $080a	            STA INDEX+2
.1a2632	20 a8 24	jsr $1a24a8	            JSR MVPROGUP
.1a2635	c2 20		rep #$20	            REP #$20
.1a2637	a5 10		lda $0810	            LDA SCRATCH2
.1a2639	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a263c	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINK_LINK = length of the new line
.1a263e	a5 d7		lda $08d7	            LDA LINENUM
.1a2640	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.1a2643	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINE_NUMBER = number of the new line
.1a2645	18		clc		            CLC                 ; Point BIP to the first byte of the new line
.1a2646	a5 00		lda $0800	            LDA BIP
.1a2648	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a264b	85 00		sta $0800	            STA BIP
.1a264d	a5 02		lda $0802	            LDA BIP+2
.1a264f	69 00 00	adc #$0000	            ADC #0
.1a2652	85 02		sta $0802	            STA BIP+2
.1a2654	a0 00 00	ldy #$0000	            LDY #0
.1a2657	e2 20		sep #$20	            SEP #$20
.1a2659	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Get the byte of the tokenized line
.1a265b	97 00		sta [$0800],y	            STA [BIP],Y         ; Copy it to its correct location in the program
.1a265d	f0 03		beq $1a2662	            BEQ done            ; If it was end-of-line byte, we're done
.1a265f	c8		iny		            INY
.1a2660	80 f7		bra $1a2659	            BRA copy_loop       ; Otherwise, continue with the next
.1a2662					done
.1a2662	20 c5 44	jsr $1a44c5	            JSR S_CLR
.1a2665	28		plp		            PLP
.1a2666	60		rts		            RTS
.1a2667					ADDLINE
.1a2667	08		php		            PHP
.1a2668	c2 30		rep #$30	            REP #$30
.1a266a	85 d7		sta $08d7	            STA LINENUM
.1a266c	20 96 25	jsr $1a2596	            JSR FINDINSPT
.1a266f	c9 00 00	cmp #$0000	            CMP #0
.1a2672	f0 2c		beq $1a26a0	            BEQ do_append       ; End-of-program found, add the line to the end
.1a2674	c9 01 00	cmp #$0001	            CMP #1
.1a2677	f0 22		beq $1a269b	            BEQ do_insert       ; Spot was found: insertion required
.1a2679	c2 20		rep #$20	            REP #$20
.1a267b	a5 08		lda $0808	            LDA INDEX
.1a267d	48		pha		            PHA
.1a267e	a5 0a		lda $080a	            LDA INDEX+2
.1a2680	48		pha		            PHA
.1a2681	20 e5 24	jsr $1a24e5	            JSR DELLINE
.1a2684	68		pla		            PLA
.1a2685	85 0a		sta $080a	            STA INDEX+2
.1a2687	68		pla		            PLA
.1a2688	85 08		sta $0808	            STA INDEX
.1a268a	a5 1a		lda $081a	            LDA CURLINE         ; Check to see if there is any non-whitespace on the line
.1a268c	85 00		sta $0800	            STA BIP
.1a268e	a5 1c		lda $081c	            LDA CURLINE+2
.1a2690	85 02		sta $0802	            STA BIP+2
.1a2692	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a2695	e2 20		sep #$20	            SEP #$20
.1a2697	a7 00		lda [$0800]	            LDA [BIP]
.1a2699	f0 0a		beq $1a26a5	            BEQ done            ; If not, we're done
.1a269b					do_insert
.1a269b	20 e4 25	jsr $1a25e4	            JSR INSLINE
.1a269e	80 05		bra $1a26a5	            BRA done
.1a26a0	a5 d7		lda $08d7	do_append   LDA LINENUM
.1a26a2	20 28 25	jsr $1a2528	            JSR APPLINE
.1a26a5	28		plp		done        PLP
.1a26a6	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\repl.s

="#"					CHAR_DIR = '#'
="|"					CHAR_BRUN = '|'
.1a26a7					EXPANDLINE
.1a26a7	0b		phd		                PHD
.1a26a8	08		php		                PHP
.1a26a9	08		php		            PHP
.1a26aa	c2 20		rep #$20	            REP #$20
.1a26ac	48		pha		            PHA
.1a26ad	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a26b0	5b		tcd		            TCD
.1a26b1	68		pla		            PLA
.1a26b2	28		plp		            PLP
.1a26b3	e2 20		sep #$20	            SEP #$20
.1a26b5	c2 10		rep #$10	            REP #$10
.1a26b7	a2 00 00	ldx #$0000	                LDX #0
.1a26ba	bd 00 4f	lda $4f00,x	count_loop      LDA INPUTBUF,X              ; Count the number of characters in the input
.1a26bd	f0 03		beq $1a26c2	                BEQ save_size
.1a26bf	e8		inx		                INX
.1a26c0	80 f8		bra $1a26ba	                BRA count_loop
.1a26c2	86 0c		stx $080c	save_size       STX SCRATCH                 ; Save the size in SCRATCH
.1a26c4	c2 30		rep #$30	            REP #$30
.1a26c6	8a		txa		                TXA
.1a26c7	c9 02 00	cmp #$0002	                CMP #2                      ; Are there arguments?
.1a26ca	90 12		bcc $1a26de	                BLT start_copy              ; No: just replace the whole string
.1a26cc	3a		dec a		                DEC A
.1a26cd	18		clc		                CLC
.1a26ce	69 00 4f	adc #$4f00	                ADC #<>INPUTBUF
.1a26d1	aa		tax		                TAX                         ; X <-- INPUTBUF + len(INPUTBUF) - 1
.1a26d2	18		clc		                CLC                         ; Y <-- INPUTBUF + len(INPUTBUF) - 1 + len(substitution)
.1a26d3	65 8f		adc $088f	                ADC MCOUNT
.1a26d5	a8		tay		                TAY
.1a26d6	a5 0c		lda $080c	                LDA SCRATCH
.1a26d8	3a		dec a		                DEC A
.1a26d9	8b		phb		                PHB
.1a26da	44 00 00	mvp #$00,#$00	                MVP #`INPUTBUF,#`INPUTBUF   ; Make room for the substitition
.1a26dd	ab		plb		                PLB
.1a26de					start_copy
.1a26de	c2 20		rep #$20	            REP #$20
.1a26e0	a6 55		ldx $0855	                LDX MARG1                   ; Source is data to copy
.1a26e2	a0 00 4f	ldy #$4f00	                LDY #<>INPUTBUF             ; Destination is input buffer
.1a26e5	a5 8f		lda $088f	                LDA MCOUNT                  ; Number of bytes to copy
.1a26e7	8b		phb		                PHB
.1a26e8	54 00 1a	mvn #$1a,#$00	                MVN #`EXPANDLINE,#`INPUTBUF ; Copy the data
.1a26eb	ab		plb		                PLB
.1a26ec	e2 20		sep #$20	            SEP #$20
.1a26ee	a5 0c		lda $080c	                LDA SCRATCH                 ; Check again to see if we need quotes
.1a26f0	c9 02		cmp #$02	                CMP #2
.1a26f2	90 18		bcc $1a270c	                BLT done
.1a26f4	a6 8f		ldx $088f	                LDX MCOUNT                  ; If so, add a quote mark here
.1a26f6	a9 22		lda #$22	                LDA #CHAR_DQUOTE
.1a26f8	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a26fb	e8		inx		skip_to_end     INX                         ; Move to the end of the input string
.1a26fc	bd 00 4f	lda $4f00,x	                LDA INPUTBUF,X
.1a26ff	d0 fa		bne $1a26fb	                BNE skip_to_end
.1a2701	a9 22		lda #$22	                LDA #CHAR_DQUOTE            ; Add the quote to the end of the string
.1a2703	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a2706	a9 00		lda #$00	                LDA #0                      ; And terminate with a NULL
.1a2708	e8		inx		                INX
.1a2709	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a270c	28		plp		done            PLP
.1a270d	2b		pld		                PLD
.1a270e	60		rts		            RTS
.1a270f					PREPROCESS
.1a270f	da		phx		                PHX
.1a2710	5a		phy		                PHY
.1a2711	8b		phb		                PHB
.1a2712	0b		phd		                PHD
.1a2713	08		php		                PHP
.1a2714	08		php		            PHP
.1a2715	c2 20		rep #$20	            REP #$20
.1a2717	48		pha		            PHA
.1a2718	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a271b	5b		tcd		            TCD
.1a271c	68		pla		            PLA
.1a271d	28		plp		            PLP
.1a271e	e2 20		sep #$20	            SEP #$20
.1a2720	c2 10		rep #$10	            REP #$10
.1a2722	ad 00 4f	lda $4f00	                LDA INPUTBUF            ; Check the first character
.1a2725	c9 23		cmp #$23	                CMP #CHAR_DIR           ; Is it the DIR character?
.1a2727	f0 0a		beq $1a2733	                BEQ expand_dir          ; Yes: expand the DIR command into place
.1a2729	c9 7c		cmp #$7c	                CMP #CHAR_BRUN          ; Is it the BRUN character?
.1a272b	f0 17		beq $1a2744	                BEQ expand_brun         ; Yes: expand the BRUN command into place
.1a272d	28		plp		done            PLP
.1a272e	2b		pld		                PLD
.1a272f	ab		plb		                PLB
.1a2730	7a		ply		                PLY
.1a2731	fa		plx		                PLX
.1a2732	60		rts		            RTS
.1a2733					expand_dir
.1a2733	c2 20		rep #$20	            REP #$20
.1a2735	a9 03 00	lda #$0003	                LDA #3                  ; Set size of substitution value
.1a2738	85 8f		sta $088f	                STA MCOUNT
.1a273a	a9 55 27	lda #$2755	                LDA #<>dir_text         ; Set pointer to substitution value
.1a273d	85 55		sta $0855	                STA MARG1
.1a273f	20 a7 26	jsr $1a26a7	            JSR EXPANDLINE
.1a2742	80 e9		bra $1a272d	                BRA done
.1a2744					expand_brun
.1a2744	c2 20		rep #$20	            REP #$20
.1a2746	a9 04 00	lda #$0004	                LDA #4                  ; Set size of substitution value
.1a2749	85 8f		sta $088f	                STA MCOUNT
.1a274b	a9 59 27	lda #$2759	                LDA #<>brun_text        ; Set pointer to substitution value
.1a274e	85 55		sta $0855	                STA MARG1
.1a2750	20 a7 26	jsr $1a26a7	            JSR EXPANDLINE
.1a2753	80 d8		bra $1a272d	                BRA done
>1a2755	44 49 52 00			dir_text        .null "DIR"             ; Expansion of the DIR character
>1a2759	42 52 55 4e 00			brun_text       .null "BRUN"            ; Expansion of the BRUN character
.1a275e					PRREADY
.1a275e	8b		phb		                PHB
.1a275f	08		php		                PHP
.1a2760	20 3d 02	jsr $1a023d	            JSR ENSURETEXT
.1a2763	08		php		            PHP
.1a2764	e2 20		sep #$20	            SEP #$20
.1a2766	48		pha		            PHA
.1a2767	a9 1a		lda #$1a	            LDA #`MPROMPT
.1a2769	48		pha		            PHA
.1a276a	ab		plb		            PLB
.1a276b	68		pla		            PLA
.1a276c	28		plp		            PLP
.1a276d	a2 6f d2	ldx #$d26f	                LDX #<>MPROMPT
.1a2770	20 64 04	jsr $1a0464	            JSR PRINTS
.1a2773	28		plp		                PLP
.1a2774	ab		plb		                PLB
.1a2775	60		rts		            RTS
.1a2776					IREADLINE
.1a2776	08		php		                PHP
.1a2777	e2 30		sep #$30	            SEP #$30
.1a2779	a9 01		lda #$01	                LDA #1
.1a277b	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a277e					read_loop
.1a277e	20 db 00	jsr $1a00db	            JSR GETKEYE
.1a2781	c9 00		cmp #$00	                CMP #0
.1a2783	f0 f9		beq $1a277e	                BEQ read_loop
.1a2785	c9 0d		cmp #$0d	                CMP #CHAR_CR
.1a2787	f0 02		beq $1a278b	                BEQ done
.1a2789	80 f3		bra $1a277e	                BRA read_loop
.1a278b	28		plp		done            PLP
.1a278c	60		rts		            RTS
.1a278d					PROCESS
.1a278d	0b		phd		                PHD
.1a278e	08		php		                PHP
.1a278f	08		php		            PHP
.1a2790	c2 20		rep #$20	            REP #$20
.1a2792	48		pha		            PHA
.1a2793	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a2796	5b		tcd		            TCD
.1a2797	68		pla		            PLA
.1a2798	28		plp		            PLP
.1a2799	c2 30		rep #$30	            REP #$30
.1a279b	64 d7		stz $08d7	                STZ LINENUM
.1a279d	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF         ; Attempt to tokenize the line that was read
.1a27a0	85 1a		sta $081a	                STA CURLINE
.1a27a2	a9 00 00	lda #$0000	                LDA #`CURLINE
.1a27a5	85 1c		sta $081c	                STA CURLINE+2
.1a27a7	20 9c 09	jsr $1a099c	            JSR TOKENIZE
.1a27aa	c2 20		rep #$20	            REP #$20
.1a27ac	a5 d7		lda $08d7	                LDA LINENUM             ; Did we get a line number?
.1a27ae	d0 05		bne $1a27b5	                BNE update_line         ; Yes: attempt to add it to the program
.1a27b0	20 51 23	jsr $1a2351	            JSR EXECCMD
.1a27b3	80 07		bra $1a27bc	                BRA done
.1a27b5					update_line
.1a27b5	20 67 26	jsr $1a2667	            JSR ADDLINE
.1a27b8	28		plp		no_prompt       PLP
.1a27b9	2b		pld		                PLD
.1a27ba	38		sec		                SEC
.1a27bb	60		rts		            RTS
.1a27bc	28		plp		done            PLP
.1a27bd	2b		pld		                PLD
.1a27be	18		clc		                CLC
.1a27bf	60		rts		            RTS
.1a27c0					INTERACT
.1a27c0	c2 30		rep #$30	            REP #$30
.1a27c2	a2 ff fe	ldx #$feff	                LDX #<>STACK_END
.1a27c5	9a		txs		                TXS
.1a27c6					ready_loop
.1a27c6	20 5e 27	jsr $1a275e	            JSR PRREADY
.1a27c9					no_ready_loop
.1a27c9	20 08 00	jsr $1a0008	            JSR READLINE
.1a27cc	20 0c 00	jsr $1a000c	            JSR SCRCOPYLINE
.1a27cf	22 3c 11 00	jsl $00113c	                JSL FK_TESTBREAK    ; Make sure the BREAK bit is cleared.
.1a27d3	a9 00 00	lda #$0000	                LDA #0              ; Hide the cursor
.1a27d6	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a27d9	20 0f 27	jsr $1a270f	            JSR PREPROCESS
.1a27dc	20 8d 27	jsr $1a278d	            JSR PROCESS
.1a27df	b0 e8		bcs $1a27c9	                BCS no_ready_loop
.1a27e1	80 e3		bra $1a27c6	                BRA ready_loop
>1ad26f	0d 52 45 41 44 59 0d 00		MPROMPT         .null 13,"READY",13

;******  Return to file: src\basic816.s


;******  Processing file: src\operators.s

.1a27e3					OP_PLUS
.1a27e3	08		php		            PHP
.1a27e4	e2 20		sep #$20	            SEP #$20
.1a27e6	20 a3 08	jsr $1a08a3	            JSR ASS_ARGS_NUMSTR
.1a27e9	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a27eb	f0 2c		beq $1a2819	            BEQ is_integer
.1a27ed	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a27ef	f0 2d		beq $1a281e	            BEQ is_float
.1a27f1	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a27f3	f0 1f		beq $1a2814	            BEQ is_string
.1a27f5					type_error
.1a27f5	08		php		            PHP
.1a27f6	c2 20		rep #$20	            REP #$20
.1a27f8	48		pha		            PHA
.1a27f9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a27fc	5b		tcd		            TCD
.1a27fd	68		pla		            PLA
.1a27fe	28		plp		            PLP
.1a27ff	e2 20		sep #$20	            SEP #$20
.1a2801	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2803	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2807	c2 20		rep #$20	            REP #$20
.1a2809	29 ff 00	and #$00ff	            AND #$00FF
.1a280c	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a280f	e2 20		sep #$20	            SEP #$20
.1a2811	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2814					is_string
.1a2814	20 51 16	jsr $1a1651	            JSR STRCONCAT
.1a2817	80 08		bra $1a2821	            BRA done
.1a2819					is_integer
.1a2819	20 72 54	jsr $1a5472	            JSR OP_INT_ADD
.1a281c	80 03		bra $1a2821	            BRA done
.1a281e					is_float
.1a281e	20 e1 56	jsr $1a56e1	            JSR OP_FP_ADD
.1a2821	28		plp		done        PLP
.1a2822	60		rts		            RTS
.1a2823					OP_MINUS
.1a2823	08		php		            PHP
.1a2824	e2 20		sep #$20	            SEP #$20
.1a2826	20 55 08	jsr $1a0855	            JSR ASS_ARGS_NUM
.1a2829	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a282b	f0 23		beq $1a2850	            BEQ is_integer
.1a282d	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a282f	f0 24		beq $1a2855	            BEQ is_float
.1a2831					type_error
.1a2831	08		php		            PHP
.1a2832	c2 20		rep #$20	            REP #$20
.1a2834	48		pha		            PHA
.1a2835	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2838	5b		tcd		            TCD
.1a2839	68		pla		            PLA
.1a283a	28		plp		            PLP
.1a283b	e2 20		sep #$20	            SEP #$20
.1a283d	a9 04		lda #$04	            LDA #ERR_TYPE
.1a283f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2843	c2 20		rep #$20	            REP #$20
.1a2845	29 ff 00	and #$00ff	            AND #$00FF
.1a2848	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a284b	e2 20		sep #$20	            SEP #$20
.1a284d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2850					is_integer
.1a2850	20 84 54	jsr $1a5484	            JSR OP_INT_SUB
.1a2853	80 03		bra $1a2858	            BRA done
.1a2855					is_float
.1a2855	20 d6 56	jsr $1a56d6	            JSR OP_FP_SUB
.1a2858	28		plp		done        PLP
.1a2859	60		rts		            RTS
.1a285a					OP_MULTIPLY
.1a285a	08		php		            PHP
.1a285b	e2 20		sep #$20	            SEP #$20
.1a285d	20 55 08	jsr $1a0855	            JSR ASS_ARGS_NUM
.1a2860	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a2862	f0 23		beq $1a2887	            BEQ is_integer
.1a2864	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2866	f0 24		beq $1a288c	            BEQ is_float
.1a2868					type_error
.1a2868	08		php		            PHP
.1a2869	c2 20		rep #$20	            REP #$20
.1a286b	48		pha		            PHA
.1a286c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a286f	5b		tcd		            TCD
.1a2870	68		pla		            PLA
.1a2871	28		plp		            PLP
.1a2872	e2 20		sep #$20	            SEP #$20
.1a2874	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2876	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a287a	c2 20		rep #$20	            REP #$20
.1a287c	29 ff 00	and #$00ff	            AND #$00FF
.1a287f	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a2882	e2 20		sep #$20	            SEP #$20
.1a2884	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2887					is_integer
.1a2887	20 96 54	jsr $1a5496	            JSR OP_INT_MUL
.1a288a	80 03		bra $1a288f	            BRA done
.1a288c					is_float
.1a288c	20 77 57	jsr $1a5777	            JSR OP_FP_MUL
.1a288f	28		plp		done        PLP
.1a2890	60		rts		            RTS
.1a2891					OP_DIVIDE
.1a2891	20 bf 07	jsr $1a07bf	            JSR ASS_ARG1_FLOAT
.1a2894	20 f0 07	jsr $1a07f0	            JSR ASS_ARG2_FLOAT
.1a2897	20 2c 57	jsr $1a572c	            JSR OP_FP_DIV
.1a289a	60		rts		            RTS
.1a289b					OP_MOD
.1a289b	a5 23		lda $0823	            LDA ARGUMENT1
.1a289d	8f 1a 01 00	sta $00011a	            STA @lD1_OPERAND_B
.1a28a1	a5 29		lda $0829	            LDA ARGUMENT2
.1a28a3	8f 18 01 00	sta $000118	            STA @lD1_OPERAND_A
.1a28a7	af 1e 01 00	lda $00011e	            LDA @lD1_REMAINDER
.1a28ab	85 23		sta $0823	            STA ARGUMENT1
.1a28ad	60		rts		            RTS
.1a28ae					OP_POW
.1a28ae	08		php		            PHP
.1a28af	c2 30		rep #$30	            REP #$30
.1a28b1	48		pha		            PHA
.1a28b2	20 bf 07	jsr $1a07bf	            JSR ASS_ARG1_FLOAT
.1a28b5	a5 2d		lda $082d	            LDA ARGTYPE2
.1a28b7	c9 00 00	cmp #$0000	            CMP #TYPE_INTEGER
.1a28ba	d0 0d		bne $1a28c9	            BNE flt_exp
.1a28bc	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a28be	d0 09		bne $1a28c9	            BNE flt_exp
.1a28c0	da		phx		            PHX
.1a28c1	a6 29		ldx $0829	            LDX ARGUMENT2
.1a28c3	20 4a 64	jsr $1a644a	            JSR Q_FP_POW_INT
.1a28c6	fa		plx		            PLX
.1a28c7	80 1c		bra $1a28e5	            BRA done
.1a28c9					flt_exp
.1a28c9	20 f0 07	jsr $1a07f0	            JSR ASS_ARG2_FLOAT
.1a28cc	c2 20		rep #$20	            REP #$20
.1a28ce	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a28d0	48		pha		            PHA
.1a28d1	a5 29		lda $0829	            LDA ARGUMENT2
.1a28d3	48		pha		            PHA
.1a28d4	20 d5 62	jsr $1a62d5	            JSR FP_LN
.1a28d7	c2 20		rep #$20	            REP #$20
.1a28d9	68		pla		            PLA
.1a28da	85 29		sta $0829	            STA ARGUMENT2
.1a28dc	68		pla		            PLA
.1a28dd	85 2b		sta $082b	            STA ARGUMENT2+2
.1a28df	20 77 57	jsr $1a5777	            JSR OP_FP_MUL
.1a28e2	20 b4 64	jsr $1a64b4	            JSR FP_EXP
.1a28e5	68		pla		done        PLA
.1a28e6	28		plp		            PLP
.1a28e7	60		rts		            RTS
.1a28e8					OP_AND
.1a28e8	08		php		            PHP
.1a28e9	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a28ec	20 82 06	jsr $1a0682	            JSR ASS_ARG2_INT
.1a28ef	c2 20		rep #$20	            REP #$20
.1a28f1	a5 23		lda $0823	            LDA ARGUMENT1
.1a28f3	25 29		and $0829	            AND ARGUMENT2
.1a28f5	85 23		sta $0823	            STA ARGUMENT1
.1a28f7	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a28f9	25 2b		and $082b	            AND ARGUMENT2+2
.1a28fb	85 25		sta $0825	            STA ARGUMENT1+2
.1a28fd	28		plp		            PLP
.1a28fe	60		rts		            RTS
.1a28ff					OP_OR
.1a28ff	08		php		            PHP
.1a2900	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a2903	20 82 06	jsr $1a0682	            JSR ASS_ARG2_INT
.1a2906	c2 20		rep #$20	            REP #$20
.1a2908	a5 23		lda $0823	            LDA ARGUMENT1
.1a290a	05 29		ora $0829	            ORA ARGUMENT2
.1a290c	85 23		sta $0823	            STA ARGUMENT1
.1a290e	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a2910	05 2b		ora $082b	            ORA ARGUMENT2+2
.1a2912	85 25		sta $0825	            STA ARGUMENT1+2
.1a2914	28		plp		done        PLP
.1a2915	60		rts		            RTS
.1a2916					OP_NOT
.1a2916	08		php		            PHP
.1a2917	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a291a	c2 20		rep #$20	            REP #$20
.1a291c	a5 23		lda $0823	            LDA ARGUMENT1
.1a291e	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a2921	85 23		sta $0823	            STA ARGUMENT1
.1a2923	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a2925	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a2928	85 25		sta $0825	            STA ARGUMENT1+2
.1a292a	28		plp		done        PLP
.1a292b	60		rts		            RTS
.1a292c					OP_LT
.1a292c	08		php		            PHP
.1a292d	e2 20		sep #$20	            SEP #$20
.1a292f	20 a3 08	jsr $1a08a3	            JSR ASS_ARGS_NUMSTR
.1a2932	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a2934	f0 2c		beq $1a2962	            BEQ is_integer
.1a2936	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2938	f0 2d		beq $1a2967	            BEQ is_float
.1a293a	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a293c	f0 1f		beq $1a295d	            BEQ is_string
.1a293e					type_error
.1a293e	08		php		            PHP
.1a293f	c2 20		rep #$20	            REP #$20
.1a2941	48		pha		            PHA
.1a2942	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2945	5b		tcd		            TCD
.1a2946	68		pla		            PLA
.1a2947	28		plp		            PLP
.1a2948	e2 20		sep #$20	            SEP #$20
.1a294a	a9 04		lda #$04	            LDA #ERR_TYPE
.1a294c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2950	c2 20		rep #$20	            REP #$20
.1a2952	29 ff 00	and #$00ff	            AND #$00FF
.1a2955	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a2958	e2 20		sep #$20	            SEP #$20
.1a295a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a295d					is_string
.1a295d	20 d9 17	jsr $1a17d9	            JSR OP_STR_LT
.1a2960	80 08		bra $1a296a	            BRA done
.1a2962					is_integer
.1a2962	20 97 55	jsr $1a5597	            JSR OP_INT_LT
.1a2965	80 03		bra $1a296a	            BRA done
.1a2967					is_float
.1a2967	20 0c 5d	jsr $1a5d0c	            JSR OP_FP_LT
.1a296a	28		plp		done        PLP
.1a296b	60		rts		            RTS
.1a296c					OP_GT
.1a296c	08		php		            PHP
.1a296d	e2 20		sep #$20	            SEP #$20
.1a296f	20 a3 08	jsr $1a08a3	            JSR ASS_ARGS_NUMSTR
.1a2972	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a2974	f0 2c		beq $1a29a2	            BEQ is_integer
.1a2976	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2978	f0 2d		beq $1a29a7	            BEQ is_float
.1a297a	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a297c	f0 1f		beq $1a299d	            BEQ is_string
.1a297e					type_error
.1a297e	08		php		            PHP
.1a297f	c2 20		rep #$20	            REP #$20
.1a2981	48		pha		            PHA
.1a2982	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2985	5b		tcd		            TCD
.1a2986	68		pla		            PLA
.1a2987	28		plp		            PLP
.1a2988	e2 20		sep #$20	            SEP #$20
.1a298a	a9 04		lda #$04	            LDA #ERR_TYPE
.1a298c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2990	c2 20		rep #$20	            REP #$20
.1a2992	29 ff 00	and #$00ff	            AND #$00FF
.1a2995	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a2998	e2 20		sep #$20	            SEP #$20
.1a299a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a299d					is_string
.1a299d	20 f0 17	jsr $1a17f0	            JSR OP_STR_GT
.1a29a0	80 08		bra $1a29aa	            BRA done
.1a29a2					is_integer
.1a29a2	20 b8 55	jsr $1a55b8	            JSR OP_INT_GT
.1a29a5	80 03		bra $1a29aa	            BRA done
.1a29a7					is_float
.1a29a7	20 21 5d	jsr $1a5d21	            JSR OP_FP_GT
.1a29aa	28		plp		done        PLP
.1a29ab	60		rts		            RTS
.1a29ac					OP_EQ
.1a29ac	08		php		            PHP
.1a29ad	e2 20		sep #$20	            SEP #$20
.1a29af	20 a3 08	jsr $1a08a3	            JSR ASS_ARGS_NUMSTR
.1a29b2	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a29b4	f0 2c		beq $1a29e2	            BEQ is_integer
.1a29b6	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a29b8	f0 2d		beq $1a29e7	            BEQ is_float
.1a29ba	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a29bc	f0 1f		beq $1a29dd	            BEQ is_string
.1a29be					type_error
.1a29be	08		php		            PHP
.1a29bf	c2 20		rep #$20	            REP #$20
.1a29c1	48		pha		            PHA
.1a29c2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a29c5	5b		tcd		            TCD
.1a29c6	68		pla		            PLA
.1a29c7	28		plp		            PLP
.1a29c8	e2 20		sep #$20	            SEP #$20
.1a29ca	a9 04		lda #$04	            LDA #ERR_TYPE
.1a29cc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a29d0	c2 20		rep #$20	            REP #$20
.1a29d2	29 ff 00	and #$00ff	            AND #$00FF
.1a29d5	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a29d8	e2 20		sep #$20	            SEP #$20
.1a29da	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a29dd					is_string
.1a29dd	20 07 18	jsr $1a1807	            JSR OP_STR_EQ
.1a29e0	80 08		bra $1a29ea	            BRA done
.1a29e2					is_integer
.1a29e2	20 e5 55	jsr $1a55e5	            JSR OP_INT_EQ
.1a29e5	80 03		bra $1a29ea	            BRA done
.1a29e7					is_float
.1a29e7	20 36 5d	jsr $1a5d36	            JSR OP_FP_EQ
.1a29ea	28		plp		done        PLP
.1a29eb	60		rts		            RTS
.1a29ec					OP_NE
.1a29ec	08		php		            PHP
.1a29ed	e2 20		sep #$20	            SEP #$20
.1a29ef	20 a3 08	jsr $1a08a3	            JSR ASS_ARGS_NUMSTR
.1a29f2	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a29f4	f0 2c		beq $1a2a22	            BEQ is_integer
.1a29f6	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a29f8	f0 2d		beq $1a2a27	            BEQ is_float
.1a29fa	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a29fc	f0 1f		beq $1a2a1d	            BEQ is_string
.1a29fe					type_error
.1a29fe	08		php		            PHP
.1a29ff	c2 20		rep #$20	            REP #$20
.1a2a01	48		pha		            PHA
.1a2a02	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2a05	5b		tcd		            TCD
.1a2a06	68		pla		            PLA
.1a2a07	28		plp		            PLP
.1a2a08	e2 20		sep #$20	            SEP #$20
.1a2a0a	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2a0c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2a10	c2 20		rep #$20	            REP #$20
.1a2a12	29 ff 00	and #$00ff	            AND #$00FF
.1a2a15	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a2a18	e2 20		sep #$20	            SEP #$20
.1a2a1a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2a1d					is_string
.1a2a1d	20 1e 18	jsr $1a181e	            JSR OP_STR_NE
.1a2a20	80 08		bra $1a2a2a	            BRA done
.1a2a22					is_integer
.1a2a22	20 03 56	jsr $1a5603	            JSR OP_INT_NE
.1a2a25	80 03		bra $1a2a2a	            BRA done
.1a2a27					is_float
.1a2a27	20 75 5d	jsr $1a5d75	            JSR OP_FP_NE
.1a2a2a	28		plp		done        PLP
.1a2a2b	60		rts		            RTS
.1a2a2c					OP_GTE
.1a2a2c	08		php		            PHP
.1a2a2d	e2 20		sep #$20	            SEP #$20
.1a2a2f	20 a3 08	jsr $1a08a3	            JSR ASS_ARGS_NUMSTR
.1a2a32	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a2a34	f0 2c		beq $1a2a62	            BEQ is_integer
.1a2a36	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2a38	f0 2d		beq $1a2a67	            BEQ is_float
.1a2a3a	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a2a3c	f0 1f		beq $1a2a5d	            BEQ is_string
.1a2a3e					type_error
.1a2a3e	08		php		            PHP
.1a2a3f	c2 20		rep #$20	            REP #$20
.1a2a41	48		pha		            PHA
.1a2a42	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2a45	5b		tcd		            TCD
.1a2a46	68		pla		            PLA
.1a2a47	28		plp		            PLP
.1a2a48	e2 20		sep #$20	            SEP #$20
.1a2a4a	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2a4c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2a50	c2 20		rep #$20	            REP #$20
.1a2a52	29 ff 00	and #$00ff	            AND #$00FF
.1a2a55	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a2a58	e2 20		sep #$20	            SEP #$20
.1a2a5a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2a5d					is_string
.1a2a5d	20 35 18	jsr $1a1835	            JSR OP_STR_GTE
.1a2a60	80 08		bra $1a2a6a	            BRA done
.1a2a62					is_integer
.1a2a62	20 21 56	jsr $1a5621	            JSR OP_INT_GTE
.1a2a65	80 03		bra $1a2a6a	            BRA done
.1a2a67					is_float
.1a2a67	20 60 5d	jsr $1a5d60	            JSR OP_FP_GTE
.1a2a6a	28		plp		done        PLP
.1a2a6b	60		rts		            RTS
.1a2a6c					OP_LTE
.1a2a6c	08		php		            PHP
.1a2a6d	e2 20		sep #$20	            SEP #$20
.1a2a6f	20 a3 08	jsr $1a08a3	            JSR ASS_ARGS_NUMSTR
.1a2a72	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a2a74	f0 2c		beq $1a2aa2	            BEQ is_integer
.1a2a76	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2a78	f0 2d		beq $1a2aa7	            BEQ is_float
.1a2a7a	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a2a7c	f0 1f		beq $1a2a9d	            BEQ is_string
.1a2a7e					type_error
.1a2a7e	08		php		            PHP
.1a2a7f	c2 20		rep #$20	            REP #$20
.1a2a81	48		pha		            PHA
.1a2a82	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2a85	5b		tcd		            TCD
.1a2a86	68		pla		            PLA
.1a2a87	28		plp		            PLP
.1a2a88	e2 20		sep #$20	            SEP #$20
.1a2a8a	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2a8c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2a90	c2 20		rep #$20	            REP #$20
.1a2a92	29 ff 00	and #$00ff	            AND #$00FF
.1a2a95	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a2a98	e2 20		sep #$20	            SEP #$20
.1a2a9a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2a9d					is_string
.1a2a9d	20 4c 18	jsr $1a184c	            JSR OP_STR_LTE
.1a2aa0	80 08		bra $1a2aaa	            BRA done
.1a2aa2					is_integer
.1a2aa2	20 4e 56	jsr $1a564e	            JSR OP_INT_LTE
.1a2aa5	80 03		bra $1a2aaa	            BRA done
.1a2aa7					is_float
.1a2aa7	20 4b 5d	jsr $1a5d4b	            JSR OP_FP_LTE
.1a2aaa	28		plp		done        PLP
.1a2aab	60		rts		            RTS
.1a2aac					OP_NEGATIVE
.1a2aac	08		php		                PHP
.1a2aad	e2 20		sep #$20	            SEP #$20
.1a2aaf	a5 27		lda $0827	                LDA ARGTYPE1                ; Check the type of the argument
.1a2ab1	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a2ab3	f0 2d		beq $1a2ae2	                BEQ int_negate              ; If integer: negate the integer
.1a2ab5	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.1a2ab7	f0 1f		beq $1a2ad8	                BEQ float_negate            ; If floating point: negate the floating point
.1a2ab9					type_error
.1a2ab9	08		php		            PHP
.1a2aba	c2 20		rep #$20	            REP #$20
.1a2abc	48		pha		            PHA
.1a2abd	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2ac0	5b		tcd		            TCD
.1a2ac1	68		pla		            PLA
.1a2ac2	28		plp		            PLP
.1a2ac3	e2 20		sep #$20	            SEP #$20
.1a2ac5	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2ac7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2acb	c2 20		rep #$20	            REP #$20
.1a2acd	29 ff 00	and #$00ff	            AND #$00FF
.1a2ad0	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a2ad3	e2 20		sep #$20	            SEP #$20
.1a2ad5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2ad8					float_negate
.1a2ad8	e2 20		sep #$20	            SEP #$20
.1a2ada	a5 26		lda $0826	                LDA ARGUMENT1+3             ; Flip the sign bit of the floating point number
.1a2adc	49 80		eor #$80	                EOR #$80
.1a2ade	85 26		sta $0826	                STA ARGUMENT1+3
.1a2ae0	80 16		bra $1a2af8	                BRA done
.1a2ae2					int_negate
.1a2ae2	c2 20		rep #$20	            REP #$20
.1a2ae4	a5 23		lda $0823	                LDA ARGUMENT1               ; Invert ARGUMENT1
.1a2ae6	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a2ae9	85 23		sta $0823	                STA ARGUMENT1
.1a2aeb	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a2aed	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a2af0	85 25		sta $0825	                STA ARGUMENT1+2
.1a2af2	e6 23		inc $0823	                INC ARGUMENT1               ; And increment to get two's complement
.1a2af4	d0 02		bne $1a2af8	                BNE done
.1a2af6	e6 25		inc $0825	                INC ARGUMENT1+2
.1a2af8					done
.1a2af8	28		plp		                PLP
.1a2af9	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\statements.s


;******  Processing file: src\C256/statements_c256.s

=0					GR_LUT_BLUE = 0
=1					GR_LUT_GREEN = 1
=2					GR_LUT_RED = 2
=3					GR_LUT_ALPHA = 3
=640					GR_DEFAULT_COLS = 640               ; Default number of columns in the display
=480					GR_DEFAULT_ROWS = 480               ; Default number of rows in the display
=8					GR_MAX_LUT = 8                      ; The number of LUTs Vicky supports
=64					SP_MAX = 64                         ; The number of sprites Vicky supports
=8					SP_REG_SIZE = 8                     ; The number of bytes in a sprite's register block
=0					SP_CONTROL = 0                      ; Offset of the control regsiter for a sprite
=1					SP_ADDR = 1                         ; Offset of the pixmap address for a sprite
=4					SP_X_COORD = 4                      ; Offset of the X coordinate for a sprite
=6					SP_Y_COORD = 6                      ; Offset of the Y coordinate for a sprite
=12					TILEMAP_REG_SIZE = 12               ; The number of bytes in a tile map's register set
=4					TILESET_REG_SIZE = 4                ; The number of bytes in a tile set's register set
=2					BM_MAX = 2                          ; Maximum number of bitmaps we support
=$0040					MAX_VRAM_VICKY = $0040              ; Upper limit (exclusive) bank address for VRAM in Vicky address space
=$00f0					MAX_VRAM_CPU = $00F0                ; Upper limit (exclusive) bank address for VRAM in CPU address space
=$00b0					MIN_VRAM_CPU = $00B0                ; Lower limit (inclusive) bank address for VRAM in CPU address space
>1af000					GR_BM0_ADDR     .dword ?            ; Address of bitmap 0 (from CPU's perspective)
>1af004					GR_BM1_ADDR     .dword ?            ; Address of bitmap 1 (from CPU's perspective)
>1af008					GR_BM0_VRAM     .dword ?            ; Address of bitmap 0 (relative to start of VRAM)
>1af00c					GR_BM1_VRAM     .dword ?            ; Address of bitmap 1 (relative to start of VRAM)
>1af010					GR_MAX_COLS     .word ?             ; Width the display in pixels
>1af012					GR_MAX_ROWS     .word ?             ; Height of the display in pixels
>1af014					GR_TOTAL_PIXELS .word ?             ; Total number of pixels in the display
>1af016					GR_TEMP         .word ?             ; A temporary word for graphics commands
>1af018					GS_SP_CONTROL   .fill SP_MAX        ; Shadow registers for the sprite controls
.1a2afa					S_SETTIME
.1a2afa	08		php		                PHP
.1a2afb	e2 20		sep #$20	            SEP #$20
.1a2afd	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2b00	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2b03	20 ae 05	jsr $1a05ae	            JSR DIVINT10
.1a2b06	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2b08	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2b09	0a		asl a		                ASL A
.1a2b0a	0a		asl a		                ASL A
.1a2b0b	0a		asl a		                ASL A
.1a2b0c	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2b0e	48		pha		                PHA
.1a2b0f	a9 2c		lda #$2c	                LDA #','
.1a2b11	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a2b14	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2b17	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2b1a	20 ae 05	jsr $1a05ae	            JSR DIVINT10
.1a2b1d	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2b1f	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2b20	0a		asl a		                ASL A
.1a2b21	0a		asl a		                ASL A
.1a2b22	0a		asl a		                ASL A
.1a2b23	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2b25	48		pha		                PHA
.1a2b26	a9 2c		lda #$2c	                LDA #','
.1a2b28	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a2b2b	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2b2e	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2b31	20 ae 05	jsr $1a05ae	            JSR DIVINT10
.1a2b34	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2b36	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2b37	0a		asl a		                ASL A
.1a2b38	0a		asl a		                ASL A
.1a2b39	0a		asl a		                ASL A
.1a2b3a	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2b3c	48		pha		                PHA
.1a2b3d	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a2b41	09 0c		ora #$0c	                ORA #%00001100
.1a2b43	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2b47	68		pla		                PLA                     ; And seconds to the RTC
.1a2b48	8f 00 08 af	sta $af0800	                STA @lRTC_SEC
.1a2b4c	68		pla		                PLA                     ; Minutes...
.1a2b4d	8f 02 08 af	sta $af0802	                STA @lRTC_MIN
.1a2b51	68		pla		                PLA                     ; Save the hour...
.1a2b52	8f 04 08 af	sta $af0804	                STA @lRTC_HRS
.1a2b56	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a2b5a	29 f7		and #$f7	                AND #%11110111
.1a2b5c	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2b60	20 62 21	jsr $1a2162	            JSR SKIPSTMT
.1a2b63	28		plp		                PLP
.1a2b64	60		rts		            RTS
.1a2b65					S_SETDATE
.1a2b65	08		php		                PHP
.1a2b66	e2 20		sep #$20	            SEP #$20
.1a2b68	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2b6b	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2b6e	20 ae 05	jsr $1a05ae	            JSR DIVINT10
.1a2b71	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2b73	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2b74	0a		asl a		                ASL A
.1a2b75	0a		asl a		                ASL A
.1a2b76	0a		asl a		                ASL A
.1a2b77	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2b79	48		pha		                PHA
.1a2b7a	a9 2c		lda #$2c	                LDA #','
.1a2b7c	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a2b7f	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2b82	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2b85	20 ae 05	jsr $1a05ae	            JSR DIVINT10
.1a2b88	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2b8a	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2b8b	0a		asl a		                ASL A
.1a2b8c	0a		asl a		                ASL A
.1a2b8d	0a		asl a		                ASL A
.1a2b8e	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2b90	48		pha		                PHA
.1a2b91	a9 2c		lda #$2c	                LDA #','
.1a2b93	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a2b96	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2b99	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a2b9c	20 e4 05	jsr $1a05e4	            JSR DIVINT100
.1a2b9f	c2 20		rep #$20	            REP #$20
.1a2ba1	a5 23		lda $0823	                LDA ARGUMENT1           ; Get the century
.1a2ba3	85 92		sta $0892	                STA MTEMP               ; Save it in MTEMP
.1a2ba5	a5 29		lda $0829	                LDA ARGUMENT2           ; Separate the 10s from the 1s digits
.1a2ba7	85 23		sta $0823	                STA ARGUMENT1
.1a2ba9	20 ae 05	jsr $1a05ae	            JSR DIVINT10
.1a2bac	e2 20		sep #$20	            SEP #$20
.1a2bae	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2bb0	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2bb1	0a		asl a		                ASL A
.1a2bb2	0a		asl a		                ASL A
.1a2bb3	0a		asl a		                ASL A
.1a2bb4	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2bb6	48		pha		                PHA                     ; Save the 10s and 1s in BCD
.1a2bb7	c2 20		rep #$20	            REP #$20
.1a2bb9	a5 92		lda $0892	                LDA MTEMP               ; Separate the 100s from the 1000s digits
.1a2bbb	85 23		sta $0823	                STA ARGUMENT1
.1a2bbd	20 ae 05	jsr $1a05ae	            JSR DIVINT10
.1a2bc0	e2 20		sep #$20	            SEP #$20
.1a2bc2	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2bc4	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2bc5	0a		asl a		                ASL A
.1a2bc6	0a		asl a		                ASL A
.1a2bc7	0a		asl a		                ASL A
.1a2bc8	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2bca	48		pha		                PHA                     ; Save the 100s and 1000s in BCD
.1a2bcb	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a2bcf	09 0c		ora #$0c	                ORA #%00001100
.1a2bd1	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2bd5	68		pla		                PLA                     ; Set the century
.1a2bd6	8f 0f 08 af	sta $af080f	                STA @lRTC_CENTURY
.1a2bda	68		pla		                PLA                     ; And year to the RTC
.1a2bdb	8f 0a 08 af	sta $af080a	                STA @lRTC_YEAR
.1a2bdf	68		pla		                PLA                     ; Month...
.1a2be0	8f 09 08 af	sta $af0809	                STA @lRTC_MONTH
.1a2be4	68		pla		                PLA                     ; Save the day...
.1a2be5	8f 06 08 af	sta $af0806	                STA @lRTC_DAY
.1a2be9	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a2bed	29 f7		and #$f7	                AND #%11110111
.1a2bef	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2bf3	20 62 21	jsr $1a2162	            JSR SKIPSTMT
.1a2bf6	28		plp		                PLP
.1a2bf7	60		rts		            RTS
.1a2bf8					S_TEXTCOLOR
.1a2bf8	08		php		                PHP
.1a2bf9					locals
>0001					L_FOREGROUND    .byte ?
.1a2bf9	e2 20		sep #$20	            SEP #$20
.1a2bfb	48		pha		            PHA
.1a2bfc	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2bff	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2c02	e2 20		sep #$20	            SEP #$20
.1a2c04	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the foreground position
.1a2c06	29 0f		and #$0f	                AND #$0F
.1a2c08	0a		asl a		                ASL A
.1a2c09	0a		asl a		                ASL A
.1a2c0a	0a		asl a		                ASL A
.1a2c0b	0a		asl a		                ASL A
.1a2c0c	83 01		sta $01,s	                STA L_FOREGROUND    ; Save the foreground color
.1a2c0e	a9 2c		lda #$2c	                LDA #','
.1a2c10	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a2c13	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2c16	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2c19	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the background position
.1a2c1b	29 0f		and #$0f	                AND #$0F
.1a2c1d	03 01		ora $01,s	                ORA L_FOREGROUND    ; Add in the foreground
.1a2c1f	8f 1e 00 00	sta $00001e	                STA @lCURCOLOR      ; And save the new color combination
.1a2c23	e2 20		sep #$20	            SEP #$20
.1a2c25	68		pla		            PLA
.1a2c26	28		plp		                PLP
.1a2c27	60		rts		            RTS
.1a2c28					S_SETBGCOLOR
.1a2c28	08		php		                PHP
.1a2c29					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.1a2c29	c2 20		rep #$20	            REP #$20
.1a2c2b	f4 00 00	pea #$0000	            PEA #0
.1a2c2e	e2 20		sep #$20	            SEP #$20
.1a2c30	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2c33	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2c36	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.1a2c38	83 01		sta $01,s	                STA L_RED
.1a2c3a	a9 2c		lda #$2c	                LDA #','
.1a2c3c	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a2c3f	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2c42	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2c45	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.1a2c47	83 02		sta $02,s	                STA L_GREEN
.1a2c49	a9 2c		lda #$2c	                LDA #','
.1a2c4b	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a2c4e	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2c51	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2c54	a5 23		lda $0823	                LDA ARGUMENT1               ; And set the actual color
.1a2c56	8f 0d 00 af	sta $af000d	                STA @lBACKGROUND_COLOR_B
.1a2c5a	a3 02		lda $02,s	                LDA L_GREEN
.1a2c5c	8f 0e 00 af	sta $af000e	                STA @lBACKGROUND_COLOR_G
.1a2c60	a3 01		lda $01,s	                LDA L_RED
.1a2c62	8f 0f 00 af	sta $af000f	                STA @lBACKGROUND_COLOR_R
.1a2c66	c2 20		rep #$20	            REP #$20
.1a2c68	68		pla		            PLA
.1a2c69	28		plp		                PLP
.1a2c6a	60		rts		            RTS
.1a2c6b					S_SETBORDER
.1a2c6b	08		php		                PHP
.1a2c6c					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.1a2c6c	c2 20		rep #$20	            REP #$20
.1a2c6e	f4 00 00	pea #$0000	            PEA #0
.1a2c71	e2 20		sep #$20	            SEP #$20
.1a2c73	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2c76	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a2c79	a5 23		lda $0823	                LDA ARGUMENT1
.1a2c7b	f0 16		beq $1a2c93	                BEQ hide_border
.1a2c7d	a9 01		lda #$01	                LDA #Border_Ctrl_Enable     ; Enable the border
.1a2c7f	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.1a2c83	a9 20		lda #$20	                LDA #BORDER_WIDTH           ; Set the border width
.1a2c85	8f 08 00 af	sta $af0008	                STA BORDER_X_SIZE
.1a2c89	8f 09 00 af	sta $af0009	                STA BORDER_Y_SIZE
.1a2c8d	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.1a2c91	80 0a		bra $1a2c9d	                BRA get_color
.1a2c93	a9 00		lda #$00	hide_border     LDA #0                      ; Hide the border
.1a2c95	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.1a2c99	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.1a2c9d	a9 2c		lda #$2c	get_color       LDA #','
.1a2c9f	85 37		sta $0837	                STA TARGETTOK
.1a2ca1	20 5f 22	jsr $1a225f	            JSR OPT_TOK
.1a2ca4	90 39		bcc $1a2cdf	                BCC done                    ; No: we're done
.1a2ca6	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a2ca9	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2cac	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2caf	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.1a2cb1	83 01		sta $01,s	                STA L_RED
.1a2cb3	a9 2c		lda #$2c	                LDA #','
.1a2cb5	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a2cb8	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2cbb	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2cbe	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.1a2cc0	83 02		sta $02,s	                STA L_GREEN
.1a2cc2	a9 2c		lda #$2c	                LDA #','
.1a2cc4	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a2cc7	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2cca	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2ccd	a5 23		lda $0823	                LDA ARGUMENT1
.1a2ccf	8f 05 00 af	sta $af0005	                STA @lBORDER_COLOR_B        ; Set the border color
.1a2cd3	a3 02		lda $02,s	                LDA L_GREEN
.1a2cd5	8f 06 00 af	sta $af0006	                STA @lBORDER_COLOR_G
.1a2cd9	a3 01		lda $01,s	                LDA L_RED
.1a2cdb	8f 07 00 af	sta $af0007	                STA @lBORDER_COLOR_R
.1a2cdf					done
.1a2cdf	c2 20		rep #$20	            REP #$20
.1a2ce1	68		pla		            PLA
.1a2ce2	28		plp		                PLP
.1a2ce3	60		rts		            RTS
.1a2ce4					S_SETCOLOR
.1a2ce4	08		php		                PHP
.1a2ce5					locals
>0001					L_LUT           .byte ?
>0002					L_COLOR         .byte ?
>0003					L_RED           .byte ?
>0004					L_GREEN         .byte ?
>0005					L_BLUE          .byte ?
.1a2ce5	c2 20		rep #$20	            REP #$20
.1a2ce7	3b		tsc		            TSC
.1a2ce8	38		sec		            SEC
.1a2ce9	e9 05 00	sbc #$0005	            SBC #SIZE(locals)
.1a2cec	1b		tcs		            TCS
.1a2ced	e2 20		sep #$20	            SEP #$20
.1a2cef	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2cf2	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2cf5	a5 23		lda $0823	                LDA ARGUMENT1
.1a2cf7	c9 0a		cmp #$0a	                CMP #10             ; And in range
.1a2cf9	90 1f		bcc $1a2d1a	                BLT save_lut
.1a2cfb					bad_argument
.1a2cfb	08		php		            PHP
.1a2cfc	c2 20		rep #$20	            REP #$20
.1a2cfe	48		pha		            PHA
.1a2cff	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2d02	5b		tcd		            TCD
.1a2d03	68		pla		            PLA
.1a2d04	28		plp		            PLP
.1a2d05	e2 20		sep #$20	            SEP #$20
.1a2d07	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a2d09	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2d0d	c2 20		rep #$20	            REP #$20
.1a2d0f	29 ff 00	and #$00ff	            AND #$00FF
.1a2d12	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a2d15	e2 20		sep #$20	            SEP #$20
.1a2d17	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2d1a	83 01		sta $01,s	save_lut        STA L_LUT           ; Save as LUT
.1a2d1c	a9 2c		lda #$2c	                LDA #','
.1a2d1e	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a2d21	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2d24	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2d27	a5 23		lda $0823	                LDA ARGUMENT1
.1a2d29	83 02		sta $02,s	                STA L_COLOR         ; Save as COLOR
.1a2d2b	a9 2c		lda #$2c	                LDA #','
.1a2d2d	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a2d30	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2d33	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2d36	a5 23		lda $0823	                LDA ARGUMENT1
.1a2d38	83 03		sta $03,s	                STA L_RED           ; Save as RED
.1a2d3a	a9 2c		lda #$2c	                LDA #','
.1a2d3c	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a2d3f	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2d42	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2d45	a5 23		lda $0823	                LDA ARGUMENT1
.1a2d47	83 04		sta $04,s	                STA L_GREEN         ; Save it as GREEN
.1a2d49	a9 2c		lda #$2c	                LDA #','
.1a2d4b	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a2d4e	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2d51	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2d54	a5 23		lda $0823	                LDA ARGUMENT1
.1a2d56	83 05		sta $05,s	                STA L_BLUE          ; Save it as BLUE
.1a2d58	a9 af		lda #$af	                LDA #`GRPH_LUT0_PTR ; Get the bank Vicky is in (should always be $AF)
.1a2d5a	85 a0		sta $08a0	                STA MTEMPPTR+2      ; MTEMPPTR will be our pointer to the LUT entry
.1a2d5c	a3 01		lda $01,s	                LDA L_LUT           ; Compute the offset to the LUT address
.1a2d5e	0a		asl a		                ASL A
.1a2d5f	c2 20		rep #$20	            REP #$20
.1a2d61	29 ff 00	and #$00ff	                AND #$00FF
.1a2d64	aa		tax		                TAX                 ; Put it in X
.1a2d65	bf 9c 2d 1a	lda $1a2d9c,x	                LDA @llut_address,X ; Get the address of the LUT
.1a2d69	85 9e		sta $089e	                STA MTEMPPTR        ; Put it in MTEMPPTR
.1a2d6b	e2 20		sep #$20	            SEP #$20
.1a2d6d	a3 02		lda $02,s	                LDA L_COLOR         ; color index *= 4
.1a2d6f	c2 20		rep #$20	            REP #$20
.1a2d71	29 ff 00	and #$00ff	                AND #$00FF
.1a2d74	0a		asl a		                ASL A               ; Since each color has four bytes of data
.1a2d75	0a		asl a		                ASL A
.1a2d76	18		clc		                CLC                 ; Add the color offset to MTEMPPTR
.1a2d77	65 9e		adc $089e	                ADC MTEMPPTR
.1a2d79	85 9e		sta $089e	                STA MTEMPPTR
.1a2d7b	e2 20		sep #$20	            SEP #$20
.1a2d7d	a0 02 00	ldy #$0002	                LDY #GR_LUT_RED
.1a2d80	a3 03		lda $03,s	                LDA L_RED
.1a2d82	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the red component to the color entry
.1a2d84	a0 01 00	ldy #$0001	                LDY #GR_LUT_GREEN
.1a2d87	a3 04		lda $04,s	                LDA L_GREEN
.1a2d89	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the green component to the color entry
.1a2d8b	a0 00 00	ldy #$0000	                LDY #GR_LUT_BLUE
.1a2d8e	a3 05		lda $05,s	                LDA L_BLUE
.1a2d90	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the blue component to the color entry
.1a2d92					done
.1a2d92	c2 20		rep #$20	            REP #$20
.1a2d94	3b		tsc		            TSC
.1a2d95	18		clc		            CLC
.1a2d96	69 05 00	adc #$0005	            ADC #SIZE(locals)
.1a2d99	1b		tcs		            TCS
.1a2d9a	28		plp		                PLP
.1a2d9b	60		rts		            RTS
>1a2d9c	00 20				lut_address     .word <>GRPH_LUT0_PTR
>1a2d9e	00 24				                .word <>GRPH_LUT1_PTR
>1a2da0	00 28				                .word <>GRPH_LUT2_PTR
>1a2da2	00 2c				                .word <>GRPH_LUT3_PTR
>1a2da4	00 30				                .word <>GRPH_LUT4_PTR
>1a2da6	00 34				                .word <>GRPH_LUT5_PTR
>1a2da8	00 38				                .word <>GRPH_LUT6_PTR
>1a2daa	00 3c				                .word <>GRPH_LUT7_PTR
>1a2dac	40 1f				                .word <>FG_CHAR_LUT_PTR
>1a2dae	80 1f				                .word <>BG_CHAR_LUT_PTR
.1a2db0					S_GRAPHICS
.1a2db0	da		phx		                PHX
.1a2db1	5a		phy		                PHY
.1a2db2	08		php		                PHP
.1a2db3	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2db6	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a2db9	c2 20		rep #$20	            REP #$20
.1a2dbb	a5 23		lda $0823	                LDA ARGUMENT1               ; Check to see if we're setting mode to 800x600 or 400x300
.1a2dbd	89 00 01	bit #$0100	                BIT #$0100
.1a2dc0	d0 17		bne $1a2dd9	                BNE set_mode                ; Yes: go ahead and set it
.1a2dc2	af 00 00 af	lda $af0000	                LDA @l MASTER_CTRL_REG_L    ; Otherwise, check to see if we're already in 800x600 or 400x300
.1a2dc6	89 00 01	bit #$0100	                BIT #$0100
.1a2dc9	f0 0e		beq $1a2dd9	                BEQ set_mode                ; No: just go ahead and set the mode
.1a2dcb	e2 20		sep #$20	            SEP #$20
.1a2dcd	a9 00		lda #$00	                LDA #0                      ; Yes: toggle back to 640x480...
.1a2dcf	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.1a2dd3	a9 01		lda #$01	                LDA #1                      ; And back to 800x600....
.1a2dd5	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.1a2dd9					set_mode
.1a2dd9	c2 20		rep #$20	            REP #$20
.1a2ddb	a5 23		lda $0823	                LDA ARGUMENT1
.1a2ddd	8f 00 00 af	sta $af0000	                STA @l MASTER_CTRL_REG_L    ; Set the graphics mode
.1a2de1	e2 20		sep #$20	            SEP #$20
.1a2de3	a5 24		lda $0824	                LDA ARGUMENT1+1             ; Get the screen size bits
.1a2de5	c2 20		rep #$20	            REP #$20
.1a2de7	29 03 00	and #$0003	                AND #$0003
.1a2dea	0a		asl a		                ASL A                       ; Multiply by two to get the index
.1a2deb	aa		tax		                TAX                         ; X is index into the size tables
.1a2dec	c2 20		rep #$20	            REP #$20
.1a2dee	bf 37 2e 1a	lda $1a2e37,x	                LDA gr_columns,X            ; Set the columns
.1a2df2	8f 10 f0 1a	sta $1af010	                STA @lGR_MAX_COLS
.1a2df6	bf 3f 2e 1a	lda $1a2e3f,x	                LDA gr_rows,X               ; Set the rows
.1a2dfa	8f 12 f0 1a	sta $1af012	                STA @lGR_MAX_ROWS
.1a2dfe	af 10 f0 1a	lda $1af010	                LDA @lGR_MAX_COLS           ; Get the current columns
.1a2e02	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.1a2e06	af 12 f0 1a	lda $1af012	                LDA @lGR_MAX_ROWS           ; Get the current rows
.1a2e0a	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B
.1a2e0e	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT             ; Multiply them to get the total pixels
.1a2e12	8f 14 f0 1a	sta $1af014	                STA @lGR_TOTAL_PIXELS
.1a2e16	e2 20		sep #$20	            SEP #$20
.1a2e18	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.1a2e1c	8f 16 f0 1a	sta $1af016	                STA @lGR_TOTAL_PIXELS+2
.1a2e20	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.1a2e24					reset_cursor
.1a2e24	c2 20		rep #$20	            REP #$20
.1a2e26	af 1a 00 00	lda $00001a	                LDA @lCURSORX
.1a2e2a	aa		tax		                TAX
.1a2e2b	af 1c 00 00	lda $00001c	                LDA @lCURSORY
.1a2e2f	a8		tay		                TAY
.1a2e30	20 20 00	jsr $1a0020	            JSR CURSORXY
.1a2e33	28		plp		                PLP
.1a2e34	7a		ply		                PLY
.1a2e35	fa		plx		                PLX
.1a2e36	60		rts		            RTS
>1a2e37	80 02 20 03 40 01 90 01		gr_columns      .word 640,800,320,400
>1a2e3f	e0 01 58 02 f0 00 2c 01		gr_rows         .word 480,600,240,300
>1a2e47	50 00 64 00 28 00 32 00		col_count       .word 80,100,40,50
>1a2e4f	3c 00 4b 00 1e 00 32 00		row_count       .word 60,75,30,50
>1a2e57	48 00 5c 00 20 00 2a 00		colb_count      .word 72,92,32,42
>1a2e5f	34 00 43 00 16 00 34 00		rowb_count      .word 52,67,22,52
.1a2e67					BITMAP_SRAM
.1a2e67	da		phx		                PHX
.1a2e68	08		php		                PHP
.1a2e69	c2 30		rep #$30	            REP #$30
.1a2e6b	c9 02 00	cmp #$0002	                CMP #BM_MAX
.1a2e6e	b0 1c		bcs $1a2e8c	                BGE range_err           ; Make sure it's within range
.1a2e70	0a		asl a		                ASL A
.1a2e71	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.1a2e72	aa		tax		                TAX
.1a2e73	bf 00 f0 1a	lda $1af000,x	                LDA @l GR_BM0_ADDR,X    ; Get the low 16-bits of the address
.1a2e77	85 9e		sta $089e	                STA MTEMPPTR
.1a2e79	bf 02 f0 1a	lda $1af002,x	                LDA @l GR_BM0_ADDR+2,X  ; Get the high bits of the address
.1a2e7d	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a2e7f	c9 f0 00	cmp #$00f0	                CMP #MAX_VRAM_CPU       ; Check to make sure address is within VRAM
.1a2e82	b0 08		bcs $1a2e8c	                BGE range_err
.1a2e84	c9 b0 00	cmp #$00b0	                CMP #MIN_VRAM_CPU
.1a2e87	90 03		bcc $1a2e8c	                BLT range_err
.1a2e89	28		plp		                PLP
.1a2e8a	fa		plx		                PLX
.1a2e8b	60		rts		            RTS
.1a2e8c					range_err
.1a2e8c	08		php		            PHP
.1a2e8d	c2 20		rep #$20	            REP #$20
.1a2e8f	48		pha		            PHA
.1a2e90	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2e93	5b		tcd		            TCD
.1a2e94	68		pla		            PLA
.1a2e95	28		plp		            PLP
.1a2e96	e2 20		sep #$20	            SEP #$20
.1a2e98	a9 09		lda #$09	            LDA #ERR_RANGE
.1a2e9a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2e9e	c2 20		rep #$20	            REP #$20
.1a2ea0	29 ff 00	and #$00ff	            AND #$00FF
.1a2ea3	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a2ea6	e2 20		sep #$20	            SEP #$20
.1a2ea8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2eab					BITMAP_VRAM
.1a2eab	da		phx		                PHX
.1a2eac	08		php		                PHP
.1a2ead	c2 30		rep #$30	            REP #$30
.1a2eaf	c9 02 00	cmp #$0002	                CMP #BM_MAX
.1a2eb2	b0 17		bcs $1a2ecb	                BGE range_err           ; Make sure it's within range
.1a2eb4	0a		asl a		                ASL A
.1a2eb5	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.1a2eb6	aa		tax		                TAX
.1a2eb7	bf 08 f0 1a	lda $1af008,x	                LDA @l GR_BM0_VRAM,X    ; Get the low 16-bits of the address
.1a2ebb	85 9e		sta $089e	                STA MTEMPPTR
.1a2ebd	bf 0a f0 1a	lda $1af00a,x	                LDA @l GR_BM0_VRAM+2,X  ; Get the high bits of the address
.1a2ec1	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a2ec3	c9 40 00	cmp #$0040	                CMP #MAX_VRAM_VICKY     ; Check to make sure the address is from $00:0000 - $3F:FFFF
.1a2ec6	b0 03		bcs $1a2ecb	                BGE range_err           ; If not, throw a range error
.1a2ec8	28		plp		                PLP
.1a2ec9	fa		plx		                PLX
.1a2eca	60		rts		            RTS
.1a2ecb					range_err
.1a2ecb	08		php		            PHP
.1a2ecc	c2 20		rep #$20	            REP #$20
.1a2ece	48		pha		            PHA
.1a2ecf	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2ed2	5b		tcd		            TCD
.1a2ed3	68		pla		            PLA
.1a2ed4	28		plp		            PLP
.1a2ed5	e2 20		sep #$20	            SEP #$20
.1a2ed7	a9 09		lda #$09	            LDA #ERR_RANGE
.1a2ed9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2edd	c2 20		rep #$20	            REP #$20
.1a2edf	29 ff 00	and #$00ff	            AND #$00FF
.1a2ee2	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a2ee5	e2 20		sep #$20	            SEP #$20
.1a2ee7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2eea					S_BITMAP
.1a2eea	08		php		                PHP
.1a2eeb					locals
>0001					L_PLANE         .word ?
>0003					L_VISIBLE       .byte ?
>0004					L_ADDRESS       .dword ?
.1a2eeb	c2 30		rep #$30	            REP #$30
.1a2eed	3b		tsc		                TSC                         ; Allocate space for the locals on the stack
.1a2eee	38		sec		                SEC
.1a2eef	e9 07 00	sbc #$0007	                SBC #SIZE(locals)
.1a2ef2	1b		tcs		                TCS
.1a2ef3	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2ef6	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2ef9	c2 20		rep #$20	            REP #$20
.1a2efb	a5 23		lda $0823	                LDA ARGUMENT1               ; Make sure it's in range
.1a2efd	c9 02 00	cmp #$0002	                CMP #BM_MAX
.1a2f00	b0 59		bcs $1a2f5b	                BGE range_err               ; If not, throw an error
.1a2f02	83 01		sta $01,s	                STA L_PLANE                 ; If so, save it to MARG1
.1a2f04	e2 20		sep #$20	            SEP #$20
.1a2f06	a9 2c		lda #$2c	                LDA #','
.1a2f08	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a2f0b	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2f0e	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2f11	a5 23		lda $0823	                LDA ARGUMENT1
.1a2f13	83 03		sta $03,s	                STA L_VISIBLE
.1a2f15	a9 2c		lda #$2c	                LDA #','
.1a2f17	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a2f1a	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2f1d	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2f20	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the number back
.1a2f22	0a		asl a		                ASL A                       ; Multiply by 8 to get the offset to the registers
.1a2f23	0a		asl a		                ASL A
.1a2f24	0a		asl a		                ASL A
.1a2f25	aa		tax		                TAX                         ; And save that offset to X
.1a2f26	a3 03		lda $03,s	                LDA L_VISIBLE               ; Check the visible flag
.1a2f28	d0 05		bne $1a2f2f	                BNE is_visible              ; If <> 0, it's visible
.1a2f2a	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the LUT #
.1a2f2c	0a		asl a		                ASL A                       ; Shift it into position for the register
.1a2f2d	80 04		bra $1a2f33	                BRA wr_bm_reg               ; And go to write it
.1a2f2f	a5 23		lda $0823	is_visible      LDA ARGUMENT1               ; Get the LUT #
.1a2f31	38		sec		                SEC
.1a2f32	2a		rol a		                ROL A                       ; And shift it into position, and set enable bit
.1a2f33	9f 00 01 af	sta $af0100,x	wr_bm_reg       STA @l BM0_CONTROL_REG,X    ; Write to the bitmap control register
.1a2f37	c2 20		rep #$20	            REP #$20
.1a2f39	a9 2c 00	lda #$002c	                LDA #','
.1a2f3c	85 37		sta $0837	                STA TARGETTOK
.1a2f3e	20 5f 22	jsr $1a225f	            JSR OPT_TOK
.1a2f41	b0 37		bcs $1a2f7a	                BCS get_address             ; Yes: parse the address
.1a2f43	c2 20		rep #$20	            REP #$20
.1a2f45	08		php		            PHP
.1a2f46	c2 20		rep #$20	            REP #$20
.1a2f48	a9 00 00	lda #$0000	            LDA #<>VRAM
.1a2f4b	85 23		sta $0823	            STA ARGUMENT1
.1a2f4d	a9 b0 00	lda #$00b0	            LDA #(VRAM >> 16)
.1a2f50	85 25		sta $0825	            STA ARGUMENT1+2
.1a2f52	e2 20		sep #$20	            SEP #$20
.1a2f54	a9 00		lda #$00	            LDA #TYPE_INTEGER
.1a2f56	85 27		sta $0827	            STA ARGUMENT1+4
.1a2f58	28		plp		            PLP
.1a2f59	80 27		bra $1a2f82	                BRA set_address
.1a2f5b					range_err
.1a2f5b	08		php		            PHP
.1a2f5c	c2 20		rep #$20	            REP #$20
.1a2f5e	48		pha		            PHA
.1a2f5f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2f62	5b		tcd		            TCD
.1a2f63	68		pla		            PLA
.1a2f64	28		plp		            PLP
.1a2f65	e2 20		sep #$20	            SEP #$20
.1a2f67	a9 09		lda #$09	            LDA #ERR_RANGE
.1a2f69	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2f6d	c2 20		rep #$20	            REP #$20
.1a2f6f	29 ff 00	and #$00ff	            AND #$00FF
.1a2f72	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a2f75	e2 20		sep #$20	            SEP #$20
.1a2f77	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2f7a					get_address
.1a2f7a	c2 20		rep #$20	            REP #$20
.1a2f7c	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a2f7f	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2f82					set_address
.1a2f82	c2 20		rep #$20	            REP #$20
.1a2f84	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.1a2f86	0a		asl a		                ASL A                       ; Multiply by four to get the offset to the address variable
.1a2f87	0a		asl a		                ASL A
.1a2f88	aa		tax		                TAX                         ; And put it in X
.1a2f89	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the CPU-space address
.1a2f8b	9f 00 f0 1a	sta $1af000,x	                STA @l GR_BM0_ADDR,X        ; And save it to the correct GR_BM?_ADDR variable
.1a2f8f	9f 08 f0 1a	sta $1af008,x	                STA @l GR_BM0_VRAM,X
.1a2f93	83 04		sta $04,s	                STA L_ADDRESS               ; And L_ADDRESS, temporarily
.1a2f95	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a2f97	9f 02 f0 1a	sta $1af002,x	                STA @l GR_BM0_ADDR+2,X
.1a2f9b	38		sec		                SEC
.1a2f9c	e9 b0 00	sbc #$00b0	                SBC #`VRAM                  ; Rebase the upper half of the address to Vicky memory space
.1a2f9f	9f 0a f0 1a	sta $1af00a,x	                STA @l GR_BM0_VRAM+2,X
.1a2fa3	83 06		sta $06,s	                STA L_ADDRESS+2             ; And to L_ADDRESS
.1a2fa5	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.1a2fa7	0a		asl a		                ASL A                       ; Multiply by eight to get the offset to the registers
.1a2fa8	0a		asl a		                ASL A
.1a2fa9	0a		asl a		                ASL A
.1a2faa	aa		tax		                TAX                         ; And put it in X
.1a2fab	e2 20		sep #$20	            SEP #$20
.1a2fad	a3 04		lda $04,s	                LDA L_ADDRESS               ; Get the address in Vicky space...
.1a2faf	9f 01 01 af	sta $af0101,x	                STA @l BM0_START_ADDY_L,X   ; Save it to the Vicky registers
.1a2fb3	a3 05		lda $05,s	                LDA L_ADDRESS+1
.1a2fb5	9f 02 01 af	sta $af0102,x	                STA @l BM0_START_ADDY_M,X
.1a2fb9	a3 06		lda $06,s	                LDA L_ADDRESS+2
.1a2fbb	9f 03 01 af	sta $af0103,x	                STA @l BM0_START_ADDY_H,X
.1a2fbf	a9 00		lda #$00	                LDA #0                      ; Default offset to (0, 0)
.1a2fc1	9f 04 01 af	sta $af0104,x	                STA @l BM0_X_OFFSET,X
.1a2fc5	9f 05 01 af	sta $af0105,x	                STA @l BM0_Y_OFFSET,X
.1a2fc9	c2 30		rep #$30	            REP #$30
.1a2fcb	3b		tsc		                TSC                         ; Remove the space for the locals from the stack
.1a2fcc	18		clc		                CLC
.1a2fcd	69 07 00	adc #$0007	                ADC #SIZE(locals)
.1a2fd0	1b		tcs		                TCS
.1a2fd1	28		plp		                PLP
.1a2fd2	60		rts		            RTS
.1a2fd3					bad_address
.1a2fd3	08		php		            PHP
.1a2fd4	c2 20		rep #$20	            REP #$20
.1a2fd6	48		pha		            PHA
.1a2fd7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2fda	5b		tcd		            TCD
.1a2fdb	68		pla		            PLA
.1a2fdc	28		plp		            PLP
.1a2fdd	e2 20		sep #$20	            SEP #$20
.1a2fdf	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a2fe1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2fe5	c2 20		rep #$20	            REP #$20
.1a2fe7	29 ff 00	and #$00ff	            AND #$00FF
.1a2fea	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a2fed	e2 20		sep #$20	            SEP #$20
.1a2fef	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2ff2					S_CLRBITMAP
.1a2ff2	08		php		                PHP
.1a2ff3	c2 20		rep #$20	            REP #$20
.1a2ff5	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a2ff8	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a2ffb	a5 23		lda $0823	                LDA ARGUMENT1
.1a2ffd	20 ab 2e	jsr $1a2eab	            JSR BITMAP_VRAM
.1a3000	c2 20		rep #$20	            REP #$20
.1a3002	a5 9e		lda $089e	                LDA MTEMPPTR                ; Set the start address and the # of pixels to write
.1a3004	8f 05 04 af	sta $af0405	                STA @lVDMA_DST_ADDY_L
.1a3008	af 14 f0 1a	lda $1af014	                LDA @lGR_TOTAL_PIXELS       ; Set the size
.1a300c	8f 08 04 af	sta $af0408	                STA @lVDMA_SIZE_L
.1a3010	e2 20		sep #$20	            SEP #$20
.1a3012	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.1a3014	8f 07 04 af	sta $af0407	                STA @lVDMA_DST_ADDY_H
.1a3018	af 16 f0 1a	lda $1af016	                LDA @lGR_TOTAL_PIXELS+2
.1a301c	8f 0a 04 af	sta $af040a	                STA @lVDMA_SIZE_H
.1a3020	a9 00		lda #$00	                LDA #0                      ; Set the color to write
.1a3022	8f 01 04 af	sta $af0401	                STA @lVDMA_BYTE_2_WRITE
.1a3026	a9 85		lda #$85	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_Start_TRF
.1a3028	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.1a302c	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.1a3030	30 fa		bmi $1a302c	                BMI wait
.1a3032	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.1a3034	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.1a3038	28		plp		done            PLP
.1a3039	60		rts		            RTS
=$000855				COLOR = MARG1
=$000859				X0 = MARG2
=$00085d				Y0 = MARG3
=$000861				X1 = MARG4
=$000865				Y1 = MARG5
=$000869				DX = MARG6
=$00086d				DY = MARG7
=$000871				ERR = MARG8
=$000875				ERR2 = MARG9
>08dd					SX      .word ?
>08df					SY      .word ?
.1a303a					PLOT
.1a303a	08		php		                PHP
.1a303b	c2 20		rep #$20	            REP #$20
.1a303d	a5 59		lda $0859	                LDA X0                      ; Get the column
.1a303f	cf 10 f0 1a	cmp $1af010	                CMP @l GR_MAX_COLS          ; Make sure it's in range for this graphics mode
.1a3043	90 1f		bcc $1a3064	                BLT chk_row                 ; If so: check the row
.1a3045					range_err
.1a3045	08		php		            PHP
.1a3046	c2 20		rep #$20	            REP #$20
.1a3048	48		pha		            PHA
.1a3049	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a304c	5b		tcd		            TCD
.1a304d	68		pla		            PLA
.1a304e	28		plp		            PLP
.1a304f	e2 20		sep #$20	            SEP #$20
.1a3051	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3053	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3057	c2 20		rep #$20	            REP #$20
.1a3059	29 ff 00	and #$00ff	            AND #$00FF
.1a305c	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a305f	e2 20		sep #$20	            SEP #$20
.1a3061	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3064					chk_row
.1a3064	c2 30		rep #$30	            REP #$30
.1a3066	a5 5d		lda $085d	                LDA Y0                      ; Get the row
.1a3068	cf 12 f0 1a	cmp $1af012	                CMP @l GR_MAX_ROWS          ; Make sure it's in range for this graphics mode
.1a306c	b0 d7		bcs $1a3045	                BGE range_err               ; If not: throw an error
.1a306e	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.1a3072	af 10 f0 1a	lda $1af010	                LDA @lGR_MAX_COLS
.1a3076	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B          ; Multiply by the number of columns in the pixmap
.1a307a	18		clc		                CLC                         ; Add the column
.1a307b	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT
.1a307f	65 59		adc $0859	                ADC X0
.1a3081	85 0c		sta $080c	                STA SCRATCH
.1a3083	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.1a3087	69 00 00	adc #$0000	                ADC #0
.1a308a	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH is offset of pixel in the pixmap
.1a308c	18		clc		                CLC                         ; Add the address of the first pixel
.1a308d	a5 0c		lda $080c	                LDA SCRATCH
.1a308f	65 9e		adc $089e	                ADC MTEMPPTR
.1a3091	85 0c		sta $080c	                STA SCRATCH
.1a3093	a5 0e		lda $080e	                LDA SCRATCH+2
.1a3095	65 a0		adc $08a0	                ADC MTEMPPTR+2
.1a3097	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH := pixmap + pixel offset
.1a3099	e2 20		sep #$20	            SEP #$20
.1a309b	a5 55		lda $0855	                LDA COLOR                   ; Get the color
.1a309d	87 0c		sta [$080c]	                STA [SCRATCH]               ; And write the color to the pixel
.1a309f	28		plp		done            PLP
.1a30a0	60		rts		            RTS
.1a30a1					LINE
.1a30a1	c2 20		rep #$20	            REP #$20
.1a30a3	a9 01 00	lda #$0001	                LDA #1                      ; Assume SX = 1
.1a30a6	85 dd		sta $08dd	                STA SX
.1a30a8	38		sec		                SEC                         ; DX := ABS(X1 - X0)
.1a30a9	a5 61		lda $0861	                LDA X1
.1a30ab	e5 59		sbc $0859	                SBC X0
.1a30ad	85 69		sta $0869	                STA DX
.1a30af	10 0b		bpl $1a30bc	                BPL abs_Y                   ; If DX < 0 {
.1a30b1	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DX := -DX
.1a30b4	1a		inc a		                INC A
.1a30b5	85 69		sta $0869	                STA DX
.1a30b7	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SX := -1
.1a30ba	85 dd		sta $08dd	                STA SX                      ; }
.1a30bc	a9 01 00	lda #$0001	abs_Y           LDA #1                      ; Assume SY = 1
.1a30bf	85 df		sta $08df	                STA SY
.1a30c1	38		sec		                SEC                         ; DY := ABS(Y1 - Y0)
.1a30c2	a5 65		lda $0865	                LDA Y1
.1a30c4	e5 5d		sbc $085d	                SBC Y0
.1a30c6	85 6d		sta $086d	                STA DY
.1a30c8	10 0b		bpl $1a30d5	                BPL calc_ERR                ; If DY < 0 {
.1a30ca	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DY := -DY
.1a30cd	1a		inc a		                INC A
.1a30ce	85 6d		sta $086d	                STA DY
.1a30d0	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SY := -1
.1a30d3	85 df		sta $08df	                STA SY                      ; }
.1a30d5	a5 6d		lda $086d	calc_ERR        LDA DY
.1a30d7	c9 01 00	cmp #$0001	                CMP #1                      ; Is DY = 1?
.1a30da	d0 19		bne $1a30f5	                BNE cmp_dx                  ; No: compare to DX
.1a30dc	a5 69		lda $0869	                LDA DX
.1a30de	c9 01 00	cmp #$0001	                CMP #1                      ; Is DX = 1 too?
.1a30e1	d0 10		bne $1a30f3	                BNE cmp_dy_dx               ; No: treat normally
.1a30e3	20 3a 30	jsr $1a303a	            JSR PLOT
.1a30e6	a5 61		lda $0861	                LDA X1
.1a30e8	85 59		sta $0859	                STA X0
.1a30ea	a5 65		lda $0865	                LDA Y1
.1a30ec	85 5d		sta $085d	                STA Y0
.1a30ee	20 3a 30	jsr $1a303a	            JSR PLOT
.1a30f1	80 5b		bra $1a314e	                BRA done
.1a30f3	a5 6d		lda $086d	cmp_dy_dx       LDA DY
.1a30f5	c5 69		cmp $0869	cmp_dx          CMP DX                      ; (DY < DX)
.1a30f7	b0 04		bcs $1a30fd	                BGE else
.1a30f9	a5 69		lda $0869	                LDA DX                      ; TRUE CASE: ERR := DX
.1a30fb	80 06		bra $1a3103	                BRA shiftERR
.1a30fd	a5 6d		lda $086d	else            LDA DY                      ; FALSE CASE: ERR := -DY
.1a30ff	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a3102	1a		inc a		                INC A
.1a3103	48		pha		shiftERR        PHA
.1a3104	0a		asl a		                ASL A
.1a3105	68		pla		                PLA
.1a3106	6a		ror a		                ROR A                       ; ERR := ERR / 2
.1a3107	85 71		sta $0871	                STA ERR
.1a3109					loop
.1a3109	20 3a 30	jsr $1a303a	            JSR PLOT
.1a310c	a5 59		lda $0859	                LDA X0                      ; break if X0=X1 and Y0=Y1
.1a310e	c5 61		cmp $0861	                CMP X1
.1a3110	d0 06		bne $1a3118	                BNE calc_ERR2
.1a3112	a5 5d		lda $085d	                LDA Y0
.1a3114	c5 65		cmp $0865	                CMP Y1
.1a3116	f0 36		beq $1a314e	                BEQ done
.1a3118	a5 71		lda $0871	calc_ERR2       LDA ERR                     ; ERR2 := ERR
.1a311a	85 75		sta $0875	                STA ERR2
.1a311c	a5 69		lda $0869	                LDA DX                      ; if (ERR2 > -DX) {
.1a311e	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a3121	1a		inc a		                INC A
.1a3122	c5 75		cmp $0875	                CMP ERR2
.1a3124	10 10		bpl $1a3136	                BPL check_DY
.1a3126	f0 0e		beq $1a3136	                BEQ check_DY
.1a3128	38		sec		                SEC                         ; ERR -= DY
.1a3129	a5 71		lda $0871	                LDA ERR
.1a312b	e5 6d		sbc $086d	                SBC DY
.1a312d	85 71		sta $0871	                STA ERR
.1a312f	18		clc		                CLC                         ; X0 += SX
.1a3130	a5 59		lda $0859	                LDA X0
.1a3132	65 dd		adc $08dd	                ADC SX
.1a3134	85 59		sta $0859	                STA X0                      ; }
.1a3136	a5 75		lda $0875	check_DY        LDA ERR2                    ; if (ERR2 < DY) {
.1a3138	c5 6d		cmp $086d	                CMP DY
.1a313a	10 cd		bpl $1a3109	                BPL loop
.1a313c	f0 cb		beq $1a3109	                BEQ loop
.1a313e	18		clc		                CLC                         ; ERR += DX
.1a313f	a5 71		lda $0871	                LDA ERR
.1a3141	65 69		adc $0869	                ADC DX
.1a3143	85 71		sta $0871	                STA ERR
.1a3145	18		clc		                CLC                         ; Y0 += SY
.1a3146	a5 5d		lda $085d	                LDA Y0
.1a3148	65 df		adc $08df	                ADC SY
.1a314a	85 5d		sta $085d	                STA Y0                      ; }
.1a314c	80 bb		bra $1a3109	                BRA loop                    ; }
.1a314e					done
.1a314e	60		rts		            RTS
.1a314f					S_PLOT
.1a314f	08		php		                PHP
.1a3150					locals
>0001					L_PLANE         .word ?
>0003					L_X             .word ?
>0005					L_Y             .word ?
.1a3150	c2 20		rep #$20	            REP #$20
.1a3152	3b		tsc		            TSC
.1a3153	38		sec		            SEC
.1a3154	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.1a3157	1b		tcs		            TCS
.1a3158	08		php		            PHP
.1a3159	c2 20		rep #$20	            REP #$20
.1a315b	48		pha		            PHA
.1a315c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a315f	5b		tcd		            TCD
.1a3160	68		pla		            PLA
.1a3161	28		plp		            PLP
.1a3162	08		php		            PHP
.1a3163	e2 20		sep #$20	            SEP #$20
.1a3165	48		pha		            PHA
.1a3166	a9 00		lda #$00	            LDA #0
.1a3168	48		pha		            PHA
.1a3169	ab		plb		            PLB
.1a316a	68		pla		            PLA
.1a316b	28		plp		            PLP
.1a316c	c2 30		rep #$30	            REP #$30
.1a316e	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3171	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a3174	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.1a3176	a9 2c 00	lda #$002c	                LDA #','
.1a3179	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a317c	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a317f	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3182	a5 23		lda $0823	                LDA ARGUMENT1
.1a3184	83 03		sta $03,s	                STA L_X                     ; Save it to X
.1a3186	a9 2c 00	lda #$002c	                LDA #','
.1a3189	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a318c	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a318f	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3192	a5 23		lda $0823	                LDA ARGUMENT1
.1a3194	83 05		sta $05,s	                STA L_Y                     ; Save it to Y
.1a3196	a9 2c 00	lda #$002c	                LDA #','
.1a3199	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a319c	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a319f	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a31a2	a5 23		lda $0823	                LDA ARGUMENT1
.1a31a4	85 55		sta $0855	                STA COLOR                   ; Save it to MARG1
.1a31a6	a3 03		lda $03,s	                LDA L_X                     ; Set the (X0, Y0) coordinates
.1a31a8	85 59		sta $0859	                STA X0
.1a31aa	a3 05		lda $05,s	                LDA L_Y
.1a31ac	85 5d		sta $085d	                STA Y0
.1a31ae	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.1a31b0	20 67 2e	jsr $1a2e67	            JSR BITMAP_SRAM
.1a31b3	20 3a 30	jsr $1a303a	            JSR PLOT
.1a31b6	c2 20		rep #$20	            REP #$20
.1a31b8	3b		tsc		            TSC
.1a31b9	18		clc		            CLC
.1a31ba	69 06 00	adc #$0006	            ADC #SIZE(locals)
.1a31bd	1b		tcs		            TCS
.1a31be	28		plp		                PLP
.1a31bf	60		rts		            RTS
.1a31c0					S_LINE
.1a31c0	08		php		                PHP
.1a31c1					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
.1a31c1	c2 20		rep #$20	            REP #$20
.1a31c3	3b		tsc		            TSC
.1a31c4	38		sec		            SEC
.1a31c5	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.1a31c8	1b		tcs		            TCS
.1a31c9	08		php		            PHP
.1a31ca	c2 20		rep #$20	            REP #$20
.1a31cc	48		pha		            PHA
.1a31cd	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a31d0	5b		tcd		            TCD
.1a31d1	68		pla		            PLA
.1a31d2	28		plp		            PLP
.1a31d3	08		php		            PHP
.1a31d4	e2 20		sep #$20	            SEP #$20
.1a31d6	48		pha		            PHA
.1a31d7	a9 00		lda #$00	            LDA #0
.1a31d9	48		pha		            PHA
.1a31da	ab		plb		            PLB
.1a31db	68		pla		            PLA
.1a31dc	28		plp		            PLP
.1a31dd	c2 30		rep #$30	            REP #$30
.1a31df	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a31e2	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a31e5	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.1a31e7	a9 2c 00	lda #$002c	                LDA #','
.1a31ea	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a31ed	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a31f0	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a31f3	a5 23		lda $0823	                LDA ARGUMENT1
.1a31f5	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.1a31f7	a9 2c 00	lda #$002c	                LDA #','
.1a31fa	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a31fd	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3200	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3203	a5 23		lda $0823	                LDA ARGUMENT1
.1a3205	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.1a3207	a9 2c 00	lda #$002c	                LDA #','
.1a320a	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a320d	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3210	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3213	a5 23		lda $0823	                LDA ARGUMENT1
.1a3215	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.1a3217	a9 2c 00	lda #$002c	                LDA #','
.1a321a	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a321d	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3220	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3223	a5 23		lda $0823	                LDA ARGUMENT1
.1a3225	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.1a3227	a9 2c 00	lda #$002c	                LDA #','
.1a322a	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a322d	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3230	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a3233	a5 23		lda $0823	                LDA ARGUMENT1
.1a3235	85 55		sta $0855	                STA COLOR                   ; Save it to COLOR
.1a3237	a3 03		lda $03,s	                LDA L_X0                    ; Set the (X0, Y0) coordinates
.1a3239	85 59		sta $0859	                STA X0
.1a323b	a3 05		lda $05,s	                LDA L_Y0
.1a323d	85 5d		sta $085d	                STA Y0
.1a323f	a3 07		lda $07,s	                LDA L_X1                    ; Set the (X1, Y1) coordinates
.1a3241	85 61		sta $0861	                STA X1
.1a3243	a3 09		lda $09,s	                LDA L_Y1
.1a3245	85 65		sta $0865	                STA Y1
.1a3247	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.1a3249	20 67 2e	jsr $1a2e67	            JSR BITMAP_SRAM
.1a324c	20 a1 30	jsr $1a30a1	            JSR LINE
.1a324f					done
.1a324f	c2 20		rep #$20	            REP #$20
.1a3251	3b		tsc		            TSC
.1a3252	18		clc		            CLC
.1a3253	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.1a3256	1b		tcs		            TCS
.1a3257	28		plp		                PLP
.1a3258	60		rts		            RTS
.1a3259					S_FILL
.1a3259	08		php		                PHP
.1a325a					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
>000b					L_COLOR         .word ?
.1a325a	c2 20		rep #$20	            REP #$20
.1a325c	3b		tsc		            TSC
.1a325d	38		sec		            SEC
.1a325e	e9 0c 00	sbc #$000c	            SBC #SIZE(locals)
.1a3261	1b		tcs		            TCS
.1a3262	08		php		            PHP
.1a3263	c2 20		rep #$20	            REP #$20
.1a3265	48		pha		            PHA
.1a3266	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3269	5b		tcd		            TCD
.1a326a	68		pla		            PLA
.1a326b	28		plp		            PLP
.1a326c	08		php		            PHP
.1a326d	e2 20		sep #$20	            SEP #$20
.1a326f	48		pha		            PHA
.1a3270	a9 00		lda #$00	            LDA #0
.1a3272	48		pha		            PHA
.1a3273	ab		plb		            PLB
.1a3274	68		pla		            PLA
.1a3275	28		plp		            PLP
.1a3276	c2 30		rep #$30	            REP #$30
.1a3278	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a327b	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a327e	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.1a3280	a9 2c 00	lda #$002c	                LDA #','
.1a3283	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3286	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3289	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a328c	a5 23		lda $0823	                LDA ARGUMENT1
.1a328e	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.1a3290	a9 2c 00	lda #$002c	                LDA #','
.1a3293	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3296	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3299	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a329c	a5 23		lda $0823	                LDA ARGUMENT1
.1a329e	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.1a32a0	a9 2c 00	lda #$002c	                LDA #','
.1a32a3	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a32a6	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a32a9	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a32ac	a5 23		lda $0823	                LDA ARGUMENT1
.1a32ae	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.1a32b0	a9 2c 00	lda #$002c	                LDA #','
.1a32b3	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a32b6	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a32b9	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a32bc	a5 23		lda $0823	                LDA ARGUMENT1
.1a32be	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.1a32c0	a9 2c 00	lda #$002c	                LDA #','
.1a32c3	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a32c6	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a32c9	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a32cc	a5 23		lda $0823	                LDA ARGUMENT1
.1a32ce	83 0b		sta $0b,s	                STA L_COLOR                 ; Save it to COLOR
.1a32d0	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.1a32d2	20 ab 2e	jsr $1a2eab	            JSR BITMAP_VRAM
.1a32d5	a9 07 00	lda #$0007	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_1D_2D
.1a32d8	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a32dc	c2 20		rep #$20	            REP #$20
.1a32de	a3 05		lda $05,s	                LDA L_Y0                    ; Get the row
.1a32e0	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.1a32e4	af 10 f0 1a	lda $1af010	                LDA @l GR_MAX_COLS
.1a32e8	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B         ; Multiply by the number of columns in the pixmap
.1a32ec	18		clc		                CLC                         ; Add the column
.1a32ed	af 04 01 00	lda $000104	                LDA @l M0_RESULT
.1a32f1	63 03		adc $03,s	                ADC L_X0
.1a32f3	85 0c		sta $080c	                STA SCRATCH
.1a32f5	e2 20		sep #$20	            SEP #$20
.1a32f7	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.1a32fb	69 00		adc #$00	                ADC #0
.1a32fd	85 0e		sta $080e	                STA SCRATCH+2
.1a32ff	c2 20		rep #$20	            REP #$20
.1a3301	18		clc		                CLC                         ; Set the destination address
.1a3302	a5 9e		lda $089e	                LDA MTEMPPTR
.1a3304	65 0c		adc $080c	                ADC SCRATCH
.1a3306	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.1a330a	e2 20		sep #$20	            SEP #$20
.1a330c	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.1a330e	65 0e		adc $080e	                ADC SCRATCH+2
.1a3310	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H
.1a3314	c2 20		rep #$20	            REP #$20
.1a3316	38		sec		                SEC                         ; Set the width of the FILL operation
.1a3317	a3 07		lda $07,s	                LDA L_X1
.1a3319	e3 03		sbc $03,s	                SBC L_X0
.1a331b	85 0c		sta $080c	                STA SCRATCH
.1a331d	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.1a3321	38		sec		                SEC
.1a3322	af 10 f0 1a	lda $1af010	                LDA @l GR_MAX_COLS
.1a3326	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L    ; And the destination stride
.1a332a	38		sec		                SEC                         ; Set the height of the FILL operation
.1a332b	a3 09		lda $09,s	                LDA L_Y1
.1a332d	e3 05		sbc $05,s	                SBC L_Y0
.1a332f	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.1a3333	e2 20		sep #$20	            SEP #$20
.1a3335	a3 0b		lda $0b,s	                LDA L_COLOR                 ; Set the color to write
.1a3337	8f 01 04 af	sta $af0401	                STA @l VDMA_BYTE_2_WRITE
.1a333b	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.1a333f	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF
.1a3341	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a3345	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.1a3349	30 fa		bmi $1a3345	                BMI wait
.1a334b	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.1a334d	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a3351					done
.1a3351	c2 20		rep #$20	            REP #$20
.1a3353	3b		tsc		            TSC
.1a3354	18		clc		            CLC
.1a3355	69 0c 00	adc #$000c	            ADC #SIZE(locals)
.1a3358	1b		tcs		            TCS
.1a3359	28		plp		                PLP
.1a335a	60		rts		            RTS
.1a335b					SPADDR
.1a335b	08		php		                PHP
.1a335c	c2 20		rep #$20	            REP #$20
.1a335e	c9 40 00	cmp #$0040	                CMP #SP_MAX
.1a3361	b0 13		bcs $1a3376	                BGE error
.1a3363	0a		asl a		                ASL A                       ; Multiply it by 8 (the size of s sprite block)
.1a3364	0a		asl a		                ASL A
.1a3365	0a		asl a		                ASL A
.1a3366	18		clc		                CLC                         ; Add it to the address of the first
.1a3367	69 00 0c	adc #$0c00	                ADC #<>SP00_CONTROL_REG     ; sprite block
.1a336a	85 9e		sta $089e	                STA MTEMPPTR
.1a336c	a9 af 00	lda #$00af	                LDA #`SP00_CONTROL_REG
.1a336f	69 00 00	adc #$0000	                ADC #0
.1a3372	85 a0		sta $08a0	                STA MTEMPPTR+2              ; And save that to MTEMPPTR
.1a3374	28		plp		                PLP
.1a3375	60		rts		            RTS
.1a3376					error
.1a3376	08		php		            PHP
.1a3377	c2 20		rep #$20	            REP #$20
.1a3379	48		pha		            PHA
.1a337a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a337d	5b		tcd		            TCD
.1a337e	68		pla		            PLA
.1a337f	28		plp		            PLP
.1a3380	e2 20		sep #$20	            SEP #$20
.1a3382	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3384	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3388	c2 20		rep #$20	            REP #$20
.1a338a	29 ff 00	and #$00ff	            AND #$00FF
.1a338d	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a3390	e2 20		sep #$20	            SEP #$20
.1a3392	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3395					S_SPRITE
.1a3395	08		php		                PHP
.1a3396					locals
>0001					L_SPRITE        .word ?
>0003					L_LUT           .byte ?
.1a3396	c2 20		rep #$20	            REP #$20
.1a3398	3b		tsc		            TSC
.1a3399	38		sec		            SEC
.1a339a	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.1a339d	1b		tcs		            TCS
.1a339e	c2 30		rep #$30	            REP #$30
.1a33a0	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a33a3	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a33a6	a5 23		lda $0823	                LDA ARGUMENT1
.1a33a8	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.1a33aa	a9 2c 00	lda #$002c	                LDA #','
.1a33ad	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a33b0	e2 20		sep #$20	            SEP #$20
.1a33b2	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a33b5	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a33b8	a5 23		lda $0823	                LDA ARGUMENT1
.1a33ba	c9 08		cmp #$08	                CMP #GR_MAX_LUT             ; Check that it's in range
.1a33bc	b0 56		bcs $1a3414	                BGE error                   ; If not: throw an error
.1a33be	83 03		sta $03,s	                STA L_LUT                   ; Save it as lut
.1a33c0	a9 2c		lda #$2c	                LDA #','
.1a33c2	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a33c5	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a33c8	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a33cb	c2 20		rep #$20	            REP #$20
.1a33cd	38		sec		                SEC                         ; Adjust address to be in Vicky's space
.1a33ce	a5 23		lda $0823	                LDA ARGUMENT1
.1a33d0	e9 00 00	sbc #$0000	                SBC #<>VRAM
.1a33d3	85 23		sta $0823	                STA ARGUMENT1
.1a33d5	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a33d7	e9 b0 00	sbc #$00b0	                SBC #`VRAM
.1a33da	85 25		sta $0825	                STA ARGUMENT1+2
.1a33dc	30 36		bmi $1a3414	                BMI error                   ; If negative, throw an error
.1a33de	c2 20		rep #$20	            REP #$20
.1a33e0	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a33e2	aa		tax		                TAX
.1a33e3	20 5b 33	jsr $1a335b	            JSR SPADDR
.1a33e6	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the lower word of the address
.1a33e8	a0 01 00	ldy #$0001	                LDY #SP_ADDR
.1a33eb	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a33ed	e2 20		sep #$20	            SEP #$20
.1a33ef	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a33f1	c8		iny		                INY
.1a33f2	c8		iny		                INY
.1a33f3	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save the upper byte of the address
.1a33f5	bf 18 f0 1a	lda $1af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the sprite control register
.1a33f9	29 f1		and #$f1	                AND #%11110001              ; Filter off the current LUT
.1a33fb	85 0c		sta $080c	                STA SCRATCH
.1a33fd	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT back
.1a33ff	0a		asl a		                ASL A                       ; Sift it into the LUT position
.1a3400	29 0e		and #$0e	                AND #%00001110              ; Make sure we don't have anything wrong there
.1a3402	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with what's in the sprite's control
.1a3404	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the register's bits
.1a3406	9f 18 f0 1a	sta $1af018,x	                STA @l GS_SP_CONTROL,X      ; And the shadow register
.1a340a					done
.1a340a	c2 20		rep #$20	            REP #$20
.1a340c	3b		tsc		            TSC
.1a340d	18		clc		            CLC
.1a340e	69 03 00	adc #$0003	            ADC #SIZE(locals)
.1a3411	1b		tcs		            TCS
.1a3412	28		plp		                PLP
.1a3413	60		rts		            RTS
.1a3414					error
.1a3414	08		php		            PHP
.1a3415	c2 20		rep #$20	            REP #$20
.1a3417	48		pha		            PHA
.1a3418	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a341b	5b		tcd		            TCD
.1a341c	68		pla		            PLA
.1a341d	28		plp		            PLP
.1a341e	e2 20		sep #$20	            SEP #$20
.1a3420	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3422	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3426	c2 20		rep #$20	            REP #$20
.1a3428	29 ff 00	and #$00ff	            AND #$00FF
.1a342b	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a342e	e2 20		sep #$20	            SEP #$20
.1a3430	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3433					S_SPRITEAT
.1a3433	08		php		                PHP
.1a3434					locals
>0001					L_SPRITE        .word ?
>0003					L_X             .word ?
.1a3434	c2 20		rep #$20	            REP #$20
.1a3436	3b		tsc		            TSC
.1a3437	38		sec		            SEC
.1a3438	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.1a343b	1b		tcs		            TCS
.1a343c	c2 30		rep #$30	            REP #$30
.1a343e	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3441	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a3444	a5 23		lda $0823	                LDA ARGUMENT1
.1a3446	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.1a3448	a9 2c 00	lda #$002c	                LDA #','
.1a344b	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a344e	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3451	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3454	a5 23		lda $0823	                LDA ARGUMENT1
.1a3456	83 03		sta $03,s	                STA L_X                     ; Save it as X
.1a3458	a9 2c 00	lda #$002c	                LDA #','
.1a345b	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a345e	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3461	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3464	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a3466	20 5b 33	jsr $1a335b	            JSR SPADDR
.1a3469	a3 03		lda $03,s	                LDA L_X                     ; Get the X coordinate
.1a346b	a0 04 00	ldy #$0004	                LDY #SP_X_COORD             ; Save the X coordinate for the sprite
.1a346e	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3470	a5 23		lda $0823	                LDA ARGUMENT1
.1a3472	a0 06 00	ldy #$0006	                LDY #SP_Y_COORD             ; Save the Y coordinate for the sprite
.1a3475	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3477					done
.1a3477	c2 20		rep #$20	            REP #$20
.1a3479	3b		tsc		            TSC
.1a347a	18		clc		            CLC
.1a347b	69 04 00	adc #$0004	            ADC #SIZE(locals)
.1a347e	1b		tcs		            TCS
.1a347f	28		plp		                PLP
.1a3480	60		rts		            RTS
.1a3481					S_SPRITESHOW
.1a3481	08		php		                PHP
.1a3482					locals
>0001					L_SPRITE        .word ?
>0003					L_VISIBLE       .byte ?
.1a3482	c2 20		rep #$20	            REP #$20
.1a3484	3b		tsc		            TSC
.1a3485	38		sec		            SEC
.1a3486	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.1a3489	1b		tcs		            TCS
.1a348a	c2 30		rep #$30	            REP #$30
.1a348c	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a348f	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a3492	a5 23		lda $0823	                LDA ARGUMENT1
.1a3494	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.1a3496	a9 2c 00	lda #$002c	                LDA #','
.1a3499	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a349c	e2 20		sep #$20	            SEP #$20
.1a349e	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a34a1	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a34a4	a5 23		lda $0823	                LDA ARGUMENT1
.1a34a6	d0 04		bne $1a34ac	                BNE is_visible
.1a34a8	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 0 (not visible)
.1a34aa	80 04		bra $1a34b0	                BRA chk_layer
.1a34ac	a9 01		lda #$01	is_visible      LDA #1
.1a34ae	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 1 (visible)
.1a34b0	a9 2c		lda #$2c	chk_layer       LDA #','
.1a34b2	85 37		sta $0837	                STA TARGETTOK
.1a34b4	20 5f 22	jsr $1a225f	            JSR OPT_TOK
.1a34b7	b0 20		bcs $1a34d9	                BCS get_layer               ; Yes: get the layer
.1a34b9					no_layer
.1a34b9	c2 30		rep #$30	            REP #$30
.1a34bb	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a34bd	aa		tax		                TAX
.1a34be	20 5b 33	jsr $1a335b	            JSR SPADDR
.1a34c1	e2 20		sep #$20	            SEP #$20
.1a34c3	bf 18 f0 1a	lda $1af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.1a34c7	29 fe		and #$fe	                AND #$FE                    ; Filter out the enable bit
.1a34c9	85 0c		sta $080c	                STA SCRATCH
.1a34cb	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.1a34cd	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.1a34cf	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.1a34d1	9f 18 f0 1a	sta $1af018,x	                STA @l GS_SP_CONTROL,X      ; And save it
.1a34d5	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; ... and to Vicky
.1a34d7	80 36		bra $1a350f	                BRA done
.1a34d9					get_layer
.1a34d9	c2 30		rep #$30	            REP #$30
.1a34db	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a34de	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a34e1	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a34e4	a5 23		lda $0823	                LDA ARGUMENT1
.1a34e6	c9 08 00	cmp #$0008	                CMP #8                      ; Make sure it's in range
.1a34e9	b0 2e		bcs $1a3519	                BGE error                   ; If not, throw an out of range error
.1a34eb	0a		asl a		                ASL A                       ; If it's ok... shift it into position
.1a34ec	0a		asl a		                ASL A
.1a34ed	0a		asl a		                ASL A
.1a34ee	0a		asl a		                ASL A
.1a34ef	85 0c		sta $080c	                STA SCRATCH                 ; And save it in SCRATCH
.1a34f1	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a34f3	aa		tax		                TAX
.1a34f4	20 5b 33	jsr $1a335b	            JSR SPADDR
.1a34f7	e2 20		sep #$20	            SEP #$20
.1a34f9	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.1a34fb	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.1a34fd	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.1a34ff	85 0c		sta $080c	                STA SCRATCH
.1a3501	bf 18 f0 1a	lda $1af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.1a3505	29 8e		and #$8e	                AND #%10001110              ; Filter out the enable and layer bits
.1a3507	05 0c		ora $080c	                ORA SCRATCH                 ; Combine with the provided layer and enable
.1a3509	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the bits in Vicky
.1a350b	9f 18 f0 1a	sta $1af018,x	                STA @l GS_SP_CONTROL,X      ; And to the shadow registers
.1a350f					done
.1a350f	c2 20		rep #$20	            REP #$20
.1a3511	3b		tsc		            TSC
.1a3512	18		clc		            CLC
.1a3513	69 03 00	adc #$0003	            ADC #SIZE(locals)
.1a3516	1b		tcs		            TCS
.1a3517	28		plp		                PLP
.1a3518	60		rts		            RTS
.1a3519					error
.1a3519	08		php		            PHP
.1a351a	c2 20		rep #$20	            REP #$20
.1a351c	48		pha		            PHA
.1a351d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3520	5b		tcd		            TCD
.1a3521	68		pla		            PLA
.1a3522	28		plp		            PLP
.1a3523	e2 20		sep #$20	            SEP #$20
.1a3525	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3527	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a352b	c2 20		rep #$20	            REP #$20
.1a352d	29 ff 00	and #$00ff	            AND #$00FF
.1a3530	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a3533	e2 20		sep #$20	            SEP #$20
.1a3535	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3538					TILESET_ADDR
.1a3538	08		php		                PHP
.1a3539	c2 20		rep #$20	            REP #$20
.1a353b	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.1a353e	b0 19		bcs $1a3559	                BGE out_of_range            ; If not, throw a range error
.1a3540	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.1a3543	a9 04 00	lda #$0004	                LDA #TILESET_REG_SIZE       ; Multiply it by the number of bytes in a tile set register set
.1a3546	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.1a3549	18		clc		                CLC                         ; Add to TILESET0_ADDY_L to get the final address
.1a354a	ad 04 01	lda $0104	                LDA @w M0_RESULT
.1a354d	69 80 02	adc #$0280	                ADC #<>TILESET0_ADDY_L
.1a3550	85 9e		sta $089e	                STA MTEMPPTR
.1a3552	a9 af 00	lda #$00af	                LDA #`TILESET0_ADDY_L
.1a3555	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a3557	28		plp		                PLP
.1a3558	60		rts		            RTS
.1a3559					out_of_range
.1a3559	08		php		            PHP
.1a355a	c2 20		rep #$20	            REP #$20
.1a355c	48		pha		            PHA
.1a355d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3560	5b		tcd		            TCD
.1a3561	68		pla		            PLA
.1a3562	28		plp		            PLP
.1a3563	e2 20		sep #$20	            SEP #$20
.1a3565	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3567	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a356b	c2 20		rep #$20	            REP #$20
.1a356d	29 ff 00	and #$00ff	            AND #$00FF
.1a3570	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a3573	e2 20		sep #$20	            SEP #$20
.1a3575	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3578					TILEMAP_ADDR
.1a3578	08		php		                PHP
.1a3579	c2 20		rep #$20	            REP #$20
.1a357b	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.1a357e	b0 19		bcs $1a3599	                BGE out_of_range            ; If not, throw a range error
.1a3580	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.1a3583	a9 0c 00	lda #$000c	                LDA #TILEMAP_REG_SIZE       ; Multiply it by the number of bytes in a tile map register set
.1a3586	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.1a3589	18		clc		                CLC
.1a358a	ad 04 01	lda $0104	                LDA @w M0_RESULT            ; Add to TL0_CONTROL_REG to get the final address
.1a358d	69 00 02	adc #$0200	                ADC #<>TL0_CONTROL_REG
.1a3590	85 9e		sta $089e	                STA MTEMPPTR
.1a3592	a9 af 00	lda #$00af	                LDA #`TL0_CONTROL_REG
.1a3595	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a3597	28		plp		                PLP
.1a3598	60		rts		            RTS
.1a3599					out_of_range
.1a3599	08		php		            PHP
.1a359a	c2 20		rep #$20	            REP #$20
.1a359c	48		pha		            PHA
.1a359d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a35a0	5b		tcd		            TCD
.1a35a1	68		pla		            PLA
.1a35a2	28		plp		            PLP
.1a35a3	e2 20		sep #$20	            SEP #$20
.1a35a5	a9 09		lda #$09	            LDA #ERR_RANGE
.1a35a7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a35ab	c2 20		rep #$20	            REP #$20
.1a35ad	29 ff 00	and #$00ff	            AND #$00FF
.1a35b0	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a35b3	e2 20		sep #$20	            SEP #$20
.1a35b5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a35b8					S_TILESET
.1a35b8	08		php		                PHP
.1a35b9					locals
>0001					L_TILENUM       .word ?
>0003					L_LUT           .word ?
>0005					L_IS_SQUARE     .word ?
.1a35b9	c2 20		rep #$20	            REP #$20
.1a35bb	3b		tsc		            TSC
.1a35bc	38		sec		            SEC
.1a35bd	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.1a35c0	1b		tcs		            TCS
.1a35c1	c2 20		rep #$20	            REP #$20
.1a35c3	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a35c6	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a35c9	a5 23		lda $0823	                LDA ARGUMENT1
.1a35cb	83 01		sta $01,s	                STA L_TILENUM               ; Save it as the tile set/map number
.1a35cd	a9 2c 00	lda #$002c	                LDA #','
.1a35d0	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a35d3	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a35d6	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a35d9	a5 23		lda $0823	                LDA ARGUMENT1
.1a35db	83 03		sta $03,s	                STA L_LUT                   ; Save it as LUT
.1a35dd	a9 2c 00	lda #$002c	                LDA #','
.1a35e0	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a35e3	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a35e6	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a35e9	a5 23		lda $0823	                LDA ARGUMENT1
.1a35eb	83 05		sta $05,s	                STA L_IS_SQUARE             ; Save it as IS_SQUARE
.1a35ed	a9 2c 00	lda #$002c	                LDA #','
.1a35f0	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a35f3	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a35f6	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a35f9	a3 01		lda $01,s	                LDA L_TILENUM
.1a35fb	20 38 35	jsr $1a3538	            JSR TILESET_ADDR
.1a35fe	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the bitmap address - the address of the start of VRAM
.1a3600	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And save it to the registers
.1a3602	e2 20		sep #$20	            SEP #$20
.1a3604	38		sec		                SEC
.1a3605	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3607	e9 b0		sbc #$b0	                SBC #`VRAM
.1a3609	a0 02 00	ldy #$0002	                LDY #TILESET_ADDY_H
.1a360c	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a360e	a3 05		lda $05,s	                LDA L_IS_SQUARE             ; Check if is_square == 0?
.1a3610	d0 0d		bne $1a361f	                BNE is_square
.1a3612					not_square
.1a3612	e2 20		sep #$20	            SEP #$20
.1a3614	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.1a3616	29 07		and #$07	                AND #$07                    ; Force it to be in range
.1a3618	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.1a361b	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.1a361d	80 0d		bra $1a362c	                BRA done
.1a361f					is_square
.1a361f	e2 20		sep #$20	            SEP #$20
.1a3621	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.1a3623	29 07		and #$07	                AND #$07                    ; Force it to be in range
.1a3625	09 08		ora #$08	                ORA #TILESET_SQUARE_256     ; Turn on the 256x256 flag
.1a3627	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.1a362a	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.1a362c					done
.1a362c	c2 20		rep #$20	            REP #$20
.1a362e	3b		tsc		            TSC
.1a362f	18		clc		            CLC
.1a3630	69 06 00	adc #$0006	            ADC #SIZE(locals)
.1a3633	1b		tcs		            TCS
.1a3634	28		plp		                PLP
.1a3635	60		rts		            RTS
.1a3636					S_TILEMAP
.1a3636	08		php		                PHP
.1a3637					locals
>0001					L_TILENUM       .word ?
>0003					L_WIDTH         .word ?
>0005					L_HEIGHT        .word ?
.1a3637	c2 20		rep #$20	            REP #$20
.1a3639	3b		tsc		            TSC
.1a363a	38		sec		            SEC
.1a363b	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.1a363e	1b		tcs		            TCS
.1a363f	c2 20		rep #$20	            REP #$20
.1a3641	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3644	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a3647	a5 23		lda $0823	                LDA ARGUMENT1
.1a3649	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.1a364b	a9 2c 00	lda #$002c	                LDA #','
.1a364e	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3651	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3654	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3657	a5 23		lda $0823	                LDA ARGUMENT1
.1a3659	83 03		sta $03,s	                STA L_WIDTH                 ; Save it as WIDTH
.1a365b	a9 2c 00	lda #$002c	                LDA #','
.1a365e	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3661	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3664	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3667	a5 23		lda $0823	                LDA ARGUMENT1
.1a3669	83 05		sta $05,s	                STA L_HEIGHT                ; Save it as HEIGHT
.1a366b	a9 2c 00	lda #$002c	                LDA #','
.1a366e	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3671	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3674	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3677	a3 01		lda $01,s	                LDA L_TILENUM
.1a3679	20 78 35	jsr $1a3578	            JSR TILEMAP_ADDR
.1a367c	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the map address - the address of the start of VRAM
.1a367e	a0 01 00	ldy #$0001	                LDY #TILEMAP_START_ADDY
.1a3681	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; And save it to the registers
.1a3683	e2 20		sep #$20	            SEP #$20
.1a3685	38		sec		                SEC
.1a3686	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3688	e9 b0		sbc #$b0	                SBC #`VRAM
.1a368a	c8		iny		                INY
.1a368b	c8		iny		                INY
.1a368c	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a368e	c2 20		rep #$20	            REP #$20
.1a3690	a3 03		lda $03,s	                LDA L_WIDTH                 ; Set the width
.1a3692	a0 04 00	ldy #$0004	                LDY #TILEMAP_TOTAL_X
.1a3695	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3697	a3 05		lda $05,s	                LDA L_HEIGHT                ; Set the height
.1a3699	a0 06 00	ldy #$0006	                LDY #TILEMAP_TOTAL_Y
.1a369c	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a369e					done
.1a369e	c2 20		rep #$20	            REP #$20
.1a36a0	3b		tsc		            TSC
.1a36a1	18		clc		            CLC
.1a36a2	69 06 00	adc #$0006	            ADC #SIZE(locals)
.1a36a5	1b		tcs		            TCS
.1a36a6	28		plp		                PLP
.1a36a7	60		rts		            RTS
.1a36a8					S_TILESHOW
.1a36a8	08		php		                PHP
.1a36a9					locals
>0001					L_TILENUM       .word ?
.1a36a9	c2 20		rep #$20	            REP #$20
.1a36ab	f4 00 00	pea #$0000	            PEA #0
.1a36ae	c2 20		rep #$20	            REP #$20
.1a36b0	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a36b3	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a36b6	a5 23		lda $0823	                LDA ARGUMENT1
.1a36b8	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.1a36ba	a9 2c 00	lda #$002c	                LDA #','
.1a36bd	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a36c0	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a36c3	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a36c6	a3 01		lda $01,s	                LDA L_TILENUM
.1a36c8	20 78 35	jsr $1a3578	            JSR TILEMAP_ADDR
.1a36cb	a5 23		lda $0823	                LDA ARGUMENT1               ; CHeck the visible parameter
.1a36cd	d0 06		bne $1a36d5	                BNE is_visible              ; If it's <> 0, make it visible
.1a36cf	e2 20		sep #$20	            SEP #$20
.1a36d1	a9 00		lda #$00	                LDA #0                      ; Control value for invisible
.1a36d3	80 04		bra $1a36d9	                BRA set_control
.1a36d5					is_visible
.1a36d5	e2 20		sep #$20	            SEP #$20
.1a36d7	a9 01		lda #$01	                LDA #TILEMAP_VISIBLE        ; Control value for visible
.1a36d9					set_control
.1a36d9	e2 20		sep #$20	            SEP #$20
.1a36db	a0 00 00	ldy #$0000	                LDY #TILEMAP_CONTROL        ; Set the control register
.1a36de	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a36e0					done
.1a36e0	c2 20		rep #$20	            REP #$20
.1a36e2	68		pla		            PLA
.1a36e3	28		plp		                PLP
.1a36e4	60		rts		            RTS
.1a36e5					S_TILEAT
.1a36e5	08		php		                PHP
.1a36e6					locals
>0001					L_TILENUM       .word ?
>0003					L_X             .word ?
.1a36e6	c2 20		rep #$20	            REP #$20
.1a36e8	3b		tsc		            TSC
.1a36e9	38		sec		            SEC
.1a36ea	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.1a36ed	1b		tcs		            TCS
.1a36ee	c2 20		rep #$20	            REP #$20
.1a36f0	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a36f3	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a36f6	a5 23		lda $0823	                LDA ARGUMENT1
.1a36f8	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.1a36fa	a9 2c 00	lda #$002c	                LDA #','
.1a36fd	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3700	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3703	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3706	a5 23		lda $0823	                LDA ARGUMENT1
.1a3708	83 03		sta $03,s	                STA L_X                     ; Save as X
.1a370a	a9 2c 00	lda #$002c	                LDA #','
.1a370d	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3710	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3713	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3716	a3 01		lda $01,s	                LDA L_TILENUM
.1a3718	20 78 35	jsr $1a3578	            JSR TILEMAP_ADDR
.1a371b	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the Y position
.1a371d	a0 0a 00	ldy #$000a	                LDY #TILEMAP_WINDOW_Y
.1a3720	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3722	a3 03		lda $03,s	                LDA L_X                     ; Set the X position
.1a3724	a0 08 00	ldy #$0008	                LDY #TILEMAP_WINDOW_X
.1a3727	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3729					done
.1a3729	c2 20		rep #$20	            REP #$20
.1a372b	3b		tsc		            TSC
.1a372c	18		clc		            CLC
.1a372d	69 04 00	adc #$0004	            ADC #SIZE(locals)
.1a3730	1b		tcs		            TCS
.1a3731	28		plp		                PLP
.1a3732	60		rts		            RTS
=0					DMA_LINEAR = 0                              ; Memory to copy is a continguous, linear range
=1					DMA_RECT = 1                                ; Memory to copy is a rectangular block
.0000					DMA_BLOCK
>0000					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>0001					ADDR            .long ?                     ; The starting address for the data to transfer
>0004					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>0007					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>0009					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>000b					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
=$01					DMA_SRC_2D = $01                            ; Source transfer should be 2D
=$02					DMA_DST_2D = $02                            ; Destination transfer should be 2D
=$10					DMA_SRC_SRAM = $10                          ; Flag indicating that the source is in SRAM ($00:0000 - $3F:FFFF)
=$20					DMA_DST_SRAM = $20                          ; Flag indicating that the destination is in SRAM ($00:0000 - $3F:FFFF)
>1af058					DMA_BLOCKS      .byte ?                     ; What blocks are involved
.1af059					DMA_SRC
>1af059					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>1af05a					ADDR            .long ?                     ; The starting address for the data to transfer
>1af05d					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>1af060					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>1af062					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>1af064					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.1af066					DMA_DEST
>1af066					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>1af067					ADDR            .long ?                     ; The starting address for the data to transfer
>1af06a					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>1af06d					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>1af06f					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>1af071					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.1a3733					DO_DMA
.1a3733	0b		phd		                PHD
.1a3734	08		php		                PHP
.1a3735	08		php		            PHP
.1a3736	c2 20		rep #$20	            REP #$20
.1a3738	48		pha		            PHA
.1a3739	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a373c	5b		tcd		            TCD
.1a373d	68		pla		            PLA
.1a373e	28		plp		            PLP
.1a373f	e2 20		sep #$20	            SEP #$20
.1a3741	a9 00		lda #$00	                LDA #0
.1a3743	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS           ; Set mode to something neutral
.1a3747	af 5c f0 1a	lda $1af05c	                LDA @l DMA_SRC.ADDR+2       ; Check the bank
.1a374b	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.1a374d	b0 1c		bcs $1a376b	                BGE src_vram                ; Yes: leave the DMA_BLOCK bit alone
.1a374f	8f 24 04 af	sta $af0424	src_sram        STA @l SDMA_SRC_ADDY_H      ; Set the SDMA source address
.1a3753	af 5b f0 1a	lda $1af05b	                LDA @l DMA_SRC.ADDR+1
.1a3757	8f 23 04 af	sta $af0423	                STA @l SDMA_SRC_ADDY_M
.1a375b	af 5a f0 1a	lda $1af05a	                LDA @l DMA_SRC.ADDR
.1a375f	8f 22 04 af	sta $af0422	                STA @l SDMA_SRC_ADDY_L
.1a3763	a9 10		lda #$10	                LDA #DMA_SRC_SRAM           ; Set the SRAM source block bit
.1a3765	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a3769	80 17		bra $1a3782	                BRA src_mode
.1a376b	38		sec		src_vram        SEC                         ; Convert to VRAM relative address
.1a376c	e9 b0		sbc #$b0	                SBC #`VRAM
.1a376e	8f 04 04 af	sta $af0404	                STA @l VDMA_SRC_ADDY_H      ; Set the VDMA source address
.1a3772	af 5b f0 1a	lda $1af05b	                LDA @l DMA_SRC.ADDR+1
.1a3776	8f 03 04 af	sta $af0403	                STA @l VDMA_SRC_ADDY_M
.1a377a	af 5a f0 1a	lda $1af05a	                LDA @l DMA_SRC.ADDR
.1a377e	8f 02 04 af	sta $af0402	                STA @l VDMA_SRC_ADDY_L
.1a3782	af 59 f0 1a	lda $1af059	src_mode        LDA @l DMA_SRC.MODE         ; Determine if source is 1D or 2D
.1a3786	d0 3c		bne $1a37c4	                BNE src_2d
.1a3788	af 58 f0 1a	lda $1af058	src_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.1a378c	f0 1b		beq $1a37a9	                BEQ src_1d_vram
.1a378e	af 5d f0 1a	lda $1af05d	src_1d_sram     LDA @l DMA_SRC.SIZE         ; It's SRAM, so set the SDMA size
.1a3792	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.1a3796	af 5e f0 1a	lda $1af05e	                LDA @l DMA_SRC.SIZE+1
.1a379a	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_M
.1a379e	af 5f f0 1a	lda $1af05f	                LDA @l DMA_SRC.SIZE+2
.1a37a2	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.1a37a6	82 8b 00	brl $1a3834	                BRL set_dst                 ; Go to set up the destination
.1a37a9	af 5d f0 1a	lda $1af05d	src_1d_vram     LDA @l DMA_SRC.SIZE         ; It's VRAM, so set the VDMA size
.1a37ad	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.1a37b1	af 5e f0 1a	lda $1af05e	                LDA @l DMA_SRC.SIZE+1
.1a37b5	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_M
.1a37b9	af 5f f0 1a	lda $1af05f	                LDA @l DMA_SRC.SIZE+2
.1a37bd	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.1a37c1	82 70 00	brl $1a3834	                BRL set_dst                 ; Go to set up the destination
.1a37c4	af 58 f0 1a	lda $1af058	src_2d          LDA @l DMA_BLOCKS
.1a37c8	09 01		ora #$01	                ORA #DMA_SRC_2D             ; Set the bit to make the source a 2D transfer
.1a37ca	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a37ce	89 10		bit #$10	                BIT #DMA_SRC_SRAM           ; Are we writing to SRAM
.1a37d0	f0 32		beq $1a3804	                BEQ src_2d_vram             ; No: set the 2d values in the VRAM source
.1a37d2	af 60 f0 1a	lda $1af060	src_2d_sram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.1a37d6	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.1a37da	af 61 f0 1a	lda $1af061	                LDA @l DMA_SRC.WIDTH+1
.1a37de	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.1a37e2	af 62 f0 1a	lda $1af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.1a37e6	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.1a37ea	af 63 f0 1a	lda $1af063	                LDA @l DMA_SRC.HEIGHT+1
.1a37ee	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.1a37f2	af 64 f0 1a	lda $1af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.1a37f6	8f 2c 04 af	sta $af042c	                STA @l SDMA_SRC_STRIDE_L
.1a37fa	af 65 f0 1a	lda $1af065	                LDA @l DMA_SRC.STRIDE+1
.1a37fe	8f 2d 04 af	sta $af042d	                STA @l SDMA_SRC_STRIDE_L+1
.1a3802	80 30		bra $1a3834	                BRA set_dst
.1a3804	af 60 f0 1a	lda $1af060	src_2d_vram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.1a3808	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.1a380c	af 61 f0 1a	lda $1af061	                LDA @l DMA_SRC.WIDTH+1
.1a3810	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.1a3814	af 62 f0 1a	lda $1af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.1a3818	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.1a381c	af 63 f0 1a	lda $1af063	                LDA @l DMA_SRC.HEIGHT+1
.1a3820	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.1a3824	af 64 f0 1a	lda $1af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.1a3828	8f 0c 04 af	sta $af040c	                STA @l VDMA_SRC_STRIDE_L
.1a382c	af 65 f0 1a	lda $1af065	                LDA @l DMA_SRC.STRIDE+1
.1a3830	8f 0d 04 af	sta $af040d	                STA @l VDMA_SRC_STRIDE_L+1
.1a3834					set_dst
.1a3834	e2 20		sep #$20	            SEP #$20
.1a3836	af 69 f0 1a	lda $1af069	                LDA @l DMA_DEST.ADDR+2      ; Check the bank
.1a383a	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.1a383c	b0 20		bcs $1a385e	                BGE dst_vram                ; Yes: leave the DMA_BLOCK bit alone
.1a383e	8f 27 04 af	sta $af0427	dst_sram        STA @l SDMA_DST_ADDY_H      ; Set the SDMA destination address
.1a3842	af 68 f0 1a	lda $1af068	                LDA @l DMA_DEST.ADDR+1
.1a3846	8f 26 04 af	sta $af0426	                STA @l SDMA_DST_ADDY_M
.1a384a	af 67 f0 1a	lda $1af067	                LDA @l DMA_DEST.ADDR
.1a384e	8f 25 04 af	sta $af0425	                STA @l SDMA_DST_ADDY_L
.1a3852	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS
.1a3856	09 20		ora #$20	                ORA #DMA_DST_SRAM           ; Set the bit to indicate the destination is SRAM
.1a3858	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a385c	80 17		bra $1a3875	                BRA dst_mode
.1a385e	38		sec		dst_vram        SEC                         ; Convert to VRAM relative address
.1a385f	e9 b0		sbc #$b0	                SBC #`VRAM
.1a3861	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H      ; Set the VDMA destination address
.1a3865	af 68 f0 1a	lda $1af068	                LDA @l DMA_DEST.ADDR+1
.1a3869	8f 06 04 af	sta $af0406	                STA @l VDMA_DST_ADDY_M
.1a386d	af 67 f0 1a	lda $1af067	                LDA @l DMA_DEST.ADDR
.1a3871	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.1a3875	af 66 f0 1a	lda $1af066	dst_mode        LDA @l DMA_DEST.MODE
.1a3879	d0 3e		bne $1a38b9	                BNE dst_2d                  ; If 2D, set up the 2D destination parameters
.1a387b	af 58 f0 1a	lda $1af058	dst_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.1a387f	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Is the destination SRAM?
.1a3881	f0 1b		beq $1a389e	                BEQ dst_1d_vram
.1a3883	af 6a f0 1a	lda $1af06a	dst_1d_sram     LDA @l DMA_DEST.SIZE
.1a3887	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.1a388b	af 6b f0 1a	lda $1af06b	                LDA @l DMA_DEST.SIZE+1
.1a388f	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_L+1
.1a3893	af 6c f0 1a	lda $1af06c	                LDA @l DMA_DEST.SIZE+2
.1a3897	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.1a389b	82 8b 00	brl $1a3929	                BRL start_xfer
.1a389e	af 6a f0 1a	lda $1af06a	dst_1d_vram     LDA @l DMA_DEST.SIZE
.1a38a2	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.1a38a6	af 6b f0 1a	lda $1af06b	                LDA @l DMA_DEST.SIZE+1
.1a38aa	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_L+1
.1a38ae	af 6c f0 1a	lda $1af06c	                LDA @l DMA_DEST.SIZE+2
.1a38b2	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.1a38b6	82 70 00	brl $1a3929	                BRL start_xfer
.1a38b9	af 58 f0 1a	lda $1af058	dst_2d          LDA @l DMA_BLOCKS
.1a38bd	09 02		ora #$02	                ORA #DMA_DST_2D             ; Set the bit to make the source a 2D transfer
.1a38bf	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a38c3	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Are we writing to the SRAM?
.1a38c5	f0 32		beq $1a38f9	                BEQ dst_2d_vram             ; No: set the 2D parameters for VRAM
.1a38c7	af 6d f0 1a	lda $1af06d	dst_2d_sram     LDA @l DMA_DEST.WIDTH       ; Set the SRAM width
.1a38cb	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.1a38cf	af 6e f0 1a	lda $1af06e	                LDA @L DMA_DEST.WIDTH+1
.1a38d3	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.1a38d7	af 6f f0 1a	lda $1af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the SRAM height
.1a38db	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.1a38df	af 70 f0 1a	lda $1af070	                LDA @L DMA_DEST.HEIGHT+1
.1a38e3	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.1a38e7	af 71 f0 1a	lda $1af071	                LDA @l DMA_DEST.STRIDE      ; Set the SRAM stride
.1a38eb	8f 2e 04 af	sta $af042e	                STA @l SDMA_DST_STRIDE_L
.1a38ef	af 72 f0 1a	lda $1af072	                LDA @L DMA_DEST.STRIDE+1
.1a38f3	8f 2f 04 af	sta $af042f	                STA @l SDMA_DST_STRIDE_L+1
.1a38f7	80 30		bra $1a3929	                BRA start_xfer
.1a38f9	af 6d f0 1a	lda $1af06d	dst_2d_vram     LDA @l DMA_DEST.WIDTH       ; Set the VRAM width
.1a38fd	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.1a3901	af 6e f0 1a	lda $1af06e	                LDA @L DMA_DEST.WIDTH+1
.1a3905	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.1a3909	af 6f f0 1a	lda $1af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the VRAM height
.1a390d	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.1a3911	af 70 f0 1a	lda $1af070	                LDA @L DMA_DEST.HEIGHT+1
.1a3915	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.1a3919	af 71 f0 1a	lda $1af071	                LDA @l DMA_DEST.STRIDE      ; Set the VRAM stride
.1a391d	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L
.1a3921	af 72 f0 1a	lda $1af072	                LDA @L DMA_DEST.STRIDE+1
.1a3925	8f 0f 04 af	sta $af040f	                STA @l VDMA_DST_STRIDE_L+1
.1a3929	af 58 f0 1a	lda $1af058	start_xfer      LDA @l DMA_BLOCKS
.1a392d	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.1a392f	f0 43		beq $1a3974	                BEQ start_vdma_only
.1a3931	c9 10		cmp #$10	                CMP #DMA_SRC_SRAM
.1a3933	f0 76		beq $1a39ab	                BEQ start_s2v
.1a3935	c9 20		cmp #$20	                CMP #DMA_DST_SRAM
.1a3937	d0 03		bne $1a393c	                BNE start_sdma_only
.1a3939	82 8a 00	brl $1a39c6	                BRL start_v2s
.1a393c					start_sdma_only
.1a393c	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.1a3940	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.1a3942	f0 23		beq $1a3967	                BEQ sdma_1d_only            ; Source and Destination 1D...
.1a3944	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.1a3946	f0 23		beq $1a396b	                BEQ sdma_2d_only            ; Source and Destination 2D
.1a3948	08		php		            PHP
.1a3949	c2 20		rep #$20	            REP #$20
.1a394b	48		pha		            PHA
.1a394c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a394f	5b		tcd		            TCD
.1a3950	68		pla		            PLA
.1a3951	28		plp		            PLP
.1a3952	e2 20		sep #$20	            SEP #$20
.1a3954	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a3956	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a395a	c2 20		rep #$20	            REP #$20
.1a395c	29 ff 00	and #$00ff	            AND #$00FF
.1a395f	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a3962	e2 20		sep #$20	            SEP #$20
.1a3964	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3967	a9 01		lda #$01	sdma_1d_only    LDA #SDMA_CTRL0_Enable      ; Set the bits for 1D, SRAM->SRAM
.1a3969	80 02		bra $1a396d	                BRA sdma_set_ctrl
.1a396b	a9 03		lda #$03	sdma_2d_only    LDA #SDMA_CTRL0_Enable | SDMA_CTRL0_1D_2D
.1a396d	8f 20 04 af	sta $af0420	sdma_set_ctrl   STA @l SDMA_CTRL_REG0
.1a3971	82 7d 00	brl $1a39f1	                BRL trig_sdma               ; And trigger the SDMA
.1a3974					start_vdma_only
.1a3974	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.1a3978	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.1a397a	f0 23		beq $1a399f	                BEQ vdma_1d_only            ; Source and Destination 1D...
.1a397c	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.1a397e	f0 23		beq $1a39a3	                BEQ vdma_2d_only            ; Source and Destination 2D...
.1a3980	08		php		            PHP
.1a3981	c2 20		rep #$20	            REP #$20
.1a3983	48		pha		            PHA
.1a3984	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3987	5b		tcd		            TCD
.1a3988	68		pla		            PLA
.1a3989	28		plp		            PLP
.1a398a	e2 20		sep #$20	            SEP #$20
.1a398c	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a398e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3992	c2 20		rep #$20	            REP #$20
.1a3994	29 ff 00	and #$00ff	            AND #$00FF
.1a3997	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a399a	e2 20		sep #$20	            SEP #$20
.1a399c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a399f	a9 01		lda #$01	vdma_1d_only    LDA #VDMA_CTRL_Enable       ; Set the bits for 1D, VRAM->VRAM
.1a39a1	80 02		bra $1a39a5	                BRA vdma_set_ctrl
.1a39a3	a9 03		lda #$03	vdma_2d_only    LDA #VDMA_CTRL_Enable | VDMA_CTRL_1D_2D
.1a39a5	8f 00 04 af	sta $af0400	vdma_set_ctrl   STA @l VDMA_CONTROL_REG
.1a39a9	80 34		bra $1a39df	                BRA trig_vdma               ; And trigger the VDMA
.1a39ab					start_s2v
.1a39ab	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.1a39af	29 01		and #$01	                AND #DMA_SRC_2D
.1a39b1	0a		asl a		                ASL A
.1a39b2	09 11		ora #$11	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Src
.1a39b4	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a39b8	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.1a39bc	29 02		and #$02	                AND #DMA_DST_2D
.1a39be	09 11		ora #$11	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Src
.1a39c0	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a39c4	80 19		bra $1a39df	                BRA trig_vdma               ; And trigger the VDMA
.1a39c6					start_v2s
.1a39c6	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.1a39ca	29 02		and #$02	                AND #DMA_DST_2D
.1a39cc	09 21		ora #$21	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Dst
.1a39ce	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a39d2	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.1a39d6	29 01		and #$01	                AND #DMA_SRC_2D
.1a39d8	0a		asl a		                ASL A
.1a39d9	09 21		ora #$21	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Dst
.1a39db	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a39df					trig_vdma
.1a39df	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.1a39e3	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF    ; Trigger the VDMA
.1a39e5	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a39e9	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Check if we need SDMA
.1a39ed	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.1a39ef	f0 0f		beq $1a3a00	                BEQ wait_vdma               ; No: wait for VDMA to complete
.1a39f1					trig_sdma
.1a39f1	af 20 04 af	lda $af0420	                LDA @l SDMA_CTRL_REG0
.1a39f5	09 80		ora #$80	                ORA #SDMA_CTRL0_Start_TRF   ; Trigger the SDMA
.1a39f7	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a39fb	ea		nop		                NOP                         ; When the transfer is started the CPU will be put on Hold (RDYn)...
.1a39fc	ea		nop		                NOP                         ; Before it actually gets to stop it will execute a couple more instructions
.1a39fd	ea		nop		                NOP                         ; From that point on, the CPU is halted (keep that in mind)
.1a39fe	ea		nop		                NOP                         ; No IRQ will be processed either during that time
.1a39ff	ea		nop		                NOP
.1a3a00	af 01 04 af	lda $af0401	wait_vdma       LDA @l VDMA_STATUS_REG      ; Check the VDMA status
.1a3a04	89 80		bit #$80	                BIT #VDMA_STAT_VDMA_IPS     ; If the transfer is still in process...
.1a3a06	d0 f8		bne $1a3a00	                BNE wait_vdma               ; Wait until it stops.
.1a3a08	a9 00		lda #$00	                LDA #$00                    ; Clear the TRF bits
.1a3a0a	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a3a0e	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a3a12	28		plp		                PLP
.1a3a13	2b		pld		                PLD
.1a3a14	60		rts		            RTS
.1a3a15					S_MEMCOPY
.1a3a15	0b		phd		                PHD
.1a3a16	08		php		                PHP
.1a3a17	e2 20		sep #$20	            SEP #$20
.1a3a19	c2 10		rep #$10	            REP #$10
.1a3a1b	a9 00		lda #$00	                LDA #0
.1a3a1d	a2 00 00	ldx #$0000	                LDX #0
.1a3a20	8f 59 f0 1a	sta $1af059	clr_loop        STA @l DMA_SRC
.1a3a24	e8		inx		                INX
.1a3a25	e0 1a 00	cpx #$001a	                CPX #SIZE(DMA_BLOCK) * 2
.1a3a28	d0 f6		bne $1a3a20	                BNE clr_loop
.1a3a2a	20 7e 22	jsr $1a227e	            JSR PEEK_TOK
.1a3a2d	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.1a3a2f	f0 23		beq $1a3a54	                BEQ src_linear                      ; Yes: go to process a linear source
.1a3a31	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.1a3a33	f0 5e		beq $1a3a93	                BEQ src_rect                        ; Yes: go to process a rectangular source
.1a3a35					syntax_err
.1a3a35	08		php		            PHP
.1a3a36	c2 20		rep #$20	            REP #$20
.1a3a38	48		pha		            PHA
.1a3a39	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3a3c	5b		tcd		            TCD
.1a3a3d	68		pla		            PLA
.1a3a3e	28		plp		            PLP
.1a3a3f	e2 20		sep #$20	            SEP #$20
.1a3a41	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3a43	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3a47	c2 20		rep #$20	            REP #$20
.1a3a49	29 ff 00	and #$00ff	            AND #$00FF
.1a3a4c	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a3a4f	e2 20		sep #$20	            SEP #$20
.1a3a51	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3a54					src_linear
.1a3a54	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3a57	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3a5a	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3a5d	c2 20		rep #$20	            REP #$20
.1a3a5f	a5 23		lda $0823	            LDA ARGUMENT1
.1a3a61	8f 5a f0 1a	sta $1af05a	            STA DMA_SRC.ADDR
.1a3a65	e2 20		sep #$20	            SEP #$20
.1a3a67	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3a69	8f 5c f0 1a	sta $1af05c	            STA DMA_SRC.ADDR+2
.1a3a6d	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a3a6f	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3a72	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3a75	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3a78	c2 20		rep #$20	            REP #$20
.1a3a7a	a5 23		lda $0823	            LDA ARGUMENT1
.1a3a7c	8f 5d f0 1a	sta $1af05d	            STA DMA_SRC.SIZE
.1a3a80	e2 20		sep #$20	            SEP #$20
.1a3a82	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3a84	8f 5f f0 1a	sta $1af05f	            STA DMA_SRC.SIZE+2
.1a3a88	e2 20		sep #$20	            SEP #$20
.1a3a8a	a9 00		lda #$00	            LDA #<DMA_LINEAR
.1a3a8c	8f 59 f0 1a	sta $1af059	            STA DMA_SRC.MODE
.1a3a90	82 74 00	brl $1a3b07	                BRL process_to
.1a3a93					src_rect
.1a3a93	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3a96	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3a99	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3a9c	c2 20		rep #$20	            REP #$20
.1a3a9e	a5 23		lda $0823	            LDA ARGUMENT1
.1a3aa0	8f 5a f0 1a	sta $1af05a	            STA DMA_SRC.ADDR
.1a3aa4	e2 20		sep #$20	            SEP #$20
.1a3aa6	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3aa8	8f 5c f0 1a	sta $1af05c	            STA DMA_SRC.ADDR+2
.1a3aac	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a3aae	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3ab1	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3ab4	20 0d 07	jsr $1a070d	            JSR ASS_ARG1_INT16
.1a3ab7	c2 20		rep #$20	            REP #$20
.1a3ab9	a5 23		lda $0823	            LDA ARGUMENT1
.1a3abb	8f 60 f0 1a	sta $1af060	            STA DMA_SRC.WIDTH
.1a3abf	8d 00 01	sta $0100	            STA M0_OPERAND_A
.1a3ac2	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a3ac5	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3ac8	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3acb	20 0d 07	jsr $1a070d	            JSR ASS_ARG1_INT16
.1a3ace	c2 20		rep #$20	            REP #$20
.1a3ad0	a5 23		lda $0823	            LDA ARGUMENT1
.1a3ad2	8f 62 f0 1a	sta $1af062	            STA DMA_SRC.HEIGHT
.1a3ad6	8d 02 01	sta $0102	            STA M0_OPERAND_B
.1a3ad9	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a3adc	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3adf	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3ae2	20 0d 07	jsr $1a070d	            JSR ASS_ARG1_INT16
.1a3ae5	c2 20		rep #$20	            REP #$20
.1a3ae7	a5 23		lda $0823	            LDA ARGUMENT1
.1a3ae9	8f 64 f0 1a	sta $1af064	            STA DMA_SRC.STRIDE
.1a3aed	c2 20		rep #$20	            REP #$20
.1a3aef	ad 04 01	lda $0104	            LDA M0_RESULT
.1a3af2	8f 5d f0 1a	sta $1af05d	            STA DMA_SRC.SIZE
.1a3af6	e2 20		sep #$20	            SEP #$20
.1a3af8	ad 06 01	lda $0106	            LDA M0_RESULT+2
.1a3afb	8f 5f f0 1a	sta $1af05f	            STA DMA_SRC.SIZE+2
.1a3aff	e2 20		sep #$20	            SEP #$20
.1a3b01	a9 01		lda #$01	            LDA #<DMA_RECT
.1a3b03	8f 59 f0 1a	sta $1af059	            STA DMA_SRC.MODE
.1a3b07					process_to
.1a3b07	e2 20		sep #$20	            SEP #$20
.1a3b09	a9 9c		lda #$9c	                LDA #TOK_TO
.1a3b0b	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3b0e	20 7e 22	jsr $1a227e	            JSR PEEK_TOK
.1a3b11	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.1a3b13	f0 23		beq $1a3b38	                BEQ dest_linear                     ; Yes: go to process a linear destination
.1a3b15	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.1a3b17	f0 5e		beq $1a3b77	                BEQ dest_rect                       ; Yes: go to process a rectangular source
.1a3b19					syntax_err2
.1a3b19	08		php		            PHP
.1a3b1a	c2 20		rep #$20	            REP #$20
.1a3b1c	48		pha		            PHA
.1a3b1d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3b20	5b		tcd		            TCD
.1a3b21	68		pla		            PLA
.1a3b22	28		plp		            PLP
.1a3b23	e2 20		sep #$20	            SEP #$20
.1a3b25	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3b27	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3b2b	c2 20		rep #$20	            REP #$20
.1a3b2d	29 ff 00	and #$00ff	            AND #$00FF
.1a3b30	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a3b33	e2 20		sep #$20	            SEP #$20
.1a3b35	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3b38					dest_linear
.1a3b38	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3b3b	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3b3e	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3b41	c2 20		rep #$20	            REP #$20
.1a3b43	a5 23		lda $0823	            LDA ARGUMENT1
.1a3b45	8f 67 f0 1a	sta $1af067	            STA DMA_DEST.ADDR
.1a3b49	e2 20		sep #$20	            SEP #$20
.1a3b4b	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3b4d	8f 69 f0 1a	sta $1af069	            STA DMA_DEST.ADDR+2
.1a3b51	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a3b53	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3b56	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3b59	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3b5c	c2 20		rep #$20	            REP #$20
.1a3b5e	a5 23		lda $0823	            LDA ARGUMENT1
.1a3b60	8f 6a f0 1a	sta $1af06a	            STA DMA_DEST.SIZE
.1a3b64	e2 20		sep #$20	            SEP #$20
.1a3b66	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3b68	8f 6c f0 1a	sta $1af06c	            STA DMA_DEST.SIZE+2
.1a3b6c	e2 20		sep #$20	            SEP #$20
.1a3b6e	a9 00		lda #$00	            LDA #<DMA_LINEAR
.1a3b70	8f 66 f0 1a	sta $1af066	            STA DMA_DEST.MODE
.1a3b74	82 74 00	brl $1a3beb	                BRL verify
.1a3b77					dest_rect
.1a3b77	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3b7a	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3b7d	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3b80	c2 20		rep #$20	            REP #$20
.1a3b82	a5 23		lda $0823	            LDA ARGUMENT1
.1a3b84	8f 67 f0 1a	sta $1af067	            STA DMA_DEST.ADDR
.1a3b88	e2 20		sep #$20	            SEP #$20
.1a3b8a	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3b8c	8f 69 f0 1a	sta $1af069	            STA DMA_DEST.ADDR+2
.1a3b90	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a3b92	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3b95	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3b98	20 0d 07	jsr $1a070d	            JSR ASS_ARG1_INT16
.1a3b9b	c2 20		rep #$20	            REP #$20
.1a3b9d	a5 23		lda $0823	            LDA ARGUMENT1
.1a3b9f	8f 6d f0 1a	sta $1af06d	            STA DMA_DEST.WIDTH
.1a3ba3	8d 00 01	sta $0100	            STA M0_OPERAND_A
.1a3ba6	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a3ba9	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3bac	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3baf	20 0d 07	jsr $1a070d	            JSR ASS_ARG1_INT16
.1a3bb2	c2 20		rep #$20	            REP #$20
.1a3bb4	a5 23		lda $0823	            LDA ARGUMENT1
.1a3bb6	8f 6f f0 1a	sta $1af06f	            STA DMA_DEST.HEIGHT
.1a3bba	8d 02 01	sta $0102	            STA M0_OPERAND_B
.1a3bbd	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a3bc0	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3bc3	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3bc6	20 0d 07	jsr $1a070d	            JSR ASS_ARG1_INT16
.1a3bc9	c2 20		rep #$20	            REP #$20
.1a3bcb	a5 23		lda $0823	            LDA ARGUMENT1
.1a3bcd	8f 71 f0 1a	sta $1af071	            STA DMA_DEST.STRIDE
.1a3bd1	c2 20		rep #$20	            REP #$20
.1a3bd3	ad 04 01	lda $0104	            LDA M0_RESULT
.1a3bd6	8f 6a f0 1a	sta $1af06a	            STA DMA_DEST.SIZE
.1a3bda	e2 20		sep #$20	            SEP #$20
.1a3bdc	ad 06 01	lda $0106	            LDA M0_RESULT+2
.1a3bdf	8f 6c f0 1a	sta $1af06c	            STA DMA_DEST.SIZE+2
.1a3be3	e2 20		sep #$20	            SEP #$20
.1a3be5	a9 01		lda #$01	            LDA #<DMA_RECT
.1a3be7	8f 66 f0 1a	sta $1af066	            STA DMA_DEST.MODE
.1a3beb					verify
.1a3beb	c2 20		rep #$20	            REP #$20
.1a3bed	af 5d f0 1a	lda $1af05d	                LDA @l DMA_SRC.SIZE
.1a3bf1	cf 6a f0 1a	cmp $1af06a	                CMP @l DMA_DEST.SIZE
.1a3bf5	d0 14		bne $1a3c0b	                BNE size_err
.1a3bf7	e2 20		sep #$20	            SEP #$20
.1a3bf9	af 5f f0 1a	lda $1af05f	                LDA @l DMA_SRC.SIZE+2
.1a3bfd	cf 6c f0 1a	cmp $1af06c	                CMP @l DMA_DEST.SIZE+2
.1a3c01	d0 08		bne $1a3c0b	                BNE size_err
.1a3c03	c2 20		rep #$20	            REP #$20
.1a3c05	20 33 37	jsr $1a3733	            JSR DO_DMA
.1a3c08	28		plp		                PLP
.1a3c09	2b		pld		                PLD
.1a3c0a	60		rts		            RTS
.1a3c0b					size_err
.1a3c0b	08		php		            PHP
.1a3c0c	c2 20		rep #$20	            REP #$20
.1a3c0e	48		pha		            PHA
.1a3c0f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3c12	5b		tcd		            TCD
.1a3c13	68		pla		            PLA
.1a3c14	28		plp		            PLP
.1a3c15	e2 20		sep #$20	            SEP #$20
.1a3c17	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a3c19	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3c1d	c2 20		rep #$20	            REP #$20
.1a3c1f	29 ff 00	and #$00ff	            AND #$00FF
.1a3c22	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a3c25	e2 20		sep #$20	            SEP #$20
.1a3c27	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3c2a					S_LOCATE
.1a3c2a	08		php		                PHP
.1a3c2b	c2 30		rep #$30	            REP #$30
.1a3c2d	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3c30	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a3c33	a5 23		lda $0823	                LDA ARGUMENT1
.1a3c35	48		pha		                PHA                         ; Save it for later
.1a3c36	a9 2c 00	lda #$002c	                LDA #','                    ; Check for the comma separator
.1a3c39	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3c3c	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3c3f	20 63 07	jsr $1a0763	            JSR ASS_ARG1_BYTE
.1a3c42	a4 23		ldy $0823	                LDY ARGUMENT1               ; Set Y to the row
.1a3c44	fa		plx		                PLX                         ; Set X to the column
.1a3c45	20 20 00	jsr $1a0020	            JSR CURSORXY
.1a3c48	28		plp		                PLP
.1a3c49	60		rts		            RTS

;******  Return to file: src\statements.s

.1a3c4a					S_INPUT
.1a3c4a	08		php		                PHP
.1a3c4b					varloop
.1a3c4b	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a3c4e	e2 20		sep #$20	            SEP #$20
.1a3c50	a7 00		lda [$0800]	                LDA [BIP]
.1a3c52	d0 03		bne $1a3c57	                BNE check_colon
.1a3c54	4c f2 3c	jmp $1a3cf2	                JMP done            ; If EOL, we're done
.1a3c57	c9 3a		cmp #$3a	check_colon     CMP #':'
.1a3c59	d0 03		bne $1a3c5e	                BNE check_string
.1a3c5b	4c f2 3c	jmp $1a3cf2	                JMP done            ; If colon, we're done
.1a3c5e	c9 22		cmp #$22	check_string    CMP #CHAR_DQUOTE    ; Is it the start of a string?
.1a3c60	d0 0b		bne $1a3c6d	                BNE check_var       ; No: then it should be a variable name
.1a3c62	20 18 1c	jsr $1a1c18	            JSR EVALSTRING
.1a3c65	20 00 46	jsr $1a4600	            JSR PR_STRING
.1a3c68	a9 3b		lda #$3b	                LDA #';'            ; Look for a semicolon
.1a3c6a	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3c6d					check_var
.1a3c6d	20 e2 04	jsr $1a04e2	            JSR ISALPHA
.1a3c70	90 44		bcc $1a3cb6	                BCC syntax_err      ; No: it's a syntax error
.1a3c72	20 20 54	jsr $1a5420	            JSR VAR_FINDNAME
.1a3c75	90 3f		bcc $1a3cb6	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3c77	a9 3f		lda #$3f	                LDA #"?"            ; Print a "? " to follow
.1a3c79	20 18 00	jsr $1a0018	            JSR PRINTC
.1a3c7c	a9 20		lda #$20	                LDA #CHAR_SP
.1a3c7e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a3c81	20 10 00	jsr $1a0010	            JSR INPUTLINE
.1a3c84	e2 20		sep #$20	            SEP #$20
.1a3c86	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Check the type of the variable
.1a3c88	c9 02		cmp #$02	                CMP #TYPE_STRING    ; If it's a string...
.1a3c8a	f0 49		beq $1a3cd5	                BEQ in_string       ; ... go to copy the string data
.1a3c8c	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; If it's an integer...
.1a3c8e	d0 03		bne $1a3c93	                BNE chk_float
.1a3c90	82 84 00	brl $1a3d17	                BRL in_integer      ; ... go to parse the integer
.1a3c93	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT     ; If it's a float...
.1a3c95	f0 5d		beq $1a3cf4	                BEQ in_float        ; ... go to parse the float
.1a3c97	08		php		            PHP
.1a3c98	c2 20		rep #$20	            REP #$20
.1a3c9a	48		pha		            PHA
.1a3c9b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3c9e	5b		tcd		            TCD
.1a3c9f	68		pla		            PLA
.1a3ca0	28		plp		            PLP
.1a3ca1	e2 20		sep #$20	            SEP #$20
.1a3ca3	a9 04		lda #$04	            LDA #ERR_TYPE
.1a3ca5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3ca9	c2 20		rep #$20	            REP #$20
.1a3cab	29 ff 00	and #$00ff	            AND #$00FF
.1a3cae	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a3cb1	e2 20		sep #$20	            SEP #$20
.1a3cb3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3cb6					syntax_err
.1a3cb6	08		php		            PHP
.1a3cb7	c2 20		rep #$20	            REP #$20
.1a3cb9	48		pha		            PHA
.1a3cba	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3cbd	5b		tcd		            TCD
.1a3cbe	68		pla		            PLA
.1a3cbf	28		plp		            PLP
.1a3cc0	e2 20		sep #$20	            SEP #$20
.1a3cc2	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3cc4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3cc8	c2 20		rep #$20	            REP #$20
.1a3cca	29 ff 00	and #$00ff	            AND #$00FF
.1a3ccd	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a3cd0	e2 20		sep #$20	            SEP #$20
.1a3cd2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3cd5					in_string
.1a3cd5	c2 20		rep #$20	            REP #$20
.1a3cd7	a9 00 4c	lda #$4c00	                LDA #<>IOBUF
.1a3cda	85 23		sta $0823	                STA ARGUMENT1
.1a3cdc	a9 00 00	lda #$0000	                LDA #`IOBUF
.1a3cdf	85 25		sta $0825	                STA ARGUMENT1+2
.1a3ce1	e2 20		sep #$20	            SEP #$20
.1a3ce3	a9 02		lda #$02	                LDA #TYPE_STRING
.1a3ce5	85 27		sta $0827	                STA ARGTYPE1
.1a3ce7					save_input
.1a3ce7	c2 20		rep #$20	            REP #$20
.1a3ce9	20 83 53	jsr $1a5383	            JSR VAR_SET
.1a3cec	a9 0d 00	lda #$000d	                LDA #CHAR_CR        ; Print a newline
.1a3cef	20 18 00	jsr $1a0018	            JSR PRINTC
.1a3cf2	28		plp		done            PLP
.1a3cf3	60		rts		            RTS
.1a3cf4					in_float
.1a3cf4	c2 20		rep #$20	            REP #$20
.1a3cf6	a5 00		lda $0800	                LDA BIP             ; Save the BIP for later use
.1a3cf8	85 40		sta $0840	                STA SAVEBIP
.1a3cfa	a5 02		lda $0802	                LDA BIP+2
.1a3cfc	85 42		sta $0842	                STA SAVEBIP+2
.1a3cfe	a9 00 4c	lda #$4c00	                LDA #<>IOBUF        ; Point to the line that was just input
.1a3d01	85 00		sta $0800	                STA BIP
.1a3d03	a9 00 00	lda #$0000	                LDA #`IOBUF
.1a3d06	85 02		sta $0802	                STA BIP+2
.1a3d08	20 42 5a	jsr $1a5a42	            JSR PARSENUM
.1a3d0b	c2 20		rep #$20	            REP #$20
.1a3d0d	a5 40		lda $0840	                LDA SAVEBIP         ; Restore the BIP
.1a3d0f	85 00		sta $0800	                STA BIP
.1a3d11	a5 42		lda $0842	                LDA SAVEBIP+2
.1a3d13	85 02		sta $0802	                STA BIP+2
.1a3d15	80 d0		bra $1a3ce7	                BRA save_input
.1a3d17					in_integer
.1a3d17	c2 20		rep #$20	            REP #$20
.1a3d19	a5 00		lda $0800	                LDA BIP             ; Save the BIP for later use
.1a3d1b	85 40		sta $0840	                STA SAVEBIP
.1a3d1d	a5 02		lda $0802	                LDA BIP+2
.1a3d1f	85 42		sta $0842	                STA SAVEBIP+2
.1a3d21	a9 00 4c	lda #$4c00	                LDA #<>IOBUF        ; Point to the line that was just input
.1a3d24	85 00		sta $0800	                STA BIP
.1a3d26	a9 00 00	lda #$0000	                LDA #`IOBUF
.1a3d29	85 02		sta $0802	                STA BIP+2
.1a3d2b	20 d8 08	jsr $1a08d8	            JSR PARSEINT
.1a3d2e	c2 20		rep #$20	            REP #$20
.1a3d30	a5 40		lda $0840	                LDA SAVEBIP         ; Restore the BIP
.1a3d32	85 00		sta $0800	                STA BIP
.1a3d34	a5 42		lda $0842	                LDA SAVEBIP+2
.1a3d36	85 02		sta $0802	                STA BIP+2
.1a3d38	80 ad		bra $1a3ce7	                BRA save_input
.1a3d3a					S_GET
.1a3d3a	08		php		                PHP
.1a3d3b					varloop
.1a3d3b	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a3d3e	e2 20		sep #$20	            SEP #$20
.1a3d40	a7 00		lda [$0800]	                LDA [BIP]
.1a3d42	f0 47		beq $1a3d8b	                BEQ done            ; If EOL, we're done
.1a3d44	c9 3a		cmp #$3a	                CMP #':'
.1a3d46	f0 43		beq $1a3d8b	                BEQ done            ; If colon, we're done
.1a3d48	20 e2 04	jsr $1a04e2	            JSR ISALPHA
.1a3d4b	90 40		bcc $1a3d8d	                BCC syntax_err      ; No: it's a syntax error
.1a3d4d	20 20 54	jsr $1a5420	            JSR VAR_FINDNAME
.1a3d50	90 3b		bcc $1a3d8d	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3d52	20 01 15	jsr $1a1501	            JSR TEMPSTRING
.1a3d55	20 14 00	jsr $1a0014	            JSR GETKEY
.1a3d58	e2 20		sep #$20	            SEP #$20
.1a3d5a	a0 00 00	ldy #$0000	                LDY #0
.1a3d5d	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a3d5f	a9 00		lda #$00	                LDA #0
.1a3d61	c8		iny		                INY
.1a3d62	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a3d64	c2 20		rep #$20	            REP #$20
.1a3d66	a5 16		lda $0816	                LDA STRPTR
.1a3d68	85 23		sta $0823	                STA ARGUMENT1
.1a3d6a	a5 18		lda $0818	                LDA STRPTR+2
.1a3d6c	85 25		sta $0825	                STA ARGUMENT1+2
.1a3d6e	e2 20		sep #$20	            SEP #$20
.1a3d70	a9 02		lda #$02	                LDA #TYPE_STRING
.1a3d72	85 27		sta $0827	                STA ARGTYPE1
.1a3d74	20 83 53	jsr $1a5383	            JSR VAR_SET
.1a3d77	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a3d7a	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.1a3d7c	f0 0d		beq $1a3d8b	                BEQ done            ; EOL? We're done
.1a3d7e	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.1a3d80	f0 09		beq $1a3d8b	                BEQ done
.1a3d82	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.1a3d84	d0 07		bne $1a3d8d	                BNE syntax_err      ; Nope: syntax error
.1a3d86	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a3d89	80 b0		bra $1a3d3b	                BRA varloop
.1a3d8b	28		plp		done            PLP
.1a3d8c	60		rts		            RTS
.1a3d8d					syntax_err
.1a3d8d	08		php		            PHP
.1a3d8e	c2 20		rep #$20	            REP #$20
.1a3d90	48		pha		            PHA
.1a3d91	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3d94	5b		tcd		            TCD
.1a3d95	68		pla		            PLA
.1a3d96	28		plp		            PLP
.1a3d97	e2 20		sep #$20	            SEP #$20
.1a3d99	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3d9b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3d9f	c2 20		rep #$20	            REP #$20
.1a3da1	29 ff 00	and #$00ff	            AND #$00FF
.1a3da4	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a3da7	e2 20		sep #$20	            SEP #$20
.1a3da9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3dac					S_CALL
.1a3dac	08		php		                PHP
.1a3dad	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3db0	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3db3	e2 20		sep #$20	            SEP #$20
.1a3db5	a9 5c		lda #$5c	                LDA #$5C            ; Set the opcode for JML
.1a3db7	85 a2		sta $08a2	                STA MJUMPINST
.1a3db9	c2 20		rep #$20	            REP #$20
.1a3dbb	a5 23		lda $0823	                LDA ARGUMENT1
.1a3dbd	85 a3		sta $08a3	                STA MJUMPADDR
.1a3dbf	e2 20		sep #$20	            SEP #$20
.1a3dc1	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3dc3	85 a5		sta $08a5	                STA MJUMPADDR+2
.1a3dc5	e2 20		sep #$20	            SEP #$20
.1a3dc7	a9 2c		lda #$2c	                LDA #','
.1a3dc9	85 37		sta $0837	                STA TARGETTOK
.1a3dcb	20 5f 22	jsr $1a225f	            JSR OPT_TOK
.1a3dce	90 41		bcc $1a3e11	                BCC launch          ; Not present... go ahead and launch
.1a3dd0	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a3dd3	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3dd6	20 0d 07	jsr $1a070d	            JSR ASS_ARG1_INT16
.1a3dd9	c2 20		rep #$20	            REP #$20
.1a3ddb	a5 23		lda $0823	                LDA ARGUMENT1
.1a3ddd	85 55		sta $0855	                STA MARG1           ; Save it to MARG1
.1a3ddf	e2 20		sep #$20	            SEP #$20
.1a3de1	a9 2c		lda #$2c	                LDA #','
.1a3de3	85 37		sta $0837	                STA TARGETTOK
.1a3de5	20 5f 22	jsr $1a225f	            JSR OPT_TOK
.1a3de8	90 27		bcc $1a3e11	                BCC launch          ; Not present... go ahead and launch
.1a3dea	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a3ded	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3df0	20 0d 07	jsr $1a070d	            JSR ASS_ARG1_INT16
.1a3df3	c2 20		rep #$20	            REP #$20
.1a3df5	a5 23		lda $0823	                LDA ARGUMENT1
.1a3df7	85 59		sta $0859	                STA MARG2           ; Save it to MARG2
.1a3df9	e2 20		sep #$20	            SEP #$20
.1a3dfb	a9 2c		lda #$2c	                LDA #','
.1a3dfd	85 37		sta $0837	                STA TARGETTOK
.1a3dff	20 5f 22	jsr $1a225f	            JSR OPT_TOK
.1a3e02	90 0d		bcc $1a3e11	                BCC launch          ; Not present... go ahead and launch
.1a3e04	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a3e07	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3e0a	20 0d 07	jsr $1a070d	            JSR ASS_ARG1_INT16
.1a3e0d	c2 20		rep #$20	            REP #$20
.1a3e0f	a4 23		ldy $0823	                LDY ARGUMENT1
.1a3e11	a6 59		ldx $0859	launch          LDX MARG2
.1a3e13	a5 55		lda $0855	                LDA MARG1
.1a3e15	0b		phd		                PHD
.1a3e16	8b		phb		                PHB
.1a3e17	08		php		                PHP
.1a3e18	22 a2 08 00	jsl $0008a2	                JSL MJUMPINST       ; Call the subroutine indicated
.1a3e1c	28		plp		                PLP
.1a3e1d	ab		plb		                PLB
.1a3e1e	2b		pld		                PLD
.1a3e1f	20 62 21	jsr $1a2162	            JSR SKIPSTMT
.1a3e22	28		plp		                PLP
.1a3e23	60		rts		            RTS
.1a3e24					type_err
.1a3e24	08		php		            PHP
.1a3e25	c2 20		rep #$20	            REP #$20
.1a3e27	48		pha		            PHA
.1a3e28	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3e2b	5b		tcd		            TCD
.1a3e2c	68		pla		            PLA
.1a3e2d	28		plp		            PLP
.1a3e2e	e2 20		sep #$20	            SEP #$20
.1a3e30	a9 04		lda #$04	            LDA #ERR_TYPE
.1a3e32	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3e36	c2 20		rep #$20	            REP #$20
.1a3e38	29 ff 00	and #$00ff	            AND #$00FF
.1a3e3b	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a3e3e	e2 20		sep #$20	            SEP #$20
.1a3e40	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3e43					S_DIM
.1a3e43	08		php		                PHP
.1a3e44	e2 20		sep #$20	            SEP #$20
.1a3e46	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a3e49	20 20 54	jsr $1a5420	            JSR VAR_FINDNAME
.1a3e4c	90 64		bcc $1a3eb2	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3e4e	a9 8f		lda #$8f	                LDA #TOK_LPAREN     ; Verify we have a left parenthesis
.1a3e50	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a3e53	a9 01		lda #$01	                LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.1a3e55	20 28 1a	jsr $1a1a28	            JSR PHOPERATOR
.1a3e58	a2 01 00	ldx #$0001	                LDX #1
.1a3e5b	a9 00		lda #$00	                LDA #0
.1a3e5d	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF     ; Set the dimension count to 0
.1a3e61					dim_loop
.1a3e61	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a3e64	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a3e67	c2 20		rep #$20	            REP #$20
.1a3e69	a5 23		lda $0823	                LDA ARGUMENT1
.1a3e6b	9f 00 4d 00	sta $004d00,x	                STA @lARRIDXBUF,X   ; And store it in the buffer
.1a3e6f	e2 20		sep #$20	            SEP #$20
.1a3e71	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF     ; Add to the dimension count
.1a3e75	1a		inc a		                INC A
.1a3e76	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF
.1a3e7a	30 55		bmi $1a3ed1	                BMI overflow        ; If > 127 throw an error
.1a3e7c	e8		inx		                INX
.1a3e7d	e8		inx		                INX
.1a3e7e	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a3e81	a7 00		lda [$0800]	                LDA [BIP]           ; Check the character
.1a3e83	c9 2c		cmp #$2c	                CMP #','            ; Is it a comma?
.1a3e85	f0 25		beq $1a3eac	                BEQ skip_comma      ; Yes: get the next dimension
.1a3e87	c9 90		cmp #$90	                CMP #TOK_RPAREN     ; No: is it a ")"?
.1a3e89	d0 27		bne $1a3eb2	                BNE syntax_err      ; No: throw a syntax error
.1a3e8b	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a3e8e	20 9e 66	jsr $1a669e	            JSR ARR_ALLOC
.1a3e91	c2 20		rep #$20	            REP #$20
.1a3e93	a5 c0		lda $08c0	                LDA CURRBLOCK       ; Set up the pointer to the array
.1a3e95	85 23		sta $0823	                STA ARGUMENT1
.1a3e97	e2 20		sep #$20	            SEP #$20
.1a3e99	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a3e9b	85 25		sta $0825	                STA ARGUMENT1+2
.1a3e9d	64 26		stz $0826	                STZ ARGUMENT1+3
.1a3e9f	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Get the type of the values
.1a3ea1	09 80		ora #$80	                ORA #$80            ; Make sure we change the type to array
.1a3ea3	85 ea		sta $08ea	                STA TOFINDTYPE      ; And save it back for searching
.1a3ea5	85 27		sta $0827	                STA ARGTYPE1        ; And for the value to set
.1a3ea7	20 83 53	jsr $1a5383	            JSR VAR_SET
.1a3eaa	28		plp		                PLP
.1a3eab	60		rts		            RTS
.1a3eac					skip_comma
.1a3eac	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a3eaf	4c 61 3e	jmp $1a3e61	                JMP dim_loop
.1a3eb2					syntax_err
.1a3eb2	08		php		            PHP
.1a3eb3	c2 20		rep #$20	            REP #$20
.1a3eb5	48		pha		            PHA
.1a3eb6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3eb9	5b		tcd		            TCD
.1a3eba	68		pla		            PLA
.1a3ebb	28		plp		            PLP
.1a3ebc	e2 20		sep #$20	            SEP #$20
.1a3ebe	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3ec0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3ec4	c2 20		rep #$20	            REP #$20
.1a3ec6	29 ff 00	and #$00ff	            AND #$00FF
.1a3ec9	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a3ecc	e2 20		sep #$20	            SEP #$20
.1a3ece	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3ed1					overflow
.1a3ed1	08		php		            PHP
.1a3ed2	c2 20		rep #$20	            REP #$20
.1a3ed4	48		pha		            PHA
.1a3ed5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3ed8	5b		tcd		            TCD
.1a3ed9	68		pla		            PLA
.1a3eda	28		plp		            PLP
.1a3edb	e2 20		sep #$20	            SEP #$20
.1a3edd	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a3edf	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3ee3	c2 20		rep #$20	            REP #$20
.1a3ee5	29 ff 00	and #$00ff	            AND #$00FF
.1a3ee8	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a3eeb	e2 20		sep #$20	            SEP #$20
.1a3eed	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3ef0					S_READ
.1a3ef0	08		php		                PHP
.1a3ef1					varloop
.1a3ef1	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a3ef4	e2 20		sep #$20	            SEP #$20
.1a3ef6	a7 00		lda [$0800]	                LDA [BIP]
.1a3ef8	f0 28		beq $1a3f22	                BEQ done            ; If EOL, we're done
.1a3efa	c9 3a		cmp #$3a	                CMP #':'
.1a3efc	f0 24		beq $1a3f22	                BEQ done            ; If colon, we're done
.1a3efe	20 e2 04	jsr $1a04e2	            JSR ISALPHA
.1a3f01	90 21		bcc $1a3f24	                BCC syntax_err      ; No: it's a syntax error
.1a3f03	20 20 54	jsr $1a5420	            JSR VAR_FINDNAME
.1a3f06	90 1c		bcc $1a3f24	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3f08	20 43 3f	jsr $1a3f43	            JSR NEXTDATA
.1a3f0b	20 83 53	jsr $1a5383	            JSR VAR_SET
.1a3f0e	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a3f11	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.1a3f13	f0 0d		beq $1a3f22	                BEQ done            ; EOL? We're done
.1a3f15	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.1a3f17	f0 09		beq $1a3f22	                BEQ done
.1a3f19	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.1a3f1b	d0 07		bne $1a3f24	                BNE syntax_err      ; Nope: syntax error
.1a3f1d	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a3f20	80 cf		bra $1a3ef1	                BRA varloop
.1a3f22	28		plp		done            PLP
.1a3f23	60		rts		            RTS
.1a3f24					syntax_err
.1a3f24	08		php		            PHP
.1a3f25	c2 20		rep #$20	            REP #$20
.1a3f27	48		pha		            PHA
.1a3f28	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3f2b	5b		tcd		            TCD
.1a3f2c	68		pla		            PLA
.1a3f2d	28		plp		            PLP
.1a3f2e	e2 20		sep #$20	            SEP #$20
.1a3f30	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3f32	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3f36	c2 20		rep #$20	            REP #$20
.1a3f38	29 ff 00	and #$00ff	            AND #$00FF
.1a3f3b	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a3f3e	e2 20		sep #$20	            SEP #$20
.1a3f40	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3f43					NEXTDATA
.1a3f43	08		php		                PHP
.1a3f44	a5 02		lda $0802	                LDA BIP+2           ; Save BIP
.1a3f46	85 42		sta $0842	                STA SAVEBIP+2
.1a3f48	a5 00		lda $0800	                LDA BIP
.1a3f4a	85 40		sta $0840	                STA SAVEBIP
.1a3f4c	a5 1c		lda $081c	                LDA CURLINE+2       ; Save CURLINE
.1a3f4e	85 46		sta $0846	                STA SAVELINE+2
.1a3f50	a5 1a		lda $081a	                LDA CURLINE
.1a3f52	85 44		sta $0844	                STA SAVELINE
.1a3f54	c2 20		rep #$20	            REP #$20
.1a3f56	a5 3a		lda $083a	                LDA DATABIP+2
.1a3f58	d0 04		bne $1a3f5e	                BNE data_set
.1a3f5a	a5 38		lda $0838	                LDA DATABIP
.1a3f5c	f0 4e		beq $1a3fac	                BEQ scan_start      ; No: scan for a DATA statement
.1a3f5e	a5 38		lda $0838	data_set        LDA DATABIP         ; Move BIP to the DATA statement
.1a3f60	85 00		sta $0800	                STA BIP
.1a3f62	a5 3a		lda $083a	                LDA DATABIP+2
.1a3f64	85 02		sta $0802	                STA BIP+2
.1a3f66	a5 3c		lda $083c	                LDA DATALINE        ; Set CURLINE from DATALINE
.1a3f68	85 1a		sta $081a	                STA CURLINE
.1a3f6a	a5 3e		lda $083e	                LDA DATALINE+2
.1a3f6c	85 1c		sta $081c	                STA CURLINE+2
.1a3f6e	e2 20		sep #$20	            SEP #$20
.1a3f70	a7 00		lda [$0800]	                LDA [BIP]           ; Check character at BIP
.1a3f72	f0 53		beq $1a3fc7	                BEQ scan_DATA       ; EOL? scan for a DATA statement
.1a3f74	c9 3a		cmp #$3a	                CMP #':'            ; Colon?
.1a3f76	f0 4f		beq $1a3fc7	                BEQ scan_DATA       ; ... scan for a DATA statement
.1a3f78	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.1a3f7a	d0 03		bne $1a3f7f	                BNE skip_parse      ; No: skip leading WS and try to parse
.1a3f7c	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a3f7f					skip_parse
.1a3f7f	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a3f82	a7 00		lda [$0800]	                LDA [BIP]
.1a3f84	c9 22		cmp #$22	                CMP #CHAR_DQUOTE    ; Is it a quote?
.1a3f86	f0 4e		beq $1a3fd6	                BEQ read_string     ; Yes: process the string
.1a3f88	20 fb 04	jsr $1a04fb	            JSR ISNUMERAL
.1a3f8b	b0 4e		bcs $1a3fdb	                BCS read_number     ; Yes: process the number
.1a3f8d					syntax_err
.1a3f8d	08		php		            PHP
.1a3f8e	c2 20		rep #$20	            REP #$20
.1a3f90	48		pha		            PHA
.1a3f91	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3f94	5b		tcd		            TCD
.1a3f95	68		pla		            PLA
.1a3f96	28		plp		            PLP
.1a3f97	e2 20		sep #$20	            SEP #$20
.1a3f99	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3f9b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3f9f	c2 20		rep #$20	            REP #$20
.1a3fa1	29 ff 00	and #$00ff	            AND #$00FF
.1a3fa4	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a3fa7	e2 20		sep #$20	            SEP #$20
.1a3fa9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3fac					scan_start
.1a3fac	c2 20		rep #$20	            REP #$20
.1a3fae	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT    ; Point CURLINE to the first line
.1a3fb1	85 1a		sta $081a	                STA CURLINE
.1a3fb3	a9 16 00	lda #$0016	                LDA #`BASIC_BOT
.1a3fb6	85 1c		sta $081c	                STA CURLINE+2
.1a3fb8	18		clc		                CLC
.1a3fb9	a5 1a		lda $081a	                LDA CURLINE         ; Point BIP to the first possible token
.1a3fbb	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.1a3fbe	85 00		sta $0800	                STA BIP
.1a3fc0	a5 1c		lda $081c	                LDA CURLINE+2
.1a3fc2	69 00 00	adc #$0000	                ADC #0
.1a3fc5	85 02		sta $0802	                STA BIP+2
.1a3fc7					scan_data
.1a3fc7	e2 20		sep #$20	            SEP #$20
.1a3fc9	a9 80		lda #$80	                LDA #$80            ; We don't want to process nesting
.1a3fcb	85 35		sta $0835	                STA SKIPNEST
.1a3fcd	a9 ab		lda #$ab	                LDA #TOK_DATA       ; We're looking for a DATA token
.1a3fcf	85 37		sta $0837	                STA TARGETTOK
.1a3fd1	20 74 21	jsr $1a2174	            JSR SKIPTOTOK
.1a3fd4	80 a9		bra $1a3f7f	                BRA skip_parse
.1a3fd6					read_string
.1a3fd6	20 18 1c	jsr $1a1c18	            JSR EVALSTRING
.1a3fd9	80 03		bra $1a3fde	                BRA done
.1a3fdb					read_number
.1a3fdb	20 0a 1b	jsr $1a1b0a	            JSR EVALNUMBER
.1a3fde					done
.1a3fde	c2 20		rep #$20	            REP #$20
.1a3fe0	a5 00		lda $0800	                LDA BIP             ; Save BIP to DATABIP
.1a3fe2	85 38		sta $0838	                STA DATABIP
.1a3fe4	a5 02		lda $0802	                LDA BIP+2
.1a3fe6	85 3a		sta $083a	                STA DATABIP+2
.1a3fe8	a5 1a		lda $081a	                LDA CURLINE         ; Save CURLINE to DATALINE
.1a3fea	85 3c		sta $083c	                STA DATALINE
.1a3fec	a5 1c		lda $081c	                LDA CURLINE+2
.1a3fee	85 3e		sta $083e	                STA DATALINE+2
.1a3ff0	a5 44		lda $0844	                LDA SAVELINE        ; Restore CURLINE
.1a3ff2	85 1a		sta $081a	                STA CURLINE
.1a3ff4	a5 46		lda $0846	                LDA SAVELINE+2
.1a3ff6	85 1c		sta $081c	                STA CURLINE+2
.1a3ff8	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.1a3ffa	85 00		sta $0800	                STA BIP
.1a3ffc	a5 42		lda $0842	                LDA SAVEBIP+2
.1a3ffe	85 02		sta $0802	                STA BIP+2
.1a4000	28		plp		                PLP
.1a4001	60		rts		            RTS
.1a4002					S_DATA
.1a4002	20 62 21	jsr $1a2162	            JSR SKIPSTMT
.1a4005	60		rts		            RTS
.1a4006					S_RESTORE
.1a4006	64 38		stz $0838	                STZ DATABIP         ; Just set DATABIP to 0
.1a4008	64 3a		stz $083a	                STZ DATABIP+2       ; The next READ will move it to the first DATA
.1a400a	64 3c		stz $083c	                STZ DATALINE        ; Set DATALINE to 0
.1a400c	64 3e		stz $083e	                STZ DATALINE+2
.1a400e	60		rts		            RTS
.1a400f					S_CLS
.1a400f	20 24 00	jsr $1a0024	            JSR CLSCREEN
.1a4012	60		rts		            RTS
.1a4013					S_POKEL
.1a4013	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4016	c2 20		rep #$20	            REP #$20
.1a4018	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.1a401a	48		pha		                PHA
.1a401b	a5 23		lda $0823	                LDA ARGUMENT1
.1a401d	48		pha		                PHA
.1a401e	e2 20		sep #$20	            SEP #$20
.1a4020	a7 00		lda [$0800]	                LDA [BIP]
.1a4022	c9 2c		cmp #$2c	                CMP #','
.1a4024	d0 22		bne $1a4048	                BNE syntax_err
.1a4026	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4029	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a402c	c2 20		rep #$20	            REP #$20
.1a402e	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a4030	d0 35		bne $1a4067	                BNE range_err
.1a4032	68		pla		                PLA                 ; Pull the target address from the stack
.1a4033	85 08		sta $0808	                STA INDEX           ; and into INDEX
.1a4035	68		pla		                PLA
.1a4036	85 0a		sta $080a	                STA INDEX+2
.1a4038	c2 20		rep #$20	            REP #$20
.1a403a	a5 23		lda $0823	                LDA ARGUMENT1
.1a403c	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.1a403e	e2 20		sep #$20	            SEP #$20
.1a4040	a0 02 00	ldy #$0002	                LDY #2
.1a4043	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4045	97 08		sta [$0808],y	                STA [INDEX],Y
.1a4047	60		rts		            RTS
.1a4048					syntax_err
.1a4048	08		php		            PHP
.1a4049	c2 20		rep #$20	            REP #$20
.1a404b	48		pha		            PHA
.1a404c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a404f	5b		tcd		            TCD
.1a4050	68		pla		            PLA
.1a4051	28		plp		            PLP
.1a4052	e2 20		sep #$20	            SEP #$20
.1a4054	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4056	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a405a	c2 20		rep #$20	            REP #$20
.1a405c	29 ff 00	and #$00ff	            AND #$00FF
.1a405f	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4062	e2 20		sep #$20	            SEP #$20
.1a4064	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4067					range_err
.1a4067	08		php		            PHP
.1a4068	c2 20		rep #$20	            REP #$20
.1a406a	48		pha		            PHA
.1a406b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a406e	5b		tcd		            TCD
.1a406f	68		pla		            PLA
.1a4070	28		plp		            PLP
.1a4071	e2 20		sep #$20	            SEP #$20
.1a4073	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4075	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4079	c2 20		rep #$20	            REP #$20
.1a407b	29 ff 00	and #$00ff	            AND #$00FF
.1a407e	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4081	e2 20		sep #$20	            SEP #$20
.1a4083	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4086					S_POKEW
.1a4086	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4089	c2 20		rep #$20	            REP #$20
.1a408b	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.1a408d	48		pha		                PHA
.1a408e	a5 23		lda $0823	                LDA ARGUMENT1
.1a4090	48		pha		                PHA
.1a4091	e2 20		sep #$20	            SEP #$20
.1a4093	a7 00		lda [$0800]	                LDA [BIP]
.1a4095	c9 2c		cmp #$2c	                CMP #','
.1a4097	d0 19		bne $1a40b2	                BNE syntax_err
.1a4099	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a409c	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a409f	c2 20		rep #$20	            REP #$20
.1a40a1	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a40a3	d0 2c		bne $1a40d1	                BNE range_err
.1a40a5	68		pla		                PLA                 ; Pull the target address from the stack
.1a40a6	85 08		sta $0808	                STA INDEX           ; and into INDEX
.1a40a8	68		pla		                PLA
.1a40a9	85 0a		sta $080a	                STA INDEX+2
.1a40ab	c2 20		rep #$20	            REP #$20
.1a40ad	a5 23		lda $0823	                LDA ARGUMENT1
.1a40af	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.1a40b1	60		rts		            RTS
.1a40b2					syntax_err
.1a40b2	08		php		            PHP
.1a40b3	c2 20		rep #$20	            REP #$20
.1a40b5	48		pha		            PHA
.1a40b6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a40b9	5b		tcd		            TCD
.1a40ba	68		pla		            PLA
.1a40bb	28		plp		            PLP
.1a40bc	e2 20		sep #$20	            SEP #$20
.1a40be	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a40c0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a40c4	c2 20		rep #$20	            REP #$20
.1a40c6	29 ff 00	and #$00ff	            AND #$00FF
.1a40c9	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a40cc	e2 20		sep #$20	            SEP #$20
.1a40ce	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a40d1					range_err
.1a40d1	08		php		            PHP
.1a40d2	c2 20		rep #$20	            REP #$20
.1a40d4	48		pha		            PHA
.1a40d5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a40d8	5b		tcd		            TCD
.1a40d9	68		pla		            PLA
.1a40da	28		plp		            PLP
.1a40db	e2 20		sep #$20	            SEP #$20
.1a40dd	a9 09		lda #$09	            LDA #ERR_RANGE
.1a40df	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a40e3	c2 20		rep #$20	            REP #$20
.1a40e5	29 ff 00	and #$00ff	            AND #$00FF
.1a40e8	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a40eb	e2 20		sep #$20	            SEP #$20
.1a40ed	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a40f0					S_POKE
.1a40f0	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a40f3	c2 20		rep #$20	            REP #$20
.1a40f5	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.1a40f7	48		pha		                PHA
.1a40f8	a5 23		lda $0823	                LDA ARGUMENT1
.1a40fa	48		pha		                PHA
.1a40fb	e2 20		sep #$20	            SEP #$20
.1a40fd	a7 00		lda [$0800]	                LDA [BIP]
.1a40ff	c9 2c		cmp #$2c	                CMP #','
.1a4101	d0 1f		bne $1a4122	                BNE syntax_err
.1a4103	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4106	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4109	e2 20		sep #$20	            SEP #$20
.1a410b	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Make sure the value is from 0 - 255
.1a410d	d0 32		bne $1a4141	                BNE range_err
.1a410f	c2 20		rep #$20	            REP #$20
.1a4111	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4113	d0 2c		bne $1a4141	                BNE range_err
.1a4115	68		pla		                PLA                 ; Pull the target address from the stack
.1a4116	85 08		sta $0808	                STA INDEX           ; and into INDEX
.1a4118	68		pla		                PLA
.1a4119	85 0a		sta $080a	                STA INDEX+2
.1a411b	e2 20		sep #$20	            SEP #$20
.1a411d	a5 23		lda $0823	                LDA ARGUMENT1
.1a411f	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.1a4121	60		rts		            RTS
.1a4122					syntax_err
.1a4122	08		php		            PHP
.1a4123	c2 20		rep #$20	            REP #$20
.1a4125	48		pha		            PHA
.1a4126	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4129	5b		tcd		            TCD
.1a412a	68		pla		            PLA
.1a412b	28		plp		            PLP
.1a412c	e2 20		sep #$20	            SEP #$20
.1a412e	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4130	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4134	c2 20		rep #$20	            REP #$20
.1a4136	29 ff 00	and #$00ff	            AND #$00FF
.1a4139	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a413c	e2 20		sep #$20	            SEP #$20
.1a413e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4141					range_err
.1a4141	08		php		            PHP
.1a4142	c2 20		rep #$20	            REP #$20
.1a4144	48		pha		            PHA
.1a4145	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4148	5b		tcd		            TCD
.1a4149	68		pla		            PLA
.1a414a	28		plp		            PLP
.1a414b	e2 20		sep #$20	            SEP #$20
.1a414d	a9 09		lda #$09	            LDA #ERR_RANGE
.1a414f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4153	c2 20		rep #$20	            REP #$20
.1a4155	29 ff 00	and #$00ff	            AND #$00FF
.1a4158	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a415b	e2 20		sep #$20	            SEP #$20
.1a415d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4160					S_STOP
.1a4160	08		php		            PHP
.1a4161	c2 20		rep #$20	            REP #$20
.1a4163	48		pha		            PHA
.1a4164	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4167	5b		tcd		            TCD
.1a4168	68		pla		            PLA
.1a4169	28		plp		            PLP
.1a416a	e2 20		sep #$20	            SEP #$20
.1a416c	a9 01		lda #$01	            LDA #ERR_BREAK
.1a416e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4172	c2 20		rep #$20	            REP #$20
.1a4174	29 ff 00	and #$00ff	            AND #$00FF
.1a4177	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a417a	e2 20		sep #$20	            SEP #$20
.1a417c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a417f					S_REM
.1a417f	08		php		                PHP
.1a4180	e2 20		sep #$20	            SEP #$20
.1a4182	a7 00		lda [$0800]	rem_loop        LDA [BIP]
.1a4184	f0 05		beq $1a418b	                BEQ done
.1a4186	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4189	80 f7		bra $1a4182	                BRA rem_loop
.1a418b	28		plp		done            PLP
.1a418c	60		rts		            RTS
.1a418d					S_EXIT
.1a418d	08		php		                PHP
.1a418e	28		plp		                PLP
.1a418f	60		rts		            RTS
.1a4190					S_DO
.1a4190	08		php		                PHP
.1a4191	28		plp		                PLP
.1a4192	60		rts		            RTS
.0000					DO_RECORD
>0000					BIP             .dword  ?
>0004					CURLINE         .dword  ?
.1a4193					S_LOOP
.1a4193	08		php		                PHP
.1a4194	28		plp		                PLP
.1a4195	60		rts		            RTS
.1a4196					S_FOR
.1a4196	08		php		                PHP
.1a4197	c2 20		rep #$20	            REP #$20
.1a4199	a5 1c		lda $081c	                LDA CURLINE+2
.1a419b	20 25 1e	jsr $1a1e25	            JSR PHRETURN
.1a419e	a5 1a		lda $081a	                LDA CURLINE
.1a41a0	20 25 1e	jsr $1a1e25	            JSR PHRETURN
.1a41a3	a5 02		lda $0802	                LDA BIP+2           ; Save current BIP
.1a41a5	48		pha		                PHA
.1a41a6	a5 00		lda $0800	                LDA BIP
.1a41a8	48		pha		                PHA
.1a41a9	20 62 21	jsr $1a2162	            JSR SKIPSTMT
.1a41ac	a5 02		lda $0802	                LDA BIP+2           ; Save the BIP for the next statement to the RETURN stack
.1a41ae	20 25 1e	jsr $1a1e25	            JSR PHRETURN
.1a41b1	a5 00		lda $0800	                LDA BIP
.1a41b3	20 25 1e	jsr $1a1e25	            JSR PHRETURN
.1a41b6	68		pla		                PLA                 ; Restore the original BIP
.1a41b7	85 00		sta $0800	                STA BIP
.1a41b9	68		pla		                PLA
.1a41ba	85 02		sta $0802	                STA BIP+2
.1a41bc	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a41bf					get_name
.1a41bf	20 20 54	jsr $1a5420	            JSR VAR_FINDNAME
.1a41c2	b0 1f		bcs $1a41e3	                BCS push_name       ; If we didn't find a name, thrown an error
.1a41c4	08		php		            PHP
.1a41c5	c2 20		rep #$20	            REP #$20
.1a41c7	48		pha		            PHA
.1a41c8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a41cb	5b		tcd		            TCD
.1a41cc	68		pla		            PLA
.1a41cd	28		plp		            PLP
.1a41ce	e2 20		sep #$20	            SEP #$20
.1a41d0	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a41d2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a41d6	c2 20		rep #$20	            REP #$20
.1a41d8	29 ff 00	and #$00ff	            AND #$00FF
.1a41db	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a41de	e2 20		sep #$20	            SEP #$20
.1a41e0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a41e3					push_name
.1a41e3	e2 20		sep #$20	            SEP #$20
.1a41e5	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; To the return stack
.1a41e7	20 3c 1e	jsr $1a1e3c	            JSR PHRETURNB
.1a41ea	a5 e9		lda $08e9	                LDA TOFIND+2
.1a41ec	20 3c 1e	jsr $1a1e3c	            JSR PHRETURNB
.1a41ef	c2 20		rep #$20	            REP #$20
.1a41f1	a5 e7		lda $08e7	                LDA TOFIND
.1a41f3	20 25 1e	jsr $1a1e25	            JSR PHRETURN
.1a41f6					else
.1a41f6	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a41f9	e2 20		sep #$20	            SEP #$20
.1a41fb	a7 00		lda [$0800]	                LDA [BIP]
.1a41fd	c9 8a		cmp #$8a	                CMP #TOK_EQ
.1a41ff	d0 6a		bne $1a426b	                BNE syntax_err      ; If not found: signal an syntax error
.1a4201	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Verify type of variable
.1a4203	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; Is it integer?
.1a4205	f0 04		beq $1a420b	                BEQ process_initial ; Yes: it's ok
.1a4207	c9 01		cmp #$01	                CMP #TYPE_FLOAT     ; Is it floating point?
.1a4209	f0 00		beq $1a420b	                BEQ process_initial ; Yes: it's ok
.1a420b					process_initial
.1a420b	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a420e	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4211	20 83 53	jsr $1a5383	            JSR VAR_SET
.1a4214	e2 20		sep #$20	            SEP #$20
.1a4216	a9 9c		lda #$9c	                LDA #TOK_TO         ; Expect the next token to be TO
.1a4218	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a421b	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a421e	c2 20		rep #$20	            REP #$20
.1a4220	a5 27		lda $0827	                LDA ARGTYPE1
.1a4222	20 25 1e	jsr $1a1e25	            JSR PHRETURN
.1a4225	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4227	20 25 1e	jsr $1a1e25	            JSR PHRETURN
.1a422a	a5 23		lda $0823	                LDA ARGUMENT1
.1a422c	20 25 1e	jsr $1a1e25	            JSR PHRETURN
.1a422f	e2 20		sep #$20	            SEP #$20
.1a4231	a9 9d		lda #$9d	                LDA #TOK_STEP
.1a4233	85 37		sta $0837	                STA TARGETTOK
.1a4235	20 5f 22	jsr $1a225f	            JSR OPT_TOK
.1a4238	90 1b		bcc $1a4255	                BCC default_inc     ; Not found: set a default increment of 1
.1a423a	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a423d	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4240	e2 20		sep #$20	            SEP #$20
.1a4242	a5 27		lda $0827	                LDA ARGTYPE1        ; Push the result as the increment
.1a4244	20 25 1e	jsr $1a1e25	            JSR PHRETURN
.1a4247	c2 20		rep #$20	            REP #$20
.1a4249	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a424b	20 25 1e	jsr $1a1e25	            JSR PHRETURN
.1a424e	a5 23		lda $0823	                LDA ARGUMENT1
.1a4250	20 25 1e	jsr $1a1e25	            JSR PHRETURN
.1a4253	80 14		bra $1a4269	                BRA done
.1a4255					default_inc
.1a4255	c2 20		rep #$20	            REP #$20
.1a4257	a9 00 00	lda #$0000	                LDA #TYPE_INTEGER
.1a425a	20 25 1e	jsr $1a1e25	            JSR PHRETURN
.1a425d	a9 00 00	lda #$0000	                LDA #0
.1a4260	20 25 1e	jsr $1a1e25	            JSR PHRETURN
.1a4263	a9 01 00	lda #$0001	                LDA #1
.1a4266	20 25 1e	jsr $1a1e25	            JSR PHRETURN
.1a4269	28		plp		done            PLP
.1a426a	60		rts		            RTS
.1a426b					syntax_err
.1a426b	08		php		            PHP
.1a426c	c2 20		rep #$20	            REP #$20
.1a426e	48		pha		            PHA
.1a426f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4272	5b		tcd		            TCD
.1a4273	68		pla		            PLA
.1a4274	28		plp		            PLP
.1a4275	e2 20		sep #$20	            SEP #$20
.1a4277	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4279	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a427d	c2 20		rep #$20	            REP #$20
.1a427f	29 ff 00	and #$00ff	            AND #$00FF
.1a4282	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4285	e2 20		sep #$20	            SEP #$20
.1a4287	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.0000					FOR_RECORD
>0000					INCREMENT       .dword  ?
>0004					INCTYPE         .word   ?
>0006					FINAL           .dword  ?
>000a					FINALTYPE       .word   ?
>000c					VARIBLE         .dword  ?
>0010					VARTYPE         .word   ?
>0012					BIP             .dword  ?
>0016					CURLINE         .dword  ?
.1a428a					S_NEXT
.1a428a	08		php		                PHP
.1a428b	8b		phb		                PHB
.1a428c	08		php		            PHP
.1a428d	e2 20		sep #$20	            SEP #$20
.1a428f	48		pha		            PHA
.1a4290	a9 00		lda #$00	            LDA #0
.1a4292	48		pha		            PHA
.1a4293	ab		plb		            PLB
.1a4294	68		pla		            PLA
.1a4295	28		plp		            PLP
.1a4296	08		php		            PHP
.1a4297	c2 20		rep #$20	            REP #$20
.1a4299	48		pha		            PHA
.1a429a	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a429d	5b		tcd		            TCD
.1a429e	68		pla		            PLA
.1a429f	28		plp		            PLP
.1a42a0	c2 30		rep #$30	            REP #$30
.1a42a2	a4 33		ldy $0833	                LDY RETURNSP                    ; Y := pointer to first byte of the FOR record
.1a42a4	c8		iny		                INY                             ; RETURNSP points to the first free slot, so move up 2 bytes
.1a42a5	c8		iny		                INY
.1a42a6	c2 20		rep #$20	            REP #$20
.1a42a8	b9 0c 00	lda $000c,y	                LDA #FOR_RECORD.VARIBLE,B,Y     ; TOFIND := FOR_RECORD.VARIABLE
.1a42ab	85 e7		sta $08e7	                STA TOFIND
.1a42ad	b9 0e 00	lda $000e,y	                LDA #FOR_RECORD.VARIBLE+2,B,Y
.1a42b0	e2 20		sep #$20	            SEP #$20
.1a42b2	85 e9		sta $08e9	                STA TOFIND+2
.1a42b4	b9 10 00	lda $0010,y	                LDA #FOR_RECORD.VARTYPE,B,Y
.1a42b7	85 ea		sta $08ea	                STA TOFINDTYPE
.1a42b9	c2 20		rep #$20	            REP #$20
.1a42bb	5a		phy		                PHY
.1a42bc	20 21 52	jsr $1a5221	            JSR VAR_REF
.1a42bf	7a		ply		                PLY
.1a42c0	c2 20		rep #$20	            REP #$20
.1a42c2	b9 00 00	lda $0000,y	                LDA #FOR_RECORD.INCREMENT,B,Y   ; ARGUMENT2 := FOR_RECORD.INCREMENT
.1a42c5	85 29		sta $0829	                STA ARGUMENT2
.1a42c7	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y
.1a42ca	85 2b		sta $082b	                STA ARGUMENT2+2
.1a42cc	e2 20		sep #$20	            SEP #$20
.1a42ce	b9 04 00	lda $0004,y	                LDA #FOR_RECORD.INCTYPE,B,Y
.1a42d1	85 2d		sta $082d	                STA ARGTYPE2
.1a42d3	c2 20		rep #$20	            REP #$20
.1a42d5	5a		phy		                PHY
.1a42d6	20 e3 27	jsr $1a27e3	            JSR OP_PLUS
.1a42d9	20 83 53	jsr $1a5383	            JSR VAR_SET
.1a42dc	7a		ply		                PLY
.1a42dd	c2 20		rep #$20	            REP #$20
.1a42df	b9 06 00	lda $0006,y	                LDA #FOR_RECORD.FINAL,B,Y       ; ARGUMENT2 := FOR_RECORD.FINAL
.1a42e2	85 29		sta $0829	                STA ARGUMENT2
.1a42e4	b9 08 00	lda $0008,y	                LDA #FOR_RECORD.FINAL+2,B,Y
.1a42e7	85 2b		sta $082b	                STA ARGUMENT2+2
.1a42e9	e2 20		sep #$20	            SEP #$20
.1a42eb	b9 0a 00	lda $000a,y	                LDA #FOR_RECORD.FINALTYPE,B,Y
.1a42ee	85 2d		sta $082d	                STA ARGTYPE2
.1a42f0	c2 20		rep #$20	            REP #$20
.1a42f2	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y ; Check the increment's sign
.1a42f5	30 0a		bmi $1a4301	                BMI going_down
.1a42f7					going_up
.1a42f7	20 6c 2a	jsr $1a2a6c	            JSR OP_LTE
.1a42fa	20 1a 06	jsr $1a061a	            JSR IS_ARG1_Z
.1a42fd	f0 28		beq $1a4327	                BEQ end_loop                    ; No: end the loop
.1a42ff	80 08		bra $1a4309	                BRA loop_back                   ; Yes: loop back
.1a4301					going_down
.1a4301	20 2c 2a	jsr $1a2a2c	            JSR OP_GTE
.1a4304	20 1a 06	jsr $1a061a	            JSR IS_ARG1_Z
.1a4307	f0 1e		beq $1a4327	                BEQ end_loop                    ; No: end the loop
.1a4309					loop_back
.1a4309	c2 20		rep #$20	            REP #$20
.1a430b	b9 12 00	lda $0012,y	                LDA #FOR_RECORD.BIP,B,Y
.1a430e	85 00		sta $0800	                STA BIP
.1a4310	b9 14 00	lda $0014,y	                LDA #FOR_RECORD.BIP+2,B,Y
.1a4313	85 02		sta $0802	                STA BIP+2
.1a4315	b9 16 00	lda $0016,y	                LDA #FOR_RECORD.CURLINE,B,Y     ; CURLINE := FOR_RECORD.CURLINE
.1a4318	85 1a		sta $081a	                STA CURLINE
.1a431a	b9 18 00	lda $0018,y	                LDA #FOR_RECORD.CURLINE+2,B,Y
.1a431d	85 1c		sta $081c	                STA CURLINE+2
.1a431f	e2 20		sep #$20	            SEP #$20
.1a4321	a9 03		lda #$03	                LDA #EXEC_RETURN
.1a4323	85 dc		sta $08dc	                STA EXECACTION
.1a4325	80 17		bra $1a433e	                BRA done
.1a4327					end_loop
.1a4327	a2 23 08	ldx #$0823	                LDX #ARGUMENT1
.1a432a	20 e9 19	jsr $1a19e9	            JSR PLARGUMENT
.1a432d	c2 20		rep #$20	            REP #$20
.1a432f	18		clc		                CLC
.1a4330	a5 33		lda $0833	                LDA RETURNSP
.1a4332	69 1a 00	adc #$001a	                ADC #size(FOR_RECORD)           ; Move pointer by number of bytes in a FOR record
.1a4335	85 33		sta $0833	                STA RETURNSP
.1a4337	a5 35		lda $0835	                LDA RETURNSP+2
.1a4339	69 00 00	adc #$0000	                ADC #0
.1a433c	85 35		sta $0835	                STA RETURNSP+2
.1a433e	ab		plb		done            PLB
.1a433f	28		plp		                PLP
.1a4340	60		rts		            RTS
.1a4341					S_GOSUB
.1a4341	08		php		                PHP
.1a4342	a5 1a		lda $081a	                LDA CURLINE                 ; Save the current line for later
.1a4344	48		pha		                PHA
.1a4345	a5 1c		lda $081c	                LDA CURLINE+2
.1a4347	48		pha		                PHA
.1a4348	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a434b	20 d8 08	jsr $1a08d8	            JSR PARSEINT
.1a434e	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.1a4350	f0 26		beq $1a4378	                BEQ syntax_err              ; If 0, no number was found... syntax error
.1a4352	20 1d 24	jsr $1a241d	            JSR FINDLINE
.1a4355	90 42		bcc $1a4399	                BCC not_found               ; If not found... LINE NOT FOUND error
.1a4357	e2 20		sep #$20	            SEP #$20
.1a4359	a9 02		lda #$02	                LDA #EXEC_GOTO
.1a435b	85 dc		sta $08dc	                STA EXECACTION
.1a435d	20 62 21	jsr $1a2162	            JSR SKIPSTMT
.1a4360	c2 20		rep #$20	            REP #$20
.1a4362	68		pla		                PLA                         ; Save the old value of CURLINE to the RETURN stack
.1a4363	20 25 1e	jsr $1a1e25	            JSR PHRETURN
.1a4366	68		pla		                PLA
.1a4367	20 25 1e	jsr $1a1e25	            JSR PHRETURN
.1a436a	a5 02		lda $0802	                LDA BIP+2                   ; Save the BASIC Instruction Pointer to the RETURN stack
.1a436c	20 25 1e	jsr $1a1e25	            JSR PHRETURN
.1a436f	a5 00		lda $0800	                LDA BIP
.1a4371	20 25 1e	jsr $1a1e25	            JSR PHRETURN
.1a4374	e6 31		inc $0831	                INC GOSUBDEPTH              ; Increase the count of GOSUBs on the stack
.1a4376	28		plp		                PLP
.1a4377	60		rts		            RTS
.1a4378	68		pla		syntax_err      PLA
.1a4379	68		pla		                PLA
.1a437a	08		php		            PHP
.1a437b	c2 20		rep #$20	            REP #$20
.1a437d	48		pha		            PHA
.1a437e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4381	5b		tcd		            TCD
.1a4382	68		pla		            PLA
.1a4383	28		plp		            PLP
.1a4384	e2 20		sep #$20	            SEP #$20
.1a4386	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4388	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a438c	c2 20		rep #$20	            REP #$20
.1a438e	29 ff 00	and #$00ff	            AND #$00FF
.1a4391	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4394	e2 20		sep #$20	            SEP #$20
.1a4396	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4399	68		pla		not_found       PLA
.1a439a	68		pla		                PLA
.1a439b	08		php		            PHP
.1a439c	c2 20		rep #$20	            REP #$20
.1a439e	48		pha		            PHA
.1a439f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a43a2	5b		tcd		            TCD
.1a43a3	68		pla		            PLA
.1a43a4	28		plp		            PLP
.1a43a5	e2 20		sep #$20	            SEP #$20
.1a43a7	a9 06		lda #$06	            LDA #ERR_NOLINE
.1a43a9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a43ad	c2 20		rep #$20	            REP #$20
.1a43af	29 ff 00	and #$00ff	            AND #$00FF
.1a43b2	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a43b5	e2 20		sep #$20	            SEP #$20
.1a43b7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a43ba					S_RETURN
.1a43ba	08		php		                PHP
.1a43bb	c2 30		rep #$30	            REP #$30
.1a43bd	a5 31		lda $0831	                LDA GOSUBDEPTH              ; Check that there is at least on GOSUB on the stack
.1a43bf	f0 1e		beq $1a43df	                BEQ underflow               ; No? It's a stack underflow error
.1a43c1	20 47 1e	jsr $1a1e47	            JSR PLRETURN
.1a43c4	85 00		sta $0800	                STA BIP
.1a43c6	20 47 1e	jsr $1a1e47	            JSR PLRETURN
.1a43c9	85 02		sta $0802	                STA BIP+2
.1a43cb	20 47 1e	jsr $1a1e47	            JSR PLRETURN
.1a43ce	85 1a		sta $081a	                STA CURLINE
.1a43d0	20 47 1e	jsr $1a1e47	            JSR PLRETURN
.1a43d3	85 1c		sta $081c	                STA CURLINE+2
.1a43d5	c6 31		dec $0831	                DEC GOSUBDEPTH              ; Indicate we've popped that GOSUB off the stack
.1a43d7	e2 20		sep #$20	            SEP #$20
.1a43d9	a9 03		lda #$03	                LDA #EXEC_RETURN
.1a43db	85 dc		sta $08dc	                STA EXECACTION
.1a43dd	28		plp		                PLP
.1a43de	60		rts		            RTS
.1a43df					underflow
.1a43df	08		php		            PHP
.1a43e0	c2 20		rep #$20	            REP #$20
.1a43e2	48		pha		            PHA
.1a43e3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a43e6	5b		tcd		            TCD
.1a43e7	68		pla		            PLA
.1a43e8	28		plp		            PLP
.1a43e9	e2 20		sep #$20	            SEP #$20
.1a43eb	a9 07		lda #$07	            LDA #ERR_STACKUNDER
.1a43ed	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a43f1	c2 20		rep #$20	            REP #$20
.1a43f3	29 ff 00	and #$00ff	            AND #$00FF
.1a43f6	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a43f9	e2 20		sep #$20	            SEP #$20
.1a43fb	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a43fe					S_IF
.1a43fe	08		php		                PHP
.1a43ff	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4402	20 1a 06	jsr $1a061a	            JSR IS_ARG1_Z
.1a4405	f0 1c		beq $1a4423	                BEQ is_false                ; If so, handle the FALSE case
.1a4407	e2 20		sep #$20	            SEP #$20
.1a4409	a9 97		lda #$97	                LDA #TOK_THEN               ; Verify that the next token is THEN and eat it
.1a440b	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a440e	20 d8 08	jsr $1a08d8	            JSR PARSEINT
.1a4411	20 1a 06	jsr $1a061a	            JSR IS_ARG1_Z
.1a4414	f0 12		beq $1a4428	                BEQ syntax_err              ; If not, we have a syntax error
.1a4416	20 1d 24	jsr $1a241d	            JSR FINDLINE
.1a4419	90 2c		bcc $1a4447	                BCC not_found               ; If not found... LINE NOT FOUND error
.1a441b	e2 20		sep #$20	            SEP #$20
.1a441d	a9 02		lda #$02	                LDA #EXEC_GOTO
.1a441f	85 dc		sta $08dc	                STA EXECACTION
.1a4421	80 03		bra $1a4426	                BRA done
.1a4423					is_false
.1a4423	20 62 21	jsr $1a2162	            JSR SKIPSTMT
.1a4426	28		plp		done            PLP
.1a4427	60		rts		            RTS
.1a4428					syntax_err
.1a4428	08		php		            PHP
.1a4429	c2 20		rep #$20	            REP #$20
.1a442b	48		pha		            PHA
.1a442c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a442f	5b		tcd		            TCD
.1a4430	68		pla		            PLA
.1a4431	28		plp		            PLP
.1a4432	e2 20		sep #$20	            SEP #$20
.1a4434	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4436	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a443a	c2 20		rep #$20	            REP #$20
.1a443c	29 ff 00	and #$00ff	            AND #$00FF
.1a443f	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4442	e2 20		sep #$20	            SEP #$20
.1a4444	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4447					not_found
.1a4447	08		php		            PHP
.1a4448	c2 20		rep #$20	            REP #$20
.1a444a	48		pha		            PHA
.1a444b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a444e	5b		tcd		            TCD
.1a444f	68		pla		            PLA
.1a4450	28		plp		            PLP
.1a4451	e2 20		sep #$20	            SEP #$20
.1a4453	a9 06		lda #$06	            LDA #ERR_NOLINE
.1a4455	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4459	c2 20		rep #$20	            REP #$20
.1a445b	29 ff 00	and #$00ff	            AND #$00FF
.1a445e	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4461	e2 20		sep #$20	            SEP #$20
.1a4463	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4466					S_END
.1a4466	08		php		                PHP
.1a4467	e2 20		sep #$20	            SEP #$20
.1a4469	a9 01		lda #$01	                LDA #EXEC_STOP
.1a446b	85 dc		sta $08dc	                STA EXECACTION
.1a446d	28		plp		                PLP
.1a446e	60		rts		            RTS
.1a446f					S_GOTO
.1a446f	08		php		                PHP
.1a4470	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a4473	20 d8 08	jsr $1a08d8	            JSR PARSEINT
.1a4476	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.1a4478	f0 0d		beq $1a4487	                BEQ syntax_err              ; If 0, no number was found... syntax error
.1a447a	20 1d 24	jsr $1a241d	            JSR FINDLINE
.1a447d	90 27		bcc $1a44a6	                BCC not_found               ; If not found... LINE NOT FOUND error
.1a447f	e2 20		sep #$20	            SEP #$20
.1a4481	a9 02		lda #$02	                LDA #EXEC_GOTO
.1a4483	85 dc		sta $08dc	                STA EXECACTION
.1a4485	28		plp		                PLP
.1a4486	60		rts		            RTS
.1a4487					syntax_err
.1a4487	08		php		            PHP
.1a4488	c2 20		rep #$20	            REP #$20
.1a448a	48		pha		            PHA
.1a448b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a448e	5b		tcd		            TCD
.1a448f	68		pla		            PLA
.1a4490	28		plp		            PLP
.1a4491	e2 20		sep #$20	            SEP #$20
.1a4493	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4495	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4499	c2 20		rep #$20	            REP #$20
.1a449b	29 ff 00	and #$00ff	            AND #$00FF
.1a449e	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a44a1	e2 20		sep #$20	            SEP #$20
.1a44a3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a44a6					not_found
.1a44a6	08		php		            PHP
.1a44a7	c2 20		rep #$20	            REP #$20
.1a44a9	48		pha		            PHA
.1a44aa	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a44ad	5b		tcd		            TCD
.1a44ae	68		pla		            PLA
.1a44af	28		plp		            PLP
.1a44b0	e2 20		sep #$20	            SEP #$20
.1a44b2	a9 06		lda #$06	            LDA #ERR_NOLINE
.1a44b4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a44b8	c2 20		rep #$20	            REP #$20
.1a44ba	29 ff 00	and #$00ff	            AND #$00FF
.1a44bd	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a44c0	e2 20		sep #$20	            SEP #$20
.1a44c2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a44c5					S_CLR
.1a44c5	20 8b 19	jsr $1a198b	            JSR INITEVALSP
.1a44c8	20 ab 10	jsr $1a10ab	            JSR INITHEAP
.1a44cb	20 20 51	jsr $1a5120	            JSR INITVARS
.1a44ce	60		rts		            RTS
.1a44cf					S_LET
.1a44cf	08		php		                PHP
.1a44d0	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.1a44d2	10 03		bpl $1a44d7	                BPL get_name        ; If it's not a token, try to find the variable name
.1a44d4	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a44d7					get_name
.1a44d7	20 20 54	jsr $1a5420	            JSR VAR_FINDNAME
.1a44da	b0 03		bcs $1a44df	                BCS check_array     ; If we didn't find a name, thrown an error
.1a44dc	4c 46 45	jmp $1a4546	                JMP syntax_err
.1a44df					check_array
.1a44df	e2 20		sep #$20	            SEP #$20
.1a44e1	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Save the variable name for later
.1a44e3	48		pha		                PHA                 ; (it will get over-written by variable references)
.1a44e4	a5 e9		lda $08e9	                LDA TOFIND+2
.1a44e6	48		pha		                PHA
.1a44e7	a5 e8		lda $08e8	                LDA TOFIND+1
.1a44e9	48		pha		                PHA
.1a44ea	a5 e7		lda $08e7	                LDA TOFIND
.1a44ec	48		pha		                PHA
.1a44ed	20 7e 22	jsr $1a227e	            JSR PEEK_TOK
.1a44f0	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it a "("
.1a44f2	d0 0e		bne $1a4502	                BNE get_value       ; No: it's a scalar assignment, look for the "="
.1a44f4	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a44f6	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a44f9	a9 00		lda #$00	                LDA #0
.1a44fb	8f 00 4d 00	sta $004d00	                STA @l ARRIDXBUF    ; Blank out the array index buffer
.1a44ff	20 0d 1b	jsr $1a1b0d	            JSR ARR_GETIDX
.1a4502					get_value
.1a4502	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a4505	e2 20		sep #$20	            SEP #$20
.1a4507	a7 00		lda [$0800]	                LDA [BIP]
.1a4509	c9 8a		cmp #$8a	                CMP #TOK_EQ
.1a450b	f0 03		beq $1a4510	                BEQ found_eq        ; If not found: signal an syntax error
.1a450d	4c 46 45	jmp $1a4546	                JMP syntax_err
.1a4510					found_eq
.1a4510	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4513	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4516	68		pla		                PLA                 ; Restore the variable name
.1a4517	85 e7		sta $08e7	                STA TOFIND
.1a4519	68		pla		                PLA
.1a451a	85 e8		sta $08e8	                STA TOFIND+1
.1a451c	68		pla		                PLA
.1a451d	85 e9		sta $08e9	                STA TOFIND+2
.1a451f	68		pla		                PLA
.1a4520	85 ea		sta $08ea	                STA TOFINDTYPE
.1a4522	29 80		and #$80	                AND #$80            ; Is it an array we're setting?
.1a4524	f0 1b		beq $1a4541	                BEQ set_scalar      ; No: do a scalar variable set
.1a4526	20 93 51	jsr $1a5193	            JSR VAR_FIND
.1a4529	90 3a		bcc $1a4565	                BCC notfound_err
.1a452b	c2 20		rep #$20	            REP #$20
.1a452d	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.1a4530	b7 08		lda [$0808],y	                LDA [INDEX],Y       ; Save the pointer to the array to CURRBLOCK
.1a4532	85 c0		sta $08c0	                STA CURRBLOCK
.1a4534	e2 20		sep #$20	            SEP #$20
.1a4536	c8		iny		                INY
.1a4537	c8		iny		                INY
.1a4538	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a453a	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a453c	20 8a 68	jsr $1a688a	            JSR ARR_SET
.1a453f	80 03		bra $1a4544	                BRA done            ; and we're finished!
.1a4541					set_scalar
.1a4541	20 83 53	jsr $1a5383	            JSR VAR_SET
.1a4544					done
.1a4544	28		plp		                PLP
.1a4545	60		rts		            RTS
.1a4546					syntax_err
.1a4546	08		php		            PHP
.1a4547	c2 20		rep #$20	            REP #$20
.1a4549	48		pha		            PHA
.1a454a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a454d	5b		tcd		            TCD
.1a454e	68		pla		            PLA
.1a454f	28		plp		            PLP
.1a4550	e2 20		sep #$20	            SEP #$20
.1a4552	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4554	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4558	c2 20		rep #$20	            REP #$20
.1a455a	29 ff 00	and #$00ff	            AND #$00FF
.1a455d	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4560	e2 20		sep #$20	            SEP #$20
.1a4562	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4565					notfound_err
.1a4565	08		php		            PHP
.1a4566	c2 20		rep #$20	            REP #$20
.1a4568	48		pha		            PHA
.1a4569	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a456c	5b		tcd		            TCD
.1a456d	68		pla		            PLA
.1a456e	28		plp		            PLP
.1a456f	e2 20		sep #$20	            SEP #$20
.1a4571	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a4573	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4577	c2 20		rep #$20	            REP #$20
.1a4579	29 ff 00	and #$00ff	            AND #$00FF
.1a457c	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a457f	e2 20		sep #$20	            SEP #$20
.1a4581	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4584					S_PRINT
.1a4584	08		php		                PHP
.1a4585	e2 20		sep #$20	            SEP #$20
.1a4587	20 7e 22	jsr $1a227e	            JSR PEEK_TOK
.1a458a	c9 00		cmp #$00	                CMP #0              ; Is it EOL or :?
.1a458c	f0 6d		beq $1a45fb	                BEQ pr_nl_exit      ; Yes: just print return
.1a458e					pr_loop
.1a458e	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4591	e2 20		sep #$20	            SEP #$20
.1a4593	a5 27		lda $0827	                LDA ARGTYPE1        ; Get the type of the result
.1a4595	c9 ff		cmp #$ff	                CMP #TYPE_NAV       ; Is is NAV?
.1a4597	f0 1b		beq $1a45b4	                BEQ check_nl        ; Yes: we are probably just printing a newline
.1a4599	c9 02		cmp #$02	                CMP #TYPE_STRING    ; Is it a string?
.1a459b	d0 05		bne $1a45a2	                BNE check_int       ; No: check to see if it's an integer
.1a459d	20 00 46	jsr $1a4600	            JSR PR_STRING
.1a45a0	80 12		bra $1a45b4	                BRA check_nl
.1a45a2	c9 00		cmp #$00	check_int       CMP #TYPE_INTEGER   ; Is it an integer?
.1a45a4	d0 05		bne $1a45ab	                BNE check_float     ; No: check to see if it is a float
.1a45a6	20 1e 46	jsr $1a461e	            JSR PR_INTEGER
.1a45a9	80 09		bra $1a45b4	                BRA check_nl
.1a45ab	c9 01		cmp #$01	check_float     CMP #TYPE_FLOAT     ; Is it a float?
.1a45ad	d0 4f		bne $1a45fe	                BNE done            ; No: just quit
.1a45af	20 31 46	jsr $1a4631	            JSR PR_FLOAT
.1a45b2	80 00		bra $1a45b4	                BRA check_nl
.1a45b4					check_nl
.1a45b4	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a45b7	a7 00		lda [$0800]	                LDA [BIP]
.1a45b9	f0 40		beq $1a45fb	                BEQ pr_nl_exit      ; If it's nul, print a newline and return
.1a45bb	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.1a45bd	f0 3c		beq $1a45fb	                BEQ pr_nl_exit      ; print a newline and return
.1a45bf	c9 2c		cmp #$2c	                CMP #','            ; If it's a comma
.1a45c1	f0 23		beq $1a45e6	                BEQ pr_comma        ; Print a TAB and try another expression
.1a45c3	c9 3b		cmp #$3b	                CMP #';'            ; If it's a semicolon...
.1a45c5	f0 24		beq $1a45eb	                BEQ is_more         ; Print nothing, and try another expression
.1a45c7	08		php		            PHP
.1a45c8	c2 20		rep #$20	            REP #$20
.1a45ca	48		pha		            PHA
.1a45cb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a45ce	5b		tcd		            TCD
.1a45cf	68		pla		            PLA
.1a45d0	28		plp		            PLP
.1a45d1	e2 20		sep #$20	            SEP #$20
.1a45d3	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a45d5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a45d9	c2 20		rep #$20	            REP #$20
.1a45db	29 ff 00	and #$00ff	            AND #$00FF
.1a45de	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a45e1	e2 20		sep #$20	            SEP #$20
.1a45e3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a45e6	a9 09		lda #$09	pr_comma        LDA #CHAR_TAB       ; Print a TAB
.1a45e8	20 18 00	jsr $1a0018	            JSR PRINTC
.1a45eb					is_more
.1a45eb	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a45ee	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a45f1	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.1a45f3	f0 09		beq $1a45fe	                BEQ done            ; If it's NULL, return without printing a newline
.1a45f5	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.1a45f7	f0 05		beq $1a45fe	                BEQ done            ; ... return without printing a newline
.1a45f9	80 93		bra $1a458e	                BRA pr_loop         ; Otherwise, we should have another expression, try to handle it
.1a45fb					pr_nl_exit
.1a45fb	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a45fe	28		plp		done            PLP
.1a45ff	60		rts		            RTS
.1a4600					PR_STRING
.1a4600	08		php		                PHP
.1a4601	8b		phb		                PHB
.1a4602	08		php		            PHP
.1a4603	c2 20		rep #$20	            REP #$20
.1a4605	48		pha		            PHA
.1a4606	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a4609	5b		tcd		            TCD
.1a460a	68		pla		            PLA
.1a460b	28		plp		            PLP
.1a460c	e2 20		sep #$20	            SEP #$20
.1a460e	a0 00 00	ldy #$0000	start_print     LDY #0
.1a4611	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y
.1a4613	f0 06		beq $1a461b	                BEQ done
.1a4615	20 18 00	jsr $1a0018	            JSR PRINTC
.1a4618	c8		iny		                INY
.1a4619	80 f6		bra $1a4611	                BRA loop
.1a461b	ab		plb		done            PLB
.1a461c	28		plp		                PLP
.1a461d	60		rts		            RTS
.1a461e					PR_INTEGER
.1a461e	08		php		                PHP
.1a461f	c2 20		rep #$20	            REP #$20
.1a4621	20 60 15	jsr $1a1560	            JSR ITOS
.1a4624	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.1a4626	85 23		sta $0823	                STA ARGUMENT1
.1a4628	a5 18		lda $0818	                LDA STRPTR+2
.1a462a	85 25		sta $0825	                STA ARGUMENT1+2
.1a462c	20 00 46	jsr $1a4600	            JSR PR_STRING
.1a462f	28		plp		                PLP
.1a4630	60		rts		            RTS
.1a4631					PR_FLOAT
.1a4631	08		php		                PHP
.1a4632	20 e9 5d	jsr $1a5de9	            JSR FTOS
.1a4635	c2 20		rep #$20	            REP #$20
.1a4637	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.1a4639	85 23		sta $0823	                STA ARGUMENT1
.1a463b	a5 18		lda $0818	                LDA STRPTR+2
.1a463d	85 25		sta $0825	                STA ARGUMENT1+2
.1a463f	20 00 46	jsr $1a4600	            JSR PR_STRING
.1a4642	28		plp		                PLP
.1a4643	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\functions.s


;******  Processing file: src\C256/functions_c256.s

.1a4644					BCD2STR
.1a4644	08		php		            PHP
.1a4645	e2 20		sep #$20	            SEP #$20
.1a4647	85 b5		sta $08b5	            STA SAVE_A
.1a4649	4a		lsr a		            LSR A
.1a464a	4a		lsr a		            LSR A
.1a464b	4a		lsr a		            LSR A
.1a464c	4a		lsr a		            LSR A
.1a464d	29 0f		and #$0f	            AND #$0F
.1a464f	18		clc		            CLC
.1a4650	69 30		adc #$30	            ADC #'0'
.1a4652	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a4654	c8		iny		            INY
.1a4655	a5 b5		lda $08b5	            LDA SAVE_A
.1a4657	29 0f		and #$0f	            AND #$0F
.1a4659	18		clc		            CLC
.1a465a	69 30		adc #$30	            ADC #'0'
.1a465c	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a465e	c8		iny		            INY
.1a465f	28		plp		            PLP
.1a4660	60		rts		            RTS
.1a4661					F_GETDATE
.1a4661	e2 20		sep #$20	            SEP #$20
.1a4663	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4665	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4668	08		php		            PHP
.1a4669	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a466c	e2 20		sep #$20	            SEP #$20
.1a466e	c2 10		rep #$10	            REP #$10
.1a4670	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a4674	09 08		ora #$08	            ORA #%00001000
.1a4676	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a467a	20 01 15	jsr $1a1501	            JSR TEMPSTRING
.1a467d	a0 00 00	ldy #$0000	            LDY #0
.1a4680	af 06 08 af	lda $af0806	            LDA @lRTC_DAY           ; Write the day of the month
.1a4684	20 44 46	jsr $1a4644	            JSR BCD2STR
.1a4687	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.1a4689	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a468b	c8		iny		            INY
.1a468c	af 09 08 af	lda $af0809	            LDA @lRTC_MONTH         ; Write the month
.1a4690	20 44 46	jsr $1a4644	            JSR BCD2STR
.1a4693	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.1a4695	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a4697	c8		iny		            INY
.1a4698	af 0f 08 af	lda $af080f	            LDA @lRTC_CENTURY       ; Write the year
.1a469c	20 44 46	jsr $1a4644	            JSR BCD2STR
.1a469f	af 0a 08 af	lda $af080a	            LDA @lRTC_YEAR          ; Write the year
.1a46a3	20 44 46	jsr $1a4644	            JSR BCD2STR
.1a46a6	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.1a46a8	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a46aa	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a46ae	29 f7		and #$f7	            AND #%11110111
.1a46b0	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a46b4	c2 20		rep #$20	            REP #$20
.1a46b6	a5 16		lda $0816	            LDA STRPTR
.1a46b8	85 23		sta $0823	            STA ARGUMENT1
.1a46ba	a5 18		lda $0818	            LDA STRPTR+2
.1a46bc	85 25		sta $0825	            STA ARGUMENT1+2
.1a46be	e2 20		sep #$20	            SEP #$20
.1a46c0	a9 02		lda #$02	            LDA #TYPE_STRING
.1a46c2	85 27		sta $0827	            STA ARGTYPE1
.1a46c4	28		plp		            PLP
.1a46c5	e2 20		sep #$20	            SEP #$20
.1a46c7	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a46ca	60		rts		            RTS
.1a46cb					F_GETTIME
.1a46cb	e2 20		sep #$20	            SEP #$20
.1a46cd	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a46cf	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a46d2	08		php		            PHP
.1a46d3	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a46d6	e2 20		sep #$20	            SEP #$20
.1a46d8	c2 10		rep #$10	            REP #$10
.1a46da	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a46de	09 08		ora #$08	            ORA #%00001000
.1a46e0	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a46e4	20 01 15	jsr $1a1501	            JSR TEMPSTRING
.1a46e7	a0 00 00	ldy #$0000	            LDY #0
.1a46ea	af 04 08 af	lda $af0804	            LDA @lRTC_HRS           ; Write the hour
.1a46ee	29 7f		and #$7f	            AND #$7F                ; Trim out the AM/PM indicator
.1a46f0	20 44 46	jsr $1a4644	            JSR BCD2STR
.1a46f3	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.1a46f5	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a46f7	c8		iny		            INY
.1a46f8	af 02 08 af	lda $af0802	            LDA @lRTC_MIN           ; Write the minute
.1a46fc	20 44 46	jsr $1a4644	            JSR BCD2STR
.1a46ff	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.1a4701	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a4703	c8		iny		            INY
.1a4704	af 00 08 af	lda $af0800	            LDA @lRTC_SEC           ; Write the second
.1a4708	20 44 46	jsr $1a4644	            JSR BCD2STR
.1a470b	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.1a470d	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a470f	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a4713	29 f7		and #$f7	            AND #%11110111
.1a4715	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a4719	c2 20		rep #$20	            REP #$20
.1a471b	a5 16		lda $0816	            LDA STRPTR
.1a471d	85 23		sta $0823	            STA ARGUMENT1
.1a471f	a5 18		lda $0818	            LDA STRPTR+2
.1a4721	85 25		sta $0825	            STA ARGUMENT1+2
.1a4723	e2 20		sep #$20	            SEP #$20
.1a4725	a9 02		lda #$02	            LDA #TYPE_STRING
.1a4727	85 27		sta $0827	            STA ARGTYPE1
.1a4729	28		plp		            PLP
.1a472a	e2 20		sep #$20	            SEP #$20
.1a472c	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a472f	60		rts		            RTS
.1a4730					FN_RND
.1a4730	e2 20		sep #$20	            SEP #$20
.1a4732	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4734	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4737	08		php		            PHP
.1a4738	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a473b	e2 20		sep #$20	            SEP #$20
.1a473d	a9 01		lda #$01	            LDA #TYPE_FLOAT             ; We'll return a floating point number
.1a473f	85 27		sta $0827	            STA ARGTYPE1
.1a4741	a9 03		lda #$03	            LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.1a4743	8f 00 e2 af	sta $afe200	            STA @l FP_MATH_CTRL0        ; Expect fixed point numbers
.1a4747	a9 01		lda #$01	            LDA #FP_OUT_DIV             ; Set us to do a division
.1a4749	8f 01 e2 af	sta $afe201	            STA @l FP_MATH_CTRL1
.1a474d	c2 30		rep #$30	            REP #$30
.1a474f	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get a random 16-bits
.1a4753	8f 08 e2 af	sta $afe208	            STA @l FP_MATH_INPUT0_LL    ; Send them to the FP unit
.1a4757	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get another random 16-bits
.1a475b	29 ff 7f	and #$7fff	            AND #$7FFF                  ; Make sure it's positive
.1a475e	8f 0a e2 af	sta $afe20a	            STA @l FP_MATH_INPUT0_LL+2  ; Send them to the FP unit
.1a4762	a9 ff ff	lda #$ffff	            LDA #$FFFF                  ; Get the maximum value
.1a4765	8f 0c e2 af	sta $afe20c	            STA @l FP_MATH_INPUT1_LL    ; Send it to the FP unit
.1a4769	a9 ff 7f	lda #$7fff	            LDA #$7FFF
.1a476c	8f 0e e2 af	sta $afe20e	            STA @l FP_MATH_INPUT1_LL+2
.1a4770	ea		nop		            NOP
.1a4771	ea		nop		            NOP
.1a4772	ea		nop		            NOP
.1a4773	af 08 e2 af	lda $afe208	            LDA @l FP_MATH_OUTPUT_FP_LL     ; Get the normalized result
.1a4777	85 23		sta $0823	            STA ARGUMENT1
.1a4779	af 0a e2 af	lda $afe20a	            LDA @l FP_MATH_OUTPUT_FP_LL+2
.1a477d	85 25		sta $0825	            STA ARGUMENT1+2
.1a477f	28		plp		            PLP
.1a4780	e2 20		sep #$20	            SEP #$20
.1a4782	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4785	60		rts		            RTS
.1a4786					FN_INKEY
.1a4786	e2 20		sep #$20	            SEP #$20
.1a4788	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a478a	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a478d	08		php		            PHP
.1a478e	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4791	22 28 10 00	jsl $001028	            JSL FK_GETSCANCODE          ; Get the scan code
.1a4795	e2 20		sep #$20	            SEP #$20
.1a4797	85 23		sta $0823	            STA ARGUMENT1
.1a4799	64 24		stz $0824	            STZ ARGUMENT1+1
.1a479b	64 25		stz $0825	            STZ ARGUMENT1+2
.1a479d	64 26		stz $0826	            STZ ARGUMENT1+3
.1a479f	a9 00		lda #$00	            LDA #TYPE_INTEGER           ; We'll return an integer number
.1a47a1	85 27		sta $0827	            STA ARGTYPE1
.1a47a3	28		plp		            PLP
.1a47a4	e2 20		sep #$20	            SEP #$20
.1a47a6	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a47a9	60		rts		            RTS

;******  Return to file: src\functions.s

.1a47aa					FN_MID
.1a47aa	e2 20		sep #$20	            SEP #$20
.1a47ac	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a47ae	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a47b1	08		php		                PHP
.1a47b2	c2 30		rep #$30	            REP #$30
.1a47b4	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a47b7	20 e3 06	jsr $1a06e3	            JSR ASS_ARG1_STR
.1a47ba					save_string
.1a47ba	c2 20		rep #$20	            REP #$20
.1a47bc	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.1a47be	48		pha		                PHA
.1a47bf	a5 23		lda $0823	                LDA ARGUMENT1
.1a47c1	48		pha		                PHA
.1a47c2	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a47c5	e2 20		sep #$20	            SEP #$20
.1a47c7	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a47c9	c9 2c		cmp #$2c	                CMP #','
.1a47cb	f0 03		beq $1a47d0	                BEQ skip_comma1
.1a47cd	4c 21 48	jmp $1a4821	                JMP syntax_err
.1a47d0					skip_comma1
.1a47d0	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a47d3	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a47d6	20 0d 07	jsr $1a070d	            JSR ASS_ARG1_INT16
.1a47d9	c2 20		rep #$20	            REP #$20
.1a47db	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the index
.1a47dd	48		pha		                PHA
.1a47de	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a47e1	e2 20		sep #$20	            SEP #$20
.1a47e3	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a47e5	c9 2c		cmp #$2c	                CMP #','
.1a47e7	f0 03		beq $1a47ec	                BEQ skip_comma2
.1a47e9	4c 21 48	jmp $1a4821	                JMP syntax_err
.1a47ec					skip_comma2
.1a47ec	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a47ef	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a47f2	20 0d 07	jsr $1a070d	            JSR ASS_ARG1_INT16
.1a47f5	c2 20		rep #$20	            REP #$20
.1a47f7	a5 23		lda $0823	            LDA ARGUMENT1
.1a47f9	85 8f		sta $088f	            STA MCOUNT
.1a47fb	e2 20		sep #$20	            SEP #$20
.1a47fd	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a47ff	85 91		sta $0891	            STA MCOUNT+2
.1a4801	c2 20		rep #$20	            REP #$20
.1a4803	68		pla		                PLA                         ; Restore index
.1a4804	85 29		sta $0829	                STA ARGUMENT2               ; ... to ARGUMENT2
.1a4806	a9 00 00	lda #$0000	                LDA #0
.1a4809	85 2b		sta $082b	                STA ARGUMENT2+2
.1a480b	68		pla		                PLA                         ; Restore string
.1a480c	85 23		sta $0823	                STA ARGUMENT1               ; ... to ARGUMENT1
.1a480e	68		pla		                PLA
.1a480f	85 25		sta $0825	                STA ARGUMENT1+2
.1a4811	e2 20		sep #$20	            SEP #$20
.1a4813	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a4815	85 27		sta $0827	            STA ARGTYPE1
.1a4817	20 59 17	jsr $1a1759	            JSR STRSUBSTR
.1a481a					done
.1a481a	e2 20		sep #$20	            SEP #$20
.1a481c	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a481f	28		plp		                PLP
.1a4820	60		rts		            RTS
.1a4821					syntax_err
.1a4821	08		php		            PHP
.1a4822	c2 20		rep #$20	            REP #$20
.1a4824	48		pha		            PHA
.1a4825	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4828	5b		tcd		            TCD
.1a4829	68		pla		            PLA
.1a482a	28		plp		            PLP
.1a482b	e2 20		sep #$20	            SEP #$20
.1a482d	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a482f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4833	c2 20		rep #$20	            REP #$20
.1a4835	29 ff 00	and #$00ff	            AND #$00FF
.1a4838	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a483b	e2 20		sep #$20	            SEP #$20
.1a483d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4840					range_err
.1a4840	08		php		            PHP
.1a4841	c2 20		rep #$20	            REP #$20
.1a4843	48		pha		            PHA
.1a4844	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4847	5b		tcd		            TCD
.1a4848	68		pla		            PLA
.1a4849	28		plp		            PLP
.1a484a	e2 20		sep #$20	            SEP #$20
.1a484c	a9 09		lda #$09	            LDA #ERR_RANGE
.1a484e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4852	c2 20		rep #$20	            REP #$20
.1a4854	29 ff 00	and #$00ff	            AND #$00FF
.1a4857	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a485a	e2 20		sep #$20	            SEP #$20
.1a485c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a485f					FN_RIGHT
.1a485f	e2 20		sep #$20	            SEP #$20
.1a4861	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4863	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4866	08		php		                PHP
.1a4867	c2 30		rep #$30	            REP #$30
.1a4869	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a486c	e2 20		sep #$20	            SEP #$20
.1a486e	a5 27		lda $0827	                LDA ARGTYPE1
.1a4870	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4872	f0 03		beq $1a4877	                BEQ save_string
.1a4874	4c e3 48	jmp $1a48e3	                JMP type_mismatch           ; Type mismatch if it's not a string
.1a4877					save_string
.1a4877	c2 20		rep #$20	            REP #$20
.1a4879	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.1a487b	48		pha		                PHA
.1a487c	a5 23		lda $0823	                LDA ARGUMENT1
.1a487e	48		pha		                PHA
.1a487f	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a4882	e2 20		sep #$20	            SEP #$20
.1a4884	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a4886	c9 2c		cmp #$2c	                CMP #','
.1a4888	f0 03		beq $1a488d	                BEQ skip_comma
.1a488a	4c 02 49	jmp $1a4902	                JMP syntax_err
.1a488d					skip_comma
.1a488d	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4890	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4893	e2 20		sep #$20	            SEP #$20
.1a4895	a5 27		lda $0827	                LDA ARGTYPE1
.1a4897	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4899	d0 48		bne $1a48e3	                BNE type_mismatch           ; Type mismatch if it's not an integer
.1a489b	c2 20		rep #$20	            REP #$20
.1a489d	a5 23		lda $0823	            LDA ARGUMENT1
.1a489f	85 8f		sta $088f	            STA MCOUNT
.1a48a1	c2 20		rep #$20	            REP #$20
.1a48a3	68		pla		                PLA                         ; Recover the string pointer
.1a48a4	85 23		sta $0823	                STA ARGUMENT1
.1a48a6	68		pla		                PLA
.1a48a7	85 25		sta $0825	                STA ARGUMENT1+2
.1a48a9	e2 20		sep #$20	            SEP #$20
.1a48ab	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a48ad	85 27		sta $0827	            STA ARGTYPE1
.1a48af	e2 20		sep #$20	            SEP #$20
.1a48b1	a0 00 00	ldy #$0000	                LDY #0
.1a48b4	b7 23		lda [$0823],y	count_loop      LDA [ARGUMENT1],Y
.1a48b6	f0 03		beq $1a48bb	                BEQ count_done
.1a48b8	c8		iny		                INY
.1a48b9	80 f9		bra $1a48b4	                BRA count_loop
.1a48bb					count_done
.1a48bb	c2 20		rep #$20	            REP #$20
.1a48bd	98		tya		                TYA                         ; ARGUMENT2 := LENGTH - MCOUNT
.1a48be	38		sec		                SEC
.1a48bf	e5 8f		sbc $088f	                SBC MCOUNT
.1a48c1	30 09		bmi $1a48cc	                BMI index0                  ; if ARGUMENT2 < 0, set ARGUMENT2 := 0
.1a48c3	85 29		sta $0829	                STA ARGUMENT2
.1a48c5	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT2[23..16] := 0
.1a48c8	85 2b		sta $082b	                STA ARGUMENT2+2
.1a48ca	80 07		bra $1a48d3	                BRA slice
.1a48cc	a9 00 00	lda #$0000	index0          LDA #0                      ; 0 is the floor for the index
.1a48cf	85 29		sta $0829	                STA ARGUMENT2
.1a48d1	85 2b		sta $082b	                STA ARGUMENT2+2
.1a48d3					slice
.1a48d3	e2 20		sep #$20	            SEP #$20
.1a48d5	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a48d7	85 2d		sta $082d	            STA ARGTYPE2
.1a48d9	20 59 17	jsr $1a1759	            JSR STRSUBSTR
.1a48dc					done
.1a48dc	e2 20		sep #$20	            SEP #$20
.1a48de	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a48e1	28		plp		                PLP
.1a48e2	60		rts		            RTS
.1a48e3					type_mismatch
.1a48e3	08		php		            PHP
.1a48e4	c2 20		rep #$20	            REP #$20
.1a48e6	48		pha		            PHA
.1a48e7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a48ea	5b		tcd		            TCD
.1a48eb	68		pla		            PLA
.1a48ec	28		plp		            PLP
.1a48ed	e2 20		sep #$20	            SEP #$20
.1a48ef	a9 04		lda #$04	            LDA #ERR_TYPE
.1a48f1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a48f5	c2 20		rep #$20	            REP #$20
.1a48f7	29 ff 00	and #$00ff	            AND #$00FF
.1a48fa	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a48fd	e2 20		sep #$20	            SEP #$20
.1a48ff	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4902					syntax_err
.1a4902	08		php		            PHP
.1a4903	c2 20		rep #$20	            REP #$20
.1a4905	48		pha		            PHA
.1a4906	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4909	5b		tcd		            TCD
.1a490a	68		pla		            PLA
.1a490b	28		plp		            PLP
.1a490c	e2 20		sep #$20	            SEP #$20
.1a490e	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4910	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4914	c2 20		rep #$20	            REP #$20
.1a4916	29 ff 00	and #$00ff	            AND #$00FF
.1a4919	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a491c	e2 20		sep #$20	            SEP #$20
.1a491e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4921					range_err
.1a4921	08		php		            PHP
.1a4922	c2 20		rep #$20	            REP #$20
.1a4924	48		pha		            PHA
.1a4925	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4928	5b		tcd		            TCD
.1a4929	68		pla		            PLA
.1a492a	28		plp		            PLP
.1a492b	e2 20		sep #$20	            SEP #$20
.1a492d	a9 09		lda #$09	            LDA #ERR_RANGE
.1a492f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4933	c2 20		rep #$20	            REP #$20
.1a4935	29 ff 00	and #$00ff	            AND #$00FF
.1a4938	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a493b	e2 20		sep #$20	            SEP #$20
.1a493d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4940					FN_LEFT
.1a4940	e2 20		sep #$20	            SEP #$20
.1a4942	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4944	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4947	08		php		                PHP
.1a4948	c2 30		rep #$30	            REP #$30
.1a494a	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a494d	e2 20		sep #$20	            SEP #$20
.1a494f	a5 27		lda $0827	                LDA ARGTYPE1
.1a4951	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4953	f0 03		beq $1a4958	                BEQ save_string
.1a4955	4c ac 49	jmp $1a49ac	                JMP type_mismatch           ; Type mismatch if it's not a string
.1a4958					save_string
.1a4958	c2 20		rep #$20	            REP #$20
.1a495a	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.1a495c	48		pha		                PHA
.1a495d	a5 23		lda $0823	                LDA ARGUMENT1
.1a495f	48		pha		                PHA
.1a4960	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a4963	e2 20		sep #$20	            SEP #$20
.1a4965	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a4967	c9 2c		cmp #$2c	                CMP #','
.1a4969	f0 03		beq $1a496e	                BEQ skip_comma
.1a496b	4c cb 49	jmp $1a49cb	                JMP syntax_err
.1a496e					skip_comma
.1a496e	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4971	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4974	e2 20		sep #$20	            SEP #$20
.1a4976	a5 27		lda $0827	                LDA ARGTYPE1
.1a4978	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a497a	d0 30		bne $1a49ac	                BNE type_mismatch           ; Type mismatch if it's not an integer
.1a497c	c2 20		rep #$20	            REP #$20
.1a497e	a5 23		lda $0823	            LDA ARGUMENT1
.1a4980	85 8f		sta $088f	            STA MCOUNT
.1a4982	c2 20		rep #$20	            REP #$20
.1a4984	a9 00 00	lda #$0000	            LDA #<>0
.1a4987	85 29		sta $0829	            STA ARGUMENT2
.1a4989	a9 00 00	lda #$0000	            LDA #(0 >> 16)
.1a498c	85 2b		sta $082b	            STA ARGUMENT2+2
.1a498e	e2 20		sep #$20	            SEP #$20
.1a4990	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a4992	85 2d		sta $082d	            STA ARGTYPE2
.1a4994	c2 20		rep #$20	            REP #$20
.1a4996	68		pla		                PLA                         ; Recover the string pointer
.1a4997	85 23		sta $0823	                STA ARGUMENT1
.1a4999	68		pla		                PLA
.1a499a	85 25		sta $0825	                STA ARGUMENT1+2
.1a499c	e2 20		sep #$20	            SEP #$20
.1a499e	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a49a0	85 27		sta $0827	            STA ARGTYPE1
.1a49a2	20 59 17	jsr $1a1759	            JSR STRSUBSTR
.1a49a5					done
.1a49a5	e2 20		sep #$20	            SEP #$20
.1a49a7	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a49aa	28		plp		                PLP
.1a49ab	60		rts		            RTS
.1a49ac					type_mismatch
.1a49ac	08		php		            PHP
.1a49ad	c2 20		rep #$20	            REP #$20
.1a49af	48		pha		            PHA
.1a49b0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a49b3	5b		tcd		            TCD
.1a49b4	68		pla		            PLA
.1a49b5	28		plp		            PLP
.1a49b6	e2 20		sep #$20	            SEP #$20
.1a49b8	a9 04		lda #$04	            LDA #ERR_TYPE
.1a49ba	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a49be	c2 20		rep #$20	            REP #$20
.1a49c0	29 ff 00	and #$00ff	            AND #$00FF
.1a49c3	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a49c6	e2 20		sep #$20	            SEP #$20
.1a49c8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a49cb					syntax_err
.1a49cb	08		php		            PHP
.1a49cc	c2 20		rep #$20	            REP #$20
.1a49ce	48		pha		            PHA
.1a49cf	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a49d2	5b		tcd		            TCD
.1a49d3	68		pla		            PLA
.1a49d4	28		plp		            PLP
.1a49d5	e2 20		sep #$20	            SEP #$20
.1a49d7	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a49d9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a49dd	c2 20		rep #$20	            REP #$20
.1a49df	29 ff 00	and #$00ff	            AND #$00FF
.1a49e2	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a49e5	e2 20		sep #$20	            SEP #$20
.1a49e7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a49ea					range_err
.1a49ea	08		php		            PHP
.1a49eb	c2 20		rep #$20	            REP #$20
.1a49ed	48		pha		            PHA
.1a49ee	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a49f1	5b		tcd		            TCD
.1a49f2	68		pla		            PLA
.1a49f3	28		plp		            PLP
.1a49f4	e2 20		sep #$20	            SEP #$20
.1a49f6	a9 09		lda #$09	            LDA #ERR_RANGE
.1a49f8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a49fc	c2 20		rep #$20	            REP #$20
.1a49fe	29 ff 00	and #$00ff	            AND #$00FF
.1a4a01	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4a04	e2 20		sep #$20	            SEP #$20
.1a4a06	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4a09					FN_VAL
.1a4a09	e2 20		sep #$20	            SEP #$20
.1a4a0b	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4a0d	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4a10	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4a13	c2 10		rep #$10	            REP #$10
.1a4a15	e2 20		sep #$20	            SEP #$20
.1a4a17	a5 27		lda $0827	                LDA ARGTYPE1
.1a4a19	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4a1b	d0 23		bne $1a4a40	                BNE type_mismatch
.1a4a1d	c2 20		rep #$20	            REP #$20
.1a4a1f	a5 00		lda $0800	                LDA BIP             ; preserve BIP for later
.1a4a21	85 40		sta $0840	                STA SAVEBIP
.1a4a23	a5 02		lda $0802	                LDA BIP+2
.1a4a25	85 42		sta $0842	                STA SAVEBIP+2
.1a4a27	a5 23		lda $0823	                LDA ARGUMENT1       ; Temporarily point BIP to the string to parse
.1a4a29	85 00		sta $0800	                STA BIP
.1a4a2b	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4a2d	85 02		sta $0802	                STA BIP+2
.1a4a2f	20 d8 08	jsr $1a08d8	            JSR PARSEINT
.1a4a32	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.1a4a34	85 00		sta $0800	                STA BIP
.1a4a36	a5 42		lda $0842	                LDA SAVEBIP+2
.1a4a38	85 02		sta $0802	                STA BIP+2
.1a4a3a	e2 20		sep #$20	            SEP #$20
.1a4a3c	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4a3f	60		rts		            RTS
.1a4a40					type_mismatch
.1a4a40	08		php		            PHP
.1a4a41	c2 20		rep #$20	            REP #$20
.1a4a43	48		pha		            PHA
.1a4a44	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4a47	5b		tcd		            TCD
.1a4a48	68		pla		            PLA
.1a4a49	28		plp		            PLP
.1a4a4a	e2 20		sep #$20	            SEP #$20
.1a4a4c	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4a4e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4a52	c2 20		rep #$20	            REP #$20
.1a4a54	29 ff 00	and #$00ff	            AND #$00FF
.1a4a57	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4a5a	e2 20		sep #$20	            SEP #$20
.1a4a5c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4a5f					FN_STR
.1a4a5f	e2 20		sep #$20	            SEP #$20
.1a4a61	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4a63	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4a66	08		php		                PHP
.1a4a67	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4a6a	c2 10		rep #$10	            REP #$10
.1a4a6c	e2 20		sep #$20	            SEP #$20
.1a4a6e	a5 27		lda $0827	                LDA ARGTYPE1
.1a4a70	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4a72	d0 1a		bne $1a4a8e	                BNE type_mismatch
.1a4a74	20 60 15	jsr $1a1560	            JSR ITOS
.1a4a77	c2 20		rep #$20	            REP #$20
.1a4a79	a5 16		lda $0816	                LDA STRPTR          ; Prepare the return result
.1a4a7b	85 23		sta $0823	                STA ARGUMENT1
.1a4a7d	a5 18		lda $0818	                LDA STRPTR+2
.1a4a7f	85 25		sta $0825	                STA ARGUMENT1+2
.1a4a81	e2 20		sep #$20	            SEP #$20
.1a4a83	a9 02		lda #$02	                LDA #TYPE_STRING
.1a4a85	85 27		sta $0827	                STA ARGTYPE1
.1a4a87	28		plp		                PLP
.1a4a88	e2 20		sep #$20	            SEP #$20
.1a4a8a	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4a8d	60		rts		            RTS
.1a4a8e					type_mismatch
.1a4a8e	08		php		            PHP
.1a4a8f	c2 20		rep #$20	            REP #$20
.1a4a91	48		pha		            PHA
.1a4a92	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4a95	5b		tcd		            TCD
.1a4a96	68		pla		            PLA
.1a4a97	28		plp		            PLP
.1a4a98	e2 20		sep #$20	            SEP #$20
.1a4a9a	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4a9c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4aa0	c2 20		rep #$20	            REP #$20
.1a4aa2	29 ff 00	and #$00ff	            AND #$00FF
.1a4aa5	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4aa8	e2 20		sep #$20	            SEP #$20
.1a4aaa	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4aad					FN_DEC
.1a4aad	e2 20		sep #$20	            SEP #$20
.1a4aaf	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4ab1	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4ab4	08		php		                PHP
.1a4ab5	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4ab8	20 e3 06	jsr $1a06e3	            JSR ASS_ARG1_STR
.1a4abb	c2 20		rep #$20	            REP #$20
.1a4abd	64 0c		stz $080c	                STZ SCRATCH
.1a4abf	64 0e		stz $080e	                STZ SCRATCH+2
.1a4ac1	e2 30		sep #$30	            SEP #$30
.1a4ac3	a0 00		ldy #$00	                LDY #0
.1a4ac5	b7 23		lda [$0823],y	skip_loop       LDA [ARGUMENT1],Y
.1a4ac7	c9 20		cmp #$20	                CMP #CHAR_SP
.1a4ac9	f0 04		beq $1a4acf	                BEQ skip_char
.1a4acb	c9 24		cmp #$24	                CMP #'$'
.1a4acd	d0 03		bne $1a4ad2	                BNE loop
.1a4acf	c8		iny		skip_char       INY
.1a4ad0	80 f3		bra $1a4ac5	                BRA skip_loop
.1a4ad2	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y   ; Check the character
.1a4ad4	20 0c 05	jsr $1a050c	            JSR ISHEX
.1a4ad7	90 1e		bcc $1a4af7	                BCC ret_result      ; No: return what we have so far
.1a4ad9	c2 20		rep #$20	            REP #$20
.1a4adb	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a4add	26 0e		rol $080e	                ROL SCRATCH+2
.1a4adf	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a4ae1	26 0e		rol $080e	                ROL SCRATCH+2
.1a4ae3	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a4ae5	26 0e		rol $080e	                ROL SCRATCH+2
.1a4ae7	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a4ae9	26 0e		rol $080e	                ROL SCRATCH+2
.1a4aeb	e2 20		sep #$20	            SEP #$20
.1a4aed	20 2d 05	jsr $1a052d	            JSR HEX2BIN
.1a4af0	05 0c		ora $080c	                ORA SCRATCH
.1a4af2	85 0c		sta $080c	                STA SCRATCH         ; And add it to the result
.1a4af4	c8		iny		                INY
.1a4af5	80 db		bra $1a4ad2	                BRA loop            ; And try the next character
.1a4af7					ret_result
.1a4af7	c2 20		rep #$20	            REP #$20
.1a4af9	a5 0c		lda $080c	                LDA SCRATCH         ; Return the result
.1a4afb	85 23		sta $0823	                STA ARGUMENT1
.1a4afd	a5 0e		lda $080e	                LDA SCRATCH+2
.1a4aff	85 25		sta $0825	                STA ARGUMENT1+2
.1a4b01	e2 20		sep #$20	            SEP #$20
.1a4b03	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a4b05	85 27		sta $0827	                STA ARGTYPE1
.1a4b07	28		plp		                PLP
.1a4b08	e2 20		sep #$20	            SEP #$20
.1a4b0a	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4b0d	60		rts		            RTS
.1a4b0e					FN_HEX
.1a4b0e	e2 20		sep #$20	            SEP #$20
.1a4b10	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4b12	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4b15	08		php		                PHP
.1a4b16	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4b19	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a4b1c	20 01 15	jsr $1a1501	            JSR TEMPSTRING
.1a4b1f	e2 30		sep #$30	            SEP #$30
.1a4b21	a0 ff		ldy #$ff	                LDY #$FF            ; Terminate the string
.1a4b23	a9 00		lda #$00	                LDA #0
.1a4b25	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4b27	88		dey		                DEY
.1a4b28	a5 23		lda $0823	loop            LDA ARGUMENT1       ; Write the low digit
.1a4b2a	29 0f		and #$0f	                AND #$0F
.1a4b2c	aa		tax		                TAX
.1a4b2d	bf 00 d0 1a	lda $1ad000,x	                LDA @lHEXDIGITS,X
.1a4b31	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4b33	88		dey		                DEY
.1a4b34	a5 23		lda $0823	                LDA ARGUMENT1       ; Write the high digit
.1a4b36	29 f0		and #$f0	                AND #$F0
.1a4b38	4a		lsr a		                LSR A
.1a4b39	4a		lsr a		                LSR A
.1a4b3a	4a		lsr a		                LSR A
.1a4b3b	4a		lsr a		                LSR A
.1a4b3c	aa		tax		                TAX
.1a4b3d	bf 00 d0 1a	lda $1ad000,x	                LDA @lHEXDIGITS,X
.1a4b41	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4b43	88		dey		                DEY
.1a4b44	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Shift value by one byte
.1a4b46	85 23		sta $0823	                STA ARGUMENT1
.1a4b48	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4b4a	85 24		sta $0824	                STA ARGUMENT1+1
.1a4b4c	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a4b4e	85 25		sta $0825	                STA ARGUMENT1+2
.1a4b50	a9 00		lda #$00	                LDA #0
.1a4b52	85 26		sta $0826	                STA ARGUMENT1+3
.1a4b54	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the argument 0?
.1a4b56	d0 d0		bne $1a4b28	                BNE loop            ; No: keep converting
.1a4b58	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a4b5a	d0 cc		bne $1a4b28	                BNE loop
.1a4b5c	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4b5e	d0 c8		bne $1a4b28	                BNE loop
.1a4b60	98		tya		                TYA                 ; Get the index of the first free char
.1a4b61	38		sec		                SEC                 ; Add 1 to get to the first character of the string
.1a4b62	65 16		adc $0816	                ADC STRPTR          ; And add the whole thing to the temp string pointer
.1a4b64	85 23		sta $0823	                STA ARGUMENT1       ; And return it as the result
.1a4b66	a5 17		lda $0817	                LDA STRPTR+1
.1a4b68	85 24		sta $0824	                STA ARGUMENT1+1
.1a4b6a	a5 18		lda $0818	                LDA STRPTR+2
.1a4b6c	85 25		sta $0825	                STA ARGUMENT1+2
.1a4b6e	a5 19		lda $0819	                LDA STRPTR+3
.1a4b70	85 26		sta $0826	                STA ARGUMENT1+3
.1a4b72	a9 02		lda #$02	                LDA #TYPE_STRING    ; And make the type STRING
.1a4b74	85 27		sta $0827	                STA ARGTYPE1
.1a4b76	28		plp		                PLP
.1a4b77	e2 20		sep #$20	            SEP #$20
.1a4b79	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4b7c	60		rts		            RTS
.1a4b7d					type_mismatch
.1a4b7d	08		php		            PHP
.1a4b7e	c2 20		rep #$20	            REP #$20
.1a4b80	48		pha		            PHA
.1a4b81	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4b84	5b		tcd		            TCD
.1a4b85	68		pla		            PLA
.1a4b86	28		plp		            PLP
.1a4b87	e2 20		sep #$20	            SEP #$20
.1a4b89	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4b8b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4b8f	c2 20		rep #$20	            REP #$20
.1a4b91	29 ff 00	and #$00ff	            AND #$00FF
.1a4b94	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4b97	e2 20		sep #$20	            SEP #$20
.1a4b99	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4b9c					FN_LEN
.1a4b9c	e2 20		sep #$20	            SEP #$20
.1a4b9e	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4ba0	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4ba3	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4ba6	e2 20		sep #$20	            SEP #$20
.1a4ba8	a5 27		lda $0827	                LDA ARGTYPE1
.1a4baa	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4bac	d0 1f		bne $1a4bcd	                BNE type_mismatch
.1a4bae	8b		phb		                PHB                 ; Set the data bank to the data bank of the string
.1a4baf	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4bb1	48		pha		                PHA
.1a4bb2	ab		plb		                PLB
.1a4bb3	c2 10		rep #$10	            REP #$10
.1a4bb5	a6 23		ldx $0823	                LDX ARGUMENT1       ; And point X to the string data
.1a4bb7	20 ed 15	jsr $1a15ed	            JSR STRLEN
.1a4bba	ab		plb		                PLB                 ; Restore the old data bank
.1a4bbb	84 23		sty $0823	                STY ARGUMENT1       ; Save the length to ARGUMENT1
.1a4bbd	c2 20		rep #$20	            REP #$20
.1a4bbf	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4bc1	e2 20		sep #$20	            SEP #$20
.1a4bc3	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the type to INTEGER
.1a4bc5	85 27		sta $0827	                STA ARGTYPE1
.1a4bc7	e2 20		sep #$20	            SEP #$20
.1a4bc9	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4bcc	60		rts		            RTS
.1a4bcd					type_mismatch
.1a4bcd	08		php		            PHP
.1a4bce	c2 20		rep #$20	            REP #$20
.1a4bd0	48		pha		            PHA
.1a4bd1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4bd4	5b		tcd		            TCD
.1a4bd5	68		pla		            PLA
.1a4bd6	28		plp		            PLP
.1a4bd7	e2 20		sep #$20	            SEP #$20
.1a4bd9	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4bdb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4bdf	c2 20		rep #$20	            REP #$20
.1a4be1	29 ff 00	and #$00ff	            AND #$00FF
.1a4be4	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4be7	e2 20		sep #$20	            SEP #$20
.1a4be9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4bec					FN_PEEK
.1a4bec	e2 20		sep #$20	            SEP #$20
.1a4bee	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4bf0	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4bf3	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4bf6	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a4bf9	e2 20		sep #$20	            SEP #$20
.1a4bfb	a5 25		lda $0825	                LDA ARGUMENT1+2                     ; Check to see if the request is to video memory
.1a4bfd	c9 b0		cmp #$b0	                CMP #`VRAM
.1a4bff	90 10		bcc $1a4c11	                BLT simple_peek                     ; No: just do an ordinary PEEK
.1a4c01	c9 f0		cmp #$f0	                CMP #$F0
.1a4c03	b0 0c		bcs $1a4c11	                BGE simple_peek
.1a4c05	8b		phb		                PHB                                 ; DBR := bank
.1a4c06	48		pha		                PHA
.1a4c07	ab		plb		                PLB
.1a4c08	a6 23		ldx $0823	                LDX ARGUMENT1                       ; X := address
.1a4c0a	22 44 11 00	jsl $001144	                JSL FK_READVRAM                     ; Fetch the low byte
.1a4c0e	ab		plb		                PLB
.1a4c0f	80 04		bra $1a4c15	                BRA save_result
.1a4c11					simple_peek
.1a4c11	e2 20		sep #$20	            SEP #$20
.1a4c13	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.1a4c15	85 23		sta $0823	save_result     STA ARGUMENT1
.1a4c17	64 24		stz $0824	                STZ ARGUMENT1+1
.1a4c19	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4c1b	64 26		stz $0826	                STZ ARGUMENT1+3
.1a4c1d	e2 20		sep #$20	            SEP #$20
.1a4c1f	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4c22	60		rts		            RTS
.1a4c23					type_mismatch
.1a4c23	08		php		            PHP
.1a4c24	c2 20		rep #$20	            REP #$20
.1a4c26	48		pha		            PHA
.1a4c27	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4c2a	5b		tcd		            TCD
.1a4c2b	68		pla		            PLA
.1a4c2c	28		plp		            PLP
.1a4c2d	e2 20		sep #$20	            SEP #$20
.1a4c2f	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4c31	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4c35	c2 20		rep #$20	            REP #$20
.1a4c37	29 ff 00	and #$00ff	            AND #$00FF
.1a4c3a	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4c3d	e2 20		sep #$20	            SEP #$20
.1a4c3f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4c42					FN_PEEKL
.1a4c42	e2 20		sep #$20	            SEP #$20
.1a4c44	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4c46	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4c49	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4c4c	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a4c4f	e2 20		sep #$20	            SEP #$20
.1a4c51	a5 25		lda $0825	                LDA ARGUMENT1+2                     ; Check to see if the request is to video memory
.1a4c53	c9 b0		cmp #$b0	                CMP #`VRAM
.1a4c55	90 22		bcc $1a4c79	                BLT simple_peek                     ; No: just do an ordinary PEEK
.1a4c57	c9 f0		cmp #$f0	                CMP #$F0
.1a4c59	b0 1e		bcs $1a4c79	                BGE simple_peek
.1a4c5b	8b		phb		                PHB                                 ; DBR := bank
.1a4c5c	48		pha		                PHA
.1a4c5d	ab		plb		                PLB
.1a4c5e	a6 23		ldx $0823	                LDX ARGUMENT1                       ; X := address
.1a4c60	da		phx		                PHX
.1a4c61	22 44 11 00	jsl $001144	                JSL FK_READVRAM                     ; Fetch the low byte
.1a4c65	85 0c		sta $080c	                STA SCRATCH                         ; Save the low byte
.1a4c67	fa		plx		                PLX
.1a4c68	e8		inx		                INX
.1a4c69	da		phx		                PHX
.1a4c6a	22 44 11 00	jsl $001144	                JSL FK_READVRAM                     ; Fetch the middle byte
.1a4c6e	85 0d		sta $080d	                STA SCRATCH+1                       ; Save the middle byte
.1a4c70	fa		plx		                PLX
.1a4c71	e8		inx		                INX
.1a4c72	22 44 11 00	jsl $001144	                JSL FK_READVRAM                     ; Fetch the high byte
.1a4c76	ab		plb		                PLB
.1a4c77	80 0d		bra $1a4c86	                BRA save_result
.1a4c79					simple_peek
.1a4c79	c2 20		rep #$20	            REP #$20
.1a4c7b	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.1a4c7d	85 0c		sta $080c	                STA SCRATCH
.1a4c7f	e2 20		sep #$20	            SEP #$20
.1a4c81	a0 02 00	ldy #$0002	                LDY #2
.1a4c84	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y
.1a4c86	85 25		sta $0825	save_result     STA ARGUMENT1+2
.1a4c88	64 26		stz $0826	                STZ ARGUMENT1+3
.1a4c8a	c2 20		rep #$20	            REP #$20
.1a4c8c	a5 0c		lda $080c	                LDA SCRATCH
.1a4c8e	85 23		sta $0823	                STA ARGUMENT1
.1a4c90	e2 20		sep #$20	            SEP #$20
.1a4c92	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4c95	60		rts		            RTS
.1a4c96					type_mismatch
.1a4c96	08		php		            PHP
.1a4c97	c2 20		rep #$20	            REP #$20
.1a4c99	48		pha		            PHA
.1a4c9a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4c9d	5b		tcd		            TCD
.1a4c9e	68		pla		            PLA
.1a4c9f	28		plp		            PLP
.1a4ca0	e2 20		sep #$20	            SEP #$20
.1a4ca2	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4ca4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4ca8	c2 20		rep #$20	            REP #$20
.1a4caa	29 ff 00	and #$00ff	            AND #$00FF
.1a4cad	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4cb0	e2 20		sep #$20	            SEP #$20
.1a4cb2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4cb5					FN_PEEKW
.1a4cb5	e2 20		sep #$20	            SEP #$20
.1a4cb7	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4cb9	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4cbc	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4cbf	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a4cc2	e2 20		sep #$20	            SEP #$20
.1a4cc4	a5 25		lda $0825	                LDA ARGUMENT1+2                     ; Check to see if the request is to video memory
.1a4cc6	c9 b0		cmp #$b0	                CMP #`VRAM
.1a4cc8	90 1d		bcc $1a4ce7	                BLT simple_peek                     ; No: just do an ordinary PEEK
.1a4cca	c9 f0		cmp #$f0	                CMP #$F0
.1a4ccc	b0 19		bcs $1a4ce7	                BGE simple_peek
.1a4cce	8b		phb		                PHB                                 ; DBR := bank
.1a4ccf	48		pha		                PHA
.1a4cd0	ab		plb		                PLB
.1a4cd1	a6 23		ldx $0823	                LDX ARGUMENT1                       ; X := address
.1a4cd3	da		phx		                PHX
.1a4cd4	22 44 11 00	jsl $001144	                JSL FK_READVRAM                     ; Fetch the low byte
.1a4cd8	85 23		sta $0823	                STA ARGUMENT1                       ; Save the low byte
.1a4cda	fa		plx		                PLX
.1a4cdb	e8		inx		                INX
.1a4cdc	22 44 11 00	jsl $001144	                JSL FK_READVRAM                     ; Fetch the high byte
.1a4ce0	85 24		sta $0824	                STA ARGUMENT1+1
.1a4ce2	ab		plb		                PLB
.1a4ce3	c2 20		rep #$20	            REP #$20
.1a4ce5	80 06		bra $1a4ced	                BRA done
.1a4ce7					simple_peek
.1a4ce7	c2 20		rep #$20	            REP #$20
.1a4ce9	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.1a4ceb	85 23		sta $0823	                STA ARGUMENT1
.1a4ced	64 25		stz $0825	done            STZ ARGUMENT1+2
.1a4cef	e2 20		sep #$20	            SEP #$20
.1a4cf1	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4cf4	60		rts		            RTS
.1a4cf5					type_mismatch
.1a4cf5	08		php		            PHP
.1a4cf6	c2 20		rep #$20	            REP #$20
.1a4cf8	48		pha		            PHA
.1a4cf9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4cfc	5b		tcd		            TCD
.1a4cfd	68		pla		            PLA
.1a4cfe	28		plp		            PLP
.1a4cff	e2 20		sep #$20	            SEP #$20
.1a4d01	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4d03	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4d07	c2 20		rep #$20	            REP #$20
.1a4d09	29 ff 00	and #$00ff	            AND #$00FF
.1a4d0c	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4d0f	e2 20		sep #$20	            SEP #$20
.1a4d11	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4d14					FN_CHR
.1a4d14	e2 20		sep #$20	            SEP #$20
.1a4d16	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4d18	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4d1b	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4d1e	e2 20		sep #$20	            SEP #$20
.1a4d20	a5 27		lda $0827	                LDA ARGTYPE1
.1a4d22	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4d24	d0 24		bne $1a4d4a	                BNE type_mismatch
.1a4d26	20 01 15	jsr $1a1501	            JSR TEMPSTRING
.1a4d29	a5 23		lda $0823	                LDA ARGUMENT1       ; Get the numberic value
.1a4d2b	87 16		sta [$0816]	                STA [STRPTR]        ; And save it as the first character
.1a4d2d	a9 00		lda #$00	                LDA #0              ; Null terminate the string
.1a4d2f	a0 01 00	ldy #$0001	                LDY #1
.1a4d32	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4d34	c2 20		rep #$20	            REP #$20
.1a4d36	a5 16		lda $0816	                LDA STRPTR
.1a4d38	85 23		sta $0823	                STA ARGUMENT1
.1a4d3a	a5 18		lda $0818	                LDA STRPTR+2
.1a4d3c	85 25		sta $0825	                STA ARGUMENT1+2
.1a4d3e	e2 20		sep #$20	            SEP #$20
.1a4d40	a9 02		lda #$02	                LDA #TYPE_STRING
.1a4d42	85 27		sta $0827	                STA ARGTYPE1
.1a4d44	e2 20		sep #$20	            SEP #$20
.1a4d46	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4d49	60		rts		            RTS
.1a4d4a					type_mismatch
.1a4d4a	08		php		            PHP
.1a4d4b	c2 20		rep #$20	            REP #$20
.1a4d4d	48		pha		            PHA
.1a4d4e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4d51	5b		tcd		            TCD
.1a4d52	68		pla		            PLA
.1a4d53	28		plp		            PLP
.1a4d54	e2 20		sep #$20	            SEP #$20
.1a4d56	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4d58	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4d5c	c2 20		rep #$20	            REP #$20
.1a4d5e	29 ff 00	and #$00ff	            AND #$00FF
.1a4d61	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4d64	e2 20		sep #$20	            SEP #$20
.1a4d66	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4d69					FN_ASC
.1a4d69	e2 20		sep #$20	            SEP #$20
.1a4d6b	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4d6d	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4d70	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4d73	e2 20		sep #$20	            SEP #$20
.1a4d75	a5 27		lda $0827	                LDA ARGTYPE1
.1a4d77	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4d79	d0 14		bne $1a4d8f	                BNE type_mismatch
.1a4d7b	a7 23		lda [$0823]	                LDA [ARGUMENT1]     ; Get the character
.1a4d7d	85 23		sta $0823	                STA ARGUMENT1       ; Save its code to ARGUMENT1
.1a4d7f	64 24		stz $0824	                STZ ARGUMENT1+1
.1a4d81	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4d83	64 26		stz $0826	                STZ ARGUMENT1+3
.1a4d85	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the return type to integer
.1a4d87	85 27		sta $0827	                STA ARGTYPE1
.1a4d89	e2 20		sep #$20	            SEP #$20
.1a4d8b	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4d8e	60		rts		            RTS
.1a4d8f					type_mismatch
.1a4d8f	08		php		            PHP
.1a4d90	c2 20		rep #$20	            REP #$20
.1a4d92	48		pha		            PHA
.1a4d93	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4d96	5b		tcd		            TCD
.1a4d97	68		pla		            PLA
.1a4d98	28		plp		            PLP
.1a4d99	e2 20		sep #$20	            SEP #$20
.1a4d9b	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4d9d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4da1	c2 20		rep #$20	            REP #$20
.1a4da3	29 ff 00	and #$00ff	            AND #$00FF
.1a4da6	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4da9	e2 20		sep #$20	            SEP #$20
.1a4dab	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4dae					FN_SPC
.1a4dae	e2 20		sep #$20	            SEP #$20
.1a4db0	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4db2	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4db5	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4db8	e2 20		sep #$20	            SEP #$20
.1a4dba	a5 27		lda $0827	                LDA ARGTYPE1
.1a4dbc	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4dbe	d0 39		bne $1a4df9	                BNE type_mismatch
.1a4dc0	e2 20		sep #$20	            SEP #$20
.1a4dc2	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.1a4dc4	d0 52		bne $1a4e18	                BNE err_limit
.1a4dc6	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4dc8	d0 4e		bne $1a4e18	                BNE err_limit
.1a4dca	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a4dcc	d0 4a		bne $1a4e18	                BNE err_limit
.1a4dce	c2 10		rep #$10	            REP #$10
.1a4dd0	20 01 15	jsr $1a1501	            JSR TEMPSTRING
.1a4dd3	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.1a4dd5	e2 20		sep #$20	            SEP #$20
.1a4dd7	a9 00		lda #$00	                LDA #0
.1a4dd9	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.1a4ddb	88		dey		                DEY
.1a4ddc	30 07		bmi $1a4de5	                BMI done
.1a4dde	a9 20		lda #$20	                LDA #CHAR_SP
.1a4de0	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.1a4de2	88		dey		                DEY
.1a4de3	10 fb		bpl $1a4de0	                BPL loop            ; And keep writing until we're done
.1a4de5	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.1a4de7	85 27		sta $0827	                STA ARGTYPE1
.1a4de9	c2 20		rep #$20	            REP #$20
.1a4deb	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.1a4ded	85 23		sta $0823	                STA ARGUMENT1
.1a4def	a5 18		lda $0818	                LDA STRPTR+2
.1a4df1	85 25		sta $0825	                STA ARGUMENT1+2
.1a4df3	e2 20		sep #$20	            SEP #$20
.1a4df5	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4df8	60		rts		            RTS
.1a4df9					type_mismatch
.1a4df9	08		php		            PHP
.1a4dfa	c2 20		rep #$20	            REP #$20
.1a4dfc	48		pha		            PHA
.1a4dfd	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4e00	5b		tcd		            TCD
.1a4e01	68		pla		            PLA
.1a4e02	28		plp		            PLP
.1a4e03	e2 20		sep #$20	            SEP #$20
.1a4e05	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4e07	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4e0b	c2 20		rep #$20	            REP #$20
.1a4e0d	29 ff 00	and #$00ff	            AND #$00FF
.1a4e10	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4e13	e2 20		sep #$20	            SEP #$20
.1a4e15	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4e18					err_limit
.1a4e18	08		php		            PHP
.1a4e19	c2 20		rep #$20	            REP #$20
.1a4e1b	48		pha		            PHA
.1a4e1c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4e1f	5b		tcd		            TCD
.1a4e20	68		pla		            PLA
.1a4e21	28		plp		            PLP
.1a4e22	e2 20		sep #$20	            SEP #$20
.1a4e24	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4e26	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4e2a	c2 20		rep #$20	            REP #$20
.1a4e2c	29 ff 00	and #$00ff	            AND #$00FF
.1a4e2f	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4e32	e2 20		sep #$20	            SEP #$20
.1a4e34	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4e37					FN_TAB
.1a4e37	e2 20		sep #$20	            SEP #$20
.1a4e39	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4e3b	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4e3e	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4e41	e2 20		sep #$20	            SEP #$20
.1a4e43	a5 27		lda $0827	                LDA ARGTYPE1
.1a4e45	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4e47	d0 39		bne $1a4e82	                BNE type_mismatch
.1a4e49	e2 20		sep #$20	            SEP #$20
.1a4e4b	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.1a4e4d	d0 52		bne $1a4ea1	                BNE err_limit
.1a4e4f	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4e51	d0 4e		bne $1a4ea1	                BNE err_limit
.1a4e53	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a4e55	d0 4a		bne $1a4ea1	                BNE err_limit
.1a4e57	c2 10		rep #$10	            REP #$10
.1a4e59	20 01 15	jsr $1a1501	            JSR TEMPSTRING
.1a4e5c	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.1a4e5e	e2 20		sep #$20	            SEP #$20
.1a4e60	a9 00		lda #$00	                LDA #0
.1a4e62	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.1a4e64	88		dey		                DEY
.1a4e65	30 07		bmi $1a4e6e	                BMI done
.1a4e67	a9 09		lda #$09	                LDA #CHAR_TAB
.1a4e69	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.1a4e6b	88		dey		                DEY
.1a4e6c	10 fb		bpl $1a4e69	                BPL loop            ; And keep writing until we're done
.1a4e6e	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.1a4e70	85 27		sta $0827	                STA ARGTYPE1
.1a4e72	c2 20		rep #$20	            REP #$20
.1a4e74	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.1a4e76	85 23		sta $0823	                STA ARGUMENT1
.1a4e78	a5 18		lda $0818	                LDA STRPTR+2
.1a4e7a	85 25		sta $0825	                STA ARGUMENT1+2
.1a4e7c	e2 20		sep #$20	            SEP #$20
.1a4e7e	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4e81	60		rts		            RTS
.1a4e82					type_mismatch
.1a4e82	08		php		            PHP
.1a4e83	c2 20		rep #$20	            REP #$20
.1a4e85	48		pha		            PHA
.1a4e86	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4e89	5b		tcd		            TCD
.1a4e8a	68		pla		            PLA
.1a4e8b	28		plp		            PLP
.1a4e8c	e2 20		sep #$20	            SEP #$20
.1a4e8e	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4e90	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4e94	c2 20		rep #$20	            REP #$20
.1a4e96	29 ff 00	and #$00ff	            AND #$00FF
.1a4e99	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4e9c	e2 20		sep #$20	            SEP #$20
.1a4e9e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4ea1					err_limit
.1a4ea1	08		php		            PHP
.1a4ea2	c2 20		rep #$20	            REP #$20
.1a4ea4	48		pha		            PHA
.1a4ea5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4ea8	5b		tcd		            TCD
.1a4ea9	68		pla		            PLA
.1a4eaa	28		plp		            PLP
.1a4eab	e2 20		sep #$20	            SEP #$20
.1a4ead	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4eaf	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4eb3	c2 20		rep #$20	            REP #$20
.1a4eb5	29 ff 00	and #$00ff	            AND #$00FF
.1a4eb8	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4ebb	e2 20		sep #$20	            SEP #$20
.1a4ebd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4ec0					FN_ABS
.1a4ec0	e2 20		sep #$20	            SEP #$20
.1a4ec2	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4ec4	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4ec7	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4eca	e2 20		sep #$20	            SEP #$20
.1a4ecc	a5 27		lda $0827	                LDA ARGTYPE1        ; Check the type
.1a4ece	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4ed0	f0 23		beq $1a4ef5	                BEQ abs_int         ; If integer, get the absolute value of the integer
.1a4ed2	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.1a4ed4	f0 3e		beq $1a4f14	                BEQ abs_float       ; If float, get the absolute value of the float
.1a4ed6					type_err
.1a4ed6	08		php		            PHP
.1a4ed7	c2 20		rep #$20	            REP #$20
.1a4ed9	48		pha		            PHA
.1a4eda	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4edd	5b		tcd		            TCD
.1a4ede	68		pla		            PLA
.1a4edf	28		plp		            PLP
.1a4ee0	e2 20		sep #$20	            SEP #$20
.1a4ee2	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4ee4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4ee8	c2 20		rep #$20	            REP #$20
.1a4eea	29 ff 00	and #$00ff	            AND #$00FF
.1a4eed	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4ef0	e2 20		sep #$20	            SEP #$20
.1a4ef2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4ef5					abs_int
.1a4ef5	c2 20		rep #$20	            REP #$20
.1a4ef7	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Is it positive already?
.1a4ef9	10 21		bpl $1a4f1c	                BPL done            ; Yes: we don't need to do anythign further
.1a4efb	49 ff ff	eor #$ffff	                EOR #$FFFF          ; Otherwise, take the two's compliment
.1a4efe	85 25		sta $0825	                STA ARGUMENT1+2     ; Of ARGUMENT1
.1a4f00	a5 23		lda $0823	                LDA ARGUMENT1
.1a4f02	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a4f05	18		clc		                CLC
.1a4f06	69 01 00	adc #$0001	                ADC #1
.1a4f09	85 23		sta $0823	                STA ARGUMENT1       ; And save it back to ARGUMENT1
.1a4f0b	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4f0d	69 00 00	adc #$0000	                ADC #0
.1a4f10	85 25		sta $0825	                STA ARGUMENT1+2
.1a4f12	80 08		bra $1a4f1c	                BRA done
.1a4f14					abs_float
.1a4f14	e2 20		sep #$20	            SEP #$20
.1a4f16	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Just clear the sign bit
.1a4f18	29 7f		and #$7f	                AND #$7F
.1a4f1a	85 26		sta $0826	                STA ARGUMENT1+3
.1a4f1c					done
.1a4f1c	e2 20		sep #$20	            SEP #$20
.1a4f1e	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4f21	60		rts		            RTS
.1a4f22					FN_SGN
.1a4f22	e2 20		sep #$20	            SEP #$20
.1a4f24	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4f26	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4f29	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4f2c	e2 20		sep #$20	            SEP #$20
.1a4f2e	a5 27		lda $0827	                LDA ARGTYPE1
.1a4f30	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4f32	d0 25		bne $1a4f59	                BNE type_mismatch
.1a4f34	c2 20		rep #$20	            REP #$20
.1a4f36	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4f38	30 12		bmi $1a4f4c	                BMI is_negative     ; Negative: return -1
.1a4f3a	d0 04		bne $1a4f40	                BNE is_positive     ; Is it not 0? Then return 1
.1a4f3c	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the lower word 0?
.1a4f3e	f0 13		beq $1a4f53	                BEQ done            ; Yes: the whole thing is zero: return 0
.1a4f40	a9 00 00	lda #$0000	is_positive     LDA #0              ; It's positive: return 1
.1a4f43	85 25		sta $0825	                STA ARGUMENT1+2
.1a4f45	a9 01 00	lda #$0001	                LDA #1
.1a4f48	85 23		sta $0823	                STA ARGUMENT1
.1a4f4a	80 07		bra $1a4f53	                BRA done
.1a4f4c	a9 ff ff	lda #$ffff	is_negative     LDA #$FFFF          ; It's negative: return -1
.1a4f4f	85 25		sta $0825	                STA ARGUMENT1+2
.1a4f51	85 23		sta $0823	                STA ARGUMENT1
.1a4f53					done
.1a4f53	e2 20		sep #$20	            SEP #$20
.1a4f55	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4f58	60		rts		            RTS
.1a4f59					type_mismatch
.1a4f59	08		php		            PHP
.1a4f5a	c2 20		rep #$20	            REP #$20
.1a4f5c	48		pha		            PHA
.1a4f5d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4f60	5b		tcd		            TCD
.1a4f61	68		pla		            PLA
.1a4f62	28		plp		            PLP
.1a4f63	e2 20		sep #$20	            SEP #$20
.1a4f65	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4f67	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4f6b	c2 20		rep #$20	            REP #$20
.1a4f6d	29 ff 00	and #$00ff	            AND #$00FF
.1a4f70	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a4f73	e2 20		sep #$20	            SEP #$20
.1a4f75	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4f78					FN_INT
.1a4f78	e2 20		sep #$20	            SEP #$20
.1a4f7a	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4f7c	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4f7f	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4f82	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a4f85					done
.1a4f85	e2 20		sep #$20	            SEP #$20
.1a4f87	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4f8a	60		rts		            RTS
.1a4f8b					FN_SIN
.1a4f8b	e2 20		sep #$20	            SEP #$20
.1a4f8d	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4f8f	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4f92	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4f95	20 bf 07	jsr $1a07bf	            JSR ASS_ARG1_FLOAT
.1a4f98	20 49 62	jsr $1a6249	            JSR FP_SIN
.1a4f9b					done
.1a4f9b	e2 20		sep #$20	            SEP #$20
.1a4f9d	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4fa0	60		rts		            RTS
.1a4fa1					FN_COS
.1a4fa1	e2 20		sep #$20	            SEP #$20
.1a4fa3	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4fa5	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4fa8	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4fab	20 bf 07	jsr $1a07bf	            JSR ASS_ARG1_FLOAT
.1a4fae	20 78 62	jsr $1a6278	            JSR FP_COS
.1a4fb1					done
.1a4fb1	e2 20		sep #$20	            SEP #$20
.1a4fb3	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4fb6	60		rts		            RTS
.1a4fb7					FN_TAN
.1a4fb7	e2 20		sep #$20	            SEP #$20
.1a4fb9	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4fbb	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4fbe	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4fc1	20 bf 07	jsr $1a07bf	            JSR ASS_ARG1_FLOAT
.1a4fc4	20 a7 62	jsr $1a62a7	            JSR FP_TAN
.1a4fc7					done
.1a4fc7	e2 20		sep #$20	            SEP #$20
.1a4fc9	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4fcc	60		rts		            RTS
.1a4fcd					FN_LN
.1a4fcd	e2 20		sep #$20	            SEP #$20
.1a4fcf	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4fd1	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4fd4	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4fd7	20 bf 07	jsr $1a07bf	            JSR ASS_ARG1_FLOAT
.1a4fda	20 d5 62	jsr $1a62d5	            JSR FP_LN
.1a4fdd					done
.1a4fdd	e2 20		sep #$20	            SEP #$20
.1a4fdf	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4fe2	60		rts		            RTS
.1a4fe3					FN_ACOS
.1a4fe3	e2 20		sep #$20	            SEP #$20
.1a4fe5	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4fe7	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a4fea	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a4fed	20 bf 07	jsr $1a07bf	            JSR ASS_ARG1_FLOAT
.1a4ff0	20 fe 63	jsr $1a63fe	            JSR FP_ACOS
.1a4ff3					done
.1a4ff3	e2 20		sep #$20	            SEP #$20
.1a4ff5	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a4ff8	60		rts		            RTS
.1a4ff9					FN_ASIN
.1a4ff9	e2 20		sep #$20	            SEP #$20
.1a4ffb	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4ffd	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a5000	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a5003	20 bf 07	jsr $1a07bf	            JSR ASS_ARG1_FLOAT
.1a5006	20 d4 63	jsr $1a63d4	            JSR FP_ASIN
.1a5009					done
.1a5009	e2 20		sep #$20	            SEP #$20
.1a500b	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a500e	60		rts		            RTS
.1a500f					FN_ATAN
.1a500f	e2 20		sep #$20	            SEP #$20
.1a5011	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a5013	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a5016	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a5019	20 bf 07	jsr $1a07bf	            JSR ASS_ARG1_FLOAT
.1a501c	20 20 64	jsr $1a6420	            JSR FP_ATAN
.1a501f					done
.1a501f	e2 20		sep #$20	            SEP #$20
.1a5021	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a5024	60		rts		            RTS
.1a5025					FN_EXP
.1a5025	e2 20		sep #$20	            SEP #$20
.1a5027	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a5029	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a502c	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a502f	20 bf 07	jsr $1a07bf	            JSR ASS_ARG1_FLOAT
.1a5032	20 b4 64	jsr $1a64b4	            JSR FP_EXP
.1a5035					done
.1a5035	e2 20		sep #$20	            SEP #$20
.1a5037	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a503a	60		rts		            RTS
.1a503b					FN_SQR
.1a503b	e2 20		sep #$20	            SEP #$20
.1a503d	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a503f	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a5042	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a5045	20 bf 07	jsr $1a07bf	            JSR ASS_ARG1_FLOAT
.1a5048	20 36 65	jsr $1a6536	            JSR FP_SQR
.1a504b					done
.1a504b	e2 20		sep #$20	            SEP #$20
.1a504d	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a5050	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\commands.s

.1a5051	00		brk #		CMD_MONITOR     BRK
.1a5052	ea		nop		                NOP
.1a5053	60		rts		            RTS
.1a5054					CMD_NEW
.1a5054	08		php		                PHP
.1a5055	0b		phd		                PHD
.1a5056	08		php		            PHP
.1a5057	c2 20		rep #$20	            REP #$20
.1a5059	48		pha		            PHA
.1a505a	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a505d	5b		tcd		            TCD
.1a505e	68		pla		            PLA
.1a505f	28		plp		            PLP
.1a5060	c2 30		rep #$30	            REP #$30
.1a5062	c2 20		rep #$20	            REP #$20
.1a5064	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.1a5067	85 d9		sta $08d9	            STA LASTLINE
.1a5069	e2 20		sep #$20	            SEP #$20
.1a506b	a9 16		lda #$16	            LDA #`BASIC_BOT
.1a506d	85 db		sta $08db	            STA LASTLINE+2
.1a506f	c2 30		rep #$30	            REP #$30
.1a5071	a9 00 00	lda #$0000	                LDA #0
.1a5074	a0 00 00	ldy #$0000	                LDY #LINE_LINK
.1a5077	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.1a5079	a0 02 00	ldy #$0002	                LDY #LINE_NUMBER
.1a507c	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.1a507e	a0 04 00	ldy #$0004	                LDY #LINE_TOKENS
.1a5081	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.1a5083	20 f3 20	jsr $1a20f3	            JSR CLRINTERP
.1a5086	2b		pld		                PLD
.1a5087	28		plp		                PLP
.1a5088	60		rts		            RTS
.1a5089					CMD_RUN
.1a5089	8b		phb		                PHB
.1a508a	08		php		                PHP
.1a508b	c2 20		rep #$20	            REP #$20
.1a508d	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT            ; Point to the first line of the program
.1a5090	85 1a		sta $081a	                STA CURLINE
.1a5092	a9 16 00	lda #$0016	                LDA #`BASIC_BOT
.1a5095	85 1c		sta $081c	                STA CURLINE + 2
.1a5097	20 f3 20	jsr $1a20f3	            JSR CLRINTERP
.1a509a	20 d3 23	jsr $1a23d3	            JSR EXECPROGRAM
.1a509d	28		plp		                PLP
.1a509e	ab		plb		                PLB
.1a509f	60		rts		            RTS
.1a50a0					CMD_LIST
.1a50a0	08		php		                PHP
.1a50a1	c2 20		rep #$20	            REP #$20
.1a50a3	64 55		stz $0855	                STZ MARG1               ; MARG1 is starting line number, default 0
.1a50a5	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.1a50a8	85 59		sta $0859	                STA MARG2               ; MARG2 is ending line number, default MAXINT
.1a50aa	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a50ad	20 7e 22	jsr $1a227e	            JSR PEEK_TOK
.1a50b0	29 ff 00	and #$00ff	                AND #$00FF
.1a50b3	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.1a50b6	f0 2c		beq $1a50e4	                BEQ call_list           ; ... just list with the defaults
.1a50b8	c9 81 00	cmp #$0081	                CMP #TOK_MINUS          ; If just "- ###"...
.1a50bb	f0 1a		beq $1a50d7	                BEQ parse_endline       ; ... try to parse the end line number
.1a50bd	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a50c0	20 d8 08	jsr $1a08d8	            JSR PARSEINT
.1a50c3	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG1
.1a50c5	85 55		sta $0855	                STA MARG1
.1a50c7	20 7e 22	jsr $1a227e	            JSR PEEK_TOK
.1a50ca	29 ff 00	and #$00ff	                AND #$00FF
.1a50cd	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.1a50d0	f0 12		beq $1a50e4	                BEQ call_list           ; ... just list with the defaults
.1a50d2	c9 81 00	cmp #$0081	                CMP #TOK_MINUS
.1a50d5	d0 2a		bne $1a5101	                BNE error               ; At this point, if not '-', it's a syntax error
.1a50d7					parse_endline
.1a50d7	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a50da	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a50dd	20 d8 08	jsr $1a08d8	            JSR PARSEINT
.1a50e0	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG2
.1a50e2	85 59		sta $0859	                STA MARG2
.1a50e4	a5 1c		lda $081c	call_list       LDA CURLINE+2           ; Save CURLINE
.1a50e6	48		pha		                PHA
.1a50e7	a5 1a		lda $081a	                LDA CURLINE
.1a50e9	48		pha		                PHA
.1a50ea	a5 02		lda $0802	                LDA BIP+2               ; Save BIP
.1a50ec	48		pha		                PHA
.1a50ed	a5 00		lda $0800	                LDA BIP
.1a50ef	48		pha		                PHA
.1a50f0	20 8b 18	jsr $1a188b	            JSR LISTPROG
.1a50f3	68		pla		                PLA
.1a50f4	85 00		sta $0800	                STA BIP
.1a50f6	68		pla		                PLA
.1a50f7	85 02		sta $0802	                STA BIP+2
.1a50f9	68		pla		                PLA
.1a50fa	85 1a		sta $081a	                STA CURLINE
.1a50fc	68		pla		                PLA
.1a50fd	85 1c		sta $081c	                STA CURLINE+2
.1a50ff	28		plp		                PLP
.1a5100	60		rts		            RTS
.1a5101					error
.1a5101	08		php		            PHP
.1a5102	c2 20		rep #$20	            REP #$20
.1a5104	48		pha		            PHA
.1a5105	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5108	5b		tcd		            TCD
.1a5109	68		pla		            PLA
.1a510a	28		plp		            PLP
.1a510b	e2 20		sep #$20	            SEP #$20
.1a510d	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a510f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5113	c2 20		rep #$20	            REP #$20
.1a5115	29 ff 00	and #$00ff	            AND #$00FF
.1a5118	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a511b	e2 20		sep #$20	            SEP #$20
.1a511d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]

;******  Return to file: src\basic816.s


;******  Processing file: src\variables.s

>08e1					NEXTVAR         .long ?         ; Pointer to the the next available byte for variable bindings
>08e4					VARIABLES       .long ?         ; Pointer to the most recently allocated variable
>08e7					TOFIND          .long ?         ; Pointer to the variable name to find
>08ea					TOFINDTYPE      .byte ?         ; The type to find
.0000					BINDING
>0000					TYPE            .fill 1                 ; The type of the data stored in the variable
>0001					NAME            .fill VAR_NAME_SIZE     ; The name of the variable
>0009					VALUE           .fill 4                 ; The data stored in the variable
>000d					NEXT            .fill 3                 ; The pointer to the next allocated variable of this type
.1a5120					INITVARS
.1a5120	08		php		                PHP
.1a5121	08		php		            PHP
.1a5122	c2 20		rep #$20	            REP #$20
.1a5124	48		pha		            PHA
.1a5125	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5128	5b		tcd		            TCD
.1a5129	68		pla		            PLA
.1a512a	28		plp		            PLP
.1a512b	c2 20		rep #$20	            REP #$20
.1a512d	64 e4		stz $08e4	                STZ VARIABLES           ; Clear the pointer to the variables
.1a512f	64 e7		stz $08e7	                STZ TOFIND
.1a5131	e2 20		sep #$20	            SEP #$20
.1a5133	64 e6		stz $08e6	                STZ VARIABLES+2
.1a5135	64 e9		stz $08e9	                STZ TOFIND+2
.1a5137	64 ea		stz $08ea	                STZ TOFINDTYPE
.1a5139	c2 20		rep #$20	            REP #$20
.1a513b	38		sec		                SEC                     ; Compute the position of the first variable
.1a513c	a5 d9		lda $08d9	                LDA LASTLINE
.1a513e	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.1a5141	85 e1		sta $08e1	                STA NEXTVAR
.1a5143	e2 20		sep #$20	            SEP #$20
.1a5145	a5 db		lda $08db	                LDA LASTLINE+2
.1a5147	69 00		adc #$00	                ADC #0
.1a5149	85 e3		sta $08e3	                STA NEXTVAR+2
.1a514b	28		plp		                PLP
.1a514c	60		rts		            RTS
.1a514d					ISVARCHAR
.1a514d	c9 5f		cmp #$5f	                CMP #'_'            ; Check if it's an underscore
.1a514f	f0 1a		beq $1a516b	                BEQ return_true     ; Yes: return true
.1a5151	c9 3a		cmp #$3a	                CMP #'9'+1          ; Check if its in [0-9]
.1a5153	b0 04		bcs $1a5159	                BGE else1           ; No: check something else
.1a5155	c9 30		cmp #$30	                CMP #'0'
.1a5157	b0 12		bcs $1a516b	                BGE return_true     ; Yes: return true
.1a5159	c9 5b		cmp #$5b	else1           CMP #'Z'+1          ; Check if its in [A-Z]
.1a515b	b0 04		bcs $1a5161	                BGE not_upper       ; No: check lower case
.1a515d	c9 41		cmp #$41	                CMP #'A'
.1a515f	b0 0a		bcs $1a516b	                BGE return_true     ; Yes: return true
.1a5161	c9 7b		cmp #$7b	not_upper       CMP #'z'+1          ; Check if its in [a-z]
.1a5163	b0 04		bcs $1a5169	                BGE return_false    ; No: return false
.1a5165	c9 61		cmp #$61	                CMP #'a'
.1a5167	b0 02		bcs $1a516b	                BGE return_true     ; Yes: return true
.1a5169	18		clc		return_false    CLC
.1a516a	60		rts		            RTS
.1a516b	38		sec		return_true     SEC
.1a516c	60		rts		            RTS
.1a516d					VARNAMECMP
.1a516d	08		php		                PHP
.1a516e	e2 20		sep #$20	            SEP #$20
.1a5170	c2 10		rep #$10	            REP #$10
.1a5172	a0 00 00	ldy #$0000	                LDY #0
.1a5175	b7 0c		lda [$080c],y	cmp_loop        LDA [SCRATCH],Y         ; Check the character in the variable name
.1a5177	f0 0a		beq $1a5183	                BEQ is_end
.1a5179	d7 e7		cmp [$08e7],y	                CMP [TOFIND],Y          ; Compare the character to the one TOFIND
.1a517b	d0 13		bne $1a5190	                BNE return_false        ; Not equal? Then this is not a match
.1a517d	c8		iny		                INY
.1a517e	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.1a5181	d0 f2		bne $1a5175	                BNE cmp_loop
.1a5183	b7 e7		lda [$08e7],y	is_end          LDA [TOFIND],Y          ; Check the character in the name to find
.1a5185	20 56 05	jsr $1a0556	            JSR TOUPPERA
.1a5188	20 4d 51	jsr $1a514d	            JSR ISVARCHAR
.1a518b	b0 03		bcs $1a5190	                BCS return_false        ; YES: we do not have a match
.1a518d					return_true
.1a518d	28		plp		                PLP
.1a518e	38		sec		                SEC
.1a518f	60		rts		            RTS
.1a5190					return_false
.1a5190	28		plp		                PLP
.1a5191	18		clc		                CLC
.1a5192	60		rts		            RTS
.1a5193					VAR_FIND
.1a5193	08		php		                PHP
.1a5194	e2 20		sep #$20	            SEP #$20
.1a5196	c2 10		rep #$10	            REP #$10
.1a5198	a0 00 00	ldy #$0000	                LDY #0
.1a519b	a2 00 00	ldx #$0000	                LDX #0
.1a519e	b7 e7		lda [$08e7],y	upper_loop      LDA [TOFIND],Y          ; Get a character
.1a51a0	f0 0b		beq $1a51ad	                BEQ done_upper
.1a51a2	20 56 05	jsr $1a0556	            JSR TOUPPERA
.1a51a5	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; And save it to the temp
.1a51a9	c8		iny		                INY
.1a51aa	e8		inx		                INX
.1a51ab	80 f1		bra $1a519e	                BRA upper_loop          ; Go back for another
.1a51ad	a9 00		lda #$00	done_upper      LDA #0
.1a51af	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; NULL terminate the temporary string
.1a51b3	c2 20		rep #$20	            REP #$20
.1a51b5	a9 00 4e	lda #$4e00	                LDA #<>TEMPBUF          ; Make the temporary string the string
.1a51b8	85 e7		sta $08e7	                STA TOFIND              ; the variable name to find
.1a51ba	e2 20		sep #$20	            SEP #$20
.1a51bc	a9 00		lda #$00	                LDA #`TEMPBUF
.1a51be	85 e9		sta $08e9	                STA TOFIND+2
.1a51c0	c2 20		rep #$20	            REP #$20
.1a51c2	a5 e4		lda $08e4	                LDA VARIABLES           ; Point INDEX to the first variable to check
.1a51c4	85 08		sta $0808	                STA INDEX
.1a51c6	d0 06		bne $1a51ce	                BNE set_index_h         ; If the low word is not 0, copy the high byte
.1a51c8	e2 20		sep #$20	            SEP #$20
.1a51ca	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a51cc	f0 4d		beq $1a521b	                BEQ not_found           ; If it is, we have no variables yet.
.1a51ce					set_index_h
.1a51ce	e2 20		sep #$20	            SEP #$20
.1a51d0	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a51d2	85 0a		sta $080a	                STA INDEX+2
.1a51d4	a5 ea		lda $08ea	check_binding   LDA TOFINDTYPE
.1a51d6	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Get the type of the variable
.1a51d9	d7 08		cmp [$0808],y	                CMP [INDEX],Y
.1a51db	d0 17		bne $1a51f4	                BNE check_next          ; If it's not a match, check the next binding
.1a51dd	c2 20		rep #$20	            REP #$20
.1a51df	18		clc		                CLC
.1a51e0	a5 08		lda $0808	                LDA INDEX
.1a51e2	69 01 00	adc #$0001	                ADC #BINDING.NAME
.1a51e5	85 0c		sta $080c	                STA SCRATCH
.1a51e7	e2 20		sep #$20	            SEP #$20
.1a51e9	a5 0a		lda $080a	                LDA INDEX+2
.1a51eb	69 00		adc #$00	                ADC #0
.1a51ed	85 0e		sta $080e	                STA SCRATCH+2
.1a51ef	20 6d 51	jsr $1a516d	            JSR VARNAMECMP
.1a51f2	b0 2a		bcs $1a521e	                BCS found               ; If they match, return that we've found the variable
.1a51f4	a0 0d 00	ldy #$000d	check_next      LDY #BINDING.NEXT       ; SCRATCH := [INDEX].NEXT
.1a51f7	c2 20		rep #$20	            REP #$20
.1a51f9	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a51fb	85 0c		sta $080c	                STA SCRATCH
.1a51fd	c8		iny		                INY
.1a51fe	c8		iny		                INY
.1a51ff	e2 20		sep #$20	            SEP #$20
.1a5201	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a5203	85 0e		sta $080e	                STA SCRATCH+2
.1a5205	d0 06		bne $1a520d	                BNE set_index           ; If SCRATCH == 0, the variable wasn't found
.1a5207	c2 20		rep #$20	            REP #$20
.1a5209	a5 0c		lda $080c	                LDA SCRATCH
.1a520b	f0 0e		beq $1a521b	                BEQ not_found
.1a520d					set_index
.1a520d	c2 20		rep #$20	            REP #$20
.1a520f	a5 0c		lda $080c	                LDA SCRATCH
.1a5211	85 08		sta $0808	                STA INDEX
.1a5213	e2 20		sep #$20	            SEP #$20
.1a5215	a5 0e		lda $080e	                LDA SCRATCH+2
.1a5217	85 0a		sta $080a	                STA INDEX+2
.1a5219	80 b9		bra $1a51d4	                BRA check_binding       ; And check this next variable for a match
.1a521b					not_found
.1a521b	28		plp		                PLP
.1a521c	18		clc		                CLC
.1a521d	60		rts		            RTS
.1a521e					found
.1a521e	28		plp		                PLP
.1a521f	38		sec		                SEC
.1a5220	60		rts		            RTS
.1a5221					VAR_REF
.1a5221	08		php		                PHP
.1a5222	20 93 51	jsr $1a5193	            JSR VAR_FIND
.1a5225	b0 1f		bcs $1a5246	                BCS found
.1a5227	08		php		            PHP
.1a5228	c2 20		rep #$20	            REP #$20
.1a522a	48		pha		            PHA
.1a522b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a522e	5b		tcd		            TCD
.1a522f	68		pla		            PLA
.1a5230	28		plp		            PLP
.1a5231	e2 20		sep #$20	            SEP #$20
.1a5233	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a5235	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5239	c2 20		rep #$20	            REP #$20
.1a523b	29 ff 00	and #$00ff	            AND #$00FF
.1a523e	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a5241	e2 20		sep #$20	            SEP #$20
.1a5243	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5246					found
.1a5246	c2 30		rep #$30	            REP #$30
.1a5248	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.1a524b	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a524d	85 23		sta $0823	                STA ARGUMENT1
.1a524f	c8		iny		                INY
.1a5250	c8		iny		                INY
.1a5251	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a5253	85 25		sta $0825	                STA ARGUMENT1+2
.1a5255	e2 20		sep #$20	            SEP #$20
.1a5257	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE
.1a525a	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a525c	85 27		sta $0827	                STA ARGTYPE1
.1a525e	28		plp		done            PLP
.1a525f	60		rts		            RTS
.1a5260					VAR_ALLOC
.1a5260	08		php		                PHP
.1a5261	c2 20		rep #$20	            REP #$20
.1a5263	18		clc		                CLC                     ; Compute extent of the binding
.1a5264	a5 e1		lda $08e1	                LDA NEXTVAR
.1a5266	69 10 00	adc #$0010	                ADC #size(BINDING)
.1a5269	85 08		sta $0808	                STA INDEX
.1a526b	e2 20		sep #$20	            SEP #$20
.1a526d	a5 e3		lda $08e3	                LDA NEXTVAR+2
.1a526f	69 00		adc #$00	                ADC #0
.1a5271	85 0a		sta $080a	                STA INDEX+2
.1a5273	c5 bc		cmp $08bc	                CMP HEAP+2              ; Check to see if HEAP > INDEX
.1a5275	90 27		bcc $1a529e	                BLT has_room
.1a5277	c2 20		rep #$20	            REP #$20
.1a5279	a5 08		lda $0808	                LDA INDEX
.1a527b	c5 ba		cmp $08ba	                CMP HEAP
.1a527d	90 1f		bcc $1a529e	                BLT has_room
.1a527f	08		php		            PHP
.1a5280	c2 20		rep #$20	            REP #$20
.1a5282	48		pha		            PHA
.1a5283	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5286	5b		tcd		            TCD
.1a5287	68		pla		            PLA
.1a5288	28		plp		            PLP
.1a5289	e2 20		sep #$20	            SEP #$20
.1a528b	a9 09		lda #$09	            LDA #ERR_RANGE
.1a528d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5291	c2 20		rep #$20	            REP #$20
.1a5293	29 ff 00	and #$00ff	            AND #$00FF
.1a5296	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a5299	e2 20		sep #$20	            SEP #$20
.1a529b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a529e					has_room
.1a529e	c2 20		rep #$20	            REP #$20
.1a52a0	a5 e1		lda $08e1	                LDA NEXTVAR             ; Yes: we can allocate the variable
.1a52a2	85 c0		sta $08c0	                STA CURRBLOCK           ; Point CURRBLOCK to it
.1a52a4	e2 20		sep #$20	            SEP #$20
.1a52a6	a5 e3		lda $08e3	                LDA NEXTVAR+2
.1a52a8	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a52aa	c2 20		rep #$20	            REP #$20
.1a52ac	a5 08		lda $0808	                LDA INDEX               ; And point NEXTVAR to the next possible spot
.1a52ae	85 e1		sta $08e1	                STA NEXTVAR
.1a52b0	e2 20		sep #$20	            SEP #$20
.1a52b2	a5 0a		lda $080a	                LDA INDEX+2
.1a52b4	85 e3		sta $08e3	                STA NEXTVAR+2
.1a52b6	28		plp		                PLP
.1a52b7	60		rts		            RTS
.1a52b8					VAR_CREATE
.1a52b8	08		php		                PHP
.1a52b9	e2 20		sep #$20	            SEP #$20
.1a52bb	a5 27		lda $0827	                LDA ARGTYPE1            ; Validate that our types match
.1a52bd	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.1a52bf	f0 33		beq $1a52f4	                BEQ chk_string          ; If so: check to see if it's a string
.1a52c1	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable type
.1a52c3	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's INTEGER
.1a52c5	d0 05		bne $1a52cc	                BNE chk_float
.1a52c7	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a52ca	80 2f		bra $1a52fb	                BRA alloc_binding       ; And bind the variable
.1a52cc	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; If it's FLOAT
.1a52ce	d0 05		bne $1a52d5	                BNE type_error
.1a52d0	20 bf 07	jsr $1a07bf	            JSR ASS_ARG1_FLOAT
.1a52d3	80 26		bra $1a52fb	                BRA alloc_binding       ; And bind the variable
.1a52d5					type_error
.1a52d5	08		php		            PHP
.1a52d6	c2 20		rep #$20	            REP #$20
.1a52d8	48		pha		            PHA
.1a52d9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a52dc	5b		tcd		            TCD
.1a52dd	68		pla		            PLA
.1a52de	28		plp		            PLP
.1a52df	e2 20		sep #$20	            SEP #$20
.1a52e1	a9 04		lda #$04	            LDA #ERR_TYPE
.1a52e3	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a52e7	c2 20		rep #$20	            REP #$20
.1a52e9	29 ff 00	and #$00ff	            AND #$00FF
.1a52ec	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a52ef	e2 20		sep #$20	            SEP #$20
.1a52f1	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a52f4	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING        ; Is it a string?
.1a52f6	d0 03		bne $1a52fb	                BNE alloc_binding       ; No: just go ahead and bind it
.1a52f8	20 f3 16	jsr $1a16f3	            JSR STRCPY
.1a52fb					alloc_binding
.1a52fb	c2 10		rep #$10	            REP #$10
.1a52fd	20 60 52	jsr $1a5260	            JSR VAR_ALLOC
.1a5300	c2 30		rep #$30	            REP #$30
.1a5302	18		clc		                CLC
.1a5303	a5 c0		lda $08c0	                LDA CURRBLOCK
.1a5305	69 01 00	adc #$0001	                ADC #BINDING.NAME
.1a5308	85 08		sta $0808	                STA INDEX
.1a530a	e2 20		sep #$20	            SEP #$20
.1a530c	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a530e	69 00		adc #$00	                ADC #0
.1a5310	85 0a		sta $080a	                STA INDEX+2
.1a5312	a0 00 00	ldy #$0000	                LDY #0                  ; Ensure that the name field is blank
.1a5315	a9 00		lda #$00	                LDA #0
.1a5317	97 08		sta [$0808],y	blank_loop      STA [INDEX],Y
.1a5319	c8		iny		                INY
.1a531a	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.1a531d	d0 f8		bne $1a5317	                BNE blank_loop
.1a531f	a0 00 00	ldy #$0000	                LDY #0
.1a5322	b7 e7		lda [$08e7],y	name_loop       LDA [TOFIND],Y          ; Copy TOFIND to the NAME field
.1a5324	f0 10		beq $1a5336	                BEQ set_type
.1a5326	20 56 05	jsr $1a0556	            JSR TOUPPERA
.1a5329	20 4d 51	jsr $1a514d	            JSR ISVARCHAR
.1a532c	90 08		bcc $1a5336	                BCC set_type
.1a532e	97 08		sta [$0808],y	                STA [INDEX],Y
.1a5330	c8		iny		                INY
.1a5331	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.1a5334	d0 ec		bne $1a5322	                BNE name_loop
.1a5336					set_type
.1a5336	c2 20		rep #$20	            REP #$20
.1a5338	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE      ; Copy the value to the variable
.1a533b	a5 23		lda $0823	                LDA ARGUMENT1
.1a533d	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a533f	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5341	c8		iny		                INY
.1a5342	c8		iny		                INY
.1a5343	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a5345	a5 e4		lda $08e4	                LDA VARIABLES           ; Point NEXT to the current top of variables
.1a5347	a0 0d 00	ldy #$000d	                LDY #BINDING.NEXT
.1a534a	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a534c	c8		iny		                INY
.1a534d	c8		iny		                INY
.1a534e	e2 20		sep #$20	            SEP #$20
.1a5350	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a5352	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a5354	c2 20		rep #$20	            REP #$20
.1a5356	a5 c0		lda $08c0	                LDA CURRBLOCK
.1a5358	85 e4		sta $08e4	                STA VARIABLES
.1a535a	e2 20		sep #$20	            SEP #$20
.1a535c	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a535e	85 e6		sta $08e6	                STA VARIABLES+2
.1a5360	e2 20		sep #$20	            SEP #$20
.1a5362	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Set the type of the variable
.1a5365	a5 27		lda $0827	                LDA ARGTYPE1
.1a5367	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a5369	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is it a string?
.1a536b	f0 02		beq $1a536f	                BEQ set_ref             ; Yes: add a reference count to it
.1a536d	28		plp		done            PLP
.1a536e	60		rts		            RTS
.1a536f					set_ref
.1a536f	c2 20		rep #$20	            REP #$20
.1a5371	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the a heap allocated value
.1a5373	85 c0		sta $08c0	                STA CURRBLOCK
.1a5375	e2 20		sep #$20	            SEP #$20
.1a5377	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5379	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a537b	20 0f 13	jsr $1a130f	            JSR HEAP_GETHED
.1a537e	20 24 13	jsr $1a1324	            JSR HEAP_ADDREF
.1a5381	80 ea		bra $1a536d	                BRA done
.1a5383					VAR_SET
.1a5383	08		php		                PHP
.1a5384	c2 30		rep #$30	            REP #$30
.1a5386	a5 e4		lda $08e4	                LDA VARIABLES          ; If VARIABLES = 0, use VAR_CREATE
.1a5388	d0 06		bne $1a5390	                BNE use_find
.1a538a	e2 20		sep #$20	            SEP #$20
.1a538c	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a538e	f0 05		beq $1a5395	                BEQ use_create
.1a5390					use_find
.1a5390	20 93 51	jsr $1a5193	            JSR VAR_FIND
.1a5393	b0 05		bcs $1a539a	                BCS found
.1a5395					use_create
.1a5395	20 b8 52	jsr $1a52b8	            JSR VAR_CREATE
.1a5398	80 4e		bra $1a53e8	                BRA done
.1a539a					found
.1a539a	e2 20		sep #$20	            SEP #$20
.1a539c	a5 27		lda $0827	                LDA ARGTYPE1            ; Do the types match?
.1a539e	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.1a53a0	f0 33		beq $1a53d5	                BEQ chk_string          ; Yes: check to see if it's string
.1a53a2	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable
.1a53a4	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; Is it INTEGER?
.1a53a6	d0 05		bne $1a53ad	                BNE chk_float
.1a53a8	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a53ab	80 2c		bra $1a53d9	                BRA set_val
.1a53ad	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; Is it FLOAT?
.1a53af	d0 05		bne $1a53b6	                BNE type_error          ; No: throw an error
.1a53b1	20 bf 07	jsr $1a07bf	            JSR ASS_ARG1_FLOAT
.1a53b4	80 23		bra $1a53d9	                BRA set_val
.1a53b6					type_error
.1a53b6	08		php		            PHP
.1a53b7	c2 20		rep #$20	            REP #$20
.1a53b9	48		pha		            PHA
.1a53ba	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a53bd	5b		tcd		            TCD
.1a53be	68		pla		            PLA
.1a53bf	28		plp		            PLP
.1a53c0	e2 20		sep #$20	            SEP #$20
.1a53c2	a9 04		lda #$04	            LDA #ERR_TYPE
.1a53c4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a53c8	c2 20		rep #$20	            REP #$20
.1a53ca	29 ff 00	and #$00ff	            AND #$00FF
.1a53cd	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a53d0	e2 20		sep #$20	            SEP #$20
.1a53d2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a53d5	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING
.1a53d7	f0 11		beq $1a53ea	                BEQ set_string          ; Yes: set the string value of the variable
.1a53d9					set_val
.1a53d9	c2 30		rep #$30	            REP #$30
.1a53db	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.1a53de	a5 23		lda $0823	                LDA ARGUMENT1
.1a53e0	97 08		sta [$0808],y	                STA [INDEX],Y
.1a53e2	c8		iny		                INY
.1a53e3	c8		iny		                INY
.1a53e4	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a53e6	97 08		sta [$0808],y	                STA [INDEX],Y
.1a53e8					done
.1a53e8	28		plp		                PLP
.1a53e9	60		rts		            RTS
.1a53ea					set_string
.1a53ea	20 f3 16	jsr $1a16f3	            JSR STRCPY
.1a53ed	a0 09 00	ldy #$0009	set_ref         LDY #BINDING.VALUE      ; Set CURRBLOCK to the current string value
.1a53f0	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a53f2	85 c0		sta $08c0	                STA CURRBLOCK
.1a53f4	c8		iny		                INY
.1a53f5	c8		iny		                INY
.1a53f6	e2 20		sep #$20	            SEP #$20
.1a53f8	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a53fa	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a53fc	20 0f 13	jsr $1a130f	            JSR HEAP_GETHED
.1a53ff	20 43 13	jsr $1a1343	            JSR HEAP_REMREF
.1a5402	e2 20		sep #$20	            SEP #$20
.1a5404	a5 27		lda $0827	                LDA ARGTYPE1
.1a5406	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is the new value a string?
.1a5408	f0 02		beq $1a540c	                BEQ add_ref             ; Yes: add a reference to it
.1a540a	80 cd		bra $1a53d9	                BRA set_val             ; No: go back to set the value... this probably shouldn't happen
.1a540c					add_ref
.1a540c	c2 20		rep #$20	            REP #$20
.1a540e	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the new string value
.1a5410	85 c0		sta $08c0	                STA CURRBLOCK
.1a5412	e2 20		sep #$20	            SEP #$20
.1a5414	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5416	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a5418	20 0f 13	jsr $1a130f	            JSR HEAP_GETHED
.1a541b	20 24 13	jsr $1a1324	            JSR HEAP_ADDREF
.1a541e	80 b9		bra $1a53d9	                BRA set_val
.1a5420					VAR_FINDNAME
.1a5420	08		php		                PHP
.1a5421	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a5424	e2 20		sep #$20	            SEP #$20
.1a5426	a7 00		lda [$0800]	                LDA [BIP]           ; Get the first character
.1a5428	20 e2 04	jsr $1a04e2	            JSR ISALPHA
.1a542b	90 42		bcc $1a546f	                BCC not_found
.1a542d	c2 20		rep #$20	            REP #$20
.1a542f	a5 00		lda $0800	                LDA BIP
.1a5431	85 e7		sta $08e7	                STA TOFIND
.1a5433	e2 20		sep #$20	            SEP #$20
.1a5435	a5 02		lda $0802	                LDA BIP+2
.1a5437	85 e9		sta $08e9	                STA TOFIND+2
.1a5439					loop
.1a5439	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a543c	a7 00		lda [$0800]	                LDA [BIP]
.1a543e	f0 0d		beq $1a544d	                BEQ is_float        ; If it's EOL, the variable is a float
.1a5440	c9 24		cmp #$24	                CMP #'$'            ; If it's $, the variable is a string
.1a5442	f0 14		beq $1a5458	                BEQ is_string
.1a5444	c9 25		cmp #$25	                CMP #'%'            ; If it's %, the variable is an integer
.1a5446	f0 09		beq $1a5451	                BEQ is_integer
.1a5448	20 4d 51	jsr $1a514d	            JSR ISVARCHAR
.1a544b	b0 ec		bcs $1a5439	                BCS loop            ; Check the next one
.1a544d	a9 01		lda #$01	is_float        LDA #TYPE_FLOAT     ; Otherwise it's a float
.1a544f	80 0c		bra $1a545d	                BRA set_type
.1a5451					is_integer
.1a5451	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a5454	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a5456	80 05		bra $1a545d	                BRA set_type
.1a5458					is_string
.1a5458	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a545b	a9 02		lda #$02	                LDA #TYPE_STRING
.1a545d	85 ea		sta $08ea	set_type        STA TOFINDTYPE
.1a545f	20 7e 22	jsr $1a227e	            JSR PEEK_TOK
.1a5462	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it "("?
.1a5464	d0 06		bne $1a546c	                BNE done            ; No: we're done... it's just a scalar variable
.1a5466	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Yes: this is an array reference
.1a5468	09 80		ora #$80	                ORA #$80            ; ... turn on the "Array of..." bit
.1a546a	85 ea		sta $08ea	                STA TOFINDTYPE
.1a546c					done
.1a546c	28		plp		                PLP
.1a546d	38		sec		                SEC
.1a546e	60		rts		            RTS
.1a546f	28		plp		not_found       PLP
.1a5470	18		clc		                CLC
.1a5471	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\integers.s

.1a5472					OP_INT_ADD
.1a5472	08		php		            PHP
.1a5473	c2 20		rep #$20	            REP #$20
.1a5475	18		clc		            CLC
.1a5476	a5 23		lda $0823	            LDA ARGUMENT1
.1a5478	65 29		adc $0829	            ADC ARGUMENT2
.1a547a	85 23		sta $0823	            STA ARGUMENT1
.1a547c	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a547e	65 2b		adc $082b	            ADC ARGUMENT2+2
.1a5480	85 25		sta $0825	            STA ARGUMENT1+2
.1a5482	28		plp		            PLP
.1a5483	60		rts		            RTS
.1a5484					OP_INT_SUB
.1a5484	08		php		            PHP
.1a5485	c2 20		rep #$20	            REP #$20
.1a5487	38		sec		            SEC
.1a5488	a5 23		lda $0823	            LDA ARGUMENT1
.1a548a	e5 29		sbc $0829	            SBC ARGUMENT2
.1a548c	85 23		sta $0823	            STA ARGUMENT1
.1a548e	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5490	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.1a5492	85 25		sta $0825	            STA ARGUMENT1+2
.1a5494	28		plp		            PLP
.1a5495	60		rts		            RTS
.1a5496					OP_INT_MUL
.1a5496	08		php		            PHP
.1a5497					locals
>0001					L_SIGN      .word ?
>0003					L_RESULT    .dword ?
>0007					            .dword ?
.1a5497	c2 20		rep #$20	            REP #$20
.1a5499	3b		tsc		            TSC
.1a549a	38		sec		            SEC
.1a549b	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.1a549e	1b		tcs		            TCS
.1a549f	c2 30		rep #$30	            REP #$30
.1a54a1	a9 00 00	lda #$0000	            LDA #0                  ; Start by assuming positive numbers
.1a54a4	83 01		sta $01,s	            STA L_SIGN
.1a54a6	83 03		sta $03,s	            STA L_RESULT            ; Clear result
.1a54a8	83 05		sta $05,s	            STA L_RESULT+2
.1a54aa	83 07		sta $07,s	            STA L_RESULT+4
.1a54ac	83 09		sta $09,s	            STA L_RESULT+6
.1a54ae	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Ensure ARGUMENT1 is positive
.1a54b0	10 18		bpl $1a54ca	            BPL chk_sign2
.1a54b2	a9 00 80	lda #$8000	            LDA #$8000              ; Record that ARGUMENT1 is negative
.1a54b5	83 01		sta $01,s	            STA L_SIGN
.1a54b7	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Take the two's complement of ARGUMENT1
.1a54b9	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a54bc	85 25		sta $0825	            STA ARGUMENT1+2
.1a54be	a5 23		lda $0823	            LDA ARGUMENT1
.1a54c0	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a54c3	1a		inc a		            INC A
.1a54c4	85 23		sta $0823	            STA ARGUMENT1
.1a54c6	d0 02		bne $1a54ca	            BNE chk_sign2
.1a54c8	e6 25		inc $0825	            INC ARGUMENT1+2
.1a54ca	a5 2b		lda $082b	chk_sign2   LDA ARGUMENT2+2         ; Ensure ARGUMENT2 is positive
.1a54cc	10 1a		bpl $1a54e8	            BPL chk_over
.1a54ce	a3 01		lda $01,s	            LDA L_SIGN              ; Flip the sign
.1a54d0	49 00 80	eor #$8000	            EOR #$8000
.1a54d3	83 01		sta $01,s	            STA L_SIGN
.1a54d5	a5 2b		lda $082b	            LDA ARGUMENT2+2         ; Take the two's complement of ARGUMENT2
.1a54d7	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a54da	85 2b		sta $082b	            STA ARGUMENT2+2
.1a54dc	a5 29		lda $0829	            LDA ARGUMENT2
.1a54de	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a54e1	1a		inc a		            INC A
.1a54e2	85 29		sta $0829	            STA ARGUMENT2
.1a54e4	d0 02		bne $1a54e8	            BNE chk_over
.1a54e6	e6 2b		inc $082b	            INC ARGUMENT2+2
.1a54e8					chk_over
.1a54e8	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a54ea	f0 04		beq $1a54f0	            BEQ do_mult
.1a54ec	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a54ee	d0 5a		bne $1a554a	            BNE overflow
.1a54f0					do_mult
.1a54f0	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*D
.1a54f2	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.1a54f6	a5 29		lda $0829	            LDA ARGUMENT2
.1a54f8	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.1a54fc	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.1a5500	83 03		sta $03,s	            STA L_RESULT
.1a5502	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.1a5506	83 05		sta $05,s	            STA L_RESULT+2
.1a5508	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Calculate A*D << 16 + B*D
.1a550a	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.1a550e	a5 29		lda $0829	            LDA ARGUMENT2
.1a5510	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.1a5514	18		clc		            CLC
.1a5515	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.1a5519	63 05		adc $05,s	            ADC L_RESULT+2
.1a551b	83 05		sta $05,s	            STA L_RESULT+2
.1a551d	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.1a5521	63 07		adc $07,s	            ADC L_RESULT+4
.1a5523	83 07		sta $07,s	            STA L_RESULT+4
.1a5525	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*C << 16 + A*D << 16 + B*D
.1a5527	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.1a552b	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a552d	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.1a5531	18		clc		            CLC
.1a5532	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.1a5536	63 05		adc $05,s	            ADC L_RESULT+2
.1a5538	83 05		sta $05,s	            STA L_RESULT+2
.1a553a	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.1a553e	63 07		adc $07,s	            ADC L_RESULT+4
.1a5540	83 07		sta $07,s	            STA L_RESULT+4
.1a5542	a3 07		lda $07,s	            LDA L_RESULT+4
.1a5544	f0 23		beq $1a5569	            BEQ no_overflow
.1a5546	a3 09		lda $09,s	            LDA L_RESULT+6
.1a5548	f0 1f		beq $1a5569	            BEQ no_overflow
.1a554a					overflow
.1a554a	08		php		            PHP
.1a554b	c2 20		rep #$20	            REP #$20
.1a554d	48		pha		            PHA
.1a554e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5551	5b		tcd		            TCD
.1a5552	68		pla		            PLA
.1a5553	28		plp		            PLP
.1a5554	e2 20		sep #$20	            SEP #$20
.1a5556	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.1a5558	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a555c	c2 20		rep #$20	            REP #$20
.1a555e	29 ff 00	and #$00ff	            AND #$00FF
.1a5561	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a5564	e2 20		sep #$20	            SEP #$20
.1a5566	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5569					no_overflow
.1a5569	c2 30		rep #$30	            REP #$30
.1a556b	a3 01		lda $01,s	            LDA L_SIGN              ; Check the sign
.1a556d	10 16		bpl $1a5585	            BPL ret_result          ; If positive: just return the result
.1a556f	a3 05		lda $05,s	            LDA L_RESULT+2          ; Compute the two's complement of the result
.1a5571	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a5574	83 05		sta $05,s	            STA L_RESULT+2
.1a5576	a3 03		lda $03,s	            LDA L_RESULT
.1a5578	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a557b	1a		inc a		            INC A
.1a557c	83 03		sta $03,s	            STA L_RESULT
.1a557e	d0 05		bne $1a5585	            BNE ret_result
.1a5580	a3 05		lda $05,s	            LDA L_RESULT+2
.1a5582	1a		inc a		            INC A
.1a5583	83 05		sta $05,s	            STA L_RESULT+2
.1a5585					ret_result
.1a5585	a3 03		lda $03,s	            LDA L_RESULT
.1a5587	85 23		sta $0823	            STA ARGUMENT1
.1a5589	a3 05		lda $05,s	            LDA L_RESULT+2
.1a558b	85 25		sta $0825	            STA ARGUMENT1+2
.1a558d	c2 20		rep #$20	            REP #$20
.1a558f	3b		tsc		            TSC
.1a5590	18		clc		            CLC
.1a5591	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.1a5594	1b		tcs		            TCS
.1a5595	28		plp		            PLP
.1a5596	60		rts		            RTS
.1a5597					OP_INT_LT
.1a5597	08		php		            PHP
.1a5598	c2 20		rep #$20	            REP #$20
.1a559a	a5 23		lda $0823	            LDA ARGUMENT1
.1a559c	c5 29		cmp $0829	            CMP ARGUMENT2
.1a559e	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a55a0	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.1a55a2	50 03		bvc $1a55a7	            BVC skip_eor
.1a55a4	49 00 80	eor #$8000	            EOR #$8000
.1a55a7	30 06		bmi $1a55af	skip_eor    BMI ret_true
.1a55a9	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a55ab	64 25		stz $0825	            STZ ARGUMENT1+2
.1a55ad	80 07		bra $1a55b6	            BRA done
.1a55af	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a55b2	85 23		sta $0823	            STA ARGUMENT1
.1a55b4	85 25		sta $0825	            STA ARGUMENT1+2
.1a55b6	28		plp		done        PLP
.1a55b7	60		rts		            RTS
.1a55b8					OP_INT_GT
.1a55b8	08		php		            PHP
.1a55b9	c2 20		rep #$20	            REP #$20
.1a55bb	a5 23		lda $0823	            LDA ARGUMENT1
.1a55bd	c5 29		cmp $0829	            CMP ARGUMENT2
.1a55bf	d0 0c		bne $1a55cd	            BNE test_fully
.1a55c1	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a55c3	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.1a55c5	d0 06		bne $1a55cd	            BNE test_fully
.1a55c7	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a55c9	64 25		stz $0825	            STZ ARGUMENT1+2
.1a55cb	80 16		bra $1a55e3	            BRA done
.1a55cd	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.1a55cf	c5 23		cmp $0823	            CMP ARGUMENT1
.1a55d1	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a55d3	e5 25		sbc $0825	            SBC ARGUMENT1+2
.1a55d5	50 03		bvc $1a55da	            BVC skip_eor
.1a55d7	49 00 80	eor #$8000	            EOR #$8000
.1a55da	10 eb		bpl $1a55c7	skip_eor    BPL ret_false
.1a55dc	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a55df	85 23		sta $0823	            STA ARGUMENT1
.1a55e1	85 25		sta $0825	            STA ARGUMENT1+2
.1a55e3	28		plp		done        PLP
.1a55e4	60		rts		            RTS
.1a55e5					OP_INT_EQ
.1a55e5	08		php		            PHP
.1a55e6	c2 20		rep #$20	            REP #$20
.1a55e8	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a55ea	c5 25		cmp $0825	            CMP ARGUMENT1+2
.1a55ec	d0 0f		bne $1a55fd	            BNE ret_false
.1a55ee	a5 29		lda $0829	            LDA ARGUMENT2
.1a55f0	c5 23		cmp $0823	            CMP ARGUMENT1
.1a55f2	d0 09		bne $1a55fd	            BNE ret_false
.1a55f4	a9 ff ff	lda #$ffff	            LDA #$FFFF
.1a55f7	85 23		sta $0823	            STA ARGUMENT1
.1a55f9	85 25		sta $0825	            STA ARGUMENT1+2
.1a55fb	80 04		bra $1a5601	            BRA done
.1a55fd	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a55ff	64 25		stz $0825	            STZ ARGUMENT1+2
.1a5601	28		plp		done        PLP
.1a5602	60		rts		            RTS
.1a5603					OP_INT_NE
.1a5603	08		php		            PHP
.1a5604	c2 20		rep #$20	            REP #$20
.1a5606	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a5608	c5 25		cmp $0825	            CMP ARGUMENT1+2
.1a560a	d0 0c		bne $1a5618	            BNE ret_true
.1a560c	a5 29		lda $0829	            LDA ARGUMENT2
.1a560e	c5 23		cmp $0823	            CMP ARGUMENT1
.1a5610	d0 06		bne $1a5618	            BNE ret_true
.1a5612	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a5614	64 25		stz $0825	            STZ ARGUMENT1+2
.1a5616	80 07		bra $1a561f	            BRA done
.1a5618	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a561b	85 23		sta $0823	            STA ARGUMENT1
.1a561d	85 25		sta $0825	            STA ARGUMENT1+2
.1a561f	28		plp		done        PLP
.1a5620	60		rts		            RTS
.1a5621					OP_INT_GTE
.1a5621	08		php		            PHP
.1a5622	c2 20		rep #$20	            REP #$20
.1a5624	a5 23		lda $0823	            LDA ARGUMENT1
.1a5626	c5 29		cmp $0829	            CMP ARGUMENT2
.1a5628	d0 0f		bne $1a5639	            BNE test_fully
.1a562a	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a562c	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.1a562e	d0 09		bne $1a5639	            BNE test_fully
.1a5630	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a5633	85 23		sta $0823	            STA ARGUMENT1
.1a5635	85 25		sta $0825	            STA ARGUMENT1+2
.1a5637	80 13		bra $1a564c	            BRA done
.1a5639	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.1a563b	c5 23		cmp $0823	            CMP ARGUMENT1
.1a563d	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a563f	e5 25		sbc $0825	            SBC ARGUMENT1+2
.1a5641	50 03		bvc $1a5646	            BVC skip_eor
.1a5643	49 00 80	eor #$8000	            EOR #$8000
.1a5646	30 e8		bmi $1a5630	skip_eor    BMI ret_true
.1a5648	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a564a	64 25		stz $0825	            STZ ARGUMENT1+2
.1a564c	28		plp		done        PLP
.1a564d	60		rts		            RTS
.1a564e					OP_INT_LTE
.1a564e	08		php		            PHP
.1a564f	c2 20		rep #$20	            REP #$20
.1a5651	a5 23		lda $0823	            LDA ARGUMENT1
.1a5653	c5 29		cmp $0829	            CMP ARGUMENT2
.1a5655	d0 0f		bne $1a5666	            BNE test_fully
.1a5657	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5659	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.1a565b	d0 09		bne $1a5666	            BNE test_fully
.1a565d	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a5660	85 23		sta $0823	            STA ARGUMENT1
.1a5662	85 25		sta $0825	            STA ARGUMENT1+2
.1a5664	80 13		bra $1a5679	            BRA done
.1a5666	a5 23		lda $0823	test_fully  LDA ARGUMENT1
.1a5668	c5 29		cmp $0829	            CMP ARGUMENT2
.1a566a	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a566c	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.1a566e	50 03		bvc $1a5673	            BVC skip_eor
.1a5670	49 00 80	eor #$8000	            EOR #$8000
.1a5673	30 e8		bmi $1a565d	skip_eor    BMI ret_true
.1a5675	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a5677	64 25		stz $0825	            STZ ARGUMENT1+2
.1a5679	28		plp		done        PLP
.1a567a	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\floats.s


;******  Processing file: src\C256/floats.s


;******  Processing file: src\C256/fp_math_defs.s

=$afe200				FP_MATH_CTRL0 = $AFE200         ; Read/write
=$08					FP_MATH_CTRL0_ADD = $08         ; 0: Substraction - 1: Addition
=$01					FP_CTRL0_CONV_0 = %00000001     ; Input 0 should be converted from 24.12 fixed point to floating point
=$02					FP_CTRL0_CONV_1 = %00000010     ; Input 1 should be converted from 24.12 fixed point to floating point
=$00					FP_ADD_IN0_MUX0 = %00000000     ; Adder input #0 is the output of MUX0
=$10					FP_ADD_IN0_MUX1 = %00010000     ; Adder input #0 is the output of MUX1
=$20					FP_ADD_IN0_MULT = %00100000     ; Adder input #0 is the output of the multiplier
=$30					FP_ADD_IN0_DIV  = %00110000     ; Adder input #0 is the output of the divider
=$00					FP_ADD_IN1_MUX0 = %00000000     ; Adder input #1 is the output of MUX0
=$40					FP_ADD_IN1_MUX1 = %01000000     ; Adder input #1 is the output of MUX1
=$80					FP_ADD_IN1_MULT = %10000000     ; Adder input #1 is the output of the multiplier
=$c0					FP_ADD_IN1_DIV  = %11000000     ; Adder input #1 is the output of the divider
=$afe201				FP_MATH_CTRL1 = $AFE201
=$00					FP_OUT_MULT = %00000000         ; Output is from the multiplier
=$01					FP_OUT_DIV  = %00000001         ; Output is from the divider
=$02					FP_OUT_ADD  = %00000010         ; Output is from the adder/subtracter
=$03					FP_OUT_ONE  = %00000011         ; Output is the constant '1.0'
=$afe202				FP_MATH_CTRL2 = $AFE202         ; Not Used - Reserved
=$afe203				FP_MATH_CTRL3 = $AFE203         ; Not Used - Reserved
=$afe204				FP_MATH_MULT_STAT = $AFE204     ; Status of the multiplier
=$01					FP_MULT_STAT_NAN  = $01         ; (NAN) Not a Number Status
=$02					FP_MULT_STAT_OVF  = $02         ; Overflow
=$04					FP_MULT_STAT_UDF  = $04         ; Underflow
=$08					FP_MULT_STAT_ZERO = $08         ; Zero
=$afe205				FP_MATH_DIV_STAT  = $AFE205     ; Status of the divider
=$01					FP_DIV_STAT_NAN       = $01     ; Not a number Status
=$02					FP_DIV_STAT_OVF       = $02     ; Overflow
=$04					FP_DIV_STAT_UDF       = $04     ; Underflow
=$08					FP_DIV_STAT_ZERO      = $08     ; Zero
=$10					FP_DIV_STAT_DIVBYZERO = $10     ; Division by Zero
=$afe206				FP_MATH_ADD_STAT  = $AFE206     ; Status of the adder/subtracter
=$01					FP_ADD_STAT_NAN  = $01          ; Not a number Status
=$02					FP_ADD_STAT_OVF  = $02          ; Overflow
=$04					FP_ADD_STAT_UDF  = $04          ; Underflow
=$08					FP_ADD_STAT_ZERO = $08          ; Zero
=$afe207				FP_MATH_CONV_STAT = $AFE207     ; Status of the fixed <=> float converters
=$01					FP_CONV_STAT_NAN  = $01         ; Not a number Status
=$02					FP_CONV_STAT_OVF  = $02         ; Overflow
=$04					FP_CONV_STAT_UDF  = $04         ; Underflow
=$afe208				FP_MATH_INPUT0_LL = $AFE208
=$afe209				FP_MATH_INPUT0_LH = $AFE209
=$afe20a				FP_MATH_INPUT0_HL = $AFE20A
=$afe20b				FP_MATH_INPUT0_HH = $AFE20B
=$afe20c				FP_MATH_INPUT1_LL = $AFE20C
=$afe20d				FP_MATH_INPUT1_LH = $AFE20D
=$afe20e				FP_MATH_INPUT1_HL = $AFE20E
=$afe20f				FP_MATH_INPUT1_HH = $AFE20F
=$afe208				FP_MATH_OUTPUT_FP_LL = $AFE208
=$afe209				FP_MATH_OUTPUT_FP_LH = $AFE209
=$afe20a				FP_MATH_OUTPUT_FP_HL = $AFE20A
=$afe20b				FP_MATH_OUTPUT_FP_HH = $AFE20B
=$afe20c				FP_MATH_OUTPUT_FIXED_LL = $AFE20C
=$afe20d				FP_MATH_OUTPUT_FIXED_LH = $AFE20D
=$afe20e				FP_MATH_OUTPUT_FIXED_HL = $AFE20E
=$afe20f				FP_MATH_OUTPUT_FIXED_HH = $AFE20F

;******  Return to file: src\C256/floats.s


;******  Processing file: src\C256/math_cop.s

.1a567b					UINT_DIV_A_X
.1a567b	08		php		                    PHP
.1a567c	c2 20		rep #$20	            REP #$20
.1a567e	8f 12 01 00	sta $000112	                    STA @l UNSIGNED_DIV_NUM_LO
.1a5682	8a		txa		                    TXA
.1a5683	8f 10 01 00	sta $000110	                    STA @l UNSIGNED_DIV_DEM_LO
.1a5687	af 16 01 00	lda $000116	                    LDA @l UNSIGNED_DIV_REM_LO
.1a568b	aa		tax		                    TAX
.1a568c	af 14 01 00	lda $000114	                    LDA @l UNSIGNED_DIV_QUO_LO
.1a5690	28		plp		                    PLP
.1a5691	60		rts		            RTS

;******  Return to file: src\C256/floats.s

.1a5692					FIXINT_TO_FP
.1a5692	08		php		                    PHP
.1a5693	e2 20		sep #$20	            SEP #$20
.1a5695	a9 03		lda #$03	                    LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.1a5697	8f 00 e2 af	sta $afe200	                    STA @l FP_MATH_CTRL0
.1a569b	a9 00		lda #$00	                    LDA #FP_OUT_MULT
.1a569d	8f 01 e2 af	sta $afe201	                    STA @l FP_MATH_CTRL1
.1a56a1	c2 20		rep #$20	            REP #$20
.1a56a3	a5 23		lda $0823	                    LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a56a5	8f 08 e2 af	sta $afe208	                    STA @l FP_MATH_INPUT0_LL
.1a56a9	a5 25		lda $0825	                    LDA ARGUMENT1+2
.1a56ab	8f 0a e2 af	sta $afe20a	                    STA @l FP_MATH_INPUT0_HL
.1a56af	a9 00 00	lda #$0000	                    LDA #0
.1a56b2	8f 0c e2 af	sta $afe20c	                    STA @l FP_MATH_INPUT1_LL    ; ARGUMENT2 = 0100 0000 = 4096 in 20:12
.1a56b6	a9 00 01	lda #$0100	                    LDA #$0100
.1a56b9	8f 0e e2 af	sta $afe20e	                    STA @l FP_MATH_INPUT1_HL
.1a56bd	ea		nop		                    NOP
.1a56be	ea		nop		                    NOP
.1a56bf	ea		nop		                    NOP
.1a56c0	ea		nop		                    NOP
.1a56c1	ea		nop		                    NOP
.1a56c2	ea		nop		                    NOP
.1a56c3	af 08 e2 af	lda $afe208	                    LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.1a56c7	85 23		sta $0823	                    STA ARGUMENT1
.1a56c9	af 0a e2 af	lda $afe20a	                    LDA @l FP_MATH_OUTPUT_FP_HL
.1a56cd	85 25		sta $0825	                    STA ARGUMENT1+2
.1a56cf	a9 01 00	lda #$0001	                    LDA #TYPE_FLOAT
.1a56d2	85 27		sta $0827	                    STA ARGTYPE1
.1a56d4	28		plp		                    PLP
.1a56d5	60		rts		            RTS
.1a56d6	08		php		OP_FP_SUB       PHP
.1a56d7	e2 20		sep #$20	            SEP #$20
.1a56d9	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a56db	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a56df	80 09		bra $1a56ea	                BRA FP_ADD_SUB
.1a56e1	08		php		OP_FP_ADD       PHP
.1a56e2	e2 20		sep #$20	            SEP #$20
.1a56e4	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a56e6	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a56ea	a9 02		lda #$02	FP_ADD_SUB      LDA #FP_OUT_ADD
.1a56ec	8f 01 e2 af	sta $afe201	                STA @lFP_MATH_CTRL1
.1a56f0	c2 20		rep #$20	            REP #$20
.1a56f2	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a56f4	8f 08 e2 af	sta $afe208	                STA @lFP_MATH_INPUT0_LL
.1a56f8	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a56fa	8f 0a e2 af	sta $afe20a	                STA @lFP_MATH_INPUT0_HL
.1a56fe	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.1a5700	8f 0c e2 af	sta $afe20c	                STA @lFP_MATH_INPUT1_LL
.1a5704	a5 2b		lda $082b	                LDA ARGUMENT2+2
.1a5706	8f 0e e2 af	sta $afe20e	                STA @lFP_MATH_INPUT1_HL
.1a570a	ea		nop		                NOP
.1a570b	ea		nop		                NOP
.1a570c	ea		nop		                NOP
.1a570d	e2 20		sep #$20	            SEP #$20
.1a570f	af 06 e2 af	lda $afe206	                LDA @lFP_MATH_ADD_STAT      ; Check the status of the addition
.1a5713	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.1a5715	d0 10		bne $1a5727	                BNE fp_add_error            ; If an issue was raise, process the math error
.1a5717	c2 20		rep #$20	            REP #$20
.1a5719	af 08 e2 af	lda $afe208	                LDA @lFP_MATH_OUTPUT_FP_LL  ; Retrieve the results into ARGUMENT1
.1a571d	85 23		sta $0823	                STA ARGUMENT1
.1a571f	af 0a e2 af	lda $afe20a	                LDA @lFP_MATH_OUTPUT_FP_HL
.1a5723	85 25		sta $0825	                STA ARGUMENT1+2
.1a5725	28		plp		fp_add_done     PLP
.1a5726	60		rts		            RTS
.1a5727					fp_add_error
.1a5727	20 c2 57	jsr $1a57c2	            JSR FP_MATH_ERROR
.1a572a	80 f9		bra $1a5725	                BRA fp_add_done
.1a572c	08		php		OP_FP_DIV       PHP
.1a572d	e2 20		sep #$20	            SEP #$20
.1a572f	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a5731	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5735	a9 00		lda #$00	                LDA #0
.1a5737	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a573b	c2 20		rep #$20	            REP #$20
.1a573d	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a573f	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5743	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5745	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5749	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.1a574b	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a574f	a5 2b		lda $082b	                LDA ARGUMENT2+2
.1a5751	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5755	ea		nop		                NOP
.1a5756	ea		nop		                NOP
.1a5757	ea		nop		                NOP
.1a5758	e2 20		sep #$20	            SEP #$20
.1a575a	af 05 e2 af	lda $afe205	                LDA @l FP_MATH_DIV_STAT     ; Check the status of the addition
.1a575e	29 17		and #$17	                AND #%00010111              ; Filter out the ZERO status
.1a5760	d0 10		bne $1a5772	                BNE fp_div_error            ; If an issue was raise, process the math error
.1a5762	c2 20		rep #$20	            REP #$20
.1a5764	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.1a5768	85 23		sta $0823	                STA ARGUMENT1
.1a576a	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a576e	85 25		sta $0825	                STA ARGUMENT1+2
.1a5770	28		plp		fp_div_done     PLP
.1a5771	60		rts		            RTS
.1a5772					fp_div_error
.1a5772	20 c2 57	jsr $1a57c2	            JSR FP_MATH_ERROR
.1a5775	80 f9		bra $1a5770	                BRA fp_div_done
.1a5777	08		php		OP_FP_MUL       PHP
.1a5778	e2 20		sep #$20	            SEP #$20
.1a577a	a9 00		lda #$00	                LDA #FP_OUT_MULT
.1a577c	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5780	a9 00		lda #$00	                LDA #0
.1a5782	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a5786	c2 20		rep #$20	            REP #$20
.1a5788	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a578a	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a578e	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5790	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5794	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.1a5796	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a579a	a5 2b		lda $082b	                LDA ARGUMENT2+2
.1a579c	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a57a0	ea		nop		                NOP
.1a57a1	ea		nop		                NOP
.1a57a2	ea		nop		                NOP
.1a57a3	e2 20		sep #$20	            SEP #$20
.1a57a5	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT    ; Check the status of the addition
.1a57a9	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.1a57ab	d0 10		bne $1a57bd	                BNE fp_mul_error            ; If an issue was raise, process the math error
.1a57ad	c2 20		rep #$20	            REP #$20
.1a57af	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.1a57b3	85 23		sta $0823	                STA ARGUMENT1
.1a57b5	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a57b9	85 25		sta $0825	                STA ARGUMENT1+2
.1a57bb	28		plp		fp_mul_done     PLP
.1a57bc	60		rts		            RTS
.1a57bd					fp_mul_error
.1a57bd	20 c2 57	jsr $1a57c2	            JSR FP_MATH_ERROR
.1a57c0	80 f9		bra $1a57bb	                BRA fp_mul_done
.1a57c2					FP_MATH_ERROR
.1a57c2	e2 20		sep #$20	            SEP #$20
.1a57c4	89 01		bit #$01	                BIT #FP_ADD_STAT_NAN        ; Is there a NaN condition?
.1a57c6	f0 20		beq $1a57e8	                BEQ check_over              ; No: check for overflow
.1a57c8	00		brk #		                BRK
.1a57c9	08		php		            PHP
.1a57ca	c2 20		rep #$20	            REP #$20
.1a57cc	48		pha		            PHA
.1a57cd	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a57d0	5b		tcd		            TCD
.1a57d1	68		pla		            PLA
.1a57d2	28		plp		            PLP
.1a57d3	e2 20		sep #$20	            SEP #$20
.1a57d5	a9 0c		lda #$0c	            LDA #ERR_NAN
.1a57d7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a57db	c2 20		rep #$20	            REP #$20
.1a57dd	29 ff 00	and #$00ff	            AND #$00FF
.1a57e0	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a57e3	e2 20		sep #$20	            SEP #$20
.1a57e5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a57e8	89 02		bit #$02	check_over      BIT #FP_ADD_STAT_OVF        ; Is ther an overflow condition?
.1a57ea	f0 1f		beq $1a580b	                BEQ check_under             ; No: check for underflow
.1a57ec	08		php		            PHP
.1a57ed	c2 20		rep #$20	            REP #$20
.1a57ef	48		pha		            PHA
.1a57f0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a57f3	5b		tcd		            TCD
.1a57f4	68		pla		            PLA
.1a57f5	28		plp		            PLP
.1a57f6	e2 20		sep #$20	            SEP #$20
.1a57f8	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.1a57fa	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a57fe	c2 20		rep #$20	            REP #$20
.1a5800	29 ff 00	and #$00ff	            AND #$00FF
.1a5803	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a5806	e2 20		sep #$20	            SEP #$20
.1a5808	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a580b	89 04		bit #$04	check_under     BIT #FP_ADD_STAT_UDF        ; Is there an underflow condition?
.1a580d	f0 1f		beq $1a582e	                BEQ done                    ; No: we should just return... this probably shouldn't happen
.1a580f	08		php		            PHP
.1a5810	c2 20		rep #$20	            REP #$20
.1a5812	48		pha		            PHA
.1a5813	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5816	5b		tcd		            TCD
.1a5817	68		pla		            PLA
.1a5818	28		plp		            PLP
.1a5819	e2 20		sep #$20	            SEP #$20
.1a581b	a9 0e		lda #$0e	            LDA #ERR_UNDERFLOW
.1a581d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5821	c2 20		rep #$20	            REP #$20
.1a5823	29 ff 00	and #$00ff	            AND #$00FF
.1a5826	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a5829	e2 20		sep #$20	            SEP #$20
.1a582b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a582e					done
.1a582e	60		rts		            RTS
.1a582f					FP_MUL10
.1a582f	08		php		                PHP
.1a5830	e2 20		sep #$20	            SEP #$20
.1a5832	a9 00		lda #$00	                LDA #FP_OUT_MULT                ; Set for multiplication
.1a5834	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5838	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1            ; Input 1 is fixed point
.1a583a	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a583e	c2 20		rep #$20	            REP #$20
.1a5840	a9 00 a0	lda #$a000	                LDA #$A000                      ; 10 is one factor
.1a5843	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5847	a9 00 00	lda #$0000	                LDA #0
.1a584a	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a584e	a5 23		lda $0823	                LDA ARGUMENT1                   ; N is the other
.1a5850	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5854	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5856	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a585a	ea		nop		                NOP
.1a585b	ea		nop		                NOP
.1a585c	ea		nop		                NOP
.1a585d	e2 20		sep #$20	            SEP #$20
.1a585f	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT        ; Check the status
.1a5863	89 07		bit #$07	                BIT #FP_MULT_STAT_NAN | FP_MULT_STAT_OVF | FP_MULT_STAT_UDF
.1a5865	f0 01		beq $1a5868	                BEQ ret_result
.1a5867	00		brk #		                BRK                             ; There was an error...
.1a5868					ret_result
.1a5868	c2 20		rep #$20	            REP #$20
.1a586a	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL     ; Save result back
.1a586e	85 23		sta $0823	                STA ARGUMENT1
.1a5870	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5874	85 25		sta $0825	                STA ARGUMENT1+2
.1a5876	28		plp		                PLP
.1a5877	60		rts		            RTS
.1a5878					FP_DIV10
.1a5878	08		php		                PHP
.1a5879	e2 20		sep #$20	            SEP #$20
.1a587b	a9 01		lda #$01	                LDA #FP_OUT_DIV             ; Set for multiplication
.1a587d	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5881	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1        ; Input 1 is fixed point
.1a5883	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5887	c2 20		rep #$20	            REP #$20
.1a5889	a9 00 a0	lda #$a000	                LDA #$A000                  ; 10 is one factor
.1a588c	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5890	a9 00 00	lda #$0000	                LDA #0
.1a5893	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5897	a5 23		lda $0823	                LDA ARGUMENT1               ; N is the other
.1a5899	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a589d	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a589f	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a58a3	ea		nop		                NOP
.1a58a4	ea		nop		                NOP
.1a58a5	ea		nop		                NOP
.1a58a6	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Save result back
.1a58aa	85 23		sta $0823	                STA ARGUMENT1
.1a58ac	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a58b0	85 25		sta $0825	                STA ARGUMENT1+2
.1a58b2	28		plp		                PLP
.1a58b3	60		rts		            RTS

;******  Return to file: src\floats.s

.1a58b4					FARG1EQ0
.1a58b4	08		php		                PHP
.1a58b5	c2 20		rep #$20	            REP #$20
.1a58b7	a5 23		lda $0823	                LDA ARGUMENT1
.1a58b9	d0 0a		bne $1a58c5	                BNE return_false
.1a58bb	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a58bd	29 ff 7f	and #$7fff	                AND #$7FFF              ; Mask off the sign bit
.1a58c0	d0 03		bne $1a58c5	                BNE return_false
.1a58c2	28		plp		return_true     PLP
.1a58c3	38		sec		                SEC
.1a58c4	60		rts		            RTS
.1a58c5	28		plp		return_false    PLP
.1a58c6	18		clc		                CLC
.1a58c7	60		rts		            RTS
.1a58c8					SHIFTDEC
.1a58c8	08		php		                PHP
.1a58c9	e2 20		sep #$20	            SEP #$20
.1a58cb	38		sec		                SEC                     ; Convert '0'..'9' to it's number
.1a58cc	e9 30		sbc #$30	                SBC #'0'
.1a58ce	20 7a 05	jsr $1a057a	            JSR MULINT10
.1a58d1	c2 20		rep #$20	            REP #$20
.1a58d3	29 ff 00	and #$00ff	                AND #$00FF              ; Add the number to ARGUMENT1
.1a58d6	18		clc		                CLC
.1a58d7	65 23		adc $0823	                ADC ARGUMENT1
.1a58d9	85 23		sta $0823	                STA ARGUMENT1
.1a58db	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a58dd	69 00 00	adc #$0000	                ADC #0
.1a58e0	85 25		sta $0825	                STA ARGUMENT1+2
.1a58e2	28		plp		                PLP
.1a58e3	60		rts		            RTS
.1a58e4					SHIFTHEX
.1a58e4	08		php		                PHP
.1a58e5	e2 20		sep #$20	            SEP #$20
.1a58e7	c9 30		cmp #$30	                CMP #'0'                ; Process 0-9
.1a58e9	90 04		bcc $1a58ef	                BLT not_09
.1a58eb	c9 3a		cmp #$3a	                CMP #'9'+1
.1a58ed	90 1c		bcc $1a590b	                BLT is_09
.1a58ef	c9 61		cmp #$61	not_09          CMP #'a'                ; Process lowercase A-F
.1a58f1	90 04		bcc $1a58f7	                BLT not_lc
.1a58f3	c9 67		cmp #$67	                CMP #'f'+1
.1a58f5	90 0a		bcc $1a5901	                BLT is_lc
.1a58f7	c9 41		cmp #$41	not_lc          CMP #'A'                ; Process uppercase A-F
.1a58f9	90 04		bcc $1a58ff	                BLT not_uc
.1a58fb	c9 47		cmp #$47	                CMP #'F'+1
.1a58fd	90 07		bcc $1a5906	                BLT is_uc
.1a58ff	80 31		bra $1a5932	not_uc          BRA done                ; Just return if we couldn't convert... this shouldn't happen
.1a5901	38		sec		is_lc           SEC                     ; Convert 'a'-'f' to the actual number
.1a5902	e9 57		sbc #$57	                SBC #'a'-10
.1a5904	80 08		bra $1a590e	                BRA shift
.1a5906	38		sec		is_uc           SEC                     ; Convert 'A'-'F' to the actual number
.1a5907	e9 37		sbc #$37	                SBC #'A'-10
.1a5909	80 03		bra $1a590e	                BRA shift
.1a590b	38		sec		is_09           SEC                     ; Convert '0'-'9' to the actual number
.1a590c	e9 30		sbc #$30	                SBC #'0'
.1a590e					shift
.1a590e	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a5910	26 24		rol $0824	                ROL ARGUMENT1+1
.1a5912	26 25		rol $0825	                ROL ARGUMENT1+2
.1a5914	26 26		rol $0826	                ROL ARGUMENT1+3
.1a5916	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a5918	26 24		rol $0824	                ROL ARGUMENT1+1
.1a591a	26 25		rol $0825	                ROL ARGUMENT1+2
.1a591c	26 26		rol $0826	                ROL ARGUMENT1+3
.1a591e	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a5920	26 24		rol $0824	                ROL ARGUMENT1+1
.1a5922	26 25		rol $0825	                ROL ARGUMENT1+2
.1a5924	26 26		rol $0826	                ROL ARGUMENT1+3
.1a5926	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a5928	26 24		rol $0824	                ROL ARGUMENT1+1
.1a592a	26 25		rol $0825	                ROL ARGUMENT1+2
.1a592c	26 26		rol $0826	                ROL ARGUMENT1+3
.1a592e	05 23		ora $0823	                ORA ARGUMENT1           ; Add the number to it
.1a5930	85 23		sta $0823	                STA ARGUMENT1
.1a5932	28		plp		done            PLP
.1a5933	60		rts		            RTS
.1a5934					SHIFTBIN
.1a5934	08		php		                PHP
.1a5935	e2 20		sep #$20	            SEP #$20
.1a5937	c9 30		cmp #$30	                CMP #'0'                ; If the character is '0'...
.1a5939	f0 06		beq $1a5941	                BEQ shift_0             ; Shift a 0 onto ARGUMENT1
.1a593b	c9 31		cmp #$31	                CMP #'1'                ; If the character is '1'...
.1a593d	f0 0a		beq $1a5949	                BEQ shift_1             ; Shift a 1 onto ARGUMENT1
.1a593f	80 0f		bra $1a5950	                BRA done
.1a5941					shift_0
.1a5941	c2 20		rep #$20	            REP #$20
.1a5943	06 23		asl $0823	                ASL ARGUMENT1
.1a5945	26 25		rol $0825	                ROL ARGUMENT1+2
.1a5947	80 07		bra $1a5950	                BRA done
.1a5949					shift_1
.1a5949	c2 20		rep #$20	            REP #$20
.1a594b	38		sec		                SEC
.1a594c	26 23		rol $0823	                ROL ARGUMENT1
.1a594e	26 25		rol $0825	                ROL ARGUMENT1+2
.1a5950	28		plp		done            PLP
.1a5951	60		rts		            RTS
.1a5952					FP_POW10
.1a5952	08		php		                PHP
.1a5953	e2 30		sep #$30	            SEP #$30
.1a5955	a5 61		lda $0861	                LDA MARG4
.1a5957	f0 0d		beq $1a5966	                BEQ return_1
.1a5959	aa		tax		                TAX
.1a595a	a5 69		lda $0869	                LDA MARG6
.1a595c	d0 15		bne $1a5973	                BNE do_div
.1a595e	a9 00		lda #$00	                LDA #FP_OUT_MULT                    ; We'll multiply
.1a5960	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5964	80 15		bra $1a597b	                BRA start_loop
.1a5966					return_1
.1a5966	e2 20		sep #$20	            SEP #$20
.1a5968	a9 03		lda #$03	                LDA #FP_OUT_ONE                     ; We want to return a 1.0
.1a596a	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a596e	ea		nop		                NOP
.1a596f	ea		nop		                NOP
.1a5970	ea		nop		                NOP
.1a5971	80 62		bra $1a59d5	                BRA ret_result                      ; And return the result
.1a5973					do_div
.1a5973	e2 20		sep #$20	            SEP #$20
.1a5975	a9 01		lda #$01	                LDA #FP_OUT_DIV                     ; We'll divide
.1a5977	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a597b					start_loop
.1a597b	e2 20		sep #$20	            SEP #$20
.1a597d	a9 43		lda #$43	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.1a597f	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.1a5983	c2 20		rep #$20	            REP #$20
.1a5985	a9 00 10	lda #$1000	                LDA #$1000                          ; Input 0 = 1.0
.1a5988	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a598c	a9 00 00	lda #$0000	                LDA #0
.1a598f	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5993					loop
.1a5993	c2 20		rep #$20	            REP #$20
.1a5995	a9 00 a0	lda #$a000	                LDA #$A000                          ; Input 1 = 10.0
.1a5998	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a599c	a9 00 00	lda #$0000	                LDA #0
.1a599f	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a59a3	ea		nop		                NOP                                 ; Wait for the operation to complete
.1a59a4	ea		nop		                NOP
.1a59a5	ea		nop		                NOP
.1a59a6	ca		dex		                DEX                                 ; Count down
.1a59a7	f0 2c		beq $1a59d5	                BEQ ret_result                      ; If 0, then we're done
.1a59a9	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; SCRATCH <-- Result
.1a59ad	8f 0c 08 00	sta $00080c	                STA @l SCRATCH
.1a59b1	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a59b5	8f 0e 08 00	sta $00080e	                STA @l SCRATCH+2
.1a59b9	e2 20		sep #$20	            SEP #$20
.1a59bb	a9 42		lda #$42	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_1
.1a59bd	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.1a59c1	c2 20		rep #$20	            REP #$20
.1a59c3	af 0c 08 00	lda $00080c	                LDA @l SCRATCH                      ; Input 0 <-- SCRATCH
.1a59c7	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a59cb	af 0e 08 00	lda $00080e	                LDA @l SCRATCH+2
.1a59cf	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a59d3	80 be		bra $1a5993	                BRA loop
.1a59d5					ret_result
.1a59d5	c2 20		rep #$20	            REP #$20
.1a59d7	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; Return the result
.1a59db	85 23		sta $0823	                STA ARGUMENT1
.1a59dd	af 0a e2 af	lda $afe20a	                LDA FP_MATH_OUTPUT_FP_HL
.1a59e1	85 25		sta $0825	                STA ARGUMENT1+2
.1a59e3	e2 20		sep #$20	            SEP #$20
.1a59e5	a9 01		lda #$01	                LDA #TYPE_FLOAT
.1a59e7	85 27		sta $0827	                STA ARGTYPE1
.1a59e9	28		plp		done            PLP
.1a59ea	60		rts		            RTS
.1a59eb					PACKFLOAT
.1a59eb	08		php		                PHP
.1a59ec	c2 20		rep #$20	            REP #$20
.1a59ee	a5 5d		lda $085d	            LDA MARG3
.1a59f0	85 23		sta $0823	            STA ARGUMENT1
.1a59f2	a5 5f		lda $085f	            LDA MARG3+2
.1a59f4	85 25		sta $0825	            STA ARGUMENT1+2
.1a59f6	20 04 5c	jsr $1a5c04	            JSR ITOF
.1a59f9	c2 20		rep #$20	            REP #$20
.1a59fb	a5 23		lda $0823	            LDA ARGUMENT1
.1a59fd	85 29		sta $0829	            STA ARGUMENT2
.1a59ff	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5a01	85 2b		sta $082b	            STA ARGUMENT2+2
.1a5a03	c2 20		rep #$20	            REP #$20
.1a5a05	a5 59		lda $0859	            LDA MARG2
.1a5a07	85 23		sta $0823	            STA ARGUMENT1
.1a5a09	a5 5b		lda $085b	            LDA MARG2+2
.1a5a0b	85 25		sta $0825	            STA ARGUMENT1+2
.1a5a0d	20 2c 57	jsr $1a572c	            JSR OP_FP_DIV
.1a5a10	c2 20		rep #$20	            REP #$20
.1a5a12	a5 55		lda $0855	            LDA MARG1
.1a5a14	85 29		sta $0829	            STA ARGUMENT2
.1a5a16	a5 57		lda $0857	            LDA MARG1+2
.1a5a18	85 2b		sta $082b	            STA ARGUMENT2+2
.1a5a1a	20 e1 56	jsr $1a56e1	            JSR OP_FP_ADD
.1a5a1d	c2 20		rep #$20	            REP #$20
.1a5a1f	a5 23		lda $0823	            LDA ARGUMENT1
.1a5a21	85 29		sta $0829	            STA ARGUMENT2
.1a5a23	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5a25	85 2b		sta $082b	            STA ARGUMENT2+2
.1a5a27	20 52 59	jsr $1a5952	            JSR FP_POW10
.1a5a2a	20 77 57	jsr $1a5777	            JSR OP_FP_MUL
.1a5a2d	c2 20		rep #$20	            REP #$20
.1a5a2f	a5 65		lda $0865	                LDA MARG5                       ; Check to see if the float should be negative
.1a5a31	f0 07		beq $1a5a3a	                BEQ set_float_type              ; If not, just set the type
.1a5a33	a5 25		lda $0825	                LDA ARGUMENT1+2                 ; If so, set the sign bit
.1a5a35	09 00 80	ora #$8000	                ORA #$8000
.1a5a38	85 25		sta $0825	                STA ARGUMENT1+2
.1a5a3a					set_float_type
.1a5a3a	e2 20		sep #$20	            SEP #$20
.1a5a3c	a9 01		lda #$01	                LDA #TYPE_FLOAT                 ; Set the type to float... ready for returning!
.1a5a3e	85 27		sta $0827	                STA ARGTYPE1
.1a5a40	28		plp		                PLP
.1a5a41	60		rts		            RTS
.1a5a42					PARSENUM
.1a5a42	5a		phy		                PHY
.1a5a43	08		php		                PHP
.1a5a44	c2 30		rep #$30	            REP #$30
.1a5a46	64 23		stz $0823	                STZ ARGUMENT1       ; This will be the accumulator for building the number
.1a5a48	64 25		stz $0825	                STZ ARGUMENT1+2
.1a5a4a	64 55		stz $0855	                STZ MARG1           ; This will be the integer portion of the mantissa for floats
.1a5a4c	64 57		stz $0857	                STZ MARG1+2
.1a5a4e	64 65		stz $0865	                STZ MARG5           ; MARG5 will be the negative flag for the number
.1a5a50	64 59		stz $0859	                STZ MARG2           ; This will be the denominator of the fractional part of the mantissa
.1a5a52	64 5b		stz $085b	                STZ MARG2+2
.1a5a54	a9 01 00	lda #$0001	                LDA #1
.1a5a57	85 5d		sta $085d	                STA MARG3           ; This will be the divisor of the fractional part of the mantissa
.1a5a59	64 5f		stz $085f	                STZ MARG3+2
.1a5a5b	64 61		stz $0861	                STZ MARG4           ; This will be the exponent of a float
.1a5a5d	64 63		stz $0863	                STZ MARG4+2
.1a5a5f	64 69		stz $0869	                STZ MARG6           ; MARG6 will be the negative flag for the exponent
.1a5a61					s0
.1a5a61	e2 20		sep #$20	            SEP #$20
.1a5a63	a0 00 00	ldy #$0000	                LDY #0
.1a5a66	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the first byte
.1a5a68	c9 2b		cmp #$2b	                CMP #'+'
.1a5a6a	f0 33		beq $1a5a9f	                BEQ s1_drop         ; '+' --> S1, drop
.1a5a6c	c9 2d		cmp #$2d	                CMP #'-'
.1a5a6e	f0 2b		beq $1a5a9b	                BEQ s1_negative     ; Flag that the number is negative
.1a5a70	c9 26		cmp #$26	                CMP #'&'
.1a5a72	f0 3a		beq $1a5aae	                BEQ s2_drop         ; '&' --> S2, drop
.1a5a74	20 fb 04	jsr $1a04fb	            JSR ISNUMERAL
.1a5a77	90 03		bcc $1a5a7c	                BCC syntax_err
.1a5a79	82 ac 00	brl $1a5b28	                BRL s7_shift        ; '0'-'9' --> S7, emit
.1a5a7c					syntax_err
.1a5a7c	08		php		            PHP
.1a5a7d	c2 20		rep #$20	            REP #$20
.1a5a7f	48		pha		            PHA
.1a5a80	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5a83	5b		tcd		            TCD
.1a5a84	68		pla		            PLA
.1a5a85	28		plp		            PLP
.1a5a86	e2 20		sep #$20	            SEP #$20
.1a5a88	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a5a8a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5a8e	c2 20		rep #$20	            REP #$20
.1a5a90	29 ff 00	and #$00ff	            AND #$00FF
.1a5a93	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a5a96	e2 20		sep #$20	            SEP #$20
.1a5a98	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5a9b	a9 01		lda #$01	s1_negative     LDA #1              ; Set the negative flag for the mantissa
.1a5a9d	85 65		sta $0865	                STA MARG5
.1a5a9f	c8		iny		s1_drop         INY                 ; Drop the character...
.1a5aa0	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next
.1a5aa2	c9 26		cmp #$26	                CMP #'&'
.1a5aa4	f0 08		beq $1a5aae	                BEQ s2_drop         ; '&' --> S2, drop the '&'
.1a5aa6	20 fb 04	jsr $1a04fb	            JSR ISNUMERAL
.1a5aa9	90 d1		bcc $1a5a7c	                BCC syntax_err
.1a5aab	82 7a 00	brl $1a5b28	                BRL s7_shift        ; '0'-'9' --> S7, shift
.1a5aae	c8		iny		s2_drop         INY                 ; Drop the character
.1a5aaf	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.1a5ab1	c9 68		cmp #$68	                CMP #'h'
.1a5ab3	f0 0e		beq $1a5ac3	                BEQ s3_drop         ; 'h', 'H' --> S3, drop
.1a5ab5	c9 48		cmp #$48	                CMP #'H'
.1a5ab7	f0 0a		beq $1a5ac3	                BEQ s3_drop
.1a5ab9	c9 62		cmp #$62	                CMP #'b'
.1a5abb	f0 4c		beq $1a5b09	                BEQ s5_drop         ; 'b', 'B' --> S5, drop
.1a5abd	c9 42		cmp #$42	                CMP #'B'
.1a5abf	f0 48		beq $1a5b09	                BEQ s5_drop
.1a5ac1	80 b9		bra $1a5a7c	                BRA syntax_err
.1a5ac3	c8		iny		s3_drop         INY                 ; Drop the character
.1a5ac4	b7 00		lda [$0800],y	s3              LDA [BIP],Y         ; Get the next character
.1a5ac6	20 0c 05	jsr $1a050c	            JSR ISHEX
.1a5ac9	b0 02		bcs $1a5acd	                BCS s4_shift
.1a5acb	80 af		bra $1a5a7c	                BRA syntax_err
.1a5acd					s4_shift
.1a5acd	20 e4 58	jsr $1a58e4	            JSR SHIFTHEX
.1a5ad0	c8		iny		                INY
.1a5ad1	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.1a5ad3	20 0c 05	jsr $1a050c	            JSR ISHEX
.1a5ad6	b0 f5		bcs $1a5acd	                BCS s4_shift        ; '0'-'9','A'-'F' --> S4, shift
.1a5ad8					ret_integer
.1a5ad8	e2 20		sep #$20	            SEP #$20
.1a5ada	a5 65		lda $0865	                LDA MARG5           ; check if the number should be negative
.1a5adc	f0 11		beq $1a5aef	                BEQ set_int_type    ; If not, just set the type and return
.1a5ade	c2 20		rep #$20	            REP #$20
.1a5ae0	38		sec		                SEC                 ; If so, negate it
.1a5ae1	a9 00 00	lda #$0000	                LDA #0
.1a5ae4	e5 23		sbc $0823	                SBC ARGUMENT1
.1a5ae6	85 23		sta $0823	                STA ARGUMENT1
.1a5ae8	a9 00 00	lda #$0000	                LDA #0
.1a5aeb	e5 25		sbc $0825	                SBC ARGUMENT1+2
.1a5aed	85 25		sta $0825	                STA ARGUMENT1+2
.1a5aef					set_int_type
.1a5aef	e2 20		sep #$20	            SEP #$20
.1a5af1	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; Return an integer
.1a5af3	85 27		sta $0827	                STA ARGTYPE1
.1a5af5					stop
.1a5af5	c2 20		rep #$20	            REP #$20
.1a5af7	18		clc		                CLC
.1a5af8	98		tya		                TYA
.1a5af9	65 00		adc $0800	                ADC BIP
.1a5afb	85 00		sta $0800	                STA BIP
.1a5afd	a5 02		lda $0802	                LDA BIP+2
.1a5aff	69 00 00	adc #$0000	                ADC #0
.1a5b02	85 02		sta $0802	                STA BIP+2
.1a5b04	e2 20		sep #$20	            SEP #$20
.1a5b06	28		plp		                PLP
.1a5b07	7a		ply		                PLY
.1a5b08	60		rts		            RTS
.1a5b09	c8		iny		s5_drop         INY                     ; Drop the character
.1a5b0a	b7 00		lda [$0800],y	s5              LDA [BIP],Y             ; Get the next character
.1a5b0c	c9 30		cmp #$30	                CMP #'0'
.1a5b0e	f0 07		beq $1a5b17	                BEQ s6_shift            ; '0', '1' --> S6, shift
.1a5b10	c9 31		cmp #$31	                CMP #'1'
.1a5b12	f0 03		beq $1a5b17	                BEQ s6_shift
.1a5b14	82 65 ff	brl $1a5a7c	                BRL syntax_err
.1a5b17					s6_shift
.1a5b17	20 34 59	jsr $1a5934	            JSR SHIFTBIN
.1a5b1a	c8		iny		                INY
.1a5b1b	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5b1d	c9 30		cmp #$30	                CMP #'0'                ; '0', '1' --> S6, shift
.1a5b1f	f0 f6		beq $1a5b17	                BEQ s6_shift
.1a5b21	c9 31		cmp #$31	                CMP #'1'
.1a5b23	f0 f2		beq $1a5b17	                BEQ s6_shift
.1a5b25	82 b0 ff	brl $1a5ad8	                BRL ret_integer         ; Return integer
.1a5b28					s7_shift
.1a5b28	20 c8 58	jsr $1a58c8	            JSR SHIFTDEC
.1a5b2b	c8		iny		                INY
.1a5b2c	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5b2e	c9 2e		cmp #$2e	                CMP #'.'                ; '.' --> S8, drop and preserve mantissa
.1a5b30	f0 08		beq $1a5b3a	                BEQ s8_mantissa
.1a5b32	20 fb 04	jsr $1a04fb	            JSR ISNUMERAL
.1a5b35	b0 f1		bcs $1a5b28	                BCS s7_shift
.1a5b37	82 9e ff	brl $1a5ad8	                BRL ret_integer         ; Return integer
.1a5b3a					s8_mantissa
.1a5b3a	c2 20		rep #$20	            REP #$20
.1a5b3c	20 04 5c	jsr $1a5c04	            JSR ITOF
.1a5b3f	c2 20		rep #$20	            REP #$20
.1a5b41	a5 23		lda $0823	            LDA ARGUMENT1
.1a5b43	85 55		sta $0855	            STA MARG1
.1a5b45	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5b47	85 57		sta $0857	            STA MARG1+2
.1a5b49	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the decimal
.1a5b4b	64 25		stz $0825	                STZ ARGUMENT1+2
.1a5b4d	e2 20		sep #$20	            SEP #$20
.1a5b4f	80 36		bra $1a5b87	                BRA s8_drop
.1a5b51					s8_shift
.1a5b51	20 c8 58	jsr $1a58c8	            JSR SHIFTDEC
.1a5b54	c2 20		rep #$20	            REP #$20
.1a5b56	a5 5f		lda $085f	                LDA MARG3+2             ; high 16 bits
.1a5b58	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.1a5b5c	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.1a5b5f	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.1a5b63	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to high 16 bits of MARG3
.1a5b67	85 5f		sta $085f	                STA MARG3+2
.1a5b69	a5 5d		lda $085d	                LDA MARG3
.1a5b6b	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.1a5b6f	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.1a5b72	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.1a5b76	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to MARG3
.1a5b7a	85 5d		sta $085d	                STA MARG3
.1a5b7c	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.1a5b80	18		clc		                CLC
.1a5b81	65 5f		adc $085f	                ADC MARG3+2
.1a5b83	85 5f		sta $085f	                STA MARG3+2
.1a5b85	e2 20		sep #$20	            SEP #$20
.1a5b87					s8_drop
.1a5b87	c8		iny		                INY
.1a5b88	b7 00		lda [$0800],y	                LDA [BIP],Y
.1a5b8a	c9 65		cmp #$65	                CMP #'e'                ; 'E' --> S9, drop
.1a5b8c	f0 24		beq $1a5bb2	                BEQ s9_drop
.1a5b8e	c9 45		cmp #$45	                CMP #'E'
.1a5b90	f0 20		beq $1a5bb2	                BEQ s9_drop
.1a5b92	20 fb 04	jsr $1a04fb	            JSR ISNUMERAL
.1a5b95	b0 ba		bcs $1a5b51	                BCS s8_shift
.1a5b97	c2 20		rep #$20	            REP #$20
.1a5b99	20 04 5c	jsr $1a5c04	            JSR ITOF
.1a5b9c	c2 20		rep #$20	            REP #$20
.1a5b9e	a5 23		lda $0823	            LDA ARGUMENT1
.1a5ba0	85 59		sta $0859	            STA MARG2
.1a5ba2	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5ba4	85 5b		sta $085b	            STA MARG2+2
.1a5ba6	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.1a5ba8	64 25		stz $0825	                STZ ARGUMENT1+2
.1a5baa	20 eb 59	jsr $1a59eb	            JSR PACKFLOAT
.1a5bad	e2 20		sep #$20	            SEP #$20
.1a5baf	82 43 ff	brl $1a5af5	                BRL stop
.1a5bb2					s9_drop
.1a5bb2	c2 20		rep #$20	            REP #$20
.1a5bb4	20 04 5c	jsr $1a5c04	            JSR ITOF
.1a5bb7	c2 20		rep #$20	            REP #$20
.1a5bb9	a5 23		lda $0823	            LDA ARGUMENT1
.1a5bbb	85 59		sta $0859	            STA MARG2
.1a5bbd	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5bbf	85 5b		sta $085b	            STA MARG2+2
.1a5bc1	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.1a5bc3	64 25		stz $0825	                STZ ARGUMENT1+2
.1a5bc5	e2 20		sep #$20	            SEP #$20
.1a5bc7	c8		iny		                INY
.1a5bc8	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5bca	c9 2b		cmp #$2b	                CMP #'+'
.1a5bcc	f0 10		beq $1a5bde	                BEQ s10_drop            ; '+' --> S10, drop
.1a5bce	c9 2d		cmp #$2d	                CMP #'-'
.1a5bd0	f0 08		beq $1a5bda	                BEQ s10_setneg          ; '-' --> S10, set exponent is negative
.1a5bd2	20 fb 04	jsr $1a04fb	            JSR ISNUMERAL
.1a5bd5	b0 12		bcs $1a5be9	                BCS S11_shift           ; '0'-'9' --> S11, shift
.1a5bd7	82 a2 fe	brl $1a5a7c	                BRL syntax_err
.1a5bda					s10_setneg
.1a5bda	a9 01		lda #$01	                LDA #1                  ; Set that the exponent should be negative
.1a5bdc	85 69		sta $0869	                STA MARG6
.1a5bde					s10_drop
.1a5bde	c8		iny		                INY
.1a5bdf	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5be1	20 fb 04	jsr $1a04fb	            JSR ISNUMERAL
.1a5be4	b0 03		bcs $1a5be9	                BCS s11_shift
.1a5be6	82 93 fe	brl $1a5a7c	                BRL syntax_err
.1a5be9					s11_shift
.1a5be9	20 c8 58	jsr $1a58c8	            JSR SHIFTDEC
.1a5bec	c8		iny		                INY
.1a5bed	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5bef	20 fb 04	jsr $1a04fb	            JSR ISNUMERAL
.1a5bf2	b0 f5		bcs $1a5be9	                BCS s11_shift
.1a5bf4	c2 20		rep #$20	            REP #$20
.1a5bf6	a5 23		lda $0823	            LDA ARGUMENT1
.1a5bf8	85 61		sta $0861	            STA MARG4
.1a5bfa	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5bfc	85 63		sta $0863	            STA MARG4+2
.1a5bfe	20 eb 59	jsr $1a59eb	            JSR PACKFLOAT
.1a5c01	82 f1 fe	brl $1a5af5	                BRL stop
.1a5c04					ITOF
.1a5c04	08		php		                PHP
.1a5c05	20 92 56	jsr $1a5692	            JSR FIXINT_TO_FP
.1a5c08	28		plp		done            PLP
.1a5c09	60		rts		            RTS
.1a5c0a					FTOI
.1a5c0a	08		php		                PHP
.1a5c0b					LOCALS
>0001					l_sign          .byte ?
>0002					l_exponent      .byte ?
>0003					l_mantissa      .dword ?
.1a5c0b	c2 20		rep #$20	            REP #$20
.1a5c0d	a9 01 5f	lda #$5f01	                LDA #<>FP_1_0
.1a5c10	85 29		sta $0829	                STA ARGUMENT2
.1a5c12	a9 1a 00	lda #$001a	                LDA #(FP_1_0 >> 16)
.1a5c15	85 2b		sta $082b	                STA ARGUMENT2+2
.1a5c17	e2 20		sep #$20	            SEP #$20
.1a5c19	a9 01		lda #$01	                LDA #TYPE_FLOAT
.1a5c1b	85 2d		sta $082d	                STA ARGTYPE2
.1a5c1d	c2 20		rep #$20	            REP #$20
.1a5c1f	20 dd 5c	jsr $1a5cdd	            JSR FP_COMPARE
.1a5c22	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a5c25	d0 0c		bne $1a5c33	                BNE alloc_locals        ; No: get ready to do the full conversion
.1a5c27	a9 00 00	lda #$0000	                LDA #0
.1a5c2a	8d 23 08	sta $0823	                STA @w ARGUMENT1        ; Yes: Return 0
.1a5c2d	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.1a5c30	82 a1 00	brl $1a5cd4	                BRL done
.1a5c33	f4 00 00	pea #$0000	alloc_locals    PEA #0                  ; Reserve space for the locals
.1a5c36	f4 00 00	pea #$0000	                PEA #0
.1a5c39	f4 00 00	pea #$0000	                PEA #0
.1a5c3c	e2 20		sep #$20	            SEP #$20
.1a5c3e	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3      ; Preserve the sign bit
.1a5c41	29 80		and #$80	                AND #$80
.1a5c43	83 01		sta $01,s	                STA l_sign
.1a5c45	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2      ; Preserve the exponent
.1a5c48	2a		rol a		                ROL A
.1a5c49	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3
.1a5c4c	2a		rol a		                ROL A
.1a5c4d	83 02		sta $02,s	                STA l_exponent
.1a5c4f	a9 00		lda #$00	save_mantissa   LDA #0                  ; Save the mantissa (with the implied 1)
.1a5c51	83 06		sta $06,s	                STA l_mantissa+3
.1a5c53	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2
.1a5c56	09 80		ora #$80	                ORA #$80
.1a5c58	83 05		sta $05,s	                STA l_mantissa+2
.1a5c5a	ad 24 08	lda $0824	                LDA @w ARGUMENT1+1
.1a5c5d	83 04		sta $04,s	                STA l_mantissa+1
.1a5c5f	ad 23 08	lda $0823	                LDA @w ARGUMENT1
.1a5c62	83 03		sta $03,s	                STA l_mantissa
.1a5c64	a3 02		lda $02,s	                LDA l_exponent
.1a5c66	c9 96		cmp #$96	loop            CMP #150
.1a5c68	f0 3a		beq $1a5ca4	                BEQ adj_sign
.1a5c6a	90 1f		bcc $1a5c8b	                BLT shift_right
.1a5c6c	08		php		            PHP
.1a5c6d	c2 20		rep #$20	            REP #$20
.1a5c6f	48		pha		            PHA
.1a5c70	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5c73	5b		tcd		            TCD
.1a5c74	68		pla		            PLA
.1a5c75	28		plp		            PLP
.1a5c76	e2 20		sep #$20	            SEP #$20
.1a5c78	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.1a5c7a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5c7e	c2 20		rep #$20	            REP #$20
.1a5c80	29 ff 00	and #$00ff	            AND #$00FF
.1a5c83	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a5c86	e2 20		sep #$20	            SEP #$20
.1a5c88	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5c8b					shift_right
.1a5c8b	c2 20		rep #$20	            REP #$20
.1a5c8d	a3 05		lda $05,s	                LDA l_mantissa+2
.1a5c8f	4a		lsr a		                LSR A
.1a5c90	83 05		sta $05,s	                STA l_mantissa+2
.1a5c92	a3 03		lda $03,s	                LDA l_mantissa
.1a5c94	6a		ror a		                ROR A
.1a5c95	83 03		sta $03,s	                STA l_mantissa
.1a5c97	e2 20		sep #$20	            SEP #$20
.1a5c99	a3 02		lda $02,s	                LDA l_exponent
.1a5c9b	1a		inc a		                INC A
.1a5c9c	83 02		sta $02,s	                STA l_exponent
.1a5c9e	c9 96		cmp #$96	                CMP #150
.1a5ca0	f0 02		beq $1a5ca4	                BEQ adj_sign
.1a5ca2	80 e7		bra $1a5c8b	                BRA shift_right
.1a5ca4	a3 01		lda $01,s	adj_sign        LDA l_sign
.1a5ca6	f0 1b		beq $1a5cc3	                BEQ ret_positive
.1a5ca8	c2 20		rep #$20	            REP #$20
.1a5caa	a3 03		lda $03,s	                LDA l_mantissa
.1a5cac	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a5caf	18		clc		                CLC
.1a5cb0	69 01 00	adc #$0001	                ADC #1
.1a5cb3	8d 23 08	sta $0823	                STA @w ARGUMENT1
.1a5cb6	a3 05		lda $05,s	                LDA l_mantissa+2
.1a5cb8	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a5cbb	69 00 00	adc #$0000	                ADC #0
.1a5cbe	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.1a5cc1	80 0c		bra $1a5ccf	                BRA clean
.1a5cc3					ret_positive
.1a5cc3	c2 20		rep #$20	            REP #$20
.1a5cc5	a3 03		lda $03,s	                LDA l_mantissa
.1a5cc7	8d 23 08	sta $0823	                STA @w ARGUMENT1
.1a5cca	a3 05		lda $05,s	                LDA l_mantissa+2
.1a5ccc	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.1a5ccf					clean
.1a5ccf	c2 20		rep #$20	            REP #$20
.1a5cd1	68		pla		                PLA                     ; Clean up the locals
.1a5cd2	68		pla		                PLA
.1a5cd3	68		pla		                PLA
.1a5cd4					done
.1a5cd4	e2 20		sep #$20	            SEP #$20
.1a5cd6	a9 00		lda #$00	                LDA #TYPE_INTEGER       ; Set the return type to integer
.1a5cd8	8d 27 08	sta $0827	                STA @w ARGTYPE1
.1a5cdb	28		plp		                PLP
.1a5cdc	60		rts		            RTS
.1a5cdd					FP_COMPARE
.1a5cdd	da		phx		                PHX
.1a5cde	08		php		                PHP
.1a5cdf	c2 20		rep #$20	            REP #$20
.1a5ce1	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save ARGUMENT1 so we don't destroy it
.1a5ce3	48		pha		                PHA
.1a5ce4	a5 23		lda $0823	                LDA ARGUMENT1
.1a5ce6	48		pha		                PHA
.1a5ce7	20 d6 56	jsr $1a56d6	            JSR OP_FP_SUB
.1a5cea	20 b4 58	jsr $1a58b4	            JSR FARG1EQ0
.1a5ced	b0 11		bcs $1a5d00	                BCS are_equal
.1a5cef	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Check the high word
.1a5cf1	89 00 80	bit #$8000	                BIT #$8000
.1a5cf4	d0 05		bne $1a5cfb	                BNE is_lt                   ; ARGUMENT1 < ARGUMENT2
.1a5cf6	a9 01 00	lda #$0001	is_gt           LDA #1                      ; ARGUMENT1 > ARGUMENT2: return 1
.1a5cf9	80 08		bra $1a5d03	                BRA ret_result
.1a5cfb	a9 ff ff	lda #$ffff	is_lt           LDA #$FFFF                  ; ARGUMENT1 > ARGUMENT2: return -1
.1a5cfe	80 03		bra $1a5d03	                BRA ret_result
.1a5d00	a9 00 00	lda #$0000	are_equal       LDA #0                      ; Equal: return 0
.1a5d03	fa		plx		ret_result      PLX                         ; Restore ARGUMENT1
.1a5d04	86 23		stx $0823	                STX ARGUMENT1
.1a5d06	fa		plx		                PLX
.1a5d07	86 25		stx $0825	                STX ARGUMENT1+2
.1a5d09	28		plp		                PLP
.1a5d0a	fa		plx		                PLX
.1a5d0b	60		rts		            RTS
.1a5d0c					OP_FP_LT
.1a5d0c	08		php		                PHP
.1a5d0d	c2 30		rep #$30	            REP #$30
.1a5d0f	20 dd 5c	jsr $1a5cdd	            JSR FP_COMPARE
.1a5d12	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a5d15	d0 05		bne $1a5d1c	                BNE ret_false
.1a5d17	20 2d 06	jsr $1a062d	            JSR SET_TRUE
.1a5d1a	80 03		bra $1a5d1f	                BRA done
.1a5d1c					ret_false
.1a5d1c	20 3f 06	jsr $1a063f	            JSR SET_FALSE
.1a5d1f	28		plp		done            PLP
.1a5d20	60		rts		            RTS
.1a5d21					OP_FP_GT
.1a5d21	08		php		                PHP
.1a5d22	c2 30		rep #$30	            REP #$30
.1a5d24	20 dd 5c	jsr $1a5cdd	            JSR FP_COMPARE
.1a5d27	c9 01 00	cmp #$0001	                CMP #1
.1a5d2a	d0 05		bne $1a5d31	                BNE ret_false
.1a5d2c	20 2d 06	jsr $1a062d	            JSR SET_TRUE
.1a5d2f	80 03		bra $1a5d34	                BRA done
.1a5d31					ret_false
.1a5d31	20 3f 06	jsr $1a063f	            JSR SET_FALSE
.1a5d34	28		plp		done            PLP
.1a5d35	60		rts		            RTS
.1a5d36					OP_FP_EQ
.1a5d36	08		php		                PHP
.1a5d37	c2 30		rep #$30	            REP #$30
.1a5d39	20 dd 5c	jsr $1a5cdd	            JSR FP_COMPARE
.1a5d3c	c9 00 00	cmp #$0000	                CMP #0
.1a5d3f	d0 05		bne $1a5d46	                BNE ret_false
.1a5d41	20 2d 06	jsr $1a062d	            JSR SET_TRUE
.1a5d44	80 03		bra $1a5d49	                BRA done
.1a5d46					ret_false
.1a5d46	20 3f 06	jsr $1a063f	            JSR SET_FALSE
.1a5d49	28		plp		done            PLP
.1a5d4a	60		rts		            RTS
.1a5d4b					OP_FP_LTE
.1a5d4b	08		php		                PHP
.1a5d4c	c2 30		rep #$30	            REP #$30
.1a5d4e	20 dd 5c	jsr $1a5cdd	            JSR FP_COMPARE
.1a5d51	c9 01 00	cmp #$0001	                CMP #1
.1a5d54	f0 05		beq $1a5d5b	                BEQ ret_false
.1a5d56	20 2d 06	jsr $1a062d	            JSR SET_TRUE
.1a5d59	80 03		bra $1a5d5e	                BRA done
.1a5d5b					ret_false
.1a5d5b	20 3f 06	jsr $1a063f	            JSR SET_FALSE
.1a5d5e	28		plp		done            PLP
.1a5d5f	60		rts		            RTS
.1a5d60					OP_FP_GTE
.1a5d60	08		php		                PHP
.1a5d61	c2 30		rep #$30	            REP #$30
.1a5d63	20 dd 5c	jsr $1a5cdd	            JSR FP_COMPARE
.1a5d66	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a5d69	f0 05		beq $1a5d70	                BEQ ret_false
.1a5d6b	20 2d 06	jsr $1a062d	            JSR SET_TRUE
.1a5d6e	80 03		bra $1a5d73	                BRA done
.1a5d70					ret_false
.1a5d70	20 3f 06	jsr $1a063f	            JSR SET_FALSE
.1a5d73	28		plp		done            PLP
.1a5d74	60		rts		            RTS
.1a5d75					OP_FP_NE
.1a5d75	08		php		                PHP
.1a5d76	c2 30		rep #$30	            REP #$30
.1a5d78	20 dd 5c	jsr $1a5cdd	            JSR FP_COMPARE
.1a5d7b	c9 00 00	cmp #$0000	                CMP #0
.1a5d7e	f0 05		beq $1a5d85	                BEQ ret_false
.1a5d80	20 2d 06	jsr $1a062d	            JSR SET_TRUE
.1a5d83	80 03		bra $1a5d88	                BRA done
.1a5d85					ret_false
.1a5d85	20 3f 06	jsr $1a063f	            JSR SET_FALSE
.1a5d88	28		plp		done            PLP
.1a5d89	60		rts		            RTS
.1a5d8a					STREMIT
.1a5d8a	08		php		                PHP
.1a5d8b	e2 20		sep #$20	            SEP #$20
.1a5d8d	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Append the character
.1a5d8f	c8		iny		                INY                         ; Advance the character pointer in Y
.1a5d90	a9 00		lda #$00	                LDA #0                      ; And add the NULL
.1a5d92	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.1a5d94	28		plp		                PLP
.1a5d95	60		rts		            RTS
.1a5d96					STREMITB
.1a5d96	da		phx		                PHX
.1a5d97	08		php		                PHP
.1a5d98	e2 20		sep #$20	            SEP #$20
.1a5d9a	c9 80		cmp #$80	                CMP #$80
.1a5d9c	90 0a		bcc $1a5da8	                BLT emit_digits
.1a5d9e	48		pha		                PHA
.1a5d9f	a9 2d		lda #$2d	                LDA #'-'                    ; Print a minus sign
.1a5da1	20 8a 5d	jsr $1a5d8a	            JSR STREMIT
.1a5da4	68		pla		                PLA
.1a5da5	49 ff		eor #$ff	                EOR #$FF                    ; And negate it
.1a5da7	1a		inc a		                INC A
.1a5da8					emit_digits
.1a5da8	c2 30		rep #$30	            REP #$30
.1a5daa	29 ff 00	and #$00ff	                AND #$00FF
.1a5dad	c9 64 00	cmp #$0064	                CMP #100
.1a5db0	90 0e		bcc $1a5dc0	                BLT chk_tens
.1a5db2	a2 64 00	ldx #$0064	                LDX #100
.1a5db5	20 7b 56	jsr $1a567b	            JSR UINT_DIV_A_X
.1a5db8	18		clc		                CLC
.1a5db9	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.1a5dbc	20 8a 5d	jsr $1a5d8a	            JSR STREMIT
.1a5dbf	8a		txa		                TXA                         ; Put the remainder in A
.1a5dc0					chk_tens
.1a5dc0	a2 0a 00	ldx #$000a	                LDX #10
.1a5dc3	20 7b 56	jsr $1a567b	            JSR UINT_DIV_A_X
.1a5dc6	18		clc		                CLC
.1a5dc7	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.1a5dca	20 8a 5d	jsr $1a5d8a	            JSR STREMIT
.1a5dcd	8a		txa		                TXA                         ; Put the remainder in A
.1a5dce					ones_digit
.1a5dce	18		clc		                CLC
.1a5dcf	69 30 00	adc #$0030	                ADC #'0'                    ; Convert it to ASCII
.1a5dd2	20 8a 5d	jsr $1a5d8a	            JSR STREMIT
.1a5dd5	28		plp		                PLP
.1a5dd6	fa		plx		                PLX
.1a5dd7	60		rts		            RTS
.1a5dd8					STRFINDEND
.1a5dd8	08		php		                PHP
.1a5dd9	e2 20		sep #$20	            SEP #$20
.1a5ddb	c2 10		rep #$10	            REP #$10
.1a5ddd	a0 00 00	ldy #$0000	                LDY #0
.1a5de0	b7 23		lda [$0823],y	find_end        LDA [ARGUMENT1],Y           ; Scan to the end of the string
.1a5de2	f0 03		beq $1a5de7	                BEQ done
.1a5de4	c8		iny		                INY
.1a5de5	80 f9		bra $1a5de0	                BRA find_end
.1a5de7	28		plp		done            PLP
.1a5de8	60		rts		            RTS
=6					FP_D = 6        ; Number of mantissa digits
.1a5de9					FTOS
.1a5de9	08		php		                PHP
.1a5dea	e2 20		sep #$20	            SEP #$20
.1a5dec	c2 10		rep #$10	            REP #$10
.1a5dee	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be the negative flag
.1a5df1	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be K
.1a5df4	f4 00 00	pea #$0000	                PEA #0                      ; This spot will be for the exponents
>0001					L_NEGATIVE      .word ?
>0003					L_K             .word ?
>0005					L_X1            .byte ?                     ; The binary exponent
>0006					L_EXP           .byte ?                     ; The decimal exponent
.1a5df7	20 b4 58	jsr $1a58b4	            JSR FARG1EQ0
.1a5dfa	90 19		bcc $1a5e15	                BCC chk_negative
.1a5dfc	20 01 15	jsr $1a1501	            JSR TEMPSTRING
.1a5dff	e2 20		sep #$20	            SEP #$20
.1a5e01	a0 00 00	ldy #$0000	                LDY #0
.1a5e04	a9 20		lda #$20	                LDA #' '
.1a5e06	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a5e08	c8		iny		                INY
.1a5e09	a9 30		lda #$30	                LDA #'0'                    ; Return a "0"
.1a5e0b	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a5e0d	c8		iny		                INY
.1a5e0e	a9 00		lda #$00	                LDA #0
.1a5e10	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a5e12	82 ce 00	brl $1a5ee3	                BRL ret_result
.1a5e15					chk_negative
.1a5e15	e2 20		sep #$20	            SEP #$20
.1a5e17	a5 26		lda $0826	                LDA ARGUMENT1+3             ; If N is negative, output a minus sign and negate N
.1a5e19	10 08		bpl $1a5e23	                BPL not_negative
.1a5e1b	29 7f		and #$7f	                AND #$7F                    ; Negate the number
.1a5e1d	85 26		sta $0826	                STA ARGUMENT1+3
.1a5e1f	a9 01		lda #$01	                LDA #1
.1a5e21	83 01		sta $01,s	                STA L_NEGATIVE              ; Set IsNegative to a TRUE value
.1a5e23					not_negative
.1a5e23	c2 20		rep #$20	            REP #$20
.1a5e25	a9 00 00	lda #$0000	                LDA #0                      ; Initialize K to 0, K is a 1-byte signed integer. (SCRATCH is K)
.1a5e28	83 03		sta $03,s	                STA L_K                     ; We're using a word here for convenience
.1a5e2a	c2 20		rep #$20	            REP #$20
.1a5e2c	af fd 5e 1a	lda $1a5efd	            LDA ten_d_1
.1a5e30	85 29		sta $0829	            STA ARGUMENT2
.1a5e32	af ff 5e 1a	lda $1a5eff	            LDA ten_d_1+2
.1a5e36	85 2b		sta $082b	            STA ARGUMENT2+2
.1a5e38	20 dd 5c	jsr $1a5cdd	            JSR FP_COMPARE
.1a5e3b	89 00 80	bit #$8000	                BIT #$8000                  ; Is N < 10^(D-1)?
.1a5e3e	d0 12		bne $1a5e52	                BNE shift_up
.1a5e40					shift_down
.1a5e40	20 78 58	jsr $1a5878	            JSR FP_DIV10
.1a5e43	a3 03		lda $03,s	                LDA L_K
.1a5e45	1a		inc a		                INC A
.1a5e46	83 03		sta $03,s	                STA L_K                     ; Increment K
.1a5e48	20 dd 5c	jsr $1a5cdd	            JSR FP_COMPARE
.1a5e4b	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N < 10^(D-1)?
.1a5e4e	f0 12		beq $1a5e62	                BEQ do_digits               ; Yes: we're ready to process digits
.1a5e50	80 ee		bra $1a5e40	                BRA shift_down              ; No: keep dividing
.1a5e52					shift_up
.1a5e52	20 2f 58	jsr $1a582f	            JSR FP_MUL10
.1a5e55	a3 03		lda $03,s	                LDA L_K
.1a5e57	3a		dec a		                DEC A
.1a5e58	83 03		sta $03,s	                STA L_K                     ; Decrement K
.1a5e5a	20 dd 5c	jsr $1a5cdd	            JSR FP_COMPARE
.1a5e5d	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N >= 10 ^ (D-1)?
.1a5e60	f0 f0		beq $1a5e52	                BEQ shift_up                ; No: keep multiplying
.1a5e62					do_digits
.1a5e62	e2 30		sep #$30	            SEP #$30
.1a5e64	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5e66	0a		asl a		                ASL A
.1a5e67	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a5e69	2a		rol a		                ROL A
.1a5e6a	83 05		sta $05,s	                STA L_X1
.1a5e6c	38		sec		                SEC
.1a5e6d	a9 96		lda #$96	                LDA #150                    ; X := 150 - X1
.1a5e6f	e3 05		sbc $05,s	                SBC L_X1
.1a5e71	aa		tax		                TAX
.1a5e72	f0 0f		beq $1a5e83	                BEQ emit_digits             ; If X = 0, just emit the digits
.1a5e74	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Set the implied '1' MSB of the mantissa
.1a5e76	09 80		ora #$80	                ORA #$80
.1a5e78	85 25		sta $0825	                STA ARGUMENT1+2
.1a5e7a	46 25		lsr $0825	shift_r         LSR ARGUMENT1+2             ; Shift the mantissa right
.1a5e7c	66 24		ror $0824	                ROR ARGUMENT1+1
.1a5e7e	66 23		ror $0823	                ROR ARGUMENT1
.1a5e80	ca		dex		                DEX
.1a5e81	d0 f7		bne $1a5e7a	                BNE shift_r                 ; Until X = 0
.1a5e83					emit_digits
.1a5e83	c2 10		rep #$10	            REP #$10
.1a5e85	e2 20		sep #$20	            SEP #$20
.1a5e87	64 26		stz $0826	                STZ ARGUMENT1+3             ; Blank out the MSB
.1a5e89	a9 00		lda #$00	                LDA #TYPE_INTEGER           ; Make it an integer
.1a5e8b	85 27		sta $0827	                STA ARGTYPE1
.1a5e8d	a3 01		lda $01,s	                LDA L_NEGATIVE              ; Check IsNegative
.1a5e8f	f0 11		beq $1a5ea2	                BEQ get_raw_digits          ; If FALSE, just convert the raw digits
.1a5e91	c2 20		rep #$20	            REP #$20
.1a5e93	38		sec		                SEC                         ; Make the raw integer negative
.1a5e94	a9 00 00	lda #$0000	                LDA #0
.1a5e97	e5 23		sbc $0823	                SBC ARGUMENT1
.1a5e99	85 23		sta $0823	                STA ARGUMENT1
.1a5e9b	a9 00 00	lda #$0000	                LDA #0
.1a5e9e	e5 25		sbc $0825	                SBC ARGUMENT1+2
.1a5ea0	85 25		sta $0825	                STA ARGUMENT1+2
.1a5ea2					get_raw_digits
.1a5ea2	20 60 15	jsr $1a1560	            JSR ITOS
.1a5ea5	c2 20		rep #$20	            REP #$20
.1a5ea7	a5 16		lda $0816	            LDA STRPTR
.1a5ea9	85 23		sta $0823	            STA ARGUMENT1
.1a5eab	a5 18		lda $0818	            LDA STRPTR+2
.1a5ead	85 25		sta $0825	            STA ARGUMENT1+2
.1a5eaf	20 d8 5d	jsr $1a5dd8	            JSR STRFINDEND
.1a5eb2	e2 20		sep #$20	            SEP #$20
.1a5eb4	c8		iny		                INY                         ; Move the NULL up one byte
.1a5eb5	a9 00		lda #$00	                LDA #0
.1a5eb7	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.1a5eb9	88		dey		insert_loop     DEY                         ; Move to the character before the one we just moved
.1a5eba	88		dey		                DEY
.1a5ebb	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y           ; Get the character
.1a5ebd	c8		iny		                INY                         ; Move to the next space
.1a5ebe	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Store the character here
.1a5ec0	c0 02 00	cpy #$0002	                CPY #2                      ; Check to see if we just moved the 2nd character
.1a5ec3	d0 f4		bne $1a5eb9	                BNE insert_loop             ; If not, keep moving the characters
.1a5ec5	a9 2e		lda #$2e	                LDA #'.'                    ; Insert the '.' in the space we openned
.1a5ec7	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.1a5ec9	e2 20		sep #$20	            SEP #$20
.1a5ecb	18		clc		                CLC                         ; Compute the exponent
.1a5ecc	a3 03		lda $03,s	                LDA L_K
.1a5ece	69 05		adc #$05	                ADC #(FP_D - 1)
.1a5ed0	83 06		sta $06,s	                STA L_EXP
.1a5ed2	f0 19		beq $1a5eed	                BEQ done                    ; If it's 0, just return the number
.1a5ed4	20 d8 5d	jsr $1a5dd8	            JSR STRFINDEND
.1a5ed7	a9 45		lda #$45	                LDA #'E'                    ; Append the "E"
.1a5ed9	20 8a 5d	jsr $1a5d8a	            JSR STREMIT
.1a5edc	a3 06		lda $06,s	                LDA L_EXP
.1a5ede	20 96 5d	jsr $1a5d96	            JSR STREMITB
.1a5ee1	80 0a		bra $1a5eed	                BRA done                    ; TODO: reformat integer... add E and exponent...
.1a5ee3					ret_result
.1a5ee3	c2 20		rep #$20	            REP #$20
.1a5ee5	a5 16		lda $0816	                LDA STRPTR                  ; Return the temporary string we've assembled
.1a5ee7	85 23		sta $0823	                STA ARGUMENT1
.1a5ee9	a5 18		lda $0818	                LDA STRPTR+2
.1a5eeb	85 25		sta $0825	                STA ARGUMENT1+2
.1a5eed					done
.1a5eed	e2 20		sep #$20	            SEP #$20
.1a5eef	a9 02		lda #$02	                LDA #TYPE_STRING
.1a5ef1	85 27		sta $0827	                STA ARGTYPE1
.1a5ef3	c2 20		rep #$20	            REP #$20
.1a5ef5	3b		tsc		                TSC                         ; Remove the locals from the stack
.1a5ef6	18		clc		                CLC
.1a5ef7	69 06 00	adc #$0006	                ADC #6
.1a5efa	1b		tcs		                TCS
.1a5efb	28		plp		                PLP
.1a5efc	60		rts		            RTS
>1a5efd	00 50 c3 47			ten_d_1         .dword $47c35000            ; 10^(FP_D-1), where FP_D=5
>1a5f01	00 00 80 3f			FP_1_0          .dword $3f800000    ; Floating point constant: 1.0
>1a5f05	f3 04 b5 3f			FP_SQR_2_0      .dword $3fb504f3    ; Floating point constant: sqrt(2.0)
>1a5f09	f3 04 35 3f			FP_SQR_0_5      .dword $3f3504f3    ; Floating point constant: sqrt(0.2)

;******  Return to file: src\basic816.s


;******  Processing file: src\transcendentals.s

.1a5f0d					Q_POLY_HR
.1a5f0d	e2 20		sep #$20	            SEP #$20
.1a5f0f	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a5f11	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5f15	c2 20		rep #$20	            REP #$20
.1a5f17	bd 00 00	lda $0000,x	                LDA 0,X
.1a5f1a	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5f1e	bd 02 00	lda $0002,x	                LDA 2,X
.1a5f21	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5f25	88		dey		                DEY             ; (Y-1) more coefficients.
.1a5f26	e8		inx		loop            INX             ; point to the next coefficient
.1a5f27	e8		inx		                INX
.1a5f28	e8		inx		                INX
.1a5f29	e8		inx		                INX
.1a5f2a	e2 20		sep #$20	            SEP #$20
.1a5f2c	a9 00		lda #$00	                LDA #FP_OUT_MULT
.1a5f2e	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5f32	c2 20		rep #$20	            REP #$20
.1a5f34	af 23 08 00	lda $000823	                LDA @l ARGUMENT1
.1a5f38	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5f3c	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a5f40	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5f44	ea		nop		                NOP
.1a5f45	ea		nop		                NOP
.1a5f46	ea		nop		                NOP
.1a5f47	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5f4b	48		pha		                PHA
.1a5f4c	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5f50	8f 0a e2 af	sta $afe20a	                STA FP_MATH_INPUT0_HL
.1a5f54	68		pla		                PLA
.1a5f55	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5f59	e2 20		sep #$20	            SEP #$20
.1a5f5b	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a5f5d	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5f61	c2 20		rep #$20	            REP #$20
.1a5f63	bd 00 00	lda $0000,x	                LDA 0,X
.1a5f66	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5f6a	bd 02 00	lda $0002,x	                LDA 2,X
.1a5f6d	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5f71	ea		nop		                NOP
.1a5f72	ea		nop		                NOP
.1a5f73	ea		nop		                NOP
.1a5f74	88		dey		                DEY
.1a5f75	f0 14		beq $1a5f8b	                BEQ done
.1a5f77	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5f7b	48		pha		                PHA
.1a5f7c	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5f80	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5f84	68		pla		                PLA
.1a5f85	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5f89	80 9b		bra $1a5f26	                BRA loop
.1a5f8b	af 08 e2 af	lda $afe208	done            LDA @l FP_MATH_OUTPUT_FP_LL
.1a5f8f	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.1a5f93	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5f97	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.1a5f9b	60		rts		                RTS
.1a5f9c					Q_SQ
.1a5f9c	e2 20		sep #$20	            SEP #$20
.1a5f9e	a9 00		lda #$00	                LDA #0
.1a5fa0	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5fa4	a9 00		lda #$00	                LDA #FP_OUT_MULT
.1a5fa6	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5faa	c2 20		rep #$20	            REP #$20
.1a5fac	a5 23		lda $0823	                LDA ARGUMENT1
.1a5fae	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5fb2	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5fb6	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a5fba	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5fbe	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5fc2	ea		nop		                NOP
.1a5fc3	ea		nop		                NOP
.1a5fc4	ea		nop		                NOP
.1a5fc5	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5fc9	85 23		sta $0823	                STA ARGUMENT1
.1a5fcb	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5fcf	85 25		sta $0825	                STA ARGUMENT1+2
.1a5fd1	60		rts		                RTS
.1a5fd2					Q_INV
.1a5fd2	e2 20		sep #$20	            SEP #$20
.1a5fd4	a9 00		lda #$00	                LDA #0
.1a5fd6	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5fda	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a5fdc	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5fe0	c2 20		rep #$20	            REP #$20
.1a5fe2	a5 23		lda $0823	                LDA ARGUMENT1
.1a5fe4	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5fe8	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a5fec	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5ff0	af 26 66 1a	lda $1a6626	                LDA @l fp_one
.1a5ff4	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5ff8	af 28 66 1a	lda $1a6628	                LDA @l fp_one+2
.1a5ffc	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a6000	ea		nop		                NOP
.1a6001	ea		nop		                NOP
.1a6002	ea		nop		                NOP
.1a6003	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a6007	85 23		sta $0823	                STA ARGUMENT1
.1a6009	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a600d	85 25		sta $0825	                STA ARGUMENT1+2
.1a600f	60		rts		                RTS
.1a6010					Q_FP_SCALE
.1a6010	a2 00 00	ldx #$0000	                LDX #0
.1a6013	a5 23		lda $0823	loop            LDA ARGUMENT1
.1a6015	c5 29		cmp $0829	                CMP ARGUMENT2
.1a6017	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6019	e5 2b		sbc $082b	                SBC ARGUMENT2+2
.1a601b	90 1e		bcc $1a603b	                BCC done
.1a601d	a5 23		lda $0823	                LDA ARGUMENT1
.1a601f	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a6023	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6025	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a6029	ea		nop		                NOP
.1a602a	ea		nop		                NOP
.1a602b	ea		nop		                NOP
.1a602c	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a6030	85 23		sta $0823	                STA ARGUMENT1
.1a6032	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a6036	85 25		sta $0825	                STA ARGUMENT1+2
.1a6038	e8		inx		                INX
.1a6039	80 d8		bra $1a6013	                BRA loop
.1a603b					done
.1a603b	60		rts		            RTS
.1a603c					Q_FP_SCALE_TAU
.1a603c	e2 20		sep #$20	            SEP #$20
.1a603e	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a6040	10 09		bpl $1a604b	                BPL notneg
.1a6042	29 7f		and #$7f	                AND #$7F
.1a6044	85 26		sta $0826	                STA ARGUMENT1+3
.1a6046	a9 01		lda #$01	                LDA #1
.1a6048	48		pha		                PHA
.1a6049	80 03		bra $1a604e	                BRA compute
.1a604b	a9 00		lda #$00	notneg          LDA #0          ; not negative, so push 0.
.1a604d	48		pha		                PHA
.1a604e	a9 40		lda #$40	compute         LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a6050	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a6054	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a6056	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a605a	c2 30		rep #$30	            REP #$30
.1a605c	af 8e 66 1a	lda $1a668e	                LDA @l twopi
.1a6060	85 29		sta $0829	                STA ARGUMENT2
.1a6062	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a6066	af 90 66 1a	lda $1a6690	                LDA @l twopi+2
.1a606a	85 2b		sta $082b	                STA ARGUMENT2+2
.1a606c	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a6070	20 10 60	jsr $1a6010	            JSR Q_FP_SCALE
.1a6073	e2 20		sep #$20	            SEP #$20
.1a6075	68		pla		                PLA
.1a6076	c2 20		rep #$20	            REP #$20
.1a6078	f0 1e		beq $1a6098	                BEQ done
.1a607a	a5 23		lda $0823	                LDA ARGUMENT1
.1a607c	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a6080	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6082	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a6086	ea		nop		                NOP
.1a6087	ea		nop		                NOP
.1a6088	ea		nop		                NOP
.1a6089	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a608d	85 23		sta $0823	                STA ARGUMENT1
.1a608f	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a6093	29 ff 7f	and #$7fff	                AND #$7fff
.1a6096	85 25		sta $0825	                STA ARGUMENT1+2
.1a6098					done
.1a6098	60		rts		            RTS
.1a6099					Q_FP_NORM_ANGLE
.1a6099	5a		phy		                PHY
.1a609a	a2 00 00	ldx #$0000	                LDX #0
.1a609d	a0 00 00	ldy #$0000	                LDY #0
.1a60a0	a5 23		lda $0823	loop            LDA ARGUMENT1
.1a60a2	df 92 66 1a	cmp $1a6692,x	                CMP @l onepi,x
.1a60a6	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a60a8	ff 94 66 1a	sbc $1a6694,x	                SBC @l onepi+2,x
.1a60ac	90 2c		bcc $1a60da	                BCC less
.1a60ae	bf 8e 66 1a	lda $1a668e,x	                LDA @l twopi,x
.1a60b2	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a60b6	bf 90 66 1a	lda $1a6690,x	                LDA @l twopi+2,x
.1a60ba	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a60be	a5 23		lda $0823	                LDA ARGUMENT1
.1a60c0	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a60c4	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a60c6	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a60ca	ea		nop		                NOP
.1a60cb	ea		nop		                NOP
.1a60cc	ea		nop		                NOP
.1a60cd	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a60d1	85 23		sta $0823	                STA ARGUMENT1
.1a60d3	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a60d7	85 25		sta $0825	                STA ARGUMENT1+2
.1a60d9	38		sec		                SEC             ; set carry to indicate a reflection
.1a60da	98		tya		less            TYA             ; carry already cleared if we branched
.1a60db	2a		rol a		                ROL             ; shift carry into flags...
.1a60dc	a8		tay		                TAY             ; and store back into y
.1a60dd	e8		inx		                INX             ; next set of values
.1a60de	e8		inx		                INX
.1a60df	e8		inx		                INX
.1a60e0	e8		inx		                INX
.1a60e1	e0 0c 00	cpx #$000c	                CPX #12         ; check if we have already looked at 3
.1a60e4	d0 ba		bne $1a60a0	                BNE loop
.1a60e6	98		tya		                TYA             ; copy Y to X, as that's what we have
.1a60e7	aa		tax		                TAX
.1a60e8	7a		ply		                PLY
.1a60e9	60		rts		            RTS
.1a60ea					Q_FP_COS
.1a60ea	08		php		                PHP
.1a60eb	c2 30		rep #$30	            REP #$30
.1a60ed	48		pha		                PHA
.1a60ee	da		phx		                PHX
.1a60ef	20 9c 5f	jsr $1a5f9c	            JSR Q_SQ
.1a60f2	8b		phb		                PHB
.1a60f3	e2 20		sep #$20	            SEP #$20
.1a60f5	a9 1a		lda #$1a	                LDA #`cos_coeff
.1a60f7	48		pha		                PHA
.1a60f8	ab		plb		                PLB
.1a60f9	c2 20		rep #$20	            REP #$20
.1a60fb	a2 ce 65	ldx #$65ce	                LDX #<>cos_coeff
.1a60fe	5a		phy		                PHY
.1a60ff	a0 05 00	ldy #$0005	                LDY #5
.1a6102	20 0d 5f	jsr $1a5f0d	            JSR Q_POLY_HR
.1a6105	7a		ply		                PLY
.1a6106	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.1a6109	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.1a610d	ab		plb		                PLB
.1a610e	fa		plx		                PLX
.1a610f	68		pla		                PLA
.1a6110	28		plp		                PLP
.1a6111	60		rts		            RTS
.1a6112					Q_FP_SIN
.1a6112	08		php		                PHP
.1a6113	c2 30		rep #$30	            REP #$30
.1a6115	48		pha		                PHA
.1a6116	da		phx		                PHX
.1a6117	a5 23		lda $0823	                LDA ARGUMENT1
.1a6119	85 29		sta $0829	                STA ARGUMENT2
.1a611b	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a611d	85 2b		sta $082b	                STA ARGUMENT2+2
.1a611f	20 9c 5f	jsr $1a5f9c	            JSR Q_SQ
.1a6122	8b		phb		                PHB
.1a6123	e2 20		sep #$20	            SEP #$20
.1a6125	a9 1a		lda #$1a	                LDA #`sin_coeff
.1a6127	48		pha		                PHA
.1a6128	ab		plb		                PLB
.1a6129	c2 20		rep #$20	            REP #$20
.1a612b	a2 e2 65	ldx #$65e2	                LDX #<>sin_coeff
.1a612e	5a		phy		                PHY
.1a612f	a0 05 00	ldy #$0005	                LDY #5
.1a6132	20 0d 5f	jsr $1a5f0d	            JSR Q_POLY_HR
.1a6135	7a		ply		                PLY
.1a6136	ab		plb		                PLB
.1a6137	20 77 57	jsr $1a5777	            JSR OP_FP_MUL
.1a613a	fa		plx		                PLX
.1a613b	68		pla		                PLA
.1a613c	28		plp		                PLP
.1a613d	60		rts		            RTS
.1a613e					Q_FP_TAN
.1a613e	08		php		                PHP
.1a613f	c2 30		rep #$30	            REP #$30
.1a6141	48		pha		                PHA
.1a6142	da		phx		                PHX
.1a6143	a5 23		lda $0823	                LDA ARGUMENT1
.1a6145	85 29		sta $0829	                STA ARGUMENT2
.1a6147	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6149	85 2b		sta $082b	                STA ARGUMENT2+2
.1a614b	20 9c 5f	jsr $1a5f9c	            JSR Q_SQ
.1a614e	8b		phb		                PHB
.1a614f	e2 20		sep #$20	            SEP #$20
.1a6151	a9 1a		lda #$1a	                LDA #`tan_coeff
.1a6153	48		pha		                PHA
.1a6154	ab		plb		                PLB
.1a6155	c2 20		rep #$20	            REP #$20
.1a6157	a2 f6 65	ldx #$65f6	                LDX #<>tan_coeff
.1a615a	5a		phy		                PHY
.1a615b	a0 05 00	ldy #$0005	                LDY #5
.1a615e	20 0d 5f	jsr $1a5f0d	            JSR Q_POLY_HR
.1a6161	7a		ply		                PLY
.1a6162	ab		plb		                PLB
.1a6163	20 77 57	jsr $1a5777	            JSR OP_FP_MUL
.1a6166	fa		plx		                PLX
.1a6167	68		pla		                PLA
.1a6168	28		plp		                PLP
.1a6169	60		rts		            RTS
.1a616a					Q_FP_LN
.1a616a	08		php		                PHP
.1a616b	c2 30		rep #$30	            REP #$30
.1a616d	48		pha		                PHA
.1a616e	da		phx		                PHX
.1a616f	e2 20		sep #$20	            SEP #$20
.1a6171	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a6173	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a6177	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a6179	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a617d	c2 20		rep #$20	            REP #$20
.1a617f	a5 23		lda $0823	                LDA ARGUMENT1
.1a6181	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a6185	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6187	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a618b	af 26 66 1a	lda $1a6626	                LDA @l fp_one
.1a618f	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a6193	af 28 66 1a	lda $1a6628	                LDA @l fp_one+2
.1a6197	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a619b	ea		nop		                NOP
.1a619c	ea		nop		                NOP
.1a619d	ea		nop		                NOP
.1a619e	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a61a2	85 0c		sta $080c	                STA SCRATCH
.1a61a4	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a61a8	85 0e		sta $080e	                STA SCRATCH+2
.1a61aa	e2 20		sep #$20	            SEP #$20
.1a61ac	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a61ae	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a61b2	c2 20		rep #$20	            REP #$20
.1a61b4	ea		nop		                NOP
.1a61b5	ea		nop		                NOP
.1a61b6	ea		nop		                NOP
.1a61b7	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a61bb	85 10		sta $0810	                STA SCRATCH2
.1a61bd	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a61c1	85 12		sta $0812	                STA SCRATCH2+2
.1a61c3	e2 20		sep #$20	            SEP #$20
.1a61c5	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a61c7	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a61cb	c2 20		rep #$20	            REP #$20
.1a61cd	a5 0c		lda $080c	                LDA SCRATCH
.1a61cf	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a61d3	a5 0e		lda $080e	                LDA SCRATCH+2
.1a61d5	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a61d9	a5 10		lda $0810	                LDA SCRATCH2
.1a61db	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a61df	a5 12		lda $0812	                LDA SCRATCH2+2
.1a61e1	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a61e5	ea		nop		                NOP
.1a61e6	ea		nop		                NOP
.1a61e7	ea		nop		                NOP
.1a61e8	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a61ec	85 23		sta $0823	                STA ARGUMENT1
.1a61ee	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a61f2	85 25		sta $0825	                STA ARGUMENT1+2
.1a61f4	e2 20		sep #$20	            SEP #$20
.1a61f6	a9 08		lda #$08	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX0
.1a61f8	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a61fc	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a61fe	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a6202	c2 20		rep #$20	            REP #$20
.1a6204	a5 23		lda $0823	                LDA ARGUMENT1
.1a6206	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a620a	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a620c	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a6210	ea		nop		                NOP
.1a6211	ea		nop		                NOP
.1a6212	ea		nop		                NOP
.1a6213	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a6217	85 29		sta $0829	                STA ARGUMENT2
.1a6219	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a621d	85 2b		sta $082b	                STA ARGUMENT2+2
.1a621f	20 9c 5f	jsr $1a5f9c	            JSR Q_SQ
.1a6222	8b		phb		                PHB
.1a6223	e2 20		sep #$20	            SEP #$20
.1a6225	a9 1a		lda #$1a	                LDA #`ln_coeff
.1a6227	48		pha		                PHA
.1a6228	ab		plb		                PLB
.1a6229	c2 20		rep #$20	            REP #$20
.1a622b	a2 0a 66	ldx #$660a	                LDX #<>ln_coeff
.1a622e	5a		phy		                PHY
.1a622f	a0 08 00	ldy #$0008	                LDY #8
.1a6232	20 0d 5f	jsr $1a5f0d	            JSR Q_POLY_HR
.1a6235	7a		ply		                PLY
.1a6236	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.1a6239	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.1a623d	8f 2d 08 00	sta $00082d	                STA @l ARGTYPE2
.1a6241	20 77 57	jsr $1a5777	            JSR OP_FP_MUL
.1a6244	ab		plb		                PLB
.1a6245	fa		plx		                PLX
.1a6246	68		pla		                PLA
.1a6247	28		plp		                PLP
.1a6248	60		rts		            RTS
.1a6249					FP_SIN
.1a6249	08		php		                PHP
.1a624a	c2 30		rep #$30	            REP #$30
.1a624c	48		pha		                PHA
.1a624d	da		phx		                PHX
.1a624e	20 3c 60	jsr $1a603c	            JSR Q_FP_SCALE_TAU
.1a6251	20 99 60	jsr $1a6099	            JSR Q_FP_NORM_ANGLE
.1a6254	da		phx		                PHX
.1a6255	8a		txa		                TXA
.1a6256	29 01 00	and #$0001	                AND #1
.1a6259	d0 05		bne $1a6260	                BNE do_cos
.1a625b	20 12 61	jsr $1a6112	            JSR Q_FP_SIN
.1a625e	80 03		bra $1a6263	                BRA maybe_neg
.1a6260					do_cos
.1a6260	20 ea 60	jsr $1a60ea	            JSR Q_FP_COS
.1a6263	fa		plx		maybe_neg       PLX
.1a6264	8a		txa		                TXA
.1a6265	29 04 00	and #$0004	                AND #4
.1a6268	f0 0a		beq $1a6274	                BEQ done
.1a626a	e2 20		sep #$20	            SEP #$20
.1a626c	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a626e	09 80		ora #$80	                ORA #$80
.1a6270	85 26		sta $0826	                STA ARGUMENT1+3
.1a6272	c2 20		rep #$20	            REP #$20
.1a6274	fa		plx		done            PLX
.1a6275	68		pla		                PLA
.1a6276	28		plp		                PLP
.1a6277	60		rts		            RTS
.1a6278					FP_COS
.1a6278	08		php		                PHP
.1a6279	c2 30		rep #$30	            REP #$30
.1a627b	48		pha		                PHA
.1a627c	da		phx		                PHX
.1a627d	20 3c 60	jsr $1a603c	            JSR Q_FP_SCALE_TAU
.1a6280	20 99 60	jsr $1a6099	            JSR Q_FP_NORM_ANGLE
.1a6283	da		phx		                PHX
.1a6284	8a		txa		                TXA
.1a6285	29 01 00	and #$0001	                AND #1
.1a6288	d0 05		bne $1a628f	                BNE do_sin
.1a628a	20 ea 60	jsr $1a60ea	            JSR Q_FP_COS
.1a628d	80 03		bra $1a6292	                BRA maybe_neg
.1a628f					do_sin
.1a628f	20 12 61	jsr $1a6112	            JSR Q_FP_SIN
.1a6292	fa		plx		maybe_neg       PLX
.1a6293	8a		txa		                TXA
.1a6294	29 02 00	and #$0002	                AND #2
.1a6297	f0 0a		beq $1a62a3	                BEQ done
.1a6299	e2 20		sep #$20	            SEP #$20
.1a629b	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a629d	09 80		ora #$80	                ORA #$80
.1a629f	85 26		sta $0826	                STA ARGUMENT1+3
.1a62a1	c2 20		rep #$20	            REP #$20
.1a62a3	fa		plx		done            PLX
.1a62a4	68		pla		                PLA
.1a62a5	28		plp		                PLP
.1a62a6	60		rts		            RTS
.1a62a7					FP_TAN
.1a62a7	08		php		                PHP
.1a62a8	c2 30		rep #$30	            REP #$30
.1a62aa	48		pha		                PHA
.1a62ab	da		phx		                PHX
.1a62ac	20 3c 60	jsr $1a603c	            JSR Q_FP_SCALE_TAU
.1a62af	20 99 60	jsr $1a6099	            JSR Q_FP_NORM_ANGLE
.1a62b2	20 3e 61	jsr $1a613e	            JSR Q_FP_TAN
.1a62b5	8a		txa		                TXA
.1a62b6	29 01 00	and #$0001	                AND #1
.1a62b9	f0 03		beq $1a62be	                BEQ no_inv
.1a62bb	20 d2 5f	jsr $1a5fd2	            JSR Q_INV
.1a62be	8a		txa		no_inv          TXA
.1a62bf	e2 20		sep #$20	            SEP #$20
.1a62c1	4a		lsr a		                LSR
.1a62c2	4a		lsr a		                LSR
.1a62c3	69 00		adc #$00	                ADC #0
.1a62c5	29 01		and #$01	                AND #1
.1a62c7	f0 06		beq $1a62cf	                BEQ no_neg
.1a62c9	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a62cb	09 80		ora #$80	                ORA #$80
.1a62cd	85 26		sta $0826	                STA ARGUMENT1+3
.1a62cf					no_neg
.1a62cf	c2 20		rep #$20	            REP #$20
.1a62d1	fa		plx		                PLX
.1a62d2	68		pla		                PLA
.1a62d3	28		plp		                PLP
.1a62d4	60		rts		            RTS
.1a62d5					FP_LN
.1a62d5	08		php		                PHP
.1a62d6	c2 30		rep #$30	            REP #$30
.1a62d8	48		pha		                PHA
.1a62d9	da		phx		                PHX
.1a62da	5a		phy		                PHY
.1a62db	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a62dd	10 1f		bpl $1a62fe	                BPL arg_ok
.1a62df	08		php		            PHP
.1a62e0	c2 20		rep #$20	            REP #$20
.1a62e2	48		pha		            PHA
.1a62e3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a62e6	5b		tcd		            TCD
.1a62e7	68		pla		            PLA
.1a62e8	28		plp		            PLP
.1a62e9	e2 20		sep #$20	            SEP #$20
.1a62eb	a9 17		lda #$17	            LDA #ERR_DOMAIN
.1a62ed	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a62f1	c2 20		rep #$20	            REP #$20
.1a62f3	29 ff 00	and #$00ff	            AND #$00FF
.1a62f6	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a62f9	e2 20		sep #$20	            SEP #$20
.1a62fb	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a62fe					arg_ok
.1a62fe	c2 30		rep #$30	            REP #$30
.1a6300	a5 23		lda $0823	                LDA ARGUMENT1
.1a6302	cf 26 66 1a	cmp $1a6626	                CMP @l fp_one
.1a6306	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6308	cf 28 66 1a	cmp $1a6628	                CMP @l fp_one+2
.1a630c	b0 04		bcs $1a6312	                BCS gtone
.1a630e	20 d2 5f	jsr $1a5fd2	            JSR Q_INV
.1a6311	18		clc		                CLC
.1a6312	a9 00 00	lda #$0000	gtone           LDA #0
.1a6315	a8		tay		                TAY
.1a6316	2a		rol a		                ROL             ; Rotate Carry into A; 0 means negate
.1a6317	48		pha		                PHA
.1a6318	e2 20		sep #$20	            SEP #$20
.1a631a	a9 00		lda #$00	                LDA #0
.1a631c	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a6320	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a6322	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a6326	c2 20		rep #$20	            REP #$20
.1a6328	af 7e 66 1a	lda $1a667e	                LDA @l eexp64
.1a632c	85 29		sta $0829	                STA ARGUMENT2
.1a632e	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a6332	af 80 66 1a	lda $1a6680	                LDA @l eexp64+2
.1a6336	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6338	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a633c	20 10 60	jsr $1a6010	            JSR Q_FP_SCALE
.1a633f	8a		txa		                TXA
.1a6340	f0 07		beq $1a6349	                BEQ chk16
.1a6342	0a		asl a		                ASL             ; multiply counter by 64
.1a6343	0a		asl a		                ASL
.1a6344	0a		asl a		                ASL
.1a6345	0a		asl a		                ASL
.1a6346	0a		asl a		                ASL
.1a6347	0a		asl a		                ASL
.1a6348	a8		tay		                TAY
.1a6349	af 82 66 1a	lda $1a6682	chk16           LDA @l eexp16
.1a634d	85 29		sta $0829	                STA ARGUMENT2
.1a634f	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a6353	af 84 66 1a	lda $1a6684	                LDA @l eexp16+2
.1a6357	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6359	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a635d	20 10 60	jsr $1a6010	            JSR Q_FP_SCALE
.1a6360	8a		txa		                TXA
.1a6361	f0 0b		beq $1a636e	                BEQ chk04
.1a6363	0a		asl a		                ASL             ; multiply counter by 16
.1a6364	0a		asl a		                ASL
.1a6365	0a		asl a		                ASL
.1a6366	0a		asl a		                ASL
.1a6367	85 29		sta $0829	                STA ARGUMENT2   ; and add into total
.1a6369	18		clc		                CLC
.1a636a	98		tya		                TYA
.1a636b	65 29		adc $0829	                ADC ARGUMENT2
.1a636d	a8		tay		                TAY
.1a636e	af 86 66 1a	lda $1a6686	chk04           LDA @l eexp04
.1a6372	85 29		sta $0829	                STA ARGUMENT2
.1a6374	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a6378	af 88 66 1a	lda $1a6688	                LDA @l eexp04+2
.1a637c	85 2b		sta $082b	                STA ARGUMENT2+2
.1a637e	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a6382	20 10 60	jsr $1a6010	            JSR Q_FP_SCALE
.1a6385	8a		txa		                TXA
.1a6386	f0 09		beq $1a6391	                BEQ chk01
.1a6388	0a		asl a		                ASL             ;multiply counter by 4
.1a6389	0a		asl a		                ASL
.1a638a	85 29		sta $0829	                STA ARGUMENT2   ;and add to total
.1a638c	18		clc		                CLC
.1a638d	98		tya		                TYA
.1a638e	65 29		adc $0829	                ADC ARGUMENT2
.1a6390	a8		tay		                TAY
.1a6391	af 8a 66 1a	lda $1a668a	chk01           LDA @l eexp01
.1a6395	85 29		sta $0829	                STA ARGUMENT2
.1a6397	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a639b	af 8c 66 1a	lda $1a668c	                LDA @l eexp01+2
.1a639f	85 2b		sta $082b	                STA ARGUMENT2+2
.1a63a1	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a63a5	20 10 60	jsr $1a6010	            JSR Q_FP_SCALE
.1a63a8	86 29		stx $0829	                STX ARGUMENT2   ; add counter to total
.1a63aa	18		clc		                CLC
.1a63ab	98		tya		                TYA
.1a63ac	65 29		adc $0829	                ADC ARGUMENT2
.1a63ae	a8		tay		                TAY
.1a63af	20 6a 61	jsr $1a616a	            JSR Q_FP_LN
.1a63b2	a5 23		lda $0823	                LDA ARGUMENT1
.1a63b4	85 29		sta $0829	                STA ARGUMENT2
.1a63b6	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a63b8	85 2b		sta $082b	                STA ARGUMENT2+2
.1a63ba	98		tya		                TYA
.1a63bb	85 23		sta $0823	                STA ARGUMENT1
.1a63bd	64 25		stz $0825	                STZ ARGUMENT1+2
.1a63bf	20 04 5c	jsr $1a5c04	            JSR ITOF
.1a63c2	20 e1 56	jsr $1a56e1	            JSR OP_FP_ADD
.1a63c5	68		pla		                PLA
.1a63c6	d0 07		bne $1a63cf	                BNE done
.1a63c8	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a63ca	09 00 80	ora #$8000	                ORA #$8000
.1a63cd	85 25		sta $0825	                STA ARGUMENT1+2
.1a63cf	7a		ply		done            PLY
.1a63d0	fa		plx		                PLX
.1a63d1	68		pla		                PLA
.1a63d2	28		plp		                PLP
.1a63d3	60		rts		            RTS
.1a63d4					FP_ASIN
.1a63d4	08		php		                PHP
.1a63d5	c2 30		rep #$30	            REP #$30
.1a63d7	48		pha		                PHA
.1a63d8	da		phx		                PHX
.1a63d9	a5 23		lda $0823	                LDA ARGUMENT1
.1a63db	85 29		sta $0829	                STA ARGUMENT2
.1a63dd	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a63df	85 2b		sta $082b	                STA ARGUMENT2+2
.1a63e1	20 9c 5f	jsr $1a5f9c	            JSR Q_SQ
.1a63e4	8b		phb		                PHB
.1a63e5	e2 20		sep #$20	            SEP #$20
.1a63e7	a9 1a		lda #$1a	                LDA #`asin_coeff
.1a63e9	48		pha		                PHA
.1a63ea	ab		plb		                PLB
.1a63eb	c2 20		rep #$20	            REP #$20
.1a63ed	a2 2e 66	ldx #$662e	                LDX #<>asin_coeff
.1a63f0	a0 05 00	ldy #$0005	                LDY #5
.1a63f3	20 0d 5f	jsr $1a5f0d	            JSR Q_POLY_HR
.1a63f6	ab		plb		                PLB
.1a63f7	20 77 57	jsr $1a5777	            JSR OP_FP_MUL
.1a63fa	fa		plx		                PLX
.1a63fb	68		pla		                PLA
.1a63fc	28		plp		                PLP
.1a63fd	60		rts		            RTS
.1a63fe					FP_ACOS
.1a63fe	08		php		                PHP
.1a63ff	c2 30		rep #$30	            REP #$30
.1a6401	48		pha		                PHA
.1a6402	da		phx		                PHX
.1a6403	20 d4 63	jsr $1a63d4	            JSR FP_ASIN
.1a6406	af 96 66 1a	lda $1a6696	                LDA @l halfpi
.1a640a	85 29		sta $0829	                STA ARGUMENT2
.1a640c	af 98 66 1a	lda $1a6698	                LDA @l halfpi+2
.1a6410	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6412	20 d6 56	jsr $1a56d6	            JSR OP_FP_SUB
.1a6415	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6417	49 00 80	eor #$8000	                EOR #$8000
.1a641a	85 25		sta $0825	                STA ARGUMENT1+2
.1a641c	fa		plx		                PLX
.1a641d	68		pla		                PLA
.1a641e	28		plp		                PLP
.1a641f	60		rts		            RTS
.1a6420					FP_ATAN
.1a6420	08		php		                PHP
.1a6421	c2 30		rep #$30	            REP #$30
.1a6423	48		pha		                PHA
.1a6424	da		phx		                PHX
.1a6425	a5 23		lda $0823	                LDA ARGUMENT1
.1a6427	85 29		sta $0829	                STA ARGUMENT2
.1a6429	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a642b	85 2b		sta $082b	                STA ARGUMENT2+2
.1a642d	20 9c 5f	jsr $1a5f9c	            JSR Q_SQ
.1a6430	8b		phb		                PHB
.1a6431	e2 20		sep #$20	            SEP #$20
.1a6433	a9 1a		lda #$1a	                LDA #`atan_coeff
.1a6435	48		pha		                PHA
.1a6436	ab		plb		                PLB
.1a6437	c2 20		rep #$20	            REP #$20
.1a6439	a2 42 66	ldx #$6642	                LDX #<>atan_coeff
.1a643c	a0 05 00	ldy #$0005	                LDY #5
.1a643f	20 0d 5f	jsr $1a5f0d	            JSR Q_POLY_HR
.1a6442	ab		plb		                PLB
.1a6443	20 77 57	jsr $1a5777	            JSR OP_FP_MUL
.1a6446	fa		plx		                PLX
.1a6447	68		pla		                PLA
.1a6448	28		plp		                PLP
.1a6449	60		rts		            RTS
.1a644a					Q_FP_POW_INT
.1a644a	c2 20		rep #$20	            REP #$20
.1a644c	a5 23		lda $0823	            LDA ARGUMENT1
.1a644e	85 29		sta $0829	            STA ARGUMENT2
.1a6450	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6452	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6454	c2 20		rep #$20	            REP #$20
.1a6456	af 26 66 1a	lda $1a6626	            LDA @l fp_one
.1a645a	85 23		sta $0823	            STA ARGUMENT1
.1a645c	af 28 66 1a	lda $1a6628	            LDA @l fp_one+2
.1a6460	85 25		sta $0825	            STA ARGUMENT1+2
.1a6462	8a		txa		loop            TXA
.1a6463	f0 30		beq $1a6495	                BEQ done
.1a6465	4a		lsr a		                LSR
.1a6466	aa		tax		                TAX
.1a6467	90 03		bcc $1a646c	                BCC next
.1a6469	20 77 57	jsr $1a5777	            JSR OP_FP_MUL
.1a646c					next
.1a646c	c2 20		rep #$20	            REP #$20
.1a646e	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6470	48		pha		            PHA
.1a6471	a5 23		lda $0823	            LDA ARGUMENT1
.1a6473	48		pha		            PHA
.1a6474	c2 20		rep #$20	            REP #$20
.1a6476	a5 29		lda $0829	            LDA ARGUMENT2
.1a6478	85 23		sta $0823	            STA ARGUMENT1
.1a647a	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a647c	85 25		sta $0825	            STA ARGUMENT1+2
.1a647e	20 9c 5f	jsr $1a5f9c	            JSR Q_SQ
.1a6481	c2 20		rep #$20	            REP #$20
.1a6483	a5 23		lda $0823	            LDA ARGUMENT1
.1a6485	85 29		sta $0829	            STA ARGUMENT2
.1a6487	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6489	85 2b		sta $082b	            STA ARGUMENT2+2
.1a648b	c2 20		rep #$20	            REP #$20
.1a648d	68		pla		            PLA
.1a648e	85 23		sta $0823	            STA ARGUMENT1
.1a6490	68		pla		            PLA
.1a6491	85 25		sta $0825	            STA ARGUMENT1+2
.1a6493	80 cd		bra $1a6462	                BRA loop
.1a6495					done
.1a6495	60		rts		            RTS
.1a6496					Q_FP_EXP
.1a6496	08		php		                PHP
.1a6497	c2 30		rep #$30	            REP #$30
.1a6499	48		pha		                PHA
.1a649a	da		phx		                PHX
.1a649b	8b		phb		                PHB
.1a649c	e2 20		sep #$20	            SEP #$20
.1a649e	a9 1a		lda #$1a	                LDA #`exp_coeff
.1a64a0	48		pha		                PHA
.1a64a1	ab		plb		                PLB
.1a64a2	c2 20		rep #$20	            REP #$20
.1a64a4	a2 56 66	ldx #$6656	                LDX #<>exp_coeff
.1a64a7	5a		phy		                PHY
.1a64a8	a0 0a 00	ldy #$000a	                LDY #10
.1a64ab	20 0d 5f	jsr $1a5f0d	            JSR Q_POLY_HR
.1a64ae	7a		ply		                PLY
.1a64af	ab		plb		                PLB
.1a64b0	fa		plx		                PLX
.1a64b1	68		pla		                PLA
.1a64b2	28		plp		                PLP
.1a64b3	60		rts		            RTS
.1a64b4					FP_EXP
.1a64b4	08		php		                PHP
.1a64b5	c2 30		rep #$30	            REP #$30
.1a64b7	48		pha		                PHA
.1a64b8	da		phx		                PHX
.1a64b9	5a		phy		                PHY
.1a64ba	a5 23		lda $0823	                LDA ARGUMENT1   ; special case for x==0
.1a64bc	05 25		ora $0825	                ORA ARGUMENT1+2
.1a64be	d0 10		bne $1a64d0	                BNE notzero
.1a64c0	c2 20		rep #$20	            REP #$20
.1a64c2	af 26 66 1a	lda $1a6626	            LDA @l fp_one
.1a64c6	85 23		sta $0823	            STA ARGUMENT1
.1a64c8	af 28 66 1a	lda $1a6628	            LDA @l fp_one+2
.1a64cc	85 25		sta $0825	            STA ARGUMENT1+2
.1a64ce	80 61		bra $1a6531	                BRA done
.1a64d0	a5 25		lda $0825	notzero         LDA ARGUMENT1+2 ; check if negative
.1a64d2	29 00 80	and #$8000	                AND #$8000
.1a64d5	a8		tay		                TAY             ; Y != 0 -> arg was negative
.1a64d6	f0 07		beq $1a64df	                BEQ notneg
.1a64d8	a5 25		lda $0825	                LDA ARGUMENT1+2 ; negate x
.1a64da	29 ff 7f	and #$7fff	                AND #$7FFF
.1a64dd	85 25		sta $0825	                STA ARGUMENT1+2
.1a64df					notneg
.1a64df	c2 20		rep #$20	            REP #$20
.1a64e1	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a64e3	48		pha		            PHA
.1a64e4	a5 23		lda $0823	            LDA ARGUMENT1
.1a64e6	48		pha		            PHA
.1a64e7	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a64ea	a6 23		ldx $0823	                LDX ARGUMENT1              ; INT(x) now in ARGUMENT1; low 16 bits into X
.1a64ec	20 bf 07	jsr $1a07bf	            JSR ASS_ARG1_FLOAT
.1a64ef	c2 20		rep #$20	            REP #$20
.1a64f1	a5 23		lda $0823	            LDA ARGUMENT1
.1a64f3	85 29		sta $0829	            STA ARGUMENT2
.1a64f5	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a64f7	85 2b		sta $082b	            STA ARGUMENT2+2
.1a64f9	c2 20		rep #$20	            REP #$20
.1a64fb	68		pla		            PLA
.1a64fc	85 23		sta $0823	            STA ARGUMENT1
.1a64fe	68		pla		            PLA
.1a64ff	85 25		sta $0825	            STA ARGUMENT1+2
.1a6501	20 d6 56	jsr $1a56d6	            JSR OP_FP_SUB
.1a6504	20 96 64	jsr $1a6496	            JSR Q_FP_EXP
.1a6507	c2 20		rep #$20	            REP #$20
.1a6509	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a650b	48		pha		            PHA
.1a650c	a5 23		lda $0823	            LDA ARGUMENT1
.1a650e	48		pha		            PHA
.1a650f	c2 20		rep #$20	            REP #$20
.1a6511	af 8a 66 1a	lda $1a668a	            LDA @leexp01
.1a6515	85 23		sta $0823	            STA ARGUMENT1
.1a6517	af 8c 66 1a	lda $1a668c	            LDA @leexp01+2
.1a651b	85 25		sta $0825	            STA ARGUMENT1+2
.1a651d	20 4a 64	jsr $1a644a	            JSR Q_FP_POW_INT
.1a6520	c2 20		rep #$20	            REP #$20
.1a6522	68		pla		            PLA
.1a6523	85 29		sta $0829	            STA ARGUMENT2
.1a6525	68		pla		            PLA
.1a6526	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6528	20 77 57	jsr $1a5777	            JSR OP_FP_MUL
.1a652b	98		tya		                TYA
.1a652c	f0 03		beq $1a6531	                BEQ done
.1a652e	20 d2 5f	jsr $1a5fd2	            JSR Q_INV
.1a6531	7a		ply		done            PLY
.1a6532	fa		plx		                PLX
.1a6533	68		pla		                PLA
.1a6534	28		plp		                PLP
.1a6535	60		rts		            RTS
.1a6536					FP_SQR
.1a6536	08		php		                PHP
.1a6537	c2 30		rep #$30	            REP #$30
.1a6539	48		pha		                PHA
.1a653a	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a653c	10 1f		bpl $1a655d	                BPL arg_ok
.1a653e	08		php		            PHP
.1a653f	c2 20		rep #$20	            REP #$20
.1a6541	48		pha		            PHA
.1a6542	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6545	5b		tcd		            TCD
.1a6546	68		pla		            PLA
.1a6547	28		plp		            PLP
.1a6548	e2 20		sep #$20	            SEP #$20
.1a654a	a9 17		lda #$17	            LDA #ERR_DOMAIN
.1a654c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6550	c2 20		rep #$20	            REP #$20
.1a6552	29 ff 00	and #$00ff	            AND #$00FF
.1a6555	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a6558	e2 20		sep #$20	            SEP #$20
.1a655a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a655d					arg_ok
.1a655d	c2 30		rep #$30	            REP #$30
.1a655f	05 23		ora $0823	                ORA ARGUMENT1
.1a6561	f0 68		beq $1a65cb	                BEQ done
.1a6563	c2 20		rep #$20	            REP #$20
.1a6565	af 2a 66 1a	lda $1a662a	            LDA @l fp_two
.1a6569	85 29		sta $0829	            STA ARGUMENT2
.1a656b	af 2c 66 1a	lda $1a662c	            LDA @l fp_two+2
.1a656f	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6571	e2 20		sep #$20	            SEP #$20
.1a6573	a9 01		lda #$01	                LDA #TYPE_FLOAT
.1a6575	85 2d		sta $082d	                STA ARGTYPE2
.1a6577	c2 20		rep #$20	            REP #$20
.1a6579	c2 20		rep #$20	            REP #$20
.1a657b	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a657d	48		pha		            PHA
.1a657e	a5 23		lda $0823	            LDA ARGUMENT1
.1a6580	48		pha		            PHA
.1a6581					loop
.1a6581	20 2c 57	jsr $1a572c	            JSR OP_FP_DIV
.1a6584	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6586	c5 2b		cmp $082b	                CMP ARGUMENT2+2
.1a6588	d0 09		bne $1a6593	                BNE more
.1a658a	a5 23		lda $0823	                LDA ARGUMENT1
.1a658c	45 29		eor $0829	                EOR ARGUMENT2
.1a658e	29 f8 ff	and #$fff8	                AND #$FFF8
.1a6591	f0 30		beq $1a65c3	                BEQ exitloop
.1a6593					more
.1a6593	20 e1 56	jsr $1a56e1	            JSR OP_FP_ADD
.1a6596	c2 20		rep #$20	            REP #$20
.1a6598	af 2a 66 1a	lda $1a662a	            LDA @l fp_two
.1a659c	85 29		sta $0829	            STA ARGUMENT2
.1a659e	af 2c 66 1a	lda $1a662c	            LDA @l fp_two+2
.1a65a2	85 2b		sta $082b	            STA ARGUMENT2+2
.1a65a4	20 2c 57	jsr $1a572c	            JSR OP_FP_DIV
.1a65a7	c2 20		rep #$20	            REP #$20
.1a65a9	a5 23		lda $0823	            LDA ARGUMENT1
.1a65ab	85 29		sta $0829	            STA ARGUMENT2
.1a65ad	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a65af	85 2b		sta $082b	            STA ARGUMENT2+2
.1a65b1	c2 20		rep #$20	            REP #$20
.1a65b3	68		pla		            PLA
.1a65b4	85 23		sta $0823	            STA ARGUMENT1
.1a65b6	68		pla		            PLA
.1a65b7	85 25		sta $0825	            STA ARGUMENT1+2
.1a65b9	c2 20		rep #$20	            REP #$20
.1a65bb	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a65bd	48		pha		            PHA
.1a65be	a5 23		lda $0823	            LDA ARGUMENT1
.1a65c0	48		pha		            PHA
.1a65c1	80 be		bra $1a6581	                BRA loop
.1a65c3					exitloop
.1a65c3	c2 20		rep #$20	            REP #$20
.1a65c5	68		pla		            PLA
.1a65c6	85 29		sta $0829	            STA ARGUMENT2
.1a65c8	68		pla		            PLA
.1a65c9	85 2b		sta $082b	            STA ARGUMENT2+2
.1a65cb	68		pla		done            PLA
.1a65cc	28		plp		                PLP
.1a65cd	60		rts		            RTS
.1a65ce					cos_coeff
>1a65ce	01 0d d0 37			                .dword $37D00D01
>1a65d2	61 0b b6 ba			                .dword $BAB60B61
>1a65d6	ab aa 2a 3d			                .dword $3D2AAAAB
>1a65da	00 00 00 bf			                .dword $BF000000
>1a65de	00 00 80 3f			                .dword $3F800000
.1a65e2					sin_coeff
>1a65e2	1d ef 38 36			                .dword $3638EF1D
>1a65e6	01 0d 50 b9			                .dword $B9500D01
>1a65ea	89 88 08 3c			                .dword $3C088889
>1a65ee	ab aa 2a be			                .dword $BE2AAAAB
>1a65f2	00 00 80 3f			                .dword $3F800000
.1a65f6					tan_coeff
>1a65f6	a4 27 b3 3c			                .dword $3CB327A4
>1a65fa	d1 0d 5d 3d			                .dword $3D5D0DD1
>1a65fe	89 88 08 3e			                .dword $3E088889
>1a6602	ab aa aa 3e			                .dword $3EAAAAAB
>1a6606	00 00 80 3f			                .dword $3F800000
.1a660a					ln_coeff
>1a660a	89 88 88 3d			                .dword $3D888889
>1a660e	d9 89 9d 3d			                .dword $3D9D89D9
>1a6612	8c 2e ba 3d			                .dword $3DBA2E8C
>1a6616	39 8e e3 3d			                .dword $3DE38E39
>1a661a	25 49 12 3e			                .dword $3E124925
>1a661e	cd cc 4c 3e			                .dword $3E4CCCCD
>1a6622	ab aa aa 3e			                .dword $3EAAAAAB
>1a6626	00 00 80 3f			fp_one          .dword $3F800000
>1a662a	00 00 00 40			fp_two          .dword $40000000
.1a662e					asin_coeff
>1a662e	8e e3 f8 3c			                .dword $3CF8E38E
>1a6632	6e db 36 3d			                .dword $3D36DB6E
>1a6636	9a 99 99 3d			                .dword $3D99999A
>1a663a	ab aa 2a 3e			                .dword $3E2AAAAB
>1a663e	00 00 80 3f			                .dword $3F800000
.1a6642					atan_coeff
>1a6642	39 8e e3 3d			                .dword $3DE38E39
>1a6646	25 49 12 be			                .dword $BE124925
>1a664a	cd cc 4c 3e			                .dword $3E4CCCCD
>1a664e	ab aa aa be			                .dword $BEAAAAAB
>1a6652	00 00 80 3f			                .dword $3F800000
.1a6656					exp_coeff
>1a6656	1d ef 38 36			        .dword $3638EF1D
>1a665a	01 0d d0 37			        .dword $37D00D01
>1a665e	01 0d 50 39			        .dword $39500D01
>1a6662	61 0b b6 3a			        .dword $3AB60B61
>1a6666	89 88 08 3c			        .dword $3C088889
>1a666a	ab aa 2a 3d			        .dword $3D2AAAAB
>1a666e	ab aa 2a 3e			        .dword $3E2AAAAB
>1a6672	00 00 00 3f			        .dword $3F000000
>1a6676	00 00 80 3f			        .dword $3F800000
>1a667a	00 00 80 3f			        .dword $3F800000
>1a667e	c1 2c a1 6d			eexp64          .dword $6DA12CC1
>1a6682	5f 97 07 4b			eexp16          .dword $4B07975F
>1a6686	81 64 5a 42			eexp04          .dword $425A6481
>1a668a	54 f8 2d 40			eexp01          .dword $402DF854
>1a668e	db 0f c9 40			twopi           .dword $40C90FDB
>1a6692	db 0f 49 40			onepi           .dword $40490FDB
>1a6696	db 0f c9 3f			halfpi          .dword $3FC90FDB
>1a669a	db 0f 49 3f			quarterpi       .dword $3F490FDB

;******  Return to file: src\basic816.s


;******  Processing file: src\arrays.s

.1a669e					ARR_ALLOC
.1a669e	08		php		                PHP
.1a669f	20 0f 13	jsr $1a130f	            JSR HEAP_GETHED
.1a66a2	c2 20		rep #$20	            REP #$20
.1a66a4	a9 01 00	lda #$0001	                LDA #1                      ; ARGUMENT1 := 1
.1a66a7	85 23		sta $0823	                STA ARGUMENT1
.1a66a9	a9 00 00	lda #$0000	                LDA #0
.1a66ac	85 25		sta $0825	                STA ARGUMENT1+2
.1a66ae	e2 20		sep #$20	            SEP #$20
.1a66b0	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.1a66b4	c2 20		rep #$20	            REP #$20
.1a66b6	29 ff 00	and #$00ff	                AND #$00FF
.1a66b9	85 8f		sta $088f	                STA MCOUNT                  ; Save it to MCOUNT for later
.1a66bb	a8		tay		                TAY                         ; Y := number of dimensions
.1a66bc	a2 01 00	ldx #$0001	                LDX #1                      ; X := index to size 0
.1a66bf					size_loop
.1a66bf	c2 20		rep #$20	            REP #$20
.1a66c1	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X           ; ARGUMENT2 := Ith dimension
.1a66c5	85 29		sta $0829	                STA ARGUMENT2
.1a66c7	a9 00 00	lda #$0000	                LDA #0
.1a66ca	85 2b		sta $082b	                STA ARGUMENT2+2
.1a66cc	e2 20		sep #$20	            SEP #$20
.1a66ce	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a66d0	85 2d		sta $082d	                STA ARGTYPE2
.1a66d2	c2 20		rep #$20	            REP #$20
.1a66d4	20 5a 28	jsr $1a285a	            JSR OP_MULTIPLY
.1a66d7	e8		inx		                INX
.1a66d8	e8		inx		                INX
.1a66d9	88		dey		                DEY
.1a66da	d0 e3		bne $1a66bf	                BNE size_loop               ; If there are more dimensions, take the next one
.1a66dc	c2 20		rep #$20	            REP #$20
.1a66de	a9 04 00	lda #$0004	                LDA #ARGUMENT_SIZE-1        ; Size of a data item (don't include the type code)
.1a66e1	85 29		sta $0829	                STA ARGUMENT2
.1a66e3	a9 00 00	lda #$0000	                LDA #0
.1a66e6	85 2b		sta $082b	                STA ARGUMENT2+2
.1a66e8	20 5a 28	jsr $1a285a	            JSR OP_MULTIPLY
.1a66eb	e2 20		sep #$20	            SEP #$20
.1a66ed	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF             ; SCRATCH := N * 2
.1a66f1	85 0c		sta $080c	                STA SCRATCH
.1a66f3	a9 00		lda #$00	                LDA #0
.1a66f5	85 0d		sta $080d	                STA SCRATCH+1
.1a66f7	c2 20		rep #$20	            REP #$20
.1a66f9	06 0c		asl $080c	                ASL SCRATCH
.1a66fb	38		sec		                SEC                         ; ARGUMENT1 := size of the complete block
.1a66fc	a5 23		lda $0823	                LDA ARGUMENT1
.1a66fe	65 0c		adc $080c	                ADC SCRATCH                 ; Size of data area + N*2 + 1 (in carry)
.1a6700	85 23		sta $0823	                STA ARGUMENT1
.1a6702	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6704	69 00 00	adc #$0000	                ADC #0
.1a6707	85 25		sta $0825	                STA ARGUMENT1+2
.1a6709	d0 29		bne $1a6734	                BNE too_big                 ; size > 16-bit? Yes: throw an error
.1a670b	e2 20		sep #$20	            SEP #$20
.1a670d	a5 ea		lda $08ea	                LDA TOFINDTYPE              ; Get the type
.1a670f	09 80		ora #$80	                ORA #$80                    ; Flip the flag to make it an array of that type
.1a6711	a6 23		ldx $0823	                LDX ARGUMENT1               ; Get the computed size
.1a6713	20 d3 10	jsr $1a10d3	            JSR ALLOC
.1a6716	e2 20		sep #$20	            SEP #$20
.1a6718	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.1a671c	87 c0		sta [$08c0]	                STA [CURRBLOCK]             ; Write the number of dimensions to the array's preamble
.1a671e	a0 01 00	ldy #$0001	                LDY #1
.1a6721	a2 00 00	ldx #$0000	                LDX #0
.1a6724					copy_loop
.1a6724	e2 20		sep #$20	            SEP #$20
.1a6726	bf 01 4d 00	lda $004d01,x	                LDA @lARRIDXBUF+1,X         ; ARGUMENT2 := Ith dimension
.1a672a	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y           ; And write the dimension to the array's preamble
.1a672c	e4 8f		cpx $088f	                CPX MCOUNT                  ; Have we written the last byte?
.1a672e	f0 23		beq $1a6753	                BEQ null_array              ; Yes: clear the array
.1a6730	e8		inx		                INX                         ; No: move to the next byte
.1a6731	c8		iny		                INY
.1a6732	80 f0		bra $1a6724	                BRA copy_loop
.1a6734					too_big
.1a6734	08		php		            PHP
.1a6735	c2 20		rep #$20	            REP #$20
.1a6737	48		pha		            PHA
.1a6738	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a673b	5b		tcd		            TCD
.1a673c	68		pla		            PLA
.1a673d	28		plp		            PLP
.1a673e	e2 20		sep #$20	            SEP #$20
.1a6740	a9 09		lda #$09	            LDA #ERR_RANGE
.1a6742	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6746	c2 20		rep #$20	            REP #$20
.1a6748	29 ff 00	and #$00ff	            AND #$00FF
.1a674b	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a674e	e2 20		sep #$20	            SEP #$20
.1a6750	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6753					null_array
.1a6753	e2 20		sep #$20	            SEP #$20
.1a6755	38		sec		                SEC                         ; INDEX := pointer to first value
.1a6756	a5 c0		lda $08c0	                LDA CURRBLOCK
.1a6758	67 c0		adc [$08c0]	                ADC [CURRBLOCK]
.1a675a	85 08		sta $0808	                STA INDEX
.1a675c	a5 c1		lda $08c1	                LDA CURRBLOCK+1
.1a675e	69 00		adc #$00	                ADC #0
.1a6760	85 09		sta $0809	                STA INDEX+1
.1a6762	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a6764	69 00		adc #$00	                ADC #0
.1a6766	85 0a		sta $080a	                STA INDEX+2
.1a6768	64 0b		stz $080b	                STZ INDEX+3
.1a676a	c2 20		rep #$20	            REP #$20
.1a676c	a0 05 00	ldy #$0005	                LDY #HEAPOBJ.END            ; SCRATCH := pointer the the first byte after the array
.1a676f	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a6771	85 0c		sta $080c	                STA SCRATCH
.1a6773	e2 20		sep #$20	            SEP #$20
.1a6775	c8		iny		                INY
.1a6776	c8		iny		                INY
.1a6777	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a6779	85 0e		sta $080e	                STA SCRATCH+2
.1a677b	64 0f		stz $080f	                STZ SCRATCH+3
.1a677d					clr_loop
.1a677d	e2 20		sep #$20	            SEP #$20
.1a677f	a9 00		lda #$00	                LDA #0
.1a6781	87 08		sta [$0808]	                STA [INDEX]                 ; Clear the byte
.1a6783	c2 20		rep #$20	            REP #$20
.1a6785	18		clc		                CLC                         ; Increment INDEX
.1a6786	a5 08		lda $0808	                LDA INDEX
.1a6788	69 01 00	adc #$0001	                ADC #1
.1a678b	85 08		sta $0808	                STA INDEX
.1a678d	a5 0a		lda $080a	                LDA INDEX+2
.1a678f	69 00 00	adc #$0000	                ADC #0
.1a6792	85 0a		sta $080a	                STA INDEX+2
.1a6794	c5 0e		cmp $080e	                CMP SCRATCH+2               ; INDEX == SCRATCH?
.1a6796	d0 e5		bne $1a677d	                BNE clr_loop                ; No: write to this next byte
.1a6798	a5 08		lda $0808	                LDA INDEX
.1a679a	c5 0c		cmp $080c	                CMP SCRATCH
.1a679c	d0 df		bne $1a677d	                BNE clr_loop
.1a679e					done
.1a679e	28		plp		                PLP
.1a679f	60		rts		            RTS
.1a67a0					ARR_CELL
.1a67a0	08		php		                PHP
.1a67a1	c2 20		rep #$20	            REP #$20
.1a67a3	64 08		stz $0808	                STZ INDEX               ; INDEX := 0
.1a67a5	64 0a		stz $080a	                STZ INDEX+2
.1a67a7	e2 20		sep #$20	            SEP #$20
.1a67a9	af 00 4d 00	lda $004d00	                LDA @l ARRIDXBUF        ; MCOUNT := N (number of dimensions)
.1a67ad	85 8f		sta $088f	                STA MCOUNT
.1a67af	64 90		stz $0890	                STZ MCOUNT+1
.1a67b1	a2 01 00	ldx #$0001	                LDX #1                  ; X := index to dimension 0
.1a67b4	e2 20		sep #$20	            SEP #$20
.1a67b6	a7 c0		lda [$08c0]	                LDA [CURRBLOCK]         ; Make sure the dimensions of the array
.1a67b8	c5 8f		cmp $088f	                CMP MCOUNT              ; ... match those requested
.1a67ba	f0 22		beq $1a67de	                BEQ dims_match          ; Yes: the dimensions match
.1a67bc	a6 8f		ldx $088f	                LDX MCOUNT
.1a67be	00		brk #		                BRK
.1a67bf					arg_err
.1a67bf	08		php		            PHP
.1a67c0	c2 20		rep #$20	            REP #$20
.1a67c2	48		pha		            PHA
.1a67c3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a67c6	5b		tcd		            TCD
.1a67c7	68		pla		            PLA
.1a67c8	28		plp		            PLP
.1a67c9	e2 20		sep #$20	            SEP #$20
.1a67cb	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a67cd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a67d1	c2 20		rep #$20	            REP #$20
.1a67d3	29 ff 00	and #$00ff	            AND #$00FF
.1a67d6	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a67d9	e2 20		sep #$20	            SEP #$20
.1a67db	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a67de	c9 01		cmp #$01	dims_match      CMP #1                  ; Check to see if this array is one dimensional
.1a67e0	f0 3a		beq $1a681c	                BEQ add_last            ; If so, just add the index of the cell to INDEX
.1a67e2	a0 01 00	ldy #$0001	                LDY #1
.1a67e5					index_loop
.1a67e5	e2 20		sep #$20	            SEP #$20
.1a67e7	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; ARGUMENT1 := I_j
.1a67eb	85 23		sta $0823	                STA ARGUMENT1
.1a67ed	64 24		stz $0824	                STZ ARGUMENT1+1
.1a67ef	64 25		stz $0825	                STZ ARGUMENT1+2
.1a67f1	64 26		stz $0826	                STZ ARGUMENT1+3
.1a67f3	b7 c0		lda [$08c0],y	                LDA [CURRBLOCK],Y       ; ARGUMENT2 := D_j
.1a67f5	85 29		sta $0829	                STA ARGUMENT2
.1a67f7	64 2a		stz $082a	                STZ ARGUMENT2+1
.1a67f9	64 2b		stz $082b	                STZ ARGUMENT2+2
.1a67fb	64 2c		stz $082c	                STZ ARGUMENT2+3
.1a67fd	a5 23		lda $0823	                LDA ARGUMENT1
.1a67ff	c5 29		cmp $0829	                CMP ARGUMENT2           ; Is I_j >= D_j
.1a6801	b0 68		bcs $1a686b	                BGE range_err           ; Yes: throw an out-of-range error
.1a6803	20 5a 28	jsr $1a285a	            JSR OP_MULTIPLY
.1a6806	c2 20		rep #$20	            REP #$20
.1a6808	18		clc		                CLC                     ; INDEX := INDEX + ARGUMENT1
.1a6809	a5 08		lda $0808	                LDA INDEX
.1a680b	65 23		adc $0823	                ADC ARGUMENT1
.1a680d	85 08		sta $0808	                STA INDEX
.1a680f	a5 0a		lda $080a	                LDA INDEX+2
.1a6811	65 25		adc $0825	                ADC ARGUMENT1+2
.1a6813	85 0a		sta $080a	                STA INDEX+2
.1a6815	e8		inx		                INX
.1a6816	e8		inx		                INX
.1a6817	c8		iny		                INY
.1a6818	c4 8f		cpy $088f	                CPY MCOUNT              ; Are we on the last index?
.1a681a	d0 c9		bne $1a67e5	                BNE index_loop          ; No: move to the next index and try again
.1a681c					add_last
.1a681c	e2 20		sep #$20	            SEP #$20
.1a681e	18		clc		                CLC
.1a681f	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; INDEX := INDEX + I_(n-1)
.1a6823	85 90		sta $0890	                STA MCOUNT+1
.1a6825	65 08		adc $0808	                ADC INDEX
.1a6827	85 08		sta $0808	                STA INDEX
.1a6829	a5 09		lda $0809	                LDA INDEX+1
.1a682b	69 00		adc #$00	                ADC #0
.1a682d	85 09		sta $0809	                STA INDEX+1
.1a682f	c2 20		rep #$20	            REP #$20
.1a6831	a5 0a		lda $080a	                LDA INDEX+2
.1a6833	69 00 00	adc #$0000	                ADC #0
.1a6836	85 0a		sta $080a	                STA INDEX+2
.1a6838	c2 20		rep #$20	            REP #$20
.1a683a	06 08		asl $0808	                ASL INDEX               ; INDEX := INDEX * 4 (size of a value)
.1a683c	26 0a		rol $080a	                ROL INDEX+2
.1a683e	06 08		asl $0808	                ASL INDEX
.1a6840	26 0a		rol $080a	                ROL INDEX+2
.1a6842	e2 20		sep #$20	            SEP #$20
.1a6844	38		sec		                SEC
.1a6845	a5 08		lda $0808	                LDA INDEX
.1a6847	65 8f		adc $088f	                ADC MCOUNT
.1a6849	85 08		sta $0808	                STA INDEX
.1a684b	a5 09		lda $0809	                LDA INDEX+1
.1a684d	69 00		adc #$00	                ADC #0
.1a684f	85 09		sta $0809	                STA INDEX+1
.1a6851	c2 20		rep #$20	            REP #$20
.1a6853	a5 0a		lda $080a	                LDA INDEX+2
.1a6855	69 00 00	adc #$0000	                ADC #0
.1a6858	85 0a		sta $080a	                STA INDEX+2
.1a685a	18		clc		                CLC                     ; INDEX := INDEX + CURRBLOCK (point to the address desired)
.1a685b	a5 08		lda $0808	                LDA INDEX
.1a685d	65 c0		adc $08c0	                ADC CURRBLOCK
.1a685f	85 08		sta $0808	                STA INDEX
.1a6861	e2 20		sep #$20	            SEP #$20
.1a6863	a5 0a		lda $080a	                LDA INDEX+2
.1a6865	65 c2		adc $08c2	                ADC CURRBLOCK+2
.1a6867	85 0a		sta $080a	                STA INDEX+2
.1a6869	28		plp		                PLP
.1a686a	60		rts		            RTS
.1a686b					range_err
.1a686b	08		php		            PHP
.1a686c	c2 20		rep #$20	            REP #$20
.1a686e	48		pha		            PHA
.1a686f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6872	5b		tcd		            TCD
.1a6873	68		pla		            PLA
.1a6874	28		plp		            PLP
.1a6875	e2 20		sep #$20	            SEP #$20
.1a6877	a9 09		lda #$09	            LDA #ERR_RANGE
.1a6879	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a687d	c2 20		rep #$20	            REP #$20
.1a687f	29 ff 00	and #$00ff	            AND #$00FF
.1a6882	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a6885	e2 20		sep #$20	            SEP #$20
.1a6887	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a688a					ARR_SET
.1a688a	08		php		                PHP
.1a688b	20 0f 13	jsr $1a130f	            JSR HEAP_GETHED
.1a688e	e2 20		sep #$20	            SEP #$20
.1a6890	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.1a6893	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a6895	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.1a6897	c9 02		cmp #$02	                CMP #TYPE_STRING    ; Is it a string array?
.1a6899	d0 05		bne $1a68a0	                BNE chk_integer
.1a689b	20 e3 06	jsr $1a06e3	            JSR ASS_ARG1_STR
.1a689e	80 10		bra $1a68b0	                BRA save_type
.1a68a0	c9 00		cmp #$00	chk_integer     CMP #TYPE_INTEGER   ; Is it an integer array?
.1a68a2	d0 05		bne $1a68a9	                BNE chk_float
.1a68a4	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a68a7	80 07		bra $1a68b0	                BRA save_type
.1a68a9	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT     ; Is it an float array?
.1a68ab	d0 2b		bne $1a68d8	                BNE type_mismatch   ; No: throw a type mismatch error... something strange...
.1a68ad	20 bf 07	jsr $1a07bf	            JSR ASS_ARG1_FLOAT
.1a68b0	a5 27		lda $0827	save_type       LDA ARGTYPE1        ; Save the type
.1a68b2	48		pha		                PHA
.1a68b3	c2 20		rep #$20	            REP #$20
.1a68b5	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Save ARGUMENT1
.1a68b7	48		pha		                PHA
.1a68b8	a5 23		lda $0823	                LDA ARGUMENT1
.1a68ba	48		pha		                PHA
.1a68bb	20 a0 67	jsr $1a67a0	            JSR ARR_CELL
.1a68be	68		pla		                PLA                 ; Restore ARGUMENT1
.1a68bf	85 23		sta $0823	                STA ARGUMENT1
.1a68c1	68		pla		                PLA
.1a68c2	85 25		sta $0825	                STA ARGUMENT1+2
.1a68c4	e2 20		sep #$20	            SEP #$20
.1a68c6	68		pla		                PLA
.1a68c7	85 27		sta $0827	                STA ARGTYPE1
.1a68c9	c2 20		rep #$20	            REP #$20
.1a68cb	a5 23		lda $0823	                LDA ARGUMENT1       ; Set the value in the cell
.1a68cd	87 08		sta [$0808]	                STA [INDEX]
.1a68cf	a0 02 00	ldy #$0002	                LDY #2
.1a68d2	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a68d4	97 08		sta [$0808],y	                STA [INDEX],Y
.1a68d6	28		plp		                PLP
.1a68d7	60		rts		            RTS
.1a68d8					type_mismatch
.1a68d8	08		php		            PHP
.1a68d9	c2 20		rep #$20	            REP #$20
.1a68db	48		pha		            PHA
.1a68dc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a68df	5b		tcd		            TCD
.1a68e0	68		pla		            PLA
.1a68e1	28		plp		            PLP
.1a68e2	e2 20		sep #$20	            SEP #$20
.1a68e4	a9 04		lda #$04	            LDA #ERR_TYPE
.1a68e6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a68ea	c2 20		rep #$20	            REP #$20
.1a68ec	29 ff 00	and #$00ff	            AND #$00FF
.1a68ef	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a68f2	e2 20		sep #$20	            SEP #$20
.1a68f4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a68f7					ARR_REF
.1a68f7	08		php		                PHP
.1a68f8	20 0f 13	jsr $1a130f	            JSR HEAP_GETHED
.1a68fb	f4 00 00	pea #$0000	                PEA #0              ; Make room on the stack that ARR_CELL expects
.1a68fe	f4 00 00	pea #$0000	                PEA #0
.1a6901	e2 20		sep #$20	            SEP #$20
.1a6903	48		pha		                PHA
.1a6904	20 a0 67	jsr $1a67a0	            JSR ARR_CELL
.1a6907	e2 20		sep #$20	            SEP #$20
.1a6909	68		pla		                PLA
.1a690a	c2 20		rep #$20	            REP #$20
.1a690c	68		pla		                PLA
.1a690d	68		pla		                PLA
.1a690e	c2 20		rep #$20	            REP #$20
.1a6910	a7 08		lda [$0808]	                LDA [INDEX]         ; Get the value in the cell
.1a6912	85 23		sta $0823	                STA ARGUMENT1
.1a6914	a0 02 00	ldy #$0002	                LDY #2
.1a6917	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a6919	85 25		sta $0825	                STA ARGUMENT1+2
.1a691b	e2 20		sep #$20	            SEP #$20
.1a691d	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.1a6920	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a6922	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.1a6924	85 27		sta $0827	                STA ARGTYPE1        ; Set the type of the return value
.1a6926	20 63 18	jsr $1a1863	            JSR STR_NORMAL
.1a6929	28		plp		                PLP
.1a692a	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\dos.s

.0000					DIRENTRY
>0000					SHORTNAME               .fill 11        ; $00 - The short name of the file (8 name, 3 extension)
>000b					ATTRIBUTE               .byte ?         ; $0B - The attribute bits
>000c					IGNORED1                .word ?         ; $0C - Unused (by us) bytes
>000e					CREATE_TIME             .word ?         ; $0E - Creation time
>0010					CREATE_DATE             .word ?         ; $10 - Creation date
>0012					ACCESS_DATE             .word ?         ; $12 - Last access date
>0014					CLUSTER_H               .word ?         ; $14 - High word of the first cluster #
>0016					MODIFIED_TIME           .word ?         ; $16 - Last modified time
>0018					MODIFIED_DATE           .word ?         ; $18 - Last modified date
>001a					CLUSTER_L               .word ?         ; $1A - Low word of the first cluster #
>001c					SIZE                    .dword ?        ; $1C - The size of the file (in bytes)
=$01					DOS_ATTR_RO = $01                       ; File is read-only
=$02					DOS_ATTR_HIDDEN = $02                   ; File is hidden
=$04					DOS_ATTR_SYSTEM = $04                   ; File is a system file
=$08					DOS_ATTR_VOLUME = $08                   ; Entry is the volume label
=$10					DOS_ATTR_DIR = $10                      ; Entry is a directory
=$20					DOS_ATTR_ARCH = $20                     ; Entry has changed since last backup
=$0f					DOS_ATTR_LONGNAME = $0F                 ; Entry is the long file name
=$e5					DOS_DIR_ENT_UNUSED = $E5                ; Marker for an unused directory entry
.0000					FILEDESC
>0000					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>0001					DEV                 .byte ?             ; The ID of the device holding the file
>0002					PATH                .dword ?            ; Pointer to a NULL terminated path string
>0006					CLUSTER             .dword ?            ; The current cluster of the file.
>000a					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>000e					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>0012					FILESIZE            .dword ?            ; The size of the file
>0016					CREATE_DATE         .word ?             ; The creation date of the file
>0018					CREATE_TIME         .word ?             ; The creation time of the file
>001a					MODIFIED_DATE       .word ?             ; The modification date of the file
>001c					MODIFIED_TIME       .word ?             ; The modification time of the file
=$01					FD_STAT_READ = $01                      ; The file is readable
=$02					FD_STAT_WRITE = $02                     ; The file is writable
=$40					FD_STAT_OPEN = $40                      ; The file is open
=$60					FD_STAT_ERROR = $60                     ; The file is in an error condition
=$80					FD_STAT_EOF = $80                       ; The file cursor is at the end of the file
>1af073					CLUSTER_BUFF    .fill 512           ; A buffer for cluster read/write operations
.1af273					FD_IN
>1af273					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>1af274					DEV                 .byte ?             ; The ID of the device holding the file
>1af275					PATH                .dword ?            ; Pointer to a NULL terminated path string
>1af279					CLUSTER             .dword ?            ; The current cluster of the file.
>1af27d					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>1af281					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>1af285					FILESIZE            .dword ?            ; The size of the file
>1af289					CREATE_DATE         .word ?             ; The creation date of the file
>1af28b					CREATE_TIME         .word ?             ; The creation time of the file
>1af28d					MODIFIED_DATE       .word ?             ; The modification date of the file
>1af28f					MODIFIED_TIME       .word ?             ; The modification time of the file
.1a692b					PR_FILESIZE
.1a692b	da		phx		                PHX
.1a692c	0b		phd		                PHD
.1a692d	08		php		                PHP
.1a692e	08		php		            PHP
.1a692f	c2 20		rep #$20	            REP #$20
.1a6931	48		pha		            PHA
.1a6932	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6935	5b		tcd		            TCD
.1a6936	68		pla		            PLA
.1a6937	28		plp		            PLP
.1a6938	c2 30		rep #$30	            REP #$30
.1a693a	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a693c	89 f0 ff	bit #$fff0	                BIT #$FFF0              ; Check to see if the amount is in MB range
.1a693f	d0 29		bne $1a696a	                BNE pr_mb               ; If so, print it in MBs
.1a6941	89 0f 00	bit #$000f	                BIT #$000F              ; Check to see if the amount is in KB range
.1a6944	d0 0c		bne $1a6952	                BNE pr_kb
.1a6946	a5 23		lda $0823	                LDA ARGUMENT1
.1a6948	89 00 fc	bit #$fc00	                BIT #$FC00
.1a694b	d0 05		bne $1a6952	                BNE pr_kb               ; If so, print it in KBs
.1a694d					pr_regular
.1a694d	20 1e 46	jsr $1a461e	            JSR PR_INTEGER
.1a6950	80 2e		bra $1a6980	                BRA done
.1a6952	a2 0a 00	ldx #$000a	pr_kb           LDX #10                 ; Shift so the amount in KB is in ARGUMENT1
.1a6955	46 25		lsr $0825	kb_shift        LSR ARGUMENT1+2
.1a6957	66 23		ror $0823	                ROR ARGUMENT1
.1a6959	ca		dex		                DEX
.1a695a	d0 f9		bne $1a6955	                BNE kb_shift
.1a695c	20 1e 46	jsr $1a461e	            JSR PR_INTEGER
.1a695f	e2 20		sep #$20	            SEP #$20
.1a6961	a9 4b		lda #$4b	                LDA #'K'
.1a6963	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6966	c2 20		rep #$20	            REP #$20
.1a6968	80 16		bra $1a6980	                BRA done
.1a696a	a2 14 00	ldx #$0014	pr_mb           LDX #20                 ; Shift so the amount in MB is in ARGUMENT1
.1a696d	46 25		lsr $0825	mb_shift        LSR ARGUMENT1+2
.1a696f	66 23		ror $0823	                ROR ARGUMENT1
.1a6971	ca		dex		                DEX
.1a6972	d0 f9		bne $1a696d	                BNE mb_shift
.1a6974	20 1e 46	jsr $1a461e	            JSR PR_INTEGER
.1a6977	e2 20		sep #$20	            SEP #$20
.1a6979	a9 4d		lda #$4d	                LDA #'M'
.1a697b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a697e	c2 20		rep #$20	            REP #$20
.1a6980	28		plp		done            PLP
.1a6981	2b		pld		                PLD
.1a6982	fa		plx		                PLX
.1a6983	60		rts		            RTS
.1a6984					CMD_DIR
.1a6984	0b		phd		                PHD
.1a6985	08		php		                PHP
.1a6986	c2 30		rep #$30	            REP #$30
.1a6988	a9 00 00	lda #$0000	                LDA #0                      ; Zero out the pagination line count
.1a698b	8f b6 08 00	sta $0008b6	                STA @l LINECOUNT
.1a698f	8f b8 08 00	sta $0008b8	                STA @l LINECOUNT+2
.1a6993	e2 20		sep #$20	            SEP #$20
.1a6995	20 7e 22	jsr $1a227e	            JSR PEEK_TOK
.1a6998	c9 00		cmp #$00	                CMP #0
.1a699a	f0 08		beq $1a69a4	                BEQ set_null                ; If none provided, set the path to empty
.1a699c	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a699f	20 e3 06	jsr $1a06e3	            JSR ASS_ARG1_STR
.1a69a2	80 11		bra $1a69b5	                BRA set_fd
.1a69a4					set_null
.1a69a4	c2 20		rep #$20	            REP #$20
.1a69a6	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT1 to the NULL string
.1a69a9	85 23		sta $0823	                STA ARGUMENT1
.1a69ab	85 25		sta $0825	                STA ARGUMENT1+2
.1a69ad	e2 20		sep #$20	            SEP #$20
.1a69af	a9 02		lda #$02	                LDA #TYPE_STRING
.1a69b1	85 27		sta $0827	                STA ARGTYPE1
.1a69b3	c2 20		rep #$20	            REP #$20
.1a69b5					set_fd
.1a69b5	20 e5 6a	jsr $1a6ae5	            JSR SETFILEDESC
.1a69b8	22 08 11 00	jsl $001108	                JSL FK_DIROPEN              ; Open up the directory
.1a69bc	b0 22		bcs $1a69e0	                BCS pr_first
.1a69be	20 96 6b	jsr $1a6b96	            JSR SET_DOSSTAT
.1a69c1	08		php		            PHP
.1a69c2	c2 20		rep #$20	            REP #$20
.1a69c4	48		pha		            PHA
.1a69c5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a69c8	5b		tcd		            TCD
.1a69c9	68		pla		            PLA
.1a69ca	28		plp		            PLP
.1a69cb	e2 20		sep #$20	            SEP #$20
.1a69cd	a9 10		lda #$10	            LDA #ERR_DIRECTORY
.1a69cf	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a69d3	c2 20		rep #$20	            REP #$20
.1a69d5	29 ff 00	and #$00ff	            AND #$00FF
.1a69d8	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a69db	e2 20		sep #$20	            SEP #$20
.1a69dd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a69e0					pr_first
.1a69e0	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a69e3					pr_entry
.1a69e3	08		php		            PHP
.1a69e4	c2 20		rep #$20	            REP #$20
.1a69e6	48		pha		            PHA
.1a69e7	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.1a69ea	5b		tcd		            TCD
.1a69eb	68		pla		            PLA
.1a69ec	28		plp		            PLP
.1a69ed	e2 20		sep #$20	            SEP #$20
.1a69ef	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Start with the file name
.1a69f2	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the initial character of the name
.1a69f4	d0 03		bne $1a69f9	                BNE chk_unused
.1a69f6	82 a9 00	brl $1a6aa2	                BRL done                    ; If it's NULL, we're done
.1a69f9	c9 e5		cmp #$e5	chk_unused      CMP #DOS_DIR_ENT_UNUSED     ; Is it the unusued code?
.1a69fb	d0 03		bne $1a6a00	                BNE chk_attributes
.1a69fd	82 96 00	brl $1a6a96	                BRL next_entry              ; Yes: go to the next entry
.1a6a00	a0 0b 00	ldy #$000b	chk_attributes  LDY #DIRENTRY.ATTRIBUTE
.1a6a03	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute byte
.1a6a05	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.1a6a07	f0 03		beq $1a6a0c	                BEQ chk_hidden
.1a6a09	82 a9 00	brl $1a6ab5	                BRL pr_volume               ; Print the volume label
.1a6a0c	89 02		bit #$02	chk_hidden      BIT #DOS_ATTR_HIDDEN        ; Is it a hidden file?
.1a6a0e	f0 03		beq $1a6a13	                BEQ chk_long
.1a6a10	82 83 00	brl $1a6a96	                BRL next_entry              ; Yes: go to the next entry
.1a6a13	29 0f		and #$0f	chk_long        AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.1a6a15	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.1a6a17	d0 03		bne $1a6a1c	                BNE get_short_name
.1a6a19	82 7a 00	brl $1a6a96	                BRL next_entry              ; Yes: go to the next entry
.1a6a1c	a0 00 00	ldy #$0000	get_short_name  LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.1a6a1f	b7 18		lda [$0338],y	pr_name_loop    LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.1a6a21	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6a24	c8		iny		                INY                         ; Move to the next character
.1a6a25	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.1a6a28	d0 f5		bne $1a6a1f	                BNE pr_name_loop            ; No: print this new character
.1a6a2a	a9 20		lda #$20	                LDA #' '                    ; Print the separator
.1a6a2c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6a2f	a0 08 00	ldy #$0008	                LDY #DIRENTRY.SHORTNAME+8   ; Move to the first of the extension characters
.1a6a32	b7 18		lda [$0338],y	pr_ext_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.1a6a34	20 18 00	jsr $1a0018	                JSR PRINTC                  ; Otherwise: print it.
.1a6a37	c8		iny		                INY                         ; Move to the next character
.1a6a38	c0 0b 00	cpy #$000b	                CPY #DIRENTRY.SHORTNAME+11  ; Are we at the end of the extension portion?
.1a6a3b	d0 f5		bne $1a6a32	                BNE pr_ext_loop             ; No: print this new character
.1a6a3d	a9 09		lda #$09	pr_tab1         LDA #CHAR_TAB               ; Print a TAB
.1a6a3f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6a42	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.1a6a45	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.1a6a47	89 10		bit #$10	                BIT #DOS_ATTR_DIR           ; Is it a directory?
.1a6a49	d0 1e		bne $1a6a69	                BNE pr_attr                 ; Yes: skip printing a file size
.1a6a4b	c2 20		rep #$20	            REP #$20
.1a6a4d	a0 1c 00	ldy #$001c	                LDY #DIRENTRY.SIZE
.1a6a50	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the file size
.1a6a52	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.1a6a56	c8		iny		                INY
.1a6a57	c8		iny		                INY
.1a6a58	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y
.1a6a5a	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.1a6a5e	e2 20		sep #$20	            SEP #$20
.1a6a60	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a6a62	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.1a6a66	20 2b 69	jsr $1a692b	            JSR PR_FILESIZE
.1a6a69	a9 09		lda #$09	pr_attr         LDA #CHAR_TAB               ; Print a TAB
.1a6a6b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6a6e	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.1a6a71	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.1a6a73	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.1a6a75	d0 1c		bne $1a6a93	                BNE end_entry               ; Yes: we're done printing this entry
.1a6a77	89 01		bit #$01	chk_read        BIT #DOS_ATTR_RO            ; Is it a read-only file?
.1a6a79	f0 05		beq $1a6a80	                BEQ chk_system
.1a6a7b	a9 52		lda #$52	                LDA #'R'                    ; Yes: print an R
.1a6a7d	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6a80	89 04		bit #$04	chk_system      BIT #DOS_ATTR_SYSTEM        ; Is it System file?
.1a6a82	f0 05		beq $1a6a89	                BEQ chk_directory
.1a6a84	a9 53		lda #$53	                LDA #'S'                    ; Yes: print an S
.1a6a86	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6a89	89 10		bit #$10	chk_directory   BIT #DOS_ATTR_DIR           ; Is it a directory?
.1a6a8b	f0 05		beq $1a6a92	                BEQ pr_tab2
.1a6a8d	a9 44		lda #$44	                LDA #'D'                    ; Yes: print a D
.1a6a8f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6a92	ea		nop		pr_tab2         NOP
.1a6a93					end_entry
.1a6a93	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a6a96					next_entry
.1a6a96	20 ee 03	jsr $1a03ee	            JSR PAGINATE
.1a6a99	22 0c 11 00	jsl $00110c	                JSL FK_DIRNEXT
.1a6a9d	90 03		bcc $1a6aa2	                BCC done
.1a6a9f	82 41 ff	brl $1a69e3	                BRL pr_entry
.1a6aa2					done
.1a6aa2	20 96 6b	jsr $1a6b96	            JSR SET_DOSSTAT
.1a6aa5	08		php		            PHP
.1a6aa6	c2 20		rep #$20	            REP #$20
.1a6aa8	48		pha		            PHA
.1a6aa9	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6aac	5b		tcd		            TCD
.1a6aad	68		pla		            PLA
.1a6aae	28		plp		            PLP
.1a6aaf	20 62 21	jsr $1a2162	            JSR SKIPSTMT
.1a6ab2	28		plp		                PLP
.1a6ab3	2b		pld		                PLD
.1a6ab4	60		rts		            RTS
.1a6ab5					pr_volume
.1a6ab5	08		php		            PHP
.1a6ab6	c2 20		rep #$20	            REP #$20
.1a6ab8	48		pha		            PHA
.1a6ab9	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.1a6abc	5b		tcd		            TCD
.1a6abd	68		pla		            PLA
.1a6abe	28		plp		            PLP
.1a6abf	e2 20		sep #$20	            SEP #$20
.1a6ac1	29 0f		and #$0f	                AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.1a6ac3	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.1a6ac5	f0 cf		beq $1a6a96	                BEQ next_entry              ; Yes: skip it
.1a6ac7	a9 5b		lda #$5b	pr_lbracket     LDA #'['
.1a6ac9	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6acc	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.1a6acf	b7 18		lda [$0338],y	pr_vol_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.1a6ad1	c9 20		cmp #$20	                CMP #CHAR_SP                ; Is it a blank?
.1a6ad3	f0 09		beq $1a6ade	                BEQ pr_rbracket             ; Yes: end the name and print the dot
.1a6ad5	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6ad8	c8		iny		                INY                         ; Move to the next character
.1a6ad9	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.1a6adc	d0 f1		bne $1a6acf	                BNE pr_vol_loop             ; No: print this new character
.1a6ade	a9 5d		lda #$5d	pr_rbracket     LDA #']'                    ; Print a close bracket
.1a6ae0	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6ae3	80 ae		bra $1a6a93	                BRA end_entry               ; And try to get the next entry
.1a6ae5					SETFILEDESC
.1a6ae5	0b		phd		                PHD
.1a6ae6	08		php		                PHP
.1a6ae7	08		php		            PHP
.1a6ae8	c2 20		rep #$20	            REP #$20
.1a6aea	48		pha		            PHA
.1a6aeb	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.1a6aee	5b		tcd		            TCD
.1a6aef	68		pla		            PLA
.1a6af0	28		plp		            PLP
.1a6af1	c2 30		rep #$30	            REP #$30
.1a6af3	a9 73 f2	lda #$f273	                LDA #<>FD_IN            ; Point to the file descriptor
.1a6af6	85 20		sta $0340	                STA DOS_FD_PTR
.1a6af8	a9 1a 00	lda #$001a	                LDA #`FD_IN
.1a6afb	85 22		sta $0342	                STA DOS_FD_PTR+2
.1a6afd	a0 00 00	ldy #$0000	                LDY #0                  ; Fille the file descriptor with 0
.1a6b00	e2 20		sep #$20	            SEP #$20
.1a6b02	a9 00		lda #$00	                LDA #0
.1a6b04	97 20		sta [$0340],y	zero_loop       STA [DOS_FD_PTR],Y
.1a6b06	c8		iny		                INY
.1a6b07	c0 1e 00	cpy #$001e	                CPY #SIZE(FILEDESC)
.1a6b0a	d0 f8		bne $1a6b04	                BNE zero_loop
.1a6b0c	c2 20		rep #$20	            REP #$20
.1a6b0e	a9 73 f0	lda #$f073	                LDA #<>CLUSTER_BUFF     ; Point to the cluster buffer
.1a6b11	8f 81 f2 1a	sta $1af281	                STA @l FD_IN.BUFFER
.1a6b15	a9 1a 00	lda #$001a	                LDA #`CLUSTER_BUFF
.1a6b18	8f 83 f2 1a	sta $1af283	                STA @l FD_IN.BUFFER+2
.1a6b1c	af 23 08 00	lda $000823	                LDA @l ARGUMENT1        ; Point the file desriptor to the path
.1a6b20	8f 75 f2 1a	sta $1af275	                STA @l FD_IN.PATH
.1a6b24	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a6b28	8f 77 f2 1a	sta $1af277	                STA @l FD_IN.PATH+2
.1a6b2c	28		plp		                PLP
.1a6b2d	2b		pld		                PLD
.1a6b2e	60		rts		            RTS
.1a6b2f					S_BLOAD
.1a6b2f	08		php		                PHP
.1a6b30	c2 30		rep #$30	            REP #$30
.1a6b32	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a6b35	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a6b38	20 e3 06	jsr $1a06e3	            JSR ASS_ARG1_STR
.1a6b3b	20 e5 6a	jsr $1a6ae5	            JSR SETFILEDESC
.1a6b3e	e2 20		sep #$20	            SEP #$20
.1a6b40	a9 2c		lda #$2c	                LDA #','
.1a6b42	85 37		sta $0837	                STA TARGETTOK
.1a6b44	20 5f 22	jsr $1a225f	            JSR OPT_TOK
.1a6b47	b0 0f		bcs $1a6b58	                BCS get_dest
.1a6b49	c2 20		rep #$20	            REP #$20
.1a6b4b	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set destination address to something "safe"
.1a6b4e	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a6b52	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a6b56	80 17		bra $1a6b6f	                BRA do_load
.1a6b58					get_dest
.1a6b58	20 1d 21	jsr $1a211d	            JSR INCBIP
.1a6b5b	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a6b5e	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a6b61	c2 20		rep #$20	            REP #$20
.1a6b63	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the destination address
.1a6b65	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a6b69	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6b6b	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a6b6f	22 18 11 00	jsl $001118	do_load         JSL FK_LOAD                 ; Attempt to load the file
.1a6b73	b0 1f		bcs $1a6b94	                BCS done
.1a6b75	08		php		            PHP
.1a6b76	c2 20		rep #$20	            REP #$20
.1a6b78	48		pha		            PHA
.1a6b79	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6b7c	5b		tcd		            TCD
.1a6b7d	68		pla		            PLA
.1a6b7e	28		plp		            PLP
.1a6b7f	e2 20		sep #$20	            SEP #$20
.1a6b81	a9 11		lda #$11	            LDA #ERR_LOAD
.1a6b83	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6b87	c2 20		rep #$20	            REP #$20
.1a6b89	29 ff 00	and #$00ff	            AND #$00FF
.1a6b8c	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a6b8f	e2 20		sep #$20	            SEP #$20
.1a6b91	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6b94	28		plp		done            PLP
.1a6b95	60		rts		            RTS
.1a6b96					SET_DOSSTAT
.1a6b96	8b		phb		                PHB
.1a6b97	0b		phd		                PHD
.1a6b98	08		php		                PHP
.1a6b99	08		php		            PHP
.1a6b9a	c2 20		rep #$20	            REP #$20
.1a6b9c	48		pha		            PHA
.1a6b9d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6ba0	5b		tcd		            TCD
.1a6ba1	68		pla		            PLA
.1a6ba2	28		plp		            PLP
.1a6ba3	08		php		            PHP
.1a6ba4	e2 20		sep #$20	            SEP #$20
.1a6ba6	48		pha		            PHA
.1a6ba7	a9 00		lda #$00	            LDA #BASIC_BANK
.1a6ba9	48		pha		            PHA
.1a6baa	ab		plb		            PLB
.1a6bab	68		pla		            PLA
.1a6bac	28		plp		            PLP
.1a6bad	e2 20		sep #$20	            SEP #$20
.1a6baf	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS           ; Get the DOS status code
.1a6bb3	85 23		sta $0823	                STA ARGUMENT1
.1a6bb5	a9 00		lda #$00	                LDA #0
.1a6bb7	85 24		sta $0824	                STA ARGUMENT1+1
.1a6bb9	85 25		sta $0825	                STA ARGUMENT1+2
.1a6bbb	85 26		sta $0826	                STA ARGUMENT1+3
.1a6bbd	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a6bbf	85 27		sta $0827	                STA ARGTYPE1
.1a6bc1	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (DOSSTAT)
.1a6bc3	a9 1a		lda #$1a	                LDA #`dosstat_name
.1a6bc5	85 e9		sta $08e9	                STA TOFIND+2
.1a6bc7	c2 20		rep #$20	            REP #$20
.1a6bc9	a9 f9 6b	lda #$6bf9	                LDA #<>dosstat_name
.1a6bcc	85 e7		sta $08e7	                STA TOFIND
.1a6bce	20 83 53	jsr $1a5383	            JSR VAR_SET
.1a6bd1	e2 20		sep #$20	            SEP #$20
.1a6bd3	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS          ; Get the BIOS status code
.1a6bd7	85 23		sta $0823	                STA ARGUMENT1
.1a6bd9	a9 00		lda #$00	                LDA #0
.1a6bdb	85 24		sta $0824	                STA ARGUMENT1+1
.1a6bdd	85 25		sta $0825	                STA ARGUMENT1+2
.1a6bdf	85 26		sta $0826	                STA ARGUMENT1+3
.1a6be1	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a6be3	85 27		sta $0827	                STA ARGTYPE1
.1a6be5	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BIOSSTAT)
.1a6be7	a9 1a		lda #$1a	                LDA #`biosstat_name
.1a6be9	85 e9		sta $08e9	                STA TOFIND+2
.1a6beb	c2 20		rep #$20	            REP #$20
.1a6bed	a9 01 6c	lda #$6c01	                LDA #<>biosstat_name
.1a6bf0	85 e7		sta $08e7	                STA TOFIND
.1a6bf2	20 83 53	jsr $1a5383	            JSR VAR_SET
.1a6bf5	28		plp		                PLP
.1a6bf6	2b		pld		                PLD
.1a6bf7	ab		plb		                PLB
.1a6bf8	60		rts		            RTS
>1a6bf9	44 4f 53 53 54 41 54 00		dosstat_name    .null "DOSSTAT"
>1a6c01	42 49 4f 53 53 54 41 54		biosstat_name   .null "BIOSSTAT"
>1a6c09	00
.1a6c0a					CMD_BRUN
.1a6c0a	08		php		                PHP
.1a6c0b	c2 30		rep #$30	            REP #$30
.1a6c0d	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a6c10	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a6c13	20 e3 06	jsr $1a06e3	            JSR ASS_ARG1_STR
.1a6c16	a5 23		lda $0823	                LDA ARGUMENT1
.1a6c18	8f 60 03 00	sta $000360	                STA @l DOS_RUN_PARAM
.1a6c1c	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6c1e	8f 62 03 00	sta $000362	                STA @l DOS_RUN_PARAM+2
.1a6c22	a9 ff ff	lda #$ffff	                LDA #$FFFF
.1a6c25	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a6c29	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a6c2d	22 24 11 00	jsl $001124	                JSL FK_RUN                  ; Attempt to run the file
.1a6c31	b0 25		bcs $1a6c58	                BCS done                    ; If we got it: try to execute it
.1a6c33	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a6c36	20 96 6b	jsr $1a6b96	            JSR SET_DOSSTAT
.1a6c39	08		php		            PHP
.1a6c3a	c2 20		rep #$20	            REP #$20
.1a6c3c	48		pha		            PHA
.1a6c3d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6c40	5b		tcd		            TCD
.1a6c41	68		pla		            PLA
.1a6c42	28		plp		            PLP
.1a6c43	e2 20		sep #$20	            SEP #$20
.1a6c45	a9 11		lda #$11	            LDA #ERR_LOAD
.1a6c47	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6c4b	c2 20		rep #$20	            REP #$20
.1a6c4d	29 ff 00	and #$00ff	            AND #$00FF
.1a6c50	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a6c53	e2 20		sep #$20	            SEP #$20
.1a6c55	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6c58					done
.1a6c58	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a6c5b	28		plp		                PLP
.1a6c5c	60		rts		            RTS
.1a6c5d					CMD_LOAD
.1a6c5d	08		php		                PHP
.1a6c5e	c2 30		rep #$30	            REP #$30
.1a6c60	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a6c63	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a6c66	20 e3 06	jsr $1a06e3	            JSR ASS_ARG1_STR
.1a6c69	20 e5 6a	jsr $1a6ae5	            JSR SETFILEDESC
.1a6c6c	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.1a6c6f	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a6c73	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.1a6c76	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2        ; Set the destination address
.1a6c7a	20 54 50	jsr $1a5054	            JSR CMD_NEW
.1a6c7d	22 18 11 00	jsl $001118	                JSL FK_LOAD                 ; Attempt to load the file
.1a6c81	b0 22		bcs $1a6ca5	                BCS start_tokenize          ; If we got it: start tokenizing
.1a6c83	20 96 6b	jsr $1a6b96	            JSR SET_DOSSTAT
.1a6c86	08		php		            PHP
.1a6c87	c2 20		rep #$20	            REP #$20
.1a6c89	48		pha		            PHA
.1a6c8a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6c8d	5b		tcd		            TCD
.1a6c8e	68		pla		            PLA
.1a6c8f	28		plp		            PLP
.1a6c90	e2 20		sep #$20	            SEP #$20
.1a6c92	a9 11		lda #$11	            LDA #ERR_LOAD
.1a6c94	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6c98	c2 20		rep #$20	            REP #$20
.1a6c9a	29 ff 00	and #$00ff	            AND #$00FF
.1a6c9d	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a6ca0	e2 20		sep #$20	            SEP #$20
.1a6ca2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6ca5					start_tokenize
.1a6ca5	20 96 6b	jsr $1a6b96	            JSR SET_DOSSTAT
.1a6ca8	c2 20		rep #$20	            REP #$20
.1a6caa	a2 12 00	ldx #$0012	                LDX #FILEDESC.FILESIZE
.1a6cad	18		clc		                CLC                         ; Set MTEMP to point to the byte after the file
.1a6cae	bf 73 f2 1a	lda $1af273,x	                LDA FD_IN,X
.1a6cb2	69 00 00	adc #$0000	                ADC #<>LOADBLOCK
.1a6cb5	85 92		sta $0892	                STA MTEMP
.1a6cb7	bf 75 f2 1a	lda $1af275,x	                LDA FD_IN+2,X
.1a6cbb	69 01 00	adc #$0001	                ADC #`LOADBLOCK
.1a6cbe	85 94		sta $0894	                STA MTEMP+2
.1a6cc0	e2 20		sep #$20	            SEP #$20
.1a6cc2	a9 00		lda #$00	                LDA #0
.1a6cc4	87 92		sta [$0892]	                STA [MTEMP]                 ; Write a NULL right after the file
.1a6cc6	c2 20		rep #$20	            REP #$20
.1a6cc8	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK            ; Set MCURSOR to the begining of the loaded data
.1a6ccb	85 7a		sta $087a	                STA MCURSOR
.1a6ccd	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.1a6cd0	85 7c		sta $087c	                STA MCURSOR+2
.1a6cd2	a2 00 00	ldx #$0000	copy_line       LDX #0
.1a6cd5					copy_char
.1a6cd5	e2 20		sep #$20	            SEP #$20
.1a6cd7	a7 7a		lda [$087a]	                LDA [MCURSOR]
.1a6cd9	f0 2a		beq $1a6d05	                BEQ clean_up                ; If the character is 0, we're done
.1a6cdb	c9 0d		cmp #$0d	                CMP #CHAR_CR                ; If it is new line...
.1a6cdd	f0 12		beq $1a6cf1	                BEQ do_process              ; ... we want to process the line
.1a6cdf	c9 0a		cmp #$0a	                CMP #CHAR_LF                ; If it is a line feed...
.1a6ce1	f0 04		beq $1a6ce7	                BEQ next_char               ; ... we want to skip it
.1a6ce3	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X              ; Otherwise, copy the character to the input buffer
.1a6ce6	e8		inx		                INX
.1a6ce7					next_char
.1a6ce7	c2 20		rep #$20	            REP #$20
.1a6ce9	e6 7a		inc $087a	                INC MCURSOR                 ; Advance the input cursor
.1a6ceb	d0 e8		bne $1a6cd5	                BNE copy_char
.1a6ced	e6 7c		inc $087c	                INC MCURSOR+2
.1a6cef	80 e4		bra $1a6cd5	                BRA copy_char
.1a6cf1					do_process
.1a6cf1	e2 20		sep #$20	            SEP #$20
.1a6cf3	a9 00		lda #$00	                LDA #0                      ; Put a 0 at the end of the input buffer
.1a6cf5	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a6cf8	20 8d 27	jsr $1a278d	            JSR PROCESS
.1a6cfb	c2 20		rep #$20	            REP #$20
.1a6cfd	e6 7a		inc $087a	                INC MCURSOR                 ; Try again with the next line
.1a6cff	d0 d1		bne $1a6cd2	                BNE copy_line
.1a6d01	e6 7c		inc $087c	                INC MCURSOR+2
.1a6d03	80 cd		bra $1a6cd2	                BRA copy_line
.1a6d05	e0 00 00	cpx #$0000	clean_up        CPX #0                      ; Is there data in the INPUTBUF?
.1a6d08	f0 0a		beq $1a6d14	                BEQ done                    ; No: just return
.1a6d0a	e2 20		sep #$20	            SEP #$20
.1a6d0c	a9 00		lda #$00	                LDA #0                      ; Make sure there is a trailing NULL
.1a6d0e	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a6d11	20 8d 27	jsr $1a278d	            JSR PROCESS
.1a6d14	28		plp		done            PLP
.1a6d15	60		rts		            RTS
.1a6d16					S_BSAVE
.1a6d16	08		php		                PHP
.1a6d17	c2 30		rep #$30	            REP #$30
.1a6d19	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a6d1c	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a6d1f	20 e3 06	jsr $1a06e3	            JSR ASS_ARG1_STR
.1a6d22	20 e5 6a	jsr $1a6ae5	            JSR SETFILEDESC
.1a6d25	e2 20		sep #$20	            SEP #$20
.1a6d27	a9 2c		lda #$2c	                LDA #','
.1a6d29	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a6d2c	c2 20		rep #$20	            REP #$20
.1a6d2e	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a6d31	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a6d34	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_SRC_PTR
.1a6d36	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.1a6d3a	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6d3c	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.1a6d40	e2 20		sep #$20	            SEP #$20
.1a6d42	a9 2c		lda #$2c	                LDA #','
.1a6d44	c2 20		rep #$20	            REP #$20
.1a6d46	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a6d49	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a6d4c	20 51 06	jsr $1a0651	            JSR ASS_ARG1_INT
.1a6d4f	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_END_PTR
.1a6d51	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.1a6d55	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6d57	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.1a6d5b	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                 ; Attempt to save the memory to file.
.1a6d5f	b0 22		bcs $1a6d83	                BCS done
.1a6d61	20 96 6b	jsr $1a6b96	            JSR SET_DOSSTAT
.1a6d64	08		php		            PHP
.1a6d65	c2 20		rep #$20	            REP #$20
.1a6d67	48		pha		            PHA
.1a6d68	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6d6b	5b		tcd		            TCD
.1a6d6c	68		pla		            PLA
.1a6d6d	28		plp		            PLP
.1a6d6e	e2 20		sep #$20	            SEP #$20
.1a6d70	a9 12		lda #$12	            LDA #ERR_SAVE
.1a6d72	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6d76	c2 20		rep #$20	            REP #$20
.1a6d78	29 ff 00	and #$00ff	            AND #$00FF
.1a6d7b	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a6d7e	e2 20		sep #$20	            SEP #$20
.1a6d80	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6d83					done
.1a6d83	20 96 6b	jsr $1a6b96	            JSR SET_DOSSTAT
.1a6d86	28		plp		                PLP
.1a6d87	60		rts		            RTS
.1a6d88					COPY2PATHBUF
.1a6d88	da		phx		                PHX
.1a6d89	5a		phy		                PHY
.1a6d8a	08		php		                PHP
.1a6d8b	a2 00 00	ldx #$0000	                LDX #0
.1a6d8e	a0 00 00	ldy #$0000	                LDY #0
.1a6d91	e2 20		sep #$20	            SEP #$20
.1a6d93	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y           ; Copy the path to the DOS_PATH_BUFF
.1a6d95	9d 00 04	sta $0400,x	                STA DOS_PATH_BUFF,X
.1a6d98	f0 04		beq $1a6d9e	                BEQ done
.1a6d9a	e8		inx		                INX
.1a6d9b	c8		iny		                INY
.1a6d9c	80 f5		bra $1a6d93	                BRA loop
.1a6d9e	28		plp		done            PLP
.1a6d9f	7a		ply		                PLY
.1a6da0	fa		plx		                PLX
.1a6da1	60		rts		            RTS
.1a6da2					CMD_SAVE
.1a6da2	08		php		                PHP
.1a6da3	c2 30		rep #$30	            REP #$30
.1a6da5	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a6da8	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a6dab	20 e3 06	jsr $1a06e3	            JSR ASS_ARG1_STR
.1a6dae	20 e5 6a	jsr $1a6ae5	            JSR SETFILEDESC
.1a6db1	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.1a6db4	85 a6		sta $08a6	                STA OBUFFER
.1a6db6	e2 20		sep #$20	            SEP #$20
.1a6db8	a9 01		lda #$01	                LDA #`LOADBLOCK
.1a6dba	85 a8		sta $08a8	                STA OBUFFER+2
.1a6dbc	a9 20		lda #$20	                LDA #DEV_BUFFER             ; Set up output for the buffer
.1a6dbe	85 b4		sta $08b4	                STA BCONSOLE
.1a6dc0	c2 20		rep #$20	            REP #$20
.1a6dc2	a9 00 00	lda #$0000	                LDA #0
.1a6dc5	85 ab		sta $08ab	                STA OBUFFIDX
.1a6dc7	a9 ff ff	lda #$ffff	                LDA #$FFFF
.1a6dca	85 a9		sta $08a9	                STA OBUFFSIZE
.1a6dcc	c2 20		rep #$20	            REP #$20
.1a6dce	a9 00 00	lda #$0000	                LDA #0                      ; Set start line number to 0
.1a6dd1	85 55		sta $0855	                STA MARG1
.1a6dd3	85 57		sta $0857	                STA MARG1+2
.1a6dd5	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set end line number to MAXINT
.1a6dd8	85 59		sta $0859	                STA MARG2
.1a6dda	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.1a6ddd	85 5b		sta $085b	                STA MARG2+2
.1a6ddf	20 8b 18	jsr $1a188b	            JSR LISTPROG
.1a6de2	e2 20		sep #$20	            SEP #$20
.1a6de4	a9 80		lda #$80	                LDA #DEV_SCREEN             ; Restore output to the screen
.1a6de6	85 b4		sta $08b4	                STA BCONSOLE
.1a6de8	c2 20		rep #$20	            REP #$20
.1a6dea	c6 ab		dec $08ab	                DEC OBUFFIDX                ; OBUFFIDX points to the next free byte... so pull it in one
.1a6dec	18		clc		                CLC                         ; Set the range of memory to save
.1a6ded	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.1a6df0	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.1a6df4	65 ab		adc $08ab	                ADC OBUFFIDX
.1a6df6	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.1a6dfa	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.1a6dfd	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.1a6e01	69 00 00	adc #$0000	                ADC #0
.1a6e04	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.1a6e08	22 1c 11 00	jsl $00111c	do_save         JSL FK_SAVE                 ; Attempt to save the file
.1a6e0c	b0 22		bcs $1a6e30	                BCS done
.1a6e0e	20 96 6b	jsr $1a6b96	            JSR SET_DOSSTAT
.1a6e11	08		php		            PHP
.1a6e12	c2 20		rep #$20	            REP #$20
.1a6e14	48		pha		            PHA
.1a6e15	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6e18	5b		tcd		            TCD
.1a6e19	68		pla		            PLA
.1a6e1a	28		plp		            PLP
.1a6e1b	e2 20		sep #$20	            SEP #$20
.1a6e1d	a9 12		lda #$12	            LDA #ERR_SAVE
.1a6e1f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6e23	c2 20		rep #$20	            REP #$20
.1a6e25	29 ff 00	and #$00ff	            AND #$00FF
.1a6e28	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a6e2b	e2 20		sep #$20	            SEP #$20
.1a6e2d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6e30					done
.1a6e30	20 96 6b	jsr $1a6b96	            JSR SET_DOSSTAT
.1a6e33	28		plp		                PLP
.1a6e34	60		rts		            RTS
.1a6e35					S_DEL
.1a6e35	08		php		                PHP
.1a6e36	c2 30		rep #$30	            REP #$30
.1a6e38	20 3e 21	jsr $1a213e	            JSR SKIPWS
.1a6e3b	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a6e3e	20 e3 06	jsr $1a06e3	            JSR ASS_ARG1_STR
.1a6e41	20 88 6d	jsr $1a6d88	            JSR COPY2PATHBUF
.1a6e44	22 04 11 00	jsl $001104	path_loaded     JSL FK_DELETE               ; Try to delete the file
.1a6e48	b0 22		bcs $1a6e6c	                BCS done
.1a6e4a	20 96 6b	jsr $1a6b96	            JSR SET_DOSSTAT
.1a6e4d	08		php		            PHP
.1a6e4e	c2 20		rep #$20	            REP #$20
.1a6e50	48		pha		            PHA
.1a6e51	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6e54	5b		tcd		            TCD
.1a6e55	68		pla		            PLA
.1a6e56	28		plp		            PLP
.1a6e57	e2 20		sep #$20	            SEP #$20
.1a6e59	a9 13		lda #$13	            LDA #ERR_DELETE
.1a6e5b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6e5f	c2 20		rep #$20	            REP #$20
.1a6e61	29 ff 00	and #$00ff	            AND #$00FF
.1a6e64	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a6e67	e2 20		sep #$20	            SEP #$20
.1a6e69	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6e6c					done
.1a6e6c	20 96 6b	jsr $1a6b96	            JSR SET_DOSSTAT
.1a6e6f	28		plp		                PLP
.1a6e70	60		rts		            RTS
.1a6e71					VALIDFILECHAR
.1a6e71	da		phx		                PHX
.1a6e72	08		php		                PHP
.1a6e73	e2 20		sep #$20	            SEP #$20
.1a6e75	c9 61		cmp #$61	                CMP #'a'                    ; Is it lower case?
.1a6e77	90 08		bcc $1a6e81	                BLT chk_space
.1a6e79	c9 7b		cmp #$7b	                CMP #'z'+1
.1a6e7b	b0 04		bcs $1a6e81	                BGE chk_space
.1a6e7d	29 df		and #$df	                AND #%11011111              ; Yes: convert to upper case
.1a6e7f	80 13		bra $1a6e94	                BRA ret_valid
.1a6e81	c9 20		cmp #$20	chk_space       CMP #CHAR_SP            ; Is it a control code?
.1a6e83	90 13		bcc $1a6e98	                BLT is_invalid          ; Yes: it's invalid
.1a6e85	a2 00 00	ldx #$0000	                LDX #0                  ; See if it's in the list of invalids
.1a6e88	df 9c 6e 1a	cmp $1a6e9c,x	loop            CMP invalid_chars,X
.1a6e8c	f0 0a		beq $1a6e98	                BEQ is_invalid
.1a6e8e	e8		inx		                INX
.1a6e8f	e0 0f 00	cpx #$000f	                CPX #15                 ; # of invalid characters
.1a6e92	d0 f4		bne $1a6e88	                BNE loop
.1a6e94	28		plp		ret_valid       PLP
.1a6e95	38		sec		                SEC
.1a6e96	fa		plx		                PLX
.1a6e97	6b		rtl		                RTL
.1a6e98	28		plp		is_invalid      PLP
.1a6e99	18		clc		                CLC
.1a6e9a	fa		plx		                PLX
.1a6e9b	6b		rtl		                RTL
>1a6e9c	2a 2b 2c 2f 3a 3b 3c 3d		invalid_chars   .text "*+,/:;<=>?\[]|",CHAR_DQUOTE
>1a6ea4	3e 3f 5c 5b 5d 7c 22
.1a6eab					S_RENAME
.1a6eab	08		php		                PHP
.1a6eac	08		php		            PHP
.1a6ead	c2 20		rep #$20	            REP #$20
.1a6eaf	48		pha		            PHA
.1a6eb0	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6eb3	5b		tcd		            TCD
.1a6eb4	68		pla		            PLA
.1a6eb5	28		plp		            PLP
.1a6eb6	c2 30		rep #$30	            REP #$30
.1a6eb8	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a6ebb	20 e3 06	jsr $1a06e3	            JSR ASS_ARG1_STR
.1a6ebe	20 88 6d	jsr $1a6d88	            JSR COPY2PATHBUF
.1a6ec1	22 10 11 00	jsl $001110	                JSL FK_DIRREAD              ; Try to read the file
.1a6ec5	b0 22		bcs $1a6ee9	                BCS get_new_name            ; If ok: get the new name
.1a6ec7	20 96 6b	jsr $1a6b96	            JSR SET_DOSSTAT
.1a6eca	08		php		            PHP
.1a6ecb	c2 20		rep #$20	            REP #$20
.1a6ecd	48		pha		            PHA
.1a6ece	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6ed1	5b		tcd		            TCD
.1a6ed2	68		pla		            PLA
.1a6ed3	28		plp		            PLP
.1a6ed4	e2 20		sep #$20	            SEP #$20
.1a6ed6	a9 14		lda #$14	            LDA #ERR_FILENOTFOUND
.1a6ed8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6edc	c2 20		rep #$20	            REP #$20
.1a6ede	29 ff 00	and #$00ff	            AND #$00FF
.1a6ee1	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a6ee4	e2 20		sep #$20	            SEP #$20
.1a6ee6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6ee9					get_new_name
.1a6ee9	e2 20		sep #$20	            SEP #$20
.1a6eeb	a9 2c		lda #$2c	                LDA #','
.1a6eed	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a6ef0	c2 20		rep #$20	            REP #$20
.1a6ef2	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a6ef5	20 e3 06	jsr $1a06e3	            JSR ASS_ARG1_STR
.1a6ef8	ad 38 03	lda $0338	                LDA DOS_DIR_PTR
.1a6efb	85 08		sta $0808	                STA INDEX
.1a6efd	ad 3a 03	lda $033a	                LDA DOS_DIR_PTR+2
.1a6f00	85 0a		sta $080a	                STA INDEX+2
.1a6f02	e2 20		sep #$20	            SEP #$20
.1a6f04	a2 00 00	ldx #$0000	                LDX #0
.1a6f07	a9 20		lda #$20	                LDA #CHAR_SP                ; We'll use MLINEBUFF as temporary name storage
.1a6f09	95 7e		sta $087e,x	blank_loop      STA MLINEBUF,X              ; Fill it with blanks
.1a6f0b	e8		inx		                INX
.1a6f0c	e0 0b 00	cpx #$000b	                CPX #11
.1a6f0f	d0 f8		bne $1a6f09	                BNE blank_loop
.1a6f11	a2 00 00	ldx #$0000	                LDX #0
.1a6f14	a0 00 00	ldy #$0000	                LDY #0
.1a6f17	b7 23		lda [$0823],y	name_loop       LDA [ARGUMENT1],Y           ; Get the character of the new name
.1a6f19	f0 76		beq $1a6f91	                BEQ copy_short_name         ; If end-of-string: copy what we have
.1a6f1b	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.1a6f1d	f0 39		beq $1a6f58	                BEQ skip_dot                ; Yes: move on to the extension characters
.1a6f1f	22 71 6e 1a	jsl $1a6e71	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.1a6f23	b0 1f		bcs $1a6f44	                BCS save_nm_char
.1a6f25	08		php		            PHP
.1a6f26	c2 20		rep #$20	            REP #$20
.1a6f28	48		pha		            PHA
.1a6f29	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6f2c	5b		tcd		            TCD
.1a6f2d	68		pla		            PLA
.1a6f2e	28		plp		            PLP
.1a6f2f	e2 20		sep #$20	            SEP #$20
.1a6f31	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a6f33	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6f37	c2 20		rep #$20	            REP #$20
.1a6f39	29 ff 00	and #$00ff	            AND #$00FF
.1a6f3c	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a6f3f	e2 20		sep #$20	            SEP #$20
.1a6f41	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6f44	95 7e		sta $087e,x	save_nm_char    STA MLINEBUF,X              ; Otherwise: copy it
.1a6f46	c8		iny		                INY
.1a6f47	e8		inx		                INX
.1a6f48	c0 08 00	cpy #$0008	                CPY #8
.1a6f4b	d0 ca		bne $1a6f17	                BNE name_loop
.1a6f4d	b7 23		lda [$0823],y	eat_name        LDA [ARGUMENT1],Y           ; Get the character
.1a6f4f	f0 40		beq $1a6f91	                BEQ copy_short_name         ; If null, we're done with the short name
.1a6f51	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.1a6f53	f0 03		beq $1a6f58	                BEQ skip_dot                ; Yes: skip over it
.1a6f55	c8		iny		                INY                         ; No: try again with the the next character
.1a6f56	80 f5		bra $1a6f4d	                BRA eat_name
.1a6f58	c8		iny		skip_dot        INY                         ; Character at Y is '.', so skip over it
.1a6f59	a2 08 00	ldx #$0008	do_ext          LDX #8
.1a6f5c	b7 23		lda [$0823],y	ext_loop        LDA [ARGUMENT1],Y           ; Get the character of the new extension
.1a6f5e	f0 31		beq $1a6f91	                BEQ copy_short_name         ; If end-of-string: copy what we have
.1a6f60	22 71 6e 1a	jsl $1a6e71	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.1a6f64	b0 22		bcs $1a6f88	                BCS save_ext_char
.1a6f66	20 96 6b	jsr $1a6b96	            JSR SET_DOSSTAT
.1a6f69	08		php		            PHP
.1a6f6a	c2 20		rep #$20	            REP #$20
.1a6f6c	48		pha		            PHA
.1a6f6d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6f70	5b		tcd		            TCD
.1a6f71	68		pla		            PLA
.1a6f72	28		plp		            PLP
.1a6f73	e2 20		sep #$20	            SEP #$20
.1a6f75	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a6f77	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6f7b	c2 20		rep #$20	            REP #$20
.1a6f7d	29 ff 00	and #$00ff	            AND #$00FF
.1a6f80	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a6f83	e2 20		sep #$20	            SEP #$20
.1a6f85	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6f88	95 7e		sta $087e,x	save_ext_char   STA MLINEBUF,X              ; Otherwise: copy it
.1a6f8a	c8		iny		                INY
.1a6f8b	e8		inx		                INX
.1a6f8c	c0 0c 00	cpy #$000c	                CPY #12
.1a6f8f	d0 cb		bne $1a6f5c	                BNE ext_loop
.1a6f91	a2 00 00	ldx #$0000	copy_short_name LDX #0                      ; Copy the short name we built to the directory entry
.1a6f94	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME
.1a6f97	b5 7e		lda $087e,x	copy_loop       LDA MLINEBUF,X
.1a6f99	97 08		sta [$0808],y	                STA [INDEX],Y
.1a6f9b	e8		inx		                INX
.1a6f9c	c8		iny		                INY
.1a6f9d	c0 0b 00	cpy #$000b	                CPY #11
.1a6fa0	d0 f5		bne $1a6f97	                BNE copy_loop
.1a6fa2	22 14 11 00	jsl $001114	                JSL FK_DIRWRITE             ; Write the directory entry back
.1a6fa6	b0 22		bcs $1a6fca	                BCS done
.1a6fa8	20 96 6b	jsr $1a6b96	            JSR SET_DOSSTAT
.1a6fab	08		php		            PHP
.1a6fac	c2 20		rep #$20	            REP #$20
.1a6fae	48		pha		            PHA
.1a6faf	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6fb2	5b		tcd		            TCD
.1a6fb3	68		pla		            PLA
.1a6fb4	28		plp		            PLP
.1a6fb5	e2 20		sep #$20	            SEP #$20
.1a6fb7	a9 15		lda #$15	            LDA #ERR_DIRNOTWRITE
.1a6fb9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6fbd	c2 20		rep #$20	            REP #$20
.1a6fbf	29 ff 00	and #$00ff	            AND #$00FF
.1a6fc2	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a6fc5	e2 20		sep #$20	            SEP #$20
.1a6fc7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6fca					done
.1a6fca	20 96 6b	jsr $1a6b96	            JSR SET_DOSSTAT
.1a6fcd	28		plp		                PLP
.1a6fce	60		rts		            RTS
.1a6fcf					S_COPY
.1a6fcf	08		php		                PHP
.1a6fd0	08		php		            PHP
.1a6fd1	c2 20		rep #$20	            REP #$20
.1a6fd3	48		pha		            PHA
.1a6fd4	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6fd7	5b		tcd		            TCD
.1a6fd8	68		pla		            PLA
.1a6fd9	28		plp		            PLP
.1a6fda	c2 30		rep #$30	            REP #$30
.1a6fdc	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a6fdf	20 e3 06	jsr $1a06e3	            JSR ASS_ARG1_STR
.1a6fe2	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.1a6fe4	8f 64 03 00	sta $000364	                STA @l DOS_STR1_PTR
.1a6fe8	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6fea	8f 66 03 00	sta $000366	                STA @l DOS_STR1_PTR+2
.1a6fee	e2 20		sep #$20	            SEP #$20
.1a6ff0	a9 2c		lda #$2c	                LDA #','
.1a6ff2	20 2a 22	jsr $1a222a	            JSR EXPECT_TOK
.1a6ff5	c2 20		rep #$20	            REP #$20
.1a6ff7	20 0c 1d	jsr $1a1d0c	            JSR EVALEXPR
.1a6ffa	20 e3 06	jsr $1a06e3	            JSR ASS_ARG1_STR
.1a6ffd	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.1a6fff	8f 68 03 00	sta $000368	                STA @l DOS_STR2_PTR
.1a7003	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a7005	8f 6a 03 00	sta $00036a	                STA @l DOS_STR2_PTR+2
.1a7009	22 30 11 00	jsl $001130	                JSL FK_COPY                 ; Attempt to copy the file
.1a700d	b0 1f		bcs $1a702e	                BCS done
.1a700f	08		php		            PHP
.1a7010	c2 20		rep #$20	            REP #$20
.1a7012	48		pha		            PHA
.1a7013	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a7016	5b		tcd		            TCD
.1a7017	68		pla		            PLA
.1a7018	28		plp		            PLP
.1a7019	e2 20		sep #$20	            SEP #$20
.1a701b	a9 16		lda #$16	            LDA #ERR_NOTCOPIED
.1a701d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a7021	c2 20		rep #$20	            REP #$20
.1a7023	29 ff 00	and #$00ff	            AND #$00FF
.1a7026	20 5e 1e	jsr $1a1e5e	            JSR SET_ERRERL
.1a7029	e2 20		sep #$20	            SEP #$20
.1a702b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a702e	28		plp		done            PLP
.1a702f	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\monitor.s

.1a7030	5c ed 89 1a	jmp $1a89ed	MRETURN         JML IMRETURN
.1a7034	5c 3e 88 1a	jmp $1a883e	MPARSE          JML IMPARSE
.1a7038	5c ee 89 1a	jmp $1a89ee	MPARSE1         JML IMPARSE1
.1a703c	5c 6a 79 1a	jmp $1a796a	MEXECUTE        JML IMEXECUTE
.1a7040	5c c7 79 1a	jmp $1a79c7	MASSEMBLE       JML IMASSEMBLE
.1a7044	5c fa 78 1a	jmp $1a78fa	MRMODIFY        JML IMRMODIFY
.1a7048	5c 80 78 1a	jmp $1a7880	MCOMPARE        JML IMCOMPARE
.1a704c	5c fd 7d 1a	jmp $1a7dfd	MDISASSEMBLE    JML IMDISASSEMBLE
.1a7050	5c eb 74 1a	jmp $1a74eb	MFILL           JML IMFILL
.1a7054	5c 18 78 1a	jmp $1a7818	MGO             JML IMGO
.1a7058	5c d3 77 1a	jmp $1a77d3	MJUMP           JML IMJUMP
.1a705c	5c 5d 77 1a	jmp $1a775d	MHUNT           JML IMHUNT
.1a7060	5c fc 88 1a	jmp $1a88fc	MLOAD           JML IMLOAD
.1a7064	5c f9 75 1a	jmp $1a75f9	MMEMORY         JML IMMEMORY
.1a7068	5c 49 74 1a	jmp $1a7449	MREGISTERS      JML IMREGISTERS
.1a706c	5c 77 89 1a	jmp $1a8977	MSAVE           JML IMSAVE
.1a7070	5c 27 75 1a	jmp $1a7527	MTRANSFER       JML IMTRANSFER
.1a7074	5c f0 89 1a	jmp $1a89f0	MVERIFY         JML IMVERIFY
.1a7078	5c e9 89 1a	jmp $1a89e9	MEXIT           JML IMEXIT
.1a707c	5c 16 77 1a	jmp $1a7716	MMODIFY         JML IMMODIFY
.1a7080	5c f1 89 1a	jmp $1a89f1	MDOS            JML IMDOS
.1a7084	18		clc		IMONITOR        CLC                 ; clear the carry flag
.1a7085	fb		xce		                XCE                 ; move carry to emulation flags
.1a7086	58		cli		                CLI                 ; Re-enable interrupts
.1a7087	5c 8b 70 1a	jmp $1a708b	                JML IMREADY
.1a708b					IMREADY
.1a708b	c2 30		rep #$30	            REP #$30
.1a708d	22 49 74 1a	jsl $1a7449	                JSL IMREGISTERS
.1a7091					ready_loop
.1a7091	20 08 00	jsr $1a0008	            JSR READLINE
.1a7094	20 0c 00	jsr $1a000c	            JSR SCRCOPYLINE
.1a7097	8b		phb		                PHB
.1a7098	e2 20		sep #$20	            SEP #$20
.1a709a	a9 00		lda #$00	                LDA #`INPUTBUF
.1a709c	48		pha		                PHA
.1a709d	ab		plb		                PLB
.1a709e	a2 00 4f	ldx #$4f00	                LDX #<>INPUTBUF
.1a70a1	20 65 05	jsr $1a0565	            JSR TOUPPER
.1a70a4	ab		plb		                PLB
.1a70a5	22 34 70 1a	jsl $1a7034	                JSL MPARSE          ; Parse the command
.1a70a9	22 3c 70 1a	jsl $1a703c	                JSL MEXECUTE        ; And execute the parsed command
.1a70ad	80 e2		bra $1a7091	                BRA ready_loop
.1a70af					IMHELP
.1a70af	08		php		                PHP
.1a70b0	8b		phb		                PHB
.1a70b1	e2 20		sep #$20	            SEP #$20
.1a70b3	a9 1a		lda #$1a	                LDA #`help_text
.1a70b5	48		pha		                PHA
.1a70b6	ab		plb		                PLB
.1a70b7	c2 10		rep #$10	            REP #$10
.1a70b9	a2 c2 70	ldx #$70c2	                LDX #<>help_text
.1a70bc	20 64 04	jsr $1a0464	            JSR PRINTS
.1a70bf	ab		plb		                PLB
.1a70c0	28		plp		                PLP
.1a70c1	6b		rtl		                RTL
>1a70c2	41 20 3c 73 74 61 72 74		help_text       .text "A <start> <assembly>",CHAR_CR
>1a70ca	3e 20 3c 61 73 73 65 6d 62 6c 79 3e 0d
>1a70d7	20 20 41 73 73 65 6d 62		                .text "  Assemble a program",CHAR_CR,CHAR_CR
>1a70df	6c 65 20 61 20 70 72 6f 67 72 61 6d 0d 0d
>1a70ed	43 20 3c 73 74 61 72 74		                .text "C <start1> <start2> [len (1 if blank)]",CHAR_CR
>1a70f5	31 3e 20 3c 73 74 61 72 74 32 3e 20 5b 6c 65 6e
>1a7105	20 28 31 20 69 66 20 62 6c 61 6e 6b 29 5d 0d
>1a7114	20 20 43 6f 6d 70 61 72		                .text "  Compare to sections of memory",CHAR_CR,CHAR_CR
>1a711c	65 20 74 6f 20 73 65 63 74 69 6f 6e 73 20 6f 66
>1a712c	20 6d 65 6d 6f 72 79 0d 0d
>1a7135	44 20 3c 73 74 61 72 74		                .text "D <start> [end]",CHAR_CR
>1a713d	3e 20 5b 65 6e 64 5d 0d
>1a7145	20 20 44 69 73 61 73 73		                .text "  Disassemble a program",CHAR_CR,CHAR_CR
>1a714d	65 6d 62 6c 65 20 61 20 70 72 6f 67 72 61 6d 0d
>1a715d	0d
>1a715e	46 20 3c 73 74 61 72 74		                .text "F <start> <end> <byte>",CHAR_CR
>1a7166	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 0d
>1a7175	20 20 46 69 6c 6c 20 61		                .text "  Fill a block of memory with a byte",CHAR_CR,CHAR_CR
>1a717d	20 62 6c 6f 63 6b 20 6f 66 20 6d 65 6d 6f 72 79
>1a718d	20 77 69 74 68 20 61 20 62 79 74 65 0d 0d
>1a719b	47 20 5b 61 64 64 72 65		                .text "G [address]",CHAR_CR
>1a71a3	73 73 5d 0d
>1a71a7	20 20 53 74 61 72 74 20		                .text "  Start execution at a location",CHAR_CR,CHAR_CR
>1a71af	65 78 65 63 75 74 69 6f 6e 20 61 74 20 61 20 6c
>1a71bf	6f 63 61 74 69 6f 6e 0d 0d
>1a71c8	4a 20 5b 61 64 64 72 65		                .text "J [address] - Jump to a location in memory",CHAR_CR
>1a71d0	73 73 5d 20 2d 20 4a 75 6d 70 20 74 6f 20 61 20
>1a71e0	6c 6f 63 61 74 69 6f 6e 20 69 6e 20 6d 65 6d 6f
>1a71f0	72 79 0d
>1a71f3	20 20 4a 75 6d 70 20 74		                .text "  Jump to a location in memory",CHAR_CR,CHAR_CR
>1a71fb	6f 20 61 20 6c 6f 63 61 74 69 6f 6e 20 69 6e 20
>1a720b	6d 65 6d 6f 72 79 0d 0d
>1a7213	48 20 3c 73 74 61 72 74		                .text "H <start> <end> <byte> [byte]..",CHAR_CR
>1a721b	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 20 5b
>1a722b	62 79 74 65 5d 2e 2e 0d
>1a7233	20 20 48 75 6e 74 20 66		                .text "  Hunt for values in memory",CHAR_CR,CHAR_CR
>1a723b	6f 72 20 76 61 6c 75 65 73 20 69 6e 20 6d 65 6d
>1a724b	6f 72 79 0d 0d
>1a7250	4c 20 20 20 20 20 4c 4f		                .text "L     LOAD         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," [destination]",CHAR_CR
>1a7258	41 44 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>1a7268	22 20 5b 64 65 73 74 69 6e 61 74 69 6f 6e 5d 0d
>1a7278	4d 20 3c 73 74 61 72 74		                .text "M <start> [end]",CHAR_CR
>1a7280	3e 20 5b 65 6e 64 5d 0d
>1a7288	20 20 44 75 6d 70 20 74		                .text "  Dump the value in memory",CHAR_CR,CHAR_CR
>1a7290	68 65 20 76 61 6c 75 65 20 69 6e 20 6d 65 6d 6f
>1a72a0	72 79 0d 0d
>1a72a4	52 20 2d 20 44 69 73 70		                .text "R - Display the values of the registers",CHAR_CR,CHAR_CR
>1a72ac	6c 61 79 20 74 68 65 20 76 61 6c 75 65 73 20 6f
>1a72bc	66 20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d
>1a72cc	0d
>1a72cd	3b 20 3c 50 43 3e 20 3c		                .text "; <PC> <A> <X> <Y> <SP> <DBR> <DP> <NVMXDIZC>",CHAR_CR
>1a72d5	41 3e 20 3c 58 3e 20 3c 59 3e 20 3c 53 50 3e 20
>1a72e5	3c 44 42 52 3e 20 3c 44 50 3e 20 3c 4e 56 4d 58
>1a72f5	44 49 5a 43 3e 0d
>1a72fb	20 20 43 68 61 6e 67 65		                .text "  Change the contents of the registers",CHAR_CR,CHAR_CR
>1a7303	20 74 68 65 20 63 6f 6e 74 65 6e 74 73 20 6f 66
>1a7313	20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d 0d
>1a7323	53 20 20 20 20 20 53 41		                .text "S     SAVE         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," <start> <end>",CHAR_CR
>1a732b	56 45 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>1a733b	22 20 3c 73 74 61 72 74 3e 20 3c 65 6e 64 3e 0d
>1a734b	54 20 3c 73 74 61 72 74		                .text "T <start> <end> <destination>",CHAR_CR
>1a7353	3e 20 3c 65 6e 64 3e 20 3c 64 65 73 74 69 6e 61
>1a7363	74 69 6f 6e 3e 0d
>1a7369	20 20 54 72 61 6e 73 66		                .text "  Transfer (copy) data within memory",CHAR_CR,CHAR_CR
>1a7371	65 72 20 28 63 6f 70 79 29 20 64 61 74 61 20 77
>1a7381	69 74 68 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>1a738f	57 20 3c 62 79 74 65 3e		                .text "W <byte>",CHAR_CR
>1a7397	0d
>1a7398	20 20 53 65 74 20 74 68		                .text "  Set the register width flags for the disassembler",CHAR_CR,CHAR_CR
>1a73a0	65 20 72 65 67 69 73 74 65 72 20 77 69 64 74 68
>1a73b0	20 66 6c 61 67 73 20 66 6f 72 20 74 68 65 20 64
>1a73c0	69 73 61 73 73 65 6d 62 6c 65 72 0d 0d
>1a73cd	58 20 2d 20 52 65 74 75		                .text "X - Return to BASIC",CHAR_CR,CHAR_CR
>1a73d5	72 6e 20 74 6f 20 42 41 53 49 43 0d 0d
>1a73e2	3e 20 3c 73 74 61 72 74		                .text "> <start> <byte> [byte]...",CHAR_CR
>1a73ea	3e 20 3c 62 79 74 65 3e 20 5b 62 79 74 65 5d 2e
>1a73fa	2e 2e 0d
>1a73fd	20 20 45 64 69 74 20 64		                .text "  Edit data in memory",CHAR_CR,CHAR_CR
>1a7405	61 74 61 20 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>1a7414	3f 20 2d 20 44 69 73 70		                .null "? - Display a short help screen",CHAR_CR,CHAR_CR
>1a741c	6c 61 79 20 61 20 73 68 6f 72 74 20 68 65 6c 70
>1a742c	20 73 63 72 65 65 6e 0d 0d 00
.1a7436					IMWIDTH
.1a7436	08		php		                PHP
.1a7437	08		php		            PHP
.1a7438	c2 20		rep #$20	            REP #$20
.1a743a	48		pha		            PHA
.1a743b	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a743e	5b		tcd		            TCD
.1a743f	68		pla		            PLA
.1a7440	28		plp		            PLP
.1a7441	e2 20		sep #$20	            SEP #$20
.1a7443	a5 0d		lda $0855	                LDA MARG1
.1a7445	85 4e		sta $0896	                STA MCPUSTAT
.1a7447	28		plp		                PLP
.1a7448	6b		rtl		                RTL
.1a7449					IMREGISTERS
.1a7449	20 3d 02	jsr $1a023d	            JSR ENSURETEXT
.1a744c	08		php		            PHP
.1a744d	e2 20		sep #$20	            SEP #$20
.1a744f	48		pha		            PHA
.1a7450	a9 1a		lda #$1a	            LDA #`mregisters_msg
.1a7452	48		pha		            PHA
.1a7453	ab		plb		            PLB
.1a7454	68		pla		            PLA
.1a7455	28		plp		            PLP
.1a7456	a2 2e 8a	ldx #$8a2e	                LDX #<>mregisters_msg
.1a7459	20 64 04	jsr $1a0464	            JSR PRINTS
.1a745c	e2 20		sep #$20	            SEP #$20
.1a745e	a9 3b		lda #$3b	                LDA #';'
.1a7460	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7463	a9 20		lda #$20	                LDA #' '
.1a7465	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7468	c2 30		rep #$30	            REP #$30
.1a746a	08		php		            PHP
.1a746b	e2 20		sep #$20	            SEP #$20
.1a746d	48		pha		            PHA
.1a746e	a9 00		lda #$00	            LDA #$0
.1a7470	48		pha		            PHA
.1a7471	ab		plb		            PLB
.1a7472	68		pla		            PLA
.1a7473	28		plp		            PLP
.1a7474	a0 03 00	ldy #$0003	                LDY #3
.1a7477	a2 42 02	ldx #$0242	                LDX #CPUPC+2
.1a747a	20 e7 03	jsr $1a03e7	            JSR PRINTH
.1a747d	c2 20		rep #$20	            REP #$20
.1a747f	a9 20 00	lda #$0020	                LDA #' '
.1a7482	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7485	af 44 02 00	lda $000244	                LDA @lCPUA
.1a7489	20 74 04	jsr $1a0474	            JSR PRHEXW
.1a748c	a9 20 00	lda #$0020	                LDA #' '
.1a748f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7492	af 46 02 00	lda $000246	                LDA @lCPUX
.1a7496	20 74 04	jsr $1a0474	            JSR PRHEXW
.1a7499	a9 20 00	lda #$0020	                LDA #' '
.1a749c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a749f	af 48 02 00	lda $000248	                LDA @lCPUY
.1a74a3	20 74 04	jsr $1a0474	            JSR PRHEXW
.1a74a6	a9 20 00	lda #$0020	                LDA #' '
.1a74a9	20 18 00	jsr $1a0018	            JSR PRINTC
.1a74ac	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK
.1a74b0	20 74 04	jsr $1a0474	            JSR PRHEXW
.1a74b3	a9 20 00	lda #$0020	                LDA #' '
.1a74b6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a74b9	af 4e 02 00	lda $00024e	                LDA @lCPUDBR
.1a74bd	20 8e 04	jsr $1a048e	            JSR PRHEXB
.1a74c0	a9 20 00	lda #$0020	                LDA #' '
.1a74c3	20 18 00	jsr $1a0018	            JSR PRINTC
.1a74c6	a9 20 00	lda #$0020	                LDA #' '
.1a74c9	20 18 00	jsr $1a0018	            JSR PRINTC
.1a74cc	af 4c 02 00	lda $00024c	                LDA @lCPUDP
.1a74d0	20 74 04	jsr $1a0474	            JSR PRHEXW
.1a74d3	a9 20 00	lda #$0020	                LDA #' '
.1a74d6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a74d9	08		php		                PHP
.1a74da	e2 20		sep #$20	            SEP #$20
.1a74dc	ad 4f 02	lda $024f	                LDA CPUFLAGS
.1a74df	22 47 87 1a	jsl $1a8747	                JSL MPRINTB
.1a74e3	28		plp		                PLP
.1a74e4	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a74e7	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a74ea	6b		rtl		                RTL
.1a74eb					IMFILL
.1a74eb	08		php		                PHP                 ; Save the caller's context
.1a74ec	0b		phd		                PHD
.1a74ed	08		php		            PHP
.1a74ee	c2 20		rep #$20	            REP #$20
.1a74f0	48		pha		            PHA
.1a74f1	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a74f4	5b		tcd		            TCD
.1a74f5	68		pla		            PLA
.1a74f6	28		plp		            PLP
.1a74f7					do_copy
.1a74f7	e2 20		sep #$20	            SEP #$20
.1a74f9	a5 15		lda $085d	                LDA MARG3
.1a74fb	87 0d		sta [$0855]	                STA [MARG1]
.1a74fd	e2 20		sep #$20	            SEP #$20
.1a74ff	a5 0f		lda $0857	                LDA MARG1+2
.1a7501	c5 13		cmp $085b	                CMP MARG2+2
.1a7503	d0 0e		bne $1a7513	                BNE go_next         ; No: we haven't reached end address yet
.1a7505	c2 20		rep #$20	            REP #$20
.1a7507	a5 0d		lda $0855	                LDA MARG1
.1a7509	c5 11		cmp $0859	                CMP MARG2           ; Are they equal?
.1a750b	d0 06		bne $1a7513	                BNE go_next         ; No: we haven't reached end address yet
.1a750d	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a7510	2b		pld		                PLD                 ; Restore the caller's context
.1a7511	28		plp		                PLP
.1a7512	6b		rtl		                RTL
.1a7513					go_next
.1a7513	c2 20		rep #$20	            REP #$20
.1a7515	18		clc		                CLC
.1a7516	a5 0d		lda $0855	                LDA MARG1
.1a7518	69 01 00	adc #$0001	                ADC #1
.1a751b	85 0d		sta $0855	                STA MARG1
.1a751d	e2 20		sep #$20	            SEP #$20
.1a751f	a5 0e		lda $0856	                LDA MARG1+1
.1a7521	69 00		adc #$00	                ADC #0
.1a7523	85 0e		sta $0856	                STA MARG1+1
.1a7525	80 d0		bra $1a74f7	                BRA do_copy
.1a7527					IMTRANSFER
.1a7527	08		php		                PHP
.1a7528	0b		phd		                PHD
.1a7529	08		php		            PHP
.1a752a	c2 20		rep #$20	            REP #$20
.1a752c	48		pha		            PHA
.1a752d	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7530	5b		tcd		            TCD
.1a7531	68		pla		            PLA
.1a7532	28		plp		            PLP
.1a7533	e2 20		sep #$20	            SEP #$20
.1a7535	a5 0f		lda $0857	                LDA MARG1+2
.1a7537	c5 17		cmp $085f	                CMP MARG3+2
.1a7539	90 45		bcc $1a7580	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.1a753b	c2 20		rep #$20	            REP #$20
.1a753d	a5 0d		lda $0855	                LDA MARG1
.1a753f	c5 15		cmp $085d	                CMP MARG3
.1a7541	90 3d		bcc $1a7580	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.1a7543					copy_byte_down
.1a7543	e2 20		sep #$20	            SEP #$20
.1a7545	a7 0d		lda [$0855]	                LDA [MARG1]         ; Copy the byte
.1a7547	87 15		sta [$085d]	                STA [MARG3]
.1a7549	a5 0f		lda $0857	                LDA MARG1+2         ; Are the source's current and end bank bytes equal?
.1a754b	c5 13		cmp $085b	                CMP MARG2+2
.1a754d	d0 0b		bne $1a755a	                BNE inc_pointers    ; No: we're not done yet
.1a754f	c2 20		rep #$20	            REP #$20
.1a7551	a5 0d		lda $0855	                LDA MARG1           ; Are the rest of the bits equal?
.1a7553	c5 11		cmp $0859	                CMP MARG2
.1a7555	d0 03		bne $1a755a	                BNE inc_pointers    ; No: we're not done yet
.1a7557	4c de 75	jmp $1a75de	                JMP done            ; Yes: we've copied the last byte, exit
.1a755a					inc_pointers
.1a755a	c2 20		rep #$20	            REP #$20
.1a755c	18		clc		                CLC
.1a755d	a5 0d		lda $0855	                LDA MARG1
.1a755f	69 01 00	adc #$0001	                ADC #1
.1a7562	85 0d		sta $0855	                STA MARG1
.1a7564	e2 20		sep #$20	            SEP #$20
.1a7566	a5 0e		lda $0856	                LDA MARG1+1
.1a7568	69 00		adc #$00	                ADC #0
.1a756a	85 0e		sta $0856	                STA MARG1+1
.1a756c	c2 20		rep #$20	            REP #$20
.1a756e	18		clc		                CLC
.1a756f	a5 15		lda $085d	                LDA MARG3
.1a7571	69 01 00	adc #$0001	                ADC #1
.1a7574	85 15		sta $085d	                STA MARG3
.1a7576	e2 20		sep #$20	            SEP #$20
.1a7578	a5 16		lda $085e	                LDA MARG3+1
.1a757a	69 00		adc #$00	                ADC #0
.1a757c	85 16		sta $085e	                STA MARG3+1
.1a757e	80 c3		bra $1a7543	                BRA copy_byte_down  ; And copy that next byte over
.1a7580					copy_up
.1a7580	c2 20		rep #$20	            REP #$20
.1a7582	38		sec		                SEC
.1a7583	a5 11		lda $0859	                LDA MARG2
.1a7585	e5 0d		sbc $0855	                SBC MARG1
.1a7587	85 19		sta $0861	                STA MARG4
.1a7589	e2 20		sep #$20	            SEP #$20
.1a758b	a5 13		lda $085b	                LDA MARG2+2
.1a758d	e5 0f		sbc $0857	                SBC MARG1+2
.1a758f	85 1b		sta $0863	                STA MARG4+2
.1a7591	c2 20		rep #$20	            REP #$20
.1a7593	18		clc		                CLC
.1a7594	a5 19		lda $0861	                LDA MARG4
.1a7596	65 15		adc $085d	                ADC MARG3
.1a7598	85 15		sta $085d	                STA MARG3
.1a759a	e2 20		sep #$20	            SEP #$20
.1a759c	a5 1b		lda $0863	                LDA MARG4+2
.1a759e	65 17		adc $085f	                ADC MARG3+2
.1a75a0	85 17		sta $085f	                STA MARG3+2
.1a75a2					copy_byte_up
.1a75a2	e2 20		sep #$20	            SEP #$20
.1a75a4	a7 11		lda [$0859]	                LDA [MARG2]
.1a75a6	87 15		sta [$085d]	                STA [MARG3]
.1a75a8	a5 13		lda $085b	                LDA MARG2+2         ; Are the source's current and start bank bytes equal?
.1a75aa	c5 0f		cmp $0857	                CMP MARG1+2
.1a75ac	d0 0a		bne $1a75b8	                BNE dec_pointers    ; No: we're not done yet
.1a75ae	c2 20		rep #$20	            REP #$20
.1a75b0	a5 11		lda $0859	                LDA MARG2           ; Are the rest of the bits equal?
.1a75b2	c5 0d		cmp $0855	                CMP MARG1
.1a75b4	d0 02		bne $1a75b8	                BNE dec_pointers    ; No: we're not done yet
.1a75b6	80 26		bra $1a75de	                BRA done            ; Yes: we've copied the last byte, exit
.1a75b8					dec_pointers
.1a75b8	c2 20		rep #$20	            REP #$20
.1a75ba	38		sec		                SEC
.1a75bb	a5 11		lda $0859	                LDA MARG2
.1a75bd	e9 01 00	sbc #$0001	                SBC #1
.1a75c0	85 11		sta $0859	                STA MARG2
.1a75c2	e2 20		sep #$20	            SEP #$20
.1a75c4	a5 12		lda $085a	                LDA MARG2+1
.1a75c6	e9 00		sbc #$00	                SBC #0
.1a75c8	85 12		sta $085a	                STA MARG2+1
.1a75ca	c2 20		rep #$20	            REP #$20
.1a75cc	38		sec		                SEC                 ; Decrement the current destination pointer (MARG3)
.1a75cd	a5 15		lda $085d	                LDA MARG3
.1a75cf	e9 01 00	sbc #$0001	                SBC #1
.1a75d2	85 15		sta $085d	                STA MARG3
.1a75d4	e2 20		sep #$20	            SEP #$20
.1a75d6	a5 16		lda $085e	                LDA MARG3+1
.1a75d8	e9 00		sbc #$00	                SBC #0
.1a75da	85 16		sta $085e	                STA MARG3+1
.1a75dc	80 c4		bra $1a75a2	                BRA copy_byte_up    ; And copy that next byte
.1a75de					done
.1a75de	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a75e1	2b		pld		                PLD
.1a75e2	28		plp		                PLP
.1a75e3	6b		rtl		                RTL
.1a75e4					IS_PRINTABLE
.1a75e4	08		php		                PHP
.1a75e5	e2 20		sep #$20	            SEP #$20
.1a75e7	c9 21		cmp #$21	                CMP #33
.1a75e9	90 0b		bcc $1a75f6	                BLT not_printable   ; 0 .. 31 are not printable
.1a75eb	c9 7f		cmp #$7f	                CMP #127
.1a75ed	90 04		bcc $1a75f3	                BLT printable       ; 32 .. 126 are printable
.1a75ef	c9 a0		cmp #$a0	                CMP #160
.1a75f1	90 03		bcc $1a75f6	                BLT not_printable   ; 127 .. 159 are not printable (assuming Latin-1)
.1a75f3	28		plp		printable       PLP
.1a75f4	38		sec		                SEC
.1a75f5	6b		rtl		                RTL
.1a75f6	28		plp		not_printable   PLP
.1a75f7	18		clc		                CLC
.1a75f8	6b		rtl		                RTL
=256					MMEMDUMPSIZE = 256  ; Default number of bytes to dump
=8					MMEMROWSIZE = 8    ; Number of bytes to dump per-row
.1a75f9					IMMEMORY
.1a75f9	08		php		                PHP
.1a75fa	8b		phb		                PHB
.1a75fb	0b		phd		                PHD
.1a75fc	08		php		            PHP
.1a75fd	c2 20		rep #$20	            REP #$20
.1a75ff	48		pha		            PHA
.1a7600	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7603	5b		tcd		            TCD
.1a7604	68		pla		            PLA
.1a7605	28		plp		            PLP
.1a7606	e2 20		sep #$20	            SEP #$20
.1a7608	a9 00		lda #$00	                LDA #0              ; Clear the pagination line counter
.1a760a	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT
.1a760e	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.1a7610	c9 02		cmp #$02	                CMP #2
.1a7612	b0 16		bcs $1a762a	                BGE set_cursor      ; 2>= arguments? Use them as-is
.1a7614	c9 01		cmp #$01	                CMP #1
.1a7616	90 20		bcc $1a7638	                BLT no_args         ; No arguments passed? Use defaults
.1a7618	c2 20		rep #$20	            REP #$20
.1a761a	18		clc		                CLC
.1a761b	a5 0d		lda $0855	                LDA MARG1
.1a761d	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a7620	85 11		sta $0859	                STA MARG2
.1a7622	e2 20		sep #$20	            SEP #$20
.1a7624	a5 0f		lda $0857	                LDA MARG1+2
.1a7626	69 00		adc #$00	                ADC #0
.1a7628	85 13		sta $085b	                STA MARG2+2
.1a762a					set_cursor
.1a762a	c2 20		rep #$20	            REP #$20
.1a762c	a5 0d		lda $0855	                LDA MARG1
.1a762e	85 32		sta $087a	                STA MCURSOR
.1a7630	e2 20		sep #$20	            SEP #$20
.1a7632	a5 0f		lda $0857	                LDA MARG1+2
.1a7634	85 34		sta $087c	                STA MCURSOR+2
.1a7636	80 12		bra $1a764a	                BRA dump_line
.1a7638					no_args
.1a7638	c2 20		rep #$20	            REP #$20
.1a763a	18		clc		                CLC
.1a763b	a5 32		lda $087a	                LDA MCURSOR
.1a763d	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a7640	85 11		sta $0859	                STA MARG2
.1a7642	e2 20		sep #$20	            SEP #$20
.1a7644	a5 34		lda $087c	                LDA MCURSOR+2
.1a7646	69 00		adc #$00	                ADC #0
.1a7648	85 13		sta $085b	                STA MARG2+2
.1a764a					dump_line
.1a764a	e2 20		sep #$20	            SEP #$20
.1a764c	a0 00 00	ldy #$0000	                LDY #0
.1a764f	c2 20		rep #$20	            REP #$20
.1a7651	a5 32		lda $087a	                LDA MCURSOR             ; NOTE: the use of MARG4 here is a temporary
.1a7653	85 19		sta $0861	                STA MARG4               ; hack. the copy_loop instruction does not
.1a7655	e2 20		sep #$20	            SEP #$20
.1a7657	a5 34		lda $087c	                LDA MCURSOR+2
.1a7659	85 1b		sta $0863	                STA MARG4+2
.1a765b	e2 20		sep #$20	            SEP #$20
.1a765d	a7 19		lda [$0861]	copy_loop       LDA [MARG4]             ; TODO: Should be LDA [MCURSOR],Y, which doesn't seem to be working
.1a765f	22 e4 75 1a	jsl $1a75e4	                JSL IS_PRINTABLE        ; Is it printable?
.1a7663	b0 02		bcs $1a7667	                BCS buffer_char         ; Yes: go ahead and add it to the line buffer
.1a7665	a9 3f		lda #$3f	                LDA #'?'                ; No: replace it with dot
.1a7667	99 7e 08	sta $087e,y	buffer_char     STA #MLINEBUF,B,Y
.1a766a	c2 20		rep #$20	            REP #$20
.1a766c	18		clc		                CLC
.1a766d	a5 19		lda $0861	                LDA MARG4
.1a766f	69 01 00	adc #$0001	                ADC #1
.1a7672	85 19		sta $0861	                STA MARG4
.1a7674	e2 20		sep #$20	            SEP #$20
.1a7676	a5 1b		lda $0863	                LDA MARG4+2
.1a7678	69 00		adc #$00	                ADC #0
.1a767a	85 1b		sta $0863	                STA MARG4+2
.1a767c	c8		iny		                INY
.1a767d	c0 08 00	cpy #$0008	                CPY #MMEMROWSIZE
.1a7680	90 db		bcc $1a765d	                BLT copy_loop
.1a7682	a9 00		lda #$00	                LDA #0
.1a7684	99 7e 08	sta $087e,y	                STA #MLINEBUF,B,Y
.1a7687	a9 3e		lda #$3e	                LDA #'>'
.1a7689	20 18 00	jsr $1a0018	            JSR PRINTC
.1a768c	a9 20		lda #$20	                LDA #' '
.1a768e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7691	e2 20		sep #$20	            SEP #$20
.1a7693	a5 34		lda $087c	                LDA MCURSOR+2
.1a7695	20 8e 04	jsr $1a048e	            JSR PRHEXB
.1a7698	a9 3a		lda #$3a	                LDA #':'                ; then a colon
.1a769a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a769d	c2 20		rep #$20	            REP #$20
.1a769f	a5 32		lda $087a	                LDA MCURSOR
.1a76a1	20 74 04	jsr $1a0474	            JSR PRHEXW
.1a76a4	c2 20		rep #$20	            REP #$20
.1a76a6	a9 08 00	lda #$0008	                LDA #MMEMROWSIZE
.1a76a9	85 47		sta $088f	                STA MCOUNT
.1a76ab					prhex_loop
.1a76ab	e2 20		sep #$20	            SEP #$20
.1a76ad	a9 20		lda #$20	                LDA #' '
.1a76af	20 18 00	jsr $1a0018	            JSR PRINTC
.1a76b2	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a76b4	20 8e 04	jsr $1a048e	            JSR PRHEXB
.1a76b7	22 26 87 1a	jsl $1a8726	                JSL M_INC_CURSOR        ; Point MCURSOR to the next byte
.1a76bb					check_line
.1a76bb	e2 20		sep #$20	            SEP #$20
.1a76bd	c6 47		dec $088f	                DEC MCOUNT              ; Count down the number of bytes on the row
.1a76bf	d0 ea		bne $1a76ab	                BNE prhex_loop          ; If we're not at zero, keep looping over the bytes
.1a76c1	a9 20		lda #$20	                LDA #' '
.1a76c3	20 18 00	jsr $1a0018	            JSR PRINTC
.1a76c6	a9 20		lda #$20	                LDA #' '
.1a76c8	20 18 00	jsr $1a0018	            JSR PRINTC
.1a76cb	08		php		            PHP
.1a76cc	e2 20		sep #$20	            SEP #$20
.1a76ce	48		pha		            PHA
.1a76cf	a9 00		lda #$00	            LDA #`MLINEBUF
.1a76d1	48		pha		            PHA
.1a76d2	ab		plb		            PLB
.1a76d3	68		pla		            PLA
.1a76d4	28		plp		            PLP
.1a76d5	a2 7e 08	ldx #$087e	                LDX #MLINEBUF
.1a76d8	20 64 04	jsr $1a0464	            JSR PRINTS
.1a76db	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a76de	20 ee 03	jsr $1a03ee	            JSR PAGINATE
.1a76e1	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.1a76e3	c5 13		cmp $085b	                CMP MARG2+2
.1a76e5	90 0f		bcc $1a76f6	                BLT continue            ; No: continue
.1a76e7	c2 20		rep #$20	            REP #$20
.1a76e9	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.1a76eb	c5 11		cmp $0859	                CMP MARG2
.1a76ed	90 07		bcc $1a76f6	                BLT continue            ; Nope... keep going
.1a76ef					done
.1a76ef	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a76f2	2b		pld		                PLD
.1a76f3	ab		plb		                PLB
.1a76f4	28		plp		                PLP
.1a76f5	6b		rtl		                RTL
.1a76f6	4c 4a 76	jmp $1a764a	continue        JMP dump_line
.1a76f9					M_COPY_ARGB
.1a76f9	08		php		                PHP
.1a76fa	8d 92 08	sta $0892	                STA MTEMP
.1a76fd	e2 20		sep #$20	            SEP #$20
.1a76ff	bd 00 00	lda $0000,x	loop            LDA #0,B,X
.1a7702	99 00 00	sta $0000,y	                STA #0,B,Y      ; Copy the byte
.1a7705	ad 92 08	lda $0892	                LDA MTEMP       ; Check the count of characters remaining
.1a7708	f0 0a		beq $1a7714	                BEQ done        ; If it's 0, we're done
.1a770a	c8		iny		                INY             ; Point to the next destination byte
.1a770b	e8		inx		                INX             ; Point to the next source byte (skip three bytes)
.1a770c	e8		inx		                INX
.1a770d	e8		inx		                INX
.1a770e	e8		inx		                INX
.1a770f	ce 92 08	dec $0892	                DEC MTEMP       ; Count down and see if we're done
.1a7712	80 eb		bra $1a76ff	                BRA loop
.1a7714	28		plp		done            PLP
.1a7715	6b		rtl		                RTL
.1a7716					IMMODIFY
.1a7716	08		php		                PHP
.1a7717	0b		phd		                PHD
.1a7718	8b		phb		                PHB
.1a7719	08		php		            PHP
.1a771a	c2 20		rep #$20	            REP #$20
.1a771c	48		pha		            PHA
.1a771d	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7720	5b		tcd		            TCD
.1a7721	68		pla		            PLA
.1a7722	28		plp		            PLP
.1a7723	08		php		            PHP
.1a7724	e2 20		sep #$20	            SEP #$20
.1a7726	48		pha		            PHA
.1a7727	a9 00		lda #$00	            LDA #0
.1a7729	48		pha		            PHA
.1a772a	ab		plb		            PLB
.1a772b	68		pla		            PLA
.1a772c	28		plp		            PLP
.1a772d	c2 30		rep #$30	            REP #$30
.1a772f	a5 0d		lda $0855	                LDA MARG1           ; Set MCURSOR to MARG1
.1a7731	85 32		sta $087a	                STA MCURSOR
.1a7733	a5 0f		lda $0857	                LDA MARG1+2
.1a7735	85 34		sta $087c	                STA MCURSOR+2
.1a7737	e2 20		sep #$20	            SEP #$20
.1a7739	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.1a773b	3a		dec a		                DEC A               ; (MARG_LEN - 1)
.1a773c	85 47		sta $088f	                STA MCOUNT
.1a773e	a2 59 08	ldx #$0859	                LDX #<>MARG2        ; Copy MCOUNT bytes from MARG2..MARG9
.1a7741	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF     ; to MLINEBUF
.1a7744	22 f9 76 1a	jsl $1a76f9	                JSL M_COPY_ARGB
.1a7748	a0 00 00	ldy #$0000	                LDY #0
.1a774b	b9 7e 08	lda $087e,y	loop            LDA MLINEBUF,Y      ; Copy the byte from the buffer
.1a774e	87 32		sta [$087a]	                STA [MCURSOR]       ; To the address indicated by MCURSOR
.1a7750	22 26 87 1a	jsl $1a8726	                JSL M_INC_CURSOR    ; Advance the cursor
.1a7754	c8		iny		                INY                 ; Go to the next buffered byte
.1a7755	c4 47		cpy $088f	                CPY MCOUNT          ; Did we just write the last one?
.1a7757	d0 f2		bne $1a774b	                BNE loop            ; No: continue writing
.1a7759	ab		plb		                PLB
.1a775a	2b		pld		                PLD
.1a775b	28		plp		                PLP
.1a775c	6b		rtl		                RTL
.1a775d					IMHUNT
.1a775d	08		php		                PHP
.1a775e	0b		phd		                PHD
.1a775f	8b		phb		                PHB
.1a7760	08		php		            PHP
.1a7761	c2 20		rep #$20	            REP #$20
.1a7763	48		pha		            PHA
.1a7764	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7767	5b		tcd		            TCD
.1a7768	68		pla		            PLA
.1a7769	28		plp		            PLP
.1a776a	08		php		            PHP
.1a776b	e2 20		sep #$20	            SEP #$20
.1a776d	48		pha		            PHA
.1a776e	a9 00		lda #$00	            LDA #0
.1a7770	48		pha		            PHA
.1a7771	ab		plb		            PLB
.1a7772	68		pla		            PLA
.1a7773	28		plp		            PLP
.1a7774	e2 20		sep #$20	            SEP #$20
.1a7776	c2 10		rep #$10	            REP #$10
.1a7778	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.1a777a	3a		dec a		                DEC A               ; (MARG_LEN - 2)
.1a777b	3a		dec a		                DEC A
.1a777c	85 47		sta $088f	                STA MCOUNT
.1a777e	a2 5d 08	ldx #$085d	                LDX #<>MARG3
.1a7781	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF
.1a7784	22 f9 76 1a	jsl $1a76f9	                JSL M_COPY_ARGB
.1a7788	c2 20		rep #$20	            REP #$20
.1a778a	a5 0d		lda $0855	                LDA MARG1           ; Copy starting address to MCURSOR
.1a778c	85 32		sta $087a	                STA MCURSOR
.1a778e	a5 0f		lda $0857	                LDA MARG1+2
.1a7790	85 34		sta $087c	                STA MCURSOR+2
.1a7792					outer_loop
.1a7792	c2 20		rep #$20	            REP #$20
.1a7794	a5 34		lda $087c	                LDA MCURSOR+2      ; If MCURSOR < MARG2, we're not done yet
.1a7796	c5 13		cmp $085b	                CMP MARG2+2
.1a7798	d0 06		bne $1a77a0	                BNE not_done
.1a779a	a5 32		lda $087a	                LDA MCURSOR
.1a779c	c5 11		cmp $0859	                CMP MARG2
.1a779e	f0 2c		beq $1a77cc	                BEQ done            ; MCURSOR = MARG2: we're done
.1a77a0					not_done
.1a77a0	e2 20		sep #$20	            SEP #$20
.1a77a2	a0 00 00	ldy #$0000	                LDY #0
.1a77a5	b7 32		lda [$087a],y	cmp_loop        LDA [MCURSOR],Y     ; Get the byte from the memory to check
.1a77a7	d9 7e 08	cmp $087e,y	                CMP MLINEBUF,Y      ; Compare it against our pattern
.1a77aa	d0 1a		bne $1a77c6	                BNE advance         ; If not equal, we need to move on
.1a77ac	c8		iny		                INY                 ; Otherwise do we have more bytes to check?
.1a77ad	c4 47		cpy $088f	                CPY MCOUNT
.1a77af	d0 f4		bne $1a77a5	                BNE cmp_loop        ; No: check more
.1a77b1	c2 20		rep #$20	            REP #$20
.1a77b3	a5 32		lda $087a	                LDA MCURSOR         ; Print the address
.1a77b5	85 4a		sta $0892	                STA MTEMP
.1a77b7	a5 34		lda $087c	                LDA MCURSOR+2
.1a77b9	85 4c		sta $0894	                STA MTEMP+2
.1a77bb	22 d0 81 1a	jsl $1a81d0	                JSL M_PR_ADDR
.1a77bf	e2 20		sep #$20	            SEP #$20
.1a77c1	a9 20		lda #$20	                LDA #' '
.1a77c3	20 18 00	jsr $1a0018	            JSR PRINTC
.1a77c6	22 26 87 1a	jsl $1a8726	advance         JSL M_INC_CURSOR    ; Move MCURSOR forward by one
.1a77ca	80 c6		bra $1a7792	                BRA outer_loop      ; And try to compare that to the pattern
.1a77cc					done
.1a77cc	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a77cf	ab		plb		                PLB
.1a77d0	2b		pld		                PLD
.1a77d1	28		plp		                PLP
.1a77d2	6b		rtl		                RTL
.1a77d3					IMJUMP
.1a77d3	08		php		            PHP
.1a77d4	c2 20		rep #$20	            REP #$20
.1a77d6	48		pha		            PHA
.1a77d7	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a77da	5b		tcd		            TCD
.1a77db	68		pla		            PLA
.1a77dc	28		plp		            PLP
.1a77dd	e2 20		sep #$20	            SEP #$20
.1a77df	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.1a77e1	f0 0e		beq $1a77f1	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.1a77e3	c2 30		rep #$30	            REP #$30
.1a77e5	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.1a77e7	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.1a77eb	a5 0f		lda $0857	                LDA MARG1+2
.1a77ed	8f 42 02 00	sta $000242	                STA @lCPUPBR
.1a77f1	af 46 02 00	lda $000246	MJUMPRESTORE    LDA @lCPUX          ; Restore X and Y
.1a77f5	aa		tax		                TAX
.1a77f6	af 48 02 00	lda $000248	                LDA @lCPUY
.1a77fa	a8		tay		                TAY
.1a77fb	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.1a77ff	1b		tcs		                TCS
.1a7800	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.1a7804	5b		tcd		                TCD
.1a7805	e2 20		sep #$20	            SEP #$20
.1a7807	a9 1a		lda #$1a	                LDA #`MJUMPSTART
.1a7809	48		pha		                PHA
.1a780a	a9 78		lda #$78	                LDA #>MJUMPSTART
.1a780c	48		pha		                PHA
.1a780d	a9 13		lda #$13	                LDA #<MJUMPSTART
.1a780f	48		pha		                PHA
.1a7810	4c 4a 78	jmp $1a784a	                JMP MGOSTACK        ; And push remaining registers and restart execution
.1a7813	ea		nop		MJUMPSTART      NOP                 ; RTL increments PC pulled from stack, NOP leaves space for that
.1a7814	5c 04 00 1a	jmp $1a0004	                JML MONITOR
.1a7818					IMGO
.1a7818	08		php		            PHP
.1a7819	c2 20		rep #$20	            REP #$20
.1a781b	48		pha		            PHA
.1a781c	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a781f	5b		tcd		            TCD
.1a7820	68		pla		            PLA
.1a7821	28		plp		            PLP
.1a7822	e2 20		sep #$20	            SEP #$20
.1a7824	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.1a7826	f0 c9		beq $1a77f1	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.1a7828	c2 30		rep #$30	            REP #$30
.1a782a	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.1a782c	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.1a7830	a5 0f		lda $0857	                LDA MARG1+2
.1a7832	8f 42 02 00	sta $000242	                STA @lCPUPBR
.1a7836	af 46 02 00	lda $000246	MGORESTORE      LDA @lCPUX          ; Restore X and Y
.1a783a	aa		tax		                TAX
.1a783b	af 48 02 00	lda $000248	                LDA @lCPUY
.1a783f	a8		tay		                TAY
.1a7840	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.1a7844	1b		tcs		                TCS
.1a7845	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.1a7849	5b		tcd		                TCD
.1a784a					MGOSTACK
.1a784a	e2 20		sep #$20	            SEP #$20
.1a784c	af 4e 02 00	lda $00024e	                LDA @lCPUDBR        ; Restore the data bank register
.1a7850	48		pha		                PHA
.1a7851	ab		plb		                PLB
.1a7852	a9 5c		lda #$5c	                LDA #$5C            ; Save the JSL opcode
.1a7854	8f a2 08 00	sta $0008a2	                STA @lMJUMPINST
.1a7858	af 42 02 00	lda $000242	                LDA @lCPUPBR        ; Write PBR
.1a785c	8f a5 08 00	sta $0008a5	                STA @lMJUMPADDR+2
.1a7860	af 41 02 00	lda $000241	                LDA @lCPUPC+1       ; Write PCH
.1a7864	8f a4 08 00	sta $0008a4	                STA @lMJUMPADDR+1
.1a7868	af 40 02 00	lda $000240	                LDA @lCPUPC         ; Write PCL
.1a786c	8f a3 08 00	sta $0008a3	                STA @lMJUMPADDR
.1a7870	af 4f 02 00	lda $00024f	                LDA @lCPUFLAGS      ; Push processor status
.1a7874	48		pha		                PHA
.1a7875	c2 20		rep #$20	            REP #$20
.1a7877	af 44 02 00	lda $000244	                LDA @lCPUA          ; Restore A
.1a787b	28		plp		                PLP                 ; And the status register
.1a787c	5c a2 08 00	jmp $0008a2	                JML MJUMPINST       ; And jump to the target address
.1a7880					IMCOMPARE
.1a7880	08		php		                PHP
.1a7881	0b		phd		                PHD
.1a7882	8b		phb		                PHB
.1a7883	08		php		            PHP
.1a7884	e2 20		sep #$20	            SEP #$20
.1a7886	48		pha		            PHA
.1a7887	a9 1a		lda #$1a	            LDA #`MERRARGS
.1a7889	48		pha		            PHA
.1a788a	ab		plb		            PLB
.1a788b	68		pla		            PLA
.1a788c	28		plp		            PLP
.1a788d	08		php		            PHP
.1a788e	c2 20		rep #$20	            REP #$20
.1a7890	48		pha		            PHA
.1a7891	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a7894	5b		tcd		            TCD
.1a7895	68		pla		            PLA
.1a7896	28		plp		            PLP
.1a7897	c2 10		rep #$10	            REP #$10
.1a7899	e2 20		sep #$20	            SEP #$20
.1a789b	a5 31		lda $0879	                LDA MARG_LEN                ; Check the number of arguments provided
.1a789d	c9 02		cmp #$02	                CMP #2
.1a789f	f0 0c		beq $1a78ad	                BEQ default_len             ; If 2: set MCOUNT to default of 1
.1a78a1	c9 03		cmp #$03	                CMP #3
.1a78a3	d0 11		bne $1a78b6	                BNE bad_arguments           ; Otherwise, if not 3: print an error
.1a78a5	c2 20		rep #$20	            REP #$20
.1a78a7	a5 15		lda $085d	                LDA MARG3                   ; If 3: set MCOUNT to MARG3
.1a78a9	85 47		sta $088f	                STA MCOUNT
.1a78ab	80 11		bra $1a78be	                BRA compare
.1a78ad					default_len
.1a78ad	c2 20		rep #$20	            REP #$20
.1a78af	a9 01 00	lda #$0001	                LDA #1                      ; No length was provided, set MCOUNT to 1
.1a78b2	85 47		sta $088f	                STA MCOUNT
.1a78b4	80 08		bra $1a78be	                BRA compare
.1a78b6	a2 f2 89	ldx #$89f2	bad_arguments   LDX #<>MERRARGS             ; The wrong number of arguments was provided
.1a78b9	20 64 04	jsr $1a0464	            JSR PRINTS
.1a78bc	80 35		bra $1a78f3	                BRA done
.1a78be	a5 0d		lda $0855	compare         LDA MARG1                   ; Set MTEMP to MARG1
.1a78c0	85 4a		sta $0892	                STA MTEMP
.1a78c2	a5 0f		lda $0857	                LDA MARG1+2
.1a78c4	85 4c		sta $0894	                STA MTEMP+2
.1a78c6	a0 00 00	ldy #$0000	                LDY #0
.1a78c9					loop
.1a78c9	e2 20		sep #$20	            SEP #$20
.1a78cb	a7 4a		lda [$0892]	                LDA [MTEMP]                 ; Compare the byte at MTEMP
.1a78cd	d7 11		cmp [$0859],y	                CMP [MARG2],Y               ; To the Yth byte from MARG2
.1a78cf	f0 09		beq $1a78da	                BEQ continue                ; If they're the same, keep going
.1a78d1	22 d0 81 1a	jsl $1a81d0	mismatch        JSL M_PR_ADDR               ; If they're different, print MTEMP
.1a78d5	a9 20		lda #$20	                LDA #' '
.1a78d7	20 18 00	jsr $1a0018	            JSR PRINTC
.1a78da					continue
.1a78da	c2 20		rep #$20	            REP #$20
.1a78dc	18		clc		                CLC                         ; Either way, increment MTEMP
.1a78dd	a5 4a		lda $0892	                LDA MTEMP
.1a78df	69 01 00	adc #$0001	                ADC #1
.1a78e2	85 4a		sta $0892	                STA MTEMP
.1a78e4	a5 4c		lda $0894	                LDA MTEMP+2
.1a78e6	69 00 00	adc #$0000	                ADC #0
.1a78e9	85 4c		sta $0894	                STA MTEMP+2
.1a78eb	c8		iny		                INY                         ; Increment Y
.1a78ec	c4 47		cpy $088f	                CPY MCOUNT                  ; Try again unless we've checked MCOUNT bytes
.1a78ee	d0 d9		bne $1a78c9	                BNE loop
.1a78f0	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a78f3					done
.1a78f3	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a78f6	ab		plb		                PLB
.1a78f7	2b		pld		                PLD
.1a78f8	28		plp		                PLP
.1a78f9	6b		rtl		                RTL
.1a78fa					IMRMODIFY
.1a78fa	08		php		                PHP
.1a78fb	0b		phd		                PHD
.1a78fc	8b		phb		                PHB
.1a78fd	08		php		            PHP
.1a78fe	e2 20		sep #$20	            SEP #$20
.1a7900	48		pha		            PHA
.1a7901	a9 00		lda #$00	            LDA #0
.1a7903	48		pha		            PHA
.1a7904	ab		plb		            PLB
.1a7905	68		pla		            PLA
.1a7906	28		plp		            PLP
.1a7907	08		php		            PHP
.1a7908	c2 20		rep #$20	            REP #$20
.1a790a	48		pha		            PHA
.1a790b	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a790e	5b		tcd		            TCD
.1a790f	68		pla		            PLA
.1a7910	28		plp		            PLP
.1a7911	e2 20		sep #$20	            SEP #$20
.1a7913	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.1a7915	f0 4f		beq $1a7966	                BEQ done            ; 0? Just quit
.1a7917	a6 0d		ldx $0855	                LDX MARG1           ; Set the PC and PBR
.1a7919	8e 40 02	stx $0240	                STX #CPUPC,B
.1a791c	a6 0f		ldx $0857	                LDX MARG1+2
.1a791e	8e 42 02	stx $0242	                STX #CPUPBR,B
.1a7921	c9 01		cmp #$01	                CMP #1              ; Check the number of arguments
.1a7923	f0 41		beq $1a7966	                BEQ done            ; 1? Just quit
.1a7925	a6 11		ldx $0859	                LDX MARG2           ; Set A
.1a7927	8e 44 02	stx $0244	                STX #CPUA,B
.1a792a	c9 02		cmp #$02	                CMP #2              ; Check the number of arguments
.1a792c	f0 38		beq $1a7966	                BEQ done            ; 2? Just quit
.1a792e	a6 15		ldx $085d	                LDX MARG3           ; Set X
.1a7930	8e 46 02	stx $0246	                STX #CPUX,B
.1a7933	c9 03		cmp #$03	                CMP #3              ; Check the number of arguments
.1a7935	f0 2f		beq $1a7966	                BEQ done            ; 3? Just quit
.1a7937	a6 19		ldx $0861	                LDX MARG4           ; Set Y
.1a7939	8e 48 02	stx $0248	                STX #CPUY,B
.1a793c	c9 04		cmp #$04	                CMP #4              ; Check the number of arguments
.1a793e	f0 26		beq $1a7966	                BEQ done            ; 4? Just quit
.1a7940	a6 1d		ldx $0865	                LDX MARG5           ; Set SP
.1a7942	8e 4a 02	stx $024a	                STX #CPUSTACK,B
.1a7945	c9 05		cmp #$05	                CMP #5              ; Check the number of arguments
.1a7947	f0 1d		beq $1a7966	                BEQ done            ; 5? Just quit
.1a7949	e2 10		sep #$10	            SEP #$10
.1a794b	a6 21		ldx $0869	                LDX MARG6           ; Set DBR
.1a794d	8e 4e 02	stx $024e	                STX #CPUDBR,B
.1a7950	c9 06		cmp #$06	                CMP #6              ; Check the number of arguments
.1a7952	f0 12		beq $1a7966	                BEQ done            ; 6? Just quit
.1a7954	c2 10		rep #$10	            REP #$10
.1a7956	a6 25		ldx $086d	                LDX MARG7           ; Set DP
.1a7958	8e 4c 02	stx $024c	                STX #CPUDP,B
.1a795b	c9 07		cmp #$07	                CMP #7              ; Check the number of arguments
.1a795d	f0 07		beq $1a7966	                BEQ done            ; 7? Just quit
.1a795f	e2 10		sep #$10	            SEP #$10
.1a7961	a6 29		ldx $0871	                LDX MARG8           ; Set flags
.1a7963	8e 4f 02	stx $024f	                STX #CPUFLAGS,B
.1a7966	ab		plb		done            PLB
.1a7967	2b		pld		                PLD
.1a7968	28		plp		                PLP
.1a7969	6b		rtl		                RTL
.1a796a					IMEXECUTE
.1a796a	08		php		                PHP
.1a796b	0b		phd		                PHD
.1a796c	8b		phb		                PHB
.1a796d	08		php		            PHP
.1a796e	c2 20		rep #$20	            REP #$20
.1a7970	48		pha		            PHA
.1a7971	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7974	5b		tcd		            TCD
.1a7975	68		pla		            PLA
.1a7976	28		plp		            PLP
.1a7977	e2 20		sep #$20	            SEP #$20
.1a7979	c2 10		rep #$10	            REP #$10
.1a797b	a2 00 00	ldx #$0000	                LDX #0
.1a797e	bf 5f 8a 1a	lda $1a8a5f,x	loop            LDA @lMCOMMANDS,X
.1a7982	f0 18		beq $1a799c	                BEQ done
.1a7984	c7 08		cmp [$0850]	                CMP [MCMD]
.1a7986	f0 03		beq $1a798b	                BEQ found
.1a7988	e8		inx		                INX
.1a7989	80 f3		bra $1a797e	                BRA loop
.1a798b					found
.1a798b	c2 20		rep #$20	            REP #$20
.1a798d	8a		txa		                TXA
.1a798e	0a		asl a		                ASL A
.1a798f	aa		tax		                TAX
.1a7990	bf a0 79 1a	lda $1a79a0,x	                LDA dispatch,X
.1a7994	8f 2f 08 00	sta $00082f	                STA @lJMP16PTR
.1a7998	22 c4 79 1a	jsl $1a79c4	                JSL MDOCMD
.1a799c	ab		plb		done            PLB
.1a799d	2b		pld		                PLD
.1a799e	28		plp		                PLP
.1a799f	6b		rtl		                RTL
>1a79a0	40 70				dispatch        .word <>MASSEMBLE
>1a79a2	48 70				                .word <>MCOMPARE
>1a79a4	4c 70				                .word <>MDISASSEMBLE
>1a79a6	50 70				                .word <>MFILL
>1a79a8	54 70				                .word <>MGO
>1a79aa	58 70				                .word <>MJUMP
>1a79ac	5c 70				                .word <>MHUNT
>1a79ae	60 70				                .word <>MLOAD
>1a79b0	64 70				                .word <>MMEMORY
>1a79b2	68 70				                .word <>MREGISTERS
>1a79b4	44 70				                .word <>MRMODIFY
>1a79b6	6c 70				                .word <>MSAVE
>1a79b8	70 70				                .word <>MTRANSFER
>1a79ba	74 70				                .word <>MVERIFY
>1a79bc	36 74				                .word <>IMWIDTH
>1a79be	78 70				                .word <>MEXIT
>1a79c0	7c 70				                .word <>MMODIFY
>1a79c2	af 70				                .word <>IMHELP
.1a79c4					MDOCMD
.1a79c4	6c 2f 08	jmp ($082f)	                JMP (JMP16PTR)

;******  Processing file: src\assembler.s

=0					ADDR_DP_IND_X = 0       ; (dd,X)
=1					ADDR_DP = 1             ; dd
=2					ADDR_IMM = 2            ; #dd
=3					ADDR_ABS = 3            ; dddd
=4					ADDR_DP_IND_Y = 4       ; (dd),Y
=5					ADDR_DP_X = 5           ; dd,X
=6					ADDR_ABS_Y = 6          ; dddd,Y
=7					ADDR_ABS_X = 7          ; dddd,X
=8					ADDR_ACC = 8            ; A
=9					ADDR_SP_R = 9           ; #d,S
=10					ADDR_DP_LONG = 10       ; [dd]
=11					ADDR_ABS_LONG = 11      ; dddddd
=12					ADDR_SP_R_Y = 12        ; #dd,S,Y
=13					ADDR_DP_Y_LONG = 13     ; [dd],Y
=14					ADDR_ABS_X_LONG = 14    ; dddddd,X
=15					ADDR_DP_IND = 15        ; (dd)
=16					ADDR_ABS_X_ID = 16      ; (dddd,X)
=17					ADDR_DP_Y = 17          ; dd,Y
=18					ADDR_PC_REL = 18        ; PC relative
=19					ADDR_IMPLIED = 19       ; Implied (no operand)
=20					ADDR_XYC = 20           ; #dd, #dd
=21					ADDR_ABS_IND = 21       ; (dddd)
=22					ADDR_PC_REL_LONG = 22   ; PC relative ()
=23					ADDR_ABS_IND_LONG = 23  ; [dddd]
=$80					OP_M_EFFECT = $80       ; Flag to indicate instruction is modified by M
=$40					OP_X_EFFECT = $40       ; Flag to indicate instruction is modified by X
.1a79c7					IMASSEMBLE
.1a79c7	08		php		                PHP
.1a79c8	8b		phb		                PHB
.1a79c9	0b		phd		                PHD
.1a79ca	08		php		            PHP
.1a79cb	c2 20		rep #$20	            REP #$20
.1a79cd	48		pha		            PHA
.1a79ce	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a79d1	5b		tcd		            TCD
.1a79d2	68		pla		            PLA
.1a79d3	28		plp		            PLP
.1a79d4	e2 20		sep #$20	            SEP #$20
.1a79d6	a5 31		lda $0879	                LDA MARG_LEN            ; Do we have at least 2 arguments?
.1a79d8	c9 02		cmp #$02	                CMP #2
.1a79da	b0 03		bcs $1a79df	                BGE has_args            ; Yes: try to assemble the line
.1a79dc	4c 6d 7b	jmp $1a7b6d	                JMP done                ; No: just return
.1a79df					has_args
.1a79df	c2 20		rep #$20	            REP #$20
.1a79e1	a5 0d		lda $0855	                LDA MARG1               ; Set the monitor cursor to the address
.1a79e3	85 32		sta $087a	                STA MCURSOR
.1a79e5	a5 0f		lda $0857	                LDA MARG1+2
.1a79e7	85 34		sta $087c	                STA MCURSOR+2
.1a79e9	c2 20		rep #$20	            REP #$20
.1a79eb	22 6f 7d 1a	jsl $1a7d6f	                JSL AS_FIND_MNEMO       ; Find the address of the mnemonic
.1a79ef	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a79f2	f0 10		beq $1a7a04	                BEQ bad_mnemonic        ; If not found, print bad mnemonic error message
.1a79f4	85 54		sta $089c	                STA MMNEMONIC
.1a79f6	e2 20		sep #$20	            SEP #$20
.1a79f8	a5 31		lda $0879	                LDA MARG_LEN            ; Check the number of arguments passed
.1a79fa	c9 03		cmp #$03	                CMP #3                  ; Were all three arguments provided?
.1a79fc	f0 36		beq $1a7a34	                BEQ get_operand         ; Yes: parse the operand
.1a79fe	a9 13		lda #$13	                LDA #ADDR_IMPLIED       ; No: assume address mode is implied
.1a7a00	85 4f		sta $0897	                STA MADDR_MODE
.1a7a02	80 4c		bra $1a7a50	                BRA get_opcode
.1a7a04					bad_mnemonic
.1a7a04	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a7a07	08		php		            PHP
.1a7a08	e2 20		sep #$20	            SEP #$20
.1a7a0a	48		pha		            PHA
.1a7a0b	a9 1a		lda #$1a	            LDA #`MERRBADMNEMO
.1a7a0d	48		pha		            PHA
.1a7a0e	ab		plb		            PLB
.1a7a0f	68		pla		            PLA
.1a7a10	28		plp		            PLP
.1a7a11	c2 10		rep #$10	            REP #$10
.1a7a13	a2 a4 7b	ldx #$7ba4	                LDX #<>MERRBADMNEMO
.1a7a16	20 64 04	jsr $1a0464	            JSR PRINTS
.1a7a19	4c 6d 7b	jmp $1a7b6d	                JMP done
.1a7a1c					bad_operand
.1a7a1c	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a7a1f	08		php		            PHP
.1a7a20	e2 20		sep #$20	            SEP #$20
.1a7a22	48		pha		            PHA
.1a7a23	a9 1a		lda #$1a	            LDA #`MERRBADOPER
.1a7a25	48		pha		            PHA
.1a7a26	ab		plb		            PLB
.1a7a27	68		pla		            PLA
.1a7a28	28		plp		            PLP
.1a7a29	c2 10		rep #$10	            REP #$10
.1a7a2b	a2 b3 7b	ldx #$7bb3	                LDX #<>MERRBADOPER
.1a7a2e	20 64 04	jsr $1a0464	            JSR PRINTS
.1a7a31	4c 6d 7b	jmp $1a7b6d	                JMP done
.1a7a34					get_operand
.1a7a34	e2 20		sep #$20	            SEP #$20
.1a7a36	22 a5 7d 1a	jsl $1a7da5	                JSL AS_FIND_MODE        ; Find the addressing mode of the operand
.1a7a3a	c9 ff		cmp #$ff	compare         CMP #$FF
.1a7a3c	f0 de		beq $1a7a1c	                BEQ bad_operand         ; If not found, print bad operand error message
.1a7a3e	85 4f		sta $0897	                STA MADDR_MODE
.1a7a40	c9 03		cmp #$03	                CMP #ADDR_ABS           ; If mode is absolute or absolute long...
.1a7a42	f0 62		beq $1a7aa6	                BEQ check_for_pcrel     ; Check to see if the mnemonic is one of the branches
.1a7a44	c9 0b		cmp #$0b	                CMP #ADDR_ABS_LONG
.1a7a46	f0 5e		beq $1a7aa6	                BEQ check_for_pcrel
.1a7a48	c9 13		cmp #$13	                CMP #ADDR_IMPLIED       ; If mode is implied or accumulator, get the opcode
.1a7a4a	f0 04		beq $1a7a50	                BEQ get_opcode
.1a7a4c	c9 08		cmp #$08	                CMP #ADDR_ACC
.1a7a4e	f0 00		beq $1a7a50	                BEQ get_opcode
.1a7a50	22 9d 7c 1a	jsl $1a7c9d	get_opcode      JSL AS_FIND_OPCODE      ; Find the opcode matching the two
.1a7a54	b0 03		bcs $1a7a59	                BCS save_opcode
.1a7a56	4c 36 7b	jmp $1a7b36	                JMP bad_mode            ; If opcode not found, print bad address mode error message
.1a7a59	87 32		sta [$087a]	save_opcode     STA [MCURSOR]           ; Write the opcode to the address
.1a7a5b	22 26 87 1a	jsl $1a8726	                JSL M_INC_CURSOR        ; And point to the next byte
.1a7a5f	08		php		            PHP
.1a7a60	e2 20		sep #$20	            SEP #$20
.1a7a62	48		pha		            PHA
.1a7a63	a9 00		lda #$00	            LDA #0
.1a7a65	48		pha		            PHA
.1a7a66	ab		plb		            PLB
.1a7a67	68		pla		            PLA
.1a7a68	28		plp		            PLP
.1a7a69	c2 20		rep #$20	            REP #$20
.1a7a6b	a5 32		lda $087a	                LDA MCURSOR             ; Make MTEMPPTR a pointer to the machine code we're assembling
.1a7a6d	85 56		sta $089e	                STA MTEMPPTR
.1a7a6f	a5 34		lda $087c	                LDA MCURSOR+2
.1a7a71	85 58		sta $08a0	                STA MTEMPPTR+2
.1a7a73	e2 20		sep #$20	            SEP #$20
.1a7a75	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check the address mode again
.1a7a77	c9 12		cmp #$12	                CMP #ADDR_PC_REL        ; If it's PC relative
.1a7a79	f0 6c		beq $1a7ae7	                BEQ compute_rel         ; Convert the address to an offset
.1a7a7b	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.1a7a7d	f0 68		beq $1a7ae7	                BEQ compute_rel
.1a7a7f	c9 14		cmp #$14	                CMP #ADDR_XYC           ; MVP/MVN addressing mode?
.1a7a81	f0 7c		beq $1a7aff	                BEQ emit_2
.1a7a83	29 3f		and #$3f	                AND #%00111111          ; Filter out the mode bits
.1a7a85	c9 02		cmp #$02	                CMP #ADDR_IMM           ; Is it immediate?
.1a7a87	d0 03		bne $1a7a8c	                BNE fixed_length        ; Yes: emit it as an immediate (variable length)
.1a7a89	4c 64 7b	jmp $1a7b64	                JMP emit_imm
.1a7a8c					fixed_length
.1a7a8c	c2 20		rep #$20	            REP #$20
.1a7a8e	29 ff 00	and #$00ff	                AND #$00FF
.1a7a91	aa		tax		                TAX
.1a7a92	e2 20		sep #$20	            SEP #$20
.1a7a94	bf 6c 86 1a	lda $1a866c,x	get_length      LDA ADDR_LENGTH,X       ; Get the number of bytes in the addressing mode
.1a7a98	c9 03		cmp #$03	                CMP #$03
.1a7a9a	f0 57		beq $1a7af3	                BEQ emit_3
.1a7a9c	c9 02		cmp #$02	                CMP #$02
.1a7a9e	f0 5f		beq $1a7aff	                BEQ emit_2
.1a7aa0	c9 01		cmp #$01	                CMP #$01
.1a7aa2	f0 67		beq $1a7b0b	                BEQ emit_1
.1a7aa4	80 71		bra $1a7b17	                BRA next_line
.1a7aa6					check_for_pcrel
.1a7aa6	c2 20		rep #$20	            REP #$20
.1a7aa8	a5 54		lda $089c	                LDA MMNEMONIC
.1a7aaa	c9 e4 82	cmp #$82e4	                CMP #<>MN_BRA
.1a7aad	f0 26		beq $1a7ad5	                BEQ is_pcrel
.1a7aaf	c9 48 83	cmp #$8348	                CMP #<>MN_BRL
.1a7ab2	f0 2a		beq $1a7ade	                BEQ is_pcrel_long
.1a7ab4	c9 c8 82	cmp #$82c8	                CMP #<>MN_BCC
.1a7ab7	f0 1c		beq $1a7ad5	                BEQ is_pcrel
.1a7ab9	c9 cc 82	cmp #$82cc	                CMP #<>MN_BCS
.1a7abc	f0 17		beq $1a7ad5	                BEQ is_pcrel
.1a7abe	c9 d4 82	cmp #$82d4	                CMP #<>MN_BEQ
.1a7ac1	f0 12		beq $1a7ad5	                BEQ is_pcrel
.1a7ac3	c9 bc 82	cmp #$82bc	                CMP #<>MN_BMI
.1a7ac6	f0 0d		beq $1a7ad5	                BEQ is_pcrel
.1a7ac8	c9 d0 82	cmp #$82d0	                CMP #<>MN_BNE
.1a7acb	f0 08		beq $1a7ad5	                BEQ is_pcrel
.1a7acd	c9 b8 82	cmp #$82b8	                CMP #<>MN_BPL
.1a7ad0	f0 03		beq $1a7ad5	                BEQ is_pcrel
.1a7ad2	4c 50 7a	jmp $1a7a50	                JMP get_opcode
.1a7ad5					is_pcrel
.1a7ad5	e2 20		sep #$20	            SEP #$20
.1a7ad7	a9 12		lda #$12	                LDA #ADDR_PC_REL
.1a7ad9	85 4f		sta $0897	                STA MADDR_MODE
.1a7adb	4c 50 7a	jmp $1a7a50	                JMP get_opcode
.1a7ade					is_pcrel_long
.1a7ade	e2 20		sep #$20	            SEP #$20
.1a7ae0	a9 16		lda #$16	                LDA #ADDR_PC_REL_LONG
.1a7ae2	85 4f		sta $0897	                STA MADDR_MODE
.1a7ae4	4c 50 7a	jmp $1a7a50	                JMP get_opcode
.1a7ae7	22 e0 7b 1a	jsl $1a7be0	compute_rel     JSL AS_PC_OFFSET        ; Try to compute the offset
.1a7aeb	90 60		bcc $1a7b4d	                BCC bad_offset          ; If failed, it's a bad offset operand
.1a7aed	c9 02		cmp #$02	emit_rel        CMP #$02                ; If the offset is two bytes
.1a7aef	f0 0e		beq $1a7aff	                BEQ emit_2              ; Emit those two bytes
.1a7af1	80 18		bra $1a7b0b	                BRA emit_1              ; Otherwise emit just the one
.1a7af3	a0 02 00	ldy #$0002	emit_3          LDY #2                  ; Write bank byte of operand
.1a7af6	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.1a7af9	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.1a7afb	22 26 87 1a	jsl $1a8726	                JSL M_INC_CURSOR
.1a7aff	a0 01 00	ldy #$0001	emit_2          LDY #1                  ; Write high byte of operand
.1a7b02	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.1a7b05	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.1a7b07	22 26 87 1a	jsl $1a8726	                JSL M_INC_CURSOR
.1a7b0b	a0 00 00	ldy #$0000	emit_1          LDY #0                  ; Write low byte of operand
.1a7b0e	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.1a7b11	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.1a7b13	22 26 87 1a	jsl $1a8726	                JSL M_INC_CURSOR
.1a7b17					next_line
.1a7b17	e2 20		sep #$20	            SEP #$20
.1a7b19	a9 41		lda #$41	                LDA #'A'
.1a7b1b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7b1e	a9 20		lda #$20	                LDA #' '
.1a7b20	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7b23	a6 32		ldx $087a	                LDX MCURSOR
.1a7b25	86 4a		stx $0892	                STX MTEMP
.1a7b27	a6 34		ldx $087c	                LDX MCURSOR+2
.1a7b29	86 4c		stx $0894	                STX MTEMP+2
.1a7b2b	22 d0 81 1a	jsl $1a81d0	                JSL M_PR_ADDR
.1a7b2f	a9 20		lda #$20	                LDA #' '
.1a7b31	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7b34	80 37		bra $1a7b6d	                BRA done
.1a7b36					bad_mode
.1a7b36	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a7b39	08		php		            PHP
.1a7b3a	e2 20		sep #$20	            SEP #$20
.1a7b3c	48		pha		            PHA
.1a7b3d	a9 1a		lda #$1a	            LDA #`MERRBADMODE
.1a7b3f	48		pha		            PHA
.1a7b40	ab		plb		            PLB
.1a7b41	68		pla		            PLA
.1a7b42	28		plp		            PLP
.1a7b43	c2 10		rep #$10	            REP #$10
.1a7b45	a2 71 7b	ldx #$7b71	                LDX #<>MERRBADMODE
.1a7b48	20 64 04	jsr $1a0464	            JSR PRINTS
.1a7b4b	80 20		bra $1a7b6d	                BRA done
.1a7b4d					bad_offset
.1a7b4d	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a7b50	08		php		            PHP
.1a7b51	e2 20		sep #$20	            SEP #$20
.1a7b53	48		pha		            PHA
.1a7b54	a9 1a		lda #$1a	            LDA #`MERRBADOFFSET
.1a7b56	48		pha		            PHA
.1a7b57	ab		plb		            PLB
.1a7b58	68		pla		            PLA
.1a7b59	28		plp		            PLP
.1a7b5a	c2 10		rep #$10	            REP #$10
.1a7b5c	a2 c1 7b	ldx #$7bc1	                LDX #<>MERRBADOFFSET
.1a7b5f	20 64 04	jsr $1a0464	            JSR PRINTS
.1a7b62	80 09		bra $1a7b6d	                BRA done
.1a7b64	a5 4f		lda $0897	emit_imm        LDA MADDR_MODE          ; Check to see if long immediate was used
.1a7b66	29 c0		and #$c0	                AND #%11000000
.1a7b68	d0 95		bne $1a7aff	                BNE emit_2              ; Yes: emit two bytes
.1a7b6a	4c 0b 7b	jmp $1a7b0b	                JMP emit_1              ; No: emit one byte
.1a7b6d	2b		pld		done            PLD
.1a7b6e	ab		plb		                PLB
.1a7b6f	28		plp		                PLP
.1a7b70	6b		rtl		                RTL
>1a7b71	41 64 64 72 65 73 73 69		MERRBADMODE     .null "Addressing mode not defined for that instruction.",CHAR_CR
>1a7b79	6e 67 20 6d 6f 64 65 20 6e 6f 74 20 64 65 66 69
>1a7b89	6e 65 64 20 66 6f 72 20 74 68 61 74 20 69 6e 73
>1a7b99	74 72 75 63 74 69 6f 6e 2e 0d 00
>1a7ba4	42 61 64 20 6d 6e 65 6d		MERRBADMNEMO    .null "Bad mnemonic.",CHAR_CR
>1a7bac	6f 6e 69 63 2e 0d 00
>1a7bb3	42 61 64 20 6f 70 65 72		MERRBADOPER     .null "Bad operand.",CHAR_CR
>1a7bbb	61 6e 64 2e 0d 00
>1a7bc1	52 65 6c 61 74 69 76 65		MERRBADOFFSET   .null "Relative offset is too large.",CHAR_CR
>1a7bc9	20 6f 66 66 73 65 74 20 69 73 20 74 6f 6f 20 6c
>1a7bd9	61 72 67 65 2e 0d 00
.1a7be0					AS_PC_OFFSET
.1a7be0	08		php		                PHP
.1a7be1	0b		phd		                PHD
.1a7be2	08		php		            PHP
.1a7be3	c2 20		rep #$20	            REP #$20
.1a7be5	48		pha		            PHA
.1a7be6	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7be9	5b		tcd		            TCD
.1a7bea	68		pla		            PLA
.1a7beb	28		plp		            PLP
.1a7bec	e2 20		sep #$20	            SEP #$20
.1a7bee	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check to see if it 1 byte or 2 byte relative
.1a7bf0	c9 12		cmp #$12	                CMP #ADDR_PC_REL
.1a7bf2	f0 0a		beq $1a7bfe	                BEQ is_short
.1a7bf4	c2 20		rep #$20	            REP #$20
.1a7bf6	18		clc		                CLC                     ; Branch is long. Compute where MCURSOR will be
.1a7bf7	a5 32		lda $087a	                LDA MCURSOR             ; with two branch offset bytes
.1a7bf9	69 02 00	adc #$0002	                ADC #2
.1a7bfc	80 08		bra $1a7c06	                BRA compute_cursor
.1a7bfe					is_short
.1a7bfe	c2 20		rep #$20	            REP #$20
.1a7c00	18		clc		                CLC                     ; Branch is short. Computer where MCURSOR will be
.1a7c01	a5 32		lda $087a	                LDA MCURSOR             ; with one branch offset byte
.1a7c03	69 01 00	adc #$0001	                ADC #1
.1a7c06	85 4a		sta $0892	compute_cursor  STA MTEMP
.1a7c08	a5 34		lda $087c	                LDA MCURSOR+2
.1a7c0a	69 00 00	adc #$0000	                ADC #0
.1a7c0d	85 4c		sta $0894	                STA MTEMP+2
.1a7c0f	38		sec		                SEC                     ; MPARSEDNUM = MPARSEDNUM - MTEMP (MCURSOR after the instruction)
.1a7c10	a5 50		lda $0898	                LDA MPARSEDNUM
.1a7c12	e5 4a		sbc $0892	                SBC MTEMP
.1a7c14	85 50		sta $0898	                STA MPARSEDNUM
.1a7c16	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a7c18	e5 4c		sbc $0894	                SBC MTEMP+2
.1a7c1a	85 52		sta $089a	                STA MPARSEDNUM+2
.1a7c1c	e2 20		sep #$20	            SEP #$20
.1a7c1e	a5 4f		lda $0897	                LDA MADDR_MODE
.1a7c20	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.1a7c22	f0 1e		beq $1a7c42	                BEQ check_long
.1a7c24	a5 50		lda $0898	                LDA MPARSEDNUM          ; Short offset... check if it's negative
.1a7c26	30 0c		bmi $1a7c34	                BMI check_short_neg
.1a7c28	a5 51		lda $0899	                LDA MPARSEDNUM+1        ; Positive short offset... upper two bytes
.1a7c2a	d0 2a		bne $1a7c56	                BNE failure             ; Must be 0 or it's an overflow
.1a7c2c	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a7c2e	d0 26		bne $1a7c56	                BNE failure
.1a7c30	a9 01		lda #$01	                LDA #1                  ; Short offset is 1 byte
.1a7c32	80 26		bra $1a7c5a	                BRA success
.1a7c34	a5 51		lda $0899	check_short_neg LDA MPARSEDNUM+1        ; Negative short offset... upper two bytes
.1a7c36	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's an  overflow
.1a7c38	d0 1c		bne $1a7c56	                BNE failure
.1a7c3a	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a7c3c	c9 ff		cmp #$ff	                CMP #$FF
.1a7c3e	d0 16		bne $1a7c56	                BNE failure
.1a7c40	80 18		bra $1a7c5a	                BRA success
.1a7c42	a5 51		lda $0899	check_long      LDA MPARSEDNUM+1        ; Long offset... check if it's negative
.1a7c44	30 06		bmi $1a7c4c	                BMI check_long_neg
.1a7c46	a5 52		lda $089a	                LDA MPARSEDNUM+2        ; Positive long offset... upper byte
.1a7c48	d0 0c		bne $1a7c56	                BNE failure             ; Must be 0 or it's an overflow
.1a7c4a	80 0e		bra $1a7c5a	                BRA success
.1a7c4c	a5 52		lda $089a	check_long_neg  LDA MPARSEDNUM+2        ; Negative offset... upper two bytes
.1a7c4e	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's and overflow
.1a7c50	d0 04		bne $1a7c56	                BNE failure
.1a7c52	a9 02		lda #$02	                LDA #2                  ; Long offset is 2 bytes
.1a7c54	80 04		bra $1a7c5a	                BRA success
.1a7c56	2b		pld		failure         PLD
.1a7c57	28		plp		                PLP
.1a7c58	18		clc		                CLC
.1a7c59	6b		rtl		                RTL
.1a7c5a	2b		pld		success         PLD
.1a7c5b	28		plp		                PLP
.1a7c5c	38		sec		                SEC
.1a7c5d	6b		rtl		                RTL
.1a7c5e					AS_SHIFT_HEX
.1a7c5e	08		php		                PHP
.1a7c5f	0b		phd		                PHD
.1a7c60	c2 10		rep #$10	            REP #$10
.1a7c62	da		phx		                PHX
.1a7c63	08		php		            PHP
.1a7c64	c2 20		rep #$20	            REP #$20
.1a7c66	48		pha		            PHA
.1a7c67	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7c6a	5b		tcd		            TCD
.1a7c6b	68		pla		            PLA
.1a7c6c	28		plp		            PLP
.1a7c6d	e2 20		sep #$20	            SEP #$20
.1a7c6f	a2 00 00	ldx #$0000	                LDX #0
.1a7c72	df 00 d0 1a	cmp $1ad000,x	seek_loop       CMP @lHEXDIGITS,X   ; Check the passed character against the hex digits
.1a7c76	f0 08		beq $1a7c80	                BEQ found
.1a7c78	e8		inx		                INX                 ; Go to the next hex digit
.1a7c79	e0 10 00	cpx #$0010	                CPX #$10            ; Are we out of digits?
.1a7c7c	f0 1b		beq $1a7c99	                BEQ done            ; Yes... just return
.1a7c7e	80 f2		bra $1a7c72	                BRA seek_loop
.1a7c80					found
.1a7c80	c2 20		rep #$20	            REP #$20
.1a7c82	06 50		asl $0898	                ASL MPARSEDNUM
.1a7c84	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7c86	06 50		asl $0898	                ASL MPARSEDNUM
.1a7c88	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7c8a	06 50		asl $0898	                ASL MPARSEDNUM
.1a7c8c	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7c8e	06 50		asl $0898	                ASL MPARSEDNUM
.1a7c90	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7c92	e2 20		sep #$20	            SEP #$20
.1a7c94	8a		txa		                TXA
.1a7c95	05 50		ora $0898	                ORA MPARSEDNUM
.1a7c97	85 50		sta $0898	                STA MPARSEDNUM
.1a7c99	fa		plx		done            PLX
.1a7c9a	2b		pld		                PLD
.1a7c9b	28		plp		                PLP
.1a7c9c	6b		rtl		                RTL
.1a7c9d					AS_FIND_OPCODE
.1a7c9d	0b		phd		                PHD
.1a7c9e	8b		phb		                PHB
.1a7c9f	08		php		            PHP
.1a7ca0	c2 20		rep #$20	            REP #$20
.1a7ca2	48		pha		            PHA
.1a7ca3	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7ca6	5b		tcd		            TCD
.1a7ca7	68		pla		            PLA
.1a7ca8	28		plp		            PLP
.1a7ca9	08		php		            PHP
.1a7caa	e2 20		sep #$20	            SEP #$20
.1a7cac	48		pha		            PHA
.1a7cad	a9 1a		lda #$1a	            LDA #`MNEMONIC_TAB
.1a7caf	48		pha		            PHA
.1a7cb0	ab		plb		            PLB
.1a7cb1	68		pla		            PLA
.1a7cb2	28		plp		            PLP
.1a7cb3	e2 20		sep #$20	            SEP #$20
.1a7cb5	a5 4f		lda $0897	                LDA MADDR_MODE
.1a7cb7	29 3f		and #$3f	                AND #%00111111
.1a7cb9	85 4a		sta $0892	                STA MTEMP
.1a7cbb	c2 30		rep #$30	            REP #$30
.1a7cbd	a2 00 00	ldx #$0000	                LDX #0
.1a7cc0	a0 00 00	ldy #$0000	                LDY #0
.1a7cc3	bd 6a 83	lda $1a836a,x	mnemonic_loop   LDA MNEMONIC_TAB,X      ; Get the mnemonic from the opcode table
.1a7cc6	f0 1b		beq $1a7ce3	                BEQ not_found           ; If it's 0, we did not find the mnemonic
.1a7cc8	c5 54		cmp $089c	                CMP MMNEMONIC           ; Does it match the passed mnemonic?
.1a7cca	d0 0d		bne $1a7cd9	                BNE next_opcode         ; No: go to the next opcode
.1a7ccc					check_mode
.1a7ccc	e2 20		sep #$20	            SEP #$20
.1a7cce	b9 6c 85	lda $1a856c,y	                LDA ADDRESS_TAB,Y       ; Get the corresponding address mode
.1a7cd1	29 3f		and #$3f	                AND #%00111111          ; Filter out effect bits
.1a7cd3	c5 4a		cmp $0892	                CMP MTEMP
.1a7cd5	f0 07		beq $1a7cde	                BEQ found               ; Yes: we found the opcode
.1a7cd7	c2 20		rep #$20	            REP #$20
.1a7cd9	e8		inx		next_opcode     INX                     ; Point to the next mnemonic in the table
.1a7cda	e8		inx		                INX
.1a7cdb	c8		iny		                INY
.1a7cdc	80 e5		bra $1a7cc3	                BRA mnemonic_loop       ; And check it
.1a7cde	98		tya		found           TYA
.1a7cdf	38		sec		                SEC                     ; Set carry to show success
.1a7ce0	ab		plb		                PLB
.1a7ce1	2b		pld		                PLD
.1a7ce2	6b		rtl		                RTL
.1a7ce3	18		clc		not_found       CLC                     ; Clear carry to show failure
.1a7ce4	ab		plb		                PLB
.1a7ce5	2b		pld		                PLD
.1a7ce6	6b		rtl		                RTL
.1a7ce7					AS_STR_MATCH
.1a7ce7	08		php		                PHP
.1a7ce8	0b		phd		                PHD
.1a7ce9	08		php		            PHP
.1a7cea	c2 20		rep #$20	            REP #$20
.1a7cec	48		pha		            PHA
.1a7ced	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7cf0	5b		tcd		            TCD
.1a7cf1	68		pla		            PLA
.1a7cf2	28		plp		            PLP
.1a7cf3	e2 20		sep #$20	            SEP #$20
.1a7cf5	c2 10		rep #$10	            REP #$10
.1a7cf7	a0 00 00	ldy #$0000	                LDY #0
.1a7cfa	64 50		stz $0898	                STZ MPARSEDNUM      ; Set parsed number to 0 in anticipation of
.1a7cfc	64 52		stz $089a	                STZ MPARSEDNUM+2    ; hex digits in the pattern
.1a7cfe	b7 03		lda [$084b],y	match_loop      LDA [MCMP_TEXT],Y   ; Get the pattern character
.1a7d00	f0 11		beq $1a7d13	                BEQ nul_check       ; If at end of pattern, check for end of test string
.1a7d02	c9 64		cmp #$64	                CMP #'d'            ; Is it a digit?
.1a7d04	f0 19		beq $1a7d1f	                BEQ check_digit     ; Yes: do special check for hex digit
.1a7d06	48		pha		compare         PHA
.1a7d07	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.1a7d09	85 4a		sta $0892	                STA MTEMP
.1a7d0b	68		pla		                PLA
.1a7d0c	c5 4a		cmp $0892	                CMP MTEMP           ; Does it match the character to test?
.1a7d0e	d0 0b		bne $1a7d1b	                BNE return_false    ; No: return fail
.1a7d10	c8		iny		next_char       INY                 ; Yes: test the next character
.1a7d11	80 eb		bra $1a7cfe	                BRA match_loop
.1a7d13	b7 36		lda [$087e],y	nul_check       LDA [MLINEBUF],Y    ; Check to see that we're at the end of the test string
.1a7d15	d0 04		bne $1a7d1b	                BNE return_false    ; If not: return false
.1a7d17	2b		pld		return_true     PLD
.1a7d18	28		plp		                PLP                 ; Return true
.1a7d19	38		sec		                SEC
.1a7d1a	6b		rtl		                RTL
.1a7d1b	2b		pld		return_false    PLD
.1a7d1c	28		plp		                PLP                 ; Return false
.1a7d1d	18		clc		                CLC
.1a7d1e	6b		rtl		                RTL
.1a7d1f					check_digit
.1a7d1f	e2 20		sep #$20	            SEP #$20
.1a7d21	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.1a7d23	c9 3a		cmp #$3a	                CMP #'9'+1
.1a7d25	b0 04		bcs $1a7d2b	                BCS check_AF
.1a7d27	c9 30		cmp #$30	                CMP #'0'
.1a7d29	b0 14		bcs $1a7d3f	                BCS shift_digit     ; character is in [0..9]
.1a7d2b	c9 47		cmp #$47	check_AF        CMP #'F'+1
.1a7d2d	b0 04		bcs $1a7d33	                BCS check_lc        ; check lower case
.1a7d2f	c9 41		cmp #$41	                CMP #'A'
.1a7d31	b0 0c		bcs $1a7d3f	                BCS shift_digit     ; character is in [A..F]
.1a7d33	c9 67		cmp #$67	check_lc        CMP #'f'+1
.1a7d35	b0 e4		bcs $1a7d1b	                BCS return_false    ; check lower case
.1a7d37	c9 61		cmp #$61	                CMP #'a'
.1a7d39	b0 02		bcs $1a7d3d	                BCS to_upcase       ; character is in [A..F]
.1a7d3b	80 de		bra $1a7d1b	                BRA return_false    ; No match found... return false
.1a7d3d	29 df		and #$df	to_upcase       AND #%11011111      ; Convert lower case to upper case
.1a7d3f	22 5e 7c 1a	jsl $1a7c5e	shift_digit     JSL AS_SHIFT_HEX    ; Shift the digit into MPARSEDNUM
.1a7d43	80 cb		bra $1a7d10	                BRA next_char       ; And check the next character
.1a7d45					AS_MCMP_NEXT
.1a7d45	0b		phd		                PHD
.1a7d46	08		php		            PHP
.1a7d47	c2 20		rep #$20	            REP #$20
.1a7d49	48		pha		            PHA
.1a7d4a	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7d4d	5b		tcd		            TCD
.1a7d4e	68		pla		            PLA
.1a7d4f	28		plp		            PLP
.1a7d50	a0 00 00	ldy #$0000	                LDY #0
.1a7d53	e2 20		sep #$20	            SEP #$20
.1a7d55	b7 03		lda [$084b],y	loop            LDA [MCMP_TEXT],Y   ; Check to see if we have gotten to the NUL
.1a7d57	f0 03		beq $1a7d5c	                BEQ found_nul
.1a7d59	c8		iny		                INY
.1a7d5a	80 f9		bra $1a7d55	                BRA loop
.1a7d5c					found_nul
.1a7d5c	c2 20		rep #$20	            REP #$20
.1a7d5e	c8		iny		                INY                 ; Got to NUL... point to next byte
.1a7d5f	5a		phy		                PHY
.1a7d60	68		pla		                PLA                 ; And add that index to MCMP_TEXT pointer
.1a7d61	18		clc		                CLC
.1a7d62	65 03		adc $084b	                ADC MCMP_TEXT
.1a7d64	85 03		sta $084b	                STA MCMP_TEXT
.1a7d66	a5 05		lda $084d	                LDA MCMP_TEXT+2
.1a7d68	69 00 00	adc #$0000	                ADC #0
.1a7d6b	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7d6d	2b		pld		                PLD
.1a7d6e	6b		rtl		                RTL
.1a7d6f					AS_FIND_MNEMO
.1a7d6f	0b		phd		                PHD
.1a7d70	08		php		            PHP
.1a7d71	c2 20		rep #$20	            REP #$20
.1a7d73	48		pha		            PHA
.1a7d74	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7d77	5b		tcd		            TCD
.1a7d78	68		pla		            PLA
.1a7d79	28		plp		            PLP
.1a7d7a	c2 20		rep #$20	            REP #$20
.1a7d7c	a5 11		lda $0859	                LDA MARG2                   ; Point MLINEBUF to the text
.1a7d7e	85 36		sta $087e	                STA MLINEBUF
.1a7d80	a5 13		lda $085b	                LDA MARG2+2
.1a7d82	85 38		sta $0880	                STA MLINEBUF+2
.1a7d84	a9 f8 81	lda #$81f8	                LDA #<>MNEMONICS_TAB        ; Point to the first mnemonic
.1a7d87	85 03		sta $084b	                STA MCMP_TEXT
.1a7d89	a9 1a 00	lda #$001a	                LDA #`MNEMONICS_TAB
.1a7d8c	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7d8e	22 e7 7c 1a	jsl $1a7ce7	match_loop      JSL AS_STR_MATCH            ; Check to see if the text matches the mnemonic
.1a7d92	b0 0d		bcs $1a7da1	                BCS found_mnemonic          ; If so: return that we found it
.1a7d94	22 45 7d 1a	jsl $1a7d45	                JSL AS_MCMP_NEXT            ; Point to the next mnemonic
.1a7d98	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Check to see if it's NUL
.1a7d9a	d0 f2		bne $1a7d8e	                BNE match_loop              ; If not, check this next mnemonic
.1a7d9c	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Otherwise, return -1
.1a7d9f	80 02		bra $1a7da3	                BRA done
.1a7da1	a5 03		lda $084b	found_mnemonic  LDA MCMP_TEXT               ; Found it: return the address
.1a7da3	2b		pld		done            PLD
.1a7da4	6b		rtl		                RTL
.1a7da5					AS_FIND_MODE
.1a7da5	08		php		                PHP
.1a7da6	0b		phd		                PHD
.1a7da7	08		php		            PHP
.1a7da8	c2 20		rep #$20	            REP #$20
.1a7daa	48		pha		            PHA
.1a7dab	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7dae	5b		tcd		            TCD
.1a7daf	68		pla		            PLA
.1a7db0	28		plp		            PLP
.1a7db1	c2 30		rep #$30	            REP #$30
.1a7db3	a5 15		lda $085d	                LDA MARG3                   ; Point MLINEBUF to the operand
.1a7db5	85 36		sta $087e	                STA MLINEBUF
.1a7db7	a5 17		lda $085f	                LDA MARG3+2
.1a7db9	85 38		sta $0880	                STA MLINEBUF+2
.1a7dbb	a9 84 86	lda #$8684	                LDA #<>ADDR_PATTERNS        ; Point to the first address mode pattern to check
.1a7dbe	85 03		sta $084b	                STA MCMP_TEXT
.1a7dc0	a9 1a 00	lda #$001a	                LDA #`ADDR_PATTERNS
.1a7dc3	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7dc5	22 e7 7c 1a	jsl $1a7ce7	match_loop      JSL AS_STR_MATCH            ; Check to see if the pattern matches the operand
.1a7dc9	b0 22		bcs $1a7ded	                BCS is_match                ; Yes: Find address mode code
.1a7dcb	22 45 7d 1a	jsl $1a7d45	                JSL AS_MCMP_NEXT            ; Point to the address mode
.1a7dcf	c2 20		rep #$20	            REP #$20
.1a7dd1	18		clc		                CLC                         ; Point to the first byte of the next pattern
.1a7dd2	a5 03		lda $084b	                LDA MCMP_TEXT
.1a7dd4	69 01 00	adc #$0001	                ADC #1
.1a7dd7	85 03		sta $084b	                STA MCMP_TEXT
.1a7dd9	a5 05		lda $084d	                LDA MCMP_TEXT+2
.1a7ddb	69 00 00	adc #$0000	                ADC #0
.1a7dde	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7de0	e2 20		sep #$20	            SEP #$20
.1a7de2	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Is the first byte 0?
.1a7de4	d0 df		bne $1a7dc5	                BNE match_loop              ; No: check this next pattern
.1a7de6	c2 20		rep #$20	            REP #$20
.1a7de8	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Yes: we didn't find a matching pattern, return -1
.1a7deb	80 0d		bra $1a7dfa	                BRA done
.1a7ded	22 45 7d 1a	jsl $1a7d45	is_match        JSL AS_MCMP_NEXT            ; Point to the address mode
.1a7df1	e2 20		sep #$20	            SEP #$20
.1a7df3	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Get the corresponding address mode code (a byte)
.1a7df5	c2 20		rep #$20	            REP #$20
.1a7df7	29 ff 00	and #$00ff	                AND #$00FF
.1a7dfa	2b		pld		done            PLD
.1a7dfb	28		plp		                PLP
.1a7dfc	6b		rtl		                RTL
.1a7dfd					IMDISASSEMBLE
.1a7dfd	08		php		                PHP
.1a7dfe	8b		phb		                PHB
.1a7dff	0b		phd		                PHD
.1a7e00	08		php		            PHP
.1a7e01	c2 20		rep #$20	            REP #$20
.1a7e03	48		pha		            PHA
.1a7e04	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7e07	5b		tcd		            TCD
.1a7e08	68		pla		            PLA
.1a7e09	28		plp		            PLP
.1a7e0a	e2 20		sep #$20	            SEP #$20
.1a7e0c	a9 00		lda #$00	                LDA #0
.1a7e0e	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT     ; Clear the pagination line counter
.1a7e12	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.1a7e14	c9 02		cmp #$02	                CMP #2
.1a7e16	b0 16		bcs $1a7e2e	                BGE set_cursor      ; 2>= arguments? Use them as-is
.1a7e18	c9 01		cmp #$01	                CMP #1
.1a7e1a	90 20		bcc $1a7e3c	                BLT no_args         ; No arguments passed? Use defaults
.1a7e1c	c2 20		rep #$20	            REP #$20
.1a7e1e	18		clc		                CLC
.1a7e1f	a5 0d		lda $0855	                LDA MARG1
.1a7e21	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a7e24	85 11		sta $0859	                STA MARG2
.1a7e26	e2 20		sep #$20	            SEP #$20
.1a7e28	a5 0f		lda $0857	                LDA MARG1+2
.1a7e2a	69 00		adc #$00	                ADC #0
.1a7e2c	85 13		sta $085b	                STA MARG2+2
.1a7e2e					set_cursor
.1a7e2e	c2 20		rep #$20	            REP #$20
.1a7e30	a5 0d		lda $0855	                LDA MARG1
.1a7e32	85 32		sta $087a	                STA MCURSOR
.1a7e34	e2 20		sep #$20	            SEP #$20
.1a7e36	a5 0f		lda $0857	                LDA MARG1+2
.1a7e38	85 34		sta $087c	                STA MCURSOR+2
.1a7e3a	80 12		bra $1a7e4e	                BRA dasm_loop
.1a7e3c					no_args
.1a7e3c	c2 20		rep #$20	            REP #$20
.1a7e3e	18		clc		                CLC
.1a7e3f	a5 32		lda $087a	                LDA MCURSOR
.1a7e41	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a7e44	85 11		sta $0859	                STA MARG2
.1a7e46	e2 20		sep #$20	            SEP #$20
.1a7e48	a5 34		lda $087c	                LDA MCURSOR+2
.1a7e4a	69 00		adc #$00	                ADC #0
.1a7e4c	85 13		sta $085b	                STA MARG2+2
.1a7e4e	22 69 7e 1a	jsl $1a7e69	dasm_loop       JSL DS_PR_LINE
.1a7e52	e2 20		sep #$20	            SEP #$20
.1a7e54	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.1a7e56	c5 13		cmp $085b	                CMP MARG2+2
.1a7e58	90 f4		bcc $1a7e4e	                BLT dasm_loop           ; No: continue
.1a7e5a	c2 20		rep #$20	            REP #$20
.1a7e5c	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.1a7e5e	c5 11		cmp $0859	                CMP MARG2
.1a7e60	90 ec		bcc $1a7e4e	                BLT dasm_loop           ; Nope... keep going
.1a7e62					done
.1a7e62	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a7e65	2b		pld		                PLD
.1a7e66	ab		plb		                PLB
.1a7e67	28		plp		                PLP
.1a7e68	6b		rtl		                RTL
.1a7e69					DS_PR_LINE
.1a7e69	08		php		                PHP
.1a7e6a	0b		phd		                PHD
.1a7e6b	e2 20		sep #$20	            SEP #$20
.1a7e6d	a9 41		lda #$41	                LDA #'A'
.1a7e6f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e72	a9 20		lda #$20	                LDA #' '
.1a7e74	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e77	08		php		            PHP
.1a7e78	c2 20		rep #$20	            REP #$20
.1a7e7a	48		pha		            PHA
.1a7e7b	a9 7a 08	lda #$087a	            LDA #MCURSOR
.1a7e7e	5b		tcd		            TCD
.1a7e7f	68		pla		            PLA
.1a7e80	28		plp		            PLP
.1a7e81	c2 20		rep #$20	            REP #$20
.1a7e83	a5 00		lda $087a	                LDA MCURSOR
.1a7e85	85 18		sta $0892	                STA MTEMP
.1a7e87	e2 20		sep #$20	            SEP #$20
.1a7e89	a5 02		lda $087c	                LDA MCURSOR+2
.1a7e8b	85 1a		sta $0894	                STA MTEMP+2
.1a7e8d	22 d0 81 1a	jsl $1a81d0	                JSL M_PR_ADDR
.1a7e91	a9 20		lda #$20	                LDA #' '
.1a7e93	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e96	c2 20		rep #$20	            REP #$20
.1a7e98	18		clc		                CLC
.1a7e99	a5 00		lda $087a	                LDA MCURSOR
.1a7e9b	69 01 00	adc #$0001	                ADC #1
.1a7e9e	85 18		sta $0892	                STA MTEMP
.1a7ea0	e2 20		sep #$20	            SEP #$20
.1a7ea2	a5 02		lda $087c	                LDA MCURSOR+2
.1a7ea4	69 00		adc #$00	                ADC #0
.1a7ea6	85 1a		sta $0894	                STA MTEMP+2
.1a7ea8	e2 20		sep #$20	            SEP #$20
.1a7eaa	c2 10		rep #$10	            REP #$10
.1a7eac	a7 00		lda [$087a]	                LDA [MCURSOR]           ; Get the mnemonic
.1a7eae	c9 c2		cmp #$c2	                CMP #$C2                ; Is it REP?
.1a7eb0	d0 0b		bne $1a7ebd	                BNE check_sep           ; No: check to see if it is SEP
.1a7eb2	48		pha		handle_rep      PHA
.1a7eb3	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.1a7eb5	49 ff		eor #$ff	                EOR #$FF                ; Invert the bits
.1a7eb7	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Mask off the bits in the CPUSTAT
.1a7ebb	80 0b		bra $1a7ec8	                BRA save_stat
.1a7ebd	c9 e2		cmp #$e2	check_sep       CMP #$E2                ; Is it SEP?
.1a7ebf	d0 0c		bne $1a7ecd	                BNE get_op_index        ; No: process the instruction regularly
.1a7ec1	48		pha		handle_sep      PHA
.1a7ec2	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.1a7ec4	0f 96 08 00	ora $000896	                ORA @lMCPUSTAT          ; Activate the bits in the CPUSTAT
.1a7ec8	8f 96 08 00	sta $000896	save_stat       STA @lMCPUSTAT          ; And save it back
.1a7ecc	68		pla		                PLA
.1a7ecd					get_op_index
.1a7ecd	c2 20		rep #$20	            REP #$20
.1a7ecf	29 ff 00	and #$00ff	                AND #$00FF
.1a7ed2	0a		asl a		                ASL A
.1a7ed3	aa		tax		                TAX                     ; Get the index into the mnemonic lookup table
.1a7ed4	bf 6a 83 1a	lda $1a836a,x	                LDA @lMNEMONIC_TAB,X    ; Get the mnemonic
.1a7ed8	aa		tax		                TAX
.1a7ed9	22 4a 81 1a	jsl $1a814a	                JSL DS_PR_MNEMONIC      ; And print it
.1a7edd	e2 20		sep #$20	            SEP #$20
.1a7edf	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a7ee1	aa		tax		                TAX
.1a7ee2	bf 6c 85 1a	lda $1a856c,x	pr_operand      LDA @lADDRESS_TAB,X     ; Get the addressing mode for the instruction
.1a7ee6	22 26 87 1a	jsl $1a8726	                JSL M_INC_CURSOR        ; Advance the cursor to the next byte
.1a7eea	22 f7 7e 1a	jsl $1a7ef7	                JSL DS_PR_OPERAND       ; And print the correct operand
.1a7eee	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a7ef1	20 ee 03	jsr $1a03ee	            JSR PAGINATE
.1a7ef4	2b		pld		                PLD
.1a7ef5	28		plp		                PLP
.1a7ef6	6b		rtl		                RTL
.1a7ef7					DS_PR_OPERAND
.1a7ef7	08		php		                PHP
.1a7ef8	e2 20		sep #$20	            SEP #$20
.1a7efa	48		pha		                PHA             ; Save the address mode so we can get to the M and X flags
.1a7efb	29 3f		and #$3f	                AND #%00111111  ; Filter out the mode flags
.1a7efd	0a		asl a		                ASL A           ; Compute the index to the table
.1a7efe	c2 10		rep #$10	            REP #$10
.1a7f00	aa		tax		                TAX
.1a7f01	68		pla		                PLA             ; Restore A
.1a7f02	7c 05 7f	jmp ($1a7f05,x)	                JMP (dispatch,X)
>1a7f05	35 7f				dispatch        .word <>is_dp_ind_x
>1a7f07	50 7f				                .word <>is_dp
>1a7f09	57 7f				                .word <>is_imm
>1a7f0b	7c 7f				                .word <>is_abs
>1a7f0d	83 7f				                .word <>is_dp_ind_y
>1a7f0f	9e 7f				                .word <>is_dp_x
>1a7f11	c0 7f				                .word <>is_abs_y
>1a7f13	d1 7f				                .word <>is_abs_x
>1a7f15	0e 80				                .word <>is_accumulator
>1a7f17	16 80				                .word <>is_stack_r
>1a7f19	27 80				                .word <>is_dp_long
>1a7f1b	38 80				                .word <>is_abs_long
>1a7f1d	3f 80				                .word <>is_stack_r_y
>1a7f1f	64 80				                .word <>is_dp_y_long
>1a7f21	91 80				                .word <>is_abs_x_long
>1a7f23	fd 7f				                .word <>is_dp_ind
>1a7f25	e2 7f				                .word <>is_abs_x_id
>1a7f27	af 7f				                .word <>is_dp_y
>1a7f29	84 80				                .word <>is_pc_rel
>1a7f2b	8e 80				                .word <>is_implied
>1a7f2d	a2 80				                .word <>is_xyc
>1a7f2f	d1 80				                .word <>is_abs_ind
>1a7f31	7f 80				                .word <>is_pc_rel_long
>1a7f33	e2 80				                .word <>is_abs_ind_long
.1a7f35	a9 28		lda #$28	is_dp_ind_x     LDA #'('                ; Print (dd,X)
.1a7f37	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f3a	22 f9 80 1a	jsl $1a80f9	                JSL DS_PR_OPERAND1      ; Print dd
.1a7f3e	a9 2c		lda #$2c	                LDA #','
.1a7f40	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f43	a9 58		lda #$58	                LDA #'X'
.1a7f45	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f48	a9 29		lda #$29	                LDA #')'
.1a7f4a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f4d	4c f3 80	jmp $1a80f3	                JMP done_1
.1a7f50	22 f9 80 1a	jsl $1a80f9	is_dp           JSL DS_PR_OPERAND1      ; Print dd
.1a7f54	4c f3 80	jmp $1a80f3	                JMP done_1
.1a7f57					is_imm
.1a7f57	e2 20		sep #$20	            SEP #$20
.1a7f59	48		pha		                PHA
.1a7f5a	a9 23		lda #$23	                LDA #'#'
.1a7f5c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f5f	68		pla		                PLA
.1a7f60	29 c0		and #$c0	                AND #%11000000          ; Filter so we just look at the mode bits
.1a7f62	c9 00		cmp #$00	                CMP #$00                ; Are any set to check?
.1a7f64	f0 0f		beq $1a7f75	                BEQ is_imm_short        ; No: treat it as a short always
.1a7f66	4a		lsr a		                LSR A                   ; Move the flag bits right by 2 to match
.1a7f67	4a		lsr a		                LSR A                   ; the positions of the bits in the CPU status register
.1a7f68	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Otherwise, filter the mode bit we care about
.1a7f6c	d0 07		bne $1a7f75	                BNE is_imm_short        ; If it is set, immediate operation is short
.1a7f6e	22 03 81 1a	jsl $1a8103	                JSL DS_PR_OPERAND2      ; Print dddd
.1a7f72	4c f3 80	jmp $1a80f3	                JMP done_1
.1a7f75	22 f9 80 1a	jsl $1a80f9	is_imm_short    JSL DS_PR_OPERAND1      ; Print dd
.1a7f79	4c f3 80	jmp $1a80f3	                JMP done_1
.1a7f7c	22 03 81 1a	jsl $1a8103	is_abs          JSL DS_PR_OPERAND2      ; Print dddd
.1a7f80	4c f3 80	jmp $1a80f3	                JMP done_1
.1a7f83	a9 28		lda #$28	is_dp_ind_y     LDA #'('                ; Print (dd),Y
.1a7f85	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f88	22 f9 80 1a	jsl $1a80f9	                JSL DS_PR_OPERAND1      ; Print dd
.1a7f8c	a9 29		lda #$29	                LDA #')'
.1a7f8e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f91	a9 2c		lda #$2c	                LDA #','
.1a7f93	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f96	a9 59		lda #$59	                LDA #'Y'
.1a7f98	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f9b	4c f3 80	jmp $1a80f3	                JMP done_1
.1a7f9e	22 f9 80 1a	jsl $1a80f9	is_dp_x         JSL DS_PR_OPERAND1      ; Print dd,X
.1a7fa2	a9 2c		lda #$2c	                LDA #','
.1a7fa4	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fa7	a9 58		lda #$58	                LDA #'X'
.1a7fa9	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fac	4c f3 80	jmp $1a80f3	                JMP done_1
.1a7faf	22 f9 80 1a	jsl $1a80f9	is_dp_y         JSL DS_PR_OPERAND1      ; Print dd,Y
.1a7fb3	a9 2c		lda #$2c	                LDA #','
.1a7fb5	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fb8	a9 59		lda #$59	                LDA #'Y'
.1a7fba	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fbd	4c f3 80	jmp $1a80f3	                JMP done_1
.1a7fc0	22 03 81 1a	jsl $1a8103	is_abs_y        JSL DS_PR_OPERAND2      ; Print dddd,Y
.1a7fc4	a9 2c		lda #$2c	                LDA #','
.1a7fc6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fc9	a9 59		lda #$59	                LDA #'Y'
.1a7fcb	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fce	4c f3 80	jmp $1a80f3	                JMP done_1
.1a7fd1	22 03 81 1a	jsl $1a8103	is_abs_x        JSL DS_PR_OPERAND2      ; Print dddd,X
.1a7fd5	a9 2c		lda #$2c	                LDA #','
.1a7fd7	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fda	a9 58		lda #$58	                LDA #'X'
.1a7fdc	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fdf	4c f3 80	jmp $1a80f3	                JMP done_1
.1a7fe2	a9 28		lda #$28	is_abs_x_id     LDA #'('
.1a7fe4	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fe7	22 03 81 1a	jsl $1a8103	                JSL DS_PR_OPERAND2      ; Print (dddd,X)
.1a7feb	a9 2c		lda #$2c	                LDA #','
.1a7fed	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ff0	a9 58		lda #$58	                LDA #'X'
.1a7ff2	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ff5	a9 29		lda #$29	                LDA #')'
.1a7ff7	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ffa	4c f3 80	jmp $1a80f3	                JMP done_1
.1a7ffd	a9 28		lda #$28	is_dp_ind       LDA #'('
.1a7fff	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8002	22 f9 80 1a	jsl $1a80f9	                JSL DS_PR_OPERAND1      ; Print (dd)
.1a8006	a9 29		lda #$29	                LDA #')'
.1a8008	20 18 00	jsr $1a0018	            JSR PRINTC
.1a800b	4c f3 80	jmp $1a80f3	                JMP done_1
.1a800e	a9 41		lda #$41	is_accumulator  LDA #'A'                ; Print A
.1a8010	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8013	4c f7 80	jmp $1a80f7	                JMP done
.1a8016	22 f9 80 1a	jsl $1a80f9	is_stack_r      JSL DS_PR_OPERAND1      ; Print dd,S
.1a801a	a9 2c		lda #$2c	                LDA #','
.1a801c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a801f	a9 53		lda #$53	                LDA #'S'
.1a8021	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8024	4c f3 80	jmp $1a80f3	                JMP done_1
.1a8027	a9 5b		lda #$5b	is_dp_long      LDA #'['                ; [dd]
.1a8029	20 18 00	jsr $1a0018	            JSR PRINTC
.1a802c	22 f9 80 1a	jsl $1a80f9	                JSL DS_PR_OPERAND1      ; Print dd
.1a8030	a9 5d		lda #$5d	                LDA #']'
.1a8032	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8035	4c f3 80	jmp $1a80f3	                JMP done_1
.1a8038	22 11 81 1a	jsl $1a8111	is_abs_long     JSL DS_PR_OPERAND3      ; Print dddddd
.1a803c	4c f7 80	jmp $1a80f7	                JMP done
.1a803f	a9 28		lda #$28	is_stack_r_y    LDA #'('                ; (dd,S),Y
.1a8041	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8044	22 f9 80 1a	jsl $1a80f9	                JSL DS_PR_OPERAND1      ; Print dd
.1a8048	a9 2c		lda #$2c	                LDA #','
.1a804a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a804d	a9 53		lda #$53	                LDA #'S'
.1a804f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8052	a9 29		lda #$29	                LDA #')'
.1a8054	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8057	a9 2c		lda #$2c	                LDA #','
.1a8059	20 18 00	jsr $1a0018	            JSR PRINTC
.1a805c	a9 59		lda #$59	                LDA #'Y'
.1a805e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8061	4c f3 80	jmp $1a80f3	                JMP done_1
.1a8064	a9 5b		lda #$5b	is_dp_y_long    LDA #'['                ; [dd],Y
.1a8066	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8069	22 f9 80 1a	jsl $1a80f9	                JSL DS_PR_OPERAND1      ; Print dd
.1a806d	a9 5d		lda #$5d	                LDA #']'
.1a806f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8072	a9 2c		lda #$2c	                LDA #','
.1a8074	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8077	a9 59		lda #$59	                LDA #'Y'
.1a8079	20 18 00	jsr $1a0018	            JSR PRINTC
.1a807c	4c f3 80	jmp $1a80f3	                JMP done_1
.1a807f	a0 02 00	ldy #$0002	is_pc_rel_long  LDY #2
.1a8082	80 03		bra $1a8087	                BRA do_pcrel
.1a8084	a0 01 00	ldy #$0001	is_pc_rel       LDY #1
.1a8087	22 77 81 1a	jsl $1a8177	do_pcrel        JSL DS_PR_PCREL
.1a808b	4c f7 80	jmp $1a80f7	                JMP done
.1a808e	4c f7 80	jmp $1a80f7	is_implied      JMP done
.1a8091	22 11 81 1a	jsl $1a8111	is_abs_x_long   JSL DS_PR_OPERAND3      ; Print dddddd
.1a8095	a9 2c		lda #$2c	                LDA #','
.1a8097	20 18 00	jsr $1a0018	            JSR PRINTC
.1a809a	a9 58		lda #$58	                LDA #'X'
.1a809c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a809f	4c f7 80	jmp $1a80f7	                JMP done
.1a80a2	a9 23		lda #$23	is_xyc          LDA #'#'
.1a80a4	20 18 00	jsr $1a0018	            JSR PRINTC
.1a80a7	8b		phb		                PHB                     ; Make sure the databank is pointed to our number
.1a80a8	a5 02		lda $087c	                LDA MCURSOR+2
.1a80aa	48		pha		                PHA
.1a80ab	ab		plb		                PLB
.1a80ac	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.1a80ae	e8		inx		                INX
.1a80af	a0 01 00	ldy #$0001	                LDY #1
.1a80b2	22 e7 03 1a	jsl $1a03e7	                JSL PRINTH
.1a80b6	a9 2c		lda #$2c	                LDA #','
.1a80b8	20 18 00	jsr $1a0018	            JSR PRINTC
.1a80bb	a9 23		lda #$23	                LDA #'#'
.1a80bd	20 18 00	jsr $1a0018	            JSR PRINTC
.1a80c0	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.1a80c2	a0 01 00	ldy #$0001	                LDY #1
.1a80c5	22 e7 03 1a	jsl $1a03e7	                JSL PRINTH
.1a80c9	ab		plb		                PLB                     ; Get our old data bank back
.1a80ca	22 26 87 1a	jsl $1a8726	                JSL M_INC_CURSOR
.1a80ce	4c f3 80	jmp $1a80f3	                JMP done_1
.1a80d1	a9 28		lda #$28	is_abs_ind      LDA #'('
.1a80d3	20 18 00	jsr $1a0018	            JSR PRINTC
.1a80d6	22 03 81 1a	jsl $1a8103	                JSL DS_PR_OPERAND2      ; Print (dddd)
.1a80da	a9 29		lda #$29	                LDA #')'
.1a80dc	20 18 00	jsr $1a0018	            JSR PRINTC
.1a80df	4c f3 80	jmp $1a80f3	                JMP done_1
.1a80e2	a9 5b		lda #$5b	is_abs_ind_long LDA #'['
.1a80e4	20 18 00	jsr $1a0018	            JSR PRINTC
.1a80e7	22 03 81 1a	jsl $1a8103	                JSL DS_PR_OPERAND2      ; Print [dddd]
.1a80eb	a9 5d		lda #$5d	                LDA #']'
.1a80ed	20 18 00	jsr $1a0018	            JSR PRINTC
.1a80f0	4c f3 80	jmp $1a80f3	                JMP done_1
.1a80f3	22 26 87 1a	jsl $1a8726	done_1          JSL M_INC_CURSOR    ; Skip over a single byte operand
.1a80f7	28		plp		done            PLP
.1a80f8	6b		rtl		                RTL
.1a80f9					DS_PR_OPERAND1
.1a80f9	08		php		                PHP
.1a80fa	e2 20		sep #$20	            SEP #$20
.1a80fc	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a80fe	20 8e 04	jsr $1a048e	            JSR PRHEXB
.1a8101	28		plp		                PLP
.1a8102	6b		rtl		                RTL
.1a8103					DS_PR_OPERAND2
.1a8103	08		php		                PHP
.1a8104	c2 30		rep #$30	            REP #$30
.1a8106	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a8108	20 74 04	jsr $1a0474	            JSR PRHEXW
.1a810b	22 26 87 1a	jsl $1a8726	                JSL M_INC_CURSOR
.1a810f	28		plp		                PLP
.1a8110	6b		rtl		                RTL
.1a8111					DS_PR_OPERAND3
.1a8111	08		php		                PHP
.1a8112	8b		phb		                PHB
.1a8113	0b		phd		                PHD
.1a8114	c2 30		rep #$30	            REP #$30
.1a8116	5a		phy		                PHY
.1a8117	08		php		            PHP
.1a8118	c2 20		rep #$20	            REP #$20
.1a811a	48		pha		            PHA
.1a811b	a9 7a 08	lda #$087a	            LDA #MCURSOR
.1a811e	5b		tcd		            TCD
.1a811f	68		pla		            PLA
.1a8120	28		plp		            PLP
.1a8121	08		php		            PHP
.1a8122	e2 20		sep #$20	            SEP #$20
.1a8124	48		pha		            PHA
.1a8125	a9 00		lda #$00	            LDA #`MTEMP
.1a8127	48		pha		            PHA
.1a8128	ab		plb		            PLB
.1a8129	68		pla		            PLA
.1a812a	28		plp		            PLP
.1a812b	e2 20		sep #$20	            SEP #$20
.1a812d	a0 00 00	ldy #$0000	                LDY #0
.1a8130	a7 00		lda [$087a]	copy_loop       LDA [MCURSOR]       ; Copy the address pointed to by MCURSOR
.1a8132	99 92 08	sta $0892,y	                STA MTEMP,Y         ; to MTEMP
.1a8135	22 26 87 1a	jsl $1a8726	                JSL M_INC_CURSOR
.1a8139	c8		iny		                INY
.1a813a	c0 03 00	cpy #$0003	                CPY #3
.1a813d	d0 f1		bne $1a8130	                BNE copy_loop
.1a813f	22 d0 81 1a	jsl $1a81d0	                JSL M_PR_ADDR       ; Print the address
.1a8143	c2 30		rep #$30	            REP #$30
.1a8145	7a		ply		                PLY
.1a8146	2b		pld		                PLD
.1a8147	ab		plb		                PLB
.1a8148	28		plp		                PLP
.1a8149	6b		rtl		                RTL
.1a814a					DS_PR_MNEMONIC
.1a814a	08		php		                PHP
.1a814b	8b		phb		                PHB
.1a814c	e2 20		sep #$20	            SEP #$20
.1a814e	c2 10		rep #$10	            REP #$10
.1a8150	08		php		            PHP
.1a8151	e2 20		sep #$20	            SEP #$20
.1a8153	48		pha		            PHA
.1a8154	a9 1a		lda #$1a	            LDA #`MN_ORA
.1a8156	48		pha		            PHA
.1a8157	ab		plb		            PLB
.1a8158	68		pla		            PLA
.1a8159	28		plp		            PLP
.1a815a	bd 00 00	lda $1a0000,x	                LDA #0,B,X
.1a815d	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8160	e8		inx		                INX
.1a8161	bd 00 00	lda $1a0000,x	                LDA #0,B,X
.1a8164	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8167	e8		inx		                INX
.1a8168	bd 00 00	lda $1a0000,x	                LDA #0,B,X
.1a816b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a816e	e8		inx		                INX
.1a816f	a9 20		lda #$20	                LDA #' '            ; Print a space
.1a8171	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8174	ab		plb		                PLB
.1a8175	28		plp		                PLP
.1a8176	6b		rtl		                RTL
.1a8177					DS_PR_PCREL
.1a8177	08		php		                PHP
.1a8178	0b		phd		                PHD
.1a8179	08		php		            PHP
.1a817a	c2 20		rep #$20	            REP #$20
.1a817c	48		pha		            PHA
.1a817d	a9 7a 08	lda #$087a	            LDA #MCURSOR
.1a8180	5b		tcd		            TCD
.1a8181	68		pla		            PLA
.1a8182	28		plp		            PLP
.1a8183	e2 20		sep #$20	            SEP #$20
.1a8185	c0 02 00	cpy #$0002	                CPY #2
.1a8188	f0 14		beq $1a819e	                BEQ offset_2
.1a818a	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a818c	85 18		sta $0892	                STA MTEMP
.1a818e	30 06		bmi $1a8196	                BMI is_negative
.1a8190	64 19		stz $0893	                STZ MTEMP+1
.1a8192	64 1a		stz $0894	                STZ MTEMP+2
.1a8194	80 1e		bra $1a81b4	                BRA add_offset
.1a8196	a9 ff		lda #$ff	is_negative     LDA #$FF
.1a8198	85 19		sta $0893	                STA MTEMP+1
.1a819a	85 1a		sta $0894	                STA MTEMP+2
.1a819c	80 16		bra $1a81b4	                BRA add_offset
.1a819e	a7 00		lda [$087a]	offset_2        LDA [MCURSOR]
.1a81a0	85 18		sta $0892	                STA MTEMP
.1a81a2	22 26 87 1a	jsl $1a8726	                JSL M_INC_CURSOR
.1a81a6	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a81a8	85 19		sta $0893	                STA MTEMP+1
.1a81aa	30 04		bmi $1a81b0	                BMI is_negative2
.1a81ac	64 1a		stz $0894	                STZ MTEMP+2
.1a81ae	80 04		bra $1a81b4	                BRA add_offset
.1a81b0	a9 ff		lda #$ff	is_negative2    LDA #$FF
.1a81b2	85 1a		sta $0894	                STA MTEMP+2
.1a81b4					add_offset
.1a81b4	c2 20		rep #$20	            REP #$20
.1a81b6	38		sec		                SEC             ; Add 1 to the offset
.1a81b7	a5 00		lda $087a	                LDA MCURSOR
.1a81b9	65 18		adc $0892	                ADC MTEMP
.1a81bb	85 18		sta $0892	                STA MTEMP
.1a81bd	e2 20		sep #$20	            SEP #$20
.1a81bf	a5 02		lda $087c	                LDA MCURSOR+2
.1a81c1	65 1a		adc $0894	                ADC MTEMP+2
.1a81c3	85 1a		sta $0894	                STA MTEMP+2
.1a81c5	22 d0 81 1a	jsl $1a81d0	                JSL M_PR_ADDR
.1a81c9	22 26 87 1a	jsl $1a8726	                JSL M_INC_CURSOR
.1a81cd	2b		pld		                PLD
.1a81ce	28		plp		                PLP
.1a81cf	6b		rtl		                RTL
.1a81d0					M_PR_ADDR
.1a81d0	08		php		                PHP
.1a81d1	0b		phd		                PHD
.1a81d2	c2 20		rep #$20	            REP #$20
.1a81d4	48		pha		                PHA
.1a81d5	08		php		            PHP
.1a81d6	c2 20		rep #$20	            REP #$20
.1a81d8	48		pha		            PHA
.1a81d9	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a81dc	5b		tcd		            TCD
.1a81dd	68		pla		            PLA
.1a81de	28		plp		            PLP
.1a81df	e2 20		sep #$20	            SEP #$20
.1a81e1	a5 4c		lda $0894	                LDA MTEMP+2     ; Print the bank byte of the address
.1a81e3	20 8e 04	jsr $1a048e	            JSR PRHEXB
.1a81e6	e2 20		sep #$20	            SEP #$20
.1a81e8	a9 3a		lda #$3a	                LDA #':'
.1a81ea	20 18 00	jsr $1a0018	            JSR PRINTC
.1a81ed	c2 20		rep #$20	            REP #$20
.1a81ef	a5 4a		lda $0892	                LDA MTEMP       ; Print the lower 16-bits of the address
.1a81f1	20 74 04	jsr $1a0474	            JSR PRHEXW
.1a81f4	68		pla		                PLA
.1a81f5	2b		pld		                PLD
.1a81f6	28		plp		                PLP
.1a81f7	6b		rtl		                RTL
.1a81f8					MNEMONICS_TAB
.1a81f8					MN_ORA
>1a81f8	4f 52 41 00			            .null "ORA"
.1a81fc					MN_AND
>1a81fc	41 4e 44 00			            .null "AND"
.1a8200					MN_EOR
>1a8200	45 4f 52 00			            .null "EOR"
.1a8204					MN_ADC
>1a8204	41 44 43 00			            .null "ADC"
.1a8208					MN_STA
>1a8208	53 54 41 00			            .null "STA"
.1a820c					MN_LDA
>1a820c	4c 44 41 00			            .null "LDA"
.1a8210					MN_CMP
>1a8210	43 4d 50 00			            .null "CMP"
.1a8214					MN_SBC
>1a8214	53 42 43 00			            .null "SBC"
.1a8218					MN_ASL
>1a8218	41 53 4c 00			            .null "ASL"
.1a821c					MN_ROL
>1a821c	52 4f 4c 00			            .null "ROL"
.1a8220					MN_LSR
>1a8220	4c 53 52 00			            .null "LSR"
.1a8224					MN_ROR
>1a8224	52 4f 52 00			            .null "ROR"
.1a8228					MN_STX
>1a8228	53 54 58 00			            .null "STX"
.1a822c					MN_LDX
>1a822c	4c 44 58 00			            .null "LDX"
.1a8230					MN_DEC
>1a8230	44 45 43 00			            .null "DEC"
.1a8234					MN_INC
>1a8234	49 4e 43 00			            .null "INC"
.1a8238					MN_BIT
>1a8238	42 49 54 00			            .null "BIT"
.1a823c					MN_JMP
>1a823c	4a 4d 50 00			            .null "JMP"
.1a8240					MN_STY
>1a8240	53 54 59 00			            .null "STY"
.1a8244					MN_LDY
>1a8244	4c 44 59 00			            .null "LDY"
.1a8248					MN_CPY
>1a8248	43 50 59 00			            .null "CPY"
.1a824c					MN_CPX
>1a824c	43 50 58 00			            .null "CPX"
.1a8250					MN_BRK
>1a8250	42 52 4b 00			            .null "BRK"
.1a8254					MN_JSR
>1a8254	4a 53 52 00			            .null "JSR"
.1a8258					MN_RTI
>1a8258	52 54 49 00			            .null "RTI"
.1a825c					MN_RTS
>1a825c	52 54 53 00			            .null "RTS"
.1a8260					MN_PHP
>1a8260	50 48 50 00			            .null "PHP"
.1a8264					MN_PLP
>1a8264	50 4c 50 00			            .null "PLP"
.1a8268					MN_PHA
>1a8268	50 48 41 00			            .null "PHA"
.1a826c					MN_PLA
>1a826c	50 4c 41 00			            .null "PLA"
.1a8270					MN_DEY
>1a8270	44 45 59 00			            .null "DEY"
.1a8274					MN_TAY
>1a8274	54 41 59 00			            .null "TAY"
.1a8278					MN_INY
>1a8278	49 4e 59 00			            .null "INY"
.1a827c					MN_INX
>1a827c	49 4e 58 00			            .null "INX"
.1a8280					MN_CLC
>1a8280	43 4c 43 00			            .null "CLC"
.1a8284					MN_SEC
>1a8284	53 45 43 00			            .null "SEC"
.1a8288					MN_CLI
>1a8288	43 4c 49 00			            .null "CLI"
.1a828c					MN_SEI
>1a828c	53 45 49 00			            .null "SEI"
.1a8290					MN_TYA
>1a8290	54 59 41 00			            .null "TYA"
.1a8294					MN_CLV
>1a8294	43 4c 56 00			            .null "CLV"
.1a8298					MN_CLD
>1a8298	43 4c 44 00			            .null "CLD"
.1a829c					MN_SED
>1a829c	53 45 44 00			            .null "SED"
.1a82a0					MN_TXA
>1a82a0	54 58 41 00			            .null "TXA"
.1a82a4					MN_TXS
>1a82a4	54 58 53 00			            .null "TXS"
.1a82a8					MN_TAX
>1a82a8	54 41 58 00			            .null "TAX"
.1a82ac					MN_TSX
>1a82ac	54 53 58 00			            .null "TSX"
.1a82b0					MN_DEX
>1a82b0	44 45 58 00			            .null "DEX"
.1a82b4					MN_NOP
>1a82b4	4e 4f 50 00			            .null "NOP"
.1a82b8					MN_BPL
>1a82b8	42 50 4c 00			            .null "BPL"
.1a82bc					MN_BMI
>1a82bc	42 4d 49 00			            .null "BMI"
.1a82c0					MN_BVC
>1a82c0	42 56 43 00			            .null "BVC"
.1a82c4					MN_BVS
>1a82c4	42 56 53 00			            .null "BVS"
.1a82c8					MN_BCC
>1a82c8	42 43 43 00			            .null "BCC"
.1a82cc					MN_BCS
>1a82cc	42 43 53 00			            .null "BCS"
.1a82d0					MN_BNE
>1a82d0	42 4e 45 00			            .null "BNE"
.1a82d4					MN_BEQ
>1a82d4	42 45 51 00			            .null "BEQ"
.1a82d8					MN_TSB
>1a82d8	54 53 42 00			            .null "TSB"
.1a82dc					MN_TRB
>1a82dc	54 52 42 00			            .null "TRB"
.1a82e0					MN_STZ
>1a82e0	53 54 5a 00			            .null "STZ"
.1a82e4					MN_BRA
>1a82e4	42 52 41 00			            .null "BRA"
.1a82e8					MN_PHY
>1a82e8	50 48 59 00			            .null "PHY"
.1a82ec					MN_PLY
>1a82ec	50 4c 59 00			            .null "PLY"
.1a82f0					MN_PHX
>1a82f0	50 48 58 00			            .null "PHX"
.1a82f4					MN_PLX
>1a82f4	50 4c 58 00			            .null "PLX"
.1a82f8					MN_PHD
>1a82f8	50 48 44 00			            .null "PHD"
.1a82fc					MN_PLD
>1a82fc	50 4c 44 00			            .null "PLD"
.1a8300					MN_PHK
>1a8300	50 48 4b 00			            .null "PHK"
.1a8304					MN_RTL
>1a8304	52 54 4c 00			            .null "RTL"
.1a8308					MN_PHB
>1a8308	50 48 42 00			            .null "PHB"
.1a830c					MN_PLB
>1a830c	50 4c 42 00			            .null "PLB"
.1a8310					MN_WAI
>1a8310	57 41 49 00			            .null "WAI"
.1a8314					MN_XBA
>1a8314	58 42 41 00			            .null "XBA"
.1a8318					MN_TCS
>1a8318	54 43 53 00			            .null "TCS"
.1a831c					MN_TSC
>1a831c	54 53 43 00			            .null "TSC"
.1a8320					MN_TCD
>1a8320	54 43 44 00			            .null "TCD"
.1a8324					MN_TDC
>1a8324	54 44 43 00			            .null "TDC"
.1a8328					MN_TXY
>1a8328	54 58 59 00			            .null "TXY"
.1a832c					MN_TYX
>1a832c	54 59 58 00			            .null "TYX"
.1a8330					MN_STP
>1a8330	53 54 50 00			            .null "STP"
.1a8334					MN_XCE
>1a8334	58 43 45 00			            .null "XCE"
.1a8338					MN_COP
>1a8338	43 4f 50 00			            .null "COP"
.1a833c					MN_JSL
>1a833c	4a 53 4c 00			            .null "JSL"
.1a8340					MN_WDM
>1a8340	57 44 4d 00			            .null "WDM"
.1a8344					MN_PER
>1a8344	50 45 52 00			            .null "PER"
.1a8348					MN_BRL
>1a8348	42 52 4c 00			            .null "BRL"
.1a834c					MN_REP
>1a834c	52 45 50 00			            .null "REP"
.1a8350					MN_SEP
>1a8350	53 45 50 00			            .null "SEP"
.1a8354					MN_MVP
>1a8354	4d 56 50 00			            .null "MVP"
.1a8358					MN_MVN
>1a8358	4d 56 4e 00			            .null "MVN"
.1a835c					MN_PEI
>1a835c	50 45 49 00			            .null "PEI"
.1a8360					MN_PEA
>1a8360	50 45 41 00			            .null "PEA"
.1a8364					MN_JML
>1a8364	4a 4d 4c 00			            .null "JML"
>1a8368	00 00				            .byte 0, 0
>1a836a	50 82 f8 81 38 83 f8 81		MNEMONIC_TAB    .word <>MN_BRK, <>MN_ORA, <>MN_COP, <>MN_ORA, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 0x
>1a8372	d8 82 f8 81 18 82 f8 81
>1a837a	60 82 f8 81 18 82 f8 82		                .word <>MN_PHP, <>MN_ORA, <>MN_ASL, <>MN_PHD, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>1a8382	d8 82 f8 81 18 82 f8 81
>1a838a	b8 82 f8 81 f8 81 f8 81		                .word <>MN_BPL, <>MN_ORA, <>MN_ORA, <>MN_ORA, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 1x
>1a8392	dc 82 f8 81 18 82 f8 81
>1a839a	80 82 f8 81 34 82 18 83		                .word <>MN_CLC, <>MN_ORA, <>MN_INC, <>MN_TCS, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>1a83a2	dc 82 f8 81 18 82 f8 81
>1a83aa	54 82 fc 81 3c 83 fc 81		                .word <>MN_JSR, <>MN_AND, <>MN_JSL, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 2x
>1a83b2	38 82 fc 81 1c 82 fc 81
>1a83ba	64 82 fc 81 1c 82 fc 82		                .word <>MN_PLP, <>MN_AND, <>MN_ROL, <>MN_PLD, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>1a83c2	38 82 fc 81 1c 82 fc 81
>1a83ca	bc 82 fc 81 fc 81 fc 81		                .word <>MN_BMI, <>MN_AND, <>MN_AND, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 3x
>1a83d2	38 82 fc 81 1c 82 fc 81
>1a83da	84 82 fc 81 30 82 1c 83		                .word <>MN_SEC, <>MN_AND, <>MN_DEC, <>MN_TSC, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>1a83e2	38 82 fc 81 1c 82 fc 81
>1a83ea	58 82 00 82 40 83 00 82		                .word <>MN_RTI, <>MN_EOR, <>MN_WDM, <>MN_EOR, <>MN_MVP, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 4x
>1a83f2	54 83 00 82 20 82 00 82
>1a83fa	68 82 00 82 20 82 00 83		                .word <>MN_PHA, <>MN_EOR, <>MN_LSR, <>MN_PHK, <>MN_JMP, <>MN_EOR, <>MN_LSR, <>MN_EOR
>1a8402	3c 82 00 82 20 82 00 82
>1a840a	c0 82 00 82 00 82 00 82		                .word <>MN_BVC, <>MN_EOR, <>MN_EOR, <>MN_EOR, <>MN_MVN, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 5x
>1a8412	58 83 00 82 20 82 00 82
>1a841a	88 82 00 82 e8 82 20 83		                .word <>MN_CLI, <>MN_EOR, <>MN_PHY, <>MN_TCD, <>MN_JML, <>MN_EOR, <>MN_LSR, <>MN_EOR
>1a8422	64 83 00 82 20 82 00 82
>1a842a	5c 82 04 82 44 83 04 82		                .word <>MN_RTS, <>MN_ADC, <>MN_PER, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 6x
>1a8432	e0 82 04 82 24 82 04 82
>1a843a	6c 82 04 82 24 82 04 83		                .word <>MN_PLA, <>MN_ADC, <>MN_ROR, <>MN_RTL, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>1a8442	3c 82 04 82 24 82 04 82
>1a844a	c4 82 04 82 04 82 04 82		                .word <>MN_BVS, <>MN_ADC, <>MN_ADC, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 7x
>1a8452	e0 82 04 82 24 82 04 82
>1a845a	8c 82 04 82 ec 82 24 83		                .word <>MN_SEI, <>MN_ADC, <>MN_PLY, <>MN_TDC, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>1a8462	3c 82 04 82 24 82 04 82
>1a846a	e4 82 08 82 48 83 08 82		                .word <>MN_BRA, <>MN_STA, <>MN_BRL, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 8x
>1a8472	40 82 08 82 28 82 08 82
>1a847a	70 82 38 82 a0 82 08 83		                .word <>MN_DEY, <>MN_BIT, <>MN_TXA, <>MN_PHB, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA
>1a8482	40 82 08 82 28 82 08 82
>1a848a	c8 82 08 82 08 82 08 82		                .word <>MN_BCC, <>MN_STA, <>MN_STA, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 9x
>1a8492	40 82 08 82 28 82 08 82
>1a849a	90 82 08 82 a4 82 28 83		                .word <>MN_TYA, <>MN_STA, <>MN_TXS, <>MN_TXY, <>MN_STZ, <>MN_STA, <>MN_STZ, <>MN_STA
>1a84a2	e0 82 08 82 e0 82 08 82
>1a84aa	44 82 0c 82 2c 82 0c 82		                .word <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Ax
>1a84b2	44 82 0c 82 2c 82 0c 82
>1a84ba	74 82 0c 82 a8 82 0c 83		                .word <>MN_TAY, <>MN_LDA, <>MN_TAX, <>MN_PLB, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>1a84c2	44 82 0c 82 2c 82 0c 82
>1a84ca	cc 82 0c 82 0c 82 0c 82		                .word <>MN_BCS, <>MN_LDA, <>MN_LDA, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Bx
>1a84d2	44 82 0c 82 2c 82 0c 82
>1a84da	94 82 0c 82 ac 82 2c 83		                .word <>MN_CLV, <>MN_LDA, <>MN_TSX, <>MN_TYX, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>1a84e2	44 82 0c 82 2c 82 0c 82
>1a84ea	48 82 10 82 4c 83 10 82		                .word <>MN_CPY, <>MN_CMP, <>MN_REP, <>MN_CMP, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Cx
>1a84f2	48 82 10 82 30 82 10 82
>1a84fa	78 82 10 82 b0 82 10 83		                .word <>MN_INY, <>MN_CMP, <>MN_DEX, <>MN_WAI, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP
>1a8502	48 82 10 82 30 82 10 82
>1a850a	d0 82 10 82 10 82 10 82		                .word <>MN_BNE, <>MN_CMP, <>MN_CMP, <>MN_CMP, <>MN_PEI, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Dx
>1a8512	5c 83 10 82 30 82 10 82
>1a851a	98 82 10 82 f0 82 30 83		                .word <>MN_CLD, <>MN_CMP, <>MN_PHX, <>MN_STP, <>MN_JML, <>MN_CMP, <>MN_DEC, <>MN_CMP
>1a8522	64 83 10 82 30 82 10 82
>1a852a	4c 82 14 82 50 83 14 82		                .word <>MN_CPX, <>MN_SBC, <>MN_SEP, <>MN_SBC, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Ex
>1a8532	4c 82 14 82 34 82 14 82
>1a853a	7c 82 14 82 b4 82 14 83		                .word <>MN_INX, <>MN_SBC, <>MN_NOP, <>MN_XBA, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC
>1a8542	4c 82 14 82 34 82 14 82
>1a854a	d4 82 14 82 14 82 14 82		                .word <>MN_BEQ, <>MN_SBC, <>MN_SBC, <>MN_SBC, <>MN_PEA, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Fx
>1a8552	60 83 14 82 34 82 14 82
>1a855a	9c 82 14 82 f4 82 34 83		                .word <>MN_SED, <>MN_SBC, <>MN_PLX, <>MN_XCE, <>MN_JSR, <>MN_SBC, <>MN_INC, <>MN_SBC
>1a8562	54 82 14 82 34 82 14 82
>1a856a	00 00				                .word 0
>1a856c	13 00 02 09			ADDRESS_TAB     .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R                  ; 0x
>1a8570	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8574	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a8578	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a857c	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 1x
>1a8580	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8584	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>1a8588	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a858c	03 00 0b 09			                .byte ADDR_ABS, ADDR_DP_IND_X, ADDR_ABS_LONG, ADDR_SP_R                 ; 2x
>1a8590	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8594	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a8598	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a859c	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 3x
>1a85a0	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a85a4	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>1a85a8	07 07 07 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a85ac	13 00 13 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMPLIED, ADDR_SP_R              ; 4x
>1a85b0	14 01 01 0a			                .byte ADDR_XYC, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a85b4	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a85b8	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a85bc	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 5x
>1a85c0	14 05 05 0d			                .byte ADDR_XYC, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a85c4	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a85c8	0b 07 07 0b			                .byte ADDR_ABS_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_LONG
>1a85cc	13 00 16 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R          ; 6x
>1a85d0	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a85d4	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a85d8	15 03 03 0b			                .byte ADDR_ABS_IND, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a85dc	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 7x
>1a85e0	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a85e4	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a85e8	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a85ec	12 00 16 09			                .byte ADDR_PC_REL, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R           ; 8x
>1a85f0	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a85f4	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a85f8	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a85fc	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 9x
>1a8600	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>1a8604	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a8608	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a860c	82 00 42 09			                .byte ADDR_IMM | OP_M_EFFECT, ADDR_DP_IND_X, ADDR_IMM | OP_X_EFFECT, ADDR_SP_R  ; Ax
>1a8610	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8614	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a8618	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a861c	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Bx
>1a8620	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>1a8624	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a8628	07 07 06 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_Y, ADDR_ABS_X_LONG
>1a862c	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Cx
>1a8630	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8634	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a8638	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a863c	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Dx
>1a8640	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8644	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a8648	17 07 07 0e			                .byte ADDR_ABS_IND_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a864c	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Ex
>1a8650	01 01 01 0f			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_IND
>1a8654	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a8658	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a865c	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Fx
>1a8660	03 05 05 0d			                .byte ADDR_ABS, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8664	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a8668	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a866c	01 01 01 02 01 01 02 02		ADDR_LENGTH     .byte 1, 1, 1, 2, 1, 1, 2, 2, 0, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 0, 2, 2, 2, 2
>1a8674	00 01 01 03 01 01 03 01 02 01 01 00 02 02 02 02
.1a8684					ADDR_PATTERNS
>1a8684	41 00				            .null "A"
>1a8686	08				            .byte ADDR_ACC
>1a8687	64 64 3a 64 64 64 64 2c		            .null "dd:dddd,X"
>1a868f	58 00
>1a8691	0e				            .byte ADDR_ABS_X_LONG
>1a8692	64 64 3a 64 64 64 64 00		            .null "dd:dddd"
>1a869a	0b				            .byte ADDR_ABS_LONG
>1a869b	64 64 64 64 2c 58 00		            .null "dddd,X"
>1a86a2	07				            .byte ADDR_ABS_X
>1a86a3	64 64 64 64 2c 59 00		            .null "dddd,Y"
>1a86aa	06				            .byte ADDR_ABS_Y
>1a86ab	64 64 64 64 00			            .null "dddd"
>1a86b0	03				            .byte ADDR_ABS
>1a86b1	64 64 2c 58 00			            .null "dd,X"
>1a86b6	05				            .byte ADDR_DP_X
>1a86b7	64 64 2c 59 00			            .null "dd,Y"
>1a86bc	11				            .byte ADDR_DP_Y
>1a86bd	64 64 2c 53 00			            .null "dd,S"
>1a86c2	09				            .byte ADDR_SP_R
>1a86c3	64 64 00			            .null "dd"
>1a86c6	01				            .byte ADDR_DP
>1a86c7	23 64 64 64 64 00		            .null "#dddd"
>1a86cd	c2				            .byte ADDR_IMM | OP_M_EFFECT | OP_X_EFFECT
>1a86ce	23 64 64 2c 23 64 64 00		            .null "#dd,#dd"
>1a86d6	14				            .byte ADDR_XYC
>1a86d7	23 64 64 00			            .null "#dd"
>1a86db	02				            .byte ADDR_IMM
>1a86dc	28 64 64 2c 53 29 2c 59		            .null "(dd,S),Y"
>1a86e4	00
>1a86e5	0c				            .byte ADDR_SP_R_Y
>1a86e6	28 64 64 64 64 2c 58 29		            .null "(dddd,X)"
>1a86ee	00
>1a86ef	10				            .byte ADDR_ABS_X_ID
>1a86f0	28 64 64 64 64 29 00		            .null "(dddd)"
>1a86f7	10				            .byte ADDR_ABS_X_ID
>1a86f8	28 64 64 2c 58 29 00		            .null "(dd,X)"
>1a86ff	00				            .byte ADDR_DP_IND_X
>1a8700	28 64 64 29 2c 59 00		            .null "(dd),Y"
>1a8707	04				            .byte ADDR_DP_IND_Y
>1a8708	28 64 64 29 00			            .null "(dd)"
>1a870d	0f				            .byte ADDR_DP_IND
>1a870e	5b 64 64 64 64 5d 00		            .null "[dddd]"
>1a8715	17				            .byte ADDR_ABS_IND_LONG
>1a8716	5b 64 64 5d 2c 59 00		            .null "[dd],Y"
>1a871d	0d				            .byte ADDR_DP_Y_LONG
>1a871e	5b 64 64 5d 00			            .null "[dd]"
>1a8723	0a				            .byte ADDR_DP_LONG
>1a8724	00 00				                .byte 0, 0

;******  Return to file: src\monitor.s

.1a8726					M_INC_CURSOR
.1a8726	08		php		                PHP
.1a8727	c2 20		rep #$20	            REP #$20
.1a8729	48		pha		                PHA
.1a872a	18		clc		                CLC
.1a872b	af 7a 08 00	lda $00087a	                LDA MCURSOR
.1a872f	69 01 00	adc #$0001	                ADC #1
.1a8732	8f 7a 08 00	sta $00087a	                STA MCURSOR
.1a8736	e2 20		sep #$20	            SEP #$20
.1a8738	af 7c 08 00	lda $00087c	                LDA MCURSOR+2
.1a873c	69 00		adc #$00	                ADC #0
.1a873e	8f 7c 08 00	sta $00087c	                STA MCURSOR+2
.1a8742	c2 20		rep #$20	            REP #$20
.1a8744	68		pla		                PLA
.1a8745	28		plp		                PLP
.1a8746	6b		rtl		                RTL
.1a8747					MPRINTB
.1a8747	08		php		                PHP
.1a8748	c2 10		rep #$10	            REP #$10
.1a874a	e2 20		sep #$20	            SEP #$20
.1a874c	da		phx		                PHX
.1a874d	a2 08 00	ldx #$0008	                LDX #8          ; Set number of bits to print to 8
.1a8750	0a		asl a		loop            ASL A           ; Shift MSB to C
.1a8751	b0 08		bcs $1a875b	                BCS is_one
.1a8753	48		pha		                PHA             ; Save value to print
.1a8754	a9 30		lda #$30	                LDA #'0'        ; Print '0'
.1a8756	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8759	80 06		bra $1a8761	                BRA continue
.1a875b	48		pha		is_one          PHA             ; Save value to print
.1a875c	a9 31		lda #$31	                LDA #'1'        ; Print '1'
.1a875e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8761	68		pla		continue        PLA
.1a8762	ca		dex		                DEX             ; Count down the bits to shift
.1a8763	d0 eb		bne $1a8750	                BNE loop        ; And try the next one if there is one
.1a8765	fa		plx		                PLX             ; Otherwise, return
.1a8766	28		plp		                PLP
.1a8767	6b		rtl		                RTL
.1a8768					MSKIPWS
.1a8768	08		php		            PHP
.1a8769	c2 20		rep #$20	            REP #$20
.1a876b	48		pha		            PHA
.1a876c	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a876f	5b		tcd		            TCD
.1a8770	68		pla		            PLA
.1a8771	28		plp		            PLP
.1a8772	e2 20		sep #$20	            SEP #$20
.1a8774	a7 32		lda [$087a]	loop            LDA [MCURSOR]       ; Check the current character
.1a8776	f0 0a		beq $1a8782	                BEQ done            ; If NULL, we're done
.1a8778	c9 20		cmp #$20	                CMP #' '            ; Is it a space?
.1a877a	d0 06		bne $1a8782	                BNE done            ; No: we're done
.1a877c	22 26 87 1a	jsl $1a8726	                JSL M_INC_CURSOR    ; Yes, try the next one
.1a8780	80 f2		bra $1a8774	                BRA loop
.1a8782	6b		rtl		done            RTL
.1a8783					MPARSESTR
.1a8783	08		php		                PHP
.1a8784	08		php		            PHP
.1a8785	c2 20		rep #$20	            REP #$20
.1a8787	48		pha		            PHA
.1a8788	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a878b	5b		tcd		            TCD
.1a878c	68		pla		            PLA
.1a878d	28		plp		            PLP
.1a878e	22 26 87 1a	jsl $1a8726	                JSL M_INC_CURSOR                ; Point to the first character of the name
.1a8792	22 68 87 1a	jsl $1a8768	                JSL MSKIPWS                     ; Skip white space
.1a8796	c2 30		rep #$30	            REP #$30
.1a8798	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.1a879a	c2 20		rep #$20	            REP #$20
.1a879c	29 ff 00	and #$00ff	                AND #$00FF
.1a879f	0a		asl a		                ASL A                           ; multiply it by forfour
.1a87a0	0a		asl a		                ASL A
.1a87a1	aa		tax		                TAX                             ; ... to get the index to the argument
.1a87a2	a5 32		lda $087a	                LDA MCURSOR                     ; Set the argument to the address of the first byte
.1a87a4	95 0d		sta $0855,x	                STA MARG1,X
.1a87a6	a5 34		lda $087c	                LDA MCURSOR+2
.1a87a8	95 0f		sta $0857,x	                STA MARG1+2,X
.1a87aa	e2 20		sep #$20	            SEP #$20
.1a87ac	a7 32		lda [$087a]	loop            LDA [MCURSOR]                   ; Scan to the closing double quote
.1a87ae	f0 14		beq $1a87c4	                BEQ done                        ; If NULL... treat it as a closed argument
.1a87b0	c9 22		cmp #$22	                CMP #CHAR_DQUOTE
.1a87b2	f0 06		beq $1a87ba	                BEQ close_string
.1a87b4	22 26 87 1a	jsl $1a8726	                JSL M_INC_CURSOR
.1a87b8	80 f2		bra $1a87ac	                BRA loop
.1a87ba	a9 00		lda #$00	close_string    LDA #0                          ; Write a NULL to close the string
.1a87bc	87 32		sta [$087a]	                STA [MCURSOR]
.1a87be	22 26 87 1a	jsl $1a8726	                JSL M_INC_CURSOR                ; And point to the next byte
.1a87c2	e6 31		inc $0879	                INC MARG_LEN
.1a87c4	28		plp		done            PLP
.1a87c5	6b		rtl		                RTL
.1a87c6					MPARSEARG
.1a87c6	08		php		            PHP
.1a87c7	c2 20		rep #$20	            REP #$20
.1a87c9	48		pha		            PHA
.1a87ca	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a87cd	5b		tcd		            TCD
.1a87ce	68		pla		            PLA
.1a87cf	28		plp		            PLP
.1a87d0	e2 20		sep #$20	            SEP #$20
.1a87d2	64 4a		stz $0892	                STZ MTEMP                       ; Use MTEMP as a flag for having processed digits
.1a87d4	c2 20		rep #$20	            REP #$20
.1a87d6	64 50		stz $0898	                STZ MPARSEDNUM                  ; Clear the parsed number
.1a87d8	64 52		stz $089a	                STZ MPARSEDNUM+2
.1a87da					pa_loop
.1a87da	e2 20		sep #$20	            SEP #$20
.1a87dc	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Get the current character
.1a87de	c9 3a		cmp #$3a	                CMP #":"
.1a87e0	f0 0d		beq $1a87ef	                BEQ pa_next_char                ; Ignore any colons
.1a87e2	20 0c 05	jsr $1a050c	            JSR ISHEX
.1a87e5	90 0e		bcc $1a87f5	                BCC finished_arg                ; No? We're done with this argument
.1a87e7	22 5e 7c 1a	jsl $1a7c5e	                JSL AS_SHIFT_HEX                ; Yes: shift it onto MPARSEDNUM
.1a87eb	a9 01		lda #$01	                LDA #1                          ; Flag that we've processed a character
.1a87ed	85 4a		sta $0892	                STA MTEMP
.1a87ef	22 26 87 1a	jsl $1a8726	pa_next_char    JSL M_INC_CURSOR                ; And try the next character
.1a87f3	80 e5		bra $1a87da	                BRA pa_loop
.1a87f5	a5 4a		lda $0892	finished_arg    LDA MTEMP                       ; Check to see if we've processed any characters
.1a87f7	f0 16		beq $1a880f	                BEQ done                        ; No: we're done
.1a87f9	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.1a87fb	c2 20		rep #$20	            REP #$20
.1a87fd	29 ff 00	and #$00ff	                AND #$00FF
.1a8800	0a		asl a		                ASL A                           ; multiply it by forfour
.1a8801	0a		asl a		                ASL A
.1a8802	aa		tax		                TAX                             ; ... to get the index to the argument
.1a8803	a5 50		lda $0898	                LDA MPARSEDNUM                  ; Copy the value to the argument slot
.1a8805	95 0d		sta $0855,x	                STA MARG1,X
.1a8807	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a8809	95 0f		sta $0857,x	                STA MARG1+2,X
.1a880b	e2 20		sep #$20	            SEP #$20
.1a880d	e6 31		inc $0879	                INC MARG_LEN                    ; And bump up the argument count
.1a880f	6b		rtl		done            RTL
.1a8810					MPARSEALLARG
.1a8810	e2 20		sep #$20	            SEP #$20
.1a8812	64 31		stz $0879	                STZ MARG_LEN                    ; Set the arg count to 0
.1a8814	22 68 87 1a	jsl $1a8768	parse_arg       JSL MSKIPWS                     ; Otherwise, skip white space
.1a8818	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Check the current character
.1a881a	f0 21		beq $1a883d	                BEQ done                        ; If it is NULL, we're done
.1a881c	c9 22		cmp #$22	                CMP #CHAR_DQUOTE                ; Is it a double-quote?
.1a881e	d0 06		bne $1a8826	                BNE regular_arg
.1a8820	22 83 87 1a	jsl $1a8783	                JSL MPARSESTR                   ; Yes: parse it as a string argument
.1a8824	80 0a		bra $1a8830	                BRA check_rest
.1a8826	22 c6 87 1a	jsl $1a87c6	regular_arg     JSL MPARSEARG                   ; Attempt to parse the argument
.1a882a	a5 31		lda $0879	                LDA MARG_LEN                    ; Check how many arguments we've processed
.1a882c	c9 09		cmp #$09	                CMP #9
.1a882e	b0 0d		bcs $1a883d	                BGE done                        ; If >=9, then we're done
.1a8830	a7 32		lda [$087a]	check_rest      LDA [MCURSOR]                   ; Check the current character
.1a8832	f0 09		beq $1a883d	                BEQ done                        ; If EOL: we're done
.1a8834	c9 20		cmp #$20	                CMP #' '
.1a8836	f0 dc		beq $1a8814	                BEQ parse_arg                   ; If space: try to process another argument
.1a8838	20 0c 05	jsr $1a050c	            JSR ISHEX
.1a883b	b0 d7		bcs $1a8814	                BCS parse_arg                   ; If hex digit: try to process another argument
.1a883d	6b		rtl		done            RTL
.1a883e					IMPARSE
.1a883e	08		php		                PHP
.1a883f	0b		phd		                PHD
.1a8840	08		php		            PHP
.1a8841	c2 20		rep #$20	            REP #$20
.1a8843	48		pha		            PHA
.1a8844	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a8847	5b		tcd		            TCD
.1a8848	68		pla		            PLA
.1a8849	28		plp		            PLP
.1a884a	c2 10		rep #$10	            REP #$10
.1a884c	e2 20		sep #$20	            SEP #$20
.1a884e	a2 31 00	ldx #$0031	                LDX #MARG_LEN - MONITOR_VARS    ; Clear the monitor command line parameters
.1a8851	74 00		stz $0848,x	clear_command   STZ MONITOR_VARS,X
.1a8853	ca		dex		                DEX
.1a8854	d0 fb		bne $1a8851	                BNE clear_command
.1a8856	a9 00		lda #$00	                LDA #`INPUTBUF                  ; Point the command parser to the input buffer
.1a8858	85 02		sta $084a	                STA MCMDADDR+2
.1a885a	85 34		sta $087c	                STA MCURSOR+2                   ; And point MCURSOR there too
.1a885c	c2 20		rep #$20	            REP #$20
.1a885e	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF
.1a8861	85 00		sta $0848	                STA MCMDADDR
.1a8863	85 32		sta $087a	                STA MCURSOR
.1a8865	e2 20		sep #$20	            SEP #$20
.1a8867	22 68 87 1a	jsl $1a8768	                JSL MSKIPWS                     ; Skip to the first letter of the command
.1a886b	c9 00		cmp #$00	                CMP #0                          ; Is the current character a NULL?
.1a886d	f0 38		beq $1a88a7	                BEQ done                        ; Yes: there's no command here
.1a886f	c2 20		rep #$20	            REP #$20
.1a8871	a5 32		lda $087a	                LDA MCURSOR
.1a8873	85 08		sta $0850	                STA MCMD
.1a8875	e2 20		sep #$20	            SEP #$20
.1a8877	a5 34		lda $087c	                LDA MCURSOR+2
.1a8879	85 0a		sta $0852	                STA MCMD+2
.1a887b	a2 01 00	ldx #$0001	                LDX #1
.1a887e	22 26 87 1a	jsl $1a8726	cmd_loop        JSL M_INC_CURSOR                ; Move to the next character
.1a8882	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; What is that character?
.1a8884	d0 06		bne $1a888c	                BNE cmd_space                   ; If not NULL: check for a space
.1a8886	86 0b		stx $0853	no_arguments    STX MCMD_LEN                    ; If NULL: Save the length of the command
.1a8888	64 31		stz $0879	                STZ MARG_LEN                    ; ... And the fact there are no arguments
.1a888a	80 1b		bra $1a88a7	                BRA done                        ; ... And return
.1a888c	c9 20		cmp #$20	cmd_space       CMP #' '                        ; Is it a space?
.1a888e	f0 03		beq $1a8893	                BEQ found_cmd                   ; Yes: save the length
.1a8890	e8		inx		                INX                             ; No: go to the next character
.1a8891	80 eb		bra $1a887e	                BRA cmd_loop
.1a8893	86 0b		stx $0853	found_cmd       STX MCMD_LEN                    ; Save the length of the command
.1a8895	a9 00		lda #$00	                LDA #0
.1a8897	87 32		sta [$087a]	                STA [MCURSOR]                   ; Write a NULL to the end of the command
.1a8899	22 26 87 1a	jsl $1a8726	                JSL M_INC_CURSOR                ; And skip to the next character
.1a889d	a7 08		lda [$0850]	                LDA [MCMD]                      ; Check the command
.1a889f	c9 41		cmp #$41	                CMP #'A'
.1a88a1	f0 07		beq $1a88aa	                BEQ parse_asm                   ; If 'A', parse the line for the assemble command
.1a88a3	22 10 88 1a	jsl $1a8810	                JSL MPARSEALLARG
.1a88a7	2b		pld		done            PLD
.1a88a8	28		plp		                PLP
.1a88a9	6b		rtl		                RTL
.1a88aa	22 68 87 1a	jsl $1a8768	parse_asm       JSL MSKIPWS                     ; Skip to the first letter of the address
.1a88ae	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a88b0	f0 f5		beq $1a88a7	                BEQ done                        ; Exit if we got the end-of-line
.1a88b2	22 c6 87 1a	jsl $1a87c6	                JSL MPARSEARG                   ; Parse the first argument as the target address
.1a88b6	22 68 87 1a	jsl $1a8768	                JSL MSKIPWS                     ; Skip to the first letter of the mnemonic
.1a88ba	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a88bc	f0 e9		beq $1a88a7	                BEQ done                        ; Exit if we got the end-of-line
.1a88be	c2 20		rep #$20	            REP #$20
.1a88c0	a5 32		lda $087a	                LDA MCURSOR                     ; Save pointer to the start of the mnemonic
.1a88c2	85 11		sta $0859	                STA MARG2
.1a88c4	e2 20		sep #$20	            SEP #$20
.1a88c6	a5 34		lda $087c	                LDA MCURSOR+2
.1a88c8	85 13		sta $085b	                STA MARG2+2
.1a88ca	22 26 87 1a	jsl $1a8726	asm_find_sp     JSL M_INC_CURSOR                ; Find the space at the end of the mnemonic
.1a88ce	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a88d0	f0 26		beq $1a88f8	                BEQ asm_no_operand              ; If EOL: we have an instruction but no operand
.1a88d2	c9 20		cmp #$20	                CMP #' '
.1a88d4	d0 f4		bne $1a88ca	                BNE asm_find_sp
.1a88d6	a9 00		lda #$00	                LDA #0
.1a88d8	87 32		sta [$087a]	                STA [MCURSOR]                   ; Null terminate the mnemonic
.1a88da	e6 31		inc $0879	                INC MARG_LEN                    ; Count the mnemonic as an argument
.1a88dc	22 26 87 1a	jsl $1a8726	                JSL M_INC_CURSOR
.1a88e0	22 68 87 1a	jsl $1a8768	                JSL MSKIPWS                     ; Skip to the addressing mode
.1a88e4	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a88e6	f0 bf		beq $1a88a7	                BEQ done                        ; If EOL: we're done
.1a88e8	c2 20		rep #$20	            REP #$20
.1a88ea	a5 32		lda $087a	                LDA MCURSOR                     ; Set the pointer to the addressing mode
.1a88ec	85 15		sta $085d	                STA MARG3
.1a88ee	e2 20		sep #$20	            SEP #$20
.1a88f0	a5 34		lda $087c	                LDA MCURSOR+2
.1a88f2	85 17		sta $085f	                STA MARG3+2
.1a88f4	e6 31		inc $0879	                INC MARG_LEN                    ; And count it as the second argument
.1a88f6	80 af		bra $1a88a7	                BRA done                        ; and return
.1a88f8	e6 31		inc $0879	asm_no_operand  INC MARG_LEN                    ; Increment the argument count
.1a88fa	80 ab		bra $1a88a7	                BRA done                        ; And quit
.1a88fc					IMLOAD
.1a88fc	08		php		                PHP
.1a88fd	c2 10		rep #$10	            REP #$10
.1a88ff	e2 20		sep #$20	            SEP #$20
.1a8901	a5 31		lda $0879	                LDA MARG_LEN
.1a8903	d0 0f		bne $1a8914	                BNE get_arguments
.1a8905	a2 f2 89	ldx #$89f2	bad_arguments   LDX #<>MERRARGS                 ; Print bad arguments error
.1a8908	a9 1a		lda #$1a	                LDA #`MERRARGS
.1a890a	48		pha		                PHA
.1a890b	ab		plb		                PLB
.1a890c	20 64 04	jsr $1a0464	            JSR PRINTS
.1a890f	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a8912	80 61		bra $1a8975	                BRA done
.1a8914					get_arguments
.1a8914	c2 20		rep #$20	            REP #$20
.1a8916	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.1a8918	8f 23 08 00	sta $000823	                STA ARGUMENT1
.1a891c	a5 0f		lda $0857	                LDA MARG1+2
.1a891e	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.1a8922	20 e5 6a	jsr $1a6ae5	            JSR SETFILEDESC
.1a8925	e2 20		sep #$20	            SEP #$20
.1a8927	a5 31		lda $0879	                LDA MARG_LEN
.1a8929	c9 01		cmp #$01	                CMP #1
.1a892b	d0 0f		bne $1a893c	                BNE get_dest
.1a892d	c2 20		rep #$20	            REP #$20
.1a892f	a9 ff ff	lda #$ffff	                LDA #$FFFF                      ; Destination address not provided...
.1a8932	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR              ; ... set it to something sane
.1a8936	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a893a	80 0e		bra $1a894a	                BRA try_load
.1a893c					get_dest
.1a893c	c2 20		rep #$20	            REP #$20
.1a893e	a5 11		lda $0859	                LDA MARG2                       ; Set the destination address from the arguments
.1a8940	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a8944	a5 13		lda $085b	                LDA MARG2+2
.1a8946	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a894a	22 18 11 00	jsl $001118	try_load        JSL FK_LOAD                     ; Try to load the file
.1a894e	b0 25		bcs $1a8975	                BCS done
.1a8950					error
.1a8950	e2 20		sep #$20	            SEP #$20
.1a8952	a2 18 8a	ldx #$8a18	                LDX #<>MCANTLOAD                ; Print bad arguments error
.1a8955	a9 1a		lda #$1a	                LDA #`MCANTLOAD
.1a8957	48		pha		                PHA
.1a8958	ab		plb		                PLB
.1a8959	20 64 04	jsr $1a0464	            JSR PRINTS
.1a895c	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.1a8960	20 8e 04	jsr $1a048e	            JSR PRHEXB
.1a8963	a9 20		lda #$20	                LDA #' '
.1a8965	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8968	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.1a896c	20 8e 04	jsr $1a048e	            JSR PRHEXB
.1a896f	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a8972	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a8975	28		plp		done            PLP
.1a8976	6b		rtl		                RTL
.1a8977					IMSAVE
.1a8977	8b		phb		                PHB
.1a8978	08		php		                PHP
.1a8979	c2 10		rep #$10	            REP #$10
.1a897b	e2 20		sep #$20	            SEP #$20
.1a897d	a5 31		lda $0879	                LDA MARG_LEN
.1a897f	c9 03		cmp #$03	                CMP #3
.1a8981	f0 0f		beq $1a8992	                BEQ get_arguments
.1a8983	a2 f2 89	ldx #$89f2	                LDX #<>MERRARGS                 ; Print bad arguments error
.1a8986	a9 1a		lda #$1a	                LDA #`MERRARGS
.1a8988	48		pha		                PHA
.1a8989	ab		plb		                PLB
.1a898a	20 64 04	jsr $1a0464	            JSR PRINTS
.1a898d	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a8990	80 54		bra $1a89e6	                BRA done
.1a8992					get_arguments
.1a8992	c2 20		rep #$20	            REP #$20
.1a8994	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.1a8996	8f 23 08 00	sta $000823	                STA ARGUMENT1
.1a899a	a5 0f		lda $0857	                LDA MARG1+2
.1a899c	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.1a89a0	20 e5 6a	jsr $1a6ae5	            JSR SETFILEDESC
.1a89a3	a5 11		lda $0859	                LDA MARG2                       ; Set the starting address
.1a89a5	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.1a89a9	a5 13		lda $085b	                LDA MARG2+2
.1a89ab	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.1a89af	a5 15		lda $085d	                LDA MARG3                       ; Set the ending address
.1a89b1	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.1a89b5	a5 17		lda $085f	                LDA MARG3+2
.1a89b7	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.1a89bb	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                     ; Save the data
.1a89bf	b0 25		bcs $1a89e6	                BCS done
.1a89c1					error
.1a89c1	e2 20		sep #$20	            SEP #$20
.1a89c3	a2 02 8a	ldx #$8a02	                LDX #<>MCANTSAVE                ; Print bad arguments error
.1a89c6	a9 1a		lda #$1a	                LDA #`MCANTSAVE
.1a89c8	48		pha		                PHA
.1a89c9	ab		plb		                PLB
.1a89ca	20 64 04	jsr $1a0464	            JSR PRINTS
.1a89cd	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.1a89d1	20 8e 04	jsr $1a048e	            JSR PRHEXB
.1a89d4	a9 20		lda #$20	                LDA #' '
.1a89d6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a89d9	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.1a89dd	20 8e 04	jsr $1a048e	            JSR PRHEXB
.1a89e0	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a89e3	20 d7 03	jsr $1a03d7	            JSR PRINTCR
.1a89e6	28		plp		done            PLP
.1a89e7	ab		plb		                PLB
.1a89e8	6b		rtl		                RTL
.1a89e9	5c c0 27 1a	jmp $1a27c0	IMEXIT          JML INTERACT
.1a89ed	6b		rtl		IMRETURN        RTL ; Handle RETURN key (ie: execute command)
.1a89ee	00		brk #		IMPARSE1        BRK ; Parse one word on the current command line
.1a89ef	00		brk #		IMASSEMBLEA     BRK ; Assemble a line of text.
.1a89f0	00		brk #		IMVERIFY        BRK ; Verify memory and file on disk
.1a89f1	00		brk #		IMDOS           BRK ; Execute DOS command
.1a89f2					MMESSAGES
>1a89f2	42 61 64 20 61 72 67 75		MERRARGS        .null "Bad arguments",CHAR_CR,CHAR_CR
>1a89fa	6d 65 6e 74 73 0d 0d 00
>1a8a02	55 6e 61 62 6c 65 20 74		MCANTSAVE       .null "Unable to save file: "
>1a8a0a	6f 20 73 61 76 65 20 66 69 6c 65 3a 20 00
>1a8a18	55 6e 61 62 6c 65 20 74		MCANTLOAD       .null "Unable to load file: "
>1a8a20	6f 20 6c 6f 61 64 20 66 69 6c 65 3a 20 00
>1a8a2e	0d 20 20 50 43 20 20 20		mregisters_msg  .null $0D,"  PC     A    X    Y    SP   DBR DP   NVMXDIZC",CHAR_CR
>1a8a36	20 20 41 20 20 20 20 58 20 20 20 20 59 20 20 20
>1a8a46	20 53 50 20 20 20 44 42 52 20 44 50 20 20 20 4e
>1a8a56	56 4d 58 44 49 5a 43 0d 00
>1a8a5f	41 43 44 46 47 4a 48 4c		MCOMMANDS       .null "ACDFGJHLMR;STVWX>?"
>1a8a67	4d 52 3b 53 54 56 57 58 3e 3f 00

;******  Return to file: src\basic816.s

.1a8a72	18		clc		START       CLC                 ; Go to native mode
.1a8a73	fb		xce		            XCE
.1a8a74	08		php		            PHP
.1a8a75	c2 20		rep #$20	            REP #$20
.1a8a77	48		pha		            PHA
.1a8a78	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a8a7b	5b		tcd		            TCD
.1a8a7c	68		pla		            PLA
.1a8a7d	28		plp		            PLP
.1a8a7e	08		php		            PHP
.1a8a7f	e2 20		sep #$20	            SEP #$20
.1a8a81	48		pha		            PHA
.1a8a82	a9 00		lda #$00	            LDA #BASIC_BANK
.1a8a84	48		pha		            PHA
.1a8a85	ab		plb		            PLB
.1a8a86	68		pla		            PLA
.1a8a87	28		plp		            PLP
.1a8a88	c2 30		rep #$30	            REP #$30
.1a8a8a	20 b1 8a	jsr $1a8ab1	            JSR INITBASIC
.1a8a8d	a9 ff fe	lda #$feff	            LDA #STACK_END      ; Set the system stack
.1a8a90	1b		tcs		            TCS
.1a8a91	08		php		            PHP
.1a8a92	e2 20		sep #$20	            SEP #$20
.1a8a94	48		pha		            PHA
.1a8a95	a9 1a		lda #$1a	            LDA #`GREET
.1a8a97	48		pha		            PHA
.1a8a98	ab		plb		            PLB
.1a8a99	68		pla		            PLA
.1a8a9a	28		plp		            PLP
.1a8a9b	a2 77 d2	ldx #$d277	            LDX #<>GREET
.1a8a9e	20 64 04	jsr $1a0464	            JSR PRINTS
.1a8aa1	08		php		            PHP
.1a8aa2	e2 20		sep #$20	            SEP #$20
.1a8aa4	48		pha		            PHA
.1a8aa5	a9 00		lda #$00	            LDA #BASIC_BANK
.1a8aa7	48		pha		            PHA
.1a8aa8	ab		plb		            PLB
.1a8aa9	68		pla		            PLA
.1a8aaa	28		plp		            PLP
.1a8aab	4c c0 27	jmp $1a27c0	            JMP INTERACT        ; Start accepting input from the user
.1a8aae	4c ae 8a	jmp $1a8aae	WAIT        JMP WAIT
.1a8ab1					INITBASIC
.1a8ab1	08		php		            PHP
.1a8ab2	20 34 03	jsr $1a0334	            JSR INITIO
.1a8ab5	20 54 50	jsr $1a5054	            JSR CMD_NEW
.1a8ab8	28		plp		            PLP
.1a8ab9	60		rts		            RTS
>1ad277	43 32 35 36 20 46 6f 65		GREET       .text "C256 Foenix BASIC816 "
>1ad27f	6e 69 78 20 42 41 53 49 43 38 31 36 20

;******  Processing file: src\version.s

>1ad28c	76 30 2e 32 2e 30 2d 61		.text "v0.2.0-alpha+408"
>1ad294	6c 70 68 61 2b 34 30 38

;******  Return to file: src\basic816.s

>1ad29c	0d 00				            .byte 13,0

;******  End of listing
