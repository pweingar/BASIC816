
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -D SYSTEM=2 -D C256_SKU=2 -D UARTSUPPORT= -D UNITTEST=0 -D TRACE_LEVEL=0 --long-address --flat -b --m65816 --intel-hex -o basic816_1A0000.hex --list=basic816_1A0000.lst --labels=basic816_1A0000.lbl src\basic816.s
; Thu May 13 19:27:50 2021

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=2					SYSTEM=2
=2					C256_SKU=2
=					UARTSUPPORT=
=0					UNITTEST=0
=0					TRACE_LEVEL=0

;******  Processing input file: src\basic816.s


;******  Processing file: src\constants.s

=2					SYSTEM_C256 = 2         ; C256 Foenix
=1					SYSTEM_C64 = 1          ; Commodore 64 with SuperCPU
=$03					CHAR_CTRL_C = $03       ; CTRL-C: used as a program interrupt key
=$07					CHAR_BELL = $07         ; Ring the console bell
=$08					CHAR_BS = $08           ; Backspace
=$09					CHAR_TAB = $09          ; TAB
=$0a					CHAR_LF = $0A           ; Linefeed
=$0d					CHAR_CR = $0D           ; Carriage Return
=$0f					CHAR_INS = $0F          ; Insert
=$1b					CHAR_ESC = $1B          ; Escape
=$22					CHAR_DQUOTE = $22       ; Double quote
=$20					CHAR_SP = $20           ; Space
=$7f					CHAR_DEL = $7F          ; Delete
=5					ARGUMENT_SIZE = 5       ; Number of bytes in an argument
=8					VAR_NAME_SIZE = 8       ; Maximum number of characters in a variable name
=0					TYPE_INTEGER = 0        ; 32-bit integer
=1					TYPE_FLOAT = 1          ; Single-precision floating point
=2					TYPE_STRING = 2         ; ASCII string
=$80					TYPE_ARR_INTEGER = $80  ; Array of 32-bit integers
=$81					TYPE_ARR_FLOAT = $81    ; Array of 32-bit floats
=$82					TYPE_ARR_STRING = $82   ; Array of strings
=$7f					TYPE_BINDING = $7F      ; A variable name binding
=$ff					TYPE_NAV = $FF          ; Not-A-Value
=0					ERR_OK = 0              ; No error
=1					ERR_BREAK = 1           ; The user pressed an interrupt key
=2					ERR_SYNTAX = 2          ; A syntax error was found on the current line
=3					ERR_MEMORY = 3          ; Out of memory
=4					ERR_TYPE = 4            ; Type mismatch error
=5					ERR_NOTFOUND = 5        ; Variable not found error
=6					ERR_NOLINE = 6          ; Line number not found
=7					ERR_STACKUNDER = 7      ; Stack underflow error
=8					ERR_STACKOVER = 8       ; Stack overflow error
=9					ERR_RANGE = 9           ; Out-of-range error
=10					ERR_ARGUMENT = 10       ; Bad argument error
=11					ERR_NOFILE = 11         ; File not found error
=12					ERR_NAN = 12            ; Floating point math resulted in something that is not a number
=13					ERR_OVERFLOW = 13       ; Math operation overflowed
=14					ERR_UNDERFLOW = 14      ; Math operation underflowed
=15					ERR_DIV0 = 15           ; Math operation involved a division by zero
=16					ERR_DIRECTORY = 16      ; Error reading the directory
=17					ERR_LOAD = 17           ; Could not load file
=18					ERR_SAVE = 18           ; Could not save a file
=19					ERR_DELETE = 19         ; Could not delete a file
=20					ERR_FILENOTFOUND = 20   ; Could not find the file
=21					ERR_DIRNOTWRITE = 21    ; Could not update the directory entry
=22					ERR_NOTCOPIED = 22      ; Could not copy the file
=23					ERR_DOMAIN = 23         ; Mathematical functions domain error

;******  Return to file: src\basic816.s


;******  Processing file: src\memorymap.s


;******  Processing file: src\C256/mmap_c256.s

=1					SYS_C256_FMX = 1        ; System SKU for C256 Foenix FMX
=2					SYS_C256_USER = 2       ; System SKU for C256 Foenix User

;******  Processing file: src\C256/page_00_inc.s

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				unused_0000      = $000000 ;12 Bytes unused
=$000008				OPL2_ADDY_PTR_LO = $000008  ; THis Points towards the Instruments Database
=$000009				OPL2_ADDY_PTR_MD = $000009
=$00000a				OPL2_ADDY_PTR_HI = $00000A
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;1 Byte Color of next character to be printed to the screen.
=$00001f				COLORPOS         = $00001F ;3 Byte address of cursor's position in the color matrix
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$000026				OPL2_OPERATOR    = $000026 ;
=$000027				OPL2_CHANNEL     = $000027 ;
=$000028				OPL2_REG_REGION  = $000028 ; Offset to the Group of Registers
=$00002a				OPL2_REG_OFFSET  = $00002A ; 2 Bytes (16Bits)
=$00002c				OPL2_IND_ADDY_LL = $00002C ; 2 Bytes Reserved (Only need 3)
=$00002e				OPL2_IND_ADDY_HL = $00002E ; 2 Bytes Reserved (Only need 3)
=$000030				OPL2_NOTE        = $000030 ; 1 Byte
=$000031				OPL2_OCTAVE      = $000031 ; 1 Byte
=$000032				OPL2_PARAMETER0  = $000032 ; 1 Byte - Key On/Feedback
=$000033				OPL2_PARAMETER1  = $000033 ; 1 Byte
=$000034				OPL2_PARAMETER2  = $000034 ; 1 Byte
=$000035				OPL2_PARAMETER3  = $000035 ; 1 Byte
=$000036				OPL2_LOOP        = $000036 ;
=$000036				OPL2_BLOCK       = $000036
=$000038				SDCARD_FILE_PTR  = $000038 ; 3 Bytes Pointer to Filename to open
=$00003c				SDCARD_BYTE_NUM  = $00003C ; 2Bytes
=$00003f				SDCARD_PRSNT_MNT = $00003F ; 1 Byte, Indicate that the SDCard is Present and that it is Mounted
=$000040				BM_CLEAR_SCRN_X  = $000040
=$000042				BM_CLEAR_SCRN_Y  = $000042
=$000040				RAD_STARTLINE    = $000040 ; 1 Byte
=$000041				RAD_PATTERN_IDX  = $000041 ; 1 Byte
=$000042				RAD_LINE         = $000042 ; 1 Byte
=$000043				RAD_LINENUMBER   = $000043 ; 1 Byte
=$000044				RAD_CHANNEL_NUM  = $000044 ; 1 Byte
=$000045				RAD_ISLASTCHAN   = $000045 ; 1 Byte
=$000046				RAD_Y_POINTER    = $000046 ; 2 Bytes
=$000048				RAD_TICK         = $000048
=$00004a				RAD_CHANNEL_DATA = $00004A ; 2 Bytes
=$00004c				RAD_CHANNE_EFFCT = $00004C
=$00004d				RAD_TEMP         = $00004D
=$000050				RAD_ADDR         = $000050 ; 3 bytes to avoid OPL2 errors.
=$000053				RAD_PATTRN       = $000053 ; 1 bytes - offset to patter
=$000054				RAD_PTN_DEST     = $000054 ; 3 bytes - where to write the pattern data
=$000057				RAD_CHANNEL      = $000057 ; 2 bytes - 0 to 8
=$000059				RAD_LAST_NOTE    = $000059 ; 1 if this is the last note
=$00005a				RAD_LINE_PTR     = $00005A ; 2 bytes - offset to memory location
=$000040				BMP_X_SIZE       = $000040 ; 2 Bytes
=$000042				BMP_Y_SIZE       = $000042 ; 2 Bytes
=$000044				BMP_PRSE_SRC_PTR = $000044 ; 3 Bytes
=$000048				BMP_PRSE_DST_PTR = $000048 ; 3 Bytes
=$00004c				BMP_COLOR_PALET  = $00004C ; 2 Bytes
=$00004e				SCRN_X_STRIDE    = $00004E ; 2 Bytes, Basically How many Pixel Accross in Bitmap Mode
=$000050				BMP_FILE_SIZE    = $000050 ; 4 Bytes
=$000054				BMP_POSITION_X   = $000054 ; 2 Bytes Where, the BMP will be position on the X Axis
=$000056				BMP_POSITION_Y   = $000056 ; 2 Bytes Where, the BMP will be position on the Y Axis
=$000058				BMP_PALET_CHOICE = $000058 ;
=$0000e0				MOUSE_PTR        = $0000E0
=$0000e1				MOUSE_POS_X_LO   = $0000E1
=$0000e2				MOUSE_POS_X_HI   = $0000E2
=$0000e3				MOUSE_POS_Y_LO   = $0000E3
=$0000e4				MOUSE_POS_Y_HI   = $0000E4
=$0000f0				USER_TEMP        = $0000F0 ;32 Bytes Temp space for user programs
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000110				DIVIDER_0        = $000110 ;0 Byte  Unsigned divider
=$000110				D0_OPERAND_A     = $000110 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$000112				D0_OPERAND_B     = $000112 ;2 Bytes Divider 0 Divisor ex B in A/B
=$000114				D0_RESULT        = $000114 ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D0_REMAINDER     = $000116 ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000118				DIVIDER_1        = $000118 ;0 Byte  Signed divider
=$000118				D1_OPERAND_A     = $000118 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$00011a				D1_OPERAND_B     = $00011A ;2 Bytes Divider 1 Divisor ex B in A/B
=$00011c				D1_RESULT        = $00011C ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$00011e				D1_REMAINDER     = $00011E ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$000120				ADDER_SIGNED_32  = $000120 ; The 32 Bit Adders takes 12Byte that are NOT RAM Location
=$000140				INT_CONTROLLER   = $000140 ; $000140...$00015F Interrupt Controller
=$000160				TIMER_CONTROLLER = $000160 ; $000160...$00017F Timer0/Timer1/Timer2 Block
=$000160				TIMER_CTRL_REGLL = $000160 ;
=$000161				TIMER_CTRL_REGLH = $000161 ;
=$000162				TIMER_CTRL_REGHL = $000162 ;
=$000163				TIMER_CTRL_REGHH = $000163 ;
=$000240				CPU_REGISTERS    = $000240 ; Byte
=$000240				CPUPC            = $000240 ;2 Bytes Program Counter (PC)
=$000242				CPUPBR           = $000242 ;2 Bytes Program Bank Register (K)
=$000244				CPUA             = $000244 ;2 Bytes Accumulator (A)
=$000246				CPUX             = $000246 ;2 Bytes X Register (X)
=$000248				CPUY             = $000248 ;2 Bytes Y Register (Y)
=$00024a				CPUSTACK         = $00024A ;2 Bytes Stack Pointer (S)
=$00024c				CPUDP            = $00024C ;2 Bytes Direct Page Register (D)
=$00024e				CPUDBR           = $00024E ;1 Byte  Data Bank Register (B)
=$00024f				CPUFLAGS         = $00024F ;1 Byte  Flags (P)
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$000300				FDC_DRIVE        = $000300 ;1 byte - The number of the selected drive
=$000301				FDC_HEAD         = $000301 ;1 byte - The head number (0 or 1)
=$000302				FDC_CYLINDER     = $000302 ;1 byte - The cylinder number
=$000303				FDC_SECTOR       = $000303 ;1 byte - The sector number
=$000304				FDC_SECTOR_SIZE  = $000304 ;1 byte - The sector size code (2 = 512)
=$000305				FDC_SECPERTRK    = $000305 ;1 byte - The number of sectors per track (18 for 1.44 MB floppy)
=$000306				FDC_ST0          = $000306 ;1 byte - Status Register 0
=$000307				FDC_ST1          = $000307 ;1 byte - Status Register 1
=$000308				FDC_ST2          = $000308 ;1 byte - Status Register 2
=$000309				FDC_ST3          = $000309 ;1 byte - Status Register 3
=$00030a				FDC_PCN          = $00030A ;1 byte - Present Cylinder Number
=$00030b				FDC_STATUS       = $00030B ;1 byte - Status of what we think is going on with the FDC:
=$00030c				DIVIDEND         = $00030C ;4 bytes - Dividend for 32-bit division
=$000310				DIVISOR          = $000310 ;4 bytes - Divisor for 32-bit division
=$000314				REMAINDER        = $000314 ;4 bytes - Remainder for 32-bit division
=$000320				SDOS_VARIABLES   = $000320
=$000320				BIOS_STATUS      = $000320      ; 1 byte - Status of any BIOS operation
=$000321				BIOS_DEV         = $000321      ; 1 byte - Block device number for block operations
=$000322				BIOS_LBA         = $000322      ; 4 bytes - Address of block to read/write (this is the physical block, w/o reference to partition)
=$000326				BIOS_BUFF_PTR    = $000326      ; 4 bytes - 24-bit pointer to memory for read/write operations
=$00032a				BIOS_FIFO_COUNT  = $00032A      ; 2 bytes - The number of bytes read on the last block read
=$00032e				DOS_STATUS       = $00032E      ; 1 byte - The error code describing any error with file access
=$000330				DOS_CLUS_ID      = $000330      ; 4 bytes - The cluster desired for a DOS operation
=$000338				DOS_DIR_PTR      = $000338      ; 4 bytes - Pointer to a directory entry (assumed to be within DOS_SECTOR)
=$00033c				DOS_BUFF_PTR     = $00033C      ; 4 bytes - A pointer for DOS cluster read/write operations
=$000340				DOS_FD_PTR       = $000340      ; 4 bytes - A pointer to a file descriptor
=$000344				DOS_FAT_LBA      = $000344      ; 4 bytes - The LBA for a sector of the FAT we need to read/write
=$000348				DOS_TEMP         = $000348      ; 4 bytes - Temporary storage for DOS operations
=$00034c				DOS_FILE_SIZE    = $00034C      ; 4 bytes - The size of a file
=$000350				DOS_SRC_PTR      = $000350      ; 4 bytes - Pointer for transferring data
=$000354				DOS_DST_PTR      = $000354      ; 4 bytes - Pointer for transferring data
=$000358				DOS_END_PTR      = $000358      ; 4 bytes - Pointer to the last byte to save
=$00035c				DOS_RUN_PTR      = $00035C      ; 4 bytes - Pointer for starting a loaded program
=$000360				DOS_RUN_PARAM    = $000360      ; 4 bytes - Pointer to the ASCIIZ string for arguments in loading a program
=$000364				DOS_STR1_PTR     = $000364      ; 4 bytes - pointer to a string
=$000368				DOS_STR2_PTR     = $000368      ; 4 bytes - pointer to a string
=$00036b				DOS_SCRATCH      = $00036B      ; 4 bytes - general purpose short term storage
=$000400				DOS_PATH_BUFF    = $000400      ; 256 bytes - A buffer for path names
=$000500				FDC_PARAMETERS   = $000500      ; 16 bytes - a buffer of parameter data for the FDC
=$000510				FDC_RESULTS      = $000510      ; 16 bytes - Buffer for results of FDC commands
=$000530				FDC_PARAM_NUM    = $000530      ; 1 byte - The number of parameters to send to the FDC (including command)
=$000532				FDC_RESULT_NUM   = $000532      ; 1 byte - The number of results expected
=$000533				FDC_EXPECT_DAT   = $000533      ; 1 byte - 0 = the command expects no data, otherwise expects data
=$000534				FDC_CMD_RETRY    = $000534      ; 1 byte - a retry counter for commands
=$000700				CURRUART         = $000700 ; 3-bytes: the base address of the current UART
=$000703				CHAN_OUT         = $000703 ; 1-byte: the number of the current output channel (for PUTC, etc.)
=$000704				CHAN_IN          = $000704 ; 1-byte: the number of the current input channel (for GETCH, etc.)
=$000705				TIMERFLAGS       = $000705 ; 1-byte: flags to indicate that one of the timer interupts has triggered
=$80					TIMER0TRIGGER    = $80
=$40					TIMER1TRIGGER    = $40
=$20					TIMER2TRIGGER    = $20
=$000f00				KEY_BUFFER       = $000F00 ; 64 Bytes keyboard buffer
=$0080					KEY_BUFFER_SIZE  = $0080   ;128 Bytes (constant) keyboard buffer length
=$000f7f				KEY_BUFFER_END   = $000F7F ;  1 Byte  Last byte of keyboard buffer
=$000f83				KEY_BUFFER_CMD   = $000F83 ;  1 Byte  Indicates the Command Process Status
=$000f84				COMMAND_SIZE_STR = $000F84 ;  1 Byte
=$000f86				COMMAND_COMP_TMP = $000F86 ;  2 Bytes
=$000f87				KEYBOARD_SC_FLG  = $000F87 ;  1 Bytes that indicate the Status of Left Shift, Left CTRL, Left ALT, Right Shift
=$000f88				KEYBOARD_SC_TMP  = $000F88 ;  1 Byte, Interrupt Save Scan Code while Processing
=$000f89				KEYBOARD_LOCKS   = $000F89 ;  1 Byte, the status of the various lock keys
=$000f8a				KEYFLAG          = $000F8A ;  1 Byte, flag to indicate if CTRL-C has been pressed
=$000f8b				KEY_BUFFER_RPOS  = $000F8B ;  2 Byte, position of the character to read from the KEY_BUFFER
=$000f8d				KEY_BUFFER_WPOS  = $000F8D ;  2 Byte, position of the character to write to the KEY_BUFFER
=$001000				KERNEL_JMP_BEGIN = $001000 ; Reserved for the Kernel jump table
=$001fff				KERNEL_JMP_END   = $001FFF
=$002000				TEST_BEGIN       = $002000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/int_math_defs.s

=$000100				UNSIGNED_MULT_A_LO  = $000100
=$000101				UNSIGNED_MULT_A_HI  = $000101
=$000102				UNSIGNED_MULT_B_LO  = $000102
=$000103				UNSIGNED_MULT_B_HI  = $000103
=$000104				UNSIGNED_MULT_AL_LO = $000104
=$000105				UNSIGNED_MULT_AL_HI = $000105
=$000106				UNSIGNED_MULT_AH_LO = $000106
=$000107				UNSIGNED_MULT_AH_HI = $000107
=$000108				SIGNED_MULT_A_LO    = $000108
=$000109				SIGNED_MULT_A_HI    = $000109
=$00010a				SIGNED_MULT_B_LO    = $00010A
=$00010b				SIGNED_MULT_B_HI    = $00010B
=$00010c				SIGNED_MULT_AL_LO   = $00010C
=$00010d				SIGNED_MULT_AL_HI   = $00010D
=$00010e				SIGNED_MULT_AH_LO   = $00010E
=$00010f				SIGNED_MULT_AH_HI   = $00010F
=$000110				UNSIGNED_DIV_DEM_LO = $000110
=$000111				UNSIGNED_DIV_DEM_HI = $000111
=$000112				UNSIGNED_DIV_NUM_LO = $000112
=$000113				UNSIGNED_DIV_NUM_HI = $000113
=$000114				UNSIGNED_DIV_QUO_LO = $000114
=$000115				UNSIGNED_DIV_QUO_HI = $000115
=$000116				UNSIGNED_DIV_REM_LO = $000116
=$000117				UNSIGNED_DIV_REM_HI = $000117
=$000118				SIGNED_DIV_DEM_LO   = $000118
=$000119				SIGNED_DIV_DEM_HI   = $000119
=$00011a				SIGNED_DIV_NUM_LO   = $00011A
=$00011b				SIGNED_DIV_NUM_HI   = $00011B
=$00011c				SIGNED_DIV_QUO_LO   = $00011C
=$00011d				SIGNED_DIV_QUO_HI   = $00011D
=$00011e				SIGNED_DIV_REM_LO   = $00011E
=$00011f				SIGNED_DIV_REM_HI   = $00011F
=$000120				ADDER32_A_LL        = $000120
=$000121				ADDER32_A_LH        = $000121
=$000122				ADDER32_A_HL        = $000122
=$000123				ADDER32_A_HH        = $000123
=$000124				ADDER32_B_LL        = $000124
=$000125				ADDER32_B_LH        = $000125
=$000126				ADDER32_B_HL        = $000126
=$000127				ADDER32_B_HH        = $000127
=$000128				ADDER32_R_LL        = $000128
=$000129				ADDER32_R_LH        = $000129
=$00012a				ADDER32_R_HL        = $00012A
=$00012b				ADDER32_R_HH        = $00012B
=$af1400				SIGNED32_MULT_A     = $AF1400
=$af1404				SIGNED32_MULT_B     = $AF1404
=$af1408				SIGNED32_MULT_OUT   = $AF1408

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/vicky_def.s

=$af0000				MASTER_CTRL_REG_L	      = $AF0000
=$01					Mstr_Ctrl_Text_Mode_En  = $01       ; Enable the Text Mode
=$02					Mstr_Ctrl_Text_Overlay  = $02       ; Enable the Overlay of the text mode on top of Graphic Mode (the Background Color is ignored)
=$04					Mstr_Ctrl_Graph_Mode_En = $04       ; Enable the Graphic Mode
=$08					Mstr_Ctrl_Bitmap_En     = $08       ; Enable the Bitmap Module In Vicky
=$10					Mstr_Ctrl_TileMap_En    = $10       ; Enable the Tile Module in Vicky
=$20					Mstr_Ctrl_Sprite_En     = $20       ; Enable the Sprite Module in Vicky
=$40					Mstr_Ctrl_GAMMA_En      = $40       ; this Enable the GAMMA correction - The Analog and DVI have different color value, the GAMMA is great to correct the difference
=$80					Mstr_Ctrl_Disable_Vid   = $80       ; This will disable the Scanning of the Video hence giving 100% bandwith to the CPU
=$af0001				MASTER_CTRL_REG_H       = $AF0001
=$01					Mstr_Ctrl_Video_Mode0   = $01       ; 0 - 640x480 (Clock @ 25.175Mhz), 1 - 800x600 (Clock @ 40Mhz)
=$02					Mstr_Ctrl_Video_Mode1   = $02       ; 0 - No Pixel Doubling, 1- Pixel Doubling (Reduce the Pixel Resolution by 2)
=$af0002				GAMMA_CTRL_REG          = $AF0002
=$01					GAMMA_Ctrl_Input        = $01 ; 0 = DipSwitch Chooses GAMMA on/off , 1- Software Control
=$02					GAMMA_Ctrl_Soft         = $02 ; 0 = GAMMA Table is not Applied, 1 = GAMMA Table is Applied
=$08					GAMMA_DP_SW_VAL         = $08 ; READ ONLY - Actual DIP Switch Value
=$10					HIRES_DP_SW_VAL         = $10 ; READ ONLY - 0 = Hi-Res on BOOT ON, 1 = Hi-Res on BOOT OFF
=$af0003				VKY_RESERVED_01         = $AF0003
=$01					Border_Ctrl_Enable      = $01
=$af0004				BORDER_CTRL_REG         = $AF0004 ; Bit[0] - Enable (1 by default)  Bit[4..6]: X Scroll Offset ( Will scroll Left) (Acceptable Value: 0..7)
=$af0005				BORDER_COLOR_B          = $AF0005
=$af0006				BORDER_COLOR_G          = $AF0006
=$af0007				BORDER_COLOR_R          = $AF0007
=$af0008				BORDER_X_SIZE           = $AF0008; X-  Values: 0 - 32 (Default: 32)
=$af0009				BORDER_Y_SIZE           = $AF0009; Y- Values 0 -32 (Default: 32)
=$af000d				BACKGROUND_COLOR_B      = $AF000D ; When in Graphic Mode, if a pixel is "0" then the Background pixel is chosen
=$af000e				BACKGROUND_COLOR_G      = $AF000E
=$af000f				BACKGROUND_COLOR_R      = $AF000F ;
=$af0010				VKY_TXT_CURSOR_CTRL_REG = $AF0010   ;[0]  Enable Text Mode
=$01					Vky_Cursor_Enable       = $01
=$02					Vky_Cursor_Flash_Rate0  = $02       ; 00 - 1/Sec, 01 - 2/Sec, 10 - 4/Sec, 11 - 5/Sec
=$04					Vky_Cursor_Flash_Rate1  = $04
=$08					Vky_Cursor_FONT_Page0   = $08       ; Pick Font Page 0 or Font Page 1
=$10					Vky_Cursor_FONT_Page1   = $10       ; Pick Font Page 0 or Font Page 1
=$af0011				VKY_TXT_START_ADD_PTR   = $AF0011   ; This is an offset to change the Starting address of the Text Mode Buffer (in x)
=$af0012				VKY_TXT_CURSOR_CHAR_REG = $AF0012
=$af0013				VKY_TXT_CURSOR_COLR_REG = $AF0013
=$af0014				VKY_TXT_CURSOR_X_REG_L  = $AF0014
=$af0015				VKY_TXT_CURSOR_X_REG_H  = $AF0015
=$af0016				VKY_TXT_CURSOR_Y_REG_L  = $AF0016
=$af0017				VKY_TXT_CURSOR_Y_REG_H  = $AF0017
=$af001b				VKY_LINE_IRQ_CTRL_REG   = $AF001B ;[0] - Enable Line 0, [1] -Enable Line 1
=$af001c				VKY_LINE0_CMP_VALUE_LO  = $AF001C ;Write Only [7:0]
=$af001d				VKY_LINE0_CMP_VALUE_HI  = $AF001D ;Write Only [3:0]
=$af001e				VKY_LINE1_CMP_VALUE_LO  = $AF001E ;Write Only [7:0]
=$af001f				VKY_LINE1_CMP_VALUE_HI  = $AF001F ;Write Only [3:0]
=$af001c				VKY_INFO_CHIP_NUM_L     = $AF001C   ; VErsion
=$af001d				VKY_INFO_CHIP_NUM_H     = $AF001D   ; Version
=$af001e				VKY_INFO_CHIP_VER_L     = $AF001E   ; Sub-Version
=$af001f				VKY_INFO_CHIP_VER_H     = $AF001F   ; Sub-Version
=$af0500				MOUSE_PTR_GRAP0_START    = $AF0500 ; 16 x 16 = 256 Pixels (Grey Scale) 0 = Transparent, 1 = Black , 255 = White
=$af05ff				MOUSE_PTR_GRAP0_END      = $AF05FF ; Pointer 0
=$af0600				MOUSE_PTR_GRAP1_START    = $AF0600 ;
=$af06ff				MOUSE_PTR_GRAP1_END      = $AF06FF ; Pointer 1
=$af0700				MOUSE_PTR_CTRL_REG_L    = $AF0700 ; Bit[0] Enable, Bit[1] = 0  ( 0 = Pointer0, 1 = Pointer1)
=$af0701				MOUSE_PTR_CTRL_REG_H    = $AF0701 ;
=$af0702				MOUSE_PTR_X_POS_L       = $AF0702 ; X Position (0 - 639) (Can only read now) Writing will have no effect
=$af0703				MOUSE_PTR_X_POS_H       = $AF0703 ;
=$af0704				MOUSE_PTR_Y_POS_L       = $AF0704 ; Y Position (0 - 479) (Can only read now) Writing will have no effect
=$af0705				MOUSE_PTR_Y_POS_H       = $AF0705 ;
=$af0706				MOUSE_PTR_BYTE0         = $AF0706 ; Byte 0 of Mouse Packet (you must write 3 Bytes)
=$af0707				MOUSE_PTR_BYTE1         = $AF0707 ; Byte 1 of Mouse Packet (if you don't, then )
=$af0708				MOUSE_PTR_BYTE2         = $AF0708 ; Byte 2 of Mouse Packet (state Machine will be jammed in 1 state)
=$af070b				C256F_MODEL_MAJOR       = $AF070B ;
=$af070c				C256F_MODEL_MINOR       = $AF070C ;
=$af070d				FPGA_DOR                = $AF070D ;
=$af070e				FPGA_MOR                = $AF070E ;
=$af070f				FPGA_YOR                = $AF070F ;
=$af0900				VMEM2CPU_CTRL_REG      = $AF0900  ;
=$01					VMEM2CPU_Clear_FIFO    = $01        ; Setting this to 1 will flush (Reset) the FIFO, clear it after to return to normal function
=$02					VMEM2CPU_Intterupt     = $02        ; This is not implemented because there is not enough Interrupt line on the FMX
=$af0901				VMEM2CPU_Data_Port     = $AF0901    ; This is a Byte Port of the data that you have requested. (Output of the FIFO)
=$af0902				VMEM2CPU_Fifo_Count_LO = $AF0902    ; FIFO Count Lo (number of byte in the FIFO) FIFO Count is 10bits, Count_Bit0 to Count_Bit7 of Count
=$af0903				VMEM2CPU_Fifo_Count_HI = $AF0903    ; FIFO Count Hi, Bit 0 = Count_Bit8, Bit 1 = Count_Bit9
=$80					VMEM2CPU_Fifo_Empty    = $80        ; Bit 7 of VMEM2CPU_Fifo_Count_HI, when 1, the FIFO is empty.
=$af1f40				FG_CHAR_LUT_PTR         = $AF1F40
=$af1f80				BG_CHAR_LUT_PTR		    = $AF1F80
=$af2000				GRPH_LUT0_PTR		    = $AF2000
=$af2400				GRPH_LUT1_PTR		    = $AF2400
=$af2800				GRPH_LUT2_PTR		    = $AF2800
=$af2c00				GRPH_LUT3_PTR		    = $AF2C00
=$af3000				GRPH_LUT4_PTR		    = $AF3000
=$af3400				GRPH_LUT5_PTR		    = $AF3400
=$af3800				GRPH_LUT6_PTR		    = $AF3800
=$af3c00				GRPH_LUT7_PTR		    = $AF3C00
=$af4000				GAMMA_B_LUT_PTR		    = $AF4000
=$af4100				GAMMA_G_LUT_PTR		    = $AF4100
=$af4200				GAMMA_R_LUT_PTR		    = $AF4200
=$af8000				FONT_MEMORY_BANK0       = $AF8000     ;$AF8000 - $AF87FF
=$afa000				CS_TEXT_MEM_PTR         = $AFA000
=$afc000				CS_COLOR_MEM_PTR        = $AFC000

;******  Processing file: src\C256/VKYII_CFP9553_BITMAP_def.s

=$01					BM_Enable             = $01
=$00					BM_LUT0               = $00 ;
=$02					BM_LUT1               = $02 ;
=$04					BM_LUT2               = $04 ;
=$06					BM_LUT3               = $06 ;
=$08					BM_LUT4               = $08 ;
=$0a					BM_LUT5               = $0A ;
=$0c					BM_LUT6               = $0C ;
=$0e					BM_LUT7               = $0E ;
=$af0100				BM0_CONTROL_REG     = $AF0100
=$af0101				BM0_START_ADDY_L    = $AF0101
=$af0102				BM0_START_ADDY_M    = $AF0102
=$af0103				BM0_START_ADDY_H    = $AF0103
=$af0104				BM0_X_OFFSET        = $AF0104   ; Not Implemented
=$af0105				BM0_Y_OFFSET        = $AF0105   ; Not Implemented
=$af0106				BM0_RESERVED_6      = $AF0106
=$af0107				BM0_RESERVED_7      = $AF0107
=$af0108				BM1_CONTROL_REG     = $AF0108
=$af0109				BM1_START_ADDY_L    = $AF0109
=$af010a				BM1_START_ADDY_M    = $AF010A
=$af010b				BM1_START_ADDY_H    = $AF010B
=$af010c				BM1_X_OFFSET        = $AF010C   ; Not Implemented
=$af010d				BM1_Y_OFFSET        = $AF010D   ; Not Implemented
=$af010e				BM1_RESERVED_6      = $AF010E
=$af010f				BM1_RESERVED_7      = $AF010F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_TILEMAP_def.s

=$01					TILE_Enable             = $01
=0					TILEMAP_CONTROL         = 0             ; Offset to a tile map's control register
=1					TILEMAP_START_ADDY      = 1             ; Offset to a tile map's address
=4					TILEMAP_TOTAL_X         = 4             ; Offset to a tile map's width
=6					TILEMAP_TOTAL_Y         = 6             ; Offset to a tile map's height
=8					TILEMAP_WINDOW_X        = 8             ; Offset to a tile map's X position
=10					TILEMAP_WINDOW_Y        = 10            ; Offset to a tile map's Y position
=1					TILEMAP_VISIBLE         = 1             ; Tile map is visible flag
=$af0200				TL0_CONTROL_REG         = $AF0200       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0201				TL0_START_ADDY_L        = $AF0201       ; Not USed right now - Starting Address to where is the MAP
=$af0202				TL0_START_ADDY_M        = $AF0202
=$af0203				TL0_START_ADDY_H        = $AF0203
=$af0204				TL0_TOTAL_X_SIZE_L      = $AF0204       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0205				TL0_TOTAL_X_SIZE_H      = $AF0205
=$af0206				TL0_TOTAL_Y_SIZE_L      = $AF0206       ; Size of the Map in Y Tile Count [9:0]
=$af0207				TL0_TOTAL_Y_SIZE_H      = $AF0207
=$af0208				TL0_WINDOW_X_POS_L      = $AF0208       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0209				TL0_WINDOW_X_POS_H      = $AF0209       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af020a				TL0_WINDOW_Y_POS_L      = $AF020A       ; Top Left Corner Position of the TileMAp Window in Y
=$af020b				TL0_WINDOW_Y_POS_H      = $AF020B       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af020c				TL1_CONTROL_REG         = $AF020C       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af020d				TL1_START_ADDY_L        = $AF020D       ; Not USed right now - Starting Address to where is the MAP
=$af020e				TL1_START_ADDY_M        = $AF020E
=$af020f				TL1_START_ADDY_H        = $AF020F
=$af0210				TL1_TOTAL_X_SIZE_L      = $AF0210       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0211				TL1_TOTAL_X_SIZE_H      = $AF0211
=$af0212				TL1_TOTAL_Y_SIZE_L      = $AF0212       ; Size of the Map in Y Tile Count [9:0]
=$af0213				TL1_TOTAL_Y_SIZE_H      = $AF0213
=$af0214				TL1_WINDOW_X_POS_L      = $AF0214       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0215				TL1_WINDOW_X_POS_H      = $AF0215       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0216				TL1_WINDOW_Y_POS_L      = $AF0216       ; Top Left Corner Position of the TileMAp Window in Y
=$af0217				TL1_WINDOW_Y_POS_H      = $AF0217       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0218				TL2_CONTROL_REG         = $AF0218       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0219				TL2_START_ADDY_L        = $AF0219       ; Not USed right now - Starting Address to where is the MAP
=$af021a				TL2_START_ADDY_M        = $AF021A
=$af021b				TL2_START_ADDY_H        = $AF021B
=$af021c				TL2_TOTAL_X_SIZE_L      = $AF021C       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af021d				TL2_TOTAL_X_SIZE_H      = $AF021D
=$af021e				TL2_TOTAL_Y_SIZE_L      = $AF021E       ; Size of the Map in Y Tile Count [9:0]
=$af021f				TL2_TOTAL_Y_SIZE_H      = $AF021F
=$af0220				TL2_WINDOW_X_POS_L      = $AF0220       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0221				TL2_WINDOW_X_POS_H      = $AF0221       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0222				TL2_WINDOW_Y_POS_L      = $AF0222       ; Top Left Corner Position of the TileMAp Window in Y
=$af0223				TL2_WINDOW_Y_POS_H      = $AF0223       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0224				TL3_CONTROL_REG         = $AF0224       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0225				TL3_START_ADDY_L        = $AF0225       ; Not USed right now - Starting Address to where is the MAP
=$af0226				TL3_START_ADDY_M        = $AF0226
=$af0227				TL3_START_ADDY_H        = $AF0227
=$af0228				TL3_TOTAL_X_SIZE_L      = $AF0228       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0229				TL3_TOTAL_X_SIZE_H      = $AF0229
=$af022a				TL3_TOTAL_Y_SIZE_L      = $AF022A       ; Size of the Map in Y Tile Count [9:0]
=$af022b				TL3_TOTAL_Y_SIZE_H      = $AF022B
=$af022c				TL3_WINDOW_X_POS_L      = $AF022C       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af022d				TL3_WINDOW_X_POS_H      = $AF022D       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af022e				TL3_WINDOW_Y_POS_L      = $AF022E       ; Top Left Corner Position of the TileMAp Window in Y
=$af022f				TL3_WINDOW_Y_POS_H      = $AF022F       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0280				TILESET0_ADDY_L         = $AF0280   ; Pointer to Tileset 0 [21:0]
=$af0281				TILESET0_ADDY_M         = $AF0281
=$af0282				TILESET0_ADDY_H         = $AF0282
=$af0283				TILESET0_ADDY_CFG       = $AF0283   ; [3] - TileStride256x256 [2:0] LUT
=2					TILESET_ADDY_H          = 2             ; Offset to high byte of tile set address
=3					TILESET_ADDY_CFG        = 3             ; Offset to the tile set address configuration
=$08					TILESET_SQUARE_256      = $08
=$af0284				TILESET1_ADDY_L         = $AF0284
=$af0285				TILESET1_ADDY_M         = $AF0285
=$af0286				TILESET1_ADDY_H         = $AF0286
=$af0287				TILESET1_ADDY_CFG       = $AF0287
=$af0288				TILESET2_ADDY_L         = $AF0288
=$af0289				TILESET2_ADDY_M         = $AF0289
=$af028a				TILESET2_ADDY_H         = $AF028A
=$af028b				TILESET2_ADDY_CFG       = $AF028B
=$af028c				TILESET3_ADDY_L         = $AF028C
=$af028d				TILESET3_ADDY_M         = $AF028D
=$af028e				TILESET3_ADDY_H         = $AF028E
=$af028f				TILESET3_ADDY_CFG       = $AF028F
=$af0290				TILESET4_ADDY_L         = $AF0290
=$af0291				TILESET4_ADDY_M         = $AF0291
=$af0292				TILESET4_ADDY_H         = $AF0292
=$af0293				TILESET4_ADDY_CFG       = $AF0293
=$af0294				TILESET5_ADDY_L         = $AF0294
=$af0295				TILESET5_ADDY_M         = $AF0295
=$af0296				TILESET5_ADDY_H         = $AF0296
=$af0297				TILESET5_ADDY_CFG       = $AF0297
=$af0298				TILESET6_ADDY_L         = $AF0298
=$af0299				TILESET6_ADDY_M         = $AF0299
=$af029a				TILESET6_ADDY_H         = $AF029A
=$af029b				TILESET6_ADDY_CFG       = $AF029B
=$af029c				TILESET7_ADDY_L         = $AF029C
=$af029d				TILESET7_ADDY_M         = $AF029D
=$af029e				TILESET7_ADDY_H         = $AF029E
=$af029f				TILESET7_ADDY_CFG       = $AF029F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SDMA_def.s

=$af0420				SDMA_CTRL_REG0           = $AF0420
=$01					SDMA_CTRL0_Enable        = $01
=$02					SDMA_CTRL0_1D_2D         = $02     ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					SDMA_CTRL0_TRF_Fill      = $04     ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					SDMA_CTRL0_Int_Enable    = $08     ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					SDMA_CTRL0_SysRAM_Src    = $10     ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					SDMA_CTRL0_SysRAM_Dst    = $20     ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$00					SDMA_XFER_SRAM2SRAM = $00           ; SRAM -> SRAM transfer
=$10					SDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					SDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$30					SDMA_XFER_SRAMIO = $30              ; SRAM <-> IO transfer (see: SDMA_CONTROL_REG1 for config and direction)
=$40					SDMA_CTLR0_RSVD          = $40      ; Reserved
=$80					SDMA_CTRL0_Start_TRF     = $80      ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$af0421				SDMA_CTRL_REG1           = $AF0421  ; Write Only - Byte to Write in the Fill Function
=$01					SDMA_CTRL1_IO_Src		 = $01		; 1 = Source is an IO Address (ADC, SuperIO, IDE)
=$02					SDMA_CTRL1_IO_Src16		 = $02		; 0 = Src 8Bits Transfer / 1= 16Bits Transfer
=$04					SDMA_CTRL1_IO_Dst		 = $04		; 1 = Destination is an IO Address (DAC, SuperIO, IDE)
=$08					SDMA_CTRL1_IO_Dst16      = $08      ; 0 = Dst 8bits Transfer / 1= 16bits
=$af0422				SDMA_SRC_ADDY_L         = $AF0422   ; Pointer to the Source of the Data to be stransfered
=$af0423				SDMA_SRC_ADDY_M         = $AF0423   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0424				SDMA_SRC_ADDY_H         = $AF0424
=$af0425				SDMA_DST_ADDY_L         = $AF0425   ; Destination Pointer within CPU's video memory Range
=$af0426				SDMA_DST_ADDY_M         = $AF0426   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0427				SDMA_DST_ADDY_H         = $AF0427
=$af0428				SDMA_SIZE_L             = $AF0428   ; Maximum Value: $40:0000 (4Megs)
=$af0429				SDMA_SIZE_M             = $AF0429
=$af042a				SDMA_SIZE_H             = $AF042A
=$af042b				SDMA_IGNORED            = $AF042B
=$af0428				SDMA_X_SIZE_L           = $AF0428   ; Maximum Value: 65535
=$af0429				SDMA_X_SIZE_H           = $AF0429
=$af042a				SDMA_Y_SIZE_L           = $AF042A   ; Maximum Value: 65535
=$af042b				SDMA_Y_SIZE_H           = $AF042B
=$af042c				SDMA_SRC_STRIDE_L       = $AF042C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042d				SDMA_SRC_STRIDE_H       = $AF042D   ;
=$af042e				SDMA_DST_STRIDE_L       = $AF042E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042f				SDMA_DST_STRIDE_H       = $AF042F   ;
=$af0430				SDMA_BYTE_2_WRITE       = $AF0430   ; Write Only - Byte to Write in the Fill Function
=$af0430				SDMA_STATUS_REG         = $AF0430   ; Read only
=$01					SDMA_STAT_Size_Err       = $01      ; If Set to 1, Overall Size is Invalid
=$02					SDMA_STAT_Dst_Add_Err    = $02      ; If Set to 1, Destination Address Invalid
=$04					SDMA_STAT_Src_Add_Err    = $04      ; If Set to 1, Source Address Invalid
=$08					SDMA_STAT_TimeOut_Err    = $08      ; will be set to 1 if a Timeout occur when transfering between data from and to VRAM

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_VDMA_def.s

=$af0400				VDMA_CONTROL_REG        = $AF0400
=$01					VDMA_CTRL_Enable        = $01
=$02					VDMA_CTRL_1D_2D         = $02       ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					VDMA_CTRL_TRF_Fill      = $04       ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					VDMA_CTRL_Int_Enable    = $08       ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					VDMA_CTRL_SysRAM_Src    = $10       ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					VDMA_CTRL_SysRAM_Dst    = $20       ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$80					VDMA_CTRL_Start_TRF     = $80       ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$00					VDMA_XFER_VRAM2VRAM = $00           ; VRAM -> VRAM transfer
=$10					VDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					VDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$af0401				VDMA_BYTE_2_WRITE       = $AF0401   ; Write Only - Byte to Write in the Fill Function
=$af0401				VDMA_STATUS_REG         = $AF0401   ; Read only
=$01					VDMA_STAT_Size_Err      = $01       ; If Set to 1, Overall Size is Invalid
=$02					VDMA_STAT_Dst_Add_Err   = $02       ; If Set to 1, Destination Address Invalid
=$04					VDMA_STAT_Src_Add_Err   = $04       ; If Set to 1, Source Address Invalid
=$80					VDMA_STAT_VDMA_IPS      = $80       ; If Set to 1, VDMA Transfer in Progress (this Inhibit CPU Access to Mem)
=$af0402				VDMA_SRC_ADDY_L         = $AF0402   ; Pointer to the Source of the Data to be stransfered
=$af0403				VDMA_SRC_ADDY_M         = $AF0403   ; This needs to be within Vicky's Range ($00_0000 - $3F_0000)
=$af0404				VDMA_SRC_ADDY_H         = $AF0404
=$af0405				VDMA_DST_ADDY_L         = $AF0405   ; Destination Pointer within Vicky's video memory Range
=$af0406				VDMA_DST_ADDY_M         = $AF0406   ; ($00_0000 - $3F_0000)
=$af0407				VDMA_DST_ADDY_H         = $AF0407
=$af0408				VDMA_SIZE_L             = $AF0408   ; Maximum Value: $40:0000 (4Megs)
=$af0409				VDMA_SIZE_M             = $AF0409
=$af040a				VDMA_SIZE_H             = $AF040A
=$af040b				VDMA_IGNORED            = $AF040B
=$af0408				VDMA_X_SIZE_L           = $AF0408   ; Maximum Value: 65535
=$af0409				VDMA_X_SIZE_H           = $AF0409
=$af040a				VDMA_Y_SIZE_L           = $AF040A   ; Maximum Value: 65535
=$af040b				VDMA_Y_SIZE_H           = $AF040B
=$af040c				VDMA_SRC_STRIDE_L       = $AF040C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040d				VDMA_SRC_STRIDE_H       = $AF040D   ;
=$af040e				VDMA_DST_STRIDE_L       = $AF040E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040f				VDMA_DST_STRIDE_H       = $AF040F   ;

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SPRITE_def.s

=$01					SPRITE_Enable             = $01
=$00					SPRITE_LUT0               = $00 ; This is the LUT that the Sprite will use
=$02					SPRITE_LUT1               = $02
=$04					SPRITE_LUT2               = $04 ; Only 4 LUT for Now, So this bit is not used.
=$06					SPRITE_LUT3               = $06 ; Only 4 LUT for Now, So this bit is not used.
=$08					SPRITE_LUT4               = $08 ; Only 4 LUT for Now, So this bit is not used.
=$0a					SPRITE_LUT5               = $0A ; Only 4 LUT for Now, So this bit is not used.
=$0c					SPRITE_LUT6               = $0C ; Only 4 LUT for Now, So this bit is not used.
=$0e					SPRITE_LUT7               = $0E ; Only 4 LUT for Now, So this bit is not used.
=$00					SPRITE_DEPTH0             = $00
=$10					SPRITE_DEPTH1             = $10
=$20					SPRITE_DEPTH2             = $20
=$30					SPRITE_DEPTH3             = $30
=$40					SPRITE_DEPTH4             = $40
=$50					SPRITE_DEPTH5             = $50
=$60					SPRITE_DEPTH6             = $60
=$af0c00				SP00_CONTROL_REG        = $AF0C00
=$af0c01				SP00_ADDY_PTR_L         = $AF0C01
=$af0c02				SP00_ADDY_PTR_M         = $AF0C02
=$af0c03				SP00_ADDY_PTR_H         = $AF0C03
=$af0c04				SP00_X_POS_L            = $AF0C04
=$af0c05				SP00_X_POS_H            = $AF0C05
=$af0c06				SP00_Y_POS_L            = $AF0C06
=$af0c07				SP00_Y_POS_H            = $AF0C07
=$af0c08				SP01_CONTROL_REG        = $AF0C08
=$af0c09				SP01_ADDY_PTR_L         = $AF0C09
=$af0c0a				SP01_ADDY_PTR_M         = $AF0C0A
=$af0c0b				SP01_ADDY_PTR_H         = $AF0C0B
=$af0c0c				SP01_X_POS_L            = $AF0C0C
=$af0c0d				SP01_X_POS_H            = $AF0C0D
=$af0c0e				SP01_Y_POS_L            = $AF0C0E
=$af0c0f				SP01_Y_POS_H            = $AF0C0F
=$af0c10				SP02_CONTROL_REG        = $AF0C10
=$af0c11				SP02_ADDY_PTR_L         = $AF0C11
=$af0c12				SP02_ADDY_PTR_M         = $AF0C12
=$af0c13				SP02_ADDY_PTR_H         = $AF0C13
=$af0c14				SP02_X_POS_L            = $AF0C14
=$af0c15				SP02_X_POS_H            = $AF0C15
=$af0c16				SP02_Y_POS_L            = $AF0C16
=$af0c17				SP02_Y_POS_H            = $AF0C17
=$af0c18				SP03_CONTROL_REG        = $AF0C18
=$af0c19				SP03_ADDY_PTR_L         = $AF0C19
=$af0c1a				SP03_ADDY_PTR_M         = $AF0C1A
=$af0c1b				SP03_ADDY_PTR_H         = $AF0C1B
=$af0c1c				SP03_X_POS_L            = $AF0C1C
=$af0c1d				SP03_X_POS_H            = $AF0C1D
=$af0c1e				SP03_Y_POS_L            = $AF0C1E
=$af0c1f				SP03_Y_POS_H            = $AF0C1F
=$af0c20				SP04_CONTROL_REG        = $AF0C20
=$af0c21				SP04_ADDY_PTR_L         = $AF0C21
=$af0c22				SP04_ADDY_PTR_M         = $AF0C22
=$af0c23				SP04_ADDY_PTR_H         = $AF0C23
=$af0c24				SP04_X_POS_L            = $AF0C24
=$af0c25				SP04_X_POS_H            = $AF0C25
=$af0c26				SP04_Y_POS_L            = $AF0C26
=$af0c27				SP04_Y_POS_H            = $AF0C27
=$af0c28				SP05_CONTROL_REG        = $AF0C28
=$af0c29				SP05_ADDY_PTR_L         = $AF0C29
=$af0c2a				SP05_ADDY_PTR_M         = $AF0C2A
=$af0c2b				SP05_ADDY_PTR_H         = $AF0C2B
=$af0c2c				SP05_X_POS_L            = $AF0C2C
=$af0c2d				SP05_X_POS_H            = $AF0C2D
=$af0c2e				SP05_Y_POS_L            = $AF0C2E
=$af0c2f				SP05_Y_POS_H            = $AF0C2F
=$af0c30				SP06_CONTROL_REG        = $AF0C30
=$af0c31				SP06_ADDY_PTR_L         = $AF0C31
=$af0c32				SP06_ADDY_PTR_M         = $AF0C32
=$af0c33				SP06_ADDY_PTR_H         = $AF0C33
=$af0c34				SP06_X_POS_L            = $AF0C34
=$af0c35				SP06_X_POS_H            = $AF0C35
=$af0c36				SP06_Y_POS_L            = $AF0C36
=$af0c37				SP06_Y_POS_H            = $AF0C37
=$af0c38				SP07_CONTROL_REG        = $AF0C38
=$af0c39				SP07_ADDY_PTR_L         = $AF0C39
=$af0c3a				SP07_ADDY_PTR_M         = $AF0C3A
=$af0c3b				SP07_ADDY_PTR_H         = $AF0C3B
=$af0c3c				SP07_X_POS_L            = $AF0C3C
=$af0c3d				SP07_X_POS_H            = $AF0C3D
=$af0c3e				SP07_Y_POS_L            = $AF0C3E
=$af0c3f				SP07_Y_POS_H            = $AF0C3F
=$af0c40				SP08_CONTROL_REG        = $AF0C40
=$af0c41				SP08_ADDY_PTR_L         = $AF0C41
=$af0c42				SP08_ADDY_PTR_M         = $AF0C42
=$af0c43				SP08_ADDY_PTR_H         = $AF0C43
=$af0c44				SP08_X_POS_L            = $AF0C44
=$af0c45				SP08_X_POS_H            = $AF0C45
=$af0c46				SP08_Y_POS_L            = $AF0C46
=$af0c47				SP08_Y_POS_H            = $AF0C47
=$af0c48				SP09_CONTROL_REG        = $AF0C48
=$af0c49				SP09_ADDY_PTR_L         = $AF0C49
=$af0c4a				SP09_ADDY_PTR_M         = $AF0C4A
=$af0c4b				SP09_ADDY_PTR_H         = $AF0C4B
=$af0c4c				SP09_X_POS_L            = $AF0C4C
=$af0c4d				SP09_X_POS_H            = $AF0C4D
=$af0c4e				SP09_Y_POS_L            = $AF0C4E
=$af0c4f				SP09_Y_POS_H            = $AF0C4F
=$af0c50				SP10_CONTROL_REG        = $AF0C50
=$af0c51				SP10_ADDY_PTR_L         = $AF0C51
=$af0c52				SP10_ADDY_PTR_M         = $AF0C52
=$af0c53				SP10_ADDY_PTR_H         = $AF0C53
=$af0c54				SP10_X_POS_L            = $AF0C54
=$af0c55				SP10_X_POS_H            = $AF0C55
=$af0c56				SP10_Y_POS_L            = $AF0C56
=$af0c57				SP10_Y_POS_H            = $AF0C57
=$af0c58				SP11_CONTROL_REG        = $AF0C58
=$af0c59				SP11_ADDY_PTR_L         = $AF0C59
=$af0c5a				SP11_ADDY_PTR_M         = $AF0C5A
=$af0c5b				SP11_ADDY_PTR_H         = $AF0C5B
=$af0c5c				SP11_X_POS_L            = $AF0C5C
=$af0c5d				SP11_X_POS_H            = $AF0C5D
=$af0c5e				SP11_Y_POS_L            = $AF0C5E
=$af0c5f				SP11_Y_POS_H            = $AF0C5F
=$af0c60				SP12_CONTROL_REG        = $AF0C60
=$af0c61				SP12_ADDY_PTR_L         = $AF0C61
=$af0c62				SP12_ADDY_PTR_M         = $AF0C62
=$af0c63				SP12_ADDY_PTR_H         = $AF0C63
=$af0c64				SP12_X_POS_L            = $AF0C64
=$af0c65				SP12_X_POS_H            = $AF0C65
=$af0c66				SP12_Y_POS_L            = $AF0C66
=$af0c67				SP12_Y_POS_H            = $AF0C67
=$af0c68				SP13_CONTROL_REG        = $AF0C68
=$af0c69				SP13_ADDY_PTR_L         = $AF0C69
=$af0c6a				SP13_ADDY_PTR_M         = $AF0C6A
=$af0c6b				SP13_ADDY_PTR_H         = $AF0C6B
=$af0c6c				SP13_X_POS_L            = $AF0C6C
=$af0c6d				SP13_X_POS_H            = $AF0C6D
=$af0c6e				SP13_Y_POS_L            = $AF0C6E
=$af0c6f				SP13_Y_POS_H            = $AF0C6F
=$af0c70				SP14_CONTROL_REG        = $AF0C70
=$af0c71				SP14_ADDY_PTR_L         = $AF0C71
=$af0c72				SP14_ADDY_PTR_M         = $AF0C72
=$af0c73				SP14_ADDY_PTR_H         = $AF0C73
=$af0c74				SP14_X_POS_L            = $AF0C74
=$af0c75				SP14_X_POS_H            = $AF0C75
=$af0c76				SP14_Y_POS_L            = $AF0C76
=$af0c77				SP14_Y_POS_H            = $AF0C77
=$af0c78				SP15_CONTROL_REG        = $AF0C78
=$af0c79				SP15_ADDY_PTR_L         = $AF0C79
=$af0c7a				SP15_ADDY_PTR_M         = $AF0C7A
=$af0c7b				SP15_ADDY_PTR_H         = $AF0C7B
=$af0c7c				SP15_X_POS_L            = $AF0C7C
=$af0c7d				SP15_X_POS_H            = $AF0C7D
=$af0c7e				SP15_Y_POS_L            = $AF0C7E
=$af0c7f				SP15_Y_POS_H            = $AF0C7F
=$af0c80				SP16_CONTROL_REG        = $AF0C80
=$af0c81				SP16_ADDY_PTR_L         = $AF0C81
=$af0c82				SP16_ADDY_PTR_M         = $AF0C82
=$af0c83				SP16_ADDY_PTR_H         = $AF0C83
=$af0c84				SP16_X_POS_L            = $AF0C84
=$af0c85				SP16_X_POS_H            = $AF0C85
=$af0c86				SP16_Y_POS_L            = $AF0C86
=$af0c87				SP16_Y_POS_H            = $AF0C87
=$af0c88				SP17_CONTROL_REG        = $AF0C88
=$af0c89				SP17_ADDY_PTR_L         = $AF0C89
=$af0c8a				SP17_ADDY_PTR_M         = $AF0C8A
=$af0c8b				SP17_ADDY_PTR_H         = $AF0C8B
=$af0c8c				SP17_X_POS_L            = $AF0C8C
=$af0c8d				SP17_X_POS_H            = $AF0C8D
=$af0c8e				SP17_Y_POS_L            = $AF0C8E
=$af0c8f				SP17_Y_POS_H            = $AF0C8F
=$af0c90				SP18_CONTROL_REG        = $AF0C90
=$af0c91				SP18_ADDY_PTR_L         = $AF0C91
=$af0c92				SP18_ADDY_PTR_M         = $AF0C92
=$af0c93				SP18_ADDY_PTR_H         = $AF0C93
=$af0c94				SP18_X_POS_L            = $AF0C94
=$af0c95				SP18_X_POS_H            = $AF0C95
=$af0c96				SP18_Y_POS_L            = $AF0C96
=$af0c97				SP18_Y_POS_H            = $AF0C97
=$af0c98				SP19_CONTROL_REG        = $AF0C98
=$af0c99				SP19_ADDY_PTR_L         = $AF0C99
=$af0c9a				SP19_ADDY_PTR_M         = $AF0C9A
=$af0c9b				SP19_ADDY_PTR_H         = $AF0C9B
=$af0c9c				SP19_X_POS_L            = $AF0C9C
=$af0c9d				SP19_X_POS_H            = $AF0C9D
=$af0c9e				SP19_Y_POS_L            = $AF0C9E
=$af0c9f				SP19_Y_POS_H            = $AF0C9F
=$af0ca0				SP20_CONTROL_REG        = $AF0CA0
=$af0ca1				SP20_ADDY_PTR_L         = $AF0CA1
=$af0ca2				SP20_ADDY_PTR_M         = $AF0CA2
=$af0ca3				SP20_ADDY_PTR_H         = $AF0CA3
=$af0ca4				SP20_X_POS_L            = $AF0CA4
=$af0ca5				SP20_X_POS_H            = $AF0CA5
=$af0ca6				SP20_Y_POS_L            = $AF0CA6
=$af0ca7				SP20_Y_POS_H            = $AF0CA7
=$af0ca8				SP21_CONTROL_REG        = $AF0CA8
=$af0ca9				SP21_ADDY_PTR_L         = $AF0CA9
=$af0caa				SP21_ADDY_PTR_M         = $AF0CAA
=$af0cab				SP21_ADDY_PTR_H         = $AF0CAB
=$af0cac				SP21_X_POS_L            = $AF0CAC
=$af0cad				SP21_X_POS_H            = $AF0CAD
=$af0cae				SP21_Y_POS_L            = $AF0CAE
=$af0caf				SP21_Y_POS_H            = $AF0CAF
=$af0cb0				SP22_CONTROL_REG        = $AF0CB0
=$af0cb1				SP22_ADDY_PTR_L         = $AF0CB1
=$af0cb2				SP22_ADDY_PTR_M         = $AF0CB2
=$af0cb3				SP22_ADDY_PTR_H         = $AF0CB3
=$af0cb4				SP22_X_POS_L            = $AF0CB4
=$af0cb5				SP22_X_POS_H            = $AF0CB5
=$af0cb6				SP22_Y_POS_L            = $AF0CB6
=$af0cb7				SP22_Y_POS_H            = $AF0CB7
=$af0cb8				SP23_CONTROL_REG        = $AF0CB8
=$af0cb9				SP23_ADDY_PTR_L         = $AF0CB9
=$af0cba				SP23_ADDY_PTR_M         = $AF0CBA
=$af0cbb				SP23_ADDY_PTR_H         = $AF0CBB
=$af0cbc				SP23_X_POS_L            = $AF0CBC
=$af0cbd				SP23_X_POS_H            = $AF0CBD
=$af0cbe				SP23_Y_POS_L            = $AF0CBE
=$af0cbf				SP23_Y_POS_H            = $AF0CBF
=$af0cc0				SP24_CONTROL_REG        = $AF0CC0
=$af0cc1				SP24_ADDY_PTR_L         = $AF0CC1
=$af0cc2				SP24_ADDY_PTR_M         = $AF0CC2
=$af0cc3				SP24_ADDY_PTR_H         = $AF0CC3
=$af0cc4				SP24_X_POS_L            = $AF0CC4
=$af0cc5				SP24_X_POS_H            = $AF0CC5
=$af0cc6				SP24_Y_POS_L            = $AF0CC6
=$af0cc7				SP24_Y_POS_H            = $AF0CC7
=$af0cc8				SP25_CONTROL_REG        = $AF0CC8
=$af0cc9				SP25_ADDY_PTR_L         = $AF0CC9
=$af0cca				SP25_ADDY_PTR_M         = $AF0CCA
=$af0ccb				SP25_ADDY_PTR_H         = $AF0CCB
=$af0ccc				SP25_X_POS_L            = $AF0CCC
=$af0ccd				SP25_X_POS_H            = $AF0CCD
=$af0cce				SP25_Y_POS_L            = $AF0CCE
=$af0ccf				SP25_Y_POS_H            = $AF0CCF
=$af0cd0				SP26_CONTROL_REG        = $AF0CD0
=$af0cd1				SP26_ADDY_PTR_L         = $AF0CD1
=$af0cd2				SP26_ADDY_PTR_M         = $AF0CD2
=$af0cd3				SP26_ADDY_PTR_H         = $AF0CD3
=$af0cd4				SP26_X_POS_L            = $AF0CD4
=$af0cd5				SP26_X_POS_H            = $AF0CD5
=$af0cd6				SP26_Y_POS_L            = $AF0CD6
=$af0cd7				SP26_Y_POS_H            = $AF0CD7
=$af0cd8				SP27_CONTROL_REG        = $AF0CD8
=$af0cd9				SP27_ADDY_PTR_L         = $AF0CD9
=$af0cda				SP27_ADDY_PTR_M         = $AF0CDA
=$af0cdb				SP27_ADDY_PTR_H         = $AF0CDB
=$af0cdc				SP27_X_POS_L            = $AF0CDC
=$af0cdd				SP27_X_POS_H            = $AF0CDD
=$af0cde				SP27_Y_POS_L            = $AF0CDE
=$af0cdf				SP27_Y_POS_H            = $AF0CDF
=$af0ce0				SP28_CONTROL_REG        = $AF0CE0
=$af0ce1				SP28_ADDY_PTR_L         = $AF0CE1
=$af0ce2				SP28_ADDY_PTR_M         = $AF0CE2
=$af0ce3				SP28_ADDY_PTR_H         = $AF0CE3
=$af0ce4				SP28_X_POS_L            = $AF0CE4
=$af0ce5				SP28_X_POS_H            = $AF0CE5
=$af0ce6				SP28_Y_POS_L            = $AF0CE6
=$af0ce7				SP28_Y_POS_H            = $AF0CE7
=$af0ce8				SP29_CONTROL_REG        = $AF0CE8
=$af0ce9				SP29_ADDY_PTR_L         = $AF0CE9
=$af0cea				SP29_ADDY_PTR_M         = $AF0CEA
=$af0ceb				SP29_ADDY_PTR_H         = $AF0CEB
=$af0cec				SP29_X_POS_L            = $AF0CEC
=$af0ced				SP29_X_POS_H            = $AF0CED
=$af0cee				SP29_Y_POS_L            = $AF0CEE
=$af0cef				SP29_Y_POS_H            = $AF0CEF
=$af0cf0				SP30_CONTROL_REG        = $AF0CF0
=$af0cf1				SP30_ADDY_PTR_L         = $AF0CF1
=$af0cf2				SP30_ADDY_PTR_M         = $AF0CF2
=$af0cf3				SP30_ADDY_PTR_H         = $AF0CF3
=$af0cf4				SP30_X_POS_L            = $AF0CF4
=$af0cf5				SP30_X_POS_H            = $AF0CF5
=$af0cf6				SP30_Y_POS_L            = $AF0CF6
=$af0cf7				SP30_Y_POS_H            = $AF0CF7
=$af0cf8				SP31_CONTROL_REG        = $AF0CF8
=$af0cf9				SP31_ADDY_PTR_L         = $AF0CF9
=$af0cfa				SP31_ADDY_PTR_M         = $AF0CFA
=$af0cfb				SP31_ADDY_PTR_H         = $AF0CFB
=$af0cfc				SP31_X_POS_L            = $AF0CFC
=$af0cfd				SP31_X_POS_H            = $AF0CFD
=$af0cfe				SP31_Y_POS_L            = $AF0CFE
=$af0cff				SP31_Y_POS_H            = $AF0CFF
=$af0d00				SP32_CONTROL_REG        = $AF0D00
=$af0d01				SP32_ADDY_PTR_L         = $AF0D01
=$af0d02				SP32_ADDY_PTR_M         = $AF0D02
=$af0d03				SP32_ADDY_PTR_H         = $AF0D03
=$af0d04				SP32_X_POS_L            = $AF0D04
=$af0d05				SP32_X_POS_H            = $AF0D05
=$af0d06				SP32_Y_POS_L            = $AF0D06
=$af0d07				SP32_Y_POS_H            = $AF0D07
=$af0d08				SP33_CONTROL_REG        = $AF0D08
=$af0d09				SP33_ADDY_PTR_L         = $AF0D09
=$af0d0a				SP33_ADDY_PTR_M         = $AF0D0A
=$af0d0b				SP33_ADDY_PTR_H         = $AF0D0B
=$af0d0c				SP33_X_POS_L            = $AF0D0C
=$af0d0d				SP33_X_POS_H            = $AF0D0D
=$af0d0e				SP33_Y_POS_L            = $AF0D0E
=$af0d0f				SP33_Y_POS_H            = $AF0D0F
=$af0d10				SP34_CONTROL_REG        = $AF0D10
=$af0d11				SP34_ADDY_PTR_L         = $AF0D11
=$af0d12				SP34_ADDY_PTR_M         = $AF0D12
=$af0d13				SP34_ADDY_PTR_H         = $AF0D13
=$af0d14				SP34_X_POS_L            = $AF0D14
=$af0d15				SP34_X_POS_H            = $AF0D15
=$af0d16				SP34_Y_POS_L            = $AF0D16
=$af0d17				SP34_Y_POS_H            = $AF0D17
=$af0d18				SP35_CONTROL_REG        = $AF0D18
=$af0d19				SP35_ADDY_PTR_L         = $AF0D19
=$af0d1a				SP35_ADDY_PTR_M         = $AF0D1A
=$af0d1b				SP35_ADDY_PTR_H         = $AF0D1B
=$af0d1c				SP35_X_POS_L            = $AF0D1C
=$af0d1d				SP35_X_POS_H            = $AF0D1D
=$af0d1e				SP35_Y_POS_L            = $AF0D1E
=$af0d1f				SP35_Y_POS_H            = $AF0D1F
=$af0d20				SP36_CONTROL_REG        = $AF0D20
=$af0d21				SP36_ADDY_PTR_L         = $AF0D21
=$af0d22				SP36_ADDY_PTR_M         = $AF0D22
=$af0d23				SP36_ADDY_PTR_H         = $AF0D23
=$af0d24				SP36_X_POS_L            = $AF0D24
=$af0d25				SP36_X_POS_H            = $AF0D25
=$af0d26				SP36_Y_POS_L            = $AF0D26
=$af0d27				SP36_Y_POS_H            = $AF0D27
=$af0d28				SP37_CONTROL_REG        = $AF0D28
=$af0d29				SP37_ADDY_PTR_L         = $AF0D29
=$af0d2a				SP37_ADDY_PTR_M         = $AF0D2A
=$af0d2b				SP37_ADDY_PTR_H         = $AF0D2B
=$af0d2c				SP37_X_POS_L            = $AF0D2C
=$af0d2d				SP37_X_POS_H            = $AF0D2D
=$af0d2e				SP37_Y_POS_L            = $AF0D2E
=$af0d2f				SP37_Y_POS_H            = $AF0D2F
=$af0d30				SP38_CONTROL_REG        = $AF0D30
=$af0d31				SP38_ADDY_PTR_L         = $AF0D31
=$af0d32				SP38_ADDY_PTR_M         = $AF0D32
=$af0d33				SP38_ADDY_PTR_H         = $AF0D33
=$af0d34				SP38_X_POS_L            = $AF0D34
=$af0d35				SP38_X_POS_H            = $AF0D35
=$af0d36				SP38_Y_POS_L            = $AF0D36
=$af0d37				SP38_Y_POS_H            = $AF0D37
=$af0d38				SP39_CONTROL_REG        = $AF0D38
=$af0d39				SP39_ADDY_PTR_L         = $AF0D39
=$af0d3a				SP39_ADDY_PTR_M         = $AF0D3A
=$af0d3b				SP39_ADDY_PTR_H         = $AF0D3B
=$af0d3c				SP39_X_POS_L            = $AF0D3C
=$af0d3d				SP39_X_POS_H            = $AF0D3D
=$af0d3e				SP39_Y_POS_L            = $AF0D3E
=$af0d3f				SP39_Y_POS_H            = $AF0D3F
=$af0d40				SP40_CONTROL_REG        = $AF0D40
=$af0d41				SP40_ADDY_PTR_L         = $AF0D41
=$af0d42				SP40_ADDY_PTR_M         = $AF0D42
=$af0d43				SP40_ADDY_PTR_H         = $AF0D43
=$af0d44				SP40_X_POS_L            = $AF0D44
=$af0d45				SP40_X_POS_H            = $AF0D45
=$af0d46				SP40_Y_POS_L            = $AF0D46
=$af0d47				SP40_Y_POS_H            = $AF0D47
=$af0d48				SP41_CONTROL_REG        = $AF0D48
=$af0d49				SP41_ADDY_PTR_L         = $AF0D49
=$af0d4a				SP41_ADDY_PTR_M         = $AF0D4A
=$af0d4b				SP41_ADDY_PTR_H         = $AF0D4B
=$af0d4c				SP41_X_POS_L            = $AF0D4C
=$af0d4d				SP41_X_POS_H            = $AF0D4D
=$af0d4e				SP41_Y_POS_L            = $AF0D4E
=$af0d4f				SP41_Y_POS_H            = $AF0D4F
=$af0d50				SP42_CONTROL_REG        = $AF0D50
=$af0d51				SP42_ADDY_PTR_L         = $AF0D51
=$af0d52				SP42_ADDY_PTR_M         = $AF0D52
=$af0d53				SP42_ADDY_PTR_H         = $AF0D53
=$af0d54				SP42_X_POS_L            = $AF0D54
=$af0d55				SP42_X_POS_H            = $AF0D55
=$af0d56				SP42_Y_POS_L            = $AF0D56
=$af0d57				SP42_Y_POS_H            = $AF0D57
=$af0d58				SP43_CONTROL_REG        = $AF0D58
=$af0d59				SP43_ADDY_PTR_L         = $AF0D59
=$af0d5a				SP43_ADDY_PTR_M         = $AF0D5A
=$af0d5b				SP43_ADDY_PTR_H         = $AF0D5B
=$af0d5c				SP43_X_POS_L            = $AF0D5C
=$af0d5d				SP43_X_POS_H            = $AF0D5D
=$af0d5e				SP43_Y_POS_L            = $AF0D5E
=$af0d5f				SP43_Y_POS_H            = $AF0D5F
=$af0d60				SP44_CONTROL_REG        = $AF0D60
=$af0d61				SP44_ADDY_PTR_L         = $AF0D61
=$af0d62				SP44_ADDY_PTR_M         = $AF0D62
=$af0d63				SP44_ADDY_PTR_H         = $AF0D63
=$af0d64				SP44_X_POS_L            = $AF0D64
=$af0d65				SP44_X_POS_H            = $AF0D65
=$af0d66				SP44_Y_POS_L            = $AF0D66
=$af0d67				SP44_Y_POS_H            = $AF0D67
=$af0d68				SP45_CONTROL_REG        = $AF0D68
=$af0d69				SP45_ADDY_PTR_L         = $AF0D69
=$af0d6a				SP45_ADDY_PTR_M         = $AF0D6A
=$af0d6b				SP45_ADDY_PTR_H         = $AF0D6B
=$af0d6c				SP45_X_POS_L            = $AF0D6C
=$af0d6d				SP45_X_POS_H            = $AF0D6D
=$af0d6e				SP45_Y_POS_L            = $AF0D6E
=$af0d6f				SP45_Y_POS_H            = $AF0D6F
=$af0d70				SP46_CONTROL_REG        = $AF0D70
=$af0d71				SP46_ADDY_PTR_L         = $AF0D71
=$af0d72				SP46_ADDY_PTR_M         = $AF0D72
=$af0d73				SP46_ADDY_PTR_H         = $AF0D73
=$af0d74				SP46_X_POS_L            = $AF0D74
=$af0d75				SP46_X_POS_H            = $AF0D75
=$af0d76				SP46_Y_POS_L            = $AF0D76
=$af0d77				SP46_Y_POS_H            = $AF0D77
=$af0d78				SP47_CONTROL_REG        = $AF0D78
=$af0d79				SP47_ADDY_PTR_L         = $AF0D79
=$af0d7a				SP47_ADDY_PTR_M         = $AF0D7A
=$af0d7b				SP47_ADDY_PTR_H         = $AF0D7B
=$af0d7c				SP47_X_POS_L            = $AF0D7C
=$af0d7d				SP47_X_POS_H            = $AF0D7D
=$af0d7e				SP47_Y_POS_L            = $AF0D7E
=$af0d7f				SP47_Y_POS_H            = $AF0D7F
=$af0d80				SP48_CONTROL_REG        = $AF0D80
=$af0d81				SP48_ADDY_PTR_L         = $AF0D81
=$af0d82				SP48_ADDY_PTR_M         = $AF0D82
=$af0d83				SP48_ADDY_PTR_H         = $AF0D83
=$af0d84				SP48_X_POS_L            = $AF0D84
=$af0d85				SP48_X_POS_H            = $AF0D85
=$af0d86				SP48_Y_POS_L            = $AF0D86
=$af0d87				SP48_Y_POS_H            = $AF0D87
=$af0d88				SP49_CONTROL_REG        = $AF0D88
=$af0d89				SP49_ADDY_PTR_L         = $AF0D89
=$af0d8a				SP49_ADDY_PTR_M         = $AF0D8A
=$af0d8b				SP49_ADDY_PTR_H         = $AF0D8B
=$af0d8c				SP49_X_POS_L            = $AF0D8C
=$af0d8d				SP49_X_POS_H            = $AF0D8D
=$af0d8e				SP49_Y_POS_L            = $AF0D8E
=$af0d8f				SP49_Y_POS_H            = $AF0D8F
=$af0d90				SP50_CONTROL_REG        = $AF0D90
=$af0d91				SP50_ADDY_PTR_L         = $AF0D91
=$af0d92				SP50_ADDY_PTR_M         = $AF0D92
=$af0d93				SP50_ADDY_PTR_H         = $AF0D93
=$af0d94				SP50_X_POS_L            = $AF0D94
=$af0d95				SP50_X_POS_H            = $AF0D95
=$af0d96				SP50_Y_POS_L            = $AF0D96
=$af0d97				SP50_Y_POS_H            = $AF0D97
=$af0d98				SP51_CONTROL_REG        = $AF0D98
=$af0d99				SP51_ADDY_PTR_L         = $AF0D99
=$af0d9a				SP51_ADDY_PTR_M         = $AF0D9A
=$af0d9b				SP51_ADDY_PTR_H         = $AF0D9B
=$af0d9c				SP51_X_POS_L            = $AF0D9C
=$af0d9d				SP51_X_POS_H            = $AF0D9D
=$af0d9e				SP51_Y_POS_L            = $AF0D9E
=$af0d9f				SP51_Y_POS_H            = $AF0D9F
=$af0da0				SP52_CONTROL_REG        = $AF0DA0
=$af0da1				SP52_ADDY_PTR_L         = $AF0DA1
=$af0da2				SP52_ADDY_PTR_M         = $AF0DA2
=$af0da3				SP52_ADDY_PTR_H         = $AF0DA3
=$af0da4				SP52_X_POS_L            = $AF0DA4
=$af0da5				SP52_X_POS_H            = $AF0DA5
=$af0da6				SP52_Y_POS_L            = $AF0DA6
=$af0da7				SP52_Y_POS_H            = $AF0DA7
=$af0da8				SP53_CONTROL_REG        = $AF0DA8
=$af0da9				SP53_ADDY_PTR_L         = $AF0DA9
=$af0daa				SP53_ADDY_PTR_M         = $AF0DAA
=$af0dab				SP53_ADDY_PTR_H         = $AF0DAB
=$af0dac				SP53_X_POS_L            = $AF0DAC
=$af0dad				SP53_X_POS_H            = $AF0DAD
=$af0dae				SP53_Y_POS_L            = $AF0DAE
=$af0daf				SP53_Y_POS_H            = $AF0DAF
=$af0db0				SP54_CONTROL_REG        = $AF0DB0
=$af0db1				SP54_ADDY_PTR_L         = $AF0DB1
=$af0db2				SP54_ADDY_PTR_M         = $AF0DB2
=$af0db3				SP54_ADDY_PTR_H         = $AF0DB3
=$af0db4				SP54_X_POS_L            = $AF0DB4
=$af0db5				SP54_X_POS_H            = $AF0DB5
=$af0db6				SP54_Y_POS_L            = $AF0DB6
=$af0db7				SP54_Y_POS_H            = $AF0DB7
=$af0db8				SP55_CONTROL_REG        = $AF0DB8
=$af0db9				SP55_ADDY_PTR_L         = $AF0DB9
=$af0dba				SP55_ADDY_PTR_M         = $AF0DBA
=$af0dbb				SP55_ADDY_PTR_H         = $AF0DBB
=$af0dbc				SP55_X_POS_L            = $AF0DBC
=$af0dbd				SP55_X_POS_H            = $AF0DBD
=$af0dbe				SP55_Y_POS_L            = $AF0DBE
=$af0dbf				SP55_Y_POS_H            = $AF0DBF
=$af0dc0				SP56_CONTROL_REG        = $AF0DC0
=$af0dc1				SP56_ADDY_PTR_L         = $AF0DC1
=$af0dc2				SP56_ADDY_PTR_M         = $AF0DC2
=$af0dc3				SP56_ADDY_PTR_H         = $AF0DC3
=$af0dc4				SP56_X_POS_L            = $AF0DC4
=$af0dc5				SP56_X_POS_H            = $AF0DC5
=$af0dc6				SP56_Y_POS_L            = $AF0DC6
=$af0dc7				SP56_Y_POS_H            = $AF0DC7
=$af0dc8				SP57_CONTROL_REG        = $AF0DC8
=$af0dc9				SP57_ADDY_PTR_L         = $AF0DC9
=$af0dca				SP57_ADDY_PTR_M         = $AF0DCA
=$af0dcb				SP57_ADDY_PTR_H         = $AF0DCB
=$af0dcc				SP57_X_POS_L            = $AF0DCC
=$af0dcd				SP57_X_POS_H            = $AF0DCD
=$af0dce				SP57_Y_POS_L            = $AF0DCE
=$af0dcf				SP57_Y_POS_H            = $AF0DCF
=$af0dd0				SP58_CONTROL_REG        = $AF0DD0
=$af0dd1				SP58_ADDY_PTR_L         = $AF0DD1
=$af0dd2				SP58_ADDY_PTR_M         = $AF0DD2
=$af0dd3				SP58_ADDY_PTR_H         = $AF0DD3
=$af0dd4				SP58_X_POS_L            = $AF0DD4
=$af0dd5				SP58_X_POS_H            = $AF0DD5
=$af0dd6				SP58_Y_POS_L            = $AF0DD6
=$af0dd7				SP58_Y_POS_H            = $AF0DD7
=$af0dd8				SP59_CONTROL_REG        = $AF0DD8
=$af0dd9				SP59_ADDY_PTR_L         = $AF0DD9
=$af0dda				SP59_ADDY_PTR_M         = $AF0DDA
=$af0ddb				SP59_ADDY_PTR_H         = $AF0DDB
=$af0ddc				SP59_X_POS_L            = $AF0DDC
=$af0ddd				SP59_X_POS_H            = $AF0DDD
=$af0dde				SP59_Y_POS_L            = $AF0DDE
=$af0ddf				SP59_Y_POS_H            = $AF0DDF
=$af0de0				SP60_CONTROL_REG        = $AF0DE0
=$af0de1				SP60_ADDY_PTR_L         = $AF0DE1
=$af0de2				SP60_ADDY_PTR_M         = $AF0DE2
=$af0de3				SP60_ADDY_PTR_H         = $AF0DE3
=$af0de4				SP60_X_POS_L            = $AF0DE4
=$af0de5				SP60_X_POS_H            = $AF0DE5
=$af0de6				SP60_Y_POS_L            = $AF0DE6
=$af0de7				SP60_Y_POS_H            = $AF0DE7
=$af0de8				SP61_CONTROL_REG        = $AF0DE8
=$af0de9				SP61_ADDY_PTR_L         = $AF0DE9
=$af0dea				SP61_ADDY_PTR_M         = $AF0DEA
=$af0deb				SP61_ADDY_PTR_H         = $AF0DEB
=$af0dec				SP61_X_POS_L            = $AF0DEC
=$af0ded				SP61_X_POS_H            = $AF0DED
=$af0dee				SP61_Y_POS_L            = $AF0DEE
=$af0def				SP61_Y_POS_H            = $AF0DEF
=$af0df0				SP62_CONTROL_REG        = $AF0DF0
=$af0df1				SP62_ADDY_PTR_L         = $AF0DF1
=$af0df2				SP62_ADDY_PTR_M         = $AF0DF2
=$af0df3				SP62_ADDY_PTR_H         = $AF0DF3
=$af0df4				SP62_X_POS_L            = $AF0DF4
=$af0df5				SP62_X_POS_H            = $AF0DF5
=$af0df6				SP62_Y_POS_L            = $AF0DF6
=$af0df7				SP62_Y_POS_H            = $AF0DF7
=$af0df8				SP63_CONTROL_REG        = $AF0DF8
=$af0df9				SP63_ADDY_PTR_L         = $AF0DF9
=$af0dfa				SP63_ADDY_PTR_M         = $AF0DFA
=$af0dfb				SP63_ADDY_PTR_H         = $AF0DFB
=$af0dfc				SP63_X_POS_L            = $AF0DFC
=$af0dfd				SP63_X_POS_H            = $AF0DFD
=$af0dfe				SP63_Y_POS_L            = $AF0DFE
=$af0dff				SP63_Y_POS_H            = $AF0DFF

;******  Return to file: src\C256/vicky_def.s


;******  Return to file: src\C256/mmap_c256.s

=$00					BASIC_BANK = $00            ; Memory bank for default purposes
=$004c00				IOBUF = $004C00             ; A buffer for I/O operations
=$004d00				ARRIDXBUF = $004D00         ; The array index buffer used for array references
=$004e00				TEMPBUF = $004E00           ; Temporary buffer for string processing, etc.
=$004f00				INPUTBUF = $004F00          ; Starting address of the line input buffer (one page)
=$005000				RETURN_BOT = $005000        ; Starting address of the return stack
=$005fff				RETURN_TOP = $005FFF        ; Ending address of the return stack
=$006000				ARGUMENT_BOT = $006000      ; Starting address of the argument stack
=$006fff				ARGUMENT_TOP = $006FFF      ; Ending address of the argument stack
=$007000				OPERATOR_BOT = $007000      ; Starting address of the operator stack
=$007fff				OPERATOR_TOP = $007FFF      ; Ending address of the operator stack
=$b00000				VRAM = $B00000              ; Start of video RAM
=$010000				LOADBLOCK = $010000         ; File loading will start here
=$360000				BASIC_BOT := $360000         ; Starting point for BASIC programs
=$37ffff				HEAP_TOP := $37FFFF          ; Starting point of the heap
=$160000				BASIC_BOT := $160000         ; Starting point for BASIC programs
=$17ffff				HEAP_TOP := $17FFFF          ; Starting point of the heap

;******  Return to file: src\memorymap.s

=$00ffe6				VBRK = $00FFE6          ; Vector for the native-mode BRK vector
=$1ad000				DATA_BLOCK = *
=$000800				GLOBAL_VARS = *
>0800					BIP         .dword ?    ; Pointer to the current byte in the current BASIC program
>0804					BIPPREV     .dword ?    ; Pointer to the previous bytein the current BASIC program
>0808					INDEX       .dword ?    ; A temporary pointer
>080c					SCRATCH     .dword ?    ; A temporary scratch variable
>0810					SCRATCH2    .dword ?    ; A temporary scratch variable
>0814					            .word  ?	; Need a few more bits for BCD conversion
>0816					STRPTR      .dword ?    ; A temporary pointer for strings
>081a					CURLINE     .dword ?    ; Pointer to the current input line needing tokenization
>081e					CURTOKLEN   .byte ?     ; Length of the text of the current token
>081f					ARGUMENTSP  .word ?     ; Pointer to the top of the argument stack
>0821					OPERATORSP  .word ?     ; Pointer to the top of the operator stack
>0823					ARGUMENT1   .dword ?    ; Argument 1 for expression calculations
>0827					ARGTYPE1    .byte ?     ; Type code for argument 1 (integer, float, string)
>0828					SIGN1       .byte ?     ; Temporary sign marker for argument 1
>0829					ARGUMENT2   .dword ?    ; Argument 2 for expression calculations
>082d					ARGTYPE2    .byte ?     ; Type code for argument 2 (integer, float, string)
>082e					SIGN2       .byte ?     ; Temporary sign marker for argument 1
>082f					JMP16PTR    .word ?     ; Pointer for 16-bit indirect jumps (within BASIC816's code base)
>0831					GOSUBDEPTH  .word ?     ; Number of GOSUBs on the stack
>0833					RETURNSP    .word ?     ; Pointer to the top of the return stack
>0835					SKIPNEST    .byte ?     ; Flag to indicate if token seeking should respect nesting (MSB set if so)
>0836					NESTING     .byte ?     ; Counter of the depth of lexical nesting for FOR/NEXT, DO/LOOP
>0837					TARGETTOK   .byte ?     ; When searching for a token, TARGETTOK is the token to find
>0838					DATABIP     .dword ?    ; Pointer to the next data element for READ statements
>083c					DATALINE    .dword ?    ; Pointer to the current line for a DATA statement
>0840					SAVEBIP     .dword ?    ; Spot to save BIP temporarily
>0844					SAVELINE    .dword ?    ; Spot to save CURLINE temporarily
=$000848				MONITOR_VARS = *
>0848					MCMDADDR    .long ?     ;3 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
>084b					MCMP_TEXT   .long ?     ;3 Bytes Address of symbol being evaluated for COMPARE routine
>084e					MCMP_LEN    .word ?     ;2 Bytes Length of symbol being evaluated for COMPARE routine
>0850					MCMD        .long ?     ;3 Bytes Address of the current command/function string
>0853					MCMD_LEN    .word ?     ;2 Bytes Length of the current command/function string
>0855					MARG1       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command
>0859					MARG2       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>085d					MARG3       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0861					MARG4       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0865					MARG5       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0869					MARG6       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>086d					MARG7       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0871					MARG8       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0875					MARG9       .dword ?    ;4 Bytes First command argument.
>0879					MARG_LEN    .byte ?     ;1 Byte count of the number of arguments passed
>087a					MCURSOR     .dword ?    ;4 Bytes Pointer to the current memory location for disassembly, memory dump, etc.
>087e					MLINEBUF    .fill 17    ;17 Byte buffer for dumping memory (TODO: could be moved to a general string scratch area)
>088f					MCOUNT      .long ?     ;2 Byte counter
>0892					MTEMP       .dword ?    ;4 Bytes of temporary space
>0896					MCPUSTAT    .byte ?     ;1 Byte to represent what the disassembler thinks the processor MX bits are
>0897					MADDR_MODE  .byte ?     ;1 Byte address mode found by the assembler
>0898					MPARSEDNUM  .dword ?    ;4 Bytes to store a parsed number
>089c					MMNEMONIC   .word ?     ;2 Byte address of mnemonic found by the assembler
>089e					MTEMPPTR    .dword ?    ;4 Byte temporary pointer
>08a2					MJUMPINST   .byte ?     ;1 Byte JSL opcode
>08a3					MJUMPADDR   .long ?     ;3 Byte address for JSL
=$000823				MANTISSA1 = ARGUMENT1
=$000826				EXPONENT1 = ARGUMENT1+3

;******  Return to file: src\basic816.s


;******  Processing file: src\macros.s


;******  Return to file: src\basic816.s

.1a0000	5c 37 8a 1a	jmp $1a8a37	COLDBOOT        JML START               ; Entry point to boot up BASIC from scratch
.1a0004	5c 49 70 1a	jmp $1a7049	MONITOR         JML IMONITOR            ; Entry point to the machine language monitor
.1a0008	5c 3b 27 1a	jmp $1a273b	READLINE        JML IREADLINE           ; Wait for the user to enter a line of text (for programming input)
.1a000c	5c ba 02 1a	jmp $1a02ba	SCRCOPYLINE     JML ISCRCPYLINE         ; Copy the line on the screen the user just input to INPUTBUF
.1a0010	5c 58 00 1a	jmp $1a0058	INPUTLINE       JML IINPUTLINE          ; Read a single line of text from the user, and copy it to TEMPBUF (for INPUT statement)
.1a0014	5c b8 00 1a	jmp $1a00b8	GETKEY          JML IGETKEY             ; Wait for a keypress by the user and return the ASCII code in A
.1a0018	5c d4 03 1a	jmp $1a03d4	PRINTC          JML IPRINTC             ; Print the character in A to the console
.1a001c	5c 5e 02 1a	jmp $1a025e	SHOWCURSOR      JML ISHOWCURSOR         ; Set cursor visibility: A=0, hide... A<>0, show.
.1a0020	5c 79 02 1a	jmp $1a0279	CURSORXY        JML ICURSORXY           ; Set the position of the cursor to (X, Y)
.1a0024	5c 80 02 1a	jmp $1a0280	CLSCREEN        JML ICLSCREEN           ; Clear the screen

;******  Processing file: src\bios.s


;******  Processing file: src\membuffers.s

>08a6					OBUFFER     .long ?     ; Pointer to the current text memory buffer for output
>08a9					OBUFFSIZE   .word ?     ; Maximum size of output text memory buffer
>08ab					OBUFFIDX    .word ?     ; Index into the current output buffer
>08ad					IBUFFER     .long ?     ; Pointer to the current text memory buffer for input
>08b0					IBUFFSIZE   .word ?     ; Number of bytes written to the buffer
>08b2					IBUFFIDX    .word ?     ; Index into the current input buffer (next available character)
.1a0028					OBUFF_PUTC
.1a0028	0b		phd		                PHD
.1a0029	08		php		                PHP
.1a002a	08		php		            PHP
.1a002b	c2 20		rep #$20	            REP #$20
.1a002d	48		pha		            PHA
.1a002e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0031	5b		tcd		            TCD
.1a0032	68		pla		            PLA
.1a0033	28		plp		            PLP
.1a0034	e2 20		sep #$20	            SEP #$20
.1a0036	85 b5		sta $08b5	                STA SAVE_A
.1a0038	c2 20		rep #$20	            REP #$20
.1a003a	a5 a6		lda $08a6	                LDA OBUFFER
.1a003c	d0 06		bne $1a0044	                BNE has_buffer
.1a003e	e2 20		sep #$20	            SEP #$20
.1a0040	a5 a8		lda $08a8	                LDA OBUFFER+2
.1a0042	f0 11		beq $1a0055	                BEQ done
.1a0044					has_buffer
.1a0044	c2 10		rep #$10	            REP #$10
.1a0046	a4 ab		ldy $08ab	                LDY OBUFFIDX        ; Check to make sure there is room
.1a0048	c4 a9		cpy $08a9	                CPY OBUFFSIZE
.1a004a	f0 09		beq $1a0055	                BEQ done            ; If not, exit silently
.1a004c	e2 20		sep #$20	            SEP #$20
.1a004e	a5 b5		lda $08b5	                LDA SAVE_A
.1a0050	97 a6		sta [$08a6],y	                STA [OBUFFER],Y     ; Write the character to the buffer
.1a0052	c8		iny		                INY                 ; Increment the index
.1a0053	84 ab		sty $08ab	                STY OBUFFIDX
.1a0055	28		plp		done            PLP
.1a0056	2b		pld		                PLD
.1a0057	60		rts		            RTS

;******  Return to file: src\bios.s


;******  Processing file: src\C256/io_c256.s


;******  Processing file: src\C256/kernel_c256.s

=$00104c				FK_GETCHW           = $00104c ; Get a character from the input channel. Waits until data received. A=0 and Carry=1 if no data is wating
=$001018				FK_PUTC             = $001018 ; Print a character to the currently selected channel
=$00101c				FK_PUTS             = $00101C ; Print a string to the currently selected channel
=$001080				FK_PRINTAH          = $001080 ; Prints hex value in A. Printed value is 2 wide if M flag is 1, 4 wide if M=0
=$001084				FK_LOCATE           = $001084 ; Reposition the cursor to row Y column X
=$001078				FK_IPRINTH          = $001078 ; Print a HEX string
=$00103c				FK_SETOUT           = $00103c ; Select an output channel
=$00112c				FK_SETSIZES         = $00112C ; Set the text screen size variables based on the border and screen resolution.
=$0010f0				FK_OPEN             = $0010F0 ; open a file for reading/writing/creating
=$0010f4				FK_CREATE           = $0010F4 ; create a new file
=$0010f8				FK_CLOSE            = $0010F8 ; close a file (make sure last cluster is written)
=$0010fc				FK_WRITE            = $0010FC ; write the current cluster to the file
=$001100				FK_READ             = $001100 ; read the next cluster from the file
=$001104				FK_DELETE           = $001104 ; delete a file / directory
=$001108				FK_DIROPEN          = $001108 ; open a directory and seek the first directory entry
=$00110c				FK_DIRNEXT          = $00110C ; seek to the next directory of an open directory
=$001110				FK_DIRREAD          = $001110 ; Read the directory entry for the specified file
=$001114				FK_DIRWRITE         = $001114 ; Write any changes in the current directory cluster back to the drive
=$001118				FK_LOAD             = $001118 ; load a binary file into memory, supports multiple file formats
=$00111c				FK_SAVE             = $00111C ; Save memory to a binary file
=$001124				FK_RUN              = $001124 ; Load and run an executable binary file
=$001130				FK_COPY             = $001130 ; Copy a file
=$001120				FK_CMDBLOCK         = $001120 ; Send a command to a block device
=$00113c				FK_TESTBREAK        = $00113C ; Check if BREAK was pressed recently by the user (C is set if true, clear if false)
=$001028				FK_GETSCANCODE      = $001028 ; Get the next scancode from the keyboard (A = scancode, 0 if none available)
=$001144				FK_READVRAM         = $001144 ; Read a byte from video RAM at B:X
=0					CHAN_CONSOLE = 0
=1					CHAN_COM1 = 1
=2					CHAN_COM2 = 2

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/RTC_inc.s

=$af0800				RTC_SEC       = $AF0800 ;Seconds Register
=$af0801				RTC_SEC_ALARM = $AF0801 ;Seconds Alarm Register
=$af0802				RTC_MIN       = $AF0802 ;Minutes Register
=$af0803				RTC_MIN_ALARM = $AF0803 ;Minutes Alarm Register
=$af0804				RTC_HRS       = $AF0804 ;Hours Register
=$af0805				RTC_HRS_ALARM = $AF0805 ;Hours Alarm Register
=$af0806				RTC_DAY       = $AF0806 ;Day Register
=$af0807				RTC_DAY_ALARM = $AF0807 ;Day Alarm Register
=$af0808				RTC_DOW       = $AF0808 ;Day of Week Register
=$af0809				RTC_MONTH     = $AF0809 ;Month Register
=$af080a				RTC_YEAR      = $AF080A ;Year Register
=$af080b				RTC_RATES     = $AF080B ;Rates Register
=$af080c				RTC_ENABLE    = $AF080C ;Enables Register
=$af080d				RTC_FLAGS     = $AF080D ;Flags Register
=$af080e				RTC_CTRL      = $AF080E ;Control Register
=$af080f				RTC_CENTURY   = $AF080F ;Century Register

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/keyboard.s


;******  Processing file: src\C256/keyboard_def.s

=$af1064				STATUS_PORT 	        =	$AF1064
=$af1060				KBD_OUT_BUF 	        =	$AF1060
=$af1060				KBD_INPT_BUF	        = $AF1060
=$af1064				KBD_CMD_BUF		        = $AF1064
=$af1060				KBD_DATA_BUF	        = $AF1060
=$af1060				PORT_A			          =	$AF1060
=$af1061				PORT_B			          =	$AF1061
=$01					OUT_BUF_FULL  =	$01
=$02					INPT_BUF_FULL	=	$02
=$04					SYS_FLAG		  =	$04
=$08					CMD_DATA		  =	$08
=$10					KEYBD_INH     =	$10
=$20					TRANS_TMOUT	  =	$20
=$40					RCV_TMOUT		  =	$40
=$80					PARITY_EVEN		=	$80
=$10					INH_KEYBOARD	=	$10
=$ae					KBD_ENA			  =	$AE
=$ad					KBD_DIS			  =	$AD
=$f1					KB_MENU			  =	$F1
=$f4					KB_ENABLE		  =	$F4
=$f7					KB_MAKEBREAK  =	$F7
=$fe					KB_ECHO			  =	$FE
=$ff					KB_RESET		  =	$FF
=$ed					KB_LED_CMD		=	$ED
=$aa					KB_OK			    =	$AA
=$fa					KB_ACK			  =	$FA
=$ff					KB_OVERRUN		=	$FF
=$fe					KB_RESEND		  =	$FE
=$f0					KB_BREAK		  =	$F0
=$10					KB_FA			    =	$10
=$20					KB_FE			    =	$20
=$40					KB_PR_LED		  =	$40
=$01					KB_SCROLL_LOCK      = $01
=$02					KB_NUM_LOCK         = $02
=$04					KB_CAPS_LOCK        = $04
=2					ANSI_IN_INS = 2     ; ANSI input code for INSERT
=3					ANSI_IN_DEL = 3     ; ANSI input code for DELETE
=24					ANSI_IN_F12 = 24    ; ANSI input code for F12
=8					ANSI_IN_CTRL = 8    ; ANSI input modifier flag for CTRL

;******  Return to file: src\C256/keyboard.s

.1a0058					IINPUTLINE
.1a0058	08		php		                PHP
.1a0059	c2 10		rep #$10	            REP #$10
.1a005b	e2 20		sep #$20	            SEP #$20
.1a005d	a9 01		lda #$01	                LDA #1              ; Show the cursor
.1a005f	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a0062	a2 00 00	ldx #$0000	                LDX #0
.1a0065	a9 00		lda #$00	                LDA #0
.1a0067	9f 00 4c 00	sta $004c00,x	zero_loop       STA @lIOBUF,X
.1a006b	e8		inx		                INX
.1a006c	e0 00 01	cpx #$0100	                CPX #$100
.1a006f	d0 f6		bne $1a0067	                BNE zero_loop
.1a0071	a2 00 00	ldx #$0000	                LDX #0
.1a0074					getchar
.1a0074	20 14 00	jsr $1a0014	            JSR GETKEY
.1a0077	c9 0d		cmp #$0d	                CMP #CHAR_CR        ; Got a CR?
.1a0079	d0 03		bne $1a007e	                BNE not_cr
.1a007b	4c b1 00	jmp $1a00b1	                JMP endofline       ; Yes: we're done
.1a007e					not_cr
.1a007e	c9 08		cmp #$08	not_right       CMP #CHAR_BS        ; Is it a backspace?
.1a0080	d0 1a		bne $1a009c	                BNE not_bs
.1a0082	e0 00 00	cpx #$0000	                CPX #0              ; Are we at the beginning of the line?
.1a0085	f0 ed		beq $1a0074	                BEQ getchar         ; yes: ignore the backspace
.1a0087	da		phx		                PHX                 ; Save the cursor position
.1a0088	bf 01 4c 00	lda $004c01,x	clr_loop        LDA @lIOBUF+1,X     ; Get the character above
.1a008c	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the current position
.1a0090	f0 06		beq $1a0098	                BEQ done_clr        ; If we copied a NUL, we're done copying
.1a0092	e8		inx		                INX                 ; Otherwise, keep copying down
.1a0093	e0 ff 00	cpx #$00ff	                CPX #$FF            ; Until we're at the end of the buffer
.1a0096	d0 f0		bne $1a0088	                BNE clr_loop
.1a0098	fa		plx		done_clr        PLX                 ; Restore the cursor position
.1a0099	ca		dex		                DEX                 ; No: move the cursor left
.1a009a	80 0e		bra $1a00aa	                BRA print_bs        ; And print the backspace
.1a009c	c9 20		cmp #$20	not_bs          CMP #$20            ; Is it in range 00 -- 1F?
.1a009e	90 d4		bcc $1a0074	                BLT getchar         ; Yes: ignore it
.1a00a0	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the input buffer
.1a00a4	e8		inx		                INX                 ; Move the cursor forward
.1a00a5					echo
.1a00a5	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00a8	80 ca		bra $1a0074	                BRA getchar         ; And get another...
.1a00aa	a9 08		lda #$08	print_bs        LDA #CHAR_BS        ; Backspace character...
.1a00ac	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00af	80 c3		bra $1a0074	                BRA getchar         ; And get another...
.1a00b1	a9 00		lda #$00	endofline       LDA #0              ; Hide the cursor
.1a00b3	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a00b6	28		plp		                PLP
.1a00b7	60		rts		            RTS
.1a00b8					IGETKEY
.1a00b8	da		phx		                PHX
.1a00b9	5a		phy		                PHY
.1a00ba	8b		phb		                PHB
.1a00bb	0b		phd		                PHD
.1a00bc	08		php		                PHP
.1a00bd	22 4c 10 00	jsl $00104c	                JSL FK_GETCHW
.1a00c1	28		plp		                PLP
.1a00c2	2b		pld		                PLD
.1a00c3	ab		plb		                PLB
.1a00c4	7a		ply		                PLY
.1a00c5	fa		plx		                PLX
.1a00c6	60		rts		            RTS
=0					GK_ST_INIT = 0      ; GETKEYE state: initial
=1					GK_ST_ESC = 1       ; GETKEYE state: ESC seen
=2					GK_ST_CSI = 2       ; GETKEYE state: CSI "ESC[" seen
=3					GK_ST_CODE = 3      ; GETKEYE state: We're at the command code in the sequence
=4					GK_ST_MODS = 4      ; GETKEYE state: We're at the modifier code in the sequence
.1a00c7					SEND_ANSI
.1a00c7	08		php		                PHP
.1a00c8	e2 30		sep #$30	            SEP #$30
.1a00ca	48		pha		                PHA
.1a00cb	a9 1b		lda #$1b	                LDA #CHAR_ESC           ; Print ESC
.1a00cd	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00d0	a9 5b		lda #$5b	                LDA #'['                ; Print [
.1a00d2	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00d5	68		pla		                PLA                     ; Print the command code
.1a00d6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00d9	28		plp		                PLP
.1a00da	60		rts		            RTS
.1a00db					GETKEYE
.1a00db	0b		phd		                PHD
.1a00dc	8b		phb		                PHB
.1a00dd	08		php		                PHP
.1a00de	08		php		            PHP
.1a00df	e2 20		sep #$20	            SEP #$20
.1a00e1	48		pha		            PHA
.1a00e2	a9 00		lda #$00	            LDA #0
.1a00e4	48		pha		            PHA
.1a00e5	ab		plb		            PLB
.1a00e6	68		pla		            PLA
.1a00e7	28		plp		            PLP
.1a00e8	08		php		            PHP
.1a00e9	c2 20		rep #$20	            REP #$20
.1a00eb	48		pha		            PHA
.1a00ec	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a00ef	5b		tcd		            TCD
.1a00f0	68		pla		            PLA
.1a00f1	28		plp		            PLP
.1a00f2					locals
>0001					l_character     .byte ?                 ; The character returned by the input stream
>0002					l_state         .byte ?                 ; Current state of the input parser
>0003					l_code          .byte ?                 ; Code number for any escaped input sequence
>0004					l_modifiers     .byte ?                 ; Modifier bit field for any escaped input sequence
.1a00f2	c2 20		rep #$20	            REP #$20
.1a00f4	3b		tsc		            TSC
.1a00f5	38		sec		            SEC
.1a00f6	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.1a00f9	1b		tcs		            TCS
.1a00fa	e2 20		sep #$20	            SEP #$20
.1a00fc	a9 00		lda #$00	get_reset       LDA #0                  ; Initialize state, code, and modifiers
.1a00fe	83 02		sta $02,s	                STA l_state
.1a0100	83 03		sta $03,s	                STA l_code
.1a0102	83 04		sta $04,s	                STA l_modifiers
.1a0104					loop
.1a0104	20 14 00	jsr $1a0014	            JSR GETKEY
.1a0107	c9 00		cmp #$00	                CMP #0                  ; Is it 0?
.1a0109	f0 f9		beq $1a0104	                BEQ loop                ; Yes: keep waiting
.1a010b	83 01		sta $01,s	                STA l_character         ; Save the character
.1a010d	a3 02		lda $02,s	                LDA l_state             ; What is the current state?
.1a010f	d0 35		bne $1a0146	                BNE chk_st_esc
.1a0111	a3 01		lda $01,s	                LDA l_character         ; Get the character back
.1a0113	c9 08		cmp #$08	                CMP #CHAR_BS            ; Is it a backspace?
.1a0115	d0 0a		bne $1a0121	                BNE not_bs
.1a0117	20 18 00	jsr $1a0018	            JSR PRINTC
.1a011a	a9 50		lda #$50	                LDA #'P'
.1a011c	20 c7 00	jsr $1a00c7	            JSR SEND_ANSI
.1a011f	80 e3		bra $1a0104	                BRA loop                ; And keep waiting for a keypress
.1a0121	c9 0d		cmp #$0d	not_bs          CMP #CHAR_CR            ; Is it a carriage return?
.1a0123	f0 0a		beq $1a012f	                BEQ send                ; Yes: print and return it
.1a0125	c9 1b		cmp #$1b	                CMP #CHAR_ESC           ; Is it ESC?
.1a0127	d0 06		bne $1a012f	                BNE send                ; No: just print it out
.1a0129	a9 01		lda #$01	                LDA #GK_ST_ESC          ; Yes: move to the ESC state
.1a012b	83 02		sta $02,s	                STA l_state
.1a012d	80 d5		bra $1a0104	                BRA loop                ; And get the next character in the sequence
.1a012f					send
.1a012f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a0132	a3 01		lda $01,s	done            LDA l_character         ; Save the character so we can return it
.1a0134	85 0c		sta $080c	                STA SCRATCH
.1a0136	c2 20		rep #$20	            REP #$20
.1a0138	3b		tsc		            TSC
.1a0139	18		clc		            CLC
.1a013a	69 04 00	adc #$0004	            ADC #SIZE(locals)
.1a013d	1b		tcs		            TCS
.1a013e	e2 20		sep #$20	            SEP #$20
.1a0140	a5 0c		lda $080c	                LDA SCRATCH             ; Restore the character we're returning
.1a0142	28		plp		                PLP
.1a0143	2b		pld		                PLD
.1a0144	ab		plb		                PLB
.1a0145	60		rts		            RTS
.1a0146	c9 01		cmp #$01	chk_st_esc      CMP #GK_ST_ESC          ; Are we in the ESC state?
.1a0148	d0 10		bne $1a015a	                BNE chk_st_csi          ; No: check to see if we're in CSI state
.1a014a	a3 01		lda $01,s	                LDA l_character         ; Get the character
.1a014c	c9 5b		cmp #$5b	                CMP #'['                ; Is it "["?
.1a014e	f0 03		beq $1a0153	                BEQ go_st_csi           ; Yes: go to the CSI state
.1a0150	82 a9 ff	brl $1a00fc	                BRL get_reset           ; Reset the state machine and keep reading characters
.1a0153	a9 02		lda #$02	go_st_csi       LDA #GK_ST_CSI          ; Yes: move to the CSI state
.1a0155	83 02		sta $02,s	                STA l_state
.1a0157	82 aa ff	brl $1a0104	                BRL loop
.1a015a	c9 02		cmp #$02	chk_st_csi      CMP #GK_ST_CSI          ; Are we in the CSI state?
.1a015c	d0 29		bne $1a0187	                BNE chk_st_code         ; No: check to see if we're in the code state
.1a015e	a3 01		lda $01,s	                LDA l_character         ; Check the character
.1a0160	c9 41		cmp #$41	                CMP #'A'                ; Is it in 'A'..'D'?
.1a0162	90 0c		bcc $1a0170	                BLT not_letter
.1a0164	c9 45		cmp #$45	                CMP #'D'+1
.1a0166	b0 08		bcs $1a0170	                BGE not_letter
.1a0168	a3 01		lda $01,s	                LDA l_character         ; Yes: it's a cursor key, send the sequence to the screen
.1a016a	20 c7 00	jsr $1a00c7	            JSR SEND_ANSI
.1a016d	82 8c ff	brl $1a00fc	                BRL get_reset           ; Reset the state machine and keep reading characters
.1a0170	c9 30		cmp #$30	not_letter      CMP #'0'                ; Is it in range '0'..'9'?
.1a0172	90 10		bcc $1a0184	                BLT not_csi_digit
.1a0174	c9 3a		cmp #$3a	                CMP #'9'+1
.1a0176	b0 0c		bcs $1a0184	                BGE not_csi_digit       ; No: handle it being invalid
.1a0178	38		sec		                SEC                     ; Yes: convert to a value
.1a0179	e9 30		sbc #$30	                SBC #'0'
.1a017b	83 03		sta $03,s	                STA l_code              ; And save it to the code variable
.1a017d	a9 03		lda #$03	                LDA #GK_ST_CODE         ; Move to the CODE state
.1a017f	83 02		sta $02,s	                STA l_state
.1a0181	82 80 ff	brl $1a0104	                BRL loop
.1a0184	82 75 ff	brl $1a00fc	not_csi_digit   BRL get_reset           ; Bad sequence: reset and keep reading characters
.1a0187	c9 03		cmp #$03	chk_st_code     CMP #GK_ST_CODE         ; Is it the CODE state?
.1a0189	d0 41		bne $1a01cc	                BNE chk_st_mods         ; No: check to see if it's MODIFIERS
.1a018b	a3 01		lda $01,s	                LDA l_character         ; Check the character
.1a018d	c9 30		cmp #$30	                CMP #'0'                ; Is it in the range '0'..'9'
.1a018f	90 29		bcc $1a01ba	                BLT not_digits_2
.1a0191	c9 3a		cmp #$3a	                CMP #'9'+1
.1a0193	b0 25		bcs $1a01ba	                BGE not_digits_2
.1a0195	a3 03		lda $03,s	                LDA l_code              ; Multiply l_code by 2
.1a0197	8f 00 01 00	sta $000100	                STA @l UNSIGNED_MULT_A_LO
.1a019b	a9 00		lda #$00	                LDA #0
.1a019d	8f 01 01 00	sta $000101	                STA @l UNSIGNED_MULT_A_HI
.1a01a1	8f 03 01 00	sta $000103	                STA @l UNSIGNED_MULT_B_HI
.1a01a5	a9 0a		lda #$0a	                LDA #10
.1a01a7	8f 02 01 00	sta $000102	                STA @l UNSIGNED_MULT_B_LO
.1a01ab	a3 01		lda $01,s	                LDA l_character         ; Convert the digit to a number
.1a01ad	38		sec		                SEC
.1a01ae	e9 30		sbc #$30	                SBC #'0'
.1a01b0	18		clc		                CLC                     ; And add to l_code
.1a01b1	6f 04 01 00	adc $000104	                ADC @l UNSIGNED_MULT_AL_LO
.1a01b5	83 03		sta $03,s	                STA l_code
.1a01b7	82 4a ff	brl $1a0104	                BRL loop                ; And keep processing the sequence
.1a01ba	c9 3b		cmp #$3b	not_digits_2    CMP #';'                ; Is it the semicolon?
.1a01bc	d0 07		bne $1a01c5	                BNE not_semi
.1a01be	a9 04		lda #$04	                LDA #GK_ST_MODS         ; Yes: Move to the MODIFIERS state
.1a01c0	83 02		sta $02,s	                STA l_state
.1a01c2	82 3f ff	brl $1a0104	                BRL loop
.1a01c5	c9 7e		cmp #$7e	not_semi        CMP #'~'                ; No: Is it the tilda?
.1a01c7	f0 40		beq $1a0209	                BEQ end_sequence        ; Yes: we've gotten the end of the sequence
.1a01c9	82 30 ff	brl $1a00fc	                BRL get_reset           ; No: we've got a bad sequence... for now just reset and keep looping
.1a01cc	c9 04		cmp #$04	chk_st_mods     CMP #GK_ST_MODS         ; Are we in the MODIFIERS state?
.1a01ce	f0 03		beq $1a01d3	                BEQ do_mods
.1a01d0	82 5f ff	brl $1a0132	                BRL done                ; No: we're done
.1a01d3	a3 01		lda $01,s	do_mods         LDA l_character         ; Check the character
.1a01d5	c9 30		cmp #$30	                CMP #'0'                ; Is it in the range '0'..'9'
.1a01d7	90 29		bcc $1a0202	                BLT not_digits_3
.1a01d9	c9 3a		cmp #$3a	                CMP #'9'+1
.1a01db	b0 25		bcs $1a0202	                BGE not_digits_3
.1a01dd	a3 04		lda $04,s	                LDA l_modifiers         ; Multiply l_modifiers by 2
.1a01df	8f 00 01 00	sta $000100	                STA @l UNSIGNED_MULT_A_LO
.1a01e3	a9 00		lda #$00	                LDA #0
.1a01e5	8f 01 01 00	sta $000101	                STA @l UNSIGNED_MULT_A_HI
.1a01e9	8f 03 01 00	sta $000103	                STA @l UNSIGNED_MULT_B_HI
.1a01ed	a9 0a		lda #$0a	                LDA #10
.1a01ef	8f 02 01 00	sta $000102	                STA @l UNSIGNED_MULT_B_LO
.1a01f3	a3 01		lda $01,s	                LDA l_character         ; Convert the digit to a number
.1a01f5	38		sec		                SEC
.1a01f6	e9 30		sbc #$30	                SBC #'0'
.1a01f8	18		clc		                CLC                     ; And add to l_modifiers
.1a01f9	6f 04 01 00	adc $000104	                ADC @l UNSIGNED_MULT_AL_LO
.1a01fd	83 04		sta $04,s	                STA l_modifiers
.1a01ff	82 02 ff	brl $1a0104	                BRL loop                ; And keep processing the sequence
.1a0202	c9 7e		cmp #$7e	not_digits_3    CMP #'~'                ; No: Is it the tilda?
.1a0204	f0 03		beq $1a0209	                BEQ end_sequence        ; Yes: we've gotten the end of the sequence
.1a0206	82 f3 fe	brl $1a00fc	                BRL get_reset           ; No: we've got a bad sequence... for now just reset and keep looping
.1a0209	a3 03		lda $03,s	end_sequence    LDA l_code              ; Get the code
.1a020b	c9 02		cmp #$02	                CMP #ANSI_IN_INS        ; Is it INSERT?
.1a020d	f0 0b		beq $1a021a	                BEQ do_ins              ; Yes: process the insert
.1a020f	c9 03		cmp #$03	                CMP #ANSI_IN_DEL        ; Is it DELETE?
.1a0211	f0 0b		beq $1a021e	                BEQ do_del              ; Yes: process the delete
.1a0213	c9 18		cmp #$18	                CMP #ANSI_IN_F12        ; Is it F12?
.1a0215	f0 0f		beq $1a0226	                BEQ do_f12              ; Yes: process the F12 key
.1a0217	82 e2 fe	brl $1a00fc	                BRL get_reset           ; Code is not one we handle, just return
.1a021a	a9 40		lda #$40	do_ins          LDA #'@'                ; Send the ANSI ICH command
.1a021c	80 02		bra $1a0220	                BRA snd_ansi
.1a021e	a9 50		lda #$50	do_del          LDA #'P'                ; Send the ANSI DCH command
.1a0220					snd_ansi
.1a0220	20 c7 00	jsr $1a00c7	            JSR SEND_ANSI
.1a0223	82 d6 fe	brl $1a00fc	                BRL get_reset           ; Reset and keep getting characters
.1a0226	a5 d2		lda $08d2	do_f12          LDA STATE               ; Check the state
.1a0228	d0 10		bne $1a023a	                BNE skip_f12            ; If we're running, ignore the F12
.1a022a	a3 04		lda $04,s	                LDA l_modifiers         ; Check to make sure it's CTRL-F12
.1a022c	c9 08		cmp #$08	                CMP #ANSI_IN_CTRL       ; Modifier flag for CTRL
.1a022e	d0 0a		bne $1a023a	                BNE skip_f12
.1a0230	a9 1b		lda #$1b	                LDA #CHAR_ESC           ; Send ESC_ (APC) to show the credits
.1a0232	20 18 00	jsr $1a0018	            JSR PRINTC
.1a0235	a9 5f		lda #$5f	                LDA #'_'
.1a0237	20 18 00	jsr $1a0018	            JSR PRINTC
.1a023a	82 bf fe	brl $1a00fc	skip_f12        BRL get_reset           ; And reset the state machine

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/screen.s

.1a023d					ENSURETEXT
.1a023d	08		php		            PHP
.1a023e	e2 20		sep #$20	            SEP #$20
.1a0240	af 00 00 af	lda $af0000	            LDA @l MASTER_CTRL_REG_L            ; Get the current display mode
.1a0244	89 3c		bit #$3c	            BIT #Mstr_Ctrl_Graph_Mode_En | Mstr_Ctrl_Bitmap_En | Mstr_Ctrl_TileMap_En | Mstr_Ctrl_Sprite_En
.1a0246	f0 08		beq $1a0250	            BEQ textonly                        ; If not, make sure text is enabled
.1a0248					overlay
.1a0248	09 03		ora #$03	            ORA #Mstr_Ctrl_Text_Mode_En | Mstr_Ctrl_Text_Overlay
.1a024a	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.1a024e	80 0c		bra $1a025c	            BRA done
.1a0250					textonly
.1a0250	09 01		ora #$01	            ORA #Mstr_Ctrl_Text_Mode_En
.1a0252	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.1a0256	a9 00		lda #$00	            LDA #CHAN_CONSOLE                   ; Make sure we're writing to the main screen
.1a0258	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.1a025c	28		plp		done        PLP
.1a025d	60		rts		            RTS
.1a025e					ISHOWCURSOR
.1a025e	08		php		            PHP
.1a025f	e2 20		sep #$20	            SEP #$20
.1a0261	c9 00		cmp #$00	            CMP #0
.1a0263	f0 08		beq $1a026d	            BEQ hide
.1a0265	af 10 00 af	lda $af0010	show        LDA @lVKY_TXT_CURSOR_CTRL_REG
.1a0269	09 01		ora #$01	            ORA #Vky_Cursor_Enable
.1a026b	80 06		bra $1a0273	            BRA setit
.1a026d	af 10 00 af	lda $af0010	hide        LDA @lVKY_TXT_CURSOR_CTRL_REG
.1a0271	29 fe		and #$fe	            AND #~Vky_Cursor_Enable
.1a0273	8f 10 00 af	sta $af0010	setit       STA @lVKY_TXT_CURSOR_CTRL_REG
.1a0277	28		plp		            PLP
.1a0278	60		rts		            RTS
.1a0279					ICURSORXY
.1a0279	08		php		            PHP
.1a027a	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.1a027e	28		plp		            PLP
.1a027f	60		rts		            RTS
.1a0280					ICLSCREEN
.1a0280	48		pha		            PHA
.1a0281	da		phx		            PHX
.1a0282	5a		phy		            PHY
.1a0283	0b		phd		            PHD
.1a0284	08		php		            PHP
.1a0285	e2 20		sep #$20	            SEP #$20
.1a0287	c2 10		rep #$10	            REP #$10
.1a0289	a2 00 00	ldx #$0000	            LDX #0
.1a028c	a9 20		lda #$20	loop        LDA #$20
.1a028e	9f 00 a0 af	sta $afa000,x	            STA @lCS_TEXT_MEM_PTR,X     ; Write a space in the text cell
.1a0292	af 1e 00 00	lda $00001e	            LDA @lCURCOLOR
.1a0296	9f 00 c0 af	sta $afc000,x	            STA @lCS_COLOR_MEM_PTR,X    ; Set the color to green on black
.1a029a	e8		inx		            INX                         ; Move to the next character cell
.1a029b	e0 00 20	cpx #$2000	            CPX #$2000
.1a029e	d0 ec		bne $1a028c	            BNE loop
.1a02a0	08		php		            PHP
.1a02a1	c2 20		rep #$20	            REP #$20
.1a02a3	48		pha		            PHA
.1a02a4	a9 00 00	lda #$0000	            LDA #0
.1a02a7	5b		tcd		            TCD
.1a02a8	68		pla		            PLA
.1a02a9	28		plp		            PLP
.1a02aa	a2 00 00	ldx #$0000	            LDX #0                      ; Set cursor to upper-left corner
.1a02ad	a0 00 00	ldy #$0000	            LDY #0
.1a02b0	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.1a02b4	28		plp		            PLP
.1a02b5	2b		pld		            PLD
.1a02b6	7a		ply		            PLY
.1a02b7	fa		plx		            PLX
.1a02b8	68		pla		            PLA
.1a02b9	60		rts		            RTS
.1a02ba					ISCRCPYLINE
.1a02ba	da		phx		            PHX
.1a02bb	5a		phy		            PHY
.1a02bc	0b		phd		            PHD
.1a02bd	08		php		            PHP
.1a02be	08		php		            PHP
.1a02bf	c2 20		rep #$20	            REP #$20
.1a02c1	48		pha		            PHA
.1a02c2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a02c5	5b		tcd		            TCD
.1a02c6	68		pla		            PLA
.1a02c7	28		plp		            PLP
.1a02c8	c2 30		rep #$30	            REP #$30
.1a02ca	af 0c 00 00	lda $00000c	            LDA @l SCREENBEGIN      ; Set INDEX to the first byte of the text screen
.1a02ce	85 08		sta $0808	            STA INDEX
.1a02d0	e2 20		sep #$20	            SEP #$20
.1a02d2	af 0e 00 00	lda $00000e	            LDA @l SCREENBEGIN+2
.1a02d6	c2 20		rep #$20	            REP #$20
.1a02d8	29 ff 00	and #$00ff	            AND #$00FF
.1a02db	85 0a		sta $080a	            STA INDEX+2
.1a02dd	af 11 00 00	lda $000011	            LDA @l COLS_PER_LINE    ; Calculate the offset to the current line
.1a02e1	8f 08 01 00	sta $000108	            STA @l M1_OPERAND_A
.1a02e5	af 1c 00 00	lda $00001c	            LDA @l CURSORY
.1a02e9	3a		dec a		            DEC A
.1a02ea	8f 0a 01 00	sta $00010a	            STA @l M1_OPERAND_B
.1a02ee	18		clc		            CLC                     ; And add it to INDEX
.1a02ef	a5 08		lda $0808	            LDA INDEX
.1a02f1	6f 0c 01 00	adc $00010c	            ADC @l M1_RESULT
.1a02f5	85 08		sta $0808	            STA INDEX
.1a02f7	a5 0a		lda $080a	            LDA INDEX+2
.1a02f9	69 00 00	adc #$0000	            ADC #0
.1a02fc	85 0a		sta $080a	            STA INDEX+2
.1a02fe	e2 20		sep #$20	            SEP #$20
.1a0300	af 0f 00 00	lda $00000f	            LDA @l COLS_VISIBLE
.1a0304	85 8f		sta $088f	            STA MCOUNT
.1a0306	a0 00 00	ldy #$0000	            LDY #0
.1a0309	a2 00 00	ldx #$0000	            LDX #0
.1a030c	b7 08		lda [$0808],y	copy_loop   LDA [INDEX],Y           ; Copy a byte from the screen to the input buffer
.1a030e	9f 00 4f 00	sta $004f00,x	            STA @l INPUTBUF,X
.1a0312	e8		inx		            INX
.1a0313	c8		iny		            INY
.1a0314	c4 8f		cpy $088f	            CPY MCOUNT
.1a0316	d0 f4		bne $1a030c	            BNE copy_loop
.1a0318	af 0f 00 00	lda $00000f	            LDA @l COLS_VISIBLE     ; Starting from the end of the line...
.1a031c	3a		dec a		            DEC A
.1a031d	aa		tax		            TAX
.1a031e	bf 00 4f 00	lda $004f00,x	trim_loop   LDA @l INPUTBUF,X       ; Replace spaces at the end with NULLs
.1a0322	c9 20		cmp #$20	            CMP #CHAR_SP
.1a0324	d0 09		bne $1a032f	            BNE done
.1a0326	a9 00		lda #$00	            LDA #0
.1a0328	9f 00 4f 00	sta $004f00,x	            STA @l INPUTBUF,X
.1a032c	ca		dex		            DEX
.1a032d	10 ef		bpl $1a031e	            BPL trim_loop
.1a032f	28		plp		done        PLP
.1a0330	2b		pld		            PLD
.1a0331	7a		ply		            PLY
.1a0332	fa		plx		            PLX
.1a0333	60		rts		            RTS

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/gabe_defs.s

=$afe880				GABE_MSTR_CTRL      = $AFE880
=$01					GABE_CTRL_PWR_LED   = $01     ; Controls the LED in the Front of the case (Next to the reset button)
=$02					GABE_CTRL_SDC_LED   = $02     ; Controls the LED in the Front of the Case (Next to SDCard)
=$04					GABE_CTRL_STS_LED0  = $04     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$08					GABE_CTRL_STS_LED1  = $08     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$10					GABE_CTRL_BUZZER    = $10     ; Controls the Buzzer
=$80					GABE_CTRL_WRM_RST   = $80     ; Warm Reset (needs to Setup other registers)
=$afe881				GABE_LED_FLASH_CTRL = $AFE881  ; Flashing LED Control
=$01					GABE_LED0_FLASH_CTRL = $01     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$02					GABE_LED1_FLASH_CTRL = $02     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED1 to manually control)
=$10					GABE_LD0_FLASH_FRQ0   = $10     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$20					GABE_LD0_FLASH_FRQ1   = $20     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$40					GABE_LD1_FLASH_FRQ0   = $40     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$80					GABE_LD1_FLASH_FRQ1   = $80     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$afe882				GABE_RST_AUTH0      = $AFE882 ; Must Contain the BYTE $AD for Reset to Activate
=$afe883				GABE_RST_AUTH1      = $AFE883 ; Must Contain the BYTE $DE for Reset to Activate
=$afe884				GABE_RNG_DAT_LO     = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_DAT_HI     = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe884				GABE_RNG_SEED_LO    = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_SEED_HI    = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe886				GABE_RNG_STAT       = $AFE886 ;
=$80					GABE_RNG_LFSR_DONE  = $80     ; indicates that Output = SEED Database
=$afe886				GABE_RNG_CTRL       = $AFE886 ;
=$01					GABE_RNG_CTRL_EN    = $01     ; Enable the LFSR BLOCK_LEN
=$02					GABE_RNG_CTRL_DV    = $02     ; After Setting the Seed Value, Toggle that Bit for it be registered
=$afe887				GABE_SYS_STAT       = $AFE887 ;
=$01					GABE_SYS_STAT_MID0  = $01     ; Machine ID -- LSB
=$02					GABE_SYS_STAT_MID1  = $02     ; Machine ID --
=$04					GABE_SYS_STAT_MID2  = $04     ; Machine ID -- MSB
=$10					GABE_SYS_STAT_EXP   = $10     ; if Zero, there is an Expansion Card Preset
=$40					GABE_SYS_STAT_CPUA  = $40     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$80					GABE_SYS_STAT_CPUX  = $80     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$afe88a				GABE_SUBVERSION_LO  = $AFE88A
=$afe88b				GABE_SUBVERSION_HI  = $AFE88B
=$afe88c				GABE_VERSION_LO     = $AFE88C
=$afe88d				GABE_VERSION_HI     = $AFE88D
=$afe88e				GABE_MODEL_LO       = $AFE88E
=$afe88f				GABE_MODEL_HI       = $AFE88F

;******  Return to file: src\C256/io_c256.s

=32					BORDER_WIDTH = 32               ; The width of the border (when it is on)
=72					TEXT_COLS_WB = 72               ; Number of columns of text with the border enabled
=52					TEXT_ROWS_WB = 52               ; Number of rows of text with the border enabled
=80					TEXT_COLS_WOB = 80              ; Number of columns of text with no border enabled
=60					TEXT_ROWS_WOB = 60              ; Number of rows of text with no border enabled
.1a0334					INITIO
.1a0334	e2 20		sep #$20	            SEP #$20
.1a0336	a2 00 00	ldx #$0000	            LDX #0              ; Clear all the sprite control shadow registers
.1a0339	a9 00		lda #$00	            LDA #0
.1a033b	9f 18 f0 1a	sta $1af018,x	sp_loop     STA GS_SP_CONTROL,X
.1a033f	e8		inx		            INX
.1a0340	e0 40 00	cpx #$0040	            CPX #SP_MAX
.1a0343	d0 f6		bne $1a033b	            BNE sp_loop
.1a0345	a9 80		lda #$80	            LDA #DEV_SCREEN
.1a0347	8f b4 08 00	sta $0008b4	            STA @lBCONSOLE
.1a034b	e2 20		sep #$20	            SEP #$20
.1a034d	a9 00		lda #$00	            LDA #0                  ; Clear the lock key flags
.1a034f	8f 89 0f 00	sta $000f89	            STA @lKEYBOARD_LOCKS
.1a0353	a9 00		lda #$00	            LDA #0
.1a0355	8f 00 02 af	sta $af0200	            STA @l TL0_CONTROL_REG
.1a0359	8f 0c 02 af	sta $af020c	            STA @l TL1_CONTROL_REG
.1a035d	8f 18 02 af	sta $af0218	            STA @l TL2_CONTROL_REG
.1a0361	8f 24 02 af	sta $af0224	            STA @l TL3_CONTROL_REG
.1a0365					done
.1a0365	60		rts		            RTS
.1a0366					SCREEN_PUTC
.1a0366	08		php		            PHP
.1a0367	e2 20		sep #$20	            SEP #$20
.1a0369	48		pha		            PHA
.1a036a	48		pha		            PHA
.1a036b	a9 00		lda #$00	            LDA #CHAN_CONSOLE       ; Switch to the console device
.1a036d	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.1a0371	68		pla		            PLA
.1a0372	22 18 10 00	jsl $001018	            JSL FK_PUTC
.1a0376	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.1a037a	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.1a037c	d0 f8		bne $1a0376	            BNE loop                ; Yes: wait until it's released
.1a037e	68		pla		            PLA
.1a037f	28		plp		            PLP
.1a0380	60		rts		            RTS
.1a0381					UART_PUTC
.1a0381	08		php		            PHP
.1a0382	e2 20		sep #$20	            SEP #$20
.1a0384	48		pha		            PHA
.1a0385	48		pha		            PHA
.1a0386	a9 01		lda #$01	            LDA #CHAN_COM1          ; Switch to COM1
.1a0388	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.1a038c	68		pla		            PLA
.1a038d	22 18 10 00	jsl $001018	            JSL FK_PUTC
.1a0391	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.1a0395	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.1a0397	d0 f8		bne $1a0391	            BNE loop                ; Yes: wait until it's released
.1a0399	68		pla		            PLA
.1a039a	28		plp		            PLP
.1a039b	60		rts		            RTS
.1a039c					PRINTCR
.1a039c	08		php		            PHP
.1a039d	c2 20		rep #$20	            REP #$20
.1a039f	48		pha		            PHA
.1a03a0	e2 20		sep #$20	            SEP #$20
.1a03a2	a9 0d		lda #$0d	            LDA #CHAR_CR
.1a03a4	20 18 00	jsr $1a0018	            JSR PRINTC
.1a03a7	c2 20		rep #$20	            REP #$20
.1a03a9	68		pla		            PLA
.1a03aa	28		plp		            PLP
.1a03ab	60		rts		            RTS
.1a03ac					PRINTH
.1a03ac	08		php		            PHP
.1a03ad	22 78 10 00	jsl $001078	            JSL FK_IPRINTH
.1a03b1	28		plp		            PLP
.1a03b2	60		rts		            RTS

;******  Return to file: src\bios.s

=10					LINES_PER_PAGE = 10     ; The number of lines to print on a page before pausing
=$80					DEV_SCREEN = $80        ; Use the screen and keyboard for the console device
=$40					DEV_UART = $40          ; Use UART for console device
=$20					DEV_BUFFER = $20        ; Use the current text memory buffer for output or input
>08b4					BCONSOLE    .byte ?     ; Device for BASIC console
>08b5					SAVE_A      .byte ?     ; Save spot for the A register
>08b6					LINECOUNT   .byte ?     ; Counter for new lines to support pagination
.1a03b3					PAGINATE
.1a03b3	08		php		            PHP
.1a03b4	0b		phd		            PHD
.1a03b5	08		php		            PHP
.1a03b6	c2 20		rep #$20	            REP #$20
.1a03b8	48		pha		            PHA
.1a03b9	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a03bc	5b		tcd		            TCD
.1a03bd	68		pla		            PLA
.1a03be	28		plp		            PLP
.1a03bf	e2 20		sep #$20	            SEP #$20
.1a03c1	a5 b6		lda $08b6	            LDA LINECOUNT           ; Check the line count
.1a03c3	1a		inc a		            INC A
.1a03c4	85 b6		sta $08b6	            STA LINECOUNT
.1a03c6	cf 13 00 00	cmp $000013	            CMP @l LINES_VISIBLE
.1a03ca	90 05		bcc $1a03d1	            BLT done                ; If < limit, just return
.1a03cc	20 14 00	jsr $1a0014	            JSR GETKEY
.1a03cf	64 b6		stz $08b6	            STZ LINECOUNT           ; And reset the line count
.1a03d1	2b		pld		done        PLD
.1a03d2	28		plp		            PLP
.1a03d3	60		rts		            RTS
.1a03d4					IPRINTC
.1a03d4	da		phx		            PHX
.1a03d5	5a		phy		            PHY
.1a03d6	0b		phd		            PHD
.1a03d7	08		php		            PHP
.1a03d8	08		php		            PHP
.1a03d9	c2 20		rep #$20	            REP #$20
.1a03db	48		pha		            PHA
.1a03dc	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a03df	5b		tcd		            TCD
.1a03e0	68		pla		            PLA
.1a03e1	28		plp		            PLP
.1a03e2	e2 20		sep #$20	            SEP #$20
.1a03e4	c2 10		rep #$10	            REP #$10
.1a03e6	8f b5 08 00	sta $0008b5	            STA @lSAVE_A
.1a03ea	af b4 08 00	lda $0008b4	chk_out     LDA @lBCONSOLE      ; Check to see if we should send to an output buffer
.1a03ee	29 20		and #$20	            AND #DEV_BUFFER
.1a03f0	f0 07		beq $1a03f9	            BEQ check_scrn      ; No... move on to the hardware screen
.1a03f2	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.1a03f6	20 28 00	jsr $1a0028	            JSR OBUFF_PUTC
.1a03f9	af b4 08 00	lda $0008b4	check_scrn  LDA @lBCONSOLE
.1a03fd	29 80		and #$80	            AND #DEV_SCREEN     ; Check to see if the screen is selected
.1a03ff	f0 07		beq $1a0408	            BEQ send_uart
.1a0401	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.1a0405	20 66 03	jsr $1a0366	            JSR SCREEN_PUTC
.1a0408	af b4 08 00	lda $0008b4	send_uart   LDA @lBCONSOLE
.1a040c	29 40		and #$40	            AND #DEV_UART       ; Check to see if the UART is active
.1a040e	f0 14		beq $1a0424	            BEQ done
.1a0410	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.1a0414	20 81 03	jsr $1a0381	            JSR UART_PUTC
.1a0417	af b5 08 00	lda $0008b5	            LDA @lSAVE_A        ; If sending a CR to the serial port
.1a041b	c9 0d		cmp #$0d	            CMP #CHAR_CR
.1a041d	d0 05		bne $1a0424	            BNE done
.1a041f	a9 0a		lda #$0a	            LDA #CHAR_LF        ; Send a linefeed after
.1a0421	20 81 03	jsr $1a0381	            JSR UART_PUTC
.1a0424	28		plp		done        PLP
.1a0425	2b		pld		            PLD
.1a0426	7a		ply		            PLY
.1a0427	fa		plx		            PLX
.1a0428	60		rts		            RTS
.1a0429					PRINTS
.1a0429	08		php		            PHP
.1a042a	e2 20		sep #$20	            SEP #$20
.1a042c	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.1a042f	f0 06		beq $1a0437	            BEQ done
.1a0431	20 18 00	jsr $1a0018	            JSR PRINTC
.1a0434	e8		inx		            INX
.1a0435	80 f5		bra $1a042c	            BRA loop
.1a0437	28		plp		done        PLP
.1a0438	60		rts		            RTS
.1a0439					PRHEXW
.1a0439	08		php		            PHP
.1a043a	c2 20		rep #$20	            REP #$20
.1a043c	48		pha		            PHA
.1a043d	48		pha		            PHA
.1a043e	4a		lsr a		            LSR A
.1a043f	4a		lsr a		            LSR A
.1a0440	4a		lsr a		            LSR A
.1a0441	4a		lsr a		            LSR A
.1a0442	4a		lsr a		            LSR A
.1a0443	4a		lsr a		            LSR A
.1a0444	4a		lsr a		            LSR A
.1a0445	4a		lsr a		            LSR A
.1a0446	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a0449	68		pla		            PLA
.1a044a	29 ff 00	and #$00ff	            AND #$00FF
.1a044d	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a0450	68		pla		            PLA
.1a0451	28		plp		            PLP
.1a0452	60		rts		            RTS
.1a0453					PRHEXB
.1a0453	08		php		            PHP
.1a0454	c2 20		rep #$20	            REP #$20
.1a0456	48		pha		            PHA
.1a0457	e2 20		sep #$20	            SEP #$20
.1a0459	48		pha		            PHA
.1a045a	4a		lsr a		            LSR A
.1a045b	4a		lsr a		            LSR A
.1a045c	4a		lsr a		            LSR A
.1a045d	4a		lsr a		            LSR A
.1a045e	20 6a 04	jsr $1a046a	            JSR PRHEXN
.1a0461	68		pla		            PLA
.1a0462	20 6a 04	jsr $1a046a	            JSR PRHEXN
.1a0465	c2 20		rep #$20	            REP #$20
.1a0467	68		pla		            PLA
.1a0468	28		plp		            PLP
.1a0469	60		rts		            RTS
.1a046a					PRHEXN
.1a046a	08		php		            PHP
.1a046b	c2 30		rep #$30	            REP #$30
.1a046d	da		phx		            PHX
.1a046e	29 0f 00	and #$000f	            AND #$000F
.1a0471	aa		tax		            TAX
.1a0472	bf 00 d0 1a	lda $1ad000,x	            LDA @lHEXDIGITS,X
.1a0476	20 18 00	jsr $1a0018	            JSR PRINTC
.1a0479	fa		plx		            PLX
.1a047a	28		plp		            PLP
.1a047b	60		rts		            RTS
>1ad000	30 31 32 33 34 35 36 37		HEXDIGITS   .text "0123456789ABCDEF"
>1ad008	38 39 41 42 43 44 45 46

;******  Return to file: src\basic816.s


;******  Processing file: src\utilities.s

.1a047c					PRTRACE
.1a047c	08		php		            PHP
.1a047d	c2 30		rep #$30	            REP #$30
.1a047f	48		pha		            PHA
.1a0480	da		phx		            PHX
.1a0481	5a		phy		            PHY
.1a0482	8b		phb		            PHB
.1a0483	0b		phd		            PHD
.1a0484	c2 30		rep #$30	            REP #$30
.1a0486	a3 0b		lda $0b,s	            LDA 11,S        ; Get the return address
.1a0488	18		clc		calc_addr   CLC
.1a0489	69 03 00	adc #$0003	            ADC #3          ; Add 3 to skip over the following branch
.1a048c	aa		tax		            TAX
.1a048d	e2 20		sep #$20	            SEP #$20
.1a048f	a9 1a		lda #$1a	            LDA #`PRTRACE
.1a0491	48		pha		            PHA
.1a0492	ab		plb		            PLB
.1a0493	bd 00 00	lda $0000,x	pr_loop     LDA #0,B,X
.1a0496	f0 06		beq $1a049e	            BEQ done
.1a0498	20 66 03	jsr $1a0366	            JSR SCREEN_PUTC
.1a049b	e8		inx		            INX
.1a049c	80 f5		bra $1a0493	            BRA pr_loop
.1a049e					done
.1a049e	c2 30		rep #$30	            REP #$30
.1a04a0	2b		pld		            PLD
.1a04a1	ab		plb		            PLB
.1a04a2	7a		ply		            PLY
.1a04a3	fa		plx		            PLX
.1a04a4	68		pla		            PLA
.1a04a5	28		plp		            PLP
.1a04a6	60		rts		            RTS
.1a04a7					ISALPHA
.1a04a7	08		php		            PHP
.1a04a8	e2 20		sep #$20	            SEP #$20
.1a04aa	c9 5b		cmp #$5b	            CMP #'Z'+1
.1a04ac	b0 04		bcs $1a04b2	            BGE not_upper
.1a04ae	c9 41		cmp #$41	            CMP #'A'
.1a04b0	b0 0b		bcs $1a04bd	            BGE is_alpha
.1a04b2	c9 7b		cmp #$7b	not_upper   CMP #'z'+1
.1a04b4	b0 04		bcs $1a04ba	            BGE not_alpha
.1a04b6	c9 61		cmp #$61	            CMP #'a'
.1a04b8	b0 03		bcs $1a04bd	            BGE is_alpha
.1a04ba					not_alpha
.1a04ba	28		plp		            PLP
.1a04bb	18		clc		            CLC
.1a04bc	60		rts		            RTS
.1a04bd					is_alpha
.1a04bd	28		plp		            PLP
.1a04be	38		sec		            SEC
.1a04bf	60		rts		            RTS
.1a04c0					ISNUMERAL
.1a04c0	08		php		            PHP
.1a04c1	e2 20		sep #$20	            SEP #$20
.1a04c3	c9 3a		cmp #$3a	            CMP #'9'+1
.1a04c5	b0 04		bcs $1a04cb	            BGE ret_false
.1a04c7	c9 30		cmp #$30	            CMP #'0'
.1a04c9	b0 03		bcs $1a04ce	            BGE ret_true
.1a04cb	28		plp		ret_false   PLP
.1a04cc	18		clc		            CLC
.1a04cd	60		rts		            RTS
.1a04ce	28		plp		ret_true    PLP
.1a04cf	38		sec		            SEC
.1a04d0	60		rts		            RTS
.1a04d1					ISHEX
.1a04d1	08		php		            PHP
.1a04d2	e2 20		sep #$20	            SEP #$20
.1a04d4	c9 3a		cmp #$3a	            CMP #'9'+1
.1a04d6	b0 04		bcs $1a04dc	            BGE chk_lca2f
.1a04d8	c9 30		cmp #$30	            CMP #'0'
.1a04da	b0 13		bcs $1a04ef	            BGE ret_true
.1a04dc	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.1a04de	b0 04		bcs $1a04e4	            BGE chk_uca2f
.1a04e0	c9 61		cmp #$61	            CMP #'a'
.1a04e2	b0 0b		bcs $1a04ef	            BGE ret_true
.1a04e4	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.1a04e6	b0 04		bcs $1a04ec	            BGE ret_false
.1a04e8	c9 41		cmp #$41	            CMP #'A'
.1a04ea	b0 03		bcs $1a04ef	            BGE ret_true
.1a04ec	28		plp		ret_false   PLP
.1a04ed	18		clc		            CLC
.1a04ee	60		rts		            RTS
.1a04ef	28		plp		ret_true    PLP
.1a04f0	38		sec		            SEC
.1a04f1	60		rts		            RTS
.1a04f2					HEX2BIN
.1a04f2	08		php		            PHP
.1a04f3	e2 20		sep #$20	            SEP #$20
.1a04f5	c9 3a		cmp #$3a	            CMP #'9'+1          ; Check to see if '0'..'9'
.1a04f7	b0 04		bcs $1a04fd	            BGE chk_lca2f
.1a04f9	c9 30		cmp #$30	            CMP #'0'
.1a04fb	b0 12		bcs $1a050f	            BGE conv_09         ; Yes: convert it
.1a04fd	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.1a04ff	b0 04		bcs $1a0505	            BGE chk_uca2f
.1a0501	c9 61		cmp #$61	            CMP #'a'
.1a0503	b0 0f		bcs $1a0514	            BGE conv_lcaf
.1a0505	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.1a0507	b0 04		bcs $1a050d	            BGE done
.1a0509	c9 41		cmp #$41	            CMP #'A'
.1a050b	b0 09		bcs $1a0516	            BGE conv_ucaf
.1a050d	28		plp		done        PLP
.1a050e	60		rts		            RTS
.1a050f	38		sec		conv_09     SEC                 ; Convert digits '0'..'9'
.1a0510	e9 30		sbc #$30	            SBC #'0'
.1a0512	80 f9		bra $1a050d	            BRA done
.1a0514	29 df		and #$df	conv_lcaf   AND #%11011111      ; Convert to upper case
.1a0516	38		sec		conv_ucaf   SEC
.1a0517	e9 37		sbc #$37	            SBC #'A'-10         ; Convert 'A'..'F'
.1a0519	80 f2		bra $1a050d	            BRA done
.1a051b					TOUPPERA
.1a051b	08		php		            PHP
.1a051c	e2 20		sep #$20	            SEP #$20
.1a051e	c9 7b		cmp #$7b	            CMP #'z'+1
.1a0520	b0 06		bcs $1a0528	            BCS done
.1a0522	c9 61		cmp #$61	            CMP #'a'
.1a0524	90 02		bcc $1a0528	            BCC done
.1a0526	29 df		and #$df	            AND #%11011111
.1a0528	28		plp		done        PLP
.1a0529	60		rts		            RTS
.1a052a					TOUPPER
.1a052a	08		php		            PHP
.1a052b	e2 20		sep #$20	            SEP #$20
.1a052d	c2 10		rep #$10	            REP #$10
.1a052f	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.1a0532	f0 09		beq $1a053d	            BEQ done
.1a0534	20 1b 05	jsr $1a051b	            JSR TOUPPERA
.1a0537	9d 00 00	sta $0000,x	            STA #0,B,X
.1a053a	e8		inx		continue    INX
.1a053b	80 f2		bra $1a052f	            BRA loop
.1a053d	28		plp		done        PLP
.1a053e	60		rts		            RTS
.1a053f					MULINT10
.1a053f	08		php		                PHP
.1a0540	0b		phd		                PHD
.1a0541	08		php		            PHP
.1a0542	c2 20		rep #$20	            REP #$20
.1a0544	48		pha		            PHA
.1a0545	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0548	5b		tcd		            TCD
.1a0549	68		pla		            PLA
.1a054a	28		plp		            PLP
.1a054b	c2 20		rep #$20	            REP #$20
.1a054d	48		pha		                PHA
.1a054e	06 23		asl $0823	                ASL ARGUMENT1           ; 7 -- 20 -- 74
.1a0550	26 25		rol $0825	                ROL ARGUMENT1+2         ; 7
.1a0552	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.1a0554	85 0c		sta $080c	                STA SCRATCH             ; 4
.1a0556	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.1a0558	85 0e		sta $080e	                STA SCRATCH+2           ; 4
.1a055a	06 0c		asl $080c	                ASL SCRATCH             ; 7 -- 28
.1a055c	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.1a055e	06 0c		asl $080c	                ASL SCRATCH             ; 7
.1a0560	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.1a0562	18		clc		                CLC                     ; 2 -- 26
.1a0563	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.1a0565	65 0c		adc $080c	                ADC SCRATCH             ; 4
.1a0567	85 23		sta $0823	                STA ARGUMENT1           ; 4
.1a0569	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.1a056b	65 0e		adc $080e	                ADC SCRATCH+2           ; 4
.1a056d	85 25		sta $0825	                STA ARGUMENT1+2         ; 4
.1a056f	68		pla		                PLA
.1a0570	2b		pld		                PLD
.1a0571	28		plp		                PLP
.1a0572	60		rts		            RTS
.1a0573					DIVINT10
.1a0573	08		php		                PHP
.1a0574	0b		phd		                PHD
.1a0575	08		php		            PHP
.1a0576	c2 20		rep #$20	            REP #$20
.1a0578	48		pha		            PHA
.1a0579	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a057c	5b		tcd		            TCD
.1a057d	68		pla		            PLA
.1a057e	28		plp		            PLP
.1a057f	c2 20		rep #$20	            REP #$20
.1a0581	a5 23		lda $0823	                LDA ARGUMENT1
.1a0583	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.1a0587	a9 0a 00	lda #$000a	                LDA #10
.1a058a	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.1a058e	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.1a0592	85 23		sta $0823	                STA ARGUMENT1
.1a0594	64 25		stz $0825	                STZ ARGUMENT1+2
.1a0596	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.1a059a	85 29		sta $0829	                STA ARGUMENT2
.1a059c	64 2b		stz $082b	                STZ ARGUMENT2+2
.1a059e	e2 20		sep #$20	            SEP #$20
.1a05a0	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a05a2	85 27		sta $0827	                STA ARGTYPE1
.1a05a4	85 2d		sta $082d	                STA ARGTYPE2
.1a05a6	2b		pld		                PLD
.1a05a7	28		plp		                PLP
.1a05a8	60		rts		            RTS
.1a05a9					DIVINT100
.1a05a9	08		php		                PHP
.1a05aa	0b		phd		                PHD
.1a05ab	08		php		            PHP
.1a05ac	c2 20		rep #$20	            REP #$20
.1a05ae	48		pha		            PHA
.1a05af	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a05b2	5b		tcd		            TCD
.1a05b3	68		pla		            PLA
.1a05b4	28		plp		            PLP
.1a05b5	c2 20		rep #$20	            REP #$20
.1a05b7	a5 23		lda $0823	                LDA ARGUMENT1
.1a05b9	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.1a05bd	a9 64 00	lda #$0064	                LDA #100
.1a05c0	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.1a05c4	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.1a05c8	85 23		sta $0823	                STA ARGUMENT1
.1a05ca	64 25		stz $0825	                STZ ARGUMENT1+2
.1a05cc	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.1a05d0	85 29		sta $0829	                STA ARGUMENT2
.1a05d2	64 2b		stz $082b	                STZ ARGUMENT2+2
.1a05d4	e2 20		sep #$20	            SEP #$20
.1a05d6	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a05d8	85 27		sta $0827	                STA ARGTYPE1
.1a05da	85 2d		sta $082d	                STA ARGTYPE2
.1a05dc	2b		pld		                PLD
.1a05dd	28		plp		                PLP
.1a05de	60		rts		            RTS
.1a05df					IS_ARG1_Z
.1a05df	08		php		                PHP
.1a05e0	c2 20		rep #$20	            REP #$20
.1a05e2	a5 23		lda $0823	                LDA ARGUMENT1
.1a05e4	d0 08		bne $1a05ee	                BNE return_false
.1a05e6	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a05e8	d0 04		bne $1a05ee	                BNE return_false
.1a05ea	28		plp		return_true     PLP
.1a05eb	e2 02		sep #$02	                SEP #$02        ; Set Z
.1a05ed	60		rts		            RTS
.1a05ee	28		plp		return_false    PLP
.1a05ef	c2 02		rep #$02	                REP #$02        ; Clear Z
.1a05f1	60		rts		            RTS
.1a05f2					SET_TRUE
.1a05f2	08		php		                PHP
.1a05f3	c2 30		rep #$30	            REP #$30
.1a05f5	a9 ff ff	lda #$ffff	                LDA #$FFFF
.1a05f8	85 23		sta $0823	                STA ARGUMENT1
.1a05fa	85 25		sta $0825	                STA ARGUMENT1+2
.1a05fc	e2 20		sep #$20	            SEP #$20
.1a05fe	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a0600	85 27		sta $0827	                STA ARGTYPE1
.1a0602	28		plp		                PLP
.1a0603	60		rts		            RTS
.1a0604					SET_FALSE
.1a0604	08		php		                PHP
.1a0605	c2 30		rep #$30	            REP #$30
.1a0607	a9 00 00	lda #$0000	                LDA #0
.1a060a	85 23		sta $0823	                STA ARGUMENT1
.1a060c	85 25		sta $0825	                STA ARGUMENT1+2
.1a060e	e2 20		sep #$20	            SEP #$20
.1a0610	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a0612	85 27		sta $0827	                STA ARGTYPE1
.1a0614	28		plp		                PLP
.1a0615	60		rts		            RTS
.1a0616					ASS_ARG1_INT
.1a0616	08		php		                PHP
.1a0617	e2 20		sep #$20	            SEP #$20
.1a0619	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.1a061b	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a061d	f0 07		beq $1a0626	                BEQ done                ; If so: just return
.1a061f	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.1a0621	d0 05		bne $1a0628	                BNE TYPE_ERR            ; If not: throw an error
.1a0623	20 cf 5b	jsr $1a5bcf	            JSR FTOI
.1a0626	28		plp		done            PLP
.1a0627	60		rts		            RTS
.1a0628					TYPE_ERR
.1a0628	08		php		            PHP
.1a0629	c2 20		rep #$20	            REP #$20
.1a062b	48		pha		            PHA
.1a062c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a062f	5b		tcd		            TCD
.1a0630	68		pla		            PLA
.1a0631	28		plp		            PLP
.1a0632	e2 20		sep #$20	            SEP #$20
.1a0634	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0636	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a063a	c2 20		rep #$20	            REP #$20
.1a063c	29 ff 00	and #$00ff	            AND #$00FF
.1a063f	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a0642	e2 20		sep #$20	            SEP #$20
.1a0644	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0647					ASS_ARG2_INT
.1a0647	08		php		                PHP
.1a0648	e2 20		sep #$20	            SEP #$20
.1a064a	a5 2d		lda $082d	                LDA ARGTYPE2                ; Verify that the type is INTEGER
.1a064c	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a064e	f0 37		beq $1a0687	                BEQ done                    ; If so: just return
.1a0650	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; Check if it's a float
.1a0652	d0 35		bne $1a0689	                BNE TYPE_ERR                ; If not: throw an error
.1a0654	c2 20		rep #$20	            REP #$20
.1a0656	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a0658	48		pha		            PHA
.1a0659	a5 23		lda $0823	            LDA ARGUMENT1
.1a065b	48		pha		            PHA
.1a065c	c2 20		rep #$20	            REP #$20
.1a065e	a5 29		lda $0829	            LDA ARGUMENT2
.1a0660	85 23		sta $0823	            STA ARGUMENT1
.1a0662	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a0664	85 25		sta $0825	            STA ARGUMENT1+2
.1a0666	e2 20		sep #$20	            SEP #$20
.1a0668	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.1a066a	85 27		sta $0827	            STA ARGTYPE1
.1a066c	20 cf 5b	jsr $1a5bcf	            JSR FTOI
.1a066f	c2 20		rep #$20	            REP #$20
.1a0671	a5 23		lda $0823	            LDA ARGUMENT1
.1a0673	85 29		sta $0829	            STA ARGUMENT2
.1a0675	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a0677	85 2b		sta $082b	            STA ARGUMENT2+2
.1a0679	e2 20		sep #$20	            SEP #$20
.1a067b	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a067d	85 2d		sta $082d	            STA ARGTYPE2
.1a067f	c2 20		rep #$20	            REP #$20
.1a0681	68		pla		            PLA
.1a0682	85 23		sta $0823	            STA ARGUMENT1
.1a0684	68		pla		            PLA
.1a0685	85 25		sta $0825	            STA ARGUMENT1+2
.1a0687	28		plp		done            PLP
.1a0688	60		rts		            RTS
.1a0689					TYPE_ERR
.1a0689	08		php		            PHP
.1a068a	c2 20		rep #$20	            REP #$20
.1a068c	48		pha		            PHA
.1a068d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0690	5b		tcd		            TCD
.1a0691	68		pla		            PLA
.1a0692	28		plp		            PLP
.1a0693	e2 20		sep #$20	            SEP #$20
.1a0695	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0697	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a069b	c2 20		rep #$20	            REP #$20
.1a069d	29 ff 00	and #$00ff	            AND #$00FF
.1a06a0	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a06a3	e2 20		sep #$20	            SEP #$20
.1a06a5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a06a8					ASS_ARG1_STR
.1a06a8	08		php		                PHP
.1a06a9	e2 20		sep #$20	            SEP #$20
.1a06ab	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is STRING
.1a06ad	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a06af	d0 02		bne $1a06b3	                BNE TYPE_ERR
.1a06b1	28		plp		                PLP
.1a06b2	60		rts		            RTS
.1a06b3					TYPE_ERR
.1a06b3	08		php		            PHP
.1a06b4	c2 20		rep #$20	            REP #$20
.1a06b6	48		pha		            PHA
.1a06b7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a06ba	5b		tcd		            TCD
.1a06bb	68		pla		            PLA
.1a06bc	28		plp		            PLP
.1a06bd	e2 20		sep #$20	            SEP #$20
.1a06bf	a9 04		lda #$04	            LDA #ERR_TYPE
.1a06c1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a06c5	c2 20		rep #$20	            REP #$20
.1a06c7	29 ff 00	and #$00ff	            AND #$00FF
.1a06ca	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a06cd	e2 20		sep #$20	            SEP #$20
.1a06cf	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a06d2					ASS_ARG1_INT16
.1a06d2	08		php		                PHP
.1a06d3	e2 20		sep #$20	            SEP #$20
.1a06d5	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.1a06d7	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a06d9	f0 07		beq $1a06e2	                BEQ check_range         ; If so: check the range
.1a06db	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.1a06dd	d0 0b		bne $1a06ea	                BNE TYPE_ERR            ; If not: throw an error
.1a06df	20 cf 5b	jsr $1a5bcf	            JSR FTOI
.1a06e2					check_range
.1a06e2	c2 20		rep #$20	            REP #$20
.1a06e4	a5 25		lda $0825	                LDA ARGUMENT1+2         ; Validate it is 16-bit
.1a06e6	d0 21		bne $1a0709	                BNE range_err
.1a06e8	28		plp		                PLP
.1a06e9	60		rts		            RTS
.1a06ea					TYPE_ERR
.1a06ea	08		php		            PHP
.1a06eb	c2 20		rep #$20	            REP #$20
.1a06ed	48		pha		            PHA
.1a06ee	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a06f1	5b		tcd		            TCD
.1a06f2	68		pla		            PLA
.1a06f3	28		plp		            PLP
.1a06f4	e2 20		sep #$20	            SEP #$20
.1a06f6	a9 04		lda #$04	            LDA #ERR_TYPE
.1a06f8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a06fc	c2 20		rep #$20	            REP #$20
.1a06fe	29 ff 00	and #$00ff	            AND #$00FF
.1a0701	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a0704	e2 20		sep #$20	            SEP #$20
.1a0706	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0709					RANGE_ERR
.1a0709	08		php		            PHP
.1a070a	c2 20		rep #$20	            REP #$20
.1a070c	48		pha		            PHA
.1a070d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0710	5b		tcd		            TCD
.1a0711	68		pla		            PLA
.1a0712	28		plp		            PLP
.1a0713	e2 20		sep #$20	            SEP #$20
.1a0715	a9 09		lda #$09	            LDA #ERR_RANGE
.1a0717	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a071b	c2 20		rep #$20	            REP #$20
.1a071d	29 ff 00	and #$00ff	            AND #$00FF
.1a0720	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a0723	e2 20		sep #$20	            SEP #$20
.1a0725	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0728					ASS_ARG1_BYTE
.1a0728	08		php		                PHP
.1a0729	e2 20		sep #$20	            SEP #$20
.1a072b	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.1a072d	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a072f	f0 07		beq $1a0738	                BEQ check_range         ; If so: check the range
.1a0731	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.1a0733	d0 11		bne $1a0746	                BNE TYPE_ERR            ; If not: throw an error
.1a0735	20 cf 5b	jsr $1a5bcf	            JSR FTOI
.1a0738	a5 26		lda $0826	check_range     LDA ARGUMENT1+3         ; Validate that the value is in byte range
.1a073a	d0 29		bne $1a0765	                BNE RANGE_ERR           ; If not... throw a range error
.1a073c	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a073e	d0 25		bne $1a0765	                BNE RANGE_ERR
.1a0740	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a0742	d0 21		bne $1a0765	                BNE RANGE_ERR
.1a0744	28		plp		                PLP
.1a0745	60		rts		            RTS
.1a0746					TYPE_ERR
.1a0746	08		php		            PHP
.1a0747	c2 20		rep #$20	            REP #$20
.1a0749	48		pha		            PHA
.1a074a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a074d	5b		tcd		            TCD
.1a074e	68		pla		            PLA
.1a074f	28		plp		            PLP
.1a0750	e2 20		sep #$20	            SEP #$20
.1a0752	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0754	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0758	c2 20		rep #$20	            REP #$20
.1a075a	29 ff 00	and #$00ff	            AND #$00FF
.1a075d	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a0760	e2 20		sep #$20	            SEP #$20
.1a0762	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0765					RANGE_ERR
.1a0765	08		php		            PHP
.1a0766	c2 20		rep #$20	            REP #$20
.1a0768	48		pha		            PHA
.1a0769	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a076c	5b		tcd		            TCD
.1a076d	68		pla		            PLA
.1a076e	28		plp		            PLP
.1a076f	e2 20		sep #$20	            SEP #$20
.1a0771	a9 09		lda #$09	            LDA #ERR_RANGE
.1a0773	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0777	c2 20		rep #$20	            REP #$20
.1a0779	29 ff 00	and #$00ff	            AND #$00FF
.1a077c	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a077f	e2 20		sep #$20	            SEP #$20
.1a0781	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0784					ASS_ARG1_FLOAT
.1a0784	08		php		                PHP
.1a0785	e2 20		sep #$20	            SEP #$20
.1a0787	a5 27		lda $0827	                LDA ARGTYPE1            ; Check the type
.1a0789	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.1a078b	f0 26		beq $1a07b3	                BEQ done                ; Then we're done
.1a078d	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.1a078f	f0 1f		beq $1a07b0	                BEQ cast                ; Then cast it to float
.1a0791					type_err
.1a0791	08		php		            PHP
.1a0792	c2 20		rep #$20	            REP #$20
.1a0794	48		pha		            PHA
.1a0795	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0798	5b		tcd		            TCD
.1a0799	68		pla		            PLA
.1a079a	28		plp		            PLP
.1a079b	e2 20		sep #$20	            SEP #$20
.1a079d	a9 04		lda #$04	            LDA #ERR_TYPE
.1a079f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a07a3	c2 20		rep #$20	            REP #$20
.1a07a5	29 ff 00	and #$00ff	            AND #$00FF
.1a07a8	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a07ab	e2 20		sep #$20	            SEP #$20
.1a07ad	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a07b0					cast
.1a07b0	20 c9 5b	jsr $1a5bc9	            JSR ITOF
.1a07b3	28		plp		done            PLP
.1a07b4	60		rts		            RTS
.1a07b5					ASS_ARG2_FLOAT
.1a07b5	08		php		                PHP
.1a07b6	e2 20		sep #$20	            SEP #$20
.1a07b8	a5 2d		lda $082d	                LDA ARGTYPE2            ; Check the type
.1a07ba	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.1a07bc	f0 26		beq $1a07e4	                BEQ done                ; Then we're done
.1a07be	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.1a07c0	f0 1f		beq $1a07e1	                BEQ cast                ; Then cast it to float
.1a07c2					type_err
.1a07c2	08		php		            PHP
.1a07c3	c2 20		rep #$20	            REP #$20
.1a07c5	48		pha		            PHA
.1a07c6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a07c9	5b		tcd		            TCD
.1a07ca	68		pla		            PLA
.1a07cb	28		plp		            PLP
.1a07cc	e2 20		sep #$20	            SEP #$20
.1a07ce	a9 04		lda #$04	            LDA #ERR_TYPE
.1a07d0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a07d4	c2 20		rep #$20	            REP #$20
.1a07d6	29 ff 00	and #$00ff	            AND #$00FF
.1a07d9	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a07dc	e2 20		sep #$20	            SEP #$20
.1a07de	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a07e1					cast
.1a07e1	20 e6 07	jsr $1a07e6	            JSR CAST_ARG2_FLOAT
.1a07e4	28		plp		done            PLP
.1a07e5	60		rts		            RTS
.1a07e6					CAST_ARG2_FLOAT
.1a07e6	c2 20		rep #$20	            REP #$20
.1a07e8	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a07ea	48		pha		            PHA
.1a07eb	a5 23		lda $0823	            LDA ARGUMENT1
.1a07ed	48		pha		            PHA
.1a07ee	c2 20		rep #$20	            REP #$20
.1a07f0	a5 29		lda $0829	            LDA ARGUMENT2
.1a07f2	85 23		sta $0823	            STA ARGUMENT1
.1a07f4	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a07f6	85 25		sta $0825	            STA ARGUMENT1+2
.1a07f8	e2 20		sep #$20	            SEP #$20
.1a07fa	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a07fc	85 27		sta $0827	            STA ARGTYPE1
.1a07fe	20 c9 5b	jsr $1a5bc9	            JSR ITOF
.1a0801	c2 20		rep #$20	            REP #$20
.1a0803	a5 23		lda $0823	            LDA ARGUMENT1
.1a0805	85 29		sta $0829	            STA ARGUMENT2
.1a0807	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a0809	85 2b		sta $082b	            STA ARGUMENT2+2
.1a080b	e2 20		sep #$20	            SEP #$20
.1a080d	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.1a080f	85 2d		sta $082d	            STA ARGTYPE2
.1a0811	c2 20		rep #$20	            REP #$20
.1a0813	68		pla		            PLA
.1a0814	85 23		sta $0823	            STA ARGUMENT1
.1a0816	68		pla		            PLA
.1a0817	85 25		sta $0825	            STA ARGUMENT1+2
.1a0819	60		rts		            RTS
.1a081a					ASS_ARGS_NUM
.1a081a	08		php		                PHP
.1a081b	e2 20		sep #$20	            SEP #$20
.1a081d	a5 27		lda $0827	                LDA ARGTYPE1                ; Check ARGUMENT1
.1a081f	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a0821	f0 23		beq $1a0846	                BEQ arg1_int
.1a0823	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.1a0825	f0 2e		beq $1a0855	                BEQ arg1_float
.1a0827					type_err
.1a0827	08		php		            PHP
.1a0828	c2 20		rep #$20	            REP #$20
.1a082a	48		pha		            PHA
.1a082b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a082e	5b		tcd		            TCD
.1a082f	68		pla		            PLA
.1a0830	28		plp		            PLP
.1a0831	e2 20		sep #$20	            SEP #$20
.1a0833	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0835	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0839	c2 20		rep #$20	            REP #$20
.1a083b	29 ff 00	and #$00ff	            AND #$00FF
.1a083e	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a0841	e2 20		sep #$20	            SEP #$20
.1a0843	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0846	a5 2d		lda $082d	arg1_int        LDA ARGTYPE2                ; Check argument 2
.1a0848	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If integer, we're done
.1a084a	f0 16		beq $1a0862	                BEQ done
.1a084c	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If not float, throw an error
.1a084e	d0 d7		bne $1a0827	                BNE type_err
.1a0850	20 c9 5b	jsr $1a5bc9	            JSR ITOF
.1a0853	80 0d		bra $1a0862	                BRA done
.1a0855	a5 2d		lda $082d	arg1_float      LDA ARGTYPE2                ; Check argument 2
.1a0857	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If it's float
.1a0859	f0 07		beq $1a0862	                BEQ done                    ; Then we're done
.1a085b	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If it's not integer
.1a085d	d0 c8		bne $1a0827	                BNE type_err                ; Thrown an error
.1a085f	20 e6 07	jsr $1a07e6	            JSR CAST_ARG2_FLOAT
.1a0862					done
.1a0862	e2 20		sep #$20	            SEP #$20
.1a0864	a5 27		lda $0827	                LDA ARGTYPE1                ; Return the type code in A
.1a0866	28		plp		                PLP
.1a0867	60		rts		            RTS
.1a0868					ASS_ARGS_NUMSTR
.1a0868	08		php		                PHP
.1a0869	e2 20		sep #$20	            SEP #$20
.1a086b	a5 27		lda $0827	                LDA ARGTYPE1                ; Check to see if ARGUMENT1 is a string
.1a086d	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a086f	d0 25		bne $1a0896	                BNE numbers
.1a0871	a5 2d		lda $082d	                LDA ARGTYPE2                ; If ARGUMENT1 is a string, make sure ARGUMENT2 is
.1a0873	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a0875	f0 24		beq $1a089b	                BEQ done
.1a0877					TYPE_ERR
.1a0877	08		php		            PHP
.1a0878	c2 20		rep #$20	            REP #$20
.1a087a	48		pha		            PHA
.1a087b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a087e	5b		tcd		            TCD
.1a087f	68		pla		            PLA
.1a0880	28		plp		            PLP
.1a0881	e2 20		sep #$20	            SEP #$20
.1a0883	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0885	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0889	c2 20		rep #$20	            REP #$20
.1a088b	29 ff 00	and #$00ff	            AND #$00FF
.1a088e	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a0891	e2 20		sep #$20	            SEP #$20
.1a0893	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0896					numbers
.1a0896	20 1a 08	jsr $1a081a	            JSR ASS_ARGS_NUM
.1a0899	a5 27		lda $0827	                LDA ARGTYPE1                ; Make sure A is the type
.1a089b	28		plp		done            PLP
.1a089c	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\tokens.s

.0000					TOKEN
>0000					precedence  .byte ?
>0001					length      .byte ?
>0002					name        .word <>?
>0004					eval        .word <>?
>0006					arity       .word <>?
.1a089d					PARSEINT
.1a089d	08		php		            PHP
.1a089e	0b		phd		            PHD
.1a089f	08		php		            PHP
.1a08a0	c2 20		rep #$20	            REP #$20
.1a08a2	48		pha		            PHA
.1a08a3	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a08a6	5b		tcd		            TCD
.1a08a7	68		pla		            PLA
.1a08a8	28		plp		            PLP
.1a08a9	c2 30		rep #$30	            REP #$30
.1a08ab	64 23		stz $0823	            STZ ARGUMENT1       ; Default to Not-a-value
.1a08ad	64 25		stz $0825	            STZ ARGUMENT1+2
.1a08af	e2 20		sep #$20	            SEP #$20
.1a08b1	64 27		stz $0827	            STZ ARGTYPE1
.1a08b3	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it starts with '$'
.1a08b5	c9 26		cmp #$26	            CMP #'&'
.1a08b7	f0 44		beq $1a08fd	            BEQ check_hex       ; Yes: parse it as a hexadecimal number
.1a08b9					loop
.1a08b9	e2 20		sep #$20	            SEP #$20
.1a08bb	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.1a08bd	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a08c0	90 76		bcc $1a0938	            BCC done            ; No, we're done parsing
.1a08c2	20 3f 05	jsr $1a053f	            JSR MULINT10
.1a08c5	38		sec		            SEC                 ; Convert the ASCII code to a number
.1a08c6	e9 30		sbc #$30	            SBC #'0'
.1a08c8	c2 20		rep #$20	            REP #$20
.1a08ca	29 ff 00	and #$00ff	            AND #$00FF
.1a08cd	18		clc		            CLC
.1a08ce	65 23		adc $0823	            ADC ARGUMENT1
.1a08d0	85 23		sta $0823	            STA ARGUMENT1
.1a08d2	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a08d4	69 00 00	adc #$0000	            ADC #0
.1a08d7	85 25		sta $0825	            STA ARGUMENT1+2
.1a08d9	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a08dc	80 db		bra $1a08b9	            BRA loop            ; And try to process it
.1a08de					syntaxerr
.1a08de	08		php		            PHP
.1a08df	c2 20		rep #$20	            REP #$20
.1a08e1	48		pha		            PHA
.1a08e2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a08e5	5b		tcd		            TCD
.1a08e6	68		pla		            PLA
.1a08e7	28		plp		            PLP
.1a08e8	e2 20		sep #$20	            SEP #$20
.1a08ea	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a08ec	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a08f0	c2 20		rep #$20	            REP #$20
.1a08f2	29 ff 00	and #$00ff	            AND #$00FF
.1a08f5	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a08f8	e2 20		sep #$20	            SEP #$20
.1a08fa	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a08fd					check_hex
.1a08fd	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a0900	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.1a0902	c9 48		cmp #$48	            CMP #'H'            ; Is it 'H'?
.1a0904	f0 04		beq $1a090a	            BEQ parse_hex       ; Yes: skip it and parse hex
.1a0906	c9 68		cmp #$68	            CMP #'h'            ; Is it 'h'?
.1a0908	d0 d4		bne $1a08de	            BNE syntaxerr       ; No: throw an error
.1a090a					parse_hex
.1a090a	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a090d					hexloop
.1a090d	e2 20		sep #$20	            SEP #$20
.1a090f	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.1a0911	20 d1 04	jsr $1a04d1	            JSR ISHEX
.1a0914	90 22		bcc $1a0938	            BCC done            ; No, we're done parsing
.1a0916	20 f2 04	jsr $1a04f2	            JSR HEX2BIN
.1a0919	c2 20		rep #$20	            REP #$20
.1a091b	06 23		asl $0823	            ASL ARGUMENT1
.1a091d	26 25		rol $0825	            ROL ARGUMENT1+2
.1a091f	06 23		asl $0823	            ASL ARGUMENT1
.1a0921	26 25		rol $0825	            ROL ARGUMENT1+2
.1a0923	06 23		asl $0823	            ASL ARGUMENT1
.1a0925	26 25		rol $0825	            ROL ARGUMENT1+2
.1a0927	06 23		asl $0823	            ASL ARGUMENT1
.1a0929	26 25		rol $0825	            ROL ARGUMENT1+2
.1a092b	29 ff 00	and #$00ff	            AND #$00FF          ; Add binary number to ARGUMENT1
.1a092e	18		clc		            CLC
.1a092f	65 23		adc $0823	            ADC ARGUMENT1
.1a0931	85 23		sta $0823	            STA ARGUMENT1
.1a0933	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a0936	80 d5		bra $1a090d	            BRA hexloop         ; And try to process it
.1a0938	2b		pld		done        PLD
.1a0939	28		plp		            PLP
.1a093a	60		rts		            RTS
.1a093b					PREVCHAR
.1a093b	08		php		            PHP
.1a093c	c2 30		rep #$30	            REP #$30
.1a093e	a5 04		lda $0804	            LDA BIPPREV
.1a0940	f0 1c		beq $1a095e	            BEQ ret_false
.1a0942	38		sec		            SEC
.1a0943	a5 04		lda $0804	            LDA BIPPREV
.1a0945	e5 1a		sbc $081a	            SBC CURLINE
.1a0947	a8		tay		            TAY
.1a0948	e2 20		sep #$20	            SEP #$20
.1a094a	b7 1a		lda [$081a],y	loop        LDA [CURLINE],Y
.1a094c	f0 10		beq $1a095e	            BEQ ret_false
.1a094e	c9 20		cmp #$20	            CMP #CHAR_SP
.1a0950	f0 06		beq $1a0958	            BEQ go_back
.1a0952	c9 09		cmp #$09	            CMP #CHAR_TAB
.1a0954	f0 02		beq $1a0958	            BEQ go_back
.1a0956	28		plp		            PLP
.1a0957	60		rts		            RTS
.1a0958	88		dey		go_back     DEY
.1a0959	c0 ff ff	cpy #$ffff	            CPY #$FFFF
.1a095c	d0 ec		bne $1a094a	            BNE loop
.1a095e					ret_false
.1a095e	a9 00		lda #$00	            LDA #0
.1a0960	60		rts		            RTS
.1a0961					TOKENIZE
.1a0961	08		php		            PHP
.1a0962	0b		phd		            PHD
.1a0963	08		php		            PHP
.1a0964	c2 20		rep #$20	            REP #$20
.1a0966	48		pha		            PHA
.1a0967	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a096a	5b		tcd		            TCD
.1a096b	68		pla		            PLA
.1a096c	28		plp		            PLP
.1a096d	c2 30		rep #$30	            REP #$30
.1a096f	a5 1a		lda $081a	            LDA CURLINE
.1a0971	85 00		sta $0800	            STA BIP
.1a0973	e2 20		sep #$20	            SEP #$20
.1a0975	a5 1c		lda $081c	            LDA CURLINE+2
.1a0977	85 02		sta $0802	            STA BIP+2
.1a0979	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a097c	a7 00		lda [$0800]	            LDA [BIP]               ; Do we have a numeral?
.1a097e	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a0981	90 0c		bcc $1a098f	            BCC mv_curline          ; No: adjust CURLINE and tokenize
.1a0983	20 9d 08	jsr $1a089d	            JSR PARSEINT
.1a0986	c2 20		rep #$20	            REP #$20
.1a0988	a5 23		lda $0823	            LDA ARGUMENT1
.1a098a	85 d7		sta $08d7	            STA LINENUM
.1a098c	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a098f					mv_curline
.1a098f	c2 20		rep #$20	            REP #$20
.1a0991	a5 00		lda $0800	            LDA BIP
.1a0993	85 1a		sta $081a	            STA CURLINE
.1a0995	e2 20		sep #$20	            SEP #$20
.1a0997	a5 02		lda $0802	            LDA BIP+2
.1a0999	85 1c		sta $081c	            STA CURLINE+2
.1a099b	20 af 09	jsr $1a09af	            JSR FINDREM
.1a099e	e2 20		sep #$20	            SEP #$20
.1a09a0					loop
.1a09a0	20 20 0a	jsr $1a0a20	            JSR TKFINDTOKEN
.1a09a3	c9 00		cmp #$00	            CMP #0                  ; Did we find a token?
.1a09a5	f0 05		beq $1a09ac	            BEQ done                ; No: return
.1a09a7	20 cb 0b	jsr $1a0bcb	            JSR TKWRITE
.1a09aa	80 f4		bra $1a09a0	            BRA loop                ; And try again
.1a09ac	2b		pld		done        PLD
.1a09ad	28		plp		            PLP
.1a09ae	60		rts		            RTS
.1a09af					FINDREM
.1a09af	08		php		            PHP
.1a09b0	c2 20		rep #$20	            REP #$20
.1a09b2	a5 1a		lda $081a	            LDA CURLINE             ; Point BIP to the beginning of the line
.1a09b4	85 00		sta $0800	            STA BIP
.1a09b6	a5 1c		lda $081c	            LDA CURLINE+2
.1a09b8	85 02		sta $0802	            STA BIP+2
.1a09ba	a2 00 00	ldx #$0000	            LDX #0                  ; X will be a flag that we're at the beginning
.1a09bd	e2 20		sep #$20	            SEP #$20
.1a09bf	a0 00 00	ldy #$0000	loop        LDY #0
.1a09c2	e0 00 00	cpx #$0000	            CPX #0                  ; If we are at the first space on the line
.1a09c5	f0 0d		beq $1a09d4	            BEQ skip_delim          ; ... skip looking for a delimiter
.1a09c7	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a09c9	f0 53		beq $1a0a1e	            BEQ done                ; Is it null? Then we're done
.1a09cb	c9 3a		cmp #$3a	            CMP #':'                ; Is it ":"
.1a09cd	f0 04		beq $1a09d3	            BEQ found_delim         ; Yes: we might have a REM... look for E
.1a09cf	c9 20		cmp #$20	            CMP #CHAR_SP
.1a09d1	d0 33		bne $1a0a06	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a09d3	c8		iny		found_delim INY
.1a09d4	b7 00		lda [$0800],y	skip_delim  LDA [BIP],Y             ; Get the first character
.1a09d6	f0 46		beq $1a0a1e	            BEQ done                ; Is it null? Then we're done
.1a09d8	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.1a09da	f0 10		beq $1a09ec	            BEQ found_R             ; Yes: we might have a REM... look for E
.1a09dc	c9 72		cmp #$72	            CMP #'r'
.1a09de	d0 26		bne $1a0a06	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a09e0	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a09e2	f0 3a		beq $1a0a1e	            BEQ done                ; Is it null? Then we're done
.1a09e4	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.1a09e6	f0 04		beq $1a09ec	            BEQ found_R             ; Yes: we might have a REM... look for E
.1a09e8	c9 72		cmp #$72	            CMP #'r'
.1a09ea	d0 1a		bne $1a0a06	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a09ec	c8		iny		found_R     INY
.1a09ed	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a09ef	f0 2d		beq $1a0a1e	            BEQ done                ; Is it null? Then we're done
.1a09f1	c9 45		cmp #$45	            CMP #'E'                ; Is it "E"
.1a09f3	f0 04		beq $1a09f9	            BEQ found_E             ; Yes: we might have a REM... look for M
.1a09f5	c9 65		cmp #$65	            CMP #'e'
.1a09f7	d0 0d		bne $1a0a06	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a09f9	c8		iny		found_E     INY
.1a09fa	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a09fc	f0 20		beq $1a0a1e	            BEQ done                ; Is it null? Then we're done
.1a09fe	c9 4d		cmp #$4d	            CMP #'M'                ; Is it "E"
.1a0a00	f0 0a		beq $1a0a0c	            BEQ found_REM           ; Yes: we might have a REM... look for M
.1a0a02	c9 6d		cmp #$6d	            CMP #'m'
.1a0a04	f0 06		beq $1a0a0c	            BEQ found_REM
.1a0a06	e8		inx		next_pos    INX                     ; Indicate we're no longer at the first position
.1a0a07	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a0a0a	80 b3		bra $1a09bf	            BRA loop
.1a0a0c	a7 00		lda [$0800]	found_REM   LDA [BIP]               ; Get the current character
.1a0a0e	c9 3a		cmp #$3a	            CMP #':'                ; Is it the delimiter?
.1a0a10	d0 03		bne $1a0a15	            BNE ret_REM             ; No: go ahead and return REM at that location
.1a0a12	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a0a15	a9 03		lda #$03	ret_REM     LDA #3
.1a0a17	85 1e		sta $081e	            STA CURTOKLEN           ; Set the size
.1a0a19	a9 91		lda #$91	            LDA #TOK_REM            ; And the token to write
.1a0a1b	20 cb 0b	jsr $1a0bcb	            JSR TKWRITE
.1a0a1e	28		plp		done        PLP
.1a0a1f	60		rts		            RTS
.1a0a20					TKFINDTOKEN
.1a0a20	08		php		            PHP
.1a0a21	0b		phd		            PHD
.1a0a22	08		php		            PHP
.1a0a23	c2 20		rep #$20	            REP #$20
.1a0a25	48		pha		            PHA
.1a0a26	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0a29	5b		tcd		            TCD
.1a0a2a	68		pla		            PLA
.1a0a2b	28		plp		            PLP
.1a0a2c	e2 20		sep #$20	            SEP #$20
.1a0a2e	a9 7f		lda #$7f	            LDA #$7F                ; Start off looking for any size token
.1a0a30	85 1e		sta $081e	            STA CURTOKLEN
.1a0a32					next_size
.1a0a32	c2 10		rep #$10	            REP #$10
.1a0a34	20 80 0b	jsr $1a0b80	            JSR TKNEXTBIG
.1a0a37	a5 1e		lda $081e	            LDA CURTOKLEN           ; Are there any keywords left?
.1a0a39	d0 03		bne $1a0a3e	            BNE else
.1a0a3b	4c c0 0a	jmp $1a0ac0	            JMP done                ; No: return to caller
.1a0a3e					else
.1a0a3e	c2 20		rep #$20	            REP #$20
.1a0a40	a5 1a		lda $081a	            LDA CURLINE
.1a0a42	85 00		sta $0800	            STA BIP
.1a0a44	e2 20		sep #$20	            SEP #$20
.1a0a46	a5 1c		lda $081c	            LDA CURLINE+2
.1a0a48	85 02		sta $0802	            STA BIP+2
.1a0a4a	c2 20		rep #$20	            REP #$20
.1a0a4c	64 04		stz $0804	            STZ BIPPREV             ; Clear BIPPREV (point to the previous character)
.1a0a4e	64 06		stz $0806	            STZ BIPPREV+2
.1a0a50					check_len
.1a0a50	e2 30		sep #$30	            SEP #$30
.1a0a52	a0 00		ldy #$00	            LDY #0
.1a0a54	b7 00		lda [$0800],y	nul_scan    LDA [BIP],Y
.1a0a56	f0 da		beq $1a0a32	            BEQ next_size
.1a0a58	c9 91		cmp #$91	            CMP #TOK_REM            ; Tokenization stops at REMarks too
.1a0a5a	f0 d6		beq $1a0a32	            BEQ next_size
.1a0a5c	c8		iny		            INY
.1a0a5d	c4 1e		cpy $081e	            CPY CURTOKLEN
.1a0a5f	90 f3		bcc $1a0a54	            BCC nul_scan
.1a0a61	c2 10		rep #$10	            REP #$10
.1a0a63	a7 00		lda [$0800]	            LDA [BIP]               ; Check the current character
.1a0a65	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.1a0a67	d0 05		bne $1a0a6e	            BNE chk_keyword         ; No: check to see if we are at the start of a possible keyword
.1a0a69	20 e2 0a	jsr $1a0ae2	            JSR SKIPQUOTED
.1a0a6c	80 28		bra $1a0a96	            BRA go_next             ; And move on to the next character
.1a0a6e	a5 1e		lda $081e	chk_keyword LDA CURTOKLEN           ; If the token length is <=2
.1a0a70	c9 03		cmp #$03	            CMP #3
.1a0a72	90 19		bcc $1a0a8d	            BLT try_match           ; ... we don't need a delimiter, go ahead and convert it
.1a0a74	c2 20		rep #$20	            REP #$20
.1a0a76	a5 00		lda $0800	            LDA BIP                 ; Check to see if we're at the start of the line
.1a0a78	c5 1a		cmp $081a	            CMP CURLINE
.1a0a7a	d0 08		bne $1a0a84	            BNE chk_delim           ; No: we need to check for a delimiters
.1a0a7c	e2 20		sep #$20	            SEP #$20
.1a0a7e	a5 02		lda $0802	            LDA BIP+2
.1a0a80	c5 1c		cmp $081c	            CMP CURLINE+2
.1a0a82	f0 09		beq $1a0a8d	            BEQ try_match           ; Yes: this can be a keyword
.1a0a84					chk_delim
.1a0a84	e2 20		sep #$20	            SEP #$20
.1a0a86	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.1a0a88	20 12 51	jsr $1a5112	            JSR ISVARCHAR
.1a0a8b	b0 09		bcs $1a0a96	            BCS go_next             ; Yes: we can't start a keyword here
.1a0a8d					try_match
.1a0a8d	e2 20		sep #$20	            SEP #$20
.1a0a8f	20 f2 0a	jsr $1a0af2	            JSR TKMATCH
.1a0a92	c9 00		cmp #$00	            CMP #0                  ; Did we get one?
.1a0a94	d0 11		bne $1a0aa7	            BNE found               ; Yes: return it
.1a0a96					go_next
.1a0a96	c2 20		rep #$20	            REP #$20
.1a0a98	a5 00		lda $0800	            LDA BIP                 ; Update BIPPREV as the point to the previous character
.1a0a9a	85 04		sta $0804	            STA BIPPREV
.1a0a9c	e2 20		sep #$20	            SEP #$20
.1a0a9e	a5 02		lda $0802	            LDA BIP+2
.1a0aa0	85 06		sta $0806	            STA BIPPREV+2
.1a0aa2	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a0aa5	80 a9		bra $1a0a50	            BRA check_len           ; And try there
.1a0aa7					found
.1a0aa7	c9 81		cmp #$81	            CMP #TOK_MINUS          ; Found a token... is it minus?
.1a0aa9	d0 15		bne $1a0ac0	            BNE done                ; Nope: go ahead and return it
.1a0aab	20 3b 09	jsr $1a093b	            JSR PREVCHAR
.1a0aae	c9 00		cmp #$00	            CMP #0                  ; Did we get anything?
.1a0ab0	f0 11		beq $1a0ac3	            BEQ syntax              ; No: line cannot start with minus... throw error
.1a0ab2	89 80		bit #$80	            BIT #$80                ; Is it a token?
.1a0ab4	f0 08		beq $1a0abe	            BEQ binaryminus         ; No: leave token unchanged
.1a0ab6	c9 90		cmp #$90	            CMP #TOK_RPAREN         ; Is the token a right parenthesis?
.1a0ab8	f0 04		beq $1a0abe	            BEQ binaryminus         ; Yes: then this should be a binary minus operator
.1a0aba	a9 af		lda #$af	            LDA #TOK_NEGATIVE       ; Otherwise: this should be a unary minus (negation)
.1a0abc	80 02		bra $1a0ac0	            BRA done
.1a0abe	a9 81		lda #$81	binaryminus LDA #TOK_MINUS          ; It's data... so token should be for binary minus
.1a0ac0					done
.1a0ac0	2b		pld		            PLD
.1a0ac1	28		plp		            PLP
.1a0ac2	60		rts		            RTS
.1a0ac3					syntax
.1a0ac3	08		php		            PHP
.1a0ac4	c2 20		rep #$20	            REP #$20
.1a0ac6	48		pha		            PHA
.1a0ac7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0aca	5b		tcd		            TCD
.1a0acb	68		pla		            PLA
.1a0acc	28		plp		            PLP
.1a0acd	e2 20		sep #$20	            SEP #$20
.1a0acf	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a0ad1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0ad5	c2 20		rep #$20	            REP #$20
.1a0ad7	29 ff 00	and #$00ff	            AND #$00FF
.1a0ada	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a0add	e2 20		sep #$20	            SEP #$20
.1a0adf	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0ae2					SKIPQUOTED
.1a0ae2	08		php		            PHP
.1a0ae3	e2 20		sep #$20	            SEP #$20
.1a0ae5					loop
.1a0ae5	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a0ae8	a7 00		lda [$0800]	            LDA [BIP]
.1a0aea	f0 04		beq $1a0af0	            BEQ done                ; If EOL, just return
.1a0aec	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.1a0aee	d0 f5		bne $1a0ae5	            BNE loop                ; No: keep skipping
.1a0af0	28		plp		done        PLP
.1a0af1	60		rts		            RTS
.1a0af2					TKMATCH
.1a0af2	da		phx		            PHX
.1a0af3	5a		phy		            PHY
.1a0af4	08		php		            PHP
.1a0af5	0b		phd		            PHD
.1a0af6	08		php		            PHP
.1a0af7	c2 20		rep #$20	            REP #$20
.1a0af9	48		pha		            PHA
.1a0afa	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0afd	5b		tcd		            TCD
.1a0afe	68		pla		            PLA
.1a0aff	28		plp		            PLP
.1a0b00	c2 20		rep #$20	            REP #$20
.1a0b02	a5 04		lda $0804	            LDA BIPPREV
.1a0b04	d0 0a		bne $1a0b10	            BNE check_prev
.1a0b06	e2 20		sep #$20	            SEP #$20
.1a0b08	a5 04		lda $0804	            LDA BIPPREV
.1a0b0a	d0 04		bne $1a0b10	            BNE check_prev
.1a0b0c	a9 00		lda #$00	            LDA #0
.1a0b0e	80 0a		bra $1a0b1a	            BRA save_delim
.1a0b10					check_prev
.1a0b10	e2 20		sep #$20	            SEP #$20
.1a0b12	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.1a0b14	20 12 51	jsr $1a5112	            JSR ISVARCHAR
.1a0b17	a9 00		lda #$00	            LDA #0
.1a0b19	2a		rol a		            ROL A
.1a0b1a	85 28		sta $0828	save_delim  STA SIGN1               ; SIGN1 := 1 if it is a variable name character
.1a0b1c	c2 30		rep #$30	            REP #$30
.1a0b1e	a9 c0 0c	lda #$0cc0	            LDA #<>TOKENS           ; Set INDEX to point to the first token record
.1a0b21	85 08		sta $0808	            STA INDEX
.1a0b23	e2 20		sep #$20	            SEP #$20
.1a0b25	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0b27	85 0a		sta $080a	            STA INDEX+2
.1a0b29	a2 80 00	ldx #$0080	            LDX #$80                ; Set the initial token ID
.1a0b2c					token_loop
.1a0b2c	e2 20		sep #$20	            SEP #$20
.1a0b2e	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.1a0b31	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the current token
.1a0b33	f0 31		beq $1a0b66	            BEQ no_match            ; Is it 0? We're out of tokens... no match found
.1a0b35	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it the same as the size of the window?
.1a0b37	d0 32		bne $1a0b6b	            BNE next_token          ; No: try the next token
.1a0b39	c2 30		rep #$30	            REP #$30
.1a0b3b	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.1a0b3e	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the pointer to the token's name
.1a0b40	85 0c		sta $080c	            STA SCRATCH             ; Set SCRATCH to point to the token's name
.1a0b42	e2 20		sep #$20	            SEP #$20
.1a0b44	a9 1a		lda #$1a	            LDA #`DATA_BLOCK
.1a0b46	85 0e		sta $080e	            STA SCRATCH+2
.1a0b48	a5 28		lda $0828	            LDA SIGN1               ; Is previous character a variable name character?
.1a0b4a	f0 07		beq $1a0b53	            BEQ cmp_keyword         ; No: we can check for this token
.1a0b4c	a7 0c		lda [$080c]	            LDA [SCRATCH]           ; Get the token's first character
.1a0b4e	20 12 51	jsr $1a5112	            JSR ISVARCHAR
.1a0b51	b0 18		bcs $1a0b6b	            BCS next_token          ; Yes: skip this token
.1a0b53					cmp_keyword
.1a0b53	e2 10		sep #$10	            SEP #$10
.1a0b55	a0 00		ldy #$00	            LDY #0
.1a0b57	b7 00		lda [$0800],y	cmp_loop    LDA [BIP],Y             ; Get the character in the window
.1a0b59	20 1b 05	jsr $1a051b	            JSR TOUPPERA
.1a0b5c	d7 0c		cmp [$080c],y	            CMP [SCRATCH],Y         ; Compare to the character in the token
.1a0b5e	d0 0b		bne $1a0b6b	            BNE next_token          ; If they don't match, try the next token
.1a0b60	c8		iny		            INY                     ; Move to the next character in the window
.1a0b61	c4 1e		cpy $081e	            CPY CURTOKLEN           ; Have we checked the whole window?
.1a0b63	90 f2		bcc $1a0b57	            BCC cmp_loop            ; No: check this next character
.1a0b65	8a		txa		            TXA                     ; Move the token ID to A
.1a0b66	2b		pld		no_match    PLD
.1a0b67	28		plp		            PLP
.1a0b68	7a		ply		            PLY
.1a0b69	fa		plx		            PLX
.1a0b6a	60		rts		            RTS
.1a0b6b					next_token
.1a0b6b	c2 30		rep #$30	            REP #$30
.1a0b6d	18		clc		            CLC
.1a0b6e	a5 08		lda $0808	            LDA INDEX
.1a0b70	69 08 00	adc #$0008	            ADC #size(TOKEN)
.1a0b73	85 08		sta $0808	            STA INDEX
.1a0b75	e2 20		sep #$20	            SEP #$20
.1a0b77	a5 0a		lda $080a	            LDA INDEX+2
.1a0b79	69 00		adc #$00	            ADC #0
.1a0b7b	85 0a		sta $080a	            STA INDEX+2
.1a0b7d	e8		inx		            INX                     ; Increment the token ID
.1a0b7e	80 ac		bra $1a0b2c	            BRA token_loop          ; And check that token
.1a0b80					TKNEXTBIG
.1a0b80	08		php		            PHP
.1a0b81	0b		phd		            PHD
.1a0b82	8b		phb		            PHB
.1a0b83	08		php		            PHP
.1a0b84	c2 20		rep #$20	            REP #$20
.1a0b86	48		pha		            PHA
.1a0b87	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0b8a	5b		tcd		            TCD
.1a0b8b	68		pla		            PLA
.1a0b8c	28		plp		            PLP
.1a0b8d	c2 30		rep #$30	            REP #$30
.1a0b8f	a9 c0 0c	lda #$0cc0	            LDA #<>TOKENS
.1a0b92	85 08		sta $0808	            STA INDEX
.1a0b94	a9 1a 00	lda #$001a	            LDA #`TOKENS
.1a0b97	85 0a		sta $080a	            STA INDEX+2
.1a0b99	64 0c		stz $080c	            STZ SCRATCH             ; Clear SCRATCH
.1a0b9b					loop
.1a0b9b	e2 20		sep #$20	            SEP #$20
.1a0b9d	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.1a0ba0	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the token
.1a0ba2	f0 1d		beq $1a0bc1	            BEQ done                ; If length is 0, we're done
.1a0ba4	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it >= CURTOKLEN?
.1a0ba6	b0 06		bcs $1a0bae	            BGE skip                ; Yes: skip to the next token
.1a0ba8	c5 0c		cmp $080c	            CMP SCRATCH             ; No: is it < SCRATCH?
.1a0baa	90 02		bcc $1a0bae	            BLT skip                ; Yes: skip to the next token
.1a0bac	85 0c		sta $080c	            STA SCRATCH             ; No: it's our new longest token!
.1a0bae					skip
.1a0bae	c2 20		rep #$20	            REP #$20
.1a0bb0	18		clc		            CLC
.1a0bb1	a5 08		lda $0808	            LDA INDEX
.1a0bb3	69 08 00	adc #$0008	            ADC #size(TOKEN)
.1a0bb6	85 08		sta $0808	            STA INDEX
.1a0bb8	a5 0a		lda $080a	            LDA INDEX+2
.1a0bba	69 00 00	adc #$0000	            ADC #0
.1a0bbd	85 0a		sta $080a	            STA INDEX+2
.1a0bbf	80 da		bra $1a0b9b	            BRA loop                ; And go around for another pass
.1a0bc1					done
.1a0bc1	e2 20		sep #$20	            SEP #$20
.1a0bc3	a5 0c		lda $080c	            LDA SCRATCH
.1a0bc5	85 1e		sta $081e	            STA CURTOKLEN
.1a0bc7	ab		plb		            PLB
.1a0bc8	2b		pld		            PLD
.1a0bc9	28		plp		            PLP
.1a0bca	60		rts		            RTS
.1a0bcb					TKWRITE
.1a0bcb	08		php		            PHP
.1a0bcc	0b		phd		            PHD
.1a0bcd	08		php		            PHP
.1a0bce	c2 20		rep #$20	            REP #$20
.1a0bd0	48		pha		            PHA
.1a0bd1	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0bd4	5b		tcd		            TCD
.1a0bd5	68		pla		            PLA
.1a0bd6	28		plp		            PLP
.1a0bd7	e2 20		sep #$20	            SEP #$20
.1a0bd9	87 00		sta [$0800]	            STA [BIP]               ; Write the token to the line
.1a0bdb	c2 20		rep #$20	            REP #$20
.1a0bdd	18		clc		            CLC
.1a0bde	a5 00		lda $0800	            LDA BIP
.1a0be0	69 01 00	adc #$0001	            ADC #1
.1a0be3	85 08		sta $0808	            STA INDEX
.1a0be5	a5 02		lda $0802	            LDA BIP+2
.1a0be7	69 00 00	adc #$0000	            ADC #0
.1a0bea	85 0a		sta $080a	            STA INDEX+2
.1a0bec	e2 10		sep #$10	            SEP #$10
.1a0bee	a4 1e		ldy $081e	            LDY CURTOKLEN           ; Y will be the number of characters to move down
.1a0bf0	88		dey		            DEY
.1a0bf1					copy_down
.1a0bf1	e2 20		sep #$20	            SEP #$20
.1a0bf3	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the byte to move down
.1a0bf5	87 08		sta [$0808]	            STA [INDEX]             ; Move it down
.1a0bf7	f0 13		beq $1a0c0c	            BEQ done                ; We've reached the end of the line
.1a0bf9	c2 20		rep #$20	            REP #$20
.1a0bfb	18		clc		            CLC
.1a0bfc	a5 08		lda $0808	            LDA INDEX
.1a0bfe	69 01 00	adc #$0001	            ADC #1
.1a0c01	85 08		sta $0808	            STA INDEX
.1a0c03	a5 0a		lda $080a	            LDA INDEX+2
.1a0c05	69 00 00	adc #$0000	            ADC #0
.1a0c08	85 0a		sta $080a	            STA INDEX+2
.1a0c0a	80 e5		bra $1a0bf1	            BRA copy_down
.1a0c0c	2b		pld		done        PLD
.1a0c0d	28		plp		            PLP
.1a0c0e	60		rts		            RTS
.1a0c0f					GETTOKREC
.1a0c0f	08		php		            PHP
.1a0c10	c2 30		rep #$30	            REP #$30
.1a0c12	29 7f 00	and #$007f	            AND #$007F
.1a0c15	0a		asl a		            ASL A
.1a0c16	0a		asl a		            ASL A
.1a0c17	0a		asl a		            ASL A
.1a0c18	18		clc		            CLC
.1a0c19	69 c0 0c	adc #$0cc0	            ADC #<>TOKENS
.1a0c1c	aa		tax		            TAX                         ; X is now the data bank relative address of the token record
.1a0c1d	28		plp		            PLP
.1a0c1e	60		rts		            RTS
.1a0c1f					TOKPRECED
.1a0c1f	08		php		            PHP
.1a0c20	8b		phb		            PHB
.1a0c21	0b		phd		            PHD
.1a0c22	08		php		            PHP
.1a0c23	c2 20		rep #$20	            REP #$20
.1a0c25	48		pha		            PHA
.1a0c26	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0c29	5b		tcd		            TCD
.1a0c2a	68		pla		            PLA
.1a0c2b	28		plp		            PLP
.1a0c2c	08		php		            PHP
.1a0c2d	e2 20		sep #$20	            SEP #$20
.1a0c2f	48		pha		            PHA
.1a0c30	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0c32	48		pha		            PHA
.1a0c33	ab		plb		            PLB
.1a0c34	68		pla		            PLA
.1a0c35	28		plp		            PLP
.1a0c36	e2 20		sep #$20	            SEP #$20
.1a0c38	c2 10		rep #$10	            REP #$10
.1a0c3a	20 0f 0c	jsr $1a0c0f	            JSR GETTOKREC
.1a0c3d	bd 00 00	lda $1a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.1a0c40	c2 20		rep #$20	            REP #$20
.1a0c42	29 0f 00	and #$000f	            AND #$000F                  ; Mask off the type code
.1a0c45	2b		pld		            PLD
.1a0c46	ab		plb		            PLB
.1a0c47	28		plp		            PLP
.1a0c48	60		rts		            RTS
.1a0c49					TOKEVAL
.1a0c49	08		php		            PHP
.1a0c4a	8b		phb		            PHB
.1a0c4b	0b		phd		            PHD
.1a0c4c	08		php		            PHP
.1a0c4d	c2 20		rep #$20	            REP #$20
.1a0c4f	48		pha		            PHA
.1a0c50	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0c53	5b		tcd		            TCD
.1a0c54	68		pla		            PLA
.1a0c55	28		plp		            PLP
.1a0c56	08		php		            PHP
.1a0c57	e2 20		sep #$20	            SEP #$20
.1a0c59	48		pha		            PHA
.1a0c5a	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0c5c	48		pha		            PHA
.1a0c5d	ab		plb		            PLB
.1a0c5e	68		pla		            PLA
.1a0c5f	28		plp		            PLP
.1a0c60	c2 30		rep #$30	            REP #$30
.1a0c62	20 0f 0c	jsr $1a0c0f	            JSR GETTOKREC
.1a0c65	bd 04 00	lda $1a0004,x	            LDA #TOKEN.eval,B,X         ; Get the address of the evaluation function
.1a0c68	2b		pld		            PLD
.1a0c69	ab		plb		            PLB
.1a0c6a	28		plp		            PLP
.1a0c6b	60		rts		            RTS
.1a0c6c					TOKTYPE
.1a0c6c	08		php		            PHP
.1a0c6d	8b		phb		            PHB
.1a0c6e	0b		phd		            PHD
.1a0c6f	08		php		            PHP
.1a0c70	c2 20		rep #$20	            REP #$20
.1a0c72	48		pha		            PHA
.1a0c73	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0c76	5b		tcd		            TCD
.1a0c77	68		pla		            PLA
.1a0c78	28		plp		            PLP
.1a0c79	08		php		            PHP
.1a0c7a	e2 20		sep #$20	            SEP #$20
.1a0c7c	48		pha		            PHA
.1a0c7d	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0c7f	48		pha		            PHA
.1a0c80	ab		plb		            PLB
.1a0c81	68		pla		            PLA
.1a0c82	28		plp		            PLP
.1a0c83	e2 20		sep #$20	            SEP #$20
.1a0c85	c2 10		rep #$10	            REP #$10
.1a0c87	20 0f 0c	jsr $1a0c0f	            JSR GETTOKREC
.1a0c8a	bd 00 00	lda $1a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.1a0c8d	c2 20		rep #$20	            REP #$20
.1a0c8f	29 f0 00	and #$00f0	            AND #$00F0                  ; Mask off the type code
.1a0c92	2b		pld		            PLD
.1a0c93	ab		plb		            PLB
.1a0c94	28		plp		            PLP
.1a0c95	60		rts		            RTS
.1a0c96					TOKARITY
.1a0c96	08		php		            PHP
.1a0c97	8b		phb		            PHB
.1a0c98	0b		phd		            PHD
.1a0c99	08		php		            PHP
.1a0c9a	c2 20		rep #$20	            REP #$20
.1a0c9c	48		pha		            PHA
.1a0c9d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0ca0	5b		tcd		            TCD
.1a0ca1	68		pla		            PLA
.1a0ca2	28		plp		            PLP
.1a0ca3	08		php		            PHP
.1a0ca4	e2 20		sep #$20	            SEP #$20
.1a0ca6	48		pha		            PHA
.1a0ca7	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0ca9	48		pha		            PHA
.1a0caa	ab		plb		            PLB
.1a0cab	68		pla		            PLA
.1a0cac	28		plp		            PLP
.1a0cad	e2 20		sep #$20	            SEP #$20
.1a0caf	c2 10		rep #$10	            REP #$10
.1a0cb1	20 0f 0c	jsr $1a0c0f	            JSR GETTOKREC
.1a0cb4	bd 06 00	lda $1a0006,x	            LDA #TOKEN.arity,B,X        ; Get the arity
.1a0cb7	c2 20		rep #$20	            REP #$20
.1a0cb9	29 ff 00	and #$00ff	            AND #$00FF
.1a0cbc	2b		pld		            PLD
.1a0cbd	ab		plb		            PLB
.1a0cbe	28		plp		            PLP
.1a0cbf	60		rts		            RTS
=$00					TOK_EOL = $00
=$01					TOK_FUNC_OPEN = $01     ; A pseudo-token to push to the operator stack to mark
=$00					TOK_TY_OP = $00         ; The token is an operator
=$10					TOK_TY_CMD = $10        ; The token is a command (e.g. RUN, LIST, etc.)
=$20					TOK_TY_STMNT = $20      ; The token is a statement (e.g. INPUT, PRINT, DIM, etc.)
=$30					TOK_TY_FUNC = $30       ; The token is a function (e.g. SIN, COS, TAB, etc.)
=$40					TOK_TY_PUNCT = $40      ; The token is a punctuation mark (e.g. "(", ")")
=$50					TOK_TY_BYWRD = $50      ; The token is a by-word (e.g. STEP, TO, WEND, etc.)
.1a0cc0					TOKENS
=$80					TOK_PLUS = $80
>1ad010	2b 00				TOKEN_TEXT  .null "+"
>1a0cc0	03				precedence  .byte TOK_TY_OP | 3
>1a0cc1	01				length      .byte len("+")
>1a0cc2	10 d0				name        .word <>TOKEN_TEXT
>1a0cc4	a8 27				eval        .word <>OP_PLUS
>1a0cc6	02 00				arity       .word <>2
=$81					TOK_MINUS = $81
>1ad012	2d 00				TOKEN_TEXT  .null "-"
>1a0cc8	03				precedence  .byte TOK_TY_OP | 3
>1a0cc9	01				length      .byte len("-")
>1a0cca	12 d0				name        .word <>TOKEN_TEXT
>1a0ccc	e8 27				eval        .word <>OP_MINUS
>1a0cce	02 00				arity       .word <>2
=$82					TOK_MULT = $82
>1ad014	2a 00				TOKEN_TEXT  .null "*"
>1a0cd0	02				precedence  .byte TOK_TY_OP | 2
>1a0cd1	01				length      .byte len("*")
>1a0cd2	14 d0				name        .word <>TOKEN_TEXT
>1a0cd4	1f 28				eval        .word <>OP_MULTIPLY
>1a0cd6	02 00				arity       .word <>2
=$83					TOK_DIVIDE = $83
>1ad016	2f 00				TOKEN_TEXT  .null "/"
>1a0cd8	02				precedence  .byte TOK_TY_OP | 2
>1a0cd9	01				length      .byte len("/")
>1a0cda	16 d0				name        .word <>TOKEN_TEXT
>1a0cdc	56 28				eval        .word <>OP_DIVIDE
>1a0cde	02 00				arity       .word <>2
=$84					TOK_MOD = $84
>1ad018	4d 4f 44 00			TOKEN_TEXT  .null "MOD"
>1a0ce0	02				precedence  .byte TOK_TY_OP | 2
>1a0ce1	03				length      .byte len("MOD")
>1a0ce2	18 d0				name        .word <>TOKEN_TEXT
>1a0ce4	60 28				eval        .word <>OP_MOD
>1a0ce6	02 00				arity       .word <>2
>1ad01c	5e 00				TOKEN_TEXT  .null "^"
>1a0ce8	00				precedence  .byte TOK_TY_OP | 0
>1a0ce9	01				length      .byte len("^")
>1a0cea	1c d0				name        .word <>TOKEN_TEXT
>1a0cec	73 28				eval        .word <>OP_POW
>1a0cee	02 00				arity       .word <>2
=$86					TOK_LE = $86
>1ad01e	3c 3d 00			TOKEN_TEXT  .null "<="
>1a0cf0	04				precedence  .byte TOK_TY_OP | 4
>1a0cf1	02				length      .byte len("<=")
>1a0cf2	1e d0				name        .word <>TOKEN_TEXT
>1a0cf4	31 2a				eval        .word <>OP_LTE
>1a0cf6	02 00				arity       .word <>2
=$87					TOK_GE = $87
>1ad021	3e 3d 00			TOKEN_TEXT  .null ">="
>1a0cf8	04				precedence  .byte TOK_TY_OP | 4
>1a0cf9	02				length      .byte len(">=")
>1a0cfa	21 d0				name        .word <>TOKEN_TEXT
>1a0cfc	f1 29				eval        .word <>OP_GTE
>1a0cfe	02 00				arity       .word <>2
=$88					TOK_NE = $88
>1ad024	3c 3e 00			TOKEN_TEXT  .null "<>"
>1a0d00	04				precedence  .byte TOK_TY_OP | 4
>1a0d01	02				length      .byte len("<>")
>1a0d02	24 d0				name        .word <>TOKEN_TEXT
>1a0d04	b1 29				eval        .word <>OP_NE
>1a0d06	02 00				arity       .word <>2
>1ad027	3c 00				TOKEN_TEXT  .null "<"
>1a0d08	04				precedence  .byte TOK_TY_OP | 4
>1a0d09	01				length      .byte len("<")
>1a0d0a	27 d0				name        .word <>TOKEN_TEXT
>1a0d0c	f1 28				eval        .word <>OP_LT
>1a0d0e	02 00				arity       .word <>2
=$8a					TOK_EQ = $8A
>1ad029	3d 00				TOKEN_TEXT  .null "="
>1a0d10	04				precedence  .byte TOK_TY_OP | 4
>1a0d11	01				length      .byte len("=")
>1a0d12	29 d0				name        .word <>TOKEN_TEXT
>1a0d14	71 29				eval        .word <>OP_EQ
>1a0d16	02 00				arity       .word <>2
>1ad02b	3e 00				TOKEN_TEXT  .null ">"
>1a0d18	04				precedence  .byte TOK_TY_OP | 4
>1a0d19	01				length      .byte len(">")
>1a0d1a	2b d0				name        .word <>TOKEN_TEXT
>1a0d1c	31 29				eval        .word <>OP_GT
>1a0d1e	02 00				arity       .word <>2
>1ad02d	4e 4f 54 00			TOKEN_TEXT  .null "NOT"
>1a0d20	05				precedence  .byte TOK_TY_OP | 5
>1a0d21	03				length      .byte len("NOT")
>1a0d22	2d d0				name        .word <>TOKEN_TEXT
>1a0d24	db 28				eval        .word <>OP_NOT
>1a0d26	01 00				arity       .word <>1
>1ad031	41 4e 44 00			TOKEN_TEXT  .null "AND"
>1a0d28	06				precedence  .byte TOK_TY_OP | 6
>1a0d29	03				length      .byte len("AND")
>1a0d2a	31 d0				name        .word <>TOKEN_TEXT
>1a0d2c	ad 28				eval        .word <>OP_AND
>1a0d2e	02 00				arity       .word <>2
>1ad035	4f 52 00			TOKEN_TEXT  .null "OR"
>1a0d30	07				precedence  .byte TOK_TY_OP | 7
>1a0d31	02				length      .byte len("OR")
>1a0d32	35 d0				name        .word <>TOKEN_TEXT
>1a0d34	c4 28				eval        .word <>OP_OR
>1a0d36	02 00				arity       .word <>2
=$8f					TOK_LPAREN = $8F
>1ad038	28 00				TOKEN_TEXT  .null "("
>1a0d38	ff				precedence  .byte TOK_TY_PUNCT | $FF
>1a0d39	01				length      .byte len("(")
>1a0d3a	38 d0				name        .word <>TOKEN_TEXT
>1a0d3c	00 00				eval        .word <>0
>1a0d3e	00 00				arity       .word <>0
=$90					TOK_RPAREN = $90
>1ad03a	29 00				TOKEN_TEXT  .null ")"
>1a0d40	40				precedence  .byte TOK_TY_PUNCT | 0
>1a0d41	01				length      .byte len(")")
>1a0d42	3a d0				name        .word <>TOKEN_TEXT
>1a0d44	00 00				eval        .word <>0
>1a0d46	00 00				arity       .word <>0
=$91					TOK_REM = $91
>1ad03c	52 45 4d 00			TOKEN_TEXT  .null "REM"
>1a0d48	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d49	03				length      .byte len("REM")
>1a0d4a	3c d0				name        .word <>TOKEN_TEXT
>1a0d4c	44 41				eval        .word <>S_REM
>1a0d4e	00 00				arity       .word <>0
=$92					TOK_PRINT = $92
>1ad040	50 52 49 4e 54 00		TOKEN_TEXT  .null "PRINT"
>1a0d50	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d51	05				length      .byte len("PRINT")
>1a0d52	40 d0				name        .word <>TOKEN_TEXT
>1a0d54	49 45				eval        .word <>S_PRINT
>1a0d56	00 00				arity       .word <>0
=$93					TOK_LET = $93
>1ad046	4c 45 54 00			TOKEN_TEXT  .null "LET"
>1a0d58	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d59	03				length      .byte len("LET")
>1a0d5a	46 d0				name        .word <>TOKEN_TEXT
>1a0d5c	94 44				eval        .word <>S_LET
>1a0d5e	00 00				arity       .word <>0
>1ad04a	47 4f 54 4f 00			TOKEN_TEXT  .null "GOTO"
>1a0d60	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d61	04				length      .byte len("GOTO")
>1a0d62	4a d0				name        .word <>TOKEN_TEXT
>1a0d64	34 44				eval        .word <>S_GOTO
>1a0d66	00 00				arity       .word <>0
=$95					TOK_END = $95
>1ad04f	45 4e 44 00			TOKEN_TEXT  .null "END"
>1a0d68	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d69	03				length      .byte len("END")
>1a0d6a	4f d0				name        .word <>TOKEN_TEXT
>1a0d6c	2b 44				eval        .word <>S_END
>1a0d6e	00 00				arity       .word <>0
>1ad053	49 46 00			TOKEN_TEXT  .null "IF"
>1a0d70	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d71	02				length      .byte len("IF")
>1a0d72	53 d0				name        .word <>TOKEN_TEXT
>1a0d74	c3 43				eval        .word <>S_IF
>1a0d76	00 00				arity       .word <>0
=$97					TOK_THEN = $97
>1ad056	54 48 45 4e 00			TOKEN_TEXT  .null "THEN"
>1a0d78	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0d79	04				length      .byte len("THEN")
>1a0d7a	56 d0				name        .word <>TOKEN_TEXT
>1a0d7c	00 00				eval        .word <>0
>1a0d7e	00 00				arity       .word <>0
>1ad05b	45 4c 53 45 00			TOKEN_TEXT  .null "ELSE"
>1a0d80	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0d81	04				length      .byte len("ELSE")
>1a0d82	5b d0				name        .word <>TOKEN_TEXT
>1a0d84	00 00				eval        .word <>0
>1a0d86	00 00				arity       .word <>0
>1ad060	47 4f 53 55 42 00		TOKEN_TEXT  .null "GOSUB"
>1a0d88	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d89	05				length      .byte len("GOSUB")
>1a0d8a	60 d0				name        .word <>TOKEN_TEXT
>1a0d8c	06 43				eval        .word <>S_GOSUB
>1a0d8e	00 00				arity       .word <>0
>1ad066	52 45 54 55 52 4e 00		TOKEN_TEXT  .null "RETURN"
>1a0d90	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d91	06				length      .byte len("RETURN")
>1a0d92	66 d0				name        .word <>TOKEN_TEXT
>1a0d94	7f 43				eval        .word <>S_RETURN
>1a0d96	00 00				arity       .word <>0
=$9b					TOK_FOR = $9B
>1ad06d	46 4f 52 00			TOKEN_TEXT  .null "FOR"
>1a0d98	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d99	03				length      .byte len("FOR")
>1a0d9a	6d d0				name        .word <>TOKEN_TEXT
>1a0d9c	5b 41				eval        .word <>S_FOR
>1a0d9e	00 00				arity       .word <>0
=$9c					TOK_TO = $9C
>1ad071	54 4f 00			TOKEN_TEXT  .null "TO"
>1a0da0	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0da1	02				length      .byte len("TO")
>1a0da2	71 d0				name        .word <>TOKEN_TEXT
>1a0da4	00 00				eval        .word <>0
>1a0da6	00 00				arity       .word <>0
=$9d					TOK_STEP = $9D
>1ad074	53 54 45 50 00			TOKEN_TEXT  .null "STEP"
>1a0da8	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0da9	04				length      .byte len("STEP")
>1a0daa	74 d0				name        .word <>TOKEN_TEXT
>1a0dac	00 00				eval        .word <>0
>1a0dae	00 00				arity       .word <>0
=$9e					TOK_NEXT = $9E
>1ad079	4e 45 58 54 00			TOKEN_TEXT  .null "NEXT"
>1a0db0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0db1	04				length      .byte len("NEXT")
>1a0db2	79 d0				name        .word <>TOKEN_TEXT
>1a0db4	4f 42				eval        .word <>S_NEXT
>1a0db6	00 00				arity       .word <>0
=$9f					TOK_DO = $9F
>1ad07e	44 4f 00			TOKEN_TEXT  .null "DO"
>1a0db8	20				precedence  .byte TOK_TY_STMNT | 0
>1a0db9	02				length      .byte len("DO")
>1a0dba	7e d0				name        .word <>TOKEN_TEXT
>1a0dbc	55 41				eval        .word <>S_DO
>1a0dbe	00 00				arity       .word <>0
=$a0					TOK_LOOP = $A0
>1ad081	4c 4f 4f 50 00			TOKEN_TEXT  .null "LOOP"
>1a0dc0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0dc1	04				length      .byte len("LOOP")
>1a0dc2	81 d0				name        .word <>TOKEN_TEXT
>1a0dc4	58 41				eval        .word <>S_LOOP
>1a0dc6	00 00				arity       .word <>0
>1ad086	57 48 49 4c 45 00		TOKEN_TEXT  .null "WHILE"
>1a0dc8	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0dc9	05				length      .byte len("WHILE")
>1a0dca	86 d0				name        .word <>TOKEN_TEXT
>1a0dcc	00 00				eval        .word <>0
>1a0dce	00 00				arity       .word <>0
>1ad08c	55 4e 54 49 4c 00		TOKEN_TEXT  .null "UNTIL"
>1a0dd0	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0dd1	05				length      .byte len("UNTIL")
>1a0dd2	8c d0				name        .word <>TOKEN_TEXT
>1a0dd4	00 00				eval        .word <>0
>1a0dd6	00 00				arity       .word <>0
>1ad092	45 58 49 54 00			TOKEN_TEXT  .null "EXIT"
>1a0dd8	20				precedence  .byte TOK_TY_STMNT | 0
>1a0dd9	04				length      .byte len("EXIT")
>1a0dda	92 d0				name        .word <>TOKEN_TEXT
>1a0ddc	52 41				eval        .word <>S_EXIT
>1a0dde	00 00				arity       .word <>0
>1ad097	43 4c 52 00			TOKEN_TEXT  .null "CLR"
>1a0de0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0de1	03				length      .byte len("CLR")
>1a0de2	97 d0				name        .word <>TOKEN_TEXT
>1a0de4	8a 44				eval        .word <>S_CLR
>1a0de6	00 00				arity       .word <>0
>1ad09b	53 54 4f 50 00			TOKEN_TEXT  .null "STOP"
>1a0de8	20				precedence  .byte TOK_TY_STMNT | 0
>1a0de9	04				length      .byte len("STOP")
>1a0dea	9b d0				name        .word <>TOKEN_TEXT
>1a0dec	25 41				eval        .word <>S_STOP
>1a0dee	00 00				arity       .word <>0
>1ad0a0	50 4f 4b 45 00			TOKEN_TEXT  .null "POKE"
>1a0df0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0df1	04				length      .byte len("POKE")
>1a0df2	a0 d0				name        .word <>TOKEN_TEXT
>1a0df4	b5 40				eval        .word <>S_POKE
>1a0df6	00 00				arity       .word <>0
>1ad0a5	50 4f 4b 45 57 00		TOKEN_TEXT  .null "POKEW"
>1a0df8	20				precedence  .byte TOK_TY_STMNT | 0
>1a0df9	05				length      .byte len("POKEW")
>1a0dfa	a5 d0				name        .word <>TOKEN_TEXT
>1a0dfc	4b 40				eval        .word <>S_POKEW
>1a0dfe	00 00				arity       .word <>0
>1ad0ab	50 4f 4b 45 4c 00		TOKEN_TEXT  .null "POKEL"
>1a0e00	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e01	05				length      .byte len("POKEL")
>1a0e02	ab d0				name        .word <>TOKEN_TEXT
>1a0e04	d8 3f				eval        .word <>S_POKEL
>1a0e06	00 00				arity       .word <>0
>1ad0b1	43 4c 53 00			TOKEN_TEXT  .null "CLS"
>1a0e08	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e09	03				length      .byte len("CLS")
>1a0e0a	b1 d0				name        .word <>TOKEN_TEXT
>1a0e0c	d4 3f				eval        .word <>S_CLS
>1a0e0e	00 00				arity       .word <>0
>1ad0b5	52 45 41 44 00			TOKEN_TEXT  .null "READ"
>1a0e10	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e11	04				length      .byte len("READ")
>1a0e12	b5 d0				name        .word <>TOKEN_TEXT
>1a0e14	b5 3e				eval        .word <>S_READ
>1a0e16	00 00				arity       .word <>0
=$ab					TOK_DATA = $AB
>1ad0ba	44 41 54 41 00			TOKEN_TEXT  .null "DATA"
>1a0e18	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e19	04				length      .byte len("DATA")
>1a0e1a	ba d0				name        .word <>TOKEN_TEXT
>1a0e1c	c7 3f				eval        .word <>S_DATA
>1a0e1e	00 00				arity       .word <>0
>1ad0bf	52 45 53 54 4f 52 45 00		TOKEN_TEXT  .null "RESTORE"
>1a0e20	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e21	07				length      .byte len("RESTORE")
>1a0e22	bf d0				name        .word <>TOKEN_TEXT
>1a0e24	cb 3f				eval        .word <>S_RESTORE
>1a0e26	00 00				arity       .word <>0
>1ad0c7	44 49 4d 00			TOKEN_TEXT  .null "DIM"
>1a0e28	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e29	03				length      .byte len("DIM")
>1a0e2a	c7 d0				name        .word <>TOKEN_TEXT
>1a0e2c	08 3e				eval        .word <>S_DIM
>1a0e2e	00 00				arity       .word <>0
>1ad0cb	43 41 4c 4c 00			TOKEN_TEXT  .null "CALL"
>1a0e30	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e31	04				length      .byte len("CALL")
>1a0e32	cb d0				name        .word <>TOKEN_TEXT
>1a0e34	71 3d				eval        .word <>S_CALL
>1a0e36	00 00				arity       .word <>0
=$af					TOK_NEGATIVE = $AF
>1ad0d0	2d 00				TOKEN_TEXT  .null "-"
>1a0e38	00				precedence  .byte TOK_TY_OP | 0
>1a0e39	01				length      .byte len("-")
>1a0e3a	d0 d0				name        .word <>TOKEN_TEXT
>1a0e3c	71 2a				eval        .word <>OP_NEGATIVE
>1a0e3e	01 00				arity       .word <>1
>1ad0d2	4c 45 4e 00			TOKEN_TEXT  .null "LEN"
>1a0e40	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e41	03				length      .byte len("LEN")
>1a0e42	d2 d0				name        .word <>TOKEN_TEXT
>1a0e44	61 4b				eval        .word <>FN_LEN
>1a0e46	00 00				arity       .word <>0
>1ad0d6	50 45 45 4b 00			TOKEN_TEXT  .null "PEEK"
>1a0e48	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e49	04				length      .byte len("PEEK")
>1a0e4a	d6 d0				name        .word <>TOKEN_TEXT
>1a0e4c	b1 4b				eval        .word <>FN_PEEK
>1a0e4e	00 00				arity       .word <>0
>1ad0db	50 45 45 4b 57 00		TOKEN_TEXT  .null "PEEKW"
>1a0e50	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e51	05				length      .byte len("PEEKW")
>1a0e52	db d0				name        .word <>TOKEN_TEXT
>1a0e54	7a 4c				eval        .word <>FN_PEEKW
>1a0e56	00 00				arity       .word <>0
>1ad0e1	50 45 45 4b 4c 00		TOKEN_TEXT  .null "PEEKL"
>1a0e58	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e59	05				length      .byte len("PEEKL")
>1a0e5a	e1 d0				name        .word <>TOKEN_TEXT
>1a0e5c	07 4c				eval        .word <>FN_PEEKL
>1a0e5e	00 00				arity       .word <>0
>1ad0e7	43 48 52 24 00			TOKEN_TEXT  .null "CHR$"
>1a0e60	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e61	04				length      .byte len("CHR$")
>1a0e62	e7 d0				name        .word <>TOKEN_TEXT
>1a0e64	d9 4c				eval        .word <>FN_CHR
>1a0e66	00 00				arity       .word <>0
>1ad0ec	41 53 43 00			TOKEN_TEXT  .null "ASC"
>1a0e68	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e69	03				length      .byte len("ASC")
>1a0e6a	ec d0				name        .word <>TOKEN_TEXT
>1a0e6c	2e 4d				eval        .word <>FN_ASC
>1a0e6e	00 00				arity       .word <>0
>1ad0f0	53 50 43 00			TOKEN_TEXT  .null "SPC"
>1a0e70	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e71	03				length      .byte len("SPC")
>1a0e72	f0 d0				name        .word <>TOKEN_TEXT
>1a0e74	73 4d				eval        .word <>FN_SPC
>1a0e76	00 00				arity       .word <>0
>1ad0f4	54 41 42 00			TOKEN_TEXT  .null "TAB"
>1a0e78	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e79	03				length      .byte len("TAB")
>1a0e7a	f4 d0				name        .word <>TOKEN_TEXT
>1a0e7c	fc 4d				eval        .word <>FN_TAB
>1a0e7e	00 00				arity       .word <>0
>1ad0f8	41 42 53 00			TOKEN_TEXT  .null "ABS"
>1a0e80	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e81	03				length      .byte len("ABS")
>1a0e82	f8 d0				name        .word <>TOKEN_TEXT
>1a0e84	85 4e				eval        .word <>FN_ABS
>1a0e86	00 00				arity       .word <>0
>1ad0fc	53 47 4e 00			TOKEN_TEXT  .null "SGN"
>1a0e88	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e89	03				length      .byte len("SGN")
>1a0e8a	fc d0				name        .word <>TOKEN_TEXT
>1a0e8c	e7 4e				eval        .word <>FN_SGN
>1a0e8e	00 00				arity       .word <>0
>1ad100	48 45 58 24 00			TOKEN_TEXT  .null "HEX$"
>1a0e90	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e91	04				length      .byte len("HEX$")
>1a0e92	00 d1				name        .word <>TOKEN_TEXT
>1a0e94	d3 4a				eval        .word <>FN_HEX
>1a0e96	00 00				arity       .word <>0
>1ad105	44 45 43 00			TOKEN_TEXT  .null "DEC"
>1a0e98	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e99	03				length      .byte len("DEC")
>1a0e9a	05 d1				name        .word <>TOKEN_TEXT
>1a0e9c	72 4a				eval        .word <>FN_DEC
>1a0e9e	00 00				arity       .word <>0
>1ad109	53 54 52 24 00			TOKEN_TEXT  .null "STR$"
>1a0ea0	30				precedence  .byte TOK_TY_FUNC | 0
>1a0ea1	04				length      .byte len("STR$")
>1a0ea2	09 d1				name        .word <>TOKEN_TEXT
>1a0ea4	24 4a				eval        .word <>FN_STR
>1a0ea6	00 00				arity       .word <>0
>1ad10e	56 41 4c 00			TOKEN_TEXT  .null "VAL"
>1a0ea8	30				precedence  .byte TOK_TY_FUNC | 0
>1a0ea9	03				length      .byte len("VAL")
>1a0eaa	0e d1				name        .word <>TOKEN_TEXT
>1a0eac	ce 49				eval        .word <>FN_VAL
>1a0eae	00 00				arity       .word <>0
>1ad112	4c 45 46 54 24 00		TOKEN_TEXT  .null "LEFT$"
>1a0eb0	30				precedence  .byte TOK_TY_FUNC | 0
>1a0eb1	05				length      .byte len("LEFT$")
>1a0eb2	12 d1				name        .word <>TOKEN_TEXT
>1a0eb4	05 49				eval        .word <>FN_LEFT
>1a0eb6	00 00				arity       .word <>0
>1ad118	52 49 47 48 54 24 00		TOKEN_TEXT  .null "RIGHT$"
>1a0eb8	30				precedence  .byte TOK_TY_FUNC | 0
>1a0eb9	06				length      .byte len("RIGHT$")
>1a0eba	18 d1				name        .word <>TOKEN_TEXT
>1a0ebc	24 48				eval        .word <>FN_RIGHT
>1a0ebe	00 00				arity       .word <>0
>1ad11f	4d 49 44 24 00			TOKEN_TEXT  .null "MID$"
>1a0ec0	30				precedence  .byte TOK_TY_FUNC | 0
>1a0ec1	04				length      .byte len("MID$")
>1a0ec2	1f d1				name        .word <>TOKEN_TEXT
>1a0ec4	6f 47				eval        .word <>FN_MID
>1a0ec6	00 00				arity       .word <>0
>1ad124	52 55 4e 00			TOKEN_TEXT  .null "RUN"
>1a0ec8	10				precedence  .byte TOK_TY_CMD | 0
>1a0ec9	03				length      .byte len("RUN")
>1a0eca	24 d1				name        .word <>TOKEN_TEXT
>1a0ecc	4e 50				eval        .word <>CMD_RUN
>1a0ece	00 00				arity       .word <>0
>1ad128	4e 45 57 00			TOKEN_TEXT  .null "NEW"
>1a0ed0	10				precedence  .byte TOK_TY_CMD | 0
>1a0ed1	03				length      .byte len("NEW")
>1a0ed2	28 d1				name        .word <>TOKEN_TEXT
>1a0ed4	19 50				eval        .word <>CMD_NEW
>1a0ed6	00 00				arity       .word <>0
>1ad12c	4c 4f 41 44 00			TOKEN_TEXT  .null "LOAD"
>1a0ed8	10				precedence  .byte TOK_TY_CMD | 0
>1a0ed9	04				length      .byte len("LOAD")
>1a0eda	2c d1				name        .word <>TOKEN_TEXT
>1a0edc	22 6c				eval        .word <>CMD_LOAD
>1a0ede	00 00				arity       .word <>0
>1ad131	4c 49 53 54 00			TOKEN_TEXT  .null "LIST"
>1a0ee0	10				precedence  .byte TOK_TY_CMD | 0
>1a0ee1	04				length      .byte len("LIST")
>1a0ee2	31 d1				name        .word <>TOKEN_TEXT
>1a0ee4	65 50				eval        .word <>CMD_LIST
>1a0ee6	00 00				arity       .word <>0
>1ad136	44 49 52 00			TOKEN_TEXT  .null "DIR"
>1a0ee8	10				precedence  .byte TOK_TY_CMD | 0
>1a0ee9	03				length      .byte len("DIR")
>1a0eea	36 d1				name        .word <>TOKEN_TEXT
>1a0eec	49 69				eval        .word <>CMD_DIR
>1a0eee	00 00				arity       .word <>0
>1ad13a	42 4c 4f 41 44 00		TOKEN_TEXT  .null "BLOAD"
>1a0ef0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ef1	05				length      .byte len("BLOAD")
>1a0ef2	3a d1				name        .word <>TOKEN_TEXT
>1a0ef4	f4 6a				eval        .word <>S_BLOAD
>1a0ef6	00 00				arity       .word <>0
>1ad140	42 52 55 4e 00			TOKEN_TEXT  .null "BRUN"
>1a0ef8	10				precedence  .byte TOK_TY_CMD | 0
>1a0ef9	04				length      .byte len("BRUN")
>1a0efa	40 d1				name        .word <>TOKEN_TEXT
>1a0efc	cf 6b				eval        .word <>CMD_BRUN
>1a0efe	00 00				arity       .word <>0
>1ad145	42 53 41 56 45 00		TOKEN_TEXT  .null "BSAVE"
>1a0f00	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f01	05				length      .byte len("BSAVE")
>1a0f02	45 d1				name        .word <>TOKEN_TEXT
>1a0f04	db 6c				eval        .word <>S_BSAVE
>1a0f06	00 00				arity       .word <>0
>1ad14b	44 45 4c 00			TOKEN_TEXT  .null "DEL"
>1a0f08	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f09	03				length      .byte len("DEL")
>1a0f0a	4b d1				name        .word <>TOKEN_TEXT
>1a0f0c	fa 6d				eval        .word <>S_DEL
>1a0f0e	00 00				arity       .word <>0
>1ad14f	53 41 56 45 00			TOKEN_TEXT  .null "SAVE"
>1a0f10	10				precedence  .byte TOK_TY_CMD | 0
>1a0f11	04				length      .byte len("SAVE")
>1a0f12	4f d1				name        .word <>TOKEN_TEXT
>1a0f14	67 6d				eval        .word <>CMD_SAVE
>1a0f16	00 00				arity       .word <>0
>1ad154	52 45 4e 41 4d 45 00		TOKEN_TEXT  .null "RENAME"
>1a0f18	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f19	06				length      .byte len("RENAME")
>1a0f1a	54 d1				name        .word <>TOKEN_TEXT
>1a0f1c	70 6e				eval        .word <>S_RENAME
>1a0f1e	00 00				arity       .word <>0
>1ad15b	43 4f 50 59 00			TOKEN_TEXT  .null "COPY"
>1a0f20	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f21	04				length      .byte len("COPY")
>1a0f22	5b d1				name        .word <>TOKEN_TEXT
>1a0f24	94 6f				eval        .word <>S_COPY
>1a0f26	00 00				arity       .word <>0
>1ad160	4d 4f 4e 49 54 4f 52 00		TOKEN_TEXT  .null "MONITOR"
>1a0f28	10				precedence  .byte TOK_TY_CMD | 0
>1a0f29	07				length      .byte len("MONITOR")
>1a0f2a	60 d1				name        .word <>TOKEN_TEXT
>1a0f2c	16 50				eval        .word <>CMD_MONITOR
>1a0f2e	00 00				arity       .word <>0
>1ad168	47 45 54 00			TOKEN_TEXT  .null "GET"
>1a0f30	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f31	03				length      .byte len("GET")
>1a0f32	68 d1				name        .word <>TOKEN_TEXT
>1a0f34	ff 3c				eval        .word <>S_GET
>1a0f36	00 00				arity       .word <>0
>1ad16c	49 4e 50 55 54 00		TOKEN_TEXT  .null "INPUT"
>1a0f38	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f39	05				length      .byte len("INPUT")
>1a0f3a	6c d1				name        .word <>TOKEN_TEXT
>1a0f3c	0f 3c				eval        .word <>S_INPUT
>1a0f3e	00 00				arity       .word <>0
>1ad172	53 45 54 42 4f 52 44 45		TOKEN_TEXT  .null "SETBORDER"
>1ad17a	52 00
>1a0f40	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f41	09				length      .byte len("SETBORDER")
>1a0f42	72 d1				name        .word <>TOKEN_TEXT
>1a0f44	30 2c				eval        .word <>S_SETBORDER
>1a0f46	00 00				arity       .word <>0
>1ad17c	54 45 58 54 43 4f 4c 4f		TOKEN_TEXT  .null "TEXTCOLOR"
>1ad184	52 00
>1a0f48	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f49	09				length      .byte len("TEXTCOLOR")
>1a0f4a	7c d1				name        .word <>TOKEN_TEXT
>1a0f4c	bd 2b				eval        .word <>S_TEXTCOLOR
>1a0f4e	00 00				arity       .word <>0
>1ad186	53 45 54 42 47 43 4f 4c		TOKEN_TEXT  .null "SETBGCOLOR"
>1ad18e	4f 52 00
>1a0f50	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f51	0a				length      .byte len("SETBGCOLOR")
>1a0f52	86 d1				name        .word <>TOKEN_TEXT
>1a0f54	ed 2b				eval        .word <>S_SETBGCOLOR
>1a0f56	00 00				arity       .word <>0
>1ad191	53 45 54 44 41 54 45 00		TOKEN_TEXT  .null "SETDATE"
>1a0f58	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f59	07				length      .byte len("SETDATE")
>1a0f5a	91 d1				name        .word <>TOKEN_TEXT
>1a0f5c	2a 2b				eval        .word <>S_SETDATE
>1a0f5e	00 00				arity       .word <>0
>1ad199	47 45 54 44 41 54 45 24		TOKEN_TEXT  .null "GETDATE$"
>1ad1a1	00
>1a0f60	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f61	08				length      .byte len("GETDATE$")
>1a0f62	99 d1				name        .word <>TOKEN_TEXT
>1a0f64	26 46				eval        .word <>F_GETDATE
>1a0f66	00 00				arity       .word <>0
>1ad1a2	53 45 54 54 49 4d 45 00		TOKEN_TEXT  .null "SETTIME"
>1a0f68	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f69	07				length      .byte len("SETTIME")
>1a0f6a	a2 d1				name        .word <>TOKEN_TEXT
>1a0f6c	bf 2a				eval        .word <>S_SETTIME
>1a0f6e	00 00				arity       .word <>0
>1ad1aa	47 45 54 54 49 4d 45 24		TOKEN_TEXT  .null "GETTIME$"
>1ad1b2	00
>1a0f70	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f71	08				length      .byte len("GETTIME$")
>1a0f72	aa d1				name        .word <>TOKEN_TEXT
>1a0f74	90 46				eval        .word <>F_GETTIME
>1a0f76	00 00				arity       .word <>0
>1ad1b3	47 52 41 50 48 49 43 53		TOKEN_TEXT  .null "GRAPHICS"
>1ad1bb	00
>1a0f78	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f79	08				length      .byte len("GRAPHICS")
>1a0f7a	b3 d1				name        .word <>TOKEN_TEXT
>1a0f7c	75 2d				eval        .word <>S_GRAPHICS
>1a0f7e	00 00				arity       .word <>0
>1ad1bc	53 45 54 43 4f 4c 4f 52		TOKEN_TEXT  .null "SETCOLOR"
>1ad1c4	00
>1a0f80	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f81	08				length      .byte len("SETCOLOR")
>1a0f82	bc d1				name        .word <>TOKEN_TEXT
>1a0f84	a9 2c				eval        .word <>S_SETCOLOR
>1a0f86	00 00				arity       .word <>0
>1ad1c5	42 49 54 4d 41 50 00		TOKEN_TEXT  .null "BITMAP"
>1a0f88	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f89	06				length      .byte len("BITMAP")
>1a0f8a	c5 d1				name        .word <>TOKEN_TEXT
>1a0f8c	af 2e				eval        .word <>S_BITMAP
>1a0f8e	00 00				arity       .word <>0
>1ad1cc	43 4c 52 42 49 54 4d 41		TOKEN_TEXT  .null "CLRBITMAP"
>1ad1d4	50 00
>1a0f90	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f91	09				length      .byte len("CLRBITMAP")
>1a0f92	cc d1				name        .word <>TOKEN_TEXT
>1a0f94	b7 2f				eval        .word <>S_CLRBITMAP
>1a0f96	00 00				arity       .word <>0
>1ad1d6	50 4c 4f 54 00			TOKEN_TEXT  .null "PLOT"
>1a0f98	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f99	04				length      .byte len("PLOT")
>1a0f9a	d6 d1				name        .word <>TOKEN_TEXT
>1a0f9c	14 31				eval        .word <>S_PLOT
>1a0f9e	00 00				arity       .word <>0
>1ad1db	4c 49 4e 45 00			TOKEN_TEXT  .null "LINE"
>1a0fa0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fa1	04				length      .byte len("LINE")
>1a0fa2	db d1				name        .word <>TOKEN_TEXT
>1a0fa4	85 31				eval        .word <>S_LINE
>1a0fa6	00 00				arity       .word <>0
>1ad1e0	46 49 4c 4c 00			TOKEN_TEXT  .null "FILL"
>1a0fa8	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fa9	04				length      .byte len("FILL")
>1a0faa	e0 d1				name        .word <>TOKEN_TEXT
>1a0fac	1e 32				eval        .word <>S_FILL
>1a0fae	00 00				arity       .word <>0
>1ad1e5	53 50 52 49 54 45 00		TOKEN_TEXT  .null "SPRITE"
>1a0fb0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fb1	06				length      .byte len("SPRITE")
>1a0fb2	e5 d1				name        .word <>TOKEN_TEXT
>1a0fb4	5a 33				eval        .word <>S_SPRITE
>1a0fb6	00 00				arity       .word <>0
>1ad1ec	53 50 52 49 54 45 41 54		TOKEN_TEXT  .null "SPRITEAT"
>1ad1f4	00
>1a0fb8	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fb9	08				length      .byte len("SPRITEAT")
>1a0fba	ec d1				name        .word <>TOKEN_TEXT
>1a0fbc	f8 33				eval        .word <>S_SPRITEAT
>1a0fbe	00 00				arity       .word <>0
>1ad1f5	53 50 52 49 54 45 53 48		TOKEN_TEXT  .null "SPRITESHOW"
>1ad1fd	4f 57 00
>1a0fc0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fc1	0a				length      .byte len("SPRITESHOW")
>1a0fc2	f5 d1				name        .word <>TOKEN_TEXT
>1a0fc4	46 34				eval        .word <>S_SPRITESHOW
>1a0fc6	00 00				arity       .word <>0
>1ad200	54 49 4c 45 53 45 54 00		TOKEN_TEXT  .null "TILESET"
>1a0fc8	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fc9	07				length      .byte len("TILESET")
>1a0fca	00 d2				name        .word <>TOKEN_TEXT
>1a0fcc	7d 35				eval        .word <>S_TILESET
>1a0fce	00 00				arity       .word <>0
>1ad208	54 49 4c 45 4d 41 50 00		TOKEN_TEXT  .null "TILEMAP"
>1a0fd0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fd1	07				length      .byte len("TILEMAP")
>1a0fd2	08 d2				name        .word <>TOKEN_TEXT
>1a0fd4	fb 35				eval        .word <>S_TILEMAP
>1a0fd6	00 00				arity       .word <>0
>1ad210	54 49 4c 45 53 48 4f 57		TOKEN_TEXT  .null "TILESHOW"
>1ad218	00
>1a0fd8	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fd9	08				length      .byte len("TILESHOW")
>1a0fda	10 d2				name        .word <>TOKEN_TEXT
>1a0fdc	6d 36				eval        .word <>S_TILESHOW
>1a0fde	00 00				arity       .word <>0
>1ad219	54 49 4c 45 41 54 00		TOKEN_TEXT  .null "TILEAT"
>1a0fe0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fe1	06				length      .byte len("TILEAT")
>1a0fe2	19 d2				name        .word <>TOKEN_TEXT
>1a0fe4	aa 36				eval        .word <>S_TILEAT
>1a0fe6	00 00				arity       .word <>0
>1ad220	4d 45 4d 43 4f 50 59 00		TOKEN_TEXT  .null "MEMCOPY"
>1a0fe8	20				precedence  .byte TOK_TY_STMNT | 0
>1a0fe9	07				length      .byte len("MEMCOPY")
>1a0fea	20 d2				name        .word <>TOKEN_TEXT
>1a0fec	da 39				eval        .word <>S_MEMCOPY
>1a0fee	00 00				arity       .word <>0
=$e6					TOK_LINEAR = $E6
>1ad228	4c 49 4e 45 41 52 00		TOKEN_TEXT  .null "LINEAR"
>1a0ff0	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0ff1	06				length      .byte len("LINEAR")
>1a0ff2	28 d2				name        .word <>TOKEN_TEXT
>1a0ff4	00 00				eval        .word <>0
>1a0ff6	00 00				arity       .word <>0
=$e7					TOK_RECT = $E7
>1ad22f	52 45 43 54 00			TOKEN_TEXT  .null "RECT"
>1a0ff8	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0ff9	04				length      .byte len("RECT")
>1a0ffa	2f d2				name        .word <>TOKEN_TEXT
>1a0ffc	00 00				eval        .word <>0
>1a0ffe	00 00				arity       .word <>0
>1ad234	4c 4f 43 41 54 45 00		TOKEN_TEXT  .null "LOCATE"
>1a1000	20				precedence  .byte TOK_TY_STMNT | 0
>1a1001	06				length      .byte len("LOCATE")
>1a1002	34 d2				name        .word <>TOKEN_TEXT
>1a1004	ef 3b				eval        .word <>S_LOCATE
>1a1006	00 00				arity       .word <>0
>1ad23b	49 4e 54 00			TOKEN_TEXT  .null "INT"
>1a1008	30				precedence  .byte TOK_TY_FUNC | 0
>1a1009	03				length      .byte len("INT")
>1a100a	3b d2				name        .word <>TOKEN_TEXT
>1a100c	3d 4f				eval        .word <>FN_INT
>1a100e	00 00				arity       .word <>0
>1ad23f	52 4e 44 00			TOKEN_TEXT  .null "RND"
>1a1010	30				precedence  .byte TOK_TY_FUNC | 0
>1a1011	03				length      .byte len("RND")
>1a1012	3f d2				name        .word <>TOKEN_TEXT
>1a1014	f5 46				eval        .word <>FN_RND
>1a1016	00 00				arity       .word <>0
>1ad243	53 49 4e 00			TOKEN_TEXT  .null "SIN"
>1a1018	30				precedence  .byte TOK_TY_FUNC | 0
>1a1019	03				length      .byte len("SIN")
>1a101a	43 d2				name        .word <>TOKEN_TEXT
>1a101c	50 4f				eval        .word <>FN_SIN
>1a101e	00 00				arity       .word <>0
>1ad247	43 4f 53 00			TOKEN_TEXT  .null "COS"
>1a1020	30				precedence  .byte TOK_TY_FUNC | 0
>1a1021	03				length      .byte len("COS")
>1a1022	47 d2				name        .word <>TOKEN_TEXT
>1a1024	66 4f				eval        .word <>FN_COS
>1a1026	00 00				arity       .word <>0
>1ad24b	54 41 4e 00			TOKEN_TEXT  .null "TAN"
>1a1028	30				precedence  .byte TOK_TY_FUNC | 0
>1a1029	03				length      .byte len("TAN")
>1a102a	4b d2				name        .word <>TOKEN_TEXT
>1a102c	7c 4f				eval        .word <>FN_TAN
>1a102e	00 00				arity       .word <>0
>1ad24f	4c 4e 00			TOKEN_TEXT  .null "LN"
>1a1030	30				precedence  .byte TOK_TY_FUNC | 0
>1a1031	02				length      .byte len("LN")
>1a1032	4f d2				name        .word <>TOKEN_TEXT
>1a1034	92 4f				eval        .word <>FN_LN
>1a1036	00 00				arity       .word <>0
>1ad252	41 43 4f 53 00			TOKEN_TEXT  .null "ACOS"
>1a1038	30				precedence  .byte TOK_TY_FUNC | 0
>1a1039	04				length      .byte len("ACOS")
>1a103a	52 d2				name        .word <>TOKEN_TEXT
>1a103c	a8 4f				eval        .word <>FN_ACOS
>1a103e	00 00				arity       .word <>0
>1ad257	41 53 49 4e 00			TOKEN_TEXT  .null "ASIN"
>1a1040	30				precedence  .byte TOK_TY_FUNC | 0
>1a1041	04				length      .byte len("ASIN")
>1a1042	57 d2				name        .word <>TOKEN_TEXT
>1a1044	be 4f				eval        .word <>FN_ASIN
>1a1046	00 00				arity       .word <>0
>1ad25c	41 54 41 4e 00			TOKEN_TEXT  .null "ATAN"
>1a1048	30				precedence  .byte TOK_TY_FUNC | 0
>1a1049	04				length      .byte len("ATAN")
>1a104a	5c d2				name        .word <>TOKEN_TEXT
>1a104c	d4 4f				eval        .word <>FN_ATAN
>1a104e	00 00				arity       .word <>0
>1ad261	45 58 50 00			TOKEN_TEXT  .null "EXP"
>1a1050	30				precedence  .byte TOK_TY_FUNC | 0
>1a1051	03				length      .byte len("EXP")
>1a1052	61 d2				name        .word <>TOKEN_TEXT
>1a1054	ea 4f				eval        .word <>FN_EXP
>1a1056	00 00				arity       .word <>0
>1ad265	53 51 52 00			TOKEN_TEXT  .null "SQR"
>1a1058	30				precedence  .byte TOK_TY_FUNC | 0
>1a1059	03				length      .byte len("SQR")
>1a105a	65 d2				name        .word <>TOKEN_TEXT
>1a105c	00 50				eval        .word <>FN_SQR
>1a105e	00 00				arity       .word <>0
>1ad269	49 4e 4b 45 59 00		TOKEN_TEXT  .null "INKEY"
>1a1060	30				precedence  .byte TOK_TY_FUNC | 0
>1a1061	05				length      .byte len("INKEY")
>1a1062	69 d2				name        .word <>TOKEN_TEXT
>1a1064	4b 47				eval        .word <>FN_INKEY
>1a1066	00 00				arity       .word <>0
>1a1068	00 00 00 00 00 00 00 00		            .word 0, 0, 0, 0

;******  Return to file: src\basic816.s


;******  Processing file: src\heap.s

>08b7					ALLOCATED   .long ?     ; Pointer to the most recently allocated object
>08ba					HEAP        .long ?     ; Pointer to the top of the heap (next empty byte)
>08bd					FREED       .long ?     ; Pointer to a linked list of freed heap objects
>08c0					CURRBLOCK   .long ?     ; Pointer to the current heap allocated block
>08c3					CURRHEADER  .long ?     ; Pointer to the header of the current block
>08c6					CURREND     .long ?     ; Pointer to the byte immediately after the current block
>08c9					CURRFREED   .long ?     ; Pointer to the current freed block
>08cc					FREEDEND    .long ?     ; Pointer to the byte immediately after the current freed block
>08cf					LASTFREED   .long ?     ;
.0000					HEAPOBJ
>0000					TYPE        .byte ?     ; Code for the type of object allocated
>0001					COUNT       .byte ?     ; Number of references to the heap object
>0002					NEXT        .long ?     ; Pointer to the next object in the list (used when freed)
>0005					END         .long ?     ; Pointer to the next byte after the block
.1a1070					INITHEAP
.1a1070	08		php		            PHP
.1a1071	0b		phd		            PHD
.1a1072	08		php		            PHP
.1a1073	c2 20		rep #$20	            REP #$20
.1a1075	48		pha		            PHA
.1a1076	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1079	5b		tcd		            TCD
.1a107a	68		pla		            PLA
.1a107b	28		plp		            PLP
.1a107c	c2 30		rep #$30	            REP #$30
.1a107e	a9 ff ff	lda #$ffff	            LDA #<>HEAP_TOP         ; Set the HEAP to the top
.1a1081	85 ba		sta $08ba	            STA HEAP
.1a1083	e2 20		sep #$20	            SEP #$20
.1a1085	a9 17		lda #$17	            LDA #`HEAP_TOP
.1a1087	85 bc		sta $08bc	            STA HEAP+2
.1a1089	c2 20		rep #$20	            REP #$20
.1a108b	64 b7		stz $08b7	            STZ ALLOCATED           ; And clear the pointer to the allocated objects
.1a108d	64 bd		stz $08bd	            STZ FREED               ; as well as the list of freed objects
.1a108f	e2 20		sep #$20	            SEP #$20
.1a1091	64 b9		stz $08b9	            STZ ALLOCATED+2
.1a1093	64 bf		stz $08bf	            STZ FREED+2
.1a1095	2b		pld		            PLD
.1a1096	28		plp		            PLP
.1a1097	60		rts		            RTS
.1a1098					ALLOC
.1a1098	5a		phy		            PHY
.1a1099	08		php		            PHP
.1a109a	e2 20		sep #$20	            SEP #$20
.1a109c	85 ea		sta $08ea	            STA TOFINDTYPE      ; Save the type of the block to TOFINDTYPE
.1a109e	c2 10		rep #$10	            REP #$10
.1a10a0	86 8f		stx $088f	            STX MCOUNT           ; And the length of the block needed to MCOUNT
.1a10a2	c2 20		rep #$20	            REP #$20
.1a10a4	a5 0e		lda $080e	            LDA SCRATCH+2
.1a10a6	48		pha		            PHA
.1a10a7	a5 0c		lda $080c	            LDA SCRATCH
.1a10a9	48		pha		            PHA
.1a10aa	a5 12		lda $0812	            LDA SCRATCH2+2
.1a10ac	48		pha		            PHA
.1a10ad	a5 10		lda $0810	            LDA SCRATCH2
.1a10af	48		pha		            PHA
.1a10b0	20 48 11	jsr $1a1148	            JSR ALLOCFREED
.1a10b3	b0 03		bcs $1a10b8	            BCS done            ; Return, if we got something back
.1a10b5	20 cc 10	jsr $1a10cc	            JSR ALLOCHEAP
.1a10b8					done
.1a10b8	20 d4 12	jsr $1a12d4	            JSR HEAP_GETHED
.1a10bb	c2 20		rep #$20	            REP #$20
.1a10bd	68		pla		            PLA
.1a10be	85 10		sta $0810	            STA SCRATCH2
.1a10c0	68		pla		            PLA
.1a10c1	85 12		sta $0812	            STA SCRATCH2+2
.1a10c3	68		pla		            PLA
.1a10c4	85 0c		sta $080c	            STA SCRATCH
.1a10c6	68		pla		            PLA
.1a10c7	85 0e		sta $080e	            STA SCRATCH+2
.1a10c9	28		plp		            PLP
.1a10ca	7a		ply		            PLY
.1a10cb	60		rts		            RTS
.1a10cc					ALLOCHEAP
.1a10cc	08		php		            PHP
.1a10cd	0b		phd		            PHD
.1a10ce	08		php		            PHP
.1a10cf	c2 20		rep #$20	            REP #$20
.1a10d1	48		pha		            PHA
.1a10d2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a10d5	5b		tcd		            TCD
.1a10d6	68		pla		            PLA
.1a10d7	28		plp		            PLP
.1a10d8	e2 20		sep #$20	            SEP #$20
.1a10da	a6 8f		ldx $088f	            LDX MCOUNT
.1a10dc	ca		dex		            DEX
.1a10dd	86 0c		stx $080c	            STX SCRATCH             ; SCRATCH := size - 1
.1a10df	e8		inx		            INX
.1a10e0	c2 30		rep #$30	            REP #$30
.1a10e2	38		sec		            SEC
.1a10e3	a5 ba		lda $08ba	            LDA HEAP
.1a10e5	e5 0c		sbc $080c	            SBC SCRATCH
.1a10e7	85 c0		sta $08c0	            STA CURRBLOCK
.1a10e9	e2 20		sep #$20	            SEP #$20
.1a10eb	a5 bc		lda $08bc	            LDA HEAP+2
.1a10ed	e9 00		sbc #$00	            SBC #0
.1a10ef	85 c2		sta $08c2	            STA CURRBLOCK+2
.1a10f1	20 d4 12	jsr $1a12d4	            JSR HEAP_GETHED
.1a10f4	e2 20		sep #$20	            SEP #$20
.1a10f6	a5 ea		lda $08ea	            LDA TOFINDTYPE
.1a10f8	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE       ; Set the type of the object
.1a10fb	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a10fd	a9 00		lda #$00	            LDA #0                  ; Set the count to zero
.1a10ff	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.1a1102	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1104	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1107	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1109	c2 20		rep #$20	            REP #$20
.1a110b	a9 00 00	lda #$0000	            LDA #0
.1a110e	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1110	c2 20		rep #$20	            REP #$20
.1a1112	18		clc		            CLC
.1a1113	a5 ba		lda $08ba	            LDA HEAP
.1a1115	69 01 00	adc #$0001	            ADC #1
.1a1118	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; To get the address of the next byte
.1a111b	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y      ; after the block
.1a111d	e2 20		sep #$20	            SEP #$20
.1a111f	c8		iny		            INY
.1a1120	c8		iny		            INY
.1a1121	a5 bc		lda $08bc	            LDA HEAP+2
.1a1123	69 00		adc #$00	            ADC #0
.1a1125	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1127	c2 20		rep #$20	            REP #$20
.1a1129	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a112b	85 b7		sta $08b7	            STA ALLOCATED
.1a112d	e2 20		sep #$20	            SEP #$20
.1a112f	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a1131	85 b9		sta $08b9	            STA ALLOCATED+2
.1a1133	c2 20		rep #$20	            REP #$20
.1a1135	38		sec		            SEC                     ; Move the HEAP pointer to the first free byte under the header
.1a1136	a5 c3		lda $08c3	            LDA CURRHEADER
.1a1138	e9 01 00	sbc #$0001	            SBC #1
.1a113b	85 ba		sta $08ba	            STA HEAP
.1a113d	e2 20		sep #$20	            SEP #$20
.1a113f	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1141	e9 00		sbc #$00	            SBC #0
.1a1143	85 bc		sta $08bc	            STA HEAP+2
.1a1145	2b		pld		            PLD
.1a1146	28		plp		            PLP
.1a1147	60		rts		            RTS
.1a1148					ALLOCFREED
.1a1148	08		php		            PHP
.1a1149	0b		phd		            PHD
.1a114a	08		php		            PHP
.1a114b	c2 20		rep #$20	            REP #$20
.1a114d	48		pha		            PHA
.1a114e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1151	5b		tcd		            TCD
.1a1152	68		pla		            PLA
.1a1153	28		plp		            PLP
.1a1154	c2 30		rep #$30	            REP #$30
.1a1156	c2 20		rep #$20	            REP #$20
.1a1158	a5 bd		lda $08bd	            LDA FREED
.1a115a	85 c9		sta $08c9	            STA CURRFREED
.1a115c	e2 20		sep #$20	            SEP #$20
.1a115e	a5 bf		lda $08bf	            LDA FREED+2
.1a1160	85 cb		sta $08cb	            STA CURRFREED+2
.1a1162	a5 c9		lda $08c9	loop        LDA CURRFREED           ; Has anything been freed?
.1a1164	d0 17		bne $1a117d	            BNE has_block           ; Yes: check to see if there's a big enough block
.1a1166	e2 20		sep #$20	            SEP #$20
.1a1168	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a116a	d0 11		bne $1a117d	            BNE has_block           ; Yes: check to see if there's a big enough block
.1a116c	c2 20		rep #$20	            REP #$20
.1a116e	a9 00 00	lda #$0000	            LDA #<>0
.1a1171	85 cf		sta $08cf	            STA LASTFREED
.1a1173	e2 20		sep #$20	            SEP #$20
.1a1175	a9 00		lda #$00	            LDA #`0
.1a1177	85 d1		sta $08d1	            STA LASTFREED+2
.1a1179	2b		pld		ret_false   PLD                     ; Return that we didn't find anything
.1a117a	28		plp		            PLP
.1a117b	18		clc		            CLC
.1a117c	60		rts		            RTS
.1a117d					has_block
.1a117d	c2 20		rep #$20	            REP #$20
.1a117f	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.1a1182	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1184	85 cc		sta $08cc	            STA FREEDEND
.1a1186	e2 20		sep #$20	            SEP #$20
.1a1188	c8		iny		            INY
.1a1189	c8		iny		            INY
.1a118a	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a118c	85 ce		sta $08ce	            STA FREEDEND+2
.1a118e	c2 20		rep #$20	            REP #$20
.1a1190	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required
.1a1191	a5 c9		lda $08c9	            LDA CURRFREED
.1a1193	65 8f		adc $088f	            ADC MCOUNT
.1a1195	85 0c		sta $080c	            STA SCRATCH
.1a1197	e2 20		sep #$20	            SEP #$20
.1a1199	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a119b	69 00		adc #$00	            ADC #0
.1a119d	85 0e		sta $080e	            STA SCRATCH+2
.1a119f	c2 20		rep #$20	            REP #$20
.1a11a1	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required + size of header
.1a11a2	a5 0c		lda $080c	            LDA SCRATCH                 ; (that is, it's a pointer to the byte immediately after the block desired)
.1a11a4	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)
.1a11a7	85 0c		sta $080c	            STA SCRATCH
.1a11a9	e2 20		sep #$20	            SEP #$20
.1a11ab	a5 0e		lda $080e	            LDA SCRATCH+2
.1a11ad	69 00		adc #$00	            ADC #0
.1a11af	85 0e		sta $080e	            STA SCRATCH+2
.1a11b1	c2 20		rep #$20	            REP #$20
.1a11b3	a5 0c		lda $080c	            LDA SCRATCH                 ; Is SCRATCH == FREEDEND?
.1a11b5	c5 cc		cmp $08cc	            CMP FREEDEND
.1a11b7	d0 28		bne $1a11e1	            BNE not_exact               ; No: check if this block is bigger than needed
.1a11b9	e2 20		sep #$20	            SEP #$20
.1a11bb	a5 0e		lda $080e	            LDA SCRATCH+2
.1a11bd	c5 ce		cmp $08ce	            CMP FREEDEND+2
.1a11bf	d0 20		bne $1a11e1	            BNE not_exact
.1a11c1	c2 20		rep #$20	            REP #$20
.1a11c3	a5 cf		lda $08cf	            LDA LASTFREED               ; LASTFREED == 0?
.1a11c5	d0 5d		bne $1a1224	            BNE adj_last1               ; No: point LASTFREED->NEXT to skip this block
.1a11c7	e2 20		sep #$20	            SEP #$20
.1a11c9	a5 d1		lda $08d1	            LDA LASTFREED+2
.1a11cb	d0 57		bne $1a1224	            BNE adj_last1
.1a11cd	c2 20		rep #$20	            REP #$20
.1a11cf	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a11d2	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a11d4	85 bd		sta $08bd	            STA FREED
.1a11d6	e2 20		sep #$20	            SEP #$20
.1a11d8	c8		iny		            INY
.1a11d9	c8		iny		            INY
.1a11da	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a11dc	85 bf		sta $08bf	            STA FREED+2
.1a11de	4c 85 12	jmp $1a1285	            JMP init_block              ; And return CURRFREED as our reallocated memory
.1a11e1					not_exact
.1a11e1	c2 20		rep #$20	            REP #$20
.1a11e3	a5 0c		lda $080c	            LDA SCRATCH                 ; Add a buffer to the room needed
.1a11e5	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)          ; So we have room to track the memory still freed
.1a11e8	85 10		sta $0810	            STA SCRATCH2
.1a11ea	e2 20		sep #$20	            SEP #$20
.1a11ec	a5 0e		lda $080e	            LDA SCRATCH+2
.1a11ee	69 00		adc #$00	            ADC #0
.1a11f0	85 12		sta $0812	            STA SCRATCH2+2
.1a11f2	e2 20		sep #$20	            SEP #$20
.1a11f4	a5 c6		lda $08c6	            LDA CURREND                 ; Is CURREND > SCRATCH2
.1a11f6	c5 10		cmp $0810	            CMP SCRATCH2
.1a11f8	b0 3e		bcs $1a1238	            BGE has_room                ; Yes: there is room in this block to allocate some memory
.1a11fa	90 08		bcc $1a1204	            BLT try_next
.1a11fc	c2 20		rep #$20	            REP #$20
.1a11fe	a5 c6		lda $08c6	            LDA CURREND
.1a1200	c5 10		cmp $0810	            CMP SCRATCH2
.1a1202	b0 34		bcs $1a1238	            BGE has_room
.1a1204					try_next
.1a1204	c2 20		rep #$20	            REP #$20
.1a1206	a5 c9		lda $08c9	            LDA CURRFREED
.1a1208	85 cf		sta $08cf	            STA LASTFREED
.1a120a	e2 20		sep #$20	            SEP #$20
.1a120c	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a120e	85 d1		sta $08d1	            STA LASTFREED+2
.1a1210	c2 20		rep #$20	            REP #$20
.1a1212	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1215	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.1a1217	85 c9		sta $08c9	            STA CURRFREED
.1a1219	e2 20		sep #$20	            SEP #$20
.1a121b	c8		iny		            INY
.1a121c	c8		iny		            INY
.1a121d	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.1a121f	85 cb		sta $08cb	            STA CURRFREED+2
.1a1221	4c 62 11	jmp $1a1162	            JMP loop                                    ; And try the next header
.1a1224					adj_last1
.1a1224	c2 20		rep #$20	            REP #$20
.1a1226	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := CURRFREED->NEXT
.1a1229	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a122b	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.1a122d	e2 20		sep #$20	            SEP #$20
.1a122f	c8		iny		            INY
.1a1230	c8		iny		            INY
.1a1231	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1233	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.1a1235	4c 85 12	jmp $1a1285	            JMP init_block              ; And get CURRFREED ready to return
.1a1238					has_room
.1a1238	c2 20		rep #$20	            REP #$20
.1a123a	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END            ; SCRATCH->END := CURRFREED->END
.1a123d	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a123f	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a1241	e2 20		sep #$20	            SEP #$20
.1a1243	c8		iny		            INY
.1a1244	c8		iny		            INY
.1a1245	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1247	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a1249	c2 20		rep #$20	            REP #$20
.1a124b	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; CURREND->NEXT := CURRFREED->NEXT
.1a124e	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1250	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a1252	e2 20		sep #$20	            SEP #$20
.1a1254	c8		iny		            INY
.1a1255	c8		iny		            INY
.1a1256	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1258	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a125a	c2 20		rep #$20	            REP #$20
.1a125c	a5 cf		lda $08cf	            LDA LASTFREED               ; Is this the first object we've examined?
.1a125e	d0 14		bne $1a1274	            BNE adj_last2               ; No: we'll need to adjust the previously examined block
.1a1260	e2 20		sep #$20	            SEP #$20
.1a1262	a5 cf		lda $08cf	            LDA LASTFREED
.1a1264	d0 0e		bne $1a1274	            BNE adj_last2
.1a1266	c2 20		rep #$20	            REP #$20
.1a1268	a5 0c		lda $080c	            LDA SCRATCH
.1a126a	85 bd		sta $08bd	            STA FREED
.1a126c	e2 20		sep #$20	            SEP #$20
.1a126e	a5 0e		lda $080e	            LDA SCRATCH+2
.1a1270	85 bf		sta $08bf	            STA FREED+2
.1a1272	80 11		bra $1a1285	            BRA init_block              ; ... and return the block we've sliced off
.1a1274					adj_last2
.1a1274	c2 20		rep #$20	            REP #$20
.1a1276	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := SCRATCH
.1a1279	a5 0c		lda $080c	            LDA SCRATCH                 ; (point the previous freed block to the newly sliced
.1a127b	97 cf		sta [$08cf],y	            STA [LASTFREED],Y           ;  off part of the current block)
.1a127d	e2 20		sep #$20	            SEP #$20
.1a127f	c8		iny		            INY
.1a1280	c8		iny		            INY
.1a1281	a5 0e		lda $080e	            LDA SCRATCH+2
.1a1283	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.1a1285					init_block
.1a1285	c2 20		rep #$20	            REP #$20
.1a1287	a5 c9		lda $08c9	            LDA CURRFREED
.1a1289	85 c3		sta $08c3	            STA CURRHEADER
.1a128b	e2 20		sep #$20	            SEP #$20
.1a128d	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a128f	85 c5		sta $08c5	            STA CURRHEADER+2
.1a1291	c2 20		rep #$20	            REP #$20
.1a1293	a5 c3		lda $08c3	            LDA CURRHEADER
.1a1295	85 b7		sta $08b7	            STA ALLOCATED
.1a1297	e2 20		sep #$20	            SEP #$20
.1a1299	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a129b	85 b9		sta $08b9	            STA ALLOCATED+2
.1a129d	c2 20		rep #$20	            REP #$20
.1a129f	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; Set CURRHEADER->END to the byte after the block
.1a12a2	a5 0c		lda $080c	            LDA SCRATCH
.1a12a4	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12a6	e2 20		sep #$20	            SEP #$20
.1a12a8	c8		iny		            INY
.1a12a9	c8		iny		            INY
.1a12aa	a5 0e		lda $080e	            LDA SCRATCH+2
.1a12ac	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12ae	c2 20		rep #$20	            REP #$20
.1a12b0	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Set CURRHEADER->NEXT to NULL
.1a12b3	a9 00 00	lda #$0000	            LDA #0
.1a12b6	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12b8	e2 20		sep #$20	            SEP #$20
.1a12ba	c8		iny		            INY
.1a12bb	c8		iny		            INY
.1a12bc	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12be	e2 20		sep #$20	            SEP #$20
.1a12c0	a5 ea		lda $08ea	            LDA TOFINDTYPE          ; Get the type code back
.1a12c2	e2 20		sep #$20	            SEP #$20
.1a12c4	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE
.1a12c7	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12c9	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT      ; Set its reference count to 0
.1a12cc	a9 00		lda #$00	            LDA #0
.1a12ce	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12d0	2b		pld		done        PLD
.1a12d1	28		plp		            PLP
.1a12d2	38		sec		            SEC
.1a12d3	60		rts		            RTS
.1a12d4					HEAP_GETHED
.1a12d4	08		php		            PHP
.1a12d5	c2 20		rep #$20	            REP #$20
.1a12d7	38		sec		            SEC
.1a12d8	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a12da	e9 08 00	sbc #$0008	            SBC #size(HEAPOBJ)
.1a12dd	85 c3		sta $08c3	            STA CURRHEADER
.1a12df	e2 20		sep #$20	            SEP #$20
.1a12e1	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a12e3	e9 00		sbc #$00	            SBC #0
.1a12e5	85 c5		sta $08c5	            STA CURRHEADER+2
.1a12e7	28		plp		            PLP
.1a12e8	60		rts		            RTS
.1a12e9					HEAP_ADDREF
.1a12e9	08		php		            PHP
.1a12ea	e2 20		sep #$20	            SEP #$20
.1a12ec	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a12ee	f0 04		beq $1a12f4	            BEQ chk_null
.1a12f0	c9 18		cmp #$18	            CMP #`(HEAP_TOP + 1)
.1a12f2	b0 12		bcs $1a1306	            BGE out_of_bnds
.1a12f4					chk_null
.1a12f4	c2 20		rep #$20	            REP #$20
.1a12f6	a5 c3		lda $08c3	            LDA CURRHEADER
.1a12f8	f0 0c		beq $1a1306	            BEQ out_of_bnds
.1a12fa					is_ok
.1a12fa	e2 20		sep #$20	            SEP #$20
.1a12fc	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.1a12ff	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1301	1a		inc a		            INC A
.1a1302	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1304	28		plp		            PLP
.1a1305	60		rts		            RTS
.1a1306	00		brk #		out_of_bnds BRK
.1a1307	ea		nop		            NOP
.1a1308					HEAP_REMREF
.1a1308	08		php		            PHP
.1a1309	e2 20		sep #$20	            SEP #$20
.1a130b	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a130d	f0 04		beq $1a1313	            BEQ chk_null
.1a130f	c9 18		cmp #$18	            CMP #`(HEAP_TOP + 1)
.1a1311	b0 17		bcs $1a132a	            BGE out_of_bnds
.1a1313					chk_null
.1a1313	c2 20		rep #$20	            REP #$20
.1a1315	a5 c3		lda $08c3	            LDA CURRHEADER
.1a1317	f0 11		beq $1a132a	            BEQ out_of_bnds
.1a1319	e2 20		sep #$20	            SEP #$20
.1a131b	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT  ; Decrement the reference count
.1a131e	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1320	3a		dec a		            DEC A
.1a1321	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1323	d0 03		bne $1a1328	            BNE done            ; If it's still >0, we are done
.1a1325	20 2c 13	jsr $1a132c	            JSR HEAP_FREE
.1a1328	28		plp		done        PLP
.1a1329	60		rts		            RTS
.1a132a	00		brk #		out_of_bnds BRK
.1a132b	ea		nop		            NOP
.1a132c					HEAP_FREE
.1a132c	08		php		            PHP
.1a132d	c2 20		rep #$20	            REP #$20
.1a132f	a5 bd		lda $08bd	            LDA FREED           ; Check to see if blocks are already on the freed list
.1a1331	d0 21		bne $1a1354	            BNE has_objects
.1a1333	e2 20		sep #$20	            SEP #$20
.1a1335	a5 bf		lda $08bf	            LDA FREED+2
.1a1337	d0 1b		bne $1a1354	            BNE has_objects
.1a1339	a5 c5		lda $08c5	            LDA CURRHEADER+2    ; No: this block is the first one
.1a133b	85 bf		sta $08bf	            STA FREED+2         ; Just make it the freed list
.1a133d	c2 20		rep #$20	            REP #$20
.1a133f	a5 c3		lda $08c3	            LDA CURRHEADER
.1a1341	85 bd		sta $08bd	            STA FREED
.1a1343	a9 00 00	lda #$0000	            LDA #0
.1a1346	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT   ; And clear its next link
.1a1349	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a134b	c8		iny		            INY
.1a134c	c8		iny		            INY
.1a134d	e2 20		sep #$20	            SEP #$20
.1a134f	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1351	4c 13 14	jmp $1a1413	            JMP done
.1a1354					has_objects
.1a1354	e2 20		sep #$20	            SEP #$20
.1a1356	a5 bf		lda $08bf	            LDA FREED+2
.1a1358	c5 c5		cmp $08c5	            CMP CURRHEADER+2
.1a135a	90 28		bcc $1a1384	            BLT start_scan
.1a135c	c2 20		rep #$20	            REP #$20
.1a135e	a5 bd		lda $08bd	            LDA FREED
.1a1360	c5 c3		cmp $08c3	            CMP CURRHEADER
.1a1362	90 20		bcc $1a1384	            BLT start_scan
.1a1364					ins_first
.1a1364	c2 20		rep #$20	            REP #$20
.1a1366	a5 bd		lda $08bd	            LDA FREED               ; CURRHEADER->NEXT := FREED
.1a1368	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a136b	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a136d	e2 20		sep #$20	            SEP #$20
.1a136f	c8		iny		            INY
.1a1370	c8		iny		            INY
.1a1371	a5 bf		lda $08bf	            LDA FREED+2
.1a1373	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1375	c2 20		rep #$20	            REP #$20
.1a1377	a5 c3		lda $08c3	            LDA CURRHEADER
.1a1379	85 bd		sta $08bd	            STA FREED
.1a137b	e2 20		sep #$20	            SEP #$20
.1a137d	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a137f	85 bf		sta $08bf	            STA FREED+2
.1a1381	4c 13 14	jmp $1a1413	            JMP done
.1a1384					start_scan
.1a1384	c2 20		rep #$20	            REP #$20
.1a1386	a5 bd		lda $08bd	            LDA FREED
.1a1388	85 08		sta $0808	            STA INDEX
.1a138a	e2 20		sep #$20	            SEP #$20
.1a138c	a5 bf		lda $08bf	            LDA FREED+2
.1a138e	85 0a		sta $080a	            STA INDEX+2
.1a1390					loop
.1a1390	e2 20		sep #$20	            SEP #$20
.1a1392	a0 04 00	ldy #$0004	            LDY #HEAPOBJ.NEXT+2
.1a1395	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a1397	c5 c8		cmp $08c8	            CMP CURREND+2
.1a1399	90 32		bcc $1a13cd	            BLT go_next             ; No: check the next spot
.1a139b	d0 0b		bne $1a13a8	            BNE ins_next
.1a139d	c2 20		rep #$20	            REP #$20
.1a139f	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a13a2	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a13a4	c5 c6		cmp $08c6	            CMP CURREND
.1a13a6	90 25		bcc $1a13cd	            BLT go_next             ; No: check the next spot
.1a13a8					ins_next
.1a13a8	c2 20		rep #$20	            REP #$20
.1a13aa	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := INDEX->NEXT
.1a13ad	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a13af	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a13b1	e2 20		sep #$20	            SEP #$20
.1a13b3	c8		iny		            INY
.1a13b4	c8		iny		            INY
.1a13b5	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a13b7	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a13b9	c2 20		rep #$20	            REP #$20
.1a13bb	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.1a13bd	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a13c0	97 08		sta [$0808],y	            STA [INDEX],Y
.1a13c2	e2 20		sep #$20	            SEP #$20
.1a13c4	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a13c6	c8		iny		            INY
.1a13c7	c8		iny		            INY
.1a13c8	97 08		sta [$0808],y	            STA [INDEX],Y
.1a13ca	4c 13 14	jmp $1a1413	            JMP done
.1a13cd					go_next
.1a13cd	c2 20		rep #$20	            REP #$20
.1a13cf	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Is INDEX->NEXT = 0
.1a13d2	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a13d4	d0 08		bne $1a13de	            BNE not_at_end          ; No: load up the next object
.1a13d6	e2 20		sep #$20	            SEP #$20
.1a13d8	c8		iny		            INY
.1a13d9	c8		iny		            INY
.1a13da	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a13dc	f0 19		beq $1a13f7	            BEQ at_end
.1a13de					not_at_end
.1a13de	c2 20		rep #$20	            REP #$20
.1a13e0	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; INDEX := INDEX->NEXT
.1a13e3	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a13e5	85 0c		sta $080c	            STA SCRATCH
.1a13e7	e2 20		sep #$20	            SEP #$20
.1a13e9	c8		iny		            INY
.1a13ea	c8		iny		            INY
.1a13eb	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a13ed	85 0a		sta $080a	            STA INDEX+2
.1a13ef	c2 20		rep #$20	            REP #$20
.1a13f1	a5 0c		lda $080c	            LDA SCRATCH
.1a13f3	85 08		sta $0808	            STA INDEX
.1a13f5	80 99		bra $1a1390	            BRA loop
.1a13f7					at_end
.1a13f7	c2 20		rep #$20	            REP #$20
.1a13f9	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.1a13fb	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a13fe	97 08		sta [$0808],y	            STA [INDEX],Y
.1a1400	e2 20		sep #$20	            SEP #$20
.1a1402	c8		iny		            INY
.1a1403	c8		iny		            INY
.1a1404	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1406	97 08		sta [$0808],y	            STA [INDEX],Y
.1a1408	a9 00		lda #$00	            LDA #0                  ; CURRHEADER->NEXT := 0
.1a140a	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a140c	c2 20		rep #$20	            REP #$20
.1a140e	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1411	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1413					done
.1a1413	20 18 14	jsr $1a1418	            JSR COALLESCE
.1a1416	28		plp		            PLP
.1a1417	60		rts		            RTS
.1a1418					COALLESCE
.1a1418	08		php		            PHP
.1a1419	c2 20		rep #$20	            REP #$20
.1a141b	a5 bd		lda $08bd	            LDA FREED
.1a141d	85 c3		sta $08c3	            STA CURRHEADER
.1a141f	e2 20		sep #$20	            SEP #$20
.1a1421	a5 bf		lda $08bf	            LDA FREED+2
.1a1423	85 c5		sta $08c5	            STA CURRHEADER+2
.1a1425					next_head
.1a1425	c2 20		rep #$20	            REP #$20
.1a1427	a5 c3		lda $08c3	            LDA CURRHEADER          ; Is CURRHEADER == 0?
.1a1429	d0 09		bne $1a1434	            BNE check_next          ; No: check if NEXT is contiguous
.1a142b	e2 20		sep #$20	            SEP #$20
.1a142d	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a142f	d0 03		bne $1a1434	            BNE check_next
.1a1431	4c bb 14	jmp $1a14bb	            JMP done                ; Yes: we're done
.1a1434					check_next
.1a1434	c2 20		rep #$20	            REP #$20
.1a1436	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1439	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a143b	85 0c		sta $080c	            STA SCRATCH
.1a143d	e2 20		sep #$20	            SEP #$20
.1a143f	c8		iny		            INY
.1a1440	c8		iny		            INY
.1a1441	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1443	85 0e		sta $080e	            STA SCRATCH+2
.1a1445	c2 20		rep #$20	            REP #$20
.1a1447	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.1a144a	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a144c	85 10		sta $0810	            STA SCRATCH2
.1a144e	e2 20		sep #$20	            SEP #$20
.1a1450	c8		iny		            INY
.1a1451	c8		iny		            INY
.1a1452	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1454	85 12		sta $0812	            STA SCRATCH2+2
.1a1456	c2 20		rep #$20	            REP #$20
.1a1458	a5 0c		lda $080c	            LDA SCRATCH
.1a145a	c5 10		cmp $0810	            CMP SCRATCH2            ; Is CURRHEADER->END = CURRHEADER->NEXT?
.1a145c	d0 08		bne $1a1466	            BNE go_next             ; No: go to the next block
.1a145e	e2 20		sep #$20	            SEP #$20
.1a1460	a5 0e		lda $080e	            LDA SCRATCH+2
.1a1462	c5 12		cmp $0812	            CMP SCRATCH2+2
.1a1464	f0 1f		beq $1a1485	            BEQ combine             ; Yes: combine the two blocks
.1a1466					go_next
.1a1466	c2 20		rep #$20	            REP #$20
.1a1468	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a146b	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a146d	85 0c		sta $080c	            STA SCRATCH
.1a146f	e2 20		sep #$20	            SEP #$20
.1a1471	c8		iny		            INY
.1a1472	c8		iny		            INY
.1a1473	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1475	85 0e		sta $080e	            STA SCRATCH+2
.1a1477	c2 20		rep #$20	            REP #$20
.1a1479	a5 0c		lda $080c	            LDA SCRATCH
.1a147b	85 c3		sta $08c3	            STA CURRHEADER
.1a147d	e2 20		sep #$20	            SEP #$20
.1a147f	a5 0e		lda $080e	            LDA SCRATCH+2
.1a1481	85 c5		sta $08c5	            STA CURRHEADER+2
.1a1483	80 a0		bra $1a1425	            BRA next_head                               ; And loop back to next_head
.1a1485					combine
.1a1485	c2 20		rep #$20	            REP #$20
.1a1487	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a148a	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a148c	85 0c		sta $080c	            STA SCRATCH
.1a148e	e2 20		sep #$20	            SEP #$20
.1a1490	c8		iny		            INY
.1a1491	c8		iny		            INY
.1a1492	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1494	85 0e		sta $080e	            STA SCRATCH+2
.1a1496	c2 20		rep #$20	            REP #$20
.1a1498	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := SCRATCH->NEXT
.1a149b	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a149d	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a149f	e2 20		sep #$20	            SEP #$20
.1a14a1	c8		iny		            INY
.1a14a2	c8		iny		            INY
.1a14a3	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a14a5	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a14a7	c2 20		rep #$20	            REP #$20
.1a14a9	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END       ; CURRHEADER->END := SCRATCH->END
.1a14ac	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a14ae	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a14b0	e2 20		sep #$20	            SEP #$20
.1a14b2	c8		iny		            INY
.1a14b3	c8		iny		            INY
.1a14b4	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a14b6	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a14b8	4c 34 14	jmp $1a1434	            JMP check_next          ; And loop back to check_next
.1a14bb	28		plp		done        PLP
.1a14bc	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\strings.s

.1a14bd					CLRTMPSTR
.1a14bd	08		php		            PHP
.1a14be	c2 20		rep #$20	            REP #$20
.1a14c0	64 16		stz $0816	            STZ STRPTR
.1a14c2	64 18		stz $0818	            STZ STRPTR+2
.1a14c4	28		plp		            PLP
.1a14c5	60		rts		            RTS
.1a14c6					TEMPSTRING
.1a14c6	08		php		            PHP
.1a14c7	c2 30		rep #$30	            REP #$30
.1a14c9	a5 16		lda $0816	            LDA STRPTR          ; Is STRPTR == 0?
.1a14cb	d0 16		bne $1a14e3	            BNE add_256         ; No: add 256 to it
.1a14cd	a5 18		lda $0818	            LDA STRPTR+2
.1a14cf	d0 12		bne $1a14e3	            BNE add_256
.1a14d1	e2 20		sep #$20	            SEP #$20
.1a14d3	64 16		stz $0816	            STZ STRPTR
.1a14d5	a5 e2		lda $08e2	            LDA NEXTVAR+1
.1a14d7	1a		inc a		            INC A
.1a14d8	1a		inc a		            INC A
.1a14d9	85 17		sta $0817	            STA STRPTR+1
.1a14db	a5 e3		lda $08e3	            LDA NEXTVAR+2
.1a14dd	85 18		sta $0818	            STA STRPTR+2
.1a14df	64 19		stz $0819	            STZ STRPTR+3
.1a14e1	80 07		bra $1a14ea	            BRA chk_room
.1a14e3					add_256
.1a14e3	c2 20		rep #$20	            REP #$20
.1a14e5	a5 17		lda $0817	            LDA STRPTR+1        ; There was already a temporary string...
.1a14e7	1a		inc a		            INC A               ; Leave 256 bytes for it
.1a14e8	85 17		sta $0817	            STA STRPTR+1
.1a14ea					chk_room
.1a14ea	c2 20		rep #$20	            REP #$20
.1a14ec	a5 bb		lda $08bb	            LDA HEAP+1          ; Check to make sure that STRPTR and HEAP haven't touched
.1a14ee	3a		dec a		            DEC A
.1a14ef	c5 17		cmp $0817	            CMP STRPTR+1
.1a14f1	f0 02		beq $1a14f5	            BEQ no_room         ; If they have, throw an error
.1a14f3	b0 1f		bcs $1a1514	            BGE done
.1a14f5					no_room
.1a14f5	08		php		            PHP
.1a14f6	c2 20		rep #$20	            REP #$20
.1a14f8	48		pha		            PHA
.1a14f9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a14fc	5b		tcd		            TCD
.1a14fd	68		pla		            PLA
.1a14fe	28		plp		            PLP
.1a14ff	e2 20		sep #$20	            SEP #$20
.1a1501	a9 03		lda #$03	            LDA #ERR_MEMORY
.1a1503	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1507	c2 20		rep #$20	            REP #$20
.1a1509	29 ff 00	and #$00ff	            AND #$00FF
.1a150c	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a150f	e2 20		sep #$20	            SEP #$20
.1a1511	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1514	28		plp		done        PLP
.1a1515	60		rts		            RTS
.1a1516					ITOS_DIGIT
.1a1516	c9 00		cmp #$00	            CMP #0          ; Is it 0?
.1a1518	d0 05		bne $1a151f	            BNE add_digit   ; No: go ahead and add it
.1a151a	c0 01 00	cpy #$0001	            CPY #1          ; Are we on the first digit?
.1a151d	f0 05		beq $1a1524	            BEQ done        ; Yes: ignore this leading 0
.1a151f	09 30		ora #$30	add_digit   ORA #$30        ; Convert it to ASCII
.1a1521	97 16		sta [$0816],y	            STA [STRPTR],Y  ; Save it to the string
.1a1523	c8		iny		            INY             ; And point to the next location
.1a1524					done
.1a1524	60		rts		            RTS
.1a1525					ITOS
.1a1525	08		php		            PHP
.1a1526	c2 30		rep #$30	            REP #$30
.1a1528	64 0c		stz $080c	            STZ SCRATCH         ; Use scratch to store if negative
.1a152a	a5 25		lda $0825	            LDA ARGUMENT1+2     ; Check to see if the number is negative
.1a152c	10 1a		bpl $1a1548	            BPL start_cnvt
.1a152e	18		clc		            CLC                 ; Yes: make ARGUMENT1 positive
.1a152f	a5 23		lda $0823	            LDA ARGUMENT1
.1a1531	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a1534	69 01 00	adc #$0001	            ADC #1
.1a1537	85 23		sta $0823	            STA ARGUMENT1
.1a1539	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a153b	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a153e	69 00 00	adc #$0000	            ADC #0
.1a1541	85 25		sta $0825	            STA ARGUMENT1+2
.1a1543	a9 ff ff	lda #$ffff	            LDA #$FFFF          ; Record that the number was negative
.1a1546	85 0c		sta $080c	            STA SCRATCH
.1a1548					start_cnvt
.1a1548	64 10		stz $0810	            STZ SCRATCH2        ; SCRATCH2 will be our BCD version of the number
.1a154a	64 12		stz $0812	            STZ SCRATCH2+2
.1a154c	64 14		stz $0814	            STZ SCRATCH2+4
.1a154e	a2 1f 00	ldx #$001f	            LDX #31
.1a1551	f8		sed		            SED                 ; Yes, we're really using BCD mode
.1a1552	06 23		asl $0823	shift_loop  ASL ARGUMENT1       ; Shift ARGUMENT1 left one bit
.1a1554	26 25		rol $0825	            ROL ARGUMENT1+2
.1a1556	a5 10		lda $0810	            LDA SCRATCH2        ; SCRATCH2 := SCRATCH2 + SCRATCH2 + Carry
.1a1558	65 10		adc $0810	            ADC SCRATCH2
.1a155a	85 10		sta $0810	            STA SCRATCH2
.1a155c	a5 12		lda $0812	            LDA SCRATCH2+2
.1a155e	65 12		adc $0812	            ADC SCRATCH2+2
.1a1560	85 12		sta $0812	            STA SCRATCH2+2
.1a1562	a5 14		lda $0814	            LDA SCRATCH2+4
.1a1564	65 14		adc $0814	            ADC SCRATCH2+4
.1a1566	85 14		sta $0814	            STA SCRATCH2+4
.1a1568	ca		dex		            DEX
.1a1569	10 e7		bpl $1a1552	            BPL shift_loop      ; Loop through all 32 bits of ARGUMENT1
.1a156b	d8		cld		            CLD                 ; Switch back out of BCD mode
.1a156c	e2 20		sep #$20	            SEP #$20
.1a156e	20 c6 14	jsr $1a14c6	            JSR TEMPSTRING
.1a1571	a0 00 00	ldy #$0000	            LDY #0              ; Y will be index into the temporary string
.1a1574	a5 0c		lda $080c	            LDA SCRATCH         ; Check to see if the number was negative
.1a1576	f0 04		beq $1a157c	            BEQ is_pos          ; No: write a leading space
.1a1578	a9 2d		lda #$2d	            LDA #'-'            ; If negative, write the minus sign
.1a157a	80 02		bra $1a157e	            BRA wr_lead
.1a157c	a9 20		lda #$20	is_pos      LDA #CHAR_SP        ; Write a leading space
.1a157e	97 16		sta [$0816],y	wr_lead     STA [STRPTR],Y
.1a1580	c8		iny		            INY
.1a1581	a2 05 00	ldx #$0005	            LDX #5
.1a1584	b5 10		lda $0810,x	ascii_loop  LDA SCRATCH2,X
.1a1586	29 f0		and #$f0	            AND #$F0
.1a1588	4a		lsr a		            LSR A
.1a1589	4a		lsr a		            LSR A
.1a158a	4a		lsr a		            LSR A
.1a158b	4a		lsr a		            LSR A
.1a158c	20 16 15	jsr $1a1516	            JSR ITOS_DIGIT
.1a158f	b5 10		lda $0810,x	            LDA SCRATCH2,X
.1a1591	29 0f		and #$0f	            AND #$0F
.1a1593	20 16 15	jsr $1a1516	            JSR ITOS_DIGIT
.1a1596	ca		dex		            DEX
.1a1597	10 eb		bpl $1a1584	            BPL ascii_loop
.1a1599	c0 01 00	cpy #$0001	            CPY #1              ; Did we write anything?
.1a159c	d0 0c		bne $1a15aa	            BNE null_term       ; Yes: add a NULL to terminate
.1a159e	a9 20		lda #$20	            LDA #' '            ; No: write a " 0" to the string
.1a15a0	87 16		sta [$0816]	            STA [STRPTR]
.1a15a2	a0 01 00	ldy #$0001	            LDY #1
.1a15a5	a9 30		lda #$30	            LDA #'0'
.1a15a7	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a15a9	c8		iny		            INY
.1a15aa	a9 00		lda #$00	null_term   LDA #0
.1a15ac	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And terminate the string
.1a15ae	28		plp		done        PLP
.1a15af	60		rts		            RTS
.1a15b0	00		brk #		fault       BRK
.1a15b1	ea		nop		            NOP
.1a15b2					STRLEN
.1a15b2	08		php		            PHP
.1a15b3	e2 20		sep #$20	            SEP #$20
.1a15b5	c2 10		rep #$10	            REP #$10
.1a15b7	a0 00 00	ldy #$0000	            LDY #0
.1a15ba	bd 00 00	lda $1a0000,x	loop        LDA #0,B,X
.1a15bd	f0 04		beq $1a15c3	            BEQ done
.1a15bf	e8		inx		            INX
.1a15c0	c8		iny		            INY
.1a15c1	80 f7		bra $1a15ba	            BRA loop
.1a15c3	28		plp		done        PLP
.1a15c4	60		rts		            RTS
.1a15c5					STRCMP
.1a15c5	08		php		            PHP
.1a15c6	0b		phd		            PHD
.1a15c7	08		php		            PHP
.1a15c8	c2 20		rep #$20	            REP #$20
.1a15ca	48		pha		            PHA
.1a15cb	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a15ce	5b		tcd		            TCD
.1a15cf	68		pla		            PLA
.1a15d0	28		plp		            PLP
.1a15d1	e2 20		sep #$20	            SEP #$20
.1a15d3	c2 10		rep #$10	            REP #$10
.1a15d5	a0 00 00	ldy #$0000	            LDY #0
.1a15d8	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Check if the character 1 is 0
.1a15da	d0 04		bne $1a15e0	            BNE comp_mag            ; If not, check the magnitudes
.1a15dc	b7 29		lda [$0829],y	            LDA [ARGUMENT2],Y       ; If so, check if the character 2 is 0
.1a15de	f0 25		beq $1a1605	            BEQ are_equal           ; If so, the strings are equal
.1a15e0	b7 23		lda [$0823],y	comp_mag    LDA [ARGUMENT1],Y       ; Otherwise, get character 1 again
.1a15e2	d7 29		cmp [$0829],y	            CMP [ARGUMENT2],Y       ; And compare it to character 2
.1a15e4	90 12		bcc $1a15f8	            BLT is_less             ; Check if character 1 < character 2
.1a15e6	d0 03		bne $1a15eb	            BNE is_greater          ; Check if character 1 > character 2
.1a15e8	c8		iny		            INY                     ; Equal so far... so go to the next pair of characters
.1a15e9	80 ed		bra $1a15d8	            BRA loop
.1a15eb					is_greater
.1a15eb	c2 20		rep #$20	            REP #$20
.1a15ed	a9 01 00	lda #$0001	            LDA #1                  ; So return 1
.1a15f0	85 23		sta $0823	            STA ARGUMENT1
.1a15f2	e2 20		sep #$20	            SEP #$20
.1a15f4	64 25		stz $0825	            STZ ARGUMENT1+2
.1a15f6	80 15		bra $1a160d	            BRA done
.1a15f8					is_less
.1a15f8	c2 20		rep #$20	            REP #$20
.1a15fa	a9 ff ff	lda #$ffff	            LDA #$FFFF              ; So return -1
.1a15fd	85 23		sta $0823	            STA ARGUMENT1
.1a15ff	e2 20		sep #$20	            SEP #$20
.1a1601	85 25		sta $0825	            STA ARGUMENT1+2
.1a1603	80 08		bra $1a160d	            BRA done
.1a1605					are_equal
.1a1605	c2 20		rep #$20	            REP #$20
.1a1607	64 23		stz $0823	            STZ ARGUMENT1           ; So return 0
.1a1609	e2 20		sep #$20	            SEP #$20
.1a160b	64 25		stz $0825	            STZ ARGUMENT1+2
.1a160d					done
.1a160d	e2 20		sep #$20	            SEP #$20
.1a160f	a9 00		lda #$00	            LDA #TYPE_INTEGER
.1a1611	85 27		sta $0827	            STA ARGTYPE1
.1a1613	2b		pld		            PLD
.1a1614	28		plp		            PLP
.1a1615	60		rts		            RTS
.1a1616					STRCONCAT
.1a1616	08		php		            PHP
.1a1617	0b		phd		            PHD
.1a1618	8b		phb		            PHB
.1a1619	08		php		            PHP
.1a161a	c2 20		rep #$20	            REP #$20
.1a161c	48		pha		            PHA
.1a161d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1620	5b		tcd		            TCD
.1a1621	68		pla		            PLA
.1a1622	28		plp		            PLP
.1a1623	e2 20		sep #$20	            SEP #$20
.1a1625	c2 10		rep #$10	            REP #$10
.1a1627	08		php		            PHP
.1a1628	c2 20		rep #$20	            REP #$20
.1a162a	48		pha		            PHA
.1a162b	e2 20		sep #$20	            SEP #$20
.1a162d	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a162f	48		pha		            PHA
.1a1630	ab		plb		            PLB
.1a1631	c2 20		rep #$20	            REP #$20
.1a1633	68		pla		            PLA
.1a1634	28		plp		            PLP
.1a1635	a6 23		ldx $0823	            LDX ARGUMENT1
.1a1637	20 b2 15	jsr $1a15b2	            JSR STRLEN
.1a163a	84 0c		sty $080c	            STY SCRATCH
.1a163c	08		php		            PHP
.1a163d	c2 20		rep #$20	            REP #$20
.1a163f	48		pha		            PHA
.1a1640	e2 20		sep #$20	            SEP #$20
.1a1642	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a1644	48		pha		            PHA
.1a1645	ab		plb		            PLB
.1a1646	c2 20		rep #$20	            REP #$20
.1a1648	68		pla		            PLA
.1a1649	28		plp		            PLP
.1a164a	a6 29		ldx $0829	            LDX ARGUMENT2
.1a164c	20 b2 15	jsr $1a15b2	            JSR STRLEN
.1a164f	c2 20		rep #$20	            REP #$20
.1a1651	98		tya		            TYA
.1a1652	38		sec		            SEC                     ; X := LEN(ARGUMENT1) + LEN(ARGUMENT2) + 1
.1a1653	65 0c		adc $080c	            ADC SCRATCH
.1a1655	aa		tax		            TAX
.1a1656	e2 20		sep #$20	            SEP #$20
.1a1658	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set type to STRING
.1a165a	20 98 10	jsr $1a1098	            JSR ALLOC
.1a165d	c2 20		rep #$20	            REP #$20
.1a165f	a5 b7		lda $08b7	            LDA ALLOCATED           ; INDEX := pointer to the string
.1a1661	85 08		sta $0808	            STA INDEX
.1a1663	e2 20		sep #$20	            SEP #$20
.1a1665	a5 b9		lda $08b9	            LDA ALLOCATED+2
.1a1667	85 0a		sta $080a	            STA INDEX+2
.1a1669	a0 00 00	ldy #$0000	            LDY #0                  ; Set the target index to the beginning
.1a166c	08		php		            PHP
.1a166d	c2 20		rep #$20	            REP #$20
.1a166f	48		pha		            PHA
.1a1670	e2 20		sep #$20	            SEP #$20
.1a1672	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a1674	48		pha		            PHA
.1a1675	ab		plb		            PLB
.1a1676	c2 20		rep #$20	            REP #$20
.1a1678	68		pla		            PLA
.1a1679	28		plp		            PLP
.1a167a	a6 23		ldx $0823	            LDX ARGUMENT1
.1a167c	bd 00 00	lda $1a0000,x	loop1       LDA #0,B,X              ; Get the Xth byte of ARGUMENT1
.1a167f	f0 06		beq $1a1687	            BEQ copy_2              ; Is it null? Yes: move on to the next string
.1a1681	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.1a1683	e8		inx		            INX                     ; Point to the next characters
.1a1684	c8		iny		            INY
.1a1685	80 f5		bra $1a167c	            BRA loop1               ; And do again
.1a1687					copy_2
.1a1687	e2 20		sep #$20	            SEP #$20
.1a1689	08		php		            PHP
.1a168a	c2 20		rep #$20	            REP #$20
.1a168c	48		pha		            PHA
.1a168d	e2 20		sep #$20	            SEP #$20
.1a168f	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a1691	48		pha		            PHA
.1a1692	ab		plb		            PLB
.1a1693	c2 20		rep #$20	            REP #$20
.1a1695	68		pla		            PLA
.1a1696	28		plp		            PLP
.1a1697	a6 29		ldx $0829	            LDX ARGUMENT2
.1a1699	bd 00 00	lda $1a0000,x	loop2       LDA #0,B,X              ; Get the Xth byte of ARGUMENT2
.1a169c	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.1a169e	f0 04		beq $1a16a4	            BEQ terminate           ; Is it null? Yes: move on to the next string
.1a16a0	e8		inx		            INX                     ; Point to the next characters
.1a16a1	c8		iny		            INY
.1a16a2	80 f5		bra $1a1699	            BRA loop2               ; And do again
.1a16a4					terminate
.1a16a4	c2 20		rep #$20	            REP #$20
.1a16a6	a5 08		lda $0808	            LDA INDEX               ; Set ARGUMENT1 to the new string
.1a16a8	85 23		sta $0823	            STA ARGUMENT1
.1a16aa	e2 20		sep #$20	            SEP #$20
.1a16ac	a5 0a		lda $080a	            LDA INDEX+2
.1a16ae	85 25		sta $0825	            STA ARGUMENT1+2
.1a16b0	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set ARGUMENT1's type to STRING
.1a16b2	85 27		sta $0827	            STA ARGTYPE1
.1a16b4	ab		plb		            PLB
.1a16b5	2b		pld		            PLD
.1a16b6	28		plp		            PLP
.1a16b7	60		rts		            RTS
.1a16b8					STRCPY
.1a16b8	da		phx		            PHX
.1a16b9	5a		phy		            PHY
.1a16ba	08		php		            PHP
.1a16bb	0b		phd		            PHD
.1a16bc	8b		phb		            PHB
.1a16bd	08		php		            PHP
.1a16be	c2 20		rep #$20	            REP #$20
.1a16c0	48		pha		            PHA
.1a16c1	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a16c4	5b		tcd		            TCD
.1a16c5	68		pla		            PLA
.1a16c6	28		plp		            PLP
.1a16c7	c2 20		rep #$20	            REP #$20
.1a16c9	a5 0a		lda $080a	            LDA INDEX+2
.1a16cb	48		pha		            PHA
.1a16cc	a5 08		lda $0808	            LDA INDEX
.1a16ce	48		pha		            PHA
.1a16cf	c2 30		rep #$30	            REP #$30
.1a16d1	08		php		            PHP
.1a16d2	c2 20		rep #$20	            REP #$20
.1a16d4	48		pha		            PHA
.1a16d5	e2 20		sep #$20	            SEP #$20
.1a16d7	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a16d9	48		pha		            PHA
.1a16da	ab		plb		            PLB
.1a16db	c2 20		rep #$20	            REP #$20
.1a16dd	68		pla		            PLA
.1a16de	28		plp		            PLP
.1a16df	a6 23		ldx $0823	            LDX ARGUMENT1
.1a16e1	20 b2 15	jsr $1a15b2	            JSR STRLEN
.1a16e4	98		tya		            TYA
.1a16e5	aa		tax		            TAX
.1a16e6	e8		inx		            INX                     ; Put length of string (plus NUL) in X
.1a16e7	e2 20		sep #$20	            SEP #$20
.1a16e9	a9 02		lda #$02	            LDA #TYPE_STRING
.1a16eb	20 98 10	jsr $1a1098	            JSR ALLOC
.1a16ee	c2 20		rep #$20	            REP #$20
.1a16f0	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a16f2	85 08		sta $0808	            STA INDEX
.1a16f4	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a16f6	85 0a		sta $080a	            STA INDEX+2
.1a16f8	a0 00 00	ldy #$0000	            LDY #0
.1a16fb	e2 20		sep #$20	            SEP #$20
.1a16fd	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Copy the data to the allocated string
.1a16ff	97 08		sta [$0808],y	            STA [INDEX],Y
.1a1701	f0 03		beq $1a1706	            BEQ ret_copy
.1a1703	c8		iny		            INY
.1a1704	80 f7		bra $1a16fd	            BRA loop
.1a1706					ret_copy
.1a1706	c2 20		rep #$20	            REP #$20
.1a1708	a5 08		lda $0808	            LDA INDEX
.1a170a	85 23		sta $0823	            STA ARGUMENT1
.1a170c	a5 0a		lda $080a	            LDA INDEX+2
.1a170e	85 25		sta $0825	            STA ARGUMENT1+2
.1a1710	c2 20		rep #$20	            REP #$20
.1a1712	68		pla		            PLA
.1a1713	85 08		sta $0808	            STA INDEX
.1a1715	68		pla		            PLA
.1a1716	85 0a		sta $080a	            STA INDEX+2
.1a1718	ab		plb		            PLB
.1a1719	2b		pld		            PLD
.1a171a	28		plp		            PLP
.1a171b	7a		ply		            PLY
.1a171c	fa		plx		            PLX
.1a171d	60		rts		            RTS
.1a171e					STRSUBSTR
.1a171e	08		php		            PHP
.1a171f	e2 20		sep #$20	            SEP #$20
.1a1721	c2 10		rep #$10	            REP #$10
.1a1723	a0 00 00	ldy #$0000	            LDY #0
.1a1726	b7 23		lda [$0823],y	count_loop  LDA [ARGUMENT1],Y
.1a1728	f0 05		beq $1a172f	            BEQ counted
.1a172a	c8		iny		            INY
.1a172b	80 f9		bra $1a1726	            BRA count_loop
.1a172d	84 92		sty $0892	            STY MTEMP               ; MTEMP := length of the source string
.1a172f					counted
.1a172f	c2 30		rep #$30	            REP #$30
.1a1731	c4 29		cpy $0829	            CPY ARGUMENT2           ; length of string <= index?
.1a1733	90 13		bcc $1a1748	            BLT ret_empty           ; Yes: return empty string
.1a1735	f0 11		beq $1a1748	            BEQ ret_empty
.1a1737	a5 8f		lda $088f	            LDA MCOUNT              ; Is the desired count <= 0?
.1a1739	30 0d		bmi $1a1748	            BMI ret_empty
.1a173b	f0 0b		beq $1a1748	            BEQ ret_empty           ; Yes: return the empty string
.1a173d	c4 8f		cpy $088f	            CPY MCOUNT              ; Is the desired length < the length of the source?
.1a173f	b0 12		bcs $1a1753	            BGE do_slice            ; Yes: go ahead and get the substring
.1a1741	a5 29		lda $0829	            LDA ARGUMENT2           ; Is INDEX == 0?
.1a1743	d0 0e		bne $1a1753	            BNE do_slice            ; No: do a slice
.1a1745	4c 9c 17	jmp $1a179c	            JMP done                ; Yes: just return the source string
.1a1748					ret_empty
.1a1748	20 c6 14	jsr $1a14c6	            JSR TEMPSTRING
.1a174b	e2 20		sep #$20	            SEP #$20
.1a174d	a9 00		lda #$00	            LDA #0
.1a174f	87 16		sta [$0816]	            STA [STRPTR]
.1a1751	80 39		bra $1a178c	            BRA finish_copy
.1a1753					do_slice
.1a1753	20 c6 14	jsr $1a14c6	            JSR TEMPSTRING
.1a1756	c2 30		rep #$30	            REP #$30
.1a1758	18		clc		            CLC                     ; ARGUMENT1 := ARGUMENT1 + index
.1a1759	a5 23		lda $0823	            LDA ARGUMENT1
.1a175b	65 29		adc $0829	            ADC ARGUMENT2
.1a175d	85 23		sta $0823	            STA ARGUMENT1
.1a175f	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a1761	69 00 00	adc #$0000	            ADC #0
.1a1764	85 25		sta $0825	            STA ARGUMENT1+2
.1a1766	a0 00 00	ldy #$0000	            LDY #0
.1a1769					copy_loop
.1a1769	e2 20		sep #$20	            SEP #$20
.1a176b	a7 23		lda [$0823]	            LDA [ARGUMENT1]         ; Copy a character from the substring to the temporary string
.1a176d	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a176f	f0 1b		beq $1a178c	            BEQ finish_copy         ; If it is a NULL, we're done
.1a1771	c2 20		rep #$20	            REP #$20
.1a1773	18		clc		            CLC                     ; Move to the next character
.1a1774	a5 23		lda $0823	            LDA ARGUMENT1
.1a1776	69 01 00	adc #$0001	            ADC #1
.1a1779	85 23		sta $0823	            STA ARGUMENT1
.1a177b	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a177d	69 00 00	adc #$0000	            ADC #0
.1a1780	85 25		sta $0825	            STA ARGUMENT1+2
.1a1782	c8		iny		            INY
.1a1783	c4 8f		cpy $088f	            CPY MCOUNT              ; Have we reached the limit to copy?
.1a1785	d0 e2		bne $1a1769	            BNE copy_loop           ; No: copy the next byte
.1a1787	a9 00 00	lda #$0000	            LDA #0                  ; Null terminate string
.1a178a	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a178c					finish_copy
.1a178c	c2 20		rep #$20	            REP #$20
.1a178e	a5 16		lda $0816	            LDA STRPTR
.1a1790	85 23		sta $0823	            STA ARGUMENT1
.1a1792	a5 18		lda $0818	            LDA STRPTR+2
.1a1794	85 25		sta $0825	            STA ARGUMENT1+2
.1a1796	e2 20		sep #$20	            SEP #$20
.1a1798	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a179a	85 27		sta $0827	            STA ARGTYPE1
.1a179c					done
.1a179c	28		plp		            PLP
.1a179d	60		rts		            RTS
.1a179e					OP_STR_LT
.1a179e	08		php		            PHP
.1a179f	c2 30		rep #$30	            REP #$30
.1a17a1	20 c5 15	jsr $1a15c5	            JSR STRCMP
.1a17a4	a5 23		lda $0823	            LDA ARGUMENT1
.1a17a6	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.1a17a9	d0 05		bne $1a17b0	            BNE ret_false               ; No: return false
.1a17ab					ret_true
.1a17ab	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a17ae	80 03		bra $1a17b3	            BRA done
.1a17b0					ret_false
.1a17b0	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a17b3	28		plp		done        PLP
.1a17b4	60		rts		            RTS
.1a17b5					OP_STR_GT
.1a17b5	08		php		            PHP
.1a17b6	c2 30		rep #$30	            REP #$30
.1a17b8	20 c5 15	jsr $1a15c5	            JSR STRCMP
.1a17bb	a5 23		lda $0823	            LDA ARGUMENT1
.1a17bd	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.1a17c0	d0 05		bne $1a17c7	            BNE ret_false               ; No: return false
.1a17c2					ret_true
.1a17c2	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a17c5	80 03		bra $1a17ca	            BRA done
.1a17c7					ret_false
.1a17c7	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a17ca	28		plp		done        PLP
.1a17cb	60		rts		            RTS
.1a17cc					OP_STR_EQ
.1a17cc	08		php		            PHP
.1a17cd	c2 30		rep #$30	            REP #$30
.1a17cf	20 c5 15	jsr $1a15c5	            JSR STRCMP
.1a17d2	a5 23		lda $0823	            LDA ARGUMENT1
.1a17d4	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.1a17d7	d0 05		bne $1a17de	            BNE ret_false               ; No: return false
.1a17d9					ret_true
.1a17d9	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a17dc	80 03		bra $1a17e1	            BRA done
.1a17de					ret_false
.1a17de	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a17e1	28		plp		done        PLP
.1a17e2	60		rts		            RTS
.1a17e3					OP_STR_NE
.1a17e3	08		php		            PHP
.1a17e4	c2 30		rep #$30	            REP #$30
.1a17e6	20 c5 15	jsr $1a15c5	            JSR STRCMP
.1a17e9	a5 23		lda $0823	            LDA ARGUMENT1
.1a17eb	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.1a17ee	f0 05		beq $1a17f5	            BEQ ret_false               ; Yes: return false
.1a17f0					ret_true
.1a17f0	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a17f3	80 03		bra $1a17f8	            BRA done
.1a17f5					ret_false
.1a17f5	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a17f8	28		plp		done        PLP
.1a17f9	60		rts		            RTS
.1a17fa					OP_STR_GTE
.1a17fa	08		php		            PHP
.1a17fb	c2 30		rep #$30	            REP #$30
.1a17fd	20 c5 15	jsr $1a15c5	            JSR STRCMP
.1a1800	a5 23		lda $0823	            LDA ARGUMENT1
.1a1802	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.1a1805	f0 05		beq $1a180c	            BEQ ret_false               ; Yes: return false
.1a1807					ret_true
.1a1807	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a180a	80 03		bra $1a180f	            BRA done
.1a180c					ret_false
.1a180c	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a180f	28		plp		done        PLP
.1a1810	60		rts		            RTS
.1a1811					OP_STR_LTE
.1a1811	08		php		            PHP
.1a1812	c2 30		rep #$30	            REP #$30
.1a1814	20 c5 15	jsr $1a15c5	            JSR STRCMP
.1a1817	a5 23		lda $0823	            LDA ARGUMENT1
.1a1819	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.1a181c	f0 05		beq $1a1823	            BEQ ret_false               ; Yes: return false
.1a181e					ret_true
.1a181e	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a1821	80 03		bra $1a1826	            BRA done
.1a1823					ret_false
.1a1823	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a1826	28		plp		done        PLP
.1a1827	60		rts		            RTS
.1a1828					STR_NORMAL
.1a1828	08		php		            PHP
.1a1829	e2 20		sep #$20	            SEP #$20
.1a182b	a5 27		lda $0827	            LDA ARGTYPE1            ; Is it a string?
.1a182d	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a182f	d0 1d		bne $1a184e	            BNE done                ; No: return it
.1a1831	a5 23		lda $0823	            LDA ARGUMENT1           ; Is it a null pointer?
.1a1833	d0 19		bne $1a184e	            BNE done
.1a1835	a5 24		lda $0824	            LDA ARGUMENT1+1
.1a1837	d0 15		bne $1a184e	            BNE done
.1a1839	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a183b	d0 11		bne $1a184e	            BNE done                ; No: return it
.1a183d	20 c6 14	jsr $1a14c6	            JSR TEMPSTRING
.1a1840	a9 00		lda #$00	            LDA #0
.1a1842	87 16		sta [$0816]	            STA [STRPTR]            ; Make it empty
.1a1844	c2 20		rep #$20	            REP #$20
.1a1846	a5 16		lda $0816	            LDA STRPTR
.1a1848	85 23		sta $0823	            STA ARGUMENT1
.1a184a	a5 18		lda $0818	            LDA STRPTR+2
.1a184c	85 25		sta $0825	            STA ARGUMENT1+2
.1a184e	28		plp		done        PLP
.1a184f	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\listing.s

.1a1850					LISTPROG
.1a1850	48		pha		            PHA
.1a1851	5a		phy		            PHY
.1a1852	0b		phd		            PHD
.1a1853	08		php		            PHP
.1a1854	08		php		            PHP
.1a1855	c2 20		rep #$20	            REP #$20
.1a1857	48		pha		            PHA
.1a1858	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a185b	5b		tcd		            TCD
.1a185c	68		pla		            PLA
.1a185d	28		plp		            PLP
.1a185e	c2 30		rep #$30	            REP #$30
.1a1860	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.1a1863	85 00		sta $0800	            STA BIP
.1a1865	85 1a		sta $081a	            STA CURLINE
.1a1867	a9 16 00	lda #$0016	            LDA #`BASIC_BOT
.1a186a	85 02		sta $0802	            STA BIP+2
.1a186c	85 1c		sta $081c	            STA CURLINE+2
.1a186e	22 3c 11 00	jsl $00113c	list_loop   JSL FK_TESTBREAK
.1a1872	b0 20		bcs $1a1894	            BCS throw_break     ; If C: user pressed an interrupt key, stop the listing
.1a1874	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.1a1877	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.1a1879	f0 0f		beq $1a188a	            BEQ done
.1a187b	c5 55		cmp $0855	            CMP MARG1
.1a187d	90 10		bcc $1a188f	            BLT skip_line
.1a187f	c5 59		cmp $0859	            CMP MARG2
.1a1881	f0 02		beq $1a1885	            BEQ print_line
.1a1883	b0 05		bcs $1a188a	            BGE done
.1a1885					print_line
.1a1885	20 b3 18	jsr $1a18b3	            JSR LISTLINE
.1a1888	80 e4		bra $1a186e	            BRA list_loop
.1a188a	28		plp		done        PLP
.1a188b	2b		pld		            PLD
.1a188c	7a		ply		            PLY
.1a188d	68		pla		            PLA
.1a188e	60		rts		            RTS
.1a188f					skip_line
.1a188f	20 bf 21	jsr $1a21bf	            JSR NEXTLINE
.1a1892	80 da		bra $1a186e	            BRA list_loop           ; And try again
.1a1894					throw_break
.1a1894	08		php		            PHP
.1a1895	c2 20		rep #$20	            REP #$20
.1a1897	48		pha		            PHA
.1a1898	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a189b	5b		tcd		            TCD
.1a189c	68		pla		            PLA
.1a189d	28		plp		            PLP
.1a189e	e2 20		sep #$20	            SEP #$20
.1a18a0	a9 01		lda #$01	            LDA #ERR_BREAK
.1a18a2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a18a6	c2 20		rep #$20	            REP #$20
.1a18a8	29 ff 00	and #$00ff	            AND #$00FF
.1a18ab	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a18ae	e2 20		sep #$20	            SEP #$20
.1a18b0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a18b3					LISTLINE
.1a18b3	08		php		            PHP
.1a18b4	c2 30		rep #$30	            REP #$30
.1a18b6	85 23		sta $0823	            STA ARGUMENT1
.1a18b8	64 25		stz $0825	            STZ ARGUMENT1+2
.1a18ba	20 25 15	jsr $1a1525	            JSR ITOS
.1a18bd	a5 16		lda $0816	            LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.1a18bf	1a		inc a		            INC A
.1a18c0	85 23		sta $0823	            STA ARGUMENT1
.1a18c2	a5 18		lda $0818	            LDA STRPTR+2
.1a18c4	85 25		sta $0825	            STA ARGUMENT1+2
.1a18c6	20 c5 45	jsr $1a45c5	            JSR PR_STRING
.1a18c9	18		clc		            CLC                 ; Move the BIP to the first byte of the line
.1a18ca	a5 1a		lda $081a	            LDA CURLINE
.1a18cc	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a18cf	85 00		sta $0800	            STA BIP
.1a18d1	a5 1c		lda $081c	            LDA CURLINE+2
.1a18d3	69 00 00	adc #$0000	            ADC #0
.1a18d6	85 02		sta $0802	            STA BIP+2
.1a18d8	e2 20		sep #$20	            SEP #$20
.1a18da	a9 20		lda #$20	            LDA #CHAR_SP
.1a18dc	20 18 00	jsr $1a0018	            JSR PRINTC
.1a18df	c2 20		rep #$20	            REP #$20
.1a18e1					loop
.1a18e1	20 f2 18	jsr $1a18f2	            JSR LISTBYTE
.1a18e4	90 fb		bcc $1a18e1	            BCC loop
.1a18e6	e2 20		sep #$20	            SEP #$20
.1a18e8	a9 0d		lda #$0d	            LDA #CHAR_CR
.1a18ea	20 18 00	jsr $1a0018	            JSR PRINTC
.1a18ed	20 bf 21	jsr $1a21bf	            JSR NEXTLINE
.1a18f0	28		plp		            PLP
.1a18f1	60		rts		            RTS
.1a18f2					LISTBYTE
.1a18f2	08		php		            PHP
.1a18f3	0b		phd		            PHD
.1a18f4	8b		phb		            PHB
.1a18f5	08		php		            PHP
.1a18f6	c2 20		rep #$20	            REP #$20
.1a18f8	48		pha		            PHA
.1a18f9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a18fc	5b		tcd		            TCD
.1a18fd	68		pla		            PLA
.1a18fe	28		plp		            PLP
.1a18ff	08		php		            PHP
.1a1900	e2 20		sep #$20	            SEP #$20
.1a1902	48		pha		            PHA
.1a1903	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1905	48		pha		            PHA
.1a1906	ab		plb		            PLB
.1a1907	68		pla		            PLA
.1a1908	28		plp		            PLP
.1a1909	e2 20		sep #$20	            SEP #$20
.1a190b	c2 10		rep #$10	            REP #$10
.1a190d	a7 00		lda [$0800]	            LDA [BIP]           ; Get the current byte
.1a190f	f0 3a		beq $1a194b	            BEQ end_of_line     ; If it's 0, return with C set
.1a1911	30 05		bmi $1a1918	            BMI is_token        ; If it's 0x80 - 0xFF, it's a token
.1a1913	20 18 00	jsr $1a0018	            JSR PRINTC
.1a1916	80 29		bra $1a1941	            BRA done            ; And return
.1a1918					is_token
.1a1918	c2 20		rep #$20	            REP #$20
.1a191a	29 7f 00	and #$007f	            AND #$007F          ; Compute the index of the token
.1a191d	0a		asl a		            ASL A               ; In the token table
.1a191e	0a		asl a		            ASL A
.1a191f	0a		asl a		            ASL A
.1a1920	18		clc		            CLC
.1a1921	69 c0 0c	adc #$0cc0	            ADC #<>TOKENS       ; Set INDEX to the address of the token
.1a1924	85 08		sta $0808	            STA INDEX
.1a1926	a9 1a 00	lda #$001a	            LDA #`TOKENS
.1a1929	69 00 00	adc #$0000	            ADC #0
.1a192c	85 0a		sta $080a	            STA INDEX+2
.1a192e					pr_default
.1a192e	08		php		            PHP
.1a192f	e2 20		sep #$20	            SEP #$20
.1a1931	48		pha		            PHA
.1a1932	a9 1a		lda #$1a	            LDA #`TOKENS
.1a1934	48		pha		            PHA
.1a1935	ab		plb		            PLB
.1a1936	68		pla		            PLA
.1a1937	28		plp		            PLP
.1a1938	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.1a193b	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a193d	aa		tax		            TAX
.1a193e	20 29 04	jsr $1a0429	            JSR PRINTS
.1a1941					done
.1a1941	c2 20		rep #$20	            REP #$20
.1a1943	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a1946	ab		plb		            PLB
.1a1947	2b		pld		            PLD
.1a1948	28		plp		            PLP
.1a1949	18		clc		            CLC
.1a194a	60		rts		            RTS
.1a194b	ab		plb		end_of_line PLB
.1a194c	2b		pld		            PLD
.1a194d	28		plp		            PLP
.1a194e	38		sec		            SEC
.1a194f	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\eval.s

.1a1950					INITEVALSP
.1a1950	08		php		            PHP
.1a1951	c2 20		rep #$20	            REP #$20
.1a1953	a9 ff 6f	lda #$6fff	            LDA #ARGUMENT_TOP
.1a1956	85 1f		sta $081f	            STA ARGUMENTSP
.1a1958	a9 ff 7f	lda #$7fff	            LDA #OPERATOR_TOP
.1a195b	85 21		sta $0821	            STA OPERATORSP
.1a195d	a9 ff ff	lda #$ffff	            LDA #$FFFF
.1a1960	85 23		sta $0823	            STA ARGUMENT1
.1a1962	85 25		sta $0825	            STA ARGUMENT1+2
.1a1964	85 29		sta $0829	            STA ARGUMENT2
.1a1966	85 2b		sta $082b	            STA ARGUMENT2+2
.1a1968	e2 20		sep #$20	            SEP #$20
.1a196a	85 27		sta $0827	            STA ARGTYPE1
.1a196c	85 2d		sta $082d	            STA ARGTYPE2
.1a196e	28		plp		            PLP
.1a196f	60		rts		            RTS
.1a1970					PHARGUMENT
.1a1970	08		php		            PHP
.1a1971	0b		phd		            PHD
.1a1972	8b		phb		            PHB
.1a1973	08		php		            PHP
.1a1974	c2 20		rep #$20	            REP #$20
.1a1976	48		pha		            PHA
.1a1977	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a197a	5b		tcd		            TCD
.1a197b	68		pla		            PLA
.1a197c	28		plp		            PLP
.1a197d	08		php		            PHP
.1a197e	e2 20		sep #$20	            SEP #$20
.1a1980	48		pha		            PHA
.1a1981	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1983	48		pha		            PHA
.1a1984	ab		plb		            PLB
.1a1985	68		pla		            PLA
.1a1986	28		plp		            PLP
.1a1987	c2 30		rep #$30	            REP #$30
.1a1989	5a		phy		            PHY
.1a198a	a4 1f		ldy $081f	            LDY ARGUMENTSP
.1a198c	bd 00 00	lda $0000,x	            LDA #0,B,X
.1a198f	99 00 00	sta $0000,y	            STA #0,B,Y
.1a1992	bd 02 00	lda $0002,x	            LDA #2,B,X
.1a1995	99 02 00	sta $0002,y	            STA #2,B,Y
.1a1998	e2 20		sep #$20	            SEP #$20
.1a199a	bd 04 00	lda $0004,x	            LDA #4,B,X
.1a199d	99 04 00	sta $0004,y	            STA #4,B,Y
.1a19a0	c2 20		rep #$20	            REP #$20
.1a19a2	38		sec		            SEC
.1a19a3	98		tya		            TYA
.1a19a4	e9 05 00	sbc #$0005	            SBC #ARGUMENT_SIZE
.1a19a7	85 1f		sta $081f	            STA ARGUMENTSP
.1a19a9	7a		ply		            PLY
.1a19aa	ab		plb		            PLB
.1a19ab	2b		pld		            PLD
.1a19ac	28		plp		            PLP
.1a19ad	60		rts		            RTS
.1a19ae					PLARGUMENT
.1a19ae	08		php		            PHP
.1a19af	0b		phd		            PHD
.1a19b0	8b		phb		            PHB
.1a19b1	08		php		            PHP
.1a19b2	c2 20		rep #$20	            REP #$20
.1a19b4	48		pha		            PHA
.1a19b5	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a19b8	5b		tcd		            TCD
.1a19b9	68		pla		            PLA
.1a19ba	28		plp		            PLP
.1a19bb	08		php		            PHP
.1a19bc	e2 20		sep #$20	            SEP #$20
.1a19be	48		pha		            PHA
.1a19bf	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a19c1	48		pha		            PHA
.1a19c2	ab		plb		            PLB
.1a19c3	68		pla		            PLA
.1a19c4	28		plp		            PLP
.1a19c5	c2 30		rep #$30	            REP #$30
.1a19c7	5a		phy		            PHY
.1a19c8	18		clc		            CLC
.1a19c9	a5 1f		lda $081f	            LDA ARGUMENTSP
.1a19cb	69 05 00	adc #$0005	            ADC #ARGUMENT_SIZE
.1a19ce	85 1f		sta $081f	            STA ARGUMENTSP
.1a19d0	a8		tay		            TAY
.1a19d1	b9 00 00	lda $0000,y	            LDA #0,B,Y
.1a19d4	9d 00 00	sta $0000,x	            STA #0,B,X
.1a19d7	b9 02 00	lda $0002,y	            LDA #2,B,Y
.1a19da	9d 02 00	sta $0002,x	            STA #2,B,X
.1a19dd	e2 20		sep #$20	            SEP #$20
.1a19df	b9 04 00	lda $0004,y	            LDA #4,B,Y
.1a19e2	9d 04 00	sta $0004,x	            STA #4,B,X
.1a19e5	bd 00 00	lda $0000,x	            LDA #0,B,X
.1a19e8	7a		ply		            PLY
.1a19e9	ab		plb		            PLB
.1a19ea	2b		pld		            PLD
.1a19eb	28		plp		            PLP
.1a19ec	60		rts		            RTS
.1a19ed					PHOPERATOR
.1a19ed	08		php		            PHP
.1a19ee	0b		phd		            PHD
.1a19ef	8b		phb		            PHB
.1a19f0	08		php		            PHP
.1a19f1	c2 20		rep #$20	            REP #$20
.1a19f3	48		pha		            PHA
.1a19f4	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a19f7	5b		tcd		            TCD
.1a19f8	68		pla		            PLA
.1a19f9	28		plp		            PLP
.1a19fa	08		php		            PHP
.1a19fb	e2 20		sep #$20	            SEP #$20
.1a19fd	48		pha		            PHA
.1a19fe	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1a00	48		pha		            PHA
.1a1a01	ab		plb		            PLB
.1a1a02	68		pla		            PLA
.1a1a03	28		plp		            PLP
.1a1a04	e2 20		sep #$20	            SEP #$20
.1a1a06	c2 10		rep #$10	            REP #$10
.1a1a08	5a		phy		            PHY
.1a1a09	a4 21		ldy $0821	            LDY OPERATORSP
.1a1a0b	99 00 00	sta $0000,y	            STA #0,B,Y
.1a1a0e	88		dey		            DEY
.1a1a0f	84 21		sty $0821	            STY OPERATORSP
.1a1a11	7a		ply		done        PLY
.1a1a12	ab		plb		            PLB
.1a1a13	2b		pld		            PLD
.1a1a14	28		plp		            PLP
.1a1a15	60		rts		            RTS
.1a1a16					PLOPERATOR
.1a1a16	08		php		            PHP
.1a1a17	0b		phd		            PHD
.1a1a18	8b		phb		            PHB
.1a1a19	08		php		            PHP
.1a1a1a	c2 20		rep #$20	            REP #$20
.1a1a1c	48		pha		            PHA
.1a1a1d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1a20	5b		tcd		            TCD
.1a1a21	68		pla		            PLA
.1a1a22	28		plp		            PLP
.1a1a23	08		php		            PHP
.1a1a24	e2 20		sep #$20	            SEP #$20
.1a1a26	48		pha		            PHA
.1a1a27	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1a29	48		pha		            PHA
.1a1a2a	ab		plb		            PLB
.1a1a2b	68		pla		            PLA
.1a1a2c	28		plp		            PLP
.1a1a2d	e2 20		sep #$20	            SEP #$20
.1a1a2f	c2 10		rep #$10	            REP #$10
.1a1a31	5a		phy		            PHY
.1a1a32	a4 21		ldy $0821	            LDY OPERATORSP
.1a1a34	c8		iny		            INY
.1a1a35	84 21		sty $0821	            STY OPERATORSP
.1a1a37	b9 00 00	lda $0000,y	            LDA #0,B,Y
.1a1a3a	c2 20		rep #$20	            REP #$20
.1a1a3c	29 ff 00	and #$00ff	            AND #$00FF
.1a1a3f	7a		ply		            PLY
.1a1a40	ab		plb		            PLB
.1a1a41	2b		pld		            PLD
.1a1a42	28		plp		            PLP
.1a1a43	60		rts		            RTS
.1a1a44					OPENPARAMS
.1a1a44	08		php		            PHP
.1a1a45	e2 20		sep #$20	            SEP #$20
.1a1a47	a9 01		lda #$01	            LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.1a1a49	20 ed 19	jsr $1a19ed	            JSR PHOPERATOR
.1a1a4c	28		plp		            PLP
.1a1a4d	60		rts		            RTS
.1a1a4e					CLOSEPARAMS
.1a1a4e	5a		phy		            PHY
.1a1a4f	08		php		            PHP
.1a1a50	8b		phb		            PHB
.1a1a51	08		php		            PHP
.1a1a52	e2 20		sep #$20	            SEP #$20
.1a1a54	48		pha		            PHA
.1a1a55	a9 00		lda #$00	            LDA #0
.1a1a57	48		pha		            PHA
.1a1a58	ab		plb		            PLB
.1a1a59	68		pla		            PLA
.1a1a5a	28		plp		            PLP
.1a1a5b	e2 20		sep #$20	            SEP #$20
.1a1a5d	a4 21		ldy $0821	            LDY OPERATORSP      ; Peek at the top operator
.1a1a5f	b9 01 00	lda $0001,y	            LDA #1,B,Y
.1a1a62	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the marker for the start of a parameter list
.1a1a64	d0 08		bne $1a1a6e	            BNE error           ; No: there's a problem
.1a1a66	c2 20		rep #$20	            REP #$20
.1a1a68	e6 21		inc $0821	            INC OPERATORSP      ; Yes: remove it from the operator stack.
.1a1a6a	ab		plb		            PLB
.1a1a6b	28		plp		            PLP
.1a1a6c	7a		ply		            PLY
.1a1a6d	60		rts		            RTS
.1a1a6e					error
.1a1a6e	08		php		            PHP
.1a1a6f	c2 20		rep #$20	            REP #$20
.1a1a71	48		pha		            PHA
.1a1a72	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1a75	5b		tcd		            TCD
.1a1a76	68		pla		            PLA
.1a1a77	28		plp		            PLP
.1a1a78	e2 20		sep #$20	            SEP #$20
.1a1a7a	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1a7c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1a80	c2 20		rep #$20	            REP #$20
.1a1a82	29 ff 00	and #$00ff	            AND #$00FF
.1a1a85	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a1a88	e2 20		sep #$20	            SEP #$20
.1a1a8a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1a8d					OPHIGHPREC
.1a1a8d	48		pha		            PHA
.1a1a8e	08		php		            PHP
.1a1a8f	0b		phd		            PHD
.1a1a90	8b		phb		            PHB
.1a1a91	08		php		            PHP
.1a1a92	c2 20		rep #$20	            REP #$20
.1a1a94	48		pha		            PHA
.1a1a95	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1a98	5b		tcd		            TCD
.1a1a99	68		pla		            PLA
.1a1a9a	28		plp		            PLP
.1a1a9b	08		php		            PHP
.1a1a9c	e2 20		sep #$20	            SEP #$20
.1a1a9e	48		pha		            PHA
.1a1a9f	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1aa1	48		pha		            PHA
.1a1aa2	ab		plb		            PLB
.1a1aa3	68		pla		            PLA
.1a1aa4	28		plp		            PLP
.1a1aa5	e2 20		sep #$20	            SEP #$20
.1a1aa7	a4 21		ldy $0821	            LDY OPERATORSP
.1a1aa9	c0 ff 7f	cpy #$7fff	            CPY #OPERATOR_TOP       ; Is the stack empty?
.1a1aac	f0 11		beq $1a1abf	            BEQ is_false            ; Yes: return false
.1a1aae	20 1f 0c	jsr $1a0c1f	            JSR TOKPRECED
.1a1ab1	85 0c		sta $080c	            STA SCRATCH             ; Save it for later comparison
.1a1ab3	b9 01 00	lda $0001,y	            LDA #1,B,Y              ; Get the operator at the top of the stack
.1a1ab6	20 1f 0c	jsr $1a0c1f	            JSR TOKPRECED
.1a1ab9	c5 0c		cmp $080c	            CMP SCRATCH             ; Compare the priorities (0 = highest priority)
.1a1abb	f0 02		beq $1a1abf	            BEQ is_false            ; A = SCRATCH, return false
.1a1abd	90 08		bcc $1a1ac7	            BCC is_true             ; A < SCRATCH (A is higher priority), return false
.1a1abf					is_false
.1a1abf	c2 20		rep #$20	            REP #$20
.1a1ac1	ab		plb		            PLB
.1a1ac2	2b		pld		            PLD
.1a1ac3	28		plp		            PLP
.1a1ac4	68		pla		            PLA
.1a1ac5	18		clc		            CLC
.1a1ac6	60		rts		            RTS
.1a1ac7					is_true
.1a1ac7	c2 20		rep #$20	            REP #$20
.1a1ac9	ab		plb		            PLB                     ; A > SCRATCH (A is lower priority), return true
.1a1aca	2b		pld		            PLD
.1a1acb	28		plp		            PLP
.1a1acc	68		pla		            PLA
.1a1acd	38		sec		            SEC
.1a1ace	60		rts		            RTS
.1a1acf					EVALNUMBER
.1a1acf	4c 9d 08	jmp $1a089d	            JMP PARSEINT
.1a1ad2					ARR_GETIDX
.1a1ad2	08		php		            PHP
.1a1ad3	e2 20		sep #$20	            SEP #$20
.1a1ad5	a9 00		lda #$00	            LDA #0
.1a1ad7	8f 00 4d 00	sta $004d00	            STA @lARRIDXBUF     ; Set the dimension to 0
.1a1adb	a2 01 00	ldx #$0001	            LDX #1
.1a1ade					eval_index
.1a1ade	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a1ae1	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a1ae4	c2 20		rep #$20	            REP #$20
.1a1ae6	a5 23		lda $0823	            LDA ARGUMENT1       ; Save the index to the array index buffer
.1a1ae8	9f 00 4d 00	sta $004d00,x	            STA @l ARRIDXBUF,X
.1a1aec	e2 20		sep #$20	            SEP #$20
.1a1aee	af 00 4d 00	lda $004d00	            LDA @l ARRIDXBUF    ; Increment the index count
.1a1af2	1a		inc a		            INC A
.1a1af3	30 3e		bmi $1a1b33	            BMI arg_err         ; If more than 127 dimensions, throw a range error
.1a1af5	8f 00 4d 00	sta $004d00	            STA @l ARRIDXBUF
.1a1af9	e8		inx		            INX
.1a1afa	e8		inx		            INX
.1a1afb	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a1afe	e2 20		sep #$20	            SEP #$20
.1a1b00	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.1a1b02	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it ")"
.1a1b04	f0 09		beq $1a1b0f	            BEQ clean_op        ; Yes: cleanup the argument stack
.1a1b06	c9 2c		cmp #$2c	            CMP #','            ; Is it a comma?
.1a1b08	d0 0a		bne $1a1b14	            BNE syntax_err      ; No: throw a syntax error
.1a1b0a					skip_comma
.1a1b0a	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a1b0d	80 cf		bra $1a1ade	            BRA eval_index      ; And grab the next index
.1a1b0f					clean_op
.1a1b0f	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a1b12	28		plp		            PLP
.1a1b13	60		rts		            RTS
.1a1b14					syntax_err
.1a1b14	08		php		            PHP
.1a1b15	c2 20		rep #$20	            REP #$20
.1a1b17	48		pha		            PHA
.1a1b18	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1b1b	5b		tcd		            TCD
.1a1b1c	68		pla		            PLA
.1a1b1d	28		plp		            PLP
.1a1b1e	e2 20		sep #$20	            SEP #$20
.1a1b20	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1b22	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1b26	c2 20		rep #$20	            REP #$20
.1a1b28	29 ff 00	and #$00ff	            AND #$00FF
.1a1b2b	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a1b2e	e2 20		sep #$20	            SEP #$20
.1a1b30	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1b33					arg_err
.1a1b33	08		php		            PHP
.1a1b34	c2 20		rep #$20	            REP #$20
.1a1b36	48		pha		            PHA
.1a1b37	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1b3a	5b		tcd		            TCD
.1a1b3b	68		pla		            PLA
.1a1b3c	28		plp		            PLP
.1a1b3d	e2 20		sep #$20	            SEP #$20
.1a1b3f	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a1b41	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1b45	c2 20		rep #$20	            REP #$20
.1a1b47	29 ff 00	and #$00ff	            AND #$00FF
.1a1b4a	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a1b4d	e2 20		sep #$20	            SEP #$20
.1a1b4f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1b52					EVALREF
.1a1b52	08		php		            PHP
.1a1b53					get_name
.1a1b53	20 e5 53	jsr $1a53e5	            JSR VAR_FINDNAME
.1a1b56	90 47		bcc $1a1b9f	            BCC syntax_err      ; If we didn't find a name, thrown an error
.1a1b58	e2 20		sep #$20	            SEP #$20
.1a1b5a	a5 ea		lda $08ea	            LDA TOFINDTYPE      ; Check the type of the variable
.1a1b5c	29 80		and #$80	            AND #$80            ; Is it an array?
.1a1b5e	d0 06		bne $1a1b66	            BNE is_array        ; Yes: look for the indexes
.1a1b60	20 e6 51	jsr $1a51e6	            JSR VAR_REF
.1a1b63	4c 9d 1b	jmp $1a1b9d	            JMP done
.1a1b66					is_array
.1a1b66	20 58 51	jsr $1a5158	            JSR VAR_FIND
.1a1b69	90 53		bcc $1a1bbe	            BCC notfound
.1a1b6b	c2 20		rep #$20	            REP #$20
.1a1b6d	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a1b6f	48		pha		            PHA
.1a1b70	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a1b72	48		pha		            PHA
.1a1b73	a0 09 00	ldy #$0009	            LDY #BINDING.VALUE
.1a1b76	b7 08		lda [$0808],y	            LDA [INDEX],Y       ; Save the pointer to the array to CURRBLOCK
.1a1b78	85 c0		sta $08c0	            STA CURRBLOCK
.1a1b7a	e2 20		sep #$20	            SEP #$20
.1a1b7c	c8		iny		            INY
.1a1b7d	c8		iny		            INY
.1a1b7e	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a1b80	85 c2		sta $08c2	            STA CURRBLOCK+2
.1a1b82	e2 20		sep #$20	            SEP #$20
.1a1b84	a9 8f		lda #$8f	            LDA #TOK_LPAREN
.1a1b86	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a1b89	20 44 1a	jsr $1a1a44	            JSR OPENPARAMS
.1a1b8c					            PHARRIDX
.1a1b8c	20 d2 1a	jsr $1a1ad2	            JSR ARR_GETIDX
.1a1b8f	20 bc 68	jsr $1a68bc	            JSR ARR_REF
.1a1b92					            PLARRIDX
.1a1b92	20 4e 1a	jsr $1a1a4e	            JSR CLOSEPARAMS
.1a1b95	c2 20		rep #$20	            REP #$20
.1a1b97	68		pla		            PLA
.1a1b98	85 c2		sta $08c2	            STA CURRBLOCK+2
.1a1b9a	68		pla		            PLA
.1a1b9b	85 c0		sta $08c0	            STA CURRBLOCK
.1a1b9d	28		plp		done        PLP
.1a1b9e	60		rts		            RTS
.1a1b9f					syntax_err
.1a1b9f	08		php		            PHP
.1a1ba0	c2 20		rep #$20	            REP #$20
.1a1ba2	48		pha		            PHA
.1a1ba3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1ba6	5b		tcd		            TCD
.1a1ba7	68		pla		            PLA
.1a1ba8	28		plp		            PLP
.1a1ba9	e2 20		sep #$20	            SEP #$20
.1a1bab	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1bad	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1bb1	c2 20		rep #$20	            REP #$20
.1a1bb3	29 ff 00	and #$00ff	            AND #$00FF
.1a1bb6	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a1bb9	e2 20		sep #$20	            SEP #$20
.1a1bbb	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1bbe					notfound
.1a1bbe	08		php		            PHP
.1a1bbf	c2 20		rep #$20	            REP #$20
.1a1bc1	48		pha		            PHA
.1a1bc2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1bc5	5b		tcd		            TCD
.1a1bc6	68		pla		            PLA
.1a1bc7	28		plp		            PLP
.1a1bc8	e2 20		sep #$20	            SEP #$20
.1a1bca	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a1bcc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1bd0	c2 20		rep #$20	            REP #$20
.1a1bd2	29 ff 00	and #$00ff	            AND #$00FF
.1a1bd5	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a1bd8	e2 20		sep #$20	            SEP #$20
.1a1bda	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1bdd					EVALSTRING
.1a1bdd	08		php		            PHP
.1a1bde	0b		phd		            PHD
.1a1bdf	08		php		            PHP
.1a1be0	c2 20		rep #$20	            REP #$20
.1a1be2	48		pha		            PHA
.1a1be3	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1be6	5b		tcd		            TCD
.1a1be7	68		pla		            PLA
.1a1be8	28		plp		            PLP
.1a1be9	e2 20		sep #$20	            SEP #$20
.1a1beb	c2 10		rep #$10	            REP #$10
.1a1bed	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a1bf0	a0 00 00	ldy #$0000	            LDY #0              ; Ywill be our length counter
.1a1bf3	b7 00		lda [$0800],y	count_loop  LDA [BIP],Y         ; Get the character
.1a1bf5	f0 24		beq $1a1c1b	            BEQ error           ; If it's end-of-line, throw an error
.1a1bf7	c9 22		cmp #$22	            CMP #CHAR_DQUOTE    ; Is it the ending double-quote?
.1a1bf9	f0 03		beq $1a1bfe	            BEQ found_end       ; Yes: Y should be the length
.1a1bfb	c8		iny		            INY
.1a1bfc	80 f5		bra $1a1bf3	            BRA count_loop
.1a1bfe	84 0c		sty $080c	found_end   STY SCRATCH         ; Save the length to SCRATCH
.1a1c00	e2 20		sep #$20	            SEP #$20
.1a1c02	a9 02		lda #$02	            LDA #TYPE_STRING    ; Set the type to allocate to STRING
.1a1c04	a6 0c		ldx $080c	            LDX SCRATCH         ; And the length to the length of the string literal
.1a1c06	e8		inx		            INX
.1a1c07	20 c6 14	jsr $1a14c6	            JSR TEMPSTRING
.1a1c0a	a0 00 00	ldy #$0000	            LDY #0
.1a1c0d	c4 0c		cpy $080c	copy_loop   CPY SCRATCH         ; Have we copied all the characters?
.1a1c0f	f0 29		beq $1a1c3a	            BEQ done            ; Yes: we're done
.1a1c11	a7 00		lda [$0800]	            LDA [BIP]           ; No: get the next character
.1a1c13	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And copy it to the allocated string
.1a1c15	c8		iny		            INY
.1a1c16	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a1c19	80 f2		bra $1a1c0d	            BRA copy_loop       ; And try the next character
.1a1c1b					error
.1a1c1b	08		php		            PHP
.1a1c1c	c2 20		rep #$20	            REP #$20
.1a1c1e	48		pha		            PHA
.1a1c1f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1c22	5b		tcd		            TCD
.1a1c23	68		pla		            PLA
.1a1c24	28		plp		            PLP
.1a1c25	e2 20		sep #$20	            SEP #$20
.1a1c27	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1c29	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1c2d	c2 20		rep #$20	            REP #$20
.1a1c2f	29 ff 00	and #$00ff	            AND #$00FF
.1a1c32	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a1c35	e2 20		sep #$20	            SEP #$20
.1a1c37	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1c3a	a9 00		lda #$00	done        LDA #0
.1a1c3c	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a1c3e	c2 20		rep #$20	            REP #$20
.1a1c40	a5 16		lda $0816	            LDA STRPTR
.1a1c42	85 23		sta $0823	            STA ARGUMENT1
.1a1c44	a5 18		lda $0818	            LDA STRPTR+2
.1a1c46	85 25		sta $0825	            STA ARGUMENT1+2
.1a1c48	a9 02 00	lda #$0002	            LDA #TYPE_STRING    ; And set the type of ARGUMENT1 to string
.1a1c4b	85 27		sta $0827	            STA ARGTYPE1
.1a1c4d	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a1c50	2b		pld		            PLD
.1a1c51	28		plp		            PLP
.1a1c52	60		rts		            RTS
.1a1c53					EVAL_FUNC
.1a1c53	08		php		            PHP
.1a1c54	e2 20		sep #$20	            SEP #$20
.1a1c56	a7 00		lda [$0800]	            LDA [BIP]           ; Get the token
.1a1c58	c2 20		rep #$20	            REP #$20
.1a1c5a	29 ff 00	and #$00ff	            AND #$00FF
.1a1c5d	20 49 0c	jsr $1a0c49	            JSR TOKEVAL
.1a1c60	85 2f		sta $082f	            STA JMP16PTR
.1a1c62	20 44 1a	jsr $1a1a44	            JSR OPENPARAMS
.1a1c65	08		php		            PHP
.1a1c66	e2 20		sep #$20	            SEP #$20
.1a1c68	48		pha		            PHA
.1a1c69	a9 00		lda #$00	            LDA #0
.1a1c6b	48		pha		            PHA
.1a1c6c	ab		plb		            PLB
.1a1c6d	68		pla		            PLA
.1a1c6e	28		plp		            PLP
.1a1c6f	20 77 1c	jsr $1a1c77	            JSR OPSTUB
.1a1c72	20 4e 1a	jsr $1a1a4e	            JSR CLOSEPARAMS
.1a1c75	28		plp		            PLP
.1a1c76	60		rts		            RTS
.1a1c77					OPSTUB
.1a1c77	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a1c7a	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.1a1c7d					PROCESSOP
.1a1c7d	48		pha		            PHA
.1a1c7e	08		php		            PHP
.1a1c7f	0b		phd		            PHD
.1a1c80	8b		phb		            PHB
.1a1c81	08		php		            PHP
.1a1c82	c2 20		rep #$20	            REP #$20
.1a1c84	48		pha		            PHA
.1a1c85	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1c88	5b		tcd		            TCD
.1a1c89	68		pla		            PLA
.1a1c8a	28		plp		            PLP
.1a1c8b	c2 30		rep #$30	            REP #$30
.1a1c8d	20 16 1a	jsr $1a1a16	            JSR PLOPERATOR
.1a1c90	89 80 00	bit #$0080	            BIT #$80            ; Check if it's really a token
.1a1c93	f0 37		beq $1a1ccc	            BEQ bad_token       ; No: it's a bad token
.1a1c95	48		pha		            PHA
.1a1c96	20 49 0c	jsr $1a0c49	            JSR TOKEVAL
.1a1c99	85 2f		sta $082f	            STA JMP16PTR
.1a1c9b	68		pla		            PLA
.1a1c9c	20 96 0c	jsr $1a0c96	            JSR TOKARITY
.1a1c9f	c9 01 00	cmp #$0001	            CMP #1              ; Check the operator's arity
.1a1ca2	f0 08		beq $1a1cac	            BEQ pull_arg1       ; If it's 1 just pull one argument from the stack
.1a1ca4	c2 30		rep #$30	            REP #$30
.1a1ca6	a2 29 08	ldx #$0829	            LDX #<>ARGUMENT2    ; Pull argument 2 from the stack
.1a1ca9	20 ae 19	jsr $1a19ae	            JSR PLARGUMENT
.1a1cac					pull_arg1
.1a1cac	c2 30		rep #$30	            REP #$30
.1a1cae	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Pull argument 1 from the stack
.1a1cb1	20 ae 19	jsr $1a19ae	            JSR PLARGUMENT
.1a1cb4	08		php		            PHP
.1a1cb5	e2 20		sep #$20	            SEP #$20
.1a1cb7	48		pha		            PHA
.1a1cb8	a9 00		lda #$00	            LDA #0
.1a1cba	48		pha		            PHA
.1a1cbb	ab		plb		            PLB
.1a1cbc	68		pla		            PLA
.1a1cbd	28		plp		            PLP
.1a1cbe	20 ce 1c	jsr $1a1cce	            JSR OPSTUB
.1a1cc1	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Get return result in argument 1
.1a1cc4	20 70 19	jsr $1a1970	            JSR PHARGUMENT
.1a1cc7	ab		plb		            PLB
.1a1cc8	2b		pld		            PLD
.1a1cc9	28		plp		            PLP
.1a1cca	68		pla		            PLA
.1a1ccb	60		rts		            RTS
.1a1ccc	00		brk #		bad_token   BRK
.1a1ccd	ea		nop		            NOP
.1a1cce	6c 2f 08	jmp ($082f)	OPSTUB      JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.1a1cd1					EVALEXPR
.1a1cd1	08		php		            PHP
.1a1cd2	08		php		            PHP
.1a1cd3	c2 20		rep #$20	            REP #$20
.1a1cd5	48		pha		            PHA
.1a1cd6	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1cd9	5b		tcd		            TCD
.1a1cda	68		pla		            PLA
.1a1cdb	28		plp		            PLP
.1a1cdc	08		php		            PHP
.1a1cdd	e2 20		sep #$20	            SEP #$20
.1a1cdf	48		pha		            PHA
.1a1ce0	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1ce2	48		pha		            PHA
.1a1ce3	ab		plb		            PLB
.1a1ce4	68		pla		            PLA
.1a1ce5	28		plp		            PLP
.1a1ce6	c2 10		rep #$10	            REP #$10
.1a1ce8	da		phx		            PHX
.1a1ce9					get_char
.1a1ce9	e2 20		sep #$20	            SEP #$20
.1a1ceb	a7 00		lda [$0800]	            LDA [BIP]           ; Get the character
.1a1ced	d0 03		bne $1a1cf2	            BNE else1
.1a1cef	4c 94 1d	jmp $1a1d94	            JMP proc_stack      ; Handle end of line, if we see it
.1a1cf2	30 33		bmi $1a1d27	else1       BMI is_token        ; If MSB is set, it's a token
.1a1cf4	c9 20		cmp #$20	            CMP #' '            ; Is it a space?
.1a1cf6	d0 03		bne $1a1cfb	            BNE else2
.1a1cf8	4c 8e 1d	jmp $1a1d8e	            JMP next_char       ; Yes: Skip to the next character
.1a1cfb	c9 3a		cmp #$3a	else2       CMP #'9'+1          ; Check to see if we have digits
.1a1cfd	b0 04		bcs $1a1d03	            BCS else3           ; No: treat as the end of the line
.1a1cff	c9 30		cmp #$30	            CMP #'0'
.1a1d01	b0 56		bcs $1a1d59	            BCS is_digit
.1a1d03	c9 26		cmp #$26	else3       CMP #'&'            ; Check for a hexadecimal prefix
.1a1d05	f0 52		beq $1a1d59	            BEQ is_digit
.1a1d07	c9 22		cmp #$22	            CMP #'"'            ; Is it a double-quote?
.1a1d09	d0 03		bne $1a1d0e	            BNE else4
.1a1d0b	4c a7 1d	jmp $1a1da7	            JMP is_string       ; Yes: process the string
.1a1d0e	c9 5b		cmp #$5b	else4       CMP #'Z'+1          ; Check to see if we have upper case alphabetics
.1a1d10	b0 07		bcs $1a1d19	            BCS check_lc        ; No: check for lower case
.1a1d12	c9 41		cmp #$41	            CMP #'A'
.1a1d14	90 03		bcc $1a1d19	            BCC check_lc
.1a1d16	4c b3 1d	jmp $1a1db3	            JMP is_alpha
.1a1d19	c9 7b		cmp #$7b	check_lc    CMP #'z'+1          ; Check to see if we have lower case alphabetics
.1a1d1b	b0 07		bcs $1a1d24	            BCS else5           ; No: treat as the end of the line
.1a1d1d	c9 61		cmp #$61	            CMP #'a'
.1a1d1f	90 03		bcc $1a1d24	            BCC else5
.1a1d21	4c b3 1d	jmp $1a1db3	            JMP is_alpha
.1a1d24	4c 94 1d	jmp $1a1d94	else5       JMP proc_stack
.1a1d27	c9 8f		cmp #$8f	is_token    CMP #TOK_LPAREN     ; Is it an LPAREN
.1a1d29	f0 40		beq $1a1d6b	            BEQ is_lparen       ; Yes: handle the LPAREN
.1a1d2b	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it an RPAREN?
.1a1d2d	f0 41		beq $1a1d70	            BEQ is_rparen       ; Yes: handle the RPAREN
.1a1d2f	20 6c 0c	jsr $1a0c6c	            JSR TOKTYPE
.1a1d32	c9 30		cmp #$30	            CMP #TOK_TY_FUNC    ; Is it a function?
.1a1d34	d0 0c		bne $1a1d42	            BNE chk_op          ; No: check if it's an operator
.1a1d36	20 53 1c	jsr $1a1c53	            JSR EVAL_FUNC
.1a1d39	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.1a1d3c	20 70 19	jsr $1a1970	            JSR PHARGUMENT
.1a1d3f	4c e9 1c	jmp $1a1ce9	            JMP get_char
.1a1d42	c9 00		cmp #$00	chk_op      CMP #TOK_TY_OP      ; Is it an operator?
.1a1d44	d0 4e		bne $1a1d94	            BNE proc_stack      ; No: we're finished processing
.1a1d46	a7 00		lda [$0800]	            LDA [BIP]           ; Yes: Get the token back
.1a1d48	a6 21		ldx $0821	chk_prec    LDX OPERATORSP      ; Is the operator stack empty?
.1a1d4a	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.1a1d4d	f0 05		beq $1a1d54	            BEQ push_op         ; Yes: push the operator
.1a1d4f	20 8d 1a	jsr $1a1a8d	            JSR OPHIGHPREC
.1a1d52	b0 12		bcs $1a1d66	            BCS process1        ; No: we should process the top operator
.1a1d54					push_op
.1a1d54	20 ed 19	jsr $1a19ed	            JSR PHOPERATOR
.1a1d57	80 35		bra $1a1d8e	            BRA next_char       ; And go to the next character
.1a1d59					is_digit
.1a1d59	c2 20		rep #$20	            REP #$20
.1a1d5b	20 07 5a	jsr $1a5a07	            JSR PARSENUM
.1a1d5e	a2 23 08	ldx #$0823	got_number  LDX #<>ARGUMENT1
.1a1d61	20 70 19	jsr $1a1970	            JSR PHARGUMENT
.1a1d64	80 83		bra $1a1ce9	            BRA get_char
.1a1d66					process1
.1a1d66	20 7d 1c	jsr $1a1c7d	            JSR PROCESSOP
.1a1d69	80 dd		bra $1a1d48	            BRA chk_prec        ; And check what to do with the current operator
.1a1d6b					is_lparen
.1a1d6b	20 ed 19	jsr $1a19ed	            JSR PHOPERATOR
.1a1d6e	80 1e		bra $1a1d8e	            BRA next_char
.1a1d70					is_rparen
.1a1d70	e2 20		sep #$20	            SEP #$20
.1a1d72	a4 21		ldy $0821	            LDY OPERATORSP      ; Is the operator stack empty?
.1a1d74	c0 ff 7f	cpy #$7fff	            CPY #<>OPERATOR_TOP
.1a1d77	f0 46		beq $1a1dbf	            BEQ done            ; Yes: we're done evaluating things
.1a1d79	a4 21		ldy $0821	paren_loop  LDY OPERATORSP      ; Peek at the top operator
.1a1d7b	b9 01 00	lda $0001,y	            LDA #1,B,Y
.1a1d7e	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the LPAREN of a function?
.1a1d80	f0 3d		beq $1a1dbf	            BEQ done            ; Yes: treat it as an empty stack
.1a1d82	c9 8f		cmp #$8f	            CMP #TOK_LPAREN     ; Is it an LPAREN?
.1a1d84	f0 05		beq $1a1d8b	            BEQ done_rparen     ; Yes: we're finished processing
.1a1d86	20 7d 1c	jsr $1a1c7d	            JSR PROCESSOP
.1a1d89	80 ee		bra $1a1d79	            BRA paren_loop
.1a1d8b					done_rparen
.1a1d8b	20 16 1a	jsr $1a1a16	            JSR PLOPERATOR
.1a1d8e					next_char
.1a1d8e	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a1d91	4c e9 1c	jmp $1a1ce9	            JMP get_char
.1a1d94					proc_stack
.1a1d94	a6 21		ldx $0821	            LDX OPERATORSP      ; Is the operator stack empty?
.1a1d96	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.1a1d99	b0 24		bcs $1a1dbf	            BGE done            ; Yes: return to the caller
.1a1d9b	bd 01 00	lda $0001,x	            LDA #1,B,X
.1a1d9e	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is top operator a function open?
.1a1da0	f0 1d		beq $1a1dbf	            BEQ done            ; Yes: treat as end of expression
.1a1da2	20 7d 1c	jsr $1a1c7d	            JSR PROCESSOP
.1a1da5	80 ed		bra $1a1d94	            BRA proc_stack
.1a1da7					is_string
.1a1da7	20 dd 1b	jsr $1a1bdd	            JSR EVALSTRING
.1a1daa	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.1a1dad	20 70 19	jsr $1a1970	            JSR PHARGUMENT
.1a1db0	4c e9 1c	jmp $1a1ce9	            JMP get_char
.1a1db3					is_alpha
.1a1db3	20 52 1b	jsr $1a1b52	            JSR EVALREF
.1a1db6	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.1a1db9	20 70 19	jsr $1a1970	            JSR PHARGUMENT
.1a1dbc	4c e9 1c	jmp $1a1ce9	            JMP get_char
.1a1dbf	a2 23 08	ldx #$0823	done        LDX #<>ARGUMENT1    ; Make sure the result is off the stack
.1a1dc2	20 ae 19	jsr $1a19ae	            JSR PLARGUMENT
.1a1dc5					real_done
.1a1dc5	fa		plx		            PLX
.1a1dc6	28		plp		            PLP
.1a1dc7	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\returnstack.s

.1a1dc8					INITRETURN
.1a1dc8	08		php		                PHP
.1a1dc9	0b		phd		                PHD
.1a1dca	8b		phb		                PHB
.1a1dcb	08		php		            PHP
.1a1dcc	e2 20		sep #$20	            SEP #$20
.1a1dce	48		pha		            PHA
.1a1dcf	a9 00		lda #$00	            LDA #0
.1a1dd1	48		pha		            PHA
.1a1dd2	ab		plb		            PLB
.1a1dd3	68		pla		            PLA
.1a1dd4	28		plp		            PLP
.1a1dd5	08		php		            PHP
.1a1dd6	c2 20		rep #$20	            REP #$20
.1a1dd8	48		pha		            PHA
.1a1dd9	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1ddc	5b		tcd		            TCD
.1a1ddd	68		pla		            PLA
.1a1dde	28		plp		            PLP
.1a1ddf	c2 30		rep #$30	            REP #$30
.1a1de1	a9 fd 5f	lda #$5ffd	                LDA #RETURN_TOP-2
.1a1de4	85 33		sta $0833	                STA RETURNSP
.1a1de6	ab		plb		                PLB
.1a1de7	2b		pld		                PLD
.1a1de8	28		plp		                PLP
.1a1de9	60		rts		            RTS
.1a1dea					PHRETURN
.1a1dea	08		php		                PHP
.1a1deb	0b		phd		                PHD
.1a1dec	08		php		            PHP
.1a1ded	c2 20		rep #$20	            REP #$20
.1a1def	48		pha		            PHA
.1a1df0	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1df3	5b		tcd		            TCD
.1a1df4	68		pla		            PLA
.1a1df5	28		plp		            PLP
.1a1df6	c2 30		rep #$30	            REP #$30
.1a1df8	92 33		sta ($0833)	                STA (RETURNSP)
.1a1dfa	c6 33		dec $0833	                DEC RETURNSP
.1a1dfc	c6 33		dec $0833	                DEC RETURNSP
.1a1dfe	2b		pld		                PLD
.1a1dff	28		plp		                PLP
.1a1e00	60		rts		            RTS
.1a1e01					PHRETURNB
.1a1e01	08		php		                PHP
.1a1e02	c2 30		rep #$30	            REP #$30
.1a1e04	29 ff 00	and #$00ff	                AND #$00FF
.1a1e07	20 ea 1d	jsr $1a1dea	            JSR PHRETURN
.1a1e0a	28		plp		                PLP
.1a1e0b	60		rts		            RTS
.1a1e0c					PLRETURN
.1a1e0c	08		php		                PHP
.1a1e0d	0b		phd		                PHD
.1a1e0e	08		php		            PHP
.1a1e0f	c2 20		rep #$20	            REP #$20
.1a1e11	48		pha		            PHA
.1a1e12	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1e15	5b		tcd		            TCD
.1a1e16	68		pla		            PLA
.1a1e17	28		plp		            PLP
.1a1e18	c2 30		rep #$30	            REP #$30
.1a1e1a	e6 33		inc $0833	                INC RETURNSP
.1a1e1c	e6 33		inc $0833	                INC RETURNSP
.1a1e1e	b2 33		lda ($0833)	                LDA (RETURNSP)
.1a1e20	2b		pld		                PLD
.1a1e21	28		plp		                PLP
.1a1e22	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\interpreter.s

=$80					ST_RUNNING = $80            ; The interpreter is running a full program
=$00					ST_INTERACT = $00           ; The interpreter is in interactive mode
>08d2					STATE       .byte ?         ; The state of the interpreter ()
>08d3					ERROR_NUM   .byte ?         ; The type of the error
>08d4					HANDLEERR   .long ?         ; Pointer to the error handler
>08d7					LINENUM     .word ?         ; The current line number
>08d9					LASTLINE    .long ?         ; Pointer to the next free space over the BASIC program
>08dc					EXECACTION  .byte ?         ; The action the exection routines should take to get their next statement
=0					LINE_LINK = 0               ; Offset to the link to the next line
=2					LINE_NUMBER = 2             ; Offset to the line number
=4					LINE_TOKENS = 4             ; Offset to the first token
=6					LINE_MINLEN = 6             ; Minimum length of a line
=0					EXEC_CONT = 0               ; Continue advancing the current line
=1					EXEC_STOP = 1               ; Stop execution of the program
=2					EXEC_GOTO = 2               ; Transfer execution to a new CURLINE that is already set
=3					EXEC_RETURN = 3             ; Transfer execution back to a line that was on the stack
.1a1e23					SET_ERRERL
.1a1e23	8b		phb		                PHB
.1a1e24	0b		phd		                PHD
.1a1e25	08		php		                PHP
.1a1e26	08		php		            PHP
.1a1e27	c2 20		rep #$20	            REP #$20
.1a1e29	48		pha		            PHA
.1a1e2a	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1e2d	5b		tcd		            TCD
.1a1e2e	68		pla		            PLA
.1a1e2f	28		plp		            PLP
.1a1e30	08		php		            PHP
.1a1e31	e2 20		sep #$20	            SEP #$20
.1a1e33	48		pha		            PHA
.1a1e34	a9 00		lda #$00	            LDA #BASIC_BANK
.1a1e36	48		pha		            PHA
.1a1e37	ab		plb		            PLB
.1a1e38	68		pla		            PLA
.1a1e39	28		plp		            PLP
.1a1e3a	c2 20		rep #$20	            REP #$20
.1a1e3c	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.1a1e3e	a9 00 00	lda #$0000	                LDA #0
.1a1e41	85 25		sta $0825	                STA ARGUMENT1+2
.1a1e43	e2 20		sep #$20	            SEP #$20
.1a1e45	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a1e47	85 27		sta $0827	                STA ARGTYPE1
.1a1e49	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.1a1e4b	a9 1a		lda #$1a	                LDA #`err_name
.1a1e4d	85 e9		sta $08e9	                STA TOFIND+2
.1a1e4f	c2 20		rep #$20	            REP #$20
.1a1e51	a9 7d 1e	lda #$1e7d	                LDA #<>err_name
.1a1e54	85 e7		sta $08e7	                STA TOFIND
.1a1e56	20 48 53	jsr $1a5348	            JSR VAR_SET
.1a1e59	c2 20		rep #$20	            REP #$20
.1a1e5b	a5 d7		lda $08d7	                LDA LINENUM
.1a1e5d	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.1a1e5f	a5 d9		lda $08d9	                LDA LINENUM+2
.1a1e61	85 25		sta $0825	                STA ARGUMENT1+2
.1a1e63	e2 20		sep #$20	            SEP #$20
.1a1e65	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a1e67	85 27		sta $0827	                STA ARGTYPE1
.1a1e69	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.1a1e6b	a9 1a		lda #$1a	                LDA #`erl_name
.1a1e6d	85 e9		sta $08e9	                STA TOFIND+2
.1a1e6f	c2 20		rep #$20	            REP #$20
.1a1e71	a9 81 1e	lda #$1e81	                LDA #<>erl_name
.1a1e74	85 e7		sta $08e7	                STA TOFIND
.1a1e76	20 48 53	jsr $1a5348	            JSR VAR_SET
.1a1e79	28		plp		                PLP
.1a1e7a	2b		pld		                PLD
.1a1e7b	ab		plb		                PLB
.1a1e7c	60		rts		            RTS
>1a1e7d	45 52 52 00			err_name        .null "ERR"
>1a1e81	45 52 4c 00			erl_name        .null "ERL"
.1a1e85					ON_ERROR
.1a1e85	e2 20		sep #$20	            SEP #$20
.1a1e87	c2 10		rep #$10	            REP #$10
.1a1e89	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a1e8c	af d3 08 00	lda $0008d3	            LDA @lERROR_NUM         ; Calculate index to the error message pointer
.1a1e90	0a		asl a		            ASL A
.1a1e91	c2 20		rep #$20	            REP #$20
.1a1e93	29 ff 00	and #$00ff	            AND #$00FF
.1a1e96	a8		tay		            TAY
.1a1e97	08		php		            PHP
.1a1e98	e2 20		sep #$20	            SEP #$20
.1a1e9a	48		pha		            PHA
.1a1e9b	a9 1a		lda #$1a	            LDA #`ERRORMSG
.1a1e9d	48		pha		            PHA
.1a1e9e	ab		plb		            PLB
.1a1e9f	68		pla		            PLA
.1a1ea0	28		plp		            PLP
.1a1ea1	be d7 1e	ldx $1a1ed7,y	            LDX ERRORMSG,Y
.1a1ea4	20 29 04	jsr $1a0429	            JSR PRINTS
.1a1ea7	c2 20		rep #$20	            REP #$20
.1a1ea9	a5 d7		lda $08d7	            LDA LINENUM
.1a1eab	f0 27		beq $1a1ed4	            BEQ skip_at
.1a1ead	a2 07 1f	ldx #$1f07	            LDX #<>MSG_AT           ; If so... print " AT "
.1a1eb0	20 29 04	jsr $1a0429	            JSR PRINTS
.1a1eb3	08		php		            PHP
.1a1eb4	e2 20		sep #$20	            SEP #$20
.1a1eb6	48		pha		            PHA
.1a1eb7	a9 00		lda #$00	            LDA #BASIC_BANK
.1a1eb9	48		pha		            PHA
.1a1eba	ab		plb		            PLB
.1a1ebb	68		pla		            PLA
.1a1ebc	28		plp		            PLP
.1a1ebd	c2 20		rep #$20	            REP #$20
.1a1ebf	af d7 08 00	lda $0008d7	            LDA @lLINENUM           ; ... and then the line number
.1a1ec3	8f 23 08 00	sta $000823	            STA @lARGUMENT1
.1a1ec7	a9 00 00	lda #$0000	            LDA #0
.1a1eca	8f 25 08 00	sta $000825	            STA @lARGUMENT1+2
.1a1ece	20 e3 45	jsr $1a45e3	            JSR PR_INTEGER
.1a1ed1	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a1ed4					skip_at
.1a1ed4	4c 85 27	jmp $1a2785	            JMP INTERACT
>1a1ed7	0b 1f				ERRORMSG    .word <>MSG_OK
>1a1ed9	0e 1f				            .word <>MSG_BREAK
>1a1edb	14 1f				            .word <>MSG_SYNTAX
>1a1edd	21 1f				            .word <>MSG_MEMORY
>1a1edf	2f 1f				            .word <>MSG_TYPE
>1a1ee1	3d 1f				            .word <>MSG_NOTFND
>1a1ee3	50 1f				            .word <>MSG_NOLINE
>1a1ee5	66 1f				            .word <>MSG_UNDFLOW
>1a1ee7	76 1f				            .word <>MSG_OVRFLOW
>1a1ee9	85 1f				            .word <>MSG_RANGE
>1a1eeb	92 1f				            .word <>MSG_ARG
>1a1eed	a3 1f				            .word <>MSG_NOFILE
>1a1eef	b2 1f				            .word <>MSG_NAN
>1a1ef1	bf 1f				            .word <>MSG_OVERFLOW
>1a1ef3	cd 1f				            .word <>MSG_UNDERFLOW
>1a1ef5	dc 1f				            .word <>MSG_DIV0
>1a1ef7	ed 1f				            .word <>MSG_DIRECTORY
>1a1ef9	06 20				            .word <>MSG_LOAD
>1a1efb	1a 20				            .word <>MSG_SAVE
>1a1efd	2e 20				            .word <>MSG_DELETE
>1a1eff	44 20				            .word <>MSG_FILENOTFND
>1a1f01	58 20				            .word <>MSG_DIRNOTWRITE
>1a1f03	73 20				            .word <>MSG_NOTCOPIED
>1a1f05	8b 20				            .word <>MSG_DOMAIN
>1a1f07	20 61 74 00			MSG_AT          .null " at"
>1a1f0b	4f 4b 00			MSG_OK          .null "OK"
>1a1f0e	42 72 65 61 6b 00		MSG_BREAK       .null "Break"
>1a1f14	53 79 6e 74 61 78 20 65		MSG_SYNTAX      .null "Syntax error"
>1a1f1c	72 72 6f 72 00
>1a1f21	4f 75 74 20 6f 66 20 6d		MSG_MEMORY      .null "Out of memory"
>1a1f29	65 6d 6f 72 79 00
>1a1f2f	54 79 70 65 20 6d 69 73		MSG_TYPE        .null "Type mismatch"
>1a1f37	6d 61 74 63 68 00
>1a1f3d	56 61 72 69 61 62 6c 65		MSG_NOTFND      .null "Variable not found"
>1a1f45	20 6e 6f 74 20 66 6f 75 6e 64 00
>1a1f50	4c 69 6e 65 20 6e 75 6d		MSG_NOLINE      .null "Line number not found"
>1a1f58	62 65 72 20 6e 6f 74 20 66 6f 75 6e 64 00
>1a1f66	53 74 61 63 6b 20 75 6e		MSG_UNDFLOW     .null "Stack underflow"
>1a1f6e	64 65 72 66 6c 6f 77 00
>1a1f76	53 74 61 63 6b 20 6f 76		MSG_OVRFLOW     .null "Stack overflow"
>1a1f7e	65 72 66 6c 6f 77 00
>1a1f85	4f 75 74 20 6f 66 20 72		MSG_RANGE       .null "Out of range"
>1a1f8d	61 6e 67 65 00
>1a1f92	49 6c 6c 65 67 61 6c 20		MSG_ARG         .null "Illegal argument"
>1a1f9a	61 72 67 75 6d 65 6e 74 00
>1a1fa3	46 69 6c 65 20 6e 6f 74		MSG_NOFILE      .null "File not found"
>1a1fab	20 66 6f 75 6e 64 00
>1a1fb2	4e 6f 74 20 61 20 6e 75		MSG_NAN         .null "Not a number"
>1a1fba	6d 62 65 72 00
>1a1fbf	4d 61 74 68 20 6f 76 65		MSG_OVERFLOW    .null "Math overflow"
>1a1fc7	72 66 6c 6f 77 00
>1a1fcd	4d 61 74 68 20 75 6e 64		MSG_UNDERFLOW   .null "Math underflow"
>1a1fd5	65 72 66 6c 6f 77 00
>1a1fdc	44 69 76 69 73 69 6f 6e		MSG_DIV0        .null "Division by zero"
>1a1fe4	20 62 79 20 7a 65 72 6f 00
>1a1fed	55 6e 61 62 6c 65 20 74		MSG_DIRECTORY   .null "Unable to read directory"
>1a1ff5	6f 20 72 65 61 64 20 64 69 72 65 63 74 6f 72 79
>1a2005	00
>1a2006	55 6e 61 62 6c 65 20 74		MSG_LOAD        .null "Unable to load file"
>1a200e	6f 20 6c 6f 61 64 20 66 69 6c 65 00
>1a201a	55 6e 61 62 6c 65 20 74		MSG_SAVE        .null "Unable to save file"
>1a2022	6f 20 73 61 76 65 20 66 69 6c 65 00
>1a202e	55 6e 61 62 6c 65 20 74		MSG_DELETE      .null "Unable to delete file"
>1a2036	6f 20 64 65 6c 65 74 65 20 66 69 6c 65 00
>1a2044	43 6f 75 6c 64 20 6e 6f		MSG_FILENOTFND  .null "Could not find file"
>1a204c	74 20 66 69 6e 64 20 66 69 6c 65 00
>1a2058	43 6f 75 6c 64 20 6e 6f		MSG_DIRNOTWRITE .null "Could not update directory"
>1a2060	74 20 75 70 64 61 74 65 20 64 69 72 65 63 74 6f
>1a2070	72 79 00
>1a2073	43 6f 75 6c 64 20 6e 6f		MSG_NOTCOPIED   .null "Could not copy the file"
>1a207b	74 20 63 6f 70 79 20 74 68 65 20 66 69 6c 65 00
>1a208b	41 72 67 75 6d 65 6e 74		MSG_DOMAIN      .null "Argument outside domain"
>1a2093	20 6f 75 74 73 69 64 65 20 64 6f 6d 61 69 6e 00
.1a20a3					SETINTERACT
.1a20a3	08		php		            PHP
.1a20a4	0b		phd		            PHD
.1a20a5	08		php		            PHP
.1a20a6	c2 20		rep #$20	            REP #$20
.1a20a8	48		pha		            PHA
.1a20a9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a20ac	5b		tcd		            TCD
.1a20ad	68		pla		            PLA
.1a20ae	28		plp		            PLP
.1a20af	e2 20		sep #$20	            SEP #$20
.1a20b1	a9 00		lda #$00	            LDA #ST_INTERACT
.1a20b3	85 d2		sta $08d2	            STA STATE
.1a20b5	2b		pld		            PLD
.1a20b6	28		plp		            PLP
.1a20b7	60		rts		            RTS
.1a20b8					CLRINTERP
.1a20b8	0b		phd		            PHD
.1a20b9	08		php		            PHP
.1a20ba	08		php		            PHP
.1a20bb	c2 20		rep #$20	            REP #$20
.1a20bd	48		pha		            PHA
.1a20be	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a20c1	5b		tcd		            TCD
.1a20c2	68		pla		            PLA
.1a20c3	28		plp		            PLP
.1a20c4	08		php		            PHP
.1a20c5	c2 20		rep #$20	            REP #$20
.1a20c7	a9 85 1e	lda #$1e85	            LDA #<>ON_ERROR
.1a20ca	8f d4 08 00	sta $0008d4	            STA @lHANDLEERR
.1a20ce	e2 20		sep #$20	            SEP #$20
.1a20d0	a9 1a		lda #$1a	            LDA #`ON_ERROR
.1a20d2	8f d6 08 00	sta $0008d6	            STA @lHANDLEERR+2
.1a20d6	28		plp		            PLP
.1a20d7	20 8a 44	jsr $1a448a	            JSR S_CLR
.1a20da	20 cb 3f	jsr $1a3fcb	            JSR S_RESTORE
.1a20dd	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the depth of the GOSUB stack
.1a20df	28		plp		            PLP
.1a20e0	2b		pld		            PLD
.1a20e1	60		rts		            RTS
.1a20e2					INCBIP
.1a20e2	08		php		            PHP
.1a20e3	0b		phd		            PHD
.1a20e4	08		php		            PHP
.1a20e5	c2 20		rep #$20	            REP #$20
.1a20e7	48		pha		            PHA
.1a20e8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a20eb	5b		tcd		            TCD
.1a20ec	68		pla		            PLA
.1a20ed	28		plp		            PLP
.1a20ee	c2 20		rep #$20	            REP #$20
.1a20f0	18		clc		            CLC
.1a20f1	a5 00		lda $0800	            LDA BIP
.1a20f3	69 01 00	adc #$0001	            ADC #1
.1a20f6	85 00		sta $0800	            STA BIP
.1a20f8	e2 20		sep #$20	            SEP #$20
.1a20fa	a5 02		lda $0802	            LDA BIP+2
.1a20fc	69 00		adc #$00	            ADC #0
.1a20fe	85 02		sta $0802	            STA BIP+2
.1a2100	2b		pld		            PLD
.1a2101	28		plp		            PLP
.1a2102	60		rts		            RTS
.1a2103					SKIPWS
.1a2103	08		php		            PHP
.1a2104	0b		phd		            PHD
.1a2105	08		php		            PHP
.1a2106	c2 20		rep #$20	            REP #$20
.1a2108	48		pha		            PHA
.1a2109	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a210c	5b		tcd		            TCD
.1a210d	68		pla		            PLA
.1a210e	28		plp		            PLP
.1a210f	e2 20		sep #$20	            SEP #$20
.1a2111	a7 00		lda [$0800]	loop        LDA [BIP]
.1a2113	f0 0f		beq $1a2124	            BEQ done            ; If character is 0, we've reached the end of the line
.1a2115	c9 20		cmp #$20	            CMP #CHAR_SP        ; Skip if it's a space
.1a2117	f0 06		beq $1a211f	            BEQ skip_char
.1a2119	c9 09		cmp #$09	            CMP #CHAR_TAB       ; Skip if it's a TAB
.1a211b	f0 02		beq $1a211f	            BEQ skip_char
.1a211d	80 05		bra $1a2124	            BRA done            ; Otherwise, we're done and BIP points to a non-whitespace
.1a211f					skip_char
.1a211f	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a2122	80 ed		bra $1a2111	            BRA loop
.1a2124	2b		pld		done        PLD
.1a2125	28		plp		            PLP
.1a2126	60		rts		            RTS
.1a2127					SKIPSTMT
.1a2127	08		php		            PHP
.1a2128	e2 20		sep #$20	            SEP #$20
.1a212a	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the current character
.1a212c	f0 09		beq $1a2137	            BEQ done            ; Is it EOL? Yes, we're done
.1a212e	c9 3a		cmp #$3a	            CMP #':'            ; Is it a colon?
.1a2130	f0 05		beq $1a2137	            BEQ done            ; Yes, we're done
.1a2132	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a2135	80 f3		bra $1a212a	            BRA loop            ; and check it...
.1a2137	28		plp		done        PLP
.1a2138	60		rts		            RTS
.1a2139					SKIPTOTOK
.1a2139	08		php		            PHP
.1a213a	e2 20		sep #$20	            SEP #$20
.1a213c	64 36		stz $0836	            STZ NESTING
.1a213e	a7 00		lda [$0800]	loop        LDA [BIP]           ; Get the character
.1a2140	f0 19		beq $1a215b	            BEQ end_of_line     ; EOL? Yes: move to the next line
.1a2142	c5 37		cmp $0837	            CMP TARGETTOK       ; Is it the one we want?
.1a2144	f0 2c		beq $1a2172	            BEQ check_depth     ; Yes: check the depth
.1a2146	c9 9b		cmp #$9b	            CMP #TOK_FOR        ; Is it a FOR?
.1a2148	f0 1e		beq $1a2168	            BEQ inc_nesting     ; Yes: increment NESTING
.1a214a	c9 9f		cmp #$9f	            CMP #TOK_DO         ; Is it a DO?
.1a214c	f0 1a		beq $1a2168	            BEQ inc_nesting     ; Yes: increment NESTING
.1a214e	c9 9e		cmp #$9e	            CMP #TOK_NEXT       ; Is it a NEXT?
.1a2150	f0 1a		beq $1a216c	            BEQ dec_nesting     ; Yes: decrement NESTING
.1a2152	c9 a0		cmp #$a0	            CMP #TOK_LOOP       ; Is it a LOOP?
.1a2154	f0 16		beq $1a216c	            BEQ dec_nesting     ; Yes: decrement NESTING
.1a2156					incloop
.1a2156	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a2159	80 e3		bra $1a213e	            BRA loop            ; and keep scanning
.1a215b					end_of_line
.1a215b	20 bf 21	jsr $1a21bf	            JSR NEXTLINE
.1a215e	c2 20		rep #$20	            REP #$20
.1a2160	a5 d7		lda $08d7	            LDA LINENUM         ; Check the line number
.1a2162	f0 1d		beq $1a2181	            BEQ syntax_err1     ; If it's zero, we reached the end of the program
.1a2164	e2 20		sep #$20	            SEP #$20
.1a2166	80 d6		bra $1a213e	            BRA loop            ; And keep scanning
.1a2168					inc_nesting
.1a2168	e6 36		inc $0836	            INC NESTING         ; Track that we have entered a lexical scope for a FOR/DO
.1a216a	80 ea		bra $1a2156	            BRA incloop
.1a216c					dec_nesting
.1a216c	c6 36		dec $0836	            DEC NESTING         ; Track that we have left a lexical scope for a FOR/DO
.1a216e	30 30		bmi $1a21a0	            BMI syntax_err2     ; If the depth goes <0, throw a syntax error
.1a2170	80 e4		bra $1a2156	            BRA incloop
.1a2172					check_depth
.1a2172	a5 35		lda $0835	            LDA SKIPNEST        ; Check to see if nesting matters
.1a2174	30 06		bmi $1a217c	            BMI found           ; No: just return that we found the token
.1a2176	a5 36		lda $0836	            LDA NESTING         ; Get the nesting depth
.1a2178	f0 02		beq $1a217c	            BEQ found           ; If it's zero, we found our token
.1a217a	80 da		bra $1a2156	            BRA incloop         ; Otherwise: it's a token for an enclosed FOR/DO, keep scanning
.1a217c					found
.1a217c	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a217f	28		plp		            PLP
.1a2180	60		rts		            RTS
.1a2181					syntax_err1
.1a2181	08		php		            PHP
.1a2182	c2 20		rep #$20	            REP #$20
.1a2184	48		pha		            PHA
.1a2185	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2188	5b		tcd		            TCD
.1a2189	68		pla		            PLA
.1a218a	28		plp		            PLP
.1a218b	e2 20		sep #$20	            SEP #$20
.1a218d	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a218f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2193	c2 20		rep #$20	            REP #$20
.1a2195	29 ff 00	and #$00ff	            AND #$00FF
.1a2198	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a219b	e2 20		sep #$20	            SEP #$20
.1a219d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a21a0					syntax_err2
.1a21a0	08		php		            PHP
.1a21a1	c2 20		rep #$20	            REP #$20
.1a21a3	48		pha		            PHA
.1a21a4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a21a7	5b		tcd		            TCD
.1a21a8	68		pla		            PLA
.1a21a9	28		plp		            PLP
.1a21aa	e2 20		sep #$20	            SEP #$20
.1a21ac	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a21ae	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a21b2	c2 20		rep #$20	            REP #$20
.1a21b4	29 ff 00	and #$00ff	            AND #$00FF
.1a21b7	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a21ba	e2 20		sep #$20	            SEP #$20
.1a21bc	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a21bf					NEXTLINE
.1a21bf	08		php		            PHP
.1a21c0	c2 30		rep #$30	            REP #$30
.1a21c2	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a21c5	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the offset to the next line
.1a21c7	85 0c		sta $080c	            STA SCRATCH
.1a21c9	18		clc		            CLC                 ; Compute the new CURLINE
.1a21ca	a5 1a		lda $081a	            LDA CURLINE         ; CURLINE := [CURLINE].LINE_LINK
.1a21cc	65 0c		adc $080c	            ADC SCRATCH
.1a21ce	85 1a		sta $081a	            STA CURLINE
.1a21d0	a5 1c		lda $081c	            LDA CURLINE+2
.1a21d2	69 00 00	adc #$0000	            ADC #0
.1a21d5	85 1c		sta $081c	            STA CURLINE+2
.1a21d7	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the LINENUM to the new current line's number
.1a21da	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; LINENUM := [CURLINE].LINE_NUMBER
.1a21dc	85 d7		sta $08d7	            STA LINENUM
.1a21de	18		clc		            CLC                 ; Point BIP to the first character of the line
.1a21df	a5 1a		lda $081a	            LDA CURLINE         ; BIP := CURLINE + LINE_TOKENS
.1a21e1	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a21e4	85 00		sta $0800	            STA BIP
.1a21e6	a5 1c		lda $081c	            LDA CURLINE+2
.1a21e8	69 00 00	adc #$0000	            ADC #0
.1a21eb	85 02		sta $0802	            STA BIP+2
.1a21ed	28		plp		            PLP
.1a21ee	60		rts		            RTS
.1a21ef					EXPECT_TOK
.1a21ef	08		php		            PHP
.1a21f0	e2 20		sep #$20	            SEP #$20
.1a21f2	48		pha		            PHA
.1a21f3	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a21f6	68		pla		            PLA
.1a21f7	e2 20		sep #$20	            SEP #$20
.1a21f9	c7 00		cmp [$0800]	            CMP [BIP]           ; Check the character at BIP
.1a21fb	d0 08		bne $1a2205	            BNE syntax_err      ; Throw a syntax error
.1a21fd	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a2200	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a2203	28		plp		            PLP
.1a2204	60		rts		            RTS
.1a2205					syntax_err
.1a2205	08		php		            PHP
.1a2206	c2 20		rep #$20	            REP #$20
.1a2208	48		pha		            PHA
.1a2209	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a220c	5b		tcd		            TCD
.1a220d	68		pla		            PLA
.1a220e	28		plp		            PLP
.1a220f	e2 20		sep #$20	            SEP #$20
.1a2211	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a2213	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2217	c2 20		rep #$20	            REP #$20
.1a2219	29 ff 00	and #$00ff	            AND #$00FF
.1a221c	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a221f	e2 20		sep #$20	            SEP #$20
.1a2221	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2224					OPT_TOK
.1a2224	08		php		            PHP
.1a2225	e2 20		sep #$20	            SEP #$20
.1a2227	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a222a	e2 20		sep #$20	            SEP #$20
.1a222c	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the character at BIP
.1a222e	f0 10		beq $1a2240	            BEQ ret_false       ; If end-of-line, return false
.1a2230	c9 3a		cmp #$3a	            CMP #':'
.1a2232	f0 0c		beq $1a2240	            BEQ ret_false       ; If colon, return false
.1a2234	c5 37		cmp $0837	            CMP TARGETTOK
.1a2236	f0 05		beq $1a223d	            BEQ ret_true        ; If matches, return true
.1a2238	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a223b	80 ef		bra $1a222c	            BRA loop
.1a223d	28		plp		ret_true    PLP
.1a223e	38		sec		            SEC
.1a223f	60		rts		            RTS
.1a2240	28		plp		ret_false   PLP
.1a2241	18		clc		            CLC
.1a2242	60		rts		            RTS
.1a2243					PEEK_TOK
.1a2243	5a		phy		            PHY
.1a2244	08		php		            PHP
.1a2245	e2 20		sep #$20	            SEP #$20
.1a2247	a0 00 00	ldy #$0000	            LDY #0
.1a224a	b7 00		lda [$0800],y	loop        LDA [BIP],Y
.1a224c	f0 0d		beq $1a225b	            BEQ done
.1a224e	c9 3a		cmp #$3a	            CMP #':'
.1a2250	f0 07		beq $1a2259	            BEQ ret_null
.1a2252	c9 20		cmp #$20	            CMP #CHAR_SP
.1a2254	d0 05		bne $1a225b	            BNE done
.1a2256	c8		iny		            INY
.1a2257	80 f1		bra $1a224a	            BRA loop
.1a2259	a9 00		lda #$00	ret_null    LDA #0
.1a225b	28		plp		done        PLP
.1a225c	7a		ply		            PLY
.1a225d	60		rts		            RTS
.1a225e					EXECSTMT
.1a225e	08		php		            PHP
.1a225f	0b		phd		            PHD
.1a2260	8b		phb		            PHB
.1a2261	08		php		            PHP
.1a2262	c2 20		rep #$20	            REP #$20
.1a2264	48		pha		            PHA
.1a2265	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2268	5b		tcd		            TCD
.1a2269	68		pla		            PLA
.1a226a	28		plp		            PLP
.1a226b	20 50 19	jsr $1a1950	            JSR INITEVALSP
.1a226e	e2 20		sep #$20	            SEP #$20
.1a2270	a9 00		lda #$00	            LDA #EXEC_CONT      ; This will tell EXECLINE and EXECPROG to procede in a
.1a2272	85 dc		sta $08dc	            STA EXECACTION      ; linear fashion through the program
.1a2274	22 3c 11 00	jsl $00113c	check_break JSL FK_TESTBREAK
.1a2278	b0 4b		bcs $1a22c5	            BCS throw_break     ; If C: user pressed an interrupt key, stop the program
.1a227a	a7 00		lda [$0800]	            LDA [BIP]           ; If we happen to have a colon, just skip over it.
.1a227c	c9 3a		cmp #$3a	            CMP #':'            ; This can happen with FOR/NEXT
.1a227e	d0 03		bne $1a2283	            BNE eat_ws
.1a2280	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a2283					eat_ws
.1a2283	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a2286	a7 00		lda [$0800]	            LDA [BIP]
.1a2288	d0 03		bne $1a228d	            BNE else
.1a228a	4c 0f 23	jmp $1a230f	            JMP done            ; If the current byte is 0, we're at the end of the line, just return
.1a228d					else
.1a228d	20 a7 04	jsr $1a04a7	            JSR ISALPHA
.1a2290	b0 52		bcs $1a22e4	            BCS is_variable     ; Yes: we may have a LET statement
.1a2292	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it's any other non-token
.1a2294	10 10		bpl $1a22a6	            BPL error           ; Yes: it's a syntax error
.1a2296	20 6c 0c	jsr $1a0c6c	            JSR TOKTYPE
.1a2299	85 0c		sta $080c	            STA SCRATCH         ; Save the type for later
.1a229b	c9 20		cmp #$20	            CMP #TOK_TY_STMNT   ; Is it a statement?
.1a229d	d0 03		bne $1a22a2	            BNE else2
.1a229f	4c fd 22	jmp $1a22fd	            JMP ok_to_exec      ; Yes: it's ok to try to execute it
.1a22a2	a5 d2		lda $08d2	else2       LDA STATE           ; Check to see if we're in interactive mode
.1a22a4	f0 51		beq $1a22f7	            BEQ is_interact
.1a22a6					error
.1a22a6	08		php		            PHP
.1a22a7	c2 20		rep #$20	            REP #$20
.1a22a9	48		pha		            PHA
.1a22aa	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a22ad	5b		tcd		            TCD
.1a22ae	68		pla		            PLA
.1a22af	28		plp		            PLP
.1a22b0	e2 20		sep #$20	            SEP #$20
.1a22b2	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a22b4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a22b8	c2 20		rep #$20	            REP #$20
.1a22ba	29 ff 00	and #$00ff	            AND #$00FF
.1a22bd	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a22c0	e2 20		sep #$20	            SEP #$20
.1a22c2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a22c5					throw_break
.1a22c5	08		php		            PHP
.1a22c6	c2 20		rep #$20	            REP #$20
.1a22c8	48		pha		            PHA
.1a22c9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a22cc	5b		tcd		            TCD
.1a22cd	68		pla		            PLA
.1a22ce	28		plp		            PLP
.1a22cf	e2 20		sep #$20	            SEP #$20
.1a22d1	a9 01		lda #$01	            LDA #ERR_BREAK
.1a22d3	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a22d7	c2 20		rep #$20	            REP #$20
.1a22d9	29 ff 00	and #$00ff	            AND #$00FF
.1a22dc	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a22df	e2 20		sep #$20	            SEP #$20
.1a22e1	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a22e4					is_variable
.1a22e4	20 94 44	jsr $1a4494	            JSR S_LET
.1a22e7	4c 0f 23	jmp $1a230f	            JMP done
.1a22ea					STSTUB
.1a22ea	08		php		            PHP
.1a22eb	e2 20		sep #$20	            SEP #$20
.1a22ed	48		pha		            PHA
.1a22ee	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a22f0	48		pha		            PHA
.1a22f1	ab		plb		            PLB
.1a22f2	68		pla		            PLA
.1a22f3	28		plp		            PLP
.1a22f4	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.1a22f7	a5 0c		lda $080c	is_interact LDA SCRATCH         ; Get the token type
.1a22f9	c9 10		cmp #$10	            CMP #TOK_TY_CMD     ; Is it a command?
.1a22fb	d0 a9		bne $1a22a6	            BNE error           ; If not, it's an error
.1a22fd					ok_to_exec
.1a22fd	a7 00		lda [$0800]	            LDA [BIP]           ; Get the original token again
.1a22ff	20 49 0c	jsr $1a0c49	            JSR TOKEVAL
.1a2302	c2 20		rep #$20	            REP #$20
.1a2304	85 2f		sta $082f	            STA JMP16PTR        ; Store it in the jump pointer
.1a2306	20 50 19	jsr $1a1950	            JSR INITEVALSP
.1a2309	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a230c	20 ea 22	jsr $1a22ea	            JSR STSTUB
.1a230f	ab		plb		done        PLB
.1a2310	2b		pld		            PLD
.1a2311	28		plp		            PLP
.1a2312	60		rts		            RTS
.1a2313					EXECCMD
.1a2313	08		php		            PHP
.1a2314	58		cli		            CLI
.1a2315	20 a3 20	jsr $1a20a3	            JSR SETINTERACT
.1a2318	20 c8 1d	jsr $1a1dc8	            JSR INITRETURN
.1a231b	e2 20		sep #$20	            SEP #$20
.1a231d	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.1a2320	c2 20		rep #$20	            REP #$20
.1a2322	a5 1a		lda $081a	            LDA CURLINE         ; Set the BASIC Instruction Pointer to the first byte of the line
.1a2324	85 00		sta $0800	            STA BIP
.1a2326	a5 1c		lda $081c	            LDA CURLINE+2
.1a2328	85 02		sta $0802	            STA BIP+2
.1a232a	4c 54 23	jmp $1a2354	            JMP exec_loop
.1a232d	08		php		EXECLINE    PHP
.1a232e	c2 20		rep #$20	            REP #$20
.1a2330	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER            ; Set the current line number
.1a2333	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.1a2335	85 d7		sta $08d7	            STA LINENUM
.1a2337	20 bd 14	jsr $1a14bd	            JSR CLRTMPSTR
.1a233a	e2 20		sep #$20	            SEP #$20
.1a233c	a5 dc		lda $08dc	            LDA EXECACTION              ; If the last EXEC action was RETURN
.1a233e	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; BIP has already been set, so...
.1a2340	f0 12		beq $1a2354	            BEQ exec_loop               ; Skip over setting the BIP to the beginning of the line
.1a2342	c2 20		rep #$20	            REP #$20
.1a2344	18		clc		            CLC                         ; Set the BASIC Instruction Pointer to the first byte of the line
.1a2345	a5 1a		lda $081a	            LDA CURLINE
.1a2347	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a234a	85 00		sta $0800	            STA BIP
.1a234c	e2 20		sep #$20	            SEP #$20
.1a234e	a5 1c		lda $081c	            LDA CURLINE+2
.1a2350	69 00		adc #$00	            ADC #0
.1a2352	85 02		sta $0802	            STA BIP+2
.1a2354					exec_loop
.1a2354	c2 20		rep #$20	            REP #$20
.1a2356	20 5e 22	jsr $1a225e	            JSR EXECSTMT
.1a2359	e2 20		sep #$20	            SEP #$20
.1a235b	a5 dc		lda $08dc	            LDA EXECACTION
.1a235d	c9 03		cmp #$03	            CMP #EXEC_RETURN
.1a235f	f0 f3		beq $1a2354	            BEQ exec_loop
.1a2361	c9 00		cmp #$00	            CMP #EXEC_CONT              ; If it's not EXEC_CONT, exit to the caller
.1a2363	d0 31		bne $1a2396	            BNE exec_done
.1a2365	e2 20		sep #$20	            SEP #$20
.1a2367	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a236a	a7 00		lda [$0800]	            LDA [BIP]                   ; Get the current character in the line
.1a236c	f0 28		beq $1a2396	            BEQ exec_done               ; If it's NULL, we're done
.1a236e	c9 3a		cmp #$3a	            CMP #':'                    ; If it's colon, we have more statements
.1a2370	f0 1f		beq $1a2391	            BEQ skip_loop               ; Skip over it and try to execute the next one
.1a2372	08		php		            PHP
.1a2373	c2 20		rep #$20	            REP #$20
.1a2375	48		pha		            PHA
.1a2376	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2379	5b		tcd		            TCD
.1a237a	68		pla		            PLA
.1a237b	28		plp		            PLP
.1a237c	e2 20		sep #$20	            SEP #$20
.1a237e	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a2380	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2384	c2 20		rep #$20	            REP #$20
.1a2386	29 ff 00	and #$00ff	            AND #$00FF
.1a2389	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a238c	e2 20		sep #$20	            SEP #$20
.1a238e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2391					skip_loop
.1a2391	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a2394	80 be		bra $1a2354	            BRA exec_loop               ; And try to execute another statement
.1a2396					exec_done
.1a2396	28		plp		            PLP
.1a2397	60		rts		            RTS
.1a2398					EXECPROGRAM
.1a2398	08		php		            PHP
.1a2399	58		cli		            CLI
.1a239a	e2 20		sep #$20	            SEP #$20
.1a239c	a9 80		lda #$80	            LDA #ST_RUNNING
.1a239e	85 d2		sta $08d2	            STA STATE
.1a23a0	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.1a23a3	20 c8 1d	jsr $1a1dc8	            JSR INITRETURN
.1a23a6	c2 30		rep #$30	            REP #$30
.1a23a8	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the count of GOSUBs
.1a23aa	a0 02 00	ldy #$0002	exec_loop   LDY #LINE_NUMBER
.1a23ad	b7 1a		lda [$081a],y	            LDA [CURLINE],Y             ; Get the line number of the current line
.1a23af	f0 29		beq $1a23da	            BEQ done                    ; If it's 0, we are finished running code (implicit END)
.1a23b1	20 2d 23	jsr $1a232d	            JSR EXECLINE
.1a23b4	e2 20		sep #$20	            SEP #$20
.1a23b6	a5 dc		lda $08dc	            LDA EXECACTION              ; Check the EXECACTION from the last line
.1a23b8	c9 01		cmp #$01	            CMP #EXEC_STOP              ; Stop execution of the program?
.1a23ba	f0 1e		beq $1a23da	            BEQ done
.1a23bc	c9 02		cmp #$02	            CMP #EXEC_GOTO              ; Transfer execution to a new CURLINE that is already set
.1a23be	f0 ea		beq $1a23aa	            BEQ exec_loop
.1a23c0	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; Transfer execution to the CURLINE and BIP that is already set
.1a23c2	f0 e6		beq $1a23aa	            BEQ exec_loop
.1a23c4	c2 20		rep #$20	            REP #$20
.1a23c6	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a23c9	18		clc		            CLC
.1a23ca	a5 1a		lda $081a	            LDA CURLINE
.1a23cc	77 1a		adc [$081a],y	            ADC [CURLINE],Y
.1a23ce	85 1a		sta $081a	            STA CURLINE
.1a23d0	e2 20		sep #$20	            SEP #$20
.1a23d2	a5 1c		lda $081c	            LDA CURLINE+2
.1a23d4	69 00		adc #$00	            ADC #0
.1a23d6	85 1c		sta $081c	            STA CURLINE+2
.1a23d8	80 d0		bra $1a23aa	            BRA exec_loop               ; And try to execute that line
.1a23da					done
.1a23da	e2 20		sep #$20	            SEP #$20
.1a23dc	a9 00		lda #$00	            LDA #ST_INTERACT            ; Set interpreter state to RUNNING
.1a23de	85 d2		sta $08d2	            STA STATE
.1a23e0	28		plp		            PLP
.1a23e1	60		rts		            RTS
.1a23e2					FINDLINE
.1a23e2	08		php		            PHP
.1a23e3	c2 30		rep #$30	            REP #$30
.1a23e5	c2 20		rep #$20	            REP #$20
.1a23e7	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT            ; INDEX points to the first line of the program
.1a23ea	85 08		sta $0808	            STA INDEX
.1a23ec	a9 16 00	lda #$0016	            LDA #`BASIC_BOT
.1a23ef	85 0a		sta $080a	            STA INDEX+2
.1a23f1	c2 20		rep #$20	            REP #$20
.1a23f3	a0 02 00	ldy #$0002	check_nmbrs LDY #LINE_NUMBER            ; Get the number of the possible target line
.1a23f6	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a23f8	f0 31		beq $1a242b	            BEQ ret_false               ; If new line number is 0, we got to the
.1a23fa	c5 23		cmp $0823	            CMP ARGUMENT1               ; Compare it to the target line number
.1a23fc	f0 1e		beq $1a241c	            BEQ found
.1a23fe	b0 2b		bcs $1a242b	            BGE ret_false               ; If the line number > target line number, the line is not present
.1a2400					next_line
.1a2400	c2 20		rep #$20	            REP #$20
.1a2402	a0 00 00	ldy #$0000	            LDY #LINE_LINK              ; INDEX := INDEX + [INDEX].LINK
.1a2405	18		clc		            CLC
.1a2406	a5 08		lda $0808	            LDA INDEX
.1a2408	77 08		adc [$0808],y	            ADC [INDEX],Y
.1a240a	85 0c		sta $080c	            STA SCRATCH
.1a240c	e2 20		sep #$20	            SEP #$20
.1a240e	a5 0a		lda $080a	            LDA INDEX+2
.1a2410	69 00		adc #$00	            ADC #0
.1a2412	85 0a		sta $080a	            STA INDEX+2
.1a2414	c2 20		rep #$20	            REP #$20
.1a2416	a5 0c		lda $080c	            LDA SCRATCH
.1a2418	85 08		sta $0808	            STA INDEX
.1a241a	80 d7		bra $1a23f3	            BRA check_nmbrs             ; And go back to check the new line INDEX is pointing to
.1a241c					found
.1a241c	c2 20		rep #$20	            REP #$20
.1a241e	a5 08		lda $0808	            LDA INDEX
.1a2420	85 1a		sta $081a	            STA CURLINE
.1a2422	e2 20		sep #$20	            SEP #$20
.1a2424	a5 0a		lda $080a	            LDA INDEX+2
.1a2426	85 1c		sta $081c	            STA CURLINE+2
.1a2428	28		plp		ret_true    PLP                         ; Return true to indicate we've found the line
.1a2429	38		sec		            SEC
.1a242a	60		rts		            RTS
.1a242b	28		plp		ret_false   PLP
.1a242c	18		clc		            CLC
.1a242d	60		rts		            RTS
.1a242e					MVPROGDN
.1a242e	08		php		            PHP
.1a242f					mvd_loop
.1a242f	e2 20		sep #$20	            SEP #$20
.1a2431	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.1a2433	87 08		sta [$0808]	            STA [INDEX]
.1a2435	c2 20		rep #$20	            REP #$20
.1a2437	a5 0c		lda $080c	            LDA SCRATCH
.1a2439	c5 00		cmp $0800	            CMP BIP
.1a243b	d0 08		bne $1a2445	            BNE increment
.1a243d	e2 20		sep #$20	            SEP #$20
.1a243f	a5 0e		lda $080e	            LDA SCRATCH+2
.1a2441	c5 02		cmp $0802	            CMP BIP+2
.1a2443	f0 26		beq $1a246b	            BEQ done            ; Yes: return
.1a2445					increment
.1a2445	c2 20		rep #$20	            REP #$20
.1a2447	18		clc		            CLC
.1a2448	a5 0c		lda $080c	            LDA SCRATCH
.1a244a	69 01 00	adc #$0001	            ADC #1
.1a244d	85 0c		sta $080c	            STA SCRATCH
.1a244f	e2 20		sep #$20	            SEP #$20
.1a2451	a5 0e		lda $080e	            LDA SCRATCH+2
.1a2453	69 00		adc #$00	            ADC #0
.1a2455	85 0e		sta $080e	            STA SCRATCH+2
.1a2457	c2 20		rep #$20	            REP #$20
.1a2459	18		clc		            CLC
.1a245a	a5 08		lda $0808	            LDA INDEX
.1a245c	69 01 00	adc #$0001	            ADC #1
.1a245f	85 08		sta $0808	            STA INDEX
.1a2461	e2 20		sep #$20	            SEP #$20
.1a2463	a5 0a		lda $080a	            LDA INDEX+2
.1a2465	69 00		adc #$00	            ADC #0
.1a2467	85 0a		sta $080a	            STA INDEX+2
.1a2469	80 c4		bra $1a242f	            BRA mvd_loop        ; And try again
.1a246b	28		plp		done        PLP
.1a246c	60		rts		            RTS
.1a246d					MVPROGUP
.1a246d	08		php		            PHP
.1a246e					mvu_loop
.1a246e	e2 20		sep #$20	            SEP #$20
.1a2470	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.1a2472	87 08		sta [$0808]	            STA [INDEX]
.1a2474	c2 20		rep #$20	            REP #$20
.1a2476	a5 0c		lda $080c	            LDA SCRATCH
.1a2478	c5 00		cmp $0800	            CMP BIP
.1a247a	d0 06		bne $1a2482	            BNE decrement
.1a247c	a5 0e		lda $080e	            LDA SCRATCH+2
.1a247e	c5 02		cmp $0802	            CMP BIP+2
.1a2480	f0 26		beq $1a24a8	            BEQ done            ; Yes: return
.1a2482					decrement
.1a2482	c2 20		rep #$20	            REP #$20
.1a2484	38		sec		            SEC
.1a2485	a5 0c		lda $080c	            LDA SCRATCH
.1a2487	e9 01 00	sbc #$0001	            SBC #1
.1a248a	85 0c		sta $080c	            STA SCRATCH
.1a248c	e2 20		sep #$20	            SEP #$20
.1a248e	a5 0e		lda $080e	            LDA SCRATCH+2
.1a2490	e9 00		sbc #$00	            SBC #0
.1a2492	85 0e		sta $080e	            STA SCRATCH+2
.1a2494	c2 20		rep #$20	            REP #$20
.1a2496	38		sec		            SEC
.1a2497	a5 08		lda $0808	            LDA INDEX
.1a2499	e9 01 00	sbc #$0001	            SBC #1
.1a249c	85 08		sta $0808	            STA INDEX
.1a249e	e2 20		sep #$20	            SEP #$20
.1a24a0	a5 0a		lda $080a	            LDA INDEX+2
.1a24a2	e9 00		sbc #$00	            SBC #0
.1a24a4	85 0a		sta $080a	            STA INDEX+2
.1a24a6	80 c6		bra $1a246e	            BRA mvu_loop        ; And try again
.1a24a8	28		plp		done        PLP
.1a24a9	60		rts		            RTS
.1a24aa					DELLINE
.1a24aa	08		php		            PHP
.1a24ab	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; SCRATCH := INDEX + [INDEX].LINK (address of the following line)
.1a24ae	c2 20		rep #$20	            REP #$20
.1a24b0	18		clc		            CLC
.1a24b1	a5 08		lda $0808	            LDA INDEX
.1a24b3	77 08		adc [$0808],y	            ADC [INDEX],Y
.1a24b5	85 0c		sta $080c	            STA SCRATCH
.1a24b7	e2 20		sep #$20	            SEP #$20
.1a24b9	a5 0a		lda $080a	            LDA INDEX+2
.1a24bb	69 00		adc #$00	            ADC #0
.1a24bd	85 0e		sta $080e	            STA SCRATCH+2
.1a24bf	c2 20		rep #$20	            REP #$20
.1a24c1	18		clc		            CLC
.1a24c2	a5 d9		lda $08d9	            LDA LASTLINE
.1a24c4	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a24c7	85 00		sta $0800	            STA BIP
.1a24c9	e2 20		sep #$20	            SEP #$20
.1a24cb	a5 db		lda $08db	            LDA LASTLINE+2
.1a24cd	69 00		adc #$00	            ADC #0
.1a24cf	85 02		sta $0802	            STA BIP+2
.1a24d1	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; LASTLINE := LASTLINE - [INDEX].LINK
.1a24d4	c2 20		rep #$20	            REP #$20
.1a24d6	38		sec		            SEC
.1a24d7	a5 d9		lda $08d9	            LDA LASTLINE
.1a24d9	f7 08		sbc [$0808],y	            SBC [INDEX],Y
.1a24db	85 d9		sta $08d9	            STA LASTLINE
.1a24dd	e2 20		sep #$20	            SEP #$20
.1a24df	a5 db		lda $08db	            LDA LASTLINE+2
.1a24e1	e9 00		sbc #$00	            SBC #0
.1a24e3	85 db		sta $08db	            STA LASTLINE+2
.1a24e5	20 2e 24	jsr $1a242e	            JSR MVPROGDN
.1a24e8					done
.1a24e8	20 8a 44	jsr $1a448a	            JSR S_CLR
.1a24eb	28		plp		            PLP
.1a24ec	60		rts		            RTS
.1a24ed					APPLINE
.1a24ed	08		php		            PHP
.1a24ee	08		php		            PHP
.1a24ef	c2 20		rep #$20	            REP #$20
.1a24f1	48		pha		            PHA
.1a24f2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a24f5	5b		tcd		            TCD
.1a24f6	68		pla		            PLA
.1a24f7	28		plp		            PLP
.1a24f8	c2 30		rep #$30	            REP #$30
.1a24fa	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the line number of the new line
.1a24fd	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.1a24ff	18		clc		            CLC                 ; Point INDEX to the position to store the tokens
.1a2500	a5 d9		lda $08d9	            LDA LASTLINE
.1a2502	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a2505	85 08		sta $0808	            STA INDEX
.1a2507	e2 20		sep #$20	            SEP #$20
.1a2509	a5 db		lda $08db	            LDA LASTLINE+2
.1a250b	69 00		adc #$00	            ADC #0
.1a250d	85 0a		sta $080a	            STA INDEX+2
.1a250f	e2 20		sep #$20	            SEP #$20
.1a2511	a0 00 00	ldy #$0000	            LDY #0
.1a2514	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Copy the tokenized line to its place in the code
.1a2516	97 08		sta [$0808],y	            STA [INDEX],Y
.1a2518	f0 03		beq $1a251d	            BEQ copy_done
.1a251a	c8		iny		            INY
.1a251b	80 f7		bra $1a2514	            BRA copy_loop
.1a251d					copy_done
.1a251d	c2 20		rep #$20	            REP #$20
.1a251f	98		tya		            TYA
.1a2520	18		clc		            CLC
.1a2521	69 05 00	adc #$0005	            ADC #LINE_TOKENS+1
.1a2524	85 0c		sta $080c	            STA SCRATCH
.1a2526	c2 20		rep #$20	            REP #$20
.1a2528	a0 00 00	ldy #$0000	            LDY #LINE_LINK      ; Set link to the offset to the next line
.1a252b	a5 0c		lda $080c	            LDA SCRATCH
.1a252d	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.1a252f	c2 20		rep #$20	            REP #$20
.1a2531	18		clc		            CLC
.1a2532	a5 d9		lda $08d9	            LDA LASTLINE
.1a2534	65 0c		adc $080c	            ADC SCRATCH
.1a2536	85 0c		sta $080c	            STA SCRATCH
.1a2538	e2 20		sep #$20	            SEP #$20
.1a253a	a5 db		lda $08db	            LDA LASTLINE+2
.1a253c	69 00		adc #$00	            ADC #0
.1a253e	85 db		sta $08db	            STA LASTLINE+2
.1a2540	c2 20		rep #$20	            REP #$20
.1a2542	a5 0c		lda $080c	            LDA SCRATCH
.1a2544	85 d9		sta $08d9	            STA LASTLINE
.1a2546	c2 20		rep #$20	            REP #$20
.1a2548	a0 00 00	ldy #$0000	            LDY #0
.1a254b	a9 00 00	lda #$0000	            LDA #0
.1a254e	97 d9		sta [$08d9],y	blank_loop  STA [LASTLINE],Y    ; Set the "line" after the last line to nulls
.1a2550	c8		iny		            INY
.1a2551	c0 05 00	cpy #$0005	            CPY #LINE_TOKENS+1
.1a2554	d0 f8		bne $1a254e	            BNE blank_loop
.1a2556	20 8a 44	jsr $1a448a	            JSR S_CLR
.1a2559	28		plp		            PLP
.1a255a	60		rts		            RTS
.1a255b					FINDINSPT
.1a255b	0b		phd		            PHD
.1a255c	08		php		            PHP
.1a255d	08		php		            PHP
.1a255e	c2 20		rep #$20	            REP #$20
.1a2560	48		pha		            PHA
.1a2561	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a2564	5b		tcd		            TCD
.1a2565	68		pla		            PLA
.1a2566	28		plp		            PLP
.1a2567	c2 30		rep #$30	            REP #$30
.1a2569	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.1a256c	85 08		sta $0808	            STA INDEX
.1a256e	a9 16 00	lda #$0016	            LDA #`BASIC_BOT
.1a2571	85 0a		sta $080a	            STA INDEX+2
.1a2573	a0 02 00	ldy #$0002	loop        LDY #LINE_NUMBER
.1a2576	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a2578	f0 1d		beq $1a2597	            BEQ found_end           ; Got to end without finding it
.1a257a	c5 d7		cmp $08d7	            CMP LINENUM
.1a257c	f0 25		beq $1a25a3	            BEQ found_line          ; LINENUM = [INDEX].LINE_NUMBER: return we found the exact line
.1a257e	b0 1d		bcs $1a259d	            BGE found_spot          ; LINENUM > [INDEX].LINE_NUMBER: return we found spot to insert
.1a2580	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a2583	18		clc		            CLC                     ; Move INDEX to the next line
.1a2584	a5 08		lda $0808	            LDA INDEX
.1a2586	77 08		adc [$0808],y	            ADC [INDEX],Y
.1a2588	85 0c		sta $080c	            STA SCRATCH
.1a258a	a5 0a		lda $080a	            LDA INDEX+2
.1a258c	69 00 00	adc #$0000	            ADC #0
.1a258f	85 0a		sta $080a	            STA INDEX+2
.1a2591	a5 0c		lda $080c	            LDA SCRATCH
.1a2593	85 08		sta $0808	            STA INDEX
.1a2595	80 dc		bra $1a2573	            BRA loop                ; And check that line
.1a2597	a9 00 00	lda #$0000	found_end   LDA #0                  ; Return that we reached the end of the program
.1a259a	28		plp		            PLP
.1a259b	2b		pld		            PLD
.1a259c	60		rts		            RTS
.1a259d	a9 01 00	lda #$0001	found_spot  LDA #1                  ; Return that we the found the spot to insert the line
.1a25a0	28		plp		            PLP                     ; But that it wasn't already there
.1a25a1	2b		pld		            PLD
.1a25a2	60		rts		            RTS
.1a25a3	a9 02 00	lda #$0002	found_line  LDA #2                  ; Return that we found the line
.1a25a6	28		plp		            PLP
.1a25a7	2b		pld		            PLD
.1a25a8	60		rts		            RTS
.1a25a9					INSLINE
.1a25a9	08		php		            PHP
.1a25aa	c2 30		rep #$30	            REP #$30
.1a25ac	a9 05 00	lda #$0005	            LDA #LINE_TOKENS+1  ; Set SCRATCH2 to the size of the line header with the end-of-line
.1a25af	85 10		sta $0810	            STA SCRATCH2
.1a25b1	a0 00 00	ldy #$0000	            LDY #0
.1a25b4					count_loop
.1a25b4	e2 20		sep #$20	            SEP #$20
.1a25b6	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the byte of the line
.1a25b8	f0 07		beq $1a25c1	            BEQ shift_prog      ; If it's end-of-line, SCRATCH2 is the length
.1a25ba	c2 20		rep #$20	            REP #$20
.1a25bc	e6 10		inc $0810	            INC SCRATCH2
.1a25be	c8		iny		            INY
.1a25bf	80 f3		bra $1a25b4	            BRA count_loop      ; Count and continue
.1a25c1					shift_prog
.1a25c1	c2 20		rep #$20	            REP #$20
.1a25c3	a5 08		lda $0808	            LDA INDEX           ; BIP = the address of the first byte for the new line
.1a25c5	85 00		sta $0800	            STA BIP
.1a25c7	a5 0a		lda $080a	            LDA INDEX+2
.1a25c9	85 02		sta $0802	            STA BIP+2
.1a25cb	18		clc		            CLC                 ; SCRATCH = address of highest byte to copy
.1a25cc	a5 d9		lda $08d9	            LDA LASTLINE
.1a25ce	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a25d1	85 0c		sta $080c	            STA SCRATCH
.1a25d3	a5 db		lda $08db	            LDA LASTLINE+2
.1a25d5	69 00 00	adc #$0000	            ADC #0
.1a25d8	85 0e		sta $080e	            STA SCRATCH+2
.1a25da	18		clc		            CLC                 ; Adjust LASTLINE to its new position after the insert
.1a25db	a5 d9		lda $08d9	            LDA LASTLINE
.1a25dd	65 10		adc $0810	            ADC SCRATCH2
.1a25df	85 d9		sta $08d9	            STA LASTLINE
.1a25e1	a5 db		lda $08db	            LDA LASTLINE+2
.1a25e3	69 00 00	adc #$0000	            ADC #0
.1a25e6	85 db		sta $08db	            STA LASTLINE+2
.1a25e8	18		clc		            CLC                 ; INDEX = address of the highest location to copy into
.1a25e9	a5 d9		lda $08d9	            LDA LASTLINE
.1a25eb	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a25ee	85 08		sta $0808	            STA INDEX
.1a25f0	a5 db		lda $08db	            LDA LASTLINE+2
.1a25f2	69 00 00	adc #$0000	            ADC #0
.1a25f5	85 0a		sta $080a	            STA INDEX+2
.1a25f7	20 6d 24	jsr $1a246d	            JSR MVPROGUP
.1a25fa	c2 20		rep #$20	            REP #$20
.1a25fc	a5 10		lda $0810	            LDA SCRATCH2
.1a25fe	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a2601	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINK_LINK = length of the new line
.1a2603	a5 d7		lda $08d7	            LDA LINENUM
.1a2605	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.1a2608	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINE_NUMBER = number of the new line
.1a260a	18		clc		            CLC                 ; Point BIP to the first byte of the new line
.1a260b	a5 00		lda $0800	            LDA BIP
.1a260d	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a2610	85 00		sta $0800	            STA BIP
.1a2612	a5 02		lda $0802	            LDA BIP+2
.1a2614	69 00 00	adc #$0000	            ADC #0
.1a2617	85 02		sta $0802	            STA BIP+2
.1a2619	a0 00 00	ldy #$0000	            LDY #0
.1a261c	e2 20		sep #$20	            SEP #$20
.1a261e	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Get the byte of the tokenized line
.1a2620	97 00		sta [$0800],y	            STA [BIP],Y         ; Copy it to its correct location in the program
.1a2622	f0 03		beq $1a2627	            BEQ done            ; If it was end-of-line byte, we're done
.1a2624	c8		iny		            INY
.1a2625	80 f7		bra $1a261e	            BRA copy_loop       ; Otherwise, continue with the next
.1a2627					done
.1a2627	20 8a 44	jsr $1a448a	            JSR S_CLR
.1a262a	28		plp		            PLP
.1a262b	60		rts		            RTS
.1a262c					ADDLINE
.1a262c	08		php		            PHP
.1a262d	c2 30		rep #$30	            REP #$30
.1a262f	85 d7		sta $08d7	            STA LINENUM
.1a2631	20 5b 25	jsr $1a255b	            JSR FINDINSPT
.1a2634	c9 00 00	cmp #$0000	            CMP #0
.1a2637	f0 2c		beq $1a2665	            BEQ do_append       ; End-of-program found, add the line to the end
.1a2639	c9 01 00	cmp #$0001	            CMP #1
.1a263c	f0 22		beq $1a2660	            BEQ do_insert       ; Spot was found: insertion required
.1a263e	c2 20		rep #$20	            REP #$20
.1a2640	a5 08		lda $0808	            LDA INDEX
.1a2642	48		pha		            PHA
.1a2643	a5 0a		lda $080a	            LDA INDEX+2
.1a2645	48		pha		            PHA
.1a2646	20 aa 24	jsr $1a24aa	            JSR DELLINE
.1a2649	68		pla		            PLA
.1a264a	85 0a		sta $080a	            STA INDEX+2
.1a264c	68		pla		            PLA
.1a264d	85 08		sta $0808	            STA INDEX
.1a264f	a5 1a		lda $081a	            LDA CURLINE         ; Check to see if there is any non-whitespace on the line
.1a2651	85 00		sta $0800	            STA BIP
.1a2653	a5 1c		lda $081c	            LDA CURLINE+2
.1a2655	85 02		sta $0802	            STA BIP+2
.1a2657	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a265a	e2 20		sep #$20	            SEP #$20
.1a265c	a7 00		lda [$0800]	            LDA [BIP]
.1a265e	f0 0a		beq $1a266a	            BEQ done            ; If not, we're done
.1a2660					do_insert
.1a2660	20 a9 25	jsr $1a25a9	            JSR INSLINE
.1a2663	80 05		bra $1a266a	            BRA done
.1a2665	a5 d7		lda $08d7	do_append   LDA LINENUM
.1a2667	20 ed 24	jsr $1a24ed	            JSR APPLINE
.1a266a	28		plp		done        PLP
.1a266b	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\repl.s

="#"					CHAR_DIR = '#'
="|"					CHAR_BRUN = '|'
.1a266c					EXPANDLINE
.1a266c	0b		phd		                PHD
.1a266d	08		php		                PHP
.1a266e	08		php		            PHP
.1a266f	c2 20		rep #$20	            REP #$20
.1a2671	48		pha		            PHA
.1a2672	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a2675	5b		tcd		            TCD
.1a2676	68		pla		            PLA
.1a2677	28		plp		            PLP
.1a2678	e2 20		sep #$20	            SEP #$20
.1a267a	c2 10		rep #$10	            REP #$10
.1a267c	a2 00 00	ldx #$0000	                LDX #0
.1a267f	bd 00 4f	lda $4f00,x	count_loop      LDA INPUTBUF,X              ; Count the number of characters in the input
.1a2682	f0 03		beq $1a2687	                BEQ save_size
.1a2684	e8		inx		                INX
.1a2685	80 f8		bra $1a267f	                BRA count_loop
.1a2687	86 0c		stx $080c	save_size       STX SCRATCH                 ; Save the size in SCRATCH
.1a2689	c2 30		rep #$30	            REP #$30
.1a268b	8a		txa		                TXA
.1a268c	c9 02 00	cmp #$0002	                CMP #2                      ; Are there arguments?
.1a268f	90 12		bcc $1a26a3	                BLT start_copy              ; No: just replace the whole string
.1a2691	3a		dec a		                DEC A
.1a2692	18		clc		                CLC
.1a2693	69 00 4f	adc #$4f00	                ADC #<>INPUTBUF
.1a2696	aa		tax		                TAX                         ; X <-- INPUTBUF + len(INPUTBUF) - 1
.1a2697	18		clc		                CLC                         ; Y <-- INPUTBUF + len(INPUTBUF) - 1 + len(substitution)
.1a2698	65 8f		adc $088f	                ADC MCOUNT
.1a269a	a8		tay		                TAY
.1a269b	a5 0c		lda $080c	                LDA SCRATCH
.1a269d	3a		dec a		                DEC A
.1a269e	8b		phb		                PHB
.1a269f	44 00 00	mvp #$00,#$00	                MVP #`INPUTBUF,#`INPUTBUF   ; Make room for the substitition
.1a26a2	ab		plb		                PLB
.1a26a3					start_copy
.1a26a3	c2 20		rep #$20	            REP #$20
.1a26a5	a6 55		ldx $0855	                LDX MARG1                   ; Source is data to copy
.1a26a7	a0 00 4f	ldy #$4f00	                LDY #<>INPUTBUF             ; Destination is input buffer
.1a26aa	a5 8f		lda $088f	                LDA MCOUNT                  ; Number of bytes to copy
.1a26ac	8b		phb		                PHB
.1a26ad	54 00 1a	mvn #$1a,#$00	                MVN #`EXPANDLINE,#`INPUTBUF ; Copy the data
.1a26b0	ab		plb		                PLB
.1a26b1	e2 20		sep #$20	            SEP #$20
.1a26b3	a5 0c		lda $080c	                LDA SCRATCH                 ; Check again to see if we need quotes
.1a26b5	c9 02		cmp #$02	                CMP #2
.1a26b7	90 18		bcc $1a26d1	                BLT done
.1a26b9	a6 8f		ldx $088f	                LDX MCOUNT                  ; If so, add a quote mark here
.1a26bb	a9 22		lda #$22	                LDA #CHAR_DQUOTE
.1a26bd	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a26c0	e8		inx		skip_to_end     INX                         ; Move to the end of the input string
.1a26c1	bd 00 4f	lda $4f00,x	                LDA INPUTBUF,X
.1a26c4	d0 fa		bne $1a26c0	                BNE skip_to_end
.1a26c6	a9 22		lda #$22	                LDA #CHAR_DQUOTE            ; Add the quote to the end of the string
.1a26c8	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a26cb	a9 00		lda #$00	                LDA #0                      ; And terminate with a NULL
.1a26cd	e8		inx		                INX
.1a26ce	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a26d1	28		plp		done            PLP
.1a26d2	2b		pld		                PLD
.1a26d3	60		rts		            RTS
.1a26d4					PREPROCESS
.1a26d4	da		phx		                PHX
.1a26d5	5a		phy		                PHY
.1a26d6	8b		phb		                PHB
.1a26d7	0b		phd		                PHD
.1a26d8	08		php		                PHP
.1a26d9	08		php		            PHP
.1a26da	c2 20		rep #$20	            REP #$20
.1a26dc	48		pha		            PHA
.1a26dd	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a26e0	5b		tcd		            TCD
.1a26e1	68		pla		            PLA
.1a26e2	28		plp		            PLP
.1a26e3	e2 20		sep #$20	            SEP #$20
.1a26e5	c2 10		rep #$10	            REP #$10
.1a26e7	ad 00 4f	lda $4f00	                LDA INPUTBUF            ; Check the first character
.1a26ea	c9 23		cmp #$23	                CMP #CHAR_DIR           ; Is it the DIR character?
.1a26ec	f0 0a		beq $1a26f8	                BEQ expand_dir          ; Yes: expand the DIR command into place
.1a26ee	c9 7c		cmp #$7c	                CMP #CHAR_BRUN          ; Is it the BRUN character?
.1a26f0	f0 17		beq $1a2709	                BEQ expand_brun         ; Yes: expand the BRUN command into place
.1a26f2	28		plp		done            PLP
.1a26f3	2b		pld		                PLD
.1a26f4	ab		plb		                PLB
.1a26f5	7a		ply		                PLY
.1a26f6	fa		plx		                PLX
.1a26f7	60		rts		            RTS
.1a26f8					expand_dir
.1a26f8	c2 20		rep #$20	            REP #$20
.1a26fa	a9 03 00	lda #$0003	                LDA #3                  ; Set size of substitution value
.1a26fd	85 8f		sta $088f	                STA MCOUNT
.1a26ff	a9 1a 27	lda #$271a	                LDA #<>dir_text         ; Set pointer to substitution value
.1a2702	85 55		sta $0855	                STA MARG1
.1a2704	20 6c 26	jsr $1a266c	            JSR EXPANDLINE
.1a2707	80 e9		bra $1a26f2	                BRA done
.1a2709					expand_brun
.1a2709	c2 20		rep #$20	            REP #$20
.1a270b	a9 04 00	lda #$0004	                LDA #4                  ; Set size of substitution value
.1a270e	85 8f		sta $088f	                STA MCOUNT
.1a2710	a9 1e 27	lda #$271e	                LDA #<>brun_text        ; Set pointer to substitution value
.1a2713	85 55		sta $0855	                STA MARG1
.1a2715	20 6c 26	jsr $1a266c	            JSR EXPANDLINE
.1a2718	80 d8		bra $1a26f2	                BRA done
>1a271a	44 49 52 00			dir_text        .null "DIR"             ; Expansion of the DIR character
>1a271e	42 52 55 4e 00			brun_text       .null "BRUN"            ; Expansion of the BRUN character
.1a2723					PRREADY
.1a2723	8b		phb		                PHB
.1a2724	08		php		                PHP
.1a2725	20 3d 02	jsr $1a023d	            JSR ENSURETEXT
.1a2728	08		php		            PHP
.1a2729	e2 20		sep #$20	            SEP #$20
.1a272b	48		pha		            PHA
.1a272c	a9 1a		lda #$1a	            LDA #`MPROMPT
.1a272e	48		pha		            PHA
.1a272f	ab		plb		            PLB
.1a2730	68		pla		            PLA
.1a2731	28		plp		            PLP
.1a2732	a2 6f d2	ldx #$d26f	                LDX #<>MPROMPT
.1a2735	20 29 04	jsr $1a0429	            JSR PRINTS
.1a2738	28		plp		                PLP
.1a2739	ab		plb		                PLB
.1a273a	60		rts		            RTS
.1a273b					IREADLINE
.1a273b	08		php		                PHP
.1a273c	e2 30		sep #$30	            SEP #$30
.1a273e	a9 01		lda #$01	                LDA #1
.1a2740	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a2743					read_loop
.1a2743	20 db 00	jsr $1a00db	            JSR GETKEYE
.1a2746	c9 00		cmp #$00	                CMP #0
.1a2748	f0 f9		beq $1a2743	                BEQ read_loop
.1a274a	c9 0d		cmp #$0d	                CMP #CHAR_CR
.1a274c	f0 02		beq $1a2750	                BEQ done
.1a274e	80 f3		bra $1a2743	                BRA read_loop
.1a2750	28		plp		done            PLP
.1a2751	60		rts		            RTS
.1a2752					PROCESS
.1a2752	0b		phd		                PHD
.1a2753	08		php		                PHP
.1a2754	08		php		            PHP
.1a2755	c2 20		rep #$20	            REP #$20
.1a2757	48		pha		            PHA
.1a2758	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a275b	5b		tcd		            TCD
.1a275c	68		pla		            PLA
.1a275d	28		plp		            PLP
.1a275e	c2 30		rep #$30	            REP #$30
.1a2760	64 d7		stz $08d7	                STZ LINENUM
.1a2762	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF         ; Attempt to tokenize the line that was read
.1a2765	85 1a		sta $081a	                STA CURLINE
.1a2767	a9 00 00	lda #$0000	                LDA #`CURLINE
.1a276a	85 1c		sta $081c	                STA CURLINE+2
.1a276c	20 61 09	jsr $1a0961	            JSR TOKENIZE
.1a276f	c2 20		rep #$20	            REP #$20
.1a2771	a5 d7		lda $08d7	                LDA LINENUM             ; Did we get a line number?
.1a2773	d0 05		bne $1a277a	                BNE update_line         ; Yes: attempt to add it to the program
.1a2775	20 13 23	jsr $1a2313	            JSR EXECCMD
.1a2778	80 07		bra $1a2781	                BRA done
.1a277a					update_line
.1a277a	20 2c 26	jsr $1a262c	            JSR ADDLINE
.1a277d	28		plp		no_prompt       PLP
.1a277e	2b		pld		                PLD
.1a277f	38		sec		                SEC
.1a2780	60		rts		            RTS
.1a2781	28		plp		done            PLP
.1a2782	2b		pld		                PLD
.1a2783	18		clc		                CLC
.1a2784	60		rts		            RTS
.1a2785					INTERACT
.1a2785	c2 30		rep #$30	            REP #$30
.1a2787	a2 ff fe	ldx #$feff	                LDX #<>STACK_END
.1a278a	9a		txs		                TXS
.1a278b					ready_loop
.1a278b	20 23 27	jsr $1a2723	            JSR PRREADY
.1a278e					no_ready_loop
.1a278e	20 08 00	jsr $1a0008	            JSR READLINE
.1a2791	20 0c 00	jsr $1a000c	            JSR SCRCOPYLINE
.1a2794	22 3c 11 00	jsl $00113c	                JSL FK_TESTBREAK    ; Make sure the BREAK bit is cleared.
.1a2798	a9 00 00	lda #$0000	                LDA #0              ; Hide the cursor
.1a279b	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a279e	20 d4 26	jsr $1a26d4	            JSR PREPROCESS
.1a27a1	20 52 27	jsr $1a2752	            JSR PROCESS
.1a27a4	b0 e8		bcs $1a278e	                BCS no_ready_loop
.1a27a6	80 e3		bra $1a278b	                BRA ready_loop
>1ad26f	0d 52 45 41 44 59 0d 00		MPROMPT         .null 13,"READY",13

;******  Return to file: src\basic816.s


;******  Processing file: src\operators.s

.1a27a8					OP_PLUS
.1a27a8	08		php		            PHP
.1a27a9	e2 20		sep #$20	            SEP #$20
.1a27ab	20 68 08	jsr $1a0868	            JSR ASS_ARGS_NUMSTR
.1a27ae	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a27b0	f0 2c		beq $1a27de	            BEQ is_integer
.1a27b2	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a27b4	f0 2d		beq $1a27e3	            BEQ is_float
.1a27b6	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a27b8	f0 1f		beq $1a27d9	            BEQ is_string
.1a27ba					type_error
.1a27ba	08		php		            PHP
.1a27bb	c2 20		rep #$20	            REP #$20
.1a27bd	48		pha		            PHA
.1a27be	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a27c1	5b		tcd		            TCD
.1a27c2	68		pla		            PLA
.1a27c3	28		plp		            PLP
.1a27c4	e2 20		sep #$20	            SEP #$20
.1a27c6	a9 04		lda #$04	            LDA #ERR_TYPE
.1a27c8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a27cc	c2 20		rep #$20	            REP #$20
.1a27ce	29 ff 00	and #$00ff	            AND #$00FF
.1a27d1	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a27d4	e2 20		sep #$20	            SEP #$20
.1a27d6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a27d9					is_string
.1a27d9	20 16 16	jsr $1a1616	            JSR STRCONCAT
.1a27dc	80 08		bra $1a27e6	            BRA done
.1a27de					is_integer
.1a27de	20 37 54	jsr $1a5437	            JSR OP_INT_ADD
.1a27e1	80 03		bra $1a27e6	            BRA done
.1a27e3					is_float
.1a27e3	20 a6 56	jsr $1a56a6	            JSR OP_FP_ADD
.1a27e6	28		plp		done        PLP
.1a27e7	60		rts		            RTS
.1a27e8					OP_MINUS
.1a27e8	08		php		            PHP
.1a27e9	e2 20		sep #$20	            SEP #$20
.1a27eb	20 1a 08	jsr $1a081a	            JSR ASS_ARGS_NUM
.1a27ee	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a27f0	f0 23		beq $1a2815	            BEQ is_integer
.1a27f2	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a27f4	f0 24		beq $1a281a	            BEQ is_float
.1a27f6					type_error
.1a27f6	08		php		            PHP
.1a27f7	c2 20		rep #$20	            REP #$20
.1a27f9	48		pha		            PHA
.1a27fa	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a27fd	5b		tcd		            TCD
.1a27fe	68		pla		            PLA
.1a27ff	28		plp		            PLP
.1a2800	e2 20		sep #$20	            SEP #$20
.1a2802	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2804	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2808	c2 20		rep #$20	            REP #$20
.1a280a	29 ff 00	and #$00ff	            AND #$00FF
.1a280d	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a2810	e2 20		sep #$20	            SEP #$20
.1a2812	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2815					is_integer
.1a2815	20 49 54	jsr $1a5449	            JSR OP_INT_SUB
.1a2818	80 03		bra $1a281d	            BRA done
.1a281a					is_float
.1a281a	20 9b 56	jsr $1a569b	            JSR OP_FP_SUB
.1a281d	28		plp		done        PLP
.1a281e	60		rts		            RTS
.1a281f					OP_MULTIPLY
.1a281f	08		php		            PHP
.1a2820	e2 20		sep #$20	            SEP #$20
.1a2822	20 1a 08	jsr $1a081a	            JSR ASS_ARGS_NUM
.1a2825	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a2827	f0 23		beq $1a284c	            BEQ is_integer
.1a2829	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a282b	f0 24		beq $1a2851	            BEQ is_float
.1a282d					type_error
.1a282d	08		php		            PHP
.1a282e	c2 20		rep #$20	            REP #$20
.1a2830	48		pha		            PHA
.1a2831	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2834	5b		tcd		            TCD
.1a2835	68		pla		            PLA
.1a2836	28		plp		            PLP
.1a2837	e2 20		sep #$20	            SEP #$20
.1a2839	a9 04		lda #$04	            LDA #ERR_TYPE
.1a283b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a283f	c2 20		rep #$20	            REP #$20
.1a2841	29 ff 00	and #$00ff	            AND #$00FF
.1a2844	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a2847	e2 20		sep #$20	            SEP #$20
.1a2849	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a284c					is_integer
.1a284c	20 5b 54	jsr $1a545b	            JSR OP_INT_MUL
.1a284f	80 03		bra $1a2854	            BRA done
.1a2851					is_float
.1a2851	20 3c 57	jsr $1a573c	            JSR OP_FP_MUL
.1a2854	28		plp		done        PLP
.1a2855	60		rts		            RTS
.1a2856					OP_DIVIDE
.1a2856	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a2859	20 b5 07	jsr $1a07b5	            JSR ASS_ARG2_FLOAT
.1a285c	20 f1 56	jsr $1a56f1	            JSR OP_FP_DIV
.1a285f	60		rts		            RTS
.1a2860					OP_MOD
.1a2860	a5 23		lda $0823	            LDA ARGUMENT1
.1a2862	8f 1a 01 00	sta $00011a	            STA @lD1_OPERAND_B
.1a2866	a5 29		lda $0829	            LDA ARGUMENT2
.1a2868	8f 18 01 00	sta $000118	            STA @lD1_OPERAND_A
.1a286c	af 1e 01 00	lda $00011e	            LDA @lD1_REMAINDER
.1a2870	85 23		sta $0823	            STA ARGUMENT1
.1a2872	60		rts		            RTS
.1a2873					OP_POW
.1a2873	08		php		            PHP
.1a2874	c2 30		rep #$30	            REP #$30
.1a2876	48		pha		            PHA
.1a2877	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a287a	a5 2d		lda $082d	            LDA ARGTYPE2
.1a287c	c9 00 00	cmp #$0000	            CMP #TYPE_INTEGER
.1a287f	d0 0d		bne $1a288e	            BNE flt_exp
.1a2881	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a2883	d0 09		bne $1a288e	            BNE flt_exp
.1a2885	da		phx		            PHX
.1a2886	a6 29		ldx $0829	            LDX ARGUMENT2
.1a2888	20 0f 64	jsr $1a640f	            JSR Q_FP_POW_INT
.1a288b	fa		plx		            PLX
.1a288c	80 1c		bra $1a28aa	            BRA done
.1a288e					flt_exp
.1a288e	20 b5 07	jsr $1a07b5	            JSR ASS_ARG2_FLOAT
.1a2891	c2 20		rep #$20	            REP #$20
.1a2893	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a2895	48		pha		            PHA
.1a2896	a5 29		lda $0829	            LDA ARGUMENT2
.1a2898	48		pha		            PHA
.1a2899	20 9a 62	jsr $1a629a	            JSR FP_LN
.1a289c	c2 20		rep #$20	            REP #$20
.1a289e	68		pla		            PLA
.1a289f	85 29		sta $0829	            STA ARGUMENT2
.1a28a1	68		pla		            PLA
.1a28a2	85 2b		sta $082b	            STA ARGUMENT2+2
.1a28a4	20 3c 57	jsr $1a573c	            JSR OP_FP_MUL
.1a28a7	20 79 64	jsr $1a6479	            JSR FP_EXP
.1a28aa	68		pla		done        PLA
.1a28ab	28		plp		            PLP
.1a28ac	60		rts		            RTS
.1a28ad					OP_AND
.1a28ad	08		php		            PHP
.1a28ae	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a28b1	20 47 06	jsr $1a0647	            JSR ASS_ARG2_INT
.1a28b4	c2 20		rep #$20	            REP #$20
.1a28b6	a5 23		lda $0823	            LDA ARGUMENT1
.1a28b8	25 29		and $0829	            AND ARGUMENT2
.1a28ba	85 23		sta $0823	            STA ARGUMENT1
.1a28bc	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a28be	25 2b		and $082b	            AND ARGUMENT2+2
.1a28c0	85 25		sta $0825	            STA ARGUMENT1+2
.1a28c2	28		plp		            PLP
.1a28c3	60		rts		            RTS
.1a28c4					OP_OR
.1a28c4	08		php		            PHP
.1a28c5	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a28c8	20 47 06	jsr $1a0647	            JSR ASS_ARG2_INT
.1a28cb	c2 20		rep #$20	            REP #$20
.1a28cd	a5 23		lda $0823	            LDA ARGUMENT1
.1a28cf	05 29		ora $0829	            ORA ARGUMENT2
.1a28d1	85 23		sta $0823	            STA ARGUMENT1
.1a28d3	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a28d5	05 2b		ora $082b	            ORA ARGUMENT2+2
.1a28d7	85 25		sta $0825	            STA ARGUMENT1+2
.1a28d9	28		plp		done        PLP
.1a28da	60		rts		            RTS
.1a28db					OP_NOT
.1a28db	08		php		            PHP
.1a28dc	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a28df	c2 20		rep #$20	            REP #$20
.1a28e1	a5 23		lda $0823	            LDA ARGUMENT1
.1a28e3	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a28e6	85 23		sta $0823	            STA ARGUMENT1
.1a28e8	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a28ea	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a28ed	85 25		sta $0825	            STA ARGUMENT1+2
.1a28ef	28		plp		done        PLP
.1a28f0	60		rts		            RTS
.1a28f1					OP_LT
.1a28f1	08		php		            PHP
.1a28f2	e2 20		sep #$20	            SEP #$20
.1a28f4	20 68 08	jsr $1a0868	            JSR ASS_ARGS_NUMSTR
.1a28f7	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a28f9	f0 2c		beq $1a2927	            BEQ is_integer
.1a28fb	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a28fd	f0 2d		beq $1a292c	            BEQ is_float
.1a28ff	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a2901	f0 1f		beq $1a2922	            BEQ is_string
.1a2903					type_error
.1a2903	08		php		            PHP
.1a2904	c2 20		rep #$20	            REP #$20
.1a2906	48		pha		            PHA
.1a2907	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a290a	5b		tcd		            TCD
.1a290b	68		pla		            PLA
.1a290c	28		plp		            PLP
.1a290d	e2 20		sep #$20	            SEP #$20
.1a290f	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2911	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2915	c2 20		rep #$20	            REP #$20
.1a2917	29 ff 00	and #$00ff	            AND #$00FF
.1a291a	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a291d	e2 20		sep #$20	            SEP #$20
.1a291f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2922					is_string
.1a2922	20 9e 17	jsr $1a179e	            JSR OP_STR_LT
.1a2925	80 08		bra $1a292f	            BRA done
.1a2927					is_integer
.1a2927	20 5c 55	jsr $1a555c	            JSR OP_INT_LT
.1a292a	80 03		bra $1a292f	            BRA done
.1a292c					is_float
.1a292c	20 d1 5c	jsr $1a5cd1	            JSR OP_FP_LT
.1a292f	28		plp		done        PLP
.1a2930	60		rts		            RTS
.1a2931					OP_GT
.1a2931	08		php		            PHP
.1a2932	e2 20		sep #$20	            SEP #$20
.1a2934	20 68 08	jsr $1a0868	            JSR ASS_ARGS_NUMSTR
.1a2937	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a2939	f0 2c		beq $1a2967	            BEQ is_integer
.1a293b	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a293d	f0 2d		beq $1a296c	            BEQ is_float
.1a293f	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a2941	f0 1f		beq $1a2962	            BEQ is_string
.1a2943					type_error
.1a2943	08		php		            PHP
.1a2944	c2 20		rep #$20	            REP #$20
.1a2946	48		pha		            PHA
.1a2947	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a294a	5b		tcd		            TCD
.1a294b	68		pla		            PLA
.1a294c	28		plp		            PLP
.1a294d	e2 20		sep #$20	            SEP #$20
.1a294f	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2951	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2955	c2 20		rep #$20	            REP #$20
.1a2957	29 ff 00	and #$00ff	            AND #$00FF
.1a295a	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a295d	e2 20		sep #$20	            SEP #$20
.1a295f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2962					is_string
.1a2962	20 b5 17	jsr $1a17b5	            JSR OP_STR_GT
.1a2965	80 08		bra $1a296f	            BRA done
.1a2967					is_integer
.1a2967	20 7d 55	jsr $1a557d	            JSR OP_INT_GT
.1a296a	80 03		bra $1a296f	            BRA done
.1a296c					is_float
.1a296c	20 e6 5c	jsr $1a5ce6	            JSR OP_FP_GT
.1a296f	28		plp		done        PLP
.1a2970	60		rts		            RTS
.1a2971					OP_EQ
.1a2971	08		php		            PHP
.1a2972	e2 20		sep #$20	            SEP #$20
.1a2974	20 68 08	jsr $1a0868	            JSR ASS_ARGS_NUMSTR
.1a2977	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a2979	f0 2c		beq $1a29a7	            BEQ is_integer
.1a297b	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a297d	f0 2d		beq $1a29ac	            BEQ is_float
.1a297f	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a2981	f0 1f		beq $1a29a2	            BEQ is_string
.1a2983					type_error
.1a2983	08		php		            PHP
.1a2984	c2 20		rep #$20	            REP #$20
.1a2986	48		pha		            PHA
.1a2987	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a298a	5b		tcd		            TCD
.1a298b	68		pla		            PLA
.1a298c	28		plp		            PLP
.1a298d	e2 20		sep #$20	            SEP #$20
.1a298f	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2991	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2995	c2 20		rep #$20	            REP #$20
.1a2997	29 ff 00	and #$00ff	            AND #$00FF
.1a299a	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a299d	e2 20		sep #$20	            SEP #$20
.1a299f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a29a2					is_string
.1a29a2	20 cc 17	jsr $1a17cc	            JSR OP_STR_EQ
.1a29a5	80 08		bra $1a29af	            BRA done
.1a29a7					is_integer
.1a29a7	20 aa 55	jsr $1a55aa	            JSR OP_INT_EQ
.1a29aa	80 03		bra $1a29af	            BRA done
.1a29ac					is_float
.1a29ac	20 fb 5c	jsr $1a5cfb	            JSR OP_FP_EQ
.1a29af	28		plp		done        PLP
.1a29b0	60		rts		            RTS
.1a29b1					OP_NE
.1a29b1	08		php		            PHP
.1a29b2	e2 20		sep #$20	            SEP #$20
.1a29b4	20 68 08	jsr $1a0868	            JSR ASS_ARGS_NUMSTR
.1a29b7	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a29b9	f0 2c		beq $1a29e7	            BEQ is_integer
.1a29bb	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a29bd	f0 2d		beq $1a29ec	            BEQ is_float
.1a29bf	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a29c1	f0 1f		beq $1a29e2	            BEQ is_string
.1a29c3					type_error
.1a29c3	08		php		            PHP
.1a29c4	c2 20		rep #$20	            REP #$20
.1a29c6	48		pha		            PHA
.1a29c7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a29ca	5b		tcd		            TCD
.1a29cb	68		pla		            PLA
.1a29cc	28		plp		            PLP
.1a29cd	e2 20		sep #$20	            SEP #$20
.1a29cf	a9 04		lda #$04	            LDA #ERR_TYPE
.1a29d1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a29d5	c2 20		rep #$20	            REP #$20
.1a29d7	29 ff 00	and #$00ff	            AND #$00FF
.1a29da	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a29dd	e2 20		sep #$20	            SEP #$20
.1a29df	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a29e2					is_string
.1a29e2	20 e3 17	jsr $1a17e3	            JSR OP_STR_NE
.1a29e5	80 08		bra $1a29ef	            BRA done
.1a29e7					is_integer
.1a29e7	20 c8 55	jsr $1a55c8	            JSR OP_INT_NE
.1a29ea	80 03		bra $1a29ef	            BRA done
.1a29ec					is_float
.1a29ec	20 3a 5d	jsr $1a5d3a	            JSR OP_FP_NE
.1a29ef	28		plp		done        PLP
.1a29f0	60		rts		            RTS
.1a29f1					OP_GTE
.1a29f1	08		php		            PHP
.1a29f2	e2 20		sep #$20	            SEP #$20
.1a29f4	20 68 08	jsr $1a0868	            JSR ASS_ARGS_NUMSTR
.1a29f7	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a29f9	f0 2c		beq $1a2a27	            BEQ is_integer
.1a29fb	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a29fd	f0 2d		beq $1a2a2c	            BEQ is_float
.1a29ff	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a2a01	f0 1f		beq $1a2a22	            BEQ is_string
.1a2a03					type_error
.1a2a03	08		php		            PHP
.1a2a04	c2 20		rep #$20	            REP #$20
.1a2a06	48		pha		            PHA
.1a2a07	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2a0a	5b		tcd		            TCD
.1a2a0b	68		pla		            PLA
.1a2a0c	28		plp		            PLP
.1a2a0d	e2 20		sep #$20	            SEP #$20
.1a2a0f	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2a11	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2a15	c2 20		rep #$20	            REP #$20
.1a2a17	29 ff 00	and #$00ff	            AND #$00FF
.1a2a1a	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a2a1d	e2 20		sep #$20	            SEP #$20
.1a2a1f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2a22					is_string
.1a2a22	20 fa 17	jsr $1a17fa	            JSR OP_STR_GTE
.1a2a25	80 08		bra $1a2a2f	            BRA done
.1a2a27					is_integer
.1a2a27	20 e6 55	jsr $1a55e6	            JSR OP_INT_GTE
.1a2a2a	80 03		bra $1a2a2f	            BRA done
.1a2a2c					is_float
.1a2a2c	20 25 5d	jsr $1a5d25	            JSR OP_FP_GTE
.1a2a2f	28		plp		done        PLP
.1a2a30	60		rts		            RTS
.1a2a31					OP_LTE
.1a2a31	08		php		            PHP
.1a2a32	e2 20		sep #$20	            SEP #$20
.1a2a34	20 68 08	jsr $1a0868	            JSR ASS_ARGS_NUMSTR
.1a2a37	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a2a39	f0 2c		beq $1a2a67	            BEQ is_integer
.1a2a3b	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2a3d	f0 2d		beq $1a2a6c	            BEQ is_float
.1a2a3f	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a2a41	f0 1f		beq $1a2a62	            BEQ is_string
.1a2a43					type_error
.1a2a43	08		php		            PHP
.1a2a44	c2 20		rep #$20	            REP #$20
.1a2a46	48		pha		            PHA
.1a2a47	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2a4a	5b		tcd		            TCD
.1a2a4b	68		pla		            PLA
.1a2a4c	28		plp		            PLP
.1a2a4d	e2 20		sep #$20	            SEP #$20
.1a2a4f	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2a51	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2a55	c2 20		rep #$20	            REP #$20
.1a2a57	29 ff 00	and #$00ff	            AND #$00FF
.1a2a5a	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a2a5d	e2 20		sep #$20	            SEP #$20
.1a2a5f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2a62					is_string
.1a2a62	20 11 18	jsr $1a1811	            JSR OP_STR_LTE
.1a2a65	80 08		bra $1a2a6f	            BRA done
.1a2a67					is_integer
.1a2a67	20 13 56	jsr $1a5613	            JSR OP_INT_LTE
.1a2a6a	80 03		bra $1a2a6f	            BRA done
.1a2a6c					is_float
.1a2a6c	20 10 5d	jsr $1a5d10	            JSR OP_FP_LTE
.1a2a6f	28		plp		done        PLP
.1a2a70	60		rts		            RTS
.1a2a71					OP_NEGATIVE
.1a2a71	08		php		                PHP
.1a2a72	e2 20		sep #$20	            SEP #$20
.1a2a74	a5 27		lda $0827	                LDA ARGTYPE1                ; Check the type of the argument
.1a2a76	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a2a78	f0 2d		beq $1a2aa7	                BEQ int_negate              ; If integer: negate the integer
.1a2a7a	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.1a2a7c	f0 1f		beq $1a2a9d	                BEQ float_negate            ; If floating point: negate the floating point
.1a2a7e					type_error
.1a2a7e	08		php		            PHP
.1a2a7f	c2 20		rep #$20	            REP #$20
.1a2a81	48		pha		            PHA
.1a2a82	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2a85	5b		tcd		            TCD
.1a2a86	68		pla		            PLA
.1a2a87	28		plp		            PLP
.1a2a88	e2 20		sep #$20	            SEP #$20
.1a2a8a	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2a8c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2a90	c2 20		rep #$20	            REP #$20
.1a2a92	29 ff 00	and #$00ff	            AND #$00FF
.1a2a95	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a2a98	e2 20		sep #$20	            SEP #$20
.1a2a9a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2a9d					float_negate
.1a2a9d	e2 20		sep #$20	            SEP #$20
.1a2a9f	a5 26		lda $0826	                LDA ARGUMENT1+3             ; Flip the sign bit of the floating point number
.1a2aa1	49 80		eor #$80	                EOR #$80
.1a2aa3	85 26		sta $0826	                STA ARGUMENT1+3
.1a2aa5	80 16		bra $1a2abd	                BRA done
.1a2aa7					int_negate
.1a2aa7	c2 20		rep #$20	            REP #$20
.1a2aa9	a5 23		lda $0823	                LDA ARGUMENT1               ; Invert ARGUMENT1
.1a2aab	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a2aae	85 23		sta $0823	                STA ARGUMENT1
.1a2ab0	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a2ab2	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a2ab5	85 25		sta $0825	                STA ARGUMENT1+2
.1a2ab7	e6 23		inc $0823	                INC ARGUMENT1               ; And increment to get two's complement
.1a2ab9	d0 02		bne $1a2abd	                BNE done
.1a2abb	e6 25		inc $0825	                INC ARGUMENT1+2
.1a2abd					done
.1a2abd	28		plp		                PLP
.1a2abe	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\statements.s


;******  Processing file: src\C256/statements_c256.s

=0					GR_LUT_BLUE = 0
=1					GR_LUT_GREEN = 1
=2					GR_LUT_RED = 2
=3					GR_LUT_ALPHA = 3
=640					GR_DEFAULT_COLS = 640               ; Default number of columns in the display
=480					GR_DEFAULT_ROWS = 480               ; Default number of rows in the display
=8					GR_MAX_LUT = 8                      ; The number of LUTs Vicky supports
=64					SP_MAX = 64                         ; The number of sprites Vicky supports
=8					SP_REG_SIZE = 8                     ; The number of bytes in a sprite's register block
=0					SP_CONTROL = 0                      ; Offset of the control regsiter for a sprite
=1					SP_ADDR = 1                         ; Offset of the pixmap address for a sprite
=4					SP_X_COORD = 4                      ; Offset of the X coordinate for a sprite
=6					SP_Y_COORD = 6                      ; Offset of the Y coordinate for a sprite
=12					TILEMAP_REG_SIZE = 12               ; The number of bytes in a tile map's register set
=4					TILESET_REG_SIZE = 4                ; The number of bytes in a tile set's register set
=2					BM_MAX = 2                          ; Maximum number of bitmaps we support
=$0040					MAX_VRAM_VICKY = $0040              ; Upper limit (exclusive) bank address for VRAM in Vicky address space
=$00f0					MAX_VRAM_CPU = $00F0                ; Upper limit (exclusive) bank address for VRAM in CPU address space
=$00b0					MIN_VRAM_CPU = $00B0                ; Lower limit (inclusive) bank address for VRAM in CPU address space
>1af000					GR_BM0_ADDR     .dword ?            ; Address of bitmap 0 (from CPU's perspective)
>1af004					GR_BM1_ADDR     .dword ?            ; Address of bitmap 1 (from CPU's perspective)
>1af008					GR_BM0_VRAM     .dword ?            ; Address of bitmap 0 (relative to start of VRAM)
>1af00c					GR_BM1_VRAM     .dword ?            ; Address of bitmap 1 (relative to start of VRAM)
>1af010					GR_MAX_COLS     .word ?             ; Width the display in pixels
>1af012					GR_MAX_ROWS     .word ?             ; Height of the display in pixels
>1af014					GR_TOTAL_PIXELS .word ?             ; Total number of pixels in the display
>1af016					GR_TEMP         .word ?             ; A temporary word for graphics commands
>1af018					GS_SP_CONTROL   .fill SP_MAX        ; Shadow registers for the sprite controls
.1a2abf					S_SETTIME
.1a2abf	08		php		                PHP
.1a2ac0	e2 20		sep #$20	            SEP #$20
.1a2ac2	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2ac5	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2ac8	20 73 05	jsr $1a0573	            JSR DIVINT10
.1a2acb	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2acd	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2ace	0a		asl a		                ASL A
.1a2acf	0a		asl a		                ASL A
.1a2ad0	0a		asl a		                ASL A
.1a2ad1	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2ad3	48		pha		                PHA
.1a2ad4	a9 2c		lda #$2c	                LDA #','
.1a2ad6	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a2ad9	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2adc	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2adf	20 73 05	jsr $1a0573	            JSR DIVINT10
.1a2ae2	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2ae4	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2ae5	0a		asl a		                ASL A
.1a2ae6	0a		asl a		                ASL A
.1a2ae7	0a		asl a		                ASL A
.1a2ae8	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2aea	48		pha		                PHA
.1a2aeb	a9 2c		lda #$2c	                LDA #','
.1a2aed	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a2af0	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2af3	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2af6	20 73 05	jsr $1a0573	            JSR DIVINT10
.1a2af9	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2afb	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2afc	0a		asl a		                ASL A
.1a2afd	0a		asl a		                ASL A
.1a2afe	0a		asl a		                ASL A
.1a2aff	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2b01	48		pha		                PHA
.1a2b02	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a2b06	09 0c		ora #$0c	                ORA #%00001100
.1a2b08	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2b0c	68		pla		                PLA                     ; And seconds to the RTC
.1a2b0d	8f 00 08 af	sta $af0800	                STA @lRTC_SEC
.1a2b11	68		pla		                PLA                     ; Minutes...
.1a2b12	8f 02 08 af	sta $af0802	                STA @lRTC_MIN
.1a2b16	68		pla		                PLA                     ; Save the hour...
.1a2b17	8f 04 08 af	sta $af0804	                STA @lRTC_HRS
.1a2b1b	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a2b1f	29 f7		and #$f7	                AND #%11110111
.1a2b21	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2b25	20 27 21	jsr $1a2127	            JSR SKIPSTMT
.1a2b28	28		plp		                PLP
.1a2b29	60		rts		            RTS
.1a2b2a					S_SETDATE
.1a2b2a	08		php		                PHP
.1a2b2b	e2 20		sep #$20	            SEP #$20
.1a2b2d	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2b30	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2b33	20 73 05	jsr $1a0573	            JSR DIVINT10
.1a2b36	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2b38	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2b39	0a		asl a		                ASL A
.1a2b3a	0a		asl a		                ASL A
.1a2b3b	0a		asl a		                ASL A
.1a2b3c	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2b3e	48		pha		                PHA
.1a2b3f	a9 2c		lda #$2c	                LDA #','
.1a2b41	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a2b44	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2b47	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2b4a	20 73 05	jsr $1a0573	            JSR DIVINT10
.1a2b4d	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2b4f	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2b50	0a		asl a		                ASL A
.1a2b51	0a		asl a		                ASL A
.1a2b52	0a		asl a		                ASL A
.1a2b53	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2b55	48		pha		                PHA
.1a2b56	a9 2c		lda #$2c	                LDA #','
.1a2b58	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a2b5b	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2b5e	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a2b61	20 a9 05	jsr $1a05a9	            JSR DIVINT100
.1a2b64	c2 20		rep #$20	            REP #$20
.1a2b66	a5 23		lda $0823	                LDA ARGUMENT1           ; Get the century
.1a2b68	85 92		sta $0892	                STA MTEMP               ; Save it in MTEMP
.1a2b6a	a5 29		lda $0829	                LDA ARGUMENT2           ; Separate the 10s from the 1s digits
.1a2b6c	85 23		sta $0823	                STA ARGUMENT1
.1a2b6e	20 73 05	jsr $1a0573	            JSR DIVINT10
.1a2b71	e2 20		sep #$20	            SEP #$20
.1a2b73	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2b75	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2b76	0a		asl a		                ASL A
.1a2b77	0a		asl a		                ASL A
.1a2b78	0a		asl a		                ASL A
.1a2b79	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2b7b	48		pha		                PHA                     ; Save the 10s and 1s in BCD
.1a2b7c	c2 20		rep #$20	            REP #$20
.1a2b7e	a5 92		lda $0892	                LDA MTEMP               ; Separate the 100s from the 1000s digits
.1a2b80	85 23		sta $0823	                STA ARGUMENT1
.1a2b82	20 73 05	jsr $1a0573	            JSR DIVINT10
.1a2b85	e2 20		sep #$20	            SEP #$20
.1a2b87	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2b89	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2b8a	0a		asl a		                ASL A
.1a2b8b	0a		asl a		                ASL A
.1a2b8c	0a		asl a		                ASL A
.1a2b8d	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2b8f	48		pha		                PHA                     ; Save the 100s and 1000s in BCD
.1a2b90	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a2b94	09 0c		ora #$0c	                ORA #%00001100
.1a2b96	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2b9a	68		pla		                PLA                     ; Set the century
.1a2b9b	8f 0f 08 af	sta $af080f	                STA @lRTC_CENTURY
.1a2b9f	68		pla		                PLA                     ; And year to the RTC
.1a2ba0	8f 0a 08 af	sta $af080a	                STA @lRTC_YEAR
.1a2ba4	68		pla		                PLA                     ; Month...
.1a2ba5	8f 09 08 af	sta $af0809	                STA @lRTC_MONTH
.1a2ba9	68		pla		                PLA                     ; Save the day...
.1a2baa	8f 06 08 af	sta $af0806	                STA @lRTC_DAY
.1a2bae	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a2bb2	29 f7		and #$f7	                AND #%11110111
.1a2bb4	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2bb8	20 27 21	jsr $1a2127	            JSR SKIPSTMT
.1a2bbb	28		plp		                PLP
.1a2bbc	60		rts		            RTS
.1a2bbd					S_TEXTCOLOR
.1a2bbd	08		php		                PHP
.1a2bbe					locals
>0001					L_FOREGROUND    .byte ?
.1a2bbe	e2 20		sep #$20	            SEP #$20
.1a2bc0	48		pha		            PHA
.1a2bc1	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2bc4	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2bc7	e2 20		sep #$20	            SEP #$20
.1a2bc9	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the foreground position
.1a2bcb	29 0f		and #$0f	                AND #$0F
.1a2bcd	0a		asl a		                ASL A
.1a2bce	0a		asl a		                ASL A
.1a2bcf	0a		asl a		                ASL A
.1a2bd0	0a		asl a		                ASL A
.1a2bd1	83 01		sta $01,s	                STA L_FOREGROUND    ; Save the foreground color
.1a2bd3	a9 2c		lda #$2c	                LDA #','
.1a2bd5	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a2bd8	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2bdb	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2bde	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the background position
.1a2be0	29 0f		and #$0f	                AND #$0F
.1a2be2	03 01		ora $01,s	                ORA L_FOREGROUND    ; Add in the foreground
.1a2be4	8f 1e 00 00	sta $00001e	                STA @lCURCOLOR      ; And save the new color combination
.1a2be8	e2 20		sep #$20	            SEP #$20
.1a2bea	68		pla		            PLA
.1a2beb	28		plp		                PLP
.1a2bec	60		rts		            RTS
.1a2bed					S_SETBGCOLOR
.1a2bed	08		php		                PHP
.1a2bee					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.1a2bee	c2 20		rep #$20	            REP #$20
.1a2bf0	f4 00 00	pea #$0000	            PEA #0
.1a2bf3	e2 20		sep #$20	            SEP #$20
.1a2bf5	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2bf8	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2bfb	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.1a2bfd	83 01		sta $01,s	                STA L_RED
.1a2bff	a9 2c		lda #$2c	                LDA #','
.1a2c01	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a2c04	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2c07	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2c0a	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.1a2c0c	83 02		sta $02,s	                STA L_GREEN
.1a2c0e	a9 2c		lda #$2c	                LDA #','
.1a2c10	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a2c13	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2c16	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2c19	a5 23		lda $0823	                LDA ARGUMENT1               ; And set the actual color
.1a2c1b	8f 0d 00 af	sta $af000d	                STA @lBACKGROUND_COLOR_B
.1a2c1f	a3 02		lda $02,s	                LDA L_GREEN
.1a2c21	8f 0e 00 af	sta $af000e	                STA @lBACKGROUND_COLOR_G
.1a2c25	a3 01		lda $01,s	                LDA L_RED
.1a2c27	8f 0f 00 af	sta $af000f	                STA @lBACKGROUND_COLOR_R
.1a2c2b	c2 20		rep #$20	            REP #$20
.1a2c2d	68		pla		            PLA
.1a2c2e	28		plp		                PLP
.1a2c2f	60		rts		            RTS
.1a2c30					S_SETBORDER
.1a2c30	08		php		                PHP
.1a2c31					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.1a2c31	c2 20		rep #$20	            REP #$20
.1a2c33	f4 00 00	pea #$0000	            PEA #0
.1a2c36	e2 20		sep #$20	            SEP #$20
.1a2c38	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2c3b	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a2c3e	a5 23		lda $0823	                LDA ARGUMENT1
.1a2c40	f0 16		beq $1a2c58	                BEQ hide_border
.1a2c42	a9 01		lda #$01	                LDA #Border_Ctrl_Enable     ; Enable the border
.1a2c44	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.1a2c48	a9 20		lda #$20	                LDA #BORDER_WIDTH           ; Set the border width
.1a2c4a	8f 08 00 af	sta $af0008	                STA BORDER_X_SIZE
.1a2c4e	8f 09 00 af	sta $af0009	                STA BORDER_Y_SIZE
.1a2c52	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.1a2c56	80 0a		bra $1a2c62	                BRA get_color
.1a2c58	a9 00		lda #$00	hide_border     LDA #0                      ; Hide the border
.1a2c5a	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.1a2c5e	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.1a2c62	a9 2c		lda #$2c	get_color       LDA #','
.1a2c64	85 37		sta $0837	                STA TARGETTOK
.1a2c66	20 24 22	jsr $1a2224	            JSR OPT_TOK
.1a2c69	90 39		bcc $1a2ca4	                BCC done                    ; No: we're done
.1a2c6b	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a2c6e	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2c71	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2c74	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.1a2c76	83 01		sta $01,s	                STA L_RED
.1a2c78	a9 2c		lda #$2c	                LDA #','
.1a2c7a	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a2c7d	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2c80	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2c83	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.1a2c85	83 02		sta $02,s	                STA L_GREEN
.1a2c87	a9 2c		lda #$2c	                LDA #','
.1a2c89	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a2c8c	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2c8f	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2c92	a5 23		lda $0823	                LDA ARGUMENT1
.1a2c94	8f 05 00 af	sta $af0005	                STA @lBORDER_COLOR_B        ; Set the border color
.1a2c98	a3 02		lda $02,s	                LDA L_GREEN
.1a2c9a	8f 06 00 af	sta $af0006	                STA @lBORDER_COLOR_G
.1a2c9e	a3 01		lda $01,s	                LDA L_RED
.1a2ca0	8f 07 00 af	sta $af0007	                STA @lBORDER_COLOR_R
.1a2ca4					done
.1a2ca4	c2 20		rep #$20	            REP #$20
.1a2ca6	68		pla		            PLA
.1a2ca7	28		plp		                PLP
.1a2ca8	60		rts		            RTS
.1a2ca9					S_SETCOLOR
.1a2ca9	08		php		                PHP
.1a2caa					locals
>0001					L_LUT           .byte ?
>0002					L_COLOR         .byte ?
>0003					L_RED           .byte ?
>0004					L_GREEN         .byte ?
>0005					L_BLUE          .byte ?
.1a2caa	c2 20		rep #$20	            REP #$20
.1a2cac	3b		tsc		            TSC
.1a2cad	38		sec		            SEC
.1a2cae	e9 05 00	sbc #$0005	            SBC #SIZE(locals)
.1a2cb1	1b		tcs		            TCS
.1a2cb2	e2 20		sep #$20	            SEP #$20
.1a2cb4	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2cb7	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2cba	a5 23		lda $0823	                LDA ARGUMENT1
.1a2cbc	c9 0a		cmp #$0a	                CMP #10             ; And in range
.1a2cbe	90 1f		bcc $1a2cdf	                BLT save_lut
.1a2cc0					bad_argument
.1a2cc0	08		php		            PHP
.1a2cc1	c2 20		rep #$20	            REP #$20
.1a2cc3	48		pha		            PHA
.1a2cc4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2cc7	5b		tcd		            TCD
.1a2cc8	68		pla		            PLA
.1a2cc9	28		plp		            PLP
.1a2cca	e2 20		sep #$20	            SEP #$20
.1a2ccc	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a2cce	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2cd2	c2 20		rep #$20	            REP #$20
.1a2cd4	29 ff 00	and #$00ff	            AND #$00FF
.1a2cd7	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a2cda	e2 20		sep #$20	            SEP #$20
.1a2cdc	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2cdf	83 01		sta $01,s	save_lut        STA L_LUT           ; Save as LUT
.1a2ce1	a9 2c		lda #$2c	                LDA #','
.1a2ce3	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a2ce6	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2ce9	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2cec	a5 23		lda $0823	                LDA ARGUMENT1
.1a2cee	83 02		sta $02,s	                STA L_COLOR         ; Save as COLOR
.1a2cf0	a9 2c		lda #$2c	                LDA #','
.1a2cf2	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a2cf5	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2cf8	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2cfb	a5 23		lda $0823	                LDA ARGUMENT1
.1a2cfd	83 03		sta $03,s	                STA L_RED           ; Save as RED
.1a2cff	a9 2c		lda #$2c	                LDA #','
.1a2d01	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a2d04	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2d07	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2d0a	a5 23		lda $0823	                LDA ARGUMENT1
.1a2d0c	83 04		sta $04,s	                STA L_GREEN         ; Save it as GREEN
.1a2d0e	a9 2c		lda #$2c	                LDA #','
.1a2d10	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a2d13	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2d16	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2d19	a5 23		lda $0823	                LDA ARGUMENT1
.1a2d1b	83 05		sta $05,s	                STA L_BLUE          ; Save it as BLUE
.1a2d1d	a9 af		lda #$af	                LDA #`GRPH_LUT0_PTR ; Get the bank Vicky is in (should always be $AF)
.1a2d1f	85 a0		sta $08a0	                STA MTEMPPTR+2      ; MTEMPPTR will be our pointer to the LUT entry
.1a2d21	a3 01		lda $01,s	                LDA L_LUT           ; Compute the offset to the LUT address
.1a2d23	0a		asl a		                ASL A
.1a2d24	c2 20		rep #$20	            REP #$20
.1a2d26	29 ff 00	and #$00ff	                AND #$00FF
.1a2d29	aa		tax		                TAX                 ; Put it in X
.1a2d2a	bf 61 2d 1a	lda $1a2d61,x	                LDA @llut_address,X ; Get the address of the LUT
.1a2d2e	85 9e		sta $089e	                STA MTEMPPTR        ; Put it in MTEMPPTR
.1a2d30	e2 20		sep #$20	            SEP #$20
.1a2d32	a3 02		lda $02,s	                LDA L_COLOR         ; color index *= 4
.1a2d34	c2 20		rep #$20	            REP #$20
.1a2d36	29 ff 00	and #$00ff	                AND #$00FF
.1a2d39	0a		asl a		                ASL A               ; Since each color has four bytes of data
.1a2d3a	0a		asl a		                ASL A
.1a2d3b	18		clc		                CLC                 ; Add the color offset to MTEMPPTR
.1a2d3c	65 9e		adc $089e	                ADC MTEMPPTR
.1a2d3e	85 9e		sta $089e	                STA MTEMPPTR
.1a2d40	e2 20		sep #$20	            SEP #$20
.1a2d42	a0 02 00	ldy #$0002	                LDY #GR_LUT_RED
.1a2d45	a3 03		lda $03,s	                LDA L_RED
.1a2d47	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the red component to the color entry
.1a2d49	a0 01 00	ldy #$0001	                LDY #GR_LUT_GREEN
.1a2d4c	a3 04		lda $04,s	                LDA L_GREEN
.1a2d4e	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the green component to the color entry
.1a2d50	a0 00 00	ldy #$0000	                LDY #GR_LUT_BLUE
.1a2d53	a3 05		lda $05,s	                LDA L_BLUE
.1a2d55	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the blue component to the color entry
.1a2d57					done
.1a2d57	c2 20		rep #$20	            REP #$20
.1a2d59	3b		tsc		            TSC
.1a2d5a	18		clc		            CLC
.1a2d5b	69 05 00	adc #$0005	            ADC #SIZE(locals)
.1a2d5e	1b		tcs		            TCS
.1a2d5f	28		plp		                PLP
.1a2d60	60		rts		            RTS
>1a2d61	00 20				lut_address     .word <>GRPH_LUT0_PTR
>1a2d63	00 24				                .word <>GRPH_LUT1_PTR
>1a2d65	00 28				                .word <>GRPH_LUT2_PTR
>1a2d67	00 2c				                .word <>GRPH_LUT3_PTR
>1a2d69	00 30				                .word <>GRPH_LUT4_PTR
>1a2d6b	00 34				                .word <>GRPH_LUT5_PTR
>1a2d6d	00 38				                .word <>GRPH_LUT6_PTR
>1a2d6f	00 3c				                .word <>GRPH_LUT7_PTR
>1a2d71	40 1f				                .word <>FG_CHAR_LUT_PTR
>1a2d73	80 1f				                .word <>BG_CHAR_LUT_PTR
.1a2d75					S_GRAPHICS
.1a2d75	da		phx		                PHX
.1a2d76	5a		phy		                PHY
.1a2d77	08		php		                PHP
.1a2d78	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2d7b	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a2d7e	c2 20		rep #$20	            REP #$20
.1a2d80	a5 23		lda $0823	                LDA ARGUMENT1               ; Check to see if we're setting mode to 800x600 or 400x300
.1a2d82	89 00 01	bit #$0100	                BIT #$0100
.1a2d85	d0 17		bne $1a2d9e	                BNE set_mode                ; Yes: go ahead and set it
.1a2d87	af 00 00 af	lda $af0000	                LDA @l MASTER_CTRL_REG_L    ; Otherwise, check to see if we're already in 800x600 or 400x300
.1a2d8b	89 00 01	bit #$0100	                BIT #$0100
.1a2d8e	f0 0e		beq $1a2d9e	                BEQ set_mode                ; No: just go ahead and set the mode
.1a2d90	e2 20		sep #$20	            SEP #$20
.1a2d92	a9 00		lda #$00	                LDA #0                      ; Yes: toggle back to 640x480...
.1a2d94	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.1a2d98	a9 01		lda #$01	                LDA #1                      ; And back to 800x600....
.1a2d9a	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.1a2d9e					set_mode
.1a2d9e	c2 20		rep #$20	            REP #$20
.1a2da0	a5 23		lda $0823	                LDA ARGUMENT1
.1a2da2	8f 00 00 af	sta $af0000	                STA @l MASTER_CTRL_REG_L    ; Set the graphics mode
.1a2da6	e2 20		sep #$20	            SEP #$20
.1a2da8	a5 24		lda $0824	                LDA ARGUMENT1+1             ; Get the screen size bits
.1a2daa	c2 20		rep #$20	            REP #$20
.1a2dac	29 03 00	and #$0003	                AND #$0003
.1a2daf	0a		asl a		                ASL A                       ; Multiply by two to get the index
.1a2db0	aa		tax		                TAX                         ; X is index into the size tables
.1a2db1	c2 20		rep #$20	            REP #$20
.1a2db3	bf fc 2d 1a	lda $1a2dfc,x	                LDA gr_columns,X            ; Set the columns
.1a2db7	8f 10 f0 1a	sta $1af010	                STA @lGR_MAX_COLS
.1a2dbb	bf 04 2e 1a	lda $1a2e04,x	                LDA gr_rows,X               ; Set the rows
.1a2dbf	8f 12 f0 1a	sta $1af012	                STA @lGR_MAX_ROWS
.1a2dc3	af 10 f0 1a	lda $1af010	                LDA @lGR_MAX_COLS           ; Get the current columns
.1a2dc7	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.1a2dcb	af 12 f0 1a	lda $1af012	                LDA @lGR_MAX_ROWS           ; Get the current rows
.1a2dcf	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B
.1a2dd3	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT             ; Multiply them to get the total pixels
.1a2dd7	8f 14 f0 1a	sta $1af014	                STA @lGR_TOTAL_PIXELS
.1a2ddb	e2 20		sep #$20	            SEP #$20
.1a2ddd	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.1a2de1	8f 16 f0 1a	sta $1af016	                STA @lGR_TOTAL_PIXELS+2
.1a2de5	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.1a2de9					reset_cursor
.1a2de9	c2 20		rep #$20	            REP #$20
.1a2deb	af 1a 00 00	lda $00001a	                LDA @lCURSORX
.1a2def	aa		tax		                TAX
.1a2df0	af 1c 00 00	lda $00001c	                LDA @lCURSORY
.1a2df4	a8		tay		                TAY
.1a2df5	20 20 00	jsr $1a0020	            JSR CURSORXY
.1a2df8	28		plp		                PLP
.1a2df9	7a		ply		                PLY
.1a2dfa	fa		plx		                PLX
.1a2dfb	60		rts		            RTS
>1a2dfc	80 02 20 03 40 01 90 01		gr_columns      .word 640,800,320,400
>1a2e04	e0 01 58 02 f0 00 2c 01		gr_rows         .word 480,600,240,300
>1a2e0c	50 00 64 00 28 00 32 00		col_count       .word 80,100,40,50
>1a2e14	3c 00 4b 00 1e 00 32 00		row_count       .word 60,75,30,50
>1a2e1c	48 00 5c 00 20 00 2a 00		colb_count      .word 72,92,32,42
>1a2e24	34 00 43 00 16 00 34 00		rowb_count      .word 52,67,22,52
.1a2e2c					BITMAP_SRAM
.1a2e2c	da		phx		                PHX
.1a2e2d	08		php		                PHP
.1a2e2e	c2 30		rep #$30	            REP #$30
.1a2e30	c9 02 00	cmp #$0002	                CMP #BM_MAX
.1a2e33	b0 1c		bcs $1a2e51	                BGE range_err           ; Make sure it's within range
.1a2e35	0a		asl a		                ASL A
.1a2e36	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.1a2e37	aa		tax		                TAX
.1a2e38	bf 00 f0 1a	lda $1af000,x	                LDA @l GR_BM0_ADDR,X    ; Get the low 16-bits of the address
.1a2e3c	85 9e		sta $089e	                STA MTEMPPTR
.1a2e3e	bf 02 f0 1a	lda $1af002,x	                LDA @l GR_BM0_ADDR+2,X  ; Get the high bits of the address
.1a2e42	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a2e44	c9 f0 00	cmp #$00f0	                CMP #MAX_VRAM_CPU       ; Check to make sure address is within VRAM
.1a2e47	b0 08		bcs $1a2e51	                BGE range_err
.1a2e49	c9 b0 00	cmp #$00b0	                CMP #MIN_VRAM_CPU
.1a2e4c	90 03		bcc $1a2e51	                BLT range_err
.1a2e4e	28		plp		                PLP
.1a2e4f	fa		plx		                PLX
.1a2e50	60		rts		            RTS
.1a2e51					range_err
.1a2e51	08		php		            PHP
.1a2e52	c2 20		rep #$20	            REP #$20
.1a2e54	48		pha		            PHA
.1a2e55	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2e58	5b		tcd		            TCD
.1a2e59	68		pla		            PLA
.1a2e5a	28		plp		            PLP
.1a2e5b	e2 20		sep #$20	            SEP #$20
.1a2e5d	a9 09		lda #$09	            LDA #ERR_RANGE
.1a2e5f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2e63	c2 20		rep #$20	            REP #$20
.1a2e65	29 ff 00	and #$00ff	            AND #$00FF
.1a2e68	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a2e6b	e2 20		sep #$20	            SEP #$20
.1a2e6d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2e70					BITMAP_VRAM
.1a2e70	da		phx		                PHX
.1a2e71	08		php		                PHP
.1a2e72	c2 30		rep #$30	            REP #$30
.1a2e74	c9 02 00	cmp #$0002	                CMP #BM_MAX
.1a2e77	b0 17		bcs $1a2e90	                BGE range_err           ; Make sure it's within range
.1a2e79	0a		asl a		                ASL A
.1a2e7a	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.1a2e7b	aa		tax		                TAX
.1a2e7c	bf 08 f0 1a	lda $1af008,x	                LDA @l GR_BM0_VRAM,X    ; Get the low 16-bits of the address
.1a2e80	85 9e		sta $089e	                STA MTEMPPTR
.1a2e82	bf 0a f0 1a	lda $1af00a,x	                LDA @l GR_BM0_VRAM+2,X  ; Get the high bits of the address
.1a2e86	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a2e88	c9 40 00	cmp #$0040	                CMP #MAX_VRAM_VICKY     ; Check to make sure the address is from $00:0000 - $3F:FFFF
.1a2e8b	b0 03		bcs $1a2e90	                BGE range_err           ; If not, throw a range error
.1a2e8d	28		plp		                PLP
.1a2e8e	fa		plx		                PLX
.1a2e8f	60		rts		            RTS
.1a2e90					range_err
.1a2e90	08		php		            PHP
.1a2e91	c2 20		rep #$20	            REP #$20
.1a2e93	48		pha		            PHA
.1a2e94	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2e97	5b		tcd		            TCD
.1a2e98	68		pla		            PLA
.1a2e99	28		plp		            PLP
.1a2e9a	e2 20		sep #$20	            SEP #$20
.1a2e9c	a9 09		lda #$09	            LDA #ERR_RANGE
.1a2e9e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2ea2	c2 20		rep #$20	            REP #$20
.1a2ea4	29 ff 00	and #$00ff	            AND #$00FF
.1a2ea7	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a2eaa	e2 20		sep #$20	            SEP #$20
.1a2eac	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2eaf					S_BITMAP
.1a2eaf	08		php		                PHP
.1a2eb0					locals
>0001					L_PLANE         .word ?
>0003					L_VISIBLE       .byte ?
>0004					L_ADDRESS       .dword ?
.1a2eb0	c2 30		rep #$30	            REP #$30
.1a2eb2	3b		tsc		                TSC                         ; Allocate space for the locals on the stack
.1a2eb3	38		sec		                SEC
.1a2eb4	e9 07 00	sbc #$0007	                SBC #SIZE(locals)
.1a2eb7	1b		tcs		                TCS
.1a2eb8	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2ebb	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2ebe	c2 20		rep #$20	            REP #$20
.1a2ec0	a5 23		lda $0823	                LDA ARGUMENT1               ; Make sure it's in range
.1a2ec2	c9 02 00	cmp #$0002	                CMP #BM_MAX
.1a2ec5	b0 59		bcs $1a2f20	                BGE range_err               ; If not, throw an error
.1a2ec7	83 01		sta $01,s	                STA L_PLANE                 ; If so, save it to MARG1
.1a2ec9	e2 20		sep #$20	            SEP #$20
.1a2ecb	a9 2c		lda #$2c	                LDA #','
.1a2ecd	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a2ed0	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2ed3	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2ed6	a5 23		lda $0823	                LDA ARGUMENT1
.1a2ed8	83 03		sta $03,s	                STA L_VISIBLE
.1a2eda	a9 2c		lda #$2c	                LDA #','
.1a2edc	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a2edf	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2ee2	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2ee5	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the number back
.1a2ee7	0a		asl a		                ASL A                       ; Multiply by 8 to get the offset to the registers
.1a2ee8	0a		asl a		                ASL A
.1a2ee9	0a		asl a		                ASL A
.1a2eea	aa		tax		                TAX                         ; And save that offset to X
.1a2eeb	a3 03		lda $03,s	                LDA L_VISIBLE               ; Check the visible flag
.1a2eed	d0 05		bne $1a2ef4	                BNE is_visible              ; If <> 0, it's visible
.1a2eef	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the LUT #
.1a2ef1	0a		asl a		                ASL A                       ; Shift it into position for the register
.1a2ef2	80 04		bra $1a2ef8	                BRA wr_bm_reg               ; And go to write it
.1a2ef4	a5 23		lda $0823	is_visible      LDA ARGUMENT1               ; Get the LUT #
.1a2ef6	38		sec		                SEC
.1a2ef7	2a		rol a		                ROL A                       ; And shift it into position, and set enable bit
.1a2ef8	9f 00 01 af	sta $af0100,x	wr_bm_reg       STA @l BM0_CONTROL_REG,X    ; Write to the bitmap control register
.1a2efc	c2 20		rep #$20	            REP #$20
.1a2efe	a9 2c 00	lda #$002c	                LDA #','
.1a2f01	85 37		sta $0837	                STA TARGETTOK
.1a2f03	20 24 22	jsr $1a2224	            JSR OPT_TOK
.1a2f06	b0 37		bcs $1a2f3f	                BCS get_address             ; Yes: parse the address
.1a2f08	c2 20		rep #$20	            REP #$20
.1a2f0a	08		php		            PHP
.1a2f0b	c2 20		rep #$20	            REP #$20
.1a2f0d	a9 00 00	lda #$0000	            LDA #<>VRAM
.1a2f10	85 23		sta $0823	            STA ARGUMENT1
.1a2f12	a9 b0 00	lda #$00b0	            LDA #(VRAM >> 16)
.1a2f15	85 25		sta $0825	            STA ARGUMENT1+2
.1a2f17	e2 20		sep #$20	            SEP #$20
.1a2f19	a9 00		lda #$00	            LDA #TYPE_INTEGER
.1a2f1b	85 27		sta $0827	            STA ARGUMENT1+4
.1a2f1d	28		plp		            PLP
.1a2f1e	80 27		bra $1a2f47	                BRA set_address
.1a2f20					range_err
.1a2f20	08		php		            PHP
.1a2f21	c2 20		rep #$20	            REP #$20
.1a2f23	48		pha		            PHA
.1a2f24	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2f27	5b		tcd		            TCD
.1a2f28	68		pla		            PLA
.1a2f29	28		plp		            PLP
.1a2f2a	e2 20		sep #$20	            SEP #$20
.1a2f2c	a9 09		lda #$09	            LDA #ERR_RANGE
.1a2f2e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2f32	c2 20		rep #$20	            REP #$20
.1a2f34	29 ff 00	and #$00ff	            AND #$00FF
.1a2f37	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a2f3a	e2 20		sep #$20	            SEP #$20
.1a2f3c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2f3f					get_address
.1a2f3f	c2 20		rep #$20	            REP #$20
.1a2f41	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a2f44	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2f47					set_address
.1a2f47	c2 20		rep #$20	            REP #$20
.1a2f49	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.1a2f4b	0a		asl a		                ASL A                       ; Multiply by four to get the offset to the address variable
.1a2f4c	0a		asl a		                ASL A
.1a2f4d	aa		tax		                TAX                         ; And put it in X
.1a2f4e	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the CPU-space address
.1a2f50	9f 00 f0 1a	sta $1af000,x	                STA @l GR_BM0_ADDR,X        ; And save it to the correct GR_BM?_ADDR variable
.1a2f54	9f 08 f0 1a	sta $1af008,x	                STA @l GR_BM0_VRAM,X
.1a2f58	83 04		sta $04,s	                STA L_ADDRESS               ; And L_ADDRESS, temporarily
.1a2f5a	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a2f5c	9f 02 f0 1a	sta $1af002,x	                STA @l GR_BM0_ADDR+2,X
.1a2f60	38		sec		                SEC
.1a2f61	e9 b0 00	sbc #$00b0	                SBC #`VRAM                  ; Rebase the upper half of the address to Vicky memory space
.1a2f64	9f 0a f0 1a	sta $1af00a,x	                STA @l GR_BM0_VRAM+2,X
.1a2f68	83 06		sta $06,s	                STA L_ADDRESS+2             ; And to L_ADDRESS
.1a2f6a	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.1a2f6c	0a		asl a		                ASL A                       ; Multiply by eight to get the offset to the registers
.1a2f6d	0a		asl a		                ASL A
.1a2f6e	0a		asl a		                ASL A
.1a2f6f	aa		tax		                TAX                         ; And put it in X
.1a2f70	e2 20		sep #$20	            SEP #$20
.1a2f72	a3 04		lda $04,s	                LDA L_ADDRESS               ; Get the address in Vicky space...
.1a2f74	9f 01 01 af	sta $af0101,x	                STA @l BM0_START_ADDY_L,X   ; Save it to the Vicky registers
.1a2f78	a3 05		lda $05,s	                LDA L_ADDRESS+1
.1a2f7a	9f 02 01 af	sta $af0102,x	                STA @l BM0_START_ADDY_M,X
.1a2f7e	a3 06		lda $06,s	                LDA L_ADDRESS+2
.1a2f80	9f 03 01 af	sta $af0103,x	                STA @l BM0_START_ADDY_H,X
.1a2f84	a9 00		lda #$00	                LDA #0                      ; Default offset to (0, 0)
.1a2f86	9f 04 01 af	sta $af0104,x	                STA @l BM0_X_OFFSET,X
.1a2f8a	9f 05 01 af	sta $af0105,x	                STA @l BM0_Y_OFFSET,X
.1a2f8e	c2 30		rep #$30	            REP #$30
.1a2f90	3b		tsc		                TSC                         ; Remove the space for the locals from the stack
.1a2f91	18		clc		                CLC
.1a2f92	69 07 00	adc #$0007	                ADC #SIZE(locals)
.1a2f95	1b		tcs		                TCS
.1a2f96	28		plp		                PLP
.1a2f97	60		rts		            RTS
.1a2f98					bad_address
.1a2f98	08		php		            PHP
.1a2f99	c2 20		rep #$20	            REP #$20
.1a2f9b	48		pha		            PHA
.1a2f9c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2f9f	5b		tcd		            TCD
.1a2fa0	68		pla		            PLA
.1a2fa1	28		plp		            PLP
.1a2fa2	e2 20		sep #$20	            SEP #$20
.1a2fa4	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a2fa6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2faa	c2 20		rep #$20	            REP #$20
.1a2fac	29 ff 00	and #$00ff	            AND #$00FF
.1a2faf	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a2fb2	e2 20		sep #$20	            SEP #$20
.1a2fb4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2fb7					S_CLRBITMAP
.1a2fb7	08		php		                PHP
.1a2fb8	c2 20		rep #$20	            REP #$20
.1a2fba	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a2fbd	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a2fc0	a5 23		lda $0823	                LDA ARGUMENT1
.1a2fc2	20 70 2e	jsr $1a2e70	            JSR BITMAP_VRAM
.1a2fc5	c2 20		rep #$20	            REP #$20
.1a2fc7	a5 9e		lda $089e	                LDA MTEMPPTR                ; Set the start address and the # of pixels to write
.1a2fc9	8f 05 04 af	sta $af0405	                STA @lVDMA_DST_ADDY_L
.1a2fcd	af 14 f0 1a	lda $1af014	                LDA @lGR_TOTAL_PIXELS       ; Set the size
.1a2fd1	8f 08 04 af	sta $af0408	                STA @lVDMA_SIZE_L
.1a2fd5	e2 20		sep #$20	            SEP #$20
.1a2fd7	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.1a2fd9	8f 07 04 af	sta $af0407	                STA @lVDMA_DST_ADDY_H
.1a2fdd	af 16 f0 1a	lda $1af016	                LDA @lGR_TOTAL_PIXELS+2
.1a2fe1	8f 0a 04 af	sta $af040a	                STA @lVDMA_SIZE_H
.1a2fe5	a9 00		lda #$00	                LDA #0                      ; Set the color to write
.1a2fe7	8f 01 04 af	sta $af0401	                STA @lVDMA_BYTE_2_WRITE
.1a2feb	a9 85		lda #$85	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_Start_TRF
.1a2fed	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.1a2ff1	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.1a2ff5	30 fa		bmi $1a2ff1	                BMI wait
.1a2ff7	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.1a2ff9	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.1a2ffd	28		plp		done            PLP
.1a2ffe	60		rts		            RTS
=$000855				COLOR = MARG1
=$000859				X0 = MARG2
=$00085d				Y0 = MARG3
=$000861				X1 = MARG4
=$000865				Y1 = MARG5
=$000869				DX = MARG6
=$00086d				DY = MARG7
=$000871				ERR = MARG8
=$000875				ERR2 = MARG9
>08dd					SX      .word ?
>08df					SY      .word ?
.1a2fff					PLOT
.1a2fff	08		php		                PHP
.1a3000	c2 20		rep #$20	            REP #$20
.1a3002	a5 59		lda $0859	                LDA X0                      ; Get the column
.1a3004	cf 10 f0 1a	cmp $1af010	                CMP @l GR_MAX_COLS          ; Make sure it's in range for this graphics mode
.1a3008	90 1f		bcc $1a3029	                BLT chk_row                 ; If so: check the row
.1a300a					range_err
.1a300a	08		php		            PHP
.1a300b	c2 20		rep #$20	            REP #$20
.1a300d	48		pha		            PHA
.1a300e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3011	5b		tcd		            TCD
.1a3012	68		pla		            PLA
.1a3013	28		plp		            PLP
.1a3014	e2 20		sep #$20	            SEP #$20
.1a3016	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3018	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a301c	c2 20		rep #$20	            REP #$20
.1a301e	29 ff 00	and #$00ff	            AND #$00FF
.1a3021	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a3024	e2 20		sep #$20	            SEP #$20
.1a3026	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3029					chk_row
.1a3029	c2 30		rep #$30	            REP #$30
.1a302b	a5 5d		lda $085d	                LDA Y0                      ; Get the row
.1a302d	cf 12 f0 1a	cmp $1af012	                CMP @l GR_MAX_ROWS          ; Make sure it's in range for this graphics mode
.1a3031	b0 d7		bcs $1a300a	                BGE range_err               ; If not: throw an error
.1a3033	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.1a3037	af 10 f0 1a	lda $1af010	                LDA @lGR_MAX_COLS
.1a303b	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B          ; Multiply by the number of columns in the pixmap
.1a303f	18		clc		                CLC                         ; Add the column
.1a3040	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT
.1a3044	65 59		adc $0859	                ADC X0
.1a3046	85 0c		sta $080c	                STA SCRATCH
.1a3048	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.1a304c	69 00 00	adc #$0000	                ADC #0
.1a304f	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH is offset of pixel in the pixmap
.1a3051	18		clc		                CLC                         ; Add the address of the first pixel
.1a3052	a5 0c		lda $080c	                LDA SCRATCH
.1a3054	65 9e		adc $089e	                ADC MTEMPPTR
.1a3056	85 0c		sta $080c	                STA SCRATCH
.1a3058	a5 0e		lda $080e	                LDA SCRATCH+2
.1a305a	65 a0		adc $08a0	                ADC MTEMPPTR+2
.1a305c	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH := pixmap + pixel offset
.1a305e	e2 20		sep #$20	            SEP #$20
.1a3060	a5 55		lda $0855	                LDA COLOR                   ; Get the color
.1a3062	87 0c		sta [$080c]	                STA [SCRATCH]               ; And write the color to the pixel
.1a3064	28		plp		done            PLP
.1a3065	60		rts		            RTS
.1a3066					LINE
.1a3066	c2 20		rep #$20	            REP #$20
.1a3068	a9 01 00	lda #$0001	                LDA #1                      ; Assume SX = 1
.1a306b	85 dd		sta $08dd	                STA SX
.1a306d	38		sec		                SEC                         ; DX := ABS(X1 - X0)
.1a306e	a5 61		lda $0861	                LDA X1
.1a3070	e5 59		sbc $0859	                SBC X0
.1a3072	85 69		sta $0869	                STA DX
.1a3074	10 0b		bpl $1a3081	                BPL abs_Y                   ; If DX < 0 {
.1a3076	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DX := -DX
.1a3079	1a		inc a		                INC A
.1a307a	85 69		sta $0869	                STA DX
.1a307c	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SX := -1
.1a307f	85 dd		sta $08dd	                STA SX                      ; }
.1a3081	a9 01 00	lda #$0001	abs_Y           LDA #1                      ; Assume SY = 1
.1a3084	85 df		sta $08df	                STA SY
.1a3086	38		sec		                SEC                         ; DY := ABS(Y1 - Y0)
.1a3087	a5 65		lda $0865	                LDA Y1
.1a3089	e5 5d		sbc $085d	                SBC Y0
.1a308b	85 6d		sta $086d	                STA DY
.1a308d	10 0b		bpl $1a309a	                BPL calc_ERR                ; If DY < 0 {
.1a308f	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DY := -DY
.1a3092	1a		inc a		                INC A
.1a3093	85 6d		sta $086d	                STA DY
.1a3095	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SY := -1
.1a3098	85 df		sta $08df	                STA SY                      ; }
.1a309a	a5 6d		lda $086d	calc_ERR        LDA DY
.1a309c	c9 01 00	cmp #$0001	                CMP #1                      ; Is DY = 1?
.1a309f	d0 19		bne $1a30ba	                BNE cmp_dx                  ; No: compare to DX
.1a30a1	a5 69		lda $0869	                LDA DX
.1a30a3	c9 01 00	cmp #$0001	                CMP #1                      ; Is DX = 1 too?
.1a30a6	d0 10		bne $1a30b8	                BNE cmp_dy_dx               ; No: treat normally
.1a30a8	20 ff 2f	jsr $1a2fff	            JSR PLOT
.1a30ab	a5 61		lda $0861	                LDA X1
.1a30ad	85 59		sta $0859	                STA X0
.1a30af	a5 65		lda $0865	                LDA Y1
.1a30b1	85 5d		sta $085d	                STA Y0
.1a30b3	20 ff 2f	jsr $1a2fff	            JSR PLOT
.1a30b6	80 5b		bra $1a3113	                BRA done
.1a30b8	a5 6d		lda $086d	cmp_dy_dx       LDA DY
.1a30ba	c5 69		cmp $0869	cmp_dx          CMP DX                      ; (DY < DX)
.1a30bc	b0 04		bcs $1a30c2	                BGE else
.1a30be	a5 69		lda $0869	                LDA DX                      ; TRUE CASE: ERR := DX
.1a30c0	80 06		bra $1a30c8	                BRA shiftERR
.1a30c2	a5 6d		lda $086d	else            LDA DY                      ; FALSE CASE: ERR := -DY
.1a30c4	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a30c7	1a		inc a		                INC A
.1a30c8	48		pha		shiftERR        PHA
.1a30c9	0a		asl a		                ASL A
.1a30ca	68		pla		                PLA
.1a30cb	6a		ror a		                ROR A                       ; ERR := ERR / 2
.1a30cc	85 71		sta $0871	                STA ERR
.1a30ce					loop
.1a30ce	20 ff 2f	jsr $1a2fff	            JSR PLOT
.1a30d1	a5 59		lda $0859	                LDA X0                      ; break if X0=X1 and Y0=Y1
.1a30d3	c5 61		cmp $0861	                CMP X1
.1a30d5	d0 06		bne $1a30dd	                BNE calc_ERR2
.1a30d7	a5 5d		lda $085d	                LDA Y0
.1a30d9	c5 65		cmp $0865	                CMP Y1
.1a30db	f0 36		beq $1a3113	                BEQ done
.1a30dd	a5 71		lda $0871	calc_ERR2       LDA ERR                     ; ERR2 := ERR
.1a30df	85 75		sta $0875	                STA ERR2
.1a30e1	a5 69		lda $0869	                LDA DX                      ; if (ERR2 > -DX) {
.1a30e3	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a30e6	1a		inc a		                INC A
.1a30e7	c5 75		cmp $0875	                CMP ERR2
.1a30e9	10 10		bpl $1a30fb	                BPL check_DY
.1a30eb	f0 0e		beq $1a30fb	                BEQ check_DY
.1a30ed	38		sec		                SEC                         ; ERR -= DY
.1a30ee	a5 71		lda $0871	                LDA ERR
.1a30f0	e5 6d		sbc $086d	                SBC DY
.1a30f2	85 71		sta $0871	                STA ERR
.1a30f4	18		clc		                CLC                         ; X0 += SX
.1a30f5	a5 59		lda $0859	                LDA X0
.1a30f7	65 dd		adc $08dd	                ADC SX
.1a30f9	85 59		sta $0859	                STA X0                      ; }
.1a30fb	a5 75		lda $0875	check_DY        LDA ERR2                    ; if (ERR2 < DY) {
.1a30fd	c5 6d		cmp $086d	                CMP DY
.1a30ff	10 cd		bpl $1a30ce	                BPL loop
.1a3101	f0 cb		beq $1a30ce	                BEQ loop
.1a3103	18		clc		                CLC                         ; ERR += DX
.1a3104	a5 71		lda $0871	                LDA ERR
.1a3106	65 69		adc $0869	                ADC DX
.1a3108	85 71		sta $0871	                STA ERR
.1a310a	18		clc		                CLC                         ; Y0 += SY
.1a310b	a5 5d		lda $085d	                LDA Y0
.1a310d	65 df		adc $08df	                ADC SY
.1a310f	85 5d		sta $085d	                STA Y0                      ; }
.1a3111	80 bb		bra $1a30ce	                BRA loop                    ; }
.1a3113					done
.1a3113	60		rts		            RTS
.1a3114					S_PLOT
.1a3114	08		php		                PHP
.1a3115					locals
>0001					L_PLANE         .word ?
>0003					L_X             .word ?
>0005					L_Y             .word ?
.1a3115	c2 20		rep #$20	            REP #$20
.1a3117	3b		tsc		            TSC
.1a3118	38		sec		            SEC
.1a3119	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.1a311c	1b		tcs		            TCS
.1a311d	08		php		            PHP
.1a311e	c2 20		rep #$20	            REP #$20
.1a3120	48		pha		            PHA
.1a3121	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3124	5b		tcd		            TCD
.1a3125	68		pla		            PLA
.1a3126	28		plp		            PLP
.1a3127	08		php		            PHP
.1a3128	e2 20		sep #$20	            SEP #$20
.1a312a	48		pha		            PHA
.1a312b	a9 00		lda #$00	            LDA #0
.1a312d	48		pha		            PHA
.1a312e	ab		plb		            PLB
.1a312f	68		pla		            PLA
.1a3130	28		plp		            PLP
.1a3131	c2 30		rep #$30	            REP #$30
.1a3133	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3136	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a3139	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.1a313b	a9 2c 00	lda #$002c	                LDA #','
.1a313e	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3141	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3144	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3147	a5 23		lda $0823	                LDA ARGUMENT1
.1a3149	83 03		sta $03,s	                STA L_X                     ; Save it to X
.1a314b	a9 2c 00	lda #$002c	                LDA #','
.1a314e	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3151	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3154	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3157	a5 23		lda $0823	                LDA ARGUMENT1
.1a3159	83 05		sta $05,s	                STA L_Y                     ; Save it to Y
.1a315b	a9 2c 00	lda #$002c	                LDA #','
.1a315e	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3161	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3164	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a3167	a5 23		lda $0823	                LDA ARGUMENT1
.1a3169	85 55		sta $0855	                STA COLOR                   ; Save it to MARG1
.1a316b	a3 03		lda $03,s	                LDA L_X                     ; Set the (X0, Y0) coordinates
.1a316d	85 59		sta $0859	                STA X0
.1a316f	a3 05		lda $05,s	                LDA L_Y
.1a3171	85 5d		sta $085d	                STA Y0
.1a3173	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.1a3175	20 2c 2e	jsr $1a2e2c	            JSR BITMAP_SRAM
.1a3178	20 ff 2f	jsr $1a2fff	            JSR PLOT
.1a317b	c2 20		rep #$20	            REP #$20
.1a317d	3b		tsc		            TSC
.1a317e	18		clc		            CLC
.1a317f	69 06 00	adc #$0006	            ADC #SIZE(locals)
.1a3182	1b		tcs		            TCS
.1a3183	28		plp		                PLP
.1a3184	60		rts		            RTS
.1a3185					S_LINE
.1a3185	08		php		                PHP
.1a3186					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
.1a3186	c2 20		rep #$20	            REP #$20
.1a3188	3b		tsc		            TSC
.1a3189	38		sec		            SEC
.1a318a	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.1a318d	1b		tcs		            TCS
.1a318e	08		php		            PHP
.1a318f	c2 20		rep #$20	            REP #$20
.1a3191	48		pha		            PHA
.1a3192	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3195	5b		tcd		            TCD
.1a3196	68		pla		            PLA
.1a3197	28		plp		            PLP
.1a3198	08		php		            PHP
.1a3199	e2 20		sep #$20	            SEP #$20
.1a319b	48		pha		            PHA
.1a319c	a9 00		lda #$00	            LDA #0
.1a319e	48		pha		            PHA
.1a319f	ab		plb		            PLB
.1a31a0	68		pla		            PLA
.1a31a1	28		plp		            PLP
.1a31a2	c2 30		rep #$30	            REP #$30
.1a31a4	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a31a7	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a31aa	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.1a31ac	a9 2c 00	lda #$002c	                LDA #','
.1a31af	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a31b2	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a31b5	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a31b8	a5 23		lda $0823	                LDA ARGUMENT1
.1a31ba	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.1a31bc	a9 2c 00	lda #$002c	                LDA #','
.1a31bf	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a31c2	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a31c5	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a31c8	a5 23		lda $0823	                LDA ARGUMENT1
.1a31ca	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.1a31cc	a9 2c 00	lda #$002c	                LDA #','
.1a31cf	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a31d2	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a31d5	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a31d8	a5 23		lda $0823	                LDA ARGUMENT1
.1a31da	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.1a31dc	a9 2c 00	lda #$002c	                LDA #','
.1a31df	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a31e2	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a31e5	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a31e8	a5 23		lda $0823	                LDA ARGUMENT1
.1a31ea	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.1a31ec	a9 2c 00	lda #$002c	                LDA #','
.1a31ef	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a31f2	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a31f5	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a31f8	a5 23		lda $0823	                LDA ARGUMENT1
.1a31fa	85 55		sta $0855	                STA COLOR                   ; Save it to COLOR
.1a31fc	a3 03		lda $03,s	                LDA L_X0                    ; Set the (X0, Y0) coordinates
.1a31fe	85 59		sta $0859	                STA X0
.1a3200	a3 05		lda $05,s	                LDA L_Y0
.1a3202	85 5d		sta $085d	                STA Y0
.1a3204	a3 07		lda $07,s	                LDA L_X1                    ; Set the (X1, Y1) coordinates
.1a3206	85 61		sta $0861	                STA X1
.1a3208	a3 09		lda $09,s	                LDA L_Y1
.1a320a	85 65		sta $0865	                STA Y1
.1a320c	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.1a320e	20 2c 2e	jsr $1a2e2c	            JSR BITMAP_SRAM
.1a3211	20 66 30	jsr $1a3066	            JSR LINE
.1a3214					done
.1a3214	c2 20		rep #$20	            REP #$20
.1a3216	3b		tsc		            TSC
.1a3217	18		clc		            CLC
.1a3218	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.1a321b	1b		tcs		            TCS
.1a321c	28		plp		                PLP
.1a321d	60		rts		            RTS
.1a321e					S_FILL
.1a321e	08		php		                PHP
.1a321f					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
>000b					L_COLOR         .word ?
.1a321f	c2 20		rep #$20	            REP #$20
.1a3221	3b		tsc		            TSC
.1a3222	38		sec		            SEC
.1a3223	e9 0c 00	sbc #$000c	            SBC #SIZE(locals)
.1a3226	1b		tcs		            TCS
.1a3227	08		php		            PHP
.1a3228	c2 20		rep #$20	            REP #$20
.1a322a	48		pha		            PHA
.1a322b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a322e	5b		tcd		            TCD
.1a322f	68		pla		            PLA
.1a3230	28		plp		            PLP
.1a3231	08		php		            PHP
.1a3232	e2 20		sep #$20	            SEP #$20
.1a3234	48		pha		            PHA
.1a3235	a9 00		lda #$00	            LDA #0
.1a3237	48		pha		            PHA
.1a3238	ab		plb		            PLB
.1a3239	68		pla		            PLA
.1a323a	28		plp		            PLP
.1a323b	c2 30		rep #$30	            REP #$30
.1a323d	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3240	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a3243	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.1a3245	a9 2c 00	lda #$002c	                LDA #','
.1a3248	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a324b	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a324e	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3251	a5 23		lda $0823	                LDA ARGUMENT1
.1a3253	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.1a3255	a9 2c 00	lda #$002c	                LDA #','
.1a3258	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a325b	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a325e	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3261	a5 23		lda $0823	                LDA ARGUMENT1
.1a3263	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.1a3265	a9 2c 00	lda #$002c	                LDA #','
.1a3268	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a326b	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a326e	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3271	a5 23		lda $0823	                LDA ARGUMENT1
.1a3273	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.1a3275	a9 2c 00	lda #$002c	                LDA #','
.1a3278	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a327b	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a327e	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3281	a5 23		lda $0823	                LDA ARGUMENT1
.1a3283	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.1a3285	a9 2c 00	lda #$002c	                LDA #','
.1a3288	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a328b	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a328e	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a3291	a5 23		lda $0823	                LDA ARGUMENT1
.1a3293	83 0b		sta $0b,s	                STA L_COLOR                 ; Save it to COLOR
.1a3295	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.1a3297	20 70 2e	jsr $1a2e70	            JSR BITMAP_VRAM
.1a329a	a9 07 00	lda #$0007	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_1D_2D
.1a329d	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a32a1	c2 20		rep #$20	            REP #$20
.1a32a3	a3 05		lda $05,s	                LDA L_Y0                    ; Get the row
.1a32a5	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.1a32a9	af 10 f0 1a	lda $1af010	                LDA @l GR_MAX_COLS
.1a32ad	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B         ; Multiply by the number of columns in the pixmap
.1a32b1	18		clc		                CLC                         ; Add the column
.1a32b2	af 04 01 00	lda $000104	                LDA @l M0_RESULT
.1a32b6	63 03		adc $03,s	                ADC L_X0
.1a32b8	85 0c		sta $080c	                STA SCRATCH
.1a32ba	e2 20		sep #$20	            SEP #$20
.1a32bc	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.1a32c0	69 00		adc #$00	                ADC #0
.1a32c2	85 0e		sta $080e	                STA SCRATCH+2
.1a32c4	c2 20		rep #$20	            REP #$20
.1a32c6	18		clc		                CLC                         ; Set the destination address
.1a32c7	a5 9e		lda $089e	                LDA MTEMPPTR
.1a32c9	65 0c		adc $080c	                ADC SCRATCH
.1a32cb	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.1a32cf	e2 20		sep #$20	            SEP #$20
.1a32d1	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.1a32d3	65 0e		adc $080e	                ADC SCRATCH+2
.1a32d5	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H
.1a32d9	c2 20		rep #$20	            REP #$20
.1a32db	38		sec		                SEC                         ; Set the width of the FILL operation
.1a32dc	a3 07		lda $07,s	                LDA L_X1
.1a32de	e3 03		sbc $03,s	                SBC L_X0
.1a32e0	85 0c		sta $080c	                STA SCRATCH
.1a32e2	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.1a32e6	38		sec		                SEC
.1a32e7	af 10 f0 1a	lda $1af010	                LDA @l GR_MAX_COLS
.1a32eb	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L    ; And the destination stride
.1a32ef	38		sec		                SEC                         ; Set the height of the FILL operation
.1a32f0	a3 09		lda $09,s	                LDA L_Y1
.1a32f2	e3 05		sbc $05,s	                SBC L_Y0
.1a32f4	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.1a32f8	e2 20		sep #$20	            SEP #$20
.1a32fa	a3 0b		lda $0b,s	                LDA L_COLOR                 ; Set the color to write
.1a32fc	8f 01 04 af	sta $af0401	                STA @l VDMA_BYTE_2_WRITE
.1a3300	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.1a3304	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF
.1a3306	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a330a	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.1a330e	30 fa		bmi $1a330a	                BMI wait
.1a3310	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.1a3312	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a3316					done
.1a3316	c2 20		rep #$20	            REP #$20
.1a3318	3b		tsc		            TSC
.1a3319	18		clc		            CLC
.1a331a	69 0c 00	adc #$000c	            ADC #SIZE(locals)
.1a331d	1b		tcs		            TCS
.1a331e	28		plp		                PLP
.1a331f	60		rts		            RTS
.1a3320					SPADDR
.1a3320	08		php		                PHP
.1a3321	c2 20		rep #$20	            REP #$20
.1a3323	c9 40 00	cmp #$0040	                CMP #SP_MAX
.1a3326	b0 13		bcs $1a333b	                BGE error
.1a3328	0a		asl a		                ASL A                       ; Multiply it by 8 (the size of s sprite block)
.1a3329	0a		asl a		                ASL A
.1a332a	0a		asl a		                ASL A
.1a332b	18		clc		                CLC                         ; Add it to the address of the first
.1a332c	69 00 0c	adc #$0c00	                ADC #<>SP00_CONTROL_REG     ; sprite block
.1a332f	85 9e		sta $089e	                STA MTEMPPTR
.1a3331	a9 af 00	lda #$00af	                LDA #`SP00_CONTROL_REG
.1a3334	69 00 00	adc #$0000	                ADC #0
.1a3337	85 a0		sta $08a0	                STA MTEMPPTR+2              ; And save that to MTEMPPTR
.1a3339	28		plp		                PLP
.1a333a	60		rts		            RTS
.1a333b					error
.1a333b	08		php		            PHP
.1a333c	c2 20		rep #$20	            REP #$20
.1a333e	48		pha		            PHA
.1a333f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3342	5b		tcd		            TCD
.1a3343	68		pla		            PLA
.1a3344	28		plp		            PLP
.1a3345	e2 20		sep #$20	            SEP #$20
.1a3347	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3349	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a334d	c2 20		rep #$20	            REP #$20
.1a334f	29 ff 00	and #$00ff	            AND #$00FF
.1a3352	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a3355	e2 20		sep #$20	            SEP #$20
.1a3357	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a335a					S_SPRITE
.1a335a	08		php		                PHP
.1a335b					locals
>0001					L_SPRITE        .word ?
>0003					L_LUT           .byte ?
.1a335b	c2 20		rep #$20	            REP #$20
.1a335d	3b		tsc		            TSC
.1a335e	38		sec		            SEC
.1a335f	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.1a3362	1b		tcs		            TCS
.1a3363	c2 30		rep #$30	            REP #$30
.1a3365	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3368	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a336b	a5 23		lda $0823	                LDA ARGUMENT1
.1a336d	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.1a336f	a9 2c 00	lda #$002c	                LDA #','
.1a3372	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3375	e2 20		sep #$20	            SEP #$20
.1a3377	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a337a	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a337d	a5 23		lda $0823	                LDA ARGUMENT1
.1a337f	c9 08		cmp #$08	                CMP #GR_MAX_LUT             ; Check that it's in range
.1a3381	b0 56		bcs $1a33d9	                BGE error                   ; If not: throw an error
.1a3383	83 03		sta $03,s	                STA L_LUT                   ; Save it as lut
.1a3385	a9 2c		lda #$2c	                LDA #','
.1a3387	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a338a	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a338d	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3390	c2 20		rep #$20	            REP #$20
.1a3392	38		sec		                SEC                         ; Adjust address to be in Vicky's space
.1a3393	a5 23		lda $0823	                LDA ARGUMENT1
.1a3395	e9 00 00	sbc #$0000	                SBC #<>VRAM
.1a3398	85 23		sta $0823	                STA ARGUMENT1
.1a339a	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a339c	e9 b0 00	sbc #$00b0	                SBC #`VRAM
.1a339f	85 25		sta $0825	                STA ARGUMENT1+2
.1a33a1	30 36		bmi $1a33d9	                BMI error                   ; If negative, throw an error
.1a33a3	c2 20		rep #$20	            REP #$20
.1a33a5	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a33a7	aa		tax		                TAX
.1a33a8	20 20 33	jsr $1a3320	            JSR SPADDR
.1a33ab	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the lower word of the address
.1a33ad	a0 01 00	ldy #$0001	                LDY #SP_ADDR
.1a33b0	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a33b2	e2 20		sep #$20	            SEP #$20
.1a33b4	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a33b6	c8		iny		                INY
.1a33b7	c8		iny		                INY
.1a33b8	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save the upper byte of the address
.1a33ba	bf 18 f0 1a	lda $1af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the sprite control register
.1a33be	29 f1		and #$f1	                AND #%11110001              ; Filter off the current LUT
.1a33c0	85 0c		sta $080c	                STA SCRATCH
.1a33c2	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT back
.1a33c4	0a		asl a		                ASL A                       ; Sift it into the LUT position
.1a33c5	29 0e		and #$0e	                AND #%00001110              ; Make sure we don't have anything wrong there
.1a33c7	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with what's in the sprite's control
.1a33c9	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the register's bits
.1a33cb	9f 18 f0 1a	sta $1af018,x	                STA @l GS_SP_CONTROL,X      ; And the shadow register
.1a33cf					done
.1a33cf	c2 20		rep #$20	            REP #$20
.1a33d1	3b		tsc		            TSC
.1a33d2	18		clc		            CLC
.1a33d3	69 03 00	adc #$0003	            ADC #SIZE(locals)
.1a33d6	1b		tcs		            TCS
.1a33d7	28		plp		                PLP
.1a33d8	60		rts		            RTS
.1a33d9					error
.1a33d9	08		php		            PHP
.1a33da	c2 20		rep #$20	            REP #$20
.1a33dc	48		pha		            PHA
.1a33dd	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a33e0	5b		tcd		            TCD
.1a33e1	68		pla		            PLA
.1a33e2	28		plp		            PLP
.1a33e3	e2 20		sep #$20	            SEP #$20
.1a33e5	a9 09		lda #$09	            LDA #ERR_RANGE
.1a33e7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a33eb	c2 20		rep #$20	            REP #$20
.1a33ed	29 ff 00	and #$00ff	            AND #$00FF
.1a33f0	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a33f3	e2 20		sep #$20	            SEP #$20
.1a33f5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a33f8					S_SPRITEAT
.1a33f8	08		php		                PHP
.1a33f9					locals
>0001					L_SPRITE        .word ?
>0003					L_X             .word ?
.1a33f9	c2 20		rep #$20	            REP #$20
.1a33fb	3b		tsc		            TSC
.1a33fc	38		sec		            SEC
.1a33fd	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.1a3400	1b		tcs		            TCS
.1a3401	c2 30		rep #$30	            REP #$30
.1a3403	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3406	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a3409	a5 23		lda $0823	                LDA ARGUMENT1
.1a340b	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.1a340d	a9 2c 00	lda #$002c	                LDA #','
.1a3410	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3413	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3416	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3419	a5 23		lda $0823	                LDA ARGUMENT1
.1a341b	83 03		sta $03,s	                STA L_X                     ; Save it as X
.1a341d	a9 2c 00	lda #$002c	                LDA #','
.1a3420	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3423	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3426	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3429	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a342b	20 20 33	jsr $1a3320	            JSR SPADDR
.1a342e	a3 03		lda $03,s	                LDA L_X                     ; Get the X coordinate
.1a3430	a0 04 00	ldy #$0004	                LDY #SP_X_COORD             ; Save the X coordinate for the sprite
.1a3433	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3435	a5 23		lda $0823	                LDA ARGUMENT1
.1a3437	a0 06 00	ldy #$0006	                LDY #SP_Y_COORD             ; Save the Y coordinate for the sprite
.1a343a	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a343c					done
.1a343c	c2 20		rep #$20	            REP #$20
.1a343e	3b		tsc		            TSC
.1a343f	18		clc		            CLC
.1a3440	69 04 00	adc #$0004	            ADC #SIZE(locals)
.1a3443	1b		tcs		            TCS
.1a3444	28		plp		                PLP
.1a3445	60		rts		            RTS
.1a3446					S_SPRITESHOW
.1a3446	08		php		                PHP
.1a3447					locals
>0001					L_SPRITE        .word ?
>0003					L_VISIBLE       .byte ?
.1a3447	c2 20		rep #$20	            REP #$20
.1a3449	3b		tsc		            TSC
.1a344a	38		sec		            SEC
.1a344b	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.1a344e	1b		tcs		            TCS
.1a344f	c2 30		rep #$30	            REP #$30
.1a3451	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3454	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a3457	a5 23		lda $0823	                LDA ARGUMENT1
.1a3459	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.1a345b	a9 2c 00	lda #$002c	                LDA #','
.1a345e	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3461	e2 20		sep #$20	            SEP #$20
.1a3463	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3466	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3469	a5 23		lda $0823	                LDA ARGUMENT1
.1a346b	d0 04		bne $1a3471	                BNE is_visible
.1a346d	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 0 (not visible)
.1a346f	80 04		bra $1a3475	                BRA chk_layer
.1a3471	a9 01		lda #$01	is_visible      LDA #1
.1a3473	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 1 (visible)
.1a3475	a9 2c		lda #$2c	chk_layer       LDA #','
.1a3477	85 37		sta $0837	                STA TARGETTOK
.1a3479	20 24 22	jsr $1a2224	            JSR OPT_TOK
.1a347c	b0 20		bcs $1a349e	                BCS get_layer               ; Yes: get the layer
.1a347e					no_layer
.1a347e	c2 30		rep #$30	            REP #$30
.1a3480	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a3482	aa		tax		                TAX
.1a3483	20 20 33	jsr $1a3320	            JSR SPADDR
.1a3486	e2 20		sep #$20	            SEP #$20
.1a3488	bf 18 f0 1a	lda $1af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.1a348c	29 fe		and #$fe	                AND #$FE                    ; Filter out the enable bit
.1a348e	85 0c		sta $080c	                STA SCRATCH
.1a3490	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.1a3492	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.1a3494	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.1a3496	9f 18 f0 1a	sta $1af018,x	                STA @l GS_SP_CONTROL,X      ; And save it
.1a349a	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; ... and to Vicky
.1a349c	80 36		bra $1a34d4	                BRA done
.1a349e					get_layer
.1a349e	c2 30		rep #$30	            REP #$30
.1a34a0	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a34a3	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a34a6	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a34a9	a5 23		lda $0823	                LDA ARGUMENT1
.1a34ab	c9 08 00	cmp #$0008	                CMP #8                      ; Make sure it's in range
.1a34ae	b0 2e		bcs $1a34de	                BGE error                   ; If not, throw an out of range error
.1a34b0	0a		asl a		                ASL A                       ; If it's ok... shift it into position
.1a34b1	0a		asl a		                ASL A
.1a34b2	0a		asl a		                ASL A
.1a34b3	0a		asl a		                ASL A
.1a34b4	85 0c		sta $080c	                STA SCRATCH                 ; And save it in SCRATCH
.1a34b6	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a34b8	aa		tax		                TAX
.1a34b9	20 20 33	jsr $1a3320	            JSR SPADDR
.1a34bc	e2 20		sep #$20	            SEP #$20
.1a34be	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.1a34c0	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.1a34c2	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.1a34c4	85 0c		sta $080c	                STA SCRATCH
.1a34c6	bf 18 f0 1a	lda $1af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.1a34ca	29 8e		and #$8e	                AND #%10001110              ; Filter out the enable and layer bits
.1a34cc	05 0c		ora $080c	                ORA SCRATCH                 ; Combine with the provided layer and enable
.1a34ce	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the bits in Vicky
.1a34d0	9f 18 f0 1a	sta $1af018,x	                STA @l GS_SP_CONTROL,X      ; And to the shadow registers
.1a34d4					done
.1a34d4	c2 20		rep #$20	            REP #$20
.1a34d6	3b		tsc		            TSC
.1a34d7	18		clc		            CLC
.1a34d8	69 03 00	adc #$0003	            ADC #SIZE(locals)
.1a34db	1b		tcs		            TCS
.1a34dc	28		plp		                PLP
.1a34dd	60		rts		            RTS
.1a34de					error
.1a34de	08		php		            PHP
.1a34df	c2 20		rep #$20	            REP #$20
.1a34e1	48		pha		            PHA
.1a34e2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a34e5	5b		tcd		            TCD
.1a34e6	68		pla		            PLA
.1a34e7	28		plp		            PLP
.1a34e8	e2 20		sep #$20	            SEP #$20
.1a34ea	a9 09		lda #$09	            LDA #ERR_RANGE
.1a34ec	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a34f0	c2 20		rep #$20	            REP #$20
.1a34f2	29 ff 00	and #$00ff	            AND #$00FF
.1a34f5	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a34f8	e2 20		sep #$20	            SEP #$20
.1a34fa	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a34fd					TILESET_ADDR
.1a34fd	08		php		                PHP
.1a34fe	c2 20		rep #$20	            REP #$20
.1a3500	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.1a3503	b0 19		bcs $1a351e	                BGE out_of_range            ; If not, throw a range error
.1a3505	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.1a3508	a9 04 00	lda #$0004	                LDA #TILESET_REG_SIZE       ; Multiply it by the number of bytes in a tile set register set
.1a350b	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.1a350e	18		clc		                CLC                         ; Add to TILESET0_ADDY_L to get the final address
.1a350f	ad 04 01	lda $0104	                LDA @w M0_RESULT
.1a3512	69 80 02	adc #$0280	                ADC #<>TILESET0_ADDY_L
.1a3515	85 9e		sta $089e	                STA MTEMPPTR
.1a3517	a9 af 00	lda #$00af	                LDA #`TILESET0_ADDY_L
.1a351a	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a351c	28		plp		                PLP
.1a351d	60		rts		            RTS
.1a351e					out_of_range
.1a351e	08		php		            PHP
.1a351f	c2 20		rep #$20	            REP #$20
.1a3521	48		pha		            PHA
.1a3522	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3525	5b		tcd		            TCD
.1a3526	68		pla		            PLA
.1a3527	28		plp		            PLP
.1a3528	e2 20		sep #$20	            SEP #$20
.1a352a	a9 09		lda #$09	            LDA #ERR_RANGE
.1a352c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3530	c2 20		rep #$20	            REP #$20
.1a3532	29 ff 00	and #$00ff	            AND #$00FF
.1a3535	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a3538	e2 20		sep #$20	            SEP #$20
.1a353a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a353d					TILEMAP_ADDR
.1a353d	08		php		                PHP
.1a353e	c2 20		rep #$20	            REP #$20
.1a3540	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.1a3543	b0 19		bcs $1a355e	                BGE out_of_range            ; If not, throw a range error
.1a3545	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.1a3548	a9 0c 00	lda #$000c	                LDA #TILEMAP_REG_SIZE       ; Multiply it by the number of bytes in a tile map register set
.1a354b	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.1a354e	18		clc		                CLC
.1a354f	ad 04 01	lda $0104	                LDA @w M0_RESULT            ; Add to TL0_CONTROL_REG to get the final address
.1a3552	69 00 02	adc #$0200	                ADC #<>TL0_CONTROL_REG
.1a3555	85 9e		sta $089e	                STA MTEMPPTR
.1a3557	a9 af 00	lda #$00af	                LDA #`TL0_CONTROL_REG
.1a355a	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a355c	28		plp		                PLP
.1a355d	60		rts		            RTS
.1a355e					out_of_range
.1a355e	08		php		            PHP
.1a355f	c2 20		rep #$20	            REP #$20
.1a3561	48		pha		            PHA
.1a3562	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3565	5b		tcd		            TCD
.1a3566	68		pla		            PLA
.1a3567	28		plp		            PLP
.1a3568	e2 20		sep #$20	            SEP #$20
.1a356a	a9 09		lda #$09	            LDA #ERR_RANGE
.1a356c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3570	c2 20		rep #$20	            REP #$20
.1a3572	29 ff 00	and #$00ff	            AND #$00FF
.1a3575	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a3578	e2 20		sep #$20	            SEP #$20
.1a357a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a357d					S_TILESET
.1a357d	08		php		                PHP
.1a357e					locals
>0001					L_TILENUM       .word ?
>0003					L_LUT           .word ?
>0005					L_IS_SQUARE     .word ?
.1a357e	c2 20		rep #$20	            REP #$20
.1a3580	3b		tsc		            TSC
.1a3581	38		sec		            SEC
.1a3582	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.1a3585	1b		tcs		            TCS
.1a3586	c2 20		rep #$20	            REP #$20
.1a3588	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a358b	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a358e	a5 23		lda $0823	                LDA ARGUMENT1
.1a3590	83 01		sta $01,s	                STA L_TILENUM               ; Save it as the tile set/map number
.1a3592	a9 2c 00	lda #$002c	                LDA #','
.1a3595	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3598	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a359b	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a359e	a5 23		lda $0823	                LDA ARGUMENT1
.1a35a0	83 03		sta $03,s	                STA L_LUT                   ; Save it as LUT
.1a35a2	a9 2c 00	lda #$002c	                LDA #','
.1a35a5	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a35a8	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a35ab	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a35ae	a5 23		lda $0823	                LDA ARGUMENT1
.1a35b0	83 05		sta $05,s	                STA L_IS_SQUARE             ; Save it as IS_SQUARE
.1a35b2	a9 2c 00	lda #$002c	                LDA #','
.1a35b5	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a35b8	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a35bb	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a35be	a3 01		lda $01,s	                LDA L_TILENUM
.1a35c0	20 fd 34	jsr $1a34fd	            JSR TILESET_ADDR
.1a35c3	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the bitmap address - the address of the start of VRAM
.1a35c5	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And save it to the registers
.1a35c7	e2 20		sep #$20	            SEP #$20
.1a35c9	38		sec		                SEC
.1a35ca	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a35cc	e9 b0		sbc #$b0	                SBC #`VRAM
.1a35ce	a0 02 00	ldy #$0002	                LDY #TILESET_ADDY_H
.1a35d1	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a35d3	a3 05		lda $05,s	                LDA L_IS_SQUARE             ; Check if is_square == 0?
.1a35d5	d0 0d		bne $1a35e4	                BNE is_square
.1a35d7					not_square
.1a35d7	e2 20		sep #$20	            SEP #$20
.1a35d9	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.1a35db	29 07		and #$07	                AND #$07                    ; Force it to be in range
.1a35dd	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.1a35e0	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.1a35e2	80 0d		bra $1a35f1	                BRA done
.1a35e4					is_square
.1a35e4	e2 20		sep #$20	            SEP #$20
.1a35e6	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.1a35e8	29 07		and #$07	                AND #$07                    ; Force it to be in range
.1a35ea	09 08		ora #$08	                ORA #TILESET_SQUARE_256     ; Turn on the 256x256 flag
.1a35ec	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.1a35ef	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.1a35f1					done
.1a35f1	c2 20		rep #$20	            REP #$20
.1a35f3	3b		tsc		            TSC
.1a35f4	18		clc		            CLC
.1a35f5	69 06 00	adc #$0006	            ADC #SIZE(locals)
.1a35f8	1b		tcs		            TCS
.1a35f9	28		plp		                PLP
.1a35fa	60		rts		            RTS
.1a35fb					S_TILEMAP
.1a35fb	08		php		                PHP
.1a35fc					locals
>0001					L_TILENUM       .word ?
>0003					L_WIDTH         .word ?
>0005					L_HEIGHT        .word ?
.1a35fc	c2 20		rep #$20	            REP #$20
.1a35fe	3b		tsc		            TSC
.1a35ff	38		sec		            SEC
.1a3600	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.1a3603	1b		tcs		            TCS
.1a3604	c2 20		rep #$20	            REP #$20
.1a3606	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3609	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a360c	a5 23		lda $0823	                LDA ARGUMENT1
.1a360e	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.1a3610	a9 2c 00	lda #$002c	                LDA #','
.1a3613	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3616	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3619	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a361c	a5 23		lda $0823	                LDA ARGUMENT1
.1a361e	83 03		sta $03,s	                STA L_WIDTH                 ; Save it as WIDTH
.1a3620	a9 2c 00	lda #$002c	                LDA #','
.1a3623	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3626	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3629	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a362c	a5 23		lda $0823	                LDA ARGUMENT1
.1a362e	83 05		sta $05,s	                STA L_HEIGHT                ; Save it as HEIGHT
.1a3630	a9 2c 00	lda #$002c	                LDA #','
.1a3633	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3636	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3639	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a363c	a3 01		lda $01,s	                LDA L_TILENUM
.1a363e	20 3d 35	jsr $1a353d	            JSR TILEMAP_ADDR
.1a3641	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the map address - the address of the start of VRAM
.1a3643	a0 01 00	ldy #$0001	                LDY #TILEMAP_START_ADDY
.1a3646	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; And save it to the registers
.1a3648	e2 20		sep #$20	            SEP #$20
.1a364a	38		sec		                SEC
.1a364b	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a364d	e9 b0		sbc #$b0	                SBC #`VRAM
.1a364f	c8		iny		                INY
.1a3650	c8		iny		                INY
.1a3651	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3653	c2 20		rep #$20	            REP #$20
.1a3655	a3 03		lda $03,s	                LDA L_WIDTH                 ; Set the width
.1a3657	a0 04 00	ldy #$0004	                LDY #TILEMAP_TOTAL_X
.1a365a	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a365c	a3 05		lda $05,s	                LDA L_HEIGHT                ; Set the height
.1a365e	a0 06 00	ldy #$0006	                LDY #TILEMAP_TOTAL_Y
.1a3661	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3663					done
.1a3663	c2 20		rep #$20	            REP #$20
.1a3665	3b		tsc		            TSC
.1a3666	18		clc		            CLC
.1a3667	69 06 00	adc #$0006	            ADC #SIZE(locals)
.1a366a	1b		tcs		            TCS
.1a366b	28		plp		                PLP
.1a366c	60		rts		            RTS
.1a366d					S_TILESHOW
.1a366d	08		php		                PHP
.1a366e					locals
>0001					L_TILENUM       .word ?
.1a366e	c2 20		rep #$20	            REP #$20
.1a3670	f4 00 00	pea #$0000	            PEA #0
.1a3673	c2 20		rep #$20	            REP #$20
.1a3675	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3678	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a367b	a5 23		lda $0823	                LDA ARGUMENT1
.1a367d	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.1a367f	a9 2c 00	lda #$002c	                LDA #','
.1a3682	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3685	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3688	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a368b	a3 01		lda $01,s	                LDA L_TILENUM
.1a368d	20 3d 35	jsr $1a353d	            JSR TILEMAP_ADDR
.1a3690	a5 23		lda $0823	                LDA ARGUMENT1               ; CHeck the visible parameter
.1a3692	d0 06		bne $1a369a	                BNE is_visible              ; If it's <> 0, make it visible
.1a3694	e2 20		sep #$20	            SEP #$20
.1a3696	a9 00		lda #$00	                LDA #0                      ; Control value for invisible
.1a3698	80 04		bra $1a369e	                BRA set_control
.1a369a					is_visible
.1a369a	e2 20		sep #$20	            SEP #$20
.1a369c	a9 01		lda #$01	                LDA #TILEMAP_VISIBLE        ; Control value for visible
.1a369e					set_control
.1a369e	e2 20		sep #$20	            SEP #$20
.1a36a0	a0 00 00	ldy #$0000	                LDY #TILEMAP_CONTROL        ; Set the control register
.1a36a3	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a36a5					done
.1a36a5	c2 20		rep #$20	            REP #$20
.1a36a7	68		pla		            PLA
.1a36a8	28		plp		                PLP
.1a36a9	60		rts		            RTS
.1a36aa					S_TILEAT
.1a36aa	08		php		                PHP
.1a36ab					locals
>0001					L_TILENUM       .word ?
>0003					L_X             .word ?
.1a36ab	c2 20		rep #$20	            REP #$20
.1a36ad	3b		tsc		            TSC
.1a36ae	38		sec		            SEC
.1a36af	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.1a36b2	1b		tcs		            TCS
.1a36b3	c2 20		rep #$20	            REP #$20
.1a36b5	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a36b8	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a36bb	a5 23		lda $0823	                LDA ARGUMENT1
.1a36bd	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.1a36bf	a9 2c 00	lda #$002c	                LDA #','
.1a36c2	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a36c5	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a36c8	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a36cb	a5 23		lda $0823	                LDA ARGUMENT1
.1a36cd	83 03		sta $03,s	                STA L_X                     ; Save as X
.1a36cf	a9 2c 00	lda #$002c	                LDA #','
.1a36d2	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a36d5	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a36d8	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a36db	a3 01		lda $01,s	                LDA L_TILENUM
.1a36dd	20 3d 35	jsr $1a353d	            JSR TILEMAP_ADDR
.1a36e0	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the Y position
.1a36e2	a0 0a 00	ldy #$000a	                LDY #TILEMAP_WINDOW_Y
.1a36e5	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a36e7	a3 03		lda $03,s	                LDA L_X                     ; Set the X position
.1a36e9	a0 08 00	ldy #$0008	                LDY #TILEMAP_WINDOW_X
.1a36ec	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a36ee					done
.1a36ee	c2 20		rep #$20	            REP #$20
.1a36f0	3b		tsc		            TSC
.1a36f1	18		clc		            CLC
.1a36f2	69 04 00	adc #$0004	            ADC #SIZE(locals)
.1a36f5	1b		tcs		            TCS
.1a36f6	28		plp		                PLP
.1a36f7	60		rts		            RTS
=0					DMA_LINEAR = 0                              ; Memory to copy is a continguous, linear range
=1					DMA_RECT = 1                                ; Memory to copy is a rectangular block
.0000					DMA_BLOCK
>0000					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>0001					ADDR            .long ?                     ; The starting address for the data to transfer
>0004					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>0007					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>0009					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>000b					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
=$01					DMA_SRC_2D = $01                            ; Source transfer should be 2D
=$02					DMA_DST_2D = $02                            ; Destination transfer should be 2D
=$10					DMA_SRC_SRAM = $10                          ; Flag indicating that the source is in SRAM ($00:0000 - $3F:FFFF)
=$20					DMA_DST_SRAM = $20                          ; Flag indicating that the destination is in SRAM ($00:0000 - $3F:FFFF)
>1af058					DMA_BLOCKS      .byte ?                     ; What blocks are involved
.1af059					DMA_SRC
>1af059					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>1af05a					ADDR            .long ?                     ; The starting address for the data to transfer
>1af05d					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>1af060					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>1af062					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>1af064					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.1af066					DMA_DEST
>1af066					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>1af067					ADDR            .long ?                     ; The starting address for the data to transfer
>1af06a					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>1af06d					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>1af06f					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>1af071					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.1a36f8					DO_DMA
.1a36f8	0b		phd		                PHD
.1a36f9	08		php		                PHP
.1a36fa	08		php		            PHP
.1a36fb	c2 20		rep #$20	            REP #$20
.1a36fd	48		pha		            PHA
.1a36fe	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a3701	5b		tcd		            TCD
.1a3702	68		pla		            PLA
.1a3703	28		plp		            PLP
.1a3704	e2 20		sep #$20	            SEP #$20
.1a3706	a9 00		lda #$00	                LDA #0
.1a3708	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS           ; Set mode to something neutral
.1a370c	af 5c f0 1a	lda $1af05c	                LDA @l DMA_SRC.ADDR+2       ; Check the bank
.1a3710	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.1a3712	b0 1c		bcs $1a3730	                BGE src_vram                ; Yes: leave the DMA_BLOCK bit alone
.1a3714	8f 24 04 af	sta $af0424	src_sram        STA @l SDMA_SRC_ADDY_H      ; Set the SDMA source address
.1a3718	af 5b f0 1a	lda $1af05b	                LDA @l DMA_SRC.ADDR+1
.1a371c	8f 23 04 af	sta $af0423	                STA @l SDMA_SRC_ADDY_M
.1a3720	af 5a f0 1a	lda $1af05a	                LDA @l DMA_SRC.ADDR
.1a3724	8f 22 04 af	sta $af0422	                STA @l SDMA_SRC_ADDY_L
.1a3728	a9 10		lda #$10	                LDA #DMA_SRC_SRAM           ; Set the SRAM source block bit
.1a372a	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a372e	80 17		bra $1a3747	                BRA src_mode
.1a3730	38		sec		src_vram        SEC                         ; Convert to VRAM relative address
.1a3731	e9 b0		sbc #$b0	                SBC #`VRAM
.1a3733	8f 04 04 af	sta $af0404	                STA @l VDMA_SRC_ADDY_H      ; Set the VDMA source address
.1a3737	af 5b f0 1a	lda $1af05b	                LDA @l DMA_SRC.ADDR+1
.1a373b	8f 03 04 af	sta $af0403	                STA @l VDMA_SRC_ADDY_M
.1a373f	af 5a f0 1a	lda $1af05a	                LDA @l DMA_SRC.ADDR
.1a3743	8f 02 04 af	sta $af0402	                STA @l VDMA_SRC_ADDY_L
.1a3747	af 59 f0 1a	lda $1af059	src_mode        LDA @l DMA_SRC.MODE         ; Determine if source is 1D or 2D
.1a374b	d0 3c		bne $1a3789	                BNE src_2d
.1a374d	af 58 f0 1a	lda $1af058	src_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.1a3751	f0 1b		beq $1a376e	                BEQ src_1d_vram
.1a3753	af 5d f0 1a	lda $1af05d	src_1d_sram     LDA @l DMA_SRC.SIZE         ; It's SRAM, so set the SDMA size
.1a3757	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.1a375b	af 5e f0 1a	lda $1af05e	                LDA @l DMA_SRC.SIZE+1
.1a375f	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_M
.1a3763	af 5f f0 1a	lda $1af05f	                LDA @l DMA_SRC.SIZE+2
.1a3767	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.1a376b	82 8b 00	brl $1a37f9	                BRL set_dst                 ; Go to set up the destination
.1a376e	af 5d f0 1a	lda $1af05d	src_1d_vram     LDA @l DMA_SRC.SIZE         ; It's VRAM, so set the VDMA size
.1a3772	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.1a3776	af 5e f0 1a	lda $1af05e	                LDA @l DMA_SRC.SIZE+1
.1a377a	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_M
.1a377e	af 5f f0 1a	lda $1af05f	                LDA @l DMA_SRC.SIZE+2
.1a3782	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.1a3786	82 70 00	brl $1a37f9	                BRL set_dst                 ; Go to set up the destination
.1a3789	af 58 f0 1a	lda $1af058	src_2d          LDA @l DMA_BLOCKS
.1a378d	09 01		ora #$01	                ORA #DMA_SRC_2D             ; Set the bit to make the source a 2D transfer
.1a378f	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a3793	89 10		bit #$10	                BIT #DMA_SRC_SRAM           ; Are we writing to SRAM
.1a3795	f0 32		beq $1a37c9	                BEQ src_2d_vram             ; No: set the 2d values in the VRAM source
.1a3797	af 60 f0 1a	lda $1af060	src_2d_sram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.1a379b	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.1a379f	af 61 f0 1a	lda $1af061	                LDA @l DMA_SRC.WIDTH+1
.1a37a3	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.1a37a7	af 62 f0 1a	lda $1af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.1a37ab	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.1a37af	af 63 f0 1a	lda $1af063	                LDA @l DMA_SRC.HEIGHT+1
.1a37b3	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.1a37b7	af 64 f0 1a	lda $1af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.1a37bb	8f 2c 04 af	sta $af042c	                STA @l SDMA_SRC_STRIDE_L
.1a37bf	af 65 f0 1a	lda $1af065	                LDA @l DMA_SRC.STRIDE+1
.1a37c3	8f 2d 04 af	sta $af042d	                STA @l SDMA_SRC_STRIDE_L+1
.1a37c7	80 30		bra $1a37f9	                BRA set_dst
.1a37c9	af 60 f0 1a	lda $1af060	src_2d_vram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.1a37cd	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.1a37d1	af 61 f0 1a	lda $1af061	                LDA @l DMA_SRC.WIDTH+1
.1a37d5	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.1a37d9	af 62 f0 1a	lda $1af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.1a37dd	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.1a37e1	af 63 f0 1a	lda $1af063	                LDA @l DMA_SRC.HEIGHT+1
.1a37e5	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.1a37e9	af 64 f0 1a	lda $1af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.1a37ed	8f 0c 04 af	sta $af040c	                STA @l VDMA_SRC_STRIDE_L
.1a37f1	af 65 f0 1a	lda $1af065	                LDA @l DMA_SRC.STRIDE+1
.1a37f5	8f 0d 04 af	sta $af040d	                STA @l VDMA_SRC_STRIDE_L+1
.1a37f9					set_dst
.1a37f9	e2 20		sep #$20	            SEP #$20
.1a37fb	af 69 f0 1a	lda $1af069	                LDA @l DMA_DEST.ADDR+2      ; Check the bank
.1a37ff	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.1a3801	b0 20		bcs $1a3823	                BGE dst_vram                ; Yes: leave the DMA_BLOCK bit alone
.1a3803	8f 27 04 af	sta $af0427	dst_sram        STA @l SDMA_DST_ADDY_H      ; Set the SDMA destination address
.1a3807	af 68 f0 1a	lda $1af068	                LDA @l DMA_DEST.ADDR+1
.1a380b	8f 26 04 af	sta $af0426	                STA @l SDMA_DST_ADDY_M
.1a380f	af 67 f0 1a	lda $1af067	                LDA @l DMA_DEST.ADDR
.1a3813	8f 25 04 af	sta $af0425	                STA @l SDMA_DST_ADDY_L
.1a3817	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS
.1a381b	09 20		ora #$20	                ORA #DMA_DST_SRAM           ; Set the bit to indicate the destination is SRAM
.1a381d	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a3821	80 17		bra $1a383a	                BRA dst_mode
.1a3823	38		sec		dst_vram        SEC                         ; Convert to VRAM relative address
.1a3824	e9 b0		sbc #$b0	                SBC #`VRAM
.1a3826	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H      ; Set the VDMA destination address
.1a382a	af 68 f0 1a	lda $1af068	                LDA @l DMA_DEST.ADDR+1
.1a382e	8f 06 04 af	sta $af0406	                STA @l VDMA_DST_ADDY_M
.1a3832	af 67 f0 1a	lda $1af067	                LDA @l DMA_DEST.ADDR
.1a3836	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.1a383a	af 66 f0 1a	lda $1af066	dst_mode        LDA @l DMA_DEST.MODE
.1a383e	d0 3e		bne $1a387e	                BNE dst_2d                  ; If 2D, set up the 2D destination parameters
.1a3840	af 58 f0 1a	lda $1af058	dst_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.1a3844	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Is the destination SRAM?
.1a3846	f0 1b		beq $1a3863	                BEQ dst_1d_vram
.1a3848	af 6a f0 1a	lda $1af06a	dst_1d_sram     LDA @l DMA_DEST.SIZE
.1a384c	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.1a3850	af 6b f0 1a	lda $1af06b	                LDA @l DMA_DEST.SIZE+1
.1a3854	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_L+1
.1a3858	af 6c f0 1a	lda $1af06c	                LDA @l DMA_DEST.SIZE+2
.1a385c	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.1a3860	82 8b 00	brl $1a38ee	                BRL start_xfer
.1a3863	af 6a f0 1a	lda $1af06a	dst_1d_vram     LDA @l DMA_DEST.SIZE
.1a3867	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.1a386b	af 6b f0 1a	lda $1af06b	                LDA @l DMA_DEST.SIZE+1
.1a386f	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_L+1
.1a3873	af 6c f0 1a	lda $1af06c	                LDA @l DMA_DEST.SIZE+2
.1a3877	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.1a387b	82 70 00	brl $1a38ee	                BRL start_xfer
.1a387e	af 58 f0 1a	lda $1af058	dst_2d          LDA @l DMA_BLOCKS
.1a3882	09 02		ora #$02	                ORA #DMA_DST_2D             ; Set the bit to make the source a 2D transfer
.1a3884	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a3888	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Are we writing to the SRAM?
.1a388a	f0 32		beq $1a38be	                BEQ dst_2d_vram             ; No: set the 2D parameters for VRAM
.1a388c	af 6d f0 1a	lda $1af06d	dst_2d_sram     LDA @l DMA_DEST.WIDTH       ; Set the SRAM width
.1a3890	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.1a3894	af 6e f0 1a	lda $1af06e	                LDA @L DMA_DEST.WIDTH+1
.1a3898	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.1a389c	af 6f f0 1a	lda $1af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the SRAM height
.1a38a0	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.1a38a4	af 70 f0 1a	lda $1af070	                LDA @L DMA_DEST.HEIGHT+1
.1a38a8	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.1a38ac	af 71 f0 1a	lda $1af071	                LDA @l DMA_DEST.STRIDE      ; Set the SRAM stride
.1a38b0	8f 2e 04 af	sta $af042e	                STA @l SDMA_DST_STRIDE_L
.1a38b4	af 72 f0 1a	lda $1af072	                LDA @L DMA_DEST.STRIDE+1
.1a38b8	8f 2f 04 af	sta $af042f	                STA @l SDMA_DST_STRIDE_L+1
.1a38bc	80 30		bra $1a38ee	                BRA start_xfer
.1a38be	af 6d f0 1a	lda $1af06d	dst_2d_vram     LDA @l DMA_DEST.WIDTH       ; Set the VRAM width
.1a38c2	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.1a38c6	af 6e f0 1a	lda $1af06e	                LDA @L DMA_DEST.WIDTH+1
.1a38ca	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.1a38ce	af 6f f0 1a	lda $1af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the VRAM height
.1a38d2	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.1a38d6	af 70 f0 1a	lda $1af070	                LDA @L DMA_DEST.HEIGHT+1
.1a38da	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.1a38de	af 71 f0 1a	lda $1af071	                LDA @l DMA_DEST.STRIDE      ; Set the VRAM stride
.1a38e2	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L
.1a38e6	af 72 f0 1a	lda $1af072	                LDA @L DMA_DEST.STRIDE+1
.1a38ea	8f 0f 04 af	sta $af040f	                STA @l VDMA_DST_STRIDE_L+1
.1a38ee	af 58 f0 1a	lda $1af058	start_xfer      LDA @l DMA_BLOCKS
.1a38f2	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.1a38f4	f0 43		beq $1a3939	                BEQ start_vdma_only
.1a38f6	c9 10		cmp #$10	                CMP #DMA_SRC_SRAM
.1a38f8	f0 76		beq $1a3970	                BEQ start_s2v
.1a38fa	c9 20		cmp #$20	                CMP #DMA_DST_SRAM
.1a38fc	d0 03		bne $1a3901	                BNE start_sdma_only
.1a38fe	82 8a 00	brl $1a398b	                BRL start_v2s
.1a3901					start_sdma_only
.1a3901	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.1a3905	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.1a3907	f0 23		beq $1a392c	                BEQ sdma_1d_only            ; Source and Destination 1D...
.1a3909	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.1a390b	f0 23		beq $1a3930	                BEQ sdma_2d_only            ; Source and Destination 2D
.1a390d	08		php		            PHP
.1a390e	c2 20		rep #$20	            REP #$20
.1a3910	48		pha		            PHA
.1a3911	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3914	5b		tcd		            TCD
.1a3915	68		pla		            PLA
.1a3916	28		plp		            PLP
.1a3917	e2 20		sep #$20	            SEP #$20
.1a3919	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a391b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a391f	c2 20		rep #$20	            REP #$20
.1a3921	29 ff 00	and #$00ff	            AND #$00FF
.1a3924	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a3927	e2 20		sep #$20	            SEP #$20
.1a3929	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a392c	a9 01		lda #$01	sdma_1d_only    LDA #SDMA_CTRL0_Enable      ; Set the bits for 1D, SRAM->SRAM
.1a392e	80 02		bra $1a3932	                BRA sdma_set_ctrl
.1a3930	a9 03		lda #$03	sdma_2d_only    LDA #SDMA_CTRL0_Enable | SDMA_CTRL0_1D_2D
.1a3932	8f 20 04 af	sta $af0420	sdma_set_ctrl   STA @l SDMA_CTRL_REG0
.1a3936	82 7d 00	brl $1a39b6	                BRL trig_sdma               ; And trigger the SDMA
.1a3939					start_vdma_only
.1a3939	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.1a393d	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.1a393f	f0 23		beq $1a3964	                BEQ vdma_1d_only            ; Source and Destination 1D...
.1a3941	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.1a3943	f0 23		beq $1a3968	                BEQ vdma_2d_only            ; Source and Destination 2D...
.1a3945	08		php		            PHP
.1a3946	c2 20		rep #$20	            REP #$20
.1a3948	48		pha		            PHA
.1a3949	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a394c	5b		tcd		            TCD
.1a394d	68		pla		            PLA
.1a394e	28		plp		            PLP
.1a394f	e2 20		sep #$20	            SEP #$20
.1a3951	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a3953	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3957	c2 20		rep #$20	            REP #$20
.1a3959	29 ff 00	and #$00ff	            AND #$00FF
.1a395c	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a395f	e2 20		sep #$20	            SEP #$20
.1a3961	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3964	a9 01		lda #$01	vdma_1d_only    LDA #VDMA_CTRL_Enable       ; Set the bits for 1D, VRAM->VRAM
.1a3966	80 02		bra $1a396a	                BRA vdma_set_ctrl
.1a3968	a9 03		lda #$03	vdma_2d_only    LDA #VDMA_CTRL_Enable | VDMA_CTRL_1D_2D
.1a396a	8f 00 04 af	sta $af0400	vdma_set_ctrl   STA @l VDMA_CONTROL_REG
.1a396e	80 34		bra $1a39a4	                BRA trig_vdma               ; And trigger the VDMA
.1a3970					start_s2v
.1a3970	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.1a3974	29 01		and #$01	                AND #DMA_SRC_2D
.1a3976	0a		asl a		                ASL A
.1a3977	09 11		ora #$11	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Src
.1a3979	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a397d	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.1a3981	29 02		and #$02	                AND #DMA_DST_2D
.1a3983	09 11		ora #$11	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Src
.1a3985	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a3989	80 19		bra $1a39a4	                BRA trig_vdma               ; And trigger the VDMA
.1a398b					start_v2s
.1a398b	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.1a398f	29 02		and #$02	                AND #DMA_DST_2D
.1a3991	09 21		ora #$21	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Dst
.1a3993	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a3997	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.1a399b	29 01		and #$01	                AND #DMA_SRC_2D
.1a399d	0a		asl a		                ASL A
.1a399e	09 21		ora #$21	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Dst
.1a39a0	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a39a4					trig_vdma
.1a39a4	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.1a39a8	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF    ; Trigger the VDMA
.1a39aa	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a39ae	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Check if we need SDMA
.1a39b2	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.1a39b4	f0 0f		beq $1a39c5	                BEQ wait_vdma               ; No: wait for VDMA to complete
.1a39b6					trig_sdma
.1a39b6	af 20 04 af	lda $af0420	                LDA @l SDMA_CTRL_REG0
.1a39ba	09 80		ora #$80	                ORA #SDMA_CTRL0_Start_TRF   ; Trigger the SDMA
.1a39bc	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a39c0	ea		nop		                NOP                         ; When the transfer is started the CPU will be put on Hold (RDYn)...
.1a39c1	ea		nop		                NOP                         ; Before it actually gets to stop it will execute a couple more instructions
.1a39c2	ea		nop		                NOP                         ; From that point on, the CPU is halted (keep that in mind)
.1a39c3	ea		nop		                NOP                         ; No IRQ will be processed either during that time
.1a39c4	ea		nop		                NOP
.1a39c5	af 01 04 af	lda $af0401	wait_vdma       LDA @l VDMA_STATUS_REG      ; Check the VDMA status
.1a39c9	89 80		bit #$80	                BIT #VDMA_STAT_VDMA_IPS     ; If the transfer is still in process...
.1a39cb	d0 f8		bne $1a39c5	                BNE wait_vdma               ; Wait until it stops.
.1a39cd	a9 00		lda #$00	                LDA #$00                    ; Clear the TRF bits
.1a39cf	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a39d3	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a39d7	28		plp		                PLP
.1a39d8	2b		pld		                PLD
.1a39d9	60		rts		            RTS
.1a39da					S_MEMCOPY
.1a39da	0b		phd		                PHD
.1a39db	08		php		                PHP
.1a39dc	e2 20		sep #$20	            SEP #$20
.1a39de	c2 10		rep #$10	            REP #$10
.1a39e0	a9 00		lda #$00	                LDA #0
.1a39e2	a2 00 00	ldx #$0000	                LDX #0
.1a39e5	8f 59 f0 1a	sta $1af059	clr_loop        STA @l DMA_SRC
.1a39e9	e8		inx		                INX
.1a39ea	e0 1a 00	cpx #$001a	                CPX #SIZE(DMA_BLOCK) * 2
.1a39ed	d0 f6		bne $1a39e5	                BNE clr_loop
.1a39ef	20 43 22	jsr $1a2243	            JSR PEEK_TOK
.1a39f2	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.1a39f4	f0 23		beq $1a3a19	                BEQ src_linear                      ; Yes: go to process a linear source
.1a39f6	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.1a39f8	f0 5e		beq $1a3a58	                BEQ src_rect                        ; Yes: go to process a rectangular source
.1a39fa					syntax_err
.1a39fa	08		php		            PHP
.1a39fb	c2 20		rep #$20	            REP #$20
.1a39fd	48		pha		            PHA
.1a39fe	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3a01	5b		tcd		            TCD
.1a3a02	68		pla		            PLA
.1a3a03	28		plp		            PLP
.1a3a04	e2 20		sep #$20	            SEP #$20
.1a3a06	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3a08	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3a0c	c2 20		rep #$20	            REP #$20
.1a3a0e	29 ff 00	and #$00ff	            AND #$00FF
.1a3a11	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a3a14	e2 20		sep #$20	            SEP #$20
.1a3a16	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3a19					src_linear
.1a3a19	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3a1c	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3a1f	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3a22	c2 20		rep #$20	            REP #$20
.1a3a24	a5 23		lda $0823	            LDA ARGUMENT1
.1a3a26	8f 5a f0 1a	sta $1af05a	            STA DMA_SRC.ADDR
.1a3a2a	e2 20		sep #$20	            SEP #$20
.1a3a2c	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3a2e	8f 5c f0 1a	sta $1af05c	            STA DMA_SRC.ADDR+2
.1a3a32	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a3a34	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3a37	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3a3a	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3a3d	c2 20		rep #$20	            REP #$20
.1a3a3f	a5 23		lda $0823	            LDA ARGUMENT1
.1a3a41	8f 5d f0 1a	sta $1af05d	            STA DMA_SRC.SIZE
.1a3a45	e2 20		sep #$20	            SEP #$20
.1a3a47	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3a49	8f 5f f0 1a	sta $1af05f	            STA DMA_SRC.SIZE+2
.1a3a4d	e2 20		sep #$20	            SEP #$20
.1a3a4f	a9 00		lda #$00	            LDA #<DMA_LINEAR
.1a3a51	8f 59 f0 1a	sta $1af059	            STA DMA_SRC.MODE
.1a3a55	82 74 00	brl $1a3acc	                BRL process_to
.1a3a58					src_rect
.1a3a58	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3a5b	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3a5e	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3a61	c2 20		rep #$20	            REP #$20
.1a3a63	a5 23		lda $0823	            LDA ARGUMENT1
.1a3a65	8f 5a f0 1a	sta $1af05a	            STA DMA_SRC.ADDR
.1a3a69	e2 20		sep #$20	            SEP #$20
.1a3a6b	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3a6d	8f 5c f0 1a	sta $1af05c	            STA DMA_SRC.ADDR+2
.1a3a71	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a3a73	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3a76	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3a79	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a3a7c	c2 20		rep #$20	            REP #$20
.1a3a7e	a5 23		lda $0823	            LDA ARGUMENT1
.1a3a80	8f 60 f0 1a	sta $1af060	            STA DMA_SRC.WIDTH
.1a3a84	8d 00 01	sta $0100	            STA M0_OPERAND_A
.1a3a87	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a3a8a	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3a8d	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3a90	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a3a93	c2 20		rep #$20	            REP #$20
.1a3a95	a5 23		lda $0823	            LDA ARGUMENT1
.1a3a97	8f 62 f0 1a	sta $1af062	            STA DMA_SRC.HEIGHT
.1a3a9b	8d 02 01	sta $0102	            STA M0_OPERAND_B
.1a3a9e	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a3aa1	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3aa4	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3aa7	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a3aaa	c2 20		rep #$20	            REP #$20
.1a3aac	a5 23		lda $0823	            LDA ARGUMENT1
.1a3aae	8f 64 f0 1a	sta $1af064	            STA DMA_SRC.STRIDE
.1a3ab2	c2 20		rep #$20	            REP #$20
.1a3ab4	ad 04 01	lda $0104	            LDA M0_RESULT
.1a3ab7	8f 5d f0 1a	sta $1af05d	            STA DMA_SRC.SIZE
.1a3abb	e2 20		sep #$20	            SEP #$20
.1a3abd	ad 06 01	lda $0106	            LDA M0_RESULT+2
.1a3ac0	8f 5f f0 1a	sta $1af05f	            STA DMA_SRC.SIZE+2
.1a3ac4	e2 20		sep #$20	            SEP #$20
.1a3ac6	a9 01		lda #$01	            LDA #<DMA_RECT
.1a3ac8	8f 59 f0 1a	sta $1af059	            STA DMA_SRC.MODE
.1a3acc					process_to
.1a3acc	e2 20		sep #$20	            SEP #$20
.1a3ace	a9 9c		lda #$9c	                LDA #TOK_TO
.1a3ad0	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3ad3	20 43 22	jsr $1a2243	            JSR PEEK_TOK
.1a3ad6	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.1a3ad8	f0 23		beq $1a3afd	                BEQ dest_linear                     ; Yes: go to process a linear destination
.1a3ada	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.1a3adc	f0 5e		beq $1a3b3c	                BEQ dest_rect                       ; Yes: go to process a rectangular source
.1a3ade					syntax_err2
.1a3ade	08		php		            PHP
.1a3adf	c2 20		rep #$20	            REP #$20
.1a3ae1	48		pha		            PHA
.1a3ae2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3ae5	5b		tcd		            TCD
.1a3ae6	68		pla		            PLA
.1a3ae7	28		plp		            PLP
.1a3ae8	e2 20		sep #$20	            SEP #$20
.1a3aea	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3aec	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3af0	c2 20		rep #$20	            REP #$20
.1a3af2	29 ff 00	and #$00ff	            AND #$00FF
.1a3af5	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a3af8	e2 20		sep #$20	            SEP #$20
.1a3afa	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3afd					dest_linear
.1a3afd	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3b00	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3b03	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3b06	c2 20		rep #$20	            REP #$20
.1a3b08	a5 23		lda $0823	            LDA ARGUMENT1
.1a3b0a	8f 67 f0 1a	sta $1af067	            STA DMA_DEST.ADDR
.1a3b0e	e2 20		sep #$20	            SEP #$20
.1a3b10	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3b12	8f 69 f0 1a	sta $1af069	            STA DMA_DEST.ADDR+2
.1a3b16	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a3b18	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3b1b	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3b1e	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3b21	c2 20		rep #$20	            REP #$20
.1a3b23	a5 23		lda $0823	            LDA ARGUMENT1
.1a3b25	8f 6a f0 1a	sta $1af06a	            STA DMA_DEST.SIZE
.1a3b29	e2 20		sep #$20	            SEP #$20
.1a3b2b	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3b2d	8f 6c f0 1a	sta $1af06c	            STA DMA_DEST.SIZE+2
.1a3b31	e2 20		sep #$20	            SEP #$20
.1a3b33	a9 00		lda #$00	            LDA #<DMA_LINEAR
.1a3b35	8f 66 f0 1a	sta $1af066	            STA DMA_DEST.MODE
.1a3b39	82 74 00	brl $1a3bb0	                BRL verify
.1a3b3c					dest_rect
.1a3b3c	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3b3f	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3b42	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3b45	c2 20		rep #$20	            REP #$20
.1a3b47	a5 23		lda $0823	            LDA ARGUMENT1
.1a3b49	8f 67 f0 1a	sta $1af067	            STA DMA_DEST.ADDR
.1a3b4d	e2 20		sep #$20	            SEP #$20
.1a3b4f	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3b51	8f 69 f0 1a	sta $1af069	            STA DMA_DEST.ADDR+2
.1a3b55	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a3b57	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3b5a	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3b5d	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a3b60	c2 20		rep #$20	            REP #$20
.1a3b62	a5 23		lda $0823	            LDA ARGUMENT1
.1a3b64	8f 6d f0 1a	sta $1af06d	            STA DMA_DEST.WIDTH
.1a3b68	8d 00 01	sta $0100	            STA M0_OPERAND_A
.1a3b6b	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a3b6e	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3b71	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3b74	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a3b77	c2 20		rep #$20	            REP #$20
.1a3b79	a5 23		lda $0823	            LDA ARGUMENT1
.1a3b7b	8f 6f f0 1a	sta $1af06f	            STA DMA_DEST.HEIGHT
.1a3b7f	8d 02 01	sta $0102	            STA M0_OPERAND_B
.1a3b82	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a3b85	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3b88	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3b8b	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a3b8e	c2 20		rep #$20	            REP #$20
.1a3b90	a5 23		lda $0823	            LDA ARGUMENT1
.1a3b92	8f 71 f0 1a	sta $1af071	            STA DMA_DEST.STRIDE
.1a3b96	c2 20		rep #$20	            REP #$20
.1a3b98	ad 04 01	lda $0104	            LDA M0_RESULT
.1a3b9b	8f 6a f0 1a	sta $1af06a	            STA DMA_DEST.SIZE
.1a3b9f	e2 20		sep #$20	            SEP #$20
.1a3ba1	ad 06 01	lda $0106	            LDA M0_RESULT+2
.1a3ba4	8f 6c f0 1a	sta $1af06c	            STA DMA_DEST.SIZE+2
.1a3ba8	e2 20		sep #$20	            SEP #$20
.1a3baa	a9 01		lda #$01	            LDA #<DMA_RECT
.1a3bac	8f 66 f0 1a	sta $1af066	            STA DMA_DEST.MODE
.1a3bb0					verify
.1a3bb0	c2 20		rep #$20	            REP #$20
.1a3bb2	af 5d f0 1a	lda $1af05d	                LDA @l DMA_SRC.SIZE
.1a3bb6	cf 6a f0 1a	cmp $1af06a	                CMP @l DMA_DEST.SIZE
.1a3bba	d0 14		bne $1a3bd0	                BNE size_err
.1a3bbc	e2 20		sep #$20	            SEP #$20
.1a3bbe	af 5f f0 1a	lda $1af05f	                LDA @l DMA_SRC.SIZE+2
.1a3bc2	cf 6c f0 1a	cmp $1af06c	                CMP @l DMA_DEST.SIZE+2
.1a3bc6	d0 08		bne $1a3bd0	                BNE size_err
.1a3bc8	c2 20		rep #$20	            REP #$20
.1a3bca	20 f8 36	jsr $1a36f8	            JSR DO_DMA
.1a3bcd	28		plp		                PLP
.1a3bce	2b		pld		                PLD
.1a3bcf	60		rts		            RTS
.1a3bd0					size_err
.1a3bd0	08		php		            PHP
.1a3bd1	c2 20		rep #$20	            REP #$20
.1a3bd3	48		pha		            PHA
.1a3bd4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3bd7	5b		tcd		            TCD
.1a3bd8	68		pla		            PLA
.1a3bd9	28		plp		            PLP
.1a3bda	e2 20		sep #$20	            SEP #$20
.1a3bdc	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a3bde	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3be2	c2 20		rep #$20	            REP #$20
.1a3be4	29 ff 00	and #$00ff	            AND #$00FF
.1a3be7	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a3bea	e2 20		sep #$20	            SEP #$20
.1a3bec	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3bef					S_LOCATE
.1a3bef	08		php		                PHP
.1a3bf0	c2 30		rep #$30	            REP #$30
.1a3bf2	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3bf5	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a3bf8	a5 23		lda $0823	                LDA ARGUMENT1
.1a3bfa	48		pha		                PHA                         ; Save it for later
.1a3bfb	a9 2c 00	lda #$002c	                LDA #','                    ; Check for the comma separator
.1a3bfe	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3c01	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3c04	20 28 07	jsr $1a0728	            JSR ASS_ARG1_BYTE
.1a3c07	a4 23		ldy $0823	                LDY ARGUMENT1               ; Set Y to the row
.1a3c09	fa		plx		                PLX                         ; Set X to the column
.1a3c0a	20 20 00	jsr $1a0020	            JSR CURSORXY
.1a3c0d	28		plp		                PLP
.1a3c0e	60		rts		            RTS

;******  Return to file: src\statements.s

.1a3c0f					S_INPUT
.1a3c0f	08		php		                PHP
.1a3c10					varloop
.1a3c10	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a3c13	e2 20		sep #$20	            SEP #$20
.1a3c15	a7 00		lda [$0800]	                LDA [BIP]
.1a3c17	d0 03		bne $1a3c1c	                BNE check_colon
.1a3c19	4c b7 3c	jmp $1a3cb7	                JMP done            ; If EOL, we're done
.1a3c1c	c9 3a		cmp #$3a	check_colon     CMP #':'
.1a3c1e	d0 03		bne $1a3c23	                BNE check_string
.1a3c20	4c b7 3c	jmp $1a3cb7	                JMP done            ; If colon, we're done
.1a3c23	c9 22		cmp #$22	check_string    CMP #CHAR_DQUOTE    ; Is it the start of a string?
.1a3c25	d0 0b		bne $1a3c32	                BNE check_var       ; No: then it should be a variable name
.1a3c27	20 dd 1b	jsr $1a1bdd	            JSR EVALSTRING
.1a3c2a	20 c5 45	jsr $1a45c5	            JSR PR_STRING
.1a3c2d	a9 3b		lda #$3b	                LDA #';'            ; Look for a semicolon
.1a3c2f	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3c32					check_var
.1a3c32	20 a7 04	jsr $1a04a7	            JSR ISALPHA
.1a3c35	90 44		bcc $1a3c7b	                BCC syntax_err      ; No: it's a syntax error
.1a3c37	20 e5 53	jsr $1a53e5	            JSR VAR_FINDNAME
.1a3c3a	90 3f		bcc $1a3c7b	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3c3c	a9 3f		lda #$3f	                LDA #"?"            ; Print a "? " to follow
.1a3c3e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a3c41	a9 20		lda #$20	                LDA #CHAR_SP
.1a3c43	20 18 00	jsr $1a0018	            JSR PRINTC
.1a3c46	20 10 00	jsr $1a0010	            JSR INPUTLINE
.1a3c49	e2 20		sep #$20	            SEP #$20
.1a3c4b	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Check the type of the variable
.1a3c4d	c9 02		cmp #$02	                CMP #TYPE_STRING    ; If it's a string...
.1a3c4f	f0 49		beq $1a3c9a	                BEQ in_string       ; ... go to copy the string data
.1a3c51	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; If it's an integer...
.1a3c53	d0 03		bne $1a3c58	                BNE chk_float
.1a3c55	82 84 00	brl $1a3cdc	                BRL in_integer      ; ... go to parse the integer
.1a3c58	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT     ; If it's a float...
.1a3c5a	f0 5d		beq $1a3cb9	                BEQ in_float        ; ... go to parse the float
.1a3c5c	08		php		            PHP
.1a3c5d	c2 20		rep #$20	            REP #$20
.1a3c5f	48		pha		            PHA
.1a3c60	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3c63	5b		tcd		            TCD
.1a3c64	68		pla		            PLA
.1a3c65	28		plp		            PLP
.1a3c66	e2 20		sep #$20	            SEP #$20
.1a3c68	a9 04		lda #$04	            LDA #ERR_TYPE
.1a3c6a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3c6e	c2 20		rep #$20	            REP #$20
.1a3c70	29 ff 00	and #$00ff	            AND #$00FF
.1a3c73	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a3c76	e2 20		sep #$20	            SEP #$20
.1a3c78	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3c7b					syntax_err
.1a3c7b	08		php		            PHP
.1a3c7c	c2 20		rep #$20	            REP #$20
.1a3c7e	48		pha		            PHA
.1a3c7f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3c82	5b		tcd		            TCD
.1a3c83	68		pla		            PLA
.1a3c84	28		plp		            PLP
.1a3c85	e2 20		sep #$20	            SEP #$20
.1a3c87	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3c89	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3c8d	c2 20		rep #$20	            REP #$20
.1a3c8f	29 ff 00	and #$00ff	            AND #$00FF
.1a3c92	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a3c95	e2 20		sep #$20	            SEP #$20
.1a3c97	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3c9a					in_string
.1a3c9a	c2 20		rep #$20	            REP #$20
.1a3c9c	a9 00 4c	lda #$4c00	                LDA #<>IOBUF
.1a3c9f	85 23		sta $0823	                STA ARGUMENT1
.1a3ca1	a9 00 00	lda #$0000	                LDA #`IOBUF
.1a3ca4	85 25		sta $0825	                STA ARGUMENT1+2
.1a3ca6	e2 20		sep #$20	            SEP #$20
.1a3ca8	a9 02		lda #$02	                LDA #TYPE_STRING
.1a3caa	85 27		sta $0827	                STA ARGTYPE1
.1a3cac					save_input
.1a3cac	c2 20		rep #$20	            REP #$20
.1a3cae	20 48 53	jsr $1a5348	            JSR VAR_SET
.1a3cb1	a9 0d 00	lda #$000d	                LDA #CHAR_CR        ; Print a newline
.1a3cb4	20 18 00	jsr $1a0018	            JSR PRINTC
.1a3cb7	28		plp		done            PLP
.1a3cb8	60		rts		            RTS
.1a3cb9					in_float
.1a3cb9	c2 20		rep #$20	            REP #$20
.1a3cbb	a5 00		lda $0800	                LDA BIP             ; Save the BIP for later use
.1a3cbd	85 40		sta $0840	                STA SAVEBIP
.1a3cbf	a5 02		lda $0802	                LDA BIP+2
.1a3cc1	85 42		sta $0842	                STA SAVEBIP+2
.1a3cc3	a9 00 4c	lda #$4c00	                LDA #<>IOBUF        ; Point to the line that was just input
.1a3cc6	85 00		sta $0800	                STA BIP
.1a3cc8	a9 00 00	lda #$0000	                LDA #`IOBUF
.1a3ccb	85 02		sta $0802	                STA BIP+2
.1a3ccd	20 07 5a	jsr $1a5a07	            JSR PARSENUM
.1a3cd0	c2 20		rep #$20	            REP #$20
.1a3cd2	a5 40		lda $0840	                LDA SAVEBIP         ; Restore the BIP
.1a3cd4	85 00		sta $0800	                STA BIP
.1a3cd6	a5 42		lda $0842	                LDA SAVEBIP+2
.1a3cd8	85 02		sta $0802	                STA BIP+2
.1a3cda	80 d0		bra $1a3cac	                BRA save_input
.1a3cdc					in_integer
.1a3cdc	c2 20		rep #$20	            REP #$20
.1a3cde	a5 00		lda $0800	                LDA BIP             ; Save the BIP for later use
.1a3ce0	85 40		sta $0840	                STA SAVEBIP
.1a3ce2	a5 02		lda $0802	                LDA BIP+2
.1a3ce4	85 42		sta $0842	                STA SAVEBIP+2
.1a3ce6	a9 00 4c	lda #$4c00	                LDA #<>IOBUF        ; Point to the line that was just input
.1a3ce9	85 00		sta $0800	                STA BIP
.1a3ceb	a9 00 00	lda #$0000	                LDA #`IOBUF
.1a3cee	85 02		sta $0802	                STA BIP+2
.1a3cf0	20 9d 08	jsr $1a089d	            JSR PARSEINT
.1a3cf3	c2 20		rep #$20	            REP #$20
.1a3cf5	a5 40		lda $0840	                LDA SAVEBIP         ; Restore the BIP
.1a3cf7	85 00		sta $0800	                STA BIP
.1a3cf9	a5 42		lda $0842	                LDA SAVEBIP+2
.1a3cfb	85 02		sta $0802	                STA BIP+2
.1a3cfd	80 ad		bra $1a3cac	                BRA save_input
.1a3cff					S_GET
.1a3cff	08		php		                PHP
.1a3d00					varloop
.1a3d00	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a3d03	e2 20		sep #$20	            SEP #$20
.1a3d05	a7 00		lda [$0800]	                LDA [BIP]
.1a3d07	f0 47		beq $1a3d50	                BEQ done            ; If EOL, we're done
.1a3d09	c9 3a		cmp #$3a	                CMP #':'
.1a3d0b	f0 43		beq $1a3d50	                BEQ done            ; If colon, we're done
.1a3d0d	20 a7 04	jsr $1a04a7	            JSR ISALPHA
.1a3d10	90 40		bcc $1a3d52	                BCC syntax_err      ; No: it's a syntax error
.1a3d12	20 e5 53	jsr $1a53e5	            JSR VAR_FINDNAME
.1a3d15	90 3b		bcc $1a3d52	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3d17	20 c6 14	jsr $1a14c6	            JSR TEMPSTRING
.1a3d1a	20 14 00	jsr $1a0014	            JSR GETKEY
.1a3d1d	e2 20		sep #$20	            SEP #$20
.1a3d1f	a0 00 00	ldy #$0000	                LDY #0
.1a3d22	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a3d24	a9 00		lda #$00	                LDA #0
.1a3d26	c8		iny		                INY
.1a3d27	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a3d29	c2 20		rep #$20	            REP #$20
.1a3d2b	a5 16		lda $0816	                LDA STRPTR
.1a3d2d	85 23		sta $0823	                STA ARGUMENT1
.1a3d2f	a5 18		lda $0818	                LDA STRPTR+2
.1a3d31	85 25		sta $0825	                STA ARGUMENT1+2
.1a3d33	e2 20		sep #$20	            SEP #$20
.1a3d35	a9 02		lda #$02	                LDA #TYPE_STRING
.1a3d37	85 27		sta $0827	                STA ARGTYPE1
.1a3d39	20 48 53	jsr $1a5348	            JSR VAR_SET
.1a3d3c	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a3d3f	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.1a3d41	f0 0d		beq $1a3d50	                BEQ done            ; EOL? We're done
.1a3d43	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.1a3d45	f0 09		beq $1a3d50	                BEQ done
.1a3d47	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.1a3d49	d0 07		bne $1a3d52	                BNE syntax_err      ; Nope: syntax error
.1a3d4b	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a3d4e	80 b0		bra $1a3d00	                BRA varloop
.1a3d50	28		plp		done            PLP
.1a3d51	60		rts		            RTS
.1a3d52					syntax_err
.1a3d52	08		php		            PHP
.1a3d53	c2 20		rep #$20	            REP #$20
.1a3d55	48		pha		            PHA
.1a3d56	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3d59	5b		tcd		            TCD
.1a3d5a	68		pla		            PLA
.1a3d5b	28		plp		            PLP
.1a3d5c	e2 20		sep #$20	            SEP #$20
.1a3d5e	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3d60	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3d64	c2 20		rep #$20	            REP #$20
.1a3d66	29 ff 00	and #$00ff	            AND #$00FF
.1a3d69	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a3d6c	e2 20		sep #$20	            SEP #$20
.1a3d6e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3d71					S_CALL
.1a3d71	08		php		                PHP
.1a3d72	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3d75	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3d78	e2 20		sep #$20	            SEP #$20
.1a3d7a	a9 5c		lda #$5c	                LDA #$5C            ; Set the opcode for JML
.1a3d7c	85 a2		sta $08a2	                STA MJUMPINST
.1a3d7e	c2 20		rep #$20	            REP #$20
.1a3d80	a5 23		lda $0823	                LDA ARGUMENT1
.1a3d82	85 a3		sta $08a3	                STA MJUMPADDR
.1a3d84	e2 20		sep #$20	            SEP #$20
.1a3d86	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3d88	85 a5		sta $08a5	                STA MJUMPADDR+2
.1a3d8a	e2 20		sep #$20	            SEP #$20
.1a3d8c	a9 2c		lda #$2c	                LDA #','
.1a3d8e	85 37		sta $0837	                STA TARGETTOK
.1a3d90	20 24 22	jsr $1a2224	            JSR OPT_TOK
.1a3d93	90 41		bcc $1a3dd6	                BCC launch          ; Not present... go ahead and launch
.1a3d95	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a3d98	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3d9b	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a3d9e	c2 20		rep #$20	            REP #$20
.1a3da0	a5 23		lda $0823	                LDA ARGUMENT1
.1a3da2	85 55		sta $0855	                STA MARG1           ; Save it to MARG1
.1a3da4	e2 20		sep #$20	            SEP #$20
.1a3da6	a9 2c		lda #$2c	                LDA #','
.1a3da8	85 37		sta $0837	                STA TARGETTOK
.1a3daa	20 24 22	jsr $1a2224	            JSR OPT_TOK
.1a3dad	90 27		bcc $1a3dd6	                BCC launch          ; Not present... go ahead and launch
.1a3daf	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a3db2	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3db5	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a3db8	c2 20		rep #$20	            REP #$20
.1a3dba	a5 23		lda $0823	                LDA ARGUMENT1
.1a3dbc	85 59		sta $0859	                STA MARG2           ; Save it to MARG2
.1a3dbe	e2 20		sep #$20	            SEP #$20
.1a3dc0	a9 2c		lda #$2c	                LDA #','
.1a3dc2	85 37		sta $0837	                STA TARGETTOK
.1a3dc4	20 24 22	jsr $1a2224	            JSR OPT_TOK
.1a3dc7	90 0d		bcc $1a3dd6	                BCC launch          ; Not present... go ahead and launch
.1a3dc9	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a3dcc	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3dcf	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a3dd2	c2 20		rep #$20	            REP #$20
.1a3dd4	a4 23		ldy $0823	                LDY ARGUMENT1
.1a3dd6	a6 59		ldx $0859	launch          LDX MARG2
.1a3dd8	a5 55		lda $0855	                LDA MARG1
.1a3dda	0b		phd		                PHD
.1a3ddb	8b		phb		                PHB
.1a3ddc	08		php		                PHP
.1a3ddd	22 a2 08 00	jsl $0008a2	                JSL MJUMPINST       ; Call the subroutine indicated
.1a3de1	28		plp		                PLP
.1a3de2	ab		plb		                PLB
.1a3de3	2b		pld		                PLD
.1a3de4	20 27 21	jsr $1a2127	            JSR SKIPSTMT
.1a3de7	28		plp		                PLP
.1a3de8	60		rts		            RTS
.1a3de9					type_err
.1a3de9	08		php		            PHP
.1a3dea	c2 20		rep #$20	            REP #$20
.1a3dec	48		pha		            PHA
.1a3ded	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3df0	5b		tcd		            TCD
.1a3df1	68		pla		            PLA
.1a3df2	28		plp		            PLP
.1a3df3	e2 20		sep #$20	            SEP #$20
.1a3df5	a9 04		lda #$04	            LDA #ERR_TYPE
.1a3df7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3dfb	c2 20		rep #$20	            REP #$20
.1a3dfd	29 ff 00	and #$00ff	            AND #$00FF
.1a3e00	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a3e03	e2 20		sep #$20	            SEP #$20
.1a3e05	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3e08					S_DIM
.1a3e08	08		php		                PHP
.1a3e09	e2 20		sep #$20	            SEP #$20
.1a3e0b	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a3e0e	20 e5 53	jsr $1a53e5	            JSR VAR_FINDNAME
.1a3e11	90 64		bcc $1a3e77	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3e13	a9 8f		lda #$8f	                LDA #TOK_LPAREN     ; Verify we have a left parenthesis
.1a3e15	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a3e18	a9 01		lda #$01	                LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.1a3e1a	20 ed 19	jsr $1a19ed	            JSR PHOPERATOR
.1a3e1d	a2 01 00	ldx #$0001	                LDX #1
.1a3e20	a9 00		lda #$00	                LDA #0
.1a3e22	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF     ; Set the dimension count to 0
.1a3e26					dim_loop
.1a3e26	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3e29	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a3e2c	c2 20		rep #$20	            REP #$20
.1a3e2e	a5 23		lda $0823	                LDA ARGUMENT1
.1a3e30	9f 00 4d 00	sta $004d00,x	                STA @lARRIDXBUF,X   ; And store it in the buffer
.1a3e34	e2 20		sep #$20	            SEP #$20
.1a3e36	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF     ; Add to the dimension count
.1a3e3a	1a		inc a		                INC A
.1a3e3b	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF
.1a3e3f	30 55		bmi $1a3e96	                BMI overflow        ; If > 127 throw an error
.1a3e41	e8		inx		                INX
.1a3e42	e8		inx		                INX
.1a3e43	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a3e46	a7 00		lda [$0800]	                LDA [BIP]           ; Check the character
.1a3e48	c9 2c		cmp #$2c	                CMP #','            ; Is it a comma?
.1a3e4a	f0 25		beq $1a3e71	                BEQ skip_comma      ; Yes: get the next dimension
.1a3e4c	c9 90		cmp #$90	                CMP #TOK_RPAREN     ; No: is it a ")"?
.1a3e4e	d0 27		bne $1a3e77	                BNE syntax_err      ; No: throw a syntax error
.1a3e50	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a3e53	20 63 66	jsr $1a6663	            JSR ARR_ALLOC
.1a3e56	c2 20		rep #$20	            REP #$20
.1a3e58	a5 c0		lda $08c0	                LDA CURRBLOCK       ; Set up the pointer to the array
.1a3e5a	85 23		sta $0823	                STA ARGUMENT1
.1a3e5c	e2 20		sep #$20	            SEP #$20
.1a3e5e	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a3e60	85 25		sta $0825	                STA ARGUMENT1+2
.1a3e62	64 26		stz $0826	                STZ ARGUMENT1+3
.1a3e64	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Get the type of the values
.1a3e66	09 80		ora #$80	                ORA #$80            ; Make sure we change the type to array
.1a3e68	85 ea		sta $08ea	                STA TOFINDTYPE      ; And save it back for searching
.1a3e6a	85 27		sta $0827	                STA ARGTYPE1        ; And for the value to set
.1a3e6c	20 48 53	jsr $1a5348	            JSR VAR_SET
.1a3e6f	28		plp		                PLP
.1a3e70	60		rts		            RTS
.1a3e71					skip_comma
.1a3e71	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a3e74	4c 26 3e	jmp $1a3e26	                JMP dim_loop
.1a3e77					syntax_err
.1a3e77	08		php		            PHP
.1a3e78	c2 20		rep #$20	            REP #$20
.1a3e7a	48		pha		            PHA
.1a3e7b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3e7e	5b		tcd		            TCD
.1a3e7f	68		pla		            PLA
.1a3e80	28		plp		            PLP
.1a3e81	e2 20		sep #$20	            SEP #$20
.1a3e83	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3e85	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3e89	c2 20		rep #$20	            REP #$20
.1a3e8b	29 ff 00	and #$00ff	            AND #$00FF
.1a3e8e	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a3e91	e2 20		sep #$20	            SEP #$20
.1a3e93	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3e96					overflow
.1a3e96	08		php		            PHP
.1a3e97	c2 20		rep #$20	            REP #$20
.1a3e99	48		pha		            PHA
.1a3e9a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3e9d	5b		tcd		            TCD
.1a3e9e	68		pla		            PLA
.1a3e9f	28		plp		            PLP
.1a3ea0	e2 20		sep #$20	            SEP #$20
.1a3ea2	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a3ea4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3ea8	c2 20		rep #$20	            REP #$20
.1a3eaa	29 ff 00	and #$00ff	            AND #$00FF
.1a3ead	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a3eb0	e2 20		sep #$20	            SEP #$20
.1a3eb2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3eb5					S_READ
.1a3eb5	08		php		                PHP
.1a3eb6					varloop
.1a3eb6	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a3eb9	e2 20		sep #$20	            SEP #$20
.1a3ebb	a7 00		lda [$0800]	                LDA [BIP]
.1a3ebd	f0 28		beq $1a3ee7	                BEQ done            ; If EOL, we're done
.1a3ebf	c9 3a		cmp #$3a	                CMP #':'
.1a3ec1	f0 24		beq $1a3ee7	                BEQ done            ; If colon, we're done
.1a3ec3	20 a7 04	jsr $1a04a7	            JSR ISALPHA
.1a3ec6	90 21		bcc $1a3ee9	                BCC syntax_err      ; No: it's a syntax error
.1a3ec8	20 e5 53	jsr $1a53e5	            JSR VAR_FINDNAME
.1a3ecb	90 1c		bcc $1a3ee9	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3ecd	20 08 3f	jsr $1a3f08	            JSR NEXTDATA
.1a3ed0	20 48 53	jsr $1a5348	            JSR VAR_SET
.1a3ed3	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a3ed6	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.1a3ed8	f0 0d		beq $1a3ee7	                BEQ done            ; EOL? We're done
.1a3eda	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.1a3edc	f0 09		beq $1a3ee7	                BEQ done
.1a3ede	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.1a3ee0	d0 07		bne $1a3ee9	                BNE syntax_err      ; Nope: syntax error
.1a3ee2	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a3ee5	80 cf		bra $1a3eb6	                BRA varloop
.1a3ee7	28		plp		done            PLP
.1a3ee8	60		rts		            RTS
.1a3ee9					syntax_err
.1a3ee9	08		php		            PHP
.1a3eea	c2 20		rep #$20	            REP #$20
.1a3eec	48		pha		            PHA
.1a3eed	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3ef0	5b		tcd		            TCD
.1a3ef1	68		pla		            PLA
.1a3ef2	28		plp		            PLP
.1a3ef3	e2 20		sep #$20	            SEP #$20
.1a3ef5	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3ef7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3efb	c2 20		rep #$20	            REP #$20
.1a3efd	29 ff 00	and #$00ff	            AND #$00FF
.1a3f00	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a3f03	e2 20		sep #$20	            SEP #$20
.1a3f05	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3f08					NEXTDATA
.1a3f08	08		php		                PHP
.1a3f09	a5 02		lda $0802	                LDA BIP+2           ; Save BIP
.1a3f0b	85 42		sta $0842	                STA SAVEBIP+2
.1a3f0d	a5 00		lda $0800	                LDA BIP
.1a3f0f	85 40		sta $0840	                STA SAVEBIP
.1a3f11	a5 1c		lda $081c	                LDA CURLINE+2       ; Save CURLINE
.1a3f13	85 46		sta $0846	                STA SAVELINE+2
.1a3f15	a5 1a		lda $081a	                LDA CURLINE
.1a3f17	85 44		sta $0844	                STA SAVELINE
.1a3f19	c2 20		rep #$20	            REP #$20
.1a3f1b	a5 3a		lda $083a	                LDA DATABIP+2
.1a3f1d	d0 04		bne $1a3f23	                BNE data_set
.1a3f1f	a5 38		lda $0838	                LDA DATABIP
.1a3f21	f0 4e		beq $1a3f71	                BEQ scan_start      ; No: scan for a DATA statement
.1a3f23	a5 38		lda $0838	data_set        LDA DATABIP         ; Move BIP to the DATA statement
.1a3f25	85 00		sta $0800	                STA BIP
.1a3f27	a5 3a		lda $083a	                LDA DATABIP+2
.1a3f29	85 02		sta $0802	                STA BIP+2
.1a3f2b	a5 3c		lda $083c	                LDA DATALINE        ; Set CURLINE from DATALINE
.1a3f2d	85 1a		sta $081a	                STA CURLINE
.1a3f2f	a5 3e		lda $083e	                LDA DATALINE+2
.1a3f31	85 1c		sta $081c	                STA CURLINE+2
.1a3f33	e2 20		sep #$20	            SEP #$20
.1a3f35	a7 00		lda [$0800]	                LDA [BIP]           ; Check character at BIP
.1a3f37	f0 53		beq $1a3f8c	                BEQ scan_DATA       ; EOL? scan for a DATA statement
.1a3f39	c9 3a		cmp #$3a	                CMP #':'            ; Colon?
.1a3f3b	f0 4f		beq $1a3f8c	                BEQ scan_DATA       ; ... scan for a DATA statement
.1a3f3d	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.1a3f3f	d0 03		bne $1a3f44	                BNE skip_parse      ; No: skip leading WS and try to parse
.1a3f41	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a3f44					skip_parse
.1a3f44	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a3f47	a7 00		lda [$0800]	                LDA [BIP]
.1a3f49	c9 22		cmp #$22	                CMP #CHAR_DQUOTE    ; Is it a quote?
.1a3f4b	f0 4e		beq $1a3f9b	                BEQ read_string     ; Yes: process the string
.1a3f4d	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a3f50	b0 4e		bcs $1a3fa0	                BCS read_number     ; Yes: process the number
.1a3f52					syntax_err
.1a3f52	08		php		            PHP
.1a3f53	c2 20		rep #$20	            REP #$20
.1a3f55	48		pha		            PHA
.1a3f56	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3f59	5b		tcd		            TCD
.1a3f5a	68		pla		            PLA
.1a3f5b	28		plp		            PLP
.1a3f5c	e2 20		sep #$20	            SEP #$20
.1a3f5e	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3f60	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3f64	c2 20		rep #$20	            REP #$20
.1a3f66	29 ff 00	and #$00ff	            AND #$00FF
.1a3f69	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a3f6c	e2 20		sep #$20	            SEP #$20
.1a3f6e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3f71					scan_start
.1a3f71	c2 20		rep #$20	            REP #$20
.1a3f73	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT    ; Point CURLINE to the first line
.1a3f76	85 1a		sta $081a	                STA CURLINE
.1a3f78	a9 16 00	lda #$0016	                LDA #`BASIC_BOT
.1a3f7b	85 1c		sta $081c	                STA CURLINE+2
.1a3f7d	18		clc		                CLC
.1a3f7e	a5 1a		lda $081a	                LDA CURLINE         ; Point BIP to the first possible token
.1a3f80	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.1a3f83	85 00		sta $0800	                STA BIP
.1a3f85	a5 1c		lda $081c	                LDA CURLINE+2
.1a3f87	69 00 00	adc #$0000	                ADC #0
.1a3f8a	85 02		sta $0802	                STA BIP+2
.1a3f8c					scan_data
.1a3f8c	e2 20		sep #$20	            SEP #$20
.1a3f8e	a9 80		lda #$80	                LDA #$80            ; We don't want to process nesting
.1a3f90	85 35		sta $0835	                STA SKIPNEST
.1a3f92	a9 ab		lda #$ab	                LDA #TOK_DATA       ; We're looking for a DATA token
.1a3f94	85 37		sta $0837	                STA TARGETTOK
.1a3f96	20 39 21	jsr $1a2139	            JSR SKIPTOTOK
.1a3f99	80 a9		bra $1a3f44	                BRA skip_parse
.1a3f9b					read_string
.1a3f9b	20 dd 1b	jsr $1a1bdd	            JSR EVALSTRING
.1a3f9e	80 03		bra $1a3fa3	                BRA done
.1a3fa0					read_number
.1a3fa0	20 cf 1a	jsr $1a1acf	            JSR EVALNUMBER
.1a3fa3					done
.1a3fa3	c2 20		rep #$20	            REP #$20
.1a3fa5	a5 00		lda $0800	                LDA BIP             ; Save BIP to DATABIP
.1a3fa7	85 38		sta $0838	                STA DATABIP
.1a3fa9	a5 02		lda $0802	                LDA BIP+2
.1a3fab	85 3a		sta $083a	                STA DATABIP+2
.1a3fad	a5 1a		lda $081a	                LDA CURLINE         ; Save CURLINE to DATALINE
.1a3faf	85 3c		sta $083c	                STA DATALINE
.1a3fb1	a5 1c		lda $081c	                LDA CURLINE+2
.1a3fb3	85 3e		sta $083e	                STA DATALINE+2
.1a3fb5	a5 44		lda $0844	                LDA SAVELINE        ; Restore CURLINE
.1a3fb7	85 1a		sta $081a	                STA CURLINE
.1a3fb9	a5 46		lda $0846	                LDA SAVELINE+2
.1a3fbb	85 1c		sta $081c	                STA CURLINE+2
.1a3fbd	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.1a3fbf	85 00		sta $0800	                STA BIP
.1a3fc1	a5 42		lda $0842	                LDA SAVEBIP+2
.1a3fc3	85 02		sta $0802	                STA BIP+2
.1a3fc5	28		plp		                PLP
.1a3fc6	60		rts		            RTS
.1a3fc7					S_DATA
.1a3fc7	20 27 21	jsr $1a2127	            JSR SKIPSTMT
.1a3fca	60		rts		            RTS
.1a3fcb					S_RESTORE
.1a3fcb	64 38		stz $0838	                STZ DATABIP         ; Just set DATABIP to 0
.1a3fcd	64 3a		stz $083a	                STZ DATABIP+2       ; The next READ will move it to the first DATA
.1a3fcf	64 3c		stz $083c	                STZ DATALINE        ; Set DATALINE to 0
.1a3fd1	64 3e		stz $083e	                STZ DATALINE+2
.1a3fd3	60		rts		            RTS
.1a3fd4					S_CLS
.1a3fd4	20 24 00	jsr $1a0024	            JSR CLSCREEN
.1a3fd7	60		rts		            RTS
.1a3fd8					S_POKEL
.1a3fd8	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3fdb	c2 20		rep #$20	            REP #$20
.1a3fdd	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.1a3fdf	48		pha		                PHA
.1a3fe0	a5 23		lda $0823	                LDA ARGUMENT1
.1a3fe2	48		pha		                PHA
.1a3fe3	e2 20		sep #$20	            SEP #$20
.1a3fe5	a7 00		lda [$0800]	                LDA [BIP]
.1a3fe7	c9 2c		cmp #$2c	                CMP #','
.1a3fe9	d0 22		bne $1a400d	                BNE syntax_err
.1a3feb	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a3fee	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a3ff1	c2 20		rep #$20	            REP #$20
.1a3ff3	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a3ff5	d0 35		bne $1a402c	                BNE range_err
.1a3ff7	68		pla		                PLA                 ; Pull the target address from the stack
.1a3ff8	85 08		sta $0808	                STA INDEX           ; and into INDEX
.1a3ffa	68		pla		                PLA
.1a3ffb	85 0a		sta $080a	                STA INDEX+2
.1a3ffd	c2 20		rep #$20	            REP #$20
.1a3fff	a5 23		lda $0823	                LDA ARGUMENT1
.1a4001	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.1a4003	e2 20		sep #$20	            SEP #$20
.1a4005	a0 02 00	ldy #$0002	                LDY #2
.1a4008	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a400a	97 08		sta [$0808],y	                STA [INDEX],Y
.1a400c	60		rts		            RTS
.1a400d					syntax_err
.1a400d	08		php		            PHP
.1a400e	c2 20		rep #$20	            REP #$20
.1a4010	48		pha		            PHA
.1a4011	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4014	5b		tcd		            TCD
.1a4015	68		pla		            PLA
.1a4016	28		plp		            PLP
.1a4017	e2 20		sep #$20	            SEP #$20
.1a4019	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a401b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a401f	c2 20		rep #$20	            REP #$20
.1a4021	29 ff 00	and #$00ff	            AND #$00FF
.1a4024	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4027	e2 20		sep #$20	            SEP #$20
.1a4029	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a402c					range_err
.1a402c	08		php		            PHP
.1a402d	c2 20		rep #$20	            REP #$20
.1a402f	48		pha		            PHA
.1a4030	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4033	5b		tcd		            TCD
.1a4034	68		pla		            PLA
.1a4035	28		plp		            PLP
.1a4036	e2 20		sep #$20	            SEP #$20
.1a4038	a9 09		lda #$09	            LDA #ERR_RANGE
.1a403a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a403e	c2 20		rep #$20	            REP #$20
.1a4040	29 ff 00	and #$00ff	            AND #$00FF
.1a4043	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4046	e2 20		sep #$20	            SEP #$20
.1a4048	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a404b					S_POKEW
.1a404b	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a404e	c2 20		rep #$20	            REP #$20
.1a4050	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.1a4052	48		pha		                PHA
.1a4053	a5 23		lda $0823	                LDA ARGUMENT1
.1a4055	48		pha		                PHA
.1a4056	e2 20		sep #$20	            SEP #$20
.1a4058	a7 00		lda [$0800]	                LDA [BIP]
.1a405a	c9 2c		cmp #$2c	                CMP #','
.1a405c	d0 19		bne $1a4077	                BNE syntax_err
.1a405e	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4061	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4064	c2 20		rep #$20	            REP #$20
.1a4066	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4068	d0 2c		bne $1a4096	                BNE range_err
.1a406a	68		pla		                PLA                 ; Pull the target address from the stack
.1a406b	85 08		sta $0808	                STA INDEX           ; and into INDEX
.1a406d	68		pla		                PLA
.1a406e	85 0a		sta $080a	                STA INDEX+2
.1a4070	c2 20		rep #$20	            REP #$20
.1a4072	a5 23		lda $0823	                LDA ARGUMENT1
.1a4074	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.1a4076	60		rts		            RTS
.1a4077					syntax_err
.1a4077	08		php		            PHP
.1a4078	c2 20		rep #$20	            REP #$20
.1a407a	48		pha		            PHA
.1a407b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a407e	5b		tcd		            TCD
.1a407f	68		pla		            PLA
.1a4080	28		plp		            PLP
.1a4081	e2 20		sep #$20	            SEP #$20
.1a4083	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4085	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4089	c2 20		rep #$20	            REP #$20
.1a408b	29 ff 00	and #$00ff	            AND #$00FF
.1a408e	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4091	e2 20		sep #$20	            SEP #$20
.1a4093	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4096					range_err
.1a4096	08		php		            PHP
.1a4097	c2 20		rep #$20	            REP #$20
.1a4099	48		pha		            PHA
.1a409a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a409d	5b		tcd		            TCD
.1a409e	68		pla		            PLA
.1a409f	28		plp		            PLP
.1a40a0	e2 20		sep #$20	            SEP #$20
.1a40a2	a9 09		lda #$09	            LDA #ERR_RANGE
.1a40a4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a40a8	c2 20		rep #$20	            REP #$20
.1a40aa	29 ff 00	and #$00ff	            AND #$00FF
.1a40ad	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a40b0	e2 20		sep #$20	            SEP #$20
.1a40b2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a40b5					S_POKE
.1a40b5	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a40b8	c2 20		rep #$20	            REP #$20
.1a40ba	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.1a40bc	48		pha		                PHA
.1a40bd	a5 23		lda $0823	                LDA ARGUMENT1
.1a40bf	48		pha		                PHA
.1a40c0	e2 20		sep #$20	            SEP #$20
.1a40c2	a7 00		lda [$0800]	                LDA [BIP]
.1a40c4	c9 2c		cmp #$2c	                CMP #','
.1a40c6	d0 1f		bne $1a40e7	                BNE syntax_err
.1a40c8	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a40cb	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a40ce	e2 20		sep #$20	            SEP #$20
.1a40d0	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Make sure the value is from 0 - 255
.1a40d2	d0 32		bne $1a4106	                BNE range_err
.1a40d4	c2 20		rep #$20	            REP #$20
.1a40d6	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a40d8	d0 2c		bne $1a4106	                BNE range_err
.1a40da	68		pla		                PLA                 ; Pull the target address from the stack
.1a40db	85 08		sta $0808	                STA INDEX           ; and into INDEX
.1a40dd	68		pla		                PLA
.1a40de	85 0a		sta $080a	                STA INDEX+2
.1a40e0	e2 20		sep #$20	            SEP #$20
.1a40e2	a5 23		lda $0823	                LDA ARGUMENT1
.1a40e4	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.1a40e6	60		rts		            RTS
.1a40e7					syntax_err
.1a40e7	08		php		            PHP
.1a40e8	c2 20		rep #$20	            REP #$20
.1a40ea	48		pha		            PHA
.1a40eb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a40ee	5b		tcd		            TCD
.1a40ef	68		pla		            PLA
.1a40f0	28		plp		            PLP
.1a40f1	e2 20		sep #$20	            SEP #$20
.1a40f3	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a40f5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a40f9	c2 20		rep #$20	            REP #$20
.1a40fb	29 ff 00	and #$00ff	            AND #$00FF
.1a40fe	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4101	e2 20		sep #$20	            SEP #$20
.1a4103	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4106					range_err
.1a4106	08		php		            PHP
.1a4107	c2 20		rep #$20	            REP #$20
.1a4109	48		pha		            PHA
.1a410a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a410d	5b		tcd		            TCD
.1a410e	68		pla		            PLA
.1a410f	28		plp		            PLP
.1a4110	e2 20		sep #$20	            SEP #$20
.1a4112	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4114	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4118	c2 20		rep #$20	            REP #$20
.1a411a	29 ff 00	and #$00ff	            AND #$00FF
.1a411d	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4120	e2 20		sep #$20	            SEP #$20
.1a4122	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4125					S_STOP
.1a4125	08		php		            PHP
.1a4126	c2 20		rep #$20	            REP #$20
.1a4128	48		pha		            PHA
.1a4129	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a412c	5b		tcd		            TCD
.1a412d	68		pla		            PLA
.1a412e	28		plp		            PLP
.1a412f	e2 20		sep #$20	            SEP #$20
.1a4131	a9 01		lda #$01	            LDA #ERR_BREAK
.1a4133	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4137	c2 20		rep #$20	            REP #$20
.1a4139	29 ff 00	and #$00ff	            AND #$00FF
.1a413c	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a413f	e2 20		sep #$20	            SEP #$20
.1a4141	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4144					S_REM
.1a4144	08		php		                PHP
.1a4145	e2 20		sep #$20	            SEP #$20
.1a4147	a7 00		lda [$0800]	rem_loop        LDA [BIP]
.1a4149	f0 05		beq $1a4150	                BEQ done
.1a414b	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a414e	80 f7		bra $1a4147	                BRA rem_loop
.1a4150	28		plp		done            PLP
.1a4151	60		rts		            RTS
.1a4152					S_EXIT
.1a4152	08		php		                PHP
.1a4153	28		plp		                PLP
.1a4154	60		rts		            RTS
.1a4155					S_DO
.1a4155	08		php		                PHP
.1a4156	28		plp		                PLP
.1a4157	60		rts		            RTS
.0000					DO_RECORD
>0000					BIP             .dword  ?
>0004					CURLINE         .dword  ?
.1a4158					S_LOOP
.1a4158	08		php		                PHP
.1a4159	28		plp		                PLP
.1a415a	60		rts		            RTS
.1a415b					S_FOR
.1a415b	08		php		                PHP
.1a415c	c2 20		rep #$20	            REP #$20
.1a415e	a5 1c		lda $081c	                LDA CURLINE+2
.1a4160	20 ea 1d	jsr $1a1dea	            JSR PHRETURN
.1a4163	a5 1a		lda $081a	                LDA CURLINE
.1a4165	20 ea 1d	jsr $1a1dea	            JSR PHRETURN
.1a4168	a5 02		lda $0802	                LDA BIP+2           ; Save current BIP
.1a416a	48		pha		                PHA
.1a416b	a5 00		lda $0800	                LDA BIP
.1a416d	48		pha		                PHA
.1a416e	20 27 21	jsr $1a2127	            JSR SKIPSTMT
.1a4171	a5 02		lda $0802	                LDA BIP+2           ; Save the BIP for the next statement to the RETURN stack
.1a4173	20 ea 1d	jsr $1a1dea	            JSR PHRETURN
.1a4176	a5 00		lda $0800	                LDA BIP
.1a4178	20 ea 1d	jsr $1a1dea	            JSR PHRETURN
.1a417b	68		pla		                PLA                 ; Restore the original BIP
.1a417c	85 00		sta $0800	                STA BIP
.1a417e	68		pla		                PLA
.1a417f	85 02		sta $0802	                STA BIP+2
.1a4181	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a4184					get_name
.1a4184	20 e5 53	jsr $1a53e5	            JSR VAR_FINDNAME
.1a4187	b0 1f		bcs $1a41a8	                BCS push_name       ; If we didn't find a name, thrown an error
.1a4189	08		php		            PHP
.1a418a	c2 20		rep #$20	            REP #$20
.1a418c	48		pha		            PHA
.1a418d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4190	5b		tcd		            TCD
.1a4191	68		pla		            PLA
.1a4192	28		plp		            PLP
.1a4193	e2 20		sep #$20	            SEP #$20
.1a4195	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a4197	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a419b	c2 20		rep #$20	            REP #$20
.1a419d	29 ff 00	and #$00ff	            AND #$00FF
.1a41a0	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a41a3	e2 20		sep #$20	            SEP #$20
.1a41a5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a41a8					push_name
.1a41a8	e2 20		sep #$20	            SEP #$20
.1a41aa	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; To the return stack
.1a41ac	20 01 1e	jsr $1a1e01	            JSR PHRETURNB
.1a41af	a5 e9		lda $08e9	                LDA TOFIND+2
.1a41b1	20 01 1e	jsr $1a1e01	            JSR PHRETURNB
.1a41b4	c2 20		rep #$20	            REP #$20
.1a41b6	a5 e7		lda $08e7	                LDA TOFIND
.1a41b8	20 ea 1d	jsr $1a1dea	            JSR PHRETURN
.1a41bb					else
.1a41bb	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a41be	e2 20		sep #$20	            SEP #$20
.1a41c0	a7 00		lda [$0800]	                LDA [BIP]
.1a41c2	c9 8a		cmp #$8a	                CMP #TOK_EQ
.1a41c4	d0 6a		bne $1a4230	                BNE syntax_err      ; If not found: signal an syntax error
.1a41c6	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Verify type of variable
.1a41c8	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; Is it integer?
.1a41ca	f0 04		beq $1a41d0	                BEQ process_initial ; Yes: it's ok
.1a41cc	c9 01		cmp #$01	                CMP #TYPE_FLOAT     ; Is it floating point?
.1a41ce	f0 00		beq $1a41d0	                BEQ process_initial ; Yes: it's ok
.1a41d0					process_initial
.1a41d0	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a41d3	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a41d6	20 48 53	jsr $1a5348	            JSR VAR_SET
.1a41d9	e2 20		sep #$20	            SEP #$20
.1a41db	a9 9c		lda #$9c	                LDA #TOK_TO         ; Expect the next token to be TO
.1a41dd	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a41e0	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a41e3	c2 20		rep #$20	            REP #$20
.1a41e5	a5 27		lda $0827	                LDA ARGTYPE1
.1a41e7	20 ea 1d	jsr $1a1dea	            JSR PHRETURN
.1a41ea	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a41ec	20 ea 1d	jsr $1a1dea	            JSR PHRETURN
.1a41ef	a5 23		lda $0823	                LDA ARGUMENT1
.1a41f1	20 ea 1d	jsr $1a1dea	            JSR PHRETURN
.1a41f4	e2 20		sep #$20	            SEP #$20
.1a41f6	a9 9d		lda #$9d	                LDA #TOK_STEP
.1a41f8	85 37		sta $0837	                STA TARGETTOK
.1a41fa	20 24 22	jsr $1a2224	            JSR OPT_TOK
.1a41fd	90 1b		bcc $1a421a	                BCC default_inc     ; Not found: set a default increment of 1
.1a41ff	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4202	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4205	e2 20		sep #$20	            SEP #$20
.1a4207	a5 27		lda $0827	                LDA ARGTYPE1        ; Push the result as the increment
.1a4209	20 ea 1d	jsr $1a1dea	            JSR PHRETURN
.1a420c	c2 20		rep #$20	            REP #$20
.1a420e	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4210	20 ea 1d	jsr $1a1dea	            JSR PHRETURN
.1a4213	a5 23		lda $0823	                LDA ARGUMENT1
.1a4215	20 ea 1d	jsr $1a1dea	            JSR PHRETURN
.1a4218	80 14		bra $1a422e	                BRA done
.1a421a					default_inc
.1a421a	c2 20		rep #$20	            REP #$20
.1a421c	a9 00 00	lda #$0000	                LDA #TYPE_INTEGER
.1a421f	20 ea 1d	jsr $1a1dea	            JSR PHRETURN
.1a4222	a9 00 00	lda #$0000	                LDA #0
.1a4225	20 ea 1d	jsr $1a1dea	            JSR PHRETURN
.1a4228	a9 01 00	lda #$0001	                LDA #1
.1a422b	20 ea 1d	jsr $1a1dea	            JSR PHRETURN
.1a422e	28		plp		done            PLP
.1a422f	60		rts		            RTS
.1a4230					syntax_err
.1a4230	08		php		            PHP
.1a4231	c2 20		rep #$20	            REP #$20
.1a4233	48		pha		            PHA
.1a4234	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4237	5b		tcd		            TCD
.1a4238	68		pla		            PLA
.1a4239	28		plp		            PLP
.1a423a	e2 20		sep #$20	            SEP #$20
.1a423c	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a423e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4242	c2 20		rep #$20	            REP #$20
.1a4244	29 ff 00	and #$00ff	            AND #$00FF
.1a4247	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a424a	e2 20		sep #$20	            SEP #$20
.1a424c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.0000					FOR_RECORD
>0000					INCREMENT       .dword  ?
>0004					INCTYPE         .word   ?
>0006					FINAL           .dword  ?
>000a					FINALTYPE       .word   ?
>000c					VARIBLE         .dword  ?
>0010					VARTYPE         .word   ?
>0012					BIP             .dword  ?
>0016					CURLINE         .dword  ?
.1a424f					S_NEXT
.1a424f	08		php		                PHP
.1a4250	8b		phb		                PHB
.1a4251	08		php		            PHP
.1a4252	e2 20		sep #$20	            SEP #$20
.1a4254	48		pha		            PHA
.1a4255	a9 00		lda #$00	            LDA #0
.1a4257	48		pha		            PHA
.1a4258	ab		plb		            PLB
.1a4259	68		pla		            PLA
.1a425a	28		plp		            PLP
.1a425b	08		php		            PHP
.1a425c	c2 20		rep #$20	            REP #$20
.1a425e	48		pha		            PHA
.1a425f	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a4262	5b		tcd		            TCD
.1a4263	68		pla		            PLA
.1a4264	28		plp		            PLP
.1a4265	c2 30		rep #$30	            REP #$30
.1a4267	a4 33		ldy $0833	                LDY RETURNSP                    ; Y := pointer to first byte of the FOR record
.1a4269	c8		iny		                INY                             ; RETURNSP points to the first free slot, so move up 2 bytes
.1a426a	c8		iny		                INY
.1a426b	c2 20		rep #$20	            REP #$20
.1a426d	b9 0c 00	lda $000c,y	                LDA #FOR_RECORD.VARIBLE,B,Y     ; TOFIND := FOR_RECORD.VARIABLE
.1a4270	85 e7		sta $08e7	                STA TOFIND
.1a4272	b9 0e 00	lda $000e,y	                LDA #FOR_RECORD.VARIBLE+2,B,Y
.1a4275	e2 20		sep #$20	            SEP #$20
.1a4277	85 e9		sta $08e9	                STA TOFIND+2
.1a4279	b9 10 00	lda $0010,y	                LDA #FOR_RECORD.VARTYPE,B,Y
.1a427c	85 ea		sta $08ea	                STA TOFINDTYPE
.1a427e	c2 20		rep #$20	            REP #$20
.1a4280	5a		phy		                PHY
.1a4281	20 e6 51	jsr $1a51e6	            JSR VAR_REF
.1a4284	7a		ply		                PLY
.1a4285	c2 20		rep #$20	            REP #$20
.1a4287	b9 00 00	lda $0000,y	                LDA #FOR_RECORD.INCREMENT,B,Y   ; ARGUMENT2 := FOR_RECORD.INCREMENT
.1a428a	85 29		sta $0829	                STA ARGUMENT2
.1a428c	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y
.1a428f	85 2b		sta $082b	                STA ARGUMENT2+2
.1a4291	e2 20		sep #$20	            SEP #$20
.1a4293	b9 04 00	lda $0004,y	                LDA #FOR_RECORD.INCTYPE,B,Y
.1a4296	85 2d		sta $082d	                STA ARGTYPE2
.1a4298	c2 20		rep #$20	            REP #$20
.1a429a	5a		phy		                PHY
.1a429b	20 a8 27	jsr $1a27a8	            JSR OP_PLUS
.1a429e	20 48 53	jsr $1a5348	            JSR VAR_SET
.1a42a1	7a		ply		                PLY
.1a42a2	c2 20		rep #$20	            REP #$20
.1a42a4	b9 06 00	lda $0006,y	                LDA #FOR_RECORD.FINAL,B,Y       ; ARGUMENT2 := FOR_RECORD.FINAL
.1a42a7	85 29		sta $0829	                STA ARGUMENT2
.1a42a9	b9 08 00	lda $0008,y	                LDA #FOR_RECORD.FINAL+2,B,Y
.1a42ac	85 2b		sta $082b	                STA ARGUMENT2+2
.1a42ae	e2 20		sep #$20	            SEP #$20
.1a42b0	b9 0a 00	lda $000a,y	                LDA #FOR_RECORD.FINALTYPE,B,Y
.1a42b3	85 2d		sta $082d	                STA ARGTYPE2
.1a42b5	c2 20		rep #$20	            REP #$20
.1a42b7	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y ; Check the increment's sign
.1a42ba	30 0a		bmi $1a42c6	                BMI going_down
.1a42bc					going_up
.1a42bc	20 31 2a	jsr $1a2a31	            JSR OP_LTE
.1a42bf	20 df 05	jsr $1a05df	            JSR IS_ARG1_Z
.1a42c2	f0 28		beq $1a42ec	                BEQ end_loop                    ; No: end the loop
.1a42c4	80 08		bra $1a42ce	                BRA loop_back                   ; Yes: loop back
.1a42c6					going_down
.1a42c6	20 f1 29	jsr $1a29f1	            JSR OP_GTE
.1a42c9	20 df 05	jsr $1a05df	            JSR IS_ARG1_Z
.1a42cc	f0 1e		beq $1a42ec	                BEQ end_loop                    ; No: end the loop
.1a42ce					loop_back
.1a42ce	c2 20		rep #$20	            REP #$20
.1a42d0	b9 12 00	lda $0012,y	                LDA #FOR_RECORD.BIP,B,Y
.1a42d3	85 00		sta $0800	                STA BIP
.1a42d5	b9 14 00	lda $0014,y	                LDA #FOR_RECORD.BIP+2,B,Y
.1a42d8	85 02		sta $0802	                STA BIP+2
.1a42da	b9 16 00	lda $0016,y	                LDA #FOR_RECORD.CURLINE,B,Y     ; CURLINE := FOR_RECORD.CURLINE
.1a42dd	85 1a		sta $081a	                STA CURLINE
.1a42df	b9 18 00	lda $0018,y	                LDA #FOR_RECORD.CURLINE+2,B,Y
.1a42e2	85 1c		sta $081c	                STA CURLINE+2
.1a42e4	e2 20		sep #$20	            SEP #$20
.1a42e6	a9 03		lda #$03	                LDA #EXEC_RETURN
.1a42e8	85 dc		sta $08dc	                STA EXECACTION
.1a42ea	80 17		bra $1a4303	                BRA done
.1a42ec					end_loop
.1a42ec	a2 23 08	ldx #$0823	                LDX #ARGUMENT1
.1a42ef	20 ae 19	jsr $1a19ae	            JSR PLARGUMENT
.1a42f2	c2 20		rep #$20	            REP #$20
.1a42f4	18		clc		                CLC
.1a42f5	a5 33		lda $0833	                LDA RETURNSP
.1a42f7	69 1a 00	adc #$001a	                ADC #size(FOR_RECORD)           ; Move pointer by number of bytes in a FOR record
.1a42fa	85 33		sta $0833	                STA RETURNSP
.1a42fc	a5 35		lda $0835	                LDA RETURNSP+2
.1a42fe	69 00 00	adc #$0000	                ADC #0
.1a4301	85 35		sta $0835	                STA RETURNSP+2
.1a4303	ab		plb		done            PLB
.1a4304	28		plp		                PLP
.1a4305	60		rts		            RTS
.1a4306					S_GOSUB
.1a4306	08		php		                PHP
.1a4307	a5 1a		lda $081a	                LDA CURLINE                 ; Save the current line for later
.1a4309	48		pha		                PHA
.1a430a	a5 1c		lda $081c	                LDA CURLINE+2
.1a430c	48		pha		                PHA
.1a430d	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a4310	20 9d 08	jsr $1a089d	            JSR PARSEINT
.1a4313	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.1a4315	f0 26		beq $1a433d	                BEQ syntax_err              ; If 0, no number was found... syntax error
.1a4317	20 e2 23	jsr $1a23e2	            JSR FINDLINE
.1a431a	90 42		bcc $1a435e	                BCC not_found               ; If not found... LINE NOT FOUND error
.1a431c	e2 20		sep #$20	            SEP #$20
.1a431e	a9 02		lda #$02	                LDA #EXEC_GOTO
.1a4320	85 dc		sta $08dc	                STA EXECACTION
.1a4322	20 27 21	jsr $1a2127	            JSR SKIPSTMT
.1a4325	c2 20		rep #$20	            REP #$20
.1a4327	68		pla		                PLA                         ; Save the old value of CURLINE to the RETURN stack
.1a4328	20 ea 1d	jsr $1a1dea	            JSR PHRETURN
.1a432b	68		pla		                PLA
.1a432c	20 ea 1d	jsr $1a1dea	            JSR PHRETURN
.1a432f	a5 02		lda $0802	                LDA BIP+2                   ; Save the BASIC Instruction Pointer to the RETURN stack
.1a4331	20 ea 1d	jsr $1a1dea	            JSR PHRETURN
.1a4334	a5 00		lda $0800	                LDA BIP
.1a4336	20 ea 1d	jsr $1a1dea	            JSR PHRETURN
.1a4339	e6 31		inc $0831	                INC GOSUBDEPTH              ; Increase the count of GOSUBs on the stack
.1a433b	28		plp		                PLP
.1a433c	60		rts		            RTS
.1a433d	68		pla		syntax_err      PLA
.1a433e	68		pla		                PLA
.1a433f	08		php		            PHP
.1a4340	c2 20		rep #$20	            REP #$20
.1a4342	48		pha		            PHA
.1a4343	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4346	5b		tcd		            TCD
.1a4347	68		pla		            PLA
.1a4348	28		plp		            PLP
.1a4349	e2 20		sep #$20	            SEP #$20
.1a434b	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a434d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4351	c2 20		rep #$20	            REP #$20
.1a4353	29 ff 00	and #$00ff	            AND #$00FF
.1a4356	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4359	e2 20		sep #$20	            SEP #$20
.1a435b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a435e	68		pla		not_found       PLA
.1a435f	68		pla		                PLA
.1a4360	08		php		            PHP
.1a4361	c2 20		rep #$20	            REP #$20
.1a4363	48		pha		            PHA
.1a4364	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4367	5b		tcd		            TCD
.1a4368	68		pla		            PLA
.1a4369	28		plp		            PLP
.1a436a	e2 20		sep #$20	            SEP #$20
.1a436c	a9 06		lda #$06	            LDA #ERR_NOLINE
.1a436e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4372	c2 20		rep #$20	            REP #$20
.1a4374	29 ff 00	and #$00ff	            AND #$00FF
.1a4377	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a437a	e2 20		sep #$20	            SEP #$20
.1a437c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a437f					S_RETURN
.1a437f	08		php		                PHP
.1a4380	c2 30		rep #$30	            REP #$30
.1a4382	a5 31		lda $0831	                LDA GOSUBDEPTH              ; Check that there is at least on GOSUB on the stack
.1a4384	f0 1e		beq $1a43a4	                BEQ underflow               ; No? It's a stack underflow error
.1a4386	20 0c 1e	jsr $1a1e0c	            JSR PLRETURN
.1a4389	85 00		sta $0800	                STA BIP
.1a438b	20 0c 1e	jsr $1a1e0c	            JSR PLRETURN
.1a438e	85 02		sta $0802	                STA BIP+2
.1a4390	20 0c 1e	jsr $1a1e0c	            JSR PLRETURN
.1a4393	85 1a		sta $081a	                STA CURLINE
.1a4395	20 0c 1e	jsr $1a1e0c	            JSR PLRETURN
.1a4398	85 1c		sta $081c	                STA CURLINE+2
.1a439a	c6 31		dec $0831	                DEC GOSUBDEPTH              ; Indicate we've popped that GOSUB off the stack
.1a439c	e2 20		sep #$20	            SEP #$20
.1a439e	a9 03		lda #$03	                LDA #EXEC_RETURN
.1a43a0	85 dc		sta $08dc	                STA EXECACTION
.1a43a2	28		plp		                PLP
.1a43a3	60		rts		            RTS
.1a43a4					underflow
.1a43a4	08		php		            PHP
.1a43a5	c2 20		rep #$20	            REP #$20
.1a43a7	48		pha		            PHA
.1a43a8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a43ab	5b		tcd		            TCD
.1a43ac	68		pla		            PLA
.1a43ad	28		plp		            PLP
.1a43ae	e2 20		sep #$20	            SEP #$20
.1a43b0	a9 07		lda #$07	            LDA #ERR_STACKUNDER
.1a43b2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a43b6	c2 20		rep #$20	            REP #$20
.1a43b8	29 ff 00	and #$00ff	            AND #$00FF
.1a43bb	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a43be	e2 20		sep #$20	            SEP #$20
.1a43c0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a43c3					S_IF
.1a43c3	08		php		                PHP
.1a43c4	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a43c7	20 df 05	jsr $1a05df	            JSR IS_ARG1_Z
.1a43ca	f0 1c		beq $1a43e8	                BEQ is_false                ; If so, handle the FALSE case
.1a43cc	e2 20		sep #$20	            SEP #$20
.1a43ce	a9 97		lda #$97	                LDA #TOK_THEN               ; Verify that the next token is THEN and eat it
.1a43d0	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a43d3	20 9d 08	jsr $1a089d	            JSR PARSEINT
.1a43d6	20 df 05	jsr $1a05df	            JSR IS_ARG1_Z
.1a43d9	f0 12		beq $1a43ed	                BEQ syntax_err              ; If not, we have a syntax error
.1a43db	20 e2 23	jsr $1a23e2	            JSR FINDLINE
.1a43de	90 2c		bcc $1a440c	                BCC not_found               ; If not found... LINE NOT FOUND error
.1a43e0	e2 20		sep #$20	            SEP #$20
.1a43e2	a9 02		lda #$02	                LDA #EXEC_GOTO
.1a43e4	85 dc		sta $08dc	                STA EXECACTION
.1a43e6	80 03		bra $1a43eb	                BRA done
.1a43e8					is_false
.1a43e8	20 27 21	jsr $1a2127	            JSR SKIPSTMT
.1a43eb	28		plp		done            PLP
.1a43ec	60		rts		            RTS
.1a43ed					syntax_err
.1a43ed	08		php		            PHP
.1a43ee	c2 20		rep #$20	            REP #$20
.1a43f0	48		pha		            PHA
.1a43f1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a43f4	5b		tcd		            TCD
.1a43f5	68		pla		            PLA
.1a43f6	28		plp		            PLP
.1a43f7	e2 20		sep #$20	            SEP #$20
.1a43f9	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a43fb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a43ff	c2 20		rep #$20	            REP #$20
.1a4401	29 ff 00	and #$00ff	            AND #$00FF
.1a4404	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4407	e2 20		sep #$20	            SEP #$20
.1a4409	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a440c					not_found
.1a440c	08		php		            PHP
.1a440d	c2 20		rep #$20	            REP #$20
.1a440f	48		pha		            PHA
.1a4410	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4413	5b		tcd		            TCD
.1a4414	68		pla		            PLA
.1a4415	28		plp		            PLP
.1a4416	e2 20		sep #$20	            SEP #$20
.1a4418	a9 06		lda #$06	            LDA #ERR_NOLINE
.1a441a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a441e	c2 20		rep #$20	            REP #$20
.1a4420	29 ff 00	and #$00ff	            AND #$00FF
.1a4423	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4426	e2 20		sep #$20	            SEP #$20
.1a4428	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a442b					S_END
.1a442b	08		php		                PHP
.1a442c	e2 20		sep #$20	            SEP #$20
.1a442e	a9 01		lda #$01	                LDA #EXEC_STOP
.1a4430	85 dc		sta $08dc	                STA EXECACTION
.1a4432	28		plp		                PLP
.1a4433	60		rts		            RTS
.1a4434					S_GOTO
.1a4434	08		php		                PHP
.1a4435	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a4438	20 9d 08	jsr $1a089d	            JSR PARSEINT
.1a443b	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.1a443d	f0 0d		beq $1a444c	                BEQ syntax_err              ; If 0, no number was found... syntax error
.1a443f	20 e2 23	jsr $1a23e2	            JSR FINDLINE
.1a4442	90 27		bcc $1a446b	                BCC not_found               ; If not found... LINE NOT FOUND error
.1a4444	e2 20		sep #$20	            SEP #$20
.1a4446	a9 02		lda #$02	                LDA #EXEC_GOTO
.1a4448	85 dc		sta $08dc	                STA EXECACTION
.1a444a	28		plp		                PLP
.1a444b	60		rts		            RTS
.1a444c					syntax_err
.1a444c	08		php		            PHP
.1a444d	c2 20		rep #$20	            REP #$20
.1a444f	48		pha		            PHA
.1a4450	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4453	5b		tcd		            TCD
.1a4454	68		pla		            PLA
.1a4455	28		plp		            PLP
.1a4456	e2 20		sep #$20	            SEP #$20
.1a4458	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a445a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a445e	c2 20		rep #$20	            REP #$20
.1a4460	29 ff 00	and #$00ff	            AND #$00FF
.1a4463	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4466	e2 20		sep #$20	            SEP #$20
.1a4468	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a446b					not_found
.1a446b	08		php		            PHP
.1a446c	c2 20		rep #$20	            REP #$20
.1a446e	48		pha		            PHA
.1a446f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4472	5b		tcd		            TCD
.1a4473	68		pla		            PLA
.1a4474	28		plp		            PLP
.1a4475	e2 20		sep #$20	            SEP #$20
.1a4477	a9 06		lda #$06	            LDA #ERR_NOLINE
.1a4479	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a447d	c2 20		rep #$20	            REP #$20
.1a447f	29 ff 00	and #$00ff	            AND #$00FF
.1a4482	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4485	e2 20		sep #$20	            SEP #$20
.1a4487	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a448a					S_CLR
.1a448a	20 50 19	jsr $1a1950	            JSR INITEVALSP
.1a448d	20 70 10	jsr $1a1070	            JSR INITHEAP
.1a4490	20 e5 50	jsr $1a50e5	            JSR INITVARS
.1a4493	60		rts		            RTS
.1a4494					S_LET
.1a4494	08		php		                PHP
.1a4495	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.1a4497	10 03		bpl $1a449c	                BPL get_name        ; If it's not a token, try to find the variable name
.1a4499	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a449c					get_name
.1a449c	20 e5 53	jsr $1a53e5	            JSR VAR_FINDNAME
.1a449f	b0 03		bcs $1a44a4	                BCS check_array     ; If we didn't find a name, thrown an error
.1a44a1	4c 0b 45	jmp $1a450b	                JMP syntax_err
.1a44a4					check_array
.1a44a4	e2 20		sep #$20	            SEP #$20
.1a44a6	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Save the variable name for later
.1a44a8	48		pha		                PHA                 ; (it will get over-written by variable references)
.1a44a9	a5 e9		lda $08e9	                LDA TOFIND+2
.1a44ab	48		pha		                PHA
.1a44ac	a5 e8		lda $08e8	                LDA TOFIND+1
.1a44ae	48		pha		                PHA
.1a44af	a5 e7		lda $08e7	                LDA TOFIND
.1a44b1	48		pha		                PHA
.1a44b2	20 43 22	jsr $1a2243	            JSR PEEK_TOK
.1a44b5	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it a "("
.1a44b7	d0 0e		bne $1a44c7	                BNE get_value       ; No: it's a scalar assignment, look for the "="
.1a44b9	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a44bb	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a44be	a9 00		lda #$00	                LDA #0
.1a44c0	8f 00 4d 00	sta $004d00	                STA @l ARRIDXBUF    ; Blank out the array index buffer
.1a44c4	20 d2 1a	jsr $1a1ad2	            JSR ARR_GETIDX
.1a44c7					get_value
.1a44c7	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a44ca	e2 20		sep #$20	            SEP #$20
.1a44cc	a7 00		lda [$0800]	                LDA [BIP]
.1a44ce	c9 8a		cmp #$8a	                CMP #TOK_EQ
.1a44d0	f0 03		beq $1a44d5	                BEQ found_eq        ; If not found: signal an syntax error
.1a44d2	4c 0b 45	jmp $1a450b	                JMP syntax_err
.1a44d5					found_eq
.1a44d5	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a44d8	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a44db	68		pla		                PLA                 ; Restore the variable name
.1a44dc	85 e7		sta $08e7	                STA TOFIND
.1a44de	68		pla		                PLA
.1a44df	85 e8		sta $08e8	                STA TOFIND+1
.1a44e1	68		pla		                PLA
.1a44e2	85 e9		sta $08e9	                STA TOFIND+2
.1a44e4	68		pla		                PLA
.1a44e5	85 ea		sta $08ea	                STA TOFINDTYPE
.1a44e7	29 80		and #$80	                AND #$80            ; Is it an array we're setting?
.1a44e9	f0 1b		beq $1a4506	                BEQ set_scalar      ; No: do a scalar variable set
.1a44eb	20 58 51	jsr $1a5158	            JSR VAR_FIND
.1a44ee	90 3a		bcc $1a452a	                BCC notfound_err
.1a44f0	c2 20		rep #$20	            REP #$20
.1a44f2	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.1a44f5	b7 08		lda [$0808],y	                LDA [INDEX],Y       ; Save the pointer to the array to CURRBLOCK
.1a44f7	85 c0		sta $08c0	                STA CURRBLOCK
.1a44f9	e2 20		sep #$20	            SEP #$20
.1a44fb	c8		iny		                INY
.1a44fc	c8		iny		                INY
.1a44fd	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a44ff	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a4501	20 4f 68	jsr $1a684f	            JSR ARR_SET
.1a4504	80 03		bra $1a4509	                BRA done            ; and we're finished!
.1a4506					set_scalar
.1a4506	20 48 53	jsr $1a5348	            JSR VAR_SET
.1a4509					done
.1a4509	28		plp		                PLP
.1a450a	60		rts		            RTS
.1a450b					syntax_err
.1a450b	08		php		            PHP
.1a450c	c2 20		rep #$20	            REP #$20
.1a450e	48		pha		            PHA
.1a450f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4512	5b		tcd		            TCD
.1a4513	68		pla		            PLA
.1a4514	28		plp		            PLP
.1a4515	e2 20		sep #$20	            SEP #$20
.1a4517	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4519	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a451d	c2 20		rep #$20	            REP #$20
.1a451f	29 ff 00	and #$00ff	            AND #$00FF
.1a4522	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4525	e2 20		sep #$20	            SEP #$20
.1a4527	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a452a					notfound_err
.1a452a	08		php		            PHP
.1a452b	c2 20		rep #$20	            REP #$20
.1a452d	48		pha		            PHA
.1a452e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4531	5b		tcd		            TCD
.1a4532	68		pla		            PLA
.1a4533	28		plp		            PLP
.1a4534	e2 20		sep #$20	            SEP #$20
.1a4536	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a4538	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a453c	c2 20		rep #$20	            REP #$20
.1a453e	29 ff 00	and #$00ff	            AND #$00FF
.1a4541	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4544	e2 20		sep #$20	            SEP #$20
.1a4546	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4549					S_PRINT
.1a4549	08		php		                PHP
.1a454a	e2 20		sep #$20	            SEP #$20
.1a454c	20 43 22	jsr $1a2243	            JSR PEEK_TOK
.1a454f	c9 00		cmp #$00	                CMP #0              ; Is it EOL or :?
.1a4551	f0 6d		beq $1a45c0	                BEQ pr_nl_exit      ; Yes: just print return
.1a4553					pr_loop
.1a4553	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4556	e2 20		sep #$20	            SEP #$20
.1a4558	a5 27		lda $0827	                LDA ARGTYPE1        ; Get the type of the result
.1a455a	c9 ff		cmp #$ff	                CMP #TYPE_NAV       ; Is is NAV?
.1a455c	f0 1b		beq $1a4579	                BEQ check_nl        ; Yes: we are probably just printing a newline
.1a455e	c9 02		cmp #$02	                CMP #TYPE_STRING    ; Is it a string?
.1a4560	d0 05		bne $1a4567	                BNE check_int       ; No: check to see if it's an integer
.1a4562	20 c5 45	jsr $1a45c5	            JSR PR_STRING
.1a4565	80 12		bra $1a4579	                BRA check_nl
.1a4567	c9 00		cmp #$00	check_int       CMP #TYPE_INTEGER   ; Is it an integer?
.1a4569	d0 05		bne $1a4570	                BNE check_float     ; No: check to see if it is a float
.1a456b	20 e3 45	jsr $1a45e3	            JSR PR_INTEGER
.1a456e	80 09		bra $1a4579	                BRA check_nl
.1a4570	c9 01		cmp #$01	check_float     CMP #TYPE_FLOAT     ; Is it a float?
.1a4572	d0 4f		bne $1a45c3	                BNE done            ; No: just quit
.1a4574	20 f6 45	jsr $1a45f6	            JSR PR_FLOAT
.1a4577	80 00		bra $1a4579	                BRA check_nl
.1a4579					check_nl
.1a4579	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a457c	a7 00		lda [$0800]	                LDA [BIP]
.1a457e	f0 40		beq $1a45c0	                BEQ pr_nl_exit      ; If it's nul, print a newline and return
.1a4580	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.1a4582	f0 3c		beq $1a45c0	                BEQ pr_nl_exit      ; print a newline and return
.1a4584	c9 2c		cmp #$2c	                CMP #','            ; If it's a comma
.1a4586	f0 23		beq $1a45ab	                BEQ pr_comma        ; Print a TAB and try another expression
.1a4588	c9 3b		cmp #$3b	                CMP #';'            ; If it's a semicolon...
.1a458a	f0 24		beq $1a45b0	                BEQ is_more         ; Print nothing, and try another expression
.1a458c	08		php		            PHP
.1a458d	c2 20		rep #$20	            REP #$20
.1a458f	48		pha		            PHA
.1a4590	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4593	5b		tcd		            TCD
.1a4594	68		pla		            PLA
.1a4595	28		plp		            PLP
.1a4596	e2 20		sep #$20	            SEP #$20
.1a4598	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a459a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a459e	c2 20		rep #$20	            REP #$20
.1a45a0	29 ff 00	and #$00ff	            AND #$00FF
.1a45a3	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a45a6	e2 20		sep #$20	            SEP #$20
.1a45a8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a45ab	a9 09		lda #$09	pr_comma        LDA #CHAR_TAB       ; Print a TAB
.1a45ad	20 18 00	jsr $1a0018	            JSR PRINTC
.1a45b0					is_more
.1a45b0	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a45b3	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a45b6	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.1a45b8	f0 09		beq $1a45c3	                BEQ done            ; If it's NULL, return without printing a newline
.1a45ba	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.1a45bc	f0 05		beq $1a45c3	                BEQ done            ; ... return without printing a newline
.1a45be	80 93		bra $1a4553	                BRA pr_loop         ; Otherwise, we should have another expression, try to handle it
.1a45c0					pr_nl_exit
.1a45c0	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a45c3	28		plp		done            PLP
.1a45c4	60		rts		            RTS
.1a45c5					PR_STRING
.1a45c5	08		php		                PHP
.1a45c6	8b		phb		                PHB
.1a45c7	08		php		            PHP
.1a45c8	c2 20		rep #$20	            REP #$20
.1a45ca	48		pha		            PHA
.1a45cb	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a45ce	5b		tcd		            TCD
.1a45cf	68		pla		            PLA
.1a45d0	28		plp		            PLP
.1a45d1	e2 20		sep #$20	            SEP #$20
.1a45d3	a0 00 00	ldy #$0000	start_print     LDY #0
.1a45d6	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y
.1a45d8	f0 06		beq $1a45e0	                BEQ done
.1a45da	20 18 00	jsr $1a0018	            JSR PRINTC
.1a45dd	c8		iny		                INY
.1a45de	80 f6		bra $1a45d6	                BRA loop
.1a45e0	ab		plb		done            PLB
.1a45e1	28		plp		                PLP
.1a45e2	60		rts		            RTS
.1a45e3					PR_INTEGER
.1a45e3	08		php		                PHP
.1a45e4	c2 20		rep #$20	            REP #$20
.1a45e6	20 25 15	jsr $1a1525	            JSR ITOS
.1a45e9	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.1a45eb	85 23		sta $0823	                STA ARGUMENT1
.1a45ed	a5 18		lda $0818	                LDA STRPTR+2
.1a45ef	85 25		sta $0825	                STA ARGUMENT1+2
.1a45f1	20 c5 45	jsr $1a45c5	            JSR PR_STRING
.1a45f4	28		plp		                PLP
.1a45f5	60		rts		            RTS
.1a45f6					PR_FLOAT
.1a45f6	08		php		                PHP
.1a45f7	20 ae 5d	jsr $1a5dae	            JSR FTOS
.1a45fa	c2 20		rep #$20	            REP #$20
.1a45fc	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.1a45fe	85 23		sta $0823	                STA ARGUMENT1
.1a4600	a5 18		lda $0818	                LDA STRPTR+2
.1a4602	85 25		sta $0825	                STA ARGUMENT1+2
.1a4604	20 c5 45	jsr $1a45c5	            JSR PR_STRING
.1a4607	28		plp		                PLP
.1a4608	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\functions.s


;******  Processing file: src\C256/functions_c256.s

.1a4609					BCD2STR
.1a4609	08		php		            PHP
.1a460a	e2 20		sep #$20	            SEP #$20
.1a460c	85 b5		sta $08b5	            STA SAVE_A
.1a460e	4a		lsr a		            LSR A
.1a460f	4a		lsr a		            LSR A
.1a4610	4a		lsr a		            LSR A
.1a4611	4a		lsr a		            LSR A
.1a4612	29 0f		and #$0f	            AND #$0F
.1a4614	18		clc		            CLC
.1a4615	69 30		adc #$30	            ADC #'0'
.1a4617	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a4619	c8		iny		            INY
.1a461a	a5 b5		lda $08b5	            LDA SAVE_A
.1a461c	29 0f		and #$0f	            AND #$0F
.1a461e	18		clc		            CLC
.1a461f	69 30		adc #$30	            ADC #'0'
.1a4621	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a4623	c8		iny		            INY
.1a4624	28		plp		            PLP
.1a4625	60		rts		            RTS
.1a4626					F_GETDATE
.1a4626	e2 20		sep #$20	            SEP #$20
.1a4628	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a462a	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a462d	08		php		            PHP
.1a462e	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4631	e2 20		sep #$20	            SEP #$20
.1a4633	c2 10		rep #$10	            REP #$10
.1a4635	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a4639	09 08		ora #$08	            ORA #%00001000
.1a463b	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a463f	20 c6 14	jsr $1a14c6	            JSR TEMPSTRING
.1a4642	a0 00 00	ldy #$0000	            LDY #0
.1a4645	af 06 08 af	lda $af0806	            LDA @lRTC_DAY           ; Write the day of the month
.1a4649	20 09 46	jsr $1a4609	            JSR BCD2STR
.1a464c	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.1a464e	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a4650	c8		iny		            INY
.1a4651	af 09 08 af	lda $af0809	            LDA @lRTC_MONTH         ; Write the month
.1a4655	20 09 46	jsr $1a4609	            JSR BCD2STR
.1a4658	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.1a465a	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a465c	c8		iny		            INY
.1a465d	af 0f 08 af	lda $af080f	            LDA @lRTC_CENTURY       ; Write the year
.1a4661	20 09 46	jsr $1a4609	            JSR BCD2STR
.1a4664	af 0a 08 af	lda $af080a	            LDA @lRTC_YEAR          ; Write the year
.1a4668	20 09 46	jsr $1a4609	            JSR BCD2STR
.1a466b	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.1a466d	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a466f	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a4673	29 f7		and #$f7	            AND #%11110111
.1a4675	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a4679	c2 20		rep #$20	            REP #$20
.1a467b	a5 16		lda $0816	            LDA STRPTR
.1a467d	85 23		sta $0823	            STA ARGUMENT1
.1a467f	a5 18		lda $0818	            LDA STRPTR+2
.1a4681	85 25		sta $0825	            STA ARGUMENT1+2
.1a4683	e2 20		sep #$20	            SEP #$20
.1a4685	a9 02		lda #$02	            LDA #TYPE_STRING
.1a4687	85 27		sta $0827	            STA ARGTYPE1
.1a4689	28		plp		            PLP
.1a468a	e2 20		sep #$20	            SEP #$20
.1a468c	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a468f	60		rts		            RTS
.1a4690					F_GETTIME
.1a4690	e2 20		sep #$20	            SEP #$20
.1a4692	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4694	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4697	08		php		            PHP
.1a4698	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a469b	e2 20		sep #$20	            SEP #$20
.1a469d	c2 10		rep #$10	            REP #$10
.1a469f	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a46a3	09 08		ora #$08	            ORA #%00001000
.1a46a5	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a46a9	20 c6 14	jsr $1a14c6	            JSR TEMPSTRING
.1a46ac	a0 00 00	ldy #$0000	            LDY #0
.1a46af	af 04 08 af	lda $af0804	            LDA @lRTC_HRS           ; Write the hour
.1a46b3	29 7f		and #$7f	            AND #$7F                ; Trim out the AM/PM indicator
.1a46b5	20 09 46	jsr $1a4609	            JSR BCD2STR
.1a46b8	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.1a46ba	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a46bc	c8		iny		            INY
.1a46bd	af 02 08 af	lda $af0802	            LDA @lRTC_MIN           ; Write the minute
.1a46c1	20 09 46	jsr $1a4609	            JSR BCD2STR
.1a46c4	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.1a46c6	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a46c8	c8		iny		            INY
.1a46c9	af 00 08 af	lda $af0800	            LDA @lRTC_SEC           ; Write the second
.1a46cd	20 09 46	jsr $1a4609	            JSR BCD2STR
.1a46d0	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.1a46d2	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a46d4	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a46d8	29 f7		and #$f7	            AND #%11110111
.1a46da	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a46de	c2 20		rep #$20	            REP #$20
.1a46e0	a5 16		lda $0816	            LDA STRPTR
.1a46e2	85 23		sta $0823	            STA ARGUMENT1
.1a46e4	a5 18		lda $0818	            LDA STRPTR+2
.1a46e6	85 25		sta $0825	            STA ARGUMENT1+2
.1a46e8	e2 20		sep #$20	            SEP #$20
.1a46ea	a9 02		lda #$02	            LDA #TYPE_STRING
.1a46ec	85 27		sta $0827	            STA ARGTYPE1
.1a46ee	28		plp		            PLP
.1a46ef	e2 20		sep #$20	            SEP #$20
.1a46f1	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a46f4	60		rts		            RTS
.1a46f5					FN_RND
.1a46f5	e2 20		sep #$20	            SEP #$20
.1a46f7	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a46f9	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a46fc	08		php		            PHP
.1a46fd	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4700	e2 20		sep #$20	            SEP #$20
.1a4702	a9 01		lda #$01	            LDA #TYPE_FLOAT             ; We'll return a floating point number
.1a4704	85 27		sta $0827	            STA ARGTYPE1
.1a4706	a9 03		lda #$03	            LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.1a4708	8f 00 e2 af	sta $afe200	            STA @l FP_MATH_CTRL0        ; Expect fixed point numbers
.1a470c	a9 01		lda #$01	            LDA #FP_OUT_DIV             ; Set us to do a division
.1a470e	8f 01 e2 af	sta $afe201	            STA @l FP_MATH_CTRL1
.1a4712	c2 30		rep #$30	            REP #$30
.1a4714	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get a random 16-bits
.1a4718	8f 08 e2 af	sta $afe208	            STA @l FP_MATH_INPUT0_LL    ; Send them to the FP unit
.1a471c	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get another random 16-bits
.1a4720	29 ff 7f	and #$7fff	            AND #$7FFF                  ; Make sure it's positive
.1a4723	8f 0a e2 af	sta $afe20a	            STA @l FP_MATH_INPUT0_LL+2  ; Send them to the FP unit
.1a4727	a9 ff ff	lda #$ffff	            LDA #$FFFF                  ; Get the maximum value
.1a472a	8f 0c e2 af	sta $afe20c	            STA @l FP_MATH_INPUT1_LL    ; Send it to the FP unit
.1a472e	a9 ff 7f	lda #$7fff	            LDA #$7FFF
.1a4731	8f 0e e2 af	sta $afe20e	            STA @l FP_MATH_INPUT1_LL+2
.1a4735	ea		nop		            NOP
.1a4736	ea		nop		            NOP
.1a4737	ea		nop		            NOP
.1a4738	af 08 e2 af	lda $afe208	            LDA @l FP_MATH_OUTPUT_FP_LL     ; Get the normalized result
.1a473c	85 23		sta $0823	            STA ARGUMENT1
.1a473e	af 0a e2 af	lda $afe20a	            LDA @l FP_MATH_OUTPUT_FP_LL+2
.1a4742	85 25		sta $0825	            STA ARGUMENT1+2
.1a4744	28		plp		            PLP
.1a4745	e2 20		sep #$20	            SEP #$20
.1a4747	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a474a	60		rts		            RTS
.1a474b					FN_INKEY
.1a474b	e2 20		sep #$20	            SEP #$20
.1a474d	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a474f	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4752	08		php		            PHP
.1a4753	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4756	22 28 10 00	jsl $001028	            JSL FK_GETSCANCODE          ; Get the scan code
.1a475a	e2 20		sep #$20	            SEP #$20
.1a475c	85 23		sta $0823	            STA ARGUMENT1
.1a475e	64 24		stz $0824	            STZ ARGUMENT1+1
.1a4760	64 25		stz $0825	            STZ ARGUMENT1+2
.1a4762	64 26		stz $0826	            STZ ARGUMENT1+3
.1a4764	a9 00		lda #$00	            LDA #TYPE_INTEGER           ; We'll return an integer number
.1a4766	85 27		sta $0827	            STA ARGTYPE1
.1a4768	28		plp		            PLP
.1a4769	e2 20		sep #$20	            SEP #$20
.1a476b	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a476e	60		rts		            RTS

;******  Return to file: src\functions.s

.1a476f					FN_MID
.1a476f	e2 20		sep #$20	            SEP #$20
.1a4771	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4773	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4776	08		php		                PHP
.1a4777	c2 30		rep #$30	            REP #$30
.1a4779	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a477c	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a477f					save_string
.1a477f	c2 20		rep #$20	            REP #$20
.1a4781	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.1a4783	48		pha		                PHA
.1a4784	a5 23		lda $0823	                LDA ARGUMENT1
.1a4786	48		pha		                PHA
.1a4787	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a478a	e2 20		sep #$20	            SEP #$20
.1a478c	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a478e	c9 2c		cmp #$2c	                CMP #','
.1a4790	f0 03		beq $1a4795	                BEQ skip_comma1
.1a4792	4c e6 47	jmp $1a47e6	                JMP syntax_err
.1a4795					skip_comma1
.1a4795	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4798	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a479b	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a479e	c2 20		rep #$20	            REP #$20
.1a47a0	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the index
.1a47a2	48		pha		                PHA
.1a47a3	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a47a6	e2 20		sep #$20	            SEP #$20
.1a47a8	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a47aa	c9 2c		cmp #$2c	                CMP #','
.1a47ac	f0 03		beq $1a47b1	                BEQ skip_comma2
.1a47ae	4c e6 47	jmp $1a47e6	                JMP syntax_err
.1a47b1					skip_comma2
.1a47b1	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a47b4	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a47b7	20 d2 06	jsr $1a06d2	            JSR ASS_ARG1_INT16
.1a47ba	c2 20		rep #$20	            REP #$20
.1a47bc	a5 23		lda $0823	            LDA ARGUMENT1
.1a47be	85 8f		sta $088f	            STA MCOUNT
.1a47c0	e2 20		sep #$20	            SEP #$20
.1a47c2	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a47c4	85 91		sta $0891	            STA MCOUNT+2
.1a47c6	c2 20		rep #$20	            REP #$20
.1a47c8	68		pla		                PLA                         ; Restore index
.1a47c9	85 29		sta $0829	                STA ARGUMENT2               ; ... to ARGUMENT2
.1a47cb	a9 00 00	lda #$0000	                LDA #0
.1a47ce	85 2b		sta $082b	                STA ARGUMENT2+2
.1a47d0	68		pla		                PLA                         ; Restore string
.1a47d1	85 23		sta $0823	                STA ARGUMENT1               ; ... to ARGUMENT1
.1a47d3	68		pla		                PLA
.1a47d4	85 25		sta $0825	                STA ARGUMENT1+2
.1a47d6	e2 20		sep #$20	            SEP #$20
.1a47d8	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a47da	85 27		sta $0827	            STA ARGTYPE1
.1a47dc	20 1e 17	jsr $1a171e	            JSR STRSUBSTR
.1a47df					done
.1a47df	e2 20		sep #$20	            SEP #$20
.1a47e1	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a47e4	28		plp		                PLP
.1a47e5	60		rts		            RTS
.1a47e6					syntax_err
.1a47e6	08		php		            PHP
.1a47e7	c2 20		rep #$20	            REP #$20
.1a47e9	48		pha		            PHA
.1a47ea	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a47ed	5b		tcd		            TCD
.1a47ee	68		pla		            PLA
.1a47ef	28		plp		            PLP
.1a47f0	e2 20		sep #$20	            SEP #$20
.1a47f2	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a47f4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a47f8	c2 20		rep #$20	            REP #$20
.1a47fa	29 ff 00	and #$00ff	            AND #$00FF
.1a47fd	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4800	e2 20		sep #$20	            SEP #$20
.1a4802	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4805					range_err
.1a4805	08		php		            PHP
.1a4806	c2 20		rep #$20	            REP #$20
.1a4808	48		pha		            PHA
.1a4809	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a480c	5b		tcd		            TCD
.1a480d	68		pla		            PLA
.1a480e	28		plp		            PLP
.1a480f	e2 20		sep #$20	            SEP #$20
.1a4811	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4813	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4817	c2 20		rep #$20	            REP #$20
.1a4819	29 ff 00	and #$00ff	            AND #$00FF
.1a481c	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a481f	e2 20		sep #$20	            SEP #$20
.1a4821	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4824					FN_RIGHT
.1a4824	e2 20		sep #$20	            SEP #$20
.1a4826	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4828	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a482b	08		php		                PHP
.1a482c	c2 30		rep #$30	            REP #$30
.1a482e	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4831	e2 20		sep #$20	            SEP #$20
.1a4833	a5 27		lda $0827	                LDA ARGTYPE1
.1a4835	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4837	f0 03		beq $1a483c	                BEQ save_string
.1a4839	4c a8 48	jmp $1a48a8	                JMP type_mismatch           ; Type mismatch if it's not a string
.1a483c					save_string
.1a483c	c2 20		rep #$20	            REP #$20
.1a483e	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.1a4840	48		pha		                PHA
.1a4841	a5 23		lda $0823	                LDA ARGUMENT1
.1a4843	48		pha		                PHA
.1a4844	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a4847	e2 20		sep #$20	            SEP #$20
.1a4849	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a484b	c9 2c		cmp #$2c	                CMP #','
.1a484d	f0 03		beq $1a4852	                BEQ skip_comma
.1a484f	4c c7 48	jmp $1a48c7	                JMP syntax_err
.1a4852					skip_comma
.1a4852	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4855	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4858	e2 20		sep #$20	            SEP #$20
.1a485a	a5 27		lda $0827	                LDA ARGTYPE1
.1a485c	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a485e	d0 48		bne $1a48a8	                BNE type_mismatch           ; Type mismatch if it's not an integer
.1a4860	c2 20		rep #$20	            REP #$20
.1a4862	a5 23		lda $0823	            LDA ARGUMENT1
.1a4864	85 8f		sta $088f	            STA MCOUNT
.1a4866	c2 20		rep #$20	            REP #$20
.1a4868	68		pla		                PLA                         ; Recover the string pointer
.1a4869	85 23		sta $0823	                STA ARGUMENT1
.1a486b	68		pla		                PLA
.1a486c	85 25		sta $0825	                STA ARGUMENT1+2
.1a486e	e2 20		sep #$20	            SEP #$20
.1a4870	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a4872	85 27		sta $0827	            STA ARGTYPE1
.1a4874	e2 20		sep #$20	            SEP #$20
.1a4876	a0 00 00	ldy #$0000	                LDY #0
.1a4879	b7 23		lda [$0823],y	count_loop      LDA [ARGUMENT1],Y
.1a487b	f0 03		beq $1a4880	                BEQ count_done
.1a487d	c8		iny		                INY
.1a487e	80 f9		bra $1a4879	                BRA count_loop
.1a4880					count_done
.1a4880	c2 20		rep #$20	            REP #$20
.1a4882	98		tya		                TYA                         ; ARGUMENT2 := LENGTH - MCOUNT
.1a4883	38		sec		                SEC
.1a4884	e5 8f		sbc $088f	                SBC MCOUNT
.1a4886	30 09		bmi $1a4891	                BMI index0                  ; if ARGUMENT2 < 0, set ARGUMENT2 := 0
.1a4888	85 29		sta $0829	                STA ARGUMENT2
.1a488a	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT2[23..16] := 0
.1a488d	85 2b		sta $082b	                STA ARGUMENT2+2
.1a488f	80 07		bra $1a4898	                BRA slice
.1a4891	a9 00 00	lda #$0000	index0          LDA #0                      ; 0 is the floor for the index
.1a4894	85 29		sta $0829	                STA ARGUMENT2
.1a4896	85 2b		sta $082b	                STA ARGUMENT2+2
.1a4898					slice
.1a4898	e2 20		sep #$20	            SEP #$20
.1a489a	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a489c	85 2d		sta $082d	            STA ARGTYPE2
.1a489e	20 1e 17	jsr $1a171e	            JSR STRSUBSTR
.1a48a1					done
.1a48a1	e2 20		sep #$20	            SEP #$20
.1a48a3	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a48a6	28		plp		                PLP
.1a48a7	60		rts		            RTS
.1a48a8					type_mismatch
.1a48a8	08		php		            PHP
.1a48a9	c2 20		rep #$20	            REP #$20
.1a48ab	48		pha		            PHA
.1a48ac	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a48af	5b		tcd		            TCD
.1a48b0	68		pla		            PLA
.1a48b1	28		plp		            PLP
.1a48b2	e2 20		sep #$20	            SEP #$20
.1a48b4	a9 04		lda #$04	            LDA #ERR_TYPE
.1a48b6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a48ba	c2 20		rep #$20	            REP #$20
.1a48bc	29 ff 00	and #$00ff	            AND #$00FF
.1a48bf	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a48c2	e2 20		sep #$20	            SEP #$20
.1a48c4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a48c7					syntax_err
.1a48c7	08		php		            PHP
.1a48c8	c2 20		rep #$20	            REP #$20
.1a48ca	48		pha		            PHA
.1a48cb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a48ce	5b		tcd		            TCD
.1a48cf	68		pla		            PLA
.1a48d0	28		plp		            PLP
.1a48d1	e2 20		sep #$20	            SEP #$20
.1a48d3	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a48d5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a48d9	c2 20		rep #$20	            REP #$20
.1a48db	29 ff 00	and #$00ff	            AND #$00FF
.1a48de	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a48e1	e2 20		sep #$20	            SEP #$20
.1a48e3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a48e6					range_err
.1a48e6	08		php		            PHP
.1a48e7	c2 20		rep #$20	            REP #$20
.1a48e9	48		pha		            PHA
.1a48ea	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a48ed	5b		tcd		            TCD
.1a48ee	68		pla		            PLA
.1a48ef	28		plp		            PLP
.1a48f0	e2 20		sep #$20	            SEP #$20
.1a48f2	a9 09		lda #$09	            LDA #ERR_RANGE
.1a48f4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a48f8	c2 20		rep #$20	            REP #$20
.1a48fa	29 ff 00	and #$00ff	            AND #$00FF
.1a48fd	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4900	e2 20		sep #$20	            SEP #$20
.1a4902	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4905					FN_LEFT
.1a4905	e2 20		sep #$20	            SEP #$20
.1a4907	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4909	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a490c	08		php		                PHP
.1a490d	c2 30		rep #$30	            REP #$30
.1a490f	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4912	e2 20		sep #$20	            SEP #$20
.1a4914	a5 27		lda $0827	                LDA ARGTYPE1
.1a4916	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4918	f0 03		beq $1a491d	                BEQ save_string
.1a491a	4c 71 49	jmp $1a4971	                JMP type_mismatch           ; Type mismatch if it's not a string
.1a491d					save_string
.1a491d	c2 20		rep #$20	            REP #$20
.1a491f	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.1a4921	48		pha		                PHA
.1a4922	a5 23		lda $0823	                LDA ARGUMENT1
.1a4924	48		pha		                PHA
.1a4925	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a4928	e2 20		sep #$20	            SEP #$20
.1a492a	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a492c	c9 2c		cmp #$2c	                CMP #','
.1a492e	f0 03		beq $1a4933	                BEQ skip_comma
.1a4930	4c 90 49	jmp $1a4990	                JMP syntax_err
.1a4933					skip_comma
.1a4933	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4936	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4939	e2 20		sep #$20	            SEP #$20
.1a493b	a5 27		lda $0827	                LDA ARGTYPE1
.1a493d	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a493f	d0 30		bne $1a4971	                BNE type_mismatch           ; Type mismatch if it's not an integer
.1a4941	c2 20		rep #$20	            REP #$20
.1a4943	a5 23		lda $0823	            LDA ARGUMENT1
.1a4945	85 8f		sta $088f	            STA MCOUNT
.1a4947	c2 20		rep #$20	            REP #$20
.1a4949	a9 00 00	lda #$0000	            LDA #<>0
.1a494c	85 29		sta $0829	            STA ARGUMENT2
.1a494e	a9 00 00	lda #$0000	            LDA #(0 >> 16)
.1a4951	85 2b		sta $082b	            STA ARGUMENT2+2
.1a4953	e2 20		sep #$20	            SEP #$20
.1a4955	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a4957	85 2d		sta $082d	            STA ARGTYPE2
.1a4959	c2 20		rep #$20	            REP #$20
.1a495b	68		pla		                PLA                         ; Recover the string pointer
.1a495c	85 23		sta $0823	                STA ARGUMENT1
.1a495e	68		pla		                PLA
.1a495f	85 25		sta $0825	                STA ARGUMENT1+2
.1a4961	e2 20		sep #$20	            SEP #$20
.1a4963	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a4965	85 27		sta $0827	            STA ARGTYPE1
.1a4967	20 1e 17	jsr $1a171e	            JSR STRSUBSTR
.1a496a					done
.1a496a	e2 20		sep #$20	            SEP #$20
.1a496c	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a496f	28		plp		                PLP
.1a4970	60		rts		            RTS
.1a4971					type_mismatch
.1a4971	08		php		            PHP
.1a4972	c2 20		rep #$20	            REP #$20
.1a4974	48		pha		            PHA
.1a4975	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4978	5b		tcd		            TCD
.1a4979	68		pla		            PLA
.1a497a	28		plp		            PLP
.1a497b	e2 20		sep #$20	            SEP #$20
.1a497d	a9 04		lda #$04	            LDA #ERR_TYPE
.1a497f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4983	c2 20		rep #$20	            REP #$20
.1a4985	29 ff 00	and #$00ff	            AND #$00FF
.1a4988	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a498b	e2 20		sep #$20	            SEP #$20
.1a498d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4990					syntax_err
.1a4990	08		php		            PHP
.1a4991	c2 20		rep #$20	            REP #$20
.1a4993	48		pha		            PHA
.1a4994	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4997	5b		tcd		            TCD
.1a4998	68		pla		            PLA
.1a4999	28		plp		            PLP
.1a499a	e2 20		sep #$20	            SEP #$20
.1a499c	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a499e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a49a2	c2 20		rep #$20	            REP #$20
.1a49a4	29 ff 00	and #$00ff	            AND #$00FF
.1a49a7	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a49aa	e2 20		sep #$20	            SEP #$20
.1a49ac	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a49af					range_err
.1a49af	08		php		            PHP
.1a49b0	c2 20		rep #$20	            REP #$20
.1a49b2	48		pha		            PHA
.1a49b3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a49b6	5b		tcd		            TCD
.1a49b7	68		pla		            PLA
.1a49b8	28		plp		            PLP
.1a49b9	e2 20		sep #$20	            SEP #$20
.1a49bb	a9 09		lda #$09	            LDA #ERR_RANGE
.1a49bd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a49c1	c2 20		rep #$20	            REP #$20
.1a49c3	29 ff 00	and #$00ff	            AND #$00FF
.1a49c6	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a49c9	e2 20		sep #$20	            SEP #$20
.1a49cb	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a49ce					FN_VAL
.1a49ce	e2 20		sep #$20	            SEP #$20
.1a49d0	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a49d2	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a49d5	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a49d8	c2 10		rep #$10	            REP #$10
.1a49da	e2 20		sep #$20	            SEP #$20
.1a49dc	a5 27		lda $0827	                LDA ARGTYPE1
.1a49de	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a49e0	d0 23		bne $1a4a05	                BNE type_mismatch
.1a49e2	c2 20		rep #$20	            REP #$20
.1a49e4	a5 00		lda $0800	                LDA BIP             ; preserve BIP for later
.1a49e6	85 40		sta $0840	                STA SAVEBIP
.1a49e8	a5 02		lda $0802	                LDA BIP+2
.1a49ea	85 42		sta $0842	                STA SAVEBIP+2
.1a49ec	a5 23		lda $0823	                LDA ARGUMENT1       ; Temporarily point BIP to the string to parse
.1a49ee	85 00		sta $0800	                STA BIP
.1a49f0	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a49f2	85 02		sta $0802	                STA BIP+2
.1a49f4	20 9d 08	jsr $1a089d	            JSR PARSEINT
.1a49f7	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.1a49f9	85 00		sta $0800	                STA BIP
.1a49fb	a5 42		lda $0842	                LDA SAVEBIP+2
.1a49fd	85 02		sta $0802	                STA BIP+2
.1a49ff	e2 20		sep #$20	            SEP #$20
.1a4a01	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4a04	60		rts		            RTS
.1a4a05					type_mismatch
.1a4a05	08		php		            PHP
.1a4a06	c2 20		rep #$20	            REP #$20
.1a4a08	48		pha		            PHA
.1a4a09	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4a0c	5b		tcd		            TCD
.1a4a0d	68		pla		            PLA
.1a4a0e	28		plp		            PLP
.1a4a0f	e2 20		sep #$20	            SEP #$20
.1a4a11	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4a13	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4a17	c2 20		rep #$20	            REP #$20
.1a4a19	29 ff 00	and #$00ff	            AND #$00FF
.1a4a1c	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4a1f	e2 20		sep #$20	            SEP #$20
.1a4a21	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4a24					FN_STR
.1a4a24	e2 20		sep #$20	            SEP #$20
.1a4a26	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4a28	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4a2b	08		php		                PHP
.1a4a2c	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4a2f	c2 10		rep #$10	            REP #$10
.1a4a31	e2 20		sep #$20	            SEP #$20
.1a4a33	a5 27		lda $0827	                LDA ARGTYPE1
.1a4a35	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4a37	d0 1a		bne $1a4a53	                BNE type_mismatch
.1a4a39	20 25 15	jsr $1a1525	            JSR ITOS
.1a4a3c	c2 20		rep #$20	            REP #$20
.1a4a3e	a5 16		lda $0816	                LDA STRPTR          ; Prepare the return result
.1a4a40	85 23		sta $0823	                STA ARGUMENT1
.1a4a42	a5 18		lda $0818	                LDA STRPTR+2
.1a4a44	85 25		sta $0825	                STA ARGUMENT1+2
.1a4a46	e2 20		sep #$20	            SEP #$20
.1a4a48	a9 02		lda #$02	                LDA #TYPE_STRING
.1a4a4a	85 27		sta $0827	                STA ARGTYPE1
.1a4a4c	28		plp		                PLP
.1a4a4d	e2 20		sep #$20	            SEP #$20
.1a4a4f	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4a52	60		rts		            RTS
.1a4a53					type_mismatch
.1a4a53	08		php		            PHP
.1a4a54	c2 20		rep #$20	            REP #$20
.1a4a56	48		pha		            PHA
.1a4a57	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4a5a	5b		tcd		            TCD
.1a4a5b	68		pla		            PLA
.1a4a5c	28		plp		            PLP
.1a4a5d	e2 20		sep #$20	            SEP #$20
.1a4a5f	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4a61	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4a65	c2 20		rep #$20	            REP #$20
.1a4a67	29 ff 00	and #$00ff	            AND #$00FF
.1a4a6a	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4a6d	e2 20		sep #$20	            SEP #$20
.1a4a6f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4a72					FN_DEC
.1a4a72	e2 20		sep #$20	            SEP #$20
.1a4a74	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4a76	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4a79	08		php		                PHP
.1a4a7a	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4a7d	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a4a80	c2 20		rep #$20	            REP #$20
.1a4a82	64 0c		stz $080c	                STZ SCRATCH
.1a4a84	64 0e		stz $080e	                STZ SCRATCH+2
.1a4a86	e2 30		sep #$30	            SEP #$30
.1a4a88	a0 00		ldy #$00	                LDY #0
.1a4a8a	b7 23		lda [$0823],y	skip_loop       LDA [ARGUMENT1],Y
.1a4a8c	c9 20		cmp #$20	                CMP #CHAR_SP
.1a4a8e	f0 04		beq $1a4a94	                BEQ skip_char
.1a4a90	c9 24		cmp #$24	                CMP #'$'
.1a4a92	d0 03		bne $1a4a97	                BNE loop
.1a4a94	c8		iny		skip_char       INY
.1a4a95	80 f3		bra $1a4a8a	                BRA skip_loop
.1a4a97	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y   ; Check the character
.1a4a99	20 d1 04	jsr $1a04d1	            JSR ISHEX
.1a4a9c	90 1e		bcc $1a4abc	                BCC ret_result      ; No: return what we have so far
.1a4a9e	c2 20		rep #$20	            REP #$20
.1a4aa0	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a4aa2	26 0e		rol $080e	                ROL SCRATCH+2
.1a4aa4	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a4aa6	26 0e		rol $080e	                ROL SCRATCH+2
.1a4aa8	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a4aaa	26 0e		rol $080e	                ROL SCRATCH+2
.1a4aac	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a4aae	26 0e		rol $080e	                ROL SCRATCH+2
.1a4ab0	e2 20		sep #$20	            SEP #$20
.1a4ab2	20 f2 04	jsr $1a04f2	            JSR HEX2BIN
.1a4ab5	05 0c		ora $080c	                ORA SCRATCH
.1a4ab7	85 0c		sta $080c	                STA SCRATCH         ; And add it to the result
.1a4ab9	c8		iny		                INY
.1a4aba	80 db		bra $1a4a97	                BRA loop            ; And try the next character
.1a4abc					ret_result
.1a4abc	c2 20		rep #$20	            REP #$20
.1a4abe	a5 0c		lda $080c	                LDA SCRATCH         ; Return the result
.1a4ac0	85 23		sta $0823	                STA ARGUMENT1
.1a4ac2	a5 0e		lda $080e	                LDA SCRATCH+2
.1a4ac4	85 25		sta $0825	                STA ARGUMENT1+2
.1a4ac6	e2 20		sep #$20	            SEP #$20
.1a4ac8	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a4aca	85 27		sta $0827	                STA ARGTYPE1
.1a4acc	28		plp		                PLP
.1a4acd	e2 20		sep #$20	            SEP #$20
.1a4acf	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4ad2	60		rts		            RTS
.1a4ad3					FN_HEX
.1a4ad3	e2 20		sep #$20	            SEP #$20
.1a4ad5	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4ad7	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4ada	08		php		                PHP
.1a4adb	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4ade	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a4ae1	20 c6 14	jsr $1a14c6	            JSR TEMPSTRING
.1a4ae4	e2 30		sep #$30	            SEP #$30
.1a4ae6	a0 ff		ldy #$ff	                LDY #$FF            ; Terminate the string
.1a4ae8	a9 00		lda #$00	                LDA #0
.1a4aea	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4aec	88		dey		                DEY
.1a4aed	a5 23		lda $0823	loop            LDA ARGUMENT1       ; Write the low digit
.1a4aef	29 0f		and #$0f	                AND #$0F
.1a4af1	aa		tax		                TAX
.1a4af2	bf 00 d0 1a	lda $1ad000,x	                LDA @lHEXDIGITS,X
.1a4af6	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4af8	88		dey		                DEY
.1a4af9	a5 23		lda $0823	                LDA ARGUMENT1       ; Write the high digit
.1a4afb	29 f0		and #$f0	                AND #$F0
.1a4afd	4a		lsr a		                LSR A
.1a4afe	4a		lsr a		                LSR A
.1a4aff	4a		lsr a		                LSR A
.1a4b00	4a		lsr a		                LSR A
.1a4b01	aa		tax		                TAX
.1a4b02	bf 00 d0 1a	lda $1ad000,x	                LDA @lHEXDIGITS,X
.1a4b06	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4b08	88		dey		                DEY
.1a4b09	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Shift value by one byte
.1a4b0b	85 23		sta $0823	                STA ARGUMENT1
.1a4b0d	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4b0f	85 24		sta $0824	                STA ARGUMENT1+1
.1a4b11	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a4b13	85 25		sta $0825	                STA ARGUMENT1+2
.1a4b15	a9 00		lda #$00	                LDA #0
.1a4b17	85 26		sta $0826	                STA ARGUMENT1+3
.1a4b19	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the argument 0?
.1a4b1b	d0 d0		bne $1a4aed	                BNE loop            ; No: keep converting
.1a4b1d	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a4b1f	d0 cc		bne $1a4aed	                BNE loop
.1a4b21	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4b23	d0 c8		bne $1a4aed	                BNE loop
.1a4b25	98		tya		                TYA                 ; Get the index of the first free char
.1a4b26	38		sec		                SEC                 ; Add 1 to get to the first character of the string
.1a4b27	65 16		adc $0816	                ADC STRPTR          ; And add the whole thing to the temp string pointer
.1a4b29	85 23		sta $0823	                STA ARGUMENT1       ; And return it as the result
.1a4b2b	a5 17		lda $0817	                LDA STRPTR+1
.1a4b2d	85 24		sta $0824	                STA ARGUMENT1+1
.1a4b2f	a5 18		lda $0818	                LDA STRPTR+2
.1a4b31	85 25		sta $0825	                STA ARGUMENT1+2
.1a4b33	a5 19		lda $0819	                LDA STRPTR+3
.1a4b35	85 26		sta $0826	                STA ARGUMENT1+3
.1a4b37	a9 02		lda #$02	                LDA #TYPE_STRING    ; And make the type STRING
.1a4b39	85 27		sta $0827	                STA ARGTYPE1
.1a4b3b	28		plp		                PLP
.1a4b3c	e2 20		sep #$20	            SEP #$20
.1a4b3e	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4b41	60		rts		            RTS
.1a4b42					type_mismatch
.1a4b42	08		php		            PHP
.1a4b43	c2 20		rep #$20	            REP #$20
.1a4b45	48		pha		            PHA
.1a4b46	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4b49	5b		tcd		            TCD
.1a4b4a	68		pla		            PLA
.1a4b4b	28		plp		            PLP
.1a4b4c	e2 20		sep #$20	            SEP #$20
.1a4b4e	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4b50	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4b54	c2 20		rep #$20	            REP #$20
.1a4b56	29 ff 00	and #$00ff	            AND #$00FF
.1a4b59	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4b5c	e2 20		sep #$20	            SEP #$20
.1a4b5e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4b61					FN_LEN
.1a4b61	e2 20		sep #$20	            SEP #$20
.1a4b63	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4b65	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4b68	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4b6b	e2 20		sep #$20	            SEP #$20
.1a4b6d	a5 27		lda $0827	                LDA ARGTYPE1
.1a4b6f	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4b71	d0 1f		bne $1a4b92	                BNE type_mismatch
.1a4b73	8b		phb		                PHB                 ; Set the data bank to the data bank of the string
.1a4b74	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4b76	48		pha		                PHA
.1a4b77	ab		plb		                PLB
.1a4b78	c2 10		rep #$10	            REP #$10
.1a4b7a	a6 23		ldx $0823	                LDX ARGUMENT1       ; And point X to the string data
.1a4b7c	20 b2 15	jsr $1a15b2	            JSR STRLEN
.1a4b7f	ab		plb		                PLB                 ; Restore the old data bank
.1a4b80	84 23		sty $0823	                STY ARGUMENT1       ; Save the length to ARGUMENT1
.1a4b82	c2 20		rep #$20	            REP #$20
.1a4b84	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4b86	e2 20		sep #$20	            SEP #$20
.1a4b88	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the type to INTEGER
.1a4b8a	85 27		sta $0827	                STA ARGTYPE1
.1a4b8c	e2 20		sep #$20	            SEP #$20
.1a4b8e	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4b91	60		rts		            RTS
.1a4b92					type_mismatch
.1a4b92	08		php		            PHP
.1a4b93	c2 20		rep #$20	            REP #$20
.1a4b95	48		pha		            PHA
.1a4b96	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4b99	5b		tcd		            TCD
.1a4b9a	68		pla		            PLA
.1a4b9b	28		plp		            PLP
.1a4b9c	e2 20		sep #$20	            SEP #$20
.1a4b9e	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4ba0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4ba4	c2 20		rep #$20	            REP #$20
.1a4ba6	29 ff 00	and #$00ff	            AND #$00FF
.1a4ba9	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4bac	e2 20		sep #$20	            SEP #$20
.1a4bae	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4bb1					FN_PEEK
.1a4bb1	e2 20		sep #$20	            SEP #$20
.1a4bb3	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4bb5	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4bb8	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4bbb	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a4bbe	e2 20		sep #$20	            SEP #$20
.1a4bc0	a5 25		lda $0825	                LDA ARGUMENT1+2                     ; Check to see if the request is to video memory
.1a4bc2	c9 b0		cmp #$b0	                CMP #`VRAM
.1a4bc4	90 10		bcc $1a4bd6	                BLT simple_peek                     ; No: just do an ordinary PEEK
.1a4bc6	c9 f0		cmp #$f0	                CMP #$F0
.1a4bc8	b0 0c		bcs $1a4bd6	                BGE simple_peek
.1a4bca	8b		phb		                PHB                                 ; DBR := bank
.1a4bcb	48		pha		                PHA
.1a4bcc	ab		plb		                PLB
.1a4bcd	a6 23		ldx $0823	                LDX ARGUMENT1                       ; X := address
.1a4bcf	22 44 11 00	jsl $001144	                JSL FK_READVRAM                     ; Fetch the low byte
.1a4bd3	ab		plb		                PLB
.1a4bd4	80 04		bra $1a4bda	                BRA save_result
.1a4bd6					simple_peek
.1a4bd6	e2 20		sep #$20	            SEP #$20
.1a4bd8	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.1a4bda	85 23		sta $0823	save_result     STA ARGUMENT1
.1a4bdc	64 24		stz $0824	                STZ ARGUMENT1+1
.1a4bde	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4be0	64 30		stz $0830	                STZ ARGUMENT1+13
.1a4be2	e2 20		sep #$20	            SEP #$20
.1a4be4	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4be7	60		rts		            RTS
.1a4be8					type_mismatch
.1a4be8	08		php		            PHP
.1a4be9	c2 20		rep #$20	            REP #$20
.1a4beb	48		pha		            PHA
.1a4bec	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4bef	5b		tcd		            TCD
.1a4bf0	68		pla		            PLA
.1a4bf1	28		plp		            PLP
.1a4bf2	e2 20		sep #$20	            SEP #$20
.1a4bf4	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4bf6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4bfa	c2 20		rep #$20	            REP #$20
.1a4bfc	29 ff 00	and #$00ff	            AND #$00FF
.1a4bff	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4c02	e2 20		sep #$20	            SEP #$20
.1a4c04	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4c07					FN_PEEKL
.1a4c07	e2 20		sep #$20	            SEP #$20
.1a4c09	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4c0b	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4c0e	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4c11	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a4c14	e2 20		sep #$20	            SEP #$20
.1a4c16	a5 25		lda $0825	                LDA ARGUMENT1+2                     ; Check to see if the request is to video memory
.1a4c18	c9 b0		cmp #$b0	                CMP #`VRAM
.1a4c1a	90 22		bcc $1a4c3e	                BLT simple_peek                     ; No: just do an ordinary PEEK
.1a4c1c	c9 f0		cmp #$f0	                CMP #$F0
.1a4c1e	b0 1e		bcs $1a4c3e	                BGE simple_peek
.1a4c20	8b		phb		                PHB                                 ; DBR := bank
.1a4c21	48		pha		                PHA
.1a4c22	ab		plb		                PLB
.1a4c23	a6 23		ldx $0823	                LDX ARGUMENT1                       ; X := address
.1a4c25	da		phx		                PHX
.1a4c26	22 44 11 00	jsl $001144	                JSL FK_READVRAM                     ; Fetch the low byte
.1a4c2a	85 0c		sta $080c	                STA SCRATCH                         ; Save the low byte
.1a4c2c	fa		plx		                PLX
.1a4c2d	e8		inx		                INX
.1a4c2e	da		phx		                PHX
.1a4c2f	22 44 11 00	jsl $001144	                JSL FK_READVRAM                     ; Fetch the middle byte
.1a4c33	85 0d		sta $080d	                STA SCRATCH+1                       ; Save the middle byte
.1a4c35	fa		plx		                PLX
.1a4c36	e8		inx		                INX
.1a4c37	22 44 11 00	jsl $001144	                JSL FK_READVRAM                     ; Fetch the high byte
.1a4c3b	ab		plb		                PLB
.1a4c3c	80 0d		bra $1a4c4b	                BRA save_result
.1a4c3e					simple_peek
.1a4c3e	c2 20		rep #$20	            REP #$20
.1a4c40	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.1a4c42	85 0c		sta $080c	                STA SCRATCH
.1a4c44	e2 20		sep #$20	            SEP #$20
.1a4c46	a0 02 00	ldy #$0002	                LDY #2
.1a4c49	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y
.1a4c4b	85 25		sta $0825	save_result     STA ARGUMENT1+2
.1a4c4d	64 26		stz $0826	                STZ ARGUMENT1+3
.1a4c4f	c2 20		rep #$20	            REP #$20
.1a4c51	a5 0c		lda $080c	                LDA SCRATCH
.1a4c53	85 23		sta $0823	                STA ARGUMENT1
.1a4c55	e2 20		sep #$20	            SEP #$20
.1a4c57	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4c5a	60		rts		            RTS
.1a4c5b					type_mismatch
.1a4c5b	08		php		            PHP
.1a4c5c	c2 20		rep #$20	            REP #$20
.1a4c5e	48		pha		            PHA
.1a4c5f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4c62	5b		tcd		            TCD
.1a4c63	68		pla		            PLA
.1a4c64	28		plp		            PLP
.1a4c65	e2 20		sep #$20	            SEP #$20
.1a4c67	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4c69	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4c6d	c2 20		rep #$20	            REP #$20
.1a4c6f	29 ff 00	and #$00ff	            AND #$00FF
.1a4c72	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4c75	e2 20		sep #$20	            SEP #$20
.1a4c77	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4c7a					FN_PEEKW
.1a4c7a	e2 20		sep #$20	            SEP #$20
.1a4c7c	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4c7e	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4c81	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4c84	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a4c87	e2 20		sep #$20	            SEP #$20
.1a4c89	a5 25		lda $0825	                LDA ARGUMENT1+2                     ; Check to see if the request is to video memory
.1a4c8b	c9 b0		cmp #$b0	                CMP #`VRAM
.1a4c8d	90 1d		bcc $1a4cac	                BLT simple_peek                     ; No: just do an ordinary PEEK
.1a4c8f	c9 f0		cmp #$f0	                CMP #$F0
.1a4c91	b0 19		bcs $1a4cac	                BGE simple_peek
.1a4c93	8b		phb		                PHB                                 ; DBR := bank
.1a4c94	48		pha		                PHA
.1a4c95	ab		plb		                PLB
.1a4c96	a6 23		ldx $0823	                LDX ARGUMENT1                       ; X := address
.1a4c98	da		phx		                PHX
.1a4c99	22 44 11 00	jsl $001144	                JSL FK_READVRAM                     ; Fetch the low byte
.1a4c9d	85 23		sta $0823	                STA ARGUMENT1                       ; Save the low byte
.1a4c9f	fa		plx		                PLX
.1a4ca0	e8		inx		                INX
.1a4ca1	22 44 11 00	jsl $001144	                JSL FK_READVRAM                     ; Fetch the high byte
.1a4ca5	85 24		sta $0824	                STA ARGUMENT1+1
.1a4ca7	ab		plb		                PLB
.1a4ca8	c2 20		rep #$20	            REP #$20
.1a4caa	80 06		bra $1a4cb2	                BRA done
.1a4cac					simple_peek
.1a4cac	c2 20		rep #$20	            REP #$20
.1a4cae	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.1a4cb0	85 23		sta $0823	                STA ARGUMENT1
.1a4cb2	64 25		stz $0825	done            STZ ARGUMENT1+2
.1a4cb4	e2 20		sep #$20	            SEP #$20
.1a4cb6	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4cb9	60		rts		            RTS
.1a4cba					type_mismatch
.1a4cba	08		php		            PHP
.1a4cbb	c2 20		rep #$20	            REP #$20
.1a4cbd	48		pha		            PHA
.1a4cbe	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4cc1	5b		tcd		            TCD
.1a4cc2	68		pla		            PLA
.1a4cc3	28		plp		            PLP
.1a4cc4	e2 20		sep #$20	            SEP #$20
.1a4cc6	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4cc8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4ccc	c2 20		rep #$20	            REP #$20
.1a4cce	29 ff 00	and #$00ff	            AND #$00FF
.1a4cd1	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4cd4	e2 20		sep #$20	            SEP #$20
.1a4cd6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4cd9					FN_CHR
.1a4cd9	e2 20		sep #$20	            SEP #$20
.1a4cdb	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4cdd	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4ce0	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4ce3	e2 20		sep #$20	            SEP #$20
.1a4ce5	a5 27		lda $0827	                LDA ARGTYPE1
.1a4ce7	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4ce9	d0 24		bne $1a4d0f	                BNE type_mismatch
.1a4ceb	20 c6 14	jsr $1a14c6	            JSR TEMPSTRING
.1a4cee	a5 23		lda $0823	                LDA ARGUMENT1       ; Get the numberic value
.1a4cf0	87 16		sta [$0816]	                STA [STRPTR]        ; And save it as the first character
.1a4cf2	a9 00		lda #$00	                LDA #0              ; Null terminate the string
.1a4cf4	a0 01 00	ldy #$0001	                LDY #1
.1a4cf7	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4cf9	c2 20		rep #$20	            REP #$20
.1a4cfb	a5 16		lda $0816	                LDA STRPTR
.1a4cfd	85 23		sta $0823	                STA ARGUMENT1
.1a4cff	a5 18		lda $0818	                LDA STRPTR+2
.1a4d01	85 25		sta $0825	                STA ARGUMENT1+2
.1a4d03	e2 20		sep #$20	            SEP #$20
.1a4d05	a9 02		lda #$02	                LDA #TYPE_STRING
.1a4d07	85 27		sta $0827	                STA ARGTYPE1
.1a4d09	e2 20		sep #$20	            SEP #$20
.1a4d0b	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4d0e	60		rts		            RTS
.1a4d0f					type_mismatch
.1a4d0f	08		php		            PHP
.1a4d10	c2 20		rep #$20	            REP #$20
.1a4d12	48		pha		            PHA
.1a4d13	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4d16	5b		tcd		            TCD
.1a4d17	68		pla		            PLA
.1a4d18	28		plp		            PLP
.1a4d19	e2 20		sep #$20	            SEP #$20
.1a4d1b	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4d1d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4d21	c2 20		rep #$20	            REP #$20
.1a4d23	29 ff 00	and #$00ff	            AND #$00FF
.1a4d26	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4d29	e2 20		sep #$20	            SEP #$20
.1a4d2b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4d2e					FN_ASC
.1a4d2e	e2 20		sep #$20	            SEP #$20
.1a4d30	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4d32	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4d35	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4d38	e2 20		sep #$20	            SEP #$20
.1a4d3a	a5 27		lda $0827	                LDA ARGTYPE1
.1a4d3c	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4d3e	d0 14		bne $1a4d54	                BNE type_mismatch
.1a4d40	a7 23		lda [$0823]	                LDA [ARGUMENT1]     ; Get the character
.1a4d42	85 23		sta $0823	                STA ARGUMENT1       ; Save its code to ARGUMENT1
.1a4d44	64 24		stz $0824	                STZ ARGUMENT1+1
.1a4d46	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4d48	64 26		stz $0826	                STZ ARGUMENT1+3
.1a4d4a	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the return type to integer
.1a4d4c	85 27		sta $0827	                STA ARGTYPE1
.1a4d4e	e2 20		sep #$20	            SEP #$20
.1a4d50	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4d53	60		rts		            RTS
.1a4d54					type_mismatch
.1a4d54	08		php		            PHP
.1a4d55	c2 20		rep #$20	            REP #$20
.1a4d57	48		pha		            PHA
.1a4d58	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4d5b	5b		tcd		            TCD
.1a4d5c	68		pla		            PLA
.1a4d5d	28		plp		            PLP
.1a4d5e	e2 20		sep #$20	            SEP #$20
.1a4d60	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4d62	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4d66	c2 20		rep #$20	            REP #$20
.1a4d68	29 ff 00	and #$00ff	            AND #$00FF
.1a4d6b	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4d6e	e2 20		sep #$20	            SEP #$20
.1a4d70	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4d73					FN_SPC
.1a4d73	e2 20		sep #$20	            SEP #$20
.1a4d75	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4d77	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4d7a	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4d7d	e2 20		sep #$20	            SEP #$20
.1a4d7f	a5 27		lda $0827	                LDA ARGTYPE1
.1a4d81	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4d83	d0 39		bne $1a4dbe	                BNE type_mismatch
.1a4d85	e2 20		sep #$20	            SEP #$20
.1a4d87	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.1a4d89	d0 52		bne $1a4ddd	                BNE err_limit
.1a4d8b	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4d8d	d0 4e		bne $1a4ddd	                BNE err_limit
.1a4d8f	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a4d91	d0 4a		bne $1a4ddd	                BNE err_limit
.1a4d93	c2 10		rep #$10	            REP #$10
.1a4d95	20 c6 14	jsr $1a14c6	            JSR TEMPSTRING
.1a4d98	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.1a4d9a	e2 20		sep #$20	            SEP #$20
.1a4d9c	a9 00		lda #$00	                LDA #0
.1a4d9e	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.1a4da0	88		dey		                DEY
.1a4da1	30 07		bmi $1a4daa	                BMI done
.1a4da3	a9 20		lda #$20	                LDA #CHAR_SP
.1a4da5	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.1a4da7	88		dey		                DEY
.1a4da8	10 fb		bpl $1a4da5	                BPL loop            ; And keep writing until we're done
.1a4daa	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.1a4dac	85 27		sta $0827	                STA ARGTYPE1
.1a4dae	c2 20		rep #$20	            REP #$20
.1a4db0	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.1a4db2	85 23		sta $0823	                STA ARGUMENT1
.1a4db4	a5 18		lda $0818	                LDA STRPTR+2
.1a4db6	85 25		sta $0825	                STA ARGUMENT1+2
.1a4db8	e2 20		sep #$20	            SEP #$20
.1a4dba	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4dbd	60		rts		            RTS
.1a4dbe					type_mismatch
.1a4dbe	08		php		            PHP
.1a4dbf	c2 20		rep #$20	            REP #$20
.1a4dc1	48		pha		            PHA
.1a4dc2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4dc5	5b		tcd		            TCD
.1a4dc6	68		pla		            PLA
.1a4dc7	28		plp		            PLP
.1a4dc8	e2 20		sep #$20	            SEP #$20
.1a4dca	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4dcc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4dd0	c2 20		rep #$20	            REP #$20
.1a4dd2	29 ff 00	and #$00ff	            AND #$00FF
.1a4dd5	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4dd8	e2 20		sep #$20	            SEP #$20
.1a4dda	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4ddd					err_limit
.1a4ddd	08		php		            PHP
.1a4dde	c2 20		rep #$20	            REP #$20
.1a4de0	48		pha		            PHA
.1a4de1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4de4	5b		tcd		            TCD
.1a4de5	68		pla		            PLA
.1a4de6	28		plp		            PLP
.1a4de7	e2 20		sep #$20	            SEP #$20
.1a4de9	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4deb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4def	c2 20		rep #$20	            REP #$20
.1a4df1	29 ff 00	and #$00ff	            AND #$00FF
.1a4df4	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4df7	e2 20		sep #$20	            SEP #$20
.1a4df9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4dfc					FN_TAB
.1a4dfc	e2 20		sep #$20	            SEP #$20
.1a4dfe	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4e00	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4e03	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4e06	e2 20		sep #$20	            SEP #$20
.1a4e08	a5 27		lda $0827	                LDA ARGTYPE1
.1a4e0a	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4e0c	d0 39		bne $1a4e47	                BNE type_mismatch
.1a4e0e	e2 20		sep #$20	            SEP #$20
.1a4e10	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.1a4e12	d0 52		bne $1a4e66	                BNE err_limit
.1a4e14	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4e16	d0 4e		bne $1a4e66	                BNE err_limit
.1a4e18	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a4e1a	d0 4a		bne $1a4e66	                BNE err_limit
.1a4e1c	c2 10		rep #$10	            REP #$10
.1a4e1e	20 c6 14	jsr $1a14c6	            JSR TEMPSTRING
.1a4e21	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.1a4e23	e2 20		sep #$20	            SEP #$20
.1a4e25	a9 00		lda #$00	                LDA #0
.1a4e27	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.1a4e29	88		dey		                DEY
.1a4e2a	30 07		bmi $1a4e33	                BMI done
.1a4e2c	a9 09		lda #$09	                LDA #CHAR_TAB
.1a4e2e	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.1a4e30	88		dey		                DEY
.1a4e31	10 fb		bpl $1a4e2e	                BPL loop            ; And keep writing until we're done
.1a4e33	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.1a4e35	85 27		sta $0827	                STA ARGTYPE1
.1a4e37	c2 20		rep #$20	            REP #$20
.1a4e39	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.1a4e3b	85 23		sta $0823	                STA ARGUMENT1
.1a4e3d	a5 18		lda $0818	                LDA STRPTR+2
.1a4e3f	85 25		sta $0825	                STA ARGUMENT1+2
.1a4e41	e2 20		sep #$20	            SEP #$20
.1a4e43	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4e46	60		rts		            RTS
.1a4e47					type_mismatch
.1a4e47	08		php		            PHP
.1a4e48	c2 20		rep #$20	            REP #$20
.1a4e4a	48		pha		            PHA
.1a4e4b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4e4e	5b		tcd		            TCD
.1a4e4f	68		pla		            PLA
.1a4e50	28		plp		            PLP
.1a4e51	e2 20		sep #$20	            SEP #$20
.1a4e53	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4e55	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4e59	c2 20		rep #$20	            REP #$20
.1a4e5b	29 ff 00	and #$00ff	            AND #$00FF
.1a4e5e	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4e61	e2 20		sep #$20	            SEP #$20
.1a4e63	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4e66					err_limit
.1a4e66	08		php		            PHP
.1a4e67	c2 20		rep #$20	            REP #$20
.1a4e69	48		pha		            PHA
.1a4e6a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4e6d	5b		tcd		            TCD
.1a4e6e	68		pla		            PLA
.1a4e6f	28		plp		            PLP
.1a4e70	e2 20		sep #$20	            SEP #$20
.1a4e72	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4e74	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4e78	c2 20		rep #$20	            REP #$20
.1a4e7a	29 ff 00	and #$00ff	            AND #$00FF
.1a4e7d	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4e80	e2 20		sep #$20	            SEP #$20
.1a4e82	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4e85					FN_ABS
.1a4e85	e2 20		sep #$20	            SEP #$20
.1a4e87	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4e89	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4e8c	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4e8f	e2 20		sep #$20	            SEP #$20
.1a4e91	a5 27		lda $0827	                LDA ARGTYPE1        ; Check the type
.1a4e93	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4e95	f0 23		beq $1a4eba	                BEQ abs_int         ; If integer, get the absolute value of the integer
.1a4e97	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.1a4e99	f0 3e		beq $1a4ed9	                BEQ abs_float       ; If float, get the absolute value of the float
.1a4e9b					type_err
.1a4e9b	08		php		            PHP
.1a4e9c	c2 20		rep #$20	            REP #$20
.1a4e9e	48		pha		            PHA
.1a4e9f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4ea2	5b		tcd		            TCD
.1a4ea3	68		pla		            PLA
.1a4ea4	28		plp		            PLP
.1a4ea5	e2 20		sep #$20	            SEP #$20
.1a4ea7	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4ea9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4ead	c2 20		rep #$20	            REP #$20
.1a4eaf	29 ff 00	and #$00ff	            AND #$00FF
.1a4eb2	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4eb5	e2 20		sep #$20	            SEP #$20
.1a4eb7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4eba					abs_int
.1a4eba	c2 20		rep #$20	            REP #$20
.1a4ebc	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Is it positive already?
.1a4ebe	10 21		bpl $1a4ee1	                BPL done            ; Yes: we don't need to do anythign further
.1a4ec0	49 ff ff	eor #$ffff	                EOR #$FFFF          ; Otherwise, take the two's compliment
.1a4ec3	85 25		sta $0825	                STA ARGUMENT1+2     ; Of ARGUMENT1
.1a4ec5	a5 23		lda $0823	                LDA ARGUMENT1
.1a4ec7	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a4eca	18		clc		                CLC
.1a4ecb	69 01 00	adc #$0001	                ADC #1
.1a4ece	85 23		sta $0823	                STA ARGUMENT1       ; And save it back to ARGUMENT1
.1a4ed0	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4ed2	69 00 00	adc #$0000	                ADC #0
.1a4ed5	85 25		sta $0825	                STA ARGUMENT1+2
.1a4ed7	80 08		bra $1a4ee1	                BRA done
.1a4ed9					abs_float
.1a4ed9	e2 20		sep #$20	            SEP #$20
.1a4edb	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Just clear the sign bit
.1a4edd	29 7f		and #$7f	                AND #$7F
.1a4edf	85 26		sta $0826	                STA ARGUMENT1+3
.1a4ee1					done
.1a4ee1	e2 20		sep #$20	            SEP #$20
.1a4ee3	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4ee6	60		rts		            RTS
.1a4ee7					FN_SGN
.1a4ee7	e2 20		sep #$20	            SEP #$20
.1a4ee9	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4eeb	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4eee	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4ef1	e2 20		sep #$20	            SEP #$20
.1a4ef3	a5 27		lda $0827	                LDA ARGTYPE1
.1a4ef5	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4ef7	d0 25		bne $1a4f1e	                BNE type_mismatch
.1a4ef9	c2 20		rep #$20	            REP #$20
.1a4efb	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4efd	30 12		bmi $1a4f11	                BMI is_negative     ; Negative: return -1
.1a4eff	d0 04		bne $1a4f05	                BNE is_positive     ; Is it not 0? Then return 1
.1a4f01	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the lower word 0?
.1a4f03	f0 13		beq $1a4f18	                BEQ done            ; Yes: the whole thing is zero: return 0
.1a4f05	a9 00 00	lda #$0000	is_positive     LDA #0              ; It's positive: return 1
.1a4f08	85 25		sta $0825	                STA ARGUMENT1+2
.1a4f0a	a9 01 00	lda #$0001	                LDA #1
.1a4f0d	85 23		sta $0823	                STA ARGUMENT1
.1a4f0f	80 07		bra $1a4f18	                BRA done
.1a4f11	a9 ff ff	lda #$ffff	is_negative     LDA #$FFFF          ; It's negative: return -1
.1a4f14	85 25		sta $0825	                STA ARGUMENT1+2
.1a4f16	85 23		sta $0823	                STA ARGUMENT1
.1a4f18					done
.1a4f18	e2 20		sep #$20	            SEP #$20
.1a4f1a	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4f1d	60		rts		            RTS
.1a4f1e					type_mismatch
.1a4f1e	08		php		            PHP
.1a4f1f	c2 20		rep #$20	            REP #$20
.1a4f21	48		pha		            PHA
.1a4f22	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4f25	5b		tcd		            TCD
.1a4f26	68		pla		            PLA
.1a4f27	28		plp		            PLP
.1a4f28	e2 20		sep #$20	            SEP #$20
.1a4f2a	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4f2c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4f30	c2 20		rep #$20	            REP #$20
.1a4f32	29 ff 00	and #$00ff	            AND #$00FF
.1a4f35	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a4f38	e2 20		sep #$20	            SEP #$20
.1a4f3a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4f3d					FN_INT
.1a4f3d	e2 20		sep #$20	            SEP #$20
.1a4f3f	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4f41	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4f44	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4f47	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a4f4a					done
.1a4f4a	e2 20		sep #$20	            SEP #$20
.1a4f4c	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4f4f	60		rts		            RTS
.1a4f50					FN_SIN
.1a4f50	e2 20		sep #$20	            SEP #$20
.1a4f52	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4f54	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4f57	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4f5a	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a4f5d	20 0e 62	jsr $1a620e	            JSR FP_SIN
.1a4f60					done
.1a4f60	e2 20		sep #$20	            SEP #$20
.1a4f62	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4f65	60		rts		            RTS
.1a4f66					FN_COS
.1a4f66	e2 20		sep #$20	            SEP #$20
.1a4f68	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4f6a	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4f6d	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4f70	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a4f73	20 3d 62	jsr $1a623d	            JSR FP_COS
.1a4f76					done
.1a4f76	e2 20		sep #$20	            SEP #$20
.1a4f78	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4f7b	60		rts		            RTS
.1a4f7c					FN_TAN
.1a4f7c	e2 20		sep #$20	            SEP #$20
.1a4f7e	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4f80	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4f83	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4f86	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a4f89	20 6c 62	jsr $1a626c	            JSR FP_TAN
.1a4f8c					done
.1a4f8c	e2 20		sep #$20	            SEP #$20
.1a4f8e	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4f91	60		rts		            RTS
.1a4f92					FN_LN
.1a4f92	e2 20		sep #$20	            SEP #$20
.1a4f94	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4f96	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4f99	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4f9c	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a4f9f	20 9a 62	jsr $1a629a	            JSR FP_LN
.1a4fa2					done
.1a4fa2	e2 20		sep #$20	            SEP #$20
.1a4fa4	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4fa7	60		rts		            RTS
.1a4fa8					FN_ACOS
.1a4fa8	e2 20		sep #$20	            SEP #$20
.1a4faa	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4fac	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4faf	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4fb2	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a4fb5	20 c3 63	jsr $1a63c3	            JSR FP_ACOS
.1a4fb8					done
.1a4fb8	e2 20		sep #$20	            SEP #$20
.1a4fba	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4fbd	60		rts		            RTS
.1a4fbe					FN_ASIN
.1a4fbe	e2 20		sep #$20	            SEP #$20
.1a4fc0	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4fc2	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4fc5	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4fc8	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a4fcb	20 99 63	jsr $1a6399	            JSR FP_ASIN
.1a4fce					done
.1a4fce	e2 20		sep #$20	            SEP #$20
.1a4fd0	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4fd3	60		rts		            RTS
.1a4fd4					FN_ATAN
.1a4fd4	e2 20		sep #$20	            SEP #$20
.1a4fd6	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4fd8	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4fdb	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4fde	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a4fe1	20 e5 63	jsr $1a63e5	            JSR FP_ATAN
.1a4fe4					done
.1a4fe4	e2 20		sep #$20	            SEP #$20
.1a4fe6	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4fe9	60		rts		            RTS
.1a4fea					FN_EXP
.1a4fea	e2 20		sep #$20	            SEP #$20
.1a4fec	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4fee	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a4ff1	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a4ff4	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a4ff7	20 79 64	jsr $1a6479	            JSR FP_EXP
.1a4ffa					done
.1a4ffa	e2 20		sep #$20	            SEP #$20
.1a4ffc	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a4fff	60		rts		            RTS
.1a5000					FN_SQR
.1a5000	e2 20		sep #$20	            SEP #$20
.1a5002	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a5004	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a5007	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a500a	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a500d	20 fb 64	jsr $1a64fb	            JSR FP_SQR
.1a5010					done
.1a5010	e2 20		sep #$20	            SEP #$20
.1a5012	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a5015	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\commands.s

.1a5016	00		brk #		CMD_MONITOR     BRK
.1a5017	ea		nop		                NOP
.1a5018	60		rts		            RTS
.1a5019					CMD_NEW
.1a5019	08		php		                PHP
.1a501a	0b		phd		                PHD
.1a501b	08		php		            PHP
.1a501c	c2 20		rep #$20	            REP #$20
.1a501e	48		pha		            PHA
.1a501f	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a5022	5b		tcd		            TCD
.1a5023	68		pla		            PLA
.1a5024	28		plp		            PLP
.1a5025	c2 30		rep #$30	            REP #$30
.1a5027	c2 20		rep #$20	            REP #$20
.1a5029	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.1a502c	85 d9		sta $08d9	            STA LASTLINE
.1a502e	e2 20		sep #$20	            SEP #$20
.1a5030	a9 16		lda #$16	            LDA #`BASIC_BOT
.1a5032	85 db		sta $08db	            STA LASTLINE+2
.1a5034	c2 30		rep #$30	            REP #$30
.1a5036	a9 00 00	lda #$0000	                LDA #0
.1a5039	a0 00 00	ldy #$0000	                LDY #LINE_LINK
.1a503c	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.1a503e	a0 02 00	ldy #$0002	                LDY #LINE_NUMBER
.1a5041	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.1a5043	a0 04 00	ldy #$0004	                LDY #LINE_TOKENS
.1a5046	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.1a5048	20 b8 20	jsr $1a20b8	            JSR CLRINTERP
.1a504b	2b		pld		                PLD
.1a504c	28		plp		                PLP
.1a504d	60		rts		            RTS
.1a504e					CMD_RUN
.1a504e	8b		phb		                PHB
.1a504f	08		php		                PHP
.1a5050	c2 20		rep #$20	            REP #$20
.1a5052	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT            ; Point to the first line of the program
.1a5055	85 1a		sta $081a	                STA CURLINE
.1a5057	a9 16 00	lda #$0016	                LDA #`BASIC_BOT
.1a505a	85 1c		sta $081c	                STA CURLINE + 2
.1a505c	20 b8 20	jsr $1a20b8	            JSR CLRINTERP
.1a505f	20 98 23	jsr $1a2398	            JSR EXECPROGRAM
.1a5062	28		plp		                PLP
.1a5063	ab		plb		                PLB
.1a5064	60		rts		            RTS
.1a5065					CMD_LIST
.1a5065	08		php		                PHP
.1a5066	c2 20		rep #$20	            REP #$20
.1a5068	64 55		stz $0855	                STZ MARG1               ; MARG1 is starting line number, default 0
.1a506a	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.1a506d	85 59		sta $0859	                STA MARG2               ; MARG2 is ending line number, default MAXINT
.1a506f	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a5072	20 43 22	jsr $1a2243	            JSR PEEK_TOK
.1a5075	29 ff 00	and #$00ff	                AND #$00FF
.1a5078	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.1a507b	f0 2c		beq $1a50a9	                BEQ call_list           ; ... just list with the defaults
.1a507d	c9 81 00	cmp #$0081	                CMP #TOK_MINUS          ; If just "- ###"...
.1a5080	f0 1a		beq $1a509c	                BEQ parse_endline       ; ... try to parse the end line number
.1a5082	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a5085	20 9d 08	jsr $1a089d	            JSR PARSEINT
.1a5088	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG1
.1a508a	85 55		sta $0855	                STA MARG1
.1a508c	20 43 22	jsr $1a2243	            JSR PEEK_TOK
.1a508f	29 ff 00	and #$00ff	                AND #$00FF
.1a5092	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.1a5095	f0 12		beq $1a50a9	                BEQ call_list           ; ... just list with the defaults
.1a5097	c9 81 00	cmp #$0081	                CMP #TOK_MINUS
.1a509a	d0 2a		bne $1a50c6	                BNE error               ; At this point, if not '-', it's a syntax error
.1a509c					parse_endline
.1a509c	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a509f	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a50a2	20 9d 08	jsr $1a089d	            JSR PARSEINT
.1a50a5	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG2
.1a50a7	85 59		sta $0859	                STA MARG2
.1a50a9	a5 1c		lda $081c	call_list       LDA CURLINE+2           ; Save CURLINE
.1a50ab	48		pha		                PHA
.1a50ac	a5 1a		lda $081a	                LDA CURLINE
.1a50ae	48		pha		                PHA
.1a50af	a5 02		lda $0802	                LDA BIP+2               ; Save BIP
.1a50b1	48		pha		                PHA
.1a50b2	a5 00		lda $0800	                LDA BIP
.1a50b4	48		pha		                PHA
.1a50b5	20 50 18	jsr $1a1850	            JSR LISTPROG
.1a50b8	68		pla		                PLA
.1a50b9	85 00		sta $0800	                STA BIP
.1a50bb	68		pla		                PLA
.1a50bc	85 02		sta $0802	                STA BIP+2
.1a50be	68		pla		                PLA
.1a50bf	85 1a		sta $081a	                STA CURLINE
.1a50c1	68		pla		                PLA
.1a50c2	85 1c		sta $081c	                STA CURLINE+2
.1a50c4	28		plp		                PLP
.1a50c5	60		rts		            RTS
.1a50c6					error
.1a50c6	08		php		            PHP
.1a50c7	c2 20		rep #$20	            REP #$20
.1a50c9	48		pha		            PHA
.1a50ca	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a50cd	5b		tcd		            TCD
.1a50ce	68		pla		            PLA
.1a50cf	28		plp		            PLP
.1a50d0	e2 20		sep #$20	            SEP #$20
.1a50d2	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a50d4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a50d8	c2 20		rep #$20	            REP #$20
.1a50da	29 ff 00	and #$00ff	            AND #$00FF
.1a50dd	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a50e0	e2 20		sep #$20	            SEP #$20
.1a50e2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]

;******  Return to file: src\basic816.s


;******  Processing file: src\variables.s

>08e1					NEXTVAR         .long ?         ; Pointer to the the next available byte for variable bindings
>08e4					VARIABLES       .long ?         ; Pointer to the most recently allocated variable
>08e7					TOFIND          .long ?         ; Pointer to the variable name to find
>08ea					TOFINDTYPE      .byte ?         ; The type to find
.0000					BINDING
>0000					TYPE            .fill 1                 ; The type of the data stored in the variable
>0001					NAME            .fill VAR_NAME_SIZE     ; The name of the variable
>0009					VALUE           .fill 4                 ; The data stored in the variable
>000d					NEXT            .fill 3                 ; The pointer to the next allocated variable of this type
.1a50e5					INITVARS
.1a50e5	08		php		                PHP
.1a50e6	08		php		            PHP
.1a50e7	c2 20		rep #$20	            REP #$20
.1a50e9	48		pha		            PHA
.1a50ea	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a50ed	5b		tcd		            TCD
.1a50ee	68		pla		            PLA
.1a50ef	28		plp		            PLP
.1a50f0	c2 20		rep #$20	            REP #$20
.1a50f2	64 e4		stz $08e4	                STZ VARIABLES           ; Clear the pointer to the variables
.1a50f4	64 e7		stz $08e7	                STZ TOFIND
.1a50f6	e2 20		sep #$20	            SEP #$20
.1a50f8	64 e6		stz $08e6	                STZ VARIABLES+2
.1a50fa	64 e9		stz $08e9	                STZ TOFIND+2
.1a50fc	64 ea		stz $08ea	                STZ TOFINDTYPE
.1a50fe	c2 20		rep #$20	            REP #$20
.1a5100	38		sec		                SEC                     ; Compute the position of the first variable
.1a5101	a5 d9		lda $08d9	                LDA LASTLINE
.1a5103	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.1a5106	85 e1		sta $08e1	                STA NEXTVAR
.1a5108	e2 20		sep #$20	            SEP #$20
.1a510a	a5 db		lda $08db	                LDA LASTLINE+2
.1a510c	69 00		adc #$00	                ADC #0
.1a510e	85 e3		sta $08e3	                STA NEXTVAR+2
.1a5110	28		plp		                PLP
.1a5111	60		rts		            RTS
.1a5112					ISVARCHAR
.1a5112	c9 5f		cmp #$5f	                CMP #'_'            ; Check if it's an underscore
.1a5114	f0 1a		beq $1a5130	                BEQ return_true     ; Yes: return true
.1a5116	c9 3a		cmp #$3a	                CMP #'9'+1          ; Check if its in [0-9]
.1a5118	b0 04		bcs $1a511e	                BGE else1           ; No: check something else
.1a511a	c9 30		cmp #$30	                CMP #'0'
.1a511c	b0 12		bcs $1a5130	                BGE return_true     ; Yes: return true
.1a511e	c9 5b		cmp #$5b	else1           CMP #'Z'+1          ; Check if its in [A-Z]
.1a5120	b0 04		bcs $1a5126	                BGE not_upper       ; No: check lower case
.1a5122	c9 41		cmp #$41	                CMP #'A'
.1a5124	b0 0a		bcs $1a5130	                BGE return_true     ; Yes: return true
.1a5126	c9 7b		cmp #$7b	not_upper       CMP #'z'+1          ; Check if its in [a-z]
.1a5128	b0 04		bcs $1a512e	                BGE return_false    ; No: return false
.1a512a	c9 61		cmp #$61	                CMP #'a'
.1a512c	b0 02		bcs $1a5130	                BGE return_true     ; Yes: return true
.1a512e	18		clc		return_false    CLC
.1a512f	60		rts		            RTS
.1a5130	38		sec		return_true     SEC
.1a5131	60		rts		            RTS
.1a5132					VARNAMECMP
.1a5132	08		php		                PHP
.1a5133	e2 20		sep #$20	            SEP #$20
.1a5135	c2 10		rep #$10	            REP #$10
.1a5137	a0 00 00	ldy #$0000	                LDY #0
.1a513a	b7 0c		lda [$080c],y	cmp_loop        LDA [SCRATCH],Y         ; Check the character in the variable name
.1a513c	f0 0a		beq $1a5148	                BEQ is_end
.1a513e	d7 e7		cmp [$08e7],y	                CMP [TOFIND],Y          ; Compare the character to the one TOFIND
.1a5140	d0 13		bne $1a5155	                BNE return_false        ; Not equal? Then this is not a match
.1a5142	c8		iny		                INY
.1a5143	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.1a5146	d0 f2		bne $1a513a	                BNE cmp_loop
.1a5148	b7 e7		lda [$08e7],y	is_end          LDA [TOFIND],Y          ; Check the character in the name to find
.1a514a	20 1b 05	jsr $1a051b	            JSR TOUPPERA
.1a514d	20 12 51	jsr $1a5112	            JSR ISVARCHAR
.1a5150	b0 03		bcs $1a5155	                BCS return_false        ; YES: we do not have a match
.1a5152					return_true
.1a5152	28		plp		                PLP
.1a5153	38		sec		                SEC
.1a5154	60		rts		            RTS
.1a5155					return_false
.1a5155	28		plp		                PLP
.1a5156	18		clc		                CLC
.1a5157	60		rts		            RTS
.1a5158					VAR_FIND
.1a5158	08		php		                PHP
.1a5159	e2 20		sep #$20	            SEP #$20
.1a515b	c2 10		rep #$10	            REP #$10
.1a515d	a0 00 00	ldy #$0000	                LDY #0
.1a5160	a2 00 00	ldx #$0000	                LDX #0
.1a5163	b7 e7		lda [$08e7],y	upper_loop      LDA [TOFIND],Y          ; Get a character
.1a5165	f0 0b		beq $1a5172	                BEQ done_upper
.1a5167	20 1b 05	jsr $1a051b	            JSR TOUPPERA
.1a516a	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; And save it to the temp
.1a516e	c8		iny		                INY
.1a516f	e8		inx		                INX
.1a5170	80 f1		bra $1a5163	                BRA upper_loop          ; Go back for another
.1a5172	a9 00		lda #$00	done_upper      LDA #0
.1a5174	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; NULL terminate the temporary string
.1a5178	c2 20		rep #$20	            REP #$20
.1a517a	a9 00 4e	lda #$4e00	                LDA #<>TEMPBUF          ; Make the temporary string the string
.1a517d	85 e7		sta $08e7	                STA TOFIND              ; the variable name to find
.1a517f	e2 20		sep #$20	            SEP #$20
.1a5181	a9 00		lda #$00	                LDA #`TEMPBUF
.1a5183	85 e9		sta $08e9	                STA TOFIND+2
.1a5185	c2 20		rep #$20	            REP #$20
.1a5187	a5 e4		lda $08e4	                LDA VARIABLES           ; Point INDEX to the first variable to check
.1a5189	85 08		sta $0808	                STA INDEX
.1a518b	d0 06		bne $1a5193	                BNE set_index_h         ; If the low word is not 0, copy the high byte
.1a518d	e2 20		sep #$20	            SEP #$20
.1a518f	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a5191	f0 4d		beq $1a51e0	                BEQ not_found           ; If it is, we have no variables yet.
.1a5193					set_index_h
.1a5193	e2 20		sep #$20	            SEP #$20
.1a5195	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a5197	85 0a		sta $080a	                STA INDEX+2
.1a5199	a5 ea		lda $08ea	check_binding   LDA TOFINDTYPE
.1a519b	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Get the type of the variable
.1a519e	d7 08		cmp [$0808],y	                CMP [INDEX],Y
.1a51a0	d0 17		bne $1a51b9	                BNE check_next          ; If it's not a match, check the next binding
.1a51a2	c2 20		rep #$20	            REP #$20
.1a51a4	18		clc		                CLC
.1a51a5	a5 08		lda $0808	                LDA INDEX
.1a51a7	69 01 00	adc #$0001	                ADC #BINDING.NAME
.1a51aa	85 0c		sta $080c	                STA SCRATCH
.1a51ac	e2 20		sep #$20	            SEP #$20
.1a51ae	a5 0a		lda $080a	                LDA INDEX+2
.1a51b0	69 00		adc #$00	                ADC #0
.1a51b2	85 0e		sta $080e	                STA SCRATCH+2
.1a51b4	20 32 51	jsr $1a5132	            JSR VARNAMECMP
.1a51b7	b0 2a		bcs $1a51e3	                BCS found               ; If they match, return that we've found the variable
.1a51b9	a0 0d 00	ldy #$000d	check_next      LDY #BINDING.NEXT       ; SCRATCH := [INDEX].NEXT
.1a51bc	c2 20		rep #$20	            REP #$20
.1a51be	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a51c0	85 0c		sta $080c	                STA SCRATCH
.1a51c2	c8		iny		                INY
.1a51c3	c8		iny		                INY
.1a51c4	e2 20		sep #$20	            SEP #$20
.1a51c6	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a51c8	85 0e		sta $080e	                STA SCRATCH+2
.1a51ca	d0 06		bne $1a51d2	                BNE set_index           ; If SCRATCH == 0, the variable wasn't found
.1a51cc	c2 20		rep #$20	            REP #$20
.1a51ce	a5 0c		lda $080c	                LDA SCRATCH
.1a51d0	f0 0e		beq $1a51e0	                BEQ not_found
.1a51d2					set_index
.1a51d2	c2 20		rep #$20	            REP #$20
.1a51d4	a5 0c		lda $080c	                LDA SCRATCH
.1a51d6	85 08		sta $0808	                STA INDEX
.1a51d8	e2 20		sep #$20	            SEP #$20
.1a51da	a5 0e		lda $080e	                LDA SCRATCH+2
.1a51dc	85 0a		sta $080a	                STA INDEX+2
.1a51de	80 b9		bra $1a5199	                BRA check_binding       ; And check this next variable for a match
.1a51e0					not_found
.1a51e0	28		plp		                PLP
.1a51e1	18		clc		                CLC
.1a51e2	60		rts		            RTS
.1a51e3					found
.1a51e3	28		plp		                PLP
.1a51e4	38		sec		                SEC
.1a51e5	60		rts		            RTS
.1a51e6					VAR_REF
.1a51e6	08		php		                PHP
.1a51e7	20 58 51	jsr $1a5158	            JSR VAR_FIND
.1a51ea	b0 1f		bcs $1a520b	                BCS found
.1a51ec	08		php		            PHP
.1a51ed	c2 20		rep #$20	            REP #$20
.1a51ef	48		pha		            PHA
.1a51f0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a51f3	5b		tcd		            TCD
.1a51f4	68		pla		            PLA
.1a51f5	28		plp		            PLP
.1a51f6	e2 20		sep #$20	            SEP #$20
.1a51f8	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a51fa	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a51fe	c2 20		rep #$20	            REP #$20
.1a5200	29 ff 00	and #$00ff	            AND #$00FF
.1a5203	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a5206	e2 20		sep #$20	            SEP #$20
.1a5208	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a520b					found
.1a520b	c2 30		rep #$30	            REP #$30
.1a520d	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.1a5210	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a5212	85 23		sta $0823	                STA ARGUMENT1
.1a5214	c8		iny		                INY
.1a5215	c8		iny		                INY
.1a5216	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a5218	85 25		sta $0825	                STA ARGUMENT1+2
.1a521a	e2 20		sep #$20	            SEP #$20
.1a521c	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE
.1a521f	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a5221	85 27		sta $0827	                STA ARGTYPE1
.1a5223	28		plp		done            PLP
.1a5224	60		rts		            RTS
.1a5225					VAR_ALLOC
.1a5225	08		php		                PHP
.1a5226	c2 20		rep #$20	            REP #$20
.1a5228	18		clc		                CLC                     ; Compute extent of the binding
.1a5229	a5 e1		lda $08e1	                LDA NEXTVAR
.1a522b	69 10 00	adc #$0010	                ADC #size(BINDING)
.1a522e	85 08		sta $0808	                STA INDEX
.1a5230	e2 20		sep #$20	            SEP #$20
.1a5232	a5 e3		lda $08e3	                LDA NEXTVAR+2
.1a5234	69 00		adc #$00	                ADC #0
.1a5236	85 0a		sta $080a	                STA INDEX+2
.1a5238	c5 bc		cmp $08bc	                CMP HEAP+2              ; Check to see if HEAP > INDEX
.1a523a	90 27		bcc $1a5263	                BLT has_room
.1a523c	c2 20		rep #$20	            REP #$20
.1a523e	a5 08		lda $0808	                LDA INDEX
.1a5240	c5 ba		cmp $08ba	                CMP HEAP
.1a5242	90 1f		bcc $1a5263	                BLT has_room
.1a5244	08		php		            PHP
.1a5245	c2 20		rep #$20	            REP #$20
.1a5247	48		pha		            PHA
.1a5248	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a524b	5b		tcd		            TCD
.1a524c	68		pla		            PLA
.1a524d	28		plp		            PLP
.1a524e	e2 20		sep #$20	            SEP #$20
.1a5250	a9 09		lda #$09	            LDA #ERR_RANGE
.1a5252	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5256	c2 20		rep #$20	            REP #$20
.1a5258	29 ff 00	and #$00ff	            AND #$00FF
.1a525b	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a525e	e2 20		sep #$20	            SEP #$20
.1a5260	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5263					has_room
.1a5263	c2 20		rep #$20	            REP #$20
.1a5265	a5 e1		lda $08e1	                LDA NEXTVAR             ; Yes: we can allocate the variable
.1a5267	85 c0		sta $08c0	                STA CURRBLOCK           ; Point CURRBLOCK to it
.1a5269	e2 20		sep #$20	            SEP #$20
.1a526b	a5 e3		lda $08e3	                LDA NEXTVAR+2
.1a526d	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a526f	c2 20		rep #$20	            REP #$20
.1a5271	a5 08		lda $0808	                LDA INDEX               ; And point NEXTVAR to the next possible spot
.1a5273	85 e1		sta $08e1	                STA NEXTVAR
.1a5275	e2 20		sep #$20	            SEP #$20
.1a5277	a5 0a		lda $080a	                LDA INDEX+2
.1a5279	85 e3		sta $08e3	                STA NEXTVAR+2
.1a527b	28		plp		                PLP
.1a527c	60		rts		            RTS
.1a527d					VAR_CREATE
.1a527d	08		php		                PHP
.1a527e	e2 20		sep #$20	            SEP #$20
.1a5280	a5 27		lda $0827	                LDA ARGTYPE1            ; Validate that our types match
.1a5282	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.1a5284	f0 33		beq $1a52b9	                BEQ chk_string          ; If so: check to see if it's a string
.1a5286	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable type
.1a5288	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's INTEGER
.1a528a	d0 05		bne $1a5291	                BNE chk_float
.1a528c	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a528f	80 2f		bra $1a52c0	                BRA alloc_binding       ; And bind the variable
.1a5291	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; If it's FLOAT
.1a5293	d0 05		bne $1a529a	                BNE type_error
.1a5295	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a5298	80 26		bra $1a52c0	                BRA alloc_binding       ; And bind the variable
.1a529a					type_error
.1a529a	08		php		            PHP
.1a529b	c2 20		rep #$20	            REP #$20
.1a529d	48		pha		            PHA
.1a529e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a52a1	5b		tcd		            TCD
.1a52a2	68		pla		            PLA
.1a52a3	28		plp		            PLP
.1a52a4	e2 20		sep #$20	            SEP #$20
.1a52a6	a9 04		lda #$04	            LDA #ERR_TYPE
.1a52a8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a52ac	c2 20		rep #$20	            REP #$20
.1a52ae	29 ff 00	and #$00ff	            AND #$00FF
.1a52b1	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a52b4	e2 20		sep #$20	            SEP #$20
.1a52b6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a52b9	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING        ; Is it a string?
.1a52bb	d0 03		bne $1a52c0	                BNE alloc_binding       ; No: just go ahead and bind it
.1a52bd	20 b8 16	jsr $1a16b8	            JSR STRCPY
.1a52c0					alloc_binding
.1a52c0	c2 10		rep #$10	            REP #$10
.1a52c2	20 25 52	jsr $1a5225	            JSR VAR_ALLOC
.1a52c5	c2 30		rep #$30	            REP #$30
.1a52c7	18		clc		                CLC
.1a52c8	a5 c0		lda $08c0	                LDA CURRBLOCK
.1a52ca	69 01 00	adc #$0001	                ADC #BINDING.NAME
.1a52cd	85 08		sta $0808	                STA INDEX
.1a52cf	e2 20		sep #$20	            SEP #$20
.1a52d1	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a52d3	69 00		adc #$00	                ADC #0
.1a52d5	85 0a		sta $080a	                STA INDEX+2
.1a52d7	a0 00 00	ldy #$0000	                LDY #0                  ; Ensure that the name field is blank
.1a52da	a9 00		lda #$00	                LDA #0
.1a52dc	97 08		sta [$0808],y	blank_loop      STA [INDEX],Y
.1a52de	c8		iny		                INY
.1a52df	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.1a52e2	d0 f8		bne $1a52dc	                BNE blank_loop
.1a52e4	a0 00 00	ldy #$0000	                LDY #0
.1a52e7	b7 e7		lda [$08e7],y	name_loop       LDA [TOFIND],Y          ; Copy TOFIND to the NAME field
.1a52e9	f0 10		beq $1a52fb	                BEQ set_type
.1a52eb	20 1b 05	jsr $1a051b	            JSR TOUPPERA
.1a52ee	20 12 51	jsr $1a5112	            JSR ISVARCHAR
.1a52f1	90 08		bcc $1a52fb	                BCC set_type
.1a52f3	97 08		sta [$0808],y	                STA [INDEX],Y
.1a52f5	c8		iny		                INY
.1a52f6	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.1a52f9	d0 ec		bne $1a52e7	                BNE name_loop
.1a52fb					set_type
.1a52fb	c2 20		rep #$20	            REP #$20
.1a52fd	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE      ; Copy the value to the variable
.1a5300	a5 23		lda $0823	                LDA ARGUMENT1
.1a5302	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a5304	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5306	c8		iny		                INY
.1a5307	c8		iny		                INY
.1a5308	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a530a	a5 e4		lda $08e4	                LDA VARIABLES           ; Point NEXT to the current top of variables
.1a530c	a0 0d 00	ldy #$000d	                LDY #BINDING.NEXT
.1a530f	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a5311	c8		iny		                INY
.1a5312	c8		iny		                INY
.1a5313	e2 20		sep #$20	            SEP #$20
.1a5315	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a5317	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a5319	c2 20		rep #$20	            REP #$20
.1a531b	a5 c0		lda $08c0	                LDA CURRBLOCK
.1a531d	85 e4		sta $08e4	                STA VARIABLES
.1a531f	e2 20		sep #$20	            SEP #$20
.1a5321	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a5323	85 e6		sta $08e6	                STA VARIABLES+2
.1a5325	e2 20		sep #$20	            SEP #$20
.1a5327	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Set the type of the variable
.1a532a	a5 27		lda $0827	                LDA ARGTYPE1
.1a532c	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a532e	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is it a string?
.1a5330	f0 02		beq $1a5334	                BEQ set_ref             ; Yes: add a reference count to it
.1a5332	28		plp		done            PLP
.1a5333	60		rts		            RTS
.1a5334					set_ref
.1a5334	c2 20		rep #$20	            REP #$20
.1a5336	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the a heap allocated value
.1a5338	85 c0		sta $08c0	                STA CURRBLOCK
.1a533a	e2 20		sep #$20	            SEP #$20
.1a533c	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a533e	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a5340	20 d4 12	jsr $1a12d4	            JSR HEAP_GETHED
.1a5343	20 e9 12	jsr $1a12e9	            JSR HEAP_ADDREF
.1a5346	80 ea		bra $1a5332	                BRA done
.1a5348					VAR_SET
.1a5348	08		php		                PHP
.1a5349	c2 30		rep #$30	            REP #$30
.1a534b	a5 e4		lda $08e4	                LDA VARIABLES          ; If VARIABLES = 0, use VAR_CREATE
.1a534d	d0 06		bne $1a5355	                BNE use_find
.1a534f	e2 20		sep #$20	            SEP #$20
.1a5351	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a5353	f0 05		beq $1a535a	                BEQ use_create
.1a5355					use_find
.1a5355	20 58 51	jsr $1a5158	            JSR VAR_FIND
.1a5358	b0 05		bcs $1a535f	                BCS found
.1a535a					use_create
.1a535a	20 7d 52	jsr $1a527d	            JSR VAR_CREATE
.1a535d	80 4e		bra $1a53ad	                BRA done
.1a535f					found
.1a535f	e2 20		sep #$20	            SEP #$20
.1a5361	a5 27		lda $0827	                LDA ARGTYPE1            ; Do the types match?
.1a5363	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.1a5365	f0 33		beq $1a539a	                BEQ chk_string          ; Yes: check to see if it's string
.1a5367	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable
.1a5369	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; Is it INTEGER?
.1a536b	d0 05		bne $1a5372	                BNE chk_float
.1a536d	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a5370	80 2c		bra $1a539e	                BRA set_val
.1a5372	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; Is it FLOAT?
.1a5374	d0 05		bne $1a537b	                BNE type_error          ; No: throw an error
.1a5376	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a5379	80 23		bra $1a539e	                BRA set_val
.1a537b					type_error
.1a537b	08		php		            PHP
.1a537c	c2 20		rep #$20	            REP #$20
.1a537e	48		pha		            PHA
.1a537f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5382	5b		tcd		            TCD
.1a5383	68		pla		            PLA
.1a5384	28		plp		            PLP
.1a5385	e2 20		sep #$20	            SEP #$20
.1a5387	a9 04		lda #$04	            LDA #ERR_TYPE
.1a5389	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a538d	c2 20		rep #$20	            REP #$20
.1a538f	29 ff 00	and #$00ff	            AND #$00FF
.1a5392	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a5395	e2 20		sep #$20	            SEP #$20
.1a5397	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a539a	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING
.1a539c	f0 11		beq $1a53af	                BEQ set_string          ; Yes: set the string value of the variable
.1a539e					set_val
.1a539e	c2 30		rep #$30	            REP #$30
.1a53a0	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.1a53a3	a5 23		lda $0823	                LDA ARGUMENT1
.1a53a5	97 08		sta [$0808],y	                STA [INDEX],Y
.1a53a7	c8		iny		                INY
.1a53a8	c8		iny		                INY
.1a53a9	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a53ab	97 08		sta [$0808],y	                STA [INDEX],Y
.1a53ad					done
.1a53ad	28		plp		                PLP
.1a53ae	60		rts		            RTS
.1a53af					set_string
.1a53af	20 b8 16	jsr $1a16b8	            JSR STRCPY
.1a53b2	a0 09 00	ldy #$0009	set_ref         LDY #BINDING.VALUE      ; Set CURRBLOCK to the current string value
.1a53b5	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a53b7	85 c0		sta $08c0	                STA CURRBLOCK
.1a53b9	c8		iny		                INY
.1a53ba	c8		iny		                INY
.1a53bb	e2 20		sep #$20	            SEP #$20
.1a53bd	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a53bf	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a53c1	20 d4 12	jsr $1a12d4	            JSR HEAP_GETHED
.1a53c4	20 08 13	jsr $1a1308	            JSR HEAP_REMREF
.1a53c7	e2 20		sep #$20	            SEP #$20
.1a53c9	a5 27		lda $0827	                LDA ARGTYPE1
.1a53cb	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is the new value a string?
.1a53cd	f0 02		beq $1a53d1	                BEQ add_ref             ; Yes: add a reference to it
.1a53cf	80 cd		bra $1a539e	                BRA set_val             ; No: go back to set the value... this probably shouldn't happen
.1a53d1					add_ref
.1a53d1	c2 20		rep #$20	            REP #$20
.1a53d3	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the new string value
.1a53d5	85 c0		sta $08c0	                STA CURRBLOCK
.1a53d7	e2 20		sep #$20	            SEP #$20
.1a53d9	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a53db	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a53dd	20 d4 12	jsr $1a12d4	            JSR HEAP_GETHED
.1a53e0	20 e9 12	jsr $1a12e9	            JSR HEAP_ADDREF
.1a53e3	80 b9		bra $1a539e	                BRA set_val
.1a53e5					VAR_FINDNAME
.1a53e5	08		php		                PHP
.1a53e6	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a53e9	e2 20		sep #$20	            SEP #$20
.1a53eb	a7 00		lda [$0800]	                LDA [BIP]           ; Get the first character
.1a53ed	20 a7 04	jsr $1a04a7	            JSR ISALPHA
.1a53f0	90 42		bcc $1a5434	                BCC not_found
.1a53f2	c2 20		rep #$20	            REP #$20
.1a53f4	a5 00		lda $0800	                LDA BIP
.1a53f6	85 e7		sta $08e7	                STA TOFIND
.1a53f8	e2 20		sep #$20	            SEP #$20
.1a53fa	a5 02		lda $0802	                LDA BIP+2
.1a53fc	85 e9		sta $08e9	                STA TOFIND+2
.1a53fe					loop
.1a53fe	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a5401	a7 00		lda [$0800]	                LDA [BIP]
.1a5403	f0 0d		beq $1a5412	                BEQ is_float        ; If it's EOL, the variable is a float
.1a5405	c9 24		cmp #$24	                CMP #'$'            ; If it's $, the variable is a string
.1a5407	f0 14		beq $1a541d	                BEQ is_string
.1a5409	c9 25		cmp #$25	                CMP #'%'            ; If it's %, the variable is an integer
.1a540b	f0 09		beq $1a5416	                BEQ is_integer
.1a540d	20 12 51	jsr $1a5112	            JSR ISVARCHAR
.1a5410	b0 ec		bcs $1a53fe	                BCS loop            ; Check the next one
.1a5412	a9 01		lda #$01	is_float        LDA #TYPE_FLOAT     ; Otherwise it's a float
.1a5414	80 0c		bra $1a5422	                BRA set_type
.1a5416					is_integer
.1a5416	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a5419	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a541b	80 05		bra $1a5422	                BRA set_type
.1a541d					is_string
.1a541d	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a5420	a9 02		lda #$02	                LDA #TYPE_STRING
.1a5422	85 ea		sta $08ea	set_type        STA TOFINDTYPE
.1a5424	20 43 22	jsr $1a2243	            JSR PEEK_TOK
.1a5427	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it "("?
.1a5429	d0 06		bne $1a5431	                BNE done            ; No: we're done... it's just a scalar variable
.1a542b	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Yes: this is an array reference
.1a542d	09 80		ora #$80	                ORA #$80            ; ... turn on the "Array of..." bit
.1a542f	85 ea		sta $08ea	                STA TOFINDTYPE
.1a5431					done
.1a5431	28		plp		                PLP
.1a5432	38		sec		                SEC
.1a5433	60		rts		            RTS
.1a5434	28		plp		not_found       PLP
.1a5435	18		clc		                CLC
.1a5436	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\integers.s

.1a5437					OP_INT_ADD
.1a5437	08		php		            PHP
.1a5438	c2 20		rep #$20	            REP #$20
.1a543a	18		clc		            CLC
.1a543b	a5 23		lda $0823	            LDA ARGUMENT1
.1a543d	65 29		adc $0829	            ADC ARGUMENT2
.1a543f	85 23		sta $0823	            STA ARGUMENT1
.1a5441	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5443	65 2b		adc $082b	            ADC ARGUMENT2+2
.1a5445	85 25		sta $0825	            STA ARGUMENT1+2
.1a5447	28		plp		            PLP
.1a5448	60		rts		            RTS
.1a5449					OP_INT_SUB
.1a5449	08		php		            PHP
.1a544a	c2 20		rep #$20	            REP #$20
.1a544c	38		sec		            SEC
.1a544d	a5 23		lda $0823	            LDA ARGUMENT1
.1a544f	e5 29		sbc $0829	            SBC ARGUMENT2
.1a5451	85 23		sta $0823	            STA ARGUMENT1
.1a5453	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5455	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.1a5457	85 25		sta $0825	            STA ARGUMENT1+2
.1a5459	28		plp		            PLP
.1a545a	60		rts		            RTS
.1a545b					OP_INT_MUL
.1a545b	08		php		            PHP
.1a545c					locals
>0001					L_SIGN      .word ?
>0003					L_RESULT    .dword ?
>0007					            .dword ?
.1a545c	c2 20		rep #$20	            REP #$20
.1a545e	3b		tsc		            TSC
.1a545f	38		sec		            SEC
.1a5460	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.1a5463	1b		tcs		            TCS
.1a5464	c2 30		rep #$30	            REP #$30
.1a5466	a9 00 00	lda #$0000	            LDA #0                  ; Start by assuming positive numbers
.1a5469	83 01		sta $01,s	            STA L_SIGN
.1a546b	83 03		sta $03,s	            STA L_RESULT            ; Clear result
.1a546d	83 05		sta $05,s	            STA L_RESULT+2
.1a546f	83 07		sta $07,s	            STA L_RESULT+4
.1a5471	83 09		sta $09,s	            STA L_RESULT+6
.1a5473	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Ensure ARGUMENT1 is positive
.1a5475	10 18		bpl $1a548f	            BPL chk_sign2
.1a5477	a9 00 80	lda #$8000	            LDA #$8000              ; Record that ARGUMENT1 is negative
.1a547a	83 01		sta $01,s	            STA L_SIGN
.1a547c	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Take the two's complement of ARGUMENT1
.1a547e	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a5481	85 25		sta $0825	            STA ARGUMENT1+2
.1a5483	a5 23		lda $0823	            LDA ARGUMENT1
.1a5485	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a5488	1a		inc a		            INC A
.1a5489	85 23		sta $0823	            STA ARGUMENT1
.1a548b	d0 02		bne $1a548f	            BNE chk_sign2
.1a548d	e6 25		inc $0825	            INC ARGUMENT1+2
.1a548f	a5 2b		lda $082b	chk_sign2   LDA ARGUMENT2+2         ; Ensure ARGUMENT2 is positive
.1a5491	10 1a		bpl $1a54ad	            BPL chk_over
.1a5493	a3 01		lda $01,s	            LDA L_SIGN              ; Flip the sign
.1a5495	49 00 80	eor #$8000	            EOR #$8000
.1a5498	83 01		sta $01,s	            STA L_SIGN
.1a549a	a5 2b		lda $082b	            LDA ARGUMENT2+2         ; Take the two's complement of ARGUMENT2
.1a549c	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a549f	85 2b		sta $082b	            STA ARGUMENT2+2
.1a54a1	a5 29		lda $0829	            LDA ARGUMENT2
.1a54a3	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a54a6	1a		inc a		            INC A
.1a54a7	85 29		sta $0829	            STA ARGUMENT2
.1a54a9	d0 02		bne $1a54ad	            BNE chk_over
.1a54ab	e6 2b		inc $082b	            INC ARGUMENT2+2
.1a54ad					chk_over
.1a54ad	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a54af	f0 04		beq $1a54b5	            BEQ do_mult
.1a54b1	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a54b3	d0 5a		bne $1a550f	            BNE overflow
.1a54b5					do_mult
.1a54b5	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*D
.1a54b7	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.1a54bb	a5 29		lda $0829	            LDA ARGUMENT2
.1a54bd	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.1a54c1	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.1a54c5	83 03		sta $03,s	            STA L_RESULT
.1a54c7	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.1a54cb	83 05		sta $05,s	            STA L_RESULT+2
.1a54cd	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Calculate A*D << 16 + B*D
.1a54cf	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.1a54d3	a5 29		lda $0829	            LDA ARGUMENT2
.1a54d5	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.1a54d9	18		clc		            CLC
.1a54da	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.1a54de	63 05		adc $05,s	            ADC L_RESULT+2
.1a54e0	83 05		sta $05,s	            STA L_RESULT+2
.1a54e2	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.1a54e6	63 07		adc $07,s	            ADC L_RESULT+4
.1a54e8	83 07		sta $07,s	            STA L_RESULT+4
.1a54ea	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*C << 16 + A*D << 16 + B*D
.1a54ec	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.1a54f0	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a54f2	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.1a54f6	18		clc		            CLC
.1a54f7	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.1a54fb	63 05		adc $05,s	            ADC L_RESULT+2
.1a54fd	83 05		sta $05,s	            STA L_RESULT+2
.1a54ff	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.1a5503	63 07		adc $07,s	            ADC L_RESULT+4
.1a5505	83 07		sta $07,s	            STA L_RESULT+4
.1a5507	a3 07		lda $07,s	            LDA L_RESULT+4
.1a5509	f0 23		beq $1a552e	            BEQ no_overflow
.1a550b	a3 09		lda $09,s	            LDA L_RESULT+6
.1a550d	f0 1f		beq $1a552e	            BEQ no_overflow
.1a550f					overflow
.1a550f	08		php		            PHP
.1a5510	c2 20		rep #$20	            REP #$20
.1a5512	48		pha		            PHA
.1a5513	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5516	5b		tcd		            TCD
.1a5517	68		pla		            PLA
.1a5518	28		plp		            PLP
.1a5519	e2 20		sep #$20	            SEP #$20
.1a551b	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.1a551d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5521	c2 20		rep #$20	            REP #$20
.1a5523	29 ff 00	and #$00ff	            AND #$00FF
.1a5526	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a5529	e2 20		sep #$20	            SEP #$20
.1a552b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a552e					no_overflow
.1a552e	c2 30		rep #$30	            REP #$30
.1a5530	a3 01		lda $01,s	            LDA L_SIGN              ; Check the sign
.1a5532	10 16		bpl $1a554a	            BPL ret_result          ; If positive: just return the result
.1a5534	a3 05		lda $05,s	            LDA L_RESULT+2          ; Compute the two's complement of the result
.1a5536	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a5539	83 05		sta $05,s	            STA L_RESULT+2
.1a553b	a3 03		lda $03,s	            LDA L_RESULT
.1a553d	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a5540	1a		inc a		            INC A
.1a5541	83 03		sta $03,s	            STA L_RESULT
.1a5543	d0 05		bne $1a554a	            BNE ret_result
.1a5545	a3 05		lda $05,s	            LDA L_RESULT+2
.1a5547	1a		inc a		            INC A
.1a5548	83 05		sta $05,s	            STA L_RESULT+2
.1a554a					ret_result
.1a554a	a3 03		lda $03,s	            LDA L_RESULT
.1a554c	85 23		sta $0823	            STA ARGUMENT1
.1a554e	a3 05		lda $05,s	            LDA L_RESULT+2
.1a5550	85 25		sta $0825	            STA ARGUMENT1+2
.1a5552	c2 20		rep #$20	            REP #$20
.1a5554	3b		tsc		            TSC
.1a5555	18		clc		            CLC
.1a5556	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.1a5559	1b		tcs		            TCS
.1a555a	28		plp		            PLP
.1a555b	60		rts		            RTS
.1a555c					OP_INT_LT
.1a555c	08		php		            PHP
.1a555d	c2 20		rep #$20	            REP #$20
.1a555f	a5 23		lda $0823	            LDA ARGUMENT1
.1a5561	c5 29		cmp $0829	            CMP ARGUMENT2
.1a5563	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5565	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.1a5567	50 03		bvc $1a556c	            BVC skip_eor
.1a5569	49 00 80	eor #$8000	            EOR #$8000
.1a556c	30 06		bmi $1a5574	skip_eor    BMI ret_true
.1a556e	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a5570	64 25		stz $0825	            STZ ARGUMENT1+2
.1a5572	80 07		bra $1a557b	            BRA done
.1a5574	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a5577	85 23		sta $0823	            STA ARGUMENT1
.1a5579	85 25		sta $0825	            STA ARGUMENT1+2
.1a557b	28		plp		done        PLP
.1a557c	60		rts		            RTS
.1a557d					OP_INT_GT
.1a557d	08		php		            PHP
.1a557e	c2 20		rep #$20	            REP #$20
.1a5580	a5 23		lda $0823	            LDA ARGUMENT1
.1a5582	c5 29		cmp $0829	            CMP ARGUMENT2
.1a5584	d0 0c		bne $1a5592	            BNE test_fully
.1a5586	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5588	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.1a558a	d0 06		bne $1a5592	            BNE test_fully
.1a558c	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a558e	64 25		stz $0825	            STZ ARGUMENT1+2
.1a5590	80 16		bra $1a55a8	            BRA done
.1a5592	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.1a5594	c5 23		cmp $0823	            CMP ARGUMENT1
.1a5596	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a5598	e5 25		sbc $0825	            SBC ARGUMENT1+2
.1a559a	50 03		bvc $1a559f	            BVC skip_eor
.1a559c	49 00 80	eor #$8000	            EOR #$8000
.1a559f	10 eb		bpl $1a558c	skip_eor    BPL ret_false
.1a55a1	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a55a4	85 23		sta $0823	            STA ARGUMENT1
.1a55a6	85 25		sta $0825	            STA ARGUMENT1+2
.1a55a8	28		plp		done        PLP
.1a55a9	60		rts		            RTS
.1a55aa					OP_INT_EQ
.1a55aa	08		php		            PHP
.1a55ab	c2 20		rep #$20	            REP #$20
.1a55ad	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a55af	c5 25		cmp $0825	            CMP ARGUMENT1+2
.1a55b1	d0 0f		bne $1a55c2	            BNE ret_false
.1a55b3	a5 29		lda $0829	            LDA ARGUMENT2
.1a55b5	c5 23		cmp $0823	            CMP ARGUMENT1
.1a55b7	d0 09		bne $1a55c2	            BNE ret_false
.1a55b9	a9 ff ff	lda #$ffff	            LDA #$FFFF
.1a55bc	85 23		sta $0823	            STA ARGUMENT1
.1a55be	85 25		sta $0825	            STA ARGUMENT1+2
.1a55c0	80 04		bra $1a55c6	            BRA done
.1a55c2	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a55c4	64 25		stz $0825	            STZ ARGUMENT1+2
.1a55c6	28		plp		done        PLP
.1a55c7	60		rts		            RTS
.1a55c8					OP_INT_NE
.1a55c8	08		php		            PHP
.1a55c9	c2 20		rep #$20	            REP #$20
.1a55cb	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a55cd	c5 25		cmp $0825	            CMP ARGUMENT1+2
.1a55cf	d0 0c		bne $1a55dd	            BNE ret_true
.1a55d1	a5 29		lda $0829	            LDA ARGUMENT2
.1a55d3	c5 23		cmp $0823	            CMP ARGUMENT1
.1a55d5	d0 06		bne $1a55dd	            BNE ret_true
.1a55d7	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a55d9	64 25		stz $0825	            STZ ARGUMENT1+2
.1a55db	80 07		bra $1a55e4	            BRA done
.1a55dd	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a55e0	85 23		sta $0823	            STA ARGUMENT1
.1a55e2	85 25		sta $0825	            STA ARGUMENT1+2
.1a55e4	28		plp		done        PLP
.1a55e5	60		rts		            RTS
.1a55e6					OP_INT_GTE
.1a55e6	08		php		            PHP
.1a55e7	c2 20		rep #$20	            REP #$20
.1a55e9	a5 23		lda $0823	            LDA ARGUMENT1
.1a55eb	c5 29		cmp $0829	            CMP ARGUMENT2
.1a55ed	d0 0f		bne $1a55fe	            BNE test_fully
.1a55ef	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a55f1	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.1a55f3	d0 09		bne $1a55fe	            BNE test_fully
.1a55f5	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a55f8	85 23		sta $0823	            STA ARGUMENT1
.1a55fa	85 25		sta $0825	            STA ARGUMENT1+2
.1a55fc	80 13		bra $1a5611	            BRA done
.1a55fe	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.1a5600	c5 23		cmp $0823	            CMP ARGUMENT1
.1a5602	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a5604	e5 25		sbc $0825	            SBC ARGUMENT1+2
.1a5606	50 03		bvc $1a560b	            BVC skip_eor
.1a5608	49 00 80	eor #$8000	            EOR #$8000
.1a560b	30 e8		bmi $1a55f5	skip_eor    BMI ret_true
.1a560d	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a560f	64 25		stz $0825	            STZ ARGUMENT1+2
.1a5611	28		plp		done        PLP
.1a5612	60		rts		            RTS
.1a5613					OP_INT_LTE
.1a5613	08		php		            PHP
.1a5614	c2 20		rep #$20	            REP #$20
.1a5616	a5 23		lda $0823	            LDA ARGUMENT1
.1a5618	c5 29		cmp $0829	            CMP ARGUMENT2
.1a561a	d0 0f		bne $1a562b	            BNE test_fully
.1a561c	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a561e	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.1a5620	d0 09		bne $1a562b	            BNE test_fully
.1a5622	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a5625	85 23		sta $0823	            STA ARGUMENT1
.1a5627	85 25		sta $0825	            STA ARGUMENT1+2
.1a5629	80 13		bra $1a563e	            BRA done
.1a562b	a5 23		lda $0823	test_fully  LDA ARGUMENT1
.1a562d	c5 29		cmp $0829	            CMP ARGUMENT2
.1a562f	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5631	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.1a5633	50 03		bvc $1a5638	            BVC skip_eor
.1a5635	49 00 80	eor #$8000	            EOR #$8000
.1a5638	30 e8		bmi $1a5622	skip_eor    BMI ret_true
.1a563a	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a563c	64 25		stz $0825	            STZ ARGUMENT1+2
.1a563e	28		plp		done        PLP
.1a563f	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\floats.s


;******  Processing file: src\C256/floats.s


;******  Processing file: src\C256/fp_math_defs.s

=$afe200				FP_MATH_CTRL0 = $AFE200         ; Read/write
=$08					FP_MATH_CTRL0_ADD = $08         ; 0: Substraction - 1: Addition
=$01					FP_CTRL0_CONV_0 = %00000001     ; Input 0 should be converted from 24.12 fixed point to floating point
=$02					FP_CTRL0_CONV_1 = %00000010     ; Input 1 should be converted from 24.12 fixed point to floating point
=$00					FP_ADD_IN0_MUX0 = %00000000     ; Adder input #0 is the output of MUX0
=$10					FP_ADD_IN0_MUX1 = %00010000     ; Adder input #0 is the output of MUX1
=$20					FP_ADD_IN0_MULT = %00100000     ; Adder input #0 is the output of the multiplier
=$30					FP_ADD_IN0_DIV  = %00110000     ; Adder input #0 is the output of the divider
=$00					FP_ADD_IN1_MUX0 = %00000000     ; Adder input #1 is the output of MUX0
=$40					FP_ADD_IN1_MUX1 = %01000000     ; Adder input #1 is the output of MUX1
=$80					FP_ADD_IN1_MULT = %10000000     ; Adder input #1 is the output of the multiplier
=$c0					FP_ADD_IN1_DIV  = %11000000     ; Adder input #1 is the output of the divider
=$afe201				FP_MATH_CTRL1 = $AFE201
=$00					FP_OUT_MULT = %00000000         ; Output is from the multiplier
=$01					FP_OUT_DIV  = %00000001         ; Output is from the divider
=$02					FP_OUT_ADD  = %00000010         ; Output is from the adder/subtracter
=$03					FP_OUT_ONE  = %00000011         ; Output is the constant '1.0'
=$afe202				FP_MATH_CTRL2 = $AFE202         ; Not Used - Reserved
=$afe203				FP_MATH_CTRL3 = $AFE203         ; Not Used - Reserved
=$afe204				FP_MATH_MULT_STAT = $AFE204     ; Status of the multiplier
=$01					FP_MULT_STAT_NAN  = $01         ; (NAN) Not a Number Status
=$02					FP_MULT_STAT_OVF  = $02         ; Overflow
=$04					FP_MULT_STAT_UDF  = $04         ; Underflow
=$08					FP_MULT_STAT_ZERO = $08         ; Zero
=$afe205				FP_MATH_DIV_STAT  = $AFE205     ; Status of the divider
=$01					FP_DIV_STAT_NAN       = $01     ; Not a number Status
=$02					FP_DIV_STAT_OVF       = $02     ; Overflow
=$04					FP_DIV_STAT_UDF       = $04     ; Underflow
=$08					FP_DIV_STAT_ZERO      = $08     ; Zero
=$10					FP_DIV_STAT_DIVBYZERO = $10     ; Division by Zero
=$afe206				FP_MATH_ADD_STAT  = $AFE206     ; Status of the adder/subtracter
=$01					FP_ADD_STAT_NAN  = $01          ; Not a number Status
=$02					FP_ADD_STAT_OVF  = $02          ; Overflow
=$04					FP_ADD_STAT_UDF  = $04          ; Underflow
=$08					FP_ADD_STAT_ZERO = $08          ; Zero
=$afe207				FP_MATH_CONV_STAT = $AFE207     ; Status of the fixed <=> float converters
=$01					FP_CONV_STAT_NAN  = $01         ; Not a number Status
=$02					FP_CONV_STAT_OVF  = $02         ; Overflow
=$04					FP_CONV_STAT_UDF  = $04         ; Underflow
=$afe208				FP_MATH_INPUT0_LL = $AFE208
=$afe209				FP_MATH_INPUT0_LH = $AFE209
=$afe20a				FP_MATH_INPUT0_HL = $AFE20A
=$afe20b				FP_MATH_INPUT0_HH = $AFE20B
=$afe20c				FP_MATH_INPUT1_LL = $AFE20C
=$afe20d				FP_MATH_INPUT1_LH = $AFE20D
=$afe20e				FP_MATH_INPUT1_HL = $AFE20E
=$afe20f				FP_MATH_INPUT1_HH = $AFE20F
=$afe208				FP_MATH_OUTPUT_FP_LL = $AFE208
=$afe209				FP_MATH_OUTPUT_FP_LH = $AFE209
=$afe20a				FP_MATH_OUTPUT_FP_HL = $AFE20A
=$afe20b				FP_MATH_OUTPUT_FP_HH = $AFE20B
=$afe20c				FP_MATH_OUTPUT_FIXED_LL = $AFE20C
=$afe20d				FP_MATH_OUTPUT_FIXED_LH = $AFE20D
=$afe20e				FP_MATH_OUTPUT_FIXED_HL = $AFE20E
=$afe20f				FP_MATH_OUTPUT_FIXED_HH = $AFE20F

;******  Return to file: src\C256/floats.s


;******  Processing file: src\C256/math_cop.s

.1a5640					UINT_DIV_A_X
.1a5640	08		php		                    PHP
.1a5641	c2 20		rep #$20	            REP #$20
.1a5643	8f 12 01 00	sta $000112	                    STA @l UNSIGNED_DIV_NUM_LO
.1a5647	8a		txa		                    TXA
.1a5648	8f 10 01 00	sta $000110	                    STA @l UNSIGNED_DIV_DEM_LO
.1a564c	af 16 01 00	lda $000116	                    LDA @l UNSIGNED_DIV_REM_LO
.1a5650	aa		tax		                    TAX
.1a5651	af 14 01 00	lda $000114	                    LDA @l UNSIGNED_DIV_QUO_LO
.1a5655	28		plp		                    PLP
.1a5656	60		rts		            RTS

;******  Return to file: src\C256/floats.s

.1a5657					FIXINT_TO_FP
.1a5657	08		php		                    PHP
.1a5658	e2 20		sep #$20	            SEP #$20
.1a565a	a9 03		lda #$03	                    LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.1a565c	8f 00 e2 af	sta $afe200	                    STA @l FP_MATH_CTRL0
.1a5660	a9 00		lda #$00	                    LDA #FP_OUT_MULT
.1a5662	8f 01 e2 af	sta $afe201	                    STA @l FP_MATH_CTRL1
.1a5666	c2 20		rep #$20	            REP #$20
.1a5668	a5 23		lda $0823	                    LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a566a	8f 08 e2 af	sta $afe208	                    STA @l FP_MATH_INPUT0_LL
.1a566e	a5 25		lda $0825	                    LDA ARGUMENT1+2
.1a5670	8f 0a e2 af	sta $afe20a	                    STA @l FP_MATH_INPUT0_HL
.1a5674	a9 00 00	lda #$0000	                    LDA #0
.1a5677	8f 0c e2 af	sta $afe20c	                    STA @l FP_MATH_INPUT1_LL    ; ARGUMENT2 = 0100 0000 = 4096 in 20:12
.1a567b	a9 00 01	lda #$0100	                    LDA #$0100
.1a567e	8f 0e e2 af	sta $afe20e	                    STA @l FP_MATH_INPUT1_HL
.1a5682	ea		nop		                    NOP
.1a5683	ea		nop		                    NOP
.1a5684	ea		nop		                    NOP
.1a5685	ea		nop		                    NOP
.1a5686	ea		nop		                    NOP
.1a5687	ea		nop		                    NOP
.1a5688	af 08 e2 af	lda $afe208	                    LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.1a568c	85 23		sta $0823	                    STA ARGUMENT1
.1a568e	af 0a e2 af	lda $afe20a	                    LDA @l FP_MATH_OUTPUT_FP_HL
.1a5692	85 25		sta $0825	                    STA ARGUMENT1+2
.1a5694	a9 01 00	lda #$0001	                    LDA #TYPE_FLOAT
.1a5697	85 27		sta $0827	                    STA ARGTYPE1
.1a5699	28		plp		                    PLP
.1a569a	60		rts		            RTS
.1a569b	08		php		OP_FP_SUB       PHP
.1a569c	e2 20		sep #$20	            SEP #$20
.1a569e	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a56a0	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a56a4	80 09		bra $1a56af	                BRA FP_ADD_SUB
.1a56a6	08		php		OP_FP_ADD       PHP
.1a56a7	e2 20		sep #$20	            SEP #$20
.1a56a9	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a56ab	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a56af	a9 02		lda #$02	FP_ADD_SUB      LDA #FP_OUT_ADD
.1a56b1	8f 01 e2 af	sta $afe201	                STA @lFP_MATH_CTRL1
.1a56b5	c2 20		rep #$20	            REP #$20
.1a56b7	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a56b9	8f 08 e2 af	sta $afe208	                STA @lFP_MATH_INPUT0_LL
.1a56bd	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a56bf	8f 0a e2 af	sta $afe20a	                STA @lFP_MATH_INPUT0_HL
.1a56c3	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.1a56c5	8f 0c e2 af	sta $afe20c	                STA @lFP_MATH_INPUT1_LL
.1a56c9	a5 2b		lda $082b	                LDA ARGUMENT2+2
.1a56cb	8f 0e e2 af	sta $afe20e	                STA @lFP_MATH_INPUT1_HL
.1a56cf	ea		nop		                NOP
.1a56d0	ea		nop		                NOP
.1a56d1	ea		nop		                NOP
.1a56d2	e2 20		sep #$20	            SEP #$20
.1a56d4	af 06 e2 af	lda $afe206	                LDA @lFP_MATH_ADD_STAT      ; Check the status of the addition
.1a56d8	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.1a56da	d0 10		bne $1a56ec	                BNE fp_add_error            ; If an issue was raise, process the math error
.1a56dc	c2 20		rep #$20	            REP #$20
.1a56de	af 08 e2 af	lda $afe208	                LDA @lFP_MATH_OUTPUT_FP_LL  ; Retrieve the results into ARGUMENT1
.1a56e2	85 23		sta $0823	                STA ARGUMENT1
.1a56e4	af 0a e2 af	lda $afe20a	                LDA @lFP_MATH_OUTPUT_FP_HL
.1a56e8	85 25		sta $0825	                STA ARGUMENT1+2
.1a56ea	28		plp		fp_add_done     PLP
.1a56eb	60		rts		            RTS
.1a56ec					fp_add_error
.1a56ec	20 87 57	jsr $1a5787	            JSR FP_MATH_ERROR
.1a56ef	80 f9		bra $1a56ea	                BRA fp_add_done
.1a56f1	08		php		OP_FP_DIV       PHP
.1a56f2	e2 20		sep #$20	            SEP #$20
.1a56f4	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a56f6	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a56fa	a9 00		lda #$00	                LDA #0
.1a56fc	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a5700	c2 20		rep #$20	            REP #$20
.1a5702	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a5704	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5708	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a570a	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a570e	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.1a5710	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5714	a5 2b		lda $082b	                LDA ARGUMENT2+2
.1a5716	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a571a	ea		nop		                NOP
.1a571b	ea		nop		                NOP
.1a571c	ea		nop		                NOP
.1a571d	e2 20		sep #$20	            SEP #$20
.1a571f	af 05 e2 af	lda $afe205	                LDA @l FP_MATH_DIV_STAT     ; Check the status of the addition
.1a5723	29 17		and #$17	                AND #%00010111              ; Filter out the ZERO status
.1a5725	d0 10		bne $1a5737	                BNE fp_div_error            ; If an issue was raise, process the math error
.1a5727	c2 20		rep #$20	            REP #$20
.1a5729	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.1a572d	85 23		sta $0823	                STA ARGUMENT1
.1a572f	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5733	85 25		sta $0825	                STA ARGUMENT1+2
.1a5735	28		plp		fp_div_done     PLP
.1a5736	60		rts		            RTS
.1a5737					fp_div_error
.1a5737	20 87 57	jsr $1a5787	            JSR FP_MATH_ERROR
.1a573a	80 f9		bra $1a5735	                BRA fp_div_done
.1a573c	08		php		OP_FP_MUL       PHP
.1a573d	e2 20		sep #$20	            SEP #$20
.1a573f	a9 00		lda #$00	                LDA #FP_OUT_MULT
.1a5741	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5745	a9 00		lda #$00	                LDA #0
.1a5747	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a574b	c2 20		rep #$20	            REP #$20
.1a574d	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a574f	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5753	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5755	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5759	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.1a575b	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a575f	a5 2b		lda $082b	                LDA ARGUMENT2+2
.1a5761	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5765	ea		nop		                NOP
.1a5766	ea		nop		                NOP
.1a5767	ea		nop		                NOP
.1a5768	e2 20		sep #$20	            SEP #$20
.1a576a	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT    ; Check the status of the addition
.1a576e	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.1a5770	d0 10		bne $1a5782	                BNE fp_mul_error            ; If an issue was raise, process the math error
.1a5772	c2 20		rep #$20	            REP #$20
.1a5774	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.1a5778	85 23		sta $0823	                STA ARGUMENT1
.1a577a	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a577e	85 25		sta $0825	                STA ARGUMENT1+2
.1a5780	28		plp		fp_mul_done     PLP
.1a5781	60		rts		            RTS
.1a5782					fp_mul_error
.1a5782	20 87 57	jsr $1a5787	            JSR FP_MATH_ERROR
.1a5785	80 f9		bra $1a5780	                BRA fp_mul_done
.1a5787					FP_MATH_ERROR
.1a5787	e2 20		sep #$20	            SEP #$20
.1a5789	89 01		bit #$01	                BIT #FP_ADD_STAT_NAN        ; Is there a NaN condition?
.1a578b	f0 20		beq $1a57ad	                BEQ check_over              ; No: check for overflow
.1a578d	00		brk #		                BRK
.1a578e	08		php		            PHP
.1a578f	c2 20		rep #$20	            REP #$20
.1a5791	48		pha		            PHA
.1a5792	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5795	5b		tcd		            TCD
.1a5796	68		pla		            PLA
.1a5797	28		plp		            PLP
.1a5798	e2 20		sep #$20	            SEP #$20
.1a579a	a9 0c		lda #$0c	            LDA #ERR_NAN
.1a579c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a57a0	c2 20		rep #$20	            REP #$20
.1a57a2	29 ff 00	and #$00ff	            AND #$00FF
.1a57a5	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a57a8	e2 20		sep #$20	            SEP #$20
.1a57aa	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a57ad	89 02		bit #$02	check_over      BIT #FP_ADD_STAT_OVF        ; Is ther an overflow condition?
.1a57af	f0 1f		beq $1a57d0	                BEQ check_under             ; No: check for underflow
.1a57b1	08		php		            PHP
.1a57b2	c2 20		rep #$20	            REP #$20
.1a57b4	48		pha		            PHA
.1a57b5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a57b8	5b		tcd		            TCD
.1a57b9	68		pla		            PLA
.1a57ba	28		plp		            PLP
.1a57bb	e2 20		sep #$20	            SEP #$20
.1a57bd	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.1a57bf	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a57c3	c2 20		rep #$20	            REP #$20
.1a57c5	29 ff 00	and #$00ff	            AND #$00FF
.1a57c8	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a57cb	e2 20		sep #$20	            SEP #$20
.1a57cd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a57d0	89 04		bit #$04	check_under     BIT #FP_ADD_STAT_UDF        ; Is there an underflow condition?
.1a57d2	f0 1f		beq $1a57f3	                BEQ done                    ; No: we should just return... this probably shouldn't happen
.1a57d4	08		php		            PHP
.1a57d5	c2 20		rep #$20	            REP #$20
.1a57d7	48		pha		            PHA
.1a57d8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a57db	5b		tcd		            TCD
.1a57dc	68		pla		            PLA
.1a57dd	28		plp		            PLP
.1a57de	e2 20		sep #$20	            SEP #$20
.1a57e0	a9 0e		lda #$0e	            LDA #ERR_UNDERFLOW
.1a57e2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a57e6	c2 20		rep #$20	            REP #$20
.1a57e8	29 ff 00	and #$00ff	            AND #$00FF
.1a57eb	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a57ee	e2 20		sep #$20	            SEP #$20
.1a57f0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a57f3					done
.1a57f3	60		rts		            RTS
.1a57f4					FP_MUL10
.1a57f4	08		php		                PHP
.1a57f5	e2 20		sep #$20	            SEP #$20
.1a57f7	a9 00		lda #$00	                LDA #FP_OUT_MULT                ; Set for multiplication
.1a57f9	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a57fd	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1            ; Input 1 is fixed point
.1a57ff	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5803	c2 20		rep #$20	            REP #$20
.1a5805	a9 00 a0	lda #$a000	                LDA #$A000                      ; 10 is one factor
.1a5808	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a580c	a9 00 00	lda #$0000	                LDA #0
.1a580f	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5813	a5 23		lda $0823	                LDA ARGUMENT1                   ; N is the other
.1a5815	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5819	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a581b	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a581f	ea		nop		                NOP
.1a5820	ea		nop		                NOP
.1a5821	ea		nop		                NOP
.1a5822	e2 20		sep #$20	            SEP #$20
.1a5824	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT        ; Check the status
.1a5828	89 07		bit #$07	                BIT #FP_MULT_STAT_NAN | FP_MULT_STAT_OVF | FP_MULT_STAT_UDF
.1a582a	f0 01		beq $1a582d	                BEQ ret_result
.1a582c	00		brk #		                BRK                             ; There was an error...
.1a582d					ret_result
.1a582d	c2 20		rep #$20	            REP #$20
.1a582f	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL     ; Save result back
.1a5833	85 23		sta $0823	                STA ARGUMENT1
.1a5835	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5839	85 25		sta $0825	                STA ARGUMENT1+2
.1a583b	28		plp		                PLP
.1a583c	60		rts		            RTS
.1a583d					FP_DIV10
.1a583d	08		php		                PHP
.1a583e	e2 20		sep #$20	            SEP #$20
.1a5840	a9 01		lda #$01	                LDA #FP_OUT_DIV             ; Set for multiplication
.1a5842	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5846	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1        ; Input 1 is fixed point
.1a5848	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a584c	c2 20		rep #$20	            REP #$20
.1a584e	a9 00 a0	lda #$a000	                LDA #$A000                  ; 10 is one factor
.1a5851	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5855	a9 00 00	lda #$0000	                LDA #0
.1a5858	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a585c	a5 23		lda $0823	                LDA ARGUMENT1               ; N is the other
.1a585e	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5862	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5864	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5868	ea		nop		                NOP
.1a5869	ea		nop		                NOP
.1a586a	ea		nop		                NOP
.1a586b	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Save result back
.1a586f	85 23		sta $0823	                STA ARGUMENT1
.1a5871	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5875	85 25		sta $0825	                STA ARGUMENT1+2
.1a5877	28		plp		                PLP
.1a5878	60		rts		            RTS

;******  Return to file: src\floats.s

.1a5879					FARG1EQ0
.1a5879	08		php		                PHP
.1a587a	c2 20		rep #$20	            REP #$20
.1a587c	a5 23		lda $0823	                LDA ARGUMENT1
.1a587e	d0 0a		bne $1a588a	                BNE return_false
.1a5880	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5882	29 ff 7f	and #$7fff	                AND #$7FFF              ; Mask off the sign bit
.1a5885	d0 03		bne $1a588a	                BNE return_false
.1a5887	28		plp		return_true     PLP
.1a5888	38		sec		                SEC
.1a5889	60		rts		            RTS
.1a588a	28		plp		return_false    PLP
.1a588b	18		clc		                CLC
.1a588c	60		rts		            RTS
.1a588d					SHIFTDEC
.1a588d	08		php		                PHP
.1a588e	e2 20		sep #$20	            SEP #$20
.1a5890	38		sec		                SEC                     ; Convert '0'..'9' to it's number
.1a5891	e9 30		sbc #$30	                SBC #'0'
.1a5893	20 3f 05	jsr $1a053f	            JSR MULINT10
.1a5896	c2 20		rep #$20	            REP #$20
.1a5898	29 ff 00	and #$00ff	                AND #$00FF              ; Add the number to ARGUMENT1
.1a589b	18		clc		                CLC
.1a589c	65 23		adc $0823	                ADC ARGUMENT1
.1a589e	85 23		sta $0823	                STA ARGUMENT1
.1a58a0	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a58a2	69 00 00	adc #$0000	                ADC #0
.1a58a5	85 25		sta $0825	                STA ARGUMENT1+2
.1a58a7	28		plp		                PLP
.1a58a8	60		rts		            RTS
.1a58a9					SHIFTHEX
.1a58a9	08		php		                PHP
.1a58aa	e2 20		sep #$20	            SEP #$20
.1a58ac	c9 30		cmp #$30	                CMP #'0'                ; Process 0-9
.1a58ae	90 04		bcc $1a58b4	                BLT not_09
.1a58b0	c9 3a		cmp #$3a	                CMP #'9'+1
.1a58b2	90 1c		bcc $1a58d0	                BLT is_09
.1a58b4	c9 61		cmp #$61	not_09          CMP #'a'                ; Process lowercase A-F
.1a58b6	90 04		bcc $1a58bc	                BLT not_lc
.1a58b8	c9 67		cmp #$67	                CMP #'f'+1
.1a58ba	90 0a		bcc $1a58c6	                BLT is_lc
.1a58bc	c9 41		cmp #$41	not_lc          CMP #'A'                ; Process uppercase A-F
.1a58be	90 04		bcc $1a58c4	                BLT not_uc
.1a58c0	c9 47		cmp #$47	                CMP #'F'+1
.1a58c2	90 07		bcc $1a58cb	                BLT is_uc
.1a58c4	80 31		bra $1a58f7	not_uc          BRA done                ; Just return if we couldn't convert... this shouldn't happen
.1a58c6	38		sec		is_lc           SEC                     ; Convert 'a'-'f' to the actual number
.1a58c7	e9 57		sbc #$57	                SBC #'a'-10
.1a58c9	80 08		bra $1a58d3	                BRA shift
.1a58cb	38		sec		is_uc           SEC                     ; Convert 'A'-'F' to the actual number
.1a58cc	e9 37		sbc #$37	                SBC #'A'-10
.1a58ce	80 03		bra $1a58d3	                BRA shift
.1a58d0	38		sec		is_09           SEC                     ; Convert '0'-'9' to the actual number
.1a58d1	e9 30		sbc #$30	                SBC #'0'
.1a58d3					shift
.1a58d3	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a58d5	26 24		rol $0824	                ROL ARGUMENT1+1
.1a58d7	26 25		rol $0825	                ROL ARGUMENT1+2
.1a58d9	26 26		rol $0826	                ROL ARGUMENT1+3
.1a58db	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a58dd	26 24		rol $0824	                ROL ARGUMENT1+1
.1a58df	26 25		rol $0825	                ROL ARGUMENT1+2
.1a58e1	26 26		rol $0826	                ROL ARGUMENT1+3
.1a58e3	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a58e5	26 24		rol $0824	                ROL ARGUMENT1+1
.1a58e7	26 25		rol $0825	                ROL ARGUMENT1+2
.1a58e9	26 26		rol $0826	                ROL ARGUMENT1+3
.1a58eb	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a58ed	26 24		rol $0824	                ROL ARGUMENT1+1
.1a58ef	26 25		rol $0825	                ROL ARGUMENT1+2
.1a58f1	26 26		rol $0826	                ROL ARGUMENT1+3
.1a58f3	05 23		ora $0823	                ORA ARGUMENT1           ; Add the number to it
.1a58f5	85 23		sta $0823	                STA ARGUMENT1
.1a58f7	28		plp		done            PLP
.1a58f8	60		rts		            RTS
.1a58f9					SHIFTBIN
.1a58f9	08		php		                PHP
.1a58fa	e2 20		sep #$20	            SEP #$20
.1a58fc	c9 30		cmp #$30	                CMP #'0'                ; If the character is '0'...
.1a58fe	f0 06		beq $1a5906	                BEQ shift_0             ; Shift a 0 onto ARGUMENT1
.1a5900	c9 31		cmp #$31	                CMP #'1'                ; If the character is '1'...
.1a5902	f0 0a		beq $1a590e	                BEQ shift_1             ; Shift a 1 onto ARGUMENT1
.1a5904	80 0f		bra $1a5915	                BRA done
.1a5906					shift_0
.1a5906	c2 20		rep #$20	            REP #$20
.1a5908	06 23		asl $0823	                ASL ARGUMENT1
.1a590a	26 25		rol $0825	                ROL ARGUMENT1+2
.1a590c	80 07		bra $1a5915	                BRA done
.1a590e					shift_1
.1a590e	c2 20		rep #$20	            REP #$20
.1a5910	38		sec		                SEC
.1a5911	26 23		rol $0823	                ROL ARGUMENT1
.1a5913	26 25		rol $0825	                ROL ARGUMENT1+2
.1a5915	28		plp		done            PLP
.1a5916	60		rts		            RTS
.1a5917					FP_POW10
.1a5917	08		php		                PHP
.1a5918	e2 30		sep #$30	            SEP #$30
.1a591a	a5 61		lda $0861	                LDA MARG4
.1a591c	f0 0d		beq $1a592b	                BEQ return_1
.1a591e	aa		tax		                TAX
.1a591f	a5 69		lda $0869	                LDA MARG6
.1a5921	d0 15		bne $1a5938	                BNE do_div
.1a5923	a9 00		lda #$00	                LDA #FP_OUT_MULT                    ; We'll multiply
.1a5925	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5929	80 15		bra $1a5940	                BRA start_loop
.1a592b					return_1
.1a592b	e2 20		sep #$20	            SEP #$20
.1a592d	a9 03		lda #$03	                LDA #FP_OUT_ONE                     ; We want to return a 1.0
.1a592f	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5933	ea		nop		                NOP
.1a5934	ea		nop		                NOP
.1a5935	ea		nop		                NOP
.1a5936	80 62		bra $1a599a	                BRA ret_result                      ; And return the result
.1a5938					do_div
.1a5938	e2 20		sep #$20	            SEP #$20
.1a593a	a9 01		lda #$01	                LDA #FP_OUT_DIV                     ; We'll divide
.1a593c	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5940					start_loop
.1a5940	e2 20		sep #$20	            SEP #$20
.1a5942	a9 43		lda #$43	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.1a5944	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.1a5948	c2 20		rep #$20	            REP #$20
.1a594a	a9 00 10	lda #$1000	                LDA #$1000                          ; Input 0 = 1.0
.1a594d	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5951	a9 00 00	lda #$0000	                LDA #0
.1a5954	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5958					loop
.1a5958	c2 20		rep #$20	            REP #$20
.1a595a	a9 00 a0	lda #$a000	                LDA #$A000                          ; Input 1 = 10.0
.1a595d	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5961	a9 00 00	lda #$0000	                LDA #0
.1a5964	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5968	ea		nop		                NOP                                 ; Wait for the operation to complete
.1a5969	ea		nop		                NOP
.1a596a	ea		nop		                NOP
.1a596b	ca		dex		                DEX                                 ; Count down
.1a596c	f0 2c		beq $1a599a	                BEQ ret_result                      ; If 0, then we're done
.1a596e	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; SCRATCH <-- Result
.1a5972	8f 0c 08 00	sta $00080c	                STA @l SCRATCH
.1a5976	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a597a	8f 0e 08 00	sta $00080e	                STA @l SCRATCH+2
.1a597e	e2 20		sep #$20	            SEP #$20
.1a5980	a9 42		lda #$42	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_1
.1a5982	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.1a5986	c2 20		rep #$20	            REP #$20
.1a5988	af 0c 08 00	lda $00080c	                LDA @l SCRATCH                      ; Input 0 <-- SCRATCH
.1a598c	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5990	af 0e 08 00	lda $00080e	                LDA @l SCRATCH+2
.1a5994	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5998	80 be		bra $1a5958	                BRA loop
.1a599a					ret_result
.1a599a	c2 20		rep #$20	            REP #$20
.1a599c	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; Return the result
.1a59a0	85 23		sta $0823	                STA ARGUMENT1
.1a59a2	af 0a e2 af	lda $afe20a	                LDA FP_MATH_OUTPUT_FP_HL
.1a59a6	85 25		sta $0825	                STA ARGUMENT1+2
.1a59a8	e2 20		sep #$20	            SEP #$20
.1a59aa	a9 01		lda #$01	                LDA #TYPE_FLOAT
.1a59ac	85 27		sta $0827	                STA ARGTYPE1
.1a59ae	28		plp		done            PLP
.1a59af	60		rts		            RTS
.1a59b0					PACKFLOAT
.1a59b0	08		php		                PHP
.1a59b1	c2 20		rep #$20	            REP #$20
.1a59b3	a5 5d		lda $085d	            LDA MARG3
.1a59b5	85 23		sta $0823	            STA ARGUMENT1
.1a59b7	a5 5f		lda $085f	            LDA MARG3+2
.1a59b9	85 25		sta $0825	            STA ARGUMENT1+2
.1a59bb	20 c9 5b	jsr $1a5bc9	            JSR ITOF
.1a59be	c2 20		rep #$20	            REP #$20
.1a59c0	a5 23		lda $0823	            LDA ARGUMENT1
.1a59c2	85 29		sta $0829	            STA ARGUMENT2
.1a59c4	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a59c6	85 2b		sta $082b	            STA ARGUMENT2+2
.1a59c8	c2 20		rep #$20	            REP #$20
.1a59ca	a5 59		lda $0859	            LDA MARG2
.1a59cc	85 23		sta $0823	            STA ARGUMENT1
.1a59ce	a5 5b		lda $085b	            LDA MARG2+2
.1a59d0	85 25		sta $0825	            STA ARGUMENT1+2
.1a59d2	20 f1 56	jsr $1a56f1	            JSR OP_FP_DIV
.1a59d5	c2 20		rep #$20	            REP #$20
.1a59d7	a5 55		lda $0855	            LDA MARG1
.1a59d9	85 29		sta $0829	            STA ARGUMENT2
.1a59db	a5 57		lda $0857	            LDA MARG1+2
.1a59dd	85 2b		sta $082b	            STA ARGUMENT2+2
.1a59df	20 a6 56	jsr $1a56a6	            JSR OP_FP_ADD
.1a59e2	c2 20		rep #$20	            REP #$20
.1a59e4	a5 23		lda $0823	            LDA ARGUMENT1
.1a59e6	85 29		sta $0829	            STA ARGUMENT2
.1a59e8	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a59ea	85 2b		sta $082b	            STA ARGUMENT2+2
.1a59ec	20 17 59	jsr $1a5917	            JSR FP_POW10
.1a59ef	20 3c 57	jsr $1a573c	            JSR OP_FP_MUL
.1a59f2	c2 20		rep #$20	            REP #$20
.1a59f4	a5 65		lda $0865	                LDA MARG5                       ; Check to see if the float should be negative
.1a59f6	f0 07		beq $1a59ff	                BEQ set_float_type              ; If not, just set the type
.1a59f8	a5 25		lda $0825	                LDA ARGUMENT1+2                 ; If so, set the sign bit
.1a59fa	09 00 80	ora #$8000	                ORA #$8000
.1a59fd	85 25		sta $0825	                STA ARGUMENT1+2
.1a59ff					set_float_type
.1a59ff	e2 20		sep #$20	            SEP #$20
.1a5a01	a9 01		lda #$01	                LDA #TYPE_FLOAT                 ; Set the type to float... ready for returning!
.1a5a03	85 27		sta $0827	                STA ARGTYPE1
.1a5a05	28		plp		                PLP
.1a5a06	60		rts		            RTS
.1a5a07					PARSENUM
.1a5a07	5a		phy		                PHY
.1a5a08	08		php		                PHP
.1a5a09	c2 30		rep #$30	            REP #$30
.1a5a0b	64 23		stz $0823	                STZ ARGUMENT1       ; This will be the accumulator for building the number
.1a5a0d	64 25		stz $0825	                STZ ARGUMENT1+2
.1a5a0f	64 55		stz $0855	                STZ MARG1           ; This will be the integer portion of the mantissa for floats
.1a5a11	64 57		stz $0857	                STZ MARG1+2
.1a5a13	64 65		stz $0865	                STZ MARG5           ; MARG5 will be the negative flag for the number
.1a5a15	64 59		stz $0859	                STZ MARG2           ; This will be the denominator of the fractional part of the mantissa
.1a5a17	64 5b		stz $085b	                STZ MARG2+2
.1a5a19	a9 01 00	lda #$0001	                LDA #1
.1a5a1c	85 5d		sta $085d	                STA MARG3           ; This will be the divisor of the fractional part of the mantissa
.1a5a1e	64 5f		stz $085f	                STZ MARG3+2
.1a5a20	64 61		stz $0861	                STZ MARG4           ; This will be the exponent of a float
.1a5a22	64 63		stz $0863	                STZ MARG4+2
.1a5a24	64 69		stz $0869	                STZ MARG6           ; MARG6 will be the negative flag for the exponent
.1a5a26					s0
.1a5a26	e2 20		sep #$20	            SEP #$20
.1a5a28	a0 00 00	ldy #$0000	                LDY #0
.1a5a2b	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the first byte
.1a5a2d	c9 2b		cmp #$2b	                CMP #'+'
.1a5a2f	f0 33		beq $1a5a64	                BEQ s1_drop         ; '+' --> S1, drop
.1a5a31	c9 2d		cmp #$2d	                CMP #'-'
.1a5a33	f0 2b		beq $1a5a60	                BEQ s1_negative     ; Flag that the number is negative
.1a5a35	c9 26		cmp #$26	                CMP #'&'
.1a5a37	f0 3a		beq $1a5a73	                BEQ s2_drop         ; '&' --> S2, drop
.1a5a39	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a5a3c	90 03		bcc $1a5a41	                BCC syntax_err
.1a5a3e	82 ac 00	brl $1a5aed	                BRL s7_shift        ; '0'-'9' --> S7, emit
.1a5a41					syntax_err
.1a5a41	08		php		            PHP
.1a5a42	c2 20		rep #$20	            REP #$20
.1a5a44	48		pha		            PHA
.1a5a45	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5a48	5b		tcd		            TCD
.1a5a49	68		pla		            PLA
.1a5a4a	28		plp		            PLP
.1a5a4b	e2 20		sep #$20	            SEP #$20
.1a5a4d	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a5a4f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5a53	c2 20		rep #$20	            REP #$20
.1a5a55	29 ff 00	and #$00ff	            AND #$00FF
.1a5a58	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a5a5b	e2 20		sep #$20	            SEP #$20
.1a5a5d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5a60	a9 01		lda #$01	s1_negative     LDA #1              ; Set the negative flag for the mantissa
.1a5a62	85 65		sta $0865	                STA MARG5
.1a5a64	c8		iny		s1_drop         INY                 ; Drop the character...
.1a5a65	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next
.1a5a67	c9 26		cmp #$26	                CMP #'&'
.1a5a69	f0 08		beq $1a5a73	                BEQ s2_drop         ; '&' --> S2, drop the '&'
.1a5a6b	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a5a6e	90 d1		bcc $1a5a41	                BCC syntax_err
.1a5a70	82 7a 00	brl $1a5aed	                BRL s7_shift        ; '0'-'9' --> S7, shift
.1a5a73	c8		iny		s2_drop         INY                 ; Drop the character
.1a5a74	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.1a5a76	c9 68		cmp #$68	                CMP #'h'
.1a5a78	f0 0e		beq $1a5a88	                BEQ s3_drop         ; 'h', 'H' --> S3, drop
.1a5a7a	c9 48		cmp #$48	                CMP #'H'
.1a5a7c	f0 0a		beq $1a5a88	                BEQ s3_drop
.1a5a7e	c9 62		cmp #$62	                CMP #'b'
.1a5a80	f0 4c		beq $1a5ace	                BEQ s5_drop         ; 'b', 'B' --> S5, drop
.1a5a82	c9 42		cmp #$42	                CMP #'B'
.1a5a84	f0 48		beq $1a5ace	                BEQ s5_drop
.1a5a86	80 b9		bra $1a5a41	                BRA syntax_err
.1a5a88	c8		iny		s3_drop         INY                 ; Drop the character
.1a5a89	b7 00		lda [$0800],y	s3              LDA [BIP],Y         ; Get the next character
.1a5a8b	20 d1 04	jsr $1a04d1	            JSR ISHEX
.1a5a8e	b0 02		bcs $1a5a92	                BCS s4_shift
.1a5a90	80 af		bra $1a5a41	                BRA syntax_err
.1a5a92					s4_shift
.1a5a92	20 a9 58	jsr $1a58a9	            JSR SHIFTHEX
.1a5a95	c8		iny		                INY
.1a5a96	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.1a5a98	20 d1 04	jsr $1a04d1	            JSR ISHEX
.1a5a9b	b0 f5		bcs $1a5a92	                BCS s4_shift        ; '0'-'9','A'-'F' --> S4, shift
.1a5a9d					ret_integer
.1a5a9d	e2 20		sep #$20	            SEP #$20
.1a5a9f	a5 65		lda $0865	                LDA MARG5           ; check if the number should be negative
.1a5aa1	f0 11		beq $1a5ab4	                BEQ set_int_type    ; If not, just set the type and return
.1a5aa3	c2 20		rep #$20	            REP #$20
.1a5aa5	38		sec		                SEC                 ; If so, negate it
.1a5aa6	a9 00 00	lda #$0000	                LDA #0
.1a5aa9	e5 23		sbc $0823	                SBC ARGUMENT1
.1a5aab	85 23		sta $0823	                STA ARGUMENT1
.1a5aad	a9 00 00	lda #$0000	                LDA #0
.1a5ab0	e5 25		sbc $0825	                SBC ARGUMENT1+2
.1a5ab2	85 25		sta $0825	                STA ARGUMENT1+2
.1a5ab4					set_int_type
.1a5ab4	e2 20		sep #$20	            SEP #$20
.1a5ab6	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; Return an integer
.1a5ab8	85 27		sta $0827	                STA ARGTYPE1
.1a5aba					stop
.1a5aba	c2 20		rep #$20	            REP #$20
.1a5abc	18		clc		                CLC
.1a5abd	98		tya		                TYA
.1a5abe	65 00		adc $0800	                ADC BIP
.1a5ac0	85 00		sta $0800	                STA BIP
.1a5ac2	a5 02		lda $0802	                LDA BIP+2
.1a5ac4	69 00 00	adc #$0000	                ADC #0
.1a5ac7	85 02		sta $0802	                STA BIP+2
.1a5ac9	e2 20		sep #$20	            SEP #$20
.1a5acb	28		plp		                PLP
.1a5acc	7a		ply		                PLY
.1a5acd	60		rts		            RTS
.1a5ace	c8		iny		s5_drop         INY                     ; Drop the character
.1a5acf	b7 00		lda [$0800],y	s5              LDA [BIP],Y             ; Get the next character
.1a5ad1	c9 30		cmp #$30	                CMP #'0'
.1a5ad3	f0 07		beq $1a5adc	                BEQ s6_shift            ; '0', '1' --> S6, shift
.1a5ad5	c9 31		cmp #$31	                CMP #'1'
.1a5ad7	f0 03		beq $1a5adc	                BEQ s6_shift
.1a5ad9	82 65 ff	brl $1a5a41	                BRL syntax_err
.1a5adc					s6_shift
.1a5adc	20 f9 58	jsr $1a58f9	            JSR SHIFTBIN
.1a5adf	c8		iny		                INY
.1a5ae0	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5ae2	c9 30		cmp #$30	                CMP #'0'                ; '0', '1' --> S6, shift
.1a5ae4	f0 f6		beq $1a5adc	                BEQ s6_shift
.1a5ae6	c9 31		cmp #$31	                CMP #'1'
.1a5ae8	f0 f2		beq $1a5adc	                BEQ s6_shift
.1a5aea	82 b0 ff	brl $1a5a9d	                BRL ret_integer         ; Return integer
.1a5aed					s7_shift
.1a5aed	20 8d 58	jsr $1a588d	            JSR SHIFTDEC
.1a5af0	c8		iny		                INY
.1a5af1	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5af3	c9 2e		cmp #$2e	                CMP #'.'                ; '.' --> S8, drop and preserve mantissa
.1a5af5	f0 08		beq $1a5aff	                BEQ s8_mantissa
.1a5af7	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a5afa	b0 f1		bcs $1a5aed	                BCS s7_shift
.1a5afc	82 9e ff	brl $1a5a9d	                BRL ret_integer         ; Return integer
.1a5aff					s8_mantissa
.1a5aff	c2 20		rep #$20	            REP #$20
.1a5b01	20 c9 5b	jsr $1a5bc9	            JSR ITOF
.1a5b04	c2 20		rep #$20	            REP #$20
.1a5b06	a5 23		lda $0823	            LDA ARGUMENT1
.1a5b08	85 55		sta $0855	            STA MARG1
.1a5b0a	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5b0c	85 57		sta $0857	            STA MARG1+2
.1a5b0e	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the decimal
.1a5b10	64 25		stz $0825	                STZ ARGUMENT1+2
.1a5b12	e2 20		sep #$20	            SEP #$20
.1a5b14	80 36		bra $1a5b4c	                BRA s8_drop
.1a5b16					s8_shift
.1a5b16	20 8d 58	jsr $1a588d	            JSR SHIFTDEC
.1a5b19	c2 20		rep #$20	            REP #$20
.1a5b1b	a5 5f		lda $085f	                LDA MARG3+2             ; high 16 bits
.1a5b1d	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.1a5b21	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.1a5b24	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.1a5b28	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to high 16 bits of MARG3
.1a5b2c	85 5f		sta $085f	                STA MARG3+2
.1a5b2e	a5 5d		lda $085d	                LDA MARG3
.1a5b30	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.1a5b34	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.1a5b37	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.1a5b3b	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to MARG3
.1a5b3f	85 5d		sta $085d	                STA MARG3
.1a5b41	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.1a5b45	18		clc		                CLC
.1a5b46	65 5f		adc $085f	                ADC MARG3+2
.1a5b48	85 5f		sta $085f	                STA MARG3+2
.1a5b4a	e2 20		sep #$20	            SEP #$20
.1a5b4c					s8_drop
.1a5b4c	c8		iny		                INY
.1a5b4d	b7 00		lda [$0800],y	                LDA [BIP],Y
.1a5b4f	c9 65		cmp #$65	                CMP #'e'                ; 'E' --> S9, drop
.1a5b51	f0 24		beq $1a5b77	                BEQ s9_drop
.1a5b53	c9 45		cmp #$45	                CMP #'E'
.1a5b55	f0 20		beq $1a5b77	                BEQ s9_drop
.1a5b57	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a5b5a	b0 ba		bcs $1a5b16	                BCS s8_shift
.1a5b5c	c2 20		rep #$20	            REP #$20
.1a5b5e	20 c9 5b	jsr $1a5bc9	            JSR ITOF
.1a5b61	c2 20		rep #$20	            REP #$20
.1a5b63	a5 23		lda $0823	            LDA ARGUMENT1
.1a5b65	85 59		sta $0859	            STA MARG2
.1a5b67	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5b69	85 5b		sta $085b	            STA MARG2+2
.1a5b6b	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.1a5b6d	64 25		stz $0825	                STZ ARGUMENT1+2
.1a5b6f	20 b0 59	jsr $1a59b0	            JSR PACKFLOAT
.1a5b72	e2 20		sep #$20	            SEP #$20
.1a5b74	82 43 ff	brl $1a5aba	                BRL stop
.1a5b77					s9_drop
.1a5b77	c2 20		rep #$20	            REP #$20
.1a5b79	20 c9 5b	jsr $1a5bc9	            JSR ITOF
.1a5b7c	c2 20		rep #$20	            REP #$20
.1a5b7e	a5 23		lda $0823	            LDA ARGUMENT1
.1a5b80	85 59		sta $0859	            STA MARG2
.1a5b82	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5b84	85 5b		sta $085b	            STA MARG2+2
.1a5b86	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.1a5b88	64 25		stz $0825	                STZ ARGUMENT1+2
.1a5b8a	e2 20		sep #$20	            SEP #$20
.1a5b8c	c8		iny		                INY
.1a5b8d	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5b8f	c9 2b		cmp #$2b	                CMP #'+'
.1a5b91	f0 10		beq $1a5ba3	                BEQ s10_drop            ; '+' --> S10, drop
.1a5b93	c9 2d		cmp #$2d	                CMP #'-'
.1a5b95	f0 08		beq $1a5b9f	                BEQ s10_setneg          ; '-' --> S10, set exponent is negative
.1a5b97	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a5b9a	b0 12		bcs $1a5bae	                BCS S11_shift           ; '0'-'9' --> S11, shift
.1a5b9c	82 a2 fe	brl $1a5a41	                BRL syntax_err
.1a5b9f					s10_setneg
.1a5b9f	a9 01		lda #$01	                LDA #1                  ; Set that the exponent should be negative
.1a5ba1	85 69		sta $0869	                STA MARG6
.1a5ba3					s10_drop
.1a5ba3	c8		iny		                INY
.1a5ba4	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5ba6	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a5ba9	b0 03		bcs $1a5bae	                BCS s11_shift
.1a5bab	82 93 fe	brl $1a5a41	                BRL syntax_err
.1a5bae					s11_shift
.1a5bae	20 8d 58	jsr $1a588d	            JSR SHIFTDEC
.1a5bb1	c8		iny		                INY
.1a5bb2	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5bb4	20 c0 04	jsr $1a04c0	            JSR ISNUMERAL
.1a5bb7	b0 f5		bcs $1a5bae	                BCS s11_shift
.1a5bb9	c2 20		rep #$20	            REP #$20
.1a5bbb	a5 23		lda $0823	            LDA ARGUMENT1
.1a5bbd	85 61		sta $0861	            STA MARG4
.1a5bbf	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5bc1	85 63		sta $0863	            STA MARG4+2
.1a5bc3	20 b0 59	jsr $1a59b0	            JSR PACKFLOAT
.1a5bc6	82 f1 fe	brl $1a5aba	                BRL stop
.1a5bc9					ITOF
.1a5bc9	08		php		                PHP
.1a5bca	20 57 56	jsr $1a5657	            JSR FIXINT_TO_FP
.1a5bcd	28		plp		done            PLP
.1a5bce	60		rts		            RTS
.1a5bcf					FTOI
.1a5bcf	08		php		                PHP
.1a5bd0					LOCALS
>0001					l_sign          .byte ?
>0002					l_exponent      .byte ?
>0003					l_mantissa      .dword ?
.1a5bd0	c2 20		rep #$20	            REP #$20
.1a5bd2	a9 c6 5e	lda #$5ec6	                LDA #<>FP_1_0
.1a5bd5	85 29		sta $0829	                STA ARGUMENT2
.1a5bd7	a9 1a 00	lda #$001a	                LDA #(FP_1_0 >> 16)
.1a5bda	85 2b		sta $082b	                STA ARGUMENT2+2
.1a5bdc	e2 20		sep #$20	            SEP #$20
.1a5bde	a9 01		lda #$01	                LDA #TYPE_FLOAT
.1a5be0	85 2d		sta $082d	                STA ARGTYPE2
.1a5be2	c2 20		rep #$20	            REP #$20
.1a5be4	20 a2 5c	jsr $1a5ca2	            JSR FP_COMPARE
.1a5be7	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a5bea	d0 0c		bne $1a5bf8	                BNE alloc_locals        ; No: get ready to do the full conversion
.1a5bec	a9 00 00	lda #$0000	                LDA #0
.1a5bef	8d 23 08	sta $0823	                STA @w ARGUMENT1        ; Yes: Return 0
.1a5bf2	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.1a5bf5	82 a1 00	brl $1a5c99	                BRL done
.1a5bf8	f4 00 00	pea #$0000	alloc_locals    PEA #0                  ; Reserve space for the locals
.1a5bfb	f4 00 00	pea #$0000	                PEA #0
.1a5bfe	f4 00 00	pea #$0000	                PEA #0
.1a5c01	e2 20		sep #$20	            SEP #$20
.1a5c03	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3      ; Preserve the sign bit
.1a5c06	29 80		and #$80	                AND #$80
.1a5c08	83 01		sta $01,s	                STA l_sign
.1a5c0a	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2      ; Preserve the exponent
.1a5c0d	2a		rol a		                ROL A
.1a5c0e	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3
.1a5c11	2a		rol a		                ROL A
.1a5c12	83 02		sta $02,s	                STA l_exponent
.1a5c14	a9 00		lda #$00	save_mantissa   LDA #0                  ; Save the mantissa (with the implied 1)
.1a5c16	83 06		sta $06,s	                STA l_mantissa+3
.1a5c18	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2
.1a5c1b	09 80		ora #$80	                ORA #$80
.1a5c1d	83 05		sta $05,s	                STA l_mantissa+2
.1a5c1f	ad 24 08	lda $0824	                LDA @w ARGUMENT1+1
.1a5c22	83 04		sta $04,s	                STA l_mantissa+1
.1a5c24	ad 23 08	lda $0823	                LDA @w ARGUMENT1
.1a5c27	83 03		sta $03,s	                STA l_mantissa
.1a5c29	a3 02		lda $02,s	                LDA l_exponent
.1a5c2b	c9 96		cmp #$96	loop            CMP #150
.1a5c2d	f0 3a		beq $1a5c69	                BEQ adj_sign
.1a5c2f	90 1f		bcc $1a5c50	                BLT shift_right
.1a5c31	08		php		            PHP
.1a5c32	c2 20		rep #$20	            REP #$20
.1a5c34	48		pha		            PHA
.1a5c35	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5c38	5b		tcd		            TCD
.1a5c39	68		pla		            PLA
.1a5c3a	28		plp		            PLP
.1a5c3b	e2 20		sep #$20	            SEP #$20
.1a5c3d	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.1a5c3f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5c43	c2 20		rep #$20	            REP #$20
.1a5c45	29 ff 00	and #$00ff	            AND #$00FF
.1a5c48	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a5c4b	e2 20		sep #$20	            SEP #$20
.1a5c4d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5c50					shift_right
.1a5c50	c2 20		rep #$20	            REP #$20
.1a5c52	a3 05		lda $05,s	                LDA l_mantissa+2
.1a5c54	4a		lsr a		                LSR A
.1a5c55	83 05		sta $05,s	                STA l_mantissa+2
.1a5c57	a3 03		lda $03,s	                LDA l_mantissa
.1a5c59	6a		ror a		                ROR A
.1a5c5a	83 03		sta $03,s	                STA l_mantissa
.1a5c5c	e2 20		sep #$20	            SEP #$20
.1a5c5e	a3 02		lda $02,s	                LDA l_exponent
.1a5c60	1a		inc a		                INC A
.1a5c61	83 02		sta $02,s	                STA l_exponent
.1a5c63	c9 96		cmp #$96	                CMP #150
.1a5c65	f0 02		beq $1a5c69	                BEQ adj_sign
.1a5c67	80 e7		bra $1a5c50	                BRA shift_right
.1a5c69	a3 01		lda $01,s	adj_sign        LDA l_sign
.1a5c6b	f0 1b		beq $1a5c88	                BEQ ret_positive
.1a5c6d	c2 20		rep #$20	            REP #$20
.1a5c6f	a3 03		lda $03,s	                LDA l_mantissa
.1a5c71	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a5c74	18		clc		                CLC
.1a5c75	69 01 00	adc #$0001	                ADC #1
.1a5c78	8d 23 08	sta $0823	                STA @w ARGUMENT1
.1a5c7b	a3 05		lda $05,s	                LDA l_mantissa+2
.1a5c7d	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a5c80	69 00 00	adc #$0000	                ADC #0
.1a5c83	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.1a5c86	80 0c		bra $1a5c94	                BRA clean
.1a5c88					ret_positive
.1a5c88	c2 20		rep #$20	            REP #$20
.1a5c8a	a3 03		lda $03,s	                LDA l_mantissa
.1a5c8c	8d 23 08	sta $0823	                STA @w ARGUMENT1
.1a5c8f	a3 05		lda $05,s	                LDA l_mantissa+2
.1a5c91	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.1a5c94					clean
.1a5c94	c2 20		rep #$20	            REP #$20
.1a5c96	68		pla		                PLA                     ; Clean up the locals
.1a5c97	68		pla		                PLA
.1a5c98	68		pla		                PLA
.1a5c99					done
.1a5c99	e2 20		sep #$20	            SEP #$20
.1a5c9b	a9 00		lda #$00	                LDA #TYPE_INTEGER       ; Set the return type to integer
.1a5c9d	8d 27 08	sta $0827	                STA @w ARGTYPE1
.1a5ca0	28		plp		                PLP
.1a5ca1	60		rts		            RTS
.1a5ca2					FP_COMPARE
.1a5ca2	da		phx		                PHX
.1a5ca3	08		php		                PHP
.1a5ca4	c2 20		rep #$20	            REP #$20
.1a5ca6	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save ARGUMENT1 so we don't destroy it
.1a5ca8	48		pha		                PHA
.1a5ca9	a5 23		lda $0823	                LDA ARGUMENT1
.1a5cab	48		pha		                PHA
.1a5cac	20 9b 56	jsr $1a569b	            JSR OP_FP_SUB
.1a5caf	20 79 58	jsr $1a5879	            JSR FARG1EQ0
.1a5cb2	b0 11		bcs $1a5cc5	                BCS are_equal
.1a5cb4	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Check the high word
.1a5cb6	89 00 80	bit #$8000	                BIT #$8000
.1a5cb9	d0 05		bne $1a5cc0	                BNE is_lt                   ; ARGUMENT1 < ARGUMENT2
.1a5cbb	a9 01 00	lda #$0001	is_gt           LDA #1                      ; ARGUMENT1 > ARGUMENT2: return 1
.1a5cbe	80 08		bra $1a5cc8	                BRA ret_result
.1a5cc0	a9 ff ff	lda #$ffff	is_lt           LDA #$FFFF                  ; ARGUMENT1 > ARGUMENT2: return -1
.1a5cc3	80 03		bra $1a5cc8	                BRA ret_result
.1a5cc5	a9 00 00	lda #$0000	are_equal       LDA #0                      ; Equal: return 0
.1a5cc8	fa		plx		ret_result      PLX                         ; Restore ARGUMENT1
.1a5cc9	86 23		stx $0823	                STX ARGUMENT1
.1a5ccb	fa		plx		                PLX
.1a5ccc	86 25		stx $0825	                STX ARGUMENT1+2
.1a5cce	28		plp		                PLP
.1a5ccf	fa		plx		                PLX
.1a5cd0	60		rts		            RTS
.1a5cd1					OP_FP_LT
.1a5cd1	08		php		                PHP
.1a5cd2	c2 30		rep #$30	            REP #$30
.1a5cd4	20 a2 5c	jsr $1a5ca2	            JSR FP_COMPARE
.1a5cd7	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a5cda	d0 05		bne $1a5ce1	                BNE ret_false
.1a5cdc	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a5cdf	80 03		bra $1a5ce4	                BRA done
.1a5ce1					ret_false
.1a5ce1	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a5ce4	28		plp		done            PLP
.1a5ce5	60		rts		            RTS
.1a5ce6					OP_FP_GT
.1a5ce6	08		php		                PHP
.1a5ce7	c2 30		rep #$30	            REP #$30
.1a5ce9	20 a2 5c	jsr $1a5ca2	            JSR FP_COMPARE
.1a5cec	c9 01 00	cmp #$0001	                CMP #1
.1a5cef	d0 05		bne $1a5cf6	                BNE ret_false
.1a5cf1	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a5cf4	80 03		bra $1a5cf9	                BRA done
.1a5cf6					ret_false
.1a5cf6	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a5cf9	28		plp		done            PLP
.1a5cfa	60		rts		            RTS
.1a5cfb					OP_FP_EQ
.1a5cfb	08		php		                PHP
.1a5cfc	c2 30		rep #$30	            REP #$30
.1a5cfe	20 a2 5c	jsr $1a5ca2	            JSR FP_COMPARE
.1a5d01	c9 00 00	cmp #$0000	                CMP #0
.1a5d04	d0 05		bne $1a5d0b	                BNE ret_false
.1a5d06	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a5d09	80 03		bra $1a5d0e	                BRA done
.1a5d0b					ret_false
.1a5d0b	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a5d0e	28		plp		done            PLP
.1a5d0f	60		rts		            RTS
.1a5d10					OP_FP_LTE
.1a5d10	08		php		                PHP
.1a5d11	c2 30		rep #$30	            REP #$30
.1a5d13	20 a2 5c	jsr $1a5ca2	            JSR FP_COMPARE
.1a5d16	c9 01 00	cmp #$0001	                CMP #1
.1a5d19	f0 05		beq $1a5d20	                BEQ ret_false
.1a5d1b	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a5d1e	80 03		bra $1a5d23	                BRA done
.1a5d20					ret_false
.1a5d20	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a5d23	28		plp		done            PLP
.1a5d24	60		rts		            RTS
.1a5d25					OP_FP_GTE
.1a5d25	08		php		                PHP
.1a5d26	c2 30		rep #$30	            REP #$30
.1a5d28	20 a2 5c	jsr $1a5ca2	            JSR FP_COMPARE
.1a5d2b	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a5d2e	f0 05		beq $1a5d35	                BEQ ret_false
.1a5d30	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a5d33	80 03		bra $1a5d38	                BRA done
.1a5d35					ret_false
.1a5d35	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a5d38	28		plp		done            PLP
.1a5d39	60		rts		            RTS
.1a5d3a					OP_FP_NE
.1a5d3a	08		php		                PHP
.1a5d3b	c2 30		rep #$30	            REP #$30
.1a5d3d	20 a2 5c	jsr $1a5ca2	            JSR FP_COMPARE
.1a5d40	c9 00 00	cmp #$0000	                CMP #0
.1a5d43	f0 05		beq $1a5d4a	                BEQ ret_false
.1a5d45	20 f2 05	jsr $1a05f2	            JSR SET_TRUE
.1a5d48	80 03		bra $1a5d4d	                BRA done
.1a5d4a					ret_false
.1a5d4a	20 04 06	jsr $1a0604	            JSR SET_FALSE
.1a5d4d	28		plp		done            PLP
.1a5d4e	60		rts		            RTS
.1a5d4f					STREMIT
.1a5d4f	08		php		                PHP
.1a5d50	e2 20		sep #$20	            SEP #$20
.1a5d52	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Append the character
.1a5d54	c8		iny		                INY                         ; Advance the character pointer in Y
.1a5d55	a9 00		lda #$00	                LDA #0                      ; And add the NULL
.1a5d57	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.1a5d59	28		plp		                PLP
.1a5d5a	60		rts		            RTS
.1a5d5b					STREMITB
.1a5d5b	da		phx		                PHX
.1a5d5c	08		php		                PHP
.1a5d5d	e2 20		sep #$20	            SEP #$20
.1a5d5f	c9 80		cmp #$80	                CMP #$80
.1a5d61	90 0a		bcc $1a5d6d	                BLT emit_digits
.1a5d63	48		pha		                PHA
.1a5d64	a9 2d		lda #$2d	                LDA #'-'                    ; Print a minus sign
.1a5d66	20 4f 5d	jsr $1a5d4f	            JSR STREMIT
.1a5d69	68		pla		                PLA
.1a5d6a	49 ff		eor #$ff	                EOR #$FF                    ; And negate it
.1a5d6c	1a		inc a		                INC A
.1a5d6d					emit_digits
.1a5d6d	c2 30		rep #$30	            REP #$30
.1a5d6f	29 ff 00	and #$00ff	                AND #$00FF
.1a5d72	c9 64 00	cmp #$0064	                CMP #100
.1a5d75	90 0e		bcc $1a5d85	                BLT chk_tens
.1a5d77	a2 64 00	ldx #$0064	                LDX #100
.1a5d7a	20 40 56	jsr $1a5640	            JSR UINT_DIV_A_X
.1a5d7d	18		clc		                CLC
.1a5d7e	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.1a5d81	20 4f 5d	jsr $1a5d4f	            JSR STREMIT
.1a5d84	8a		txa		                TXA                         ; Put the remainder in A
.1a5d85					chk_tens
.1a5d85	a2 0a 00	ldx #$000a	                LDX #10
.1a5d88	20 40 56	jsr $1a5640	            JSR UINT_DIV_A_X
.1a5d8b	18		clc		                CLC
.1a5d8c	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.1a5d8f	20 4f 5d	jsr $1a5d4f	            JSR STREMIT
.1a5d92	8a		txa		                TXA                         ; Put the remainder in A
.1a5d93					ones_digit
.1a5d93	18		clc		                CLC
.1a5d94	69 30 00	adc #$0030	                ADC #'0'                    ; Convert it to ASCII
.1a5d97	20 4f 5d	jsr $1a5d4f	            JSR STREMIT
.1a5d9a	28		plp		                PLP
.1a5d9b	fa		plx		                PLX
.1a5d9c	60		rts		            RTS
.1a5d9d					STRFINDEND
.1a5d9d	08		php		                PHP
.1a5d9e	e2 20		sep #$20	            SEP #$20
.1a5da0	c2 10		rep #$10	            REP #$10
.1a5da2	a0 00 00	ldy #$0000	                LDY #0
.1a5da5	b7 23		lda [$0823],y	find_end        LDA [ARGUMENT1],Y           ; Scan to the end of the string
.1a5da7	f0 03		beq $1a5dac	                BEQ done
.1a5da9	c8		iny		                INY
.1a5daa	80 f9		bra $1a5da5	                BRA find_end
.1a5dac	28		plp		done            PLP
.1a5dad	60		rts		            RTS
=6					FP_D = 6        ; Number of mantissa digits
.1a5dae					FTOS
.1a5dae	08		php		                PHP
.1a5daf	e2 20		sep #$20	            SEP #$20
.1a5db1	c2 10		rep #$10	            REP #$10
.1a5db3	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be the negative flag
.1a5db6	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be K
.1a5db9	f4 00 00	pea #$0000	                PEA #0                      ; This spot will be for the exponents
>0001					L_NEGATIVE      .word ?
>0003					L_K             .word ?
>0005					L_X1            .byte ?                     ; The binary exponent
>0006					L_EXP           .byte ?                     ; The decimal exponent
.1a5dbc	20 79 58	jsr $1a5879	            JSR FARG1EQ0
.1a5dbf	90 19		bcc $1a5dda	                BCC chk_negative
.1a5dc1	20 c6 14	jsr $1a14c6	            JSR TEMPSTRING
.1a5dc4	e2 20		sep #$20	            SEP #$20
.1a5dc6	a0 00 00	ldy #$0000	                LDY #0
.1a5dc9	a9 20		lda #$20	                LDA #' '
.1a5dcb	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a5dcd	c8		iny		                INY
.1a5dce	a9 30		lda #$30	                LDA #'0'                    ; Return a "0"
.1a5dd0	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a5dd2	c8		iny		                INY
.1a5dd3	a9 00		lda #$00	                LDA #0
.1a5dd5	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a5dd7	82 ce 00	brl $1a5ea8	                BRL ret_result
.1a5dda					chk_negative
.1a5dda	e2 20		sep #$20	            SEP #$20
.1a5ddc	a5 26		lda $0826	                LDA ARGUMENT1+3             ; If N is negative, output a minus sign and negate N
.1a5dde	10 08		bpl $1a5de8	                BPL not_negative
.1a5de0	29 7f		and #$7f	                AND #$7F                    ; Negate the number
.1a5de2	85 26		sta $0826	                STA ARGUMENT1+3
.1a5de4	a9 01		lda #$01	                LDA #1
.1a5de6	83 01		sta $01,s	                STA L_NEGATIVE              ; Set IsNegative to a TRUE value
.1a5de8					not_negative
.1a5de8	c2 20		rep #$20	            REP #$20
.1a5dea	a9 00 00	lda #$0000	                LDA #0                      ; Initialize K to 0, K is a 1-byte signed integer. (SCRATCH is K)
.1a5ded	83 03		sta $03,s	                STA L_K                     ; We're using a word here for convenience
.1a5def	c2 20		rep #$20	            REP #$20
.1a5df1	af c2 5e 1a	lda $1a5ec2	            LDA ten_d_1
.1a5df5	85 29		sta $0829	            STA ARGUMENT2
.1a5df7	af c4 5e 1a	lda $1a5ec4	            LDA ten_d_1+2
.1a5dfb	85 2b		sta $082b	            STA ARGUMENT2+2
.1a5dfd	20 a2 5c	jsr $1a5ca2	            JSR FP_COMPARE
.1a5e00	89 00 80	bit #$8000	                BIT #$8000                  ; Is N < 10^(D-1)?
.1a5e03	d0 12		bne $1a5e17	                BNE shift_up
.1a5e05					shift_down
.1a5e05	20 3d 58	jsr $1a583d	            JSR FP_DIV10
.1a5e08	a3 03		lda $03,s	                LDA L_K
.1a5e0a	1a		inc a		                INC A
.1a5e0b	83 03		sta $03,s	                STA L_K                     ; Increment K
.1a5e0d	20 a2 5c	jsr $1a5ca2	            JSR FP_COMPARE
.1a5e10	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N < 10^(D-1)?
.1a5e13	f0 12		beq $1a5e27	                BEQ do_digits               ; Yes: we're ready to process digits
.1a5e15	80 ee		bra $1a5e05	                BRA shift_down              ; No: keep dividing
.1a5e17					shift_up
.1a5e17	20 f4 57	jsr $1a57f4	            JSR FP_MUL10
.1a5e1a	a3 03		lda $03,s	                LDA L_K
.1a5e1c	3a		dec a		                DEC A
.1a5e1d	83 03		sta $03,s	                STA L_K                     ; Decrement K
.1a5e1f	20 a2 5c	jsr $1a5ca2	            JSR FP_COMPARE
.1a5e22	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N >= 10 ^ (D-1)?
.1a5e25	f0 f0		beq $1a5e17	                BEQ shift_up                ; No: keep multiplying
.1a5e27					do_digits
.1a5e27	e2 30		sep #$30	            SEP #$30
.1a5e29	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5e2b	0a		asl a		                ASL A
.1a5e2c	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a5e2e	2a		rol a		                ROL A
.1a5e2f	83 05		sta $05,s	                STA L_X1
.1a5e31	38		sec		                SEC
.1a5e32	a9 96		lda #$96	                LDA #150                    ; X := 150 - X1
.1a5e34	e3 05		sbc $05,s	                SBC L_X1
.1a5e36	aa		tax		                TAX
.1a5e37	f0 0f		beq $1a5e48	                BEQ emit_digits             ; If X = 0, just emit the digits
.1a5e39	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Set the implied '1' MSB of the mantissa
.1a5e3b	09 80		ora #$80	                ORA #$80
.1a5e3d	85 25		sta $0825	                STA ARGUMENT1+2
.1a5e3f	46 25		lsr $0825	shift_r         LSR ARGUMENT1+2             ; Shift the mantissa right
.1a5e41	66 24		ror $0824	                ROR ARGUMENT1+1
.1a5e43	66 23		ror $0823	                ROR ARGUMENT1
.1a5e45	ca		dex		                DEX
.1a5e46	d0 f7		bne $1a5e3f	                BNE shift_r                 ; Until X = 0
.1a5e48					emit_digits
.1a5e48	c2 10		rep #$10	            REP #$10
.1a5e4a	e2 20		sep #$20	            SEP #$20
.1a5e4c	64 26		stz $0826	                STZ ARGUMENT1+3             ; Blank out the MSB
.1a5e4e	a9 00		lda #$00	                LDA #TYPE_INTEGER           ; Make it an integer
.1a5e50	85 27		sta $0827	                STA ARGTYPE1
.1a5e52	a3 01		lda $01,s	                LDA L_NEGATIVE              ; Check IsNegative
.1a5e54	f0 11		beq $1a5e67	                BEQ get_raw_digits          ; If FALSE, just convert the raw digits
.1a5e56	c2 20		rep #$20	            REP #$20
.1a5e58	38		sec		                SEC                         ; Make the raw integer negative
.1a5e59	a9 00 00	lda #$0000	                LDA #0
.1a5e5c	e5 23		sbc $0823	                SBC ARGUMENT1
.1a5e5e	85 23		sta $0823	                STA ARGUMENT1
.1a5e60	a9 00 00	lda #$0000	                LDA #0
.1a5e63	e5 25		sbc $0825	                SBC ARGUMENT1+2
.1a5e65	85 25		sta $0825	                STA ARGUMENT1+2
.1a5e67					get_raw_digits
.1a5e67	20 25 15	jsr $1a1525	            JSR ITOS
.1a5e6a	c2 20		rep #$20	            REP #$20
.1a5e6c	a5 16		lda $0816	            LDA STRPTR
.1a5e6e	85 23		sta $0823	            STA ARGUMENT1
.1a5e70	a5 18		lda $0818	            LDA STRPTR+2
.1a5e72	85 25		sta $0825	            STA ARGUMENT1+2
.1a5e74	20 9d 5d	jsr $1a5d9d	            JSR STRFINDEND
.1a5e77	e2 20		sep #$20	            SEP #$20
.1a5e79	c8		iny		                INY                         ; Move the NULL up one byte
.1a5e7a	a9 00		lda #$00	                LDA #0
.1a5e7c	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.1a5e7e	88		dey		insert_loop     DEY                         ; Move to the character before the one we just moved
.1a5e7f	88		dey		                DEY
.1a5e80	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y           ; Get the character
.1a5e82	c8		iny		                INY                         ; Move to the next space
.1a5e83	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Store the character here
.1a5e85	c0 02 00	cpy #$0002	                CPY #2                      ; Check to see if we just moved the 2nd character
.1a5e88	d0 f4		bne $1a5e7e	                BNE insert_loop             ; If not, keep moving the characters
.1a5e8a	a9 2e		lda #$2e	                LDA #'.'                    ; Insert the '.' in the space we openned
.1a5e8c	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.1a5e8e	e2 20		sep #$20	            SEP #$20
.1a5e90	18		clc		                CLC                         ; Compute the exponent
.1a5e91	a3 03		lda $03,s	                LDA L_K
.1a5e93	69 05		adc #$05	                ADC #(FP_D - 1)
.1a5e95	83 06		sta $06,s	                STA L_EXP
.1a5e97	f0 19		beq $1a5eb2	                BEQ done                    ; If it's 0, just return the number
.1a5e99	20 9d 5d	jsr $1a5d9d	            JSR STRFINDEND
.1a5e9c	a9 45		lda #$45	                LDA #'E'                    ; Append the "E"
.1a5e9e	20 4f 5d	jsr $1a5d4f	            JSR STREMIT
.1a5ea1	a3 06		lda $06,s	                LDA L_EXP
.1a5ea3	20 5b 5d	jsr $1a5d5b	            JSR STREMITB
.1a5ea6	80 0a		bra $1a5eb2	                BRA done                    ; TODO: reformat integer... add E and exponent...
.1a5ea8					ret_result
.1a5ea8	c2 20		rep #$20	            REP #$20
.1a5eaa	a5 16		lda $0816	                LDA STRPTR                  ; Return the temporary string we've assembled
.1a5eac	85 23		sta $0823	                STA ARGUMENT1
.1a5eae	a5 18		lda $0818	                LDA STRPTR+2
.1a5eb0	85 25		sta $0825	                STA ARGUMENT1+2
.1a5eb2					done
.1a5eb2	e2 20		sep #$20	            SEP #$20
.1a5eb4	a9 02		lda #$02	                LDA #TYPE_STRING
.1a5eb6	85 27		sta $0827	                STA ARGTYPE1
.1a5eb8	c2 20		rep #$20	            REP #$20
.1a5eba	3b		tsc		                TSC                         ; Remove the locals from the stack
.1a5ebb	18		clc		                CLC
.1a5ebc	69 06 00	adc #$0006	                ADC #6
.1a5ebf	1b		tcs		                TCS
.1a5ec0	28		plp		                PLP
.1a5ec1	60		rts		            RTS
>1a5ec2	00 50 c3 47			ten_d_1         .dword $47c35000            ; 10^(FP_D-1), where FP_D=5
>1a5ec6	00 00 80 3f			FP_1_0          .dword $3f800000    ; Floating point constant: 1.0
>1a5eca	f3 04 b5 3f			FP_SQR_2_0      .dword $3fb504f3    ; Floating point constant: sqrt(2.0)
>1a5ece	f3 04 35 3f			FP_SQR_0_5      .dword $3f3504f3    ; Floating point constant: sqrt(0.2)

;******  Return to file: src\basic816.s


;******  Processing file: src\transcendentals.s

.1a5ed2					Q_POLY_HR
.1a5ed2	e2 20		sep #$20	            SEP #$20
.1a5ed4	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a5ed6	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5eda	c2 20		rep #$20	            REP #$20
.1a5edc	bd 00 00	lda $0000,x	                LDA 0,X
.1a5edf	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5ee3	bd 02 00	lda $0002,x	                LDA 2,X
.1a5ee6	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5eea	88		dey		                DEY             ; (Y-1) more coefficients.
.1a5eeb	e8		inx		loop            INX             ; point to the next coefficient
.1a5eec	e8		inx		                INX
.1a5eed	e8		inx		                INX
.1a5eee	e8		inx		                INX
.1a5eef	e2 20		sep #$20	            SEP #$20
.1a5ef1	a9 00		lda #$00	                LDA #FP_OUT_MULT
.1a5ef3	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5ef7	c2 20		rep #$20	            REP #$20
.1a5ef9	af 23 08 00	lda $000823	                LDA @l ARGUMENT1
.1a5efd	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5f01	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a5f05	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5f09	ea		nop		                NOP
.1a5f0a	ea		nop		                NOP
.1a5f0b	ea		nop		                NOP
.1a5f0c	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5f10	48		pha		                PHA
.1a5f11	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5f15	8f 0a e2 af	sta $afe20a	                STA FP_MATH_INPUT0_HL
.1a5f19	68		pla		                PLA
.1a5f1a	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5f1e	e2 20		sep #$20	            SEP #$20
.1a5f20	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a5f22	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5f26	c2 20		rep #$20	            REP #$20
.1a5f28	bd 00 00	lda $0000,x	                LDA 0,X
.1a5f2b	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5f2f	bd 02 00	lda $0002,x	                LDA 2,X
.1a5f32	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5f36	ea		nop		                NOP
.1a5f37	ea		nop		                NOP
.1a5f38	ea		nop		                NOP
.1a5f39	88		dey		                DEY
.1a5f3a	f0 14		beq $1a5f50	                BEQ done
.1a5f3c	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5f40	48		pha		                PHA
.1a5f41	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5f45	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5f49	68		pla		                PLA
.1a5f4a	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5f4e	80 9b		bra $1a5eeb	                BRA loop
.1a5f50	af 08 e2 af	lda $afe208	done            LDA @l FP_MATH_OUTPUT_FP_LL
.1a5f54	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.1a5f58	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5f5c	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.1a5f60	60		rts		                RTS
.1a5f61					Q_SQ
.1a5f61	e2 20		sep #$20	            SEP #$20
.1a5f63	a9 00		lda #$00	                LDA #0
.1a5f65	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5f69	a9 00		lda #$00	                LDA #FP_OUT_MULT
.1a5f6b	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5f6f	c2 20		rep #$20	            REP #$20
.1a5f71	a5 23		lda $0823	                LDA ARGUMENT1
.1a5f73	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5f77	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5f7b	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a5f7f	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5f83	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5f87	ea		nop		                NOP
.1a5f88	ea		nop		                NOP
.1a5f89	ea		nop		                NOP
.1a5f8a	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5f8e	85 23		sta $0823	                STA ARGUMENT1
.1a5f90	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5f94	85 25		sta $0825	                STA ARGUMENT1+2
.1a5f96	60		rts		                RTS
.1a5f97					Q_INV
.1a5f97	e2 20		sep #$20	            SEP #$20
.1a5f99	a9 00		lda #$00	                LDA #0
.1a5f9b	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5f9f	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a5fa1	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5fa5	c2 20		rep #$20	            REP #$20
.1a5fa7	a5 23		lda $0823	                LDA ARGUMENT1
.1a5fa9	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5fad	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a5fb1	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5fb5	af eb 65 1a	lda $1a65eb	                LDA @l fp_one
.1a5fb9	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5fbd	af ed 65 1a	lda $1a65ed	                LDA @l fp_one+2
.1a5fc1	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5fc5	ea		nop		                NOP
.1a5fc6	ea		nop		                NOP
.1a5fc7	ea		nop		                NOP
.1a5fc8	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5fcc	85 23		sta $0823	                STA ARGUMENT1
.1a5fce	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5fd2	85 25		sta $0825	                STA ARGUMENT1+2
.1a5fd4	60		rts		                RTS
.1a5fd5					Q_FP_SCALE
.1a5fd5	a2 00 00	ldx #$0000	                LDX #0
.1a5fd8	a5 23		lda $0823	loop            LDA ARGUMENT1
.1a5fda	c5 29		cmp $0829	                CMP ARGUMENT2
.1a5fdc	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5fde	e5 2b		sbc $082b	                SBC ARGUMENT2+2
.1a5fe0	90 1e		bcc $1a6000	                BCC done
.1a5fe2	a5 23		lda $0823	                LDA ARGUMENT1
.1a5fe4	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5fe8	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5fea	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5fee	ea		nop		                NOP
.1a5fef	ea		nop		                NOP
.1a5ff0	ea		nop		                NOP
.1a5ff1	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5ff5	85 23		sta $0823	                STA ARGUMENT1
.1a5ff7	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5ffb	85 25		sta $0825	                STA ARGUMENT1+2
.1a5ffd	e8		inx		                INX
.1a5ffe	80 d8		bra $1a5fd8	                BRA loop
.1a6000					done
.1a6000	60		rts		            RTS
.1a6001					Q_FP_SCALE_TAU
.1a6001	e2 20		sep #$20	            SEP #$20
.1a6003	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a6005	10 09		bpl $1a6010	                BPL notneg
.1a6007	29 7f		and #$7f	                AND #$7F
.1a6009	85 26		sta $0826	                STA ARGUMENT1+3
.1a600b	a9 01		lda #$01	                LDA #1
.1a600d	48		pha		                PHA
.1a600e	80 03		bra $1a6013	                BRA compute
.1a6010	a9 00		lda #$00	notneg          LDA #0          ; not negative, so push 0.
.1a6012	48		pha		                PHA
.1a6013	a9 40		lda #$40	compute         LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a6015	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a6019	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a601b	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a601f	c2 30		rep #$30	            REP #$30
.1a6021	af 53 66 1a	lda $1a6653	                LDA @l twopi
.1a6025	85 29		sta $0829	                STA ARGUMENT2
.1a6027	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a602b	af 55 66 1a	lda $1a6655	                LDA @l twopi+2
.1a602f	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6031	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a6035	20 d5 5f	jsr $1a5fd5	            JSR Q_FP_SCALE
.1a6038	e2 20		sep #$20	            SEP #$20
.1a603a	68		pla		                PLA
.1a603b	c2 20		rep #$20	            REP #$20
.1a603d	f0 1e		beq $1a605d	                BEQ done
.1a603f	a5 23		lda $0823	                LDA ARGUMENT1
.1a6041	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a6045	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6047	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a604b	ea		nop		                NOP
.1a604c	ea		nop		                NOP
.1a604d	ea		nop		                NOP
.1a604e	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a6052	85 23		sta $0823	                STA ARGUMENT1
.1a6054	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a6058	29 ff 7f	and #$7fff	                AND #$7fff
.1a605b	85 25		sta $0825	                STA ARGUMENT1+2
.1a605d					done
.1a605d	60		rts		            RTS
.1a605e					Q_FP_NORM_ANGLE
.1a605e	5a		phy		                PHY
.1a605f	a2 00 00	ldx #$0000	                LDX #0
.1a6062	a0 00 00	ldy #$0000	                LDY #0
.1a6065	a5 23		lda $0823	loop            LDA ARGUMENT1
.1a6067	df 57 66 1a	cmp $1a6657,x	                CMP @l onepi,x
.1a606b	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a606d	ff 59 66 1a	sbc $1a6659,x	                SBC @l onepi+2,x
.1a6071	90 2c		bcc $1a609f	                BCC less
.1a6073	bf 53 66 1a	lda $1a6653,x	                LDA @l twopi,x
.1a6077	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a607b	bf 55 66 1a	lda $1a6655,x	                LDA @l twopi+2,x
.1a607f	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a6083	a5 23		lda $0823	                LDA ARGUMENT1
.1a6085	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a6089	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a608b	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a608f	ea		nop		                NOP
.1a6090	ea		nop		                NOP
.1a6091	ea		nop		                NOP
.1a6092	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a6096	85 23		sta $0823	                STA ARGUMENT1
.1a6098	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a609c	85 25		sta $0825	                STA ARGUMENT1+2
.1a609e	38		sec		                SEC             ; set carry to indicate a reflection
.1a609f	98		tya		less            TYA             ; carry already cleared if we branched
.1a60a0	2a		rol a		                ROL             ; shift carry into flags...
.1a60a1	a8		tay		                TAY             ; and store back into y
.1a60a2	e8		inx		                INX             ; next set of values
.1a60a3	e8		inx		                INX
.1a60a4	e8		inx		                INX
.1a60a5	e8		inx		                INX
.1a60a6	e0 0c 00	cpx #$000c	                CPX #12         ; check if we have already looked at 3
.1a60a9	d0 ba		bne $1a6065	                BNE loop
.1a60ab	98		tya		                TYA             ; copy Y to X, as that's what we have
.1a60ac	aa		tax		                TAX
.1a60ad	7a		ply		                PLY
.1a60ae	60		rts		            RTS
.1a60af					Q_FP_COS
.1a60af	08		php		                PHP
.1a60b0	c2 30		rep #$30	            REP #$30
.1a60b2	48		pha		                PHA
.1a60b3	da		phx		                PHX
.1a60b4	20 61 5f	jsr $1a5f61	            JSR Q_SQ
.1a60b7	8b		phb		                PHB
.1a60b8	e2 20		sep #$20	            SEP #$20
.1a60ba	a9 1a		lda #$1a	                LDA #`cos_coeff
.1a60bc	48		pha		                PHA
.1a60bd	ab		plb		                PLB
.1a60be	c2 20		rep #$20	            REP #$20
.1a60c0	a2 93 65	ldx #$6593	                LDX #<>cos_coeff
.1a60c3	5a		phy		                PHY
.1a60c4	a0 05 00	ldy #$0005	                LDY #5
.1a60c7	20 d2 5e	jsr $1a5ed2	            JSR Q_POLY_HR
.1a60ca	7a		ply		                PLY
.1a60cb	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.1a60ce	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.1a60d2	ab		plb		                PLB
.1a60d3	fa		plx		                PLX
.1a60d4	68		pla		                PLA
.1a60d5	28		plp		                PLP
.1a60d6	60		rts		            RTS
.1a60d7					Q_FP_SIN
.1a60d7	08		php		                PHP
.1a60d8	c2 30		rep #$30	            REP #$30
.1a60da	48		pha		                PHA
.1a60db	da		phx		                PHX
.1a60dc	a5 23		lda $0823	                LDA ARGUMENT1
.1a60de	85 29		sta $0829	                STA ARGUMENT2
.1a60e0	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a60e2	85 2b		sta $082b	                STA ARGUMENT2+2
.1a60e4	20 61 5f	jsr $1a5f61	            JSR Q_SQ
.1a60e7	8b		phb		                PHB
.1a60e8	e2 20		sep #$20	            SEP #$20
.1a60ea	a9 1a		lda #$1a	                LDA #`sin_coeff
.1a60ec	48		pha		                PHA
.1a60ed	ab		plb		                PLB
.1a60ee	c2 20		rep #$20	            REP #$20
.1a60f0	a2 a7 65	ldx #$65a7	                LDX #<>sin_coeff
.1a60f3	5a		phy		                PHY
.1a60f4	a0 05 00	ldy #$0005	                LDY #5
.1a60f7	20 d2 5e	jsr $1a5ed2	            JSR Q_POLY_HR
.1a60fa	7a		ply		                PLY
.1a60fb	ab		plb		                PLB
.1a60fc	20 3c 57	jsr $1a573c	            JSR OP_FP_MUL
.1a60ff	fa		plx		                PLX
.1a6100	68		pla		                PLA
.1a6101	28		plp		                PLP
.1a6102	60		rts		            RTS
.1a6103					Q_FP_TAN
.1a6103	08		php		                PHP
.1a6104	c2 30		rep #$30	            REP #$30
.1a6106	48		pha		                PHA
.1a6107	da		phx		                PHX
.1a6108	a5 23		lda $0823	                LDA ARGUMENT1
.1a610a	85 29		sta $0829	                STA ARGUMENT2
.1a610c	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a610e	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6110	20 61 5f	jsr $1a5f61	            JSR Q_SQ
.1a6113	8b		phb		                PHB
.1a6114	e2 20		sep #$20	            SEP #$20
.1a6116	a9 1a		lda #$1a	                LDA #`tan_coeff
.1a6118	48		pha		                PHA
.1a6119	ab		plb		                PLB
.1a611a	c2 20		rep #$20	            REP #$20
.1a611c	a2 bb 65	ldx #$65bb	                LDX #<>tan_coeff
.1a611f	5a		phy		                PHY
.1a6120	a0 05 00	ldy #$0005	                LDY #5
.1a6123	20 d2 5e	jsr $1a5ed2	            JSR Q_POLY_HR
.1a6126	7a		ply		                PLY
.1a6127	ab		plb		                PLB
.1a6128	20 3c 57	jsr $1a573c	            JSR OP_FP_MUL
.1a612b	fa		plx		                PLX
.1a612c	68		pla		                PLA
.1a612d	28		plp		                PLP
.1a612e	60		rts		            RTS
.1a612f					Q_FP_LN
.1a612f	08		php		                PHP
.1a6130	c2 30		rep #$30	            REP #$30
.1a6132	48		pha		                PHA
.1a6133	da		phx		                PHX
.1a6134	e2 20		sep #$20	            SEP #$20
.1a6136	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a6138	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a613c	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a613e	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a6142	c2 20		rep #$20	            REP #$20
.1a6144	a5 23		lda $0823	                LDA ARGUMENT1
.1a6146	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a614a	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a614c	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a6150	af eb 65 1a	lda $1a65eb	                LDA @l fp_one
.1a6154	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a6158	af ed 65 1a	lda $1a65ed	                LDA @l fp_one+2
.1a615c	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a6160	ea		nop		                NOP
.1a6161	ea		nop		                NOP
.1a6162	ea		nop		                NOP
.1a6163	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a6167	85 0c		sta $080c	                STA SCRATCH
.1a6169	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a616d	85 0e		sta $080e	                STA SCRATCH+2
.1a616f	e2 20		sep #$20	            SEP #$20
.1a6171	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a6173	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a6177	c2 20		rep #$20	            REP #$20
.1a6179	ea		nop		                NOP
.1a617a	ea		nop		                NOP
.1a617b	ea		nop		                NOP
.1a617c	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a6180	85 10		sta $0810	                STA SCRATCH2
.1a6182	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a6186	85 12		sta $0812	                STA SCRATCH2+2
.1a6188	e2 20		sep #$20	            SEP #$20
.1a618a	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a618c	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a6190	c2 20		rep #$20	            REP #$20
.1a6192	a5 0c		lda $080c	                LDA SCRATCH
.1a6194	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a6198	a5 0e		lda $080e	                LDA SCRATCH+2
.1a619a	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a619e	a5 10		lda $0810	                LDA SCRATCH2
.1a61a0	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a61a4	a5 12		lda $0812	                LDA SCRATCH2+2
.1a61a6	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a61aa	ea		nop		                NOP
.1a61ab	ea		nop		                NOP
.1a61ac	ea		nop		                NOP
.1a61ad	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a61b1	85 23		sta $0823	                STA ARGUMENT1
.1a61b3	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a61b7	85 25		sta $0825	                STA ARGUMENT1+2
.1a61b9	e2 20		sep #$20	            SEP #$20
.1a61bb	a9 08		lda #$08	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX0
.1a61bd	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a61c1	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a61c3	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a61c7	c2 20		rep #$20	            REP #$20
.1a61c9	a5 23		lda $0823	                LDA ARGUMENT1
.1a61cb	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a61cf	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a61d1	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a61d5	ea		nop		                NOP
.1a61d6	ea		nop		                NOP
.1a61d7	ea		nop		                NOP
.1a61d8	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a61dc	85 29		sta $0829	                STA ARGUMENT2
.1a61de	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a61e2	85 2b		sta $082b	                STA ARGUMENT2+2
.1a61e4	20 61 5f	jsr $1a5f61	            JSR Q_SQ
.1a61e7	8b		phb		                PHB
.1a61e8	e2 20		sep #$20	            SEP #$20
.1a61ea	a9 1a		lda #$1a	                LDA #`ln_coeff
.1a61ec	48		pha		                PHA
.1a61ed	ab		plb		                PLB
.1a61ee	c2 20		rep #$20	            REP #$20
.1a61f0	a2 cf 65	ldx #$65cf	                LDX #<>ln_coeff
.1a61f3	5a		phy		                PHY
.1a61f4	a0 08 00	ldy #$0008	                LDY #8
.1a61f7	20 d2 5e	jsr $1a5ed2	            JSR Q_POLY_HR
.1a61fa	7a		ply		                PLY
.1a61fb	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.1a61fe	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.1a6202	8f 2d 08 00	sta $00082d	                STA @l ARGTYPE2
.1a6206	20 3c 57	jsr $1a573c	            JSR OP_FP_MUL
.1a6209	ab		plb		                PLB
.1a620a	fa		plx		                PLX
.1a620b	68		pla		                PLA
.1a620c	28		plp		                PLP
.1a620d	60		rts		            RTS
.1a620e					FP_SIN
.1a620e	08		php		                PHP
.1a620f	c2 30		rep #$30	            REP #$30
.1a6211	48		pha		                PHA
.1a6212	da		phx		                PHX
.1a6213	20 01 60	jsr $1a6001	            JSR Q_FP_SCALE_TAU
.1a6216	20 5e 60	jsr $1a605e	            JSR Q_FP_NORM_ANGLE
.1a6219	da		phx		                PHX
.1a621a	8a		txa		                TXA
.1a621b	29 01 00	and #$0001	                AND #1
.1a621e	d0 05		bne $1a6225	                BNE do_cos
.1a6220	20 d7 60	jsr $1a60d7	            JSR Q_FP_SIN
.1a6223	80 03		bra $1a6228	                BRA maybe_neg
.1a6225					do_cos
.1a6225	20 af 60	jsr $1a60af	            JSR Q_FP_COS
.1a6228	fa		plx		maybe_neg       PLX
.1a6229	8a		txa		                TXA
.1a622a	29 04 00	and #$0004	                AND #4
.1a622d	f0 0a		beq $1a6239	                BEQ done
.1a622f	e2 20		sep #$20	            SEP #$20
.1a6231	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a6233	09 80		ora #$80	                ORA #$80
.1a6235	85 26		sta $0826	                STA ARGUMENT1+3
.1a6237	c2 20		rep #$20	            REP #$20
.1a6239	fa		plx		done            PLX
.1a623a	68		pla		                PLA
.1a623b	28		plp		                PLP
.1a623c	60		rts		            RTS
.1a623d					FP_COS
.1a623d	08		php		                PHP
.1a623e	c2 30		rep #$30	            REP #$30
.1a6240	48		pha		                PHA
.1a6241	da		phx		                PHX
.1a6242	20 01 60	jsr $1a6001	            JSR Q_FP_SCALE_TAU
.1a6245	20 5e 60	jsr $1a605e	            JSR Q_FP_NORM_ANGLE
.1a6248	da		phx		                PHX
.1a6249	8a		txa		                TXA
.1a624a	29 01 00	and #$0001	                AND #1
.1a624d	d0 05		bne $1a6254	                BNE do_sin
.1a624f	20 af 60	jsr $1a60af	            JSR Q_FP_COS
.1a6252	80 03		bra $1a6257	                BRA maybe_neg
.1a6254					do_sin
.1a6254	20 d7 60	jsr $1a60d7	            JSR Q_FP_SIN
.1a6257	fa		plx		maybe_neg       PLX
.1a6258	8a		txa		                TXA
.1a6259	29 02 00	and #$0002	                AND #2
.1a625c	f0 0a		beq $1a6268	                BEQ done
.1a625e	e2 20		sep #$20	            SEP #$20
.1a6260	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a6262	09 80		ora #$80	                ORA #$80
.1a6264	85 26		sta $0826	                STA ARGUMENT1+3
.1a6266	c2 20		rep #$20	            REP #$20
.1a6268	fa		plx		done            PLX
.1a6269	68		pla		                PLA
.1a626a	28		plp		                PLP
.1a626b	60		rts		            RTS
.1a626c					FP_TAN
.1a626c	08		php		                PHP
.1a626d	c2 30		rep #$30	            REP #$30
.1a626f	48		pha		                PHA
.1a6270	da		phx		                PHX
.1a6271	20 01 60	jsr $1a6001	            JSR Q_FP_SCALE_TAU
.1a6274	20 5e 60	jsr $1a605e	            JSR Q_FP_NORM_ANGLE
.1a6277	20 03 61	jsr $1a6103	            JSR Q_FP_TAN
.1a627a	8a		txa		                TXA
.1a627b	29 01 00	and #$0001	                AND #1
.1a627e	f0 03		beq $1a6283	                BEQ no_inv
.1a6280	20 97 5f	jsr $1a5f97	            JSR Q_INV
.1a6283	8a		txa		no_inv          TXA
.1a6284	e2 20		sep #$20	            SEP #$20
.1a6286	4a		lsr a		                LSR
.1a6287	4a		lsr a		                LSR
.1a6288	69 00		adc #$00	                ADC #0
.1a628a	29 01		and #$01	                AND #1
.1a628c	f0 06		beq $1a6294	                BEQ no_neg
.1a628e	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a6290	09 80		ora #$80	                ORA #$80
.1a6292	85 26		sta $0826	                STA ARGUMENT1+3
.1a6294					no_neg
.1a6294	c2 20		rep #$20	            REP #$20
.1a6296	fa		plx		                PLX
.1a6297	68		pla		                PLA
.1a6298	28		plp		                PLP
.1a6299	60		rts		            RTS
.1a629a					FP_LN
.1a629a	08		php		                PHP
.1a629b	c2 30		rep #$30	            REP #$30
.1a629d	48		pha		                PHA
.1a629e	da		phx		                PHX
.1a629f	5a		phy		                PHY
.1a62a0	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a62a2	10 1f		bpl $1a62c3	                BPL arg_ok
.1a62a4	08		php		            PHP
.1a62a5	c2 20		rep #$20	            REP #$20
.1a62a7	48		pha		            PHA
.1a62a8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a62ab	5b		tcd		            TCD
.1a62ac	68		pla		            PLA
.1a62ad	28		plp		            PLP
.1a62ae	e2 20		sep #$20	            SEP #$20
.1a62b0	a9 17		lda #$17	            LDA #ERR_DOMAIN
.1a62b2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a62b6	c2 20		rep #$20	            REP #$20
.1a62b8	29 ff 00	and #$00ff	            AND #$00FF
.1a62bb	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a62be	e2 20		sep #$20	            SEP #$20
.1a62c0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a62c3					arg_ok
.1a62c3	c2 30		rep #$30	            REP #$30
.1a62c5	a5 23		lda $0823	                LDA ARGUMENT1
.1a62c7	cf eb 65 1a	cmp $1a65eb	                CMP @l fp_one
.1a62cb	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a62cd	cf ed 65 1a	cmp $1a65ed	                CMP @l fp_one+2
.1a62d1	b0 04		bcs $1a62d7	                BCS gtone
.1a62d3	20 97 5f	jsr $1a5f97	            JSR Q_INV
.1a62d6	18		clc		                CLC
.1a62d7	a9 00 00	lda #$0000	gtone           LDA #0
.1a62da	a8		tay		                TAY
.1a62db	2a		rol a		                ROL             ; Rotate Carry into A; 0 means negate
.1a62dc	48		pha		                PHA
.1a62dd	e2 20		sep #$20	            SEP #$20
.1a62df	a9 00		lda #$00	                LDA #0
.1a62e1	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a62e5	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a62e7	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a62eb	c2 20		rep #$20	            REP #$20
.1a62ed	af 43 66 1a	lda $1a6643	                LDA @l eexp64
.1a62f1	85 29		sta $0829	                STA ARGUMENT2
.1a62f3	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a62f7	af 45 66 1a	lda $1a6645	                LDA @l eexp64+2
.1a62fb	85 2b		sta $082b	                STA ARGUMENT2+2
.1a62fd	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a6301	20 d5 5f	jsr $1a5fd5	            JSR Q_FP_SCALE
.1a6304	8a		txa		                TXA
.1a6305	f0 07		beq $1a630e	                BEQ chk16
.1a6307	0a		asl a		                ASL             ; multiply counter by 64
.1a6308	0a		asl a		                ASL
.1a6309	0a		asl a		                ASL
.1a630a	0a		asl a		                ASL
.1a630b	0a		asl a		                ASL
.1a630c	0a		asl a		                ASL
.1a630d	a8		tay		                TAY
.1a630e	af 47 66 1a	lda $1a6647	chk16           LDA @l eexp16
.1a6312	85 29		sta $0829	                STA ARGUMENT2
.1a6314	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a6318	af 49 66 1a	lda $1a6649	                LDA @l eexp16+2
.1a631c	85 2b		sta $082b	                STA ARGUMENT2+2
.1a631e	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a6322	20 d5 5f	jsr $1a5fd5	            JSR Q_FP_SCALE
.1a6325	8a		txa		                TXA
.1a6326	f0 0b		beq $1a6333	                BEQ chk04
.1a6328	0a		asl a		                ASL             ; multiply counter by 16
.1a6329	0a		asl a		                ASL
.1a632a	0a		asl a		                ASL
.1a632b	0a		asl a		                ASL
.1a632c	85 29		sta $0829	                STA ARGUMENT2   ; and add into total
.1a632e	18		clc		                CLC
.1a632f	98		tya		                TYA
.1a6330	65 29		adc $0829	                ADC ARGUMENT2
.1a6332	a8		tay		                TAY
.1a6333	af 4b 66 1a	lda $1a664b	chk04           LDA @l eexp04
.1a6337	85 29		sta $0829	                STA ARGUMENT2
.1a6339	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a633d	af 4d 66 1a	lda $1a664d	                LDA @l eexp04+2
.1a6341	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6343	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a6347	20 d5 5f	jsr $1a5fd5	            JSR Q_FP_SCALE
.1a634a	8a		txa		                TXA
.1a634b	f0 09		beq $1a6356	                BEQ chk01
.1a634d	0a		asl a		                ASL             ;multiply counter by 4
.1a634e	0a		asl a		                ASL
.1a634f	85 29		sta $0829	                STA ARGUMENT2   ;and add to total
.1a6351	18		clc		                CLC
.1a6352	98		tya		                TYA
.1a6353	65 29		adc $0829	                ADC ARGUMENT2
.1a6355	a8		tay		                TAY
.1a6356	af 4f 66 1a	lda $1a664f	chk01           LDA @l eexp01
.1a635a	85 29		sta $0829	                STA ARGUMENT2
.1a635c	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a6360	af 51 66 1a	lda $1a6651	                LDA @l eexp01+2
.1a6364	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6366	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a636a	20 d5 5f	jsr $1a5fd5	            JSR Q_FP_SCALE
.1a636d	86 29		stx $0829	                STX ARGUMENT2   ; add counter to total
.1a636f	18		clc		                CLC
.1a6370	98		tya		                TYA
.1a6371	65 29		adc $0829	                ADC ARGUMENT2
.1a6373	a8		tay		                TAY
.1a6374	20 2f 61	jsr $1a612f	            JSR Q_FP_LN
.1a6377	a5 23		lda $0823	                LDA ARGUMENT1
.1a6379	85 29		sta $0829	                STA ARGUMENT2
.1a637b	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a637d	85 2b		sta $082b	                STA ARGUMENT2+2
.1a637f	98		tya		                TYA
.1a6380	85 23		sta $0823	                STA ARGUMENT1
.1a6382	64 25		stz $0825	                STZ ARGUMENT1+2
.1a6384	20 c9 5b	jsr $1a5bc9	            JSR ITOF
.1a6387	20 a6 56	jsr $1a56a6	            JSR OP_FP_ADD
.1a638a	68		pla		                PLA
.1a638b	d0 07		bne $1a6394	                BNE done
.1a638d	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a638f	09 00 80	ora #$8000	                ORA #$8000
.1a6392	85 25		sta $0825	                STA ARGUMENT1+2
.1a6394	7a		ply		done            PLY
.1a6395	fa		plx		                PLX
.1a6396	68		pla		                PLA
.1a6397	28		plp		                PLP
.1a6398	60		rts		            RTS
.1a6399					FP_ASIN
.1a6399	08		php		                PHP
.1a639a	c2 30		rep #$30	            REP #$30
.1a639c	48		pha		                PHA
.1a639d	da		phx		                PHX
.1a639e	a5 23		lda $0823	                LDA ARGUMENT1
.1a63a0	85 29		sta $0829	                STA ARGUMENT2
.1a63a2	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a63a4	85 2b		sta $082b	                STA ARGUMENT2+2
.1a63a6	20 61 5f	jsr $1a5f61	            JSR Q_SQ
.1a63a9	8b		phb		                PHB
.1a63aa	e2 20		sep #$20	            SEP #$20
.1a63ac	a9 1a		lda #$1a	                LDA #`asin_coeff
.1a63ae	48		pha		                PHA
.1a63af	ab		plb		                PLB
.1a63b0	c2 20		rep #$20	            REP #$20
.1a63b2	a2 f3 65	ldx #$65f3	                LDX #<>asin_coeff
.1a63b5	a0 05 00	ldy #$0005	                LDY #5
.1a63b8	20 d2 5e	jsr $1a5ed2	            JSR Q_POLY_HR
.1a63bb	ab		plb		                PLB
.1a63bc	20 3c 57	jsr $1a573c	            JSR OP_FP_MUL
.1a63bf	fa		plx		                PLX
.1a63c0	68		pla		                PLA
.1a63c1	28		plp		                PLP
.1a63c2	60		rts		            RTS
.1a63c3					FP_ACOS
.1a63c3	08		php		                PHP
.1a63c4	c2 30		rep #$30	            REP #$30
.1a63c6	48		pha		                PHA
.1a63c7	da		phx		                PHX
.1a63c8	20 99 63	jsr $1a6399	            JSR FP_ASIN
.1a63cb	af 5b 66 1a	lda $1a665b	                LDA @l halfpi
.1a63cf	85 29		sta $0829	                STA ARGUMENT2
.1a63d1	af 5d 66 1a	lda $1a665d	                LDA @l halfpi+2
.1a63d5	85 2b		sta $082b	                STA ARGUMENT2+2
.1a63d7	20 9b 56	jsr $1a569b	            JSR OP_FP_SUB
.1a63da	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a63dc	49 00 80	eor #$8000	                EOR #$8000
.1a63df	85 25		sta $0825	                STA ARGUMENT1+2
.1a63e1	fa		plx		                PLX
.1a63e2	68		pla		                PLA
.1a63e3	28		plp		                PLP
.1a63e4	60		rts		            RTS
.1a63e5					FP_ATAN
.1a63e5	08		php		                PHP
.1a63e6	c2 30		rep #$30	            REP #$30
.1a63e8	48		pha		                PHA
.1a63e9	da		phx		                PHX
.1a63ea	a5 23		lda $0823	                LDA ARGUMENT1
.1a63ec	85 29		sta $0829	                STA ARGUMENT2
.1a63ee	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a63f0	85 2b		sta $082b	                STA ARGUMENT2+2
.1a63f2	20 61 5f	jsr $1a5f61	            JSR Q_SQ
.1a63f5	8b		phb		                PHB
.1a63f6	e2 20		sep #$20	            SEP #$20
.1a63f8	a9 1a		lda #$1a	                LDA #`atan_coeff
.1a63fa	48		pha		                PHA
.1a63fb	ab		plb		                PLB
.1a63fc	c2 20		rep #$20	            REP #$20
.1a63fe	a2 07 66	ldx #$6607	                LDX #<>atan_coeff
.1a6401	a0 05 00	ldy #$0005	                LDY #5
.1a6404	20 d2 5e	jsr $1a5ed2	            JSR Q_POLY_HR
.1a6407	ab		plb		                PLB
.1a6408	20 3c 57	jsr $1a573c	            JSR OP_FP_MUL
.1a640b	fa		plx		                PLX
.1a640c	68		pla		                PLA
.1a640d	28		plp		                PLP
.1a640e	60		rts		            RTS
.1a640f					Q_FP_POW_INT
.1a640f	c2 20		rep #$20	            REP #$20
.1a6411	a5 23		lda $0823	            LDA ARGUMENT1
.1a6413	85 29		sta $0829	            STA ARGUMENT2
.1a6415	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6417	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6419	c2 20		rep #$20	            REP #$20
.1a641b	af eb 65 1a	lda $1a65eb	            LDA @l fp_one
.1a641f	85 23		sta $0823	            STA ARGUMENT1
.1a6421	af ed 65 1a	lda $1a65ed	            LDA @l fp_one+2
.1a6425	85 25		sta $0825	            STA ARGUMENT1+2
.1a6427	8a		txa		loop            TXA
.1a6428	f0 30		beq $1a645a	                BEQ done
.1a642a	4a		lsr a		                LSR
.1a642b	aa		tax		                TAX
.1a642c	90 03		bcc $1a6431	                BCC next
.1a642e	20 3c 57	jsr $1a573c	            JSR OP_FP_MUL
.1a6431					next
.1a6431	c2 20		rep #$20	            REP #$20
.1a6433	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6435	48		pha		            PHA
.1a6436	a5 23		lda $0823	            LDA ARGUMENT1
.1a6438	48		pha		            PHA
.1a6439	c2 20		rep #$20	            REP #$20
.1a643b	a5 29		lda $0829	            LDA ARGUMENT2
.1a643d	85 23		sta $0823	            STA ARGUMENT1
.1a643f	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a6441	85 25		sta $0825	            STA ARGUMENT1+2
.1a6443	20 61 5f	jsr $1a5f61	            JSR Q_SQ
.1a6446	c2 20		rep #$20	            REP #$20
.1a6448	a5 23		lda $0823	            LDA ARGUMENT1
.1a644a	85 29		sta $0829	            STA ARGUMENT2
.1a644c	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a644e	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6450	c2 20		rep #$20	            REP #$20
.1a6452	68		pla		            PLA
.1a6453	85 23		sta $0823	            STA ARGUMENT1
.1a6455	68		pla		            PLA
.1a6456	85 25		sta $0825	            STA ARGUMENT1+2
.1a6458	80 cd		bra $1a6427	                BRA loop
.1a645a					done
.1a645a	60		rts		            RTS
.1a645b					Q_FP_EXP
.1a645b	08		php		                PHP
.1a645c	c2 30		rep #$30	            REP #$30
.1a645e	48		pha		                PHA
.1a645f	da		phx		                PHX
.1a6460	8b		phb		                PHB
.1a6461	e2 20		sep #$20	            SEP #$20
.1a6463	a9 1a		lda #$1a	                LDA #`exp_coeff
.1a6465	48		pha		                PHA
.1a6466	ab		plb		                PLB
.1a6467	c2 20		rep #$20	            REP #$20
.1a6469	a2 1b 66	ldx #$661b	                LDX #<>exp_coeff
.1a646c	5a		phy		                PHY
.1a646d	a0 0a 00	ldy #$000a	                LDY #10
.1a6470	20 d2 5e	jsr $1a5ed2	            JSR Q_POLY_HR
.1a6473	7a		ply		                PLY
.1a6474	ab		plb		                PLB
.1a6475	fa		plx		                PLX
.1a6476	68		pla		                PLA
.1a6477	28		plp		                PLP
.1a6478	60		rts		            RTS
.1a6479					FP_EXP
.1a6479	08		php		                PHP
.1a647a	c2 30		rep #$30	            REP #$30
.1a647c	48		pha		                PHA
.1a647d	da		phx		                PHX
.1a647e	5a		phy		                PHY
.1a647f	a5 23		lda $0823	                LDA ARGUMENT1   ; special case for x==0
.1a6481	05 25		ora $0825	                ORA ARGUMENT1+2
.1a6483	d0 10		bne $1a6495	                BNE notzero
.1a6485	c2 20		rep #$20	            REP #$20
.1a6487	af eb 65 1a	lda $1a65eb	            LDA @l fp_one
.1a648b	85 23		sta $0823	            STA ARGUMENT1
.1a648d	af ed 65 1a	lda $1a65ed	            LDA @l fp_one+2
.1a6491	85 25		sta $0825	            STA ARGUMENT1+2
.1a6493	80 61		bra $1a64f6	                BRA done
.1a6495	a5 25		lda $0825	notzero         LDA ARGUMENT1+2 ; check if negative
.1a6497	29 00 80	and #$8000	                AND #$8000
.1a649a	a8		tay		                TAY             ; Y != 0 -> arg was negative
.1a649b	f0 07		beq $1a64a4	                BEQ notneg
.1a649d	a5 25		lda $0825	                LDA ARGUMENT1+2 ; negate x
.1a649f	29 ff 7f	and #$7fff	                AND #$7FFF
.1a64a2	85 25		sta $0825	                STA ARGUMENT1+2
.1a64a4					notneg
.1a64a4	c2 20		rep #$20	            REP #$20
.1a64a6	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a64a8	48		pha		            PHA
.1a64a9	a5 23		lda $0823	            LDA ARGUMENT1
.1a64ab	48		pha		            PHA
.1a64ac	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a64af	a6 23		ldx $0823	                LDX ARGUMENT1              ; INT(x) now in ARGUMENT1; low 16 bits into X
.1a64b1	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a64b4	c2 20		rep #$20	            REP #$20
.1a64b6	a5 23		lda $0823	            LDA ARGUMENT1
.1a64b8	85 29		sta $0829	            STA ARGUMENT2
.1a64ba	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a64bc	85 2b		sta $082b	            STA ARGUMENT2+2
.1a64be	c2 20		rep #$20	            REP #$20
.1a64c0	68		pla		            PLA
.1a64c1	85 23		sta $0823	            STA ARGUMENT1
.1a64c3	68		pla		            PLA
.1a64c4	85 25		sta $0825	            STA ARGUMENT1+2
.1a64c6	20 9b 56	jsr $1a569b	            JSR OP_FP_SUB
.1a64c9	20 5b 64	jsr $1a645b	            JSR Q_FP_EXP
.1a64cc	c2 20		rep #$20	            REP #$20
.1a64ce	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a64d0	48		pha		            PHA
.1a64d1	a5 23		lda $0823	            LDA ARGUMENT1
.1a64d3	48		pha		            PHA
.1a64d4	c2 20		rep #$20	            REP #$20
.1a64d6	af 4f 66 1a	lda $1a664f	            LDA @leexp01
.1a64da	85 23		sta $0823	            STA ARGUMENT1
.1a64dc	af 51 66 1a	lda $1a6651	            LDA @leexp01+2
.1a64e0	85 25		sta $0825	            STA ARGUMENT1+2
.1a64e2	20 0f 64	jsr $1a640f	            JSR Q_FP_POW_INT
.1a64e5	c2 20		rep #$20	            REP #$20
.1a64e7	68		pla		            PLA
.1a64e8	85 29		sta $0829	            STA ARGUMENT2
.1a64ea	68		pla		            PLA
.1a64eb	85 2b		sta $082b	            STA ARGUMENT2+2
.1a64ed	20 3c 57	jsr $1a573c	            JSR OP_FP_MUL
.1a64f0	98		tya		                TYA
.1a64f1	f0 03		beq $1a64f6	                BEQ done
.1a64f3	20 97 5f	jsr $1a5f97	            JSR Q_INV
.1a64f6	7a		ply		done            PLY
.1a64f7	fa		plx		                PLX
.1a64f8	68		pla		                PLA
.1a64f9	28		plp		                PLP
.1a64fa	60		rts		            RTS
.1a64fb					FP_SQR
.1a64fb	08		php		                PHP
.1a64fc	c2 30		rep #$30	            REP #$30
.1a64fe	48		pha		                PHA
.1a64ff	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6501	10 1f		bpl $1a6522	                BPL arg_ok
.1a6503	08		php		            PHP
.1a6504	c2 20		rep #$20	            REP #$20
.1a6506	48		pha		            PHA
.1a6507	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a650a	5b		tcd		            TCD
.1a650b	68		pla		            PLA
.1a650c	28		plp		            PLP
.1a650d	e2 20		sep #$20	            SEP #$20
.1a650f	a9 17		lda #$17	            LDA #ERR_DOMAIN
.1a6511	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6515	c2 20		rep #$20	            REP #$20
.1a6517	29 ff 00	and #$00ff	            AND #$00FF
.1a651a	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a651d	e2 20		sep #$20	            SEP #$20
.1a651f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6522					arg_ok
.1a6522	c2 30		rep #$30	            REP #$30
.1a6524	05 23		ora $0823	                ORA ARGUMENT1
.1a6526	f0 68		beq $1a6590	                BEQ done
.1a6528	c2 20		rep #$20	            REP #$20
.1a652a	af ef 65 1a	lda $1a65ef	            LDA @l fp_two
.1a652e	85 29		sta $0829	            STA ARGUMENT2
.1a6530	af f1 65 1a	lda $1a65f1	            LDA @l fp_two+2
.1a6534	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6536	e2 20		sep #$20	            SEP #$20
.1a6538	a9 01		lda #$01	                LDA #TYPE_FLOAT
.1a653a	85 2d		sta $082d	                STA ARGTYPE2
.1a653c	c2 20		rep #$20	            REP #$20
.1a653e	c2 20		rep #$20	            REP #$20
.1a6540	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6542	48		pha		            PHA
.1a6543	a5 23		lda $0823	            LDA ARGUMENT1
.1a6545	48		pha		            PHA
.1a6546					loop
.1a6546	20 f1 56	jsr $1a56f1	            JSR OP_FP_DIV
.1a6549	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a654b	c5 2b		cmp $082b	                CMP ARGUMENT2+2
.1a654d	d0 09		bne $1a6558	                BNE more
.1a654f	a5 23		lda $0823	                LDA ARGUMENT1
.1a6551	45 29		eor $0829	                EOR ARGUMENT2
.1a6553	29 f8 ff	and #$fff8	                AND #$FFF8
.1a6556	f0 30		beq $1a6588	                BEQ exitloop
.1a6558					more
.1a6558	20 a6 56	jsr $1a56a6	            JSR OP_FP_ADD
.1a655b	c2 20		rep #$20	            REP #$20
.1a655d	af ef 65 1a	lda $1a65ef	            LDA @l fp_two
.1a6561	85 29		sta $0829	            STA ARGUMENT2
.1a6563	af f1 65 1a	lda $1a65f1	            LDA @l fp_two+2
.1a6567	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6569	20 f1 56	jsr $1a56f1	            JSR OP_FP_DIV
.1a656c	c2 20		rep #$20	            REP #$20
.1a656e	a5 23		lda $0823	            LDA ARGUMENT1
.1a6570	85 29		sta $0829	            STA ARGUMENT2
.1a6572	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6574	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6576	c2 20		rep #$20	            REP #$20
.1a6578	68		pla		            PLA
.1a6579	85 23		sta $0823	            STA ARGUMENT1
.1a657b	68		pla		            PLA
.1a657c	85 25		sta $0825	            STA ARGUMENT1+2
.1a657e	c2 20		rep #$20	            REP #$20
.1a6580	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6582	48		pha		            PHA
.1a6583	a5 23		lda $0823	            LDA ARGUMENT1
.1a6585	48		pha		            PHA
.1a6586	80 be		bra $1a6546	                BRA loop
.1a6588					exitloop
.1a6588	c2 20		rep #$20	            REP #$20
.1a658a	68		pla		            PLA
.1a658b	85 29		sta $0829	            STA ARGUMENT2
.1a658d	68		pla		            PLA
.1a658e	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6590	68		pla		done            PLA
.1a6591	28		plp		                PLP
.1a6592	60		rts		            RTS
.1a6593					cos_coeff
>1a6593	01 0d d0 37			                .dword $37D00D01
>1a6597	61 0b b6 ba			                .dword $BAB60B61
>1a659b	ab aa 2a 3d			                .dword $3D2AAAAB
>1a659f	00 00 00 bf			                .dword $BF000000
>1a65a3	00 00 80 3f			                .dword $3F800000
.1a65a7					sin_coeff
>1a65a7	1d ef 38 36			                .dword $3638EF1D
>1a65ab	01 0d 50 b9			                .dword $B9500D01
>1a65af	89 88 08 3c			                .dword $3C088889
>1a65b3	ab aa 2a be			                .dword $BE2AAAAB
>1a65b7	00 00 80 3f			                .dword $3F800000
.1a65bb					tan_coeff
>1a65bb	a4 27 b3 3c			                .dword $3CB327A4
>1a65bf	d1 0d 5d 3d			                .dword $3D5D0DD1
>1a65c3	89 88 08 3e			                .dword $3E088889
>1a65c7	ab aa aa 3e			                .dword $3EAAAAAB
>1a65cb	00 00 80 3f			                .dword $3F800000
.1a65cf					ln_coeff
>1a65cf	89 88 88 3d			                .dword $3D888889
>1a65d3	d9 89 9d 3d			                .dword $3D9D89D9
>1a65d7	8c 2e ba 3d			                .dword $3DBA2E8C
>1a65db	39 8e e3 3d			                .dword $3DE38E39
>1a65df	25 49 12 3e			                .dword $3E124925
>1a65e3	cd cc 4c 3e			                .dword $3E4CCCCD
>1a65e7	ab aa aa 3e			                .dword $3EAAAAAB
>1a65eb	00 00 80 3f			fp_one          .dword $3F800000
>1a65ef	00 00 00 40			fp_two          .dword $40000000
.1a65f3					asin_coeff
>1a65f3	8e e3 f8 3c			                .dword $3CF8E38E
>1a65f7	6e db 36 3d			                .dword $3D36DB6E
>1a65fb	9a 99 99 3d			                .dword $3D99999A
>1a65ff	ab aa 2a 3e			                .dword $3E2AAAAB
>1a6603	00 00 80 3f			                .dword $3F800000
.1a6607					atan_coeff
>1a6607	39 8e e3 3d			                .dword $3DE38E39
>1a660b	25 49 12 be			                .dword $BE124925
>1a660f	cd cc 4c 3e			                .dword $3E4CCCCD
>1a6613	ab aa aa be			                .dword $BEAAAAAB
>1a6617	00 00 80 3f			                .dword $3F800000
.1a661b					exp_coeff
>1a661b	1d ef 38 36			        .dword $3638EF1D
>1a661f	01 0d d0 37			        .dword $37D00D01
>1a6623	01 0d 50 39			        .dword $39500D01
>1a6627	61 0b b6 3a			        .dword $3AB60B61
>1a662b	89 88 08 3c			        .dword $3C088889
>1a662f	ab aa 2a 3d			        .dword $3D2AAAAB
>1a6633	ab aa 2a 3e			        .dword $3E2AAAAB
>1a6637	00 00 00 3f			        .dword $3F000000
>1a663b	00 00 80 3f			        .dword $3F800000
>1a663f	00 00 80 3f			        .dword $3F800000
>1a6643	c1 2c a1 6d			eexp64          .dword $6DA12CC1
>1a6647	5f 97 07 4b			eexp16          .dword $4B07975F
>1a664b	81 64 5a 42			eexp04          .dword $425A6481
>1a664f	54 f8 2d 40			eexp01          .dword $402DF854
>1a6653	db 0f c9 40			twopi           .dword $40C90FDB
>1a6657	db 0f 49 40			onepi           .dword $40490FDB
>1a665b	db 0f c9 3f			halfpi          .dword $3FC90FDB
>1a665f	db 0f 49 3f			quarterpi       .dword $3F490FDB

;******  Return to file: src\basic816.s


;******  Processing file: src\arrays.s

.1a6663					ARR_ALLOC
.1a6663	08		php		                PHP
.1a6664	20 d4 12	jsr $1a12d4	            JSR HEAP_GETHED
.1a6667	c2 20		rep #$20	            REP #$20
.1a6669	a9 01 00	lda #$0001	                LDA #1                      ; ARGUMENT1 := 1
.1a666c	85 23		sta $0823	                STA ARGUMENT1
.1a666e	a9 00 00	lda #$0000	                LDA #0
.1a6671	85 25		sta $0825	                STA ARGUMENT1+2
.1a6673	e2 20		sep #$20	            SEP #$20
.1a6675	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.1a6679	c2 20		rep #$20	            REP #$20
.1a667b	29 ff 00	and #$00ff	                AND #$00FF
.1a667e	85 8f		sta $088f	                STA MCOUNT                  ; Save it to MCOUNT for later
.1a6680	a8		tay		                TAY                         ; Y := number of dimensions
.1a6681	a2 01 00	ldx #$0001	                LDX #1                      ; X := index to size 0
.1a6684					size_loop
.1a6684	c2 20		rep #$20	            REP #$20
.1a6686	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X           ; ARGUMENT2 := Ith dimension
.1a668a	85 29		sta $0829	                STA ARGUMENT2
.1a668c	a9 00 00	lda #$0000	                LDA #0
.1a668f	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6691	e2 20		sep #$20	            SEP #$20
.1a6693	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a6695	85 2d		sta $082d	                STA ARGTYPE2
.1a6697	c2 20		rep #$20	            REP #$20
.1a6699	20 1f 28	jsr $1a281f	            JSR OP_MULTIPLY
.1a669c	e8		inx		                INX
.1a669d	e8		inx		                INX
.1a669e	88		dey		                DEY
.1a669f	d0 e3		bne $1a6684	                BNE size_loop               ; If there are more dimensions, take the next one
.1a66a1	c2 20		rep #$20	            REP #$20
.1a66a3	a9 04 00	lda #$0004	                LDA #ARGUMENT_SIZE-1        ; Size of a data item (don't include the type code)
.1a66a6	85 29		sta $0829	                STA ARGUMENT2
.1a66a8	a9 00 00	lda #$0000	                LDA #0
.1a66ab	85 2b		sta $082b	                STA ARGUMENT2+2
.1a66ad	20 1f 28	jsr $1a281f	            JSR OP_MULTIPLY
.1a66b0	e2 20		sep #$20	            SEP #$20
.1a66b2	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF             ; SCRATCH := N * 2
.1a66b6	85 0c		sta $080c	                STA SCRATCH
.1a66b8	a9 00		lda #$00	                LDA #0
.1a66ba	85 0d		sta $080d	                STA SCRATCH+1
.1a66bc	c2 20		rep #$20	            REP #$20
.1a66be	06 0c		asl $080c	                ASL SCRATCH
.1a66c0	38		sec		                SEC                         ; ARGUMENT1 := size of the complete block
.1a66c1	a5 23		lda $0823	                LDA ARGUMENT1
.1a66c3	65 0c		adc $080c	                ADC SCRATCH                 ; Size of data area + N*2 + 1 (in carry)
.1a66c5	85 23		sta $0823	                STA ARGUMENT1
.1a66c7	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a66c9	69 00 00	adc #$0000	                ADC #0
.1a66cc	85 25		sta $0825	                STA ARGUMENT1+2
.1a66ce	d0 29		bne $1a66f9	                BNE too_big                 ; size > 16-bit? Yes: throw an error
.1a66d0	e2 20		sep #$20	            SEP #$20
.1a66d2	a5 ea		lda $08ea	                LDA TOFINDTYPE              ; Get the type
.1a66d4	09 80		ora #$80	                ORA #$80                    ; Flip the flag to make it an array of that type
.1a66d6	a6 23		ldx $0823	                LDX ARGUMENT1               ; Get the computed size
.1a66d8	20 98 10	jsr $1a1098	            JSR ALLOC
.1a66db	e2 20		sep #$20	            SEP #$20
.1a66dd	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.1a66e1	87 c0		sta [$08c0]	                STA [CURRBLOCK]             ; Write the number of dimensions to the array's preamble
.1a66e3	a0 01 00	ldy #$0001	                LDY #1
.1a66e6	a2 00 00	ldx #$0000	                LDX #0
.1a66e9					copy_loop
.1a66e9	e2 20		sep #$20	            SEP #$20
.1a66eb	bf 01 4d 00	lda $004d01,x	                LDA @lARRIDXBUF+1,X         ; ARGUMENT2 := Ith dimension
.1a66ef	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y           ; And write the dimension to the array's preamble
.1a66f1	e4 8f		cpx $088f	                CPX MCOUNT                  ; Have we written the last byte?
.1a66f3	f0 23		beq $1a6718	                BEQ null_array              ; Yes: clear the array
.1a66f5	e8		inx		                INX                         ; No: move to the next byte
.1a66f6	c8		iny		                INY
.1a66f7	80 f0		bra $1a66e9	                BRA copy_loop
.1a66f9					too_big
.1a66f9	08		php		            PHP
.1a66fa	c2 20		rep #$20	            REP #$20
.1a66fc	48		pha		            PHA
.1a66fd	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6700	5b		tcd		            TCD
.1a6701	68		pla		            PLA
.1a6702	28		plp		            PLP
.1a6703	e2 20		sep #$20	            SEP #$20
.1a6705	a9 09		lda #$09	            LDA #ERR_RANGE
.1a6707	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a670b	c2 20		rep #$20	            REP #$20
.1a670d	29 ff 00	and #$00ff	            AND #$00FF
.1a6710	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a6713	e2 20		sep #$20	            SEP #$20
.1a6715	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6718					null_array
.1a6718	e2 20		sep #$20	            SEP #$20
.1a671a	38		sec		                SEC                         ; INDEX := pointer to first value
.1a671b	a5 c0		lda $08c0	                LDA CURRBLOCK
.1a671d	67 c0		adc [$08c0]	                ADC [CURRBLOCK]
.1a671f	85 08		sta $0808	                STA INDEX
.1a6721	a5 c1		lda $08c1	                LDA CURRBLOCK+1
.1a6723	69 00		adc #$00	                ADC #0
.1a6725	85 09		sta $0809	                STA INDEX+1
.1a6727	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a6729	69 00		adc #$00	                ADC #0
.1a672b	85 0a		sta $080a	                STA INDEX+2
.1a672d	64 0b		stz $080b	                STZ INDEX+3
.1a672f	c2 20		rep #$20	            REP #$20
.1a6731	a0 05 00	ldy #$0005	                LDY #HEAPOBJ.END            ; SCRATCH := pointer the the first byte after the array
.1a6734	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a6736	85 0c		sta $080c	                STA SCRATCH
.1a6738	e2 20		sep #$20	            SEP #$20
.1a673a	c8		iny		                INY
.1a673b	c8		iny		                INY
.1a673c	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a673e	85 0e		sta $080e	                STA SCRATCH+2
.1a6740	64 0f		stz $080f	                STZ SCRATCH+3
.1a6742					clr_loop
.1a6742	e2 20		sep #$20	            SEP #$20
.1a6744	a9 00		lda #$00	                LDA #0
.1a6746	87 08		sta [$0808]	                STA [INDEX]                 ; Clear the byte
.1a6748	c2 20		rep #$20	            REP #$20
.1a674a	18		clc		                CLC                         ; Increment INDEX
.1a674b	a5 08		lda $0808	                LDA INDEX
.1a674d	69 01 00	adc #$0001	                ADC #1
.1a6750	85 08		sta $0808	                STA INDEX
.1a6752	a5 0a		lda $080a	                LDA INDEX+2
.1a6754	69 00 00	adc #$0000	                ADC #0
.1a6757	85 0a		sta $080a	                STA INDEX+2
.1a6759	c5 0e		cmp $080e	                CMP SCRATCH+2               ; INDEX == SCRATCH?
.1a675b	d0 e5		bne $1a6742	                BNE clr_loop                ; No: write to this next byte
.1a675d	a5 08		lda $0808	                LDA INDEX
.1a675f	c5 0c		cmp $080c	                CMP SCRATCH
.1a6761	d0 df		bne $1a6742	                BNE clr_loop
.1a6763					done
.1a6763	28		plp		                PLP
.1a6764	60		rts		            RTS
.1a6765					ARR_CELL
.1a6765	08		php		                PHP
.1a6766	c2 20		rep #$20	            REP #$20
.1a6768	64 08		stz $0808	                STZ INDEX               ; INDEX := 0
.1a676a	64 0a		stz $080a	                STZ INDEX+2
.1a676c	e2 20		sep #$20	            SEP #$20
.1a676e	af 00 4d 00	lda $004d00	                LDA @l ARRIDXBUF        ; MCOUNT := N (number of dimensions)
.1a6772	85 8f		sta $088f	                STA MCOUNT
.1a6774	64 90		stz $0890	                STZ MCOUNT+1
.1a6776	a2 01 00	ldx #$0001	                LDX #1                  ; X := index to dimension 0
.1a6779	e2 20		sep #$20	            SEP #$20
.1a677b	a7 c0		lda [$08c0]	                LDA [CURRBLOCK]         ; Make sure the dimensions of the array
.1a677d	c5 8f		cmp $088f	                CMP MCOUNT              ; ... match those requested
.1a677f	f0 22		beq $1a67a3	                BEQ dims_match          ; Yes: the dimensions match
.1a6781	a6 8f		ldx $088f	                LDX MCOUNT
.1a6783	00		brk #		                BRK
.1a6784					arg_err
.1a6784	08		php		            PHP
.1a6785	c2 20		rep #$20	            REP #$20
.1a6787	48		pha		            PHA
.1a6788	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a678b	5b		tcd		            TCD
.1a678c	68		pla		            PLA
.1a678d	28		plp		            PLP
.1a678e	e2 20		sep #$20	            SEP #$20
.1a6790	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a6792	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6796	c2 20		rep #$20	            REP #$20
.1a6798	29 ff 00	and #$00ff	            AND #$00FF
.1a679b	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a679e	e2 20		sep #$20	            SEP #$20
.1a67a0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a67a3	c9 01		cmp #$01	dims_match      CMP #1                  ; Check to see if this array is one dimensional
.1a67a5	f0 3a		beq $1a67e1	                BEQ add_last            ; If so, just add the index of the cell to INDEX
.1a67a7	a0 01 00	ldy #$0001	                LDY #1
.1a67aa					index_loop
.1a67aa	e2 20		sep #$20	            SEP #$20
.1a67ac	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; ARGUMENT1 := I_j
.1a67b0	85 23		sta $0823	                STA ARGUMENT1
.1a67b2	64 24		stz $0824	                STZ ARGUMENT1+1
.1a67b4	64 25		stz $0825	                STZ ARGUMENT1+2
.1a67b6	64 26		stz $0826	                STZ ARGUMENT1+3
.1a67b8	b7 c0		lda [$08c0],y	                LDA [CURRBLOCK],Y       ; ARGUMENT2 := D_j
.1a67ba	85 29		sta $0829	                STA ARGUMENT2
.1a67bc	64 2a		stz $082a	                STZ ARGUMENT2+1
.1a67be	64 2b		stz $082b	                STZ ARGUMENT2+2
.1a67c0	64 2c		stz $082c	                STZ ARGUMENT2+3
.1a67c2	a5 23		lda $0823	                LDA ARGUMENT1
.1a67c4	c5 29		cmp $0829	                CMP ARGUMENT2           ; Is I_j >= D_j
.1a67c6	b0 68		bcs $1a6830	                BGE range_err           ; Yes: throw an out-of-range error
.1a67c8	20 1f 28	jsr $1a281f	            JSR OP_MULTIPLY
.1a67cb	c2 20		rep #$20	            REP #$20
.1a67cd	18		clc		                CLC                     ; INDEX := INDEX + ARGUMENT1
.1a67ce	a5 08		lda $0808	                LDA INDEX
.1a67d0	65 23		adc $0823	                ADC ARGUMENT1
.1a67d2	85 08		sta $0808	                STA INDEX
.1a67d4	a5 0a		lda $080a	                LDA INDEX+2
.1a67d6	65 25		adc $0825	                ADC ARGUMENT1+2
.1a67d8	85 0a		sta $080a	                STA INDEX+2
.1a67da	e8		inx		                INX
.1a67db	e8		inx		                INX
.1a67dc	c8		iny		                INY
.1a67dd	c4 8f		cpy $088f	                CPY MCOUNT              ; Are we on the last index?
.1a67df	d0 c9		bne $1a67aa	                BNE index_loop          ; No: move to the next index and try again
.1a67e1					add_last
.1a67e1	e2 20		sep #$20	            SEP #$20
.1a67e3	18		clc		                CLC
.1a67e4	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; INDEX := INDEX + I_(n-1)
.1a67e8	85 90		sta $0890	                STA MCOUNT+1
.1a67ea	65 08		adc $0808	                ADC INDEX
.1a67ec	85 08		sta $0808	                STA INDEX
.1a67ee	a5 09		lda $0809	                LDA INDEX+1
.1a67f0	69 00		adc #$00	                ADC #0
.1a67f2	85 09		sta $0809	                STA INDEX+1
.1a67f4	c2 20		rep #$20	            REP #$20
.1a67f6	a5 0a		lda $080a	                LDA INDEX+2
.1a67f8	69 00 00	adc #$0000	                ADC #0
.1a67fb	85 0a		sta $080a	                STA INDEX+2
.1a67fd	c2 20		rep #$20	            REP #$20
.1a67ff	06 08		asl $0808	                ASL INDEX               ; INDEX := INDEX * 4 (size of a value)
.1a6801	26 0a		rol $080a	                ROL INDEX+2
.1a6803	06 08		asl $0808	                ASL INDEX
.1a6805	26 0a		rol $080a	                ROL INDEX+2
.1a6807	e2 20		sep #$20	            SEP #$20
.1a6809	38		sec		                SEC
.1a680a	a5 08		lda $0808	                LDA INDEX
.1a680c	65 8f		adc $088f	                ADC MCOUNT
.1a680e	85 08		sta $0808	                STA INDEX
.1a6810	a5 09		lda $0809	                LDA INDEX+1
.1a6812	69 00		adc #$00	                ADC #0
.1a6814	85 09		sta $0809	                STA INDEX+1
.1a6816	c2 20		rep #$20	            REP #$20
.1a6818	a5 0a		lda $080a	                LDA INDEX+2
.1a681a	69 00 00	adc #$0000	                ADC #0
.1a681d	85 0a		sta $080a	                STA INDEX+2
.1a681f	18		clc		                CLC                     ; INDEX := INDEX + CURRBLOCK (point to the address desired)
.1a6820	a5 08		lda $0808	                LDA INDEX
.1a6822	65 c0		adc $08c0	                ADC CURRBLOCK
.1a6824	85 08		sta $0808	                STA INDEX
.1a6826	e2 20		sep #$20	            SEP #$20
.1a6828	a5 0a		lda $080a	                LDA INDEX+2
.1a682a	65 c2		adc $08c2	                ADC CURRBLOCK+2
.1a682c	85 0a		sta $080a	                STA INDEX+2
.1a682e	28		plp		                PLP
.1a682f	60		rts		            RTS
.1a6830					range_err
.1a6830	08		php		            PHP
.1a6831	c2 20		rep #$20	            REP #$20
.1a6833	48		pha		            PHA
.1a6834	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6837	5b		tcd		            TCD
.1a6838	68		pla		            PLA
.1a6839	28		plp		            PLP
.1a683a	e2 20		sep #$20	            SEP #$20
.1a683c	a9 09		lda #$09	            LDA #ERR_RANGE
.1a683e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6842	c2 20		rep #$20	            REP #$20
.1a6844	29 ff 00	and #$00ff	            AND #$00FF
.1a6847	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a684a	e2 20		sep #$20	            SEP #$20
.1a684c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a684f					ARR_SET
.1a684f	08		php		                PHP
.1a6850	20 d4 12	jsr $1a12d4	            JSR HEAP_GETHED
.1a6853	e2 20		sep #$20	            SEP #$20
.1a6855	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.1a6858	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a685a	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.1a685c	c9 02		cmp #$02	                CMP #TYPE_STRING    ; Is it a string array?
.1a685e	d0 05		bne $1a6865	                BNE chk_integer
.1a6860	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6863	80 10		bra $1a6875	                BRA save_type
.1a6865	c9 00		cmp #$00	chk_integer     CMP #TYPE_INTEGER   ; Is it an integer array?
.1a6867	d0 05		bne $1a686e	                BNE chk_float
.1a6869	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a686c	80 07		bra $1a6875	                BRA save_type
.1a686e	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT     ; Is it an float array?
.1a6870	d0 2b		bne $1a689d	                BNE type_mismatch   ; No: throw a type mismatch error... something strange...
.1a6872	20 84 07	jsr $1a0784	            JSR ASS_ARG1_FLOAT
.1a6875	a5 27		lda $0827	save_type       LDA ARGTYPE1        ; Save the type
.1a6877	48		pha		                PHA
.1a6878	c2 20		rep #$20	            REP #$20
.1a687a	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Save ARGUMENT1
.1a687c	48		pha		                PHA
.1a687d	a5 23		lda $0823	                LDA ARGUMENT1
.1a687f	48		pha		                PHA
.1a6880	20 65 67	jsr $1a6765	            JSR ARR_CELL
.1a6883	68		pla		                PLA                 ; Restore ARGUMENT1
.1a6884	85 23		sta $0823	                STA ARGUMENT1
.1a6886	68		pla		                PLA
.1a6887	85 25		sta $0825	                STA ARGUMENT1+2
.1a6889	e2 20		sep #$20	            SEP #$20
.1a688b	68		pla		                PLA
.1a688c	85 27		sta $0827	                STA ARGTYPE1
.1a688e	c2 20		rep #$20	            REP #$20
.1a6890	a5 23		lda $0823	                LDA ARGUMENT1       ; Set the value in the cell
.1a6892	87 08		sta [$0808]	                STA [INDEX]
.1a6894	a0 02 00	ldy #$0002	                LDY #2
.1a6897	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6899	97 08		sta [$0808],y	                STA [INDEX],Y
.1a689b	28		plp		                PLP
.1a689c	60		rts		            RTS
.1a689d					type_mismatch
.1a689d	08		php		            PHP
.1a689e	c2 20		rep #$20	            REP #$20
.1a68a0	48		pha		            PHA
.1a68a1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a68a4	5b		tcd		            TCD
.1a68a5	68		pla		            PLA
.1a68a6	28		plp		            PLP
.1a68a7	e2 20		sep #$20	            SEP #$20
.1a68a9	a9 04		lda #$04	            LDA #ERR_TYPE
.1a68ab	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a68af	c2 20		rep #$20	            REP #$20
.1a68b1	29 ff 00	and #$00ff	            AND #$00FF
.1a68b4	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a68b7	e2 20		sep #$20	            SEP #$20
.1a68b9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a68bc					ARR_REF
.1a68bc	08		php		                PHP
.1a68bd	20 d4 12	jsr $1a12d4	            JSR HEAP_GETHED
.1a68c0	f4 00 00	pea #$0000	                PEA #0              ; Make room on the stack that ARR_CELL expects
.1a68c3	f4 00 00	pea #$0000	                PEA #0
.1a68c6	e2 20		sep #$20	            SEP #$20
.1a68c8	48		pha		                PHA
.1a68c9	20 65 67	jsr $1a6765	            JSR ARR_CELL
.1a68cc	e2 20		sep #$20	            SEP #$20
.1a68ce	68		pla		                PLA
.1a68cf	c2 20		rep #$20	            REP #$20
.1a68d1	68		pla		                PLA
.1a68d2	68		pla		                PLA
.1a68d3	c2 20		rep #$20	            REP #$20
.1a68d5	a7 08		lda [$0808]	                LDA [INDEX]         ; Get the value in the cell
.1a68d7	85 23		sta $0823	                STA ARGUMENT1
.1a68d9	a0 02 00	ldy #$0002	                LDY #2
.1a68dc	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a68de	85 25		sta $0825	                STA ARGUMENT1+2
.1a68e0	e2 20		sep #$20	            SEP #$20
.1a68e2	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.1a68e5	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a68e7	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.1a68e9	85 27		sta $0827	                STA ARGTYPE1        ; Set the type of the return value
.1a68eb	20 28 18	jsr $1a1828	            JSR STR_NORMAL
.1a68ee	28		plp		                PLP
.1a68ef	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\dos.s

.0000					DIRENTRY
>0000					SHORTNAME               .fill 11        ; $00 - The short name of the file (8 name, 3 extension)
>000b					ATTRIBUTE               .byte ?         ; $0B - The attribute bits
>000c					IGNORED1                .word ?         ; $0C - Unused (by us) bytes
>000e					CREATE_TIME             .word ?         ; $0E - Creation time
>0010					CREATE_DATE             .word ?         ; $10 - Creation date
>0012					ACCESS_DATE             .word ?         ; $12 - Last access date
>0014					CLUSTER_H               .word ?         ; $14 - High word of the first cluster #
>0016					MODIFIED_TIME           .word ?         ; $16 - Last modified time
>0018					MODIFIED_DATE           .word ?         ; $18 - Last modified date
>001a					CLUSTER_L               .word ?         ; $1A - Low word of the first cluster #
>001c					SIZE                    .dword ?        ; $1C - The size of the file (in bytes)
=$01					DOS_ATTR_RO = $01                       ; File is read-only
=$02					DOS_ATTR_HIDDEN = $02                   ; File is hidden
=$04					DOS_ATTR_SYSTEM = $04                   ; File is a system file
=$08					DOS_ATTR_VOLUME = $08                   ; Entry is the volume label
=$10					DOS_ATTR_DIR = $10                      ; Entry is a directory
=$20					DOS_ATTR_ARCH = $20                     ; Entry has changed since last backup
=$0f					DOS_ATTR_LONGNAME = $0F                 ; Entry is the long file name
=$e5					DOS_DIR_ENT_UNUSED = $E5                ; Marker for an unused directory entry
.0000					FILEDESC
>0000					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>0001					DEV                 .byte ?             ; The ID of the device holding the file
>0002					PATH                .dword ?            ; Pointer to a NULL terminated path string
>0006					CLUSTER             .dword ?            ; The current cluster of the file.
>000a					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>000e					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>0012					FILESIZE            .dword ?            ; The size of the file
>0016					CREATE_DATE         .word ?             ; The creation date of the file
>0018					CREATE_TIME         .word ?             ; The creation time of the file
>001a					MODIFIED_DATE       .word ?             ; The modification date of the file
>001c					MODIFIED_TIME       .word ?             ; The modification time of the file
=$01					FD_STAT_READ = $01                      ; The file is readable
=$02					FD_STAT_WRITE = $02                     ; The file is writable
=$40					FD_STAT_OPEN = $40                      ; The file is open
=$60					FD_STAT_ERROR = $60                     ; The file is in an error condition
=$80					FD_STAT_EOF = $80                       ; The file cursor is at the end of the file
>1af073					CLUSTER_BUFF    .fill 512           ; A buffer for cluster read/write operations
.1af273					FD_IN
>1af273					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>1af274					DEV                 .byte ?             ; The ID of the device holding the file
>1af275					PATH                .dword ?            ; Pointer to a NULL terminated path string
>1af279					CLUSTER             .dword ?            ; The current cluster of the file.
>1af27d					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>1af281					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>1af285					FILESIZE            .dword ?            ; The size of the file
>1af289					CREATE_DATE         .word ?             ; The creation date of the file
>1af28b					CREATE_TIME         .word ?             ; The creation time of the file
>1af28d					MODIFIED_DATE       .word ?             ; The modification date of the file
>1af28f					MODIFIED_TIME       .word ?             ; The modification time of the file
.1a68f0					PR_FILESIZE
.1a68f0	da		phx		                PHX
.1a68f1	0b		phd		                PHD
.1a68f2	08		php		                PHP
.1a68f3	08		php		            PHP
.1a68f4	c2 20		rep #$20	            REP #$20
.1a68f6	48		pha		            PHA
.1a68f7	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a68fa	5b		tcd		            TCD
.1a68fb	68		pla		            PLA
.1a68fc	28		plp		            PLP
.1a68fd	c2 30		rep #$30	            REP #$30
.1a68ff	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6901	89 f0 ff	bit #$fff0	                BIT #$FFF0              ; Check to see if the amount is in MB range
.1a6904	d0 29		bne $1a692f	                BNE pr_mb               ; If so, print it in MBs
.1a6906	89 0f 00	bit #$000f	                BIT #$000F              ; Check to see if the amount is in KB range
.1a6909	d0 0c		bne $1a6917	                BNE pr_kb
.1a690b	a5 23		lda $0823	                LDA ARGUMENT1
.1a690d	89 00 fc	bit #$fc00	                BIT #$FC00
.1a6910	d0 05		bne $1a6917	                BNE pr_kb               ; If so, print it in KBs
.1a6912					pr_regular
.1a6912	20 e3 45	jsr $1a45e3	            JSR PR_INTEGER
.1a6915	80 2e		bra $1a6945	                BRA done
.1a6917	a2 0a 00	ldx #$000a	pr_kb           LDX #10                 ; Shift so the amount in KB is in ARGUMENT1
.1a691a	46 25		lsr $0825	kb_shift        LSR ARGUMENT1+2
.1a691c	66 23		ror $0823	                ROR ARGUMENT1
.1a691e	ca		dex		                DEX
.1a691f	d0 f9		bne $1a691a	                BNE kb_shift
.1a6921	20 e3 45	jsr $1a45e3	            JSR PR_INTEGER
.1a6924	e2 20		sep #$20	            SEP #$20
.1a6926	a9 4b		lda #$4b	                LDA #'K'
.1a6928	20 18 00	jsr $1a0018	            JSR PRINTC
.1a692b	c2 20		rep #$20	            REP #$20
.1a692d	80 16		bra $1a6945	                BRA done
.1a692f	a2 14 00	ldx #$0014	pr_mb           LDX #20                 ; Shift so the amount in MB is in ARGUMENT1
.1a6932	46 25		lsr $0825	mb_shift        LSR ARGUMENT1+2
.1a6934	66 23		ror $0823	                ROR ARGUMENT1
.1a6936	ca		dex		                DEX
.1a6937	d0 f9		bne $1a6932	                BNE mb_shift
.1a6939	20 e3 45	jsr $1a45e3	            JSR PR_INTEGER
.1a693c	e2 20		sep #$20	            SEP #$20
.1a693e	a9 4d		lda #$4d	                LDA #'M'
.1a6940	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6943	c2 20		rep #$20	            REP #$20
.1a6945	28		plp		done            PLP
.1a6946	2b		pld		                PLD
.1a6947	fa		plx		                PLX
.1a6948	60		rts		            RTS
.1a6949					CMD_DIR
.1a6949	0b		phd		                PHD
.1a694a	08		php		                PHP
.1a694b	c2 30		rep #$30	            REP #$30
.1a694d	a9 00 00	lda #$0000	                LDA #0                      ; Zero out the pagination line count
.1a6950	8f b6 08 00	sta $0008b6	                STA @l LINECOUNT
.1a6954	8f b8 08 00	sta $0008b8	                STA @l LINECOUNT+2
.1a6958	e2 20		sep #$20	            SEP #$20
.1a695a	20 43 22	jsr $1a2243	            JSR PEEK_TOK
.1a695d	c9 00		cmp #$00	                CMP #0
.1a695f	f0 08		beq $1a6969	                BEQ set_null                ; If none provided, set the path to empty
.1a6961	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a6964	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6967	80 11		bra $1a697a	                BRA set_fd
.1a6969					set_null
.1a6969	c2 20		rep #$20	            REP #$20
.1a696b	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT1 to the NULL string
.1a696e	85 23		sta $0823	                STA ARGUMENT1
.1a6970	85 25		sta $0825	                STA ARGUMENT1+2
.1a6972	e2 20		sep #$20	            SEP #$20
.1a6974	a9 02		lda #$02	                LDA #TYPE_STRING
.1a6976	85 27		sta $0827	                STA ARGTYPE1
.1a6978	c2 20		rep #$20	            REP #$20
.1a697a					set_fd
.1a697a	20 aa 6a	jsr $1a6aaa	            JSR SETFILEDESC
.1a697d	22 08 11 00	jsl $001108	                JSL FK_DIROPEN              ; Open up the directory
.1a6981	b0 22		bcs $1a69a5	                BCS pr_first
.1a6983	20 5b 6b	jsr $1a6b5b	            JSR SET_DOSSTAT
.1a6986	08		php		            PHP
.1a6987	c2 20		rep #$20	            REP #$20
.1a6989	48		pha		            PHA
.1a698a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a698d	5b		tcd		            TCD
.1a698e	68		pla		            PLA
.1a698f	28		plp		            PLP
.1a6990	e2 20		sep #$20	            SEP #$20
.1a6992	a9 10		lda #$10	            LDA #ERR_DIRECTORY
.1a6994	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6998	c2 20		rep #$20	            REP #$20
.1a699a	29 ff 00	and #$00ff	            AND #$00FF
.1a699d	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a69a0	e2 20		sep #$20	            SEP #$20
.1a69a2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a69a5					pr_first
.1a69a5	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a69a8					pr_entry
.1a69a8	08		php		            PHP
.1a69a9	c2 20		rep #$20	            REP #$20
.1a69ab	48		pha		            PHA
.1a69ac	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.1a69af	5b		tcd		            TCD
.1a69b0	68		pla		            PLA
.1a69b1	28		plp		            PLP
.1a69b2	e2 20		sep #$20	            SEP #$20
.1a69b4	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Start with the file name
.1a69b7	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the initial character of the name
.1a69b9	d0 03		bne $1a69be	                BNE chk_unused
.1a69bb	82 a9 00	brl $1a6a67	                BRL done                    ; If it's NULL, we're done
.1a69be	c9 e5		cmp #$e5	chk_unused      CMP #DOS_DIR_ENT_UNUSED     ; Is it the unusued code?
.1a69c0	d0 03		bne $1a69c5	                BNE chk_attributes
.1a69c2	82 96 00	brl $1a6a5b	                BRL next_entry              ; Yes: go to the next entry
.1a69c5	a0 0b 00	ldy #$000b	chk_attributes  LDY #DIRENTRY.ATTRIBUTE
.1a69c8	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute byte
.1a69ca	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.1a69cc	f0 03		beq $1a69d1	                BEQ chk_hidden
.1a69ce	82 a9 00	brl $1a6a7a	                BRL pr_volume               ; Print the volume label
.1a69d1	89 02		bit #$02	chk_hidden      BIT #DOS_ATTR_HIDDEN        ; Is it a hidden file?
.1a69d3	f0 03		beq $1a69d8	                BEQ chk_long
.1a69d5	82 83 00	brl $1a6a5b	                BRL next_entry              ; Yes: go to the next entry
.1a69d8	29 0f		and #$0f	chk_long        AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.1a69da	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.1a69dc	d0 03		bne $1a69e1	                BNE get_short_name
.1a69de	82 7a 00	brl $1a6a5b	                BRL next_entry              ; Yes: go to the next entry
.1a69e1	a0 00 00	ldy #$0000	get_short_name  LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.1a69e4	b7 18		lda [$0338],y	pr_name_loop    LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.1a69e6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a69e9	c8		iny		                INY                         ; Move to the next character
.1a69ea	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.1a69ed	d0 f5		bne $1a69e4	                BNE pr_name_loop            ; No: print this new character
.1a69ef	a9 20		lda #$20	                LDA #' '                    ; Print the separator
.1a69f1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a69f4	a0 08 00	ldy #$0008	                LDY #DIRENTRY.SHORTNAME+8   ; Move to the first of the extension characters
.1a69f7	b7 18		lda [$0338],y	pr_ext_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.1a69f9	20 18 00	jsr $1a0018	                JSR PRINTC                  ; Otherwise: print it.
.1a69fc	c8		iny		                INY                         ; Move to the next character
.1a69fd	c0 0b 00	cpy #$000b	                CPY #DIRENTRY.SHORTNAME+11  ; Are we at the end of the extension portion?
.1a6a00	d0 f5		bne $1a69f7	                BNE pr_ext_loop             ; No: print this new character
.1a6a02	a9 09		lda #$09	pr_tab1         LDA #CHAR_TAB               ; Print a TAB
.1a6a04	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6a07	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.1a6a0a	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.1a6a0c	89 10		bit #$10	                BIT #DOS_ATTR_DIR           ; Is it a directory?
.1a6a0e	d0 1e		bne $1a6a2e	                BNE pr_attr                 ; Yes: skip printing a file size
.1a6a10	c2 20		rep #$20	            REP #$20
.1a6a12	a0 1c 00	ldy #$001c	                LDY #DIRENTRY.SIZE
.1a6a15	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the file size
.1a6a17	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.1a6a1b	c8		iny		                INY
.1a6a1c	c8		iny		                INY
.1a6a1d	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y
.1a6a1f	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.1a6a23	e2 20		sep #$20	            SEP #$20
.1a6a25	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a6a27	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.1a6a2b	20 f0 68	jsr $1a68f0	            JSR PR_FILESIZE
.1a6a2e	a9 09		lda #$09	pr_attr         LDA #CHAR_TAB               ; Print a TAB
.1a6a30	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6a33	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.1a6a36	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.1a6a38	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.1a6a3a	d0 1c		bne $1a6a58	                BNE end_entry               ; Yes: we're done printing this entry
.1a6a3c	89 01		bit #$01	chk_read        BIT #DOS_ATTR_RO            ; Is it a read-only file?
.1a6a3e	f0 05		beq $1a6a45	                BEQ chk_system
.1a6a40	a9 52		lda #$52	                LDA #'R'                    ; Yes: print an R
.1a6a42	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6a45	89 04		bit #$04	chk_system      BIT #DOS_ATTR_SYSTEM        ; Is it System file?
.1a6a47	f0 05		beq $1a6a4e	                BEQ chk_directory
.1a6a49	a9 53		lda #$53	                LDA #'S'                    ; Yes: print an S
.1a6a4b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6a4e	89 10		bit #$10	chk_directory   BIT #DOS_ATTR_DIR           ; Is it a directory?
.1a6a50	f0 05		beq $1a6a57	                BEQ pr_tab2
.1a6a52	a9 44		lda #$44	                LDA #'D'                    ; Yes: print a D
.1a6a54	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6a57	ea		nop		pr_tab2         NOP
.1a6a58					end_entry
.1a6a58	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a6a5b					next_entry
.1a6a5b	20 b3 03	jsr $1a03b3	            JSR PAGINATE
.1a6a5e	22 0c 11 00	jsl $00110c	                JSL FK_DIRNEXT
.1a6a62	90 03		bcc $1a6a67	                BCC done
.1a6a64	82 41 ff	brl $1a69a8	                BRL pr_entry
.1a6a67					done
.1a6a67	20 5b 6b	jsr $1a6b5b	            JSR SET_DOSSTAT
.1a6a6a	08		php		            PHP
.1a6a6b	c2 20		rep #$20	            REP #$20
.1a6a6d	48		pha		            PHA
.1a6a6e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6a71	5b		tcd		            TCD
.1a6a72	68		pla		            PLA
.1a6a73	28		plp		            PLP
.1a6a74	20 27 21	jsr $1a2127	            JSR SKIPSTMT
.1a6a77	28		plp		                PLP
.1a6a78	2b		pld		                PLD
.1a6a79	60		rts		            RTS
.1a6a7a					pr_volume
.1a6a7a	08		php		            PHP
.1a6a7b	c2 20		rep #$20	            REP #$20
.1a6a7d	48		pha		            PHA
.1a6a7e	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.1a6a81	5b		tcd		            TCD
.1a6a82	68		pla		            PLA
.1a6a83	28		plp		            PLP
.1a6a84	e2 20		sep #$20	            SEP #$20
.1a6a86	29 0f		and #$0f	                AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.1a6a88	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.1a6a8a	f0 cf		beq $1a6a5b	                BEQ next_entry              ; Yes: skip it
.1a6a8c	a9 5b		lda #$5b	pr_lbracket     LDA #'['
.1a6a8e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6a91	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.1a6a94	b7 18		lda [$0338],y	pr_vol_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.1a6a96	c9 20		cmp #$20	                CMP #CHAR_SP                ; Is it a blank?
.1a6a98	f0 09		beq $1a6aa3	                BEQ pr_rbracket             ; Yes: end the name and print the dot
.1a6a9a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6a9d	c8		iny		                INY                         ; Move to the next character
.1a6a9e	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.1a6aa1	d0 f1		bne $1a6a94	                BNE pr_vol_loop             ; No: print this new character
.1a6aa3	a9 5d		lda #$5d	pr_rbracket     LDA #']'                    ; Print a close bracket
.1a6aa5	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6aa8	80 ae		bra $1a6a58	                BRA end_entry               ; And try to get the next entry
.1a6aaa					SETFILEDESC
.1a6aaa	0b		phd		                PHD
.1a6aab	08		php		                PHP
.1a6aac	08		php		            PHP
.1a6aad	c2 20		rep #$20	            REP #$20
.1a6aaf	48		pha		            PHA
.1a6ab0	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.1a6ab3	5b		tcd		            TCD
.1a6ab4	68		pla		            PLA
.1a6ab5	28		plp		            PLP
.1a6ab6	c2 30		rep #$30	            REP #$30
.1a6ab8	a9 73 f2	lda #$f273	                LDA #<>FD_IN            ; Point to the file descriptor
.1a6abb	85 20		sta $0340	                STA DOS_FD_PTR
.1a6abd	a9 1a 00	lda #$001a	                LDA #`FD_IN
.1a6ac0	85 22		sta $0342	                STA DOS_FD_PTR+2
.1a6ac2	a0 00 00	ldy #$0000	                LDY #0                  ; Fille the file descriptor with 0
.1a6ac5	e2 20		sep #$20	            SEP #$20
.1a6ac7	a9 00		lda #$00	                LDA #0
.1a6ac9	97 20		sta [$0340],y	zero_loop       STA [DOS_FD_PTR],Y
.1a6acb	c8		iny		                INY
.1a6acc	c0 1e 00	cpy #$001e	                CPY #SIZE(FILEDESC)
.1a6acf	d0 f8		bne $1a6ac9	                BNE zero_loop
.1a6ad1	c2 20		rep #$20	            REP #$20
.1a6ad3	a9 73 f0	lda #$f073	                LDA #<>CLUSTER_BUFF     ; Point to the cluster buffer
.1a6ad6	8f 81 f2 1a	sta $1af281	                STA @l FD_IN.BUFFER
.1a6ada	a9 1a 00	lda #$001a	                LDA #`CLUSTER_BUFF
.1a6add	8f 83 f2 1a	sta $1af283	                STA @l FD_IN.BUFFER+2
.1a6ae1	af 23 08 00	lda $000823	                LDA @l ARGUMENT1        ; Point the file desriptor to the path
.1a6ae5	8f 75 f2 1a	sta $1af275	                STA @l FD_IN.PATH
.1a6ae9	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a6aed	8f 77 f2 1a	sta $1af277	                STA @l FD_IN.PATH+2
.1a6af1	28		plp		                PLP
.1a6af2	2b		pld		                PLD
.1a6af3	60		rts		            RTS
.1a6af4					S_BLOAD
.1a6af4	08		php		                PHP
.1a6af5	c2 30		rep #$30	            REP #$30
.1a6af7	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a6afa	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a6afd	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6b00	20 aa 6a	jsr $1a6aaa	            JSR SETFILEDESC
.1a6b03	e2 20		sep #$20	            SEP #$20
.1a6b05	a9 2c		lda #$2c	                LDA #','
.1a6b07	85 37		sta $0837	                STA TARGETTOK
.1a6b09	20 24 22	jsr $1a2224	            JSR OPT_TOK
.1a6b0c	b0 0f		bcs $1a6b1d	                BCS get_dest
.1a6b0e	c2 20		rep #$20	            REP #$20
.1a6b10	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set destination address to something "safe"
.1a6b13	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a6b17	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a6b1b	80 17		bra $1a6b34	                BRA do_load
.1a6b1d					get_dest
.1a6b1d	20 e2 20	jsr $1a20e2	            JSR INCBIP
.1a6b20	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a6b23	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a6b26	c2 20		rep #$20	            REP #$20
.1a6b28	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the destination address
.1a6b2a	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a6b2e	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6b30	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a6b34	22 18 11 00	jsl $001118	do_load         JSL FK_LOAD                 ; Attempt to load the file
.1a6b38	b0 1f		bcs $1a6b59	                BCS done
.1a6b3a	08		php		            PHP
.1a6b3b	c2 20		rep #$20	            REP #$20
.1a6b3d	48		pha		            PHA
.1a6b3e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6b41	5b		tcd		            TCD
.1a6b42	68		pla		            PLA
.1a6b43	28		plp		            PLP
.1a6b44	e2 20		sep #$20	            SEP #$20
.1a6b46	a9 11		lda #$11	            LDA #ERR_LOAD
.1a6b48	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6b4c	c2 20		rep #$20	            REP #$20
.1a6b4e	29 ff 00	and #$00ff	            AND #$00FF
.1a6b51	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a6b54	e2 20		sep #$20	            SEP #$20
.1a6b56	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6b59	28		plp		done            PLP
.1a6b5a	60		rts		            RTS
.1a6b5b					SET_DOSSTAT
.1a6b5b	8b		phb		                PHB
.1a6b5c	0b		phd		                PHD
.1a6b5d	08		php		                PHP
.1a6b5e	08		php		            PHP
.1a6b5f	c2 20		rep #$20	            REP #$20
.1a6b61	48		pha		            PHA
.1a6b62	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6b65	5b		tcd		            TCD
.1a6b66	68		pla		            PLA
.1a6b67	28		plp		            PLP
.1a6b68	08		php		            PHP
.1a6b69	e2 20		sep #$20	            SEP #$20
.1a6b6b	48		pha		            PHA
.1a6b6c	a9 00		lda #$00	            LDA #BASIC_BANK
.1a6b6e	48		pha		            PHA
.1a6b6f	ab		plb		            PLB
.1a6b70	68		pla		            PLA
.1a6b71	28		plp		            PLP
.1a6b72	e2 20		sep #$20	            SEP #$20
.1a6b74	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS           ; Get the DOS status code
.1a6b78	85 23		sta $0823	                STA ARGUMENT1
.1a6b7a	a9 00		lda #$00	                LDA #0
.1a6b7c	85 24		sta $0824	                STA ARGUMENT1+1
.1a6b7e	85 25		sta $0825	                STA ARGUMENT1+2
.1a6b80	85 26		sta $0826	                STA ARGUMENT1+3
.1a6b82	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a6b84	85 27		sta $0827	                STA ARGTYPE1
.1a6b86	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (DOSSTAT)
.1a6b88	a9 1a		lda #$1a	                LDA #`dosstat_name
.1a6b8a	85 e9		sta $08e9	                STA TOFIND+2
.1a6b8c	c2 20		rep #$20	            REP #$20
.1a6b8e	a9 be 6b	lda #$6bbe	                LDA #<>dosstat_name
.1a6b91	85 e7		sta $08e7	                STA TOFIND
.1a6b93	20 48 53	jsr $1a5348	            JSR VAR_SET
.1a6b96	e2 20		sep #$20	            SEP #$20
.1a6b98	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS          ; Get the BIOS status code
.1a6b9c	85 23		sta $0823	                STA ARGUMENT1
.1a6b9e	a9 00		lda #$00	                LDA #0
.1a6ba0	85 24		sta $0824	                STA ARGUMENT1+1
.1a6ba2	85 25		sta $0825	                STA ARGUMENT1+2
.1a6ba4	85 26		sta $0826	                STA ARGUMENT1+3
.1a6ba6	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a6ba8	85 27		sta $0827	                STA ARGTYPE1
.1a6baa	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BIOSSTAT)
.1a6bac	a9 1a		lda #$1a	                LDA #`biosstat_name
.1a6bae	85 e9		sta $08e9	                STA TOFIND+2
.1a6bb0	c2 20		rep #$20	            REP #$20
.1a6bb2	a9 c6 6b	lda #$6bc6	                LDA #<>biosstat_name
.1a6bb5	85 e7		sta $08e7	                STA TOFIND
.1a6bb7	20 48 53	jsr $1a5348	            JSR VAR_SET
.1a6bba	28		plp		                PLP
.1a6bbb	2b		pld		                PLD
.1a6bbc	ab		plb		                PLB
.1a6bbd	60		rts		            RTS
>1a6bbe	44 4f 53 53 54 41 54 00		dosstat_name    .null "DOSSTAT"
>1a6bc6	42 49 4f 53 53 54 41 54		biosstat_name   .null "BIOSSTAT"
>1a6bce	00
.1a6bcf					CMD_BRUN
.1a6bcf	08		php		                PHP
.1a6bd0	c2 30		rep #$30	            REP #$30
.1a6bd2	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a6bd5	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a6bd8	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6bdb	a5 23		lda $0823	                LDA ARGUMENT1
.1a6bdd	8f 60 03 00	sta $000360	                STA @l DOS_RUN_PARAM
.1a6be1	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6be3	8f 62 03 00	sta $000362	                STA @l DOS_RUN_PARAM+2
.1a6be7	a9 ff ff	lda #$ffff	                LDA #$FFFF
.1a6bea	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a6bee	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a6bf2	22 24 11 00	jsl $001124	                JSL FK_RUN                  ; Attempt to run the file
.1a6bf6	b0 25		bcs $1a6c1d	                BCS done                    ; If we got it: try to execute it
.1a6bf8	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a6bfb	20 5b 6b	jsr $1a6b5b	            JSR SET_DOSSTAT
.1a6bfe	08		php		            PHP
.1a6bff	c2 20		rep #$20	            REP #$20
.1a6c01	48		pha		            PHA
.1a6c02	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6c05	5b		tcd		            TCD
.1a6c06	68		pla		            PLA
.1a6c07	28		plp		            PLP
.1a6c08	e2 20		sep #$20	            SEP #$20
.1a6c0a	a9 11		lda #$11	            LDA #ERR_LOAD
.1a6c0c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6c10	c2 20		rep #$20	            REP #$20
.1a6c12	29 ff 00	and #$00ff	            AND #$00FF
.1a6c15	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a6c18	e2 20		sep #$20	            SEP #$20
.1a6c1a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6c1d					done
.1a6c1d	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a6c20	28		plp		                PLP
.1a6c21	60		rts		            RTS
.1a6c22					CMD_LOAD
.1a6c22	08		php		                PHP
.1a6c23	c2 30		rep #$30	            REP #$30
.1a6c25	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a6c28	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a6c2b	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6c2e	20 aa 6a	jsr $1a6aaa	            JSR SETFILEDESC
.1a6c31	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.1a6c34	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a6c38	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.1a6c3b	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2        ; Set the destination address
.1a6c3f	20 19 50	jsr $1a5019	            JSR CMD_NEW
.1a6c42	22 18 11 00	jsl $001118	                JSL FK_LOAD                 ; Attempt to load the file
.1a6c46	b0 22		bcs $1a6c6a	                BCS start_tokenize          ; If we got it: start tokenizing
.1a6c48	20 5b 6b	jsr $1a6b5b	            JSR SET_DOSSTAT
.1a6c4b	08		php		            PHP
.1a6c4c	c2 20		rep #$20	            REP #$20
.1a6c4e	48		pha		            PHA
.1a6c4f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6c52	5b		tcd		            TCD
.1a6c53	68		pla		            PLA
.1a6c54	28		plp		            PLP
.1a6c55	e2 20		sep #$20	            SEP #$20
.1a6c57	a9 11		lda #$11	            LDA #ERR_LOAD
.1a6c59	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6c5d	c2 20		rep #$20	            REP #$20
.1a6c5f	29 ff 00	and #$00ff	            AND #$00FF
.1a6c62	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a6c65	e2 20		sep #$20	            SEP #$20
.1a6c67	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6c6a					start_tokenize
.1a6c6a	20 5b 6b	jsr $1a6b5b	            JSR SET_DOSSTAT
.1a6c6d	c2 20		rep #$20	            REP #$20
.1a6c6f	a2 12 00	ldx #$0012	                LDX #FILEDESC.FILESIZE
.1a6c72	18		clc		                CLC                         ; Set MTEMP to point to the byte after the file
.1a6c73	bf 73 f2 1a	lda $1af273,x	                LDA FD_IN,X
.1a6c77	69 00 00	adc #$0000	                ADC #<>LOADBLOCK
.1a6c7a	85 92		sta $0892	                STA MTEMP
.1a6c7c	bf 75 f2 1a	lda $1af275,x	                LDA FD_IN+2,X
.1a6c80	69 01 00	adc #$0001	                ADC #`LOADBLOCK
.1a6c83	85 94		sta $0894	                STA MTEMP+2
.1a6c85	e2 20		sep #$20	            SEP #$20
.1a6c87	a9 00		lda #$00	                LDA #0
.1a6c89	87 92		sta [$0892]	                STA [MTEMP]                 ; Write a NULL right after the file
.1a6c8b	c2 20		rep #$20	            REP #$20
.1a6c8d	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK            ; Set MCURSOR to the begining of the loaded data
.1a6c90	85 7a		sta $087a	                STA MCURSOR
.1a6c92	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.1a6c95	85 7c		sta $087c	                STA MCURSOR+2
.1a6c97	a2 00 00	ldx #$0000	copy_line       LDX #0
.1a6c9a					copy_char
.1a6c9a	e2 20		sep #$20	            SEP #$20
.1a6c9c	a7 7a		lda [$087a]	                LDA [MCURSOR]
.1a6c9e	f0 2a		beq $1a6cca	                BEQ clean_up                ; If the character is 0, we're done
.1a6ca0	c9 0d		cmp #$0d	                CMP #CHAR_CR                ; If it is new line...
.1a6ca2	f0 12		beq $1a6cb6	                BEQ do_process              ; ... we want to process the line
.1a6ca4	c9 0a		cmp #$0a	                CMP #CHAR_LF                ; If it is a line feed...
.1a6ca6	f0 04		beq $1a6cac	                BEQ next_char               ; ... we want to skip it
.1a6ca8	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X              ; Otherwise, copy the character to the input buffer
.1a6cab	e8		inx		                INX
.1a6cac					next_char
.1a6cac	c2 20		rep #$20	            REP #$20
.1a6cae	e6 7a		inc $087a	                INC MCURSOR                 ; Advance the input cursor
.1a6cb0	d0 e8		bne $1a6c9a	                BNE copy_char
.1a6cb2	e6 7c		inc $087c	                INC MCURSOR+2
.1a6cb4	80 e4		bra $1a6c9a	                BRA copy_char
.1a6cb6					do_process
.1a6cb6	e2 20		sep #$20	            SEP #$20
.1a6cb8	a9 00		lda #$00	                LDA #0                      ; Put a 0 at the end of the input buffer
.1a6cba	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a6cbd	20 52 27	jsr $1a2752	            JSR PROCESS
.1a6cc0	c2 20		rep #$20	            REP #$20
.1a6cc2	e6 7a		inc $087a	                INC MCURSOR                 ; Try again with the next line
.1a6cc4	d0 d1		bne $1a6c97	                BNE copy_line
.1a6cc6	e6 7c		inc $087c	                INC MCURSOR+2
.1a6cc8	80 cd		bra $1a6c97	                BRA copy_line
.1a6cca	e0 00 00	cpx #$0000	clean_up        CPX #0                      ; Is there data in the INPUTBUF?
.1a6ccd	f0 0a		beq $1a6cd9	                BEQ done                    ; No: just return
.1a6ccf	e2 20		sep #$20	            SEP #$20
.1a6cd1	a9 00		lda #$00	                LDA #0                      ; Make sure there is a trailing NULL
.1a6cd3	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a6cd6	20 52 27	jsr $1a2752	            JSR PROCESS
.1a6cd9	28		plp		done            PLP
.1a6cda	60		rts		            RTS
.1a6cdb					S_BSAVE
.1a6cdb	08		php		                PHP
.1a6cdc	c2 30		rep #$30	            REP #$30
.1a6cde	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a6ce1	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a6ce4	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6ce7	20 aa 6a	jsr $1a6aaa	            JSR SETFILEDESC
.1a6cea	e2 20		sep #$20	            SEP #$20
.1a6cec	a9 2c		lda #$2c	                LDA #','
.1a6cee	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a6cf1	c2 20		rep #$20	            REP #$20
.1a6cf3	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a6cf6	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a6cf9	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_SRC_PTR
.1a6cfb	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.1a6cff	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6d01	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.1a6d05	e2 20		sep #$20	            SEP #$20
.1a6d07	a9 2c		lda #$2c	                LDA #','
.1a6d09	c2 20		rep #$20	            REP #$20
.1a6d0b	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a6d0e	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a6d11	20 16 06	jsr $1a0616	            JSR ASS_ARG1_INT
.1a6d14	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_END_PTR
.1a6d16	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.1a6d1a	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6d1c	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.1a6d20	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                 ; Attempt to save the memory to file.
.1a6d24	b0 22		bcs $1a6d48	                BCS done
.1a6d26	20 5b 6b	jsr $1a6b5b	            JSR SET_DOSSTAT
.1a6d29	08		php		            PHP
.1a6d2a	c2 20		rep #$20	            REP #$20
.1a6d2c	48		pha		            PHA
.1a6d2d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6d30	5b		tcd		            TCD
.1a6d31	68		pla		            PLA
.1a6d32	28		plp		            PLP
.1a6d33	e2 20		sep #$20	            SEP #$20
.1a6d35	a9 12		lda #$12	            LDA #ERR_SAVE
.1a6d37	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6d3b	c2 20		rep #$20	            REP #$20
.1a6d3d	29 ff 00	and #$00ff	            AND #$00FF
.1a6d40	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a6d43	e2 20		sep #$20	            SEP #$20
.1a6d45	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6d48					done
.1a6d48	20 5b 6b	jsr $1a6b5b	            JSR SET_DOSSTAT
.1a6d4b	28		plp		                PLP
.1a6d4c	60		rts		            RTS
.1a6d4d					COPY2PATHBUF
.1a6d4d	da		phx		                PHX
.1a6d4e	5a		phy		                PHY
.1a6d4f	08		php		                PHP
.1a6d50	a2 00 00	ldx #$0000	                LDX #0
.1a6d53	a0 00 00	ldy #$0000	                LDY #0
.1a6d56	e2 20		sep #$20	            SEP #$20
.1a6d58	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y           ; Copy the path to the DOS_PATH_BUFF
.1a6d5a	9d 00 04	sta $0400,x	                STA DOS_PATH_BUFF,X
.1a6d5d	f0 04		beq $1a6d63	                BEQ done
.1a6d5f	e8		inx		                INX
.1a6d60	c8		iny		                INY
.1a6d61	80 f5		bra $1a6d58	                BRA loop
.1a6d63	28		plp		done            PLP
.1a6d64	7a		ply		                PLY
.1a6d65	fa		plx		                PLX
.1a6d66	60		rts		            RTS
.1a6d67					CMD_SAVE
.1a6d67	08		php		                PHP
.1a6d68	c2 30		rep #$30	            REP #$30
.1a6d6a	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a6d6d	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a6d70	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6d73	20 aa 6a	jsr $1a6aaa	            JSR SETFILEDESC
.1a6d76	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.1a6d79	85 a6		sta $08a6	                STA OBUFFER
.1a6d7b	e2 20		sep #$20	            SEP #$20
.1a6d7d	a9 01		lda #$01	                LDA #`LOADBLOCK
.1a6d7f	85 a8		sta $08a8	                STA OBUFFER+2
.1a6d81	a9 20		lda #$20	                LDA #DEV_BUFFER             ; Set up output for the buffer
.1a6d83	85 b4		sta $08b4	                STA BCONSOLE
.1a6d85	c2 20		rep #$20	            REP #$20
.1a6d87	a9 00 00	lda #$0000	                LDA #0
.1a6d8a	85 ab		sta $08ab	                STA OBUFFIDX
.1a6d8c	a9 ff ff	lda #$ffff	                LDA #$FFFF
.1a6d8f	85 a9		sta $08a9	                STA OBUFFSIZE
.1a6d91	c2 20		rep #$20	            REP #$20
.1a6d93	a9 00 00	lda #$0000	                LDA #0                      ; Set start line number to 0
.1a6d96	85 55		sta $0855	                STA MARG1
.1a6d98	85 57		sta $0857	                STA MARG1+2
.1a6d9a	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set end line number to MAXINT
.1a6d9d	85 59		sta $0859	                STA MARG2
.1a6d9f	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.1a6da2	85 5b		sta $085b	                STA MARG2+2
.1a6da4	20 50 18	jsr $1a1850	            JSR LISTPROG
.1a6da7	e2 20		sep #$20	            SEP #$20
.1a6da9	a9 80		lda #$80	                LDA #DEV_SCREEN             ; Restore output to the screen
.1a6dab	85 b4		sta $08b4	                STA BCONSOLE
.1a6dad	c2 20		rep #$20	            REP #$20
.1a6daf	c6 ab		dec $08ab	                DEC OBUFFIDX                ; OBUFFIDX points to the next free byte... so pull it in one
.1a6db1	18		clc		                CLC                         ; Set the range of memory to save
.1a6db2	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.1a6db5	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.1a6db9	65 ab		adc $08ab	                ADC OBUFFIDX
.1a6dbb	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.1a6dbf	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.1a6dc2	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.1a6dc6	69 00 00	adc #$0000	                ADC #0
.1a6dc9	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.1a6dcd	22 1c 11 00	jsl $00111c	do_save         JSL FK_SAVE                 ; Attempt to save the file
.1a6dd1	b0 22		bcs $1a6df5	                BCS done
.1a6dd3	20 5b 6b	jsr $1a6b5b	            JSR SET_DOSSTAT
.1a6dd6	08		php		            PHP
.1a6dd7	c2 20		rep #$20	            REP #$20
.1a6dd9	48		pha		            PHA
.1a6dda	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6ddd	5b		tcd		            TCD
.1a6dde	68		pla		            PLA
.1a6ddf	28		plp		            PLP
.1a6de0	e2 20		sep #$20	            SEP #$20
.1a6de2	a9 12		lda #$12	            LDA #ERR_SAVE
.1a6de4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6de8	c2 20		rep #$20	            REP #$20
.1a6dea	29 ff 00	and #$00ff	            AND #$00FF
.1a6ded	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a6df0	e2 20		sep #$20	            SEP #$20
.1a6df2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6df5					done
.1a6df5	20 5b 6b	jsr $1a6b5b	            JSR SET_DOSSTAT
.1a6df8	28		plp		                PLP
.1a6df9	60		rts		            RTS
.1a6dfa					S_DEL
.1a6dfa	08		php		                PHP
.1a6dfb	c2 30		rep #$30	            REP #$30
.1a6dfd	20 03 21	jsr $1a2103	            JSR SKIPWS
.1a6e00	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a6e03	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6e06	20 4d 6d	jsr $1a6d4d	            JSR COPY2PATHBUF
.1a6e09	22 04 11 00	jsl $001104	path_loaded     JSL FK_DELETE               ; Try to delete the file
.1a6e0d	b0 22		bcs $1a6e31	                BCS done
.1a6e0f	20 5b 6b	jsr $1a6b5b	            JSR SET_DOSSTAT
.1a6e12	08		php		            PHP
.1a6e13	c2 20		rep #$20	            REP #$20
.1a6e15	48		pha		            PHA
.1a6e16	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6e19	5b		tcd		            TCD
.1a6e1a	68		pla		            PLA
.1a6e1b	28		plp		            PLP
.1a6e1c	e2 20		sep #$20	            SEP #$20
.1a6e1e	a9 13		lda #$13	            LDA #ERR_DELETE
.1a6e20	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6e24	c2 20		rep #$20	            REP #$20
.1a6e26	29 ff 00	and #$00ff	            AND #$00FF
.1a6e29	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a6e2c	e2 20		sep #$20	            SEP #$20
.1a6e2e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6e31					done
.1a6e31	20 5b 6b	jsr $1a6b5b	            JSR SET_DOSSTAT
.1a6e34	28		plp		                PLP
.1a6e35	60		rts		            RTS
.1a6e36					VALIDFILECHAR
.1a6e36	da		phx		                PHX
.1a6e37	08		php		                PHP
.1a6e38	e2 20		sep #$20	            SEP #$20
.1a6e3a	c9 61		cmp #$61	                CMP #'a'                    ; Is it lower case?
.1a6e3c	90 08		bcc $1a6e46	                BLT chk_space
.1a6e3e	c9 7b		cmp #$7b	                CMP #'z'+1
.1a6e40	b0 04		bcs $1a6e46	                BGE chk_space
.1a6e42	29 df		and #$df	                AND #%11011111              ; Yes: convert to upper case
.1a6e44	80 13		bra $1a6e59	                BRA ret_valid
.1a6e46	c9 20		cmp #$20	chk_space       CMP #CHAR_SP            ; Is it a control code?
.1a6e48	90 13		bcc $1a6e5d	                BLT is_invalid          ; Yes: it's invalid
.1a6e4a	a2 00 00	ldx #$0000	                LDX #0                  ; See if it's in the list of invalids
.1a6e4d	df 61 6e 1a	cmp $1a6e61,x	loop            CMP invalid_chars,X
.1a6e51	f0 0a		beq $1a6e5d	                BEQ is_invalid
.1a6e53	e8		inx		                INX
.1a6e54	e0 0f 00	cpx #$000f	                CPX #15                 ; # of invalid characters
.1a6e57	d0 f4		bne $1a6e4d	                BNE loop
.1a6e59	28		plp		ret_valid       PLP
.1a6e5a	38		sec		                SEC
.1a6e5b	fa		plx		                PLX
.1a6e5c	6b		rtl		                RTL
.1a6e5d	28		plp		is_invalid      PLP
.1a6e5e	18		clc		                CLC
.1a6e5f	fa		plx		                PLX
.1a6e60	6b		rtl		                RTL
>1a6e61	2a 2b 2c 2f 3a 3b 3c 3d		invalid_chars   .text "*+,/:;<=>?\[]|",CHAR_DQUOTE
>1a6e69	3e 3f 5c 5b 5d 7c 22
.1a6e70					S_RENAME
.1a6e70	08		php		                PHP
.1a6e71	08		php		            PHP
.1a6e72	c2 20		rep #$20	            REP #$20
.1a6e74	48		pha		            PHA
.1a6e75	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6e78	5b		tcd		            TCD
.1a6e79	68		pla		            PLA
.1a6e7a	28		plp		            PLP
.1a6e7b	c2 30		rep #$30	            REP #$30
.1a6e7d	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a6e80	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6e83	20 4d 6d	jsr $1a6d4d	            JSR COPY2PATHBUF
.1a6e86	22 10 11 00	jsl $001110	                JSL FK_DIRREAD              ; Try to read the file
.1a6e8a	b0 22		bcs $1a6eae	                BCS get_new_name            ; If ok: get the new name
.1a6e8c	20 5b 6b	jsr $1a6b5b	            JSR SET_DOSSTAT
.1a6e8f	08		php		            PHP
.1a6e90	c2 20		rep #$20	            REP #$20
.1a6e92	48		pha		            PHA
.1a6e93	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6e96	5b		tcd		            TCD
.1a6e97	68		pla		            PLA
.1a6e98	28		plp		            PLP
.1a6e99	e2 20		sep #$20	            SEP #$20
.1a6e9b	a9 14		lda #$14	            LDA #ERR_FILENOTFOUND
.1a6e9d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6ea1	c2 20		rep #$20	            REP #$20
.1a6ea3	29 ff 00	and #$00ff	            AND #$00FF
.1a6ea6	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a6ea9	e2 20		sep #$20	            SEP #$20
.1a6eab	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6eae					get_new_name
.1a6eae	e2 20		sep #$20	            SEP #$20
.1a6eb0	a9 2c		lda #$2c	                LDA #','
.1a6eb2	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a6eb5	c2 20		rep #$20	            REP #$20
.1a6eb7	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a6eba	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6ebd	ad 38 03	lda $0338	                LDA DOS_DIR_PTR
.1a6ec0	85 08		sta $0808	                STA INDEX
.1a6ec2	ad 3a 03	lda $033a	                LDA DOS_DIR_PTR+2
.1a6ec5	85 0a		sta $080a	                STA INDEX+2
.1a6ec7	e2 20		sep #$20	            SEP #$20
.1a6ec9	a2 00 00	ldx #$0000	                LDX #0
.1a6ecc	a9 20		lda #$20	                LDA #CHAR_SP                ; We'll use MLINEBUFF as temporary name storage
.1a6ece	95 7e		sta $087e,x	blank_loop      STA MLINEBUF,X              ; Fill it with blanks
.1a6ed0	e8		inx		                INX
.1a6ed1	e0 0b 00	cpx #$000b	                CPX #11
.1a6ed4	d0 f8		bne $1a6ece	                BNE blank_loop
.1a6ed6	a2 00 00	ldx #$0000	                LDX #0
.1a6ed9	a0 00 00	ldy #$0000	                LDY #0
.1a6edc	b7 23		lda [$0823],y	name_loop       LDA [ARGUMENT1],Y           ; Get the character of the new name
.1a6ede	f0 76		beq $1a6f56	                BEQ copy_short_name         ; If end-of-string: copy what we have
.1a6ee0	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.1a6ee2	f0 39		beq $1a6f1d	                BEQ skip_dot                ; Yes: move on to the extension characters
.1a6ee4	22 36 6e 1a	jsl $1a6e36	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.1a6ee8	b0 1f		bcs $1a6f09	                BCS save_nm_char
.1a6eea	08		php		            PHP
.1a6eeb	c2 20		rep #$20	            REP #$20
.1a6eed	48		pha		            PHA
.1a6eee	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6ef1	5b		tcd		            TCD
.1a6ef2	68		pla		            PLA
.1a6ef3	28		plp		            PLP
.1a6ef4	e2 20		sep #$20	            SEP #$20
.1a6ef6	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a6ef8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6efc	c2 20		rep #$20	            REP #$20
.1a6efe	29 ff 00	and #$00ff	            AND #$00FF
.1a6f01	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a6f04	e2 20		sep #$20	            SEP #$20
.1a6f06	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6f09	95 7e		sta $087e,x	save_nm_char    STA MLINEBUF,X              ; Otherwise: copy it
.1a6f0b	c8		iny		                INY
.1a6f0c	e8		inx		                INX
.1a6f0d	c0 08 00	cpy #$0008	                CPY #8
.1a6f10	d0 ca		bne $1a6edc	                BNE name_loop
.1a6f12	b7 23		lda [$0823],y	eat_name        LDA [ARGUMENT1],Y           ; Get the character
.1a6f14	f0 40		beq $1a6f56	                BEQ copy_short_name         ; If null, we're done with the short name
.1a6f16	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.1a6f18	f0 03		beq $1a6f1d	                BEQ skip_dot                ; Yes: skip over it
.1a6f1a	c8		iny		                INY                         ; No: try again with the the next character
.1a6f1b	80 f5		bra $1a6f12	                BRA eat_name
.1a6f1d	c8		iny		skip_dot        INY                         ; Character at Y is '.', so skip over it
.1a6f1e	a2 08 00	ldx #$0008	do_ext          LDX #8
.1a6f21	b7 23		lda [$0823],y	ext_loop        LDA [ARGUMENT1],Y           ; Get the character of the new extension
.1a6f23	f0 31		beq $1a6f56	                BEQ copy_short_name         ; If end-of-string: copy what we have
.1a6f25	22 36 6e 1a	jsl $1a6e36	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.1a6f29	b0 22		bcs $1a6f4d	                BCS save_ext_char
.1a6f2b	20 5b 6b	jsr $1a6b5b	            JSR SET_DOSSTAT
.1a6f2e	08		php		            PHP
.1a6f2f	c2 20		rep #$20	            REP #$20
.1a6f31	48		pha		            PHA
.1a6f32	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6f35	5b		tcd		            TCD
.1a6f36	68		pla		            PLA
.1a6f37	28		plp		            PLP
.1a6f38	e2 20		sep #$20	            SEP #$20
.1a6f3a	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a6f3c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6f40	c2 20		rep #$20	            REP #$20
.1a6f42	29 ff 00	and #$00ff	            AND #$00FF
.1a6f45	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a6f48	e2 20		sep #$20	            SEP #$20
.1a6f4a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6f4d	95 7e		sta $087e,x	save_ext_char   STA MLINEBUF,X              ; Otherwise: copy it
.1a6f4f	c8		iny		                INY
.1a6f50	e8		inx		                INX
.1a6f51	c0 0c 00	cpy #$000c	                CPY #12
.1a6f54	d0 cb		bne $1a6f21	                BNE ext_loop
.1a6f56	a2 00 00	ldx #$0000	copy_short_name LDX #0                      ; Copy the short name we built to the directory entry
.1a6f59	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME
.1a6f5c	b5 7e		lda $087e,x	copy_loop       LDA MLINEBUF,X
.1a6f5e	97 08		sta [$0808],y	                STA [INDEX],Y
.1a6f60	e8		inx		                INX
.1a6f61	c8		iny		                INY
.1a6f62	c0 0b 00	cpy #$000b	                CPY #11
.1a6f65	d0 f5		bne $1a6f5c	                BNE copy_loop
.1a6f67	22 14 11 00	jsl $001114	                JSL FK_DIRWRITE             ; Write the directory entry back
.1a6f6b	b0 22		bcs $1a6f8f	                BCS done
.1a6f6d	20 5b 6b	jsr $1a6b5b	            JSR SET_DOSSTAT
.1a6f70	08		php		            PHP
.1a6f71	c2 20		rep #$20	            REP #$20
.1a6f73	48		pha		            PHA
.1a6f74	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6f77	5b		tcd		            TCD
.1a6f78	68		pla		            PLA
.1a6f79	28		plp		            PLP
.1a6f7a	e2 20		sep #$20	            SEP #$20
.1a6f7c	a9 15		lda #$15	            LDA #ERR_DIRNOTWRITE
.1a6f7e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6f82	c2 20		rep #$20	            REP #$20
.1a6f84	29 ff 00	and #$00ff	            AND #$00FF
.1a6f87	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a6f8a	e2 20		sep #$20	            SEP #$20
.1a6f8c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6f8f					done
.1a6f8f	20 5b 6b	jsr $1a6b5b	            JSR SET_DOSSTAT
.1a6f92	28		plp		                PLP
.1a6f93	60		rts		            RTS
.1a6f94					S_COPY
.1a6f94	08		php		                PHP
.1a6f95	08		php		            PHP
.1a6f96	c2 20		rep #$20	            REP #$20
.1a6f98	48		pha		            PHA
.1a6f99	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6f9c	5b		tcd		            TCD
.1a6f9d	68		pla		            PLA
.1a6f9e	28		plp		            PLP
.1a6f9f	c2 30		rep #$30	            REP #$30
.1a6fa1	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a6fa4	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6fa7	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.1a6fa9	8f 64 03 00	sta $000364	                STA @l DOS_STR1_PTR
.1a6fad	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6faf	8f 66 03 00	sta $000366	                STA @l DOS_STR1_PTR+2
.1a6fb3	e2 20		sep #$20	            SEP #$20
.1a6fb5	a9 2c		lda #$2c	                LDA #','
.1a6fb7	20 ef 21	jsr $1a21ef	            JSR EXPECT_TOK
.1a6fba	c2 20		rep #$20	            REP #$20
.1a6fbc	20 d1 1c	jsr $1a1cd1	            JSR EVALEXPR
.1a6fbf	20 a8 06	jsr $1a06a8	            JSR ASS_ARG1_STR
.1a6fc2	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.1a6fc4	8f 68 03 00	sta $000368	                STA @l DOS_STR2_PTR
.1a6fc8	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6fca	8f 6a 03 00	sta $00036a	                STA @l DOS_STR2_PTR+2
.1a6fce	22 30 11 00	jsl $001130	                JSL FK_COPY                 ; Attempt to copy the file
.1a6fd2	b0 1f		bcs $1a6ff3	                BCS done
.1a6fd4	08		php		            PHP
.1a6fd5	c2 20		rep #$20	            REP #$20
.1a6fd7	48		pha		            PHA
.1a6fd8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6fdb	5b		tcd		            TCD
.1a6fdc	68		pla		            PLA
.1a6fdd	28		plp		            PLP
.1a6fde	e2 20		sep #$20	            SEP #$20
.1a6fe0	a9 16		lda #$16	            LDA #ERR_NOTCOPIED
.1a6fe2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6fe6	c2 20		rep #$20	            REP #$20
.1a6fe8	29 ff 00	and #$00ff	            AND #$00FF
.1a6feb	20 23 1e	jsr $1a1e23	            JSR SET_ERRERL
.1a6fee	e2 20		sep #$20	            SEP #$20
.1a6ff0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6ff3	28		plp		done            PLP
.1a6ff4	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\monitor.s

.1a6ff5	5c b2 89 1a	jmp $1a89b2	MRETURN         JML IMRETURN
.1a6ff9	5c 03 88 1a	jmp $1a8803	MPARSE          JML IMPARSE
.1a6ffd	5c b3 89 1a	jmp $1a89b3	MPARSE1         JML IMPARSE1
.1a7001	5c 2f 79 1a	jmp $1a792f	MEXECUTE        JML IMEXECUTE
.1a7005	5c 8c 79 1a	jmp $1a798c	MASSEMBLE       JML IMASSEMBLE
.1a7009	5c bf 78 1a	jmp $1a78bf	MRMODIFY        JML IMRMODIFY
.1a700d	5c 45 78 1a	jmp $1a7845	MCOMPARE        JML IMCOMPARE
.1a7011	5c c2 7d 1a	jmp $1a7dc2	MDISASSEMBLE    JML IMDISASSEMBLE
.1a7015	5c b0 74 1a	jmp $1a74b0	MFILL           JML IMFILL
.1a7019	5c dd 77 1a	jmp $1a77dd	MGO             JML IMGO
.1a701d	5c 98 77 1a	jmp $1a7798	MJUMP           JML IMJUMP
.1a7021	5c 22 77 1a	jmp $1a7722	MHUNT           JML IMHUNT
.1a7025	5c c1 88 1a	jmp $1a88c1	MLOAD           JML IMLOAD
.1a7029	5c be 75 1a	jmp $1a75be	MMEMORY         JML IMMEMORY
.1a702d	5c 0e 74 1a	jmp $1a740e	MREGISTERS      JML IMREGISTERS
.1a7031	5c 3c 89 1a	jmp $1a893c	MSAVE           JML IMSAVE
.1a7035	5c ec 74 1a	jmp $1a74ec	MTRANSFER       JML IMTRANSFER
.1a7039	5c b5 89 1a	jmp $1a89b5	MVERIFY         JML IMVERIFY
.1a703d	5c ae 89 1a	jmp $1a89ae	MEXIT           JML IMEXIT
.1a7041	5c db 76 1a	jmp $1a76db	MMODIFY         JML IMMODIFY
.1a7045	5c b6 89 1a	jmp $1a89b6	MDOS            JML IMDOS
.1a7049	18		clc		IMONITOR        CLC                 ; clear the carry flag
.1a704a	fb		xce		                XCE                 ; move carry to emulation flags
.1a704b	58		cli		                CLI                 ; Re-enable interrupts
.1a704c	5c 50 70 1a	jmp $1a7050	                JML IMREADY
.1a7050					IMREADY
.1a7050	c2 30		rep #$30	            REP #$30
.1a7052	22 0e 74 1a	jsl $1a740e	                JSL IMREGISTERS
.1a7056					ready_loop
.1a7056	20 08 00	jsr $1a0008	            JSR READLINE
.1a7059	20 0c 00	jsr $1a000c	            JSR SCRCOPYLINE
.1a705c	8b		phb		                PHB
.1a705d	e2 20		sep #$20	            SEP #$20
.1a705f	a9 00		lda #$00	                LDA #`INPUTBUF
.1a7061	48		pha		                PHA
.1a7062	ab		plb		                PLB
.1a7063	a2 00 4f	ldx #$4f00	                LDX #<>INPUTBUF
.1a7066	20 2a 05	jsr $1a052a	            JSR TOUPPER
.1a7069	ab		plb		                PLB
.1a706a	22 f9 6f 1a	jsl $1a6ff9	                JSL MPARSE          ; Parse the command
.1a706e	22 01 70 1a	jsl $1a7001	                JSL MEXECUTE        ; And execute the parsed command
.1a7072	80 e2		bra $1a7056	                BRA ready_loop
.1a7074					IMHELP
.1a7074	08		php		                PHP
.1a7075	8b		phb		                PHB
.1a7076	e2 20		sep #$20	            SEP #$20
.1a7078	a9 1a		lda #$1a	                LDA #`help_text
.1a707a	48		pha		                PHA
.1a707b	ab		plb		                PLB
.1a707c	c2 10		rep #$10	            REP #$10
.1a707e	a2 87 70	ldx #$7087	                LDX #<>help_text
.1a7081	20 29 04	jsr $1a0429	            JSR PRINTS
.1a7084	ab		plb		                PLB
.1a7085	28		plp		                PLP
.1a7086	6b		rtl		                RTL
>1a7087	41 20 3c 73 74 61 72 74		help_text       .text "A <start> <assembly>",CHAR_CR
>1a708f	3e 20 3c 61 73 73 65 6d 62 6c 79 3e 0d
>1a709c	20 20 41 73 73 65 6d 62		                .text "  Assemble a program",CHAR_CR,CHAR_CR
>1a70a4	6c 65 20 61 20 70 72 6f 67 72 61 6d 0d 0d
>1a70b2	43 20 3c 73 74 61 72 74		                .text "C <start1> <start2> [len (1 if blank)]",CHAR_CR
>1a70ba	31 3e 20 3c 73 74 61 72 74 32 3e 20 5b 6c 65 6e
>1a70ca	20 28 31 20 69 66 20 62 6c 61 6e 6b 29 5d 0d
>1a70d9	20 20 43 6f 6d 70 61 72		                .text "  Compare to sections of memory",CHAR_CR,CHAR_CR
>1a70e1	65 20 74 6f 20 73 65 63 74 69 6f 6e 73 20 6f 66
>1a70f1	20 6d 65 6d 6f 72 79 0d 0d
>1a70fa	44 20 3c 73 74 61 72 74		                .text "D <start> [end]",CHAR_CR
>1a7102	3e 20 5b 65 6e 64 5d 0d
>1a710a	20 20 44 69 73 61 73 73		                .text "  Disassemble a program",CHAR_CR,CHAR_CR
>1a7112	65 6d 62 6c 65 20 61 20 70 72 6f 67 72 61 6d 0d
>1a7122	0d
>1a7123	46 20 3c 73 74 61 72 74		                .text "F <start> <end> <byte>",CHAR_CR
>1a712b	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 0d
>1a713a	20 20 46 69 6c 6c 20 61		                .text "  Fill a block of memory with a byte",CHAR_CR,CHAR_CR
>1a7142	20 62 6c 6f 63 6b 20 6f 66 20 6d 65 6d 6f 72 79
>1a7152	20 77 69 74 68 20 61 20 62 79 74 65 0d 0d
>1a7160	47 20 5b 61 64 64 72 65		                .text "G [address]",CHAR_CR
>1a7168	73 73 5d 0d
>1a716c	20 20 53 74 61 72 74 20		                .text "  Start execution at a location",CHAR_CR,CHAR_CR
>1a7174	65 78 65 63 75 74 69 6f 6e 20 61 74 20 61 20 6c
>1a7184	6f 63 61 74 69 6f 6e 0d 0d
>1a718d	4a 20 5b 61 64 64 72 65		                .text "J [address] - Jump to a location in memory",CHAR_CR
>1a7195	73 73 5d 20 2d 20 4a 75 6d 70 20 74 6f 20 61 20
>1a71a5	6c 6f 63 61 74 69 6f 6e 20 69 6e 20 6d 65 6d 6f
>1a71b5	72 79 0d
>1a71b8	20 20 4a 75 6d 70 20 74		                .text "  Jump to a location in memory",CHAR_CR,CHAR_CR
>1a71c0	6f 20 61 20 6c 6f 63 61 74 69 6f 6e 20 69 6e 20
>1a71d0	6d 65 6d 6f 72 79 0d 0d
>1a71d8	48 20 3c 73 74 61 72 74		                .text "H <start> <end> <byte> [byte]..",CHAR_CR
>1a71e0	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 20 5b
>1a71f0	62 79 74 65 5d 2e 2e 0d
>1a71f8	20 20 48 75 6e 74 20 66		                .text "  Hunt for values in memory",CHAR_CR,CHAR_CR
>1a7200	6f 72 20 76 61 6c 75 65 73 20 69 6e 20 6d 65 6d
>1a7210	6f 72 79 0d 0d
>1a7215	4c 20 20 20 20 20 4c 4f		                .text "L     LOAD         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," [destination]",CHAR_CR
>1a721d	41 44 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>1a722d	22 20 5b 64 65 73 74 69 6e 61 74 69 6f 6e 5d 0d
>1a723d	4d 20 3c 73 74 61 72 74		                .text "M <start> [end]",CHAR_CR
>1a7245	3e 20 5b 65 6e 64 5d 0d
>1a724d	20 20 44 75 6d 70 20 74		                .text "  Dump the value in memory",CHAR_CR,CHAR_CR
>1a7255	68 65 20 76 61 6c 75 65 20 69 6e 20 6d 65 6d 6f
>1a7265	72 79 0d 0d
>1a7269	52 20 2d 20 44 69 73 70		                .text "R - Display the values of the registers",CHAR_CR,CHAR_CR
>1a7271	6c 61 79 20 74 68 65 20 76 61 6c 75 65 73 20 6f
>1a7281	66 20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d
>1a7291	0d
>1a7292	3b 20 3c 50 43 3e 20 3c		                .text "; <PC> <A> <X> <Y> <SP> <DBR> <DP> <NVMXDIZC>",CHAR_CR
>1a729a	41 3e 20 3c 58 3e 20 3c 59 3e 20 3c 53 50 3e 20
>1a72aa	3c 44 42 52 3e 20 3c 44 50 3e 20 3c 4e 56 4d 58
>1a72ba	44 49 5a 43 3e 0d
>1a72c0	20 20 43 68 61 6e 67 65		                .text "  Change the contents of the registers",CHAR_CR,CHAR_CR
>1a72c8	20 74 68 65 20 63 6f 6e 74 65 6e 74 73 20 6f 66
>1a72d8	20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d 0d
>1a72e8	53 20 20 20 20 20 53 41		                .text "S     SAVE         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," <start> <end>",CHAR_CR
>1a72f0	56 45 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>1a7300	22 20 3c 73 74 61 72 74 3e 20 3c 65 6e 64 3e 0d
>1a7310	54 20 3c 73 74 61 72 74		                .text "T <start> <end> <destination>",CHAR_CR
>1a7318	3e 20 3c 65 6e 64 3e 20 3c 64 65 73 74 69 6e 61
>1a7328	74 69 6f 6e 3e 0d
>1a732e	20 20 54 72 61 6e 73 66		                .text "  Transfer (copy) data within memory",CHAR_CR,CHAR_CR
>1a7336	65 72 20 28 63 6f 70 79 29 20 64 61 74 61 20 77
>1a7346	69 74 68 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>1a7354	57 20 3c 62 79 74 65 3e		                .text "W <byte>",CHAR_CR
>1a735c	0d
>1a735d	20 20 53 65 74 20 74 68		                .text "  Set the register width flags for the disassembler",CHAR_CR,CHAR_CR
>1a7365	65 20 72 65 67 69 73 74 65 72 20 77 69 64 74 68
>1a7375	20 66 6c 61 67 73 20 66 6f 72 20 74 68 65 20 64
>1a7385	69 73 61 73 73 65 6d 62 6c 65 72 0d 0d
>1a7392	58 20 2d 20 52 65 74 75		                .text "X - Return to BASIC",CHAR_CR,CHAR_CR
>1a739a	72 6e 20 74 6f 20 42 41 53 49 43 0d 0d
>1a73a7	3e 20 3c 73 74 61 72 74		                .text "> <start> <byte> [byte]...",CHAR_CR
>1a73af	3e 20 3c 62 79 74 65 3e 20 5b 62 79 74 65 5d 2e
>1a73bf	2e 2e 0d
>1a73c2	20 20 45 64 69 74 20 64		                .text "  Edit data in memory",CHAR_CR,CHAR_CR
>1a73ca	61 74 61 20 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>1a73d9	3f 20 2d 20 44 69 73 70		                .null "? - Display a short help screen",CHAR_CR,CHAR_CR
>1a73e1	6c 61 79 20 61 20 73 68 6f 72 74 20 68 65 6c 70
>1a73f1	20 73 63 72 65 65 6e 0d 0d 00
.1a73fb					IMWIDTH
.1a73fb	08		php		                PHP
.1a73fc	08		php		            PHP
.1a73fd	c2 20		rep #$20	            REP #$20
.1a73ff	48		pha		            PHA
.1a7400	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7403	5b		tcd		            TCD
.1a7404	68		pla		            PLA
.1a7405	28		plp		            PLP
.1a7406	e2 20		sep #$20	            SEP #$20
.1a7408	a5 0d		lda $0855	                LDA MARG1
.1a740a	85 4e		sta $0896	                STA MCPUSTAT
.1a740c	28		plp		                PLP
.1a740d	6b		rtl		                RTL
.1a740e					IMREGISTERS
.1a740e	20 3d 02	jsr $1a023d	            JSR ENSURETEXT
.1a7411	08		php		            PHP
.1a7412	e2 20		sep #$20	            SEP #$20
.1a7414	48		pha		            PHA
.1a7415	a9 1a		lda #$1a	            LDA #`mregisters_msg
.1a7417	48		pha		            PHA
.1a7418	ab		plb		            PLB
.1a7419	68		pla		            PLA
.1a741a	28		plp		            PLP
.1a741b	a2 f3 89	ldx #$89f3	                LDX #<>mregisters_msg
.1a741e	20 29 04	jsr $1a0429	            JSR PRINTS
.1a7421	e2 20		sep #$20	            SEP #$20
.1a7423	a9 3b		lda #$3b	                LDA #';'
.1a7425	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7428	a9 20		lda #$20	                LDA #' '
.1a742a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a742d	c2 30		rep #$30	            REP #$30
.1a742f	08		php		            PHP
.1a7430	e2 20		sep #$20	            SEP #$20
.1a7432	48		pha		            PHA
.1a7433	a9 00		lda #$00	            LDA #$0
.1a7435	48		pha		            PHA
.1a7436	ab		plb		            PLB
.1a7437	68		pla		            PLA
.1a7438	28		plp		            PLP
.1a7439	a0 03 00	ldy #$0003	                LDY #3
.1a743c	a2 42 02	ldx #$0242	                LDX #CPUPC+2
.1a743f	20 ac 03	jsr $1a03ac	            JSR PRINTH
.1a7442	c2 20		rep #$20	            REP #$20
.1a7444	a9 20 00	lda #$0020	                LDA #' '
.1a7447	20 18 00	jsr $1a0018	            JSR PRINTC
.1a744a	af 44 02 00	lda $000244	                LDA @lCPUA
.1a744e	20 39 04	jsr $1a0439	            JSR PRHEXW
.1a7451	a9 20 00	lda #$0020	                LDA #' '
.1a7454	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7457	af 46 02 00	lda $000246	                LDA @lCPUX
.1a745b	20 39 04	jsr $1a0439	            JSR PRHEXW
.1a745e	a9 20 00	lda #$0020	                LDA #' '
.1a7461	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7464	af 48 02 00	lda $000248	                LDA @lCPUY
.1a7468	20 39 04	jsr $1a0439	            JSR PRHEXW
.1a746b	a9 20 00	lda #$0020	                LDA #' '
.1a746e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7471	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK
.1a7475	20 39 04	jsr $1a0439	            JSR PRHEXW
.1a7478	a9 20 00	lda #$0020	                LDA #' '
.1a747b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a747e	af 4e 02 00	lda $00024e	                LDA @lCPUDBR
.1a7482	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a7485	a9 20 00	lda #$0020	                LDA #' '
.1a7488	20 18 00	jsr $1a0018	            JSR PRINTC
.1a748b	a9 20 00	lda #$0020	                LDA #' '
.1a748e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7491	af 4c 02 00	lda $00024c	                LDA @lCPUDP
.1a7495	20 39 04	jsr $1a0439	            JSR PRHEXW
.1a7498	a9 20 00	lda #$0020	                LDA #' '
.1a749b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a749e	08		php		                PHP
.1a749f	e2 20		sep #$20	            SEP #$20
.1a74a1	ad 4f 02	lda $024f	                LDA CPUFLAGS
.1a74a4	22 0c 87 1a	jsl $1a870c	                JSL MPRINTB
.1a74a8	28		plp		                PLP
.1a74a9	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a74ac	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a74af	6b		rtl		                RTL
.1a74b0					IMFILL
.1a74b0	08		php		                PHP                 ; Save the caller's context
.1a74b1	0b		phd		                PHD
.1a74b2	08		php		            PHP
.1a74b3	c2 20		rep #$20	            REP #$20
.1a74b5	48		pha		            PHA
.1a74b6	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a74b9	5b		tcd		            TCD
.1a74ba	68		pla		            PLA
.1a74bb	28		plp		            PLP
.1a74bc					do_copy
.1a74bc	e2 20		sep #$20	            SEP #$20
.1a74be	a5 15		lda $085d	                LDA MARG3
.1a74c0	87 0d		sta [$0855]	                STA [MARG1]
.1a74c2	e2 20		sep #$20	            SEP #$20
.1a74c4	a5 0f		lda $0857	                LDA MARG1+2
.1a74c6	c5 13		cmp $085b	                CMP MARG2+2
.1a74c8	d0 0e		bne $1a74d8	                BNE go_next         ; No: we haven't reached end address yet
.1a74ca	c2 20		rep #$20	            REP #$20
.1a74cc	a5 0d		lda $0855	                LDA MARG1
.1a74ce	c5 11		cmp $0859	                CMP MARG2           ; Are they equal?
.1a74d0	d0 06		bne $1a74d8	                BNE go_next         ; No: we haven't reached end address yet
.1a74d2	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a74d5	2b		pld		                PLD                 ; Restore the caller's context
.1a74d6	28		plp		                PLP
.1a74d7	6b		rtl		                RTL
.1a74d8					go_next
.1a74d8	c2 20		rep #$20	            REP #$20
.1a74da	18		clc		                CLC
.1a74db	a5 0d		lda $0855	                LDA MARG1
.1a74dd	69 01 00	adc #$0001	                ADC #1
.1a74e0	85 0d		sta $0855	                STA MARG1
.1a74e2	e2 20		sep #$20	            SEP #$20
.1a74e4	a5 0e		lda $0856	                LDA MARG1+1
.1a74e6	69 00		adc #$00	                ADC #0
.1a74e8	85 0e		sta $0856	                STA MARG1+1
.1a74ea	80 d0		bra $1a74bc	                BRA do_copy
.1a74ec					IMTRANSFER
.1a74ec	08		php		                PHP
.1a74ed	0b		phd		                PHD
.1a74ee	08		php		            PHP
.1a74ef	c2 20		rep #$20	            REP #$20
.1a74f1	48		pha		            PHA
.1a74f2	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a74f5	5b		tcd		            TCD
.1a74f6	68		pla		            PLA
.1a74f7	28		plp		            PLP
.1a74f8	e2 20		sep #$20	            SEP #$20
.1a74fa	a5 0f		lda $0857	                LDA MARG1+2
.1a74fc	c5 17		cmp $085f	                CMP MARG3+2
.1a74fe	90 45		bcc $1a7545	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.1a7500	c2 20		rep #$20	            REP #$20
.1a7502	a5 0d		lda $0855	                LDA MARG1
.1a7504	c5 15		cmp $085d	                CMP MARG3
.1a7506	90 3d		bcc $1a7545	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.1a7508					copy_byte_down
.1a7508	e2 20		sep #$20	            SEP #$20
.1a750a	a7 0d		lda [$0855]	                LDA [MARG1]         ; Copy the byte
.1a750c	87 15		sta [$085d]	                STA [MARG3]
.1a750e	a5 0f		lda $0857	                LDA MARG1+2         ; Are the source's current and end bank bytes equal?
.1a7510	c5 13		cmp $085b	                CMP MARG2+2
.1a7512	d0 0b		bne $1a751f	                BNE inc_pointers    ; No: we're not done yet
.1a7514	c2 20		rep #$20	            REP #$20
.1a7516	a5 0d		lda $0855	                LDA MARG1           ; Are the rest of the bits equal?
.1a7518	c5 11		cmp $0859	                CMP MARG2
.1a751a	d0 03		bne $1a751f	                BNE inc_pointers    ; No: we're not done yet
.1a751c	4c a3 75	jmp $1a75a3	                JMP done            ; Yes: we've copied the last byte, exit
.1a751f					inc_pointers
.1a751f	c2 20		rep #$20	            REP #$20
.1a7521	18		clc		                CLC
.1a7522	a5 0d		lda $0855	                LDA MARG1
.1a7524	69 01 00	adc #$0001	                ADC #1
.1a7527	85 0d		sta $0855	                STA MARG1
.1a7529	e2 20		sep #$20	            SEP #$20
.1a752b	a5 0e		lda $0856	                LDA MARG1+1
.1a752d	69 00		adc #$00	                ADC #0
.1a752f	85 0e		sta $0856	                STA MARG1+1
.1a7531	c2 20		rep #$20	            REP #$20
.1a7533	18		clc		                CLC
.1a7534	a5 15		lda $085d	                LDA MARG3
.1a7536	69 01 00	adc #$0001	                ADC #1
.1a7539	85 15		sta $085d	                STA MARG3
.1a753b	e2 20		sep #$20	            SEP #$20
.1a753d	a5 16		lda $085e	                LDA MARG3+1
.1a753f	69 00		adc #$00	                ADC #0
.1a7541	85 16		sta $085e	                STA MARG3+1
.1a7543	80 c3		bra $1a7508	                BRA copy_byte_down  ; And copy that next byte over
.1a7545					copy_up
.1a7545	c2 20		rep #$20	            REP #$20
.1a7547	38		sec		                SEC
.1a7548	a5 11		lda $0859	                LDA MARG2
.1a754a	e5 0d		sbc $0855	                SBC MARG1
.1a754c	85 19		sta $0861	                STA MARG4
.1a754e	e2 20		sep #$20	            SEP #$20
.1a7550	a5 13		lda $085b	                LDA MARG2+2
.1a7552	e5 0f		sbc $0857	                SBC MARG1+2
.1a7554	85 1b		sta $0863	                STA MARG4+2
.1a7556	c2 20		rep #$20	            REP #$20
.1a7558	18		clc		                CLC
.1a7559	a5 19		lda $0861	                LDA MARG4
.1a755b	65 15		adc $085d	                ADC MARG3
.1a755d	85 15		sta $085d	                STA MARG3
.1a755f	e2 20		sep #$20	            SEP #$20
.1a7561	a5 1b		lda $0863	                LDA MARG4+2
.1a7563	65 17		adc $085f	                ADC MARG3+2
.1a7565	85 17		sta $085f	                STA MARG3+2
.1a7567					copy_byte_up
.1a7567	e2 20		sep #$20	            SEP #$20
.1a7569	a7 11		lda [$0859]	                LDA [MARG2]
.1a756b	87 15		sta [$085d]	                STA [MARG3]
.1a756d	a5 13		lda $085b	                LDA MARG2+2         ; Are the source's current and start bank bytes equal?
.1a756f	c5 0f		cmp $0857	                CMP MARG1+2
.1a7571	d0 0a		bne $1a757d	                BNE dec_pointers    ; No: we're not done yet
.1a7573	c2 20		rep #$20	            REP #$20
.1a7575	a5 11		lda $0859	                LDA MARG2           ; Are the rest of the bits equal?
.1a7577	c5 0d		cmp $0855	                CMP MARG1
.1a7579	d0 02		bne $1a757d	                BNE dec_pointers    ; No: we're not done yet
.1a757b	80 26		bra $1a75a3	                BRA done            ; Yes: we've copied the last byte, exit
.1a757d					dec_pointers
.1a757d	c2 20		rep #$20	            REP #$20
.1a757f	38		sec		                SEC
.1a7580	a5 11		lda $0859	                LDA MARG2
.1a7582	e9 01 00	sbc #$0001	                SBC #1
.1a7585	85 11		sta $0859	                STA MARG2
.1a7587	e2 20		sep #$20	            SEP #$20
.1a7589	a5 12		lda $085a	                LDA MARG2+1
.1a758b	e9 00		sbc #$00	                SBC #0
.1a758d	85 12		sta $085a	                STA MARG2+1
.1a758f	c2 20		rep #$20	            REP #$20
.1a7591	38		sec		                SEC                 ; Decrement the current destination pointer (MARG3)
.1a7592	a5 15		lda $085d	                LDA MARG3
.1a7594	e9 01 00	sbc #$0001	                SBC #1
.1a7597	85 15		sta $085d	                STA MARG3
.1a7599	e2 20		sep #$20	            SEP #$20
.1a759b	a5 16		lda $085e	                LDA MARG3+1
.1a759d	e9 00		sbc #$00	                SBC #0
.1a759f	85 16		sta $085e	                STA MARG3+1
.1a75a1	80 c4		bra $1a7567	                BRA copy_byte_up    ; And copy that next byte
.1a75a3					done
.1a75a3	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a75a6	2b		pld		                PLD
.1a75a7	28		plp		                PLP
.1a75a8	6b		rtl		                RTL
.1a75a9					IS_PRINTABLE
.1a75a9	08		php		                PHP
.1a75aa	e2 20		sep #$20	            SEP #$20
.1a75ac	c9 21		cmp #$21	                CMP #33
.1a75ae	90 0b		bcc $1a75bb	                BLT not_printable   ; 0 .. 31 are not printable
.1a75b0	c9 7f		cmp #$7f	                CMP #127
.1a75b2	90 04		bcc $1a75b8	                BLT printable       ; 32 .. 126 are printable
.1a75b4	c9 a0		cmp #$a0	                CMP #160
.1a75b6	90 03		bcc $1a75bb	                BLT not_printable   ; 127 .. 159 are not printable (assuming Latin-1)
.1a75b8	28		plp		printable       PLP
.1a75b9	38		sec		                SEC
.1a75ba	6b		rtl		                RTL
.1a75bb	28		plp		not_printable   PLP
.1a75bc	18		clc		                CLC
.1a75bd	6b		rtl		                RTL
=256					MMEMDUMPSIZE = 256  ; Default number of bytes to dump
=8					MMEMROWSIZE = 8    ; Number of bytes to dump per-row
.1a75be					IMMEMORY
.1a75be	08		php		                PHP
.1a75bf	8b		phb		                PHB
.1a75c0	0b		phd		                PHD
.1a75c1	08		php		            PHP
.1a75c2	c2 20		rep #$20	            REP #$20
.1a75c4	48		pha		            PHA
.1a75c5	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a75c8	5b		tcd		            TCD
.1a75c9	68		pla		            PLA
.1a75ca	28		plp		            PLP
.1a75cb	e2 20		sep #$20	            SEP #$20
.1a75cd	a9 00		lda #$00	                LDA #0              ; Clear the pagination line counter
.1a75cf	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT
.1a75d3	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.1a75d5	c9 02		cmp #$02	                CMP #2
.1a75d7	b0 16		bcs $1a75ef	                BGE set_cursor      ; 2>= arguments? Use them as-is
.1a75d9	c9 01		cmp #$01	                CMP #1
.1a75db	90 20		bcc $1a75fd	                BLT no_args         ; No arguments passed? Use defaults
.1a75dd	c2 20		rep #$20	            REP #$20
.1a75df	18		clc		                CLC
.1a75e0	a5 0d		lda $0855	                LDA MARG1
.1a75e2	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a75e5	85 11		sta $0859	                STA MARG2
.1a75e7	e2 20		sep #$20	            SEP #$20
.1a75e9	a5 0f		lda $0857	                LDA MARG1+2
.1a75eb	69 00		adc #$00	                ADC #0
.1a75ed	85 13		sta $085b	                STA MARG2+2
.1a75ef					set_cursor
.1a75ef	c2 20		rep #$20	            REP #$20
.1a75f1	a5 0d		lda $0855	                LDA MARG1
.1a75f3	85 32		sta $087a	                STA MCURSOR
.1a75f5	e2 20		sep #$20	            SEP #$20
.1a75f7	a5 0f		lda $0857	                LDA MARG1+2
.1a75f9	85 34		sta $087c	                STA MCURSOR+2
.1a75fb	80 12		bra $1a760f	                BRA dump_line
.1a75fd					no_args
.1a75fd	c2 20		rep #$20	            REP #$20
.1a75ff	18		clc		                CLC
.1a7600	a5 32		lda $087a	                LDA MCURSOR
.1a7602	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a7605	85 11		sta $0859	                STA MARG2
.1a7607	e2 20		sep #$20	            SEP #$20
.1a7609	a5 34		lda $087c	                LDA MCURSOR+2
.1a760b	69 00		adc #$00	                ADC #0
.1a760d	85 13		sta $085b	                STA MARG2+2
.1a760f					dump_line
.1a760f	e2 20		sep #$20	            SEP #$20
.1a7611	a0 00 00	ldy #$0000	                LDY #0
.1a7614	c2 20		rep #$20	            REP #$20
.1a7616	a5 32		lda $087a	                LDA MCURSOR             ; NOTE: the use of MARG4 here is a temporary
.1a7618	85 19		sta $0861	                STA MARG4               ; hack. the copy_loop instruction does not
.1a761a	e2 20		sep #$20	            SEP #$20
.1a761c	a5 34		lda $087c	                LDA MCURSOR+2
.1a761e	85 1b		sta $0863	                STA MARG4+2
.1a7620	e2 20		sep #$20	            SEP #$20
.1a7622	a7 19		lda [$0861]	copy_loop       LDA [MARG4]             ; TODO: Should be LDA [MCURSOR],Y, which doesn't seem to be working
.1a7624	22 a9 75 1a	jsl $1a75a9	                JSL IS_PRINTABLE        ; Is it printable?
.1a7628	b0 02		bcs $1a762c	                BCS buffer_char         ; Yes: go ahead and add it to the line buffer
.1a762a	a9 3f		lda #$3f	                LDA #'?'                ; No: replace it with dot
.1a762c	99 7e 08	sta $087e,y	buffer_char     STA #MLINEBUF,B,Y
.1a762f	c2 20		rep #$20	            REP #$20
.1a7631	18		clc		                CLC
.1a7632	a5 19		lda $0861	                LDA MARG4
.1a7634	69 01 00	adc #$0001	                ADC #1
.1a7637	85 19		sta $0861	                STA MARG4
.1a7639	e2 20		sep #$20	            SEP #$20
.1a763b	a5 1b		lda $0863	                LDA MARG4+2
.1a763d	69 00		adc #$00	                ADC #0
.1a763f	85 1b		sta $0863	                STA MARG4+2
.1a7641	c8		iny		                INY
.1a7642	c0 08 00	cpy #$0008	                CPY #MMEMROWSIZE
.1a7645	90 db		bcc $1a7622	                BLT copy_loop
.1a7647	a9 00		lda #$00	                LDA #0
.1a7649	99 7e 08	sta $087e,y	                STA #MLINEBUF,B,Y
.1a764c	a9 3e		lda #$3e	                LDA #'>'
.1a764e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7651	a9 20		lda #$20	                LDA #' '
.1a7653	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7656	e2 20		sep #$20	            SEP #$20
.1a7658	a5 34		lda $087c	                LDA MCURSOR+2
.1a765a	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a765d	a9 3a		lda #$3a	                LDA #':'                ; then a colon
.1a765f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7662	c2 20		rep #$20	            REP #$20
.1a7664	a5 32		lda $087a	                LDA MCURSOR
.1a7666	20 39 04	jsr $1a0439	            JSR PRHEXW
.1a7669	c2 20		rep #$20	            REP #$20
.1a766b	a9 08 00	lda #$0008	                LDA #MMEMROWSIZE
.1a766e	85 47		sta $088f	                STA MCOUNT
.1a7670					prhex_loop
.1a7670	e2 20		sep #$20	            SEP #$20
.1a7672	a9 20		lda #$20	                LDA #' '
.1a7674	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7677	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a7679	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a767c	22 eb 86 1a	jsl $1a86eb	                JSL M_INC_CURSOR        ; Point MCURSOR to the next byte
.1a7680					check_line
.1a7680	e2 20		sep #$20	            SEP #$20
.1a7682	c6 47		dec $088f	                DEC MCOUNT              ; Count down the number of bytes on the row
.1a7684	d0 ea		bne $1a7670	                BNE prhex_loop          ; If we're not at zero, keep looping over the bytes
.1a7686	a9 20		lda #$20	                LDA #' '
.1a7688	20 18 00	jsr $1a0018	            JSR PRINTC
.1a768b	a9 20		lda #$20	                LDA #' '
.1a768d	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7690	08		php		            PHP
.1a7691	e2 20		sep #$20	            SEP #$20
.1a7693	48		pha		            PHA
.1a7694	a9 00		lda #$00	            LDA #`MLINEBUF
.1a7696	48		pha		            PHA
.1a7697	ab		plb		            PLB
.1a7698	68		pla		            PLA
.1a7699	28		plp		            PLP
.1a769a	a2 7e 08	ldx #$087e	                LDX #MLINEBUF
.1a769d	20 29 04	jsr $1a0429	            JSR PRINTS
.1a76a0	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a76a3	20 b3 03	jsr $1a03b3	            JSR PAGINATE
.1a76a6	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.1a76a8	c5 13		cmp $085b	                CMP MARG2+2
.1a76aa	90 0f		bcc $1a76bb	                BLT continue            ; No: continue
.1a76ac	c2 20		rep #$20	            REP #$20
.1a76ae	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.1a76b0	c5 11		cmp $0859	                CMP MARG2
.1a76b2	90 07		bcc $1a76bb	                BLT continue            ; Nope... keep going
.1a76b4					done
.1a76b4	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a76b7	2b		pld		                PLD
.1a76b8	ab		plb		                PLB
.1a76b9	28		plp		                PLP
.1a76ba	6b		rtl		                RTL
.1a76bb	4c 0f 76	jmp $1a760f	continue        JMP dump_line
.1a76be					M_COPY_ARGB
.1a76be	08		php		                PHP
.1a76bf	8d 92 08	sta $0892	                STA MTEMP
.1a76c2	e2 20		sep #$20	            SEP #$20
.1a76c4	bd 00 00	lda $0000,x	loop            LDA #0,B,X
.1a76c7	99 00 00	sta $0000,y	                STA #0,B,Y      ; Copy the byte
.1a76ca	ad 92 08	lda $0892	                LDA MTEMP       ; Check the count of characters remaining
.1a76cd	f0 0a		beq $1a76d9	                BEQ done        ; If it's 0, we're done
.1a76cf	c8		iny		                INY             ; Point to the next destination byte
.1a76d0	e8		inx		                INX             ; Point to the next source byte (skip three bytes)
.1a76d1	e8		inx		                INX
.1a76d2	e8		inx		                INX
.1a76d3	e8		inx		                INX
.1a76d4	ce 92 08	dec $0892	                DEC MTEMP       ; Count down and see if we're done
.1a76d7	80 eb		bra $1a76c4	                BRA loop
.1a76d9	28		plp		done            PLP
.1a76da	6b		rtl		                RTL
.1a76db					IMMODIFY
.1a76db	08		php		                PHP
.1a76dc	0b		phd		                PHD
.1a76dd	8b		phb		                PHB
.1a76de	08		php		            PHP
.1a76df	c2 20		rep #$20	            REP #$20
.1a76e1	48		pha		            PHA
.1a76e2	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a76e5	5b		tcd		            TCD
.1a76e6	68		pla		            PLA
.1a76e7	28		plp		            PLP
.1a76e8	08		php		            PHP
.1a76e9	e2 20		sep #$20	            SEP #$20
.1a76eb	48		pha		            PHA
.1a76ec	a9 00		lda #$00	            LDA #0
.1a76ee	48		pha		            PHA
.1a76ef	ab		plb		            PLB
.1a76f0	68		pla		            PLA
.1a76f1	28		plp		            PLP
.1a76f2	c2 30		rep #$30	            REP #$30
.1a76f4	a5 0d		lda $0855	                LDA MARG1           ; Set MCURSOR to MARG1
.1a76f6	85 32		sta $087a	                STA MCURSOR
.1a76f8	a5 0f		lda $0857	                LDA MARG1+2
.1a76fa	85 34		sta $087c	                STA MCURSOR+2
.1a76fc	e2 20		sep #$20	            SEP #$20
.1a76fe	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.1a7700	3a		dec a		                DEC A               ; (MARG_LEN - 1)
.1a7701	85 47		sta $088f	                STA MCOUNT
.1a7703	a2 59 08	ldx #$0859	                LDX #<>MARG2        ; Copy MCOUNT bytes from MARG2..MARG9
.1a7706	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF     ; to MLINEBUF
.1a7709	22 be 76 1a	jsl $1a76be	                JSL M_COPY_ARGB
.1a770d	a0 00 00	ldy #$0000	                LDY #0
.1a7710	b9 7e 08	lda $087e,y	loop            LDA MLINEBUF,Y      ; Copy the byte from the buffer
.1a7713	87 32		sta [$087a]	                STA [MCURSOR]       ; To the address indicated by MCURSOR
.1a7715	22 eb 86 1a	jsl $1a86eb	                JSL M_INC_CURSOR    ; Advance the cursor
.1a7719	c8		iny		                INY                 ; Go to the next buffered byte
.1a771a	c4 47		cpy $088f	                CPY MCOUNT          ; Did we just write the last one?
.1a771c	d0 f2		bne $1a7710	                BNE loop            ; No: continue writing
.1a771e	ab		plb		                PLB
.1a771f	2b		pld		                PLD
.1a7720	28		plp		                PLP
.1a7721	6b		rtl		                RTL
.1a7722					IMHUNT
.1a7722	08		php		                PHP
.1a7723	0b		phd		                PHD
.1a7724	8b		phb		                PHB
.1a7725	08		php		            PHP
.1a7726	c2 20		rep #$20	            REP #$20
.1a7728	48		pha		            PHA
.1a7729	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a772c	5b		tcd		            TCD
.1a772d	68		pla		            PLA
.1a772e	28		plp		            PLP
.1a772f	08		php		            PHP
.1a7730	e2 20		sep #$20	            SEP #$20
.1a7732	48		pha		            PHA
.1a7733	a9 00		lda #$00	            LDA #0
.1a7735	48		pha		            PHA
.1a7736	ab		plb		            PLB
.1a7737	68		pla		            PLA
.1a7738	28		plp		            PLP
.1a7739	e2 20		sep #$20	            SEP #$20
.1a773b	c2 10		rep #$10	            REP #$10
.1a773d	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.1a773f	3a		dec a		                DEC A               ; (MARG_LEN - 2)
.1a7740	3a		dec a		                DEC A
.1a7741	85 47		sta $088f	                STA MCOUNT
.1a7743	a2 5d 08	ldx #$085d	                LDX #<>MARG3
.1a7746	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF
.1a7749	22 be 76 1a	jsl $1a76be	                JSL M_COPY_ARGB
.1a774d	c2 20		rep #$20	            REP #$20
.1a774f	a5 0d		lda $0855	                LDA MARG1           ; Copy starting address to MCURSOR
.1a7751	85 32		sta $087a	                STA MCURSOR
.1a7753	a5 0f		lda $0857	                LDA MARG1+2
.1a7755	85 34		sta $087c	                STA MCURSOR+2
.1a7757					outer_loop
.1a7757	c2 20		rep #$20	            REP #$20
.1a7759	a5 34		lda $087c	                LDA MCURSOR+2      ; If MCURSOR < MARG2, we're not done yet
.1a775b	c5 13		cmp $085b	                CMP MARG2+2
.1a775d	d0 06		bne $1a7765	                BNE not_done
.1a775f	a5 32		lda $087a	                LDA MCURSOR
.1a7761	c5 11		cmp $0859	                CMP MARG2
.1a7763	f0 2c		beq $1a7791	                BEQ done            ; MCURSOR = MARG2: we're done
.1a7765					not_done
.1a7765	e2 20		sep #$20	            SEP #$20
.1a7767	a0 00 00	ldy #$0000	                LDY #0
.1a776a	b7 32		lda [$087a],y	cmp_loop        LDA [MCURSOR],Y     ; Get the byte from the memory to check
.1a776c	d9 7e 08	cmp $087e,y	                CMP MLINEBUF,Y      ; Compare it against our pattern
.1a776f	d0 1a		bne $1a778b	                BNE advance         ; If not equal, we need to move on
.1a7771	c8		iny		                INY                 ; Otherwise do we have more bytes to check?
.1a7772	c4 47		cpy $088f	                CPY MCOUNT
.1a7774	d0 f4		bne $1a776a	                BNE cmp_loop        ; No: check more
.1a7776	c2 20		rep #$20	            REP #$20
.1a7778	a5 32		lda $087a	                LDA MCURSOR         ; Print the address
.1a777a	85 4a		sta $0892	                STA MTEMP
.1a777c	a5 34		lda $087c	                LDA MCURSOR+2
.1a777e	85 4c		sta $0894	                STA MTEMP+2
.1a7780	22 95 81 1a	jsl $1a8195	                JSL M_PR_ADDR
.1a7784	e2 20		sep #$20	            SEP #$20
.1a7786	a9 20		lda #$20	                LDA #' '
.1a7788	20 18 00	jsr $1a0018	            JSR PRINTC
.1a778b	22 eb 86 1a	jsl $1a86eb	advance         JSL M_INC_CURSOR    ; Move MCURSOR forward by one
.1a778f	80 c6		bra $1a7757	                BRA outer_loop      ; And try to compare that to the pattern
.1a7791					done
.1a7791	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a7794	ab		plb		                PLB
.1a7795	2b		pld		                PLD
.1a7796	28		plp		                PLP
.1a7797	6b		rtl		                RTL
.1a7798					IMJUMP
.1a7798	08		php		            PHP
.1a7799	c2 20		rep #$20	            REP #$20
.1a779b	48		pha		            PHA
.1a779c	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a779f	5b		tcd		            TCD
.1a77a0	68		pla		            PLA
.1a77a1	28		plp		            PLP
.1a77a2	e2 20		sep #$20	            SEP #$20
.1a77a4	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.1a77a6	f0 0e		beq $1a77b6	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.1a77a8	c2 30		rep #$30	            REP #$30
.1a77aa	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.1a77ac	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.1a77b0	a5 0f		lda $0857	                LDA MARG1+2
.1a77b2	8f 42 02 00	sta $000242	                STA @lCPUPBR
.1a77b6	af 46 02 00	lda $000246	MJUMPRESTORE    LDA @lCPUX          ; Restore X and Y
.1a77ba	aa		tax		                TAX
.1a77bb	af 48 02 00	lda $000248	                LDA @lCPUY
.1a77bf	a8		tay		                TAY
.1a77c0	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.1a77c4	1b		tcs		                TCS
.1a77c5	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.1a77c9	5b		tcd		                TCD
.1a77ca	e2 20		sep #$20	            SEP #$20
.1a77cc	a9 1a		lda #$1a	                LDA #`MJUMPSTART
.1a77ce	48		pha		                PHA
.1a77cf	a9 77		lda #$77	                LDA #>MJUMPSTART
.1a77d1	48		pha		                PHA
.1a77d2	a9 d8		lda #$d8	                LDA #<MJUMPSTART
.1a77d4	48		pha		                PHA
.1a77d5	4c 0f 78	jmp $1a780f	                JMP MGOSTACK        ; And push remaining registers and restart execution
.1a77d8	ea		nop		MJUMPSTART      NOP                 ; RTL increments PC pulled from stack, NOP leaves space for that
.1a77d9	5c 04 00 1a	jmp $1a0004	                JML MONITOR
.1a77dd					IMGO
.1a77dd	08		php		            PHP
.1a77de	c2 20		rep #$20	            REP #$20
.1a77e0	48		pha		            PHA
.1a77e1	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a77e4	5b		tcd		            TCD
.1a77e5	68		pla		            PLA
.1a77e6	28		plp		            PLP
.1a77e7	e2 20		sep #$20	            SEP #$20
.1a77e9	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.1a77eb	f0 c9		beq $1a77b6	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.1a77ed	c2 30		rep #$30	            REP #$30
.1a77ef	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.1a77f1	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.1a77f5	a5 0f		lda $0857	                LDA MARG1+2
.1a77f7	8f 42 02 00	sta $000242	                STA @lCPUPBR
.1a77fb	af 46 02 00	lda $000246	MGORESTORE      LDA @lCPUX          ; Restore X and Y
.1a77ff	aa		tax		                TAX
.1a7800	af 48 02 00	lda $000248	                LDA @lCPUY
.1a7804	a8		tay		                TAY
.1a7805	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.1a7809	1b		tcs		                TCS
.1a780a	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.1a780e	5b		tcd		                TCD
.1a780f					MGOSTACK
.1a780f	e2 20		sep #$20	            SEP #$20
.1a7811	af 4e 02 00	lda $00024e	                LDA @lCPUDBR        ; Restore the data bank register
.1a7815	48		pha		                PHA
.1a7816	ab		plb		                PLB
.1a7817	a9 5c		lda #$5c	                LDA #$5C            ; Save the JSL opcode
.1a7819	8f a2 08 00	sta $0008a2	                STA @lMJUMPINST
.1a781d	af 42 02 00	lda $000242	                LDA @lCPUPBR        ; Write PBR
.1a7821	8f a5 08 00	sta $0008a5	                STA @lMJUMPADDR+2
.1a7825	af 41 02 00	lda $000241	                LDA @lCPUPC+1       ; Write PCH
.1a7829	8f a4 08 00	sta $0008a4	                STA @lMJUMPADDR+1
.1a782d	af 40 02 00	lda $000240	                LDA @lCPUPC         ; Write PCL
.1a7831	8f a3 08 00	sta $0008a3	                STA @lMJUMPADDR
.1a7835	af 4f 02 00	lda $00024f	                LDA @lCPUFLAGS      ; Push processor status
.1a7839	48		pha		                PHA
.1a783a	c2 20		rep #$20	            REP #$20
.1a783c	af 44 02 00	lda $000244	                LDA @lCPUA          ; Restore A
.1a7840	28		plp		                PLP                 ; And the status register
.1a7841	5c a2 08 00	jmp $0008a2	                JML MJUMPINST       ; And jump to the target address
.1a7845					IMCOMPARE
.1a7845	08		php		                PHP
.1a7846	0b		phd		                PHD
.1a7847	8b		phb		                PHB
.1a7848	08		php		            PHP
.1a7849	e2 20		sep #$20	            SEP #$20
.1a784b	48		pha		            PHA
.1a784c	a9 1a		lda #$1a	            LDA #`MERRARGS
.1a784e	48		pha		            PHA
.1a784f	ab		plb		            PLB
.1a7850	68		pla		            PLA
.1a7851	28		plp		            PLP
.1a7852	08		php		            PHP
.1a7853	c2 20		rep #$20	            REP #$20
.1a7855	48		pha		            PHA
.1a7856	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a7859	5b		tcd		            TCD
.1a785a	68		pla		            PLA
.1a785b	28		plp		            PLP
.1a785c	c2 10		rep #$10	            REP #$10
.1a785e	e2 20		sep #$20	            SEP #$20
.1a7860	a5 31		lda $0879	                LDA MARG_LEN                ; Check the number of arguments provided
.1a7862	c9 02		cmp #$02	                CMP #2
.1a7864	f0 0c		beq $1a7872	                BEQ default_len             ; If 2: set MCOUNT to default of 1
.1a7866	c9 03		cmp #$03	                CMP #3
.1a7868	d0 11		bne $1a787b	                BNE bad_arguments           ; Otherwise, if not 3: print an error
.1a786a	c2 20		rep #$20	            REP #$20
.1a786c	a5 15		lda $085d	                LDA MARG3                   ; If 3: set MCOUNT to MARG3
.1a786e	85 47		sta $088f	                STA MCOUNT
.1a7870	80 11		bra $1a7883	                BRA compare
.1a7872					default_len
.1a7872	c2 20		rep #$20	            REP #$20
.1a7874	a9 01 00	lda #$0001	                LDA #1                      ; No length was provided, set MCOUNT to 1
.1a7877	85 47		sta $088f	                STA MCOUNT
.1a7879	80 08		bra $1a7883	                BRA compare
.1a787b	a2 b7 89	ldx #$89b7	bad_arguments   LDX #<>MERRARGS             ; The wrong number of arguments was provided
.1a787e	20 29 04	jsr $1a0429	            JSR PRINTS
.1a7881	80 35		bra $1a78b8	                BRA done
.1a7883	a5 0d		lda $0855	compare         LDA MARG1                   ; Set MTEMP to MARG1
.1a7885	85 4a		sta $0892	                STA MTEMP
.1a7887	a5 0f		lda $0857	                LDA MARG1+2
.1a7889	85 4c		sta $0894	                STA MTEMP+2
.1a788b	a0 00 00	ldy #$0000	                LDY #0
.1a788e					loop
.1a788e	e2 20		sep #$20	            SEP #$20
.1a7890	a7 4a		lda [$0892]	                LDA [MTEMP]                 ; Compare the byte at MTEMP
.1a7892	d7 11		cmp [$0859],y	                CMP [MARG2],Y               ; To the Yth byte from MARG2
.1a7894	f0 09		beq $1a789f	                BEQ continue                ; If they're the same, keep going
.1a7896	22 95 81 1a	jsl $1a8195	mismatch        JSL M_PR_ADDR               ; If they're different, print MTEMP
.1a789a	a9 20		lda #$20	                LDA #' '
.1a789c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a789f					continue
.1a789f	c2 20		rep #$20	            REP #$20
.1a78a1	18		clc		                CLC                         ; Either way, increment MTEMP
.1a78a2	a5 4a		lda $0892	                LDA MTEMP
.1a78a4	69 01 00	adc #$0001	                ADC #1
.1a78a7	85 4a		sta $0892	                STA MTEMP
.1a78a9	a5 4c		lda $0894	                LDA MTEMP+2
.1a78ab	69 00 00	adc #$0000	                ADC #0
.1a78ae	85 4c		sta $0894	                STA MTEMP+2
.1a78b0	c8		iny		                INY                         ; Increment Y
.1a78b1	c4 47		cpy $088f	                CPY MCOUNT                  ; Try again unless we've checked MCOUNT bytes
.1a78b3	d0 d9		bne $1a788e	                BNE loop
.1a78b5	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a78b8					done
.1a78b8	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a78bb	ab		plb		                PLB
.1a78bc	2b		pld		                PLD
.1a78bd	28		plp		                PLP
.1a78be	6b		rtl		                RTL
.1a78bf					IMRMODIFY
.1a78bf	08		php		                PHP
.1a78c0	0b		phd		                PHD
.1a78c1	8b		phb		                PHB
.1a78c2	08		php		            PHP
.1a78c3	e2 20		sep #$20	            SEP #$20
.1a78c5	48		pha		            PHA
.1a78c6	a9 00		lda #$00	            LDA #0
.1a78c8	48		pha		            PHA
.1a78c9	ab		plb		            PLB
.1a78ca	68		pla		            PLA
.1a78cb	28		plp		            PLP
.1a78cc	08		php		            PHP
.1a78cd	c2 20		rep #$20	            REP #$20
.1a78cf	48		pha		            PHA
.1a78d0	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a78d3	5b		tcd		            TCD
.1a78d4	68		pla		            PLA
.1a78d5	28		plp		            PLP
.1a78d6	e2 20		sep #$20	            SEP #$20
.1a78d8	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.1a78da	f0 4f		beq $1a792b	                BEQ done            ; 0? Just quit
.1a78dc	a6 0d		ldx $0855	                LDX MARG1           ; Set the PC and PBR
.1a78de	8e 40 02	stx $0240	                STX #CPUPC,B
.1a78e1	a6 0f		ldx $0857	                LDX MARG1+2
.1a78e3	8e 42 02	stx $0242	                STX #CPUPBR,B
.1a78e6	c9 01		cmp #$01	                CMP #1              ; Check the number of arguments
.1a78e8	f0 41		beq $1a792b	                BEQ done            ; 1? Just quit
.1a78ea	a6 11		ldx $0859	                LDX MARG2           ; Set A
.1a78ec	8e 44 02	stx $0244	                STX #CPUA,B
.1a78ef	c9 02		cmp #$02	                CMP #2              ; Check the number of arguments
.1a78f1	f0 38		beq $1a792b	                BEQ done            ; 2? Just quit
.1a78f3	a6 15		ldx $085d	                LDX MARG3           ; Set X
.1a78f5	8e 46 02	stx $0246	                STX #CPUX,B
.1a78f8	c9 03		cmp #$03	                CMP #3              ; Check the number of arguments
.1a78fa	f0 2f		beq $1a792b	                BEQ done            ; 3? Just quit
.1a78fc	a6 19		ldx $0861	                LDX MARG4           ; Set Y
.1a78fe	8e 48 02	stx $0248	                STX #CPUY,B
.1a7901	c9 04		cmp #$04	                CMP #4              ; Check the number of arguments
.1a7903	f0 26		beq $1a792b	                BEQ done            ; 4? Just quit
.1a7905	a6 1d		ldx $0865	                LDX MARG5           ; Set SP
.1a7907	8e 4a 02	stx $024a	                STX #CPUSTACK,B
.1a790a	c9 05		cmp #$05	                CMP #5              ; Check the number of arguments
.1a790c	f0 1d		beq $1a792b	                BEQ done            ; 5? Just quit
.1a790e	e2 10		sep #$10	            SEP #$10
.1a7910	a6 21		ldx $0869	                LDX MARG6           ; Set DBR
.1a7912	8e 4e 02	stx $024e	                STX #CPUDBR,B
.1a7915	c9 06		cmp #$06	                CMP #6              ; Check the number of arguments
.1a7917	f0 12		beq $1a792b	                BEQ done            ; 6? Just quit
.1a7919	c2 10		rep #$10	            REP #$10
.1a791b	a6 25		ldx $086d	                LDX MARG7           ; Set DP
.1a791d	8e 4c 02	stx $024c	                STX #CPUDP,B
.1a7920	c9 07		cmp #$07	                CMP #7              ; Check the number of arguments
.1a7922	f0 07		beq $1a792b	                BEQ done            ; 7? Just quit
.1a7924	e2 10		sep #$10	            SEP #$10
.1a7926	a6 29		ldx $0871	                LDX MARG8           ; Set flags
.1a7928	8e 4f 02	stx $024f	                STX #CPUFLAGS,B
.1a792b	ab		plb		done            PLB
.1a792c	2b		pld		                PLD
.1a792d	28		plp		                PLP
.1a792e	6b		rtl		                RTL
.1a792f					IMEXECUTE
.1a792f	08		php		                PHP
.1a7930	0b		phd		                PHD
.1a7931	8b		phb		                PHB
.1a7932	08		php		            PHP
.1a7933	c2 20		rep #$20	            REP #$20
.1a7935	48		pha		            PHA
.1a7936	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7939	5b		tcd		            TCD
.1a793a	68		pla		            PLA
.1a793b	28		plp		            PLP
.1a793c	e2 20		sep #$20	            SEP #$20
.1a793e	c2 10		rep #$10	            REP #$10
.1a7940	a2 00 00	ldx #$0000	                LDX #0
.1a7943	bf 24 8a 1a	lda $1a8a24,x	loop            LDA @lMCOMMANDS,X
.1a7947	f0 18		beq $1a7961	                BEQ done
.1a7949	c7 08		cmp [$0850]	                CMP [MCMD]
.1a794b	f0 03		beq $1a7950	                BEQ found
.1a794d	e8		inx		                INX
.1a794e	80 f3		bra $1a7943	                BRA loop
.1a7950					found
.1a7950	c2 20		rep #$20	            REP #$20
.1a7952	8a		txa		                TXA
.1a7953	0a		asl a		                ASL A
.1a7954	aa		tax		                TAX
.1a7955	bf 65 79 1a	lda $1a7965,x	                LDA dispatch,X
.1a7959	8f 2f 08 00	sta $00082f	                STA @lJMP16PTR
.1a795d	22 89 79 1a	jsl $1a7989	                JSL MDOCMD
.1a7961	ab		plb		done            PLB
.1a7962	2b		pld		                PLD
.1a7963	28		plp		                PLP
.1a7964	6b		rtl		                RTL
>1a7965	05 70				dispatch        .word <>MASSEMBLE
>1a7967	0d 70				                .word <>MCOMPARE
>1a7969	11 70				                .word <>MDISASSEMBLE
>1a796b	15 70				                .word <>MFILL
>1a796d	19 70				                .word <>MGO
>1a796f	1d 70				                .word <>MJUMP
>1a7971	21 70				                .word <>MHUNT
>1a7973	25 70				                .word <>MLOAD
>1a7975	29 70				                .word <>MMEMORY
>1a7977	2d 70				                .word <>MREGISTERS
>1a7979	09 70				                .word <>MRMODIFY
>1a797b	31 70				                .word <>MSAVE
>1a797d	35 70				                .word <>MTRANSFER
>1a797f	39 70				                .word <>MVERIFY
>1a7981	fb 73				                .word <>IMWIDTH
>1a7983	3d 70				                .word <>MEXIT
>1a7985	41 70				                .word <>MMODIFY
>1a7987	74 70				                .word <>IMHELP
.1a7989					MDOCMD
.1a7989	6c 2f 08	jmp ($082f)	                JMP (JMP16PTR)

;******  Processing file: src\assembler.s

=0					ADDR_DP_IND_X = 0       ; (dd,X)
=1					ADDR_DP = 1             ; dd
=2					ADDR_IMM = 2            ; #dd
=3					ADDR_ABS = 3            ; dddd
=4					ADDR_DP_IND_Y = 4       ; (dd),Y
=5					ADDR_DP_X = 5           ; dd,X
=6					ADDR_ABS_Y = 6          ; dddd,Y
=7					ADDR_ABS_X = 7          ; dddd,X
=8					ADDR_ACC = 8            ; A
=9					ADDR_SP_R = 9           ; #d,S
=10					ADDR_DP_LONG = 10       ; [dd]
=11					ADDR_ABS_LONG = 11      ; dddddd
=12					ADDR_SP_R_Y = 12        ; #dd,S,Y
=13					ADDR_DP_Y_LONG = 13     ; [dd],Y
=14					ADDR_ABS_X_LONG = 14    ; dddddd,X
=15					ADDR_DP_IND = 15        ; (dd)
=16					ADDR_ABS_X_ID = 16      ; (dddd,X)
=17					ADDR_DP_Y = 17          ; dd,Y
=18					ADDR_PC_REL = 18        ; PC relative
=19					ADDR_IMPLIED = 19       ; Implied (no operand)
=20					ADDR_XYC = 20           ; #dd, #dd
=21					ADDR_ABS_IND = 21       ; (dddd)
=22					ADDR_PC_REL_LONG = 22   ; PC relative ()
=23					ADDR_ABS_IND_LONG = 23  ; [dddd]
=$80					OP_M_EFFECT = $80       ; Flag to indicate instruction is modified by M
=$40					OP_X_EFFECT = $40       ; Flag to indicate instruction is modified by X
.1a798c					IMASSEMBLE
.1a798c	08		php		                PHP
.1a798d	8b		phb		                PHB
.1a798e	0b		phd		                PHD
.1a798f	08		php		            PHP
.1a7990	c2 20		rep #$20	            REP #$20
.1a7992	48		pha		            PHA
.1a7993	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7996	5b		tcd		            TCD
.1a7997	68		pla		            PLA
.1a7998	28		plp		            PLP
.1a7999	e2 20		sep #$20	            SEP #$20
.1a799b	a5 31		lda $0879	                LDA MARG_LEN            ; Do we have at least 2 arguments?
.1a799d	c9 02		cmp #$02	                CMP #2
.1a799f	b0 03		bcs $1a79a4	                BGE has_args            ; Yes: try to assemble the line
.1a79a1	4c 32 7b	jmp $1a7b32	                JMP done                ; No: just return
.1a79a4					has_args
.1a79a4	c2 20		rep #$20	            REP #$20
.1a79a6	a5 0d		lda $0855	                LDA MARG1               ; Set the monitor cursor to the address
.1a79a8	85 32		sta $087a	                STA MCURSOR
.1a79aa	a5 0f		lda $0857	                LDA MARG1+2
.1a79ac	85 34		sta $087c	                STA MCURSOR+2
.1a79ae	c2 20		rep #$20	            REP #$20
.1a79b0	22 34 7d 1a	jsl $1a7d34	                JSL AS_FIND_MNEMO       ; Find the address of the mnemonic
.1a79b4	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a79b7	f0 10		beq $1a79c9	                BEQ bad_mnemonic        ; If not found, print bad mnemonic error message
.1a79b9	85 54		sta $089c	                STA MMNEMONIC
.1a79bb	e2 20		sep #$20	            SEP #$20
.1a79bd	a5 31		lda $0879	                LDA MARG_LEN            ; Check the number of arguments passed
.1a79bf	c9 03		cmp #$03	                CMP #3                  ; Were all three arguments provided?
.1a79c1	f0 36		beq $1a79f9	                BEQ get_operand         ; Yes: parse the operand
.1a79c3	a9 13		lda #$13	                LDA #ADDR_IMPLIED       ; No: assume address mode is implied
.1a79c5	85 4f		sta $0897	                STA MADDR_MODE
.1a79c7	80 4c		bra $1a7a15	                BRA get_opcode
.1a79c9					bad_mnemonic
.1a79c9	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a79cc	08		php		            PHP
.1a79cd	e2 20		sep #$20	            SEP #$20
.1a79cf	48		pha		            PHA
.1a79d0	a9 1a		lda #$1a	            LDA #`MERRBADMNEMO
.1a79d2	48		pha		            PHA
.1a79d3	ab		plb		            PLB
.1a79d4	68		pla		            PLA
.1a79d5	28		plp		            PLP
.1a79d6	c2 10		rep #$10	            REP #$10
.1a79d8	a2 69 7b	ldx #$7b69	                LDX #<>MERRBADMNEMO
.1a79db	20 29 04	jsr $1a0429	            JSR PRINTS
.1a79de	4c 32 7b	jmp $1a7b32	                JMP done
.1a79e1					bad_operand
.1a79e1	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a79e4	08		php		            PHP
.1a79e5	e2 20		sep #$20	            SEP #$20
.1a79e7	48		pha		            PHA
.1a79e8	a9 1a		lda #$1a	            LDA #`MERRBADOPER
.1a79ea	48		pha		            PHA
.1a79eb	ab		plb		            PLB
.1a79ec	68		pla		            PLA
.1a79ed	28		plp		            PLP
.1a79ee	c2 10		rep #$10	            REP #$10
.1a79f0	a2 78 7b	ldx #$7b78	                LDX #<>MERRBADOPER
.1a79f3	20 29 04	jsr $1a0429	            JSR PRINTS
.1a79f6	4c 32 7b	jmp $1a7b32	                JMP done
.1a79f9					get_operand
.1a79f9	e2 20		sep #$20	            SEP #$20
.1a79fb	22 6a 7d 1a	jsl $1a7d6a	                JSL AS_FIND_MODE        ; Find the addressing mode of the operand
.1a79ff	c9 ff		cmp #$ff	compare         CMP #$FF
.1a7a01	f0 de		beq $1a79e1	                BEQ bad_operand         ; If not found, print bad operand error message
.1a7a03	85 4f		sta $0897	                STA MADDR_MODE
.1a7a05	c9 03		cmp #$03	                CMP #ADDR_ABS           ; If mode is absolute or absolute long...
.1a7a07	f0 62		beq $1a7a6b	                BEQ check_for_pcrel     ; Check to see if the mnemonic is one of the branches
.1a7a09	c9 0b		cmp #$0b	                CMP #ADDR_ABS_LONG
.1a7a0b	f0 5e		beq $1a7a6b	                BEQ check_for_pcrel
.1a7a0d	c9 13		cmp #$13	                CMP #ADDR_IMPLIED       ; If mode is implied or accumulator, get the opcode
.1a7a0f	f0 04		beq $1a7a15	                BEQ get_opcode
.1a7a11	c9 08		cmp #$08	                CMP #ADDR_ACC
.1a7a13	f0 00		beq $1a7a15	                BEQ get_opcode
.1a7a15	22 62 7c 1a	jsl $1a7c62	get_opcode      JSL AS_FIND_OPCODE      ; Find the opcode matching the two
.1a7a19	b0 03		bcs $1a7a1e	                BCS save_opcode
.1a7a1b	4c fb 7a	jmp $1a7afb	                JMP bad_mode            ; If opcode not found, print bad address mode error message
.1a7a1e	87 32		sta [$087a]	save_opcode     STA [MCURSOR]           ; Write the opcode to the address
.1a7a20	22 eb 86 1a	jsl $1a86eb	                JSL M_INC_CURSOR        ; And point to the next byte
.1a7a24	08		php		            PHP
.1a7a25	e2 20		sep #$20	            SEP #$20
.1a7a27	48		pha		            PHA
.1a7a28	a9 00		lda #$00	            LDA #0
.1a7a2a	48		pha		            PHA
.1a7a2b	ab		plb		            PLB
.1a7a2c	68		pla		            PLA
.1a7a2d	28		plp		            PLP
.1a7a2e	c2 20		rep #$20	            REP #$20
.1a7a30	a5 32		lda $087a	                LDA MCURSOR             ; Make MTEMPPTR a pointer to the machine code we're assembling
.1a7a32	85 56		sta $089e	                STA MTEMPPTR
.1a7a34	a5 34		lda $087c	                LDA MCURSOR+2
.1a7a36	85 58		sta $08a0	                STA MTEMPPTR+2
.1a7a38	e2 20		sep #$20	            SEP #$20
.1a7a3a	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check the address mode again
.1a7a3c	c9 12		cmp #$12	                CMP #ADDR_PC_REL        ; If it's PC relative
.1a7a3e	f0 6c		beq $1a7aac	                BEQ compute_rel         ; Convert the address to an offset
.1a7a40	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.1a7a42	f0 68		beq $1a7aac	                BEQ compute_rel
.1a7a44	c9 14		cmp #$14	                CMP #ADDR_XYC           ; MVP/MVN addressing mode?
.1a7a46	f0 7c		beq $1a7ac4	                BEQ emit_2
.1a7a48	29 3f		and #$3f	                AND #%00111111          ; Filter out the mode bits
.1a7a4a	c9 02		cmp #$02	                CMP #ADDR_IMM           ; Is it immediate?
.1a7a4c	d0 03		bne $1a7a51	                BNE fixed_length        ; Yes: emit it as an immediate (variable length)
.1a7a4e	4c 29 7b	jmp $1a7b29	                JMP emit_imm
.1a7a51					fixed_length
.1a7a51	c2 20		rep #$20	            REP #$20
.1a7a53	29 ff 00	and #$00ff	                AND #$00FF
.1a7a56	aa		tax		                TAX
.1a7a57	e2 20		sep #$20	            SEP #$20
.1a7a59	bf 31 86 1a	lda $1a8631,x	get_length      LDA ADDR_LENGTH,X       ; Get the number of bytes in the addressing mode
.1a7a5d	c9 03		cmp #$03	                CMP #$03
.1a7a5f	f0 57		beq $1a7ab8	                BEQ emit_3
.1a7a61	c9 02		cmp #$02	                CMP #$02
.1a7a63	f0 5f		beq $1a7ac4	                BEQ emit_2
.1a7a65	c9 01		cmp #$01	                CMP #$01
.1a7a67	f0 67		beq $1a7ad0	                BEQ emit_1
.1a7a69	80 71		bra $1a7adc	                BRA next_line
.1a7a6b					check_for_pcrel
.1a7a6b	c2 20		rep #$20	            REP #$20
.1a7a6d	a5 54		lda $089c	                LDA MMNEMONIC
.1a7a6f	c9 a9 82	cmp #$82a9	                CMP #<>MN_BRA
.1a7a72	f0 26		beq $1a7a9a	                BEQ is_pcrel
.1a7a74	c9 0d 83	cmp #$830d	                CMP #<>MN_BRL
.1a7a77	f0 2a		beq $1a7aa3	                BEQ is_pcrel_long
.1a7a79	c9 8d 82	cmp #$828d	                CMP #<>MN_BCC
.1a7a7c	f0 1c		beq $1a7a9a	                BEQ is_pcrel
.1a7a7e	c9 91 82	cmp #$8291	                CMP #<>MN_BCS
.1a7a81	f0 17		beq $1a7a9a	                BEQ is_pcrel
.1a7a83	c9 99 82	cmp #$8299	                CMP #<>MN_BEQ
.1a7a86	f0 12		beq $1a7a9a	                BEQ is_pcrel
.1a7a88	c9 81 82	cmp #$8281	                CMP #<>MN_BMI
.1a7a8b	f0 0d		beq $1a7a9a	                BEQ is_pcrel
.1a7a8d	c9 95 82	cmp #$8295	                CMP #<>MN_BNE
.1a7a90	f0 08		beq $1a7a9a	                BEQ is_pcrel
.1a7a92	c9 7d 82	cmp #$827d	                CMP #<>MN_BPL
.1a7a95	f0 03		beq $1a7a9a	                BEQ is_pcrel
.1a7a97	4c 15 7a	jmp $1a7a15	                JMP get_opcode
.1a7a9a					is_pcrel
.1a7a9a	e2 20		sep #$20	            SEP #$20
.1a7a9c	a9 12		lda #$12	                LDA #ADDR_PC_REL
.1a7a9e	85 4f		sta $0897	                STA MADDR_MODE
.1a7aa0	4c 15 7a	jmp $1a7a15	                JMP get_opcode
.1a7aa3					is_pcrel_long
.1a7aa3	e2 20		sep #$20	            SEP #$20
.1a7aa5	a9 16		lda #$16	                LDA #ADDR_PC_REL_LONG
.1a7aa7	85 4f		sta $0897	                STA MADDR_MODE
.1a7aa9	4c 15 7a	jmp $1a7a15	                JMP get_opcode
.1a7aac	22 a5 7b 1a	jsl $1a7ba5	compute_rel     JSL AS_PC_OFFSET        ; Try to compute the offset
.1a7ab0	90 60		bcc $1a7b12	                BCC bad_offset          ; If failed, it's a bad offset operand
.1a7ab2	c9 02		cmp #$02	emit_rel        CMP #$02                ; If the offset is two bytes
.1a7ab4	f0 0e		beq $1a7ac4	                BEQ emit_2              ; Emit those two bytes
.1a7ab6	80 18		bra $1a7ad0	                BRA emit_1              ; Otherwise emit just the one
.1a7ab8	a0 02 00	ldy #$0002	emit_3          LDY #2                  ; Write bank byte of operand
.1a7abb	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.1a7abe	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.1a7ac0	22 eb 86 1a	jsl $1a86eb	                JSL M_INC_CURSOR
.1a7ac4	a0 01 00	ldy #$0001	emit_2          LDY #1                  ; Write high byte of operand
.1a7ac7	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.1a7aca	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.1a7acc	22 eb 86 1a	jsl $1a86eb	                JSL M_INC_CURSOR
.1a7ad0	a0 00 00	ldy #$0000	emit_1          LDY #0                  ; Write low byte of operand
.1a7ad3	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.1a7ad6	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.1a7ad8	22 eb 86 1a	jsl $1a86eb	                JSL M_INC_CURSOR
.1a7adc					next_line
.1a7adc	e2 20		sep #$20	            SEP #$20
.1a7ade	a9 41		lda #$41	                LDA #'A'
.1a7ae0	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ae3	a9 20		lda #$20	                LDA #' '
.1a7ae5	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ae8	a6 32		ldx $087a	                LDX MCURSOR
.1a7aea	86 4a		stx $0892	                STX MTEMP
.1a7aec	a6 34		ldx $087c	                LDX MCURSOR+2
.1a7aee	86 4c		stx $0894	                STX MTEMP+2
.1a7af0	22 95 81 1a	jsl $1a8195	                JSL M_PR_ADDR
.1a7af4	a9 20		lda #$20	                LDA #' '
.1a7af6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7af9	80 37		bra $1a7b32	                BRA done
.1a7afb					bad_mode
.1a7afb	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a7afe	08		php		            PHP
.1a7aff	e2 20		sep #$20	            SEP #$20
.1a7b01	48		pha		            PHA
.1a7b02	a9 1a		lda #$1a	            LDA #`MERRBADMODE
.1a7b04	48		pha		            PHA
.1a7b05	ab		plb		            PLB
.1a7b06	68		pla		            PLA
.1a7b07	28		plp		            PLP
.1a7b08	c2 10		rep #$10	            REP #$10
.1a7b0a	a2 36 7b	ldx #$7b36	                LDX #<>MERRBADMODE
.1a7b0d	20 29 04	jsr $1a0429	            JSR PRINTS
.1a7b10	80 20		bra $1a7b32	                BRA done
.1a7b12					bad_offset
.1a7b12	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a7b15	08		php		            PHP
.1a7b16	e2 20		sep #$20	            SEP #$20
.1a7b18	48		pha		            PHA
.1a7b19	a9 1a		lda #$1a	            LDA #`MERRBADOFFSET
.1a7b1b	48		pha		            PHA
.1a7b1c	ab		plb		            PLB
.1a7b1d	68		pla		            PLA
.1a7b1e	28		plp		            PLP
.1a7b1f	c2 10		rep #$10	            REP #$10
.1a7b21	a2 86 7b	ldx #$7b86	                LDX #<>MERRBADOFFSET
.1a7b24	20 29 04	jsr $1a0429	            JSR PRINTS
.1a7b27	80 09		bra $1a7b32	                BRA done
.1a7b29	a5 4f		lda $0897	emit_imm        LDA MADDR_MODE          ; Check to see if long immediate was used
.1a7b2b	29 c0		and #$c0	                AND #%11000000
.1a7b2d	d0 95		bne $1a7ac4	                BNE emit_2              ; Yes: emit two bytes
.1a7b2f	4c d0 7a	jmp $1a7ad0	                JMP emit_1              ; No: emit one byte
.1a7b32	2b		pld		done            PLD
.1a7b33	ab		plb		                PLB
.1a7b34	28		plp		                PLP
.1a7b35	6b		rtl		                RTL
>1a7b36	41 64 64 72 65 73 73 69		MERRBADMODE     .null "Addressing mode not defined for that instruction.",CHAR_CR
>1a7b3e	6e 67 20 6d 6f 64 65 20 6e 6f 74 20 64 65 66 69
>1a7b4e	6e 65 64 20 66 6f 72 20 74 68 61 74 20 69 6e 73
>1a7b5e	74 72 75 63 74 69 6f 6e 2e 0d 00
>1a7b69	42 61 64 20 6d 6e 65 6d		MERRBADMNEMO    .null "Bad mnemonic.",CHAR_CR
>1a7b71	6f 6e 69 63 2e 0d 00
>1a7b78	42 61 64 20 6f 70 65 72		MERRBADOPER     .null "Bad operand.",CHAR_CR
>1a7b80	61 6e 64 2e 0d 00
>1a7b86	52 65 6c 61 74 69 76 65		MERRBADOFFSET   .null "Relative offset is too large.",CHAR_CR
>1a7b8e	20 6f 66 66 73 65 74 20 69 73 20 74 6f 6f 20 6c
>1a7b9e	61 72 67 65 2e 0d 00
.1a7ba5					AS_PC_OFFSET
.1a7ba5	08		php		                PHP
.1a7ba6	0b		phd		                PHD
.1a7ba7	08		php		            PHP
.1a7ba8	c2 20		rep #$20	            REP #$20
.1a7baa	48		pha		            PHA
.1a7bab	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7bae	5b		tcd		            TCD
.1a7baf	68		pla		            PLA
.1a7bb0	28		plp		            PLP
.1a7bb1	e2 20		sep #$20	            SEP #$20
.1a7bb3	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check to see if it 1 byte or 2 byte relative
.1a7bb5	c9 12		cmp #$12	                CMP #ADDR_PC_REL
.1a7bb7	f0 0a		beq $1a7bc3	                BEQ is_short
.1a7bb9	c2 20		rep #$20	            REP #$20
.1a7bbb	18		clc		                CLC                     ; Branch is long. Compute where MCURSOR will be
.1a7bbc	a5 32		lda $087a	                LDA MCURSOR             ; with two branch offset bytes
.1a7bbe	69 02 00	adc #$0002	                ADC #2
.1a7bc1	80 08		bra $1a7bcb	                BRA compute_cursor
.1a7bc3					is_short
.1a7bc3	c2 20		rep #$20	            REP #$20
.1a7bc5	18		clc		                CLC                     ; Branch is short. Computer where MCURSOR will be
.1a7bc6	a5 32		lda $087a	                LDA MCURSOR             ; with one branch offset byte
.1a7bc8	69 01 00	adc #$0001	                ADC #1
.1a7bcb	85 4a		sta $0892	compute_cursor  STA MTEMP
.1a7bcd	a5 34		lda $087c	                LDA MCURSOR+2
.1a7bcf	69 00 00	adc #$0000	                ADC #0
.1a7bd2	85 4c		sta $0894	                STA MTEMP+2
.1a7bd4	38		sec		                SEC                     ; MPARSEDNUM = MPARSEDNUM - MTEMP (MCURSOR after the instruction)
.1a7bd5	a5 50		lda $0898	                LDA MPARSEDNUM
.1a7bd7	e5 4a		sbc $0892	                SBC MTEMP
.1a7bd9	85 50		sta $0898	                STA MPARSEDNUM
.1a7bdb	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a7bdd	e5 4c		sbc $0894	                SBC MTEMP+2
.1a7bdf	85 52		sta $089a	                STA MPARSEDNUM+2
.1a7be1	e2 20		sep #$20	            SEP #$20
.1a7be3	a5 4f		lda $0897	                LDA MADDR_MODE
.1a7be5	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.1a7be7	f0 1e		beq $1a7c07	                BEQ check_long
.1a7be9	a5 50		lda $0898	                LDA MPARSEDNUM          ; Short offset... check if it's negative
.1a7beb	30 0c		bmi $1a7bf9	                BMI check_short_neg
.1a7bed	a5 51		lda $0899	                LDA MPARSEDNUM+1        ; Positive short offset... upper two bytes
.1a7bef	d0 2a		bne $1a7c1b	                BNE failure             ; Must be 0 or it's an overflow
.1a7bf1	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a7bf3	d0 26		bne $1a7c1b	                BNE failure
.1a7bf5	a9 01		lda #$01	                LDA #1                  ; Short offset is 1 byte
.1a7bf7	80 26		bra $1a7c1f	                BRA success
.1a7bf9	a5 51		lda $0899	check_short_neg LDA MPARSEDNUM+1        ; Negative short offset... upper two bytes
.1a7bfb	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's an  overflow
.1a7bfd	d0 1c		bne $1a7c1b	                BNE failure
.1a7bff	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a7c01	c9 ff		cmp #$ff	                CMP #$FF
.1a7c03	d0 16		bne $1a7c1b	                BNE failure
.1a7c05	80 18		bra $1a7c1f	                BRA success
.1a7c07	a5 51		lda $0899	check_long      LDA MPARSEDNUM+1        ; Long offset... check if it's negative
.1a7c09	30 06		bmi $1a7c11	                BMI check_long_neg
.1a7c0b	a5 52		lda $089a	                LDA MPARSEDNUM+2        ; Positive long offset... upper byte
.1a7c0d	d0 0c		bne $1a7c1b	                BNE failure             ; Must be 0 or it's an overflow
.1a7c0f	80 0e		bra $1a7c1f	                BRA success
.1a7c11	a5 52		lda $089a	check_long_neg  LDA MPARSEDNUM+2        ; Negative offset... upper two bytes
.1a7c13	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's and overflow
.1a7c15	d0 04		bne $1a7c1b	                BNE failure
.1a7c17	a9 02		lda #$02	                LDA #2                  ; Long offset is 2 bytes
.1a7c19	80 04		bra $1a7c1f	                BRA success
.1a7c1b	2b		pld		failure         PLD
.1a7c1c	28		plp		                PLP
.1a7c1d	18		clc		                CLC
.1a7c1e	6b		rtl		                RTL
.1a7c1f	2b		pld		success         PLD
.1a7c20	28		plp		                PLP
.1a7c21	38		sec		                SEC
.1a7c22	6b		rtl		                RTL
.1a7c23					AS_SHIFT_HEX
.1a7c23	08		php		                PHP
.1a7c24	0b		phd		                PHD
.1a7c25	c2 10		rep #$10	            REP #$10
.1a7c27	da		phx		                PHX
.1a7c28	08		php		            PHP
.1a7c29	c2 20		rep #$20	            REP #$20
.1a7c2b	48		pha		            PHA
.1a7c2c	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7c2f	5b		tcd		            TCD
.1a7c30	68		pla		            PLA
.1a7c31	28		plp		            PLP
.1a7c32	e2 20		sep #$20	            SEP #$20
.1a7c34	a2 00 00	ldx #$0000	                LDX #0
.1a7c37	df 00 d0 1a	cmp $1ad000,x	seek_loop       CMP @lHEXDIGITS,X   ; Check the passed character against the hex digits
.1a7c3b	f0 08		beq $1a7c45	                BEQ found
.1a7c3d	e8		inx		                INX                 ; Go to the next hex digit
.1a7c3e	e0 10 00	cpx #$0010	                CPX #$10            ; Are we out of digits?
.1a7c41	f0 1b		beq $1a7c5e	                BEQ done            ; Yes... just return
.1a7c43	80 f2		bra $1a7c37	                BRA seek_loop
.1a7c45					found
.1a7c45	c2 20		rep #$20	            REP #$20
.1a7c47	06 50		asl $0898	                ASL MPARSEDNUM
.1a7c49	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7c4b	06 50		asl $0898	                ASL MPARSEDNUM
.1a7c4d	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7c4f	06 50		asl $0898	                ASL MPARSEDNUM
.1a7c51	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7c53	06 50		asl $0898	                ASL MPARSEDNUM
.1a7c55	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7c57	e2 20		sep #$20	            SEP #$20
.1a7c59	8a		txa		                TXA
.1a7c5a	05 50		ora $0898	                ORA MPARSEDNUM
.1a7c5c	85 50		sta $0898	                STA MPARSEDNUM
.1a7c5e	fa		plx		done            PLX
.1a7c5f	2b		pld		                PLD
.1a7c60	28		plp		                PLP
.1a7c61	6b		rtl		                RTL
.1a7c62					AS_FIND_OPCODE
.1a7c62	0b		phd		                PHD
.1a7c63	8b		phb		                PHB
.1a7c64	08		php		            PHP
.1a7c65	c2 20		rep #$20	            REP #$20
.1a7c67	48		pha		            PHA
.1a7c68	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7c6b	5b		tcd		            TCD
.1a7c6c	68		pla		            PLA
.1a7c6d	28		plp		            PLP
.1a7c6e	08		php		            PHP
.1a7c6f	e2 20		sep #$20	            SEP #$20
.1a7c71	48		pha		            PHA
.1a7c72	a9 1a		lda #$1a	            LDA #`MNEMONIC_TAB
.1a7c74	48		pha		            PHA
.1a7c75	ab		plb		            PLB
.1a7c76	68		pla		            PLA
.1a7c77	28		plp		            PLP
.1a7c78	e2 20		sep #$20	            SEP #$20
.1a7c7a	a5 4f		lda $0897	                LDA MADDR_MODE
.1a7c7c	29 3f		and #$3f	                AND #%00111111
.1a7c7e	85 4a		sta $0892	                STA MTEMP
.1a7c80	c2 30		rep #$30	            REP #$30
.1a7c82	a2 00 00	ldx #$0000	                LDX #0
.1a7c85	a0 00 00	ldy #$0000	                LDY #0
.1a7c88	bd 2f 83	lda $1a832f,x	mnemonic_loop   LDA MNEMONIC_TAB,X      ; Get the mnemonic from the opcode table
.1a7c8b	f0 1b		beq $1a7ca8	                BEQ not_found           ; If it's 0, we did not find the mnemonic
.1a7c8d	c5 54		cmp $089c	                CMP MMNEMONIC           ; Does it match the passed mnemonic?
.1a7c8f	d0 0d		bne $1a7c9e	                BNE next_opcode         ; No: go to the next opcode
.1a7c91					check_mode
.1a7c91	e2 20		sep #$20	            SEP #$20
.1a7c93	b9 31 85	lda $1a8531,y	                LDA ADDRESS_TAB,Y       ; Get the corresponding address mode
.1a7c96	29 3f		and #$3f	                AND #%00111111          ; Filter out effect bits
.1a7c98	c5 4a		cmp $0892	                CMP MTEMP
.1a7c9a	f0 07		beq $1a7ca3	                BEQ found               ; Yes: we found the opcode
.1a7c9c	c2 20		rep #$20	            REP #$20
.1a7c9e	e8		inx		next_opcode     INX                     ; Point to the next mnemonic in the table
.1a7c9f	e8		inx		                INX
.1a7ca0	c8		iny		                INY
.1a7ca1	80 e5		bra $1a7c88	                BRA mnemonic_loop       ; And check it
.1a7ca3	98		tya		found           TYA
.1a7ca4	38		sec		                SEC                     ; Set carry to show success
.1a7ca5	ab		plb		                PLB
.1a7ca6	2b		pld		                PLD
.1a7ca7	6b		rtl		                RTL
.1a7ca8	18		clc		not_found       CLC                     ; Clear carry to show failure
.1a7ca9	ab		plb		                PLB
.1a7caa	2b		pld		                PLD
.1a7cab	6b		rtl		                RTL
.1a7cac					AS_STR_MATCH
.1a7cac	08		php		                PHP
.1a7cad	0b		phd		                PHD
.1a7cae	08		php		            PHP
.1a7caf	c2 20		rep #$20	            REP #$20
.1a7cb1	48		pha		            PHA
.1a7cb2	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7cb5	5b		tcd		            TCD
.1a7cb6	68		pla		            PLA
.1a7cb7	28		plp		            PLP
.1a7cb8	e2 20		sep #$20	            SEP #$20
.1a7cba	c2 10		rep #$10	            REP #$10
.1a7cbc	a0 00 00	ldy #$0000	                LDY #0
.1a7cbf	64 50		stz $0898	                STZ MPARSEDNUM      ; Set parsed number to 0 in anticipation of
.1a7cc1	64 52		stz $089a	                STZ MPARSEDNUM+2    ; hex digits in the pattern
.1a7cc3	b7 03		lda [$084b],y	match_loop      LDA [MCMP_TEXT],Y   ; Get the pattern character
.1a7cc5	f0 11		beq $1a7cd8	                BEQ nul_check       ; If at end of pattern, check for end of test string
.1a7cc7	c9 64		cmp #$64	                CMP #'d'            ; Is it a digit?
.1a7cc9	f0 19		beq $1a7ce4	                BEQ check_digit     ; Yes: do special check for hex digit
.1a7ccb	48		pha		compare         PHA
.1a7ccc	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.1a7cce	85 4a		sta $0892	                STA MTEMP
.1a7cd0	68		pla		                PLA
.1a7cd1	c5 4a		cmp $0892	                CMP MTEMP           ; Does it match the character to test?
.1a7cd3	d0 0b		bne $1a7ce0	                BNE return_false    ; No: return fail
.1a7cd5	c8		iny		next_char       INY                 ; Yes: test the next character
.1a7cd6	80 eb		bra $1a7cc3	                BRA match_loop
.1a7cd8	b7 36		lda [$087e],y	nul_check       LDA [MLINEBUF],Y    ; Check to see that we're at the end of the test string
.1a7cda	d0 04		bne $1a7ce0	                BNE return_false    ; If not: return false
.1a7cdc	2b		pld		return_true     PLD
.1a7cdd	28		plp		                PLP                 ; Return true
.1a7cde	38		sec		                SEC
.1a7cdf	6b		rtl		                RTL
.1a7ce0	2b		pld		return_false    PLD
.1a7ce1	28		plp		                PLP                 ; Return false
.1a7ce2	18		clc		                CLC
.1a7ce3	6b		rtl		                RTL
.1a7ce4					check_digit
.1a7ce4	e2 20		sep #$20	            SEP #$20
.1a7ce6	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.1a7ce8	c9 3a		cmp #$3a	                CMP #'9'+1
.1a7cea	b0 04		bcs $1a7cf0	                BCS check_AF
.1a7cec	c9 30		cmp #$30	                CMP #'0'
.1a7cee	b0 14		bcs $1a7d04	                BCS shift_digit     ; character is in [0..9]
.1a7cf0	c9 47		cmp #$47	check_AF        CMP #'F'+1
.1a7cf2	b0 04		bcs $1a7cf8	                BCS check_lc        ; check lower case
.1a7cf4	c9 41		cmp #$41	                CMP #'A'
.1a7cf6	b0 0c		bcs $1a7d04	                BCS shift_digit     ; character is in [A..F]
.1a7cf8	c9 67		cmp #$67	check_lc        CMP #'f'+1
.1a7cfa	b0 e4		bcs $1a7ce0	                BCS return_false    ; check lower case
.1a7cfc	c9 61		cmp #$61	                CMP #'a'
.1a7cfe	b0 02		bcs $1a7d02	                BCS to_upcase       ; character is in [A..F]
.1a7d00	80 de		bra $1a7ce0	                BRA return_false    ; No match found... return false
.1a7d02	29 df		and #$df	to_upcase       AND #%11011111      ; Convert lower case to upper case
.1a7d04	22 23 7c 1a	jsl $1a7c23	shift_digit     JSL AS_SHIFT_HEX    ; Shift the digit into MPARSEDNUM
.1a7d08	80 cb		bra $1a7cd5	                BRA next_char       ; And check the next character
.1a7d0a					AS_MCMP_NEXT
.1a7d0a	0b		phd		                PHD
.1a7d0b	08		php		            PHP
.1a7d0c	c2 20		rep #$20	            REP #$20
.1a7d0e	48		pha		            PHA
.1a7d0f	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7d12	5b		tcd		            TCD
.1a7d13	68		pla		            PLA
.1a7d14	28		plp		            PLP
.1a7d15	a0 00 00	ldy #$0000	                LDY #0
.1a7d18	e2 20		sep #$20	            SEP #$20
.1a7d1a	b7 03		lda [$084b],y	loop            LDA [MCMP_TEXT],Y   ; Check to see if we have gotten to the NUL
.1a7d1c	f0 03		beq $1a7d21	                BEQ found_nul
.1a7d1e	c8		iny		                INY
.1a7d1f	80 f9		bra $1a7d1a	                BRA loop
.1a7d21					found_nul
.1a7d21	c2 20		rep #$20	            REP #$20
.1a7d23	c8		iny		                INY                 ; Got to NUL... point to next byte
.1a7d24	5a		phy		                PHY
.1a7d25	68		pla		                PLA                 ; And add that index to MCMP_TEXT pointer
.1a7d26	18		clc		                CLC
.1a7d27	65 03		adc $084b	                ADC MCMP_TEXT
.1a7d29	85 03		sta $084b	                STA MCMP_TEXT
.1a7d2b	a5 05		lda $084d	                LDA MCMP_TEXT+2
.1a7d2d	69 00 00	adc #$0000	                ADC #0
.1a7d30	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7d32	2b		pld		                PLD
.1a7d33	6b		rtl		                RTL
.1a7d34					AS_FIND_MNEMO
.1a7d34	0b		phd		                PHD
.1a7d35	08		php		            PHP
.1a7d36	c2 20		rep #$20	            REP #$20
.1a7d38	48		pha		            PHA
.1a7d39	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7d3c	5b		tcd		            TCD
.1a7d3d	68		pla		            PLA
.1a7d3e	28		plp		            PLP
.1a7d3f	c2 20		rep #$20	            REP #$20
.1a7d41	a5 11		lda $0859	                LDA MARG2                   ; Point MLINEBUF to the text
.1a7d43	85 36		sta $087e	                STA MLINEBUF
.1a7d45	a5 13		lda $085b	                LDA MARG2+2
.1a7d47	85 38		sta $0880	                STA MLINEBUF+2
.1a7d49	a9 bd 81	lda #$81bd	                LDA #<>MNEMONICS_TAB        ; Point to the first mnemonic
.1a7d4c	85 03		sta $084b	                STA MCMP_TEXT
.1a7d4e	a9 1a 00	lda #$001a	                LDA #`MNEMONICS_TAB
.1a7d51	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7d53	22 ac 7c 1a	jsl $1a7cac	match_loop      JSL AS_STR_MATCH            ; Check to see if the text matches the mnemonic
.1a7d57	b0 0d		bcs $1a7d66	                BCS found_mnemonic          ; If so: return that we found it
.1a7d59	22 0a 7d 1a	jsl $1a7d0a	                JSL AS_MCMP_NEXT            ; Point to the next mnemonic
.1a7d5d	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Check to see if it's NUL
.1a7d5f	d0 f2		bne $1a7d53	                BNE match_loop              ; If not, check this next mnemonic
.1a7d61	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Otherwise, return -1
.1a7d64	80 02		bra $1a7d68	                BRA done
.1a7d66	a5 03		lda $084b	found_mnemonic  LDA MCMP_TEXT               ; Found it: return the address
.1a7d68	2b		pld		done            PLD
.1a7d69	6b		rtl		                RTL
.1a7d6a					AS_FIND_MODE
.1a7d6a	08		php		                PHP
.1a7d6b	0b		phd		                PHD
.1a7d6c	08		php		            PHP
.1a7d6d	c2 20		rep #$20	            REP #$20
.1a7d6f	48		pha		            PHA
.1a7d70	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7d73	5b		tcd		            TCD
.1a7d74	68		pla		            PLA
.1a7d75	28		plp		            PLP
.1a7d76	c2 30		rep #$30	            REP #$30
.1a7d78	a5 15		lda $085d	                LDA MARG3                   ; Point MLINEBUF to the operand
.1a7d7a	85 36		sta $087e	                STA MLINEBUF
.1a7d7c	a5 17		lda $085f	                LDA MARG3+2
.1a7d7e	85 38		sta $0880	                STA MLINEBUF+2
.1a7d80	a9 49 86	lda #$8649	                LDA #<>ADDR_PATTERNS        ; Point to the first address mode pattern to check
.1a7d83	85 03		sta $084b	                STA MCMP_TEXT
.1a7d85	a9 1a 00	lda #$001a	                LDA #`ADDR_PATTERNS
.1a7d88	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7d8a	22 ac 7c 1a	jsl $1a7cac	match_loop      JSL AS_STR_MATCH            ; Check to see if the pattern matches the operand
.1a7d8e	b0 22		bcs $1a7db2	                BCS is_match                ; Yes: Find address mode code
.1a7d90	22 0a 7d 1a	jsl $1a7d0a	                JSL AS_MCMP_NEXT            ; Point to the address mode
.1a7d94	c2 20		rep #$20	            REP #$20
.1a7d96	18		clc		                CLC                         ; Point to the first byte of the next pattern
.1a7d97	a5 03		lda $084b	                LDA MCMP_TEXT
.1a7d99	69 01 00	adc #$0001	                ADC #1
.1a7d9c	85 03		sta $084b	                STA MCMP_TEXT
.1a7d9e	a5 05		lda $084d	                LDA MCMP_TEXT+2
.1a7da0	69 00 00	adc #$0000	                ADC #0
.1a7da3	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7da5	e2 20		sep #$20	            SEP #$20
.1a7da7	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Is the first byte 0?
.1a7da9	d0 df		bne $1a7d8a	                BNE match_loop              ; No: check this next pattern
.1a7dab	c2 20		rep #$20	            REP #$20
.1a7dad	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Yes: we didn't find a matching pattern, return -1
.1a7db0	80 0d		bra $1a7dbf	                BRA done
.1a7db2	22 0a 7d 1a	jsl $1a7d0a	is_match        JSL AS_MCMP_NEXT            ; Point to the address mode
.1a7db6	e2 20		sep #$20	            SEP #$20
.1a7db8	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Get the corresponding address mode code (a byte)
.1a7dba	c2 20		rep #$20	            REP #$20
.1a7dbc	29 ff 00	and #$00ff	                AND #$00FF
.1a7dbf	2b		pld		done            PLD
.1a7dc0	28		plp		                PLP
.1a7dc1	6b		rtl		                RTL
.1a7dc2					IMDISASSEMBLE
.1a7dc2	08		php		                PHP
.1a7dc3	8b		phb		                PHB
.1a7dc4	0b		phd		                PHD
.1a7dc5	08		php		            PHP
.1a7dc6	c2 20		rep #$20	            REP #$20
.1a7dc8	48		pha		            PHA
.1a7dc9	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7dcc	5b		tcd		            TCD
.1a7dcd	68		pla		            PLA
.1a7dce	28		plp		            PLP
.1a7dcf	e2 20		sep #$20	            SEP #$20
.1a7dd1	a9 00		lda #$00	                LDA #0
.1a7dd3	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT     ; Clear the pagination line counter
.1a7dd7	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.1a7dd9	c9 02		cmp #$02	                CMP #2
.1a7ddb	b0 16		bcs $1a7df3	                BGE set_cursor      ; 2>= arguments? Use them as-is
.1a7ddd	c9 01		cmp #$01	                CMP #1
.1a7ddf	90 20		bcc $1a7e01	                BLT no_args         ; No arguments passed? Use defaults
.1a7de1	c2 20		rep #$20	            REP #$20
.1a7de3	18		clc		                CLC
.1a7de4	a5 0d		lda $0855	                LDA MARG1
.1a7de6	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a7de9	85 11		sta $0859	                STA MARG2
.1a7deb	e2 20		sep #$20	            SEP #$20
.1a7ded	a5 0f		lda $0857	                LDA MARG1+2
.1a7def	69 00		adc #$00	                ADC #0
.1a7df1	85 13		sta $085b	                STA MARG2+2
.1a7df3					set_cursor
.1a7df3	c2 20		rep #$20	            REP #$20
.1a7df5	a5 0d		lda $0855	                LDA MARG1
.1a7df7	85 32		sta $087a	                STA MCURSOR
.1a7df9	e2 20		sep #$20	            SEP #$20
.1a7dfb	a5 0f		lda $0857	                LDA MARG1+2
.1a7dfd	85 34		sta $087c	                STA MCURSOR+2
.1a7dff	80 12		bra $1a7e13	                BRA dasm_loop
.1a7e01					no_args
.1a7e01	c2 20		rep #$20	            REP #$20
.1a7e03	18		clc		                CLC
.1a7e04	a5 32		lda $087a	                LDA MCURSOR
.1a7e06	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a7e09	85 11		sta $0859	                STA MARG2
.1a7e0b	e2 20		sep #$20	            SEP #$20
.1a7e0d	a5 34		lda $087c	                LDA MCURSOR+2
.1a7e0f	69 00		adc #$00	                ADC #0
.1a7e11	85 13		sta $085b	                STA MARG2+2
.1a7e13	22 2e 7e 1a	jsl $1a7e2e	dasm_loop       JSL DS_PR_LINE
.1a7e17	e2 20		sep #$20	            SEP #$20
.1a7e19	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.1a7e1b	c5 13		cmp $085b	                CMP MARG2+2
.1a7e1d	90 f4		bcc $1a7e13	                BLT dasm_loop           ; No: continue
.1a7e1f	c2 20		rep #$20	            REP #$20
.1a7e21	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.1a7e23	c5 11		cmp $0859	                CMP MARG2
.1a7e25	90 ec		bcc $1a7e13	                BLT dasm_loop           ; Nope... keep going
.1a7e27					done
.1a7e27	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a7e2a	2b		pld		                PLD
.1a7e2b	ab		plb		                PLB
.1a7e2c	28		plp		                PLP
.1a7e2d	6b		rtl		                RTL
.1a7e2e					DS_PR_LINE
.1a7e2e	08		php		                PHP
.1a7e2f	0b		phd		                PHD
.1a7e30	e2 20		sep #$20	            SEP #$20
.1a7e32	a9 41		lda #$41	                LDA #'A'
.1a7e34	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e37	a9 20		lda #$20	                LDA #' '
.1a7e39	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e3c	08		php		            PHP
.1a7e3d	c2 20		rep #$20	            REP #$20
.1a7e3f	48		pha		            PHA
.1a7e40	a9 7a 08	lda #$087a	            LDA #MCURSOR
.1a7e43	5b		tcd		            TCD
.1a7e44	68		pla		            PLA
.1a7e45	28		plp		            PLP
.1a7e46	c2 20		rep #$20	            REP #$20
.1a7e48	a5 00		lda $087a	                LDA MCURSOR
.1a7e4a	85 18		sta $0892	                STA MTEMP
.1a7e4c	e2 20		sep #$20	            SEP #$20
.1a7e4e	a5 02		lda $087c	                LDA MCURSOR+2
.1a7e50	85 1a		sta $0894	                STA MTEMP+2
.1a7e52	22 95 81 1a	jsl $1a8195	                JSL M_PR_ADDR
.1a7e56	a9 20		lda #$20	                LDA #' '
.1a7e58	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e5b	c2 20		rep #$20	            REP #$20
.1a7e5d	18		clc		                CLC
.1a7e5e	a5 00		lda $087a	                LDA MCURSOR
.1a7e60	69 01 00	adc #$0001	                ADC #1
.1a7e63	85 18		sta $0892	                STA MTEMP
.1a7e65	e2 20		sep #$20	            SEP #$20
.1a7e67	a5 02		lda $087c	                LDA MCURSOR+2
.1a7e69	69 00		adc #$00	                ADC #0
.1a7e6b	85 1a		sta $0894	                STA MTEMP+2
.1a7e6d	e2 20		sep #$20	            SEP #$20
.1a7e6f	c2 10		rep #$10	            REP #$10
.1a7e71	a7 00		lda [$087a]	                LDA [MCURSOR]           ; Get the mnemonic
.1a7e73	c9 c2		cmp #$c2	                CMP #$C2                ; Is it REP?
.1a7e75	d0 0b		bne $1a7e82	                BNE check_sep           ; No: check to see if it is SEP
.1a7e77	48		pha		handle_rep      PHA
.1a7e78	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.1a7e7a	49 ff		eor #$ff	                EOR #$FF                ; Invert the bits
.1a7e7c	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Mask off the bits in the CPUSTAT
.1a7e80	80 0b		bra $1a7e8d	                BRA save_stat
.1a7e82	c9 e2		cmp #$e2	check_sep       CMP #$E2                ; Is it SEP?
.1a7e84	d0 0c		bne $1a7e92	                BNE get_op_index        ; No: process the instruction regularly
.1a7e86	48		pha		handle_sep      PHA
.1a7e87	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.1a7e89	0f 96 08 00	ora $000896	                ORA @lMCPUSTAT          ; Activate the bits in the CPUSTAT
.1a7e8d	8f 96 08 00	sta $000896	save_stat       STA @lMCPUSTAT          ; And save it back
.1a7e91	68		pla		                PLA
.1a7e92					get_op_index
.1a7e92	c2 20		rep #$20	            REP #$20
.1a7e94	29 ff 00	and #$00ff	                AND #$00FF
.1a7e97	0a		asl a		                ASL A
.1a7e98	aa		tax		                TAX                     ; Get the index into the mnemonic lookup table
.1a7e99	bf 2f 83 1a	lda $1a832f,x	                LDA @lMNEMONIC_TAB,X    ; Get the mnemonic
.1a7e9d	aa		tax		                TAX
.1a7e9e	22 0f 81 1a	jsl $1a810f	                JSL DS_PR_MNEMONIC      ; And print it
.1a7ea2	e2 20		sep #$20	            SEP #$20
.1a7ea4	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a7ea6	aa		tax		                TAX
.1a7ea7	bf 31 85 1a	lda $1a8531,x	pr_operand      LDA @lADDRESS_TAB,X     ; Get the addressing mode for the instruction
.1a7eab	22 eb 86 1a	jsl $1a86eb	                JSL M_INC_CURSOR        ; Advance the cursor to the next byte
.1a7eaf	22 bc 7e 1a	jsl $1a7ebc	                JSL DS_PR_OPERAND       ; And print the correct operand
.1a7eb3	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a7eb6	20 b3 03	jsr $1a03b3	            JSR PAGINATE
.1a7eb9	2b		pld		                PLD
.1a7eba	28		plp		                PLP
.1a7ebb	6b		rtl		                RTL
.1a7ebc					DS_PR_OPERAND
.1a7ebc	08		php		                PHP
.1a7ebd	e2 20		sep #$20	            SEP #$20
.1a7ebf	48		pha		                PHA             ; Save the address mode so we can get to the M and X flags
.1a7ec0	29 3f		and #$3f	                AND #%00111111  ; Filter out the mode flags
.1a7ec2	0a		asl a		                ASL A           ; Compute the index to the table
.1a7ec3	c2 10		rep #$10	            REP #$10
.1a7ec5	aa		tax		                TAX
.1a7ec6	68		pla		                PLA             ; Restore A
.1a7ec7	7c ca 7e	jmp ($1a7eca,x)	                JMP (dispatch,X)
>1a7eca	fa 7e				dispatch        .word <>is_dp_ind_x
>1a7ecc	15 7f				                .word <>is_dp
>1a7ece	1c 7f				                .word <>is_imm
>1a7ed0	41 7f				                .word <>is_abs
>1a7ed2	48 7f				                .word <>is_dp_ind_y
>1a7ed4	63 7f				                .word <>is_dp_x
>1a7ed6	85 7f				                .word <>is_abs_y
>1a7ed8	96 7f				                .word <>is_abs_x
>1a7eda	d3 7f				                .word <>is_accumulator
>1a7edc	db 7f				                .word <>is_stack_r
>1a7ede	ec 7f				                .word <>is_dp_long
>1a7ee0	fd 7f				                .word <>is_abs_long
>1a7ee2	04 80				                .word <>is_stack_r_y
>1a7ee4	29 80				                .word <>is_dp_y_long
>1a7ee6	56 80				                .word <>is_abs_x_long
>1a7ee8	c2 7f				                .word <>is_dp_ind
>1a7eea	a7 7f				                .word <>is_abs_x_id
>1a7eec	74 7f				                .word <>is_dp_y
>1a7eee	49 80				                .word <>is_pc_rel
>1a7ef0	53 80				                .word <>is_implied
>1a7ef2	67 80				                .word <>is_xyc
>1a7ef4	96 80				                .word <>is_abs_ind
>1a7ef6	44 80				                .word <>is_pc_rel_long
>1a7ef8	a7 80				                .word <>is_abs_ind_long
.1a7efa	a9 28		lda #$28	is_dp_ind_x     LDA #'('                ; Print (dd,X)
.1a7efc	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7eff	22 be 80 1a	jsl $1a80be	                JSL DS_PR_OPERAND1      ; Print dd
.1a7f03	a9 2c		lda #$2c	                LDA #','
.1a7f05	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f08	a9 58		lda #$58	                LDA #'X'
.1a7f0a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f0d	a9 29		lda #$29	                LDA #')'
.1a7f0f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f12	4c b8 80	jmp $1a80b8	                JMP done_1
.1a7f15	22 be 80 1a	jsl $1a80be	is_dp           JSL DS_PR_OPERAND1      ; Print dd
.1a7f19	4c b8 80	jmp $1a80b8	                JMP done_1
.1a7f1c					is_imm
.1a7f1c	e2 20		sep #$20	            SEP #$20
.1a7f1e	48		pha		                PHA
.1a7f1f	a9 23		lda #$23	                LDA #'#'
.1a7f21	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f24	68		pla		                PLA
.1a7f25	29 c0		and #$c0	                AND #%11000000          ; Filter so we just look at the mode bits
.1a7f27	c9 00		cmp #$00	                CMP #$00                ; Are any set to check?
.1a7f29	f0 0f		beq $1a7f3a	                BEQ is_imm_short        ; No: treat it as a short always
.1a7f2b	4a		lsr a		                LSR A                   ; Move the flag bits right by 2 to match
.1a7f2c	4a		lsr a		                LSR A                   ; the positions of the bits in the CPU status register
.1a7f2d	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Otherwise, filter the mode bit we care about
.1a7f31	d0 07		bne $1a7f3a	                BNE is_imm_short        ; If it is set, immediate operation is short
.1a7f33	22 c8 80 1a	jsl $1a80c8	                JSL DS_PR_OPERAND2      ; Print dddd
.1a7f37	4c b8 80	jmp $1a80b8	                JMP done_1
.1a7f3a	22 be 80 1a	jsl $1a80be	is_imm_short    JSL DS_PR_OPERAND1      ; Print dd
.1a7f3e	4c b8 80	jmp $1a80b8	                JMP done_1
.1a7f41	22 c8 80 1a	jsl $1a80c8	is_abs          JSL DS_PR_OPERAND2      ; Print dddd
.1a7f45	4c b8 80	jmp $1a80b8	                JMP done_1
.1a7f48	a9 28		lda #$28	is_dp_ind_y     LDA #'('                ; Print (dd),Y
.1a7f4a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f4d	22 be 80 1a	jsl $1a80be	                JSL DS_PR_OPERAND1      ; Print dd
.1a7f51	a9 29		lda #$29	                LDA #')'
.1a7f53	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f56	a9 2c		lda #$2c	                LDA #','
.1a7f58	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f5b	a9 59		lda #$59	                LDA #'Y'
.1a7f5d	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f60	4c b8 80	jmp $1a80b8	                JMP done_1
.1a7f63	22 be 80 1a	jsl $1a80be	is_dp_x         JSL DS_PR_OPERAND1      ; Print dd,X
.1a7f67	a9 2c		lda #$2c	                LDA #','
.1a7f69	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f6c	a9 58		lda #$58	                LDA #'X'
.1a7f6e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f71	4c b8 80	jmp $1a80b8	                JMP done_1
.1a7f74	22 be 80 1a	jsl $1a80be	is_dp_y         JSL DS_PR_OPERAND1      ; Print dd,Y
.1a7f78	a9 2c		lda #$2c	                LDA #','
.1a7f7a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f7d	a9 59		lda #$59	                LDA #'Y'
.1a7f7f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f82	4c b8 80	jmp $1a80b8	                JMP done_1
.1a7f85	22 c8 80 1a	jsl $1a80c8	is_abs_y        JSL DS_PR_OPERAND2      ; Print dddd,Y
.1a7f89	a9 2c		lda #$2c	                LDA #','
.1a7f8b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f8e	a9 59		lda #$59	                LDA #'Y'
.1a7f90	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f93	4c b8 80	jmp $1a80b8	                JMP done_1
.1a7f96	22 c8 80 1a	jsl $1a80c8	is_abs_x        JSL DS_PR_OPERAND2      ; Print dddd,X
.1a7f9a	a9 2c		lda #$2c	                LDA #','
.1a7f9c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f9f	a9 58		lda #$58	                LDA #'X'
.1a7fa1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fa4	4c b8 80	jmp $1a80b8	                JMP done_1
.1a7fa7	a9 28		lda #$28	is_abs_x_id     LDA #'('
.1a7fa9	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fac	22 c8 80 1a	jsl $1a80c8	                JSL DS_PR_OPERAND2      ; Print (dddd,X)
.1a7fb0	a9 2c		lda #$2c	                LDA #','
.1a7fb2	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fb5	a9 58		lda #$58	                LDA #'X'
.1a7fb7	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fba	a9 29		lda #$29	                LDA #')'
.1a7fbc	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fbf	4c b8 80	jmp $1a80b8	                JMP done_1
.1a7fc2	a9 28		lda #$28	is_dp_ind       LDA #'('
.1a7fc4	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fc7	22 be 80 1a	jsl $1a80be	                JSL DS_PR_OPERAND1      ; Print (dd)
.1a7fcb	a9 29		lda #$29	                LDA #')'
.1a7fcd	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fd0	4c b8 80	jmp $1a80b8	                JMP done_1
.1a7fd3	a9 41		lda #$41	is_accumulator  LDA #'A'                ; Print A
.1a7fd5	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fd8	4c bc 80	jmp $1a80bc	                JMP done
.1a7fdb	22 be 80 1a	jsl $1a80be	is_stack_r      JSL DS_PR_OPERAND1      ; Print dd,S
.1a7fdf	a9 2c		lda #$2c	                LDA #','
.1a7fe1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fe4	a9 53		lda #$53	                LDA #'S'
.1a7fe6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7fe9	4c b8 80	jmp $1a80b8	                JMP done_1
.1a7fec	a9 5b		lda #$5b	is_dp_long      LDA #'['                ; [dd]
.1a7fee	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ff1	22 be 80 1a	jsl $1a80be	                JSL DS_PR_OPERAND1      ; Print dd
.1a7ff5	a9 5d		lda #$5d	                LDA #']'
.1a7ff7	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ffa	4c b8 80	jmp $1a80b8	                JMP done_1
.1a7ffd	22 d6 80 1a	jsl $1a80d6	is_abs_long     JSL DS_PR_OPERAND3      ; Print dddddd
.1a8001	4c bc 80	jmp $1a80bc	                JMP done
.1a8004	a9 28		lda #$28	is_stack_r_y    LDA #'('                ; (dd,S),Y
.1a8006	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8009	22 be 80 1a	jsl $1a80be	                JSL DS_PR_OPERAND1      ; Print dd
.1a800d	a9 2c		lda #$2c	                LDA #','
.1a800f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8012	a9 53		lda #$53	                LDA #'S'
.1a8014	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8017	a9 29		lda #$29	                LDA #')'
.1a8019	20 18 00	jsr $1a0018	            JSR PRINTC
.1a801c	a9 2c		lda #$2c	                LDA #','
.1a801e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8021	a9 59		lda #$59	                LDA #'Y'
.1a8023	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8026	4c b8 80	jmp $1a80b8	                JMP done_1
.1a8029	a9 5b		lda #$5b	is_dp_y_long    LDA #'['                ; [dd],Y
.1a802b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a802e	22 be 80 1a	jsl $1a80be	                JSL DS_PR_OPERAND1      ; Print dd
.1a8032	a9 5d		lda #$5d	                LDA #']'
.1a8034	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8037	a9 2c		lda #$2c	                LDA #','
.1a8039	20 18 00	jsr $1a0018	            JSR PRINTC
.1a803c	a9 59		lda #$59	                LDA #'Y'
.1a803e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8041	4c b8 80	jmp $1a80b8	                JMP done_1
.1a8044	a0 02 00	ldy #$0002	is_pc_rel_long  LDY #2
.1a8047	80 03		bra $1a804c	                BRA do_pcrel
.1a8049	a0 01 00	ldy #$0001	is_pc_rel       LDY #1
.1a804c	22 3c 81 1a	jsl $1a813c	do_pcrel        JSL DS_PR_PCREL
.1a8050	4c bc 80	jmp $1a80bc	                JMP done
.1a8053	4c bc 80	jmp $1a80bc	is_implied      JMP done
.1a8056	22 d6 80 1a	jsl $1a80d6	is_abs_x_long   JSL DS_PR_OPERAND3      ; Print dddddd
.1a805a	a9 2c		lda #$2c	                LDA #','
.1a805c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a805f	a9 58		lda #$58	                LDA #'X'
.1a8061	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8064	4c bc 80	jmp $1a80bc	                JMP done
.1a8067	a9 23		lda #$23	is_xyc          LDA #'#'
.1a8069	20 18 00	jsr $1a0018	            JSR PRINTC
.1a806c	8b		phb		                PHB                     ; Make sure the databank is pointed to our number
.1a806d	a5 02		lda $087c	                LDA MCURSOR+2
.1a806f	48		pha		                PHA
.1a8070	ab		plb		                PLB
.1a8071	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.1a8073	e8		inx		                INX
.1a8074	a0 01 00	ldy #$0001	                LDY #1
.1a8077	22 ac 03 1a	jsl $1a03ac	                JSL PRINTH
.1a807b	a9 2c		lda #$2c	                LDA #','
.1a807d	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8080	a9 23		lda #$23	                LDA #'#'
.1a8082	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8085	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.1a8087	a0 01 00	ldy #$0001	                LDY #1
.1a808a	22 ac 03 1a	jsl $1a03ac	                JSL PRINTH
.1a808e	ab		plb		                PLB                     ; Get our old data bank back
.1a808f	22 eb 86 1a	jsl $1a86eb	                JSL M_INC_CURSOR
.1a8093	4c b8 80	jmp $1a80b8	                JMP done_1
.1a8096	a9 28		lda #$28	is_abs_ind      LDA #'('
.1a8098	20 18 00	jsr $1a0018	            JSR PRINTC
.1a809b	22 c8 80 1a	jsl $1a80c8	                JSL DS_PR_OPERAND2      ; Print (dddd)
.1a809f	a9 29		lda #$29	                LDA #')'
.1a80a1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a80a4	4c b8 80	jmp $1a80b8	                JMP done_1
.1a80a7	a9 5b		lda #$5b	is_abs_ind_long LDA #'['
.1a80a9	20 18 00	jsr $1a0018	            JSR PRINTC
.1a80ac	22 c8 80 1a	jsl $1a80c8	                JSL DS_PR_OPERAND2      ; Print [dddd]
.1a80b0	a9 5d		lda #$5d	                LDA #']'
.1a80b2	20 18 00	jsr $1a0018	            JSR PRINTC
.1a80b5	4c b8 80	jmp $1a80b8	                JMP done_1
.1a80b8	22 eb 86 1a	jsl $1a86eb	done_1          JSL M_INC_CURSOR    ; Skip over a single byte operand
.1a80bc	28		plp		done            PLP
.1a80bd	6b		rtl		                RTL
.1a80be					DS_PR_OPERAND1
.1a80be	08		php		                PHP
.1a80bf	e2 20		sep #$20	            SEP #$20
.1a80c1	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a80c3	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a80c6	28		plp		                PLP
.1a80c7	6b		rtl		                RTL
.1a80c8					DS_PR_OPERAND2
.1a80c8	08		php		                PHP
.1a80c9	c2 30		rep #$30	            REP #$30
.1a80cb	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a80cd	20 39 04	jsr $1a0439	            JSR PRHEXW
.1a80d0	22 eb 86 1a	jsl $1a86eb	                JSL M_INC_CURSOR
.1a80d4	28		plp		                PLP
.1a80d5	6b		rtl		                RTL
.1a80d6					DS_PR_OPERAND3
.1a80d6	08		php		                PHP
.1a80d7	8b		phb		                PHB
.1a80d8	0b		phd		                PHD
.1a80d9	c2 30		rep #$30	            REP #$30
.1a80db	5a		phy		                PHY
.1a80dc	08		php		            PHP
.1a80dd	c2 20		rep #$20	            REP #$20
.1a80df	48		pha		            PHA
.1a80e0	a9 7a 08	lda #$087a	            LDA #MCURSOR
.1a80e3	5b		tcd		            TCD
.1a80e4	68		pla		            PLA
.1a80e5	28		plp		            PLP
.1a80e6	08		php		            PHP
.1a80e7	e2 20		sep #$20	            SEP #$20
.1a80e9	48		pha		            PHA
.1a80ea	a9 00		lda #$00	            LDA #`MTEMP
.1a80ec	48		pha		            PHA
.1a80ed	ab		plb		            PLB
.1a80ee	68		pla		            PLA
.1a80ef	28		plp		            PLP
.1a80f0	e2 20		sep #$20	            SEP #$20
.1a80f2	a0 00 00	ldy #$0000	                LDY #0
.1a80f5	a7 00		lda [$087a]	copy_loop       LDA [MCURSOR]       ; Copy the address pointed to by MCURSOR
.1a80f7	99 92 08	sta $0892,y	                STA MTEMP,Y         ; to MTEMP
.1a80fa	22 eb 86 1a	jsl $1a86eb	                JSL M_INC_CURSOR
.1a80fe	c8		iny		                INY
.1a80ff	c0 03 00	cpy #$0003	                CPY #3
.1a8102	d0 f1		bne $1a80f5	                BNE copy_loop
.1a8104	22 95 81 1a	jsl $1a8195	                JSL M_PR_ADDR       ; Print the address
.1a8108	c2 30		rep #$30	            REP #$30
.1a810a	7a		ply		                PLY
.1a810b	2b		pld		                PLD
.1a810c	ab		plb		                PLB
.1a810d	28		plp		                PLP
.1a810e	6b		rtl		                RTL
.1a810f					DS_PR_MNEMONIC
.1a810f	08		php		                PHP
.1a8110	8b		phb		                PHB
.1a8111	e2 20		sep #$20	            SEP #$20
.1a8113	c2 10		rep #$10	            REP #$10
.1a8115	08		php		            PHP
.1a8116	e2 20		sep #$20	            SEP #$20
.1a8118	48		pha		            PHA
.1a8119	a9 1a		lda #$1a	            LDA #`MN_ORA
.1a811b	48		pha		            PHA
.1a811c	ab		plb		            PLB
.1a811d	68		pla		            PLA
.1a811e	28		plp		            PLP
.1a811f	bd 00 00	lda $1a0000,x	                LDA #0,B,X
.1a8122	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8125	e8		inx		                INX
.1a8126	bd 00 00	lda $1a0000,x	                LDA #0,B,X
.1a8129	20 18 00	jsr $1a0018	            JSR PRINTC
.1a812c	e8		inx		                INX
.1a812d	bd 00 00	lda $1a0000,x	                LDA #0,B,X
.1a8130	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8133	e8		inx		                INX
.1a8134	a9 20		lda #$20	                LDA #' '            ; Print a space
.1a8136	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8139	ab		plb		                PLB
.1a813a	28		plp		                PLP
.1a813b	6b		rtl		                RTL
.1a813c					DS_PR_PCREL
.1a813c	08		php		                PHP
.1a813d	0b		phd		                PHD
.1a813e	08		php		            PHP
.1a813f	c2 20		rep #$20	            REP #$20
.1a8141	48		pha		            PHA
.1a8142	a9 7a 08	lda #$087a	            LDA #MCURSOR
.1a8145	5b		tcd		            TCD
.1a8146	68		pla		            PLA
.1a8147	28		plp		            PLP
.1a8148	e2 20		sep #$20	            SEP #$20
.1a814a	c0 02 00	cpy #$0002	                CPY #2
.1a814d	f0 14		beq $1a8163	                BEQ offset_2
.1a814f	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a8151	85 18		sta $0892	                STA MTEMP
.1a8153	30 06		bmi $1a815b	                BMI is_negative
.1a8155	64 19		stz $0893	                STZ MTEMP+1
.1a8157	64 1a		stz $0894	                STZ MTEMP+2
.1a8159	80 1e		bra $1a8179	                BRA add_offset
.1a815b	a9 ff		lda #$ff	is_negative     LDA #$FF
.1a815d	85 19		sta $0893	                STA MTEMP+1
.1a815f	85 1a		sta $0894	                STA MTEMP+2
.1a8161	80 16		bra $1a8179	                BRA add_offset
.1a8163	a7 00		lda [$087a]	offset_2        LDA [MCURSOR]
.1a8165	85 18		sta $0892	                STA MTEMP
.1a8167	22 eb 86 1a	jsl $1a86eb	                JSL M_INC_CURSOR
.1a816b	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a816d	85 19		sta $0893	                STA MTEMP+1
.1a816f	30 04		bmi $1a8175	                BMI is_negative2
.1a8171	64 1a		stz $0894	                STZ MTEMP+2
.1a8173	80 04		bra $1a8179	                BRA add_offset
.1a8175	a9 ff		lda #$ff	is_negative2    LDA #$FF
.1a8177	85 1a		sta $0894	                STA MTEMP+2
.1a8179					add_offset
.1a8179	c2 20		rep #$20	            REP #$20
.1a817b	38		sec		                SEC             ; Add 1 to the offset
.1a817c	a5 00		lda $087a	                LDA MCURSOR
.1a817e	65 18		adc $0892	                ADC MTEMP
.1a8180	85 18		sta $0892	                STA MTEMP
.1a8182	e2 20		sep #$20	            SEP #$20
.1a8184	a5 02		lda $087c	                LDA MCURSOR+2
.1a8186	65 1a		adc $0894	                ADC MTEMP+2
.1a8188	85 1a		sta $0894	                STA MTEMP+2
.1a818a	22 95 81 1a	jsl $1a8195	                JSL M_PR_ADDR
.1a818e	22 eb 86 1a	jsl $1a86eb	                JSL M_INC_CURSOR
.1a8192	2b		pld		                PLD
.1a8193	28		plp		                PLP
.1a8194	6b		rtl		                RTL
.1a8195					M_PR_ADDR
.1a8195	08		php		                PHP
.1a8196	0b		phd		                PHD
.1a8197	c2 20		rep #$20	            REP #$20
.1a8199	48		pha		                PHA
.1a819a	08		php		            PHP
.1a819b	c2 20		rep #$20	            REP #$20
.1a819d	48		pha		            PHA
.1a819e	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a81a1	5b		tcd		            TCD
.1a81a2	68		pla		            PLA
.1a81a3	28		plp		            PLP
.1a81a4	e2 20		sep #$20	            SEP #$20
.1a81a6	a5 4c		lda $0894	                LDA MTEMP+2     ; Print the bank byte of the address
.1a81a8	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a81ab	e2 20		sep #$20	            SEP #$20
.1a81ad	a9 3a		lda #$3a	                LDA #':'
.1a81af	20 18 00	jsr $1a0018	            JSR PRINTC
.1a81b2	c2 20		rep #$20	            REP #$20
.1a81b4	a5 4a		lda $0892	                LDA MTEMP       ; Print the lower 16-bits of the address
.1a81b6	20 39 04	jsr $1a0439	            JSR PRHEXW
.1a81b9	68		pla		                PLA
.1a81ba	2b		pld		                PLD
.1a81bb	28		plp		                PLP
.1a81bc	6b		rtl		                RTL
.1a81bd					MNEMONICS_TAB
.1a81bd					MN_ORA
>1a81bd	4f 52 41 00			            .null "ORA"
.1a81c1					MN_AND
>1a81c1	41 4e 44 00			            .null "AND"
.1a81c5					MN_EOR
>1a81c5	45 4f 52 00			            .null "EOR"
.1a81c9					MN_ADC
>1a81c9	41 44 43 00			            .null "ADC"
.1a81cd					MN_STA
>1a81cd	53 54 41 00			            .null "STA"
.1a81d1					MN_LDA
>1a81d1	4c 44 41 00			            .null "LDA"
.1a81d5					MN_CMP
>1a81d5	43 4d 50 00			            .null "CMP"
.1a81d9					MN_SBC
>1a81d9	53 42 43 00			            .null "SBC"
.1a81dd					MN_ASL
>1a81dd	41 53 4c 00			            .null "ASL"
.1a81e1					MN_ROL
>1a81e1	52 4f 4c 00			            .null "ROL"
.1a81e5					MN_LSR
>1a81e5	4c 53 52 00			            .null "LSR"
.1a81e9					MN_ROR
>1a81e9	52 4f 52 00			            .null "ROR"
.1a81ed					MN_STX
>1a81ed	53 54 58 00			            .null "STX"
.1a81f1					MN_LDX
>1a81f1	4c 44 58 00			            .null "LDX"
.1a81f5					MN_DEC
>1a81f5	44 45 43 00			            .null "DEC"
.1a81f9					MN_INC
>1a81f9	49 4e 43 00			            .null "INC"
.1a81fd					MN_BIT
>1a81fd	42 49 54 00			            .null "BIT"
.1a8201					MN_JMP
>1a8201	4a 4d 50 00			            .null "JMP"
.1a8205					MN_STY
>1a8205	53 54 59 00			            .null "STY"
.1a8209					MN_LDY
>1a8209	4c 44 59 00			            .null "LDY"
.1a820d					MN_CPY
>1a820d	43 50 59 00			            .null "CPY"
.1a8211					MN_CPX
>1a8211	43 50 58 00			            .null "CPX"
.1a8215					MN_BRK
>1a8215	42 52 4b 00			            .null "BRK"
.1a8219					MN_JSR
>1a8219	4a 53 52 00			            .null "JSR"
.1a821d					MN_RTI
>1a821d	52 54 49 00			            .null "RTI"
.1a8221					MN_RTS
>1a8221	52 54 53 00			            .null "RTS"
.1a8225					MN_PHP
>1a8225	50 48 50 00			            .null "PHP"
.1a8229					MN_PLP
>1a8229	50 4c 50 00			            .null "PLP"
.1a822d					MN_PHA
>1a822d	50 48 41 00			            .null "PHA"
.1a8231					MN_PLA
>1a8231	50 4c 41 00			            .null "PLA"
.1a8235					MN_DEY
>1a8235	44 45 59 00			            .null "DEY"
.1a8239					MN_TAY
>1a8239	54 41 59 00			            .null "TAY"
.1a823d					MN_INY
>1a823d	49 4e 59 00			            .null "INY"
.1a8241					MN_INX
>1a8241	49 4e 58 00			            .null "INX"
.1a8245					MN_CLC
>1a8245	43 4c 43 00			            .null "CLC"
.1a8249					MN_SEC
>1a8249	53 45 43 00			            .null "SEC"
.1a824d					MN_CLI
>1a824d	43 4c 49 00			            .null "CLI"
.1a8251					MN_SEI
>1a8251	53 45 49 00			            .null "SEI"
.1a8255					MN_TYA
>1a8255	54 59 41 00			            .null "TYA"
.1a8259					MN_CLV
>1a8259	43 4c 56 00			            .null "CLV"
.1a825d					MN_CLD
>1a825d	43 4c 44 00			            .null "CLD"
.1a8261					MN_SED
>1a8261	53 45 44 00			            .null "SED"
.1a8265					MN_TXA
>1a8265	54 58 41 00			            .null "TXA"
.1a8269					MN_TXS
>1a8269	54 58 53 00			            .null "TXS"
.1a826d					MN_TAX
>1a826d	54 41 58 00			            .null "TAX"
.1a8271					MN_TSX
>1a8271	54 53 58 00			            .null "TSX"
.1a8275					MN_DEX
>1a8275	44 45 58 00			            .null "DEX"
.1a8279					MN_NOP
>1a8279	4e 4f 50 00			            .null "NOP"
.1a827d					MN_BPL
>1a827d	42 50 4c 00			            .null "BPL"
.1a8281					MN_BMI
>1a8281	42 4d 49 00			            .null "BMI"
.1a8285					MN_BVC
>1a8285	42 56 43 00			            .null "BVC"
.1a8289					MN_BVS
>1a8289	42 56 53 00			            .null "BVS"
.1a828d					MN_BCC
>1a828d	42 43 43 00			            .null "BCC"
.1a8291					MN_BCS
>1a8291	42 43 53 00			            .null "BCS"
.1a8295					MN_BNE
>1a8295	42 4e 45 00			            .null "BNE"
.1a8299					MN_BEQ
>1a8299	42 45 51 00			            .null "BEQ"
.1a829d					MN_TSB
>1a829d	54 53 42 00			            .null "TSB"
.1a82a1					MN_TRB
>1a82a1	54 52 42 00			            .null "TRB"
.1a82a5					MN_STZ
>1a82a5	53 54 5a 00			            .null "STZ"
.1a82a9					MN_BRA
>1a82a9	42 52 41 00			            .null "BRA"
.1a82ad					MN_PHY
>1a82ad	50 48 59 00			            .null "PHY"
.1a82b1					MN_PLY
>1a82b1	50 4c 59 00			            .null "PLY"
.1a82b5					MN_PHX
>1a82b5	50 48 58 00			            .null "PHX"
.1a82b9					MN_PLX
>1a82b9	50 4c 58 00			            .null "PLX"
.1a82bd					MN_PHD
>1a82bd	50 48 44 00			            .null "PHD"
.1a82c1					MN_PLD
>1a82c1	50 4c 44 00			            .null "PLD"
.1a82c5					MN_PHK
>1a82c5	50 48 4b 00			            .null "PHK"
.1a82c9					MN_RTL
>1a82c9	52 54 4c 00			            .null "RTL"
.1a82cd					MN_PHB
>1a82cd	50 48 42 00			            .null "PHB"
.1a82d1					MN_PLB
>1a82d1	50 4c 42 00			            .null "PLB"
.1a82d5					MN_WAI
>1a82d5	57 41 49 00			            .null "WAI"
.1a82d9					MN_XBA
>1a82d9	58 42 41 00			            .null "XBA"
.1a82dd					MN_TCS
>1a82dd	54 43 53 00			            .null "TCS"
.1a82e1					MN_TSC
>1a82e1	54 53 43 00			            .null "TSC"
.1a82e5					MN_TCD
>1a82e5	54 43 44 00			            .null "TCD"
.1a82e9					MN_TDC
>1a82e9	54 44 43 00			            .null "TDC"
.1a82ed					MN_TXY
>1a82ed	54 58 59 00			            .null "TXY"
.1a82f1					MN_TYX
>1a82f1	54 59 58 00			            .null "TYX"
.1a82f5					MN_STP
>1a82f5	53 54 50 00			            .null "STP"
.1a82f9					MN_XCE
>1a82f9	58 43 45 00			            .null "XCE"
.1a82fd					MN_COP
>1a82fd	43 4f 50 00			            .null "COP"
.1a8301					MN_JSL
>1a8301	4a 53 4c 00			            .null "JSL"
.1a8305					MN_WDM
>1a8305	57 44 4d 00			            .null "WDM"
.1a8309					MN_PER
>1a8309	50 45 52 00			            .null "PER"
.1a830d					MN_BRL
>1a830d	42 52 4c 00			            .null "BRL"
.1a8311					MN_REP
>1a8311	52 45 50 00			            .null "REP"
.1a8315					MN_SEP
>1a8315	53 45 50 00			            .null "SEP"
.1a8319					MN_MVP
>1a8319	4d 56 50 00			            .null "MVP"
.1a831d					MN_MVN
>1a831d	4d 56 4e 00			            .null "MVN"
.1a8321					MN_PEI
>1a8321	50 45 49 00			            .null "PEI"
.1a8325					MN_PEA
>1a8325	50 45 41 00			            .null "PEA"
.1a8329					MN_JML
>1a8329	4a 4d 4c 00			            .null "JML"
>1a832d	00 00				            .byte 0, 0
>1a832f	15 82 bd 81 fd 82 bd 81		MNEMONIC_TAB    .word <>MN_BRK, <>MN_ORA, <>MN_COP, <>MN_ORA, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 0x
>1a8337	9d 82 bd 81 dd 81 bd 81
>1a833f	25 82 bd 81 dd 81 bd 82		                .word <>MN_PHP, <>MN_ORA, <>MN_ASL, <>MN_PHD, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>1a8347	9d 82 bd 81 dd 81 bd 81
>1a834f	7d 82 bd 81 bd 81 bd 81		                .word <>MN_BPL, <>MN_ORA, <>MN_ORA, <>MN_ORA, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 1x
>1a8357	a1 82 bd 81 dd 81 bd 81
>1a835f	45 82 bd 81 f9 81 dd 82		                .word <>MN_CLC, <>MN_ORA, <>MN_INC, <>MN_TCS, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>1a8367	a1 82 bd 81 dd 81 bd 81
>1a836f	19 82 c1 81 01 83 c1 81		                .word <>MN_JSR, <>MN_AND, <>MN_JSL, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 2x
>1a8377	fd 81 c1 81 e1 81 c1 81
>1a837f	29 82 c1 81 e1 81 c1 82		                .word <>MN_PLP, <>MN_AND, <>MN_ROL, <>MN_PLD, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>1a8387	fd 81 c1 81 e1 81 c1 81
>1a838f	81 82 c1 81 c1 81 c1 81		                .word <>MN_BMI, <>MN_AND, <>MN_AND, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 3x
>1a8397	fd 81 c1 81 e1 81 c1 81
>1a839f	49 82 c1 81 f5 81 e1 82		                .word <>MN_SEC, <>MN_AND, <>MN_DEC, <>MN_TSC, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>1a83a7	fd 81 c1 81 e1 81 c1 81
>1a83af	1d 82 c5 81 05 83 c5 81		                .word <>MN_RTI, <>MN_EOR, <>MN_WDM, <>MN_EOR, <>MN_MVP, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 4x
>1a83b7	19 83 c5 81 e5 81 c5 81
>1a83bf	2d 82 c5 81 e5 81 c5 82		                .word <>MN_PHA, <>MN_EOR, <>MN_LSR, <>MN_PHK, <>MN_JMP, <>MN_EOR, <>MN_LSR, <>MN_EOR
>1a83c7	01 82 c5 81 e5 81 c5 81
>1a83cf	85 82 c5 81 c5 81 c5 81		                .word <>MN_BVC, <>MN_EOR, <>MN_EOR, <>MN_EOR, <>MN_MVN, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 5x
>1a83d7	1d 83 c5 81 e5 81 c5 81
>1a83df	4d 82 c5 81 ad 82 e5 82		                .word <>MN_CLI, <>MN_EOR, <>MN_PHY, <>MN_TCD, <>MN_JML, <>MN_EOR, <>MN_LSR, <>MN_EOR
>1a83e7	29 83 c5 81 e5 81 c5 81
>1a83ef	21 82 c9 81 09 83 c9 81		                .word <>MN_RTS, <>MN_ADC, <>MN_PER, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 6x
>1a83f7	a5 82 c9 81 e9 81 c9 81
>1a83ff	31 82 c9 81 e9 81 c9 82		                .word <>MN_PLA, <>MN_ADC, <>MN_ROR, <>MN_RTL, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>1a8407	01 82 c9 81 e9 81 c9 81
>1a840f	89 82 c9 81 c9 81 c9 81		                .word <>MN_BVS, <>MN_ADC, <>MN_ADC, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 7x
>1a8417	a5 82 c9 81 e9 81 c9 81
>1a841f	51 82 c9 81 b1 82 e9 82		                .word <>MN_SEI, <>MN_ADC, <>MN_PLY, <>MN_TDC, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>1a8427	01 82 c9 81 e9 81 c9 81
>1a842f	a9 82 cd 81 0d 83 cd 81		                .word <>MN_BRA, <>MN_STA, <>MN_BRL, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 8x
>1a8437	05 82 cd 81 ed 81 cd 81
>1a843f	35 82 fd 81 65 82 cd 82		                .word <>MN_DEY, <>MN_BIT, <>MN_TXA, <>MN_PHB, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA
>1a8447	05 82 cd 81 ed 81 cd 81
>1a844f	8d 82 cd 81 cd 81 cd 81		                .word <>MN_BCC, <>MN_STA, <>MN_STA, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 9x
>1a8457	05 82 cd 81 ed 81 cd 81
>1a845f	55 82 cd 81 69 82 ed 82		                .word <>MN_TYA, <>MN_STA, <>MN_TXS, <>MN_TXY, <>MN_STZ, <>MN_STA, <>MN_STZ, <>MN_STA
>1a8467	a5 82 cd 81 a5 82 cd 81
>1a846f	09 82 d1 81 f1 81 d1 81		                .word <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Ax
>1a8477	09 82 d1 81 f1 81 d1 81
>1a847f	39 82 d1 81 6d 82 d1 82		                .word <>MN_TAY, <>MN_LDA, <>MN_TAX, <>MN_PLB, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>1a8487	09 82 d1 81 f1 81 d1 81
>1a848f	91 82 d1 81 d1 81 d1 81		                .word <>MN_BCS, <>MN_LDA, <>MN_LDA, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Bx
>1a8497	09 82 d1 81 f1 81 d1 81
>1a849f	59 82 d1 81 71 82 f1 82		                .word <>MN_CLV, <>MN_LDA, <>MN_TSX, <>MN_TYX, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>1a84a7	09 82 d1 81 f1 81 d1 81
>1a84af	0d 82 d5 81 11 83 d5 81		                .word <>MN_CPY, <>MN_CMP, <>MN_REP, <>MN_CMP, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Cx
>1a84b7	0d 82 d5 81 f5 81 d5 81
>1a84bf	3d 82 d5 81 75 82 d5 82		                .word <>MN_INY, <>MN_CMP, <>MN_DEX, <>MN_WAI, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP
>1a84c7	0d 82 d5 81 f5 81 d5 81
>1a84cf	95 82 d5 81 d5 81 d5 81		                .word <>MN_BNE, <>MN_CMP, <>MN_CMP, <>MN_CMP, <>MN_PEI, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Dx
>1a84d7	21 83 d5 81 f5 81 d5 81
>1a84df	5d 82 d5 81 b5 82 f5 82		                .word <>MN_CLD, <>MN_CMP, <>MN_PHX, <>MN_STP, <>MN_JML, <>MN_CMP, <>MN_DEC, <>MN_CMP
>1a84e7	29 83 d5 81 f5 81 d5 81
>1a84ef	11 82 d9 81 15 83 d9 81		                .word <>MN_CPX, <>MN_SBC, <>MN_SEP, <>MN_SBC, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Ex
>1a84f7	11 82 d9 81 f9 81 d9 81
>1a84ff	41 82 d9 81 79 82 d9 82		                .word <>MN_INX, <>MN_SBC, <>MN_NOP, <>MN_XBA, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC
>1a8507	11 82 d9 81 f9 81 d9 81
>1a850f	99 82 d9 81 d9 81 d9 81		                .word <>MN_BEQ, <>MN_SBC, <>MN_SBC, <>MN_SBC, <>MN_PEA, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Fx
>1a8517	25 83 d9 81 f9 81 d9 81
>1a851f	61 82 d9 81 b9 82 f9 82		                .word <>MN_SED, <>MN_SBC, <>MN_PLX, <>MN_XCE, <>MN_JSR, <>MN_SBC, <>MN_INC, <>MN_SBC
>1a8527	19 82 d9 81 f9 81 d9 81
>1a852f	00 00				                .word 0
>1a8531	13 00 02 09			ADDRESS_TAB     .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R                  ; 0x
>1a8535	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8539	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a853d	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8541	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 1x
>1a8545	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8549	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>1a854d	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a8551	03 00 0b 09			                .byte ADDR_ABS, ADDR_DP_IND_X, ADDR_ABS_LONG, ADDR_SP_R                 ; 2x
>1a8555	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8559	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a855d	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8561	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 3x
>1a8565	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8569	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>1a856d	07 07 07 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a8571	13 00 13 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMPLIED, ADDR_SP_R              ; 4x
>1a8575	14 01 01 0a			                .byte ADDR_XYC, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8579	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a857d	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8581	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 5x
>1a8585	14 05 05 0d			                .byte ADDR_XYC, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8589	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a858d	0b 07 07 0b			                .byte ADDR_ABS_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_LONG
>1a8591	13 00 16 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R          ; 6x
>1a8595	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8599	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a859d	15 03 03 0b			                .byte ADDR_ABS_IND, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a85a1	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 7x
>1a85a5	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a85a9	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a85ad	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a85b1	12 00 16 09			                .byte ADDR_PC_REL, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R           ; 8x
>1a85b5	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a85b9	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a85bd	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a85c1	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 9x
>1a85c5	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>1a85c9	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a85cd	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a85d1	82 00 42 09			                .byte ADDR_IMM | OP_M_EFFECT, ADDR_DP_IND_X, ADDR_IMM | OP_X_EFFECT, ADDR_SP_R  ; Ax
>1a85d5	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a85d9	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a85dd	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a85e1	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Bx
>1a85e5	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>1a85e9	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a85ed	07 07 06 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_Y, ADDR_ABS_X_LONG
>1a85f1	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Cx
>1a85f5	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a85f9	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a85fd	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8601	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Dx
>1a8605	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8609	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a860d	17 07 07 0e			                .byte ADDR_ABS_IND_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a8611	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Ex
>1a8615	01 01 01 0f			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_IND
>1a8619	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a861d	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8621	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Fx
>1a8625	03 05 05 0d			                .byte ADDR_ABS, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8629	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a862d	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a8631	01 01 01 02 01 01 02 02		ADDR_LENGTH     .byte 1, 1, 1, 2, 1, 1, 2, 2, 0, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 0, 2, 2, 2, 2
>1a8639	00 01 01 03 01 01 03 01 02 01 01 00 02 02 02 02
.1a8649					ADDR_PATTERNS
>1a8649	41 00				            .null "A"
>1a864b	08				            .byte ADDR_ACC
>1a864c	64 64 3a 64 64 64 64 2c		            .null "dd:dddd,X"
>1a8654	58 00
>1a8656	0e				            .byte ADDR_ABS_X_LONG
>1a8657	64 64 3a 64 64 64 64 00		            .null "dd:dddd"
>1a865f	0b				            .byte ADDR_ABS_LONG
>1a8660	64 64 64 64 2c 58 00		            .null "dddd,X"
>1a8667	07				            .byte ADDR_ABS_X
>1a8668	64 64 64 64 2c 59 00		            .null "dddd,Y"
>1a866f	06				            .byte ADDR_ABS_Y
>1a8670	64 64 64 64 00			            .null "dddd"
>1a8675	03				            .byte ADDR_ABS
>1a8676	64 64 2c 58 00			            .null "dd,X"
>1a867b	05				            .byte ADDR_DP_X
>1a867c	64 64 2c 59 00			            .null "dd,Y"
>1a8681	11				            .byte ADDR_DP_Y
>1a8682	64 64 2c 53 00			            .null "dd,S"
>1a8687	09				            .byte ADDR_SP_R
>1a8688	64 64 00			            .null "dd"
>1a868b	01				            .byte ADDR_DP
>1a868c	23 64 64 64 64 00		            .null "#dddd"
>1a8692	c2				            .byte ADDR_IMM | OP_M_EFFECT | OP_X_EFFECT
>1a8693	23 64 64 2c 23 64 64 00		            .null "#dd,#dd"
>1a869b	14				            .byte ADDR_XYC
>1a869c	23 64 64 00			            .null "#dd"
>1a86a0	02				            .byte ADDR_IMM
>1a86a1	28 64 64 2c 53 29 2c 59		            .null "(dd,S),Y"
>1a86a9	00
>1a86aa	0c				            .byte ADDR_SP_R_Y
>1a86ab	28 64 64 64 64 2c 58 29		            .null "(dddd,X)"
>1a86b3	00
>1a86b4	10				            .byte ADDR_ABS_X_ID
>1a86b5	28 64 64 64 64 29 00		            .null "(dddd)"
>1a86bc	10				            .byte ADDR_ABS_X_ID
>1a86bd	28 64 64 2c 58 29 00		            .null "(dd,X)"
>1a86c4	00				            .byte ADDR_DP_IND_X
>1a86c5	28 64 64 29 2c 59 00		            .null "(dd),Y"
>1a86cc	04				            .byte ADDR_DP_IND_Y
>1a86cd	28 64 64 29 00			            .null "(dd)"
>1a86d2	0f				            .byte ADDR_DP_IND
>1a86d3	5b 64 64 64 64 5d 00		            .null "[dddd]"
>1a86da	17				            .byte ADDR_ABS_IND_LONG
>1a86db	5b 64 64 5d 2c 59 00		            .null "[dd],Y"
>1a86e2	0d				            .byte ADDR_DP_Y_LONG
>1a86e3	5b 64 64 5d 00			            .null "[dd]"
>1a86e8	0a				            .byte ADDR_DP_LONG
>1a86e9	00 00				                .byte 0, 0

;******  Return to file: src\monitor.s

.1a86eb					M_INC_CURSOR
.1a86eb	08		php		                PHP
.1a86ec	c2 20		rep #$20	            REP #$20
.1a86ee	48		pha		                PHA
.1a86ef	18		clc		                CLC
.1a86f0	af 7a 08 00	lda $00087a	                LDA MCURSOR
.1a86f4	69 01 00	adc #$0001	                ADC #1
.1a86f7	8f 7a 08 00	sta $00087a	                STA MCURSOR
.1a86fb	e2 20		sep #$20	            SEP #$20
.1a86fd	af 7c 08 00	lda $00087c	                LDA MCURSOR+2
.1a8701	69 00		adc #$00	                ADC #0
.1a8703	8f 7c 08 00	sta $00087c	                STA MCURSOR+2
.1a8707	c2 20		rep #$20	            REP #$20
.1a8709	68		pla		                PLA
.1a870a	28		plp		                PLP
.1a870b	6b		rtl		                RTL
.1a870c					MPRINTB
.1a870c	08		php		                PHP
.1a870d	c2 10		rep #$10	            REP #$10
.1a870f	e2 20		sep #$20	            SEP #$20
.1a8711	da		phx		                PHX
.1a8712	a2 08 00	ldx #$0008	                LDX #8          ; Set number of bits to print to 8
.1a8715	0a		asl a		loop            ASL A           ; Shift MSB to C
.1a8716	b0 08		bcs $1a8720	                BCS is_one
.1a8718	48		pha		                PHA             ; Save value to print
.1a8719	a9 30		lda #$30	                LDA #'0'        ; Print '0'
.1a871b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a871e	80 06		bra $1a8726	                BRA continue
.1a8720	48		pha		is_one          PHA             ; Save value to print
.1a8721	a9 31		lda #$31	                LDA #'1'        ; Print '1'
.1a8723	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8726	68		pla		continue        PLA
.1a8727	ca		dex		                DEX             ; Count down the bits to shift
.1a8728	d0 eb		bne $1a8715	                BNE loop        ; And try the next one if there is one
.1a872a	fa		plx		                PLX             ; Otherwise, return
.1a872b	28		plp		                PLP
.1a872c	6b		rtl		                RTL
.1a872d					MSKIPWS
.1a872d	08		php		            PHP
.1a872e	c2 20		rep #$20	            REP #$20
.1a8730	48		pha		            PHA
.1a8731	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a8734	5b		tcd		            TCD
.1a8735	68		pla		            PLA
.1a8736	28		plp		            PLP
.1a8737	e2 20		sep #$20	            SEP #$20
.1a8739	a7 32		lda [$087a]	loop            LDA [MCURSOR]       ; Check the current character
.1a873b	f0 0a		beq $1a8747	                BEQ done            ; If NULL, we're done
.1a873d	c9 20		cmp #$20	                CMP #' '            ; Is it a space?
.1a873f	d0 06		bne $1a8747	                BNE done            ; No: we're done
.1a8741	22 eb 86 1a	jsl $1a86eb	                JSL M_INC_CURSOR    ; Yes, try the next one
.1a8745	80 f2		bra $1a8739	                BRA loop
.1a8747	6b		rtl		done            RTL
.1a8748					MPARSESTR
.1a8748	08		php		                PHP
.1a8749	08		php		            PHP
.1a874a	c2 20		rep #$20	            REP #$20
.1a874c	48		pha		            PHA
.1a874d	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a8750	5b		tcd		            TCD
.1a8751	68		pla		            PLA
.1a8752	28		plp		            PLP
.1a8753	22 eb 86 1a	jsl $1a86eb	                JSL M_INC_CURSOR                ; Point to the first character of the name
.1a8757	22 2d 87 1a	jsl $1a872d	                JSL MSKIPWS                     ; Skip white space
.1a875b	c2 30		rep #$30	            REP #$30
.1a875d	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.1a875f	c2 20		rep #$20	            REP #$20
.1a8761	29 ff 00	and #$00ff	                AND #$00FF
.1a8764	0a		asl a		                ASL A                           ; multiply it by forfour
.1a8765	0a		asl a		                ASL A
.1a8766	aa		tax		                TAX                             ; ... to get the index to the argument
.1a8767	a5 32		lda $087a	                LDA MCURSOR                     ; Set the argument to the address of the first byte
.1a8769	95 0d		sta $0855,x	                STA MARG1,X
.1a876b	a5 34		lda $087c	                LDA MCURSOR+2
.1a876d	95 0f		sta $0857,x	                STA MARG1+2,X
.1a876f	e2 20		sep #$20	            SEP #$20
.1a8771	a7 32		lda [$087a]	loop            LDA [MCURSOR]                   ; Scan to the closing double quote
.1a8773	f0 14		beq $1a8789	                BEQ done                        ; If NULL... treat it as a closed argument
.1a8775	c9 22		cmp #$22	                CMP #CHAR_DQUOTE
.1a8777	f0 06		beq $1a877f	                BEQ close_string
.1a8779	22 eb 86 1a	jsl $1a86eb	                JSL M_INC_CURSOR
.1a877d	80 f2		bra $1a8771	                BRA loop
.1a877f	a9 00		lda #$00	close_string    LDA #0                          ; Write a NULL to close the string
.1a8781	87 32		sta [$087a]	                STA [MCURSOR]
.1a8783	22 eb 86 1a	jsl $1a86eb	                JSL M_INC_CURSOR                ; And point to the next byte
.1a8787	e6 31		inc $0879	                INC MARG_LEN
.1a8789	28		plp		done            PLP
.1a878a	6b		rtl		                RTL
.1a878b					MPARSEARG
.1a878b	08		php		            PHP
.1a878c	c2 20		rep #$20	            REP #$20
.1a878e	48		pha		            PHA
.1a878f	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a8792	5b		tcd		            TCD
.1a8793	68		pla		            PLA
.1a8794	28		plp		            PLP
.1a8795	e2 20		sep #$20	            SEP #$20
.1a8797	64 4a		stz $0892	                STZ MTEMP                       ; Use MTEMP as a flag for having processed digits
.1a8799	c2 20		rep #$20	            REP #$20
.1a879b	64 50		stz $0898	                STZ MPARSEDNUM                  ; Clear the parsed number
.1a879d	64 52		stz $089a	                STZ MPARSEDNUM+2
.1a879f					pa_loop
.1a879f	e2 20		sep #$20	            SEP #$20
.1a87a1	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Get the current character
.1a87a3	c9 3a		cmp #$3a	                CMP #":"
.1a87a5	f0 0d		beq $1a87b4	                BEQ pa_next_char                ; Ignore any colons
.1a87a7	20 d1 04	jsr $1a04d1	            JSR ISHEX
.1a87aa	90 0e		bcc $1a87ba	                BCC finished_arg                ; No? We're done with this argument
.1a87ac	22 23 7c 1a	jsl $1a7c23	                JSL AS_SHIFT_HEX                ; Yes: shift it onto MPARSEDNUM
.1a87b0	a9 01		lda #$01	                LDA #1                          ; Flag that we've processed a character
.1a87b2	85 4a		sta $0892	                STA MTEMP
.1a87b4	22 eb 86 1a	jsl $1a86eb	pa_next_char    JSL M_INC_CURSOR                ; And try the next character
.1a87b8	80 e5		bra $1a879f	                BRA pa_loop
.1a87ba	a5 4a		lda $0892	finished_arg    LDA MTEMP                       ; Check to see if we've processed any characters
.1a87bc	f0 16		beq $1a87d4	                BEQ done                        ; No: we're done
.1a87be	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.1a87c0	c2 20		rep #$20	            REP #$20
.1a87c2	29 ff 00	and #$00ff	                AND #$00FF
.1a87c5	0a		asl a		                ASL A                           ; multiply it by forfour
.1a87c6	0a		asl a		                ASL A
.1a87c7	aa		tax		                TAX                             ; ... to get the index to the argument
.1a87c8	a5 50		lda $0898	                LDA MPARSEDNUM                  ; Copy the value to the argument slot
.1a87ca	95 0d		sta $0855,x	                STA MARG1,X
.1a87cc	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a87ce	95 0f		sta $0857,x	                STA MARG1+2,X
.1a87d0	e2 20		sep #$20	            SEP #$20
.1a87d2	e6 31		inc $0879	                INC MARG_LEN                    ; And bump up the argument count
.1a87d4	6b		rtl		done            RTL
.1a87d5					MPARSEALLARG
.1a87d5	e2 20		sep #$20	            SEP #$20
.1a87d7	64 31		stz $0879	                STZ MARG_LEN                    ; Set the arg count to 0
.1a87d9	22 2d 87 1a	jsl $1a872d	parse_arg       JSL MSKIPWS                     ; Otherwise, skip white space
.1a87dd	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Check the current character
.1a87df	f0 21		beq $1a8802	                BEQ done                        ; If it is NULL, we're done
.1a87e1	c9 22		cmp #$22	                CMP #CHAR_DQUOTE                ; Is it a double-quote?
.1a87e3	d0 06		bne $1a87eb	                BNE regular_arg
.1a87e5	22 48 87 1a	jsl $1a8748	                JSL MPARSESTR                   ; Yes: parse it as a string argument
.1a87e9	80 0a		bra $1a87f5	                BRA check_rest
.1a87eb	22 8b 87 1a	jsl $1a878b	regular_arg     JSL MPARSEARG                   ; Attempt to parse the argument
.1a87ef	a5 31		lda $0879	                LDA MARG_LEN                    ; Check how many arguments we've processed
.1a87f1	c9 09		cmp #$09	                CMP #9
.1a87f3	b0 0d		bcs $1a8802	                BGE done                        ; If >=9, then we're done
.1a87f5	a7 32		lda [$087a]	check_rest      LDA [MCURSOR]                   ; Check the current character
.1a87f7	f0 09		beq $1a8802	                BEQ done                        ; If EOL: we're done
.1a87f9	c9 20		cmp #$20	                CMP #' '
.1a87fb	f0 dc		beq $1a87d9	                BEQ parse_arg                   ; If space: try to process another argument
.1a87fd	20 d1 04	jsr $1a04d1	            JSR ISHEX
.1a8800	b0 d7		bcs $1a87d9	                BCS parse_arg                   ; If hex digit: try to process another argument
.1a8802	6b		rtl		done            RTL
.1a8803					IMPARSE
.1a8803	08		php		                PHP
.1a8804	0b		phd		                PHD
.1a8805	08		php		            PHP
.1a8806	c2 20		rep #$20	            REP #$20
.1a8808	48		pha		            PHA
.1a8809	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a880c	5b		tcd		            TCD
.1a880d	68		pla		            PLA
.1a880e	28		plp		            PLP
.1a880f	c2 10		rep #$10	            REP #$10
.1a8811	e2 20		sep #$20	            SEP #$20
.1a8813	a2 31 00	ldx #$0031	                LDX #MARG_LEN - MONITOR_VARS    ; Clear the monitor command line parameters
.1a8816	74 00		stz $0848,x	clear_command   STZ MONITOR_VARS,X
.1a8818	ca		dex		                DEX
.1a8819	d0 fb		bne $1a8816	                BNE clear_command
.1a881b	a9 00		lda #$00	                LDA #`INPUTBUF                  ; Point the command parser to the input buffer
.1a881d	85 02		sta $084a	                STA MCMDADDR+2
.1a881f	85 34		sta $087c	                STA MCURSOR+2                   ; And point MCURSOR there too
.1a8821	c2 20		rep #$20	            REP #$20
.1a8823	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF
.1a8826	85 00		sta $0848	                STA MCMDADDR
.1a8828	85 32		sta $087a	                STA MCURSOR
.1a882a	e2 20		sep #$20	            SEP #$20
.1a882c	22 2d 87 1a	jsl $1a872d	                JSL MSKIPWS                     ; Skip to the first letter of the command
.1a8830	c9 00		cmp #$00	                CMP #0                          ; Is the current character a NULL?
.1a8832	f0 38		beq $1a886c	                BEQ done                        ; Yes: there's no command here
.1a8834	c2 20		rep #$20	            REP #$20
.1a8836	a5 32		lda $087a	                LDA MCURSOR
.1a8838	85 08		sta $0850	                STA MCMD
.1a883a	e2 20		sep #$20	            SEP #$20
.1a883c	a5 34		lda $087c	                LDA MCURSOR+2
.1a883e	85 0a		sta $0852	                STA MCMD+2
.1a8840	a2 01 00	ldx #$0001	                LDX #1
.1a8843	22 eb 86 1a	jsl $1a86eb	cmd_loop        JSL M_INC_CURSOR                ; Move to the next character
.1a8847	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; What is that character?
.1a8849	d0 06		bne $1a8851	                BNE cmd_space                   ; If not NULL: check for a space
.1a884b	86 0b		stx $0853	no_arguments    STX MCMD_LEN                    ; If NULL: Save the length of the command
.1a884d	64 31		stz $0879	                STZ MARG_LEN                    ; ... And the fact there are no arguments
.1a884f	80 1b		bra $1a886c	                BRA done                        ; ... And return
.1a8851	c9 20		cmp #$20	cmd_space       CMP #' '                        ; Is it a space?
.1a8853	f0 03		beq $1a8858	                BEQ found_cmd                   ; Yes: save the length
.1a8855	e8		inx		                INX                             ; No: go to the next character
.1a8856	80 eb		bra $1a8843	                BRA cmd_loop
.1a8858	86 0b		stx $0853	found_cmd       STX MCMD_LEN                    ; Save the length of the command
.1a885a	a9 00		lda #$00	                LDA #0
.1a885c	87 32		sta [$087a]	                STA [MCURSOR]                   ; Write a NULL to the end of the command
.1a885e	22 eb 86 1a	jsl $1a86eb	                JSL M_INC_CURSOR                ; And skip to the next character
.1a8862	a7 08		lda [$0850]	                LDA [MCMD]                      ; Check the command
.1a8864	c9 41		cmp #$41	                CMP #'A'
.1a8866	f0 07		beq $1a886f	                BEQ parse_asm                   ; If 'A', parse the line for the assemble command
.1a8868	22 d5 87 1a	jsl $1a87d5	                JSL MPARSEALLARG
.1a886c	2b		pld		done            PLD
.1a886d	28		plp		                PLP
.1a886e	6b		rtl		                RTL
.1a886f	22 2d 87 1a	jsl $1a872d	parse_asm       JSL MSKIPWS                     ; Skip to the first letter of the address
.1a8873	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a8875	f0 f5		beq $1a886c	                BEQ done                        ; Exit if we got the end-of-line
.1a8877	22 8b 87 1a	jsl $1a878b	                JSL MPARSEARG                   ; Parse the first argument as the target address
.1a887b	22 2d 87 1a	jsl $1a872d	                JSL MSKIPWS                     ; Skip to the first letter of the mnemonic
.1a887f	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a8881	f0 e9		beq $1a886c	                BEQ done                        ; Exit if we got the end-of-line
.1a8883	c2 20		rep #$20	            REP #$20
.1a8885	a5 32		lda $087a	                LDA MCURSOR                     ; Save pointer to the start of the mnemonic
.1a8887	85 11		sta $0859	                STA MARG2
.1a8889	e2 20		sep #$20	            SEP #$20
.1a888b	a5 34		lda $087c	                LDA MCURSOR+2
.1a888d	85 13		sta $085b	                STA MARG2+2
.1a888f	22 eb 86 1a	jsl $1a86eb	asm_find_sp     JSL M_INC_CURSOR                ; Find the space at the end of the mnemonic
.1a8893	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a8895	f0 26		beq $1a88bd	                BEQ asm_no_operand              ; If EOL: we have an instruction but no operand
.1a8897	c9 20		cmp #$20	                CMP #' '
.1a8899	d0 f4		bne $1a888f	                BNE asm_find_sp
.1a889b	a9 00		lda #$00	                LDA #0
.1a889d	87 32		sta [$087a]	                STA [MCURSOR]                   ; Null terminate the mnemonic
.1a889f	e6 31		inc $0879	                INC MARG_LEN                    ; Count the mnemonic as an argument
.1a88a1	22 eb 86 1a	jsl $1a86eb	                JSL M_INC_CURSOR
.1a88a5	22 2d 87 1a	jsl $1a872d	                JSL MSKIPWS                     ; Skip to the addressing mode
.1a88a9	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a88ab	f0 bf		beq $1a886c	                BEQ done                        ; If EOL: we're done
.1a88ad	c2 20		rep #$20	            REP #$20
.1a88af	a5 32		lda $087a	                LDA MCURSOR                     ; Set the pointer to the addressing mode
.1a88b1	85 15		sta $085d	                STA MARG3
.1a88b3	e2 20		sep #$20	            SEP #$20
.1a88b5	a5 34		lda $087c	                LDA MCURSOR+2
.1a88b7	85 17		sta $085f	                STA MARG3+2
.1a88b9	e6 31		inc $0879	                INC MARG_LEN                    ; And count it as the second argument
.1a88bb	80 af		bra $1a886c	                BRA done                        ; and return
.1a88bd	e6 31		inc $0879	asm_no_operand  INC MARG_LEN                    ; Increment the argument count
.1a88bf	80 ab		bra $1a886c	                BRA done                        ; And quit
.1a88c1					IMLOAD
.1a88c1	08		php		                PHP
.1a88c2	c2 10		rep #$10	            REP #$10
.1a88c4	e2 20		sep #$20	            SEP #$20
.1a88c6	a5 31		lda $0879	                LDA MARG_LEN
.1a88c8	d0 0f		bne $1a88d9	                BNE get_arguments
.1a88ca	a2 b7 89	ldx #$89b7	bad_arguments   LDX #<>MERRARGS                 ; Print bad arguments error
.1a88cd	a9 1a		lda #$1a	                LDA #`MERRARGS
.1a88cf	48		pha		                PHA
.1a88d0	ab		plb		                PLB
.1a88d1	20 29 04	jsr $1a0429	            JSR PRINTS
.1a88d4	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a88d7	80 61		bra $1a893a	                BRA done
.1a88d9					get_arguments
.1a88d9	c2 20		rep #$20	            REP #$20
.1a88db	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.1a88dd	8f 23 08 00	sta $000823	                STA ARGUMENT1
.1a88e1	a5 0f		lda $0857	                LDA MARG1+2
.1a88e3	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.1a88e7	20 aa 6a	jsr $1a6aaa	            JSR SETFILEDESC
.1a88ea	e2 20		sep #$20	            SEP #$20
.1a88ec	a5 31		lda $0879	                LDA MARG_LEN
.1a88ee	c9 01		cmp #$01	                CMP #1
.1a88f0	d0 0f		bne $1a8901	                BNE get_dest
.1a88f2	c2 20		rep #$20	            REP #$20
.1a88f4	a9 ff ff	lda #$ffff	                LDA #$FFFF                      ; Destination address not provided...
.1a88f7	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR              ; ... set it to something sane
.1a88fb	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a88ff	80 0e		bra $1a890f	                BRA try_load
.1a8901					get_dest
.1a8901	c2 20		rep #$20	            REP #$20
.1a8903	a5 11		lda $0859	                LDA MARG2                       ; Set the destination address from the arguments
.1a8905	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a8909	a5 13		lda $085b	                LDA MARG2+2
.1a890b	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a890f	22 18 11 00	jsl $001118	try_load        JSL FK_LOAD                     ; Try to load the file
.1a8913	b0 25		bcs $1a893a	                BCS done
.1a8915					error
.1a8915	e2 20		sep #$20	            SEP #$20
.1a8917	a2 dd 89	ldx #$89dd	                LDX #<>MCANTLOAD                ; Print bad arguments error
.1a891a	a9 1a		lda #$1a	                LDA #`MCANTLOAD
.1a891c	48		pha		                PHA
.1a891d	ab		plb		                PLB
.1a891e	20 29 04	jsr $1a0429	            JSR PRINTS
.1a8921	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.1a8925	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a8928	a9 20		lda #$20	                LDA #' '
.1a892a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a892d	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.1a8931	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a8934	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a8937	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a893a	28		plp		done            PLP
.1a893b	6b		rtl		                RTL
.1a893c					IMSAVE
.1a893c	8b		phb		                PHB
.1a893d	08		php		                PHP
.1a893e	c2 10		rep #$10	            REP #$10
.1a8940	e2 20		sep #$20	            SEP #$20
.1a8942	a5 31		lda $0879	                LDA MARG_LEN
.1a8944	c9 03		cmp #$03	                CMP #3
.1a8946	f0 0f		beq $1a8957	                BEQ get_arguments
.1a8948	a2 b7 89	ldx #$89b7	                LDX #<>MERRARGS                 ; Print bad arguments error
.1a894b	a9 1a		lda #$1a	                LDA #`MERRARGS
.1a894d	48		pha		                PHA
.1a894e	ab		plb		                PLB
.1a894f	20 29 04	jsr $1a0429	            JSR PRINTS
.1a8952	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a8955	80 54		bra $1a89ab	                BRA done
.1a8957					get_arguments
.1a8957	c2 20		rep #$20	            REP #$20
.1a8959	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.1a895b	8f 23 08 00	sta $000823	                STA ARGUMENT1
.1a895f	a5 0f		lda $0857	                LDA MARG1+2
.1a8961	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.1a8965	20 aa 6a	jsr $1a6aaa	            JSR SETFILEDESC
.1a8968	a5 11		lda $0859	                LDA MARG2                       ; Set the starting address
.1a896a	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.1a896e	a5 13		lda $085b	                LDA MARG2+2
.1a8970	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.1a8974	a5 15		lda $085d	                LDA MARG3                       ; Set the ending address
.1a8976	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.1a897a	a5 17		lda $085f	                LDA MARG3+2
.1a897c	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.1a8980	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                     ; Save the data
.1a8984	b0 25		bcs $1a89ab	                BCS done
.1a8986					error
.1a8986	e2 20		sep #$20	            SEP #$20
.1a8988	a2 c7 89	ldx #$89c7	                LDX #<>MCANTSAVE                ; Print bad arguments error
.1a898b	a9 1a		lda #$1a	                LDA #`MCANTSAVE
.1a898d	48		pha		                PHA
.1a898e	ab		plb		                PLB
.1a898f	20 29 04	jsr $1a0429	            JSR PRINTS
.1a8992	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.1a8996	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a8999	a9 20		lda #$20	                LDA #' '
.1a899b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a899e	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.1a89a2	20 53 04	jsr $1a0453	            JSR PRHEXB
.1a89a5	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a89a8	20 9c 03	jsr $1a039c	            JSR PRINTCR
.1a89ab	28		plp		done            PLP
.1a89ac	ab		plb		                PLB
.1a89ad	6b		rtl		                RTL
.1a89ae	5c 85 27 1a	jmp $1a2785	IMEXIT          JML INTERACT
.1a89b2	6b		rtl		IMRETURN        RTL ; Handle RETURN key (ie: execute command)
.1a89b3	00		brk #		IMPARSE1        BRK ; Parse one word on the current command line
.1a89b4	00		brk #		IMASSEMBLEA     BRK ; Assemble a line of text.
.1a89b5	00		brk #		IMVERIFY        BRK ; Verify memory and file on disk
.1a89b6	00		brk #		IMDOS           BRK ; Execute DOS command
.1a89b7					MMESSAGES
>1a89b7	42 61 64 20 61 72 67 75		MERRARGS        .null "Bad arguments",CHAR_CR,CHAR_CR
>1a89bf	6d 65 6e 74 73 0d 0d 00
>1a89c7	55 6e 61 62 6c 65 20 74		MCANTSAVE       .null "Unable to save file: "
>1a89cf	6f 20 73 61 76 65 20 66 69 6c 65 3a 20 00
>1a89dd	55 6e 61 62 6c 65 20 74		MCANTLOAD       .null "Unable to load file: "
>1a89e5	6f 20 6c 6f 61 64 20 66 69 6c 65 3a 20 00
>1a89f3	0d 20 20 50 43 20 20 20		mregisters_msg  .null $0D,"  PC     A    X    Y    SP   DBR DP   NVMXDIZC",CHAR_CR
>1a89fb	20 20 41 20 20 20 20 58 20 20 20 20 59 20 20 20
>1a8a0b	20 53 50 20 20 20 44 42 52 20 44 50 20 20 20 4e
>1a8a1b	56 4d 58 44 49 5a 43 0d 00
>1a8a24	41 43 44 46 47 4a 48 4c		MCOMMANDS       .null "ACDFGJHLMR;STVWX>?"
>1a8a2c	4d 52 3b 53 54 56 57 58 3e 3f 00

;******  Return to file: src\basic816.s

.1a8a37	18		clc		START       CLC                 ; Go to native mode
.1a8a38	fb		xce		            XCE
.1a8a39	08		php		            PHP
.1a8a3a	c2 20		rep #$20	            REP #$20
.1a8a3c	48		pha		            PHA
.1a8a3d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a8a40	5b		tcd		            TCD
.1a8a41	68		pla		            PLA
.1a8a42	28		plp		            PLP
.1a8a43	08		php		            PHP
.1a8a44	e2 20		sep #$20	            SEP #$20
.1a8a46	48		pha		            PHA
.1a8a47	a9 00		lda #$00	            LDA #BASIC_BANK
.1a8a49	48		pha		            PHA
.1a8a4a	ab		plb		            PLB
.1a8a4b	68		pla		            PLA
.1a8a4c	28		plp		            PLP
.1a8a4d	c2 30		rep #$30	            REP #$30
.1a8a4f	20 76 8a	jsr $1a8a76	            JSR INITBASIC
.1a8a52	a9 ff fe	lda #$feff	            LDA #STACK_END      ; Set the system stack
.1a8a55	1b		tcs		            TCS
.1a8a56	08		php		            PHP
.1a8a57	e2 20		sep #$20	            SEP #$20
.1a8a59	48		pha		            PHA
.1a8a5a	a9 1a		lda #$1a	            LDA #`GREET
.1a8a5c	48		pha		            PHA
.1a8a5d	ab		plb		            PLB
.1a8a5e	68		pla		            PLA
.1a8a5f	28		plp		            PLP
.1a8a60	a2 77 d2	ldx #$d277	            LDX #<>GREET
.1a8a63	20 29 04	jsr $1a0429	            JSR PRINTS
.1a8a66	08		php		            PHP
.1a8a67	e2 20		sep #$20	            SEP #$20
.1a8a69	48		pha		            PHA
.1a8a6a	a9 00		lda #$00	            LDA #BASIC_BANK
.1a8a6c	48		pha		            PHA
.1a8a6d	ab		plb		            PLB
.1a8a6e	68		pla		            PLA
.1a8a6f	28		plp		            PLP
.1a8a70	4c 85 27	jmp $1a2785	            JMP INTERACT        ; Start accepting input from the user
.1a8a73	4c 73 8a	jmp $1a8a73	WAIT        JMP WAIT
.1a8a76					INITBASIC
.1a8a76	08		php		            PHP
.1a8a77	20 34 03	jsr $1a0334	            JSR INITIO
.1a8a7a	20 19 50	jsr $1a5019	            JSR CMD_NEW
.1a8a7d	28		plp		            PLP
.1a8a7e	60		rts		            RTS
>1ad277	43 32 35 36 20 46 6f 65		GREET       .text "C256 Foenix BASIC816 "
>1ad27f	6e 69 78 20 42 41 53 49 43 38 31 36 20

;******  Processing file: src\version.s

>1ad28c	76 30 2e 32 2e 30 2d 61		.text "v0.2.0-alpha+404"
>1ad294	6c 70 68 61 2b 34 30 34

;******  Return to file: src\basic816.s

>1ad29c	0d 00				            .byte 13,0

;******  End of listing
