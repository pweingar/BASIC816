
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -D SYSTEM=2 -D C256_SKU=2 -D UARTSUPPORT= -D UNITTEST=0 -D TRACE_LEVEL=0 --long-address --flat -b --m65816 --intel-hex -o basic816_1A0000.hex --list=basic816_1A0000.lst --labels=basic816_1A0000.lbl src\basic816.s
; Tue May 04 15:30:10 2021

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=2					SYSTEM=2
=2					C256_SKU=2
=					UARTSUPPORT=
=0					UNITTEST=0
=0					TRACE_LEVEL=0

;******  Processing input file: src\basic816.s


;******  Processing file: src\constants.s

=2					SYSTEM_C256 = 2         ; C256 Foenix
=1					SYSTEM_C64 = 1          ; Commodore 64 with SuperCPU
=$03					CHAR_CTRL_C = $03       ; CTRL-C: used as a program interrupt key
=$07					CHAR_BELL = $07         ; Ring the console bell
=$08					CHAR_BS = $08           ; Backspace
=$09					CHAR_TAB = $09          ; TAB
=$0a					CHAR_LF = $0A           ; Linefeed
=$0d					CHAR_CR = $0D           ; Carriage Return
=$0f					CHAR_INS = $0F          ; Insert
=$1b					CHAR_ESC = $1B          ; Escape
=$22					CHAR_DQUOTE = $22       ; Double quote
=$20					CHAR_SP = $20           ; Space
=$7f					CHAR_DEL = $7F          ; Delete
=5					ARGUMENT_SIZE = 5       ; Number of bytes in an argument
=8					VAR_NAME_SIZE = 8       ; Maximum number of characters in a variable name
=0					TYPE_INTEGER = 0        ; 32-bit integer
=1					TYPE_FLOAT = 1          ; Single-precision floating point
=2					TYPE_STRING = 2         ; ASCII string
=$80					TYPE_ARR_INTEGER = $80  ; Array of 32-bit integers
=$81					TYPE_ARR_FLOAT = $81    ; Array of 32-bit floats
=$82					TYPE_ARR_STRING = $82   ; Array of strings
=$7f					TYPE_BINDING = $7F      ; A variable name binding
=$ff					TYPE_NAV = $FF          ; Not-A-Value
=0					ERR_OK = 0              ; No error
=1					ERR_BREAK = 1           ; The user pressed an interrupt key
=2					ERR_SYNTAX = 2          ; A syntax error was found on the current line
=3					ERR_MEMORY = 3          ; Out of memory
=4					ERR_TYPE = 4            ; Type mismatch error
=5					ERR_NOTFOUND = 5        ; Variable not found error
=6					ERR_NOLINE = 6          ; Line number not found
=7					ERR_STACKUNDER = 7      ; Stack underflow error
=8					ERR_STACKOVER = 8       ; Stack overflow error
=9					ERR_RANGE = 9           ; Out-of-range error
=10					ERR_ARGUMENT = 10       ; Bad argument error
=11					ERR_NOFILE = 11         ; File not found error
=12					ERR_NAN = 12            ; Floating point math resulted in something that is not a number
=13					ERR_OVERFLOW = 13       ; Math operation overflowed
=14					ERR_UNDERFLOW = 14      ; Math operation underflowed
=15					ERR_DIV0 = 15           ; Math operation involved a division by zero
=16					ERR_DIRECTORY = 16      ; Error reading the directory
=17					ERR_LOAD = 17           ; Could not load file
=18					ERR_SAVE = 18           ; Could not save a file
=19					ERR_DELETE = 19         ; Could not delete a file
=20					ERR_FILENOTFOUND = 20   ; Could not find the file
=21					ERR_DIRNOTWRITE = 21    ; Could not update the directory entry
=22					ERR_NOTCOPIED = 22      ; Could not copy the file
=23					ERR_DOMAIN = 23         ; Mathematical functions domain error

;******  Return to file: src\basic816.s


;******  Processing file: src\memorymap.s


;******  Processing file: src\C256/mmap_c256.s

=1					SYS_C256_FMX = 1        ; System SKU for C256 Foenix FMX
=2					SYS_C256_USER = 2       ; System SKU for C256 Foenix User

;******  Processing file: src\C256/page_00_inc.s

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				unused_0000      = $000000 ;12 Bytes unused
=$000008				OPL2_ADDY_PTR_LO = $000008  ; THis Points towards the Instruments Database
=$000009				OPL2_ADDY_PTR_MD = $000009
=$00000a				OPL2_ADDY_PTR_HI = $00000A
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;1 Byte Color of next character to be printed to the screen.
=$00001f				COLORPOS         = $00001F ;3 Byte address of cursor's position in the color matrix
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$000026				OPL2_OPERATOR    = $000026 ;
=$000027				OPL2_CHANNEL     = $000027 ;
=$000028				OPL2_REG_REGION  = $000028 ; Offset to the Group of Registers
=$00002a				OPL2_REG_OFFSET  = $00002A ; 2 Bytes (16Bits)
=$00002c				OPL2_IND_ADDY_LL = $00002C ; 2 Bytes Reserved (Only need 3)
=$00002e				OPL2_IND_ADDY_HL = $00002E ; 2 Bytes Reserved (Only need 3)
=$000030				OPL2_NOTE        = $000030 ; 1 Byte
=$000031				OPL2_OCTAVE      = $000031 ; 1 Byte
=$000032				OPL2_PARAMETER0  = $000032 ; 1 Byte - Key On/Feedback
=$000033				OPL2_PARAMETER1  = $000033 ; 1 Byte
=$000034				OPL2_PARAMETER2  = $000034 ; 1 Byte
=$000035				OPL2_PARAMETER3  = $000035 ; 1 Byte
=$000036				OPL2_LOOP        = $000036 ;
=$000036				OPL2_BLOCK       = $000036
=$000038				SDCARD_FILE_PTR  = $000038 ; 3 Bytes Pointer to Filename to open
=$00003c				SDCARD_BYTE_NUM  = $00003C ; 2Bytes
=$00003f				SDCARD_PRSNT_MNT = $00003F ; 1 Byte, Indicate that the SDCard is Present and that it is Mounted
=$000040				BM_CLEAR_SCRN_X  = $000040
=$000042				BM_CLEAR_SCRN_Y  = $000042
=$000040				RAD_STARTLINE    = $000040 ; 1 Byte
=$000041				RAD_PATTERN_IDX  = $000041 ; 1 Byte
=$000042				RAD_LINE         = $000042 ; 1 Byte
=$000043				RAD_LINENUMBER   = $000043 ; 1 Byte
=$000044				RAD_CHANNEL_NUM  = $000044 ; 1 Byte
=$000045				RAD_ISLASTCHAN   = $000045 ; 1 Byte
=$000046				RAD_Y_POINTER    = $000046 ; 2 Bytes
=$000048				RAD_TICK         = $000048
=$00004a				RAD_CHANNEL_DATA = $00004A ; 2 Bytes
=$00004c				RAD_CHANNE_EFFCT = $00004C
=$00004d				RAD_TEMP         = $00004D
=$000050				RAD_ADDR         = $000050 ; 3 bytes to avoid OPL2 errors.
=$000053				RAD_PATTRN       = $000053 ; 1 bytes - offset to patter
=$000054				RAD_PTN_DEST     = $000054 ; 3 bytes - where to write the pattern data
=$000057				RAD_CHANNEL      = $000057 ; 2 bytes - 0 to 8
=$000059				RAD_LAST_NOTE    = $000059 ; 1 if this is the last note
=$00005a				RAD_LINE_PTR     = $00005A ; 2 bytes - offset to memory location
=$000040				BMP_X_SIZE       = $000040 ; 2 Bytes
=$000042				BMP_Y_SIZE       = $000042 ; 2 Bytes
=$000044				BMP_PRSE_SRC_PTR = $000044 ; 3 Bytes
=$000048				BMP_PRSE_DST_PTR = $000048 ; 3 Bytes
=$00004c				BMP_COLOR_PALET  = $00004C ; 2 Bytes
=$00004e				SCRN_X_STRIDE    = $00004E ; 2 Bytes, Basically How many Pixel Accross in Bitmap Mode
=$000050				BMP_FILE_SIZE    = $000050 ; 4 Bytes
=$000054				BMP_POSITION_X   = $000054 ; 2 Bytes Where, the BMP will be position on the X Axis
=$000056				BMP_POSITION_Y   = $000056 ; 2 Bytes Where, the BMP will be position on the Y Axis
=$000058				BMP_PALET_CHOICE = $000058 ;
=$0000e0				MOUSE_PTR        = $0000E0
=$0000e1				MOUSE_POS_X_LO   = $0000E1
=$0000e2				MOUSE_POS_X_HI   = $0000E2
=$0000e3				MOUSE_POS_Y_LO   = $0000E3
=$0000e4				MOUSE_POS_Y_HI   = $0000E4
=$0000f0				USER_TEMP        = $0000F0 ;32 Bytes Temp space for user programs
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000110				DIVIDER_0        = $000110 ;0 Byte  Unsigned divider
=$000110				D0_OPERAND_A     = $000110 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$000112				D0_OPERAND_B     = $000112 ;2 Bytes Divider 0 Divisor ex B in A/B
=$000114				D0_RESULT        = $000114 ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D0_REMAINDER     = $000116 ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000118				DIVIDER_1        = $000118 ;0 Byte  Signed divider
=$000118				D1_OPERAND_A     = $000118 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$00011a				D1_OPERAND_B     = $00011A ;2 Bytes Divider 1 Divisor ex B in A/B
=$00011c				D1_RESULT        = $00011C ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$00011e				D1_REMAINDER     = $00011E ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$000120				ADDER_SIGNED_32  = $000120 ; The 32 Bit Adders takes 12Byte that are NOT RAM Location
=$000140				INT_CONTROLLER   = $000140 ; $000140...$00015F Interrupt Controller
=$000160				TIMER_CONTROLLER = $000160 ; $000160...$00017F Timer0/Timer1/Timer2 Block
=$000160				TIMER_CTRL_REGLL = $000160 ;
=$000161				TIMER_CTRL_REGLH = $000161 ;
=$000162				TIMER_CTRL_REGHL = $000162 ;
=$000163				TIMER_CTRL_REGHH = $000163 ;
=$000240				CPU_REGISTERS    = $000240 ; Byte
=$000240				CPUPC            = $000240 ;2 Bytes Program Counter (PC)
=$000242				CPUPBR           = $000242 ;2 Bytes Program Bank Register (K)
=$000244				CPUA             = $000244 ;2 Bytes Accumulator (A)
=$000246				CPUX             = $000246 ;2 Bytes X Register (X)
=$000248				CPUY             = $000248 ;2 Bytes Y Register (Y)
=$00024a				CPUSTACK         = $00024A ;2 Bytes Stack Pointer (S)
=$00024c				CPUDP            = $00024C ;2 Bytes Direct Page Register (D)
=$00024e				CPUDBR           = $00024E ;1 Byte  Data Bank Register (B)
=$00024f				CPUFLAGS         = $00024F ;1 Byte  Flags (P)
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$000300				FDC_DRIVE        = $000300 ;1 byte - The number of the selected drive
=$000301				FDC_HEAD         = $000301 ;1 byte - The head number (0 or 1)
=$000302				FDC_CYLINDER     = $000302 ;1 byte - The cylinder number
=$000303				FDC_SECTOR       = $000303 ;1 byte - The sector number
=$000304				FDC_SECTOR_SIZE  = $000304 ;1 byte - The sector size code (2 = 512)
=$000305				FDC_SECPERTRK    = $000305 ;1 byte - The number of sectors per track (18 for 1.44 MB floppy)
=$000306				FDC_ST0          = $000306 ;1 byte - Status Register 0
=$000307				FDC_ST1          = $000307 ;1 byte - Status Register 1
=$000308				FDC_ST2          = $000308 ;1 byte - Status Register 2
=$000309				FDC_ST3          = $000309 ;1 byte - Status Register 3
=$00030a				FDC_PCN          = $00030A ;1 byte - Present Cylinder Number
=$00030b				FDC_STATUS       = $00030B ;1 byte - Status of what we think is going on with the FDC:
=$00030c				DIVIDEND         = $00030C ;4 bytes - Dividend for 32-bit division
=$000310				DIVISOR          = $000310 ;4 bytes - Divisor for 32-bit division
=$000314				REMAINDER        = $000314 ;4 bytes - Remainder for 32-bit division
=$000320				SDOS_VARIABLES   = $000320
=$000320				BIOS_STATUS      = $000320      ; 1 byte - Status of any BIOS operation
=$000321				BIOS_DEV         = $000321      ; 1 byte - Block device number for block operations
=$000322				BIOS_LBA         = $000322      ; 4 bytes - Address of block to read/write (this is the physical block, w/o reference to partition)
=$000326				BIOS_BUFF_PTR    = $000326      ; 4 bytes - 24-bit pointer to memory for read/write operations
=$00032a				BIOS_FIFO_COUNT  = $00032A      ; 2 bytes - The number of bytes read on the last block read
=$00032e				DOS_STATUS       = $00032E      ; 1 byte - The error code describing any error with file access
=$000330				DOS_CLUS_ID      = $000330      ; 4 bytes - The cluster desired for a DOS operation
=$000338				DOS_DIR_PTR      = $000338      ; 4 bytes - Pointer to a directory entry (assumed to be within DOS_SECTOR)
=$00033c				DOS_BUFF_PTR     = $00033C      ; 4 bytes - A pointer for DOS cluster read/write operations
=$000340				DOS_FD_PTR       = $000340      ; 4 bytes - A pointer to a file descriptor
=$000344				DOS_FAT_LBA      = $000344      ; 4 bytes - The LBA for a sector of the FAT we need to read/write
=$000348				DOS_TEMP         = $000348      ; 4 bytes - Temporary storage for DOS operations
=$00034c				DOS_FILE_SIZE    = $00034C      ; 4 bytes - The size of a file
=$000350				DOS_SRC_PTR      = $000350      ; 4 bytes - Pointer for transferring data
=$000354				DOS_DST_PTR      = $000354      ; 4 bytes - Pointer for transferring data
=$000358				DOS_END_PTR      = $000358      ; 4 bytes - Pointer to the last byte to save
=$00035c				DOS_RUN_PTR      = $00035C      ; 4 bytes - Pointer for starting a loaded program
=$000360				DOS_RUN_PARAM    = $000360      ; 4 bytes - Pointer to the ASCIIZ string for arguments in loading a program
=$000364				DOS_STR1_PTR     = $000364      ; 4 bytes - pointer to a string
=$000368				DOS_STR2_PTR     = $000368      ; 4 bytes - pointer to a string
=$00036b				DOS_SCRATCH      = $00036B      ; 4 bytes - general purpose short term storage
=$000400				DOS_PATH_BUFF    = $000400      ; 256 bytes - A buffer for path names
=$000500				FDC_PARAMETERS   = $000500      ; 16 bytes - a buffer of parameter data for the FDC
=$000510				FDC_RESULTS      = $000510      ; 16 bytes - Buffer for results of FDC commands
=$000530				FDC_PARAM_NUM    = $000530      ; 1 byte - The number of parameters to send to the FDC (including command)
=$000532				FDC_RESULT_NUM   = $000532      ; 1 byte - The number of results expected
=$000533				FDC_EXPECT_DAT   = $000533      ; 1 byte - 0 = the command expects no data, otherwise expects data
=$000534				FDC_CMD_RETRY    = $000534      ; 1 byte - a retry counter for commands
=$000700				CURRUART         = $000700 ; 3-bytes: the base address of the current UART
=$000703				CHAN_OUT         = $000703 ; 1-byte: the number of the current output channel (for PUTC, etc.)
=$000704				CHAN_IN          = $000704 ; 1-byte: the number of the current input channel (for GETCH, etc.)
=$000705				TIMERFLAGS       = $000705 ; 1-byte: flags to indicate that one of the timer interupts has triggered
=$80					TIMER0TRIGGER    = $80
=$40					TIMER1TRIGGER    = $40
=$20					TIMER2TRIGGER    = $20
=$000f00				KEY_BUFFER       = $000F00 ; 64 Bytes keyboard buffer
=$0080					KEY_BUFFER_SIZE  = $0080   ;128 Bytes (constant) keyboard buffer length
=$000f7f				KEY_BUFFER_END   = $000F7F ;  1 Byte  Last byte of keyboard buffer
=$000f83				KEY_BUFFER_CMD   = $000F83 ;  1 Byte  Indicates the Command Process Status
=$000f84				COMMAND_SIZE_STR = $000F84 ;  1 Byte
=$000f86				COMMAND_COMP_TMP = $000F86 ;  2 Bytes
=$000f87				KEYBOARD_SC_FLG  = $000F87 ;  1 Bytes that indicate the Status of Left Shift, Left CTRL, Left ALT, Right Shift
=$000f88				KEYBOARD_SC_TMP  = $000F88 ;  1 Byte, Interrupt Save Scan Code while Processing
=$000f89				KEYBOARD_LOCKS   = $000F89 ;  1 Byte, the status of the various lock keys
=$000f8a				KEYFLAG          = $000F8A ;  1 Byte, flag to indicate if CTRL-C has been pressed
=$000f8b				KEY_BUFFER_RPOS  = $000F8B ;  2 Byte, position of the character to read from the KEY_BUFFER
=$000f8d				KEY_BUFFER_WPOS  = $000F8D ;  2 Byte, position of the character to write to the KEY_BUFFER
=$001000				KERNEL_JMP_BEGIN = $001000 ; Reserved for the Kernel jump table
=$001fff				KERNEL_JMP_END   = $001FFF
=$002000				TEST_BEGIN       = $002000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/int_math_defs.s

=$000100				UNSIGNED_MULT_A_LO  = $000100
=$000101				UNSIGNED_MULT_A_HI  = $000101
=$000102				UNSIGNED_MULT_B_LO  = $000102
=$000103				UNSIGNED_MULT_B_HI  = $000103
=$000104				UNSIGNED_MULT_AL_LO = $000104
=$000105				UNSIGNED_MULT_AL_HI = $000105
=$000106				UNSIGNED_MULT_AH_LO = $000106
=$000107				UNSIGNED_MULT_AH_HI = $000107
=$000108				SIGNED_MULT_A_LO    = $000108
=$000109				SIGNED_MULT_A_HI    = $000109
=$00010a				SIGNED_MULT_B_LO    = $00010A
=$00010b				SIGNED_MULT_B_HI    = $00010B
=$00010c				SIGNED_MULT_AL_LO   = $00010C
=$00010d				SIGNED_MULT_AL_HI   = $00010D
=$00010e				SIGNED_MULT_AH_LO   = $00010E
=$00010f				SIGNED_MULT_AH_HI   = $00010F
=$000110				UNSIGNED_DIV_DEM_LO = $000110
=$000111				UNSIGNED_DIV_DEM_HI = $000111
=$000112				UNSIGNED_DIV_NUM_LO = $000112
=$000113				UNSIGNED_DIV_NUM_HI = $000113
=$000114				UNSIGNED_DIV_QUO_LO = $000114
=$000115				UNSIGNED_DIV_QUO_HI = $000115
=$000116				UNSIGNED_DIV_REM_LO = $000116
=$000117				UNSIGNED_DIV_REM_HI = $000117
=$000118				SIGNED_DIV_DEM_LO   = $000118
=$000119				SIGNED_DIV_DEM_HI   = $000119
=$00011a				SIGNED_DIV_NUM_LO   = $00011A
=$00011b				SIGNED_DIV_NUM_HI   = $00011B
=$00011c				SIGNED_DIV_QUO_LO   = $00011C
=$00011d				SIGNED_DIV_QUO_HI   = $00011D
=$00011e				SIGNED_DIV_REM_LO   = $00011E
=$00011f				SIGNED_DIV_REM_HI   = $00011F
=$000120				ADDER32_A_LL        = $000120
=$000121				ADDER32_A_LH        = $000121
=$000122				ADDER32_A_HL        = $000122
=$000123				ADDER32_A_HH        = $000123
=$000124				ADDER32_B_LL        = $000124
=$000125				ADDER32_B_LH        = $000125
=$000126				ADDER32_B_HL        = $000126
=$000127				ADDER32_B_HH        = $000127
=$000128				ADDER32_R_LL        = $000128
=$000129				ADDER32_R_LH        = $000129
=$00012a				ADDER32_R_HL        = $00012A
=$00012b				ADDER32_R_HH        = $00012B
=$af1400				SIGNED32_MULT_A     = $AF1400
=$af1404				SIGNED32_MULT_B     = $AF1404
=$af1408				SIGNED32_MULT_OUT   = $AF1408

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/vicky_def.s

=$af0000				MASTER_CTRL_REG_L	      = $AF0000
=$01					Mstr_Ctrl_Text_Mode_En  = $01       ; Enable the Text Mode
=$02					Mstr_Ctrl_Text_Overlay  = $02       ; Enable the Overlay of the text mode on top of Graphic Mode (the Background Color is ignored)
=$04					Mstr_Ctrl_Graph_Mode_En = $04       ; Enable the Graphic Mode
=$08					Mstr_Ctrl_Bitmap_En     = $08       ; Enable the Bitmap Module In Vicky
=$10					Mstr_Ctrl_TileMap_En    = $10       ; Enable the Tile Module in Vicky
=$20					Mstr_Ctrl_Sprite_En     = $20       ; Enable the Sprite Module in Vicky
=$40					Mstr_Ctrl_GAMMA_En      = $40       ; this Enable the GAMMA correction - The Analog and DVI have different color value, the GAMMA is great to correct the difference
=$80					Mstr_Ctrl_Disable_Vid   = $80       ; This will disable the Scanning of the Video hence giving 100% bandwith to the CPU
=$af0001				MASTER_CTRL_REG_H       = $AF0001
=$01					Mstr_Ctrl_Video_Mode0   = $01       ; 0 - 640x480 (Clock @ 25.175Mhz), 1 - 800x600 (Clock @ 40Mhz)
=$02					Mstr_Ctrl_Video_Mode1   = $02       ; 0 - No Pixel Doubling, 1- Pixel Doubling (Reduce the Pixel Resolution by 2)
=$af0002				GAMMA_CTRL_REG          = $AF0002
=$01					GAMMA_Ctrl_Input        = $01 ; 0 = DipSwitch Chooses GAMMA on/off , 1- Software Control
=$02					GAMMA_Ctrl_Soft         = $02 ; 0 = GAMMA Table is not Applied, 1 = GAMMA Table is Applied
=$08					GAMMA_DP_SW_VAL         = $08 ; READ ONLY - Actual DIP Switch Value
=$10					HIRES_DP_SW_VAL         = $10 ; READ ONLY - 0 = Hi-Res on BOOT ON, 1 = Hi-Res on BOOT OFF
=$af0003				VKY_RESERVED_01         = $AF0003
=$01					Border_Ctrl_Enable      = $01
=$af0004				BORDER_CTRL_REG         = $AF0004 ; Bit[0] - Enable (1 by default)  Bit[4..6]: X Scroll Offset ( Will scroll Left) (Acceptable Value: 0..7)
=$af0005				BORDER_COLOR_B          = $AF0005
=$af0006				BORDER_COLOR_G          = $AF0006
=$af0007				BORDER_COLOR_R          = $AF0007
=$af0008				BORDER_X_SIZE           = $AF0008; X-  Values: 0 - 32 (Default: 32)
=$af0009				BORDER_Y_SIZE           = $AF0009; Y- Values 0 -32 (Default: 32)
=$af000d				BACKGROUND_COLOR_B      = $AF000D ; When in Graphic Mode, if a pixel is "0" then the Background pixel is chosen
=$af000e				BACKGROUND_COLOR_G      = $AF000E
=$af000f				BACKGROUND_COLOR_R      = $AF000F ;
=$af0010				VKY_TXT_CURSOR_CTRL_REG = $AF0010   ;[0]  Enable Text Mode
=$01					Vky_Cursor_Enable       = $01
=$02					Vky_Cursor_Flash_Rate0  = $02       ; 00 - 1/Sec, 01 - 2/Sec, 10 - 4/Sec, 11 - 5/Sec
=$04					Vky_Cursor_Flash_Rate1  = $04
=$08					Vky_Cursor_FONT_Page0   = $08       ; Pick Font Page 0 or Font Page 1
=$10					Vky_Cursor_FONT_Page1   = $10       ; Pick Font Page 0 or Font Page 1
=$af0011				VKY_TXT_START_ADD_PTR   = $AF0011   ; This is an offset to change the Starting address of the Text Mode Buffer (in x)
=$af0012				VKY_TXT_CURSOR_CHAR_REG = $AF0012
=$af0013				VKY_TXT_CURSOR_COLR_REG = $AF0013
=$af0014				VKY_TXT_CURSOR_X_REG_L  = $AF0014
=$af0015				VKY_TXT_CURSOR_X_REG_H  = $AF0015
=$af0016				VKY_TXT_CURSOR_Y_REG_L  = $AF0016
=$af0017				VKY_TXT_CURSOR_Y_REG_H  = $AF0017
=$af001b				VKY_LINE_IRQ_CTRL_REG   = $AF001B ;[0] - Enable Line 0, [1] -Enable Line 1
=$af001c				VKY_LINE0_CMP_VALUE_LO  = $AF001C ;Write Only [7:0]
=$af001d				VKY_LINE0_CMP_VALUE_HI  = $AF001D ;Write Only [3:0]
=$af001e				VKY_LINE1_CMP_VALUE_LO  = $AF001E ;Write Only [7:0]
=$af001f				VKY_LINE1_CMP_VALUE_HI  = $AF001F ;Write Only [3:0]
=$af001c				VKY_INFO_CHIP_NUM_L     = $AF001C   ; VErsion
=$af001d				VKY_INFO_CHIP_NUM_H     = $AF001D   ; Version
=$af001e				VKY_INFO_CHIP_VER_L     = $AF001E   ; Sub-Version
=$af001f				VKY_INFO_CHIP_VER_H     = $AF001F   ; Sub-Version
=$af0500				MOUSE_PTR_GRAP0_START    = $AF0500 ; 16 x 16 = 256 Pixels (Grey Scale) 0 = Transparent, 1 = Black , 255 = White
=$af05ff				MOUSE_PTR_GRAP0_END      = $AF05FF ; Pointer 0
=$af0600				MOUSE_PTR_GRAP1_START    = $AF0600 ;
=$af06ff				MOUSE_PTR_GRAP1_END      = $AF06FF ; Pointer 1
=$af0700				MOUSE_PTR_CTRL_REG_L    = $AF0700 ; Bit[0] Enable, Bit[1] = 0  ( 0 = Pointer0, 1 = Pointer1)
=$af0701				MOUSE_PTR_CTRL_REG_H    = $AF0701 ;
=$af0702				MOUSE_PTR_X_POS_L       = $AF0702 ; X Position (0 - 639) (Can only read now) Writing will have no effect
=$af0703				MOUSE_PTR_X_POS_H       = $AF0703 ;
=$af0704				MOUSE_PTR_Y_POS_L       = $AF0704 ; Y Position (0 - 479) (Can only read now) Writing will have no effect
=$af0705				MOUSE_PTR_Y_POS_H       = $AF0705 ;
=$af0706				MOUSE_PTR_BYTE0         = $AF0706 ; Byte 0 of Mouse Packet (you must write 3 Bytes)
=$af0707				MOUSE_PTR_BYTE1         = $AF0707 ; Byte 1 of Mouse Packet (if you don't, then )
=$af0708				MOUSE_PTR_BYTE2         = $AF0708 ; Byte 2 of Mouse Packet (state Machine will be jammed in 1 state)
=$af070b				C256F_MODEL_MAJOR       = $AF070B ;
=$af070c				C256F_MODEL_MINOR       = $AF070C ;
=$af070d				FPGA_DOR                = $AF070D ;
=$af070e				FPGA_MOR                = $AF070E ;
=$af070f				FPGA_YOR                = $AF070F ;
=$af0900				VMEM2CPU_CTRL_REG      = $AF0900  ;
=$01					VMEM2CPU_Clear_FIFO    = $01        ; Setting this to 1 will flush (Reset) the FIFO, clear it after to return to normal function
=$02					VMEM2CPU_Intterupt     = $02        ; This is not implemented because there is not enough Interrupt line on the FMX
=$af0901				VMEM2CPU_Data_Port     = $AF0901    ; This is a Byte Port of the data that you have requested. (Output of the FIFO)
=$af0902				VMEM2CPU_Fifo_Count_LO = $AF0902    ; FIFO Count Lo (number of byte in the FIFO) FIFO Count is 10bits, Count_Bit0 to Count_Bit7 of Count
=$af0903				VMEM2CPU_Fifo_Count_HI = $AF0903    ; FIFO Count Hi, Bit 0 = Count_Bit8, Bit 1 = Count_Bit9
=$80					VMEM2CPU_Fifo_Empty    = $80        ; Bit 7 of VMEM2CPU_Fifo_Count_HI, when 1, the FIFO is empty.
=$af1f40				FG_CHAR_LUT_PTR         = $AF1F40
=$af1f80				BG_CHAR_LUT_PTR		    = $AF1F80
=$af2000				GRPH_LUT0_PTR		    = $AF2000
=$af2400				GRPH_LUT1_PTR		    = $AF2400
=$af2800				GRPH_LUT2_PTR		    = $AF2800
=$af2c00				GRPH_LUT3_PTR		    = $AF2C00
=$af3000				GRPH_LUT4_PTR		    = $AF3000
=$af3400				GRPH_LUT5_PTR		    = $AF3400
=$af3800				GRPH_LUT6_PTR		    = $AF3800
=$af3c00				GRPH_LUT7_PTR		    = $AF3C00
=$af4000				GAMMA_B_LUT_PTR		    = $AF4000
=$af4100				GAMMA_G_LUT_PTR		    = $AF4100
=$af4200				GAMMA_R_LUT_PTR		    = $AF4200
=$af8000				FONT_MEMORY_BANK0       = $AF8000     ;$AF8000 - $AF87FF
=$afa000				CS_TEXT_MEM_PTR         = $AFA000
=$afc000				CS_COLOR_MEM_PTR        = $AFC000

;******  Processing file: src\C256/VKYII_CFP9553_BITMAP_def.s

=$01					BM_Enable             = $01
=$00					BM_LUT0               = $00 ;
=$02					BM_LUT1               = $02 ;
=$04					BM_LUT2               = $04 ;
=$06					BM_LUT3               = $06 ;
=$08					BM_LUT4               = $08 ;
=$0a					BM_LUT5               = $0A ;
=$0c					BM_LUT6               = $0C ;
=$0e					BM_LUT7               = $0E ;
=$af0100				BM0_CONTROL_REG     = $AF0100
=$af0101				BM0_START_ADDY_L    = $AF0101
=$af0102				BM0_START_ADDY_M    = $AF0102
=$af0103				BM0_START_ADDY_H    = $AF0103
=$af0104				BM0_X_OFFSET        = $AF0104   ; Not Implemented
=$af0105				BM0_Y_OFFSET        = $AF0105   ; Not Implemented
=$af0106				BM0_RESERVED_6      = $AF0106
=$af0107				BM0_RESERVED_7      = $AF0107
=$af0108				BM1_CONTROL_REG     = $AF0108
=$af0109				BM1_START_ADDY_L    = $AF0109
=$af010a				BM1_START_ADDY_M    = $AF010A
=$af010b				BM1_START_ADDY_H    = $AF010B
=$af010c				BM1_X_OFFSET        = $AF010C   ; Not Implemented
=$af010d				BM1_Y_OFFSET        = $AF010D   ; Not Implemented
=$af010e				BM1_RESERVED_6      = $AF010E
=$af010f				BM1_RESERVED_7      = $AF010F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_TILEMAP_def.s

=$01					TILE_Enable             = $01
=0					TILEMAP_CONTROL         = 0             ; Offset to a tile map's control register
=1					TILEMAP_START_ADDY      = 1             ; Offset to a tile map's address
=4					TILEMAP_TOTAL_X         = 4             ; Offset to a tile map's width
=6					TILEMAP_TOTAL_Y         = 6             ; Offset to a tile map's height
=8					TILEMAP_WINDOW_X        = 8             ; Offset to a tile map's X position
=10					TILEMAP_WINDOW_Y        = 10            ; Offset to a tile map's Y position
=1					TILEMAP_VISIBLE         = 1             ; Tile map is visible flag
=$af0200				TL0_CONTROL_REG         = $AF0200       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0201				TL0_START_ADDY_L        = $AF0201       ; Not USed right now - Starting Address to where is the MAP
=$af0202				TL0_START_ADDY_M        = $AF0202
=$af0203				TL0_START_ADDY_H        = $AF0203
=$af0204				TL0_TOTAL_X_SIZE_L      = $AF0204       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0205				TL0_TOTAL_X_SIZE_H      = $AF0205
=$af0206				TL0_TOTAL_Y_SIZE_L      = $AF0206       ; Size of the Map in Y Tile Count [9:0]
=$af0207				TL0_TOTAL_Y_SIZE_H      = $AF0207
=$af0208				TL0_WINDOW_X_POS_L      = $AF0208       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0209				TL0_WINDOW_X_POS_H      = $AF0209       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af020a				TL0_WINDOW_Y_POS_L      = $AF020A       ; Top Left Corner Position of the TileMAp Window in Y
=$af020b				TL0_WINDOW_Y_POS_H      = $AF020B       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af020c				TL1_CONTROL_REG         = $AF020C       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af020d				TL1_START_ADDY_L        = $AF020D       ; Not USed right now - Starting Address to where is the MAP
=$af020e				TL1_START_ADDY_M        = $AF020E
=$af020f				TL1_START_ADDY_H        = $AF020F
=$af0210				TL1_TOTAL_X_SIZE_L      = $AF0210       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0211				TL1_TOTAL_X_SIZE_H      = $AF0211
=$af0212				TL1_TOTAL_Y_SIZE_L      = $AF0212       ; Size of the Map in Y Tile Count [9:0]
=$af0213				TL1_TOTAL_Y_SIZE_H      = $AF0213
=$af0214				TL1_WINDOW_X_POS_L      = $AF0214       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0215				TL1_WINDOW_X_POS_H      = $AF0215       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0216				TL1_WINDOW_Y_POS_L      = $AF0216       ; Top Left Corner Position of the TileMAp Window in Y
=$af0217				TL1_WINDOW_Y_POS_H      = $AF0217       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0218				TL2_CONTROL_REG         = $AF0218       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0219				TL2_START_ADDY_L        = $AF0219       ; Not USed right now - Starting Address to where is the MAP
=$af021a				TL2_START_ADDY_M        = $AF021A
=$af021b				TL2_START_ADDY_H        = $AF021B
=$af021c				TL2_TOTAL_X_SIZE_L      = $AF021C       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af021d				TL2_TOTAL_X_SIZE_H      = $AF021D
=$af021e				TL2_TOTAL_Y_SIZE_L      = $AF021E       ; Size of the Map in Y Tile Count [9:0]
=$af021f				TL2_TOTAL_Y_SIZE_H      = $AF021F
=$af0220				TL2_WINDOW_X_POS_L      = $AF0220       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0221				TL2_WINDOW_X_POS_H      = $AF0221       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0222				TL2_WINDOW_Y_POS_L      = $AF0222       ; Top Left Corner Position of the TileMAp Window in Y
=$af0223				TL2_WINDOW_Y_POS_H      = $AF0223       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0224				TL3_CONTROL_REG         = $AF0224       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0225				TL3_START_ADDY_L        = $AF0225       ; Not USed right now - Starting Address to where is the MAP
=$af0226				TL3_START_ADDY_M        = $AF0226
=$af0227				TL3_START_ADDY_H        = $AF0227
=$af0228				TL3_TOTAL_X_SIZE_L      = $AF0228       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0229				TL3_TOTAL_X_SIZE_H      = $AF0229
=$af022a				TL3_TOTAL_Y_SIZE_L      = $AF022A       ; Size of the Map in Y Tile Count [9:0]
=$af022b				TL3_TOTAL_Y_SIZE_H      = $AF022B
=$af022c				TL3_WINDOW_X_POS_L      = $AF022C       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af022d				TL3_WINDOW_X_POS_H      = $AF022D       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af022e				TL3_WINDOW_Y_POS_L      = $AF022E       ; Top Left Corner Position of the TileMAp Window in Y
=$af022f				TL3_WINDOW_Y_POS_H      = $AF022F       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0280				TILESET0_ADDY_L         = $AF0280   ; Pointer to Tileset 0 [21:0]
=$af0281				TILESET0_ADDY_M         = $AF0281
=$af0282				TILESET0_ADDY_H         = $AF0282
=$af0283				TILESET0_ADDY_CFG       = $AF0283   ; [3] - TileStride256x256 [2:0] LUT
=2					TILESET_ADDY_H          = 2             ; Offset to high byte of tile set address
=3					TILESET_ADDY_CFG        = 3             ; Offset to the tile set address configuration
=$08					TILESET_SQUARE_256      = $08
=$af0284				TILESET1_ADDY_L         = $AF0284
=$af0285				TILESET1_ADDY_M         = $AF0285
=$af0286				TILESET1_ADDY_H         = $AF0286
=$af0287				TILESET1_ADDY_CFG       = $AF0287
=$af0288				TILESET2_ADDY_L         = $AF0288
=$af0289				TILESET2_ADDY_M         = $AF0289
=$af028a				TILESET2_ADDY_H         = $AF028A
=$af028b				TILESET2_ADDY_CFG       = $AF028B
=$af028c				TILESET3_ADDY_L         = $AF028C
=$af028d				TILESET3_ADDY_M         = $AF028D
=$af028e				TILESET3_ADDY_H         = $AF028E
=$af028f				TILESET3_ADDY_CFG       = $AF028F
=$af0290				TILESET4_ADDY_L         = $AF0290
=$af0291				TILESET4_ADDY_M         = $AF0291
=$af0292				TILESET4_ADDY_H         = $AF0292
=$af0293				TILESET4_ADDY_CFG       = $AF0293
=$af0294				TILESET5_ADDY_L         = $AF0294
=$af0295				TILESET5_ADDY_M         = $AF0295
=$af0296				TILESET5_ADDY_H         = $AF0296
=$af0297				TILESET5_ADDY_CFG       = $AF0297
=$af0298				TILESET6_ADDY_L         = $AF0298
=$af0299				TILESET6_ADDY_M         = $AF0299
=$af029a				TILESET6_ADDY_H         = $AF029A
=$af029b				TILESET6_ADDY_CFG       = $AF029B
=$af029c				TILESET7_ADDY_L         = $AF029C
=$af029d				TILESET7_ADDY_M         = $AF029D
=$af029e				TILESET7_ADDY_H         = $AF029E
=$af029f				TILESET7_ADDY_CFG       = $AF029F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SDMA_def.s

=$af0420				SDMA_CTRL_REG0           = $AF0420
=$01					SDMA_CTRL0_Enable        = $01
=$02					SDMA_CTRL0_1D_2D         = $02     ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					SDMA_CTRL0_TRF_Fill      = $04     ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					SDMA_CTRL0_Int_Enable    = $08     ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					SDMA_CTRL0_SysRAM_Src    = $10     ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					SDMA_CTRL0_SysRAM_Dst    = $20     ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$00					SDMA_XFER_SRAM2SRAM = $00           ; SRAM -> SRAM transfer
=$10					SDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					SDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$30					SDMA_XFER_SRAMIO = $30              ; SRAM <-> IO transfer (see: SDMA_CONTROL_REG1 for config and direction)
=$40					SDMA_CTLR0_RSVD          = $40      ; Reserved
=$80					SDMA_CTRL0_Start_TRF     = $80      ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$af0421				SDMA_CTRL_REG1           = $AF0421  ; Write Only - Byte to Write in the Fill Function
=$01					SDMA_CTRL1_IO_Src		 = $01		; 1 = Source is an IO Address (ADC, SuperIO, IDE)
=$02					SDMA_CTRL1_IO_Src16		 = $02		; 0 = Src 8Bits Transfer / 1= 16Bits Transfer
=$04					SDMA_CTRL1_IO_Dst		 = $04		; 1 = Destination is an IO Address (DAC, SuperIO, IDE)
=$08					SDMA_CTRL1_IO_Dst16      = $08      ; 0 = Dst 8bits Transfer / 1= 16bits
=$af0422				SDMA_SRC_ADDY_L         = $AF0422   ; Pointer to the Source of the Data to be stransfered
=$af0423				SDMA_SRC_ADDY_M         = $AF0423   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0424				SDMA_SRC_ADDY_H         = $AF0424
=$af0425				SDMA_DST_ADDY_L         = $AF0425   ; Destination Pointer within CPU's video memory Range
=$af0426				SDMA_DST_ADDY_M         = $AF0426   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0427				SDMA_DST_ADDY_H         = $AF0427
=$af0428				SDMA_SIZE_L             = $AF0428   ; Maximum Value: $40:0000 (4Megs)
=$af0429				SDMA_SIZE_M             = $AF0429
=$af042a				SDMA_SIZE_H             = $AF042A
=$af042b				SDMA_IGNORED            = $AF042B
=$af0428				SDMA_X_SIZE_L           = $AF0428   ; Maximum Value: 65535
=$af0429				SDMA_X_SIZE_H           = $AF0429
=$af042a				SDMA_Y_SIZE_L           = $AF042A   ; Maximum Value: 65535
=$af042b				SDMA_Y_SIZE_H           = $AF042B
=$af042c				SDMA_SRC_STRIDE_L       = $AF042C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042d				SDMA_SRC_STRIDE_H       = $AF042D   ;
=$af042e				SDMA_DST_STRIDE_L       = $AF042E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042f				SDMA_DST_STRIDE_H       = $AF042F   ;
=$af0430				SDMA_BYTE_2_WRITE       = $AF0430   ; Write Only - Byte to Write in the Fill Function
=$af0430				SDMA_STATUS_REG         = $AF0430   ; Read only
=$01					SDMA_STAT_Size_Err       = $01      ; If Set to 1, Overall Size is Invalid
=$02					SDMA_STAT_Dst_Add_Err    = $02      ; If Set to 1, Destination Address Invalid
=$04					SDMA_STAT_Src_Add_Err    = $04      ; If Set to 1, Source Address Invalid
=$08					SDMA_STAT_TimeOut_Err    = $08      ; will be set to 1 if a Timeout occur when transfering between data from and to VRAM

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_VDMA_def.s

=$af0400				VDMA_CONTROL_REG        = $AF0400
=$01					VDMA_CTRL_Enable        = $01
=$02					VDMA_CTRL_1D_2D         = $02       ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					VDMA_CTRL_TRF_Fill      = $04       ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					VDMA_CTRL_Int_Enable    = $08       ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					VDMA_CTRL_SysRAM_Src    = $10       ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					VDMA_CTRL_SysRAM_Dst    = $20       ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$80					VDMA_CTRL_Start_TRF     = $80       ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$00					VDMA_XFER_VRAM2VRAM = $00           ; VRAM -> VRAM transfer
=$10					VDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					VDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$af0401				VDMA_BYTE_2_WRITE       = $AF0401   ; Write Only - Byte to Write in the Fill Function
=$af0401				VDMA_STATUS_REG         = $AF0401   ; Read only
=$01					VDMA_STAT_Size_Err      = $01       ; If Set to 1, Overall Size is Invalid
=$02					VDMA_STAT_Dst_Add_Err   = $02       ; If Set to 1, Destination Address Invalid
=$04					VDMA_STAT_Src_Add_Err   = $04       ; If Set to 1, Source Address Invalid
=$80					VDMA_STAT_VDMA_IPS      = $80       ; If Set to 1, VDMA Transfer in Progress (this Inhibit CPU Access to Mem)
=$af0402				VDMA_SRC_ADDY_L         = $AF0402   ; Pointer to the Source of the Data to be stransfered
=$af0403				VDMA_SRC_ADDY_M         = $AF0403   ; This needs to be within Vicky's Range ($00_0000 - $3F_0000)
=$af0404				VDMA_SRC_ADDY_H         = $AF0404
=$af0405				VDMA_DST_ADDY_L         = $AF0405   ; Destination Pointer within Vicky's video memory Range
=$af0406				VDMA_DST_ADDY_M         = $AF0406   ; ($00_0000 - $3F_0000)
=$af0407				VDMA_DST_ADDY_H         = $AF0407
=$af0408				VDMA_SIZE_L             = $AF0408   ; Maximum Value: $40:0000 (4Megs)
=$af0409				VDMA_SIZE_M             = $AF0409
=$af040a				VDMA_SIZE_H             = $AF040A
=$af040b				VDMA_IGNORED            = $AF040B
=$af0408				VDMA_X_SIZE_L           = $AF0408   ; Maximum Value: 65535
=$af0409				VDMA_X_SIZE_H           = $AF0409
=$af040a				VDMA_Y_SIZE_L           = $AF040A   ; Maximum Value: 65535
=$af040b				VDMA_Y_SIZE_H           = $AF040B
=$af040c				VDMA_SRC_STRIDE_L       = $AF040C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040d				VDMA_SRC_STRIDE_H       = $AF040D   ;
=$af040e				VDMA_DST_STRIDE_L       = $AF040E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040f				VDMA_DST_STRIDE_H       = $AF040F   ;

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SPRITE_def.s

=$01					SPRITE_Enable             = $01
=$00					SPRITE_LUT0               = $00 ; This is the LUT that the Sprite will use
=$02					SPRITE_LUT1               = $02
=$04					SPRITE_LUT2               = $04 ; Only 4 LUT for Now, So this bit is not used.
=$06					SPRITE_LUT3               = $06 ; Only 4 LUT for Now, So this bit is not used.
=$08					SPRITE_LUT4               = $08 ; Only 4 LUT for Now, So this bit is not used.
=$0a					SPRITE_LUT5               = $0A ; Only 4 LUT for Now, So this bit is not used.
=$0c					SPRITE_LUT6               = $0C ; Only 4 LUT for Now, So this bit is not used.
=$0e					SPRITE_LUT7               = $0E ; Only 4 LUT for Now, So this bit is not used.
=$00					SPRITE_DEPTH0             = $00
=$10					SPRITE_DEPTH1             = $10
=$20					SPRITE_DEPTH2             = $20
=$30					SPRITE_DEPTH3             = $30
=$40					SPRITE_DEPTH4             = $40
=$50					SPRITE_DEPTH5             = $50
=$60					SPRITE_DEPTH6             = $60
=$af0c00				SP00_CONTROL_REG        = $AF0C00
=$af0c01				SP00_ADDY_PTR_L         = $AF0C01
=$af0c02				SP00_ADDY_PTR_M         = $AF0C02
=$af0c03				SP00_ADDY_PTR_H         = $AF0C03
=$af0c04				SP00_X_POS_L            = $AF0C04
=$af0c05				SP00_X_POS_H            = $AF0C05
=$af0c06				SP00_Y_POS_L            = $AF0C06
=$af0c07				SP00_Y_POS_H            = $AF0C07
=$af0c08				SP01_CONTROL_REG        = $AF0C08
=$af0c09				SP01_ADDY_PTR_L         = $AF0C09
=$af0c0a				SP01_ADDY_PTR_M         = $AF0C0A
=$af0c0b				SP01_ADDY_PTR_H         = $AF0C0B
=$af0c0c				SP01_X_POS_L            = $AF0C0C
=$af0c0d				SP01_X_POS_H            = $AF0C0D
=$af0c0e				SP01_Y_POS_L            = $AF0C0E
=$af0c0f				SP01_Y_POS_H            = $AF0C0F
=$af0c10				SP02_CONTROL_REG        = $AF0C10
=$af0c11				SP02_ADDY_PTR_L         = $AF0C11
=$af0c12				SP02_ADDY_PTR_M         = $AF0C12
=$af0c13				SP02_ADDY_PTR_H         = $AF0C13
=$af0c14				SP02_X_POS_L            = $AF0C14
=$af0c15				SP02_X_POS_H            = $AF0C15
=$af0c16				SP02_Y_POS_L            = $AF0C16
=$af0c17				SP02_Y_POS_H            = $AF0C17
=$af0c18				SP03_CONTROL_REG        = $AF0C18
=$af0c19				SP03_ADDY_PTR_L         = $AF0C19
=$af0c1a				SP03_ADDY_PTR_M         = $AF0C1A
=$af0c1b				SP03_ADDY_PTR_H         = $AF0C1B
=$af0c1c				SP03_X_POS_L            = $AF0C1C
=$af0c1d				SP03_X_POS_H            = $AF0C1D
=$af0c1e				SP03_Y_POS_L            = $AF0C1E
=$af0c1f				SP03_Y_POS_H            = $AF0C1F
=$af0c20				SP04_CONTROL_REG        = $AF0C20
=$af0c21				SP04_ADDY_PTR_L         = $AF0C21
=$af0c22				SP04_ADDY_PTR_M         = $AF0C22
=$af0c23				SP04_ADDY_PTR_H         = $AF0C23
=$af0c24				SP04_X_POS_L            = $AF0C24
=$af0c25				SP04_X_POS_H            = $AF0C25
=$af0c26				SP04_Y_POS_L            = $AF0C26
=$af0c27				SP04_Y_POS_H            = $AF0C27
=$af0c28				SP05_CONTROL_REG        = $AF0C28
=$af0c29				SP05_ADDY_PTR_L         = $AF0C29
=$af0c2a				SP05_ADDY_PTR_M         = $AF0C2A
=$af0c2b				SP05_ADDY_PTR_H         = $AF0C2B
=$af0c2c				SP05_X_POS_L            = $AF0C2C
=$af0c2d				SP05_X_POS_H            = $AF0C2D
=$af0c2e				SP05_Y_POS_L            = $AF0C2E
=$af0c2f				SP05_Y_POS_H            = $AF0C2F
=$af0c30				SP06_CONTROL_REG        = $AF0C30
=$af0c31				SP06_ADDY_PTR_L         = $AF0C31
=$af0c32				SP06_ADDY_PTR_M         = $AF0C32
=$af0c33				SP06_ADDY_PTR_H         = $AF0C33
=$af0c34				SP06_X_POS_L            = $AF0C34
=$af0c35				SP06_X_POS_H            = $AF0C35
=$af0c36				SP06_Y_POS_L            = $AF0C36
=$af0c37				SP06_Y_POS_H            = $AF0C37
=$af0c38				SP07_CONTROL_REG        = $AF0C38
=$af0c39				SP07_ADDY_PTR_L         = $AF0C39
=$af0c3a				SP07_ADDY_PTR_M         = $AF0C3A
=$af0c3b				SP07_ADDY_PTR_H         = $AF0C3B
=$af0c3c				SP07_X_POS_L            = $AF0C3C
=$af0c3d				SP07_X_POS_H            = $AF0C3D
=$af0c3e				SP07_Y_POS_L            = $AF0C3E
=$af0c3f				SP07_Y_POS_H            = $AF0C3F
=$af0c40				SP08_CONTROL_REG        = $AF0C40
=$af0c41				SP08_ADDY_PTR_L         = $AF0C41
=$af0c42				SP08_ADDY_PTR_M         = $AF0C42
=$af0c43				SP08_ADDY_PTR_H         = $AF0C43
=$af0c44				SP08_X_POS_L            = $AF0C44
=$af0c45				SP08_X_POS_H            = $AF0C45
=$af0c46				SP08_Y_POS_L            = $AF0C46
=$af0c47				SP08_Y_POS_H            = $AF0C47
=$af0c48				SP09_CONTROL_REG        = $AF0C48
=$af0c49				SP09_ADDY_PTR_L         = $AF0C49
=$af0c4a				SP09_ADDY_PTR_M         = $AF0C4A
=$af0c4b				SP09_ADDY_PTR_H         = $AF0C4B
=$af0c4c				SP09_X_POS_L            = $AF0C4C
=$af0c4d				SP09_X_POS_H            = $AF0C4D
=$af0c4e				SP09_Y_POS_L            = $AF0C4E
=$af0c4f				SP09_Y_POS_H            = $AF0C4F
=$af0c50				SP10_CONTROL_REG        = $AF0C50
=$af0c51				SP10_ADDY_PTR_L         = $AF0C51
=$af0c52				SP10_ADDY_PTR_M         = $AF0C52
=$af0c53				SP10_ADDY_PTR_H         = $AF0C53
=$af0c54				SP10_X_POS_L            = $AF0C54
=$af0c55				SP10_X_POS_H            = $AF0C55
=$af0c56				SP10_Y_POS_L            = $AF0C56
=$af0c57				SP10_Y_POS_H            = $AF0C57
=$af0c58				SP11_CONTROL_REG        = $AF0C58
=$af0c59				SP11_ADDY_PTR_L         = $AF0C59
=$af0c5a				SP11_ADDY_PTR_M         = $AF0C5A
=$af0c5b				SP11_ADDY_PTR_H         = $AF0C5B
=$af0c5c				SP11_X_POS_L            = $AF0C5C
=$af0c5d				SP11_X_POS_H            = $AF0C5D
=$af0c5e				SP11_Y_POS_L            = $AF0C5E
=$af0c5f				SP11_Y_POS_H            = $AF0C5F
=$af0c60				SP12_CONTROL_REG        = $AF0C60
=$af0c61				SP12_ADDY_PTR_L         = $AF0C61
=$af0c62				SP12_ADDY_PTR_M         = $AF0C62
=$af0c63				SP12_ADDY_PTR_H         = $AF0C63
=$af0c64				SP12_X_POS_L            = $AF0C64
=$af0c65				SP12_X_POS_H            = $AF0C65
=$af0c66				SP12_Y_POS_L            = $AF0C66
=$af0c67				SP12_Y_POS_H            = $AF0C67
=$af0c68				SP13_CONTROL_REG        = $AF0C68
=$af0c69				SP13_ADDY_PTR_L         = $AF0C69
=$af0c6a				SP13_ADDY_PTR_M         = $AF0C6A
=$af0c6b				SP13_ADDY_PTR_H         = $AF0C6B
=$af0c6c				SP13_X_POS_L            = $AF0C6C
=$af0c6d				SP13_X_POS_H            = $AF0C6D
=$af0c6e				SP13_Y_POS_L            = $AF0C6E
=$af0c6f				SP13_Y_POS_H            = $AF0C6F
=$af0c70				SP14_CONTROL_REG        = $AF0C70
=$af0c71				SP14_ADDY_PTR_L         = $AF0C71
=$af0c72				SP14_ADDY_PTR_M         = $AF0C72
=$af0c73				SP14_ADDY_PTR_H         = $AF0C73
=$af0c74				SP14_X_POS_L            = $AF0C74
=$af0c75				SP14_X_POS_H            = $AF0C75
=$af0c76				SP14_Y_POS_L            = $AF0C76
=$af0c77				SP14_Y_POS_H            = $AF0C77
=$af0c78				SP15_CONTROL_REG        = $AF0C78
=$af0c79				SP15_ADDY_PTR_L         = $AF0C79
=$af0c7a				SP15_ADDY_PTR_M         = $AF0C7A
=$af0c7b				SP15_ADDY_PTR_H         = $AF0C7B
=$af0c7c				SP15_X_POS_L            = $AF0C7C
=$af0c7d				SP15_X_POS_H            = $AF0C7D
=$af0c7e				SP15_Y_POS_L            = $AF0C7E
=$af0c7f				SP15_Y_POS_H            = $AF0C7F
=$af0c80				SP16_CONTROL_REG        = $AF0C80
=$af0c81				SP16_ADDY_PTR_L         = $AF0C81
=$af0c82				SP16_ADDY_PTR_M         = $AF0C82
=$af0c83				SP16_ADDY_PTR_H         = $AF0C83
=$af0c84				SP16_X_POS_L            = $AF0C84
=$af0c85				SP16_X_POS_H            = $AF0C85
=$af0c86				SP16_Y_POS_L            = $AF0C86
=$af0c87				SP16_Y_POS_H            = $AF0C87
=$af0c88				SP17_CONTROL_REG        = $AF0C88
=$af0c89				SP17_ADDY_PTR_L         = $AF0C89
=$af0c8a				SP17_ADDY_PTR_M         = $AF0C8A
=$af0c8b				SP17_ADDY_PTR_H         = $AF0C8B
=$af0c8c				SP17_X_POS_L            = $AF0C8C
=$af0c8d				SP17_X_POS_H            = $AF0C8D
=$af0c8e				SP17_Y_POS_L            = $AF0C8E
=$af0c8f				SP17_Y_POS_H            = $AF0C8F
=$af0c90				SP18_CONTROL_REG        = $AF0C90
=$af0c91				SP18_ADDY_PTR_L         = $AF0C91
=$af0c92				SP18_ADDY_PTR_M         = $AF0C92
=$af0c93				SP18_ADDY_PTR_H         = $AF0C93
=$af0c94				SP18_X_POS_L            = $AF0C94
=$af0c95				SP18_X_POS_H            = $AF0C95
=$af0c96				SP18_Y_POS_L            = $AF0C96
=$af0c97				SP18_Y_POS_H            = $AF0C97
=$af0c98				SP19_CONTROL_REG        = $AF0C98
=$af0c99				SP19_ADDY_PTR_L         = $AF0C99
=$af0c9a				SP19_ADDY_PTR_M         = $AF0C9A
=$af0c9b				SP19_ADDY_PTR_H         = $AF0C9B
=$af0c9c				SP19_X_POS_L            = $AF0C9C
=$af0c9d				SP19_X_POS_H            = $AF0C9D
=$af0c9e				SP19_Y_POS_L            = $AF0C9E
=$af0c9f				SP19_Y_POS_H            = $AF0C9F
=$af0ca0				SP20_CONTROL_REG        = $AF0CA0
=$af0ca1				SP20_ADDY_PTR_L         = $AF0CA1
=$af0ca2				SP20_ADDY_PTR_M         = $AF0CA2
=$af0ca3				SP20_ADDY_PTR_H         = $AF0CA3
=$af0ca4				SP20_X_POS_L            = $AF0CA4
=$af0ca5				SP20_X_POS_H            = $AF0CA5
=$af0ca6				SP20_Y_POS_L            = $AF0CA6
=$af0ca7				SP20_Y_POS_H            = $AF0CA7
=$af0ca8				SP21_CONTROL_REG        = $AF0CA8
=$af0ca9				SP21_ADDY_PTR_L         = $AF0CA9
=$af0caa				SP21_ADDY_PTR_M         = $AF0CAA
=$af0cab				SP21_ADDY_PTR_H         = $AF0CAB
=$af0cac				SP21_X_POS_L            = $AF0CAC
=$af0cad				SP21_X_POS_H            = $AF0CAD
=$af0cae				SP21_Y_POS_L            = $AF0CAE
=$af0caf				SP21_Y_POS_H            = $AF0CAF
=$af0cb0				SP22_CONTROL_REG        = $AF0CB0
=$af0cb1				SP22_ADDY_PTR_L         = $AF0CB1
=$af0cb2				SP22_ADDY_PTR_M         = $AF0CB2
=$af0cb3				SP22_ADDY_PTR_H         = $AF0CB3
=$af0cb4				SP22_X_POS_L            = $AF0CB4
=$af0cb5				SP22_X_POS_H            = $AF0CB5
=$af0cb6				SP22_Y_POS_L            = $AF0CB6
=$af0cb7				SP22_Y_POS_H            = $AF0CB7
=$af0cb8				SP23_CONTROL_REG        = $AF0CB8
=$af0cb9				SP23_ADDY_PTR_L         = $AF0CB9
=$af0cba				SP23_ADDY_PTR_M         = $AF0CBA
=$af0cbb				SP23_ADDY_PTR_H         = $AF0CBB
=$af0cbc				SP23_X_POS_L            = $AF0CBC
=$af0cbd				SP23_X_POS_H            = $AF0CBD
=$af0cbe				SP23_Y_POS_L            = $AF0CBE
=$af0cbf				SP23_Y_POS_H            = $AF0CBF
=$af0cc0				SP24_CONTROL_REG        = $AF0CC0
=$af0cc1				SP24_ADDY_PTR_L         = $AF0CC1
=$af0cc2				SP24_ADDY_PTR_M         = $AF0CC2
=$af0cc3				SP24_ADDY_PTR_H         = $AF0CC3
=$af0cc4				SP24_X_POS_L            = $AF0CC4
=$af0cc5				SP24_X_POS_H            = $AF0CC5
=$af0cc6				SP24_Y_POS_L            = $AF0CC6
=$af0cc7				SP24_Y_POS_H            = $AF0CC7
=$af0cc8				SP25_CONTROL_REG        = $AF0CC8
=$af0cc9				SP25_ADDY_PTR_L         = $AF0CC9
=$af0cca				SP25_ADDY_PTR_M         = $AF0CCA
=$af0ccb				SP25_ADDY_PTR_H         = $AF0CCB
=$af0ccc				SP25_X_POS_L            = $AF0CCC
=$af0ccd				SP25_X_POS_H            = $AF0CCD
=$af0cce				SP25_Y_POS_L            = $AF0CCE
=$af0ccf				SP25_Y_POS_H            = $AF0CCF
=$af0cd0				SP26_CONTROL_REG        = $AF0CD0
=$af0cd1				SP26_ADDY_PTR_L         = $AF0CD1
=$af0cd2				SP26_ADDY_PTR_M         = $AF0CD2
=$af0cd3				SP26_ADDY_PTR_H         = $AF0CD3
=$af0cd4				SP26_X_POS_L            = $AF0CD4
=$af0cd5				SP26_X_POS_H            = $AF0CD5
=$af0cd6				SP26_Y_POS_L            = $AF0CD6
=$af0cd7				SP26_Y_POS_H            = $AF0CD7
=$af0cd8				SP27_CONTROL_REG        = $AF0CD8
=$af0cd9				SP27_ADDY_PTR_L         = $AF0CD9
=$af0cda				SP27_ADDY_PTR_M         = $AF0CDA
=$af0cdb				SP27_ADDY_PTR_H         = $AF0CDB
=$af0cdc				SP27_X_POS_L            = $AF0CDC
=$af0cdd				SP27_X_POS_H            = $AF0CDD
=$af0cde				SP27_Y_POS_L            = $AF0CDE
=$af0cdf				SP27_Y_POS_H            = $AF0CDF
=$af0ce0				SP28_CONTROL_REG        = $AF0CE0
=$af0ce1				SP28_ADDY_PTR_L         = $AF0CE1
=$af0ce2				SP28_ADDY_PTR_M         = $AF0CE2
=$af0ce3				SP28_ADDY_PTR_H         = $AF0CE3
=$af0ce4				SP28_X_POS_L            = $AF0CE4
=$af0ce5				SP28_X_POS_H            = $AF0CE5
=$af0ce6				SP28_Y_POS_L            = $AF0CE6
=$af0ce7				SP28_Y_POS_H            = $AF0CE7
=$af0ce8				SP29_CONTROL_REG        = $AF0CE8
=$af0ce9				SP29_ADDY_PTR_L         = $AF0CE9
=$af0cea				SP29_ADDY_PTR_M         = $AF0CEA
=$af0ceb				SP29_ADDY_PTR_H         = $AF0CEB
=$af0cec				SP29_X_POS_L            = $AF0CEC
=$af0ced				SP29_X_POS_H            = $AF0CED
=$af0cee				SP29_Y_POS_L            = $AF0CEE
=$af0cef				SP29_Y_POS_H            = $AF0CEF
=$af0cf0				SP30_CONTROL_REG        = $AF0CF0
=$af0cf1				SP30_ADDY_PTR_L         = $AF0CF1
=$af0cf2				SP30_ADDY_PTR_M         = $AF0CF2
=$af0cf3				SP30_ADDY_PTR_H         = $AF0CF3
=$af0cf4				SP30_X_POS_L            = $AF0CF4
=$af0cf5				SP30_X_POS_H            = $AF0CF5
=$af0cf6				SP30_Y_POS_L            = $AF0CF6
=$af0cf7				SP30_Y_POS_H            = $AF0CF7
=$af0cf8				SP31_CONTROL_REG        = $AF0CF8
=$af0cf9				SP31_ADDY_PTR_L         = $AF0CF9
=$af0cfa				SP31_ADDY_PTR_M         = $AF0CFA
=$af0cfb				SP31_ADDY_PTR_H         = $AF0CFB
=$af0cfc				SP31_X_POS_L            = $AF0CFC
=$af0cfd				SP31_X_POS_H            = $AF0CFD
=$af0cfe				SP31_Y_POS_L            = $AF0CFE
=$af0cff				SP31_Y_POS_H            = $AF0CFF
=$af0d00				SP32_CONTROL_REG        = $AF0D00
=$af0d01				SP32_ADDY_PTR_L         = $AF0D01
=$af0d02				SP32_ADDY_PTR_M         = $AF0D02
=$af0d03				SP32_ADDY_PTR_H         = $AF0D03
=$af0d04				SP32_X_POS_L            = $AF0D04
=$af0d05				SP32_X_POS_H            = $AF0D05
=$af0d06				SP32_Y_POS_L            = $AF0D06
=$af0d07				SP32_Y_POS_H            = $AF0D07
=$af0d08				SP33_CONTROL_REG        = $AF0D08
=$af0d09				SP33_ADDY_PTR_L         = $AF0D09
=$af0d0a				SP33_ADDY_PTR_M         = $AF0D0A
=$af0d0b				SP33_ADDY_PTR_H         = $AF0D0B
=$af0d0c				SP33_X_POS_L            = $AF0D0C
=$af0d0d				SP33_X_POS_H            = $AF0D0D
=$af0d0e				SP33_Y_POS_L            = $AF0D0E
=$af0d0f				SP33_Y_POS_H            = $AF0D0F
=$af0d10				SP34_CONTROL_REG        = $AF0D10
=$af0d11				SP34_ADDY_PTR_L         = $AF0D11
=$af0d12				SP34_ADDY_PTR_M         = $AF0D12
=$af0d13				SP34_ADDY_PTR_H         = $AF0D13
=$af0d14				SP34_X_POS_L            = $AF0D14
=$af0d15				SP34_X_POS_H            = $AF0D15
=$af0d16				SP34_Y_POS_L            = $AF0D16
=$af0d17				SP34_Y_POS_H            = $AF0D17
=$af0d18				SP35_CONTROL_REG        = $AF0D18
=$af0d19				SP35_ADDY_PTR_L         = $AF0D19
=$af0d1a				SP35_ADDY_PTR_M         = $AF0D1A
=$af0d1b				SP35_ADDY_PTR_H         = $AF0D1B
=$af0d1c				SP35_X_POS_L            = $AF0D1C
=$af0d1d				SP35_X_POS_H            = $AF0D1D
=$af0d1e				SP35_Y_POS_L            = $AF0D1E
=$af0d1f				SP35_Y_POS_H            = $AF0D1F
=$af0d20				SP36_CONTROL_REG        = $AF0D20
=$af0d21				SP36_ADDY_PTR_L         = $AF0D21
=$af0d22				SP36_ADDY_PTR_M         = $AF0D22
=$af0d23				SP36_ADDY_PTR_H         = $AF0D23
=$af0d24				SP36_X_POS_L            = $AF0D24
=$af0d25				SP36_X_POS_H            = $AF0D25
=$af0d26				SP36_Y_POS_L            = $AF0D26
=$af0d27				SP36_Y_POS_H            = $AF0D27
=$af0d28				SP37_CONTROL_REG        = $AF0D28
=$af0d29				SP37_ADDY_PTR_L         = $AF0D29
=$af0d2a				SP37_ADDY_PTR_M         = $AF0D2A
=$af0d2b				SP37_ADDY_PTR_H         = $AF0D2B
=$af0d2c				SP37_X_POS_L            = $AF0D2C
=$af0d2d				SP37_X_POS_H            = $AF0D2D
=$af0d2e				SP37_Y_POS_L            = $AF0D2E
=$af0d2f				SP37_Y_POS_H            = $AF0D2F
=$af0d30				SP38_CONTROL_REG        = $AF0D30
=$af0d31				SP38_ADDY_PTR_L         = $AF0D31
=$af0d32				SP38_ADDY_PTR_M         = $AF0D32
=$af0d33				SP38_ADDY_PTR_H         = $AF0D33
=$af0d34				SP38_X_POS_L            = $AF0D34
=$af0d35				SP38_X_POS_H            = $AF0D35
=$af0d36				SP38_Y_POS_L            = $AF0D36
=$af0d37				SP38_Y_POS_H            = $AF0D37
=$af0d38				SP39_CONTROL_REG        = $AF0D38
=$af0d39				SP39_ADDY_PTR_L         = $AF0D39
=$af0d3a				SP39_ADDY_PTR_M         = $AF0D3A
=$af0d3b				SP39_ADDY_PTR_H         = $AF0D3B
=$af0d3c				SP39_X_POS_L            = $AF0D3C
=$af0d3d				SP39_X_POS_H            = $AF0D3D
=$af0d3e				SP39_Y_POS_L            = $AF0D3E
=$af0d3f				SP39_Y_POS_H            = $AF0D3F
=$af0d40				SP40_CONTROL_REG        = $AF0D40
=$af0d41				SP40_ADDY_PTR_L         = $AF0D41
=$af0d42				SP40_ADDY_PTR_M         = $AF0D42
=$af0d43				SP40_ADDY_PTR_H         = $AF0D43
=$af0d44				SP40_X_POS_L            = $AF0D44
=$af0d45				SP40_X_POS_H            = $AF0D45
=$af0d46				SP40_Y_POS_L            = $AF0D46
=$af0d47				SP40_Y_POS_H            = $AF0D47
=$af0d48				SP41_CONTROL_REG        = $AF0D48
=$af0d49				SP41_ADDY_PTR_L         = $AF0D49
=$af0d4a				SP41_ADDY_PTR_M         = $AF0D4A
=$af0d4b				SP41_ADDY_PTR_H         = $AF0D4B
=$af0d4c				SP41_X_POS_L            = $AF0D4C
=$af0d4d				SP41_X_POS_H            = $AF0D4D
=$af0d4e				SP41_Y_POS_L            = $AF0D4E
=$af0d4f				SP41_Y_POS_H            = $AF0D4F
=$af0d50				SP42_CONTROL_REG        = $AF0D50
=$af0d51				SP42_ADDY_PTR_L         = $AF0D51
=$af0d52				SP42_ADDY_PTR_M         = $AF0D52
=$af0d53				SP42_ADDY_PTR_H         = $AF0D53
=$af0d54				SP42_X_POS_L            = $AF0D54
=$af0d55				SP42_X_POS_H            = $AF0D55
=$af0d56				SP42_Y_POS_L            = $AF0D56
=$af0d57				SP42_Y_POS_H            = $AF0D57
=$af0d58				SP43_CONTROL_REG        = $AF0D58
=$af0d59				SP43_ADDY_PTR_L         = $AF0D59
=$af0d5a				SP43_ADDY_PTR_M         = $AF0D5A
=$af0d5b				SP43_ADDY_PTR_H         = $AF0D5B
=$af0d5c				SP43_X_POS_L            = $AF0D5C
=$af0d5d				SP43_X_POS_H            = $AF0D5D
=$af0d5e				SP43_Y_POS_L            = $AF0D5E
=$af0d5f				SP43_Y_POS_H            = $AF0D5F
=$af0d60				SP44_CONTROL_REG        = $AF0D60
=$af0d61				SP44_ADDY_PTR_L         = $AF0D61
=$af0d62				SP44_ADDY_PTR_M         = $AF0D62
=$af0d63				SP44_ADDY_PTR_H         = $AF0D63
=$af0d64				SP44_X_POS_L            = $AF0D64
=$af0d65				SP44_X_POS_H            = $AF0D65
=$af0d66				SP44_Y_POS_L            = $AF0D66
=$af0d67				SP44_Y_POS_H            = $AF0D67
=$af0d68				SP45_CONTROL_REG        = $AF0D68
=$af0d69				SP45_ADDY_PTR_L         = $AF0D69
=$af0d6a				SP45_ADDY_PTR_M         = $AF0D6A
=$af0d6b				SP45_ADDY_PTR_H         = $AF0D6B
=$af0d6c				SP45_X_POS_L            = $AF0D6C
=$af0d6d				SP45_X_POS_H            = $AF0D6D
=$af0d6e				SP45_Y_POS_L            = $AF0D6E
=$af0d6f				SP45_Y_POS_H            = $AF0D6F
=$af0d70				SP46_CONTROL_REG        = $AF0D70
=$af0d71				SP46_ADDY_PTR_L         = $AF0D71
=$af0d72				SP46_ADDY_PTR_M         = $AF0D72
=$af0d73				SP46_ADDY_PTR_H         = $AF0D73
=$af0d74				SP46_X_POS_L            = $AF0D74
=$af0d75				SP46_X_POS_H            = $AF0D75
=$af0d76				SP46_Y_POS_L            = $AF0D76
=$af0d77				SP46_Y_POS_H            = $AF0D77
=$af0d78				SP47_CONTROL_REG        = $AF0D78
=$af0d79				SP47_ADDY_PTR_L         = $AF0D79
=$af0d7a				SP47_ADDY_PTR_M         = $AF0D7A
=$af0d7b				SP47_ADDY_PTR_H         = $AF0D7B
=$af0d7c				SP47_X_POS_L            = $AF0D7C
=$af0d7d				SP47_X_POS_H            = $AF0D7D
=$af0d7e				SP47_Y_POS_L            = $AF0D7E
=$af0d7f				SP47_Y_POS_H            = $AF0D7F
=$af0d80				SP48_CONTROL_REG        = $AF0D80
=$af0d81				SP48_ADDY_PTR_L         = $AF0D81
=$af0d82				SP48_ADDY_PTR_M         = $AF0D82
=$af0d83				SP48_ADDY_PTR_H         = $AF0D83
=$af0d84				SP48_X_POS_L            = $AF0D84
=$af0d85				SP48_X_POS_H            = $AF0D85
=$af0d86				SP48_Y_POS_L            = $AF0D86
=$af0d87				SP48_Y_POS_H            = $AF0D87
=$af0d88				SP49_CONTROL_REG        = $AF0D88
=$af0d89				SP49_ADDY_PTR_L         = $AF0D89
=$af0d8a				SP49_ADDY_PTR_M         = $AF0D8A
=$af0d8b				SP49_ADDY_PTR_H         = $AF0D8B
=$af0d8c				SP49_X_POS_L            = $AF0D8C
=$af0d8d				SP49_X_POS_H            = $AF0D8D
=$af0d8e				SP49_Y_POS_L            = $AF0D8E
=$af0d8f				SP49_Y_POS_H            = $AF0D8F
=$af0d90				SP50_CONTROL_REG        = $AF0D90
=$af0d91				SP50_ADDY_PTR_L         = $AF0D91
=$af0d92				SP50_ADDY_PTR_M         = $AF0D92
=$af0d93				SP50_ADDY_PTR_H         = $AF0D93
=$af0d94				SP50_X_POS_L            = $AF0D94
=$af0d95				SP50_X_POS_H            = $AF0D95
=$af0d96				SP50_Y_POS_L            = $AF0D96
=$af0d97				SP50_Y_POS_H            = $AF0D97
=$af0d98				SP51_CONTROL_REG        = $AF0D98
=$af0d99				SP51_ADDY_PTR_L         = $AF0D99
=$af0d9a				SP51_ADDY_PTR_M         = $AF0D9A
=$af0d9b				SP51_ADDY_PTR_H         = $AF0D9B
=$af0d9c				SP51_X_POS_L            = $AF0D9C
=$af0d9d				SP51_X_POS_H            = $AF0D9D
=$af0d9e				SP51_Y_POS_L            = $AF0D9E
=$af0d9f				SP51_Y_POS_H            = $AF0D9F
=$af0da0				SP52_CONTROL_REG        = $AF0DA0
=$af0da1				SP52_ADDY_PTR_L         = $AF0DA1
=$af0da2				SP52_ADDY_PTR_M         = $AF0DA2
=$af0da3				SP52_ADDY_PTR_H         = $AF0DA3
=$af0da4				SP52_X_POS_L            = $AF0DA4
=$af0da5				SP52_X_POS_H            = $AF0DA5
=$af0da6				SP52_Y_POS_L            = $AF0DA6
=$af0da7				SP52_Y_POS_H            = $AF0DA7
=$af0da8				SP53_CONTROL_REG        = $AF0DA8
=$af0da9				SP53_ADDY_PTR_L         = $AF0DA9
=$af0daa				SP53_ADDY_PTR_M         = $AF0DAA
=$af0dab				SP53_ADDY_PTR_H         = $AF0DAB
=$af0dac				SP53_X_POS_L            = $AF0DAC
=$af0dad				SP53_X_POS_H            = $AF0DAD
=$af0dae				SP53_Y_POS_L            = $AF0DAE
=$af0daf				SP53_Y_POS_H            = $AF0DAF
=$af0db0				SP54_CONTROL_REG        = $AF0DB0
=$af0db1				SP54_ADDY_PTR_L         = $AF0DB1
=$af0db2				SP54_ADDY_PTR_M         = $AF0DB2
=$af0db3				SP54_ADDY_PTR_H         = $AF0DB3
=$af0db4				SP54_X_POS_L            = $AF0DB4
=$af0db5				SP54_X_POS_H            = $AF0DB5
=$af0db6				SP54_Y_POS_L            = $AF0DB6
=$af0db7				SP54_Y_POS_H            = $AF0DB7
=$af0db8				SP55_CONTROL_REG        = $AF0DB8
=$af0db9				SP55_ADDY_PTR_L         = $AF0DB9
=$af0dba				SP55_ADDY_PTR_M         = $AF0DBA
=$af0dbb				SP55_ADDY_PTR_H         = $AF0DBB
=$af0dbc				SP55_X_POS_L            = $AF0DBC
=$af0dbd				SP55_X_POS_H            = $AF0DBD
=$af0dbe				SP55_Y_POS_L            = $AF0DBE
=$af0dbf				SP55_Y_POS_H            = $AF0DBF
=$af0dc0				SP56_CONTROL_REG        = $AF0DC0
=$af0dc1				SP56_ADDY_PTR_L         = $AF0DC1
=$af0dc2				SP56_ADDY_PTR_M         = $AF0DC2
=$af0dc3				SP56_ADDY_PTR_H         = $AF0DC3
=$af0dc4				SP56_X_POS_L            = $AF0DC4
=$af0dc5				SP56_X_POS_H            = $AF0DC5
=$af0dc6				SP56_Y_POS_L            = $AF0DC6
=$af0dc7				SP56_Y_POS_H            = $AF0DC7
=$af0dc8				SP57_CONTROL_REG        = $AF0DC8
=$af0dc9				SP57_ADDY_PTR_L         = $AF0DC9
=$af0dca				SP57_ADDY_PTR_M         = $AF0DCA
=$af0dcb				SP57_ADDY_PTR_H         = $AF0DCB
=$af0dcc				SP57_X_POS_L            = $AF0DCC
=$af0dcd				SP57_X_POS_H            = $AF0DCD
=$af0dce				SP57_Y_POS_L            = $AF0DCE
=$af0dcf				SP57_Y_POS_H            = $AF0DCF
=$af0dd0				SP58_CONTROL_REG        = $AF0DD0
=$af0dd1				SP58_ADDY_PTR_L         = $AF0DD1
=$af0dd2				SP58_ADDY_PTR_M         = $AF0DD2
=$af0dd3				SP58_ADDY_PTR_H         = $AF0DD3
=$af0dd4				SP58_X_POS_L            = $AF0DD4
=$af0dd5				SP58_X_POS_H            = $AF0DD5
=$af0dd6				SP58_Y_POS_L            = $AF0DD6
=$af0dd7				SP58_Y_POS_H            = $AF0DD7
=$af0dd8				SP59_CONTROL_REG        = $AF0DD8
=$af0dd9				SP59_ADDY_PTR_L         = $AF0DD9
=$af0dda				SP59_ADDY_PTR_M         = $AF0DDA
=$af0ddb				SP59_ADDY_PTR_H         = $AF0DDB
=$af0ddc				SP59_X_POS_L            = $AF0DDC
=$af0ddd				SP59_X_POS_H            = $AF0DDD
=$af0dde				SP59_Y_POS_L            = $AF0DDE
=$af0ddf				SP59_Y_POS_H            = $AF0DDF
=$af0de0				SP60_CONTROL_REG        = $AF0DE0
=$af0de1				SP60_ADDY_PTR_L         = $AF0DE1
=$af0de2				SP60_ADDY_PTR_M         = $AF0DE2
=$af0de3				SP60_ADDY_PTR_H         = $AF0DE3
=$af0de4				SP60_X_POS_L            = $AF0DE4
=$af0de5				SP60_X_POS_H            = $AF0DE5
=$af0de6				SP60_Y_POS_L            = $AF0DE6
=$af0de7				SP60_Y_POS_H            = $AF0DE7
=$af0de8				SP61_CONTROL_REG        = $AF0DE8
=$af0de9				SP61_ADDY_PTR_L         = $AF0DE9
=$af0dea				SP61_ADDY_PTR_M         = $AF0DEA
=$af0deb				SP61_ADDY_PTR_H         = $AF0DEB
=$af0dec				SP61_X_POS_L            = $AF0DEC
=$af0ded				SP61_X_POS_H            = $AF0DED
=$af0dee				SP61_Y_POS_L            = $AF0DEE
=$af0def				SP61_Y_POS_H            = $AF0DEF
=$af0df0				SP62_CONTROL_REG        = $AF0DF0
=$af0df1				SP62_ADDY_PTR_L         = $AF0DF1
=$af0df2				SP62_ADDY_PTR_M         = $AF0DF2
=$af0df3				SP62_ADDY_PTR_H         = $AF0DF3
=$af0df4				SP62_X_POS_L            = $AF0DF4
=$af0df5				SP62_X_POS_H            = $AF0DF5
=$af0df6				SP62_Y_POS_L            = $AF0DF6
=$af0df7				SP62_Y_POS_H            = $AF0DF7
=$af0df8				SP63_CONTROL_REG        = $AF0DF8
=$af0df9				SP63_ADDY_PTR_L         = $AF0DF9
=$af0dfa				SP63_ADDY_PTR_M         = $AF0DFA
=$af0dfb				SP63_ADDY_PTR_H         = $AF0DFB
=$af0dfc				SP63_X_POS_L            = $AF0DFC
=$af0dfd				SP63_X_POS_H            = $AF0DFD
=$af0dfe				SP63_Y_POS_L            = $AF0DFE
=$af0dff				SP63_Y_POS_H            = $AF0DFF

;******  Return to file: src\C256/vicky_def.s


;******  Return to file: src\C256/mmap_c256.s

=$00					BASIC_BANK = $00            ; Memory bank for default purposes
=$004c00				IOBUF = $004C00             ; A buffer for I/O operations
=$004d00				ARRIDXBUF = $004D00         ; The array index buffer used for array references
=$004e00				TEMPBUF = $004E00           ; Temporary buffer for string processing, etc.
=$004f00				INPUTBUF = $004F00          ; Starting address of the line input buffer (one page)
=$005000				RETURN_BOT = $005000        ; Starting address of the return stack
=$005fff				RETURN_TOP = $005FFF        ; Ending address of the return stack
=$006000				ARGUMENT_BOT = $006000      ; Starting address of the argument stack
=$006fff				ARGUMENT_TOP = $006FFF      ; Ending address of the argument stack
=$007000				OPERATOR_BOT = $007000      ; Starting address of the operator stack
=$007fff				OPERATOR_TOP = $007FFF      ; Ending address of the operator stack
=$b00000				VRAM = $B00000              ; Start of video RAM
=$010000				LOADBLOCK = $010000         ; File loading will start here
=$360000				BASIC_BOT := $360000         ; Starting point for BASIC programs
=$37ffff				HEAP_TOP := $37FFFF          ; Starting point of the heap
=$160000				BASIC_BOT := $160000         ; Starting point for BASIC programs
=$17ffff				HEAP_TOP := $17FFFF          ; Starting point of the heap

;******  Return to file: src\memorymap.s

=$00ffe6				VBRK = $00FFE6          ; Vector for the native-mode BRK vector
=$1ad000				DATA_BLOCK = *
=$000800				GLOBAL_VARS = *
>0800					BIP         .dword ?    ; Pointer to the current byte in the current BASIC program
>0804					BIPPREV     .dword ?    ; Pointer to the previous bytein the current BASIC program
>0808					INDEX       .dword ?    ; A temporary pointer
>080c					SCRATCH     .dword ?    ; A temporary scratch variable
>0810					SCRATCH2    .dword ?    ; A temporary scratch variable
>0814					            .word  ?	; Need a few more bits for BCD conversion
>0816					STRPTR      .dword ?    ; A temporary pointer for strings
>081a					CURLINE     .dword ?    ; Pointer to the current input line needing tokenization
>081e					CURTOKLEN   .byte ?     ; Length of the text of the current token
>081f					ARGUMENTSP  .word ?     ; Pointer to the top of the argument stack
>0821					OPERATORSP  .word ?     ; Pointer to the top of the operator stack
>0823					ARGUMENT1   .dword ?    ; Argument 1 for expression calculations
>0827					ARGTYPE1    .byte ?     ; Type code for argument 1 (integer, float, string)
>0828					SIGN1       .byte ?     ; Temporary sign marker for argument 1
>0829					ARGUMENT2   .dword ?    ; Argument 2 for expression calculations
>082d					ARGTYPE2    .byte ?     ; Type code for argument 2 (integer, float, string)
>082e					SIGN2       .byte ?     ; Temporary sign marker for argument 1
>082f					JMP16PTR    .word ?     ; Pointer for 16-bit indirect jumps (within BASIC816's code base)
>0831					GOSUBDEPTH  .word ?     ; Number of GOSUBs on the stack
>0833					RETURNSP    .word ?     ; Pointer to the top of the return stack
>0835					SKIPNEST    .byte ?     ; Flag to indicate if token seeking should respect nesting (MSB set if so)
>0836					NESTING     .byte ?     ; Counter of the depth of lexical nesting for FOR/NEXT, DO/LOOP
>0837					TARGETTOK   .byte ?     ; When searching for a token, TARGETTOK is the token to find
>0838					DATABIP     .dword ?    ; Pointer to the next data element for READ statements
>083c					DATALINE    .dword ?    ; Pointer to the current line for a DATA statement
>0840					SAVEBIP     .dword ?    ; Spot to save BIP temporarily
>0844					SAVELINE    .dword ?    ; Spot to save CURLINE temporarily
=$000848				MONITOR_VARS = *
>0848					MCMDADDR    .long ?     ;3 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
>084b					MCMP_TEXT   .long ?     ;3 Bytes Address of symbol being evaluated for COMPARE routine
>084e					MCMP_LEN    .word ?     ;2 Bytes Length of symbol being evaluated for COMPARE routine
>0850					MCMD        .long ?     ;3 Bytes Address of the current command/function string
>0853					MCMD_LEN    .word ?     ;2 Bytes Length of the current command/function string
>0855					MARG1       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command
>0859					MARG2       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>085d					MARG3       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0861					MARG4       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0865					MARG5       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0869					MARG6       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>086d					MARG7       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0871					MARG8       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0875					MARG9       .dword ?    ;4 Bytes First command argument.
>0879					MARG_LEN    .byte ?     ;1 Byte count of the number of arguments passed
>087a					MCURSOR     .dword ?    ;4 Bytes Pointer to the current memory location for disassembly, memory dump, etc.
>087e					MLINEBUF    .fill 17    ;17 Byte buffer for dumping memory (TODO: could be moved to a general string scratch area)
>088f					MCOUNT      .long ?     ;2 Byte counter
>0892					MTEMP       .dword ?    ;4 Bytes of temporary space
>0896					MCPUSTAT    .byte ?     ;1 Byte to represent what the disassembler thinks the processor MX bits are
>0897					MADDR_MODE  .byte ?     ;1 Byte address mode found by the assembler
>0898					MPARSEDNUM  .dword ?    ;4 Bytes to store a parsed number
>089c					MMNEMONIC   .word ?     ;2 Byte address of mnemonic found by the assembler
>089e					MTEMPPTR    .dword ?    ;4 Byte temporary pointer
>08a2					MJUMPINST   .byte ?     ;1 Byte JSL opcode
>08a3					MJUMPADDR   .long ?     ;3 Byte address for JSL
=$000823				MANTISSA1 = ARGUMENT1
=$000826				EXPONENT1 = ARGUMENT1+3

;******  Return to file: src\basic816.s


;******  Processing file: src\macros.s


;******  Return to file: src\basic816.s

.1a0000	5c fe 87 1a	jmp $1a87fe	COLDBOOT        JML START               ; Entry point to boot up BASIC from scratch
.1a0004	5c 0d 6e 1a	jmp $1a6e0d	MONITOR         JML IMONITOR            ; Entry point to the machine language monitor
.1a0008	5c ef 25 1a	jmp $1a25ef	READLINE        JML IREADLINE           ; Wait for the user to enter a line of text (for programming input)
.1a000c	5c 94 01 1a	jmp $1a0194	SCRCOPYLINE     JML ISCRCPYLINE         ; Copy the line on the screen the user just input to INPUTBUF
.1a0010	5c 58 00 1a	jmp $1a0058	INPUTLINE       JML IINPUTLINE          ; Read a single line of text from the user, and copy it to TEMPBUF (for INPUT statement)
.1a0014	5c d6 00 1a	jmp $1a00d6	GETKEY          JML IGETKEY             ; Wait for a keypress by the user and return the ASCII code in A
.1a0018	5c fa 02 1a	jmp $1a02fa	PRINTC          JML IPRINTC             ; Print the character in A to the console
.1a001c	5c 38 01 1a	jmp $1a0138	SHOWCURSOR      JML ISHOWCURSOR         ; Set cursor visibility: A=0, hide... A<>0, show.
.1a0020	5c 53 01 1a	jmp $1a0153	CURSORXY        JML ICURSORXY           ; Set the position of the cursor to (X, Y)
.1a0024	5c 5a 01 1a	jmp $1a015a	CLSCREEN        JML ICLSCREEN           ; Clear the screen

;******  Processing file: src\bios.s


;******  Processing file: src\membuffers.s

>08a6					OBUFFER     .long ?     ; Pointer to the current text memory buffer for output
>08a9					OBUFFSIZE   .word ?     ; Maximum size of output text memory buffer
>08ab					OBUFFIDX    .word ?     ; Index into the current output buffer
>08ad					IBUFFER     .long ?     ; Pointer to the current text memory buffer for input
>08b0					IBUFFSIZE   .word ?     ; Number of bytes written to the buffer
>08b2					IBUFFIDX    .word ?     ; Index into the current input buffer (next available character)
.1a0028					OBUFF_PUTC
.1a0028	0b		phd		                PHD
.1a0029	08		php		                PHP
.1a002a	08		php		            PHP
.1a002b	c2 20		rep #$20	            REP #$20
.1a002d	48		pha		            PHA
.1a002e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0031	5b		tcd		            TCD
.1a0032	68		pla		            PLA
.1a0033	28		plp		            PLP
.1a0034	e2 20		sep #$20	            SEP #$20
.1a0036	85 b5		sta $08b5	                STA SAVE_A
.1a0038	c2 20		rep #$20	            REP #$20
.1a003a	a5 a6		lda $08a6	                LDA OBUFFER
.1a003c	d0 06		bne $1a0044	                BNE has_buffer
.1a003e	e2 20		sep #$20	            SEP #$20
.1a0040	a5 a8		lda $08a8	                LDA OBUFFER+2
.1a0042	f0 11		beq $1a0055	                BEQ done
.1a0044					has_buffer
.1a0044	c2 10		rep #$10	            REP #$10
.1a0046	a4 ab		ldy $08ab	                LDY OBUFFIDX        ; Check to make sure there is room
.1a0048	c4 a9		cpy $08a9	                CPY OBUFFSIZE
.1a004a	f0 09		beq $1a0055	                BEQ done            ; If not, exit silently
.1a004c	e2 20		sep #$20	            SEP #$20
.1a004e	a5 b5		lda $08b5	                LDA SAVE_A
.1a0050	97 a6		sta [$08a6],y	                STA [OBUFFER],Y     ; Write the character to the buffer
.1a0052	c8		iny		                INY                 ; Increment the index
.1a0053	84 ab		sty $08ab	                STY OBUFFIDX
.1a0055	28		plp		done            PLP
.1a0056	2b		pld		                PLD
.1a0057	60		rts		            RTS

;******  Return to file: src\bios.s


;******  Processing file: src\C256/io_c256.s


;******  Processing file: src\C256/kernel_c256.s

=$00104c				FK_GETCHW           = $00104c ; Get a character from the input channel. Waits until data received. A=0 and Carry=1 if no data is wating
=$001018				FK_PUTC             = $001018 ; Print a character to the currently selected channel
=$00101c				FK_PUTS             = $00101C ; Print a string to the currently selected channel
=$001080				FK_PRINTAH          = $001080 ; Prints hex value in A. Printed value is 2 wide if M flag is 1, 4 wide if M=0
=$001084				FK_LOCATE           = $001084 ; Reposition the cursor to row Y column X
=$001078				FK_IPRINTH          = $001078 ; Print a HEX string
=$00103c				FK_SETOUT           = $00103c ; Select an output channel
=$00112c				FK_SETSIZES         = $00112C ; Set the text screen size variables based on the border and screen resolution.
=$0010f0				FK_OPEN             = $0010F0 ; open a file for reading/writing/creating
=$0010f4				FK_CREATE           = $0010F4 ; create a new file
=$0010f8				FK_CLOSE            = $0010F8 ; close a file (make sure last cluster is written)
=$0010fc				FK_WRITE            = $0010FC ; write the current cluster to the file
=$001100				FK_READ             = $001100 ; read the next cluster from the file
=$001104				FK_DELETE           = $001104 ; delete a file / directory
=$001108				FK_DIROPEN          = $001108 ; open a directory and seek the first directory entry
=$00110c				FK_DIRNEXT          = $00110C ; seek to the next directory of an open directory
=$001110				FK_DIRREAD          = $001110 ; Read the directory entry for the specified file
=$001114				FK_DIRWRITE         = $001114 ; Write any changes in the current directory cluster back to the drive
=$001118				FK_LOAD             = $001118 ; load a binary file into memory, supports multiple file formats
=$00111c				FK_SAVE             = $00111C ; Save memory to a binary file
=$001124				FK_RUN              = $001124 ; Load and run an executable binary file
=$001130				FK_COPY             = $001130 ; Copy a file
=$001120				FK_CMDBLOCK         = $001120 ; Send a command to a block device
=0					CHAN_CONSOLE = 0
=1					CHAN_COM1 = 1
=2					CHAN_COM2 = 2

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/RTC_inc.s

=$af0800				RTC_SEC       = $AF0800 ;Seconds Register
=$af0801				RTC_SEC_ALARM = $AF0801 ;Seconds Alarm Register
=$af0802				RTC_MIN       = $AF0802 ;Minutes Register
=$af0803				RTC_MIN_ALARM = $AF0803 ;Minutes Alarm Register
=$af0804				RTC_HRS       = $AF0804 ;Hours Register
=$af0805				RTC_HRS_ALARM = $AF0805 ;Hours Alarm Register
=$af0806				RTC_DAY       = $AF0806 ;Day Register
=$af0807				RTC_DAY_ALARM = $AF0807 ;Day Alarm Register
=$af0808				RTC_DOW       = $AF0808 ;Day of Week Register
=$af0809				RTC_MONTH     = $AF0809 ;Month Register
=$af080a				RTC_YEAR      = $AF080A ;Year Register
=$af080b				RTC_RATES     = $AF080B ;Rates Register
=$af080c				RTC_ENABLE    = $AF080C ;Enables Register
=$af080d				RTC_FLAGS     = $AF080D ;Flags Register
=$af080e				RTC_CTRL      = $AF080E ;Control Register
=$af080f				RTC_CENTURY   = $AF080F ;Century Register

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/keyboard.s


;******  Processing file: src\C256/keyboard_def.s

=$af1064				STATUS_PORT 	        =	$AF1064
=$af1060				KBD_OUT_BUF 	        =	$AF1060
=$af1060				KBD_INPT_BUF	        = $AF1060
=$af1064				KBD_CMD_BUF		        = $AF1064
=$af1060				KBD_DATA_BUF	        = $AF1060
=$af1060				PORT_A			          =	$AF1060
=$af1061				PORT_B			          =	$AF1061
=$01					OUT_BUF_FULL  =	$01
=$02					INPT_BUF_FULL	=	$02
=$04					SYS_FLAG		  =	$04
=$08					CMD_DATA		  =	$08
=$10					KEYBD_INH     =	$10
=$20					TRANS_TMOUT	  =	$20
=$40					RCV_TMOUT		  =	$40
=$80					PARITY_EVEN		=	$80
=$10					INH_KEYBOARD	=	$10
=$ae					KBD_ENA			  =	$AE
=$ad					KBD_DIS			  =	$AD
=$f1					KB_MENU			  =	$F1
=$f4					KB_ENABLE		  =	$F4
=$f7					KB_MAKEBREAK  =	$F7
=$fe					KB_ECHO			  =	$FE
=$ff					KB_RESET		  =	$FF
=$ed					KB_LED_CMD		=	$ED
=$aa					KB_OK			    =	$AA
=$fa					KB_ACK			  =	$FA
=$ff					KB_OVERRUN		=	$FF
=$fe					KB_RESEND		  =	$FE
=$f0					KB_BREAK		  =	$F0
=$10					KB_FA			    =	$10
=$20					KB_FE			    =	$20
=$40					KB_PR_LED		  =	$40
=$01					KB_SCROLL_LOCK      = $01
=$02					KB_NUM_LOCK         = $02
=$04					KB_CAPS_LOCK        = $04

;******  Return to file: src\C256/keyboard.s

.1a0058					IINPUTLINE
.1a0058	08		php		                PHP
.1a0059	c2 10		rep #$10	            REP #$10
.1a005b	e2 20		sep #$20	            SEP #$20
.1a005d	a9 01		lda #$01	                LDA #1              ; Show the cursor
.1a005f	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a0062	a2 00 00	ldx #$0000	                LDX #0
.1a0065	a9 00		lda #$00	                LDA #0
.1a0067	9f 00 4c 00	sta $004c00,x	zero_loop       STA @lIOBUF,X
.1a006b	e8		inx		                INX
.1a006c	e0 00 01	cpx #$0100	                CPX #$100
.1a006f	d0 f6		bne $1a0067	                BNE zero_loop
.1a0071	a2 00 00	ldx #$0000	                LDX #0
.1a0074					getchar
.1a0074	20 14 00	jsr $1a0014	            JSR GETKEY
.1a0077	c9 0d		cmp #$0d	                CMP #CHAR_CR        ; Got a CR?
.1a0079	d0 03		bne $1a007e	                BNE not_cr
.1a007b	4c cf 00	jmp $1a00cf	                JMP endofline       ; Yes: we're done
.1a007e	c9 9d		cmp #$9d	not_cr          CMP #K_LEFT         ; Is it the left cursor?
.1a0080	d0 08		bne $1a008a	                BNE not_left
.1a0082	e0 00 00	cpx #$0000	                CPX #0              ; Are we all the way to the left?
.1a0085	f0 ed		beq $1a0074	                BEQ getchar         ; Yes: ignore it
.1a0087	ca		dex		                DEX                 ; Move the cursor back
.1a0088	80 39		bra $1a00c3	                BRA echo            ; And echo it
.1a008a	c9 1d		cmp #$1d	not_left        CMP #K_RIGHT        ; Is it the right arrow?
.1a008c	d0 0e		bne $1a009c	                BNE not_right
.1a008e	bf 00 4c 00	lda $004c00,x	                LDA @lIOBUF,X       ; Check the current character
.1a0092	f0 e0		beq $1a0074	                BEQ getchar         ; If it's already blank, we're as far right as we go
.1a0094	e0 4f 00	cpx #$004f	                CPX #79             ; Are we at the end of the line?
.1a0097	f0 db		beq $1a0074	                BEQ getchar         ; Yes: ignore it
.1a0099	e8		inx		                INX                 ; Otherwise: advance the cursor
.1a009a	80 27		bra $1a00c3	                BRA echo            ; And print the code
.1a009c	c9 08		cmp #$08	not_right       CMP #CHAR_BS        ; Is it a backspace?
.1a009e	d0 1a		bne $1a00ba	                BNE not_bs
.1a00a0	e0 00 00	cpx #$0000	                CPX #0              ; Are we at the beginning of the line?
.1a00a3	f0 cf		beq $1a0074	                BEQ getchar         ; yes: ignore the backspace
.1a00a5	da		phx		                PHX                 ; Save the cursor position
.1a00a6	bf 01 4c 00	lda $004c01,x	clr_loop        LDA @lIOBUF+1,X     ; Get the character above
.1a00aa	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the current position
.1a00ae	f0 06		beq $1a00b6	                BEQ done_clr        ; If we copied a NUL, we're done copying
.1a00b0	e8		inx		                INX                 ; Otherwise, keep copying down
.1a00b1	e0 ff 00	cpx #$00ff	                CPX #$FF            ; Until we're at the end of the buffer
.1a00b4	d0 f0		bne $1a00a6	                BNE clr_loop
.1a00b6	fa		plx		done_clr        PLX                 ; Restore the cursor position
.1a00b7	ca		dex		                DEX                 ; No: move the cursor left
.1a00b8	80 0e		bra $1a00c8	                BRA print_bs        ; And print the backspace
.1a00ba	c9 20		cmp #$20	not_bs          CMP #$20            ; Is it in range 00 -- 1F?
.1a00bc	90 b6		bcc $1a0074	                BLT getchar         ; Yes: ignore it
.1a00be	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the input buffer
.1a00c2	e8		inx		                INX                 ; Move the cursor forward
.1a00c3					echo
.1a00c3	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00c6	80 ac		bra $1a0074	                BRA getchar         ; And get another...
.1a00c8	a9 08		lda #$08	print_bs        LDA #CHAR_BS        ; Backspace character...
.1a00ca	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00cd	80 a5		bra $1a0074	                BRA getchar         ; And get another...
.1a00cf	a9 00		lda #$00	endofline       LDA #0              ; Hide the cursor
.1a00d1	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a00d4	28		plp		                PLP
.1a00d5	60		rts		            RTS
.1a00d6					IGETKEY
.1a00d6	22 4c 10 00	jsl $00104c	                JSL FK_GETCHW
.1a00da	60		rts		            RTS
.1a00db					GETKEYE
.1a00db	08		php		                PHP
.1a00dc	e2 20		sep #$20	            SEP #$20
.1a00de					loop
.1a00de	20 14 00	jsr $1a0014	            JSR GETKEY
.1a00e1	c9 11		cmp #$11	                CMP #K_UP
.1a00e3	f0 17		beq $1a00fc	                BEQ csr_up
.1a00e5	c9 91		cmp #$91	                CMP #K_DOWN
.1a00e7	f0 17		beq $1a0100	                BEQ csr_down
.1a00e9	c9 9d		cmp #$9d	                CMP #K_LEFT
.1a00eb	f0 1b		beq $1a0108	                BEQ csr_left
.1a00ed	c9 1d		cmp #$1d	                CMP #K_RIGHT
.1a00ef	f0 13		beq $1a0104	                BEQ csr_right
.1a00f1	c9 80		cmp #$80	                CMP #128                ; Temporary: skip anything outside ASCII
.1a00f3	b0 e9		bcs $1a00de	                BGE loop
.1a00f5	48		pha		                PHA
.1a00f6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00f9	68		pla		                PLA
.1a00fa	28		plp		done            PLP
.1a00fb	60		rts		            RTS
.1a00fc	a9 41		lda #$41	csr_up          LDA #'A'
.1a00fe	80 0a		bra $1a010a	                BRA pr_ansi
.1a0100	a9 42		lda #$42	csr_down        LDA #'B'
.1a0102	80 06		bra $1a010a	                BRA pr_ansi
.1a0104	a9 43		lda #$43	csr_right       LDA #'C'
.1a0106	80 02		bra $1a010a	                BRA pr_ansi
.1a0108	a9 44		lda #$44	csr_left        LDA #'D'
.1a010a	48		pha		pr_ansi         PHA
.1a010b	a9 1b		lda #$1b	                LDA #CHAR_ESC
.1a010d	20 18 00	jsr $1a0018	            JSR PRINTC
.1a0110	a9 5b		lda #$5b	                LDA #'['
.1a0112	20 18 00	jsr $1a0018	            JSR PRINTC
.1a0115	68		pla		                PLA
.1a0116	20 18 00	jsr $1a0018	            JSR PRINTC
.1a0119	a9 00		lda #$00	                LDA #0
.1a011b	80 dd		bra $1a00fa	                BRA done
=$11					K_UP = $11      ; Keypad UP
=$1d					K_RIGHT = $1D   ; Keypad Right
=$91					K_DOWN = $91    ; Keypad Down
=$9d					K_LEFT = $9D    ; Keypad Left

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/screen.s

.1a011d					ENSURETEXT
.1a011d	08		php		            PHP
.1a011e	e2 20		sep #$20	            SEP #$20
.1a0120	af 00 00 af	lda $af0000	            LDA @l MASTER_CTRL_REG_L            ; Get the current display mode
.1a0124	89 3c		bit #$3c	            BIT #Mstr_Ctrl_Graph_Mode_En | Mstr_Ctrl_Bitmap_En | Mstr_Ctrl_TileMap_En | Mstr_Ctrl_Sprite_En
.1a0126	f0 08		beq $1a0130	            BEQ textonly                        ; If not, make sure text is enabled
.1a0128					overlay
.1a0128	09 03		ora #$03	            ORA #Mstr_Ctrl_Text_Mode_En | Mstr_Ctrl_Text_Overlay
.1a012a	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.1a012e	80 06		bra $1a0136	            BRA done
.1a0130					textonly
.1a0130	09 01		ora #$01	            ORA #Mstr_Ctrl_Text_Mode_En
.1a0132	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.1a0136	28		plp		done        PLP
.1a0137	60		rts		            RTS
.1a0138					ISHOWCURSOR
.1a0138	08		php		            PHP
.1a0139	e2 20		sep #$20	            SEP #$20
.1a013b	c9 00		cmp #$00	            CMP #0
.1a013d	f0 08		beq $1a0147	            BEQ hide
.1a013f	af 10 00 af	lda $af0010	show        LDA @lVKY_TXT_CURSOR_CTRL_REG
.1a0143	09 01		ora #$01	            ORA #Vky_Cursor_Enable
.1a0145	80 06		bra $1a014d	            BRA setit
.1a0147	af 10 00 af	lda $af0010	hide        LDA @lVKY_TXT_CURSOR_CTRL_REG
.1a014b	29 fe		and #$fe	            AND #~Vky_Cursor_Enable
.1a014d	8f 10 00 af	sta $af0010	setit       STA @lVKY_TXT_CURSOR_CTRL_REG
.1a0151	28		plp		            PLP
.1a0152	60		rts		            RTS
.1a0153					ICURSORXY
.1a0153	08		php		            PHP
.1a0154	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.1a0158	28		plp		            PLP
.1a0159	60		rts		            RTS
.1a015a					ICLSCREEN
.1a015a	48		pha		            PHA
.1a015b	da		phx		            PHX
.1a015c	5a		phy		            PHY
.1a015d	0b		phd		            PHD
.1a015e	08		php		            PHP
.1a015f	e2 20		sep #$20	            SEP #$20
.1a0161	c2 10		rep #$10	            REP #$10
.1a0163	a2 00 00	ldx #$0000	            LDX #0
.1a0166	a9 20		lda #$20	loop        LDA #$20
.1a0168	9f 00 a0 af	sta $afa000,x	            STA @lCS_TEXT_MEM_PTR,X     ; Write a space in the text cell
.1a016c	af 1e 00 00	lda $00001e	            LDA @lCURCOLOR
.1a0170	9f 00 c0 af	sta $afc000,x	            STA @lCS_COLOR_MEM_PTR,X    ; Set the color to green on black
.1a0174	e8		inx		            INX                         ; Move to the next character cell
.1a0175	e0 00 20	cpx #$2000	            CPX #$2000
.1a0178	d0 ec		bne $1a0166	            BNE loop
.1a017a	08		php		            PHP
.1a017b	c2 20		rep #$20	            REP #$20
.1a017d	48		pha		            PHA
.1a017e	a9 00 00	lda #$0000	            LDA #0
.1a0181	5b		tcd		            TCD
.1a0182	68		pla		            PLA
.1a0183	28		plp		            PLP
.1a0184	a2 00 00	ldx #$0000	            LDX #0                      ; Set cursor to upper-left corner
.1a0187	a0 00 00	ldy #$0000	            LDY #0
.1a018a	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.1a018e	28		plp		            PLP
.1a018f	2b		pld		            PLD
.1a0190	7a		ply		            PLY
.1a0191	fa		plx		            PLX
.1a0192	68		pla		            PLA
.1a0193	60		rts		            RTS
.1a0194					ISCRCPYLINE
.1a0194	da		phx		            PHX
.1a0195	5a		phy		            PHY
.1a0196	0b		phd		            PHD
.1a0197	08		php		            PHP
.1a0198	08		php		            PHP
.1a0199	c2 20		rep #$20	            REP #$20
.1a019b	48		pha		            PHA
.1a019c	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a019f	5b		tcd		            TCD
.1a01a0	68		pla		            PLA
.1a01a1	28		plp		            PLP
.1a01a2	c2 30		rep #$30	            REP #$30
.1a01a4	af 0c 00 00	lda $00000c	            LDA @lSCREENBEGIN       ; Set INDEX to the first byte of the text screen
.1a01a8	85 08		sta $0808	            STA INDEX
.1a01aa	e2 20		sep #$20	            SEP #$20
.1a01ac	af 0e 00 00	lda $00000e	            LDA @lSCREENBEGIN+2
.1a01b0	c2 20		rep #$20	            REP #$20
.1a01b2	29 ff 00	and #$00ff	            AND #$00FF
.1a01b5	85 0a		sta $080a	            STA INDEX+2
.1a01b7	af 11 00 00	lda $000011	            LDA @lCOLS_PER_LINE     ; Calculate the offset to the current line
.1a01bb	8f 08 01 00	sta $000108	            STA @lM1_OPERAND_A
.1a01bf	af 1c 00 00	lda $00001c	            LDA @lCURSORY
.1a01c3	3a		dec a		            DEC A
.1a01c4	8f 0a 01 00	sta $00010a	            STA @lM1_OPERAND_B
.1a01c8	18		clc		            CLC                     ; And add it to INDEX
.1a01c9	a5 08		lda $0808	            LDA INDEX
.1a01cb	6f 0c 01 00	adc $00010c	            ADC @lM1_RESULT
.1a01cf	85 08		sta $0808	            STA INDEX
.1a01d1	a5 0a		lda $080a	            LDA INDEX+2
.1a01d3	69 00 00	adc #$0000	            ADC #0
.1a01d6	85 0a		sta $080a	            STA INDEX+2
.1a01d8	e2 20		sep #$20	            SEP #$20
.1a01da	af 0f 00 00	lda $00000f	            LDA @lCOLS_VISIBLE
.1a01de	85 8f		sta $088f	            STA MCOUNT
.1a01e0	a0 00 00	ldy #$0000	            LDY #0
.1a01e3	a2 00 00	ldx #$0000	            LDX #0
.1a01e6	b7 08		lda [$0808],y	copy_loop   LDA [INDEX],Y           ; Copy a byte from the screen to the input buffer
.1a01e8	9f 00 4f 00	sta $004f00,x	            STA @lINPUTBUF,X
.1a01ec	e8		inx		            INX
.1a01ed	c8		iny		            INY
.1a01ee	c4 8f		cpy $088f	            CPY MCOUNT
.1a01f0	d0 f4		bne $1a01e6	            BNE copy_loop
.1a01f2	ca		dex		            DEX
.1a01f3	bf 00 4f 00	lda $004f00,x	trim_loop   LDA @lINPUTBUF,X        ; Replace spaces at the end with NULLs
.1a01f7	c9 20		cmp #$20	            CMP #CHAR_SP
.1a01f9	d0 09		bne $1a0204	            BNE done
.1a01fb	a9 00		lda #$00	            LDA #0
.1a01fd	9f 00 4f 00	sta $004f00,x	            STA @lINPUTBUF,X
.1a0201	ca		dex		            DEX
.1a0202	10 ef		bpl $1a01f3	            BPL trim_loop
.1a0204	28		plp		done        PLP
.1a0205	2b		pld		            PLD
.1a0206	7a		ply		            PLY
.1a0207	fa		plx		            PLX
.1a0208	60		rts		            RTS

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/gabe_defs.s

=$afe880				GABE_MSTR_CTRL      = $AFE880
=$01					GABE_CTRL_PWR_LED   = $01     ; Controls the LED in the Front of the case (Next to the reset button)
=$02					GABE_CTRL_SDC_LED   = $02     ; Controls the LED in the Front of the Case (Next to SDCard)
=$04					GABE_CTRL_STS_LED0  = $04     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$08					GABE_CTRL_STS_LED1  = $08     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$10					GABE_CTRL_BUZZER    = $10     ; Controls the Buzzer
=$80					GABE_CTRL_WRM_RST   = $80     ; Warm Reset (needs to Setup other registers)
=$afe881				GABE_LED_FLASH_CTRL = $AFE881  ; Flashing LED Control
=$01					GABE_LED0_FLASH_CTRL = $01     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$02					GABE_LED1_FLASH_CTRL = $02     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED1 to manually control)
=$10					GABE_LD0_FLASH_FRQ0   = $10     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$20					GABE_LD0_FLASH_FRQ1   = $20     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$40					GABE_LD1_FLASH_FRQ0   = $40     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$80					GABE_LD1_FLASH_FRQ1   = $80     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$afe882				GABE_RST_AUTH0      = $AFE882 ; Must Contain the BYTE $AD for Reset to Activate
=$afe883				GABE_RST_AUTH1      = $AFE883 ; Must Contain the BYTE $DE for Reset to Activate
=$afe884				GABE_RNG_DAT_LO     = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_DAT_HI     = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe884				GABE_RNG_SEED_LO    = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_SEED_HI    = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe886				GABE_RNG_STAT       = $AFE886 ;
=$80					GABE_RNG_LFSR_DONE  = $80     ; indicates that Output = SEED Database
=$afe886				GABE_RNG_CTRL       = $AFE886 ;
=$01					GABE_RNG_CTRL_EN    = $01     ; Enable the LFSR BLOCK_LEN
=$02					GABE_RNG_CTRL_DV    = $02     ; After Setting the Seed Value, Toggle that Bit for it be registered
=$afe887				GABE_SYS_STAT       = $AFE887 ;
=$01					GABE_SYS_STAT_MID0  = $01     ; Machine ID -- LSB
=$02					GABE_SYS_STAT_MID1  = $02     ; Machine ID --
=$04					GABE_SYS_STAT_MID2  = $04     ; Machine ID -- MSB
=$10					GABE_SYS_STAT_EXP   = $10     ; if Zero, there is an Expansion Card Preset
=$40					GABE_SYS_STAT_CPUA  = $40     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$80					GABE_SYS_STAT_CPUX  = $80     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$afe88a				GABE_SUBVERSION_LO  = $AFE88A
=$afe88b				GABE_SUBVERSION_HI  = $AFE88B
=$afe88c				GABE_VERSION_LO     = $AFE88C
=$afe88d				GABE_VERSION_HI     = $AFE88D
=$afe88e				GABE_MODEL_LO       = $AFE88E
=$afe88f				GABE_MODEL_HI       = $AFE88F

;******  Return to file: src\C256/io_c256.s

=32					BORDER_WIDTH = 32               ; The width of the border (when it is on)
=72					TEXT_COLS_WB = 72               ; Number of columns of text with the border enabled
=52					TEXT_ROWS_WB = 52               ; Number of rows of text with the border enabled
=80					TEXT_COLS_WOB = 80              ; Number of columns of text with no border enabled
=60					TEXT_ROWS_WOB = 60              ; Number of rows of text with no border enabled
.1a0209					INITIO
.1a0209	e2 20		sep #$20	            SEP #$20
.1a020b	20 54 02	jsr $1a0254	            JSR INITRNG
.1a020e	a9 48		lda #$48	            LDA #TEXT_COLS_WB   ; Make sure the screen size is right
.1a0210	8f 0f 00 00	sta $00000f	            STA @lCOLS_VISIBLE  ; TODO: remove this when the kernel is correct
.1a0214	a9 34		lda #$34	            LDA #TEXT_ROWS_WB
.1a0216	8f 13 00 00	sta $000013	            STA @lLINES_VISIBLE
.1a021a	a9 20		lda #$20	            LDA #BORDER_WIDTH   ; Set the border width
.1a021c	8f 08 00 af	sta $af0008	            STA BORDER_X_SIZE
.1a0220	8f 09 00 af	sta $af0009	            STA BORDER_Y_SIZE
.1a0224	a2 00 00	ldx #$0000	            LDX #0              ; Clear all the sprite control shadow registers
.1a0227	a9 00		lda #$00	            LDA #0
.1a0229	9f 18 f0 1a	sta $1af018,x	sp_loop     STA GS_SP_CONTROL,X
.1a022d	e8		inx		            INX
.1a022e	e0 40 00	cpx #$0040	            CPX #SP_MAX
.1a0231	d0 f6		bne $1a0229	            BNE sp_loop
.1a0233	a9 80		lda #$80	            LDA #DEV_SCREEN
.1a0235	8f b4 08 00	sta $0008b4	            STA @lBCONSOLE
.1a0239	e2 20		sep #$20	            SEP #$20
.1a023b	a9 00		lda #$00	            LDA #0                  ; Clear the lock key flags
.1a023d	8f 89 0f 00	sta $000f89	            STA @lKEYBOARD_LOCKS
.1a0241	a9 00		lda #$00	            LDA #0
.1a0243	8f 00 02 af	sta $af0200	            STA @l TL0_CONTROL_REG
.1a0247	8f 0c 02 af	sta $af020c	            STA @l TL1_CONTROL_REG
.1a024b	8f 18 02 af	sta $af0218	            STA @l TL2_CONTROL_REG
.1a024f	8f 24 02 af	sta $af0224	            STA @l TL3_CONTROL_REG
.1a0253					done
.1a0253	60		rts		            RTS
.1a0254					INITRNG
.1a0254	08		php		            PHP
.1a0255	e2 20		sep #$20	            SEP #$20
.1a0257	af 0e 08 af	lda $af080e	            LDA @l RTC_CTRL         ; Pause updates to the clock registers
.1a025b	09 08		ora #$08	            ORA #%00001000
.1a025d	8f 0e 08 af	sta $af080e	            STA @l RTC_CTRL
.1a0261	af 00 08 af	lda $af0800	            LDA @l RTC_SEC          ; Set the random number generator seed
.1a0265	8f 84 e8 af	sta $afe884	            STA @l GABE_RNG_SEED_LO
.1a0269	af 02 08 af	lda $af0802	            LDA @l RTC_MIN
.1a026d	8f 85 e8 af	sta $afe885	            STA @l GABE_RNG_SEED_HI
.1a0271	a9 03		lda #$03	            LDA #GABE_RNG_CTRL_DV | GABE_RNG_CTRL_EN
.1a0273	8f 86 e8 af	sta $afe886	            STA @l GABE_RNG_CTRL    ; Load the seed into the RNG
.1a0277	af 0e 08 af	lda $af080e	            LDA @l RTC_CTRL         ; Re-enable updates to the clock registers
.1a027b	29 f7		and #$f7	            AND #%11110111
.1a027d	8f 0e 08 af	sta $af080e	            STA @l RTC_CTRL
.1a0281	ea		nop		            NOP                     ; Give the RNG some time... not sure if needed, really
.1a0282	ea		nop		            NOP
.1a0283	ea		nop		            NOP
.1a0284	a9 01		lda #$01	            LDA #GABE_RNG_CTRL_EN   ; Turn on the random number genertator
.1a0286	8f 86 e8 af	sta $afe886	            STA @l GABE_RNG_CTRL
.1a028a	28		plp		            PLP
.1a028b	60		rts		            RTS
.1a028c					SCREEN_PUTC
.1a028c	08		php		            PHP
.1a028d	e2 20		sep #$20	            SEP #$20
.1a028f	48		pha		            PHA
.1a0290	48		pha		            PHA
.1a0291	a9 00		lda #$00	            LDA #CHAN_CONSOLE       ; Switch to the console device
.1a0293	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.1a0297	68		pla		            PLA
.1a0298	22 18 10 00	jsl $001018	            JSL FK_PUTC
.1a029c	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.1a02a0	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.1a02a2	d0 f8		bne $1a029c	            BNE loop                ; Yes: wait until it's released
.1a02a4	68		pla		            PLA
.1a02a5	28		plp		            PLP
.1a02a6	60		rts		            RTS
.1a02a7					UART_PUTC
.1a02a7	08		php		            PHP
.1a02a8	e2 20		sep #$20	            SEP #$20
.1a02aa	48		pha		            PHA
.1a02ab	48		pha		            PHA
.1a02ac	a9 01		lda #$01	            LDA #CHAN_COM1          ; Switch to COM1
.1a02ae	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.1a02b2	68		pla		            PLA
.1a02b3	22 18 10 00	jsl $001018	            JSL FK_PUTC
.1a02b7	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.1a02bb	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.1a02bd	d0 f8		bne $1a02b7	            BNE loop                ; Yes: wait until it's released
.1a02bf	68		pla		            PLA
.1a02c0	28		plp		            PLP
.1a02c1	60		rts		            RTS
.1a02c2					PRINTCR
.1a02c2	08		php		            PHP
.1a02c3	c2 20		rep #$20	            REP #$20
.1a02c5	48		pha		            PHA
.1a02c6	e2 20		sep #$20	            SEP #$20
.1a02c8	a9 0d		lda #$0d	            LDA #CHAR_CR
.1a02ca	20 18 00	jsr $1a0018	            JSR PRINTC
.1a02cd	c2 20		rep #$20	            REP #$20
.1a02cf	68		pla		            PLA
.1a02d0	28		plp		            PLP
.1a02d1	60		rts		            RTS
.1a02d2					PRINTH
.1a02d2	08		php		            PHP
.1a02d3	22 78 10 00	jsl $001078	            JSL FK_IPRINTH
.1a02d7	28		plp		            PLP
.1a02d8	60		rts		            RTS

;******  Return to file: src\bios.s

=10					LINES_PER_PAGE = 10     ; The number of lines to print on a page before pausing
=$80					DEV_SCREEN = $80        ; Use the screen and keyboard for the console device
=$40					DEV_UART = $40          ; Use UART for console device
=$20					DEV_BUFFER = $20        ; Use the current text memory buffer for output or input
>08b4					BCONSOLE    .byte ?     ; Device for BASIC console
>08b5					SAVE_A      .byte ?     ; Save spot for the A register
>08b6					LINECOUNT   .byte ?     ; Counter for new lines to support pagination
.1a02d9					PAGINATE
.1a02d9	08		php		            PHP
.1a02da	0b		phd		            PHD
.1a02db	08		php		            PHP
.1a02dc	c2 20		rep #$20	            REP #$20
.1a02de	48		pha		            PHA
.1a02df	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a02e2	5b		tcd		            TCD
.1a02e3	68		pla		            PLA
.1a02e4	28		plp		            PLP
.1a02e5	e2 20		sep #$20	            SEP #$20
.1a02e7	a5 b6		lda $08b6	            LDA LINECOUNT           ; Check the line count
.1a02e9	1a		inc a		            INC A
.1a02ea	85 b6		sta $08b6	            STA LINECOUNT
.1a02ec	cf 13 00 00	cmp $000013	            CMP @l LINES_VISIBLE
.1a02f0	90 05		bcc $1a02f7	            BLT done                ; If < limit, just return
.1a02f2	20 14 00	jsr $1a0014	            JSR GETKEY
.1a02f5	64 b6		stz $08b6	            STZ LINECOUNT           ; And reset the line count
.1a02f7	2b		pld		done        PLD
.1a02f8	28		plp		            PLP
.1a02f9	60		rts		            RTS
.1a02fa					IPRINTC
.1a02fa	da		phx		            PHX
.1a02fb	5a		phy		            PHY
.1a02fc	0b		phd		            PHD
.1a02fd	08		php		            PHP
.1a02fe	08		php		            PHP
.1a02ff	c2 20		rep #$20	            REP #$20
.1a0301	48		pha		            PHA
.1a0302	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0305	5b		tcd		            TCD
.1a0306	68		pla		            PLA
.1a0307	28		plp		            PLP
.1a0308	e2 20		sep #$20	            SEP #$20
.1a030a	c2 10		rep #$10	            REP #$10
.1a030c	8f b5 08 00	sta $0008b5	            STA @lSAVE_A
.1a0310	af b4 08 00	lda $0008b4	chk_out     LDA @lBCONSOLE      ; Check to see if we should send to an output buffer
.1a0314	29 20		and #$20	            AND #DEV_BUFFER
.1a0316	f0 07		beq $1a031f	            BEQ check_scrn      ; No... move on to the hardware screen
.1a0318	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.1a031c	20 28 00	jsr $1a0028	            JSR OBUFF_PUTC
.1a031f	af b4 08 00	lda $0008b4	check_scrn  LDA @lBCONSOLE
.1a0323	29 80		and #$80	            AND #DEV_SCREEN     ; Check to see if the screen is selected
.1a0325	f0 07		beq $1a032e	            BEQ send_uart
.1a0327	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.1a032b	20 8c 02	jsr $1a028c	            JSR SCREEN_PUTC
.1a032e	af b4 08 00	lda $0008b4	send_uart   LDA @lBCONSOLE
.1a0332	29 40		and #$40	            AND #DEV_UART       ; Check to see if the UART is active
.1a0334	f0 14		beq $1a034a	            BEQ done
.1a0336	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.1a033a	20 a7 02	jsr $1a02a7	            JSR UART_PUTC
.1a033d	af b5 08 00	lda $0008b5	            LDA @lSAVE_A        ; If sending a CR to the serial port
.1a0341	c9 0d		cmp #$0d	            CMP #CHAR_CR
.1a0343	d0 05		bne $1a034a	            BNE done
.1a0345	a9 0a		lda #$0a	            LDA #CHAR_LF        ; Send a linefeed after
.1a0347	20 a7 02	jsr $1a02a7	            JSR UART_PUTC
.1a034a	28		plp		done        PLP
.1a034b	2b		pld		            PLD
.1a034c	7a		ply		            PLY
.1a034d	fa		plx		            PLX
.1a034e	60		rts		            RTS
.1a034f					PRINTS
.1a034f	08		php		            PHP
.1a0350	e2 20		sep #$20	            SEP #$20
.1a0352	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.1a0355	f0 06		beq $1a035d	            BEQ done
.1a0357	20 18 00	jsr $1a0018	            JSR PRINTC
.1a035a	e8		inx		            INX
.1a035b	80 f5		bra $1a0352	            BRA loop
.1a035d	28		plp		done        PLP
.1a035e	60		rts		            RTS
.1a035f					PRHEXW
.1a035f	08		php		            PHP
.1a0360	c2 20		rep #$20	            REP #$20
.1a0362	48		pha		            PHA
.1a0363	48		pha		            PHA
.1a0364	4a		lsr a		            LSR A
.1a0365	4a		lsr a		            LSR A
.1a0366	4a		lsr a		            LSR A
.1a0367	4a		lsr a		            LSR A
.1a0368	4a		lsr a		            LSR A
.1a0369	4a		lsr a		            LSR A
.1a036a	4a		lsr a		            LSR A
.1a036b	4a		lsr a		            LSR A
.1a036c	20 79 03	jsr $1a0379	            JSR PRHEXB
.1a036f	68		pla		            PLA
.1a0370	29 ff 00	and #$00ff	            AND #$00FF
.1a0373	20 79 03	jsr $1a0379	            JSR PRHEXB
.1a0376	68		pla		            PLA
.1a0377	28		plp		            PLP
.1a0378	60		rts		            RTS
.1a0379					PRHEXB
.1a0379	08		php		            PHP
.1a037a	c2 20		rep #$20	            REP #$20
.1a037c	48		pha		            PHA
.1a037d	e2 20		sep #$20	            SEP #$20
.1a037f	48		pha		            PHA
.1a0380	4a		lsr a		            LSR A
.1a0381	4a		lsr a		            LSR A
.1a0382	4a		lsr a		            LSR A
.1a0383	4a		lsr a		            LSR A
.1a0384	20 90 03	jsr $1a0390	            JSR PRHEXN
.1a0387	68		pla		            PLA
.1a0388	20 90 03	jsr $1a0390	            JSR PRHEXN
.1a038b	c2 20		rep #$20	            REP #$20
.1a038d	68		pla		            PLA
.1a038e	28		plp		            PLP
.1a038f	60		rts		            RTS
.1a0390					PRHEXN
.1a0390	08		php		            PHP
.1a0391	c2 30		rep #$30	            REP #$30
.1a0393	da		phx		            PHX
.1a0394	29 0f 00	and #$000f	            AND #$000F
.1a0397	aa		tax		            TAX
.1a0398	bf 00 d0 1a	lda $1ad000,x	            LDA @lHEXDIGITS,X
.1a039c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a039f	fa		plx		            PLX
.1a03a0	28		plp		            PLP
.1a03a1	60		rts		            RTS
>1ad000	30 31 32 33 34 35 36 37		HEXDIGITS   .text "0123456789ABCDEF"
>1ad008	38 39 41 42 43 44 45 46

;******  Return to file: src\basic816.s


;******  Processing file: src\utilities.s

.1a03a2					PRTRACE
.1a03a2	08		php		            PHP
.1a03a3	c2 30		rep #$30	            REP #$30
.1a03a5	48		pha		            PHA
.1a03a6	da		phx		            PHX
.1a03a7	5a		phy		            PHY
.1a03a8	8b		phb		            PHB
.1a03a9	0b		phd		            PHD
.1a03aa	c2 30		rep #$30	            REP #$30
.1a03ac	a3 0b		lda $0b,s	            LDA 11,S        ; Get the return address
.1a03ae	18		clc		calc_addr   CLC
.1a03af	69 03 00	adc #$0003	            ADC #3          ; Add 3 to skip over the following branch
.1a03b2	aa		tax		            TAX
.1a03b3	e2 20		sep #$20	            SEP #$20
.1a03b5	a9 1a		lda #$1a	            LDA #`PRTRACE
.1a03b7	48		pha		            PHA
.1a03b8	ab		plb		            PLB
.1a03b9	bd 00 00	lda $0000,x	pr_loop     LDA #0,B,X
.1a03bc	f0 06		beq $1a03c4	            BEQ done
.1a03be	20 8c 02	jsr $1a028c	            JSR SCREEN_PUTC
.1a03c1	e8		inx		            INX
.1a03c2	80 f5		bra $1a03b9	            BRA pr_loop
.1a03c4					done
.1a03c4	c2 30		rep #$30	            REP #$30
.1a03c6	2b		pld		            PLD
.1a03c7	ab		plb		            PLB
.1a03c8	7a		ply		            PLY
.1a03c9	fa		plx		            PLX
.1a03ca	68		pla		            PLA
.1a03cb	28		plp		            PLP
.1a03cc	60		rts		            RTS
.1a03cd					ISALPHA
.1a03cd	08		php		            PHP
.1a03ce	e2 20		sep #$20	            SEP #$20
.1a03d0	c9 5b		cmp #$5b	            CMP #'Z'+1
.1a03d2	b0 04		bcs $1a03d8	            BGE not_upper
.1a03d4	c9 41		cmp #$41	            CMP #'A'
.1a03d6	b0 0b		bcs $1a03e3	            BGE is_alpha
.1a03d8	c9 7b		cmp #$7b	not_upper   CMP #'z'+1
.1a03da	b0 04		bcs $1a03e0	            BGE not_alpha
.1a03dc	c9 61		cmp #$61	            CMP #'a'
.1a03de	b0 03		bcs $1a03e3	            BGE is_alpha
.1a03e0					not_alpha
.1a03e0	28		plp		            PLP
.1a03e1	18		clc		            CLC
.1a03e2	60		rts		            RTS
.1a03e3					is_alpha
.1a03e3	28		plp		            PLP
.1a03e4	38		sec		            SEC
.1a03e5	60		rts		            RTS
.1a03e6					ISNUMERAL
.1a03e6	08		php		            PHP
.1a03e7	e2 20		sep #$20	            SEP #$20
.1a03e9	c9 3a		cmp #$3a	            CMP #'9'+1
.1a03eb	b0 04		bcs $1a03f1	            BGE ret_false
.1a03ed	c9 30		cmp #$30	            CMP #'0'
.1a03ef	b0 03		bcs $1a03f4	            BGE ret_true
.1a03f1	28		plp		ret_false   PLP
.1a03f2	18		clc		            CLC
.1a03f3	60		rts		            RTS
.1a03f4	28		plp		ret_true    PLP
.1a03f5	38		sec		            SEC
.1a03f6	60		rts		            RTS
.1a03f7					ISHEX
.1a03f7	08		php		            PHP
.1a03f8	e2 20		sep #$20	            SEP #$20
.1a03fa	c9 3a		cmp #$3a	            CMP #'9'+1
.1a03fc	b0 04		bcs $1a0402	            BGE chk_lca2f
.1a03fe	c9 30		cmp #$30	            CMP #'0'
.1a0400	b0 13		bcs $1a0415	            BGE ret_true
.1a0402	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.1a0404	b0 04		bcs $1a040a	            BGE chk_uca2f
.1a0406	c9 61		cmp #$61	            CMP #'a'
.1a0408	b0 0b		bcs $1a0415	            BGE ret_true
.1a040a	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.1a040c	b0 04		bcs $1a0412	            BGE ret_false
.1a040e	c9 41		cmp #$41	            CMP #'A'
.1a0410	b0 03		bcs $1a0415	            BGE ret_true
.1a0412	28		plp		ret_false   PLP
.1a0413	18		clc		            CLC
.1a0414	60		rts		            RTS
.1a0415	28		plp		ret_true    PLP
.1a0416	38		sec		            SEC
.1a0417	60		rts		            RTS
.1a0418					HEX2BIN
.1a0418	08		php		            PHP
.1a0419	e2 20		sep #$20	            SEP #$20
.1a041b	c9 3a		cmp #$3a	            CMP #'9'+1          ; Check to see if '0'..'9'
.1a041d	b0 04		bcs $1a0423	            BGE chk_lca2f
.1a041f	c9 30		cmp #$30	            CMP #'0'
.1a0421	b0 12		bcs $1a0435	            BGE conv_09         ; Yes: convert it
.1a0423	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.1a0425	b0 04		bcs $1a042b	            BGE chk_uca2f
.1a0427	c9 61		cmp #$61	            CMP #'a'
.1a0429	b0 0f		bcs $1a043a	            BGE conv_lcaf
.1a042b	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.1a042d	b0 04		bcs $1a0433	            BGE done
.1a042f	c9 41		cmp #$41	            CMP #'A'
.1a0431	b0 09		bcs $1a043c	            BGE conv_ucaf
.1a0433	28		plp		done        PLP
.1a0434	60		rts		            RTS
.1a0435	38		sec		conv_09     SEC                 ; Convert digits '0'..'9'
.1a0436	e9 30		sbc #$30	            SBC #'0'
.1a0438	80 f9		bra $1a0433	            BRA done
.1a043a	29 df		and #$df	conv_lcaf   AND #%11011111      ; Convert to upper case
.1a043c	38		sec		conv_ucaf   SEC
.1a043d	e9 37		sbc #$37	            SBC #'A'-10         ; Convert 'A'..'F'
.1a043f	80 f2		bra $1a0433	            BRA done
.1a0441					TOUPPERA
.1a0441	08		php		            PHP
.1a0442	e2 20		sep #$20	            SEP #$20
.1a0444	c9 7b		cmp #$7b	            CMP #'z'+1
.1a0446	b0 06		bcs $1a044e	            BCS done
.1a0448	c9 61		cmp #$61	            CMP #'a'
.1a044a	90 02		bcc $1a044e	            BCC done
.1a044c	29 df		and #$df	            AND #%11011111
.1a044e	28		plp		done        PLP
.1a044f	60		rts		            RTS
.1a0450					TOUPPER
.1a0450	08		php		            PHP
.1a0451	e2 20		sep #$20	            SEP #$20
.1a0453	c2 10		rep #$10	            REP #$10
.1a0455	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.1a0458	f0 09		beq $1a0463	            BEQ done
.1a045a	20 41 04	jsr $1a0441	            JSR TOUPPERA
.1a045d	9d 00 00	sta $0000,x	            STA #0,B,X
.1a0460	e8		inx		continue    INX
.1a0461	80 f2		bra $1a0455	            BRA loop
.1a0463	28		plp		done        PLP
.1a0464	60		rts		            RTS
.1a0465					MULINT10
.1a0465	08		php		                PHP
.1a0466	0b		phd		                PHD
.1a0467	08		php		            PHP
.1a0468	c2 20		rep #$20	            REP #$20
.1a046a	48		pha		            PHA
.1a046b	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a046e	5b		tcd		            TCD
.1a046f	68		pla		            PLA
.1a0470	28		plp		            PLP
.1a0471	c2 20		rep #$20	            REP #$20
.1a0473	48		pha		                PHA
.1a0474	06 23		asl $0823	                ASL ARGUMENT1           ; 7 -- 20 -- 74
.1a0476	26 25		rol $0825	                ROL ARGUMENT1+2         ; 7
.1a0478	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.1a047a	85 0c		sta $080c	                STA SCRATCH             ; 4
.1a047c	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.1a047e	85 0e		sta $080e	                STA SCRATCH+2           ; 4
.1a0480	06 0c		asl $080c	                ASL SCRATCH             ; 7 -- 28
.1a0482	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.1a0484	06 0c		asl $080c	                ASL SCRATCH             ; 7
.1a0486	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.1a0488	18		clc		                CLC                     ; 2 -- 26
.1a0489	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.1a048b	65 0c		adc $080c	                ADC SCRATCH             ; 4
.1a048d	85 23		sta $0823	                STA ARGUMENT1           ; 4
.1a048f	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.1a0491	65 0e		adc $080e	                ADC SCRATCH+2           ; 4
.1a0493	85 25		sta $0825	                STA ARGUMENT1+2         ; 4
.1a0495	68		pla		                PLA
.1a0496	2b		pld		                PLD
.1a0497	28		plp		                PLP
.1a0498	60		rts		            RTS
.1a0499					DIVINT10
.1a0499	08		php		                PHP
.1a049a	0b		phd		                PHD
.1a049b	08		php		            PHP
.1a049c	c2 20		rep #$20	            REP #$20
.1a049e	48		pha		            PHA
.1a049f	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a04a2	5b		tcd		            TCD
.1a04a3	68		pla		            PLA
.1a04a4	28		plp		            PLP
.1a04a5	c2 20		rep #$20	            REP #$20
.1a04a7	a5 23		lda $0823	                LDA ARGUMENT1
.1a04a9	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.1a04ad	a9 0a 00	lda #$000a	                LDA #10
.1a04b0	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.1a04b4	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.1a04b8	85 23		sta $0823	                STA ARGUMENT1
.1a04ba	64 25		stz $0825	                STZ ARGUMENT1+2
.1a04bc	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.1a04c0	85 29		sta $0829	                STA ARGUMENT2
.1a04c2	64 2b		stz $082b	                STZ ARGUMENT2+2
.1a04c4	e2 20		sep #$20	            SEP #$20
.1a04c6	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a04c8	85 27		sta $0827	                STA ARGTYPE1
.1a04ca	85 2d		sta $082d	                STA ARGTYPE2
.1a04cc	2b		pld		                PLD
.1a04cd	28		plp		                PLP
.1a04ce	60		rts		            RTS
.1a04cf					DIVINT100
.1a04cf	08		php		                PHP
.1a04d0	0b		phd		                PHD
.1a04d1	08		php		            PHP
.1a04d2	c2 20		rep #$20	            REP #$20
.1a04d4	48		pha		            PHA
.1a04d5	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a04d8	5b		tcd		            TCD
.1a04d9	68		pla		            PLA
.1a04da	28		plp		            PLP
.1a04db	c2 20		rep #$20	            REP #$20
.1a04dd	a5 23		lda $0823	                LDA ARGUMENT1
.1a04df	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.1a04e3	a9 64 00	lda #$0064	                LDA #100
.1a04e6	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.1a04ea	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.1a04ee	85 23		sta $0823	                STA ARGUMENT1
.1a04f0	64 25		stz $0825	                STZ ARGUMENT1+2
.1a04f2	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.1a04f6	85 29		sta $0829	                STA ARGUMENT2
.1a04f8	64 2b		stz $082b	                STZ ARGUMENT2+2
.1a04fa	e2 20		sep #$20	            SEP #$20
.1a04fc	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a04fe	85 27		sta $0827	                STA ARGTYPE1
.1a0500	85 2d		sta $082d	                STA ARGTYPE2
.1a0502	2b		pld		                PLD
.1a0503	28		plp		                PLP
.1a0504	60		rts		            RTS
.1a0505					IS_ARG1_Z
.1a0505	08		php		                PHP
.1a0506	c2 20		rep #$20	            REP #$20
.1a0508	a5 23		lda $0823	                LDA ARGUMENT1
.1a050a	d0 08		bne $1a0514	                BNE return_false
.1a050c	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a050e	d0 04		bne $1a0514	                BNE return_false
.1a0510	28		plp		return_true     PLP
.1a0511	e2 02		sep #$02	                SEP #$02        ; Set Z
.1a0513	60		rts		            RTS
.1a0514	28		plp		return_false    PLP
.1a0515	c2 02		rep #$02	                REP #$02        ; Clear Z
.1a0517	60		rts		            RTS
.1a0518					SET_TRUE
.1a0518	08		php		                PHP
.1a0519	c2 30		rep #$30	            REP #$30
.1a051b	a9 ff ff	lda #$ffff	                LDA #$FFFF
.1a051e	85 23		sta $0823	                STA ARGUMENT1
.1a0520	85 25		sta $0825	                STA ARGUMENT1+2
.1a0522	e2 20		sep #$20	            SEP #$20
.1a0524	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a0526	85 27		sta $0827	                STA ARGTYPE1
.1a0528	28		plp		                PLP
.1a0529	60		rts		            RTS
.1a052a					SET_FALSE
.1a052a	08		php		                PHP
.1a052b	c2 30		rep #$30	            REP #$30
.1a052d	a9 00 00	lda #$0000	                LDA #0
.1a0530	85 23		sta $0823	                STA ARGUMENT1
.1a0532	85 25		sta $0825	                STA ARGUMENT1+2
.1a0534	e2 20		sep #$20	            SEP #$20
.1a0536	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a0538	85 27		sta $0827	                STA ARGTYPE1
.1a053a	28		plp		                PLP
.1a053b	60		rts		            RTS
.1a053c					ASS_ARG1_INT
.1a053c	08		php		                PHP
.1a053d	e2 20		sep #$20	            SEP #$20
.1a053f	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.1a0541	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a0543	f0 07		beq $1a054c	                BEQ done                ; If so: just return
.1a0545	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.1a0547	d0 05		bne $1a054e	                BNE TYPE_ERR            ; If not: throw an error
.1a0549	20 b6 59	jsr $1a59b6	            JSR FTOI
.1a054c	28		plp		done            PLP
.1a054d	60		rts		            RTS
.1a054e					TYPE_ERR
.1a054e	08		php		            PHP
.1a054f	c2 20		rep #$20	            REP #$20
.1a0551	48		pha		            PHA
.1a0552	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0555	5b		tcd		            TCD
.1a0556	68		pla		            PLA
.1a0557	28		plp		            PLP
.1a0558	e2 20		sep #$20	            SEP #$20
.1a055a	a9 04		lda #$04	            LDA #ERR_TYPE
.1a055c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0560	c2 20		rep #$20	            REP #$20
.1a0562	29 ff 00	and #$00ff	            AND #$00FF
.1a0565	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a0568	e2 20		sep #$20	            SEP #$20
.1a056a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a056d					ASS_ARG2_INT
.1a056d	08		php		                PHP
.1a056e	e2 20		sep #$20	            SEP #$20
.1a0570	a5 2d		lda $082d	                LDA ARGTYPE2                ; Verify that the type is INTEGER
.1a0572	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a0574	f0 37		beq $1a05ad	                BEQ done                    ; If so: just return
.1a0576	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; Check if it's a float
.1a0578	d0 35		bne $1a05af	                BNE TYPE_ERR                ; If not: throw an error
.1a057a	c2 20		rep #$20	            REP #$20
.1a057c	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a057e	48		pha		            PHA
.1a057f	a5 23		lda $0823	            LDA ARGUMENT1
.1a0581	48		pha		            PHA
.1a0582	c2 20		rep #$20	            REP #$20
.1a0584	a5 29		lda $0829	            LDA ARGUMENT2
.1a0586	85 23		sta $0823	            STA ARGUMENT1
.1a0588	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a058a	85 25		sta $0825	            STA ARGUMENT1+2
.1a058c	e2 20		sep #$20	            SEP #$20
.1a058e	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.1a0590	85 27		sta $0827	            STA ARGTYPE1
.1a0592	20 b6 59	jsr $1a59b6	            JSR FTOI
.1a0595	c2 20		rep #$20	            REP #$20
.1a0597	a5 23		lda $0823	            LDA ARGUMENT1
.1a0599	85 29		sta $0829	            STA ARGUMENT2
.1a059b	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a059d	85 2b		sta $082b	            STA ARGUMENT2+2
.1a059f	e2 20		sep #$20	            SEP #$20
.1a05a1	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a05a3	85 2d		sta $082d	            STA ARGTYPE2
.1a05a5	c2 20		rep #$20	            REP #$20
.1a05a7	68		pla		            PLA
.1a05a8	85 23		sta $0823	            STA ARGUMENT1
.1a05aa	68		pla		            PLA
.1a05ab	85 25		sta $0825	            STA ARGUMENT1+2
.1a05ad	28		plp		done            PLP
.1a05ae	60		rts		            RTS
.1a05af					TYPE_ERR
.1a05af	08		php		            PHP
.1a05b0	c2 20		rep #$20	            REP #$20
.1a05b2	48		pha		            PHA
.1a05b3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a05b6	5b		tcd		            TCD
.1a05b7	68		pla		            PLA
.1a05b8	28		plp		            PLP
.1a05b9	e2 20		sep #$20	            SEP #$20
.1a05bb	a9 04		lda #$04	            LDA #ERR_TYPE
.1a05bd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a05c1	c2 20		rep #$20	            REP #$20
.1a05c3	29 ff 00	and #$00ff	            AND #$00FF
.1a05c6	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a05c9	e2 20		sep #$20	            SEP #$20
.1a05cb	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a05ce					ASS_ARG1_STR
.1a05ce	08		php		                PHP
.1a05cf	e2 20		sep #$20	            SEP #$20
.1a05d1	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is STRING
.1a05d3	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a05d5	d0 02		bne $1a05d9	                BNE TYPE_ERR
.1a05d7	28		plp		                PLP
.1a05d8	60		rts		            RTS
.1a05d9					TYPE_ERR
.1a05d9	08		php		            PHP
.1a05da	c2 20		rep #$20	            REP #$20
.1a05dc	48		pha		            PHA
.1a05dd	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a05e0	5b		tcd		            TCD
.1a05e1	68		pla		            PLA
.1a05e2	28		plp		            PLP
.1a05e3	e2 20		sep #$20	            SEP #$20
.1a05e5	a9 04		lda #$04	            LDA #ERR_TYPE
.1a05e7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a05eb	c2 20		rep #$20	            REP #$20
.1a05ed	29 ff 00	and #$00ff	            AND #$00FF
.1a05f0	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a05f3	e2 20		sep #$20	            SEP #$20
.1a05f5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a05f8					ASS_ARG1_INT16
.1a05f8	08		php		                PHP
.1a05f9	e2 20		sep #$20	            SEP #$20
.1a05fb	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.1a05fd	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a05ff	f0 07		beq $1a0608	                BEQ check_range         ; If so: check the range
.1a0601	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.1a0603	d0 0b		bne $1a0610	                BNE TYPE_ERR            ; If not: throw an error
.1a0605	20 b6 59	jsr $1a59b6	            JSR FTOI
.1a0608					check_range
.1a0608	c2 20		rep #$20	            REP #$20
.1a060a	a5 25		lda $0825	                LDA ARGUMENT1+2         ; Validate it is 16-bit
.1a060c	d0 21		bne $1a062f	                BNE range_err
.1a060e	28		plp		                PLP
.1a060f	60		rts		            RTS
.1a0610					TYPE_ERR
.1a0610	08		php		            PHP
.1a0611	c2 20		rep #$20	            REP #$20
.1a0613	48		pha		            PHA
.1a0614	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0617	5b		tcd		            TCD
.1a0618	68		pla		            PLA
.1a0619	28		plp		            PLP
.1a061a	e2 20		sep #$20	            SEP #$20
.1a061c	a9 04		lda #$04	            LDA #ERR_TYPE
.1a061e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0622	c2 20		rep #$20	            REP #$20
.1a0624	29 ff 00	and #$00ff	            AND #$00FF
.1a0627	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a062a	e2 20		sep #$20	            SEP #$20
.1a062c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a062f					RANGE_ERR
.1a062f	08		php		            PHP
.1a0630	c2 20		rep #$20	            REP #$20
.1a0632	48		pha		            PHA
.1a0633	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0636	5b		tcd		            TCD
.1a0637	68		pla		            PLA
.1a0638	28		plp		            PLP
.1a0639	e2 20		sep #$20	            SEP #$20
.1a063b	a9 09		lda #$09	            LDA #ERR_RANGE
.1a063d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0641	c2 20		rep #$20	            REP #$20
.1a0643	29 ff 00	and #$00ff	            AND #$00FF
.1a0646	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a0649	e2 20		sep #$20	            SEP #$20
.1a064b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a064e					ASS_ARG1_BYTE
.1a064e	08		php		                PHP
.1a064f	e2 20		sep #$20	            SEP #$20
.1a0651	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.1a0653	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a0655	f0 07		beq $1a065e	                BEQ check_range         ; If so: check the range
.1a0657	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.1a0659	d0 11		bne $1a066c	                BNE TYPE_ERR            ; If not: throw an error
.1a065b	20 b6 59	jsr $1a59b6	            JSR FTOI
.1a065e	a5 26		lda $0826	check_range     LDA ARGUMENT1+3         ; Validate that the value is in byte range
.1a0660	d0 29		bne $1a068b	                BNE RANGE_ERR           ; If not... throw a range error
.1a0662	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a0664	d0 25		bne $1a068b	                BNE RANGE_ERR
.1a0666	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a0668	d0 21		bne $1a068b	                BNE RANGE_ERR
.1a066a	28		plp		                PLP
.1a066b	60		rts		            RTS
.1a066c					TYPE_ERR
.1a066c	08		php		            PHP
.1a066d	c2 20		rep #$20	            REP #$20
.1a066f	48		pha		            PHA
.1a0670	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0673	5b		tcd		            TCD
.1a0674	68		pla		            PLA
.1a0675	28		plp		            PLP
.1a0676	e2 20		sep #$20	            SEP #$20
.1a0678	a9 04		lda #$04	            LDA #ERR_TYPE
.1a067a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a067e	c2 20		rep #$20	            REP #$20
.1a0680	29 ff 00	and #$00ff	            AND #$00FF
.1a0683	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a0686	e2 20		sep #$20	            SEP #$20
.1a0688	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a068b					RANGE_ERR
.1a068b	08		php		            PHP
.1a068c	c2 20		rep #$20	            REP #$20
.1a068e	48		pha		            PHA
.1a068f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0692	5b		tcd		            TCD
.1a0693	68		pla		            PLA
.1a0694	28		plp		            PLP
.1a0695	e2 20		sep #$20	            SEP #$20
.1a0697	a9 09		lda #$09	            LDA #ERR_RANGE
.1a0699	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a069d	c2 20		rep #$20	            REP #$20
.1a069f	29 ff 00	and #$00ff	            AND #$00FF
.1a06a2	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a06a5	e2 20		sep #$20	            SEP #$20
.1a06a7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a06aa					ASS_ARG1_FLOAT
.1a06aa	08		php		                PHP
.1a06ab	e2 20		sep #$20	            SEP #$20
.1a06ad	a5 27		lda $0827	                LDA ARGTYPE1            ; Check the type
.1a06af	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.1a06b1	f0 26		beq $1a06d9	                BEQ done                ; Then we're done
.1a06b3	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.1a06b5	f0 1f		beq $1a06d6	                BEQ cast                ; Then cast it to float
.1a06b7					type_err
.1a06b7	08		php		            PHP
.1a06b8	c2 20		rep #$20	            REP #$20
.1a06ba	48		pha		            PHA
.1a06bb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a06be	5b		tcd		            TCD
.1a06bf	68		pla		            PLA
.1a06c0	28		plp		            PLP
.1a06c1	e2 20		sep #$20	            SEP #$20
.1a06c3	a9 04		lda #$04	            LDA #ERR_TYPE
.1a06c5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a06c9	c2 20		rep #$20	            REP #$20
.1a06cb	29 ff 00	and #$00ff	            AND #$00FF
.1a06ce	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a06d1	e2 20		sep #$20	            SEP #$20
.1a06d3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a06d6					cast
.1a06d6	20 b0 59	jsr $1a59b0	            JSR ITOF
.1a06d9	28		plp		done            PLP
.1a06da	60		rts		            RTS
.1a06db					ASS_ARG2_FLOAT
.1a06db	08		php		                PHP
.1a06dc	e2 20		sep #$20	            SEP #$20
.1a06de	a5 2d		lda $082d	                LDA ARGTYPE2            ; Check the type
.1a06e0	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.1a06e2	f0 26		beq $1a070a	                BEQ done                ; Then we're done
.1a06e4	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.1a06e6	f0 1f		beq $1a0707	                BEQ cast                ; Then cast it to float
.1a06e8					type_err
.1a06e8	08		php		            PHP
.1a06e9	c2 20		rep #$20	            REP #$20
.1a06eb	48		pha		            PHA
.1a06ec	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a06ef	5b		tcd		            TCD
.1a06f0	68		pla		            PLA
.1a06f1	28		plp		            PLP
.1a06f2	e2 20		sep #$20	            SEP #$20
.1a06f4	a9 04		lda #$04	            LDA #ERR_TYPE
.1a06f6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a06fa	c2 20		rep #$20	            REP #$20
.1a06fc	29 ff 00	and #$00ff	            AND #$00FF
.1a06ff	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a0702	e2 20		sep #$20	            SEP #$20
.1a0704	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0707					cast
.1a0707	20 0c 07	jsr $1a070c	            JSR CAST_ARG2_FLOAT
.1a070a	28		plp		done            PLP
.1a070b	60		rts		            RTS
.1a070c					CAST_ARG2_FLOAT
.1a070c	c2 20		rep #$20	            REP #$20
.1a070e	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a0710	48		pha		            PHA
.1a0711	a5 23		lda $0823	            LDA ARGUMENT1
.1a0713	48		pha		            PHA
.1a0714	c2 20		rep #$20	            REP #$20
.1a0716	a5 29		lda $0829	            LDA ARGUMENT2
.1a0718	85 23		sta $0823	            STA ARGUMENT1
.1a071a	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a071c	85 25		sta $0825	            STA ARGUMENT1+2
.1a071e	e2 20		sep #$20	            SEP #$20
.1a0720	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a0722	85 27		sta $0827	            STA ARGTYPE1
.1a0724	20 b0 59	jsr $1a59b0	            JSR ITOF
.1a0727	c2 20		rep #$20	            REP #$20
.1a0729	a5 23		lda $0823	            LDA ARGUMENT1
.1a072b	85 29		sta $0829	            STA ARGUMENT2
.1a072d	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a072f	85 2b		sta $082b	            STA ARGUMENT2+2
.1a0731	e2 20		sep #$20	            SEP #$20
.1a0733	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.1a0735	85 2d		sta $082d	            STA ARGTYPE2
.1a0737	c2 20		rep #$20	            REP #$20
.1a0739	68		pla		            PLA
.1a073a	85 23		sta $0823	            STA ARGUMENT1
.1a073c	68		pla		            PLA
.1a073d	85 25		sta $0825	            STA ARGUMENT1+2
.1a073f	60		rts		            RTS
.1a0740					ASS_ARGS_NUM
.1a0740	08		php		                PHP
.1a0741	e2 20		sep #$20	            SEP #$20
.1a0743	a5 27		lda $0827	                LDA ARGTYPE1                ; Check ARGUMENT1
.1a0745	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a0747	f0 23		beq $1a076c	                BEQ arg1_int
.1a0749	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.1a074b	f0 2e		beq $1a077b	                BEQ arg1_float
.1a074d					type_err
.1a074d	08		php		            PHP
.1a074e	c2 20		rep #$20	            REP #$20
.1a0750	48		pha		            PHA
.1a0751	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0754	5b		tcd		            TCD
.1a0755	68		pla		            PLA
.1a0756	28		plp		            PLP
.1a0757	e2 20		sep #$20	            SEP #$20
.1a0759	a9 04		lda #$04	            LDA #ERR_TYPE
.1a075b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a075f	c2 20		rep #$20	            REP #$20
.1a0761	29 ff 00	and #$00ff	            AND #$00FF
.1a0764	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a0767	e2 20		sep #$20	            SEP #$20
.1a0769	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a076c	a5 2d		lda $082d	arg1_int        LDA ARGTYPE2                ; Check argument 2
.1a076e	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If integer, we're done
.1a0770	f0 16		beq $1a0788	                BEQ done
.1a0772	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If not float, throw an error
.1a0774	d0 d7		bne $1a074d	                BNE type_err
.1a0776	20 b0 59	jsr $1a59b0	            JSR ITOF
.1a0779	80 0d		bra $1a0788	                BRA done
.1a077b	a5 2d		lda $082d	arg1_float      LDA ARGTYPE2                ; Check argument 2
.1a077d	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If it's float
.1a077f	f0 07		beq $1a0788	                BEQ done                    ; Then we're done
.1a0781	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If it's not integer
.1a0783	d0 c8		bne $1a074d	                BNE type_err                ; Thrown an error
.1a0785	20 0c 07	jsr $1a070c	            JSR CAST_ARG2_FLOAT
.1a0788					done
.1a0788	e2 20		sep #$20	            SEP #$20
.1a078a	a5 27		lda $0827	                LDA ARGTYPE1                ; Return the type code in A
.1a078c	28		plp		                PLP
.1a078d	60		rts		            RTS
.1a078e					ASS_ARGS_NUMSTR
.1a078e	08		php		                PHP
.1a078f	e2 20		sep #$20	            SEP #$20
.1a0791	a5 27		lda $0827	                LDA ARGTYPE1                ; Check to see if ARGUMENT1 is a string
.1a0793	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a0795	d0 25		bne $1a07bc	                BNE numbers
.1a0797	a5 2d		lda $082d	                LDA ARGTYPE2                ; If ARGUMENT1 is a string, make sure ARGUMENT2 is
.1a0799	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a079b	f0 24		beq $1a07c1	                BEQ done
.1a079d					TYPE_ERR
.1a079d	08		php		            PHP
.1a079e	c2 20		rep #$20	            REP #$20
.1a07a0	48		pha		            PHA
.1a07a1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a07a4	5b		tcd		            TCD
.1a07a5	68		pla		            PLA
.1a07a6	28		plp		            PLP
.1a07a7	e2 20		sep #$20	            SEP #$20
.1a07a9	a9 04		lda #$04	            LDA #ERR_TYPE
.1a07ab	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a07af	c2 20		rep #$20	            REP #$20
.1a07b1	29 ff 00	and #$00ff	            AND #$00FF
.1a07b4	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a07b7	e2 20		sep #$20	            SEP #$20
.1a07b9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a07bc					numbers
.1a07bc	20 40 07	jsr $1a0740	            JSR ASS_ARGS_NUM
.1a07bf	a5 27		lda $0827	                LDA ARGTYPE1                ; Make sure A is the type
.1a07c1	28		plp		done            PLP
.1a07c2	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\tokens.s

.0000					TOKEN
>0000					precedence  .byte ?
>0001					length      .byte ?
>0002					name        .word <>?
>0004					eval        .word <>?
>0006					arity       .word <>?
.1a07c3					PARSEINT
.1a07c3	08		php		            PHP
.1a07c4	0b		phd		            PHD
.1a07c5	08		php		            PHP
.1a07c6	c2 20		rep #$20	            REP #$20
.1a07c8	48		pha		            PHA
.1a07c9	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a07cc	5b		tcd		            TCD
.1a07cd	68		pla		            PLA
.1a07ce	28		plp		            PLP
.1a07cf	c2 30		rep #$30	            REP #$30
.1a07d1	64 23		stz $0823	            STZ ARGUMENT1       ; Default to Not-a-value
.1a07d3	64 25		stz $0825	            STZ ARGUMENT1+2
.1a07d5	e2 20		sep #$20	            SEP #$20
.1a07d7	64 27		stz $0827	            STZ ARGTYPE1
.1a07d9	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it starts with '$'
.1a07db	c9 26		cmp #$26	            CMP #'&'
.1a07dd	f0 44		beq $1a0823	            BEQ check_hex       ; Yes: parse it as a hexadecimal number
.1a07df					loop
.1a07df	e2 20		sep #$20	            SEP #$20
.1a07e1	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.1a07e3	20 e6 03	jsr $1a03e6	            JSR ISNUMERAL
.1a07e6	90 76		bcc $1a085e	            BCC done            ; No, we're done parsing
.1a07e8	20 65 04	jsr $1a0465	            JSR MULINT10
.1a07eb	38		sec		            SEC                 ; Convert the ASCII code to a number
.1a07ec	e9 30		sbc #$30	            SBC #'0'
.1a07ee	c2 20		rep #$20	            REP #$20
.1a07f0	29 ff 00	and #$00ff	            AND #$00FF
.1a07f3	18		clc		            CLC
.1a07f4	65 23		adc $0823	            ADC ARGUMENT1
.1a07f6	85 23		sta $0823	            STA ARGUMENT1
.1a07f8	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a07fa	69 00 00	adc #$0000	            ADC #0
.1a07fd	85 25		sta $0825	            STA ARGUMENT1+2
.1a07ff	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a0802	80 db		bra $1a07df	            BRA loop            ; And try to process it
.1a0804					syntaxerr
.1a0804	08		php		            PHP
.1a0805	c2 20		rep #$20	            REP #$20
.1a0807	48		pha		            PHA
.1a0808	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a080b	5b		tcd		            TCD
.1a080c	68		pla		            PLA
.1a080d	28		plp		            PLP
.1a080e	e2 20		sep #$20	            SEP #$20
.1a0810	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a0812	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0816	c2 20		rep #$20	            REP #$20
.1a0818	29 ff 00	and #$00ff	            AND #$00FF
.1a081b	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a081e	e2 20		sep #$20	            SEP #$20
.1a0820	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0823					check_hex
.1a0823	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a0826	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.1a0828	c9 48		cmp #$48	            CMP #'H'            ; Is it 'H'?
.1a082a	f0 04		beq $1a0830	            BEQ parse_hex       ; Yes: skip it and parse hex
.1a082c	c9 68		cmp #$68	            CMP #'h'            ; Is it 'h'?
.1a082e	d0 d4		bne $1a0804	            BNE syntaxerr       ; No: throw an error
.1a0830					parse_hex
.1a0830	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a0833					hexloop
.1a0833	e2 20		sep #$20	            SEP #$20
.1a0835	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.1a0837	20 f7 03	jsr $1a03f7	            JSR ISHEX
.1a083a	90 22		bcc $1a085e	            BCC done            ; No, we're done parsing
.1a083c	20 18 04	jsr $1a0418	            JSR HEX2BIN
.1a083f	c2 20		rep #$20	            REP #$20
.1a0841	06 23		asl $0823	            ASL ARGUMENT1
.1a0843	26 25		rol $0825	            ROL ARGUMENT1+2
.1a0845	06 23		asl $0823	            ASL ARGUMENT1
.1a0847	26 25		rol $0825	            ROL ARGUMENT1+2
.1a0849	06 23		asl $0823	            ASL ARGUMENT1
.1a084b	26 25		rol $0825	            ROL ARGUMENT1+2
.1a084d	06 23		asl $0823	            ASL ARGUMENT1
.1a084f	26 25		rol $0825	            ROL ARGUMENT1+2
.1a0851	29 ff 00	and #$00ff	            AND #$00FF          ; Add binary number to ARGUMENT1
.1a0854	18		clc		            CLC
.1a0855	65 23		adc $0823	            ADC ARGUMENT1
.1a0857	85 23		sta $0823	            STA ARGUMENT1
.1a0859	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a085c	80 d5		bra $1a0833	            BRA hexloop         ; And try to process it
.1a085e	2b		pld		done        PLD
.1a085f	28		plp		            PLP
.1a0860	60		rts		            RTS
.1a0861					PREVCHAR
.1a0861	08		php		            PHP
.1a0862	c2 30		rep #$30	            REP #$30
.1a0864	a5 04		lda $0804	            LDA BIPPREV
.1a0866	f0 1c		beq $1a0884	            BEQ ret_false
.1a0868	38		sec		            SEC
.1a0869	a5 04		lda $0804	            LDA BIPPREV
.1a086b	e5 1a		sbc $081a	            SBC CURLINE
.1a086d	a8		tay		            TAY
.1a086e	e2 20		sep #$20	            SEP #$20
.1a0870	b7 1a		lda [$081a],y	loop        LDA [CURLINE],Y
.1a0872	f0 10		beq $1a0884	            BEQ ret_false
.1a0874	c9 20		cmp #$20	            CMP #CHAR_SP
.1a0876	f0 06		beq $1a087e	            BEQ go_back
.1a0878	c9 09		cmp #$09	            CMP #CHAR_TAB
.1a087a	f0 02		beq $1a087e	            BEQ go_back
.1a087c	28		plp		            PLP
.1a087d	60		rts		            RTS
.1a087e	88		dey		go_back     DEY
.1a087f	c0 ff ff	cpy #$ffff	            CPY #$FFFF
.1a0882	d0 ec		bne $1a0870	            BNE loop
.1a0884					ret_false
.1a0884	a9 00		lda #$00	            LDA #0
.1a0886	60		rts		            RTS
.1a0887					TOKENIZE
.1a0887	08		php		            PHP
.1a0888	0b		phd		            PHD
.1a0889	08		php		            PHP
.1a088a	c2 20		rep #$20	            REP #$20
.1a088c	48		pha		            PHA
.1a088d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0890	5b		tcd		            TCD
.1a0891	68		pla		            PLA
.1a0892	28		plp		            PLP
.1a0893	c2 30		rep #$30	            REP #$30
.1a0895	a5 1a		lda $081a	            LDA CURLINE
.1a0897	85 00		sta $0800	            STA BIP
.1a0899	e2 20		sep #$20	            SEP #$20
.1a089b	a5 1c		lda $081c	            LDA CURLINE+2
.1a089d	85 02		sta $0802	            STA BIP+2
.1a089f	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a08a2	a7 00		lda [$0800]	            LDA [BIP]               ; Do we have a numeral?
.1a08a4	20 e6 03	jsr $1a03e6	            JSR ISNUMERAL
.1a08a7	90 0c		bcc $1a08b5	            BCC mv_curline          ; No: adjust CURLINE and tokenize
.1a08a9	20 c3 07	jsr $1a07c3	            JSR PARSEINT
.1a08ac	c2 20		rep #$20	            REP #$20
.1a08ae	a5 23		lda $0823	            LDA ARGUMENT1
.1a08b0	85 d7		sta $08d7	            STA LINENUM
.1a08b2	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a08b5					mv_curline
.1a08b5	c2 20		rep #$20	            REP #$20
.1a08b7	a5 00		lda $0800	            LDA BIP
.1a08b9	85 1a		sta $081a	            STA CURLINE
.1a08bb	e2 20		sep #$20	            SEP #$20
.1a08bd	a5 02		lda $0802	            LDA BIP+2
.1a08bf	85 1c		sta $081c	            STA CURLINE+2
.1a08c1	20 d5 08	jsr $1a08d5	            JSR FINDREM
.1a08c4	e2 20		sep #$20	            SEP #$20
.1a08c6					loop
.1a08c6	20 46 09	jsr $1a0946	            JSR TKFINDTOKEN
.1a08c9	c9 00		cmp #$00	            CMP #0                  ; Did we find a token?
.1a08cb	f0 05		beq $1a08d2	            BEQ done                ; No: return
.1a08cd	20 f4 0a	jsr $1a0af4	            JSR TKWRITE
.1a08d0	80 f4		bra $1a08c6	            BRA loop                ; And try again
.1a08d2	2b		pld		done        PLD
.1a08d3	28		plp		            PLP
.1a08d4	60		rts		            RTS
.1a08d5					FINDREM
.1a08d5	08		php		            PHP
.1a08d6	c2 20		rep #$20	            REP #$20
.1a08d8	a5 1a		lda $081a	            LDA CURLINE             ; Point BIP to the beginning of the line
.1a08da	85 00		sta $0800	            STA BIP
.1a08dc	a5 1c		lda $081c	            LDA CURLINE+2
.1a08de	85 02		sta $0802	            STA BIP+2
.1a08e0	a2 00 00	ldx #$0000	            LDX #0                  ; X will be a flag that we're at the beginning
.1a08e3	e2 20		sep #$20	            SEP #$20
.1a08e5	a0 00 00	ldy #$0000	loop        LDY #0
.1a08e8	e0 00 00	cpx #$0000	            CPX #0                  ; If we are at the first space on the line
.1a08eb	f0 0d		beq $1a08fa	            BEQ skip_delim          ; ... skip looking for a delimiter
.1a08ed	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a08ef	f0 53		beq $1a0944	            BEQ done                ; Is it null? Then we're done
.1a08f1	c9 3a		cmp #$3a	            CMP #':'                ; Is it ":"
.1a08f3	f0 04		beq $1a08f9	            BEQ found_delim         ; Yes: we might have a REM... look for E
.1a08f5	c9 20		cmp #$20	            CMP #CHAR_SP
.1a08f7	d0 33		bne $1a092c	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a08f9	c8		iny		found_delim INY
.1a08fa	b7 00		lda [$0800],y	skip_delim  LDA [BIP],Y             ; Get the first character
.1a08fc	f0 46		beq $1a0944	            BEQ done                ; Is it null? Then we're done
.1a08fe	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.1a0900	f0 10		beq $1a0912	            BEQ found_R             ; Yes: we might have a REM... look for E
.1a0902	c9 72		cmp #$72	            CMP #'r'
.1a0904	d0 26		bne $1a092c	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a0906	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a0908	f0 3a		beq $1a0944	            BEQ done                ; Is it null? Then we're done
.1a090a	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.1a090c	f0 04		beq $1a0912	            BEQ found_R             ; Yes: we might have a REM... look for E
.1a090e	c9 72		cmp #$72	            CMP #'r'
.1a0910	d0 1a		bne $1a092c	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a0912	c8		iny		found_R     INY
.1a0913	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a0915	f0 2d		beq $1a0944	            BEQ done                ; Is it null? Then we're done
.1a0917	c9 45		cmp #$45	            CMP #'E'                ; Is it "E"
.1a0919	f0 04		beq $1a091f	            BEQ found_E             ; Yes: we might have a REM... look for M
.1a091b	c9 65		cmp #$65	            CMP #'e'
.1a091d	d0 0d		bne $1a092c	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a091f	c8		iny		found_E     INY
.1a0920	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a0922	f0 20		beq $1a0944	            BEQ done                ; Is it null? Then we're done
.1a0924	c9 4d		cmp #$4d	            CMP #'M'                ; Is it "E"
.1a0926	f0 0a		beq $1a0932	            BEQ found_REM           ; Yes: we might have a REM... look for M
.1a0928	c9 6d		cmp #$6d	            CMP #'m'
.1a092a	f0 06		beq $1a0932	            BEQ found_REM
.1a092c	e8		inx		next_pos    INX                     ; Indicate we're no longer at the first position
.1a092d	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a0930	80 b3		bra $1a08e5	            BRA loop
.1a0932	a7 00		lda [$0800]	found_REM   LDA [BIP]               ; Get the current character
.1a0934	c9 3a		cmp #$3a	            CMP #':'                ; Is it the delimiter?
.1a0936	d0 03		bne $1a093b	            BNE ret_REM             ; No: go ahead and return REM at that location
.1a0938	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a093b	a9 03		lda #$03	ret_REM     LDA #3
.1a093d	85 1e		sta $081e	            STA CURTOKLEN           ; Set the size
.1a093f	a9 91		lda #$91	            LDA #TOK_REM            ; And the token to write
.1a0941	20 f4 0a	jsr $1a0af4	            JSR TKWRITE
.1a0944	28		plp		done        PLP
.1a0945	60		rts		            RTS
.1a0946					TKFINDTOKEN
.1a0946	08		php		            PHP
.1a0947	0b		phd		            PHD
.1a0948	08		php		            PHP
.1a0949	c2 20		rep #$20	            REP #$20
.1a094b	48		pha		            PHA
.1a094c	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a094f	5b		tcd		            TCD
.1a0950	68		pla		            PLA
.1a0951	28		plp		            PLP
.1a0952	e2 20		sep #$20	            SEP #$20
.1a0954	a9 7f		lda #$7f	            LDA #$7F                ; Start off looking for any size token
.1a0956	85 1e		sta $081e	            STA CURTOKLEN
.1a0958					next_size
.1a0958	c2 10		rep #$10	            REP #$10
.1a095a	20 a9 0a	jsr $1a0aa9	            JSR TKNEXTBIG
.1a095d	a5 1e		lda $081e	            LDA CURTOKLEN           ; Are there any keywords left?
.1a095f	d0 03		bne $1a0964	            BNE else
.1a0961	4c e9 09	jmp $1a09e9	            JMP done                ; No: return to caller
.1a0964					else
.1a0964	c2 20		rep #$20	            REP #$20
.1a0966	a5 1a		lda $081a	            LDA CURLINE
.1a0968	85 00		sta $0800	            STA BIP
.1a096a	e2 20		sep #$20	            SEP #$20
.1a096c	a5 1c		lda $081c	            LDA CURLINE+2
.1a096e	85 02		sta $0802	            STA BIP+2
.1a0970	c2 20		rep #$20	            REP #$20
.1a0972	64 04		stz $0804	            STZ BIPPREV             ; Clear BIPPREV (point to the previous character)
.1a0974	64 06		stz $0806	            STZ BIPPREV+2
.1a0976					check_len
.1a0976	e2 30		sep #$30	            SEP #$30
.1a0978	a0 00		ldy #$00	            LDY #0
.1a097a	b7 00		lda [$0800],y	nul_scan    LDA [BIP],Y
.1a097c	f0 da		beq $1a0958	            BEQ next_size
.1a097e	c9 91		cmp #$91	            CMP #TOK_REM            ; Tokenization stops at REMarks too
.1a0980	f0 d6		beq $1a0958	            BEQ next_size
.1a0982	c8		iny		            INY
.1a0983	c4 1e		cpy $081e	            CPY CURTOKLEN
.1a0985	90 f3		bcc $1a097a	            BCC nul_scan
.1a0987	c2 10		rep #$10	            REP #$10
.1a0989	a7 00		lda [$0800]	            LDA [BIP]               ; Check the current character
.1a098b	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.1a098d	d0 05		bne $1a0994	            BNE chk_keyword         ; No: check to see if we are at the start of a possible keyword
.1a098f	20 0b 0a	jsr $1a0a0b	            JSR SKIPQUOTED
.1a0992	80 28		bra $1a09bc	            BRA go_next             ; And move on to the next character
.1a0994	a5 1e		lda $081e	chk_keyword LDA CURTOKLEN           ; If the token length is <=2
.1a0996	c9 03		cmp #$03	            CMP #3
.1a0998	90 19		bcc $1a09b3	            BLT try_match           ; ... we don't need a delimiter, go ahead and convert it
.1a099a	c2 20		rep #$20	            REP #$20
.1a099c	a5 00		lda $0800	            LDA BIP                 ; Check to see if we're at the start of the line
.1a099e	c5 1a		cmp $081a	            CMP CURLINE
.1a09a0	d0 08		bne $1a09aa	            BNE chk_delim           ; No: we need to check for a delimiters
.1a09a2	e2 20		sep #$20	            SEP #$20
.1a09a4	a5 02		lda $0802	            LDA BIP+2
.1a09a6	c5 1c		cmp $081c	            CMP CURLINE+2
.1a09a8	f0 09		beq $1a09b3	            BEQ try_match           ; Yes: this can be a keyword
.1a09aa					chk_delim
.1a09aa	e2 20		sep #$20	            SEP #$20
.1a09ac	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.1a09ae	20 f9 4e	jsr $1a4ef9	            JSR ISVARCHAR
.1a09b1	b0 09		bcs $1a09bc	            BCS go_next             ; Yes: we can't start a keyword here
.1a09b3					try_match
.1a09b3	e2 20		sep #$20	            SEP #$20
.1a09b5	20 1b 0a	jsr $1a0a1b	            JSR TKMATCH
.1a09b8	c9 00		cmp #$00	            CMP #0                  ; Did we get one?
.1a09ba	d0 11		bne $1a09cd	            BNE found               ; Yes: return it
.1a09bc					go_next
.1a09bc	c2 20		rep #$20	            REP #$20
.1a09be	a5 00		lda $0800	            LDA BIP                 ; Update BIPPREV as the point to the previous character
.1a09c0	85 04		sta $0804	            STA BIPPREV
.1a09c2	e2 20		sep #$20	            SEP #$20
.1a09c4	a5 02		lda $0802	            LDA BIP+2
.1a09c6	85 06		sta $0806	            STA BIPPREV+2
.1a09c8	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a09cb	80 a9		bra $1a0976	            BRA check_len           ; And try there
.1a09cd					found
.1a09cd	c9 81		cmp #$81	            CMP #TOK_MINUS          ; Found a token... is it minus?
.1a09cf	d0 18		bne $1a09e9	            BNE done                ; Nope: go ahead and return it
.1a09d1	20 61 08	jsr $1a0861	            JSR PREVCHAR
.1a09d4	c9 00		cmp #$00	            CMP #0                  ; Did we get anything?
.1a09d6	f0 14		beq $1a09ec	            BEQ syntax              ; No: line cannot start with minus... throw error
.1a09d8	89 80		bit #$80	            BIT #$80                ; Is it a token?
.1a09da	10 0b		bpl $1a09e7	            BPL binaryminus         ; No: leave token unchanged
.1a09dc	20 95 0b	jsr $1a0b95	            JSR TOKTYPE
.1a09df	c9 30		cmp #$30	            CMP #TOK_TY_FUNC        ; Is it a function?
.1a09e1	f0 04		beq $1a09e7	            BEQ binaryminus         ; Yes: then this should be a binary minus operator
.1a09e3	a9 af		lda #$af	            LDA #TOK_NEGATIVE       ; Otherwise: this should be a unary minus (negation)
.1a09e5	80 02		bra $1a09e9	            BRA done
.1a09e7	a9 81		lda #$81	binaryminus LDA #TOK_MINUS          ; It's data... so token should be for binary minus
.1a09e9					done
.1a09e9	2b		pld		            PLD
.1a09ea	28		plp		            PLP
.1a09eb	60		rts		            RTS
.1a09ec					syntax
.1a09ec	08		php		            PHP
.1a09ed	c2 20		rep #$20	            REP #$20
.1a09ef	48		pha		            PHA
.1a09f0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a09f3	5b		tcd		            TCD
.1a09f4	68		pla		            PLA
.1a09f5	28		plp		            PLP
.1a09f6	e2 20		sep #$20	            SEP #$20
.1a09f8	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a09fa	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a09fe	c2 20		rep #$20	            REP #$20
.1a0a00	29 ff 00	and #$00ff	            AND #$00FF
.1a0a03	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a0a06	e2 20		sep #$20	            SEP #$20
.1a0a08	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0a0b					SKIPQUOTED
.1a0a0b	08		php		            PHP
.1a0a0c	e2 20		sep #$20	            SEP #$20
.1a0a0e					loop
.1a0a0e	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a0a11	a7 00		lda [$0800]	            LDA [BIP]
.1a0a13	f0 04		beq $1a0a19	            BEQ done                ; If EOL, just return
.1a0a15	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.1a0a17	d0 f5		bne $1a0a0e	            BNE loop                ; No: keep skipping
.1a0a19	28		plp		done        PLP
.1a0a1a	60		rts		            RTS
.1a0a1b					TKMATCH
.1a0a1b	da		phx		            PHX
.1a0a1c	5a		phy		            PHY
.1a0a1d	08		php		            PHP
.1a0a1e	0b		phd		            PHD
.1a0a1f	08		php		            PHP
.1a0a20	c2 20		rep #$20	            REP #$20
.1a0a22	48		pha		            PHA
.1a0a23	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0a26	5b		tcd		            TCD
.1a0a27	68		pla		            PLA
.1a0a28	28		plp		            PLP
.1a0a29	c2 20		rep #$20	            REP #$20
.1a0a2b	a5 04		lda $0804	            LDA BIPPREV
.1a0a2d	d0 0a		bne $1a0a39	            BNE check_prev
.1a0a2f	e2 20		sep #$20	            SEP #$20
.1a0a31	a5 04		lda $0804	            LDA BIPPREV
.1a0a33	d0 04		bne $1a0a39	            BNE check_prev
.1a0a35	a9 00		lda #$00	            LDA #0
.1a0a37	80 0a		bra $1a0a43	            BRA save_delim
.1a0a39					check_prev
.1a0a39	e2 20		sep #$20	            SEP #$20
.1a0a3b	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.1a0a3d	20 f9 4e	jsr $1a4ef9	            JSR ISVARCHAR
.1a0a40	a9 00		lda #$00	            LDA #0
.1a0a42	2a		rol a		            ROL A
.1a0a43	85 28		sta $0828	save_delim  STA SIGN1               ; SIGN1 := 1 if it is a variable name character
.1a0a45	c2 30		rep #$30	            REP #$30
.1a0a47	a9 e9 0b	lda #$0be9	            LDA #<>TOKENS           ; Set INDEX to point to the first token record
.1a0a4a	85 08		sta $0808	            STA INDEX
.1a0a4c	e2 20		sep #$20	            SEP #$20
.1a0a4e	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0a50	85 0a		sta $080a	            STA INDEX+2
.1a0a52	a2 80 00	ldx #$0080	            LDX #$80                ; Set the initial token ID
.1a0a55					token_loop
.1a0a55	e2 20		sep #$20	            SEP #$20
.1a0a57	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.1a0a5a	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the current token
.1a0a5c	f0 31		beq $1a0a8f	            BEQ no_match            ; Is it 0? We're out of tokens... no match found
.1a0a5e	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it the same as the size of the window?
.1a0a60	d0 32		bne $1a0a94	            BNE next_token          ; No: try the next token
.1a0a62	c2 30		rep #$30	            REP #$30
.1a0a64	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.1a0a67	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the pointer to the token's name
.1a0a69	85 0c		sta $080c	            STA SCRATCH             ; Set SCRATCH to point to the token's name
.1a0a6b	e2 20		sep #$20	            SEP #$20
.1a0a6d	a9 1a		lda #$1a	            LDA #`DATA_BLOCK
.1a0a6f	85 0e		sta $080e	            STA SCRATCH+2
.1a0a71	a5 28		lda $0828	            LDA SIGN1               ; Is previous character a variable name character?
.1a0a73	f0 07		beq $1a0a7c	            BEQ cmp_keyword         ; No: we can check for this token
.1a0a75	a7 0c		lda [$080c]	            LDA [SCRATCH]           ; Get the token's first character
.1a0a77	20 f9 4e	jsr $1a4ef9	            JSR ISVARCHAR
.1a0a7a	b0 18		bcs $1a0a94	            BCS next_token          ; Yes: skip this token
.1a0a7c					cmp_keyword
.1a0a7c	e2 10		sep #$10	            SEP #$10
.1a0a7e	a0 00		ldy #$00	            LDY #0
.1a0a80	b7 00		lda [$0800],y	cmp_loop    LDA [BIP],Y             ; Get the character in the window
.1a0a82	20 41 04	jsr $1a0441	            JSR TOUPPERA
.1a0a85	d7 0c		cmp [$080c],y	            CMP [SCRATCH],Y         ; Compare to the character in the token
.1a0a87	d0 0b		bne $1a0a94	            BNE next_token          ; If they don't match, try the next token
.1a0a89	c8		iny		            INY                     ; Move to the next character in the window
.1a0a8a	c4 1e		cpy $081e	            CPY CURTOKLEN           ; Have we checked the whole window?
.1a0a8c	90 f2		bcc $1a0a80	            BCC cmp_loop            ; No: check this next character
.1a0a8e	8a		txa		            TXA                     ; Move the token ID to A
.1a0a8f	2b		pld		no_match    PLD
.1a0a90	28		plp		            PLP
.1a0a91	7a		ply		            PLY
.1a0a92	fa		plx		            PLX
.1a0a93	60		rts		            RTS
.1a0a94					next_token
.1a0a94	c2 30		rep #$30	            REP #$30
.1a0a96	18		clc		            CLC
.1a0a97	a5 08		lda $0808	            LDA INDEX
.1a0a99	69 08 00	adc #$0008	            ADC #size(TOKEN)
.1a0a9c	85 08		sta $0808	            STA INDEX
.1a0a9e	e2 20		sep #$20	            SEP #$20
.1a0aa0	a5 0a		lda $080a	            LDA INDEX+2
.1a0aa2	69 00		adc #$00	            ADC #0
.1a0aa4	85 0a		sta $080a	            STA INDEX+2
.1a0aa6	e8		inx		            INX                     ; Increment the token ID
.1a0aa7	80 ac		bra $1a0a55	            BRA token_loop          ; And check that token
.1a0aa9					TKNEXTBIG
.1a0aa9	08		php		            PHP
.1a0aaa	0b		phd		            PHD
.1a0aab	8b		phb		            PHB
.1a0aac	08		php		            PHP
.1a0aad	c2 20		rep #$20	            REP #$20
.1a0aaf	48		pha		            PHA
.1a0ab0	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0ab3	5b		tcd		            TCD
.1a0ab4	68		pla		            PLA
.1a0ab5	28		plp		            PLP
.1a0ab6	c2 30		rep #$30	            REP #$30
.1a0ab8	a9 e9 0b	lda #$0be9	            LDA #<>TOKENS
.1a0abb	85 08		sta $0808	            STA INDEX
.1a0abd	a9 1a 00	lda #$001a	            LDA #`TOKENS
.1a0ac0	85 0a		sta $080a	            STA INDEX+2
.1a0ac2	64 0c		stz $080c	            STZ SCRATCH             ; Clear SCRATCH
.1a0ac4					loop
.1a0ac4	e2 20		sep #$20	            SEP #$20
.1a0ac6	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.1a0ac9	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the token
.1a0acb	f0 1d		beq $1a0aea	            BEQ done                ; If length is 0, we're done
.1a0acd	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it >= CURTOKLEN?
.1a0acf	b0 06		bcs $1a0ad7	            BGE skip                ; Yes: skip to the next token
.1a0ad1	c5 0c		cmp $080c	            CMP SCRATCH             ; No: is it < SCRATCH?
.1a0ad3	90 02		bcc $1a0ad7	            BLT skip                ; Yes: skip to the next token
.1a0ad5	85 0c		sta $080c	            STA SCRATCH             ; No: it's our new longest token!
.1a0ad7					skip
.1a0ad7	c2 20		rep #$20	            REP #$20
.1a0ad9	18		clc		            CLC
.1a0ada	a5 08		lda $0808	            LDA INDEX
.1a0adc	69 08 00	adc #$0008	            ADC #size(TOKEN)
.1a0adf	85 08		sta $0808	            STA INDEX
.1a0ae1	a5 0a		lda $080a	            LDA INDEX+2
.1a0ae3	69 00 00	adc #$0000	            ADC #0
.1a0ae6	85 0a		sta $080a	            STA INDEX+2
.1a0ae8	80 da		bra $1a0ac4	            BRA loop                ; And go around for another pass
.1a0aea					done
.1a0aea	e2 20		sep #$20	            SEP #$20
.1a0aec	a5 0c		lda $080c	            LDA SCRATCH
.1a0aee	85 1e		sta $081e	            STA CURTOKLEN
.1a0af0	ab		plb		            PLB
.1a0af1	2b		pld		            PLD
.1a0af2	28		plp		            PLP
.1a0af3	60		rts		            RTS
.1a0af4					TKWRITE
.1a0af4	08		php		            PHP
.1a0af5	0b		phd		            PHD
.1a0af6	08		php		            PHP
.1a0af7	c2 20		rep #$20	            REP #$20
.1a0af9	48		pha		            PHA
.1a0afa	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0afd	5b		tcd		            TCD
.1a0afe	68		pla		            PLA
.1a0aff	28		plp		            PLP
.1a0b00	e2 20		sep #$20	            SEP #$20
.1a0b02	87 00		sta [$0800]	            STA [BIP]               ; Write the token to the line
.1a0b04	c2 20		rep #$20	            REP #$20
.1a0b06	18		clc		            CLC
.1a0b07	a5 00		lda $0800	            LDA BIP
.1a0b09	69 01 00	adc #$0001	            ADC #1
.1a0b0c	85 08		sta $0808	            STA INDEX
.1a0b0e	a5 02		lda $0802	            LDA BIP+2
.1a0b10	69 00 00	adc #$0000	            ADC #0
.1a0b13	85 0a		sta $080a	            STA INDEX+2
.1a0b15	e2 10		sep #$10	            SEP #$10
.1a0b17	a4 1e		ldy $081e	            LDY CURTOKLEN           ; Y will be the number of characters to move down
.1a0b19	88		dey		            DEY
.1a0b1a					copy_down
.1a0b1a	e2 20		sep #$20	            SEP #$20
.1a0b1c	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the byte to move down
.1a0b1e	87 08		sta [$0808]	            STA [INDEX]             ; Move it down
.1a0b20	f0 13		beq $1a0b35	            BEQ done                ; We've reached the end of the line
.1a0b22	c2 20		rep #$20	            REP #$20
.1a0b24	18		clc		            CLC
.1a0b25	a5 08		lda $0808	            LDA INDEX
.1a0b27	69 01 00	adc #$0001	            ADC #1
.1a0b2a	85 08		sta $0808	            STA INDEX
.1a0b2c	a5 0a		lda $080a	            LDA INDEX+2
.1a0b2e	69 00 00	adc #$0000	            ADC #0
.1a0b31	85 0a		sta $080a	            STA INDEX+2
.1a0b33	80 e5		bra $1a0b1a	            BRA copy_down
.1a0b35	2b		pld		done        PLD
.1a0b36	28		plp		            PLP
.1a0b37	60		rts		            RTS
.1a0b38					GETTOKREC
.1a0b38	08		php		            PHP
.1a0b39	c2 30		rep #$30	            REP #$30
.1a0b3b	29 7f 00	and #$007f	            AND #$007F
.1a0b3e	0a		asl a		            ASL A
.1a0b3f	0a		asl a		            ASL A
.1a0b40	0a		asl a		            ASL A
.1a0b41	18		clc		            CLC
.1a0b42	69 e9 0b	adc #$0be9	            ADC #<>TOKENS
.1a0b45	aa		tax		            TAX                         ; X is now the data bank relative address of the token record
.1a0b46	28		plp		            PLP
.1a0b47	60		rts		            RTS
.1a0b48					TOKPRECED
.1a0b48	08		php		            PHP
.1a0b49	8b		phb		            PHB
.1a0b4a	0b		phd		            PHD
.1a0b4b	08		php		            PHP
.1a0b4c	c2 20		rep #$20	            REP #$20
.1a0b4e	48		pha		            PHA
.1a0b4f	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0b52	5b		tcd		            TCD
.1a0b53	68		pla		            PLA
.1a0b54	28		plp		            PLP
.1a0b55	08		php		            PHP
.1a0b56	e2 20		sep #$20	            SEP #$20
.1a0b58	48		pha		            PHA
.1a0b59	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0b5b	48		pha		            PHA
.1a0b5c	ab		plb		            PLB
.1a0b5d	68		pla		            PLA
.1a0b5e	28		plp		            PLP
.1a0b5f	e2 20		sep #$20	            SEP #$20
.1a0b61	c2 10		rep #$10	            REP #$10
.1a0b63	20 38 0b	jsr $1a0b38	            JSR GETTOKREC
.1a0b66	bd 00 00	lda $1a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.1a0b69	c2 20		rep #$20	            REP #$20
.1a0b6b	29 0f 00	and #$000f	            AND #$000F                  ; Mask off the type code
.1a0b6e	2b		pld		            PLD
.1a0b6f	ab		plb		            PLB
.1a0b70	28		plp		            PLP
.1a0b71	60		rts		            RTS
.1a0b72					TOKEVAL
.1a0b72	08		php		            PHP
.1a0b73	8b		phb		            PHB
.1a0b74	0b		phd		            PHD
.1a0b75	08		php		            PHP
.1a0b76	c2 20		rep #$20	            REP #$20
.1a0b78	48		pha		            PHA
.1a0b79	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0b7c	5b		tcd		            TCD
.1a0b7d	68		pla		            PLA
.1a0b7e	28		plp		            PLP
.1a0b7f	08		php		            PHP
.1a0b80	e2 20		sep #$20	            SEP #$20
.1a0b82	48		pha		            PHA
.1a0b83	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0b85	48		pha		            PHA
.1a0b86	ab		plb		            PLB
.1a0b87	68		pla		            PLA
.1a0b88	28		plp		            PLP
.1a0b89	c2 30		rep #$30	            REP #$30
.1a0b8b	20 38 0b	jsr $1a0b38	            JSR GETTOKREC
.1a0b8e	bd 04 00	lda $1a0004,x	            LDA #TOKEN.eval,B,X         ; Get the address of the evaluation function
.1a0b91	2b		pld		            PLD
.1a0b92	ab		plb		            PLB
.1a0b93	28		plp		            PLP
.1a0b94	60		rts		            RTS
.1a0b95					TOKTYPE
.1a0b95	08		php		            PHP
.1a0b96	8b		phb		            PHB
.1a0b97	0b		phd		            PHD
.1a0b98	08		php		            PHP
.1a0b99	c2 20		rep #$20	            REP #$20
.1a0b9b	48		pha		            PHA
.1a0b9c	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0b9f	5b		tcd		            TCD
.1a0ba0	68		pla		            PLA
.1a0ba1	28		plp		            PLP
.1a0ba2	08		php		            PHP
.1a0ba3	e2 20		sep #$20	            SEP #$20
.1a0ba5	48		pha		            PHA
.1a0ba6	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0ba8	48		pha		            PHA
.1a0ba9	ab		plb		            PLB
.1a0baa	68		pla		            PLA
.1a0bab	28		plp		            PLP
.1a0bac	e2 20		sep #$20	            SEP #$20
.1a0bae	c2 10		rep #$10	            REP #$10
.1a0bb0	20 38 0b	jsr $1a0b38	            JSR GETTOKREC
.1a0bb3	bd 00 00	lda $1a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.1a0bb6	c2 20		rep #$20	            REP #$20
.1a0bb8	29 f0 00	and #$00f0	            AND #$00F0                  ; Mask off the type code
.1a0bbb	2b		pld		            PLD
.1a0bbc	ab		plb		            PLB
.1a0bbd	28		plp		            PLP
.1a0bbe	60		rts		            RTS
.1a0bbf					TOKARITY
.1a0bbf	08		php		            PHP
.1a0bc0	8b		phb		            PHB
.1a0bc1	0b		phd		            PHD
.1a0bc2	08		php		            PHP
.1a0bc3	c2 20		rep #$20	            REP #$20
.1a0bc5	48		pha		            PHA
.1a0bc6	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0bc9	5b		tcd		            TCD
.1a0bca	68		pla		            PLA
.1a0bcb	28		plp		            PLP
.1a0bcc	08		php		            PHP
.1a0bcd	e2 20		sep #$20	            SEP #$20
.1a0bcf	48		pha		            PHA
.1a0bd0	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0bd2	48		pha		            PHA
.1a0bd3	ab		plb		            PLB
.1a0bd4	68		pla		            PLA
.1a0bd5	28		plp		            PLP
.1a0bd6	e2 20		sep #$20	            SEP #$20
.1a0bd8	c2 10		rep #$10	            REP #$10
.1a0bda	20 38 0b	jsr $1a0b38	            JSR GETTOKREC
.1a0bdd	bd 06 00	lda $1a0006,x	            LDA #TOKEN.arity,B,X        ; Get the arity
.1a0be0	c2 20		rep #$20	            REP #$20
.1a0be2	29 ff 00	and #$00ff	            AND #$00FF
.1a0be5	2b		pld		            PLD
.1a0be6	ab		plb		            PLB
.1a0be7	28		plp		            PLP
.1a0be8	60		rts		            RTS
=$00					TOK_EOL = $00
=$01					TOK_FUNC_OPEN = $01     ; A pseudo-token to push to the operator stack to mark
=$00					TOK_TY_OP = $00         ; The token is an operator
=$10					TOK_TY_CMD = $10        ; The token is a command (e.g. RUN, LIST, etc.)
=$20					TOK_TY_STMNT = $20      ; The token is a statement (e.g. INPUT, PRINT, DIM, etc.)
=$30					TOK_TY_FUNC = $30       ; The token is a function (e.g. SIN, COS, TAB, etc.)
=$40					TOK_TY_PUNCT = $40      ; The token is a punctuation mark (e.g. "(", ")")
=$50					TOK_TY_BYWRD = $50      ; The token is a by-word (e.g. STEP, TO, WEND, etc.)
.1a0be9					TOKENS
=$80					TOK_PLUS = $80
>1ad010	2b 00				TOKEN_TEXT  .null "+"
>1a0be9	03				precedence  .byte TOK_TY_OP | 3
>1a0bea	01				length      .byte len("+")
>1a0beb	10 d0				name        .word <>TOKEN_TEXT
>1a0bed	56 26				eval        .word <>OP_PLUS
>1a0bef	02 00				arity       .word <>2
=$81					TOK_MINUS = $81
>1ad012	2d 00				TOKEN_TEXT  .null "-"
>1a0bf1	03				precedence  .byte TOK_TY_OP | 3
>1a0bf2	01				length      .byte len("-")
>1a0bf3	12 d0				name        .word <>TOKEN_TEXT
>1a0bf5	96 26				eval        .word <>OP_MINUS
>1a0bf7	02 00				arity       .word <>2
=$82					TOK_MULT = $82
>1ad014	2a 00				TOKEN_TEXT  .null "*"
>1a0bf9	02				precedence  .byte TOK_TY_OP | 2
>1a0bfa	01				length      .byte len("*")
>1a0bfb	14 d0				name        .word <>TOKEN_TEXT
>1a0bfd	cd 26				eval        .word <>OP_MULTIPLY
>1a0bff	02 00				arity       .word <>2
=$83					TOK_DIVIDE = $83
>1ad016	2f 00				TOKEN_TEXT  .null "/"
>1a0c01	02				precedence  .byte TOK_TY_OP | 2
>1a0c02	01				length      .byte len("/")
>1a0c03	16 d0				name        .word <>TOKEN_TEXT
>1a0c05	04 27				eval        .word <>OP_DIVIDE
>1a0c07	02 00				arity       .word <>2
=$84					TOK_MOD = $84
>1ad018	4d 4f 44 00			TOKEN_TEXT  .null "MOD"
>1a0c09	02				precedence  .byte TOK_TY_OP | 2
>1a0c0a	03				length      .byte len("MOD")
>1a0c0b	18 d0				name        .word <>TOKEN_TEXT
>1a0c0d	0e 27				eval        .word <>OP_MOD
>1a0c0f	02 00				arity       .word <>2
>1ad01c	5e 00				TOKEN_TEXT  .null "^"
>1a0c11	00				precedence  .byte TOK_TY_OP | 0
>1a0c12	01				length      .byte len("^")
>1a0c13	1c d0				name        .word <>TOKEN_TEXT
>1a0c15	21 27				eval        .word <>OP_POW
>1a0c17	02 00				arity       .word <>2
=$86					TOK_LE = $86
>1ad01e	3c 3d 00			TOKEN_TEXT  .null "<="
>1a0c19	04				precedence  .byte TOK_TY_OP | 4
>1a0c1a	02				length      .byte len("<=")
>1a0c1b	1e d0				name        .word <>TOKEN_TEXT
>1a0c1d	df 28				eval        .word <>OP_LTE
>1a0c1f	02 00				arity       .word <>2
=$87					TOK_GE = $87
>1ad021	3e 3d 00			TOKEN_TEXT  .null ">="
>1a0c21	04				precedence  .byte TOK_TY_OP | 4
>1a0c22	02				length      .byte len(">=")
>1a0c23	21 d0				name        .word <>TOKEN_TEXT
>1a0c25	9f 28				eval        .word <>OP_GTE
>1a0c27	02 00				arity       .word <>2
=$88					TOK_NE = $88
>1ad024	3c 3e 00			TOKEN_TEXT  .null "<>"
>1a0c29	04				precedence  .byte TOK_TY_OP | 4
>1a0c2a	02				length      .byte len("<>")
>1a0c2b	24 d0				name        .word <>TOKEN_TEXT
>1a0c2d	5f 28				eval        .word <>OP_NE
>1a0c2f	02 00				arity       .word <>2
>1ad027	3c 00				TOKEN_TEXT  .null "<"
>1a0c31	04				precedence  .byte TOK_TY_OP | 4
>1a0c32	01				length      .byte len("<")
>1a0c33	27 d0				name        .word <>TOKEN_TEXT
>1a0c35	9f 27				eval        .word <>OP_LT
>1a0c37	02 00				arity       .word <>2
=$8a					TOK_EQ = $8A
>1ad029	3d 00				TOKEN_TEXT  .null "="
>1a0c39	04				precedence  .byte TOK_TY_OP | 4
>1a0c3a	01				length      .byte len("=")
>1a0c3b	29 d0				name        .word <>TOKEN_TEXT
>1a0c3d	1f 28				eval        .word <>OP_EQ
>1a0c3f	02 00				arity       .word <>2
>1ad02b	3e 00				TOKEN_TEXT  .null ">"
>1a0c41	04				precedence  .byte TOK_TY_OP | 4
>1a0c42	01				length      .byte len(">")
>1a0c43	2b d0				name        .word <>TOKEN_TEXT
>1a0c45	df 27				eval        .word <>OP_GT
>1a0c47	02 00				arity       .word <>2
>1ad02d	4e 4f 54 00			TOKEN_TEXT  .null "NOT"
>1a0c49	05				precedence  .byte TOK_TY_OP | 5
>1a0c4a	03				length      .byte len("NOT")
>1a0c4b	2d d0				name        .word <>TOKEN_TEXT
>1a0c4d	89 27				eval        .word <>OP_NOT
>1a0c4f	01 00				arity       .word <>1
>1ad031	41 4e 44 00			TOKEN_TEXT  .null "AND"
>1a0c51	06				precedence  .byte TOK_TY_OP | 6
>1a0c52	03				length      .byte len("AND")
>1a0c53	31 d0				name        .word <>TOKEN_TEXT
>1a0c55	5b 27				eval        .word <>OP_AND
>1a0c57	02 00				arity       .word <>2
>1ad035	4f 52 00			TOKEN_TEXT  .null "OR"
>1a0c59	07				precedence  .byte TOK_TY_OP | 7
>1a0c5a	02				length      .byte len("OR")
>1a0c5b	35 d0				name        .word <>TOKEN_TEXT
>1a0c5d	72 27				eval        .word <>OP_OR
>1a0c5f	02 00				arity       .word <>2
=$8f					TOK_LPAREN = $8F
>1ad038	28 00				TOKEN_TEXT  .null "("
>1a0c61	ff				precedence  .byte TOK_TY_PUNCT | $FF
>1a0c62	01				length      .byte len("(")
>1a0c63	38 d0				name        .word <>TOKEN_TEXT
>1a0c65	00 00				eval        .word <>0
>1a0c67	00 00				arity       .word <>0
=$90					TOK_RPAREN = $90
>1ad03a	29 00				TOKEN_TEXT  .null ")"
>1a0c69	40				precedence  .byte TOK_TY_PUNCT | 0
>1a0c6a	01				length      .byte len(")")
>1a0c6b	3a d0				name        .word <>TOKEN_TEXT
>1a0c6d	00 00				eval        .word <>0
>1a0c6f	00 00				arity       .word <>0
=$91					TOK_REM = $91
>1ad03c	52 45 4d 00			TOKEN_TEXT  .null "REM"
>1a0c71	20				precedence  .byte TOK_TY_STMNT | 0
>1a0c72	03				length      .byte len("REM")
>1a0c73	3c d0				name        .word <>TOKEN_TEXT
>1a0c75	a5 3f				eval        .word <>S_REM
>1a0c77	00 00				arity       .word <>0
=$92					TOK_PRINT = $92
>1ad040	50 52 49 4e 54 00		TOKEN_TEXT  .null "PRINT"
>1a0c79	20				precedence  .byte TOK_TY_STMNT | 0
>1a0c7a	05				length      .byte len("PRINT")
>1a0c7b	40 d0				name        .word <>TOKEN_TEXT
>1a0c7d	aa 43				eval        .word <>S_PRINT
>1a0c7f	00 00				arity       .word <>0
=$93					TOK_LET = $93
>1ad046	4c 45 54 00			TOKEN_TEXT  .null "LET"
>1a0c81	20				precedence  .byte TOK_TY_STMNT | 0
>1a0c82	03				length      .byte len("LET")
>1a0c83	46 d0				name        .word <>TOKEN_TEXT
>1a0c85	f5 42				eval        .word <>S_LET
>1a0c87	00 00				arity       .word <>0
>1ad04a	47 4f 54 4f 00			TOKEN_TEXT  .null "GOTO"
>1a0c89	20				precedence  .byte TOK_TY_STMNT | 0
>1a0c8a	04				length      .byte len("GOTO")
>1a0c8b	4a d0				name        .word <>TOKEN_TEXT
>1a0c8d	95 42				eval        .word <>S_GOTO
>1a0c8f	00 00				arity       .word <>0
=$95					TOK_END = $95
>1ad04f	45 4e 44 00			TOKEN_TEXT  .null "END"
>1a0c91	20				precedence  .byte TOK_TY_STMNT | 0
>1a0c92	03				length      .byte len("END")
>1a0c93	4f d0				name        .word <>TOKEN_TEXT
>1a0c95	8c 42				eval        .word <>S_END
>1a0c97	00 00				arity       .word <>0
>1ad053	49 46 00			TOKEN_TEXT  .null "IF"
>1a0c99	20				precedence  .byte TOK_TY_STMNT | 0
>1a0c9a	02				length      .byte len("IF")
>1a0c9b	53 d0				name        .word <>TOKEN_TEXT
>1a0c9d	24 42				eval        .word <>S_IF
>1a0c9f	00 00				arity       .word <>0
=$97					TOK_THEN = $97
>1ad056	54 48 45 4e 00			TOKEN_TEXT  .null "THEN"
>1a0ca1	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0ca2	04				length      .byte len("THEN")
>1a0ca3	56 d0				name        .word <>TOKEN_TEXT
>1a0ca5	00 00				eval        .word <>0
>1a0ca7	00 00				arity       .word <>0
>1ad05b	45 4c 53 45 00			TOKEN_TEXT  .null "ELSE"
>1a0ca9	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0caa	04				length      .byte len("ELSE")
>1a0cab	5b d0				name        .word <>TOKEN_TEXT
>1a0cad	00 00				eval        .word <>0
>1a0caf	00 00				arity       .word <>0
>1ad060	47 4f 53 55 42 00		TOKEN_TEXT  .null "GOSUB"
>1a0cb1	20				precedence  .byte TOK_TY_STMNT | 0
>1a0cb2	05				length      .byte len("GOSUB")
>1a0cb3	60 d0				name        .word <>TOKEN_TEXT
>1a0cb5	67 41				eval        .word <>S_GOSUB
>1a0cb7	00 00				arity       .word <>0
>1ad066	52 45 54 55 52 4e 00		TOKEN_TEXT  .null "RETURN"
>1a0cb9	20				precedence  .byte TOK_TY_STMNT | 0
>1a0cba	06				length      .byte len("RETURN")
>1a0cbb	66 d0				name        .word <>TOKEN_TEXT
>1a0cbd	e0 41				eval        .word <>S_RETURN
>1a0cbf	00 00				arity       .word <>0
=$9b					TOK_FOR = $9B
>1ad06d	46 4f 52 00			TOKEN_TEXT  .null "FOR"
>1a0cc1	20				precedence  .byte TOK_TY_STMNT | 0
>1a0cc2	03				length      .byte len("FOR")
>1a0cc3	6d d0				name        .word <>TOKEN_TEXT
>1a0cc5	bc 3f				eval        .word <>S_FOR
>1a0cc7	00 00				arity       .word <>0
=$9c					TOK_TO = $9C
>1ad071	54 4f 00			TOKEN_TEXT  .null "TO"
>1a0cc9	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0cca	02				length      .byte len("TO")
>1a0ccb	71 d0				name        .word <>TOKEN_TEXT
>1a0ccd	00 00				eval        .word <>0
>1a0ccf	00 00				arity       .word <>0
=$9d					TOK_STEP = $9D
>1ad074	53 54 45 50 00			TOKEN_TEXT  .null "STEP"
>1a0cd1	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0cd2	04				length      .byte len("STEP")
>1a0cd3	74 d0				name        .word <>TOKEN_TEXT
>1a0cd5	00 00				eval        .word <>0
>1a0cd7	00 00				arity       .word <>0
=$9e					TOK_NEXT = $9E
>1ad079	4e 45 58 54 00			TOKEN_TEXT  .null "NEXT"
>1a0cd9	20				precedence  .byte TOK_TY_STMNT | 0
>1a0cda	04				length      .byte len("NEXT")
>1a0cdb	79 d0				name        .word <>TOKEN_TEXT
>1a0cdd	b0 40				eval        .word <>S_NEXT
>1a0cdf	00 00				arity       .word <>0
=$9f					TOK_DO = $9F
>1ad07e	44 4f 00			TOKEN_TEXT  .null "DO"
>1a0ce1	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ce2	02				length      .byte len("DO")
>1a0ce3	7e d0				name        .word <>TOKEN_TEXT
>1a0ce5	b6 3f				eval        .word <>S_DO
>1a0ce7	00 00				arity       .word <>0
=$a0					TOK_LOOP = $A0
>1ad081	4c 4f 4f 50 00			TOKEN_TEXT  .null "LOOP"
>1a0ce9	20				precedence  .byte TOK_TY_STMNT | 0
>1a0cea	04				length      .byte len("LOOP")
>1a0ceb	81 d0				name        .word <>TOKEN_TEXT
>1a0ced	b9 3f				eval        .word <>S_LOOP
>1a0cef	00 00				arity       .word <>0
>1ad086	57 48 49 4c 45 00		TOKEN_TEXT  .null "WHILE"
>1a0cf1	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0cf2	05				length      .byte len("WHILE")
>1a0cf3	86 d0				name        .word <>TOKEN_TEXT
>1a0cf5	00 00				eval        .word <>0
>1a0cf7	00 00				arity       .word <>0
>1ad08c	55 4e 54 49 4c 00		TOKEN_TEXT  .null "UNTIL"
>1a0cf9	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0cfa	05				length      .byte len("UNTIL")
>1a0cfb	8c d0				name        .word <>TOKEN_TEXT
>1a0cfd	00 00				eval        .word <>0
>1a0cff	00 00				arity       .word <>0
>1ad092	45 58 49 54 00			TOKEN_TEXT  .null "EXIT"
>1a0d01	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d02	04				length      .byte len("EXIT")
>1a0d03	92 d0				name        .word <>TOKEN_TEXT
>1a0d05	b3 3f				eval        .word <>S_EXIT
>1a0d07	00 00				arity       .word <>0
>1ad097	43 4c 52 00			TOKEN_TEXT  .null "CLR"
>1a0d09	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d0a	03				length      .byte len("CLR")
>1a0d0b	97 d0				name        .word <>TOKEN_TEXT
>1a0d0d	eb 42				eval        .word <>S_CLR
>1a0d0f	00 00				arity       .word <>0
>1ad09b	53 54 4f 50 00			TOKEN_TEXT  .null "STOP"
>1a0d11	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d12	04				length      .byte len("STOP")
>1a0d13	9b d0				name        .word <>TOKEN_TEXT
>1a0d15	86 3f				eval        .word <>S_STOP
>1a0d17	00 00				arity       .word <>0
>1ad0a0	50 4f 4b 45 00			TOKEN_TEXT  .null "POKE"
>1a0d19	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d1a	04				length      .byte len("POKE")
>1a0d1b	a0 d0				name        .word <>TOKEN_TEXT
>1a0d1d	16 3f				eval        .word <>S_POKE
>1a0d1f	00 00				arity       .word <>0
>1ad0a5	50 4f 4b 45 57 00		TOKEN_TEXT  .null "POKEW"
>1a0d21	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d22	05				length      .byte len("POKEW")
>1a0d23	a5 d0				name        .word <>TOKEN_TEXT
>1a0d25	ac 3e				eval        .word <>S_POKEW
>1a0d27	00 00				arity       .word <>0
>1ad0ab	50 4f 4b 45 4c 00		TOKEN_TEXT  .null "POKEL"
>1a0d29	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d2a	05				length      .byte len("POKEL")
>1a0d2b	ab d0				name        .word <>TOKEN_TEXT
>1a0d2d	39 3e				eval        .word <>S_POKEL
>1a0d2f	00 00				arity       .word <>0
>1ad0b1	43 4c 53 00			TOKEN_TEXT  .null "CLS"
>1a0d31	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d32	03				length      .byte len("CLS")
>1a0d33	b1 d0				name        .word <>TOKEN_TEXT
>1a0d35	35 3e				eval        .word <>S_CLS
>1a0d37	00 00				arity       .word <>0
>1ad0b5	52 45 41 44 00			TOKEN_TEXT  .null "READ"
>1a0d39	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d3a	04				length      .byte len("READ")
>1a0d3b	b5 d0				name        .word <>TOKEN_TEXT
>1a0d3d	16 3d				eval        .word <>S_READ
>1a0d3f	00 00				arity       .word <>0
=$ab					TOK_DATA = $AB
>1ad0ba	44 41 54 41 00			TOKEN_TEXT  .null "DATA"
>1a0d41	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d42	04				length      .byte len("DATA")
>1a0d43	ba d0				name        .word <>TOKEN_TEXT
>1a0d45	28 3e				eval        .word <>S_DATA
>1a0d47	00 00				arity       .word <>0
>1ad0bf	52 45 53 54 4f 52 45 00		TOKEN_TEXT  .null "RESTORE"
>1a0d49	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d4a	07				length      .byte len("RESTORE")
>1a0d4b	bf d0				name        .word <>TOKEN_TEXT
>1a0d4d	2c 3e				eval        .word <>S_RESTORE
>1a0d4f	00 00				arity       .word <>0
>1ad0c7	44 49 4d 00			TOKEN_TEXT  .null "DIM"
>1a0d51	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d52	03				length      .byte len("DIM")
>1a0d53	c7 d0				name        .word <>TOKEN_TEXT
>1a0d55	69 3c				eval        .word <>S_DIM
>1a0d57	00 00				arity       .word <>0
>1ad0cb	43 41 4c 4c 00			TOKEN_TEXT  .null "CALL"
>1a0d59	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d5a	04				length      .byte len("CALL")
>1a0d5b	cb d0				name        .word <>TOKEN_TEXT
>1a0d5d	d2 3b				eval        .word <>S_CALL
>1a0d5f	00 00				arity       .word <>0
=$af					TOK_NEGATIVE = $AF
>1ad0d0	2d 00				TOKEN_TEXT  .null "-"
>1a0d61	00				precedence  .byte TOK_TY_OP | 0
>1a0d62	01				length      .byte len("-")
>1a0d63	d0 d0				name        .word <>TOKEN_TEXT
>1a0d65	1f 29				eval        .word <>OP_NEGATIVE
>1a0d67	01 00				arity       .word <>1
>1ad0d2	4c 45 4e 00			TOKEN_TEXT  .null "LEN"
>1a0d69	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d6a	03				length      .byte len("LEN")
>1a0d6b	d2 d0				name        .word <>TOKEN_TEXT
>1a0d6d	a0 49				eval        .word <>FN_LEN
>1a0d6f	00 00				arity       .word <>0
>1ad0d6	50 45 45 4b 00			TOKEN_TEXT  .null "PEEK"
>1a0d71	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d72	04				length      .byte len("PEEK")
>1a0d73	d6 d0				name        .word <>TOKEN_TEXT
>1a0d75	f0 49				eval        .word <>FN_PEEK
>1a0d77	00 00				arity       .word <>0
>1ad0db	50 45 45 4b 57 00		TOKEN_TEXT  .null "PEEKW"
>1a0d79	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d7a	05				length      .byte len("PEEKW")
>1a0d7b	db d0				name        .word <>TOKEN_TEXT
>1a0d7d	81 4a				eval        .word <>FN_PEEKW
>1a0d7f	00 00				arity       .word <>0
>1ad0e1	50 45 45 4b 4c 00		TOKEN_TEXT  .null "PEEKL"
>1a0d81	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d82	05				length      .byte len("PEEKL")
>1a0d83	e1 d0				name        .word <>TOKEN_TEXT
>1a0d85	33 4a				eval        .word <>FN_PEEKL
>1a0d87	00 00				arity       .word <>0
>1ad0e7	43 48 52 24 00			TOKEN_TEXT  .null "CHR$"
>1a0d89	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d8a	04				length      .byte len("CHR$")
>1a0d8b	e7 d0				name        .word <>TOKEN_TEXT
>1a0d8d	c0 4a				eval        .word <>FN_CHR
>1a0d8f	00 00				arity       .word <>0
>1ad0ec	41 53 43 00			TOKEN_TEXT  .null "ASC"
>1a0d91	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d92	03				length      .byte len("ASC")
>1a0d93	ec d0				name        .word <>TOKEN_TEXT
>1a0d95	15 4b				eval        .word <>FN_ASC
>1a0d97	00 00				arity       .word <>0
>1ad0f0	53 50 43 00			TOKEN_TEXT  .null "SPC"
>1a0d99	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d9a	03				length      .byte len("SPC")
>1a0d9b	f0 d0				name        .word <>TOKEN_TEXT
>1a0d9d	5a 4b				eval        .word <>FN_SPC
>1a0d9f	00 00				arity       .word <>0
>1ad0f4	54 41 42 00			TOKEN_TEXT  .null "TAB"
>1a0da1	30				precedence  .byte TOK_TY_FUNC | 0
>1a0da2	03				length      .byte len("TAB")
>1a0da3	f4 d0				name        .word <>TOKEN_TEXT
>1a0da5	e3 4b				eval        .word <>FN_TAB
>1a0da7	00 00				arity       .word <>0
>1ad0f8	41 42 53 00			TOKEN_TEXT  .null "ABS"
>1a0da9	30				precedence  .byte TOK_TY_FUNC | 0
>1a0daa	03				length      .byte len("ABS")
>1a0dab	f8 d0				name        .word <>TOKEN_TEXT
>1a0dad	6c 4c				eval        .word <>FN_ABS
>1a0daf	00 00				arity       .word <>0
>1ad0fc	53 47 4e 00			TOKEN_TEXT  .null "SGN"
>1a0db1	30				precedence  .byte TOK_TY_FUNC | 0
>1a0db2	03				length      .byte len("SGN")
>1a0db3	fc d0				name        .word <>TOKEN_TEXT
>1a0db5	ce 4c				eval        .word <>FN_SGN
>1a0db7	00 00				arity       .word <>0
>1ad100	48 45 58 24 00			TOKEN_TEXT  .null "HEX$"
>1a0db9	30				precedence  .byte TOK_TY_FUNC | 0
>1a0dba	04				length      .byte len("HEX$")
>1a0dbb	00 d1				name        .word <>TOKEN_TEXT
>1a0dbd	12 49				eval        .word <>FN_HEX
>1a0dbf	00 00				arity       .word <>0
>1ad105	44 45 43 00			TOKEN_TEXT  .null "DEC"
>1a0dc1	30				precedence  .byte TOK_TY_FUNC | 0
>1a0dc2	03				length      .byte len("DEC")
>1a0dc3	05 d1				name        .word <>TOKEN_TEXT
>1a0dc5	b1 48				eval        .word <>FN_DEC
>1a0dc7	00 00				arity       .word <>0
>1ad109	53 54 52 24 00			TOKEN_TEXT  .null "STR$"
>1a0dc9	30				precedence  .byte TOK_TY_FUNC | 0
>1a0dca	04				length      .byte len("STR$")
>1a0dcb	09 d1				name        .word <>TOKEN_TEXT
>1a0dcd	63 48				eval        .word <>FN_STR
>1a0dcf	00 00				arity       .word <>0
>1ad10e	56 41 4c 00			TOKEN_TEXT  .null "VAL"
>1a0dd1	30				precedence  .byte TOK_TY_FUNC | 0
>1a0dd2	03				length      .byte len("VAL")
>1a0dd3	0e d1				name        .word <>TOKEN_TEXT
>1a0dd5	0d 48				eval        .word <>FN_VAL
>1a0dd7	00 00				arity       .word <>0
>1ad112	4c 45 46 54 24 00		TOKEN_TEXT  .null "LEFT$"
>1a0dd9	30				precedence  .byte TOK_TY_FUNC | 0
>1a0dda	05				length      .byte len("LEFT$")
>1a0ddb	12 d1				name        .word <>TOKEN_TEXT
>1a0ddd	44 47				eval        .word <>FN_LEFT
>1a0ddf	00 00				arity       .word <>0
>1ad118	52 49 47 48 54 24 00		TOKEN_TEXT  .null "RIGHT$"
>1a0de1	30				precedence  .byte TOK_TY_FUNC | 0
>1a0de2	06				length      .byte len("RIGHT$")
>1a0de3	18 d1				name        .word <>TOKEN_TEXT
>1a0de5	63 46				eval        .word <>FN_RIGHT
>1a0de7	00 00				arity       .word <>0
>1ad11f	4d 49 44 24 00			TOKEN_TEXT  .null "MID$"
>1a0de9	30				precedence  .byte TOK_TY_FUNC | 0
>1a0dea	04				length      .byte len("MID$")
>1a0deb	1f d1				name        .word <>TOKEN_TEXT
>1a0ded	ae 45				eval        .word <>FN_MID
>1a0def	00 00				arity       .word <>0
>1ad124	52 55 4e 00			TOKEN_TEXT  .null "RUN"
>1a0df1	10				precedence  .byte TOK_TY_CMD | 0
>1a0df2	03				length      .byte len("RUN")
>1a0df3	24 d1				name        .word <>TOKEN_TEXT
>1a0df5	35 4e				eval        .word <>CMD_RUN
>1a0df7	00 00				arity       .word <>0
>1ad128	4e 45 57 00			TOKEN_TEXT  .null "NEW"
>1a0df9	10				precedence  .byte TOK_TY_CMD | 0
>1a0dfa	03				length      .byte len("NEW")
>1a0dfb	28 d1				name        .word <>TOKEN_TEXT
>1a0dfd	00 4e				eval        .word <>CMD_NEW
>1a0dff	00 00				arity       .word <>0
>1ad12c	4c 4f 41 44 00			TOKEN_TEXT  .null "LOAD"
>1a0e01	10				precedence  .byte TOK_TY_CMD | 0
>1a0e02	04				length      .byte len("LOAD")
>1a0e03	2c d1				name        .word <>TOKEN_TEXT
>1a0e05	e6 69				eval        .word <>CMD_LOAD
>1a0e07	00 00				arity       .word <>0
>1ad131	4c 49 53 54 00			TOKEN_TEXT  .null "LIST"
>1a0e09	10				precedence  .byte TOK_TY_CMD | 0
>1a0e0a	04				length      .byte len("LIST")
>1a0e0b	31 d1				name        .word <>TOKEN_TEXT
>1a0e0d	4c 4e				eval        .word <>CMD_LIST
>1a0e0f	00 00				arity       .word <>0
>1ad136	44 49 52 00			TOKEN_TEXT  .null "DIR"
>1a0e11	10				precedence  .byte TOK_TY_CMD | 0
>1a0e12	03				length      .byte len("DIR")
>1a0e13	36 d1				name        .word <>TOKEN_TEXT
>1a0e15	0d 67				eval        .word <>CMD_DIR
>1a0e17	00 00				arity       .word <>0
>1ad13a	42 4c 4f 41 44 00		TOKEN_TEXT  .null "BLOAD"
>1a0e19	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e1a	05				length      .byte len("BLOAD")
>1a0e1b	3a d1				name        .word <>TOKEN_TEXT
>1a0e1d	b8 68				eval        .word <>S_BLOAD
>1a0e1f	00 00				arity       .word <>0
>1ad140	42 52 55 4e 00			TOKEN_TEXT  .null "BRUN"
>1a0e21	10				precedence  .byte TOK_TY_CMD | 0
>1a0e22	04				length      .byte len("BRUN")
>1a0e23	40 d1				name        .word <>TOKEN_TEXT
>1a0e25	93 69				eval        .word <>CMD_BRUN
>1a0e27	00 00				arity       .word <>0
>1ad145	42 53 41 56 45 00		TOKEN_TEXT  .null "BSAVE"
>1a0e29	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e2a	05				length      .byte len("BSAVE")
>1a0e2b	45 d1				name        .word <>TOKEN_TEXT
>1a0e2d	9f 6a				eval        .word <>S_BSAVE
>1a0e2f	00 00				arity       .word <>0
>1ad14b	44 45 4c 00			TOKEN_TEXT  .null "DEL"
>1a0e31	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e32	03				length      .byte len("DEL")
>1a0e33	4b d1				name        .word <>TOKEN_TEXT
>1a0e35	be 6b				eval        .word <>S_DEL
>1a0e37	00 00				arity       .word <>0
>1ad14f	53 41 56 45 00			TOKEN_TEXT  .null "SAVE"
>1a0e39	10				precedence  .byte TOK_TY_CMD | 0
>1a0e3a	04				length      .byte len("SAVE")
>1a0e3b	4f d1				name        .word <>TOKEN_TEXT
>1a0e3d	2b 6b				eval        .word <>CMD_SAVE
>1a0e3f	00 00				arity       .word <>0
>1ad154	52 45 4e 41 4d 45 00		TOKEN_TEXT  .null "RENAME"
>1a0e41	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e42	06				length      .byte len("RENAME")
>1a0e43	54 d1				name        .word <>TOKEN_TEXT
>1a0e45	34 6c				eval        .word <>S_RENAME
>1a0e47	00 00				arity       .word <>0
>1ad15b	43 4f 50 59 00			TOKEN_TEXT  .null "COPY"
>1a0e49	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e4a	04				length      .byte len("COPY")
>1a0e4b	5b d1				name        .word <>TOKEN_TEXT
>1a0e4d	58 6d				eval        .word <>S_COPY
>1a0e4f	00 00				arity       .word <>0
>1ad160	4d 4f 4e 49 54 4f 52 00		TOKEN_TEXT  .null "MONITOR"
>1a0e51	10				precedence  .byte TOK_TY_CMD | 0
>1a0e52	07				length      .byte len("MONITOR")
>1a0e53	60 d1				name        .word <>TOKEN_TEXT
>1a0e55	fd 4d				eval        .word <>CMD_MONITOR
>1a0e57	00 00				arity       .word <>0
>1ad168	47 45 54 00			TOKEN_TEXT  .null "GET"
>1a0e59	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e5a	03				length      .byte len("GET")
>1a0e5b	68 d1				name        .word <>TOKEN_TEXT
>1a0e5d	60 3b				eval        .word <>S_GET
>1a0e5f	00 00				arity       .word <>0
>1ad16c	49 4e 50 55 54 00		TOKEN_TEXT  .null "INPUT"
>1a0e61	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e62	05				length      .byte len("INPUT")
>1a0e63	6c d1				name        .word <>TOKEN_TEXT
>1a0e65	70 3a				eval        .word <>S_INPUT
>1a0e67	00 00				arity       .word <>0
>1ad172	53 45 54 42 4f 52 44 45		TOKEN_TEXT  .null "SETBORDER"
>1ad17a	52 00
>1a0e69	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e6a	09				length      .byte len("SETBORDER")
>1a0e6b	72 d1				name        .word <>TOKEN_TEXT
>1a0e6d	de 2a				eval        .word <>S_SETBORDER
>1a0e6f	00 00				arity       .word <>0
>1ad17c	54 45 58 54 43 4f 4c 4f		TOKEN_TEXT  .null "TEXTCOLOR"
>1ad184	52 00
>1a0e71	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e72	09				length      .byte len("TEXTCOLOR")
>1a0e73	7c d1				name        .word <>TOKEN_TEXT
>1a0e75	6b 2a				eval        .word <>S_TEXTCOLOR
>1a0e77	00 00				arity       .word <>0
>1ad186	53 45 54 42 47 43 4f 4c		TOKEN_TEXT  .null "SETBGCOLOR"
>1ad18e	4f 52 00
>1a0e79	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e7a	0a				length      .byte len("SETBGCOLOR")
>1a0e7b	86 d1				name        .word <>TOKEN_TEXT
>1a0e7d	9b 2a				eval        .word <>S_SETBGCOLOR
>1a0e7f	00 00				arity       .word <>0
>1ad191	53 45 54 44 41 54 45 00		TOKEN_TEXT  .null "SETDATE"
>1a0e81	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e82	07				length      .byte len("SETDATE")
>1a0e83	91 d1				name        .word <>TOKEN_TEXT
>1a0e85	d8 29				eval        .word <>S_SETDATE
>1a0e87	00 00				arity       .word <>0
>1ad199	47 45 54 44 41 54 45 24		TOKEN_TEXT  .null "GETDATE$"
>1ad1a1	00
>1a0e89	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e8a	08				length      .byte len("GETDATE$")
>1a0e8b	99 d1				name        .word <>TOKEN_TEXT
>1a0e8d	89 44				eval        .word <>F_GETDATE
>1a0e8f	00 00				arity       .word <>0
>1ad1a2	53 45 54 54 49 4d 45 00		TOKEN_TEXT  .null "SETTIME"
>1a0e91	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e92	07				length      .byte len("SETTIME")
>1a0e93	a2 d1				name        .word <>TOKEN_TEXT
>1a0e95	6d 29				eval        .word <>S_SETTIME
>1a0e97	00 00				arity       .word <>0
>1ad1aa	47 45 54 54 49 4d 45 24		TOKEN_TEXT  .null "GETTIME$"
>1ad1b2	00
>1a0e99	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e9a	08				length      .byte len("GETTIME$")
>1a0e9b	aa d1				name        .word <>TOKEN_TEXT
>1a0e9d	f3 44				eval        .word <>F_GETTIME
>1a0e9f	00 00				arity       .word <>0
>1ad1b3	47 52 41 50 48 49 43 53		TOKEN_TEXT  .null "GRAPHICS"
>1ad1bb	00
>1a0ea1	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ea2	08				length      .byte len("GRAPHICS")
>1a0ea3	b3 d1				name        .word <>TOKEN_TEXT
>1a0ea5	23 2c				eval        .word <>S_GRAPHICS
>1a0ea7	00 00				arity       .word <>0
>1ad1bc	53 45 54 43 4f 4c 4f 52		TOKEN_TEXT  .null "SETCOLOR"
>1ad1c4	00
>1a0ea9	20				precedence  .byte TOK_TY_STMNT | 0
>1a0eaa	08				length      .byte len("SETCOLOR")
>1a0eab	bc d1				name        .word <>TOKEN_TEXT
>1a0ead	57 2b				eval        .word <>S_SETCOLOR
>1a0eaf	00 00				arity       .word <>0
>1ad1c5	42 49 54 4d 41 50 00		TOKEN_TEXT  .null "BITMAP"
>1a0eb1	20				precedence  .byte TOK_TY_STMNT | 0
>1a0eb2	06				length      .byte len("BITMAP")
>1a0eb3	c5 d1				name        .word <>TOKEN_TEXT
>1a0eb5	5d 2d				eval        .word <>S_BITMAP
>1a0eb7	00 00				arity       .word <>0
>1ad1cc	43 4c 52 42 49 54 4d 41		TOKEN_TEXT  .null "CLRBITMAP"
>1ad1d4	50 00
>1a0eb9	20				precedence  .byte TOK_TY_STMNT | 0
>1a0eba	09				length      .byte len("CLRBITMAP")
>1a0ebb	cc d1				name        .word <>TOKEN_TEXT
>1a0ebd	65 2e				eval        .word <>S_CLRBITMAP
>1a0ebf	00 00				arity       .word <>0
>1ad1d6	50 4c 4f 54 00			TOKEN_TEXT  .null "PLOT"
>1a0ec1	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ec2	04				length      .byte len("PLOT")
>1a0ec3	d6 d1				name        .word <>TOKEN_TEXT
>1a0ec5	75 2f				eval        .word <>S_PLOT
>1a0ec7	00 00				arity       .word <>0
>1ad1db	4c 49 4e 45 00			TOKEN_TEXT  .null "LINE"
>1a0ec9	20				precedence  .byte TOK_TY_STMNT | 0
>1a0eca	04				length      .byte len("LINE")
>1a0ecb	db d1				name        .word <>TOKEN_TEXT
>1a0ecd	e6 2f				eval        .word <>S_LINE
>1a0ecf	00 00				arity       .word <>0
>1ad1e0	46 49 4c 4c 00			TOKEN_TEXT  .null "FILL"
>1a0ed1	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ed2	04				length      .byte len("FILL")
>1a0ed3	e0 d1				name        .word <>TOKEN_TEXT
>1a0ed5	7f 30				eval        .word <>S_FILL
>1a0ed7	00 00				arity       .word <>0
>1ad1e5	53 50 52 49 54 45 00		TOKEN_TEXT  .null "SPRITE"
>1a0ed9	20				precedence  .byte TOK_TY_STMNT | 0
>1a0eda	06				length      .byte len("SPRITE")
>1a0edb	e5 d1				name        .word <>TOKEN_TEXT
>1a0edd	bb 31				eval        .word <>S_SPRITE
>1a0edf	00 00				arity       .word <>0
>1ad1ec	53 50 52 49 54 45 41 54		TOKEN_TEXT  .null "SPRITEAT"
>1ad1f4	00
>1a0ee1	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ee2	08				length      .byte len("SPRITEAT")
>1a0ee3	ec d1				name        .word <>TOKEN_TEXT
>1a0ee5	59 32				eval        .word <>S_SPRITEAT
>1a0ee7	00 00				arity       .word <>0
>1ad1f5	53 50 52 49 54 45 53 48		TOKEN_TEXT  .null "SPRITESHOW"
>1ad1fd	4f 57 00
>1a0ee9	20				precedence  .byte TOK_TY_STMNT | 0
>1a0eea	0a				length      .byte len("SPRITESHOW")
>1a0eeb	f5 d1				name        .word <>TOKEN_TEXT
>1a0eed	a7 32				eval        .word <>S_SPRITESHOW
>1a0eef	00 00				arity       .word <>0
>1ad200	54 49 4c 45 53 45 54 00		TOKEN_TEXT  .null "TILESET"
>1a0ef1	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ef2	07				length      .byte len("TILESET")
>1a0ef3	00 d2				name        .word <>TOKEN_TEXT
>1a0ef5	de 33				eval        .word <>S_TILESET
>1a0ef7	00 00				arity       .word <>0
>1ad208	54 49 4c 45 4d 41 50 00		TOKEN_TEXT  .null "TILEMAP"
>1a0ef9	20				precedence  .byte TOK_TY_STMNT | 0
>1a0efa	07				length      .byte len("TILEMAP")
>1a0efb	08 d2				name        .word <>TOKEN_TEXT
>1a0efd	5c 34				eval        .word <>S_TILEMAP
>1a0eff	00 00				arity       .word <>0
>1ad210	54 49 4c 45 53 48 4f 57		TOKEN_TEXT  .null "TILESHOW"
>1ad218	00
>1a0f01	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f02	08				length      .byte len("TILESHOW")
>1a0f03	10 d2				name        .word <>TOKEN_TEXT
>1a0f05	ce 34				eval        .word <>S_TILESHOW
>1a0f07	00 00				arity       .word <>0
>1ad219	54 49 4c 45 41 54 00		TOKEN_TEXT  .null "TILEAT"
>1a0f09	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f0a	06				length      .byte len("TILEAT")
>1a0f0b	19 d2				name        .word <>TOKEN_TEXT
>1a0f0d	0b 35				eval        .word <>S_TILEAT
>1a0f0f	00 00				arity       .word <>0
>1ad220	4d 45 4d 43 4f 50 59 00		TOKEN_TEXT  .null "MEMCOPY"
>1a0f11	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f12	07				length      .byte len("MEMCOPY")
>1a0f13	20 d2				name        .word <>TOKEN_TEXT
>1a0f15	3b 38				eval        .word <>S_MEMCOPY
>1a0f17	00 00				arity       .word <>0
=$e6					TOK_LINEAR = $E6
>1ad228	4c 49 4e 45 41 52 00		TOKEN_TEXT  .null "LINEAR"
>1a0f19	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0f1a	06				length      .byte len("LINEAR")
>1a0f1b	28 d2				name        .word <>TOKEN_TEXT
>1a0f1d	00 00				eval        .word <>0
>1a0f1f	00 00				arity       .word <>0
=$e7					TOK_RECT = $E7
>1ad22f	52 45 43 54 00			TOKEN_TEXT  .null "RECT"
>1a0f21	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0f22	04				length      .byte len("RECT")
>1a0f23	2f d2				name        .word <>TOKEN_TEXT
>1a0f25	00 00				eval        .word <>0
>1a0f27	00 00				arity       .word <>0
>1ad234	4c 4f 43 41 54 45 00		TOKEN_TEXT  .null "LOCATE"
>1a0f29	20				precedence  .byte TOK_TY_STMNT | 0
>1a0f2a	06				length      .byte len("LOCATE")
>1a0f2b	34 d2				name        .word <>TOKEN_TEXT
>1a0f2d	50 3a				eval        .word <>S_LOCATE
>1a0f2f	00 00				arity       .word <>0
>1ad23b	49 4e 54 00			TOKEN_TEXT  .null "INT"
>1a0f31	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f32	03				length      .byte len("INT")
>1a0f33	3b d2				name        .word <>TOKEN_TEXT
>1a0f35	24 4d				eval        .word <>FN_INT
>1a0f37	00 00				arity       .word <>0
>1ad23f	52 4e 44 00			TOKEN_TEXT  .null "RND"
>1a0f39	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f3a	03				length      .byte len("RND")
>1a0f3b	3f d2				name        .word <>TOKEN_TEXT
>1a0f3d	58 45				eval        .word <>FN_RND
>1a0f3f	00 00				arity       .word <>0
>1ad243	53 49 4e 00			TOKEN_TEXT  .null "SIN"
>1a0f41	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f42	03				length      .byte len("SIN")
>1a0f43	43 d2				name        .word <>TOKEN_TEXT
>1a0f45	37 4d				eval        .word <>FN_SIN
>1a0f47	00 00				arity       .word <>0
>1ad247	43 4f 53 00			TOKEN_TEXT  .null "COS"
>1a0f49	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f4a	03				length      .byte len("COS")
>1a0f4b	47 d2				name        .word <>TOKEN_TEXT
>1a0f4d	4d 4d				eval        .word <>FN_COS
>1a0f4f	00 00				arity       .word <>0
>1ad24b	54 41 4e 00			TOKEN_TEXT  .null "TAN"
>1a0f51	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f52	03				length      .byte len("TAN")
>1a0f53	4b d2				name        .word <>TOKEN_TEXT
>1a0f55	63 4d				eval        .word <>FN_TAN
>1a0f57	00 00				arity       .word <>0
>1ad24f	4c 4e 00			TOKEN_TEXT  .null "LN"
>1a0f59	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f5a	02				length      .byte len("LN")
>1a0f5b	4f d2				name        .word <>TOKEN_TEXT
>1a0f5d	79 4d				eval        .word <>FN_LN
>1a0f5f	00 00				arity       .word <>0
>1ad252	41 43 4f 53 00			TOKEN_TEXT  .null "ACOS"
>1a0f61	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f62	04				length      .byte len("ACOS")
>1a0f63	52 d2				name        .word <>TOKEN_TEXT
>1a0f65	8f 4d				eval        .word <>FN_ACOS
>1a0f67	00 00				arity       .word <>0
>1ad257	41 53 49 4e 00			TOKEN_TEXT  .null "ASIN"
>1a0f69	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f6a	04				length      .byte len("ASIN")
>1a0f6b	57 d2				name        .word <>TOKEN_TEXT
>1a0f6d	a5 4d				eval        .word <>FN_ASIN
>1a0f6f	00 00				arity       .word <>0
>1ad25c	41 54 41 4e 00			TOKEN_TEXT  .null "ATAN"
>1a0f71	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f72	04				length      .byte len("ATAN")
>1a0f73	5c d2				name        .word <>TOKEN_TEXT
>1a0f75	bb 4d				eval        .word <>FN_ATAN
>1a0f77	00 00				arity       .word <>0
>1ad261	45 58 50 00			TOKEN_TEXT  .null "EXP"
>1a0f79	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f7a	03				length      .byte len("EXP")
>1a0f7b	61 d2				name        .word <>TOKEN_TEXT
>1a0f7d	d1 4d				eval        .word <>FN_EXP
>1a0f7f	00 00				arity       .word <>0
>1ad265	53 51 52 00			TOKEN_TEXT  .null "SQR"
>1a0f81	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f82	03				length      .byte len("SQR")
>1a0f83	65 d2				name        .word <>TOKEN_TEXT
>1a0f85	e7 4d				eval        .word <>FN_SQR
>1a0f87	00 00				arity       .word <>0
>1a0f89	00 00 00 00 00 00 00 00		            .word 0, 0, 0, 0

;******  Return to file: src\basic816.s


;******  Processing file: src\heap.s

>08b7					ALLOCATED   .long ?     ; Pointer to the most recently allocated object
>08ba					HEAP        .long ?     ; Pointer to the top of the heap (next empty byte)
>08bd					FREED       .long ?     ; Pointer to a linked list of freed heap objects
>08c0					CURRBLOCK   .long ?     ; Pointer to the current heap allocated block
>08c3					CURRHEADER  .long ?     ; Pointer to the header of the current block
>08c6					CURREND     .long ?     ; Pointer to the byte immediately after the current block
>08c9					CURRFREED   .long ?     ; Pointer to the current freed block
>08cc					FREEDEND    .long ?     ; Pointer to the byte immediately after the current freed block
>08cf					LASTFREED   .long ?     ;
.0000					HEAPOBJ
>0000					TYPE        .byte ?     ; Code for the type of object allocated
>0001					COUNT       .byte ?     ; Number of references to the heap object
>0002					NEXT        .long ?     ; Pointer to the next object in the list (used when freed)
>0005					END         .long ?     ; Pointer to the next byte after the block
.1a0f91					INITHEAP
.1a0f91	08		php		            PHP
.1a0f92	0b		phd		            PHD
.1a0f93	08		php		            PHP
.1a0f94	c2 20		rep #$20	            REP #$20
.1a0f96	48		pha		            PHA
.1a0f97	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0f9a	5b		tcd		            TCD
.1a0f9b	68		pla		            PLA
.1a0f9c	28		plp		            PLP
.1a0f9d	c2 30		rep #$30	            REP #$30
.1a0f9f	a9 ff ff	lda #$ffff	            LDA #<>HEAP_TOP         ; Set the HEAP to the top
.1a0fa2	85 ba		sta $08ba	            STA HEAP
.1a0fa4	e2 20		sep #$20	            SEP #$20
.1a0fa6	a9 17		lda #$17	            LDA #`HEAP_TOP
.1a0fa8	85 bc		sta $08bc	            STA HEAP+2
.1a0faa	c2 20		rep #$20	            REP #$20
.1a0fac	64 b7		stz $08b7	            STZ ALLOCATED           ; And clear the pointer to the allocated objects
.1a0fae	64 bd		stz $08bd	            STZ FREED               ; as well as the list of freed objects
.1a0fb0	e2 20		sep #$20	            SEP #$20
.1a0fb2	64 b9		stz $08b9	            STZ ALLOCATED+2
.1a0fb4	64 bf		stz $08bf	            STZ FREED+2
.1a0fb6	2b		pld		            PLD
.1a0fb7	28		plp		            PLP
.1a0fb8	60		rts		            RTS
.1a0fb9					ALLOC
.1a0fb9	5a		phy		            PHY
.1a0fba	08		php		            PHP
.1a0fbb	e2 20		sep #$20	            SEP #$20
.1a0fbd	85 ea		sta $08ea	            STA TOFINDTYPE      ; Save the type of the block to TOFINDTYPE
.1a0fbf	c2 10		rep #$10	            REP #$10
.1a0fc1	86 8f		stx $088f	            STX MCOUNT           ; And the length of the block needed to MCOUNT
.1a0fc3	c2 20		rep #$20	            REP #$20
.1a0fc5	a5 0e		lda $080e	            LDA SCRATCH+2
.1a0fc7	48		pha		            PHA
.1a0fc8	a5 0c		lda $080c	            LDA SCRATCH
.1a0fca	48		pha		            PHA
.1a0fcb	a5 12		lda $0812	            LDA SCRATCH2+2
.1a0fcd	48		pha		            PHA
.1a0fce	a5 10		lda $0810	            LDA SCRATCH2
.1a0fd0	48		pha		            PHA
.1a0fd1	20 69 10	jsr $1a1069	            JSR ALLOCFREED
.1a0fd4	b0 03		bcs $1a0fd9	            BCS done            ; Return, if we got something back
.1a0fd6	20 ed 0f	jsr $1a0fed	            JSR ALLOCHEAP
.1a0fd9					done
.1a0fd9	20 f5 11	jsr $1a11f5	            JSR HEAP_GETHED
.1a0fdc	c2 20		rep #$20	            REP #$20
.1a0fde	68		pla		            PLA
.1a0fdf	85 10		sta $0810	            STA SCRATCH2
.1a0fe1	68		pla		            PLA
.1a0fe2	85 12		sta $0812	            STA SCRATCH2+2
.1a0fe4	68		pla		            PLA
.1a0fe5	85 0c		sta $080c	            STA SCRATCH
.1a0fe7	68		pla		            PLA
.1a0fe8	85 0e		sta $080e	            STA SCRATCH+2
.1a0fea	28		plp		            PLP
.1a0feb	7a		ply		            PLY
.1a0fec	60		rts		            RTS
.1a0fed					ALLOCHEAP
.1a0fed	08		php		            PHP
.1a0fee	0b		phd		            PHD
.1a0fef	08		php		            PHP
.1a0ff0	c2 20		rep #$20	            REP #$20
.1a0ff2	48		pha		            PHA
.1a0ff3	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0ff6	5b		tcd		            TCD
.1a0ff7	68		pla		            PLA
.1a0ff8	28		plp		            PLP
.1a0ff9	e2 20		sep #$20	            SEP #$20
.1a0ffb	a6 8f		ldx $088f	            LDX MCOUNT
.1a0ffd	ca		dex		            DEX
.1a0ffe	86 0c		stx $080c	            STX SCRATCH             ; SCRATCH := size - 1
.1a1000	e8		inx		            INX
.1a1001	c2 30		rep #$30	            REP #$30
.1a1003	38		sec		            SEC
.1a1004	a5 ba		lda $08ba	            LDA HEAP
.1a1006	e5 0c		sbc $080c	            SBC SCRATCH
.1a1008	85 c0		sta $08c0	            STA CURRBLOCK
.1a100a	e2 20		sep #$20	            SEP #$20
.1a100c	a5 bc		lda $08bc	            LDA HEAP+2
.1a100e	e9 00		sbc #$00	            SBC #0
.1a1010	85 c2		sta $08c2	            STA CURRBLOCK+2
.1a1012	20 f5 11	jsr $1a11f5	            JSR HEAP_GETHED
.1a1015	e2 20		sep #$20	            SEP #$20
.1a1017	a5 ea		lda $08ea	            LDA TOFINDTYPE
.1a1019	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE       ; Set the type of the object
.1a101c	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a101e	a9 00		lda #$00	            LDA #0                  ; Set the count to zero
.1a1020	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.1a1023	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1025	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1028	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a102a	c2 20		rep #$20	            REP #$20
.1a102c	a9 00 00	lda #$0000	            LDA #0
.1a102f	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1031	c2 20		rep #$20	            REP #$20
.1a1033	18		clc		            CLC
.1a1034	a5 ba		lda $08ba	            LDA HEAP
.1a1036	69 01 00	adc #$0001	            ADC #1
.1a1039	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; To get the address of the next byte
.1a103c	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y      ; after the block
.1a103e	e2 20		sep #$20	            SEP #$20
.1a1040	c8		iny		            INY
.1a1041	c8		iny		            INY
.1a1042	a5 bc		lda $08bc	            LDA HEAP+2
.1a1044	69 00		adc #$00	            ADC #0
.1a1046	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1048	c2 20		rep #$20	            REP #$20
.1a104a	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a104c	85 b7		sta $08b7	            STA ALLOCATED
.1a104e	e2 20		sep #$20	            SEP #$20
.1a1050	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a1052	85 b9		sta $08b9	            STA ALLOCATED+2
.1a1054	c2 20		rep #$20	            REP #$20
.1a1056	38		sec		            SEC                     ; Move the HEAP pointer to the first free byte under the header
.1a1057	a5 c3		lda $08c3	            LDA CURRHEADER
.1a1059	e9 01 00	sbc #$0001	            SBC #1
.1a105c	85 ba		sta $08ba	            STA HEAP
.1a105e	e2 20		sep #$20	            SEP #$20
.1a1060	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1062	e9 00		sbc #$00	            SBC #0
.1a1064	85 bc		sta $08bc	            STA HEAP+2
.1a1066	2b		pld		            PLD
.1a1067	28		plp		            PLP
.1a1068	60		rts		            RTS
.1a1069					ALLOCFREED
.1a1069	08		php		            PHP
.1a106a	0b		phd		            PHD
.1a106b	08		php		            PHP
.1a106c	c2 20		rep #$20	            REP #$20
.1a106e	48		pha		            PHA
.1a106f	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1072	5b		tcd		            TCD
.1a1073	68		pla		            PLA
.1a1074	28		plp		            PLP
.1a1075	c2 30		rep #$30	            REP #$30
.1a1077	c2 20		rep #$20	            REP #$20
.1a1079	a5 bd		lda $08bd	            LDA FREED
.1a107b	85 c9		sta $08c9	            STA CURRFREED
.1a107d	e2 20		sep #$20	            SEP #$20
.1a107f	a5 bf		lda $08bf	            LDA FREED+2
.1a1081	85 cb		sta $08cb	            STA CURRFREED+2
.1a1083	a5 c9		lda $08c9	loop        LDA CURRFREED           ; Has anything been freed?
.1a1085	d0 17		bne $1a109e	            BNE has_block           ; Yes: check to see if there's a big enough block
.1a1087	e2 20		sep #$20	            SEP #$20
.1a1089	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a108b	d0 11		bne $1a109e	            BNE has_block           ; Yes: check to see if there's a big enough block
.1a108d	c2 20		rep #$20	            REP #$20
.1a108f	a9 00 00	lda #$0000	            LDA #<>0
.1a1092	85 cf		sta $08cf	            STA LASTFREED
.1a1094	e2 20		sep #$20	            SEP #$20
.1a1096	a9 00		lda #$00	            LDA #`0
.1a1098	85 d1		sta $08d1	            STA LASTFREED+2
.1a109a	2b		pld		ret_false   PLD                     ; Return that we didn't find anything
.1a109b	28		plp		            PLP
.1a109c	18		clc		            CLC
.1a109d	60		rts		            RTS
.1a109e					has_block
.1a109e	c2 20		rep #$20	            REP #$20
.1a10a0	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.1a10a3	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a10a5	85 cc		sta $08cc	            STA FREEDEND
.1a10a7	e2 20		sep #$20	            SEP #$20
.1a10a9	c8		iny		            INY
.1a10aa	c8		iny		            INY
.1a10ab	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a10ad	85 ce		sta $08ce	            STA FREEDEND+2
.1a10af	c2 20		rep #$20	            REP #$20
.1a10b1	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required
.1a10b2	a5 c9		lda $08c9	            LDA CURRFREED
.1a10b4	65 8f		adc $088f	            ADC MCOUNT
.1a10b6	85 0c		sta $080c	            STA SCRATCH
.1a10b8	e2 20		sep #$20	            SEP #$20
.1a10ba	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a10bc	69 00		adc #$00	            ADC #0
.1a10be	85 0e		sta $080e	            STA SCRATCH+2
.1a10c0	c2 20		rep #$20	            REP #$20
.1a10c2	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required + size of header
.1a10c3	a5 0c		lda $080c	            LDA SCRATCH                 ; (that is, it's a pointer to the byte immediately after the block desired)
.1a10c5	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)
.1a10c8	85 0c		sta $080c	            STA SCRATCH
.1a10ca	e2 20		sep #$20	            SEP #$20
.1a10cc	a5 0e		lda $080e	            LDA SCRATCH+2
.1a10ce	69 00		adc #$00	            ADC #0
.1a10d0	85 0e		sta $080e	            STA SCRATCH+2
.1a10d2	c2 20		rep #$20	            REP #$20
.1a10d4	a5 0c		lda $080c	            LDA SCRATCH                 ; Is SCRATCH == FREEDEND?
.1a10d6	c5 cc		cmp $08cc	            CMP FREEDEND
.1a10d8	d0 28		bne $1a1102	            BNE not_exact               ; No: check if this block is bigger than needed
.1a10da	e2 20		sep #$20	            SEP #$20
.1a10dc	a5 0e		lda $080e	            LDA SCRATCH+2
.1a10de	c5 ce		cmp $08ce	            CMP FREEDEND+2
.1a10e0	d0 20		bne $1a1102	            BNE not_exact
.1a10e2	c2 20		rep #$20	            REP #$20
.1a10e4	a5 cf		lda $08cf	            LDA LASTFREED               ; LASTFREED == 0?
.1a10e6	d0 5d		bne $1a1145	            BNE adj_last1               ; No: point LASTFREED->NEXT to skip this block
.1a10e8	e2 20		sep #$20	            SEP #$20
.1a10ea	a5 d1		lda $08d1	            LDA LASTFREED+2
.1a10ec	d0 57		bne $1a1145	            BNE adj_last1
.1a10ee	c2 20		rep #$20	            REP #$20
.1a10f0	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a10f3	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a10f5	85 bd		sta $08bd	            STA FREED
.1a10f7	e2 20		sep #$20	            SEP #$20
.1a10f9	c8		iny		            INY
.1a10fa	c8		iny		            INY
.1a10fb	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a10fd	85 bf		sta $08bf	            STA FREED+2
.1a10ff	4c a6 11	jmp $1a11a6	            JMP init_block              ; And return CURRFREED as our reallocated memory
.1a1102					not_exact
.1a1102	c2 20		rep #$20	            REP #$20
.1a1104	a5 0c		lda $080c	            LDA SCRATCH                 ; Add a buffer to the room needed
.1a1106	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)          ; So we have room to track the memory still freed
.1a1109	85 10		sta $0810	            STA SCRATCH2
.1a110b	e2 20		sep #$20	            SEP #$20
.1a110d	a5 0e		lda $080e	            LDA SCRATCH+2
.1a110f	69 00		adc #$00	            ADC #0
.1a1111	85 12		sta $0812	            STA SCRATCH2+2
.1a1113	e2 20		sep #$20	            SEP #$20
.1a1115	a5 c6		lda $08c6	            LDA CURREND                 ; Is CURREND > SCRATCH2
.1a1117	c5 10		cmp $0810	            CMP SCRATCH2
.1a1119	b0 3e		bcs $1a1159	            BGE has_room                ; Yes: there is room in this block to allocate some memory
.1a111b	90 08		bcc $1a1125	            BLT try_next
.1a111d	c2 20		rep #$20	            REP #$20
.1a111f	a5 c6		lda $08c6	            LDA CURREND
.1a1121	c5 10		cmp $0810	            CMP SCRATCH2
.1a1123	b0 34		bcs $1a1159	            BGE has_room
.1a1125					try_next
.1a1125	c2 20		rep #$20	            REP #$20
.1a1127	a5 c9		lda $08c9	            LDA CURRFREED
.1a1129	85 cf		sta $08cf	            STA LASTFREED
.1a112b	e2 20		sep #$20	            SEP #$20
.1a112d	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a112f	85 d1		sta $08d1	            STA LASTFREED+2
.1a1131	c2 20		rep #$20	            REP #$20
.1a1133	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1136	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.1a1138	85 c9		sta $08c9	            STA CURRFREED
.1a113a	e2 20		sep #$20	            SEP #$20
.1a113c	c8		iny		            INY
.1a113d	c8		iny		            INY
.1a113e	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.1a1140	85 cb		sta $08cb	            STA CURRFREED+2
.1a1142	4c 83 10	jmp $1a1083	            JMP loop                                    ; And try the next header
.1a1145					adj_last1
.1a1145	c2 20		rep #$20	            REP #$20
.1a1147	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := CURRFREED->NEXT
.1a114a	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a114c	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.1a114e	e2 20		sep #$20	            SEP #$20
.1a1150	c8		iny		            INY
.1a1151	c8		iny		            INY
.1a1152	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1154	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.1a1156	4c a6 11	jmp $1a11a6	            JMP init_block              ; And get CURRFREED ready to return
.1a1159					has_room
.1a1159	c2 20		rep #$20	            REP #$20
.1a115b	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END            ; SCRATCH->END := CURRFREED->END
.1a115e	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1160	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a1162	e2 20		sep #$20	            SEP #$20
.1a1164	c8		iny		            INY
.1a1165	c8		iny		            INY
.1a1166	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1168	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a116a	c2 20		rep #$20	            REP #$20
.1a116c	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; CURREND->NEXT := CURRFREED->NEXT
.1a116f	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1171	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a1173	e2 20		sep #$20	            SEP #$20
.1a1175	c8		iny		            INY
.1a1176	c8		iny		            INY
.1a1177	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1179	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a117b	c2 20		rep #$20	            REP #$20
.1a117d	a5 cf		lda $08cf	            LDA LASTFREED               ; Is this the first object we've examined?
.1a117f	d0 14		bne $1a1195	            BNE adj_last2               ; No: we'll need to adjust the previously examined block
.1a1181	e2 20		sep #$20	            SEP #$20
.1a1183	a5 cf		lda $08cf	            LDA LASTFREED
.1a1185	d0 0e		bne $1a1195	            BNE adj_last2
.1a1187	c2 20		rep #$20	            REP #$20
.1a1189	a5 0c		lda $080c	            LDA SCRATCH
.1a118b	85 bd		sta $08bd	            STA FREED
.1a118d	e2 20		sep #$20	            SEP #$20
.1a118f	a5 0e		lda $080e	            LDA SCRATCH+2
.1a1191	85 bf		sta $08bf	            STA FREED+2
.1a1193	80 11		bra $1a11a6	            BRA init_block              ; ... and return the block we've sliced off
.1a1195					adj_last2
.1a1195	c2 20		rep #$20	            REP #$20
.1a1197	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := SCRATCH
.1a119a	a5 0c		lda $080c	            LDA SCRATCH                 ; (point the previous freed block to the newly sliced
.1a119c	97 cf		sta [$08cf],y	            STA [LASTFREED],Y           ;  off part of the current block)
.1a119e	e2 20		sep #$20	            SEP #$20
.1a11a0	c8		iny		            INY
.1a11a1	c8		iny		            INY
.1a11a2	a5 0e		lda $080e	            LDA SCRATCH+2
.1a11a4	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.1a11a6					init_block
.1a11a6	c2 20		rep #$20	            REP #$20
.1a11a8	a5 c9		lda $08c9	            LDA CURRFREED
.1a11aa	85 c3		sta $08c3	            STA CURRHEADER
.1a11ac	e2 20		sep #$20	            SEP #$20
.1a11ae	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a11b0	85 c5		sta $08c5	            STA CURRHEADER+2
.1a11b2	c2 20		rep #$20	            REP #$20
.1a11b4	a5 c3		lda $08c3	            LDA CURRHEADER
.1a11b6	85 b7		sta $08b7	            STA ALLOCATED
.1a11b8	e2 20		sep #$20	            SEP #$20
.1a11ba	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a11bc	85 b9		sta $08b9	            STA ALLOCATED+2
.1a11be	c2 20		rep #$20	            REP #$20
.1a11c0	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; Set CURRHEADER->END to the byte after the block
.1a11c3	a5 0c		lda $080c	            LDA SCRATCH
.1a11c5	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a11c7	e2 20		sep #$20	            SEP #$20
.1a11c9	c8		iny		            INY
.1a11ca	c8		iny		            INY
.1a11cb	a5 0e		lda $080e	            LDA SCRATCH+2
.1a11cd	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a11cf	c2 20		rep #$20	            REP #$20
.1a11d1	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Set CURRHEADER->NEXT to NULL
.1a11d4	a9 00 00	lda #$0000	            LDA #0
.1a11d7	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a11d9	e2 20		sep #$20	            SEP #$20
.1a11db	c8		iny		            INY
.1a11dc	c8		iny		            INY
.1a11dd	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a11df	e2 20		sep #$20	            SEP #$20
.1a11e1	a5 ea		lda $08ea	            LDA TOFINDTYPE          ; Get the type code back
.1a11e3	e2 20		sep #$20	            SEP #$20
.1a11e5	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE
.1a11e8	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a11ea	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT      ; Set its reference count to 0
.1a11ed	a9 00		lda #$00	            LDA #0
.1a11ef	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a11f1	2b		pld		done        PLD
.1a11f2	28		plp		            PLP
.1a11f3	38		sec		            SEC
.1a11f4	60		rts		            RTS
.1a11f5					HEAP_GETHED
.1a11f5	08		php		            PHP
.1a11f6	c2 20		rep #$20	            REP #$20
.1a11f8	38		sec		            SEC
.1a11f9	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a11fb	e9 08 00	sbc #$0008	            SBC #size(HEAPOBJ)
.1a11fe	85 c3		sta $08c3	            STA CURRHEADER
.1a1200	e2 20		sep #$20	            SEP #$20
.1a1202	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a1204	e9 00		sbc #$00	            SBC #0
.1a1206	85 c5		sta $08c5	            STA CURRHEADER+2
.1a1208	28		plp		            PLP
.1a1209	60		rts		            RTS
.1a120a					HEAP_ADDREF
.1a120a	08		php		            PHP
.1a120b	e2 20		sep #$20	            SEP #$20
.1a120d	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a120f	f0 04		beq $1a1215	            BEQ chk_null
.1a1211	c9 18		cmp #$18	            CMP #`(HEAP_TOP + 1)
.1a1213	b0 12		bcs $1a1227	            BGE out_of_bnds
.1a1215					chk_null
.1a1215	c2 20		rep #$20	            REP #$20
.1a1217	a5 c3		lda $08c3	            LDA CURRHEADER
.1a1219	f0 0c		beq $1a1227	            BEQ out_of_bnds
.1a121b					is_ok
.1a121b	e2 20		sep #$20	            SEP #$20
.1a121d	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.1a1220	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1222	1a		inc a		            INC A
.1a1223	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1225	28		plp		            PLP
.1a1226	60		rts		            RTS
.1a1227	00		brk #		out_of_bnds BRK
.1a1228	ea		nop		            NOP
.1a1229					HEAP_REMREF
.1a1229	08		php		            PHP
.1a122a	e2 20		sep #$20	            SEP #$20
.1a122c	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a122e	f0 04		beq $1a1234	            BEQ chk_null
.1a1230	c9 18		cmp #$18	            CMP #`(HEAP_TOP + 1)
.1a1232	b0 17		bcs $1a124b	            BGE out_of_bnds
.1a1234					chk_null
.1a1234	c2 20		rep #$20	            REP #$20
.1a1236	a5 c3		lda $08c3	            LDA CURRHEADER
.1a1238	f0 11		beq $1a124b	            BEQ out_of_bnds
.1a123a	e2 20		sep #$20	            SEP #$20
.1a123c	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT  ; Decrement the reference count
.1a123f	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1241	3a		dec a		            DEC A
.1a1242	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1244	d0 03		bne $1a1249	            BNE done            ; If it's still >0, we are done
.1a1246	20 4d 12	jsr $1a124d	            JSR HEAP_FREE
.1a1249	28		plp		done        PLP
.1a124a	60		rts		            RTS
.1a124b	00		brk #		out_of_bnds BRK
.1a124c	ea		nop		            NOP
.1a124d					HEAP_FREE
.1a124d	08		php		            PHP
.1a124e	c2 20		rep #$20	            REP #$20
.1a1250	a5 bd		lda $08bd	            LDA FREED           ; Check to see if blocks are already on the freed list
.1a1252	d0 21		bne $1a1275	            BNE has_objects
.1a1254	e2 20		sep #$20	            SEP #$20
.1a1256	a5 bf		lda $08bf	            LDA FREED+2
.1a1258	d0 1b		bne $1a1275	            BNE has_objects
.1a125a	a5 c5		lda $08c5	            LDA CURRHEADER+2    ; No: this block is the first one
.1a125c	85 bf		sta $08bf	            STA FREED+2         ; Just make it the freed list
.1a125e	c2 20		rep #$20	            REP #$20
.1a1260	a5 c3		lda $08c3	            LDA CURRHEADER
.1a1262	85 bd		sta $08bd	            STA FREED
.1a1264	a9 00 00	lda #$0000	            LDA #0
.1a1267	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT   ; And clear its next link
.1a126a	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a126c	c8		iny		            INY
.1a126d	c8		iny		            INY
.1a126e	e2 20		sep #$20	            SEP #$20
.1a1270	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1272	4c 34 13	jmp $1a1334	            JMP done
.1a1275					has_objects
.1a1275	e2 20		sep #$20	            SEP #$20
.1a1277	a5 bf		lda $08bf	            LDA FREED+2
.1a1279	c5 c5		cmp $08c5	            CMP CURRHEADER+2
.1a127b	90 28		bcc $1a12a5	            BLT start_scan
.1a127d	c2 20		rep #$20	            REP #$20
.1a127f	a5 bd		lda $08bd	            LDA FREED
.1a1281	c5 c3		cmp $08c3	            CMP CURRHEADER
.1a1283	90 20		bcc $1a12a5	            BLT start_scan
.1a1285					ins_first
.1a1285	c2 20		rep #$20	            REP #$20
.1a1287	a5 bd		lda $08bd	            LDA FREED               ; CURRHEADER->NEXT := FREED
.1a1289	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a128c	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a128e	e2 20		sep #$20	            SEP #$20
.1a1290	c8		iny		            INY
.1a1291	c8		iny		            INY
.1a1292	a5 bf		lda $08bf	            LDA FREED+2
.1a1294	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1296	c2 20		rep #$20	            REP #$20
.1a1298	a5 c3		lda $08c3	            LDA CURRHEADER
.1a129a	85 bd		sta $08bd	            STA FREED
.1a129c	e2 20		sep #$20	            SEP #$20
.1a129e	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a12a0	85 bf		sta $08bf	            STA FREED+2
.1a12a2	4c 34 13	jmp $1a1334	            JMP done
.1a12a5					start_scan
.1a12a5	c2 20		rep #$20	            REP #$20
.1a12a7	a5 bd		lda $08bd	            LDA FREED
.1a12a9	85 08		sta $0808	            STA INDEX
.1a12ab	e2 20		sep #$20	            SEP #$20
.1a12ad	a5 bf		lda $08bf	            LDA FREED+2
.1a12af	85 0a		sta $080a	            STA INDEX+2
.1a12b1					loop
.1a12b1	e2 20		sep #$20	            SEP #$20
.1a12b3	a0 04 00	ldy #$0004	            LDY #HEAPOBJ.NEXT+2
.1a12b6	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a12b8	c5 c8		cmp $08c8	            CMP CURREND+2
.1a12ba	90 32		bcc $1a12ee	            BLT go_next             ; No: check the next spot
.1a12bc	d0 0b		bne $1a12c9	            BNE ins_next
.1a12be	c2 20		rep #$20	            REP #$20
.1a12c0	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a12c3	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a12c5	c5 c6		cmp $08c6	            CMP CURREND
.1a12c7	90 25		bcc $1a12ee	            BLT go_next             ; No: check the next spot
.1a12c9					ins_next
.1a12c9	c2 20		rep #$20	            REP #$20
.1a12cb	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := INDEX->NEXT
.1a12ce	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a12d0	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12d2	e2 20		sep #$20	            SEP #$20
.1a12d4	c8		iny		            INY
.1a12d5	c8		iny		            INY
.1a12d6	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a12d8	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12da	c2 20		rep #$20	            REP #$20
.1a12dc	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.1a12de	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a12e1	97 08		sta [$0808],y	            STA [INDEX],Y
.1a12e3	e2 20		sep #$20	            SEP #$20
.1a12e5	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a12e7	c8		iny		            INY
.1a12e8	c8		iny		            INY
.1a12e9	97 08		sta [$0808],y	            STA [INDEX],Y
.1a12eb	4c 34 13	jmp $1a1334	            JMP done
.1a12ee					go_next
.1a12ee	c2 20		rep #$20	            REP #$20
.1a12f0	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Is INDEX->NEXT = 0
.1a12f3	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a12f5	d0 08		bne $1a12ff	            BNE not_at_end          ; No: load up the next object
.1a12f7	e2 20		sep #$20	            SEP #$20
.1a12f9	c8		iny		            INY
.1a12fa	c8		iny		            INY
.1a12fb	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a12fd	f0 19		beq $1a1318	            BEQ at_end
.1a12ff					not_at_end
.1a12ff	c2 20		rep #$20	            REP #$20
.1a1301	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; INDEX := INDEX->NEXT
.1a1304	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a1306	85 0c		sta $080c	            STA SCRATCH
.1a1308	e2 20		sep #$20	            SEP #$20
.1a130a	c8		iny		            INY
.1a130b	c8		iny		            INY
.1a130c	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a130e	85 0a		sta $080a	            STA INDEX+2
.1a1310	c2 20		rep #$20	            REP #$20
.1a1312	a5 0c		lda $080c	            LDA SCRATCH
.1a1314	85 08		sta $0808	            STA INDEX
.1a1316	80 99		bra $1a12b1	            BRA loop
.1a1318					at_end
.1a1318	c2 20		rep #$20	            REP #$20
.1a131a	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.1a131c	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a131f	97 08		sta [$0808],y	            STA [INDEX],Y
.1a1321	e2 20		sep #$20	            SEP #$20
.1a1323	c8		iny		            INY
.1a1324	c8		iny		            INY
.1a1325	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1327	97 08		sta [$0808],y	            STA [INDEX],Y
.1a1329	a9 00		lda #$00	            LDA #0                  ; CURRHEADER->NEXT := 0
.1a132b	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a132d	c2 20		rep #$20	            REP #$20
.1a132f	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1332	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1334					done
.1a1334	20 39 13	jsr $1a1339	            JSR COALLESCE
.1a1337	28		plp		            PLP
.1a1338	60		rts		            RTS
.1a1339					COALLESCE
.1a1339	08		php		            PHP
.1a133a	c2 20		rep #$20	            REP #$20
.1a133c	a5 bd		lda $08bd	            LDA FREED
.1a133e	85 c3		sta $08c3	            STA CURRHEADER
.1a1340	e2 20		sep #$20	            SEP #$20
.1a1342	a5 bf		lda $08bf	            LDA FREED+2
.1a1344	85 c5		sta $08c5	            STA CURRHEADER+2
.1a1346					next_head
.1a1346	c2 20		rep #$20	            REP #$20
.1a1348	a5 c3		lda $08c3	            LDA CURRHEADER          ; Is CURRHEADER == 0?
.1a134a	d0 09		bne $1a1355	            BNE check_next          ; No: check if NEXT is contiguous
.1a134c	e2 20		sep #$20	            SEP #$20
.1a134e	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1350	d0 03		bne $1a1355	            BNE check_next
.1a1352	4c dc 13	jmp $1a13dc	            JMP done                ; Yes: we're done
.1a1355					check_next
.1a1355	c2 20		rep #$20	            REP #$20
.1a1357	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a135a	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a135c	85 0c		sta $080c	            STA SCRATCH
.1a135e	e2 20		sep #$20	            SEP #$20
.1a1360	c8		iny		            INY
.1a1361	c8		iny		            INY
.1a1362	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1364	85 0e		sta $080e	            STA SCRATCH+2
.1a1366	c2 20		rep #$20	            REP #$20
.1a1368	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.1a136b	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a136d	85 10		sta $0810	            STA SCRATCH2
.1a136f	e2 20		sep #$20	            SEP #$20
.1a1371	c8		iny		            INY
.1a1372	c8		iny		            INY
.1a1373	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1375	85 12		sta $0812	            STA SCRATCH2+2
.1a1377	c2 20		rep #$20	            REP #$20
.1a1379	a5 0c		lda $080c	            LDA SCRATCH
.1a137b	c5 10		cmp $0810	            CMP SCRATCH2            ; Is CURRHEADER->END = CURRHEADER->NEXT?
.1a137d	d0 08		bne $1a1387	            BNE go_next             ; No: go to the next block
.1a137f	e2 20		sep #$20	            SEP #$20
.1a1381	a5 0e		lda $080e	            LDA SCRATCH+2
.1a1383	c5 12		cmp $0812	            CMP SCRATCH2+2
.1a1385	f0 1f		beq $1a13a6	            BEQ combine             ; Yes: combine the two blocks
.1a1387					go_next
.1a1387	c2 20		rep #$20	            REP #$20
.1a1389	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a138c	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a138e	85 0c		sta $080c	            STA SCRATCH
.1a1390	e2 20		sep #$20	            SEP #$20
.1a1392	c8		iny		            INY
.1a1393	c8		iny		            INY
.1a1394	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1396	85 0e		sta $080e	            STA SCRATCH+2
.1a1398	c2 20		rep #$20	            REP #$20
.1a139a	a5 0c		lda $080c	            LDA SCRATCH
.1a139c	85 c3		sta $08c3	            STA CURRHEADER
.1a139e	e2 20		sep #$20	            SEP #$20
.1a13a0	a5 0e		lda $080e	            LDA SCRATCH+2
.1a13a2	85 c5		sta $08c5	            STA CURRHEADER+2
.1a13a4	80 a0		bra $1a1346	            BRA next_head                               ; And loop back to next_head
.1a13a6					combine
.1a13a6	c2 20		rep #$20	            REP #$20
.1a13a8	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a13ab	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a13ad	85 0c		sta $080c	            STA SCRATCH
.1a13af	e2 20		sep #$20	            SEP #$20
.1a13b1	c8		iny		            INY
.1a13b2	c8		iny		            INY
.1a13b3	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a13b5	85 0e		sta $080e	            STA SCRATCH+2
.1a13b7	c2 20		rep #$20	            REP #$20
.1a13b9	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := SCRATCH->NEXT
.1a13bc	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a13be	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a13c0	e2 20		sep #$20	            SEP #$20
.1a13c2	c8		iny		            INY
.1a13c3	c8		iny		            INY
.1a13c4	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a13c6	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a13c8	c2 20		rep #$20	            REP #$20
.1a13ca	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END       ; CURRHEADER->END := SCRATCH->END
.1a13cd	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a13cf	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a13d1	e2 20		sep #$20	            SEP #$20
.1a13d3	c8		iny		            INY
.1a13d4	c8		iny		            INY
.1a13d5	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a13d7	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a13d9	4c 55 13	jmp $1a1355	            JMP check_next          ; And loop back to check_next
.1a13dc	28		plp		done        PLP
.1a13dd	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\strings.s

.1a13de					CLRTMPSTR
.1a13de	08		php		            PHP
.1a13df	c2 20		rep #$20	            REP #$20
.1a13e1	64 16		stz $0816	            STZ STRPTR
.1a13e3	64 18		stz $0818	            STZ STRPTR+2
.1a13e5	28		plp		            PLP
.1a13e6	60		rts		            RTS
.1a13e7					TEMPSTRING
.1a13e7	08		php		            PHP
.1a13e8	c2 30		rep #$30	            REP #$30
.1a13ea	a5 16		lda $0816	            LDA STRPTR          ; Is STRPTR == 0?
.1a13ec	d0 16		bne $1a1404	            BNE add_256         ; No: add 256 to it
.1a13ee	a5 18		lda $0818	            LDA STRPTR+2
.1a13f0	d0 12		bne $1a1404	            BNE add_256
.1a13f2	e2 20		sep #$20	            SEP #$20
.1a13f4	64 16		stz $0816	            STZ STRPTR
.1a13f6	a5 e2		lda $08e2	            LDA NEXTVAR+1
.1a13f8	1a		inc a		            INC A
.1a13f9	1a		inc a		            INC A
.1a13fa	85 17		sta $0817	            STA STRPTR+1
.1a13fc	a5 e3		lda $08e3	            LDA NEXTVAR+2
.1a13fe	85 18		sta $0818	            STA STRPTR+2
.1a1400	64 19		stz $0819	            STZ STRPTR+3
.1a1402	80 07		bra $1a140b	            BRA chk_room
.1a1404					add_256
.1a1404	c2 20		rep #$20	            REP #$20
.1a1406	a5 17		lda $0817	            LDA STRPTR+1        ; There was already a temporary string...
.1a1408	1a		inc a		            INC A               ; Leave 256 bytes for it
.1a1409	85 17		sta $0817	            STA STRPTR+1
.1a140b					chk_room
.1a140b	c2 20		rep #$20	            REP #$20
.1a140d	a5 bb		lda $08bb	            LDA HEAP+1          ; Check to make sure that STRPTR and HEAP haven't touched
.1a140f	3a		dec a		            DEC A
.1a1410	c5 17		cmp $0817	            CMP STRPTR+1
.1a1412	f0 02		beq $1a1416	            BEQ no_room         ; If they have, throw an error
.1a1414	b0 1f		bcs $1a1435	            BGE done
.1a1416					no_room
.1a1416	08		php		            PHP
.1a1417	c2 20		rep #$20	            REP #$20
.1a1419	48		pha		            PHA
.1a141a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a141d	5b		tcd		            TCD
.1a141e	68		pla		            PLA
.1a141f	28		plp		            PLP
.1a1420	e2 20		sep #$20	            SEP #$20
.1a1422	a9 03		lda #$03	            LDA #ERR_MEMORY
.1a1424	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1428	c2 20		rep #$20	            REP #$20
.1a142a	29 ff 00	and #$00ff	            AND #$00FF
.1a142d	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a1430	e2 20		sep #$20	            SEP #$20
.1a1432	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1435	28		plp		done        PLP
.1a1436	60		rts		            RTS
.1a1437					ITOS_DIGIT
.1a1437	c9 00		cmp #$00	            CMP #0          ; Is it 0?
.1a1439	d0 05		bne $1a1440	            BNE add_digit   ; No: go ahead and add it
.1a143b	c0 01 00	cpy #$0001	            CPY #1          ; Are we on the first digit?
.1a143e	f0 05		beq $1a1445	            BEQ done        ; Yes: ignore this leading 0
.1a1440	09 30		ora #$30	add_digit   ORA #$30        ; Convert it to ASCII
.1a1442	97 16		sta [$0816],y	            STA [STRPTR],Y  ; Save it to the string
.1a1444	c8		iny		            INY             ; And point to the next location
.1a1445					done
.1a1445	60		rts		            RTS
.1a1446					ITOS
.1a1446	08		php		            PHP
.1a1447	c2 30		rep #$30	            REP #$30
.1a1449	64 0c		stz $080c	            STZ SCRATCH         ; Use scratch to store if negative
.1a144b	a5 25		lda $0825	            LDA ARGUMENT1+2     ; Check to see if the number is negative
.1a144d	10 1a		bpl $1a1469	            BPL start_cnvt
.1a144f	18		clc		            CLC                 ; Yes: make ARGUMENT1 positive
.1a1450	a5 23		lda $0823	            LDA ARGUMENT1
.1a1452	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a1455	69 01 00	adc #$0001	            ADC #1
.1a1458	85 23		sta $0823	            STA ARGUMENT1
.1a145a	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a145c	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a145f	69 00 00	adc #$0000	            ADC #0
.1a1462	85 25		sta $0825	            STA ARGUMENT1+2
.1a1464	a9 ff ff	lda #$ffff	            LDA #$FFFF          ; Record that the number was negative
.1a1467	85 0c		sta $080c	            STA SCRATCH
.1a1469					start_cnvt
.1a1469	64 10		stz $0810	            STZ SCRATCH2        ; SCRATCH2 will be our BCD version of the number
.1a146b	64 12		stz $0812	            STZ SCRATCH2+2
.1a146d	64 14		stz $0814	            STZ SCRATCH2+4
.1a146f	a2 1f 00	ldx #$001f	            LDX #31
.1a1472	f8		sed		            SED                 ; Yes, we're really using BCD mode
.1a1473	06 23		asl $0823	shift_loop  ASL ARGUMENT1       ; Shift ARGUMENT1 left one bit
.1a1475	26 25		rol $0825	            ROL ARGUMENT1+2
.1a1477	a5 10		lda $0810	            LDA SCRATCH2        ; SCRATCH2 := SCRATCH2 + SCRATCH2 + Carry
.1a1479	65 10		adc $0810	            ADC SCRATCH2
.1a147b	85 10		sta $0810	            STA SCRATCH2
.1a147d	a5 12		lda $0812	            LDA SCRATCH2+2
.1a147f	65 12		adc $0812	            ADC SCRATCH2+2
.1a1481	85 12		sta $0812	            STA SCRATCH2+2
.1a1483	a5 14		lda $0814	            LDA SCRATCH2+4
.1a1485	65 14		adc $0814	            ADC SCRATCH2+4
.1a1487	85 14		sta $0814	            STA SCRATCH2+4
.1a1489	ca		dex		            DEX
.1a148a	10 e7		bpl $1a1473	            BPL shift_loop      ; Loop through all 32 bits of ARGUMENT1
.1a148c	d8		cld		            CLD                 ; Switch back out of BCD mode
.1a148d	e2 20		sep #$20	            SEP #$20
.1a148f	20 e7 13	jsr $1a13e7	            JSR TEMPSTRING
.1a1492	a0 00 00	ldy #$0000	            LDY #0              ; Y will be index into the temporary string
.1a1495	a5 0c		lda $080c	            LDA SCRATCH         ; Check to see if the number was negative
.1a1497	f0 04		beq $1a149d	            BEQ is_pos          ; No: write a leading space
.1a1499	a9 2d		lda #$2d	            LDA #'-'            ; If negative, write the minus sign
.1a149b	80 02		bra $1a149f	            BRA wr_lead
.1a149d	a9 20		lda #$20	is_pos      LDA #CHAR_SP        ; Write a leading space
.1a149f	97 16		sta [$0816],y	wr_lead     STA [STRPTR],Y
.1a14a1	c8		iny		            INY
.1a14a2	a2 05 00	ldx #$0005	            LDX #5
.1a14a5	b5 10		lda $0810,x	ascii_loop  LDA SCRATCH2,X
.1a14a7	29 f0		and #$f0	            AND #$F0
.1a14a9	4a		lsr a		            LSR A
.1a14aa	4a		lsr a		            LSR A
.1a14ab	4a		lsr a		            LSR A
.1a14ac	4a		lsr a		            LSR A
.1a14ad	20 37 14	jsr $1a1437	            JSR ITOS_DIGIT
.1a14b0	b5 10		lda $0810,x	            LDA SCRATCH2,X
.1a14b2	29 0f		and #$0f	            AND #$0F
.1a14b4	20 37 14	jsr $1a1437	            JSR ITOS_DIGIT
.1a14b7	ca		dex		            DEX
.1a14b8	10 eb		bpl $1a14a5	            BPL ascii_loop
.1a14ba	c0 01 00	cpy #$0001	            CPY #1              ; Did we write anything?
.1a14bd	d0 0c		bne $1a14cb	            BNE null_term       ; Yes: add a NULL to terminate
.1a14bf	a9 20		lda #$20	            LDA #' '            ; No: write a " 0" to the string
.1a14c1	87 16		sta [$0816]	            STA [STRPTR]
.1a14c3	a0 01 00	ldy #$0001	            LDY #1
.1a14c6	a9 30		lda #$30	            LDA #'0'
.1a14c8	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a14ca	c8		iny		            INY
.1a14cb	a9 00		lda #$00	null_term   LDA #0
.1a14cd	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And terminate the string
.1a14cf	28		plp		done        PLP
.1a14d0	60		rts		            RTS
.1a14d1	00		brk #		fault       BRK
.1a14d2	ea		nop		            NOP
.1a14d3					STRLEN
.1a14d3	08		php		            PHP
.1a14d4	e2 20		sep #$20	            SEP #$20
.1a14d6	c2 10		rep #$10	            REP #$10
.1a14d8	a0 00 00	ldy #$0000	            LDY #0
.1a14db	bd 00 00	lda $1a0000,x	loop        LDA #0,B,X
.1a14de	f0 04		beq $1a14e4	            BEQ done
.1a14e0	e8		inx		            INX
.1a14e1	c8		iny		            INY
.1a14e2	80 f7		bra $1a14db	            BRA loop
.1a14e4	28		plp		done        PLP
.1a14e5	60		rts		            RTS
.1a14e6					STRCMP
.1a14e6	08		php		            PHP
.1a14e7	0b		phd		            PHD
.1a14e8	08		php		            PHP
.1a14e9	c2 20		rep #$20	            REP #$20
.1a14eb	48		pha		            PHA
.1a14ec	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a14ef	5b		tcd		            TCD
.1a14f0	68		pla		            PLA
.1a14f1	28		plp		            PLP
.1a14f2	e2 20		sep #$20	            SEP #$20
.1a14f4	c2 10		rep #$10	            REP #$10
.1a14f6	a0 00 00	ldy #$0000	            LDY #0
.1a14f9	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Check if the character 1 is 0
.1a14fb	d0 04		bne $1a1501	            BNE comp_mag            ; If not, check the magnitudes
.1a14fd	b7 29		lda [$0829],y	            LDA [ARGUMENT2],Y       ; If so, check if the character 2 is 0
.1a14ff	f0 25		beq $1a1526	            BEQ are_equal           ; If so, the strings are equal
.1a1501	b7 23		lda [$0823],y	comp_mag    LDA [ARGUMENT1],Y       ; Otherwise, get character 1 again
.1a1503	d7 29		cmp [$0829],y	            CMP [ARGUMENT2],Y       ; And compare it to character 2
.1a1505	90 12		bcc $1a1519	            BLT is_less             ; Check if character 1 < character 2
.1a1507	d0 03		bne $1a150c	            BNE is_greater          ; Check if character 1 > character 2
.1a1509	c8		iny		            INY                     ; Equal so far... so go to the next pair of characters
.1a150a	80 ed		bra $1a14f9	            BRA loop
.1a150c					is_greater
.1a150c	c2 20		rep #$20	            REP #$20
.1a150e	a9 01 00	lda #$0001	            LDA #1                  ; So return 1
.1a1511	85 23		sta $0823	            STA ARGUMENT1
.1a1513	e2 20		sep #$20	            SEP #$20
.1a1515	64 25		stz $0825	            STZ ARGUMENT1+2
.1a1517	80 15		bra $1a152e	            BRA done
.1a1519					is_less
.1a1519	c2 20		rep #$20	            REP #$20
.1a151b	a9 ff ff	lda #$ffff	            LDA #$FFFF              ; So return -1
.1a151e	85 23		sta $0823	            STA ARGUMENT1
.1a1520	e2 20		sep #$20	            SEP #$20
.1a1522	85 25		sta $0825	            STA ARGUMENT1+2
.1a1524	80 08		bra $1a152e	            BRA done
.1a1526					are_equal
.1a1526	c2 20		rep #$20	            REP #$20
.1a1528	64 23		stz $0823	            STZ ARGUMENT1           ; So return 0
.1a152a	e2 20		sep #$20	            SEP #$20
.1a152c	64 25		stz $0825	            STZ ARGUMENT1+2
.1a152e					done
.1a152e	e2 20		sep #$20	            SEP #$20
.1a1530	a9 00		lda #$00	            LDA #TYPE_INTEGER
.1a1532	85 27		sta $0827	            STA ARGTYPE1
.1a1534	2b		pld		            PLD
.1a1535	28		plp		            PLP
.1a1536	60		rts		            RTS
.1a1537					STRCONCAT
.1a1537	08		php		            PHP
.1a1538	0b		phd		            PHD
.1a1539	8b		phb		            PHB
.1a153a	08		php		            PHP
.1a153b	c2 20		rep #$20	            REP #$20
.1a153d	48		pha		            PHA
.1a153e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1541	5b		tcd		            TCD
.1a1542	68		pla		            PLA
.1a1543	28		plp		            PLP
.1a1544	e2 20		sep #$20	            SEP #$20
.1a1546	c2 10		rep #$10	            REP #$10
.1a1548	08		php		            PHP
.1a1549	c2 20		rep #$20	            REP #$20
.1a154b	48		pha		            PHA
.1a154c	e2 20		sep #$20	            SEP #$20
.1a154e	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a1550	48		pha		            PHA
.1a1551	ab		plb		            PLB
.1a1552	c2 20		rep #$20	            REP #$20
.1a1554	68		pla		            PLA
.1a1555	28		plp		            PLP
.1a1556	a6 23		ldx $0823	            LDX ARGUMENT1
.1a1558	20 d3 14	jsr $1a14d3	            JSR STRLEN
.1a155b	84 0c		sty $080c	            STY SCRATCH
.1a155d	08		php		            PHP
.1a155e	c2 20		rep #$20	            REP #$20
.1a1560	48		pha		            PHA
.1a1561	e2 20		sep #$20	            SEP #$20
.1a1563	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a1565	48		pha		            PHA
.1a1566	ab		plb		            PLB
.1a1567	c2 20		rep #$20	            REP #$20
.1a1569	68		pla		            PLA
.1a156a	28		plp		            PLP
.1a156b	a6 29		ldx $0829	            LDX ARGUMENT2
.1a156d	20 d3 14	jsr $1a14d3	            JSR STRLEN
.1a1570	c2 20		rep #$20	            REP #$20
.1a1572	98		tya		            TYA
.1a1573	38		sec		            SEC                     ; X := LEN(ARGUMENT1) + LEN(ARGUMENT2) + 1
.1a1574	65 0c		adc $080c	            ADC SCRATCH
.1a1576	aa		tax		            TAX
.1a1577	e2 20		sep #$20	            SEP #$20
.1a1579	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set type to STRING
.1a157b	20 b9 0f	jsr $1a0fb9	            JSR ALLOC
.1a157e	c2 20		rep #$20	            REP #$20
.1a1580	a5 b7		lda $08b7	            LDA ALLOCATED           ; INDEX := pointer to the string
.1a1582	85 08		sta $0808	            STA INDEX
.1a1584	e2 20		sep #$20	            SEP #$20
.1a1586	a5 b9		lda $08b9	            LDA ALLOCATED+2
.1a1588	85 0a		sta $080a	            STA INDEX+2
.1a158a	a0 00 00	ldy #$0000	            LDY #0                  ; Set the target index to the beginning
.1a158d	08		php		            PHP
.1a158e	c2 20		rep #$20	            REP #$20
.1a1590	48		pha		            PHA
.1a1591	e2 20		sep #$20	            SEP #$20
.1a1593	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a1595	48		pha		            PHA
.1a1596	ab		plb		            PLB
.1a1597	c2 20		rep #$20	            REP #$20
.1a1599	68		pla		            PLA
.1a159a	28		plp		            PLP
.1a159b	a6 23		ldx $0823	            LDX ARGUMENT1
.1a159d	bd 00 00	lda $1a0000,x	loop1       LDA #0,B,X              ; Get the Xth byte of ARGUMENT1
.1a15a0	f0 06		beq $1a15a8	            BEQ copy_2              ; Is it null? Yes: move on to the next string
.1a15a2	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.1a15a4	e8		inx		            INX                     ; Point to the next characters
.1a15a5	c8		iny		            INY
.1a15a6	80 f5		bra $1a159d	            BRA loop1               ; And do again
.1a15a8					copy_2
.1a15a8	e2 20		sep #$20	            SEP #$20
.1a15aa	08		php		            PHP
.1a15ab	c2 20		rep #$20	            REP #$20
.1a15ad	48		pha		            PHA
.1a15ae	e2 20		sep #$20	            SEP #$20
.1a15b0	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a15b2	48		pha		            PHA
.1a15b3	ab		plb		            PLB
.1a15b4	c2 20		rep #$20	            REP #$20
.1a15b6	68		pla		            PLA
.1a15b7	28		plp		            PLP
.1a15b8	a6 29		ldx $0829	            LDX ARGUMENT2
.1a15ba	bd 00 00	lda $1a0000,x	loop2       LDA #0,B,X              ; Get the Xth byte of ARGUMENT2
.1a15bd	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.1a15bf	f0 04		beq $1a15c5	            BEQ terminate           ; Is it null? Yes: move on to the next string
.1a15c1	e8		inx		            INX                     ; Point to the next characters
.1a15c2	c8		iny		            INY
.1a15c3	80 f5		bra $1a15ba	            BRA loop2               ; And do again
.1a15c5					terminate
.1a15c5	c2 20		rep #$20	            REP #$20
.1a15c7	a5 08		lda $0808	            LDA INDEX               ; Set ARGUMENT1 to the new string
.1a15c9	85 23		sta $0823	            STA ARGUMENT1
.1a15cb	e2 20		sep #$20	            SEP #$20
.1a15cd	a5 0a		lda $080a	            LDA INDEX+2
.1a15cf	85 25		sta $0825	            STA ARGUMENT1+2
.1a15d1	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set ARGUMENT1's type to STRING
.1a15d3	85 27		sta $0827	            STA ARGTYPE1
.1a15d5	ab		plb		            PLB
.1a15d6	2b		pld		            PLD
.1a15d7	28		plp		            PLP
.1a15d8	60		rts		            RTS
.1a15d9					STRCPY
.1a15d9	da		phx		            PHX
.1a15da	5a		phy		            PHY
.1a15db	08		php		            PHP
.1a15dc	0b		phd		            PHD
.1a15dd	8b		phb		            PHB
.1a15de	08		php		            PHP
.1a15df	c2 20		rep #$20	            REP #$20
.1a15e1	48		pha		            PHA
.1a15e2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a15e5	5b		tcd		            TCD
.1a15e6	68		pla		            PLA
.1a15e7	28		plp		            PLP
.1a15e8	c2 20		rep #$20	            REP #$20
.1a15ea	a5 0a		lda $080a	            LDA INDEX+2
.1a15ec	48		pha		            PHA
.1a15ed	a5 08		lda $0808	            LDA INDEX
.1a15ef	48		pha		            PHA
.1a15f0	c2 30		rep #$30	            REP #$30
.1a15f2	08		php		            PHP
.1a15f3	c2 20		rep #$20	            REP #$20
.1a15f5	48		pha		            PHA
.1a15f6	e2 20		sep #$20	            SEP #$20
.1a15f8	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a15fa	48		pha		            PHA
.1a15fb	ab		plb		            PLB
.1a15fc	c2 20		rep #$20	            REP #$20
.1a15fe	68		pla		            PLA
.1a15ff	28		plp		            PLP
.1a1600	a6 23		ldx $0823	            LDX ARGUMENT1
.1a1602	20 d3 14	jsr $1a14d3	            JSR STRLEN
.1a1605	98		tya		            TYA
.1a1606	aa		tax		            TAX
.1a1607	e8		inx		            INX                     ; Put length of string (plus NUL) in X
.1a1608	e2 20		sep #$20	            SEP #$20
.1a160a	a9 02		lda #$02	            LDA #TYPE_STRING
.1a160c	20 b9 0f	jsr $1a0fb9	            JSR ALLOC
.1a160f	c2 20		rep #$20	            REP #$20
.1a1611	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a1613	85 08		sta $0808	            STA INDEX
.1a1615	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a1617	85 0a		sta $080a	            STA INDEX+2
.1a1619	a0 00 00	ldy #$0000	            LDY #0
.1a161c	e2 20		sep #$20	            SEP #$20
.1a161e	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Copy the data to the allocated string
.1a1620	97 08		sta [$0808],y	            STA [INDEX],Y
.1a1622	f0 03		beq $1a1627	            BEQ ret_copy
.1a1624	c8		iny		            INY
.1a1625	80 f7		bra $1a161e	            BRA loop
.1a1627					ret_copy
.1a1627	c2 20		rep #$20	            REP #$20
.1a1629	a5 08		lda $0808	            LDA INDEX
.1a162b	85 23		sta $0823	            STA ARGUMENT1
.1a162d	a5 0a		lda $080a	            LDA INDEX+2
.1a162f	85 25		sta $0825	            STA ARGUMENT1+2
.1a1631	c2 20		rep #$20	            REP #$20
.1a1633	68		pla		            PLA
.1a1634	85 08		sta $0808	            STA INDEX
.1a1636	68		pla		            PLA
.1a1637	85 0a		sta $080a	            STA INDEX+2
.1a1639	ab		plb		            PLB
.1a163a	2b		pld		            PLD
.1a163b	28		plp		            PLP
.1a163c	7a		ply		            PLY
.1a163d	fa		plx		            PLX
.1a163e	60		rts		            RTS
.1a163f					STRSUBSTR
.1a163f	08		php		            PHP
.1a1640	e2 20		sep #$20	            SEP #$20
.1a1642	c2 10		rep #$10	            REP #$10
.1a1644	a0 00 00	ldy #$0000	            LDY #0
.1a1647	b7 23		lda [$0823],y	count_loop  LDA [ARGUMENT1],Y
.1a1649	f0 05		beq $1a1650	            BEQ counted
.1a164b	c8		iny		            INY
.1a164c	80 f9		bra $1a1647	            BRA count_loop
.1a164e	84 92		sty $0892	            STY MTEMP               ; MTEMP := length of the source string
.1a1650					counted
.1a1650	c2 30		rep #$30	            REP #$30
.1a1652	c4 29		cpy $0829	            CPY ARGUMENT2           ; length of string <= index?
.1a1654	90 13		bcc $1a1669	            BLT ret_empty           ; Yes: return empty string
.1a1656	f0 11		beq $1a1669	            BEQ ret_empty
.1a1658	a5 8f		lda $088f	            LDA MCOUNT              ; Is the desired count <= 0?
.1a165a	30 0d		bmi $1a1669	            BMI ret_empty
.1a165c	f0 0b		beq $1a1669	            BEQ ret_empty           ; Yes: return the empty string
.1a165e	c4 8f		cpy $088f	            CPY MCOUNT              ; Is the desired length < the length of the source?
.1a1660	b0 12		bcs $1a1674	            BGE do_slice            ; Yes: go ahead and get the substring
.1a1662	a5 29		lda $0829	            LDA ARGUMENT2           ; Is INDEX == 0?
.1a1664	d0 0e		bne $1a1674	            BNE do_slice            ; No: do a slice
.1a1666	4c bd 16	jmp $1a16bd	            JMP done                ; Yes: just return the source string
.1a1669					ret_empty
.1a1669	20 e7 13	jsr $1a13e7	            JSR TEMPSTRING
.1a166c	e2 20		sep #$20	            SEP #$20
.1a166e	a9 00		lda #$00	            LDA #0
.1a1670	87 16		sta [$0816]	            STA [STRPTR]
.1a1672	80 39		bra $1a16ad	            BRA finish_copy
.1a1674					do_slice
.1a1674	20 e7 13	jsr $1a13e7	            JSR TEMPSTRING
.1a1677	c2 30		rep #$30	            REP #$30
.1a1679	18		clc		            CLC                     ; ARGUMENT1 := ARGUMENT1 + index
.1a167a	a5 23		lda $0823	            LDA ARGUMENT1
.1a167c	65 29		adc $0829	            ADC ARGUMENT2
.1a167e	85 23		sta $0823	            STA ARGUMENT1
.1a1680	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a1682	69 00 00	adc #$0000	            ADC #0
.1a1685	85 25		sta $0825	            STA ARGUMENT1+2
.1a1687	a0 00 00	ldy #$0000	            LDY #0
.1a168a					copy_loop
.1a168a	e2 20		sep #$20	            SEP #$20
.1a168c	a7 23		lda [$0823]	            LDA [ARGUMENT1]         ; Copy a character from the substring to the temporary string
.1a168e	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a1690	f0 1b		beq $1a16ad	            BEQ finish_copy         ; If it is a NULL, we're done
.1a1692	c2 20		rep #$20	            REP #$20
.1a1694	18		clc		            CLC                     ; Move to the next character
.1a1695	a5 23		lda $0823	            LDA ARGUMENT1
.1a1697	69 01 00	adc #$0001	            ADC #1
.1a169a	85 23		sta $0823	            STA ARGUMENT1
.1a169c	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a169e	69 00 00	adc #$0000	            ADC #0
.1a16a1	85 25		sta $0825	            STA ARGUMENT1+2
.1a16a3	c8		iny		            INY
.1a16a4	c4 8f		cpy $088f	            CPY MCOUNT              ; Have we reached the limit to copy?
.1a16a6	d0 e2		bne $1a168a	            BNE copy_loop           ; No: copy the next byte
.1a16a8	a9 00 00	lda #$0000	            LDA #0                  ; Null terminate string
.1a16ab	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a16ad					finish_copy
.1a16ad	c2 20		rep #$20	            REP #$20
.1a16af	a5 16		lda $0816	            LDA STRPTR
.1a16b1	85 23		sta $0823	            STA ARGUMENT1
.1a16b3	a5 18		lda $0818	            LDA STRPTR+2
.1a16b5	85 25		sta $0825	            STA ARGUMENT1+2
.1a16b7	e2 20		sep #$20	            SEP #$20
.1a16b9	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a16bb	85 27		sta $0827	            STA ARGTYPE1
.1a16bd					done
.1a16bd	28		plp		            PLP
.1a16be	60		rts		            RTS
.1a16bf					OP_STR_LT
.1a16bf	08		php		            PHP
.1a16c0	c2 30		rep #$30	            REP #$30
.1a16c2	20 e6 14	jsr $1a14e6	            JSR STRCMP
.1a16c5	a5 23		lda $0823	            LDA ARGUMENT1
.1a16c7	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.1a16ca	d0 05		bne $1a16d1	            BNE ret_false               ; No: return false
.1a16cc					ret_true
.1a16cc	20 18 05	jsr $1a0518	            JSR SET_TRUE
.1a16cf	80 03		bra $1a16d4	            BRA done
.1a16d1					ret_false
.1a16d1	20 2a 05	jsr $1a052a	            JSR SET_FALSE
.1a16d4	28		plp		done        PLP
.1a16d5	60		rts		            RTS
.1a16d6					OP_STR_GT
.1a16d6	08		php		            PHP
.1a16d7	c2 30		rep #$30	            REP #$30
.1a16d9	20 e6 14	jsr $1a14e6	            JSR STRCMP
.1a16dc	a5 23		lda $0823	            LDA ARGUMENT1
.1a16de	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.1a16e1	d0 05		bne $1a16e8	            BNE ret_false               ; No: return false
.1a16e3					ret_true
.1a16e3	20 18 05	jsr $1a0518	            JSR SET_TRUE
.1a16e6	80 03		bra $1a16eb	            BRA done
.1a16e8					ret_false
.1a16e8	20 2a 05	jsr $1a052a	            JSR SET_FALSE
.1a16eb	28		plp		done        PLP
.1a16ec	60		rts		            RTS
.1a16ed					OP_STR_EQ
.1a16ed	08		php		            PHP
.1a16ee	c2 30		rep #$30	            REP #$30
.1a16f0	20 e6 14	jsr $1a14e6	            JSR STRCMP
.1a16f3	a5 23		lda $0823	            LDA ARGUMENT1
.1a16f5	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.1a16f8	d0 05		bne $1a16ff	            BNE ret_false               ; No: return false
.1a16fa					ret_true
.1a16fa	20 18 05	jsr $1a0518	            JSR SET_TRUE
.1a16fd	80 03		bra $1a1702	            BRA done
.1a16ff					ret_false
.1a16ff	20 2a 05	jsr $1a052a	            JSR SET_FALSE
.1a1702	28		plp		done        PLP
.1a1703	60		rts		            RTS
.1a1704					OP_STR_NE
.1a1704	08		php		            PHP
.1a1705	c2 30		rep #$30	            REP #$30
.1a1707	20 e6 14	jsr $1a14e6	            JSR STRCMP
.1a170a	a5 23		lda $0823	            LDA ARGUMENT1
.1a170c	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.1a170f	f0 05		beq $1a1716	            BEQ ret_false               ; Yes: return false
.1a1711					ret_true
.1a1711	20 18 05	jsr $1a0518	            JSR SET_TRUE
.1a1714	80 03		bra $1a1719	            BRA done
.1a1716					ret_false
.1a1716	20 2a 05	jsr $1a052a	            JSR SET_FALSE
.1a1719	28		plp		done        PLP
.1a171a	60		rts		            RTS
.1a171b					OP_STR_GTE
.1a171b	08		php		            PHP
.1a171c	c2 30		rep #$30	            REP #$30
.1a171e	20 e6 14	jsr $1a14e6	            JSR STRCMP
.1a1721	a5 23		lda $0823	            LDA ARGUMENT1
.1a1723	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.1a1726	f0 05		beq $1a172d	            BEQ ret_false               ; Yes: return false
.1a1728					ret_true
.1a1728	20 18 05	jsr $1a0518	            JSR SET_TRUE
.1a172b	80 03		bra $1a1730	            BRA done
.1a172d					ret_false
.1a172d	20 2a 05	jsr $1a052a	            JSR SET_FALSE
.1a1730	28		plp		done        PLP
.1a1731	60		rts		            RTS
.1a1732					OP_STR_LTE
.1a1732	08		php		            PHP
.1a1733	c2 30		rep #$30	            REP #$30
.1a1735	20 e6 14	jsr $1a14e6	            JSR STRCMP
.1a1738	a5 23		lda $0823	            LDA ARGUMENT1
.1a173a	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.1a173d	f0 05		beq $1a1744	            BEQ ret_false               ; Yes: return false
.1a173f					ret_true
.1a173f	20 18 05	jsr $1a0518	            JSR SET_TRUE
.1a1742	80 03		bra $1a1747	            BRA done
.1a1744					ret_false
.1a1744	20 2a 05	jsr $1a052a	            JSR SET_FALSE
.1a1747	28		plp		done        PLP
.1a1748	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\listing.s

.1a1749					LISTPROG
.1a1749	48		pha		            PHA
.1a174a	5a		phy		            PHY
.1a174b	0b		phd		            PHD
.1a174c	08		php		            PHP
.1a174d	08		php		            PHP
.1a174e	c2 20		rep #$20	            REP #$20
.1a1750	48		pha		            PHA
.1a1751	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1754	5b		tcd		            TCD
.1a1755	68		pla		            PLA
.1a1756	28		plp		            PLP
.1a1757	c2 30		rep #$30	            REP #$30
.1a1759	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.1a175c	85 00		sta $0800	            STA BIP
.1a175e	85 1a		sta $081a	            STA CURLINE
.1a1760	a9 16 00	lda #$0016	            LDA #`BASIC_BOT
.1a1763	85 02		sta $0802	            STA BIP+2
.1a1765	85 1c		sta $081c	            STA CURLINE+2
.1a1767	ad 8a 0f	lda $0f8a	list_loop   LDA KEYFLAG         ; Check the keyboard flags
.1a176a	30 20		bmi $1a178c	            BMI throw_break     ; If MSB: user pressed an interrupt key, stop the listing
.1a176c	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.1a176f	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.1a1771	f0 0f		beq $1a1782	            BEQ done
.1a1773	c5 55		cmp $0855	            CMP MARG1
.1a1775	90 10		bcc $1a1787	            BLT skip_line
.1a1777	c5 59		cmp $0859	            CMP MARG2
.1a1779	f0 02		beq $1a177d	            BEQ print_line
.1a177b	b0 05		bcs $1a1782	            BGE done
.1a177d					print_line
.1a177d	20 ab 17	jsr $1a17ab	            JSR LISTLINE
.1a1780	80 e5		bra $1a1767	            BRA list_loop
.1a1782	28		plp		done        PLP
.1a1783	2b		pld		            PLD
.1a1784	7a		ply		            PLY
.1a1785	68		pla		            PLA
.1a1786	60		rts		            RTS
.1a1787					skip_line
.1a1787	20 74 20	jsr $1a2074	            JSR NEXTLINE
.1a178a	80 db		bra $1a1767	            BRA list_loop           ; And try again
.1a178c					throw_break
.1a178c	08		php		            PHP
.1a178d	c2 20		rep #$20	            REP #$20
.1a178f	48		pha		            PHA
.1a1790	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1793	5b		tcd		            TCD
.1a1794	68		pla		            PLA
.1a1795	28		plp		            PLP
.1a1796	e2 20		sep #$20	            SEP #$20
.1a1798	a9 01		lda #$01	            LDA #ERR_BREAK
.1a179a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a179e	c2 20		rep #$20	            REP #$20
.1a17a0	29 ff 00	and #$00ff	            AND #$00FF
.1a17a3	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a17a6	e2 20		sep #$20	            SEP #$20
.1a17a8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a17ab					LISTLINE
.1a17ab	08		php		            PHP
.1a17ac	c2 30		rep #$30	            REP #$30
.1a17ae	85 23		sta $0823	            STA ARGUMENT1
.1a17b0	64 25		stz $0825	            STZ ARGUMENT1+2
.1a17b2	20 46 14	jsr $1a1446	            JSR ITOS
.1a17b5	a5 16		lda $0816	            LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.1a17b7	1a		inc a		            INC A
.1a17b8	85 23		sta $0823	            STA ARGUMENT1
.1a17ba	a5 18		lda $0818	            LDA STRPTR+2
.1a17bc	85 25		sta $0825	            STA ARGUMENT1+2
.1a17be	20 26 44	jsr $1a4426	            JSR PR_STRING
.1a17c1	18		clc		            CLC                 ; Move the BIP to the first byte of the line
.1a17c2	a5 1a		lda $081a	            LDA CURLINE
.1a17c4	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a17c7	85 00		sta $0800	            STA BIP
.1a17c9	a5 1c		lda $081c	            LDA CURLINE+2
.1a17cb	69 00 00	adc #$0000	            ADC #0
.1a17ce	85 02		sta $0802	            STA BIP+2
.1a17d0	e2 20		sep #$20	            SEP #$20
.1a17d2	a9 20		lda #$20	            LDA #CHAR_SP
.1a17d4	20 18 00	jsr $1a0018	            JSR PRINTC
.1a17d7	c2 20		rep #$20	            REP #$20
.1a17d9					loop
.1a17d9	20 ea 17	jsr $1a17ea	            JSR LISTBYTE
.1a17dc	90 fb		bcc $1a17d9	            BCC loop
.1a17de	e2 20		sep #$20	            SEP #$20
.1a17e0	a9 0d		lda #$0d	            LDA #CHAR_CR
.1a17e2	20 18 00	jsr $1a0018	            JSR PRINTC
.1a17e5	20 74 20	jsr $1a2074	            JSR NEXTLINE
.1a17e8	28		plp		            PLP
.1a17e9	60		rts		            RTS
.1a17ea					LISTBYTE
.1a17ea	08		php		            PHP
.1a17eb	0b		phd		            PHD
.1a17ec	8b		phb		            PHB
.1a17ed	08		php		            PHP
.1a17ee	c2 20		rep #$20	            REP #$20
.1a17f0	48		pha		            PHA
.1a17f1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a17f4	5b		tcd		            TCD
.1a17f5	68		pla		            PLA
.1a17f6	28		plp		            PLP
.1a17f7	08		php		            PHP
.1a17f8	e2 20		sep #$20	            SEP #$20
.1a17fa	48		pha		            PHA
.1a17fb	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a17fd	48		pha		            PHA
.1a17fe	ab		plb		            PLB
.1a17ff	68		pla		            PLA
.1a1800	28		plp		            PLP
.1a1801	e2 20		sep #$20	            SEP #$20
.1a1803	c2 10		rep #$10	            REP #$10
.1a1805	a7 00		lda [$0800]	            LDA [BIP]           ; Get the current byte
.1a1807	f0 3a		beq $1a1843	            BEQ end_of_line     ; If it's 0, return with C set
.1a1809	30 05		bmi $1a1810	            BMI is_token        ; If it's 0x80 - 0xFF, it's a token
.1a180b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a180e	80 29		bra $1a1839	            BRA done            ; And return
.1a1810					is_token
.1a1810	c2 20		rep #$20	            REP #$20
.1a1812	29 7f 00	and #$007f	            AND #$007F          ; Compute the index of the token
.1a1815	0a		asl a		            ASL A               ; In the token table
.1a1816	0a		asl a		            ASL A
.1a1817	0a		asl a		            ASL A
.1a1818	18		clc		            CLC
.1a1819	69 e9 0b	adc #$0be9	            ADC #<>TOKENS       ; Set INDEX to the address of the token
.1a181c	85 08		sta $0808	            STA INDEX
.1a181e	a9 1a 00	lda #$001a	            LDA #`TOKENS
.1a1821	69 00 00	adc #$0000	            ADC #0
.1a1824	85 0a		sta $080a	            STA INDEX+2
.1a1826					pr_default
.1a1826	08		php		            PHP
.1a1827	e2 20		sep #$20	            SEP #$20
.1a1829	48		pha		            PHA
.1a182a	a9 1a		lda #$1a	            LDA #`TOKENS
.1a182c	48		pha		            PHA
.1a182d	ab		plb		            PLB
.1a182e	68		pla		            PLA
.1a182f	28		plp		            PLP
.1a1830	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.1a1833	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a1835	aa		tax		            TAX
.1a1836	20 4f 03	jsr $1a034f	            JSR PRINTS
.1a1839					done
.1a1839	c2 20		rep #$20	            REP #$20
.1a183b	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a183e	ab		plb		            PLB
.1a183f	2b		pld		            PLD
.1a1840	28		plp		            PLP
.1a1841	18		clc		            CLC
.1a1842	60		rts		            RTS
.1a1843	ab		plb		end_of_line PLB
.1a1844	2b		pld		            PLD
.1a1845	28		plp		            PLP
.1a1846	38		sec		            SEC
.1a1847	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\eval.s

.1a1848					INITEVALSP
.1a1848	08		php		            PHP
.1a1849	c2 20		rep #$20	            REP #$20
.1a184b	a9 ff 6f	lda #$6fff	            LDA #ARGUMENT_TOP
.1a184e	85 1f		sta $081f	            STA ARGUMENTSP
.1a1850	a9 ff 7f	lda #$7fff	            LDA #OPERATOR_TOP
.1a1853	85 21		sta $0821	            STA OPERATORSP
.1a1855	a9 ff ff	lda #$ffff	            LDA #$FFFF
.1a1858	85 23		sta $0823	            STA ARGUMENT1
.1a185a	85 25		sta $0825	            STA ARGUMENT1+2
.1a185c	85 29		sta $0829	            STA ARGUMENT2
.1a185e	85 2b		sta $082b	            STA ARGUMENT2+2
.1a1860	e2 20		sep #$20	            SEP #$20
.1a1862	85 27		sta $0827	            STA ARGTYPE1
.1a1864	85 2d		sta $082d	            STA ARGTYPE2
.1a1866	28		plp		            PLP
.1a1867	60		rts		            RTS
.1a1868					PHARGUMENT
.1a1868	08		php		            PHP
.1a1869	0b		phd		            PHD
.1a186a	8b		phb		            PHB
.1a186b	08		php		            PHP
.1a186c	c2 20		rep #$20	            REP #$20
.1a186e	48		pha		            PHA
.1a186f	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1872	5b		tcd		            TCD
.1a1873	68		pla		            PLA
.1a1874	28		plp		            PLP
.1a1875	08		php		            PHP
.1a1876	e2 20		sep #$20	            SEP #$20
.1a1878	48		pha		            PHA
.1a1879	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a187b	48		pha		            PHA
.1a187c	ab		plb		            PLB
.1a187d	68		pla		            PLA
.1a187e	28		plp		            PLP
.1a187f	c2 30		rep #$30	            REP #$30
.1a1881	5a		phy		            PHY
.1a1882	a4 1f		ldy $081f	            LDY ARGUMENTSP
.1a1884	bd 00 00	lda $0000,x	            LDA #0,B,X
.1a1887	99 00 00	sta $0000,y	            STA #0,B,Y
.1a188a	bd 02 00	lda $0002,x	            LDA #2,B,X
.1a188d	99 02 00	sta $0002,y	            STA #2,B,Y
.1a1890	e2 20		sep #$20	            SEP #$20
.1a1892	bd 04 00	lda $0004,x	            LDA #4,B,X
.1a1895	99 04 00	sta $0004,y	            STA #4,B,Y
.1a1898	c2 20		rep #$20	            REP #$20
.1a189a	38		sec		            SEC
.1a189b	98		tya		            TYA
.1a189c	e9 05 00	sbc #$0005	            SBC #ARGUMENT_SIZE
.1a189f	85 1f		sta $081f	            STA ARGUMENTSP
.1a18a1	7a		ply		            PLY
.1a18a2	ab		plb		            PLB
.1a18a3	2b		pld		            PLD
.1a18a4	28		plp		            PLP
.1a18a5	60		rts		            RTS
.1a18a6					PLARGUMENT
.1a18a6	08		php		            PHP
.1a18a7	0b		phd		            PHD
.1a18a8	8b		phb		            PHB
.1a18a9	08		php		            PHP
.1a18aa	c2 20		rep #$20	            REP #$20
.1a18ac	48		pha		            PHA
.1a18ad	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a18b0	5b		tcd		            TCD
.1a18b1	68		pla		            PLA
.1a18b2	28		plp		            PLP
.1a18b3	08		php		            PHP
.1a18b4	e2 20		sep #$20	            SEP #$20
.1a18b6	48		pha		            PHA
.1a18b7	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a18b9	48		pha		            PHA
.1a18ba	ab		plb		            PLB
.1a18bb	68		pla		            PLA
.1a18bc	28		plp		            PLP
.1a18bd	c2 30		rep #$30	            REP #$30
.1a18bf	5a		phy		            PHY
.1a18c0	18		clc		            CLC
.1a18c1	a5 1f		lda $081f	            LDA ARGUMENTSP
.1a18c3	69 05 00	adc #$0005	            ADC #ARGUMENT_SIZE
.1a18c6	85 1f		sta $081f	            STA ARGUMENTSP
.1a18c8	a8		tay		            TAY
.1a18c9	b9 00 00	lda $0000,y	            LDA #0,B,Y
.1a18cc	9d 00 00	sta $0000,x	            STA #0,B,X
.1a18cf	b9 02 00	lda $0002,y	            LDA #2,B,Y
.1a18d2	9d 02 00	sta $0002,x	            STA #2,B,X
.1a18d5	e2 20		sep #$20	            SEP #$20
.1a18d7	b9 04 00	lda $0004,y	            LDA #4,B,Y
.1a18da	9d 04 00	sta $0004,x	            STA #4,B,X
.1a18dd	bd 00 00	lda $0000,x	            LDA #0,B,X
.1a18e0	7a		ply		            PLY
.1a18e1	ab		plb		            PLB
.1a18e2	2b		pld		            PLD
.1a18e3	28		plp		            PLP
.1a18e4	60		rts		            RTS
.1a18e5					PHOPERATOR
.1a18e5	08		php		            PHP
.1a18e6	0b		phd		            PHD
.1a18e7	8b		phb		            PHB
.1a18e8	08		php		            PHP
.1a18e9	c2 20		rep #$20	            REP #$20
.1a18eb	48		pha		            PHA
.1a18ec	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a18ef	5b		tcd		            TCD
.1a18f0	68		pla		            PLA
.1a18f1	28		plp		            PLP
.1a18f2	08		php		            PHP
.1a18f3	e2 20		sep #$20	            SEP #$20
.1a18f5	48		pha		            PHA
.1a18f6	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a18f8	48		pha		            PHA
.1a18f9	ab		plb		            PLB
.1a18fa	68		pla		            PLA
.1a18fb	28		plp		            PLP
.1a18fc	e2 20		sep #$20	            SEP #$20
.1a18fe	c2 10		rep #$10	            REP #$10
.1a1900	5a		phy		            PHY
.1a1901	a4 21		ldy $0821	            LDY OPERATORSP
.1a1903	99 00 00	sta $0000,y	            STA #0,B,Y
.1a1906	88		dey		            DEY
.1a1907	84 21		sty $0821	            STY OPERATORSP
.1a1909	7a		ply		done        PLY
.1a190a	ab		plb		            PLB
.1a190b	2b		pld		            PLD
.1a190c	28		plp		            PLP
.1a190d	60		rts		            RTS
.1a190e					PLOPERATOR
.1a190e	08		php		            PHP
.1a190f	0b		phd		            PHD
.1a1910	8b		phb		            PHB
.1a1911	08		php		            PHP
.1a1912	c2 20		rep #$20	            REP #$20
.1a1914	48		pha		            PHA
.1a1915	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1918	5b		tcd		            TCD
.1a1919	68		pla		            PLA
.1a191a	28		plp		            PLP
.1a191b	08		php		            PHP
.1a191c	e2 20		sep #$20	            SEP #$20
.1a191e	48		pha		            PHA
.1a191f	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1921	48		pha		            PHA
.1a1922	ab		plb		            PLB
.1a1923	68		pla		            PLA
.1a1924	28		plp		            PLP
.1a1925	e2 20		sep #$20	            SEP #$20
.1a1927	c2 10		rep #$10	            REP #$10
.1a1929	5a		phy		            PHY
.1a192a	a4 21		ldy $0821	            LDY OPERATORSP
.1a192c	c8		iny		            INY
.1a192d	84 21		sty $0821	            STY OPERATORSP
.1a192f	b9 00 00	lda $0000,y	            LDA #0,B,Y
.1a1932	c2 20		rep #$20	            REP #$20
.1a1934	29 ff 00	and #$00ff	            AND #$00FF
.1a1937	7a		ply		            PLY
.1a1938	ab		plb		            PLB
.1a1939	2b		pld		            PLD
.1a193a	28		plp		            PLP
.1a193b	60		rts		            RTS
.1a193c					OPENPARAMS
.1a193c	08		php		            PHP
.1a193d	e2 20		sep #$20	            SEP #$20
.1a193f	a9 01		lda #$01	            LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.1a1941	20 e5 18	jsr $1a18e5	            JSR PHOPERATOR
.1a1944	28		plp		            PLP
.1a1945	60		rts		            RTS
.1a1946					CLOSEPARAMS
.1a1946	5a		phy		            PHY
.1a1947	08		php		            PHP
.1a1948	8b		phb		            PHB
.1a1949	08		php		            PHP
.1a194a	e2 20		sep #$20	            SEP #$20
.1a194c	48		pha		            PHA
.1a194d	a9 00		lda #$00	            LDA #0
.1a194f	48		pha		            PHA
.1a1950	ab		plb		            PLB
.1a1951	68		pla		            PLA
.1a1952	28		plp		            PLP
.1a1953	e2 20		sep #$20	            SEP #$20
.1a1955	a4 21		ldy $0821	            LDY OPERATORSP      ; Peek at the top operator
.1a1957	b9 01 00	lda $0001,y	            LDA #1,B,Y
.1a195a	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the marker for the start of a parameter list
.1a195c	d0 08		bne $1a1966	            BNE error           ; No: there's a problem
.1a195e	c2 20		rep #$20	            REP #$20
.1a1960	e6 21		inc $0821	            INC OPERATORSP      ; Yes: remove it from the operator stack.
.1a1962	ab		plb		            PLB
.1a1963	28		plp		            PLP
.1a1964	7a		ply		            PLY
.1a1965	60		rts		            RTS
.1a1966					error
.1a1966	08		php		            PHP
.1a1967	c2 20		rep #$20	            REP #$20
.1a1969	48		pha		            PHA
.1a196a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a196d	5b		tcd		            TCD
.1a196e	68		pla		            PLA
.1a196f	28		plp		            PLP
.1a1970	e2 20		sep #$20	            SEP #$20
.1a1972	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1974	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1978	c2 20		rep #$20	            REP #$20
.1a197a	29 ff 00	and #$00ff	            AND #$00FF
.1a197d	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a1980	e2 20		sep #$20	            SEP #$20
.1a1982	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1985					OPHIGHPREC
.1a1985	48		pha		            PHA
.1a1986	08		php		            PHP
.1a1987	0b		phd		            PHD
.1a1988	8b		phb		            PHB
.1a1989	08		php		            PHP
.1a198a	c2 20		rep #$20	            REP #$20
.1a198c	48		pha		            PHA
.1a198d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1990	5b		tcd		            TCD
.1a1991	68		pla		            PLA
.1a1992	28		plp		            PLP
.1a1993	08		php		            PHP
.1a1994	e2 20		sep #$20	            SEP #$20
.1a1996	48		pha		            PHA
.1a1997	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1999	48		pha		            PHA
.1a199a	ab		plb		            PLB
.1a199b	68		pla		            PLA
.1a199c	28		plp		            PLP
.1a199d	e2 20		sep #$20	            SEP #$20
.1a199f	a4 21		ldy $0821	            LDY OPERATORSP
.1a19a1	c0 ff 7f	cpy #$7fff	            CPY #OPERATOR_TOP       ; Is the stack empty?
.1a19a4	f0 11		beq $1a19b7	            BEQ is_false            ; Yes: return false
.1a19a6	20 48 0b	jsr $1a0b48	            JSR TOKPRECED
.1a19a9	85 0c		sta $080c	            STA SCRATCH             ; Save it for later comparison
.1a19ab	b9 01 00	lda $0001,y	            LDA #1,B,Y              ; Get the operator at the top of the stack
.1a19ae	20 48 0b	jsr $1a0b48	            JSR TOKPRECED
.1a19b1	c5 0c		cmp $080c	            CMP SCRATCH             ; Compare the priorities (0 = highest priority)
.1a19b3	f0 02		beq $1a19b7	            BEQ is_false            ; A = SCRATCH, return false
.1a19b5	90 08		bcc $1a19bf	            BCC is_true             ; A < SCRATCH (A is higher priority), return false
.1a19b7					is_false
.1a19b7	c2 20		rep #$20	            REP #$20
.1a19b9	ab		plb		            PLB
.1a19ba	2b		pld		            PLD
.1a19bb	28		plp		            PLP
.1a19bc	68		pla		            PLA
.1a19bd	18		clc		            CLC
.1a19be	60		rts		            RTS
.1a19bf					is_true
.1a19bf	c2 20		rep #$20	            REP #$20
.1a19c1	ab		plb		            PLB                     ; A > SCRATCH (A is lower priority), return true
.1a19c2	2b		pld		            PLD
.1a19c3	28		plp		            PLP
.1a19c4	68		pla		            PLA
.1a19c5	38		sec		            SEC
.1a19c6	60		rts		            RTS
.1a19c7					EVALNUMBER
.1a19c7	4c c3 07	jmp $1a07c3	            JMP PARSEINT
.1a19ca					ARR_GETIDX
.1a19ca	08		php		            PHP
.1a19cb	e2 20		sep #$20	            SEP #$20
.1a19cd	a9 00		lda #$00	            LDA #0
.1a19cf	8f 00 4d 00	sta $004d00	            STA @lARRIDXBUF     ; Set the dimension to 0
.1a19d3	a2 01 00	ldx #$0001	            LDX #1
.1a19d6					eval_index
.1a19d6	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a19d9	20 f8 05	jsr $1a05f8	            JSR ASS_ARG1_INT16
.1a19dc	c2 20		rep #$20	            REP #$20
.1a19de	a5 23		lda $0823	            LDA ARGUMENT1       ; Save the index to the array index buffer
.1a19e0	9f 00 4d 00	sta $004d00,x	            STA @lARRIDXBUF,X
.1a19e4	e2 20		sep #$20	            SEP #$20
.1a19e6	af 00 4d 00	lda $004d00	            LDA @lARRIDXBUF     ; Increment the index count
.1a19ea	1a		inc a		            INC A
.1a19eb	30 3e		bmi $1a1a2b	            BMI arg_err         ; If more than 127 dimensions, throw a range error
.1a19ed	8f 00 4d 00	sta $004d00	            STA @lARRIDXBUF
.1a19f1	e8		inx		            INX
.1a19f2	e8		inx		            INX
.1a19f3	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a19f6	e2 20		sep #$20	            SEP #$20
.1a19f8	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.1a19fa	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it ")"
.1a19fc	f0 09		beq $1a1a07	            BEQ clean_op        ; Yes: cleanup the argument stack
.1a19fe	c9 2c		cmp #$2c	            CMP #','            ; Is it a comma?
.1a1a00	d0 0a		bne $1a1a0c	            BNE syntax_err      ; No: throw a syntax error
.1a1a02					skip_comma
.1a1a02	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a1a05	80 cf		bra $1a19d6	            BRA eval_index      ; And grab the next index
.1a1a07					clean_op
.1a1a07	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a1a0a	28		plp		            PLP
.1a1a0b	60		rts		            RTS
.1a1a0c					syntax_err
.1a1a0c	08		php		            PHP
.1a1a0d	c2 20		rep #$20	            REP #$20
.1a1a0f	48		pha		            PHA
.1a1a10	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1a13	5b		tcd		            TCD
.1a1a14	68		pla		            PLA
.1a1a15	28		plp		            PLP
.1a1a16	e2 20		sep #$20	            SEP #$20
.1a1a18	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1a1a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1a1e	c2 20		rep #$20	            REP #$20
.1a1a20	29 ff 00	and #$00ff	            AND #$00FF
.1a1a23	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a1a26	e2 20		sep #$20	            SEP #$20
.1a1a28	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1a2b					arg_err
.1a1a2b	08		php		            PHP
.1a1a2c	c2 20		rep #$20	            REP #$20
.1a1a2e	48		pha		            PHA
.1a1a2f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1a32	5b		tcd		            TCD
.1a1a33	68		pla		            PLA
.1a1a34	28		plp		            PLP
.1a1a35	e2 20		sep #$20	            SEP #$20
.1a1a37	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a1a39	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1a3d	c2 20		rep #$20	            REP #$20
.1a1a3f	29 ff 00	and #$00ff	            AND #$00FF
.1a1a42	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a1a45	e2 20		sep #$20	            SEP #$20
.1a1a47	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1a4a					EVALREF
.1a1a4a	08		php		            PHP
.1a1a4b					get_name
.1a1a4b	20 cc 51	jsr $1a51cc	            JSR VAR_FINDNAME
.1a1a4e	90 23		bcc $1a1a73	            BCC syntax_err      ; If we didn't find a name, thrown an error
.1a1a50	e2 20		sep #$20	            SEP #$20
.1a1a52	a5 ea		lda $08ea	            LDA TOFINDTYPE      ; Check the type of the variable
.1a1a54	29 80		and #$80	            AND #$80            ; Is it an array?
.1a1a56	d0 06		bne $1a1a5e	            BNE is_array        ; Yes: look for the indexes
.1a1a58	20 cd 4f	jsr $1a4fcd	            JSR VAR_REF
.1a1a5b	4c 71 1a	jmp $1a1a71	            JMP done
.1a1a5e					is_array
.1a1a5e	e2 20		sep #$20	            SEP #$20
.1a1a60	a9 8f		lda #$8f	            LDA #TOK_LPAREN
.1a1a62	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a1a65	20 3c 19	jsr $1a193c	            JSR OPENPARAMS
.1a1a68					            PHARRIDX
.1a1a68	20 ca 19	jsr $1a19ca	            JSR ARR_GETIDX
.1a1a6b	20 83 66	jsr $1a6683	            JSR ARR_REF
.1a1a6e					            PLARRIDX
.1a1a6e	20 46 19	jsr $1a1946	            JSR CLOSEPARAMS
.1a1a71	28		plp		done        PLP
.1a1a72	60		rts		            RTS
.1a1a73					syntax_err
.1a1a73	08		php		            PHP
.1a1a74	c2 20		rep #$20	            REP #$20
.1a1a76	48		pha		            PHA
.1a1a77	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1a7a	5b		tcd		            TCD
.1a1a7b	68		pla		            PLA
.1a1a7c	28		plp		            PLP
.1a1a7d	e2 20		sep #$20	            SEP #$20
.1a1a7f	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1a81	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1a85	c2 20		rep #$20	            REP #$20
.1a1a87	29 ff 00	and #$00ff	            AND #$00FF
.1a1a8a	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a1a8d	e2 20		sep #$20	            SEP #$20
.1a1a8f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1a92					EVALSTRING
.1a1a92	08		php		            PHP
.1a1a93	0b		phd		            PHD
.1a1a94	08		php		            PHP
.1a1a95	c2 20		rep #$20	            REP #$20
.1a1a97	48		pha		            PHA
.1a1a98	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1a9b	5b		tcd		            TCD
.1a1a9c	68		pla		            PLA
.1a1a9d	28		plp		            PLP
.1a1a9e	e2 20		sep #$20	            SEP #$20
.1a1aa0	c2 10		rep #$10	            REP #$10
.1a1aa2	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a1aa5	a0 00 00	ldy #$0000	            LDY #0              ; Ywill be our length counter
.1a1aa8	b7 00		lda [$0800],y	count_loop  LDA [BIP],Y         ; Get the character
.1a1aaa	f0 24		beq $1a1ad0	            BEQ error           ; If it's end-of-line, throw an error
.1a1aac	c9 22		cmp #$22	            CMP #CHAR_DQUOTE    ; Is it the ending double-quote?
.1a1aae	f0 03		beq $1a1ab3	            BEQ found_end       ; Yes: Y should be the length
.1a1ab0	c8		iny		            INY
.1a1ab1	80 f5		bra $1a1aa8	            BRA count_loop
.1a1ab3	84 0c		sty $080c	found_end   STY SCRATCH         ; Save the length to SCRATCH
.1a1ab5	e2 20		sep #$20	            SEP #$20
.1a1ab7	a9 02		lda #$02	            LDA #TYPE_STRING    ; Set the type to allocate to STRING
.1a1ab9	a6 0c		ldx $080c	            LDX SCRATCH         ; And the length to the length of the string literal
.1a1abb	e8		inx		            INX
.1a1abc	20 e7 13	jsr $1a13e7	            JSR TEMPSTRING
.1a1abf	a0 00 00	ldy #$0000	            LDY #0
.1a1ac2	c4 0c		cpy $080c	copy_loop   CPY SCRATCH         ; Have we copied all the characters?
.1a1ac4	f0 29		beq $1a1aef	            BEQ done            ; Yes: we're done
.1a1ac6	a7 00		lda [$0800]	            LDA [BIP]           ; No: get the next character
.1a1ac8	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And copy it to the allocated string
.1a1aca	c8		iny		            INY
.1a1acb	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a1ace	80 f2		bra $1a1ac2	            BRA copy_loop       ; And try the next character
.1a1ad0					error
.1a1ad0	08		php		            PHP
.1a1ad1	c2 20		rep #$20	            REP #$20
.1a1ad3	48		pha		            PHA
.1a1ad4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1ad7	5b		tcd		            TCD
.1a1ad8	68		pla		            PLA
.1a1ad9	28		plp		            PLP
.1a1ada	e2 20		sep #$20	            SEP #$20
.1a1adc	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1ade	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1ae2	c2 20		rep #$20	            REP #$20
.1a1ae4	29 ff 00	and #$00ff	            AND #$00FF
.1a1ae7	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a1aea	e2 20		sep #$20	            SEP #$20
.1a1aec	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1aef	a9 00		lda #$00	done        LDA #0
.1a1af1	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a1af3	c2 20		rep #$20	            REP #$20
.1a1af5	a5 16		lda $0816	            LDA STRPTR
.1a1af7	85 23		sta $0823	            STA ARGUMENT1
.1a1af9	a5 18		lda $0818	            LDA STRPTR+2
.1a1afb	85 25		sta $0825	            STA ARGUMENT1+2
.1a1afd	a9 02 00	lda #$0002	            LDA #TYPE_STRING    ; And set the type of ARGUMENT1 to string
.1a1b00	85 27		sta $0827	            STA ARGTYPE1
.1a1b02	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a1b05	2b		pld		            PLD
.1a1b06	28		plp		            PLP
.1a1b07	60		rts		            RTS
.1a1b08					EVAL_FUNC
.1a1b08	08		php		            PHP
.1a1b09	e2 20		sep #$20	            SEP #$20
.1a1b0b	a7 00		lda [$0800]	            LDA [BIP]           ; Get the token
.1a1b0d	c2 20		rep #$20	            REP #$20
.1a1b0f	29 ff 00	and #$00ff	            AND #$00FF
.1a1b12	20 72 0b	jsr $1a0b72	            JSR TOKEVAL
.1a1b15	85 2f		sta $082f	            STA JMP16PTR
.1a1b17	20 3c 19	jsr $1a193c	            JSR OPENPARAMS
.1a1b1a	08		php		            PHP
.1a1b1b	e2 20		sep #$20	            SEP #$20
.1a1b1d	48		pha		            PHA
.1a1b1e	a9 00		lda #$00	            LDA #0
.1a1b20	48		pha		            PHA
.1a1b21	ab		plb		            PLB
.1a1b22	68		pla		            PLA
.1a1b23	28		plp		            PLP
.1a1b24	20 2c 1b	jsr $1a1b2c	            JSR OPSTUB
.1a1b27	20 46 19	jsr $1a1946	            JSR CLOSEPARAMS
.1a1b2a	28		plp		            PLP
.1a1b2b	60		rts		            RTS
.1a1b2c					OPSTUB
.1a1b2c	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a1b2f	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.1a1b32					PROCESSOP
.1a1b32	48		pha		            PHA
.1a1b33	08		php		            PHP
.1a1b34	0b		phd		            PHD
.1a1b35	8b		phb		            PHB
.1a1b36	08		php		            PHP
.1a1b37	c2 20		rep #$20	            REP #$20
.1a1b39	48		pha		            PHA
.1a1b3a	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1b3d	5b		tcd		            TCD
.1a1b3e	68		pla		            PLA
.1a1b3f	28		plp		            PLP
.1a1b40	c2 30		rep #$30	            REP #$30
.1a1b42	20 0e 19	jsr $1a190e	            JSR PLOPERATOR
.1a1b45	89 80 00	bit #$0080	            BIT #$80            ; Check if it's really a token
.1a1b48	f0 37		beq $1a1b81	            BEQ bad_token       ; No: it's a bad token
.1a1b4a	48		pha		            PHA
.1a1b4b	20 72 0b	jsr $1a0b72	            JSR TOKEVAL
.1a1b4e	85 2f		sta $082f	            STA JMP16PTR
.1a1b50	68		pla		            PLA
.1a1b51	20 bf 0b	jsr $1a0bbf	            JSR TOKARITY
.1a1b54	c9 01 00	cmp #$0001	            CMP #1              ; Check the operator's arity
.1a1b57	f0 08		beq $1a1b61	            BEQ pull_arg1       ; If it's 1 just pull one argument from the stack
.1a1b59	c2 30		rep #$30	            REP #$30
.1a1b5b	a2 29 08	ldx #$0829	            LDX #<>ARGUMENT2    ; Pull argument 2 from the stack
.1a1b5e	20 a6 18	jsr $1a18a6	            JSR PLARGUMENT
.1a1b61					pull_arg1
.1a1b61	c2 30		rep #$30	            REP #$30
.1a1b63	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Pull argument 1 from the stack
.1a1b66	20 a6 18	jsr $1a18a6	            JSR PLARGUMENT
.1a1b69	08		php		            PHP
.1a1b6a	e2 20		sep #$20	            SEP #$20
.1a1b6c	48		pha		            PHA
.1a1b6d	a9 00		lda #$00	            LDA #0
.1a1b6f	48		pha		            PHA
.1a1b70	ab		plb		            PLB
.1a1b71	68		pla		            PLA
.1a1b72	28		plp		            PLP
.1a1b73	20 83 1b	jsr $1a1b83	            JSR OPSTUB
.1a1b76	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Get return result in argument 1
.1a1b79	20 68 18	jsr $1a1868	            JSR PHARGUMENT
.1a1b7c	ab		plb		            PLB
.1a1b7d	2b		pld		            PLD
.1a1b7e	28		plp		            PLP
.1a1b7f	68		pla		            PLA
.1a1b80	60		rts		            RTS
.1a1b81	00		brk #		bad_token   BRK
.1a1b82	ea		nop		            NOP
.1a1b83	6c 2f 08	jmp ($082f)	OPSTUB      JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.1a1b86					EVALEXPR
.1a1b86	08		php		            PHP
.1a1b87	08		php		            PHP
.1a1b88	c2 20		rep #$20	            REP #$20
.1a1b8a	48		pha		            PHA
.1a1b8b	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1b8e	5b		tcd		            TCD
.1a1b8f	68		pla		            PLA
.1a1b90	28		plp		            PLP
.1a1b91	08		php		            PHP
.1a1b92	e2 20		sep #$20	            SEP #$20
.1a1b94	48		pha		            PHA
.1a1b95	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1b97	48		pha		            PHA
.1a1b98	ab		plb		            PLB
.1a1b99	68		pla		            PLA
.1a1b9a	28		plp		            PLP
.1a1b9b	c2 10		rep #$10	            REP #$10
.1a1b9d	da		phx		            PHX
.1a1b9e					get_char
.1a1b9e	e2 20		sep #$20	            SEP #$20
.1a1ba0	a7 00		lda [$0800]	            LDA [BIP]           ; Get the character
.1a1ba2	d0 03		bne $1a1ba7	            BNE else1
.1a1ba4	4c 49 1c	jmp $1a1c49	            JMP proc_stack      ; Handle end of line, if we see it
.1a1ba7	30 33		bmi $1a1bdc	else1       BMI is_token        ; If MSB is set, it's a token
.1a1ba9	c9 20		cmp #$20	            CMP #' '            ; Is it a space?
.1a1bab	d0 03		bne $1a1bb0	            BNE else2
.1a1bad	4c 43 1c	jmp $1a1c43	            JMP next_char       ; Yes: Skip to the next character
.1a1bb0	c9 3a		cmp #$3a	else2       CMP #'9'+1          ; Check to see if we have digits
.1a1bb2	b0 04		bcs $1a1bb8	            BCS else3           ; No: treat as the end of the line
.1a1bb4	c9 30		cmp #$30	            CMP #'0'
.1a1bb6	b0 56		bcs $1a1c0e	            BCS is_digit
.1a1bb8	c9 26		cmp #$26	else3       CMP #'&'            ; Check for a hexadecimal prefix
.1a1bba	f0 52		beq $1a1c0e	            BEQ is_digit
.1a1bbc	c9 22		cmp #$22	            CMP #'"'            ; Is it a double-quote?
.1a1bbe	d0 03		bne $1a1bc3	            BNE else4
.1a1bc0	4c 5c 1c	jmp $1a1c5c	            JMP is_string       ; Yes: process the string
.1a1bc3	c9 5b		cmp #$5b	else4       CMP #'Z'+1          ; Check to see if we have upper case alphabetics
.1a1bc5	b0 07		bcs $1a1bce	            BCS check_lc        ; No: check for lower case
.1a1bc7	c9 41		cmp #$41	            CMP #'A'
.1a1bc9	90 03		bcc $1a1bce	            BCC check_lc
.1a1bcb	4c 68 1c	jmp $1a1c68	            JMP is_alpha
.1a1bce	c9 7b		cmp #$7b	check_lc    CMP #'z'+1          ; Check to see if we have lower case alphabetics
.1a1bd0	b0 07		bcs $1a1bd9	            BCS else5           ; No: treat as the end of the line
.1a1bd2	c9 61		cmp #$61	            CMP #'a'
.1a1bd4	90 03		bcc $1a1bd9	            BCC else5
.1a1bd6	4c 68 1c	jmp $1a1c68	            JMP is_alpha
.1a1bd9	4c 49 1c	jmp $1a1c49	else5       JMP proc_stack
.1a1bdc	c9 8f		cmp #$8f	is_token    CMP #TOK_LPAREN     ; Is it an LPAREN
.1a1bde	f0 40		beq $1a1c20	            BEQ is_lparen       ; Yes: handle the LPAREN
.1a1be0	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it an RPAREN?
.1a1be2	f0 41		beq $1a1c25	            BEQ is_rparen       ; Yes: handle the RPAREN
.1a1be4	20 95 0b	jsr $1a0b95	            JSR TOKTYPE
.1a1be7	c9 30		cmp #$30	            CMP #TOK_TY_FUNC    ; Is it a function?
.1a1be9	d0 0c		bne $1a1bf7	            BNE chk_op          ; No: check if it's an operator
.1a1beb	20 08 1b	jsr $1a1b08	            JSR EVAL_FUNC
.1a1bee	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.1a1bf1	20 68 18	jsr $1a1868	            JSR PHARGUMENT
.1a1bf4	4c 9e 1b	jmp $1a1b9e	            JMP get_char
.1a1bf7	c9 00		cmp #$00	chk_op      CMP #TOK_TY_OP      ; Is it an operator?
.1a1bf9	d0 4e		bne $1a1c49	            BNE proc_stack      ; No: we're finished processing
.1a1bfb	a7 00		lda [$0800]	            LDA [BIP]           ; Yes: Get the token back
.1a1bfd	a6 21		ldx $0821	chk_prec    LDX OPERATORSP      ; Is the operator stack empty?
.1a1bff	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.1a1c02	f0 05		beq $1a1c09	            BEQ push_op         ; Yes: push the operator
.1a1c04	20 85 19	jsr $1a1985	            JSR OPHIGHPREC
.1a1c07	b0 12		bcs $1a1c1b	            BCS process1        ; No: we should process the top operator
.1a1c09					push_op
.1a1c09	20 e5 18	jsr $1a18e5	            JSR PHOPERATOR
.1a1c0c	80 35		bra $1a1c43	            BRA next_char       ; And go to the next character
.1a1c0e					is_digit
.1a1c0e	c2 20		rep #$20	            REP #$20
.1a1c10	20 ee 57	jsr $1a57ee	            JSR PARSENUM
.1a1c13	a2 23 08	ldx #$0823	got_number  LDX #<>ARGUMENT1
.1a1c16	20 68 18	jsr $1a1868	            JSR PHARGUMENT
.1a1c19	80 83		bra $1a1b9e	            BRA get_char
.1a1c1b					process1
.1a1c1b	20 32 1b	jsr $1a1b32	            JSR PROCESSOP
.1a1c1e	80 dd		bra $1a1bfd	            BRA chk_prec        ; And check what to do with the current operator
.1a1c20					is_lparen
.1a1c20	20 e5 18	jsr $1a18e5	            JSR PHOPERATOR
.1a1c23	80 1e		bra $1a1c43	            BRA next_char
.1a1c25					is_rparen
.1a1c25	e2 20		sep #$20	            SEP #$20
.1a1c27	a4 21		ldy $0821	            LDY OPERATORSP      ; Is the operator stack empty?
.1a1c29	c0 ff 7f	cpy #$7fff	            CPY #<>OPERATOR_TOP
.1a1c2c	f0 46		beq $1a1c74	            BEQ done            ; Yes: we're done evaluating things
.1a1c2e	a4 21		ldy $0821	paren_loop  LDY OPERATORSP      ; Peek at the top operator
.1a1c30	b9 01 00	lda $0001,y	            LDA #1,B,Y
.1a1c33	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the LPAREN of a function?
.1a1c35	f0 3d		beq $1a1c74	            BEQ done            ; Yes: treat it as an empty stack
.1a1c37	c9 8f		cmp #$8f	            CMP #TOK_LPAREN     ; Is it an LPAREN?
.1a1c39	f0 05		beq $1a1c40	            BEQ done_rparen     ; Yes: we're finished processing
.1a1c3b	20 32 1b	jsr $1a1b32	            JSR PROCESSOP
.1a1c3e	80 ee		bra $1a1c2e	            BRA paren_loop
.1a1c40					done_rparen
.1a1c40	20 0e 19	jsr $1a190e	            JSR PLOPERATOR
.1a1c43					next_char
.1a1c43	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a1c46	4c 9e 1b	jmp $1a1b9e	            JMP get_char
.1a1c49					proc_stack
.1a1c49	a6 21		ldx $0821	            LDX OPERATORSP      ; Is the operator stack empty?
.1a1c4b	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.1a1c4e	b0 24		bcs $1a1c74	            BGE done            ; Yes: return to the caller
.1a1c50	bd 01 00	lda $0001,x	            LDA #1,B,X
.1a1c53	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is top operator a function open?
.1a1c55	f0 1d		beq $1a1c74	            BEQ done            ; Yes: treat as end of expression
.1a1c57	20 32 1b	jsr $1a1b32	            JSR PROCESSOP
.1a1c5a	80 ed		bra $1a1c49	            BRA proc_stack
.1a1c5c					is_string
.1a1c5c	20 92 1a	jsr $1a1a92	            JSR EVALSTRING
.1a1c5f	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.1a1c62	20 68 18	jsr $1a1868	            JSR PHARGUMENT
.1a1c65	4c 9e 1b	jmp $1a1b9e	            JMP get_char
.1a1c68					is_alpha
.1a1c68	20 4a 1a	jsr $1a1a4a	            JSR EVALREF
.1a1c6b	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.1a1c6e	20 68 18	jsr $1a1868	            JSR PHARGUMENT
.1a1c71	4c 9e 1b	jmp $1a1b9e	            JMP get_char
.1a1c74	a2 23 08	ldx #$0823	done        LDX #<>ARGUMENT1    ; Make sure the result is off the stack
.1a1c77	20 a6 18	jsr $1a18a6	            JSR PLARGUMENT
.1a1c7a	fa		plx		            PLX
.1a1c7b	28		plp		            PLP
.1a1c7c	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\returnstack.s

.1a1c7d					INITRETURN
.1a1c7d	08		php		                PHP
.1a1c7e	0b		phd		                PHD
.1a1c7f	8b		phb		                PHB
.1a1c80	08		php		            PHP
.1a1c81	e2 20		sep #$20	            SEP #$20
.1a1c83	48		pha		            PHA
.1a1c84	a9 00		lda #$00	            LDA #0
.1a1c86	48		pha		            PHA
.1a1c87	ab		plb		            PLB
.1a1c88	68		pla		            PLA
.1a1c89	28		plp		            PLP
.1a1c8a	08		php		            PHP
.1a1c8b	c2 20		rep #$20	            REP #$20
.1a1c8d	48		pha		            PHA
.1a1c8e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1c91	5b		tcd		            TCD
.1a1c92	68		pla		            PLA
.1a1c93	28		plp		            PLP
.1a1c94	c2 30		rep #$30	            REP #$30
.1a1c96	a9 fd 5f	lda #$5ffd	                LDA #RETURN_TOP-2
.1a1c99	85 33		sta $0833	                STA RETURNSP
.1a1c9b	ab		plb		                PLB
.1a1c9c	2b		pld		                PLD
.1a1c9d	28		plp		                PLP
.1a1c9e	60		rts		            RTS
.1a1c9f					PHRETURN
.1a1c9f	08		php		                PHP
.1a1ca0	0b		phd		                PHD
.1a1ca1	08		php		            PHP
.1a1ca2	c2 20		rep #$20	            REP #$20
.1a1ca4	48		pha		            PHA
.1a1ca5	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1ca8	5b		tcd		            TCD
.1a1ca9	68		pla		            PLA
.1a1caa	28		plp		            PLP
.1a1cab	c2 30		rep #$30	            REP #$30
.1a1cad	92 33		sta ($0833)	                STA (RETURNSP)
.1a1caf	c6 33		dec $0833	                DEC RETURNSP
.1a1cb1	c6 33		dec $0833	                DEC RETURNSP
.1a1cb3	2b		pld		                PLD
.1a1cb4	28		plp		                PLP
.1a1cb5	60		rts		            RTS
.1a1cb6					PHRETURNB
.1a1cb6	08		php		                PHP
.1a1cb7	c2 30		rep #$30	            REP #$30
.1a1cb9	29 ff 00	and #$00ff	                AND #$00FF
.1a1cbc	20 9f 1c	jsr $1a1c9f	            JSR PHRETURN
.1a1cbf	28		plp		                PLP
.1a1cc0	60		rts		            RTS
.1a1cc1					PLRETURN
.1a1cc1	08		php		                PHP
.1a1cc2	0b		phd		                PHD
.1a1cc3	08		php		            PHP
.1a1cc4	c2 20		rep #$20	            REP #$20
.1a1cc6	48		pha		            PHA
.1a1cc7	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1cca	5b		tcd		            TCD
.1a1ccb	68		pla		            PLA
.1a1ccc	28		plp		            PLP
.1a1ccd	c2 30		rep #$30	            REP #$30
.1a1ccf	e6 33		inc $0833	                INC RETURNSP
.1a1cd1	e6 33		inc $0833	                INC RETURNSP
.1a1cd3	b2 33		lda ($0833)	                LDA (RETURNSP)
.1a1cd5	2b		pld		                PLD
.1a1cd6	28		plp		                PLP
.1a1cd7	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\interpreter.s

=$80					ST_RUNNING = $80            ; The interpreter is running a full program
=$00					ST_INTERACT = $00           ; The interpreter is in interactive mode
>08d2					STATE       .byte ?         ; The state of the interpreter ()
>08d3					ERROR_NUM   .byte ?         ; The type of the error
>08d4					HANDLEERR   .long ?         ; Pointer to the error handler
>08d7					LINENUM     .word ?         ; The current line number
>08d9					LASTLINE    .long ?         ; Pointer to the next free space over the BASIC program
>08dc					EXECACTION  .byte ?         ; The action the exection routines should take to get their next statement
=0					LINE_LINK = 0               ; Offset to the link to the next line
=2					LINE_NUMBER = 2             ; Offset to the line number
=4					LINE_TOKENS = 4             ; Offset to the first token
=6					LINE_MINLEN = 6             ; Minimum length of a line
=0					EXEC_CONT = 0               ; Continue advancing the current line
=1					EXEC_STOP = 1               ; Stop execution of the program
=2					EXEC_GOTO = 2               ; Transfer execution to a new CURLINE that is already set
=3					EXEC_RETURN = 3             ; Transfer execution back to a line that was on the stack
.1a1cd8					SET_ERRERL
.1a1cd8	8b		phb		                PHB
.1a1cd9	0b		phd		                PHD
.1a1cda	08		php		                PHP
.1a1cdb	08		php		            PHP
.1a1cdc	c2 20		rep #$20	            REP #$20
.1a1cde	48		pha		            PHA
.1a1cdf	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1ce2	5b		tcd		            TCD
.1a1ce3	68		pla		            PLA
.1a1ce4	28		plp		            PLP
.1a1ce5	08		php		            PHP
.1a1ce6	e2 20		sep #$20	            SEP #$20
.1a1ce8	48		pha		            PHA
.1a1ce9	a9 00		lda #$00	            LDA #BASIC_BANK
.1a1ceb	48		pha		            PHA
.1a1cec	ab		plb		            PLB
.1a1ced	68		pla		            PLA
.1a1cee	28		plp		            PLP
.1a1cef	c2 20		rep #$20	            REP #$20
.1a1cf1	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.1a1cf3	a9 00 00	lda #$0000	                LDA #0
.1a1cf6	85 25		sta $0825	                STA ARGUMENT1+2
.1a1cf8	e2 20		sep #$20	            SEP #$20
.1a1cfa	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a1cfc	85 27		sta $0827	                STA ARGTYPE1
.1a1cfe	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.1a1d00	a9 1a		lda #$1a	                LDA #`err_name
.1a1d02	85 e9		sta $08e9	                STA TOFIND+2
.1a1d04	c2 20		rep #$20	            REP #$20
.1a1d06	a9 32 1d	lda #$1d32	                LDA #<>err_name
.1a1d09	85 e7		sta $08e7	                STA TOFIND
.1a1d0b	20 2f 51	jsr $1a512f	            JSR VAR_SET
.1a1d0e	c2 20		rep #$20	            REP #$20
.1a1d10	a5 d7		lda $08d7	                LDA LINENUM
.1a1d12	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.1a1d14	a5 d9		lda $08d9	                LDA LINENUM+2
.1a1d16	85 25		sta $0825	                STA ARGUMENT1+2
.1a1d18	e2 20		sep #$20	            SEP #$20
.1a1d1a	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a1d1c	85 27		sta $0827	                STA ARGTYPE1
.1a1d1e	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.1a1d20	a9 1a		lda #$1a	                LDA #`erl_name
.1a1d22	85 e9		sta $08e9	                STA TOFIND+2
.1a1d24	c2 20		rep #$20	            REP #$20
.1a1d26	a9 36 1d	lda #$1d36	                LDA #<>erl_name
.1a1d29	85 e7		sta $08e7	                STA TOFIND
.1a1d2b	20 2f 51	jsr $1a512f	            JSR VAR_SET
.1a1d2e	28		plp		                PLP
.1a1d2f	2b		pld		                PLD
.1a1d30	ab		plb		                PLB
.1a1d31	60		rts		            RTS
>1a1d32	45 52 52 00			err_name        .null "ERR"
>1a1d36	45 52 4c 00			erl_name        .null "ERL"
.1a1d3a					ON_ERROR
.1a1d3a	e2 20		sep #$20	            SEP #$20
.1a1d3c	c2 10		rep #$10	            REP #$10
.1a1d3e	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a1d41	af d3 08 00	lda $0008d3	            LDA @lERROR_NUM         ; Calculate index to the error message pointer
.1a1d45	0a		asl a		            ASL A
.1a1d46	c2 20		rep #$20	            REP #$20
.1a1d48	29 ff 00	and #$00ff	            AND #$00FF
.1a1d4b	a8		tay		            TAY
.1a1d4c	08		php		            PHP
.1a1d4d	e2 20		sep #$20	            SEP #$20
.1a1d4f	48		pha		            PHA
.1a1d50	a9 1a		lda #$1a	            LDA #`ERRORMSG
.1a1d52	48		pha		            PHA
.1a1d53	ab		plb		            PLB
.1a1d54	68		pla		            PLA
.1a1d55	28		plp		            PLP
.1a1d56	be 8c 1d	ldx $1a1d8c,y	            LDX ERRORMSG,Y
.1a1d59	20 4f 03	jsr $1a034f	            JSR PRINTS
.1a1d5c	c2 20		rep #$20	            REP #$20
.1a1d5e	a5 d7		lda $08d7	            LDA LINENUM
.1a1d60	f0 27		beq $1a1d89	            BEQ skip_at
.1a1d62	a2 bc 1d	ldx #$1dbc	            LDX #<>MSG_AT           ; If so... print " AT "
.1a1d65	20 4f 03	jsr $1a034f	            JSR PRINTS
.1a1d68	08		php		            PHP
.1a1d69	e2 20		sep #$20	            SEP #$20
.1a1d6b	48		pha		            PHA
.1a1d6c	a9 00		lda #$00	            LDA #BASIC_BANK
.1a1d6e	48		pha		            PHA
.1a1d6f	ab		plb		            PLB
.1a1d70	68		pla		            PLA
.1a1d71	28		plp		            PLP
.1a1d72	c2 20		rep #$20	            REP #$20
.1a1d74	af d7 08 00	lda $0008d7	            LDA @lLINENUM           ; ... and then the line number
.1a1d78	8f 23 08 00	sta $000823	            STA @lARGUMENT1
.1a1d7c	a9 00 00	lda #$0000	            LDA #0
.1a1d7f	8f 25 08 00	sta $000825	            STA @lARGUMENT1+2
.1a1d83	20 46 44	jsr $1a4446	            JSR PR_INTEGER
.1a1d86	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a1d89					skip_at
.1a1d89	4c 37 26	jmp $1a2637	            JMP INTERACT
>1a1d8c	c0 1d				ERRORMSG    .word <>MSG_OK
>1a1d8e	c3 1d				            .word <>MSG_BREAK
>1a1d90	c9 1d				            .word <>MSG_SYNTAX
>1a1d92	d6 1d				            .word <>MSG_MEMORY
>1a1d94	e4 1d				            .word <>MSG_TYPE
>1a1d96	f2 1d				            .word <>MSG_NOTFND
>1a1d98	05 1e				            .word <>MSG_NOLINE
>1a1d9a	1b 1e				            .word <>MSG_UNDFLOW
>1a1d9c	2b 1e				            .word <>MSG_OVRFLOW
>1a1d9e	3a 1e				            .word <>MSG_RANGE
>1a1da0	47 1e				            .word <>MSG_ARG
>1a1da2	58 1e				            .word <>MSG_NOFILE
>1a1da4	67 1e				            .word <>MSG_NAN
>1a1da6	74 1e				            .word <>MSG_OVERFLOW
>1a1da8	82 1e				            .word <>MSG_UNDERFLOW
>1a1daa	91 1e				            .word <>MSG_DIV0
>1a1dac	a2 1e				            .word <>MSG_DIRECTORY
>1a1dae	bb 1e				            .word <>MSG_LOAD
>1a1db0	cf 1e				            .word <>MSG_SAVE
>1a1db2	e3 1e				            .word <>MSG_DELETE
>1a1db4	f9 1e				            .word <>MSG_FILENOTFND
>1a1db6	0d 1f				            .word <>MSG_DIRNOTWRITE
>1a1db8	28 1f				            .word <>MSG_NOTCOPIED
>1a1dba	40 1f				            .word <>MSG_DOMAIN
>1a1dbc	20 61 74 00			MSG_AT          .null " at"
>1a1dc0	4f 4b 00			MSG_OK          .null "OK"
>1a1dc3	42 72 65 61 6b 00		MSG_BREAK       .null "Break"
>1a1dc9	53 79 6e 74 61 78 20 65		MSG_SYNTAX      .null "Syntax error"
>1a1dd1	72 72 6f 72 00
>1a1dd6	4f 75 74 20 6f 66 20 6d		MSG_MEMORY      .null "Out of memory"
>1a1dde	65 6d 6f 72 79 00
>1a1de4	54 79 70 65 20 6d 69 73		MSG_TYPE        .null "Type mismatch"
>1a1dec	6d 61 74 63 68 00
>1a1df2	56 61 72 69 61 62 6c 65		MSG_NOTFND      .null "Variable not found"
>1a1dfa	20 6e 6f 74 20 66 6f 75 6e 64 00
>1a1e05	4c 69 6e 65 20 6e 75 6d		MSG_NOLINE      .null "Line number not found"
>1a1e0d	62 65 72 20 6e 6f 74 20 66 6f 75 6e 64 00
>1a1e1b	53 74 61 63 6b 20 75 6e		MSG_UNDFLOW     .null "Stack underflow"
>1a1e23	64 65 72 66 6c 6f 77 00
>1a1e2b	53 74 61 63 6b 20 6f 76		MSG_OVRFLOW     .null "Stack overflow"
>1a1e33	65 72 66 6c 6f 77 00
>1a1e3a	4f 75 74 20 6f 66 20 72		MSG_RANGE       .null "Out of range"
>1a1e42	61 6e 67 65 00
>1a1e47	49 6c 6c 65 67 61 6c 20		MSG_ARG         .null "Illegal argument"
>1a1e4f	61 72 67 75 6d 65 6e 74 00
>1a1e58	46 69 6c 65 20 6e 6f 74		MSG_NOFILE      .null "File not found"
>1a1e60	20 66 6f 75 6e 64 00
>1a1e67	4e 6f 74 20 61 20 6e 75		MSG_NAN         .null "Not a number"
>1a1e6f	6d 62 65 72 00
>1a1e74	4d 61 74 68 20 6f 76 65		MSG_OVERFLOW    .null "Math overflow"
>1a1e7c	72 66 6c 6f 77 00
>1a1e82	4d 61 74 68 20 75 6e 64		MSG_UNDERFLOW   .null "Math underflow"
>1a1e8a	65 72 66 6c 6f 77 00
>1a1e91	44 69 76 69 73 69 6f 6e		MSG_DIV0        .null "Division by zero"
>1a1e99	20 62 79 20 7a 65 72 6f 00
>1a1ea2	55 6e 61 62 6c 65 20 74		MSG_DIRECTORY   .null "Unable to read directory"
>1a1eaa	6f 20 72 65 61 64 20 64 69 72 65 63 74 6f 72 79
>1a1eba	00
>1a1ebb	55 6e 61 62 6c 65 20 74		MSG_LOAD        .null "Unable to load file"
>1a1ec3	6f 20 6c 6f 61 64 20 66 69 6c 65 00
>1a1ecf	55 6e 61 62 6c 65 20 74		MSG_SAVE        .null "Unable to save file"
>1a1ed7	6f 20 73 61 76 65 20 66 69 6c 65 00
>1a1ee3	55 6e 61 62 6c 65 20 74		MSG_DELETE      .null "Unable to delete file"
>1a1eeb	6f 20 64 65 6c 65 74 65 20 66 69 6c 65 00
>1a1ef9	43 6f 75 6c 64 20 6e 6f		MSG_FILENOTFND  .null "Could not find file"
>1a1f01	74 20 66 69 6e 64 20 66 69 6c 65 00
>1a1f0d	43 6f 75 6c 64 20 6e 6f		MSG_DIRNOTWRITE .null "Could not update directory"
>1a1f15	74 20 75 70 64 61 74 65 20 64 69 72 65 63 74 6f
>1a1f25	72 79 00
>1a1f28	43 6f 75 6c 64 20 6e 6f		MSG_NOTCOPIED   .null "Could not copy the file"
>1a1f30	74 20 63 6f 70 79 20 74 68 65 20 66 69 6c 65 00
>1a1f40	41 72 67 75 6d 65 6e 74		MSG_DOMAIN      .null "Argument outside domain"
>1a1f48	20 6f 75 74 73 69 64 65 20 64 6f 6d 61 69 6e 00
.1a1f58					SETINTERACT
.1a1f58	08		php		            PHP
.1a1f59	0b		phd		            PHD
.1a1f5a	08		php		            PHP
.1a1f5b	c2 20		rep #$20	            REP #$20
.1a1f5d	48		pha		            PHA
.1a1f5e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1f61	5b		tcd		            TCD
.1a1f62	68		pla		            PLA
.1a1f63	28		plp		            PLP
.1a1f64	e2 20		sep #$20	            SEP #$20
.1a1f66	a9 00		lda #$00	            LDA #ST_INTERACT
.1a1f68	85 d2		sta $08d2	            STA STATE
.1a1f6a	2b		pld		            PLD
.1a1f6b	28		plp		            PLP
.1a1f6c	60		rts		            RTS
.1a1f6d					CLRINTERP
.1a1f6d	0b		phd		            PHD
.1a1f6e	08		php		            PHP
.1a1f6f	08		php		            PHP
.1a1f70	c2 20		rep #$20	            REP #$20
.1a1f72	48		pha		            PHA
.1a1f73	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1f76	5b		tcd		            TCD
.1a1f77	68		pla		            PLA
.1a1f78	28		plp		            PLP
.1a1f79	08		php		            PHP
.1a1f7a	c2 20		rep #$20	            REP #$20
.1a1f7c	a9 3a 1d	lda #$1d3a	            LDA #<>ON_ERROR
.1a1f7f	8f d4 08 00	sta $0008d4	            STA @lHANDLEERR
.1a1f83	e2 20		sep #$20	            SEP #$20
.1a1f85	a9 1a		lda #$1a	            LDA #`ON_ERROR
.1a1f87	8f d6 08 00	sta $0008d6	            STA @lHANDLEERR+2
.1a1f8b	28		plp		            PLP
.1a1f8c	20 eb 42	jsr $1a42eb	            JSR S_CLR
.1a1f8f	20 2c 3e	jsr $1a3e2c	            JSR S_RESTORE
.1a1f92	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the depth of the GOSUB stack
.1a1f94	28		plp		            PLP
.1a1f95	2b		pld		            PLD
.1a1f96	60		rts		            RTS
.1a1f97					INCBIP
.1a1f97	08		php		            PHP
.1a1f98	0b		phd		            PHD
.1a1f99	08		php		            PHP
.1a1f9a	c2 20		rep #$20	            REP #$20
.1a1f9c	48		pha		            PHA
.1a1f9d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1fa0	5b		tcd		            TCD
.1a1fa1	68		pla		            PLA
.1a1fa2	28		plp		            PLP
.1a1fa3	c2 20		rep #$20	            REP #$20
.1a1fa5	18		clc		            CLC
.1a1fa6	a5 00		lda $0800	            LDA BIP
.1a1fa8	69 01 00	adc #$0001	            ADC #1
.1a1fab	85 00		sta $0800	            STA BIP
.1a1fad	e2 20		sep #$20	            SEP #$20
.1a1faf	a5 02		lda $0802	            LDA BIP+2
.1a1fb1	69 00		adc #$00	            ADC #0
.1a1fb3	85 02		sta $0802	            STA BIP+2
.1a1fb5	2b		pld		            PLD
.1a1fb6	28		plp		            PLP
.1a1fb7	60		rts		            RTS
.1a1fb8					SKIPWS
.1a1fb8	08		php		            PHP
.1a1fb9	0b		phd		            PHD
.1a1fba	08		php		            PHP
.1a1fbb	c2 20		rep #$20	            REP #$20
.1a1fbd	48		pha		            PHA
.1a1fbe	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1fc1	5b		tcd		            TCD
.1a1fc2	68		pla		            PLA
.1a1fc3	28		plp		            PLP
.1a1fc4	e2 20		sep #$20	            SEP #$20
.1a1fc6	a7 00		lda [$0800]	loop        LDA [BIP]
.1a1fc8	f0 0f		beq $1a1fd9	            BEQ done            ; If character is 0, we've reached the end of the line
.1a1fca	c9 20		cmp #$20	            CMP #CHAR_SP        ; Skip if it's a space
.1a1fcc	f0 06		beq $1a1fd4	            BEQ skip_char
.1a1fce	c9 09		cmp #$09	            CMP #CHAR_TAB       ; Skip if it's a TAB
.1a1fd0	f0 02		beq $1a1fd4	            BEQ skip_char
.1a1fd2	80 05		bra $1a1fd9	            BRA done            ; Otherwise, we're done and BIP points to a non-whitespace
.1a1fd4					skip_char
.1a1fd4	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a1fd7	80 ed		bra $1a1fc6	            BRA loop
.1a1fd9	2b		pld		done        PLD
.1a1fda	28		plp		            PLP
.1a1fdb	60		rts		            RTS
.1a1fdc					SKIPSTMT
.1a1fdc	08		php		            PHP
.1a1fdd	e2 20		sep #$20	            SEP #$20
.1a1fdf	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the current character
.1a1fe1	f0 09		beq $1a1fec	            BEQ done            ; Is it EOL? Yes, we're done
.1a1fe3	c9 3a		cmp #$3a	            CMP #':'            ; Is it a colon?
.1a1fe5	f0 05		beq $1a1fec	            BEQ done            ; Yes, we're done
.1a1fe7	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a1fea	80 f3		bra $1a1fdf	            BRA loop            ; and check it...
.1a1fec	28		plp		done        PLP
.1a1fed	60		rts		            RTS
.1a1fee					SKIPTOTOK
.1a1fee	08		php		            PHP
.1a1fef	e2 20		sep #$20	            SEP #$20
.1a1ff1	64 36		stz $0836	            STZ NESTING
.1a1ff3	a7 00		lda [$0800]	loop        LDA [BIP]           ; Get the character
.1a1ff5	f0 19		beq $1a2010	            BEQ end_of_line     ; EOL? Yes: move to the next line
.1a1ff7	c5 37		cmp $0837	            CMP TARGETTOK       ; Is it the one we want?
.1a1ff9	f0 2c		beq $1a2027	            BEQ check_depth     ; Yes: check the depth
.1a1ffb	c9 9b		cmp #$9b	            CMP #TOK_FOR        ; Is it a FOR?
.1a1ffd	f0 1e		beq $1a201d	            BEQ inc_nesting     ; Yes: increment NESTING
.1a1fff	c9 9f		cmp #$9f	            CMP #TOK_DO         ; Is it a DO?
.1a2001	f0 1a		beq $1a201d	            BEQ inc_nesting     ; Yes: increment NESTING
.1a2003	c9 9e		cmp #$9e	            CMP #TOK_NEXT       ; Is it a NEXT?
.1a2005	f0 1a		beq $1a2021	            BEQ dec_nesting     ; Yes: decrement NESTING
.1a2007	c9 a0		cmp #$a0	            CMP #TOK_LOOP       ; Is it a LOOP?
.1a2009	f0 16		beq $1a2021	            BEQ dec_nesting     ; Yes: decrement NESTING
.1a200b					incloop
.1a200b	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a200e	80 e3		bra $1a1ff3	            BRA loop            ; and keep scanning
.1a2010					end_of_line
.1a2010	20 74 20	jsr $1a2074	            JSR NEXTLINE
.1a2013	c2 20		rep #$20	            REP #$20
.1a2015	a5 d7		lda $08d7	            LDA LINENUM         ; Check the line number
.1a2017	f0 1d		beq $1a2036	            BEQ syntax_err1     ; If it's zero, we reached the end of the program
.1a2019	e2 20		sep #$20	            SEP #$20
.1a201b	80 d6		bra $1a1ff3	            BRA loop            ; And keep scanning
.1a201d					inc_nesting
.1a201d	e6 36		inc $0836	            INC NESTING         ; Track that we have entered a lexical scope for a FOR/DO
.1a201f	80 ea		bra $1a200b	            BRA incloop
.1a2021					dec_nesting
.1a2021	c6 36		dec $0836	            DEC NESTING         ; Track that we have left a lexical scope for a FOR/DO
.1a2023	30 30		bmi $1a2055	            BMI syntax_err2     ; If the depth goes <0, throw a syntax error
.1a2025	80 e4		bra $1a200b	            BRA incloop
.1a2027					check_depth
.1a2027	a5 35		lda $0835	            LDA SKIPNEST        ; Check to see if nesting matters
.1a2029	30 06		bmi $1a2031	            BMI found           ; No: just return that we found the token
.1a202b	a5 36		lda $0836	            LDA NESTING         ; Get the nesting depth
.1a202d	f0 02		beq $1a2031	            BEQ found           ; If it's zero, we found our token
.1a202f	80 da		bra $1a200b	            BRA incloop         ; Otherwise: it's a token for an enclosed FOR/DO, keep scanning
.1a2031					found
.1a2031	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a2034	28		plp		            PLP
.1a2035	60		rts		            RTS
.1a2036					syntax_err1
.1a2036	08		php		            PHP
.1a2037	c2 20		rep #$20	            REP #$20
.1a2039	48		pha		            PHA
.1a203a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a203d	5b		tcd		            TCD
.1a203e	68		pla		            PLA
.1a203f	28		plp		            PLP
.1a2040	e2 20		sep #$20	            SEP #$20
.1a2042	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a2044	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2048	c2 20		rep #$20	            REP #$20
.1a204a	29 ff 00	and #$00ff	            AND #$00FF
.1a204d	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a2050	e2 20		sep #$20	            SEP #$20
.1a2052	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2055					syntax_err2
.1a2055	08		php		            PHP
.1a2056	c2 20		rep #$20	            REP #$20
.1a2058	48		pha		            PHA
.1a2059	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a205c	5b		tcd		            TCD
.1a205d	68		pla		            PLA
.1a205e	28		plp		            PLP
.1a205f	e2 20		sep #$20	            SEP #$20
.1a2061	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a2063	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2067	c2 20		rep #$20	            REP #$20
.1a2069	29 ff 00	and #$00ff	            AND #$00FF
.1a206c	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a206f	e2 20		sep #$20	            SEP #$20
.1a2071	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2074					NEXTLINE
.1a2074	08		php		            PHP
.1a2075	c2 30		rep #$30	            REP #$30
.1a2077	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a207a	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the offset to the next line
.1a207c	85 0c		sta $080c	            STA SCRATCH
.1a207e	18		clc		            CLC                 ; Compute the new CURLINE
.1a207f	a5 1a		lda $081a	            LDA CURLINE         ; CURLINE := [CURLINE].LINE_LINK
.1a2081	65 0c		adc $080c	            ADC SCRATCH
.1a2083	85 1a		sta $081a	            STA CURLINE
.1a2085	a5 1c		lda $081c	            LDA CURLINE+2
.1a2087	69 00 00	adc #$0000	            ADC #0
.1a208a	85 1c		sta $081c	            STA CURLINE+2
.1a208c	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the LINENUM to the new current line's number
.1a208f	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; LINENUM := [CURLINE].LINE_NUMBER
.1a2091	85 d7		sta $08d7	            STA LINENUM
.1a2093	18		clc		            CLC                 ; Point BIP to the first character of the line
.1a2094	a5 1a		lda $081a	            LDA CURLINE         ; BIP := CURLINE + LINE_TOKENS
.1a2096	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a2099	85 00		sta $0800	            STA BIP
.1a209b	a5 1c		lda $081c	            LDA CURLINE+2
.1a209d	69 00 00	adc #$0000	            ADC #0
.1a20a0	85 02		sta $0802	            STA BIP+2
.1a20a2	28		plp		            PLP
.1a20a3	60		rts		            RTS
.1a20a4					EXPECT_TOK
.1a20a4	08		php		            PHP
.1a20a5	e2 20		sep #$20	            SEP #$20
.1a20a7	48		pha		            PHA
.1a20a8	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a20ab	68		pla		            PLA
.1a20ac	e2 20		sep #$20	            SEP #$20
.1a20ae	c7 00		cmp [$0800]	            CMP [BIP]           ; Check the character at BIP
.1a20b0	d0 08		bne $1a20ba	            BNE syntax_err      ; Throw a syntax error
.1a20b2	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a20b5	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a20b8	28		plp		            PLP
.1a20b9	60		rts		            RTS
.1a20ba					syntax_err
.1a20ba	08		php		            PHP
.1a20bb	c2 20		rep #$20	            REP #$20
.1a20bd	48		pha		            PHA
.1a20be	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a20c1	5b		tcd		            TCD
.1a20c2	68		pla		            PLA
.1a20c3	28		plp		            PLP
.1a20c4	e2 20		sep #$20	            SEP #$20
.1a20c6	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a20c8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a20cc	c2 20		rep #$20	            REP #$20
.1a20ce	29 ff 00	and #$00ff	            AND #$00FF
.1a20d1	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a20d4	e2 20		sep #$20	            SEP #$20
.1a20d6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a20d9					OPT_TOK
.1a20d9	08		php		            PHP
.1a20da	e2 20		sep #$20	            SEP #$20
.1a20dc	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a20df	e2 20		sep #$20	            SEP #$20
.1a20e1	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the character at BIP
.1a20e3	f0 10		beq $1a20f5	            BEQ ret_false       ; If end-of-line, return false
.1a20e5	c9 3a		cmp #$3a	            CMP #':'
.1a20e7	f0 0c		beq $1a20f5	            BEQ ret_false       ; If colon, return false
.1a20e9	c5 37		cmp $0837	            CMP TARGETTOK
.1a20eb	f0 05		beq $1a20f2	            BEQ ret_true        ; If matches, return true
.1a20ed	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a20f0	80 ef		bra $1a20e1	            BRA loop
.1a20f2	28		plp		ret_true    PLP
.1a20f3	38		sec		            SEC
.1a20f4	60		rts		            RTS
.1a20f5	28		plp		ret_false   PLP
.1a20f6	18		clc		            CLC
.1a20f7	60		rts		            RTS
.1a20f8					PEEK_TOK
.1a20f8	5a		phy		            PHY
.1a20f9	08		php		            PHP
.1a20fa	e2 20		sep #$20	            SEP #$20
.1a20fc	a0 00 00	ldy #$0000	            LDY #0
.1a20ff	b7 00		lda [$0800],y	loop        LDA [BIP],Y
.1a2101	f0 0d		beq $1a2110	            BEQ done
.1a2103	c9 3a		cmp #$3a	            CMP #':'
.1a2105	f0 07		beq $1a210e	            BEQ ret_null
.1a2107	c9 20		cmp #$20	            CMP #CHAR_SP
.1a2109	d0 05		bne $1a2110	            BNE done
.1a210b	c8		iny		            INY
.1a210c	80 f1		bra $1a20ff	            BRA loop
.1a210e	a9 00		lda #$00	ret_null    LDA #0
.1a2110	28		plp		done        PLP
.1a2111	7a		ply		            PLY
.1a2112	60		rts		            RTS
.1a2113					EXECSTMT
.1a2113	08		php		            PHP
.1a2114	0b		phd		            PHD
.1a2115	8b		phb		            PHB
.1a2116	08		php		            PHP
.1a2117	c2 20		rep #$20	            REP #$20
.1a2119	48		pha		            PHA
.1a211a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a211d	5b		tcd		            TCD
.1a211e	68		pla		            PLA
.1a211f	28		plp		            PLP
.1a2120	20 48 18	jsr $1a1848	            JSR INITEVALSP
.1a2123	e2 20		sep #$20	            SEP #$20
.1a2125	a9 00		lda #$00	            LDA #EXEC_CONT      ; This will tell EXECLINE and EXECPROG to procede in a
.1a2127	85 dc		sta $08dc	            STA EXECACTION      ; linear fashion through the program
.1a2129	ad 8a 0f	lda $0f8a	check_break LDA KEYFLAG         ; Check the keyboard flags
.1a212c	30 4b		bmi $1a2179	            BMI throw_break     ; If MSB: user pressed an interrupt key, stop the program
.1a212e	a7 00		lda [$0800]	            LDA [BIP]           ; If we happen to have a colon, just skip over it.
.1a2130	c9 3a		cmp #$3a	            CMP #':'            ; This can happen with FOR/NEXT
.1a2132	d0 03		bne $1a2137	            BNE eat_ws
.1a2134	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a2137					eat_ws
.1a2137	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a213a	a7 00		lda [$0800]	            LDA [BIP]
.1a213c	d0 03		bne $1a2141	            BNE else
.1a213e	4c c3 21	jmp $1a21c3	            JMP done            ; If the current byte is 0, we're at the end of the line, just return
.1a2141					else
.1a2141	20 cd 03	jsr $1a03cd	            JSR ISALPHA
.1a2144	b0 52		bcs $1a2198	            BCS is_variable     ; Yes: we may have a LET statement
.1a2146	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it's any other non-token
.1a2148	10 10		bpl $1a215a	            BPL error           ; Yes: it's a syntax error
.1a214a	20 95 0b	jsr $1a0b95	            JSR TOKTYPE
.1a214d	85 0c		sta $080c	            STA SCRATCH         ; Save the type for later
.1a214f	c9 20		cmp #$20	            CMP #TOK_TY_STMNT   ; Is it a statement?
.1a2151	d0 03		bne $1a2156	            BNE else2
.1a2153	4c b1 21	jmp $1a21b1	            JMP ok_to_exec      ; Yes: it's ok to try to execute it
.1a2156	a5 d2		lda $08d2	else2       LDA STATE           ; Check to see if we're in interactive mode
.1a2158	f0 51		beq $1a21ab	            BEQ is_interact
.1a215a					error
.1a215a	08		php		            PHP
.1a215b	c2 20		rep #$20	            REP #$20
.1a215d	48		pha		            PHA
.1a215e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2161	5b		tcd		            TCD
.1a2162	68		pla		            PLA
.1a2163	28		plp		            PLP
.1a2164	e2 20		sep #$20	            SEP #$20
.1a2166	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a2168	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a216c	c2 20		rep #$20	            REP #$20
.1a216e	29 ff 00	and #$00ff	            AND #$00FF
.1a2171	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a2174	e2 20		sep #$20	            SEP #$20
.1a2176	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2179					throw_break
.1a2179	08		php		            PHP
.1a217a	c2 20		rep #$20	            REP #$20
.1a217c	48		pha		            PHA
.1a217d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2180	5b		tcd		            TCD
.1a2181	68		pla		            PLA
.1a2182	28		plp		            PLP
.1a2183	e2 20		sep #$20	            SEP #$20
.1a2185	a9 01		lda #$01	            LDA #ERR_BREAK
.1a2187	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a218b	c2 20		rep #$20	            REP #$20
.1a218d	29 ff 00	and #$00ff	            AND #$00FF
.1a2190	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a2193	e2 20		sep #$20	            SEP #$20
.1a2195	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2198					is_variable
.1a2198	20 f5 42	jsr $1a42f5	            JSR S_LET
.1a219b	4c c3 21	jmp $1a21c3	            JMP done
.1a219e					STSTUB
.1a219e	08		php		            PHP
.1a219f	e2 20		sep #$20	            SEP #$20
.1a21a1	48		pha		            PHA
.1a21a2	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a21a4	48		pha		            PHA
.1a21a5	ab		plb		            PLB
.1a21a6	68		pla		            PLA
.1a21a7	28		plp		            PLP
.1a21a8	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.1a21ab	a5 0c		lda $080c	is_interact LDA SCRATCH         ; Get the token type
.1a21ad	c9 10		cmp #$10	            CMP #TOK_TY_CMD     ; Is it a command?
.1a21af	d0 a9		bne $1a215a	            BNE error           ; If not, it's an error
.1a21b1					ok_to_exec
.1a21b1	a7 00		lda [$0800]	            LDA [BIP]           ; Get the original token again
.1a21b3	20 72 0b	jsr $1a0b72	            JSR TOKEVAL
.1a21b6	c2 20		rep #$20	            REP #$20
.1a21b8	85 2f		sta $082f	            STA JMP16PTR        ; Store it in the jump pointer
.1a21ba	20 48 18	jsr $1a1848	            JSR INITEVALSP
.1a21bd	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a21c0	20 9e 21	jsr $1a219e	            JSR STSTUB
.1a21c3	ab		plb		done        PLB
.1a21c4	2b		pld		            PLD
.1a21c5	28		plp		            PLP
.1a21c6	60		rts		            RTS
.1a21c7					EXECCMD
.1a21c7	08		php		            PHP
.1a21c8	58		cli		            CLI
.1a21c9	20 58 1f	jsr $1a1f58	            JSR SETINTERACT
.1a21cc	20 7d 1c	jsr $1a1c7d	            JSR INITRETURN
.1a21cf	e2 20		sep #$20	            SEP #$20
.1a21d1	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.1a21d4	c2 20		rep #$20	            REP #$20
.1a21d6	a5 1a		lda $081a	            LDA CURLINE         ; Set the BASIC Instruction Pointer to the first byte of the line
.1a21d8	85 00		sta $0800	            STA BIP
.1a21da	a5 1c		lda $081c	            LDA CURLINE+2
.1a21dc	85 02		sta $0802	            STA BIP+2
.1a21de	4c 08 22	jmp $1a2208	            JMP exec_loop
.1a21e1	08		php		EXECLINE    PHP
.1a21e2	c2 20		rep #$20	            REP #$20
.1a21e4	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER            ; Set the current line number
.1a21e7	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.1a21e9	85 d7		sta $08d7	            STA LINENUM
.1a21eb	20 de 13	jsr $1a13de	            JSR CLRTMPSTR
.1a21ee	e2 20		sep #$20	            SEP #$20
.1a21f0	a5 dc		lda $08dc	            LDA EXECACTION              ; If the last EXEC action was RETURN
.1a21f2	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; BIP has already been set, so...
.1a21f4	f0 12		beq $1a2208	            BEQ exec_loop               ; Skip over setting the BIP to the beginning of the line
.1a21f6	c2 20		rep #$20	            REP #$20
.1a21f8	18		clc		            CLC                         ; Set the BASIC Instruction Pointer to the first byte of the line
.1a21f9	a5 1a		lda $081a	            LDA CURLINE
.1a21fb	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a21fe	85 00		sta $0800	            STA BIP
.1a2200	e2 20		sep #$20	            SEP #$20
.1a2202	a5 1c		lda $081c	            LDA CURLINE+2
.1a2204	69 00		adc #$00	            ADC #0
.1a2206	85 02		sta $0802	            STA BIP+2
.1a2208					exec_loop
.1a2208	c2 20		rep #$20	            REP #$20
.1a220a	20 13 21	jsr $1a2113	            JSR EXECSTMT
.1a220d	e2 20		sep #$20	            SEP #$20
.1a220f	a5 dc		lda $08dc	            LDA EXECACTION
.1a2211	c9 03		cmp #$03	            CMP #EXEC_RETURN
.1a2213	f0 f3		beq $1a2208	            BEQ exec_loop
.1a2215	c9 00		cmp #$00	            CMP #EXEC_CONT              ; If it's not EXEC_CONT, exit to the caller
.1a2217	d0 31		bne $1a224a	            BNE exec_done
.1a2219	e2 20		sep #$20	            SEP #$20
.1a221b	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a221e	a7 00		lda [$0800]	            LDA [BIP]                   ; Get the current character in the line
.1a2220	f0 28		beq $1a224a	            BEQ exec_done               ; If it's NULL, we're done
.1a2222	c9 3a		cmp #$3a	            CMP #':'                    ; If it's colon, we have more statements
.1a2224	f0 1f		beq $1a2245	            BEQ skip_loop               ; Skip over it and try to execute the next one
.1a2226	08		php		            PHP
.1a2227	c2 20		rep #$20	            REP #$20
.1a2229	48		pha		            PHA
.1a222a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a222d	5b		tcd		            TCD
.1a222e	68		pla		            PLA
.1a222f	28		plp		            PLP
.1a2230	e2 20		sep #$20	            SEP #$20
.1a2232	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a2234	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2238	c2 20		rep #$20	            REP #$20
.1a223a	29 ff 00	and #$00ff	            AND #$00FF
.1a223d	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a2240	e2 20		sep #$20	            SEP #$20
.1a2242	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2245					skip_loop
.1a2245	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a2248	80 be		bra $1a2208	            BRA exec_loop               ; And try to execute another statement
.1a224a					exec_done
.1a224a	28		plp		            PLP
.1a224b	60		rts		            RTS
.1a224c					EXECPROGRAM
.1a224c	08		php		            PHP
.1a224d	58		cli		            CLI
.1a224e	e2 20		sep #$20	            SEP #$20
.1a2250	a9 80		lda #$80	            LDA #ST_RUNNING
.1a2252	85 d2		sta $08d2	            STA STATE
.1a2254	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.1a2257	20 7d 1c	jsr $1a1c7d	            JSR INITRETURN
.1a225a	c2 30		rep #$30	            REP #$30
.1a225c	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the count of GOSUBs
.1a225e	a0 02 00	ldy #$0002	exec_loop   LDY #LINE_NUMBER
.1a2261	b7 1a		lda [$081a],y	            LDA [CURLINE],Y             ; Get the line number of the current line
.1a2263	f0 29		beq $1a228e	            BEQ done                    ; If it's 0, we are finished running code (implicit END)
.1a2265	20 e1 21	jsr $1a21e1	            JSR EXECLINE
.1a2268	e2 20		sep #$20	            SEP #$20
.1a226a	a5 dc		lda $08dc	            LDA EXECACTION              ; Check the EXECACTION from the last line
.1a226c	c9 01		cmp #$01	            CMP #EXEC_STOP              ; Stop execution of the program?
.1a226e	f0 1e		beq $1a228e	            BEQ done
.1a2270	c9 02		cmp #$02	            CMP #EXEC_GOTO              ; Transfer execution to a new CURLINE that is already set
.1a2272	f0 ea		beq $1a225e	            BEQ exec_loop
.1a2274	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; Transfer execution to the CURLINE and BIP that is already set
.1a2276	f0 e6		beq $1a225e	            BEQ exec_loop
.1a2278	c2 20		rep #$20	            REP #$20
.1a227a	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a227d	18		clc		            CLC
.1a227e	a5 1a		lda $081a	            LDA CURLINE
.1a2280	77 1a		adc [$081a],y	            ADC [CURLINE],Y
.1a2282	85 1a		sta $081a	            STA CURLINE
.1a2284	e2 20		sep #$20	            SEP #$20
.1a2286	a5 1c		lda $081c	            LDA CURLINE+2
.1a2288	69 00		adc #$00	            ADC #0
.1a228a	85 1c		sta $081c	            STA CURLINE+2
.1a228c	80 d0		bra $1a225e	            BRA exec_loop               ; And try to execute that line
.1a228e					done
.1a228e	e2 20		sep #$20	            SEP #$20
.1a2290	a9 00		lda #$00	            LDA #ST_INTERACT            ; Set interpreter state to RUNNING
.1a2292	85 d2		sta $08d2	            STA STATE
.1a2294	28		plp		            PLP
.1a2295	60		rts		            RTS
.1a2296					FINDLINE
.1a2296	08		php		            PHP
.1a2297	c2 30		rep #$30	            REP #$30
.1a2299	c2 20		rep #$20	            REP #$20
.1a229b	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT            ; INDEX points to the first line of the program
.1a229e	85 08		sta $0808	            STA INDEX
.1a22a0	a9 16 00	lda #$0016	            LDA #`BASIC_BOT
.1a22a3	85 0a		sta $080a	            STA INDEX+2
.1a22a5	c2 20		rep #$20	            REP #$20
.1a22a7	a0 02 00	ldy #$0002	check_nmbrs LDY #LINE_NUMBER            ; Get the number of the possible target line
.1a22aa	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a22ac	f0 31		beq $1a22df	            BEQ ret_false               ; If new line number is 0, we got to the
.1a22ae	c5 23		cmp $0823	            CMP ARGUMENT1               ; Compare it to the target line number
.1a22b0	f0 1e		beq $1a22d0	            BEQ found
.1a22b2	b0 2b		bcs $1a22df	            BGE ret_false               ; If the line number > target line number, the line is not present
.1a22b4					next_line
.1a22b4	c2 20		rep #$20	            REP #$20
.1a22b6	a0 00 00	ldy #$0000	            LDY #LINE_LINK              ; INDEX := INDEX + [INDEX].LINK
.1a22b9	18		clc		            CLC
.1a22ba	a5 08		lda $0808	            LDA INDEX
.1a22bc	77 08		adc [$0808],y	            ADC [INDEX],Y
.1a22be	85 0c		sta $080c	            STA SCRATCH
.1a22c0	e2 20		sep #$20	            SEP #$20
.1a22c2	a5 0a		lda $080a	            LDA INDEX+2
.1a22c4	69 00		adc #$00	            ADC #0
.1a22c6	85 0a		sta $080a	            STA INDEX+2
.1a22c8	c2 20		rep #$20	            REP #$20
.1a22ca	a5 0c		lda $080c	            LDA SCRATCH
.1a22cc	85 08		sta $0808	            STA INDEX
.1a22ce	80 d7		bra $1a22a7	            BRA check_nmbrs             ; And go back to check the new line INDEX is pointing to
.1a22d0					found
.1a22d0	c2 20		rep #$20	            REP #$20
.1a22d2	a5 08		lda $0808	            LDA INDEX
.1a22d4	85 1a		sta $081a	            STA CURLINE
.1a22d6	e2 20		sep #$20	            SEP #$20
.1a22d8	a5 0a		lda $080a	            LDA INDEX+2
.1a22da	85 1c		sta $081c	            STA CURLINE+2
.1a22dc	28		plp		ret_true    PLP                         ; Return true to indicate we've found the line
.1a22dd	38		sec		            SEC
.1a22de	60		rts		            RTS
.1a22df	28		plp		ret_false   PLP
.1a22e0	18		clc		            CLC
.1a22e1	60		rts		            RTS
.1a22e2					MVPROGDN
.1a22e2	08		php		            PHP
.1a22e3					mvd_loop
.1a22e3	e2 20		sep #$20	            SEP #$20
.1a22e5	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.1a22e7	87 08		sta [$0808]	            STA [INDEX]
.1a22e9	c2 20		rep #$20	            REP #$20
.1a22eb	a5 0c		lda $080c	            LDA SCRATCH
.1a22ed	c5 00		cmp $0800	            CMP BIP
.1a22ef	d0 08		bne $1a22f9	            BNE increment
.1a22f1	e2 20		sep #$20	            SEP #$20
.1a22f3	a5 0e		lda $080e	            LDA SCRATCH+2
.1a22f5	c5 02		cmp $0802	            CMP BIP+2
.1a22f7	f0 26		beq $1a231f	            BEQ done            ; Yes: return
.1a22f9					increment
.1a22f9	c2 20		rep #$20	            REP #$20
.1a22fb	18		clc		            CLC
.1a22fc	a5 0c		lda $080c	            LDA SCRATCH
.1a22fe	69 01 00	adc #$0001	            ADC #1
.1a2301	85 0c		sta $080c	            STA SCRATCH
.1a2303	e2 20		sep #$20	            SEP #$20
.1a2305	a5 0e		lda $080e	            LDA SCRATCH+2
.1a2307	69 00		adc #$00	            ADC #0
.1a2309	85 0e		sta $080e	            STA SCRATCH+2
.1a230b	c2 20		rep #$20	            REP #$20
.1a230d	18		clc		            CLC
.1a230e	a5 08		lda $0808	            LDA INDEX
.1a2310	69 01 00	adc #$0001	            ADC #1
.1a2313	85 08		sta $0808	            STA INDEX
.1a2315	e2 20		sep #$20	            SEP #$20
.1a2317	a5 0a		lda $080a	            LDA INDEX+2
.1a2319	69 00		adc #$00	            ADC #0
.1a231b	85 0a		sta $080a	            STA INDEX+2
.1a231d	80 c4		bra $1a22e3	            BRA mvd_loop        ; And try again
.1a231f	28		plp		done        PLP
.1a2320	60		rts		            RTS
.1a2321					MVPROGUP
.1a2321	08		php		            PHP
.1a2322					mvu_loop
.1a2322	e2 20		sep #$20	            SEP #$20
.1a2324	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.1a2326	87 08		sta [$0808]	            STA [INDEX]
.1a2328	c2 20		rep #$20	            REP #$20
.1a232a	a5 0c		lda $080c	            LDA SCRATCH
.1a232c	c5 00		cmp $0800	            CMP BIP
.1a232e	d0 06		bne $1a2336	            BNE decrement
.1a2330	a5 0e		lda $080e	            LDA SCRATCH+2
.1a2332	c5 02		cmp $0802	            CMP BIP+2
.1a2334	f0 26		beq $1a235c	            BEQ done            ; Yes: return
.1a2336					decrement
.1a2336	c2 20		rep #$20	            REP #$20
.1a2338	38		sec		            SEC
.1a2339	a5 0c		lda $080c	            LDA SCRATCH
.1a233b	e9 01 00	sbc #$0001	            SBC #1
.1a233e	85 0c		sta $080c	            STA SCRATCH
.1a2340	e2 20		sep #$20	            SEP #$20
.1a2342	a5 0e		lda $080e	            LDA SCRATCH+2
.1a2344	e9 00		sbc #$00	            SBC #0
.1a2346	85 0e		sta $080e	            STA SCRATCH+2
.1a2348	c2 20		rep #$20	            REP #$20
.1a234a	38		sec		            SEC
.1a234b	a5 08		lda $0808	            LDA INDEX
.1a234d	e9 01 00	sbc #$0001	            SBC #1
.1a2350	85 08		sta $0808	            STA INDEX
.1a2352	e2 20		sep #$20	            SEP #$20
.1a2354	a5 0a		lda $080a	            LDA INDEX+2
.1a2356	e9 00		sbc #$00	            SBC #0
.1a2358	85 0a		sta $080a	            STA INDEX+2
.1a235a	80 c6		bra $1a2322	            BRA mvu_loop        ; And try again
.1a235c	28		plp		done        PLP
.1a235d	60		rts		            RTS
.1a235e					DELLINE
.1a235e	08		php		            PHP
.1a235f	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; SCRATCH := INDEX + [INDEX].LINK (address of the following line)
.1a2362	c2 20		rep #$20	            REP #$20
.1a2364	18		clc		            CLC
.1a2365	a5 08		lda $0808	            LDA INDEX
.1a2367	77 08		adc [$0808],y	            ADC [INDEX],Y
.1a2369	85 0c		sta $080c	            STA SCRATCH
.1a236b	e2 20		sep #$20	            SEP #$20
.1a236d	a5 0a		lda $080a	            LDA INDEX+2
.1a236f	69 00		adc #$00	            ADC #0
.1a2371	85 0e		sta $080e	            STA SCRATCH+2
.1a2373	c2 20		rep #$20	            REP #$20
.1a2375	18		clc		            CLC
.1a2376	a5 d9		lda $08d9	            LDA LASTLINE
.1a2378	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a237b	85 00		sta $0800	            STA BIP
.1a237d	e2 20		sep #$20	            SEP #$20
.1a237f	a5 db		lda $08db	            LDA LASTLINE+2
.1a2381	69 00		adc #$00	            ADC #0
.1a2383	85 02		sta $0802	            STA BIP+2
.1a2385	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; LASTLINE := LASTLINE - [INDEX].LINK
.1a2388	c2 20		rep #$20	            REP #$20
.1a238a	38		sec		            SEC
.1a238b	a5 d9		lda $08d9	            LDA LASTLINE
.1a238d	f7 08		sbc [$0808],y	            SBC [INDEX],Y
.1a238f	85 d9		sta $08d9	            STA LASTLINE
.1a2391	e2 20		sep #$20	            SEP #$20
.1a2393	a5 db		lda $08db	            LDA LASTLINE+2
.1a2395	e9 00		sbc #$00	            SBC #0
.1a2397	85 db		sta $08db	            STA LASTLINE+2
.1a2399	20 e2 22	jsr $1a22e2	            JSR MVPROGDN
.1a239c					done
.1a239c	20 eb 42	jsr $1a42eb	            JSR S_CLR
.1a239f	28		plp		            PLP
.1a23a0	60		rts		            RTS
.1a23a1					APPLINE
.1a23a1	08		php		            PHP
.1a23a2	08		php		            PHP
.1a23a3	c2 20		rep #$20	            REP #$20
.1a23a5	48		pha		            PHA
.1a23a6	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a23a9	5b		tcd		            TCD
.1a23aa	68		pla		            PLA
.1a23ab	28		plp		            PLP
.1a23ac	c2 30		rep #$30	            REP #$30
.1a23ae	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the line number of the new line
.1a23b1	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.1a23b3	18		clc		            CLC                 ; Point INDEX to the position to store the tokens
.1a23b4	a5 d9		lda $08d9	            LDA LASTLINE
.1a23b6	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a23b9	85 08		sta $0808	            STA INDEX
.1a23bb	e2 20		sep #$20	            SEP #$20
.1a23bd	a5 db		lda $08db	            LDA LASTLINE+2
.1a23bf	69 00		adc #$00	            ADC #0
.1a23c1	85 0a		sta $080a	            STA INDEX+2
.1a23c3	e2 20		sep #$20	            SEP #$20
.1a23c5	a0 00 00	ldy #$0000	            LDY #0
.1a23c8	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Copy the tokenized line to its place in the code
.1a23ca	97 08		sta [$0808],y	            STA [INDEX],Y
.1a23cc	f0 03		beq $1a23d1	            BEQ copy_done
.1a23ce	c8		iny		            INY
.1a23cf	80 f7		bra $1a23c8	            BRA copy_loop
.1a23d1					copy_done
.1a23d1	c2 20		rep #$20	            REP #$20
.1a23d3	98		tya		            TYA
.1a23d4	18		clc		            CLC
.1a23d5	69 05 00	adc #$0005	            ADC #LINE_TOKENS+1
.1a23d8	85 0c		sta $080c	            STA SCRATCH
.1a23da	c2 20		rep #$20	            REP #$20
.1a23dc	a0 00 00	ldy #$0000	            LDY #LINE_LINK      ; Set link to the offset to the next line
.1a23df	a5 0c		lda $080c	            LDA SCRATCH
.1a23e1	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.1a23e3	c2 20		rep #$20	            REP #$20
.1a23e5	18		clc		            CLC
.1a23e6	a5 d9		lda $08d9	            LDA LASTLINE
.1a23e8	65 0c		adc $080c	            ADC SCRATCH
.1a23ea	85 0c		sta $080c	            STA SCRATCH
.1a23ec	e2 20		sep #$20	            SEP #$20
.1a23ee	a5 db		lda $08db	            LDA LASTLINE+2
.1a23f0	69 00		adc #$00	            ADC #0
.1a23f2	85 db		sta $08db	            STA LASTLINE+2
.1a23f4	c2 20		rep #$20	            REP #$20
.1a23f6	a5 0c		lda $080c	            LDA SCRATCH
.1a23f8	85 d9		sta $08d9	            STA LASTLINE
.1a23fa	c2 20		rep #$20	            REP #$20
.1a23fc	a0 00 00	ldy #$0000	            LDY #0
.1a23ff	a9 00 00	lda #$0000	            LDA #0
.1a2402	97 d9		sta [$08d9],y	blank_loop  STA [LASTLINE],Y    ; Set the "line" after the last line to nulls
.1a2404	c8		iny		            INY
.1a2405	c0 05 00	cpy #$0005	            CPY #LINE_TOKENS+1
.1a2408	d0 f8		bne $1a2402	            BNE blank_loop
.1a240a	20 eb 42	jsr $1a42eb	            JSR S_CLR
.1a240d	28		plp		            PLP
.1a240e	60		rts		            RTS
.1a240f					FINDINSPT
.1a240f	0b		phd		            PHD
.1a2410	08		php		            PHP
.1a2411	08		php		            PHP
.1a2412	c2 20		rep #$20	            REP #$20
.1a2414	48		pha		            PHA
.1a2415	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a2418	5b		tcd		            TCD
.1a2419	68		pla		            PLA
.1a241a	28		plp		            PLP
.1a241b	c2 30		rep #$30	            REP #$30
.1a241d	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.1a2420	85 08		sta $0808	            STA INDEX
.1a2422	a9 16 00	lda #$0016	            LDA #`BASIC_BOT
.1a2425	85 0a		sta $080a	            STA INDEX+2
.1a2427	a0 02 00	ldy #$0002	loop        LDY #LINE_NUMBER
.1a242a	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a242c	f0 1d		beq $1a244b	            BEQ found_end           ; Got to end without finding it
.1a242e	c5 d7		cmp $08d7	            CMP LINENUM
.1a2430	f0 25		beq $1a2457	            BEQ found_line          ; LINENUM = [INDEX].LINE_NUMBER: return we found the exact line
.1a2432	b0 1d		bcs $1a2451	            BGE found_spot          ; LINENUM > [INDEX].LINE_NUMBER: return we found spot to insert
.1a2434	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a2437	18		clc		            CLC                     ; Move INDEX to the next line
.1a2438	a5 08		lda $0808	            LDA INDEX
.1a243a	77 08		adc [$0808],y	            ADC [INDEX],Y
.1a243c	85 0c		sta $080c	            STA SCRATCH
.1a243e	a5 0a		lda $080a	            LDA INDEX+2
.1a2440	69 00 00	adc #$0000	            ADC #0
.1a2443	85 0a		sta $080a	            STA INDEX+2
.1a2445	a5 0c		lda $080c	            LDA SCRATCH
.1a2447	85 08		sta $0808	            STA INDEX
.1a2449	80 dc		bra $1a2427	            BRA loop                ; And check that line
.1a244b	a9 00 00	lda #$0000	found_end   LDA #0                  ; Return that we reached the end of the program
.1a244e	28		plp		            PLP
.1a244f	2b		pld		            PLD
.1a2450	60		rts		            RTS
.1a2451	a9 01 00	lda #$0001	found_spot  LDA #1                  ; Return that we the found the spot to insert the line
.1a2454	28		plp		            PLP                     ; But that it wasn't already there
.1a2455	2b		pld		            PLD
.1a2456	60		rts		            RTS
.1a2457	a9 02 00	lda #$0002	found_line  LDA #2                  ; Return that we found the line
.1a245a	28		plp		            PLP
.1a245b	2b		pld		            PLD
.1a245c	60		rts		            RTS
.1a245d					INSLINE
.1a245d	08		php		            PHP
.1a245e	c2 30		rep #$30	            REP #$30
.1a2460	a9 05 00	lda #$0005	            LDA #LINE_TOKENS+1  ; Set SCRATCH2 to the size of the line header with the end-of-line
.1a2463	85 10		sta $0810	            STA SCRATCH2
.1a2465	a0 00 00	ldy #$0000	            LDY #0
.1a2468					count_loop
.1a2468	e2 20		sep #$20	            SEP #$20
.1a246a	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the byte of the line
.1a246c	f0 07		beq $1a2475	            BEQ shift_prog      ; If it's end-of-line, SCRATCH2 is the length
.1a246e	c2 20		rep #$20	            REP #$20
.1a2470	e6 10		inc $0810	            INC SCRATCH2
.1a2472	c8		iny		            INY
.1a2473	80 f3		bra $1a2468	            BRA count_loop      ; Count and continue
.1a2475					shift_prog
.1a2475	c2 20		rep #$20	            REP #$20
.1a2477	a5 08		lda $0808	            LDA INDEX           ; BIP = the address of the first byte for the new line
.1a2479	85 00		sta $0800	            STA BIP
.1a247b	a5 0a		lda $080a	            LDA INDEX+2
.1a247d	85 02		sta $0802	            STA BIP+2
.1a247f	18		clc		            CLC                 ; SCRATCH = address of highest byte to copy
.1a2480	a5 d9		lda $08d9	            LDA LASTLINE
.1a2482	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a2485	85 0c		sta $080c	            STA SCRATCH
.1a2487	a5 db		lda $08db	            LDA LASTLINE+2
.1a2489	69 00 00	adc #$0000	            ADC #0
.1a248c	85 0e		sta $080e	            STA SCRATCH+2
.1a248e	18		clc		            CLC                 ; Adjust LASTLINE to its new position after the insert
.1a248f	a5 d9		lda $08d9	            LDA LASTLINE
.1a2491	65 10		adc $0810	            ADC SCRATCH2
.1a2493	85 d9		sta $08d9	            STA LASTLINE
.1a2495	a5 db		lda $08db	            LDA LASTLINE+2
.1a2497	69 00 00	adc #$0000	            ADC #0
.1a249a	85 db		sta $08db	            STA LASTLINE+2
.1a249c	18		clc		            CLC                 ; INDEX = address of the highest location to copy into
.1a249d	a5 d9		lda $08d9	            LDA LASTLINE
.1a249f	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a24a2	85 08		sta $0808	            STA INDEX
.1a24a4	a5 db		lda $08db	            LDA LASTLINE+2
.1a24a6	69 00 00	adc #$0000	            ADC #0
.1a24a9	85 0a		sta $080a	            STA INDEX+2
.1a24ab	20 21 23	jsr $1a2321	            JSR MVPROGUP
.1a24ae	c2 20		rep #$20	            REP #$20
.1a24b0	a5 10		lda $0810	            LDA SCRATCH2
.1a24b2	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a24b5	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINK_LINK = length of the new line
.1a24b7	a5 d7		lda $08d7	            LDA LINENUM
.1a24b9	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.1a24bc	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINE_NUMBER = number of the new line
.1a24be	18		clc		            CLC                 ; Point BIP to the first byte of the new line
.1a24bf	a5 00		lda $0800	            LDA BIP
.1a24c1	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a24c4	85 00		sta $0800	            STA BIP
.1a24c6	a5 02		lda $0802	            LDA BIP+2
.1a24c8	69 00 00	adc #$0000	            ADC #0
.1a24cb	85 02		sta $0802	            STA BIP+2
.1a24cd	a0 00 00	ldy #$0000	            LDY #0
.1a24d0	e2 20		sep #$20	            SEP #$20
.1a24d2	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Get the byte of the tokenized line
.1a24d4	97 00		sta [$0800],y	            STA [BIP],Y         ; Copy it to its correct location in the program
.1a24d6	f0 03		beq $1a24db	            BEQ done            ; If it was end-of-line byte, we're done
.1a24d8	c8		iny		            INY
.1a24d9	80 f7		bra $1a24d2	            BRA copy_loop       ; Otherwise, continue with the next
.1a24db					done
.1a24db	20 eb 42	jsr $1a42eb	            JSR S_CLR
.1a24de	28		plp		            PLP
.1a24df	60		rts		            RTS
.1a24e0					ADDLINE
.1a24e0	08		php		            PHP
.1a24e1	c2 30		rep #$30	            REP #$30
.1a24e3	85 d7		sta $08d7	            STA LINENUM
.1a24e5	20 0f 24	jsr $1a240f	            JSR FINDINSPT
.1a24e8	c9 00 00	cmp #$0000	            CMP #0
.1a24eb	f0 2c		beq $1a2519	            BEQ do_append       ; End-of-program found, add the line to the end
.1a24ed	c9 01 00	cmp #$0001	            CMP #1
.1a24f0	f0 22		beq $1a2514	            BEQ do_insert       ; Spot was found: insertion required
.1a24f2	c2 20		rep #$20	            REP #$20
.1a24f4	a5 08		lda $0808	            LDA INDEX
.1a24f6	48		pha		            PHA
.1a24f7	a5 0a		lda $080a	            LDA INDEX+2
.1a24f9	48		pha		            PHA
.1a24fa	20 5e 23	jsr $1a235e	            JSR DELLINE
.1a24fd	68		pla		            PLA
.1a24fe	85 0a		sta $080a	            STA INDEX+2
.1a2500	68		pla		            PLA
.1a2501	85 08		sta $0808	            STA INDEX
.1a2503	a5 1a		lda $081a	            LDA CURLINE         ; Check to see if there is any non-whitespace on the line
.1a2505	85 00		sta $0800	            STA BIP
.1a2507	a5 1c		lda $081c	            LDA CURLINE+2
.1a2509	85 02		sta $0802	            STA BIP+2
.1a250b	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a250e	e2 20		sep #$20	            SEP #$20
.1a2510	a7 00		lda [$0800]	            LDA [BIP]
.1a2512	f0 0a		beq $1a251e	            BEQ done            ; If not, we're done
.1a2514					do_insert
.1a2514	20 5d 24	jsr $1a245d	            JSR INSLINE
.1a2517	80 05		bra $1a251e	            BRA done
.1a2519	a5 d7		lda $08d7	do_append   LDA LINENUM
.1a251b	20 a1 23	jsr $1a23a1	            JSR APPLINE
.1a251e	28		plp		done        PLP
.1a251f	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\repl.s

="#"					CHAR_DIR = '#'
="|"					CHAR_BRUN = '|'
.1a2520					EXPANDLINE
.1a2520	0b		phd		                PHD
.1a2521	08		php		                PHP
.1a2522	08		php		            PHP
.1a2523	c2 20		rep #$20	            REP #$20
.1a2525	48		pha		            PHA
.1a2526	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a2529	5b		tcd		            TCD
.1a252a	68		pla		            PLA
.1a252b	28		plp		            PLP
.1a252c	e2 20		sep #$20	            SEP #$20
.1a252e	c2 10		rep #$10	            REP #$10
.1a2530	a2 00 00	ldx #$0000	                LDX #0
.1a2533	bd 00 4f	lda $4f00,x	count_loop      LDA INPUTBUF,X              ; Count the number of characters in the input
.1a2536	f0 03		beq $1a253b	                BEQ save_size
.1a2538	e8		inx		                INX
.1a2539	80 f8		bra $1a2533	                BRA count_loop
.1a253b	86 0c		stx $080c	save_size       STX SCRATCH                 ; Save the size in SCRATCH
.1a253d	c2 30		rep #$30	            REP #$30
.1a253f	8a		txa		                TXA
.1a2540	c9 02 00	cmp #$0002	                CMP #2                      ; Are there arguments?
.1a2543	90 12		bcc $1a2557	                BLT start_copy              ; No: just replace the whole string
.1a2545	3a		dec a		                DEC A
.1a2546	18		clc		                CLC
.1a2547	69 00 4f	adc #$4f00	                ADC #<>INPUTBUF
.1a254a	aa		tax		                TAX                         ; X <-- INPUTBUF + len(INPUTBUF) - 1
.1a254b	18		clc		                CLC                         ; Y <-- INPUTBUF + len(INPUTBUF) - 1 + len(substitution)
.1a254c	65 8f		adc $088f	                ADC MCOUNT
.1a254e	a8		tay		                TAY
.1a254f	a5 0c		lda $080c	                LDA SCRATCH
.1a2551	3a		dec a		                DEC A
.1a2552	8b		phb		                PHB
.1a2553	44 00 00	mvp #$00,#$00	                MVP #`INPUTBUF,#`INPUTBUF   ; Make room for the substitition
.1a2556	ab		plb		                PLB
.1a2557					start_copy
.1a2557	c2 20		rep #$20	            REP #$20
.1a2559	a6 55		ldx $0855	                LDX MARG1                   ; Source is data to copy
.1a255b	a0 00 4f	ldy #$4f00	                LDY #<>INPUTBUF             ; Destination is input buffer
.1a255e	a5 8f		lda $088f	                LDA MCOUNT                  ; Number of bytes to copy
.1a2560	8b		phb		                PHB
.1a2561	54 00 1a	mvn #$1a,#$00	                MVN #`EXPANDLINE,#`INPUTBUF ; Copy the data
.1a2564	ab		plb		                PLB
.1a2565	e2 20		sep #$20	            SEP #$20
.1a2567	a5 0c		lda $080c	                LDA SCRATCH                 ; Check again to see if we need quotes
.1a2569	c9 02		cmp #$02	                CMP #2
.1a256b	90 18		bcc $1a2585	                BLT done
.1a256d	a6 8f		ldx $088f	                LDX MCOUNT                  ; If so, add a quote mark here
.1a256f	a9 22		lda #$22	                LDA #CHAR_DQUOTE
.1a2571	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a2574	e8		inx		skip_to_end     INX                         ; Move to the end of the input string
.1a2575	bd 00 4f	lda $4f00,x	                LDA INPUTBUF,X
.1a2578	d0 fa		bne $1a2574	                BNE skip_to_end
.1a257a	a9 22		lda #$22	                LDA #CHAR_DQUOTE            ; Add the quote to the end of the string
.1a257c	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a257f	a9 00		lda #$00	                LDA #0                      ; And terminate with a NULL
.1a2581	e8		inx		                INX
.1a2582	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a2585	28		plp		done            PLP
.1a2586	2b		pld		                PLD
.1a2587	60		rts		            RTS
.1a2588					PREPROCESS
.1a2588	da		phx		                PHX
.1a2589	5a		phy		                PHY
.1a258a	8b		phb		                PHB
.1a258b	0b		phd		                PHD
.1a258c	08		php		                PHP
.1a258d	08		php		            PHP
.1a258e	c2 20		rep #$20	            REP #$20
.1a2590	48		pha		            PHA
.1a2591	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a2594	5b		tcd		            TCD
.1a2595	68		pla		            PLA
.1a2596	28		plp		            PLP
.1a2597	e2 20		sep #$20	            SEP #$20
.1a2599	c2 10		rep #$10	            REP #$10
.1a259b	ad 00 4f	lda $4f00	                LDA INPUTBUF            ; Check the first character
.1a259e	c9 23		cmp #$23	                CMP #CHAR_DIR           ; Is it the DIR character?
.1a25a0	f0 0a		beq $1a25ac	                BEQ expand_dir          ; Yes: expand the DIR command into place
.1a25a2	c9 7c		cmp #$7c	                CMP #CHAR_BRUN          ; Is it the BRUN character?
.1a25a4	f0 17		beq $1a25bd	                BEQ expand_brun         ; Yes: expand the BRUN command into place
.1a25a6	28		plp		done            PLP
.1a25a7	2b		pld		                PLD
.1a25a8	ab		plb		                PLB
.1a25a9	7a		ply		                PLY
.1a25aa	fa		plx		                PLX
.1a25ab	60		rts		            RTS
.1a25ac					expand_dir
.1a25ac	c2 20		rep #$20	            REP #$20
.1a25ae	a9 03 00	lda #$0003	                LDA #3                  ; Set size of substitution value
.1a25b1	85 8f		sta $088f	                STA MCOUNT
.1a25b3	a9 ce 25	lda #$25ce	                LDA #<>dir_text         ; Set pointer to substitution value
.1a25b6	85 55		sta $0855	                STA MARG1
.1a25b8	20 20 25	jsr $1a2520	            JSR EXPANDLINE
.1a25bb	80 e9		bra $1a25a6	                BRA done
.1a25bd					expand_brun
.1a25bd	c2 20		rep #$20	            REP #$20
.1a25bf	a9 04 00	lda #$0004	                LDA #4                  ; Set size of substitution value
.1a25c2	85 8f		sta $088f	                STA MCOUNT
.1a25c4	a9 d2 25	lda #$25d2	                LDA #<>brun_text        ; Set pointer to substitution value
.1a25c7	85 55		sta $0855	                STA MARG1
.1a25c9	20 20 25	jsr $1a2520	            JSR EXPANDLINE
.1a25cc	80 d8		bra $1a25a6	                BRA done
>1a25ce	44 49 52 00			dir_text        .null "DIR"             ; Expansion of the DIR character
>1a25d2	42 52 55 4e 00			brun_text       .null "BRUN"            ; Expansion of the BRUN character
.1a25d7					PRREADY
.1a25d7	8b		phb		                PHB
.1a25d8	08		php		                PHP
.1a25d9	20 1d 01	jsr $1a011d	            JSR ENSURETEXT
.1a25dc	08		php		            PHP
.1a25dd	e2 20		sep #$20	            SEP #$20
.1a25df	48		pha		            PHA
.1a25e0	a9 1a		lda #$1a	            LDA #`MPROMPT
.1a25e2	48		pha		            PHA
.1a25e3	ab		plb		            PLB
.1a25e4	68		pla		            PLA
.1a25e5	28		plp		            PLP
.1a25e6	a2 69 d2	ldx #$d269	                LDX #<>MPROMPT
.1a25e9	20 4f 03	jsr $1a034f	            JSR PRINTS
.1a25ec	28		plp		                PLP
.1a25ed	ab		plb		                PLB
.1a25ee	60		rts		            RTS
.1a25ef					IREADLINE
.1a25ef	08		php		                PHP
.1a25f0	e2 30		sep #$30	            SEP #$30
.1a25f2	a9 01		lda #$01	                LDA #1
.1a25f4	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a25f7					read_loop
.1a25f7	20 db 00	jsr $1a00db	            JSR GETKEYE
.1a25fa	f0 06		beq $1a2602	                BEQ done
.1a25fc	c9 0d		cmp #$0d	                CMP #CHAR_CR
.1a25fe	f0 02		beq $1a2602	                BEQ done
.1a2600	80 f5		bra $1a25f7	                BRA read_loop
.1a2602	28		plp		done            PLP
.1a2603	60		rts		            RTS
.1a2604					PROCESS
.1a2604	0b		phd		                PHD
.1a2605	08		php		                PHP
.1a2606	08		php		            PHP
.1a2607	c2 20		rep #$20	            REP #$20
.1a2609	48		pha		            PHA
.1a260a	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a260d	5b		tcd		            TCD
.1a260e	68		pla		            PLA
.1a260f	28		plp		            PLP
.1a2610	c2 30		rep #$30	            REP #$30
.1a2612	64 d7		stz $08d7	                STZ LINENUM
.1a2614	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF         ; Attempt to tokenize the line that was read
.1a2617	85 1a		sta $081a	                STA CURLINE
.1a2619	a9 00 00	lda #$0000	                LDA #`CURLINE
.1a261c	85 1c		sta $081c	                STA CURLINE+2
.1a261e	20 87 08	jsr $1a0887	            JSR TOKENIZE
.1a2621	c2 20		rep #$20	            REP #$20
.1a2623	a5 d7		lda $08d7	                LDA LINENUM             ; Did we get a line number?
.1a2625	d0 05		bne $1a262c	                BNE update_line         ; Yes: attempt to add it to the program
.1a2627	20 c7 21	jsr $1a21c7	            JSR EXECCMD
.1a262a	80 07		bra $1a2633	                BRA done
.1a262c					update_line
.1a262c	20 e0 24	jsr $1a24e0	            JSR ADDLINE
.1a262f	28		plp		no_prompt       PLP
.1a2630	2b		pld		                PLD
.1a2631	38		sec		                SEC
.1a2632	60		rts		            RTS
.1a2633	28		plp		done            PLP
.1a2634	2b		pld		                PLD
.1a2635	18		clc		                CLC
.1a2636	60		rts		            RTS
.1a2637					INTERACT
.1a2637	c2 30		rep #$30	            REP #$30
.1a2639	a2 ff fe	ldx #$feff	                LDX #<>STACK_END
.1a263c	9a		txs		                TXS
.1a263d					ready_loop
.1a263d	20 d7 25	jsr $1a25d7	            JSR PRREADY
.1a2640					no_ready_loop
.1a2640	20 08 00	jsr $1a0008	            JSR READLINE
.1a2643	20 0c 00	jsr $1a000c	            JSR SCRCOPYLINE
.1a2646	a9 00 00	lda #$0000	                LDA #0              ; Hide the cursor
.1a2649	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a264c	20 88 25	jsr $1a2588	            JSR PREPROCESS
.1a264f	20 04 26	jsr $1a2604	            JSR PROCESS
.1a2652	b0 ec		bcs $1a2640	                BCS no_ready_loop
.1a2654	80 e7		bra $1a263d	                BRA ready_loop
>1ad269	0d 52 45 41 44 59 0d 00		MPROMPT         .null 13,"READY",13

;******  Return to file: src\basic816.s


;******  Processing file: src\operators.s

.1a2656					OP_PLUS
.1a2656	08		php		            PHP
.1a2657	e2 20		sep #$20	            SEP #$20
.1a2659	20 8e 07	jsr $1a078e	            JSR ASS_ARGS_NUMSTR
.1a265c	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a265e	f0 2c		beq $1a268c	            BEQ is_integer
.1a2660	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2662	f0 2d		beq $1a2691	            BEQ is_float
.1a2664	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a2666	f0 1f		beq $1a2687	            BEQ is_string
.1a2668					type_error
.1a2668	08		php		            PHP
.1a2669	c2 20		rep #$20	            REP #$20
.1a266b	48		pha		            PHA
.1a266c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a266f	5b		tcd		            TCD
.1a2670	68		pla		            PLA
.1a2671	28		plp		            PLP
.1a2672	e2 20		sep #$20	            SEP #$20
.1a2674	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2676	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a267a	c2 20		rep #$20	            REP #$20
.1a267c	29 ff 00	and #$00ff	            AND #$00FF
.1a267f	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a2682	e2 20		sep #$20	            SEP #$20
.1a2684	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2687					is_string
.1a2687	20 37 15	jsr $1a1537	            JSR STRCONCAT
.1a268a	80 08		bra $1a2694	            BRA done
.1a268c					is_integer
.1a268c	20 1e 52	jsr $1a521e	            JSR OP_INT_ADD
.1a268f	80 03		bra $1a2694	            BRA done
.1a2691					is_float
.1a2691	20 8d 54	jsr $1a548d	            JSR OP_FP_ADD
.1a2694	28		plp		done        PLP
.1a2695	60		rts		            RTS
.1a2696					OP_MINUS
.1a2696	08		php		            PHP
.1a2697	e2 20		sep #$20	            SEP #$20
.1a2699	20 40 07	jsr $1a0740	            JSR ASS_ARGS_NUM
.1a269c	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a269e	f0 23		beq $1a26c3	            BEQ is_integer
.1a26a0	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a26a2	f0 24		beq $1a26c8	            BEQ is_float
.1a26a4					type_error
.1a26a4	08		php		            PHP
.1a26a5	c2 20		rep #$20	            REP #$20
.1a26a7	48		pha		            PHA
.1a26a8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a26ab	5b		tcd		            TCD
.1a26ac	68		pla		            PLA
.1a26ad	28		plp		            PLP
.1a26ae	e2 20		sep #$20	            SEP #$20
.1a26b0	a9 04		lda #$04	            LDA #ERR_TYPE
.1a26b2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a26b6	c2 20		rep #$20	            REP #$20
.1a26b8	29 ff 00	and #$00ff	            AND #$00FF
.1a26bb	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a26be	e2 20		sep #$20	            SEP #$20
.1a26c0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a26c3					is_integer
.1a26c3	20 30 52	jsr $1a5230	            JSR OP_INT_SUB
.1a26c6	80 03		bra $1a26cb	            BRA done
.1a26c8					is_float
.1a26c8	20 82 54	jsr $1a5482	            JSR OP_FP_SUB
.1a26cb	28		plp		done        PLP
.1a26cc	60		rts		            RTS
.1a26cd					OP_MULTIPLY
.1a26cd	08		php		            PHP
.1a26ce	e2 20		sep #$20	            SEP #$20
.1a26d0	20 40 07	jsr $1a0740	            JSR ASS_ARGS_NUM
.1a26d3	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a26d5	f0 23		beq $1a26fa	            BEQ is_integer
.1a26d7	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a26d9	f0 24		beq $1a26ff	            BEQ is_float
.1a26db					type_error
.1a26db	08		php		            PHP
.1a26dc	c2 20		rep #$20	            REP #$20
.1a26de	48		pha		            PHA
.1a26df	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a26e2	5b		tcd		            TCD
.1a26e3	68		pla		            PLA
.1a26e4	28		plp		            PLP
.1a26e5	e2 20		sep #$20	            SEP #$20
.1a26e7	a9 04		lda #$04	            LDA #ERR_TYPE
.1a26e9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a26ed	c2 20		rep #$20	            REP #$20
.1a26ef	29 ff 00	and #$00ff	            AND #$00FF
.1a26f2	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a26f5	e2 20		sep #$20	            SEP #$20
.1a26f7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a26fa					is_integer
.1a26fa	20 42 52	jsr $1a5242	            JSR OP_INT_MUL
.1a26fd	80 03		bra $1a2702	            BRA done
.1a26ff					is_float
.1a26ff	20 23 55	jsr $1a5523	            JSR OP_FP_MUL
.1a2702	28		plp		done        PLP
.1a2703	60		rts		            RTS
.1a2704					OP_DIVIDE
.1a2704	20 aa 06	jsr $1a06aa	            JSR ASS_ARG1_FLOAT
.1a2707	20 db 06	jsr $1a06db	            JSR ASS_ARG2_FLOAT
.1a270a	20 d8 54	jsr $1a54d8	            JSR OP_FP_DIV
.1a270d	60		rts		            RTS
.1a270e					OP_MOD
.1a270e	a5 23		lda $0823	            LDA ARGUMENT1
.1a2710	8f 1a 01 00	sta $00011a	            STA @lD1_OPERAND_B
.1a2714	a5 29		lda $0829	            LDA ARGUMENT2
.1a2716	8f 18 01 00	sta $000118	            STA @lD1_OPERAND_A
.1a271a	af 1e 01 00	lda $00011e	            LDA @lD1_REMAINDER
.1a271e	85 23		sta $0823	            STA ARGUMENT1
.1a2720	60		rts		            RTS
.1a2721					OP_POW
.1a2721	08		php		            PHP
.1a2722	c2 30		rep #$30	            REP #$30
.1a2724	48		pha		            PHA
.1a2725	20 aa 06	jsr $1a06aa	            JSR ASS_ARG1_FLOAT
.1a2728	a5 2d		lda $082d	            LDA ARGTYPE2
.1a272a	c9 00 00	cmp #$0000	            CMP #TYPE_INTEGER
.1a272d	d0 0d		bne $1a273c	            BNE flt_exp
.1a272f	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a2731	d0 09		bne $1a273c	            BNE flt_exp
.1a2733	da		phx		            PHX
.1a2734	a6 29		ldx $0829	            LDX ARGUMENT2
.1a2736	20 f6 61	jsr $1a61f6	            JSR Q_FP_POW_INT
.1a2739	fa		plx		            PLX
.1a273a	80 1c		bra $1a2758	            BRA done
.1a273c					flt_exp
.1a273c	20 db 06	jsr $1a06db	            JSR ASS_ARG2_FLOAT
.1a273f	c2 20		rep #$20	            REP #$20
.1a2741	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a2743	48		pha		            PHA
.1a2744	a5 29		lda $0829	            LDA ARGUMENT2
.1a2746	48		pha		            PHA
.1a2747	20 81 60	jsr $1a6081	            JSR FP_LN
.1a274a	c2 20		rep #$20	            REP #$20
.1a274c	68		pla		            PLA
.1a274d	85 29		sta $0829	            STA ARGUMENT2
.1a274f	68		pla		            PLA
.1a2750	85 2b		sta $082b	            STA ARGUMENT2+2
.1a2752	20 23 55	jsr $1a5523	            JSR OP_FP_MUL
.1a2755	20 60 62	jsr $1a6260	            JSR FP_EXP
.1a2758	68		pla		done        PLA
.1a2759	28		plp		            PLP
.1a275a	60		rts		            RTS
.1a275b					OP_AND
.1a275b	08		php		            PHP
.1a275c	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a275f	20 6d 05	jsr $1a056d	            JSR ASS_ARG2_INT
.1a2762	c2 20		rep #$20	            REP #$20
.1a2764	a5 23		lda $0823	            LDA ARGUMENT1
.1a2766	25 29		and $0829	            AND ARGUMENT2
.1a2768	85 23		sta $0823	            STA ARGUMENT1
.1a276a	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a276c	25 2b		and $082b	            AND ARGUMENT2+2
.1a276e	85 25		sta $0825	            STA ARGUMENT1+2
.1a2770	28		plp		            PLP
.1a2771	60		rts		            RTS
.1a2772					OP_OR
.1a2772	08		php		            PHP
.1a2773	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a2776	20 6d 05	jsr $1a056d	            JSR ASS_ARG2_INT
.1a2779	c2 20		rep #$20	            REP #$20
.1a277b	a5 23		lda $0823	            LDA ARGUMENT1
.1a277d	05 29		ora $0829	            ORA ARGUMENT2
.1a277f	85 23		sta $0823	            STA ARGUMENT1
.1a2781	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a2783	05 2b		ora $082b	            ORA ARGUMENT2+2
.1a2785	85 25		sta $0825	            STA ARGUMENT1+2
.1a2787	28		plp		done        PLP
.1a2788	60		rts		            RTS
.1a2789					OP_NOT
.1a2789	08		php		            PHP
.1a278a	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a278d	c2 20		rep #$20	            REP #$20
.1a278f	a5 23		lda $0823	            LDA ARGUMENT1
.1a2791	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a2794	85 23		sta $0823	            STA ARGUMENT1
.1a2796	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a2798	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a279b	85 25		sta $0825	            STA ARGUMENT1+2
.1a279d	28		plp		done        PLP
.1a279e	60		rts		            RTS
.1a279f					OP_LT
.1a279f	08		php		            PHP
.1a27a0	e2 20		sep #$20	            SEP #$20
.1a27a2	20 8e 07	jsr $1a078e	            JSR ASS_ARGS_NUMSTR
.1a27a5	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a27a7	f0 2c		beq $1a27d5	            BEQ is_integer
.1a27a9	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a27ab	f0 2d		beq $1a27da	            BEQ is_float
.1a27ad	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a27af	f0 1f		beq $1a27d0	            BEQ is_string
.1a27b1					type_error
.1a27b1	08		php		            PHP
.1a27b2	c2 20		rep #$20	            REP #$20
.1a27b4	48		pha		            PHA
.1a27b5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a27b8	5b		tcd		            TCD
.1a27b9	68		pla		            PLA
.1a27ba	28		plp		            PLP
.1a27bb	e2 20		sep #$20	            SEP #$20
.1a27bd	a9 04		lda #$04	            LDA #ERR_TYPE
.1a27bf	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a27c3	c2 20		rep #$20	            REP #$20
.1a27c5	29 ff 00	and #$00ff	            AND #$00FF
.1a27c8	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a27cb	e2 20		sep #$20	            SEP #$20
.1a27cd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a27d0					is_string
.1a27d0	20 bf 16	jsr $1a16bf	            JSR OP_STR_LT
.1a27d3	80 08		bra $1a27dd	            BRA done
.1a27d5					is_integer
.1a27d5	20 43 53	jsr $1a5343	            JSR OP_INT_LT
.1a27d8	80 03		bra $1a27dd	            BRA done
.1a27da					is_float
.1a27da	20 b8 5a	jsr $1a5ab8	            JSR OP_FP_LT
.1a27dd	28		plp		done        PLP
.1a27de	60		rts		            RTS
.1a27df					OP_GT
.1a27df	08		php		            PHP
.1a27e0	e2 20		sep #$20	            SEP #$20
.1a27e2	20 8e 07	jsr $1a078e	            JSR ASS_ARGS_NUMSTR
.1a27e5	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a27e7	f0 2c		beq $1a2815	            BEQ is_integer
.1a27e9	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a27eb	f0 2d		beq $1a281a	            BEQ is_float
.1a27ed	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a27ef	f0 1f		beq $1a2810	            BEQ is_string
.1a27f1					type_error
.1a27f1	08		php		            PHP
.1a27f2	c2 20		rep #$20	            REP #$20
.1a27f4	48		pha		            PHA
.1a27f5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a27f8	5b		tcd		            TCD
.1a27f9	68		pla		            PLA
.1a27fa	28		plp		            PLP
.1a27fb	e2 20		sep #$20	            SEP #$20
.1a27fd	a9 04		lda #$04	            LDA #ERR_TYPE
.1a27ff	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2803	c2 20		rep #$20	            REP #$20
.1a2805	29 ff 00	and #$00ff	            AND #$00FF
.1a2808	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a280b	e2 20		sep #$20	            SEP #$20
.1a280d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2810					is_string
.1a2810	20 d6 16	jsr $1a16d6	            JSR OP_STR_GT
.1a2813	80 08		bra $1a281d	            BRA done
.1a2815					is_integer
.1a2815	20 64 53	jsr $1a5364	            JSR OP_INT_GT
.1a2818	80 03		bra $1a281d	            BRA done
.1a281a					is_float
.1a281a	20 cd 5a	jsr $1a5acd	            JSR OP_FP_GT
.1a281d	28		plp		done        PLP
.1a281e	60		rts		            RTS
.1a281f					OP_EQ
.1a281f	08		php		            PHP
.1a2820	e2 20		sep #$20	            SEP #$20
.1a2822	20 8e 07	jsr $1a078e	            JSR ASS_ARGS_NUMSTR
.1a2825	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a2827	f0 2c		beq $1a2855	            BEQ is_integer
.1a2829	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a282b	f0 2d		beq $1a285a	            BEQ is_float
.1a282d	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a282f	f0 1f		beq $1a2850	            BEQ is_string
.1a2831					type_error
.1a2831	08		php		            PHP
.1a2832	c2 20		rep #$20	            REP #$20
.1a2834	48		pha		            PHA
.1a2835	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2838	5b		tcd		            TCD
.1a2839	68		pla		            PLA
.1a283a	28		plp		            PLP
.1a283b	e2 20		sep #$20	            SEP #$20
.1a283d	a9 04		lda #$04	            LDA #ERR_TYPE
.1a283f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2843	c2 20		rep #$20	            REP #$20
.1a2845	29 ff 00	and #$00ff	            AND #$00FF
.1a2848	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a284b	e2 20		sep #$20	            SEP #$20
.1a284d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2850					is_string
.1a2850	20 ed 16	jsr $1a16ed	            JSR OP_STR_EQ
.1a2853	80 08		bra $1a285d	            BRA done
.1a2855					is_integer
.1a2855	20 91 53	jsr $1a5391	            JSR OP_INT_EQ
.1a2858	80 03		bra $1a285d	            BRA done
.1a285a					is_float
.1a285a	20 e2 5a	jsr $1a5ae2	            JSR OP_FP_EQ
.1a285d	28		plp		done        PLP
.1a285e	60		rts		            RTS
.1a285f					OP_NE
.1a285f	08		php		            PHP
.1a2860	e2 20		sep #$20	            SEP #$20
.1a2862	20 8e 07	jsr $1a078e	            JSR ASS_ARGS_NUMSTR
.1a2865	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a2867	f0 2c		beq $1a2895	            BEQ is_integer
.1a2869	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a286b	f0 2d		beq $1a289a	            BEQ is_float
.1a286d	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a286f	f0 1f		beq $1a2890	            BEQ is_string
.1a2871					type_error
.1a2871	08		php		            PHP
.1a2872	c2 20		rep #$20	            REP #$20
.1a2874	48		pha		            PHA
.1a2875	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2878	5b		tcd		            TCD
.1a2879	68		pla		            PLA
.1a287a	28		plp		            PLP
.1a287b	e2 20		sep #$20	            SEP #$20
.1a287d	a9 04		lda #$04	            LDA #ERR_TYPE
.1a287f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2883	c2 20		rep #$20	            REP #$20
.1a2885	29 ff 00	and #$00ff	            AND #$00FF
.1a2888	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a288b	e2 20		sep #$20	            SEP #$20
.1a288d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2890					is_string
.1a2890	20 04 17	jsr $1a1704	            JSR OP_STR_NE
.1a2893	80 08		bra $1a289d	            BRA done
.1a2895					is_integer
.1a2895	20 af 53	jsr $1a53af	            JSR OP_INT_NE
.1a2898	80 03		bra $1a289d	            BRA done
.1a289a					is_float
.1a289a	20 21 5b	jsr $1a5b21	            JSR OP_FP_NE
.1a289d	28		plp		done        PLP
.1a289e	60		rts		            RTS
.1a289f					OP_GTE
.1a289f	08		php		            PHP
.1a28a0	e2 20		sep #$20	            SEP #$20
.1a28a2	20 8e 07	jsr $1a078e	            JSR ASS_ARGS_NUMSTR
.1a28a5	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a28a7	f0 2c		beq $1a28d5	            BEQ is_integer
.1a28a9	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a28ab	f0 2d		beq $1a28da	            BEQ is_float
.1a28ad	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a28af	f0 1f		beq $1a28d0	            BEQ is_string
.1a28b1					type_error
.1a28b1	08		php		            PHP
.1a28b2	c2 20		rep #$20	            REP #$20
.1a28b4	48		pha		            PHA
.1a28b5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a28b8	5b		tcd		            TCD
.1a28b9	68		pla		            PLA
.1a28ba	28		plp		            PLP
.1a28bb	e2 20		sep #$20	            SEP #$20
.1a28bd	a9 04		lda #$04	            LDA #ERR_TYPE
.1a28bf	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a28c3	c2 20		rep #$20	            REP #$20
.1a28c5	29 ff 00	and #$00ff	            AND #$00FF
.1a28c8	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a28cb	e2 20		sep #$20	            SEP #$20
.1a28cd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a28d0					is_string
.1a28d0	20 1b 17	jsr $1a171b	            JSR OP_STR_GTE
.1a28d3	80 08		bra $1a28dd	            BRA done
.1a28d5					is_integer
.1a28d5	20 cd 53	jsr $1a53cd	            JSR OP_INT_GTE
.1a28d8	80 03		bra $1a28dd	            BRA done
.1a28da					is_float
.1a28da	20 0c 5b	jsr $1a5b0c	            JSR OP_FP_GTE
.1a28dd	28		plp		done        PLP
.1a28de	60		rts		            RTS
.1a28df					OP_LTE
.1a28df	08		php		            PHP
.1a28e0	e2 20		sep #$20	            SEP #$20
.1a28e2	20 8e 07	jsr $1a078e	            JSR ASS_ARGS_NUMSTR
.1a28e5	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a28e7	f0 2c		beq $1a2915	            BEQ is_integer
.1a28e9	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a28eb	f0 2d		beq $1a291a	            BEQ is_float
.1a28ed	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a28ef	f0 1f		beq $1a2910	            BEQ is_string
.1a28f1					type_error
.1a28f1	08		php		            PHP
.1a28f2	c2 20		rep #$20	            REP #$20
.1a28f4	48		pha		            PHA
.1a28f5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a28f8	5b		tcd		            TCD
.1a28f9	68		pla		            PLA
.1a28fa	28		plp		            PLP
.1a28fb	e2 20		sep #$20	            SEP #$20
.1a28fd	a9 04		lda #$04	            LDA #ERR_TYPE
.1a28ff	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2903	c2 20		rep #$20	            REP #$20
.1a2905	29 ff 00	and #$00ff	            AND #$00FF
.1a2908	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a290b	e2 20		sep #$20	            SEP #$20
.1a290d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2910					is_string
.1a2910	20 32 17	jsr $1a1732	            JSR OP_STR_LTE
.1a2913	80 08		bra $1a291d	            BRA done
.1a2915					is_integer
.1a2915	20 fa 53	jsr $1a53fa	            JSR OP_INT_LTE
.1a2918	80 03		bra $1a291d	            BRA done
.1a291a					is_float
.1a291a	20 f7 5a	jsr $1a5af7	            JSR OP_FP_LTE
.1a291d	28		plp		done        PLP
.1a291e	60		rts		            RTS
.1a291f					OP_NEGATIVE
.1a291f	08		php		                PHP
.1a2920	e2 20		sep #$20	            SEP #$20
.1a2922	a5 27		lda $0827	                LDA ARGTYPE1                ; Check the type of the argument
.1a2924	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a2926	f0 2d		beq $1a2955	                BEQ int_negate              ; If integer: negate the integer
.1a2928	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.1a292a	f0 1f		beq $1a294b	                BEQ float_negate            ; If floating point: negate the floating point
.1a292c					type_error
.1a292c	08		php		            PHP
.1a292d	c2 20		rep #$20	            REP #$20
.1a292f	48		pha		            PHA
.1a2930	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2933	5b		tcd		            TCD
.1a2934	68		pla		            PLA
.1a2935	28		plp		            PLP
.1a2936	e2 20		sep #$20	            SEP #$20
.1a2938	a9 04		lda #$04	            LDA #ERR_TYPE
.1a293a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a293e	c2 20		rep #$20	            REP #$20
.1a2940	29 ff 00	and #$00ff	            AND #$00FF
.1a2943	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a2946	e2 20		sep #$20	            SEP #$20
.1a2948	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a294b					float_negate
.1a294b	e2 20		sep #$20	            SEP #$20
.1a294d	a5 26		lda $0826	                LDA ARGUMENT1+3             ; Flip the sign bit of the floating point number
.1a294f	49 80		eor #$80	                EOR #$80
.1a2951	85 26		sta $0826	                STA ARGUMENT1+3
.1a2953	80 16		bra $1a296b	                BRA done
.1a2955					int_negate
.1a2955	c2 20		rep #$20	            REP #$20
.1a2957	a5 23		lda $0823	                LDA ARGUMENT1               ; Invert ARGUMENT1
.1a2959	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a295c	85 23		sta $0823	                STA ARGUMENT1
.1a295e	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a2960	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a2963	85 25		sta $0825	                STA ARGUMENT1+2
.1a2965	e6 23		inc $0823	                INC ARGUMENT1               ; And increment to get two's complement
.1a2967	d0 02		bne $1a296b	                BNE done
.1a2969	e6 25		inc $0825	                INC ARGUMENT1+2
.1a296b					done
.1a296b	28		plp		                PLP
.1a296c	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\statements.s


;******  Processing file: src\C256/statements_c256.s

=0					GR_LUT_BLUE = 0
=1					GR_LUT_GREEN = 1
=2					GR_LUT_RED = 2
=3					GR_LUT_ALPHA = 3
=640					GR_DEFAULT_COLS = 640               ; Default number of columns in the display
=480					GR_DEFAULT_ROWS = 480               ; Default number of rows in the display
=8					GR_MAX_LUT = 8                      ; The number of LUTs Vicky supports
=64					SP_MAX = 64                         ; The number of sprites Vicky supports
=8					SP_REG_SIZE = 8                     ; The number of bytes in a sprite's register block
=0					SP_CONTROL = 0                      ; Offset of the control regsiter for a sprite
=1					SP_ADDR = 1                         ; Offset of the pixmap address for a sprite
=4					SP_X_COORD = 4                      ; Offset of the X coordinate for a sprite
=6					SP_Y_COORD = 6                      ; Offset of the Y coordinate for a sprite
=12					TILEMAP_REG_SIZE = 12               ; The number of bytes in a tile map's register set
=4					TILESET_REG_SIZE = 4                ; The number of bytes in a tile set's register set
=2					BM_MAX = 2                          ; Maximum number of bitmaps we support
=$0040					MAX_VRAM_VICKY = $0040              ; Upper limit (exclusive) bank address for VRAM in Vicky address space
=$00f0					MAX_VRAM_CPU = $00F0                ; Upper limit (exclusive) bank address for VRAM in CPU address space
=$00b0					MIN_VRAM_CPU = $00B0                ; Lower limit (inclusive) bank address for VRAM in CPU address space
>1af000					GR_BM0_ADDR     .dword ?            ; Address of bitmap 0 (from CPU's perspective)
>1af004					GR_BM1_ADDR     .dword ?            ; Address of bitmap 1 (from CPU's perspective)
>1af008					GR_BM0_VRAM     .dword ?            ; Address of bitmap 0 (relative to start of VRAM)
>1af00c					GR_BM1_VRAM     .dword ?            ; Address of bitmap 1 (relative to start of VRAM)
>1af010					GR_MAX_COLS     .word ?             ; Width the display in pixels
>1af012					GR_MAX_ROWS     .word ?             ; Height of the display in pixels
>1af014					GR_TOTAL_PIXELS .word ?             ; Total number of pixels in the display
>1af016					GR_TEMP         .word ?             ; A temporary word for graphics commands
>1af018					GS_SP_CONTROL   .fill SP_MAX        ; Shadow registers for the sprite controls
.1a296d					S_SETTIME
.1a296d	08		php		                PHP
.1a296e	e2 20		sep #$20	            SEP #$20
.1a2970	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2973	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2976	20 99 04	jsr $1a0499	            JSR DIVINT10
.1a2979	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a297b	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a297c	0a		asl a		                ASL A
.1a297d	0a		asl a		                ASL A
.1a297e	0a		asl a		                ASL A
.1a297f	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2981	48		pha		                PHA
.1a2982	a9 2c		lda #$2c	                LDA #','
.1a2984	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a2987	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a298a	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a298d	20 99 04	jsr $1a0499	            JSR DIVINT10
.1a2990	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2992	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2993	0a		asl a		                ASL A
.1a2994	0a		asl a		                ASL A
.1a2995	0a		asl a		                ASL A
.1a2996	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2998	48		pha		                PHA
.1a2999	a9 2c		lda #$2c	                LDA #','
.1a299b	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a299e	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a29a1	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a29a4	20 99 04	jsr $1a0499	            JSR DIVINT10
.1a29a7	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a29a9	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a29aa	0a		asl a		                ASL A
.1a29ab	0a		asl a		                ASL A
.1a29ac	0a		asl a		                ASL A
.1a29ad	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a29af	48		pha		                PHA
.1a29b0	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a29b4	09 0c		ora #$0c	                ORA #%00001100
.1a29b6	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a29ba	68		pla		                PLA                     ; And seconds to the RTC
.1a29bb	8f 00 08 af	sta $af0800	                STA @lRTC_SEC
.1a29bf	68		pla		                PLA                     ; Minutes...
.1a29c0	8f 02 08 af	sta $af0802	                STA @lRTC_MIN
.1a29c4	68		pla		                PLA                     ; Save the hour...
.1a29c5	8f 04 08 af	sta $af0804	                STA @lRTC_HRS
.1a29c9	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a29cd	29 f7		and #$f7	                AND #%11110111
.1a29cf	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a29d3	20 dc 1f	jsr $1a1fdc	            JSR SKIPSTMT
.1a29d6	28		plp		                PLP
.1a29d7	60		rts		            RTS
.1a29d8					S_SETDATE
.1a29d8	08		php		                PHP
.1a29d9	e2 20		sep #$20	            SEP #$20
.1a29db	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a29de	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a29e1	20 99 04	jsr $1a0499	            JSR DIVINT10
.1a29e4	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a29e6	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a29e7	0a		asl a		                ASL A
.1a29e8	0a		asl a		                ASL A
.1a29e9	0a		asl a		                ASL A
.1a29ea	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a29ec	48		pha		                PHA
.1a29ed	a9 2c		lda #$2c	                LDA #','
.1a29ef	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a29f2	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a29f5	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a29f8	20 99 04	jsr $1a0499	            JSR DIVINT10
.1a29fb	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a29fd	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a29fe	0a		asl a		                ASL A
.1a29ff	0a		asl a		                ASL A
.1a2a00	0a		asl a		                ASL A
.1a2a01	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2a03	48		pha		                PHA
.1a2a04	a9 2c		lda #$2c	                LDA #','
.1a2a06	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a2a09	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2a0c	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a2a0f	20 cf 04	jsr $1a04cf	            JSR DIVINT100
.1a2a12	c2 20		rep #$20	            REP #$20
.1a2a14	a5 23		lda $0823	                LDA ARGUMENT1           ; Get the century
.1a2a16	85 92		sta $0892	                STA MTEMP               ; Save it in MTEMP
.1a2a18	a5 29		lda $0829	                LDA ARGUMENT2           ; Separate the 10s from the 1s digits
.1a2a1a	85 23		sta $0823	                STA ARGUMENT1
.1a2a1c	20 99 04	jsr $1a0499	            JSR DIVINT10
.1a2a1f	e2 20		sep #$20	            SEP #$20
.1a2a21	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2a23	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2a24	0a		asl a		                ASL A
.1a2a25	0a		asl a		                ASL A
.1a2a26	0a		asl a		                ASL A
.1a2a27	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2a29	48		pha		                PHA                     ; Save the 10s and 1s in BCD
.1a2a2a	c2 20		rep #$20	            REP #$20
.1a2a2c	a5 92		lda $0892	                LDA MTEMP               ; Separate the 100s from the 1000s digits
.1a2a2e	85 23		sta $0823	                STA ARGUMENT1
.1a2a30	20 99 04	jsr $1a0499	            JSR DIVINT10
.1a2a33	e2 20		sep #$20	            SEP #$20
.1a2a35	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2a37	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2a38	0a		asl a		                ASL A
.1a2a39	0a		asl a		                ASL A
.1a2a3a	0a		asl a		                ASL A
.1a2a3b	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2a3d	48		pha		                PHA                     ; Save the 100s and 1000s in BCD
.1a2a3e	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a2a42	09 0c		ora #$0c	                ORA #%00001100
.1a2a44	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2a48	68		pla		                PLA                     ; Set the century
.1a2a49	8f 0f 08 af	sta $af080f	                STA @lRTC_CENTURY
.1a2a4d	68		pla		                PLA                     ; And year to the RTC
.1a2a4e	8f 0a 08 af	sta $af080a	                STA @lRTC_YEAR
.1a2a52	68		pla		                PLA                     ; Month...
.1a2a53	8f 09 08 af	sta $af0809	                STA @lRTC_MONTH
.1a2a57	68		pla		                PLA                     ; Save the day...
.1a2a58	8f 06 08 af	sta $af0806	                STA @lRTC_DAY
.1a2a5c	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a2a60	29 f7		and #$f7	                AND #%11110111
.1a2a62	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2a66	20 dc 1f	jsr $1a1fdc	            JSR SKIPSTMT
.1a2a69	28		plp		                PLP
.1a2a6a	60		rts		            RTS
.1a2a6b					S_TEXTCOLOR
.1a2a6b	08		php		                PHP
.1a2a6c					locals
>0001					L_FOREGROUND    .byte ?
.1a2a6c	e2 20		sep #$20	            SEP #$20
.1a2a6e	48		pha		            PHA
.1a2a6f	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2a72	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2a75	e2 20		sep #$20	            SEP #$20
.1a2a77	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the foreground position
.1a2a79	29 0f		and #$0f	                AND #$0F
.1a2a7b	0a		asl a		                ASL A
.1a2a7c	0a		asl a		                ASL A
.1a2a7d	0a		asl a		                ASL A
.1a2a7e	0a		asl a		                ASL A
.1a2a7f	83 01		sta $01,s	                STA L_FOREGROUND    ; Save the foreground color
.1a2a81	a9 2c		lda #$2c	                LDA #','
.1a2a83	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a2a86	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2a89	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2a8c	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the background position
.1a2a8e	29 0f		and #$0f	                AND #$0F
.1a2a90	03 01		ora $01,s	                ORA L_FOREGROUND    ; Add in the foreground
.1a2a92	8f 1e 00 00	sta $00001e	                STA @lCURCOLOR      ; And save the new color combination
.1a2a96	e2 20		sep #$20	            SEP #$20
.1a2a98	68		pla		            PLA
.1a2a99	28		plp		                PLP
.1a2a9a	60		rts		            RTS
.1a2a9b					S_SETBGCOLOR
.1a2a9b	08		php		                PHP
.1a2a9c					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.1a2a9c	c2 20		rep #$20	            REP #$20
.1a2a9e	f4 00 00	pea #$0000	            PEA #0
.1a2aa1	e2 20		sep #$20	            SEP #$20
.1a2aa3	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2aa6	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2aa9	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.1a2aab	83 01		sta $01,s	                STA L_RED
.1a2aad	a9 2c		lda #$2c	                LDA #','
.1a2aaf	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a2ab2	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2ab5	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2ab8	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.1a2aba	83 02		sta $02,s	                STA L_GREEN
.1a2abc	a9 2c		lda #$2c	                LDA #','
.1a2abe	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a2ac1	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2ac4	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2ac7	a5 23		lda $0823	                LDA ARGUMENT1               ; And set the actual color
.1a2ac9	8f 0d 00 af	sta $af000d	                STA @lBACKGROUND_COLOR_B
.1a2acd	a3 02		lda $02,s	                LDA L_GREEN
.1a2acf	8f 0e 00 af	sta $af000e	                STA @lBACKGROUND_COLOR_G
.1a2ad3	a3 01		lda $01,s	                LDA L_RED
.1a2ad5	8f 0f 00 af	sta $af000f	                STA @lBACKGROUND_COLOR_R
.1a2ad9	c2 20		rep #$20	            REP #$20
.1a2adb	68		pla		            PLA
.1a2adc	28		plp		                PLP
.1a2add	60		rts		            RTS
.1a2ade					S_SETBORDER
.1a2ade	08		php		                PHP
.1a2adf					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.1a2adf	c2 20		rep #$20	            REP #$20
.1a2ae1	f4 00 00	pea #$0000	            PEA #0
.1a2ae4	e2 20		sep #$20	            SEP #$20
.1a2ae6	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2ae9	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a2aec	a5 23		lda $0823	                LDA ARGUMENT1
.1a2aee	f0 16		beq $1a2b06	                BEQ hide_border
.1a2af0	a9 01		lda #$01	                LDA #Border_Ctrl_Enable     ; Enable the border
.1a2af2	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.1a2af6	a9 20		lda #$20	                LDA #BORDER_WIDTH           ; Set the border width
.1a2af8	8f 08 00 af	sta $af0008	                STA BORDER_X_SIZE
.1a2afc	8f 09 00 af	sta $af0009	                STA BORDER_Y_SIZE
.1a2b00	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.1a2b04	80 0a		bra $1a2b10	                BRA get_color
.1a2b06	a9 00		lda #$00	hide_border     LDA #0                      ; Hide the border
.1a2b08	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.1a2b0c	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.1a2b10	a9 2c		lda #$2c	get_color       LDA #','
.1a2b12	85 37		sta $0837	                STA TARGETTOK
.1a2b14	20 d9 20	jsr $1a20d9	            JSR OPT_TOK
.1a2b17	90 39		bcc $1a2b52	                BCC done                    ; No: we're done
.1a2b19	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a2b1c	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2b1f	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2b22	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.1a2b24	83 01		sta $01,s	                STA L_RED
.1a2b26	a9 2c		lda #$2c	                LDA #','
.1a2b28	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a2b2b	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2b2e	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2b31	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.1a2b33	83 02		sta $02,s	                STA L_GREEN
.1a2b35	a9 2c		lda #$2c	                LDA #','
.1a2b37	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a2b3a	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2b3d	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2b40	a5 23		lda $0823	                LDA ARGUMENT1
.1a2b42	8f 05 00 af	sta $af0005	                STA @lBORDER_COLOR_B        ; Set the border color
.1a2b46	a3 02		lda $02,s	                LDA L_GREEN
.1a2b48	8f 06 00 af	sta $af0006	                STA @lBORDER_COLOR_G
.1a2b4c	a3 01		lda $01,s	                LDA L_RED
.1a2b4e	8f 07 00 af	sta $af0007	                STA @lBORDER_COLOR_R
.1a2b52					done
.1a2b52	c2 20		rep #$20	            REP #$20
.1a2b54	68		pla		            PLA
.1a2b55	28		plp		                PLP
.1a2b56	60		rts		            RTS
.1a2b57					S_SETCOLOR
.1a2b57	08		php		                PHP
.1a2b58					locals
>0001					L_LUT           .byte ?
>0002					L_COLOR         .byte ?
>0003					L_RED           .byte ?
>0004					L_GREEN         .byte ?
>0005					L_BLUE          .byte ?
.1a2b58	c2 20		rep #$20	            REP #$20
.1a2b5a	3b		tsc		            TSC
.1a2b5b	38		sec		            SEC
.1a2b5c	e9 05 00	sbc #$0005	            SBC #SIZE(locals)
.1a2b5f	1b		tcs		            TCS
.1a2b60	e2 20		sep #$20	            SEP #$20
.1a2b62	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2b65	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2b68	a5 23		lda $0823	                LDA ARGUMENT1
.1a2b6a	c9 0a		cmp #$0a	                CMP #10             ; And in range
.1a2b6c	90 1f		bcc $1a2b8d	                BLT save_lut
.1a2b6e					bad_argument
.1a2b6e	08		php		            PHP
.1a2b6f	c2 20		rep #$20	            REP #$20
.1a2b71	48		pha		            PHA
.1a2b72	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2b75	5b		tcd		            TCD
.1a2b76	68		pla		            PLA
.1a2b77	28		plp		            PLP
.1a2b78	e2 20		sep #$20	            SEP #$20
.1a2b7a	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a2b7c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2b80	c2 20		rep #$20	            REP #$20
.1a2b82	29 ff 00	and #$00ff	            AND #$00FF
.1a2b85	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a2b88	e2 20		sep #$20	            SEP #$20
.1a2b8a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2b8d	83 01		sta $01,s	save_lut        STA L_LUT           ; Save as LUT
.1a2b8f	a9 2c		lda #$2c	                LDA #','
.1a2b91	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a2b94	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2b97	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2b9a	a5 23		lda $0823	                LDA ARGUMENT1
.1a2b9c	83 02		sta $02,s	                STA L_COLOR         ; Save as COLOR
.1a2b9e	a9 2c		lda #$2c	                LDA #','
.1a2ba0	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a2ba3	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2ba6	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2ba9	a5 23		lda $0823	                LDA ARGUMENT1
.1a2bab	83 03		sta $03,s	                STA L_RED           ; Save as RED
.1a2bad	a9 2c		lda #$2c	                LDA #','
.1a2baf	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a2bb2	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2bb5	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2bb8	a5 23		lda $0823	                LDA ARGUMENT1
.1a2bba	83 04		sta $04,s	                STA L_GREEN         ; Save it as GREEN
.1a2bbc	a9 2c		lda #$2c	                LDA #','
.1a2bbe	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a2bc1	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2bc4	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2bc7	a5 23		lda $0823	                LDA ARGUMENT1
.1a2bc9	83 05		sta $05,s	                STA L_BLUE          ; Save it as BLUE
.1a2bcb	a9 af		lda #$af	                LDA #`GRPH_LUT0_PTR ; Get the bank Vicky is in (should always be $AF)
.1a2bcd	85 a0		sta $08a0	                STA MTEMPPTR+2      ; MTEMPPTR will be our pointer to the LUT entry
.1a2bcf	a3 01		lda $01,s	                LDA L_LUT           ; Compute the offset to the LUT address
.1a2bd1	0a		asl a		                ASL A
.1a2bd2	c2 20		rep #$20	            REP #$20
.1a2bd4	29 ff 00	and #$00ff	                AND #$00FF
.1a2bd7	aa		tax		                TAX                 ; Put it in X
.1a2bd8	bf 0f 2c 1a	lda $1a2c0f,x	                LDA @llut_address,X ; Get the address of the LUT
.1a2bdc	85 9e		sta $089e	                STA MTEMPPTR        ; Put it in MTEMPPTR
.1a2bde	e2 20		sep #$20	            SEP #$20
.1a2be0	a3 02		lda $02,s	                LDA L_COLOR         ; color index *= 4
.1a2be2	c2 20		rep #$20	            REP #$20
.1a2be4	29 ff 00	and #$00ff	                AND #$00FF
.1a2be7	0a		asl a		                ASL A               ; Since each color has four bytes of data
.1a2be8	0a		asl a		                ASL A
.1a2be9	18		clc		                CLC                 ; Add the color offset to MTEMPPTR
.1a2bea	65 9e		adc $089e	                ADC MTEMPPTR
.1a2bec	85 9e		sta $089e	                STA MTEMPPTR
.1a2bee	e2 20		sep #$20	            SEP #$20
.1a2bf0	a0 02 00	ldy #$0002	                LDY #GR_LUT_RED
.1a2bf3	a3 03		lda $03,s	                LDA L_RED
.1a2bf5	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the red component to the color entry
.1a2bf7	a0 01 00	ldy #$0001	                LDY #GR_LUT_GREEN
.1a2bfa	a3 04		lda $04,s	                LDA L_GREEN
.1a2bfc	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the green component to the color entry
.1a2bfe	a0 00 00	ldy #$0000	                LDY #GR_LUT_BLUE
.1a2c01	a3 05		lda $05,s	                LDA L_BLUE
.1a2c03	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the blue component to the color entry
.1a2c05					done
.1a2c05	c2 20		rep #$20	            REP #$20
.1a2c07	3b		tsc		            TSC
.1a2c08	18		clc		            CLC
.1a2c09	69 05 00	adc #$0005	            ADC #SIZE(locals)
.1a2c0c	1b		tcs		            TCS
.1a2c0d	28		plp		                PLP
.1a2c0e	60		rts		            RTS
>1a2c0f	00 20				lut_address     .word <>GRPH_LUT0_PTR
>1a2c11	00 24				                .word <>GRPH_LUT1_PTR
>1a2c13	00 28				                .word <>GRPH_LUT2_PTR
>1a2c15	00 2c				                .word <>GRPH_LUT3_PTR
>1a2c17	00 30				                .word <>GRPH_LUT4_PTR
>1a2c19	00 34				                .word <>GRPH_LUT5_PTR
>1a2c1b	00 38				                .word <>GRPH_LUT6_PTR
>1a2c1d	00 3c				                .word <>GRPH_LUT7_PTR
>1a2c1f	40 1f				                .word <>FG_CHAR_LUT_PTR
>1a2c21	80 1f				                .word <>BG_CHAR_LUT_PTR
.1a2c23					S_GRAPHICS
.1a2c23	da		phx		                PHX
.1a2c24	5a		phy		                PHY
.1a2c25	08		php		                PHP
.1a2c26	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2c29	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a2c2c	c2 20		rep #$20	            REP #$20
.1a2c2e	a5 23		lda $0823	                LDA ARGUMENT1               ; Check to see if we're setting mode to 800x600 or 400x300
.1a2c30	89 00 01	bit #$0100	                BIT #$0100
.1a2c33	d0 17		bne $1a2c4c	                BNE set_mode                ; Yes: go ahead and set it
.1a2c35	af 00 00 af	lda $af0000	                LDA @l MASTER_CTRL_REG_L    ; Otherwise, check to see if we're already in 800x600 or 400x300
.1a2c39	89 00 01	bit #$0100	                BIT #$0100
.1a2c3c	f0 0e		beq $1a2c4c	                BEQ set_mode                ; No: just go ahead and set the mode
.1a2c3e	e2 20		sep #$20	            SEP #$20
.1a2c40	a9 00		lda #$00	                LDA #0                      ; Yes: toggle back to 640x480...
.1a2c42	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.1a2c46	a9 01		lda #$01	                LDA #1                      ; And back to 800x600....
.1a2c48	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.1a2c4c					set_mode
.1a2c4c	c2 20		rep #$20	            REP #$20
.1a2c4e	a5 23		lda $0823	                LDA ARGUMENT1
.1a2c50	8f 00 00 af	sta $af0000	                STA @l MASTER_CTRL_REG_L    ; Set the graphics mode
.1a2c54	e2 20		sep #$20	            SEP #$20
.1a2c56	a5 24		lda $0824	                LDA ARGUMENT1+1             ; Get the screen size bits
.1a2c58	c2 20		rep #$20	            REP #$20
.1a2c5a	29 03 00	and #$0003	                AND #$0003
.1a2c5d	0a		asl a		                ASL A                       ; Multiply by two to get the index
.1a2c5e	aa		tax		                TAX                         ; X is index into the size tables
.1a2c5f	c2 20		rep #$20	            REP #$20
.1a2c61	bf aa 2c 1a	lda $1a2caa,x	                LDA gr_columns,X            ; Set the columns
.1a2c65	8f 10 f0 1a	sta $1af010	                STA @lGR_MAX_COLS
.1a2c69	bf b2 2c 1a	lda $1a2cb2,x	                LDA gr_rows,X               ; Set the rows
.1a2c6d	8f 12 f0 1a	sta $1af012	                STA @lGR_MAX_ROWS
.1a2c71	af 10 f0 1a	lda $1af010	                LDA @lGR_MAX_COLS           ; Get the current columns
.1a2c75	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.1a2c79	af 12 f0 1a	lda $1af012	                LDA @lGR_MAX_ROWS           ; Get the current rows
.1a2c7d	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B
.1a2c81	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT             ; Multiply them to get the total pixels
.1a2c85	8f 14 f0 1a	sta $1af014	                STA @lGR_TOTAL_PIXELS
.1a2c89	e2 20		sep #$20	            SEP #$20
.1a2c8b	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.1a2c8f	8f 16 f0 1a	sta $1af016	                STA @lGR_TOTAL_PIXELS+2
.1a2c93	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.1a2c97					reset_cursor
.1a2c97	c2 20		rep #$20	            REP #$20
.1a2c99	af 1a 00 00	lda $00001a	                LDA @lCURSORX
.1a2c9d	aa		tax		                TAX
.1a2c9e	af 1c 00 00	lda $00001c	                LDA @lCURSORY
.1a2ca2	a8		tay		                TAY
.1a2ca3	20 20 00	jsr $1a0020	            JSR CURSORXY
.1a2ca6	28		plp		                PLP
.1a2ca7	7a		ply		                PLY
.1a2ca8	fa		plx		                PLX
.1a2ca9	60		rts		            RTS
>1a2caa	80 02 20 03 40 01 90 01		gr_columns      .word 640,800,320,400
>1a2cb2	e0 01 58 02 f0 00 2c 01		gr_rows         .word 480,600,240,300
>1a2cba	50 00 64 00 28 00 32 00		col_count       .word 80,100,40,50
>1a2cc2	3c 00 4b 00 1e 00 32 00		row_count       .word 60,75,30,50
>1a2cca	48 00 5c 00 20 00 2a 00		colb_count      .word 72,92,32,42
>1a2cd2	34 00 43 00 16 00 34 00		rowb_count      .word 52,67,22,52
.1a2cda					BITMAP_SRAM
.1a2cda	da		phx		                PHX
.1a2cdb	08		php		                PHP
.1a2cdc	c2 30		rep #$30	            REP #$30
.1a2cde	c9 02 00	cmp #$0002	                CMP #BM_MAX
.1a2ce1	b0 1c		bcs $1a2cff	                BGE range_err           ; Make sure it's within range
.1a2ce3	0a		asl a		                ASL A
.1a2ce4	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.1a2ce5	aa		tax		                TAX
.1a2ce6	bf 00 f0 1a	lda $1af000,x	                LDA @l GR_BM0_ADDR,X    ; Get the low 16-bits of the address
.1a2cea	85 9e		sta $089e	                STA MTEMPPTR
.1a2cec	bf 02 f0 1a	lda $1af002,x	                LDA @l GR_BM0_ADDR+2,X  ; Get the high bits of the address
.1a2cf0	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a2cf2	c9 f0 00	cmp #$00f0	                CMP #MAX_VRAM_CPU       ; Check to make sure address is within VRAM
.1a2cf5	b0 08		bcs $1a2cff	                BGE range_err
.1a2cf7	c9 b0 00	cmp #$00b0	                CMP #MIN_VRAM_CPU
.1a2cfa	90 03		bcc $1a2cff	                BLT range_err
.1a2cfc	28		plp		                PLP
.1a2cfd	fa		plx		                PLX
.1a2cfe	60		rts		            RTS
.1a2cff					range_err
.1a2cff	08		php		            PHP
.1a2d00	c2 20		rep #$20	            REP #$20
.1a2d02	48		pha		            PHA
.1a2d03	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2d06	5b		tcd		            TCD
.1a2d07	68		pla		            PLA
.1a2d08	28		plp		            PLP
.1a2d09	e2 20		sep #$20	            SEP #$20
.1a2d0b	a9 09		lda #$09	            LDA #ERR_RANGE
.1a2d0d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2d11	c2 20		rep #$20	            REP #$20
.1a2d13	29 ff 00	and #$00ff	            AND #$00FF
.1a2d16	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a2d19	e2 20		sep #$20	            SEP #$20
.1a2d1b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2d1e					BITMAP_VRAM
.1a2d1e	da		phx		                PHX
.1a2d1f	08		php		                PHP
.1a2d20	c2 30		rep #$30	            REP #$30
.1a2d22	c9 02 00	cmp #$0002	                CMP #BM_MAX
.1a2d25	b0 17		bcs $1a2d3e	                BGE range_err           ; Make sure it's within range
.1a2d27	0a		asl a		                ASL A
.1a2d28	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.1a2d29	aa		tax		                TAX
.1a2d2a	bf 08 f0 1a	lda $1af008,x	                LDA @l GR_BM0_VRAM,X    ; Get the low 16-bits of the address
.1a2d2e	85 9e		sta $089e	                STA MTEMPPTR
.1a2d30	bf 0a f0 1a	lda $1af00a,x	                LDA @l GR_BM0_VRAM+2,X  ; Get the high bits of the address
.1a2d34	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a2d36	c9 40 00	cmp #$0040	                CMP #MAX_VRAM_VICKY     ; Check to make sure the address is from $00:0000 - $3F:FFFF
.1a2d39	b0 03		bcs $1a2d3e	                BGE range_err           ; If not, throw a range error
.1a2d3b	28		plp		                PLP
.1a2d3c	fa		plx		                PLX
.1a2d3d	60		rts		            RTS
.1a2d3e					range_err
.1a2d3e	08		php		            PHP
.1a2d3f	c2 20		rep #$20	            REP #$20
.1a2d41	48		pha		            PHA
.1a2d42	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2d45	5b		tcd		            TCD
.1a2d46	68		pla		            PLA
.1a2d47	28		plp		            PLP
.1a2d48	e2 20		sep #$20	            SEP #$20
.1a2d4a	a9 09		lda #$09	            LDA #ERR_RANGE
.1a2d4c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2d50	c2 20		rep #$20	            REP #$20
.1a2d52	29 ff 00	and #$00ff	            AND #$00FF
.1a2d55	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a2d58	e2 20		sep #$20	            SEP #$20
.1a2d5a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2d5d					S_BITMAP
.1a2d5d	08		php		                PHP
.1a2d5e					locals
>0001					L_PLANE         .word ?
>0003					L_VISIBLE       .byte ?
>0004					L_ADDRESS       .dword ?
.1a2d5e	c2 30		rep #$30	            REP #$30
.1a2d60	3b		tsc		                TSC                         ; Allocate space for the locals on the stack
.1a2d61	38		sec		                SEC
.1a2d62	e9 07 00	sbc #$0007	                SBC #SIZE(locals)
.1a2d65	1b		tcs		                TCS
.1a2d66	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2d69	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2d6c	c2 20		rep #$20	            REP #$20
.1a2d6e	a5 23		lda $0823	                LDA ARGUMENT1               ; Make sure it's in range
.1a2d70	c9 02 00	cmp #$0002	                CMP #BM_MAX
.1a2d73	b0 59		bcs $1a2dce	                BGE range_err               ; If not, throw an error
.1a2d75	83 01		sta $01,s	                STA L_PLANE                 ; If so, save it to MARG1
.1a2d77	e2 20		sep #$20	            SEP #$20
.1a2d79	a9 2c		lda #$2c	                LDA #','
.1a2d7b	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a2d7e	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2d81	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2d84	a5 23		lda $0823	                LDA ARGUMENT1
.1a2d86	83 03		sta $03,s	                STA L_VISIBLE
.1a2d88	a9 2c		lda #$2c	                LDA #','
.1a2d8a	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a2d8d	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2d90	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2d93	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the number back
.1a2d95	0a		asl a		                ASL A                       ; Multiply by 8 to get the offset to the registers
.1a2d96	0a		asl a		                ASL A
.1a2d97	0a		asl a		                ASL A
.1a2d98	aa		tax		                TAX                         ; And save that offset to X
.1a2d99	a3 03		lda $03,s	                LDA L_VISIBLE               ; Check the visible flag
.1a2d9b	d0 05		bne $1a2da2	                BNE is_visible              ; If <> 0, it's visible
.1a2d9d	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the LUT #
.1a2d9f	0a		asl a		                ASL A                       ; Shift it into position for the register
.1a2da0	80 04		bra $1a2da6	                BRA wr_bm_reg               ; And go to write it
.1a2da2	a5 23		lda $0823	is_visible      LDA ARGUMENT1               ; Get the LUT #
.1a2da4	38		sec		                SEC
.1a2da5	2a		rol a		                ROL A                       ; And shift it into position, and set enable bit
.1a2da6	9f 00 01 af	sta $af0100,x	wr_bm_reg       STA @l BM0_CONTROL_REG,X    ; Write to the bitmap control register
.1a2daa	c2 20		rep #$20	            REP #$20
.1a2dac	a9 2c 00	lda #$002c	                LDA #','
.1a2daf	85 37		sta $0837	                STA TARGETTOK
.1a2db1	20 d9 20	jsr $1a20d9	            JSR OPT_TOK
.1a2db4	b0 37		bcs $1a2ded	                BCS get_address             ; Yes: parse the address
.1a2db6	c2 20		rep #$20	            REP #$20
.1a2db8	08		php		            PHP
.1a2db9	c2 20		rep #$20	            REP #$20
.1a2dbb	a9 00 00	lda #$0000	            LDA #<>VRAM
.1a2dbe	85 23		sta $0823	            STA ARGUMENT1
.1a2dc0	a9 b0 00	lda #$00b0	            LDA #(VRAM >> 16)
.1a2dc3	85 25		sta $0825	            STA ARGUMENT1+2
.1a2dc5	e2 20		sep #$20	            SEP #$20
.1a2dc7	a9 00		lda #$00	            LDA #TYPE_INTEGER
.1a2dc9	85 27		sta $0827	            STA ARGUMENT1+4
.1a2dcb	28		plp		            PLP
.1a2dcc	80 27		bra $1a2df5	                BRA set_address
.1a2dce					range_err
.1a2dce	08		php		            PHP
.1a2dcf	c2 20		rep #$20	            REP #$20
.1a2dd1	48		pha		            PHA
.1a2dd2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2dd5	5b		tcd		            TCD
.1a2dd6	68		pla		            PLA
.1a2dd7	28		plp		            PLP
.1a2dd8	e2 20		sep #$20	            SEP #$20
.1a2dda	a9 09		lda #$09	            LDA #ERR_RANGE
.1a2ddc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2de0	c2 20		rep #$20	            REP #$20
.1a2de2	29 ff 00	and #$00ff	            AND #$00FF
.1a2de5	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a2de8	e2 20		sep #$20	            SEP #$20
.1a2dea	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2ded					get_address
.1a2ded	c2 20		rep #$20	            REP #$20
.1a2def	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a2df2	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2df5					set_address
.1a2df5	c2 20		rep #$20	            REP #$20
.1a2df7	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.1a2df9	0a		asl a		                ASL A                       ; Multiply by four to get the offset to the address variable
.1a2dfa	0a		asl a		                ASL A
.1a2dfb	aa		tax		                TAX                         ; And put it in X
.1a2dfc	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the CPU-space address
.1a2dfe	9f 00 f0 1a	sta $1af000,x	                STA @l GR_BM0_ADDR,X        ; And save it to the correct GR_BM?_ADDR variable
.1a2e02	9f 08 f0 1a	sta $1af008,x	                STA @l GR_BM0_VRAM,X
.1a2e06	83 04		sta $04,s	                STA L_ADDRESS               ; And L_ADDRESS, temporarily
.1a2e08	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a2e0a	9f 02 f0 1a	sta $1af002,x	                STA @l GR_BM0_ADDR+2,X
.1a2e0e	38		sec		                SEC
.1a2e0f	e9 b0 00	sbc #$00b0	                SBC #`VRAM                  ; Rebase the upper half of the address to Vicky memory space
.1a2e12	9f 0a f0 1a	sta $1af00a,x	                STA @l GR_BM0_VRAM+2,X
.1a2e16	83 06		sta $06,s	                STA L_ADDRESS+2             ; And to L_ADDRESS
.1a2e18	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.1a2e1a	0a		asl a		                ASL A                       ; Multiply by eight to get the offset to the registers
.1a2e1b	0a		asl a		                ASL A
.1a2e1c	0a		asl a		                ASL A
.1a2e1d	aa		tax		                TAX                         ; And put it in X
.1a2e1e	e2 20		sep #$20	            SEP #$20
.1a2e20	a3 04		lda $04,s	                LDA L_ADDRESS               ; Get the address in Vicky space...
.1a2e22	9f 01 01 af	sta $af0101,x	                STA @l BM0_START_ADDY_L,X   ; Save it to the Vicky registers
.1a2e26	a3 05		lda $05,s	                LDA L_ADDRESS+1
.1a2e28	9f 02 01 af	sta $af0102,x	                STA @l BM0_START_ADDY_M,X
.1a2e2c	a3 06		lda $06,s	                LDA L_ADDRESS+2
.1a2e2e	9f 03 01 af	sta $af0103,x	                STA @l BM0_START_ADDY_H,X
.1a2e32	a9 00		lda #$00	                LDA #0                      ; Default offset to (0, 0)
.1a2e34	9f 04 01 af	sta $af0104,x	                STA @l BM0_X_OFFSET,X
.1a2e38	9f 05 01 af	sta $af0105,x	                STA @l BM0_Y_OFFSET,X
.1a2e3c	c2 30		rep #$30	            REP #$30
.1a2e3e	3b		tsc		                TSC                         ; Remove the space for the locals from the stack
.1a2e3f	18		clc		                CLC
.1a2e40	69 07 00	adc #$0007	                ADC #SIZE(locals)
.1a2e43	1b		tcs		                TCS
.1a2e44	28		plp		                PLP
.1a2e45	60		rts		            RTS
.1a2e46					bad_address
.1a2e46	08		php		            PHP
.1a2e47	c2 20		rep #$20	            REP #$20
.1a2e49	48		pha		            PHA
.1a2e4a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2e4d	5b		tcd		            TCD
.1a2e4e	68		pla		            PLA
.1a2e4f	28		plp		            PLP
.1a2e50	e2 20		sep #$20	            SEP #$20
.1a2e52	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a2e54	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2e58	c2 20		rep #$20	            REP #$20
.1a2e5a	29 ff 00	and #$00ff	            AND #$00FF
.1a2e5d	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a2e60	e2 20		sep #$20	            SEP #$20
.1a2e62	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2e65					S_CLRBITMAP
.1a2e65	08		php		                PHP
.1a2e66	c2 20		rep #$20	            REP #$20
.1a2e68	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2e6b	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2e6e	a5 23		lda $0823	                LDA ARGUMENT1
.1a2e70	20 1e 2d	jsr $1a2d1e	            JSR BITMAP_VRAM
.1a2e73	c2 20		rep #$20	            REP #$20
.1a2e75	a5 9e		lda $089e	                LDA MTEMPPTR                ; Set the start address and the # of pixels to write
.1a2e77	8f 05 04 af	sta $af0405	                STA @lVDMA_DST_ADDY_L
.1a2e7b	af 14 f0 1a	lda $1af014	                LDA @lGR_TOTAL_PIXELS       ; Set the size
.1a2e7f	8f 08 04 af	sta $af0408	                STA @lVDMA_SIZE_L
.1a2e83	e2 20		sep #$20	            SEP #$20
.1a2e85	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.1a2e87	8f 07 04 af	sta $af0407	                STA @lVDMA_DST_ADDY_H
.1a2e8b	af 16 f0 1a	lda $1af016	                LDA @lGR_TOTAL_PIXELS+2
.1a2e8f	8f 0a 04 af	sta $af040a	                STA @lVDMA_SIZE_H
.1a2e93	a9 00		lda #$00	                LDA #0                      ; Set the color to write
.1a2e95	8f 01 04 af	sta $af0401	                STA @lVDMA_BYTE_2_WRITE
.1a2e99	a9 85		lda #$85	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_Start_TRF
.1a2e9b	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.1a2e9f	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.1a2ea3	30 fa		bmi $1a2e9f	                BMI wait
.1a2ea5	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.1a2ea7	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.1a2eab	28		plp		done            PLP
.1a2eac	60		rts		            RTS
=$000855				COLOR = MARG1
=$000859				X0 = MARG2
=$00085d				Y0 = MARG3
=$000861				X1 = MARG4
=$000865				Y1 = MARG5
=$000869				DX = MARG6
=$00086d				DY = MARG7
=$000871				ERR = MARG8
=$000875				ERR2 = MARG9
>08dd					SX      .word ?
>08df					SY      .word ?
.1a2ead					PLOT
.1a2ead	08		php		                PHP
.1a2eae	c2 20		rep #$20	            REP #$20
.1a2eb0	a5 5d		lda $085d	                LDA Y0                      ; Get the row
.1a2eb2	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.1a2eb6	af 10 f0 1a	lda $1af010	                LDA @lGR_MAX_COLS
.1a2eba	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B          ; Multiply by the number of columns in the pixmap
.1a2ebe	18		clc		                CLC                         ; Add the column
.1a2ebf	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT
.1a2ec3	65 59		adc $0859	                ADC X0
.1a2ec5	85 0c		sta $080c	                STA SCRATCH
.1a2ec7	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.1a2ecb	69 00 00	adc #$0000	                ADC #0
.1a2ece	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH is offset of pixel in the pixmap
.1a2ed0	18		clc		                CLC                         ; Add the address of the first pixel
.1a2ed1	a5 0c		lda $080c	                LDA SCRATCH
.1a2ed3	65 9e		adc $089e	                ADC MTEMPPTR
.1a2ed5	85 0c		sta $080c	                STA SCRATCH
.1a2ed7	a5 0e		lda $080e	                LDA SCRATCH+2
.1a2ed9	65 a0		adc $08a0	                ADC MTEMPPTR+2
.1a2edb	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH := pixmap + pixel offset
.1a2edd	e2 20		sep #$20	            SEP #$20
.1a2edf	a5 55		lda $0855	                LDA COLOR                   ; Get the color
.1a2ee1	87 0c		sta [$080c]	                STA [SCRATCH]               ; And write the color to the pixel
.1a2ee3	28		plp		                PLP
.1a2ee4	60		rts		            RTS
.1a2ee5					LINE
.1a2ee5	c2 20		rep #$20	            REP #$20
.1a2ee7	a9 01 00	lda #$0001	                LDA #1                      ; Assume SX = 1
.1a2eea	85 dd		sta $08dd	                STA SX
.1a2eec	38		sec		                SEC                         ; DX := ABS(X1 - X0)
.1a2eed	a5 61		lda $0861	                LDA X1
.1a2eef	e5 59		sbc $0859	                SBC X0
.1a2ef1	85 69		sta $0869	                STA DX
.1a2ef3	10 0b		bpl $1a2f00	                BPL abs_Y                   ; If DX < 0 {
.1a2ef5	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DX := -DX
.1a2ef8	1a		inc a		                INC A
.1a2ef9	85 69		sta $0869	                STA DX
.1a2efb	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SX := -1
.1a2efe	85 dd		sta $08dd	                STA SX                      ; }
.1a2f00	a9 01 00	lda #$0001	abs_Y           LDA #1                      ; Assume SY = 1
.1a2f03	85 df		sta $08df	                STA SY
.1a2f05	38		sec		                SEC                         ; DY := ABS(Y1 - Y0)
.1a2f06	a5 65		lda $0865	                LDA Y1
.1a2f08	e5 5d		sbc $085d	                SBC Y0
.1a2f0a	85 6d		sta $086d	                STA DY
.1a2f0c	10 0b		bpl $1a2f19	                BPL calc_ERR                ; If DY < 0 {
.1a2f0e	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DY := -DY
.1a2f11	1a		inc a		                INC A
.1a2f12	85 6d		sta $086d	                STA DY
.1a2f14	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SY := -1
.1a2f17	85 df		sta $08df	                STA SY                      ; }
.1a2f19	a5 6d		lda $086d	calc_ERR        LDA DY                      ; (DY < DX)
.1a2f1b	c5 69		cmp $0869	                CMP DX
.1a2f1d	b0 04		bcs $1a2f23	                BGE else
.1a2f1f	a5 69		lda $0869	                LDA DX                      ; TRUE CASE: ERR := DX
.1a2f21	80 06		bra $1a2f29	                BRA shiftERR
.1a2f23	a5 6d		lda $086d	else            LDA DY                      ; FALSE CASE: ERR := -DY
.1a2f25	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a2f28	1a		inc a		                INC A
.1a2f29	48		pha		shiftERR        PHA
.1a2f2a	0a		asl a		                ASL A
.1a2f2b	68		pla		                PLA
.1a2f2c	6a		ror a		                ROR A                       ; ERR := ERR / 2
.1a2f2d	85 71		sta $0871	                STA ERR
.1a2f2f					loop
.1a2f2f	20 ad 2e	jsr $1a2ead	            JSR PLOT
.1a2f32	a5 59		lda $0859	                LDA X0                      ; break if X0=X1 and Y0=Y1
.1a2f34	c5 61		cmp $0861	                CMP X1
.1a2f36	d0 06		bne $1a2f3e	                BNE calc_ERR2
.1a2f38	a5 5d		lda $085d	                LDA Y0
.1a2f3a	c5 65		cmp $0865	                CMP Y1
.1a2f3c	f0 36		beq $1a2f74	                BEQ done
.1a2f3e	a5 71		lda $0871	calc_ERR2       LDA ERR                     ; ERR2 := ERR
.1a2f40	85 75		sta $0875	                STA ERR2
.1a2f42	a5 69		lda $0869	                LDA DX                      ; if (ERR2 > -DX) {
.1a2f44	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a2f47	1a		inc a		                INC A
.1a2f48	c5 75		cmp $0875	                CMP ERR2
.1a2f4a	10 10		bpl $1a2f5c	                BPL check_DY
.1a2f4c	f0 0e		beq $1a2f5c	                BEQ check_DY
.1a2f4e	38		sec		                SEC                         ; ERR -= DY
.1a2f4f	a5 71		lda $0871	                LDA ERR
.1a2f51	e5 6d		sbc $086d	                SBC DY
.1a2f53	85 71		sta $0871	                STA ERR
.1a2f55	18		clc		                CLC                         ; X0 += SX
.1a2f56	a5 59		lda $0859	                LDA X0
.1a2f58	65 dd		adc $08dd	                ADC SX
.1a2f5a	85 59		sta $0859	                STA X0                      ; }
.1a2f5c	a5 75		lda $0875	check_DY        LDA ERR2                    ; if (ERR2 < DY) {
.1a2f5e	c5 6d		cmp $086d	                CMP DY
.1a2f60	10 cd		bpl $1a2f2f	                BPL loop
.1a2f62	f0 cb		beq $1a2f2f	                BEQ loop
.1a2f64	18		clc		                CLC                         ; ERR += DX
.1a2f65	a5 71		lda $0871	                LDA ERR
.1a2f67	65 69		adc $0869	                ADC DX
.1a2f69	85 71		sta $0871	                STA ERR
.1a2f6b	18		clc		                CLC                         ; Y0 += SY
.1a2f6c	a5 5d		lda $085d	                LDA Y0
.1a2f6e	65 df		adc $08df	                ADC SY
.1a2f70	85 5d		sta $085d	                STA Y0                      ; }
.1a2f72	80 bb		bra $1a2f2f	                BRA loop                    ; }
.1a2f74					done
.1a2f74	60		rts		            RTS
.1a2f75					S_PLOT
.1a2f75	08		php		                PHP
.1a2f76					locals
>0001					L_PLANE         .word ?
>0003					L_X             .word ?
>0005					L_Y             .word ?
.1a2f76	c2 20		rep #$20	            REP #$20
.1a2f78	3b		tsc		            TSC
.1a2f79	38		sec		            SEC
.1a2f7a	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.1a2f7d	1b		tcs		            TCS
.1a2f7e	08		php		            PHP
.1a2f7f	c2 20		rep #$20	            REP #$20
.1a2f81	48		pha		            PHA
.1a2f82	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2f85	5b		tcd		            TCD
.1a2f86	68		pla		            PLA
.1a2f87	28		plp		            PLP
.1a2f88	08		php		            PHP
.1a2f89	e2 20		sep #$20	            SEP #$20
.1a2f8b	48		pha		            PHA
.1a2f8c	a9 00		lda #$00	            LDA #0
.1a2f8e	48		pha		            PHA
.1a2f8f	ab		plb		            PLB
.1a2f90	68		pla		            PLA
.1a2f91	28		plp		            PLP
.1a2f92	c2 30		rep #$30	            REP #$30
.1a2f94	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2f97	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2f9a	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.1a2f9c	a9 2c 00	lda #$002c	                LDA #','
.1a2f9f	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a2fa2	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2fa5	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a2fa8	a5 23		lda $0823	                LDA ARGUMENT1
.1a2faa	83 03		sta $03,s	                STA L_X                     ; Save it to X
.1a2fac	a9 2c 00	lda #$002c	                LDA #','
.1a2faf	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a2fb2	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2fb5	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a2fb8	a5 23		lda $0823	                LDA ARGUMENT1
.1a2fba	83 05		sta $05,s	                STA L_Y                     ; Save it to Y
.1a2fbc	a9 2c 00	lda #$002c	                LDA #','
.1a2fbf	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a2fc2	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a2fc5	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a2fc8	a5 23		lda $0823	                LDA ARGUMENT1
.1a2fca	85 55		sta $0855	                STA COLOR                   ; Save it to MARG1
.1a2fcc	a3 03		lda $03,s	                LDA L_X                     ; Set the (X0, Y0) coordinates
.1a2fce	85 59		sta $0859	                STA X0
.1a2fd0	a3 05		lda $05,s	                LDA L_Y
.1a2fd2	85 5d		sta $085d	                STA Y0
.1a2fd4	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.1a2fd6	20 da 2c	jsr $1a2cda	            JSR BITMAP_SRAM
.1a2fd9	20 ad 2e	jsr $1a2ead	            JSR PLOT
.1a2fdc	c2 20		rep #$20	            REP #$20
.1a2fde	3b		tsc		            TSC
.1a2fdf	18		clc		            CLC
.1a2fe0	69 06 00	adc #$0006	            ADC #SIZE(locals)
.1a2fe3	1b		tcs		            TCS
.1a2fe4	28		plp		                PLP
.1a2fe5	60		rts		            RTS
.1a2fe6					S_LINE
.1a2fe6	08		php		                PHP
.1a2fe7					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
.1a2fe7	c2 20		rep #$20	            REP #$20
.1a2fe9	3b		tsc		            TSC
.1a2fea	38		sec		            SEC
.1a2feb	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.1a2fee	1b		tcs		            TCS
.1a2fef	08		php		            PHP
.1a2ff0	c2 20		rep #$20	            REP #$20
.1a2ff2	48		pha		            PHA
.1a2ff3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2ff6	5b		tcd		            TCD
.1a2ff7	68		pla		            PLA
.1a2ff8	28		plp		            PLP
.1a2ff9	08		php		            PHP
.1a2ffa	e2 20		sep #$20	            SEP #$20
.1a2ffc	48		pha		            PHA
.1a2ffd	a9 00		lda #$00	            LDA #0
.1a2fff	48		pha		            PHA
.1a3000	ab		plb		            PLB
.1a3001	68		pla		            PLA
.1a3002	28		plp		            PLP
.1a3003	c2 30		rep #$30	            REP #$30
.1a3005	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3008	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a300b	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.1a300d	a9 2c 00	lda #$002c	                LDA #','
.1a3010	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3013	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3016	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a3019	a5 23		lda $0823	                LDA ARGUMENT1
.1a301b	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.1a301d	a9 2c 00	lda #$002c	                LDA #','
.1a3020	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3023	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3026	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a3029	a5 23		lda $0823	                LDA ARGUMENT1
.1a302b	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.1a302d	a9 2c 00	lda #$002c	                LDA #','
.1a3030	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3033	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3036	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a3039	a5 23		lda $0823	                LDA ARGUMENT1
.1a303b	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.1a303d	a9 2c 00	lda #$002c	                LDA #','
.1a3040	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3043	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3046	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a3049	a5 23		lda $0823	                LDA ARGUMENT1
.1a304b	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.1a304d	a9 2c 00	lda #$002c	                LDA #','
.1a3050	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3053	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3056	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a3059	a5 23		lda $0823	                LDA ARGUMENT1
.1a305b	85 55		sta $0855	                STA COLOR                   ; Save it to COLOR
.1a305d	a3 03		lda $03,s	                LDA L_X0                    ; Set the (X0, Y0) coordinates
.1a305f	85 59		sta $0859	                STA X0
.1a3061	a3 05		lda $05,s	                LDA L_Y0
.1a3063	85 5d		sta $085d	                STA Y0
.1a3065	a3 07		lda $07,s	                LDA L_X1                    ; Set the (X1, Y1) coordinates
.1a3067	85 61		sta $0861	                STA X1
.1a3069	a3 09		lda $09,s	                LDA L_Y1
.1a306b	85 65		sta $0865	                STA Y1
.1a306d	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.1a306f	20 da 2c	jsr $1a2cda	            JSR BITMAP_SRAM
.1a3072	20 e5 2e	jsr $1a2ee5	            JSR LINE
.1a3075					done
.1a3075	c2 20		rep #$20	            REP #$20
.1a3077	3b		tsc		            TSC
.1a3078	18		clc		            CLC
.1a3079	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.1a307c	1b		tcs		            TCS
.1a307d	28		plp		                PLP
.1a307e	60		rts		            RTS
.1a307f					S_FILL
.1a307f	08		php		                PHP
.1a3080					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
>000b					L_COLOR         .word ?
.1a3080	c2 20		rep #$20	            REP #$20
.1a3082	3b		tsc		            TSC
.1a3083	38		sec		            SEC
.1a3084	e9 0c 00	sbc #$000c	            SBC #SIZE(locals)
.1a3087	1b		tcs		            TCS
.1a3088	08		php		            PHP
.1a3089	c2 20		rep #$20	            REP #$20
.1a308b	48		pha		            PHA
.1a308c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a308f	5b		tcd		            TCD
.1a3090	68		pla		            PLA
.1a3091	28		plp		            PLP
.1a3092	08		php		            PHP
.1a3093	e2 20		sep #$20	            SEP #$20
.1a3095	48		pha		            PHA
.1a3096	a9 00		lda #$00	            LDA #0
.1a3098	48		pha		            PHA
.1a3099	ab		plb		            PLB
.1a309a	68		pla		            PLA
.1a309b	28		plp		            PLP
.1a309c	c2 30		rep #$30	            REP #$30
.1a309e	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a30a1	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a30a4	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.1a30a6	a9 2c 00	lda #$002c	                LDA #','
.1a30a9	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a30ac	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a30af	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a30b2	a5 23		lda $0823	                LDA ARGUMENT1
.1a30b4	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.1a30b6	a9 2c 00	lda #$002c	                LDA #','
.1a30b9	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a30bc	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a30bf	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a30c2	a5 23		lda $0823	                LDA ARGUMENT1
.1a30c4	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.1a30c6	a9 2c 00	lda #$002c	                LDA #','
.1a30c9	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a30cc	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a30cf	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a30d2	a5 23		lda $0823	                LDA ARGUMENT1
.1a30d4	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.1a30d6	a9 2c 00	lda #$002c	                LDA #','
.1a30d9	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a30dc	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a30df	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a30e2	a5 23		lda $0823	                LDA ARGUMENT1
.1a30e4	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.1a30e6	a9 2c 00	lda #$002c	                LDA #','
.1a30e9	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a30ec	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a30ef	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a30f2	a5 23		lda $0823	                LDA ARGUMENT1
.1a30f4	83 0b		sta $0b,s	                STA L_COLOR                 ; Save it to COLOR
.1a30f6	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.1a30f8	20 1e 2d	jsr $1a2d1e	            JSR BITMAP_VRAM
.1a30fb	a9 07 00	lda #$0007	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_1D_2D
.1a30fe	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a3102	c2 20		rep #$20	            REP #$20
.1a3104	a3 05		lda $05,s	                LDA L_Y0                    ; Get the row
.1a3106	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.1a310a	af 10 f0 1a	lda $1af010	                LDA @l GR_MAX_COLS
.1a310e	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B         ; Multiply by the number of columns in the pixmap
.1a3112	18		clc		                CLC                         ; Add the column
.1a3113	af 04 01 00	lda $000104	                LDA @l M0_RESULT
.1a3117	63 03		adc $03,s	                ADC L_X0
.1a3119	85 0c		sta $080c	                STA SCRATCH
.1a311b	e2 20		sep #$20	            SEP #$20
.1a311d	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.1a3121	69 00		adc #$00	                ADC #0
.1a3123	85 0e		sta $080e	                STA SCRATCH+2
.1a3125	c2 20		rep #$20	            REP #$20
.1a3127	18		clc		                CLC                         ; Set the destination address
.1a3128	a5 9e		lda $089e	                LDA MTEMPPTR
.1a312a	65 0c		adc $080c	                ADC SCRATCH
.1a312c	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.1a3130	e2 20		sep #$20	            SEP #$20
.1a3132	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.1a3134	65 0e		adc $080e	                ADC SCRATCH+2
.1a3136	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H
.1a313a	c2 20		rep #$20	            REP #$20
.1a313c	38		sec		                SEC                         ; Set the width of the FILL operation
.1a313d	a3 07		lda $07,s	                LDA L_X1
.1a313f	e3 03		sbc $03,s	                SBC L_X0
.1a3141	85 0c		sta $080c	                STA SCRATCH
.1a3143	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.1a3147	38		sec		                SEC
.1a3148	af 10 f0 1a	lda $1af010	                LDA @l GR_MAX_COLS
.1a314c	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L    ; And the destination stride
.1a3150	38		sec		                SEC                         ; Set the height of the FILL operation
.1a3151	a3 09		lda $09,s	                LDA L_Y1
.1a3153	e3 05		sbc $05,s	                SBC L_Y0
.1a3155	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.1a3159	e2 20		sep #$20	            SEP #$20
.1a315b	a3 0b		lda $0b,s	                LDA L_COLOR                 ; Set the color to write
.1a315d	8f 01 04 af	sta $af0401	                STA @l VDMA_BYTE_2_WRITE
.1a3161	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.1a3165	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF
.1a3167	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a316b	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.1a316f	30 fa		bmi $1a316b	                BMI wait
.1a3171	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.1a3173	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a3177					done
.1a3177	c2 20		rep #$20	            REP #$20
.1a3179	3b		tsc		            TSC
.1a317a	18		clc		            CLC
.1a317b	69 0c 00	adc #$000c	            ADC #SIZE(locals)
.1a317e	1b		tcs		            TCS
.1a317f	28		plp		                PLP
.1a3180	60		rts		            RTS
.1a3181					SPADDR
.1a3181	08		php		                PHP
.1a3182	c2 20		rep #$20	            REP #$20
.1a3184	c9 40 00	cmp #$0040	                CMP #SP_MAX
.1a3187	b0 13		bcs $1a319c	                BGE error
.1a3189	0a		asl a		                ASL A                       ; Multiply it by 8 (the size of s sprite block)
.1a318a	0a		asl a		                ASL A
.1a318b	0a		asl a		                ASL A
.1a318c	18		clc		                CLC                         ; Add it to the address of the first
.1a318d	69 00 0c	adc #$0c00	                ADC #<>SP00_CONTROL_REG     ; sprite block
.1a3190	85 9e		sta $089e	                STA MTEMPPTR
.1a3192	a9 af 00	lda #$00af	                LDA #`SP00_CONTROL_REG
.1a3195	69 00 00	adc #$0000	                ADC #0
.1a3198	85 a0		sta $08a0	                STA MTEMPPTR+2              ; And save that to MTEMPPTR
.1a319a	28		plp		                PLP
.1a319b	60		rts		            RTS
.1a319c					error
.1a319c	08		php		            PHP
.1a319d	c2 20		rep #$20	            REP #$20
.1a319f	48		pha		            PHA
.1a31a0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a31a3	5b		tcd		            TCD
.1a31a4	68		pla		            PLA
.1a31a5	28		plp		            PLP
.1a31a6	e2 20		sep #$20	            SEP #$20
.1a31a8	a9 09		lda #$09	            LDA #ERR_RANGE
.1a31aa	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a31ae	c2 20		rep #$20	            REP #$20
.1a31b0	29 ff 00	and #$00ff	            AND #$00FF
.1a31b3	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a31b6	e2 20		sep #$20	            SEP #$20
.1a31b8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a31bb					S_SPRITE
.1a31bb	08		php		                PHP
.1a31bc					locals
>0001					L_SPRITE        .word ?
>0003					L_LUT           .byte ?
.1a31bc	c2 20		rep #$20	            REP #$20
.1a31be	3b		tsc		            TSC
.1a31bf	38		sec		            SEC
.1a31c0	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.1a31c3	1b		tcs		            TCS
.1a31c4	c2 30		rep #$30	            REP #$30
.1a31c6	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a31c9	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a31cc	a5 23		lda $0823	                LDA ARGUMENT1
.1a31ce	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.1a31d0	a9 2c 00	lda #$002c	                LDA #','
.1a31d3	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a31d6	e2 20		sep #$20	            SEP #$20
.1a31d8	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a31db	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a31de	a5 23		lda $0823	                LDA ARGUMENT1
.1a31e0	c9 08		cmp #$08	                CMP #GR_MAX_LUT             ; Check that it's in range
.1a31e2	b0 56		bcs $1a323a	                BGE error                   ; If not: throw an error
.1a31e4	83 03		sta $03,s	                STA L_LUT                   ; Save it as lut
.1a31e6	a9 2c		lda #$2c	                LDA #','
.1a31e8	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a31eb	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a31ee	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a31f1	c2 20		rep #$20	            REP #$20
.1a31f3	38		sec		                SEC                         ; Adjust address to be in Vicky's space
.1a31f4	a5 23		lda $0823	                LDA ARGUMENT1
.1a31f6	e9 00 00	sbc #$0000	                SBC #<>VRAM
.1a31f9	85 23		sta $0823	                STA ARGUMENT1
.1a31fb	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a31fd	e9 b0 00	sbc #$00b0	                SBC #`VRAM
.1a3200	85 25		sta $0825	                STA ARGUMENT1+2
.1a3202	30 36		bmi $1a323a	                BMI error                   ; If negative, throw an error
.1a3204	c2 20		rep #$20	            REP #$20
.1a3206	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a3208	aa		tax		                TAX
.1a3209	20 81 31	jsr $1a3181	            JSR SPADDR
.1a320c	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the lower word of the address
.1a320e	a0 01 00	ldy #$0001	                LDY #SP_ADDR
.1a3211	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3213	e2 20		sep #$20	            SEP #$20
.1a3215	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3217	c8		iny		                INY
.1a3218	c8		iny		                INY
.1a3219	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save the upper byte of the address
.1a321b	bf 18 f0 1a	lda $1af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the sprite control register
.1a321f	29 f1		and #$f1	                AND #%11110001              ; Filter off the current LUT
.1a3221	85 0c		sta $080c	                STA SCRATCH
.1a3223	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT back
.1a3225	0a		asl a		                ASL A                       ; Sift it into the LUT position
.1a3226	29 0e		and #$0e	                AND #%00001110              ; Make sure we don't have anything wrong there
.1a3228	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with what's in the sprite's control
.1a322a	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the register's bits
.1a322c	9f 18 f0 1a	sta $1af018,x	                STA @l GS_SP_CONTROL,X      ; And the shadow register
.1a3230					done
.1a3230	c2 20		rep #$20	            REP #$20
.1a3232	3b		tsc		            TSC
.1a3233	18		clc		            CLC
.1a3234	69 03 00	adc #$0003	            ADC #SIZE(locals)
.1a3237	1b		tcs		            TCS
.1a3238	28		plp		                PLP
.1a3239	60		rts		            RTS
.1a323a					error
.1a323a	08		php		            PHP
.1a323b	c2 20		rep #$20	            REP #$20
.1a323d	48		pha		            PHA
.1a323e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3241	5b		tcd		            TCD
.1a3242	68		pla		            PLA
.1a3243	28		plp		            PLP
.1a3244	e2 20		sep #$20	            SEP #$20
.1a3246	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3248	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a324c	c2 20		rep #$20	            REP #$20
.1a324e	29 ff 00	and #$00ff	            AND #$00FF
.1a3251	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3254	e2 20		sep #$20	            SEP #$20
.1a3256	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3259					S_SPRITEAT
.1a3259	08		php		                PHP
.1a325a					locals
>0001					L_SPRITE        .word ?
>0003					L_X             .word ?
.1a325a	c2 20		rep #$20	            REP #$20
.1a325c	3b		tsc		            TSC
.1a325d	38		sec		            SEC
.1a325e	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.1a3261	1b		tcs		            TCS
.1a3262	c2 30		rep #$30	            REP #$30
.1a3264	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3267	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a326a	a5 23		lda $0823	                LDA ARGUMENT1
.1a326c	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.1a326e	a9 2c 00	lda #$002c	                LDA #','
.1a3271	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3274	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3277	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a327a	a5 23		lda $0823	                LDA ARGUMENT1
.1a327c	83 03		sta $03,s	                STA L_X                     ; Save it as X
.1a327e	a9 2c 00	lda #$002c	                LDA #','
.1a3281	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3284	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3287	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a328a	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a328c	20 81 31	jsr $1a3181	            JSR SPADDR
.1a328f	a3 03		lda $03,s	                LDA L_X                     ; Get the X coordinate
.1a3291	a0 04 00	ldy #$0004	                LDY #SP_X_COORD             ; Save the X coordinate for the sprite
.1a3294	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3296	a5 23		lda $0823	                LDA ARGUMENT1
.1a3298	a0 06 00	ldy #$0006	                LDY #SP_Y_COORD             ; Save the Y coordinate for the sprite
.1a329b	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a329d					done
.1a329d	c2 20		rep #$20	            REP #$20
.1a329f	3b		tsc		            TSC
.1a32a0	18		clc		            CLC
.1a32a1	69 04 00	adc #$0004	            ADC #SIZE(locals)
.1a32a4	1b		tcs		            TCS
.1a32a5	28		plp		                PLP
.1a32a6	60		rts		            RTS
.1a32a7					S_SPRITESHOW
.1a32a7	08		php		                PHP
.1a32a8					locals
>0001					L_SPRITE        .word ?
>0003					L_VISIBLE       .byte ?
.1a32a8	c2 20		rep #$20	            REP #$20
.1a32aa	3b		tsc		            TSC
.1a32ab	38		sec		            SEC
.1a32ac	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.1a32af	1b		tcs		            TCS
.1a32b0	c2 30		rep #$30	            REP #$30
.1a32b2	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a32b5	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a32b8	a5 23		lda $0823	                LDA ARGUMENT1
.1a32ba	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.1a32bc	a9 2c 00	lda #$002c	                LDA #','
.1a32bf	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a32c2	e2 20		sep #$20	            SEP #$20
.1a32c4	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a32c7	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a32ca	a5 23		lda $0823	                LDA ARGUMENT1
.1a32cc	d0 04		bne $1a32d2	                BNE is_visible
.1a32ce	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 0 (not visible)
.1a32d0	80 04		bra $1a32d6	                BRA chk_layer
.1a32d2	a9 01		lda #$01	is_visible      LDA #1
.1a32d4	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 1 (visible)
.1a32d6	a9 2c		lda #$2c	chk_layer       LDA #','
.1a32d8	85 37		sta $0837	                STA TARGETTOK
.1a32da	20 d9 20	jsr $1a20d9	            JSR OPT_TOK
.1a32dd	b0 20		bcs $1a32ff	                BCS get_layer               ; Yes: get the layer
.1a32df					no_layer
.1a32df	c2 30		rep #$30	            REP #$30
.1a32e1	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a32e3	aa		tax		                TAX
.1a32e4	20 81 31	jsr $1a3181	            JSR SPADDR
.1a32e7	e2 20		sep #$20	            SEP #$20
.1a32e9	bf 18 f0 1a	lda $1af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.1a32ed	29 fe		and #$fe	                AND #$FE                    ; Filter out the enable bit
.1a32ef	85 0c		sta $080c	                STA SCRATCH
.1a32f1	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.1a32f3	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.1a32f5	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.1a32f7	9f 18 f0 1a	sta $1af018,x	                STA @l GS_SP_CONTROL,X      ; And save it
.1a32fb	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; ... and to Vicky
.1a32fd	80 36		bra $1a3335	                BRA done
.1a32ff					get_layer
.1a32ff	c2 30		rep #$30	            REP #$30
.1a3301	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a3304	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3307	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a330a	a5 23		lda $0823	                LDA ARGUMENT1
.1a330c	c9 08 00	cmp #$0008	                CMP #8                      ; Make sure it's in range
.1a330f	b0 2e		bcs $1a333f	                BGE error                   ; If not, throw an out of range error
.1a3311	0a		asl a		                ASL A                       ; If it's ok... shift it into position
.1a3312	0a		asl a		                ASL A
.1a3313	0a		asl a		                ASL A
.1a3314	0a		asl a		                ASL A
.1a3315	85 0c		sta $080c	                STA SCRATCH                 ; And save it in SCRATCH
.1a3317	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a3319	aa		tax		                TAX
.1a331a	20 81 31	jsr $1a3181	            JSR SPADDR
.1a331d	e2 20		sep #$20	            SEP #$20
.1a331f	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.1a3321	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.1a3323	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.1a3325	85 0c		sta $080c	                STA SCRATCH
.1a3327	bf 18 f0 1a	lda $1af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.1a332b	29 8e		and #$8e	                AND #%10001110              ; Filter out the enable and layer bits
.1a332d	05 0c		ora $080c	                ORA SCRATCH                 ; Combine with the provided layer and enable
.1a332f	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the bits in Vicky
.1a3331	9f 18 f0 1a	sta $1af018,x	                STA @l GS_SP_CONTROL,X      ; And to the shadow registers
.1a3335					done
.1a3335	c2 20		rep #$20	            REP #$20
.1a3337	3b		tsc		            TSC
.1a3338	18		clc		            CLC
.1a3339	69 03 00	adc #$0003	            ADC #SIZE(locals)
.1a333c	1b		tcs		            TCS
.1a333d	28		plp		                PLP
.1a333e	60		rts		            RTS
.1a333f					error
.1a333f	08		php		            PHP
.1a3340	c2 20		rep #$20	            REP #$20
.1a3342	48		pha		            PHA
.1a3343	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3346	5b		tcd		            TCD
.1a3347	68		pla		            PLA
.1a3348	28		plp		            PLP
.1a3349	e2 20		sep #$20	            SEP #$20
.1a334b	a9 09		lda #$09	            LDA #ERR_RANGE
.1a334d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3351	c2 20		rep #$20	            REP #$20
.1a3353	29 ff 00	and #$00ff	            AND #$00FF
.1a3356	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3359	e2 20		sep #$20	            SEP #$20
.1a335b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a335e					TILESET_ADDR
.1a335e	08		php		                PHP
.1a335f	c2 20		rep #$20	            REP #$20
.1a3361	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.1a3364	b0 19		bcs $1a337f	                BGE out_of_range            ; If not, throw a range error
.1a3366	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.1a3369	a9 04 00	lda #$0004	                LDA #TILESET_REG_SIZE       ; Multiply it by the number of bytes in a tile set register set
.1a336c	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.1a336f	18		clc		                CLC                         ; Add to TILESET0_ADDY_L to get the final address
.1a3370	ad 04 01	lda $0104	                LDA @w M0_RESULT
.1a3373	69 80 02	adc #$0280	                ADC #<>TILESET0_ADDY_L
.1a3376	85 9e		sta $089e	                STA MTEMPPTR
.1a3378	a9 af 00	lda #$00af	                LDA #`TILESET0_ADDY_L
.1a337b	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a337d	28		plp		                PLP
.1a337e	60		rts		            RTS
.1a337f					out_of_range
.1a337f	08		php		            PHP
.1a3380	c2 20		rep #$20	            REP #$20
.1a3382	48		pha		            PHA
.1a3383	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3386	5b		tcd		            TCD
.1a3387	68		pla		            PLA
.1a3388	28		plp		            PLP
.1a3389	e2 20		sep #$20	            SEP #$20
.1a338b	a9 09		lda #$09	            LDA #ERR_RANGE
.1a338d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3391	c2 20		rep #$20	            REP #$20
.1a3393	29 ff 00	and #$00ff	            AND #$00FF
.1a3396	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3399	e2 20		sep #$20	            SEP #$20
.1a339b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a339e					TILEMAP_ADDR
.1a339e	08		php		                PHP
.1a339f	c2 20		rep #$20	            REP #$20
.1a33a1	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.1a33a4	b0 19		bcs $1a33bf	                BGE out_of_range            ; If not, throw a range error
.1a33a6	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.1a33a9	a9 0c 00	lda #$000c	                LDA #TILEMAP_REG_SIZE       ; Multiply it by the number of bytes in a tile map register set
.1a33ac	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.1a33af	18		clc		                CLC
.1a33b0	ad 04 01	lda $0104	                LDA @w M0_RESULT            ; Add to TL0_CONTROL_REG to get the final address
.1a33b3	69 00 02	adc #$0200	                ADC #<>TL0_CONTROL_REG
.1a33b6	85 9e		sta $089e	                STA MTEMPPTR
.1a33b8	a9 af 00	lda #$00af	                LDA #`TL0_CONTROL_REG
.1a33bb	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a33bd	28		plp		                PLP
.1a33be	60		rts		            RTS
.1a33bf					out_of_range
.1a33bf	08		php		            PHP
.1a33c0	c2 20		rep #$20	            REP #$20
.1a33c2	48		pha		            PHA
.1a33c3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a33c6	5b		tcd		            TCD
.1a33c7	68		pla		            PLA
.1a33c8	28		plp		            PLP
.1a33c9	e2 20		sep #$20	            SEP #$20
.1a33cb	a9 09		lda #$09	            LDA #ERR_RANGE
.1a33cd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a33d1	c2 20		rep #$20	            REP #$20
.1a33d3	29 ff 00	and #$00ff	            AND #$00FF
.1a33d6	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a33d9	e2 20		sep #$20	            SEP #$20
.1a33db	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a33de					S_TILESET
.1a33de	08		php		                PHP
.1a33df					locals
>0001					L_TILENUM       .word ?
>0003					L_LUT           .word ?
>0005					L_IS_SQUARE     .word ?
.1a33df	c2 20		rep #$20	            REP #$20
.1a33e1	3b		tsc		            TSC
.1a33e2	38		sec		            SEC
.1a33e3	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.1a33e6	1b		tcs		            TCS
.1a33e7	c2 20		rep #$20	            REP #$20
.1a33e9	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a33ec	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a33ef	a5 23		lda $0823	                LDA ARGUMENT1
.1a33f1	83 01		sta $01,s	                STA L_TILENUM               ; Save it as the tile set/map number
.1a33f3	a9 2c 00	lda #$002c	                LDA #','
.1a33f6	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a33f9	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a33fc	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a33ff	a5 23		lda $0823	                LDA ARGUMENT1
.1a3401	83 03		sta $03,s	                STA L_LUT                   ; Save it as LUT
.1a3403	a9 2c 00	lda #$002c	                LDA #','
.1a3406	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3409	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a340c	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a340f	a5 23		lda $0823	                LDA ARGUMENT1
.1a3411	83 05		sta $05,s	                STA L_IS_SQUARE             ; Save it as IS_SQUARE
.1a3413	a9 2c 00	lda #$002c	                LDA #','
.1a3416	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3419	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a341c	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a341f	a3 01		lda $01,s	                LDA L_TILENUM
.1a3421	20 5e 33	jsr $1a335e	            JSR TILESET_ADDR
.1a3424	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the bitmap address - the address of the start of VRAM
.1a3426	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And save it to the registers
.1a3428	e2 20		sep #$20	            SEP #$20
.1a342a	38		sec		                SEC
.1a342b	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a342d	e9 b0		sbc #$b0	                SBC #`VRAM
.1a342f	a0 02 00	ldy #$0002	                LDY #TILESET_ADDY_H
.1a3432	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3434	a3 05		lda $05,s	                LDA L_IS_SQUARE             ; Check if is_square == 0?
.1a3436	d0 0d		bne $1a3445	                BNE is_square
.1a3438					not_square
.1a3438	e2 20		sep #$20	            SEP #$20
.1a343a	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.1a343c	29 07		and #$07	                AND #$07                    ; Force it to be in range
.1a343e	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.1a3441	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.1a3443	80 0d		bra $1a3452	                BRA done
.1a3445					is_square
.1a3445	e2 20		sep #$20	            SEP #$20
.1a3447	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.1a3449	29 07		and #$07	                AND #$07                    ; Force it to be in range
.1a344b	09 08		ora #$08	                ORA #TILESET_SQUARE_256     ; Turn on the 256x256 flag
.1a344d	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.1a3450	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.1a3452					done
.1a3452	c2 20		rep #$20	            REP #$20
.1a3454	3b		tsc		            TSC
.1a3455	18		clc		            CLC
.1a3456	69 06 00	adc #$0006	            ADC #SIZE(locals)
.1a3459	1b		tcs		            TCS
.1a345a	28		plp		                PLP
.1a345b	60		rts		            RTS
.1a345c					S_TILEMAP
.1a345c	08		php		                PHP
.1a345d					locals
>0001					L_TILENUM       .word ?
>0003					L_WIDTH         .word ?
>0005					L_HEIGHT        .word ?
.1a345d	c2 20		rep #$20	            REP #$20
.1a345f	3b		tsc		            TSC
.1a3460	38		sec		            SEC
.1a3461	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.1a3464	1b		tcs		            TCS
.1a3465	c2 20		rep #$20	            REP #$20
.1a3467	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a346a	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a346d	a5 23		lda $0823	                LDA ARGUMENT1
.1a346f	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.1a3471	a9 2c 00	lda #$002c	                LDA #','
.1a3474	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3477	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a347a	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a347d	a5 23		lda $0823	                LDA ARGUMENT1
.1a347f	83 03		sta $03,s	                STA L_WIDTH                 ; Save it as WIDTH
.1a3481	a9 2c 00	lda #$002c	                LDA #','
.1a3484	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3487	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a348a	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a348d	a5 23		lda $0823	                LDA ARGUMENT1
.1a348f	83 05		sta $05,s	                STA L_HEIGHT                ; Save it as HEIGHT
.1a3491	a9 2c 00	lda #$002c	                LDA #','
.1a3494	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3497	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a349a	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a349d	a3 01		lda $01,s	                LDA L_TILENUM
.1a349f	20 9e 33	jsr $1a339e	            JSR TILEMAP_ADDR
.1a34a2	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the map address - the address of the start of VRAM
.1a34a4	a0 01 00	ldy #$0001	                LDY #TILEMAP_START_ADDY
.1a34a7	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; And save it to the registers
.1a34a9	e2 20		sep #$20	            SEP #$20
.1a34ab	38		sec		                SEC
.1a34ac	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a34ae	e9 b0		sbc #$b0	                SBC #`VRAM
.1a34b0	c8		iny		                INY
.1a34b1	c8		iny		                INY
.1a34b2	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a34b4	c2 20		rep #$20	            REP #$20
.1a34b6	a3 03		lda $03,s	                LDA L_WIDTH                 ; Set the width
.1a34b8	a0 04 00	ldy #$0004	                LDY #TILEMAP_TOTAL_X
.1a34bb	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a34bd	a3 05		lda $05,s	                LDA L_HEIGHT                ; Set the height
.1a34bf	a0 06 00	ldy #$0006	                LDY #TILEMAP_TOTAL_Y
.1a34c2	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a34c4					done
.1a34c4	c2 20		rep #$20	            REP #$20
.1a34c6	3b		tsc		            TSC
.1a34c7	18		clc		            CLC
.1a34c8	69 06 00	adc #$0006	            ADC #SIZE(locals)
.1a34cb	1b		tcs		            TCS
.1a34cc	28		plp		                PLP
.1a34cd	60		rts		            RTS
.1a34ce					S_TILESHOW
.1a34ce	08		php		                PHP
.1a34cf					locals
>0001					L_TILENUM       .word ?
.1a34cf	c2 20		rep #$20	            REP #$20
.1a34d1	f4 00 00	pea #$0000	            PEA #0
.1a34d4	c2 20		rep #$20	            REP #$20
.1a34d6	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a34d9	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a34dc	a5 23		lda $0823	                LDA ARGUMENT1
.1a34de	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.1a34e0	a9 2c 00	lda #$002c	                LDA #','
.1a34e3	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a34e6	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a34e9	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a34ec	a3 01		lda $01,s	                LDA L_TILENUM
.1a34ee	20 9e 33	jsr $1a339e	            JSR TILEMAP_ADDR
.1a34f1	a5 23		lda $0823	                LDA ARGUMENT1               ; CHeck the visible parameter
.1a34f3	d0 06		bne $1a34fb	                BNE is_visible              ; If it's <> 0, make it visible
.1a34f5	e2 20		sep #$20	            SEP #$20
.1a34f7	a9 00		lda #$00	                LDA #0                      ; Control value for invisible
.1a34f9	80 04		bra $1a34ff	                BRA set_control
.1a34fb					is_visible
.1a34fb	e2 20		sep #$20	            SEP #$20
.1a34fd	a9 01		lda #$01	                LDA #TILEMAP_VISIBLE        ; Control value for visible
.1a34ff					set_control
.1a34ff	e2 20		sep #$20	            SEP #$20
.1a3501	a0 00 00	ldy #$0000	                LDY #TILEMAP_CONTROL        ; Set the control register
.1a3504	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3506					done
.1a3506	c2 20		rep #$20	            REP #$20
.1a3508	68		pla		            PLA
.1a3509	28		plp		                PLP
.1a350a	60		rts		            RTS
.1a350b					S_TILEAT
.1a350b	08		php		                PHP
.1a350c					locals
>0001					L_TILENUM       .word ?
>0003					L_X             .word ?
.1a350c	c2 20		rep #$20	            REP #$20
.1a350e	3b		tsc		            TSC
.1a350f	38		sec		            SEC
.1a3510	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.1a3513	1b		tcs		            TCS
.1a3514	c2 20		rep #$20	            REP #$20
.1a3516	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3519	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a351c	a5 23		lda $0823	                LDA ARGUMENT1
.1a351e	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.1a3520	a9 2c 00	lda #$002c	                LDA #','
.1a3523	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3526	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3529	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a352c	a5 23		lda $0823	                LDA ARGUMENT1
.1a352e	83 03		sta $03,s	                STA L_X                     ; Save as X
.1a3530	a9 2c 00	lda #$002c	                LDA #','
.1a3533	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3536	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3539	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a353c	a3 01		lda $01,s	                LDA L_TILENUM
.1a353e	20 9e 33	jsr $1a339e	            JSR TILEMAP_ADDR
.1a3541	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the Y position
.1a3543	a0 0a 00	ldy #$000a	                LDY #TILEMAP_WINDOW_Y
.1a3546	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3548	a3 03		lda $03,s	                LDA L_X                     ; Set the X position
.1a354a	a0 08 00	ldy #$0008	                LDY #TILEMAP_WINDOW_X
.1a354d	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a354f					done
.1a354f	c2 20		rep #$20	            REP #$20
.1a3551	3b		tsc		            TSC
.1a3552	18		clc		            CLC
.1a3553	69 04 00	adc #$0004	            ADC #SIZE(locals)
.1a3556	1b		tcs		            TCS
.1a3557	28		plp		                PLP
.1a3558	60		rts		            RTS
=0					DMA_LINEAR = 0                              ; Memory to copy is a continguous, linear range
=1					DMA_RECT = 1                                ; Memory to copy is a rectangular block
.0000					DMA_BLOCK
>0000					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>0001					ADDR            .long ?                     ; The starting address for the data to transfer
>0004					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>0007					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>0009					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>000b					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
=$01					DMA_SRC_2D = $01                            ; Source transfer should be 2D
=$02					DMA_DST_2D = $02                            ; Destination transfer should be 2D
=$10					DMA_SRC_SRAM = $10                          ; Flag indicating that the source is in SRAM ($00:0000 - $3F:FFFF)
=$20					DMA_DST_SRAM = $20                          ; Flag indicating that the destination is in SRAM ($00:0000 - $3F:FFFF)
>1af058					DMA_BLOCKS      .byte ?                     ; What blocks are involved
.1af059					DMA_SRC
>1af059					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>1af05a					ADDR            .long ?                     ; The starting address for the data to transfer
>1af05d					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>1af060					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>1af062					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>1af064					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.1af066					DMA_DEST
>1af066					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>1af067					ADDR            .long ?                     ; The starting address for the data to transfer
>1af06a					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>1af06d					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>1af06f					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>1af071					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.1a3559					DO_DMA
.1a3559	0b		phd		                PHD
.1a355a	08		php		                PHP
.1a355b	08		php		            PHP
.1a355c	c2 20		rep #$20	            REP #$20
.1a355e	48		pha		            PHA
.1a355f	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a3562	5b		tcd		            TCD
.1a3563	68		pla		            PLA
.1a3564	28		plp		            PLP
.1a3565	e2 20		sep #$20	            SEP #$20
.1a3567	a9 00		lda #$00	                LDA #0
.1a3569	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS           ; Set mode to something neutral
.1a356d	af 5c f0 1a	lda $1af05c	                LDA @l DMA_SRC.ADDR+2       ; Check the bank
.1a3571	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.1a3573	b0 1c		bcs $1a3591	                BGE src_vram                ; Yes: leave the DMA_BLOCK bit alone
.1a3575	8f 24 04 af	sta $af0424	src_sram        STA @l SDMA_SRC_ADDY_H      ; Set the SDMA source address
.1a3579	af 5b f0 1a	lda $1af05b	                LDA @l DMA_SRC.ADDR+1
.1a357d	8f 23 04 af	sta $af0423	                STA @l SDMA_SRC_ADDY_M
.1a3581	af 5a f0 1a	lda $1af05a	                LDA @l DMA_SRC.ADDR
.1a3585	8f 22 04 af	sta $af0422	                STA @l SDMA_SRC_ADDY_L
.1a3589	a9 10		lda #$10	                LDA #DMA_SRC_SRAM           ; Set the SRAM source block bit
.1a358b	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a358f	80 17		bra $1a35a8	                BRA src_mode
.1a3591	38		sec		src_vram        SEC                         ; Convert to VRAM relative address
.1a3592	e9 b0		sbc #$b0	                SBC #`VRAM
.1a3594	8f 04 04 af	sta $af0404	                STA @l VDMA_SRC_ADDY_H      ; Set the VDMA source address
.1a3598	af 5b f0 1a	lda $1af05b	                LDA @l DMA_SRC.ADDR+1
.1a359c	8f 03 04 af	sta $af0403	                STA @l VDMA_SRC_ADDY_M
.1a35a0	af 5a f0 1a	lda $1af05a	                LDA @l DMA_SRC.ADDR
.1a35a4	8f 02 04 af	sta $af0402	                STA @l VDMA_SRC_ADDY_L
.1a35a8	af 59 f0 1a	lda $1af059	src_mode        LDA @l DMA_SRC.MODE         ; Determine if source is 1D or 2D
.1a35ac	d0 3c		bne $1a35ea	                BNE src_2d
.1a35ae	af 58 f0 1a	lda $1af058	src_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.1a35b2	f0 1b		beq $1a35cf	                BEQ src_1d_vram
.1a35b4	af 5d f0 1a	lda $1af05d	src_1d_sram     LDA @l DMA_SRC.SIZE         ; It's SRAM, so set the SDMA size
.1a35b8	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.1a35bc	af 5e f0 1a	lda $1af05e	                LDA @l DMA_SRC.SIZE+1
.1a35c0	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_M
.1a35c4	af 5f f0 1a	lda $1af05f	                LDA @l DMA_SRC.SIZE+2
.1a35c8	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.1a35cc	82 8b 00	brl $1a365a	                BRL set_dst                 ; Go to set up the destination
.1a35cf	af 5d f0 1a	lda $1af05d	src_1d_vram     LDA @l DMA_SRC.SIZE         ; It's VRAM, so set the VDMA size
.1a35d3	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.1a35d7	af 5e f0 1a	lda $1af05e	                LDA @l DMA_SRC.SIZE+1
.1a35db	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_M
.1a35df	af 5f f0 1a	lda $1af05f	                LDA @l DMA_SRC.SIZE+2
.1a35e3	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.1a35e7	82 70 00	brl $1a365a	                BRL set_dst                 ; Go to set up the destination
.1a35ea	af 58 f0 1a	lda $1af058	src_2d          LDA @l DMA_BLOCKS
.1a35ee	09 01		ora #$01	                ORA #DMA_SRC_2D             ; Set the bit to make the source a 2D transfer
.1a35f0	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a35f4	89 10		bit #$10	                BIT #DMA_SRC_SRAM           ; Are we writing to SRAM
.1a35f6	f0 32		beq $1a362a	                BEQ src_2d_vram             ; No: set the 2d values in the VRAM source
.1a35f8	af 60 f0 1a	lda $1af060	src_2d_sram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.1a35fc	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.1a3600	af 61 f0 1a	lda $1af061	                LDA @l DMA_SRC.WIDTH+1
.1a3604	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.1a3608	af 62 f0 1a	lda $1af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.1a360c	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.1a3610	af 63 f0 1a	lda $1af063	                LDA @l DMA_SRC.HEIGHT+1
.1a3614	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.1a3618	af 64 f0 1a	lda $1af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.1a361c	8f 2c 04 af	sta $af042c	                STA @l SDMA_SRC_STRIDE_L
.1a3620	af 65 f0 1a	lda $1af065	                LDA @l DMA_SRC.STRIDE+1
.1a3624	8f 2d 04 af	sta $af042d	                STA @l SDMA_SRC_STRIDE_L+1
.1a3628	80 30		bra $1a365a	                BRA set_dst
.1a362a	af 60 f0 1a	lda $1af060	src_2d_vram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.1a362e	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.1a3632	af 61 f0 1a	lda $1af061	                LDA @l DMA_SRC.WIDTH+1
.1a3636	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.1a363a	af 62 f0 1a	lda $1af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.1a363e	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.1a3642	af 63 f0 1a	lda $1af063	                LDA @l DMA_SRC.HEIGHT+1
.1a3646	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.1a364a	af 64 f0 1a	lda $1af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.1a364e	8f 0c 04 af	sta $af040c	                STA @l VDMA_SRC_STRIDE_L
.1a3652	af 65 f0 1a	lda $1af065	                LDA @l DMA_SRC.STRIDE+1
.1a3656	8f 0d 04 af	sta $af040d	                STA @l VDMA_SRC_STRIDE_L+1
.1a365a					set_dst
.1a365a	e2 20		sep #$20	            SEP #$20
.1a365c	af 69 f0 1a	lda $1af069	                LDA @l DMA_DEST.ADDR+2      ; Check the bank
.1a3660	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.1a3662	b0 20		bcs $1a3684	                BGE dst_vram                ; Yes: leave the DMA_BLOCK bit alone
.1a3664	8f 27 04 af	sta $af0427	dst_sram        STA @l SDMA_DST_ADDY_H      ; Set the SDMA destination address
.1a3668	af 68 f0 1a	lda $1af068	                LDA @l DMA_DEST.ADDR+1
.1a366c	8f 26 04 af	sta $af0426	                STA @l SDMA_DST_ADDY_M
.1a3670	af 67 f0 1a	lda $1af067	                LDA @l DMA_DEST.ADDR
.1a3674	8f 25 04 af	sta $af0425	                STA @l SDMA_DST_ADDY_L
.1a3678	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS
.1a367c	09 20		ora #$20	                ORA #DMA_DST_SRAM           ; Set the bit to indicate the destination is SRAM
.1a367e	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a3682	80 17		bra $1a369b	                BRA dst_mode
.1a3684	38		sec		dst_vram        SEC                         ; Convert to VRAM relative address
.1a3685	e9 b0		sbc #$b0	                SBC #`VRAM
.1a3687	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H      ; Set the VDMA destination address
.1a368b	af 68 f0 1a	lda $1af068	                LDA @l DMA_DEST.ADDR+1
.1a368f	8f 06 04 af	sta $af0406	                STA @l VDMA_DST_ADDY_M
.1a3693	af 67 f0 1a	lda $1af067	                LDA @l DMA_DEST.ADDR
.1a3697	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.1a369b	af 66 f0 1a	lda $1af066	dst_mode        LDA @l DMA_DEST.MODE
.1a369f	d0 3e		bne $1a36df	                BNE dst_2d                  ; If 2D, set up the 2D destination parameters
.1a36a1	af 58 f0 1a	lda $1af058	dst_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.1a36a5	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Is the destination SRAM?
.1a36a7	f0 1b		beq $1a36c4	                BEQ dst_1d_vram
.1a36a9	af 6a f0 1a	lda $1af06a	dst_1d_sram     LDA @l DMA_DEST.SIZE
.1a36ad	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.1a36b1	af 6b f0 1a	lda $1af06b	                LDA @l DMA_DEST.SIZE+1
.1a36b5	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_L+1
.1a36b9	af 6c f0 1a	lda $1af06c	                LDA @l DMA_DEST.SIZE+2
.1a36bd	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.1a36c1	82 8b 00	brl $1a374f	                BRL start_xfer
.1a36c4	af 6a f0 1a	lda $1af06a	dst_1d_vram     LDA @l DMA_DEST.SIZE
.1a36c8	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.1a36cc	af 6b f0 1a	lda $1af06b	                LDA @l DMA_DEST.SIZE+1
.1a36d0	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_L+1
.1a36d4	af 6c f0 1a	lda $1af06c	                LDA @l DMA_DEST.SIZE+2
.1a36d8	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.1a36dc	82 70 00	brl $1a374f	                BRL start_xfer
.1a36df	af 58 f0 1a	lda $1af058	dst_2d          LDA @l DMA_BLOCKS
.1a36e3	09 02		ora #$02	                ORA #DMA_DST_2D             ; Set the bit to make the source a 2D transfer
.1a36e5	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a36e9	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Are we writing to the SRAM?
.1a36eb	f0 32		beq $1a371f	                BEQ dst_2d_vram             ; No: set the 2D parameters for VRAM
.1a36ed	af 6d f0 1a	lda $1af06d	dst_2d_sram     LDA @l DMA_DEST.WIDTH       ; Set the SRAM width
.1a36f1	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.1a36f5	af 6e f0 1a	lda $1af06e	                LDA @L DMA_DEST.WIDTH+1
.1a36f9	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.1a36fd	af 6f f0 1a	lda $1af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the SRAM height
.1a3701	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.1a3705	af 70 f0 1a	lda $1af070	                LDA @L DMA_DEST.HEIGHT+1
.1a3709	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.1a370d	af 71 f0 1a	lda $1af071	                LDA @l DMA_DEST.STRIDE      ; Set the SRAM stride
.1a3711	8f 2e 04 af	sta $af042e	                STA @l SDMA_DST_STRIDE_L
.1a3715	af 72 f0 1a	lda $1af072	                LDA @L DMA_DEST.STRIDE+1
.1a3719	8f 2f 04 af	sta $af042f	                STA @l SDMA_DST_STRIDE_L+1
.1a371d	80 30		bra $1a374f	                BRA start_xfer
.1a371f	af 6d f0 1a	lda $1af06d	dst_2d_vram     LDA @l DMA_DEST.WIDTH       ; Set the VRAM width
.1a3723	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.1a3727	af 6e f0 1a	lda $1af06e	                LDA @L DMA_DEST.WIDTH+1
.1a372b	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.1a372f	af 6f f0 1a	lda $1af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the VRAM height
.1a3733	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.1a3737	af 70 f0 1a	lda $1af070	                LDA @L DMA_DEST.HEIGHT+1
.1a373b	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.1a373f	af 71 f0 1a	lda $1af071	                LDA @l DMA_DEST.STRIDE      ; Set the VRAM stride
.1a3743	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L
.1a3747	af 72 f0 1a	lda $1af072	                LDA @L DMA_DEST.STRIDE+1
.1a374b	8f 0f 04 af	sta $af040f	                STA @l VDMA_DST_STRIDE_L+1
.1a374f	af 58 f0 1a	lda $1af058	start_xfer      LDA @l DMA_BLOCKS
.1a3753	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.1a3755	f0 43		beq $1a379a	                BEQ start_vdma_only
.1a3757	c9 10		cmp #$10	                CMP #DMA_SRC_SRAM
.1a3759	f0 76		beq $1a37d1	                BEQ start_s2v
.1a375b	c9 20		cmp #$20	                CMP #DMA_DST_SRAM
.1a375d	d0 03		bne $1a3762	                BNE start_sdma_only
.1a375f	82 8a 00	brl $1a37ec	                BRL start_v2s
.1a3762					start_sdma_only
.1a3762	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.1a3766	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.1a3768	f0 23		beq $1a378d	                BEQ sdma_1d_only            ; Source and Destination 1D...
.1a376a	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.1a376c	f0 23		beq $1a3791	                BEQ sdma_2d_only            ; Source and Destination 2D
.1a376e	08		php		            PHP
.1a376f	c2 20		rep #$20	            REP #$20
.1a3771	48		pha		            PHA
.1a3772	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3775	5b		tcd		            TCD
.1a3776	68		pla		            PLA
.1a3777	28		plp		            PLP
.1a3778	e2 20		sep #$20	            SEP #$20
.1a377a	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a377c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3780	c2 20		rep #$20	            REP #$20
.1a3782	29 ff 00	and #$00ff	            AND #$00FF
.1a3785	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3788	e2 20		sep #$20	            SEP #$20
.1a378a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a378d	a9 01		lda #$01	sdma_1d_only    LDA #SDMA_CTRL0_Enable      ; Set the bits for 1D, SRAM->SRAM
.1a378f	80 02		bra $1a3793	                BRA sdma_set_ctrl
.1a3791	a9 03		lda #$03	sdma_2d_only    LDA #SDMA_CTRL0_Enable | SDMA_CTRL0_1D_2D
.1a3793	8f 20 04 af	sta $af0420	sdma_set_ctrl   STA @l SDMA_CTRL_REG0
.1a3797	82 7d 00	brl $1a3817	                BRL trig_sdma               ; And trigger the SDMA
.1a379a					start_vdma_only
.1a379a	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.1a379e	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.1a37a0	f0 23		beq $1a37c5	                BEQ vdma_1d_only            ; Source and Destination 1D...
.1a37a2	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.1a37a4	f0 23		beq $1a37c9	                BEQ vdma_2d_only            ; Source and Destination 2D...
.1a37a6	08		php		            PHP
.1a37a7	c2 20		rep #$20	            REP #$20
.1a37a9	48		pha		            PHA
.1a37aa	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a37ad	5b		tcd		            TCD
.1a37ae	68		pla		            PLA
.1a37af	28		plp		            PLP
.1a37b0	e2 20		sep #$20	            SEP #$20
.1a37b2	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a37b4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a37b8	c2 20		rep #$20	            REP #$20
.1a37ba	29 ff 00	and #$00ff	            AND #$00FF
.1a37bd	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a37c0	e2 20		sep #$20	            SEP #$20
.1a37c2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a37c5	a9 01		lda #$01	vdma_1d_only    LDA #VDMA_CTRL_Enable       ; Set the bits for 1D, VRAM->VRAM
.1a37c7	80 02		bra $1a37cb	                BRA vdma_set_ctrl
.1a37c9	a9 03		lda #$03	vdma_2d_only    LDA #VDMA_CTRL_Enable | VDMA_CTRL_1D_2D
.1a37cb	8f 00 04 af	sta $af0400	vdma_set_ctrl   STA @l VDMA_CONTROL_REG
.1a37cf	80 34		bra $1a3805	                BRA trig_vdma               ; And trigger the VDMA
.1a37d1					start_s2v
.1a37d1	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.1a37d5	29 01		and #$01	                AND #DMA_SRC_2D
.1a37d7	0a		asl a		                ASL A
.1a37d8	09 11		ora #$11	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Src
.1a37da	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a37de	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.1a37e2	29 02		and #$02	                AND #DMA_DST_2D
.1a37e4	09 11		ora #$11	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Src
.1a37e6	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a37ea	80 19		bra $1a3805	                BRA trig_vdma               ; And trigger the VDMA
.1a37ec					start_v2s
.1a37ec	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.1a37f0	29 02		and #$02	                AND #DMA_DST_2D
.1a37f2	09 21		ora #$21	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Dst
.1a37f4	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a37f8	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.1a37fc	29 01		and #$01	                AND #DMA_SRC_2D
.1a37fe	0a		asl a		                ASL A
.1a37ff	09 21		ora #$21	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Dst
.1a3801	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a3805					trig_vdma
.1a3805	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.1a3809	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF    ; Trigger the VDMA
.1a380b	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a380f	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Check if we need SDMA
.1a3813	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.1a3815	f0 0f		beq $1a3826	                BEQ wait_vdma               ; No: wait for VDMA to complete
.1a3817					trig_sdma
.1a3817	af 20 04 af	lda $af0420	                LDA @l SDMA_CTRL_REG0
.1a381b	09 80		ora #$80	                ORA #SDMA_CTRL0_Start_TRF   ; Trigger the SDMA
.1a381d	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a3821	ea		nop		                NOP                         ; When the transfer is started the CPU will be put on Hold (RDYn)...
.1a3822	ea		nop		                NOP                         ; Before it actually gets to stop it will execute a couple more instructions
.1a3823	ea		nop		                NOP                         ; From that point on, the CPU is halted (keep that in mind)
.1a3824	ea		nop		                NOP                         ; No IRQ will be processed either during that time
.1a3825	ea		nop		                NOP
.1a3826	af 01 04 af	lda $af0401	wait_vdma       LDA @l VDMA_STATUS_REG      ; Check the VDMA status
.1a382a	89 80		bit #$80	                BIT #VDMA_STAT_VDMA_IPS     ; If the transfer is still in process...
.1a382c	d0 f8		bne $1a3826	                BNE wait_vdma               ; Wait until it stops.
.1a382e	a9 00		lda #$00	                LDA #$00                    ; Clear the TRF bits
.1a3830	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a3834	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a3838	28		plp		                PLP
.1a3839	2b		pld		                PLD
.1a383a	60		rts		            RTS
.1a383b					S_MEMCOPY
.1a383b	0b		phd		                PHD
.1a383c	08		php		                PHP
.1a383d	e2 20		sep #$20	            SEP #$20
.1a383f	c2 10		rep #$10	            REP #$10
.1a3841	a9 00		lda #$00	                LDA #0
.1a3843	a2 00 00	ldx #$0000	                LDX #0
.1a3846	8f 59 f0 1a	sta $1af059	clr_loop        STA @l DMA_SRC
.1a384a	e8		inx		                INX
.1a384b	e0 1a 00	cpx #$001a	                CPX #SIZE(DMA_BLOCK) * 2
.1a384e	d0 f6		bne $1a3846	                BNE clr_loop
.1a3850	20 f8 20	jsr $1a20f8	            JSR PEEK_TOK
.1a3853	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.1a3855	f0 23		beq $1a387a	                BEQ src_linear                      ; Yes: go to process a linear source
.1a3857	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.1a3859	f0 5e		beq $1a38b9	                BEQ src_rect                        ; Yes: go to process a rectangular source
.1a385b					syntax_err
.1a385b	08		php		            PHP
.1a385c	c2 20		rep #$20	            REP #$20
.1a385e	48		pha		            PHA
.1a385f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3862	5b		tcd		            TCD
.1a3863	68		pla		            PLA
.1a3864	28		plp		            PLP
.1a3865	e2 20		sep #$20	            SEP #$20
.1a3867	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3869	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a386d	c2 20		rep #$20	            REP #$20
.1a386f	29 ff 00	and #$00ff	            AND #$00FF
.1a3872	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3875	e2 20		sep #$20	            SEP #$20
.1a3877	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a387a					src_linear
.1a387a	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a387d	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3880	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a3883	c2 20		rep #$20	            REP #$20
.1a3885	a5 23		lda $0823	            LDA ARGUMENT1
.1a3887	8f 5a f0 1a	sta $1af05a	            STA DMA_SRC.ADDR
.1a388b	e2 20		sep #$20	            SEP #$20
.1a388d	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a388f	8f 5c f0 1a	sta $1af05c	            STA DMA_SRC.ADDR+2
.1a3893	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a3895	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3898	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a389b	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a389e	c2 20		rep #$20	            REP #$20
.1a38a0	a5 23		lda $0823	            LDA ARGUMENT1
.1a38a2	8f 5d f0 1a	sta $1af05d	            STA DMA_SRC.SIZE
.1a38a6	e2 20		sep #$20	            SEP #$20
.1a38a8	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a38aa	8f 5f f0 1a	sta $1af05f	            STA DMA_SRC.SIZE+2
.1a38ae	e2 20		sep #$20	            SEP #$20
.1a38b0	a9 00		lda #$00	            LDA #<DMA_LINEAR
.1a38b2	8f 59 f0 1a	sta $1af059	            STA DMA_SRC.MODE
.1a38b6	82 74 00	brl $1a392d	                BRL process_to
.1a38b9					src_rect
.1a38b9	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a38bc	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a38bf	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a38c2	c2 20		rep #$20	            REP #$20
.1a38c4	a5 23		lda $0823	            LDA ARGUMENT1
.1a38c6	8f 5a f0 1a	sta $1af05a	            STA DMA_SRC.ADDR
.1a38ca	e2 20		sep #$20	            SEP #$20
.1a38cc	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a38ce	8f 5c f0 1a	sta $1af05c	            STA DMA_SRC.ADDR+2
.1a38d2	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a38d4	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a38d7	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a38da	20 f8 05	jsr $1a05f8	            JSR ASS_ARG1_INT16
.1a38dd	c2 20		rep #$20	            REP #$20
.1a38df	a5 23		lda $0823	            LDA ARGUMENT1
.1a38e1	8f 60 f0 1a	sta $1af060	            STA DMA_SRC.WIDTH
.1a38e5	8d 00 01	sta $0100	            STA M0_OPERAND_A
.1a38e8	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a38eb	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a38ee	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a38f1	20 f8 05	jsr $1a05f8	            JSR ASS_ARG1_INT16
.1a38f4	c2 20		rep #$20	            REP #$20
.1a38f6	a5 23		lda $0823	            LDA ARGUMENT1
.1a38f8	8f 62 f0 1a	sta $1af062	            STA DMA_SRC.HEIGHT
.1a38fc	8d 02 01	sta $0102	            STA M0_OPERAND_B
.1a38ff	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a3902	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3905	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3908	20 f8 05	jsr $1a05f8	            JSR ASS_ARG1_INT16
.1a390b	c2 20		rep #$20	            REP #$20
.1a390d	a5 23		lda $0823	            LDA ARGUMENT1
.1a390f	8f 64 f0 1a	sta $1af064	            STA DMA_SRC.STRIDE
.1a3913	c2 20		rep #$20	            REP #$20
.1a3915	ad 04 01	lda $0104	            LDA M0_RESULT
.1a3918	8f 5d f0 1a	sta $1af05d	            STA DMA_SRC.SIZE
.1a391c	e2 20		sep #$20	            SEP #$20
.1a391e	ad 06 01	lda $0106	            LDA M0_RESULT+2
.1a3921	8f 5f f0 1a	sta $1af05f	            STA DMA_SRC.SIZE+2
.1a3925	e2 20		sep #$20	            SEP #$20
.1a3927	a9 01		lda #$01	            LDA #<DMA_RECT
.1a3929	8f 59 f0 1a	sta $1af059	            STA DMA_SRC.MODE
.1a392d					process_to
.1a392d	e2 20		sep #$20	            SEP #$20
.1a392f	a9 9c		lda #$9c	                LDA #TOK_TO
.1a3931	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3934	20 f8 20	jsr $1a20f8	            JSR PEEK_TOK
.1a3937	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.1a3939	f0 23		beq $1a395e	                BEQ dest_linear                     ; Yes: go to process a linear destination
.1a393b	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.1a393d	f0 5e		beq $1a399d	                BEQ dest_rect                       ; Yes: go to process a rectangular source
.1a393f					syntax_err2
.1a393f	08		php		            PHP
.1a3940	c2 20		rep #$20	            REP #$20
.1a3942	48		pha		            PHA
.1a3943	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3946	5b		tcd		            TCD
.1a3947	68		pla		            PLA
.1a3948	28		plp		            PLP
.1a3949	e2 20		sep #$20	            SEP #$20
.1a394b	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a394d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3951	c2 20		rep #$20	            REP #$20
.1a3953	29 ff 00	and #$00ff	            AND #$00FF
.1a3956	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3959	e2 20		sep #$20	            SEP #$20
.1a395b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a395e					dest_linear
.1a395e	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3961	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3964	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a3967	c2 20		rep #$20	            REP #$20
.1a3969	a5 23		lda $0823	            LDA ARGUMENT1
.1a396b	8f 67 f0 1a	sta $1af067	            STA DMA_DEST.ADDR
.1a396f	e2 20		sep #$20	            SEP #$20
.1a3971	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3973	8f 69 f0 1a	sta $1af069	            STA DMA_DEST.ADDR+2
.1a3977	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a3979	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a397c	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a397f	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a3982	c2 20		rep #$20	            REP #$20
.1a3984	a5 23		lda $0823	            LDA ARGUMENT1
.1a3986	8f 6a f0 1a	sta $1af06a	            STA DMA_DEST.SIZE
.1a398a	e2 20		sep #$20	            SEP #$20
.1a398c	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a398e	8f 6c f0 1a	sta $1af06c	            STA DMA_DEST.SIZE+2
.1a3992	e2 20		sep #$20	            SEP #$20
.1a3994	a9 00		lda #$00	            LDA #<DMA_LINEAR
.1a3996	8f 66 f0 1a	sta $1af066	            STA DMA_DEST.MODE
.1a399a	82 74 00	brl $1a3a11	                BRL verify
.1a399d					dest_rect
.1a399d	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a39a0	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a39a3	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a39a6	c2 20		rep #$20	            REP #$20
.1a39a8	a5 23		lda $0823	            LDA ARGUMENT1
.1a39aa	8f 67 f0 1a	sta $1af067	            STA DMA_DEST.ADDR
.1a39ae	e2 20		sep #$20	            SEP #$20
.1a39b0	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a39b2	8f 69 f0 1a	sta $1af069	            STA DMA_DEST.ADDR+2
.1a39b6	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a39b8	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a39bb	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a39be	20 f8 05	jsr $1a05f8	            JSR ASS_ARG1_INT16
.1a39c1	c2 20		rep #$20	            REP #$20
.1a39c3	a5 23		lda $0823	            LDA ARGUMENT1
.1a39c5	8f 6d f0 1a	sta $1af06d	            STA DMA_DEST.WIDTH
.1a39c9	8d 00 01	sta $0100	            STA M0_OPERAND_A
.1a39cc	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a39cf	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a39d2	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a39d5	20 f8 05	jsr $1a05f8	            JSR ASS_ARG1_INT16
.1a39d8	c2 20		rep #$20	            REP #$20
.1a39da	a5 23		lda $0823	            LDA ARGUMENT1
.1a39dc	8f 6f f0 1a	sta $1af06f	            STA DMA_DEST.HEIGHT
.1a39e0	8d 02 01	sta $0102	            STA M0_OPERAND_B
.1a39e3	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a39e6	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a39e9	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a39ec	20 f8 05	jsr $1a05f8	            JSR ASS_ARG1_INT16
.1a39ef	c2 20		rep #$20	            REP #$20
.1a39f1	a5 23		lda $0823	            LDA ARGUMENT1
.1a39f3	8f 71 f0 1a	sta $1af071	            STA DMA_DEST.STRIDE
.1a39f7	c2 20		rep #$20	            REP #$20
.1a39f9	ad 04 01	lda $0104	            LDA M0_RESULT
.1a39fc	8f 6a f0 1a	sta $1af06a	            STA DMA_DEST.SIZE
.1a3a00	e2 20		sep #$20	            SEP #$20
.1a3a02	ad 06 01	lda $0106	            LDA M0_RESULT+2
.1a3a05	8f 6c f0 1a	sta $1af06c	            STA DMA_DEST.SIZE+2
.1a3a09	e2 20		sep #$20	            SEP #$20
.1a3a0b	a9 01		lda #$01	            LDA #<DMA_RECT
.1a3a0d	8f 66 f0 1a	sta $1af066	            STA DMA_DEST.MODE
.1a3a11					verify
.1a3a11	c2 20		rep #$20	            REP #$20
.1a3a13	af 5d f0 1a	lda $1af05d	                LDA @l DMA_SRC.SIZE
.1a3a17	cf 6a f0 1a	cmp $1af06a	                CMP @l DMA_DEST.SIZE
.1a3a1b	d0 14		bne $1a3a31	                BNE size_err
.1a3a1d	e2 20		sep #$20	            SEP #$20
.1a3a1f	af 5f f0 1a	lda $1af05f	                LDA @l DMA_SRC.SIZE+2
.1a3a23	cf 6c f0 1a	cmp $1af06c	                CMP @l DMA_DEST.SIZE+2
.1a3a27	d0 08		bne $1a3a31	                BNE size_err
.1a3a29	c2 20		rep #$20	            REP #$20
.1a3a2b	20 59 35	jsr $1a3559	            JSR DO_DMA
.1a3a2e	28		plp		                PLP
.1a3a2f	2b		pld		                PLD
.1a3a30	60		rts		            RTS
.1a3a31					size_err
.1a3a31	08		php		            PHP
.1a3a32	c2 20		rep #$20	            REP #$20
.1a3a34	48		pha		            PHA
.1a3a35	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3a38	5b		tcd		            TCD
.1a3a39	68		pla		            PLA
.1a3a3a	28		plp		            PLP
.1a3a3b	e2 20		sep #$20	            SEP #$20
.1a3a3d	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a3a3f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3a43	c2 20		rep #$20	            REP #$20
.1a3a45	29 ff 00	and #$00ff	            AND #$00FF
.1a3a48	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3a4b	e2 20		sep #$20	            SEP #$20
.1a3a4d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3a50					S_LOCATE
.1a3a50	08		php		                PHP
.1a3a51	c2 30		rep #$30	            REP #$30
.1a3a53	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3a56	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a3a59	a5 23		lda $0823	                LDA ARGUMENT1
.1a3a5b	48		pha		                PHA                         ; Save it for later
.1a3a5c	a9 2c 00	lda #$002c	                LDA #','                    ; Check for the comma separator
.1a3a5f	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3a62	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3a65	20 4e 06	jsr $1a064e	            JSR ASS_ARG1_BYTE
.1a3a68	a4 23		ldy $0823	                LDY ARGUMENT1               ; Set Y to the row
.1a3a6a	fa		plx		                PLX                         ; Set X to the column
.1a3a6b	20 20 00	jsr $1a0020	            JSR CURSORXY
.1a3a6e	28		plp		                PLP
.1a3a6f	60		rts		            RTS

;******  Return to file: src\statements.s

.1a3a70					S_INPUT
.1a3a70	08		php		                PHP
.1a3a71					varloop
.1a3a71	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a3a74	e2 20		sep #$20	            SEP #$20
.1a3a76	a7 00		lda [$0800]	                LDA [BIP]
.1a3a78	d0 03		bne $1a3a7d	                BNE check_colon
.1a3a7a	4c 18 3b	jmp $1a3b18	                JMP done            ; If EOL, we're done
.1a3a7d	c9 3a		cmp #$3a	check_colon     CMP #':'
.1a3a7f	d0 03		bne $1a3a84	                BNE check_string
.1a3a81	4c 18 3b	jmp $1a3b18	                JMP done            ; If colon, we're done
.1a3a84	c9 22		cmp #$22	check_string    CMP #CHAR_DQUOTE    ; Is it the start of a string?
.1a3a86	d0 0b		bne $1a3a93	                BNE check_var       ; No: then it should be a variable name
.1a3a88	20 92 1a	jsr $1a1a92	            JSR EVALSTRING
.1a3a8b	20 26 44	jsr $1a4426	            JSR PR_STRING
.1a3a8e	a9 3b		lda #$3b	                LDA #';'            ; Look for a semicolon
.1a3a90	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3a93					check_var
.1a3a93	20 cd 03	jsr $1a03cd	            JSR ISALPHA
.1a3a96	90 44		bcc $1a3adc	                BCC syntax_err      ; No: it's a syntax error
.1a3a98	20 cc 51	jsr $1a51cc	            JSR VAR_FINDNAME
.1a3a9b	90 3f		bcc $1a3adc	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3a9d	a9 3f		lda #$3f	                LDA #"?"            ; Print a "? " to follow
.1a3a9f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a3aa2	a9 20		lda #$20	                LDA #CHAR_SP
.1a3aa4	20 18 00	jsr $1a0018	            JSR PRINTC
.1a3aa7	20 10 00	jsr $1a0010	            JSR INPUTLINE
.1a3aaa	e2 20		sep #$20	            SEP #$20
.1a3aac	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Check the type of the variable
.1a3aae	c9 02		cmp #$02	                CMP #TYPE_STRING    ; If it's a string...
.1a3ab0	f0 49		beq $1a3afb	                BEQ in_string       ; ... go to copy the string data
.1a3ab2	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; If it's an integer...
.1a3ab4	d0 03		bne $1a3ab9	                BNE chk_float
.1a3ab6	82 84 00	brl $1a3b3d	                BRL in_integer      ; ... go to parse the integer
.1a3ab9	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT     ; If it's a float...
.1a3abb	f0 5d		beq $1a3b1a	                BEQ in_float        ; ... go to parse the float
.1a3abd	08		php		            PHP
.1a3abe	c2 20		rep #$20	            REP #$20
.1a3ac0	48		pha		            PHA
.1a3ac1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3ac4	5b		tcd		            TCD
.1a3ac5	68		pla		            PLA
.1a3ac6	28		plp		            PLP
.1a3ac7	e2 20		sep #$20	            SEP #$20
.1a3ac9	a9 04		lda #$04	            LDA #ERR_TYPE
.1a3acb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3acf	c2 20		rep #$20	            REP #$20
.1a3ad1	29 ff 00	and #$00ff	            AND #$00FF
.1a3ad4	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3ad7	e2 20		sep #$20	            SEP #$20
.1a3ad9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3adc					syntax_err
.1a3adc	08		php		            PHP
.1a3add	c2 20		rep #$20	            REP #$20
.1a3adf	48		pha		            PHA
.1a3ae0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3ae3	5b		tcd		            TCD
.1a3ae4	68		pla		            PLA
.1a3ae5	28		plp		            PLP
.1a3ae6	e2 20		sep #$20	            SEP #$20
.1a3ae8	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3aea	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3aee	c2 20		rep #$20	            REP #$20
.1a3af0	29 ff 00	and #$00ff	            AND #$00FF
.1a3af3	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3af6	e2 20		sep #$20	            SEP #$20
.1a3af8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3afb					in_string
.1a3afb	c2 20		rep #$20	            REP #$20
.1a3afd	a9 00 4c	lda #$4c00	                LDA #<>IOBUF
.1a3b00	85 23		sta $0823	                STA ARGUMENT1
.1a3b02	a9 00 00	lda #$0000	                LDA #`IOBUF
.1a3b05	85 25		sta $0825	                STA ARGUMENT1+2
.1a3b07	e2 20		sep #$20	            SEP #$20
.1a3b09	a9 02		lda #$02	                LDA #TYPE_STRING
.1a3b0b	85 27		sta $0827	                STA ARGTYPE1
.1a3b0d					save_input
.1a3b0d	c2 20		rep #$20	            REP #$20
.1a3b0f	20 2f 51	jsr $1a512f	            JSR VAR_SET
.1a3b12	a9 0d 00	lda #$000d	                LDA #CHAR_CR        ; Print a newline
.1a3b15	20 18 00	jsr $1a0018	            JSR PRINTC
.1a3b18	28		plp		done            PLP
.1a3b19	60		rts		            RTS
.1a3b1a					in_float
.1a3b1a	c2 20		rep #$20	            REP #$20
.1a3b1c	a5 00		lda $0800	                LDA BIP             ; Save the BIP for later use
.1a3b1e	85 40		sta $0840	                STA SAVEBIP
.1a3b20	a5 02		lda $0802	                LDA BIP+2
.1a3b22	85 42		sta $0842	                STA SAVEBIP+2
.1a3b24	a9 00 4c	lda #$4c00	                LDA #<>IOBUF        ; Point to the line that was just input
.1a3b27	85 00		sta $0800	                STA BIP
.1a3b29	a9 00 00	lda #$0000	                LDA #`IOBUF
.1a3b2c	85 02		sta $0802	                STA BIP+2
.1a3b2e	20 ee 57	jsr $1a57ee	            JSR PARSENUM
.1a3b31	c2 20		rep #$20	            REP #$20
.1a3b33	a5 40		lda $0840	                LDA SAVEBIP         ; Restore the BIP
.1a3b35	85 00		sta $0800	                STA BIP
.1a3b37	a5 42		lda $0842	                LDA SAVEBIP+2
.1a3b39	85 02		sta $0802	                STA BIP+2
.1a3b3b	80 d0		bra $1a3b0d	                BRA save_input
.1a3b3d					in_integer
.1a3b3d	c2 20		rep #$20	            REP #$20
.1a3b3f	a5 00		lda $0800	                LDA BIP             ; Save the BIP for later use
.1a3b41	85 40		sta $0840	                STA SAVEBIP
.1a3b43	a5 02		lda $0802	                LDA BIP+2
.1a3b45	85 42		sta $0842	                STA SAVEBIP+2
.1a3b47	a9 00 4c	lda #$4c00	                LDA #<>IOBUF        ; Point to the line that was just input
.1a3b4a	85 00		sta $0800	                STA BIP
.1a3b4c	a9 00 00	lda #$0000	                LDA #`IOBUF
.1a3b4f	85 02		sta $0802	                STA BIP+2
.1a3b51	20 c3 07	jsr $1a07c3	            JSR PARSEINT
.1a3b54	c2 20		rep #$20	            REP #$20
.1a3b56	a5 40		lda $0840	                LDA SAVEBIP         ; Restore the BIP
.1a3b58	85 00		sta $0800	                STA BIP
.1a3b5a	a5 42		lda $0842	                LDA SAVEBIP+2
.1a3b5c	85 02		sta $0802	                STA BIP+2
.1a3b5e	80 ad		bra $1a3b0d	                BRA save_input
.1a3b60					S_GET
.1a3b60	08		php		                PHP
.1a3b61					varloop
.1a3b61	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a3b64	e2 20		sep #$20	            SEP #$20
.1a3b66	a7 00		lda [$0800]	                LDA [BIP]
.1a3b68	f0 47		beq $1a3bb1	                BEQ done            ; If EOL, we're done
.1a3b6a	c9 3a		cmp #$3a	                CMP #':'
.1a3b6c	f0 43		beq $1a3bb1	                BEQ done            ; If colon, we're done
.1a3b6e	20 cd 03	jsr $1a03cd	            JSR ISALPHA
.1a3b71	90 40		bcc $1a3bb3	                BCC syntax_err      ; No: it's a syntax error
.1a3b73	20 cc 51	jsr $1a51cc	            JSR VAR_FINDNAME
.1a3b76	90 3b		bcc $1a3bb3	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3b78	20 e7 13	jsr $1a13e7	            JSR TEMPSTRING
.1a3b7b	20 14 00	jsr $1a0014	            JSR GETKEY
.1a3b7e	e2 20		sep #$20	            SEP #$20
.1a3b80	a0 00 00	ldy #$0000	                LDY #0
.1a3b83	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a3b85	a9 00		lda #$00	                LDA #0
.1a3b87	c8		iny		                INY
.1a3b88	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a3b8a	c2 20		rep #$20	            REP #$20
.1a3b8c	a5 16		lda $0816	                LDA STRPTR
.1a3b8e	85 23		sta $0823	                STA ARGUMENT1
.1a3b90	a5 18		lda $0818	                LDA STRPTR+2
.1a3b92	85 25		sta $0825	                STA ARGUMENT1+2
.1a3b94	e2 20		sep #$20	            SEP #$20
.1a3b96	a9 02		lda #$02	                LDA #TYPE_STRING
.1a3b98	85 27		sta $0827	                STA ARGTYPE1
.1a3b9a	20 2f 51	jsr $1a512f	            JSR VAR_SET
.1a3b9d	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a3ba0	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.1a3ba2	f0 0d		beq $1a3bb1	                BEQ done            ; EOL? We're done
.1a3ba4	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.1a3ba6	f0 09		beq $1a3bb1	                BEQ done
.1a3ba8	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.1a3baa	d0 07		bne $1a3bb3	                BNE syntax_err      ; Nope: syntax error
.1a3bac	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a3baf	80 b0		bra $1a3b61	                BRA varloop
.1a3bb1	28		plp		done            PLP
.1a3bb2	60		rts		            RTS
.1a3bb3					syntax_err
.1a3bb3	08		php		            PHP
.1a3bb4	c2 20		rep #$20	            REP #$20
.1a3bb6	48		pha		            PHA
.1a3bb7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3bba	5b		tcd		            TCD
.1a3bbb	68		pla		            PLA
.1a3bbc	28		plp		            PLP
.1a3bbd	e2 20		sep #$20	            SEP #$20
.1a3bbf	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3bc1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3bc5	c2 20		rep #$20	            REP #$20
.1a3bc7	29 ff 00	and #$00ff	            AND #$00FF
.1a3bca	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3bcd	e2 20		sep #$20	            SEP #$20
.1a3bcf	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3bd2					S_CALL
.1a3bd2	08		php		                PHP
.1a3bd3	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3bd6	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a3bd9	e2 20		sep #$20	            SEP #$20
.1a3bdb	a9 5c		lda #$5c	                LDA #$5C            ; Set the opcode for JML
.1a3bdd	85 a2		sta $08a2	                STA MJUMPINST
.1a3bdf	c2 20		rep #$20	            REP #$20
.1a3be1	a5 23		lda $0823	                LDA ARGUMENT1
.1a3be3	85 a3		sta $08a3	                STA MJUMPADDR
.1a3be5	e2 20		sep #$20	            SEP #$20
.1a3be7	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3be9	85 a5		sta $08a5	                STA MJUMPADDR+2
.1a3beb	e2 20		sep #$20	            SEP #$20
.1a3bed	a9 2c		lda #$2c	                LDA #','
.1a3bef	85 37		sta $0837	                STA TARGETTOK
.1a3bf1	20 d9 20	jsr $1a20d9	            JSR OPT_TOK
.1a3bf4	90 41		bcc $1a3c37	                BCC launch          ; Not present... go ahead and launch
.1a3bf6	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a3bf9	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3bfc	20 f8 05	jsr $1a05f8	            JSR ASS_ARG1_INT16
.1a3bff	c2 20		rep #$20	            REP #$20
.1a3c01	a5 23		lda $0823	                LDA ARGUMENT1
.1a3c03	85 55		sta $0855	                STA MARG1           ; Save it to MARG1
.1a3c05	e2 20		sep #$20	            SEP #$20
.1a3c07	a9 2c		lda #$2c	                LDA #','
.1a3c09	85 37		sta $0837	                STA TARGETTOK
.1a3c0b	20 d9 20	jsr $1a20d9	            JSR OPT_TOK
.1a3c0e	90 27		bcc $1a3c37	                BCC launch          ; Not present... go ahead and launch
.1a3c10	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a3c13	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3c16	20 f8 05	jsr $1a05f8	            JSR ASS_ARG1_INT16
.1a3c19	c2 20		rep #$20	            REP #$20
.1a3c1b	a5 23		lda $0823	                LDA ARGUMENT1
.1a3c1d	85 59		sta $0859	                STA MARG2           ; Save it to MARG2
.1a3c1f	e2 20		sep #$20	            SEP #$20
.1a3c21	a9 2c		lda #$2c	                LDA #','
.1a3c23	85 37		sta $0837	                STA TARGETTOK
.1a3c25	20 d9 20	jsr $1a20d9	            JSR OPT_TOK
.1a3c28	90 0d		bcc $1a3c37	                BCC launch          ; Not present... go ahead and launch
.1a3c2a	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a3c2d	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3c30	20 f8 05	jsr $1a05f8	            JSR ASS_ARG1_INT16
.1a3c33	c2 20		rep #$20	            REP #$20
.1a3c35	a4 23		ldy $0823	                LDY ARGUMENT1
.1a3c37	a6 59		ldx $0859	launch          LDX MARG2
.1a3c39	a5 55		lda $0855	                LDA MARG1
.1a3c3b	0b		phd		                PHD
.1a3c3c	8b		phb		                PHB
.1a3c3d	08		php		                PHP
.1a3c3e	22 a2 08 00	jsl $0008a2	                JSL MJUMPINST       ; Call the subroutine indicated
.1a3c42	28		plp		                PLP
.1a3c43	ab		plb		                PLB
.1a3c44	2b		pld		                PLD
.1a3c45	20 dc 1f	jsr $1a1fdc	            JSR SKIPSTMT
.1a3c48	28		plp		                PLP
.1a3c49	60		rts		            RTS
.1a3c4a					type_err
.1a3c4a	08		php		            PHP
.1a3c4b	c2 20		rep #$20	            REP #$20
.1a3c4d	48		pha		            PHA
.1a3c4e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3c51	5b		tcd		            TCD
.1a3c52	68		pla		            PLA
.1a3c53	28		plp		            PLP
.1a3c54	e2 20		sep #$20	            SEP #$20
.1a3c56	a9 04		lda #$04	            LDA #ERR_TYPE
.1a3c58	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3c5c	c2 20		rep #$20	            REP #$20
.1a3c5e	29 ff 00	and #$00ff	            AND #$00FF
.1a3c61	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3c64	e2 20		sep #$20	            SEP #$20
.1a3c66	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3c69					S_DIM
.1a3c69	08		php		                PHP
.1a3c6a	e2 20		sep #$20	            SEP #$20
.1a3c6c	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a3c6f	20 cc 51	jsr $1a51cc	            JSR VAR_FINDNAME
.1a3c72	90 64		bcc $1a3cd8	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3c74	a9 8f		lda #$8f	                LDA #TOK_LPAREN     ; Verify we have a left parenthesis
.1a3c76	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a3c79	a9 01		lda #$01	                LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.1a3c7b	20 e5 18	jsr $1a18e5	            JSR PHOPERATOR
.1a3c7e	a2 01 00	ldx #$0001	                LDX #1
.1a3c81	a9 00		lda #$00	                LDA #0
.1a3c83	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF     ; Set the dimension count to 0
.1a3c87					dim_loop
.1a3c87	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3c8a	20 f8 05	jsr $1a05f8	            JSR ASS_ARG1_INT16
.1a3c8d	c2 20		rep #$20	            REP #$20
.1a3c8f	a5 23		lda $0823	                LDA ARGUMENT1
.1a3c91	9f 00 4d 00	sta $004d00,x	                STA @lARRIDXBUF,X   ; And store it in the buffer
.1a3c95	e2 20		sep #$20	            SEP #$20
.1a3c97	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF     ; Add to the dimension count
.1a3c9b	1a		inc a		                INC A
.1a3c9c	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF
.1a3ca0	30 55		bmi $1a3cf7	                BMI overflow        ; If > 127 throw an error
.1a3ca2	e8		inx		                INX
.1a3ca3	e8		inx		                INX
.1a3ca4	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a3ca7	a7 00		lda [$0800]	                LDA [BIP]           ; Check the character
.1a3ca9	c9 2c		cmp #$2c	                CMP #','            ; Is it a comma?
.1a3cab	f0 25		beq $1a3cd2	                BEQ skip_comma      ; Yes: get the next dimension
.1a3cad	c9 90		cmp #$90	                CMP #TOK_RPAREN     ; No: is it a ")"?
.1a3caf	d0 27		bne $1a3cd8	                BNE syntax_err      ; No: throw a syntax error
.1a3cb1	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a3cb4	20 4a 64	jsr $1a644a	            JSR ARR_ALLOC
.1a3cb7	c2 20		rep #$20	            REP #$20
.1a3cb9	a5 c0		lda $08c0	                LDA CURRBLOCK       ; Set up the pointer to the array
.1a3cbb	85 23		sta $0823	                STA ARGUMENT1
.1a3cbd	e2 20		sep #$20	            SEP #$20
.1a3cbf	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a3cc1	85 25		sta $0825	                STA ARGUMENT1+2
.1a3cc3	64 26		stz $0826	                STZ ARGUMENT1+3
.1a3cc5	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Get the type of the values
.1a3cc7	09 80		ora #$80	                ORA #$80            ; Make sure we change the type to array
.1a3cc9	85 ea		sta $08ea	                STA TOFINDTYPE      ; And save it back for searching
.1a3ccb	85 27		sta $0827	                STA ARGTYPE1        ; And for the value to set
.1a3ccd	20 2f 51	jsr $1a512f	            JSR VAR_SET
.1a3cd0	28		plp		                PLP
.1a3cd1	60		rts		            RTS
.1a3cd2					skip_comma
.1a3cd2	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a3cd5	4c 87 3c	jmp $1a3c87	                JMP dim_loop
.1a3cd8					syntax_err
.1a3cd8	08		php		            PHP
.1a3cd9	c2 20		rep #$20	            REP #$20
.1a3cdb	48		pha		            PHA
.1a3cdc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3cdf	5b		tcd		            TCD
.1a3ce0	68		pla		            PLA
.1a3ce1	28		plp		            PLP
.1a3ce2	e2 20		sep #$20	            SEP #$20
.1a3ce4	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3ce6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3cea	c2 20		rep #$20	            REP #$20
.1a3cec	29 ff 00	and #$00ff	            AND #$00FF
.1a3cef	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3cf2	e2 20		sep #$20	            SEP #$20
.1a3cf4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3cf7					overflow
.1a3cf7	08		php		            PHP
.1a3cf8	c2 20		rep #$20	            REP #$20
.1a3cfa	48		pha		            PHA
.1a3cfb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3cfe	5b		tcd		            TCD
.1a3cff	68		pla		            PLA
.1a3d00	28		plp		            PLP
.1a3d01	e2 20		sep #$20	            SEP #$20
.1a3d03	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a3d05	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3d09	c2 20		rep #$20	            REP #$20
.1a3d0b	29 ff 00	and #$00ff	            AND #$00FF
.1a3d0e	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3d11	e2 20		sep #$20	            SEP #$20
.1a3d13	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3d16					S_READ
.1a3d16	08		php		                PHP
.1a3d17					varloop
.1a3d17	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a3d1a	e2 20		sep #$20	            SEP #$20
.1a3d1c	a7 00		lda [$0800]	                LDA [BIP]
.1a3d1e	f0 28		beq $1a3d48	                BEQ done            ; If EOL, we're done
.1a3d20	c9 3a		cmp #$3a	                CMP #':'
.1a3d22	f0 24		beq $1a3d48	                BEQ done            ; If colon, we're done
.1a3d24	20 cd 03	jsr $1a03cd	            JSR ISALPHA
.1a3d27	90 21		bcc $1a3d4a	                BCC syntax_err      ; No: it's a syntax error
.1a3d29	20 cc 51	jsr $1a51cc	            JSR VAR_FINDNAME
.1a3d2c	90 1c		bcc $1a3d4a	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3d2e	20 69 3d	jsr $1a3d69	            JSR NEXTDATA
.1a3d31	20 2f 51	jsr $1a512f	            JSR VAR_SET
.1a3d34	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a3d37	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.1a3d39	f0 0d		beq $1a3d48	                BEQ done            ; EOL? We're done
.1a3d3b	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.1a3d3d	f0 09		beq $1a3d48	                BEQ done
.1a3d3f	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.1a3d41	d0 07		bne $1a3d4a	                BNE syntax_err      ; Nope: syntax error
.1a3d43	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a3d46	80 cf		bra $1a3d17	                BRA varloop
.1a3d48	28		plp		done            PLP
.1a3d49	60		rts		            RTS
.1a3d4a					syntax_err
.1a3d4a	08		php		            PHP
.1a3d4b	c2 20		rep #$20	            REP #$20
.1a3d4d	48		pha		            PHA
.1a3d4e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3d51	5b		tcd		            TCD
.1a3d52	68		pla		            PLA
.1a3d53	28		plp		            PLP
.1a3d54	e2 20		sep #$20	            SEP #$20
.1a3d56	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3d58	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3d5c	c2 20		rep #$20	            REP #$20
.1a3d5e	29 ff 00	and #$00ff	            AND #$00FF
.1a3d61	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3d64	e2 20		sep #$20	            SEP #$20
.1a3d66	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3d69					NEXTDATA
.1a3d69	08		php		                PHP
.1a3d6a	a5 02		lda $0802	                LDA BIP+2           ; Save BIP
.1a3d6c	85 42		sta $0842	                STA SAVEBIP+2
.1a3d6e	a5 00		lda $0800	                LDA BIP
.1a3d70	85 40		sta $0840	                STA SAVEBIP
.1a3d72	a5 1c		lda $081c	                LDA CURLINE+2       ; Save CURLINE
.1a3d74	85 46		sta $0846	                STA SAVELINE+2
.1a3d76	a5 1a		lda $081a	                LDA CURLINE
.1a3d78	85 44		sta $0844	                STA SAVELINE
.1a3d7a	c2 20		rep #$20	            REP #$20
.1a3d7c	a5 3a		lda $083a	                LDA DATABIP+2
.1a3d7e	d0 04		bne $1a3d84	                BNE data_set
.1a3d80	a5 38		lda $0838	                LDA DATABIP
.1a3d82	f0 4e		beq $1a3dd2	                BEQ scan_start      ; No: scan for a DATA statement
.1a3d84	a5 38		lda $0838	data_set        LDA DATABIP         ; Move BIP to the DATA statement
.1a3d86	85 00		sta $0800	                STA BIP
.1a3d88	a5 3a		lda $083a	                LDA DATABIP+2
.1a3d8a	85 02		sta $0802	                STA BIP+2
.1a3d8c	a5 3c		lda $083c	                LDA DATALINE        ; Set CURLINE from DATALINE
.1a3d8e	85 1a		sta $081a	                STA CURLINE
.1a3d90	a5 3e		lda $083e	                LDA DATALINE+2
.1a3d92	85 1c		sta $081c	                STA CURLINE+2
.1a3d94	e2 20		sep #$20	            SEP #$20
.1a3d96	a7 00		lda [$0800]	                LDA [BIP]           ; Check character at BIP
.1a3d98	f0 53		beq $1a3ded	                BEQ scan_DATA       ; EOL? scan for a DATA statement
.1a3d9a	c9 3a		cmp #$3a	                CMP #':'            ; Colon?
.1a3d9c	f0 4f		beq $1a3ded	                BEQ scan_DATA       ; ... scan for a DATA statement
.1a3d9e	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.1a3da0	d0 03		bne $1a3da5	                BNE skip_parse      ; No: skip leading WS and try to parse
.1a3da2	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a3da5					skip_parse
.1a3da5	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a3da8	a7 00		lda [$0800]	                LDA [BIP]
.1a3daa	c9 22		cmp #$22	                CMP #CHAR_DQUOTE    ; Is it a quote?
.1a3dac	f0 4e		beq $1a3dfc	                BEQ read_string     ; Yes: process the string
.1a3dae	20 e6 03	jsr $1a03e6	            JSR ISNUMERAL
.1a3db1	b0 4e		bcs $1a3e01	                BCS read_number     ; Yes: process the number
.1a3db3					syntax_err
.1a3db3	08		php		            PHP
.1a3db4	c2 20		rep #$20	            REP #$20
.1a3db6	48		pha		            PHA
.1a3db7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3dba	5b		tcd		            TCD
.1a3dbb	68		pla		            PLA
.1a3dbc	28		plp		            PLP
.1a3dbd	e2 20		sep #$20	            SEP #$20
.1a3dbf	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3dc1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3dc5	c2 20		rep #$20	            REP #$20
.1a3dc7	29 ff 00	and #$00ff	            AND #$00FF
.1a3dca	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3dcd	e2 20		sep #$20	            SEP #$20
.1a3dcf	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3dd2					scan_start
.1a3dd2	c2 20		rep #$20	            REP #$20
.1a3dd4	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT    ; Point CURLINE to the first line
.1a3dd7	85 1a		sta $081a	                STA CURLINE
.1a3dd9	a9 16 00	lda #$0016	                LDA #`BASIC_BOT
.1a3ddc	85 1c		sta $081c	                STA CURLINE+2
.1a3dde	18		clc		                CLC
.1a3ddf	a5 1a		lda $081a	                LDA CURLINE         ; Point BIP to the first possible token
.1a3de1	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.1a3de4	85 00		sta $0800	                STA BIP
.1a3de6	a5 1c		lda $081c	                LDA CURLINE+2
.1a3de8	69 00 00	adc #$0000	                ADC #0
.1a3deb	85 02		sta $0802	                STA BIP+2
.1a3ded					scan_data
.1a3ded	e2 20		sep #$20	            SEP #$20
.1a3def	a9 80		lda #$80	                LDA #$80            ; We don't want to process nesting
.1a3df1	85 35		sta $0835	                STA SKIPNEST
.1a3df3	a9 ab		lda #$ab	                LDA #TOK_DATA       ; We're looking for a DATA token
.1a3df5	85 37		sta $0837	                STA TARGETTOK
.1a3df7	20 ee 1f	jsr $1a1fee	            JSR SKIPTOTOK
.1a3dfa	80 a9		bra $1a3da5	                BRA skip_parse
.1a3dfc					read_string
.1a3dfc	20 92 1a	jsr $1a1a92	            JSR EVALSTRING
.1a3dff	80 03		bra $1a3e04	                BRA done
.1a3e01					read_number
.1a3e01	20 c7 19	jsr $1a19c7	            JSR EVALNUMBER
.1a3e04					done
.1a3e04	c2 20		rep #$20	            REP #$20
.1a3e06	a5 00		lda $0800	                LDA BIP             ; Save BIP to DATABIP
.1a3e08	85 38		sta $0838	                STA DATABIP
.1a3e0a	a5 02		lda $0802	                LDA BIP+2
.1a3e0c	85 3a		sta $083a	                STA DATABIP+2
.1a3e0e	a5 1a		lda $081a	                LDA CURLINE         ; Save CURLINE to DATALINE
.1a3e10	85 3c		sta $083c	                STA DATALINE
.1a3e12	a5 1c		lda $081c	                LDA CURLINE+2
.1a3e14	85 3e		sta $083e	                STA DATALINE+2
.1a3e16	a5 44		lda $0844	                LDA SAVELINE        ; Restore CURLINE
.1a3e18	85 1a		sta $081a	                STA CURLINE
.1a3e1a	a5 46		lda $0846	                LDA SAVELINE+2
.1a3e1c	85 1c		sta $081c	                STA CURLINE+2
.1a3e1e	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.1a3e20	85 00		sta $0800	                STA BIP
.1a3e22	a5 42		lda $0842	                LDA SAVEBIP+2
.1a3e24	85 02		sta $0802	                STA BIP+2
.1a3e26	28		plp		                PLP
.1a3e27	60		rts		            RTS
.1a3e28					S_DATA
.1a3e28	20 dc 1f	jsr $1a1fdc	            JSR SKIPSTMT
.1a3e2b	60		rts		            RTS
.1a3e2c					S_RESTORE
.1a3e2c	64 38		stz $0838	                STZ DATABIP         ; Just set DATABIP to 0
.1a3e2e	64 3a		stz $083a	                STZ DATABIP+2       ; The next READ will move it to the first DATA
.1a3e30	64 3c		stz $083c	                STZ DATALINE        ; Set DATALINE to 0
.1a3e32	64 3e		stz $083e	                STZ DATALINE+2
.1a3e34	60		rts		            RTS
.1a3e35					S_CLS
.1a3e35	20 24 00	jsr $1a0024	            JSR CLSCREEN
.1a3e38	60		rts		            RTS
.1a3e39					S_POKEL
.1a3e39	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3e3c	c2 20		rep #$20	            REP #$20
.1a3e3e	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.1a3e40	48		pha		                PHA
.1a3e41	a5 23		lda $0823	                LDA ARGUMENT1
.1a3e43	48		pha		                PHA
.1a3e44	e2 20		sep #$20	            SEP #$20
.1a3e46	a7 00		lda [$0800]	                LDA [BIP]
.1a3e48	c9 2c		cmp #$2c	                CMP #','
.1a3e4a	d0 22		bne $1a3e6e	                BNE syntax_err
.1a3e4c	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a3e4f	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3e52	c2 20		rep #$20	            REP #$20
.1a3e54	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a3e56	d0 35		bne $1a3e8d	                BNE range_err
.1a3e58	68		pla		                PLA                 ; Pull the target address from the stack
.1a3e59	85 08		sta $0808	                STA INDEX           ; and into INDEX
.1a3e5b	68		pla		                PLA
.1a3e5c	85 0a		sta $080a	                STA INDEX+2
.1a3e5e	c2 20		rep #$20	            REP #$20
.1a3e60	a5 23		lda $0823	                LDA ARGUMENT1
.1a3e62	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.1a3e64	e2 20		sep #$20	            SEP #$20
.1a3e66	a0 02 00	ldy #$0002	                LDY #2
.1a3e69	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3e6b	97 08		sta [$0808],y	                STA [INDEX],Y
.1a3e6d	60		rts		            RTS
.1a3e6e					syntax_err
.1a3e6e	08		php		            PHP
.1a3e6f	c2 20		rep #$20	            REP #$20
.1a3e71	48		pha		            PHA
.1a3e72	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3e75	5b		tcd		            TCD
.1a3e76	68		pla		            PLA
.1a3e77	28		plp		            PLP
.1a3e78	e2 20		sep #$20	            SEP #$20
.1a3e7a	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3e7c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3e80	c2 20		rep #$20	            REP #$20
.1a3e82	29 ff 00	and #$00ff	            AND #$00FF
.1a3e85	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3e88	e2 20		sep #$20	            SEP #$20
.1a3e8a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3e8d					range_err
.1a3e8d	08		php		            PHP
.1a3e8e	c2 20		rep #$20	            REP #$20
.1a3e90	48		pha		            PHA
.1a3e91	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3e94	5b		tcd		            TCD
.1a3e95	68		pla		            PLA
.1a3e96	28		plp		            PLP
.1a3e97	e2 20		sep #$20	            SEP #$20
.1a3e99	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3e9b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3e9f	c2 20		rep #$20	            REP #$20
.1a3ea1	29 ff 00	and #$00ff	            AND #$00FF
.1a3ea4	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3ea7	e2 20		sep #$20	            SEP #$20
.1a3ea9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3eac					S_POKEW
.1a3eac	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3eaf	c2 20		rep #$20	            REP #$20
.1a3eb1	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.1a3eb3	48		pha		                PHA
.1a3eb4	a5 23		lda $0823	                LDA ARGUMENT1
.1a3eb6	48		pha		                PHA
.1a3eb7	e2 20		sep #$20	            SEP #$20
.1a3eb9	a7 00		lda [$0800]	                LDA [BIP]
.1a3ebb	c9 2c		cmp #$2c	                CMP #','
.1a3ebd	d0 19		bne $1a3ed8	                BNE syntax_err
.1a3ebf	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a3ec2	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3ec5	c2 20		rep #$20	            REP #$20
.1a3ec7	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3ec9	d0 2c		bne $1a3ef7	                BNE range_err
.1a3ecb	68		pla		                PLA                 ; Pull the target address from the stack
.1a3ecc	85 08		sta $0808	                STA INDEX           ; and into INDEX
.1a3ece	68		pla		                PLA
.1a3ecf	85 0a		sta $080a	                STA INDEX+2
.1a3ed1	c2 20		rep #$20	            REP #$20
.1a3ed3	a5 23		lda $0823	                LDA ARGUMENT1
.1a3ed5	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.1a3ed7	60		rts		            RTS
.1a3ed8					syntax_err
.1a3ed8	08		php		            PHP
.1a3ed9	c2 20		rep #$20	            REP #$20
.1a3edb	48		pha		            PHA
.1a3edc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3edf	5b		tcd		            TCD
.1a3ee0	68		pla		            PLA
.1a3ee1	28		plp		            PLP
.1a3ee2	e2 20		sep #$20	            SEP #$20
.1a3ee4	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3ee6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3eea	c2 20		rep #$20	            REP #$20
.1a3eec	29 ff 00	and #$00ff	            AND #$00FF
.1a3eef	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3ef2	e2 20		sep #$20	            SEP #$20
.1a3ef4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3ef7					range_err
.1a3ef7	08		php		            PHP
.1a3ef8	c2 20		rep #$20	            REP #$20
.1a3efa	48		pha		            PHA
.1a3efb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3efe	5b		tcd		            TCD
.1a3eff	68		pla		            PLA
.1a3f00	28		plp		            PLP
.1a3f01	e2 20		sep #$20	            SEP #$20
.1a3f03	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3f05	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3f09	c2 20		rep #$20	            REP #$20
.1a3f0b	29 ff 00	and #$00ff	            AND #$00FF
.1a3f0e	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3f11	e2 20		sep #$20	            SEP #$20
.1a3f13	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3f16					S_POKE
.1a3f16	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3f19	c2 20		rep #$20	            REP #$20
.1a3f1b	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.1a3f1d	48		pha		                PHA
.1a3f1e	a5 23		lda $0823	                LDA ARGUMENT1
.1a3f20	48		pha		                PHA
.1a3f21	e2 20		sep #$20	            SEP #$20
.1a3f23	a7 00		lda [$0800]	                LDA [BIP]
.1a3f25	c9 2c		cmp #$2c	                CMP #','
.1a3f27	d0 1f		bne $1a3f48	                BNE syntax_err
.1a3f29	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a3f2c	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a3f2f	e2 20		sep #$20	            SEP #$20
.1a3f31	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Make sure the value is from 0 - 255
.1a3f33	d0 32		bne $1a3f67	                BNE range_err
.1a3f35	c2 20		rep #$20	            REP #$20
.1a3f37	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3f39	d0 2c		bne $1a3f67	                BNE range_err
.1a3f3b	68		pla		                PLA                 ; Pull the target address from the stack
.1a3f3c	85 08		sta $0808	                STA INDEX           ; and into INDEX
.1a3f3e	68		pla		                PLA
.1a3f3f	85 0a		sta $080a	                STA INDEX+2
.1a3f41	e2 20		sep #$20	            SEP #$20
.1a3f43	a5 23		lda $0823	                LDA ARGUMENT1
.1a3f45	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.1a3f47	60		rts		            RTS
.1a3f48					syntax_err
.1a3f48	08		php		            PHP
.1a3f49	c2 20		rep #$20	            REP #$20
.1a3f4b	48		pha		            PHA
.1a3f4c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3f4f	5b		tcd		            TCD
.1a3f50	68		pla		            PLA
.1a3f51	28		plp		            PLP
.1a3f52	e2 20		sep #$20	            SEP #$20
.1a3f54	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3f56	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3f5a	c2 20		rep #$20	            REP #$20
.1a3f5c	29 ff 00	and #$00ff	            AND #$00FF
.1a3f5f	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3f62	e2 20		sep #$20	            SEP #$20
.1a3f64	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3f67					range_err
.1a3f67	08		php		            PHP
.1a3f68	c2 20		rep #$20	            REP #$20
.1a3f6a	48		pha		            PHA
.1a3f6b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3f6e	5b		tcd		            TCD
.1a3f6f	68		pla		            PLA
.1a3f70	28		plp		            PLP
.1a3f71	e2 20		sep #$20	            SEP #$20
.1a3f73	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3f75	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3f79	c2 20		rep #$20	            REP #$20
.1a3f7b	29 ff 00	and #$00ff	            AND #$00FF
.1a3f7e	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3f81	e2 20		sep #$20	            SEP #$20
.1a3f83	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3f86					S_STOP
.1a3f86	08		php		            PHP
.1a3f87	c2 20		rep #$20	            REP #$20
.1a3f89	48		pha		            PHA
.1a3f8a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3f8d	5b		tcd		            TCD
.1a3f8e	68		pla		            PLA
.1a3f8f	28		plp		            PLP
.1a3f90	e2 20		sep #$20	            SEP #$20
.1a3f92	a9 01		lda #$01	            LDA #ERR_BREAK
.1a3f94	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3f98	c2 20		rep #$20	            REP #$20
.1a3f9a	29 ff 00	and #$00ff	            AND #$00FF
.1a3f9d	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a3fa0	e2 20		sep #$20	            SEP #$20
.1a3fa2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3fa5					S_REM
.1a3fa5	08		php		                PHP
.1a3fa6	e2 20		sep #$20	            SEP #$20
.1a3fa8	a7 00		lda [$0800]	rem_loop        LDA [BIP]
.1a3faa	f0 05		beq $1a3fb1	                BEQ done
.1a3fac	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a3faf	80 f7		bra $1a3fa8	                BRA rem_loop
.1a3fb1	28		plp		done            PLP
.1a3fb2	60		rts		            RTS
.1a3fb3					S_EXIT
.1a3fb3	08		php		                PHP
.1a3fb4	28		plp		                PLP
.1a3fb5	60		rts		            RTS
.1a3fb6					S_DO
.1a3fb6	08		php		                PHP
.1a3fb7	28		plp		                PLP
.1a3fb8	60		rts		            RTS
.0000					DO_RECORD
>0000					BIP             .dword  ?
>0004					CURLINE         .dword  ?
.1a3fb9					S_LOOP
.1a3fb9	08		php		                PHP
.1a3fba	28		plp		                PLP
.1a3fbb	60		rts		            RTS
.1a3fbc					S_FOR
.1a3fbc	08		php		                PHP
.1a3fbd	c2 20		rep #$20	            REP #$20
.1a3fbf	a5 1c		lda $081c	                LDA CURLINE+2
.1a3fc1	20 9f 1c	jsr $1a1c9f	            JSR PHRETURN
.1a3fc4	a5 1a		lda $081a	                LDA CURLINE
.1a3fc6	20 9f 1c	jsr $1a1c9f	            JSR PHRETURN
.1a3fc9	a5 02		lda $0802	                LDA BIP+2           ; Save current BIP
.1a3fcb	48		pha		                PHA
.1a3fcc	a5 00		lda $0800	                LDA BIP
.1a3fce	48		pha		                PHA
.1a3fcf	20 dc 1f	jsr $1a1fdc	            JSR SKIPSTMT
.1a3fd2	a5 02		lda $0802	                LDA BIP+2           ; Save the BIP for the next statement to the RETURN stack
.1a3fd4	20 9f 1c	jsr $1a1c9f	            JSR PHRETURN
.1a3fd7	a5 00		lda $0800	                LDA BIP
.1a3fd9	20 9f 1c	jsr $1a1c9f	            JSR PHRETURN
.1a3fdc	68		pla		                PLA                 ; Restore the original BIP
.1a3fdd	85 00		sta $0800	                STA BIP
.1a3fdf	68		pla		                PLA
.1a3fe0	85 02		sta $0802	                STA BIP+2
.1a3fe2	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a3fe5					get_name
.1a3fe5	20 cc 51	jsr $1a51cc	            JSR VAR_FINDNAME
.1a3fe8	b0 1f		bcs $1a4009	                BCS push_name       ; If we didn't find a name, thrown an error
.1a3fea	08		php		            PHP
.1a3feb	c2 20		rep #$20	            REP #$20
.1a3fed	48		pha		            PHA
.1a3fee	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3ff1	5b		tcd		            TCD
.1a3ff2	68		pla		            PLA
.1a3ff3	28		plp		            PLP
.1a3ff4	e2 20		sep #$20	            SEP #$20
.1a3ff6	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a3ff8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3ffc	c2 20		rep #$20	            REP #$20
.1a3ffe	29 ff 00	and #$00ff	            AND #$00FF
.1a4001	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4004	e2 20		sep #$20	            SEP #$20
.1a4006	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4009					push_name
.1a4009	e2 20		sep #$20	            SEP #$20
.1a400b	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; To the return stack
.1a400d	20 b6 1c	jsr $1a1cb6	            JSR PHRETURNB
.1a4010	a5 e9		lda $08e9	                LDA TOFIND+2
.1a4012	20 b6 1c	jsr $1a1cb6	            JSR PHRETURNB
.1a4015	c2 20		rep #$20	            REP #$20
.1a4017	a5 e7		lda $08e7	                LDA TOFIND
.1a4019	20 9f 1c	jsr $1a1c9f	            JSR PHRETURN
.1a401c					else
.1a401c	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a401f	e2 20		sep #$20	            SEP #$20
.1a4021	a7 00		lda [$0800]	                LDA [BIP]
.1a4023	c9 8a		cmp #$8a	                CMP #TOK_EQ
.1a4025	d0 6a		bne $1a4091	                BNE syntax_err      ; If not found: signal an syntax error
.1a4027	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Verify type of variable
.1a4029	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; Is it integer?
.1a402b	f0 04		beq $1a4031	                BEQ process_initial ; Yes: it's ok
.1a402d	c9 01		cmp #$01	                CMP #TYPE_FLOAT     ; Is it floating point?
.1a402f	f0 00		beq $1a4031	                BEQ process_initial ; Yes: it's ok
.1a4031					process_initial
.1a4031	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4034	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4037	20 2f 51	jsr $1a512f	            JSR VAR_SET
.1a403a	e2 20		sep #$20	            SEP #$20
.1a403c	a9 9c		lda #$9c	                LDA #TOK_TO         ; Expect the next token to be TO
.1a403e	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4041	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4044	c2 20		rep #$20	            REP #$20
.1a4046	a5 27		lda $0827	                LDA ARGTYPE1
.1a4048	20 9f 1c	jsr $1a1c9f	            JSR PHRETURN
.1a404b	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a404d	20 9f 1c	jsr $1a1c9f	            JSR PHRETURN
.1a4050	a5 23		lda $0823	                LDA ARGUMENT1
.1a4052	20 9f 1c	jsr $1a1c9f	            JSR PHRETURN
.1a4055	e2 20		sep #$20	            SEP #$20
.1a4057	a9 9d		lda #$9d	                LDA #TOK_STEP
.1a4059	85 37		sta $0837	                STA TARGETTOK
.1a405b	20 d9 20	jsr $1a20d9	            JSR OPT_TOK
.1a405e	90 1b		bcc $1a407b	                BCC default_inc     ; Not found: set a default increment of 1
.1a4060	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4063	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4066	e2 20		sep #$20	            SEP #$20
.1a4068	a5 27		lda $0827	                LDA ARGTYPE1        ; Push the result as the increment
.1a406a	20 9f 1c	jsr $1a1c9f	            JSR PHRETURN
.1a406d	c2 20		rep #$20	            REP #$20
.1a406f	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4071	20 9f 1c	jsr $1a1c9f	            JSR PHRETURN
.1a4074	a5 23		lda $0823	                LDA ARGUMENT1
.1a4076	20 9f 1c	jsr $1a1c9f	            JSR PHRETURN
.1a4079	80 14		bra $1a408f	                BRA done
.1a407b					default_inc
.1a407b	c2 20		rep #$20	            REP #$20
.1a407d	a9 00 00	lda #$0000	                LDA #TYPE_INTEGER
.1a4080	20 9f 1c	jsr $1a1c9f	            JSR PHRETURN
.1a4083	a9 00 00	lda #$0000	                LDA #0
.1a4086	20 9f 1c	jsr $1a1c9f	            JSR PHRETURN
.1a4089	a9 01 00	lda #$0001	                LDA #1
.1a408c	20 9f 1c	jsr $1a1c9f	            JSR PHRETURN
.1a408f	28		plp		done            PLP
.1a4090	60		rts		            RTS
.1a4091					syntax_err
.1a4091	08		php		            PHP
.1a4092	c2 20		rep #$20	            REP #$20
.1a4094	48		pha		            PHA
.1a4095	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4098	5b		tcd		            TCD
.1a4099	68		pla		            PLA
.1a409a	28		plp		            PLP
.1a409b	e2 20		sep #$20	            SEP #$20
.1a409d	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a409f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a40a3	c2 20		rep #$20	            REP #$20
.1a40a5	29 ff 00	and #$00ff	            AND #$00FF
.1a40a8	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a40ab	e2 20		sep #$20	            SEP #$20
.1a40ad	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.0000					FOR_RECORD
>0000					INCREMENT       .dword  ?
>0004					INCTYPE         .word   ?
>0006					FINAL           .dword  ?
>000a					FINALTYPE       .word   ?
>000c					VARIBLE         .dword  ?
>0010					VARTYPE         .word   ?
>0012					BIP             .dword  ?
>0016					CURLINE         .dword  ?
.1a40b0					S_NEXT
.1a40b0	08		php		                PHP
.1a40b1	8b		phb		                PHB
.1a40b2	08		php		            PHP
.1a40b3	e2 20		sep #$20	            SEP #$20
.1a40b5	48		pha		            PHA
.1a40b6	a9 00		lda #$00	            LDA #0
.1a40b8	48		pha		            PHA
.1a40b9	ab		plb		            PLB
.1a40ba	68		pla		            PLA
.1a40bb	28		plp		            PLP
.1a40bc	08		php		            PHP
.1a40bd	c2 20		rep #$20	            REP #$20
.1a40bf	48		pha		            PHA
.1a40c0	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a40c3	5b		tcd		            TCD
.1a40c4	68		pla		            PLA
.1a40c5	28		plp		            PLP
.1a40c6	c2 30		rep #$30	            REP #$30
.1a40c8	a4 33		ldy $0833	                LDY RETURNSP                    ; Y := pointer to first byte of the FOR record
.1a40ca	c8		iny		                INY                             ; RETURNSP points to the first free slot, so move up 2 bytes
.1a40cb	c8		iny		                INY
.1a40cc	c2 20		rep #$20	            REP #$20
.1a40ce	b9 0c 00	lda $000c,y	                LDA #FOR_RECORD.VARIBLE,B,Y     ; TOFIND := FOR_RECORD.VARIABLE
.1a40d1	85 e7		sta $08e7	                STA TOFIND
.1a40d3	b9 0e 00	lda $000e,y	                LDA #FOR_RECORD.VARIBLE+2,B,Y
.1a40d6	e2 20		sep #$20	            SEP #$20
.1a40d8	85 e9		sta $08e9	                STA TOFIND+2
.1a40da	b9 10 00	lda $0010,y	                LDA #FOR_RECORD.VARTYPE,B,Y
.1a40dd	85 ea		sta $08ea	                STA TOFINDTYPE
.1a40df	c2 20		rep #$20	            REP #$20
.1a40e1	5a		phy		                PHY
.1a40e2	20 cd 4f	jsr $1a4fcd	            JSR VAR_REF
.1a40e5	7a		ply		                PLY
.1a40e6	c2 20		rep #$20	            REP #$20
.1a40e8	b9 00 00	lda $0000,y	                LDA #FOR_RECORD.INCREMENT,B,Y   ; ARGUMENT2 := FOR_RECORD.INCREMENT
.1a40eb	85 29		sta $0829	                STA ARGUMENT2
.1a40ed	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y
.1a40f0	85 2b		sta $082b	                STA ARGUMENT2+2
.1a40f2	e2 20		sep #$20	            SEP #$20
.1a40f4	b9 04 00	lda $0004,y	                LDA #FOR_RECORD.INCTYPE,B,Y
.1a40f7	85 2d		sta $082d	                STA ARGTYPE2
.1a40f9	c2 20		rep #$20	            REP #$20
.1a40fb	5a		phy		                PHY
.1a40fc	20 56 26	jsr $1a2656	            JSR OP_PLUS
.1a40ff	20 2f 51	jsr $1a512f	            JSR VAR_SET
.1a4102	7a		ply		                PLY
.1a4103	c2 20		rep #$20	            REP #$20
.1a4105	b9 06 00	lda $0006,y	                LDA #FOR_RECORD.FINAL,B,Y       ; ARGUMENT2 := FOR_RECORD.FINAL
.1a4108	85 29		sta $0829	                STA ARGUMENT2
.1a410a	b9 08 00	lda $0008,y	                LDA #FOR_RECORD.FINAL+2,B,Y
.1a410d	85 2b		sta $082b	                STA ARGUMENT2+2
.1a410f	e2 20		sep #$20	            SEP #$20
.1a4111	b9 0a 00	lda $000a,y	                LDA #FOR_RECORD.FINALTYPE,B,Y
.1a4114	85 2d		sta $082d	                STA ARGTYPE2
.1a4116	c2 20		rep #$20	            REP #$20
.1a4118	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y ; Check the increment's sign
.1a411b	30 0a		bmi $1a4127	                BMI going_down
.1a411d					going_up
.1a411d	20 df 28	jsr $1a28df	            JSR OP_LTE
.1a4120	20 05 05	jsr $1a0505	            JSR IS_ARG1_Z
.1a4123	f0 28		beq $1a414d	                BEQ end_loop                    ; No: end the loop
.1a4125	80 08		bra $1a412f	                BRA loop_back                   ; Yes: loop back
.1a4127					going_down
.1a4127	20 9f 28	jsr $1a289f	            JSR OP_GTE
.1a412a	20 05 05	jsr $1a0505	            JSR IS_ARG1_Z
.1a412d	f0 1e		beq $1a414d	                BEQ end_loop                    ; No: end the loop
.1a412f					loop_back
.1a412f	c2 20		rep #$20	            REP #$20
.1a4131	b9 12 00	lda $0012,y	                LDA #FOR_RECORD.BIP,B,Y
.1a4134	85 00		sta $0800	                STA BIP
.1a4136	b9 14 00	lda $0014,y	                LDA #FOR_RECORD.BIP+2,B,Y
.1a4139	85 02		sta $0802	                STA BIP+2
.1a413b	b9 16 00	lda $0016,y	                LDA #FOR_RECORD.CURLINE,B,Y     ; CURLINE := FOR_RECORD.CURLINE
.1a413e	85 1a		sta $081a	                STA CURLINE
.1a4140	b9 18 00	lda $0018,y	                LDA #FOR_RECORD.CURLINE+2,B,Y
.1a4143	85 1c		sta $081c	                STA CURLINE+2
.1a4145	e2 20		sep #$20	            SEP #$20
.1a4147	a9 03		lda #$03	                LDA #EXEC_RETURN
.1a4149	85 dc		sta $08dc	                STA EXECACTION
.1a414b	80 17		bra $1a4164	                BRA done
.1a414d					end_loop
.1a414d	a2 23 08	ldx #$0823	                LDX #ARGUMENT1
.1a4150	20 a6 18	jsr $1a18a6	            JSR PLARGUMENT
.1a4153	c2 20		rep #$20	            REP #$20
.1a4155	18		clc		                CLC
.1a4156	a5 33		lda $0833	                LDA RETURNSP
.1a4158	69 1a 00	adc #$001a	                ADC #size(FOR_RECORD)           ; Move pointer by number of bytes in a FOR record
.1a415b	85 33		sta $0833	                STA RETURNSP
.1a415d	a5 35		lda $0835	                LDA RETURNSP+2
.1a415f	69 00 00	adc #$0000	                ADC #0
.1a4162	85 35		sta $0835	                STA RETURNSP+2
.1a4164	ab		plb		done            PLB
.1a4165	28		plp		                PLP
.1a4166	60		rts		            RTS
.1a4167					S_GOSUB
.1a4167	08		php		                PHP
.1a4168	a5 1a		lda $081a	                LDA CURLINE                 ; Save the current line for later
.1a416a	48		pha		                PHA
.1a416b	a5 1c		lda $081c	                LDA CURLINE+2
.1a416d	48		pha		                PHA
.1a416e	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a4171	20 c3 07	jsr $1a07c3	            JSR PARSEINT
.1a4174	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.1a4176	f0 26		beq $1a419e	                BEQ syntax_err              ; If 0, no number was found... syntax error
.1a4178	20 96 22	jsr $1a2296	            JSR FINDLINE
.1a417b	90 42		bcc $1a41bf	                BCC not_found               ; If not found... LINE NOT FOUND error
.1a417d	e2 20		sep #$20	            SEP #$20
.1a417f	a9 02		lda #$02	                LDA #EXEC_GOTO
.1a4181	85 dc		sta $08dc	                STA EXECACTION
.1a4183	20 dc 1f	jsr $1a1fdc	            JSR SKIPSTMT
.1a4186	c2 20		rep #$20	            REP #$20
.1a4188	68		pla		                PLA                         ; Save the old value of CURLINE to the RETURN stack
.1a4189	20 9f 1c	jsr $1a1c9f	            JSR PHRETURN
.1a418c	68		pla		                PLA
.1a418d	20 9f 1c	jsr $1a1c9f	            JSR PHRETURN
.1a4190	a5 02		lda $0802	                LDA BIP+2                   ; Save the BASIC Instruction Pointer to the RETURN stack
.1a4192	20 9f 1c	jsr $1a1c9f	            JSR PHRETURN
.1a4195	a5 00		lda $0800	                LDA BIP
.1a4197	20 9f 1c	jsr $1a1c9f	            JSR PHRETURN
.1a419a	e6 31		inc $0831	                INC GOSUBDEPTH              ; Increase the count of GOSUBs on the stack
.1a419c	28		plp		                PLP
.1a419d	60		rts		            RTS
.1a419e	68		pla		syntax_err      PLA
.1a419f	68		pla		                PLA
.1a41a0	08		php		            PHP
.1a41a1	c2 20		rep #$20	            REP #$20
.1a41a3	48		pha		            PHA
.1a41a4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a41a7	5b		tcd		            TCD
.1a41a8	68		pla		            PLA
.1a41a9	28		plp		            PLP
.1a41aa	e2 20		sep #$20	            SEP #$20
.1a41ac	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a41ae	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a41b2	c2 20		rep #$20	            REP #$20
.1a41b4	29 ff 00	and #$00ff	            AND #$00FF
.1a41b7	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a41ba	e2 20		sep #$20	            SEP #$20
.1a41bc	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a41bf	68		pla		not_found       PLA
.1a41c0	68		pla		                PLA
.1a41c1	08		php		            PHP
.1a41c2	c2 20		rep #$20	            REP #$20
.1a41c4	48		pha		            PHA
.1a41c5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a41c8	5b		tcd		            TCD
.1a41c9	68		pla		            PLA
.1a41ca	28		plp		            PLP
.1a41cb	e2 20		sep #$20	            SEP #$20
.1a41cd	a9 06		lda #$06	            LDA #ERR_NOLINE
.1a41cf	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a41d3	c2 20		rep #$20	            REP #$20
.1a41d5	29 ff 00	and #$00ff	            AND #$00FF
.1a41d8	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a41db	e2 20		sep #$20	            SEP #$20
.1a41dd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a41e0					S_RETURN
.1a41e0	08		php		                PHP
.1a41e1	c2 30		rep #$30	            REP #$30
.1a41e3	a5 31		lda $0831	                LDA GOSUBDEPTH              ; Check that there is at least on GOSUB on the stack
.1a41e5	f0 1e		beq $1a4205	                BEQ underflow               ; No? It's a stack underflow error
.1a41e7	20 c1 1c	jsr $1a1cc1	            JSR PLRETURN
.1a41ea	85 00		sta $0800	                STA BIP
.1a41ec	20 c1 1c	jsr $1a1cc1	            JSR PLRETURN
.1a41ef	85 02		sta $0802	                STA BIP+2
.1a41f1	20 c1 1c	jsr $1a1cc1	            JSR PLRETURN
.1a41f4	85 1a		sta $081a	                STA CURLINE
.1a41f6	20 c1 1c	jsr $1a1cc1	            JSR PLRETURN
.1a41f9	85 1c		sta $081c	                STA CURLINE+2
.1a41fb	c6 31		dec $0831	                DEC GOSUBDEPTH              ; Indicate we've popped that GOSUB off the stack
.1a41fd	e2 20		sep #$20	            SEP #$20
.1a41ff	a9 03		lda #$03	                LDA #EXEC_RETURN
.1a4201	85 dc		sta $08dc	                STA EXECACTION
.1a4203	28		plp		                PLP
.1a4204	60		rts		            RTS
.1a4205					underflow
.1a4205	08		php		            PHP
.1a4206	c2 20		rep #$20	            REP #$20
.1a4208	48		pha		            PHA
.1a4209	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a420c	5b		tcd		            TCD
.1a420d	68		pla		            PLA
.1a420e	28		plp		            PLP
.1a420f	e2 20		sep #$20	            SEP #$20
.1a4211	a9 07		lda #$07	            LDA #ERR_STACKUNDER
.1a4213	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4217	c2 20		rep #$20	            REP #$20
.1a4219	29 ff 00	and #$00ff	            AND #$00FF
.1a421c	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a421f	e2 20		sep #$20	            SEP #$20
.1a4221	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4224					S_IF
.1a4224	08		php		                PHP
.1a4225	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4228	20 05 05	jsr $1a0505	            JSR IS_ARG1_Z
.1a422b	f0 1c		beq $1a4249	                BEQ is_false                ; If so, handle the FALSE case
.1a422d	e2 20		sep #$20	            SEP #$20
.1a422f	a9 97		lda #$97	                LDA #TOK_THEN               ; Verify that the next token is THEN and eat it
.1a4231	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4234	20 c3 07	jsr $1a07c3	            JSR PARSEINT
.1a4237	20 05 05	jsr $1a0505	            JSR IS_ARG1_Z
.1a423a	f0 12		beq $1a424e	                BEQ syntax_err              ; If not, we have a syntax error
.1a423c	20 96 22	jsr $1a2296	            JSR FINDLINE
.1a423f	90 2c		bcc $1a426d	                BCC not_found               ; If not found... LINE NOT FOUND error
.1a4241	e2 20		sep #$20	            SEP #$20
.1a4243	a9 02		lda #$02	                LDA #EXEC_GOTO
.1a4245	85 dc		sta $08dc	                STA EXECACTION
.1a4247	80 03		bra $1a424c	                BRA done
.1a4249					is_false
.1a4249	20 dc 1f	jsr $1a1fdc	            JSR SKIPSTMT
.1a424c	28		plp		done            PLP
.1a424d	60		rts		            RTS
.1a424e					syntax_err
.1a424e	08		php		            PHP
.1a424f	c2 20		rep #$20	            REP #$20
.1a4251	48		pha		            PHA
.1a4252	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4255	5b		tcd		            TCD
.1a4256	68		pla		            PLA
.1a4257	28		plp		            PLP
.1a4258	e2 20		sep #$20	            SEP #$20
.1a425a	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a425c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4260	c2 20		rep #$20	            REP #$20
.1a4262	29 ff 00	and #$00ff	            AND #$00FF
.1a4265	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4268	e2 20		sep #$20	            SEP #$20
.1a426a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a426d					not_found
.1a426d	08		php		            PHP
.1a426e	c2 20		rep #$20	            REP #$20
.1a4270	48		pha		            PHA
.1a4271	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4274	5b		tcd		            TCD
.1a4275	68		pla		            PLA
.1a4276	28		plp		            PLP
.1a4277	e2 20		sep #$20	            SEP #$20
.1a4279	a9 06		lda #$06	            LDA #ERR_NOLINE
.1a427b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a427f	c2 20		rep #$20	            REP #$20
.1a4281	29 ff 00	and #$00ff	            AND #$00FF
.1a4284	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4287	e2 20		sep #$20	            SEP #$20
.1a4289	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a428c					S_END
.1a428c	08		php		                PHP
.1a428d	e2 20		sep #$20	            SEP #$20
.1a428f	a9 01		lda #$01	                LDA #EXEC_STOP
.1a4291	85 dc		sta $08dc	                STA EXECACTION
.1a4293	28		plp		                PLP
.1a4294	60		rts		            RTS
.1a4295					S_GOTO
.1a4295	08		php		                PHP
.1a4296	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a4299	20 c3 07	jsr $1a07c3	            JSR PARSEINT
.1a429c	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.1a429e	f0 0d		beq $1a42ad	                BEQ syntax_err              ; If 0, no number was found... syntax error
.1a42a0	20 96 22	jsr $1a2296	            JSR FINDLINE
.1a42a3	90 27		bcc $1a42cc	                BCC not_found               ; If not found... LINE NOT FOUND error
.1a42a5	e2 20		sep #$20	            SEP #$20
.1a42a7	a9 02		lda #$02	                LDA #EXEC_GOTO
.1a42a9	85 dc		sta $08dc	                STA EXECACTION
.1a42ab	28		plp		                PLP
.1a42ac	60		rts		            RTS
.1a42ad					syntax_err
.1a42ad	08		php		            PHP
.1a42ae	c2 20		rep #$20	            REP #$20
.1a42b0	48		pha		            PHA
.1a42b1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a42b4	5b		tcd		            TCD
.1a42b5	68		pla		            PLA
.1a42b6	28		plp		            PLP
.1a42b7	e2 20		sep #$20	            SEP #$20
.1a42b9	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a42bb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a42bf	c2 20		rep #$20	            REP #$20
.1a42c1	29 ff 00	and #$00ff	            AND #$00FF
.1a42c4	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a42c7	e2 20		sep #$20	            SEP #$20
.1a42c9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a42cc					not_found
.1a42cc	08		php		            PHP
.1a42cd	c2 20		rep #$20	            REP #$20
.1a42cf	48		pha		            PHA
.1a42d0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a42d3	5b		tcd		            TCD
.1a42d4	68		pla		            PLA
.1a42d5	28		plp		            PLP
.1a42d6	e2 20		sep #$20	            SEP #$20
.1a42d8	a9 06		lda #$06	            LDA #ERR_NOLINE
.1a42da	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a42de	c2 20		rep #$20	            REP #$20
.1a42e0	29 ff 00	and #$00ff	            AND #$00FF
.1a42e3	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a42e6	e2 20		sep #$20	            SEP #$20
.1a42e8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a42eb					S_CLR
.1a42eb	20 48 18	jsr $1a1848	            JSR INITEVALSP
.1a42ee	20 91 0f	jsr $1a0f91	            JSR INITHEAP
.1a42f1	20 cc 4e	jsr $1a4ecc	            JSR INITVARS
.1a42f4	60		rts		            RTS
.1a42f5					S_LET
.1a42f5	08		php		                PHP
.1a42f6	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.1a42f8	10 03		bpl $1a42fd	                BPL get_name        ; If it's not a token, try to find the variable name
.1a42fa	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a42fd					get_name
.1a42fd	20 cc 51	jsr $1a51cc	            JSR VAR_FINDNAME
.1a4300	b0 03		bcs $1a4305	                BCS check_array     ; If we didn't find a name, thrown an error
.1a4302	4c 6c 43	jmp $1a436c	                JMP syntax_err
.1a4305					check_array
.1a4305	e2 20		sep #$20	            SEP #$20
.1a4307	20 f8 20	jsr $1a20f8	            JSR PEEK_TOK
.1a430a	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it a "("
.1a430c	d0 0e		bne $1a431c	                BNE get_value       ; No: it's a scalar assignment, look for the "="
.1a430e	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4310	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4313	a9 00		lda #$00	                LDA #0
.1a4315	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF     ; Blank out the array index buffer
.1a4319	20 ca 19	jsr $1a19ca	            JSR ARR_GETIDX
.1a431c					get_value
.1a431c	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a431f	e2 20		sep #$20	            SEP #$20
.1a4321	a7 00		lda [$0800]	                LDA [BIP]
.1a4323	c9 8a		cmp #$8a	                CMP #TOK_EQ
.1a4325	f0 03		beq $1a432a	                BEQ found_eq        ; If not found: signal an syntax error
.1a4327	4c 6c 43	jmp $1a436c	                JMP syntax_err
.1a432a					found_eq
.1a432a	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a432d	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Save the variable name for later
.1a432f	48		pha		                PHA                 ; (it will get over-written by variable references)
.1a4330	a5 e9		lda $08e9	                LDA TOFIND+2
.1a4332	48		pha		                PHA
.1a4333	a5 e8		lda $08e8	                LDA TOFIND+1
.1a4335	48		pha		                PHA
.1a4336	a5 e7		lda $08e7	                LDA TOFIND
.1a4338	48		pha		                PHA
.1a4339	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a433c	68		pla		                PLA                 ; Restore the variable name
.1a433d	85 e7		sta $08e7	                STA TOFIND
.1a433f	68		pla		                PLA
.1a4340	85 e8		sta $08e8	                STA TOFIND+1
.1a4342	68		pla		                PLA
.1a4343	85 e9		sta $08e9	                STA TOFIND+2
.1a4345	68		pla		                PLA
.1a4346	85 ea		sta $08ea	                STA TOFINDTYPE
.1a4348	29 80		and #$80	                AND #$80            ; Is it an array we're setting?
.1a434a	f0 1b		beq $1a4367	                BEQ set_scalar      ; No: do a scalar variable set
.1a434c	20 3f 4f	jsr $1a4f3f	            JSR VAR_FIND
.1a434f	90 3a		bcc $1a438b	                BCC notfound_err
.1a4351	c2 20		rep #$20	            REP #$20
.1a4353	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.1a4356	b7 08		lda [$0808],y	                LDA [INDEX],Y       ; Save the pointer to the array to CURRBLOCK
.1a4358	85 c0		sta $08c0	                STA CURRBLOCK
.1a435a	e2 20		sep #$20	            SEP #$20
.1a435c	c8		iny		                INY
.1a435d	c8		iny		                INY
.1a435e	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a4360	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a4362	20 2b 66	jsr $1a662b	            JSR ARR_SET
.1a4365	80 03		bra $1a436a	                BRA done            ; and we're finished!
.1a4367					set_scalar
.1a4367	20 2f 51	jsr $1a512f	            JSR VAR_SET
.1a436a					done
.1a436a	28		plp		                PLP
.1a436b	60		rts		            RTS
.1a436c					syntax_err
.1a436c	08		php		            PHP
.1a436d	c2 20		rep #$20	            REP #$20
.1a436f	48		pha		            PHA
.1a4370	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4373	5b		tcd		            TCD
.1a4374	68		pla		            PLA
.1a4375	28		plp		            PLP
.1a4376	e2 20		sep #$20	            SEP #$20
.1a4378	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a437a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a437e	c2 20		rep #$20	            REP #$20
.1a4380	29 ff 00	and #$00ff	            AND #$00FF
.1a4383	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4386	e2 20		sep #$20	            SEP #$20
.1a4388	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a438b					notfound_err
.1a438b	08		php		            PHP
.1a438c	c2 20		rep #$20	            REP #$20
.1a438e	48		pha		            PHA
.1a438f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4392	5b		tcd		            TCD
.1a4393	68		pla		            PLA
.1a4394	28		plp		            PLP
.1a4395	e2 20		sep #$20	            SEP #$20
.1a4397	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a4399	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a439d	c2 20		rep #$20	            REP #$20
.1a439f	29 ff 00	and #$00ff	            AND #$00FF
.1a43a2	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a43a5	e2 20		sep #$20	            SEP #$20
.1a43a7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a43aa					S_PRINT
.1a43aa	08		php		                PHP
.1a43ab	e2 20		sep #$20	            SEP #$20
.1a43ad	20 f8 20	jsr $1a20f8	            JSR PEEK_TOK
.1a43b0	c9 00		cmp #$00	                CMP #0              ; Is it EOL or :?
.1a43b2	f0 6d		beq $1a4421	                BEQ pr_nl_exit      ; Yes: just print return
.1a43b4					pr_loop
.1a43b4	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a43b7	e2 20		sep #$20	            SEP #$20
.1a43b9	a5 27		lda $0827	                LDA ARGTYPE1        ; Get the type of the result
.1a43bb	c9 ff		cmp #$ff	                CMP #TYPE_NAV       ; Is is NAV?
.1a43bd	f0 1b		beq $1a43da	                BEQ check_nl        ; Yes: we are probably just printing a newline
.1a43bf	c9 02		cmp #$02	                CMP #TYPE_STRING    ; Is it a string?
.1a43c1	d0 05		bne $1a43c8	                BNE check_int       ; No: check to see if it's an integer
.1a43c3	20 26 44	jsr $1a4426	            JSR PR_STRING
.1a43c6	80 12		bra $1a43da	                BRA check_nl
.1a43c8	c9 00		cmp #$00	check_int       CMP #TYPE_INTEGER   ; Is it an integer?
.1a43ca	d0 05		bne $1a43d1	                BNE check_float     ; No: check to see if it is a float
.1a43cc	20 46 44	jsr $1a4446	            JSR PR_INTEGER
.1a43cf	80 09		bra $1a43da	                BRA check_nl
.1a43d1	c9 01		cmp #$01	check_float     CMP #TYPE_FLOAT     ; Is it a float?
.1a43d3	d0 4f		bne $1a4424	                BNE done            ; No: just quit
.1a43d5	20 59 44	jsr $1a4459	            JSR PR_FLOAT
.1a43d8	80 00		bra $1a43da	                BRA check_nl
.1a43da					check_nl
.1a43da	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a43dd	a7 00		lda [$0800]	                LDA [BIP]
.1a43df	f0 40		beq $1a4421	                BEQ pr_nl_exit      ; If it's nul, print a newline and return
.1a43e1	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.1a43e3	f0 3c		beq $1a4421	                BEQ pr_nl_exit      ; print a newline and return
.1a43e5	c9 2c		cmp #$2c	                CMP #','            ; If it's a comma
.1a43e7	f0 23		beq $1a440c	                BEQ pr_comma        ; Print a TAB and try another expression
.1a43e9	c9 3b		cmp #$3b	                CMP #';'            ; If it's a semicolon...
.1a43eb	f0 24		beq $1a4411	                BEQ is_more         ; Print nothing, and try another expression
.1a43ed	08		php		            PHP
.1a43ee	c2 20		rep #$20	            REP #$20
.1a43f0	48		pha		            PHA
.1a43f1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a43f4	5b		tcd		            TCD
.1a43f5	68		pla		            PLA
.1a43f6	28		plp		            PLP
.1a43f7	e2 20		sep #$20	            SEP #$20
.1a43f9	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a43fb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a43ff	c2 20		rep #$20	            REP #$20
.1a4401	29 ff 00	and #$00ff	            AND #$00FF
.1a4404	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4407	e2 20		sep #$20	            SEP #$20
.1a4409	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a440c	a9 09		lda #$09	pr_comma        LDA #CHAR_TAB       ; Print a TAB
.1a440e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a4411					is_more
.1a4411	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4414	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a4417	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.1a4419	f0 09		beq $1a4424	                BEQ done            ; If it's NULL, return without printing a newline
.1a441b	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.1a441d	f0 05		beq $1a4424	                BEQ done            ; ... return without printing a newline
.1a441f	80 93		bra $1a43b4	                BRA pr_loop         ; Otherwise, we should have another expression, try to handle it
.1a4421					pr_nl_exit
.1a4421	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a4424	28		plp		done            PLP
.1a4425	60		rts		            RTS
.1a4426					PR_STRING
.1a4426	08		php		                PHP
.1a4427	8b		phb		                PHB
.1a4428	08		php		            PHP
.1a4429	c2 20		rep #$20	            REP #$20
.1a442b	48		pha		            PHA
.1a442c	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a442f	5b		tcd		            TCD
.1a4430	68		pla		            PLA
.1a4431	28		plp		            PLP
.1a4432	e2 20		sep #$20	            SEP #$20
.1a4434	c2 10		rep #$10	            REP #$10
.1a4436	a0 00 00	ldy #$0000	                LDY #0
.1a4439	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y
.1a443b	f0 06		beq $1a4443	                BEQ done
.1a443d	20 18 00	jsr $1a0018	            JSR PRINTC
.1a4440	c8		iny		                INY
.1a4441	80 f6		bra $1a4439	                BRA loop
.1a4443	ab		plb		done            PLB
.1a4444	28		plp		                PLP
.1a4445	60		rts		            RTS
.1a4446					PR_INTEGER
.1a4446	08		php		                PHP
.1a4447	c2 20		rep #$20	            REP #$20
.1a4449	20 46 14	jsr $1a1446	            JSR ITOS
.1a444c	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.1a444e	85 23		sta $0823	                STA ARGUMENT1
.1a4450	a5 18		lda $0818	                LDA STRPTR+2
.1a4452	85 25		sta $0825	                STA ARGUMENT1+2
.1a4454	20 26 44	jsr $1a4426	            JSR PR_STRING
.1a4457	28		plp		                PLP
.1a4458	60		rts		            RTS
.1a4459					PR_FLOAT
.1a4459	08		php		                PHP
.1a445a	20 95 5b	jsr $1a5b95	            JSR FTOS
.1a445d	c2 20		rep #$20	            REP #$20
.1a445f	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.1a4461	85 23		sta $0823	                STA ARGUMENT1
.1a4463	a5 18		lda $0818	                LDA STRPTR+2
.1a4465	85 25		sta $0825	                STA ARGUMENT1+2
.1a4467	20 26 44	jsr $1a4426	            JSR PR_STRING
.1a446a	28		plp		                PLP
.1a446b	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\functions.s


;******  Processing file: src\C256/functions_c256.s

.1a446c					BCD2STR
.1a446c	08		php		            PHP
.1a446d	e2 20		sep #$20	            SEP #$20
.1a446f	85 b5		sta $08b5	            STA SAVE_A
.1a4471	4a		lsr a		            LSR A
.1a4472	4a		lsr a		            LSR A
.1a4473	4a		lsr a		            LSR A
.1a4474	4a		lsr a		            LSR A
.1a4475	29 0f		and #$0f	            AND #$0F
.1a4477	18		clc		            CLC
.1a4478	69 30		adc #$30	            ADC #'0'
.1a447a	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a447c	c8		iny		            INY
.1a447d	a5 b5		lda $08b5	            LDA SAVE_A
.1a447f	29 0f		and #$0f	            AND #$0F
.1a4481	18		clc		            CLC
.1a4482	69 30		adc #$30	            ADC #'0'
.1a4484	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a4486	c8		iny		            INY
.1a4487	28		plp		            PLP
.1a4488	60		rts		            RTS
.1a4489					F_GETDATE
.1a4489	e2 20		sep #$20	            SEP #$20
.1a448b	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a448d	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4490	08		php		            PHP
.1a4491	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4494	e2 20		sep #$20	            SEP #$20
.1a4496	c2 10		rep #$10	            REP #$10
.1a4498	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a449c	09 08		ora #$08	            ORA #%00001000
.1a449e	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a44a2	20 e7 13	jsr $1a13e7	            JSR TEMPSTRING
.1a44a5	a0 00 00	ldy #$0000	            LDY #0
.1a44a8	af 06 08 af	lda $af0806	            LDA @lRTC_DAY           ; Write the day of the month
.1a44ac	20 6c 44	jsr $1a446c	            JSR BCD2STR
.1a44af	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.1a44b1	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a44b3	c8		iny		            INY
.1a44b4	af 09 08 af	lda $af0809	            LDA @lRTC_MONTH         ; Write the month
.1a44b8	20 6c 44	jsr $1a446c	            JSR BCD2STR
.1a44bb	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.1a44bd	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a44bf	c8		iny		            INY
.1a44c0	af 0f 08 af	lda $af080f	            LDA @lRTC_CENTURY       ; Write the year
.1a44c4	20 6c 44	jsr $1a446c	            JSR BCD2STR
.1a44c7	af 0a 08 af	lda $af080a	            LDA @lRTC_YEAR          ; Write the year
.1a44cb	20 6c 44	jsr $1a446c	            JSR BCD2STR
.1a44ce	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.1a44d0	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a44d2	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a44d6	29 f7		and #$f7	            AND #%11110111
.1a44d8	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a44dc	c2 20		rep #$20	            REP #$20
.1a44de	a5 16		lda $0816	            LDA STRPTR
.1a44e0	85 23		sta $0823	            STA ARGUMENT1
.1a44e2	a5 18		lda $0818	            LDA STRPTR+2
.1a44e4	85 25		sta $0825	            STA ARGUMENT1+2
.1a44e6	e2 20		sep #$20	            SEP #$20
.1a44e8	a9 02		lda #$02	            LDA #TYPE_STRING
.1a44ea	85 27		sta $0827	            STA ARGTYPE1
.1a44ec	28		plp		            PLP
.1a44ed	e2 20		sep #$20	            SEP #$20
.1a44ef	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a44f2	60		rts		            RTS
.1a44f3					F_GETTIME
.1a44f3	e2 20		sep #$20	            SEP #$20
.1a44f5	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a44f7	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a44fa	08		php		            PHP
.1a44fb	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a44fe	e2 20		sep #$20	            SEP #$20
.1a4500	c2 10		rep #$10	            REP #$10
.1a4502	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a4506	09 08		ora #$08	            ORA #%00001000
.1a4508	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a450c	20 e7 13	jsr $1a13e7	            JSR TEMPSTRING
.1a450f	a0 00 00	ldy #$0000	            LDY #0
.1a4512	af 04 08 af	lda $af0804	            LDA @lRTC_HRS           ; Write the hour
.1a4516	29 7f		and #$7f	            AND #$7F                ; Trim out the AM/PM indicator
.1a4518	20 6c 44	jsr $1a446c	            JSR BCD2STR
.1a451b	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.1a451d	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a451f	c8		iny		            INY
.1a4520	af 02 08 af	lda $af0802	            LDA @lRTC_MIN           ; Write the minute
.1a4524	20 6c 44	jsr $1a446c	            JSR BCD2STR
.1a4527	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.1a4529	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a452b	c8		iny		            INY
.1a452c	af 00 08 af	lda $af0800	            LDA @lRTC_SEC           ; Write the second
.1a4530	20 6c 44	jsr $1a446c	            JSR BCD2STR
.1a4533	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.1a4535	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a4537	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a453b	29 f7		and #$f7	            AND #%11110111
.1a453d	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a4541	c2 20		rep #$20	            REP #$20
.1a4543	a5 16		lda $0816	            LDA STRPTR
.1a4545	85 23		sta $0823	            STA ARGUMENT1
.1a4547	a5 18		lda $0818	            LDA STRPTR+2
.1a4549	85 25		sta $0825	            STA ARGUMENT1+2
.1a454b	e2 20		sep #$20	            SEP #$20
.1a454d	a9 02		lda #$02	            LDA #TYPE_STRING
.1a454f	85 27		sta $0827	            STA ARGTYPE1
.1a4551	28		plp		            PLP
.1a4552	e2 20		sep #$20	            SEP #$20
.1a4554	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4557	60		rts		            RTS
.1a4558					FN_RND
.1a4558	e2 20		sep #$20	            SEP #$20
.1a455a	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a455c	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a455f	08		php		            PHP
.1a4560	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4563	e2 20		sep #$20	            SEP #$20
.1a4565	a9 01		lda #$01	            LDA #TYPE_FLOAT             ; We'll return a floating point number
.1a4567	85 27		sta $0827	            STA ARGTYPE1
.1a4569	a9 03		lda #$03	            LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.1a456b	8f 00 e2 af	sta $afe200	            STA @l FP_MATH_CTRL0        ; Expect fixed point numbers
.1a456f	a9 01		lda #$01	            LDA #FP_OUT_DIV             ; Set us to do a division
.1a4571	8f 01 e2 af	sta $afe201	            STA @l FP_MATH_CTRL1
.1a4575	c2 30		rep #$30	            REP #$30
.1a4577	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get a random 16-bits
.1a457b	8f 08 e2 af	sta $afe208	            STA @l FP_MATH_INPUT0_LL    ; Send them to the FP unit
.1a457f	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get another random 16-bits
.1a4583	29 ff 7f	and #$7fff	            AND #$7FFF                  ; Make sure it's positive
.1a4586	8f 0a e2 af	sta $afe20a	            STA @l FP_MATH_INPUT0_LL+2  ; Send them to the FP unit
.1a458a	a9 ff ff	lda #$ffff	            LDA #$FFFF                  ; Get the maximum value
.1a458d	8f 0c e2 af	sta $afe20c	            STA @l FP_MATH_INPUT1_LL    ; Send it to the FP unit
.1a4591	a9 ff 7f	lda #$7fff	            LDA #$7FFF
.1a4594	8f 0e e2 af	sta $afe20e	            STA @l FP_MATH_INPUT1_LL+2
.1a4598	ea		nop		            NOP
.1a4599	ea		nop		            NOP
.1a459a	ea		nop		            NOP
.1a459b	af 08 e2 af	lda $afe208	            LDA @l FP_MATH_OUTPUT_FP_LL     ; Get the normalized result
.1a459f	85 23		sta $0823	            STA ARGUMENT1
.1a45a1	af 0a e2 af	lda $afe20a	            LDA @l FP_MATH_OUTPUT_FP_LL+2
.1a45a5	85 25		sta $0825	            STA ARGUMENT1+2
.1a45a7	28		plp		            PLP
.1a45a8	e2 20		sep #$20	            SEP #$20
.1a45aa	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a45ad	60		rts		            RTS

;******  Return to file: src\functions.s

.1a45ae					FN_MID
.1a45ae	e2 20		sep #$20	            SEP #$20
.1a45b0	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a45b2	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a45b5	08		php		                PHP
.1a45b6	c2 30		rep #$30	            REP #$30
.1a45b8	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a45bb	20 ce 05	jsr $1a05ce	            JSR ASS_ARG1_STR
.1a45be					save_string
.1a45be	c2 20		rep #$20	            REP #$20
.1a45c0	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.1a45c2	48		pha		                PHA
.1a45c3	a5 23		lda $0823	                LDA ARGUMENT1
.1a45c5	48		pha		                PHA
.1a45c6	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a45c9	e2 20		sep #$20	            SEP #$20
.1a45cb	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a45cd	c9 2c		cmp #$2c	                CMP #','
.1a45cf	f0 03		beq $1a45d4	                BEQ skip_comma1
.1a45d1	4c 25 46	jmp $1a4625	                JMP syntax_err
.1a45d4					skip_comma1
.1a45d4	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a45d7	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a45da	20 f8 05	jsr $1a05f8	            JSR ASS_ARG1_INT16
.1a45dd	c2 20		rep #$20	            REP #$20
.1a45df	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the index
.1a45e1	48		pha		                PHA
.1a45e2	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a45e5	e2 20		sep #$20	            SEP #$20
.1a45e7	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a45e9	c9 2c		cmp #$2c	                CMP #','
.1a45eb	f0 03		beq $1a45f0	                BEQ skip_comma2
.1a45ed	4c 25 46	jmp $1a4625	                JMP syntax_err
.1a45f0					skip_comma2
.1a45f0	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a45f3	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a45f6	20 f8 05	jsr $1a05f8	            JSR ASS_ARG1_INT16
.1a45f9	c2 20		rep #$20	            REP #$20
.1a45fb	a5 23		lda $0823	            LDA ARGUMENT1
.1a45fd	85 8f		sta $088f	            STA MCOUNT
.1a45ff	e2 20		sep #$20	            SEP #$20
.1a4601	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a4603	85 91		sta $0891	            STA MCOUNT+2
.1a4605	c2 20		rep #$20	            REP #$20
.1a4607	68		pla		                PLA                         ; Restore index
.1a4608	85 29		sta $0829	                STA ARGUMENT2               ; ... to ARGUMENT2
.1a460a	a9 00 00	lda #$0000	                LDA #0
.1a460d	85 2b		sta $082b	                STA ARGUMENT2+2
.1a460f	68		pla		                PLA                         ; Restore string
.1a4610	85 23		sta $0823	                STA ARGUMENT1               ; ... to ARGUMENT1
.1a4612	68		pla		                PLA
.1a4613	85 25		sta $0825	                STA ARGUMENT1+2
.1a4615	e2 20		sep #$20	            SEP #$20
.1a4617	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a4619	85 27		sta $0827	            STA ARGTYPE1
.1a461b	20 3f 16	jsr $1a163f	            JSR STRSUBSTR
.1a461e					done
.1a461e	e2 20		sep #$20	            SEP #$20
.1a4620	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4623	28		plp		                PLP
.1a4624	60		rts		            RTS
.1a4625					syntax_err
.1a4625	08		php		            PHP
.1a4626	c2 20		rep #$20	            REP #$20
.1a4628	48		pha		            PHA
.1a4629	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a462c	5b		tcd		            TCD
.1a462d	68		pla		            PLA
.1a462e	28		plp		            PLP
.1a462f	e2 20		sep #$20	            SEP #$20
.1a4631	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4633	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4637	c2 20		rep #$20	            REP #$20
.1a4639	29 ff 00	and #$00ff	            AND #$00FF
.1a463c	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a463f	e2 20		sep #$20	            SEP #$20
.1a4641	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4644					range_err
.1a4644	08		php		            PHP
.1a4645	c2 20		rep #$20	            REP #$20
.1a4647	48		pha		            PHA
.1a4648	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a464b	5b		tcd		            TCD
.1a464c	68		pla		            PLA
.1a464d	28		plp		            PLP
.1a464e	e2 20		sep #$20	            SEP #$20
.1a4650	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4652	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4656	c2 20		rep #$20	            REP #$20
.1a4658	29 ff 00	and #$00ff	            AND #$00FF
.1a465b	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a465e	e2 20		sep #$20	            SEP #$20
.1a4660	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4663					FN_RIGHT
.1a4663	e2 20		sep #$20	            SEP #$20
.1a4665	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4667	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a466a	08		php		                PHP
.1a466b	c2 30		rep #$30	            REP #$30
.1a466d	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4670	e2 20		sep #$20	            SEP #$20
.1a4672	a5 27		lda $0827	                LDA ARGTYPE1
.1a4674	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4676	f0 03		beq $1a467b	                BEQ save_string
.1a4678	4c e7 46	jmp $1a46e7	                JMP type_mismatch           ; Type mismatch if it's not a string
.1a467b					save_string
.1a467b	c2 20		rep #$20	            REP #$20
.1a467d	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.1a467f	48		pha		                PHA
.1a4680	a5 23		lda $0823	                LDA ARGUMENT1
.1a4682	48		pha		                PHA
.1a4683	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a4686	e2 20		sep #$20	            SEP #$20
.1a4688	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a468a	c9 2c		cmp #$2c	                CMP #','
.1a468c	f0 03		beq $1a4691	                BEQ skip_comma
.1a468e	4c 06 47	jmp $1a4706	                JMP syntax_err
.1a4691					skip_comma
.1a4691	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4694	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4697	e2 20		sep #$20	            SEP #$20
.1a4699	a5 27		lda $0827	                LDA ARGTYPE1
.1a469b	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a469d	d0 48		bne $1a46e7	                BNE type_mismatch           ; Type mismatch if it's not an integer
.1a469f	c2 20		rep #$20	            REP #$20
.1a46a1	a5 23		lda $0823	            LDA ARGUMENT1
.1a46a3	85 8f		sta $088f	            STA MCOUNT
.1a46a5	c2 20		rep #$20	            REP #$20
.1a46a7	68		pla		                PLA                         ; Recover the string pointer
.1a46a8	85 23		sta $0823	                STA ARGUMENT1
.1a46aa	68		pla		                PLA
.1a46ab	85 25		sta $0825	                STA ARGUMENT1+2
.1a46ad	e2 20		sep #$20	            SEP #$20
.1a46af	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a46b1	85 27		sta $0827	            STA ARGTYPE1
.1a46b3	e2 20		sep #$20	            SEP #$20
.1a46b5	a0 00 00	ldy #$0000	                LDY #0
.1a46b8	b7 23		lda [$0823],y	count_loop      LDA [ARGUMENT1],Y
.1a46ba	f0 03		beq $1a46bf	                BEQ count_done
.1a46bc	c8		iny		                INY
.1a46bd	80 f9		bra $1a46b8	                BRA count_loop
.1a46bf					count_done
.1a46bf	c2 20		rep #$20	            REP #$20
.1a46c1	98		tya		                TYA                         ; ARGUMENT2 := LENGTH - MCOUNT
.1a46c2	38		sec		                SEC
.1a46c3	e5 8f		sbc $088f	                SBC MCOUNT
.1a46c5	30 09		bmi $1a46d0	                BMI index0                  ; if ARGUMENT2 < 0, set ARGUMENT2 := 0
.1a46c7	85 29		sta $0829	                STA ARGUMENT2
.1a46c9	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT2[23..16] := 0
.1a46cc	85 2b		sta $082b	                STA ARGUMENT2+2
.1a46ce	80 07		bra $1a46d7	                BRA slice
.1a46d0	a9 00 00	lda #$0000	index0          LDA #0                      ; 0 is the floor for the index
.1a46d3	85 29		sta $0829	                STA ARGUMENT2
.1a46d5	85 2b		sta $082b	                STA ARGUMENT2+2
.1a46d7					slice
.1a46d7	e2 20		sep #$20	            SEP #$20
.1a46d9	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a46db	85 2d		sta $082d	            STA ARGTYPE2
.1a46dd	20 3f 16	jsr $1a163f	            JSR STRSUBSTR
.1a46e0					done
.1a46e0	e2 20		sep #$20	            SEP #$20
.1a46e2	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a46e5	28		plp		                PLP
.1a46e6	60		rts		            RTS
.1a46e7					type_mismatch
.1a46e7	08		php		            PHP
.1a46e8	c2 20		rep #$20	            REP #$20
.1a46ea	48		pha		            PHA
.1a46eb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a46ee	5b		tcd		            TCD
.1a46ef	68		pla		            PLA
.1a46f0	28		plp		            PLP
.1a46f1	e2 20		sep #$20	            SEP #$20
.1a46f3	a9 04		lda #$04	            LDA #ERR_TYPE
.1a46f5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a46f9	c2 20		rep #$20	            REP #$20
.1a46fb	29 ff 00	and #$00ff	            AND #$00FF
.1a46fe	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4701	e2 20		sep #$20	            SEP #$20
.1a4703	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4706					syntax_err
.1a4706	08		php		            PHP
.1a4707	c2 20		rep #$20	            REP #$20
.1a4709	48		pha		            PHA
.1a470a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a470d	5b		tcd		            TCD
.1a470e	68		pla		            PLA
.1a470f	28		plp		            PLP
.1a4710	e2 20		sep #$20	            SEP #$20
.1a4712	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4714	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4718	c2 20		rep #$20	            REP #$20
.1a471a	29 ff 00	and #$00ff	            AND #$00FF
.1a471d	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4720	e2 20		sep #$20	            SEP #$20
.1a4722	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4725					range_err
.1a4725	08		php		            PHP
.1a4726	c2 20		rep #$20	            REP #$20
.1a4728	48		pha		            PHA
.1a4729	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a472c	5b		tcd		            TCD
.1a472d	68		pla		            PLA
.1a472e	28		plp		            PLP
.1a472f	e2 20		sep #$20	            SEP #$20
.1a4731	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4733	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4737	c2 20		rep #$20	            REP #$20
.1a4739	29 ff 00	and #$00ff	            AND #$00FF
.1a473c	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a473f	e2 20		sep #$20	            SEP #$20
.1a4741	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4744					FN_LEFT
.1a4744	e2 20		sep #$20	            SEP #$20
.1a4746	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4748	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a474b	08		php		                PHP
.1a474c	c2 30		rep #$30	            REP #$30
.1a474e	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4751	e2 20		sep #$20	            SEP #$20
.1a4753	a5 27		lda $0827	                LDA ARGTYPE1
.1a4755	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4757	f0 03		beq $1a475c	                BEQ save_string
.1a4759	4c b0 47	jmp $1a47b0	                JMP type_mismatch           ; Type mismatch if it's not a string
.1a475c					save_string
.1a475c	c2 20		rep #$20	            REP #$20
.1a475e	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.1a4760	48		pha		                PHA
.1a4761	a5 23		lda $0823	                LDA ARGUMENT1
.1a4763	48		pha		                PHA
.1a4764	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a4767	e2 20		sep #$20	            SEP #$20
.1a4769	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a476b	c9 2c		cmp #$2c	                CMP #','
.1a476d	f0 03		beq $1a4772	                BEQ skip_comma
.1a476f	4c cf 47	jmp $1a47cf	                JMP syntax_err
.1a4772					skip_comma
.1a4772	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4775	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4778	e2 20		sep #$20	            SEP #$20
.1a477a	a5 27		lda $0827	                LDA ARGTYPE1
.1a477c	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a477e	d0 30		bne $1a47b0	                BNE type_mismatch           ; Type mismatch if it's not an integer
.1a4780	c2 20		rep #$20	            REP #$20
.1a4782	a5 23		lda $0823	            LDA ARGUMENT1
.1a4784	85 8f		sta $088f	            STA MCOUNT
.1a4786	c2 20		rep #$20	            REP #$20
.1a4788	a9 00 00	lda #$0000	            LDA #<>0
.1a478b	85 29		sta $0829	            STA ARGUMENT2
.1a478d	a9 00 00	lda #$0000	            LDA #(0 >> 16)
.1a4790	85 2b		sta $082b	            STA ARGUMENT2+2
.1a4792	e2 20		sep #$20	            SEP #$20
.1a4794	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a4796	85 2d		sta $082d	            STA ARGTYPE2
.1a4798	c2 20		rep #$20	            REP #$20
.1a479a	68		pla		                PLA                         ; Recover the string pointer
.1a479b	85 23		sta $0823	                STA ARGUMENT1
.1a479d	68		pla		                PLA
.1a479e	85 25		sta $0825	                STA ARGUMENT1+2
.1a47a0	e2 20		sep #$20	            SEP #$20
.1a47a2	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a47a4	85 27		sta $0827	            STA ARGTYPE1
.1a47a6	20 3f 16	jsr $1a163f	            JSR STRSUBSTR
.1a47a9					done
.1a47a9	e2 20		sep #$20	            SEP #$20
.1a47ab	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a47ae	28		plp		                PLP
.1a47af	60		rts		            RTS
.1a47b0					type_mismatch
.1a47b0	08		php		            PHP
.1a47b1	c2 20		rep #$20	            REP #$20
.1a47b3	48		pha		            PHA
.1a47b4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a47b7	5b		tcd		            TCD
.1a47b8	68		pla		            PLA
.1a47b9	28		plp		            PLP
.1a47ba	e2 20		sep #$20	            SEP #$20
.1a47bc	a9 04		lda #$04	            LDA #ERR_TYPE
.1a47be	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a47c2	c2 20		rep #$20	            REP #$20
.1a47c4	29 ff 00	and #$00ff	            AND #$00FF
.1a47c7	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a47ca	e2 20		sep #$20	            SEP #$20
.1a47cc	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a47cf					syntax_err
.1a47cf	08		php		            PHP
.1a47d0	c2 20		rep #$20	            REP #$20
.1a47d2	48		pha		            PHA
.1a47d3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a47d6	5b		tcd		            TCD
.1a47d7	68		pla		            PLA
.1a47d8	28		plp		            PLP
.1a47d9	e2 20		sep #$20	            SEP #$20
.1a47db	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a47dd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a47e1	c2 20		rep #$20	            REP #$20
.1a47e3	29 ff 00	and #$00ff	            AND #$00FF
.1a47e6	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a47e9	e2 20		sep #$20	            SEP #$20
.1a47eb	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a47ee					range_err
.1a47ee	08		php		            PHP
.1a47ef	c2 20		rep #$20	            REP #$20
.1a47f1	48		pha		            PHA
.1a47f2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a47f5	5b		tcd		            TCD
.1a47f6	68		pla		            PLA
.1a47f7	28		plp		            PLP
.1a47f8	e2 20		sep #$20	            SEP #$20
.1a47fa	a9 09		lda #$09	            LDA #ERR_RANGE
.1a47fc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4800	c2 20		rep #$20	            REP #$20
.1a4802	29 ff 00	and #$00ff	            AND #$00FF
.1a4805	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4808	e2 20		sep #$20	            SEP #$20
.1a480a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a480d					FN_VAL
.1a480d	e2 20		sep #$20	            SEP #$20
.1a480f	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4811	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4814	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4817	c2 10		rep #$10	            REP #$10
.1a4819	e2 20		sep #$20	            SEP #$20
.1a481b	a5 27		lda $0827	                LDA ARGTYPE1
.1a481d	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a481f	d0 23		bne $1a4844	                BNE type_mismatch
.1a4821	c2 20		rep #$20	            REP #$20
.1a4823	a5 00		lda $0800	                LDA BIP             ; preserve BIP for later
.1a4825	85 40		sta $0840	                STA SAVEBIP
.1a4827	a5 02		lda $0802	                LDA BIP+2
.1a4829	85 42		sta $0842	                STA SAVEBIP+2
.1a482b	a5 23		lda $0823	                LDA ARGUMENT1       ; Temporarily point BIP to the string to parse
.1a482d	85 00		sta $0800	                STA BIP
.1a482f	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4831	85 02		sta $0802	                STA BIP+2
.1a4833	20 c3 07	jsr $1a07c3	            JSR PARSEINT
.1a4836	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.1a4838	85 00		sta $0800	                STA BIP
.1a483a	a5 42		lda $0842	                LDA SAVEBIP+2
.1a483c	85 02		sta $0802	                STA BIP+2
.1a483e	e2 20		sep #$20	            SEP #$20
.1a4840	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4843	60		rts		            RTS
.1a4844					type_mismatch
.1a4844	08		php		            PHP
.1a4845	c2 20		rep #$20	            REP #$20
.1a4847	48		pha		            PHA
.1a4848	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a484b	5b		tcd		            TCD
.1a484c	68		pla		            PLA
.1a484d	28		plp		            PLP
.1a484e	e2 20		sep #$20	            SEP #$20
.1a4850	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4852	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4856	c2 20		rep #$20	            REP #$20
.1a4858	29 ff 00	and #$00ff	            AND #$00FF
.1a485b	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a485e	e2 20		sep #$20	            SEP #$20
.1a4860	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4863					FN_STR
.1a4863	e2 20		sep #$20	            SEP #$20
.1a4865	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4867	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a486a	08		php		                PHP
.1a486b	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a486e	c2 10		rep #$10	            REP #$10
.1a4870	e2 20		sep #$20	            SEP #$20
.1a4872	a5 27		lda $0827	                LDA ARGTYPE1
.1a4874	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4876	d0 1a		bne $1a4892	                BNE type_mismatch
.1a4878	20 46 14	jsr $1a1446	            JSR ITOS
.1a487b	c2 20		rep #$20	            REP #$20
.1a487d	a5 16		lda $0816	                LDA STRPTR          ; Prepare the return result
.1a487f	85 23		sta $0823	                STA ARGUMENT1
.1a4881	a5 18		lda $0818	                LDA STRPTR+2
.1a4883	85 25		sta $0825	                STA ARGUMENT1+2
.1a4885	e2 20		sep #$20	            SEP #$20
.1a4887	a9 02		lda #$02	                LDA #TYPE_STRING
.1a4889	85 27		sta $0827	                STA ARGTYPE1
.1a488b	28		plp		                PLP
.1a488c	e2 20		sep #$20	            SEP #$20
.1a488e	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4891	60		rts		            RTS
.1a4892					type_mismatch
.1a4892	08		php		            PHP
.1a4893	c2 20		rep #$20	            REP #$20
.1a4895	48		pha		            PHA
.1a4896	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4899	5b		tcd		            TCD
.1a489a	68		pla		            PLA
.1a489b	28		plp		            PLP
.1a489c	e2 20		sep #$20	            SEP #$20
.1a489e	a9 04		lda #$04	            LDA #ERR_TYPE
.1a48a0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a48a4	c2 20		rep #$20	            REP #$20
.1a48a6	29 ff 00	and #$00ff	            AND #$00FF
.1a48a9	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a48ac	e2 20		sep #$20	            SEP #$20
.1a48ae	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a48b1					FN_DEC
.1a48b1	e2 20		sep #$20	            SEP #$20
.1a48b3	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a48b5	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a48b8	08		php		                PHP
.1a48b9	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a48bc	20 ce 05	jsr $1a05ce	            JSR ASS_ARG1_STR
.1a48bf	c2 20		rep #$20	            REP #$20
.1a48c1	64 0c		stz $080c	                STZ SCRATCH
.1a48c3	64 0e		stz $080e	                STZ SCRATCH+2
.1a48c5	e2 30		sep #$30	            SEP #$30
.1a48c7	a0 00		ldy #$00	                LDY #0
.1a48c9	b7 23		lda [$0823],y	skip_loop       LDA [ARGUMENT1],Y
.1a48cb	c9 20		cmp #$20	                CMP #CHAR_SP
.1a48cd	f0 04		beq $1a48d3	                BEQ skip_char
.1a48cf	c9 24		cmp #$24	                CMP #'$'
.1a48d1	d0 03		bne $1a48d6	                BNE loop
.1a48d3	c8		iny		skip_char       INY
.1a48d4	80 f3		bra $1a48c9	                BRA skip_loop
.1a48d6	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y   ; Check the character
.1a48d8	20 f7 03	jsr $1a03f7	            JSR ISHEX
.1a48db	90 1e		bcc $1a48fb	                BCC ret_result      ; No: return what we have so far
.1a48dd	c2 20		rep #$20	            REP #$20
.1a48df	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a48e1	26 0e		rol $080e	                ROL SCRATCH+2
.1a48e3	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a48e5	26 0e		rol $080e	                ROL SCRATCH+2
.1a48e7	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a48e9	26 0e		rol $080e	                ROL SCRATCH+2
.1a48eb	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a48ed	26 0e		rol $080e	                ROL SCRATCH+2
.1a48ef	e2 20		sep #$20	            SEP #$20
.1a48f1	20 18 04	jsr $1a0418	            JSR HEX2BIN
.1a48f4	05 0c		ora $080c	                ORA SCRATCH
.1a48f6	85 0c		sta $080c	                STA SCRATCH         ; And add it to the result
.1a48f8	c8		iny		                INY
.1a48f9	80 db		bra $1a48d6	                BRA loop            ; And try the next character
.1a48fb					ret_result
.1a48fb	c2 20		rep #$20	            REP #$20
.1a48fd	a5 0c		lda $080c	                LDA SCRATCH         ; Return the result
.1a48ff	85 23		sta $0823	                STA ARGUMENT1
.1a4901	a5 0e		lda $080e	                LDA SCRATCH+2
.1a4903	85 25		sta $0825	                STA ARGUMENT1+2
.1a4905	e2 20		sep #$20	            SEP #$20
.1a4907	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a4909	85 27		sta $0827	                STA ARGTYPE1
.1a490b	28		plp		                PLP
.1a490c	e2 20		sep #$20	            SEP #$20
.1a490e	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4911	60		rts		            RTS
.1a4912					FN_HEX
.1a4912	e2 20		sep #$20	            SEP #$20
.1a4914	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4916	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4919	08		php		                PHP
.1a491a	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a491d	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a4920	20 e7 13	jsr $1a13e7	            JSR TEMPSTRING
.1a4923	e2 30		sep #$30	            SEP #$30
.1a4925	a0 ff		ldy #$ff	                LDY #$FF            ; Terminate the string
.1a4927	a9 00		lda #$00	                LDA #0
.1a4929	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a492b	88		dey		                DEY
.1a492c	a5 23		lda $0823	loop            LDA ARGUMENT1       ; Write the low digit
.1a492e	29 0f		and #$0f	                AND #$0F
.1a4930	aa		tax		                TAX
.1a4931	bf 00 d0 1a	lda $1ad000,x	                LDA @lHEXDIGITS,X
.1a4935	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4937	88		dey		                DEY
.1a4938	a5 23		lda $0823	                LDA ARGUMENT1       ; Write the high digit
.1a493a	29 f0		and #$f0	                AND #$F0
.1a493c	4a		lsr a		                LSR A
.1a493d	4a		lsr a		                LSR A
.1a493e	4a		lsr a		                LSR A
.1a493f	4a		lsr a		                LSR A
.1a4940	aa		tax		                TAX
.1a4941	bf 00 d0 1a	lda $1ad000,x	                LDA @lHEXDIGITS,X
.1a4945	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4947	88		dey		                DEY
.1a4948	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Shift value by one byte
.1a494a	85 23		sta $0823	                STA ARGUMENT1
.1a494c	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a494e	85 24		sta $0824	                STA ARGUMENT1+1
.1a4950	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a4952	85 25		sta $0825	                STA ARGUMENT1+2
.1a4954	a9 00		lda #$00	                LDA #0
.1a4956	85 26		sta $0826	                STA ARGUMENT1+3
.1a4958	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the argument 0?
.1a495a	d0 d0		bne $1a492c	                BNE loop            ; No: keep converting
.1a495c	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a495e	d0 cc		bne $1a492c	                BNE loop
.1a4960	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4962	d0 c8		bne $1a492c	                BNE loop
.1a4964	98		tya		                TYA                 ; Get the index of the first free char
.1a4965	38		sec		                SEC                 ; Add 1 to get to the first character of the string
.1a4966	65 16		adc $0816	                ADC STRPTR          ; And add the whole thing to the temp string pointer
.1a4968	85 23		sta $0823	                STA ARGUMENT1       ; And return it as the result
.1a496a	a5 17		lda $0817	                LDA STRPTR+1
.1a496c	85 24		sta $0824	                STA ARGUMENT1+1
.1a496e	a5 18		lda $0818	                LDA STRPTR+2
.1a4970	85 25		sta $0825	                STA ARGUMENT1+2
.1a4972	a5 19		lda $0819	                LDA STRPTR+3
.1a4974	85 26		sta $0826	                STA ARGUMENT1+3
.1a4976	a9 02		lda #$02	                LDA #TYPE_STRING    ; And make the type STRING
.1a4978	85 27		sta $0827	                STA ARGTYPE1
.1a497a	28		plp		                PLP
.1a497b	e2 20		sep #$20	            SEP #$20
.1a497d	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4980	60		rts		            RTS
.1a4981					type_mismatch
.1a4981	08		php		            PHP
.1a4982	c2 20		rep #$20	            REP #$20
.1a4984	48		pha		            PHA
.1a4985	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4988	5b		tcd		            TCD
.1a4989	68		pla		            PLA
.1a498a	28		plp		            PLP
.1a498b	e2 20		sep #$20	            SEP #$20
.1a498d	a9 04		lda #$04	            LDA #ERR_TYPE
.1a498f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4993	c2 20		rep #$20	            REP #$20
.1a4995	29 ff 00	and #$00ff	            AND #$00FF
.1a4998	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a499b	e2 20		sep #$20	            SEP #$20
.1a499d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a49a0					FN_LEN
.1a49a0	e2 20		sep #$20	            SEP #$20
.1a49a2	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a49a4	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a49a7	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a49aa	e2 20		sep #$20	            SEP #$20
.1a49ac	a5 27		lda $0827	                LDA ARGTYPE1
.1a49ae	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a49b0	d0 1f		bne $1a49d1	                BNE type_mismatch
.1a49b2	8b		phb		                PHB                 ; Set the data bank to the data bank of the string
.1a49b3	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a49b5	48		pha		                PHA
.1a49b6	ab		plb		                PLB
.1a49b7	c2 10		rep #$10	            REP #$10
.1a49b9	a6 23		ldx $0823	                LDX ARGUMENT1       ; And point X to the string data
.1a49bb	20 d3 14	jsr $1a14d3	            JSR STRLEN
.1a49be	ab		plb		                PLB                 ; Restore the old data bank
.1a49bf	84 23		sty $0823	                STY ARGUMENT1       ; Save the length to ARGUMENT1
.1a49c1	c2 20		rep #$20	            REP #$20
.1a49c3	64 25		stz $0825	                STZ ARGUMENT1+2
.1a49c5	e2 20		sep #$20	            SEP #$20
.1a49c7	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the type to INTEGER
.1a49c9	85 27		sta $0827	                STA ARGTYPE1
.1a49cb	e2 20		sep #$20	            SEP #$20
.1a49cd	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a49d0	60		rts		            RTS
.1a49d1					type_mismatch
.1a49d1	08		php		            PHP
.1a49d2	c2 20		rep #$20	            REP #$20
.1a49d4	48		pha		            PHA
.1a49d5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a49d8	5b		tcd		            TCD
.1a49d9	68		pla		            PLA
.1a49da	28		plp		            PLP
.1a49db	e2 20		sep #$20	            SEP #$20
.1a49dd	a9 04		lda #$04	            LDA #ERR_TYPE
.1a49df	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a49e3	c2 20		rep #$20	            REP #$20
.1a49e5	29 ff 00	and #$00ff	            AND #$00FF
.1a49e8	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a49eb	e2 20		sep #$20	            SEP #$20
.1a49ed	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a49f0					FN_PEEK
.1a49f0	e2 20		sep #$20	            SEP #$20
.1a49f2	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a49f4	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a49f7	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a49fa	e2 20		sep #$20	            SEP #$20
.1a49fc	a5 27		lda $0827	                LDA ARGTYPE1
.1a49fe	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4a00	d0 12		bne $1a4a14	                BNE type_mismatch
.1a4a02	e2 20		sep #$20	            SEP #$20
.1a4a04	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.1a4a06	85 23		sta $0823	                STA ARGUMENT1
.1a4a08	64 24		stz $0824	                STZ ARGUMENT1+1
.1a4a0a	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4a0c	64 30		stz $0830	                STZ ARGUMENT1+13
.1a4a0e	e2 20		sep #$20	            SEP #$20
.1a4a10	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4a13	60		rts		            RTS
.1a4a14					type_mismatch
.1a4a14	08		php		            PHP
.1a4a15	c2 20		rep #$20	            REP #$20
.1a4a17	48		pha		            PHA
.1a4a18	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4a1b	5b		tcd		            TCD
.1a4a1c	68		pla		            PLA
.1a4a1d	28		plp		            PLP
.1a4a1e	e2 20		sep #$20	            SEP #$20
.1a4a20	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4a22	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4a26	c2 20		rep #$20	            REP #$20
.1a4a28	29 ff 00	and #$00ff	            AND #$00FF
.1a4a2b	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4a2e	e2 20		sep #$20	            SEP #$20
.1a4a30	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4a33					FN_PEEKL
.1a4a33	e2 20		sep #$20	            SEP #$20
.1a4a35	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4a37	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4a3a	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4a3d	e2 20		sep #$20	            SEP #$20
.1a4a3f	a5 27		lda $0827	                LDA ARGTYPE1
.1a4a41	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4a43	d0 1d		bne $1a4a62	                BNE type_mismatch
.1a4a45	c2 20		rep #$20	            REP #$20
.1a4a47	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.1a4a49	85 0c		sta $080c	                STA SCRATCH
.1a4a4b	e2 20		sep #$20	            SEP #$20
.1a4a4d	a0 02 00	ldy #$0002	                LDY #2
.1a4a50	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y
.1a4a52	85 25		sta $0825	                STA ARGUMENT1+2
.1a4a54	64 26		stz $0826	                STZ ARGUMENT1+3
.1a4a56	c2 20		rep #$20	            REP #$20
.1a4a58	a5 0c		lda $080c	                LDA SCRATCH
.1a4a5a	85 23		sta $0823	                STA ARGUMENT1
.1a4a5c	e2 20		sep #$20	            SEP #$20
.1a4a5e	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4a61	60		rts		            RTS
.1a4a62					type_mismatch
.1a4a62	08		php		            PHP
.1a4a63	c2 20		rep #$20	            REP #$20
.1a4a65	48		pha		            PHA
.1a4a66	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4a69	5b		tcd		            TCD
.1a4a6a	68		pla		            PLA
.1a4a6b	28		plp		            PLP
.1a4a6c	e2 20		sep #$20	            SEP #$20
.1a4a6e	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4a70	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4a74	c2 20		rep #$20	            REP #$20
.1a4a76	29 ff 00	and #$00ff	            AND #$00FF
.1a4a79	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4a7c	e2 20		sep #$20	            SEP #$20
.1a4a7e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4a81					FN_PEEKW
.1a4a81	e2 20		sep #$20	            SEP #$20
.1a4a83	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4a85	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4a88	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4a8b	e2 20		sep #$20	            SEP #$20
.1a4a8d	a5 27		lda $0827	                LDA ARGTYPE1
.1a4a8f	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4a91	d0 0e		bne $1a4aa1	                BNE type_mismatch
.1a4a93	c2 20		rep #$20	            REP #$20
.1a4a95	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.1a4a97	85 23		sta $0823	                STA ARGUMENT1
.1a4a99	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4a9b	e2 20		sep #$20	            SEP #$20
.1a4a9d	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4aa0	60		rts		            RTS
.1a4aa1					type_mismatch
.1a4aa1	08		php		            PHP
.1a4aa2	c2 20		rep #$20	            REP #$20
.1a4aa4	48		pha		            PHA
.1a4aa5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4aa8	5b		tcd		            TCD
.1a4aa9	68		pla		            PLA
.1a4aaa	28		plp		            PLP
.1a4aab	e2 20		sep #$20	            SEP #$20
.1a4aad	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4aaf	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4ab3	c2 20		rep #$20	            REP #$20
.1a4ab5	29 ff 00	and #$00ff	            AND #$00FF
.1a4ab8	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4abb	e2 20		sep #$20	            SEP #$20
.1a4abd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4ac0					FN_CHR
.1a4ac0	e2 20		sep #$20	            SEP #$20
.1a4ac2	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4ac4	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4ac7	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4aca	e2 20		sep #$20	            SEP #$20
.1a4acc	a5 27		lda $0827	                LDA ARGTYPE1
.1a4ace	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4ad0	d0 24		bne $1a4af6	                BNE type_mismatch
.1a4ad2	20 e7 13	jsr $1a13e7	            JSR TEMPSTRING
.1a4ad5	a5 23		lda $0823	                LDA ARGUMENT1       ; Get the numberic value
.1a4ad7	87 16		sta [$0816]	                STA [STRPTR]        ; And save it as the first character
.1a4ad9	a9 00		lda #$00	                LDA #0              ; Null terminate the string
.1a4adb	a0 01 00	ldy #$0001	                LDY #1
.1a4ade	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4ae0	c2 20		rep #$20	            REP #$20
.1a4ae2	a5 16		lda $0816	                LDA STRPTR
.1a4ae4	85 23		sta $0823	                STA ARGUMENT1
.1a4ae6	a5 18		lda $0818	                LDA STRPTR+2
.1a4ae8	85 25		sta $0825	                STA ARGUMENT1+2
.1a4aea	e2 20		sep #$20	            SEP #$20
.1a4aec	a9 02		lda #$02	                LDA #TYPE_STRING
.1a4aee	85 27		sta $0827	                STA ARGTYPE1
.1a4af0	e2 20		sep #$20	            SEP #$20
.1a4af2	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4af5	60		rts		            RTS
.1a4af6					type_mismatch
.1a4af6	08		php		            PHP
.1a4af7	c2 20		rep #$20	            REP #$20
.1a4af9	48		pha		            PHA
.1a4afa	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4afd	5b		tcd		            TCD
.1a4afe	68		pla		            PLA
.1a4aff	28		plp		            PLP
.1a4b00	e2 20		sep #$20	            SEP #$20
.1a4b02	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4b04	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4b08	c2 20		rep #$20	            REP #$20
.1a4b0a	29 ff 00	and #$00ff	            AND #$00FF
.1a4b0d	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4b10	e2 20		sep #$20	            SEP #$20
.1a4b12	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4b15					FN_ASC
.1a4b15	e2 20		sep #$20	            SEP #$20
.1a4b17	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4b19	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4b1c	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4b1f	e2 20		sep #$20	            SEP #$20
.1a4b21	a5 27		lda $0827	                LDA ARGTYPE1
.1a4b23	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4b25	d0 14		bne $1a4b3b	                BNE type_mismatch
.1a4b27	a7 23		lda [$0823]	                LDA [ARGUMENT1]     ; Get the character
.1a4b29	85 23		sta $0823	                STA ARGUMENT1       ; Save its code to ARGUMENT1
.1a4b2b	64 24		stz $0824	                STZ ARGUMENT1+1
.1a4b2d	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4b2f	64 26		stz $0826	                STZ ARGUMENT1+3
.1a4b31	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the return type to integer
.1a4b33	85 27		sta $0827	                STA ARGTYPE1
.1a4b35	e2 20		sep #$20	            SEP #$20
.1a4b37	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4b3a	60		rts		            RTS
.1a4b3b					type_mismatch
.1a4b3b	08		php		            PHP
.1a4b3c	c2 20		rep #$20	            REP #$20
.1a4b3e	48		pha		            PHA
.1a4b3f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4b42	5b		tcd		            TCD
.1a4b43	68		pla		            PLA
.1a4b44	28		plp		            PLP
.1a4b45	e2 20		sep #$20	            SEP #$20
.1a4b47	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4b49	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4b4d	c2 20		rep #$20	            REP #$20
.1a4b4f	29 ff 00	and #$00ff	            AND #$00FF
.1a4b52	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4b55	e2 20		sep #$20	            SEP #$20
.1a4b57	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4b5a					FN_SPC
.1a4b5a	e2 20		sep #$20	            SEP #$20
.1a4b5c	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4b5e	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4b61	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4b64	e2 20		sep #$20	            SEP #$20
.1a4b66	a5 27		lda $0827	                LDA ARGTYPE1
.1a4b68	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4b6a	d0 39		bne $1a4ba5	                BNE type_mismatch
.1a4b6c	e2 20		sep #$20	            SEP #$20
.1a4b6e	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.1a4b70	d0 52		bne $1a4bc4	                BNE err_limit
.1a4b72	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4b74	d0 4e		bne $1a4bc4	                BNE err_limit
.1a4b76	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a4b78	d0 4a		bne $1a4bc4	                BNE err_limit
.1a4b7a	c2 10		rep #$10	            REP #$10
.1a4b7c	20 e7 13	jsr $1a13e7	            JSR TEMPSTRING
.1a4b7f	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.1a4b81	e2 20		sep #$20	            SEP #$20
.1a4b83	a9 00		lda #$00	                LDA #0
.1a4b85	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.1a4b87	88		dey		                DEY
.1a4b88	30 07		bmi $1a4b91	                BMI done
.1a4b8a	a9 20		lda #$20	                LDA #CHAR_SP
.1a4b8c	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.1a4b8e	88		dey		                DEY
.1a4b8f	10 fb		bpl $1a4b8c	                BPL loop            ; And keep writing until we're done
.1a4b91	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.1a4b93	85 27		sta $0827	                STA ARGTYPE1
.1a4b95	c2 20		rep #$20	            REP #$20
.1a4b97	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.1a4b99	85 23		sta $0823	                STA ARGUMENT1
.1a4b9b	a5 18		lda $0818	                LDA STRPTR+2
.1a4b9d	85 25		sta $0825	                STA ARGUMENT1+2
.1a4b9f	e2 20		sep #$20	            SEP #$20
.1a4ba1	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4ba4	60		rts		            RTS
.1a4ba5					type_mismatch
.1a4ba5	08		php		            PHP
.1a4ba6	c2 20		rep #$20	            REP #$20
.1a4ba8	48		pha		            PHA
.1a4ba9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4bac	5b		tcd		            TCD
.1a4bad	68		pla		            PLA
.1a4bae	28		plp		            PLP
.1a4baf	e2 20		sep #$20	            SEP #$20
.1a4bb1	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4bb3	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4bb7	c2 20		rep #$20	            REP #$20
.1a4bb9	29 ff 00	and #$00ff	            AND #$00FF
.1a4bbc	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4bbf	e2 20		sep #$20	            SEP #$20
.1a4bc1	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4bc4					err_limit
.1a4bc4	08		php		            PHP
.1a4bc5	c2 20		rep #$20	            REP #$20
.1a4bc7	48		pha		            PHA
.1a4bc8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4bcb	5b		tcd		            TCD
.1a4bcc	68		pla		            PLA
.1a4bcd	28		plp		            PLP
.1a4bce	e2 20		sep #$20	            SEP #$20
.1a4bd0	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4bd2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4bd6	c2 20		rep #$20	            REP #$20
.1a4bd8	29 ff 00	and #$00ff	            AND #$00FF
.1a4bdb	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4bde	e2 20		sep #$20	            SEP #$20
.1a4be0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4be3					FN_TAB
.1a4be3	e2 20		sep #$20	            SEP #$20
.1a4be5	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4be7	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4bea	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4bed	e2 20		sep #$20	            SEP #$20
.1a4bef	a5 27		lda $0827	                LDA ARGTYPE1
.1a4bf1	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4bf3	d0 39		bne $1a4c2e	                BNE type_mismatch
.1a4bf5	e2 20		sep #$20	            SEP #$20
.1a4bf7	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.1a4bf9	d0 52		bne $1a4c4d	                BNE err_limit
.1a4bfb	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4bfd	d0 4e		bne $1a4c4d	                BNE err_limit
.1a4bff	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a4c01	d0 4a		bne $1a4c4d	                BNE err_limit
.1a4c03	c2 10		rep #$10	            REP #$10
.1a4c05	20 e7 13	jsr $1a13e7	            JSR TEMPSTRING
.1a4c08	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.1a4c0a	e2 20		sep #$20	            SEP #$20
.1a4c0c	a9 00		lda #$00	                LDA #0
.1a4c0e	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.1a4c10	88		dey		                DEY
.1a4c11	30 07		bmi $1a4c1a	                BMI done
.1a4c13	a9 09		lda #$09	                LDA #CHAR_TAB
.1a4c15	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.1a4c17	88		dey		                DEY
.1a4c18	10 fb		bpl $1a4c15	                BPL loop            ; And keep writing until we're done
.1a4c1a	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.1a4c1c	85 27		sta $0827	                STA ARGTYPE1
.1a4c1e	c2 20		rep #$20	            REP #$20
.1a4c20	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.1a4c22	85 23		sta $0823	                STA ARGUMENT1
.1a4c24	a5 18		lda $0818	                LDA STRPTR+2
.1a4c26	85 25		sta $0825	                STA ARGUMENT1+2
.1a4c28	e2 20		sep #$20	            SEP #$20
.1a4c2a	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4c2d	60		rts		            RTS
.1a4c2e					type_mismatch
.1a4c2e	08		php		            PHP
.1a4c2f	c2 20		rep #$20	            REP #$20
.1a4c31	48		pha		            PHA
.1a4c32	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4c35	5b		tcd		            TCD
.1a4c36	68		pla		            PLA
.1a4c37	28		plp		            PLP
.1a4c38	e2 20		sep #$20	            SEP #$20
.1a4c3a	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4c3c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4c40	c2 20		rep #$20	            REP #$20
.1a4c42	29 ff 00	and #$00ff	            AND #$00FF
.1a4c45	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4c48	e2 20		sep #$20	            SEP #$20
.1a4c4a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4c4d					err_limit
.1a4c4d	08		php		            PHP
.1a4c4e	c2 20		rep #$20	            REP #$20
.1a4c50	48		pha		            PHA
.1a4c51	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4c54	5b		tcd		            TCD
.1a4c55	68		pla		            PLA
.1a4c56	28		plp		            PLP
.1a4c57	e2 20		sep #$20	            SEP #$20
.1a4c59	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4c5b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4c5f	c2 20		rep #$20	            REP #$20
.1a4c61	29 ff 00	and #$00ff	            AND #$00FF
.1a4c64	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4c67	e2 20		sep #$20	            SEP #$20
.1a4c69	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4c6c					FN_ABS
.1a4c6c	e2 20		sep #$20	            SEP #$20
.1a4c6e	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4c70	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4c73	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4c76	e2 20		sep #$20	            SEP #$20
.1a4c78	a5 27		lda $0827	                LDA ARGTYPE1        ; Check the type
.1a4c7a	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4c7c	f0 23		beq $1a4ca1	                BEQ abs_int         ; If integer, get the absolute value of the integer
.1a4c7e	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.1a4c80	f0 3e		beq $1a4cc0	                BEQ abs_float       ; If float, get the absolute value of the float
.1a4c82					type_err
.1a4c82	08		php		            PHP
.1a4c83	c2 20		rep #$20	            REP #$20
.1a4c85	48		pha		            PHA
.1a4c86	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4c89	5b		tcd		            TCD
.1a4c8a	68		pla		            PLA
.1a4c8b	28		plp		            PLP
.1a4c8c	e2 20		sep #$20	            SEP #$20
.1a4c8e	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4c90	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4c94	c2 20		rep #$20	            REP #$20
.1a4c96	29 ff 00	and #$00ff	            AND #$00FF
.1a4c99	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4c9c	e2 20		sep #$20	            SEP #$20
.1a4c9e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4ca1					abs_int
.1a4ca1	c2 20		rep #$20	            REP #$20
.1a4ca3	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Is it positive already?
.1a4ca5	10 21		bpl $1a4cc8	                BPL done            ; Yes: we don't need to do anythign further
.1a4ca7	49 ff ff	eor #$ffff	                EOR #$FFFF          ; Otherwise, take the two's compliment
.1a4caa	85 25		sta $0825	                STA ARGUMENT1+2     ; Of ARGUMENT1
.1a4cac	a5 23		lda $0823	                LDA ARGUMENT1
.1a4cae	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a4cb1	18		clc		                CLC
.1a4cb2	69 01 00	adc #$0001	                ADC #1
.1a4cb5	85 23		sta $0823	                STA ARGUMENT1       ; And save it back to ARGUMENT1
.1a4cb7	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4cb9	69 00 00	adc #$0000	                ADC #0
.1a4cbc	85 25		sta $0825	                STA ARGUMENT1+2
.1a4cbe	80 08		bra $1a4cc8	                BRA done
.1a4cc0					abs_float
.1a4cc0	e2 20		sep #$20	            SEP #$20
.1a4cc2	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Just clear the sign bit
.1a4cc4	29 7f		and #$7f	                AND #$7F
.1a4cc6	85 26		sta $0826	                STA ARGUMENT1+3
.1a4cc8					done
.1a4cc8	e2 20		sep #$20	            SEP #$20
.1a4cca	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4ccd	60		rts		            RTS
.1a4cce					FN_SGN
.1a4cce	e2 20		sep #$20	            SEP #$20
.1a4cd0	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4cd2	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4cd5	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4cd8	e2 20		sep #$20	            SEP #$20
.1a4cda	a5 27		lda $0827	                LDA ARGTYPE1
.1a4cdc	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4cde	d0 25		bne $1a4d05	                BNE type_mismatch
.1a4ce0	c2 20		rep #$20	            REP #$20
.1a4ce2	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4ce4	30 12		bmi $1a4cf8	                BMI is_negative     ; Negative: return -1
.1a4ce6	d0 04		bne $1a4cec	                BNE is_positive     ; Is it not 0? Then return 1
.1a4ce8	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the lower word 0?
.1a4cea	f0 13		beq $1a4cff	                BEQ done            ; Yes: the whole thing is zero: return 0
.1a4cec	a9 00 00	lda #$0000	is_positive     LDA #0              ; It's positive: return 1
.1a4cef	85 25		sta $0825	                STA ARGUMENT1+2
.1a4cf1	a9 01 00	lda #$0001	                LDA #1
.1a4cf4	85 23		sta $0823	                STA ARGUMENT1
.1a4cf6	80 07		bra $1a4cff	                BRA done
.1a4cf8	a9 ff ff	lda #$ffff	is_negative     LDA #$FFFF          ; It's negative: return -1
.1a4cfb	85 25		sta $0825	                STA ARGUMENT1+2
.1a4cfd	85 23		sta $0823	                STA ARGUMENT1
.1a4cff					done
.1a4cff	e2 20		sep #$20	            SEP #$20
.1a4d01	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4d04	60		rts		            RTS
.1a4d05					type_mismatch
.1a4d05	08		php		            PHP
.1a4d06	c2 20		rep #$20	            REP #$20
.1a4d08	48		pha		            PHA
.1a4d09	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4d0c	5b		tcd		            TCD
.1a4d0d	68		pla		            PLA
.1a4d0e	28		plp		            PLP
.1a4d0f	e2 20		sep #$20	            SEP #$20
.1a4d11	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4d13	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4d17	c2 20		rep #$20	            REP #$20
.1a4d19	29 ff 00	and #$00ff	            AND #$00FF
.1a4d1c	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4d1f	e2 20		sep #$20	            SEP #$20
.1a4d21	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4d24					FN_INT
.1a4d24	e2 20		sep #$20	            SEP #$20
.1a4d26	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4d28	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4d2b	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4d2e	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a4d31					done
.1a4d31	e2 20		sep #$20	            SEP #$20
.1a4d33	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4d36	60		rts		            RTS
.1a4d37					FN_SIN
.1a4d37	e2 20		sep #$20	            SEP #$20
.1a4d39	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4d3b	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4d3e	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4d41	20 aa 06	jsr $1a06aa	            JSR ASS_ARG1_FLOAT
.1a4d44	20 f5 5f	jsr $1a5ff5	            JSR FP_SIN
.1a4d47					done
.1a4d47	e2 20		sep #$20	            SEP #$20
.1a4d49	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4d4c	60		rts		            RTS
.1a4d4d					FN_COS
.1a4d4d	e2 20		sep #$20	            SEP #$20
.1a4d4f	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4d51	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4d54	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4d57	20 aa 06	jsr $1a06aa	            JSR ASS_ARG1_FLOAT
.1a4d5a	20 24 60	jsr $1a6024	            JSR FP_COS
.1a4d5d					done
.1a4d5d	e2 20		sep #$20	            SEP #$20
.1a4d5f	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4d62	60		rts		            RTS
.1a4d63					FN_TAN
.1a4d63	e2 20		sep #$20	            SEP #$20
.1a4d65	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4d67	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4d6a	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4d6d	20 aa 06	jsr $1a06aa	            JSR ASS_ARG1_FLOAT
.1a4d70	20 53 60	jsr $1a6053	            JSR FP_TAN
.1a4d73					done
.1a4d73	e2 20		sep #$20	            SEP #$20
.1a4d75	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4d78	60		rts		            RTS
.1a4d79					FN_LN
.1a4d79	e2 20		sep #$20	            SEP #$20
.1a4d7b	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4d7d	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4d80	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4d83	20 aa 06	jsr $1a06aa	            JSR ASS_ARG1_FLOAT
.1a4d86	20 81 60	jsr $1a6081	            JSR FP_LN
.1a4d89					done
.1a4d89	e2 20		sep #$20	            SEP #$20
.1a4d8b	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4d8e	60		rts		            RTS
.1a4d8f					FN_ACOS
.1a4d8f	e2 20		sep #$20	            SEP #$20
.1a4d91	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4d93	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4d96	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4d99	20 aa 06	jsr $1a06aa	            JSR ASS_ARG1_FLOAT
.1a4d9c	20 aa 61	jsr $1a61aa	            JSR FP_ACOS
.1a4d9f					done
.1a4d9f	e2 20		sep #$20	            SEP #$20
.1a4da1	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4da4	60		rts		            RTS
.1a4da5					FN_ASIN
.1a4da5	e2 20		sep #$20	            SEP #$20
.1a4da7	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4da9	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4dac	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4daf	20 aa 06	jsr $1a06aa	            JSR ASS_ARG1_FLOAT
.1a4db2	20 80 61	jsr $1a6180	            JSR FP_ASIN
.1a4db5					done
.1a4db5	e2 20		sep #$20	            SEP #$20
.1a4db7	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4dba	60		rts		            RTS
.1a4dbb					FN_ATAN
.1a4dbb	e2 20		sep #$20	            SEP #$20
.1a4dbd	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4dbf	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4dc2	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4dc5	20 aa 06	jsr $1a06aa	            JSR ASS_ARG1_FLOAT
.1a4dc8	20 cc 61	jsr $1a61cc	            JSR FP_ATAN
.1a4dcb					done
.1a4dcb	e2 20		sep #$20	            SEP #$20
.1a4dcd	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4dd0	60		rts		            RTS
.1a4dd1					FN_EXP
.1a4dd1	e2 20		sep #$20	            SEP #$20
.1a4dd3	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4dd5	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4dd8	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4ddb	20 aa 06	jsr $1a06aa	            JSR ASS_ARG1_FLOAT
.1a4dde	20 60 62	jsr $1a6260	            JSR FP_EXP
.1a4de1					done
.1a4de1	e2 20		sep #$20	            SEP #$20
.1a4de3	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4de6	60		rts		            RTS
.1a4de7					FN_SQR
.1a4de7	e2 20		sep #$20	            SEP #$20
.1a4de9	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4deb	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4dee	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a4df1	20 aa 06	jsr $1a06aa	            JSR ASS_ARG1_FLOAT
.1a4df4	20 e2 62	jsr $1a62e2	            JSR FP_SQR
.1a4df7					done
.1a4df7	e2 20		sep #$20	            SEP #$20
.1a4df9	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a4dfc	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\commands.s

.1a4dfd	00		brk #		CMD_MONITOR     BRK
.1a4dfe	ea		nop		                NOP
.1a4dff	60		rts		            RTS
.1a4e00					CMD_NEW
.1a4e00	08		php		                PHP
.1a4e01	0b		phd		                PHD
.1a4e02	08		php		            PHP
.1a4e03	c2 20		rep #$20	            REP #$20
.1a4e05	48		pha		            PHA
.1a4e06	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a4e09	5b		tcd		            TCD
.1a4e0a	68		pla		            PLA
.1a4e0b	28		plp		            PLP
.1a4e0c	c2 30		rep #$30	            REP #$30
.1a4e0e	c2 20		rep #$20	            REP #$20
.1a4e10	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.1a4e13	85 d9		sta $08d9	            STA LASTLINE
.1a4e15	e2 20		sep #$20	            SEP #$20
.1a4e17	a9 16		lda #$16	            LDA #`BASIC_BOT
.1a4e19	85 db		sta $08db	            STA LASTLINE+2
.1a4e1b	c2 30		rep #$30	            REP #$30
.1a4e1d	a9 00 00	lda #$0000	                LDA #0
.1a4e20	a0 00 00	ldy #$0000	                LDY #LINE_LINK
.1a4e23	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.1a4e25	a0 02 00	ldy #$0002	                LDY #LINE_NUMBER
.1a4e28	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.1a4e2a	a0 04 00	ldy #$0004	                LDY #LINE_TOKENS
.1a4e2d	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.1a4e2f	20 6d 1f	jsr $1a1f6d	            JSR CLRINTERP
.1a4e32	2b		pld		                PLD
.1a4e33	28		plp		                PLP
.1a4e34	60		rts		            RTS
.1a4e35					CMD_RUN
.1a4e35	8b		phb		                PHB
.1a4e36	08		php		                PHP
.1a4e37	c2 20		rep #$20	            REP #$20
.1a4e39	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT            ; Point to the first line of the program
.1a4e3c	85 1a		sta $081a	                STA CURLINE
.1a4e3e	a9 16 00	lda #$0016	                LDA #`BASIC_BOT
.1a4e41	85 1c		sta $081c	                STA CURLINE + 2
.1a4e43	20 6d 1f	jsr $1a1f6d	            JSR CLRINTERP
.1a4e46	20 4c 22	jsr $1a224c	            JSR EXECPROGRAM
.1a4e49	28		plp		                PLP
.1a4e4a	ab		plb		                PLB
.1a4e4b	60		rts		            RTS
.1a4e4c					CMD_LIST
.1a4e4c	08		php		                PHP
.1a4e4d	c2 20		rep #$20	            REP #$20
.1a4e4f	64 55		stz $0855	                STZ MARG1               ; MARG1 is starting line number, default 0
.1a4e51	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.1a4e54	85 59		sta $0859	                STA MARG2               ; MARG2 is ending line number, default MAXINT
.1a4e56	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a4e59	20 f8 20	jsr $1a20f8	            JSR PEEK_TOK
.1a4e5c	29 ff 00	and #$00ff	                AND #$00FF
.1a4e5f	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.1a4e62	f0 2c		beq $1a4e90	                BEQ call_list           ; ... just list with the defaults
.1a4e64	c9 81 00	cmp #$0081	                CMP #TOK_MINUS          ; If just "- ###"...
.1a4e67	f0 1a		beq $1a4e83	                BEQ parse_endline       ; ... try to parse the end line number
.1a4e69	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a4e6c	20 c3 07	jsr $1a07c3	            JSR PARSEINT
.1a4e6f	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG1
.1a4e71	85 55		sta $0855	                STA MARG1
.1a4e73	20 f8 20	jsr $1a20f8	            JSR PEEK_TOK
.1a4e76	29 ff 00	and #$00ff	                AND #$00FF
.1a4e79	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.1a4e7c	f0 12		beq $1a4e90	                BEQ call_list           ; ... just list with the defaults
.1a4e7e	c9 81 00	cmp #$0081	                CMP #TOK_MINUS
.1a4e81	d0 2a		bne $1a4ead	                BNE error               ; At this point, if not '-', it's a syntax error
.1a4e83					parse_endline
.1a4e83	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a4e86	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a4e89	20 c3 07	jsr $1a07c3	            JSR PARSEINT
.1a4e8c	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG2
.1a4e8e	85 59		sta $0859	                STA MARG2
.1a4e90	a5 1c		lda $081c	call_list       LDA CURLINE+2           ; Save CURLINE
.1a4e92	48		pha		                PHA
.1a4e93	a5 1a		lda $081a	                LDA CURLINE
.1a4e95	48		pha		                PHA
.1a4e96	a5 02		lda $0802	                LDA BIP+2               ; Save BIP
.1a4e98	48		pha		                PHA
.1a4e99	a5 00		lda $0800	                LDA BIP
.1a4e9b	48		pha		                PHA
.1a4e9c	20 49 17	jsr $1a1749	            JSR LISTPROG
.1a4e9f	68		pla		                PLA
.1a4ea0	85 00		sta $0800	                STA BIP
.1a4ea2	68		pla		                PLA
.1a4ea3	85 02		sta $0802	                STA BIP+2
.1a4ea5	68		pla		                PLA
.1a4ea6	85 1a		sta $081a	                STA CURLINE
.1a4ea8	68		pla		                PLA
.1a4ea9	85 1c		sta $081c	                STA CURLINE+2
.1a4eab	28		plp		                PLP
.1a4eac	60		rts		            RTS
.1a4ead					error
.1a4ead	08		php		            PHP
.1a4eae	c2 20		rep #$20	            REP #$20
.1a4eb0	48		pha		            PHA
.1a4eb1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4eb4	5b		tcd		            TCD
.1a4eb5	68		pla		            PLA
.1a4eb6	28		plp		            PLP
.1a4eb7	e2 20		sep #$20	            SEP #$20
.1a4eb9	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4ebb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4ebf	c2 20		rep #$20	            REP #$20
.1a4ec1	29 ff 00	and #$00ff	            AND #$00FF
.1a4ec4	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4ec7	e2 20		sep #$20	            SEP #$20
.1a4ec9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]

;******  Return to file: src\basic816.s


;******  Processing file: src\variables.s

>08e1					NEXTVAR         .long ?         ; Pointer to the the next available byte for variable bindings
>08e4					VARIABLES       .long ?         ; Pointer to the most recently allocated variable
>08e7					TOFIND          .long ?         ; Pointer to the variable name to find
>08ea					TOFINDTYPE      .byte ?         ; The type to find
.0000					BINDING
>0000					TYPE            .fill 1                 ; The type of the data stored in the variable
>0001					NAME            .fill VAR_NAME_SIZE     ; The name of the variable
>0009					VALUE           .fill 4                 ; The data stored in the variable
>000d					NEXT            .fill 3                 ; The pointer to the next allocated variable of this type
.1a4ecc					INITVARS
.1a4ecc	08		php		                PHP
.1a4ecd	08		php		            PHP
.1a4ece	c2 20		rep #$20	            REP #$20
.1a4ed0	48		pha		            PHA
.1a4ed1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4ed4	5b		tcd		            TCD
.1a4ed5	68		pla		            PLA
.1a4ed6	28		plp		            PLP
.1a4ed7	c2 20		rep #$20	            REP #$20
.1a4ed9	64 e4		stz $08e4	                STZ VARIABLES           ; Clear the pointer to the variables
.1a4edb	64 e7		stz $08e7	                STZ TOFIND
.1a4edd	e2 20		sep #$20	            SEP #$20
.1a4edf	64 e6		stz $08e6	                STZ VARIABLES+2
.1a4ee1	64 e9		stz $08e9	                STZ TOFIND+2
.1a4ee3	64 ea		stz $08ea	                STZ TOFINDTYPE
.1a4ee5	c2 20		rep #$20	            REP #$20
.1a4ee7	38		sec		                SEC                     ; Compute the position of the first variable
.1a4ee8	a5 d9		lda $08d9	                LDA LASTLINE
.1a4eea	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.1a4eed	85 e1		sta $08e1	                STA NEXTVAR
.1a4eef	e2 20		sep #$20	            SEP #$20
.1a4ef1	a5 db		lda $08db	                LDA LASTLINE+2
.1a4ef3	69 00		adc #$00	                ADC #0
.1a4ef5	85 e3		sta $08e3	                STA NEXTVAR+2
.1a4ef7	28		plp		                PLP
.1a4ef8	60		rts		            RTS
.1a4ef9					ISVARCHAR
.1a4ef9	c9 5f		cmp #$5f	                CMP #'_'            ; Check if it's an underscore
.1a4efb	f0 1a		beq $1a4f17	                BEQ return_true     ; Yes: return true
.1a4efd	c9 3a		cmp #$3a	                CMP #'9'+1          ; Check if its in [0-9]
.1a4eff	b0 04		bcs $1a4f05	                BGE else1           ; No: check something else
.1a4f01	c9 30		cmp #$30	                CMP #'0'
.1a4f03	b0 12		bcs $1a4f17	                BGE return_true     ; Yes: return true
.1a4f05	c9 5b		cmp #$5b	else1           CMP #'Z'+1          ; Check if its in [A-Z]
.1a4f07	b0 04		bcs $1a4f0d	                BGE not_upper       ; No: check lower case
.1a4f09	c9 41		cmp #$41	                CMP #'A'
.1a4f0b	b0 0a		bcs $1a4f17	                BGE return_true     ; Yes: return true
.1a4f0d	c9 7b		cmp #$7b	not_upper       CMP #'z'+1          ; Check if its in [a-z]
.1a4f0f	b0 04		bcs $1a4f15	                BGE return_false    ; No: return false
.1a4f11	c9 61		cmp #$61	                CMP #'a'
.1a4f13	b0 02		bcs $1a4f17	                BGE return_true     ; Yes: return true
.1a4f15	18		clc		return_false    CLC
.1a4f16	60		rts		            RTS
.1a4f17	38		sec		return_true     SEC
.1a4f18	60		rts		            RTS
.1a4f19					VARNAMECMP
.1a4f19	08		php		                PHP
.1a4f1a	e2 20		sep #$20	            SEP #$20
.1a4f1c	c2 10		rep #$10	            REP #$10
.1a4f1e	a0 00 00	ldy #$0000	                LDY #0
.1a4f21	b7 0c		lda [$080c],y	cmp_loop        LDA [SCRATCH],Y         ; Check the character in the variable name
.1a4f23	f0 0a		beq $1a4f2f	                BEQ is_end
.1a4f25	d7 e7		cmp [$08e7],y	                CMP [TOFIND],Y          ; Compare the character to the one TOFIND
.1a4f27	d0 13		bne $1a4f3c	                BNE return_false        ; Not equal? Then this is not a match
.1a4f29	c8		iny		                INY
.1a4f2a	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.1a4f2d	d0 f2		bne $1a4f21	                BNE cmp_loop
.1a4f2f	b7 e7		lda [$08e7],y	is_end          LDA [TOFIND],Y          ; Check the character in the name to find
.1a4f31	20 41 04	jsr $1a0441	            JSR TOUPPERA
.1a4f34	20 f9 4e	jsr $1a4ef9	            JSR ISVARCHAR
.1a4f37	b0 03		bcs $1a4f3c	                BCS return_false        ; YES: we do not have a match
.1a4f39					return_true
.1a4f39	28		plp		                PLP
.1a4f3a	38		sec		                SEC
.1a4f3b	60		rts		            RTS
.1a4f3c					return_false
.1a4f3c	28		plp		                PLP
.1a4f3d	18		clc		                CLC
.1a4f3e	60		rts		            RTS
.1a4f3f					VAR_FIND
.1a4f3f	08		php		                PHP
.1a4f40	e2 20		sep #$20	            SEP #$20
.1a4f42	c2 10		rep #$10	            REP #$10
.1a4f44	a0 00 00	ldy #$0000	                LDY #0
.1a4f47	a2 00 00	ldx #$0000	                LDX #0
.1a4f4a	b7 e7		lda [$08e7],y	upper_loop      LDA [TOFIND],Y          ; Get a character
.1a4f4c	f0 0b		beq $1a4f59	                BEQ done_upper
.1a4f4e	20 41 04	jsr $1a0441	            JSR TOUPPERA
.1a4f51	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; And save it to the temp
.1a4f55	c8		iny		                INY
.1a4f56	e8		inx		                INX
.1a4f57	80 f1		bra $1a4f4a	                BRA upper_loop          ; Go back for another
.1a4f59	a9 00		lda #$00	done_upper      LDA #0
.1a4f5b	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; NULL terminate the temporary string
.1a4f5f	c2 20		rep #$20	            REP #$20
.1a4f61	a9 00 4e	lda #$4e00	                LDA #<>TEMPBUF          ; Make the temporary string the string
.1a4f64	85 e7		sta $08e7	                STA TOFIND              ; the variable name to find
.1a4f66	e2 20		sep #$20	            SEP #$20
.1a4f68	a9 00		lda #$00	                LDA #`TEMPBUF
.1a4f6a	85 e9		sta $08e9	                STA TOFIND+2
.1a4f6c	c2 20		rep #$20	            REP #$20
.1a4f6e	a5 e4		lda $08e4	                LDA VARIABLES           ; Point INDEX to the first variable to check
.1a4f70	85 08		sta $0808	                STA INDEX
.1a4f72	d0 06		bne $1a4f7a	                BNE set_index_h         ; If the low word is not 0, copy the high byte
.1a4f74	e2 20		sep #$20	            SEP #$20
.1a4f76	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a4f78	f0 4d		beq $1a4fc7	                BEQ not_found           ; If it is, we have no variables yet.
.1a4f7a					set_index_h
.1a4f7a	e2 20		sep #$20	            SEP #$20
.1a4f7c	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a4f7e	85 0a		sta $080a	                STA INDEX+2
.1a4f80	a5 ea		lda $08ea	check_binding   LDA TOFINDTYPE
.1a4f82	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Get the type of the variable
.1a4f85	d7 08		cmp [$0808],y	                CMP [INDEX],Y
.1a4f87	d0 17		bne $1a4fa0	                BNE check_next          ; If it's not a match, check the next binding
.1a4f89	c2 20		rep #$20	            REP #$20
.1a4f8b	18		clc		                CLC
.1a4f8c	a5 08		lda $0808	                LDA INDEX
.1a4f8e	69 01 00	adc #$0001	                ADC #BINDING.NAME
.1a4f91	85 0c		sta $080c	                STA SCRATCH
.1a4f93	e2 20		sep #$20	            SEP #$20
.1a4f95	a5 0a		lda $080a	                LDA INDEX+2
.1a4f97	69 00		adc #$00	                ADC #0
.1a4f99	85 0e		sta $080e	                STA SCRATCH+2
.1a4f9b	20 19 4f	jsr $1a4f19	            JSR VARNAMECMP
.1a4f9e	b0 2a		bcs $1a4fca	                BCS found               ; If they match, return that we've found the variable
.1a4fa0	a0 0d 00	ldy #$000d	check_next      LDY #BINDING.NEXT       ; SCRATCH := [INDEX].NEXT
.1a4fa3	c2 20		rep #$20	            REP #$20
.1a4fa5	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a4fa7	85 0c		sta $080c	                STA SCRATCH
.1a4fa9	c8		iny		                INY
.1a4faa	c8		iny		                INY
.1a4fab	e2 20		sep #$20	            SEP #$20
.1a4fad	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a4faf	85 0e		sta $080e	                STA SCRATCH+2
.1a4fb1	d0 06		bne $1a4fb9	                BNE set_index           ; If SCRATCH == 0, the variable wasn't found
.1a4fb3	c2 20		rep #$20	            REP #$20
.1a4fb5	a5 0c		lda $080c	                LDA SCRATCH
.1a4fb7	f0 0e		beq $1a4fc7	                BEQ not_found
.1a4fb9					set_index
.1a4fb9	c2 20		rep #$20	            REP #$20
.1a4fbb	a5 0c		lda $080c	                LDA SCRATCH
.1a4fbd	85 08		sta $0808	                STA INDEX
.1a4fbf	e2 20		sep #$20	            SEP #$20
.1a4fc1	a5 0e		lda $080e	                LDA SCRATCH+2
.1a4fc3	85 0a		sta $080a	                STA INDEX+2
.1a4fc5	80 b9		bra $1a4f80	                BRA check_binding       ; And check this next variable for a match
.1a4fc7					not_found
.1a4fc7	28		plp		                PLP
.1a4fc8	18		clc		                CLC
.1a4fc9	60		rts		            RTS
.1a4fca					found
.1a4fca	28		plp		                PLP
.1a4fcb	38		sec		                SEC
.1a4fcc	60		rts		            RTS
.1a4fcd					VAR_REF
.1a4fcd	08		php		                PHP
.1a4fce	20 3f 4f	jsr $1a4f3f	            JSR VAR_FIND
.1a4fd1	b0 1f		bcs $1a4ff2	                BCS found
.1a4fd3	08		php		            PHP
.1a4fd4	c2 20		rep #$20	            REP #$20
.1a4fd6	48		pha		            PHA
.1a4fd7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4fda	5b		tcd		            TCD
.1a4fdb	68		pla		            PLA
.1a4fdc	28		plp		            PLP
.1a4fdd	e2 20		sep #$20	            SEP #$20
.1a4fdf	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a4fe1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4fe5	c2 20		rep #$20	            REP #$20
.1a4fe7	29 ff 00	and #$00ff	            AND #$00FF
.1a4fea	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a4fed	e2 20		sep #$20	            SEP #$20
.1a4fef	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4ff2					found
.1a4ff2	c2 30		rep #$30	            REP #$30
.1a4ff4	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.1a4ff7	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a4ff9	85 23		sta $0823	                STA ARGUMENT1
.1a4ffb	c8		iny		                INY
.1a4ffc	c8		iny		                INY
.1a4ffd	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a4fff	85 25		sta $0825	                STA ARGUMENT1+2
.1a5001	e2 20		sep #$20	            SEP #$20
.1a5003	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE
.1a5006	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a5008	85 27		sta $0827	                STA ARGTYPE1
.1a500a	28		plp		done            PLP
.1a500b	60		rts		            RTS
.1a500c					VAR_ALLOC
.1a500c	08		php		                PHP
.1a500d	c2 20		rep #$20	            REP #$20
.1a500f	18		clc		                CLC                     ; Compute extent of the binding
.1a5010	a5 e1		lda $08e1	                LDA NEXTVAR
.1a5012	69 10 00	adc #$0010	                ADC #size(BINDING)
.1a5015	85 08		sta $0808	                STA INDEX
.1a5017	e2 20		sep #$20	            SEP #$20
.1a5019	a5 e3		lda $08e3	                LDA NEXTVAR+2
.1a501b	69 00		adc #$00	                ADC #0
.1a501d	85 0a		sta $080a	                STA INDEX+2
.1a501f	c5 bc		cmp $08bc	                CMP HEAP+2              ; Check to see if HEAP > INDEX
.1a5021	90 27		bcc $1a504a	                BLT has_room
.1a5023	c2 20		rep #$20	            REP #$20
.1a5025	a5 08		lda $0808	                LDA INDEX
.1a5027	c5 ba		cmp $08ba	                CMP HEAP
.1a5029	90 1f		bcc $1a504a	                BLT has_room
.1a502b	08		php		            PHP
.1a502c	c2 20		rep #$20	            REP #$20
.1a502e	48		pha		            PHA
.1a502f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5032	5b		tcd		            TCD
.1a5033	68		pla		            PLA
.1a5034	28		plp		            PLP
.1a5035	e2 20		sep #$20	            SEP #$20
.1a5037	a9 09		lda #$09	            LDA #ERR_RANGE
.1a5039	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a503d	c2 20		rep #$20	            REP #$20
.1a503f	29 ff 00	and #$00ff	            AND #$00FF
.1a5042	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a5045	e2 20		sep #$20	            SEP #$20
.1a5047	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a504a					has_room
.1a504a	c2 20		rep #$20	            REP #$20
.1a504c	a5 e1		lda $08e1	                LDA NEXTVAR             ; Yes: we can allocate the variable
.1a504e	85 c0		sta $08c0	                STA CURRBLOCK           ; Point CURRBLOCK to it
.1a5050	e2 20		sep #$20	            SEP #$20
.1a5052	a5 e3		lda $08e3	                LDA NEXTVAR+2
.1a5054	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a5056	c2 20		rep #$20	            REP #$20
.1a5058	a5 08		lda $0808	                LDA INDEX               ; And point NEXTVAR to the next possible spot
.1a505a	85 e1		sta $08e1	                STA NEXTVAR
.1a505c	e2 20		sep #$20	            SEP #$20
.1a505e	a5 0a		lda $080a	                LDA INDEX+2
.1a5060	85 e3		sta $08e3	                STA NEXTVAR+2
.1a5062	28		plp		                PLP
.1a5063	60		rts		            RTS
.1a5064					VAR_CREATE
.1a5064	08		php		                PHP
.1a5065	e2 20		sep #$20	            SEP #$20
.1a5067	a5 27		lda $0827	                LDA ARGTYPE1            ; Validate that our types match
.1a5069	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.1a506b	f0 33		beq $1a50a0	                BEQ chk_string          ; If so: check to see if it's a string
.1a506d	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable type
.1a506f	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's INTEGER
.1a5071	d0 05		bne $1a5078	                BNE chk_float
.1a5073	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a5076	80 2f		bra $1a50a7	                BRA alloc_binding       ; And bind the variable
.1a5078	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; If it's FLOAT
.1a507a	d0 05		bne $1a5081	                BNE type_error
.1a507c	20 aa 06	jsr $1a06aa	            JSR ASS_ARG1_FLOAT
.1a507f	80 26		bra $1a50a7	                BRA alloc_binding       ; And bind the variable
.1a5081					type_error
.1a5081	08		php		            PHP
.1a5082	c2 20		rep #$20	            REP #$20
.1a5084	48		pha		            PHA
.1a5085	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5088	5b		tcd		            TCD
.1a5089	68		pla		            PLA
.1a508a	28		plp		            PLP
.1a508b	e2 20		sep #$20	            SEP #$20
.1a508d	a9 04		lda #$04	            LDA #ERR_TYPE
.1a508f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5093	c2 20		rep #$20	            REP #$20
.1a5095	29 ff 00	and #$00ff	            AND #$00FF
.1a5098	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a509b	e2 20		sep #$20	            SEP #$20
.1a509d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a50a0	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING        ; Is it a string?
.1a50a2	d0 03		bne $1a50a7	                BNE alloc_binding       ; No: just go ahead and bind it
.1a50a4	20 d9 15	jsr $1a15d9	            JSR STRCPY
.1a50a7					alloc_binding
.1a50a7	c2 10		rep #$10	            REP #$10
.1a50a9	20 0c 50	jsr $1a500c	            JSR VAR_ALLOC
.1a50ac	c2 30		rep #$30	            REP #$30
.1a50ae	18		clc		                CLC
.1a50af	a5 c0		lda $08c0	                LDA CURRBLOCK
.1a50b1	69 01 00	adc #$0001	                ADC #BINDING.NAME
.1a50b4	85 08		sta $0808	                STA INDEX
.1a50b6	e2 20		sep #$20	            SEP #$20
.1a50b8	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a50ba	69 00		adc #$00	                ADC #0
.1a50bc	85 0a		sta $080a	                STA INDEX+2
.1a50be	a0 00 00	ldy #$0000	                LDY #0                  ; Ensure that the name field is blank
.1a50c1	a9 00		lda #$00	                LDA #0
.1a50c3	97 08		sta [$0808],y	blank_loop      STA [INDEX],Y
.1a50c5	c8		iny		                INY
.1a50c6	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.1a50c9	d0 f8		bne $1a50c3	                BNE blank_loop
.1a50cb	a0 00 00	ldy #$0000	                LDY #0
.1a50ce	b7 e7		lda [$08e7],y	name_loop       LDA [TOFIND],Y          ; Copy TOFIND to the NAME field
.1a50d0	f0 10		beq $1a50e2	                BEQ set_type
.1a50d2	20 41 04	jsr $1a0441	            JSR TOUPPERA
.1a50d5	20 f9 4e	jsr $1a4ef9	            JSR ISVARCHAR
.1a50d8	90 08		bcc $1a50e2	                BCC set_type
.1a50da	97 08		sta [$0808],y	                STA [INDEX],Y
.1a50dc	c8		iny		                INY
.1a50dd	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.1a50e0	d0 ec		bne $1a50ce	                BNE name_loop
.1a50e2					set_type
.1a50e2	c2 20		rep #$20	            REP #$20
.1a50e4	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE      ; Copy the value to the variable
.1a50e7	a5 23		lda $0823	                LDA ARGUMENT1
.1a50e9	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a50eb	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a50ed	c8		iny		                INY
.1a50ee	c8		iny		                INY
.1a50ef	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a50f1	a5 e4		lda $08e4	                LDA VARIABLES           ; Point NEXT to the current top of variables
.1a50f3	a0 0d 00	ldy #$000d	                LDY #BINDING.NEXT
.1a50f6	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a50f8	c8		iny		                INY
.1a50f9	c8		iny		                INY
.1a50fa	e2 20		sep #$20	            SEP #$20
.1a50fc	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a50fe	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a5100	c2 20		rep #$20	            REP #$20
.1a5102	a5 c0		lda $08c0	                LDA CURRBLOCK
.1a5104	85 e4		sta $08e4	                STA VARIABLES
.1a5106	e2 20		sep #$20	            SEP #$20
.1a5108	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a510a	85 e6		sta $08e6	                STA VARIABLES+2
.1a510c	e2 20		sep #$20	            SEP #$20
.1a510e	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Set the type of the variable
.1a5111	a5 27		lda $0827	                LDA ARGTYPE1
.1a5113	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a5115	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is it a string?
.1a5117	f0 02		beq $1a511b	                BEQ set_ref             ; Yes: add a reference count to it
.1a5119	28		plp		done            PLP
.1a511a	60		rts		            RTS
.1a511b					set_ref
.1a511b	c2 20		rep #$20	            REP #$20
.1a511d	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the a heap allocated value
.1a511f	85 c0		sta $08c0	                STA CURRBLOCK
.1a5121	e2 20		sep #$20	            SEP #$20
.1a5123	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5125	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a5127	20 f5 11	jsr $1a11f5	            JSR HEAP_GETHED
.1a512a	20 0a 12	jsr $1a120a	            JSR HEAP_ADDREF
.1a512d	80 ea		bra $1a5119	                BRA done
.1a512f					VAR_SET
.1a512f	08		php		                PHP
.1a5130	c2 30		rep #$30	            REP #$30
.1a5132	a5 e4		lda $08e4	                LDA VARIABLES          ; If VARIABLES = 0, use VAR_CREATE
.1a5134	d0 06		bne $1a513c	                BNE use_find
.1a5136	e2 20		sep #$20	            SEP #$20
.1a5138	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a513a	f0 05		beq $1a5141	                BEQ use_create
.1a513c					use_find
.1a513c	20 3f 4f	jsr $1a4f3f	            JSR VAR_FIND
.1a513f	b0 05		bcs $1a5146	                BCS found
.1a5141					use_create
.1a5141	20 64 50	jsr $1a5064	            JSR VAR_CREATE
.1a5144	80 4e		bra $1a5194	                BRA done
.1a5146					found
.1a5146	e2 20		sep #$20	            SEP #$20
.1a5148	a5 27		lda $0827	                LDA ARGTYPE1            ; Do the types match?
.1a514a	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.1a514c	f0 33		beq $1a5181	                BEQ chk_string          ; Yes: check to see if it's string
.1a514e	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable
.1a5150	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; Is it INTEGER?
.1a5152	d0 05		bne $1a5159	                BNE chk_float
.1a5154	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a5157	80 2c		bra $1a5185	                BRA set_val
.1a5159	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; Is it FLOAT?
.1a515b	d0 05		bne $1a5162	                BNE type_error          ; No: throw an error
.1a515d	20 aa 06	jsr $1a06aa	            JSR ASS_ARG1_FLOAT
.1a5160	80 23		bra $1a5185	                BRA set_val
.1a5162					type_error
.1a5162	08		php		            PHP
.1a5163	c2 20		rep #$20	            REP #$20
.1a5165	48		pha		            PHA
.1a5166	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5169	5b		tcd		            TCD
.1a516a	68		pla		            PLA
.1a516b	28		plp		            PLP
.1a516c	e2 20		sep #$20	            SEP #$20
.1a516e	a9 04		lda #$04	            LDA #ERR_TYPE
.1a5170	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5174	c2 20		rep #$20	            REP #$20
.1a5176	29 ff 00	and #$00ff	            AND #$00FF
.1a5179	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a517c	e2 20		sep #$20	            SEP #$20
.1a517e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5181	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING
.1a5183	f0 11		beq $1a5196	                BEQ set_string          ; Yes: set the string value of the variable
.1a5185					set_val
.1a5185	c2 30		rep #$30	            REP #$30
.1a5187	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.1a518a	a5 23		lda $0823	                LDA ARGUMENT1
.1a518c	97 08		sta [$0808],y	                STA [INDEX],Y
.1a518e	c8		iny		                INY
.1a518f	c8		iny		                INY
.1a5190	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5192	97 08		sta [$0808],y	                STA [INDEX],Y
.1a5194					done
.1a5194	28		plp		                PLP
.1a5195	60		rts		            RTS
.1a5196					set_string
.1a5196	20 d9 15	jsr $1a15d9	            JSR STRCPY
.1a5199	a0 09 00	ldy #$0009	set_ref         LDY #BINDING.VALUE      ; Set CURRBLOCK to the current string value
.1a519c	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a519e	85 c0		sta $08c0	                STA CURRBLOCK
.1a51a0	c8		iny		                INY
.1a51a1	c8		iny		                INY
.1a51a2	e2 20		sep #$20	            SEP #$20
.1a51a4	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a51a6	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a51a8	20 f5 11	jsr $1a11f5	            JSR HEAP_GETHED
.1a51ab	20 29 12	jsr $1a1229	            JSR HEAP_REMREF
.1a51ae	e2 20		sep #$20	            SEP #$20
.1a51b0	a5 27		lda $0827	                LDA ARGTYPE1
.1a51b2	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is the new value a string?
.1a51b4	f0 02		beq $1a51b8	                BEQ add_ref             ; Yes: add a reference to it
.1a51b6	80 cd		bra $1a5185	                BRA set_val             ; No: go back to set the value... this probably shouldn't happen
.1a51b8					add_ref
.1a51b8	c2 20		rep #$20	            REP #$20
.1a51ba	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the new string value
.1a51bc	85 c0		sta $08c0	                STA CURRBLOCK
.1a51be	e2 20		sep #$20	            SEP #$20
.1a51c0	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a51c2	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a51c4	20 f5 11	jsr $1a11f5	            JSR HEAP_GETHED
.1a51c7	20 0a 12	jsr $1a120a	            JSR HEAP_ADDREF
.1a51ca	80 b9		bra $1a5185	                BRA set_val
.1a51cc					VAR_FINDNAME
.1a51cc	08		php		                PHP
.1a51cd	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a51d0	e2 20		sep #$20	            SEP #$20
.1a51d2	a7 00		lda [$0800]	                LDA [BIP]           ; Get the first character
.1a51d4	20 cd 03	jsr $1a03cd	            JSR ISALPHA
.1a51d7	90 42		bcc $1a521b	                BCC not_found
.1a51d9	c2 20		rep #$20	            REP #$20
.1a51db	a5 00		lda $0800	                LDA BIP
.1a51dd	85 e7		sta $08e7	                STA TOFIND
.1a51df	e2 20		sep #$20	            SEP #$20
.1a51e1	a5 02		lda $0802	                LDA BIP+2
.1a51e3	85 e9		sta $08e9	                STA TOFIND+2
.1a51e5					loop
.1a51e5	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a51e8	a7 00		lda [$0800]	                LDA [BIP]
.1a51ea	f0 0d		beq $1a51f9	                BEQ is_float        ; If it's EOL, the variable is a float
.1a51ec	c9 24		cmp #$24	                CMP #'$'            ; If it's $, the variable is a string
.1a51ee	f0 14		beq $1a5204	                BEQ is_string
.1a51f0	c9 25		cmp #$25	                CMP #'%'            ; If it's %, the variable is an integer
.1a51f2	f0 09		beq $1a51fd	                BEQ is_integer
.1a51f4	20 f9 4e	jsr $1a4ef9	            JSR ISVARCHAR
.1a51f7	b0 ec		bcs $1a51e5	                BCS loop            ; Check the next one
.1a51f9	a9 01		lda #$01	is_float        LDA #TYPE_FLOAT     ; Otherwise it's a float
.1a51fb	80 0c		bra $1a5209	                BRA set_type
.1a51fd					is_integer
.1a51fd	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a5200	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a5202	80 05		bra $1a5209	                BRA set_type
.1a5204					is_string
.1a5204	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a5207	a9 02		lda #$02	                LDA #TYPE_STRING
.1a5209	85 ea		sta $08ea	set_type        STA TOFINDTYPE
.1a520b	20 f8 20	jsr $1a20f8	            JSR PEEK_TOK
.1a520e	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it "("?
.1a5210	d0 06		bne $1a5218	                BNE done            ; No: we're done... it's just a scalar variable
.1a5212	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Yes: this is an array reference
.1a5214	09 80		ora #$80	                ORA #$80            ; ... turn on the "Array of..." bit
.1a5216	85 ea		sta $08ea	                STA TOFINDTYPE
.1a5218					done
.1a5218	28		plp		                PLP
.1a5219	38		sec		                SEC
.1a521a	60		rts		            RTS
.1a521b	28		plp		not_found       PLP
.1a521c	18		clc		                CLC
.1a521d	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\integers.s

.1a521e					OP_INT_ADD
.1a521e	08		php		            PHP
.1a521f	c2 20		rep #$20	            REP #$20
.1a5221	18		clc		            CLC
.1a5222	a5 23		lda $0823	            LDA ARGUMENT1
.1a5224	65 29		adc $0829	            ADC ARGUMENT2
.1a5226	85 23		sta $0823	            STA ARGUMENT1
.1a5228	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a522a	65 2b		adc $082b	            ADC ARGUMENT2+2
.1a522c	85 25		sta $0825	            STA ARGUMENT1+2
.1a522e	28		plp		            PLP
.1a522f	60		rts		            RTS
.1a5230					OP_INT_SUB
.1a5230	08		php		            PHP
.1a5231	c2 20		rep #$20	            REP #$20
.1a5233	38		sec		            SEC
.1a5234	a5 23		lda $0823	            LDA ARGUMENT1
.1a5236	e5 29		sbc $0829	            SBC ARGUMENT2
.1a5238	85 23		sta $0823	            STA ARGUMENT1
.1a523a	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a523c	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.1a523e	85 25		sta $0825	            STA ARGUMENT1+2
.1a5240	28		plp		            PLP
.1a5241	60		rts		            RTS
.1a5242					OP_INT_MUL
.1a5242	08		php		            PHP
.1a5243					locals
>0001					L_SIGN      .word ?
>0003					L_RESULT    .dword ?
>0007					            .dword ?
.1a5243	c2 20		rep #$20	            REP #$20
.1a5245	3b		tsc		            TSC
.1a5246	38		sec		            SEC
.1a5247	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.1a524a	1b		tcs		            TCS
.1a524b	c2 30		rep #$30	            REP #$30
.1a524d	a9 00 00	lda #$0000	            LDA #0                  ; Start by assuming positive numbers
.1a5250	83 01		sta $01,s	            STA L_SIGN
.1a5252	83 03		sta $03,s	            STA L_RESULT            ; Clear result
.1a5254	83 05		sta $05,s	            STA L_RESULT+2
.1a5256	83 07		sta $07,s	            STA L_RESULT+4
.1a5258	83 09		sta $09,s	            STA L_RESULT+6
.1a525a	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Ensure ARGUMENT1 is positive
.1a525c	10 18		bpl $1a5276	            BPL chk_sign2
.1a525e	a9 00 80	lda #$8000	            LDA #$8000              ; Record that ARGUMENT1 is negative
.1a5261	83 01		sta $01,s	            STA L_SIGN
.1a5263	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Take the two's complement of ARGUMENT1
.1a5265	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a5268	85 25		sta $0825	            STA ARGUMENT1+2
.1a526a	a5 23		lda $0823	            LDA ARGUMENT1
.1a526c	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a526f	1a		inc a		            INC A
.1a5270	85 23		sta $0823	            STA ARGUMENT1
.1a5272	d0 02		bne $1a5276	            BNE chk_sign2
.1a5274	e6 25		inc $0825	            INC ARGUMENT1+2
.1a5276	a5 2b		lda $082b	chk_sign2   LDA ARGUMENT2+2         ; Ensure ARGUMENT2 is positive
.1a5278	10 1a		bpl $1a5294	            BPL chk_over
.1a527a	a3 01		lda $01,s	            LDA L_SIGN              ; Flip the sign
.1a527c	49 00 80	eor #$8000	            EOR #$8000
.1a527f	83 01		sta $01,s	            STA L_SIGN
.1a5281	a5 2b		lda $082b	            LDA ARGUMENT2+2         ; Take the two's complement of ARGUMENT2
.1a5283	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a5286	85 2b		sta $082b	            STA ARGUMENT2+2
.1a5288	a5 29		lda $0829	            LDA ARGUMENT2
.1a528a	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a528d	1a		inc a		            INC A
.1a528e	85 29		sta $0829	            STA ARGUMENT2
.1a5290	d0 02		bne $1a5294	            BNE chk_over
.1a5292	e6 2b		inc $082b	            INC ARGUMENT2+2
.1a5294					chk_over
.1a5294	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5296	f0 04		beq $1a529c	            BEQ do_mult
.1a5298	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a529a	d0 5a		bne $1a52f6	            BNE overflow
.1a529c					do_mult
.1a529c	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*D
.1a529e	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.1a52a2	a5 29		lda $0829	            LDA ARGUMENT2
.1a52a4	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.1a52a8	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.1a52ac	83 03		sta $03,s	            STA L_RESULT
.1a52ae	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.1a52b2	83 05		sta $05,s	            STA L_RESULT+2
.1a52b4	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Calculate A*D << 16 + B*D
.1a52b6	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.1a52ba	a5 29		lda $0829	            LDA ARGUMENT2
.1a52bc	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.1a52c0	18		clc		            CLC
.1a52c1	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.1a52c5	63 05		adc $05,s	            ADC L_RESULT+2
.1a52c7	83 05		sta $05,s	            STA L_RESULT+2
.1a52c9	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.1a52cd	63 07		adc $07,s	            ADC L_RESULT+4
.1a52cf	83 07		sta $07,s	            STA L_RESULT+4
.1a52d1	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*C << 16 + A*D << 16 + B*D
.1a52d3	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.1a52d7	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a52d9	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.1a52dd	18		clc		            CLC
.1a52de	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.1a52e2	63 05		adc $05,s	            ADC L_RESULT+2
.1a52e4	83 05		sta $05,s	            STA L_RESULT+2
.1a52e6	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.1a52ea	63 07		adc $07,s	            ADC L_RESULT+4
.1a52ec	83 07		sta $07,s	            STA L_RESULT+4
.1a52ee	a3 07		lda $07,s	            LDA L_RESULT+4
.1a52f0	f0 23		beq $1a5315	            BEQ no_overflow
.1a52f2	a3 09		lda $09,s	            LDA L_RESULT+6
.1a52f4	f0 1f		beq $1a5315	            BEQ no_overflow
.1a52f6					overflow
.1a52f6	08		php		            PHP
.1a52f7	c2 20		rep #$20	            REP #$20
.1a52f9	48		pha		            PHA
.1a52fa	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a52fd	5b		tcd		            TCD
.1a52fe	68		pla		            PLA
.1a52ff	28		plp		            PLP
.1a5300	e2 20		sep #$20	            SEP #$20
.1a5302	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.1a5304	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5308	c2 20		rep #$20	            REP #$20
.1a530a	29 ff 00	and #$00ff	            AND #$00FF
.1a530d	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a5310	e2 20		sep #$20	            SEP #$20
.1a5312	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5315					no_overflow
.1a5315	c2 30		rep #$30	            REP #$30
.1a5317	a3 01		lda $01,s	            LDA L_SIGN              ; Check the sign
.1a5319	10 16		bpl $1a5331	            BPL ret_result          ; If positive: just return the result
.1a531b	a3 05		lda $05,s	            LDA L_RESULT+2          ; Compute the two's complement of the result
.1a531d	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a5320	83 05		sta $05,s	            STA L_RESULT+2
.1a5322	a3 03		lda $03,s	            LDA L_RESULT
.1a5324	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a5327	1a		inc a		            INC A
.1a5328	83 03		sta $03,s	            STA L_RESULT
.1a532a	d0 05		bne $1a5331	            BNE ret_result
.1a532c	a3 05		lda $05,s	            LDA L_RESULT+2
.1a532e	1a		inc a		            INC A
.1a532f	83 05		sta $05,s	            STA L_RESULT+2
.1a5331					ret_result
.1a5331	a3 03		lda $03,s	            LDA L_RESULT
.1a5333	85 23		sta $0823	            STA ARGUMENT1
.1a5335	a3 05		lda $05,s	            LDA L_RESULT+2
.1a5337	85 25		sta $0825	            STA ARGUMENT1+2
.1a5339	c2 20		rep #$20	            REP #$20
.1a533b	3b		tsc		            TSC
.1a533c	18		clc		            CLC
.1a533d	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.1a5340	1b		tcs		            TCS
.1a5341	28		plp		            PLP
.1a5342	60		rts		            RTS
.1a5343					OP_INT_LT
.1a5343	08		php		            PHP
.1a5344	c2 20		rep #$20	            REP #$20
.1a5346	a5 23		lda $0823	            LDA ARGUMENT1
.1a5348	c5 29		cmp $0829	            CMP ARGUMENT2
.1a534a	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a534c	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.1a534e	50 03		bvc $1a5353	            BVC skip_eor
.1a5350	49 00 80	eor #$8000	            EOR #$8000
.1a5353	30 06		bmi $1a535b	skip_eor    BMI ret_true
.1a5355	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a5357	64 25		stz $0825	            STZ ARGUMENT1+2
.1a5359	80 07		bra $1a5362	            BRA done
.1a535b	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a535e	85 23		sta $0823	            STA ARGUMENT1
.1a5360	85 25		sta $0825	            STA ARGUMENT1+2
.1a5362	28		plp		done        PLP
.1a5363	60		rts		            RTS
.1a5364					OP_INT_GT
.1a5364	08		php		            PHP
.1a5365	c2 20		rep #$20	            REP #$20
.1a5367	a5 23		lda $0823	            LDA ARGUMENT1
.1a5369	c5 29		cmp $0829	            CMP ARGUMENT2
.1a536b	d0 0c		bne $1a5379	            BNE test_fully
.1a536d	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a536f	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.1a5371	d0 06		bne $1a5379	            BNE test_fully
.1a5373	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a5375	64 25		stz $0825	            STZ ARGUMENT1+2
.1a5377	80 16		bra $1a538f	            BRA done
.1a5379	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.1a537b	c5 23		cmp $0823	            CMP ARGUMENT1
.1a537d	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a537f	e5 25		sbc $0825	            SBC ARGUMENT1+2
.1a5381	50 03		bvc $1a5386	            BVC skip_eor
.1a5383	49 00 80	eor #$8000	            EOR #$8000
.1a5386	10 eb		bpl $1a5373	skip_eor    BPL ret_false
.1a5388	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a538b	85 23		sta $0823	            STA ARGUMENT1
.1a538d	85 25		sta $0825	            STA ARGUMENT1+2
.1a538f	28		plp		done        PLP
.1a5390	60		rts		            RTS
.1a5391					OP_INT_EQ
.1a5391	08		php		            PHP
.1a5392	c2 20		rep #$20	            REP #$20
.1a5394	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a5396	c5 25		cmp $0825	            CMP ARGUMENT1+2
.1a5398	d0 0f		bne $1a53a9	            BNE ret_false
.1a539a	a5 29		lda $0829	            LDA ARGUMENT2
.1a539c	c5 23		cmp $0823	            CMP ARGUMENT1
.1a539e	d0 09		bne $1a53a9	            BNE ret_false
.1a53a0	a9 ff ff	lda #$ffff	            LDA #$FFFF
.1a53a3	85 23		sta $0823	            STA ARGUMENT1
.1a53a5	85 25		sta $0825	            STA ARGUMENT1+2
.1a53a7	80 04		bra $1a53ad	            BRA done
.1a53a9	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a53ab	64 25		stz $0825	            STZ ARGUMENT1+2
.1a53ad	28		plp		done        PLP
.1a53ae	60		rts		            RTS
.1a53af					OP_INT_NE
.1a53af	08		php		            PHP
.1a53b0	c2 20		rep #$20	            REP #$20
.1a53b2	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a53b4	c5 25		cmp $0825	            CMP ARGUMENT1+2
.1a53b6	d0 0c		bne $1a53c4	            BNE ret_true
.1a53b8	a5 29		lda $0829	            LDA ARGUMENT2
.1a53ba	c5 23		cmp $0823	            CMP ARGUMENT1
.1a53bc	d0 06		bne $1a53c4	            BNE ret_true
.1a53be	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a53c0	64 25		stz $0825	            STZ ARGUMENT1+2
.1a53c2	80 07		bra $1a53cb	            BRA done
.1a53c4	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a53c7	85 23		sta $0823	            STA ARGUMENT1
.1a53c9	85 25		sta $0825	            STA ARGUMENT1+2
.1a53cb	28		plp		done        PLP
.1a53cc	60		rts		            RTS
.1a53cd					OP_INT_GTE
.1a53cd	08		php		            PHP
.1a53ce	c2 20		rep #$20	            REP #$20
.1a53d0	a5 23		lda $0823	            LDA ARGUMENT1
.1a53d2	c5 29		cmp $0829	            CMP ARGUMENT2
.1a53d4	d0 0f		bne $1a53e5	            BNE test_fully
.1a53d6	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a53d8	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.1a53da	d0 09		bne $1a53e5	            BNE test_fully
.1a53dc	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a53df	85 23		sta $0823	            STA ARGUMENT1
.1a53e1	85 25		sta $0825	            STA ARGUMENT1+2
.1a53e3	80 13		bra $1a53f8	            BRA done
.1a53e5	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.1a53e7	c5 23		cmp $0823	            CMP ARGUMENT1
.1a53e9	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a53eb	e5 25		sbc $0825	            SBC ARGUMENT1+2
.1a53ed	50 03		bvc $1a53f2	            BVC skip_eor
.1a53ef	49 00 80	eor #$8000	            EOR #$8000
.1a53f2	30 e8		bmi $1a53dc	skip_eor    BMI ret_true
.1a53f4	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a53f6	64 25		stz $0825	            STZ ARGUMENT1+2
.1a53f8	28		plp		done        PLP
.1a53f9	60		rts		            RTS
.1a53fa					OP_INT_LTE
.1a53fa	08		php		            PHP
.1a53fb	c2 20		rep #$20	            REP #$20
.1a53fd	a5 23		lda $0823	            LDA ARGUMENT1
.1a53ff	c5 29		cmp $0829	            CMP ARGUMENT2
.1a5401	d0 0f		bne $1a5412	            BNE test_fully
.1a5403	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5405	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.1a5407	d0 09		bne $1a5412	            BNE test_fully
.1a5409	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a540c	85 23		sta $0823	            STA ARGUMENT1
.1a540e	85 25		sta $0825	            STA ARGUMENT1+2
.1a5410	80 13		bra $1a5425	            BRA done
.1a5412	a5 23		lda $0823	test_fully  LDA ARGUMENT1
.1a5414	c5 29		cmp $0829	            CMP ARGUMENT2
.1a5416	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5418	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.1a541a	50 03		bvc $1a541f	            BVC skip_eor
.1a541c	49 00 80	eor #$8000	            EOR #$8000
.1a541f	30 e8		bmi $1a5409	skip_eor    BMI ret_true
.1a5421	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a5423	64 25		stz $0825	            STZ ARGUMENT1+2
.1a5425	28		plp		done        PLP
.1a5426	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\floats.s


;******  Processing file: src\C256/floats.s


;******  Processing file: src\C256/fp_math_defs.s

=$afe200				FP_MATH_CTRL0 = $AFE200         ; Read/write
=$08					FP_MATH_CTRL0_ADD = $08         ; 0: Substraction - 1: Addition
=$01					FP_CTRL0_CONV_0 = %00000001     ; Input 0 should be converted from 24.12 fixed point to floating point
=$02					FP_CTRL0_CONV_1 = %00000010     ; Input 1 should be converted from 24.12 fixed point to floating point
=$00					FP_ADD_IN0_MUX0 = %00000000     ; Adder input #0 is the output of MUX0
=$10					FP_ADD_IN0_MUX1 = %00010000     ; Adder input #0 is the output of MUX1
=$20					FP_ADD_IN0_MULT = %00100000     ; Adder input #0 is the output of the multiplier
=$30					FP_ADD_IN0_DIV  = %00110000     ; Adder input #0 is the output of the divider
=$00					FP_ADD_IN1_MUX0 = %00000000     ; Adder input #1 is the output of MUX0
=$40					FP_ADD_IN1_MUX1 = %01000000     ; Adder input #1 is the output of MUX1
=$80					FP_ADD_IN1_MULT = %10000000     ; Adder input #1 is the output of the multiplier
=$c0					FP_ADD_IN1_DIV  = %11000000     ; Adder input #1 is the output of the divider
=$afe201				FP_MATH_CTRL1 = $AFE201
=$00					FP_OUT_MULT = %00000000         ; Output is from the multiplier
=$01					FP_OUT_DIV  = %00000001         ; Output is from the divider
=$02					FP_OUT_ADD  = %00000010         ; Output is from the adder/subtracter
=$03					FP_OUT_ONE  = %00000011         ; Output is the constant '1.0'
=$afe202				FP_MATH_CTRL2 = $AFE202         ; Not Used - Reserved
=$afe203				FP_MATH_CTRL3 = $AFE203         ; Not Used - Reserved
=$afe204				FP_MATH_MULT_STAT = $AFE204     ; Status of the multiplier
=$01					FP_MULT_STAT_NAN  = $01         ; (NAN) Not a Number Status
=$02					FP_MULT_STAT_OVF  = $02         ; Overflow
=$04					FP_MULT_STAT_UDF  = $04         ; Underflow
=$08					FP_MULT_STAT_ZERO = $08         ; Zero
=$afe205				FP_MATH_DIV_STAT  = $AFE205     ; Status of the divider
=$01					FP_DIV_STAT_NAN       = $01     ; Not a number Status
=$02					FP_DIV_STAT_OVF       = $02     ; Overflow
=$04					FP_DIV_STAT_UDF       = $04     ; Underflow
=$08					FP_DIV_STAT_ZERO      = $08     ; Zero
=$10					FP_DIV_STAT_DIVBYZERO = $10     ; Division by Zero
=$afe206				FP_MATH_ADD_STAT  = $AFE206     ; Status of the adder/subtracter
=$01					FP_ADD_STAT_NAN  = $01          ; Not a number Status
=$02					FP_ADD_STAT_OVF  = $02          ; Overflow
=$04					FP_ADD_STAT_UDF  = $04          ; Underflow
=$08					FP_ADD_STAT_ZERO = $08          ; Zero
=$afe207				FP_MATH_CONV_STAT = $AFE207     ; Status of the fixed <=> float converters
=$01					FP_CONV_STAT_NAN  = $01         ; Not a number Status
=$02					FP_CONV_STAT_OVF  = $02         ; Overflow
=$04					FP_CONV_STAT_UDF  = $04         ; Underflow
=$afe208				FP_MATH_INPUT0_LL = $AFE208
=$afe209				FP_MATH_INPUT0_LH = $AFE209
=$afe20a				FP_MATH_INPUT0_HL = $AFE20A
=$afe20b				FP_MATH_INPUT0_HH = $AFE20B
=$afe20c				FP_MATH_INPUT1_LL = $AFE20C
=$afe20d				FP_MATH_INPUT1_LH = $AFE20D
=$afe20e				FP_MATH_INPUT1_HL = $AFE20E
=$afe20f				FP_MATH_INPUT1_HH = $AFE20F
=$afe208				FP_MATH_OUTPUT_FP_LL = $AFE208
=$afe209				FP_MATH_OUTPUT_FP_LH = $AFE209
=$afe20a				FP_MATH_OUTPUT_FP_HL = $AFE20A
=$afe20b				FP_MATH_OUTPUT_FP_HH = $AFE20B
=$afe20c				FP_MATH_OUTPUT_FIXED_LL = $AFE20C
=$afe20d				FP_MATH_OUTPUT_FIXED_LH = $AFE20D
=$afe20e				FP_MATH_OUTPUT_FIXED_HL = $AFE20E
=$afe20f				FP_MATH_OUTPUT_FIXED_HH = $AFE20F

;******  Return to file: src\C256/floats.s


;******  Processing file: src\C256/math_cop.s

.1a5427					UINT_DIV_A_X
.1a5427	08		php		                    PHP
.1a5428	c2 20		rep #$20	            REP #$20
.1a542a	8f 12 01 00	sta $000112	                    STA @l UNSIGNED_DIV_NUM_LO
.1a542e	8a		txa		                    TXA
.1a542f	8f 10 01 00	sta $000110	                    STA @l UNSIGNED_DIV_DEM_LO
.1a5433	af 16 01 00	lda $000116	                    LDA @l UNSIGNED_DIV_REM_LO
.1a5437	aa		tax		                    TAX
.1a5438	af 14 01 00	lda $000114	                    LDA @l UNSIGNED_DIV_QUO_LO
.1a543c	28		plp		                    PLP
.1a543d	60		rts		            RTS

;******  Return to file: src\C256/floats.s

.1a543e					FIXINT_TO_FP
.1a543e	08		php		                    PHP
.1a543f	e2 20		sep #$20	            SEP #$20
.1a5441	a9 03		lda #$03	                    LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.1a5443	8f 00 e2 af	sta $afe200	                    STA @l FP_MATH_CTRL0
.1a5447	a9 00		lda #$00	                    LDA #FP_OUT_MULT
.1a5449	8f 01 e2 af	sta $afe201	                    STA @l FP_MATH_CTRL1
.1a544d	c2 20		rep #$20	            REP #$20
.1a544f	a5 23		lda $0823	                    LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a5451	8f 08 e2 af	sta $afe208	                    STA @l FP_MATH_INPUT0_LL
.1a5455	a5 25		lda $0825	                    LDA ARGUMENT1+2
.1a5457	8f 0a e2 af	sta $afe20a	                    STA @l FP_MATH_INPUT0_HL
.1a545b	a9 00 00	lda #$0000	                    LDA #0
.1a545e	8f 0c e2 af	sta $afe20c	                    STA @l FP_MATH_INPUT1_LL    ; ARGUMENT2 = 0100 0000 = 4096 in 20:12
.1a5462	a9 00 01	lda #$0100	                    LDA #$0100
.1a5465	8f 0e e2 af	sta $afe20e	                    STA @l FP_MATH_INPUT1_HL
.1a5469	ea		nop		                    NOP
.1a546a	ea		nop		                    NOP
.1a546b	ea		nop		                    NOP
.1a546c	ea		nop		                    NOP
.1a546d	ea		nop		                    NOP
.1a546e	ea		nop		                    NOP
.1a546f	af 08 e2 af	lda $afe208	                    LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.1a5473	85 23		sta $0823	                    STA ARGUMENT1
.1a5475	af 0a e2 af	lda $afe20a	                    LDA @l FP_MATH_OUTPUT_FP_HL
.1a5479	85 25		sta $0825	                    STA ARGUMENT1+2
.1a547b	a9 01 00	lda #$0001	                    LDA #TYPE_FLOAT
.1a547e	85 27		sta $0827	                    STA ARGTYPE1
.1a5480	28		plp		                    PLP
.1a5481	60		rts		            RTS
.1a5482	08		php		OP_FP_SUB       PHP
.1a5483	e2 20		sep #$20	            SEP #$20
.1a5485	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a5487	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a548b	80 09		bra $1a5496	                BRA FP_ADD_SUB
.1a548d	08		php		OP_FP_ADD       PHP
.1a548e	e2 20		sep #$20	            SEP #$20
.1a5490	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a5492	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a5496	a9 02		lda #$02	FP_ADD_SUB      LDA #FP_OUT_ADD
.1a5498	8f 01 e2 af	sta $afe201	                STA @lFP_MATH_CTRL1
.1a549c	c2 20		rep #$20	            REP #$20
.1a549e	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a54a0	8f 08 e2 af	sta $afe208	                STA @lFP_MATH_INPUT0_LL
.1a54a4	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a54a6	8f 0a e2 af	sta $afe20a	                STA @lFP_MATH_INPUT0_HL
.1a54aa	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.1a54ac	8f 0c e2 af	sta $afe20c	                STA @lFP_MATH_INPUT1_LL
.1a54b0	a5 2b		lda $082b	                LDA ARGUMENT2+2
.1a54b2	8f 0e e2 af	sta $afe20e	                STA @lFP_MATH_INPUT1_HL
.1a54b6	ea		nop		                NOP
.1a54b7	ea		nop		                NOP
.1a54b8	ea		nop		                NOP
.1a54b9	e2 20		sep #$20	            SEP #$20
.1a54bb	af 06 e2 af	lda $afe206	                LDA @lFP_MATH_ADD_STAT      ; Check the status of the addition
.1a54bf	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.1a54c1	d0 10		bne $1a54d3	                BNE fp_add_error            ; If an issue was raise, process the math error
.1a54c3	c2 20		rep #$20	            REP #$20
.1a54c5	af 08 e2 af	lda $afe208	                LDA @lFP_MATH_OUTPUT_FP_LL  ; Retrieve the results into ARGUMENT1
.1a54c9	85 23		sta $0823	                STA ARGUMENT1
.1a54cb	af 0a e2 af	lda $afe20a	                LDA @lFP_MATH_OUTPUT_FP_HL
.1a54cf	85 25		sta $0825	                STA ARGUMENT1+2
.1a54d1	28		plp		fp_add_done     PLP
.1a54d2	60		rts		            RTS
.1a54d3					fp_add_error
.1a54d3	20 6e 55	jsr $1a556e	            JSR FP_MATH_ERROR
.1a54d6	80 f9		bra $1a54d1	                BRA fp_add_done
.1a54d8	08		php		OP_FP_DIV       PHP
.1a54d9	e2 20		sep #$20	            SEP #$20
.1a54db	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a54dd	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a54e1	a9 00		lda #$00	                LDA #0
.1a54e3	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a54e7	c2 20		rep #$20	            REP #$20
.1a54e9	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a54eb	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a54ef	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a54f1	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a54f5	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.1a54f7	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a54fb	a5 2b		lda $082b	                LDA ARGUMENT2+2
.1a54fd	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5501	ea		nop		                NOP
.1a5502	ea		nop		                NOP
.1a5503	ea		nop		                NOP
.1a5504	e2 20		sep #$20	            SEP #$20
.1a5506	af 05 e2 af	lda $afe205	                LDA @l FP_MATH_DIV_STAT     ; Check the status of the addition
.1a550a	29 17		and #$17	                AND #%00010111              ; Filter out the ZERO status
.1a550c	d0 10		bne $1a551e	                BNE fp_div_error            ; If an issue was raise, process the math error
.1a550e	c2 20		rep #$20	            REP #$20
.1a5510	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.1a5514	85 23		sta $0823	                STA ARGUMENT1
.1a5516	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a551a	85 25		sta $0825	                STA ARGUMENT1+2
.1a551c	28		plp		fp_div_done     PLP
.1a551d	60		rts		            RTS
.1a551e					fp_div_error
.1a551e	20 6e 55	jsr $1a556e	            JSR FP_MATH_ERROR
.1a5521	80 f9		bra $1a551c	                BRA fp_div_done
.1a5523	08		php		OP_FP_MUL       PHP
.1a5524	e2 20		sep #$20	            SEP #$20
.1a5526	a9 00		lda #$00	                LDA #FP_OUT_MULT
.1a5528	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a552c	a9 00		lda #$00	                LDA #0
.1a552e	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a5532	c2 20		rep #$20	            REP #$20
.1a5534	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a5536	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a553a	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a553c	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5540	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.1a5542	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5546	a5 2b		lda $082b	                LDA ARGUMENT2+2
.1a5548	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a554c	ea		nop		                NOP
.1a554d	ea		nop		                NOP
.1a554e	ea		nop		                NOP
.1a554f	e2 20		sep #$20	            SEP #$20
.1a5551	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT    ; Check the status of the addition
.1a5555	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.1a5557	d0 10		bne $1a5569	                BNE fp_mul_error            ; If an issue was raise, process the math error
.1a5559	c2 20		rep #$20	            REP #$20
.1a555b	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.1a555f	85 23		sta $0823	                STA ARGUMENT1
.1a5561	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5565	85 25		sta $0825	                STA ARGUMENT1+2
.1a5567	28		plp		fp_mul_done     PLP
.1a5568	60		rts		            RTS
.1a5569					fp_mul_error
.1a5569	20 6e 55	jsr $1a556e	            JSR FP_MATH_ERROR
.1a556c	80 f9		bra $1a5567	                BRA fp_mul_done
.1a556e					FP_MATH_ERROR
.1a556e	e2 20		sep #$20	            SEP #$20
.1a5570	89 01		bit #$01	                BIT #FP_ADD_STAT_NAN        ; Is there a NaN condition?
.1a5572	f0 20		beq $1a5594	                BEQ check_over              ; No: check for overflow
.1a5574	00		brk #		                BRK
.1a5575	08		php		            PHP
.1a5576	c2 20		rep #$20	            REP #$20
.1a5578	48		pha		            PHA
.1a5579	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a557c	5b		tcd		            TCD
.1a557d	68		pla		            PLA
.1a557e	28		plp		            PLP
.1a557f	e2 20		sep #$20	            SEP #$20
.1a5581	a9 0c		lda #$0c	            LDA #ERR_NAN
.1a5583	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5587	c2 20		rep #$20	            REP #$20
.1a5589	29 ff 00	and #$00ff	            AND #$00FF
.1a558c	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a558f	e2 20		sep #$20	            SEP #$20
.1a5591	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5594	89 02		bit #$02	check_over      BIT #FP_ADD_STAT_OVF        ; Is ther an overflow condition?
.1a5596	f0 1f		beq $1a55b7	                BEQ check_under             ; No: check for underflow
.1a5598	08		php		            PHP
.1a5599	c2 20		rep #$20	            REP #$20
.1a559b	48		pha		            PHA
.1a559c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a559f	5b		tcd		            TCD
.1a55a0	68		pla		            PLA
.1a55a1	28		plp		            PLP
.1a55a2	e2 20		sep #$20	            SEP #$20
.1a55a4	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.1a55a6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a55aa	c2 20		rep #$20	            REP #$20
.1a55ac	29 ff 00	and #$00ff	            AND #$00FF
.1a55af	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a55b2	e2 20		sep #$20	            SEP #$20
.1a55b4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a55b7	89 04		bit #$04	check_under     BIT #FP_ADD_STAT_UDF        ; Is there an underflow condition?
.1a55b9	f0 1f		beq $1a55da	                BEQ done                    ; No: we should just return... this probably shouldn't happen
.1a55bb	08		php		            PHP
.1a55bc	c2 20		rep #$20	            REP #$20
.1a55be	48		pha		            PHA
.1a55bf	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a55c2	5b		tcd		            TCD
.1a55c3	68		pla		            PLA
.1a55c4	28		plp		            PLP
.1a55c5	e2 20		sep #$20	            SEP #$20
.1a55c7	a9 0e		lda #$0e	            LDA #ERR_UNDERFLOW
.1a55c9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a55cd	c2 20		rep #$20	            REP #$20
.1a55cf	29 ff 00	and #$00ff	            AND #$00FF
.1a55d2	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a55d5	e2 20		sep #$20	            SEP #$20
.1a55d7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a55da					done
.1a55da	60		rts		            RTS
.1a55db					FP_MUL10
.1a55db	08		php		                PHP
.1a55dc	e2 20		sep #$20	            SEP #$20
.1a55de	a9 00		lda #$00	                LDA #FP_OUT_MULT                ; Set for multiplication
.1a55e0	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a55e4	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1            ; Input 1 is fixed point
.1a55e6	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a55ea	c2 20		rep #$20	            REP #$20
.1a55ec	a9 00 a0	lda #$a000	                LDA #$A000                      ; 10 is one factor
.1a55ef	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a55f3	a9 00 00	lda #$0000	                LDA #0
.1a55f6	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a55fa	a5 23		lda $0823	                LDA ARGUMENT1                   ; N is the other
.1a55fc	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5600	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5602	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5606	ea		nop		                NOP
.1a5607	ea		nop		                NOP
.1a5608	ea		nop		                NOP
.1a5609	e2 20		sep #$20	            SEP #$20
.1a560b	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT        ; Check the status
.1a560f	89 07		bit #$07	                BIT #FP_MULT_STAT_NAN | FP_MULT_STAT_OVF | FP_MULT_STAT_UDF
.1a5611	f0 01		beq $1a5614	                BEQ ret_result
.1a5613	00		brk #		                BRK                             ; There was an error...
.1a5614					ret_result
.1a5614	c2 20		rep #$20	            REP #$20
.1a5616	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL     ; Save result back
.1a561a	85 23		sta $0823	                STA ARGUMENT1
.1a561c	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5620	85 25		sta $0825	                STA ARGUMENT1+2
.1a5622	28		plp		                PLP
.1a5623	60		rts		            RTS
.1a5624					FP_DIV10
.1a5624	08		php		                PHP
.1a5625	e2 20		sep #$20	            SEP #$20
.1a5627	a9 01		lda #$01	                LDA #FP_OUT_DIV             ; Set for multiplication
.1a5629	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a562d	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1        ; Input 1 is fixed point
.1a562f	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5633	c2 20		rep #$20	            REP #$20
.1a5635	a9 00 a0	lda #$a000	                LDA #$A000                  ; 10 is one factor
.1a5638	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a563c	a9 00 00	lda #$0000	                LDA #0
.1a563f	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5643	a5 23		lda $0823	                LDA ARGUMENT1               ; N is the other
.1a5645	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5649	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a564b	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a564f	ea		nop		                NOP
.1a5650	ea		nop		                NOP
.1a5651	ea		nop		                NOP
.1a5652	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Save result back
.1a5656	85 23		sta $0823	                STA ARGUMENT1
.1a5658	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a565c	85 25		sta $0825	                STA ARGUMENT1+2
.1a565e	28		plp		                PLP
.1a565f	60		rts		            RTS

;******  Return to file: src\floats.s

.1a5660					FARG1EQ0
.1a5660	08		php		                PHP
.1a5661	c2 20		rep #$20	            REP #$20
.1a5663	a5 23		lda $0823	                LDA ARGUMENT1
.1a5665	d0 0a		bne $1a5671	                BNE return_false
.1a5667	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5669	29 ff 7f	and #$7fff	                AND #$7FFF              ; Mask off the sign bit
.1a566c	d0 03		bne $1a5671	                BNE return_false
.1a566e	28		plp		return_true     PLP
.1a566f	38		sec		                SEC
.1a5670	60		rts		            RTS
.1a5671	28		plp		return_false    PLP
.1a5672	18		clc		                CLC
.1a5673	60		rts		            RTS
.1a5674					SHIFTDEC
.1a5674	08		php		                PHP
.1a5675	e2 20		sep #$20	            SEP #$20
.1a5677	38		sec		                SEC                     ; Convert '0'..'9' to it's number
.1a5678	e9 30		sbc #$30	                SBC #'0'
.1a567a	20 65 04	jsr $1a0465	            JSR MULINT10
.1a567d	c2 20		rep #$20	            REP #$20
.1a567f	29 ff 00	and #$00ff	                AND #$00FF              ; Add the number to ARGUMENT1
.1a5682	18		clc		                CLC
.1a5683	65 23		adc $0823	                ADC ARGUMENT1
.1a5685	85 23		sta $0823	                STA ARGUMENT1
.1a5687	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5689	69 00 00	adc #$0000	                ADC #0
.1a568c	85 25		sta $0825	                STA ARGUMENT1+2
.1a568e	28		plp		                PLP
.1a568f	60		rts		            RTS
.1a5690					SHIFTHEX
.1a5690	08		php		                PHP
.1a5691	e2 20		sep #$20	            SEP #$20
.1a5693	c9 30		cmp #$30	                CMP #'0'                ; Process 0-9
.1a5695	90 04		bcc $1a569b	                BLT not_09
.1a5697	c9 3a		cmp #$3a	                CMP #'9'+1
.1a5699	90 1c		bcc $1a56b7	                BLT is_09
.1a569b	c9 61		cmp #$61	not_09          CMP #'a'                ; Process lowercase A-F
.1a569d	90 04		bcc $1a56a3	                BLT not_lc
.1a569f	c9 67		cmp #$67	                CMP #'f'+1
.1a56a1	90 0a		bcc $1a56ad	                BLT is_lc
.1a56a3	c9 41		cmp #$41	not_lc          CMP #'A'                ; Process uppercase A-F
.1a56a5	90 04		bcc $1a56ab	                BLT not_uc
.1a56a7	c9 47		cmp #$47	                CMP #'F'+1
.1a56a9	90 07		bcc $1a56b2	                BLT is_uc
.1a56ab	80 31		bra $1a56de	not_uc          BRA done                ; Just return if we couldn't convert... this shouldn't happen
.1a56ad	38		sec		is_lc           SEC                     ; Convert 'a'-'f' to the actual number
.1a56ae	e9 57		sbc #$57	                SBC #'a'-10
.1a56b0	80 08		bra $1a56ba	                BRA shift
.1a56b2	38		sec		is_uc           SEC                     ; Convert 'A'-'F' to the actual number
.1a56b3	e9 37		sbc #$37	                SBC #'A'-10
.1a56b5	80 03		bra $1a56ba	                BRA shift
.1a56b7	38		sec		is_09           SEC                     ; Convert '0'-'9' to the actual number
.1a56b8	e9 30		sbc #$30	                SBC #'0'
.1a56ba					shift
.1a56ba	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a56bc	26 24		rol $0824	                ROL ARGUMENT1+1
.1a56be	26 25		rol $0825	                ROL ARGUMENT1+2
.1a56c0	26 26		rol $0826	                ROL ARGUMENT1+3
.1a56c2	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a56c4	26 24		rol $0824	                ROL ARGUMENT1+1
.1a56c6	26 25		rol $0825	                ROL ARGUMENT1+2
.1a56c8	26 26		rol $0826	                ROL ARGUMENT1+3
.1a56ca	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a56cc	26 24		rol $0824	                ROL ARGUMENT1+1
.1a56ce	26 25		rol $0825	                ROL ARGUMENT1+2
.1a56d0	26 26		rol $0826	                ROL ARGUMENT1+3
.1a56d2	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a56d4	26 24		rol $0824	                ROL ARGUMENT1+1
.1a56d6	26 25		rol $0825	                ROL ARGUMENT1+2
.1a56d8	26 26		rol $0826	                ROL ARGUMENT1+3
.1a56da	05 23		ora $0823	                ORA ARGUMENT1           ; Add the number to it
.1a56dc	85 23		sta $0823	                STA ARGUMENT1
.1a56de	28		plp		done            PLP
.1a56df	60		rts		            RTS
.1a56e0					SHIFTBIN
.1a56e0	08		php		                PHP
.1a56e1	e2 20		sep #$20	            SEP #$20
.1a56e3	c9 30		cmp #$30	                CMP #'0'                ; If the character is '0'...
.1a56e5	f0 06		beq $1a56ed	                BEQ shift_0             ; Shift a 0 onto ARGUMENT1
.1a56e7	c9 31		cmp #$31	                CMP #'1'                ; If the character is '1'...
.1a56e9	f0 0a		beq $1a56f5	                BEQ shift_1             ; Shift a 1 onto ARGUMENT1
.1a56eb	80 0f		bra $1a56fc	                BRA done
.1a56ed					shift_0
.1a56ed	c2 20		rep #$20	            REP #$20
.1a56ef	06 23		asl $0823	                ASL ARGUMENT1
.1a56f1	26 25		rol $0825	                ROL ARGUMENT1+2
.1a56f3	80 07		bra $1a56fc	                BRA done
.1a56f5					shift_1
.1a56f5	c2 20		rep #$20	            REP #$20
.1a56f7	38		sec		                SEC
.1a56f8	26 23		rol $0823	                ROL ARGUMENT1
.1a56fa	26 25		rol $0825	                ROL ARGUMENT1+2
.1a56fc	28		plp		done            PLP
.1a56fd	60		rts		            RTS
.1a56fe					FP_POW10
.1a56fe	08		php		                PHP
.1a56ff	e2 30		sep #$30	            SEP #$30
.1a5701	a5 61		lda $0861	                LDA MARG4
.1a5703	f0 0d		beq $1a5712	                BEQ return_1
.1a5705	aa		tax		                TAX
.1a5706	a5 69		lda $0869	                LDA MARG6
.1a5708	d0 15		bne $1a571f	                BNE do_div
.1a570a	a9 00		lda #$00	                LDA #FP_OUT_MULT                    ; We'll multiply
.1a570c	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5710	80 15		bra $1a5727	                BRA start_loop
.1a5712					return_1
.1a5712	e2 20		sep #$20	            SEP #$20
.1a5714	a9 03		lda #$03	                LDA #FP_OUT_ONE                     ; We want to return a 1.0
.1a5716	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a571a	ea		nop		                NOP
.1a571b	ea		nop		                NOP
.1a571c	ea		nop		                NOP
.1a571d	80 62		bra $1a5781	                BRA ret_result                      ; And return the result
.1a571f					do_div
.1a571f	e2 20		sep #$20	            SEP #$20
.1a5721	a9 01		lda #$01	                LDA #FP_OUT_DIV                     ; We'll divide
.1a5723	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5727					start_loop
.1a5727	e2 20		sep #$20	            SEP #$20
.1a5729	a9 43		lda #$43	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.1a572b	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.1a572f	c2 20		rep #$20	            REP #$20
.1a5731	a9 00 10	lda #$1000	                LDA #$1000                          ; Input 0 = 1.0
.1a5734	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5738	a9 00 00	lda #$0000	                LDA #0
.1a573b	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a573f					loop
.1a573f	c2 20		rep #$20	            REP #$20
.1a5741	a9 00 a0	lda #$a000	                LDA #$A000                          ; Input 1 = 10.0
.1a5744	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5748	a9 00 00	lda #$0000	                LDA #0
.1a574b	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a574f	ea		nop		                NOP                                 ; Wait for the operation to complete
.1a5750	ea		nop		                NOP
.1a5751	ea		nop		                NOP
.1a5752	ca		dex		                DEX                                 ; Count down
.1a5753	f0 2c		beq $1a5781	                BEQ ret_result                      ; If 0, then we're done
.1a5755	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; SCRATCH <-- Result
.1a5759	8f 0c 08 00	sta $00080c	                STA @l SCRATCH
.1a575d	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5761	8f 0e 08 00	sta $00080e	                STA @l SCRATCH+2
.1a5765	e2 20		sep #$20	            SEP #$20
.1a5767	a9 42		lda #$42	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_1
.1a5769	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.1a576d	c2 20		rep #$20	            REP #$20
.1a576f	af 0c 08 00	lda $00080c	                LDA @l SCRATCH                      ; Input 0 <-- SCRATCH
.1a5773	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5777	af 0e 08 00	lda $00080e	                LDA @l SCRATCH+2
.1a577b	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a577f	80 be		bra $1a573f	                BRA loop
.1a5781					ret_result
.1a5781	c2 20		rep #$20	            REP #$20
.1a5783	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; Return the result
.1a5787	85 23		sta $0823	                STA ARGUMENT1
.1a5789	af 0a e2 af	lda $afe20a	                LDA FP_MATH_OUTPUT_FP_HL
.1a578d	85 25		sta $0825	                STA ARGUMENT1+2
.1a578f	e2 20		sep #$20	            SEP #$20
.1a5791	a9 01		lda #$01	                LDA #TYPE_FLOAT
.1a5793	85 27		sta $0827	                STA ARGTYPE1
.1a5795	28		plp		done            PLP
.1a5796	60		rts		            RTS
.1a5797					PACKFLOAT
.1a5797	08		php		                PHP
.1a5798	c2 20		rep #$20	            REP #$20
.1a579a	a5 5d		lda $085d	            LDA MARG3
.1a579c	85 23		sta $0823	            STA ARGUMENT1
.1a579e	a5 5f		lda $085f	            LDA MARG3+2
.1a57a0	85 25		sta $0825	            STA ARGUMENT1+2
.1a57a2	20 b0 59	jsr $1a59b0	            JSR ITOF
.1a57a5	c2 20		rep #$20	            REP #$20
.1a57a7	a5 23		lda $0823	            LDA ARGUMENT1
.1a57a9	85 29		sta $0829	            STA ARGUMENT2
.1a57ab	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a57ad	85 2b		sta $082b	            STA ARGUMENT2+2
.1a57af	c2 20		rep #$20	            REP #$20
.1a57b1	a5 59		lda $0859	            LDA MARG2
.1a57b3	85 23		sta $0823	            STA ARGUMENT1
.1a57b5	a5 5b		lda $085b	            LDA MARG2+2
.1a57b7	85 25		sta $0825	            STA ARGUMENT1+2
.1a57b9	20 d8 54	jsr $1a54d8	            JSR OP_FP_DIV
.1a57bc	c2 20		rep #$20	            REP #$20
.1a57be	a5 55		lda $0855	            LDA MARG1
.1a57c0	85 29		sta $0829	            STA ARGUMENT2
.1a57c2	a5 57		lda $0857	            LDA MARG1+2
.1a57c4	85 2b		sta $082b	            STA ARGUMENT2+2
.1a57c6	20 8d 54	jsr $1a548d	            JSR OP_FP_ADD
.1a57c9	c2 20		rep #$20	            REP #$20
.1a57cb	a5 23		lda $0823	            LDA ARGUMENT1
.1a57cd	85 29		sta $0829	            STA ARGUMENT2
.1a57cf	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a57d1	85 2b		sta $082b	            STA ARGUMENT2+2
.1a57d3	20 fe 56	jsr $1a56fe	            JSR FP_POW10
.1a57d6	20 23 55	jsr $1a5523	            JSR OP_FP_MUL
.1a57d9	c2 20		rep #$20	            REP #$20
.1a57db	a5 65		lda $0865	                LDA MARG5                       ; Check to see if the float should be negative
.1a57dd	f0 07		beq $1a57e6	                BEQ set_float_type              ; If not, just set the type
.1a57df	a5 25		lda $0825	                LDA ARGUMENT1+2                 ; If so, set the sign bit
.1a57e1	09 00 80	ora #$8000	                ORA #$8000
.1a57e4	85 25		sta $0825	                STA ARGUMENT1+2
.1a57e6					set_float_type
.1a57e6	e2 20		sep #$20	            SEP #$20
.1a57e8	a9 01		lda #$01	                LDA #TYPE_FLOAT                 ; Set the type to float... ready for returning!
.1a57ea	85 27		sta $0827	                STA ARGTYPE1
.1a57ec	28		plp		                PLP
.1a57ed	60		rts		            RTS
.1a57ee					PARSENUM
.1a57ee	5a		phy		                PHY
.1a57ef	08		php		                PHP
.1a57f0	c2 30		rep #$30	            REP #$30
.1a57f2	64 23		stz $0823	                STZ ARGUMENT1       ; This will be the accumulator for building the number
.1a57f4	64 25		stz $0825	                STZ ARGUMENT1+2
.1a57f6	64 55		stz $0855	                STZ MARG1           ; This will be the integer portion of the mantissa for floats
.1a57f8	64 57		stz $0857	                STZ MARG1+2
.1a57fa	64 65		stz $0865	                STZ MARG5           ; MARG5 will be the negative flag for the number
.1a57fc	64 59		stz $0859	                STZ MARG2           ; This will be the denominator of the fractional part of the mantissa
.1a57fe	64 5b		stz $085b	                STZ MARG2+2
.1a5800	a9 01 00	lda #$0001	                LDA #1
.1a5803	85 5d		sta $085d	                STA MARG3           ; This will be the divisor of the fractional part of the mantissa
.1a5805	64 5f		stz $085f	                STZ MARG3+2
.1a5807	64 61		stz $0861	                STZ MARG4           ; This will be the exponent of a float
.1a5809	64 63		stz $0863	                STZ MARG4+2
.1a580b	64 69		stz $0869	                STZ MARG6           ; MARG6 will be the negative flag for the exponent
.1a580d					s0
.1a580d	e2 20		sep #$20	            SEP #$20
.1a580f	a0 00 00	ldy #$0000	                LDY #0
.1a5812	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the first byte
.1a5814	c9 2b		cmp #$2b	                CMP #'+'
.1a5816	f0 33		beq $1a584b	                BEQ s1_drop         ; '+' --> S1, drop
.1a5818	c9 2d		cmp #$2d	                CMP #'-'
.1a581a	f0 2b		beq $1a5847	                BEQ s1_negative     ; Flag that the number is negative
.1a581c	c9 26		cmp #$26	                CMP #'&'
.1a581e	f0 3a		beq $1a585a	                BEQ s2_drop         ; '&' --> S2, drop
.1a5820	20 e6 03	jsr $1a03e6	            JSR ISNUMERAL
.1a5823	90 03		bcc $1a5828	                BCC syntax_err
.1a5825	82 ac 00	brl $1a58d4	                BRL s7_shift        ; '0'-'9' --> S7, emit
.1a5828					syntax_err
.1a5828	08		php		            PHP
.1a5829	c2 20		rep #$20	            REP #$20
.1a582b	48		pha		            PHA
.1a582c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a582f	5b		tcd		            TCD
.1a5830	68		pla		            PLA
.1a5831	28		plp		            PLP
.1a5832	e2 20		sep #$20	            SEP #$20
.1a5834	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a5836	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a583a	c2 20		rep #$20	            REP #$20
.1a583c	29 ff 00	and #$00ff	            AND #$00FF
.1a583f	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a5842	e2 20		sep #$20	            SEP #$20
.1a5844	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5847	a9 01		lda #$01	s1_negative     LDA #1              ; Set the negative flag for the mantissa
.1a5849	85 65		sta $0865	                STA MARG5
.1a584b	c8		iny		s1_drop         INY                 ; Drop the character...
.1a584c	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next
.1a584e	c9 26		cmp #$26	                CMP #'&'
.1a5850	f0 08		beq $1a585a	                BEQ s2_drop         ; '&' --> S2, drop the '&'
.1a5852	20 e6 03	jsr $1a03e6	            JSR ISNUMERAL
.1a5855	90 d1		bcc $1a5828	                BCC syntax_err
.1a5857	82 7a 00	brl $1a58d4	                BRL s7_shift        ; '0'-'9' --> S7, shift
.1a585a	c8		iny		s2_drop         INY                 ; Drop the character
.1a585b	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.1a585d	c9 68		cmp #$68	                CMP #'h'
.1a585f	f0 0e		beq $1a586f	                BEQ s3_drop         ; 'h', 'H' --> S3, drop
.1a5861	c9 48		cmp #$48	                CMP #'H'
.1a5863	f0 0a		beq $1a586f	                BEQ s3_drop
.1a5865	c9 62		cmp #$62	                CMP #'b'
.1a5867	f0 4c		beq $1a58b5	                BEQ s5_drop         ; 'b', 'B' --> S5, drop
.1a5869	c9 42		cmp #$42	                CMP #'B'
.1a586b	f0 48		beq $1a58b5	                BEQ s5_drop
.1a586d	80 b9		bra $1a5828	                BRA syntax_err
.1a586f	c8		iny		s3_drop         INY                 ; Drop the character
.1a5870	b7 00		lda [$0800],y	s3              LDA [BIP],Y         ; Get the next character
.1a5872	20 f7 03	jsr $1a03f7	            JSR ISHEX
.1a5875	b0 02		bcs $1a5879	                BCS s4_shift
.1a5877	80 af		bra $1a5828	                BRA syntax_err
.1a5879					s4_shift
.1a5879	20 90 56	jsr $1a5690	            JSR SHIFTHEX
.1a587c	c8		iny		                INY
.1a587d	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.1a587f	20 f7 03	jsr $1a03f7	            JSR ISHEX
.1a5882	b0 f5		bcs $1a5879	                BCS s4_shift        ; '0'-'9','A'-'F' --> S4, shift
.1a5884					ret_integer
.1a5884	e2 20		sep #$20	            SEP #$20
.1a5886	a5 65		lda $0865	                LDA MARG5           ; check if the number should be negative
.1a5888	f0 11		beq $1a589b	                BEQ set_int_type    ; If not, just set the type and return
.1a588a	c2 20		rep #$20	            REP #$20
.1a588c	38		sec		                SEC                 ; If so, negate it
.1a588d	a9 00 00	lda #$0000	                LDA #0
.1a5890	e5 23		sbc $0823	                SBC ARGUMENT1
.1a5892	85 23		sta $0823	                STA ARGUMENT1
.1a5894	a9 00 00	lda #$0000	                LDA #0
.1a5897	e5 25		sbc $0825	                SBC ARGUMENT1+2
.1a5899	85 25		sta $0825	                STA ARGUMENT1+2
.1a589b					set_int_type
.1a589b	e2 20		sep #$20	            SEP #$20
.1a589d	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; Return an integer
.1a589f	85 27		sta $0827	                STA ARGTYPE1
.1a58a1					stop
.1a58a1	c2 20		rep #$20	            REP #$20
.1a58a3	18		clc		                CLC
.1a58a4	98		tya		                TYA
.1a58a5	65 00		adc $0800	                ADC BIP
.1a58a7	85 00		sta $0800	                STA BIP
.1a58a9	a5 02		lda $0802	                LDA BIP+2
.1a58ab	69 00 00	adc #$0000	                ADC #0
.1a58ae	85 02		sta $0802	                STA BIP+2
.1a58b0	e2 20		sep #$20	            SEP #$20
.1a58b2	28		plp		                PLP
.1a58b3	7a		ply		                PLY
.1a58b4	60		rts		            RTS
.1a58b5	c8		iny		s5_drop         INY                     ; Drop the character
.1a58b6	b7 00		lda [$0800],y	s5              LDA [BIP],Y             ; Get the next character
.1a58b8	c9 30		cmp #$30	                CMP #'0'
.1a58ba	f0 07		beq $1a58c3	                BEQ s6_shift            ; '0', '1' --> S6, shift
.1a58bc	c9 31		cmp #$31	                CMP #'1'
.1a58be	f0 03		beq $1a58c3	                BEQ s6_shift
.1a58c0	82 65 ff	brl $1a5828	                BRL syntax_err
.1a58c3					s6_shift
.1a58c3	20 e0 56	jsr $1a56e0	            JSR SHIFTBIN
.1a58c6	c8		iny		                INY
.1a58c7	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a58c9	c9 30		cmp #$30	                CMP #'0'                ; '0', '1' --> S6, shift
.1a58cb	f0 f6		beq $1a58c3	                BEQ s6_shift
.1a58cd	c9 31		cmp #$31	                CMP #'1'
.1a58cf	f0 f2		beq $1a58c3	                BEQ s6_shift
.1a58d1	82 b0 ff	brl $1a5884	                BRL ret_integer         ; Return integer
.1a58d4					s7_shift
.1a58d4	20 74 56	jsr $1a5674	            JSR SHIFTDEC
.1a58d7	c8		iny		                INY
.1a58d8	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a58da	c9 2e		cmp #$2e	                CMP #'.'                ; '.' --> S8, drop and preserve mantissa
.1a58dc	f0 08		beq $1a58e6	                BEQ s8_mantissa
.1a58de	20 e6 03	jsr $1a03e6	            JSR ISNUMERAL
.1a58e1	b0 f1		bcs $1a58d4	                BCS s7_shift
.1a58e3	82 9e ff	brl $1a5884	                BRL ret_integer         ; Return integer
.1a58e6					s8_mantissa
.1a58e6	c2 20		rep #$20	            REP #$20
.1a58e8	20 b0 59	jsr $1a59b0	            JSR ITOF
.1a58eb	c2 20		rep #$20	            REP #$20
.1a58ed	a5 23		lda $0823	            LDA ARGUMENT1
.1a58ef	85 55		sta $0855	            STA MARG1
.1a58f1	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a58f3	85 57		sta $0857	            STA MARG1+2
.1a58f5	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the decimal
.1a58f7	64 25		stz $0825	                STZ ARGUMENT1+2
.1a58f9	e2 20		sep #$20	            SEP #$20
.1a58fb	80 36		bra $1a5933	                BRA s8_drop
.1a58fd					s8_shift
.1a58fd	20 74 56	jsr $1a5674	            JSR SHIFTDEC
.1a5900	c2 20		rep #$20	            REP #$20
.1a5902	a5 5f		lda $085f	                LDA MARG3+2             ; high 16 bits
.1a5904	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.1a5908	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.1a590b	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.1a590f	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to high 16 bits of MARG3
.1a5913	85 5f		sta $085f	                STA MARG3+2
.1a5915	a5 5d		lda $085d	                LDA MARG3
.1a5917	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.1a591b	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.1a591e	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.1a5922	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to MARG3
.1a5926	85 5d		sta $085d	                STA MARG3
.1a5928	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.1a592c	18		clc		                CLC
.1a592d	65 5f		adc $085f	                ADC MARG3+2
.1a592f	85 5f		sta $085f	                STA MARG3+2
.1a5931	e2 20		sep #$20	            SEP #$20
.1a5933					s8_drop
.1a5933	c8		iny		                INY
.1a5934	b7 00		lda [$0800],y	                LDA [BIP],Y
.1a5936	c9 65		cmp #$65	                CMP #'e'                ; 'E' --> S9, drop
.1a5938	f0 24		beq $1a595e	                BEQ s9_drop
.1a593a	c9 45		cmp #$45	                CMP #'E'
.1a593c	f0 20		beq $1a595e	                BEQ s9_drop
.1a593e	20 e6 03	jsr $1a03e6	            JSR ISNUMERAL
.1a5941	b0 ba		bcs $1a58fd	                BCS s8_shift
.1a5943	c2 20		rep #$20	            REP #$20
.1a5945	20 b0 59	jsr $1a59b0	            JSR ITOF
.1a5948	c2 20		rep #$20	            REP #$20
.1a594a	a5 23		lda $0823	            LDA ARGUMENT1
.1a594c	85 59		sta $0859	            STA MARG2
.1a594e	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5950	85 5b		sta $085b	            STA MARG2+2
.1a5952	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.1a5954	64 25		stz $0825	                STZ ARGUMENT1+2
.1a5956	20 97 57	jsr $1a5797	            JSR PACKFLOAT
.1a5959	e2 20		sep #$20	            SEP #$20
.1a595b	82 43 ff	brl $1a58a1	                BRL stop
.1a595e					s9_drop
.1a595e	c2 20		rep #$20	            REP #$20
.1a5960	20 b0 59	jsr $1a59b0	            JSR ITOF
.1a5963	c2 20		rep #$20	            REP #$20
.1a5965	a5 23		lda $0823	            LDA ARGUMENT1
.1a5967	85 59		sta $0859	            STA MARG2
.1a5969	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a596b	85 5b		sta $085b	            STA MARG2+2
.1a596d	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.1a596f	64 25		stz $0825	                STZ ARGUMENT1+2
.1a5971	e2 20		sep #$20	            SEP #$20
.1a5973	c8		iny		                INY
.1a5974	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5976	c9 2b		cmp #$2b	                CMP #'+'
.1a5978	f0 10		beq $1a598a	                BEQ s10_drop            ; '+' --> S10, drop
.1a597a	c9 2d		cmp #$2d	                CMP #'-'
.1a597c	f0 08		beq $1a5986	                BEQ s10_setneg          ; '-' --> S10, set exponent is negative
.1a597e	20 e6 03	jsr $1a03e6	            JSR ISNUMERAL
.1a5981	b0 12		bcs $1a5995	                BCS S11_shift           ; '0'-'9' --> S11, shift
.1a5983	82 a2 fe	brl $1a5828	                BRL syntax_err
.1a5986					s10_setneg
.1a5986	a9 01		lda #$01	                LDA #1                  ; Set that the exponent should be negative
.1a5988	85 69		sta $0869	                STA MARG6
.1a598a					s10_drop
.1a598a	c8		iny		                INY
.1a598b	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a598d	20 e6 03	jsr $1a03e6	            JSR ISNUMERAL
.1a5990	b0 03		bcs $1a5995	                BCS s11_shift
.1a5992	82 93 fe	brl $1a5828	                BRL syntax_err
.1a5995					s11_shift
.1a5995	20 74 56	jsr $1a5674	            JSR SHIFTDEC
.1a5998	c8		iny		                INY
.1a5999	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a599b	20 e6 03	jsr $1a03e6	            JSR ISNUMERAL
.1a599e	b0 f5		bcs $1a5995	                BCS s11_shift
.1a59a0	c2 20		rep #$20	            REP #$20
.1a59a2	a5 23		lda $0823	            LDA ARGUMENT1
.1a59a4	85 61		sta $0861	            STA MARG4
.1a59a6	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a59a8	85 63		sta $0863	            STA MARG4+2
.1a59aa	20 97 57	jsr $1a5797	            JSR PACKFLOAT
.1a59ad	82 f1 fe	brl $1a58a1	                BRL stop
.1a59b0					ITOF
.1a59b0	08		php		                PHP
.1a59b1	20 3e 54	jsr $1a543e	            JSR FIXINT_TO_FP
.1a59b4	28		plp		done            PLP
.1a59b5	60		rts		            RTS
.1a59b6					FTOI
.1a59b6	08		php		                PHP
.1a59b7					LOCALS
>0001					l_sign          .byte ?
>0002					l_exponent      .byte ?
>0003					l_mantissa      .dword ?
.1a59b7	c2 20		rep #$20	            REP #$20
.1a59b9	a9 ad 5c	lda #$5cad	                LDA #<>FP_1_0
.1a59bc	85 29		sta $0829	                STA ARGUMENT2
.1a59be	a9 1a 00	lda #$001a	                LDA #(FP_1_0 >> 16)
.1a59c1	85 2b		sta $082b	                STA ARGUMENT2+2
.1a59c3	e2 20		sep #$20	            SEP #$20
.1a59c5	a9 01		lda #$01	                LDA #TYPE_FLOAT
.1a59c7	85 2d		sta $082d	                STA ARGTYPE2
.1a59c9	c2 20		rep #$20	            REP #$20
.1a59cb	20 89 5a	jsr $1a5a89	            JSR FP_COMPARE
.1a59ce	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a59d1	d0 0c		bne $1a59df	                BNE alloc_locals        ; No: get ready to do the full conversion
.1a59d3	a9 00 00	lda #$0000	                LDA #0
.1a59d6	8d 23 08	sta $0823	                STA @w ARGUMENT1        ; Yes: Return 0
.1a59d9	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.1a59dc	82 a1 00	brl $1a5a80	                BRL done
.1a59df	f4 00 00	pea #$0000	alloc_locals    PEA #0                  ; Reserve space for the locals
.1a59e2	f4 00 00	pea #$0000	                PEA #0
.1a59e5	f4 00 00	pea #$0000	                PEA #0
.1a59e8	e2 20		sep #$20	            SEP #$20
.1a59ea	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3      ; Preserve the sign bit
.1a59ed	29 80		and #$80	                AND #$80
.1a59ef	83 01		sta $01,s	                STA l_sign
.1a59f1	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2      ; Preserve the exponent
.1a59f4	2a		rol a		                ROL A
.1a59f5	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3
.1a59f8	2a		rol a		                ROL A
.1a59f9	83 02		sta $02,s	                STA l_exponent
.1a59fb	a9 00		lda #$00	save_mantissa   LDA #0                  ; Save the mantissa (with the implied 1)
.1a59fd	83 06		sta $06,s	                STA l_mantissa+3
.1a59ff	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2
.1a5a02	09 80		ora #$80	                ORA #$80
.1a5a04	83 05		sta $05,s	                STA l_mantissa+2
.1a5a06	ad 24 08	lda $0824	                LDA @w ARGUMENT1+1
.1a5a09	83 04		sta $04,s	                STA l_mantissa+1
.1a5a0b	ad 23 08	lda $0823	                LDA @w ARGUMENT1
.1a5a0e	83 03		sta $03,s	                STA l_mantissa
.1a5a10	a3 02		lda $02,s	                LDA l_exponent
.1a5a12	c9 96		cmp #$96	loop            CMP #150
.1a5a14	f0 3a		beq $1a5a50	                BEQ adj_sign
.1a5a16	90 1f		bcc $1a5a37	                BLT shift_right
.1a5a18	08		php		            PHP
.1a5a19	c2 20		rep #$20	            REP #$20
.1a5a1b	48		pha		            PHA
.1a5a1c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5a1f	5b		tcd		            TCD
.1a5a20	68		pla		            PLA
.1a5a21	28		plp		            PLP
.1a5a22	e2 20		sep #$20	            SEP #$20
.1a5a24	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.1a5a26	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5a2a	c2 20		rep #$20	            REP #$20
.1a5a2c	29 ff 00	and #$00ff	            AND #$00FF
.1a5a2f	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a5a32	e2 20		sep #$20	            SEP #$20
.1a5a34	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5a37					shift_right
.1a5a37	c2 20		rep #$20	            REP #$20
.1a5a39	a3 05		lda $05,s	                LDA l_mantissa+2
.1a5a3b	4a		lsr a		                LSR A
.1a5a3c	83 05		sta $05,s	                STA l_mantissa+2
.1a5a3e	a3 03		lda $03,s	                LDA l_mantissa
.1a5a40	6a		ror a		                ROR A
.1a5a41	83 03		sta $03,s	                STA l_mantissa
.1a5a43	e2 20		sep #$20	            SEP #$20
.1a5a45	a3 02		lda $02,s	                LDA l_exponent
.1a5a47	1a		inc a		                INC A
.1a5a48	83 02		sta $02,s	                STA l_exponent
.1a5a4a	c9 96		cmp #$96	                CMP #150
.1a5a4c	f0 02		beq $1a5a50	                BEQ adj_sign
.1a5a4e	80 e7		bra $1a5a37	                BRA shift_right
.1a5a50	a3 01		lda $01,s	adj_sign        LDA l_sign
.1a5a52	f0 1b		beq $1a5a6f	                BEQ ret_positive
.1a5a54	c2 20		rep #$20	            REP #$20
.1a5a56	a3 03		lda $03,s	                LDA l_mantissa
.1a5a58	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a5a5b	18		clc		                CLC
.1a5a5c	69 01 00	adc #$0001	                ADC #1
.1a5a5f	8d 23 08	sta $0823	                STA @w ARGUMENT1
.1a5a62	a3 05		lda $05,s	                LDA l_mantissa+2
.1a5a64	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a5a67	69 00 00	adc #$0000	                ADC #0
.1a5a6a	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.1a5a6d	80 0c		bra $1a5a7b	                BRA clean
.1a5a6f					ret_positive
.1a5a6f	c2 20		rep #$20	            REP #$20
.1a5a71	a3 03		lda $03,s	                LDA l_mantissa
.1a5a73	8d 23 08	sta $0823	                STA @w ARGUMENT1
.1a5a76	a3 05		lda $05,s	                LDA l_mantissa+2
.1a5a78	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.1a5a7b					clean
.1a5a7b	c2 20		rep #$20	            REP #$20
.1a5a7d	68		pla		                PLA                     ; Clean up the locals
.1a5a7e	68		pla		                PLA
.1a5a7f	68		pla		                PLA
.1a5a80					done
.1a5a80	e2 20		sep #$20	            SEP #$20
.1a5a82	a9 00		lda #$00	                LDA #TYPE_INTEGER       ; Set the return type to integer
.1a5a84	8d 27 08	sta $0827	                STA @w ARGTYPE1
.1a5a87	28		plp		                PLP
.1a5a88	60		rts		            RTS
.1a5a89					FP_COMPARE
.1a5a89	da		phx		                PHX
.1a5a8a	08		php		                PHP
.1a5a8b	c2 20		rep #$20	            REP #$20
.1a5a8d	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save ARGUMENT1 so we don't destroy it
.1a5a8f	48		pha		                PHA
.1a5a90	a5 23		lda $0823	                LDA ARGUMENT1
.1a5a92	48		pha		                PHA
.1a5a93	20 82 54	jsr $1a5482	            JSR OP_FP_SUB
.1a5a96	20 60 56	jsr $1a5660	            JSR FARG1EQ0
.1a5a99	b0 11		bcs $1a5aac	                BCS are_equal
.1a5a9b	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Check the high word
.1a5a9d	89 00 80	bit #$8000	                BIT #$8000
.1a5aa0	d0 05		bne $1a5aa7	                BNE is_lt                   ; ARGUMENT1 < ARGUMENT2
.1a5aa2	a9 01 00	lda #$0001	is_gt           LDA #1                      ; ARGUMENT1 > ARGUMENT2: return 1
.1a5aa5	80 08		bra $1a5aaf	                BRA ret_result
.1a5aa7	a9 ff ff	lda #$ffff	is_lt           LDA #$FFFF                  ; ARGUMENT1 > ARGUMENT2: return -1
.1a5aaa	80 03		bra $1a5aaf	                BRA ret_result
.1a5aac	a9 00 00	lda #$0000	are_equal       LDA #0                      ; Equal: return 0
.1a5aaf	fa		plx		ret_result      PLX                         ; Restore ARGUMENT1
.1a5ab0	86 23		stx $0823	                STX ARGUMENT1
.1a5ab2	fa		plx		                PLX
.1a5ab3	86 25		stx $0825	                STX ARGUMENT1+2
.1a5ab5	28		plp		                PLP
.1a5ab6	fa		plx		                PLX
.1a5ab7	60		rts		            RTS
.1a5ab8					OP_FP_LT
.1a5ab8	08		php		                PHP
.1a5ab9	c2 30		rep #$30	            REP #$30
.1a5abb	20 89 5a	jsr $1a5a89	            JSR FP_COMPARE
.1a5abe	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a5ac1	d0 05		bne $1a5ac8	                BNE ret_false
.1a5ac3	20 18 05	jsr $1a0518	            JSR SET_TRUE
.1a5ac6	80 03		bra $1a5acb	                BRA done
.1a5ac8					ret_false
.1a5ac8	20 2a 05	jsr $1a052a	            JSR SET_FALSE
.1a5acb	28		plp		done            PLP
.1a5acc	60		rts		            RTS
.1a5acd					OP_FP_GT
.1a5acd	08		php		                PHP
.1a5ace	c2 30		rep #$30	            REP #$30
.1a5ad0	20 89 5a	jsr $1a5a89	            JSR FP_COMPARE
.1a5ad3	c9 01 00	cmp #$0001	                CMP #1
.1a5ad6	d0 05		bne $1a5add	                BNE ret_false
.1a5ad8	20 18 05	jsr $1a0518	            JSR SET_TRUE
.1a5adb	80 03		bra $1a5ae0	                BRA done
.1a5add					ret_false
.1a5add	20 2a 05	jsr $1a052a	            JSR SET_FALSE
.1a5ae0	28		plp		done            PLP
.1a5ae1	60		rts		            RTS
.1a5ae2					OP_FP_EQ
.1a5ae2	08		php		                PHP
.1a5ae3	c2 30		rep #$30	            REP #$30
.1a5ae5	20 89 5a	jsr $1a5a89	            JSR FP_COMPARE
.1a5ae8	c9 00 00	cmp #$0000	                CMP #0
.1a5aeb	d0 05		bne $1a5af2	                BNE ret_false
.1a5aed	20 18 05	jsr $1a0518	            JSR SET_TRUE
.1a5af0	80 03		bra $1a5af5	                BRA done
.1a5af2					ret_false
.1a5af2	20 2a 05	jsr $1a052a	            JSR SET_FALSE
.1a5af5	28		plp		done            PLP
.1a5af6	60		rts		            RTS
.1a5af7					OP_FP_LTE
.1a5af7	08		php		                PHP
.1a5af8	c2 30		rep #$30	            REP #$30
.1a5afa	20 89 5a	jsr $1a5a89	            JSR FP_COMPARE
.1a5afd	c9 01 00	cmp #$0001	                CMP #1
.1a5b00	f0 05		beq $1a5b07	                BEQ ret_false
.1a5b02	20 18 05	jsr $1a0518	            JSR SET_TRUE
.1a5b05	80 03		bra $1a5b0a	                BRA done
.1a5b07					ret_false
.1a5b07	20 2a 05	jsr $1a052a	            JSR SET_FALSE
.1a5b0a	28		plp		done            PLP
.1a5b0b	60		rts		            RTS
.1a5b0c					OP_FP_GTE
.1a5b0c	08		php		                PHP
.1a5b0d	c2 30		rep #$30	            REP #$30
.1a5b0f	20 89 5a	jsr $1a5a89	            JSR FP_COMPARE
.1a5b12	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a5b15	f0 05		beq $1a5b1c	                BEQ ret_false
.1a5b17	20 18 05	jsr $1a0518	            JSR SET_TRUE
.1a5b1a	80 03		bra $1a5b1f	                BRA done
.1a5b1c					ret_false
.1a5b1c	20 2a 05	jsr $1a052a	            JSR SET_FALSE
.1a5b1f	28		plp		done            PLP
.1a5b20	60		rts		            RTS
.1a5b21					OP_FP_NE
.1a5b21	08		php		                PHP
.1a5b22	c2 30		rep #$30	            REP #$30
.1a5b24	20 89 5a	jsr $1a5a89	            JSR FP_COMPARE
.1a5b27	c9 00 00	cmp #$0000	                CMP #0
.1a5b2a	f0 05		beq $1a5b31	                BEQ ret_false
.1a5b2c	20 18 05	jsr $1a0518	            JSR SET_TRUE
.1a5b2f	80 03		bra $1a5b34	                BRA done
.1a5b31					ret_false
.1a5b31	20 2a 05	jsr $1a052a	            JSR SET_FALSE
.1a5b34	28		plp		done            PLP
.1a5b35	60		rts		            RTS
.1a5b36					STREMIT
.1a5b36	08		php		                PHP
.1a5b37	e2 20		sep #$20	            SEP #$20
.1a5b39	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Append the character
.1a5b3b	c8		iny		                INY                         ; Advance the character pointer in Y
.1a5b3c	a9 00		lda #$00	                LDA #0                      ; And add the NULL
.1a5b3e	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.1a5b40	28		plp		                PLP
.1a5b41	60		rts		            RTS
.1a5b42					STREMITB
.1a5b42	da		phx		                PHX
.1a5b43	08		php		                PHP
.1a5b44	e2 20		sep #$20	            SEP #$20
.1a5b46	c9 80		cmp #$80	                CMP #$80
.1a5b48	90 0a		bcc $1a5b54	                BLT emit_digits
.1a5b4a	48		pha		                PHA
.1a5b4b	a9 2d		lda #$2d	                LDA #'-'                    ; Print a minus sign
.1a5b4d	20 36 5b	jsr $1a5b36	            JSR STREMIT
.1a5b50	68		pla		                PLA
.1a5b51	49 ff		eor #$ff	                EOR #$FF                    ; And negate it
.1a5b53	1a		inc a		                INC A
.1a5b54					emit_digits
.1a5b54	c2 30		rep #$30	            REP #$30
.1a5b56	29 ff 00	and #$00ff	                AND #$00FF
.1a5b59	c9 64 00	cmp #$0064	                CMP #100
.1a5b5c	90 0e		bcc $1a5b6c	                BLT chk_tens
.1a5b5e	a2 64 00	ldx #$0064	                LDX #100
.1a5b61	20 27 54	jsr $1a5427	            JSR UINT_DIV_A_X
.1a5b64	18		clc		                CLC
.1a5b65	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.1a5b68	20 36 5b	jsr $1a5b36	            JSR STREMIT
.1a5b6b	8a		txa		                TXA                         ; Put the remainder in A
.1a5b6c					chk_tens
.1a5b6c	a2 0a 00	ldx #$000a	                LDX #10
.1a5b6f	20 27 54	jsr $1a5427	            JSR UINT_DIV_A_X
.1a5b72	18		clc		                CLC
.1a5b73	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.1a5b76	20 36 5b	jsr $1a5b36	            JSR STREMIT
.1a5b79	8a		txa		                TXA                         ; Put the remainder in A
.1a5b7a					ones_digit
.1a5b7a	18		clc		                CLC
.1a5b7b	69 30 00	adc #$0030	                ADC #'0'                    ; Convert it to ASCII
.1a5b7e	20 36 5b	jsr $1a5b36	            JSR STREMIT
.1a5b81	28		plp		                PLP
.1a5b82	fa		plx		                PLX
.1a5b83	60		rts		            RTS
.1a5b84					STRFINDEND
.1a5b84	08		php		                PHP
.1a5b85	e2 20		sep #$20	            SEP #$20
.1a5b87	c2 10		rep #$10	            REP #$10
.1a5b89	a0 00 00	ldy #$0000	                LDY #0
.1a5b8c	b7 23		lda [$0823],y	find_end        LDA [ARGUMENT1],Y           ; Scan to the end of the string
.1a5b8e	f0 03		beq $1a5b93	                BEQ done
.1a5b90	c8		iny		                INY
.1a5b91	80 f9		bra $1a5b8c	                BRA find_end
.1a5b93	28		plp		done            PLP
.1a5b94	60		rts		            RTS
=6					FP_D = 6        ; Number of mantissa digits
.1a5b95					FTOS
.1a5b95	08		php		                PHP
.1a5b96	e2 20		sep #$20	            SEP #$20
.1a5b98	c2 10		rep #$10	            REP #$10
.1a5b9a	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be the negative flag
.1a5b9d	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be K
.1a5ba0	f4 00 00	pea #$0000	                PEA #0                      ; This spot will be for the exponents
>0001					L_NEGATIVE      .word ?
>0003					L_K             .word ?
>0005					L_X1            .byte ?                     ; The binary exponent
>0006					L_EXP           .byte ?                     ; The decimal exponent
.1a5ba3	20 60 56	jsr $1a5660	            JSR FARG1EQ0
.1a5ba6	90 19		bcc $1a5bc1	                BCC chk_negative
.1a5ba8	20 e7 13	jsr $1a13e7	            JSR TEMPSTRING
.1a5bab	e2 20		sep #$20	            SEP #$20
.1a5bad	a0 00 00	ldy #$0000	                LDY #0
.1a5bb0	a9 20		lda #$20	                LDA #' '
.1a5bb2	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a5bb4	c8		iny		                INY
.1a5bb5	a9 30		lda #$30	                LDA #'0'                    ; Return a "0"
.1a5bb7	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a5bb9	c8		iny		                INY
.1a5bba	a9 00		lda #$00	                LDA #0
.1a5bbc	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a5bbe	82 ce 00	brl $1a5c8f	                BRL ret_result
.1a5bc1					chk_negative
.1a5bc1	e2 20		sep #$20	            SEP #$20
.1a5bc3	a5 26		lda $0826	                LDA ARGUMENT1+3             ; If N is negative, output a minus sign and negate N
.1a5bc5	10 08		bpl $1a5bcf	                BPL not_negative
.1a5bc7	29 7f		and #$7f	                AND #$7F                    ; Negate the number
.1a5bc9	85 26		sta $0826	                STA ARGUMENT1+3
.1a5bcb	a9 01		lda #$01	                LDA #1
.1a5bcd	83 01		sta $01,s	                STA L_NEGATIVE              ; Set IsNegative to a TRUE value
.1a5bcf					not_negative
.1a5bcf	c2 20		rep #$20	            REP #$20
.1a5bd1	a9 00 00	lda #$0000	                LDA #0                      ; Initialize K to 0, K is a 1-byte signed integer. (SCRATCH is K)
.1a5bd4	83 03		sta $03,s	                STA L_K                     ; We're using a word here for convenience
.1a5bd6	c2 20		rep #$20	            REP #$20
.1a5bd8	af a9 5c 1a	lda $1a5ca9	            LDA ten_d_1
.1a5bdc	85 29		sta $0829	            STA ARGUMENT2
.1a5bde	af ab 5c 1a	lda $1a5cab	            LDA ten_d_1+2
.1a5be2	85 2b		sta $082b	            STA ARGUMENT2+2
.1a5be4	20 89 5a	jsr $1a5a89	            JSR FP_COMPARE
.1a5be7	89 00 80	bit #$8000	                BIT #$8000                  ; Is N < 10^(D-1)?
.1a5bea	d0 12		bne $1a5bfe	                BNE shift_up
.1a5bec					shift_down
.1a5bec	20 24 56	jsr $1a5624	            JSR FP_DIV10
.1a5bef	a3 03		lda $03,s	                LDA L_K
.1a5bf1	1a		inc a		                INC A
.1a5bf2	83 03		sta $03,s	                STA L_K                     ; Increment K
.1a5bf4	20 89 5a	jsr $1a5a89	            JSR FP_COMPARE
.1a5bf7	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N < 10^(D-1)?
.1a5bfa	f0 12		beq $1a5c0e	                BEQ do_digits               ; Yes: we're ready to process digits
.1a5bfc	80 ee		bra $1a5bec	                BRA shift_down              ; No: keep dividing
.1a5bfe					shift_up
.1a5bfe	20 db 55	jsr $1a55db	            JSR FP_MUL10
.1a5c01	a3 03		lda $03,s	                LDA L_K
.1a5c03	3a		dec a		                DEC A
.1a5c04	83 03		sta $03,s	                STA L_K                     ; Decrement K
.1a5c06	20 89 5a	jsr $1a5a89	            JSR FP_COMPARE
.1a5c09	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N >= 10 ^ (D-1)?
.1a5c0c	f0 f0		beq $1a5bfe	                BEQ shift_up                ; No: keep multiplying
.1a5c0e					do_digits
.1a5c0e	e2 30		sep #$30	            SEP #$30
.1a5c10	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5c12	0a		asl a		                ASL A
.1a5c13	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a5c15	2a		rol a		                ROL A
.1a5c16	83 05		sta $05,s	                STA L_X1
.1a5c18	38		sec		                SEC
.1a5c19	a9 96		lda #$96	                LDA #150                    ; X := 150 - X1
.1a5c1b	e3 05		sbc $05,s	                SBC L_X1
.1a5c1d	aa		tax		                TAX
.1a5c1e	f0 0f		beq $1a5c2f	                BEQ emit_digits             ; If X = 0, just emit the digits
.1a5c20	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Set the implied '1' MSB of the mantissa
.1a5c22	09 80		ora #$80	                ORA #$80
.1a5c24	85 25		sta $0825	                STA ARGUMENT1+2
.1a5c26	46 25		lsr $0825	shift_r         LSR ARGUMENT1+2             ; Shift the mantissa right
.1a5c28	66 24		ror $0824	                ROR ARGUMENT1+1
.1a5c2a	66 23		ror $0823	                ROR ARGUMENT1
.1a5c2c	ca		dex		                DEX
.1a5c2d	d0 f7		bne $1a5c26	                BNE shift_r                 ; Until X = 0
.1a5c2f					emit_digits
.1a5c2f	c2 10		rep #$10	            REP #$10
.1a5c31	e2 20		sep #$20	            SEP #$20
.1a5c33	64 26		stz $0826	                STZ ARGUMENT1+3             ; Blank out the MSB
.1a5c35	a9 00		lda #$00	                LDA #TYPE_INTEGER           ; Make it an integer
.1a5c37	85 27		sta $0827	                STA ARGTYPE1
.1a5c39	a3 01		lda $01,s	                LDA L_NEGATIVE              ; Check IsNegative
.1a5c3b	f0 11		beq $1a5c4e	                BEQ get_raw_digits          ; If FALSE, just convert the raw digits
.1a5c3d	c2 20		rep #$20	            REP #$20
.1a5c3f	38		sec		                SEC                         ; Make the raw integer negative
.1a5c40	a9 00 00	lda #$0000	                LDA #0
.1a5c43	e5 23		sbc $0823	                SBC ARGUMENT1
.1a5c45	85 23		sta $0823	                STA ARGUMENT1
.1a5c47	a9 00 00	lda #$0000	                LDA #0
.1a5c4a	e5 25		sbc $0825	                SBC ARGUMENT1+2
.1a5c4c	85 25		sta $0825	                STA ARGUMENT1+2
.1a5c4e					get_raw_digits
.1a5c4e	20 46 14	jsr $1a1446	            JSR ITOS
.1a5c51	c2 20		rep #$20	            REP #$20
.1a5c53	a5 16		lda $0816	            LDA STRPTR
.1a5c55	85 23		sta $0823	            STA ARGUMENT1
.1a5c57	a5 18		lda $0818	            LDA STRPTR+2
.1a5c59	85 25		sta $0825	            STA ARGUMENT1+2
.1a5c5b	20 84 5b	jsr $1a5b84	            JSR STRFINDEND
.1a5c5e	e2 20		sep #$20	            SEP #$20
.1a5c60	c8		iny		                INY                         ; Move the NULL up one byte
.1a5c61	a9 00		lda #$00	                LDA #0
.1a5c63	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.1a5c65	88		dey		insert_loop     DEY                         ; Move to the character before the one we just moved
.1a5c66	88		dey		                DEY
.1a5c67	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y           ; Get the character
.1a5c69	c8		iny		                INY                         ; Move to the next space
.1a5c6a	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Store the character here
.1a5c6c	c0 02 00	cpy #$0002	                CPY #2                      ; Check to see if we just moved the 2nd character
.1a5c6f	d0 f4		bne $1a5c65	                BNE insert_loop             ; If not, keep moving the characters
.1a5c71	a9 2e		lda #$2e	                LDA #'.'                    ; Insert the '.' in the space we openned
.1a5c73	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.1a5c75	e2 20		sep #$20	            SEP #$20
.1a5c77	18		clc		                CLC                         ; Compute the exponent
.1a5c78	a3 03		lda $03,s	                LDA L_K
.1a5c7a	69 05		adc #$05	                ADC #(FP_D - 1)
.1a5c7c	83 06		sta $06,s	                STA L_EXP
.1a5c7e	f0 19		beq $1a5c99	                BEQ done                    ; If it's 0, just return the number
.1a5c80	20 84 5b	jsr $1a5b84	            JSR STRFINDEND
.1a5c83	a9 45		lda #$45	                LDA #'E'                    ; Append the "E"
.1a5c85	20 36 5b	jsr $1a5b36	            JSR STREMIT
.1a5c88	a3 06		lda $06,s	                LDA L_EXP
.1a5c8a	20 42 5b	jsr $1a5b42	            JSR STREMITB
.1a5c8d	80 0a		bra $1a5c99	                BRA done                    ; TODO: reformat integer... add E and exponent...
.1a5c8f					ret_result
.1a5c8f	c2 20		rep #$20	            REP #$20
.1a5c91	a5 16		lda $0816	                LDA STRPTR                  ; Return the temporary string we've assembled
.1a5c93	85 23		sta $0823	                STA ARGUMENT1
.1a5c95	a5 18		lda $0818	                LDA STRPTR+2
.1a5c97	85 25		sta $0825	                STA ARGUMENT1+2
.1a5c99					done
.1a5c99	e2 20		sep #$20	            SEP #$20
.1a5c9b	a9 02		lda #$02	                LDA #TYPE_STRING
.1a5c9d	85 27		sta $0827	                STA ARGTYPE1
.1a5c9f	c2 20		rep #$20	            REP #$20
.1a5ca1	3b		tsc		                TSC                         ; Remove the locals from the stack
.1a5ca2	18		clc		                CLC
.1a5ca3	69 06 00	adc #$0006	                ADC #6
.1a5ca6	1b		tcs		                TCS
.1a5ca7	28		plp		                PLP
.1a5ca8	60		rts		            RTS
>1a5ca9	00 50 c3 47			ten_d_1         .dword $47c35000            ; 10^(FP_D-1), where FP_D=5
>1a5cad	00 00 80 3f			FP_1_0          .dword $3f800000    ; Floating point constant: 1.0
>1a5cb1	f3 04 b5 3f			FP_SQR_2_0      .dword $3fb504f3    ; Floating point constant: sqrt(2.0)
>1a5cb5	f3 04 35 3f			FP_SQR_0_5      .dword $3f3504f3    ; Floating point constant: sqrt(0.2)

;******  Return to file: src\basic816.s


;******  Processing file: src\transcendentals.s

.1a5cb9					Q_POLY_HR
.1a5cb9	e2 20		sep #$20	            SEP #$20
.1a5cbb	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a5cbd	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5cc1	c2 20		rep #$20	            REP #$20
.1a5cc3	bd 00 00	lda $0000,x	                LDA 0,X
.1a5cc6	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5cca	bd 02 00	lda $0002,x	                LDA 2,X
.1a5ccd	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5cd1	88		dey		                DEY             ; (Y-1) more coefficients.
.1a5cd2	e8		inx		loop            INX             ; point to the next coefficient
.1a5cd3	e8		inx		                INX
.1a5cd4	e8		inx		                INX
.1a5cd5	e8		inx		                INX
.1a5cd6	e2 20		sep #$20	            SEP #$20
.1a5cd8	a9 00		lda #$00	                LDA #FP_OUT_MULT
.1a5cda	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5cde	c2 20		rep #$20	            REP #$20
.1a5ce0	af 23 08 00	lda $000823	                LDA @l ARGUMENT1
.1a5ce4	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5ce8	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a5cec	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5cf0	ea		nop		                NOP
.1a5cf1	ea		nop		                NOP
.1a5cf2	ea		nop		                NOP
.1a5cf3	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5cf7	48		pha		                PHA
.1a5cf8	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5cfc	8f 0a e2 af	sta $afe20a	                STA FP_MATH_INPUT0_HL
.1a5d00	68		pla		                PLA
.1a5d01	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5d05	e2 20		sep #$20	            SEP #$20
.1a5d07	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a5d09	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5d0d	c2 20		rep #$20	            REP #$20
.1a5d0f	bd 00 00	lda $0000,x	                LDA 0,X
.1a5d12	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5d16	bd 02 00	lda $0002,x	                LDA 2,X
.1a5d19	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5d1d	ea		nop		                NOP
.1a5d1e	ea		nop		                NOP
.1a5d1f	ea		nop		                NOP
.1a5d20	88		dey		                DEY
.1a5d21	f0 14		beq $1a5d37	                BEQ done
.1a5d23	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5d27	48		pha		                PHA
.1a5d28	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5d2c	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5d30	68		pla		                PLA
.1a5d31	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5d35	80 9b		bra $1a5cd2	                BRA loop
.1a5d37	af 08 e2 af	lda $afe208	done            LDA @l FP_MATH_OUTPUT_FP_LL
.1a5d3b	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.1a5d3f	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5d43	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.1a5d47	60		rts		                RTS
.1a5d48					Q_SQ
.1a5d48	e2 20		sep #$20	            SEP #$20
.1a5d4a	a9 00		lda #$00	                LDA #0
.1a5d4c	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5d50	a9 00		lda #$00	                LDA #FP_OUT_MULT
.1a5d52	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5d56	c2 20		rep #$20	            REP #$20
.1a5d58	a5 23		lda $0823	                LDA ARGUMENT1
.1a5d5a	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5d5e	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5d62	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a5d66	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5d6a	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5d6e	ea		nop		                NOP
.1a5d6f	ea		nop		                NOP
.1a5d70	ea		nop		                NOP
.1a5d71	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5d75	85 23		sta $0823	                STA ARGUMENT1
.1a5d77	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5d7b	85 25		sta $0825	                STA ARGUMENT1+2
.1a5d7d	60		rts		                RTS
.1a5d7e					Q_INV
.1a5d7e	e2 20		sep #$20	            SEP #$20
.1a5d80	a9 00		lda #$00	                LDA #0
.1a5d82	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5d86	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a5d88	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5d8c	c2 20		rep #$20	            REP #$20
.1a5d8e	a5 23		lda $0823	                LDA ARGUMENT1
.1a5d90	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5d94	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a5d98	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5d9c	af d2 63 1a	lda $1a63d2	                LDA @l fp_one
.1a5da0	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5da4	af d4 63 1a	lda $1a63d4	                LDA @l fp_one+2
.1a5da8	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5dac	ea		nop		                NOP
.1a5dad	ea		nop		                NOP
.1a5dae	ea		nop		                NOP
.1a5daf	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5db3	85 23		sta $0823	                STA ARGUMENT1
.1a5db5	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5db9	85 25		sta $0825	                STA ARGUMENT1+2
.1a5dbb	60		rts		                RTS
.1a5dbc					Q_FP_SCALE
.1a5dbc	a2 00 00	ldx #$0000	                LDX #0
.1a5dbf	a5 23		lda $0823	loop            LDA ARGUMENT1
.1a5dc1	c5 29		cmp $0829	                CMP ARGUMENT2
.1a5dc3	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5dc5	e5 2b		sbc $082b	                SBC ARGUMENT2+2
.1a5dc7	90 1e		bcc $1a5de7	                BCC done
.1a5dc9	a5 23		lda $0823	                LDA ARGUMENT1
.1a5dcb	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5dcf	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5dd1	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5dd5	ea		nop		                NOP
.1a5dd6	ea		nop		                NOP
.1a5dd7	ea		nop		                NOP
.1a5dd8	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5ddc	85 23		sta $0823	                STA ARGUMENT1
.1a5dde	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5de2	85 25		sta $0825	                STA ARGUMENT1+2
.1a5de4	e8		inx		                INX
.1a5de5	80 d8		bra $1a5dbf	                BRA loop
.1a5de7					done
.1a5de7	60		rts		            RTS
.1a5de8					Q_FP_SCALE_TAU
.1a5de8	e2 20		sep #$20	            SEP #$20
.1a5dea	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a5dec	10 09		bpl $1a5df7	                BPL notneg
.1a5dee	29 7f		and #$7f	                AND #$7F
.1a5df0	85 26		sta $0826	                STA ARGUMENT1+3
.1a5df2	a9 01		lda #$01	                LDA #1
.1a5df4	48		pha		                PHA
.1a5df5	80 03		bra $1a5dfa	                BRA compute
.1a5df7	a9 00		lda #$00	notneg          LDA #0          ; not negative, so push 0.
.1a5df9	48		pha		                PHA
.1a5dfa	a9 40		lda #$40	compute         LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a5dfc	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5e00	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a5e02	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5e06	c2 30		rep #$30	            REP #$30
.1a5e08	af 3a 64 1a	lda $1a643a	                LDA @l twopi
.1a5e0c	85 29		sta $0829	                STA ARGUMENT2
.1a5e0e	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5e12	af 3c 64 1a	lda $1a643c	                LDA @l twopi+2
.1a5e16	85 2b		sta $082b	                STA ARGUMENT2+2
.1a5e18	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5e1c	20 bc 5d	jsr $1a5dbc	            JSR Q_FP_SCALE
.1a5e1f	e2 20		sep #$20	            SEP #$20
.1a5e21	68		pla		                PLA
.1a5e22	c2 20		rep #$20	            REP #$20
.1a5e24	f0 1e		beq $1a5e44	                BEQ done
.1a5e26	a5 23		lda $0823	                LDA ARGUMENT1
.1a5e28	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5e2c	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5e2e	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5e32	ea		nop		                NOP
.1a5e33	ea		nop		                NOP
.1a5e34	ea		nop		                NOP
.1a5e35	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5e39	85 23		sta $0823	                STA ARGUMENT1
.1a5e3b	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5e3f	29 ff 7f	and #$7fff	                AND #$7fff
.1a5e42	85 25		sta $0825	                STA ARGUMENT1+2
.1a5e44					done
.1a5e44	60		rts		            RTS
.1a5e45					Q_FP_NORM_ANGLE
.1a5e45	5a		phy		                PHY
.1a5e46	a2 00 00	ldx #$0000	                LDX #0
.1a5e49	a0 00 00	ldy #$0000	                LDY #0
.1a5e4c	a5 23		lda $0823	loop            LDA ARGUMENT1
.1a5e4e	df 3e 64 1a	cmp $1a643e,x	                CMP @l onepi,x
.1a5e52	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5e54	ff 40 64 1a	sbc $1a6440,x	                SBC @l onepi+2,x
.1a5e58	90 2c		bcc $1a5e86	                BCC less
.1a5e5a	bf 3a 64 1a	lda $1a643a,x	                LDA @l twopi,x
.1a5e5e	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5e62	bf 3c 64 1a	lda $1a643c,x	                LDA @l twopi+2,x
.1a5e66	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5e6a	a5 23		lda $0823	                LDA ARGUMENT1
.1a5e6c	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5e70	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5e72	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5e76	ea		nop		                NOP
.1a5e77	ea		nop		                NOP
.1a5e78	ea		nop		                NOP
.1a5e79	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5e7d	85 23		sta $0823	                STA ARGUMENT1
.1a5e7f	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5e83	85 25		sta $0825	                STA ARGUMENT1+2
.1a5e85	38		sec		                SEC             ; set carry to indicate a reflection
.1a5e86	98		tya		less            TYA             ; carry already cleared if we branched
.1a5e87	2a		rol a		                ROL             ; shift carry into flags...
.1a5e88	a8		tay		                TAY             ; and store back into y
.1a5e89	e8		inx		                INX             ; next set of values
.1a5e8a	e8		inx		                INX
.1a5e8b	e8		inx		                INX
.1a5e8c	e8		inx		                INX
.1a5e8d	e0 0c 00	cpx #$000c	                CPX #12         ; check if we have already looked at 3
.1a5e90	d0 ba		bne $1a5e4c	                BNE loop
.1a5e92	98		tya		                TYA             ; copy Y to X, as that's what we have
.1a5e93	aa		tax		                TAX
.1a5e94	7a		ply		                PLY
.1a5e95	60		rts		            RTS
.1a5e96					Q_FP_COS
.1a5e96	08		php		                PHP
.1a5e97	c2 30		rep #$30	            REP #$30
.1a5e99	48		pha		                PHA
.1a5e9a	da		phx		                PHX
.1a5e9b	20 48 5d	jsr $1a5d48	            JSR Q_SQ
.1a5e9e	8b		phb		                PHB
.1a5e9f	e2 20		sep #$20	            SEP #$20
.1a5ea1	a9 1a		lda #$1a	                LDA #`cos_coeff
.1a5ea3	48		pha		                PHA
.1a5ea4	ab		plb		                PLB
.1a5ea5	c2 20		rep #$20	            REP #$20
.1a5ea7	a2 7a 63	ldx #$637a	                LDX #<>cos_coeff
.1a5eaa	5a		phy		                PHY
.1a5eab	a0 05 00	ldy #$0005	                LDY #5
.1a5eae	20 b9 5c	jsr $1a5cb9	            JSR Q_POLY_HR
.1a5eb1	7a		ply		                PLY
.1a5eb2	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.1a5eb5	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.1a5eb9	ab		plb		                PLB
.1a5eba	fa		plx		                PLX
.1a5ebb	68		pla		                PLA
.1a5ebc	28		plp		                PLP
.1a5ebd	60		rts		            RTS
.1a5ebe					Q_FP_SIN
.1a5ebe	08		php		                PHP
.1a5ebf	c2 30		rep #$30	            REP #$30
.1a5ec1	48		pha		                PHA
.1a5ec2	da		phx		                PHX
.1a5ec3	a5 23		lda $0823	                LDA ARGUMENT1
.1a5ec5	85 29		sta $0829	                STA ARGUMENT2
.1a5ec7	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5ec9	85 2b		sta $082b	                STA ARGUMENT2+2
.1a5ecb	20 48 5d	jsr $1a5d48	            JSR Q_SQ
.1a5ece	8b		phb		                PHB
.1a5ecf	e2 20		sep #$20	            SEP #$20
.1a5ed1	a9 1a		lda #$1a	                LDA #`sin_coeff
.1a5ed3	48		pha		                PHA
.1a5ed4	ab		plb		                PLB
.1a5ed5	c2 20		rep #$20	            REP #$20
.1a5ed7	a2 8e 63	ldx #$638e	                LDX #<>sin_coeff
.1a5eda	5a		phy		                PHY
.1a5edb	a0 05 00	ldy #$0005	                LDY #5
.1a5ede	20 b9 5c	jsr $1a5cb9	            JSR Q_POLY_HR
.1a5ee1	7a		ply		                PLY
.1a5ee2	ab		plb		                PLB
.1a5ee3	20 23 55	jsr $1a5523	            JSR OP_FP_MUL
.1a5ee6	fa		plx		                PLX
.1a5ee7	68		pla		                PLA
.1a5ee8	28		plp		                PLP
.1a5ee9	60		rts		            RTS
.1a5eea					Q_FP_TAN
.1a5eea	08		php		                PHP
.1a5eeb	c2 30		rep #$30	            REP #$30
.1a5eed	48		pha		                PHA
.1a5eee	da		phx		                PHX
.1a5eef	a5 23		lda $0823	                LDA ARGUMENT1
.1a5ef1	85 29		sta $0829	                STA ARGUMENT2
.1a5ef3	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5ef5	85 2b		sta $082b	                STA ARGUMENT2+2
.1a5ef7	20 48 5d	jsr $1a5d48	            JSR Q_SQ
.1a5efa	8b		phb		                PHB
.1a5efb	e2 20		sep #$20	            SEP #$20
.1a5efd	a9 1a		lda #$1a	                LDA #`tan_coeff
.1a5eff	48		pha		                PHA
.1a5f00	ab		plb		                PLB
.1a5f01	c2 20		rep #$20	            REP #$20
.1a5f03	a2 a2 63	ldx #$63a2	                LDX #<>tan_coeff
.1a5f06	5a		phy		                PHY
.1a5f07	a0 05 00	ldy #$0005	                LDY #5
.1a5f0a	20 b9 5c	jsr $1a5cb9	            JSR Q_POLY_HR
.1a5f0d	7a		ply		                PLY
.1a5f0e	ab		plb		                PLB
.1a5f0f	20 23 55	jsr $1a5523	            JSR OP_FP_MUL
.1a5f12	fa		plx		                PLX
.1a5f13	68		pla		                PLA
.1a5f14	28		plp		                PLP
.1a5f15	60		rts		            RTS
.1a5f16					Q_FP_LN
.1a5f16	08		php		                PHP
.1a5f17	c2 30		rep #$30	            REP #$30
.1a5f19	48		pha		                PHA
.1a5f1a	da		phx		                PHX
.1a5f1b	e2 20		sep #$20	            SEP #$20
.1a5f1d	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a5f1f	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5f23	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a5f25	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5f29	c2 20		rep #$20	            REP #$20
.1a5f2b	a5 23		lda $0823	                LDA ARGUMENT1
.1a5f2d	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5f31	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5f33	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5f37	af d2 63 1a	lda $1a63d2	                LDA @l fp_one
.1a5f3b	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5f3f	af d4 63 1a	lda $1a63d4	                LDA @l fp_one+2
.1a5f43	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5f47	ea		nop		                NOP
.1a5f48	ea		nop		                NOP
.1a5f49	ea		nop		                NOP
.1a5f4a	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5f4e	85 0c		sta $080c	                STA SCRATCH
.1a5f50	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5f54	85 0e		sta $080e	                STA SCRATCH+2
.1a5f56	e2 20		sep #$20	            SEP #$20
.1a5f58	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a5f5a	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5f5e	c2 20		rep #$20	            REP #$20
.1a5f60	ea		nop		                NOP
.1a5f61	ea		nop		                NOP
.1a5f62	ea		nop		                NOP
.1a5f63	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5f67	85 10		sta $0810	                STA SCRATCH2
.1a5f69	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5f6d	85 12		sta $0812	                STA SCRATCH2+2
.1a5f6f	e2 20		sep #$20	            SEP #$20
.1a5f71	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a5f73	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5f77	c2 20		rep #$20	            REP #$20
.1a5f79	a5 0c		lda $080c	                LDA SCRATCH
.1a5f7b	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5f7f	a5 0e		lda $080e	                LDA SCRATCH+2
.1a5f81	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5f85	a5 10		lda $0810	                LDA SCRATCH2
.1a5f87	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5f8b	a5 12		lda $0812	                LDA SCRATCH2+2
.1a5f8d	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5f91	ea		nop		                NOP
.1a5f92	ea		nop		                NOP
.1a5f93	ea		nop		                NOP
.1a5f94	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5f98	85 23		sta $0823	                STA ARGUMENT1
.1a5f9a	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5f9e	85 25		sta $0825	                STA ARGUMENT1+2
.1a5fa0	e2 20		sep #$20	            SEP #$20
.1a5fa2	a9 08		lda #$08	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX0
.1a5fa4	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5fa8	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a5faa	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5fae	c2 20		rep #$20	            REP #$20
.1a5fb0	a5 23		lda $0823	                LDA ARGUMENT1
.1a5fb2	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5fb6	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5fb8	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5fbc	ea		nop		                NOP
.1a5fbd	ea		nop		                NOP
.1a5fbe	ea		nop		                NOP
.1a5fbf	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5fc3	85 29		sta $0829	                STA ARGUMENT2
.1a5fc5	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5fc9	85 2b		sta $082b	                STA ARGUMENT2+2
.1a5fcb	20 48 5d	jsr $1a5d48	            JSR Q_SQ
.1a5fce	8b		phb		                PHB
.1a5fcf	e2 20		sep #$20	            SEP #$20
.1a5fd1	a9 1a		lda #$1a	                LDA #`ln_coeff
.1a5fd3	48		pha		                PHA
.1a5fd4	ab		plb		                PLB
.1a5fd5	c2 20		rep #$20	            REP #$20
.1a5fd7	a2 b6 63	ldx #$63b6	                LDX #<>ln_coeff
.1a5fda	5a		phy		                PHY
.1a5fdb	a0 08 00	ldy #$0008	                LDY #8
.1a5fde	20 b9 5c	jsr $1a5cb9	            JSR Q_POLY_HR
.1a5fe1	7a		ply		                PLY
.1a5fe2	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.1a5fe5	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.1a5fe9	8f 2d 08 00	sta $00082d	                STA @l ARGTYPE2
.1a5fed	20 23 55	jsr $1a5523	            JSR OP_FP_MUL
.1a5ff0	ab		plb		                PLB
.1a5ff1	fa		plx		                PLX
.1a5ff2	68		pla		                PLA
.1a5ff3	28		plp		                PLP
.1a5ff4	60		rts		            RTS
.1a5ff5					FP_SIN
.1a5ff5	08		php		                PHP
.1a5ff6	c2 30		rep #$30	            REP #$30
.1a5ff8	48		pha		                PHA
.1a5ff9	da		phx		                PHX
.1a5ffa	20 e8 5d	jsr $1a5de8	            JSR Q_FP_SCALE_TAU
.1a5ffd	20 45 5e	jsr $1a5e45	            JSR Q_FP_NORM_ANGLE
.1a6000	da		phx		                PHX
.1a6001	8a		txa		                TXA
.1a6002	29 01 00	and #$0001	                AND #1
.1a6005	d0 05		bne $1a600c	                BNE do_cos
.1a6007	20 be 5e	jsr $1a5ebe	            JSR Q_FP_SIN
.1a600a	80 03		bra $1a600f	                BRA maybe_neg
.1a600c					do_cos
.1a600c	20 96 5e	jsr $1a5e96	            JSR Q_FP_COS
.1a600f	fa		plx		maybe_neg       PLX
.1a6010	8a		txa		                TXA
.1a6011	29 04 00	and #$0004	                AND #4
.1a6014	f0 0a		beq $1a6020	                BEQ done
.1a6016	e2 20		sep #$20	            SEP #$20
.1a6018	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a601a	09 80		ora #$80	                ORA #$80
.1a601c	85 26		sta $0826	                STA ARGUMENT1+3
.1a601e	c2 20		rep #$20	            REP #$20
.1a6020	fa		plx		done            PLX
.1a6021	68		pla		                PLA
.1a6022	28		plp		                PLP
.1a6023	60		rts		            RTS
.1a6024					FP_COS
.1a6024	08		php		                PHP
.1a6025	c2 30		rep #$30	            REP #$30
.1a6027	48		pha		                PHA
.1a6028	da		phx		                PHX
.1a6029	20 e8 5d	jsr $1a5de8	            JSR Q_FP_SCALE_TAU
.1a602c	20 45 5e	jsr $1a5e45	            JSR Q_FP_NORM_ANGLE
.1a602f	da		phx		                PHX
.1a6030	8a		txa		                TXA
.1a6031	29 01 00	and #$0001	                AND #1
.1a6034	d0 05		bne $1a603b	                BNE do_sin
.1a6036	20 96 5e	jsr $1a5e96	            JSR Q_FP_COS
.1a6039	80 03		bra $1a603e	                BRA maybe_neg
.1a603b					do_sin
.1a603b	20 be 5e	jsr $1a5ebe	            JSR Q_FP_SIN
.1a603e	fa		plx		maybe_neg       PLX
.1a603f	8a		txa		                TXA
.1a6040	29 02 00	and #$0002	                AND #2
.1a6043	f0 0a		beq $1a604f	                BEQ done
.1a6045	e2 20		sep #$20	            SEP #$20
.1a6047	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a6049	09 80		ora #$80	                ORA #$80
.1a604b	85 26		sta $0826	                STA ARGUMENT1+3
.1a604d	c2 20		rep #$20	            REP #$20
.1a604f	fa		plx		done            PLX
.1a6050	68		pla		                PLA
.1a6051	28		plp		                PLP
.1a6052	60		rts		            RTS
.1a6053					FP_TAN
.1a6053	08		php		                PHP
.1a6054	c2 30		rep #$30	            REP #$30
.1a6056	48		pha		                PHA
.1a6057	da		phx		                PHX
.1a6058	20 e8 5d	jsr $1a5de8	            JSR Q_FP_SCALE_TAU
.1a605b	20 45 5e	jsr $1a5e45	            JSR Q_FP_NORM_ANGLE
.1a605e	20 ea 5e	jsr $1a5eea	            JSR Q_FP_TAN
.1a6061	8a		txa		                TXA
.1a6062	29 01 00	and #$0001	                AND #1
.1a6065	f0 03		beq $1a606a	                BEQ no_inv
.1a6067	20 7e 5d	jsr $1a5d7e	            JSR Q_INV
.1a606a	8a		txa		no_inv          TXA
.1a606b	e2 20		sep #$20	            SEP #$20
.1a606d	4a		lsr a		                LSR
.1a606e	4a		lsr a		                LSR
.1a606f	69 00		adc #$00	                ADC #0
.1a6071	29 01		and #$01	                AND #1
.1a6073	f0 06		beq $1a607b	                BEQ no_neg
.1a6075	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a6077	09 80		ora #$80	                ORA #$80
.1a6079	85 26		sta $0826	                STA ARGUMENT1+3
.1a607b					no_neg
.1a607b	c2 20		rep #$20	            REP #$20
.1a607d	fa		plx		                PLX
.1a607e	68		pla		                PLA
.1a607f	28		plp		                PLP
.1a6080	60		rts		            RTS
.1a6081					FP_LN
.1a6081	08		php		                PHP
.1a6082	c2 30		rep #$30	            REP #$30
.1a6084	48		pha		                PHA
.1a6085	da		phx		                PHX
.1a6086	5a		phy		                PHY
.1a6087	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6089	10 1f		bpl $1a60aa	                BPL arg_ok
.1a608b	08		php		            PHP
.1a608c	c2 20		rep #$20	            REP #$20
.1a608e	48		pha		            PHA
.1a608f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6092	5b		tcd		            TCD
.1a6093	68		pla		            PLA
.1a6094	28		plp		            PLP
.1a6095	e2 20		sep #$20	            SEP #$20
.1a6097	a9 17		lda #$17	            LDA #ERR_DOMAIN
.1a6099	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a609d	c2 20		rep #$20	            REP #$20
.1a609f	29 ff 00	and #$00ff	            AND #$00FF
.1a60a2	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a60a5	e2 20		sep #$20	            SEP #$20
.1a60a7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a60aa					arg_ok
.1a60aa	c2 30		rep #$30	            REP #$30
.1a60ac	a5 23		lda $0823	                LDA ARGUMENT1
.1a60ae	cf d2 63 1a	cmp $1a63d2	                CMP @l fp_one
.1a60b2	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a60b4	cf d4 63 1a	cmp $1a63d4	                CMP @l fp_one+2
.1a60b8	b0 04		bcs $1a60be	                BCS gtone
.1a60ba	20 7e 5d	jsr $1a5d7e	            JSR Q_INV
.1a60bd	18		clc		                CLC
.1a60be	a9 00 00	lda #$0000	gtone           LDA #0
.1a60c1	a8		tay		                TAY
.1a60c2	2a		rol a		                ROL             ; Rotate Carry into A; 0 means negate
.1a60c3	48		pha		                PHA
.1a60c4	e2 20		sep #$20	            SEP #$20
.1a60c6	a9 00		lda #$00	                LDA #0
.1a60c8	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a60cc	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a60ce	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a60d2	c2 20		rep #$20	            REP #$20
.1a60d4	af 2a 64 1a	lda $1a642a	                LDA @l eexp64
.1a60d8	85 29		sta $0829	                STA ARGUMENT2
.1a60da	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a60de	af 2c 64 1a	lda $1a642c	                LDA @l eexp64+2
.1a60e2	85 2b		sta $082b	                STA ARGUMENT2+2
.1a60e4	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a60e8	20 bc 5d	jsr $1a5dbc	            JSR Q_FP_SCALE
.1a60eb	8a		txa		                TXA
.1a60ec	f0 07		beq $1a60f5	                BEQ chk16
.1a60ee	0a		asl a		                ASL             ; multiply counter by 64
.1a60ef	0a		asl a		                ASL
.1a60f0	0a		asl a		                ASL
.1a60f1	0a		asl a		                ASL
.1a60f2	0a		asl a		                ASL
.1a60f3	0a		asl a		                ASL
.1a60f4	a8		tay		                TAY
.1a60f5	af 2e 64 1a	lda $1a642e	chk16           LDA @l eexp16
.1a60f9	85 29		sta $0829	                STA ARGUMENT2
.1a60fb	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a60ff	af 30 64 1a	lda $1a6430	                LDA @l eexp16+2
.1a6103	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6105	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a6109	20 bc 5d	jsr $1a5dbc	            JSR Q_FP_SCALE
.1a610c	8a		txa		                TXA
.1a610d	f0 0b		beq $1a611a	                BEQ chk04
.1a610f	0a		asl a		                ASL             ; multiply counter by 16
.1a6110	0a		asl a		                ASL
.1a6111	0a		asl a		                ASL
.1a6112	0a		asl a		                ASL
.1a6113	85 29		sta $0829	                STA ARGUMENT2   ; and add into total
.1a6115	18		clc		                CLC
.1a6116	98		tya		                TYA
.1a6117	65 29		adc $0829	                ADC ARGUMENT2
.1a6119	a8		tay		                TAY
.1a611a	af 32 64 1a	lda $1a6432	chk04           LDA @l eexp04
.1a611e	85 29		sta $0829	                STA ARGUMENT2
.1a6120	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a6124	af 34 64 1a	lda $1a6434	                LDA @l eexp04+2
.1a6128	85 2b		sta $082b	                STA ARGUMENT2+2
.1a612a	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a612e	20 bc 5d	jsr $1a5dbc	            JSR Q_FP_SCALE
.1a6131	8a		txa		                TXA
.1a6132	f0 09		beq $1a613d	                BEQ chk01
.1a6134	0a		asl a		                ASL             ;multiply counter by 4
.1a6135	0a		asl a		                ASL
.1a6136	85 29		sta $0829	                STA ARGUMENT2   ;and add to total
.1a6138	18		clc		                CLC
.1a6139	98		tya		                TYA
.1a613a	65 29		adc $0829	                ADC ARGUMENT2
.1a613c	a8		tay		                TAY
.1a613d	af 36 64 1a	lda $1a6436	chk01           LDA @l eexp01
.1a6141	85 29		sta $0829	                STA ARGUMENT2
.1a6143	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a6147	af 38 64 1a	lda $1a6438	                LDA @l eexp01+2
.1a614b	85 2b		sta $082b	                STA ARGUMENT2+2
.1a614d	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a6151	20 bc 5d	jsr $1a5dbc	            JSR Q_FP_SCALE
.1a6154	86 29		stx $0829	                STX ARGUMENT2   ; add counter to total
.1a6156	18		clc		                CLC
.1a6157	98		tya		                TYA
.1a6158	65 29		adc $0829	                ADC ARGUMENT2
.1a615a	a8		tay		                TAY
.1a615b	20 16 5f	jsr $1a5f16	            JSR Q_FP_LN
.1a615e	a5 23		lda $0823	                LDA ARGUMENT1
.1a6160	85 29		sta $0829	                STA ARGUMENT2
.1a6162	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6164	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6166	98		tya		                TYA
.1a6167	85 23		sta $0823	                STA ARGUMENT1
.1a6169	64 25		stz $0825	                STZ ARGUMENT1+2
.1a616b	20 b0 59	jsr $1a59b0	            JSR ITOF
.1a616e	20 8d 54	jsr $1a548d	            JSR OP_FP_ADD
.1a6171	68		pla		                PLA
.1a6172	d0 07		bne $1a617b	                BNE done
.1a6174	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6176	09 00 80	ora #$8000	                ORA #$8000
.1a6179	85 25		sta $0825	                STA ARGUMENT1+2
.1a617b	7a		ply		done            PLY
.1a617c	fa		plx		                PLX
.1a617d	68		pla		                PLA
.1a617e	28		plp		                PLP
.1a617f	60		rts		            RTS
.1a6180					FP_ASIN
.1a6180	08		php		                PHP
.1a6181	c2 30		rep #$30	            REP #$30
.1a6183	48		pha		                PHA
.1a6184	da		phx		                PHX
.1a6185	a5 23		lda $0823	                LDA ARGUMENT1
.1a6187	85 29		sta $0829	                STA ARGUMENT2
.1a6189	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a618b	85 2b		sta $082b	                STA ARGUMENT2+2
.1a618d	20 48 5d	jsr $1a5d48	            JSR Q_SQ
.1a6190	8b		phb		                PHB
.1a6191	e2 20		sep #$20	            SEP #$20
.1a6193	a9 1a		lda #$1a	                LDA #`asin_coeff
.1a6195	48		pha		                PHA
.1a6196	ab		plb		                PLB
.1a6197	c2 20		rep #$20	            REP #$20
.1a6199	a2 da 63	ldx #$63da	                LDX #<>asin_coeff
.1a619c	a0 05 00	ldy #$0005	                LDY #5
.1a619f	20 b9 5c	jsr $1a5cb9	            JSR Q_POLY_HR
.1a61a2	ab		plb		                PLB
.1a61a3	20 23 55	jsr $1a5523	            JSR OP_FP_MUL
.1a61a6	fa		plx		                PLX
.1a61a7	68		pla		                PLA
.1a61a8	28		plp		                PLP
.1a61a9	60		rts		            RTS
.1a61aa					FP_ACOS
.1a61aa	08		php		                PHP
.1a61ab	c2 30		rep #$30	            REP #$30
.1a61ad	48		pha		                PHA
.1a61ae	da		phx		                PHX
.1a61af	20 80 61	jsr $1a6180	            JSR FP_ASIN
.1a61b2	af 42 64 1a	lda $1a6442	                LDA @l halfpi
.1a61b6	85 29		sta $0829	                STA ARGUMENT2
.1a61b8	af 44 64 1a	lda $1a6444	                LDA @l halfpi+2
.1a61bc	85 2b		sta $082b	                STA ARGUMENT2+2
.1a61be	20 82 54	jsr $1a5482	            JSR OP_FP_SUB
.1a61c1	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a61c3	49 00 80	eor #$8000	                EOR #$8000
.1a61c6	85 25		sta $0825	                STA ARGUMENT1+2
.1a61c8	fa		plx		                PLX
.1a61c9	68		pla		                PLA
.1a61ca	28		plp		                PLP
.1a61cb	60		rts		            RTS
.1a61cc					FP_ATAN
.1a61cc	08		php		                PHP
.1a61cd	c2 30		rep #$30	            REP #$30
.1a61cf	48		pha		                PHA
.1a61d0	da		phx		                PHX
.1a61d1	a5 23		lda $0823	                LDA ARGUMENT1
.1a61d3	85 29		sta $0829	                STA ARGUMENT2
.1a61d5	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a61d7	85 2b		sta $082b	                STA ARGUMENT2+2
.1a61d9	20 48 5d	jsr $1a5d48	            JSR Q_SQ
.1a61dc	8b		phb		                PHB
.1a61dd	e2 20		sep #$20	            SEP #$20
.1a61df	a9 1a		lda #$1a	                LDA #`atan_coeff
.1a61e1	48		pha		                PHA
.1a61e2	ab		plb		                PLB
.1a61e3	c2 20		rep #$20	            REP #$20
.1a61e5	a2 ee 63	ldx #$63ee	                LDX #<>atan_coeff
.1a61e8	a0 05 00	ldy #$0005	                LDY #5
.1a61eb	20 b9 5c	jsr $1a5cb9	            JSR Q_POLY_HR
.1a61ee	ab		plb		                PLB
.1a61ef	20 23 55	jsr $1a5523	            JSR OP_FP_MUL
.1a61f2	fa		plx		                PLX
.1a61f3	68		pla		                PLA
.1a61f4	28		plp		                PLP
.1a61f5	60		rts		            RTS
.1a61f6					Q_FP_POW_INT
.1a61f6	c2 20		rep #$20	            REP #$20
.1a61f8	a5 23		lda $0823	            LDA ARGUMENT1
.1a61fa	85 29		sta $0829	            STA ARGUMENT2
.1a61fc	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a61fe	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6200	c2 20		rep #$20	            REP #$20
.1a6202	af d2 63 1a	lda $1a63d2	            LDA @l fp_one
.1a6206	85 23		sta $0823	            STA ARGUMENT1
.1a6208	af d4 63 1a	lda $1a63d4	            LDA @l fp_one+2
.1a620c	85 25		sta $0825	            STA ARGUMENT1+2
.1a620e	8a		txa		loop            TXA
.1a620f	f0 30		beq $1a6241	                BEQ done
.1a6211	4a		lsr a		                LSR
.1a6212	aa		tax		                TAX
.1a6213	90 03		bcc $1a6218	                BCC next
.1a6215	20 23 55	jsr $1a5523	            JSR OP_FP_MUL
.1a6218					next
.1a6218	c2 20		rep #$20	            REP #$20
.1a621a	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a621c	48		pha		            PHA
.1a621d	a5 23		lda $0823	            LDA ARGUMENT1
.1a621f	48		pha		            PHA
.1a6220	c2 20		rep #$20	            REP #$20
.1a6222	a5 29		lda $0829	            LDA ARGUMENT2
.1a6224	85 23		sta $0823	            STA ARGUMENT1
.1a6226	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a6228	85 25		sta $0825	            STA ARGUMENT1+2
.1a622a	20 48 5d	jsr $1a5d48	            JSR Q_SQ
.1a622d	c2 20		rep #$20	            REP #$20
.1a622f	a5 23		lda $0823	            LDA ARGUMENT1
.1a6231	85 29		sta $0829	            STA ARGUMENT2
.1a6233	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6235	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6237	c2 20		rep #$20	            REP #$20
.1a6239	68		pla		            PLA
.1a623a	85 23		sta $0823	            STA ARGUMENT1
.1a623c	68		pla		            PLA
.1a623d	85 25		sta $0825	            STA ARGUMENT1+2
.1a623f	80 cd		bra $1a620e	                BRA loop
.1a6241					done
.1a6241	60		rts		            RTS
.1a6242					Q_FP_EXP
.1a6242	08		php		                PHP
.1a6243	c2 30		rep #$30	            REP #$30
.1a6245	48		pha		                PHA
.1a6246	da		phx		                PHX
.1a6247	8b		phb		                PHB
.1a6248	e2 20		sep #$20	            SEP #$20
.1a624a	a9 1a		lda #$1a	                LDA #`exp_coeff
.1a624c	48		pha		                PHA
.1a624d	ab		plb		                PLB
.1a624e	c2 20		rep #$20	            REP #$20
.1a6250	a2 02 64	ldx #$6402	                LDX #<>exp_coeff
.1a6253	5a		phy		                PHY
.1a6254	a0 0a 00	ldy #$000a	                LDY #10
.1a6257	20 b9 5c	jsr $1a5cb9	            JSR Q_POLY_HR
.1a625a	7a		ply		                PLY
.1a625b	ab		plb		                PLB
.1a625c	fa		plx		                PLX
.1a625d	68		pla		                PLA
.1a625e	28		plp		                PLP
.1a625f	60		rts		            RTS
.1a6260					FP_EXP
.1a6260	08		php		                PHP
.1a6261	c2 30		rep #$30	            REP #$30
.1a6263	48		pha		                PHA
.1a6264	da		phx		                PHX
.1a6265	5a		phy		                PHY
.1a6266	a5 23		lda $0823	                LDA ARGUMENT1   ; special case for x==0
.1a6268	05 25		ora $0825	                ORA ARGUMENT1+2
.1a626a	d0 10		bne $1a627c	                BNE notzero
.1a626c	c2 20		rep #$20	            REP #$20
.1a626e	af d2 63 1a	lda $1a63d2	            LDA @l fp_one
.1a6272	85 23		sta $0823	            STA ARGUMENT1
.1a6274	af d4 63 1a	lda $1a63d4	            LDA @l fp_one+2
.1a6278	85 25		sta $0825	            STA ARGUMENT1+2
.1a627a	80 61		bra $1a62dd	                BRA done
.1a627c	a5 25		lda $0825	notzero         LDA ARGUMENT1+2 ; check if negative
.1a627e	29 00 80	and #$8000	                AND #$8000
.1a6281	a8		tay		                TAY             ; Y != 0 -> arg was negative
.1a6282	f0 07		beq $1a628b	                BEQ notneg
.1a6284	a5 25		lda $0825	                LDA ARGUMENT1+2 ; negate x
.1a6286	29 ff 7f	and #$7fff	                AND #$7FFF
.1a6289	85 25		sta $0825	                STA ARGUMENT1+2
.1a628b					notneg
.1a628b	c2 20		rep #$20	            REP #$20
.1a628d	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a628f	48		pha		            PHA
.1a6290	a5 23		lda $0823	            LDA ARGUMENT1
.1a6292	48		pha		            PHA
.1a6293	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a6296	a6 23		ldx $0823	                LDX ARGUMENT1              ; INT(x) now in ARGUMENT1; low 16 bits into X
.1a6298	20 aa 06	jsr $1a06aa	            JSR ASS_ARG1_FLOAT
.1a629b	c2 20		rep #$20	            REP #$20
.1a629d	a5 23		lda $0823	            LDA ARGUMENT1
.1a629f	85 29		sta $0829	            STA ARGUMENT2
.1a62a1	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a62a3	85 2b		sta $082b	            STA ARGUMENT2+2
.1a62a5	c2 20		rep #$20	            REP #$20
.1a62a7	68		pla		            PLA
.1a62a8	85 23		sta $0823	            STA ARGUMENT1
.1a62aa	68		pla		            PLA
.1a62ab	85 25		sta $0825	            STA ARGUMENT1+2
.1a62ad	20 82 54	jsr $1a5482	            JSR OP_FP_SUB
.1a62b0	20 42 62	jsr $1a6242	            JSR Q_FP_EXP
.1a62b3	c2 20		rep #$20	            REP #$20
.1a62b5	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a62b7	48		pha		            PHA
.1a62b8	a5 23		lda $0823	            LDA ARGUMENT1
.1a62ba	48		pha		            PHA
.1a62bb	c2 20		rep #$20	            REP #$20
.1a62bd	af 36 64 1a	lda $1a6436	            LDA @leexp01
.1a62c1	85 23		sta $0823	            STA ARGUMENT1
.1a62c3	af 38 64 1a	lda $1a6438	            LDA @leexp01+2
.1a62c7	85 25		sta $0825	            STA ARGUMENT1+2
.1a62c9	20 f6 61	jsr $1a61f6	            JSR Q_FP_POW_INT
.1a62cc	c2 20		rep #$20	            REP #$20
.1a62ce	68		pla		            PLA
.1a62cf	85 29		sta $0829	            STA ARGUMENT2
.1a62d1	68		pla		            PLA
.1a62d2	85 2b		sta $082b	            STA ARGUMENT2+2
.1a62d4	20 23 55	jsr $1a5523	            JSR OP_FP_MUL
.1a62d7	98		tya		                TYA
.1a62d8	f0 03		beq $1a62dd	                BEQ done
.1a62da	20 7e 5d	jsr $1a5d7e	            JSR Q_INV
.1a62dd	7a		ply		done            PLY
.1a62de	fa		plx		                PLX
.1a62df	68		pla		                PLA
.1a62e0	28		plp		                PLP
.1a62e1	60		rts		            RTS
.1a62e2					FP_SQR
.1a62e2	08		php		                PHP
.1a62e3	c2 30		rep #$30	            REP #$30
.1a62e5	48		pha		                PHA
.1a62e6	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a62e8	10 1f		bpl $1a6309	                BPL arg_ok
.1a62ea	08		php		            PHP
.1a62eb	c2 20		rep #$20	            REP #$20
.1a62ed	48		pha		            PHA
.1a62ee	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a62f1	5b		tcd		            TCD
.1a62f2	68		pla		            PLA
.1a62f3	28		plp		            PLP
.1a62f4	e2 20		sep #$20	            SEP #$20
.1a62f6	a9 17		lda #$17	            LDA #ERR_DOMAIN
.1a62f8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a62fc	c2 20		rep #$20	            REP #$20
.1a62fe	29 ff 00	and #$00ff	            AND #$00FF
.1a6301	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a6304	e2 20		sep #$20	            SEP #$20
.1a6306	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6309					arg_ok
.1a6309	c2 30		rep #$30	            REP #$30
.1a630b	05 23		ora $0823	                ORA ARGUMENT1
.1a630d	f0 68		beq $1a6377	                BEQ done
.1a630f	c2 20		rep #$20	            REP #$20
.1a6311	af d6 63 1a	lda $1a63d6	            LDA @l fp_two
.1a6315	85 29		sta $0829	            STA ARGUMENT2
.1a6317	af d8 63 1a	lda $1a63d8	            LDA @l fp_two+2
.1a631b	85 2b		sta $082b	            STA ARGUMENT2+2
.1a631d	e2 20		sep #$20	            SEP #$20
.1a631f	a9 01		lda #$01	                LDA #TYPE_FLOAT
.1a6321	85 2d		sta $082d	                STA ARGTYPE2
.1a6323	c2 20		rep #$20	            REP #$20
.1a6325	c2 20		rep #$20	            REP #$20
.1a6327	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6329	48		pha		            PHA
.1a632a	a5 23		lda $0823	            LDA ARGUMENT1
.1a632c	48		pha		            PHA
.1a632d					loop
.1a632d	20 d8 54	jsr $1a54d8	            JSR OP_FP_DIV
.1a6330	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6332	c5 2b		cmp $082b	                CMP ARGUMENT2+2
.1a6334	d0 09		bne $1a633f	                BNE more
.1a6336	a5 23		lda $0823	                LDA ARGUMENT1
.1a6338	45 29		eor $0829	                EOR ARGUMENT2
.1a633a	29 f8 ff	and #$fff8	                AND #$FFF8
.1a633d	f0 30		beq $1a636f	                BEQ exitloop
.1a633f					more
.1a633f	20 8d 54	jsr $1a548d	            JSR OP_FP_ADD
.1a6342	c2 20		rep #$20	            REP #$20
.1a6344	af d6 63 1a	lda $1a63d6	            LDA @l fp_two
.1a6348	85 29		sta $0829	            STA ARGUMENT2
.1a634a	af d8 63 1a	lda $1a63d8	            LDA @l fp_two+2
.1a634e	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6350	20 d8 54	jsr $1a54d8	            JSR OP_FP_DIV
.1a6353	c2 20		rep #$20	            REP #$20
.1a6355	a5 23		lda $0823	            LDA ARGUMENT1
.1a6357	85 29		sta $0829	            STA ARGUMENT2
.1a6359	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a635b	85 2b		sta $082b	            STA ARGUMENT2+2
.1a635d	c2 20		rep #$20	            REP #$20
.1a635f	68		pla		            PLA
.1a6360	85 23		sta $0823	            STA ARGUMENT1
.1a6362	68		pla		            PLA
.1a6363	85 25		sta $0825	            STA ARGUMENT1+2
.1a6365	c2 20		rep #$20	            REP #$20
.1a6367	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6369	48		pha		            PHA
.1a636a	a5 23		lda $0823	            LDA ARGUMENT1
.1a636c	48		pha		            PHA
.1a636d	80 be		bra $1a632d	                BRA loop
.1a636f					exitloop
.1a636f	c2 20		rep #$20	            REP #$20
.1a6371	68		pla		            PLA
.1a6372	85 29		sta $0829	            STA ARGUMENT2
.1a6374	68		pla		            PLA
.1a6375	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6377	68		pla		done            PLA
.1a6378	28		plp		                PLP
.1a6379	60		rts		            RTS
.1a637a					cos_coeff
>1a637a	01 0d d0 37			                .dword $37D00D01
>1a637e	61 0b b6 ba			                .dword $BAB60B61
>1a6382	ab aa 2a 3d			                .dword $3D2AAAAB
>1a6386	00 00 00 bf			                .dword $BF000000
>1a638a	00 00 80 3f			                .dword $3F800000
.1a638e					sin_coeff
>1a638e	1d ef 38 36			                .dword $3638EF1D
>1a6392	01 0d 50 b9			                .dword $B9500D01
>1a6396	89 88 08 3c			                .dword $3C088889
>1a639a	ab aa 2a be			                .dword $BE2AAAAB
>1a639e	00 00 80 3f			                .dword $3F800000
.1a63a2					tan_coeff
>1a63a2	a4 27 b3 3c			                .dword $3CB327A4
>1a63a6	d1 0d 5d 3d			                .dword $3D5D0DD1
>1a63aa	89 88 08 3e			                .dword $3E088889
>1a63ae	ab aa aa 3e			                .dword $3EAAAAAB
>1a63b2	00 00 80 3f			                .dword $3F800000
.1a63b6					ln_coeff
>1a63b6	89 88 88 3d			                .dword $3D888889
>1a63ba	d9 89 9d 3d			                .dword $3D9D89D9
>1a63be	8c 2e ba 3d			                .dword $3DBA2E8C
>1a63c2	39 8e e3 3d			                .dword $3DE38E39
>1a63c6	25 49 12 3e			                .dword $3E124925
>1a63ca	cd cc 4c 3e			                .dword $3E4CCCCD
>1a63ce	ab aa aa 3e			                .dword $3EAAAAAB
>1a63d2	00 00 80 3f			fp_one          .dword $3F800000
>1a63d6	00 00 00 40			fp_two          .dword $40000000
.1a63da					asin_coeff
>1a63da	8e e3 f8 3c			                .dword $3CF8E38E
>1a63de	6e db 36 3d			                .dword $3D36DB6E
>1a63e2	9a 99 99 3d			                .dword $3D99999A
>1a63e6	ab aa 2a 3e			                .dword $3E2AAAAB
>1a63ea	00 00 80 3f			                .dword $3F800000
.1a63ee					atan_coeff
>1a63ee	39 8e e3 3d			                .dword $3DE38E39
>1a63f2	25 49 12 be			                .dword $BE124925
>1a63f6	cd cc 4c 3e			                .dword $3E4CCCCD
>1a63fa	ab aa aa be			                .dword $BEAAAAAB
>1a63fe	00 00 80 3f			                .dword $3F800000
.1a6402					exp_coeff
>1a6402	1d ef 38 36			        .dword $3638EF1D
>1a6406	01 0d d0 37			        .dword $37D00D01
>1a640a	01 0d 50 39			        .dword $39500D01
>1a640e	61 0b b6 3a			        .dword $3AB60B61
>1a6412	89 88 08 3c			        .dword $3C088889
>1a6416	ab aa 2a 3d			        .dword $3D2AAAAB
>1a641a	ab aa 2a 3e			        .dword $3E2AAAAB
>1a641e	00 00 00 3f			        .dword $3F000000
>1a6422	00 00 80 3f			        .dword $3F800000
>1a6426	00 00 80 3f			        .dword $3F800000
>1a642a	c1 2c a1 6d			eexp64          .dword $6DA12CC1
>1a642e	5f 97 07 4b			eexp16          .dword $4B07975F
>1a6432	81 64 5a 42			eexp04          .dword $425A6481
>1a6436	54 f8 2d 40			eexp01          .dword $402DF854
>1a643a	db 0f c9 40			twopi           .dword $40C90FDB
>1a643e	db 0f 49 40			onepi           .dword $40490FDB
>1a6442	db 0f c9 3f			halfpi          .dword $3FC90FDB
>1a6446	db 0f 49 3f			quarterpi       .dword $3F490FDB

;******  Return to file: src\basic816.s


;******  Processing file: src\arrays.s

.1a644a					ARR_ALLOC
.1a644a	08		php		                PHP
.1a644b	20 f5 11	jsr $1a11f5	            JSR HEAP_GETHED
.1a644e	c2 20		rep #$20	            REP #$20
.1a6450	a9 01 00	lda #$0001	                LDA #1                      ; ARGUMENT1 := 1
.1a6453	85 23		sta $0823	                STA ARGUMENT1
.1a6455	a9 00 00	lda #$0000	                LDA #0
.1a6458	85 25		sta $0825	                STA ARGUMENT1+2
.1a645a	e2 20		sep #$20	            SEP #$20
.1a645c	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.1a6460	c2 20		rep #$20	            REP #$20
.1a6462	29 ff 00	and #$00ff	                AND #$00FF
.1a6465	85 8f		sta $088f	                STA MCOUNT                  ; Save it to MCOUNT for later
.1a6467	a8		tay		                TAY                         ; Y := number of dimensions
.1a6468	a2 01 00	ldx #$0001	                LDX #1                      ; X := index to size 0
.1a646b					size_loop
.1a646b	c2 20		rep #$20	            REP #$20
.1a646d	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X           ; ARGUMENT2 := Ith dimension
.1a6471	85 29		sta $0829	                STA ARGUMENT2
.1a6473	a9 00 00	lda #$0000	                LDA #0
.1a6476	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6478	20 cd 26	jsr $1a26cd	            JSR OP_MULTIPLY
.1a647b	e8		inx		                INX
.1a647c	e8		inx		                INX
.1a647d	88		dey		                DEY
.1a647e	d0 eb		bne $1a646b	                BNE size_loop               ; If there are more dimensions, take the next one
.1a6480	c2 20		rep #$20	            REP #$20
.1a6482	a9 04 00	lda #$0004	                LDA #ARGUMENT_SIZE-1        ; Size of a data item (don't include the type code)
.1a6485	85 29		sta $0829	                STA ARGUMENT2
.1a6487	a9 00 00	lda #$0000	                LDA #0
.1a648a	85 2b		sta $082b	                STA ARGUMENT2+2
.1a648c	20 cd 26	jsr $1a26cd	            JSR OP_MULTIPLY
.1a648f	e2 20		sep #$20	            SEP #$20
.1a6491	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF             ; SCRATCH := N * 2
.1a6495	85 0c		sta $080c	                STA SCRATCH
.1a6497	a9 00		lda #$00	                LDA #0
.1a6499	85 0d		sta $080d	                STA SCRATCH+1
.1a649b	c2 20		rep #$20	            REP #$20
.1a649d	06 0c		asl $080c	                ASL SCRATCH
.1a649f	38		sec		                SEC                         ; ARGUMENT1 := size of the complete block
.1a64a0	a5 23		lda $0823	                LDA ARGUMENT1
.1a64a2	65 0c		adc $080c	                ADC SCRATCH                 ; Size of data area + N*2 + 1 (in carry)
.1a64a4	85 23		sta $0823	                STA ARGUMENT1
.1a64a6	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a64a8	69 00 00	adc #$0000	                ADC #0
.1a64ab	85 25		sta $0825	                STA ARGUMENT1+2
.1a64ad	d0 29		bne $1a64d8	                BNE too_big                 ; size > 16-bit? Yes: throw an error
.1a64af	e2 20		sep #$20	            SEP #$20
.1a64b1	a5 ea		lda $08ea	                LDA TOFINDTYPE              ; Get the type
.1a64b3	09 80		ora #$80	                ORA #$80                    ; Flip the flag to make it an array of that type
.1a64b5	a6 23		ldx $0823	                LDX ARGUMENT1               ; Get the computed size
.1a64b7	20 b9 0f	jsr $1a0fb9	            JSR ALLOC
.1a64ba	e2 20		sep #$20	            SEP #$20
.1a64bc	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.1a64c0	87 c0		sta [$08c0]	                STA [CURRBLOCK]             ; Write the number of dimensions to the array's preamble
.1a64c2	a0 01 00	ldy #$0001	                LDY #1
.1a64c5	a2 00 00	ldx #$0000	                LDX #0
.1a64c8					copy_loop
.1a64c8	e2 20		sep #$20	            SEP #$20
.1a64ca	bf 01 4d 00	lda $004d01,x	                LDA @lARRIDXBUF+1,X         ; ARGUMENT2 := Ith dimension
.1a64ce	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y           ; And write the dimension to the array's preamble
.1a64d0	e4 8f		cpx $088f	                CPX MCOUNT                  ; Have we written the last byte?
.1a64d2	f0 23		beq $1a64f7	                BEQ null_array              ; Yes: clear the array
.1a64d4	e8		inx		                INX                         ; No: move to the next byte
.1a64d5	c8		iny		                INY
.1a64d6	80 f0		bra $1a64c8	                BRA copy_loop
.1a64d8					too_big
.1a64d8	08		php		            PHP
.1a64d9	c2 20		rep #$20	            REP #$20
.1a64db	48		pha		            PHA
.1a64dc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a64df	5b		tcd		            TCD
.1a64e0	68		pla		            PLA
.1a64e1	28		plp		            PLP
.1a64e2	e2 20		sep #$20	            SEP #$20
.1a64e4	a9 09		lda #$09	            LDA #ERR_RANGE
.1a64e6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a64ea	c2 20		rep #$20	            REP #$20
.1a64ec	29 ff 00	and #$00ff	            AND #$00FF
.1a64ef	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a64f2	e2 20		sep #$20	            SEP #$20
.1a64f4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a64f7					null_array
.1a64f7	e2 20		sep #$20	            SEP #$20
.1a64f9	38		sec		                SEC                         ; INDEX := pointer to first value
.1a64fa	a5 c0		lda $08c0	                LDA CURRBLOCK
.1a64fc	67 c0		adc [$08c0]	                ADC [CURRBLOCK]
.1a64fe	85 08		sta $0808	                STA INDEX
.1a6500	a5 c1		lda $08c1	                LDA CURRBLOCK+1
.1a6502	69 00		adc #$00	                ADC #0
.1a6504	85 09		sta $0809	                STA INDEX+1
.1a6506	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a6508	69 00		adc #$00	                ADC #0
.1a650a	85 0a		sta $080a	                STA INDEX+2
.1a650c	64 0b		stz $080b	                STZ INDEX+3
.1a650e	c2 20		rep #$20	            REP #$20
.1a6510	a0 05 00	ldy #$0005	                LDY #HEAPOBJ.END            ; SCRATCH := pointer the the first byte after the array
.1a6513	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a6515	85 0c		sta $080c	                STA SCRATCH
.1a6517	e2 20		sep #$20	            SEP #$20
.1a6519	c8		iny		                INY
.1a651a	c8		iny		                INY
.1a651b	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a651d	85 0e		sta $080e	                STA SCRATCH+2
.1a651f	64 0f		stz $080f	                STZ SCRATCH+3
.1a6521					clr_loop
.1a6521	e2 20		sep #$20	            SEP #$20
.1a6523	a9 00		lda #$00	                LDA #0
.1a6525	87 08		sta [$0808]	                STA [INDEX]                 ; Clear the byte
.1a6527	c2 20		rep #$20	            REP #$20
.1a6529	18		clc		                CLC                         ; Increment INDEX
.1a652a	a5 08		lda $0808	                LDA INDEX
.1a652c	69 01 00	adc #$0001	                ADC #1
.1a652f	85 08		sta $0808	                STA INDEX
.1a6531	a5 0a		lda $080a	                LDA INDEX+2
.1a6533	69 00 00	adc #$0000	                ADC #0
.1a6536	85 0a		sta $080a	                STA INDEX+2
.1a6538	c5 0e		cmp $080e	                CMP SCRATCH+2               ; INDEX == SCRATCH?
.1a653a	d0 e5		bne $1a6521	                BNE clr_loop                ; No: write to this next byte
.1a653c	a5 08		lda $0808	                LDA INDEX
.1a653e	c5 0c		cmp $080c	                CMP SCRATCH
.1a6540	d0 df		bne $1a6521	                BNE clr_loop
.1a6542					done
.1a6542	28		plp		                PLP
.1a6543	60		rts		            RTS
.1a6544					ARR_CELL
.1a6544	08		php		                PHP
.1a6545	c2 20		rep #$20	            REP #$20
.1a6547	64 08		stz $0808	                STZ INDEX               ; INDEX := 0
.1a6549	64 0a		stz $080a	                STZ INDEX+2
.1a654b	e2 20		sep #$20	            SEP #$20
.1a654d	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF         ; MCOUNT := N (number of dimensions)
.1a6551	85 8f		sta $088f	                STA MCOUNT
.1a6553	64 90		stz $0890	                STZ MCOUNT+1
.1a6555	a2 01 00	ldx #$0001	                LDX #1                  ; X := index to dimension 0
.1a6558	e2 20		sep #$20	            SEP #$20
.1a655a	a7 c0		lda [$08c0]	                LDA [CURRBLOCK]         ; Make sure the dimensions of the array
.1a655c	c5 8f		cmp $088f	                CMP MCOUNT              ; ... match those requested
.1a655e	f0 1f		beq $1a657f	                BEQ dims_match          ; Yes: the dimensions match
.1a6560					arg_err
.1a6560	08		php		            PHP
.1a6561	c2 20		rep #$20	            REP #$20
.1a6563	48		pha		            PHA
.1a6564	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6567	5b		tcd		            TCD
.1a6568	68		pla		            PLA
.1a6569	28		plp		            PLP
.1a656a	e2 20		sep #$20	            SEP #$20
.1a656c	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a656e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6572	c2 20		rep #$20	            REP #$20
.1a6574	29 ff 00	and #$00ff	            AND #$00FF
.1a6577	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a657a	e2 20		sep #$20	            SEP #$20
.1a657c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a657f	c9 01		cmp #$01	dims_match      CMP #1                  ; Check to see if this array is one dimensional
.1a6581	f0 3a		beq $1a65bd	                BEQ add_last            ; If so, just add the index of the cell to INDEX
.1a6583	a0 01 00	ldy #$0001	                LDY #1
.1a6586					index_loop
.1a6586	e2 20		sep #$20	            SEP #$20
.1a6588	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; ARGUMENT1 := I_j
.1a658c	85 23		sta $0823	                STA ARGUMENT1
.1a658e	64 24		stz $0824	                STZ ARGUMENT1+1
.1a6590	64 25		stz $0825	                STZ ARGUMENT1+2
.1a6592	64 26		stz $0826	                STZ ARGUMENT1+3
.1a6594	b7 c0		lda [$08c0],y	                LDA [CURRBLOCK],Y       ; ARGUMENT2 := D_j
.1a6596	85 29		sta $0829	                STA ARGUMENT2
.1a6598	64 2a		stz $082a	                STZ ARGUMENT2+1
.1a659a	64 2b		stz $082b	                STZ ARGUMENT2+2
.1a659c	64 2c		stz $082c	                STZ ARGUMENT2+3
.1a659e	a5 23		lda $0823	                LDA ARGUMENT1
.1a65a0	c5 29		cmp $0829	                CMP ARGUMENT2           ; Is I_j >= D_j
.1a65a2	b0 68		bcs $1a660c	                BGE range_err           ; Yes: throw an out-of-range error
.1a65a4	20 cd 26	jsr $1a26cd	            JSR OP_MULTIPLY
.1a65a7	c2 20		rep #$20	            REP #$20
.1a65a9	18		clc		                CLC                     ; INDEX := INDEX + ARGUMENT1
.1a65aa	a5 08		lda $0808	                LDA INDEX
.1a65ac	65 23		adc $0823	                ADC ARGUMENT1
.1a65ae	85 08		sta $0808	                STA INDEX
.1a65b0	a5 0a		lda $080a	                LDA INDEX+2
.1a65b2	65 25		adc $0825	                ADC ARGUMENT1+2
.1a65b4	85 0a		sta $080a	                STA INDEX+2
.1a65b6	e8		inx		                INX
.1a65b7	e8		inx		                INX
.1a65b8	c8		iny		                INY
.1a65b9	c4 8f		cpy $088f	                CPY MCOUNT              ; Are we on the last index?
.1a65bb	d0 c9		bne $1a6586	                BNE index_loop          ; No: move to the next index and try again
.1a65bd					add_last
.1a65bd	e2 20		sep #$20	            SEP #$20
.1a65bf	18		clc		                CLC
.1a65c0	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; INDEX := INDEX + I_(n-1)
.1a65c4	85 90		sta $0890	                STA MCOUNT+1
.1a65c6	65 08		adc $0808	                ADC INDEX
.1a65c8	85 08		sta $0808	                STA INDEX
.1a65ca	a5 09		lda $0809	                LDA INDEX+1
.1a65cc	69 00		adc #$00	                ADC #0
.1a65ce	85 09		sta $0809	                STA INDEX+1
.1a65d0	c2 20		rep #$20	            REP #$20
.1a65d2	a5 0a		lda $080a	                LDA INDEX+2
.1a65d4	69 00 00	adc #$0000	                ADC #0
.1a65d7	85 0a		sta $080a	                STA INDEX+2
.1a65d9	c2 20		rep #$20	            REP #$20
.1a65db	06 08		asl $0808	                ASL INDEX               ; INDEX := INDEX * 4 (size of a value)
.1a65dd	26 0a		rol $080a	                ROL INDEX+2
.1a65df	06 08		asl $0808	                ASL INDEX
.1a65e1	26 0a		rol $080a	                ROL INDEX+2
.1a65e3	e2 20		sep #$20	            SEP #$20
.1a65e5	38		sec		                SEC
.1a65e6	a5 08		lda $0808	                LDA INDEX
.1a65e8	65 8f		adc $088f	                ADC MCOUNT
.1a65ea	85 08		sta $0808	                STA INDEX
.1a65ec	a5 09		lda $0809	                LDA INDEX+1
.1a65ee	69 00		adc #$00	                ADC #0
.1a65f0	85 09		sta $0809	                STA INDEX+1
.1a65f2	c2 20		rep #$20	            REP #$20
.1a65f4	a5 0a		lda $080a	                LDA INDEX+2
.1a65f6	69 00 00	adc #$0000	                ADC #0
.1a65f9	85 0a		sta $080a	                STA INDEX+2
.1a65fb	18		clc		                CLC                     ; INDEX := INDEX + CURRBLOCK (point to the address desired)
.1a65fc	a5 08		lda $0808	                LDA INDEX
.1a65fe	65 c0		adc $08c0	                ADC CURRBLOCK
.1a6600	85 08		sta $0808	                STA INDEX
.1a6602	e2 20		sep #$20	            SEP #$20
.1a6604	a5 0a		lda $080a	                LDA INDEX+2
.1a6606	65 c2		adc $08c2	                ADC CURRBLOCK+2
.1a6608	85 0a		sta $080a	                STA INDEX+2
.1a660a	28		plp		                PLP
.1a660b	60		rts		            RTS
.1a660c					range_err
.1a660c	08		php		            PHP
.1a660d	c2 20		rep #$20	            REP #$20
.1a660f	48		pha		            PHA
.1a6610	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6613	5b		tcd		            TCD
.1a6614	68		pla		            PLA
.1a6615	28		plp		            PLP
.1a6616	e2 20		sep #$20	            SEP #$20
.1a6618	a9 09		lda #$09	            LDA #ERR_RANGE
.1a661a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a661e	c2 20		rep #$20	            REP #$20
.1a6620	29 ff 00	and #$00ff	            AND #$00FF
.1a6623	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a6626	e2 20		sep #$20	            SEP #$20
.1a6628	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a662b					ARR_SET
.1a662b	08		php		                PHP
.1a662c	20 f5 11	jsr $1a11f5	            JSR HEAP_GETHED
.1a662f	e2 20		sep #$20	            SEP #$20
.1a6631	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.1a6634	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a6636	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.1a6638	c5 27		cmp $0827	                CMP ARGTYPE1        ; is it the same as the argument?
.1a663a	d0 28		bne $1a6664	                BNE type_mismatch   ; No: throw a type mismatch error
.1a663c	a5 27		lda $0827	                LDA ARGTYPE1        ; Save the type
.1a663e	48		pha		                PHA
.1a663f	c2 20		rep #$20	            REP #$20
.1a6641	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Save ARGUMENT1
.1a6643	48		pha		                PHA
.1a6644	a5 23		lda $0823	                LDA ARGUMENT1
.1a6646	48		pha		                PHA
.1a6647	20 44 65	jsr $1a6544	            JSR ARR_CELL
.1a664a	68		pla		                PLA                 ; Restore ARGUMENT1
.1a664b	85 23		sta $0823	                STA ARGUMENT1
.1a664d	68		pla		                PLA
.1a664e	85 25		sta $0825	                STA ARGUMENT1+2
.1a6650	e2 20		sep #$20	            SEP #$20
.1a6652	68		pla		                PLA
.1a6653	85 27		sta $0827	                STA ARGTYPE1
.1a6655	c2 20		rep #$20	            REP #$20
.1a6657	a5 23		lda $0823	                LDA ARGUMENT1       ; Set the value in the cell
.1a6659	87 08		sta [$0808]	                STA [INDEX]
.1a665b	a0 02 00	ldy #$0002	                LDY #2
.1a665e	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6660	97 08		sta [$0808],y	                STA [INDEX],Y
.1a6662	28		plp		                PLP
.1a6663	60		rts		            RTS
.1a6664					type_mismatch
.1a6664	08		php		            PHP
.1a6665	c2 20		rep #$20	            REP #$20
.1a6667	48		pha		            PHA
.1a6668	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a666b	5b		tcd		            TCD
.1a666c	68		pla		            PLA
.1a666d	28		plp		            PLP
.1a666e	e2 20		sep #$20	            SEP #$20
.1a6670	a9 04		lda #$04	            LDA #ERR_TYPE
.1a6672	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6676	c2 20		rep #$20	            REP #$20
.1a6678	29 ff 00	and #$00ff	            AND #$00FF
.1a667b	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a667e	e2 20		sep #$20	            SEP #$20
.1a6680	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6683					ARR_REF
.1a6683	08		php		                PHP
.1a6684	20 f5 11	jsr $1a11f5	            JSR HEAP_GETHED
.1a6687	f4 00 00	pea #$0000	                PEA #0              ; Make room on the stack that ARR_CELL expects
.1a668a	f4 00 00	pea #$0000	                PEA #0
.1a668d	e2 20		sep #$20	            SEP #$20
.1a668f	48		pha		                PHA
.1a6690	20 44 65	jsr $1a6544	            JSR ARR_CELL
.1a6693	e2 20		sep #$20	            SEP #$20
.1a6695	68		pla		                PLA
.1a6696	c2 20		rep #$20	            REP #$20
.1a6698	68		pla		                PLA
.1a6699	68		pla		                PLA
.1a669a	c2 20		rep #$20	            REP #$20
.1a669c	a7 08		lda [$0808]	                LDA [INDEX]         ; Get the value in the cell
.1a669e	85 23		sta $0823	                STA ARGUMENT1
.1a66a0	a0 02 00	ldy #$0002	                LDY #2
.1a66a3	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a66a5	85 25		sta $0825	                STA ARGUMENT1+2
.1a66a7	e2 20		sep #$20	            SEP #$20
.1a66a9	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.1a66ac	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a66ae	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.1a66b0	85 27		sta $0827	                STA ARGTYPE1        ; Set the type of the return value
.1a66b2	28		plp		                PLP
.1a66b3	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\dos.s

.0000					DIRENTRY
>0000					SHORTNAME               .fill 11        ; $00 - The short name of the file (8 name, 3 extension)
>000b					ATTRIBUTE               .byte ?         ; $0B - The attribute bits
>000c					IGNORED1                .word ?         ; $0C - Unused (by us) bytes
>000e					CREATE_TIME             .word ?         ; $0E - Creation time
>0010					CREATE_DATE             .word ?         ; $10 - Creation date
>0012					ACCESS_DATE             .word ?         ; $12 - Last access date
>0014					CLUSTER_H               .word ?         ; $14 - High word of the first cluster #
>0016					MODIFIED_TIME           .word ?         ; $16 - Last modified time
>0018					MODIFIED_DATE           .word ?         ; $18 - Last modified date
>001a					CLUSTER_L               .word ?         ; $1A - Low word of the first cluster #
>001c					SIZE                    .dword ?        ; $1C - The size of the file (in bytes)
=$01					DOS_ATTR_RO = $01                       ; File is read-only
=$02					DOS_ATTR_HIDDEN = $02                   ; File is hidden
=$04					DOS_ATTR_SYSTEM = $04                   ; File is a system file
=$08					DOS_ATTR_VOLUME = $08                   ; Entry is the volume label
=$10					DOS_ATTR_DIR = $10                      ; Entry is a directory
=$20					DOS_ATTR_ARCH = $20                     ; Entry has changed since last backup
=$0f					DOS_ATTR_LONGNAME = $0F                 ; Entry is the long file name
=$e5					DOS_DIR_ENT_UNUSED = $E5                ; Marker for an unused directory entry
.0000					FILEDESC
>0000					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>0001					DEV                 .byte ?             ; The ID of the device holding the file
>0002					PATH                .dword ?            ; Pointer to a NULL terminated path string
>0006					CLUSTER             .dword ?            ; The current cluster of the file.
>000a					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>000e					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>0012					FILESIZE            .dword ?            ; The size of the file
>0016					CREATE_DATE         .word ?             ; The creation date of the file
>0018					CREATE_TIME         .word ?             ; The creation time of the file
>001a					MODIFIED_DATE       .word ?             ; The modification date of the file
>001c					MODIFIED_TIME       .word ?             ; The modification time of the file
=$01					FD_STAT_READ = $01                      ; The file is readable
=$02					FD_STAT_WRITE = $02                     ; The file is writable
=$40					FD_STAT_OPEN = $40                      ; The file is open
=$60					FD_STAT_ERROR = $60                     ; The file is in an error condition
=$80					FD_STAT_EOF = $80                       ; The file cursor is at the end of the file
>1af073					CLUSTER_BUFF    .fill 512           ; A buffer for cluster read/write operations
.1af273					FD_IN
>1af273					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>1af274					DEV                 .byte ?             ; The ID of the device holding the file
>1af275					PATH                .dword ?            ; Pointer to a NULL terminated path string
>1af279					CLUSTER             .dword ?            ; The current cluster of the file.
>1af27d					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>1af281					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>1af285					FILESIZE            .dword ?            ; The size of the file
>1af289					CREATE_DATE         .word ?             ; The creation date of the file
>1af28b					CREATE_TIME         .word ?             ; The creation time of the file
>1af28d					MODIFIED_DATE       .word ?             ; The modification date of the file
>1af28f					MODIFIED_TIME       .word ?             ; The modification time of the file
.1a66b4					PR_FILESIZE
.1a66b4	da		phx		                PHX
.1a66b5	0b		phd		                PHD
.1a66b6	08		php		                PHP
.1a66b7	08		php		            PHP
.1a66b8	c2 20		rep #$20	            REP #$20
.1a66ba	48		pha		            PHA
.1a66bb	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a66be	5b		tcd		            TCD
.1a66bf	68		pla		            PLA
.1a66c0	28		plp		            PLP
.1a66c1	c2 30		rep #$30	            REP #$30
.1a66c3	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a66c5	89 f0 ff	bit #$fff0	                BIT #$FFF0              ; Check to see if the amount is in MB range
.1a66c8	d0 29		bne $1a66f3	                BNE pr_mb               ; If so, print it in MBs
.1a66ca	89 0f 00	bit #$000f	                BIT #$000F              ; Check to see if the amount is in KB range
.1a66cd	d0 0c		bne $1a66db	                BNE pr_kb
.1a66cf	a5 23		lda $0823	                LDA ARGUMENT1
.1a66d1	89 00 fc	bit #$fc00	                BIT #$FC00
.1a66d4	d0 05		bne $1a66db	                BNE pr_kb               ; If so, print it in KBs
.1a66d6					pr_regular
.1a66d6	20 46 44	jsr $1a4446	            JSR PR_INTEGER
.1a66d9	80 2e		bra $1a6709	                BRA done
.1a66db	a2 0a 00	ldx #$000a	pr_kb           LDX #10                 ; Shift so the amount in KB is in ARGUMENT1
.1a66de	46 25		lsr $0825	kb_shift        LSR ARGUMENT1+2
.1a66e0	66 23		ror $0823	                ROR ARGUMENT1
.1a66e2	ca		dex		                DEX
.1a66e3	d0 f9		bne $1a66de	                BNE kb_shift
.1a66e5	20 46 44	jsr $1a4446	            JSR PR_INTEGER
.1a66e8	e2 20		sep #$20	            SEP #$20
.1a66ea	a9 4b		lda #$4b	                LDA #'K'
.1a66ec	20 18 00	jsr $1a0018	            JSR PRINTC
.1a66ef	c2 20		rep #$20	            REP #$20
.1a66f1	80 16		bra $1a6709	                BRA done
.1a66f3	a2 14 00	ldx #$0014	pr_mb           LDX #20                 ; Shift so the amount in MB is in ARGUMENT1
.1a66f6	46 25		lsr $0825	mb_shift        LSR ARGUMENT1+2
.1a66f8	66 23		ror $0823	                ROR ARGUMENT1
.1a66fa	ca		dex		                DEX
.1a66fb	d0 f9		bne $1a66f6	                BNE mb_shift
.1a66fd	20 46 44	jsr $1a4446	            JSR PR_INTEGER
.1a6700	e2 20		sep #$20	            SEP #$20
.1a6702	a9 4d		lda #$4d	                LDA #'M'
.1a6704	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6707	c2 20		rep #$20	            REP #$20
.1a6709	28		plp		done            PLP
.1a670a	2b		pld		                PLD
.1a670b	fa		plx		                PLX
.1a670c	60		rts		            RTS
.1a670d					CMD_DIR
.1a670d	0b		phd		                PHD
.1a670e	08		php		                PHP
.1a670f	c2 30		rep #$30	            REP #$30
.1a6711	a9 00 00	lda #$0000	                LDA #0                      ; Zero out the pagination line count
.1a6714	8f b6 08 00	sta $0008b6	                STA @l LINECOUNT
.1a6718	8f b8 08 00	sta $0008b8	                STA @l LINECOUNT+2
.1a671c	e2 20		sep #$20	            SEP #$20
.1a671e	20 f8 20	jsr $1a20f8	            JSR PEEK_TOK
.1a6721	c9 00		cmp #$00	                CMP #0
.1a6723	f0 08		beq $1a672d	                BEQ set_null                ; If none provided, set the path to empty
.1a6725	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a6728	20 ce 05	jsr $1a05ce	            JSR ASS_ARG1_STR
.1a672b	80 11		bra $1a673e	                BRA set_fd
.1a672d					set_null
.1a672d	c2 20		rep #$20	            REP #$20
.1a672f	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT1 to the NULL string
.1a6732	85 23		sta $0823	                STA ARGUMENT1
.1a6734	85 25		sta $0825	                STA ARGUMENT1+2
.1a6736	e2 20		sep #$20	            SEP #$20
.1a6738	a9 02		lda #$02	                LDA #TYPE_STRING
.1a673a	85 27		sta $0827	                STA ARGTYPE1
.1a673c	c2 20		rep #$20	            REP #$20
.1a673e					set_fd
.1a673e	20 6e 68	jsr $1a686e	            JSR SETFILEDESC
.1a6741	22 08 11 00	jsl $001108	                JSL FK_DIROPEN              ; Open up the directory
.1a6745	b0 22		bcs $1a6769	                BCS pr_first
.1a6747	20 1f 69	jsr $1a691f	            JSR SET_DOSSTAT
.1a674a	08		php		            PHP
.1a674b	c2 20		rep #$20	            REP #$20
.1a674d	48		pha		            PHA
.1a674e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6751	5b		tcd		            TCD
.1a6752	68		pla		            PLA
.1a6753	28		plp		            PLP
.1a6754	e2 20		sep #$20	            SEP #$20
.1a6756	a9 10		lda #$10	            LDA #ERR_DIRECTORY
.1a6758	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a675c	c2 20		rep #$20	            REP #$20
.1a675e	29 ff 00	and #$00ff	            AND #$00FF
.1a6761	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a6764	e2 20		sep #$20	            SEP #$20
.1a6766	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6769					pr_first
.1a6769	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a676c					pr_entry
.1a676c	08		php		            PHP
.1a676d	c2 20		rep #$20	            REP #$20
.1a676f	48		pha		            PHA
.1a6770	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.1a6773	5b		tcd		            TCD
.1a6774	68		pla		            PLA
.1a6775	28		plp		            PLP
.1a6776	e2 20		sep #$20	            SEP #$20
.1a6778	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Start with the file name
.1a677b	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the initial character of the name
.1a677d	d0 03		bne $1a6782	                BNE chk_unused
.1a677f	82 a9 00	brl $1a682b	                BRL done                    ; If it's NULL, we're done
.1a6782	c9 e5		cmp #$e5	chk_unused      CMP #DOS_DIR_ENT_UNUSED     ; Is it the unusued code?
.1a6784	d0 03		bne $1a6789	                BNE chk_attributes
.1a6786	82 96 00	brl $1a681f	                BRL next_entry              ; Yes: go to the next entry
.1a6789	a0 0b 00	ldy #$000b	chk_attributes  LDY #DIRENTRY.ATTRIBUTE
.1a678c	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute byte
.1a678e	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.1a6790	f0 03		beq $1a6795	                BEQ chk_hidden
.1a6792	82 a9 00	brl $1a683e	                BRL pr_volume               ; Print the volume label
.1a6795	89 02		bit #$02	chk_hidden      BIT #DOS_ATTR_HIDDEN        ; Is it a hidden file?
.1a6797	f0 03		beq $1a679c	                BEQ chk_long
.1a6799	82 83 00	brl $1a681f	                BRL next_entry              ; Yes: go to the next entry
.1a679c	29 0f		and #$0f	chk_long        AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.1a679e	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.1a67a0	d0 03		bne $1a67a5	                BNE get_short_name
.1a67a2	82 7a 00	brl $1a681f	                BRL next_entry              ; Yes: go to the next entry
.1a67a5	a0 00 00	ldy #$0000	get_short_name  LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.1a67a8	b7 18		lda [$0338],y	pr_name_loop    LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.1a67aa	20 18 00	jsr $1a0018	            JSR PRINTC
.1a67ad	c8		iny		                INY                         ; Move to the next character
.1a67ae	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.1a67b1	d0 f5		bne $1a67a8	                BNE pr_name_loop            ; No: print this new character
.1a67b3	a9 20		lda #$20	                LDA #' '                    ; Print the separator
.1a67b5	20 18 00	jsr $1a0018	            JSR PRINTC
.1a67b8	a0 08 00	ldy #$0008	                LDY #DIRENTRY.SHORTNAME+8   ; Move to the first of the extension characters
.1a67bb	b7 18		lda [$0338],y	pr_ext_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.1a67bd	20 18 00	jsr $1a0018	                JSR PRINTC                  ; Otherwise: print it.
.1a67c0	c8		iny		                INY                         ; Move to the next character
.1a67c1	c0 0b 00	cpy #$000b	                CPY #DIRENTRY.SHORTNAME+11  ; Are we at the end of the extension portion?
.1a67c4	d0 f5		bne $1a67bb	                BNE pr_ext_loop             ; No: print this new character
.1a67c6	a9 09		lda #$09	pr_tab1         LDA #CHAR_TAB               ; Print a TAB
.1a67c8	20 18 00	jsr $1a0018	            JSR PRINTC
.1a67cb	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.1a67ce	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.1a67d0	89 10		bit #$10	                BIT #DOS_ATTR_DIR           ; Is it a directory?
.1a67d2	d0 1e		bne $1a67f2	                BNE pr_attr                 ; Yes: skip printing a file size
.1a67d4	c2 20		rep #$20	            REP #$20
.1a67d6	a0 1c 00	ldy #$001c	                LDY #DIRENTRY.SIZE
.1a67d9	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the file size
.1a67db	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.1a67df	c8		iny		                INY
.1a67e0	c8		iny		                INY
.1a67e1	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y
.1a67e3	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.1a67e7	e2 20		sep #$20	            SEP #$20
.1a67e9	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a67eb	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.1a67ef	20 b4 66	jsr $1a66b4	            JSR PR_FILESIZE
.1a67f2	a9 09		lda #$09	pr_attr         LDA #CHAR_TAB               ; Print a TAB
.1a67f4	20 18 00	jsr $1a0018	            JSR PRINTC
.1a67f7	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.1a67fa	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.1a67fc	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.1a67fe	d0 1c		bne $1a681c	                BNE end_entry               ; Yes: we're done printing this entry
.1a6800	89 01		bit #$01	chk_read        BIT #DOS_ATTR_RO            ; Is it a read-only file?
.1a6802	f0 05		beq $1a6809	                BEQ chk_system
.1a6804	a9 52		lda #$52	                LDA #'R'                    ; Yes: print an R
.1a6806	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6809	89 04		bit #$04	chk_system      BIT #DOS_ATTR_SYSTEM        ; Is it System file?
.1a680b	f0 05		beq $1a6812	                BEQ chk_directory
.1a680d	a9 53		lda #$53	                LDA #'S'                    ; Yes: print an S
.1a680f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6812	89 10		bit #$10	chk_directory   BIT #DOS_ATTR_DIR           ; Is it a directory?
.1a6814	f0 05		beq $1a681b	                BEQ pr_tab2
.1a6816	a9 44		lda #$44	                LDA #'D'                    ; Yes: print a D
.1a6818	20 18 00	jsr $1a0018	            JSR PRINTC
.1a681b	ea		nop		pr_tab2         NOP
.1a681c					end_entry
.1a681c	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a681f					next_entry
.1a681f	20 d9 02	jsr $1a02d9	            JSR PAGINATE
.1a6822	22 0c 11 00	jsl $00110c	                JSL FK_DIRNEXT
.1a6826	90 03		bcc $1a682b	                BCC done
.1a6828	82 41 ff	brl $1a676c	                BRL pr_entry
.1a682b					done
.1a682b	20 1f 69	jsr $1a691f	            JSR SET_DOSSTAT
.1a682e	08		php		            PHP
.1a682f	c2 20		rep #$20	            REP #$20
.1a6831	48		pha		            PHA
.1a6832	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6835	5b		tcd		            TCD
.1a6836	68		pla		            PLA
.1a6837	28		plp		            PLP
.1a6838	20 dc 1f	jsr $1a1fdc	            JSR SKIPSTMT
.1a683b	28		plp		                PLP
.1a683c	2b		pld		                PLD
.1a683d	60		rts		            RTS
.1a683e					pr_volume
.1a683e	08		php		            PHP
.1a683f	c2 20		rep #$20	            REP #$20
.1a6841	48		pha		            PHA
.1a6842	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.1a6845	5b		tcd		            TCD
.1a6846	68		pla		            PLA
.1a6847	28		plp		            PLP
.1a6848	e2 20		sep #$20	            SEP #$20
.1a684a	29 0f		and #$0f	                AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.1a684c	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.1a684e	f0 cf		beq $1a681f	                BEQ next_entry              ; Yes: skip it
.1a6850	a9 5b		lda #$5b	pr_lbracket     LDA #'['
.1a6852	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6855	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.1a6858	b7 18		lda [$0338],y	pr_vol_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.1a685a	c9 20		cmp #$20	                CMP #CHAR_SP                ; Is it a blank?
.1a685c	f0 09		beq $1a6867	                BEQ pr_rbracket             ; Yes: end the name and print the dot
.1a685e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6861	c8		iny		                INY                         ; Move to the next character
.1a6862	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.1a6865	d0 f1		bne $1a6858	                BNE pr_vol_loop             ; No: print this new character
.1a6867	a9 5d		lda #$5d	pr_rbracket     LDA #']'                    ; Print a close bracket
.1a6869	20 18 00	jsr $1a0018	            JSR PRINTC
.1a686c	80 ae		bra $1a681c	                BRA end_entry               ; And try to get the next entry
.1a686e					SETFILEDESC
.1a686e	0b		phd		                PHD
.1a686f	08		php		                PHP
.1a6870	08		php		            PHP
.1a6871	c2 20		rep #$20	            REP #$20
.1a6873	48		pha		            PHA
.1a6874	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.1a6877	5b		tcd		            TCD
.1a6878	68		pla		            PLA
.1a6879	28		plp		            PLP
.1a687a	c2 30		rep #$30	            REP #$30
.1a687c	a9 73 f2	lda #$f273	                LDA #<>FD_IN            ; Point to the file descriptor
.1a687f	85 20		sta $0340	                STA DOS_FD_PTR
.1a6881	a9 1a 00	lda #$001a	                LDA #`FD_IN
.1a6884	85 22		sta $0342	                STA DOS_FD_PTR+2
.1a6886	a0 00 00	ldy #$0000	                LDY #0                  ; Fille the file descriptor with 0
.1a6889	e2 20		sep #$20	            SEP #$20
.1a688b	a9 00		lda #$00	                LDA #0
.1a688d	97 20		sta [$0340],y	zero_loop       STA [DOS_FD_PTR],Y
.1a688f	c8		iny		                INY
.1a6890	c0 1e 00	cpy #$001e	                CPY #SIZE(FILEDESC)
.1a6893	d0 f8		bne $1a688d	                BNE zero_loop
.1a6895	c2 20		rep #$20	            REP #$20
.1a6897	a9 73 f0	lda #$f073	                LDA #<>CLUSTER_BUFF     ; Point to the cluster buffer
.1a689a	8f 81 f2 1a	sta $1af281	                STA @l FD_IN.BUFFER
.1a689e	a9 1a 00	lda #$001a	                LDA #`CLUSTER_BUFF
.1a68a1	8f 83 f2 1a	sta $1af283	                STA @l FD_IN.BUFFER+2
.1a68a5	af 23 08 00	lda $000823	                LDA @l ARGUMENT1        ; Point the file desriptor to the path
.1a68a9	8f 75 f2 1a	sta $1af275	                STA @l FD_IN.PATH
.1a68ad	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a68b1	8f 77 f2 1a	sta $1af277	                STA @l FD_IN.PATH+2
.1a68b5	28		plp		                PLP
.1a68b6	2b		pld		                PLD
.1a68b7	60		rts		            RTS
.1a68b8					S_BLOAD
.1a68b8	08		php		                PHP
.1a68b9	c2 30		rep #$30	            REP #$30
.1a68bb	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a68be	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a68c1	20 ce 05	jsr $1a05ce	            JSR ASS_ARG1_STR
.1a68c4	20 6e 68	jsr $1a686e	            JSR SETFILEDESC
.1a68c7	e2 20		sep #$20	            SEP #$20
.1a68c9	a9 2c		lda #$2c	                LDA #','
.1a68cb	85 37		sta $0837	                STA TARGETTOK
.1a68cd	20 d9 20	jsr $1a20d9	            JSR OPT_TOK
.1a68d0	b0 0f		bcs $1a68e1	                BCS get_dest
.1a68d2	c2 20		rep #$20	            REP #$20
.1a68d4	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set destination address to something "safe"
.1a68d7	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a68db	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a68df	80 17		bra $1a68f8	                BRA do_load
.1a68e1					get_dest
.1a68e1	20 97 1f	jsr $1a1f97	            JSR INCBIP
.1a68e4	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a68e7	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a68ea	c2 20		rep #$20	            REP #$20
.1a68ec	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the destination address
.1a68ee	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a68f2	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a68f4	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a68f8	22 18 11 00	jsl $001118	do_load         JSL FK_LOAD                 ; Attempt to load the file
.1a68fc	b0 1f		bcs $1a691d	                BCS done
.1a68fe	08		php		            PHP
.1a68ff	c2 20		rep #$20	            REP #$20
.1a6901	48		pha		            PHA
.1a6902	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6905	5b		tcd		            TCD
.1a6906	68		pla		            PLA
.1a6907	28		plp		            PLP
.1a6908	e2 20		sep #$20	            SEP #$20
.1a690a	a9 11		lda #$11	            LDA #ERR_LOAD
.1a690c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6910	c2 20		rep #$20	            REP #$20
.1a6912	29 ff 00	and #$00ff	            AND #$00FF
.1a6915	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a6918	e2 20		sep #$20	            SEP #$20
.1a691a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a691d	28		plp		done            PLP
.1a691e	60		rts		            RTS
.1a691f					SET_DOSSTAT
.1a691f	8b		phb		                PHB
.1a6920	0b		phd		                PHD
.1a6921	08		php		                PHP
.1a6922	08		php		            PHP
.1a6923	c2 20		rep #$20	            REP #$20
.1a6925	48		pha		            PHA
.1a6926	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6929	5b		tcd		            TCD
.1a692a	68		pla		            PLA
.1a692b	28		plp		            PLP
.1a692c	08		php		            PHP
.1a692d	e2 20		sep #$20	            SEP #$20
.1a692f	48		pha		            PHA
.1a6930	a9 00		lda #$00	            LDA #BASIC_BANK
.1a6932	48		pha		            PHA
.1a6933	ab		plb		            PLB
.1a6934	68		pla		            PLA
.1a6935	28		plp		            PLP
.1a6936	e2 20		sep #$20	            SEP #$20
.1a6938	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS           ; Get the DOS status code
.1a693c	85 23		sta $0823	                STA ARGUMENT1
.1a693e	a9 00		lda #$00	                LDA #0
.1a6940	85 24		sta $0824	                STA ARGUMENT1+1
.1a6942	85 25		sta $0825	                STA ARGUMENT1+2
.1a6944	85 26		sta $0826	                STA ARGUMENT1+3
.1a6946	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a6948	85 27		sta $0827	                STA ARGTYPE1
.1a694a	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (DOSSTAT)
.1a694c	a9 1a		lda #$1a	                LDA #`dosstat_name
.1a694e	85 e9		sta $08e9	                STA TOFIND+2
.1a6950	c2 20		rep #$20	            REP #$20
.1a6952	a9 82 69	lda #$6982	                LDA #<>dosstat_name
.1a6955	85 e7		sta $08e7	                STA TOFIND
.1a6957	20 2f 51	jsr $1a512f	            JSR VAR_SET
.1a695a	e2 20		sep #$20	            SEP #$20
.1a695c	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS          ; Get the BIOS status code
.1a6960	85 23		sta $0823	                STA ARGUMENT1
.1a6962	a9 00		lda #$00	                LDA #0
.1a6964	85 24		sta $0824	                STA ARGUMENT1+1
.1a6966	85 25		sta $0825	                STA ARGUMENT1+2
.1a6968	85 26		sta $0826	                STA ARGUMENT1+3
.1a696a	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a696c	85 27		sta $0827	                STA ARGTYPE1
.1a696e	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BIOSSTAT)
.1a6970	a9 1a		lda #$1a	                LDA #`biosstat_name
.1a6972	85 e9		sta $08e9	                STA TOFIND+2
.1a6974	c2 20		rep #$20	            REP #$20
.1a6976	a9 8a 69	lda #$698a	                LDA #<>biosstat_name
.1a6979	85 e7		sta $08e7	                STA TOFIND
.1a697b	20 2f 51	jsr $1a512f	            JSR VAR_SET
.1a697e	28		plp		                PLP
.1a697f	2b		pld		                PLD
.1a6980	ab		plb		                PLB
.1a6981	60		rts		            RTS
>1a6982	44 4f 53 53 54 41 54 00		dosstat_name    .null "DOSSTAT"
>1a698a	42 49 4f 53 53 54 41 54		biosstat_name   .null "BIOSSTAT"
>1a6992	00
.1a6993					CMD_BRUN
.1a6993	08		php		                PHP
.1a6994	c2 30		rep #$30	            REP #$30
.1a6996	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a6999	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a699c	20 ce 05	jsr $1a05ce	            JSR ASS_ARG1_STR
.1a699f	a5 23		lda $0823	                LDA ARGUMENT1
.1a69a1	8f 60 03 00	sta $000360	                STA @l DOS_RUN_PARAM
.1a69a5	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a69a7	8f 62 03 00	sta $000362	                STA @l DOS_RUN_PARAM+2
.1a69ab	a9 ff ff	lda #$ffff	                LDA #$FFFF
.1a69ae	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a69b2	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a69b6	22 24 11 00	jsl $001124	                JSL FK_RUN                  ; Attempt to run the file
.1a69ba	b0 25		bcs $1a69e1	                BCS done                    ; If we got it: try to execute it
.1a69bc	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a69bf	20 1f 69	jsr $1a691f	            JSR SET_DOSSTAT
.1a69c2	08		php		            PHP
.1a69c3	c2 20		rep #$20	            REP #$20
.1a69c5	48		pha		            PHA
.1a69c6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a69c9	5b		tcd		            TCD
.1a69ca	68		pla		            PLA
.1a69cb	28		plp		            PLP
.1a69cc	e2 20		sep #$20	            SEP #$20
.1a69ce	a9 11		lda #$11	            LDA #ERR_LOAD
.1a69d0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a69d4	c2 20		rep #$20	            REP #$20
.1a69d6	29 ff 00	and #$00ff	            AND #$00FF
.1a69d9	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a69dc	e2 20		sep #$20	            SEP #$20
.1a69de	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a69e1					done
.1a69e1	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a69e4	28		plp		                PLP
.1a69e5	60		rts		            RTS
.1a69e6					CMD_LOAD
.1a69e6	08		php		                PHP
.1a69e7	c2 30		rep #$30	            REP #$30
.1a69e9	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a69ec	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a69ef	20 ce 05	jsr $1a05ce	            JSR ASS_ARG1_STR
.1a69f2	20 6e 68	jsr $1a686e	            JSR SETFILEDESC
.1a69f5	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.1a69f8	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a69fc	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.1a69ff	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2        ; Set the destination address
.1a6a03	20 00 4e	jsr $1a4e00	            JSR CMD_NEW
.1a6a06	22 18 11 00	jsl $001118	                JSL FK_LOAD                 ; Attempt to load the file
.1a6a0a	b0 22		bcs $1a6a2e	                BCS start_tokenize          ; If we got it: start tokenizing
.1a6a0c	20 1f 69	jsr $1a691f	            JSR SET_DOSSTAT
.1a6a0f	08		php		            PHP
.1a6a10	c2 20		rep #$20	            REP #$20
.1a6a12	48		pha		            PHA
.1a6a13	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6a16	5b		tcd		            TCD
.1a6a17	68		pla		            PLA
.1a6a18	28		plp		            PLP
.1a6a19	e2 20		sep #$20	            SEP #$20
.1a6a1b	a9 11		lda #$11	            LDA #ERR_LOAD
.1a6a1d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6a21	c2 20		rep #$20	            REP #$20
.1a6a23	29 ff 00	and #$00ff	            AND #$00FF
.1a6a26	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a6a29	e2 20		sep #$20	            SEP #$20
.1a6a2b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6a2e					start_tokenize
.1a6a2e	20 1f 69	jsr $1a691f	            JSR SET_DOSSTAT
.1a6a31	c2 20		rep #$20	            REP #$20
.1a6a33	a2 12 00	ldx #$0012	                LDX #FILEDESC.FILESIZE
.1a6a36	18		clc		                CLC                         ; Set MTEMP to point to the byte after the file
.1a6a37	bf 73 f2 1a	lda $1af273,x	                LDA FD_IN,X
.1a6a3b	69 00 00	adc #$0000	                ADC #<>LOADBLOCK
.1a6a3e	85 92		sta $0892	                STA MTEMP
.1a6a40	bf 75 f2 1a	lda $1af275,x	                LDA FD_IN+2,X
.1a6a44	69 01 00	adc #$0001	                ADC #`LOADBLOCK
.1a6a47	85 94		sta $0894	                STA MTEMP+2
.1a6a49	e2 20		sep #$20	            SEP #$20
.1a6a4b	a9 00		lda #$00	                LDA #0
.1a6a4d	87 92		sta [$0892]	                STA [MTEMP]                 ; Write a NULL right after the file
.1a6a4f	c2 20		rep #$20	            REP #$20
.1a6a51	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK            ; Set MCURSOR to the begining of the loaded data
.1a6a54	85 7a		sta $087a	                STA MCURSOR
.1a6a56	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.1a6a59	85 7c		sta $087c	                STA MCURSOR+2
.1a6a5b	a2 00 00	ldx #$0000	copy_line       LDX #0
.1a6a5e					copy_char
.1a6a5e	e2 20		sep #$20	            SEP #$20
.1a6a60	a7 7a		lda [$087a]	                LDA [MCURSOR]
.1a6a62	f0 2a		beq $1a6a8e	                BEQ clean_up                ; If the character is 0, we're done
.1a6a64	c9 0d		cmp #$0d	                CMP #CHAR_CR                ; If it is new line...
.1a6a66	f0 12		beq $1a6a7a	                BEQ do_process              ; ... we want to process the line
.1a6a68	c9 0a		cmp #$0a	                CMP #CHAR_LF                ; If it is a line feed...
.1a6a6a	f0 04		beq $1a6a70	                BEQ next_char               ; ... we want to skip it
.1a6a6c	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X              ; Otherwise, copy the character to the input buffer
.1a6a6f	e8		inx		                INX
.1a6a70					next_char
.1a6a70	c2 20		rep #$20	            REP #$20
.1a6a72	e6 7a		inc $087a	                INC MCURSOR                 ; Advance the input cursor
.1a6a74	d0 e8		bne $1a6a5e	                BNE copy_char
.1a6a76	e6 7c		inc $087c	                INC MCURSOR+2
.1a6a78	80 e4		bra $1a6a5e	                BRA copy_char
.1a6a7a					do_process
.1a6a7a	e2 20		sep #$20	            SEP #$20
.1a6a7c	a9 00		lda #$00	                LDA #0                      ; Put a 0 at the end of the input buffer
.1a6a7e	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a6a81	20 04 26	jsr $1a2604	            JSR PROCESS
.1a6a84	c2 20		rep #$20	            REP #$20
.1a6a86	e6 7a		inc $087a	                INC MCURSOR                 ; Try again with the next line
.1a6a88	d0 d1		bne $1a6a5b	                BNE copy_line
.1a6a8a	e6 7c		inc $087c	                INC MCURSOR+2
.1a6a8c	80 cd		bra $1a6a5b	                BRA copy_line
.1a6a8e	e0 00 00	cpx #$0000	clean_up        CPX #0                      ; Is there data in the INPUTBUF?
.1a6a91	f0 0a		beq $1a6a9d	                BEQ done                    ; No: just return
.1a6a93	e2 20		sep #$20	            SEP #$20
.1a6a95	a9 00		lda #$00	                LDA #0                      ; Make sure there is a trailing NULL
.1a6a97	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a6a9a	20 04 26	jsr $1a2604	            JSR PROCESS
.1a6a9d	28		plp		done            PLP
.1a6a9e	60		rts		            RTS
.1a6a9f					S_BSAVE
.1a6a9f	08		php		                PHP
.1a6aa0	c2 30		rep #$30	            REP #$30
.1a6aa2	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a6aa5	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a6aa8	20 ce 05	jsr $1a05ce	            JSR ASS_ARG1_STR
.1a6aab	20 6e 68	jsr $1a686e	            JSR SETFILEDESC
.1a6aae	e2 20		sep #$20	            SEP #$20
.1a6ab0	a9 2c		lda #$2c	                LDA #','
.1a6ab2	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a6ab5	c2 20		rep #$20	            REP #$20
.1a6ab7	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a6aba	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a6abd	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_SRC_PTR
.1a6abf	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.1a6ac3	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6ac5	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.1a6ac9	e2 20		sep #$20	            SEP #$20
.1a6acb	a9 2c		lda #$2c	                LDA #','
.1a6acd	c2 20		rep #$20	            REP #$20
.1a6acf	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a6ad2	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a6ad5	20 3c 05	jsr $1a053c	            JSR ASS_ARG1_INT
.1a6ad8	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_END_PTR
.1a6ada	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.1a6ade	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6ae0	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.1a6ae4	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                 ; Attempt to save the memory to file.
.1a6ae8	b0 22		bcs $1a6b0c	                BCS done
.1a6aea	20 1f 69	jsr $1a691f	            JSR SET_DOSSTAT
.1a6aed	08		php		            PHP
.1a6aee	c2 20		rep #$20	            REP #$20
.1a6af0	48		pha		            PHA
.1a6af1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6af4	5b		tcd		            TCD
.1a6af5	68		pla		            PLA
.1a6af6	28		plp		            PLP
.1a6af7	e2 20		sep #$20	            SEP #$20
.1a6af9	a9 12		lda #$12	            LDA #ERR_SAVE
.1a6afb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6aff	c2 20		rep #$20	            REP #$20
.1a6b01	29 ff 00	and #$00ff	            AND #$00FF
.1a6b04	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a6b07	e2 20		sep #$20	            SEP #$20
.1a6b09	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6b0c					done
.1a6b0c	20 1f 69	jsr $1a691f	            JSR SET_DOSSTAT
.1a6b0f	28		plp		                PLP
.1a6b10	60		rts		            RTS
.1a6b11					COPY2PATHBUF
.1a6b11	da		phx		                PHX
.1a6b12	5a		phy		                PHY
.1a6b13	08		php		                PHP
.1a6b14	a2 00 00	ldx #$0000	                LDX #0
.1a6b17	a0 00 00	ldy #$0000	                LDY #0
.1a6b1a	e2 20		sep #$20	            SEP #$20
.1a6b1c	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y           ; Copy the path to the DOS_PATH_BUFF
.1a6b1e	9d 00 04	sta $0400,x	                STA DOS_PATH_BUFF,X
.1a6b21	f0 04		beq $1a6b27	                BEQ done
.1a6b23	e8		inx		                INX
.1a6b24	c8		iny		                INY
.1a6b25	80 f5		bra $1a6b1c	                BRA loop
.1a6b27	28		plp		done            PLP
.1a6b28	7a		ply		                PLY
.1a6b29	fa		plx		                PLX
.1a6b2a	60		rts		            RTS
.1a6b2b					CMD_SAVE
.1a6b2b	08		php		                PHP
.1a6b2c	c2 30		rep #$30	            REP #$30
.1a6b2e	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a6b31	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a6b34	20 ce 05	jsr $1a05ce	            JSR ASS_ARG1_STR
.1a6b37	20 6e 68	jsr $1a686e	            JSR SETFILEDESC
.1a6b3a	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.1a6b3d	85 a6		sta $08a6	                STA OBUFFER
.1a6b3f	e2 20		sep #$20	            SEP #$20
.1a6b41	a9 01		lda #$01	                LDA #`LOADBLOCK
.1a6b43	85 a8		sta $08a8	                STA OBUFFER+2
.1a6b45	a9 20		lda #$20	                LDA #DEV_BUFFER             ; Set up output for the buffer
.1a6b47	85 b4		sta $08b4	                STA BCONSOLE
.1a6b49	c2 20		rep #$20	            REP #$20
.1a6b4b	a9 00 00	lda #$0000	                LDA #0
.1a6b4e	85 ab		sta $08ab	                STA OBUFFIDX
.1a6b50	a9 ff ff	lda #$ffff	                LDA #$FFFF
.1a6b53	85 a9		sta $08a9	                STA OBUFFSIZE
.1a6b55	c2 20		rep #$20	            REP #$20
.1a6b57	a9 00 00	lda #$0000	                LDA #0                      ; Set start line number to 0
.1a6b5a	85 55		sta $0855	                STA MARG1
.1a6b5c	85 57		sta $0857	                STA MARG1+2
.1a6b5e	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set end line number to MAXINT
.1a6b61	85 59		sta $0859	                STA MARG2
.1a6b63	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.1a6b66	85 5b		sta $085b	                STA MARG2+2
.1a6b68	20 49 17	jsr $1a1749	            JSR LISTPROG
.1a6b6b	e2 20		sep #$20	            SEP #$20
.1a6b6d	a9 80		lda #$80	                LDA #DEV_SCREEN             ; Restore output to the screen
.1a6b6f	85 b4		sta $08b4	                STA BCONSOLE
.1a6b71	c2 20		rep #$20	            REP #$20
.1a6b73	c6 ab		dec $08ab	                DEC OBUFFIDX                ; OBUFFIDX points to the next free byte... so pull it in one
.1a6b75	18		clc		                CLC                         ; Set the range of memory to save
.1a6b76	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.1a6b79	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.1a6b7d	65 ab		adc $08ab	                ADC OBUFFIDX
.1a6b7f	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.1a6b83	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.1a6b86	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.1a6b8a	69 00 00	adc #$0000	                ADC #0
.1a6b8d	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.1a6b91	22 1c 11 00	jsl $00111c	do_save         JSL FK_SAVE                 ; Attempt to save the file
.1a6b95	b0 22		bcs $1a6bb9	                BCS done
.1a6b97	20 1f 69	jsr $1a691f	            JSR SET_DOSSTAT
.1a6b9a	08		php		            PHP
.1a6b9b	c2 20		rep #$20	            REP #$20
.1a6b9d	48		pha		            PHA
.1a6b9e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6ba1	5b		tcd		            TCD
.1a6ba2	68		pla		            PLA
.1a6ba3	28		plp		            PLP
.1a6ba4	e2 20		sep #$20	            SEP #$20
.1a6ba6	a9 12		lda #$12	            LDA #ERR_SAVE
.1a6ba8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6bac	c2 20		rep #$20	            REP #$20
.1a6bae	29 ff 00	and #$00ff	            AND #$00FF
.1a6bb1	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a6bb4	e2 20		sep #$20	            SEP #$20
.1a6bb6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6bb9					done
.1a6bb9	20 1f 69	jsr $1a691f	            JSR SET_DOSSTAT
.1a6bbc	28		plp		                PLP
.1a6bbd	60		rts		            RTS
.1a6bbe					S_DEL
.1a6bbe	08		php		                PHP
.1a6bbf	c2 30		rep #$30	            REP #$30
.1a6bc1	20 b8 1f	jsr $1a1fb8	            JSR SKIPWS
.1a6bc4	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a6bc7	20 ce 05	jsr $1a05ce	            JSR ASS_ARG1_STR
.1a6bca	20 11 6b	jsr $1a6b11	            JSR COPY2PATHBUF
.1a6bcd	22 04 11 00	jsl $001104	path_loaded     JSL FK_DELETE               ; Try to delete the file
.1a6bd1	b0 22		bcs $1a6bf5	                BCS done
.1a6bd3	20 1f 69	jsr $1a691f	            JSR SET_DOSSTAT
.1a6bd6	08		php		            PHP
.1a6bd7	c2 20		rep #$20	            REP #$20
.1a6bd9	48		pha		            PHA
.1a6bda	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6bdd	5b		tcd		            TCD
.1a6bde	68		pla		            PLA
.1a6bdf	28		plp		            PLP
.1a6be0	e2 20		sep #$20	            SEP #$20
.1a6be2	a9 13		lda #$13	            LDA #ERR_DELETE
.1a6be4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6be8	c2 20		rep #$20	            REP #$20
.1a6bea	29 ff 00	and #$00ff	            AND #$00FF
.1a6bed	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a6bf0	e2 20		sep #$20	            SEP #$20
.1a6bf2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6bf5					done
.1a6bf5	20 1f 69	jsr $1a691f	            JSR SET_DOSSTAT
.1a6bf8	28		plp		                PLP
.1a6bf9	60		rts		            RTS
.1a6bfa					VALIDFILECHAR
.1a6bfa	da		phx		                PHX
.1a6bfb	08		php		                PHP
.1a6bfc	e2 20		sep #$20	            SEP #$20
.1a6bfe	c9 61		cmp #$61	                CMP #'a'                    ; Is it lower case?
.1a6c00	90 08		bcc $1a6c0a	                BLT chk_space
.1a6c02	c9 7b		cmp #$7b	                CMP #'z'+1
.1a6c04	b0 04		bcs $1a6c0a	                BGE chk_space
.1a6c06	29 df		and #$df	                AND #%11011111              ; Yes: convert to upper case
.1a6c08	80 13		bra $1a6c1d	                BRA ret_valid
.1a6c0a	c9 20		cmp #$20	chk_space       CMP #CHAR_SP            ; Is it a control code?
.1a6c0c	90 13		bcc $1a6c21	                BLT is_invalid          ; Yes: it's invalid
.1a6c0e	a2 00 00	ldx #$0000	                LDX #0                  ; See if it's in the list of invalids
.1a6c11	df 25 6c 1a	cmp $1a6c25,x	loop            CMP invalid_chars,X
.1a6c15	f0 0a		beq $1a6c21	                BEQ is_invalid
.1a6c17	e8		inx		                INX
.1a6c18	e0 0f 00	cpx #$000f	                CPX #15                 ; # of invalid characters
.1a6c1b	d0 f4		bne $1a6c11	                BNE loop
.1a6c1d	28		plp		ret_valid       PLP
.1a6c1e	38		sec		                SEC
.1a6c1f	fa		plx		                PLX
.1a6c20	6b		rtl		                RTL
.1a6c21	28		plp		is_invalid      PLP
.1a6c22	18		clc		                CLC
.1a6c23	fa		plx		                PLX
.1a6c24	6b		rtl		                RTL
>1a6c25	2a 2b 2c 2f 3a 3b 3c 3d		invalid_chars   .text "*+,/:;<=>?\[]|",CHAR_DQUOTE
>1a6c2d	3e 3f 5c 5b 5d 7c 22
.1a6c34					S_RENAME
.1a6c34	08		php		                PHP
.1a6c35	08		php		            PHP
.1a6c36	c2 20		rep #$20	            REP #$20
.1a6c38	48		pha		            PHA
.1a6c39	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6c3c	5b		tcd		            TCD
.1a6c3d	68		pla		            PLA
.1a6c3e	28		plp		            PLP
.1a6c3f	c2 30		rep #$30	            REP #$30
.1a6c41	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a6c44	20 ce 05	jsr $1a05ce	            JSR ASS_ARG1_STR
.1a6c47	20 11 6b	jsr $1a6b11	            JSR COPY2PATHBUF
.1a6c4a	22 10 11 00	jsl $001110	                JSL FK_DIRREAD              ; Try to read the file
.1a6c4e	b0 22		bcs $1a6c72	                BCS get_new_name            ; If ok: get the new name
.1a6c50	20 1f 69	jsr $1a691f	            JSR SET_DOSSTAT
.1a6c53	08		php		            PHP
.1a6c54	c2 20		rep #$20	            REP #$20
.1a6c56	48		pha		            PHA
.1a6c57	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6c5a	5b		tcd		            TCD
.1a6c5b	68		pla		            PLA
.1a6c5c	28		plp		            PLP
.1a6c5d	e2 20		sep #$20	            SEP #$20
.1a6c5f	a9 14		lda #$14	            LDA #ERR_FILENOTFOUND
.1a6c61	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6c65	c2 20		rep #$20	            REP #$20
.1a6c67	29 ff 00	and #$00ff	            AND #$00FF
.1a6c6a	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a6c6d	e2 20		sep #$20	            SEP #$20
.1a6c6f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6c72					get_new_name
.1a6c72	e2 20		sep #$20	            SEP #$20
.1a6c74	a9 2c		lda #$2c	                LDA #','
.1a6c76	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a6c79	c2 20		rep #$20	            REP #$20
.1a6c7b	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a6c7e	20 ce 05	jsr $1a05ce	            JSR ASS_ARG1_STR
.1a6c81	ad 38 03	lda $0338	                LDA DOS_DIR_PTR
.1a6c84	85 08		sta $0808	                STA INDEX
.1a6c86	ad 3a 03	lda $033a	                LDA DOS_DIR_PTR+2
.1a6c89	85 0a		sta $080a	                STA INDEX+2
.1a6c8b	e2 20		sep #$20	            SEP #$20
.1a6c8d	a2 00 00	ldx #$0000	                LDX #0
.1a6c90	a9 20		lda #$20	                LDA #CHAR_SP                ; We'll use MLINEBUFF as temporary name storage
.1a6c92	95 7e		sta $087e,x	blank_loop      STA MLINEBUF,X              ; Fill it with blanks
.1a6c94	e8		inx		                INX
.1a6c95	e0 0b 00	cpx #$000b	                CPX #11
.1a6c98	d0 f8		bne $1a6c92	                BNE blank_loop
.1a6c9a	a2 00 00	ldx #$0000	                LDX #0
.1a6c9d	a0 00 00	ldy #$0000	                LDY #0
.1a6ca0	b7 23		lda [$0823],y	name_loop       LDA [ARGUMENT1],Y           ; Get the character of the new name
.1a6ca2	f0 76		beq $1a6d1a	                BEQ copy_short_name         ; If end-of-string: copy what we have
.1a6ca4	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.1a6ca6	f0 39		beq $1a6ce1	                BEQ skip_dot                ; Yes: move on to the extension characters
.1a6ca8	22 fa 6b 1a	jsl $1a6bfa	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.1a6cac	b0 1f		bcs $1a6ccd	                BCS save_nm_char
.1a6cae	08		php		            PHP
.1a6caf	c2 20		rep #$20	            REP #$20
.1a6cb1	48		pha		            PHA
.1a6cb2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6cb5	5b		tcd		            TCD
.1a6cb6	68		pla		            PLA
.1a6cb7	28		plp		            PLP
.1a6cb8	e2 20		sep #$20	            SEP #$20
.1a6cba	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a6cbc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6cc0	c2 20		rep #$20	            REP #$20
.1a6cc2	29 ff 00	and #$00ff	            AND #$00FF
.1a6cc5	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a6cc8	e2 20		sep #$20	            SEP #$20
.1a6cca	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6ccd	95 7e		sta $087e,x	save_nm_char    STA MLINEBUF,X              ; Otherwise: copy it
.1a6ccf	c8		iny		                INY
.1a6cd0	e8		inx		                INX
.1a6cd1	c0 08 00	cpy #$0008	                CPY #8
.1a6cd4	d0 ca		bne $1a6ca0	                BNE name_loop
.1a6cd6	b7 23		lda [$0823],y	eat_name        LDA [ARGUMENT1],Y           ; Get the character
.1a6cd8	f0 40		beq $1a6d1a	                BEQ copy_short_name         ; If null, we're done with the short name
.1a6cda	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.1a6cdc	f0 03		beq $1a6ce1	                BEQ skip_dot                ; Yes: skip over it
.1a6cde	c8		iny		                INY                         ; No: try again with the the next character
.1a6cdf	80 f5		bra $1a6cd6	                BRA eat_name
.1a6ce1	c8		iny		skip_dot        INY                         ; Character at Y is '.', so skip over it
.1a6ce2	a2 08 00	ldx #$0008	do_ext          LDX #8
.1a6ce5	b7 23		lda [$0823],y	ext_loop        LDA [ARGUMENT1],Y           ; Get the character of the new extension
.1a6ce7	f0 31		beq $1a6d1a	                BEQ copy_short_name         ; If end-of-string: copy what we have
.1a6ce9	22 fa 6b 1a	jsl $1a6bfa	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.1a6ced	b0 22		bcs $1a6d11	                BCS save_ext_char
.1a6cef	20 1f 69	jsr $1a691f	            JSR SET_DOSSTAT
.1a6cf2	08		php		            PHP
.1a6cf3	c2 20		rep #$20	            REP #$20
.1a6cf5	48		pha		            PHA
.1a6cf6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6cf9	5b		tcd		            TCD
.1a6cfa	68		pla		            PLA
.1a6cfb	28		plp		            PLP
.1a6cfc	e2 20		sep #$20	            SEP #$20
.1a6cfe	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a6d00	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6d04	c2 20		rep #$20	            REP #$20
.1a6d06	29 ff 00	and #$00ff	            AND #$00FF
.1a6d09	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a6d0c	e2 20		sep #$20	            SEP #$20
.1a6d0e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6d11	95 7e		sta $087e,x	save_ext_char   STA MLINEBUF,X              ; Otherwise: copy it
.1a6d13	c8		iny		                INY
.1a6d14	e8		inx		                INX
.1a6d15	c0 0c 00	cpy #$000c	                CPY #12
.1a6d18	d0 cb		bne $1a6ce5	                BNE ext_loop
.1a6d1a	a2 00 00	ldx #$0000	copy_short_name LDX #0                      ; Copy the short name we built to the directory entry
.1a6d1d	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME
.1a6d20	b5 7e		lda $087e,x	copy_loop       LDA MLINEBUF,X
.1a6d22	97 08		sta [$0808],y	                STA [INDEX],Y
.1a6d24	e8		inx		                INX
.1a6d25	c8		iny		                INY
.1a6d26	c0 0b 00	cpy #$000b	                CPY #11
.1a6d29	d0 f5		bne $1a6d20	                BNE copy_loop
.1a6d2b	22 14 11 00	jsl $001114	                JSL FK_DIRWRITE             ; Write the directory entry back
.1a6d2f	b0 22		bcs $1a6d53	                BCS done
.1a6d31	20 1f 69	jsr $1a691f	            JSR SET_DOSSTAT
.1a6d34	08		php		            PHP
.1a6d35	c2 20		rep #$20	            REP #$20
.1a6d37	48		pha		            PHA
.1a6d38	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6d3b	5b		tcd		            TCD
.1a6d3c	68		pla		            PLA
.1a6d3d	28		plp		            PLP
.1a6d3e	e2 20		sep #$20	            SEP #$20
.1a6d40	a9 15		lda #$15	            LDA #ERR_DIRNOTWRITE
.1a6d42	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6d46	c2 20		rep #$20	            REP #$20
.1a6d48	29 ff 00	and #$00ff	            AND #$00FF
.1a6d4b	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a6d4e	e2 20		sep #$20	            SEP #$20
.1a6d50	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6d53					done
.1a6d53	20 1f 69	jsr $1a691f	            JSR SET_DOSSTAT
.1a6d56	28		plp		                PLP
.1a6d57	60		rts		            RTS
.1a6d58					S_COPY
.1a6d58	08		php		                PHP
.1a6d59	08		php		            PHP
.1a6d5a	c2 20		rep #$20	            REP #$20
.1a6d5c	48		pha		            PHA
.1a6d5d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6d60	5b		tcd		            TCD
.1a6d61	68		pla		            PLA
.1a6d62	28		plp		            PLP
.1a6d63	c2 30		rep #$30	            REP #$30
.1a6d65	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a6d68	20 ce 05	jsr $1a05ce	            JSR ASS_ARG1_STR
.1a6d6b	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.1a6d6d	8f 64 03 00	sta $000364	                STA @l DOS_STR1_PTR
.1a6d71	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6d73	8f 66 03 00	sta $000366	                STA @l DOS_STR1_PTR+2
.1a6d77	e2 20		sep #$20	            SEP #$20
.1a6d79	a9 2c		lda #$2c	                LDA #','
.1a6d7b	20 a4 20	jsr $1a20a4	            JSR EXPECT_TOK
.1a6d7e	c2 20		rep #$20	            REP #$20
.1a6d80	20 86 1b	jsr $1a1b86	            JSR EVALEXPR
.1a6d83	20 ce 05	jsr $1a05ce	            JSR ASS_ARG1_STR
.1a6d86	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.1a6d88	8f 68 03 00	sta $000368	                STA @l DOS_STR2_PTR
.1a6d8c	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6d8e	8f 6a 03 00	sta $00036a	                STA @l DOS_STR2_PTR+2
.1a6d92	22 30 11 00	jsl $001130	                JSL FK_COPY                 ; Attempt to copy the file
.1a6d96	b0 1f		bcs $1a6db7	                BCS done
.1a6d98	08		php		            PHP
.1a6d99	c2 20		rep #$20	            REP #$20
.1a6d9b	48		pha		            PHA
.1a6d9c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6d9f	5b		tcd		            TCD
.1a6da0	68		pla		            PLA
.1a6da1	28		plp		            PLP
.1a6da2	e2 20		sep #$20	            SEP #$20
.1a6da4	a9 16		lda #$16	            LDA #ERR_NOTCOPIED
.1a6da6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6daa	c2 20		rep #$20	            REP #$20
.1a6dac	29 ff 00	and #$00ff	            AND #$00FF
.1a6daf	20 d8 1c	jsr $1a1cd8	            JSR SET_ERRERL
.1a6db2	e2 20		sep #$20	            SEP #$20
.1a6db4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6db7	28		plp		done            PLP
.1a6db8	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\monitor.s

.1a6db9	5c 79 87 1a	jmp $1a8779	MRETURN         JML IMRETURN
.1a6dbd	5c ca 85 1a	jmp $1a85ca	MPARSE          JML IMPARSE
.1a6dc1	5c 7a 87 1a	jmp $1a877a	MPARSE1         JML IMPARSE1
.1a6dc5	5c f6 76 1a	jmp $1a76f6	MEXECUTE        JML IMEXECUTE
.1a6dc9	5c 53 77 1a	jmp $1a7753	MASSEMBLE       JML IMASSEMBLE
.1a6dcd	5c 86 76 1a	jmp $1a7686	MRMODIFY        JML IMRMODIFY
.1a6dd1	5c 0c 76 1a	jmp $1a760c	MCOMPARE        JML IMCOMPARE
.1a6dd5	5c 89 7b 1a	jmp $1a7b89	MDISASSEMBLE    JML IMDISASSEMBLE
.1a6dd9	5c 77 72 1a	jmp $1a7277	MFILL           JML IMFILL
.1a6ddd	5c a4 75 1a	jmp $1a75a4	MGO             JML IMGO
.1a6de1	5c 5f 75 1a	jmp $1a755f	MJUMP           JML IMJUMP
.1a6de5	5c e9 74 1a	jmp $1a74e9	MHUNT           JML IMHUNT
.1a6de9	5c 88 86 1a	jmp $1a8688	MLOAD           JML IMLOAD
.1a6ded	5c 85 73 1a	jmp $1a7385	MMEMORY         JML IMMEMORY
.1a6df1	5c d8 71 1a	jmp $1a71d8	MREGISTERS      JML IMREGISTERS
.1a6df5	5c 03 87 1a	jmp $1a8703	MSAVE           JML IMSAVE
.1a6df9	5c b3 72 1a	jmp $1a72b3	MTRANSFER       JML IMTRANSFER
.1a6dfd	5c 7c 87 1a	jmp $1a877c	MVERIFY         JML IMVERIFY
.1a6e01	5c 75 87 1a	jmp $1a8775	MEXIT           JML IMEXIT
.1a6e05	5c a2 74 1a	jmp $1a74a2	MMODIFY         JML IMMODIFY
.1a6e09	5c 7d 87 1a	jmp $1a877d	MDOS            JML IMDOS
.1a6e0d	18		clc		IMONITOR        CLC                 ; clear the carry flag
.1a6e0e	fb		xce		                XCE                 ; move carry to emulation flags
.1a6e0f	c2 20		rep #$20	            REP #$20
.1a6e11	a9 ff fe	lda #$feff	                LDA #STACK_END      ; Reset the stack
.1a6e14	1b		tcs		                TAS
.1a6e15	58		cli		                CLI                 ; Re-enable interrupts
.1a6e16	5c 1a 6e 1a	jmp $1a6e1a	                JML IMREADY
.1a6e1a					IMREADY
.1a6e1a	c2 30		rep #$30	            REP #$30
.1a6e1c	22 d8 71 1a	jsl $1a71d8	                JSL IMREGISTERS
.1a6e20					ready_loop
.1a6e20	20 08 00	jsr $1a0008	            JSR READLINE
.1a6e23	20 0c 00	jsr $1a000c	            JSR SCRCOPYLINE
.1a6e26	8b		phb		                PHB
.1a6e27	e2 20		sep #$20	            SEP #$20
.1a6e29	a9 00		lda #$00	                LDA #`INPUTBUF
.1a6e2b	48		pha		                PHA
.1a6e2c	ab		plb		                PLB
.1a6e2d	a2 00 4f	ldx #$4f00	                LDX #<>INPUTBUF
.1a6e30	20 50 04	jsr $1a0450	            JSR TOUPPER
.1a6e33	ab		plb		                PLB
.1a6e34	22 bd 6d 1a	jsl $1a6dbd	                JSL MPARSE          ; Parse the command
.1a6e38	22 c5 6d 1a	jsl $1a6dc5	                JSL MEXECUTE        ; And execute the parsed command
.1a6e3c	80 e2		bra $1a6e20	                BRA ready_loop
.1a6e3e					IMHELP
.1a6e3e	08		php		                PHP
.1a6e3f	8b		phb		                PHB
.1a6e40	e2 20		sep #$20	            SEP #$20
.1a6e42	a9 1a		lda #$1a	                LDA #`help_text
.1a6e44	48		pha		                PHA
.1a6e45	ab		plb		                PLB
.1a6e46	c2 10		rep #$10	            REP #$10
.1a6e48	a2 51 6e	ldx #$6e51	                LDX #<>help_text
.1a6e4b	20 4f 03	jsr $1a034f	            JSR PRINTS
.1a6e4e	ab		plb		                PLB
.1a6e4f	28		plp		                PLP
.1a6e50	6b		rtl		                RTL
>1a6e51	41 20 3c 73 74 61 72 74		help_text       .text "A <start> <assembly>",CHAR_CR
>1a6e59	3e 20 3c 61 73 73 65 6d 62 6c 79 3e 0d
>1a6e66	20 20 41 73 73 65 6d 62		                .text "  Assemble a program",CHAR_CR,CHAR_CR
>1a6e6e	6c 65 20 61 20 70 72 6f 67 72 61 6d 0d 0d
>1a6e7c	43 20 3c 73 74 61 72 74		                .text "C <start1> <start2> [len (1 if blank)]",CHAR_CR
>1a6e84	31 3e 20 3c 73 74 61 72 74 32 3e 20 5b 6c 65 6e
>1a6e94	20 28 31 20 69 66 20 62 6c 61 6e 6b 29 5d 0d
>1a6ea3	20 20 43 6f 6d 70 61 72		                .text "  Compare to sections of memory",CHAR_CR,CHAR_CR
>1a6eab	65 20 74 6f 20 73 65 63 74 69 6f 6e 73 20 6f 66
>1a6ebb	20 6d 65 6d 6f 72 79 0d 0d
>1a6ec4	44 20 3c 73 74 61 72 74		                .text "D <start> [end]",CHAR_CR
>1a6ecc	3e 20 5b 65 6e 64 5d 0d
>1a6ed4	20 20 44 69 73 61 73 73		                .text "  Disassemble a program",CHAR_CR,CHAR_CR
>1a6edc	65 6d 62 6c 65 20 61 20 70 72 6f 67 72 61 6d 0d
>1a6eec	0d
>1a6eed	46 20 3c 73 74 61 72 74		                .text "F <start> <end> <byte>",CHAR_CR
>1a6ef5	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 0d
>1a6f04	20 20 46 69 6c 6c 20 61		                .text "  Fill a block of memory with a byte",CHAR_CR,CHAR_CR
>1a6f0c	20 62 6c 6f 63 6b 20 6f 66 20 6d 65 6d 6f 72 79
>1a6f1c	20 77 69 74 68 20 61 20 62 79 74 65 0d 0d
>1a6f2a	47 20 5b 61 64 64 72 65		                .text "G [address]",CHAR_CR
>1a6f32	73 73 5d 0d
>1a6f36	20 20 53 74 61 72 74 20		                .text "  Start execution at a location",CHAR_CR,CHAR_CR
>1a6f3e	65 78 65 63 75 74 69 6f 6e 20 61 74 20 61 20 6c
>1a6f4e	6f 63 61 74 69 6f 6e 0d 0d
>1a6f57	4a 20 5b 61 64 64 72 65		                .text "J [address] - Jump to a location in memory",CHAR_CR
>1a6f5f	73 73 5d 20 2d 20 4a 75 6d 70 20 74 6f 20 61 20
>1a6f6f	6c 6f 63 61 74 69 6f 6e 20 69 6e 20 6d 65 6d 6f
>1a6f7f	72 79 0d
>1a6f82	20 20 4a 75 6d 70 20 74		                .text "  Jump to a location in memory",CHAR_CR,CHAR_CR
>1a6f8a	6f 20 61 20 6c 6f 63 61 74 69 6f 6e 20 69 6e 20
>1a6f9a	6d 65 6d 6f 72 79 0d 0d
>1a6fa2	48 20 3c 73 74 61 72 74		                .text "H <start> <end> <byte> [byte]..",CHAR_CR
>1a6faa	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 20 5b
>1a6fba	62 79 74 65 5d 2e 2e 0d
>1a6fc2	20 20 48 75 6e 74 20 66		                .text "  Hunt for values in memory",CHAR_CR,CHAR_CR
>1a6fca	6f 72 20 76 61 6c 75 65 73 20 69 6e 20 6d 65 6d
>1a6fda	6f 72 79 0d 0d
>1a6fdf	4c 20 20 20 20 20 4c 4f		                .text "L     LOAD         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," [destination]",CHAR_CR
>1a6fe7	41 44 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>1a6ff7	22 20 5b 64 65 73 74 69 6e 61 74 69 6f 6e 5d 0d
>1a7007	4d 20 3c 73 74 61 72 74		                .text "M <start> [end]",CHAR_CR
>1a700f	3e 20 5b 65 6e 64 5d 0d
>1a7017	20 20 44 75 6d 70 20 74		                .text "  Dump the value in memory",CHAR_CR,CHAR_CR
>1a701f	68 65 20 76 61 6c 75 65 20 69 6e 20 6d 65 6d 6f
>1a702f	72 79 0d 0d
>1a7033	52 20 2d 20 44 69 73 70		                .text "R - Display the values of the registers",CHAR_CR,CHAR_CR
>1a703b	6c 61 79 20 74 68 65 20 76 61 6c 75 65 73 20 6f
>1a704b	66 20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d
>1a705b	0d
>1a705c	3b 20 3c 50 43 3e 20 3c		                .text "; <PC> <A> <X> <Y> <SP> <DBR> <DP> <NVMXDIZC>",CHAR_CR
>1a7064	41 3e 20 3c 58 3e 20 3c 59 3e 20 3c 53 50 3e 20
>1a7074	3c 44 42 52 3e 20 3c 44 50 3e 20 3c 4e 56 4d 58
>1a7084	44 49 5a 43 3e 0d
>1a708a	20 20 43 68 61 6e 67 65		                .text "  Change the contents of the registers",CHAR_CR,CHAR_CR
>1a7092	20 74 68 65 20 63 6f 6e 74 65 6e 74 73 20 6f 66
>1a70a2	20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d 0d
>1a70b2	53 20 20 20 20 20 53 41		                .text "S     SAVE         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," <start> <end>",CHAR_CR
>1a70ba	56 45 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>1a70ca	22 20 3c 73 74 61 72 74 3e 20 3c 65 6e 64 3e 0d
>1a70da	54 20 3c 73 74 61 72 74		                .text "T <start> <end> <destination>",CHAR_CR
>1a70e2	3e 20 3c 65 6e 64 3e 20 3c 64 65 73 74 69 6e 61
>1a70f2	74 69 6f 6e 3e 0d
>1a70f8	20 20 54 72 61 6e 73 66		                .text "  Transfer (copy) data within memory",CHAR_CR,CHAR_CR
>1a7100	65 72 20 28 63 6f 70 79 29 20 64 61 74 61 20 77
>1a7110	69 74 68 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>1a711e	57 20 3c 62 79 74 65 3e		                .text "W <byte>",CHAR_CR
>1a7126	0d
>1a7127	20 20 53 65 74 20 74 68		                .text "  Set the register width flags for the disassembler",CHAR_CR,CHAR_CR
>1a712f	65 20 72 65 67 69 73 74 65 72 20 77 69 64 74 68
>1a713f	20 66 6c 61 67 73 20 66 6f 72 20 74 68 65 20 64
>1a714f	69 73 61 73 73 65 6d 62 6c 65 72 0d 0d
>1a715c	58 20 2d 20 52 65 74 75		                .text "X - Return to BASIC",CHAR_CR,CHAR_CR
>1a7164	72 6e 20 74 6f 20 42 41 53 49 43 0d 0d
>1a7171	3e 20 3c 73 74 61 72 74		                .text "> <start> <byte> [byte]...",CHAR_CR
>1a7179	3e 20 3c 62 79 74 65 3e 20 5b 62 79 74 65 5d 2e
>1a7189	2e 2e 0d
>1a718c	20 20 45 64 69 74 20 64		                .text "  Edit data in memory",CHAR_CR,CHAR_CR
>1a7194	61 74 61 20 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>1a71a3	3f 20 2d 20 44 69 73 70		                .null "? - Display a short help screen",CHAR_CR,CHAR_CR
>1a71ab	6c 61 79 20 61 20 73 68 6f 72 74 20 68 65 6c 70
>1a71bb	20 73 63 72 65 65 6e 0d 0d 00
.1a71c5					IMWIDTH
.1a71c5	08		php		                PHP
.1a71c6	08		php		            PHP
.1a71c7	c2 20		rep #$20	            REP #$20
.1a71c9	48		pha		            PHA
.1a71ca	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a71cd	5b		tcd		            TCD
.1a71ce	68		pla		            PLA
.1a71cf	28		plp		            PLP
.1a71d0	e2 20		sep #$20	            SEP #$20
.1a71d2	a5 0d		lda $0855	                LDA MARG1
.1a71d4	85 4e		sta $0896	                STA MCPUSTAT
.1a71d6	28		plp		                PLP
.1a71d7	6b		rtl		                RTL
.1a71d8					IMREGISTERS
.1a71d8	20 1d 01	jsr $1a011d	            JSR ENSURETEXT
.1a71db	08		php		            PHP
.1a71dc	e2 20		sep #$20	            SEP #$20
.1a71de	48		pha		            PHA
.1a71df	a9 1a		lda #$1a	            LDA #`mregisters_msg
.1a71e1	48		pha		            PHA
.1a71e2	ab		plb		            PLB
.1a71e3	68		pla		            PLA
.1a71e4	28		plp		            PLP
.1a71e5	a2 ba 87	ldx #$87ba	                LDX #<>mregisters_msg
.1a71e8	20 4f 03	jsr $1a034f	            JSR PRINTS
.1a71eb	e2 20		sep #$20	            SEP #$20
.1a71ed	a9 3b		lda #$3b	                LDA #';'
.1a71ef	20 18 00	jsr $1a0018	            JSR PRINTC
.1a71f2	a9 20		lda #$20	                LDA #' '
.1a71f4	20 18 00	jsr $1a0018	            JSR PRINTC
.1a71f7	c2 30		rep #$30	            REP #$30
.1a71f9	08		php		            PHP
.1a71fa	e2 20		sep #$20	            SEP #$20
.1a71fc	48		pha		            PHA
.1a71fd	a9 00		lda #$00	            LDA #$0
.1a71ff	48		pha		            PHA
.1a7200	ab		plb		            PLB
.1a7201	68		pla		            PLA
.1a7202	28		plp		            PLP
.1a7203	a0 03 00	ldy #$0003	                LDY #3
.1a7206	a2 42 02	ldx #$0242	                LDX #CPUPC+2
.1a7209	20 d2 02	jsr $1a02d2	            JSR PRINTH
.1a720c	c2 20		rep #$20	            REP #$20
.1a720e	a9 20 00	lda #$0020	                LDA #' '
.1a7211	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7214	af 44 02 00	lda $000244	                LDA @lCPUA
.1a7218	20 5f 03	jsr $1a035f	            JSR PRHEXW
.1a721b	a9 20 00	lda #$0020	                LDA #' '
.1a721e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7221	af 46 02 00	lda $000246	                LDA @lCPUX
.1a7225	20 5f 03	jsr $1a035f	            JSR PRHEXW
.1a7228	a9 20 00	lda #$0020	                LDA #' '
.1a722b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a722e	af 48 02 00	lda $000248	                LDA @lCPUY
.1a7232	20 5f 03	jsr $1a035f	            JSR PRHEXW
.1a7235	a9 20 00	lda #$0020	                LDA #' '
.1a7238	20 18 00	jsr $1a0018	            JSR PRINTC
.1a723b	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK
.1a723f	20 5f 03	jsr $1a035f	            JSR PRHEXW
.1a7242	a9 20 00	lda #$0020	                LDA #' '
.1a7245	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7248	af 4e 02 00	lda $00024e	                LDA @lCPUDBR
.1a724c	20 79 03	jsr $1a0379	            JSR PRHEXB
.1a724f	a9 20 00	lda #$0020	                LDA #' '
.1a7252	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7255	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7258	af 4c 02 00	lda $00024c	                LDA @lCPUDP
.1a725c	20 5f 03	jsr $1a035f	            JSR PRHEXW
.1a725f	a9 20 00	lda #$0020	                LDA #' '
.1a7262	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7265	08		php		                PHP
.1a7266	e2 20		sep #$20	            SEP #$20
.1a7268	ad 4f 02	lda $024f	                LDA CPUFLAGS
.1a726b	22 d3 84 1a	jsl $1a84d3	                JSL MPRINTB
.1a726f	28		plp		                PLP
.1a7270	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a7273	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a7276	6b		rtl		                RTL
.1a7277					IMFILL
.1a7277	08		php		                PHP                 ; Save the caller's context
.1a7278	0b		phd		                PHD
.1a7279	08		php		            PHP
.1a727a	c2 20		rep #$20	            REP #$20
.1a727c	48		pha		            PHA
.1a727d	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7280	5b		tcd		            TCD
.1a7281	68		pla		            PLA
.1a7282	28		plp		            PLP
.1a7283					do_copy
.1a7283	e2 20		sep #$20	            SEP #$20
.1a7285	a5 15		lda $085d	                LDA MARG3
.1a7287	87 0d		sta [$0855]	                STA [MARG1]
.1a7289	e2 20		sep #$20	            SEP #$20
.1a728b	a5 0f		lda $0857	                LDA MARG1+2
.1a728d	c5 13		cmp $085b	                CMP MARG2+2
.1a728f	d0 0e		bne $1a729f	                BNE go_next         ; No: we haven't reached end address yet
.1a7291	c2 20		rep #$20	            REP #$20
.1a7293	a5 0d		lda $0855	                LDA MARG1
.1a7295	c5 11		cmp $0859	                CMP MARG2           ; Are they equal?
.1a7297	d0 06		bne $1a729f	                BNE go_next         ; No: we haven't reached end address yet
.1a7299	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a729c	2b		pld		                PLD                 ; Restore the caller's context
.1a729d	28		plp		                PLP
.1a729e	6b		rtl		                RTL
.1a729f					go_next
.1a729f	c2 20		rep #$20	            REP #$20
.1a72a1	18		clc		                CLC
.1a72a2	a5 0d		lda $0855	                LDA MARG1
.1a72a4	69 01 00	adc #$0001	                ADC #1
.1a72a7	85 0d		sta $0855	                STA MARG1
.1a72a9	e2 20		sep #$20	            SEP #$20
.1a72ab	a5 0e		lda $0856	                LDA MARG1+1
.1a72ad	69 00		adc #$00	                ADC #0
.1a72af	85 0e		sta $0856	                STA MARG1+1
.1a72b1	80 d0		bra $1a7283	                BRA do_copy
.1a72b3					IMTRANSFER
.1a72b3	08		php		                PHP
.1a72b4	0b		phd		                PHD
.1a72b5	08		php		            PHP
.1a72b6	c2 20		rep #$20	            REP #$20
.1a72b8	48		pha		            PHA
.1a72b9	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a72bc	5b		tcd		            TCD
.1a72bd	68		pla		            PLA
.1a72be	28		plp		            PLP
.1a72bf	e2 20		sep #$20	            SEP #$20
.1a72c1	a5 0f		lda $0857	                LDA MARG1+2
.1a72c3	c5 17		cmp $085f	                CMP MARG3+2
.1a72c5	90 45		bcc $1a730c	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.1a72c7	c2 20		rep #$20	            REP #$20
.1a72c9	a5 0d		lda $0855	                LDA MARG1
.1a72cb	c5 15		cmp $085d	                CMP MARG3
.1a72cd	90 3d		bcc $1a730c	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.1a72cf					copy_byte_down
.1a72cf	e2 20		sep #$20	            SEP #$20
.1a72d1	a7 0d		lda [$0855]	                LDA [MARG1]         ; Copy the byte
.1a72d3	87 15		sta [$085d]	                STA [MARG3]
.1a72d5	a5 0f		lda $0857	                LDA MARG1+2         ; Are the source's current and end bank bytes equal?
.1a72d7	c5 13		cmp $085b	                CMP MARG2+2
.1a72d9	d0 0b		bne $1a72e6	                BNE inc_pointers    ; No: we're not done yet
.1a72db	c2 20		rep #$20	            REP #$20
.1a72dd	a5 0d		lda $0855	                LDA MARG1           ; Are the rest of the bits equal?
.1a72df	c5 11		cmp $0859	                CMP MARG2
.1a72e1	d0 03		bne $1a72e6	                BNE inc_pointers    ; No: we're not done yet
.1a72e3	4c 6a 73	jmp $1a736a	                JMP done            ; Yes: we've copied the last byte, exit
.1a72e6					inc_pointers
.1a72e6	c2 20		rep #$20	            REP #$20
.1a72e8	18		clc		                CLC
.1a72e9	a5 0d		lda $0855	                LDA MARG1
.1a72eb	69 01 00	adc #$0001	                ADC #1
.1a72ee	85 0d		sta $0855	                STA MARG1
.1a72f0	e2 20		sep #$20	            SEP #$20
.1a72f2	a5 0e		lda $0856	                LDA MARG1+1
.1a72f4	69 00		adc #$00	                ADC #0
.1a72f6	85 0e		sta $0856	                STA MARG1+1
.1a72f8	c2 20		rep #$20	            REP #$20
.1a72fa	18		clc		                CLC
.1a72fb	a5 15		lda $085d	                LDA MARG3
.1a72fd	69 01 00	adc #$0001	                ADC #1
.1a7300	85 15		sta $085d	                STA MARG3
.1a7302	e2 20		sep #$20	            SEP #$20
.1a7304	a5 16		lda $085e	                LDA MARG3+1
.1a7306	69 00		adc #$00	                ADC #0
.1a7308	85 16		sta $085e	                STA MARG3+1
.1a730a	80 c3		bra $1a72cf	                BRA copy_byte_down  ; And copy that next byte over
.1a730c					copy_up
.1a730c	c2 20		rep #$20	            REP #$20
.1a730e	38		sec		                SEC
.1a730f	a5 11		lda $0859	                LDA MARG2
.1a7311	e5 0d		sbc $0855	                SBC MARG1
.1a7313	85 19		sta $0861	                STA MARG4
.1a7315	e2 20		sep #$20	            SEP #$20
.1a7317	a5 13		lda $085b	                LDA MARG2+2
.1a7319	e5 0f		sbc $0857	                SBC MARG1+2
.1a731b	85 1b		sta $0863	                STA MARG4+2
.1a731d	c2 20		rep #$20	            REP #$20
.1a731f	18		clc		                CLC
.1a7320	a5 19		lda $0861	                LDA MARG4
.1a7322	65 15		adc $085d	                ADC MARG3
.1a7324	85 15		sta $085d	                STA MARG3
.1a7326	e2 20		sep #$20	            SEP #$20
.1a7328	a5 1b		lda $0863	                LDA MARG4+2
.1a732a	65 17		adc $085f	                ADC MARG3+2
.1a732c	85 17		sta $085f	                STA MARG3+2
.1a732e					copy_byte_up
.1a732e	e2 20		sep #$20	            SEP #$20
.1a7330	a7 11		lda [$0859]	                LDA [MARG2]
.1a7332	87 15		sta [$085d]	                STA [MARG3]
.1a7334	a5 13		lda $085b	                LDA MARG2+2         ; Are the source's current and start bank bytes equal?
.1a7336	c5 0f		cmp $0857	                CMP MARG1+2
.1a7338	d0 0a		bne $1a7344	                BNE dec_pointers    ; No: we're not done yet
.1a733a	c2 20		rep #$20	            REP #$20
.1a733c	a5 11		lda $0859	                LDA MARG2           ; Are the rest of the bits equal?
.1a733e	c5 0d		cmp $0855	                CMP MARG1
.1a7340	d0 02		bne $1a7344	                BNE dec_pointers    ; No: we're not done yet
.1a7342	80 26		bra $1a736a	                BRA done            ; Yes: we've copied the last byte, exit
.1a7344					dec_pointers
.1a7344	c2 20		rep #$20	            REP #$20
.1a7346	38		sec		                SEC
.1a7347	a5 11		lda $0859	                LDA MARG2
.1a7349	e9 01 00	sbc #$0001	                SBC #1
.1a734c	85 11		sta $0859	                STA MARG2
.1a734e	e2 20		sep #$20	            SEP #$20
.1a7350	a5 12		lda $085a	                LDA MARG2+1
.1a7352	e9 00		sbc #$00	                SBC #0
.1a7354	85 12		sta $085a	                STA MARG2+1
.1a7356	c2 20		rep #$20	            REP #$20
.1a7358	38		sec		                SEC                 ; Decrement the current destination pointer (MARG3)
.1a7359	a5 15		lda $085d	                LDA MARG3
.1a735b	e9 01 00	sbc #$0001	                SBC #1
.1a735e	85 15		sta $085d	                STA MARG3
.1a7360	e2 20		sep #$20	            SEP #$20
.1a7362	a5 16		lda $085e	                LDA MARG3+1
.1a7364	e9 00		sbc #$00	                SBC #0
.1a7366	85 16		sta $085e	                STA MARG3+1
.1a7368	80 c4		bra $1a732e	                BRA copy_byte_up    ; And copy that next byte
.1a736a					done
.1a736a	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a736d	2b		pld		                PLD
.1a736e	28		plp		                PLP
.1a736f	6b		rtl		                RTL
.1a7370					IS_PRINTABLE
.1a7370	08		php		                PHP
.1a7371	e2 20		sep #$20	            SEP #$20
.1a7373	c9 21		cmp #$21	                CMP #33
.1a7375	90 0b		bcc $1a7382	                BLT not_printable   ; 0 .. 31 are not printable
.1a7377	c9 7f		cmp #$7f	                CMP #127
.1a7379	90 04		bcc $1a737f	                BLT printable       ; 32 .. 126 are printable
.1a737b	c9 a0		cmp #$a0	                CMP #160
.1a737d	90 03		bcc $1a7382	                BLT not_printable   ; 127 .. 159 are not printable (assuming Latin-1)
.1a737f	28		plp		printable       PLP
.1a7380	38		sec		                SEC
.1a7381	6b		rtl		                RTL
.1a7382	28		plp		not_printable   PLP
.1a7383	18		clc		                CLC
.1a7384	6b		rtl		                RTL
=256					MMEMDUMPSIZE = 256  ; Default number of bytes to dump
=8					MMEMROWSIZE = 8    ; Number of bytes to dump per-row
.1a7385					IMMEMORY
.1a7385	08		php		                PHP
.1a7386	8b		phb		                PHB
.1a7387	0b		phd		                PHD
.1a7388	08		php		            PHP
.1a7389	c2 20		rep #$20	            REP #$20
.1a738b	48		pha		            PHA
.1a738c	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a738f	5b		tcd		            TCD
.1a7390	68		pla		            PLA
.1a7391	28		plp		            PLP
.1a7392	e2 20		sep #$20	            SEP #$20
.1a7394	a9 00		lda #$00	                LDA #0              ; Clear the pagination line counter
.1a7396	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT
.1a739a	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.1a739c	c9 02		cmp #$02	                CMP #2
.1a739e	b0 16		bcs $1a73b6	                BGE set_cursor      ; 2>= arguments? Use them as-is
.1a73a0	c9 01		cmp #$01	                CMP #1
.1a73a2	90 20		bcc $1a73c4	                BLT no_args         ; No arguments passed? Use defaults
.1a73a4	c2 20		rep #$20	            REP #$20
.1a73a6	18		clc		                CLC
.1a73a7	a5 0d		lda $0855	                LDA MARG1
.1a73a9	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a73ac	85 11		sta $0859	                STA MARG2
.1a73ae	e2 20		sep #$20	            SEP #$20
.1a73b0	a5 0f		lda $0857	                LDA MARG1+2
.1a73b2	69 00		adc #$00	                ADC #0
.1a73b4	85 13		sta $085b	                STA MARG2+2
.1a73b6					set_cursor
.1a73b6	c2 20		rep #$20	            REP #$20
.1a73b8	a5 0d		lda $0855	                LDA MARG1
.1a73ba	85 32		sta $087a	                STA MCURSOR
.1a73bc	e2 20		sep #$20	            SEP #$20
.1a73be	a5 0f		lda $0857	                LDA MARG1+2
.1a73c0	85 34		sta $087c	                STA MCURSOR+2
.1a73c2	80 12		bra $1a73d6	                BRA dump_line
.1a73c4					no_args
.1a73c4	c2 20		rep #$20	            REP #$20
.1a73c6	18		clc		                CLC
.1a73c7	a5 32		lda $087a	                LDA MCURSOR
.1a73c9	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a73cc	85 11		sta $0859	                STA MARG2
.1a73ce	e2 20		sep #$20	            SEP #$20
.1a73d0	a5 34		lda $087c	                LDA MCURSOR+2
.1a73d2	69 00		adc #$00	                ADC #0
.1a73d4	85 13		sta $085b	                STA MARG2+2
.1a73d6					dump_line
.1a73d6	e2 20		sep #$20	            SEP #$20
.1a73d8	a0 00 00	ldy #$0000	                LDY #0
.1a73db	c2 20		rep #$20	            REP #$20
.1a73dd	a5 32		lda $087a	                LDA MCURSOR             ; NOTE: the use of MARG4 here is a temporary
.1a73df	85 19		sta $0861	                STA MARG4               ; hack. the copy_loop instruction does not
.1a73e1	e2 20		sep #$20	            SEP #$20
.1a73e3	a5 34		lda $087c	                LDA MCURSOR+2
.1a73e5	85 1b		sta $0863	                STA MARG4+2
.1a73e7	e2 20		sep #$20	            SEP #$20
.1a73e9	a7 19		lda [$0861]	copy_loop       LDA [MARG4]             ; TODO: Should be LDA [MCURSOR],Y, which doesn't seem to be working
.1a73eb	22 70 73 1a	jsl $1a7370	                JSL IS_PRINTABLE        ; Is it printable?
.1a73ef	b0 02		bcs $1a73f3	                BCS buffer_char         ; Yes: go ahead and add it to the line buffer
.1a73f1	a9 3f		lda #$3f	                LDA #'?'                ; No: replace it with dot
.1a73f3	99 7e 08	sta $087e,y	buffer_char     STA #MLINEBUF,B,Y
.1a73f6	c2 20		rep #$20	            REP #$20
.1a73f8	18		clc		                CLC
.1a73f9	a5 19		lda $0861	                LDA MARG4
.1a73fb	69 01 00	adc #$0001	                ADC #1
.1a73fe	85 19		sta $0861	                STA MARG4
.1a7400	e2 20		sep #$20	            SEP #$20
.1a7402	a5 1b		lda $0863	                LDA MARG4+2
.1a7404	69 00		adc #$00	                ADC #0
.1a7406	85 1b		sta $0863	                STA MARG4+2
.1a7408	c8		iny		                INY
.1a7409	c0 08 00	cpy #$0008	                CPY #MMEMROWSIZE
.1a740c	90 db		bcc $1a73e9	                BLT copy_loop
.1a740e	a9 00		lda #$00	                LDA #0
.1a7410	99 7e 08	sta $087e,y	                STA #MLINEBUF,B,Y
.1a7413	a9 3e		lda #$3e	                LDA #'>'
.1a7415	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7418	a9 20		lda #$20	                LDA #' '
.1a741a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a741d	e2 20		sep #$20	            SEP #$20
.1a741f	a5 34		lda $087c	                LDA MCURSOR+2
.1a7421	20 79 03	jsr $1a0379	            JSR PRHEXB
.1a7424	a9 3a		lda #$3a	                LDA #':'                ; then a colon
.1a7426	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7429	c2 20		rep #$20	            REP #$20
.1a742b	a5 32		lda $087a	                LDA MCURSOR
.1a742d	20 5f 03	jsr $1a035f	            JSR PRHEXW
.1a7430	c2 20		rep #$20	            REP #$20
.1a7432	a9 08 00	lda #$0008	                LDA #MMEMROWSIZE
.1a7435	85 47		sta $088f	                STA MCOUNT
.1a7437					prhex_loop
.1a7437	e2 20		sep #$20	            SEP #$20
.1a7439	a9 20		lda #$20	                LDA #' '
.1a743b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a743e	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a7440	20 79 03	jsr $1a0379	            JSR PRHEXB
.1a7443	22 b2 84 1a	jsl $1a84b2	                JSL M_INC_CURSOR        ; Point MCURSOR to the next byte
.1a7447					check_line
.1a7447	e2 20		sep #$20	            SEP #$20
.1a7449	c6 47		dec $088f	                DEC MCOUNT              ; Count down the number of bytes on the row
.1a744b	d0 ea		bne $1a7437	                BNE prhex_loop          ; If we're not at zero, keep looping over the bytes
.1a744d	a9 20		lda #$20	                LDA #' '
.1a744f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7452	a9 20		lda #$20	                LDA #' '
.1a7454	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7457	08		php		            PHP
.1a7458	e2 20		sep #$20	            SEP #$20
.1a745a	48		pha		            PHA
.1a745b	a9 00		lda #$00	            LDA #`MLINEBUF
.1a745d	48		pha		            PHA
.1a745e	ab		plb		            PLB
.1a745f	68		pla		            PLA
.1a7460	28		plp		            PLP
.1a7461	a2 7e 08	ldx #$087e	                LDX #MLINEBUF
.1a7464	20 4f 03	jsr $1a034f	            JSR PRINTS
.1a7467	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a746a	20 d9 02	jsr $1a02d9	            JSR PAGINATE
.1a746d	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.1a746f	c5 13		cmp $085b	                CMP MARG2+2
.1a7471	90 0f		bcc $1a7482	                BLT continue            ; No: continue
.1a7473	c2 20		rep #$20	            REP #$20
.1a7475	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.1a7477	c5 11		cmp $0859	                CMP MARG2
.1a7479	90 07		bcc $1a7482	                BLT continue            ; Nope... keep going
.1a747b					done
.1a747b	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a747e	2b		pld		                PLD
.1a747f	ab		plb		                PLB
.1a7480	28		plp		                PLP
.1a7481	6b		rtl		                RTL
.1a7482	4c d6 73	jmp $1a73d6	continue        JMP dump_line
.1a7485					M_COPY_ARGB
.1a7485	08		php		                PHP
.1a7486	8d 92 08	sta $0892	                STA MTEMP
.1a7489	e2 20		sep #$20	            SEP #$20
.1a748b	bd 00 00	lda $0000,x	loop            LDA #0,B,X
.1a748e	99 00 00	sta $0000,y	                STA #0,B,Y      ; Copy the byte
.1a7491	ad 92 08	lda $0892	                LDA MTEMP       ; Check the count of characters remaining
.1a7494	f0 0a		beq $1a74a0	                BEQ done        ; If it's 0, we're done
.1a7496	c8		iny		                INY             ; Point to the next destination byte
.1a7497	e8		inx		                INX             ; Point to the next source byte (skip three bytes)
.1a7498	e8		inx		                INX
.1a7499	e8		inx		                INX
.1a749a	e8		inx		                INX
.1a749b	ce 92 08	dec $0892	                DEC MTEMP       ; Count down and see if we're done
.1a749e	80 eb		bra $1a748b	                BRA loop
.1a74a0	28		plp		done            PLP
.1a74a1	6b		rtl		                RTL
.1a74a2					IMMODIFY
.1a74a2	08		php		                PHP
.1a74a3	0b		phd		                PHD
.1a74a4	8b		phb		                PHB
.1a74a5	08		php		            PHP
.1a74a6	c2 20		rep #$20	            REP #$20
.1a74a8	48		pha		            PHA
.1a74a9	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a74ac	5b		tcd		            TCD
.1a74ad	68		pla		            PLA
.1a74ae	28		plp		            PLP
.1a74af	08		php		            PHP
.1a74b0	e2 20		sep #$20	            SEP #$20
.1a74b2	48		pha		            PHA
.1a74b3	a9 00		lda #$00	            LDA #0
.1a74b5	48		pha		            PHA
.1a74b6	ab		plb		            PLB
.1a74b7	68		pla		            PLA
.1a74b8	28		plp		            PLP
.1a74b9	c2 30		rep #$30	            REP #$30
.1a74bb	a5 0d		lda $0855	                LDA MARG1           ; Set MCURSOR to MARG1
.1a74bd	85 32		sta $087a	                STA MCURSOR
.1a74bf	a5 0f		lda $0857	                LDA MARG1+2
.1a74c1	85 34		sta $087c	                STA MCURSOR+2
.1a74c3	e2 20		sep #$20	            SEP #$20
.1a74c5	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.1a74c7	3a		dec a		                DEC A               ; (MARG_LEN - 1)
.1a74c8	85 47		sta $088f	                STA MCOUNT
.1a74ca	a2 59 08	ldx #$0859	                LDX #<>MARG2        ; Copy MCOUNT bytes from MARG2..MARG9
.1a74cd	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF     ; to MLINEBUF
.1a74d0	22 85 74 1a	jsl $1a7485	                JSL M_COPY_ARGB
.1a74d4	a0 00 00	ldy #$0000	                LDY #0
.1a74d7	b9 7e 08	lda $087e,y	loop            LDA MLINEBUF,Y      ; Copy the byte from the buffer
.1a74da	87 32		sta [$087a]	                STA [MCURSOR]       ; To the address indicated by MCURSOR
.1a74dc	22 b2 84 1a	jsl $1a84b2	                JSL M_INC_CURSOR    ; Advance the cursor
.1a74e0	c8		iny		                INY                 ; Go to the next buffered byte
.1a74e1	c4 47		cpy $088f	                CPY MCOUNT          ; Did we just write the last one?
.1a74e3	d0 f2		bne $1a74d7	                BNE loop            ; No: continue writing
.1a74e5	ab		plb		                PLB
.1a74e6	2b		pld		                PLD
.1a74e7	28		plp		                PLP
.1a74e8	6b		rtl		                RTL
.1a74e9					IMHUNT
.1a74e9	08		php		                PHP
.1a74ea	0b		phd		                PHD
.1a74eb	8b		phb		                PHB
.1a74ec	08		php		            PHP
.1a74ed	c2 20		rep #$20	            REP #$20
.1a74ef	48		pha		            PHA
.1a74f0	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a74f3	5b		tcd		            TCD
.1a74f4	68		pla		            PLA
.1a74f5	28		plp		            PLP
.1a74f6	08		php		            PHP
.1a74f7	e2 20		sep #$20	            SEP #$20
.1a74f9	48		pha		            PHA
.1a74fa	a9 00		lda #$00	            LDA #0
.1a74fc	48		pha		            PHA
.1a74fd	ab		plb		            PLB
.1a74fe	68		pla		            PLA
.1a74ff	28		plp		            PLP
.1a7500	e2 20		sep #$20	            SEP #$20
.1a7502	c2 10		rep #$10	            REP #$10
.1a7504	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.1a7506	3a		dec a		                DEC A               ; (MARG_LEN - 2)
.1a7507	3a		dec a		                DEC A
.1a7508	85 47		sta $088f	                STA MCOUNT
.1a750a	a2 5d 08	ldx #$085d	                LDX #<>MARG3
.1a750d	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF
.1a7510	22 85 74 1a	jsl $1a7485	                JSL M_COPY_ARGB
.1a7514	c2 20		rep #$20	            REP #$20
.1a7516	a5 0d		lda $0855	                LDA MARG1           ; Copy starting address to MCURSOR
.1a7518	85 32		sta $087a	                STA MCURSOR
.1a751a	a5 0f		lda $0857	                LDA MARG1+2
.1a751c	85 34		sta $087c	                STA MCURSOR+2
.1a751e					outer_loop
.1a751e	c2 20		rep #$20	            REP #$20
.1a7520	a5 34		lda $087c	                LDA MCURSOR+2      ; If MCURSOR < MARG2, we're not done yet
.1a7522	c5 13		cmp $085b	                CMP MARG2+2
.1a7524	d0 06		bne $1a752c	                BNE not_done
.1a7526	a5 32		lda $087a	                LDA MCURSOR
.1a7528	c5 11		cmp $0859	                CMP MARG2
.1a752a	f0 2c		beq $1a7558	                BEQ done            ; MCURSOR = MARG2: we're done
.1a752c					not_done
.1a752c	e2 20		sep #$20	            SEP #$20
.1a752e	a0 00 00	ldy #$0000	                LDY #0
.1a7531	b7 32		lda [$087a],y	cmp_loop        LDA [MCURSOR],Y     ; Get the byte from the memory to check
.1a7533	d9 7e 08	cmp $087e,y	                CMP MLINEBUF,Y      ; Compare it against our pattern
.1a7536	d0 1a		bne $1a7552	                BNE advance         ; If not equal, we need to move on
.1a7538	c8		iny		                INY                 ; Otherwise do we have more bytes to check?
.1a7539	c4 47		cpy $088f	                CPY MCOUNT
.1a753b	d0 f4		bne $1a7531	                BNE cmp_loop        ; No: check more
.1a753d	c2 20		rep #$20	            REP #$20
.1a753f	a5 32		lda $087a	                LDA MCURSOR         ; Print the address
.1a7541	85 4a		sta $0892	                STA MTEMP
.1a7543	a5 34		lda $087c	                LDA MCURSOR+2
.1a7545	85 4c		sta $0894	                STA MTEMP+2
.1a7547	22 5c 7f 1a	jsl $1a7f5c	                JSL M_PR_ADDR
.1a754b	e2 20		sep #$20	            SEP #$20
.1a754d	a9 20		lda #$20	                LDA #' '
.1a754f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7552	22 b2 84 1a	jsl $1a84b2	advance         JSL M_INC_CURSOR    ; Move MCURSOR forward by one
.1a7556	80 c6		bra $1a751e	                BRA outer_loop      ; And try to compare that to the pattern
.1a7558					done
.1a7558	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a755b	ab		plb		                PLB
.1a755c	2b		pld		                PLD
.1a755d	28		plp		                PLP
.1a755e	6b		rtl		                RTL
.1a755f					IMJUMP
.1a755f	08		php		            PHP
.1a7560	c2 20		rep #$20	            REP #$20
.1a7562	48		pha		            PHA
.1a7563	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a7566	5b		tcd		            TCD
.1a7567	68		pla		            PLA
.1a7568	28		plp		            PLP
.1a7569	e2 20		sep #$20	            SEP #$20
.1a756b	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.1a756d	f0 0e		beq $1a757d	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.1a756f	c2 30		rep #$30	            REP #$30
.1a7571	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.1a7573	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.1a7577	a5 0f		lda $0857	                LDA MARG1+2
.1a7579	8f 42 02 00	sta $000242	                STA @lCPUPBR
.1a757d	af 46 02 00	lda $000246	MJUMPRESTORE    LDA @lCPUX          ; Restore X and Y
.1a7581	aa		tax		                TAX
.1a7582	af 48 02 00	lda $000248	                LDA @lCPUY
.1a7586	a8		tay		                TAY
.1a7587	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.1a758b	1b		tcs		                TCS
.1a758c	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.1a7590	5b		tcd		                TCD
.1a7591	e2 20		sep #$20	            SEP #$20
.1a7593	a9 1a		lda #$1a	                LDA #`MJUMPSTART
.1a7595	48		pha		                PHA
.1a7596	a9 75		lda #$75	                LDA #>MJUMPSTART
.1a7598	48		pha		                PHA
.1a7599	a9 9f		lda #$9f	                LDA #<MJUMPSTART
.1a759b	48		pha		                PHA
.1a759c	4c d6 75	jmp $1a75d6	                JMP MGOSTACK        ; And push remaining registers and restart execution
.1a759f	ea		nop		MJUMPSTART      NOP                 ; RTL increments PC pulled from stack, NOP leaves space for that
.1a75a0	5c 04 00 1a	jmp $1a0004	                JML MONITOR
.1a75a4					IMGO
.1a75a4	08		php		            PHP
.1a75a5	c2 20		rep #$20	            REP #$20
.1a75a7	48		pha		            PHA
.1a75a8	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a75ab	5b		tcd		            TCD
.1a75ac	68		pla		            PLA
.1a75ad	28		plp		            PLP
.1a75ae	e2 20		sep #$20	            SEP #$20
.1a75b0	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.1a75b2	f0 c9		beq $1a757d	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.1a75b4	c2 30		rep #$30	            REP #$30
.1a75b6	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.1a75b8	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.1a75bc	a5 0f		lda $0857	                LDA MARG1+2
.1a75be	8f 42 02 00	sta $000242	                STA @lCPUPBR
.1a75c2	af 46 02 00	lda $000246	MGORESTORE      LDA @lCPUX          ; Restore X and Y
.1a75c6	aa		tax		                TAX
.1a75c7	af 48 02 00	lda $000248	                LDA @lCPUY
.1a75cb	a8		tay		                TAY
.1a75cc	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.1a75d0	1b		tcs		                TCS
.1a75d1	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.1a75d5	5b		tcd		                TCD
.1a75d6					MGOSTACK
.1a75d6	e2 20		sep #$20	            SEP #$20
.1a75d8	af 4e 02 00	lda $00024e	                LDA @lCPUDBR        ; Restore the data bank register
.1a75dc	48		pha		                PHA
.1a75dd	ab		plb		                PLB
.1a75de	a9 5c		lda #$5c	                LDA #$5C            ; Save the JSL opcode
.1a75e0	8f a2 08 00	sta $0008a2	                STA @lMJUMPINST
.1a75e4	af 42 02 00	lda $000242	                LDA @lCPUPBR        ; Write PBR
.1a75e8	8f a5 08 00	sta $0008a5	                STA @lMJUMPADDR+2
.1a75ec	af 41 02 00	lda $000241	                LDA @lCPUPC+1       ; Write PCH
.1a75f0	8f a4 08 00	sta $0008a4	                STA @lMJUMPADDR+1
.1a75f4	af 40 02 00	lda $000240	                LDA @lCPUPC         ; Write PCL
.1a75f8	8f a3 08 00	sta $0008a3	                STA @lMJUMPADDR
.1a75fc	af 4f 02 00	lda $00024f	                LDA @lCPUFLAGS      ; Push processor status
.1a7600	48		pha		                PHA
.1a7601	c2 20		rep #$20	            REP #$20
.1a7603	af 44 02 00	lda $000244	                LDA @lCPUA          ; Restore A
.1a7607	28		plp		                PLP                 ; And the status register
.1a7608	5c a2 08 00	jmp $0008a2	                JML MJUMPINST       ; And jump to the target address
.1a760c					IMCOMPARE
.1a760c	08		php		                PHP
.1a760d	0b		phd		                PHD
.1a760e	8b		phb		                PHB
.1a760f	08		php		            PHP
.1a7610	e2 20		sep #$20	            SEP #$20
.1a7612	48		pha		            PHA
.1a7613	a9 1a		lda #$1a	            LDA #`MERRARGS
.1a7615	48		pha		            PHA
.1a7616	ab		plb		            PLB
.1a7617	68		pla		            PLA
.1a7618	28		plp		            PLP
.1a7619	08		php		            PHP
.1a761a	c2 20		rep #$20	            REP #$20
.1a761c	48		pha		            PHA
.1a761d	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a7620	5b		tcd		            TCD
.1a7621	68		pla		            PLA
.1a7622	28		plp		            PLP
.1a7623	c2 10		rep #$10	            REP #$10
.1a7625	e2 20		sep #$20	            SEP #$20
.1a7627	a5 31		lda $0879	                LDA MARG_LEN                ; Check the number of arguments provided
.1a7629	c9 02		cmp #$02	                CMP #2
.1a762b	f0 0c		beq $1a7639	                BEQ default_len             ; If 2: set MCOUNT to default of 1
.1a762d	c9 03		cmp #$03	                CMP #3
.1a762f	d0 11		bne $1a7642	                BNE bad_arguments           ; Otherwise, if not 3: print an error
.1a7631	c2 20		rep #$20	            REP #$20
.1a7633	a5 15		lda $085d	                LDA MARG3                   ; If 3: set MCOUNT to MARG3
.1a7635	85 47		sta $088f	                STA MCOUNT
.1a7637	80 11		bra $1a764a	                BRA compare
.1a7639					default_len
.1a7639	c2 20		rep #$20	            REP #$20
.1a763b	a9 01 00	lda #$0001	                LDA #1                      ; No length was provided, set MCOUNT to 1
.1a763e	85 47		sta $088f	                STA MCOUNT
.1a7640	80 08		bra $1a764a	                BRA compare
.1a7642	a2 7e 87	ldx #$877e	bad_arguments   LDX #<>MERRARGS             ; The wrong number of arguments was provided
.1a7645	20 4f 03	jsr $1a034f	            JSR PRINTS
.1a7648	80 35		bra $1a767f	                BRA done
.1a764a	a5 0d		lda $0855	compare         LDA MARG1                   ; Set MTEMP to MARG1
.1a764c	85 4a		sta $0892	                STA MTEMP
.1a764e	a5 0f		lda $0857	                LDA MARG1+2
.1a7650	85 4c		sta $0894	                STA MTEMP+2
.1a7652	a0 00 00	ldy #$0000	                LDY #0
.1a7655					loop
.1a7655	e2 20		sep #$20	            SEP #$20
.1a7657	a7 4a		lda [$0892]	                LDA [MTEMP]                 ; Compare the byte at MTEMP
.1a7659	d7 11		cmp [$0859],y	                CMP [MARG2],Y               ; To the Yth byte from MARG2
.1a765b	f0 09		beq $1a7666	                BEQ continue                ; If they're the same, keep going
.1a765d	22 5c 7f 1a	jsl $1a7f5c	mismatch        JSL M_PR_ADDR               ; If they're different, print MTEMP
.1a7661	a9 20		lda #$20	                LDA #' '
.1a7663	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7666					continue
.1a7666	c2 20		rep #$20	            REP #$20
.1a7668	18		clc		                CLC                         ; Either way, increment MTEMP
.1a7669	a5 4a		lda $0892	                LDA MTEMP
.1a766b	69 01 00	adc #$0001	                ADC #1
.1a766e	85 4a		sta $0892	                STA MTEMP
.1a7670	a5 4c		lda $0894	                LDA MTEMP+2
.1a7672	69 00 00	adc #$0000	                ADC #0
.1a7675	85 4c		sta $0894	                STA MTEMP+2
.1a7677	c8		iny		                INY                         ; Increment Y
.1a7678	c4 47		cpy $088f	                CPY MCOUNT                  ; Try again unless we've checked MCOUNT bytes
.1a767a	d0 d9		bne $1a7655	                BNE loop
.1a767c	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a767f					done
.1a767f	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a7682	ab		plb		                PLB
.1a7683	2b		pld		                PLD
.1a7684	28		plp		                PLP
.1a7685	6b		rtl		                RTL
.1a7686					IMRMODIFY
.1a7686	08		php		                PHP
.1a7687	0b		phd		                PHD
.1a7688	8b		phb		                PHB
.1a7689	08		php		            PHP
.1a768a	e2 20		sep #$20	            SEP #$20
.1a768c	48		pha		            PHA
.1a768d	a9 00		lda #$00	            LDA #0
.1a768f	48		pha		            PHA
.1a7690	ab		plb		            PLB
.1a7691	68		pla		            PLA
.1a7692	28		plp		            PLP
.1a7693	08		php		            PHP
.1a7694	c2 20		rep #$20	            REP #$20
.1a7696	48		pha		            PHA
.1a7697	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a769a	5b		tcd		            TCD
.1a769b	68		pla		            PLA
.1a769c	28		plp		            PLP
.1a769d	e2 20		sep #$20	            SEP #$20
.1a769f	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.1a76a1	f0 4f		beq $1a76f2	                BEQ done            ; 0? Just quit
.1a76a3	a6 0d		ldx $0855	                LDX MARG1           ; Set the PC and PBR
.1a76a5	8e 40 02	stx $0240	                STX #CPUPC,B
.1a76a8	a6 0f		ldx $0857	                LDX MARG1+2
.1a76aa	8e 42 02	stx $0242	                STX #CPUPBR,B
.1a76ad	c9 01		cmp #$01	                CMP #1              ; Check the number of arguments
.1a76af	f0 41		beq $1a76f2	                BEQ done            ; 1? Just quit
.1a76b1	a6 11		ldx $0859	                LDX MARG2           ; Set A
.1a76b3	8e 44 02	stx $0244	                STX #CPUA,B
.1a76b6	c9 02		cmp #$02	                CMP #2              ; Check the number of arguments
.1a76b8	f0 38		beq $1a76f2	                BEQ done            ; 2? Just quit
.1a76ba	a6 15		ldx $085d	                LDX MARG3           ; Set X
.1a76bc	8e 46 02	stx $0246	                STX #CPUX,B
.1a76bf	c9 03		cmp #$03	                CMP #3              ; Check the number of arguments
.1a76c1	f0 2f		beq $1a76f2	                BEQ done            ; 3? Just quit
.1a76c3	a6 19		ldx $0861	                LDX MARG4           ; Set Y
.1a76c5	8e 48 02	stx $0248	                STX #CPUY,B
.1a76c8	c9 04		cmp #$04	                CMP #4              ; Check the number of arguments
.1a76ca	f0 26		beq $1a76f2	                BEQ done            ; 4? Just quit
.1a76cc	a6 1d		ldx $0865	                LDX MARG5           ; Set SP
.1a76ce	8e 4a 02	stx $024a	                STX #CPUSTACK,B
.1a76d1	c9 05		cmp #$05	                CMP #5              ; Check the number of arguments
.1a76d3	f0 1d		beq $1a76f2	                BEQ done            ; 5? Just quit
.1a76d5	e2 10		sep #$10	            SEP #$10
.1a76d7	a6 21		ldx $0869	                LDX MARG6           ; Set DBR
.1a76d9	8e 4e 02	stx $024e	                STX #CPUDBR,B
.1a76dc	c9 06		cmp #$06	                CMP #6              ; Check the number of arguments
.1a76de	f0 12		beq $1a76f2	                BEQ done            ; 6? Just quit
.1a76e0	c2 10		rep #$10	            REP #$10
.1a76e2	a6 25		ldx $086d	                LDX MARG7           ; Set DP
.1a76e4	8e 4c 02	stx $024c	                STX #CPUDP,B
.1a76e7	c9 07		cmp #$07	                CMP #7              ; Check the number of arguments
.1a76e9	f0 07		beq $1a76f2	                BEQ done            ; 7? Just quit
.1a76eb	e2 10		sep #$10	            SEP #$10
.1a76ed	a6 29		ldx $0871	                LDX MARG8           ; Set flags
.1a76ef	8e 4f 02	stx $024f	                STX #CPUFLAGS,B
.1a76f2	ab		plb		done            PLB
.1a76f3	2b		pld		                PLD
.1a76f4	28		plp		                PLP
.1a76f5	6b		rtl		                RTL
.1a76f6					IMEXECUTE
.1a76f6	08		php		                PHP
.1a76f7	0b		phd		                PHD
.1a76f8	8b		phb		                PHB
.1a76f9	08		php		            PHP
.1a76fa	c2 20		rep #$20	            REP #$20
.1a76fc	48		pha		            PHA
.1a76fd	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7700	5b		tcd		            TCD
.1a7701	68		pla		            PLA
.1a7702	28		plp		            PLP
.1a7703	e2 20		sep #$20	            SEP #$20
.1a7705	c2 10		rep #$10	            REP #$10
.1a7707	a2 00 00	ldx #$0000	                LDX #0
.1a770a	bf eb 87 1a	lda $1a87eb,x	loop            LDA @lMCOMMANDS,X
.1a770e	f0 18		beq $1a7728	                BEQ done
.1a7710	c7 08		cmp [$0850]	                CMP [MCMD]
.1a7712	f0 03		beq $1a7717	                BEQ found
.1a7714	e8		inx		                INX
.1a7715	80 f3		bra $1a770a	                BRA loop
.1a7717					found
.1a7717	c2 20		rep #$20	            REP #$20
.1a7719	8a		txa		                TXA
.1a771a	0a		asl a		                ASL A
.1a771b	aa		tax		                TAX
.1a771c	bf 2c 77 1a	lda $1a772c,x	                LDA dispatch,X
.1a7720	8f 2f 08 00	sta $00082f	                STA @lJMP16PTR
.1a7724	22 50 77 1a	jsl $1a7750	                JSL MDOCMD
.1a7728	ab		plb		done            PLB
.1a7729	2b		pld		                PLD
.1a772a	28		plp		                PLP
.1a772b	6b		rtl		                RTL
>1a772c	c9 6d				dispatch        .word <>MASSEMBLE
>1a772e	d1 6d				                .word <>MCOMPARE
>1a7730	d5 6d				                .word <>MDISASSEMBLE
>1a7732	d9 6d				                .word <>MFILL
>1a7734	dd 6d				                .word <>MGO
>1a7736	e1 6d				                .word <>MJUMP
>1a7738	e5 6d				                .word <>MHUNT
>1a773a	e9 6d				                .word <>MLOAD
>1a773c	ed 6d				                .word <>MMEMORY
>1a773e	f1 6d				                .word <>MREGISTERS
>1a7740	cd 6d				                .word <>MRMODIFY
>1a7742	f5 6d				                .word <>MSAVE
>1a7744	f9 6d				                .word <>MTRANSFER
>1a7746	fd 6d				                .word <>MVERIFY
>1a7748	c5 71				                .word <>IMWIDTH
>1a774a	01 6e				                .word <>MEXIT
>1a774c	05 6e				                .word <>MMODIFY
>1a774e	3e 6e				                .word <>IMHELP
.1a7750					MDOCMD
.1a7750	6c 2f 08	jmp ($082f)	                JMP (JMP16PTR)

;******  Processing file: src\assembler.s

=0					ADDR_DP_IND_X = 0       ; (dd,X)
=1					ADDR_DP = 1             ; dd
=2					ADDR_IMM = 2            ; #dd
=3					ADDR_ABS = 3            ; dddd
=4					ADDR_DP_IND_Y = 4       ; (dd),Y
=5					ADDR_DP_X = 5           ; dd,X
=6					ADDR_ABS_Y = 6          ; dddd,Y
=7					ADDR_ABS_X = 7          ; dddd,X
=8					ADDR_ACC = 8            ; A
=9					ADDR_SP_R = 9           ; #d,S
=10					ADDR_DP_LONG = 10       ; [dd]
=11					ADDR_ABS_LONG = 11      ; dddddd
=12					ADDR_SP_R_Y = 12        ; #dd,S,Y
=13					ADDR_DP_Y_LONG = 13     ; [dd],Y
=14					ADDR_ABS_X_LONG = 14    ; dddddd,X
=15					ADDR_DP_IND = 15        ; (dd)
=16					ADDR_ABS_X_ID = 16      ; (dddd,X)
=17					ADDR_DP_Y = 17          ; dd,Y
=18					ADDR_PC_REL = 18        ; PC relative
=19					ADDR_IMPLIED = 19       ; Implied (no operand)
=20					ADDR_XYC = 20           ; #dd, #dd
=21					ADDR_ABS_IND = 21       ; (dddd)
=22					ADDR_PC_REL_LONG = 22   ; PC relative ()
=23					ADDR_ABS_IND_LONG = 23  ; [dddd]
=$80					OP_M_EFFECT = $80       ; Flag to indicate instruction is modified by M
=$40					OP_X_EFFECT = $40       ; Flag to indicate instruction is modified by X
.1a7753					IMASSEMBLE
.1a7753	08		php		                PHP
.1a7754	8b		phb		                PHB
.1a7755	0b		phd		                PHD
.1a7756	08		php		            PHP
.1a7757	c2 20		rep #$20	            REP #$20
.1a7759	48		pha		            PHA
.1a775a	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a775d	5b		tcd		            TCD
.1a775e	68		pla		            PLA
.1a775f	28		plp		            PLP
.1a7760	e2 20		sep #$20	            SEP #$20
.1a7762	a5 31		lda $0879	                LDA MARG_LEN            ; Do we have at least 2 arguments?
.1a7764	c9 02		cmp #$02	                CMP #2
.1a7766	b0 03		bcs $1a776b	                BGE has_args            ; Yes: try to assemble the line
.1a7768	4c f9 78	jmp $1a78f9	                JMP done                ; No: just return
.1a776b					has_args
.1a776b	c2 20		rep #$20	            REP #$20
.1a776d	a5 0d		lda $0855	                LDA MARG1               ; Set the monitor cursor to the address
.1a776f	85 32		sta $087a	                STA MCURSOR
.1a7771	a5 0f		lda $0857	                LDA MARG1+2
.1a7773	85 34		sta $087c	                STA MCURSOR+2
.1a7775	c2 20		rep #$20	            REP #$20
.1a7777	22 fb 7a 1a	jsl $1a7afb	                JSL AS_FIND_MNEMO       ; Find the address of the mnemonic
.1a777b	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a777e	f0 10		beq $1a7790	                BEQ bad_mnemonic        ; If not found, print bad mnemonic error message
.1a7780	85 54		sta $089c	                STA MMNEMONIC
.1a7782	e2 20		sep #$20	            SEP #$20
.1a7784	a5 31		lda $0879	                LDA MARG_LEN            ; Check the number of arguments passed
.1a7786	c9 03		cmp #$03	                CMP #3                  ; Were all three arguments provided?
.1a7788	f0 36		beq $1a77c0	                BEQ get_operand         ; Yes: parse the operand
.1a778a	a9 13		lda #$13	                LDA #ADDR_IMPLIED       ; No: assume address mode is implied
.1a778c	85 4f		sta $0897	                STA MADDR_MODE
.1a778e	80 4c		bra $1a77dc	                BRA get_opcode
.1a7790					bad_mnemonic
.1a7790	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a7793	08		php		            PHP
.1a7794	e2 20		sep #$20	            SEP #$20
.1a7796	48		pha		            PHA
.1a7797	a9 1a		lda #$1a	            LDA #`MERRBADMNEMO
.1a7799	48		pha		            PHA
.1a779a	ab		plb		            PLB
.1a779b	68		pla		            PLA
.1a779c	28		plp		            PLP
.1a779d	c2 10		rep #$10	            REP #$10
.1a779f	a2 30 79	ldx #$7930	                LDX #<>MERRBADMNEMO
.1a77a2	20 4f 03	jsr $1a034f	            JSR PRINTS
.1a77a5	4c f9 78	jmp $1a78f9	                JMP done
.1a77a8					bad_operand
.1a77a8	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a77ab	08		php		            PHP
.1a77ac	e2 20		sep #$20	            SEP #$20
.1a77ae	48		pha		            PHA
.1a77af	a9 1a		lda #$1a	            LDA #`MERRBADOPER
.1a77b1	48		pha		            PHA
.1a77b2	ab		plb		            PLB
.1a77b3	68		pla		            PLA
.1a77b4	28		plp		            PLP
.1a77b5	c2 10		rep #$10	            REP #$10
.1a77b7	a2 3f 79	ldx #$793f	                LDX #<>MERRBADOPER
.1a77ba	20 4f 03	jsr $1a034f	            JSR PRINTS
.1a77bd	4c f9 78	jmp $1a78f9	                JMP done
.1a77c0					get_operand
.1a77c0	e2 20		sep #$20	            SEP #$20
.1a77c2	22 31 7b 1a	jsl $1a7b31	                JSL AS_FIND_MODE        ; Find the addressing mode of the operand
.1a77c6	c9 ff		cmp #$ff	compare         CMP #$FF
.1a77c8	f0 de		beq $1a77a8	                BEQ bad_operand         ; If not found, print bad operand error message
.1a77ca	85 4f		sta $0897	                STA MADDR_MODE
.1a77cc	c9 03		cmp #$03	                CMP #ADDR_ABS           ; If mode is absolute or absolute long...
.1a77ce	f0 62		beq $1a7832	                BEQ check_for_pcrel     ; Check to see if the mnemonic is one of the branches
.1a77d0	c9 0b		cmp #$0b	                CMP #ADDR_ABS_LONG
.1a77d2	f0 5e		beq $1a7832	                BEQ check_for_pcrel
.1a77d4	c9 13		cmp #$13	                CMP #ADDR_IMPLIED       ; If mode is implied or accumulator, get the opcode
.1a77d6	f0 04		beq $1a77dc	                BEQ get_opcode
.1a77d8	c9 08		cmp #$08	                CMP #ADDR_ACC
.1a77da	f0 00		beq $1a77dc	                BEQ get_opcode
.1a77dc	22 29 7a 1a	jsl $1a7a29	get_opcode      JSL AS_FIND_OPCODE      ; Find the opcode matching the two
.1a77e0	b0 03		bcs $1a77e5	                BCS save_opcode
.1a77e2	4c c2 78	jmp $1a78c2	                JMP bad_mode            ; If opcode not found, print bad address mode error message
.1a77e5	87 32		sta [$087a]	save_opcode     STA [MCURSOR]           ; Write the opcode to the address
.1a77e7	22 b2 84 1a	jsl $1a84b2	                JSL M_INC_CURSOR        ; And point to the next byte
.1a77eb	08		php		            PHP
.1a77ec	e2 20		sep #$20	            SEP #$20
.1a77ee	48		pha		            PHA
.1a77ef	a9 00		lda #$00	            LDA #0
.1a77f1	48		pha		            PHA
.1a77f2	ab		plb		            PLB
.1a77f3	68		pla		            PLA
.1a77f4	28		plp		            PLP
.1a77f5	c2 20		rep #$20	            REP #$20
.1a77f7	a5 32		lda $087a	                LDA MCURSOR             ; Make MTEMPPTR a pointer to the machine code we're assembling
.1a77f9	85 56		sta $089e	                STA MTEMPPTR
.1a77fb	a5 34		lda $087c	                LDA MCURSOR+2
.1a77fd	85 58		sta $08a0	                STA MTEMPPTR+2
.1a77ff	e2 20		sep #$20	            SEP #$20
.1a7801	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check the address mode again
.1a7803	c9 12		cmp #$12	                CMP #ADDR_PC_REL        ; If it's PC relative
.1a7805	f0 6c		beq $1a7873	                BEQ compute_rel         ; Convert the address to an offset
.1a7807	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.1a7809	f0 68		beq $1a7873	                BEQ compute_rel
.1a780b	c9 14		cmp #$14	                CMP #ADDR_XYC           ; MVP/MVN addressing mode?
.1a780d	f0 7c		beq $1a788b	                BEQ emit_2
.1a780f	29 3f		and #$3f	                AND #%00111111          ; Filter out the mode bits
.1a7811	c9 02		cmp #$02	                CMP #ADDR_IMM           ; Is it immediate?
.1a7813	d0 03		bne $1a7818	                BNE fixed_length        ; Yes: emit it as an immediate (variable length)
.1a7815	4c f0 78	jmp $1a78f0	                JMP emit_imm
.1a7818					fixed_length
.1a7818	c2 20		rep #$20	            REP #$20
.1a781a	29 ff 00	and #$00ff	                AND #$00FF
.1a781d	aa		tax		                TAX
.1a781e	e2 20		sep #$20	            SEP #$20
.1a7820	bf f8 83 1a	lda $1a83f8,x	get_length      LDA ADDR_LENGTH,X       ; Get the number of bytes in the addressing mode
.1a7824	c9 03		cmp #$03	                CMP #$03
.1a7826	f0 57		beq $1a787f	                BEQ emit_3
.1a7828	c9 02		cmp #$02	                CMP #$02
.1a782a	f0 5f		beq $1a788b	                BEQ emit_2
.1a782c	c9 01		cmp #$01	                CMP #$01
.1a782e	f0 67		beq $1a7897	                BEQ emit_1
.1a7830	80 71		bra $1a78a3	                BRA next_line
.1a7832					check_for_pcrel
.1a7832	c2 20		rep #$20	            REP #$20
.1a7834	a5 54		lda $089c	                LDA MMNEMONIC
.1a7836	c9 70 80	cmp #$8070	                CMP #<>MN_BRA
.1a7839	f0 26		beq $1a7861	                BEQ is_pcrel
.1a783b	c9 d4 80	cmp #$80d4	                CMP #<>MN_BRL
.1a783e	f0 2a		beq $1a786a	                BEQ is_pcrel_long
.1a7840	c9 54 80	cmp #$8054	                CMP #<>MN_BCC
.1a7843	f0 1c		beq $1a7861	                BEQ is_pcrel
.1a7845	c9 58 80	cmp #$8058	                CMP #<>MN_BCS
.1a7848	f0 17		beq $1a7861	                BEQ is_pcrel
.1a784a	c9 60 80	cmp #$8060	                CMP #<>MN_BEQ
.1a784d	f0 12		beq $1a7861	                BEQ is_pcrel
.1a784f	c9 48 80	cmp #$8048	                CMP #<>MN_BMI
.1a7852	f0 0d		beq $1a7861	                BEQ is_pcrel
.1a7854	c9 5c 80	cmp #$805c	                CMP #<>MN_BNE
.1a7857	f0 08		beq $1a7861	                BEQ is_pcrel
.1a7859	c9 44 80	cmp #$8044	                CMP #<>MN_BPL
.1a785c	f0 03		beq $1a7861	                BEQ is_pcrel
.1a785e	4c dc 77	jmp $1a77dc	                JMP get_opcode
.1a7861					is_pcrel
.1a7861	e2 20		sep #$20	            SEP #$20
.1a7863	a9 12		lda #$12	                LDA #ADDR_PC_REL
.1a7865	85 4f		sta $0897	                STA MADDR_MODE
.1a7867	4c dc 77	jmp $1a77dc	                JMP get_opcode
.1a786a					is_pcrel_long
.1a786a	e2 20		sep #$20	            SEP #$20
.1a786c	a9 16		lda #$16	                LDA #ADDR_PC_REL_LONG
.1a786e	85 4f		sta $0897	                STA MADDR_MODE
.1a7870	4c dc 77	jmp $1a77dc	                JMP get_opcode
.1a7873	22 6c 79 1a	jsl $1a796c	compute_rel     JSL AS_PC_OFFSET        ; Try to compute the offset
.1a7877	90 60		bcc $1a78d9	                BCC bad_offset          ; If failed, it's a bad offset operand
.1a7879	c9 02		cmp #$02	emit_rel        CMP #$02                ; If the offset is two bytes
.1a787b	f0 0e		beq $1a788b	                BEQ emit_2              ; Emit those two bytes
.1a787d	80 18		bra $1a7897	                BRA emit_1              ; Otherwise emit just the one
.1a787f	a0 02 00	ldy #$0002	emit_3          LDY #2                  ; Write bank byte of operand
.1a7882	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.1a7885	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.1a7887	22 b2 84 1a	jsl $1a84b2	                JSL M_INC_CURSOR
.1a788b	a0 01 00	ldy #$0001	emit_2          LDY #1                  ; Write high byte of operand
.1a788e	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.1a7891	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.1a7893	22 b2 84 1a	jsl $1a84b2	                JSL M_INC_CURSOR
.1a7897	a0 00 00	ldy #$0000	emit_1          LDY #0                  ; Write low byte of operand
.1a789a	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.1a789d	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.1a789f	22 b2 84 1a	jsl $1a84b2	                JSL M_INC_CURSOR
.1a78a3					next_line
.1a78a3	e2 20		sep #$20	            SEP #$20
.1a78a5	a9 41		lda #$41	                LDA #'A'
.1a78a7	20 18 00	jsr $1a0018	            JSR PRINTC
.1a78aa	a9 20		lda #$20	                LDA #' '
.1a78ac	20 18 00	jsr $1a0018	            JSR PRINTC
.1a78af	a6 32		ldx $087a	                LDX MCURSOR
.1a78b1	86 4a		stx $0892	                STX MTEMP
.1a78b3	a6 34		ldx $087c	                LDX MCURSOR+2
.1a78b5	86 4c		stx $0894	                STX MTEMP+2
.1a78b7	22 5c 7f 1a	jsl $1a7f5c	                JSL M_PR_ADDR
.1a78bb	a9 20		lda #$20	                LDA #' '
.1a78bd	20 18 00	jsr $1a0018	            JSR PRINTC
.1a78c0	80 37		bra $1a78f9	                BRA done
.1a78c2					bad_mode
.1a78c2	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a78c5	08		php		            PHP
.1a78c6	e2 20		sep #$20	            SEP #$20
.1a78c8	48		pha		            PHA
.1a78c9	a9 1a		lda #$1a	            LDA #`MERRBADMODE
.1a78cb	48		pha		            PHA
.1a78cc	ab		plb		            PLB
.1a78cd	68		pla		            PLA
.1a78ce	28		plp		            PLP
.1a78cf	c2 10		rep #$10	            REP #$10
.1a78d1	a2 fd 78	ldx #$78fd	                LDX #<>MERRBADMODE
.1a78d4	20 4f 03	jsr $1a034f	            JSR PRINTS
.1a78d7	80 20		bra $1a78f9	                BRA done
.1a78d9					bad_offset
.1a78d9	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a78dc	08		php		            PHP
.1a78dd	e2 20		sep #$20	            SEP #$20
.1a78df	48		pha		            PHA
.1a78e0	a9 1a		lda #$1a	            LDA #`MERRBADOFFSET
.1a78e2	48		pha		            PHA
.1a78e3	ab		plb		            PLB
.1a78e4	68		pla		            PLA
.1a78e5	28		plp		            PLP
.1a78e6	c2 10		rep #$10	            REP #$10
.1a78e8	a2 4d 79	ldx #$794d	                LDX #<>MERRBADOFFSET
.1a78eb	20 4f 03	jsr $1a034f	            JSR PRINTS
.1a78ee	80 09		bra $1a78f9	                BRA done
.1a78f0	a5 4f		lda $0897	emit_imm        LDA MADDR_MODE          ; Check to see if long immediate was used
.1a78f2	29 c0		and #$c0	                AND #%11000000
.1a78f4	d0 95		bne $1a788b	                BNE emit_2              ; Yes: emit two bytes
.1a78f6	4c 97 78	jmp $1a7897	                JMP emit_1              ; No: emit one byte
.1a78f9	2b		pld		done            PLD
.1a78fa	ab		plb		                PLB
.1a78fb	28		plp		                PLP
.1a78fc	6b		rtl		                RTL
>1a78fd	41 64 64 72 65 73 73 69		MERRBADMODE     .null "Addressing mode not defined for that instruction.",CHAR_CR
>1a7905	6e 67 20 6d 6f 64 65 20 6e 6f 74 20 64 65 66 69
>1a7915	6e 65 64 20 66 6f 72 20 74 68 61 74 20 69 6e 73
>1a7925	74 72 75 63 74 69 6f 6e 2e 0d 00
>1a7930	42 61 64 20 6d 6e 65 6d		MERRBADMNEMO    .null "Bad mnemonic.",CHAR_CR
>1a7938	6f 6e 69 63 2e 0d 00
>1a793f	42 61 64 20 6f 70 65 72		MERRBADOPER     .null "Bad operand.",CHAR_CR
>1a7947	61 6e 64 2e 0d 00
>1a794d	52 65 6c 61 74 69 76 65		MERRBADOFFSET   .null "Relative offset is too large.",CHAR_CR
>1a7955	20 6f 66 66 73 65 74 20 69 73 20 74 6f 6f 20 6c
>1a7965	61 72 67 65 2e 0d 00
.1a796c					AS_PC_OFFSET
.1a796c	08		php		                PHP
.1a796d	0b		phd		                PHD
.1a796e	08		php		            PHP
.1a796f	c2 20		rep #$20	            REP #$20
.1a7971	48		pha		            PHA
.1a7972	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7975	5b		tcd		            TCD
.1a7976	68		pla		            PLA
.1a7977	28		plp		            PLP
.1a7978	e2 20		sep #$20	            SEP #$20
.1a797a	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check to see if it 1 byte or 2 byte relative
.1a797c	c9 12		cmp #$12	                CMP #ADDR_PC_REL
.1a797e	f0 0a		beq $1a798a	                BEQ is_short
.1a7980	c2 20		rep #$20	            REP #$20
.1a7982	18		clc		                CLC                     ; Branch is long. Compute where MCURSOR will be
.1a7983	a5 32		lda $087a	                LDA MCURSOR             ; with two branch offset bytes
.1a7985	69 02 00	adc #$0002	                ADC #2
.1a7988	80 08		bra $1a7992	                BRA compute_cursor
.1a798a					is_short
.1a798a	c2 20		rep #$20	            REP #$20
.1a798c	18		clc		                CLC                     ; Branch is short. Computer where MCURSOR will be
.1a798d	a5 32		lda $087a	                LDA MCURSOR             ; with one branch offset byte
.1a798f	69 01 00	adc #$0001	                ADC #1
.1a7992	85 4a		sta $0892	compute_cursor  STA MTEMP
.1a7994	a5 34		lda $087c	                LDA MCURSOR+2
.1a7996	69 00 00	adc #$0000	                ADC #0
.1a7999	85 4c		sta $0894	                STA MTEMP+2
.1a799b	38		sec		                SEC                     ; MPARSEDNUM = MPARSEDNUM - MTEMP (MCURSOR after the instruction)
.1a799c	a5 50		lda $0898	                LDA MPARSEDNUM
.1a799e	e5 4a		sbc $0892	                SBC MTEMP
.1a79a0	85 50		sta $0898	                STA MPARSEDNUM
.1a79a2	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a79a4	e5 4c		sbc $0894	                SBC MTEMP+2
.1a79a6	85 52		sta $089a	                STA MPARSEDNUM+2
.1a79a8	e2 20		sep #$20	            SEP #$20
.1a79aa	a5 4f		lda $0897	                LDA MADDR_MODE
.1a79ac	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.1a79ae	f0 1e		beq $1a79ce	                BEQ check_long
.1a79b0	a5 50		lda $0898	                LDA MPARSEDNUM          ; Short offset... check if it's negative
.1a79b2	30 0c		bmi $1a79c0	                BMI check_short_neg
.1a79b4	a5 51		lda $0899	                LDA MPARSEDNUM+1        ; Positive short offset... upper two bytes
.1a79b6	d0 2a		bne $1a79e2	                BNE failure             ; Must be 0 or it's an overflow
.1a79b8	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a79ba	d0 26		bne $1a79e2	                BNE failure
.1a79bc	a9 01		lda #$01	                LDA #1                  ; Short offset is 1 byte
.1a79be	80 26		bra $1a79e6	                BRA success
.1a79c0	a5 51		lda $0899	check_short_neg LDA MPARSEDNUM+1        ; Negative short offset... upper two bytes
.1a79c2	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's an  overflow
.1a79c4	d0 1c		bne $1a79e2	                BNE failure
.1a79c6	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a79c8	c9 ff		cmp #$ff	                CMP #$FF
.1a79ca	d0 16		bne $1a79e2	                BNE failure
.1a79cc	80 18		bra $1a79e6	                BRA success
.1a79ce	a5 51		lda $0899	check_long      LDA MPARSEDNUM+1        ; Long offset... check if it's negative
.1a79d0	30 06		bmi $1a79d8	                BMI check_long_neg
.1a79d2	a5 52		lda $089a	                LDA MPARSEDNUM+2        ; Positive long offset... upper byte
.1a79d4	d0 0c		bne $1a79e2	                BNE failure             ; Must be 0 or it's an overflow
.1a79d6	80 0e		bra $1a79e6	                BRA success
.1a79d8	a5 52		lda $089a	check_long_neg  LDA MPARSEDNUM+2        ; Negative offset... upper two bytes
.1a79da	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's and overflow
.1a79dc	d0 04		bne $1a79e2	                BNE failure
.1a79de	a9 02		lda #$02	                LDA #2                  ; Long offset is 2 bytes
.1a79e0	80 04		bra $1a79e6	                BRA success
.1a79e2	2b		pld		failure         PLD
.1a79e3	28		plp		                PLP
.1a79e4	18		clc		                CLC
.1a79e5	6b		rtl		                RTL
.1a79e6	2b		pld		success         PLD
.1a79e7	28		plp		                PLP
.1a79e8	38		sec		                SEC
.1a79e9	6b		rtl		                RTL
.1a79ea					AS_SHIFT_HEX
.1a79ea	08		php		                PHP
.1a79eb	0b		phd		                PHD
.1a79ec	c2 10		rep #$10	            REP #$10
.1a79ee	da		phx		                PHX
.1a79ef	08		php		            PHP
.1a79f0	c2 20		rep #$20	            REP #$20
.1a79f2	48		pha		            PHA
.1a79f3	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a79f6	5b		tcd		            TCD
.1a79f7	68		pla		            PLA
.1a79f8	28		plp		            PLP
.1a79f9	e2 20		sep #$20	            SEP #$20
.1a79fb	a2 00 00	ldx #$0000	                LDX #0
.1a79fe	df 00 d0 1a	cmp $1ad000,x	seek_loop       CMP @lHEXDIGITS,X   ; Check the passed character against the hex digits
.1a7a02	f0 08		beq $1a7a0c	                BEQ found
.1a7a04	e8		inx		                INX                 ; Go to the next hex digit
.1a7a05	e0 10 00	cpx #$0010	                CPX #$10            ; Are we out of digits?
.1a7a08	f0 1b		beq $1a7a25	                BEQ done            ; Yes... just return
.1a7a0a	80 f2		bra $1a79fe	                BRA seek_loop
.1a7a0c					found
.1a7a0c	c2 20		rep #$20	            REP #$20
.1a7a0e	06 50		asl $0898	                ASL MPARSEDNUM
.1a7a10	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7a12	06 50		asl $0898	                ASL MPARSEDNUM
.1a7a14	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7a16	06 50		asl $0898	                ASL MPARSEDNUM
.1a7a18	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7a1a	06 50		asl $0898	                ASL MPARSEDNUM
.1a7a1c	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a7a1e	e2 20		sep #$20	            SEP #$20
.1a7a20	8a		txa		                TXA
.1a7a21	05 50		ora $0898	                ORA MPARSEDNUM
.1a7a23	85 50		sta $0898	                STA MPARSEDNUM
.1a7a25	fa		plx		done            PLX
.1a7a26	2b		pld		                PLD
.1a7a27	28		plp		                PLP
.1a7a28	6b		rtl		                RTL
.1a7a29					AS_FIND_OPCODE
.1a7a29	0b		phd		                PHD
.1a7a2a	8b		phb		                PHB
.1a7a2b	08		php		            PHP
.1a7a2c	c2 20		rep #$20	            REP #$20
.1a7a2e	48		pha		            PHA
.1a7a2f	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7a32	5b		tcd		            TCD
.1a7a33	68		pla		            PLA
.1a7a34	28		plp		            PLP
.1a7a35	08		php		            PHP
.1a7a36	e2 20		sep #$20	            SEP #$20
.1a7a38	48		pha		            PHA
.1a7a39	a9 1a		lda #$1a	            LDA #`MNEMONIC_TAB
.1a7a3b	48		pha		            PHA
.1a7a3c	ab		plb		            PLB
.1a7a3d	68		pla		            PLA
.1a7a3e	28		plp		            PLP
.1a7a3f	e2 20		sep #$20	            SEP #$20
.1a7a41	a5 4f		lda $0897	                LDA MADDR_MODE
.1a7a43	29 3f		and #$3f	                AND #%00111111
.1a7a45	85 4a		sta $0892	                STA MTEMP
.1a7a47	c2 30		rep #$30	            REP #$30
.1a7a49	a2 00 00	ldx #$0000	                LDX #0
.1a7a4c	a0 00 00	ldy #$0000	                LDY #0
.1a7a4f	bd f6 80	lda $1a80f6,x	mnemonic_loop   LDA MNEMONIC_TAB,X      ; Get the mnemonic from the opcode table
.1a7a52	f0 1b		beq $1a7a6f	                BEQ not_found           ; If it's 0, we did not find the mnemonic
.1a7a54	c5 54		cmp $089c	                CMP MMNEMONIC           ; Does it match the passed mnemonic?
.1a7a56	d0 0d		bne $1a7a65	                BNE next_opcode         ; No: go to the next opcode
.1a7a58					check_mode
.1a7a58	e2 20		sep #$20	            SEP #$20
.1a7a5a	b9 f8 82	lda $1a82f8,y	                LDA ADDRESS_TAB,Y       ; Get the corresponding address mode
.1a7a5d	29 3f		and #$3f	                AND #%00111111          ; Filter out effect bits
.1a7a5f	c5 4a		cmp $0892	                CMP MTEMP
.1a7a61	f0 07		beq $1a7a6a	                BEQ found               ; Yes: we found the opcode
.1a7a63	c2 20		rep #$20	            REP #$20
.1a7a65	e8		inx		next_opcode     INX                     ; Point to the next mnemonic in the table
.1a7a66	e8		inx		                INX
.1a7a67	c8		iny		                INY
.1a7a68	80 e5		bra $1a7a4f	                BRA mnemonic_loop       ; And check it
.1a7a6a	98		tya		found           TYA
.1a7a6b	38		sec		                SEC                     ; Set carry to show success
.1a7a6c	ab		plb		                PLB
.1a7a6d	2b		pld		                PLD
.1a7a6e	6b		rtl		                RTL
.1a7a6f	18		clc		not_found       CLC                     ; Clear carry to show failure
.1a7a70	ab		plb		                PLB
.1a7a71	2b		pld		                PLD
.1a7a72	6b		rtl		                RTL
.1a7a73					AS_STR_MATCH
.1a7a73	08		php		                PHP
.1a7a74	0b		phd		                PHD
.1a7a75	08		php		            PHP
.1a7a76	c2 20		rep #$20	            REP #$20
.1a7a78	48		pha		            PHA
.1a7a79	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7a7c	5b		tcd		            TCD
.1a7a7d	68		pla		            PLA
.1a7a7e	28		plp		            PLP
.1a7a7f	e2 20		sep #$20	            SEP #$20
.1a7a81	c2 10		rep #$10	            REP #$10
.1a7a83	a0 00 00	ldy #$0000	                LDY #0
.1a7a86	64 50		stz $0898	                STZ MPARSEDNUM      ; Set parsed number to 0 in anticipation of
.1a7a88	64 52		stz $089a	                STZ MPARSEDNUM+2    ; hex digits in the pattern
.1a7a8a	b7 03		lda [$084b],y	match_loop      LDA [MCMP_TEXT],Y   ; Get the pattern character
.1a7a8c	f0 11		beq $1a7a9f	                BEQ nul_check       ; If at end of pattern, check for end of test string
.1a7a8e	c9 64		cmp #$64	                CMP #'d'            ; Is it a digit?
.1a7a90	f0 19		beq $1a7aab	                BEQ check_digit     ; Yes: do special check for hex digit
.1a7a92	48		pha		compare         PHA
.1a7a93	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.1a7a95	85 4a		sta $0892	                STA MTEMP
.1a7a97	68		pla		                PLA
.1a7a98	c5 4a		cmp $0892	                CMP MTEMP           ; Does it match the character to test?
.1a7a9a	d0 0b		bne $1a7aa7	                BNE return_false    ; No: return fail
.1a7a9c	c8		iny		next_char       INY                 ; Yes: test the next character
.1a7a9d	80 eb		bra $1a7a8a	                BRA match_loop
.1a7a9f	b7 36		lda [$087e],y	nul_check       LDA [MLINEBUF],Y    ; Check to see that we're at the end of the test string
.1a7aa1	d0 04		bne $1a7aa7	                BNE return_false    ; If not: return false
.1a7aa3	2b		pld		return_true     PLD
.1a7aa4	28		plp		                PLP                 ; Return true
.1a7aa5	38		sec		                SEC
.1a7aa6	6b		rtl		                RTL
.1a7aa7	2b		pld		return_false    PLD
.1a7aa8	28		plp		                PLP                 ; Return false
.1a7aa9	18		clc		                CLC
.1a7aaa	6b		rtl		                RTL
.1a7aab					check_digit
.1a7aab	e2 20		sep #$20	            SEP #$20
.1a7aad	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.1a7aaf	c9 3a		cmp #$3a	                CMP #'9'+1
.1a7ab1	b0 04		bcs $1a7ab7	                BCS check_AF
.1a7ab3	c9 30		cmp #$30	                CMP #'0'
.1a7ab5	b0 14		bcs $1a7acb	                BCS shift_digit     ; character is in [0..9]
.1a7ab7	c9 47		cmp #$47	check_AF        CMP #'F'+1
.1a7ab9	b0 04		bcs $1a7abf	                BCS check_lc        ; check lower case
.1a7abb	c9 41		cmp #$41	                CMP #'A'
.1a7abd	b0 0c		bcs $1a7acb	                BCS shift_digit     ; character is in [A..F]
.1a7abf	c9 67		cmp #$67	check_lc        CMP #'f'+1
.1a7ac1	b0 e4		bcs $1a7aa7	                BCS return_false    ; check lower case
.1a7ac3	c9 61		cmp #$61	                CMP #'a'
.1a7ac5	b0 02		bcs $1a7ac9	                BCS to_upcase       ; character is in [A..F]
.1a7ac7	80 de		bra $1a7aa7	                BRA return_false    ; No match found... return false
.1a7ac9	29 df		and #$df	to_upcase       AND #%11011111      ; Convert lower case to upper case
.1a7acb	22 ea 79 1a	jsl $1a79ea	shift_digit     JSL AS_SHIFT_HEX    ; Shift the digit into MPARSEDNUM
.1a7acf	80 cb		bra $1a7a9c	                BRA next_char       ; And check the next character
.1a7ad1					AS_MCMP_NEXT
.1a7ad1	0b		phd		                PHD
.1a7ad2	08		php		            PHP
.1a7ad3	c2 20		rep #$20	            REP #$20
.1a7ad5	48		pha		            PHA
.1a7ad6	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7ad9	5b		tcd		            TCD
.1a7ada	68		pla		            PLA
.1a7adb	28		plp		            PLP
.1a7adc	a0 00 00	ldy #$0000	                LDY #0
.1a7adf	e2 20		sep #$20	            SEP #$20
.1a7ae1	b7 03		lda [$084b],y	loop            LDA [MCMP_TEXT],Y   ; Check to see if we have gotten to the NUL
.1a7ae3	f0 03		beq $1a7ae8	                BEQ found_nul
.1a7ae5	c8		iny		                INY
.1a7ae6	80 f9		bra $1a7ae1	                BRA loop
.1a7ae8					found_nul
.1a7ae8	c2 20		rep #$20	            REP #$20
.1a7aea	c8		iny		                INY                 ; Got to NUL... point to next byte
.1a7aeb	5a		phy		                PHY
.1a7aec	68		pla		                PLA                 ; And add that index to MCMP_TEXT pointer
.1a7aed	18		clc		                CLC
.1a7aee	65 03		adc $084b	                ADC MCMP_TEXT
.1a7af0	85 03		sta $084b	                STA MCMP_TEXT
.1a7af2	a5 05		lda $084d	                LDA MCMP_TEXT+2
.1a7af4	69 00 00	adc #$0000	                ADC #0
.1a7af7	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7af9	2b		pld		                PLD
.1a7afa	6b		rtl		                RTL
.1a7afb					AS_FIND_MNEMO
.1a7afb	0b		phd		                PHD
.1a7afc	08		php		            PHP
.1a7afd	c2 20		rep #$20	            REP #$20
.1a7aff	48		pha		            PHA
.1a7b00	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7b03	5b		tcd		            TCD
.1a7b04	68		pla		            PLA
.1a7b05	28		plp		            PLP
.1a7b06	c2 20		rep #$20	            REP #$20
.1a7b08	a5 11		lda $0859	                LDA MARG2                   ; Point MLINEBUF to the text
.1a7b0a	85 36		sta $087e	                STA MLINEBUF
.1a7b0c	a5 13		lda $085b	                LDA MARG2+2
.1a7b0e	85 38		sta $0880	                STA MLINEBUF+2
.1a7b10	a9 84 7f	lda #$7f84	                LDA #<>MNEMONICS_TAB        ; Point to the first mnemonic
.1a7b13	85 03		sta $084b	                STA MCMP_TEXT
.1a7b15	a9 1a 00	lda #$001a	                LDA #`MNEMONICS_TAB
.1a7b18	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7b1a	22 73 7a 1a	jsl $1a7a73	match_loop      JSL AS_STR_MATCH            ; Check to see if the text matches the mnemonic
.1a7b1e	b0 0d		bcs $1a7b2d	                BCS found_mnemonic          ; If so: return that we found it
.1a7b20	22 d1 7a 1a	jsl $1a7ad1	                JSL AS_MCMP_NEXT            ; Point to the next mnemonic
.1a7b24	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Check to see if it's NUL
.1a7b26	d0 f2		bne $1a7b1a	                BNE match_loop              ; If not, check this next mnemonic
.1a7b28	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Otherwise, return -1
.1a7b2b	80 02		bra $1a7b2f	                BRA done
.1a7b2d	a5 03		lda $084b	found_mnemonic  LDA MCMP_TEXT               ; Found it: return the address
.1a7b2f	2b		pld		done            PLD
.1a7b30	6b		rtl		                RTL
.1a7b31					AS_FIND_MODE
.1a7b31	08		php		                PHP
.1a7b32	0b		phd		                PHD
.1a7b33	08		php		            PHP
.1a7b34	c2 20		rep #$20	            REP #$20
.1a7b36	48		pha		            PHA
.1a7b37	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7b3a	5b		tcd		            TCD
.1a7b3b	68		pla		            PLA
.1a7b3c	28		plp		            PLP
.1a7b3d	c2 30		rep #$30	            REP #$30
.1a7b3f	a5 15		lda $085d	                LDA MARG3                   ; Point MLINEBUF to the operand
.1a7b41	85 36		sta $087e	                STA MLINEBUF
.1a7b43	a5 17		lda $085f	                LDA MARG3+2
.1a7b45	85 38		sta $0880	                STA MLINEBUF+2
.1a7b47	a9 10 84	lda #$8410	                LDA #<>ADDR_PATTERNS        ; Point to the first address mode pattern to check
.1a7b4a	85 03		sta $084b	                STA MCMP_TEXT
.1a7b4c	a9 1a 00	lda #$001a	                LDA #`ADDR_PATTERNS
.1a7b4f	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7b51	22 73 7a 1a	jsl $1a7a73	match_loop      JSL AS_STR_MATCH            ; Check to see if the pattern matches the operand
.1a7b55	b0 22		bcs $1a7b79	                BCS is_match                ; Yes: Find address mode code
.1a7b57	22 d1 7a 1a	jsl $1a7ad1	                JSL AS_MCMP_NEXT            ; Point to the address mode
.1a7b5b	c2 20		rep #$20	            REP #$20
.1a7b5d	18		clc		                CLC                         ; Point to the first byte of the next pattern
.1a7b5e	a5 03		lda $084b	                LDA MCMP_TEXT
.1a7b60	69 01 00	adc #$0001	                ADC #1
.1a7b63	85 03		sta $084b	                STA MCMP_TEXT
.1a7b65	a5 05		lda $084d	                LDA MCMP_TEXT+2
.1a7b67	69 00 00	adc #$0000	                ADC #0
.1a7b6a	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7b6c	e2 20		sep #$20	            SEP #$20
.1a7b6e	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Is the first byte 0?
.1a7b70	d0 df		bne $1a7b51	                BNE match_loop              ; No: check this next pattern
.1a7b72	c2 20		rep #$20	            REP #$20
.1a7b74	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Yes: we didn't find a matching pattern, return -1
.1a7b77	80 0d		bra $1a7b86	                BRA done
.1a7b79	22 d1 7a 1a	jsl $1a7ad1	is_match        JSL AS_MCMP_NEXT            ; Point to the address mode
.1a7b7d	e2 20		sep #$20	            SEP #$20
.1a7b7f	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Get the corresponding address mode code (a byte)
.1a7b81	c2 20		rep #$20	            REP #$20
.1a7b83	29 ff 00	and #$00ff	                AND #$00FF
.1a7b86	2b		pld		done            PLD
.1a7b87	28		plp		                PLP
.1a7b88	6b		rtl		                RTL
.1a7b89					IMDISASSEMBLE
.1a7b89	08		php		                PHP
.1a7b8a	8b		phb		                PHB
.1a7b8b	0b		phd		                PHD
.1a7b8c	08		php		            PHP
.1a7b8d	c2 20		rep #$20	            REP #$20
.1a7b8f	48		pha		            PHA
.1a7b90	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7b93	5b		tcd		            TCD
.1a7b94	68		pla		            PLA
.1a7b95	28		plp		            PLP
.1a7b96	e2 20		sep #$20	            SEP #$20
.1a7b98	a9 00		lda #$00	                LDA #0
.1a7b9a	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT     ; Clear the pagination line counter
.1a7b9e	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.1a7ba0	c9 02		cmp #$02	                CMP #2
.1a7ba2	b0 16		bcs $1a7bba	                BGE set_cursor      ; 2>= arguments? Use them as-is
.1a7ba4	c9 01		cmp #$01	                CMP #1
.1a7ba6	90 20		bcc $1a7bc8	                BLT no_args         ; No arguments passed? Use defaults
.1a7ba8	c2 20		rep #$20	            REP #$20
.1a7baa	18		clc		                CLC
.1a7bab	a5 0d		lda $0855	                LDA MARG1
.1a7bad	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a7bb0	85 11		sta $0859	                STA MARG2
.1a7bb2	e2 20		sep #$20	            SEP #$20
.1a7bb4	a5 0f		lda $0857	                LDA MARG1+2
.1a7bb6	69 00		adc #$00	                ADC #0
.1a7bb8	85 13		sta $085b	                STA MARG2+2
.1a7bba					set_cursor
.1a7bba	c2 20		rep #$20	            REP #$20
.1a7bbc	a5 0d		lda $0855	                LDA MARG1
.1a7bbe	85 32		sta $087a	                STA MCURSOR
.1a7bc0	e2 20		sep #$20	            SEP #$20
.1a7bc2	a5 0f		lda $0857	                LDA MARG1+2
.1a7bc4	85 34		sta $087c	                STA MCURSOR+2
.1a7bc6	80 12		bra $1a7bda	                BRA dasm_loop
.1a7bc8					no_args
.1a7bc8	c2 20		rep #$20	            REP #$20
.1a7bca	18		clc		                CLC
.1a7bcb	a5 32		lda $087a	                LDA MCURSOR
.1a7bcd	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a7bd0	85 11		sta $0859	                STA MARG2
.1a7bd2	e2 20		sep #$20	            SEP #$20
.1a7bd4	a5 34		lda $087c	                LDA MCURSOR+2
.1a7bd6	69 00		adc #$00	                ADC #0
.1a7bd8	85 13		sta $085b	                STA MARG2+2
.1a7bda	22 f5 7b 1a	jsl $1a7bf5	dasm_loop       JSL DS_PR_LINE
.1a7bde	e2 20		sep #$20	            SEP #$20
.1a7be0	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.1a7be2	c5 13		cmp $085b	                CMP MARG2+2
.1a7be4	90 f4		bcc $1a7bda	                BLT dasm_loop           ; No: continue
.1a7be6	c2 20		rep #$20	            REP #$20
.1a7be8	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.1a7bea	c5 11		cmp $0859	                CMP MARG2
.1a7bec	90 ec		bcc $1a7bda	                BLT dasm_loop           ; Nope... keep going
.1a7bee					done
.1a7bee	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a7bf1	2b		pld		                PLD
.1a7bf2	ab		plb		                PLB
.1a7bf3	28		plp		                PLP
.1a7bf4	6b		rtl		                RTL
.1a7bf5					DS_PR_LINE
.1a7bf5	08		php		                PHP
.1a7bf6	0b		phd		                PHD
.1a7bf7	e2 20		sep #$20	            SEP #$20
.1a7bf9	a9 41		lda #$41	                LDA #'A'
.1a7bfb	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7bfe	a9 20		lda #$20	                LDA #' '
.1a7c00	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7c03	08		php		            PHP
.1a7c04	c2 20		rep #$20	            REP #$20
.1a7c06	48		pha		            PHA
.1a7c07	a9 7a 08	lda #$087a	            LDA #MCURSOR
.1a7c0a	5b		tcd		            TCD
.1a7c0b	68		pla		            PLA
.1a7c0c	28		plp		            PLP
.1a7c0d	c2 20		rep #$20	            REP #$20
.1a7c0f	a5 00		lda $087a	                LDA MCURSOR
.1a7c11	85 18		sta $0892	                STA MTEMP
.1a7c13	e2 20		sep #$20	            SEP #$20
.1a7c15	a5 02		lda $087c	                LDA MCURSOR+2
.1a7c17	85 1a		sta $0894	                STA MTEMP+2
.1a7c19	22 5c 7f 1a	jsl $1a7f5c	                JSL M_PR_ADDR
.1a7c1d	a9 20		lda #$20	                LDA #' '
.1a7c1f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7c22	c2 20		rep #$20	            REP #$20
.1a7c24	18		clc		                CLC
.1a7c25	a5 00		lda $087a	                LDA MCURSOR
.1a7c27	69 01 00	adc #$0001	                ADC #1
.1a7c2a	85 18		sta $0892	                STA MTEMP
.1a7c2c	e2 20		sep #$20	            SEP #$20
.1a7c2e	a5 02		lda $087c	                LDA MCURSOR+2
.1a7c30	69 00		adc #$00	                ADC #0
.1a7c32	85 1a		sta $0894	                STA MTEMP+2
.1a7c34	e2 20		sep #$20	            SEP #$20
.1a7c36	c2 10		rep #$10	            REP #$10
.1a7c38	a7 00		lda [$087a]	                LDA [MCURSOR]           ; Get the mnemonic
.1a7c3a	c9 c2		cmp #$c2	                CMP #$C2                ; Is it REP?
.1a7c3c	d0 0b		bne $1a7c49	                BNE check_sep           ; No: check to see if it is SEP
.1a7c3e	48		pha		handle_rep      PHA
.1a7c3f	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.1a7c41	49 ff		eor #$ff	                EOR #$FF                ; Invert the bits
.1a7c43	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Mask off the bits in the CPUSTAT
.1a7c47	80 0b		bra $1a7c54	                BRA save_stat
.1a7c49	c9 e2		cmp #$e2	check_sep       CMP #$E2                ; Is it SEP?
.1a7c4b	d0 0c		bne $1a7c59	                BNE get_op_index        ; No: process the instruction regularly
.1a7c4d	48		pha		handle_sep      PHA
.1a7c4e	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.1a7c50	0f 96 08 00	ora $000896	                ORA @lMCPUSTAT          ; Activate the bits in the CPUSTAT
.1a7c54	8f 96 08 00	sta $000896	save_stat       STA @lMCPUSTAT          ; And save it back
.1a7c58	68		pla		                PLA
.1a7c59					get_op_index
.1a7c59	c2 20		rep #$20	            REP #$20
.1a7c5b	29 ff 00	and #$00ff	                AND #$00FF
.1a7c5e	0a		asl a		                ASL A
.1a7c5f	aa		tax		                TAX                     ; Get the index into the mnemonic lookup table
.1a7c60	bf f6 80 1a	lda $1a80f6,x	                LDA @lMNEMONIC_TAB,X    ; Get the mnemonic
.1a7c64	aa		tax		                TAX
.1a7c65	22 d6 7e 1a	jsl $1a7ed6	                JSL DS_PR_MNEMONIC      ; And print it
.1a7c69	e2 20		sep #$20	            SEP #$20
.1a7c6b	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a7c6d	aa		tax		                TAX
.1a7c6e	bf f8 82 1a	lda $1a82f8,x	pr_operand      LDA @lADDRESS_TAB,X     ; Get the addressing mode for the instruction
.1a7c72	22 b2 84 1a	jsl $1a84b2	                JSL M_INC_CURSOR        ; Advance the cursor to the next byte
.1a7c76	22 83 7c 1a	jsl $1a7c83	                JSL DS_PR_OPERAND       ; And print the correct operand
.1a7c7a	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a7c7d	20 d9 02	jsr $1a02d9	            JSR PAGINATE
.1a7c80	2b		pld		                PLD
.1a7c81	28		plp		                PLP
.1a7c82	6b		rtl		                RTL
.1a7c83					DS_PR_OPERAND
.1a7c83	08		php		                PHP
.1a7c84	e2 20		sep #$20	            SEP #$20
.1a7c86	48		pha		                PHA             ; Save the address mode so we can get to the M and X flags
.1a7c87	29 3f		and #$3f	                AND #%00111111  ; Filter out the mode flags
.1a7c89	0a		asl a		                ASL A           ; Compute the index to the table
.1a7c8a	c2 10		rep #$10	            REP #$10
.1a7c8c	aa		tax		                TAX
.1a7c8d	68		pla		                PLA             ; Restore A
.1a7c8e	7c 91 7c	jmp ($1a7c91,x)	                JMP (dispatch,X)
>1a7c91	c1 7c				dispatch        .word <>is_dp_ind_x
>1a7c93	dc 7c				                .word <>is_dp
>1a7c95	e3 7c				                .word <>is_imm
>1a7c97	08 7d				                .word <>is_abs
>1a7c99	0f 7d				                .word <>is_dp_ind_y
>1a7c9b	2a 7d				                .word <>is_dp_x
>1a7c9d	4c 7d				                .word <>is_abs_y
>1a7c9f	5d 7d				                .word <>is_abs_x
>1a7ca1	9a 7d				                .word <>is_accumulator
>1a7ca3	a2 7d				                .word <>is_stack_r
>1a7ca5	b3 7d				                .word <>is_dp_long
>1a7ca7	c4 7d				                .word <>is_abs_long
>1a7ca9	cb 7d				                .word <>is_stack_r_y
>1a7cab	f0 7d				                .word <>is_dp_y_long
>1a7cad	1d 7e				                .word <>is_abs_x_long
>1a7caf	89 7d				                .word <>is_dp_ind
>1a7cb1	6e 7d				                .word <>is_abs_x_id
>1a7cb3	3b 7d				                .word <>is_dp_y
>1a7cb5	10 7e				                .word <>is_pc_rel
>1a7cb7	1a 7e				                .word <>is_implied
>1a7cb9	2e 7e				                .word <>is_xyc
>1a7cbb	5d 7e				                .word <>is_abs_ind
>1a7cbd	0b 7e				                .word <>is_pc_rel_long
>1a7cbf	6e 7e				                .word <>is_abs_ind_long
.1a7cc1	a9 28		lda #$28	is_dp_ind_x     LDA #'('                ; Print (dd,X)
.1a7cc3	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7cc6	22 85 7e 1a	jsl $1a7e85	                JSL DS_PR_OPERAND1      ; Print dd
.1a7cca	a9 2c		lda #$2c	                LDA #','
.1a7ccc	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ccf	a9 58		lda #$58	                LDA #'X'
.1a7cd1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7cd4	a9 29		lda #$29	                LDA #')'
.1a7cd6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7cd9	4c 7f 7e	jmp $1a7e7f	                JMP done_1
.1a7cdc	22 85 7e 1a	jsl $1a7e85	is_dp           JSL DS_PR_OPERAND1      ; Print dd
.1a7ce0	4c 7f 7e	jmp $1a7e7f	                JMP done_1
.1a7ce3					is_imm
.1a7ce3	e2 20		sep #$20	            SEP #$20
.1a7ce5	48		pha		                PHA
.1a7ce6	a9 23		lda #$23	                LDA #'#'
.1a7ce8	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ceb	68		pla		                PLA
.1a7cec	29 c0		and #$c0	                AND #%11000000          ; Filter so we just look at the mode bits
.1a7cee	c9 00		cmp #$00	                CMP #$00                ; Are any set to check?
.1a7cf0	f0 0f		beq $1a7d01	                BEQ is_imm_short        ; No: treat it as a short always
.1a7cf2	4a		lsr a		                LSR A                   ; Move the flag bits right by 2 to match
.1a7cf3	4a		lsr a		                LSR A                   ; the positions of the bits in the CPU status register
.1a7cf4	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Otherwise, filter the mode bit we care about
.1a7cf8	d0 07		bne $1a7d01	                BNE is_imm_short        ; If it is set, immediate operation is short
.1a7cfa	22 8f 7e 1a	jsl $1a7e8f	                JSL DS_PR_OPERAND2      ; Print dddd
.1a7cfe	4c 7f 7e	jmp $1a7e7f	                JMP done_1
.1a7d01	22 85 7e 1a	jsl $1a7e85	is_imm_short    JSL DS_PR_OPERAND1      ; Print dd
.1a7d05	4c 7f 7e	jmp $1a7e7f	                JMP done_1
.1a7d08	22 8f 7e 1a	jsl $1a7e8f	is_abs          JSL DS_PR_OPERAND2      ; Print dddd
.1a7d0c	4c 7f 7e	jmp $1a7e7f	                JMP done_1
.1a7d0f	a9 28		lda #$28	is_dp_ind_y     LDA #'('                ; Print (dd),Y
.1a7d11	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d14	22 85 7e 1a	jsl $1a7e85	                JSL DS_PR_OPERAND1      ; Print dd
.1a7d18	a9 29		lda #$29	                LDA #')'
.1a7d1a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d1d	a9 2c		lda #$2c	                LDA #','
.1a7d1f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d22	a9 59		lda #$59	                LDA #'Y'
.1a7d24	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d27	4c 7f 7e	jmp $1a7e7f	                JMP done_1
.1a7d2a	22 85 7e 1a	jsl $1a7e85	is_dp_x         JSL DS_PR_OPERAND1      ; Print dd,X
.1a7d2e	a9 2c		lda #$2c	                LDA #','
.1a7d30	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d33	a9 58		lda #$58	                LDA #'X'
.1a7d35	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d38	4c 7f 7e	jmp $1a7e7f	                JMP done_1
.1a7d3b	22 85 7e 1a	jsl $1a7e85	is_dp_y         JSL DS_PR_OPERAND1      ; Print dd,Y
.1a7d3f	a9 2c		lda #$2c	                LDA #','
.1a7d41	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d44	a9 59		lda #$59	                LDA #'Y'
.1a7d46	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d49	4c 7f 7e	jmp $1a7e7f	                JMP done_1
.1a7d4c	22 8f 7e 1a	jsl $1a7e8f	is_abs_y        JSL DS_PR_OPERAND2      ; Print dddd,Y
.1a7d50	a9 2c		lda #$2c	                LDA #','
.1a7d52	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d55	a9 59		lda #$59	                LDA #'Y'
.1a7d57	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d5a	4c 7f 7e	jmp $1a7e7f	                JMP done_1
.1a7d5d	22 8f 7e 1a	jsl $1a7e8f	is_abs_x        JSL DS_PR_OPERAND2      ; Print dddd,X
.1a7d61	a9 2c		lda #$2c	                LDA #','
.1a7d63	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d66	a9 58		lda #$58	                LDA #'X'
.1a7d68	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d6b	4c 7f 7e	jmp $1a7e7f	                JMP done_1
.1a7d6e	a9 28		lda #$28	is_abs_x_id     LDA #'('
.1a7d70	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d73	22 8f 7e 1a	jsl $1a7e8f	                JSL DS_PR_OPERAND2      ; Print (dddd,X)
.1a7d77	a9 2c		lda #$2c	                LDA #','
.1a7d79	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d7c	a9 58		lda #$58	                LDA #'X'
.1a7d7e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d81	a9 29		lda #$29	                LDA #')'
.1a7d83	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d86	4c 7f 7e	jmp $1a7e7f	                JMP done_1
.1a7d89	a9 28		lda #$28	is_dp_ind       LDA #'('
.1a7d8b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d8e	22 85 7e 1a	jsl $1a7e85	                JSL DS_PR_OPERAND1      ; Print (dd)
.1a7d92	a9 29		lda #$29	                LDA #')'
.1a7d94	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d97	4c 7f 7e	jmp $1a7e7f	                JMP done_1
.1a7d9a	a9 41		lda #$41	is_accumulator  LDA #'A'                ; Print A
.1a7d9c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d9f	4c 83 7e	jmp $1a7e83	                JMP done
.1a7da2	22 85 7e 1a	jsl $1a7e85	is_stack_r      JSL DS_PR_OPERAND1      ; Print dd,S
.1a7da6	a9 2c		lda #$2c	                LDA #','
.1a7da8	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7dab	a9 53		lda #$53	                LDA #'S'
.1a7dad	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7db0	4c 7f 7e	jmp $1a7e7f	                JMP done_1
.1a7db3	a9 5b		lda #$5b	is_dp_long      LDA #'['                ; [dd]
.1a7db5	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7db8	22 85 7e 1a	jsl $1a7e85	                JSL DS_PR_OPERAND1      ; Print dd
.1a7dbc	a9 5d		lda #$5d	                LDA #']'
.1a7dbe	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7dc1	4c 7f 7e	jmp $1a7e7f	                JMP done_1
.1a7dc4	22 9d 7e 1a	jsl $1a7e9d	is_abs_long     JSL DS_PR_OPERAND3      ; Print dddddd
.1a7dc8	4c 83 7e	jmp $1a7e83	                JMP done
.1a7dcb	a9 28		lda #$28	is_stack_r_y    LDA #'('                ; (dd,S),Y
.1a7dcd	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7dd0	22 85 7e 1a	jsl $1a7e85	                JSL DS_PR_OPERAND1      ; Print dd
.1a7dd4	a9 2c		lda #$2c	                LDA #','
.1a7dd6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7dd9	a9 53		lda #$53	                LDA #'S'
.1a7ddb	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7dde	a9 29		lda #$29	                LDA #')'
.1a7de0	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7de3	a9 2c		lda #$2c	                LDA #','
.1a7de5	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7de8	a9 59		lda #$59	                LDA #'Y'
.1a7dea	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ded	4c 7f 7e	jmp $1a7e7f	                JMP done_1
.1a7df0	a9 5b		lda #$5b	is_dp_y_long    LDA #'['                ; [dd],Y
.1a7df2	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7df5	22 85 7e 1a	jsl $1a7e85	                JSL DS_PR_OPERAND1      ; Print dd
.1a7df9	a9 5d		lda #$5d	                LDA #']'
.1a7dfb	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7dfe	a9 2c		lda #$2c	                LDA #','
.1a7e00	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e03	a9 59		lda #$59	                LDA #'Y'
.1a7e05	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e08	4c 7f 7e	jmp $1a7e7f	                JMP done_1
.1a7e0b	a0 02 00	ldy #$0002	is_pc_rel_long  LDY #2
.1a7e0e	80 03		bra $1a7e13	                BRA do_pcrel
.1a7e10	a0 01 00	ldy #$0001	is_pc_rel       LDY #1
.1a7e13	22 03 7f 1a	jsl $1a7f03	do_pcrel        JSL DS_PR_PCREL
.1a7e17	4c 83 7e	jmp $1a7e83	                JMP done
.1a7e1a	4c 83 7e	jmp $1a7e83	is_implied      JMP done
.1a7e1d	22 9d 7e 1a	jsl $1a7e9d	is_abs_x_long   JSL DS_PR_OPERAND3      ; Print dddddd
.1a7e21	a9 2c		lda #$2c	                LDA #','
.1a7e23	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e26	a9 58		lda #$58	                LDA #'X'
.1a7e28	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e2b	4c 83 7e	jmp $1a7e83	                JMP done
.1a7e2e	a9 23		lda #$23	is_xyc          LDA #'#'
.1a7e30	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e33	8b		phb		                PHB                     ; Make sure the databank is pointed to our number
.1a7e34	a5 02		lda $087c	                LDA MCURSOR+2
.1a7e36	48		pha		                PHA
.1a7e37	ab		plb		                PLB
.1a7e38	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.1a7e3a	e8		inx		                INX
.1a7e3b	a0 01 00	ldy #$0001	                LDY #1
.1a7e3e	22 d2 02 1a	jsl $1a02d2	                JSL PRINTH
.1a7e42	a9 2c		lda #$2c	                LDA #','
.1a7e44	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e47	a9 23		lda #$23	                LDA #'#'
.1a7e49	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e4c	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.1a7e4e	a0 01 00	ldy #$0001	                LDY #1
.1a7e51	22 d2 02 1a	jsl $1a02d2	                JSL PRINTH
.1a7e55	ab		plb		                PLB                     ; Get our old data bank back
.1a7e56	22 b2 84 1a	jsl $1a84b2	                JSL M_INC_CURSOR
.1a7e5a	4c 7f 7e	jmp $1a7e7f	                JMP done_1
.1a7e5d	a9 28		lda #$28	is_abs_ind      LDA #'('
.1a7e5f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e62	22 8f 7e 1a	jsl $1a7e8f	                JSL DS_PR_OPERAND2      ; Print (dddd)
.1a7e66	a9 29		lda #$29	                LDA #')'
.1a7e68	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e6b	4c 7f 7e	jmp $1a7e7f	                JMP done_1
.1a7e6e	a9 5b		lda #$5b	is_abs_ind_long LDA #'['
.1a7e70	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e73	22 8f 7e 1a	jsl $1a7e8f	                JSL DS_PR_OPERAND2      ; Print [dddd]
.1a7e77	a9 5d		lda #$5d	                LDA #']'
.1a7e79	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e7c	4c 7f 7e	jmp $1a7e7f	                JMP done_1
.1a7e7f	22 b2 84 1a	jsl $1a84b2	done_1          JSL M_INC_CURSOR    ; Skip over a single byte operand
.1a7e83	28		plp		done            PLP
.1a7e84	6b		rtl		                RTL
.1a7e85					DS_PR_OPERAND1
.1a7e85	08		php		                PHP
.1a7e86	e2 20		sep #$20	            SEP #$20
.1a7e88	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a7e8a	20 79 03	jsr $1a0379	            JSR PRHEXB
.1a7e8d	28		plp		                PLP
.1a7e8e	6b		rtl		                RTL
.1a7e8f					DS_PR_OPERAND2
.1a7e8f	08		php		                PHP
.1a7e90	c2 30		rep #$30	            REP #$30
.1a7e92	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a7e94	20 5f 03	jsr $1a035f	            JSR PRHEXW
.1a7e97	22 b2 84 1a	jsl $1a84b2	                JSL M_INC_CURSOR
.1a7e9b	28		plp		                PLP
.1a7e9c	6b		rtl		                RTL
.1a7e9d					DS_PR_OPERAND3
.1a7e9d	08		php		                PHP
.1a7e9e	8b		phb		                PHB
.1a7e9f	0b		phd		                PHD
.1a7ea0	c2 30		rep #$30	            REP #$30
.1a7ea2	5a		phy		                PHY
.1a7ea3	08		php		            PHP
.1a7ea4	c2 20		rep #$20	            REP #$20
.1a7ea6	48		pha		            PHA
.1a7ea7	a9 7a 08	lda #$087a	            LDA #MCURSOR
.1a7eaa	5b		tcd		            TCD
.1a7eab	68		pla		            PLA
.1a7eac	28		plp		            PLP
.1a7ead	08		php		            PHP
.1a7eae	e2 20		sep #$20	            SEP #$20
.1a7eb0	48		pha		            PHA
.1a7eb1	a9 00		lda #$00	            LDA #`MTEMP
.1a7eb3	48		pha		            PHA
.1a7eb4	ab		plb		            PLB
.1a7eb5	68		pla		            PLA
.1a7eb6	28		plp		            PLP
.1a7eb7	e2 20		sep #$20	            SEP #$20
.1a7eb9	a0 00 00	ldy #$0000	                LDY #0
.1a7ebc	a7 00		lda [$087a]	copy_loop       LDA [MCURSOR]       ; Copy the address pointed to by MCURSOR
.1a7ebe	99 92 08	sta $0892,y	                STA MTEMP,Y         ; to MTEMP
.1a7ec1	22 b2 84 1a	jsl $1a84b2	                JSL M_INC_CURSOR
.1a7ec5	c8		iny		                INY
.1a7ec6	c0 03 00	cpy #$0003	                CPY #3
.1a7ec9	d0 f1		bne $1a7ebc	                BNE copy_loop
.1a7ecb	22 5c 7f 1a	jsl $1a7f5c	                JSL M_PR_ADDR       ; Print the address
.1a7ecf	c2 30		rep #$30	            REP #$30
.1a7ed1	7a		ply		                PLY
.1a7ed2	2b		pld		                PLD
.1a7ed3	ab		plb		                PLB
.1a7ed4	28		plp		                PLP
.1a7ed5	6b		rtl		                RTL
.1a7ed6					DS_PR_MNEMONIC
.1a7ed6	08		php		                PHP
.1a7ed7	8b		phb		                PHB
.1a7ed8	e2 20		sep #$20	            SEP #$20
.1a7eda	c2 10		rep #$10	            REP #$10
.1a7edc	08		php		            PHP
.1a7edd	e2 20		sep #$20	            SEP #$20
.1a7edf	48		pha		            PHA
.1a7ee0	a9 1a		lda #$1a	            LDA #`MN_ORA
.1a7ee2	48		pha		            PHA
.1a7ee3	ab		plb		            PLB
.1a7ee4	68		pla		            PLA
.1a7ee5	28		plp		            PLP
.1a7ee6	bd 00 00	lda $1a0000,x	                LDA #0,B,X
.1a7ee9	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7eec	e8		inx		                INX
.1a7eed	bd 00 00	lda $1a0000,x	                LDA #0,B,X
.1a7ef0	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ef3	e8		inx		                INX
.1a7ef4	bd 00 00	lda $1a0000,x	                LDA #0,B,X
.1a7ef7	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7efa	e8		inx		                INX
.1a7efb	a9 20		lda #$20	                LDA #' '            ; Print a space
.1a7efd	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f00	ab		plb		                PLB
.1a7f01	28		plp		                PLP
.1a7f02	6b		rtl		                RTL
.1a7f03					DS_PR_PCREL
.1a7f03	08		php		                PHP
.1a7f04	0b		phd		                PHD
.1a7f05	08		php		            PHP
.1a7f06	c2 20		rep #$20	            REP #$20
.1a7f08	48		pha		            PHA
.1a7f09	a9 7a 08	lda #$087a	            LDA #MCURSOR
.1a7f0c	5b		tcd		            TCD
.1a7f0d	68		pla		            PLA
.1a7f0e	28		plp		            PLP
.1a7f0f	e2 20		sep #$20	            SEP #$20
.1a7f11	c0 02 00	cpy #$0002	                CPY #2
.1a7f14	f0 14		beq $1a7f2a	                BEQ offset_2
.1a7f16	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a7f18	85 18		sta $0892	                STA MTEMP
.1a7f1a	30 06		bmi $1a7f22	                BMI is_negative
.1a7f1c	64 19		stz $0893	                STZ MTEMP+1
.1a7f1e	64 1a		stz $0894	                STZ MTEMP+2
.1a7f20	80 1e		bra $1a7f40	                BRA add_offset
.1a7f22	a9 ff		lda #$ff	is_negative     LDA #$FF
.1a7f24	85 19		sta $0893	                STA MTEMP+1
.1a7f26	85 1a		sta $0894	                STA MTEMP+2
.1a7f28	80 16		bra $1a7f40	                BRA add_offset
.1a7f2a	a7 00		lda [$087a]	offset_2        LDA [MCURSOR]
.1a7f2c	85 18		sta $0892	                STA MTEMP
.1a7f2e	22 b2 84 1a	jsl $1a84b2	                JSL M_INC_CURSOR
.1a7f32	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a7f34	85 19		sta $0893	                STA MTEMP+1
.1a7f36	30 04		bmi $1a7f3c	                BMI is_negative2
.1a7f38	64 1a		stz $0894	                STZ MTEMP+2
.1a7f3a	80 04		bra $1a7f40	                BRA add_offset
.1a7f3c	a9 ff		lda #$ff	is_negative2    LDA #$FF
.1a7f3e	85 1a		sta $0894	                STA MTEMP+2
.1a7f40					add_offset
.1a7f40	c2 20		rep #$20	            REP #$20
.1a7f42	38		sec		                SEC             ; Add 1 to the offset
.1a7f43	a5 00		lda $087a	                LDA MCURSOR
.1a7f45	65 18		adc $0892	                ADC MTEMP
.1a7f47	85 18		sta $0892	                STA MTEMP
.1a7f49	e2 20		sep #$20	            SEP #$20
.1a7f4b	a5 02		lda $087c	                LDA MCURSOR+2
.1a7f4d	65 1a		adc $0894	                ADC MTEMP+2
.1a7f4f	85 1a		sta $0894	                STA MTEMP+2
.1a7f51	22 5c 7f 1a	jsl $1a7f5c	                JSL M_PR_ADDR
.1a7f55	22 b2 84 1a	jsl $1a84b2	                JSL M_INC_CURSOR
.1a7f59	2b		pld		                PLD
.1a7f5a	28		plp		                PLP
.1a7f5b	6b		rtl		                RTL
.1a7f5c					M_PR_ADDR
.1a7f5c	08		php		                PHP
.1a7f5d	0b		phd		                PHD
.1a7f5e	c2 20		rep #$20	            REP #$20
.1a7f60	48		pha		                PHA
.1a7f61	08		php		            PHP
.1a7f62	c2 20		rep #$20	            REP #$20
.1a7f64	48		pha		            PHA
.1a7f65	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7f68	5b		tcd		            TCD
.1a7f69	68		pla		            PLA
.1a7f6a	28		plp		            PLP
.1a7f6b	e2 20		sep #$20	            SEP #$20
.1a7f6d	a5 4c		lda $0894	                LDA MTEMP+2     ; Print the bank byte of the address
.1a7f6f	20 79 03	jsr $1a0379	            JSR PRHEXB
.1a7f72	e2 20		sep #$20	            SEP #$20
.1a7f74	a9 3a		lda #$3a	                LDA #':'
.1a7f76	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f79	c2 20		rep #$20	            REP #$20
.1a7f7b	a5 4a		lda $0892	                LDA MTEMP       ; Print the lower 16-bits of the address
.1a7f7d	20 5f 03	jsr $1a035f	            JSR PRHEXW
.1a7f80	68		pla		                PLA
.1a7f81	2b		pld		                PLD
.1a7f82	28		plp		                PLP
.1a7f83	6b		rtl		                RTL
.1a7f84					MNEMONICS_TAB
.1a7f84					MN_ORA
>1a7f84	4f 52 41 00			            .null "ORA"
.1a7f88					MN_AND
>1a7f88	41 4e 44 00			            .null "AND"
.1a7f8c					MN_EOR
>1a7f8c	45 4f 52 00			            .null "EOR"
.1a7f90					MN_ADC
>1a7f90	41 44 43 00			            .null "ADC"
.1a7f94					MN_STA
>1a7f94	53 54 41 00			            .null "STA"
.1a7f98					MN_LDA
>1a7f98	4c 44 41 00			            .null "LDA"
.1a7f9c					MN_CMP
>1a7f9c	43 4d 50 00			            .null "CMP"
.1a7fa0					MN_SBC
>1a7fa0	53 42 43 00			            .null "SBC"
.1a7fa4					MN_ASL
>1a7fa4	41 53 4c 00			            .null "ASL"
.1a7fa8					MN_ROL
>1a7fa8	52 4f 4c 00			            .null "ROL"
.1a7fac					MN_LSR
>1a7fac	4c 53 52 00			            .null "LSR"
.1a7fb0					MN_ROR
>1a7fb0	52 4f 52 00			            .null "ROR"
.1a7fb4					MN_STX
>1a7fb4	53 54 58 00			            .null "STX"
.1a7fb8					MN_LDX
>1a7fb8	4c 44 58 00			            .null "LDX"
.1a7fbc					MN_DEC
>1a7fbc	44 45 43 00			            .null "DEC"
.1a7fc0					MN_INC
>1a7fc0	49 4e 43 00			            .null "INC"
.1a7fc4					MN_BIT
>1a7fc4	42 49 54 00			            .null "BIT"
.1a7fc8					MN_JMP
>1a7fc8	4a 4d 50 00			            .null "JMP"
.1a7fcc					MN_STY
>1a7fcc	53 54 59 00			            .null "STY"
.1a7fd0					MN_LDY
>1a7fd0	4c 44 59 00			            .null "LDY"
.1a7fd4					MN_CPY
>1a7fd4	43 50 59 00			            .null "CPY"
.1a7fd8					MN_CPX
>1a7fd8	43 50 58 00			            .null "CPX"
.1a7fdc					MN_BRK
>1a7fdc	42 52 4b 00			            .null "BRK"
.1a7fe0					MN_JSR
>1a7fe0	4a 53 52 00			            .null "JSR"
.1a7fe4					MN_RTI
>1a7fe4	52 54 49 00			            .null "RTI"
.1a7fe8					MN_RTS
>1a7fe8	52 54 53 00			            .null "RTS"
.1a7fec					MN_PHP
>1a7fec	50 48 50 00			            .null "PHP"
.1a7ff0					MN_PLP
>1a7ff0	50 4c 50 00			            .null "PLP"
.1a7ff4					MN_PHA
>1a7ff4	50 48 41 00			            .null "PHA"
.1a7ff8					MN_PLA
>1a7ff8	50 4c 41 00			            .null "PLA"
.1a7ffc					MN_DEY
>1a7ffc	44 45 59 00			            .null "DEY"
.1a8000					MN_TAY
>1a8000	54 41 59 00			            .null "TAY"
.1a8004					MN_INY
>1a8004	49 4e 59 00			            .null "INY"
.1a8008					MN_INX
>1a8008	49 4e 58 00			            .null "INX"
.1a800c					MN_CLC
>1a800c	43 4c 43 00			            .null "CLC"
.1a8010					MN_SEC
>1a8010	53 45 43 00			            .null "SEC"
.1a8014					MN_CLI
>1a8014	43 4c 49 00			            .null "CLI"
.1a8018					MN_SEI
>1a8018	53 45 49 00			            .null "SEI"
.1a801c					MN_TYA
>1a801c	54 59 41 00			            .null "TYA"
.1a8020					MN_CLV
>1a8020	43 4c 56 00			            .null "CLV"
.1a8024					MN_CLD
>1a8024	43 4c 44 00			            .null "CLD"
.1a8028					MN_SED
>1a8028	53 45 44 00			            .null "SED"
.1a802c					MN_TXA
>1a802c	54 58 41 00			            .null "TXA"
.1a8030					MN_TXS
>1a8030	54 58 53 00			            .null "TXS"
.1a8034					MN_TAX
>1a8034	54 41 58 00			            .null "TAX"
.1a8038					MN_TSX
>1a8038	54 53 58 00			            .null "TSX"
.1a803c					MN_DEX
>1a803c	44 45 58 00			            .null "DEX"
.1a8040					MN_NOP
>1a8040	4e 4f 50 00			            .null "NOP"
.1a8044					MN_BPL
>1a8044	42 50 4c 00			            .null "BPL"
.1a8048					MN_BMI
>1a8048	42 4d 49 00			            .null "BMI"
.1a804c					MN_BVC
>1a804c	42 56 43 00			            .null "BVC"
.1a8050					MN_BVS
>1a8050	42 56 53 00			            .null "BVS"
.1a8054					MN_BCC
>1a8054	42 43 43 00			            .null "BCC"
.1a8058					MN_BCS
>1a8058	42 43 53 00			            .null "BCS"
.1a805c					MN_BNE
>1a805c	42 4e 45 00			            .null "BNE"
.1a8060					MN_BEQ
>1a8060	42 45 51 00			            .null "BEQ"
.1a8064					MN_TSB
>1a8064	54 53 42 00			            .null "TSB"
.1a8068					MN_TRB
>1a8068	54 52 42 00			            .null "TRB"
.1a806c					MN_STZ
>1a806c	53 54 5a 00			            .null "STZ"
.1a8070					MN_BRA
>1a8070	42 52 41 00			            .null "BRA"
.1a8074					MN_PHY
>1a8074	50 48 59 00			            .null "PHY"
.1a8078					MN_PLY
>1a8078	50 4c 59 00			            .null "PLY"
.1a807c					MN_PHX
>1a807c	50 48 58 00			            .null "PHX"
.1a8080					MN_PLX
>1a8080	50 4c 58 00			            .null "PLX"
.1a8084					MN_PHD
>1a8084	50 48 44 00			            .null "PHD"
.1a8088					MN_PLD
>1a8088	50 4c 44 00			            .null "PLD"
.1a808c					MN_PHK
>1a808c	50 48 4b 00			            .null "PHK"
.1a8090					MN_RTL
>1a8090	52 54 4c 00			            .null "RTL"
.1a8094					MN_PHB
>1a8094	50 48 42 00			            .null "PHB"
.1a8098					MN_PLB
>1a8098	50 4c 42 00			            .null "PLB"
.1a809c					MN_WAI
>1a809c	57 41 49 00			            .null "WAI"
.1a80a0					MN_XBA
>1a80a0	58 42 41 00			            .null "XBA"
.1a80a4					MN_TCS
>1a80a4	54 43 53 00			            .null "TCS"
.1a80a8					MN_TSC
>1a80a8	54 53 43 00			            .null "TSC"
.1a80ac					MN_TCD
>1a80ac	54 43 44 00			            .null "TCD"
.1a80b0					MN_TDC
>1a80b0	54 44 43 00			            .null "TDC"
.1a80b4					MN_TXY
>1a80b4	54 58 59 00			            .null "TXY"
.1a80b8					MN_TYX
>1a80b8	54 59 58 00			            .null "TYX"
.1a80bc					MN_STP
>1a80bc	53 54 50 00			            .null "STP"
.1a80c0					MN_XCE
>1a80c0	58 43 45 00			            .null "XCE"
.1a80c4					MN_COP
>1a80c4	43 4f 50 00			            .null "COP"
.1a80c8					MN_JSL
>1a80c8	4a 53 4c 00			            .null "JSL"
.1a80cc					MN_WDM
>1a80cc	57 44 4d 00			            .null "WDM"
.1a80d0					MN_PER
>1a80d0	50 45 52 00			            .null "PER"
.1a80d4					MN_BRL
>1a80d4	42 52 4c 00			            .null "BRL"
.1a80d8					MN_REP
>1a80d8	52 45 50 00			            .null "REP"
.1a80dc					MN_SEP
>1a80dc	53 45 50 00			            .null "SEP"
.1a80e0					MN_MVP
>1a80e0	4d 56 50 00			            .null "MVP"
.1a80e4					MN_MVN
>1a80e4	4d 56 4e 00			            .null "MVN"
.1a80e8					MN_PEI
>1a80e8	50 45 49 00			            .null "PEI"
.1a80ec					MN_PEA
>1a80ec	50 45 41 00			            .null "PEA"
.1a80f0					MN_JML
>1a80f0	4a 4d 4c 00			            .null "JML"
>1a80f4	00 00				            .byte 0, 0
>1a80f6	dc 7f 84 7f c4 80 84 7f		MNEMONIC_TAB    .word <>MN_BRK, <>MN_ORA, <>MN_COP, <>MN_ORA, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 0x
>1a80fe	64 80 84 7f a4 7f 84 7f
>1a8106	ec 7f 84 7f a4 7f 84 80		                .word <>MN_PHP, <>MN_ORA, <>MN_ASL, <>MN_PHD, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>1a810e	64 80 84 7f a4 7f 84 7f
>1a8116	44 80 84 7f 84 7f 84 7f		                .word <>MN_BPL, <>MN_ORA, <>MN_ORA, <>MN_ORA, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 1x
>1a811e	68 80 84 7f a4 7f 84 7f
>1a8126	0c 80 84 7f c0 7f a4 80		                .word <>MN_CLC, <>MN_ORA, <>MN_INC, <>MN_TCS, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>1a812e	68 80 84 7f a4 7f 84 7f
>1a8136	e0 7f 88 7f c8 80 88 7f		                .word <>MN_JSR, <>MN_AND, <>MN_JSL, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 2x
>1a813e	c4 7f 88 7f a8 7f 88 7f
>1a8146	f0 7f 88 7f a8 7f 88 80		                .word <>MN_PLP, <>MN_AND, <>MN_ROL, <>MN_PLD, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>1a814e	c4 7f 88 7f a8 7f 88 7f
>1a8156	48 80 88 7f 88 7f 88 7f		                .word <>MN_BMI, <>MN_AND, <>MN_AND, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 3x
>1a815e	c4 7f 88 7f a8 7f 88 7f
>1a8166	10 80 88 7f bc 7f a8 80		                .word <>MN_SEC, <>MN_AND, <>MN_DEC, <>MN_TSC, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>1a816e	c4 7f 88 7f a8 7f 88 7f
>1a8176	e4 7f 8c 7f cc 80 8c 7f		                .word <>MN_RTI, <>MN_EOR, <>MN_WDM, <>MN_EOR, <>MN_MVP, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 4x
>1a817e	e0 80 8c 7f ac 7f 8c 7f
>1a8186	f4 7f 8c 7f ac 7f 8c 80		                .word <>MN_PHA, <>MN_EOR, <>MN_LSR, <>MN_PHK, <>MN_JMP, <>MN_EOR, <>MN_LSR, <>MN_EOR
>1a818e	c8 7f 8c 7f ac 7f 8c 7f
>1a8196	4c 80 8c 7f 8c 7f 8c 7f		                .word <>MN_BVC, <>MN_EOR, <>MN_EOR, <>MN_EOR, <>MN_MVN, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 5x
>1a819e	e4 80 8c 7f ac 7f 8c 7f
>1a81a6	14 80 8c 7f 74 80 ac 80		                .word <>MN_CLI, <>MN_EOR, <>MN_PHY, <>MN_TCD, <>MN_JML, <>MN_EOR, <>MN_LSR, <>MN_EOR
>1a81ae	f0 80 8c 7f ac 7f 8c 7f
>1a81b6	e8 7f 90 7f d0 80 90 7f		                .word <>MN_RTS, <>MN_ADC, <>MN_PER, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 6x
>1a81be	6c 80 90 7f b0 7f 90 7f
>1a81c6	f8 7f 90 7f b0 7f 90 80		                .word <>MN_PLA, <>MN_ADC, <>MN_ROR, <>MN_RTL, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>1a81ce	c8 7f 90 7f b0 7f 90 7f
>1a81d6	50 80 90 7f 90 7f 90 7f		                .word <>MN_BVS, <>MN_ADC, <>MN_ADC, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 7x
>1a81de	6c 80 90 7f b0 7f 90 7f
>1a81e6	18 80 90 7f 78 80 b0 80		                .word <>MN_SEI, <>MN_ADC, <>MN_PLY, <>MN_TDC, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>1a81ee	c8 7f 90 7f b0 7f 90 7f
>1a81f6	70 80 94 7f d4 80 94 7f		                .word <>MN_BRA, <>MN_STA, <>MN_BRL, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 8x
>1a81fe	cc 7f 94 7f b4 7f 94 7f
>1a8206	fc 7f c4 7f 2c 80 94 80		                .word <>MN_DEY, <>MN_BIT, <>MN_TXA, <>MN_PHB, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA
>1a820e	cc 7f 94 7f b4 7f 94 7f
>1a8216	54 80 94 7f 94 7f 94 7f		                .word <>MN_BCC, <>MN_STA, <>MN_STA, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 9x
>1a821e	cc 7f 94 7f b4 7f 94 7f
>1a8226	1c 80 94 7f 30 80 b4 80		                .word <>MN_TYA, <>MN_STA, <>MN_TXS, <>MN_TXY, <>MN_STZ, <>MN_STA, <>MN_STZ, <>MN_STA
>1a822e	6c 80 94 7f 6c 80 94 7f
>1a8236	d0 7f 98 7f b8 7f 98 7f		                .word <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Ax
>1a823e	d0 7f 98 7f b8 7f 98 7f
>1a8246	00 80 98 7f 34 80 98 80		                .word <>MN_TAY, <>MN_LDA, <>MN_TAX, <>MN_PLB, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>1a824e	d0 7f 98 7f b8 7f 98 7f
>1a8256	58 80 98 7f 98 7f 98 7f		                .word <>MN_BCS, <>MN_LDA, <>MN_LDA, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Bx
>1a825e	d0 7f 98 7f b8 7f 98 7f
>1a8266	20 80 98 7f 38 80 b8 80		                .word <>MN_CLV, <>MN_LDA, <>MN_TSX, <>MN_TYX, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>1a826e	d0 7f 98 7f b8 7f 98 7f
>1a8276	d4 7f 9c 7f d8 80 9c 7f		                .word <>MN_CPY, <>MN_CMP, <>MN_REP, <>MN_CMP, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Cx
>1a827e	d4 7f 9c 7f bc 7f 9c 7f
>1a8286	04 80 9c 7f 3c 80 9c 80		                .word <>MN_INY, <>MN_CMP, <>MN_DEX, <>MN_WAI, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP
>1a828e	d4 7f 9c 7f bc 7f 9c 7f
>1a8296	5c 80 9c 7f 9c 7f 9c 7f		                .word <>MN_BNE, <>MN_CMP, <>MN_CMP, <>MN_CMP, <>MN_PEI, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Dx
>1a829e	e8 80 9c 7f bc 7f 9c 7f
>1a82a6	24 80 9c 7f 7c 80 bc 80		                .word <>MN_CLD, <>MN_CMP, <>MN_PHX, <>MN_STP, <>MN_JML, <>MN_CMP, <>MN_DEC, <>MN_CMP
>1a82ae	f0 80 9c 7f bc 7f 9c 7f
>1a82b6	d8 7f a0 7f dc 80 a0 7f		                .word <>MN_CPX, <>MN_SBC, <>MN_SEP, <>MN_SBC, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Ex
>1a82be	d8 7f a0 7f c0 7f a0 7f
>1a82c6	08 80 a0 7f 40 80 a0 80		                .word <>MN_INX, <>MN_SBC, <>MN_NOP, <>MN_XBA, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC
>1a82ce	d8 7f a0 7f c0 7f a0 7f
>1a82d6	60 80 a0 7f a0 7f a0 7f		                .word <>MN_BEQ, <>MN_SBC, <>MN_SBC, <>MN_SBC, <>MN_PEA, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Fx
>1a82de	ec 80 a0 7f c0 7f a0 7f
>1a82e6	28 80 a0 7f 80 80 c0 80		                .word <>MN_SED, <>MN_SBC, <>MN_PLX, <>MN_XCE, <>MN_JSR, <>MN_SBC, <>MN_INC, <>MN_SBC
>1a82ee	e0 7f a0 7f c0 7f a0 7f
>1a82f6	00 00				                .word 0
>1a82f8	13 00 02 09			ADDRESS_TAB     .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R                  ; 0x
>1a82fc	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8300	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a8304	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8308	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 1x
>1a830c	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8310	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>1a8314	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a8318	03 00 0b 09			                .byte ADDR_ABS, ADDR_DP_IND_X, ADDR_ABS_LONG, ADDR_SP_R                 ; 2x
>1a831c	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8320	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a8324	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8328	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 3x
>1a832c	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8330	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>1a8334	07 07 07 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a8338	13 00 13 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMPLIED, ADDR_SP_R              ; 4x
>1a833c	14 01 01 0a			                .byte ADDR_XYC, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8340	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a8344	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8348	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 5x
>1a834c	14 05 05 0d			                .byte ADDR_XYC, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8350	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a8354	0b 07 07 0b			                .byte ADDR_ABS_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_LONG
>1a8358	13 00 16 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R          ; 6x
>1a835c	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8360	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a8364	15 03 03 0b			                .byte ADDR_ABS_IND, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8368	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 7x
>1a836c	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8370	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a8374	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a8378	12 00 16 09			                .byte ADDR_PC_REL, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R           ; 8x
>1a837c	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8380	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a8384	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8388	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 9x
>1a838c	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>1a8390	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a8394	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a8398	82 00 42 09			                .byte ADDR_IMM | OP_M_EFFECT, ADDR_DP_IND_X, ADDR_IMM | OP_X_EFFECT, ADDR_SP_R  ; Ax
>1a839c	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a83a0	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a83a4	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a83a8	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Bx
>1a83ac	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>1a83b0	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a83b4	07 07 06 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_Y, ADDR_ABS_X_LONG
>1a83b8	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Cx
>1a83bc	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a83c0	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a83c4	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a83c8	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Dx
>1a83cc	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a83d0	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a83d4	17 07 07 0e			                .byte ADDR_ABS_IND_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a83d8	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Ex
>1a83dc	01 01 01 0f			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_IND
>1a83e0	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a83e4	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a83e8	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Fx
>1a83ec	03 05 05 0d			                .byte ADDR_ABS, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a83f0	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a83f4	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a83f8	01 01 01 02 01 01 02 02		ADDR_LENGTH     .byte 1, 1, 1, 2, 1, 1, 2, 2, 0, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 0, 2, 2, 2, 2
>1a8400	00 01 01 03 01 01 03 01 02 01 01 00 02 02 02 02
.1a8410					ADDR_PATTERNS
>1a8410	41 00				            .null "A"
>1a8412	08				            .byte ADDR_ACC
>1a8413	64 64 3a 64 64 64 64 2c		            .null "dd:dddd,X"
>1a841b	58 00
>1a841d	0e				            .byte ADDR_ABS_X_LONG
>1a841e	64 64 3a 64 64 64 64 00		            .null "dd:dddd"
>1a8426	0b				            .byte ADDR_ABS_LONG
>1a8427	64 64 64 64 2c 58 00		            .null "dddd,X"
>1a842e	07				            .byte ADDR_ABS_X
>1a842f	64 64 64 64 2c 59 00		            .null "dddd,Y"
>1a8436	06				            .byte ADDR_ABS_Y
>1a8437	64 64 64 64 00			            .null "dddd"
>1a843c	03				            .byte ADDR_ABS
>1a843d	64 64 2c 58 00			            .null "dd,X"
>1a8442	05				            .byte ADDR_DP_X
>1a8443	64 64 2c 59 00			            .null "dd,Y"
>1a8448	11				            .byte ADDR_DP_Y
>1a8449	64 64 2c 53 00			            .null "dd,S"
>1a844e	09				            .byte ADDR_SP_R
>1a844f	64 64 00			            .null "dd"
>1a8452	01				            .byte ADDR_DP
>1a8453	23 64 64 64 64 00		            .null "#dddd"
>1a8459	c2				            .byte ADDR_IMM | OP_M_EFFECT | OP_X_EFFECT
>1a845a	23 64 64 2c 23 64 64 00		            .null "#dd,#dd"
>1a8462	14				            .byte ADDR_XYC
>1a8463	23 64 64 00			            .null "#dd"
>1a8467	02				            .byte ADDR_IMM
>1a8468	28 64 64 2c 53 29 2c 59		            .null "(dd,S),Y"
>1a8470	00
>1a8471	0c				            .byte ADDR_SP_R_Y
>1a8472	28 64 64 64 64 2c 58 29		            .null "(dddd,X)"
>1a847a	00
>1a847b	10				            .byte ADDR_ABS_X_ID
>1a847c	28 64 64 64 64 29 00		            .null "(dddd)"
>1a8483	10				            .byte ADDR_ABS_X_ID
>1a8484	28 64 64 2c 58 29 00		            .null "(dd,X)"
>1a848b	00				            .byte ADDR_DP_IND_X
>1a848c	28 64 64 29 2c 59 00		            .null "(dd),Y"
>1a8493	04				            .byte ADDR_DP_IND_Y
>1a8494	28 64 64 29 00			            .null "(dd)"
>1a8499	0f				            .byte ADDR_DP_IND
>1a849a	5b 64 64 64 64 5d 00		            .null "[dddd]"
>1a84a1	17				            .byte ADDR_ABS_IND_LONG
>1a84a2	5b 64 64 5d 2c 59 00		            .null "[dd],Y"
>1a84a9	0d				            .byte ADDR_DP_Y_LONG
>1a84aa	5b 64 64 5d 00			            .null "[dd]"
>1a84af	0a				            .byte ADDR_DP_LONG
>1a84b0	00 00				                .byte 0, 0

;******  Return to file: src\monitor.s

.1a84b2					M_INC_CURSOR
.1a84b2	08		php		                PHP
.1a84b3	c2 20		rep #$20	            REP #$20
.1a84b5	48		pha		                PHA
.1a84b6	18		clc		                CLC
.1a84b7	af 7a 08 00	lda $00087a	                LDA MCURSOR
.1a84bb	69 01 00	adc #$0001	                ADC #1
.1a84be	8f 7a 08 00	sta $00087a	                STA MCURSOR
.1a84c2	e2 20		sep #$20	            SEP #$20
.1a84c4	af 7c 08 00	lda $00087c	                LDA MCURSOR+2
.1a84c8	69 00		adc #$00	                ADC #0
.1a84ca	8f 7c 08 00	sta $00087c	                STA MCURSOR+2
.1a84ce	c2 20		rep #$20	            REP #$20
.1a84d0	68		pla		                PLA
.1a84d1	28		plp		                PLP
.1a84d2	6b		rtl		                RTL
.1a84d3					MPRINTB
.1a84d3	08		php		                PHP
.1a84d4	c2 10		rep #$10	            REP #$10
.1a84d6	e2 20		sep #$20	            SEP #$20
.1a84d8	da		phx		                PHX
.1a84d9	a2 08 00	ldx #$0008	                LDX #8          ; Set number of bits to print to 8
.1a84dc	0a		asl a		loop            ASL A           ; Shift MSB to C
.1a84dd	b0 08		bcs $1a84e7	                BCS is_one
.1a84df	48		pha		                PHA             ; Save value to print
.1a84e0	a9 30		lda #$30	                LDA #'0'        ; Print '0'
.1a84e2	20 18 00	jsr $1a0018	            JSR PRINTC
.1a84e5	80 06		bra $1a84ed	                BRA continue
.1a84e7	48		pha		is_one          PHA             ; Save value to print
.1a84e8	a9 31		lda #$31	                LDA #'1'        ; Print '1'
.1a84ea	20 18 00	jsr $1a0018	            JSR PRINTC
.1a84ed	68		pla		continue        PLA
.1a84ee	ca		dex		                DEX             ; Count down the bits to shift
.1a84ef	d0 eb		bne $1a84dc	                BNE loop        ; And try the next one if there is one
.1a84f1	fa		plx		                PLX             ; Otherwise, return
.1a84f2	28		plp		                PLP
.1a84f3	6b		rtl		                RTL
.1a84f4					MSKIPWS
.1a84f4	08		php		            PHP
.1a84f5	c2 20		rep #$20	            REP #$20
.1a84f7	48		pha		            PHA
.1a84f8	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a84fb	5b		tcd		            TCD
.1a84fc	68		pla		            PLA
.1a84fd	28		plp		            PLP
.1a84fe	e2 20		sep #$20	            SEP #$20
.1a8500	a7 32		lda [$087a]	loop            LDA [MCURSOR]       ; Check the current character
.1a8502	f0 0a		beq $1a850e	                BEQ done            ; If NULL, we're done
.1a8504	c9 20		cmp #$20	                CMP #' '            ; Is it a space?
.1a8506	d0 06		bne $1a850e	                BNE done            ; No: we're done
.1a8508	22 b2 84 1a	jsl $1a84b2	                JSL M_INC_CURSOR    ; Yes, try the next one
.1a850c	80 f2		bra $1a8500	                BRA loop
.1a850e	6b		rtl		done            RTL
.1a850f					MPARSESTR
.1a850f	08		php		                PHP
.1a8510	08		php		            PHP
.1a8511	c2 20		rep #$20	            REP #$20
.1a8513	48		pha		            PHA
.1a8514	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a8517	5b		tcd		            TCD
.1a8518	68		pla		            PLA
.1a8519	28		plp		            PLP
.1a851a	22 b2 84 1a	jsl $1a84b2	                JSL M_INC_CURSOR                ; Point to the first character of the name
.1a851e	22 f4 84 1a	jsl $1a84f4	                JSL MSKIPWS                     ; Skip white space
.1a8522	c2 30		rep #$30	            REP #$30
.1a8524	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.1a8526	c2 20		rep #$20	            REP #$20
.1a8528	29 ff 00	and #$00ff	                AND #$00FF
.1a852b	0a		asl a		                ASL A                           ; multiply it by forfour
.1a852c	0a		asl a		                ASL A
.1a852d	aa		tax		                TAX                             ; ... to get the index to the argument
.1a852e	a5 32		lda $087a	                LDA MCURSOR                     ; Set the argument to the address of the first byte
.1a8530	95 0d		sta $0855,x	                STA MARG1,X
.1a8532	a5 34		lda $087c	                LDA MCURSOR+2
.1a8534	95 0f		sta $0857,x	                STA MARG1+2,X
.1a8536	e2 20		sep #$20	            SEP #$20
.1a8538	a7 32		lda [$087a]	loop            LDA [MCURSOR]                   ; Scan to the closing double quote
.1a853a	f0 14		beq $1a8550	                BEQ done                        ; If NULL... treat it as a closed argument
.1a853c	c9 22		cmp #$22	                CMP #CHAR_DQUOTE
.1a853e	f0 06		beq $1a8546	                BEQ close_string
.1a8540	22 b2 84 1a	jsl $1a84b2	                JSL M_INC_CURSOR
.1a8544	80 f2		bra $1a8538	                BRA loop
.1a8546	a9 00		lda #$00	close_string    LDA #0                          ; Write a NULL to close the string
.1a8548	87 32		sta [$087a]	                STA [MCURSOR]
.1a854a	22 b2 84 1a	jsl $1a84b2	                JSL M_INC_CURSOR                ; And point to the next byte
.1a854e	e6 31		inc $0879	                INC MARG_LEN
.1a8550	28		plp		done            PLP
.1a8551	6b		rtl		                RTL
.1a8552					MPARSEARG
.1a8552	08		php		            PHP
.1a8553	c2 20		rep #$20	            REP #$20
.1a8555	48		pha		            PHA
.1a8556	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a8559	5b		tcd		            TCD
.1a855a	68		pla		            PLA
.1a855b	28		plp		            PLP
.1a855c	e2 20		sep #$20	            SEP #$20
.1a855e	64 4a		stz $0892	                STZ MTEMP                       ; Use MTEMP as a flag for having processed digits
.1a8560	c2 20		rep #$20	            REP #$20
.1a8562	64 50		stz $0898	                STZ MPARSEDNUM                  ; Clear the parsed number
.1a8564	64 52		stz $089a	                STZ MPARSEDNUM+2
.1a8566					pa_loop
.1a8566	e2 20		sep #$20	            SEP #$20
.1a8568	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Get the current character
.1a856a	c9 3a		cmp #$3a	                CMP #":"
.1a856c	f0 0d		beq $1a857b	                BEQ pa_next_char                ; Ignore any colons
.1a856e	20 f7 03	jsr $1a03f7	            JSR ISHEX
.1a8571	90 0e		bcc $1a8581	                BCC finished_arg                ; No? We're done with this argument
.1a8573	22 ea 79 1a	jsl $1a79ea	                JSL AS_SHIFT_HEX                ; Yes: shift it onto MPARSEDNUM
.1a8577	a9 01		lda #$01	                LDA #1                          ; Flag that we've processed a character
.1a8579	85 4a		sta $0892	                STA MTEMP
.1a857b	22 b2 84 1a	jsl $1a84b2	pa_next_char    JSL M_INC_CURSOR                ; And try the next character
.1a857f	80 e5		bra $1a8566	                BRA pa_loop
.1a8581	a5 4a		lda $0892	finished_arg    LDA MTEMP                       ; Check to see if we've processed any characters
.1a8583	f0 16		beq $1a859b	                BEQ done                        ; No: we're done
.1a8585	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.1a8587	c2 20		rep #$20	            REP #$20
.1a8589	29 ff 00	and #$00ff	                AND #$00FF
.1a858c	0a		asl a		                ASL A                           ; multiply it by forfour
.1a858d	0a		asl a		                ASL A
.1a858e	aa		tax		                TAX                             ; ... to get the index to the argument
.1a858f	a5 50		lda $0898	                LDA MPARSEDNUM                  ; Copy the value to the argument slot
.1a8591	95 0d		sta $0855,x	                STA MARG1,X
.1a8593	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a8595	95 0f		sta $0857,x	                STA MARG1+2,X
.1a8597	e2 20		sep #$20	            SEP #$20
.1a8599	e6 31		inc $0879	                INC MARG_LEN                    ; And bump up the argument count
.1a859b	6b		rtl		done            RTL
.1a859c					MPARSEALLARG
.1a859c	e2 20		sep #$20	            SEP #$20
.1a859e	64 31		stz $0879	                STZ MARG_LEN                    ; Set the arg count to 0
.1a85a0	22 f4 84 1a	jsl $1a84f4	parse_arg       JSL MSKIPWS                     ; Otherwise, skip white space
.1a85a4	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Check the current character
.1a85a6	f0 21		beq $1a85c9	                BEQ done                        ; If it is NULL, we're done
.1a85a8	c9 22		cmp #$22	                CMP #CHAR_DQUOTE                ; Is it a double-quote?
.1a85aa	d0 06		bne $1a85b2	                BNE regular_arg
.1a85ac	22 0f 85 1a	jsl $1a850f	                JSL MPARSESTR                   ; Yes: parse it as a string argument
.1a85b0	80 0a		bra $1a85bc	                BRA check_rest
.1a85b2	22 52 85 1a	jsl $1a8552	regular_arg     JSL MPARSEARG                   ; Attempt to parse the argument
.1a85b6	a5 31		lda $0879	                LDA MARG_LEN                    ; Check how many arguments we've processed
.1a85b8	c9 09		cmp #$09	                CMP #9
.1a85ba	b0 0d		bcs $1a85c9	                BGE done                        ; If >=9, then we're done
.1a85bc	a7 32		lda [$087a]	check_rest      LDA [MCURSOR]                   ; Check the current character
.1a85be	f0 09		beq $1a85c9	                BEQ done                        ; If EOL: we're done
.1a85c0	c9 20		cmp #$20	                CMP #' '
.1a85c2	f0 dc		beq $1a85a0	                BEQ parse_arg                   ; If space: try to process another argument
.1a85c4	20 f7 03	jsr $1a03f7	            JSR ISHEX
.1a85c7	b0 d7		bcs $1a85a0	                BCS parse_arg                   ; If hex digit: try to process another argument
.1a85c9	6b		rtl		done            RTL
.1a85ca					IMPARSE
.1a85ca	08		php		                PHP
.1a85cb	0b		phd		                PHD
.1a85cc	08		php		            PHP
.1a85cd	c2 20		rep #$20	            REP #$20
.1a85cf	48		pha		            PHA
.1a85d0	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a85d3	5b		tcd		            TCD
.1a85d4	68		pla		            PLA
.1a85d5	28		plp		            PLP
.1a85d6	c2 10		rep #$10	            REP #$10
.1a85d8	e2 20		sep #$20	            SEP #$20
.1a85da	a2 31 00	ldx #$0031	                LDX #MARG_LEN - MONITOR_VARS    ; Clear the monitor command line parameters
.1a85dd	74 00		stz $0848,x	clear_command   STZ MONITOR_VARS,X
.1a85df	ca		dex		                DEX
.1a85e0	d0 fb		bne $1a85dd	                BNE clear_command
.1a85e2	a9 00		lda #$00	                LDA #`INPUTBUF                  ; Point the command parser to the input buffer
.1a85e4	85 02		sta $084a	                STA MCMDADDR+2
.1a85e6	85 34		sta $087c	                STA MCURSOR+2                   ; And point MCURSOR there too
.1a85e8	c2 20		rep #$20	            REP #$20
.1a85ea	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF
.1a85ed	85 00		sta $0848	                STA MCMDADDR
.1a85ef	85 32		sta $087a	                STA MCURSOR
.1a85f1	e2 20		sep #$20	            SEP #$20
.1a85f3	22 f4 84 1a	jsl $1a84f4	                JSL MSKIPWS                     ; Skip to the first letter of the command
.1a85f7	c9 00		cmp #$00	                CMP #0                          ; Is the current character a NULL?
.1a85f9	f0 38		beq $1a8633	                BEQ done                        ; Yes: there's no command here
.1a85fb	c2 20		rep #$20	            REP #$20
.1a85fd	a5 32		lda $087a	                LDA MCURSOR
.1a85ff	85 08		sta $0850	                STA MCMD
.1a8601	e2 20		sep #$20	            SEP #$20
.1a8603	a5 34		lda $087c	                LDA MCURSOR+2
.1a8605	85 0a		sta $0852	                STA MCMD+2
.1a8607	a2 01 00	ldx #$0001	                LDX #1
.1a860a	22 b2 84 1a	jsl $1a84b2	cmd_loop        JSL M_INC_CURSOR                ; Move to the next character
.1a860e	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; What is that character?
.1a8610	d0 06		bne $1a8618	                BNE cmd_space                   ; If not NULL: check for a space
.1a8612	86 0b		stx $0853	no_arguments    STX MCMD_LEN                    ; If NULL: Save the length of the command
.1a8614	64 31		stz $0879	                STZ MARG_LEN                    ; ... And the fact there are no arguments
.1a8616	80 1b		bra $1a8633	                BRA done                        ; ... And return
.1a8618	c9 20		cmp #$20	cmd_space       CMP #' '                        ; Is it a space?
.1a861a	f0 03		beq $1a861f	                BEQ found_cmd                   ; Yes: save the length
.1a861c	e8		inx		                INX                             ; No: go to the next character
.1a861d	80 eb		bra $1a860a	                BRA cmd_loop
.1a861f	86 0b		stx $0853	found_cmd       STX MCMD_LEN                    ; Save the length of the command
.1a8621	a9 00		lda #$00	                LDA #0
.1a8623	87 32		sta [$087a]	                STA [MCURSOR]                   ; Write a NULL to the end of the command
.1a8625	22 b2 84 1a	jsl $1a84b2	                JSL M_INC_CURSOR                ; And skip to the next character
.1a8629	a7 08		lda [$0850]	                LDA [MCMD]                      ; Check the command
.1a862b	c9 41		cmp #$41	                CMP #'A'
.1a862d	f0 07		beq $1a8636	                BEQ parse_asm                   ; If 'A', parse the line for the assemble command
.1a862f	22 9c 85 1a	jsl $1a859c	                JSL MPARSEALLARG
.1a8633	2b		pld		done            PLD
.1a8634	28		plp		                PLP
.1a8635	6b		rtl		                RTL
.1a8636	22 f4 84 1a	jsl $1a84f4	parse_asm       JSL MSKIPWS                     ; Skip to the first letter of the address
.1a863a	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a863c	f0 f5		beq $1a8633	                BEQ done                        ; Exit if we got the end-of-line
.1a863e	22 52 85 1a	jsl $1a8552	                JSL MPARSEARG                   ; Parse the first argument as the target address
.1a8642	22 f4 84 1a	jsl $1a84f4	                JSL MSKIPWS                     ; Skip to the first letter of the mnemonic
.1a8646	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a8648	f0 e9		beq $1a8633	                BEQ done                        ; Exit if we got the end-of-line
.1a864a	c2 20		rep #$20	            REP #$20
.1a864c	a5 32		lda $087a	                LDA MCURSOR                     ; Save pointer to the start of the mnemonic
.1a864e	85 11		sta $0859	                STA MARG2
.1a8650	e2 20		sep #$20	            SEP #$20
.1a8652	a5 34		lda $087c	                LDA MCURSOR+2
.1a8654	85 13		sta $085b	                STA MARG2+2
.1a8656	22 b2 84 1a	jsl $1a84b2	asm_find_sp     JSL M_INC_CURSOR                ; Find the space at the end of the mnemonic
.1a865a	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a865c	f0 26		beq $1a8684	                BEQ asm_no_operand              ; If EOL: we have an instruction but no operand
.1a865e	c9 20		cmp #$20	                CMP #' '
.1a8660	d0 f4		bne $1a8656	                BNE asm_find_sp
.1a8662	a9 00		lda #$00	                LDA #0
.1a8664	87 32		sta [$087a]	                STA [MCURSOR]                   ; Null terminate the mnemonic
.1a8666	e6 31		inc $0879	                INC MARG_LEN                    ; Count the mnemonic as an argument
.1a8668	22 b2 84 1a	jsl $1a84b2	                JSL M_INC_CURSOR
.1a866c	22 f4 84 1a	jsl $1a84f4	                JSL MSKIPWS                     ; Skip to the addressing mode
.1a8670	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a8672	f0 bf		beq $1a8633	                BEQ done                        ; If EOL: we're done
.1a8674	c2 20		rep #$20	            REP #$20
.1a8676	a5 32		lda $087a	                LDA MCURSOR                     ; Set the pointer to the addressing mode
.1a8678	85 15		sta $085d	                STA MARG3
.1a867a	e2 20		sep #$20	            SEP #$20
.1a867c	a5 34		lda $087c	                LDA MCURSOR+2
.1a867e	85 17		sta $085f	                STA MARG3+2
.1a8680	e6 31		inc $0879	                INC MARG_LEN                    ; And count it as the second argument
.1a8682	80 af		bra $1a8633	                BRA done                        ; and return
.1a8684	e6 31		inc $0879	asm_no_operand  INC MARG_LEN                    ; Increment the argument count
.1a8686	80 ab		bra $1a8633	                BRA done                        ; And quit
.1a8688					IMLOAD
.1a8688	08		php		                PHP
.1a8689	c2 10		rep #$10	            REP #$10
.1a868b	e2 20		sep #$20	            SEP #$20
.1a868d	a5 31		lda $0879	                LDA MARG_LEN
.1a868f	d0 0f		bne $1a86a0	                BNE get_arguments
.1a8691	a2 7e 87	ldx #$877e	bad_arguments   LDX #<>MERRARGS                 ; Print bad arguments error
.1a8694	a9 1a		lda #$1a	                LDA #`MERRARGS
.1a8696	48		pha		                PHA
.1a8697	ab		plb		                PLB
.1a8698	20 4f 03	jsr $1a034f	            JSR PRINTS
.1a869b	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a869e	80 61		bra $1a8701	                BRA done
.1a86a0					get_arguments
.1a86a0	c2 20		rep #$20	            REP #$20
.1a86a2	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.1a86a4	8f 23 08 00	sta $000823	                STA ARGUMENT1
.1a86a8	a5 0f		lda $0857	                LDA MARG1+2
.1a86aa	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.1a86ae	20 6e 68	jsr $1a686e	            JSR SETFILEDESC
.1a86b1	e2 20		sep #$20	            SEP #$20
.1a86b3	a5 31		lda $0879	                LDA MARG_LEN
.1a86b5	c9 01		cmp #$01	                CMP #1
.1a86b7	d0 0f		bne $1a86c8	                BNE get_dest
.1a86b9	c2 20		rep #$20	            REP #$20
.1a86bb	a9 ff ff	lda #$ffff	                LDA #$FFFF                      ; Destination address not provided...
.1a86be	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR              ; ... set it to something sane
.1a86c2	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a86c6	80 0e		bra $1a86d6	                BRA try_load
.1a86c8					get_dest
.1a86c8	c2 20		rep #$20	            REP #$20
.1a86ca	a5 11		lda $0859	                LDA MARG2                       ; Set the destination address from the arguments
.1a86cc	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a86d0	a5 13		lda $085b	                LDA MARG2+2
.1a86d2	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a86d6	22 18 11 00	jsl $001118	try_load        JSL FK_LOAD                     ; Try to load the file
.1a86da	b0 25		bcs $1a8701	                BCS done
.1a86dc					error
.1a86dc	e2 20		sep #$20	            SEP #$20
.1a86de	a2 a4 87	ldx #$87a4	                LDX #<>MCANTLOAD                ; Print bad arguments error
.1a86e1	a9 1a		lda #$1a	                LDA #`MCANTLOAD
.1a86e3	48		pha		                PHA
.1a86e4	ab		plb		                PLB
.1a86e5	20 4f 03	jsr $1a034f	            JSR PRINTS
.1a86e8	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.1a86ec	20 79 03	jsr $1a0379	            JSR PRHEXB
.1a86ef	a9 20		lda #$20	                LDA #' '
.1a86f1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a86f4	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.1a86f8	20 79 03	jsr $1a0379	            JSR PRHEXB
.1a86fb	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a86fe	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a8701	28		plp		done            PLP
.1a8702	6b		rtl		                RTL
.1a8703					IMSAVE
.1a8703	8b		phb		                PHB
.1a8704	08		php		                PHP
.1a8705	c2 10		rep #$10	            REP #$10
.1a8707	e2 20		sep #$20	            SEP #$20
.1a8709	a5 31		lda $0879	                LDA MARG_LEN
.1a870b	c9 03		cmp #$03	                CMP #3
.1a870d	f0 0f		beq $1a871e	                BEQ get_arguments
.1a870f	a2 7e 87	ldx #$877e	                LDX #<>MERRARGS                 ; Print bad arguments error
.1a8712	a9 1a		lda #$1a	                LDA #`MERRARGS
.1a8714	48		pha		                PHA
.1a8715	ab		plb		                PLB
.1a8716	20 4f 03	jsr $1a034f	            JSR PRINTS
.1a8719	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a871c	80 54		bra $1a8772	                BRA done
.1a871e					get_arguments
.1a871e	c2 20		rep #$20	            REP #$20
.1a8720	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.1a8722	8f 23 08 00	sta $000823	                STA ARGUMENT1
.1a8726	a5 0f		lda $0857	                LDA MARG1+2
.1a8728	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.1a872c	20 6e 68	jsr $1a686e	            JSR SETFILEDESC
.1a872f	a5 11		lda $0859	                LDA MARG2                       ; Set the starting address
.1a8731	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.1a8735	a5 13		lda $085b	                LDA MARG2+2
.1a8737	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.1a873b	a5 15		lda $085d	                LDA MARG3                       ; Set the ending address
.1a873d	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.1a8741	a5 17		lda $085f	                LDA MARG3+2
.1a8743	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.1a8747	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                     ; Save the data
.1a874b	b0 25		bcs $1a8772	                BCS done
.1a874d					error
.1a874d	e2 20		sep #$20	            SEP #$20
.1a874f	a2 8e 87	ldx #$878e	                LDX #<>MCANTSAVE                ; Print bad arguments error
.1a8752	a9 1a		lda #$1a	                LDA #`MCANTSAVE
.1a8754	48		pha		                PHA
.1a8755	ab		plb		                PLB
.1a8756	20 4f 03	jsr $1a034f	            JSR PRINTS
.1a8759	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.1a875d	20 79 03	jsr $1a0379	            JSR PRHEXB
.1a8760	a9 20		lda #$20	                LDA #' '
.1a8762	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8765	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.1a8769	20 79 03	jsr $1a0379	            JSR PRHEXB
.1a876c	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a876f	20 c2 02	jsr $1a02c2	            JSR PRINTCR
.1a8772	28		plp		done            PLP
.1a8773	ab		plb		                PLB
.1a8774	6b		rtl		                RTL
.1a8775	5c 37 26 1a	jmp $1a2637	IMEXIT          JML INTERACT
.1a8779	6b		rtl		IMRETURN        RTL ; Handle RETURN key (ie: execute command)
.1a877a	00		brk #		IMPARSE1        BRK ; Parse one word on the current command line
.1a877b	00		brk #		IMASSEMBLEA     BRK ; Assemble a line of text.
.1a877c	00		brk #		IMVERIFY        BRK ; Verify memory and file on disk
.1a877d	00		brk #		IMDOS           BRK ; Execute DOS command
.1a877e					MMESSAGES
>1a877e	42 61 64 20 61 72 67 75		MERRARGS        .null "Bad arguments",CHAR_CR,CHAR_CR
>1a8786	6d 65 6e 74 73 0d 0d 00
>1a878e	55 6e 61 62 6c 65 20 74		MCANTSAVE       .null "Unable to save file: "
>1a8796	6f 20 73 61 76 65 20 66 69 6c 65 3a 20 00
>1a87a4	55 6e 61 62 6c 65 20 74		MCANTLOAD       .null "Unable to load file: "
>1a87ac	6f 20 6c 6f 61 64 20 66 69 6c 65 3a 20 00
>1a87ba	0d 20 20 50 43 20 20 20		mregisters_msg  .null $0D,"  PC     A    X    Y    SP   DBR DP   NVMXDIZC",CHAR_CR
>1a87c2	20 20 41 20 20 20 20 58 20 20 20 20 59 20 20 20
>1a87d2	20 53 50 20 20 20 44 42 52 20 44 50 20 20 20 4e
>1a87e2	56 4d 58 44 49 5a 43 0d 00
>1a87eb	41 43 44 46 47 4a 48 4c		MCOMMANDS       .null "ACDFGJHLMR;STVWX>?"
>1a87f3	4d 52 3b 53 54 56 57 58 3e 3f 00

;******  Return to file: src\basic816.s

.1a87fe	18		clc		START       CLC                 ; Go to native mode
.1a87ff	fb		xce		            XCE
.1a8800	08		php		            PHP
.1a8801	c2 20		rep #$20	            REP #$20
.1a8803	48		pha		            PHA
.1a8804	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a8807	5b		tcd		            TCD
.1a8808	68		pla		            PLA
.1a8809	28		plp		            PLP
.1a880a	08		php		            PHP
.1a880b	e2 20		sep #$20	            SEP #$20
.1a880d	48		pha		            PHA
.1a880e	a9 00		lda #$00	            LDA #BASIC_BANK
.1a8810	48		pha		            PHA
.1a8811	ab		plb		            PLB
.1a8812	68		pla		            PLA
.1a8813	28		plp		            PLP
.1a8814	c2 30		rep #$30	            REP #$30
.1a8816	20 3d 88	jsr $1a883d	            JSR INITBASIC
.1a8819	a9 ff fe	lda #$feff	            LDA #STACK_END      ; Set the system stack
.1a881c	1b		tcs		            TCS
.1a881d	08		php		            PHP
.1a881e	e2 20		sep #$20	            SEP #$20
.1a8820	48		pha		            PHA
.1a8821	a9 1a		lda #$1a	            LDA #`GREET
.1a8823	48		pha		            PHA
.1a8824	ab		plb		            PLB
.1a8825	68		pla		            PLA
.1a8826	28		plp		            PLP
.1a8827	a2 71 d2	ldx #$d271	            LDX #<>GREET
.1a882a	20 4f 03	jsr $1a034f	            JSR PRINTS
.1a882d	08		php		            PHP
.1a882e	e2 20		sep #$20	            SEP #$20
.1a8830	48		pha		            PHA
.1a8831	a9 00		lda #$00	            LDA #BASIC_BANK
.1a8833	48		pha		            PHA
.1a8834	ab		plb		            PLB
.1a8835	68		pla		            PLA
.1a8836	28		plp		            PLP
.1a8837	4c 37 26	jmp $1a2637	            JMP INTERACT        ; Start accepting input from the user
.1a883a	4c 3a 88	jmp $1a883a	WAIT        JMP WAIT
.1a883d					INITBASIC
.1a883d	08		php		            PHP
.1a883e	20 09 02	jsr $1a0209	            JSR INITIO
.1a8841	20 00 4e	jsr $1a4e00	            JSR CMD_NEW
.1a8844	28		plp		            PLP
.1a8845	60		rts		            RTS
>1ad271	43 32 35 36 20 46 6f 65		GREET       .text "C256 Foenix BASIC816 "
>1ad279	6e 69 78 20 42 41 53 49 43 38 31 36 20

;******  Processing file: src\version.s

>1ad286	76 30 2e 32 2e 30 2d 61		.text "v0.2.0-alpha+274"
>1ad28e	6c 70 68 61 2b 32 37 34

;******  Return to file: src\basic816.s

>1ad296	0d 00				            .byte 13,0

;******  End of listing
