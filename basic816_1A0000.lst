
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -D SYSTEM=2 -D C256_SKU=2 -D UARTSUPPORT= -D UNITTEST=0 -D TRACE_LEVEL=0 --long-address --flat -b --m65816 --intel-hex -o basic816_1A0000.hex --list=basic816_1A0000.lst --labels=basic816_1A0000.lbl src\basic816.s
; Fri Apr 30 13:02:30 2021

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=2					SYSTEM=2
=2					C256_SKU=2
=					UARTSUPPORT=
=0					UNITTEST=0
=0					TRACE_LEVEL=0

;******  Processing input file: src\basic816.s


;******  Processing file: src\constants.s

=2					SYSTEM_C256 = 2         ; C256 Foenix
=1					SYSTEM_C64 = 1          ; Commodore 64 with SuperCPU
=$03					CHAR_CTRL_C = $03       ; CTRL-C: used as a program interrupt key
=$07					CHAR_BELL = $07         ; Ring the console bell
=$08					CHAR_BS = $08           ; Backspace
=$09					CHAR_TAB = $09          ; TAB
=$0a					CHAR_LF = $0A           ; Linefeed
=$0d					CHAR_CR = $0D           ; Carriage Return
=$0f					CHAR_INS = $0F          ; Insert
=$1b					CHAR_ESC = $1B          ; Escape
=$22					CHAR_DQUOTE = $22       ; Double quote
=$20					CHAR_SP = $20           ; Space
=$7f					CHAR_DEL = $7F          ; Delete
=5					ARGUMENT_SIZE = 5       ; Number of bytes in an argument
=8					VAR_NAME_SIZE = 8       ; Maximum number of characters in a variable name
=0					TYPE_INTEGER = 0        ; 32-bit integer
=1					TYPE_FLOAT = 1          ; Single-precision floating point
=2					TYPE_STRING = 2         ; ASCII string
=$80					TYPE_ARR_INTEGER = $80  ; Array of 32-bit integers
=$81					TYPE_ARR_FLOAT = $81    ; Array of 32-bit floats
=$82					TYPE_ARR_STRING = $82   ; Array of strings
=$7f					TYPE_BINDING = $7F      ; A variable name binding
=$ff					TYPE_NAV = $FF          ; Not-A-Value
=0					ERR_OK = 0              ; No error
=1					ERR_BREAK = 1           ; The user pressed an interrupt key
=2					ERR_SYNTAX = 2          ; A syntax error was found on the current line
=3					ERR_MEMORY = 3          ; Out of memory
=4					ERR_TYPE = 4            ; Type mismatch error
=5					ERR_NOTFOUND = 5        ; Variable not found error
=6					ERR_NOLINE = 6          ; Line number not found
=7					ERR_STACKUNDER = 7      ; Stack underflow error
=8					ERR_STACKOVER = 8       ; Stack overflow error
=9					ERR_RANGE = 9           ; Out-of-range error
=10					ERR_ARGUMENT = 10       ; Bad argument error
=11					ERR_NOFILE = 11         ; File not found error
=12					ERR_NAN = 12            ; Floating point math resulted in something that is not a number
=13					ERR_OVERFLOW = 13       ; Math operation overflowed
=14					ERR_UNDERFLOW = 14      ; Math operation underflowed
=15					ERR_DIV0 = 15           ; Math operation involved a division by zero
=16					ERR_DIRECTORY = 16      ; Error reading the directory
=17					ERR_LOAD = 17           ; Could not load file
=18					ERR_SAVE = 18           ; Could not save a file
=19					ERR_DELETE = 19         ; Could not delete a file
=20					ERR_FILENOTFOUND = 20   ; Could not find the file
=21					ERR_DIRNOTWRITE = 21    ; Could not update the directory entry
=22					ERR_NOTCOPIED = 22      ; Could not copy the file
=23					ERR_DOMAIN = 23         ; Mathematical functions domain error

;******  Return to file: src\basic816.s


;******  Processing file: src\memorymap.s


;******  Processing file: src\C256/mmap_c256.s

=1					SYS_C256_FMX = 1        ; System SKU for C256 Foenix FMX
=2					SYS_C256_USER = 2       ; System SKU for C256 Foenix User

;******  Processing file: src\C256/page_00_inc.s

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				unused_0000      = $000000 ;12 Bytes unused
=$000008				OPL2_ADDY_PTR_LO = $000008  ; THis Points towards the Instruments Database
=$000009				OPL2_ADDY_PTR_MD = $000009
=$00000a				OPL2_ADDY_PTR_HI = $00000A
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;1 Byte Color of next character to be printed to the screen.
=$00001f				COLORPOS         = $00001F ;3 Byte address of cursor's position in the color matrix
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$000026				OPL2_OPERATOR    = $000026 ;
=$000027				OPL2_CHANNEL     = $000027 ;
=$000028				OPL2_REG_REGION  = $000028 ; Offset to the Group of Registers
=$00002a				OPL2_REG_OFFSET  = $00002A ; 2 Bytes (16Bits)
=$00002c				OPL2_IND_ADDY_LL = $00002C ; 2 Bytes Reserved (Only need 3)
=$00002e				OPL2_IND_ADDY_HL = $00002E ; 2 Bytes Reserved (Only need 3)
=$000030				OPL2_NOTE        = $000030 ; 1 Byte
=$000031				OPL2_OCTAVE      = $000031 ; 1 Byte
=$000032				OPL2_PARAMETER0  = $000032 ; 1 Byte - Key On/Feedback
=$000033				OPL2_PARAMETER1  = $000033 ; 1 Byte
=$000034				OPL2_PARAMETER2  = $000034 ; 1 Byte
=$000035				OPL2_PARAMETER3  = $000035 ; 1 Byte
=$000036				OPL2_LOOP        = $000036 ;
=$000036				OPL2_BLOCK       = $000036
=$000038				SDCARD_FILE_PTR  = $000038 ; 3 Bytes Pointer to Filename to open
=$00003c				SDCARD_BYTE_NUM  = $00003C ; 2Bytes
=$00003f				SDCARD_PRSNT_MNT = $00003F ; 1 Byte, Indicate that the SDCard is Present and that it is Mounted
=$000040				BM_CLEAR_SCRN_X  = $000040
=$000042				BM_CLEAR_SCRN_Y  = $000042
=$000040				RAD_STARTLINE    = $000040 ; 1 Byte
=$000041				RAD_PATTERN_IDX  = $000041 ; 1 Byte
=$000042				RAD_LINE         = $000042 ; 1 Byte
=$000043				RAD_LINENUMBER   = $000043 ; 1 Byte
=$000044				RAD_CHANNEL_NUM  = $000044 ; 1 Byte
=$000045				RAD_ISLASTCHAN   = $000045 ; 1 Byte
=$000046				RAD_Y_POINTER    = $000046 ; 2 Bytes
=$000048				RAD_TICK         = $000048
=$00004a				RAD_CHANNEL_DATA = $00004A ; 2 Bytes
=$00004c				RAD_CHANNE_EFFCT = $00004C
=$00004d				RAD_TEMP         = $00004D
=$000050				RAD_ADDR         = $000050 ; 3 bytes to avoid OPL2 errors.
=$000053				RAD_PATTRN       = $000053 ; 1 bytes - offset to patter
=$000054				RAD_PTN_DEST     = $000054 ; 3 bytes - where to write the pattern data
=$000057				RAD_CHANNEL      = $000057 ; 2 bytes - 0 to 8
=$000059				RAD_LAST_NOTE    = $000059 ; 1 if this is the last note
=$00005a				RAD_LINE_PTR     = $00005A ; 2 bytes - offset to memory location
=$000040				BMP_X_SIZE       = $000040 ; 2 Bytes
=$000042				BMP_Y_SIZE       = $000042 ; 2 Bytes
=$000044				BMP_PRSE_SRC_PTR = $000044 ; 3 Bytes
=$000048				BMP_PRSE_DST_PTR = $000048 ; 3 Bytes
=$00004c				BMP_COLOR_PALET  = $00004C ; 2 Bytes
=$00004e				SCRN_X_STRIDE    = $00004E ; 2 Bytes, Basically How many Pixel Accross in Bitmap Mode
=$000050				BMP_FILE_SIZE    = $000050 ; 4 Bytes
=$000054				BMP_POSITION_X   = $000054 ; 2 Bytes Where, the BMP will be position on the X Axis
=$000056				BMP_POSITION_Y   = $000056 ; 2 Bytes Where, the BMP will be position on the Y Axis
=$000058				BMP_PALET_CHOICE = $000058 ;
=$0000e0				MOUSE_PTR        = $0000E0
=$0000e1				MOUSE_POS_X_LO   = $0000E1
=$0000e2				MOUSE_POS_X_HI   = $0000E2
=$0000e3				MOUSE_POS_Y_LO   = $0000E3
=$0000e4				MOUSE_POS_Y_HI   = $0000E4
=$0000f0				USER_TEMP        = $0000F0 ;32 Bytes Temp space for user programs
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000110				DIVIDER_0        = $000110 ;0 Byte  Unsigned divider
=$000110				D0_OPERAND_A     = $000110 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$000112				D0_OPERAND_B     = $000112 ;2 Bytes Divider 0 Divisor ex B in A/B
=$000114				D0_RESULT        = $000114 ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D0_REMAINDER     = $000116 ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000118				DIVIDER_1        = $000118 ;0 Byte  Signed divider
=$000118				D1_OPERAND_A     = $000118 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$00011a				D1_OPERAND_B     = $00011A ;2 Bytes Divider 1 Divisor ex B in A/B
=$00011c				D1_RESULT        = $00011C ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$00011e				D1_REMAINDER     = $00011E ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$000120				ADDER_SIGNED_32  = $000120 ; The 32 Bit Adders takes 12Byte that are NOT RAM Location
=$000140				INT_CONTROLLER   = $000140 ; $000140...$00015F Interrupt Controller
=$000160				TIMER_CONTROLLER = $000160 ; $000160...$00017F Timer0/Timer1/Timer2 Block
=$000160				TIMER_CTRL_REGLL = $000160 ;
=$000161				TIMER_CTRL_REGLH = $000161 ;
=$000162				TIMER_CTRL_REGHL = $000162 ;
=$000163				TIMER_CTRL_REGHH = $000163 ;
=$000240				CPU_REGISTERS    = $000240 ; Byte
=$000240				CPUPC            = $000240 ;2 Bytes Program Counter (PC)
=$000242				CPUPBR           = $000242 ;2 Bytes Program Bank Register (K)
=$000244				CPUA             = $000244 ;2 Bytes Accumulator (A)
=$000246				CPUX             = $000246 ;2 Bytes X Register (X)
=$000248				CPUY             = $000248 ;2 Bytes Y Register (Y)
=$00024a				CPUSTACK         = $00024A ;2 Bytes Stack Pointer (S)
=$00024c				CPUDP            = $00024C ;2 Bytes Direct Page Register (D)
=$00024e				CPUDBR           = $00024E ;1 Byte  Data Bank Register (B)
=$00024f				CPUFLAGS         = $00024F ;1 Byte  Flags (P)
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$000300				FDC_DRIVE        = $000300 ;1 byte - The number of the selected drive
=$000301				FDC_HEAD         = $000301 ;1 byte - The head number (0 or 1)
=$000302				FDC_CYLINDER     = $000302 ;1 byte - The cylinder number
=$000303				FDC_SECTOR       = $000303 ;1 byte - The sector number
=$000304				FDC_SECTOR_SIZE  = $000304 ;1 byte - The sector size code (2 = 512)
=$000305				FDC_SECPERTRK    = $000305 ;1 byte - The number of sectors per track (18 for 1.44 MB floppy)
=$000306				FDC_ST0          = $000306 ;1 byte - Status Register 0
=$000307				FDC_ST1          = $000307 ;1 byte - Status Register 1
=$000308				FDC_ST2          = $000308 ;1 byte - Status Register 2
=$000309				FDC_ST3          = $000309 ;1 byte - Status Register 3
=$00030a				FDC_PCN          = $00030A ;1 byte - Present Cylinder Number
=$00030b				FDC_STATUS       = $00030B ;1 byte - Status of what we think is going on with the FDC:
=$00030c				DIVIDEND         = $00030C ;4 bytes - Dividend for 32-bit division
=$000310				DIVISOR          = $000310 ;4 bytes - Divisor for 32-bit division
=$000314				REMAINDER        = $000314 ;4 bytes - Remainder for 32-bit division
=$000320				SDOS_VARIABLES   = $000320
=$000320				BIOS_STATUS      = $000320      ; 1 byte - Status of any BIOS operation
=$000321				BIOS_DEV         = $000321      ; 1 byte - Block device number for block operations
=$000322				BIOS_LBA         = $000322      ; 4 bytes - Address of block to read/write (this is the physical block, w/o reference to partition)
=$000326				BIOS_BUFF_PTR    = $000326      ; 4 bytes - 24-bit pointer to memory for read/write operations
=$00032a				BIOS_FIFO_COUNT  = $00032A      ; 2 bytes - The number of bytes read on the last block read
=$00032e				DOS_STATUS       = $00032E      ; 1 byte - The error code describing any error with file access
=$000330				DOS_CLUS_ID      = $000330      ; 4 bytes - The cluster desired for a DOS operation
=$000338				DOS_DIR_PTR      = $000338      ; 4 bytes - Pointer to a directory entry (assumed to be within DOS_SECTOR)
=$00033c				DOS_BUFF_PTR     = $00033C      ; 4 bytes - A pointer for DOS cluster read/write operations
=$000340				DOS_FD_PTR       = $000340      ; 4 bytes - A pointer to a file descriptor
=$000344				DOS_FAT_LBA      = $000344      ; 4 bytes - The LBA for a sector of the FAT we need to read/write
=$000348				DOS_TEMP         = $000348      ; 4 bytes - Temporary storage for DOS operations
=$00034c				DOS_FILE_SIZE    = $00034C      ; 4 bytes - The size of a file
=$000350				DOS_SRC_PTR      = $000350      ; 4 bytes - Pointer for transferring data
=$000354				DOS_DST_PTR      = $000354      ; 4 bytes - Pointer for transferring data
=$000358				DOS_END_PTR      = $000358      ; 4 bytes - Pointer to the last byte to save
=$00035c				DOS_RUN_PTR      = $00035C      ; 4 bytes - Pointer for starting a loaded program
=$000360				DOS_RUN_PARAM    = $000360      ; 4 bytes - Pointer to the ASCIIZ string for arguments in loading a program
=$000364				DOS_STR1_PTR     = $000364      ; 4 bytes - pointer to a string
=$000368				DOS_STR2_PTR     = $000368      ; 4 bytes - pointer to a string
=$00036b				DOS_SCRATCH      = $00036B      ; 4 bytes - general purpose short term storage
=$000400				DOS_PATH_BUFF    = $000400      ; 256 bytes - A buffer for path names
=$000500				FDC_PARAMETERS   = $000500      ; 16 bytes - a buffer of parameter data for the FDC
=$000510				FDC_RESULTS      = $000510      ; 16 bytes - Buffer for results of FDC commands
=$000530				FDC_PARAM_NUM    = $000530      ; 1 byte - The number of parameters to send to the FDC (including command)
=$000532				FDC_RESULT_NUM   = $000532      ; 1 byte - The number of results expected
=$000533				FDC_EXPECT_DAT   = $000533      ; 1 byte - 0 = the command expects no data, otherwise expects data
=$000534				FDC_CMD_RETRY    = $000534      ; 1 byte - a retry counter for commands
=$000700				CURRUART         = $000700 ; 3-bytes: the base address of the current UART
=$000703				CHAN_OUT         = $000703 ; 1-byte: the number of the current output channel (for PUTC, etc.)
=$000704				CHAN_IN          = $000704 ; 1-byte: the number of the current input channel (for GETCH, etc.)
=$000705				TIMERFLAGS       = $000705 ; 1-byte: flags to indicate that one of the timer interupts has triggered
=$80					TIMER0TRIGGER    = $80
=$40					TIMER1TRIGGER    = $40
=$20					TIMER2TRIGGER    = $20
=$000f00				KEY_BUFFER       = $000F00 ; 64 Bytes keyboard buffer
=$0080					KEY_BUFFER_SIZE  = $0080   ;128 Bytes (constant) keyboard buffer length
=$000f7f				KEY_BUFFER_END   = $000F7F ;  1 Byte  Last byte of keyboard buffer
=$000f83				KEY_BUFFER_CMD   = $000F83 ;  1 Byte  Indicates the Command Process Status
=$000f84				COMMAND_SIZE_STR = $000F84 ;  1 Byte
=$000f86				COMMAND_COMP_TMP = $000F86 ;  2 Bytes
=$000f87				KEYBOARD_SC_FLG  = $000F87 ;  1 Bytes that indicate the Status of Left Shift, Left CTRL, Left ALT, Right Shift
=$000f88				KEYBOARD_SC_TMP  = $000F88 ;  1 Byte, Interrupt Save Scan Code while Processing
=$000f89				KEYBOARD_LOCKS   = $000F89 ;  1 Byte, the status of the various lock keys
=$000f8a				KEYFLAG          = $000F8A ;  1 Byte, flag to indicate if CTRL-C has been pressed
=$000f8b				KEY_BUFFER_RPOS  = $000F8B ;  2 Byte, position of the character to read from the KEY_BUFFER
=$000f8d				KEY_BUFFER_WPOS  = $000F8D ;  2 Byte, position of the character to write to the KEY_BUFFER
=$001000				KERNEL_JMP_BEGIN = $001000 ; Reserved for the Kernel jump table
=$001fff				KERNEL_JMP_END   = $001FFF
=$002000				TEST_BEGIN       = $002000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/int_math_defs.s

=$000100				UNSIGNED_MULT_A_LO  = $000100
=$000101				UNSIGNED_MULT_A_HI  = $000101
=$000102				UNSIGNED_MULT_B_LO  = $000102
=$000103				UNSIGNED_MULT_B_HI  = $000103
=$000104				UNSIGNED_MULT_AL_LO = $000104
=$000105				UNSIGNED_MULT_AL_HI = $000105
=$000106				UNSIGNED_MULT_AH_LO = $000106
=$000107				UNSIGNED_MULT_AH_HI = $000107
=$000108				SIGNED_MULT_A_LO    = $000108
=$000109				SIGNED_MULT_A_HI    = $000109
=$00010a				SIGNED_MULT_B_LO    = $00010A
=$00010b				SIGNED_MULT_B_HI    = $00010B
=$00010c				SIGNED_MULT_AL_LO   = $00010C
=$00010d				SIGNED_MULT_AL_HI   = $00010D
=$00010e				SIGNED_MULT_AH_LO   = $00010E
=$00010f				SIGNED_MULT_AH_HI   = $00010F
=$000110				UNSIGNED_DIV_DEM_LO = $000110
=$000111				UNSIGNED_DIV_DEM_HI = $000111
=$000112				UNSIGNED_DIV_NUM_LO = $000112
=$000113				UNSIGNED_DIV_NUM_HI = $000113
=$000114				UNSIGNED_DIV_QUO_LO = $000114
=$000115				UNSIGNED_DIV_QUO_HI = $000115
=$000116				UNSIGNED_DIV_REM_LO = $000116
=$000117				UNSIGNED_DIV_REM_HI = $000117
=$000118				SIGNED_DIV_DEM_LO   = $000118
=$000119				SIGNED_DIV_DEM_HI   = $000119
=$00011a				SIGNED_DIV_NUM_LO   = $00011A
=$00011b				SIGNED_DIV_NUM_HI   = $00011B
=$00011c				SIGNED_DIV_QUO_LO   = $00011C
=$00011d				SIGNED_DIV_QUO_HI   = $00011D
=$00011e				SIGNED_DIV_REM_LO   = $00011E
=$00011f				SIGNED_DIV_REM_HI   = $00011F
=$000120				ADDER32_A_LL        = $000120
=$000121				ADDER32_A_LH        = $000121
=$000122				ADDER32_A_HL        = $000122
=$000123				ADDER32_A_HH        = $000123
=$000124				ADDER32_B_LL        = $000124
=$000125				ADDER32_B_LH        = $000125
=$000126				ADDER32_B_HL        = $000126
=$000127				ADDER32_B_HH        = $000127
=$000128				ADDER32_R_LL        = $000128
=$000129				ADDER32_R_LH        = $000129
=$00012a				ADDER32_R_HL        = $00012A
=$00012b				ADDER32_R_HH        = $00012B
=$af1400				SIGNED32_MULT_A     = $AF1400
=$af1404				SIGNED32_MULT_B     = $AF1404
=$af1408				SIGNED32_MULT_OUT   = $AF1408

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/vicky_def.s

=$af0000				MASTER_CTRL_REG_L	      = $AF0000
=$01					Mstr_Ctrl_Text_Mode_En  = $01       ; Enable the Text Mode
=$02					Mstr_Ctrl_Text_Overlay  = $02       ; Enable the Overlay of the text mode on top of Graphic Mode (the Background Color is ignored)
=$04					Mstr_Ctrl_Graph_Mode_En = $04       ; Enable the Graphic Mode
=$08					Mstr_Ctrl_Bitmap_En     = $08       ; Enable the Bitmap Module In Vicky
=$10					Mstr_Ctrl_TileMap_En    = $10       ; Enable the Tile Module in Vicky
=$20					Mstr_Ctrl_Sprite_En     = $20       ; Enable the Sprite Module in Vicky
=$40					Mstr_Ctrl_GAMMA_En      = $40       ; this Enable the GAMMA correction - The Analog and DVI have different color value, the GAMMA is great to correct the difference
=$80					Mstr_Ctrl_Disable_Vid   = $80       ; This will disable the Scanning of the Video hence giving 100% bandwith to the CPU
=$af0001				MASTER_CTRL_REG_H       = $AF0001
=$01					Mstr_Ctrl_Video_Mode0   = $01       ; 0 - 640x480 (Clock @ 25.175Mhz), 1 - 800x600 (Clock @ 40Mhz)
=$02					Mstr_Ctrl_Video_Mode1   = $02       ; 0 - No Pixel Doubling, 1- Pixel Doubling (Reduce the Pixel Resolution by 2)
=$af0002				GAMMA_CTRL_REG          = $AF0002
=$01					GAMMA_Ctrl_Input        = $01 ; 0 = DipSwitch Chooses GAMMA on/off , 1- Software Control
=$02					GAMMA_Ctrl_Soft         = $02 ; 0 = GAMMA Table is not Applied, 1 = GAMMA Table is Applied
=$08					GAMMA_DP_SW_VAL         = $08 ; READ ONLY - Actual DIP Switch Value
=$10					HIRES_DP_SW_VAL         = $10 ; READ ONLY - 0 = Hi-Res on BOOT ON, 1 = Hi-Res on BOOT OFF
=$af0003				VKY_RESERVED_01         = $AF0003
=$01					Border_Ctrl_Enable      = $01
=$af0004				BORDER_CTRL_REG         = $AF0004 ; Bit[0] - Enable (1 by default)  Bit[4..6]: X Scroll Offset ( Will scroll Left) (Acceptable Value: 0..7)
=$af0005				BORDER_COLOR_B          = $AF0005
=$af0006				BORDER_COLOR_G          = $AF0006
=$af0007				BORDER_COLOR_R          = $AF0007
=$af0008				BORDER_X_SIZE           = $AF0008; X-  Values: 0 - 32 (Default: 32)
=$af0009				BORDER_Y_SIZE           = $AF0009; Y- Values 0 -32 (Default: 32)
=$af000d				BACKGROUND_COLOR_B      = $AF000D ; When in Graphic Mode, if a pixel is "0" then the Background pixel is chosen
=$af000e				BACKGROUND_COLOR_G      = $AF000E
=$af000f				BACKGROUND_COLOR_R      = $AF000F ;
=$af0010				VKY_TXT_CURSOR_CTRL_REG = $AF0010   ;[0]  Enable Text Mode
=$01					Vky_Cursor_Enable       = $01
=$02					Vky_Cursor_Flash_Rate0  = $02       ; 00 - 1/Sec, 01 - 2/Sec, 10 - 4/Sec, 11 - 5/Sec
=$04					Vky_Cursor_Flash_Rate1  = $04
=$08					Vky_Cursor_FONT_Page0   = $08       ; Pick Font Page 0 or Font Page 1
=$10					Vky_Cursor_FONT_Page1   = $10       ; Pick Font Page 0 or Font Page 1
=$af0011				VKY_TXT_START_ADD_PTR   = $AF0011   ; This is an offset to change the Starting address of the Text Mode Buffer (in x)
=$af0012				VKY_TXT_CURSOR_CHAR_REG = $AF0012
=$af0013				VKY_TXT_CURSOR_COLR_REG = $AF0013
=$af0014				VKY_TXT_CURSOR_X_REG_L  = $AF0014
=$af0015				VKY_TXT_CURSOR_X_REG_H  = $AF0015
=$af0016				VKY_TXT_CURSOR_Y_REG_L  = $AF0016
=$af0017				VKY_TXT_CURSOR_Y_REG_H  = $AF0017
=$af001b				VKY_LINE_IRQ_CTRL_REG   = $AF001B ;[0] - Enable Line 0, [1] -Enable Line 1
=$af001c				VKY_LINE0_CMP_VALUE_LO  = $AF001C ;Write Only [7:0]
=$af001d				VKY_LINE0_CMP_VALUE_HI  = $AF001D ;Write Only [3:0]
=$af001e				VKY_LINE1_CMP_VALUE_LO  = $AF001E ;Write Only [7:0]
=$af001f				VKY_LINE1_CMP_VALUE_HI  = $AF001F ;Write Only [3:0]
=$af001c				VKY_INFO_CHIP_NUM_L     = $AF001C   ; VErsion
=$af001d				VKY_INFO_CHIP_NUM_H     = $AF001D   ; Version
=$af001e				VKY_INFO_CHIP_VER_L     = $AF001E   ; Sub-Version
=$af001f				VKY_INFO_CHIP_VER_H     = $AF001F   ; Sub-Version
=$af0500				MOUSE_PTR_GRAP0_START    = $AF0500 ; 16 x 16 = 256 Pixels (Grey Scale) 0 = Transparent, 1 = Black , 255 = White
=$af05ff				MOUSE_PTR_GRAP0_END      = $AF05FF ; Pointer 0
=$af0600				MOUSE_PTR_GRAP1_START    = $AF0600 ;
=$af06ff				MOUSE_PTR_GRAP1_END      = $AF06FF ; Pointer 1
=$af0700				MOUSE_PTR_CTRL_REG_L    = $AF0700 ; Bit[0] Enable, Bit[1] = 0  ( 0 = Pointer0, 1 = Pointer1)
=$af0701				MOUSE_PTR_CTRL_REG_H    = $AF0701 ;
=$af0702				MOUSE_PTR_X_POS_L       = $AF0702 ; X Position (0 - 639) (Can only read now) Writing will have no effect
=$af0703				MOUSE_PTR_X_POS_H       = $AF0703 ;
=$af0704				MOUSE_PTR_Y_POS_L       = $AF0704 ; Y Position (0 - 479) (Can only read now) Writing will have no effect
=$af0705				MOUSE_PTR_Y_POS_H       = $AF0705 ;
=$af0706				MOUSE_PTR_BYTE0         = $AF0706 ; Byte 0 of Mouse Packet (you must write 3 Bytes)
=$af0707				MOUSE_PTR_BYTE1         = $AF0707 ; Byte 1 of Mouse Packet (if you don't, then )
=$af0708				MOUSE_PTR_BYTE2         = $AF0708 ; Byte 2 of Mouse Packet (state Machine will be jammed in 1 state)
=$af070b				C256F_MODEL_MAJOR       = $AF070B ;
=$af070c				C256F_MODEL_MINOR       = $AF070C ;
=$af070d				FPGA_DOR                = $AF070D ;
=$af070e				FPGA_MOR                = $AF070E ;
=$af070f				FPGA_YOR                = $AF070F ;
=$af0900				VMEM2CPU_CTRL_REG      = $AF0900  ;
=$01					VMEM2CPU_Clear_FIFO    = $01        ; Setting this to 1 will flush (Reset) the FIFO, clear it after to return to normal function
=$02					VMEM2CPU_Intterupt     = $02        ; This is not implemented because there is not enough Interrupt line on the FMX
=$af0901				VMEM2CPU_Data_Port     = $AF0901    ; This is a Byte Port of the data that you have requested. (Output of the FIFO)
=$af0902				VMEM2CPU_Fifo_Count_LO = $AF0902    ; FIFO Count Lo (number of byte in the FIFO) FIFO Count is 10bits, Count_Bit0 to Count_Bit7 of Count
=$af0903				VMEM2CPU_Fifo_Count_HI = $AF0903    ; FIFO Count Hi, Bit 0 = Count_Bit8, Bit 1 = Count_Bit9
=$80					VMEM2CPU_Fifo_Empty    = $80        ; Bit 7 of VMEM2CPU_Fifo_Count_HI, when 1, the FIFO is empty.
=$af1f40				FG_CHAR_LUT_PTR         = $AF1F40
=$af1f80				BG_CHAR_LUT_PTR		    = $AF1F80
=$af2000				GRPH_LUT0_PTR		    = $AF2000
=$af2400				GRPH_LUT1_PTR		    = $AF2400
=$af2800				GRPH_LUT2_PTR		    = $AF2800
=$af2c00				GRPH_LUT3_PTR		    = $AF2C00
=$af3000				GRPH_LUT4_PTR		    = $AF3000
=$af3400				GRPH_LUT5_PTR		    = $AF3400
=$af3800				GRPH_LUT6_PTR		    = $AF3800
=$af3c00				GRPH_LUT7_PTR		    = $AF3C00
=$af4000				GAMMA_B_LUT_PTR		    = $AF4000
=$af4100				GAMMA_G_LUT_PTR		    = $AF4100
=$af4200				GAMMA_R_LUT_PTR		    = $AF4200
=$af8000				FONT_MEMORY_BANK0       = $AF8000     ;$AF8000 - $AF87FF
=$afa000				CS_TEXT_MEM_PTR         = $AFA000
=$afc000				CS_COLOR_MEM_PTR        = $AFC000

;******  Processing file: src\C256/VKYII_CFP9553_BITMAP_def.s

=$01					BM_Enable             = $01
=$00					BM_LUT0               = $00 ;
=$02					BM_LUT1               = $02 ;
=$04					BM_LUT2               = $04 ;
=$06					BM_LUT3               = $06 ;
=$08					BM_LUT4               = $08 ;
=$0a					BM_LUT5               = $0A ;
=$0c					BM_LUT6               = $0C ;
=$0e					BM_LUT7               = $0E ;
=$af0100				BM0_CONTROL_REG     = $AF0100
=$af0101				BM0_START_ADDY_L    = $AF0101
=$af0102				BM0_START_ADDY_M    = $AF0102
=$af0103				BM0_START_ADDY_H    = $AF0103
=$af0104				BM0_X_OFFSET        = $AF0104   ; Not Implemented
=$af0105				BM0_Y_OFFSET        = $AF0105   ; Not Implemented
=$af0106				BM0_RESERVED_6      = $AF0106
=$af0107				BM0_RESERVED_7      = $AF0107
=$af0108				BM1_CONTROL_REG     = $AF0108
=$af0109				BM1_START_ADDY_L    = $AF0109
=$af010a				BM1_START_ADDY_M    = $AF010A
=$af010b				BM1_START_ADDY_H    = $AF010B
=$af010c				BM1_X_OFFSET        = $AF010C   ; Not Implemented
=$af010d				BM1_Y_OFFSET        = $AF010D   ; Not Implemented
=$af010e				BM1_RESERVED_6      = $AF010E
=$af010f				BM1_RESERVED_7      = $AF010F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_TILEMAP_def.s

=$01					TILE_Enable             = $01
=0					TILEMAP_CONTROL         = 0             ; Offset to a tile map's control register
=1					TILEMAP_START_ADDY      = 1             ; Offset to a tile map's address
=4					TILEMAP_TOTAL_X         = 4             ; Offset to a tile map's width
=6					TILEMAP_TOTAL_Y         = 6             ; Offset to a tile map's height
=8					TILEMAP_WINDOW_X        = 8             ; Offset to a tile map's X position
=10					TILEMAP_WINDOW_Y        = 10            ; Offset to a tile map's Y position
=1					TILEMAP_VISIBLE         = 1             ; Tile map is visible flag
=$af0200				TL0_CONTROL_REG         = $AF0200       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0201				TL0_START_ADDY_L        = $AF0201       ; Not USed right now - Starting Address to where is the MAP
=$af0202				TL0_START_ADDY_M        = $AF0202
=$af0203				TL0_START_ADDY_H        = $AF0203
=$af0204				TL0_TOTAL_X_SIZE_L      = $AF0204       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0205				TL0_TOTAL_X_SIZE_H      = $AF0205
=$af0206				TL0_TOTAL_Y_SIZE_L      = $AF0206       ; Size of the Map in Y Tile Count [9:0]
=$af0207				TL0_TOTAL_Y_SIZE_H      = $AF0207
=$af0208				TL0_WINDOW_X_POS_L      = $AF0208       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0209				TL0_WINDOW_X_POS_H      = $AF0209       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af020a				TL0_WINDOW_Y_POS_L      = $AF020A       ; Top Left Corner Position of the TileMAp Window in Y
=$af020b				TL0_WINDOW_Y_POS_H      = $AF020B       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af020c				TL1_CONTROL_REG         = $AF020C       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af020d				TL1_START_ADDY_L        = $AF020D       ; Not USed right now - Starting Address to where is the MAP
=$af020e				TL1_START_ADDY_M        = $AF020E
=$af020f				TL1_START_ADDY_H        = $AF020F
=$af0210				TL1_TOTAL_X_SIZE_L      = $AF0210       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0211				TL1_TOTAL_X_SIZE_H      = $AF0211
=$af0212				TL1_TOTAL_Y_SIZE_L      = $AF0212       ; Size of the Map in Y Tile Count [9:0]
=$af0213				TL1_TOTAL_Y_SIZE_H      = $AF0213
=$af0214				TL1_WINDOW_X_POS_L      = $AF0214       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0215				TL1_WINDOW_X_POS_H      = $AF0215       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0216				TL1_WINDOW_Y_POS_L      = $AF0216       ; Top Left Corner Position of the TileMAp Window in Y
=$af0217				TL1_WINDOW_Y_POS_H      = $AF0217       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0218				TL2_CONTROL_REG         = $AF0218       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0219				TL2_START_ADDY_L        = $AF0219       ; Not USed right now - Starting Address to where is the MAP
=$af021a				TL2_START_ADDY_M        = $AF021A
=$af021b				TL2_START_ADDY_H        = $AF021B
=$af021c				TL2_TOTAL_X_SIZE_L      = $AF021C       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af021d				TL2_TOTAL_X_SIZE_H      = $AF021D
=$af021e				TL2_TOTAL_Y_SIZE_L      = $AF021E       ; Size of the Map in Y Tile Count [9:0]
=$af021f				TL2_TOTAL_Y_SIZE_H      = $AF021F
=$af0220				TL2_WINDOW_X_POS_L      = $AF0220       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0221				TL2_WINDOW_X_POS_H      = $AF0221       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0222				TL2_WINDOW_Y_POS_L      = $AF0222       ; Top Left Corner Position of the TileMAp Window in Y
=$af0223				TL2_WINDOW_Y_POS_H      = $AF0223       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0224				TL3_CONTROL_REG         = $AF0224       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0225				TL3_START_ADDY_L        = $AF0225       ; Not USed right now - Starting Address to where is the MAP
=$af0226				TL3_START_ADDY_M        = $AF0226
=$af0227				TL3_START_ADDY_H        = $AF0227
=$af0228				TL3_TOTAL_X_SIZE_L      = $AF0228       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0229				TL3_TOTAL_X_SIZE_H      = $AF0229
=$af022a				TL3_TOTAL_Y_SIZE_L      = $AF022A       ; Size of the Map in Y Tile Count [9:0]
=$af022b				TL3_TOTAL_Y_SIZE_H      = $AF022B
=$af022c				TL3_WINDOW_X_POS_L      = $AF022C       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af022d				TL3_WINDOW_X_POS_H      = $AF022D       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af022e				TL3_WINDOW_Y_POS_L      = $AF022E       ; Top Left Corner Position of the TileMAp Window in Y
=$af022f				TL3_WINDOW_Y_POS_H      = $AF022F       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0280				TILESET0_ADDY_L         = $AF0280   ; Pointer to Tileset 0 [21:0]
=$af0281				TILESET0_ADDY_M         = $AF0281
=$af0282				TILESET0_ADDY_H         = $AF0282
=$af0283				TILESET0_ADDY_CFG       = $AF0283   ; [3] - TileStride256x256 [2:0] LUT
=2					TILESET_ADDY_H          = 2             ; Offset to high byte of tile set address
=3					TILESET_ADDY_CFG        = 3             ; Offset to the tile set address configuration
=$08					TILESET_SQUARE_256      = $08
=$af0284				TILESET1_ADDY_L         = $AF0284
=$af0285				TILESET1_ADDY_M         = $AF0285
=$af0286				TILESET1_ADDY_H         = $AF0286
=$af0287				TILESET1_ADDY_CFG       = $AF0287
=$af0288				TILESET2_ADDY_L         = $AF0288
=$af0289				TILESET2_ADDY_M         = $AF0289
=$af028a				TILESET2_ADDY_H         = $AF028A
=$af028b				TILESET2_ADDY_CFG       = $AF028B
=$af028c				TILESET3_ADDY_L         = $AF028C
=$af028d				TILESET3_ADDY_M         = $AF028D
=$af028e				TILESET3_ADDY_H         = $AF028E
=$af028f				TILESET3_ADDY_CFG       = $AF028F
=$af0290				TILESET4_ADDY_L         = $AF0290
=$af0291				TILESET4_ADDY_M         = $AF0291
=$af0292				TILESET4_ADDY_H         = $AF0292
=$af0293				TILESET4_ADDY_CFG       = $AF0293
=$af0294				TILESET5_ADDY_L         = $AF0294
=$af0295				TILESET5_ADDY_M         = $AF0295
=$af0296				TILESET5_ADDY_H         = $AF0296
=$af0297				TILESET5_ADDY_CFG       = $AF0297
=$af0298				TILESET6_ADDY_L         = $AF0298
=$af0299				TILESET6_ADDY_M         = $AF0299
=$af029a				TILESET6_ADDY_H         = $AF029A
=$af029b				TILESET6_ADDY_CFG       = $AF029B
=$af029c				TILESET7_ADDY_L         = $AF029C
=$af029d				TILESET7_ADDY_M         = $AF029D
=$af029e				TILESET7_ADDY_H         = $AF029E
=$af029f				TILESET7_ADDY_CFG       = $AF029F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SDMA_def.s

=$af0420				SDMA_CTRL_REG0           = $AF0420
=$01					SDMA_CTRL0_Enable        = $01
=$02					SDMA_CTRL0_1D_2D         = $02     ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					SDMA_CTRL0_TRF_Fill      = $04     ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					SDMA_CTRL0_Int_Enable    = $08     ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					SDMA_CTRL0_SysRAM_Src    = $10     ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					SDMA_CTRL0_SysRAM_Dst    = $20     ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$00					SDMA_XFER_SRAM2SRAM = $00           ; SRAM -> SRAM transfer
=$10					SDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					SDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$30					SDMA_XFER_SRAMIO = $30              ; SRAM <-> IO transfer (see: SDMA_CONTROL_REG1 for config and direction)
=$40					SDMA_CTLR0_RSVD          = $40      ; Reserved
=$80					SDMA_CTRL0_Start_TRF     = $80      ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$af0421				SDMA_CTRL_REG1           = $AF0421  ; Write Only - Byte to Write in the Fill Function
=$01					SDMA_CTRL1_IO_Src		 = $01		; 1 = Source is an IO Address (ADC, SuperIO, IDE)
=$02					SDMA_CTRL1_IO_Src16		 = $02		; 0 = Src 8Bits Transfer / 1= 16Bits Transfer
=$04					SDMA_CTRL1_IO_Dst		 = $04		; 1 = Destination is an IO Address (DAC, SuperIO, IDE)
=$08					SDMA_CTRL1_IO_Dst16      = $08      ; 0 = Dst 8bits Transfer / 1= 16bits
=$af0422				SDMA_SRC_ADDY_L         = $AF0422   ; Pointer to the Source of the Data to be stransfered
=$af0423				SDMA_SRC_ADDY_M         = $AF0423   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0424				SDMA_SRC_ADDY_H         = $AF0424
=$af0425				SDMA_DST_ADDY_L         = $AF0425   ; Destination Pointer within CPU's video memory Range
=$af0426				SDMA_DST_ADDY_M         = $AF0426   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0427				SDMA_DST_ADDY_H         = $AF0427
=$af0428				SDMA_SIZE_L             = $AF0428   ; Maximum Value: $40:0000 (4Megs)
=$af0429				SDMA_SIZE_M             = $AF0429
=$af042a				SDMA_SIZE_H             = $AF042A
=$af042b				SDMA_IGNORED            = $AF042B
=$af0428				SDMA_X_SIZE_L           = $AF0428   ; Maximum Value: 65535
=$af0429				SDMA_X_SIZE_H           = $AF0429
=$af042a				SDMA_Y_SIZE_L           = $AF042A   ; Maximum Value: 65535
=$af042b				SDMA_Y_SIZE_H           = $AF042B
=$af042c				SDMA_SRC_STRIDE_L       = $AF042C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042d				SDMA_SRC_STRIDE_H       = $AF042D   ;
=$af042e				SDMA_DST_STRIDE_L       = $AF042E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042f				SDMA_DST_STRIDE_H       = $AF042F   ;
=$af0430				SDMA_BYTE_2_WRITE       = $AF0430   ; Write Only - Byte to Write in the Fill Function
=$af0430				SDMA_STATUS_REG         = $AF0430   ; Read only
=$01					SDMA_STAT_Size_Err       = $01      ; If Set to 1, Overall Size is Invalid
=$02					SDMA_STAT_Dst_Add_Err    = $02      ; If Set to 1, Destination Address Invalid
=$04					SDMA_STAT_Src_Add_Err    = $04      ; If Set to 1, Source Address Invalid
=$08					SDMA_STAT_TimeOut_Err    = $08      ; will be set to 1 if a Timeout occur when transfering between data from and to VRAM

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_VDMA_def.s

=$af0400				VDMA_CONTROL_REG        = $AF0400
=$01					VDMA_CTRL_Enable        = $01
=$02					VDMA_CTRL_1D_2D         = $02       ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					VDMA_CTRL_TRF_Fill      = $04       ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					VDMA_CTRL_Int_Enable    = $08       ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					VDMA_CTRL_SysRAM_Src    = $10       ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					VDMA_CTRL_SysRAM_Dst    = $20       ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$80					VDMA_CTRL_Start_TRF     = $80       ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$00					VDMA_XFER_VRAM2VRAM = $00           ; VRAM -> VRAM transfer
=$10					VDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					VDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$af0401				VDMA_BYTE_2_WRITE       = $AF0401   ; Write Only - Byte to Write in the Fill Function
=$af0401				VDMA_STATUS_REG         = $AF0401   ; Read only
=$01					VDMA_STAT_Size_Err      = $01       ; If Set to 1, Overall Size is Invalid
=$02					VDMA_STAT_Dst_Add_Err   = $02       ; If Set to 1, Destination Address Invalid
=$04					VDMA_STAT_Src_Add_Err   = $04       ; If Set to 1, Source Address Invalid
=$80					VDMA_STAT_VDMA_IPS      = $80       ; If Set to 1, VDMA Transfer in Progress (this Inhibit CPU Access to Mem)
=$af0402				VDMA_SRC_ADDY_L         = $AF0402   ; Pointer to the Source of the Data to be stransfered
=$af0403				VDMA_SRC_ADDY_M         = $AF0403   ; This needs to be within Vicky's Range ($00_0000 - $3F_0000)
=$af0404				VDMA_SRC_ADDY_H         = $AF0404
=$af0405				VDMA_DST_ADDY_L         = $AF0405   ; Destination Pointer within Vicky's video memory Range
=$af0406				VDMA_DST_ADDY_M         = $AF0406   ; ($00_0000 - $3F_0000)
=$af0407				VDMA_DST_ADDY_H         = $AF0407
=$af0408				VDMA_SIZE_L             = $AF0408   ; Maximum Value: $40:0000 (4Megs)
=$af0409				VDMA_SIZE_M             = $AF0409
=$af040a				VDMA_SIZE_H             = $AF040A
=$af040b				VDMA_IGNORED            = $AF040B
=$af0408				VDMA_X_SIZE_L           = $AF0408   ; Maximum Value: 65535
=$af0409				VDMA_X_SIZE_H           = $AF0409
=$af040a				VDMA_Y_SIZE_L           = $AF040A   ; Maximum Value: 65535
=$af040b				VDMA_Y_SIZE_H           = $AF040B
=$af040c				VDMA_SRC_STRIDE_L       = $AF040C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040d				VDMA_SRC_STRIDE_H       = $AF040D   ;
=$af040e				VDMA_DST_STRIDE_L       = $AF040E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040f				VDMA_DST_STRIDE_H       = $AF040F   ;

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SPRITE_def.s

=$01					SPRITE_Enable             = $01
=$00					SPRITE_LUT0               = $00 ; This is the LUT that the Sprite will use
=$02					SPRITE_LUT1               = $02
=$04					SPRITE_LUT2               = $04 ; Only 4 LUT for Now, So this bit is not used.
=$06					SPRITE_LUT3               = $06 ; Only 4 LUT for Now, So this bit is not used.
=$08					SPRITE_LUT4               = $08 ; Only 4 LUT for Now, So this bit is not used.
=$0a					SPRITE_LUT5               = $0A ; Only 4 LUT for Now, So this bit is not used.
=$0c					SPRITE_LUT6               = $0C ; Only 4 LUT for Now, So this bit is not used.
=$0e					SPRITE_LUT7               = $0E ; Only 4 LUT for Now, So this bit is not used.
=$00					SPRITE_DEPTH0             = $00
=$10					SPRITE_DEPTH1             = $10
=$20					SPRITE_DEPTH2             = $20
=$30					SPRITE_DEPTH3             = $30
=$40					SPRITE_DEPTH4             = $40
=$50					SPRITE_DEPTH5             = $50
=$60					SPRITE_DEPTH6             = $60
=$af0c00				SP00_CONTROL_REG        = $AF0C00
=$af0c01				SP00_ADDY_PTR_L         = $AF0C01
=$af0c02				SP00_ADDY_PTR_M         = $AF0C02
=$af0c03				SP00_ADDY_PTR_H         = $AF0C03
=$af0c04				SP00_X_POS_L            = $AF0C04
=$af0c05				SP00_X_POS_H            = $AF0C05
=$af0c06				SP00_Y_POS_L            = $AF0C06
=$af0c07				SP00_Y_POS_H            = $AF0C07
=$af0c08				SP01_CONTROL_REG        = $AF0C08
=$af0c09				SP01_ADDY_PTR_L         = $AF0C09
=$af0c0a				SP01_ADDY_PTR_M         = $AF0C0A
=$af0c0b				SP01_ADDY_PTR_H         = $AF0C0B
=$af0c0c				SP01_X_POS_L            = $AF0C0C
=$af0c0d				SP01_X_POS_H            = $AF0C0D
=$af0c0e				SP01_Y_POS_L            = $AF0C0E
=$af0c0f				SP01_Y_POS_H            = $AF0C0F
=$af0c10				SP02_CONTROL_REG        = $AF0C10
=$af0c11				SP02_ADDY_PTR_L         = $AF0C11
=$af0c12				SP02_ADDY_PTR_M         = $AF0C12
=$af0c13				SP02_ADDY_PTR_H         = $AF0C13
=$af0c14				SP02_X_POS_L            = $AF0C14
=$af0c15				SP02_X_POS_H            = $AF0C15
=$af0c16				SP02_Y_POS_L            = $AF0C16
=$af0c17				SP02_Y_POS_H            = $AF0C17
=$af0c18				SP03_CONTROL_REG        = $AF0C18
=$af0c19				SP03_ADDY_PTR_L         = $AF0C19
=$af0c1a				SP03_ADDY_PTR_M         = $AF0C1A
=$af0c1b				SP03_ADDY_PTR_H         = $AF0C1B
=$af0c1c				SP03_X_POS_L            = $AF0C1C
=$af0c1d				SP03_X_POS_H            = $AF0C1D
=$af0c1e				SP03_Y_POS_L            = $AF0C1E
=$af0c1f				SP03_Y_POS_H            = $AF0C1F
=$af0c20				SP04_CONTROL_REG        = $AF0C20
=$af0c21				SP04_ADDY_PTR_L         = $AF0C21
=$af0c22				SP04_ADDY_PTR_M         = $AF0C22
=$af0c23				SP04_ADDY_PTR_H         = $AF0C23
=$af0c24				SP04_X_POS_L            = $AF0C24
=$af0c25				SP04_X_POS_H            = $AF0C25
=$af0c26				SP04_Y_POS_L            = $AF0C26
=$af0c27				SP04_Y_POS_H            = $AF0C27
=$af0c28				SP05_CONTROL_REG        = $AF0C28
=$af0c29				SP05_ADDY_PTR_L         = $AF0C29
=$af0c2a				SP05_ADDY_PTR_M         = $AF0C2A
=$af0c2b				SP05_ADDY_PTR_H         = $AF0C2B
=$af0c2c				SP05_X_POS_L            = $AF0C2C
=$af0c2d				SP05_X_POS_H            = $AF0C2D
=$af0c2e				SP05_Y_POS_L            = $AF0C2E
=$af0c2f				SP05_Y_POS_H            = $AF0C2F
=$af0c30				SP06_CONTROL_REG        = $AF0C30
=$af0c31				SP06_ADDY_PTR_L         = $AF0C31
=$af0c32				SP06_ADDY_PTR_M         = $AF0C32
=$af0c33				SP06_ADDY_PTR_H         = $AF0C33
=$af0c34				SP06_X_POS_L            = $AF0C34
=$af0c35				SP06_X_POS_H            = $AF0C35
=$af0c36				SP06_Y_POS_L            = $AF0C36
=$af0c37				SP06_Y_POS_H            = $AF0C37
=$af0c38				SP07_CONTROL_REG        = $AF0C38
=$af0c39				SP07_ADDY_PTR_L         = $AF0C39
=$af0c3a				SP07_ADDY_PTR_M         = $AF0C3A
=$af0c3b				SP07_ADDY_PTR_H         = $AF0C3B
=$af0c3c				SP07_X_POS_L            = $AF0C3C
=$af0c3d				SP07_X_POS_H            = $AF0C3D
=$af0c3e				SP07_Y_POS_L            = $AF0C3E
=$af0c3f				SP07_Y_POS_H            = $AF0C3F
=$af0c40				SP08_CONTROL_REG        = $AF0C40
=$af0c41				SP08_ADDY_PTR_L         = $AF0C41
=$af0c42				SP08_ADDY_PTR_M         = $AF0C42
=$af0c43				SP08_ADDY_PTR_H         = $AF0C43
=$af0c44				SP08_X_POS_L            = $AF0C44
=$af0c45				SP08_X_POS_H            = $AF0C45
=$af0c46				SP08_Y_POS_L            = $AF0C46
=$af0c47				SP08_Y_POS_H            = $AF0C47
=$af0c48				SP09_CONTROL_REG        = $AF0C48
=$af0c49				SP09_ADDY_PTR_L         = $AF0C49
=$af0c4a				SP09_ADDY_PTR_M         = $AF0C4A
=$af0c4b				SP09_ADDY_PTR_H         = $AF0C4B
=$af0c4c				SP09_X_POS_L            = $AF0C4C
=$af0c4d				SP09_X_POS_H            = $AF0C4D
=$af0c4e				SP09_Y_POS_L            = $AF0C4E
=$af0c4f				SP09_Y_POS_H            = $AF0C4F
=$af0c50				SP10_CONTROL_REG        = $AF0C50
=$af0c51				SP10_ADDY_PTR_L         = $AF0C51
=$af0c52				SP10_ADDY_PTR_M         = $AF0C52
=$af0c53				SP10_ADDY_PTR_H         = $AF0C53
=$af0c54				SP10_X_POS_L            = $AF0C54
=$af0c55				SP10_X_POS_H            = $AF0C55
=$af0c56				SP10_Y_POS_L            = $AF0C56
=$af0c57				SP10_Y_POS_H            = $AF0C57
=$af0c58				SP11_CONTROL_REG        = $AF0C58
=$af0c59				SP11_ADDY_PTR_L         = $AF0C59
=$af0c5a				SP11_ADDY_PTR_M         = $AF0C5A
=$af0c5b				SP11_ADDY_PTR_H         = $AF0C5B
=$af0c5c				SP11_X_POS_L            = $AF0C5C
=$af0c5d				SP11_X_POS_H            = $AF0C5D
=$af0c5e				SP11_Y_POS_L            = $AF0C5E
=$af0c5f				SP11_Y_POS_H            = $AF0C5F
=$af0c60				SP12_CONTROL_REG        = $AF0C60
=$af0c61				SP12_ADDY_PTR_L         = $AF0C61
=$af0c62				SP12_ADDY_PTR_M         = $AF0C62
=$af0c63				SP12_ADDY_PTR_H         = $AF0C63
=$af0c64				SP12_X_POS_L            = $AF0C64
=$af0c65				SP12_X_POS_H            = $AF0C65
=$af0c66				SP12_Y_POS_L            = $AF0C66
=$af0c67				SP12_Y_POS_H            = $AF0C67
=$af0c68				SP13_CONTROL_REG        = $AF0C68
=$af0c69				SP13_ADDY_PTR_L         = $AF0C69
=$af0c6a				SP13_ADDY_PTR_M         = $AF0C6A
=$af0c6b				SP13_ADDY_PTR_H         = $AF0C6B
=$af0c6c				SP13_X_POS_L            = $AF0C6C
=$af0c6d				SP13_X_POS_H            = $AF0C6D
=$af0c6e				SP13_Y_POS_L            = $AF0C6E
=$af0c6f				SP13_Y_POS_H            = $AF0C6F
=$af0c70				SP14_CONTROL_REG        = $AF0C70
=$af0c71				SP14_ADDY_PTR_L         = $AF0C71
=$af0c72				SP14_ADDY_PTR_M         = $AF0C72
=$af0c73				SP14_ADDY_PTR_H         = $AF0C73
=$af0c74				SP14_X_POS_L            = $AF0C74
=$af0c75				SP14_X_POS_H            = $AF0C75
=$af0c76				SP14_Y_POS_L            = $AF0C76
=$af0c77				SP14_Y_POS_H            = $AF0C77
=$af0c78				SP15_CONTROL_REG        = $AF0C78
=$af0c79				SP15_ADDY_PTR_L         = $AF0C79
=$af0c7a				SP15_ADDY_PTR_M         = $AF0C7A
=$af0c7b				SP15_ADDY_PTR_H         = $AF0C7B
=$af0c7c				SP15_X_POS_L            = $AF0C7C
=$af0c7d				SP15_X_POS_H            = $AF0C7D
=$af0c7e				SP15_Y_POS_L            = $AF0C7E
=$af0c7f				SP15_Y_POS_H            = $AF0C7F
=$af0c80				SP16_CONTROL_REG        = $AF0C80
=$af0c81				SP16_ADDY_PTR_L         = $AF0C81
=$af0c82				SP16_ADDY_PTR_M         = $AF0C82
=$af0c83				SP16_ADDY_PTR_H         = $AF0C83
=$af0c84				SP16_X_POS_L            = $AF0C84
=$af0c85				SP16_X_POS_H            = $AF0C85
=$af0c86				SP16_Y_POS_L            = $AF0C86
=$af0c87				SP16_Y_POS_H            = $AF0C87
=$af0c88				SP17_CONTROL_REG        = $AF0C88
=$af0c89				SP17_ADDY_PTR_L         = $AF0C89
=$af0c8a				SP17_ADDY_PTR_M         = $AF0C8A
=$af0c8b				SP17_ADDY_PTR_H         = $AF0C8B
=$af0c8c				SP17_X_POS_L            = $AF0C8C
=$af0c8d				SP17_X_POS_H            = $AF0C8D
=$af0c8e				SP17_Y_POS_L            = $AF0C8E
=$af0c8f				SP17_Y_POS_H            = $AF0C8F
=$af0c90				SP18_CONTROL_REG        = $AF0C90
=$af0c91				SP18_ADDY_PTR_L         = $AF0C91
=$af0c92				SP18_ADDY_PTR_M         = $AF0C92
=$af0c93				SP18_ADDY_PTR_H         = $AF0C93
=$af0c94				SP18_X_POS_L            = $AF0C94
=$af0c95				SP18_X_POS_H            = $AF0C95
=$af0c96				SP18_Y_POS_L            = $AF0C96
=$af0c97				SP18_Y_POS_H            = $AF0C97
=$af0c98				SP19_CONTROL_REG        = $AF0C98
=$af0c99				SP19_ADDY_PTR_L         = $AF0C99
=$af0c9a				SP19_ADDY_PTR_M         = $AF0C9A
=$af0c9b				SP19_ADDY_PTR_H         = $AF0C9B
=$af0c9c				SP19_X_POS_L            = $AF0C9C
=$af0c9d				SP19_X_POS_H            = $AF0C9D
=$af0c9e				SP19_Y_POS_L            = $AF0C9E
=$af0c9f				SP19_Y_POS_H            = $AF0C9F
=$af0ca0				SP20_CONTROL_REG        = $AF0CA0
=$af0ca1				SP20_ADDY_PTR_L         = $AF0CA1
=$af0ca2				SP20_ADDY_PTR_M         = $AF0CA2
=$af0ca3				SP20_ADDY_PTR_H         = $AF0CA3
=$af0ca4				SP20_X_POS_L            = $AF0CA4
=$af0ca5				SP20_X_POS_H            = $AF0CA5
=$af0ca6				SP20_Y_POS_L            = $AF0CA6
=$af0ca7				SP20_Y_POS_H            = $AF0CA7
=$af0ca8				SP21_CONTROL_REG        = $AF0CA8
=$af0ca9				SP21_ADDY_PTR_L         = $AF0CA9
=$af0caa				SP21_ADDY_PTR_M         = $AF0CAA
=$af0cab				SP21_ADDY_PTR_H         = $AF0CAB
=$af0cac				SP21_X_POS_L            = $AF0CAC
=$af0cad				SP21_X_POS_H            = $AF0CAD
=$af0cae				SP21_Y_POS_L            = $AF0CAE
=$af0caf				SP21_Y_POS_H            = $AF0CAF
=$af0cb0				SP22_CONTROL_REG        = $AF0CB0
=$af0cb1				SP22_ADDY_PTR_L         = $AF0CB1
=$af0cb2				SP22_ADDY_PTR_M         = $AF0CB2
=$af0cb3				SP22_ADDY_PTR_H         = $AF0CB3
=$af0cb4				SP22_X_POS_L            = $AF0CB4
=$af0cb5				SP22_X_POS_H            = $AF0CB5
=$af0cb6				SP22_Y_POS_L            = $AF0CB6
=$af0cb7				SP22_Y_POS_H            = $AF0CB7
=$af0cb8				SP23_CONTROL_REG        = $AF0CB8
=$af0cb9				SP23_ADDY_PTR_L         = $AF0CB9
=$af0cba				SP23_ADDY_PTR_M         = $AF0CBA
=$af0cbb				SP23_ADDY_PTR_H         = $AF0CBB
=$af0cbc				SP23_X_POS_L            = $AF0CBC
=$af0cbd				SP23_X_POS_H            = $AF0CBD
=$af0cbe				SP23_Y_POS_L            = $AF0CBE
=$af0cbf				SP23_Y_POS_H            = $AF0CBF
=$af0cc0				SP24_CONTROL_REG        = $AF0CC0
=$af0cc1				SP24_ADDY_PTR_L         = $AF0CC1
=$af0cc2				SP24_ADDY_PTR_M         = $AF0CC2
=$af0cc3				SP24_ADDY_PTR_H         = $AF0CC3
=$af0cc4				SP24_X_POS_L            = $AF0CC4
=$af0cc5				SP24_X_POS_H            = $AF0CC5
=$af0cc6				SP24_Y_POS_L            = $AF0CC6
=$af0cc7				SP24_Y_POS_H            = $AF0CC7
=$af0cc8				SP25_CONTROL_REG        = $AF0CC8
=$af0cc9				SP25_ADDY_PTR_L         = $AF0CC9
=$af0cca				SP25_ADDY_PTR_M         = $AF0CCA
=$af0ccb				SP25_ADDY_PTR_H         = $AF0CCB
=$af0ccc				SP25_X_POS_L            = $AF0CCC
=$af0ccd				SP25_X_POS_H            = $AF0CCD
=$af0cce				SP25_Y_POS_L            = $AF0CCE
=$af0ccf				SP25_Y_POS_H            = $AF0CCF
=$af0cd0				SP26_CONTROL_REG        = $AF0CD0
=$af0cd1				SP26_ADDY_PTR_L         = $AF0CD1
=$af0cd2				SP26_ADDY_PTR_M         = $AF0CD2
=$af0cd3				SP26_ADDY_PTR_H         = $AF0CD3
=$af0cd4				SP26_X_POS_L            = $AF0CD4
=$af0cd5				SP26_X_POS_H            = $AF0CD5
=$af0cd6				SP26_Y_POS_L            = $AF0CD6
=$af0cd7				SP26_Y_POS_H            = $AF0CD7
=$af0cd8				SP27_CONTROL_REG        = $AF0CD8
=$af0cd9				SP27_ADDY_PTR_L         = $AF0CD9
=$af0cda				SP27_ADDY_PTR_M         = $AF0CDA
=$af0cdb				SP27_ADDY_PTR_H         = $AF0CDB
=$af0cdc				SP27_X_POS_L            = $AF0CDC
=$af0cdd				SP27_X_POS_H            = $AF0CDD
=$af0cde				SP27_Y_POS_L            = $AF0CDE
=$af0cdf				SP27_Y_POS_H            = $AF0CDF
=$af0ce0				SP28_CONTROL_REG        = $AF0CE0
=$af0ce1				SP28_ADDY_PTR_L         = $AF0CE1
=$af0ce2				SP28_ADDY_PTR_M         = $AF0CE2
=$af0ce3				SP28_ADDY_PTR_H         = $AF0CE3
=$af0ce4				SP28_X_POS_L            = $AF0CE4
=$af0ce5				SP28_X_POS_H            = $AF0CE5
=$af0ce6				SP28_Y_POS_L            = $AF0CE6
=$af0ce7				SP28_Y_POS_H            = $AF0CE7
=$af0ce8				SP29_CONTROL_REG        = $AF0CE8
=$af0ce9				SP29_ADDY_PTR_L         = $AF0CE9
=$af0cea				SP29_ADDY_PTR_M         = $AF0CEA
=$af0ceb				SP29_ADDY_PTR_H         = $AF0CEB
=$af0cec				SP29_X_POS_L            = $AF0CEC
=$af0ced				SP29_X_POS_H            = $AF0CED
=$af0cee				SP29_Y_POS_L            = $AF0CEE
=$af0cef				SP29_Y_POS_H            = $AF0CEF
=$af0cf0				SP30_CONTROL_REG        = $AF0CF0
=$af0cf1				SP30_ADDY_PTR_L         = $AF0CF1
=$af0cf2				SP30_ADDY_PTR_M         = $AF0CF2
=$af0cf3				SP30_ADDY_PTR_H         = $AF0CF3
=$af0cf4				SP30_X_POS_L            = $AF0CF4
=$af0cf5				SP30_X_POS_H            = $AF0CF5
=$af0cf6				SP30_Y_POS_L            = $AF0CF6
=$af0cf7				SP30_Y_POS_H            = $AF0CF7
=$af0cf8				SP31_CONTROL_REG        = $AF0CF8
=$af0cf9				SP31_ADDY_PTR_L         = $AF0CF9
=$af0cfa				SP31_ADDY_PTR_M         = $AF0CFA
=$af0cfb				SP31_ADDY_PTR_H         = $AF0CFB
=$af0cfc				SP31_X_POS_L            = $AF0CFC
=$af0cfd				SP31_X_POS_H            = $AF0CFD
=$af0cfe				SP31_Y_POS_L            = $AF0CFE
=$af0cff				SP31_Y_POS_H            = $AF0CFF
=$af0d00				SP32_CONTROL_REG        = $AF0D00
=$af0d01				SP32_ADDY_PTR_L         = $AF0D01
=$af0d02				SP32_ADDY_PTR_M         = $AF0D02
=$af0d03				SP32_ADDY_PTR_H         = $AF0D03
=$af0d04				SP32_X_POS_L            = $AF0D04
=$af0d05				SP32_X_POS_H            = $AF0D05
=$af0d06				SP32_Y_POS_L            = $AF0D06
=$af0d07				SP32_Y_POS_H            = $AF0D07
=$af0d08				SP33_CONTROL_REG        = $AF0D08
=$af0d09				SP33_ADDY_PTR_L         = $AF0D09
=$af0d0a				SP33_ADDY_PTR_M         = $AF0D0A
=$af0d0b				SP33_ADDY_PTR_H         = $AF0D0B
=$af0d0c				SP33_X_POS_L            = $AF0D0C
=$af0d0d				SP33_X_POS_H            = $AF0D0D
=$af0d0e				SP33_Y_POS_L            = $AF0D0E
=$af0d0f				SP33_Y_POS_H            = $AF0D0F
=$af0d10				SP34_CONTROL_REG        = $AF0D10
=$af0d11				SP34_ADDY_PTR_L         = $AF0D11
=$af0d12				SP34_ADDY_PTR_M         = $AF0D12
=$af0d13				SP34_ADDY_PTR_H         = $AF0D13
=$af0d14				SP34_X_POS_L            = $AF0D14
=$af0d15				SP34_X_POS_H            = $AF0D15
=$af0d16				SP34_Y_POS_L            = $AF0D16
=$af0d17				SP34_Y_POS_H            = $AF0D17
=$af0d18				SP35_CONTROL_REG        = $AF0D18
=$af0d19				SP35_ADDY_PTR_L         = $AF0D19
=$af0d1a				SP35_ADDY_PTR_M         = $AF0D1A
=$af0d1b				SP35_ADDY_PTR_H         = $AF0D1B
=$af0d1c				SP35_X_POS_L            = $AF0D1C
=$af0d1d				SP35_X_POS_H            = $AF0D1D
=$af0d1e				SP35_Y_POS_L            = $AF0D1E
=$af0d1f				SP35_Y_POS_H            = $AF0D1F
=$af0d20				SP36_CONTROL_REG        = $AF0D20
=$af0d21				SP36_ADDY_PTR_L         = $AF0D21
=$af0d22				SP36_ADDY_PTR_M         = $AF0D22
=$af0d23				SP36_ADDY_PTR_H         = $AF0D23
=$af0d24				SP36_X_POS_L            = $AF0D24
=$af0d25				SP36_X_POS_H            = $AF0D25
=$af0d26				SP36_Y_POS_L            = $AF0D26
=$af0d27				SP36_Y_POS_H            = $AF0D27
=$af0d28				SP37_CONTROL_REG        = $AF0D28
=$af0d29				SP37_ADDY_PTR_L         = $AF0D29
=$af0d2a				SP37_ADDY_PTR_M         = $AF0D2A
=$af0d2b				SP37_ADDY_PTR_H         = $AF0D2B
=$af0d2c				SP37_X_POS_L            = $AF0D2C
=$af0d2d				SP37_X_POS_H            = $AF0D2D
=$af0d2e				SP37_Y_POS_L            = $AF0D2E
=$af0d2f				SP37_Y_POS_H            = $AF0D2F
=$af0d30				SP38_CONTROL_REG        = $AF0D30
=$af0d31				SP38_ADDY_PTR_L         = $AF0D31
=$af0d32				SP38_ADDY_PTR_M         = $AF0D32
=$af0d33				SP38_ADDY_PTR_H         = $AF0D33
=$af0d34				SP38_X_POS_L            = $AF0D34
=$af0d35				SP38_X_POS_H            = $AF0D35
=$af0d36				SP38_Y_POS_L            = $AF0D36
=$af0d37				SP38_Y_POS_H            = $AF0D37
=$af0d38				SP39_CONTROL_REG        = $AF0D38
=$af0d39				SP39_ADDY_PTR_L         = $AF0D39
=$af0d3a				SP39_ADDY_PTR_M         = $AF0D3A
=$af0d3b				SP39_ADDY_PTR_H         = $AF0D3B
=$af0d3c				SP39_X_POS_L            = $AF0D3C
=$af0d3d				SP39_X_POS_H            = $AF0D3D
=$af0d3e				SP39_Y_POS_L            = $AF0D3E
=$af0d3f				SP39_Y_POS_H            = $AF0D3F
=$af0d40				SP40_CONTROL_REG        = $AF0D40
=$af0d41				SP40_ADDY_PTR_L         = $AF0D41
=$af0d42				SP40_ADDY_PTR_M         = $AF0D42
=$af0d43				SP40_ADDY_PTR_H         = $AF0D43
=$af0d44				SP40_X_POS_L            = $AF0D44
=$af0d45				SP40_X_POS_H            = $AF0D45
=$af0d46				SP40_Y_POS_L            = $AF0D46
=$af0d47				SP40_Y_POS_H            = $AF0D47
=$af0d48				SP41_CONTROL_REG        = $AF0D48
=$af0d49				SP41_ADDY_PTR_L         = $AF0D49
=$af0d4a				SP41_ADDY_PTR_M         = $AF0D4A
=$af0d4b				SP41_ADDY_PTR_H         = $AF0D4B
=$af0d4c				SP41_X_POS_L            = $AF0D4C
=$af0d4d				SP41_X_POS_H            = $AF0D4D
=$af0d4e				SP41_Y_POS_L            = $AF0D4E
=$af0d4f				SP41_Y_POS_H            = $AF0D4F
=$af0d50				SP42_CONTROL_REG        = $AF0D50
=$af0d51				SP42_ADDY_PTR_L         = $AF0D51
=$af0d52				SP42_ADDY_PTR_M         = $AF0D52
=$af0d53				SP42_ADDY_PTR_H         = $AF0D53
=$af0d54				SP42_X_POS_L            = $AF0D54
=$af0d55				SP42_X_POS_H            = $AF0D55
=$af0d56				SP42_Y_POS_L            = $AF0D56
=$af0d57				SP42_Y_POS_H            = $AF0D57
=$af0d58				SP43_CONTROL_REG        = $AF0D58
=$af0d59				SP43_ADDY_PTR_L         = $AF0D59
=$af0d5a				SP43_ADDY_PTR_M         = $AF0D5A
=$af0d5b				SP43_ADDY_PTR_H         = $AF0D5B
=$af0d5c				SP43_X_POS_L            = $AF0D5C
=$af0d5d				SP43_X_POS_H            = $AF0D5D
=$af0d5e				SP43_Y_POS_L            = $AF0D5E
=$af0d5f				SP43_Y_POS_H            = $AF0D5F
=$af0d60				SP44_CONTROL_REG        = $AF0D60
=$af0d61				SP44_ADDY_PTR_L         = $AF0D61
=$af0d62				SP44_ADDY_PTR_M         = $AF0D62
=$af0d63				SP44_ADDY_PTR_H         = $AF0D63
=$af0d64				SP44_X_POS_L            = $AF0D64
=$af0d65				SP44_X_POS_H            = $AF0D65
=$af0d66				SP44_Y_POS_L            = $AF0D66
=$af0d67				SP44_Y_POS_H            = $AF0D67
=$af0d68				SP45_CONTROL_REG        = $AF0D68
=$af0d69				SP45_ADDY_PTR_L         = $AF0D69
=$af0d6a				SP45_ADDY_PTR_M         = $AF0D6A
=$af0d6b				SP45_ADDY_PTR_H         = $AF0D6B
=$af0d6c				SP45_X_POS_L            = $AF0D6C
=$af0d6d				SP45_X_POS_H            = $AF0D6D
=$af0d6e				SP45_Y_POS_L            = $AF0D6E
=$af0d6f				SP45_Y_POS_H            = $AF0D6F
=$af0d70				SP46_CONTROL_REG        = $AF0D70
=$af0d71				SP46_ADDY_PTR_L         = $AF0D71
=$af0d72				SP46_ADDY_PTR_M         = $AF0D72
=$af0d73				SP46_ADDY_PTR_H         = $AF0D73
=$af0d74				SP46_X_POS_L            = $AF0D74
=$af0d75				SP46_X_POS_H            = $AF0D75
=$af0d76				SP46_Y_POS_L            = $AF0D76
=$af0d77				SP46_Y_POS_H            = $AF0D77
=$af0d78				SP47_CONTROL_REG        = $AF0D78
=$af0d79				SP47_ADDY_PTR_L         = $AF0D79
=$af0d7a				SP47_ADDY_PTR_M         = $AF0D7A
=$af0d7b				SP47_ADDY_PTR_H         = $AF0D7B
=$af0d7c				SP47_X_POS_L            = $AF0D7C
=$af0d7d				SP47_X_POS_H            = $AF0D7D
=$af0d7e				SP47_Y_POS_L            = $AF0D7E
=$af0d7f				SP47_Y_POS_H            = $AF0D7F
=$af0d80				SP48_CONTROL_REG        = $AF0D80
=$af0d81				SP48_ADDY_PTR_L         = $AF0D81
=$af0d82				SP48_ADDY_PTR_M         = $AF0D82
=$af0d83				SP48_ADDY_PTR_H         = $AF0D83
=$af0d84				SP48_X_POS_L            = $AF0D84
=$af0d85				SP48_X_POS_H            = $AF0D85
=$af0d86				SP48_Y_POS_L            = $AF0D86
=$af0d87				SP48_Y_POS_H            = $AF0D87
=$af0d88				SP49_CONTROL_REG        = $AF0D88
=$af0d89				SP49_ADDY_PTR_L         = $AF0D89
=$af0d8a				SP49_ADDY_PTR_M         = $AF0D8A
=$af0d8b				SP49_ADDY_PTR_H         = $AF0D8B
=$af0d8c				SP49_X_POS_L            = $AF0D8C
=$af0d8d				SP49_X_POS_H            = $AF0D8D
=$af0d8e				SP49_Y_POS_L            = $AF0D8E
=$af0d8f				SP49_Y_POS_H            = $AF0D8F
=$af0d90				SP50_CONTROL_REG        = $AF0D90
=$af0d91				SP50_ADDY_PTR_L         = $AF0D91
=$af0d92				SP50_ADDY_PTR_M         = $AF0D92
=$af0d93				SP50_ADDY_PTR_H         = $AF0D93
=$af0d94				SP50_X_POS_L            = $AF0D94
=$af0d95				SP50_X_POS_H            = $AF0D95
=$af0d96				SP50_Y_POS_L            = $AF0D96
=$af0d97				SP50_Y_POS_H            = $AF0D97
=$af0d98				SP51_CONTROL_REG        = $AF0D98
=$af0d99				SP51_ADDY_PTR_L         = $AF0D99
=$af0d9a				SP51_ADDY_PTR_M         = $AF0D9A
=$af0d9b				SP51_ADDY_PTR_H         = $AF0D9B
=$af0d9c				SP51_X_POS_L            = $AF0D9C
=$af0d9d				SP51_X_POS_H            = $AF0D9D
=$af0d9e				SP51_Y_POS_L            = $AF0D9E
=$af0d9f				SP51_Y_POS_H            = $AF0D9F
=$af0da0				SP52_CONTROL_REG        = $AF0DA0
=$af0da1				SP52_ADDY_PTR_L         = $AF0DA1
=$af0da2				SP52_ADDY_PTR_M         = $AF0DA2
=$af0da3				SP52_ADDY_PTR_H         = $AF0DA3
=$af0da4				SP52_X_POS_L            = $AF0DA4
=$af0da5				SP52_X_POS_H            = $AF0DA5
=$af0da6				SP52_Y_POS_L            = $AF0DA6
=$af0da7				SP52_Y_POS_H            = $AF0DA7
=$af0da8				SP53_CONTROL_REG        = $AF0DA8
=$af0da9				SP53_ADDY_PTR_L         = $AF0DA9
=$af0daa				SP53_ADDY_PTR_M         = $AF0DAA
=$af0dab				SP53_ADDY_PTR_H         = $AF0DAB
=$af0dac				SP53_X_POS_L            = $AF0DAC
=$af0dad				SP53_X_POS_H            = $AF0DAD
=$af0dae				SP53_Y_POS_L            = $AF0DAE
=$af0daf				SP53_Y_POS_H            = $AF0DAF
=$af0db0				SP54_CONTROL_REG        = $AF0DB0
=$af0db1				SP54_ADDY_PTR_L         = $AF0DB1
=$af0db2				SP54_ADDY_PTR_M         = $AF0DB2
=$af0db3				SP54_ADDY_PTR_H         = $AF0DB3
=$af0db4				SP54_X_POS_L            = $AF0DB4
=$af0db5				SP54_X_POS_H            = $AF0DB5
=$af0db6				SP54_Y_POS_L            = $AF0DB6
=$af0db7				SP54_Y_POS_H            = $AF0DB7
=$af0db8				SP55_CONTROL_REG        = $AF0DB8
=$af0db9				SP55_ADDY_PTR_L         = $AF0DB9
=$af0dba				SP55_ADDY_PTR_M         = $AF0DBA
=$af0dbb				SP55_ADDY_PTR_H         = $AF0DBB
=$af0dbc				SP55_X_POS_L            = $AF0DBC
=$af0dbd				SP55_X_POS_H            = $AF0DBD
=$af0dbe				SP55_Y_POS_L            = $AF0DBE
=$af0dbf				SP55_Y_POS_H            = $AF0DBF
=$af0dc0				SP56_CONTROL_REG        = $AF0DC0
=$af0dc1				SP56_ADDY_PTR_L         = $AF0DC1
=$af0dc2				SP56_ADDY_PTR_M         = $AF0DC2
=$af0dc3				SP56_ADDY_PTR_H         = $AF0DC3
=$af0dc4				SP56_X_POS_L            = $AF0DC4
=$af0dc5				SP56_X_POS_H            = $AF0DC5
=$af0dc6				SP56_Y_POS_L            = $AF0DC6
=$af0dc7				SP56_Y_POS_H            = $AF0DC7
=$af0dc8				SP57_CONTROL_REG        = $AF0DC8
=$af0dc9				SP57_ADDY_PTR_L         = $AF0DC9
=$af0dca				SP57_ADDY_PTR_M         = $AF0DCA
=$af0dcb				SP57_ADDY_PTR_H         = $AF0DCB
=$af0dcc				SP57_X_POS_L            = $AF0DCC
=$af0dcd				SP57_X_POS_H            = $AF0DCD
=$af0dce				SP57_Y_POS_L            = $AF0DCE
=$af0dcf				SP57_Y_POS_H            = $AF0DCF
=$af0dd0				SP58_CONTROL_REG        = $AF0DD0
=$af0dd1				SP58_ADDY_PTR_L         = $AF0DD1
=$af0dd2				SP58_ADDY_PTR_M         = $AF0DD2
=$af0dd3				SP58_ADDY_PTR_H         = $AF0DD3
=$af0dd4				SP58_X_POS_L            = $AF0DD4
=$af0dd5				SP58_X_POS_H            = $AF0DD5
=$af0dd6				SP58_Y_POS_L            = $AF0DD6
=$af0dd7				SP58_Y_POS_H            = $AF0DD7
=$af0dd8				SP59_CONTROL_REG        = $AF0DD8
=$af0dd9				SP59_ADDY_PTR_L         = $AF0DD9
=$af0dda				SP59_ADDY_PTR_M         = $AF0DDA
=$af0ddb				SP59_ADDY_PTR_H         = $AF0DDB
=$af0ddc				SP59_X_POS_L            = $AF0DDC
=$af0ddd				SP59_X_POS_H            = $AF0DDD
=$af0dde				SP59_Y_POS_L            = $AF0DDE
=$af0ddf				SP59_Y_POS_H            = $AF0DDF
=$af0de0				SP60_CONTROL_REG        = $AF0DE0
=$af0de1				SP60_ADDY_PTR_L         = $AF0DE1
=$af0de2				SP60_ADDY_PTR_M         = $AF0DE2
=$af0de3				SP60_ADDY_PTR_H         = $AF0DE3
=$af0de4				SP60_X_POS_L            = $AF0DE4
=$af0de5				SP60_X_POS_H            = $AF0DE5
=$af0de6				SP60_Y_POS_L            = $AF0DE6
=$af0de7				SP60_Y_POS_H            = $AF0DE7
=$af0de8				SP61_CONTROL_REG        = $AF0DE8
=$af0de9				SP61_ADDY_PTR_L         = $AF0DE9
=$af0dea				SP61_ADDY_PTR_M         = $AF0DEA
=$af0deb				SP61_ADDY_PTR_H         = $AF0DEB
=$af0dec				SP61_X_POS_L            = $AF0DEC
=$af0ded				SP61_X_POS_H            = $AF0DED
=$af0dee				SP61_Y_POS_L            = $AF0DEE
=$af0def				SP61_Y_POS_H            = $AF0DEF
=$af0df0				SP62_CONTROL_REG        = $AF0DF0
=$af0df1				SP62_ADDY_PTR_L         = $AF0DF1
=$af0df2				SP62_ADDY_PTR_M         = $AF0DF2
=$af0df3				SP62_ADDY_PTR_H         = $AF0DF3
=$af0df4				SP62_X_POS_L            = $AF0DF4
=$af0df5				SP62_X_POS_H            = $AF0DF5
=$af0df6				SP62_Y_POS_L            = $AF0DF6
=$af0df7				SP62_Y_POS_H            = $AF0DF7
=$af0df8				SP63_CONTROL_REG        = $AF0DF8
=$af0df9				SP63_ADDY_PTR_L         = $AF0DF9
=$af0dfa				SP63_ADDY_PTR_M         = $AF0DFA
=$af0dfb				SP63_ADDY_PTR_H         = $AF0DFB
=$af0dfc				SP63_X_POS_L            = $AF0DFC
=$af0dfd				SP63_X_POS_H            = $AF0DFD
=$af0dfe				SP63_Y_POS_L            = $AF0DFE
=$af0dff				SP63_Y_POS_H            = $AF0DFF

;******  Return to file: src\C256/vicky_def.s


;******  Return to file: src\C256/mmap_c256.s

=$00					BASIC_BANK = $00            ; Memory bank for default purposes
=$004c00				IOBUF = $004C00             ; A buffer for I/O operations
=$004d00				ARRIDXBUF = $004D00         ; The array index buffer used for array references
=$004e00				TEMPBUF = $004E00           ; Temporary buffer for string processing, etc.
=$004f00				INPUTBUF = $004F00          ; Starting address of the line input buffer (one page)
=$005000				RETURN_BOT = $005000        ; Starting address of the return stack
=$005fff				RETURN_TOP = $005FFF        ; Ending address of the return stack
=$006000				ARGUMENT_BOT = $006000      ; Starting address of the argument stack
=$006fff				ARGUMENT_TOP = $006FFF      ; Ending address of the argument stack
=$007000				OPERATOR_BOT = $007000      ; Starting address of the operator stack
=$007fff				OPERATOR_TOP = $007FFF      ; Ending address of the operator stack
=$b00000				VRAM = $B00000              ; Start of video RAM
=$010000				LOADBLOCK = $010000         ; File loading will start here
=$360000				BASIC_BOT := $360000         ; Starting point for BASIC programs
=$37ffff				HEAP_TOP := $37FFFF          ; Starting point of the heap
=$160000				BASIC_BOT := $160000         ; Starting point for BASIC programs
=$17ffff				HEAP_TOP := $17FFFF          ; Starting point of the heap

;******  Return to file: src\memorymap.s

=$00ffe6				VBRK = $00FFE6          ; Vector for the native-mode BRK vector
=$1ad000				DATA_BLOCK = *
=$000800				GLOBAL_VARS = *
>0800					BIP         .dword ?    ; Pointer to the current byte in the current BASIC program
>0804					BIPPREV     .dword ?    ; Pointer to the previous bytein the current BASIC program
>0808					INDEX       .dword ?    ; A temporary pointer
>080c					SCRATCH     .dword ?    ; A temporary scratch variable
>0810					SCRATCH2    .dword ?    ; A temporary scratch variable
>0814					            .word  ?	; Need a few more bits for BCD conversion
>0816					STRPTR      .dword ?    ; A temporary pointer for strings
>081a					CURLINE     .dword ?    ; Pointer to the current input line needing tokenization
>081e					CURTOKLEN   .byte ?     ; Length of the text of the current token
>081f					ARGUMENTSP  .word ?     ; Pointer to the top of the argument stack
>0821					OPERATORSP  .word ?     ; Pointer to the top of the operator stack
>0823					ARGUMENT1   .dword ?    ; Argument 1 for expression calculations
>0827					ARGTYPE1    .byte ?     ; Type code for argument 1 (integer, float, string)
>0828					SIGN1       .byte ?     ; Temporary sign marker for argument 1
>0829					ARGUMENT2   .dword ?    ; Argument 2 for expression calculations
>082d					ARGTYPE2    .byte ?     ; Type code for argument 2 (integer, float, string)
>082e					SIGN2       .byte ?     ; Temporary sign marker for argument 1
>082f					JMP16PTR    .word ?     ; Pointer for 16-bit indirect jumps (within BASIC816's code base)
>0831					GOSUBDEPTH  .word ?     ; Number of GOSUBs on the stack
>0833					RETURNSP    .word ?     ; Pointer to the top of the return stack
>0835					SKIPNEST    .byte ?     ; Flag to indicate if token seeking should respect nesting (MSB set if so)
>0836					NESTING     .byte ?     ; Counter of the depth of lexical nesting for FOR/NEXT, DO/LOOP
>0837					TARGETTOK   .byte ?     ; When searching for a token, TARGETTOK is the token to find
>0838					DATABIP     .dword ?    ; Pointer to the next data element for READ statements
>083c					DATALINE    .dword ?    ; Pointer to the current line for a DATA statement
>0840					SAVEBIP     .dword ?    ; Spot to save BIP temporarily
>0844					SAVELINE    .dword ?    ; Spot to save CURLINE temporarily
=$000848				MONITOR_VARS = *
>0848					MCMDADDR    .long ?     ;3 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
>084b					MCMP_TEXT   .long ?     ;3 Bytes Address of symbol being evaluated for COMPARE routine
>084e					MCMP_LEN    .word ?     ;2 Bytes Length of symbol being evaluated for COMPARE routine
>0850					MCMD        .long ?     ;3 Bytes Address of the current command/function string
>0853					MCMD_LEN    .word ?     ;2 Bytes Length of the current command/function string
>0855					MARG1       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command
>0859					MARG2       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>085d					MARG3       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0861					MARG4       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0865					MARG5       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0869					MARG6       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>086d					MARG7       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0871					MARG8       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0875					MARG9       .dword ?    ;4 Bytes First command argument.
>0879					MARG_LEN    .byte ?     ;1 Byte count of the number of arguments passed
>087a					MCURSOR     .dword ?    ;4 Bytes Pointer to the current memory location for disassembly, memory dump, etc.
>087e					MLINEBUF    .fill 17    ;17 Byte buffer for dumping memory (TODO: could be moved to a general string scratch area)
>088f					MCOUNT      .long ?     ;2 Byte counter
>0892					MTEMP       .dword ?    ;4 Bytes of temporary space
>0896					MCPUSTAT    .byte ?     ;1 Byte to represent what the disassembler thinks the processor MX bits are
>0897					MADDR_MODE  .byte ?     ;1 Byte address mode found by the assembler
>0898					MPARSEDNUM  .dword ?    ;4 Bytes to store a parsed number
>089c					MMNEMONIC   .word ?     ;2 Byte address of mnemonic found by the assembler
>089e					MTEMPPTR    .dword ?    ;4 Byte temporary pointer
>08a2					MJUMPINST   .byte ?     ;1 Byte JSL opcode
>08a3					MJUMPADDR   .long ?     ;3 Byte address for JSL
=$000823				MANTISSA1 = ARGUMENT1
=$000826				EXPONENT1 = ARGUMENT1+3

;******  Return to file: src\basic816.s


;******  Processing file: src\macros.s


;******  Return to file: src\basic816.s

.1a0000	5c bf 87 1a	jmp $1a87bf	COLDBOOT        JML START               ; Entry point to boot up BASIC from scratch
.1a0004	5c ce 6d 1a	jmp $1a6dce	MONITOR         JML IMONITOR            ; Entry point to the machine language monitor
.1a0008	5c b6 25 1a	jmp $1a25b6	READLINE        JML IREADLINE           ; Wait for the user to enter a line of text (for programming input)
.1a000c	5c 5b 01 1a	jmp $1a015b	SCRCOPYLINE     JML ISCRCPYLINE         ; Copy the line on the screen the user just input to INPUTBUF
.1a0010	5c 58 00 1a	jmp $1a0058	INPUTLINE       JML IINPUTLINE          ; Read a single line of text from the user, and copy it to TEMPBUF (for INPUT statement)
.1a0014	5c d6 00 1a	jmp $1a00d6	GETKEY          JML IGETKEY             ; Wait for a keypress by the user and return the ASCII code in A
.1a0018	5c c1 02 1a	jmp $1a02c1	PRINTC          JML IPRINTC             ; Print the character in A to the console
.1a001c	5c ff 00 1a	jmp $1a00ff	SHOWCURSOR      JML ISHOWCURSOR         ; Set cursor visibility: A=0, hide... A<>0, show.
.1a0020	5c 1a 01 1a	jmp $1a011a	CURSORXY        JML ICURSORXY           ; Set the position of the cursor to (X, Y)
.1a0024	5c 21 01 1a	jmp $1a0121	CLSCREEN        JML ICLSCREEN           ; Clear the screen

;******  Processing file: src\bios.s


;******  Processing file: src\membuffers.s

>08a6					OBUFFER     .long ?     ; Pointer to the current text memory buffer for output
>08a9					OBUFFSIZE   .word ?     ; Maximum size of output text memory buffer
>08ab					OBUFFIDX    .word ?     ; Index into the current output buffer
>08ad					IBUFFER     .long ?     ; Pointer to the current text memory buffer for input
>08b0					IBUFFSIZE   .word ?     ; Number of bytes written to the buffer
>08b2					IBUFFIDX    .word ?     ; Index into the current input buffer (next available character)
.1a0028					OBUFF_PUTC
.1a0028	0b		phd		                PHD
.1a0029	08		php		                PHP
.1a002a	08		php		            PHP
.1a002b	c2 20		rep #$20	            REP #$20
.1a002d	48		pha		            PHA
.1a002e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0031	5b		tcd		            TCD
.1a0032	68		pla		            PLA
.1a0033	28		plp		            PLP
.1a0034	e2 20		sep #$20	            SEP #$20
.1a0036	85 b5		sta $08b5	                STA SAVE_A
.1a0038	c2 20		rep #$20	            REP #$20
.1a003a	a5 a6		lda $08a6	                LDA OBUFFER
.1a003c	d0 06		bne $1a0044	                BNE has_buffer
.1a003e	e2 20		sep #$20	            SEP #$20
.1a0040	a5 a8		lda $08a8	                LDA OBUFFER+2
.1a0042	f0 11		beq $1a0055	                BEQ done
.1a0044					has_buffer
.1a0044	c2 10		rep #$10	            REP #$10
.1a0046	a4 ab		ldy $08ab	                LDY OBUFFIDX        ; Check to make sure there is room
.1a0048	c4 a9		cpy $08a9	                CPY OBUFFSIZE
.1a004a	f0 09		beq $1a0055	                BEQ done            ; If not, exit silently
.1a004c	e2 20		sep #$20	            SEP #$20
.1a004e	a5 b5		lda $08b5	                LDA SAVE_A
.1a0050	97 a6		sta [$08a6],y	                STA [OBUFFER],Y     ; Write the character to the buffer
.1a0052	c8		iny		                INY                 ; Increment the index
.1a0053	84 ab		sty $08ab	                STY OBUFFIDX
.1a0055	28		plp		done            PLP
.1a0056	2b		pld		                PLD
.1a0057	60		rts		            RTS

;******  Return to file: src\bios.s


;******  Processing file: src\C256/io_c256.s


;******  Processing file: src\C256/kernel_c256.s

=$00104c				FK_GETCHW           = $00104c ; Get a character from the input channel. Waits until data received. A=0 and Carry=1 if no data is wating
=$001018				FK_PUTC             = $001018 ; Print a character to the currently selected channel
=$00101c				FK_PUTS             = $00101C ; Print a string to the currently selected channel
=$001084				FK_LOCATE           = $001084 ; Reposition the cursor to row Y column X
=$001078				FK_IPRINTH          = $001078 ; Print a HEX string
=$00103c				FK_SETOUT           = $00103c ; Select an output channel
=$00112c				FK_SETSIZES         = $00112C ; Set the text screen size variables based on the border and screen resolution.
=$0010f0				FK_OPEN             = $0010F0 ; open a file for reading/writing/creating
=$0010f4				FK_CREATE           = $0010F4 ; create a new file
=$0010f8				FK_CLOSE            = $0010F8 ; close a file (make sure last cluster is written)
=$0010fc				FK_WRITE            = $0010FC ; write the current cluster to the file
=$001100				FK_READ             = $001100 ; read the next cluster from the file
=$001104				FK_DELETE           = $001104 ; delete a file / directory
=$001108				FK_DIROPEN          = $001108 ; open a directory and seek the first directory entry
=$00110c				FK_DIRNEXT          = $00110C ; seek to the next directory of an open directory
=$001110				FK_DIRREAD          = $001110 ; Read the directory entry for the specified file
=$001114				FK_DIRWRITE         = $001114 ; Write any changes in the current directory cluster back to the drive
=$001118				FK_LOAD             = $001118 ; load a binary file into memory, supports multiple file formats
=$00111c				FK_SAVE             = $00111C ; Save memory to a binary file
=$001124				FK_RUN              = $001124 ; Load and run an executable binary file
=$001130				FK_COPY             = $001130 ; Copy a file
=$001120				FK_CMDBLOCK         = $001120 ; Send a command to a block device
=0					CHAN_CONSOLE = 0
=1					CHAN_COM1 = 1
=2					CHAN_COM2 = 2

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/RTC_inc.s

=$af0800				RTC_SEC       = $AF0800 ;Seconds Register
=$af0801				RTC_SEC_ALARM = $AF0801 ;Seconds Alarm Register
=$af0802				RTC_MIN       = $AF0802 ;Minutes Register
=$af0803				RTC_MIN_ALARM = $AF0803 ;Minutes Alarm Register
=$af0804				RTC_HRS       = $AF0804 ;Hours Register
=$af0805				RTC_HRS_ALARM = $AF0805 ;Hours Alarm Register
=$af0806				RTC_DAY       = $AF0806 ;Day Register
=$af0807				RTC_DAY_ALARM = $AF0807 ;Day Alarm Register
=$af0808				RTC_DOW       = $AF0808 ;Day of Week Register
=$af0809				RTC_MONTH     = $AF0809 ;Month Register
=$af080a				RTC_YEAR      = $AF080A ;Year Register
=$af080b				RTC_RATES     = $AF080B ;Rates Register
=$af080c				RTC_ENABLE    = $AF080C ;Enables Register
=$af080d				RTC_FLAGS     = $AF080D ;Flags Register
=$af080e				RTC_CTRL      = $AF080E ;Control Register
=$af080f				RTC_CENTURY   = $AF080F ;Century Register

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/keyboard.s


;******  Processing file: src\C256/keyboard_def.s

=$af1064				STATUS_PORT 	        =	$AF1064
=$af1060				KBD_OUT_BUF 	        =	$AF1060
=$af1060				KBD_INPT_BUF	        = $AF1060
=$af1064				KBD_CMD_BUF		        = $AF1064
=$af1060				KBD_DATA_BUF	        = $AF1060
=$af1060				PORT_A			          =	$AF1060
=$af1061				PORT_B			          =	$AF1061
=$01					OUT_BUF_FULL  =	$01
=$02					INPT_BUF_FULL	=	$02
=$04					SYS_FLAG		  =	$04
=$08					CMD_DATA		  =	$08
=$10					KEYBD_INH     =	$10
=$20					TRANS_TMOUT	  =	$20
=$40					RCV_TMOUT		  =	$40
=$80					PARITY_EVEN		=	$80
=$10					INH_KEYBOARD	=	$10
=$ae					KBD_ENA			  =	$AE
=$ad					KBD_DIS			  =	$AD
=$f1					KB_MENU			  =	$F1
=$f4					KB_ENABLE		  =	$F4
=$f7					KB_MAKEBREAK  =	$F7
=$fe					KB_ECHO			  =	$FE
=$ff					KB_RESET		  =	$FF
=$ed					KB_LED_CMD		=	$ED
=$aa					KB_OK			    =	$AA
=$fa					KB_ACK			  =	$FA
=$ff					KB_OVERRUN		=	$FF
=$fe					KB_RESEND		  =	$FE
=$f0					KB_BREAK		  =	$F0
=$10					KB_FA			    =	$10
=$20					KB_FE			    =	$20
=$40					KB_PR_LED		  =	$40
=$01					KB_SCROLL_LOCK      = $01
=$02					KB_NUM_LOCK         = $02
=$04					KB_CAPS_LOCK        = $04

;******  Return to file: src\C256/keyboard.s

.1a0058					IINPUTLINE
.1a0058	08		php		                PHP
.1a0059	c2 10		rep #$10	            REP #$10
.1a005b	e2 20		sep #$20	            SEP #$20
.1a005d	a9 01		lda #$01	                LDA #1              ; Show the cursor
.1a005f	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a0062	a2 00 00	ldx #$0000	                LDX #0
.1a0065	a9 00		lda #$00	                LDA #0
.1a0067	9f 00 4c 00	sta $004c00,x	zero_loop       STA @lIOBUF,X
.1a006b	e8		inx		                INX
.1a006c	e0 00 01	cpx #$0100	                CPX #$100
.1a006f	d0 f6		bne $1a0067	                BNE zero_loop
.1a0071	a2 00 00	ldx #$0000	                LDX #0
.1a0074					getchar
.1a0074	20 14 00	jsr $1a0014	            JSR GETKEY
.1a0077	c9 0d		cmp #$0d	                CMP #CHAR_CR        ; Got a CR?
.1a0079	d0 03		bne $1a007e	                BNE not_cr
.1a007b	4c cf 00	jmp $1a00cf	                JMP endofline       ; Yes: we're done
.1a007e	c9 9d		cmp #$9d	not_cr          CMP #K_LEFT         ; Is it the left cursor?
.1a0080	d0 08		bne $1a008a	                BNE not_left
.1a0082	e0 00 00	cpx #$0000	                CPX #0              ; Are we all the way to the left?
.1a0085	f0 ed		beq $1a0074	                BEQ getchar         ; Yes: ignore it
.1a0087	ca		dex		                DEX                 ; Move the cursor back
.1a0088	80 39		bra $1a00c3	                BRA echo            ; And echo it
.1a008a	c9 1d		cmp #$1d	not_left        CMP #K_RIGHT        ; Is it the right arrow?
.1a008c	d0 0e		bne $1a009c	                BNE not_right
.1a008e	bf 00 4c 00	lda $004c00,x	                LDA @lIOBUF,X       ; Check the current character
.1a0092	f0 e0		beq $1a0074	                BEQ getchar         ; If it's already blank, we're as far right as we go
.1a0094	e0 4f 00	cpx #$004f	                CPX #79             ; Are we at the end of the line?
.1a0097	f0 db		beq $1a0074	                BEQ getchar         ; Yes: ignore it
.1a0099	e8		inx		                INX                 ; Otherwise: advance the cursor
.1a009a	80 27		bra $1a00c3	                BRA echo            ; And print the code
.1a009c	c9 08		cmp #$08	not_right       CMP #CHAR_BS        ; Is it a backspace?
.1a009e	d0 1a		bne $1a00ba	                BNE not_bs
.1a00a0	e0 00 00	cpx #$0000	                CPX #0              ; Are we at the beginning of the line?
.1a00a3	f0 cf		beq $1a0074	                BEQ getchar         ; yes: ignore the backspace
.1a00a5	da		phx		                PHX                 ; Save the cursor position
.1a00a6	bf 01 4c 00	lda $004c01,x	clr_loop        LDA @lIOBUF+1,X     ; Get the character above
.1a00aa	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the current position
.1a00ae	f0 06		beq $1a00b6	                BEQ done_clr        ; If we copied a NUL, we're done copying
.1a00b0	e8		inx		                INX                 ; Otherwise, keep copying down
.1a00b1	e0 ff 00	cpx #$00ff	                CPX #$FF            ; Until we're at the end of the buffer
.1a00b4	d0 f0		bne $1a00a6	                BNE clr_loop
.1a00b6	fa		plx		done_clr        PLX                 ; Restore the cursor position
.1a00b7	ca		dex		                DEX                 ; No: move the cursor left
.1a00b8	80 0e		bra $1a00c8	                BRA print_bs        ; And print the backspace
.1a00ba	c9 20		cmp #$20	not_bs          CMP #$20            ; Is it in range 00 -- 1F?
.1a00bc	90 b6		bcc $1a0074	                BLT getchar         ; Yes: ignore it
.1a00be	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the input buffer
.1a00c2	e8		inx		                INX                 ; Move the cursor forward
.1a00c3					echo
.1a00c3	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00c6	80 ac		bra $1a0074	                BRA getchar         ; And get another...
.1a00c8	a9 08		lda #$08	print_bs        LDA #CHAR_BS        ; Backspace character...
.1a00ca	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00cd	80 a5		bra $1a0074	                BRA getchar         ; And get another...
.1a00cf	a9 00		lda #$00	endofline       LDA #0              ; Hide the cursor
.1a00d1	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a00d4	28		plp		                PLP
.1a00d5	60		rts		            RTS
.1a00d6					IGETKEY
.1a00d6	22 4c 10 00	jsl $00104c	                JSL FK_GETCHW
.1a00da	60		rts		            RTS
.1a00db					GETKEYE
.1a00db	20 14 00	jsr $1a0014	            JSR GETKEY
.1a00de	48		pha		                PHA
.1a00df	20 18 00	jsr $1a0018	            JSR PRINTC
.1a00e2	68		pla		                PLA
.1a00e3	60		rts		            RTS
=$11					K_UP = $11      ; Keypad UP
=$1d					K_RIGHT = $1D   ; Keypad Right
=$91					K_DOWN = $91    ; Keypad Down
=$9d					K_LEFT = $9D    ; Keypad Left

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/screen.s

.1a00e4					ENSURETEXT
.1a00e4	08		php		            PHP
.1a00e5	e2 20		sep #$20	            SEP #$20
.1a00e7	af 00 00 af	lda $af0000	            LDA @l MASTER_CTRL_REG_L            ; Get the current display mode
.1a00eb	89 3c		bit #$3c	            BIT #Mstr_Ctrl_Graph_Mode_En | Mstr_Ctrl_Bitmap_En | Mstr_Ctrl_TileMap_En | Mstr_Ctrl_Sprite_En
.1a00ed	f0 08		beq $1a00f7	            BEQ textonly                        ; If not, make sure text is enabled
.1a00ef					overlay
.1a00ef	09 03		ora #$03	            ORA #Mstr_Ctrl_Text_Mode_En | Mstr_Ctrl_Text_Overlay
.1a00f1	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.1a00f5	80 06		bra $1a00fd	            BRA done
.1a00f7					textonly
.1a00f7	09 01		ora #$01	            ORA #Mstr_Ctrl_Text_Mode_En
.1a00f9	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.1a00fd	28		plp		done        PLP
.1a00fe	60		rts		            RTS
.1a00ff					ISHOWCURSOR
.1a00ff	08		php		            PHP
.1a0100	e2 20		sep #$20	            SEP #$20
.1a0102	c9 00		cmp #$00	            CMP #0
.1a0104	f0 08		beq $1a010e	            BEQ hide
.1a0106	af 10 00 af	lda $af0010	show        LDA @lVKY_TXT_CURSOR_CTRL_REG
.1a010a	09 01		ora #$01	            ORA #Vky_Cursor_Enable
.1a010c	80 06		bra $1a0114	            BRA setit
.1a010e	af 10 00 af	lda $af0010	hide        LDA @lVKY_TXT_CURSOR_CTRL_REG
.1a0112	29 fe		and #$fe	            AND #~Vky_Cursor_Enable
.1a0114	8f 10 00 af	sta $af0010	setit       STA @lVKY_TXT_CURSOR_CTRL_REG
.1a0118	28		plp		            PLP
.1a0119	60		rts		            RTS
.1a011a					ICURSORXY
.1a011a	08		php		            PHP
.1a011b	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.1a011f	28		plp		            PLP
.1a0120	60		rts		            RTS
.1a0121					ICLSCREEN
.1a0121	48		pha		            PHA
.1a0122	da		phx		            PHX
.1a0123	5a		phy		            PHY
.1a0124	0b		phd		            PHD
.1a0125	08		php		            PHP
.1a0126	e2 20		sep #$20	            SEP #$20
.1a0128	c2 10		rep #$10	            REP #$10
.1a012a	a2 00 00	ldx #$0000	            LDX #0
.1a012d	a9 20		lda #$20	loop        LDA #$20
.1a012f	9f 00 a0 af	sta $afa000,x	            STA @lCS_TEXT_MEM_PTR,X     ; Write a space in the text cell
.1a0133	af 1e 00 00	lda $00001e	            LDA @lCURCOLOR
.1a0137	9f 00 c0 af	sta $afc000,x	            STA @lCS_COLOR_MEM_PTR,X    ; Set the color to green on black
.1a013b	e8		inx		            INX                         ; Move to the next character cell
.1a013c	e0 00 20	cpx #$2000	            CPX #$2000
.1a013f	d0 ec		bne $1a012d	            BNE loop
.1a0141	08		php		            PHP
.1a0142	c2 20		rep #$20	            REP #$20
.1a0144	48		pha		            PHA
.1a0145	a9 00 00	lda #$0000	            LDA #0
.1a0148	5b		tcd		            TCD
.1a0149	68		pla		            PLA
.1a014a	28		plp		            PLP
.1a014b	a2 00 00	ldx #$0000	            LDX #0                      ; Set cursor to upper-left corner
.1a014e	a0 00 00	ldy #$0000	            LDY #0
.1a0151	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.1a0155	28		plp		            PLP
.1a0156	2b		pld		            PLD
.1a0157	7a		ply		            PLY
.1a0158	fa		plx		            PLX
.1a0159	68		pla		            PLA
.1a015a	60		rts		            RTS
.1a015b					ISCRCPYLINE
.1a015b	da		phx		            PHX
.1a015c	5a		phy		            PHY
.1a015d	0b		phd		            PHD
.1a015e	08		php		            PHP
.1a015f	08		php		            PHP
.1a0160	c2 20		rep #$20	            REP #$20
.1a0162	48		pha		            PHA
.1a0163	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0166	5b		tcd		            TCD
.1a0167	68		pla		            PLA
.1a0168	28		plp		            PLP
.1a0169	c2 30		rep #$30	            REP #$30
.1a016b	af 0c 00 00	lda $00000c	            LDA @lSCREENBEGIN       ; Set INDEX to the first byte of the text screen
.1a016f	85 08		sta $0808	            STA INDEX
.1a0171	e2 20		sep #$20	            SEP #$20
.1a0173	af 0e 00 00	lda $00000e	            LDA @lSCREENBEGIN+2
.1a0177	c2 20		rep #$20	            REP #$20
.1a0179	29 ff 00	and #$00ff	            AND #$00FF
.1a017c	85 0a		sta $080a	            STA INDEX+2
.1a017e	af 11 00 00	lda $000011	            LDA @lCOLS_PER_LINE     ; Calculate the offset to the current line
.1a0182	8f 08 01 00	sta $000108	            STA @lM1_OPERAND_A
.1a0186	af 1c 00 00	lda $00001c	            LDA @lCURSORY
.1a018a	3a		dec a		            DEC A
.1a018b	8f 0a 01 00	sta $00010a	            STA @lM1_OPERAND_B
.1a018f	18		clc		            CLC                     ; And add it to INDEX
.1a0190	a5 08		lda $0808	            LDA INDEX
.1a0192	6f 0c 01 00	adc $00010c	            ADC @lM1_RESULT
.1a0196	85 08		sta $0808	            STA INDEX
.1a0198	a5 0a		lda $080a	            LDA INDEX+2
.1a019a	69 00 00	adc #$0000	            ADC #0
.1a019d	85 0a		sta $080a	            STA INDEX+2
.1a019f	e2 20		sep #$20	            SEP #$20
.1a01a1	af 0f 00 00	lda $00000f	            LDA @lCOLS_VISIBLE
.1a01a5	85 8f		sta $088f	            STA MCOUNT
.1a01a7	a0 00 00	ldy #$0000	            LDY #0
.1a01aa	a2 00 00	ldx #$0000	            LDX #0
.1a01ad	b7 08		lda [$0808],y	copy_loop   LDA [INDEX],Y           ; Copy a byte from the screen to the input buffer
.1a01af	9f 00 4f 00	sta $004f00,x	            STA @lINPUTBUF,X
.1a01b3	e8		inx		            INX
.1a01b4	c8		iny		            INY
.1a01b5	c4 8f		cpy $088f	            CPY MCOUNT
.1a01b7	d0 f4		bne $1a01ad	            BNE copy_loop
.1a01b9	ca		dex		            DEX
.1a01ba	bf 00 4f 00	lda $004f00,x	trim_loop   LDA @lINPUTBUF,X        ; Replace spaces at the end with NULLs
.1a01be	c9 20		cmp #$20	            CMP #CHAR_SP
.1a01c0	d0 09		bne $1a01cb	            BNE done
.1a01c2	a9 00		lda #$00	            LDA #0
.1a01c4	9f 00 4f 00	sta $004f00,x	            STA @lINPUTBUF,X
.1a01c8	ca		dex		            DEX
.1a01c9	10 ef		bpl $1a01ba	            BPL trim_loop
.1a01cb	28		plp		done        PLP
.1a01cc	2b		pld		            PLD
.1a01cd	7a		ply		            PLY
.1a01ce	fa		plx		            PLX
.1a01cf	60		rts		            RTS

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/gabe_defs.s

=$afe880				GABE_MSTR_CTRL      = $AFE880
=$01					GABE_CTRL_PWR_LED   = $01     ; Controls the LED in the Front of the case (Next to the reset button)
=$02					GABE_CTRL_SDC_LED   = $02     ; Controls the LED in the Front of the Case (Next to SDCard)
=$04					GABE_CTRL_STS_LED0  = $04     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$08					GABE_CTRL_STS_LED1  = $08     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$10					GABE_CTRL_BUZZER    = $10     ; Controls the Buzzer
=$80					GABE_CTRL_WRM_RST   = $80     ; Warm Reset (needs to Setup other registers)
=$afe881				GABE_LED_FLASH_CTRL = $AFE881  ; Flashing LED Control
=$01					GABE_LED0_FLASH_CTRL = $01     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$02					GABE_LED1_FLASH_CTRL = $02     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED1 to manually control)
=$10					GABE_LD0_FLASH_FRQ0   = $10     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$20					GABE_LD0_FLASH_FRQ1   = $20     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$40					GABE_LD1_FLASH_FRQ0   = $40     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$80					GABE_LD1_FLASH_FRQ1   = $80     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$afe882				GABE_RST_AUTH0      = $AFE882 ; Must Contain the BYTE $AD for Reset to Activate
=$afe883				GABE_RST_AUTH1      = $AFE883 ; Must Contain the BYTE $DE for Reset to Activate
=$afe884				GABE_RNG_DAT_LO     = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_DAT_HI     = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe884				GABE_RNG_SEED_LO    = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_SEED_HI    = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe886				GABE_RNG_STAT       = $AFE886 ;
=$80					GABE_RNG_LFSR_DONE  = $80     ; indicates that Output = SEED Database
=$afe886				GABE_RNG_CTRL       = $AFE886 ;
=$01					GABE_RNG_CTRL_EN    = $01     ; Enable the LFSR BLOCK_LEN
=$02					GABE_RNG_CTRL_DV    = $02     ; After Setting the Seed Value, Toggle that Bit for it be registered
=$afe887				GABE_SYS_STAT       = $AFE887 ;
=$01					GABE_SYS_STAT_MID0  = $01     ; Machine ID -- LSB
=$02					GABE_SYS_STAT_MID1  = $02     ; Machine ID --
=$04					GABE_SYS_STAT_MID2  = $04     ; Machine ID -- MSB
=$10					GABE_SYS_STAT_EXP   = $10     ; if Zero, there is an Expansion Card Preset
=$40					GABE_SYS_STAT_CPUA  = $40     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$80					GABE_SYS_STAT_CPUX  = $80     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$afe88a				GABE_SUBVERSION_LO  = $AFE88A
=$afe88b				GABE_SUBVERSION_HI  = $AFE88B
=$afe88c				GABE_VERSION_LO     = $AFE88C
=$afe88d				GABE_VERSION_HI     = $AFE88D
=$afe88e				GABE_MODEL_LO       = $AFE88E
=$afe88f				GABE_MODEL_HI       = $AFE88F

;******  Return to file: src\C256/io_c256.s

=32					BORDER_WIDTH = 32               ; The width of the border (when it is on)
=72					TEXT_COLS_WB = 72               ; Number of columns of text with the border enabled
=52					TEXT_ROWS_WB = 52               ; Number of rows of text with the border enabled
=80					TEXT_COLS_WOB = 80              ; Number of columns of text with no border enabled
=60					TEXT_ROWS_WOB = 60              ; Number of rows of text with no border enabled
.1a01d0					INITIO
.1a01d0	e2 20		sep #$20	            SEP #$20
.1a01d2	20 1b 02	jsr $1a021b	            JSR INITRNG
.1a01d5	a9 48		lda #$48	            LDA #TEXT_COLS_WB   ; Make sure the screen size is right
.1a01d7	8f 0f 00 00	sta $00000f	            STA @lCOLS_VISIBLE  ; TODO: remove this when the kernel is correct
.1a01db	a9 34		lda #$34	            LDA #TEXT_ROWS_WB
.1a01dd	8f 13 00 00	sta $000013	            STA @lLINES_VISIBLE
.1a01e1	a9 20		lda #$20	            LDA #BORDER_WIDTH   ; Set the border width
.1a01e3	8f 08 00 af	sta $af0008	            STA BORDER_X_SIZE
.1a01e7	8f 09 00 af	sta $af0009	            STA BORDER_Y_SIZE
.1a01eb	a2 00 00	ldx #$0000	            LDX #0              ; Clear all the sprite control shadow registers
.1a01ee	a9 00		lda #$00	            LDA #0
.1a01f0	9f 18 f0 1a	sta $1af018,x	sp_loop     STA GS_SP_CONTROL,X
.1a01f4	e8		inx		            INX
.1a01f5	e0 40 00	cpx #$0040	            CPX #SP_MAX
.1a01f8	d0 f6		bne $1a01f0	            BNE sp_loop
.1a01fa	a9 80		lda #$80	            LDA #DEV_SCREEN
.1a01fc	8f b4 08 00	sta $0008b4	            STA @lBCONSOLE
.1a0200	e2 20		sep #$20	            SEP #$20
.1a0202	a9 00		lda #$00	            LDA #0                  ; Clear the lock key flags
.1a0204	8f 89 0f 00	sta $000f89	            STA @lKEYBOARD_LOCKS
.1a0208	a9 00		lda #$00	            LDA #0
.1a020a	8f 00 02 af	sta $af0200	            STA @l TL0_CONTROL_REG
.1a020e	8f 0c 02 af	sta $af020c	            STA @l TL1_CONTROL_REG
.1a0212	8f 18 02 af	sta $af0218	            STA @l TL2_CONTROL_REG
.1a0216	8f 24 02 af	sta $af0224	            STA @l TL3_CONTROL_REG
.1a021a					done
.1a021a	60		rts		            RTS
.1a021b					INITRNG
.1a021b	08		php		            PHP
.1a021c	e2 20		sep #$20	            SEP #$20
.1a021e	af 0e 08 af	lda $af080e	            LDA @l RTC_CTRL         ; Pause updates to the clock registers
.1a0222	09 08		ora #$08	            ORA #%00001000
.1a0224	8f 0e 08 af	sta $af080e	            STA @l RTC_CTRL
.1a0228	af 00 08 af	lda $af0800	            LDA @l RTC_SEC          ; Set the random number generator seed
.1a022c	8f 84 e8 af	sta $afe884	            STA @l GABE_RNG_SEED_LO
.1a0230	af 02 08 af	lda $af0802	            LDA @l RTC_MIN
.1a0234	8f 85 e8 af	sta $afe885	            STA @l GABE_RNG_SEED_HI
.1a0238	a9 03		lda #$03	            LDA #GABE_RNG_CTRL_DV | GABE_RNG_CTRL_EN
.1a023a	8f 86 e8 af	sta $afe886	            STA @l GABE_RNG_CTRL    ; Load the seed into the RNG
.1a023e	af 0e 08 af	lda $af080e	            LDA @l RTC_CTRL         ; Re-enable updates to the clock registers
.1a0242	29 f7		and #$f7	            AND #%11110111
.1a0244	8f 0e 08 af	sta $af080e	            STA @l RTC_CTRL
.1a0248	ea		nop		            NOP                     ; Give the RNG some time... not sure if needed, really
.1a0249	ea		nop		            NOP
.1a024a	ea		nop		            NOP
.1a024b	a9 01		lda #$01	            LDA #GABE_RNG_CTRL_EN   ; Turn on the random number genertator
.1a024d	8f 86 e8 af	sta $afe886	            STA @l GABE_RNG_CTRL
.1a0251	28		plp		            PLP
.1a0252	60		rts		            RTS
.1a0253					SCREEN_PUTC
.1a0253	08		php		            PHP
.1a0254	e2 20		sep #$20	            SEP #$20
.1a0256	48		pha		            PHA
.1a0257	48		pha		            PHA
.1a0258	a9 00		lda #$00	            LDA #CHAN_CONSOLE       ; Switch to the console device
.1a025a	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.1a025e	68		pla		            PLA
.1a025f	22 18 10 00	jsl $001018	            JSL FK_PUTC
.1a0263	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.1a0267	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.1a0269	d0 f8		bne $1a0263	            BNE loop                ; Yes: wait until it's released
.1a026b	68		pla		            PLA
.1a026c	28		plp		            PLP
.1a026d	60		rts		            RTS
.1a026e					UART_PUTC
.1a026e	08		php		            PHP
.1a026f	e2 20		sep #$20	            SEP #$20
.1a0271	48		pha		            PHA
.1a0272	48		pha		            PHA
.1a0273	a9 01		lda #$01	            LDA #CHAN_COM1          ; Switch to COM1
.1a0275	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.1a0279	68		pla		            PLA
.1a027a	22 18 10 00	jsl $001018	            JSL FK_PUTC
.1a027e	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.1a0282	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.1a0284	d0 f8		bne $1a027e	            BNE loop                ; Yes: wait until it's released
.1a0286	68		pla		            PLA
.1a0287	28		plp		            PLP
.1a0288	60		rts		            RTS
.1a0289					PRINTCR
.1a0289	08		php		            PHP
.1a028a	c2 20		rep #$20	            REP #$20
.1a028c	48		pha		            PHA
.1a028d	e2 20		sep #$20	            SEP #$20
.1a028f	a9 0d		lda #$0d	            LDA #CHAR_CR
.1a0291	20 18 00	jsr $1a0018	            JSR PRINTC
.1a0294	c2 20		rep #$20	            REP #$20
.1a0296	68		pla		            PLA
.1a0297	28		plp		            PLP
.1a0298	60		rts		            RTS
.1a0299					PRINTH
.1a0299	08		php		            PHP
.1a029a	22 78 10 00	jsl $001078	            JSL FK_IPRINTH
.1a029e	28		plp		            PLP
.1a029f	60		rts		            RTS

;******  Return to file: src\bios.s

=10					LINES_PER_PAGE = 10     ; The number of lines to print on a page before pausing
=$80					DEV_SCREEN = $80        ; Use the screen and keyboard for the console device
=$40					DEV_UART = $40          ; Use UART for console device
=$20					DEV_BUFFER = $20        ; Use the current text memory buffer for output or input
>08b4					BCONSOLE    .byte ?     ; Device for BASIC console
>08b5					SAVE_A      .byte ?     ; Save spot for the A register
>08b6					LINECOUNT   .byte ?     ; Counter for new lines to support pagination
.1a02a0					PAGINATE
.1a02a0	08		php		            PHP
.1a02a1	0b		phd		            PHD
.1a02a2	08		php		            PHP
.1a02a3	c2 20		rep #$20	            REP #$20
.1a02a5	48		pha		            PHA
.1a02a6	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a02a9	5b		tcd		            TCD
.1a02aa	68		pla		            PLA
.1a02ab	28		plp		            PLP
.1a02ac	e2 20		sep #$20	            SEP #$20
.1a02ae	a5 b6		lda $08b6	            LDA LINECOUNT           ; Check the line count
.1a02b0	1a		inc a		            INC A
.1a02b1	85 b6		sta $08b6	            STA LINECOUNT
.1a02b3	cf 13 00 00	cmp $000013	            CMP @l LINES_VISIBLE
.1a02b7	90 05		bcc $1a02be	            BLT done                ; If < limit, just return
.1a02b9	20 14 00	jsr $1a0014	            JSR GETKEY
.1a02bc	64 b6		stz $08b6	            STZ LINECOUNT           ; And reset the line count
.1a02be	2b		pld		done        PLD
.1a02bf	28		plp		            PLP
.1a02c0	60		rts		            RTS
.1a02c1					IPRINTC
.1a02c1	da		phx		            PHX
.1a02c2	5a		phy		            PHY
.1a02c3	0b		phd		            PHD
.1a02c4	08		php		            PHP
.1a02c5	08		php		            PHP
.1a02c6	c2 20		rep #$20	            REP #$20
.1a02c8	48		pha		            PHA
.1a02c9	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a02cc	5b		tcd		            TCD
.1a02cd	68		pla		            PLA
.1a02ce	28		plp		            PLP
.1a02cf	e2 20		sep #$20	            SEP #$20
.1a02d1	c2 10		rep #$10	            REP #$10
.1a02d3	8f b5 08 00	sta $0008b5	            STA @lSAVE_A
.1a02d7	af b4 08 00	lda $0008b4	chk_out     LDA @lBCONSOLE      ; Check to see if we should send to an output buffer
.1a02db	29 20		and #$20	            AND #DEV_BUFFER
.1a02dd	f0 07		beq $1a02e6	            BEQ check_scrn      ; No... move on to the hardware screen
.1a02df	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.1a02e3	20 28 00	jsr $1a0028	            JSR OBUFF_PUTC
.1a02e6	af b4 08 00	lda $0008b4	check_scrn  LDA @lBCONSOLE
.1a02ea	29 80		and #$80	            AND #DEV_SCREEN     ; Check to see if the screen is selected
.1a02ec	f0 07		beq $1a02f5	            BEQ send_uart
.1a02ee	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.1a02f2	20 53 02	jsr $1a0253	            JSR SCREEN_PUTC
.1a02f5	af b4 08 00	lda $0008b4	send_uart   LDA @lBCONSOLE
.1a02f9	29 40		and #$40	            AND #DEV_UART       ; Check to see if the UART is active
.1a02fb	f0 14		beq $1a0311	            BEQ done
.1a02fd	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.1a0301	20 6e 02	jsr $1a026e	            JSR UART_PUTC
.1a0304	af b5 08 00	lda $0008b5	            LDA @lSAVE_A        ; If sending a CR to the serial port
.1a0308	c9 0d		cmp #$0d	            CMP #CHAR_CR
.1a030a	d0 05		bne $1a0311	            BNE done
.1a030c	a9 0a		lda #$0a	            LDA #CHAR_LF        ; Send a linefeed after
.1a030e	20 6e 02	jsr $1a026e	            JSR UART_PUTC
.1a0311	28		plp		done        PLP
.1a0312	2b		pld		            PLD
.1a0313	7a		ply		            PLY
.1a0314	fa		plx		            PLX
.1a0315	60		rts		            RTS
.1a0316					PRINTS
.1a0316	08		php		            PHP
.1a0317	e2 20		sep #$20	            SEP #$20
.1a0319	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.1a031c	f0 06		beq $1a0324	            BEQ done
.1a031e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a0321	e8		inx		            INX
.1a0322	80 f5		bra $1a0319	            BRA loop
.1a0324	28		plp		done        PLP
.1a0325	60		rts		            RTS
.1a0326					PRHEXW
.1a0326	08		php		            PHP
.1a0327	c2 20		rep #$20	            REP #$20
.1a0329	48		pha		            PHA
.1a032a	48		pha		            PHA
.1a032b	4a		lsr a		            LSR A
.1a032c	4a		lsr a		            LSR A
.1a032d	4a		lsr a		            LSR A
.1a032e	4a		lsr a		            LSR A
.1a032f	4a		lsr a		            LSR A
.1a0330	4a		lsr a		            LSR A
.1a0331	4a		lsr a		            LSR A
.1a0332	4a		lsr a		            LSR A
.1a0333	20 40 03	jsr $1a0340	            JSR PRHEXB
.1a0336	68		pla		            PLA
.1a0337	29 ff 00	and #$00ff	            AND #$00FF
.1a033a	20 40 03	jsr $1a0340	            JSR PRHEXB
.1a033d	68		pla		            PLA
.1a033e	28		plp		            PLP
.1a033f	60		rts		            RTS
.1a0340					PRHEXB
.1a0340	08		php		            PHP
.1a0341	c2 20		rep #$20	            REP #$20
.1a0343	48		pha		            PHA
.1a0344	e2 20		sep #$20	            SEP #$20
.1a0346	48		pha		            PHA
.1a0347	4a		lsr a		            LSR A
.1a0348	4a		lsr a		            LSR A
.1a0349	4a		lsr a		            LSR A
.1a034a	4a		lsr a		            LSR A
.1a034b	20 57 03	jsr $1a0357	            JSR PRHEXN
.1a034e	68		pla		            PLA
.1a034f	20 57 03	jsr $1a0357	            JSR PRHEXN
.1a0352	c2 20		rep #$20	            REP #$20
.1a0354	68		pla		            PLA
.1a0355	28		plp		            PLP
.1a0356	60		rts		            RTS
.1a0357					PRHEXN
.1a0357	08		php		            PHP
.1a0358	c2 30		rep #$30	            REP #$30
.1a035a	da		phx		            PHX
.1a035b	29 0f 00	and #$000f	            AND #$000F
.1a035e	aa		tax		            TAX
.1a035f	bf 00 d0 1a	lda $1ad000,x	            LDA @lHEXDIGITS,X
.1a0363	20 18 00	jsr $1a0018	            JSR PRINTC
.1a0366	fa		plx		            PLX
.1a0367	28		plp		            PLP
.1a0368	60		rts		            RTS
>1ad000	30 31 32 33 34 35 36 37		HEXDIGITS   .text "0123456789ABCDEF"
>1ad008	38 39 41 42 43 44 45 46

;******  Return to file: src\basic816.s


;******  Processing file: src\utilities.s

.1a0369					PRTRACE
.1a0369	08		php		            PHP
.1a036a	c2 30		rep #$30	            REP #$30
.1a036c	48		pha		            PHA
.1a036d	da		phx		            PHX
.1a036e	5a		phy		            PHY
.1a036f	8b		phb		            PHB
.1a0370	0b		phd		            PHD
.1a0371	c2 30		rep #$30	            REP #$30
.1a0373	a3 0b		lda $0b,s	            LDA 11,S        ; Get the return address
.1a0375	18		clc		calc_addr   CLC
.1a0376	69 03 00	adc #$0003	            ADC #3          ; Add 3 to skip over the following branch
.1a0379	aa		tax		            TAX
.1a037a	e2 20		sep #$20	            SEP #$20
.1a037c	a9 1a		lda #$1a	            LDA #`PRTRACE
.1a037e	48		pha		            PHA
.1a037f	ab		plb		            PLB
.1a0380	bd 00 00	lda $0000,x	pr_loop     LDA #0,B,X
.1a0383	f0 06		beq $1a038b	            BEQ done
.1a0385	20 53 02	jsr $1a0253	            JSR SCREEN_PUTC
.1a0388	e8		inx		            INX
.1a0389	80 f5		bra $1a0380	            BRA pr_loop
.1a038b					done
.1a038b	c2 30		rep #$30	            REP #$30
.1a038d	2b		pld		            PLD
.1a038e	ab		plb		            PLB
.1a038f	7a		ply		            PLY
.1a0390	fa		plx		            PLX
.1a0391	68		pla		            PLA
.1a0392	28		plp		            PLP
.1a0393	60		rts		            RTS
.1a0394					ISALPHA
.1a0394	08		php		            PHP
.1a0395	e2 20		sep #$20	            SEP #$20
.1a0397	c9 5b		cmp #$5b	            CMP #'Z'+1
.1a0399	b0 04		bcs $1a039f	            BGE not_upper
.1a039b	c9 41		cmp #$41	            CMP #'A'
.1a039d	b0 0b		bcs $1a03aa	            BGE is_alpha
.1a039f	c9 7b		cmp #$7b	not_upper   CMP #'z'+1
.1a03a1	b0 04		bcs $1a03a7	            BGE not_alpha
.1a03a3	c9 61		cmp #$61	            CMP #'a'
.1a03a5	b0 03		bcs $1a03aa	            BGE is_alpha
.1a03a7					not_alpha
.1a03a7	28		plp		            PLP
.1a03a8	18		clc		            CLC
.1a03a9	60		rts		            RTS
.1a03aa					is_alpha
.1a03aa	28		plp		            PLP
.1a03ab	38		sec		            SEC
.1a03ac	60		rts		            RTS
.1a03ad					ISNUMERAL
.1a03ad	08		php		            PHP
.1a03ae	e2 20		sep #$20	            SEP #$20
.1a03b0	c9 3a		cmp #$3a	            CMP #'9'+1
.1a03b2	b0 04		bcs $1a03b8	            BGE ret_false
.1a03b4	c9 30		cmp #$30	            CMP #'0'
.1a03b6	b0 03		bcs $1a03bb	            BGE ret_true
.1a03b8	28		plp		ret_false   PLP
.1a03b9	18		clc		            CLC
.1a03ba	60		rts		            RTS
.1a03bb	28		plp		ret_true    PLP
.1a03bc	38		sec		            SEC
.1a03bd	60		rts		            RTS
.1a03be					ISHEX
.1a03be	08		php		            PHP
.1a03bf	e2 20		sep #$20	            SEP #$20
.1a03c1	c9 3a		cmp #$3a	            CMP #'9'+1
.1a03c3	b0 04		bcs $1a03c9	            BGE chk_lca2f
.1a03c5	c9 30		cmp #$30	            CMP #'0'
.1a03c7	b0 13		bcs $1a03dc	            BGE ret_true
.1a03c9	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.1a03cb	b0 04		bcs $1a03d1	            BGE chk_uca2f
.1a03cd	c9 61		cmp #$61	            CMP #'a'
.1a03cf	b0 0b		bcs $1a03dc	            BGE ret_true
.1a03d1	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.1a03d3	b0 04		bcs $1a03d9	            BGE ret_false
.1a03d5	c9 41		cmp #$41	            CMP #'A'
.1a03d7	b0 03		bcs $1a03dc	            BGE ret_true
.1a03d9	28		plp		ret_false   PLP
.1a03da	18		clc		            CLC
.1a03db	60		rts		            RTS
.1a03dc	28		plp		ret_true    PLP
.1a03dd	38		sec		            SEC
.1a03de	60		rts		            RTS
.1a03df					HEX2BIN
.1a03df	08		php		            PHP
.1a03e0	e2 20		sep #$20	            SEP #$20
.1a03e2	c9 3a		cmp #$3a	            CMP #'9'+1          ; Check to see if '0'..'9'
.1a03e4	b0 04		bcs $1a03ea	            BGE chk_lca2f
.1a03e6	c9 30		cmp #$30	            CMP #'0'
.1a03e8	b0 12		bcs $1a03fc	            BGE conv_09         ; Yes: convert it
.1a03ea	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.1a03ec	b0 04		bcs $1a03f2	            BGE chk_uca2f
.1a03ee	c9 61		cmp #$61	            CMP #'a'
.1a03f0	b0 0f		bcs $1a0401	            BGE conv_lcaf
.1a03f2	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.1a03f4	b0 04		bcs $1a03fa	            BGE done
.1a03f6	c9 41		cmp #$41	            CMP #'A'
.1a03f8	b0 09		bcs $1a0403	            BGE conv_ucaf
.1a03fa	28		plp		done        PLP
.1a03fb	60		rts		            RTS
.1a03fc	38		sec		conv_09     SEC                 ; Convert digits '0'..'9'
.1a03fd	e9 30		sbc #$30	            SBC #'0'
.1a03ff	80 f9		bra $1a03fa	            BRA done
.1a0401	29 df		and #$df	conv_lcaf   AND #%11011111      ; Convert to upper case
.1a0403	38		sec		conv_ucaf   SEC
.1a0404	e9 37		sbc #$37	            SBC #'A'-10         ; Convert 'A'..'F'
.1a0406	80 f2		bra $1a03fa	            BRA done
.1a0408					TOUPPERA
.1a0408	08		php		            PHP
.1a0409	e2 20		sep #$20	            SEP #$20
.1a040b	c9 7b		cmp #$7b	            CMP #'z'+1
.1a040d	b0 06		bcs $1a0415	            BCS done
.1a040f	c9 61		cmp #$61	            CMP #'a'
.1a0411	90 02		bcc $1a0415	            BCC done
.1a0413	29 df		and #$df	            AND #%11011111
.1a0415	28		plp		done        PLP
.1a0416	60		rts		            RTS
.1a0417					TOUPPER
.1a0417	08		php		            PHP
.1a0418	e2 20		sep #$20	            SEP #$20
.1a041a	c2 10		rep #$10	            REP #$10
.1a041c	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.1a041f	f0 09		beq $1a042a	            BEQ done
.1a0421	20 08 04	jsr $1a0408	            JSR TOUPPERA
.1a0424	9d 00 00	sta $0000,x	            STA #0,B,X
.1a0427	e8		inx		continue    INX
.1a0428	80 f2		bra $1a041c	            BRA loop
.1a042a	28		plp		done        PLP
.1a042b	60		rts		            RTS
.1a042c					MULINT10
.1a042c	08		php		                PHP
.1a042d	0b		phd		                PHD
.1a042e	08		php		            PHP
.1a042f	c2 20		rep #$20	            REP #$20
.1a0431	48		pha		            PHA
.1a0432	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0435	5b		tcd		            TCD
.1a0436	68		pla		            PLA
.1a0437	28		plp		            PLP
.1a0438	c2 20		rep #$20	            REP #$20
.1a043a	48		pha		                PHA
.1a043b	06 23		asl $0823	                ASL ARGUMENT1           ; 7 -- 20 -- 74
.1a043d	26 25		rol $0825	                ROL ARGUMENT1+2         ; 7
.1a043f	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.1a0441	85 0c		sta $080c	                STA SCRATCH             ; 4
.1a0443	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.1a0445	85 0e		sta $080e	                STA SCRATCH+2           ; 4
.1a0447	06 0c		asl $080c	                ASL SCRATCH             ; 7 -- 28
.1a0449	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.1a044b	06 0c		asl $080c	                ASL SCRATCH             ; 7
.1a044d	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.1a044f	18		clc		                CLC                     ; 2 -- 26
.1a0450	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.1a0452	65 0c		adc $080c	                ADC SCRATCH             ; 4
.1a0454	85 23		sta $0823	                STA ARGUMENT1           ; 4
.1a0456	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.1a0458	65 0e		adc $080e	                ADC SCRATCH+2           ; 4
.1a045a	85 25		sta $0825	                STA ARGUMENT1+2         ; 4
.1a045c	68		pla		                PLA
.1a045d	2b		pld		                PLD
.1a045e	28		plp		                PLP
.1a045f	60		rts		            RTS
.1a0460					DIVINT10
.1a0460	08		php		                PHP
.1a0461	0b		phd		                PHD
.1a0462	08		php		            PHP
.1a0463	c2 20		rep #$20	            REP #$20
.1a0465	48		pha		            PHA
.1a0466	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0469	5b		tcd		            TCD
.1a046a	68		pla		            PLA
.1a046b	28		plp		            PLP
.1a046c	c2 20		rep #$20	            REP #$20
.1a046e	a5 23		lda $0823	                LDA ARGUMENT1
.1a0470	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.1a0474	a9 0a 00	lda #$000a	                LDA #10
.1a0477	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.1a047b	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.1a047f	85 23		sta $0823	                STA ARGUMENT1
.1a0481	64 25		stz $0825	                STZ ARGUMENT1+2
.1a0483	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.1a0487	85 29		sta $0829	                STA ARGUMENT2
.1a0489	64 2b		stz $082b	                STZ ARGUMENT2+2
.1a048b	e2 20		sep #$20	            SEP #$20
.1a048d	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a048f	85 27		sta $0827	                STA ARGTYPE1
.1a0491	85 2d		sta $082d	                STA ARGTYPE2
.1a0493	2b		pld		                PLD
.1a0494	28		plp		                PLP
.1a0495	60		rts		            RTS
.1a0496					DIVINT100
.1a0496	08		php		                PHP
.1a0497	0b		phd		                PHD
.1a0498	08		php		            PHP
.1a0499	c2 20		rep #$20	            REP #$20
.1a049b	48		pha		            PHA
.1a049c	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a049f	5b		tcd		            TCD
.1a04a0	68		pla		            PLA
.1a04a1	28		plp		            PLP
.1a04a2	c2 20		rep #$20	            REP #$20
.1a04a4	a5 23		lda $0823	                LDA ARGUMENT1
.1a04a6	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.1a04aa	a9 64 00	lda #$0064	                LDA #100
.1a04ad	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.1a04b1	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.1a04b5	85 23		sta $0823	                STA ARGUMENT1
.1a04b7	64 25		stz $0825	                STZ ARGUMENT1+2
.1a04b9	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.1a04bd	85 29		sta $0829	                STA ARGUMENT2
.1a04bf	64 2b		stz $082b	                STZ ARGUMENT2+2
.1a04c1	e2 20		sep #$20	            SEP #$20
.1a04c3	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a04c5	85 27		sta $0827	                STA ARGTYPE1
.1a04c7	85 2d		sta $082d	                STA ARGTYPE2
.1a04c9	2b		pld		                PLD
.1a04ca	28		plp		                PLP
.1a04cb	60		rts		            RTS
.1a04cc					IS_ARG1_Z
.1a04cc	08		php		                PHP
.1a04cd	c2 20		rep #$20	            REP #$20
.1a04cf	a5 23		lda $0823	                LDA ARGUMENT1
.1a04d1	d0 08		bne $1a04db	                BNE return_false
.1a04d3	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a04d5	d0 04		bne $1a04db	                BNE return_false
.1a04d7	28		plp		return_true     PLP
.1a04d8	e2 02		sep #$02	                SEP #$02        ; Set Z
.1a04da	60		rts		            RTS
.1a04db	28		plp		return_false    PLP
.1a04dc	c2 02		rep #$02	                REP #$02        ; Clear Z
.1a04de	60		rts		            RTS
.1a04df					SET_TRUE
.1a04df	08		php		                PHP
.1a04e0	c2 30		rep #$30	            REP #$30
.1a04e2	a9 ff ff	lda #$ffff	                LDA #$FFFF
.1a04e5	85 23		sta $0823	                STA ARGUMENT1
.1a04e7	85 25		sta $0825	                STA ARGUMENT1+2
.1a04e9	e2 20		sep #$20	            SEP #$20
.1a04eb	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a04ed	85 27		sta $0827	                STA ARGTYPE1
.1a04ef	28		plp		                PLP
.1a04f0	60		rts		            RTS
.1a04f1					SET_FALSE
.1a04f1	08		php		                PHP
.1a04f2	c2 30		rep #$30	            REP #$30
.1a04f4	a9 00 00	lda #$0000	                LDA #0
.1a04f7	85 23		sta $0823	                STA ARGUMENT1
.1a04f9	85 25		sta $0825	                STA ARGUMENT1+2
.1a04fb	e2 20		sep #$20	            SEP #$20
.1a04fd	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a04ff	85 27		sta $0827	                STA ARGTYPE1
.1a0501	28		plp		                PLP
.1a0502	60		rts		            RTS
.1a0503					ASS_ARG1_INT
.1a0503	08		php		                PHP
.1a0504	e2 20		sep #$20	            SEP #$20
.1a0506	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.1a0508	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a050a	f0 07		beq $1a0513	                BEQ done                ; If so: just return
.1a050c	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.1a050e	d0 05		bne $1a0515	                BNE TYPE_ERR            ; If not: throw an error
.1a0510	20 77 59	jsr $1a5977	            JSR FTOI
.1a0513	28		plp		done            PLP
.1a0514	60		rts		            RTS
.1a0515					TYPE_ERR
.1a0515	08		php		            PHP
.1a0516	c2 20		rep #$20	            REP #$20
.1a0518	48		pha		            PHA
.1a0519	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a051c	5b		tcd		            TCD
.1a051d	68		pla		            PLA
.1a051e	28		plp		            PLP
.1a051f	e2 20		sep #$20	            SEP #$20
.1a0521	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0523	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0527	c2 20		rep #$20	            REP #$20
.1a0529	29 ff 00	and #$00ff	            AND #$00FF
.1a052c	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a052f	e2 20		sep #$20	            SEP #$20
.1a0531	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0534					ASS_ARG2_INT
.1a0534	08		php		                PHP
.1a0535	e2 20		sep #$20	            SEP #$20
.1a0537	a5 2d		lda $082d	                LDA ARGTYPE2                ; Verify that the type is INTEGER
.1a0539	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a053b	f0 37		beq $1a0574	                BEQ done                    ; If so: just return
.1a053d	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; Check if it's a float
.1a053f	d0 35		bne $1a0576	                BNE TYPE_ERR                ; If not: throw an error
.1a0541	c2 20		rep #$20	            REP #$20
.1a0543	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a0545	48		pha		            PHA
.1a0546	a5 23		lda $0823	            LDA ARGUMENT1
.1a0548	48		pha		            PHA
.1a0549	c2 20		rep #$20	            REP #$20
.1a054b	a5 29		lda $0829	            LDA ARGUMENT2
.1a054d	85 23		sta $0823	            STA ARGUMENT1
.1a054f	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a0551	85 25		sta $0825	            STA ARGUMENT1+2
.1a0553	e2 20		sep #$20	            SEP #$20
.1a0555	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.1a0557	85 27		sta $0827	            STA ARGTYPE1
.1a0559	20 77 59	jsr $1a5977	            JSR FTOI
.1a055c	c2 20		rep #$20	            REP #$20
.1a055e	a5 23		lda $0823	            LDA ARGUMENT1
.1a0560	85 29		sta $0829	            STA ARGUMENT2
.1a0562	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a0564	85 2b		sta $082b	            STA ARGUMENT2+2
.1a0566	e2 20		sep #$20	            SEP #$20
.1a0568	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a056a	85 2d		sta $082d	            STA ARGTYPE2
.1a056c	c2 20		rep #$20	            REP #$20
.1a056e	68		pla		            PLA
.1a056f	85 23		sta $0823	            STA ARGUMENT1
.1a0571	68		pla		            PLA
.1a0572	85 25		sta $0825	            STA ARGUMENT1+2
.1a0574	28		plp		done            PLP
.1a0575	60		rts		            RTS
.1a0576					TYPE_ERR
.1a0576	08		php		            PHP
.1a0577	c2 20		rep #$20	            REP #$20
.1a0579	48		pha		            PHA
.1a057a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a057d	5b		tcd		            TCD
.1a057e	68		pla		            PLA
.1a057f	28		plp		            PLP
.1a0580	e2 20		sep #$20	            SEP #$20
.1a0582	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0584	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0588	c2 20		rep #$20	            REP #$20
.1a058a	29 ff 00	and #$00ff	            AND #$00FF
.1a058d	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a0590	e2 20		sep #$20	            SEP #$20
.1a0592	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0595					ASS_ARG1_STR
.1a0595	08		php		                PHP
.1a0596	e2 20		sep #$20	            SEP #$20
.1a0598	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is STRING
.1a059a	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a059c	d0 02		bne $1a05a0	                BNE TYPE_ERR
.1a059e	28		plp		                PLP
.1a059f	60		rts		            RTS
.1a05a0					TYPE_ERR
.1a05a0	08		php		            PHP
.1a05a1	c2 20		rep #$20	            REP #$20
.1a05a3	48		pha		            PHA
.1a05a4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a05a7	5b		tcd		            TCD
.1a05a8	68		pla		            PLA
.1a05a9	28		plp		            PLP
.1a05aa	e2 20		sep #$20	            SEP #$20
.1a05ac	a9 04		lda #$04	            LDA #ERR_TYPE
.1a05ae	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a05b2	c2 20		rep #$20	            REP #$20
.1a05b4	29 ff 00	and #$00ff	            AND #$00FF
.1a05b7	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a05ba	e2 20		sep #$20	            SEP #$20
.1a05bc	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a05bf					ASS_ARG1_INT16
.1a05bf	08		php		                PHP
.1a05c0	e2 20		sep #$20	            SEP #$20
.1a05c2	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.1a05c4	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a05c6	f0 07		beq $1a05cf	                BEQ check_range         ; If so: check the range
.1a05c8	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.1a05ca	d0 0b		bne $1a05d7	                BNE TYPE_ERR            ; If not: throw an error
.1a05cc	20 77 59	jsr $1a5977	            JSR FTOI
.1a05cf					check_range
.1a05cf	c2 20		rep #$20	            REP #$20
.1a05d1	a5 25		lda $0825	                LDA ARGUMENT1+2         ; Validate it is 16-bit
.1a05d3	d0 21		bne $1a05f6	                BNE range_err
.1a05d5	28		plp		                PLP
.1a05d6	60		rts		            RTS
.1a05d7					TYPE_ERR
.1a05d7	08		php		            PHP
.1a05d8	c2 20		rep #$20	            REP #$20
.1a05da	48		pha		            PHA
.1a05db	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a05de	5b		tcd		            TCD
.1a05df	68		pla		            PLA
.1a05e0	28		plp		            PLP
.1a05e1	e2 20		sep #$20	            SEP #$20
.1a05e3	a9 04		lda #$04	            LDA #ERR_TYPE
.1a05e5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a05e9	c2 20		rep #$20	            REP #$20
.1a05eb	29 ff 00	and #$00ff	            AND #$00FF
.1a05ee	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a05f1	e2 20		sep #$20	            SEP #$20
.1a05f3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a05f6					RANGE_ERR
.1a05f6	08		php		            PHP
.1a05f7	c2 20		rep #$20	            REP #$20
.1a05f9	48		pha		            PHA
.1a05fa	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a05fd	5b		tcd		            TCD
.1a05fe	68		pla		            PLA
.1a05ff	28		plp		            PLP
.1a0600	e2 20		sep #$20	            SEP #$20
.1a0602	a9 09		lda #$09	            LDA #ERR_RANGE
.1a0604	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0608	c2 20		rep #$20	            REP #$20
.1a060a	29 ff 00	and #$00ff	            AND #$00FF
.1a060d	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a0610	e2 20		sep #$20	            SEP #$20
.1a0612	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0615					ASS_ARG1_BYTE
.1a0615	08		php		                PHP
.1a0616	e2 20		sep #$20	            SEP #$20
.1a0618	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.1a061a	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a061c	f0 07		beq $1a0625	                BEQ check_range         ; If so: check the range
.1a061e	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.1a0620	d0 11		bne $1a0633	                BNE TYPE_ERR            ; If not: throw an error
.1a0622	20 77 59	jsr $1a5977	            JSR FTOI
.1a0625	a5 26		lda $0826	check_range     LDA ARGUMENT1+3         ; Validate that the value is in byte range
.1a0627	d0 29		bne $1a0652	                BNE RANGE_ERR           ; If not... throw a range error
.1a0629	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a062b	d0 25		bne $1a0652	                BNE RANGE_ERR
.1a062d	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a062f	d0 21		bne $1a0652	                BNE RANGE_ERR
.1a0631	28		plp		                PLP
.1a0632	60		rts		            RTS
.1a0633					TYPE_ERR
.1a0633	08		php		            PHP
.1a0634	c2 20		rep #$20	            REP #$20
.1a0636	48		pha		            PHA
.1a0637	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a063a	5b		tcd		            TCD
.1a063b	68		pla		            PLA
.1a063c	28		plp		            PLP
.1a063d	e2 20		sep #$20	            SEP #$20
.1a063f	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0641	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0645	c2 20		rep #$20	            REP #$20
.1a0647	29 ff 00	and #$00ff	            AND #$00FF
.1a064a	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a064d	e2 20		sep #$20	            SEP #$20
.1a064f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0652					RANGE_ERR
.1a0652	08		php		            PHP
.1a0653	c2 20		rep #$20	            REP #$20
.1a0655	48		pha		            PHA
.1a0656	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0659	5b		tcd		            TCD
.1a065a	68		pla		            PLA
.1a065b	28		plp		            PLP
.1a065c	e2 20		sep #$20	            SEP #$20
.1a065e	a9 09		lda #$09	            LDA #ERR_RANGE
.1a0660	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0664	c2 20		rep #$20	            REP #$20
.1a0666	29 ff 00	and #$00ff	            AND #$00FF
.1a0669	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a066c	e2 20		sep #$20	            SEP #$20
.1a066e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0671					ASS_ARG1_FLOAT
.1a0671	08		php		                PHP
.1a0672	e2 20		sep #$20	            SEP #$20
.1a0674	a5 27		lda $0827	                LDA ARGTYPE1            ; Check the type
.1a0676	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.1a0678	f0 26		beq $1a06a0	                BEQ done                ; Then we're done
.1a067a	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.1a067c	f0 1f		beq $1a069d	                BEQ cast                ; Then cast it to float
.1a067e					type_err
.1a067e	08		php		            PHP
.1a067f	c2 20		rep #$20	            REP #$20
.1a0681	48		pha		            PHA
.1a0682	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a0685	5b		tcd		            TCD
.1a0686	68		pla		            PLA
.1a0687	28		plp		            PLP
.1a0688	e2 20		sep #$20	            SEP #$20
.1a068a	a9 04		lda #$04	            LDA #ERR_TYPE
.1a068c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0690	c2 20		rep #$20	            REP #$20
.1a0692	29 ff 00	and #$00ff	            AND #$00FF
.1a0695	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a0698	e2 20		sep #$20	            SEP #$20
.1a069a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a069d					cast
.1a069d	20 71 59	jsr $1a5971	            JSR ITOF
.1a06a0	28		plp		done            PLP
.1a06a1	60		rts		            RTS
.1a06a2					ASS_ARG2_FLOAT
.1a06a2	08		php		                PHP
.1a06a3	e2 20		sep #$20	            SEP #$20
.1a06a5	a5 2d		lda $082d	                LDA ARGTYPE2            ; Check the type
.1a06a7	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.1a06a9	f0 26		beq $1a06d1	                BEQ done                ; Then we're done
.1a06ab	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.1a06ad	f0 1f		beq $1a06ce	                BEQ cast                ; Then cast it to float
.1a06af					type_err
.1a06af	08		php		            PHP
.1a06b0	c2 20		rep #$20	            REP #$20
.1a06b2	48		pha		            PHA
.1a06b3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a06b6	5b		tcd		            TCD
.1a06b7	68		pla		            PLA
.1a06b8	28		plp		            PLP
.1a06b9	e2 20		sep #$20	            SEP #$20
.1a06bb	a9 04		lda #$04	            LDA #ERR_TYPE
.1a06bd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a06c1	c2 20		rep #$20	            REP #$20
.1a06c3	29 ff 00	and #$00ff	            AND #$00FF
.1a06c6	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a06c9	e2 20		sep #$20	            SEP #$20
.1a06cb	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a06ce					cast
.1a06ce	20 d3 06	jsr $1a06d3	            JSR CAST_ARG2_FLOAT
.1a06d1	28		plp		done            PLP
.1a06d2	60		rts		            RTS
.1a06d3					CAST_ARG2_FLOAT
.1a06d3	c2 20		rep #$20	            REP #$20
.1a06d5	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a06d7	48		pha		            PHA
.1a06d8	a5 23		lda $0823	            LDA ARGUMENT1
.1a06da	48		pha		            PHA
.1a06db	c2 20		rep #$20	            REP #$20
.1a06dd	a5 29		lda $0829	            LDA ARGUMENT2
.1a06df	85 23		sta $0823	            STA ARGUMENT1
.1a06e1	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a06e3	85 25		sta $0825	            STA ARGUMENT1+2
.1a06e5	e2 20		sep #$20	            SEP #$20
.1a06e7	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a06e9	85 27		sta $0827	            STA ARGTYPE1
.1a06eb	20 71 59	jsr $1a5971	            JSR ITOF
.1a06ee	c2 20		rep #$20	            REP #$20
.1a06f0	a5 23		lda $0823	            LDA ARGUMENT1
.1a06f2	85 29		sta $0829	            STA ARGUMENT2
.1a06f4	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a06f6	85 2b		sta $082b	            STA ARGUMENT2+2
.1a06f8	e2 20		sep #$20	            SEP #$20
.1a06fa	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.1a06fc	85 2d		sta $082d	            STA ARGTYPE2
.1a06fe	c2 20		rep #$20	            REP #$20
.1a0700	68		pla		            PLA
.1a0701	85 23		sta $0823	            STA ARGUMENT1
.1a0703	68		pla		            PLA
.1a0704	85 25		sta $0825	            STA ARGUMENT1+2
.1a0706	60		rts		            RTS
.1a0707					ASS_ARGS_NUM
.1a0707	08		php		                PHP
.1a0708	e2 20		sep #$20	            SEP #$20
.1a070a	a5 27		lda $0827	                LDA ARGTYPE1                ; Check ARGUMENT1
.1a070c	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a070e	f0 23		beq $1a0733	                BEQ arg1_int
.1a0710	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.1a0712	f0 2e		beq $1a0742	                BEQ arg1_float
.1a0714					type_err
.1a0714	08		php		            PHP
.1a0715	c2 20		rep #$20	            REP #$20
.1a0717	48		pha		            PHA
.1a0718	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a071b	5b		tcd		            TCD
.1a071c	68		pla		            PLA
.1a071d	28		plp		            PLP
.1a071e	e2 20		sep #$20	            SEP #$20
.1a0720	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0722	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0726	c2 20		rep #$20	            REP #$20
.1a0728	29 ff 00	and #$00ff	            AND #$00FF
.1a072b	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a072e	e2 20		sep #$20	            SEP #$20
.1a0730	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0733	a5 2d		lda $082d	arg1_int        LDA ARGTYPE2                ; Check argument 2
.1a0735	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If integer, we're done
.1a0737	f0 16		beq $1a074f	                BEQ done
.1a0739	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If not float, throw an error
.1a073b	d0 d7		bne $1a0714	                BNE type_err
.1a073d	20 71 59	jsr $1a5971	            JSR ITOF
.1a0740	80 0d		bra $1a074f	                BRA done
.1a0742	a5 2d		lda $082d	arg1_float      LDA ARGTYPE2                ; Check argument 2
.1a0744	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If it's float
.1a0746	f0 07		beq $1a074f	                BEQ done                    ; Then we're done
.1a0748	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If it's not integer
.1a074a	d0 c8		bne $1a0714	                BNE type_err                ; Thrown an error
.1a074c	20 d3 06	jsr $1a06d3	            JSR CAST_ARG2_FLOAT
.1a074f					done
.1a074f	e2 20		sep #$20	            SEP #$20
.1a0751	a5 27		lda $0827	                LDA ARGTYPE1                ; Return the type code in A
.1a0753	28		plp		                PLP
.1a0754	60		rts		            RTS
.1a0755					ASS_ARGS_NUMSTR
.1a0755	08		php		                PHP
.1a0756	e2 20		sep #$20	            SEP #$20
.1a0758	a5 27		lda $0827	                LDA ARGTYPE1                ; Check to see if ARGUMENT1 is a string
.1a075a	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a075c	d0 25		bne $1a0783	                BNE numbers
.1a075e	a5 2d		lda $082d	                LDA ARGTYPE2                ; If ARGUMENT1 is a string, make sure ARGUMENT2 is
.1a0760	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a0762	f0 24		beq $1a0788	                BEQ done
.1a0764					TYPE_ERR
.1a0764	08		php		            PHP
.1a0765	c2 20		rep #$20	            REP #$20
.1a0767	48		pha		            PHA
.1a0768	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a076b	5b		tcd		            TCD
.1a076c	68		pla		            PLA
.1a076d	28		plp		            PLP
.1a076e	e2 20		sep #$20	            SEP #$20
.1a0770	a9 04		lda #$04	            LDA #ERR_TYPE
.1a0772	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a0776	c2 20		rep #$20	            REP #$20
.1a0778	29 ff 00	and #$00ff	            AND #$00FF
.1a077b	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a077e	e2 20		sep #$20	            SEP #$20
.1a0780	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a0783					numbers
.1a0783	20 07 07	jsr $1a0707	            JSR ASS_ARGS_NUM
.1a0786	a5 27		lda $0827	                LDA ARGTYPE1                ; Make sure A is the type
.1a0788	28		plp		done            PLP
.1a0789	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\tokens.s

.0000					TOKEN
>0000					precedence  .byte ?
>0001					length      .byte ?
>0002					name        .word <>?
>0004					eval        .word <>?
>0006					arity       .word <>?
.1a078a					PARSEINT
.1a078a	08		php		            PHP
.1a078b	0b		phd		            PHD
.1a078c	08		php		            PHP
.1a078d	c2 20		rep #$20	            REP #$20
.1a078f	48		pha		            PHA
.1a0790	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0793	5b		tcd		            TCD
.1a0794	68		pla		            PLA
.1a0795	28		plp		            PLP
.1a0796	c2 30		rep #$30	            REP #$30
.1a0798	64 23		stz $0823	            STZ ARGUMENT1       ; Default to Not-a-value
.1a079a	64 25		stz $0825	            STZ ARGUMENT1+2
.1a079c	e2 20		sep #$20	            SEP #$20
.1a079e	64 27		stz $0827	            STZ ARGTYPE1
.1a07a0	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it starts with '$'
.1a07a2	c9 26		cmp #$26	            CMP #'&'
.1a07a4	f0 44		beq $1a07ea	            BEQ check_hex       ; Yes: parse it as a hexadecimal number
.1a07a6					loop
.1a07a6	e2 20		sep #$20	            SEP #$20
.1a07a8	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.1a07aa	20 ad 03	jsr $1a03ad	            JSR ISNUMERAL
.1a07ad	90 76		bcc $1a0825	            BCC done            ; No, we're done parsing
.1a07af	20 2c 04	jsr $1a042c	            JSR MULINT10
.1a07b2	38		sec		            SEC                 ; Convert the ASCII code to a number
.1a07b3	e9 30		sbc #$30	            SBC #'0'
.1a07b5	c2 20		rep #$20	            REP #$20
.1a07b7	29 ff 00	and #$00ff	            AND #$00FF
.1a07ba	18		clc		            CLC
.1a07bb	65 23		adc $0823	            ADC ARGUMENT1
.1a07bd	85 23		sta $0823	            STA ARGUMENT1
.1a07bf	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a07c1	69 00 00	adc #$0000	            ADC #0
.1a07c4	85 25		sta $0825	            STA ARGUMENT1+2
.1a07c6	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a07c9	80 db		bra $1a07a6	            BRA loop            ; And try to process it
.1a07cb					syntaxerr
.1a07cb	08		php		            PHP
.1a07cc	c2 20		rep #$20	            REP #$20
.1a07ce	48		pha		            PHA
.1a07cf	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a07d2	5b		tcd		            TCD
.1a07d3	68		pla		            PLA
.1a07d4	28		plp		            PLP
.1a07d5	e2 20		sep #$20	            SEP #$20
.1a07d7	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a07d9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a07dd	c2 20		rep #$20	            REP #$20
.1a07df	29 ff 00	and #$00ff	            AND #$00FF
.1a07e2	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a07e5	e2 20		sep #$20	            SEP #$20
.1a07e7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a07ea					check_hex
.1a07ea	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a07ed	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.1a07ef	c9 48		cmp #$48	            CMP #'H'            ; Is it 'H'?
.1a07f1	f0 04		beq $1a07f7	            BEQ parse_hex       ; Yes: skip it and parse hex
.1a07f3	c9 68		cmp #$68	            CMP #'h'            ; Is it 'h'?
.1a07f5	d0 d4		bne $1a07cb	            BNE syntaxerr       ; No: throw an error
.1a07f7					parse_hex
.1a07f7	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a07fa					hexloop
.1a07fa	e2 20		sep #$20	            SEP #$20
.1a07fc	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.1a07fe	20 be 03	jsr $1a03be	            JSR ISHEX
.1a0801	90 22		bcc $1a0825	            BCC done            ; No, we're done parsing
.1a0803	20 df 03	jsr $1a03df	            JSR HEX2BIN
.1a0806	c2 20		rep #$20	            REP #$20
.1a0808	06 23		asl $0823	            ASL ARGUMENT1
.1a080a	26 25		rol $0825	            ROL ARGUMENT1+2
.1a080c	06 23		asl $0823	            ASL ARGUMENT1
.1a080e	26 25		rol $0825	            ROL ARGUMENT1+2
.1a0810	06 23		asl $0823	            ASL ARGUMENT1
.1a0812	26 25		rol $0825	            ROL ARGUMENT1+2
.1a0814	06 23		asl $0823	            ASL ARGUMENT1
.1a0816	26 25		rol $0825	            ROL ARGUMENT1+2
.1a0818	29 ff 00	and #$00ff	            AND #$00FF          ; Add binary number to ARGUMENT1
.1a081b	18		clc		            CLC
.1a081c	65 23		adc $0823	            ADC ARGUMENT1
.1a081e	85 23		sta $0823	            STA ARGUMENT1
.1a0820	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a0823	80 d5		bra $1a07fa	            BRA hexloop         ; And try to process it
.1a0825	2b		pld		done        PLD
.1a0826	28		plp		            PLP
.1a0827	60		rts		            RTS
.1a0828					PREVCHAR
.1a0828	08		php		            PHP
.1a0829	c2 30		rep #$30	            REP #$30
.1a082b	a5 04		lda $0804	            LDA BIPPREV
.1a082d	f0 1c		beq $1a084b	            BEQ ret_false
.1a082f	38		sec		            SEC
.1a0830	a5 04		lda $0804	            LDA BIPPREV
.1a0832	e5 1a		sbc $081a	            SBC CURLINE
.1a0834	a8		tay		            TAY
.1a0835	e2 20		sep #$20	            SEP #$20
.1a0837	b7 1a		lda [$081a],y	loop        LDA [CURLINE],Y
.1a0839	f0 10		beq $1a084b	            BEQ ret_false
.1a083b	c9 20		cmp #$20	            CMP #CHAR_SP
.1a083d	f0 06		beq $1a0845	            BEQ go_back
.1a083f	c9 09		cmp #$09	            CMP #CHAR_TAB
.1a0841	f0 02		beq $1a0845	            BEQ go_back
.1a0843	28		plp		            PLP
.1a0844	60		rts		            RTS
.1a0845	88		dey		go_back     DEY
.1a0846	c0 ff ff	cpy #$ffff	            CPY #$FFFF
.1a0849	d0 ec		bne $1a0837	            BNE loop
.1a084b					ret_false
.1a084b	a9 00		lda #$00	            LDA #0
.1a084d	60		rts		            RTS
.1a084e					TOKENIZE
.1a084e	08		php		            PHP
.1a084f	0b		phd		            PHD
.1a0850	08		php		            PHP
.1a0851	c2 20		rep #$20	            REP #$20
.1a0853	48		pha		            PHA
.1a0854	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0857	5b		tcd		            TCD
.1a0858	68		pla		            PLA
.1a0859	28		plp		            PLP
.1a085a	c2 30		rep #$30	            REP #$30
.1a085c	a5 1a		lda $081a	            LDA CURLINE
.1a085e	85 00		sta $0800	            STA BIP
.1a0860	e2 20		sep #$20	            SEP #$20
.1a0862	a5 1c		lda $081c	            LDA CURLINE+2
.1a0864	85 02		sta $0802	            STA BIP+2
.1a0866	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a0869	a7 00		lda [$0800]	            LDA [BIP]               ; Do we have a numeral?
.1a086b	20 ad 03	jsr $1a03ad	            JSR ISNUMERAL
.1a086e	90 0c		bcc $1a087c	            BCC mv_curline          ; No: adjust CURLINE and tokenize
.1a0870	20 8a 07	jsr $1a078a	            JSR PARSEINT
.1a0873	c2 20		rep #$20	            REP #$20
.1a0875	a5 23		lda $0823	            LDA ARGUMENT1
.1a0877	85 d7		sta $08d7	            STA LINENUM
.1a0879	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a087c					mv_curline
.1a087c	c2 20		rep #$20	            REP #$20
.1a087e	a5 00		lda $0800	            LDA BIP
.1a0880	85 1a		sta $081a	            STA CURLINE
.1a0882	e2 20		sep #$20	            SEP #$20
.1a0884	a5 02		lda $0802	            LDA BIP+2
.1a0886	85 1c		sta $081c	            STA CURLINE+2
.1a0888	20 9c 08	jsr $1a089c	            JSR FINDREM
.1a088b	e2 20		sep #$20	            SEP #$20
.1a088d					loop
.1a088d	20 0d 09	jsr $1a090d	            JSR TKFINDTOKEN
.1a0890	c9 00		cmp #$00	            CMP #0                  ; Did we find a token?
.1a0892	f0 05		beq $1a0899	            BEQ done                ; No: return
.1a0894	20 bb 0a	jsr $1a0abb	            JSR TKWRITE
.1a0897	80 f4		bra $1a088d	            BRA loop                ; And try again
.1a0899	2b		pld		done        PLD
.1a089a	28		plp		            PLP
.1a089b	60		rts		            RTS
.1a089c					FINDREM
.1a089c	08		php		            PHP
.1a089d	c2 20		rep #$20	            REP #$20
.1a089f	a5 1a		lda $081a	            LDA CURLINE             ; Point BIP to the beginning of the line
.1a08a1	85 00		sta $0800	            STA BIP
.1a08a3	a5 1c		lda $081c	            LDA CURLINE+2
.1a08a5	85 02		sta $0802	            STA BIP+2
.1a08a7	a2 00 00	ldx #$0000	            LDX #0                  ; X will be a flag that we're at the beginning
.1a08aa	e2 20		sep #$20	            SEP #$20
.1a08ac	a0 00 00	ldy #$0000	loop        LDY #0
.1a08af	e0 00 00	cpx #$0000	            CPX #0                  ; If we are at the first space on the line
.1a08b2	f0 0d		beq $1a08c1	            BEQ skip_delim          ; ... skip looking for a delimiter
.1a08b4	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a08b6	f0 53		beq $1a090b	            BEQ done                ; Is it null? Then we're done
.1a08b8	c9 3a		cmp #$3a	            CMP #':'                ; Is it ":"
.1a08ba	f0 04		beq $1a08c0	            BEQ found_delim         ; Yes: we might have a REM... look for E
.1a08bc	c9 20		cmp #$20	            CMP #CHAR_SP
.1a08be	d0 33		bne $1a08f3	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a08c0	c8		iny		found_delim INY
.1a08c1	b7 00		lda [$0800],y	skip_delim  LDA [BIP],Y             ; Get the first character
.1a08c3	f0 46		beq $1a090b	            BEQ done                ; Is it null? Then we're done
.1a08c5	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.1a08c7	f0 10		beq $1a08d9	            BEQ found_R             ; Yes: we might have a REM... look for E
.1a08c9	c9 72		cmp #$72	            CMP #'r'
.1a08cb	d0 26		bne $1a08f3	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a08cd	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a08cf	f0 3a		beq $1a090b	            BEQ done                ; Is it null? Then we're done
.1a08d1	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.1a08d3	f0 04		beq $1a08d9	            BEQ found_R             ; Yes: we might have a REM... look for E
.1a08d5	c9 72		cmp #$72	            CMP #'r'
.1a08d7	d0 1a		bne $1a08f3	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a08d9	c8		iny		found_R     INY
.1a08da	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a08dc	f0 2d		beq $1a090b	            BEQ done                ; Is it null? Then we're done
.1a08de	c9 45		cmp #$45	            CMP #'E'                ; Is it "E"
.1a08e0	f0 04		beq $1a08e6	            BEQ found_E             ; Yes: we might have a REM... look for M
.1a08e2	c9 65		cmp #$65	            CMP #'e'
.1a08e4	d0 0d		bne $1a08f3	            BNE next_pos            ; No: we didn't find REM here... check next position
.1a08e6	c8		iny		found_E     INY
.1a08e7	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.1a08e9	f0 20		beq $1a090b	            BEQ done                ; Is it null? Then we're done
.1a08eb	c9 4d		cmp #$4d	            CMP #'M'                ; Is it "E"
.1a08ed	f0 0a		beq $1a08f9	            BEQ found_REM           ; Yes: we might have a REM... look for M
.1a08ef	c9 6d		cmp #$6d	            CMP #'m'
.1a08f1	f0 06		beq $1a08f9	            BEQ found_REM
.1a08f3	e8		inx		next_pos    INX                     ; Indicate we're no longer at the first position
.1a08f4	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a08f7	80 b3		bra $1a08ac	            BRA loop
.1a08f9	a7 00		lda [$0800]	found_REM   LDA [BIP]               ; Get the current character
.1a08fb	c9 3a		cmp #$3a	            CMP #':'                ; Is it the delimiter?
.1a08fd	d0 03		bne $1a0902	            BNE ret_REM             ; No: go ahead and return REM at that location
.1a08ff	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a0902	a9 03		lda #$03	ret_REM     LDA #3
.1a0904	85 1e		sta $081e	            STA CURTOKLEN           ; Set the size
.1a0906	a9 91		lda #$91	            LDA #TOK_REM            ; And the token to write
.1a0908	20 bb 0a	jsr $1a0abb	            JSR TKWRITE
.1a090b	28		plp		done        PLP
.1a090c	60		rts		            RTS
.1a090d					TKFINDTOKEN
.1a090d	08		php		            PHP
.1a090e	0b		phd		            PHD
.1a090f	08		php		            PHP
.1a0910	c2 20		rep #$20	            REP #$20
.1a0912	48		pha		            PHA
.1a0913	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0916	5b		tcd		            TCD
.1a0917	68		pla		            PLA
.1a0918	28		plp		            PLP
.1a0919	e2 20		sep #$20	            SEP #$20
.1a091b	a9 7f		lda #$7f	            LDA #$7F                ; Start off looking for any size token
.1a091d	85 1e		sta $081e	            STA CURTOKLEN
.1a091f					next_size
.1a091f	c2 10		rep #$10	            REP #$10
.1a0921	20 70 0a	jsr $1a0a70	            JSR TKNEXTBIG
.1a0924	a5 1e		lda $081e	            LDA CURTOKLEN           ; Are there any keywords left?
.1a0926	d0 03		bne $1a092b	            BNE else
.1a0928	4c b0 09	jmp $1a09b0	            JMP done                ; No: return to caller
.1a092b					else
.1a092b	c2 20		rep #$20	            REP #$20
.1a092d	a5 1a		lda $081a	            LDA CURLINE
.1a092f	85 00		sta $0800	            STA BIP
.1a0931	e2 20		sep #$20	            SEP #$20
.1a0933	a5 1c		lda $081c	            LDA CURLINE+2
.1a0935	85 02		sta $0802	            STA BIP+2
.1a0937	c2 20		rep #$20	            REP #$20
.1a0939	64 04		stz $0804	            STZ BIPPREV             ; Clear BIPPREV (point to the previous character)
.1a093b	64 06		stz $0806	            STZ BIPPREV+2
.1a093d					check_len
.1a093d	e2 30		sep #$30	            SEP #$30
.1a093f	a0 00		ldy #$00	            LDY #0
.1a0941	b7 00		lda [$0800],y	nul_scan    LDA [BIP],Y
.1a0943	f0 da		beq $1a091f	            BEQ next_size
.1a0945	c9 91		cmp #$91	            CMP #TOK_REM            ; Tokenization stops at REMarks too
.1a0947	f0 d6		beq $1a091f	            BEQ next_size
.1a0949	c8		iny		            INY
.1a094a	c4 1e		cpy $081e	            CPY CURTOKLEN
.1a094c	90 f3		bcc $1a0941	            BCC nul_scan
.1a094e	c2 10		rep #$10	            REP #$10
.1a0950	a7 00		lda [$0800]	            LDA [BIP]               ; Check the current character
.1a0952	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.1a0954	d0 05		bne $1a095b	            BNE chk_keyword         ; No: check to see if we are at the start of a possible keyword
.1a0956	20 d2 09	jsr $1a09d2	            JSR SKIPQUOTED
.1a0959	80 28		bra $1a0983	            BRA go_next             ; And move on to the next character
.1a095b	a5 1e		lda $081e	chk_keyword LDA CURTOKLEN           ; If the token length is <=2
.1a095d	c9 03		cmp #$03	            CMP #3
.1a095f	90 19		bcc $1a097a	            BLT try_match           ; ... we don't need a delimiter, go ahead and convert it
.1a0961	c2 20		rep #$20	            REP #$20
.1a0963	a5 00		lda $0800	            LDA BIP                 ; Check to see if we're at the start of the line
.1a0965	c5 1a		cmp $081a	            CMP CURLINE
.1a0967	d0 08		bne $1a0971	            BNE chk_delim           ; No: we need to check for a delimiters
.1a0969	e2 20		sep #$20	            SEP #$20
.1a096b	a5 02		lda $0802	            LDA BIP+2
.1a096d	c5 1c		cmp $081c	            CMP CURLINE+2
.1a096f	f0 09		beq $1a097a	            BEQ try_match           ; Yes: this can be a keyword
.1a0971					chk_delim
.1a0971	e2 20		sep #$20	            SEP #$20
.1a0973	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.1a0975	20 ba 4e	jsr $1a4eba	            JSR ISVARCHAR
.1a0978	b0 09		bcs $1a0983	            BCS go_next             ; Yes: we can't start a keyword here
.1a097a					try_match
.1a097a	e2 20		sep #$20	            SEP #$20
.1a097c	20 e2 09	jsr $1a09e2	            JSR TKMATCH
.1a097f	c9 00		cmp #$00	            CMP #0                  ; Did we get one?
.1a0981	d0 11		bne $1a0994	            BNE found               ; Yes: return it
.1a0983					go_next
.1a0983	c2 20		rep #$20	            REP #$20
.1a0985	a5 00		lda $0800	            LDA BIP                 ; Update BIPPREV as the point to the previous character
.1a0987	85 04		sta $0804	            STA BIPPREV
.1a0989	e2 20		sep #$20	            SEP #$20
.1a098b	a5 02		lda $0802	            LDA BIP+2
.1a098d	85 06		sta $0806	            STA BIPPREV+2
.1a098f	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a0992	80 a9		bra $1a093d	            BRA check_len           ; And try there
.1a0994					found
.1a0994	c9 81		cmp #$81	            CMP #TOK_MINUS          ; Found a token... is it minus?
.1a0996	d0 18		bne $1a09b0	            BNE done                ; Nope: go ahead and return it
.1a0998	20 28 08	jsr $1a0828	            JSR PREVCHAR
.1a099b	c9 00		cmp #$00	            CMP #0                  ; Did we get anything?
.1a099d	f0 14		beq $1a09b3	            BEQ syntax              ; No: line cannot start with minus... throw error
.1a099f	89 80		bit #$80	            BIT #$80                ; Is it a token?
.1a09a1	10 0b		bpl $1a09ae	            BPL binaryminus         ; No: leave token unchanged
.1a09a3	20 5c 0b	jsr $1a0b5c	            JSR TOKTYPE
.1a09a6	c9 30		cmp #$30	            CMP #TOK_TY_FUNC        ; Is it a function?
.1a09a8	f0 04		beq $1a09ae	            BEQ binaryminus         ; Yes: then this should be a binary minus operator
.1a09aa	a9 af		lda #$af	            LDA #TOK_NEGATIVE       ; Otherwise: this should be a unary minus (negation)
.1a09ac	80 02		bra $1a09b0	            BRA done
.1a09ae	a9 81		lda #$81	binaryminus LDA #TOK_MINUS          ; It's data... so token should be for binary minus
.1a09b0					done
.1a09b0	2b		pld		            PLD
.1a09b1	28		plp		            PLP
.1a09b2	60		rts		            RTS
.1a09b3					syntax
.1a09b3	08		php		            PHP
.1a09b4	c2 20		rep #$20	            REP #$20
.1a09b6	48		pha		            PHA
.1a09b7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a09ba	5b		tcd		            TCD
.1a09bb	68		pla		            PLA
.1a09bc	28		plp		            PLP
.1a09bd	e2 20		sep #$20	            SEP #$20
.1a09bf	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a09c1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a09c5	c2 20		rep #$20	            REP #$20
.1a09c7	29 ff 00	and #$00ff	            AND #$00FF
.1a09ca	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a09cd	e2 20		sep #$20	            SEP #$20
.1a09cf	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a09d2					SKIPQUOTED
.1a09d2	08		php		            PHP
.1a09d3	e2 20		sep #$20	            SEP #$20
.1a09d5					loop
.1a09d5	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a09d8	a7 00		lda [$0800]	            LDA [BIP]
.1a09da	f0 04		beq $1a09e0	            BEQ done                ; If EOL, just return
.1a09dc	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.1a09de	d0 f5		bne $1a09d5	            BNE loop                ; No: keep skipping
.1a09e0	28		plp		done        PLP
.1a09e1	60		rts		            RTS
.1a09e2					TKMATCH
.1a09e2	da		phx		            PHX
.1a09e3	5a		phy		            PHY
.1a09e4	08		php		            PHP
.1a09e5	0b		phd		            PHD
.1a09e6	08		php		            PHP
.1a09e7	c2 20		rep #$20	            REP #$20
.1a09e9	48		pha		            PHA
.1a09ea	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a09ed	5b		tcd		            TCD
.1a09ee	68		pla		            PLA
.1a09ef	28		plp		            PLP
.1a09f0	c2 20		rep #$20	            REP #$20
.1a09f2	a5 04		lda $0804	            LDA BIPPREV
.1a09f4	d0 0a		bne $1a0a00	            BNE check_prev
.1a09f6	e2 20		sep #$20	            SEP #$20
.1a09f8	a5 04		lda $0804	            LDA BIPPREV
.1a09fa	d0 04		bne $1a0a00	            BNE check_prev
.1a09fc	a9 00		lda #$00	            LDA #0
.1a09fe	80 0a		bra $1a0a0a	            BRA save_delim
.1a0a00					check_prev
.1a0a00	e2 20		sep #$20	            SEP #$20
.1a0a02	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.1a0a04	20 ba 4e	jsr $1a4eba	            JSR ISVARCHAR
.1a0a07	a9 00		lda #$00	            LDA #0
.1a0a09	2a		rol a		            ROL A
.1a0a0a	85 28		sta $0828	save_delim  STA SIGN1               ; SIGN1 := 1 if it is a variable name character
.1a0a0c	c2 30		rep #$30	            REP #$30
.1a0a0e	a9 b0 0b	lda #$0bb0	            LDA #<>TOKENS           ; Set INDEX to point to the first token record
.1a0a11	85 08		sta $0808	            STA INDEX
.1a0a13	e2 20		sep #$20	            SEP #$20
.1a0a15	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0a17	85 0a		sta $080a	            STA INDEX+2
.1a0a19	a2 80 00	ldx #$0080	            LDX #$80                ; Set the initial token ID
.1a0a1c					token_loop
.1a0a1c	e2 20		sep #$20	            SEP #$20
.1a0a1e	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.1a0a21	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the current token
.1a0a23	f0 31		beq $1a0a56	            BEQ no_match            ; Is it 0? We're out of tokens... no match found
.1a0a25	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it the same as the size of the window?
.1a0a27	d0 32		bne $1a0a5b	            BNE next_token          ; No: try the next token
.1a0a29	c2 30		rep #$30	            REP #$30
.1a0a2b	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.1a0a2e	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the pointer to the token's name
.1a0a30	85 0c		sta $080c	            STA SCRATCH             ; Set SCRATCH to point to the token's name
.1a0a32	e2 20		sep #$20	            SEP #$20
.1a0a34	a9 1a		lda #$1a	            LDA #`DATA_BLOCK
.1a0a36	85 0e		sta $080e	            STA SCRATCH+2
.1a0a38	a5 28		lda $0828	            LDA SIGN1               ; Is previous character a variable name character?
.1a0a3a	f0 07		beq $1a0a43	            BEQ cmp_keyword         ; No: we can check for this token
.1a0a3c	a7 0c		lda [$080c]	            LDA [SCRATCH]           ; Get the token's first character
.1a0a3e	20 ba 4e	jsr $1a4eba	            JSR ISVARCHAR
.1a0a41	b0 18		bcs $1a0a5b	            BCS next_token          ; Yes: skip this token
.1a0a43					cmp_keyword
.1a0a43	e2 10		sep #$10	            SEP #$10
.1a0a45	a0 00		ldy #$00	            LDY #0
.1a0a47	b7 00		lda [$0800],y	cmp_loop    LDA [BIP],Y             ; Get the character in the window
.1a0a49	20 08 04	jsr $1a0408	            JSR TOUPPERA
.1a0a4c	d7 0c		cmp [$080c],y	            CMP [SCRATCH],Y         ; Compare to the character in the token
.1a0a4e	d0 0b		bne $1a0a5b	            BNE next_token          ; If they don't match, try the next token
.1a0a50	c8		iny		            INY                     ; Move to the next character in the window
.1a0a51	c4 1e		cpy $081e	            CPY CURTOKLEN           ; Have we checked the whole window?
.1a0a53	90 f2		bcc $1a0a47	            BCC cmp_loop            ; No: check this next character
.1a0a55	8a		txa		            TXA                     ; Move the token ID to A
.1a0a56	2b		pld		no_match    PLD
.1a0a57	28		plp		            PLP
.1a0a58	7a		ply		            PLY
.1a0a59	fa		plx		            PLX
.1a0a5a	60		rts		            RTS
.1a0a5b					next_token
.1a0a5b	c2 30		rep #$30	            REP #$30
.1a0a5d	18		clc		            CLC
.1a0a5e	a5 08		lda $0808	            LDA INDEX
.1a0a60	69 08 00	adc #$0008	            ADC #size(TOKEN)
.1a0a63	85 08		sta $0808	            STA INDEX
.1a0a65	e2 20		sep #$20	            SEP #$20
.1a0a67	a5 0a		lda $080a	            LDA INDEX+2
.1a0a69	69 00		adc #$00	            ADC #0
.1a0a6b	85 0a		sta $080a	            STA INDEX+2
.1a0a6d	e8		inx		            INX                     ; Increment the token ID
.1a0a6e	80 ac		bra $1a0a1c	            BRA token_loop          ; And check that token
.1a0a70					TKNEXTBIG
.1a0a70	08		php		            PHP
.1a0a71	0b		phd		            PHD
.1a0a72	8b		phb		            PHB
.1a0a73	08		php		            PHP
.1a0a74	c2 20		rep #$20	            REP #$20
.1a0a76	48		pha		            PHA
.1a0a77	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0a7a	5b		tcd		            TCD
.1a0a7b	68		pla		            PLA
.1a0a7c	28		plp		            PLP
.1a0a7d	c2 30		rep #$30	            REP #$30
.1a0a7f	a9 b0 0b	lda #$0bb0	            LDA #<>TOKENS
.1a0a82	85 08		sta $0808	            STA INDEX
.1a0a84	a9 1a 00	lda #$001a	            LDA #`TOKENS
.1a0a87	85 0a		sta $080a	            STA INDEX+2
.1a0a89	64 0c		stz $080c	            STZ SCRATCH             ; Clear SCRATCH
.1a0a8b					loop
.1a0a8b	e2 20		sep #$20	            SEP #$20
.1a0a8d	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.1a0a90	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the token
.1a0a92	f0 1d		beq $1a0ab1	            BEQ done                ; If length is 0, we're done
.1a0a94	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it >= CURTOKLEN?
.1a0a96	b0 06		bcs $1a0a9e	            BGE skip                ; Yes: skip to the next token
.1a0a98	c5 0c		cmp $080c	            CMP SCRATCH             ; No: is it < SCRATCH?
.1a0a9a	90 02		bcc $1a0a9e	            BLT skip                ; Yes: skip to the next token
.1a0a9c	85 0c		sta $080c	            STA SCRATCH             ; No: it's our new longest token!
.1a0a9e					skip
.1a0a9e	c2 20		rep #$20	            REP #$20
.1a0aa0	18		clc		            CLC
.1a0aa1	a5 08		lda $0808	            LDA INDEX
.1a0aa3	69 08 00	adc #$0008	            ADC #size(TOKEN)
.1a0aa6	85 08		sta $0808	            STA INDEX
.1a0aa8	a5 0a		lda $080a	            LDA INDEX+2
.1a0aaa	69 00 00	adc #$0000	            ADC #0
.1a0aad	85 0a		sta $080a	            STA INDEX+2
.1a0aaf	80 da		bra $1a0a8b	            BRA loop                ; And go around for another pass
.1a0ab1					done
.1a0ab1	e2 20		sep #$20	            SEP #$20
.1a0ab3	a5 0c		lda $080c	            LDA SCRATCH
.1a0ab5	85 1e		sta $081e	            STA CURTOKLEN
.1a0ab7	ab		plb		            PLB
.1a0ab8	2b		pld		            PLD
.1a0ab9	28		plp		            PLP
.1a0aba	60		rts		            RTS
.1a0abb					TKWRITE
.1a0abb	08		php		            PHP
.1a0abc	0b		phd		            PHD
.1a0abd	08		php		            PHP
.1a0abe	c2 20		rep #$20	            REP #$20
.1a0ac0	48		pha		            PHA
.1a0ac1	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0ac4	5b		tcd		            TCD
.1a0ac5	68		pla		            PLA
.1a0ac6	28		plp		            PLP
.1a0ac7	e2 20		sep #$20	            SEP #$20
.1a0ac9	87 00		sta [$0800]	            STA [BIP]               ; Write the token to the line
.1a0acb	c2 20		rep #$20	            REP #$20
.1a0acd	18		clc		            CLC
.1a0ace	a5 00		lda $0800	            LDA BIP
.1a0ad0	69 01 00	adc #$0001	            ADC #1
.1a0ad3	85 08		sta $0808	            STA INDEX
.1a0ad5	a5 02		lda $0802	            LDA BIP+2
.1a0ad7	69 00 00	adc #$0000	            ADC #0
.1a0ada	85 0a		sta $080a	            STA INDEX+2
.1a0adc	e2 10		sep #$10	            SEP #$10
.1a0ade	a4 1e		ldy $081e	            LDY CURTOKLEN           ; Y will be the number of characters to move down
.1a0ae0	88		dey		            DEY
.1a0ae1					copy_down
.1a0ae1	e2 20		sep #$20	            SEP #$20
.1a0ae3	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the byte to move down
.1a0ae5	87 08		sta [$0808]	            STA [INDEX]             ; Move it down
.1a0ae7	f0 13		beq $1a0afc	            BEQ done                ; We've reached the end of the line
.1a0ae9	c2 20		rep #$20	            REP #$20
.1a0aeb	18		clc		            CLC
.1a0aec	a5 08		lda $0808	            LDA INDEX
.1a0aee	69 01 00	adc #$0001	            ADC #1
.1a0af1	85 08		sta $0808	            STA INDEX
.1a0af3	a5 0a		lda $080a	            LDA INDEX+2
.1a0af5	69 00 00	adc #$0000	            ADC #0
.1a0af8	85 0a		sta $080a	            STA INDEX+2
.1a0afa	80 e5		bra $1a0ae1	            BRA copy_down
.1a0afc	2b		pld		done        PLD
.1a0afd	28		plp		            PLP
.1a0afe	60		rts		            RTS
.1a0aff					GETTOKREC
.1a0aff	08		php		            PHP
.1a0b00	c2 30		rep #$30	            REP #$30
.1a0b02	29 7f 00	and #$007f	            AND #$007F
.1a0b05	0a		asl a		            ASL A
.1a0b06	0a		asl a		            ASL A
.1a0b07	0a		asl a		            ASL A
.1a0b08	18		clc		            CLC
.1a0b09	69 b0 0b	adc #$0bb0	            ADC #<>TOKENS
.1a0b0c	aa		tax		            TAX                         ; X is now the data bank relative address of the token record
.1a0b0d	28		plp		            PLP
.1a0b0e	60		rts		            RTS
.1a0b0f					TOKPRECED
.1a0b0f	08		php		            PHP
.1a0b10	8b		phb		            PHB
.1a0b11	0b		phd		            PHD
.1a0b12	08		php		            PHP
.1a0b13	c2 20		rep #$20	            REP #$20
.1a0b15	48		pha		            PHA
.1a0b16	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0b19	5b		tcd		            TCD
.1a0b1a	68		pla		            PLA
.1a0b1b	28		plp		            PLP
.1a0b1c	08		php		            PHP
.1a0b1d	e2 20		sep #$20	            SEP #$20
.1a0b1f	48		pha		            PHA
.1a0b20	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0b22	48		pha		            PHA
.1a0b23	ab		plb		            PLB
.1a0b24	68		pla		            PLA
.1a0b25	28		plp		            PLP
.1a0b26	e2 20		sep #$20	            SEP #$20
.1a0b28	c2 10		rep #$10	            REP #$10
.1a0b2a	20 ff 0a	jsr $1a0aff	            JSR GETTOKREC
.1a0b2d	bd 00 00	lda $1a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.1a0b30	c2 20		rep #$20	            REP #$20
.1a0b32	29 0f 00	and #$000f	            AND #$000F                  ; Mask off the type code
.1a0b35	2b		pld		            PLD
.1a0b36	ab		plb		            PLB
.1a0b37	28		plp		            PLP
.1a0b38	60		rts		            RTS
.1a0b39					TOKEVAL
.1a0b39	08		php		            PHP
.1a0b3a	8b		phb		            PHB
.1a0b3b	0b		phd		            PHD
.1a0b3c	08		php		            PHP
.1a0b3d	c2 20		rep #$20	            REP #$20
.1a0b3f	48		pha		            PHA
.1a0b40	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0b43	5b		tcd		            TCD
.1a0b44	68		pla		            PLA
.1a0b45	28		plp		            PLP
.1a0b46	08		php		            PHP
.1a0b47	e2 20		sep #$20	            SEP #$20
.1a0b49	48		pha		            PHA
.1a0b4a	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0b4c	48		pha		            PHA
.1a0b4d	ab		plb		            PLB
.1a0b4e	68		pla		            PLA
.1a0b4f	28		plp		            PLP
.1a0b50	c2 30		rep #$30	            REP #$30
.1a0b52	20 ff 0a	jsr $1a0aff	            JSR GETTOKREC
.1a0b55	bd 04 00	lda $1a0004,x	            LDA #TOKEN.eval,B,X         ; Get the address of the evaluation function
.1a0b58	2b		pld		            PLD
.1a0b59	ab		plb		            PLB
.1a0b5a	28		plp		            PLP
.1a0b5b	60		rts		            RTS
.1a0b5c					TOKTYPE
.1a0b5c	08		php		            PHP
.1a0b5d	8b		phb		            PHB
.1a0b5e	0b		phd		            PHD
.1a0b5f	08		php		            PHP
.1a0b60	c2 20		rep #$20	            REP #$20
.1a0b62	48		pha		            PHA
.1a0b63	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0b66	5b		tcd		            TCD
.1a0b67	68		pla		            PLA
.1a0b68	28		plp		            PLP
.1a0b69	08		php		            PHP
.1a0b6a	e2 20		sep #$20	            SEP #$20
.1a0b6c	48		pha		            PHA
.1a0b6d	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0b6f	48		pha		            PHA
.1a0b70	ab		plb		            PLB
.1a0b71	68		pla		            PLA
.1a0b72	28		plp		            PLP
.1a0b73	e2 20		sep #$20	            SEP #$20
.1a0b75	c2 10		rep #$10	            REP #$10
.1a0b77	20 ff 0a	jsr $1a0aff	            JSR GETTOKREC
.1a0b7a	bd 00 00	lda $1a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.1a0b7d	c2 20		rep #$20	            REP #$20
.1a0b7f	29 f0 00	and #$00f0	            AND #$00F0                  ; Mask off the type code
.1a0b82	2b		pld		            PLD
.1a0b83	ab		plb		            PLB
.1a0b84	28		plp		            PLP
.1a0b85	60		rts		            RTS
.1a0b86					TOKARITY
.1a0b86	08		php		            PHP
.1a0b87	8b		phb		            PHB
.1a0b88	0b		phd		            PHD
.1a0b89	08		php		            PHP
.1a0b8a	c2 20		rep #$20	            REP #$20
.1a0b8c	48		pha		            PHA
.1a0b8d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0b90	5b		tcd		            TCD
.1a0b91	68		pla		            PLA
.1a0b92	28		plp		            PLP
.1a0b93	08		php		            PHP
.1a0b94	e2 20		sep #$20	            SEP #$20
.1a0b96	48		pha		            PHA
.1a0b97	a9 1a		lda #$1a	            LDA #`TOKENS
.1a0b99	48		pha		            PHA
.1a0b9a	ab		plb		            PLB
.1a0b9b	68		pla		            PLA
.1a0b9c	28		plp		            PLP
.1a0b9d	e2 20		sep #$20	            SEP #$20
.1a0b9f	c2 10		rep #$10	            REP #$10
.1a0ba1	20 ff 0a	jsr $1a0aff	            JSR GETTOKREC
.1a0ba4	bd 06 00	lda $1a0006,x	            LDA #TOKEN.arity,B,X        ; Get the arity
.1a0ba7	c2 20		rep #$20	            REP #$20
.1a0ba9	29 ff 00	and #$00ff	            AND #$00FF
.1a0bac	2b		pld		            PLD
.1a0bad	ab		plb		            PLB
.1a0bae	28		plp		            PLP
.1a0baf	60		rts		            RTS
=$00					TOK_EOL = $00
=$01					TOK_FUNC_OPEN = $01     ; A pseudo-token to push to the operator stack to mark
=$00					TOK_TY_OP = $00         ; The token is an operator
=$10					TOK_TY_CMD = $10        ; The token is a command (e.g. RUN, LIST, etc.)
=$20					TOK_TY_STMNT = $20      ; The token is a statement (e.g. INPUT, PRINT, DIM, etc.)
=$30					TOK_TY_FUNC = $30       ; The token is a function (e.g. SIN, COS, TAB, etc.)
=$40					TOK_TY_PUNCT = $40      ; The token is a punctuation mark (e.g. "(", ")")
=$50					TOK_TY_BYWRD = $50      ; The token is a by-word (e.g. STEP, TO, WEND, etc.)
.1a0bb0					TOKENS
=$80					TOK_PLUS = $80
>1ad010	2b 00				TOKEN_TEXT  .null "+"
>1a0bb0	03				precedence  .byte TOK_TY_OP | 3
>1a0bb1	01				length      .byte len("+")
>1a0bb2	10 d0				name        .word <>TOKEN_TEXT
>1a0bb4	1d 26				eval        .word <>OP_PLUS
>1a0bb6	02 00				arity       .word <>2
=$81					TOK_MINUS = $81
>1ad012	2d 00				TOKEN_TEXT  .null "-"
>1a0bb8	03				precedence  .byte TOK_TY_OP | 3
>1a0bb9	01				length      .byte len("-")
>1a0bba	12 d0				name        .word <>TOKEN_TEXT
>1a0bbc	5d 26				eval        .word <>OP_MINUS
>1a0bbe	02 00				arity       .word <>2
=$82					TOK_MULT = $82
>1ad014	2a 00				TOKEN_TEXT  .null "*"
>1a0bc0	02				precedence  .byte TOK_TY_OP | 2
>1a0bc1	01				length      .byte len("*")
>1a0bc2	14 d0				name        .word <>TOKEN_TEXT
>1a0bc4	94 26				eval        .word <>OP_MULTIPLY
>1a0bc6	02 00				arity       .word <>2
=$83					TOK_DIVIDE = $83
>1ad016	2f 00				TOKEN_TEXT  .null "/"
>1a0bc8	02				precedence  .byte TOK_TY_OP | 2
>1a0bc9	01				length      .byte len("/")
>1a0bca	16 d0				name        .word <>TOKEN_TEXT
>1a0bcc	cb 26				eval        .word <>OP_DIVIDE
>1a0bce	02 00				arity       .word <>2
=$84					TOK_MOD = $84
>1ad018	4d 4f 44 00			TOKEN_TEXT  .null "MOD"
>1a0bd0	02				precedence  .byte TOK_TY_OP | 2
>1a0bd1	03				length      .byte len("MOD")
>1a0bd2	18 d0				name        .word <>TOKEN_TEXT
>1a0bd4	d5 26				eval        .word <>OP_MOD
>1a0bd6	02 00				arity       .word <>2
>1ad01c	5e 00				TOKEN_TEXT  .null "^"
>1a0bd8	00				precedence  .byte TOK_TY_OP | 0
>1a0bd9	01				length      .byte len("^")
>1a0bda	1c d0				name        .word <>TOKEN_TEXT
>1a0bdc	e8 26				eval        .word <>OP_POW
>1a0bde	02 00				arity       .word <>2
=$86					TOK_LE = $86
>1ad01e	3c 3d 00			TOKEN_TEXT  .null "<="
>1a0be0	04				precedence  .byte TOK_TY_OP | 4
>1a0be1	02				length      .byte len("<=")
>1a0be2	1e d0				name        .word <>TOKEN_TEXT
>1a0be4	a6 28				eval        .word <>OP_LTE
>1a0be6	02 00				arity       .word <>2
=$87					TOK_GE = $87
>1ad021	3e 3d 00			TOKEN_TEXT  .null ">="
>1a0be8	04				precedence  .byte TOK_TY_OP | 4
>1a0be9	02				length      .byte len(">=")
>1a0bea	21 d0				name        .word <>TOKEN_TEXT
>1a0bec	66 28				eval        .word <>OP_GTE
>1a0bee	02 00				arity       .word <>2
=$88					TOK_NE = $88
>1ad024	3c 3e 00			TOKEN_TEXT  .null "<>"
>1a0bf0	04				precedence  .byte TOK_TY_OP | 4
>1a0bf1	02				length      .byte len("<>")
>1a0bf2	24 d0				name        .word <>TOKEN_TEXT
>1a0bf4	26 28				eval        .word <>OP_NE
>1a0bf6	02 00				arity       .word <>2
>1ad027	3c 00				TOKEN_TEXT  .null "<"
>1a0bf8	04				precedence  .byte TOK_TY_OP | 4
>1a0bf9	01				length      .byte len("<")
>1a0bfa	27 d0				name        .word <>TOKEN_TEXT
>1a0bfc	66 27				eval        .word <>OP_LT
>1a0bfe	02 00				arity       .word <>2
=$8a					TOK_EQ = $8A
>1ad029	3d 00				TOKEN_TEXT  .null "="
>1a0c00	04				precedence  .byte TOK_TY_OP | 4
>1a0c01	01				length      .byte len("=")
>1a0c02	29 d0				name        .word <>TOKEN_TEXT
>1a0c04	e6 27				eval        .word <>OP_EQ
>1a0c06	02 00				arity       .word <>2
>1ad02b	3e 00				TOKEN_TEXT  .null ">"
>1a0c08	04				precedence  .byte TOK_TY_OP | 4
>1a0c09	01				length      .byte len(">")
>1a0c0a	2b d0				name        .word <>TOKEN_TEXT
>1a0c0c	a6 27				eval        .word <>OP_GT
>1a0c0e	02 00				arity       .word <>2
>1ad02d	4e 4f 54 00			TOKEN_TEXT  .null "NOT"
>1a0c10	05				precedence  .byte TOK_TY_OP | 5
>1a0c11	03				length      .byte len("NOT")
>1a0c12	2d d0				name        .word <>TOKEN_TEXT
>1a0c14	50 27				eval        .word <>OP_NOT
>1a0c16	01 00				arity       .word <>1
>1ad031	41 4e 44 00			TOKEN_TEXT  .null "AND"
>1a0c18	06				precedence  .byte TOK_TY_OP | 6
>1a0c19	03				length      .byte len("AND")
>1a0c1a	31 d0				name        .word <>TOKEN_TEXT
>1a0c1c	22 27				eval        .word <>OP_AND
>1a0c1e	02 00				arity       .word <>2
>1ad035	4f 52 00			TOKEN_TEXT  .null "OR"
>1a0c20	07				precedence  .byte TOK_TY_OP | 7
>1a0c21	02				length      .byte len("OR")
>1a0c22	35 d0				name        .word <>TOKEN_TEXT
>1a0c24	39 27				eval        .word <>OP_OR
>1a0c26	02 00				arity       .word <>2
=$8f					TOK_LPAREN = $8F
>1ad038	28 00				TOKEN_TEXT  .null "("
>1a0c28	ff				precedence  .byte TOK_TY_PUNCT | $FF
>1a0c29	01				length      .byte len("(")
>1a0c2a	38 d0				name        .word <>TOKEN_TEXT
>1a0c2c	00 00				eval        .word <>0
>1a0c2e	00 00				arity       .word <>0
=$90					TOK_RPAREN = $90
>1ad03a	29 00				TOKEN_TEXT  .null ")"
>1a0c30	40				precedence  .byte TOK_TY_PUNCT | 0
>1a0c31	01				length      .byte len(")")
>1a0c32	3a d0				name        .word <>TOKEN_TEXT
>1a0c34	00 00				eval        .word <>0
>1a0c36	00 00				arity       .word <>0
=$91					TOK_REM = $91
>1ad03c	52 45 4d 00			TOKEN_TEXT  .null "REM"
>1a0c38	20				precedence  .byte TOK_TY_STMNT | 0
>1a0c39	03				length      .byte len("REM")
>1a0c3a	3c d0				name        .word <>TOKEN_TEXT
>1a0c3c	66 3f				eval        .word <>S_REM
>1a0c3e	00 00				arity       .word <>0
=$92					TOK_PRINT = $92
>1ad040	50 52 49 4e 54 00		TOKEN_TEXT  .null "PRINT"
>1a0c40	20				precedence  .byte TOK_TY_STMNT | 0
>1a0c41	05				length      .byte len("PRINT")
>1a0c42	40 d0				name        .word <>TOKEN_TEXT
>1a0c44	6b 43				eval        .word <>S_PRINT
>1a0c46	00 00				arity       .word <>0
=$93					TOK_LET = $93
>1ad046	4c 45 54 00			TOKEN_TEXT  .null "LET"
>1a0c48	20				precedence  .byte TOK_TY_STMNT | 0
>1a0c49	03				length      .byte len("LET")
>1a0c4a	46 d0				name        .word <>TOKEN_TEXT
>1a0c4c	b6 42				eval        .word <>S_LET
>1a0c4e	00 00				arity       .word <>0
>1ad04a	47 4f 54 4f 00			TOKEN_TEXT  .null "GOTO"
>1a0c50	20				precedence  .byte TOK_TY_STMNT | 0
>1a0c51	04				length      .byte len("GOTO")
>1a0c52	4a d0				name        .word <>TOKEN_TEXT
>1a0c54	56 42				eval        .word <>S_GOTO
>1a0c56	00 00				arity       .word <>0
=$95					TOK_END = $95
>1ad04f	45 4e 44 00			TOKEN_TEXT  .null "END"
>1a0c58	20				precedence  .byte TOK_TY_STMNT | 0
>1a0c59	03				length      .byte len("END")
>1a0c5a	4f d0				name        .word <>TOKEN_TEXT
>1a0c5c	4d 42				eval        .word <>S_END
>1a0c5e	00 00				arity       .word <>0
>1ad053	49 46 00			TOKEN_TEXT  .null "IF"
>1a0c60	20				precedence  .byte TOK_TY_STMNT | 0
>1a0c61	02				length      .byte len("IF")
>1a0c62	53 d0				name        .word <>TOKEN_TEXT
>1a0c64	e5 41				eval        .word <>S_IF
>1a0c66	00 00				arity       .word <>0
=$97					TOK_THEN = $97
>1ad056	54 48 45 4e 00			TOKEN_TEXT  .null "THEN"
>1a0c68	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0c69	04				length      .byte len("THEN")
>1a0c6a	56 d0				name        .word <>TOKEN_TEXT
>1a0c6c	00 00				eval        .word <>0
>1a0c6e	00 00				arity       .word <>0
>1ad05b	45 4c 53 45 00			TOKEN_TEXT  .null "ELSE"
>1a0c70	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0c71	04				length      .byte len("ELSE")
>1a0c72	5b d0				name        .word <>TOKEN_TEXT
>1a0c74	00 00				eval        .word <>0
>1a0c76	00 00				arity       .word <>0
>1ad060	47 4f 53 55 42 00		TOKEN_TEXT  .null "GOSUB"
>1a0c78	20				precedence  .byte TOK_TY_STMNT | 0
>1a0c79	05				length      .byte len("GOSUB")
>1a0c7a	60 d0				name        .word <>TOKEN_TEXT
>1a0c7c	28 41				eval        .word <>S_GOSUB
>1a0c7e	00 00				arity       .word <>0
>1ad066	52 45 54 55 52 4e 00		TOKEN_TEXT  .null "RETURN"
>1a0c80	20				precedence  .byte TOK_TY_STMNT | 0
>1a0c81	06				length      .byte len("RETURN")
>1a0c82	66 d0				name        .word <>TOKEN_TEXT
>1a0c84	a1 41				eval        .word <>S_RETURN
>1a0c86	00 00				arity       .word <>0
=$9b					TOK_FOR = $9B
>1ad06d	46 4f 52 00			TOKEN_TEXT  .null "FOR"
>1a0c88	20				precedence  .byte TOK_TY_STMNT | 0
>1a0c89	03				length      .byte len("FOR")
>1a0c8a	6d d0				name        .word <>TOKEN_TEXT
>1a0c8c	7d 3f				eval        .word <>S_FOR
>1a0c8e	00 00				arity       .word <>0
=$9c					TOK_TO = $9C
>1ad071	54 4f 00			TOKEN_TEXT  .null "TO"
>1a0c90	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0c91	02				length      .byte len("TO")
>1a0c92	71 d0				name        .word <>TOKEN_TEXT
>1a0c94	00 00				eval        .word <>0
>1a0c96	00 00				arity       .word <>0
=$9d					TOK_STEP = $9D
>1ad074	53 54 45 50 00			TOKEN_TEXT  .null "STEP"
>1a0c98	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0c99	04				length      .byte len("STEP")
>1a0c9a	74 d0				name        .word <>TOKEN_TEXT
>1a0c9c	00 00				eval        .word <>0
>1a0c9e	00 00				arity       .word <>0
=$9e					TOK_NEXT = $9E
>1ad079	4e 45 58 54 00			TOKEN_TEXT  .null "NEXT"
>1a0ca0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ca1	04				length      .byte len("NEXT")
>1a0ca2	79 d0				name        .word <>TOKEN_TEXT
>1a0ca4	71 40				eval        .word <>S_NEXT
>1a0ca6	00 00				arity       .word <>0
=$9f					TOK_DO = $9F
>1ad07e	44 4f 00			TOKEN_TEXT  .null "DO"
>1a0ca8	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ca9	02				length      .byte len("DO")
>1a0caa	7e d0				name        .word <>TOKEN_TEXT
>1a0cac	77 3f				eval        .word <>S_DO
>1a0cae	00 00				arity       .word <>0
=$a0					TOK_LOOP = $A0
>1ad081	4c 4f 4f 50 00			TOKEN_TEXT  .null "LOOP"
>1a0cb0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0cb1	04				length      .byte len("LOOP")
>1a0cb2	81 d0				name        .word <>TOKEN_TEXT
>1a0cb4	7a 3f				eval        .word <>S_LOOP
>1a0cb6	00 00				arity       .word <>0
>1ad086	57 48 49 4c 45 00		TOKEN_TEXT  .null "WHILE"
>1a0cb8	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0cb9	05				length      .byte len("WHILE")
>1a0cba	86 d0				name        .word <>TOKEN_TEXT
>1a0cbc	00 00				eval        .word <>0
>1a0cbe	00 00				arity       .word <>0
>1ad08c	55 4e 54 49 4c 00		TOKEN_TEXT  .null "UNTIL"
>1a0cc0	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0cc1	05				length      .byte len("UNTIL")
>1a0cc2	8c d0				name        .word <>TOKEN_TEXT
>1a0cc4	00 00				eval        .word <>0
>1a0cc6	00 00				arity       .word <>0
>1ad092	45 58 49 54 00			TOKEN_TEXT  .null "EXIT"
>1a0cc8	20				precedence  .byte TOK_TY_STMNT | 0
>1a0cc9	04				length      .byte len("EXIT")
>1a0cca	92 d0				name        .word <>TOKEN_TEXT
>1a0ccc	74 3f				eval        .word <>S_EXIT
>1a0cce	00 00				arity       .word <>0
>1ad097	43 4c 52 00			TOKEN_TEXT  .null "CLR"
>1a0cd0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0cd1	03				length      .byte len("CLR")
>1a0cd2	97 d0				name        .word <>TOKEN_TEXT
>1a0cd4	ac 42				eval        .word <>S_CLR
>1a0cd6	00 00				arity       .word <>0
>1ad09b	53 54 4f 50 00			TOKEN_TEXT  .null "STOP"
>1a0cd8	20				precedence  .byte TOK_TY_STMNT | 0
>1a0cd9	04				length      .byte len("STOP")
>1a0cda	9b d0				name        .word <>TOKEN_TEXT
>1a0cdc	47 3f				eval        .word <>S_STOP
>1a0cde	00 00				arity       .word <>0
>1ad0a0	50 4f 4b 45 00			TOKEN_TEXT  .null "POKE"
>1a0ce0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ce1	04				length      .byte len("POKE")
>1a0ce2	a0 d0				name        .word <>TOKEN_TEXT
>1a0ce4	d7 3e				eval        .word <>S_POKE
>1a0ce6	00 00				arity       .word <>0
>1ad0a5	50 4f 4b 45 57 00		TOKEN_TEXT  .null "POKEW"
>1a0ce8	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ce9	05				length      .byte len("POKEW")
>1a0cea	a5 d0				name        .word <>TOKEN_TEXT
>1a0cec	6d 3e				eval        .word <>S_POKEW
>1a0cee	00 00				arity       .word <>0
>1ad0ab	50 4f 4b 45 4c 00		TOKEN_TEXT  .null "POKEL"
>1a0cf0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0cf1	05				length      .byte len("POKEL")
>1a0cf2	ab d0				name        .word <>TOKEN_TEXT
>1a0cf4	fa 3d				eval        .word <>S_POKEL
>1a0cf6	00 00				arity       .word <>0
>1ad0b1	43 4c 53 00			TOKEN_TEXT  .null "CLS"
>1a0cf8	20				precedence  .byte TOK_TY_STMNT | 0
>1a0cf9	03				length      .byte len("CLS")
>1a0cfa	b1 d0				name        .word <>TOKEN_TEXT
>1a0cfc	f6 3d				eval        .word <>S_CLS
>1a0cfe	00 00				arity       .word <>0
>1ad0b5	52 45 41 44 00			TOKEN_TEXT  .null "READ"
>1a0d00	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d01	04				length      .byte len("READ")
>1a0d02	b5 d0				name        .word <>TOKEN_TEXT
>1a0d04	d7 3c				eval        .word <>S_READ
>1a0d06	00 00				arity       .word <>0
=$ab					TOK_DATA = $AB
>1ad0ba	44 41 54 41 00			TOKEN_TEXT  .null "DATA"
>1a0d08	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d09	04				length      .byte len("DATA")
>1a0d0a	ba d0				name        .word <>TOKEN_TEXT
>1a0d0c	e9 3d				eval        .word <>S_DATA
>1a0d0e	00 00				arity       .word <>0
>1ad0bf	52 45 53 54 4f 52 45 00		TOKEN_TEXT  .null "RESTORE"
>1a0d10	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d11	07				length      .byte len("RESTORE")
>1a0d12	bf d0				name        .word <>TOKEN_TEXT
>1a0d14	ed 3d				eval        .word <>S_RESTORE
>1a0d16	00 00				arity       .word <>0
>1ad0c7	44 49 4d 00			TOKEN_TEXT  .null "DIM"
>1a0d18	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d19	03				length      .byte len("DIM")
>1a0d1a	c7 d0				name        .word <>TOKEN_TEXT
>1a0d1c	2a 3c				eval        .word <>S_DIM
>1a0d1e	00 00				arity       .word <>0
>1ad0cb	43 41 4c 4c 00			TOKEN_TEXT  .null "CALL"
>1a0d20	20				precedence  .byte TOK_TY_STMNT | 0
>1a0d21	04				length      .byte len("CALL")
>1a0d22	cb d0				name        .word <>TOKEN_TEXT
>1a0d24	93 3b				eval        .word <>S_CALL
>1a0d26	00 00				arity       .word <>0
=$af					TOK_NEGATIVE = $AF
>1ad0d0	2d 00				TOKEN_TEXT  .null "-"
>1a0d28	00				precedence  .byte TOK_TY_OP | 0
>1a0d29	01				length      .byte len("-")
>1a0d2a	d0 d0				name        .word <>TOKEN_TEXT
>1a0d2c	e6 28				eval        .word <>OP_NEGATIVE
>1a0d2e	01 00				arity       .word <>1
>1ad0d2	4c 45 4e 00			TOKEN_TEXT  .null "LEN"
>1a0d30	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d31	03				length      .byte len("LEN")
>1a0d32	d2 d0				name        .word <>TOKEN_TEXT
>1a0d34	61 49				eval        .word <>FN_LEN
>1a0d36	00 00				arity       .word <>0
>1ad0d6	50 45 45 4b 00			TOKEN_TEXT  .null "PEEK"
>1a0d38	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d39	04				length      .byte len("PEEK")
>1a0d3a	d6 d0				name        .word <>TOKEN_TEXT
>1a0d3c	b1 49				eval        .word <>FN_PEEK
>1a0d3e	00 00				arity       .word <>0
>1ad0db	50 45 45 4b 57 00		TOKEN_TEXT  .null "PEEKW"
>1a0d40	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d41	05				length      .byte len("PEEKW")
>1a0d42	db d0				name        .word <>TOKEN_TEXT
>1a0d44	42 4a				eval        .word <>FN_PEEKW
>1a0d46	00 00				arity       .word <>0
>1ad0e1	50 45 45 4b 4c 00		TOKEN_TEXT  .null "PEEKL"
>1a0d48	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d49	05				length      .byte len("PEEKL")
>1a0d4a	e1 d0				name        .word <>TOKEN_TEXT
>1a0d4c	f4 49				eval        .word <>FN_PEEKL
>1a0d4e	00 00				arity       .word <>0
>1ad0e7	43 48 52 24 00			TOKEN_TEXT  .null "CHR$"
>1a0d50	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d51	04				length      .byte len("CHR$")
>1a0d52	e7 d0				name        .word <>TOKEN_TEXT
>1a0d54	81 4a				eval        .word <>FN_CHR
>1a0d56	00 00				arity       .word <>0
>1ad0ec	41 53 43 00			TOKEN_TEXT  .null "ASC"
>1a0d58	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d59	03				length      .byte len("ASC")
>1a0d5a	ec d0				name        .word <>TOKEN_TEXT
>1a0d5c	d6 4a				eval        .word <>FN_ASC
>1a0d5e	00 00				arity       .word <>0
>1ad0f0	53 50 43 00			TOKEN_TEXT  .null "SPC"
>1a0d60	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d61	03				length      .byte len("SPC")
>1a0d62	f0 d0				name        .word <>TOKEN_TEXT
>1a0d64	1b 4b				eval        .word <>FN_SPC
>1a0d66	00 00				arity       .word <>0
>1ad0f4	54 41 42 00			TOKEN_TEXT  .null "TAB"
>1a0d68	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d69	03				length      .byte len("TAB")
>1a0d6a	f4 d0				name        .word <>TOKEN_TEXT
>1a0d6c	a4 4b				eval        .word <>FN_TAB
>1a0d6e	00 00				arity       .word <>0
>1ad0f8	41 42 53 00			TOKEN_TEXT  .null "ABS"
>1a0d70	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d71	03				length      .byte len("ABS")
>1a0d72	f8 d0				name        .word <>TOKEN_TEXT
>1a0d74	2d 4c				eval        .word <>FN_ABS
>1a0d76	00 00				arity       .word <>0
>1ad0fc	53 47 4e 00			TOKEN_TEXT  .null "SGN"
>1a0d78	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d79	03				length      .byte len("SGN")
>1a0d7a	fc d0				name        .word <>TOKEN_TEXT
>1a0d7c	8f 4c				eval        .word <>FN_SGN
>1a0d7e	00 00				arity       .word <>0
>1ad100	48 45 58 24 00			TOKEN_TEXT  .null "HEX$"
>1a0d80	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d81	04				length      .byte len("HEX$")
>1a0d82	00 d1				name        .word <>TOKEN_TEXT
>1a0d84	d3 48				eval        .word <>FN_HEX
>1a0d86	00 00				arity       .word <>0
>1ad105	44 45 43 00			TOKEN_TEXT  .null "DEC"
>1a0d88	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d89	03				length      .byte len("DEC")
>1a0d8a	05 d1				name        .word <>TOKEN_TEXT
>1a0d8c	72 48				eval        .word <>FN_DEC
>1a0d8e	00 00				arity       .word <>0
>1ad109	53 54 52 24 00			TOKEN_TEXT  .null "STR$"
>1a0d90	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d91	04				length      .byte len("STR$")
>1a0d92	09 d1				name        .word <>TOKEN_TEXT
>1a0d94	24 48				eval        .word <>FN_STR
>1a0d96	00 00				arity       .word <>0
>1ad10e	56 41 4c 00			TOKEN_TEXT  .null "VAL"
>1a0d98	30				precedence  .byte TOK_TY_FUNC | 0
>1a0d99	03				length      .byte len("VAL")
>1a0d9a	0e d1				name        .word <>TOKEN_TEXT
>1a0d9c	ce 47				eval        .word <>FN_VAL
>1a0d9e	00 00				arity       .word <>0
>1ad112	4c 45 46 54 24 00		TOKEN_TEXT  .null "LEFT$"
>1a0da0	30				precedence  .byte TOK_TY_FUNC | 0
>1a0da1	05				length      .byte len("LEFT$")
>1a0da2	12 d1				name        .word <>TOKEN_TEXT
>1a0da4	05 47				eval        .word <>FN_LEFT
>1a0da6	00 00				arity       .word <>0
>1ad118	52 49 47 48 54 24 00		TOKEN_TEXT  .null "RIGHT$"
>1a0da8	30				precedence  .byte TOK_TY_FUNC | 0
>1a0da9	06				length      .byte len("RIGHT$")
>1a0daa	18 d1				name        .word <>TOKEN_TEXT
>1a0dac	24 46				eval        .word <>FN_RIGHT
>1a0dae	00 00				arity       .word <>0
>1ad11f	4d 49 44 24 00			TOKEN_TEXT  .null "MID$"
>1a0db0	30				precedence  .byte TOK_TY_FUNC | 0
>1a0db1	04				length      .byte len("MID$")
>1a0db2	1f d1				name        .word <>TOKEN_TEXT
>1a0db4	6f 45				eval        .word <>FN_MID
>1a0db6	00 00				arity       .word <>0
>1ad124	52 55 4e 00			TOKEN_TEXT  .null "RUN"
>1a0db8	10				precedence  .byte TOK_TY_CMD | 0
>1a0db9	03				length      .byte len("RUN")
>1a0dba	24 d1				name        .word <>TOKEN_TEXT
>1a0dbc	f6 4d				eval        .word <>CMD_RUN
>1a0dbe	00 00				arity       .word <>0
>1ad128	4e 45 57 00			TOKEN_TEXT  .null "NEW"
>1a0dc0	10				precedence  .byte TOK_TY_CMD | 0
>1a0dc1	03				length      .byte len("NEW")
>1a0dc2	28 d1				name        .word <>TOKEN_TEXT
>1a0dc4	c1 4d				eval        .word <>CMD_NEW
>1a0dc6	00 00				arity       .word <>0
>1ad12c	4c 4f 41 44 00			TOKEN_TEXT  .null "LOAD"
>1a0dc8	10				precedence  .byte TOK_TY_CMD | 0
>1a0dc9	04				length      .byte len("LOAD")
>1a0dca	2c d1				name        .word <>TOKEN_TEXT
>1a0dcc	a7 69				eval        .word <>CMD_LOAD
>1a0dce	00 00				arity       .word <>0
>1ad131	4c 49 53 54 00			TOKEN_TEXT  .null "LIST"
>1a0dd0	10				precedence  .byte TOK_TY_CMD | 0
>1a0dd1	04				length      .byte len("LIST")
>1a0dd2	31 d1				name        .word <>TOKEN_TEXT
>1a0dd4	0d 4e				eval        .word <>CMD_LIST
>1a0dd6	00 00				arity       .word <>0
>1ad136	44 49 52 00			TOKEN_TEXT  .null "DIR"
>1a0dd8	10				precedence  .byte TOK_TY_CMD | 0
>1a0dd9	03				length      .byte len("DIR")
>1a0dda	36 d1				name        .word <>TOKEN_TEXT
>1a0ddc	ce 66				eval        .word <>CMD_DIR
>1a0dde	00 00				arity       .word <>0
>1ad13a	42 4c 4f 41 44 00		TOKEN_TEXT  .null "BLOAD"
>1a0de0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0de1	05				length      .byte len("BLOAD")
>1a0de2	3a d1				name        .word <>TOKEN_TEXT
>1a0de4	79 68				eval        .word <>S_BLOAD
>1a0de6	00 00				arity       .word <>0
>1ad140	42 52 55 4e 00			TOKEN_TEXT  .null "BRUN"
>1a0de8	10				precedence  .byte TOK_TY_CMD | 0
>1a0de9	04				length      .byte len("BRUN")
>1a0dea	40 d1				name        .word <>TOKEN_TEXT
>1a0dec	54 69				eval        .word <>CMD_BRUN
>1a0dee	00 00				arity       .word <>0
>1ad145	42 53 41 56 45 00		TOKEN_TEXT  .null "BSAVE"
>1a0df0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0df1	05				length      .byte len("BSAVE")
>1a0df2	45 d1				name        .word <>TOKEN_TEXT
>1a0df4	60 6a				eval        .word <>S_BSAVE
>1a0df6	00 00				arity       .word <>0
>1ad14b	44 45 4c 00			TOKEN_TEXT  .null "DEL"
>1a0df8	20				precedence  .byte TOK_TY_STMNT | 0
>1a0df9	03				length      .byte len("DEL")
>1a0dfa	4b d1				name        .word <>TOKEN_TEXT
>1a0dfc	7f 6b				eval        .word <>S_DEL
>1a0dfe	00 00				arity       .word <>0
>1ad14f	53 41 56 45 00			TOKEN_TEXT  .null "SAVE"
>1a0e00	10				precedence  .byte TOK_TY_CMD | 0
>1a0e01	04				length      .byte len("SAVE")
>1a0e02	4f d1				name        .word <>TOKEN_TEXT
>1a0e04	ec 6a				eval        .word <>CMD_SAVE
>1a0e06	00 00				arity       .word <>0
>1ad154	52 45 4e 41 4d 45 00		TOKEN_TEXT  .null "RENAME"
>1a0e08	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e09	06				length      .byte len("RENAME")
>1a0e0a	54 d1				name        .word <>TOKEN_TEXT
>1a0e0c	f5 6b				eval        .word <>S_RENAME
>1a0e0e	00 00				arity       .word <>0
>1ad15b	43 4f 50 59 00			TOKEN_TEXT  .null "COPY"
>1a0e10	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e11	04				length      .byte len("COPY")
>1a0e12	5b d1				name        .word <>TOKEN_TEXT
>1a0e14	19 6d				eval        .word <>S_COPY
>1a0e16	00 00				arity       .word <>0
>1ad160	4d 4f 4e 49 54 4f 52 00		TOKEN_TEXT  .null "MONITOR"
>1a0e18	10				precedence  .byte TOK_TY_CMD | 0
>1a0e19	07				length      .byte len("MONITOR")
>1a0e1a	60 d1				name        .word <>TOKEN_TEXT
>1a0e1c	be 4d				eval        .word <>CMD_MONITOR
>1a0e1e	00 00				arity       .word <>0
>1ad168	47 45 54 00			TOKEN_TEXT  .null "GET"
>1a0e20	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e21	03				length      .byte len("GET")
>1a0e22	68 d1				name        .word <>TOKEN_TEXT
>1a0e24	21 3b				eval        .word <>S_GET
>1a0e26	00 00				arity       .word <>0
>1ad16c	49 4e 50 55 54 00		TOKEN_TEXT  .null "INPUT"
>1a0e28	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e29	05				length      .byte len("INPUT")
>1a0e2a	6c d1				name        .word <>TOKEN_TEXT
>1a0e2c	31 3a				eval        .word <>S_INPUT
>1a0e2e	00 00				arity       .word <>0
>1ad172	53 45 54 42 4f 52 44 45		TOKEN_TEXT  .null "SETBORDER"
>1ad17a	52 00
>1a0e30	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e31	09				length      .byte len("SETBORDER")
>1a0e32	72 d1				name        .word <>TOKEN_TEXT
>1a0e34	a5 2a				eval        .word <>S_SETBORDER
>1a0e36	00 00				arity       .word <>0
>1ad17c	54 45 58 54 43 4f 4c 4f		TOKEN_TEXT  .null "TEXTCOLOR"
>1ad184	52 00
>1a0e38	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e39	09				length      .byte len("TEXTCOLOR")
>1a0e3a	7c d1				name        .word <>TOKEN_TEXT
>1a0e3c	32 2a				eval        .word <>S_TEXTCOLOR
>1a0e3e	00 00				arity       .word <>0
>1ad186	53 45 54 42 47 43 4f 4c		TOKEN_TEXT  .null "SETBGCOLOR"
>1ad18e	4f 52 00
>1a0e40	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e41	0a				length      .byte len("SETBGCOLOR")
>1a0e42	86 d1				name        .word <>TOKEN_TEXT
>1a0e44	62 2a				eval        .word <>S_SETBGCOLOR
>1a0e46	00 00				arity       .word <>0
>1ad191	53 45 54 44 41 54 45 00		TOKEN_TEXT  .null "SETDATE"
>1a0e48	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e49	07				length      .byte len("SETDATE")
>1a0e4a	91 d1				name        .word <>TOKEN_TEXT
>1a0e4c	9f 29				eval        .word <>S_SETDATE
>1a0e4e	00 00				arity       .word <>0
>1ad199	47 45 54 44 41 54 45 24		TOKEN_TEXT  .null "GETDATE$"
>1ad1a1	00
>1a0e50	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e51	08				length      .byte len("GETDATE$")
>1a0e52	99 d1				name        .word <>TOKEN_TEXT
>1a0e54	4a 44				eval        .word <>F_GETDATE
>1a0e56	00 00				arity       .word <>0
>1ad1a2	53 45 54 54 49 4d 45 00		TOKEN_TEXT  .null "SETTIME"
>1a0e58	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e59	07				length      .byte len("SETTIME")
>1a0e5a	a2 d1				name        .word <>TOKEN_TEXT
>1a0e5c	34 29				eval        .word <>S_SETTIME
>1a0e5e	00 00				arity       .word <>0
>1ad1aa	47 45 54 54 49 4d 45 24		TOKEN_TEXT  .null "GETTIME$"
>1ad1b2	00
>1a0e60	30				precedence  .byte TOK_TY_FUNC | 0
>1a0e61	08				length      .byte len("GETTIME$")
>1a0e62	aa d1				name        .word <>TOKEN_TEXT
>1a0e64	b4 44				eval        .word <>F_GETTIME
>1a0e66	00 00				arity       .word <>0
>1ad1b3	47 52 41 50 48 49 43 53		TOKEN_TEXT  .null "GRAPHICS"
>1ad1bb	00
>1a0e68	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e69	08				length      .byte len("GRAPHICS")
>1a0e6a	b3 d1				name        .word <>TOKEN_TEXT
>1a0e6c	ea 2b				eval        .word <>S_GRAPHICS
>1a0e6e	00 00				arity       .word <>0
>1ad1bc	53 45 54 43 4f 4c 4f 52		TOKEN_TEXT  .null "SETCOLOR"
>1ad1c4	00
>1a0e70	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e71	08				length      .byte len("SETCOLOR")
>1a0e72	bc d1				name        .word <>TOKEN_TEXT
>1a0e74	1e 2b				eval        .word <>S_SETCOLOR
>1a0e76	00 00				arity       .word <>0
>1ad1c5	42 49 54 4d 41 50 00		TOKEN_TEXT  .null "BITMAP"
>1a0e78	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e79	06				length      .byte len("BITMAP")
>1a0e7a	c5 d1				name        .word <>TOKEN_TEXT
>1a0e7c	24 2d				eval        .word <>S_BITMAP
>1a0e7e	00 00				arity       .word <>0
>1ad1cc	43 4c 52 42 49 54 4d 41		TOKEN_TEXT  .null "CLRBITMAP"
>1ad1d4	50 00
>1a0e80	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e81	09				length      .byte len("CLRBITMAP")
>1a0e82	cc d1				name        .word <>TOKEN_TEXT
>1a0e84	2c 2e				eval        .word <>S_CLRBITMAP
>1a0e86	00 00				arity       .word <>0
>1ad1d6	50 4c 4f 54 00			TOKEN_TEXT  .null "PLOT"
>1a0e88	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e89	04				length      .byte len("PLOT")
>1a0e8a	d6 d1				name        .word <>TOKEN_TEXT
>1a0e8c	3c 2f				eval        .word <>S_PLOT
>1a0e8e	00 00				arity       .word <>0
>1ad1db	4c 49 4e 45 00			TOKEN_TEXT  .null "LINE"
>1a0e90	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e91	04				length      .byte len("LINE")
>1a0e92	db d1				name        .word <>TOKEN_TEXT
>1a0e94	ad 2f				eval        .word <>S_LINE
>1a0e96	00 00				arity       .word <>0
>1ad1e0	46 49 4c 4c 00			TOKEN_TEXT  .null "FILL"
>1a0e98	20				precedence  .byte TOK_TY_STMNT | 0
>1a0e99	04				length      .byte len("FILL")
>1a0e9a	e0 d1				name        .word <>TOKEN_TEXT
>1a0e9c	46 30				eval        .word <>S_FILL
>1a0e9e	00 00				arity       .word <>0
>1ad1e5	53 50 52 49 54 45 00		TOKEN_TEXT  .null "SPRITE"
>1a0ea0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ea1	06				length      .byte len("SPRITE")
>1a0ea2	e5 d1				name        .word <>TOKEN_TEXT
>1a0ea4	82 31				eval        .word <>S_SPRITE
>1a0ea6	00 00				arity       .word <>0
>1ad1ec	53 50 52 49 54 45 41 54		TOKEN_TEXT  .null "SPRITEAT"
>1ad1f4	00
>1a0ea8	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ea9	08				length      .byte len("SPRITEAT")
>1a0eaa	ec d1				name        .word <>TOKEN_TEXT
>1a0eac	1e 32				eval        .word <>S_SPRITEAT
>1a0eae	00 00				arity       .word <>0
>1ad1f5	53 50 52 49 54 45 53 48		TOKEN_TEXT  .null "SPRITESHOW"
>1ad1fd	4f 57 00
>1a0eb0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0eb1	0a				length      .byte len("SPRITESHOW")
>1a0eb2	f5 d1				name        .word <>TOKEN_TEXT
>1a0eb4	6a 32				eval        .word <>S_SPRITESHOW
>1a0eb6	00 00				arity       .word <>0
>1ad200	54 49 4c 45 53 45 54 00		TOKEN_TEXT  .null "TILESET"
>1a0eb8	20				precedence  .byte TOK_TY_STMNT | 0
>1a0eb9	07				length      .byte len("TILESET")
>1a0eba	00 d2				name        .word <>TOKEN_TEXT
>1a0ebc	9f 33				eval        .word <>S_TILESET
>1a0ebe	00 00				arity       .word <>0
>1ad208	54 49 4c 45 4d 41 50 00		TOKEN_TEXT  .null "TILEMAP"
>1a0ec0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ec1	07				length      .byte len("TILEMAP")
>1a0ec2	08 d2				name        .word <>TOKEN_TEXT
>1a0ec4	1d 34				eval        .word <>S_TILEMAP
>1a0ec6	00 00				arity       .word <>0
>1ad210	54 49 4c 45 53 48 4f 57		TOKEN_TEXT  .null "TILESHOW"
>1ad218	00
>1a0ec8	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ec9	08				length      .byte len("TILESHOW")
>1a0eca	10 d2				name        .word <>TOKEN_TEXT
>1a0ecc	8f 34				eval        .word <>S_TILESHOW
>1a0ece	00 00				arity       .word <>0
>1ad219	54 49 4c 45 41 54 00		TOKEN_TEXT  .null "TILEAT"
>1a0ed0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ed1	06				length      .byte len("TILEAT")
>1a0ed2	19 d2				name        .word <>TOKEN_TEXT
>1a0ed4	cc 34				eval        .word <>S_TILEAT
>1a0ed6	00 00				arity       .word <>0
>1ad220	4d 45 4d 43 4f 50 59 00		TOKEN_TEXT  .null "MEMCOPY"
>1a0ed8	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ed9	07				length      .byte len("MEMCOPY")
>1a0eda	20 d2				name        .word <>TOKEN_TEXT
>1a0edc	fc 37				eval        .word <>S_MEMCOPY
>1a0ede	00 00				arity       .word <>0
=$e6					TOK_LINEAR = $E6
>1ad228	4c 49 4e 45 41 52 00		TOKEN_TEXT  .null "LINEAR"
>1a0ee0	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0ee1	06				length      .byte len("LINEAR")
>1a0ee2	28 d2				name        .word <>TOKEN_TEXT
>1a0ee4	00 00				eval        .word <>0
>1a0ee6	00 00				arity       .word <>0
=$e7					TOK_RECT = $E7
>1ad22f	52 45 43 54 00			TOKEN_TEXT  .null "RECT"
>1a0ee8	50				precedence  .byte TOK_TY_BYWRD | 0
>1a0ee9	04				length      .byte len("RECT")
>1a0eea	2f d2				name        .word <>TOKEN_TEXT
>1a0eec	00 00				eval        .word <>0
>1a0eee	00 00				arity       .word <>0
>1ad234	4c 4f 43 41 54 45 00		TOKEN_TEXT  .null "LOCATE"
>1a0ef0	20				precedence  .byte TOK_TY_STMNT | 0
>1a0ef1	06				length      .byte len("LOCATE")
>1a0ef2	34 d2				name        .word <>TOKEN_TEXT
>1a0ef4	11 3a				eval        .word <>S_LOCATE
>1a0ef6	00 00				arity       .word <>0
>1ad23b	49 4e 54 00			TOKEN_TEXT  .null "INT"
>1a0ef8	30				precedence  .byte TOK_TY_FUNC | 0
>1a0ef9	03				length      .byte len("INT")
>1a0efa	3b d2				name        .word <>TOKEN_TEXT
>1a0efc	e5 4c				eval        .word <>FN_INT
>1a0efe	00 00				arity       .word <>0
>1ad23f	52 4e 44 00			TOKEN_TEXT  .null "RND"
>1a0f00	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f01	03				length      .byte len("RND")
>1a0f02	3f d2				name        .word <>TOKEN_TEXT
>1a0f04	19 45				eval        .word <>FN_RND
>1a0f06	00 00				arity       .word <>0
>1ad243	53 49 4e 00			TOKEN_TEXT  .null "SIN"
>1a0f08	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f09	03				length      .byte len("SIN")
>1a0f0a	43 d2				name        .word <>TOKEN_TEXT
>1a0f0c	f8 4c				eval        .word <>FN_SIN
>1a0f0e	00 00				arity       .word <>0
>1ad247	43 4f 53 00			TOKEN_TEXT  .null "COS"
>1a0f10	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f11	03				length      .byte len("COS")
>1a0f12	47 d2				name        .word <>TOKEN_TEXT
>1a0f14	0e 4d				eval        .word <>FN_COS
>1a0f16	00 00				arity       .word <>0
>1ad24b	54 41 4e 00			TOKEN_TEXT  .null "TAN"
>1a0f18	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f19	03				length      .byte len("TAN")
>1a0f1a	4b d2				name        .word <>TOKEN_TEXT
>1a0f1c	24 4d				eval        .word <>FN_TAN
>1a0f1e	00 00				arity       .word <>0
>1ad24f	4c 4e 00			TOKEN_TEXT  .null "LN"
>1a0f20	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f21	02				length      .byte len("LN")
>1a0f22	4f d2				name        .word <>TOKEN_TEXT
>1a0f24	3a 4d				eval        .word <>FN_LN
>1a0f26	00 00				arity       .word <>0
>1ad252	41 43 4f 53 00			TOKEN_TEXT  .null "ACOS"
>1a0f28	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f29	04				length      .byte len("ACOS")
>1a0f2a	52 d2				name        .word <>TOKEN_TEXT
>1a0f2c	50 4d				eval        .word <>FN_ACOS
>1a0f2e	00 00				arity       .word <>0
>1ad257	41 53 49 4e 00			TOKEN_TEXT  .null "ASIN"
>1a0f30	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f31	04				length      .byte len("ASIN")
>1a0f32	57 d2				name        .word <>TOKEN_TEXT
>1a0f34	66 4d				eval        .word <>FN_ASIN
>1a0f36	00 00				arity       .word <>0
>1ad25c	41 54 41 4e 00			TOKEN_TEXT  .null "ATAN"
>1a0f38	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f39	04				length      .byte len("ATAN")
>1a0f3a	5c d2				name        .word <>TOKEN_TEXT
>1a0f3c	7c 4d				eval        .word <>FN_ATAN
>1a0f3e	00 00				arity       .word <>0
>1ad261	45 58 50 00			TOKEN_TEXT  .null "EXP"
>1a0f40	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f41	03				length      .byte len("EXP")
>1a0f42	61 d2				name        .word <>TOKEN_TEXT
>1a0f44	92 4d				eval        .word <>FN_EXP
>1a0f46	00 00				arity       .word <>0
>1ad265	53 51 52 00			TOKEN_TEXT  .null "SQR"
>1a0f48	30				precedence  .byte TOK_TY_FUNC | 0
>1a0f49	03				length      .byte len("SQR")
>1a0f4a	65 d2				name        .word <>TOKEN_TEXT
>1a0f4c	a8 4d				eval        .word <>FN_SQR
>1a0f4e	00 00				arity       .word <>0
>1a0f50	00 00 00 00 00 00 00 00		            .word 0, 0, 0, 0

;******  Return to file: src\basic816.s


;******  Processing file: src\heap.s

>08b7					ALLOCATED   .long ?     ; Pointer to the most recently allocated object
>08ba					HEAP        .long ?     ; Pointer to the top of the heap (next empty byte)
>08bd					FREED       .long ?     ; Pointer to a linked list of freed heap objects
>08c0					CURRBLOCK   .long ?     ; Pointer to the current heap allocated block
>08c3					CURRHEADER  .long ?     ; Pointer to the header of the current block
>08c6					CURREND     .long ?     ; Pointer to the byte immediately after the current block
>08c9					CURRFREED   .long ?     ; Pointer to the current freed block
>08cc					FREEDEND    .long ?     ; Pointer to the byte immediately after the current freed block
>08cf					LASTFREED   .long ?     ;
.0000					HEAPOBJ
>0000					TYPE        .byte ?     ; Code for the type of object allocated
>0001					COUNT       .byte ?     ; Number of references to the heap object
>0002					NEXT        .long ?     ; Pointer to the next object in the list (used when freed)
>0005					END         .long ?     ; Pointer to the next byte after the block
.1a0f58					INITHEAP
.1a0f58	08		php		            PHP
.1a0f59	0b		phd		            PHD
.1a0f5a	08		php		            PHP
.1a0f5b	c2 20		rep #$20	            REP #$20
.1a0f5d	48		pha		            PHA
.1a0f5e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0f61	5b		tcd		            TCD
.1a0f62	68		pla		            PLA
.1a0f63	28		plp		            PLP
.1a0f64	c2 30		rep #$30	            REP #$30
.1a0f66	a9 ff ff	lda #$ffff	            LDA #<>HEAP_TOP         ; Set the HEAP to the top
.1a0f69	85 ba		sta $08ba	            STA HEAP
.1a0f6b	e2 20		sep #$20	            SEP #$20
.1a0f6d	a9 17		lda #$17	            LDA #`HEAP_TOP
.1a0f6f	85 bc		sta $08bc	            STA HEAP+2
.1a0f71	c2 20		rep #$20	            REP #$20
.1a0f73	64 b7		stz $08b7	            STZ ALLOCATED           ; And clear the pointer to the allocated objects
.1a0f75	64 bd		stz $08bd	            STZ FREED               ; as well as the list of freed objects
.1a0f77	e2 20		sep #$20	            SEP #$20
.1a0f79	64 b9		stz $08b9	            STZ ALLOCATED+2
.1a0f7b	64 bf		stz $08bf	            STZ FREED+2
.1a0f7d	2b		pld		            PLD
.1a0f7e	28		plp		            PLP
.1a0f7f	60		rts		            RTS
.1a0f80					ALLOC
.1a0f80	5a		phy		            PHY
.1a0f81	08		php		            PHP
.1a0f82	e2 20		sep #$20	            SEP #$20
.1a0f84	85 ea		sta $08ea	            STA TOFINDTYPE      ; Save the type of the block to TOFINDTYPE
.1a0f86	c2 10		rep #$10	            REP #$10
.1a0f88	86 8f		stx $088f	            STX MCOUNT           ; And the length of the block needed to MCOUNT
.1a0f8a	c2 20		rep #$20	            REP #$20
.1a0f8c	a5 0e		lda $080e	            LDA SCRATCH+2
.1a0f8e	48		pha		            PHA
.1a0f8f	a5 0c		lda $080c	            LDA SCRATCH
.1a0f91	48		pha		            PHA
.1a0f92	a5 12		lda $0812	            LDA SCRATCH2+2
.1a0f94	48		pha		            PHA
.1a0f95	a5 10		lda $0810	            LDA SCRATCH2
.1a0f97	48		pha		            PHA
.1a0f98	20 30 10	jsr $1a1030	            JSR ALLOCFREED
.1a0f9b	b0 03		bcs $1a0fa0	            BCS done            ; Return, if we got something back
.1a0f9d	20 b4 0f	jsr $1a0fb4	            JSR ALLOCHEAP
.1a0fa0					done
.1a0fa0	20 bc 11	jsr $1a11bc	            JSR HEAP_GETHED
.1a0fa3	c2 20		rep #$20	            REP #$20
.1a0fa5	68		pla		            PLA
.1a0fa6	85 10		sta $0810	            STA SCRATCH2
.1a0fa8	68		pla		            PLA
.1a0fa9	85 12		sta $0812	            STA SCRATCH2+2
.1a0fab	68		pla		            PLA
.1a0fac	85 0c		sta $080c	            STA SCRATCH
.1a0fae	68		pla		            PLA
.1a0faf	85 0e		sta $080e	            STA SCRATCH+2
.1a0fb1	28		plp		            PLP
.1a0fb2	7a		ply		            PLY
.1a0fb3	60		rts		            RTS
.1a0fb4					ALLOCHEAP
.1a0fb4	08		php		            PHP
.1a0fb5	0b		phd		            PHD
.1a0fb6	08		php		            PHP
.1a0fb7	c2 20		rep #$20	            REP #$20
.1a0fb9	48		pha		            PHA
.1a0fba	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a0fbd	5b		tcd		            TCD
.1a0fbe	68		pla		            PLA
.1a0fbf	28		plp		            PLP
.1a0fc0	e2 20		sep #$20	            SEP #$20
.1a0fc2	a6 8f		ldx $088f	            LDX MCOUNT
.1a0fc4	ca		dex		            DEX
.1a0fc5	86 0c		stx $080c	            STX SCRATCH             ; SCRATCH := size - 1
.1a0fc7	e8		inx		            INX
.1a0fc8	c2 30		rep #$30	            REP #$30
.1a0fca	38		sec		            SEC
.1a0fcb	a5 ba		lda $08ba	            LDA HEAP
.1a0fcd	e5 0c		sbc $080c	            SBC SCRATCH
.1a0fcf	85 c0		sta $08c0	            STA CURRBLOCK
.1a0fd1	e2 20		sep #$20	            SEP #$20
.1a0fd3	a5 bc		lda $08bc	            LDA HEAP+2
.1a0fd5	e9 00		sbc #$00	            SBC #0
.1a0fd7	85 c2		sta $08c2	            STA CURRBLOCK+2
.1a0fd9	20 bc 11	jsr $1a11bc	            JSR HEAP_GETHED
.1a0fdc	e2 20		sep #$20	            SEP #$20
.1a0fde	a5 ea		lda $08ea	            LDA TOFINDTYPE
.1a0fe0	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE       ; Set the type of the object
.1a0fe3	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a0fe5	a9 00		lda #$00	            LDA #0                  ; Set the count to zero
.1a0fe7	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.1a0fea	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a0fec	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a0fef	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a0ff1	c2 20		rep #$20	            REP #$20
.1a0ff3	a9 00 00	lda #$0000	            LDA #0
.1a0ff6	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a0ff8	c2 20		rep #$20	            REP #$20
.1a0ffa	18		clc		            CLC
.1a0ffb	a5 ba		lda $08ba	            LDA HEAP
.1a0ffd	69 01 00	adc #$0001	            ADC #1
.1a1000	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; To get the address of the next byte
.1a1003	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y      ; after the block
.1a1005	e2 20		sep #$20	            SEP #$20
.1a1007	c8		iny		            INY
.1a1008	c8		iny		            INY
.1a1009	a5 bc		lda $08bc	            LDA HEAP+2
.1a100b	69 00		adc #$00	            ADC #0
.1a100d	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a100f	c2 20		rep #$20	            REP #$20
.1a1011	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a1013	85 b7		sta $08b7	            STA ALLOCATED
.1a1015	e2 20		sep #$20	            SEP #$20
.1a1017	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a1019	85 b9		sta $08b9	            STA ALLOCATED+2
.1a101b	c2 20		rep #$20	            REP #$20
.1a101d	38		sec		            SEC                     ; Move the HEAP pointer to the first free byte under the header
.1a101e	a5 c3		lda $08c3	            LDA CURRHEADER
.1a1020	e9 01 00	sbc #$0001	            SBC #1
.1a1023	85 ba		sta $08ba	            STA HEAP
.1a1025	e2 20		sep #$20	            SEP #$20
.1a1027	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1029	e9 00		sbc #$00	            SBC #0
.1a102b	85 bc		sta $08bc	            STA HEAP+2
.1a102d	2b		pld		            PLD
.1a102e	28		plp		            PLP
.1a102f	60		rts		            RTS
.1a1030					ALLOCFREED
.1a1030	08		php		            PHP
.1a1031	0b		phd		            PHD
.1a1032	08		php		            PHP
.1a1033	c2 20		rep #$20	            REP #$20
.1a1035	48		pha		            PHA
.1a1036	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1039	5b		tcd		            TCD
.1a103a	68		pla		            PLA
.1a103b	28		plp		            PLP
.1a103c	c2 30		rep #$30	            REP #$30
.1a103e	c2 20		rep #$20	            REP #$20
.1a1040	a5 bd		lda $08bd	            LDA FREED
.1a1042	85 c9		sta $08c9	            STA CURRFREED
.1a1044	e2 20		sep #$20	            SEP #$20
.1a1046	a5 bf		lda $08bf	            LDA FREED+2
.1a1048	85 cb		sta $08cb	            STA CURRFREED+2
.1a104a	a5 c9		lda $08c9	loop        LDA CURRFREED           ; Has anything been freed?
.1a104c	d0 17		bne $1a1065	            BNE has_block           ; Yes: check to see if there's a big enough block
.1a104e	e2 20		sep #$20	            SEP #$20
.1a1050	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a1052	d0 11		bne $1a1065	            BNE has_block           ; Yes: check to see if there's a big enough block
.1a1054	c2 20		rep #$20	            REP #$20
.1a1056	a9 00 00	lda #$0000	            LDA #<>0
.1a1059	85 cf		sta $08cf	            STA LASTFREED
.1a105b	e2 20		sep #$20	            SEP #$20
.1a105d	a9 00		lda #$00	            LDA #`0
.1a105f	85 d1		sta $08d1	            STA LASTFREED+2
.1a1061	2b		pld		ret_false   PLD                     ; Return that we didn't find anything
.1a1062	28		plp		            PLP
.1a1063	18		clc		            CLC
.1a1064	60		rts		            RTS
.1a1065					has_block
.1a1065	c2 20		rep #$20	            REP #$20
.1a1067	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.1a106a	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a106c	85 cc		sta $08cc	            STA FREEDEND
.1a106e	e2 20		sep #$20	            SEP #$20
.1a1070	c8		iny		            INY
.1a1071	c8		iny		            INY
.1a1072	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1074	85 ce		sta $08ce	            STA FREEDEND+2
.1a1076	c2 20		rep #$20	            REP #$20
.1a1078	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required
.1a1079	a5 c9		lda $08c9	            LDA CURRFREED
.1a107b	65 8f		adc $088f	            ADC MCOUNT
.1a107d	85 0c		sta $080c	            STA SCRATCH
.1a107f	e2 20		sep #$20	            SEP #$20
.1a1081	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a1083	69 00		adc #$00	            ADC #0
.1a1085	85 0e		sta $080e	            STA SCRATCH+2
.1a1087	c2 20		rep #$20	            REP #$20
.1a1089	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required + size of header
.1a108a	a5 0c		lda $080c	            LDA SCRATCH                 ; (that is, it's a pointer to the byte immediately after the block desired)
.1a108c	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)
.1a108f	85 0c		sta $080c	            STA SCRATCH
.1a1091	e2 20		sep #$20	            SEP #$20
.1a1093	a5 0e		lda $080e	            LDA SCRATCH+2
.1a1095	69 00		adc #$00	            ADC #0
.1a1097	85 0e		sta $080e	            STA SCRATCH+2
.1a1099	c2 20		rep #$20	            REP #$20
.1a109b	a5 0c		lda $080c	            LDA SCRATCH                 ; Is SCRATCH == FREEDEND?
.1a109d	c5 cc		cmp $08cc	            CMP FREEDEND
.1a109f	d0 28		bne $1a10c9	            BNE not_exact               ; No: check if this block is bigger than needed
.1a10a1	e2 20		sep #$20	            SEP #$20
.1a10a3	a5 0e		lda $080e	            LDA SCRATCH+2
.1a10a5	c5 ce		cmp $08ce	            CMP FREEDEND+2
.1a10a7	d0 20		bne $1a10c9	            BNE not_exact
.1a10a9	c2 20		rep #$20	            REP #$20
.1a10ab	a5 cf		lda $08cf	            LDA LASTFREED               ; LASTFREED == 0?
.1a10ad	d0 5d		bne $1a110c	            BNE adj_last1               ; No: point LASTFREED->NEXT to skip this block
.1a10af	e2 20		sep #$20	            SEP #$20
.1a10b1	a5 d1		lda $08d1	            LDA LASTFREED+2
.1a10b3	d0 57		bne $1a110c	            BNE adj_last1
.1a10b5	c2 20		rep #$20	            REP #$20
.1a10b7	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a10ba	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a10bc	85 bd		sta $08bd	            STA FREED
.1a10be	e2 20		sep #$20	            SEP #$20
.1a10c0	c8		iny		            INY
.1a10c1	c8		iny		            INY
.1a10c2	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a10c4	85 bf		sta $08bf	            STA FREED+2
.1a10c6	4c 6d 11	jmp $1a116d	            JMP init_block              ; And return CURRFREED as our reallocated memory
.1a10c9					not_exact
.1a10c9	c2 20		rep #$20	            REP #$20
.1a10cb	a5 0c		lda $080c	            LDA SCRATCH                 ; Add a buffer to the room needed
.1a10cd	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)          ; So we have room to track the memory still freed
.1a10d0	85 10		sta $0810	            STA SCRATCH2
.1a10d2	e2 20		sep #$20	            SEP #$20
.1a10d4	a5 0e		lda $080e	            LDA SCRATCH+2
.1a10d6	69 00		adc #$00	            ADC #0
.1a10d8	85 12		sta $0812	            STA SCRATCH2+2
.1a10da	e2 20		sep #$20	            SEP #$20
.1a10dc	a5 c6		lda $08c6	            LDA CURREND                 ; Is CURREND > SCRATCH2
.1a10de	c5 10		cmp $0810	            CMP SCRATCH2
.1a10e0	b0 3e		bcs $1a1120	            BGE has_room                ; Yes: there is room in this block to allocate some memory
.1a10e2	90 08		bcc $1a10ec	            BLT try_next
.1a10e4	c2 20		rep #$20	            REP #$20
.1a10e6	a5 c6		lda $08c6	            LDA CURREND
.1a10e8	c5 10		cmp $0810	            CMP SCRATCH2
.1a10ea	b0 34		bcs $1a1120	            BGE has_room
.1a10ec					try_next
.1a10ec	c2 20		rep #$20	            REP #$20
.1a10ee	a5 c9		lda $08c9	            LDA CURRFREED
.1a10f0	85 cf		sta $08cf	            STA LASTFREED
.1a10f2	e2 20		sep #$20	            SEP #$20
.1a10f4	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a10f6	85 d1		sta $08d1	            STA LASTFREED+2
.1a10f8	c2 20		rep #$20	            REP #$20
.1a10fa	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a10fd	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.1a10ff	85 c9		sta $08c9	            STA CURRFREED
.1a1101	e2 20		sep #$20	            SEP #$20
.1a1103	c8		iny		            INY
.1a1104	c8		iny		            INY
.1a1105	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.1a1107	85 cb		sta $08cb	            STA CURRFREED+2
.1a1109	4c 4a 10	jmp $1a104a	            JMP loop                                    ; And try the next header
.1a110c					adj_last1
.1a110c	c2 20		rep #$20	            REP #$20
.1a110e	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := CURRFREED->NEXT
.1a1111	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1113	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.1a1115	e2 20		sep #$20	            SEP #$20
.1a1117	c8		iny		            INY
.1a1118	c8		iny		            INY
.1a1119	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a111b	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.1a111d	4c 6d 11	jmp $1a116d	            JMP init_block              ; And get CURRFREED ready to return
.1a1120					has_room
.1a1120	c2 20		rep #$20	            REP #$20
.1a1122	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END            ; SCRATCH->END := CURRFREED->END
.1a1125	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1127	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a1129	e2 20		sep #$20	            SEP #$20
.1a112b	c8		iny		            INY
.1a112c	c8		iny		            INY
.1a112d	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a112f	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a1131	c2 20		rep #$20	            REP #$20
.1a1133	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; CURREND->NEXT := CURRFREED->NEXT
.1a1136	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1138	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a113a	e2 20		sep #$20	            SEP #$20
.1a113c	c8		iny		            INY
.1a113d	c8		iny		            INY
.1a113e	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.1a1140	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.1a1142	c2 20		rep #$20	            REP #$20
.1a1144	a5 cf		lda $08cf	            LDA LASTFREED               ; Is this the first object we've examined?
.1a1146	d0 14		bne $1a115c	            BNE adj_last2               ; No: we'll need to adjust the previously examined block
.1a1148	e2 20		sep #$20	            SEP #$20
.1a114a	a5 cf		lda $08cf	            LDA LASTFREED
.1a114c	d0 0e		bne $1a115c	            BNE adj_last2
.1a114e	c2 20		rep #$20	            REP #$20
.1a1150	a5 0c		lda $080c	            LDA SCRATCH
.1a1152	85 bd		sta $08bd	            STA FREED
.1a1154	e2 20		sep #$20	            SEP #$20
.1a1156	a5 0e		lda $080e	            LDA SCRATCH+2
.1a1158	85 bf		sta $08bf	            STA FREED+2
.1a115a	80 11		bra $1a116d	            BRA init_block              ; ... and return the block we've sliced off
.1a115c					adj_last2
.1a115c	c2 20		rep #$20	            REP #$20
.1a115e	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := SCRATCH
.1a1161	a5 0c		lda $080c	            LDA SCRATCH                 ; (point the previous freed block to the newly sliced
.1a1163	97 cf		sta [$08cf],y	            STA [LASTFREED],Y           ;  off part of the current block)
.1a1165	e2 20		sep #$20	            SEP #$20
.1a1167	c8		iny		            INY
.1a1168	c8		iny		            INY
.1a1169	a5 0e		lda $080e	            LDA SCRATCH+2
.1a116b	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.1a116d					init_block
.1a116d	c2 20		rep #$20	            REP #$20
.1a116f	a5 c9		lda $08c9	            LDA CURRFREED
.1a1171	85 c3		sta $08c3	            STA CURRHEADER
.1a1173	e2 20		sep #$20	            SEP #$20
.1a1175	a5 cb		lda $08cb	            LDA CURRFREED+2
.1a1177	85 c5		sta $08c5	            STA CURRHEADER+2
.1a1179	c2 20		rep #$20	            REP #$20
.1a117b	a5 c3		lda $08c3	            LDA CURRHEADER
.1a117d	85 b7		sta $08b7	            STA ALLOCATED
.1a117f	e2 20		sep #$20	            SEP #$20
.1a1181	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1183	85 b9		sta $08b9	            STA ALLOCATED+2
.1a1185	c2 20		rep #$20	            REP #$20
.1a1187	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; Set CURRHEADER->END to the byte after the block
.1a118a	a5 0c		lda $080c	            LDA SCRATCH
.1a118c	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a118e	e2 20		sep #$20	            SEP #$20
.1a1190	c8		iny		            INY
.1a1191	c8		iny		            INY
.1a1192	a5 0e		lda $080e	            LDA SCRATCH+2
.1a1194	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1196	c2 20		rep #$20	            REP #$20
.1a1198	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Set CURRHEADER->NEXT to NULL
.1a119b	a9 00 00	lda #$0000	            LDA #0
.1a119e	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a11a0	e2 20		sep #$20	            SEP #$20
.1a11a2	c8		iny		            INY
.1a11a3	c8		iny		            INY
.1a11a4	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a11a6	e2 20		sep #$20	            SEP #$20
.1a11a8	a5 ea		lda $08ea	            LDA TOFINDTYPE          ; Get the type code back
.1a11aa	e2 20		sep #$20	            SEP #$20
.1a11ac	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE
.1a11af	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a11b1	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT      ; Set its reference count to 0
.1a11b4	a9 00		lda #$00	            LDA #0
.1a11b6	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a11b8	2b		pld		done        PLD
.1a11b9	28		plp		            PLP
.1a11ba	38		sec		            SEC
.1a11bb	60		rts		            RTS
.1a11bc					HEAP_GETHED
.1a11bc	08		php		            PHP
.1a11bd	c2 20		rep #$20	            REP #$20
.1a11bf	38		sec		            SEC
.1a11c0	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a11c2	e9 08 00	sbc #$0008	            SBC #size(HEAPOBJ)
.1a11c5	85 c3		sta $08c3	            STA CURRHEADER
.1a11c7	e2 20		sep #$20	            SEP #$20
.1a11c9	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a11cb	e9 00		sbc #$00	            SBC #0
.1a11cd	85 c5		sta $08c5	            STA CURRHEADER+2
.1a11cf	28		plp		            PLP
.1a11d0	60		rts		            RTS
.1a11d1					HEAP_ADDREF
.1a11d1	08		php		            PHP
.1a11d2	e2 20		sep #$20	            SEP #$20
.1a11d4	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a11d6	f0 04		beq $1a11dc	            BEQ chk_null
.1a11d8	c9 18		cmp #$18	            CMP #`(HEAP_TOP + 1)
.1a11da	b0 12		bcs $1a11ee	            BGE out_of_bnds
.1a11dc					chk_null
.1a11dc	c2 20		rep #$20	            REP #$20
.1a11de	a5 c3		lda $08c3	            LDA CURRHEADER
.1a11e0	f0 0c		beq $1a11ee	            BEQ out_of_bnds
.1a11e2					is_ok
.1a11e2	e2 20		sep #$20	            SEP #$20
.1a11e4	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.1a11e7	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a11e9	1a		inc a		            INC A
.1a11ea	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a11ec	28		plp		            PLP
.1a11ed	60		rts		            RTS
.1a11ee	00		brk #		out_of_bnds BRK
.1a11ef	ea		nop		            NOP
.1a11f0					HEAP_REMREF
.1a11f0	08		php		            PHP
.1a11f1	e2 20		sep #$20	            SEP #$20
.1a11f3	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a11f5	f0 04		beq $1a11fb	            BEQ chk_null
.1a11f7	c9 18		cmp #$18	            CMP #`(HEAP_TOP + 1)
.1a11f9	b0 17		bcs $1a1212	            BGE out_of_bnds
.1a11fb					chk_null
.1a11fb	c2 20		rep #$20	            REP #$20
.1a11fd	a5 c3		lda $08c3	            LDA CURRHEADER
.1a11ff	f0 11		beq $1a1212	            BEQ out_of_bnds
.1a1201	e2 20		sep #$20	            SEP #$20
.1a1203	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT  ; Decrement the reference count
.1a1206	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1208	3a		dec a		            DEC A
.1a1209	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a120b	d0 03		bne $1a1210	            BNE done            ; If it's still >0, we are done
.1a120d	20 14 12	jsr $1a1214	            JSR HEAP_FREE
.1a1210	28		plp		done        PLP
.1a1211	60		rts		            RTS
.1a1212	00		brk #		out_of_bnds BRK
.1a1213	ea		nop		            NOP
.1a1214					HEAP_FREE
.1a1214	08		php		            PHP
.1a1215	c2 20		rep #$20	            REP #$20
.1a1217	a5 bd		lda $08bd	            LDA FREED           ; Check to see if blocks are already on the freed list
.1a1219	d0 21		bne $1a123c	            BNE has_objects
.1a121b	e2 20		sep #$20	            SEP #$20
.1a121d	a5 bf		lda $08bf	            LDA FREED+2
.1a121f	d0 1b		bne $1a123c	            BNE has_objects
.1a1221	a5 c5		lda $08c5	            LDA CURRHEADER+2    ; No: this block is the first one
.1a1223	85 bf		sta $08bf	            STA FREED+2         ; Just make it the freed list
.1a1225	c2 20		rep #$20	            REP #$20
.1a1227	a5 c3		lda $08c3	            LDA CURRHEADER
.1a1229	85 bd		sta $08bd	            STA FREED
.1a122b	a9 00 00	lda #$0000	            LDA #0
.1a122e	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT   ; And clear its next link
.1a1231	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1233	c8		iny		            INY
.1a1234	c8		iny		            INY
.1a1235	e2 20		sep #$20	            SEP #$20
.1a1237	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1239	4c fb 12	jmp $1a12fb	            JMP done
.1a123c					has_objects
.1a123c	e2 20		sep #$20	            SEP #$20
.1a123e	a5 bf		lda $08bf	            LDA FREED+2
.1a1240	c5 c5		cmp $08c5	            CMP CURRHEADER+2
.1a1242	90 28		bcc $1a126c	            BLT start_scan
.1a1244	c2 20		rep #$20	            REP #$20
.1a1246	a5 bd		lda $08bd	            LDA FREED
.1a1248	c5 c3		cmp $08c3	            CMP CURRHEADER
.1a124a	90 20		bcc $1a126c	            BLT start_scan
.1a124c					ins_first
.1a124c	c2 20		rep #$20	            REP #$20
.1a124e	a5 bd		lda $08bd	            LDA FREED               ; CURRHEADER->NEXT := FREED
.1a1250	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1253	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1255	e2 20		sep #$20	            SEP #$20
.1a1257	c8		iny		            INY
.1a1258	c8		iny		            INY
.1a1259	a5 bf		lda $08bf	            LDA FREED+2
.1a125b	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a125d	c2 20		rep #$20	            REP #$20
.1a125f	a5 c3		lda $08c3	            LDA CURRHEADER
.1a1261	85 bd		sta $08bd	            STA FREED
.1a1263	e2 20		sep #$20	            SEP #$20
.1a1265	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1267	85 bf		sta $08bf	            STA FREED+2
.1a1269	4c fb 12	jmp $1a12fb	            JMP done
.1a126c					start_scan
.1a126c	c2 20		rep #$20	            REP #$20
.1a126e	a5 bd		lda $08bd	            LDA FREED
.1a1270	85 08		sta $0808	            STA INDEX
.1a1272	e2 20		sep #$20	            SEP #$20
.1a1274	a5 bf		lda $08bf	            LDA FREED+2
.1a1276	85 0a		sta $080a	            STA INDEX+2
.1a1278					loop
.1a1278	e2 20		sep #$20	            SEP #$20
.1a127a	a0 04 00	ldy #$0004	            LDY #HEAPOBJ.NEXT+2
.1a127d	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a127f	c5 c8		cmp $08c8	            CMP CURREND+2
.1a1281	90 32		bcc $1a12b5	            BLT go_next             ; No: check the next spot
.1a1283	d0 0b		bne $1a1290	            BNE ins_next
.1a1285	c2 20		rep #$20	            REP #$20
.1a1287	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a128a	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a128c	c5 c6		cmp $08c6	            CMP CURREND
.1a128e	90 25		bcc $1a12b5	            BLT go_next             ; No: check the next spot
.1a1290					ins_next
.1a1290	c2 20		rep #$20	            REP #$20
.1a1292	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := INDEX->NEXT
.1a1295	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a1297	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1299	e2 20		sep #$20	            SEP #$20
.1a129b	c8		iny		            INY
.1a129c	c8		iny		            INY
.1a129d	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a129f	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12a1	c2 20		rep #$20	            REP #$20
.1a12a3	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.1a12a5	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a12a8	97 08		sta [$0808],y	            STA [INDEX],Y
.1a12aa	e2 20		sep #$20	            SEP #$20
.1a12ac	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a12ae	c8		iny		            INY
.1a12af	c8		iny		            INY
.1a12b0	97 08		sta [$0808],y	            STA [INDEX],Y
.1a12b2	4c fb 12	jmp $1a12fb	            JMP done
.1a12b5					go_next
.1a12b5	c2 20		rep #$20	            REP #$20
.1a12b7	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Is INDEX->NEXT = 0
.1a12ba	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a12bc	d0 08		bne $1a12c6	            BNE not_at_end          ; No: load up the next object
.1a12be	e2 20		sep #$20	            SEP #$20
.1a12c0	c8		iny		            INY
.1a12c1	c8		iny		            INY
.1a12c2	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a12c4	f0 19		beq $1a12df	            BEQ at_end
.1a12c6					not_at_end
.1a12c6	c2 20		rep #$20	            REP #$20
.1a12c8	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; INDEX := INDEX->NEXT
.1a12cb	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a12cd	85 0c		sta $080c	            STA SCRATCH
.1a12cf	e2 20		sep #$20	            SEP #$20
.1a12d1	c8		iny		            INY
.1a12d2	c8		iny		            INY
.1a12d3	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a12d5	85 0a		sta $080a	            STA INDEX+2
.1a12d7	c2 20		rep #$20	            REP #$20
.1a12d9	a5 0c		lda $080c	            LDA SCRATCH
.1a12db	85 08		sta $0808	            STA INDEX
.1a12dd	80 99		bra $1a1278	            BRA loop
.1a12df					at_end
.1a12df	c2 20		rep #$20	            REP #$20
.1a12e1	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.1a12e3	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a12e6	97 08		sta [$0808],y	            STA [INDEX],Y
.1a12e8	e2 20		sep #$20	            SEP #$20
.1a12ea	c8		iny		            INY
.1a12eb	c8		iny		            INY
.1a12ec	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a12ee	97 08		sta [$0808],y	            STA [INDEX],Y
.1a12f0	a9 00		lda #$00	            LDA #0                  ; CURRHEADER->NEXT := 0
.1a12f2	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12f4	c2 20		rep #$20	            REP #$20
.1a12f6	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a12f9	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a12fb					done
.1a12fb	20 00 13	jsr $1a1300	            JSR COALLESCE
.1a12fe	28		plp		            PLP
.1a12ff	60		rts		            RTS
.1a1300					COALLESCE
.1a1300	08		php		            PHP
.1a1301	c2 20		rep #$20	            REP #$20
.1a1303	a5 bd		lda $08bd	            LDA FREED
.1a1305	85 c3		sta $08c3	            STA CURRHEADER
.1a1307	e2 20		sep #$20	            SEP #$20
.1a1309	a5 bf		lda $08bf	            LDA FREED+2
.1a130b	85 c5		sta $08c5	            STA CURRHEADER+2
.1a130d					next_head
.1a130d	c2 20		rep #$20	            REP #$20
.1a130f	a5 c3		lda $08c3	            LDA CURRHEADER          ; Is CURRHEADER == 0?
.1a1311	d0 09		bne $1a131c	            BNE check_next          ; No: check if NEXT is contiguous
.1a1313	e2 20		sep #$20	            SEP #$20
.1a1315	a5 c5		lda $08c5	            LDA CURRHEADER+2
.1a1317	d0 03		bne $1a131c	            BNE check_next
.1a1319	4c a3 13	jmp $1a13a3	            JMP done                ; Yes: we're done
.1a131c					check_next
.1a131c	c2 20		rep #$20	            REP #$20
.1a131e	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1321	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1323	85 0c		sta $080c	            STA SCRATCH
.1a1325	e2 20		sep #$20	            SEP #$20
.1a1327	c8		iny		            INY
.1a1328	c8		iny		            INY
.1a1329	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a132b	85 0e		sta $080e	            STA SCRATCH+2
.1a132d	c2 20		rep #$20	            REP #$20
.1a132f	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.1a1332	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1334	85 10		sta $0810	            STA SCRATCH2
.1a1336	e2 20		sep #$20	            SEP #$20
.1a1338	c8		iny		            INY
.1a1339	c8		iny		            INY
.1a133a	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a133c	85 12		sta $0812	            STA SCRATCH2+2
.1a133e	c2 20		rep #$20	            REP #$20
.1a1340	a5 0c		lda $080c	            LDA SCRATCH
.1a1342	c5 10		cmp $0810	            CMP SCRATCH2            ; Is CURRHEADER->END = CURRHEADER->NEXT?
.1a1344	d0 08		bne $1a134e	            BNE go_next             ; No: go to the next block
.1a1346	e2 20		sep #$20	            SEP #$20
.1a1348	a5 0e		lda $080e	            LDA SCRATCH+2
.1a134a	c5 12		cmp $0812	            CMP SCRATCH2+2
.1a134c	f0 1f		beq $1a136d	            BEQ combine             ; Yes: combine the two blocks
.1a134e					go_next
.1a134e	c2 20		rep #$20	            REP #$20
.1a1350	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1353	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1355	85 0c		sta $080c	            STA SCRATCH
.1a1357	e2 20		sep #$20	            SEP #$20
.1a1359	c8		iny		            INY
.1a135a	c8		iny		            INY
.1a135b	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a135d	85 0e		sta $080e	            STA SCRATCH+2
.1a135f	c2 20		rep #$20	            REP #$20
.1a1361	a5 0c		lda $080c	            LDA SCRATCH
.1a1363	85 c3		sta $08c3	            STA CURRHEADER
.1a1365	e2 20		sep #$20	            SEP #$20
.1a1367	a5 0e		lda $080e	            LDA SCRATCH+2
.1a1369	85 c5		sta $08c5	            STA CURRHEADER+2
.1a136b	80 a0		bra $1a130d	            BRA next_head                               ; And loop back to next_head
.1a136d					combine
.1a136d	c2 20		rep #$20	            REP #$20
.1a136f	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.1a1372	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a1374	85 0c		sta $080c	            STA SCRATCH
.1a1376	e2 20		sep #$20	            SEP #$20
.1a1378	c8		iny		            INY
.1a1379	c8		iny		            INY
.1a137a	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.1a137c	85 0e		sta $080e	            STA SCRATCH+2
.1a137e	c2 20		rep #$20	            REP #$20
.1a1380	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := SCRATCH->NEXT
.1a1383	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a1385	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1387	e2 20		sep #$20	            SEP #$20
.1a1389	c8		iny		            INY
.1a138a	c8		iny		            INY
.1a138b	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a138d	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a138f	c2 20		rep #$20	            REP #$20
.1a1391	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END       ; CURRHEADER->END := SCRATCH->END
.1a1394	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a1396	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a1398	e2 20		sep #$20	            SEP #$20
.1a139a	c8		iny		            INY
.1a139b	c8		iny		            INY
.1a139c	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.1a139e	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.1a13a0	4c 1c 13	jmp $1a131c	            JMP check_next          ; And loop back to check_next
.1a13a3	28		plp		done        PLP
.1a13a4	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\strings.s

.1a13a5					CLRTMPSTR
.1a13a5	08		php		            PHP
.1a13a6	c2 20		rep #$20	            REP #$20
.1a13a8	64 16		stz $0816	            STZ STRPTR
.1a13aa	64 18		stz $0818	            STZ STRPTR+2
.1a13ac	28		plp		            PLP
.1a13ad	60		rts		            RTS
.1a13ae					TEMPSTRING
.1a13ae	08		php		            PHP
.1a13af	c2 30		rep #$30	            REP #$30
.1a13b1	a5 16		lda $0816	            LDA STRPTR          ; Is STRPTR == 0?
.1a13b3	d0 16		bne $1a13cb	            BNE add_256         ; No: add 256 to it
.1a13b5	a5 18		lda $0818	            LDA STRPTR+2
.1a13b7	d0 12		bne $1a13cb	            BNE add_256
.1a13b9	e2 20		sep #$20	            SEP #$20
.1a13bb	64 16		stz $0816	            STZ STRPTR
.1a13bd	a5 e2		lda $08e2	            LDA NEXTVAR+1
.1a13bf	1a		inc a		            INC A
.1a13c0	1a		inc a		            INC A
.1a13c1	85 17		sta $0817	            STA STRPTR+1
.1a13c3	a5 e3		lda $08e3	            LDA NEXTVAR+2
.1a13c5	85 18		sta $0818	            STA STRPTR+2
.1a13c7	64 19		stz $0819	            STZ STRPTR+3
.1a13c9	80 07		bra $1a13d2	            BRA chk_room
.1a13cb					add_256
.1a13cb	c2 20		rep #$20	            REP #$20
.1a13cd	a5 17		lda $0817	            LDA STRPTR+1        ; There was already a temporary string...
.1a13cf	1a		inc a		            INC A               ; Leave 256 bytes for it
.1a13d0	85 17		sta $0817	            STA STRPTR+1
.1a13d2					chk_room
.1a13d2	c2 20		rep #$20	            REP #$20
.1a13d4	a5 bb		lda $08bb	            LDA HEAP+1          ; Check to make sure that STRPTR and HEAP haven't touched
.1a13d6	3a		dec a		            DEC A
.1a13d7	c5 17		cmp $0817	            CMP STRPTR+1
.1a13d9	f0 02		beq $1a13dd	            BEQ no_room         ; If they have, throw an error
.1a13db	b0 1f		bcs $1a13fc	            BGE done
.1a13dd					no_room
.1a13dd	08		php		            PHP
.1a13de	c2 20		rep #$20	            REP #$20
.1a13e0	48		pha		            PHA
.1a13e1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a13e4	5b		tcd		            TCD
.1a13e5	68		pla		            PLA
.1a13e6	28		plp		            PLP
.1a13e7	e2 20		sep #$20	            SEP #$20
.1a13e9	a9 03		lda #$03	            LDA #ERR_MEMORY
.1a13eb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a13ef	c2 20		rep #$20	            REP #$20
.1a13f1	29 ff 00	and #$00ff	            AND #$00FF
.1a13f4	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a13f7	e2 20		sep #$20	            SEP #$20
.1a13f9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a13fc	28		plp		done        PLP
.1a13fd	60		rts		            RTS
.1a13fe					ITOS_DIGIT
.1a13fe	c9 00		cmp #$00	            CMP #0          ; Is it 0?
.1a1400	d0 05		bne $1a1407	            BNE add_digit   ; No: go ahead and add it
.1a1402	c0 01 00	cpy #$0001	            CPY #1          ; Are we on the first digit?
.1a1405	f0 05		beq $1a140c	            BEQ done        ; Yes: ignore this leading 0
.1a1407	09 30		ora #$30	add_digit   ORA #$30        ; Convert it to ASCII
.1a1409	97 16		sta [$0816],y	            STA [STRPTR],Y  ; Save it to the string
.1a140b	c8		iny		            INY             ; And point to the next location
.1a140c					done
.1a140c	60		rts		            RTS
.1a140d					ITOS
.1a140d	08		php		            PHP
.1a140e	c2 30		rep #$30	            REP #$30
.1a1410	64 0c		stz $080c	            STZ SCRATCH         ; Use scratch to store if negative
.1a1412	a5 25		lda $0825	            LDA ARGUMENT1+2     ; Check to see if the number is negative
.1a1414	10 1a		bpl $1a1430	            BPL start_cnvt
.1a1416	18		clc		            CLC                 ; Yes: make ARGUMENT1 positive
.1a1417	a5 23		lda $0823	            LDA ARGUMENT1
.1a1419	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a141c	69 01 00	adc #$0001	            ADC #1
.1a141f	85 23		sta $0823	            STA ARGUMENT1
.1a1421	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a1423	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a1426	69 00 00	adc #$0000	            ADC #0
.1a1429	85 25		sta $0825	            STA ARGUMENT1+2
.1a142b	a9 ff ff	lda #$ffff	            LDA #$FFFF          ; Record that the number was negative
.1a142e	85 0c		sta $080c	            STA SCRATCH
.1a1430					start_cnvt
.1a1430	64 10		stz $0810	            STZ SCRATCH2        ; SCRATCH2 will be our BCD version of the number
.1a1432	64 12		stz $0812	            STZ SCRATCH2+2
.1a1434	64 14		stz $0814	            STZ SCRATCH2+4
.1a1436	a2 1f 00	ldx #$001f	            LDX #31
.1a1439	f8		sed		            SED                 ; Yes, we're really using BCD mode
.1a143a	06 23		asl $0823	shift_loop  ASL ARGUMENT1       ; Shift ARGUMENT1 left one bit
.1a143c	26 25		rol $0825	            ROL ARGUMENT1+2
.1a143e	a5 10		lda $0810	            LDA SCRATCH2        ; SCRATCH2 := SCRATCH2 + SCRATCH2 + Carry
.1a1440	65 10		adc $0810	            ADC SCRATCH2
.1a1442	85 10		sta $0810	            STA SCRATCH2
.1a1444	a5 12		lda $0812	            LDA SCRATCH2+2
.1a1446	65 12		adc $0812	            ADC SCRATCH2+2
.1a1448	85 12		sta $0812	            STA SCRATCH2+2
.1a144a	a5 14		lda $0814	            LDA SCRATCH2+4
.1a144c	65 14		adc $0814	            ADC SCRATCH2+4
.1a144e	85 14		sta $0814	            STA SCRATCH2+4
.1a1450	ca		dex		            DEX
.1a1451	10 e7		bpl $1a143a	            BPL shift_loop      ; Loop through all 32 bits of ARGUMENT1
.1a1453	d8		cld		            CLD                 ; Switch back out of BCD mode
.1a1454	e2 20		sep #$20	            SEP #$20
.1a1456	20 ae 13	jsr $1a13ae	            JSR TEMPSTRING
.1a1459	a0 00 00	ldy #$0000	            LDY #0              ; Y will be index into the temporary string
.1a145c	a5 0c		lda $080c	            LDA SCRATCH         ; Check to see if the number was negative
.1a145e	f0 04		beq $1a1464	            BEQ is_pos          ; No: write a leading space
.1a1460	a9 2d		lda #$2d	            LDA #'-'            ; If negative, write the minus sign
.1a1462	80 02		bra $1a1466	            BRA wr_lead
.1a1464	a9 20		lda #$20	is_pos      LDA #CHAR_SP        ; Write a leading space
.1a1466	97 16		sta [$0816],y	wr_lead     STA [STRPTR],Y
.1a1468	c8		iny		            INY
.1a1469	a2 05 00	ldx #$0005	            LDX #5
.1a146c	b5 10		lda $0810,x	ascii_loop  LDA SCRATCH2,X
.1a146e	29 f0		and #$f0	            AND #$F0
.1a1470	4a		lsr a		            LSR A
.1a1471	4a		lsr a		            LSR A
.1a1472	4a		lsr a		            LSR A
.1a1473	4a		lsr a		            LSR A
.1a1474	20 fe 13	jsr $1a13fe	            JSR ITOS_DIGIT
.1a1477	b5 10		lda $0810,x	            LDA SCRATCH2,X
.1a1479	29 0f		and #$0f	            AND #$0F
.1a147b	20 fe 13	jsr $1a13fe	            JSR ITOS_DIGIT
.1a147e	ca		dex		            DEX
.1a147f	10 eb		bpl $1a146c	            BPL ascii_loop
.1a1481	c0 01 00	cpy #$0001	            CPY #1              ; Did we write anything?
.1a1484	d0 0c		bne $1a1492	            BNE null_term       ; Yes: add a NULL to terminate
.1a1486	a9 20		lda #$20	            LDA #' '            ; No: write a " 0" to the string
.1a1488	87 16		sta [$0816]	            STA [STRPTR]
.1a148a	a0 01 00	ldy #$0001	            LDY #1
.1a148d	a9 30		lda #$30	            LDA #'0'
.1a148f	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a1491	c8		iny		            INY
.1a1492	a9 00		lda #$00	null_term   LDA #0
.1a1494	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And terminate the string
.1a1496	28		plp		done        PLP
.1a1497	60		rts		            RTS
.1a1498	00		brk #		fault       BRK
.1a1499	ea		nop		            NOP
.1a149a					STRLEN
.1a149a	08		php		            PHP
.1a149b	e2 20		sep #$20	            SEP #$20
.1a149d	c2 10		rep #$10	            REP #$10
.1a149f	a0 00 00	ldy #$0000	            LDY #0
.1a14a2	bd 00 00	lda $1a0000,x	loop        LDA #0,B,X
.1a14a5	f0 04		beq $1a14ab	            BEQ done
.1a14a7	e8		inx		            INX
.1a14a8	c8		iny		            INY
.1a14a9	80 f7		bra $1a14a2	            BRA loop
.1a14ab	28		plp		done        PLP
.1a14ac	60		rts		            RTS
.1a14ad					STRCMP
.1a14ad	08		php		            PHP
.1a14ae	0b		phd		            PHD
.1a14af	08		php		            PHP
.1a14b0	c2 20		rep #$20	            REP #$20
.1a14b2	48		pha		            PHA
.1a14b3	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a14b6	5b		tcd		            TCD
.1a14b7	68		pla		            PLA
.1a14b8	28		plp		            PLP
.1a14b9	e2 20		sep #$20	            SEP #$20
.1a14bb	c2 10		rep #$10	            REP #$10
.1a14bd	a0 00 00	ldy #$0000	            LDY #0
.1a14c0	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Check if the character 1 is 0
.1a14c2	d0 04		bne $1a14c8	            BNE comp_mag            ; If not, check the magnitudes
.1a14c4	b7 29		lda [$0829],y	            LDA [ARGUMENT2],Y       ; If so, check if the character 2 is 0
.1a14c6	f0 25		beq $1a14ed	            BEQ are_equal           ; If so, the strings are equal
.1a14c8	b7 23		lda [$0823],y	comp_mag    LDA [ARGUMENT1],Y       ; Otherwise, get character 1 again
.1a14ca	d7 29		cmp [$0829],y	            CMP [ARGUMENT2],Y       ; And compare it to character 2
.1a14cc	90 12		bcc $1a14e0	            BLT is_less             ; Check if character 1 < character 2
.1a14ce	d0 03		bne $1a14d3	            BNE is_greater          ; Check if character 1 > character 2
.1a14d0	c8		iny		            INY                     ; Equal so far... so go to the next pair of characters
.1a14d1	80 ed		bra $1a14c0	            BRA loop
.1a14d3					is_greater
.1a14d3	c2 20		rep #$20	            REP #$20
.1a14d5	a9 01 00	lda #$0001	            LDA #1                  ; So return 1
.1a14d8	85 23		sta $0823	            STA ARGUMENT1
.1a14da	e2 20		sep #$20	            SEP #$20
.1a14dc	64 25		stz $0825	            STZ ARGUMENT1+2
.1a14de	80 15		bra $1a14f5	            BRA done
.1a14e0					is_less
.1a14e0	c2 20		rep #$20	            REP #$20
.1a14e2	a9 ff ff	lda #$ffff	            LDA #$FFFF              ; So return -1
.1a14e5	85 23		sta $0823	            STA ARGUMENT1
.1a14e7	e2 20		sep #$20	            SEP #$20
.1a14e9	85 25		sta $0825	            STA ARGUMENT1+2
.1a14eb	80 08		bra $1a14f5	            BRA done
.1a14ed					are_equal
.1a14ed	c2 20		rep #$20	            REP #$20
.1a14ef	64 23		stz $0823	            STZ ARGUMENT1           ; So return 0
.1a14f1	e2 20		sep #$20	            SEP #$20
.1a14f3	64 25		stz $0825	            STZ ARGUMENT1+2
.1a14f5					done
.1a14f5	e2 20		sep #$20	            SEP #$20
.1a14f7	a9 00		lda #$00	            LDA #TYPE_INTEGER
.1a14f9	85 27		sta $0827	            STA ARGTYPE1
.1a14fb	2b		pld		            PLD
.1a14fc	28		plp		            PLP
.1a14fd	60		rts		            RTS
.1a14fe					STRCONCAT
.1a14fe	08		php		            PHP
.1a14ff	0b		phd		            PHD
.1a1500	8b		phb		            PHB
.1a1501	08		php		            PHP
.1a1502	c2 20		rep #$20	            REP #$20
.1a1504	48		pha		            PHA
.1a1505	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1508	5b		tcd		            TCD
.1a1509	68		pla		            PLA
.1a150a	28		plp		            PLP
.1a150b	e2 20		sep #$20	            SEP #$20
.1a150d	c2 10		rep #$10	            REP #$10
.1a150f	08		php		            PHP
.1a1510	c2 20		rep #$20	            REP #$20
.1a1512	48		pha		            PHA
.1a1513	e2 20		sep #$20	            SEP #$20
.1a1515	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a1517	48		pha		            PHA
.1a1518	ab		plb		            PLB
.1a1519	c2 20		rep #$20	            REP #$20
.1a151b	68		pla		            PLA
.1a151c	28		plp		            PLP
.1a151d	a6 23		ldx $0823	            LDX ARGUMENT1
.1a151f	20 9a 14	jsr $1a149a	            JSR STRLEN
.1a1522	84 0c		sty $080c	            STY SCRATCH
.1a1524	08		php		            PHP
.1a1525	c2 20		rep #$20	            REP #$20
.1a1527	48		pha		            PHA
.1a1528	e2 20		sep #$20	            SEP #$20
.1a152a	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a152c	48		pha		            PHA
.1a152d	ab		plb		            PLB
.1a152e	c2 20		rep #$20	            REP #$20
.1a1530	68		pla		            PLA
.1a1531	28		plp		            PLP
.1a1532	a6 29		ldx $0829	            LDX ARGUMENT2
.1a1534	20 9a 14	jsr $1a149a	            JSR STRLEN
.1a1537	c2 20		rep #$20	            REP #$20
.1a1539	98		tya		            TYA
.1a153a	38		sec		            SEC                     ; X := LEN(ARGUMENT1) + LEN(ARGUMENT2) + 1
.1a153b	65 0c		adc $080c	            ADC SCRATCH
.1a153d	aa		tax		            TAX
.1a153e	e2 20		sep #$20	            SEP #$20
.1a1540	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set type to STRING
.1a1542	20 80 0f	jsr $1a0f80	            JSR ALLOC
.1a1545	c2 20		rep #$20	            REP #$20
.1a1547	a5 b7		lda $08b7	            LDA ALLOCATED           ; INDEX := pointer to the string
.1a1549	85 08		sta $0808	            STA INDEX
.1a154b	e2 20		sep #$20	            SEP #$20
.1a154d	a5 b9		lda $08b9	            LDA ALLOCATED+2
.1a154f	85 0a		sta $080a	            STA INDEX+2
.1a1551	a0 00 00	ldy #$0000	            LDY #0                  ; Set the target index to the beginning
.1a1554	08		php		            PHP
.1a1555	c2 20		rep #$20	            REP #$20
.1a1557	48		pha		            PHA
.1a1558	e2 20		sep #$20	            SEP #$20
.1a155a	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a155c	48		pha		            PHA
.1a155d	ab		plb		            PLB
.1a155e	c2 20		rep #$20	            REP #$20
.1a1560	68		pla		            PLA
.1a1561	28		plp		            PLP
.1a1562	a6 23		ldx $0823	            LDX ARGUMENT1
.1a1564	bd 00 00	lda $1a0000,x	loop1       LDA #0,B,X              ; Get the Xth byte of ARGUMENT1
.1a1567	f0 06		beq $1a156f	            BEQ copy_2              ; Is it null? Yes: move on to the next string
.1a1569	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.1a156b	e8		inx		            INX                     ; Point to the next characters
.1a156c	c8		iny		            INY
.1a156d	80 f5		bra $1a1564	            BRA loop1               ; And do again
.1a156f					copy_2
.1a156f	e2 20		sep #$20	            SEP #$20
.1a1571	08		php		            PHP
.1a1572	c2 20		rep #$20	            REP #$20
.1a1574	48		pha		            PHA
.1a1575	e2 20		sep #$20	            SEP #$20
.1a1577	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a1579	48		pha		            PHA
.1a157a	ab		plb		            PLB
.1a157b	c2 20		rep #$20	            REP #$20
.1a157d	68		pla		            PLA
.1a157e	28		plp		            PLP
.1a157f	a6 29		ldx $0829	            LDX ARGUMENT2
.1a1581	bd 00 00	lda $1a0000,x	loop2       LDA #0,B,X              ; Get the Xth byte of ARGUMENT2
.1a1584	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.1a1586	f0 04		beq $1a158c	            BEQ terminate           ; Is it null? Yes: move on to the next string
.1a1588	e8		inx		            INX                     ; Point to the next characters
.1a1589	c8		iny		            INY
.1a158a	80 f5		bra $1a1581	            BRA loop2               ; And do again
.1a158c					terminate
.1a158c	c2 20		rep #$20	            REP #$20
.1a158e	a5 08		lda $0808	            LDA INDEX               ; Set ARGUMENT1 to the new string
.1a1590	85 23		sta $0823	            STA ARGUMENT1
.1a1592	e2 20		sep #$20	            SEP #$20
.1a1594	a5 0a		lda $080a	            LDA INDEX+2
.1a1596	85 25		sta $0825	            STA ARGUMENT1+2
.1a1598	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set ARGUMENT1's type to STRING
.1a159a	85 27		sta $0827	            STA ARGTYPE1
.1a159c	ab		plb		            PLB
.1a159d	2b		pld		            PLD
.1a159e	28		plp		            PLP
.1a159f	60		rts		            RTS
.1a15a0					STRCPY
.1a15a0	da		phx		            PHX
.1a15a1	5a		phy		            PHY
.1a15a2	08		php		            PHP
.1a15a3	0b		phd		            PHD
.1a15a4	8b		phb		            PHB
.1a15a5	08		php		            PHP
.1a15a6	c2 20		rep #$20	            REP #$20
.1a15a8	48		pha		            PHA
.1a15a9	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a15ac	5b		tcd		            TCD
.1a15ad	68		pla		            PLA
.1a15ae	28		plp		            PLP
.1a15af	c2 20		rep #$20	            REP #$20
.1a15b1	a5 0a		lda $080a	            LDA INDEX+2
.1a15b3	48		pha		            PHA
.1a15b4	a5 08		lda $0808	            LDA INDEX
.1a15b6	48		pha		            PHA
.1a15b7	c2 30		rep #$30	            REP #$30
.1a15b9	08		php		            PHP
.1a15ba	c2 20		rep #$20	            REP #$20
.1a15bc	48		pha		            PHA
.1a15bd	e2 20		sep #$20	            SEP #$20
.1a15bf	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a15c1	48		pha		            PHA
.1a15c2	ab		plb		            PLB
.1a15c3	c2 20		rep #$20	            REP #$20
.1a15c5	68		pla		            PLA
.1a15c6	28		plp		            PLP
.1a15c7	a6 23		ldx $0823	            LDX ARGUMENT1
.1a15c9	20 9a 14	jsr $1a149a	            JSR STRLEN
.1a15cc	98		tya		            TYA
.1a15cd	aa		tax		            TAX
.1a15ce	e8		inx		            INX                     ; Put length of string (plus NUL) in X
.1a15cf	e2 20		sep #$20	            SEP #$20
.1a15d1	a9 02		lda #$02	            LDA #TYPE_STRING
.1a15d3	20 80 0f	jsr $1a0f80	            JSR ALLOC
.1a15d6	c2 20		rep #$20	            REP #$20
.1a15d8	a5 c0		lda $08c0	            LDA CURRBLOCK
.1a15da	85 08		sta $0808	            STA INDEX
.1a15dc	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.1a15de	85 0a		sta $080a	            STA INDEX+2
.1a15e0	a0 00 00	ldy #$0000	            LDY #0
.1a15e3	e2 20		sep #$20	            SEP #$20
.1a15e5	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Copy the data to the allocated string
.1a15e7	97 08		sta [$0808],y	            STA [INDEX],Y
.1a15e9	f0 03		beq $1a15ee	            BEQ ret_copy
.1a15eb	c8		iny		            INY
.1a15ec	80 f7		bra $1a15e5	            BRA loop
.1a15ee					ret_copy
.1a15ee	c2 20		rep #$20	            REP #$20
.1a15f0	a5 08		lda $0808	            LDA INDEX
.1a15f2	85 23		sta $0823	            STA ARGUMENT1
.1a15f4	a5 0a		lda $080a	            LDA INDEX+2
.1a15f6	85 25		sta $0825	            STA ARGUMENT1+2
.1a15f8	c2 20		rep #$20	            REP #$20
.1a15fa	68		pla		            PLA
.1a15fb	85 08		sta $0808	            STA INDEX
.1a15fd	68		pla		            PLA
.1a15fe	85 0a		sta $080a	            STA INDEX+2
.1a1600	ab		plb		            PLB
.1a1601	2b		pld		            PLD
.1a1602	28		plp		            PLP
.1a1603	7a		ply		            PLY
.1a1604	fa		plx		            PLX
.1a1605	60		rts		            RTS
.1a1606					STRSUBSTR
.1a1606	08		php		            PHP
.1a1607	e2 20		sep #$20	            SEP #$20
.1a1609	c2 10		rep #$10	            REP #$10
.1a160b	a0 00 00	ldy #$0000	            LDY #0
.1a160e	b7 23		lda [$0823],y	count_loop  LDA [ARGUMENT1],Y
.1a1610	f0 05		beq $1a1617	            BEQ counted
.1a1612	c8		iny		            INY
.1a1613	80 f9		bra $1a160e	            BRA count_loop
.1a1615	84 92		sty $0892	            STY MTEMP               ; MTEMP := length of the source string
.1a1617					counted
.1a1617	c2 30		rep #$30	            REP #$30
.1a1619	c4 29		cpy $0829	            CPY ARGUMENT2           ; length of string <= index?
.1a161b	90 13		bcc $1a1630	            BLT ret_empty           ; Yes: return empty string
.1a161d	f0 11		beq $1a1630	            BEQ ret_empty
.1a161f	a5 8f		lda $088f	            LDA MCOUNT              ; Is the desired count <= 0?
.1a1621	30 0d		bmi $1a1630	            BMI ret_empty
.1a1623	f0 0b		beq $1a1630	            BEQ ret_empty           ; Yes: return the empty string
.1a1625	c4 8f		cpy $088f	            CPY MCOUNT              ; Is the desired length < the length of the source?
.1a1627	b0 12		bcs $1a163b	            BGE do_slice            ; Yes: go ahead and get the substring
.1a1629	a5 29		lda $0829	            LDA ARGUMENT2           ; Is INDEX == 0?
.1a162b	d0 0e		bne $1a163b	            BNE do_slice            ; No: do a slice
.1a162d	4c 84 16	jmp $1a1684	            JMP done                ; Yes: just return the source string
.1a1630					ret_empty
.1a1630	20 ae 13	jsr $1a13ae	            JSR TEMPSTRING
.1a1633	e2 20		sep #$20	            SEP #$20
.1a1635	a9 00		lda #$00	            LDA #0
.1a1637	87 16		sta [$0816]	            STA [STRPTR]
.1a1639	80 39		bra $1a1674	            BRA finish_copy
.1a163b					do_slice
.1a163b	20 ae 13	jsr $1a13ae	            JSR TEMPSTRING
.1a163e	c2 30		rep #$30	            REP #$30
.1a1640	18		clc		            CLC                     ; ARGUMENT1 := ARGUMENT1 + index
.1a1641	a5 23		lda $0823	            LDA ARGUMENT1
.1a1643	65 29		adc $0829	            ADC ARGUMENT2
.1a1645	85 23		sta $0823	            STA ARGUMENT1
.1a1647	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a1649	69 00 00	adc #$0000	            ADC #0
.1a164c	85 25		sta $0825	            STA ARGUMENT1+2
.1a164e	a0 00 00	ldy #$0000	            LDY #0
.1a1651					copy_loop
.1a1651	e2 20		sep #$20	            SEP #$20
.1a1653	a7 23		lda [$0823]	            LDA [ARGUMENT1]         ; Copy a character from the substring to the temporary string
.1a1655	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a1657	f0 1b		beq $1a1674	            BEQ finish_copy         ; If it is a NULL, we're done
.1a1659	c2 20		rep #$20	            REP #$20
.1a165b	18		clc		            CLC                     ; Move to the next character
.1a165c	a5 23		lda $0823	            LDA ARGUMENT1
.1a165e	69 01 00	adc #$0001	            ADC #1
.1a1661	85 23		sta $0823	            STA ARGUMENT1
.1a1663	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a1665	69 00 00	adc #$0000	            ADC #0
.1a1668	85 25		sta $0825	            STA ARGUMENT1+2
.1a166a	c8		iny		            INY
.1a166b	c4 8f		cpy $088f	            CPY MCOUNT              ; Have we reached the limit to copy?
.1a166d	d0 e2		bne $1a1651	            BNE copy_loop           ; No: copy the next byte
.1a166f	a9 00 00	lda #$0000	            LDA #0                  ; Null terminate string
.1a1672	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a1674					finish_copy
.1a1674	c2 20		rep #$20	            REP #$20
.1a1676	a5 16		lda $0816	            LDA STRPTR
.1a1678	85 23		sta $0823	            STA ARGUMENT1
.1a167a	a5 18		lda $0818	            LDA STRPTR+2
.1a167c	85 25		sta $0825	            STA ARGUMENT1+2
.1a167e	e2 20		sep #$20	            SEP #$20
.1a1680	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a1682	85 27		sta $0827	            STA ARGTYPE1
.1a1684					done
.1a1684	28		plp		            PLP
.1a1685	60		rts		            RTS
.1a1686					OP_STR_LT
.1a1686	08		php		            PHP
.1a1687	c2 30		rep #$30	            REP #$30
.1a1689	20 ad 14	jsr $1a14ad	            JSR STRCMP
.1a168c	a5 23		lda $0823	            LDA ARGUMENT1
.1a168e	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.1a1691	d0 05		bne $1a1698	            BNE ret_false               ; No: return false
.1a1693					ret_true
.1a1693	20 df 04	jsr $1a04df	            JSR SET_TRUE
.1a1696	80 03		bra $1a169b	            BRA done
.1a1698					ret_false
.1a1698	20 f1 04	jsr $1a04f1	            JSR SET_FALSE
.1a169b	28		plp		done        PLP
.1a169c	60		rts		            RTS
.1a169d					OP_STR_GT
.1a169d	08		php		            PHP
.1a169e	c2 30		rep #$30	            REP #$30
.1a16a0	20 ad 14	jsr $1a14ad	            JSR STRCMP
.1a16a3	a5 23		lda $0823	            LDA ARGUMENT1
.1a16a5	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.1a16a8	d0 05		bne $1a16af	            BNE ret_false               ; No: return false
.1a16aa					ret_true
.1a16aa	20 df 04	jsr $1a04df	            JSR SET_TRUE
.1a16ad	80 03		bra $1a16b2	            BRA done
.1a16af					ret_false
.1a16af	20 f1 04	jsr $1a04f1	            JSR SET_FALSE
.1a16b2	28		plp		done        PLP
.1a16b3	60		rts		            RTS
.1a16b4					OP_STR_EQ
.1a16b4	08		php		            PHP
.1a16b5	c2 30		rep #$30	            REP #$30
.1a16b7	20 ad 14	jsr $1a14ad	            JSR STRCMP
.1a16ba	a5 23		lda $0823	            LDA ARGUMENT1
.1a16bc	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.1a16bf	d0 05		bne $1a16c6	            BNE ret_false               ; No: return false
.1a16c1					ret_true
.1a16c1	20 df 04	jsr $1a04df	            JSR SET_TRUE
.1a16c4	80 03		bra $1a16c9	            BRA done
.1a16c6					ret_false
.1a16c6	20 f1 04	jsr $1a04f1	            JSR SET_FALSE
.1a16c9	28		plp		done        PLP
.1a16ca	60		rts		            RTS
.1a16cb					OP_STR_NE
.1a16cb	08		php		            PHP
.1a16cc	c2 30		rep #$30	            REP #$30
.1a16ce	20 ad 14	jsr $1a14ad	            JSR STRCMP
.1a16d1	a5 23		lda $0823	            LDA ARGUMENT1
.1a16d3	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.1a16d6	f0 05		beq $1a16dd	            BEQ ret_false               ; Yes: return false
.1a16d8					ret_true
.1a16d8	20 df 04	jsr $1a04df	            JSR SET_TRUE
.1a16db	80 03		bra $1a16e0	            BRA done
.1a16dd					ret_false
.1a16dd	20 f1 04	jsr $1a04f1	            JSR SET_FALSE
.1a16e0	28		plp		done        PLP
.1a16e1	60		rts		            RTS
.1a16e2					OP_STR_GTE
.1a16e2	08		php		            PHP
.1a16e3	c2 30		rep #$30	            REP #$30
.1a16e5	20 ad 14	jsr $1a14ad	            JSR STRCMP
.1a16e8	a5 23		lda $0823	            LDA ARGUMENT1
.1a16ea	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.1a16ed	f0 05		beq $1a16f4	            BEQ ret_false               ; Yes: return false
.1a16ef					ret_true
.1a16ef	20 df 04	jsr $1a04df	            JSR SET_TRUE
.1a16f2	80 03		bra $1a16f7	            BRA done
.1a16f4					ret_false
.1a16f4	20 f1 04	jsr $1a04f1	            JSR SET_FALSE
.1a16f7	28		plp		done        PLP
.1a16f8	60		rts		            RTS
.1a16f9					OP_STR_LTE
.1a16f9	08		php		            PHP
.1a16fa	c2 30		rep #$30	            REP #$30
.1a16fc	20 ad 14	jsr $1a14ad	            JSR STRCMP
.1a16ff	a5 23		lda $0823	            LDA ARGUMENT1
.1a1701	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.1a1704	f0 05		beq $1a170b	            BEQ ret_false               ; Yes: return false
.1a1706					ret_true
.1a1706	20 df 04	jsr $1a04df	            JSR SET_TRUE
.1a1709	80 03		bra $1a170e	            BRA done
.1a170b					ret_false
.1a170b	20 f1 04	jsr $1a04f1	            JSR SET_FALSE
.1a170e	28		plp		done        PLP
.1a170f	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\listing.s

.1a1710					LISTPROG
.1a1710	48		pha		            PHA
.1a1711	5a		phy		            PHY
.1a1712	0b		phd		            PHD
.1a1713	08		php		            PHP
.1a1714	08		php		            PHP
.1a1715	c2 20		rep #$20	            REP #$20
.1a1717	48		pha		            PHA
.1a1718	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a171b	5b		tcd		            TCD
.1a171c	68		pla		            PLA
.1a171d	28		plp		            PLP
.1a171e	c2 30		rep #$30	            REP #$30
.1a1720	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.1a1723	85 00		sta $0800	            STA BIP
.1a1725	85 1a		sta $081a	            STA CURLINE
.1a1727	a9 16 00	lda #$0016	            LDA #`BASIC_BOT
.1a172a	85 02		sta $0802	            STA BIP+2
.1a172c	85 1c		sta $081c	            STA CURLINE+2
.1a172e	ad 8a 0f	lda $0f8a	list_loop   LDA KEYFLAG         ; Check the keyboard flags
.1a1731	30 20		bmi $1a1753	            BMI throw_break     ; If MSB: user pressed an interrupt key, stop the listing
.1a1733	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.1a1736	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.1a1738	f0 0f		beq $1a1749	            BEQ done
.1a173a	c5 55		cmp $0855	            CMP MARG1
.1a173c	90 10		bcc $1a174e	            BLT skip_line
.1a173e	c5 59		cmp $0859	            CMP MARG2
.1a1740	f0 02		beq $1a1744	            BEQ print_line
.1a1742	b0 05		bcs $1a1749	            BGE done
.1a1744					print_line
.1a1744	20 72 17	jsr $1a1772	            JSR LISTLINE
.1a1747	80 e5		bra $1a172e	            BRA list_loop
.1a1749	28		plp		done        PLP
.1a174a	2b		pld		            PLD
.1a174b	7a		ply		            PLY
.1a174c	68		pla		            PLA
.1a174d	60		rts		            RTS
.1a174e					skip_line
.1a174e	20 3b 20	jsr $1a203b	            JSR NEXTLINE
.1a1751	80 db		bra $1a172e	            BRA list_loop           ; And try again
.1a1753					throw_break
.1a1753	08		php		            PHP
.1a1754	c2 20		rep #$20	            REP #$20
.1a1756	48		pha		            PHA
.1a1757	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a175a	5b		tcd		            TCD
.1a175b	68		pla		            PLA
.1a175c	28		plp		            PLP
.1a175d	e2 20		sep #$20	            SEP #$20
.1a175f	a9 01		lda #$01	            LDA #ERR_BREAK
.1a1761	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1765	c2 20		rep #$20	            REP #$20
.1a1767	29 ff 00	and #$00ff	            AND #$00FF
.1a176a	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a176d	e2 20		sep #$20	            SEP #$20
.1a176f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1772					LISTLINE
.1a1772	08		php		            PHP
.1a1773	c2 30		rep #$30	            REP #$30
.1a1775	85 23		sta $0823	            STA ARGUMENT1
.1a1777	64 25		stz $0825	            STZ ARGUMENT1+2
.1a1779	20 0d 14	jsr $1a140d	            JSR ITOS
.1a177c	a5 16		lda $0816	            LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.1a177e	1a		inc a		            INC A
.1a177f	85 23		sta $0823	            STA ARGUMENT1
.1a1781	a5 18		lda $0818	            LDA STRPTR+2
.1a1783	85 25		sta $0825	            STA ARGUMENT1+2
.1a1785	20 e7 43	jsr $1a43e7	            JSR PR_STRING
.1a1788	18		clc		            CLC                 ; Move the BIP to the first byte of the line
.1a1789	a5 1a		lda $081a	            LDA CURLINE
.1a178b	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a178e	85 00		sta $0800	            STA BIP
.1a1790	a5 1c		lda $081c	            LDA CURLINE+2
.1a1792	69 00 00	adc #$0000	            ADC #0
.1a1795	85 02		sta $0802	            STA BIP+2
.1a1797	e2 20		sep #$20	            SEP #$20
.1a1799	a9 20		lda #$20	            LDA #CHAR_SP
.1a179b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a179e	c2 20		rep #$20	            REP #$20
.1a17a0					loop
.1a17a0	20 b1 17	jsr $1a17b1	            JSR LISTBYTE
.1a17a3	90 fb		bcc $1a17a0	            BCC loop
.1a17a5	e2 20		sep #$20	            SEP #$20
.1a17a7	a9 0d		lda #$0d	            LDA #CHAR_CR
.1a17a9	20 18 00	jsr $1a0018	            JSR PRINTC
.1a17ac	20 3b 20	jsr $1a203b	            JSR NEXTLINE
.1a17af	28		plp		            PLP
.1a17b0	60		rts		            RTS
.1a17b1					LISTBYTE
.1a17b1	08		php		            PHP
.1a17b2	0b		phd		            PHD
.1a17b3	8b		phb		            PHB
.1a17b4	08		php		            PHP
.1a17b5	c2 20		rep #$20	            REP #$20
.1a17b7	48		pha		            PHA
.1a17b8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a17bb	5b		tcd		            TCD
.1a17bc	68		pla		            PLA
.1a17bd	28		plp		            PLP
.1a17be	08		php		            PHP
.1a17bf	e2 20		sep #$20	            SEP #$20
.1a17c1	48		pha		            PHA
.1a17c2	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a17c4	48		pha		            PHA
.1a17c5	ab		plb		            PLB
.1a17c6	68		pla		            PLA
.1a17c7	28		plp		            PLP
.1a17c8	e2 20		sep #$20	            SEP #$20
.1a17ca	c2 10		rep #$10	            REP #$10
.1a17cc	a7 00		lda [$0800]	            LDA [BIP]           ; Get the current byte
.1a17ce	f0 3a		beq $1a180a	            BEQ end_of_line     ; If it's 0, return with C set
.1a17d0	30 05		bmi $1a17d7	            BMI is_token        ; If it's 0x80 - 0xFF, it's a token
.1a17d2	20 18 00	jsr $1a0018	            JSR PRINTC
.1a17d5	80 29		bra $1a1800	            BRA done            ; And return
.1a17d7					is_token
.1a17d7	c2 20		rep #$20	            REP #$20
.1a17d9	29 7f 00	and #$007f	            AND #$007F          ; Compute the index of the token
.1a17dc	0a		asl a		            ASL A               ; In the token table
.1a17dd	0a		asl a		            ASL A
.1a17de	0a		asl a		            ASL A
.1a17df	18		clc		            CLC
.1a17e0	69 b0 0b	adc #$0bb0	            ADC #<>TOKENS       ; Set INDEX to the address of the token
.1a17e3	85 08		sta $0808	            STA INDEX
.1a17e5	a9 1a 00	lda #$001a	            LDA #`TOKENS
.1a17e8	69 00 00	adc #$0000	            ADC #0
.1a17eb	85 0a		sta $080a	            STA INDEX+2
.1a17ed					pr_default
.1a17ed	08		php		            PHP
.1a17ee	e2 20		sep #$20	            SEP #$20
.1a17f0	48		pha		            PHA
.1a17f1	a9 1a		lda #$1a	            LDA #`TOKENS
.1a17f3	48		pha		            PHA
.1a17f4	ab		plb		            PLB
.1a17f5	68		pla		            PLA
.1a17f6	28		plp		            PLP
.1a17f7	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.1a17fa	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a17fc	aa		tax		            TAX
.1a17fd	20 16 03	jsr $1a0316	            JSR PRINTS
.1a1800					done
.1a1800	c2 20		rep #$20	            REP #$20
.1a1802	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a1805	ab		plb		            PLB
.1a1806	2b		pld		            PLD
.1a1807	28		plp		            PLP
.1a1808	18		clc		            CLC
.1a1809	60		rts		            RTS
.1a180a	ab		plb		end_of_line PLB
.1a180b	2b		pld		            PLD
.1a180c	28		plp		            PLP
.1a180d	38		sec		            SEC
.1a180e	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\eval.s

.1a180f					INITEVALSP
.1a180f	08		php		            PHP
.1a1810	c2 20		rep #$20	            REP #$20
.1a1812	a9 ff 6f	lda #$6fff	            LDA #ARGUMENT_TOP
.1a1815	85 1f		sta $081f	            STA ARGUMENTSP
.1a1817	a9 ff 7f	lda #$7fff	            LDA #OPERATOR_TOP
.1a181a	85 21		sta $0821	            STA OPERATORSP
.1a181c	a9 ff ff	lda #$ffff	            LDA #$FFFF
.1a181f	85 23		sta $0823	            STA ARGUMENT1
.1a1821	85 25		sta $0825	            STA ARGUMENT1+2
.1a1823	85 29		sta $0829	            STA ARGUMENT2
.1a1825	85 2b		sta $082b	            STA ARGUMENT2+2
.1a1827	e2 20		sep #$20	            SEP #$20
.1a1829	85 27		sta $0827	            STA ARGTYPE1
.1a182b	85 2d		sta $082d	            STA ARGTYPE2
.1a182d	28		plp		            PLP
.1a182e	60		rts		            RTS
.1a182f					PHARGUMENT
.1a182f	08		php		            PHP
.1a1830	0b		phd		            PHD
.1a1831	8b		phb		            PHB
.1a1832	08		php		            PHP
.1a1833	c2 20		rep #$20	            REP #$20
.1a1835	48		pha		            PHA
.1a1836	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1839	5b		tcd		            TCD
.1a183a	68		pla		            PLA
.1a183b	28		plp		            PLP
.1a183c	08		php		            PHP
.1a183d	e2 20		sep #$20	            SEP #$20
.1a183f	48		pha		            PHA
.1a1840	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1842	48		pha		            PHA
.1a1843	ab		plb		            PLB
.1a1844	68		pla		            PLA
.1a1845	28		plp		            PLP
.1a1846	c2 30		rep #$30	            REP #$30
.1a1848	5a		phy		            PHY
.1a1849	a4 1f		ldy $081f	            LDY ARGUMENTSP
.1a184b	bd 00 00	lda $0000,x	            LDA #0,B,X
.1a184e	99 00 00	sta $0000,y	            STA #0,B,Y
.1a1851	bd 02 00	lda $0002,x	            LDA #2,B,X
.1a1854	99 02 00	sta $0002,y	            STA #2,B,Y
.1a1857	e2 20		sep #$20	            SEP #$20
.1a1859	bd 04 00	lda $0004,x	            LDA #4,B,X
.1a185c	99 04 00	sta $0004,y	            STA #4,B,Y
.1a185f	c2 20		rep #$20	            REP #$20
.1a1861	38		sec		            SEC
.1a1862	98		tya		            TYA
.1a1863	e9 05 00	sbc #$0005	            SBC #ARGUMENT_SIZE
.1a1866	85 1f		sta $081f	            STA ARGUMENTSP
.1a1868	7a		ply		            PLY
.1a1869	ab		plb		            PLB
.1a186a	2b		pld		            PLD
.1a186b	28		plp		            PLP
.1a186c	60		rts		            RTS
.1a186d					PLARGUMENT
.1a186d	08		php		            PHP
.1a186e	0b		phd		            PHD
.1a186f	8b		phb		            PHB
.1a1870	08		php		            PHP
.1a1871	c2 20		rep #$20	            REP #$20
.1a1873	48		pha		            PHA
.1a1874	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1877	5b		tcd		            TCD
.1a1878	68		pla		            PLA
.1a1879	28		plp		            PLP
.1a187a	08		php		            PHP
.1a187b	e2 20		sep #$20	            SEP #$20
.1a187d	48		pha		            PHA
.1a187e	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1880	48		pha		            PHA
.1a1881	ab		plb		            PLB
.1a1882	68		pla		            PLA
.1a1883	28		plp		            PLP
.1a1884	c2 30		rep #$30	            REP #$30
.1a1886	5a		phy		            PHY
.1a1887	18		clc		            CLC
.1a1888	a5 1f		lda $081f	            LDA ARGUMENTSP
.1a188a	69 05 00	adc #$0005	            ADC #ARGUMENT_SIZE
.1a188d	85 1f		sta $081f	            STA ARGUMENTSP
.1a188f	a8		tay		            TAY
.1a1890	b9 00 00	lda $0000,y	            LDA #0,B,Y
.1a1893	9d 00 00	sta $0000,x	            STA #0,B,X
.1a1896	b9 02 00	lda $0002,y	            LDA #2,B,Y
.1a1899	9d 02 00	sta $0002,x	            STA #2,B,X
.1a189c	e2 20		sep #$20	            SEP #$20
.1a189e	b9 04 00	lda $0004,y	            LDA #4,B,Y
.1a18a1	9d 04 00	sta $0004,x	            STA #4,B,X
.1a18a4	bd 00 00	lda $0000,x	            LDA #0,B,X
.1a18a7	7a		ply		            PLY
.1a18a8	ab		plb		            PLB
.1a18a9	2b		pld		            PLD
.1a18aa	28		plp		            PLP
.1a18ab	60		rts		            RTS
.1a18ac					PHOPERATOR
.1a18ac	08		php		            PHP
.1a18ad	0b		phd		            PHD
.1a18ae	8b		phb		            PHB
.1a18af	08		php		            PHP
.1a18b0	c2 20		rep #$20	            REP #$20
.1a18b2	48		pha		            PHA
.1a18b3	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a18b6	5b		tcd		            TCD
.1a18b7	68		pla		            PLA
.1a18b8	28		plp		            PLP
.1a18b9	08		php		            PHP
.1a18ba	e2 20		sep #$20	            SEP #$20
.1a18bc	48		pha		            PHA
.1a18bd	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a18bf	48		pha		            PHA
.1a18c0	ab		plb		            PLB
.1a18c1	68		pla		            PLA
.1a18c2	28		plp		            PLP
.1a18c3	e2 20		sep #$20	            SEP #$20
.1a18c5	c2 10		rep #$10	            REP #$10
.1a18c7	5a		phy		            PHY
.1a18c8	a4 21		ldy $0821	            LDY OPERATORSP
.1a18ca	99 00 00	sta $0000,y	            STA #0,B,Y
.1a18cd	88		dey		            DEY
.1a18ce	84 21		sty $0821	            STY OPERATORSP
.1a18d0	7a		ply		done        PLY
.1a18d1	ab		plb		            PLB
.1a18d2	2b		pld		            PLD
.1a18d3	28		plp		            PLP
.1a18d4	60		rts		            RTS
.1a18d5					PLOPERATOR
.1a18d5	08		php		            PHP
.1a18d6	0b		phd		            PHD
.1a18d7	8b		phb		            PHB
.1a18d8	08		php		            PHP
.1a18d9	c2 20		rep #$20	            REP #$20
.1a18db	48		pha		            PHA
.1a18dc	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a18df	5b		tcd		            TCD
.1a18e0	68		pla		            PLA
.1a18e1	28		plp		            PLP
.1a18e2	08		php		            PHP
.1a18e3	e2 20		sep #$20	            SEP #$20
.1a18e5	48		pha		            PHA
.1a18e6	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a18e8	48		pha		            PHA
.1a18e9	ab		plb		            PLB
.1a18ea	68		pla		            PLA
.1a18eb	28		plp		            PLP
.1a18ec	e2 20		sep #$20	            SEP #$20
.1a18ee	c2 10		rep #$10	            REP #$10
.1a18f0	5a		phy		            PHY
.1a18f1	a4 21		ldy $0821	            LDY OPERATORSP
.1a18f3	c8		iny		            INY
.1a18f4	84 21		sty $0821	            STY OPERATORSP
.1a18f6	b9 00 00	lda $0000,y	            LDA #0,B,Y
.1a18f9	c2 20		rep #$20	            REP #$20
.1a18fb	29 ff 00	and #$00ff	            AND #$00FF
.1a18fe	7a		ply		            PLY
.1a18ff	ab		plb		            PLB
.1a1900	2b		pld		            PLD
.1a1901	28		plp		            PLP
.1a1902	60		rts		            RTS
.1a1903					OPENPARAMS
.1a1903	08		php		            PHP
.1a1904	e2 20		sep #$20	            SEP #$20
.1a1906	a9 01		lda #$01	            LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.1a1908	20 ac 18	jsr $1a18ac	            JSR PHOPERATOR
.1a190b	28		plp		            PLP
.1a190c	60		rts		            RTS
.1a190d					CLOSEPARAMS
.1a190d	5a		phy		            PHY
.1a190e	08		php		            PHP
.1a190f	8b		phb		            PHB
.1a1910	08		php		            PHP
.1a1911	e2 20		sep #$20	            SEP #$20
.1a1913	48		pha		            PHA
.1a1914	a9 00		lda #$00	            LDA #0
.1a1916	48		pha		            PHA
.1a1917	ab		plb		            PLB
.1a1918	68		pla		            PLA
.1a1919	28		plp		            PLP
.1a191a	e2 20		sep #$20	            SEP #$20
.1a191c	a4 21		ldy $0821	            LDY OPERATORSP      ; Peek at the top operator
.1a191e	b9 01 00	lda $0001,y	            LDA #1,B,Y
.1a1921	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the marker for the start of a parameter list
.1a1923	d0 08		bne $1a192d	            BNE error           ; No: there's a problem
.1a1925	c2 20		rep #$20	            REP #$20
.1a1927	e6 21		inc $0821	            INC OPERATORSP      ; Yes: remove it from the operator stack.
.1a1929	ab		plb		            PLB
.1a192a	28		plp		            PLP
.1a192b	7a		ply		            PLY
.1a192c	60		rts		            RTS
.1a192d					error
.1a192d	08		php		            PHP
.1a192e	c2 20		rep #$20	            REP #$20
.1a1930	48		pha		            PHA
.1a1931	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1934	5b		tcd		            TCD
.1a1935	68		pla		            PLA
.1a1936	28		plp		            PLP
.1a1937	e2 20		sep #$20	            SEP #$20
.1a1939	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a193b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a193f	c2 20		rep #$20	            REP #$20
.1a1941	29 ff 00	and #$00ff	            AND #$00FF
.1a1944	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a1947	e2 20		sep #$20	            SEP #$20
.1a1949	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a194c					OPHIGHPREC
.1a194c	48		pha		            PHA
.1a194d	08		php		            PHP
.1a194e	0b		phd		            PHD
.1a194f	8b		phb		            PHB
.1a1950	08		php		            PHP
.1a1951	c2 20		rep #$20	            REP #$20
.1a1953	48		pha		            PHA
.1a1954	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1957	5b		tcd		            TCD
.1a1958	68		pla		            PLA
.1a1959	28		plp		            PLP
.1a195a	08		php		            PHP
.1a195b	e2 20		sep #$20	            SEP #$20
.1a195d	48		pha		            PHA
.1a195e	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1960	48		pha		            PHA
.1a1961	ab		plb		            PLB
.1a1962	68		pla		            PLA
.1a1963	28		plp		            PLP
.1a1964	e2 20		sep #$20	            SEP #$20
.1a1966	a4 21		ldy $0821	            LDY OPERATORSP
.1a1968	c0 ff 7f	cpy #$7fff	            CPY #OPERATOR_TOP       ; Is the stack empty?
.1a196b	f0 11		beq $1a197e	            BEQ is_false            ; Yes: return false
.1a196d	20 0f 0b	jsr $1a0b0f	            JSR TOKPRECED
.1a1970	85 0c		sta $080c	            STA SCRATCH             ; Save it for later comparison
.1a1972	b9 01 00	lda $0001,y	            LDA #1,B,Y              ; Get the operator at the top of the stack
.1a1975	20 0f 0b	jsr $1a0b0f	            JSR TOKPRECED
.1a1978	c5 0c		cmp $080c	            CMP SCRATCH             ; Compare the priorities (0 = highest priority)
.1a197a	f0 02		beq $1a197e	            BEQ is_false            ; A = SCRATCH, return false
.1a197c	90 08		bcc $1a1986	            BCC is_true             ; A < SCRATCH (A is higher priority), return false
.1a197e					is_false
.1a197e	c2 20		rep #$20	            REP #$20
.1a1980	ab		plb		            PLB
.1a1981	2b		pld		            PLD
.1a1982	28		plp		            PLP
.1a1983	68		pla		            PLA
.1a1984	18		clc		            CLC
.1a1985	60		rts		            RTS
.1a1986					is_true
.1a1986	c2 20		rep #$20	            REP #$20
.1a1988	ab		plb		            PLB                     ; A > SCRATCH (A is lower priority), return true
.1a1989	2b		pld		            PLD
.1a198a	28		plp		            PLP
.1a198b	68		pla		            PLA
.1a198c	38		sec		            SEC
.1a198d	60		rts		            RTS
.1a198e					EVALNUMBER
.1a198e	4c 8a 07	jmp $1a078a	            JMP PARSEINT
.1a1991					ARR_GETIDX
.1a1991	08		php		            PHP
.1a1992	e2 20		sep #$20	            SEP #$20
.1a1994	a9 00		lda #$00	            LDA #0
.1a1996	8f 00 4d 00	sta $004d00	            STA @lARRIDXBUF     ; Set the dimension to 0
.1a199a	a2 01 00	ldx #$0001	            LDX #1
.1a199d					eval_index
.1a199d	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a19a0	20 bf 05	jsr $1a05bf	            JSR ASS_ARG1_INT16
.1a19a3	c2 20		rep #$20	            REP #$20
.1a19a5	a5 23		lda $0823	            LDA ARGUMENT1       ; Save the index to the array index buffer
.1a19a7	9f 00 4d 00	sta $004d00,x	            STA @lARRIDXBUF,X
.1a19ab	e2 20		sep #$20	            SEP #$20
.1a19ad	af 00 4d 00	lda $004d00	            LDA @lARRIDXBUF     ; Increment the index count
.1a19b1	1a		inc a		            INC A
.1a19b2	30 3e		bmi $1a19f2	            BMI arg_err         ; If more than 127 dimensions, throw a range error
.1a19b4	8f 00 4d 00	sta $004d00	            STA @lARRIDXBUF
.1a19b8	e8		inx		            INX
.1a19b9	e8		inx		            INX
.1a19ba	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a19bd	e2 20		sep #$20	            SEP #$20
.1a19bf	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.1a19c1	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it ")"
.1a19c3	f0 09		beq $1a19ce	            BEQ clean_op        ; Yes: cleanup the argument stack
.1a19c5	c9 2c		cmp #$2c	            CMP #','            ; Is it a comma?
.1a19c7	d0 0a		bne $1a19d3	            BNE syntax_err      ; No: throw a syntax error
.1a19c9					skip_comma
.1a19c9	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a19cc	80 cf		bra $1a199d	            BRA eval_index      ; And grab the next index
.1a19ce					clean_op
.1a19ce	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a19d1	28		plp		            PLP
.1a19d2	60		rts		            RTS
.1a19d3					syntax_err
.1a19d3	08		php		            PHP
.1a19d4	c2 20		rep #$20	            REP #$20
.1a19d6	48		pha		            PHA
.1a19d7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a19da	5b		tcd		            TCD
.1a19db	68		pla		            PLA
.1a19dc	28		plp		            PLP
.1a19dd	e2 20		sep #$20	            SEP #$20
.1a19df	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a19e1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a19e5	c2 20		rep #$20	            REP #$20
.1a19e7	29 ff 00	and #$00ff	            AND #$00FF
.1a19ea	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a19ed	e2 20		sep #$20	            SEP #$20
.1a19ef	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a19f2					arg_err
.1a19f2	08		php		            PHP
.1a19f3	c2 20		rep #$20	            REP #$20
.1a19f5	48		pha		            PHA
.1a19f6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a19f9	5b		tcd		            TCD
.1a19fa	68		pla		            PLA
.1a19fb	28		plp		            PLP
.1a19fc	e2 20		sep #$20	            SEP #$20
.1a19fe	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a1a00	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1a04	c2 20		rep #$20	            REP #$20
.1a1a06	29 ff 00	and #$00ff	            AND #$00FF
.1a1a09	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a1a0c	e2 20		sep #$20	            SEP #$20
.1a1a0e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1a11					EVALREF
.1a1a11	08		php		            PHP
.1a1a12					get_name
.1a1a12	20 8d 51	jsr $1a518d	            JSR VAR_FINDNAME
.1a1a15	90 23		bcc $1a1a3a	            BCC syntax_err      ; If we didn't find a name, thrown an error
.1a1a17	e2 20		sep #$20	            SEP #$20
.1a1a19	a5 ea		lda $08ea	            LDA TOFINDTYPE      ; Check the type of the variable
.1a1a1b	29 80		and #$80	            AND #$80            ; Is it an array?
.1a1a1d	d0 06		bne $1a1a25	            BNE is_array        ; Yes: look for the indexes
.1a1a1f	20 8e 4f	jsr $1a4f8e	            JSR VAR_REF
.1a1a22	4c 38 1a	jmp $1a1a38	            JMP done
.1a1a25					is_array
.1a1a25	e2 20		sep #$20	            SEP #$20
.1a1a27	a9 8f		lda #$8f	            LDA #TOK_LPAREN
.1a1a29	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a1a2c	20 03 19	jsr $1a1903	            JSR OPENPARAMS
.1a1a2f					            PHARRIDX
.1a1a2f	20 91 19	jsr $1a1991	            JSR ARR_GETIDX
.1a1a32	20 44 66	jsr $1a6644	            JSR ARR_REF
.1a1a35					            PLARRIDX
.1a1a35	20 0d 19	jsr $1a190d	            JSR CLOSEPARAMS
.1a1a38	28		plp		done        PLP
.1a1a39	60		rts		            RTS
.1a1a3a					syntax_err
.1a1a3a	08		php		            PHP
.1a1a3b	c2 20		rep #$20	            REP #$20
.1a1a3d	48		pha		            PHA
.1a1a3e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1a41	5b		tcd		            TCD
.1a1a42	68		pla		            PLA
.1a1a43	28		plp		            PLP
.1a1a44	e2 20		sep #$20	            SEP #$20
.1a1a46	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1a48	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1a4c	c2 20		rep #$20	            REP #$20
.1a1a4e	29 ff 00	and #$00ff	            AND #$00FF
.1a1a51	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a1a54	e2 20		sep #$20	            SEP #$20
.1a1a56	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1a59					EVALSTRING
.1a1a59	08		php		            PHP
.1a1a5a	0b		phd		            PHD
.1a1a5b	08		php		            PHP
.1a1a5c	c2 20		rep #$20	            REP #$20
.1a1a5e	48		pha		            PHA
.1a1a5f	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1a62	5b		tcd		            TCD
.1a1a63	68		pla		            PLA
.1a1a64	28		plp		            PLP
.1a1a65	e2 20		sep #$20	            SEP #$20
.1a1a67	c2 10		rep #$10	            REP #$10
.1a1a69	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a1a6c	a0 00 00	ldy #$0000	            LDY #0              ; Ywill be our length counter
.1a1a6f	b7 00		lda [$0800],y	count_loop  LDA [BIP],Y         ; Get the character
.1a1a71	f0 24		beq $1a1a97	            BEQ error           ; If it's end-of-line, throw an error
.1a1a73	c9 22		cmp #$22	            CMP #CHAR_DQUOTE    ; Is it the ending double-quote?
.1a1a75	f0 03		beq $1a1a7a	            BEQ found_end       ; Yes: Y should be the length
.1a1a77	c8		iny		            INY
.1a1a78	80 f5		bra $1a1a6f	            BRA count_loop
.1a1a7a	84 0c		sty $080c	found_end   STY SCRATCH         ; Save the length to SCRATCH
.1a1a7c	e2 20		sep #$20	            SEP #$20
.1a1a7e	a9 02		lda #$02	            LDA #TYPE_STRING    ; Set the type to allocate to STRING
.1a1a80	a6 0c		ldx $080c	            LDX SCRATCH         ; And the length to the length of the string literal
.1a1a82	e8		inx		            INX
.1a1a83	20 ae 13	jsr $1a13ae	            JSR TEMPSTRING
.1a1a86	a0 00 00	ldy #$0000	            LDY #0
.1a1a89	c4 0c		cpy $080c	copy_loop   CPY SCRATCH         ; Have we copied all the characters?
.1a1a8b	f0 29		beq $1a1ab6	            BEQ done            ; Yes: we're done
.1a1a8d	a7 00		lda [$0800]	            LDA [BIP]           ; No: get the next character
.1a1a8f	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And copy it to the allocated string
.1a1a91	c8		iny		            INY
.1a1a92	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a1a95	80 f2		bra $1a1a89	            BRA copy_loop       ; And try the next character
.1a1a97					error
.1a1a97	08		php		            PHP
.1a1a98	c2 20		rep #$20	            REP #$20
.1a1a9a	48		pha		            PHA
.1a1a9b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1a9e	5b		tcd		            TCD
.1a1a9f	68		pla		            PLA
.1a1aa0	28		plp		            PLP
.1a1aa1	e2 20		sep #$20	            SEP #$20
.1a1aa3	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a1aa5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a1aa9	c2 20		rep #$20	            REP #$20
.1a1aab	29 ff 00	and #$00ff	            AND #$00FF
.1a1aae	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a1ab1	e2 20		sep #$20	            SEP #$20
.1a1ab3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a1ab6	a9 00		lda #$00	done        LDA #0
.1a1ab8	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a1aba	c2 20		rep #$20	            REP #$20
.1a1abc	a5 16		lda $0816	            LDA STRPTR
.1a1abe	85 23		sta $0823	            STA ARGUMENT1
.1a1ac0	a5 18		lda $0818	            LDA STRPTR+2
.1a1ac2	85 25		sta $0825	            STA ARGUMENT1+2
.1a1ac4	a9 02 00	lda #$0002	            LDA #TYPE_STRING    ; And set the type of ARGUMENT1 to string
.1a1ac7	85 27		sta $0827	            STA ARGTYPE1
.1a1ac9	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a1acc	2b		pld		            PLD
.1a1acd	28		plp		            PLP
.1a1ace	60		rts		            RTS
.1a1acf					EVAL_FUNC
.1a1acf	08		php		            PHP
.1a1ad0	e2 20		sep #$20	            SEP #$20
.1a1ad2	a7 00		lda [$0800]	            LDA [BIP]           ; Get the token
.1a1ad4	c2 20		rep #$20	            REP #$20
.1a1ad6	29 ff 00	and #$00ff	            AND #$00FF
.1a1ad9	20 39 0b	jsr $1a0b39	            JSR TOKEVAL
.1a1adc	85 2f		sta $082f	            STA JMP16PTR
.1a1ade	20 03 19	jsr $1a1903	            JSR OPENPARAMS
.1a1ae1	08		php		            PHP
.1a1ae2	e2 20		sep #$20	            SEP #$20
.1a1ae4	48		pha		            PHA
.1a1ae5	a9 00		lda #$00	            LDA #0
.1a1ae7	48		pha		            PHA
.1a1ae8	ab		plb		            PLB
.1a1ae9	68		pla		            PLA
.1a1aea	28		plp		            PLP
.1a1aeb	20 f3 1a	jsr $1a1af3	            JSR OPSTUB
.1a1aee	20 0d 19	jsr $1a190d	            JSR CLOSEPARAMS
.1a1af1	28		plp		            PLP
.1a1af2	60		rts		            RTS
.1a1af3					OPSTUB
.1a1af3	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a1af6	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.1a1af9					PROCESSOP
.1a1af9	48		pha		            PHA
.1a1afa	08		php		            PHP
.1a1afb	0b		phd		            PHD
.1a1afc	8b		phb		            PHB
.1a1afd	08		php		            PHP
.1a1afe	c2 20		rep #$20	            REP #$20
.1a1b00	48		pha		            PHA
.1a1b01	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1b04	5b		tcd		            TCD
.1a1b05	68		pla		            PLA
.1a1b06	28		plp		            PLP
.1a1b07	c2 30		rep #$30	            REP #$30
.1a1b09	20 d5 18	jsr $1a18d5	            JSR PLOPERATOR
.1a1b0c	89 80 00	bit #$0080	            BIT #$80            ; Check if it's really a token
.1a1b0f	f0 37		beq $1a1b48	            BEQ bad_token       ; No: it's a bad token
.1a1b11	48		pha		            PHA
.1a1b12	20 39 0b	jsr $1a0b39	            JSR TOKEVAL
.1a1b15	85 2f		sta $082f	            STA JMP16PTR
.1a1b17	68		pla		            PLA
.1a1b18	20 86 0b	jsr $1a0b86	            JSR TOKARITY
.1a1b1b	c9 01 00	cmp #$0001	            CMP #1              ; Check the operator's arity
.1a1b1e	f0 08		beq $1a1b28	            BEQ pull_arg1       ; If it's 1 just pull one argument from the stack
.1a1b20	c2 30		rep #$30	            REP #$30
.1a1b22	a2 29 08	ldx #$0829	            LDX #<>ARGUMENT2    ; Pull argument 2 from the stack
.1a1b25	20 6d 18	jsr $1a186d	            JSR PLARGUMENT
.1a1b28					pull_arg1
.1a1b28	c2 30		rep #$30	            REP #$30
.1a1b2a	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Pull argument 1 from the stack
.1a1b2d	20 6d 18	jsr $1a186d	            JSR PLARGUMENT
.1a1b30	08		php		            PHP
.1a1b31	e2 20		sep #$20	            SEP #$20
.1a1b33	48		pha		            PHA
.1a1b34	a9 00		lda #$00	            LDA #0
.1a1b36	48		pha		            PHA
.1a1b37	ab		plb		            PLB
.1a1b38	68		pla		            PLA
.1a1b39	28		plp		            PLP
.1a1b3a	20 4a 1b	jsr $1a1b4a	            JSR OPSTUB
.1a1b3d	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Get return result in argument 1
.1a1b40	20 2f 18	jsr $1a182f	            JSR PHARGUMENT
.1a1b43	ab		plb		            PLB
.1a1b44	2b		pld		            PLD
.1a1b45	28		plp		            PLP
.1a1b46	68		pla		            PLA
.1a1b47	60		rts		            RTS
.1a1b48	00		brk #		bad_token   BRK
.1a1b49	ea		nop		            NOP
.1a1b4a	6c 2f 08	jmp ($082f)	OPSTUB      JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.1a1b4d					EVALEXPR
.1a1b4d	08		php		            PHP
.1a1b4e	08		php		            PHP
.1a1b4f	c2 20		rep #$20	            REP #$20
.1a1b51	48		pha		            PHA
.1a1b52	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1b55	5b		tcd		            TCD
.1a1b56	68		pla		            PLA
.1a1b57	28		plp		            PLP
.1a1b58	08		php		            PHP
.1a1b59	e2 20		sep #$20	            SEP #$20
.1a1b5b	48		pha		            PHA
.1a1b5c	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a1b5e	48		pha		            PHA
.1a1b5f	ab		plb		            PLB
.1a1b60	68		pla		            PLA
.1a1b61	28		plp		            PLP
.1a1b62	c2 10		rep #$10	            REP #$10
.1a1b64	da		phx		            PHX
.1a1b65					get_char
.1a1b65	e2 20		sep #$20	            SEP #$20
.1a1b67	a7 00		lda [$0800]	            LDA [BIP]           ; Get the character
.1a1b69	d0 03		bne $1a1b6e	            BNE else1
.1a1b6b	4c 10 1c	jmp $1a1c10	            JMP proc_stack      ; Handle end of line, if we see it
.1a1b6e	30 33		bmi $1a1ba3	else1       BMI is_token        ; If MSB is set, it's a token
.1a1b70	c9 20		cmp #$20	            CMP #' '            ; Is it a space?
.1a1b72	d0 03		bne $1a1b77	            BNE else2
.1a1b74	4c 0a 1c	jmp $1a1c0a	            JMP next_char       ; Yes: Skip to the next character
.1a1b77	c9 3a		cmp #$3a	else2       CMP #'9'+1          ; Check to see if we have digits
.1a1b79	b0 04		bcs $1a1b7f	            BCS else3           ; No: treat as the end of the line
.1a1b7b	c9 30		cmp #$30	            CMP #'0'
.1a1b7d	b0 56		bcs $1a1bd5	            BCS is_digit
.1a1b7f	c9 26		cmp #$26	else3       CMP #'&'            ; Check for a hexadecimal prefix
.1a1b81	f0 52		beq $1a1bd5	            BEQ is_digit
.1a1b83	c9 22		cmp #$22	            CMP #'"'            ; Is it a double-quote?
.1a1b85	d0 03		bne $1a1b8a	            BNE else4
.1a1b87	4c 23 1c	jmp $1a1c23	            JMP is_string       ; Yes: process the string
.1a1b8a	c9 5b		cmp #$5b	else4       CMP #'Z'+1          ; Check to see if we have upper case alphabetics
.1a1b8c	b0 07		bcs $1a1b95	            BCS check_lc        ; No: check for lower case
.1a1b8e	c9 41		cmp #$41	            CMP #'A'
.1a1b90	90 03		bcc $1a1b95	            BCC check_lc
.1a1b92	4c 2f 1c	jmp $1a1c2f	            JMP is_alpha
.1a1b95	c9 7b		cmp #$7b	check_lc    CMP #'z'+1          ; Check to see if we have lower case alphabetics
.1a1b97	b0 07		bcs $1a1ba0	            BCS else5           ; No: treat as the end of the line
.1a1b99	c9 61		cmp #$61	            CMP #'a'
.1a1b9b	90 03		bcc $1a1ba0	            BCC else5
.1a1b9d	4c 2f 1c	jmp $1a1c2f	            JMP is_alpha
.1a1ba0	4c 10 1c	jmp $1a1c10	else5       JMP proc_stack
.1a1ba3	c9 8f		cmp #$8f	is_token    CMP #TOK_LPAREN     ; Is it an LPAREN
.1a1ba5	f0 40		beq $1a1be7	            BEQ is_lparen       ; Yes: handle the LPAREN
.1a1ba7	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it an RPAREN?
.1a1ba9	f0 41		beq $1a1bec	            BEQ is_rparen       ; Yes: handle the RPAREN
.1a1bab	20 5c 0b	jsr $1a0b5c	            JSR TOKTYPE
.1a1bae	c9 30		cmp #$30	            CMP #TOK_TY_FUNC    ; Is it a function?
.1a1bb0	d0 0c		bne $1a1bbe	            BNE chk_op          ; No: check if it's an operator
.1a1bb2	20 cf 1a	jsr $1a1acf	            JSR EVAL_FUNC
.1a1bb5	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.1a1bb8	20 2f 18	jsr $1a182f	            JSR PHARGUMENT
.1a1bbb	4c 65 1b	jmp $1a1b65	            JMP get_char
.1a1bbe	c9 00		cmp #$00	chk_op      CMP #TOK_TY_OP      ; Is it an operator?
.1a1bc0	d0 4e		bne $1a1c10	            BNE proc_stack      ; No: we're finished processing
.1a1bc2	a7 00		lda [$0800]	            LDA [BIP]           ; Yes: Get the token back
.1a1bc4	a6 21		ldx $0821	chk_prec    LDX OPERATORSP      ; Is the operator stack empty?
.1a1bc6	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.1a1bc9	f0 05		beq $1a1bd0	            BEQ push_op         ; Yes: push the operator
.1a1bcb	20 4c 19	jsr $1a194c	            JSR OPHIGHPREC
.1a1bce	b0 12		bcs $1a1be2	            BCS process1        ; No: we should process the top operator
.1a1bd0					push_op
.1a1bd0	20 ac 18	jsr $1a18ac	            JSR PHOPERATOR
.1a1bd3	80 35		bra $1a1c0a	            BRA next_char       ; And go to the next character
.1a1bd5					is_digit
.1a1bd5	c2 20		rep #$20	            REP #$20
.1a1bd7	20 af 57	jsr $1a57af	            JSR PARSENUM
.1a1bda	a2 23 08	ldx #$0823	got_number  LDX #<>ARGUMENT1
.1a1bdd	20 2f 18	jsr $1a182f	            JSR PHARGUMENT
.1a1be0	80 83		bra $1a1b65	            BRA get_char
.1a1be2					process1
.1a1be2	20 f9 1a	jsr $1a1af9	            JSR PROCESSOP
.1a1be5	80 dd		bra $1a1bc4	            BRA chk_prec        ; And check what to do with the current operator
.1a1be7					is_lparen
.1a1be7	20 ac 18	jsr $1a18ac	            JSR PHOPERATOR
.1a1bea	80 1e		bra $1a1c0a	            BRA next_char
.1a1bec					is_rparen
.1a1bec	e2 20		sep #$20	            SEP #$20
.1a1bee	a4 21		ldy $0821	            LDY OPERATORSP      ; Is the operator stack empty?
.1a1bf0	c0 ff 7f	cpy #$7fff	            CPY #<>OPERATOR_TOP
.1a1bf3	f0 46		beq $1a1c3b	            BEQ done            ; Yes: we're done evaluating things
.1a1bf5	a4 21		ldy $0821	paren_loop  LDY OPERATORSP      ; Peek at the top operator
.1a1bf7	b9 01 00	lda $0001,y	            LDA #1,B,Y
.1a1bfa	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the LPAREN of a function?
.1a1bfc	f0 3d		beq $1a1c3b	            BEQ done            ; Yes: treat it as an empty stack
.1a1bfe	c9 8f		cmp #$8f	            CMP #TOK_LPAREN     ; Is it an LPAREN?
.1a1c00	f0 05		beq $1a1c07	            BEQ done_rparen     ; Yes: we're finished processing
.1a1c02	20 f9 1a	jsr $1a1af9	            JSR PROCESSOP
.1a1c05	80 ee		bra $1a1bf5	            BRA paren_loop
.1a1c07					done_rparen
.1a1c07	20 d5 18	jsr $1a18d5	            JSR PLOPERATOR
.1a1c0a					next_char
.1a1c0a	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a1c0d	4c 65 1b	jmp $1a1b65	            JMP get_char
.1a1c10					proc_stack
.1a1c10	a6 21		ldx $0821	            LDX OPERATORSP      ; Is the operator stack empty?
.1a1c12	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.1a1c15	b0 24		bcs $1a1c3b	            BGE done            ; Yes: return to the caller
.1a1c17	bd 01 00	lda $0001,x	            LDA #1,B,X
.1a1c1a	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is top operator a function open?
.1a1c1c	f0 1d		beq $1a1c3b	            BEQ done            ; Yes: treat as end of expression
.1a1c1e	20 f9 1a	jsr $1a1af9	            JSR PROCESSOP
.1a1c21	80 ed		bra $1a1c10	            BRA proc_stack
.1a1c23					is_string
.1a1c23	20 59 1a	jsr $1a1a59	            JSR EVALSTRING
.1a1c26	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.1a1c29	20 2f 18	jsr $1a182f	            JSR PHARGUMENT
.1a1c2c	4c 65 1b	jmp $1a1b65	            JMP get_char
.1a1c2f					is_alpha
.1a1c2f	20 11 1a	jsr $1a1a11	            JSR EVALREF
.1a1c32	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.1a1c35	20 2f 18	jsr $1a182f	            JSR PHARGUMENT
.1a1c38	4c 65 1b	jmp $1a1b65	            JMP get_char
.1a1c3b	a2 23 08	ldx #$0823	done        LDX #<>ARGUMENT1    ; Make sure the result is off the stack
.1a1c3e	20 6d 18	jsr $1a186d	            JSR PLARGUMENT
.1a1c41	fa		plx		            PLX
.1a1c42	28		plp		            PLP
.1a1c43	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\returnstack.s

.1a1c44					INITRETURN
.1a1c44	08		php		                PHP
.1a1c45	0b		phd		                PHD
.1a1c46	8b		phb		                PHB
.1a1c47	08		php		            PHP
.1a1c48	e2 20		sep #$20	            SEP #$20
.1a1c4a	48		pha		            PHA
.1a1c4b	a9 00		lda #$00	            LDA #0
.1a1c4d	48		pha		            PHA
.1a1c4e	ab		plb		            PLB
.1a1c4f	68		pla		            PLA
.1a1c50	28		plp		            PLP
.1a1c51	08		php		            PHP
.1a1c52	c2 20		rep #$20	            REP #$20
.1a1c54	48		pha		            PHA
.1a1c55	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1c58	5b		tcd		            TCD
.1a1c59	68		pla		            PLA
.1a1c5a	28		plp		            PLP
.1a1c5b	c2 30		rep #$30	            REP #$30
.1a1c5d	a9 fd 5f	lda #$5ffd	                LDA #RETURN_TOP-2
.1a1c60	85 33		sta $0833	                STA RETURNSP
.1a1c62	ab		plb		                PLB
.1a1c63	2b		pld		                PLD
.1a1c64	28		plp		                PLP
.1a1c65	60		rts		            RTS
.1a1c66					PHRETURN
.1a1c66	08		php		                PHP
.1a1c67	0b		phd		                PHD
.1a1c68	08		php		            PHP
.1a1c69	c2 20		rep #$20	            REP #$20
.1a1c6b	48		pha		            PHA
.1a1c6c	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1c6f	5b		tcd		            TCD
.1a1c70	68		pla		            PLA
.1a1c71	28		plp		            PLP
.1a1c72	c2 30		rep #$30	            REP #$30
.1a1c74	92 33		sta ($0833)	                STA (RETURNSP)
.1a1c76	c6 33		dec $0833	                DEC RETURNSP
.1a1c78	c6 33		dec $0833	                DEC RETURNSP
.1a1c7a	2b		pld		                PLD
.1a1c7b	28		plp		                PLP
.1a1c7c	60		rts		            RTS
.1a1c7d					PHRETURNB
.1a1c7d	08		php		                PHP
.1a1c7e	c2 30		rep #$30	            REP #$30
.1a1c80	29 ff 00	and #$00ff	                AND #$00FF
.1a1c83	20 66 1c	jsr $1a1c66	            JSR PHRETURN
.1a1c86	28		plp		                PLP
.1a1c87	60		rts		            RTS
.1a1c88					PLRETURN
.1a1c88	08		php		                PHP
.1a1c89	0b		phd		                PHD
.1a1c8a	08		php		            PHP
.1a1c8b	c2 20		rep #$20	            REP #$20
.1a1c8d	48		pha		            PHA
.1a1c8e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1c91	5b		tcd		            TCD
.1a1c92	68		pla		            PLA
.1a1c93	28		plp		            PLP
.1a1c94	c2 30		rep #$30	            REP #$30
.1a1c96	e6 33		inc $0833	                INC RETURNSP
.1a1c98	e6 33		inc $0833	                INC RETURNSP
.1a1c9a	b2 33		lda ($0833)	                LDA (RETURNSP)
.1a1c9c	2b		pld		                PLD
.1a1c9d	28		plp		                PLP
.1a1c9e	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\interpreter.s

=$80					ST_RUNNING = $80            ; The interpreter is running a full program
=$00					ST_INTERACT = $00           ; The interpreter is in interactive mode
>08d2					STATE       .byte ?         ; The state of the interpreter ()
>08d3					ERROR_NUM   .byte ?         ; The type of the error
>08d4					HANDLEERR   .long ?         ; Pointer to the error handler
>08d7					LINENUM     .word ?         ; The current line number
>08d9					LASTLINE    .long ?         ; Pointer to the next free space over the BASIC program
>08dc					EXECACTION  .byte ?         ; The action the exection routines should take to get their next statement
=0					LINE_LINK = 0               ; Offset to the link to the next line
=2					LINE_NUMBER = 2             ; Offset to the line number
=4					LINE_TOKENS = 4             ; Offset to the first token
=6					LINE_MINLEN = 6             ; Minimum length of a line
=0					EXEC_CONT = 0               ; Continue advancing the current line
=1					EXEC_STOP = 1               ; Stop execution of the program
=2					EXEC_GOTO = 2               ; Transfer execution to a new CURLINE that is already set
=3					EXEC_RETURN = 3             ; Transfer execution back to a line that was on the stack
.1a1c9f					SET_ERRERL
.1a1c9f	8b		phb		                PHB
.1a1ca0	0b		phd		                PHD
.1a1ca1	08		php		                PHP
.1a1ca2	08		php		            PHP
.1a1ca3	c2 20		rep #$20	            REP #$20
.1a1ca5	48		pha		            PHA
.1a1ca6	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a1ca9	5b		tcd		            TCD
.1a1caa	68		pla		            PLA
.1a1cab	28		plp		            PLP
.1a1cac	08		php		            PHP
.1a1cad	e2 20		sep #$20	            SEP #$20
.1a1caf	48		pha		            PHA
.1a1cb0	a9 00		lda #$00	            LDA #BASIC_BANK
.1a1cb2	48		pha		            PHA
.1a1cb3	ab		plb		            PLB
.1a1cb4	68		pla		            PLA
.1a1cb5	28		plp		            PLP
.1a1cb6	c2 20		rep #$20	            REP #$20
.1a1cb8	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.1a1cba	a9 00 00	lda #$0000	                LDA #0
.1a1cbd	85 25		sta $0825	                STA ARGUMENT1+2
.1a1cbf	e2 20		sep #$20	            SEP #$20
.1a1cc1	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a1cc3	85 27		sta $0827	                STA ARGTYPE1
.1a1cc5	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.1a1cc7	a9 1a		lda #$1a	                LDA #`err_name
.1a1cc9	85 e9		sta $08e9	                STA TOFIND+2
.1a1ccb	c2 20		rep #$20	            REP #$20
.1a1ccd	a9 f9 1c	lda #$1cf9	                LDA #<>err_name
.1a1cd0	85 e7		sta $08e7	                STA TOFIND
.1a1cd2	20 f0 50	jsr $1a50f0	            JSR VAR_SET
.1a1cd5	c2 20		rep #$20	            REP #$20
.1a1cd7	a5 d7		lda $08d7	                LDA LINENUM
.1a1cd9	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.1a1cdb	a5 d9		lda $08d9	                LDA LINENUM+2
.1a1cdd	85 25		sta $0825	                STA ARGUMENT1+2
.1a1cdf	e2 20		sep #$20	            SEP #$20
.1a1ce1	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a1ce3	85 27		sta $0827	                STA ARGTYPE1
.1a1ce5	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.1a1ce7	a9 1a		lda #$1a	                LDA #`erl_name
.1a1ce9	85 e9		sta $08e9	                STA TOFIND+2
.1a1ceb	c2 20		rep #$20	            REP #$20
.1a1ced	a9 fd 1c	lda #$1cfd	                LDA #<>erl_name
.1a1cf0	85 e7		sta $08e7	                STA TOFIND
.1a1cf2	20 f0 50	jsr $1a50f0	            JSR VAR_SET
.1a1cf5	28		plp		                PLP
.1a1cf6	2b		pld		                PLD
.1a1cf7	ab		plb		                PLB
.1a1cf8	60		rts		            RTS
>1a1cf9	45 52 52 00			err_name        .null "ERR"
>1a1cfd	45 52 4c 00			erl_name        .null "ERL"
.1a1d01					ON_ERROR
.1a1d01	e2 20		sep #$20	            SEP #$20
.1a1d03	c2 10		rep #$10	            REP #$10
.1a1d05	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a1d08	af d3 08 00	lda $0008d3	            LDA @lERROR_NUM         ; Calculate index to the error message pointer
.1a1d0c	0a		asl a		            ASL A
.1a1d0d	c2 20		rep #$20	            REP #$20
.1a1d0f	29 ff 00	and #$00ff	            AND #$00FF
.1a1d12	a8		tay		            TAY
.1a1d13	08		php		            PHP
.1a1d14	e2 20		sep #$20	            SEP #$20
.1a1d16	48		pha		            PHA
.1a1d17	a9 1a		lda #$1a	            LDA #`ERRORMSG
.1a1d19	48		pha		            PHA
.1a1d1a	ab		plb		            PLB
.1a1d1b	68		pla		            PLA
.1a1d1c	28		plp		            PLP
.1a1d1d	be 53 1d	ldx $1a1d53,y	            LDX ERRORMSG,Y
.1a1d20	20 16 03	jsr $1a0316	            JSR PRINTS
.1a1d23	c2 20		rep #$20	            REP #$20
.1a1d25	a5 d7		lda $08d7	            LDA LINENUM
.1a1d27	f0 27		beq $1a1d50	            BEQ skip_at
.1a1d29	a2 83 1d	ldx #$1d83	            LDX #<>MSG_AT           ; If so... print " AT "
.1a1d2c	20 16 03	jsr $1a0316	            JSR PRINTS
.1a1d2f	08		php		            PHP
.1a1d30	e2 20		sep #$20	            SEP #$20
.1a1d32	48		pha		            PHA
.1a1d33	a9 00		lda #$00	            LDA #BASIC_BANK
.1a1d35	48		pha		            PHA
.1a1d36	ab		plb		            PLB
.1a1d37	68		pla		            PLA
.1a1d38	28		plp		            PLP
.1a1d39	c2 20		rep #$20	            REP #$20
.1a1d3b	af d7 08 00	lda $0008d7	            LDA @lLINENUM           ; ... and then the line number
.1a1d3f	8f 23 08 00	sta $000823	            STA @lARGUMENT1
.1a1d43	a9 00 00	lda #$0000	            LDA #0
.1a1d46	8f 25 08 00	sta $000825	            STA @lARGUMENT1+2
.1a1d4a	20 07 44	jsr $1a4407	            JSR PR_INTEGER
.1a1d4d	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a1d50					skip_at
.1a1d50	4c fe 25	jmp $1a25fe	            JMP INTERACT
>1a1d53	87 1d				ERRORMSG    .word <>MSG_OK
>1a1d55	8a 1d				            .word <>MSG_BREAK
>1a1d57	90 1d				            .word <>MSG_SYNTAX
>1a1d59	9d 1d				            .word <>MSG_MEMORY
>1a1d5b	ab 1d				            .word <>MSG_TYPE
>1a1d5d	b9 1d				            .word <>MSG_NOTFND
>1a1d5f	cc 1d				            .word <>MSG_NOLINE
>1a1d61	e2 1d				            .word <>MSG_UNDFLOW
>1a1d63	f2 1d				            .word <>MSG_OVRFLOW
>1a1d65	01 1e				            .word <>MSG_RANGE
>1a1d67	0e 1e				            .word <>MSG_ARG
>1a1d69	1f 1e				            .word <>MSG_NOFILE
>1a1d6b	2e 1e				            .word <>MSG_NAN
>1a1d6d	3b 1e				            .word <>MSG_OVERFLOW
>1a1d6f	49 1e				            .word <>MSG_UNDERFLOW
>1a1d71	58 1e				            .word <>MSG_DIV0
>1a1d73	69 1e				            .word <>MSG_DIRECTORY
>1a1d75	82 1e				            .word <>MSG_LOAD
>1a1d77	96 1e				            .word <>MSG_SAVE
>1a1d79	aa 1e				            .word <>MSG_DELETE
>1a1d7b	c0 1e				            .word <>MSG_FILENOTFND
>1a1d7d	d4 1e				            .word <>MSG_DIRNOTWRITE
>1a1d7f	ef 1e				            .word <>MSG_NOTCOPIED
>1a1d81	07 1f				            .word <>MSG_DOMAIN
>1a1d83	20 61 74 00			MSG_AT          .null " at"
>1a1d87	4f 4b 00			MSG_OK          .null "OK"
>1a1d8a	42 72 65 61 6b 00		MSG_BREAK       .null "Break"
>1a1d90	53 79 6e 74 61 78 20 65		MSG_SYNTAX      .null "Syntax error"
>1a1d98	72 72 6f 72 00
>1a1d9d	4f 75 74 20 6f 66 20 6d		MSG_MEMORY      .null "Out of memory"
>1a1da5	65 6d 6f 72 79 00
>1a1dab	54 79 70 65 20 6d 69 73		MSG_TYPE        .null "Type mismatch"
>1a1db3	6d 61 74 63 68 00
>1a1db9	56 61 72 69 61 62 6c 65		MSG_NOTFND      .null "Variable not found"
>1a1dc1	20 6e 6f 74 20 66 6f 75 6e 64 00
>1a1dcc	4c 69 6e 65 20 6e 75 6d		MSG_NOLINE      .null "Line number not found"
>1a1dd4	62 65 72 20 6e 6f 74 20 66 6f 75 6e 64 00
>1a1de2	53 74 61 63 6b 20 75 6e		MSG_UNDFLOW     .null "Stack underflow"
>1a1dea	64 65 72 66 6c 6f 77 00
>1a1df2	53 74 61 63 6b 20 6f 76		MSG_OVRFLOW     .null "Stack overflow"
>1a1dfa	65 72 66 6c 6f 77 00
>1a1e01	4f 75 74 20 6f 66 20 72		MSG_RANGE       .null "Out of range"
>1a1e09	61 6e 67 65 00
>1a1e0e	49 6c 6c 65 67 61 6c 20		MSG_ARG         .null "Illegal argument"
>1a1e16	61 72 67 75 6d 65 6e 74 00
>1a1e1f	46 69 6c 65 20 6e 6f 74		MSG_NOFILE      .null "File not found"
>1a1e27	20 66 6f 75 6e 64 00
>1a1e2e	4e 6f 74 20 61 20 6e 75		MSG_NAN         .null "Not a number"
>1a1e36	6d 62 65 72 00
>1a1e3b	4d 61 74 68 20 6f 76 65		MSG_OVERFLOW    .null "Math overflow"
>1a1e43	72 66 6c 6f 77 00
>1a1e49	4d 61 74 68 20 75 6e 64		MSG_UNDERFLOW   .null "Math underflow"
>1a1e51	65 72 66 6c 6f 77 00
>1a1e58	44 69 76 69 73 69 6f 6e		MSG_DIV0        .null "Division by zero"
>1a1e60	20 62 79 20 7a 65 72 6f 00
>1a1e69	55 6e 61 62 6c 65 20 74		MSG_DIRECTORY   .null "Unable to read directory"
>1a1e71	6f 20 72 65 61 64 20 64 69 72 65 63 74 6f 72 79
>1a1e81	00
>1a1e82	55 6e 61 62 6c 65 20 74		MSG_LOAD        .null "Unable to load file"
>1a1e8a	6f 20 6c 6f 61 64 20 66 69 6c 65 00
>1a1e96	55 6e 61 62 6c 65 20 74		MSG_SAVE        .null "Unable to save file"
>1a1e9e	6f 20 73 61 76 65 20 66 69 6c 65 00
>1a1eaa	55 6e 61 62 6c 65 20 74		MSG_DELETE      .null "Unable to delete file"
>1a1eb2	6f 20 64 65 6c 65 74 65 20 66 69 6c 65 00
>1a1ec0	43 6f 75 6c 64 20 6e 6f		MSG_FILENOTFND  .null "Could not find file"
>1a1ec8	74 20 66 69 6e 64 20 66 69 6c 65 00
>1a1ed4	43 6f 75 6c 64 20 6e 6f		MSG_DIRNOTWRITE .null "Could not update directory"
>1a1edc	74 20 75 70 64 61 74 65 20 64 69 72 65 63 74 6f
>1a1eec	72 79 00
>1a1eef	43 6f 75 6c 64 20 6e 6f		MSG_NOTCOPIED   .null "Could not copy the file"
>1a1ef7	74 20 63 6f 70 79 20 74 68 65 20 66 69 6c 65 00
>1a1f07	41 72 67 75 6d 65 6e 74		MSG_DOMAIN      .null "Argument outside domain"
>1a1f0f	20 6f 75 74 73 69 64 65 20 64 6f 6d 61 69 6e 00
.1a1f1f					SETINTERACT
.1a1f1f	08		php		            PHP
.1a1f20	0b		phd		            PHD
.1a1f21	08		php		            PHP
.1a1f22	c2 20		rep #$20	            REP #$20
.1a1f24	48		pha		            PHA
.1a1f25	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1f28	5b		tcd		            TCD
.1a1f29	68		pla		            PLA
.1a1f2a	28		plp		            PLP
.1a1f2b	e2 20		sep #$20	            SEP #$20
.1a1f2d	a9 00		lda #$00	            LDA #ST_INTERACT
.1a1f2f	85 d2		sta $08d2	            STA STATE
.1a1f31	2b		pld		            PLD
.1a1f32	28		plp		            PLP
.1a1f33	60		rts		            RTS
.1a1f34					CLRINTERP
.1a1f34	0b		phd		            PHD
.1a1f35	08		php		            PHP
.1a1f36	08		php		            PHP
.1a1f37	c2 20		rep #$20	            REP #$20
.1a1f39	48		pha		            PHA
.1a1f3a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1f3d	5b		tcd		            TCD
.1a1f3e	68		pla		            PLA
.1a1f3f	28		plp		            PLP
.1a1f40	08		php		            PHP
.1a1f41	c2 20		rep #$20	            REP #$20
.1a1f43	a9 01 1d	lda #$1d01	            LDA #<>ON_ERROR
.1a1f46	8f d4 08 00	sta $0008d4	            STA @lHANDLEERR
.1a1f4a	e2 20		sep #$20	            SEP #$20
.1a1f4c	a9 1a		lda #$1a	            LDA #`ON_ERROR
.1a1f4e	8f d6 08 00	sta $0008d6	            STA @lHANDLEERR+2
.1a1f52	28		plp		            PLP
.1a1f53	20 ac 42	jsr $1a42ac	            JSR S_CLR
.1a1f56	20 ed 3d	jsr $1a3ded	            JSR S_RESTORE
.1a1f59	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the depth of the GOSUB stack
.1a1f5b	28		plp		            PLP
.1a1f5c	2b		pld		            PLD
.1a1f5d	60		rts		            RTS
.1a1f5e					INCBIP
.1a1f5e	08		php		            PHP
.1a1f5f	0b		phd		            PHD
.1a1f60	08		php		            PHP
.1a1f61	c2 20		rep #$20	            REP #$20
.1a1f63	48		pha		            PHA
.1a1f64	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1f67	5b		tcd		            TCD
.1a1f68	68		pla		            PLA
.1a1f69	28		plp		            PLP
.1a1f6a	c2 20		rep #$20	            REP #$20
.1a1f6c	18		clc		            CLC
.1a1f6d	a5 00		lda $0800	            LDA BIP
.1a1f6f	69 01 00	adc #$0001	            ADC #1
.1a1f72	85 00		sta $0800	            STA BIP
.1a1f74	e2 20		sep #$20	            SEP #$20
.1a1f76	a5 02		lda $0802	            LDA BIP+2
.1a1f78	69 00		adc #$00	            ADC #0
.1a1f7a	85 02		sta $0802	            STA BIP+2
.1a1f7c	2b		pld		            PLD
.1a1f7d	28		plp		            PLP
.1a1f7e	60		rts		            RTS
.1a1f7f					SKIPWS
.1a1f7f	08		php		            PHP
.1a1f80	0b		phd		            PHD
.1a1f81	08		php		            PHP
.1a1f82	c2 20		rep #$20	            REP #$20
.1a1f84	48		pha		            PHA
.1a1f85	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a1f88	5b		tcd		            TCD
.1a1f89	68		pla		            PLA
.1a1f8a	28		plp		            PLP
.1a1f8b	e2 20		sep #$20	            SEP #$20
.1a1f8d	a7 00		lda [$0800]	loop        LDA [BIP]
.1a1f8f	f0 0f		beq $1a1fa0	            BEQ done            ; If character is 0, we've reached the end of the line
.1a1f91	c9 20		cmp #$20	            CMP #CHAR_SP        ; Skip if it's a space
.1a1f93	f0 06		beq $1a1f9b	            BEQ skip_char
.1a1f95	c9 09		cmp #$09	            CMP #CHAR_TAB       ; Skip if it's a TAB
.1a1f97	f0 02		beq $1a1f9b	            BEQ skip_char
.1a1f99	80 05		bra $1a1fa0	            BRA done            ; Otherwise, we're done and BIP points to a non-whitespace
.1a1f9b					skip_char
.1a1f9b	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a1f9e	80 ed		bra $1a1f8d	            BRA loop
.1a1fa0	2b		pld		done        PLD
.1a1fa1	28		plp		            PLP
.1a1fa2	60		rts		            RTS
.1a1fa3					SKIPSTMT
.1a1fa3	08		php		            PHP
.1a1fa4	e2 20		sep #$20	            SEP #$20
.1a1fa6	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the current character
.1a1fa8	f0 09		beq $1a1fb3	            BEQ done            ; Is it EOL? Yes, we're done
.1a1faa	c9 3a		cmp #$3a	            CMP #':'            ; Is it a colon?
.1a1fac	f0 05		beq $1a1fb3	            BEQ done            ; Yes, we're done
.1a1fae	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a1fb1	80 f3		bra $1a1fa6	            BRA loop            ; and check it...
.1a1fb3	28		plp		done        PLP
.1a1fb4	60		rts		            RTS
.1a1fb5					SKIPTOTOK
.1a1fb5	08		php		            PHP
.1a1fb6	e2 20		sep #$20	            SEP #$20
.1a1fb8	64 36		stz $0836	            STZ NESTING
.1a1fba	a7 00		lda [$0800]	loop        LDA [BIP]           ; Get the character
.1a1fbc	f0 19		beq $1a1fd7	            BEQ end_of_line     ; EOL? Yes: move to the next line
.1a1fbe	c5 37		cmp $0837	            CMP TARGETTOK       ; Is it the one we want?
.1a1fc0	f0 2c		beq $1a1fee	            BEQ check_depth     ; Yes: check the depth
.1a1fc2	c9 9b		cmp #$9b	            CMP #TOK_FOR        ; Is it a FOR?
.1a1fc4	f0 1e		beq $1a1fe4	            BEQ inc_nesting     ; Yes: increment NESTING
.1a1fc6	c9 9f		cmp #$9f	            CMP #TOK_DO         ; Is it a DO?
.1a1fc8	f0 1a		beq $1a1fe4	            BEQ inc_nesting     ; Yes: increment NESTING
.1a1fca	c9 9e		cmp #$9e	            CMP #TOK_NEXT       ; Is it a NEXT?
.1a1fcc	f0 1a		beq $1a1fe8	            BEQ dec_nesting     ; Yes: decrement NESTING
.1a1fce	c9 a0		cmp #$a0	            CMP #TOK_LOOP       ; Is it a LOOP?
.1a1fd0	f0 16		beq $1a1fe8	            BEQ dec_nesting     ; Yes: decrement NESTING
.1a1fd2					incloop
.1a1fd2	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a1fd5	80 e3		bra $1a1fba	            BRA loop            ; and keep scanning
.1a1fd7					end_of_line
.1a1fd7	20 3b 20	jsr $1a203b	            JSR NEXTLINE
.1a1fda	c2 20		rep #$20	            REP #$20
.1a1fdc	a5 d7		lda $08d7	            LDA LINENUM         ; Check the line number
.1a1fde	f0 1d		beq $1a1ffd	            BEQ syntax_err1     ; If it's zero, we reached the end of the program
.1a1fe0	e2 20		sep #$20	            SEP #$20
.1a1fe2	80 d6		bra $1a1fba	            BRA loop            ; And keep scanning
.1a1fe4					inc_nesting
.1a1fe4	e6 36		inc $0836	            INC NESTING         ; Track that we have entered a lexical scope for a FOR/DO
.1a1fe6	80 ea		bra $1a1fd2	            BRA incloop
.1a1fe8					dec_nesting
.1a1fe8	c6 36		dec $0836	            DEC NESTING         ; Track that we have left a lexical scope for a FOR/DO
.1a1fea	30 30		bmi $1a201c	            BMI syntax_err2     ; If the depth goes <0, throw a syntax error
.1a1fec	80 e4		bra $1a1fd2	            BRA incloop
.1a1fee					check_depth
.1a1fee	a5 35		lda $0835	            LDA SKIPNEST        ; Check to see if nesting matters
.1a1ff0	30 06		bmi $1a1ff8	            BMI found           ; No: just return that we found the token
.1a1ff2	a5 36		lda $0836	            LDA NESTING         ; Get the nesting depth
.1a1ff4	f0 02		beq $1a1ff8	            BEQ found           ; If it's zero, we found our token
.1a1ff6	80 da		bra $1a1fd2	            BRA incloop         ; Otherwise: it's a token for an enclosed FOR/DO, keep scanning
.1a1ff8					found
.1a1ff8	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a1ffb	28		plp		            PLP
.1a1ffc	60		rts		            RTS
.1a1ffd					syntax_err1
.1a1ffd	08		php		            PHP
.1a1ffe	c2 20		rep #$20	            REP #$20
.1a2000	48		pha		            PHA
.1a2001	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2004	5b		tcd		            TCD
.1a2005	68		pla		            PLA
.1a2006	28		plp		            PLP
.1a2007	e2 20		sep #$20	            SEP #$20
.1a2009	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a200b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a200f	c2 20		rep #$20	            REP #$20
.1a2011	29 ff 00	and #$00ff	            AND #$00FF
.1a2014	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a2017	e2 20		sep #$20	            SEP #$20
.1a2019	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a201c					syntax_err2
.1a201c	08		php		            PHP
.1a201d	c2 20		rep #$20	            REP #$20
.1a201f	48		pha		            PHA
.1a2020	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2023	5b		tcd		            TCD
.1a2024	68		pla		            PLA
.1a2025	28		plp		            PLP
.1a2026	e2 20		sep #$20	            SEP #$20
.1a2028	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a202a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a202e	c2 20		rep #$20	            REP #$20
.1a2030	29 ff 00	and #$00ff	            AND #$00FF
.1a2033	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a2036	e2 20		sep #$20	            SEP #$20
.1a2038	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a203b					NEXTLINE
.1a203b	08		php		            PHP
.1a203c	c2 30		rep #$30	            REP #$30
.1a203e	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a2041	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the offset to the next line
.1a2043	85 0c		sta $080c	            STA SCRATCH
.1a2045	18		clc		            CLC                 ; Compute the new CURLINE
.1a2046	a5 1a		lda $081a	            LDA CURLINE         ; CURLINE := [CURLINE].LINE_LINK
.1a2048	65 0c		adc $080c	            ADC SCRATCH
.1a204a	85 1a		sta $081a	            STA CURLINE
.1a204c	a5 1c		lda $081c	            LDA CURLINE+2
.1a204e	69 00 00	adc #$0000	            ADC #0
.1a2051	85 1c		sta $081c	            STA CURLINE+2
.1a2053	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the LINENUM to the new current line's number
.1a2056	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; LINENUM := [CURLINE].LINE_NUMBER
.1a2058	85 d7		sta $08d7	            STA LINENUM
.1a205a	18		clc		            CLC                 ; Point BIP to the first character of the line
.1a205b	a5 1a		lda $081a	            LDA CURLINE         ; BIP := CURLINE + LINE_TOKENS
.1a205d	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a2060	85 00		sta $0800	            STA BIP
.1a2062	a5 1c		lda $081c	            LDA CURLINE+2
.1a2064	69 00 00	adc #$0000	            ADC #0
.1a2067	85 02		sta $0802	            STA BIP+2
.1a2069	28		plp		            PLP
.1a206a	60		rts		            RTS
.1a206b					EXPECT_TOK
.1a206b	08		php		            PHP
.1a206c	e2 20		sep #$20	            SEP #$20
.1a206e	48		pha		            PHA
.1a206f	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a2072	68		pla		            PLA
.1a2073	e2 20		sep #$20	            SEP #$20
.1a2075	c7 00		cmp [$0800]	            CMP [BIP]           ; Check the character at BIP
.1a2077	d0 08		bne $1a2081	            BNE syntax_err      ; Throw a syntax error
.1a2079	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a207c	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a207f	28		plp		            PLP
.1a2080	60		rts		            RTS
.1a2081					syntax_err
.1a2081	08		php		            PHP
.1a2082	c2 20		rep #$20	            REP #$20
.1a2084	48		pha		            PHA
.1a2085	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2088	5b		tcd		            TCD
.1a2089	68		pla		            PLA
.1a208a	28		plp		            PLP
.1a208b	e2 20		sep #$20	            SEP #$20
.1a208d	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a208f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2093	c2 20		rep #$20	            REP #$20
.1a2095	29 ff 00	and #$00ff	            AND #$00FF
.1a2098	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a209b	e2 20		sep #$20	            SEP #$20
.1a209d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a20a0					OPT_TOK
.1a20a0	08		php		            PHP
.1a20a1	e2 20		sep #$20	            SEP #$20
.1a20a3	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a20a6	e2 20		sep #$20	            SEP #$20
.1a20a8	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the character at BIP
.1a20aa	f0 10		beq $1a20bc	            BEQ ret_false       ; If end-of-line, return false
.1a20ac	c9 3a		cmp #$3a	            CMP #':'
.1a20ae	f0 0c		beq $1a20bc	            BEQ ret_false       ; If colon, return false
.1a20b0	c5 37		cmp $0837	            CMP TARGETTOK
.1a20b2	f0 05		beq $1a20b9	            BEQ ret_true        ; If matches, return true
.1a20b4	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a20b7	80 ef		bra $1a20a8	            BRA loop
.1a20b9	28		plp		ret_true    PLP
.1a20ba	38		sec		            SEC
.1a20bb	60		rts		            RTS
.1a20bc	28		plp		ret_false   PLP
.1a20bd	18		clc		            CLC
.1a20be	60		rts		            RTS
.1a20bf					PEEK_TOK
.1a20bf	5a		phy		            PHY
.1a20c0	08		php		            PHP
.1a20c1	e2 20		sep #$20	            SEP #$20
.1a20c3	a0 00 00	ldy #$0000	            LDY #0
.1a20c6	b7 00		lda [$0800],y	loop        LDA [BIP],Y
.1a20c8	f0 0d		beq $1a20d7	            BEQ done
.1a20ca	c9 3a		cmp #$3a	            CMP #':'
.1a20cc	f0 07		beq $1a20d5	            BEQ ret_null
.1a20ce	c9 20		cmp #$20	            CMP #CHAR_SP
.1a20d0	d0 05		bne $1a20d7	            BNE done
.1a20d2	c8		iny		            INY
.1a20d3	80 f1		bra $1a20c6	            BRA loop
.1a20d5	a9 00		lda #$00	ret_null    LDA #0
.1a20d7	28		plp		done        PLP
.1a20d8	7a		ply		            PLY
.1a20d9	60		rts		            RTS
.1a20da					EXECSTMT
.1a20da	08		php		            PHP
.1a20db	0b		phd		            PHD
.1a20dc	8b		phb		            PHB
.1a20dd	08		php		            PHP
.1a20de	c2 20		rep #$20	            REP #$20
.1a20e0	48		pha		            PHA
.1a20e1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a20e4	5b		tcd		            TCD
.1a20e5	68		pla		            PLA
.1a20e6	28		plp		            PLP
.1a20e7	20 0f 18	jsr $1a180f	            JSR INITEVALSP
.1a20ea	e2 20		sep #$20	            SEP #$20
.1a20ec	a9 00		lda #$00	            LDA #EXEC_CONT      ; This will tell EXECLINE and EXECPROG to procede in a
.1a20ee	85 dc		sta $08dc	            STA EXECACTION      ; linear fashion through the program
.1a20f0	ad 8a 0f	lda $0f8a	check_break LDA KEYFLAG         ; Check the keyboard flags
.1a20f3	30 4b		bmi $1a2140	            BMI throw_break     ; If MSB: user pressed an interrupt key, stop the program
.1a20f5	a7 00		lda [$0800]	            LDA [BIP]           ; If we happen to have a colon, just skip over it.
.1a20f7	c9 3a		cmp #$3a	            CMP #':'            ; This can happen with FOR/NEXT
.1a20f9	d0 03		bne $1a20fe	            BNE eat_ws
.1a20fb	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a20fe					eat_ws
.1a20fe	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a2101	a7 00		lda [$0800]	            LDA [BIP]
.1a2103	d0 03		bne $1a2108	            BNE else
.1a2105	4c 8a 21	jmp $1a218a	            JMP done            ; If the current byte is 0, we're at the end of the line, just return
.1a2108					else
.1a2108	20 94 03	jsr $1a0394	            JSR ISALPHA
.1a210b	b0 52		bcs $1a215f	            BCS is_variable     ; Yes: we may have a LET statement
.1a210d	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it's any other non-token
.1a210f	10 10		bpl $1a2121	            BPL error           ; Yes: it's a syntax error
.1a2111	20 5c 0b	jsr $1a0b5c	            JSR TOKTYPE
.1a2114	85 0c		sta $080c	            STA SCRATCH         ; Save the type for later
.1a2116	c9 20		cmp #$20	            CMP #TOK_TY_STMNT   ; Is it a statement?
.1a2118	d0 03		bne $1a211d	            BNE else2
.1a211a	4c 78 21	jmp $1a2178	            JMP ok_to_exec      ; Yes: it's ok to try to execute it
.1a211d	a5 d2		lda $08d2	else2       LDA STATE           ; Check to see if we're in interactive mode
.1a211f	f0 51		beq $1a2172	            BEQ is_interact
.1a2121					error
.1a2121	08		php		            PHP
.1a2122	c2 20		rep #$20	            REP #$20
.1a2124	48		pha		            PHA
.1a2125	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2128	5b		tcd		            TCD
.1a2129	68		pla		            PLA
.1a212a	28		plp		            PLP
.1a212b	e2 20		sep #$20	            SEP #$20
.1a212d	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a212f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2133	c2 20		rep #$20	            REP #$20
.1a2135	29 ff 00	and #$00ff	            AND #$00FF
.1a2138	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a213b	e2 20		sep #$20	            SEP #$20
.1a213d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2140					throw_break
.1a2140	08		php		            PHP
.1a2141	c2 20		rep #$20	            REP #$20
.1a2143	48		pha		            PHA
.1a2144	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2147	5b		tcd		            TCD
.1a2148	68		pla		            PLA
.1a2149	28		plp		            PLP
.1a214a	e2 20		sep #$20	            SEP #$20
.1a214c	a9 01		lda #$01	            LDA #ERR_BREAK
.1a214e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2152	c2 20		rep #$20	            REP #$20
.1a2154	29 ff 00	and #$00ff	            AND #$00FF
.1a2157	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a215a	e2 20		sep #$20	            SEP #$20
.1a215c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a215f					is_variable
.1a215f	20 b6 42	jsr $1a42b6	            JSR S_LET
.1a2162	4c 8a 21	jmp $1a218a	            JMP done
.1a2165					STSTUB
.1a2165	08		php		            PHP
.1a2166	e2 20		sep #$20	            SEP #$20
.1a2168	48		pha		            PHA
.1a2169	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.1a216b	48		pha		            PHA
.1a216c	ab		plb		            PLB
.1a216d	68		pla		            PLA
.1a216e	28		plp		            PLP
.1a216f	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.1a2172	a5 0c		lda $080c	is_interact LDA SCRATCH         ; Get the token type
.1a2174	c9 10		cmp #$10	            CMP #TOK_TY_CMD     ; Is it a command?
.1a2176	d0 a9		bne $1a2121	            BNE error           ; If not, it's an error
.1a2178					ok_to_exec
.1a2178	a7 00		lda [$0800]	            LDA [BIP]           ; Get the original token again
.1a217a	20 39 0b	jsr $1a0b39	            JSR TOKEVAL
.1a217d	c2 20		rep #$20	            REP #$20
.1a217f	85 2f		sta $082f	            STA JMP16PTR        ; Store it in the jump pointer
.1a2181	20 0f 18	jsr $1a180f	            JSR INITEVALSP
.1a2184	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a2187	20 65 21	jsr $1a2165	            JSR STSTUB
.1a218a	ab		plb		done        PLB
.1a218b	2b		pld		            PLD
.1a218c	28		plp		            PLP
.1a218d	60		rts		            RTS
.1a218e					EXECCMD
.1a218e	08		php		            PHP
.1a218f	58		cli		            CLI
.1a2190	20 1f 1f	jsr $1a1f1f	            JSR SETINTERACT
.1a2193	20 44 1c	jsr $1a1c44	            JSR INITRETURN
.1a2196	e2 20		sep #$20	            SEP #$20
.1a2198	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.1a219b	c2 20		rep #$20	            REP #$20
.1a219d	a5 1a		lda $081a	            LDA CURLINE         ; Set the BASIC Instruction Pointer to the first byte of the line
.1a219f	85 00		sta $0800	            STA BIP
.1a21a1	a5 1c		lda $081c	            LDA CURLINE+2
.1a21a3	85 02		sta $0802	            STA BIP+2
.1a21a5	4c cf 21	jmp $1a21cf	            JMP exec_loop
.1a21a8	08		php		EXECLINE    PHP
.1a21a9	c2 20		rep #$20	            REP #$20
.1a21ab	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER            ; Set the current line number
.1a21ae	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.1a21b0	85 d7		sta $08d7	            STA LINENUM
.1a21b2	20 a5 13	jsr $1a13a5	            JSR CLRTMPSTR
.1a21b5	e2 20		sep #$20	            SEP #$20
.1a21b7	a5 dc		lda $08dc	            LDA EXECACTION              ; If the last EXEC action was RETURN
.1a21b9	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; BIP has already been set, so...
.1a21bb	f0 12		beq $1a21cf	            BEQ exec_loop               ; Skip over setting the BIP to the beginning of the line
.1a21bd	c2 20		rep #$20	            REP #$20
.1a21bf	18		clc		            CLC                         ; Set the BASIC Instruction Pointer to the first byte of the line
.1a21c0	a5 1a		lda $081a	            LDA CURLINE
.1a21c2	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a21c5	85 00		sta $0800	            STA BIP
.1a21c7	e2 20		sep #$20	            SEP #$20
.1a21c9	a5 1c		lda $081c	            LDA CURLINE+2
.1a21cb	69 00		adc #$00	            ADC #0
.1a21cd	85 02		sta $0802	            STA BIP+2
.1a21cf					exec_loop
.1a21cf	c2 20		rep #$20	            REP #$20
.1a21d1	20 da 20	jsr $1a20da	            JSR EXECSTMT
.1a21d4	e2 20		sep #$20	            SEP #$20
.1a21d6	a5 dc		lda $08dc	            LDA EXECACTION
.1a21d8	c9 03		cmp #$03	            CMP #EXEC_RETURN
.1a21da	f0 f3		beq $1a21cf	            BEQ exec_loop
.1a21dc	c9 00		cmp #$00	            CMP #EXEC_CONT              ; If it's not EXEC_CONT, exit to the caller
.1a21de	d0 31		bne $1a2211	            BNE exec_done
.1a21e0	e2 20		sep #$20	            SEP #$20
.1a21e2	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a21e5	a7 00		lda [$0800]	            LDA [BIP]                   ; Get the current character in the line
.1a21e7	f0 28		beq $1a2211	            BEQ exec_done               ; If it's NULL, we're done
.1a21e9	c9 3a		cmp #$3a	            CMP #':'                    ; If it's colon, we have more statements
.1a21eb	f0 1f		beq $1a220c	            BEQ skip_loop               ; Skip over it and try to execute the next one
.1a21ed	08		php		            PHP
.1a21ee	c2 20		rep #$20	            REP #$20
.1a21f0	48		pha		            PHA
.1a21f1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a21f4	5b		tcd		            TCD
.1a21f5	68		pla		            PLA
.1a21f6	28		plp		            PLP
.1a21f7	e2 20		sep #$20	            SEP #$20
.1a21f9	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a21fb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a21ff	c2 20		rep #$20	            REP #$20
.1a2201	29 ff 00	and #$00ff	            AND #$00FF
.1a2204	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a2207	e2 20		sep #$20	            SEP #$20
.1a2209	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a220c					skip_loop
.1a220c	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a220f	80 be		bra $1a21cf	            BRA exec_loop               ; And try to execute another statement
.1a2211					exec_done
.1a2211	28		plp		            PLP
.1a2212	60		rts		            RTS
.1a2213					EXECPROGRAM
.1a2213	08		php		            PHP
.1a2214	58		cli		            CLI
.1a2215	e2 20		sep #$20	            SEP #$20
.1a2217	a9 80		lda #$80	            LDA #ST_RUNNING
.1a2219	85 d2		sta $08d2	            STA STATE
.1a221b	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.1a221e	20 44 1c	jsr $1a1c44	            JSR INITRETURN
.1a2221	c2 30		rep #$30	            REP #$30
.1a2223	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the count of GOSUBs
.1a2225	a0 02 00	ldy #$0002	exec_loop   LDY #LINE_NUMBER
.1a2228	b7 1a		lda [$081a],y	            LDA [CURLINE],Y             ; Get the line number of the current line
.1a222a	f0 29		beq $1a2255	            BEQ done                    ; If it's 0, we are finished running code (implicit END)
.1a222c	20 a8 21	jsr $1a21a8	            JSR EXECLINE
.1a222f	e2 20		sep #$20	            SEP #$20
.1a2231	a5 dc		lda $08dc	            LDA EXECACTION              ; Check the EXECACTION from the last line
.1a2233	c9 01		cmp #$01	            CMP #EXEC_STOP              ; Stop execution of the program?
.1a2235	f0 1e		beq $1a2255	            BEQ done
.1a2237	c9 02		cmp #$02	            CMP #EXEC_GOTO              ; Transfer execution to a new CURLINE that is already set
.1a2239	f0 ea		beq $1a2225	            BEQ exec_loop
.1a223b	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; Transfer execution to the CURLINE and BIP that is already set
.1a223d	f0 e6		beq $1a2225	            BEQ exec_loop
.1a223f	c2 20		rep #$20	            REP #$20
.1a2241	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a2244	18		clc		            CLC
.1a2245	a5 1a		lda $081a	            LDA CURLINE
.1a2247	77 1a		adc [$081a],y	            ADC [CURLINE],Y
.1a2249	85 1a		sta $081a	            STA CURLINE
.1a224b	e2 20		sep #$20	            SEP #$20
.1a224d	a5 1c		lda $081c	            LDA CURLINE+2
.1a224f	69 00		adc #$00	            ADC #0
.1a2251	85 1c		sta $081c	            STA CURLINE+2
.1a2253	80 d0		bra $1a2225	            BRA exec_loop               ; And try to execute that line
.1a2255					done
.1a2255	e2 20		sep #$20	            SEP #$20
.1a2257	a9 00		lda #$00	            LDA #ST_INTERACT            ; Set interpreter state to RUNNING
.1a2259	85 d2		sta $08d2	            STA STATE
.1a225b	28		plp		            PLP
.1a225c	60		rts		            RTS
.1a225d					FINDLINE
.1a225d	08		php		            PHP
.1a225e	c2 30		rep #$30	            REP #$30
.1a2260	c2 20		rep #$20	            REP #$20
.1a2262	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT            ; INDEX points to the first line of the program
.1a2265	85 08		sta $0808	            STA INDEX
.1a2267	a9 16 00	lda #$0016	            LDA #`BASIC_BOT
.1a226a	85 0a		sta $080a	            STA INDEX+2
.1a226c	c2 20		rep #$20	            REP #$20
.1a226e	a0 02 00	ldy #$0002	check_nmbrs LDY #LINE_NUMBER            ; Get the number of the possible target line
.1a2271	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a2273	f0 31		beq $1a22a6	            BEQ ret_false               ; If new line number is 0, we got to the
.1a2275	c5 23		cmp $0823	            CMP ARGUMENT1               ; Compare it to the target line number
.1a2277	f0 1e		beq $1a2297	            BEQ found
.1a2279	b0 2b		bcs $1a22a6	            BGE ret_false               ; If the line number > target line number, the line is not present
.1a227b					next_line
.1a227b	c2 20		rep #$20	            REP #$20
.1a227d	a0 00 00	ldy #$0000	            LDY #LINE_LINK              ; INDEX := INDEX + [INDEX].LINK
.1a2280	18		clc		            CLC
.1a2281	a5 08		lda $0808	            LDA INDEX
.1a2283	77 08		adc [$0808],y	            ADC [INDEX],Y
.1a2285	85 0c		sta $080c	            STA SCRATCH
.1a2287	e2 20		sep #$20	            SEP #$20
.1a2289	a5 0a		lda $080a	            LDA INDEX+2
.1a228b	69 00		adc #$00	            ADC #0
.1a228d	85 0a		sta $080a	            STA INDEX+2
.1a228f	c2 20		rep #$20	            REP #$20
.1a2291	a5 0c		lda $080c	            LDA SCRATCH
.1a2293	85 08		sta $0808	            STA INDEX
.1a2295	80 d7		bra $1a226e	            BRA check_nmbrs             ; And go back to check the new line INDEX is pointing to
.1a2297					found
.1a2297	c2 20		rep #$20	            REP #$20
.1a2299	a5 08		lda $0808	            LDA INDEX
.1a229b	85 1a		sta $081a	            STA CURLINE
.1a229d	e2 20		sep #$20	            SEP #$20
.1a229f	a5 0a		lda $080a	            LDA INDEX+2
.1a22a1	85 1c		sta $081c	            STA CURLINE+2
.1a22a3	28		plp		ret_true    PLP                         ; Return true to indicate we've found the line
.1a22a4	38		sec		            SEC
.1a22a5	60		rts		            RTS
.1a22a6	28		plp		ret_false   PLP
.1a22a7	18		clc		            CLC
.1a22a8	60		rts		            RTS
.1a22a9					MVPROGDN
.1a22a9	08		php		            PHP
.1a22aa					mvd_loop
.1a22aa	e2 20		sep #$20	            SEP #$20
.1a22ac	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.1a22ae	87 08		sta [$0808]	            STA [INDEX]
.1a22b0	c2 20		rep #$20	            REP #$20
.1a22b2	a5 0c		lda $080c	            LDA SCRATCH
.1a22b4	c5 00		cmp $0800	            CMP BIP
.1a22b6	d0 08		bne $1a22c0	            BNE increment
.1a22b8	e2 20		sep #$20	            SEP #$20
.1a22ba	a5 0e		lda $080e	            LDA SCRATCH+2
.1a22bc	c5 02		cmp $0802	            CMP BIP+2
.1a22be	f0 26		beq $1a22e6	            BEQ done            ; Yes: return
.1a22c0					increment
.1a22c0	c2 20		rep #$20	            REP #$20
.1a22c2	18		clc		            CLC
.1a22c3	a5 0c		lda $080c	            LDA SCRATCH
.1a22c5	69 01 00	adc #$0001	            ADC #1
.1a22c8	85 0c		sta $080c	            STA SCRATCH
.1a22ca	e2 20		sep #$20	            SEP #$20
.1a22cc	a5 0e		lda $080e	            LDA SCRATCH+2
.1a22ce	69 00		adc #$00	            ADC #0
.1a22d0	85 0e		sta $080e	            STA SCRATCH+2
.1a22d2	c2 20		rep #$20	            REP #$20
.1a22d4	18		clc		            CLC
.1a22d5	a5 08		lda $0808	            LDA INDEX
.1a22d7	69 01 00	adc #$0001	            ADC #1
.1a22da	85 08		sta $0808	            STA INDEX
.1a22dc	e2 20		sep #$20	            SEP #$20
.1a22de	a5 0a		lda $080a	            LDA INDEX+2
.1a22e0	69 00		adc #$00	            ADC #0
.1a22e2	85 0a		sta $080a	            STA INDEX+2
.1a22e4	80 c4		bra $1a22aa	            BRA mvd_loop        ; And try again
.1a22e6	28		plp		done        PLP
.1a22e7	60		rts		            RTS
.1a22e8					MVPROGUP
.1a22e8	08		php		            PHP
.1a22e9					mvu_loop
.1a22e9	e2 20		sep #$20	            SEP #$20
.1a22eb	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.1a22ed	87 08		sta [$0808]	            STA [INDEX]
.1a22ef	c2 20		rep #$20	            REP #$20
.1a22f1	a5 0c		lda $080c	            LDA SCRATCH
.1a22f3	c5 00		cmp $0800	            CMP BIP
.1a22f5	d0 06		bne $1a22fd	            BNE decrement
.1a22f7	a5 0e		lda $080e	            LDA SCRATCH+2
.1a22f9	c5 02		cmp $0802	            CMP BIP+2
.1a22fb	f0 26		beq $1a2323	            BEQ done            ; Yes: return
.1a22fd					decrement
.1a22fd	c2 20		rep #$20	            REP #$20
.1a22ff	38		sec		            SEC
.1a2300	a5 0c		lda $080c	            LDA SCRATCH
.1a2302	e9 01 00	sbc #$0001	            SBC #1
.1a2305	85 0c		sta $080c	            STA SCRATCH
.1a2307	e2 20		sep #$20	            SEP #$20
.1a2309	a5 0e		lda $080e	            LDA SCRATCH+2
.1a230b	e9 00		sbc #$00	            SBC #0
.1a230d	85 0e		sta $080e	            STA SCRATCH+2
.1a230f	c2 20		rep #$20	            REP #$20
.1a2311	38		sec		            SEC
.1a2312	a5 08		lda $0808	            LDA INDEX
.1a2314	e9 01 00	sbc #$0001	            SBC #1
.1a2317	85 08		sta $0808	            STA INDEX
.1a2319	e2 20		sep #$20	            SEP #$20
.1a231b	a5 0a		lda $080a	            LDA INDEX+2
.1a231d	e9 00		sbc #$00	            SBC #0
.1a231f	85 0a		sta $080a	            STA INDEX+2
.1a2321	80 c6		bra $1a22e9	            BRA mvu_loop        ; And try again
.1a2323	28		plp		done        PLP
.1a2324	60		rts		            RTS
.1a2325					DELLINE
.1a2325	08		php		            PHP
.1a2326	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; SCRATCH := INDEX + [INDEX].LINK (address of the following line)
.1a2329	c2 20		rep #$20	            REP #$20
.1a232b	18		clc		            CLC
.1a232c	a5 08		lda $0808	            LDA INDEX
.1a232e	77 08		adc [$0808],y	            ADC [INDEX],Y
.1a2330	85 0c		sta $080c	            STA SCRATCH
.1a2332	e2 20		sep #$20	            SEP #$20
.1a2334	a5 0a		lda $080a	            LDA INDEX+2
.1a2336	69 00		adc #$00	            ADC #0
.1a2338	85 0e		sta $080e	            STA SCRATCH+2
.1a233a	c2 20		rep #$20	            REP #$20
.1a233c	18		clc		            CLC
.1a233d	a5 d9		lda $08d9	            LDA LASTLINE
.1a233f	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a2342	85 00		sta $0800	            STA BIP
.1a2344	e2 20		sep #$20	            SEP #$20
.1a2346	a5 db		lda $08db	            LDA LASTLINE+2
.1a2348	69 00		adc #$00	            ADC #0
.1a234a	85 02		sta $0802	            STA BIP+2
.1a234c	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; LASTLINE := LASTLINE - [INDEX].LINK
.1a234f	c2 20		rep #$20	            REP #$20
.1a2351	38		sec		            SEC
.1a2352	a5 d9		lda $08d9	            LDA LASTLINE
.1a2354	f7 08		sbc [$0808],y	            SBC [INDEX],Y
.1a2356	85 d9		sta $08d9	            STA LASTLINE
.1a2358	e2 20		sep #$20	            SEP #$20
.1a235a	a5 db		lda $08db	            LDA LASTLINE+2
.1a235c	e9 00		sbc #$00	            SBC #0
.1a235e	85 db		sta $08db	            STA LASTLINE+2
.1a2360	20 a9 22	jsr $1a22a9	            JSR MVPROGDN
.1a2363					done
.1a2363	20 ac 42	jsr $1a42ac	            JSR S_CLR
.1a2366	28		plp		            PLP
.1a2367	60		rts		            RTS
.1a2368					APPLINE
.1a2368	08		php		            PHP
.1a2369	08		php		            PHP
.1a236a	c2 20		rep #$20	            REP #$20
.1a236c	48		pha		            PHA
.1a236d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a2370	5b		tcd		            TCD
.1a2371	68		pla		            PLA
.1a2372	28		plp		            PLP
.1a2373	c2 30		rep #$30	            REP #$30
.1a2375	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the line number of the new line
.1a2378	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.1a237a	18		clc		            CLC                 ; Point INDEX to the position to store the tokens
.1a237b	a5 d9		lda $08d9	            LDA LASTLINE
.1a237d	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a2380	85 08		sta $0808	            STA INDEX
.1a2382	e2 20		sep #$20	            SEP #$20
.1a2384	a5 db		lda $08db	            LDA LASTLINE+2
.1a2386	69 00		adc #$00	            ADC #0
.1a2388	85 0a		sta $080a	            STA INDEX+2
.1a238a	e2 20		sep #$20	            SEP #$20
.1a238c	a0 00 00	ldy #$0000	            LDY #0
.1a238f	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Copy the tokenized line to its place in the code
.1a2391	97 08		sta [$0808],y	            STA [INDEX],Y
.1a2393	f0 03		beq $1a2398	            BEQ copy_done
.1a2395	c8		iny		            INY
.1a2396	80 f7		bra $1a238f	            BRA copy_loop
.1a2398					copy_done
.1a2398	c2 20		rep #$20	            REP #$20
.1a239a	98		tya		            TYA
.1a239b	18		clc		            CLC
.1a239c	69 05 00	adc #$0005	            ADC #LINE_TOKENS+1
.1a239f	85 0c		sta $080c	            STA SCRATCH
.1a23a1	c2 20		rep #$20	            REP #$20
.1a23a3	a0 00 00	ldy #$0000	            LDY #LINE_LINK      ; Set link to the offset to the next line
.1a23a6	a5 0c		lda $080c	            LDA SCRATCH
.1a23a8	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.1a23aa	c2 20		rep #$20	            REP #$20
.1a23ac	18		clc		            CLC
.1a23ad	a5 d9		lda $08d9	            LDA LASTLINE
.1a23af	65 0c		adc $080c	            ADC SCRATCH
.1a23b1	85 0c		sta $080c	            STA SCRATCH
.1a23b3	e2 20		sep #$20	            SEP #$20
.1a23b5	a5 db		lda $08db	            LDA LASTLINE+2
.1a23b7	69 00		adc #$00	            ADC #0
.1a23b9	85 db		sta $08db	            STA LASTLINE+2
.1a23bb	c2 20		rep #$20	            REP #$20
.1a23bd	a5 0c		lda $080c	            LDA SCRATCH
.1a23bf	85 d9		sta $08d9	            STA LASTLINE
.1a23c1	c2 20		rep #$20	            REP #$20
.1a23c3	a0 00 00	ldy #$0000	            LDY #0
.1a23c6	a9 00 00	lda #$0000	            LDA #0
.1a23c9	97 d9		sta [$08d9],y	blank_loop  STA [LASTLINE],Y    ; Set the "line" after the last line to nulls
.1a23cb	c8		iny		            INY
.1a23cc	c0 05 00	cpy #$0005	            CPY #LINE_TOKENS+1
.1a23cf	d0 f8		bne $1a23c9	            BNE blank_loop
.1a23d1	20 ac 42	jsr $1a42ac	            JSR S_CLR
.1a23d4	28		plp		            PLP
.1a23d5	60		rts		            RTS
.1a23d6					FINDINSPT
.1a23d6	0b		phd		            PHD
.1a23d7	08		php		            PHP
.1a23d8	08		php		            PHP
.1a23d9	c2 20		rep #$20	            REP #$20
.1a23db	48		pha		            PHA
.1a23dc	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a23df	5b		tcd		            TCD
.1a23e0	68		pla		            PLA
.1a23e1	28		plp		            PLP
.1a23e2	c2 30		rep #$30	            REP #$30
.1a23e4	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.1a23e7	85 08		sta $0808	            STA INDEX
.1a23e9	a9 16 00	lda #$0016	            LDA #`BASIC_BOT
.1a23ec	85 0a		sta $080a	            STA INDEX+2
.1a23ee	a0 02 00	ldy #$0002	loop        LDY #LINE_NUMBER
.1a23f1	b7 08		lda [$0808],y	            LDA [INDEX],Y
.1a23f3	f0 1d		beq $1a2412	            BEQ found_end           ; Got to end without finding it
.1a23f5	c5 d7		cmp $08d7	            CMP LINENUM
.1a23f7	f0 25		beq $1a241e	            BEQ found_line          ; LINENUM = [INDEX].LINE_NUMBER: return we found the exact line
.1a23f9	b0 1d		bcs $1a2418	            BGE found_spot          ; LINENUM > [INDEX].LINE_NUMBER: return we found spot to insert
.1a23fb	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a23fe	18		clc		            CLC                     ; Move INDEX to the next line
.1a23ff	a5 08		lda $0808	            LDA INDEX
.1a2401	77 08		adc [$0808],y	            ADC [INDEX],Y
.1a2403	85 0c		sta $080c	            STA SCRATCH
.1a2405	a5 0a		lda $080a	            LDA INDEX+2
.1a2407	69 00 00	adc #$0000	            ADC #0
.1a240a	85 0a		sta $080a	            STA INDEX+2
.1a240c	a5 0c		lda $080c	            LDA SCRATCH
.1a240e	85 08		sta $0808	            STA INDEX
.1a2410	80 dc		bra $1a23ee	            BRA loop                ; And check that line
.1a2412	a9 00 00	lda #$0000	found_end   LDA #0                  ; Return that we reached the end of the program
.1a2415	28		plp		            PLP
.1a2416	2b		pld		            PLD
.1a2417	60		rts		            RTS
.1a2418	a9 01 00	lda #$0001	found_spot  LDA #1                  ; Return that we the found the spot to insert the line
.1a241b	28		plp		            PLP                     ; But that it wasn't already there
.1a241c	2b		pld		            PLD
.1a241d	60		rts		            RTS
.1a241e	a9 02 00	lda #$0002	found_line  LDA #2                  ; Return that we found the line
.1a2421	28		plp		            PLP
.1a2422	2b		pld		            PLD
.1a2423	60		rts		            RTS
.1a2424					INSLINE
.1a2424	08		php		            PHP
.1a2425	c2 30		rep #$30	            REP #$30
.1a2427	a9 05 00	lda #$0005	            LDA #LINE_TOKENS+1  ; Set SCRATCH2 to the size of the line header with the end-of-line
.1a242a	85 10		sta $0810	            STA SCRATCH2
.1a242c	a0 00 00	ldy #$0000	            LDY #0
.1a242f					count_loop
.1a242f	e2 20		sep #$20	            SEP #$20
.1a2431	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the byte of the line
.1a2433	f0 07		beq $1a243c	            BEQ shift_prog      ; If it's end-of-line, SCRATCH2 is the length
.1a2435	c2 20		rep #$20	            REP #$20
.1a2437	e6 10		inc $0810	            INC SCRATCH2
.1a2439	c8		iny		            INY
.1a243a	80 f3		bra $1a242f	            BRA count_loop      ; Count and continue
.1a243c					shift_prog
.1a243c	c2 20		rep #$20	            REP #$20
.1a243e	a5 08		lda $0808	            LDA INDEX           ; BIP = the address of the first byte for the new line
.1a2440	85 00		sta $0800	            STA BIP
.1a2442	a5 0a		lda $080a	            LDA INDEX+2
.1a2444	85 02		sta $0802	            STA BIP+2
.1a2446	18		clc		            CLC                 ; SCRATCH = address of highest byte to copy
.1a2447	a5 d9		lda $08d9	            LDA LASTLINE
.1a2449	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a244c	85 0c		sta $080c	            STA SCRATCH
.1a244e	a5 db		lda $08db	            LDA LASTLINE+2
.1a2450	69 00 00	adc #$0000	            ADC #0
.1a2453	85 0e		sta $080e	            STA SCRATCH+2
.1a2455	18		clc		            CLC                 ; Adjust LASTLINE to its new position after the insert
.1a2456	a5 d9		lda $08d9	            LDA LASTLINE
.1a2458	65 10		adc $0810	            ADC SCRATCH2
.1a245a	85 d9		sta $08d9	            STA LASTLINE
.1a245c	a5 db		lda $08db	            LDA LASTLINE+2
.1a245e	69 00 00	adc #$0000	            ADC #0
.1a2461	85 db		sta $08db	            STA LASTLINE+2
.1a2463	18		clc		            CLC                 ; INDEX = address of the highest location to copy into
.1a2464	a5 d9		lda $08d9	            LDA LASTLINE
.1a2466	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a2469	85 08		sta $0808	            STA INDEX
.1a246b	a5 db		lda $08db	            LDA LASTLINE+2
.1a246d	69 00 00	adc #$0000	            ADC #0
.1a2470	85 0a		sta $080a	            STA INDEX+2
.1a2472	20 e8 22	jsr $1a22e8	            JSR MVPROGUP
.1a2475	c2 20		rep #$20	            REP #$20
.1a2477	a5 10		lda $0810	            LDA SCRATCH2
.1a2479	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.1a247c	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINK_LINK = length of the new line
.1a247e	a5 d7		lda $08d7	            LDA LINENUM
.1a2480	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.1a2483	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINE_NUMBER = number of the new line
.1a2485	18		clc		            CLC                 ; Point BIP to the first byte of the new line
.1a2486	a5 00		lda $0800	            LDA BIP
.1a2488	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.1a248b	85 00		sta $0800	            STA BIP
.1a248d	a5 02		lda $0802	            LDA BIP+2
.1a248f	69 00 00	adc #$0000	            ADC #0
.1a2492	85 02		sta $0802	            STA BIP+2
.1a2494	a0 00 00	ldy #$0000	            LDY #0
.1a2497	e2 20		sep #$20	            SEP #$20
.1a2499	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Get the byte of the tokenized line
.1a249b	97 00		sta [$0800],y	            STA [BIP],Y         ; Copy it to its correct location in the program
.1a249d	f0 03		beq $1a24a2	            BEQ done            ; If it was end-of-line byte, we're done
.1a249f	c8		iny		            INY
.1a24a0	80 f7		bra $1a2499	            BRA copy_loop       ; Otherwise, continue with the next
.1a24a2					done
.1a24a2	20 ac 42	jsr $1a42ac	            JSR S_CLR
.1a24a5	28		plp		            PLP
.1a24a6	60		rts		            RTS
.1a24a7					ADDLINE
.1a24a7	08		php		            PHP
.1a24a8	c2 30		rep #$30	            REP #$30
.1a24aa	85 d7		sta $08d7	            STA LINENUM
.1a24ac	20 d6 23	jsr $1a23d6	            JSR FINDINSPT
.1a24af	c9 00 00	cmp #$0000	            CMP #0
.1a24b2	f0 2c		beq $1a24e0	            BEQ do_append       ; End-of-program found, add the line to the end
.1a24b4	c9 01 00	cmp #$0001	            CMP #1
.1a24b7	f0 22		beq $1a24db	            BEQ do_insert       ; Spot was found: insertion required
.1a24b9	c2 20		rep #$20	            REP #$20
.1a24bb	a5 08		lda $0808	            LDA INDEX
.1a24bd	48		pha		            PHA
.1a24be	a5 0a		lda $080a	            LDA INDEX+2
.1a24c0	48		pha		            PHA
.1a24c1	20 25 23	jsr $1a2325	            JSR DELLINE
.1a24c4	68		pla		            PLA
.1a24c5	85 0a		sta $080a	            STA INDEX+2
.1a24c7	68		pla		            PLA
.1a24c8	85 08		sta $0808	            STA INDEX
.1a24ca	a5 1a		lda $081a	            LDA CURLINE         ; Check to see if there is any non-whitespace on the line
.1a24cc	85 00		sta $0800	            STA BIP
.1a24ce	a5 1c		lda $081c	            LDA CURLINE+2
.1a24d0	85 02		sta $0802	            STA BIP+2
.1a24d2	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a24d5	e2 20		sep #$20	            SEP #$20
.1a24d7	a7 00		lda [$0800]	            LDA [BIP]
.1a24d9	f0 0a		beq $1a24e5	            BEQ done            ; If not, we're done
.1a24db					do_insert
.1a24db	20 24 24	jsr $1a2424	            JSR INSLINE
.1a24de	80 05		bra $1a24e5	            BRA done
.1a24e0	a5 d7		lda $08d7	do_append   LDA LINENUM
.1a24e2	20 68 23	jsr $1a2368	            JSR APPLINE
.1a24e5	28		plp		done        PLP
.1a24e6	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\repl.s

="#"					CHAR_DIR = '#'
="|"					CHAR_BRUN = '|'
.1a24e7					EXPANDLINE
.1a24e7	0b		phd		                PHD
.1a24e8	08		php		                PHP
.1a24e9	08		php		            PHP
.1a24ea	c2 20		rep #$20	            REP #$20
.1a24ec	48		pha		            PHA
.1a24ed	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a24f0	5b		tcd		            TCD
.1a24f1	68		pla		            PLA
.1a24f2	28		plp		            PLP
.1a24f3	e2 20		sep #$20	            SEP #$20
.1a24f5	c2 10		rep #$10	            REP #$10
.1a24f7	a2 00 00	ldx #$0000	                LDX #0
.1a24fa	bd 00 4f	lda $4f00,x	count_loop      LDA INPUTBUF,X              ; Count the number of characters in the input
.1a24fd	f0 03		beq $1a2502	                BEQ save_size
.1a24ff	e8		inx		                INX
.1a2500	80 f8		bra $1a24fa	                BRA count_loop
.1a2502	86 0c		stx $080c	save_size       STX SCRATCH                 ; Save the size in SCRATCH
.1a2504	c2 30		rep #$30	            REP #$30
.1a2506	8a		txa		                TXA
.1a2507	c9 02 00	cmp #$0002	                CMP #2                      ; Are there arguments?
.1a250a	90 12		bcc $1a251e	                BLT start_copy              ; No: just replace the whole string
.1a250c	3a		dec a		                DEC A
.1a250d	18		clc		                CLC
.1a250e	69 00 4f	adc #$4f00	                ADC #<>INPUTBUF
.1a2511	aa		tax		                TAX                         ; X <-- INPUTBUF + len(INPUTBUF) - 1
.1a2512	18		clc		                CLC                         ; Y <-- INPUTBUF + len(INPUTBUF) - 1 + len(substitution)
.1a2513	65 8f		adc $088f	                ADC MCOUNT
.1a2515	a8		tay		                TAY
.1a2516	a5 0c		lda $080c	                LDA SCRATCH
.1a2518	3a		dec a		                DEC A
.1a2519	8b		phb		                PHB
.1a251a	44 00 00	mvp #$00,#$00	                MVP #`INPUTBUF,#`INPUTBUF   ; Make room for the substitition
.1a251d	ab		plb		                PLB
.1a251e					start_copy
.1a251e	c2 20		rep #$20	            REP #$20
.1a2520	a6 55		ldx $0855	                LDX MARG1                   ; Source is data to copy
.1a2522	a0 00 4f	ldy #$4f00	                LDY #<>INPUTBUF             ; Destination is input buffer
.1a2525	a5 8f		lda $088f	                LDA MCOUNT                  ; Number of bytes to copy
.1a2527	8b		phb		                PHB
.1a2528	54 00 1a	mvn #$1a,#$00	                MVN #`EXPANDLINE,#`INPUTBUF ; Copy the data
.1a252b	ab		plb		                PLB
.1a252c	e2 20		sep #$20	            SEP #$20
.1a252e	a5 0c		lda $080c	                LDA SCRATCH                 ; Check again to see if we need quotes
.1a2530	c9 02		cmp #$02	                CMP #2
.1a2532	90 18		bcc $1a254c	                BLT done
.1a2534	a6 8f		ldx $088f	                LDX MCOUNT                  ; If so, add a quote mark here
.1a2536	a9 22		lda #$22	                LDA #CHAR_DQUOTE
.1a2538	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a253b	e8		inx		skip_to_end     INX                         ; Move to the end of the input string
.1a253c	bd 00 4f	lda $4f00,x	                LDA INPUTBUF,X
.1a253f	d0 fa		bne $1a253b	                BNE skip_to_end
.1a2541	a9 22		lda #$22	                LDA #CHAR_DQUOTE            ; Add the quote to the end of the string
.1a2543	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a2546	a9 00		lda #$00	                LDA #0                      ; And terminate with a NULL
.1a2548	e8		inx		                INX
.1a2549	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a254c	28		plp		done            PLP
.1a254d	2b		pld		                PLD
.1a254e	60		rts		            RTS
.1a254f					PREPROCESS
.1a254f	da		phx		                PHX
.1a2550	5a		phy		                PHY
.1a2551	8b		phb		                PHB
.1a2552	0b		phd		                PHD
.1a2553	08		php		                PHP
.1a2554	08		php		            PHP
.1a2555	c2 20		rep #$20	            REP #$20
.1a2557	48		pha		            PHA
.1a2558	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a255b	5b		tcd		            TCD
.1a255c	68		pla		            PLA
.1a255d	28		plp		            PLP
.1a255e	e2 20		sep #$20	            SEP #$20
.1a2560	c2 10		rep #$10	            REP #$10
.1a2562	ad 00 4f	lda $4f00	                LDA INPUTBUF            ; Check the first character
.1a2565	c9 23		cmp #$23	                CMP #CHAR_DIR           ; Is it the DIR character?
.1a2567	f0 0a		beq $1a2573	                BEQ expand_dir          ; Yes: expand the DIR command into place
.1a2569	c9 7c		cmp #$7c	                CMP #CHAR_BRUN          ; Is it the BRUN character?
.1a256b	f0 17		beq $1a2584	                BEQ expand_brun         ; Yes: expand the BRUN command into place
.1a256d	28		plp		done            PLP
.1a256e	2b		pld		                PLD
.1a256f	ab		plb		                PLB
.1a2570	7a		ply		                PLY
.1a2571	fa		plx		                PLX
.1a2572	60		rts		            RTS
.1a2573					expand_dir
.1a2573	c2 20		rep #$20	            REP #$20
.1a2575	a9 03 00	lda #$0003	                LDA #3                  ; Set size of substitution value
.1a2578	85 8f		sta $088f	                STA MCOUNT
.1a257a	a9 95 25	lda #$2595	                LDA #<>dir_text         ; Set pointer to substitution value
.1a257d	85 55		sta $0855	                STA MARG1
.1a257f	20 e7 24	jsr $1a24e7	            JSR EXPANDLINE
.1a2582	80 e9		bra $1a256d	                BRA done
.1a2584					expand_brun
.1a2584	c2 20		rep #$20	            REP #$20
.1a2586	a9 04 00	lda #$0004	                LDA #4                  ; Set size of substitution value
.1a2589	85 8f		sta $088f	                STA MCOUNT
.1a258b	a9 99 25	lda #$2599	                LDA #<>brun_text        ; Set pointer to substitution value
.1a258e	85 55		sta $0855	                STA MARG1
.1a2590	20 e7 24	jsr $1a24e7	            JSR EXPANDLINE
.1a2593	80 d8		bra $1a256d	                BRA done
>1a2595	44 49 52 00			dir_text        .null "DIR"             ; Expansion of the DIR character
>1a2599	42 52 55 4e 00			brun_text       .null "BRUN"            ; Expansion of the BRUN character
.1a259e					PRREADY
.1a259e	8b		phb		                PHB
.1a259f	08		php		                PHP
.1a25a0	20 e4 00	jsr $1a00e4	            JSR ENSURETEXT
.1a25a3	08		php		            PHP
.1a25a4	e2 20		sep #$20	            SEP #$20
.1a25a6	48		pha		            PHA
.1a25a7	a9 1a		lda #$1a	            LDA #`MPROMPT
.1a25a9	48		pha		            PHA
.1a25aa	ab		plb		            PLB
.1a25ab	68		pla		            PLA
.1a25ac	28		plp		            PLP
.1a25ad	a2 69 d2	ldx #$d269	                LDX #<>MPROMPT
.1a25b0	20 16 03	jsr $1a0316	            JSR PRINTS
.1a25b3	28		plp		                PLP
.1a25b4	ab		plb		                PLB
.1a25b5	60		rts		            RTS
.1a25b6					IREADLINE
.1a25b6	08		php		                PHP
.1a25b7	e2 30		sep #$30	            SEP #$30
.1a25b9	a9 01		lda #$01	                LDA #1
.1a25bb	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a25be					read_loop
.1a25be	20 db 00	jsr $1a00db	            JSR GETKEYE
.1a25c1	f0 06		beq $1a25c9	                BEQ done
.1a25c3	c9 0d		cmp #$0d	                CMP #CHAR_CR
.1a25c5	f0 02		beq $1a25c9	                BEQ done
.1a25c7	80 f5		bra $1a25be	                BRA read_loop
.1a25c9	28		plp		done            PLP
.1a25ca	60		rts		            RTS
.1a25cb					PROCESS
.1a25cb	0b		phd		                PHD
.1a25cc	08		php		                PHP
.1a25cd	08		php		            PHP
.1a25ce	c2 20		rep #$20	            REP #$20
.1a25d0	48		pha		            PHA
.1a25d1	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a25d4	5b		tcd		            TCD
.1a25d5	68		pla		            PLA
.1a25d6	28		plp		            PLP
.1a25d7	c2 30		rep #$30	            REP #$30
.1a25d9	64 d7		stz $08d7	                STZ LINENUM
.1a25db	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF         ; Attempt to tokenize the line that was read
.1a25de	85 1a		sta $081a	                STA CURLINE
.1a25e0	a9 00 00	lda #$0000	                LDA #`CURLINE
.1a25e3	85 1c		sta $081c	                STA CURLINE+2
.1a25e5	20 4e 08	jsr $1a084e	            JSR TOKENIZE
.1a25e8	c2 20		rep #$20	            REP #$20
.1a25ea	a5 d7		lda $08d7	                LDA LINENUM             ; Did we get a line number?
.1a25ec	d0 05		bne $1a25f3	                BNE update_line         ; Yes: attempt to add it to the program
.1a25ee	20 8e 21	jsr $1a218e	            JSR EXECCMD
.1a25f1	80 07		bra $1a25fa	                BRA done
.1a25f3					update_line
.1a25f3	20 a7 24	jsr $1a24a7	            JSR ADDLINE
.1a25f6	28		plp		no_prompt       PLP
.1a25f7	2b		pld		                PLD
.1a25f8	38		sec		                SEC
.1a25f9	60		rts		            RTS
.1a25fa	28		plp		done            PLP
.1a25fb	2b		pld		                PLD
.1a25fc	18		clc		                CLC
.1a25fd	60		rts		            RTS
.1a25fe					INTERACT
.1a25fe	c2 30		rep #$30	            REP #$30
.1a2600	a2 ff fe	ldx #$feff	                LDX #<>STACK_END
.1a2603	9a		txs		                TXS
.1a2604					ready_loop
.1a2604	20 9e 25	jsr $1a259e	            JSR PRREADY
.1a2607					no_ready_loop
.1a2607	20 08 00	jsr $1a0008	            JSR READLINE
.1a260a	20 0c 00	jsr $1a000c	            JSR SCRCOPYLINE
.1a260d	a9 00 00	lda #$0000	                LDA #0              ; Hide the cursor
.1a2610	20 1c 00	jsr $1a001c	            JSR SHOWCURSOR
.1a2613	20 4f 25	jsr $1a254f	            JSR PREPROCESS
.1a2616	20 cb 25	jsr $1a25cb	            JSR PROCESS
.1a2619	b0 ec		bcs $1a2607	                BCS no_ready_loop
.1a261b	80 e7		bra $1a2604	                BRA ready_loop
>1ad269	0d 52 45 41 44 59 0d 00		MPROMPT         .null 13,"READY",13

;******  Return to file: src\basic816.s


;******  Processing file: src\operators.s

.1a261d					OP_PLUS
.1a261d	08		php		            PHP
.1a261e	e2 20		sep #$20	            SEP #$20
.1a2620	20 55 07	jsr $1a0755	            JSR ASS_ARGS_NUMSTR
.1a2623	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a2625	f0 2c		beq $1a2653	            BEQ is_integer
.1a2627	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2629	f0 2d		beq $1a2658	            BEQ is_float
.1a262b	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a262d	f0 1f		beq $1a264e	            BEQ is_string
.1a262f					type_error
.1a262f	08		php		            PHP
.1a2630	c2 20		rep #$20	            REP #$20
.1a2632	48		pha		            PHA
.1a2633	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2636	5b		tcd		            TCD
.1a2637	68		pla		            PLA
.1a2638	28		plp		            PLP
.1a2639	e2 20		sep #$20	            SEP #$20
.1a263b	a9 04		lda #$04	            LDA #ERR_TYPE
.1a263d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2641	c2 20		rep #$20	            REP #$20
.1a2643	29 ff 00	and #$00ff	            AND #$00FF
.1a2646	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a2649	e2 20		sep #$20	            SEP #$20
.1a264b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a264e					is_string
.1a264e	20 fe 14	jsr $1a14fe	            JSR STRCONCAT
.1a2651	80 08		bra $1a265b	            BRA done
.1a2653					is_integer
.1a2653	20 df 51	jsr $1a51df	            JSR OP_INT_ADD
.1a2656	80 03		bra $1a265b	            BRA done
.1a2658					is_float
.1a2658	20 4e 54	jsr $1a544e	            JSR OP_FP_ADD
.1a265b	28		plp		done        PLP
.1a265c	60		rts		            RTS
.1a265d					OP_MINUS
.1a265d	08		php		            PHP
.1a265e	e2 20		sep #$20	            SEP #$20
.1a2660	20 07 07	jsr $1a0707	            JSR ASS_ARGS_NUM
.1a2663	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a2665	f0 23		beq $1a268a	            BEQ is_integer
.1a2667	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2669	f0 24		beq $1a268f	            BEQ is_float
.1a266b					type_error
.1a266b	08		php		            PHP
.1a266c	c2 20		rep #$20	            REP #$20
.1a266e	48		pha		            PHA
.1a266f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2672	5b		tcd		            TCD
.1a2673	68		pla		            PLA
.1a2674	28		plp		            PLP
.1a2675	e2 20		sep #$20	            SEP #$20
.1a2677	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2679	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a267d	c2 20		rep #$20	            REP #$20
.1a267f	29 ff 00	and #$00ff	            AND #$00FF
.1a2682	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a2685	e2 20		sep #$20	            SEP #$20
.1a2687	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a268a					is_integer
.1a268a	20 f1 51	jsr $1a51f1	            JSR OP_INT_SUB
.1a268d	80 03		bra $1a2692	            BRA done
.1a268f					is_float
.1a268f	20 43 54	jsr $1a5443	            JSR OP_FP_SUB
.1a2692	28		plp		done        PLP
.1a2693	60		rts		            RTS
.1a2694					OP_MULTIPLY
.1a2694	08		php		            PHP
.1a2695	e2 20		sep #$20	            SEP #$20
.1a2697	20 07 07	jsr $1a0707	            JSR ASS_ARGS_NUM
.1a269a	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a269c	f0 23		beq $1a26c1	            BEQ is_integer
.1a269e	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a26a0	f0 24		beq $1a26c6	            BEQ is_float
.1a26a2					type_error
.1a26a2	08		php		            PHP
.1a26a3	c2 20		rep #$20	            REP #$20
.1a26a5	48		pha		            PHA
.1a26a6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a26a9	5b		tcd		            TCD
.1a26aa	68		pla		            PLA
.1a26ab	28		plp		            PLP
.1a26ac	e2 20		sep #$20	            SEP #$20
.1a26ae	a9 04		lda #$04	            LDA #ERR_TYPE
.1a26b0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a26b4	c2 20		rep #$20	            REP #$20
.1a26b6	29 ff 00	and #$00ff	            AND #$00FF
.1a26b9	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a26bc	e2 20		sep #$20	            SEP #$20
.1a26be	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a26c1					is_integer
.1a26c1	20 03 52	jsr $1a5203	            JSR OP_INT_MUL
.1a26c4	80 03		bra $1a26c9	            BRA done
.1a26c6					is_float
.1a26c6	20 e4 54	jsr $1a54e4	            JSR OP_FP_MUL
.1a26c9	28		plp		done        PLP
.1a26ca	60		rts		            RTS
.1a26cb					OP_DIVIDE
.1a26cb	20 71 06	jsr $1a0671	            JSR ASS_ARG1_FLOAT
.1a26ce	20 a2 06	jsr $1a06a2	            JSR ASS_ARG2_FLOAT
.1a26d1	20 99 54	jsr $1a5499	            JSR OP_FP_DIV
.1a26d4	60		rts		            RTS
.1a26d5					OP_MOD
.1a26d5	a5 23		lda $0823	            LDA ARGUMENT1
.1a26d7	8f 1a 01 00	sta $00011a	            STA @lD1_OPERAND_B
.1a26db	a5 29		lda $0829	            LDA ARGUMENT2
.1a26dd	8f 18 01 00	sta $000118	            STA @lD1_OPERAND_A
.1a26e1	af 1e 01 00	lda $00011e	            LDA @lD1_REMAINDER
.1a26e5	85 23		sta $0823	            STA ARGUMENT1
.1a26e7	60		rts		            RTS
.1a26e8					OP_POW
.1a26e8	08		php		            PHP
.1a26e9	c2 30		rep #$30	            REP #$30
.1a26eb	48		pha		            PHA
.1a26ec	20 71 06	jsr $1a0671	            JSR ASS_ARG1_FLOAT
.1a26ef	a5 2d		lda $082d	            LDA ARGTYPE2
.1a26f1	c9 00 00	cmp #$0000	            CMP #TYPE_INTEGER
.1a26f4	d0 0d		bne $1a2703	            BNE flt_exp
.1a26f6	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a26f8	d0 09		bne $1a2703	            BNE flt_exp
.1a26fa	da		phx		            PHX
.1a26fb	a6 29		ldx $0829	            LDX ARGUMENT2
.1a26fd	20 b7 61	jsr $1a61b7	            JSR Q_FP_POW_INT
.1a2700	fa		plx		            PLX
.1a2701	80 1c		bra $1a271f	            BRA done
.1a2703					flt_exp
.1a2703	20 a2 06	jsr $1a06a2	            JSR ASS_ARG2_FLOAT
.1a2706	c2 20		rep #$20	            REP #$20
.1a2708	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a270a	48		pha		            PHA
.1a270b	a5 29		lda $0829	            LDA ARGUMENT2
.1a270d	48		pha		            PHA
.1a270e	20 42 60	jsr $1a6042	            JSR FP_LN
.1a2711	c2 20		rep #$20	            REP #$20
.1a2713	68		pla		            PLA
.1a2714	85 29		sta $0829	            STA ARGUMENT2
.1a2716	68		pla		            PLA
.1a2717	85 2b		sta $082b	            STA ARGUMENT2+2
.1a2719	20 e4 54	jsr $1a54e4	            JSR OP_FP_MUL
.1a271c	20 21 62	jsr $1a6221	            JSR FP_EXP
.1a271f	68		pla		done        PLA
.1a2720	28		plp		            PLP
.1a2721	60		rts		            RTS
.1a2722					OP_AND
.1a2722	08		php		            PHP
.1a2723	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a2726	20 34 05	jsr $1a0534	            JSR ASS_ARG2_INT
.1a2729	c2 20		rep #$20	            REP #$20
.1a272b	a5 23		lda $0823	            LDA ARGUMENT1
.1a272d	25 29		and $0829	            AND ARGUMENT2
.1a272f	85 23		sta $0823	            STA ARGUMENT1
.1a2731	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a2733	25 2b		and $082b	            AND ARGUMENT2+2
.1a2735	85 25		sta $0825	            STA ARGUMENT1+2
.1a2737	28		plp		            PLP
.1a2738	60		rts		            RTS
.1a2739					OP_OR
.1a2739	08		php		            PHP
.1a273a	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a273d	20 34 05	jsr $1a0534	            JSR ASS_ARG2_INT
.1a2740	c2 20		rep #$20	            REP #$20
.1a2742	a5 23		lda $0823	            LDA ARGUMENT1
.1a2744	05 29		ora $0829	            ORA ARGUMENT2
.1a2746	85 23		sta $0823	            STA ARGUMENT1
.1a2748	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a274a	05 2b		ora $082b	            ORA ARGUMENT2+2
.1a274c	85 25		sta $0825	            STA ARGUMENT1+2
.1a274e	28		plp		done        PLP
.1a274f	60		rts		            RTS
.1a2750					OP_NOT
.1a2750	08		php		            PHP
.1a2751	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a2754	c2 20		rep #$20	            REP #$20
.1a2756	a5 23		lda $0823	            LDA ARGUMENT1
.1a2758	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a275b	85 23		sta $0823	            STA ARGUMENT1
.1a275d	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a275f	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a2762	85 25		sta $0825	            STA ARGUMENT1+2
.1a2764	28		plp		done        PLP
.1a2765	60		rts		            RTS
.1a2766					OP_LT
.1a2766	08		php		            PHP
.1a2767	e2 20		sep #$20	            SEP #$20
.1a2769	20 55 07	jsr $1a0755	            JSR ASS_ARGS_NUMSTR
.1a276c	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a276e	f0 2c		beq $1a279c	            BEQ is_integer
.1a2770	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2772	f0 2d		beq $1a27a1	            BEQ is_float
.1a2774	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a2776	f0 1f		beq $1a2797	            BEQ is_string
.1a2778					type_error
.1a2778	08		php		            PHP
.1a2779	c2 20		rep #$20	            REP #$20
.1a277b	48		pha		            PHA
.1a277c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a277f	5b		tcd		            TCD
.1a2780	68		pla		            PLA
.1a2781	28		plp		            PLP
.1a2782	e2 20		sep #$20	            SEP #$20
.1a2784	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2786	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a278a	c2 20		rep #$20	            REP #$20
.1a278c	29 ff 00	and #$00ff	            AND #$00FF
.1a278f	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a2792	e2 20		sep #$20	            SEP #$20
.1a2794	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2797					is_string
.1a2797	20 86 16	jsr $1a1686	            JSR OP_STR_LT
.1a279a	80 08		bra $1a27a4	            BRA done
.1a279c					is_integer
.1a279c	20 04 53	jsr $1a5304	            JSR OP_INT_LT
.1a279f	80 03		bra $1a27a4	            BRA done
.1a27a1					is_float
.1a27a1	20 79 5a	jsr $1a5a79	            JSR OP_FP_LT
.1a27a4	28		plp		done        PLP
.1a27a5	60		rts		            RTS
.1a27a6					OP_GT
.1a27a6	08		php		            PHP
.1a27a7	e2 20		sep #$20	            SEP #$20
.1a27a9	20 55 07	jsr $1a0755	            JSR ASS_ARGS_NUMSTR
.1a27ac	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a27ae	f0 2c		beq $1a27dc	            BEQ is_integer
.1a27b0	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a27b2	f0 2d		beq $1a27e1	            BEQ is_float
.1a27b4	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a27b6	f0 1f		beq $1a27d7	            BEQ is_string
.1a27b8					type_error
.1a27b8	08		php		            PHP
.1a27b9	c2 20		rep #$20	            REP #$20
.1a27bb	48		pha		            PHA
.1a27bc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a27bf	5b		tcd		            TCD
.1a27c0	68		pla		            PLA
.1a27c1	28		plp		            PLP
.1a27c2	e2 20		sep #$20	            SEP #$20
.1a27c4	a9 04		lda #$04	            LDA #ERR_TYPE
.1a27c6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a27ca	c2 20		rep #$20	            REP #$20
.1a27cc	29 ff 00	and #$00ff	            AND #$00FF
.1a27cf	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a27d2	e2 20		sep #$20	            SEP #$20
.1a27d4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a27d7					is_string
.1a27d7	20 9d 16	jsr $1a169d	            JSR OP_STR_GT
.1a27da	80 08		bra $1a27e4	            BRA done
.1a27dc					is_integer
.1a27dc	20 25 53	jsr $1a5325	            JSR OP_INT_GT
.1a27df	80 03		bra $1a27e4	            BRA done
.1a27e1					is_float
.1a27e1	20 8e 5a	jsr $1a5a8e	            JSR OP_FP_GT
.1a27e4	28		plp		done        PLP
.1a27e5	60		rts		            RTS
.1a27e6					OP_EQ
.1a27e6	08		php		            PHP
.1a27e7	e2 20		sep #$20	            SEP #$20
.1a27e9	20 55 07	jsr $1a0755	            JSR ASS_ARGS_NUMSTR
.1a27ec	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a27ee	f0 2c		beq $1a281c	            BEQ is_integer
.1a27f0	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a27f2	f0 2d		beq $1a2821	            BEQ is_float
.1a27f4	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a27f6	f0 1f		beq $1a2817	            BEQ is_string
.1a27f8					type_error
.1a27f8	08		php		            PHP
.1a27f9	c2 20		rep #$20	            REP #$20
.1a27fb	48		pha		            PHA
.1a27fc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a27ff	5b		tcd		            TCD
.1a2800	68		pla		            PLA
.1a2801	28		plp		            PLP
.1a2802	e2 20		sep #$20	            SEP #$20
.1a2804	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2806	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a280a	c2 20		rep #$20	            REP #$20
.1a280c	29 ff 00	and #$00ff	            AND #$00FF
.1a280f	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a2812	e2 20		sep #$20	            SEP #$20
.1a2814	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2817					is_string
.1a2817	20 b4 16	jsr $1a16b4	            JSR OP_STR_EQ
.1a281a	80 08		bra $1a2824	            BRA done
.1a281c					is_integer
.1a281c	20 52 53	jsr $1a5352	            JSR OP_INT_EQ
.1a281f	80 03		bra $1a2824	            BRA done
.1a2821					is_float
.1a2821	20 a3 5a	jsr $1a5aa3	            JSR OP_FP_EQ
.1a2824	28		plp		done        PLP
.1a2825	60		rts		            RTS
.1a2826					OP_NE
.1a2826	08		php		            PHP
.1a2827	e2 20		sep #$20	            SEP #$20
.1a2829	20 55 07	jsr $1a0755	            JSR ASS_ARGS_NUMSTR
.1a282c	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a282e	f0 2c		beq $1a285c	            BEQ is_integer
.1a2830	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2832	f0 2d		beq $1a2861	            BEQ is_float
.1a2834	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a2836	f0 1f		beq $1a2857	            BEQ is_string
.1a2838					type_error
.1a2838	08		php		            PHP
.1a2839	c2 20		rep #$20	            REP #$20
.1a283b	48		pha		            PHA
.1a283c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a283f	5b		tcd		            TCD
.1a2840	68		pla		            PLA
.1a2841	28		plp		            PLP
.1a2842	e2 20		sep #$20	            SEP #$20
.1a2844	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2846	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a284a	c2 20		rep #$20	            REP #$20
.1a284c	29 ff 00	and #$00ff	            AND #$00FF
.1a284f	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a2852	e2 20		sep #$20	            SEP #$20
.1a2854	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2857					is_string
.1a2857	20 cb 16	jsr $1a16cb	            JSR OP_STR_NE
.1a285a	80 08		bra $1a2864	            BRA done
.1a285c					is_integer
.1a285c	20 70 53	jsr $1a5370	            JSR OP_INT_NE
.1a285f	80 03		bra $1a2864	            BRA done
.1a2861					is_float
.1a2861	20 e2 5a	jsr $1a5ae2	            JSR OP_FP_NE
.1a2864	28		plp		done        PLP
.1a2865	60		rts		            RTS
.1a2866					OP_GTE
.1a2866	08		php		            PHP
.1a2867	e2 20		sep #$20	            SEP #$20
.1a2869	20 55 07	jsr $1a0755	            JSR ASS_ARGS_NUMSTR
.1a286c	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a286e	f0 2c		beq $1a289c	            BEQ is_integer
.1a2870	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a2872	f0 2d		beq $1a28a1	            BEQ is_float
.1a2874	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a2876	f0 1f		beq $1a2897	            BEQ is_string
.1a2878					type_error
.1a2878	08		php		            PHP
.1a2879	c2 20		rep #$20	            REP #$20
.1a287b	48		pha		            PHA
.1a287c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a287f	5b		tcd		            TCD
.1a2880	68		pla		            PLA
.1a2881	28		plp		            PLP
.1a2882	e2 20		sep #$20	            SEP #$20
.1a2884	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2886	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a288a	c2 20		rep #$20	            REP #$20
.1a288c	29 ff 00	and #$00ff	            AND #$00FF
.1a288f	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a2892	e2 20		sep #$20	            SEP #$20
.1a2894	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2897					is_string
.1a2897	20 e2 16	jsr $1a16e2	            JSR OP_STR_GTE
.1a289a	80 08		bra $1a28a4	            BRA done
.1a289c					is_integer
.1a289c	20 8e 53	jsr $1a538e	            JSR OP_INT_GTE
.1a289f	80 03		bra $1a28a4	            BRA done
.1a28a1					is_float
.1a28a1	20 cd 5a	jsr $1a5acd	            JSR OP_FP_GTE
.1a28a4	28		plp		done        PLP
.1a28a5	60		rts		            RTS
.1a28a6					OP_LTE
.1a28a6	08		php		            PHP
.1a28a7	e2 20		sep #$20	            SEP #$20
.1a28a9	20 55 07	jsr $1a0755	            JSR ASS_ARGS_NUMSTR
.1a28ac	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.1a28ae	f0 2c		beq $1a28dc	            BEQ is_integer
.1a28b0	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.1a28b2	f0 2d		beq $1a28e1	            BEQ is_float
.1a28b4	c9 02		cmp #$02	            CMP #TYPE_STRING
.1a28b6	f0 1f		beq $1a28d7	            BEQ is_string
.1a28b8					type_error
.1a28b8	08		php		            PHP
.1a28b9	c2 20		rep #$20	            REP #$20
.1a28bb	48		pha		            PHA
.1a28bc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a28bf	5b		tcd		            TCD
.1a28c0	68		pla		            PLA
.1a28c1	28		plp		            PLP
.1a28c2	e2 20		sep #$20	            SEP #$20
.1a28c4	a9 04		lda #$04	            LDA #ERR_TYPE
.1a28c6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a28ca	c2 20		rep #$20	            REP #$20
.1a28cc	29 ff 00	and #$00ff	            AND #$00FF
.1a28cf	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a28d2	e2 20		sep #$20	            SEP #$20
.1a28d4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a28d7					is_string
.1a28d7	20 f9 16	jsr $1a16f9	            JSR OP_STR_LTE
.1a28da	80 08		bra $1a28e4	            BRA done
.1a28dc					is_integer
.1a28dc	20 bb 53	jsr $1a53bb	            JSR OP_INT_LTE
.1a28df	80 03		bra $1a28e4	            BRA done
.1a28e1					is_float
.1a28e1	20 b8 5a	jsr $1a5ab8	            JSR OP_FP_LTE
.1a28e4	28		plp		done        PLP
.1a28e5	60		rts		            RTS
.1a28e6					OP_NEGATIVE
.1a28e6	08		php		                PHP
.1a28e7	e2 20		sep #$20	            SEP #$20
.1a28e9	a5 27		lda $0827	                LDA ARGTYPE1                ; Check the type of the argument
.1a28eb	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a28ed	f0 2d		beq $1a291c	                BEQ int_negate              ; If integer: negate the integer
.1a28ef	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.1a28f1	f0 1f		beq $1a2912	                BEQ float_negate            ; If floating point: negate the floating point
.1a28f3					type_error
.1a28f3	08		php		            PHP
.1a28f4	c2 20		rep #$20	            REP #$20
.1a28f6	48		pha		            PHA
.1a28f7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a28fa	5b		tcd		            TCD
.1a28fb	68		pla		            PLA
.1a28fc	28		plp		            PLP
.1a28fd	e2 20		sep #$20	            SEP #$20
.1a28ff	a9 04		lda #$04	            LDA #ERR_TYPE
.1a2901	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2905	c2 20		rep #$20	            REP #$20
.1a2907	29 ff 00	and #$00ff	            AND #$00FF
.1a290a	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a290d	e2 20		sep #$20	            SEP #$20
.1a290f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2912					float_negate
.1a2912	e2 20		sep #$20	            SEP #$20
.1a2914	a5 26		lda $0826	                LDA ARGUMENT1+3             ; Flip the sign bit of the floating point number
.1a2916	49 80		eor #$80	                EOR #$80
.1a2918	85 26		sta $0826	                STA ARGUMENT1+3
.1a291a	80 16		bra $1a2932	                BRA done
.1a291c					int_negate
.1a291c	c2 20		rep #$20	            REP #$20
.1a291e	a5 23		lda $0823	                LDA ARGUMENT1               ; Invert ARGUMENT1
.1a2920	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a2923	85 23		sta $0823	                STA ARGUMENT1
.1a2925	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a2927	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a292a	85 25		sta $0825	                STA ARGUMENT1+2
.1a292c	e6 23		inc $0823	                INC ARGUMENT1               ; And increment to get two's complement
.1a292e	d0 02		bne $1a2932	                BNE done
.1a2930	e6 25		inc $0825	                INC ARGUMENT1+2
.1a2932					done
.1a2932	28		plp		                PLP
.1a2933	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\statements.s


;******  Processing file: src\C256/statements_c256.s

=0					GR_LUT_BLUE = 0
=1					GR_LUT_GREEN = 1
=2					GR_LUT_RED = 2
=3					GR_LUT_ALPHA = 3
=640					GR_DEFAULT_COLS = 640               ; Default number of columns in the display
=480					GR_DEFAULT_ROWS = 480               ; Default number of rows in the display
=8					GR_MAX_LUT = 8                      ; The number of LUTs Vicky supports
=64					SP_MAX = 64                         ; The number of sprites Vicky supports
=8					SP_REG_SIZE = 8                     ; The number of bytes in a sprite's register block
=0					SP_CONTROL = 0                      ; Offset of the control regsiter for a sprite
=1					SP_ADDR = 1                         ; Offset of the pixmap address for a sprite
=4					SP_X_COORD = 4                      ; Offset of the X coordinate for a sprite
=6					SP_Y_COORD = 6                      ; Offset of the Y coordinate for a sprite
=12					TILEMAP_REG_SIZE = 12               ; The number of bytes in a tile map's register set
=4					TILESET_REG_SIZE = 4                ; The number of bytes in a tile set's register set
=2					BM_MAX = 2                          ; Maximum number of bitmaps we support
=$0040					MAX_VRAM_VICKY = $0040              ; Upper limit (exclusive) bank address for VRAM in Vicky address space
=$00f0					MAX_VRAM_CPU = $00F0                ; Upper limit (exclusive) bank address for VRAM in CPU address space
=$00b0					MIN_VRAM_CPU = $00B0                ; Lower limit (inclusive) bank address for VRAM in CPU address space
>1af000					GR_BM0_ADDR     .dword ?            ; Address of bitmap 0 (from CPU's perspective)
>1af004					GR_BM1_ADDR     .dword ?            ; Address of bitmap 1 (from CPU's perspective)
>1af008					GR_BM0_VRAM     .dword ?            ; Address of bitmap 0 (relative to start of VRAM)
>1af00c					GR_BM1_VRAM     .dword ?            ; Address of bitmap 1 (relative to start of VRAM)
>1af010					GR_MAX_COLS     .word ?             ; Width the display in pixels
>1af012					GR_MAX_ROWS     .word ?             ; Height of the display in pixels
>1af014					GR_TOTAL_PIXELS .word ?             ; Total number of pixels in the display
>1af016					GR_TEMP         .word ?             ; A temporary word for graphics commands
>1af018					GS_SP_CONTROL   .fill SP_MAX        ; Shadow registers for the sprite controls
.1a2934					S_SETTIME
.1a2934	08		php		                PHP
.1a2935	e2 20		sep #$20	            SEP #$20
.1a2937	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a293a	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a293d	20 60 04	jsr $1a0460	            JSR DIVINT10
.1a2940	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2942	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2943	0a		asl a		                ASL A
.1a2944	0a		asl a		                ASL A
.1a2945	0a		asl a		                ASL A
.1a2946	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2948	48		pha		                PHA
.1a2949	a9 2c		lda #$2c	                LDA #','
.1a294b	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a294e	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2951	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2954	20 60 04	jsr $1a0460	            JSR DIVINT10
.1a2957	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2959	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a295a	0a		asl a		                ASL A
.1a295b	0a		asl a		                ASL A
.1a295c	0a		asl a		                ASL A
.1a295d	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a295f	48		pha		                PHA
.1a2960	a9 2c		lda #$2c	                LDA #','
.1a2962	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a2965	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2968	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a296b	20 60 04	jsr $1a0460	            JSR DIVINT10
.1a296e	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a2970	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a2971	0a		asl a		                ASL A
.1a2972	0a		asl a		                ASL A
.1a2973	0a		asl a		                ASL A
.1a2974	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2976	48		pha		                PHA
.1a2977	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a297b	09 0c		ora #$0c	                ORA #%00001100
.1a297d	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2981	68		pla		                PLA                     ; And seconds to the RTC
.1a2982	8f 00 08 af	sta $af0800	                STA @lRTC_SEC
.1a2986	68		pla		                PLA                     ; Minutes...
.1a2987	8f 02 08 af	sta $af0802	                STA @lRTC_MIN
.1a298b	68		pla		                PLA                     ; Save the hour...
.1a298c	8f 04 08 af	sta $af0804	                STA @lRTC_HRS
.1a2990	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a2994	29 f7		and #$f7	                AND #%11110111
.1a2996	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a299a	20 a3 1f	jsr $1a1fa3	            JSR SKIPSTMT
.1a299d	28		plp		                PLP
.1a299e	60		rts		            RTS
.1a299f					S_SETDATE
.1a299f	08		php		                PHP
.1a29a0	e2 20		sep #$20	            SEP #$20
.1a29a2	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a29a5	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a29a8	20 60 04	jsr $1a0460	            JSR DIVINT10
.1a29ab	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a29ad	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a29ae	0a		asl a		                ASL A
.1a29af	0a		asl a		                ASL A
.1a29b0	0a		asl a		                ASL A
.1a29b1	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a29b3	48		pha		                PHA
.1a29b4	a9 2c		lda #$2c	                LDA #','
.1a29b6	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a29b9	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a29bc	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a29bf	20 60 04	jsr $1a0460	            JSR DIVINT10
.1a29c2	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a29c4	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a29c5	0a		asl a		                ASL A
.1a29c6	0a		asl a		                ASL A
.1a29c7	0a		asl a		                ASL A
.1a29c8	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a29ca	48		pha		                PHA
.1a29cb	a9 2c		lda #$2c	                LDA #','
.1a29cd	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a29d0	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a29d3	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a29d6	20 96 04	jsr $1a0496	            JSR DIVINT100
.1a29d9	c2 20		rep #$20	            REP #$20
.1a29db	a5 23		lda $0823	                LDA ARGUMENT1           ; Get the century
.1a29dd	85 92		sta $0892	                STA MTEMP               ; Save it in MTEMP
.1a29df	a5 29		lda $0829	                LDA ARGUMENT2           ; Separate the 10s from the 1s digits
.1a29e1	85 23		sta $0823	                STA ARGUMENT1
.1a29e3	20 60 04	jsr $1a0460	            JSR DIVINT10
.1a29e6	e2 20		sep #$20	            SEP #$20
.1a29e8	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a29ea	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a29eb	0a		asl a		                ASL A
.1a29ec	0a		asl a		                ASL A
.1a29ed	0a		asl a		                ASL A
.1a29ee	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a29f0	48		pha		                PHA                     ; Save the 10s and 1s in BCD
.1a29f1	c2 20		rep #$20	            REP #$20
.1a29f3	a5 92		lda $0892	                LDA MTEMP               ; Separate the 100s from the 1000s digits
.1a29f5	85 23		sta $0823	                STA ARGUMENT1
.1a29f7	20 60 04	jsr $1a0460	            JSR DIVINT10
.1a29fa	e2 20		sep #$20	            SEP #$20
.1a29fc	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.1a29fe	0a		asl a		                ASL A                   ; Shift it 4 bits
.1a29ff	0a		asl a		                ASL A
.1a2a00	0a		asl a		                ASL A
.1a2a01	0a		asl a		                ASL A
.1a2a02	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.1a2a04	48		pha		                PHA                     ; Save the 100s and 1000s in BCD
.1a2a05	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a2a09	09 0c		ora #$0c	                ORA #%00001100
.1a2a0b	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2a0f	68		pla		                PLA                     ; Set the century
.1a2a10	8f 0f 08 af	sta $af080f	                STA @lRTC_CENTURY
.1a2a14	68		pla		                PLA                     ; And year to the RTC
.1a2a15	8f 0a 08 af	sta $af080a	                STA @lRTC_YEAR
.1a2a19	68		pla		                PLA                     ; Month...
.1a2a1a	8f 09 08 af	sta $af0809	                STA @lRTC_MONTH
.1a2a1e	68		pla		                PLA                     ; Save the day...
.1a2a1f	8f 06 08 af	sta $af0806	                STA @lRTC_DAY
.1a2a23	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a2a27	29 f7		and #$f7	                AND #%11110111
.1a2a29	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.1a2a2d	20 a3 1f	jsr $1a1fa3	            JSR SKIPSTMT
.1a2a30	28		plp		                PLP
.1a2a31	60		rts		            RTS
.1a2a32					S_TEXTCOLOR
.1a2a32	08		php		                PHP
.1a2a33					locals
>0001					L_FOREGROUND    .byte ?
.1a2a33	e2 20		sep #$20	            SEP #$20
.1a2a35	48		pha		            PHA
.1a2a36	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2a39	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2a3c	e2 20		sep #$20	            SEP #$20
.1a2a3e	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the foreground position
.1a2a40	29 0f		and #$0f	                AND #$0F
.1a2a42	0a		asl a		                ASL A
.1a2a43	0a		asl a		                ASL A
.1a2a44	0a		asl a		                ASL A
.1a2a45	0a		asl a		                ASL A
.1a2a46	83 01		sta $01,s	                STA L_FOREGROUND    ; Save the foreground color
.1a2a48	a9 2c		lda #$2c	                LDA #','
.1a2a4a	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a2a4d	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2a50	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2a53	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the background position
.1a2a55	29 0f		and #$0f	                AND #$0F
.1a2a57	03 01		ora $01,s	                ORA L_FOREGROUND    ; Add in the foreground
.1a2a59	8f 1e 00 00	sta $00001e	                STA @lCURCOLOR      ; And save the new color combination
.1a2a5d	e2 20		sep #$20	            SEP #$20
.1a2a5f	68		pla		            PLA
.1a2a60	28		plp		                PLP
.1a2a61	60		rts		            RTS
.1a2a62					S_SETBGCOLOR
.1a2a62	08		php		                PHP
.1a2a63					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.1a2a63	c2 20		rep #$20	            REP #$20
.1a2a65	f4 00 00	pea #$0000	            PEA #0
.1a2a68	e2 20		sep #$20	            SEP #$20
.1a2a6a	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2a6d	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2a70	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.1a2a72	83 01		sta $01,s	                STA L_RED
.1a2a74	a9 2c		lda #$2c	                LDA #','
.1a2a76	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a2a79	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2a7c	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2a7f	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.1a2a81	83 02		sta $02,s	                STA L_GREEN
.1a2a83	a9 2c		lda #$2c	                LDA #','
.1a2a85	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a2a88	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2a8b	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2a8e	a5 23		lda $0823	                LDA ARGUMENT1               ; And set the actual color
.1a2a90	8f 0d 00 af	sta $af000d	                STA @lBACKGROUND_COLOR_B
.1a2a94	a3 02		lda $02,s	                LDA L_GREEN
.1a2a96	8f 0e 00 af	sta $af000e	                STA @lBACKGROUND_COLOR_G
.1a2a9a	a3 01		lda $01,s	                LDA L_RED
.1a2a9c	8f 0f 00 af	sta $af000f	                STA @lBACKGROUND_COLOR_R
.1a2aa0	c2 20		rep #$20	            REP #$20
.1a2aa2	68		pla		            PLA
.1a2aa3	28		plp		                PLP
.1a2aa4	60		rts		            RTS
.1a2aa5					S_SETBORDER
.1a2aa5	08		php		                PHP
.1a2aa6					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.1a2aa6	c2 20		rep #$20	            REP #$20
.1a2aa8	f4 00 00	pea #$0000	            PEA #0
.1a2aab	e2 20		sep #$20	            SEP #$20
.1a2aad	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2ab0	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a2ab3	a5 23		lda $0823	                LDA ARGUMENT1
.1a2ab5	f0 16		beq $1a2acd	                BEQ hide_border
.1a2ab7	a9 01		lda #$01	                LDA #Border_Ctrl_Enable     ; Enable the border
.1a2ab9	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.1a2abd	a9 20		lda #$20	                LDA #BORDER_WIDTH           ; Set the border width
.1a2abf	8f 08 00 af	sta $af0008	                STA BORDER_X_SIZE
.1a2ac3	8f 09 00 af	sta $af0009	                STA BORDER_Y_SIZE
.1a2ac7	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.1a2acb	80 0a		bra $1a2ad7	                BRA get_color
.1a2acd	a9 00		lda #$00	hide_border     LDA #0                      ; Hide the border
.1a2acf	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.1a2ad3	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.1a2ad7	a9 2c		lda #$2c	get_color       LDA #','
.1a2ad9	85 37		sta $0837	                STA TARGETTOK
.1a2adb	20 a0 20	jsr $1a20a0	            JSR OPT_TOK
.1a2ade	90 39		bcc $1a2b19	                BCC done                    ; No: we're done
.1a2ae0	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a2ae3	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2ae6	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2ae9	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.1a2aeb	83 01		sta $01,s	                STA L_RED
.1a2aed	a9 2c		lda #$2c	                LDA #','
.1a2aef	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a2af2	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2af5	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2af8	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.1a2afa	83 02		sta $02,s	                STA L_GREEN
.1a2afc	a9 2c		lda #$2c	                LDA #','
.1a2afe	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a2b01	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2b04	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2b07	a5 23		lda $0823	                LDA ARGUMENT1
.1a2b09	8f 05 00 af	sta $af0005	                STA @lBORDER_COLOR_B        ; Set the border color
.1a2b0d	a3 02		lda $02,s	                LDA L_GREEN
.1a2b0f	8f 06 00 af	sta $af0006	                STA @lBORDER_COLOR_G
.1a2b13	a3 01		lda $01,s	                LDA L_RED
.1a2b15	8f 07 00 af	sta $af0007	                STA @lBORDER_COLOR_R
.1a2b19					done
.1a2b19	c2 20		rep #$20	            REP #$20
.1a2b1b	68		pla		            PLA
.1a2b1c	28		plp		                PLP
.1a2b1d	60		rts		            RTS
.1a2b1e					S_SETCOLOR
.1a2b1e	08		php		                PHP
.1a2b1f					locals
>0001					L_LUT           .byte ?
>0002					L_COLOR         .byte ?
>0003					L_RED           .byte ?
>0004					L_GREEN         .byte ?
>0005					L_BLUE          .byte ?
.1a2b1f	c2 20		rep #$20	            REP #$20
.1a2b21	3b		tsc		            TSC
.1a2b22	38		sec		            SEC
.1a2b23	e9 05 00	sbc #$0005	            SBC #SIZE(locals)
.1a2b26	1b		tcs		            TCS
.1a2b27	e2 20		sep #$20	            SEP #$20
.1a2b29	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2b2c	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2b2f	a5 23		lda $0823	                LDA ARGUMENT1
.1a2b31	c9 0a		cmp #$0a	                CMP #10             ; And in range
.1a2b33	90 1f		bcc $1a2b54	                BLT save_lut
.1a2b35					bad_argument
.1a2b35	08		php		            PHP
.1a2b36	c2 20		rep #$20	            REP #$20
.1a2b38	48		pha		            PHA
.1a2b39	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2b3c	5b		tcd		            TCD
.1a2b3d	68		pla		            PLA
.1a2b3e	28		plp		            PLP
.1a2b3f	e2 20		sep #$20	            SEP #$20
.1a2b41	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a2b43	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2b47	c2 20		rep #$20	            REP #$20
.1a2b49	29 ff 00	and #$00ff	            AND #$00FF
.1a2b4c	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a2b4f	e2 20		sep #$20	            SEP #$20
.1a2b51	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2b54	83 01		sta $01,s	save_lut        STA L_LUT           ; Save as LUT
.1a2b56	a9 2c		lda #$2c	                LDA #','
.1a2b58	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a2b5b	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2b5e	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2b61	a5 23		lda $0823	                LDA ARGUMENT1
.1a2b63	83 02		sta $02,s	                STA L_COLOR         ; Save as COLOR
.1a2b65	a9 2c		lda #$2c	                LDA #','
.1a2b67	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a2b6a	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2b6d	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2b70	a5 23		lda $0823	                LDA ARGUMENT1
.1a2b72	83 03		sta $03,s	                STA L_RED           ; Save as RED
.1a2b74	a9 2c		lda #$2c	                LDA #','
.1a2b76	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a2b79	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2b7c	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2b7f	a5 23		lda $0823	                LDA ARGUMENT1
.1a2b81	83 04		sta $04,s	                STA L_GREEN         ; Save it as GREEN
.1a2b83	a9 2c		lda #$2c	                LDA #','
.1a2b85	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a2b88	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2b8b	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2b8e	a5 23		lda $0823	                LDA ARGUMENT1
.1a2b90	83 05		sta $05,s	                STA L_BLUE          ; Save it as BLUE
.1a2b92	a9 af		lda #$af	                LDA #`GRPH_LUT0_PTR ; Get the bank Vicky is in (should always be $AF)
.1a2b94	85 a0		sta $08a0	                STA MTEMPPTR+2      ; MTEMPPTR will be our pointer to the LUT entry
.1a2b96	a3 01		lda $01,s	                LDA L_LUT           ; Compute the offset to the LUT address
.1a2b98	0a		asl a		                ASL A
.1a2b99	c2 20		rep #$20	            REP #$20
.1a2b9b	29 ff 00	and #$00ff	                AND #$00FF
.1a2b9e	aa		tax		                TAX                 ; Put it in X
.1a2b9f	bf d6 2b 1a	lda $1a2bd6,x	                LDA @llut_address,X ; Get the address of the LUT
.1a2ba3	85 9e		sta $089e	                STA MTEMPPTR        ; Put it in MTEMPPTR
.1a2ba5	e2 20		sep #$20	            SEP #$20
.1a2ba7	a3 02		lda $02,s	                LDA L_COLOR         ; color index *= 4
.1a2ba9	c2 20		rep #$20	            REP #$20
.1a2bab	29 ff 00	and #$00ff	                AND #$00FF
.1a2bae	0a		asl a		                ASL A               ; Since each color has four bytes of data
.1a2baf	0a		asl a		                ASL A
.1a2bb0	18		clc		                CLC                 ; Add the color offset to MTEMPPTR
.1a2bb1	65 9e		adc $089e	                ADC MTEMPPTR
.1a2bb3	85 9e		sta $089e	                STA MTEMPPTR
.1a2bb5	e2 20		sep #$20	            SEP #$20
.1a2bb7	a0 02 00	ldy #$0002	                LDY #GR_LUT_RED
.1a2bba	a3 03		lda $03,s	                LDA L_RED
.1a2bbc	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the red component to the color entry
.1a2bbe	a0 01 00	ldy #$0001	                LDY #GR_LUT_GREEN
.1a2bc1	a3 04		lda $04,s	                LDA L_GREEN
.1a2bc3	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the green component to the color entry
.1a2bc5	a0 00 00	ldy #$0000	                LDY #GR_LUT_BLUE
.1a2bc8	a3 05		lda $05,s	                LDA L_BLUE
.1a2bca	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the blue component to the color entry
.1a2bcc					done
.1a2bcc	c2 20		rep #$20	            REP #$20
.1a2bce	3b		tsc		            TSC
.1a2bcf	18		clc		            CLC
.1a2bd0	69 05 00	adc #$0005	            ADC #SIZE(locals)
.1a2bd3	1b		tcs		            TCS
.1a2bd4	28		plp		                PLP
.1a2bd5	60		rts		            RTS
>1a2bd6	00 20				lut_address     .word <>GRPH_LUT0_PTR
>1a2bd8	00 24				                .word <>GRPH_LUT1_PTR
>1a2bda	00 28				                .word <>GRPH_LUT2_PTR
>1a2bdc	00 2c				                .word <>GRPH_LUT3_PTR
>1a2bde	00 30				                .word <>GRPH_LUT4_PTR
>1a2be0	00 34				                .word <>GRPH_LUT5_PTR
>1a2be2	00 38				                .word <>GRPH_LUT6_PTR
>1a2be4	00 3c				                .word <>GRPH_LUT7_PTR
>1a2be6	40 1f				                .word <>FG_CHAR_LUT_PTR
>1a2be8	80 1f				                .word <>BG_CHAR_LUT_PTR
.1a2bea					S_GRAPHICS
.1a2bea	da		phx		                PHX
.1a2beb	5a		phy		                PHY
.1a2bec	08		php		                PHP
.1a2bed	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2bf0	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a2bf3	c2 20		rep #$20	            REP #$20
.1a2bf5	a5 23		lda $0823	                LDA ARGUMENT1               ; Check to see if we're setting mode to 800x600 or 400x300
.1a2bf7	89 00 01	bit #$0100	                BIT #$0100
.1a2bfa	d0 17		bne $1a2c13	                BNE set_mode                ; Yes: go ahead and set it
.1a2bfc	af 00 00 af	lda $af0000	                LDA @l MASTER_CTRL_REG_L    ; Otherwise, check to see if we're already in 800x600 or 400x300
.1a2c00	89 00 01	bit #$0100	                BIT #$0100
.1a2c03	f0 0e		beq $1a2c13	                BEQ set_mode                ; No: just go ahead and set the mode
.1a2c05	e2 20		sep #$20	            SEP #$20
.1a2c07	a9 00		lda #$00	                LDA #0                      ; Yes: toggle back to 640x480...
.1a2c09	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.1a2c0d	a9 01		lda #$01	                LDA #1                      ; And back to 800x600....
.1a2c0f	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.1a2c13					set_mode
.1a2c13	c2 20		rep #$20	            REP #$20
.1a2c15	a5 23		lda $0823	                LDA ARGUMENT1
.1a2c17	8f 00 00 af	sta $af0000	                STA @l MASTER_CTRL_REG_L    ; Set the graphics mode
.1a2c1b	e2 20		sep #$20	            SEP #$20
.1a2c1d	a5 24		lda $0824	                LDA ARGUMENT1+1             ; Get the screen size bits
.1a2c1f	c2 20		rep #$20	            REP #$20
.1a2c21	29 03 00	and #$0003	                AND #$0003
.1a2c24	0a		asl a		                ASL A                       ; Multiply by two to get the index
.1a2c25	aa		tax		                TAX                         ; X is index into the size tables
.1a2c26	c2 20		rep #$20	            REP #$20
.1a2c28	bf 71 2c 1a	lda $1a2c71,x	                LDA gr_columns,X            ; Set the columns
.1a2c2c	8f 10 f0 1a	sta $1af010	                STA @lGR_MAX_COLS
.1a2c30	bf 79 2c 1a	lda $1a2c79,x	                LDA gr_rows,X               ; Set the rows
.1a2c34	8f 12 f0 1a	sta $1af012	                STA @lGR_MAX_ROWS
.1a2c38	af 10 f0 1a	lda $1af010	                LDA @lGR_MAX_COLS           ; Get the current columns
.1a2c3c	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.1a2c40	af 12 f0 1a	lda $1af012	                LDA @lGR_MAX_ROWS           ; Get the current rows
.1a2c44	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B
.1a2c48	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT             ; Multiply them to get the total pixels
.1a2c4c	8f 14 f0 1a	sta $1af014	                STA @lGR_TOTAL_PIXELS
.1a2c50	e2 20		sep #$20	            SEP #$20
.1a2c52	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.1a2c56	8f 16 f0 1a	sta $1af016	                STA @lGR_TOTAL_PIXELS+2
.1a2c5a	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.1a2c5e					reset_cursor
.1a2c5e	c2 20		rep #$20	            REP #$20
.1a2c60	af 1a 00 00	lda $00001a	                LDA @lCURSORX
.1a2c64	aa		tax		                TAX
.1a2c65	af 1c 00 00	lda $00001c	                LDA @lCURSORY
.1a2c69	a8		tay		                TAY
.1a2c6a	20 20 00	jsr $1a0020	            JSR CURSORXY
.1a2c6d	28		plp		                PLP
.1a2c6e	7a		ply		                PLY
.1a2c6f	fa		plx		                PLX
.1a2c70	60		rts		            RTS
>1a2c71	80 02 20 03 40 01 90 01		gr_columns      .word 640,800,320,400
>1a2c79	e0 01 58 02 f0 00 2c 01		gr_rows         .word 480,600,240,300
>1a2c81	50 00 64 00 28 00 32 00		col_count       .word 80,100,40,50
>1a2c89	3c 00 4b 00 1e 00 32 00		row_count       .word 60,75,30,50
>1a2c91	48 00 5c 00 20 00 2a 00		colb_count      .word 72,92,32,42
>1a2c99	34 00 43 00 16 00 34 00		rowb_count      .word 52,67,22,52
.1a2ca1					BITMAP_SRAM
.1a2ca1	da		phx		                PHX
.1a2ca2	08		php		                PHP
.1a2ca3	c2 30		rep #$30	            REP #$30
.1a2ca5	c9 02 00	cmp #$0002	                CMP #BM_MAX
.1a2ca8	b0 1c		bcs $1a2cc6	                BGE range_err           ; Make sure it's within range
.1a2caa	0a		asl a		                ASL A
.1a2cab	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.1a2cac	aa		tax		                TAX
.1a2cad	bf 00 f0 1a	lda $1af000,x	                LDA @l GR_BM0_ADDR,X    ; Get the low 16-bits of the address
.1a2cb1	85 9e		sta $089e	                STA MTEMPPTR
.1a2cb3	bf 02 f0 1a	lda $1af002,x	                LDA @l GR_BM0_ADDR+2,X  ; Get the high bits of the address
.1a2cb7	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a2cb9	c9 f0 00	cmp #$00f0	                CMP #MAX_VRAM_CPU       ; Check to make sure address is within VRAM
.1a2cbc	b0 08		bcs $1a2cc6	                BGE range_err
.1a2cbe	c9 b0 00	cmp #$00b0	                CMP #MIN_VRAM_CPU
.1a2cc1	90 03		bcc $1a2cc6	                BLT range_err
.1a2cc3	28		plp		                PLP
.1a2cc4	fa		plx		                PLX
.1a2cc5	60		rts		            RTS
.1a2cc6					range_err
.1a2cc6	08		php		            PHP
.1a2cc7	c2 20		rep #$20	            REP #$20
.1a2cc9	48		pha		            PHA
.1a2cca	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2ccd	5b		tcd		            TCD
.1a2cce	68		pla		            PLA
.1a2ccf	28		plp		            PLP
.1a2cd0	e2 20		sep #$20	            SEP #$20
.1a2cd2	a9 09		lda #$09	            LDA #ERR_RANGE
.1a2cd4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2cd8	c2 20		rep #$20	            REP #$20
.1a2cda	29 ff 00	and #$00ff	            AND #$00FF
.1a2cdd	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a2ce0	e2 20		sep #$20	            SEP #$20
.1a2ce2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2ce5					BITMAP_VRAM
.1a2ce5	da		phx		                PHX
.1a2ce6	08		php		                PHP
.1a2ce7	c2 30		rep #$30	            REP #$30
.1a2ce9	c9 02 00	cmp #$0002	                CMP #BM_MAX
.1a2cec	b0 17		bcs $1a2d05	                BGE range_err           ; Make sure it's within range
.1a2cee	0a		asl a		                ASL A
.1a2cef	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.1a2cf0	aa		tax		                TAX
.1a2cf1	bf 08 f0 1a	lda $1af008,x	                LDA @l GR_BM0_VRAM,X    ; Get the low 16-bits of the address
.1a2cf5	85 9e		sta $089e	                STA MTEMPPTR
.1a2cf7	bf 0a f0 1a	lda $1af00a,x	                LDA @l GR_BM0_VRAM+2,X  ; Get the high bits of the address
.1a2cfb	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a2cfd	c9 40 00	cmp #$0040	                CMP #MAX_VRAM_VICKY     ; Check to make sure the address is from $00:0000 - $3F:FFFF
.1a2d00	b0 03		bcs $1a2d05	                BGE range_err           ; If not, throw a range error
.1a2d02	28		plp		                PLP
.1a2d03	fa		plx		                PLX
.1a2d04	60		rts		            RTS
.1a2d05					range_err
.1a2d05	08		php		            PHP
.1a2d06	c2 20		rep #$20	            REP #$20
.1a2d08	48		pha		            PHA
.1a2d09	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2d0c	5b		tcd		            TCD
.1a2d0d	68		pla		            PLA
.1a2d0e	28		plp		            PLP
.1a2d0f	e2 20		sep #$20	            SEP #$20
.1a2d11	a9 09		lda #$09	            LDA #ERR_RANGE
.1a2d13	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2d17	c2 20		rep #$20	            REP #$20
.1a2d19	29 ff 00	and #$00ff	            AND #$00FF
.1a2d1c	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a2d1f	e2 20		sep #$20	            SEP #$20
.1a2d21	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2d24					S_BITMAP
.1a2d24	08		php		                PHP
.1a2d25					locals
>0001					L_PLANE         .word ?
>0003					L_VISIBLE       .byte ?
>0004					L_ADDRESS       .dword ?
.1a2d25	c2 30		rep #$30	            REP #$30
.1a2d27	3b		tsc		                TSC                         ; Allocate space for the locals on the stack
.1a2d28	38		sec		                SEC
.1a2d29	e9 07 00	sbc #$0007	                SBC #SIZE(locals)
.1a2d2c	1b		tcs		                TCS
.1a2d2d	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2d30	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2d33	c2 20		rep #$20	            REP #$20
.1a2d35	a5 23		lda $0823	                LDA ARGUMENT1               ; Make sure it's in range
.1a2d37	c9 02 00	cmp #$0002	                CMP #BM_MAX
.1a2d3a	b0 59		bcs $1a2d95	                BGE range_err               ; If not, throw an error
.1a2d3c	83 01		sta $01,s	                STA L_PLANE                 ; If so, save it to MARG1
.1a2d3e	e2 20		sep #$20	            SEP #$20
.1a2d40	a9 2c		lda #$2c	                LDA #','
.1a2d42	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a2d45	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2d48	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2d4b	a5 23		lda $0823	                LDA ARGUMENT1
.1a2d4d	83 03		sta $03,s	                STA L_VISIBLE
.1a2d4f	a9 2c		lda #$2c	                LDA #','
.1a2d51	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a2d54	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2d57	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2d5a	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the number back
.1a2d5c	0a		asl a		                ASL A                       ; Multiply by 8 to get the offset to the registers
.1a2d5d	0a		asl a		                ASL A
.1a2d5e	0a		asl a		                ASL A
.1a2d5f	aa		tax		                TAX                         ; And save that offset to X
.1a2d60	a3 03		lda $03,s	                LDA L_VISIBLE               ; Check the visible flag
.1a2d62	d0 05		bne $1a2d69	                BNE is_visible              ; If <> 0, it's visible
.1a2d64	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the LUT #
.1a2d66	0a		asl a		                ASL A                       ; Shift it into position for the register
.1a2d67	80 04		bra $1a2d6d	                BRA wr_bm_reg               ; And go to write it
.1a2d69	a5 23		lda $0823	is_visible      LDA ARGUMENT1               ; Get the LUT #
.1a2d6b	38		sec		                SEC
.1a2d6c	2a		rol a		                ROL A                       ; And shift it into position, and set enable bit
.1a2d6d	9f 00 01 af	sta $af0100,x	wr_bm_reg       STA @l BM0_CONTROL_REG,X    ; Write to the bitmap control register
.1a2d71	c2 20		rep #$20	            REP #$20
.1a2d73	a9 2c 00	lda #$002c	                LDA #','
.1a2d76	85 37		sta $0837	                STA TARGETTOK
.1a2d78	20 a0 20	jsr $1a20a0	            JSR OPT_TOK
.1a2d7b	b0 37		bcs $1a2db4	                BCS get_address             ; Yes: parse the address
.1a2d7d	c2 20		rep #$20	            REP #$20
.1a2d7f	08		php		            PHP
.1a2d80	c2 20		rep #$20	            REP #$20
.1a2d82	a9 00 00	lda #$0000	            LDA #<>VRAM
.1a2d85	85 23		sta $0823	            STA ARGUMENT1
.1a2d87	a9 b0 00	lda #$00b0	            LDA #(VRAM >> 16)
.1a2d8a	85 25		sta $0825	            STA ARGUMENT1+2
.1a2d8c	e2 20		sep #$20	            SEP #$20
.1a2d8e	a9 00		lda #$00	            LDA #TYPE_INTEGER
.1a2d90	85 27		sta $0827	            STA ARGUMENT1+4
.1a2d92	28		plp		            PLP
.1a2d93	80 27		bra $1a2dbc	                BRA set_address
.1a2d95					range_err
.1a2d95	08		php		            PHP
.1a2d96	c2 20		rep #$20	            REP #$20
.1a2d98	48		pha		            PHA
.1a2d99	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2d9c	5b		tcd		            TCD
.1a2d9d	68		pla		            PLA
.1a2d9e	28		plp		            PLP
.1a2d9f	e2 20		sep #$20	            SEP #$20
.1a2da1	a9 09		lda #$09	            LDA #ERR_RANGE
.1a2da3	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2da7	c2 20		rep #$20	            REP #$20
.1a2da9	29 ff 00	and #$00ff	            AND #$00FF
.1a2dac	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a2daf	e2 20		sep #$20	            SEP #$20
.1a2db1	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2db4					get_address
.1a2db4	c2 20		rep #$20	            REP #$20
.1a2db6	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a2db9	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2dbc					set_address
.1a2dbc	c2 20		rep #$20	            REP #$20
.1a2dbe	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.1a2dc0	0a		asl a		                ASL A                       ; Multiply by four to get the offset to the address variable
.1a2dc1	0a		asl a		                ASL A
.1a2dc2	aa		tax		                TAX                         ; And put it in X
.1a2dc3	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the CPU-space address
.1a2dc5	9f 00 f0 1a	sta $1af000,x	                STA @l GR_BM0_ADDR,X        ; And save it to the correct GR_BM?_ADDR variable
.1a2dc9	9f 08 f0 1a	sta $1af008,x	                STA @l GR_BM0_VRAM,X
.1a2dcd	83 04		sta $04,s	                STA L_ADDRESS               ; And L_ADDRESS, temporarily
.1a2dcf	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a2dd1	9f 02 f0 1a	sta $1af002,x	                STA @l GR_BM0_ADDR+2,X
.1a2dd5	38		sec		                SEC
.1a2dd6	e9 b0 00	sbc #$00b0	                SBC #`VRAM                  ; Rebase the upper half of the address to Vicky memory space
.1a2dd9	9f 0a f0 1a	sta $1af00a,x	                STA @l GR_BM0_VRAM+2,X
.1a2ddd	83 06		sta $06,s	                STA L_ADDRESS+2             ; And to L_ADDRESS
.1a2ddf	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.1a2de1	0a		asl a		                ASL A                       ; Multiply by eight to get the offset to the registers
.1a2de2	0a		asl a		                ASL A
.1a2de3	0a		asl a		                ASL A
.1a2de4	aa		tax		                TAX                         ; And put it in X
.1a2de5	e2 20		sep #$20	            SEP #$20
.1a2de7	a3 04		lda $04,s	                LDA L_ADDRESS               ; Get the address in Vicky space...
.1a2de9	9f 01 01 af	sta $af0101,x	                STA @l BM0_START_ADDY_L,X   ; Save it to the Vicky registers
.1a2ded	a3 05		lda $05,s	                LDA L_ADDRESS+1
.1a2def	9f 02 01 af	sta $af0102,x	                STA @l BM0_START_ADDY_M,X
.1a2df3	a3 06		lda $06,s	                LDA L_ADDRESS+2
.1a2df5	9f 03 01 af	sta $af0103,x	                STA @l BM0_START_ADDY_H,X
.1a2df9	a9 00		lda #$00	                LDA #0                      ; Default offset to (0, 0)
.1a2dfb	9f 04 01 af	sta $af0104,x	                STA @l BM0_X_OFFSET,X
.1a2dff	9f 05 01 af	sta $af0105,x	                STA @l BM0_Y_OFFSET,X
.1a2e03	c2 30		rep #$30	            REP #$30
.1a2e05	3b		tsc		                TSC                         ; Remove the space for the locals from the stack
.1a2e06	18		clc		                CLC
.1a2e07	69 07 00	adc #$0007	                ADC #SIZE(locals)
.1a2e0a	1b		tcs		                TCS
.1a2e0b	28		plp		                PLP
.1a2e0c	60		rts		            RTS
.1a2e0d					bad_address
.1a2e0d	08		php		            PHP
.1a2e0e	c2 20		rep #$20	            REP #$20
.1a2e10	48		pha		            PHA
.1a2e11	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2e14	5b		tcd		            TCD
.1a2e15	68		pla		            PLA
.1a2e16	28		plp		            PLP
.1a2e17	e2 20		sep #$20	            SEP #$20
.1a2e19	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a2e1b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a2e1f	c2 20		rep #$20	            REP #$20
.1a2e21	29 ff 00	and #$00ff	            AND #$00FF
.1a2e24	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a2e27	e2 20		sep #$20	            SEP #$20
.1a2e29	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a2e2c					S_CLRBITMAP
.1a2e2c	08		php		                PHP
.1a2e2d	c2 20		rep #$20	            REP #$20
.1a2e2f	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2e32	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2e35	a5 23		lda $0823	                LDA ARGUMENT1
.1a2e37	20 e5 2c	jsr $1a2ce5	            JSR BITMAP_VRAM
.1a2e3a	c2 20		rep #$20	            REP #$20
.1a2e3c	a5 9e		lda $089e	                LDA MTEMPPTR                ; Set the start address and the # of pixels to write
.1a2e3e	8f 05 04 af	sta $af0405	                STA @lVDMA_DST_ADDY_L
.1a2e42	af 14 f0 1a	lda $1af014	                LDA @lGR_TOTAL_PIXELS       ; Set the size
.1a2e46	8f 08 04 af	sta $af0408	                STA @lVDMA_SIZE_L
.1a2e4a	e2 20		sep #$20	            SEP #$20
.1a2e4c	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.1a2e4e	8f 07 04 af	sta $af0407	                STA @lVDMA_DST_ADDY_H
.1a2e52	af 16 f0 1a	lda $1af016	                LDA @lGR_TOTAL_PIXELS+2
.1a2e56	8f 0a 04 af	sta $af040a	                STA @lVDMA_SIZE_H
.1a2e5a	a9 00		lda #$00	                LDA #0                      ; Set the color to write
.1a2e5c	8f 01 04 af	sta $af0401	                STA @lVDMA_BYTE_2_WRITE
.1a2e60	a9 85		lda #$85	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_Start_TRF
.1a2e62	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.1a2e66	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.1a2e6a	30 fa		bmi $1a2e66	                BMI wait
.1a2e6c	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.1a2e6e	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.1a2e72	28		plp		done            PLP
.1a2e73	60		rts		            RTS
=$000855				COLOR = MARG1
=$000859				X0 = MARG2
=$00085d				Y0 = MARG3
=$000861				X1 = MARG4
=$000865				Y1 = MARG5
=$000869				DX = MARG6
=$00086d				DY = MARG7
=$000871				ERR = MARG8
=$000875				ERR2 = MARG9
>08dd					SX      .word ?
>08df					SY      .word ?
.1a2e74					PLOT
.1a2e74	08		php		                PHP
.1a2e75	c2 20		rep #$20	            REP #$20
.1a2e77	a5 5d		lda $085d	                LDA Y0                      ; Get the row
.1a2e79	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.1a2e7d	af 10 f0 1a	lda $1af010	                LDA @lGR_MAX_COLS
.1a2e81	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B          ; Multiply by the number of columns in the pixmap
.1a2e85	18		clc		                CLC                         ; Add the column
.1a2e86	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT
.1a2e8a	65 59		adc $0859	                ADC X0
.1a2e8c	85 0c		sta $080c	                STA SCRATCH
.1a2e8e	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.1a2e92	69 00 00	adc #$0000	                ADC #0
.1a2e95	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH is offset of pixel in the pixmap
.1a2e97	18		clc		                CLC                         ; Add the address of the first pixel
.1a2e98	a5 0c		lda $080c	                LDA SCRATCH
.1a2e9a	65 9e		adc $089e	                ADC MTEMPPTR
.1a2e9c	85 0c		sta $080c	                STA SCRATCH
.1a2e9e	a5 0e		lda $080e	                LDA SCRATCH+2
.1a2ea0	65 a0		adc $08a0	                ADC MTEMPPTR+2
.1a2ea2	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH := pixmap + pixel offset
.1a2ea4	e2 20		sep #$20	            SEP #$20
.1a2ea6	a5 55		lda $0855	                LDA COLOR                   ; Get the color
.1a2ea8	87 0c		sta [$080c]	                STA [SCRATCH]               ; And write the color to the pixel
.1a2eaa	28		plp		                PLP
.1a2eab	60		rts		            RTS
.1a2eac					LINE
.1a2eac	c2 20		rep #$20	            REP #$20
.1a2eae	a9 01 00	lda #$0001	                LDA #1                      ; Assume SX = 1
.1a2eb1	85 dd		sta $08dd	                STA SX
.1a2eb3	38		sec		                SEC                         ; DX := ABS(X1 - X0)
.1a2eb4	a5 61		lda $0861	                LDA X1
.1a2eb6	e5 59		sbc $0859	                SBC X0
.1a2eb8	85 69		sta $0869	                STA DX
.1a2eba	10 0b		bpl $1a2ec7	                BPL abs_Y                   ; If DX < 0 {
.1a2ebc	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DX := -DX
.1a2ebf	1a		inc a		                INC A
.1a2ec0	85 69		sta $0869	                STA DX
.1a2ec2	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SX := -1
.1a2ec5	85 dd		sta $08dd	                STA SX                      ; }
.1a2ec7	a9 01 00	lda #$0001	abs_Y           LDA #1                      ; Assume SY = 1
.1a2eca	85 df		sta $08df	                STA SY
.1a2ecc	38		sec		                SEC                         ; DY := ABS(Y1 - Y0)
.1a2ecd	a5 65		lda $0865	                LDA Y1
.1a2ecf	e5 5d		sbc $085d	                SBC Y0
.1a2ed1	85 6d		sta $086d	                STA DY
.1a2ed3	10 0b		bpl $1a2ee0	                BPL calc_ERR                ; If DY < 0 {
.1a2ed5	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DY := -DY
.1a2ed8	1a		inc a		                INC A
.1a2ed9	85 6d		sta $086d	                STA DY
.1a2edb	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SY := -1
.1a2ede	85 df		sta $08df	                STA SY                      ; }
.1a2ee0	a5 6d		lda $086d	calc_ERR        LDA DY                      ; (DY < DX)
.1a2ee2	c5 69		cmp $0869	                CMP DX
.1a2ee4	b0 04		bcs $1a2eea	                BGE else
.1a2ee6	a5 69		lda $0869	                LDA DX                      ; TRUE CASE: ERR := DX
.1a2ee8	80 06		bra $1a2ef0	                BRA shiftERR
.1a2eea	a5 6d		lda $086d	else            LDA DY                      ; FALSE CASE: ERR := -DY
.1a2eec	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a2eef	1a		inc a		                INC A
.1a2ef0	48		pha		shiftERR        PHA
.1a2ef1	0a		asl a		                ASL A
.1a2ef2	68		pla		                PLA
.1a2ef3	6a		ror a		                ROR A                       ; ERR := ERR / 2
.1a2ef4	85 71		sta $0871	                STA ERR
.1a2ef6					loop
.1a2ef6	20 74 2e	jsr $1a2e74	            JSR PLOT
.1a2ef9	a5 59		lda $0859	                LDA X0                      ; break if X0=X1 and Y0=Y1
.1a2efb	c5 61		cmp $0861	                CMP X1
.1a2efd	d0 06		bne $1a2f05	                BNE calc_ERR2
.1a2eff	a5 5d		lda $085d	                LDA Y0
.1a2f01	c5 65		cmp $0865	                CMP Y1
.1a2f03	f0 36		beq $1a2f3b	                BEQ done
.1a2f05	a5 71		lda $0871	calc_ERR2       LDA ERR                     ; ERR2 := ERR
.1a2f07	85 75		sta $0875	                STA ERR2
.1a2f09	a5 69		lda $0869	                LDA DX                      ; if (ERR2 > -DX) {
.1a2f0b	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a2f0e	1a		inc a		                INC A
.1a2f0f	c5 75		cmp $0875	                CMP ERR2
.1a2f11	10 10		bpl $1a2f23	                BPL check_DY
.1a2f13	f0 0e		beq $1a2f23	                BEQ check_DY
.1a2f15	38		sec		                SEC                         ; ERR -= DY
.1a2f16	a5 71		lda $0871	                LDA ERR
.1a2f18	e5 6d		sbc $086d	                SBC DY
.1a2f1a	85 71		sta $0871	                STA ERR
.1a2f1c	18		clc		                CLC                         ; X0 += SX
.1a2f1d	a5 59		lda $0859	                LDA X0
.1a2f1f	65 dd		adc $08dd	                ADC SX
.1a2f21	85 59		sta $0859	                STA X0                      ; }
.1a2f23	a5 75		lda $0875	check_DY        LDA ERR2                    ; if (ERR2 < DY) {
.1a2f25	c5 6d		cmp $086d	                CMP DY
.1a2f27	10 cd		bpl $1a2ef6	                BPL loop
.1a2f29	f0 cb		beq $1a2ef6	                BEQ loop
.1a2f2b	18		clc		                CLC                         ; ERR += DX
.1a2f2c	a5 71		lda $0871	                LDA ERR
.1a2f2e	65 69		adc $0869	                ADC DX
.1a2f30	85 71		sta $0871	                STA ERR
.1a2f32	18		clc		                CLC                         ; Y0 += SY
.1a2f33	a5 5d		lda $085d	                LDA Y0
.1a2f35	65 df		adc $08df	                ADC SY
.1a2f37	85 5d		sta $085d	                STA Y0                      ; }
.1a2f39	80 bb		bra $1a2ef6	                BRA loop                    ; }
.1a2f3b					done
.1a2f3b	60		rts		            RTS
.1a2f3c					S_PLOT
.1a2f3c	08		php		                PHP
.1a2f3d					locals
>0001					L_PLANE         .word ?
>0003					L_X             .word ?
>0005					L_Y             .word ?
.1a2f3d	c2 20		rep #$20	            REP #$20
.1a2f3f	3b		tsc		            TSC
.1a2f40	38		sec		            SEC
.1a2f41	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.1a2f44	1b		tcs		            TCS
.1a2f45	08		php		            PHP
.1a2f46	c2 20		rep #$20	            REP #$20
.1a2f48	48		pha		            PHA
.1a2f49	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2f4c	5b		tcd		            TCD
.1a2f4d	68		pla		            PLA
.1a2f4e	28		plp		            PLP
.1a2f4f	08		php		            PHP
.1a2f50	e2 20		sep #$20	            SEP #$20
.1a2f52	48		pha		            PHA
.1a2f53	a9 00		lda #$00	            LDA #0
.1a2f55	48		pha		            PHA
.1a2f56	ab		plb		            PLB
.1a2f57	68		pla		            PLA
.1a2f58	28		plp		            PLP
.1a2f59	c2 30		rep #$30	            REP #$30
.1a2f5b	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2f5e	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2f61	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.1a2f63	a9 2c 00	lda #$002c	                LDA #','
.1a2f66	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a2f69	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2f6c	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a2f6f	a5 23		lda $0823	                LDA ARGUMENT1
.1a2f71	83 03		sta $03,s	                STA L_X                     ; Save it to X
.1a2f73	a9 2c 00	lda #$002c	                LDA #','
.1a2f76	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a2f79	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2f7c	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a2f7f	a5 23		lda $0823	                LDA ARGUMENT1
.1a2f81	83 05		sta $05,s	                STA L_Y                     ; Save it to Y
.1a2f83	a9 2c 00	lda #$002c	                LDA #','
.1a2f86	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a2f89	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2f8c	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2f8f	a5 23		lda $0823	                LDA ARGUMENT1
.1a2f91	85 55		sta $0855	                STA COLOR                   ; Save it to MARG1
.1a2f93	a3 03		lda $03,s	                LDA L_X                     ; Set the (X0, Y0) coordinates
.1a2f95	85 59		sta $0859	                STA X0
.1a2f97	a3 05		lda $05,s	                LDA L_Y
.1a2f99	85 5d		sta $085d	                STA Y0
.1a2f9b	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.1a2f9d	20 a1 2c	jsr $1a2ca1	            JSR BITMAP_SRAM
.1a2fa0	20 74 2e	jsr $1a2e74	            JSR PLOT
.1a2fa3	c2 20		rep #$20	            REP #$20
.1a2fa5	3b		tsc		            TSC
.1a2fa6	18		clc		            CLC
.1a2fa7	69 06 00	adc #$0006	            ADC #SIZE(locals)
.1a2faa	1b		tcs		            TCS
.1a2fab	28		plp		                PLP
.1a2fac	60		rts		            RTS
.1a2fad					S_LINE
.1a2fad	08		php		                PHP
.1a2fae					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
.1a2fae	c2 20		rep #$20	            REP #$20
.1a2fb0	3b		tsc		            TSC
.1a2fb1	38		sec		            SEC
.1a2fb2	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.1a2fb5	1b		tcs		            TCS
.1a2fb6	08		php		            PHP
.1a2fb7	c2 20		rep #$20	            REP #$20
.1a2fb9	48		pha		            PHA
.1a2fba	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a2fbd	5b		tcd		            TCD
.1a2fbe	68		pla		            PLA
.1a2fbf	28		plp		            PLP
.1a2fc0	08		php		            PHP
.1a2fc1	e2 20		sep #$20	            SEP #$20
.1a2fc3	48		pha		            PHA
.1a2fc4	a9 00		lda #$00	            LDA #0
.1a2fc6	48		pha		            PHA
.1a2fc7	ab		plb		            PLB
.1a2fc8	68		pla		            PLA
.1a2fc9	28		plp		            PLP
.1a2fca	c2 30		rep #$30	            REP #$30
.1a2fcc	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2fcf	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a2fd2	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.1a2fd4	a9 2c 00	lda #$002c	                LDA #','
.1a2fd7	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a2fda	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2fdd	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a2fe0	a5 23		lda $0823	                LDA ARGUMENT1
.1a2fe2	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.1a2fe4	a9 2c 00	lda #$002c	                LDA #','
.1a2fe7	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a2fea	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2fed	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a2ff0	a5 23		lda $0823	                LDA ARGUMENT1
.1a2ff2	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.1a2ff4	a9 2c 00	lda #$002c	                LDA #','
.1a2ff7	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a2ffa	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a2ffd	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a3000	a5 23		lda $0823	                LDA ARGUMENT1
.1a3002	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.1a3004	a9 2c 00	lda #$002c	                LDA #','
.1a3007	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a300a	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a300d	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a3010	a5 23		lda $0823	                LDA ARGUMENT1
.1a3012	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.1a3014	a9 2c 00	lda #$002c	                LDA #','
.1a3017	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a301a	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a301d	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a3020	a5 23		lda $0823	                LDA ARGUMENT1
.1a3022	85 55		sta $0855	                STA COLOR                   ; Save it to COLOR
.1a3024	a3 03		lda $03,s	                LDA L_X0                    ; Set the (X0, Y0) coordinates
.1a3026	85 59		sta $0859	                STA X0
.1a3028	a3 05		lda $05,s	                LDA L_Y0
.1a302a	85 5d		sta $085d	                STA Y0
.1a302c	a3 07		lda $07,s	                LDA L_X1                    ; Set the (X1, Y1) coordinates
.1a302e	85 61		sta $0861	                STA X1
.1a3030	a3 09		lda $09,s	                LDA L_Y1
.1a3032	85 65		sta $0865	                STA Y1
.1a3034	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.1a3036	20 a1 2c	jsr $1a2ca1	            JSR BITMAP_SRAM
.1a3039	20 ac 2e	jsr $1a2eac	            JSR LINE
.1a303c					done
.1a303c	c2 20		rep #$20	            REP #$20
.1a303e	3b		tsc		            TSC
.1a303f	18		clc		            CLC
.1a3040	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.1a3043	1b		tcs		            TCS
.1a3044	28		plp		                PLP
.1a3045	60		rts		            RTS
.1a3046					S_FILL
.1a3046	08		php		                PHP
.1a3047					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
>000b					L_COLOR         .word ?
.1a3047	c2 20		rep #$20	            REP #$20
.1a3049	3b		tsc		            TSC
.1a304a	38		sec		            SEC
.1a304b	e9 0c 00	sbc #$000c	            SBC #SIZE(locals)
.1a304e	1b		tcs		            TCS
.1a304f	08		php		            PHP
.1a3050	c2 20		rep #$20	            REP #$20
.1a3052	48		pha		            PHA
.1a3053	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3056	5b		tcd		            TCD
.1a3057	68		pla		            PLA
.1a3058	28		plp		            PLP
.1a3059	08		php		            PHP
.1a305a	e2 20		sep #$20	            SEP #$20
.1a305c	48		pha		            PHA
.1a305d	a9 00		lda #$00	            LDA #0
.1a305f	48		pha		            PHA
.1a3060	ab		plb		            PLB
.1a3061	68		pla		            PLA
.1a3062	28		plp		            PLP
.1a3063	c2 30		rep #$30	            REP #$30
.1a3065	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3068	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a306b	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.1a306d	a9 2c 00	lda #$002c	                LDA #','
.1a3070	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a3073	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3076	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a3079	a5 23		lda $0823	                LDA ARGUMENT1
.1a307b	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.1a307d	a9 2c 00	lda #$002c	                LDA #','
.1a3080	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a3083	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3086	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a3089	a5 23		lda $0823	                LDA ARGUMENT1
.1a308b	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.1a308d	a9 2c 00	lda #$002c	                LDA #','
.1a3090	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a3093	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3096	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a3099	a5 23		lda $0823	                LDA ARGUMENT1
.1a309b	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.1a309d	a9 2c 00	lda #$002c	                LDA #','
.1a30a0	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a30a3	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a30a6	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a30a9	a5 23		lda $0823	                LDA ARGUMENT1
.1a30ab	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.1a30ad	a9 2c 00	lda #$002c	                LDA #','
.1a30b0	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a30b3	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a30b6	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a30b9	a5 23		lda $0823	                LDA ARGUMENT1
.1a30bb	83 0b		sta $0b,s	                STA L_COLOR                 ; Save it to COLOR
.1a30bd	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.1a30bf	20 e5 2c	jsr $1a2ce5	            JSR BITMAP_VRAM
.1a30c2	a9 07 00	lda #$0007	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_1D_2D
.1a30c5	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a30c9	c2 20		rep #$20	            REP #$20
.1a30cb	a3 05		lda $05,s	                LDA L_Y0                    ; Get the row
.1a30cd	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.1a30d1	af 10 f0 1a	lda $1af010	                LDA @l GR_MAX_COLS
.1a30d5	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B         ; Multiply by the number of columns in the pixmap
.1a30d9	18		clc		                CLC                         ; Add the column
.1a30da	af 04 01 00	lda $000104	                LDA @l M0_RESULT
.1a30de	63 03		adc $03,s	                ADC L_X0
.1a30e0	85 0c		sta $080c	                STA SCRATCH
.1a30e2	e2 20		sep #$20	            SEP #$20
.1a30e4	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.1a30e8	69 00		adc #$00	                ADC #0
.1a30ea	85 0e		sta $080e	                STA SCRATCH+2
.1a30ec	c2 20		rep #$20	            REP #$20
.1a30ee	18		clc		                CLC                         ; Set the destination address
.1a30ef	a5 9e		lda $089e	                LDA MTEMPPTR
.1a30f1	65 0c		adc $080c	                ADC SCRATCH
.1a30f3	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.1a30f7	e2 20		sep #$20	            SEP #$20
.1a30f9	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.1a30fb	65 0e		adc $080e	                ADC SCRATCH+2
.1a30fd	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H
.1a3101	c2 20		rep #$20	            REP #$20
.1a3103	38		sec		                SEC                         ; Set the width of the FILL operation
.1a3104	a3 07		lda $07,s	                LDA L_X1
.1a3106	e3 03		sbc $03,s	                SBC L_X0
.1a3108	85 0c		sta $080c	                STA SCRATCH
.1a310a	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.1a310e	38		sec		                SEC
.1a310f	af 10 f0 1a	lda $1af010	                LDA @l GR_MAX_COLS
.1a3113	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L    ; And the destination stride
.1a3117	38		sec		                SEC                         ; Set the height of the FILL operation
.1a3118	a3 09		lda $09,s	                LDA L_Y1
.1a311a	e3 05		sbc $05,s	                SBC L_Y0
.1a311c	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.1a3120	e2 20		sep #$20	            SEP #$20
.1a3122	a3 0b		lda $0b,s	                LDA L_COLOR                 ; Set the color to write
.1a3124	8f 01 04 af	sta $af0401	                STA @l VDMA_BYTE_2_WRITE
.1a3128	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.1a312c	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF
.1a312e	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a3132	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.1a3136	30 fa		bmi $1a3132	                BMI wait
.1a3138	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.1a313a	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a313e					done
.1a313e	c2 20		rep #$20	            REP #$20
.1a3140	3b		tsc		            TSC
.1a3141	18		clc		            CLC
.1a3142	69 0c 00	adc #$000c	            ADC #SIZE(locals)
.1a3145	1b		tcs		            TCS
.1a3146	28		plp		                PLP
.1a3147	60		rts		            RTS
.1a3148					SPADDR
.1a3148	08		php		                PHP
.1a3149	c2 20		rep #$20	            REP #$20
.1a314b	c9 40 00	cmp #$0040	                CMP #SP_MAX
.1a314e	b0 13		bcs $1a3163	                BGE error
.1a3150	0a		asl a		                ASL A                       ; Multiply it by 8 (the size of s sprite block)
.1a3151	0a		asl a		                ASL A
.1a3152	0a		asl a		                ASL A
.1a3153	18		clc		                CLC                         ; Add it to the address of the first
.1a3154	69 00 0c	adc #$0c00	                ADC #<>SP00_CONTROL_REG     ; sprite block
.1a3157	85 9e		sta $089e	                STA MTEMPPTR
.1a3159	a9 af 00	lda #$00af	                LDA #`SP00_CONTROL_REG
.1a315c	69 00 00	adc #$0000	                ADC #0
.1a315f	85 a0		sta $08a0	                STA MTEMPPTR+2              ; And save that to MTEMPPTR
.1a3161	28		plp		                PLP
.1a3162	60		rts		            RTS
.1a3163					error
.1a3163	08		php		            PHP
.1a3164	c2 20		rep #$20	            REP #$20
.1a3166	48		pha		            PHA
.1a3167	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a316a	5b		tcd		            TCD
.1a316b	68		pla		            PLA
.1a316c	28		plp		            PLP
.1a316d	e2 20		sep #$20	            SEP #$20
.1a316f	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3171	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3175	c2 20		rep #$20	            REP #$20
.1a3177	29 ff 00	and #$00ff	            AND #$00FF
.1a317a	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a317d	e2 20		sep #$20	            SEP #$20
.1a317f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3182					S_SPRITE
.1a3182	08		php		                PHP
.1a3183					locals
>0001					L_SPRITE        .word ?
>0003					L_LUT           .byte ?
.1a3183	c2 20		rep #$20	            REP #$20
.1a3185	3b		tsc		            TSC
.1a3186	38		sec		            SEC
.1a3187	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.1a318a	1b		tcs		            TCS
.1a318b	c2 30		rep #$30	            REP #$30
.1a318d	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3190	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a3193	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.1a3195	a9 2c 00	lda #$002c	                LDA #','
.1a3198	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a319b	e2 20		sep #$20	            SEP #$20
.1a319d	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a31a0	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a31a3	a5 23		lda $0823	                LDA ARGUMENT1
.1a31a5	c9 08		cmp #$08	                CMP #GR_MAX_LUT             ; Check that it's in range
.1a31a7	b0 56		bcs $1a31ff	                BGE error                   ; If not: throw an error
.1a31a9	83 03		sta $03,s	                STA L_LUT                   ; Save it as lut
.1a31ab	a9 2c		lda #$2c	                LDA #','
.1a31ad	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a31b0	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a31b3	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a31b6	c2 20		rep #$20	            REP #$20
.1a31b8	38		sec		                SEC                         ; Adjust address to be in Vicky's space
.1a31b9	a5 23		lda $0823	                LDA ARGUMENT1
.1a31bb	e9 00 00	sbc #$0000	                SBC #<>VRAM
.1a31be	85 23		sta $0823	                STA ARGUMENT1
.1a31c0	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a31c2	e9 b0 00	sbc #$00b0	                SBC #`VRAM
.1a31c5	85 25		sta $0825	                STA ARGUMENT1+2
.1a31c7	30 36		bmi $1a31ff	                BMI error                   ; If negative, throw an error
.1a31c9	c2 20		rep #$20	            REP #$20
.1a31cb	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a31cd	aa		tax		                TAX
.1a31ce	20 48 31	jsr $1a3148	            JSR SPADDR
.1a31d1	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the lower word of the address
.1a31d3	a0 01 00	ldy #$0001	                LDY #SP_ADDR
.1a31d6	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a31d8	e2 20		sep #$20	            SEP #$20
.1a31da	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a31dc	c8		iny		                INY
.1a31dd	c8		iny		                INY
.1a31de	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save the upper byte of the address
.1a31e0	bf 18 f0 1a	lda $1af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the sprite control register
.1a31e4	29 f1		and #$f1	                AND #%11110001              ; Filter off the current LUT
.1a31e6	85 0c		sta $080c	                STA SCRATCH
.1a31e8	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT back
.1a31ea	0a		asl a		                ASL A                       ; Sift it into the LUT position
.1a31eb	29 0e		and #$0e	                AND #%00001110              ; Make sure we don't have anything wrong there
.1a31ed	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with what's in the sprite's control
.1a31ef	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the register's bits
.1a31f1	9f 18 f0 1a	sta $1af018,x	                STA @l GS_SP_CONTROL,X      ; And the shadow register
.1a31f5					done
.1a31f5	c2 20		rep #$20	            REP #$20
.1a31f7	3b		tsc		            TSC
.1a31f8	18		clc		            CLC
.1a31f9	69 03 00	adc #$0003	            ADC #SIZE(locals)
.1a31fc	1b		tcs		            TCS
.1a31fd	28		plp		                PLP
.1a31fe	60		rts		            RTS
.1a31ff					error
.1a31ff	08		php		            PHP
.1a3200	c2 20		rep #$20	            REP #$20
.1a3202	48		pha		            PHA
.1a3203	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3206	5b		tcd		            TCD
.1a3207	68		pla		            PLA
.1a3208	28		plp		            PLP
.1a3209	e2 20		sep #$20	            SEP #$20
.1a320b	a9 09		lda #$09	            LDA #ERR_RANGE
.1a320d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3211	c2 20		rep #$20	            REP #$20
.1a3213	29 ff 00	and #$00ff	            AND #$00FF
.1a3216	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3219	e2 20		sep #$20	            SEP #$20
.1a321b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a321e					S_SPRITEAT
.1a321e	08		php		                PHP
.1a321f					locals
>0001					L_SPRITE        .word ?
>0003					L_X             .word ?
.1a321f	c2 20		rep #$20	            REP #$20
.1a3221	3b		tsc		            TSC
.1a3222	38		sec		            SEC
.1a3223	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.1a3226	1b		tcs		            TCS
.1a3227	c2 30		rep #$30	            REP #$30
.1a3229	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a322c	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a322f	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.1a3231	a9 2c 00	lda #$002c	                LDA #','
.1a3234	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a3237	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a323a	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a323d	a5 23		lda $0823	                LDA ARGUMENT1
.1a323f	83 03		sta $03,s	                STA L_X                     ; Save it as X
.1a3241	a9 2c 00	lda #$002c	                LDA #','
.1a3244	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a3247	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a324a	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a324d	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a324f	20 48 31	jsr $1a3148	            JSR SPADDR
.1a3252	a3 03		lda $03,s	                LDA L_X                     ; Get the X coordinate
.1a3254	a0 04 00	ldy #$0004	                LDY #SP_X_COORD             ; Save the X coordinate for the sprite
.1a3257	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3259	a5 23		lda $0823	                LDA ARGUMENT1
.1a325b	a0 06 00	ldy #$0006	                LDY #SP_Y_COORD             ; Save the Y coordinate for the sprite
.1a325e	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3260					done
.1a3260	c2 20		rep #$20	            REP #$20
.1a3262	3b		tsc		            TSC
.1a3263	18		clc		            CLC
.1a3264	69 04 00	adc #$0004	            ADC #SIZE(locals)
.1a3267	1b		tcs		            TCS
.1a3268	28		plp		                PLP
.1a3269	60		rts		            RTS
.1a326a					S_SPRITESHOW
.1a326a	08		php		                PHP
.1a326b					locals
>0001					L_SPRITE        .word ?
>0003					L_VISIBLE       .byte ?
.1a326b	c2 20		rep #$20	            REP #$20
.1a326d	3b		tsc		            TSC
.1a326e	38		sec		            SEC
.1a326f	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.1a3272	1b		tcs		            TCS
.1a3273	c2 30		rep #$30	            REP #$30
.1a3275	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3278	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a327b	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.1a327d	a9 2c 00	lda #$002c	                LDA #','
.1a3280	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a3283	e2 20		sep #$20	            SEP #$20
.1a3285	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3288	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a328b	a5 23		lda $0823	                LDA ARGUMENT1
.1a328d	d0 04		bne $1a3293	                BNE is_visible
.1a328f	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 0 (not visible)
.1a3291	80 04		bra $1a3297	                BRA chk_layer
.1a3293	a9 01		lda #$01	is_visible      LDA #1
.1a3295	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 1 (visible)
.1a3297	a9 2c		lda #$2c	chk_layer       LDA #','
.1a3299	85 37		sta $0837	                STA TARGETTOK
.1a329b	20 a0 20	jsr $1a20a0	            JSR OPT_TOK
.1a329e	b0 20		bcs $1a32c0	                BCS get_layer               ; Yes: get the layer
.1a32a0					no_layer
.1a32a0	c2 30		rep #$30	            REP #$30
.1a32a2	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a32a4	aa		tax		                TAX
.1a32a5	20 48 31	jsr $1a3148	            JSR SPADDR
.1a32a8	e2 20		sep #$20	            SEP #$20
.1a32aa	bf 18 f0 1a	lda $1af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.1a32ae	29 fe		and #$fe	                AND #$FE                    ; Filter out the enable bit
.1a32b0	85 0c		sta $080c	                STA SCRATCH
.1a32b2	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.1a32b4	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.1a32b6	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.1a32b8	9f 18 f0 1a	sta $1af018,x	                STA @l GS_SP_CONTROL,X      ; And save it
.1a32bc	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; ... and to Vicky
.1a32be	80 36		bra $1a32f6	                BRA done
.1a32c0					get_layer
.1a32c0	c2 30		rep #$30	            REP #$30
.1a32c2	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a32c5	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a32c8	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a32cb	a5 23		lda $0823	                LDA ARGUMENT1
.1a32cd	c9 08 00	cmp #$0008	                CMP #8                      ; Make sure it's in range
.1a32d0	b0 2e		bcs $1a3300	                BGE error                   ; If not, throw an out of range error
.1a32d2	0a		asl a		                ASL A                       ; If it's ok... shift it into position
.1a32d3	0a		asl a		                ASL A
.1a32d4	0a		asl a		                ASL A
.1a32d5	0a		asl a		                ASL A
.1a32d6	85 0c		sta $080c	                STA SCRATCH                 ; And save it in SCRATCH
.1a32d8	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.1a32da	aa		tax		                TAX
.1a32db	20 48 31	jsr $1a3148	            JSR SPADDR
.1a32de	e2 20		sep #$20	            SEP #$20
.1a32e0	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.1a32e2	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.1a32e4	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.1a32e6	85 0c		sta $080c	                STA SCRATCH
.1a32e8	bf 18 f0 1a	lda $1af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.1a32ec	29 8e		and #$8e	                AND #%10001110              ; Filter out the enable and layer bits
.1a32ee	05 0c		ora $080c	                ORA SCRATCH                 ; Combine with the provided layer and enable
.1a32f0	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the bits in Vicky
.1a32f2	9f 18 f0 1a	sta $1af018,x	                STA @l GS_SP_CONTROL,X      ; And to the shadow registers
.1a32f6					done
.1a32f6	c2 20		rep #$20	            REP #$20
.1a32f8	3b		tsc		            TSC
.1a32f9	18		clc		            CLC
.1a32fa	69 03 00	adc #$0003	            ADC #SIZE(locals)
.1a32fd	1b		tcs		            TCS
.1a32fe	28		plp		                PLP
.1a32ff	60		rts		            RTS
.1a3300					error
.1a3300	08		php		            PHP
.1a3301	c2 20		rep #$20	            REP #$20
.1a3303	48		pha		            PHA
.1a3304	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3307	5b		tcd		            TCD
.1a3308	68		pla		            PLA
.1a3309	28		plp		            PLP
.1a330a	e2 20		sep #$20	            SEP #$20
.1a330c	a9 09		lda #$09	            LDA #ERR_RANGE
.1a330e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3312	c2 20		rep #$20	            REP #$20
.1a3314	29 ff 00	and #$00ff	            AND #$00FF
.1a3317	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a331a	e2 20		sep #$20	            SEP #$20
.1a331c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a331f					TILESET_ADDR
.1a331f	08		php		                PHP
.1a3320	c2 20		rep #$20	            REP #$20
.1a3322	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.1a3325	b0 19		bcs $1a3340	                BGE out_of_range            ; If not, throw a range error
.1a3327	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.1a332a	a9 04 00	lda #$0004	                LDA #TILESET_REG_SIZE       ; Multiply it by the number of bytes in a tile set register set
.1a332d	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.1a3330	18		clc		                CLC                         ; Add to TILESET0_ADDY_L to get the final address
.1a3331	ad 04 01	lda $0104	                LDA @w M0_RESULT
.1a3334	69 80 02	adc #$0280	                ADC #<>TILESET0_ADDY_L
.1a3337	85 9e		sta $089e	                STA MTEMPPTR
.1a3339	a9 af 00	lda #$00af	                LDA #`TILESET0_ADDY_L
.1a333c	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a333e	28		plp		                PLP
.1a333f	60		rts		            RTS
.1a3340					out_of_range
.1a3340	08		php		            PHP
.1a3341	c2 20		rep #$20	            REP #$20
.1a3343	48		pha		            PHA
.1a3344	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3347	5b		tcd		            TCD
.1a3348	68		pla		            PLA
.1a3349	28		plp		            PLP
.1a334a	e2 20		sep #$20	            SEP #$20
.1a334c	a9 09		lda #$09	            LDA #ERR_RANGE
.1a334e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3352	c2 20		rep #$20	            REP #$20
.1a3354	29 ff 00	and #$00ff	            AND #$00FF
.1a3357	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a335a	e2 20		sep #$20	            SEP #$20
.1a335c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a335f					TILEMAP_ADDR
.1a335f	08		php		                PHP
.1a3360	c2 20		rep #$20	            REP #$20
.1a3362	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.1a3365	b0 19		bcs $1a3380	                BGE out_of_range            ; If not, throw a range error
.1a3367	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.1a336a	a9 0c 00	lda #$000c	                LDA #TILEMAP_REG_SIZE       ; Multiply it by the number of bytes in a tile map register set
.1a336d	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.1a3370	18		clc		                CLC
.1a3371	ad 04 01	lda $0104	                LDA @w M0_RESULT            ; Add to TL0_CONTROL_REG to get the final address
.1a3374	69 00 02	adc #$0200	                ADC #<>TL0_CONTROL_REG
.1a3377	85 9e		sta $089e	                STA MTEMPPTR
.1a3379	a9 af 00	lda #$00af	                LDA #`TL0_CONTROL_REG
.1a337c	85 a0		sta $08a0	                STA MTEMPPTR+2
.1a337e	28		plp		                PLP
.1a337f	60		rts		            RTS
.1a3380					out_of_range
.1a3380	08		php		            PHP
.1a3381	c2 20		rep #$20	            REP #$20
.1a3383	48		pha		            PHA
.1a3384	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3387	5b		tcd		            TCD
.1a3388	68		pla		            PLA
.1a3389	28		plp		            PLP
.1a338a	e2 20		sep #$20	            SEP #$20
.1a338c	a9 09		lda #$09	            LDA #ERR_RANGE
.1a338e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3392	c2 20		rep #$20	            REP #$20
.1a3394	29 ff 00	and #$00ff	            AND #$00FF
.1a3397	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a339a	e2 20		sep #$20	            SEP #$20
.1a339c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a339f					S_TILESET
.1a339f	08		php		                PHP
.1a33a0					locals
>0001					L_TILENUM       .word ?
>0003					L_LUT           .word ?
>0005					L_IS_SQUARE     .word ?
.1a33a0	c2 20		rep #$20	            REP #$20
.1a33a2	3b		tsc		            TSC
.1a33a3	38		sec		            SEC
.1a33a4	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.1a33a7	1b		tcs		            TCS
.1a33a8	c2 20		rep #$20	            REP #$20
.1a33aa	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a33ad	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a33b0	a5 23		lda $0823	                LDA ARGUMENT1
.1a33b2	83 01		sta $01,s	                STA L_TILENUM               ; Save it as the tile set/map number
.1a33b4	a9 2c 00	lda #$002c	                LDA #','
.1a33b7	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a33ba	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a33bd	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a33c0	a5 23		lda $0823	                LDA ARGUMENT1
.1a33c2	83 03		sta $03,s	                STA L_LUT                   ; Save it as LUT
.1a33c4	a9 2c 00	lda #$002c	                LDA #','
.1a33c7	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a33ca	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a33cd	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a33d0	a5 23		lda $0823	                LDA ARGUMENT1
.1a33d2	83 05		sta $05,s	                STA L_IS_SQUARE             ; Save it as IS_SQUARE
.1a33d4	a9 2c 00	lda #$002c	                LDA #','
.1a33d7	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a33da	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a33dd	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a33e0	a3 01		lda $01,s	                LDA L_TILENUM
.1a33e2	20 1f 33	jsr $1a331f	            JSR TILESET_ADDR
.1a33e5	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the bitmap address - the address of the start of VRAM
.1a33e7	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And save it to the registers
.1a33e9	e2 20		sep #$20	            SEP #$20
.1a33eb	38		sec		                SEC
.1a33ec	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a33ee	e9 b0		sbc #$b0	                SBC #`VRAM
.1a33f0	a0 02 00	ldy #$0002	                LDY #TILESET_ADDY_H
.1a33f3	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a33f5	a3 05		lda $05,s	                LDA L_IS_SQUARE             ; Check if is_square == 0?
.1a33f7	d0 0d		bne $1a3406	                BNE is_square
.1a33f9					not_square
.1a33f9	e2 20		sep #$20	            SEP #$20
.1a33fb	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.1a33fd	29 07		and #$07	                AND #$07                    ; Force it to be in range
.1a33ff	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.1a3402	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.1a3404	80 0d		bra $1a3413	                BRA done
.1a3406					is_square
.1a3406	e2 20		sep #$20	            SEP #$20
.1a3408	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.1a340a	29 07		and #$07	                AND #$07                    ; Force it to be in range
.1a340c	09 08		ora #$08	                ORA #TILESET_SQUARE_256     ; Turn on the 256x256 flag
.1a340e	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.1a3411	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.1a3413					done
.1a3413	c2 20		rep #$20	            REP #$20
.1a3415	3b		tsc		            TSC
.1a3416	18		clc		            CLC
.1a3417	69 06 00	adc #$0006	            ADC #SIZE(locals)
.1a341a	1b		tcs		            TCS
.1a341b	28		plp		                PLP
.1a341c	60		rts		            RTS
.1a341d					S_TILEMAP
.1a341d	08		php		                PHP
.1a341e					locals
>0001					L_TILENUM       .word ?
>0003					L_WIDTH         .word ?
>0005					L_HEIGHT        .word ?
.1a341e	c2 20		rep #$20	            REP #$20
.1a3420	3b		tsc		            TSC
.1a3421	38		sec		            SEC
.1a3422	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.1a3425	1b		tcs		            TCS
.1a3426	c2 20		rep #$20	            REP #$20
.1a3428	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a342b	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a342e	a5 23		lda $0823	                LDA ARGUMENT1
.1a3430	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.1a3432	a9 2c 00	lda #$002c	                LDA #','
.1a3435	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a3438	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a343b	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a343e	a5 23		lda $0823	                LDA ARGUMENT1
.1a3440	83 03		sta $03,s	                STA L_WIDTH                 ; Save it as WIDTH
.1a3442	a9 2c 00	lda #$002c	                LDA #','
.1a3445	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a3448	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a344b	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a344e	a5 23		lda $0823	                LDA ARGUMENT1
.1a3450	83 05		sta $05,s	                STA L_HEIGHT                ; Save it as HEIGHT
.1a3452	a9 2c 00	lda #$002c	                LDA #','
.1a3455	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a3458	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a345b	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a345e	a3 01		lda $01,s	                LDA L_TILENUM
.1a3460	20 5f 33	jsr $1a335f	            JSR TILEMAP_ADDR
.1a3463	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the map address - the address of the start of VRAM
.1a3465	a0 01 00	ldy #$0001	                LDY #TILEMAP_START_ADDY
.1a3468	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; And save it to the registers
.1a346a	e2 20		sep #$20	            SEP #$20
.1a346c	38		sec		                SEC
.1a346d	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a346f	e9 b0		sbc #$b0	                SBC #`VRAM
.1a3471	c8		iny		                INY
.1a3472	c8		iny		                INY
.1a3473	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3475	c2 20		rep #$20	            REP #$20
.1a3477	a3 03		lda $03,s	                LDA L_WIDTH                 ; Set the width
.1a3479	a0 04 00	ldy #$0004	                LDY #TILEMAP_TOTAL_X
.1a347c	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a347e	a3 05		lda $05,s	                LDA L_HEIGHT                ; Set the height
.1a3480	a0 06 00	ldy #$0006	                LDY #TILEMAP_TOTAL_Y
.1a3483	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3485					done
.1a3485	c2 20		rep #$20	            REP #$20
.1a3487	3b		tsc		            TSC
.1a3488	18		clc		            CLC
.1a3489	69 06 00	adc #$0006	            ADC #SIZE(locals)
.1a348c	1b		tcs		            TCS
.1a348d	28		plp		                PLP
.1a348e	60		rts		            RTS
.1a348f					S_TILESHOW
.1a348f	08		php		                PHP
.1a3490					locals
>0001					L_TILENUM       .word ?
.1a3490	c2 20		rep #$20	            REP #$20
.1a3492	f4 00 00	pea #$0000	            PEA #0
.1a3495	c2 20		rep #$20	            REP #$20
.1a3497	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a349a	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a349d	a5 23		lda $0823	                LDA ARGUMENT1
.1a349f	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.1a34a1	a9 2c 00	lda #$002c	                LDA #','
.1a34a4	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a34a7	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a34aa	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a34ad	a3 01		lda $01,s	                LDA L_TILENUM
.1a34af	20 5f 33	jsr $1a335f	            JSR TILEMAP_ADDR
.1a34b2	a5 23		lda $0823	                LDA ARGUMENT1               ; CHeck the visible parameter
.1a34b4	d0 06		bne $1a34bc	                BNE is_visible              ; If it's <> 0, make it visible
.1a34b6	e2 20		sep #$20	            SEP #$20
.1a34b8	a9 00		lda #$00	                LDA #0                      ; Control value for invisible
.1a34ba	80 04		bra $1a34c0	                BRA set_control
.1a34bc					is_visible
.1a34bc	e2 20		sep #$20	            SEP #$20
.1a34be	a9 01		lda #$01	                LDA #TILEMAP_VISIBLE        ; Control value for visible
.1a34c0					set_control
.1a34c0	e2 20		sep #$20	            SEP #$20
.1a34c2	a0 00 00	ldy #$0000	                LDY #TILEMAP_CONTROL        ; Set the control register
.1a34c5	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a34c7					done
.1a34c7	c2 20		rep #$20	            REP #$20
.1a34c9	68		pla		            PLA
.1a34ca	28		plp		                PLP
.1a34cb	60		rts		            RTS
.1a34cc					S_TILEAT
.1a34cc	08		php		                PHP
.1a34cd					locals
>0001					L_TILENUM       .word ?
>0003					L_X             .word ?
.1a34cd	c2 20		rep #$20	            REP #$20
.1a34cf	3b		tsc		            TSC
.1a34d0	38		sec		            SEC
.1a34d1	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.1a34d4	1b		tcs		            TCS
.1a34d5	c2 20		rep #$20	            REP #$20
.1a34d7	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a34da	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a34dd	a5 23		lda $0823	                LDA ARGUMENT1
.1a34df	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.1a34e1	a9 2c 00	lda #$002c	                LDA #','
.1a34e4	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a34e7	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a34ea	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a34ed	a5 23		lda $0823	                LDA ARGUMENT1
.1a34ef	83 03		sta $03,s	                STA L_X                     ; Save as X
.1a34f1	a9 2c 00	lda #$002c	                LDA #','
.1a34f4	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a34f7	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a34fa	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a34fd	a3 01		lda $01,s	                LDA L_TILENUM
.1a34ff	20 5f 33	jsr $1a335f	            JSR TILEMAP_ADDR
.1a3502	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the Y position
.1a3504	a0 0a 00	ldy #$000a	                LDY #TILEMAP_WINDOW_Y
.1a3507	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3509	a3 03		lda $03,s	                LDA L_X                     ; Set the X position
.1a350b	a0 08 00	ldy #$0008	                LDY #TILEMAP_WINDOW_X
.1a350e	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.1a3510					done
.1a3510	c2 20		rep #$20	            REP #$20
.1a3512	3b		tsc		            TSC
.1a3513	18		clc		            CLC
.1a3514	69 04 00	adc #$0004	            ADC #SIZE(locals)
.1a3517	1b		tcs		            TCS
.1a3518	28		plp		                PLP
.1a3519	60		rts		            RTS
=0					DMA_LINEAR = 0                              ; Memory to copy is a continguous, linear range
=1					DMA_RECT = 1                                ; Memory to copy is a rectangular block
.0000					DMA_BLOCK
>0000					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>0001					ADDR            .long ?                     ; The starting address for the data to transfer
>0004					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>0007					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>0009					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>000b					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
=$01					DMA_SRC_2D = $01                            ; Source transfer should be 2D
=$02					DMA_DST_2D = $02                            ; Destination transfer should be 2D
=$10					DMA_SRC_SRAM = $10                          ; Flag indicating that the source is in SRAM ($00:0000 - $3F:FFFF)
=$20					DMA_DST_SRAM = $20                          ; Flag indicating that the destination is in SRAM ($00:0000 - $3F:FFFF)
>1af058					DMA_BLOCKS      .byte ?                     ; What blocks are involved
.1af059					DMA_SRC
>1af059					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>1af05a					ADDR            .long ?                     ; The starting address for the data to transfer
>1af05d					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>1af060					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>1af062					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>1af064					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.1af066					DMA_DEST
>1af066					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>1af067					ADDR            .long ?                     ; The starting address for the data to transfer
>1af06a					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>1af06d					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>1af06f					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>1af071					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.1a351a					DO_DMA
.1a351a	0b		phd		                PHD
.1a351b	08		php		                PHP
.1a351c	08		php		            PHP
.1a351d	c2 20		rep #$20	            REP #$20
.1a351f	48		pha		            PHA
.1a3520	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a3523	5b		tcd		            TCD
.1a3524	68		pla		            PLA
.1a3525	28		plp		            PLP
.1a3526	e2 20		sep #$20	            SEP #$20
.1a3528	a9 00		lda #$00	                LDA #0
.1a352a	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS           ; Set mode to something neutral
.1a352e	af 5c f0 1a	lda $1af05c	                LDA @l DMA_SRC.ADDR+2       ; Check the bank
.1a3532	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.1a3534	b0 1c		bcs $1a3552	                BGE src_vram                ; Yes: leave the DMA_BLOCK bit alone
.1a3536	8f 24 04 af	sta $af0424	src_sram        STA @l SDMA_SRC_ADDY_H      ; Set the SDMA source address
.1a353a	af 5b f0 1a	lda $1af05b	                LDA @l DMA_SRC.ADDR+1
.1a353e	8f 23 04 af	sta $af0423	                STA @l SDMA_SRC_ADDY_M
.1a3542	af 5a f0 1a	lda $1af05a	                LDA @l DMA_SRC.ADDR
.1a3546	8f 22 04 af	sta $af0422	                STA @l SDMA_SRC_ADDY_L
.1a354a	a9 10		lda #$10	                LDA #DMA_SRC_SRAM           ; Set the SRAM source block bit
.1a354c	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a3550	80 17		bra $1a3569	                BRA src_mode
.1a3552	38		sec		src_vram        SEC                         ; Convert to VRAM relative address
.1a3553	e9 b0		sbc #$b0	                SBC #`VRAM
.1a3555	8f 04 04 af	sta $af0404	                STA @l VDMA_SRC_ADDY_H      ; Set the VDMA source address
.1a3559	af 5b f0 1a	lda $1af05b	                LDA @l DMA_SRC.ADDR+1
.1a355d	8f 03 04 af	sta $af0403	                STA @l VDMA_SRC_ADDY_M
.1a3561	af 5a f0 1a	lda $1af05a	                LDA @l DMA_SRC.ADDR
.1a3565	8f 02 04 af	sta $af0402	                STA @l VDMA_SRC_ADDY_L
.1a3569	af 59 f0 1a	lda $1af059	src_mode        LDA @l DMA_SRC.MODE         ; Determine if source is 1D or 2D
.1a356d	d0 3c		bne $1a35ab	                BNE src_2d
.1a356f	af 58 f0 1a	lda $1af058	src_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.1a3573	f0 1b		beq $1a3590	                BEQ src_1d_vram
.1a3575	af 5d f0 1a	lda $1af05d	src_1d_sram     LDA @l DMA_SRC.SIZE         ; It's SRAM, so set the SDMA size
.1a3579	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.1a357d	af 5e f0 1a	lda $1af05e	                LDA @l DMA_SRC.SIZE+1
.1a3581	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_M
.1a3585	af 5f f0 1a	lda $1af05f	                LDA @l DMA_SRC.SIZE+2
.1a3589	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.1a358d	82 8b 00	brl $1a361b	                BRL set_dst                 ; Go to set up the destination
.1a3590	af 5d f0 1a	lda $1af05d	src_1d_vram     LDA @l DMA_SRC.SIZE         ; It's VRAM, so set the VDMA size
.1a3594	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.1a3598	af 5e f0 1a	lda $1af05e	                LDA @l DMA_SRC.SIZE+1
.1a359c	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_M
.1a35a0	af 5f f0 1a	lda $1af05f	                LDA @l DMA_SRC.SIZE+2
.1a35a4	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.1a35a8	82 70 00	brl $1a361b	                BRL set_dst                 ; Go to set up the destination
.1a35ab	af 58 f0 1a	lda $1af058	src_2d          LDA @l DMA_BLOCKS
.1a35af	09 01		ora #$01	                ORA #DMA_SRC_2D             ; Set the bit to make the source a 2D transfer
.1a35b1	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a35b5	89 10		bit #$10	                BIT #DMA_SRC_SRAM           ; Are we writing to SRAM
.1a35b7	f0 32		beq $1a35eb	                BEQ src_2d_vram             ; No: set the 2d values in the VRAM source
.1a35b9	af 60 f0 1a	lda $1af060	src_2d_sram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.1a35bd	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.1a35c1	af 61 f0 1a	lda $1af061	                LDA @l DMA_SRC.WIDTH+1
.1a35c5	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.1a35c9	af 62 f0 1a	lda $1af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.1a35cd	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.1a35d1	af 63 f0 1a	lda $1af063	                LDA @l DMA_SRC.HEIGHT+1
.1a35d5	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.1a35d9	af 64 f0 1a	lda $1af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.1a35dd	8f 2c 04 af	sta $af042c	                STA @l SDMA_SRC_STRIDE_L
.1a35e1	af 65 f0 1a	lda $1af065	                LDA @l DMA_SRC.STRIDE+1
.1a35e5	8f 2d 04 af	sta $af042d	                STA @l SDMA_SRC_STRIDE_L+1
.1a35e9	80 30		bra $1a361b	                BRA set_dst
.1a35eb	af 60 f0 1a	lda $1af060	src_2d_vram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.1a35ef	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.1a35f3	af 61 f0 1a	lda $1af061	                LDA @l DMA_SRC.WIDTH+1
.1a35f7	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.1a35fb	af 62 f0 1a	lda $1af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.1a35ff	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.1a3603	af 63 f0 1a	lda $1af063	                LDA @l DMA_SRC.HEIGHT+1
.1a3607	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.1a360b	af 64 f0 1a	lda $1af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.1a360f	8f 0c 04 af	sta $af040c	                STA @l VDMA_SRC_STRIDE_L
.1a3613	af 65 f0 1a	lda $1af065	                LDA @l DMA_SRC.STRIDE+1
.1a3617	8f 0d 04 af	sta $af040d	                STA @l VDMA_SRC_STRIDE_L+1
.1a361b					set_dst
.1a361b	e2 20		sep #$20	            SEP #$20
.1a361d	af 69 f0 1a	lda $1af069	                LDA @l DMA_DEST.ADDR+2      ; Check the bank
.1a3621	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.1a3623	b0 20		bcs $1a3645	                BGE dst_vram                ; Yes: leave the DMA_BLOCK bit alone
.1a3625	8f 27 04 af	sta $af0427	dst_sram        STA @l SDMA_DST_ADDY_H      ; Set the SDMA destination address
.1a3629	af 68 f0 1a	lda $1af068	                LDA @l DMA_DEST.ADDR+1
.1a362d	8f 26 04 af	sta $af0426	                STA @l SDMA_DST_ADDY_M
.1a3631	af 67 f0 1a	lda $1af067	                LDA @l DMA_DEST.ADDR
.1a3635	8f 25 04 af	sta $af0425	                STA @l SDMA_DST_ADDY_L
.1a3639	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS
.1a363d	09 20		ora #$20	                ORA #DMA_DST_SRAM           ; Set the bit to indicate the destination is SRAM
.1a363f	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a3643	80 17		bra $1a365c	                BRA dst_mode
.1a3645	38		sec		dst_vram        SEC                         ; Convert to VRAM relative address
.1a3646	e9 b0		sbc #$b0	                SBC #`VRAM
.1a3648	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H      ; Set the VDMA destination address
.1a364c	af 68 f0 1a	lda $1af068	                LDA @l DMA_DEST.ADDR+1
.1a3650	8f 06 04 af	sta $af0406	                STA @l VDMA_DST_ADDY_M
.1a3654	af 67 f0 1a	lda $1af067	                LDA @l DMA_DEST.ADDR
.1a3658	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.1a365c	af 66 f0 1a	lda $1af066	dst_mode        LDA @l DMA_DEST.MODE
.1a3660	d0 3e		bne $1a36a0	                BNE dst_2d                  ; If 2D, set up the 2D destination parameters
.1a3662	af 58 f0 1a	lda $1af058	dst_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.1a3666	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Is the destination SRAM?
.1a3668	f0 1b		beq $1a3685	                BEQ dst_1d_vram
.1a366a	af 6a f0 1a	lda $1af06a	dst_1d_sram     LDA @l DMA_DEST.SIZE
.1a366e	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.1a3672	af 6b f0 1a	lda $1af06b	                LDA @l DMA_DEST.SIZE+1
.1a3676	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_L+1
.1a367a	af 6c f0 1a	lda $1af06c	                LDA @l DMA_DEST.SIZE+2
.1a367e	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.1a3682	82 8b 00	brl $1a3710	                BRL start_xfer
.1a3685	af 6a f0 1a	lda $1af06a	dst_1d_vram     LDA @l DMA_DEST.SIZE
.1a3689	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.1a368d	af 6b f0 1a	lda $1af06b	                LDA @l DMA_DEST.SIZE+1
.1a3691	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_L+1
.1a3695	af 6c f0 1a	lda $1af06c	                LDA @l DMA_DEST.SIZE+2
.1a3699	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.1a369d	82 70 00	brl $1a3710	                BRL start_xfer
.1a36a0	af 58 f0 1a	lda $1af058	dst_2d          LDA @l DMA_BLOCKS
.1a36a4	09 02		ora #$02	                ORA #DMA_DST_2D             ; Set the bit to make the source a 2D transfer
.1a36a6	8f 58 f0 1a	sta $1af058	                STA @l DMA_BLOCKS
.1a36aa	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Are we writing to the SRAM?
.1a36ac	f0 32		beq $1a36e0	                BEQ dst_2d_vram             ; No: set the 2D parameters for VRAM
.1a36ae	af 6d f0 1a	lda $1af06d	dst_2d_sram     LDA @l DMA_DEST.WIDTH       ; Set the SRAM width
.1a36b2	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.1a36b6	af 6e f0 1a	lda $1af06e	                LDA @L DMA_DEST.WIDTH+1
.1a36ba	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.1a36be	af 6f f0 1a	lda $1af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the SRAM height
.1a36c2	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.1a36c6	af 70 f0 1a	lda $1af070	                LDA @L DMA_DEST.HEIGHT+1
.1a36ca	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.1a36ce	af 71 f0 1a	lda $1af071	                LDA @l DMA_DEST.STRIDE      ; Set the SRAM stride
.1a36d2	8f 2e 04 af	sta $af042e	                STA @l SDMA_DST_STRIDE_L
.1a36d6	af 72 f0 1a	lda $1af072	                LDA @L DMA_DEST.STRIDE+1
.1a36da	8f 2f 04 af	sta $af042f	                STA @l SDMA_DST_STRIDE_L+1
.1a36de	80 30		bra $1a3710	                BRA start_xfer
.1a36e0	af 6d f0 1a	lda $1af06d	dst_2d_vram     LDA @l DMA_DEST.WIDTH       ; Set the VRAM width
.1a36e4	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.1a36e8	af 6e f0 1a	lda $1af06e	                LDA @L DMA_DEST.WIDTH+1
.1a36ec	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.1a36f0	af 6f f0 1a	lda $1af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the VRAM height
.1a36f4	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.1a36f8	af 70 f0 1a	lda $1af070	                LDA @L DMA_DEST.HEIGHT+1
.1a36fc	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.1a3700	af 71 f0 1a	lda $1af071	                LDA @l DMA_DEST.STRIDE      ; Set the VRAM stride
.1a3704	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L
.1a3708	af 72 f0 1a	lda $1af072	                LDA @L DMA_DEST.STRIDE+1
.1a370c	8f 0f 04 af	sta $af040f	                STA @l VDMA_DST_STRIDE_L+1
.1a3710	af 58 f0 1a	lda $1af058	start_xfer      LDA @l DMA_BLOCKS
.1a3714	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.1a3716	f0 43		beq $1a375b	                BEQ start_vdma_only
.1a3718	c9 10		cmp #$10	                CMP #DMA_SRC_SRAM
.1a371a	f0 76		beq $1a3792	                BEQ start_s2v
.1a371c	c9 20		cmp #$20	                CMP #DMA_DST_SRAM
.1a371e	d0 03		bne $1a3723	                BNE start_sdma_only
.1a3720	82 8a 00	brl $1a37ad	                BRL start_v2s
.1a3723					start_sdma_only
.1a3723	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.1a3727	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.1a3729	f0 23		beq $1a374e	                BEQ sdma_1d_only            ; Source and Destination 1D...
.1a372b	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.1a372d	f0 23		beq $1a3752	                BEQ sdma_2d_only            ; Source and Destination 2D
.1a372f	08		php		            PHP
.1a3730	c2 20		rep #$20	            REP #$20
.1a3732	48		pha		            PHA
.1a3733	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3736	5b		tcd		            TCD
.1a3737	68		pla		            PLA
.1a3738	28		plp		            PLP
.1a3739	e2 20		sep #$20	            SEP #$20
.1a373b	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a373d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3741	c2 20		rep #$20	            REP #$20
.1a3743	29 ff 00	and #$00ff	            AND #$00FF
.1a3746	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3749	e2 20		sep #$20	            SEP #$20
.1a374b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a374e	a9 01		lda #$01	sdma_1d_only    LDA #SDMA_CTRL0_Enable      ; Set the bits for 1D, SRAM->SRAM
.1a3750	80 02		bra $1a3754	                BRA sdma_set_ctrl
.1a3752	a9 03		lda #$03	sdma_2d_only    LDA #SDMA_CTRL0_Enable | SDMA_CTRL0_1D_2D
.1a3754	8f 20 04 af	sta $af0420	sdma_set_ctrl   STA @l SDMA_CTRL_REG0
.1a3758	82 7d 00	brl $1a37d8	                BRL trig_sdma               ; And trigger the SDMA
.1a375b					start_vdma_only
.1a375b	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.1a375f	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.1a3761	f0 23		beq $1a3786	                BEQ vdma_1d_only            ; Source and Destination 1D...
.1a3763	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.1a3765	f0 23		beq $1a378a	                BEQ vdma_2d_only            ; Source and Destination 2D...
.1a3767	08		php		            PHP
.1a3768	c2 20		rep #$20	            REP #$20
.1a376a	48		pha		            PHA
.1a376b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a376e	5b		tcd		            TCD
.1a376f	68		pla		            PLA
.1a3770	28		plp		            PLP
.1a3771	e2 20		sep #$20	            SEP #$20
.1a3773	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a3775	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3779	c2 20		rep #$20	            REP #$20
.1a377b	29 ff 00	and #$00ff	            AND #$00FF
.1a377e	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3781	e2 20		sep #$20	            SEP #$20
.1a3783	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3786	a9 01		lda #$01	vdma_1d_only    LDA #VDMA_CTRL_Enable       ; Set the bits for 1D, VRAM->VRAM
.1a3788	80 02		bra $1a378c	                BRA vdma_set_ctrl
.1a378a	a9 03		lda #$03	vdma_2d_only    LDA #VDMA_CTRL_Enable | VDMA_CTRL_1D_2D
.1a378c	8f 00 04 af	sta $af0400	vdma_set_ctrl   STA @l VDMA_CONTROL_REG
.1a3790	80 34		bra $1a37c6	                BRA trig_vdma               ; And trigger the VDMA
.1a3792					start_s2v
.1a3792	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.1a3796	29 01		and #$01	                AND #DMA_SRC_2D
.1a3798	0a		asl a		                ASL A
.1a3799	09 11		ora #$11	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Src
.1a379b	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a379f	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.1a37a3	29 02		and #$02	                AND #DMA_DST_2D
.1a37a5	09 11		ora #$11	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Src
.1a37a7	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a37ab	80 19		bra $1a37c6	                BRA trig_vdma               ; And trigger the VDMA
.1a37ad					start_v2s
.1a37ad	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.1a37b1	29 02		and #$02	                AND #DMA_DST_2D
.1a37b3	09 21		ora #$21	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Dst
.1a37b5	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a37b9	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.1a37bd	29 01		and #$01	                AND #DMA_SRC_2D
.1a37bf	0a		asl a		                ASL A
.1a37c0	09 21		ora #$21	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Dst
.1a37c2	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a37c6					trig_vdma
.1a37c6	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.1a37ca	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF    ; Trigger the VDMA
.1a37cc	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a37d0	af 58 f0 1a	lda $1af058	                LDA @l DMA_BLOCKS           ; Check if we need SDMA
.1a37d4	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.1a37d6	f0 0f		beq $1a37e7	                BEQ wait_vdma               ; No: wait for VDMA to complete
.1a37d8					trig_sdma
.1a37d8	af 20 04 af	lda $af0420	                LDA @l SDMA_CTRL_REG0
.1a37dc	09 80		ora #$80	                ORA #SDMA_CTRL0_Start_TRF   ; Trigger the SDMA
.1a37de	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a37e2	ea		nop		                NOP                         ; When the transfer is started the CPU will be put on Hold (RDYn)...
.1a37e3	ea		nop		                NOP                         ; Before it actually gets to stop it will execute a couple more instructions
.1a37e4	ea		nop		                NOP                         ; From that point on, the CPU is halted (keep that in mind)
.1a37e5	ea		nop		                NOP                         ; No IRQ will be processed either during that time
.1a37e6	ea		nop		                NOP
.1a37e7	af 01 04 af	lda $af0401	wait_vdma       LDA @l VDMA_STATUS_REG      ; Check the VDMA status
.1a37eb	89 80		bit #$80	                BIT #VDMA_STAT_VDMA_IPS     ; If the transfer is still in process...
.1a37ed	d0 f8		bne $1a37e7	                BNE wait_vdma               ; Wait until it stops.
.1a37ef	a9 00		lda #$00	                LDA #$00                    ; Clear the TRF bits
.1a37f1	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.1a37f5	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.1a37f9	28		plp		                PLP
.1a37fa	2b		pld		                PLD
.1a37fb	60		rts		            RTS
.1a37fc					S_MEMCOPY
.1a37fc	0b		phd		                PHD
.1a37fd	08		php		                PHP
.1a37fe	e2 20		sep #$20	            SEP #$20
.1a3800	c2 10		rep #$10	            REP #$10
.1a3802	a9 00		lda #$00	                LDA #0
.1a3804	a2 00 00	ldx #$0000	                LDX #0
.1a3807	8f 59 f0 1a	sta $1af059	clr_loop        STA @l DMA_SRC
.1a380b	e8		inx		                INX
.1a380c	e0 1a 00	cpx #$001a	                CPX #SIZE(DMA_BLOCK) * 2
.1a380f	d0 f6		bne $1a3807	                BNE clr_loop
.1a3811	20 bf 20	jsr $1a20bf	            JSR PEEK_TOK
.1a3814	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.1a3816	f0 23		beq $1a383b	                BEQ src_linear                      ; Yes: go to process a linear source
.1a3818	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.1a381a	f0 5e		beq $1a387a	                BEQ src_rect                        ; Yes: go to process a rectangular source
.1a381c					syntax_err
.1a381c	08		php		            PHP
.1a381d	c2 20		rep #$20	            REP #$20
.1a381f	48		pha		            PHA
.1a3820	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3823	5b		tcd		            TCD
.1a3824	68		pla		            PLA
.1a3825	28		plp		            PLP
.1a3826	e2 20		sep #$20	            SEP #$20
.1a3828	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a382a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a382e	c2 20		rep #$20	            REP #$20
.1a3830	29 ff 00	and #$00ff	            AND #$00FF
.1a3833	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3836	e2 20		sep #$20	            SEP #$20
.1a3838	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a383b					src_linear
.1a383b	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a383e	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3841	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a3844	c2 20		rep #$20	            REP #$20
.1a3846	a5 23		lda $0823	            LDA ARGUMENT1
.1a3848	8f 5a f0 1a	sta $1af05a	            STA DMA_SRC.ADDR
.1a384c	e2 20		sep #$20	            SEP #$20
.1a384e	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3850	8f 5c f0 1a	sta $1af05c	            STA DMA_SRC.ADDR+2
.1a3854	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a3856	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a3859	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a385c	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a385f	c2 20		rep #$20	            REP #$20
.1a3861	a5 23		lda $0823	            LDA ARGUMENT1
.1a3863	8f 5d f0 1a	sta $1af05d	            STA DMA_SRC.SIZE
.1a3867	e2 20		sep #$20	            SEP #$20
.1a3869	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a386b	8f 5f f0 1a	sta $1af05f	            STA DMA_SRC.SIZE+2
.1a386f	e2 20		sep #$20	            SEP #$20
.1a3871	a9 00		lda #$00	            LDA #<DMA_LINEAR
.1a3873	8f 59 f0 1a	sta $1af059	            STA DMA_SRC.MODE
.1a3877	82 74 00	brl $1a38ee	                BRL process_to
.1a387a					src_rect
.1a387a	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a387d	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3880	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a3883	c2 20		rep #$20	            REP #$20
.1a3885	a5 23		lda $0823	            LDA ARGUMENT1
.1a3887	8f 5a f0 1a	sta $1af05a	            STA DMA_SRC.ADDR
.1a388b	e2 20		sep #$20	            SEP #$20
.1a388d	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a388f	8f 5c f0 1a	sta $1af05c	            STA DMA_SRC.ADDR+2
.1a3893	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a3895	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a3898	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a389b	20 bf 05	jsr $1a05bf	            JSR ASS_ARG1_INT16
.1a389e	c2 20		rep #$20	            REP #$20
.1a38a0	a5 23		lda $0823	            LDA ARGUMENT1
.1a38a2	8f 60 f0 1a	sta $1af060	            STA DMA_SRC.WIDTH
.1a38a6	8d 00 01	sta $0100	            STA M0_OPERAND_A
.1a38a9	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a38ac	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a38af	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a38b2	20 bf 05	jsr $1a05bf	            JSR ASS_ARG1_INT16
.1a38b5	c2 20		rep #$20	            REP #$20
.1a38b7	a5 23		lda $0823	            LDA ARGUMENT1
.1a38b9	8f 62 f0 1a	sta $1af062	            STA DMA_SRC.HEIGHT
.1a38bd	8d 02 01	sta $0102	            STA M0_OPERAND_B
.1a38c0	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a38c3	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a38c6	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a38c9	20 bf 05	jsr $1a05bf	            JSR ASS_ARG1_INT16
.1a38cc	c2 20		rep #$20	            REP #$20
.1a38ce	a5 23		lda $0823	            LDA ARGUMENT1
.1a38d0	8f 64 f0 1a	sta $1af064	            STA DMA_SRC.STRIDE
.1a38d4	c2 20		rep #$20	            REP #$20
.1a38d6	ad 04 01	lda $0104	            LDA M0_RESULT
.1a38d9	8f 5d f0 1a	sta $1af05d	            STA DMA_SRC.SIZE
.1a38dd	e2 20		sep #$20	            SEP #$20
.1a38df	ad 06 01	lda $0106	            LDA M0_RESULT+2
.1a38e2	8f 5f f0 1a	sta $1af05f	            STA DMA_SRC.SIZE+2
.1a38e6	e2 20		sep #$20	            SEP #$20
.1a38e8	a9 01		lda #$01	            LDA #<DMA_RECT
.1a38ea	8f 59 f0 1a	sta $1af059	            STA DMA_SRC.MODE
.1a38ee					process_to
.1a38ee	e2 20		sep #$20	            SEP #$20
.1a38f0	a9 9c		lda #$9c	                LDA #TOK_TO
.1a38f2	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a38f5	20 bf 20	jsr $1a20bf	            JSR PEEK_TOK
.1a38f8	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.1a38fa	f0 23		beq $1a391f	                BEQ dest_linear                     ; Yes: go to process a linear destination
.1a38fc	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.1a38fe	f0 5e		beq $1a395e	                BEQ dest_rect                       ; Yes: go to process a rectangular source
.1a3900					syntax_err2
.1a3900	08		php		            PHP
.1a3901	c2 20		rep #$20	            REP #$20
.1a3903	48		pha		            PHA
.1a3904	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3907	5b		tcd		            TCD
.1a3908	68		pla		            PLA
.1a3909	28		plp		            PLP
.1a390a	e2 20		sep #$20	            SEP #$20
.1a390c	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a390e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3912	c2 20		rep #$20	            REP #$20
.1a3914	29 ff 00	and #$00ff	            AND #$00FF
.1a3917	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a391a	e2 20		sep #$20	            SEP #$20
.1a391c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a391f					dest_linear
.1a391f	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a3922	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3925	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a3928	c2 20		rep #$20	            REP #$20
.1a392a	a5 23		lda $0823	            LDA ARGUMENT1
.1a392c	8f 67 f0 1a	sta $1af067	            STA DMA_DEST.ADDR
.1a3930	e2 20		sep #$20	            SEP #$20
.1a3932	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3934	8f 69 f0 1a	sta $1af069	            STA DMA_DEST.ADDR+2
.1a3938	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a393a	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a393d	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3940	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a3943	c2 20		rep #$20	            REP #$20
.1a3945	a5 23		lda $0823	            LDA ARGUMENT1
.1a3947	8f 6a f0 1a	sta $1af06a	            STA DMA_DEST.SIZE
.1a394b	e2 20		sep #$20	            SEP #$20
.1a394d	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a394f	8f 6c f0 1a	sta $1af06c	            STA DMA_DEST.SIZE+2
.1a3953	e2 20		sep #$20	            SEP #$20
.1a3955	a9 00		lda #$00	            LDA #<DMA_LINEAR
.1a3957	8f 66 f0 1a	sta $1af066	            STA DMA_DEST.MODE
.1a395b	82 74 00	brl $1a39d2	                BRL verify
.1a395e					dest_rect
.1a395e	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a3961	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3964	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a3967	c2 20		rep #$20	            REP #$20
.1a3969	a5 23		lda $0823	            LDA ARGUMENT1
.1a396b	8f 67 f0 1a	sta $1af067	            STA DMA_DEST.ADDR
.1a396f	e2 20		sep #$20	            SEP #$20
.1a3971	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a3973	8f 69 f0 1a	sta $1af069	            STA DMA_DEST.ADDR+2
.1a3977	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.1a3979	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a397c	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a397f	20 bf 05	jsr $1a05bf	            JSR ASS_ARG1_INT16
.1a3982	c2 20		rep #$20	            REP #$20
.1a3984	a5 23		lda $0823	            LDA ARGUMENT1
.1a3986	8f 6d f0 1a	sta $1af06d	            STA DMA_DEST.WIDTH
.1a398a	8d 00 01	sta $0100	            STA M0_OPERAND_A
.1a398d	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a3990	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a3993	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3996	20 bf 05	jsr $1a05bf	            JSR ASS_ARG1_INT16
.1a3999	c2 20		rep #$20	            REP #$20
.1a399b	a5 23		lda $0823	            LDA ARGUMENT1
.1a399d	8f 6f f0 1a	sta $1af06f	            STA DMA_DEST.HEIGHT
.1a39a1	8d 02 01	sta $0102	            STA M0_OPERAND_B
.1a39a4	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.1a39a7	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a39aa	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a39ad	20 bf 05	jsr $1a05bf	            JSR ASS_ARG1_INT16
.1a39b0	c2 20		rep #$20	            REP #$20
.1a39b2	a5 23		lda $0823	            LDA ARGUMENT1
.1a39b4	8f 71 f0 1a	sta $1af071	            STA DMA_DEST.STRIDE
.1a39b8	c2 20		rep #$20	            REP #$20
.1a39ba	ad 04 01	lda $0104	            LDA M0_RESULT
.1a39bd	8f 6a f0 1a	sta $1af06a	            STA DMA_DEST.SIZE
.1a39c1	e2 20		sep #$20	            SEP #$20
.1a39c3	ad 06 01	lda $0106	            LDA M0_RESULT+2
.1a39c6	8f 6c f0 1a	sta $1af06c	            STA DMA_DEST.SIZE+2
.1a39ca	e2 20		sep #$20	            SEP #$20
.1a39cc	a9 01		lda #$01	            LDA #<DMA_RECT
.1a39ce	8f 66 f0 1a	sta $1af066	            STA DMA_DEST.MODE
.1a39d2					verify
.1a39d2	c2 20		rep #$20	            REP #$20
.1a39d4	af 5d f0 1a	lda $1af05d	                LDA @l DMA_SRC.SIZE
.1a39d8	cf 6a f0 1a	cmp $1af06a	                CMP @l DMA_DEST.SIZE
.1a39dc	d0 14		bne $1a39f2	                BNE size_err
.1a39de	e2 20		sep #$20	            SEP #$20
.1a39e0	af 5f f0 1a	lda $1af05f	                LDA @l DMA_SRC.SIZE+2
.1a39e4	cf 6c f0 1a	cmp $1af06c	                CMP @l DMA_DEST.SIZE+2
.1a39e8	d0 08		bne $1a39f2	                BNE size_err
.1a39ea	c2 20		rep #$20	            REP #$20
.1a39ec	20 1a 35	jsr $1a351a	            JSR DO_DMA
.1a39ef	28		plp		                PLP
.1a39f0	2b		pld		                PLD
.1a39f1	60		rts		            RTS
.1a39f2					size_err
.1a39f2	08		php		            PHP
.1a39f3	c2 20		rep #$20	            REP #$20
.1a39f5	48		pha		            PHA
.1a39f6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a39f9	5b		tcd		            TCD
.1a39fa	68		pla		            PLA
.1a39fb	28		plp		            PLP
.1a39fc	e2 20		sep #$20	            SEP #$20
.1a39fe	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a3a00	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3a04	c2 20		rep #$20	            REP #$20
.1a3a06	29 ff 00	and #$00ff	            AND #$00FF
.1a3a09	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3a0c	e2 20		sep #$20	            SEP #$20
.1a3a0e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3a11					S_LOCATE
.1a3a11	08		php		                PHP
.1a3a12	c2 30		rep #$30	            REP #$30
.1a3a14	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3a17	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a3a1a	a5 23		lda $0823	                LDA ARGUMENT1
.1a3a1c	48		pha		                PHA                         ; Save it for later
.1a3a1d	a9 2c 00	lda #$002c	                LDA #','                    ; Check for the comma separator
.1a3a20	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a3a23	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3a26	20 15 06	jsr $1a0615	            JSR ASS_ARG1_BYTE
.1a3a29	a4 23		ldy $0823	                LDY ARGUMENT1               ; Set Y to the row
.1a3a2b	fa		plx		                PLX                         ; Set X to the column
.1a3a2c	20 20 00	jsr $1a0020	            JSR CURSORXY
.1a3a2f	28		plp		                PLP
.1a3a30	60		rts		            RTS

;******  Return to file: src\statements.s

.1a3a31					S_INPUT
.1a3a31	08		php		                PHP
.1a3a32					varloop
.1a3a32	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a3a35	e2 20		sep #$20	            SEP #$20
.1a3a37	a7 00		lda [$0800]	                LDA [BIP]
.1a3a39	d0 03		bne $1a3a3e	                BNE check_colon
.1a3a3b	4c d9 3a	jmp $1a3ad9	                JMP done            ; If EOL, we're done
.1a3a3e	c9 3a		cmp #$3a	check_colon     CMP #':'
.1a3a40	d0 03		bne $1a3a45	                BNE check_string
.1a3a42	4c d9 3a	jmp $1a3ad9	                JMP done            ; If colon, we're done
.1a3a45	c9 22		cmp #$22	check_string    CMP #CHAR_DQUOTE    ; Is it the start of a string?
.1a3a47	d0 0b		bne $1a3a54	                BNE check_var       ; No: then it should be a variable name
.1a3a49	20 59 1a	jsr $1a1a59	            JSR EVALSTRING
.1a3a4c	20 e7 43	jsr $1a43e7	            JSR PR_STRING
.1a3a4f	a9 3b		lda #$3b	                LDA #';'            ; Look for a semicolon
.1a3a51	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a3a54					check_var
.1a3a54	20 94 03	jsr $1a0394	            JSR ISALPHA
.1a3a57	90 44		bcc $1a3a9d	                BCC syntax_err      ; No: it's a syntax error
.1a3a59	20 8d 51	jsr $1a518d	            JSR VAR_FINDNAME
.1a3a5c	90 3f		bcc $1a3a9d	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3a5e	a9 3f		lda #$3f	                LDA #"?"            ; Print a "? " to follow
.1a3a60	20 18 00	jsr $1a0018	            JSR PRINTC
.1a3a63	a9 20		lda #$20	                LDA #CHAR_SP
.1a3a65	20 18 00	jsr $1a0018	            JSR PRINTC
.1a3a68	20 10 00	jsr $1a0010	            JSR INPUTLINE
.1a3a6b	e2 20		sep #$20	            SEP #$20
.1a3a6d	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Check the type of the variable
.1a3a6f	c9 02		cmp #$02	                CMP #TYPE_STRING    ; If it's a string...
.1a3a71	f0 49		beq $1a3abc	                BEQ in_string       ; ... go to copy the string data
.1a3a73	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; If it's an integer...
.1a3a75	d0 03		bne $1a3a7a	                BNE chk_float
.1a3a77	82 84 00	brl $1a3afe	                BRL in_integer      ; ... go to parse the integer
.1a3a7a	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT     ; If it's a float...
.1a3a7c	f0 5d		beq $1a3adb	                BEQ in_float        ; ... go to parse the float
.1a3a7e	08		php		            PHP
.1a3a7f	c2 20		rep #$20	            REP #$20
.1a3a81	48		pha		            PHA
.1a3a82	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3a85	5b		tcd		            TCD
.1a3a86	68		pla		            PLA
.1a3a87	28		plp		            PLP
.1a3a88	e2 20		sep #$20	            SEP #$20
.1a3a8a	a9 04		lda #$04	            LDA #ERR_TYPE
.1a3a8c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3a90	c2 20		rep #$20	            REP #$20
.1a3a92	29 ff 00	and #$00ff	            AND #$00FF
.1a3a95	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3a98	e2 20		sep #$20	            SEP #$20
.1a3a9a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3a9d					syntax_err
.1a3a9d	08		php		            PHP
.1a3a9e	c2 20		rep #$20	            REP #$20
.1a3aa0	48		pha		            PHA
.1a3aa1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3aa4	5b		tcd		            TCD
.1a3aa5	68		pla		            PLA
.1a3aa6	28		plp		            PLP
.1a3aa7	e2 20		sep #$20	            SEP #$20
.1a3aa9	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3aab	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3aaf	c2 20		rep #$20	            REP #$20
.1a3ab1	29 ff 00	and #$00ff	            AND #$00FF
.1a3ab4	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3ab7	e2 20		sep #$20	            SEP #$20
.1a3ab9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3abc					in_string
.1a3abc	c2 20		rep #$20	            REP #$20
.1a3abe	a9 00 4c	lda #$4c00	                LDA #<>IOBUF
.1a3ac1	85 23		sta $0823	                STA ARGUMENT1
.1a3ac3	a9 00 00	lda #$0000	                LDA #`IOBUF
.1a3ac6	85 25		sta $0825	                STA ARGUMENT1+2
.1a3ac8	e2 20		sep #$20	            SEP #$20
.1a3aca	a9 02		lda #$02	                LDA #TYPE_STRING
.1a3acc	85 27		sta $0827	                STA ARGTYPE1
.1a3ace					save_input
.1a3ace	c2 20		rep #$20	            REP #$20
.1a3ad0	20 f0 50	jsr $1a50f0	            JSR VAR_SET
.1a3ad3	a9 0d 00	lda #$000d	                LDA #CHAR_CR        ; Print a newline
.1a3ad6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a3ad9	28		plp		done            PLP
.1a3ada	60		rts		            RTS
.1a3adb					in_float
.1a3adb	c2 20		rep #$20	            REP #$20
.1a3add	a5 00		lda $0800	                LDA BIP             ; Save the BIP for later use
.1a3adf	85 40		sta $0840	                STA SAVEBIP
.1a3ae1	a5 02		lda $0802	                LDA BIP+2
.1a3ae3	85 42		sta $0842	                STA SAVEBIP+2
.1a3ae5	a9 00 4c	lda #$4c00	                LDA #<>IOBUF        ; Point to the line that was just input
.1a3ae8	85 00		sta $0800	                STA BIP
.1a3aea	a9 00 00	lda #$0000	                LDA #`IOBUF
.1a3aed	85 02		sta $0802	                STA BIP+2
.1a3aef	20 af 57	jsr $1a57af	            JSR PARSENUM
.1a3af2	c2 20		rep #$20	            REP #$20
.1a3af4	a5 40		lda $0840	                LDA SAVEBIP         ; Restore the BIP
.1a3af6	85 00		sta $0800	                STA BIP
.1a3af8	a5 42		lda $0842	                LDA SAVEBIP+2
.1a3afa	85 02		sta $0802	                STA BIP+2
.1a3afc	80 d0		bra $1a3ace	                BRA save_input
.1a3afe					in_integer
.1a3afe	c2 20		rep #$20	            REP #$20
.1a3b00	a5 00		lda $0800	                LDA BIP             ; Save the BIP for later use
.1a3b02	85 40		sta $0840	                STA SAVEBIP
.1a3b04	a5 02		lda $0802	                LDA BIP+2
.1a3b06	85 42		sta $0842	                STA SAVEBIP+2
.1a3b08	a9 00 4c	lda #$4c00	                LDA #<>IOBUF        ; Point to the line that was just input
.1a3b0b	85 00		sta $0800	                STA BIP
.1a3b0d	a9 00 00	lda #$0000	                LDA #`IOBUF
.1a3b10	85 02		sta $0802	                STA BIP+2
.1a3b12	20 8a 07	jsr $1a078a	            JSR PARSEINT
.1a3b15	c2 20		rep #$20	            REP #$20
.1a3b17	a5 40		lda $0840	                LDA SAVEBIP         ; Restore the BIP
.1a3b19	85 00		sta $0800	                STA BIP
.1a3b1b	a5 42		lda $0842	                LDA SAVEBIP+2
.1a3b1d	85 02		sta $0802	                STA BIP+2
.1a3b1f	80 ad		bra $1a3ace	                BRA save_input
.1a3b21					S_GET
.1a3b21	08		php		                PHP
.1a3b22					varloop
.1a3b22	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a3b25	e2 20		sep #$20	            SEP #$20
.1a3b27	a7 00		lda [$0800]	                LDA [BIP]
.1a3b29	f0 47		beq $1a3b72	                BEQ done            ; If EOL, we're done
.1a3b2b	c9 3a		cmp #$3a	                CMP #':'
.1a3b2d	f0 43		beq $1a3b72	                BEQ done            ; If colon, we're done
.1a3b2f	20 94 03	jsr $1a0394	            JSR ISALPHA
.1a3b32	90 40		bcc $1a3b74	                BCC syntax_err      ; No: it's a syntax error
.1a3b34	20 8d 51	jsr $1a518d	            JSR VAR_FINDNAME
.1a3b37	90 3b		bcc $1a3b74	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3b39	20 ae 13	jsr $1a13ae	            JSR TEMPSTRING
.1a3b3c	20 14 00	jsr $1a0014	            JSR GETKEY
.1a3b3f	e2 20		sep #$20	            SEP #$20
.1a3b41	a0 00 00	ldy #$0000	                LDY #0
.1a3b44	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a3b46	a9 00		lda #$00	                LDA #0
.1a3b48	c8		iny		                INY
.1a3b49	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a3b4b	c2 20		rep #$20	            REP #$20
.1a3b4d	a5 16		lda $0816	                LDA STRPTR
.1a3b4f	85 23		sta $0823	                STA ARGUMENT1
.1a3b51	a5 18		lda $0818	                LDA STRPTR+2
.1a3b53	85 25		sta $0825	                STA ARGUMENT1+2
.1a3b55	e2 20		sep #$20	            SEP #$20
.1a3b57	a9 02		lda #$02	                LDA #TYPE_STRING
.1a3b59	85 27		sta $0827	                STA ARGTYPE1
.1a3b5b	20 f0 50	jsr $1a50f0	            JSR VAR_SET
.1a3b5e	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a3b61	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.1a3b63	f0 0d		beq $1a3b72	                BEQ done            ; EOL? We're done
.1a3b65	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.1a3b67	f0 09		beq $1a3b72	                BEQ done
.1a3b69	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.1a3b6b	d0 07		bne $1a3b74	                BNE syntax_err      ; Nope: syntax error
.1a3b6d	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a3b70	80 b0		bra $1a3b22	                BRA varloop
.1a3b72	28		plp		done            PLP
.1a3b73	60		rts		            RTS
.1a3b74					syntax_err
.1a3b74	08		php		            PHP
.1a3b75	c2 20		rep #$20	            REP #$20
.1a3b77	48		pha		            PHA
.1a3b78	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3b7b	5b		tcd		            TCD
.1a3b7c	68		pla		            PLA
.1a3b7d	28		plp		            PLP
.1a3b7e	e2 20		sep #$20	            SEP #$20
.1a3b80	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3b82	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3b86	c2 20		rep #$20	            REP #$20
.1a3b88	29 ff 00	and #$00ff	            AND #$00FF
.1a3b8b	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3b8e	e2 20		sep #$20	            SEP #$20
.1a3b90	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3b93					S_CALL
.1a3b93	08		php		                PHP
.1a3b94	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3b97	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a3b9a	e2 20		sep #$20	            SEP #$20
.1a3b9c	a9 5c		lda #$5c	                LDA #$5C            ; Set the opcode for JML
.1a3b9e	85 a2		sta $08a2	                STA MJUMPINST
.1a3ba0	c2 20		rep #$20	            REP #$20
.1a3ba2	a5 23		lda $0823	                LDA ARGUMENT1
.1a3ba4	85 a3		sta $08a3	                STA MJUMPADDR
.1a3ba6	e2 20		sep #$20	            SEP #$20
.1a3ba8	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3baa	85 a5		sta $08a5	                STA MJUMPADDR+2
.1a3bac	e2 20		sep #$20	            SEP #$20
.1a3bae	a9 2c		lda #$2c	                LDA #','
.1a3bb0	85 37		sta $0837	                STA TARGETTOK
.1a3bb2	20 a0 20	jsr $1a20a0	            JSR OPT_TOK
.1a3bb5	90 41		bcc $1a3bf8	                BCC launch          ; Not present... go ahead and launch
.1a3bb7	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a3bba	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3bbd	20 bf 05	jsr $1a05bf	            JSR ASS_ARG1_INT16
.1a3bc0	c2 20		rep #$20	            REP #$20
.1a3bc2	a5 23		lda $0823	                LDA ARGUMENT1
.1a3bc4	85 55		sta $0855	                STA MARG1           ; Save it to MARG1
.1a3bc6	e2 20		sep #$20	            SEP #$20
.1a3bc8	a9 2c		lda #$2c	                LDA #','
.1a3bca	85 37		sta $0837	                STA TARGETTOK
.1a3bcc	20 a0 20	jsr $1a20a0	            JSR OPT_TOK
.1a3bcf	90 27		bcc $1a3bf8	                BCC launch          ; Not present... go ahead and launch
.1a3bd1	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a3bd4	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3bd7	20 bf 05	jsr $1a05bf	            JSR ASS_ARG1_INT16
.1a3bda	c2 20		rep #$20	            REP #$20
.1a3bdc	a5 23		lda $0823	                LDA ARGUMENT1
.1a3bde	85 59		sta $0859	                STA MARG2           ; Save it to MARG2
.1a3be0	e2 20		sep #$20	            SEP #$20
.1a3be2	a9 2c		lda #$2c	                LDA #','
.1a3be4	85 37		sta $0837	                STA TARGETTOK
.1a3be6	20 a0 20	jsr $1a20a0	            JSR OPT_TOK
.1a3be9	90 0d		bcc $1a3bf8	                BCC launch          ; Not present... go ahead and launch
.1a3beb	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a3bee	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3bf1	20 bf 05	jsr $1a05bf	            JSR ASS_ARG1_INT16
.1a3bf4	c2 20		rep #$20	            REP #$20
.1a3bf6	a4 23		ldy $0823	                LDY ARGUMENT1
.1a3bf8	a6 59		ldx $0859	launch          LDX MARG2
.1a3bfa	a5 55		lda $0855	                LDA MARG1
.1a3bfc	0b		phd		                PHD
.1a3bfd	8b		phb		                PHB
.1a3bfe	08		php		                PHP
.1a3bff	22 a2 08 00	jsl $0008a2	                JSL MJUMPINST       ; Call the subroutine indicated
.1a3c03	28		plp		                PLP
.1a3c04	ab		plb		                PLB
.1a3c05	2b		pld		                PLD
.1a3c06	20 a3 1f	jsr $1a1fa3	            JSR SKIPSTMT
.1a3c09	28		plp		                PLP
.1a3c0a	60		rts		            RTS
.1a3c0b					type_err
.1a3c0b	08		php		            PHP
.1a3c0c	c2 20		rep #$20	            REP #$20
.1a3c0e	48		pha		            PHA
.1a3c0f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3c12	5b		tcd		            TCD
.1a3c13	68		pla		            PLA
.1a3c14	28		plp		            PLP
.1a3c15	e2 20		sep #$20	            SEP #$20
.1a3c17	a9 04		lda #$04	            LDA #ERR_TYPE
.1a3c19	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3c1d	c2 20		rep #$20	            REP #$20
.1a3c1f	29 ff 00	and #$00ff	            AND #$00FF
.1a3c22	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3c25	e2 20		sep #$20	            SEP #$20
.1a3c27	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3c2a					S_DIM
.1a3c2a	08		php		                PHP
.1a3c2b	e2 20		sep #$20	            SEP #$20
.1a3c2d	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a3c30	20 8d 51	jsr $1a518d	            JSR VAR_FINDNAME
.1a3c33	90 64		bcc $1a3c99	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3c35	a9 8f		lda #$8f	                LDA #TOK_LPAREN     ; Verify we have a left parenthesis
.1a3c37	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a3c3a	a9 01		lda #$01	                LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.1a3c3c	20 ac 18	jsr $1a18ac	            JSR PHOPERATOR
.1a3c3f	a2 01 00	ldx #$0001	                LDX #1
.1a3c42	a9 00		lda #$00	                LDA #0
.1a3c44	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF     ; Set the dimension count to 0
.1a3c48					dim_loop
.1a3c48	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3c4b	20 bf 05	jsr $1a05bf	            JSR ASS_ARG1_INT16
.1a3c4e	c2 20		rep #$20	            REP #$20
.1a3c50	a5 23		lda $0823	                LDA ARGUMENT1
.1a3c52	9f 00 4d 00	sta $004d00,x	                STA @lARRIDXBUF,X   ; And store it in the buffer
.1a3c56	e2 20		sep #$20	            SEP #$20
.1a3c58	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF     ; Add to the dimension count
.1a3c5c	1a		inc a		                INC A
.1a3c5d	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF
.1a3c61	30 55		bmi $1a3cb8	                BMI overflow        ; If > 127 throw an error
.1a3c63	e8		inx		                INX
.1a3c64	e8		inx		                INX
.1a3c65	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a3c68	a7 00		lda [$0800]	                LDA [BIP]           ; Check the character
.1a3c6a	c9 2c		cmp #$2c	                CMP #','            ; Is it a comma?
.1a3c6c	f0 25		beq $1a3c93	                BEQ skip_comma      ; Yes: get the next dimension
.1a3c6e	c9 90		cmp #$90	                CMP #TOK_RPAREN     ; No: is it a ")"?
.1a3c70	d0 27		bne $1a3c99	                BNE syntax_err      ; No: throw a syntax error
.1a3c72	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a3c75	20 0b 64	jsr $1a640b	            JSR ARR_ALLOC
.1a3c78	c2 20		rep #$20	            REP #$20
.1a3c7a	a5 c0		lda $08c0	                LDA CURRBLOCK       ; Set up the pointer to the array
.1a3c7c	85 23		sta $0823	                STA ARGUMENT1
.1a3c7e	e2 20		sep #$20	            SEP #$20
.1a3c80	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a3c82	85 25		sta $0825	                STA ARGUMENT1+2
.1a3c84	64 26		stz $0826	                STZ ARGUMENT1+3
.1a3c86	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Get the type of the values
.1a3c88	09 80		ora #$80	                ORA #$80            ; Make sure we change the type to array
.1a3c8a	85 ea		sta $08ea	                STA TOFINDTYPE      ; And save it back for searching
.1a3c8c	85 27		sta $0827	                STA ARGTYPE1        ; And for the value to set
.1a3c8e	20 f0 50	jsr $1a50f0	            JSR VAR_SET
.1a3c91	28		plp		                PLP
.1a3c92	60		rts		            RTS
.1a3c93					skip_comma
.1a3c93	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a3c96	4c 48 3c	jmp $1a3c48	                JMP dim_loop
.1a3c99					syntax_err
.1a3c99	08		php		            PHP
.1a3c9a	c2 20		rep #$20	            REP #$20
.1a3c9c	48		pha		            PHA
.1a3c9d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3ca0	5b		tcd		            TCD
.1a3ca1	68		pla		            PLA
.1a3ca2	28		plp		            PLP
.1a3ca3	e2 20		sep #$20	            SEP #$20
.1a3ca5	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3ca7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3cab	c2 20		rep #$20	            REP #$20
.1a3cad	29 ff 00	and #$00ff	            AND #$00FF
.1a3cb0	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3cb3	e2 20		sep #$20	            SEP #$20
.1a3cb5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3cb8					overflow
.1a3cb8	08		php		            PHP
.1a3cb9	c2 20		rep #$20	            REP #$20
.1a3cbb	48		pha		            PHA
.1a3cbc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3cbf	5b		tcd		            TCD
.1a3cc0	68		pla		            PLA
.1a3cc1	28		plp		            PLP
.1a3cc2	e2 20		sep #$20	            SEP #$20
.1a3cc4	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a3cc6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3cca	c2 20		rep #$20	            REP #$20
.1a3ccc	29 ff 00	and #$00ff	            AND #$00FF
.1a3ccf	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3cd2	e2 20		sep #$20	            SEP #$20
.1a3cd4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3cd7					S_READ
.1a3cd7	08		php		                PHP
.1a3cd8					varloop
.1a3cd8	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a3cdb	e2 20		sep #$20	            SEP #$20
.1a3cdd	a7 00		lda [$0800]	                LDA [BIP]
.1a3cdf	f0 28		beq $1a3d09	                BEQ done            ; If EOL, we're done
.1a3ce1	c9 3a		cmp #$3a	                CMP #':'
.1a3ce3	f0 24		beq $1a3d09	                BEQ done            ; If colon, we're done
.1a3ce5	20 94 03	jsr $1a0394	            JSR ISALPHA
.1a3ce8	90 21		bcc $1a3d0b	                BCC syntax_err      ; No: it's a syntax error
.1a3cea	20 8d 51	jsr $1a518d	            JSR VAR_FINDNAME
.1a3ced	90 1c		bcc $1a3d0b	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.1a3cef	20 2a 3d	jsr $1a3d2a	            JSR NEXTDATA
.1a3cf2	20 f0 50	jsr $1a50f0	            JSR VAR_SET
.1a3cf5	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a3cf8	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.1a3cfa	f0 0d		beq $1a3d09	                BEQ done            ; EOL? We're done
.1a3cfc	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.1a3cfe	f0 09		beq $1a3d09	                BEQ done
.1a3d00	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.1a3d02	d0 07		bne $1a3d0b	                BNE syntax_err      ; Nope: syntax error
.1a3d04	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a3d07	80 cf		bra $1a3cd8	                BRA varloop
.1a3d09	28		plp		done            PLP
.1a3d0a	60		rts		            RTS
.1a3d0b					syntax_err
.1a3d0b	08		php		            PHP
.1a3d0c	c2 20		rep #$20	            REP #$20
.1a3d0e	48		pha		            PHA
.1a3d0f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3d12	5b		tcd		            TCD
.1a3d13	68		pla		            PLA
.1a3d14	28		plp		            PLP
.1a3d15	e2 20		sep #$20	            SEP #$20
.1a3d17	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3d19	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3d1d	c2 20		rep #$20	            REP #$20
.1a3d1f	29 ff 00	and #$00ff	            AND #$00FF
.1a3d22	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3d25	e2 20		sep #$20	            SEP #$20
.1a3d27	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3d2a					NEXTDATA
.1a3d2a	08		php		                PHP
.1a3d2b	a5 02		lda $0802	                LDA BIP+2           ; Save BIP
.1a3d2d	85 42		sta $0842	                STA SAVEBIP+2
.1a3d2f	a5 00		lda $0800	                LDA BIP
.1a3d31	85 40		sta $0840	                STA SAVEBIP
.1a3d33	a5 1c		lda $081c	                LDA CURLINE+2       ; Save CURLINE
.1a3d35	85 46		sta $0846	                STA SAVELINE+2
.1a3d37	a5 1a		lda $081a	                LDA CURLINE
.1a3d39	85 44		sta $0844	                STA SAVELINE
.1a3d3b	c2 20		rep #$20	            REP #$20
.1a3d3d	a5 3a		lda $083a	                LDA DATABIP+2
.1a3d3f	d0 04		bne $1a3d45	                BNE data_set
.1a3d41	a5 38		lda $0838	                LDA DATABIP
.1a3d43	f0 4e		beq $1a3d93	                BEQ scan_start      ; No: scan for a DATA statement
.1a3d45	a5 38		lda $0838	data_set        LDA DATABIP         ; Move BIP to the DATA statement
.1a3d47	85 00		sta $0800	                STA BIP
.1a3d49	a5 3a		lda $083a	                LDA DATABIP+2
.1a3d4b	85 02		sta $0802	                STA BIP+2
.1a3d4d	a5 3c		lda $083c	                LDA DATALINE        ; Set CURLINE from DATALINE
.1a3d4f	85 1a		sta $081a	                STA CURLINE
.1a3d51	a5 3e		lda $083e	                LDA DATALINE+2
.1a3d53	85 1c		sta $081c	                STA CURLINE+2
.1a3d55	e2 20		sep #$20	            SEP #$20
.1a3d57	a7 00		lda [$0800]	                LDA [BIP]           ; Check character at BIP
.1a3d59	f0 53		beq $1a3dae	                BEQ scan_DATA       ; EOL? scan for a DATA statement
.1a3d5b	c9 3a		cmp #$3a	                CMP #':'            ; Colon?
.1a3d5d	f0 4f		beq $1a3dae	                BEQ scan_DATA       ; ... scan for a DATA statement
.1a3d5f	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.1a3d61	d0 03		bne $1a3d66	                BNE skip_parse      ; No: skip leading WS and try to parse
.1a3d63	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a3d66					skip_parse
.1a3d66	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a3d69	a7 00		lda [$0800]	                LDA [BIP]
.1a3d6b	c9 22		cmp #$22	                CMP #CHAR_DQUOTE    ; Is it a quote?
.1a3d6d	f0 4e		beq $1a3dbd	                BEQ read_string     ; Yes: process the string
.1a3d6f	20 ad 03	jsr $1a03ad	            JSR ISNUMERAL
.1a3d72	b0 4e		bcs $1a3dc2	                BCS read_number     ; Yes: process the number
.1a3d74					syntax_err
.1a3d74	08		php		            PHP
.1a3d75	c2 20		rep #$20	            REP #$20
.1a3d77	48		pha		            PHA
.1a3d78	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3d7b	5b		tcd		            TCD
.1a3d7c	68		pla		            PLA
.1a3d7d	28		plp		            PLP
.1a3d7e	e2 20		sep #$20	            SEP #$20
.1a3d80	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3d82	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3d86	c2 20		rep #$20	            REP #$20
.1a3d88	29 ff 00	and #$00ff	            AND #$00FF
.1a3d8b	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3d8e	e2 20		sep #$20	            SEP #$20
.1a3d90	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3d93					scan_start
.1a3d93	c2 20		rep #$20	            REP #$20
.1a3d95	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT    ; Point CURLINE to the first line
.1a3d98	85 1a		sta $081a	                STA CURLINE
.1a3d9a	a9 16 00	lda #$0016	                LDA #`BASIC_BOT
.1a3d9d	85 1c		sta $081c	                STA CURLINE+2
.1a3d9f	18		clc		                CLC
.1a3da0	a5 1a		lda $081a	                LDA CURLINE         ; Point BIP to the first possible token
.1a3da2	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.1a3da5	85 00		sta $0800	                STA BIP
.1a3da7	a5 1c		lda $081c	                LDA CURLINE+2
.1a3da9	69 00 00	adc #$0000	                ADC #0
.1a3dac	85 02		sta $0802	                STA BIP+2
.1a3dae					scan_data
.1a3dae	e2 20		sep #$20	            SEP #$20
.1a3db0	a9 80		lda #$80	                LDA #$80            ; We don't want to process nesting
.1a3db2	85 35		sta $0835	                STA SKIPNEST
.1a3db4	a9 ab		lda #$ab	                LDA #TOK_DATA       ; We're looking for a DATA token
.1a3db6	85 37		sta $0837	                STA TARGETTOK
.1a3db8	20 b5 1f	jsr $1a1fb5	            JSR SKIPTOTOK
.1a3dbb	80 a9		bra $1a3d66	                BRA skip_parse
.1a3dbd					read_string
.1a3dbd	20 59 1a	jsr $1a1a59	            JSR EVALSTRING
.1a3dc0	80 03		bra $1a3dc5	                BRA done
.1a3dc2					read_number
.1a3dc2	20 8e 19	jsr $1a198e	            JSR EVALNUMBER
.1a3dc5					done
.1a3dc5	c2 20		rep #$20	            REP #$20
.1a3dc7	a5 00		lda $0800	                LDA BIP             ; Save BIP to DATABIP
.1a3dc9	85 38		sta $0838	                STA DATABIP
.1a3dcb	a5 02		lda $0802	                LDA BIP+2
.1a3dcd	85 3a		sta $083a	                STA DATABIP+2
.1a3dcf	a5 1a		lda $081a	                LDA CURLINE         ; Save CURLINE to DATALINE
.1a3dd1	85 3c		sta $083c	                STA DATALINE
.1a3dd3	a5 1c		lda $081c	                LDA CURLINE+2
.1a3dd5	85 3e		sta $083e	                STA DATALINE+2
.1a3dd7	a5 44		lda $0844	                LDA SAVELINE        ; Restore CURLINE
.1a3dd9	85 1a		sta $081a	                STA CURLINE
.1a3ddb	a5 46		lda $0846	                LDA SAVELINE+2
.1a3ddd	85 1c		sta $081c	                STA CURLINE+2
.1a3ddf	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.1a3de1	85 00		sta $0800	                STA BIP
.1a3de3	a5 42		lda $0842	                LDA SAVEBIP+2
.1a3de5	85 02		sta $0802	                STA BIP+2
.1a3de7	28		plp		                PLP
.1a3de8	60		rts		            RTS
.1a3de9					S_DATA
.1a3de9	20 a3 1f	jsr $1a1fa3	            JSR SKIPSTMT
.1a3dec	60		rts		            RTS
.1a3ded					S_RESTORE
.1a3ded	64 38		stz $0838	                STZ DATABIP         ; Just set DATABIP to 0
.1a3def	64 3a		stz $083a	                STZ DATABIP+2       ; The next READ will move it to the first DATA
.1a3df1	64 3c		stz $083c	                STZ DATALINE        ; Set DATALINE to 0
.1a3df3	64 3e		stz $083e	                STZ DATALINE+2
.1a3df5	60		rts		            RTS
.1a3df6					S_CLS
.1a3df6	20 24 00	jsr $1a0024	            JSR CLSCREEN
.1a3df9	60		rts		            RTS
.1a3dfa					S_POKEL
.1a3dfa	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3dfd	c2 20		rep #$20	            REP #$20
.1a3dff	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.1a3e01	48		pha		                PHA
.1a3e02	a5 23		lda $0823	                LDA ARGUMENT1
.1a3e04	48		pha		                PHA
.1a3e05	e2 20		sep #$20	            SEP #$20
.1a3e07	a7 00		lda [$0800]	                LDA [BIP]
.1a3e09	c9 2c		cmp #$2c	                CMP #','
.1a3e0b	d0 22		bne $1a3e2f	                BNE syntax_err
.1a3e0d	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a3e10	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3e13	c2 20		rep #$20	            REP #$20
.1a3e15	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a3e17	d0 35		bne $1a3e4e	                BNE range_err
.1a3e19	68		pla		                PLA                 ; Pull the target address from the stack
.1a3e1a	85 08		sta $0808	                STA INDEX           ; and into INDEX
.1a3e1c	68		pla		                PLA
.1a3e1d	85 0a		sta $080a	                STA INDEX+2
.1a3e1f	c2 20		rep #$20	            REP #$20
.1a3e21	a5 23		lda $0823	                LDA ARGUMENT1
.1a3e23	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.1a3e25	e2 20		sep #$20	            SEP #$20
.1a3e27	a0 02 00	ldy #$0002	                LDY #2
.1a3e2a	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3e2c	97 08		sta [$0808],y	                STA [INDEX],Y
.1a3e2e	60		rts		            RTS
.1a3e2f					syntax_err
.1a3e2f	08		php		            PHP
.1a3e30	c2 20		rep #$20	            REP #$20
.1a3e32	48		pha		            PHA
.1a3e33	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3e36	5b		tcd		            TCD
.1a3e37	68		pla		            PLA
.1a3e38	28		plp		            PLP
.1a3e39	e2 20		sep #$20	            SEP #$20
.1a3e3b	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3e3d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3e41	c2 20		rep #$20	            REP #$20
.1a3e43	29 ff 00	and #$00ff	            AND #$00FF
.1a3e46	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3e49	e2 20		sep #$20	            SEP #$20
.1a3e4b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3e4e					range_err
.1a3e4e	08		php		            PHP
.1a3e4f	c2 20		rep #$20	            REP #$20
.1a3e51	48		pha		            PHA
.1a3e52	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3e55	5b		tcd		            TCD
.1a3e56	68		pla		            PLA
.1a3e57	28		plp		            PLP
.1a3e58	e2 20		sep #$20	            SEP #$20
.1a3e5a	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3e5c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3e60	c2 20		rep #$20	            REP #$20
.1a3e62	29 ff 00	and #$00ff	            AND #$00FF
.1a3e65	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3e68	e2 20		sep #$20	            SEP #$20
.1a3e6a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3e6d					S_POKEW
.1a3e6d	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3e70	c2 20		rep #$20	            REP #$20
.1a3e72	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.1a3e74	48		pha		                PHA
.1a3e75	a5 23		lda $0823	                LDA ARGUMENT1
.1a3e77	48		pha		                PHA
.1a3e78	e2 20		sep #$20	            SEP #$20
.1a3e7a	a7 00		lda [$0800]	                LDA [BIP]
.1a3e7c	c9 2c		cmp #$2c	                CMP #','
.1a3e7e	d0 19		bne $1a3e99	                BNE syntax_err
.1a3e80	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a3e83	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3e86	c2 20		rep #$20	            REP #$20
.1a3e88	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3e8a	d0 2c		bne $1a3eb8	                BNE range_err
.1a3e8c	68		pla		                PLA                 ; Pull the target address from the stack
.1a3e8d	85 08		sta $0808	                STA INDEX           ; and into INDEX
.1a3e8f	68		pla		                PLA
.1a3e90	85 0a		sta $080a	                STA INDEX+2
.1a3e92	c2 20		rep #$20	            REP #$20
.1a3e94	a5 23		lda $0823	                LDA ARGUMENT1
.1a3e96	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.1a3e98	60		rts		            RTS
.1a3e99					syntax_err
.1a3e99	08		php		            PHP
.1a3e9a	c2 20		rep #$20	            REP #$20
.1a3e9c	48		pha		            PHA
.1a3e9d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3ea0	5b		tcd		            TCD
.1a3ea1	68		pla		            PLA
.1a3ea2	28		plp		            PLP
.1a3ea3	e2 20		sep #$20	            SEP #$20
.1a3ea5	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3ea7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3eab	c2 20		rep #$20	            REP #$20
.1a3ead	29 ff 00	and #$00ff	            AND #$00FF
.1a3eb0	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3eb3	e2 20		sep #$20	            SEP #$20
.1a3eb5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3eb8					range_err
.1a3eb8	08		php		            PHP
.1a3eb9	c2 20		rep #$20	            REP #$20
.1a3ebb	48		pha		            PHA
.1a3ebc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3ebf	5b		tcd		            TCD
.1a3ec0	68		pla		            PLA
.1a3ec1	28		plp		            PLP
.1a3ec2	e2 20		sep #$20	            SEP #$20
.1a3ec4	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3ec6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3eca	c2 20		rep #$20	            REP #$20
.1a3ecc	29 ff 00	and #$00ff	            AND #$00FF
.1a3ecf	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3ed2	e2 20		sep #$20	            SEP #$20
.1a3ed4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3ed7					S_POKE
.1a3ed7	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3eda	c2 20		rep #$20	            REP #$20
.1a3edc	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.1a3ede	48		pha		                PHA
.1a3edf	a5 23		lda $0823	                LDA ARGUMENT1
.1a3ee1	48		pha		                PHA
.1a3ee2	e2 20		sep #$20	            SEP #$20
.1a3ee4	a7 00		lda [$0800]	                LDA [BIP]
.1a3ee6	c9 2c		cmp #$2c	                CMP #','
.1a3ee8	d0 1f		bne $1a3f09	                BNE syntax_err
.1a3eea	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a3eed	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3ef0	e2 20		sep #$20	            SEP #$20
.1a3ef2	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Make sure the value is from 0 - 255
.1a3ef4	d0 32		bne $1a3f28	                BNE range_err
.1a3ef6	c2 20		rep #$20	            REP #$20
.1a3ef8	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a3efa	d0 2c		bne $1a3f28	                BNE range_err
.1a3efc	68		pla		                PLA                 ; Pull the target address from the stack
.1a3efd	85 08		sta $0808	                STA INDEX           ; and into INDEX
.1a3eff	68		pla		                PLA
.1a3f00	85 0a		sta $080a	                STA INDEX+2
.1a3f02	e2 20		sep #$20	            SEP #$20
.1a3f04	a5 23		lda $0823	                LDA ARGUMENT1
.1a3f06	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.1a3f08	60		rts		            RTS
.1a3f09					syntax_err
.1a3f09	08		php		            PHP
.1a3f0a	c2 20		rep #$20	            REP #$20
.1a3f0c	48		pha		            PHA
.1a3f0d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3f10	5b		tcd		            TCD
.1a3f11	68		pla		            PLA
.1a3f12	28		plp		            PLP
.1a3f13	e2 20		sep #$20	            SEP #$20
.1a3f15	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a3f17	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3f1b	c2 20		rep #$20	            REP #$20
.1a3f1d	29 ff 00	and #$00ff	            AND #$00FF
.1a3f20	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3f23	e2 20		sep #$20	            SEP #$20
.1a3f25	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3f28					range_err
.1a3f28	08		php		            PHP
.1a3f29	c2 20		rep #$20	            REP #$20
.1a3f2b	48		pha		            PHA
.1a3f2c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3f2f	5b		tcd		            TCD
.1a3f30	68		pla		            PLA
.1a3f31	28		plp		            PLP
.1a3f32	e2 20		sep #$20	            SEP #$20
.1a3f34	a9 09		lda #$09	            LDA #ERR_RANGE
.1a3f36	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3f3a	c2 20		rep #$20	            REP #$20
.1a3f3c	29 ff 00	and #$00ff	            AND #$00FF
.1a3f3f	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3f42	e2 20		sep #$20	            SEP #$20
.1a3f44	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3f47					S_STOP
.1a3f47	08		php		            PHP
.1a3f48	c2 20		rep #$20	            REP #$20
.1a3f4a	48		pha		            PHA
.1a3f4b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3f4e	5b		tcd		            TCD
.1a3f4f	68		pla		            PLA
.1a3f50	28		plp		            PLP
.1a3f51	e2 20		sep #$20	            SEP #$20
.1a3f53	a9 01		lda #$01	            LDA #ERR_BREAK
.1a3f55	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3f59	c2 20		rep #$20	            REP #$20
.1a3f5b	29 ff 00	and #$00ff	            AND #$00FF
.1a3f5e	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3f61	e2 20		sep #$20	            SEP #$20
.1a3f63	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3f66					S_REM
.1a3f66	08		php		                PHP
.1a3f67	e2 20		sep #$20	            SEP #$20
.1a3f69	a7 00		lda [$0800]	rem_loop        LDA [BIP]
.1a3f6b	f0 05		beq $1a3f72	                BEQ done
.1a3f6d	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a3f70	80 f7		bra $1a3f69	                BRA rem_loop
.1a3f72	28		plp		done            PLP
.1a3f73	60		rts		            RTS
.1a3f74					S_EXIT
.1a3f74	08		php		                PHP
.1a3f75	28		plp		                PLP
.1a3f76	60		rts		            RTS
.1a3f77					S_DO
.1a3f77	08		php		                PHP
.1a3f78	28		plp		                PLP
.1a3f79	60		rts		            RTS
.0000					DO_RECORD
>0000					BIP             .dword  ?
>0004					CURLINE         .dword  ?
.1a3f7a					S_LOOP
.1a3f7a	08		php		                PHP
.1a3f7b	28		plp		                PLP
.1a3f7c	60		rts		            RTS
.1a3f7d					S_FOR
.1a3f7d	08		php		                PHP
.1a3f7e	c2 20		rep #$20	            REP #$20
.1a3f80	a5 1c		lda $081c	                LDA CURLINE+2
.1a3f82	20 66 1c	jsr $1a1c66	            JSR PHRETURN
.1a3f85	a5 1a		lda $081a	                LDA CURLINE
.1a3f87	20 66 1c	jsr $1a1c66	            JSR PHRETURN
.1a3f8a	a5 02		lda $0802	                LDA BIP+2           ; Save current BIP
.1a3f8c	48		pha		                PHA
.1a3f8d	a5 00		lda $0800	                LDA BIP
.1a3f8f	48		pha		                PHA
.1a3f90	20 a3 1f	jsr $1a1fa3	            JSR SKIPSTMT
.1a3f93	a5 02		lda $0802	                LDA BIP+2           ; Save the BIP for the next statement to the RETURN stack
.1a3f95	20 66 1c	jsr $1a1c66	            JSR PHRETURN
.1a3f98	a5 00		lda $0800	                LDA BIP
.1a3f9a	20 66 1c	jsr $1a1c66	            JSR PHRETURN
.1a3f9d	68		pla		                PLA                 ; Restore the original BIP
.1a3f9e	85 00		sta $0800	                STA BIP
.1a3fa0	68		pla		                PLA
.1a3fa1	85 02		sta $0802	                STA BIP+2
.1a3fa3	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a3fa6					get_name
.1a3fa6	20 8d 51	jsr $1a518d	            JSR VAR_FINDNAME
.1a3fa9	b0 1f		bcs $1a3fca	                BCS push_name       ; If we didn't find a name, thrown an error
.1a3fab	08		php		            PHP
.1a3fac	c2 20		rep #$20	            REP #$20
.1a3fae	48		pha		            PHA
.1a3faf	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a3fb2	5b		tcd		            TCD
.1a3fb3	68		pla		            PLA
.1a3fb4	28		plp		            PLP
.1a3fb5	e2 20		sep #$20	            SEP #$20
.1a3fb7	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a3fb9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a3fbd	c2 20		rep #$20	            REP #$20
.1a3fbf	29 ff 00	and #$00ff	            AND #$00FF
.1a3fc2	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a3fc5	e2 20		sep #$20	            SEP #$20
.1a3fc7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a3fca					push_name
.1a3fca	e2 20		sep #$20	            SEP #$20
.1a3fcc	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; To the return stack
.1a3fce	20 7d 1c	jsr $1a1c7d	            JSR PHRETURNB
.1a3fd1	a5 e9		lda $08e9	                LDA TOFIND+2
.1a3fd3	20 7d 1c	jsr $1a1c7d	            JSR PHRETURNB
.1a3fd6	c2 20		rep #$20	            REP #$20
.1a3fd8	a5 e7		lda $08e7	                LDA TOFIND
.1a3fda	20 66 1c	jsr $1a1c66	            JSR PHRETURN
.1a3fdd					else
.1a3fdd	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a3fe0	e2 20		sep #$20	            SEP #$20
.1a3fe2	a7 00		lda [$0800]	                LDA [BIP]
.1a3fe4	c9 8a		cmp #$8a	                CMP #TOK_EQ
.1a3fe6	d0 6a		bne $1a4052	                BNE syntax_err      ; If not found: signal an syntax error
.1a3fe8	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Verify type of variable
.1a3fea	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; Is it integer?
.1a3fec	f0 04		beq $1a3ff2	                BEQ process_initial ; Yes: it's ok
.1a3fee	c9 01		cmp #$01	                CMP #TYPE_FLOAT     ; Is it floating point?
.1a3ff0	f0 00		beq $1a3ff2	                BEQ process_initial ; Yes: it's ok
.1a3ff2					process_initial
.1a3ff2	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a3ff5	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a3ff8	20 f0 50	jsr $1a50f0	            JSR VAR_SET
.1a3ffb	e2 20		sep #$20	            SEP #$20
.1a3ffd	a9 9c		lda #$9c	                LDA #TOK_TO         ; Expect the next token to be TO
.1a3fff	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4002	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4005	c2 20		rep #$20	            REP #$20
.1a4007	a5 27		lda $0827	                LDA ARGTYPE1
.1a4009	20 66 1c	jsr $1a1c66	            JSR PHRETURN
.1a400c	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a400e	20 66 1c	jsr $1a1c66	            JSR PHRETURN
.1a4011	a5 23		lda $0823	                LDA ARGUMENT1
.1a4013	20 66 1c	jsr $1a1c66	            JSR PHRETURN
.1a4016	e2 20		sep #$20	            SEP #$20
.1a4018	a9 9d		lda #$9d	                LDA #TOK_STEP
.1a401a	85 37		sta $0837	                STA TARGETTOK
.1a401c	20 a0 20	jsr $1a20a0	            JSR OPT_TOK
.1a401f	90 1b		bcc $1a403c	                BCC default_inc     ; Not found: set a default increment of 1
.1a4021	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4024	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4027	e2 20		sep #$20	            SEP #$20
.1a4029	a5 27		lda $0827	                LDA ARGTYPE1        ; Push the result as the increment
.1a402b	20 66 1c	jsr $1a1c66	            JSR PHRETURN
.1a402e	c2 20		rep #$20	            REP #$20
.1a4030	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4032	20 66 1c	jsr $1a1c66	            JSR PHRETURN
.1a4035	a5 23		lda $0823	                LDA ARGUMENT1
.1a4037	20 66 1c	jsr $1a1c66	            JSR PHRETURN
.1a403a	80 14		bra $1a4050	                BRA done
.1a403c					default_inc
.1a403c	c2 20		rep #$20	            REP #$20
.1a403e	a9 00 00	lda #$0000	                LDA #TYPE_INTEGER
.1a4041	20 66 1c	jsr $1a1c66	            JSR PHRETURN
.1a4044	a9 00 00	lda #$0000	                LDA #0
.1a4047	20 66 1c	jsr $1a1c66	            JSR PHRETURN
.1a404a	a9 01 00	lda #$0001	                LDA #1
.1a404d	20 66 1c	jsr $1a1c66	            JSR PHRETURN
.1a4050	28		plp		done            PLP
.1a4051	60		rts		            RTS
.1a4052					syntax_err
.1a4052	08		php		            PHP
.1a4053	c2 20		rep #$20	            REP #$20
.1a4055	48		pha		            PHA
.1a4056	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4059	5b		tcd		            TCD
.1a405a	68		pla		            PLA
.1a405b	28		plp		            PLP
.1a405c	e2 20		sep #$20	            SEP #$20
.1a405e	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4060	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4064	c2 20		rep #$20	            REP #$20
.1a4066	29 ff 00	and #$00ff	            AND #$00FF
.1a4069	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a406c	e2 20		sep #$20	            SEP #$20
.1a406e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.0000					FOR_RECORD
>0000					INCREMENT       .dword  ?
>0004					INCTYPE         .word   ?
>0006					FINAL           .dword  ?
>000a					FINALTYPE       .word   ?
>000c					VARIBLE         .dword  ?
>0010					VARTYPE         .word   ?
>0012					BIP             .dword  ?
>0016					CURLINE         .dword  ?
.1a4071					S_NEXT
.1a4071	08		php		                PHP
.1a4072	8b		phb		                PHB
.1a4073	08		php		            PHP
.1a4074	e2 20		sep #$20	            SEP #$20
.1a4076	48		pha		            PHA
.1a4077	a9 00		lda #$00	            LDA #0
.1a4079	48		pha		            PHA
.1a407a	ab		plb		            PLB
.1a407b	68		pla		            PLA
.1a407c	28		plp		            PLP
.1a407d	08		php		            PHP
.1a407e	c2 20		rep #$20	            REP #$20
.1a4080	48		pha		            PHA
.1a4081	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a4084	5b		tcd		            TCD
.1a4085	68		pla		            PLA
.1a4086	28		plp		            PLP
.1a4087	c2 30		rep #$30	            REP #$30
.1a4089	a4 33		ldy $0833	                LDY RETURNSP                    ; Y := pointer to first byte of the FOR record
.1a408b	c8		iny		                INY                             ; RETURNSP points to the first free slot, so move up 2 bytes
.1a408c	c8		iny		                INY
.1a408d	c2 20		rep #$20	            REP #$20
.1a408f	b9 0c 00	lda $000c,y	                LDA #FOR_RECORD.VARIBLE,B,Y     ; TOFIND := FOR_RECORD.VARIABLE
.1a4092	85 e7		sta $08e7	                STA TOFIND
.1a4094	b9 0e 00	lda $000e,y	                LDA #FOR_RECORD.VARIBLE+2,B,Y
.1a4097	e2 20		sep #$20	            SEP #$20
.1a4099	85 e9		sta $08e9	                STA TOFIND+2
.1a409b	b9 10 00	lda $0010,y	                LDA #FOR_RECORD.VARTYPE,B,Y
.1a409e	85 ea		sta $08ea	                STA TOFINDTYPE
.1a40a0	c2 20		rep #$20	            REP #$20
.1a40a2	5a		phy		                PHY
.1a40a3	20 8e 4f	jsr $1a4f8e	            JSR VAR_REF
.1a40a6	7a		ply		                PLY
.1a40a7	c2 20		rep #$20	            REP #$20
.1a40a9	b9 00 00	lda $0000,y	                LDA #FOR_RECORD.INCREMENT,B,Y   ; ARGUMENT2 := FOR_RECORD.INCREMENT
.1a40ac	85 29		sta $0829	                STA ARGUMENT2
.1a40ae	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y
.1a40b1	85 2b		sta $082b	                STA ARGUMENT2+2
.1a40b3	e2 20		sep #$20	            SEP #$20
.1a40b5	b9 04 00	lda $0004,y	                LDA #FOR_RECORD.INCTYPE,B,Y
.1a40b8	85 2d		sta $082d	                STA ARGTYPE2
.1a40ba	c2 20		rep #$20	            REP #$20
.1a40bc	5a		phy		                PHY
.1a40bd	20 1d 26	jsr $1a261d	            JSR OP_PLUS
.1a40c0	20 f0 50	jsr $1a50f0	            JSR VAR_SET
.1a40c3	7a		ply		                PLY
.1a40c4	c2 20		rep #$20	            REP #$20
.1a40c6	b9 06 00	lda $0006,y	                LDA #FOR_RECORD.FINAL,B,Y       ; ARGUMENT2 := FOR_RECORD.FINAL
.1a40c9	85 29		sta $0829	                STA ARGUMENT2
.1a40cb	b9 08 00	lda $0008,y	                LDA #FOR_RECORD.FINAL+2,B,Y
.1a40ce	85 2b		sta $082b	                STA ARGUMENT2+2
.1a40d0	e2 20		sep #$20	            SEP #$20
.1a40d2	b9 0a 00	lda $000a,y	                LDA #FOR_RECORD.FINALTYPE,B,Y
.1a40d5	85 2d		sta $082d	                STA ARGTYPE2
.1a40d7	c2 20		rep #$20	            REP #$20
.1a40d9	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y ; Check the increment's sign
.1a40dc	30 0a		bmi $1a40e8	                BMI going_down
.1a40de					going_up
.1a40de	20 a6 28	jsr $1a28a6	            JSR OP_LTE
.1a40e1	20 cc 04	jsr $1a04cc	            JSR IS_ARG1_Z
.1a40e4	f0 28		beq $1a410e	                BEQ end_loop                    ; No: end the loop
.1a40e6	80 08		bra $1a40f0	                BRA loop_back                   ; Yes: loop back
.1a40e8					going_down
.1a40e8	20 66 28	jsr $1a2866	            JSR OP_GTE
.1a40eb	20 cc 04	jsr $1a04cc	            JSR IS_ARG1_Z
.1a40ee	f0 1e		beq $1a410e	                BEQ end_loop                    ; No: end the loop
.1a40f0					loop_back
.1a40f0	c2 20		rep #$20	            REP #$20
.1a40f2	b9 12 00	lda $0012,y	                LDA #FOR_RECORD.BIP,B,Y
.1a40f5	85 00		sta $0800	                STA BIP
.1a40f7	b9 14 00	lda $0014,y	                LDA #FOR_RECORD.BIP+2,B,Y
.1a40fa	85 02		sta $0802	                STA BIP+2
.1a40fc	b9 16 00	lda $0016,y	                LDA #FOR_RECORD.CURLINE,B,Y     ; CURLINE := FOR_RECORD.CURLINE
.1a40ff	85 1a		sta $081a	                STA CURLINE
.1a4101	b9 18 00	lda $0018,y	                LDA #FOR_RECORD.CURLINE+2,B,Y
.1a4104	85 1c		sta $081c	                STA CURLINE+2
.1a4106	e2 20		sep #$20	            SEP #$20
.1a4108	a9 03		lda #$03	                LDA #EXEC_RETURN
.1a410a	85 dc		sta $08dc	                STA EXECACTION
.1a410c	80 17		bra $1a4125	                BRA done
.1a410e					end_loop
.1a410e	a2 23 08	ldx #$0823	                LDX #ARGUMENT1
.1a4111	20 6d 18	jsr $1a186d	            JSR PLARGUMENT
.1a4114	c2 20		rep #$20	            REP #$20
.1a4116	18		clc		                CLC
.1a4117	a5 33		lda $0833	                LDA RETURNSP
.1a4119	69 1a 00	adc #$001a	                ADC #size(FOR_RECORD)           ; Move pointer by number of bytes in a FOR record
.1a411c	85 33		sta $0833	                STA RETURNSP
.1a411e	a5 35		lda $0835	                LDA RETURNSP+2
.1a4120	69 00 00	adc #$0000	                ADC #0
.1a4123	85 35		sta $0835	                STA RETURNSP+2
.1a4125	ab		plb		done            PLB
.1a4126	28		plp		                PLP
.1a4127	60		rts		            RTS
.1a4128					S_GOSUB
.1a4128	08		php		                PHP
.1a4129	a5 1a		lda $081a	                LDA CURLINE                 ; Save the current line for later
.1a412b	48		pha		                PHA
.1a412c	a5 1c		lda $081c	                LDA CURLINE+2
.1a412e	48		pha		                PHA
.1a412f	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a4132	20 8a 07	jsr $1a078a	            JSR PARSEINT
.1a4135	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.1a4137	f0 26		beq $1a415f	                BEQ syntax_err              ; If 0, no number was found... syntax error
.1a4139	20 5d 22	jsr $1a225d	            JSR FINDLINE
.1a413c	90 42		bcc $1a4180	                BCC not_found               ; If not found... LINE NOT FOUND error
.1a413e	e2 20		sep #$20	            SEP #$20
.1a4140	a9 02		lda #$02	                LDA #EXEC_GOTO
.1a4142	85 dc		sta $08dc	                STA EXECACTION
.1a4144	20 a3 1f	jsr $1a1fa3	            JSR SKIPSTMT
.1a4147	c2 20		rep #$20	            REP #$20
.1a4149	68		pla		                PLA                         ; Save the old value of CURLINE to the RETURN stack
.1a414a	20 66 1c	jsr $1a1c66	            JSR PHRETURN
.1a414d	68		pla		                PLA
.1a414e	20 66 1c	jsr $1a1c66	            JSR PHRETURN
.1a4151	a5 02		lda $0802	                LDA BIP+2                   ; Save the BASIC Instruction Pointer to the RETURN stack
.1a4153	20 66 1c	jsr $1a1c66	            JSR PHRETURN
.1a4156	a5 00		lda $0800	                LDA BIP
.1a4158	20 66 1c	jsr $1a1c66	            JSR PHRETURN
.1a415b	e6 31		inc $0831	                INC GOSUBDEPTH              ; Increase the count of GOSUBs on the stack
.1a415d	28		plp		                PLP
.1a415e	60		rts		            RTS
.1a415f	68		pla		syntax_err      PLA
.1a4160	68		pla		                PLA
.1a4161	08		php		            PHP
.1a4162	c2 20		rep #$20	            REP #$20
.1a4164	48		pha		            PHA
.1a4165	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4168	5b		tcd		            TCD
.1a4169	68		pla		            PLA
.1a416a	28		plp		            PLP
.1a416b	e2 20		sep #$20	            SEP #$20
.1a416d	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a416f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4173	c2 20		rep #$20	            REP #$20
.1a4175	29 ff 00	and #$00ff	            AND #$00FF
.1a4178	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a417b	e2 20		sep #$20	            SEP #$20
.1a417d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4180	68		pla		not_found       PLA
.1a4181	68		pla		                PLA
.1a4182	08		php		            PHP
.1a4183	c2 20		rep #$20	            REP #$20
.1a4185	48		pha		            PHA
.1a4186	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4189	5b		tcd		            TCD
.1a418a	68		pla		            PLA
.1a418b	28		plp		            PLP
.1a418c	e2 20		sep #$20	            SEP #$20
.1a418e	a9 06		lda #$06	            LDA #ERR_NOLINE
.1a4190	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4194	c2 20		rep #$20	            REP #$20
.1a4196	29 ff 00	and #$00ff	            AND #$00FF
.1a4199	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a419c	e2 20		sep #$20	            SEP #$20
.1a419e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a41a1					S_RETURN
.1a41a1	08		php		                PHP
.1a41a2	c2 30		rep #$30	            REP #$30
.1a41a4	a5 31		lda $0831	                LDA GOSUBDEPTH              ; Check that there is at least on GOSUB on the stack
.1a41a6	f0 1e		beq $1a41c6	                BEQ underflow               ; No? It's a stack underflow error
.1a41a8	20 88 1c	jsr $1a1c88	            JSR PLRETURN
.1a41ab	85 00		sta $0800	                STA BIP
.1a41ad	20 88 1c	jsr $1a1c88	            JSR PLRETURN
.1a41b0	85 02		sta $0802	                STA BIP+2
.1a41b2	20 88 1c	jsr $1a1c88	            JSR PLRETURN
.1a41b5	85 1a		sta $081a	                STA CURLINE
.1a41b7	20 88 1c	jsr $1a1c88	            JSR PLRETURN
.1a41ba	85 1c		sta $081c	                STA CURLINE+2
.1a41bc	c6 31		dec $0831	                DEC GOSUBDEPTH              ; Indicate we've popped that GOSUB off the stack
.1a41be	e2 20		sep #$20	            SEP #$20
.1a41c0	a9 03		lda #$03	                LDA #EXEC_RETURN
.1a41c2	85 dc		sta $08dc	                STA EXECACTION
.1a41c4	28		plp		                PLP
.1a41c5	60		rts		            RTS
.1a41c6					underflow
.1a41c6	08		php		            PHP
.1a41c7	c2 20		rep #$20	            REP #$20
.1a41c9	48		pha		            PHA
.1a41ca	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a41cd	5b		tcd		            TCD
.1a41ce	68		pla		            PLA
.1a41cf	28		plp		            PLP
.1a41d0	e2 20		sep #$20	            SEP #$20
.1a41d2	a9 07		lda #$07	            LDA #ERR_STACKUNDER
.1a41d4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a41d8	c2 20		rep #$20	            REP #$20
.1a41da	29 ff 00	and #$00ff	            AND #$00FF
.1a41dd	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a41e0	e2 20		sep #$20	            SEP #$20
.1a41e2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a41e5					S_IF
.1a41e5	08		php		                PHP
.1a41e6	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a41e9	20 cc 04	jsr $1a04cc	            JSR IS_ARG1_Z
.1a41ec	f0 1c		beq $1a420a	                BEQ is_false                ; If so, handle the FALSE case
.1a41ee	e2 20		sep #$20	            SEP #$20
.1a41f0	a9 97		lda #$97	                LDA #TOK_THEN               ; Verify that the next token is THEN and eat it
.1a41f2	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a41f5	20 8a 07	jsr $1a078a	            JSR PARSEINT
.1a41f8	20 cc 04	jsr $1a04cc	            JSR IS_ARG1_Z
.1a41fb	f0 12		beq $1a420f	                BEQ syntax_err              ; If not, we have a syntax error
.1a41fd	20 5d 22	jsr $1a225d	            JSR FINDLINE
.1a4200	90 2c		bcc $1a422e	                BCC not_found               ; If not found... LINE NOT FOUND error
.1a4202	e2 20		sep #$20	            SEP #$20
.1a4204	a9 02		lda #$02	                LDA #EXEC_GOTO
.1a4206	85 dc		sta $08dc	                STA EXECACTION
.1a4208	80 03		bra $1a420d	                BRA done
.1a420a					is_false
.1a420a	20 a3 1f	jsr $1a1fa3	            JSR SKIPSTMT
.1a420d	28		plp		done            PLP
.1a420e	60		rts		            RTS
.1a420f					syntax_err
.1a420f	08		php		            PHP
.1a4210	c2 20		rep #$20	            REP #$20
.1a4212	48		pha		            PHA
.1a4213	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4216	5b		tcd		            TCD
.1a4217	68		pla		            PLA
.1a4218	28		plp		            PLP
.1a4219	e2 20		sep #$20	            SEP #$20
.1a421b	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a421d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4221	c2 20		rep #$20	            REP #$20
.1a4223	29 ff 00	and #$00ff	            AND #$00FF
.1a4226	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a4229	e2 20		sep #$20	            SEP #$20
.1a422b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a422e					not_found
.1a422e	08		php		            PHP
.1a422f	c2 20		rep #$20	            REP #$20
.1a4231	48		pha		            PHA
.1a4232	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4235	5b		tcd		            TCD
.1a4236	68		pla		            PLA
.1a4237	28		plp		            PLP
.1a4238	e2 20		sep #$20	            SEP #$20
.1a423a	a9 06		lda #$06	            LDA #ERR_NOLINE
.1a423c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4240	c2 20		rep #$20	            REP #$20
.1a4242	29 ff 00	and #$00ff	            AND #$00FF
.1a4245	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a4248	e2 20		sep #$20	            SEP #$20
.1a424a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a424d					S_END
.1a424d	08		php		                PHP
.1a424e	e2 20		sep #$20	            SEP #$20
.1a4250	a9 01		lda #$01	                LDA #EXEC_STOP
.1a4252	85 dc		sta $08dc	                STA EXECACTION
.1a4254	28		plp		                PLP
.1a4255	60		rts		            RTS
.1a4256					S_GOTO
.1a4256	08		php		                PHP
.1a4257	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a425a	20 8a 07	jsr $1a078a	            JSR PARSEINT
.1a425d	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.1a425f	f0 0d		beq $1a426e	                BEQ syntax_err              ; If 0, no number was found... syntax error
.1a4261	20 5d 22	jsr $1a225d	            JSR FINDLINE
.1a4264	90 27		bcc $1a428d	                BCC not_found               ; If not found... LINE NOT FOUND error
.1a4266	e2 20		sep #$20	            SEP #$20
.1a4268	a9 02		lda #$02	                LDA #EXEC_GOTO
.1a426a	85 dc		sta $08dc	                STA EXECACTION
.1a426c	28		plp		                PLP
.1a426d	60		rts		            RTS
.1a426e					syntax_err
.1a426e	08		php		            PHP
.1a426f	c2 20		rep #$20	            REP #$20
.1a4271	48		pha		            PHA
.1a4272	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4275	5b		tcd		            TCD
.1a4276	68		pla		            PLA
.1a4277	28		plp		            PLP
.1a4278	e2 20		sep #$20	            SEP #$20
.1a427a	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a427c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4280	c2 20		rep #$20	            REP #$20
.1a4282	29 ff 00	and #$00ff	            AND #$00FF
.1a4285	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a4288	e2 20		sep #$20	            SEP #$20
.1a428a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a428d					not_found
.1a428d	08		php		            PHP
.1a428e	c2 20		rep #$20	            REP #$20
.1a4290	48		pha		            PHA
.1a4291	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4294	5b		tcd		            TCD
.1a4295	68		pla		            PLA
.1a4296	28		plp		            PLP
.1a4297	e2 20		sep #$20	            SEP #$20
.1a4299	a9 06		lda #$06	            LDA #ERR_NOLINE
.1a429b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a429f	c2 20		rep #$20	            REP #$20
.1a42a1	29 ff 00	and #$00ff	            AND #$00FF
.1a42a4	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a42a7	e2 20		sep #$20	            SEP #$20
.1a42a9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a42ac					S_CLR
.1a42ac	20 0f 18	jsr $1a180f	            JSR INITEVALSP
.1a42af	20 58 0f	jsr $1a0f58	            JSR INITHEAP
.1a42b2	20 8d 4e	jsr $1a4e8d	            JSR INITVARS
.1a42b5	60		rts		            RTS
.1a42b6					S_LET
.1a42b6	08		php		                PHP
.1a42b7	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.1a42b9	10 03		bpl $1a42be	                BPL get_name        ; If it's not a token, try to find the variable name
.1a42bb	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a42be					get_name
.1a42be	20 8d 51	jsr $1a518d	            JSR VAR_FINDNAME
.1a42c1	b0 03		bcs $1a42c6	                BCS check_array     ; If we didn't find a name, thrown an error
.1a42c3	4c 2d 43	jmp $1a432d	                JMP syntax_err
.1a42c6					check_array
.1a42c6	e2 20		sep #$20	            SEP #$20
.1a42c8	20 bf 20	jsr $1a20bf	            JSR PEEK_TOK
.1a42cb	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it a "("
.1a42cd	d0 0e		bne $1a42dd	                BNE get_value       ; No: it's a scalar assignment, look for the "="
.1a42cf	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a42d1	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a42d4	a9 00		lda #$00	                LDA #0
.1a42d6	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF     ; Blank out the array index buffer
.1a42da	20 91 19	jsr $1a1991	            JSR ARR_GETIDX
.1a42dd					get_value
.1a42dd	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a42e0	e2 20		sep #$20	            SEP #$20
.1a42e2	a7 00		lda [$0800]	                LDA [BIP]
.1a42e4	c9 8a		cmp #$8a	                CMP #TOK_EQ
.1a42e6	f0 03		beq $1a42eb	                BEQ found_eq        ; If not found: signal an syntax error
.1a42e8	4c 2d 43	jmp $1a432d	                JMP syntax_err
.1a42eb					found_eq
.1a42eb	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a42ee	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Save the variable name for later
.1a42f0	48		pha		                PHA                 ; (it will get over-written by variable references)
.1a42f1	a5 e9		lda $08e9	                LDA TOFIND+2
.1a42f3	48		pha		                PHA
.1a42f4	a5 e8		lda $08e8	                LDA TOFIND+1
.1a42f6	48		pha		                PHA
.1a42f7	a5 e7		lda $08e7	                LDA TOFIND
.1a42f9	48		pha		                PHA
.1a42fa	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a42fd	68		pla		                PLA                 ; Restore the variable name
.1a42fe	85 e7		sta $08e7	                STA TOFIND
.1a4300	68		pla		                PLA
.1a4301	85 e8		sta $08e8	                STA TOFIND+1
.1a4303	68		pla		                PLA
.1a4304	85 e9		sta $08e9	                STA TOFIND+2
.1a4306	68		pla		                PLA
.1a4307	85 ea		sta $08ea	                STA TOFINDTYPE
.1a4309	29 80		and #$80	                AND #$80            ; Is it an array we're setting?
.1a430b	f0 1b		beq $1a4328	                BEQ set_scalar      ; No: do a scalar variable set
.1a430d	20 00 4f	jsr $1a4f00	            JSR VAR_FIND
.1a4310	90 3a		bcc $1a434c	                BCC notfound_err
.1a4312	c2 20		rep #$20	            REP #$20
.1a4314	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.1a4317	b7 08		lda [$0808],y	                LDA [INDEX],Y       ; Save the pointer to the array to CURRBLOCK
.1a4319	85 c0		sta $08c0	                STA CURRBLOCK
.1a431b	e2 20		sep #$20	            SEP #$20
.1a431d	c8		iny		                INY
.1a431e	c8		iny		                INY
.1a431f	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a4321	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a4323	20 ec 65	jsr $1a65ec	            JSR ARR_SET
.1a4326	80 03		bra $1a432b	                BRA done            ; and we're finished!
.1a4328					set_scalar
.1a4328	20 f0 50	jsr $1a50f0	            JSR VAR_SET
.1a432b					done
.1a432b	28		plp		                PLP
.1a432c	60		rts		            RTS
.1a432d					syntax_err
.1a432d	08		php		            PHP
.1a432e	c2 20		rep #$20	            REP #$20
.1a4330	48		pha		            PHA
.1a4331	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4334	5b		tcd		            TCD
.1a4335	68		pla		            PLA
.1a4336	28		plp		            PLP
.1a4337	e2 20		sep #$20	            SEP #$20
.1a4339	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a433b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a433f	c2 20		rep #$20	            REP #$20
.1a4341	29 ff 00	and #$00ff	            AND #$00FF
.1a4344	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a4347	e2 20		sep #$20	            SEP #$20
.1a4349	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a434c					notfound_err
.1a434c	08		php		            PHP
.1a434d	c2 20		rep #$20	            REP #$20
.1a434f	48		pha		            PHA
.1a4350	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4353	5b		tcd		            TCD
.1a4354	68		pla		            PLA
.1a4355	28		plp		            PLP
.1a4356	e2 20		sep #$20	            SEP #$20
.1a4358	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a435a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a435e	c2 20		rep #$20	            REP #$20
.1a4360	29 ff 00	and #$00ff	            AND #$00FF
.1a4363	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a4366	e2 20		sep #$20	            SEP #$20
.1a4368	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a436b					S_PRINT
.1a436b	08		php		                PHP
.1a436c	e2 20		sep #$20	            SEP #$20
.1a436e	20 bf 20	jsr $1a20bf	            JSR PEEK_TOK
.1a4371	c9 00		cmp #$00	                CMP #0              ; Is it EOL or :?
.1a4373	f0 6d		beq $1a43e2	                BEQ pr_nl_exit      ; Yes: just print return
.1a4375					pr_loop
.1a4375	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4378	e2 20		sep #$20	            SEP #$20
.1a437a	a5 27		lda $0827	                LDA ARGTYPE1        ; Get the type of the result
.1a437c	c9 ff		cmp #$ff	                CMP #TYPE_NAV       ; Is is NAV?
.1a437e	f0 1b		beq $1a439b	                BEQ check_nl        ; Yes: we are probably just printing a newline
.1a4380	c9 02		cmp #$02	                CMP #TYPE_STRING    ; Is it a string?
.1a4382	d0 05		bne $1a4389	                BNE check_int       ; No: check to see if it's an integer
.1a4384	20 e7 43	jsr $1a43e7	            JSR PR_STRING
.1a4387	80 12		bra $1a439b	                BRA check_nl
.1a4389	c9 00		cmp #$00	check_int       CMP #TYPE_INTEGER   ; Is it an integer?
.1a438b	d0 05		bne $1a4392	                BNE check_float     ; No: check to see if it is a float
.1a438d	20 07 44	jsr $1a4407	            JSR PR_INTEGER
.1a4390	80 09		bra $1a439b	                BRA check_nl
.1a4392	c9 01		cmp #$01	check_float     CMP #TYPE_FLOAT     ; Is it a float?
.1a4394	d0 4f		bne $1a43e5	                BNE done            ; No: just quit
.1a4396	20 1a 44	jsr $1a441a	            JSR PR_FLOAT
.1a4399	80 00		bra $1a439b	                BRA check_nl
.1a439b					check_nl
.1a439b	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a439e	a7 00		lda [$0800]	                LDA [BIP]
.1a43a0	f0 40		beq $1a43e2	                BEQ pr_nl_exit      ; If it's nul, print a newline and return
.1a43a2	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.1a43a4	f0 3c		beq $1a43e2	                BEQ pr_nl_exit      ; print a newline and return
.1a43a6	c9 2c		cmp #$2c	                CMP #','            ; If it's a comma
.1a43a8	f0 23		beq $1a43cd	                BEQ pr_comma        ; Print a TAB and try another expression
.1a43aa	c9 3b		cmp #$3b	                CMP #';'            ; If it's a semicolon...
.1a43ac	f0 24		beq $1a43d2	                BEQ is_more         ; Print nothing, and try another expression
.1a43ae	08		php		            PHP
.1a43af	c2 20		rep #$20	            REP #$20
.1a43b1	48		pha		            PHA
.1a43b2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a43b5	5b		tcd		            TCD
.1a43b6	68		pla		            PLA
.1a43b7	28		plp		            PLP
.1a43b8	e2 20		sep #$20	            SEP #$20
.1a43ba	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a43bc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a43c0	c2 20		rep #$20	            REP #$20
.1a43c2	29 ff 00	and #$00ff	            AND #$00FF
.1a43c5	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a43c8	e2 20		sep #$20	            SEP #$20
.1a43ca	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a43cd	a9 09		lda #$09	pr_comma        LDA #CHAR_TAB       ; Print a TAB
.1a43cf	20 18 00	jsr $1a0018	            JSR PRINTC
.1a43d2					is_more
.1a43d2	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a43d5	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a43d8	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.1a43da	f0 09		beq $1a43e5	                BEQ done            ; If it's NULL, return without printing a newline
.1a43dc	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.1a43de	f0 05		beq $1a43e5	                BEQ done            ; ... return without printing a newline
.1a43e0	80 93		bra $1a4375	                BRA pr_loop         ; Otherwise, we should have another expression, try to handle it
.1a43e2					pr_nl_exit
.1a43e2	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a43e5	28		plp		done            PLP
.1a43e6	60		rts		            RTS
.1a43e7					PR_STRING
.1a43e7	08		php		                PHP
.1a43e8	8b		phb		                PHB
.1a43e9	08		php		            PHP
.1a43ea	c2 20		rep #$20	            REP #$20
.1a43ec	48		pha		            PHA
.1a43ed	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a43f0	5b		tcd		            TCD
.1a43f1	68		pla		            PLA
.1a43f2	28		plp		            PLP
.1a43f3	e2 20		sep #$20	            SEP #$20
.1a43f5	c2 10		rep #$10	            REP #$10
.1a43f7	a0 00 00	ldy #$0000	                LDY #0
.1a43fa	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y
.1a43fc	f0 06		beq $1a4404	                BEQ done
.1a43fe	20 18 00	jsr $1a0018	            JSR PRINTC
.1a4401	c8		iny		                INY
.1a4402	80 f6		bra $1a43fa	                BRA loop
.1a4404	ab		plb		done            PLB
.1a4405	28		plp		                PLP
.1a4406	60		rts		            RTS
.1a4407					PR_INTEGER
.1a4407	08		php		                PHP
.1a4408	c2 20		rep #$20	            REP #$20
.1a440a	20 0d 14	jsr $1a140d	            JSR ITOS
.1a440d	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.1a440f	85 23		sta $0823	                STA ARGUMENT1
.1a4411	a5 18		lda $0818	                LDA STRPTR+2
.1a4413	85 25		sta $0825	                STA ARGUMENT1+2
.1a4415	20 e7 43	jsr $1a43e7	            JSR PR_STRING
.1a4418	28		plp		                PLP
.1a4419	60		rts		            RTS
.1a441a					PR_FLOAT
.1a441a	08		php		                PHP
.1a441b	20 56 5b	jsr $1a5b56	            JSR FTOS
.1a441e	c2 20		rep #$20	            REP #$20
.1a4420	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.1a4422	85 23		sta $0823	                STA ARGUMENT1
.1a4424	a5 18		lda $0818	                LDA STRPTR+2
.1a4426	85 25		sta $0825	                STA ARGUMENT1+2
.1a4428	20 e7 43	jsr $1a43e7	            JSR PR_STRING
.1a442b	28		plp		                PLP
.1a442c	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\functions.s


;******  Processing file: src\C256/functions_c256.s

.1a442d					BCD2STR
.1a442d	08		php		            PHP
.1a442e	e2 20		sep #$20	            SEP #$20
.1a4430	85 b5		sta $08b5	            STA SAVE_A
.1a4432	4a		lsr a		            LSR A
.1a4433	4a		lsr a		            LSR A
.1a4434	4a		lsr a		            LSR A
.1a4435	4a		lsr a		            LSR A
.1a4436	29 0f		and #$0f	            AND #$0F
.1a4438	18		clc		            CLC
.1a4439	69 30		adc #$30	            ADC #'0'
.1a443b	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a443d	c8		iny		            INY
.1a443e	a5 b5		lda $08b5	            LDA SAVE_A
.1a4440	29 0f		and #$0f	            AND #$0F
.1a4442	18		clc		            CLC
.1a4443	69 30		adc #$30	            ADC #'0'
.1a4445	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a4447	c8		iny		            INY
.1a4448	28		plp		            PLP
.1a4449	60		rts		            RTS
.1a444a					F_GETDATE
.1a444a	e2 20		sep #$20	            SEP #$20
.1a444c	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a444e	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4451	08		php		            PHP
.1a4452	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4455	e2 20		sep #$20	            SEP #$20
.1a4457	c2 10		rep #$10	            REP #$10
.1a4459	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a445d	09 08		ora #$08	            ORA #%00001000
.1a445f	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a4463	20 ae 13	jsr $1a13ae	            JSR TEMPSTRING
.1a4466	a0 00 00	ldy #$0000	            LDY #0
.1a4469	af 06 08 af	lda $af0806	            LDA @lRTC_DAY           ; Write the day of the month
.1a446d	20 2d 44	jsr $1a442d	            JSR BCD2STR
.1a4470	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.1a4472	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a4474	c8		iny		            INY
.1a4475	af 09 08 af	lda $af0809	            LDA @lRTC_MONTH         ; Write the month
.1a4479	20 2d 44	jsr $1a442d	            JSR BCD2STR
.1a447c	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.1a447e	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a4480	c8		iny		            INY
.1a4481	af 0f 08 af	lda $af080f	            LDA @lRTC_CENTURY       ; Write the year
.1a4485	20 2d 44	jsr $1a442d	            JSR BCD2STR
.1a4488	af 0a 08 af	lda $af080a	            LDA @lRTC_YEAR          ; Write the year
.1a448c	20 2d 44	jsr $1a442d	            JSR BCD2STR
.1a448f	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.1a4491	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a4493	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a4497	29 f7		and #$f7	            AND #%11110111
.1a4499	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a449d	c2 20		rep #$20	            REP #$20
.1a449f	a5 16		lda $0816	            LDA STRPTR
.1a44a1	85 23		sta $0823	            STA ARGUMENT1
.1a44a3	a5 18		lda $0818	            LDA STRPTR+2
.1a44a5	85 25		sta $0825	            STA ARGUMENT1+2
.1a44a7	e2 20		sep #$20	            SEP #$20
.1a44a9	a9 02		lda #$02	            LDA #TYPE_STRING
.1a44ab	85 27		sta $0827	            STA ARGTYPE1
.1a44ad	28		plp		            PLP
.1a44ae	e2 20		sep #$20	            SEP #$20
.1a44b0	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a44b3	60		rts		            RTS
.1a44b4					F_GETTIME
.1a44b4	e2 20		sep #$20	            SEP #$20
.1a44b6	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a44b8	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a44bb	08		php		            PHP
.1a44bc	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a44bf	e2 20		sep #$20	            SEP #$20
.1a44c1	c2 10		rep #$10	            REP #$10
.1a44c3	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.1a44c7	09 08		ora #$08	            ORA #%00001000
.1a44c9	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a44cd	20 ae 13	jsr $1a13ae	            JSR TEMPSTRING
.1a44d0	a0 00 00	ldy #$0000	            LDY #0
.1a44d3	af 04 08 af	lda $af0804	            LDA @lRTC_HRS           ; Write the hour
.1a44d7	29 7f		and #$7f	            AND #$7F                ; Trim out the AM/PM indicator
.1a44d9	20 2d 44	jsr $1a442d	            JSR BCD2STR
.1a44dc	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.1a44de	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a44e0	c8		iny		            INY
.1a44e1	af 02 08 af	lda $af0802	            LDA @lRTC_MIN           ; Write the minute
.1a44e5	20 2d 44	jsr $1a442d	            JSR BCD2STR
.1a44e8	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.1a44ea	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a44ec	c8		iny		            INY
.1a44ed	af 00 08 af	lda $af0800	            LDA @lRTC_SEC           ; Write the second
.1a44f1	20 2d 44	jsr $1a442d	            JSR BCD2STR
.1a44f4	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.1a44f6	97 16		sta [$0816],y	            STA [STRPTR],Y
.1a44f8	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.1a44fc	29 f7		and #$f7	            AND #%11110111
.1a44fe	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.1a4502	c2 20		rep #$20	            REP #$20
.1a4504	a5 16		lda $0816	            LDA STRPTR
.1a4506	85 23		sta $0823	            STA ARGUMENT1
.1a4508	a5 18		lda $0818	            LDA STRPTR+2
.1a450a	85 25		sta $0825	            STA ARGUMENT1+2
.1a450c	e2 20		sep #$20	            SEP #$20
.1a450e	a9 02		lda #$02	            LDA #TYPE_STRING
.1a4510	85 27		sta $0827	            STA ARGTYPE1
.1a4512	28		plp		            PLP
.1a4513	e2 20		sep #$20	            SEP #$20
.1a4515	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4518	60		rts		            RTS
.1a4519					FN_RND
.1a4519	e2 20		sep #$20	            SEP #$20
.1a451b	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a451d	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4520	08		php		            PHP
.1a4521	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4524	e2 20		sep #$20	            SEP #$20
.1a4526	a9 01		lda #$01	            LDA #TYPE_FLOAT             ; We'll return a floating point number
.1a4528	85 27		sta $0827	            STA ARGTYPE1
.1a452a	a9 03		lda #$03	            LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.1a452c	8f 00 e2 af	sta $afe200	            STA @l FP_MATH_CTRL0        ; Expect fixed point numbers
.1a4530	a9 01		lda #$01	            LDA #FP_OUT_DIV             ; Set us to do a division
.1a4532	8f 01 e2 af	sta $afe201	            STA @l FP_MATH_CTRL1
.1a4536	c2 30		rep #$30	            REP #$30
.1a4538	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get a random 16-bits
.1a453c	8f 08 e2 af	sta $afe208	            STA @l FP_MATH_INPUT0_LL    ; Send them to the FP unit
.1a4540	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get another random 16-bits
.1a4544	29 ff 7f	and #$7fff	            AND #$7FFF                  ; Make sure it's positive
.1a4547	8f 0a e2 af	sta $afe20a	            STA @l FP_MATH_INPUT0_LL+2  ; Send them to the FP unit
.1a454b	a9 ff ff	lda #$ffff	            LDA #$FFFF                  ; Get the maximum value
.1a454e	8f 0c e2 af	sta $afe20c	            STA @l FP_MATH_INPUT1_LL    ; Send it to the FP unit
.1a4552	a9 ff 7f	lda #$7fff	            LDA #$7FFF
.1a4555	8f 0e e2 af	sta $afe20e	            STA @l FP_MATH_INPUT1_LL+2
.1a4559	ea		nop		            NOP
.1a455a	ea		nop		            NOP
.1a455b	ea		nop		            NOP
.1a455c	af 08 e2 af	lda $afe208	            LDA @l FP_MATH_OUTPUT_FP_LL     ; Get the normalized result
.1a4560	85 23		sta $0823	            STA ARGUMENT1
.1a4562	af 0a e2 af	lda $afe20a	            LDA @l FP_MATH_OUTPUT_FP_LL+2
.1a4566	85 25		sta $0825	            STA ARGUMENT1+2
.1a4568	28		plp		            PLP
.1a4569	e2 20		sep #$20	            SEP #$20
.1a456b	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a456e	60		rts		            RTS

;******  Return to file: src\functions.s

.1a456f					FN_MID
.1a456f	e2 20		sep #$20	            SEP #$20
.1a4571	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4573	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4576	08		php		                PHP
.1a4577	c2 30		rep #$30	            REP #$30
.1a4579	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a457c	20 95 05	jsr $1a0595	            JSR ASS_ARG1_STR
.1a457f					save_string
.1a457f	c2 20		rep #$20	            REP #$20
.1a4581	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.1a4583	48		pha		                PHA
.1a4584	a5 23		lda $0823	                LDA ARGUMENT1
.1a4586	48		pha		                PHA
.1a4587	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a458a	e2 20		sep #$20	            SEP #$20
.1a458c	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a458e	c9 2c		cmp #$2c	                CMP #','
.1a4590	f0 03		beq $1a4595	                BEQ skip_comma1
.1a4592	4c e6 45	jmp $1a45e6	                JMP syntax_err
.1a4595					skip_comma1
.1a4595	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4598	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a459b	20 bf 05	jsr $1a05bf	            JSR ASS_ARG1_INT16
.1a459e	c2 20		rep #$20	            REP #$20
.1a45a0	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the index
.1a45a2	48		pha		                PHA
.1a45a3	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a45a6	e2 20		sep #$20	            SEP #$20
.1a45a8	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a45aa	c9 2c		cmp #$2c	                CMP #','
.1a45ac	f0 03		beq $1a45b1	                BEQ skip_comma2
.1a45ae	4c e6 45	jmp $1a45e6	                JMP syntax_err
.1a45b1					skip_comma2
.1a45b1	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a45b4	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a45b7	20 bf 05	jsr $1a05bf	            JSR ASS_ARG1_INT16
.1a45ba	c2 20		rep #$20	            REP #$20
.1a45bc	a5 23		lda $0823	            LDA ARGUMENT1
.1a45be	85 8f		sta $088f	            STA MCOUNT
.1a45c0	e2 20		sep #$20	            SEP #$20
.1a45c2	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a45c4	85 91		sta $0891	            STA MCOUNT+2
.1a45c6	c2 20		rep #$20	            REP #$20
.1a45c8	68		pla		                PLA                         ; Restore index
.1a45c9	85 29		sta $0829	                STA ARGUMENT2               ; ... to ARGUMENT2
.1a45cb	a9 00 00	lda #$0000	                LDA #0
.1a45ce	85 2b		sta $082b	                STA ARGUMENT2+2
.1a45d0	68		pla		                PLA                         ; Restore string
.1a45d1	85 23		sta $0823	                STA ARGUMENT1               ; ... to ARGUMENT1
.1a45d3	68		pla		                PLA
.1a45d4	85 25		sta $0825	                STA ARGUMENT1+2
.1a45d6	e2 20		sep #$20	            SEP #$20
.1a45d8	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a45da	85 27		sta $0827	            STA ARGTYPE1
.1a45dc	20 06 16	jsr $1a1606	            JSR STRSUBSTR
.1a45df					done
.1a45df	e2 20		sep #$20	            SEP #$20
.1a45e1	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a45e4	28		plp		                PLP
.1a45e5	60		rts		            RTS
.1a45e6					syntax_err
.1a45e6	08		php		            PHP
.1a45e7	c2 20		rep #$20	            REP #$20
.1a45e9	48		pha		            PHA
.1a45ea	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a45ed	5b		tcd		            TCD
.1a45ee	68		pla		            PLA
.1a45ef	28		plp		            PLP
.1a45f0	e2 20		sep #$20	            SEP #$20
.1a45f2	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a45f4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a45f8	c2 20		rep #$20	            REP #$20
.1a45fa	29 ff 00	and #$00ff	            AND #$00FF
.1a45fd	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a4600	e2 20		sep #$20	            SEP #$20
.1a4602	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4605					range_err
.1a4605	08		php		            PHP
.1a4606	c2 20		rep #$20	            REP #$20
.1a4608	48		pha		            PHA
.1a4609	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a460c	5b		tcd		            TCD
.1a460d	68		pla		            PLA
.1a460e	28		plp		            PLP
.1a460f	e2 20		sep #$20	            SEP #$20
.1a4611	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4613	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4617	c2 20		rep #$20	            REP #$20
.1a4619	29 ff 00	and #$00ff	            AND #$00FF
.1a461c	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a461f	e2 20		sep #$20	            SEP #$20
.1a4621	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4624					FN_RIGHT
.1a4624	e2 20		sep #$20	            SEP #$20
.1a4626	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4628	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a462b	08		php		                PHP
.1a462c	c2 30		rep #$30	            REP #$30
.1a462e	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4631	e2 20		sep #$20	            SEP #$20
.1a4633	a5 27		lda $0827	                LDA ARGTYPE1
.1a4635	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4637	f0 03		beq $1a463c	                BEQ save_string
.1a4639	4c a8 46	jmp $1a46a8	                JMP type_mismatch           ; Type mismatch if it's not a string
.1a463c					save_string
.1a463c	c2 20		rep #$20	            REP #$20
.1a463e	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.1a4640	48		pha		                PHA
.1a4641	a5 23		lda $0823	                LDA ARGUMENT1
.1a4643	48		pha		                PHA
.1a4644	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a4647	e2 20		sep #$20	            SEP #$20
.1a4649	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a464b	c9 2c		cmp #$2c	                CMP #','
.1a464d	f0 03		beq $1a4652	                BEQ skip_comma
.1a464f	4c c7 46	jmp $1a46c7	                JMP syntax_err
.1a4652					skip_comma
.1a4652	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4655	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4658	e2 20		sep #$20	            SEP #$20
.1a465a	a5 27		lda $0827	                LDA ARGTYPE1
.1a465c	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a465e	d0 48		bne $1a46a8	                BNE type_mismatch           ; Type mismatch if it's not an integer
.1a4660	c2 20		rep #$20	            REP #$20
.1a4662	a5 23		lda $0823	            LDA ARGUMENT1
.1a4664	85 8f		sta $088f	            STA MCOUNT
.1a4666	c2 20		rep #$20	            REP #$20
.1a4668	68		pla		                PLA                         ; Recover the string pointer
.1a4669	85 23		sta $0823	                STA ARGUMENT1
.1a466b	68		pla		                PLA
.1a466c	85 25		sta $0825	                STA ARGUMENT1+2
.1a466e	e2 20		sep #$20	            SEP #$20
.1a4670	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a4672	85 27		sta $0827	            STA ARGTYPE1
.1a4674	e2 20		sep #$20	            SEP #$20
.1a4676	a0 00 00	ldy #$0000	                LDY #0
.1a4679	b7 23		lda [$0823],y	count_loop      LDA [ARGUMENT1],Y
.1a467b	f0 03		beq $1a4680	                BEQ count_done
.1a467d	c8		iny		                INY
.1a467e	80 f9		bra $1a4679	                BRA count_loop
.1a4680					count_done
.1a4680	c2 20		rep #$20	            REP #$20
.1a4682	98		tya		                TYA                         ; ARGUMENT2 := LENGTH - MCOUNT
.1a4683	38		sec		                SEC
.1a4684	e5 8f		sbc $088f	                SBC MCOUNT
.1a4686	30 09		bmi $1a4691	                BMI index0                  ; if ARGUMENT2 < 0, set ARGUMENT2 := 0
.1a4688	85 29		sta $0829	                STA ARGUMENT2
.1a468a	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT2[23..16] := 0
.1a468d	85 2b		sta $082b	                STA ARGUMENT2+2
.1a468f	80 07		bra $1a4698	                BRA slice
.1a4691	a9 00 00	lda #$0000	index0          LDA #0                      ; 0 is the floor for the index
.1a4694	85 29		sta $0829	                STA ARGUMENT2
.1a4696	85 2b		sta $082b	                STA ARGUMENT2+2
.1a4698					slice
.1a4698	e2 20		sep #$20	            SEP #$20
.1a469a	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a469c	85 2d		sta $082d	            STA ARGTYPE2
.1a469e	20 06 16	jsr $1a1606	            JSR STRSUBSTR
.1a46a1					done
.1a46a1	e2 20		sep #$20	            SEP #$20
.1a46a3	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a46a6	28		plp		                PLP
.1a46a7	60		rts		            RTS
.1a46a8					type_mismatch
.1a46a8	08		php		            PHP
.1a46a9	c2 20		rep #$20	            REP #$20
.1a46ab	48		pha		            PHA
.1a46ac	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a46af	5b		tcd		            TCD
.1a46b0	68		pla		            PLA
.1a46b1	28		plp		            PLP
.1a46b2	e2 20		sep #$20	            SEP #$20
.1a46b4	a9 04		lda #$04	            LDA #ERR_TYPE
.1a46b6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a46ba	c2 20		rep #$20	            REP #$20
.1a46bc	29 ff 00	and #$00ff	            AND #$00FF
.1a46bf	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a46c2	e2 20		sep #$20	            SEP #$20
.1a46c4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a46c7					syntax_err
.1a46c7	08		php		            PHP
.1a46c8	c2 20		rep #$20	            REP #$20
.1a46ca	48		pha		            PHA
.1a46cb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a46ce	5b		tcd		            TCD
.1a46cf	68		pla		            PLA
.1a46d0	28		plp		            PLP
.1a46d1	e2 20		sep #$20	            SEP #$20
.1a46d3	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a46d5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a46d9	c2 20		rep #$20	            REP #$20
.1a46db	29 ff 00	and #$00ff	            AND #$00FF
.1a46de	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a46e1	e2 20		sep #$20	            SEP #$20
.1a46e3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a46e6					range_err
.1a46e6	08		php		            PHP
.1a46e7	c2 20		rep #$20	            REP #$20
.1a46e9	48		pha		            PHA
.1a46ea	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a46ed	5b		tcd		            TCD
.1a46ee	68		pla		            PLA
.1a46ef	28		plp		            PLP
.1a46f0	e2 20		sep #$20	            SEP #$20
.1a46f2	a9 09		lda #$09	            LDA #ERR_RANGE
.1a46f4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a46f8	c2 20		rep #$20	            REP #$20
.1a46fa	29 ff 00	and #$00ff	            AND #$00FF
.1a46fd	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a4700	e2 20		sep #$20	            SEP #$20
.1a4702	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4705					FN_LEFT
.1a4705	e2 20		sep #$20	            SEP #$20
.1a4707	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4709	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a470c	08		php		                PHP
.1a470d	c2 30		rep #$30	            REP #$30
.1a470f	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4712	e2 20		sep #$20	            SEP #$20
.1a4714	a5 27		lda $0827	                LDA ARGTYPE1
.1a4716	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4718	f0 03		beq $1a471d	                BEQ save_string
.1a471a	4c 71 47	jmp $1a4771	                JMP type_mismatch           ; Type mismatch if it's not a string
.1a471d					save_string
.1a471d	c2 20		rep #$20	            REP #$20
.1a471f	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.1a4721	48		pha		                PHA
.1a4722	a5 23		lda $0823	                LDA ARGUMENT1
.1a4724	48		pha		                PHA
.1a4725	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a4728	e2 20		sep #$20	            SEP #$20
.1a472a	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.1a472c	c9 2c		cmp #$2c	                CMP #','
.1a472e	f0 03		beq $1a4733	                BEQ skip_comma
.1a4730	4c 90 47	jmp $1a4790	                JMP syntax_err
.1a4733					skip_comma
.1a4733	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4736	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4739	e2 20		sep #$20	            SEP #$20
.1a473b	a5 27		lda $0827	                LDA ARGTYPE1
.1a473d	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a473f	d0 30		bne $1a4771	                BNE type_mismatch           ; Type mismatch if it's not an integer
.1a4741	c2 20		rep #$20	            REP #$20
.1a4743	a5 23		lda $0823	            LDA ARGUMENT1
.1a4745	85 8f		sta $088f	            STA MCOUNT
.1a4747	c2 20		rep #$20	            REP #$20
.1a4749	a9 00 00	lda #$0000	            LDA #<>0
.1a474c	85 29		sta $0829	            STA ARGUMENT2
.1a474e	a9 00 00	lda #$0000	            LDA #(0 >> 16)
.1a4751	85 2b		sta $082b	            STA ARGUMENT2+2
.1a4753	e2 20		sep #$20	            SEP #$20
.1a4755	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.1a4757	85 2d		sta $082d	            STA ARGTYPE2
.1a4759	c2 20		rep #$20	            REP #$20
.1a475b	68		pla		                PLA                         ; Recover the string pointer
.1a475c	85 23		sta $0823	                STA ARGUMENT1
.1a475e	68		pla		                PLA
.1a475f	85 25		sta $0825	                STA ARGUMENT1+2
.1a4761	e2 20		sep #$20	            SEP #$20
.1a4763	a9 02		lda #$02	            LDA #<TYPE_STRING
.1a4765	85 27		sta $0827	            STA ARGTYPE1
.1a4767	20 06 16	jsr $1a1606	            JSR STRSUBSTR
.1a476a					done
.1a476a	e2 20		sep #$20	            SEP #$20
.1a476c	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a476f	28		plp		                PLP
.1a4770	60		rts		            RTS
.1a4771					type_mismatch
.1a4771	08		php		            PHP
.1a4772	c2 20		rep #$20	            REP #$20
.1a4774	48		pha		            PHA
.1a4775	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4778	5b		tcd		            TCD
.1a4779	68		pla		            PLA
.1a477a	28		plp		            PLP
.1a477b	e2 20		sep #$20	            SEP #$20
.1a477d	a9 04		lda #$04	            LDA #ERR_TYPE
.1a477f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4783	c2 20		rep #$20	            REP #$20
.1a4785	29 ff 00	and #$00ff	            AND #$00FF
.1a4788	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a478b	e2 20		sep #$20	            SEP #$20
.1a478d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4790					syntax_err
.1a4790	08		php		            PHP
.1a4791	c2 20		rep #$20	            REP #$20
.1a4793	48		pha		            PHA
.1a4794	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4797	5b		tcd		            TCD
.1a4798	68		pla		            PLA
.1a4799	28		plp		            PLP
.1a479a	e2 20		sep #$20	            SEP #$20
.1a479c	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a479e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a47a2	c2 20		rep #$20	            REP #$20
.1a47a4	29 ff 00	and #$00ff	            AND #$00FF
.1a47a7	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a47aa	e2 20		sep #$20	            SEP #$20
.1a47ac	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a47af					range_err
.1a47af	08		php		            PHP
.1a47b0	c2 20		rep #$20	            REP #$20
.1a47b2	48		pha		            PHA
.1a47b3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a47b6	5b		tcd		            TCD
.1a47b7	68		pla		            PLA
.1a47b8	28		plp		            PLP
.1a47b9	e2 20		sep #$20	            SEP #$20
.1a47bb	a9 09		lda #$09	            LDA #ERR_RANGE
.1a47bd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a47c1	c2 20		rep #$20	            REP #$20
.1a47c3	29 ff 00	and #$00ff	            AND #$00FF
.1a47c6	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a47c9	e2 20		sep #$20	            SEP #$20
.1a47cb	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a47ce					FN_VAL
.1a47ce	e2 20		sep #$20	            SEP #$20
.1a47d0	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a47d2	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a47d5	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a47d8	c2 10		rep #$10	            REP #$10
.1a47da	e2 20		sep #$20	            SEP #$20
.1a47dc	a5 27		lda $0827	                LDA ARGTYPE1
.1a47de	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a47e0	d0 23		bne $1a4805	                BNE type_mismatch
.1a47e2	c2 20		rep #$20	            REP #$20
.1a47e4	a5 00		lda $0800	                LDA BIP             ; preserve BIP for later
.1a47e6	85 40		sta $0840	                STA SAVEBIP
.1a47e8	a5 02		lda $0802	                LDA BIP+2
.1a47ea	85 42		sta $0842	                STA SAVEBIP+2
.1a47ec	a5 23		lda $0823	                LDA ARGUMENT1       ; Temporarily point BIP to the string to parse
.1a47ee	85 00		sta $0800	                STA BIP
.1a47f0	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a47f2	85 02		sta $0802	                STA BIP+2
.1a47f4	20 8a 07	jsr $1a078a	            JSR PARSEINT
.1a47f7	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.1a47f9	85 00		sta $0800	                STA BIP
.1a47fb	a5 42		lda $0842	                LDA SAVEBIP+2
.1a47fd	85 02		sta $0802	                STA BIP+2
.1a47ff	e2 20		sep #$20	            SEP #$20
.1a4801	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4804	60		rts		            RTS
.1a4805					type_mismatch
.1a4805	08		php		            PHP
.1a4806	c2 20		rep #$20	            REP #$20
.1a4808	48		pha		            PHA
.1a4809	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a480c	5b		tcd		            TCD
.1a480d	68		pla		            PLA
.1a480e	28		plp		            PLP
.1a480f	e2 20		sep #$20	            SEP #$20
.1a4811	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4813	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4817	c2 20		rep #$20	            REP #$20
.1a4819	29 ff 00	and #$00ff	            AND #$00FF
.1a481c	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a481f	e2 20		sep #$20	            SEP #$20
.1a4821	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4824					FN_STR
.1a4824	e2 20		sep #$20	            SEP #$20
.1a4826	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4828	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a482b	08		php		                PHP
.1a482c	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a482f	c2 10		rep #$10	            REP #$10
.1a4831	e2 20		sep #$20	            SEP #$20
.1a4833	a5 27		lda $0827	                LDA ARGTYPE1
.1a4835	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4837	d0 1a		bne $1a4853	                BNE type_mismatch
.1a4839	20 0d 14	jsr $1a140d	            JSR ITOS
.1a483c	c2 20		rep #$20	            REP #$20
.1a483e	a5 16		lda $0816	                LDA STRPTR          ; Prepare the return result
.1a4840	85 23		sta $0823	                STA ARGUMENT1
.1a4842	a5 18		lda $0818	                LDA STRPTR+2
.1a4844	85 25		sta $0825	                STA ARGUMENT1+2
.1a4846	e2 20		sep #$20	            SEP #$20
.1a4848	a9 02		lda #$02	                LDA #TYPE_STRING
.1a484a	85 27		sta $0827	                STA ARGTYPE1
.1a484c	28		plp		                PLP
.1a484d	e2 20		sep #$20	            SEP #$20
.1a484f	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4852	60		rts		            RTS
.1a4853					type_mismatch
.1a4853	08		php		            PHP
.1a4854	c2 20		rep #$20	            REP #$20
.1a4856	48		pha		            PHA
.1a4857	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a485a	5b		tcd		            TCD
.1a485b	68		pla		            PLA
.1a485c	28		plp		            PLP
.1a485d	e2 20		sep #$20	            SEP #$20
.1a485f	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4861	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4865	c2 20		rep #$20	            REP #$20
.1a4867	29 ff 00	and #$00ff	            AND #$00FF
.1a486a	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a486d	e2 20		sep #$20	            SEP #$20
.1a486f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4872					FN_DEC
.1a4872	e2 20		sep #$20	            SEP #$20
.1a4874	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4876	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4879	08		php		                PHP
.1a487a	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a487d	20 95 05	jsr $1a0595	            JSR ASS_ARG1_STR
.1a4880	c2 20		rep #$20	            REP #$20
.1a4882	64 0c		stz $080c	                STZ SCRATCH
.1a4884	64 0e		stz $080e	                STZ SCRATCH+2
.1a4886	e2 30		sep #$30	            SEP #$30
.1a4888	a0 00		ldy #$00	                LDY #0
.1a488a	b7 23		lda [$0823],y	skip_loop       LDA [ARGUMENT1],Y
.1a488c	c9 20		cmp #$20	                CMP #CHAR_SP
.1a488e	f0 04		beq $1a4894	                BEQ skip_char
.1a4890	c9 24		cmp #$24	                CMP #'$'
.1a4892	d0 03		bne $1a4897	                BNE loop
.1a4894	c8		iny		skip_char       INY
.1a4895	80 f3		bra $1a488a	                BRA skip_loop
.1a4897	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y   ; Check the character
.1a4899	20 be 03	jsr $1a03be	            JSR ISHEX
.1a489c	90 1e		bcc $1a48bc	                BCC ret_result      ; No: return what we have so far
.1a489e	c2 20		rep #$20	            REP #$20
.1a48a0	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a48a2	26 0e		rol $080e	                ROL SCRATCH+2
.1a48a4	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a48a6	26 0e		rol $080e	                ROL SCRATCH+2
.1a48a8	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a48aa	26 0e		rol $080e	                ROL SCRATCH+2
.1a48ac	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.1a48ae	26 0e		rol $080e	                ROL SCRATCH+2
.1a48b0	e2 20		sep #$20	            SEP #$20
.1a48b2	20 df 03	jsr $1a03df	            JSR HEX2BIN
.1a48b5	05 0c		ora $080c	                ORA SCRATCH
.1a48b7	85 0c		sta $080c	                STA SCRATCH         ; And add it to the result
.1a48b9	c8		iny		                INY
.1a48ba	80 db		bra $1a4897	                BRA loop            ; And try the next character
.1a48bc					ret_result
.1a48bc	c2 20		rep #$20	            REP #$20
.1a48be	a5 0c		lda $080c	                LDA SCRATCH         ; Return the result
.1a48c0	85 23		sta $0823	                STA ARGUMENT1
.1a48c2	a5 0e		lda $080e	                LDA SCRATCH+2
.1a48c4	85 25		sta $0825	                STA ARGUMENT1+2
.1a48c6	e2 20		sep #$20	            SEP #$20
.1a48c8	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a48ca	85 27		sta $0827	                STA ARGTYPE1
.1a48cc	28		plp		                PLP
.1a48cd	e2 20		sep #$20	            SEP #$20
.1a48cf	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a48d2	60		rts		            RTS
.1a48d3					FN_HEX
.1a48d3	e2 20		sep #$20	            SEP #$20
.1a48d5	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a48d7	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a48da	08		php		                PHP
.1a48db	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a48de	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a48e1	20 ae 13	jsr $1a13ae	            JSR TEMPSTRING
.1a48e4	e2 30		sep #$30	            SEP #$30
.1a48e6	a0 ff		ldy #$ff	                LDY #$FF            ; Terminate the string
.1a48e8	a9 00		lda #$00	                LDA #0
.1a48ea	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a48ec	88		dey		                DEY
.1a48ed	a5 23		lda $0823	loop            LDA ARGUMENT1       ; Write the low digit
.1a48ef	29 0f		and #$0f	                AND #$0F
.1a48f1	aa		tax		                TAX
.1a48f2	bf 00 d0 1a	lda $1ad000,x	                LDA @lHEXDIGITS,X
.1a48f6	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a48f8	88		dey		                DEY
.1a48f9	a5 23		lda $0823	                LDA ARGUMENT1       ; Write the high digit
.1a48fb	29 f0		and #$f0	                AND #$F0
.1a48fd	4a		lsr a		                LSR A
.1a48fe	4a		lsr a		                LSR A
.1a48ff	4a		lsr a		                LSR A
.1a4900	4a		lsr a		                LSR A
.1a4901	aa		tax		                TAX
.1a4902	bf 00 d0 1a	lda $1ad000,x	                LDA @lHEXDIGITS,X
.1a4906	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4908	88		dey		                DEY
.1a4909	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Shift value by one byte
.1a490b	85 23		sta $0823	                STA ARGUMENT1
.1a490d	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a490f	85 24		sta $0824	                STA ARGUMENT1+1
.1a4911	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a4913	85 25		sta $0825	                STA ARGUMENT1+2
.1a4915	a9 00		lda #$00	                LDA #0
.1a4917	85 26		sta $0826	                STA ARGUMENT1+3
.1a4919	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the argument 0?
.1a491b	d0 d0		bne $1a48ed	                BNE loop            ; No: keep converting
.1a491d	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a491f	d0 cc		bne $1a48ed	                BNE loop
.1a4921	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4923	d0 c8		bne $1a48ed	                BNE loop
.1a4925	98		tya		                TYA                 ; Get the index of the first free char
.1a4926	38		sec		                SEC                 ; Add 1 to get to the first character of the string
.1a4927	65 16		adc $0816	                ADC STRPTR          ; And add the whole thing to the temp string pointer
.1a4929	85 23		sta $0823	                STA ARGUMENT1       ; And return it as the result
.1a492b	a5 17		lda $0817	                LDA STRPTR+1
.1a492d	85 24		sta $0824	                STA ARGUMENT1+1
.1a492f	a5 18		lda $0818	                LDA STRPTR+2
.1a4931	85 25		sta $0825	                STA ARGUMENT1+2
.1a4933	a5 19		lda $0819	                LDA STRPTR+3
.1a4935	85 26		sta $0826	                STA ARGUMENT1+3
.1a4937	a9 02		lda #$02	                LDA #TYPE_STRING    ; And make the type STRING
.1a4939	85 27		sta $0827	                STA ARGTYPE1
.1a493b	28		plp		                PLP
.1a493c	e2 20		sep #$20	            SEP #$20
.1a493e	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4941	60		rts		            RTS
.1a4942					type_mismatch
.1a4942	08		php		            PHP
.1a4943	c2 20		rep #$20	            REP #$20
.1a4945	48		pha		            PHA
.1a4946	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4949	5b		tcd		            TCD
.1a494a	68		pla		            PLA
.1a494b	28		plp		            PLP
.1a494c	e2 20		sep #$20	            SEP #$20
.1a494e	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4950	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4954	c2 20		rep #$20	            REP #$20
.1a4956	29 ff 00	and #$00ff	            AND #$00FF
.1a4959	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a495c	e2 20		sep #$20	            SEP #$20
.1a495e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4961					FN_LEN
.1a4961	e2 20		sep #$20	            SEP #$20
.1a4963	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4965	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4968	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a496b	e2 20		sep #$20	            SEP #$20
.1a496d	a5 27		lda $0827	                LDA ARGTYPE1
.1a496f	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4971	d0 1f		bne $1a4992	                BNE type_mismatch
.1a4973	8b		phb		                PHB                 ; Set the data bank to the data bank of the string
.1a4974	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4976	48		pha		                PHA
.1a4977	ab		plb		                PLB
.1a4978	c2 10		rep #$10	            REP #$10
.1a497a	a6 23		ldx $0823	                LDX ARGUMENT1       ; And point X to the string data
.1a497c	20 9a 14	jsr $1a149a	            JSR STRLEN
.1a497f	ab		plb		                PLB                 ; Restore the old data bank
.1a4980	84 23		sty $0823	                STY ARGUMENT1       ; Save the length to ARGUMENT1
.1a4982	c2 20		rep #$20	            REP #$20
.1a4984	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4986	e2 20		sep #$20	            SEP #$20
.1a4988	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the type to INTEGER
.1a498a	85 27		sta $0827	                STA ARGTYPE1
.1a498c	e2 20		sep #$20	            SEP #$20
.1a498e	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4991	60		rts		            RTS
.1a4992					type_mismatch
.1a4992	08		php		            PHP
.1a4993	c2 20		rep #$20	            REP #$20
.1a4995	48		pha		            PHA
.1a4996	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4999	5b		tcd		            TCD
.1a499a	68		pla		            PLA
.1a499b	28		plp		            PLP
.1a499c	e2 20		sep #$20	            SEP #$20
.1a499e	a9 04		lda #$04	            LDA #ERR_TYPE
.1a49a0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a49a4	c2 20		rep #$20	            REP #$20
.1a49a6	29 ff 00	and #$00ff	            AND #$00FF
.1a49a9	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a49ac	e2 20		sep #$20	            SEP #$20
.1a49ae	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a49b1					FN_PEEK
.1a49b1	e2 20		sep #$20	            SEP #$20
.1a49b3	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a49b5	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a49b8	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a49bb	e2 20		sep #$20	            SEP #$20
.1a49bd	a5 27		lda $0827	                LDA ARGTYPE1
.1a49bf	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a49c1	d0 12		bne $1a49d5	                BNE type_mismatch
.1a49c3	e2 20		sep #$20	            SEP #$20
.1a49c5	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.1a49c7	85 23		sta $0823	                STA ARGUMENT1
.1a49c9	64 24		stz $0824	                STZ ARGUMENT1+1
.1a49cb	64 25		stz $0825	                STZ ARGUMENT1+2
.1a49cd	64 30		stz $0830	                STZ ARGUMENT1+13
.1a49cf	e2 20		sep #$20	            SEP #$20
.1a49d1	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a49d4	60		rts		            RTS
.1a49d5					type_mismatch
.1a49d5	08		php		            PHP
.1a49d6	c2 20		rep #$20	            REP #$20
.1a49d8	48		pha		            PHA
.1a49d9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a49dc	5b		tcd		            TCD
.1a49dd	68		pla		            PLA
.1a49de	28		plp		            PLP
.1a49df	e2 20		sep #$20	            SEP #$20
.1a49e1	a9 04		lda #$04	            LDA #ERR_TYPE
.1a49e3	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a49e7	c2 20		rep #$20	            REP #$20
.1a49e9	29 ff 00	and #$00ff	            AND #$00FF
.1a49ec	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a49ef	e2 20		sep #$20	            SEP #$20
.1a49f1	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a49f4					FN_PEEKL
.1a49f4	e2 20		sep #$20	            SEP #$20
.1a49f6	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a49f8	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a49fb	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a49fe	e2 20		sep #$20	            SEP #$20
.1a4a00	a5 27		lda $0827	                LDA ARGTYPE1
.1a4a02	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4a04	d0 1d		bne $1a4a23	                BNE type_mismatch
.1a4a06	c2 20		rep #$20	            REP #$20
.1a4a08	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.1a4a0a	85 0c		sta $080c	                STA SCRATCH
.1a4a0c	e2 20		sep #$20	            SEP #$20
.1a4a0e	a0 02 00	ldy #$0002	                LDY #2
.1a4a11	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y
.1a4a13	85 25		sta $0825	                STA ARGUMENT1+2
.1a4a15	64 26		stz $0826	                STZ ARGUMENT1+3
.1a4a17	c2 20		rep #$20	            REP #$20
.1a4a19	a5 0c		lda $080c	                LDA SCRATCH
.1a4a1b	85 23		sta $0823	                STA ARGUMENT1
.1a4a1d	e2 20		sep #$20	            SEP #$20
.1a4a1f	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4a22	60		rts		            RTS
.1a4a23					type_mismatch
.1a4a23	08		php		            PHP
.1a4a24	c2 20		rep #$20	            REP #$20
.1a4a26	48		pha		            PHA
.1a4a27	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4a2a	5b		tcd		            TCD
.1a4a2b	68		pla		            PLA
.1a4a2c	28		plp		            PLP
.1a4a2d	e2 20		sep #$20	            SEP #$20
.1a4a2f	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4a31	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4a35	c2 20		rep #$20	            REP #$20
.1a4a37	29 ff 00	and #$00ff	            AND #$00FF
.1a4a3a	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a4a3d	e2 20		sep #$20	            SEP #$20
.1a4a3f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4a42					FN_PEEKW
.1a4a42	e2 20		sep #$20	            SEP #$20
.1a4a44	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4a46	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4a49	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4a4c	e2 20		sep #$20	            SEP #$20
.1a4a4e	a5 27		lda $0827	                LDA ARGTYPE1
.1a4a50	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4a52	d0 0e		bne $1a4a62	                BNE type_mismatch
.1a4a54	c2 20		rep #$20	            REP #$20
.1a4a56	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.1a4a58	85 23		sta $0823	                STA ARGUMENT1
.1a4a5a	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4a5c	e2 20		sep #$20	            SEP #$20
.1a4a5e	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4a61	60		rts		            RTS
.1a4a62					type_mismatch
.1a4a62	08		php		            PHP
.1a4a63	c2 20		rep #$20	            REP #$20
.1a4a65	48		pha		            PHA
.1a4a66	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4a69	5b		tcd		            TCD
.1a4a6a	68		pla		            PLA
.1a4a6b	28		plp		            PLP
.1a4a6c	e2 20		sep #$20	            SEP #$20
.1a4a6e	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4a70	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4a74	c2 20		rep #$20	            REP #$20
.1a4a76	29 ff 00	and #$00ff	            AND #$00FF
.1a4a79	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a4a7c	e2 20		sep #$20	            SEP #$20
.1a4a7e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4a81					FN_CHR
.1a4a81	e2 20		sep #$20	            SEP #$20
.1a4a83	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4a85	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4a88	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4a8b	e2 20		sep #$20	            SEP #$20
.1a4a8d	a5 27		lda $0827	                LDA ARGTYPE1
.1a4a8f	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4a91	d0 24		bne $1a4ab7	                BNE type_mismatch
.1a4a93	20 ae 13	jsr $1a13ae	            JSR TEMPSTRING
.1a4a96	a5 23		lda $0823	                LDA ARGUMENT1       ; Get the numberic value
.1a4a98	87 16		sta [$0816]	                STA [STRPTR]        ; And save it as the first character
.1a4a9a	a9 00		lda #$00	                LDA #0              ; Null terminate the string
.1a4a9c	a0 01 00	ldy #$0001	                LDY #1
.1a4a9f	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a4aa1	c2 20		rep #$20	            REP #$20
.1a4aa3	a5 16		lda $0816	                LDA STRPTR
.1a4aa5	85 23		sta $0823	                STA ARGUMENT1
.1a4aa7	a5 18		lda $0818	                LDA STRPTR+2
.1a4aa9	85 25		sta $0825	                STA ARGUMENT1+2
.1a4aab	e2 20		sep #$20	            SEP #$20
.1a4aad	a9 02		lda #$02	                LDA #TYPE_STRING
.1a4aaf	85 27		sta $0827	                STA ARGTYPE1
.1a4ab1	e2 20		sep #$20	            SEP #$20
.1a4ab3	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4ab6	60		rts		            RTS
.1a4ab7					type_mismatch
.1a4ab7	08		php		            PHP
.1a4ab8	c2 20		rep #$20	            REP #$20
.1a4aba	48		pha		            PHA
.1a4abb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4abe	5b		tcd		            TCD
.1a4abf	68		pla		            PLA
.1a4ac0	28		plp		            PLP
.1a4ac1	e2 20		sep #$20	            SEP #$20
.1a4ac3	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4ac5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4ac9	c2 20		rep #$20	            REP #$20
.1a4acb	29 ff 00	and #$00ff	            AND #$00FF
.1a4ace	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a4ad1	e2 20		sep #$20	            SEP #$20
.1a4ad3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4ad6					FN_ASC
.1a4ad6	e2 20		sep #$20	            SEP #$20
.1a4ad8	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4ada	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4add	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4ae0	e2 20		sep #$20	            SEP #$20
.1a4ae2	a5 27		lda $0827	                LDA ARGTYPE1
.1a4ae4	c9 02		cmp #$02	                CMP #TYPE_STRING
.1a4ae6	d0 14		bne $1a4afc	                BNE type_mismatch
.1a4ae8	a7 23		lda [$0823]	                LDA [ARGUMENT1]     ; Get the character
.1a4aea	85 23		sta $0823	                STA ARGUMENT1       ; Save its code to ARGUMENT1
.1a4aec	64 24		stz $0824	                STZ ARGUMENT1+1
.1a4aee	64 25		stz $0825	                STZ ARGUMENT1+2
.1a4af0	64 26		stz $0826	                STZ ARGUMENT1+3
.1a4af2	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the return type to integer
.1a4af4	85 27		sta $0827	                STA ARGTYPE1
.1a4af6	e2 20		sep #$20	            SEP #$20
.1a4af8	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4afb	60		rts		            RTS
.1a4afc					type_mismatch
.1a4afc	08		php		            PHP
.1a4afd	c2 20		rep #$20	            REP #$20
.1a4aff	48		pha		            PHA
.1a4b00	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4b03	5b		tcd		            TCD
.1a4b04	68		pla		            PLA
.1a4b05	28		plp		            PLP
.1a4b06	e2 20		sep #$20	            SEP #$20
.1a4b08	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4b0a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4b0e	c2 20		rep #$20	            REP #$20
.1a4b10	29 ff 00	and #$00ff	            AND #$00FF
.1a4b13	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a4b16	e2 20		sep #$20	            SEP #$20
.1a4b18	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4b1b					FN_SPC
.1a4b1b	e2 20		sep #$20	            SEP #$20
.1a4b1d	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4b1f	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4b22	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4b25	e2 20		sep #$20	            SEP #$20
.1a4b27	a5 27		lda $0827	                LDA ARGTYPE1
.1a4b29	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4b2b	d0 39		bne $1a4b66	                BNE type_mismatch
.1a4b2d	e2 20		sep #$20	            SEP #$20
.1a4b2f	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.1a4b31	d0 52		bne $1a4b85	                BNE err_limit
.1a4b33	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4b35	d0 4e		bne $1a4b85	                BNE err_limit
.1a4b37	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a4b39	d0 4a		bne $1a4b85	                BNE err_limit
.1a4b3b	c2 10		rep #$10	            REP #$10
.1a4b3d	20 ae 13	jsr $1a13ae	            JSR TEMPSTRING
.1a4b40	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.1a4b42	e2 20		sep #$20	            SEP #$20
.1a4b44	a9 00		lda #$00	                LDA #0
.1a4b46	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.1a4b48	88		dey		                DEY
.1a4b49	30 07		bmi $1a4b52	                BMI done
.1a4b4b	a9 20		lda #$20	                LDA #CHAR_SP
.1a4b4d	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.1a4b4f	88		dey		                DEY
.1a4b50	10 fb		bpl $1a4b4d	                BPL loop            ; And keep writing until we're done
.1a4b52	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.1a4b54	85 27		sta $0827	                STA ARGTYPE1
.1a4b56	c2 20		rep #$20	            REP #$20
.1a4b58	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.1a4b5a	85 23		sta $0823	                STA ARGUMENT1
.1a4b5c	a5 18		lda $0818	                LDA STRPTR+2
.1a4b5e	85 25		sta $0825	                STA ARGUMENT1+2
.1a4b60	e2 20		sep #$20	            SEP #$20
.1a4b62	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4b65	60		rts		            RTS
.1a4b66					type_mismatch
.1a4b66	08		php		            PHP
.1a4b67	c2 20		rep #$20	            REP #$20
.1a4b69	48		pha		            PHA
.1a4b6a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4b6d	5b		tcd		            TCD
.1a4b6e	68		pla		            PLA
.1a4b6f	28		plp		            PLP
.1a4b70	e2 20		sep #$20	            SEP #$20
.1a4b72	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4b74	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4b78	c2 20		rep #$20	            REP #$20
.1a4b7a	29 ff 00	and #$00ff	            AND #$00FF
.1a4b7d	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a4b80	e2 20		sep #$20	            SEP #$20
.1a4b82	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4b85					err_limit
.1a4b85	08		php		            PHP
.1a4b86	c2 20		rep #$20	            REP #$20
.1a4b88	48		pha		            PHA
.1a4b89	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4b8c	5b		tcd		            TCD
.1a4b8d	68		pla		            PLA
.1a4b8e	28		plp		            PLP
.1a4b8f	e2 20		sep #$20	            SEP #$20
.1a4b91	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4b93	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4b97	c2 20		rep #$20	            REP #$20
.1a4b99	29 ff 00	and #$00ff	            AND #$00FF
.1a4b9c	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a4b9f	e2 20		sep #$20	            SEP #$20
.1a4ba1	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4ba4					FN_TAB
.1a4ba4	e2 20		sep #$20	            SEP #$20
.1a4ba6	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4ba8	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4bab	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4bae	e2 20		sep #$20	            SEP #$20
.1a4bb0	a5 27		lda $0827	                LDA ARGTYPE1
.1a4bb2	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4bb4	d0 39		bne $1a4bef	                BNE type_mismatch
.1a4bb6	e2 20		sep #$20	            SEP #$20
.1a4bb8	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.1a4bba	d0 52		bne $1a4c0e	                BNE err_limit
.1a4bbc	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4bbe	d0 4e		bne $1a4c0e	                BNE err_limit
.1a4bc0	a5 24		lda $0824	                LDA ARGUMENT1+1
.1a4bc2	d0 4a		bne $1a4c0e	                BNE err_limit
.1a4bc4	c2 10		rep #$10	            REP #$10
.1a4bc6	20 ae 13	jsr $1a13ae	            JSR TEMPSTRING
.1a4bc9	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.1a4bcb	e2 20		sep #$20	            SEP #$20
.1a4bcd	a9 00		lda #$00	                LDA #0
.1a4bcf	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.1a4bd1	88		dey		                DEY
.1a4bd2	30 07		bmi $1a4bdb	                BMI done
.1a4bd4	a9 09		lda #$09	                LDA #CHAR_TAB
.1a4bd6	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.1a4bd8	88		dey		                DEY
.1a4bd9	10 fb		bpl $1a4bd6	                BPL loop            ; And keep writing until we're done
.1a4bdb	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.1a4bdd	85 27		sta $0827	                STA ARGTYPE1
.1a4bdf	c2 20		rep #$20	            REP #$20
.1a4be1	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.1a4be3	85 23		sta $0823	                STA ARGUMENT1
.1a4be5	a5 18		lda $0818	                LDA STRPTR+2
.1a4be7	85 25		sta $0825	                STA ARGUMENT1+2
.1a4be9	e2 20		sep #$20	            SEP #$20
.1a4beb	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4bee	60		rts		            RTS
.1a4bef					type_mismatch
.1a4bef	08		php		            PHP
.1a4bf0	c2 20		rep #$20	            REP #$20
.1a4bf2	48		pha		            PHA
.1a4bf3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4bf6	5b		tcd		            TCD
.1a4bf7	68		pla		            PLA
.1a4bf8	28		plp		            PLP
.1a4bf9	e2 20		sep #$20	            SEP #$20
.1a4bfb	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4bfd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4c01	c2 20		rep #$20	            REP #$20
.1a4c03	29 ff 00	and #$00ff	            AND #$00FF
.1a4c06	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a4c09	e2 20		sep #$20	            SEP #$20
.1a4c0b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4c0e					err_limit
.1a4c0e	08		php		            PHP
.1a4c0f	c2 20		rep #$20	            REP #$20
.1a4c11	48		pha		            PHA
.1a4c12	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4c15	5b		tcd		            TCD
.1a4c16	68		pla		            PLA
.1a4c17	28		plp		            PLP
.1a4c18	e2 20		sep #$20	            SEP #$20
.1a4c1a	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4c1c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4c20	c2 20		rep #$20	            REP #$20
.1a4c22	29 ff 00	and #$00ff	            AND #$00FF
.1a4c25	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a4c28	e2 20		sep #$20	            SEP #$20
.1a4c2a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4c2d					FN_ABS
.1a4c2d	e2 20		sep #$20	            SEP #$20
.1a4c2f	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4c31	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4c34	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4c37	e2 20		sep #$20	            SEP #$20
.1a4c39	a5 27		lda $0827	                LDA ARGTYPE1        ; Check the type
.1a4c3b	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4c3d	f0 23		beq $1a4c62	                BEQ abs_int         ; If integer, get the absolute value of the integer
.1a4c3f	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.1a4c41	f0 3e		beq $1a4c81	                BEQ abs_float       ; If float, get the absolute value of the float
.1a4c43					type_err
.1a4c43	08		php		            PHP
.1a4c44	c2 20		rep #$20	            REP #$20
.1a4c46	48		pha		            PHA
.1a4c47	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4c4a	5b		tcd		            TCD
.1a4c4b	68		pla		            PLA
.1a4c4c	28		plp		            PLP
.1a4c4d	e2 20		sep #$20	            SEP #$20
.1a4c4f	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4c51	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4c55	c2 20		rep #$20	            REP #$20
.1a4c57	29 ff 00	and #$00ff	            AND #$00FF
.1a4c5a	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a4c5d	e2 20		sep #$20	            SEP #$20
.1a4c5f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4c62					abs_int
.1a4c62	c2 20		rep #$20	            REP #$20
.1a4c64	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Is it positive already?
.1a4c66	10 21		bpl $1a4c89	                BPL done            ; Yes: we don't need to do anythign further
.1a4c68	49 ff ff	eor #$ffff	                EOR #$FFFF          ; Otherwise, take the two's compliment
.1a4c6b	85 25		sta $0825	                STA ARGUMENT1+2     ; Of ARGUMENT1
.1a4c6d	a5 23		lda $0823	                LDA ARGUMENT1
.1a4c6f	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a4c72	18		clc		                CLC
.1a4c73	69 01 00	adc #$0001	                ADC #1
.1a4c76	85 23		sta $0823	                STA ARGUMENT1       ; And save it back to ARGUMENT1
.1a4c78	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4c7a	69 00 00	adc #$0000	                ADC #0
.1a4c7d	85 25		sta $0825	                STA ARGUMENT1+2
.1a4c7f	80 08		bra $1a4c89	                BRA done
.1a4c81					abs_float
.1a4c81	e2 20		sep #$20	            SEP #$20
.1a4c83	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Just clear the sign bit
.1a4c85	29 7f		and #$7f	                AND #$7F
.1a4c87	85 26		sta $0826	                STA ARGUMENT1+3
.1a4c89					done
.1a4c89	e2 20		sep #$20	            SEP #$20
.1a4c8b	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4c8e	60		rts		            RTS
.1a4c8f					FN_SGN
.1a4c8f	e2 20		sep #$20	            SEP #$20
.1a4c91	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4c93	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4c96	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4c99	e2 20		sep #$20	            SEP #$20
.1a4c9b	a5 27		lda $0827	                LDA ARGTYPE1
.1a4c9d	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.1a4c9f	d0 25		bne $1a4cc6	                BNE type_mismatch
.1a4ca1	c2 20		rep #$20	            REP #$20
.1a4ca3	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a4ca5	30 12		bmi $1a4cb9	                BMI is_negative     ; Negative: return -1
.1a4ca7	d0 04		bne $1a4cad	                BNE is_positive     ; Is it not 0? Then return 1
.1a4ca9	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the lower word 0?
.1a4cab	f0 13		beq $1a4cc0	                BEQ done            ; Yes: the whole thing is zero: return 0
.1a4cad	a9 00 00	lda #$0000	is_positive     LDA #0              ; It's positive: return 1
.1a4cb0	85 25		sta $0825	                STA ARGUMENT1+2
.1a4cb2	a9 01 00	lda #$0001	                LDA #1
.1a4cb5	85 23		sta $0823	                STA ARGUMENT1
.1a4cb7	80 07		bra $1a4cc0	                BRA done
.1a4cb9	a9 ff ff	lda #$ffff	is_negative     LDA #$FFFF          ; It's negative: return -1
.1a4cbc	85 25		sta $0825	                STA ARGUMENT1+2
.1a4cbe	85 23		sta $0823	                STA ARGUMENT1
.1a4cc0					done
.1a4cc0	e2 20		sep #$20	            SEP #$20
.1a4cc2	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4cc5	60		rts		            RTS
.1a4cc6					type_mismatch
.1a4cc6	08		php		            PHP
.1a4cc7	c2 20		rep #$20	            REP #$20
.1a4cc9	48		pha		            PHA
.1a4cca	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4ccd	5b		tcd		            TCD
.1a4cce	68		pla		            PLA
.1a4ccf	28		plp		            PLP
.1a4cd0	e2 20		sep #$20	            SEP #$20
.1a4cd2	a9 04		lda #$04	            LDA #ERR_TYPE
.1a4cd4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4cd8	c2 20		rep #$20	            REP #$20
.1a4cda	29 ff 00	and #$00ff	            AND #$00FF
.1a4cdd	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a4ce0	e2 20		sep #$20	            SEP #$20
.1a4ce2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4ce5					FN_INT
.1a4ce5	e2 20		sep #$20	            SEP #$20
.1a4ce7	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4ce9	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4cec	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4cef	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a4cf2					done
.1a4cf2	e2 20		sep #$20	            SEP #$20
.1a4cf4	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4cf7	60		rts		            RTS
.1a4cf8					FN_SIN
.1a4cf8	e2 20		sep #$20	            SEP #$20
.1a4cfa	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4cfc	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4cff	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4d02	20 71 06	jsr $1a0671	            JSR ASS_ARG1_FLOAT
.1a4d05	20 b6 5f	jsr $1a5fb6	            JSR FP_SIN
.1a4d08					done
.1a4d08	e2 20		sep #$20	            SEP #$20
.1a4d0a	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4d0d	60		rts		            RTS
.1a4d0e					FN_COS
.1a4d0e	e2 20		sep #$20	            SEP #$20
.1a4d10	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4d12	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4d15	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4d18	20 71 06	jsr $1a0671	            JSR ASS_ARG1_FLOAT
.1a4d1b	20 e5 5f	jsr $1a5fe5	            JSR FP_COS
.1a4d1e					done
.1a4d1e	e2 20		sep #$20	            SEP #$20
.1a4d20	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4d23	60		rts		            RTS
.1a4d24					FN_TAN
.1a4d24	e2 20		sep #$20	            SEP #$20
.1a4d26	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4d28	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4d2b	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4d2e	20 71 06	jsr $1a0671	            JSR ASS_ARG1_FLOAT
.1a4d31	20 14 60	jsr $1a6014	            JSR FP_TAN
.1a4d34					done
.1a4d34	e2 20		sep #$20	            SEP #$20
.1a4d36	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4d39	60		rts		            RTS
.1a4d3a					FN_LN
.1a4d3a	e2 20		sep #$20	            SEP #$20
.1a4d3c	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4d3e	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4d41	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4d44	20 71 06	jsr $1a0671	            JSR ASS_ARG1_FLOAT
.1a4d47	20 42 60	jsr $1a6042	            JSR FP_LN
.1a4d4a					done
.1a4d4a	e2 20		sep #$20	            SEP #$20
.1a4d4c	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4d4f	60		rts		            RTS
.1a4d50					FN_ACOS
.1a4d50	e2 20		sep #$20	            SEP #$20
.1a4d52	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4d54	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4d57	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4d5a	20 71 06	jsr $1a0671	            JSR ASS_ARG1_FLOAT
.1a4d5d	20 6b 61	jsr $1a616b	            JSR FP_ACOS
.1a4d60					done
.1a4d60	e2 20		sep #$20	            SEP #$20
.1a4d62	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4d65	60		rts		            RTS
.1a4d66					FN_ASIN
.1a4d66	e2 20		sep #$20	            SEP #$20
.1a4d68	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4d6a	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4d6d	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4d70	20 71 06	jsr $1a0671	            JSR ASS_ARG1_FLOAT
.1a4d73	20 41 61	jsr $1a6141	            JSR FP_ASIN
.1a4d76					done
.1a4d76	e2 20		sep #$20	            SEP #$20
.1a4d78	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4d7b	60		rts		            RTS
.1a4d7c					FN_ATAN
.1a4d7c	e2 20		sep #$20	            SEP #$20
.1a4d7e	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4d80	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4d83	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4d86	20 71 06	jsr $1a0671	            JSR ASS_ARG1_FLOAT
.1a4d89	20 8d 61	jsr $1a618d	            JSR FP_ATAN
.1a4d8c					done
.1a4d8c	e2 20		sep #$20	            SEP #$20
.1a4d8e	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4d91	60		rts		            RTS
.1a4d92					FN_EXP
.1a4d92	e2 20		sep #$20	            SEP #$20
.1a4d94	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4d96	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4d99	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4d9c	20 71 06	jsr $1a0671	            JSR ASS_ARG1_FLOAT
.1a4d9f	20 21 62	jsr $1a6221	            JSR FP_EXP
.1a4da2					done
.1a4da2	e2 20		sep #$20	            SEP #$20
.1a4da4	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4da7	60		rts		            RTS
.1a4da8					FN_SQR
.1a4da8	e2 20		sep #$20	            SEP #$20
.1a4daa	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.1a4dac	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4daf	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a4db2	20 71 06	jsr $1a0671	            JSR ASS_ARG1_FLOAT
.1a4db5	20 a3 62	jsr $1a62a3	            JSR FP_SQR
.1a4db8					done
.1a4db8	e2 20		sep #$20	            SEP #$20
.1a4dba	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a4dbd	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\commands.s

.1a4dbe	00		brk #		CMD_MONITOR     BRK
.1a4dbf	ea		nop		                NOP
.1a4dc0	60		rts		            RTS
.1a4dc1					CMD_NEW
.1a4dc1	08		php		                PHP
.1a4dc2	0b		phd		                PHD
.1a4dc3	08		php		            PHP
.1a4dc4	c2 20		rep #$20	            REP #$20
.1a4dc6	48		pha		            PHA
.1a4dc7	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a4dca	5b		tcd		            TCD
.1a4dcb	68		pla		            PLA
.1a4dcc	28		plp		            PLP
.1a4dcd	c2 30		rep #$30	            REP #$30
.1a4dcf	c2 20		rep #$20	            REP #$20
.1a4dd1	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.1a4dd4	85 d9		sta $08d9	            STA LASTLINE
.1a4dd6	e2 20		sep #$20	            SEP #$20
.1a4dd8	a9 16		lda #$16	            LDA #`BASIC_BOT
.1a4dda	85 db		sta $08db	            STA LASTLINE+2
.1a4ddc	c2 30		rep #$30	            REP #$30
.1a4dde	a9 00 00	lda #$0000	                LDA #0
.1a4de1	a0 00 00	ldy #$0000	                LDY #LINE_LINK
.1a4de4	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.1a4de6	a0 02 00	ldy #$0002	                LDY #LINE_NUMBER
.1a4de9	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.1a4deb	a0 04 00	ldy #$0004	                LDY #LINE_TOKENS
.1a4dee	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.1a4df0	20 34 1f	jsr $1a1f34	            JSR CLRINTERP
.1a4df3	2b		pld		                PLD
.1a4df4	28		plp		                PLP
.1a4df5	60		rts		            RTS
.1a4df6					CMD_RUN
.1a4df6	8b		phb		                PHB
.1a4df7	08		php		                PHP
.1a4df8	c2 20		rep #$20	            REP #$20
.1a4dfa	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT            ; Point to the first line of the program
.1a4dfd	85 1a		sta $081a	                STA CURLINE
.1a4dff	a9 16 00	lda #$0016	                LDA #`BASIC_BOT
.1a4e02	85 1c		sta $081c	                STA CURLINE + 2
.1a4e04	20 34 1f	jsr $1a1f34	            JSR CLRINTERP
.1a4e07	20 13 22	jsr $1a2213	            JSR EXECPROGRAM
.1a4e0a	28		plp		                PLP
.1a4e0b	ab		plb		                PLB
.1a4e0c	60		rts		            RTS
.1a4e0d					CMD_LIST
.1a4e0d	08		php		                PHP
.1a4e0e	c2 20		rep #$20	            REP #$20
.1a4e10	64 55		stz $0855	                STZ MARG1               ; MARG1 is starting line number, default 0
.1a4e12	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.1a4e15	85 59		sta $0859	                STA MARG2               ; MARG2 is ending line number, default MAXINT
.1a4e17	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a4e1a	20 bf 20	jsr $1a20bf	            JSR PEEK_TOK
.1a4e1d	29 ff 00	and #$00ff	                AND #$00FF
.1a4e20	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.1a4e23	f0 2c		beq $1a4e51	                BEQ call_list           ; ... just list with the defaults
.1a4e25	c9 81 00	cmp #$0081	                CMP #TOK_MINUS          ; If just "- ###"...
.1a4e28	f0 1a		beq $1a4e44	                BEQ parse_endline       ; ... try to parse the end line number
.1a4e2a	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a4e2d	20 8a 07	jsr $1a078a	            JSR PARSEINT
.1a4e30	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG1
.1a4e32	85 55		sta $0855	                STA MARG1
.1a4e34	20 bf 20	jsr $1a20bf	            JSR PEEK_TOK
.1a4e37	29 ff 00	and #$00ff	                AND #$00FF
.1a4e3a	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.1a4e3d	f0 12		beq $1a4e51	                BEQ call_list           ; ... just list with the defaults
.1a4e3f	c9 81 00	cmp #$0081	                CMP #TOK_MINUS
.1a4e42	d0 2a		bne $1a4e6e	                BNE error               ; At this point, if not '-', it's a syntax error
.1a4e44					parse_endline
.1a4e44	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a4e47	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a4e4a	20 8a 07	jsr $1a078a	            JSR PARSEINT
.1a4e4d	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG2
.1a4e4f	85 59		sta $0859	                STA MARG2
.1a4e51	a5 1c		lda $081c	call_list       LDA CURLINE+2           ; Save CURLINE
.1a4e53	48		pha		                PHA
.1a4e54	a5 1a		lda $081a	                LDA CURLINE
.1a4e56	48		pha		                PHA
.1a4e57	a5 02		lda $0802	                LDA BIP+2               ; Save BIP
.1a4e59	48		pha		                PHA
.1a4e5a	a5 00		lda $0800	                LDA BIP
.1a4e5c	48		pha		                PHA
.1a4e5d	20 10 17	jsr $1a1710	            JSR LISTPROG
.1a4e60	68		pla		                PLA
.1a4e61	85 00		sta $0800	                STA BIP
.1a4e63	68		pla		                PLA
.1a4e64	85 02		sta $0802	                STA BIP+2
.1a4e66	68		pla		                PLA
.1a4e67	85 1a		sta $081a	                STA CURLINE
.1a4e69	68		pla		                PLA
.1a4e6a	85 1c		sta $081c	                STA CURLINE+2
.1a4e6c	28		plp		                PLP
.1a4e6d	60		rts		            RTS
.1a4e6e					error
.1a4e6e	08		php		            PHP
.1a4e6f	c2 20		rep #$20	            REP #$20
.1a4e71	48		pha		            PHA
.1a4e72	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4e75	5b		tcd		            TCD
.1a4e76	68		pla		            PLA
.1a4e77	28		plp		            PLP
.1a4e78	e2 20		sep #$20	            SEP #$20
.1a4e7a	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a4e7c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4e80	c2 20		rep #$20	            REP #$20
.1a4e82	29 ff 00	and #$00ff	            AND #$00FF
.1a4e85	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a4e88	e2 20		sep #$20	            SEP #$20
.1a4e8a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]

;******  Return to file: src\basic816.s


;******  Processing file: src\variables.s

>08e1					NEXTVAR         .long ?         ; Pointer to the the next available byte for variable bindings
>08e4					VARIABLES       .long ?         ; Pointer to the most recently allocated variable
>08e7					TOFIND          .long ?         ; Pointer to the variable name to find
>08ea					TOFINDTYPE      .byte ?         ; The type to find
.0000					BINDING
>0000					TYPE            .fill 1                 ; The type of the data stored in the variable
>0001					NAME            .fill VAR_NAME_SIZE     ; The name of the variable
>0009					VALUE           .fill 4                 ; The data stored in the variable
>000d					NEXT            .fill 3                 ; The pointer to the next allocated variable of this type
.1a4e8d					INITVARS
.1a4e8d	08		php		                PHP
.1a4e8e	08		php		            PHP
.1a4e8f	c2 20		rep #$20	            REP #$20
.1a4e91	48		pha		            PHA
.1a4e92	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4e95	5b		tcd		            TCD
.1a4e96	68		pla		            PLA
.1a4e97	28		plp		            PLP
.1a4e98	c2 20		rep #$20	            REP #$20
.1a4e9a	64 e4		stz $08e4	                STZ VARIABLES           ; Clear the pointer to the variables
.1a4e9c	64 e7		stz $08e7	                STZ TOFIND
.1a4e9e	e2 20		sep #$20	            SEP #$20
.1a4ea0	64 e6		stz $08e6	                STZ VARIABLES+2
.1a4ea2	64 e9		stz $08e9	                STZ TOFIND+2
.1a4ea4	64 ea		stz $08ea	                STZ TOFINDTYPE
.1a4ea6	c2 20		rep #$20	            REP #$20
.1a4ea8	38		sec		                SEC                     ; Compute the position of the first variable
.1a4ea9	a5 d9		lda $08d9	                LDA LASTLINE
.1a4eab	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.1a4eae	85 e1		sta $08e1	                STA NEXTVAR
.1a4eb0	e2 20		sep #$20	            SEP #$20
.1a4eb2	a5 db		lda $08db	                LDA LASTLINE+2
.1a4eb4	69 00		adc #$00	                ADC #0
.1a4eb6	85 e3		sta $08e3	                STA NEXTVAR+2
.1a4eb8	28		plp		                PLP
.1a4eb9	60		rts		            RTS
.1a4eba					ISVARCHAR
.1a4eba	c9 5f		cmp #$5f	                CMP #'_'            ; Check if it's an underscore
.1a4ebc	f0 1a		beq $1a4ed8	                BEQ return_true     ; Yes: return true
.1a4ebe	c9 3a		cmp #$3a	                CMP #'9'+1          ; Check if its in [0-9]
.1a4ec0	b0 04		bcs $1a4ec6	                BGE else1           ; No: check something else
.1a4ec2	c9 30		cmp #$30	                CMP #'0'
.1a4ec4	b0 12		bcs $1a4ed8	                BGE return_true     ; Yes: return true
.1a4ec6	c9 5b		cmp #$5b	else1           CMP #'Z'+1          ; Check if its in [A-Z]
.1a4ec8	b0 04		bcs $1a4ece	                BGE not_upper       ; No: check lower case
.1a4eca	c9 41		cmp #$41	                CMP #'A'
.1a4ecc	b0 0a		bcs $1a4ed8	                BGE return_true     ; Yes: return true
.1a4ece	c9 7b		cmp #$7b	not_upper       CMP #'z'+1          ; Check if its in [a-z]
.1a4ed0	b0 04		bcs $1a4ed6	                BGE return_false    ; No: return false
.1a4ed2	c9 61		cmp #$61	                CMP #'a'
.1a4ed4	b0 02		bcs $1a4ed8	                BGE return_true     ; Yes: return true
.1a4ed6	18		clc		return_false    CLC
.1a4ed7	60		rts		            RTS
.1a4ed8	38		sec		return_true     SEC
.1a4ed9	60		rts		            RTS
.1a4eda					VARNAMECMP
.1a4eda	08		php		                PHP
.1a4edb	e2 20		sep #$20	            SEP #$20
.1a4edd	c2 10		rep #$10	            REP #$10
.1a4edf	a0 00 00	ldy #$0000	                LDY #0
.1a4ee2	b7 0c		lda [$080c],y	cmp_loop        LDA [SCRATCH],Y         ; Check the character in the variable name
.1a4ee4	f0 0a		beq $1a4ef0	                BEQ is_end
.1a4ee6	d7 e7		cmp [$08e7],y	                CMP [TOFIND],Y          ; Compare the character to the one TOFIND
.1a4ee8	d0 13		bne $1a4efd	                BNE return_false        ; Not equal? Then this is not a match
.1a4eea	c8		iny		                INY
.1a4eeb	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.1a4eee	d0 f2		bne $1a4ee2	                BNE cmp_loop
.1a4ef0	b7 e7		lda [$08e7],y	is_end          LDA [TOFIND],Y          ; Check the character in the name to find
.1a4ef2	20 08 04	jsr $1a0408	            JSR TOUPPERA
.1a4ef5	20 ba 4e	jsr $1a4eba	            JSR ISVARCHAR
.1a4ef8	b0 03		bcs $1a4efd	                BCS return_false        ; YES: we do not have a match
.1a4efa					return_true
.1a4efa	28		plp		                PLP
.1a4efb	38		sec		                SEC
.1a4efc	60		rts		            RTS
.1a4efd					return_false
.1a4efd	28		plp		                PLP
.1a4efe	18		clc		                CLC
.1a4eff	60		rts		            RTS
.1a4f00					VAR_FIND
.1a4f00	08		php		                PHP
.1a4f01	e2 20		sep #$20	            SEP #$20
.1a4f03	c2 10		rep #$10	            REP #$10
.1a4f05	a0 00 00	ldy #$0000	                LDY #0
.1a4f08	a2 00 00	ldx #$0000	                LDX #0
.1a4f0b	b7 e7		lda [$08e7],y	upper_loop      LDA [TOFIND],Y          ; Get a character
.1a4f0d	f0 0b		beq $1a4f1a	                BEQ done_upper
.1a4f0f	20 08 04	jsr $1a0408	            JSR TOUPPERA
.1a4f12	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; And save it to the temp
.1a4f16	c8		iny		                INY
.1a4f17	e8		inx		                INX
.1a4f18	80 f1		bra $1a4f0b	                BRA upper_loop          ; Go back for another
.1a4f1a	a9 00		lda #$00	done_upper      LDA #0
.1a4f1c	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; NULL terminate the temporary string
.1a4f20	c2 20		rep #$20	            REP #$20
.1a4f22	a9 00 4e	lda #$4e00	                LDA #<>TEMPBUF          ; Make the temporary string the string
.1a4f25	85 e7		sta $08e7	                STA TOFIND              ; the variable name to find
.1a4f27	e2 20		sep #$20	            SEP #$20
.1a4f29	a9 00		lda #$00	                LDA #`TEMPBUF
.1a4f2b	85 e9		sta $08e9	                STA TOFIND+2
.1a4f2d	c2 20		rep #$20	            REP #$20
.1a4f2f	a5 e4		lda $08e4	                LDA VARIABLES           ; Point INDEX to the first variable to check
.1a4f31	85 08		sta $0808	                STA INDEX
.1a4f33	d0 06		bne $1a4f3b	                BNE set_index_h         ; If the low word is not 0, copy the high byte
.1a4f35	e2 20		sep #$20	            SEP #$20
.1a4f37	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a4f39	f0 4d		beq $1a4f88	                BEQ not_found           ; If it is, we have no variables yet.
.1a4f3b					set_index_h
.1a4f3b	e2 20		sep #$20	            SEP #$20
.1a4f3d	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a4f3f	85 0a		sta $080a	                STA INDEX+2
.1a4f41	a5 ea		lda $08ea	check_binding   LDA TOFINDTYPE
.1a4f43	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Get the type of the variable
.1a4f46	d7 08		cmp [$0808],y	                CMP [INDEX],Y
.1a4f48	d0 17		bne $1a4f61	                BNE check_next          ; If it's not a match, check the next binding
.1a4f4a	c2 20		rep #$20	            REP #$20
.1a4f4c	18		clc		                CLC
.1a4f4d	a5 08		lda $0808	                LDA INDEX
.1a4f4f	69 01 00	adc #$0001	                ADC #BINDING.NAME
.1a4f52	85 0c		sta $080c	                STA SCRATCH
.1a4f54	e2 20		sep #$20	            SEP #$20
.1a4f56	a5 0a		lda $080a	                LDA INDEX+2
.1a4f58	69 00		adc #$00	                ADC #0
.1a4f5a	85 0e		sta $080e	                STA SCRATCH+2
.1a4f5c	20 da 4e	jsr $1a4eda	            JSR VARNAMECMP
.1a4f5f	b0 2a		bcs $1a4f8b	                BCS found               ; If they match, return that we've found the variable
.1a4f61	a0 0d 00	ldy #$000d	check_next      LDY #BINDING.NEXT       ; SCRATCH := [INDEX].NEXT
.1a4f64	c2 20		rep #$20	            REP #$20
.1a4f66	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a4f68	85 0c		sta $080c	                STA SCRATCH
.1a4f6a	c8		iny		                INY
.1a4f6b	c8		iny		                INY
.1a4f6c	e2 20		sep #$20	            SEP #$20
.1a4f6e	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a4f70	85 0e		sta $080e	                STA SCRATCH+2
.1a4f72	d0 06		bne $1a4f7a	                BNE set_index           ; If SCRATCH == 0, the variable wasn't found
.1a4f74	c2 20		rep #$20	            REP #$20
.1a4f76	a5 0c		lda $080c	                LDA SCRATCH
.1a4f78	f0 0e		beq $1a4f88	                BEQ not_found
.1a4f7a					set_index
.1a4f7a	c2 20		rep #$20	            REP #$20
.1a4f7c	a5 0c		lda $080c	                LDA SCRATCH
.1a4f7e	85 08		sta $0808	                STA INDEX
.1a4f80	e2 20		sep #$20	            SEP #$20
.1a4f82	a5 0e		lda $080e	                LDA SCRATCH+2
.1a4f84	85 0a		sta $080a	                STA INDEX+2
.1a4f86	80 b9		bra $1a4f41	                BRA check_binding       ; And check this next variable for a match
.1a4f88					not_found
.1a4f88	28		plp		                PLP
.1a4f89	18		clc		                CLC
.1a4f8a	60		rts		            RTS
.1a4f8b					found
.1a4f8b	28		plp		                PLP
.1a4f8c	38		sec		                SEC
.1a4f8d	60		rts		            RTS
.1a4f8e					VAR_REF
.1a4f8e	08		php		                PHP
.1a4f8f	20 00 4f	jsr $1a4f00	            JSR VAR_FIND
.1a4f92	b0 1f		bcs $1a4fb3	                BCS found
.1a4f94	08		php		            PHP
.1a4f95	c2 20		rep #$20	            REP #$20
.1a4f97	48		pha		            PHA
.1a4f98	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4f9b	5b		tcd		            TCD
.1a4f9c	68		pla		            PLA
.1a4f9d	28		plp		            PLP
.1a4f9e	e2 20		sep #$20	            SEP #$20
.1a4fa0	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.1a4fa2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4fa6	c2 20		rep #$20	            REP #$20
.1a4fa8	29 ff 00	and #$00ff	            AND #$00FF
.1a4fab	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a4fae	e2 20		sep #$20	            SEP #$20
.1a4fb0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a4fb3					found
.1a4fb3	c2 30		rep #$30	            REP #$30
.1a4fb5	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.1a4fb8	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a4fba	85 23		sta $0823	                STA ARGUMENT1
.1a4fbc	c8		iny		                INY
.1a4fbd	c8		iny		                INY
.1a4fbe	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a4fc0	85 25		sta $0825	                STA ARGUMENT1+2
.1a4fc2	e2 20		sep #$20	            SEP #$20
.1a4fc4	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE
.1a4fc7	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a4fc9	85 27		sta $0827	                STA ARGTYPE1
.1a4fcb	28		plp		done            PLP
.1a4fcc	60		rts		            RTS
.1a4fcd					VAR_ALLOC
.1a4fcd	08		php		                PHP
.1a4fce	c2 20		rep #$20	            REP #$20
.1a4fd0	18		clc		                CLC                     ; Compute extent of the binding
.1a4fd1	a5 e1		lda $08e1	                LDA NEXTVAR
.1a4fd3	69 10 00	adc #$0010	                ADC #size(BINDING)
.1a4fd6	85 08		sta $0808	                STA INDEX
.1a4fd8	e2 20		sep #$20	            SEP #$20
.1a4fda	a5 e3		lda $08e3	                LDA NEXTVAR+2
.1a4fdc	69 00		adc #$00	                ADC #0
.1a4fde	85 0a		sta $080a	                STA INDEX+2
.1a4fe0	c5 bc		cmp $08bc	                CMP HEAP+2              ; Check to see if HEAP > INDEX
.1a4fe2	90 27		bcc $1a500b	                BLT has_room
.1a4fe4	c2 20		rep #$20	            REP #$20
.1a4fe6	a5 08		lda $0808	                LDA INDEX
.1a4fe8	c5 ba		cmp $08ba	                CMP HEAP
.1a4fea	90 1f		bcc $1a500b	                BLT has_room
.1a4fec	08		php		            PHP
.1a4fed	c2 20		rep #$20	            REP #$20
.1a4fef	48		pha		            PHA
.1a4ff0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a4ff3	5b		tcd		            TCD
.1a4ff4	68		pla		            PLA
.1a4ff5	28		plp		            PLP
.1a4ff6	e2 20		sep #$20	            SEP #$20
.1a4ff8	a9 09		lda #$09	            LDA #ERR_RANGE
.1a4ffa	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a4ffe	c2 20		rep #$20	            REP #$20
.1a5000	29 ff 00	and #$00ff	            AND #$00FF
.1a5003	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a5006	e2 20		sep #$20	            SEP #$20
.1a5008	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a500b					has_room
.1a500b	c2 20		rep #$20	            REP #$20
.1a500d	a5 e1		lda $08e1	                LDA NEXTVAR             ; Yes: we can allocate the variable
.1a500f	85 c0		sta $08c0	                STA CURRBLOCK           ; Point CURRBLOCK to it
.1a5011	e2 20		sep #$20	            SEP #$20
.1a5013	a5 e3		lda $08e3	                LDA NEXTVAR+2
.1a5015	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a5017	c2 20		rep #$20	            REP #$20
.1a5019	a5 08		lda $0808	                LDA INDEX               ; And point NEXTVAR to the next possible spot
.1a501b	85 e1		sta $08e1	                STA NEXTVAR
.1a501d	e2 20		sep #$20	            SEP #$20
.1a501f	a5 0a		lda $080a	                LDA INDEX+2
.1a5021	85 e3		sta $08e3	                STA NEXTVAR+2
.1a5023	28		plp		                PLP
.1a5024	60		rts		            RTS
.1a5025					VAR_CREATE
.1a5025	08		php		                PHP
.1a5026	e2 20		sep #$20	            SEP #$20
.1a5028	a5 27		lda $0827	                LDA ARGTYPE1            ; Validate that our types match
.1a502a	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.1a502c	f0 33		beq $1a5061	                BEQ chk_string          ; If so: check to see if it's a string
.1a502e	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable type
.1a5030	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's INTEGER
.1a5032	d0 05		bne $1a5039	                BNE chk_float
.1a5034	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a5037	80 2f		bra $1a5068	                BRA alloc_binding       ; And bind the variable
.1a5039	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; If it's FLOAT
.1a503b	d0 05		bne $1a5042	                BNE type_error
.1a503d	20 71 06	jsr $1a0671	            JSR ASS_ARG1_FLOAT
.1a5040	80 26		bra $1a5068	                BRA alloc_binding       ; And bind the variable
.1a5042					type_error
.1a5042	08		php		            PHP
.1a5043	c2 20		rep #$20	            REP #$20
.1a5045	48		pha		            PHA
.1a5046	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5049	5b		tcd		            TCD
.1a504a	68		pla		            PLA
.1a504b	28		plp		            PLP
.1a504c	e2 20		sep #$20	            SEP #$20
.1a504e	a9 04		lda #$04	            LDA #ERR_TYPE
.1a5050	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5054	c2 20		rep #$20	            REP #$20
.1a5056	29 ff 00	and #$00ff	            AND #$00FF
.1a5059	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a505c	e2 20		sep #$20	            SEP #$20
.1a505e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5061	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING        ; Is it a string?
.1a5063	d0 03		bne $1a5068	                BNE alloc_binding       ; No: just go ahead and bind it
.1a5065	20 a0 15	jsr $1a15a0	            JSR STRCPY
.1a5068					alloc_binding
.1a5068	c2 10		rep #$10	            REP #$10
.1a506a	20 cd 4f	jsr $1a4fcd	            JSR VAR_ALLOC
.1a506d	c2 30		rep #$30	            REP #$30
.1a506f	18		clc		                CLC
.1a5070	a5 c0		lda $08c0	                LDA CURRBLOCK
.1a5072	69 01 00	adc #$0001	                ADC #BINDING.NAME
.1a5075	85 08		sta $0808	                STA INDEX
.1a5077	e2 20		sep #$20	            SEP #$20
.1a5079	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a507b	69 00		adc #$00	                ADC #0
.1a507d	85 0a		sta $080a	                STA INDEX+2
.1a507f	a0 00 00	ldy #$0000	                LDY #0                  ; Ensure that the name field is blank
.1a5082	a9 00		lda #$00	                LDA #0
.1a5084	97 08		sta [$0808],y	blank_loop      STA [INDEX],Y
.1a5086	c8		iny		                INY
.1a5087	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.1a508a	d0 f8		bne $1a5084	                BNE blank_loop
.1a508c	a0 00 00	ldy #$0000	                LDY #0
.1a508f	b7 e7		lda [$08e7],y	name_loop       LDA [TOFIND],Y          ; Copy TOFIND to the NAME field
.1a5091	f0 10		beq $1a50a3	                BEQ set_type
.1a5093	20 08 04	jsr $1a0408	            JSR TOUPPERA
.1a5096	20 ba 4e	jsr $1a4eba	            JSR ISVARCHAR
.1a5099	90 08		bcc $1a50a3	                BCC set_type
.1a509b	97 08		sta [$0808],y	                STA [INDEX],Y
.1a509d	c8		iny		                INY
.1a509e	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.1a50a1	d0 ec		bne $1a508f	                BNE name_loop
.1a50a3					set_type
.1a50a3	c2 20		rep #$20	            REP #$20
.1a50a5	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE      ; Copy the value to the variable
.1a50a8	a5 23		lda $0823	                LDA ARGUMENT1
.1a50aa	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a50ac	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a50ae	c8		iny		                INY
.1a50af	c8		iny		                INY
.1a50b0	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a50b2	a5 e4		lda $08e4	                LDA VARIABLES           ; Point NEXT to the current top of variables
.1a50b4	a0 0d 00	ldy #$000d	                LDY #BINDING.NEXT
.1a50b7	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a50b9	c8		iny		                INY
.1a50ba	c8		iny		                INY
.1a50bb	e2 20		sep #$20	            SEP #$20
.1a50bd	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a50bf	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a50c1	c2 20		rep #$20	            REP #$20
.1a50c3	a5 c0		lda $08c0	                LDA CURRBLOCK
.1a50c5	85 e4		sta $08e4	                STA VARIABLES
.1a50c7	e2 20		sep #$20	            SEP #$20
.1a50c9	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a50cb	85 e6		sta $08e6	                STA VARIABLES+2
.1a50cd	e2 20		sep #$20	            SEP #$20
.1a50cf	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Set the type of the variable
.1a50d2	a5 27		lda $0827	                LDA ARGTYPE1
.1a50d4	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.1a50d6	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is it a string?
.1a50d8	f0 02		beq $1a50dc	                BEQ set_ref             ; Yes: add a reference count to it
.1a50da	28		plp		done            PLP
.1a50db	60		rts		            RTS
.1a50dc					set_ref
.1a50dc	c2 20		rep #$20	            REP #$20
.1a50de	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the a heap allocated value
.1a50e0	85 c0		sta $08c0	                STA CURRBLOCK
.1a50e2	e2 20		sep #$20	            SEP #$20
.1a50e4	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a50e6	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a50e8	20 bc 11	jsr $1a11bc	            JSR HEAP_GETHED
.1a50eb	20 d1 11	jsr $1a11d1	            JSR HEAP_ADDREF
.1a50ee	80 ea		bra $1a50da	                BRA done
.1a50f0					VAR_SET
.1a50f0	08		php		                PHP
.1a50f1	c2 30		rep #$30	            REP #$30
.1a50f3	a5 e4		lda $08e4	                LDA VARIABLES          ; If VARIABLES = 0, use VAR_CREATE
.1a50f5	d0 06		bne $1a50fd	                BNE use_find
.1a50f7	e2 20		sep #$20	            SEP #$20
.1a50f9	a5 e6		lda $08e6	                LDA VARIABLES+2
.1a50fb	f0 05		beq $1a5102	                BEQ use_create
.1a50fd					use_find
.1a50fd	20 00 4f	jsr $1a4f00	            JSR VAR_FIND
.1a5100	b0 05		bcs $1a5107	                BCS found
.1a5102					use_create
.1a5102	20 25 50	jsr $1a5025	            JSR VAR_CREATE
.1a5105	80 4e		bra $1a5155	                BRA done
.1a5107					found
.1a5107	e2 20		sep #$20	            SEP #$20
.1a5109	a5 27		lda $0827	                LDA ARGTYPE1            ; Do the types match?
.1a510b	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.1a510d	f0 33		beq $1a5142	                BEQ chk_string          ; Yes: check to see if it's string
.1a510f	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable
.1a5111	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; Is it INTEGER?
.1a5113	d0 05		bne $1a511a	                BNE chk_float
.1a5115	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a5118	80 2c		bra $1a5146	                BRA set_val
.1a511a	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; Is it FLOAT?
.1a511c	d0 05		bne $1a5123	                BNE type_error          ; No: throw an error
.1a511e	20 71 06	jsr $1a0671	            JSR ASS_ARG1_FLOAT
.1a5121	80 23		bra $1a5146	                BRA set_val
.1a5123					type_error
.1a5123	08		php		            PHP
.1a5124	c2 20		rep #$20	            REP #$20
.1a5126	48		pha		            PHA
.1a5127	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a512a	5b		tcd		            TCD
.1a512b	68		pla		            PLA
.1a512c	28		plp		            PLP
.1a512d	e2 20		sep #$20	            SEP #$20
.1a512f	a9 04		lda #$04	            LDA #ERR_TYPE
.1a5131	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5135	c2 20		rep #$20	            REP #$20
.1a5137	29 ff 00	and #$00ff	            AND #$00FF
.1a513a	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a513d	e2 20		sep #$20	            SEP #$20
.1a513f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5142	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING
.1a5144	f0 11		beq $1a5157	                BEQ set_string          ; Yes: set the string value of the variable
.1a5146					set_val
.1a5146	c2 30		rep #$30	            REP #$30
.1a5148	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.1a514b	a5 23		lda $0823	                LDA ARGUMENT1
.1a514d	97 08		sta [$0808],y	                STA [INDEX],Y
.1a514f	c8		iny		                INY
.1a5150	c8		iny		                INY
.1a5151	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5153	97 08		sta [$0808],y	                STA [INDEX],Y
.1a5155					done
.1a5155	28		plp		                PLP
.1a5156	60		rts		            RTS
.1a5157					set_string
.1a5157	20 a0 15	jsr $1a15a0	            JSR STRCPY
.1a515a	a0 09 00	ldy #$0009	set_ref         LDY #BINDING.VALUE      ; Set CURRBLOCK to the current string value
.1a515d	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a515f	85 c0		sta $08c0	                STA CURRBLOCK
.1a5161	c8		iny		                INY
.1a5162	c8		iny		                INY
.1a5163	e2 20		sep #$20	            SEP #$20
.1a5165	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a5167	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a5169	20 bc 11	jsr $1a11bc	            JSR HEAP_GETHED
.1a516c	20 f0 11	jsr $1a11f0	            JSR HEAP_REMREF
.1a516f	e2 20		sep #$20	            SEP #$20
.1a5171	a5 27		lda $0827	                LDA ARGTYPE1
.1a5173	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is the new value a string?
.1a5175	f0 02		beq $1a5179	                BEQ add_ref             ; Yes: add a reference to it
.1a5177	80 cd		bra $1a5146	                BRA set_val             ; No: go back to set the value... this probably shouldn't happen
.1a5179					add_ref
.1a5179	c2 20		rep #$20	            REP #$20
.1a517b	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the new string value
.1a517d	85 c0		sta $08c0	                STA CURRBLOCK
.1a517f	e2 20		sep #$20	            SEP #$20
.1a5181	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5183	85 c2		sta $08c2	                STA CURRBLOCK+2
.1a5185	20 bc 11	jsr $1a11bc	            JSR HEAP_GETHED
.1a5188	20 d1 11	jsr $1a11d1	            JSR HEAP_ADDREF
.1a518b	80 b9		bra $1a5146	                BRA set_val
.1a518d					VAR_FINDNAME
.1a518d	08		php		                PHP
.1a518e	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a5191	e2 20		sep #$20	            SEP #$20
.1a5193	a7 00		lda [$0800]	                LDA [BIP]           ; Get the first character
.1a5195	20 94 03	jsr $1a0394	            JSR ISALPHA
.1a5198	90 42		bcc $1a51dc	                BCC not_found
.1a519a	c2 20		rep #$20	            REP #$20
.1a519c	a5 00		lda $0800	                LDA BIP
.1a519e	85 e7		sta $08e7	                STA TOFIND
.1a51a0	e2 20		sep #$20	            SEP #$20
.1a51a2	a5 02		lda $0802	                LDA BIP+2
.1a51a4	85 e9		sta $08e9	                STA TOFIND+2
.1a51a6					loop
.1a51a6	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a51a9	a7 00		lda [$0800]	                LDA [BIP]
.1a51ab	f0 0d		beq $1a51ba	                BEQ is_float        ; If it's EOL, the variable is a float
.1a51ad	c9 24		cmp #$24	                CMP #'$'            ; If it's $, the variable is a string
.1a51af	f0 14		beq $1a51c5	                BEQ is_string
.1a51b1	c9 25		cmp #$25	                CMP #'%'            ; If it's %, the variable is an integer
.1a51b3	f0 09		beq $1a51be	                BEQ is_integer
.1a51b5	20 ba 4e	jsr $1a4eba	            JSR ISVARCHAR
.1a51b8	b0 ec		bcs $1a51a6	                BCS loop            ; Check the next one
.1a51ba	a9 01		lda #$01	is_float        LDA #TYPE_FLOAT     ; Otherwise it's a float
.1a51bc	80 0c		bra $1a51ca	                BRA set_type
.1a51be					is_integer
.1a51be	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a51c1	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a51c3	80 05		bra $1a51ca	                BRA set_type
.1a51c5					is_string
.1a51c5	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a51c8	a9 02		lda #$02	                LDA #TYPE_STRING
.1a51ca	85 ea		sta $08ea	set_type        STA TOFINDTYPE
.1a51cc	20 bf 20	jsr $1a20bf	            JSR PEEK_TOK
.1a51cf	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it "("?
.1a51d1	d0 06		bne $1a51d9	                BNE done            ; No: we're done... it's just a scalar variable
.1a51d3	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Yes: this is an array reference
.1a51d5	09 80		ora #$80	                ORA #$80            ; ... turn on the "Array of..." bit
.1a51d7	85 ea		sta $08ea	                STA TOFINDTYPE
.1a51d9					done
.1a51d9	28		plp		                PLP
.1a51da	38		sec		                SEC
.1a51db	60		rts		            RTS
.1a51dc	28		plp		not_found       PLP
.1a51dd	18		clc		                CLC
.1a51de	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\integers.s

.1a51df					OP_INT_ADD
.1a51df	08		php		            PHP
.1a51e0	c2 20		rep #$20	            REP #$20
.1a51e2	18		clc		            CLC
.1a51e3	a5 23		lda $0823	            LDA ARGUMENT1
.1a51e5	65 29		adc $0829	            ADC ARGUMENT2
.1a51e7	85 23		sta $0823	            STA ARGUMENT1
.1a51e9	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a51eb	65 2b		adc $082b	            ADC ARGUMENT2+2
.1a51ed	85 25		sta $0825	            STA ARGUMENT1+2
.1a51ef	28		plp		            PLP
.1a51f0	60		rts		            RTS
.1a51f1					OP_INT_SUB
.1a51f1	08		php		            PHP
.1a51f2	c2 20		rep #$20	            REP #$20
.1a51f4	38		sec		            SEC
.1a51f5	a5 23		lda $0823	            LDA ARGUMENT1
.1a51f7	e5 29		sbc $0829	            SBC ARGUMENT2
.1a51f9	85 23		sta $0823	            STA ARGUMENT1
.1a51fb	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a51fd	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.1a51ff	85 25		sta $0825	            STA ARGUMENT1+2
.1a5201	28		plp		            PLP
.1a5202	60		rts		            RTS
.1a5203					OP_INT_MUL
.1a5203	08		php		            PHP
.1a5204					locals
>0001					L_SIGN      .word ?
>0003					L_RESULT    .dword ?
>0007					            .dword ?
.1a5204	c2 20		rep #$20	            REP #$20
.1a5206	3b		tsc		            TSC
.1a5207	38		sec		            SEC
.1a5208	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.1a520b	1b		tcs		            TCS
.1a520c	c2 30		rep #$30	            REP #$30
.1a520e	a9 00 00	lda #$0000	            LDA #0                  ; Start by assuming positive numbers
.1a5211	83 01		sta $01,s	            STA L_SIGN
.1a5213	83 03		sta $03,s	            STA L_RESULT            ; Clear result
.1a5215	83 05		sta $05,s	            STA L_RESULT+2
.1a5217	83 07		sta $07,s	            STA L_RESULT+4
.1a5219	83 09		sta $09,s	            STA L_RESULT+6
.1a521b	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Ensure ARGUMENT1 is positive
.1a521d	10 18		bpl $1a5237	            BPL chk_sign2
.1a521f	a9 00 80	lda #$8000	            LDA #$8000              ; Record that ARGUMENT1 is negative
.1a5222	83 01		sta $01,s	            STA L_SIGN
.1a5224	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Take the two's complement of ARGUMENT1
.1a5226	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a5229	85 25		sta $0825	            STA ARGUMENT1+2
.1a522b	a5 23		lda $0823	            LDA ARGUMENT1
.1a522d	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a5230	1a		inc a		            INC A
.1a5231	85 23		sta $0823	            STA ARGUMENT1
.1a5233	d0 02		bne $1a5237	            BNE chk_sign2
.1a5235	e6 25		inc $0825	            INC ARGUMENT1+2
.1a5237	a5 2b		lda $082b	chk_sign2   LDA ARGUMENT2+2         ; Ensure ARGUMENT2 is positive
.1a5239	10 1a		bpl $1a5255	            BPL chk_over
.1a523b	a3 01		lda $01,s	            LDA L_SIGN              ; Flip the sign
.1a523d	49 00 80	eor #$8000	            EOR #$8000
.1a5240	83 01		sta $01,s	            STA L_SIGN
.1a5242	a5 2b		lda $082b	            LDA ARGUMENT2+2         ; Take the two's complement of ARGUMENT2
.1a5244	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a5247	85 2b		sta $082b	            STA ARGUMENT2+2
.1a5249	a5 29		lda $0829	            LDA ARGUMENT2
.1a524b	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a524e	1a		inc a		            INC A
.1a524f	85 29		sta $0829	            STA ARGUMENT2
.1a5251	d0 02		bne $1a5255	            BNE chk_over
.1a5253	e6 2b		inc $082b	            INC ARGUMENT2+2
.1a5255					chk_over
.1a5255	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5257	f0 04		beq $1a525d	            BEQ do_mult
.1a5259	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a525b	d0 5a		bne $1a52b7	            BNE overflow
.1a525d					do_mult
.1a525d	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*D
.1a525f	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.1a5263	a5 29		lda $0829	            LDA ARGUMENT2
.1a5265	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.1a5269	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.1a526d	83 03		sta $03,s	            STA L_RESULT
.1a526f	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.1a5273	83 05		sta $05,s	            STA L_RESULT+2
.1a5275	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Calculate A*D << 16 + B*D
.1a5277	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.1a527b	a5 29		lda $0829	            LDA ARGUMENT2
.1a527d	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.1a5281	18		clc		            CLC
.1a5282	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.1a5286	63 05		adc $05,s	            ADC L_RESULT+2
.1a5288	83 05		sta $05,s	            STA L_RESULT+2
.1a528a	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.1a528e	63 07		adc $07,s	            ADC L_RESULT+4
.1a5290	83 07		sta $07,s	            STA L_RESULT+4
.1a5292	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*C << 16 + A*D << 16 + B*D
.1a5294	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.1a5298	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a529a	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.1a529e	18		clc		            CLC
.1a529f	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.1a52a3	63 05		adc $05,s	            ADC L_RESULT+2
.1a52a5	83 05		sta $05,s	            STA L_RESULT+2
.1a52a7	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.1a52ab	63 07		adc $07,s	            ADC L_RESULT+4
.1a52ad	83 07		sta $07,s	            STA L_RESULT+4
.1a52af	a3 07		lda $07,s	            LDA L_RESULT+4
.1a52b1	f0 23		beq $1a52d6	            BEQ no_overflow
.1a52b3	a3 09		lda $09,s	            LDA L_RESULT+6
.1a52b5	f0 1f		beq $1a52d6	            BEQ no_overflow
.1a52b7					overflow
.1a52b7	08		php		            PHP
.1a52b8	c2 20		rep #$20	            REP #$20
.1a52ba	48		pha		            PHA
.1a52bb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a52be	5b		tcd		            TCD
.1a52bf	68		pla		            PLA
.1a52c0	28		plp		            PLP
.1a52c1	e2 20		sep #$20	            SEP #$20
.1a52c3	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.1a52c5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a52c9	c2 20		rep #$20	            REP #$20
.1a52cb	29 ff 00	and #$00ff	            AND #$00FF
.1a52ce	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a52d1	e2 20		sep #$20	            SEP #$20
.1a52d3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a52d6					no_overflow
.1a52d6	c2 30		rep #$30	            REP #$30
.1a52d8	a3 01		lda $01,s	            LDA L_SIGN              ; Check the sign
.1a52da	10 16		bpl $1a52f2	            BPL ret_result          ; If positive: just return the result
.1a52dc	a3 05		lda $05,s	            LDA L_RESULT+2          ; Compute the two's complement of the result
.1a52de	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a52e1	83 05		sta $05,s	            STA L_RESULT+2
.1a52e3	a3 03		lda $03,s	            LDA L_RESULT
.1a52e5	49 ff ff	eor #$ffff	            EOR #$FFFF
.1a52e8	1a		inc a		            INC A
.1a52e9	83 03		sta $03,s	            STA L_RESULT
.1a52eb	d0 05		bne $1a52f2	            BNE ret_result
.1a52ed	a3 05		lda $05,s	            LDA L_RESULT+2
.1a52ef	1a		inc a		            INC A
.1a52f0	83 05		sta $05,s	            STA L_RESULT+2
.1a52f2					ret_result
.1a52f2	a3 03		lda $03,s	            LDA L_RESULT
.1a52f4	85 23		sta $0823	            STA ARGUMENT1
.1a52f6	a3 05		lda $05,s	            LDA L_RESULT+2
.1a52f8	85 25		sta $0825	            STA ARGUMENT1+2
.1a52fa	c2 20		rep #$20	            REP #$20
.1a52fc	3b		tsc		            TSC
.1a52fd	18		clc		            CLC
.1a52fe	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.1a5301	1b		tcs		            TCS
.1a5302	28		plp		            PLP
.1a5303	60		rts		            RTS
.1a5304					OP_INT_LT
.1a5304	08		php		            PHP
.1a5305	c2 20		rep #$20	            REP #$20
.1a5307	a5 23		lda $0823	            LDA ARGUMENT1
.1a5309	c5 29		cmp $0829	            CMP ARGUMENT2
.1a530b	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a530d	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.1a530f	50 03		bvc $1a5314	            BVC skip_eor
.1a5311	49 00 80	eor #$8000	            EOR #$8000
.1a5314	30 06		bmi $1a531c	skip_eor    BMI ret_true
.1a5316	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a5318	64 25		stz $0825	            STZ ARGUMENT1+2
.1a531a	80 07		bra $1a5323	            BRA done
.1a531c	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a531f	85 23		sta $0823	            STA ARGUMENT1
.1a5321	85 25		sta $0825	            STA ARGUMENT1+2
.1a5323	28		plp		done        PLP
.1a5324	60		rts		            RTS
.1a5325					OP_INT_GT
.1a5325	08		php		            PHP
.1a5326	c2 20		rep #$20	            REP #$20
.1a5328	a5 23		lda $0823	            LDA ARGUMENT1
.1a532a	c5 29		cmp $0829	            CMP ARGUMENT2
.1a532c	d0 0c		bne $1a533a	            BNE test_fully
.1a532e	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5330	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.1a5332	d0 06		bne $1a533a	            BNE test_fully
.1a5334	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a5336	64 25		stz $0825	            STZ ARGUMENT1+2
.1a5338	80 16		bra $1a5350	            BRA done
.1a533a	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.1a533c	c5 23		cmp $0823	            CMP ARGUMENT1
.1a533e	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a5340	e5 25		sbc $0825	            SBC ARGUMENT1+2
.1a5342	50 03		bvc $1a5347	            BVC skip_eor
.1a5344	49 00 80	eor #$8000	            EOR #$8000
.1a5347	10 eb		bpl $1a5334	skip_eor    BPL ret_false
.1a5349	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a534c	85 23		sta $0823	            STA ARGUMENT1
.1a534e	85 25		sta $0825	            STA ARGUMENT1+2
.1a5350	28		plp		done        PLP
.1a5351	60		rts		            RTS
.1a5352					OP_INT_EQ
.1a5352	08		php		            PHP
.1a5353	c2 20		rep #$20	            REP #$20
.1a5355	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a5357	c5 25		cmp $0825	            CMP ARGUMENT1+2
.1a5359	d0 0f		bne $1a536a	            BNE ret_false
.1a535b	a5 29		lda $0829	            LDA ARGUMENT2
.1a535d	c5 23		cmp $0823	            CMP ARGUMENT1
.1a535f	d0 09		bne $1a536a	            BNE ret_false
.1a5361	a9 ff ff	lda #$ffff	            LDA #$FFFF
.1a5364	85 23		sta $0823	            STA ARGUMENT1
.1a5366	85 25		sta $0825	            STA ARGUMENT1+2
.1a5368	80 04		bra $1a536e	            BRA done
.1a536a	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a536c	64 25		stz $0825	            STZ ARGUMENT1+2
.1a536e	28		plp		done        PLP
.1a536f	60		rts		            RTS
.1a5370					OP_INT_NE
.1a5370	08		php		            PHP
.1a5371	c2 20		rep #$20	            REP #$20
.1a5373	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a5375	c5 25		cmp $0825	            CMP ARGUMENT1+2
.1a5377	d0 0c		bne $1a5385	            BNE ret_true
.1a5379	a5 29		lda $0829	            LDA ARGUMENT2
.1a537b	c5 23		cmp $0823	            CMP ARGUMENT1
.1a537d	d0 06		bne $1a5385	            BNE ret_true
.1a537f	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a5381	64 25		stz $0825	            STZ ARGUMENT1+2
.1a5383	80 07		bra $1a538c	            BRA done
.1a5385	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a5388	85 23		sta $0823	            STA ARGUMENT1
.1a538a	85 25		sta $0825	            STA ARGUMENT1+2
.1a538c	28		plp		done        PLP
.1a538d	60		rts		            RTS
.1a538e					OP_INT_GTE
.1a538e	08		php		            PHP
.1a538f	c2 20		rep #$20	            REP #$20
.1a5391	a5 23		lda $0823	            LDA ARGUMENT1
.1a5393	c5 29		cmp $0829	            CMP ARGUMENT2
.1a5395	d0 0f		bne $1a53a6	            BNE test_fully
.1a5397	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5399	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.1a539b	d0 09		bne $1a53a6	            BNE test_fully
.1a539d	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a53a0	85 23		sta $0823	            STA ARGUMENT1
.1a53a2	85 25		sta $0825	            STA ARGUMENT1+2
.1a53a4	80 13		bra $1a53b9	            BRA done
.1a53a6	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.1a53a8	c5 23		cmp $0823	            CMP ARGUMENT1
.1a53aa	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a53ac	e5 25		sbc $0825	            SBC ARGUMENT1+2
.1a53ae	50 03		bvc $1a53b3	            BVC skip_eor
.1a53b0	49 00 80	eor #$8000	            EOR #$8000
.1a53b3	30 e8		bmi $1a539d	skip_eor    BMI ret_true
.1a53b5	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a53b7	64 25		stz $0825	            STZ ARGUMENT1+2
.1a53b9	28		plp		done        PLP
.1a53ba	60		rts		            RTS
.1a53bb					OP_INT_LTE
.1a53bb	08		php		            PHP
.1a53bc	c2 20		rep #$20	            REP #$20
.1a53be	a5 23		lda $0823	            LDA ARGUMENT1
.1a53c0	c5 29		cmp $0829	            CMP ARGUMENT2
.1a53c2	d0 0f		bne $1a53d3	            BNE test_fully
.1a53c4	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a53c6	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.1a53c8	d0 09		bne $1a53d3	            BNE test_fully
.1a53ca	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.1a53cd	85 23		sta $0823	            STA ARGUMENT1
.1a53cf	85 25		sta $0825	            STA ARGUMENT1+2
.1a53d1	80 13		bra $1a53e6	            BRA done
.1a53d3	a5 23		lda $0823	test_fully  LDA ARGUMENT1
.1a53d5	c5 29		cmp $0829	            CMP ARGUMENT2
.1a53d7	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a53d9	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.1a53db	50 03		bvc $1a53e0	            BVC skip_eor
.1a53dd	49 00 80	eor #$8000	            EOR #$8000
.1a53e0	30 e8		bmi $1a53ca	skip_eor    BMI ret_true
.1a53e2	64 23		stz $0823	ret_false   STZ ARGUMENT1
.1a53e4	64 25		stz $0825	            STZ ARGUMENT1+2
.1a53e6	28		plp		done        PLP
.1a53e7	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\floats.s


;******  Processing file: src\C256/floats.s


;******  Processing file: src\C256/fp_math_defs.s

=$afe200				FP_MATH_CTRL0 = $AFE200         ; Read/write
=$08					FP_MATH_CTRL0_ADD = $08         ; 0: Substraction - 1: Addition
=$01					FP_CTRL0_CONV_0 = %00000001     ; Input 0 should be converted from 24.12 fixed point to floating point
=$02					FP_CTRL0_CONV_1 = %00000010     ; Input 1 should be converted from 24.12 fixed point to floating point
=$00					FP_ADD_IN0_MUX0 = %00000000     ; Adder input #0 is the output of MUX0
=$10					FP_ADD_IN0_MUX1 = %00010000     ; Adder input #0 is the output of MUX1
=$20					FP_ADD_IN0_MULT = %00100000     ; Adder input #0 is the output of the multiplier
=$30					FP_ADD_IN0_DIV  = %00110000     ; Adder input #0 is the output of the divider
=$00					FP_ADD_IN1_MUX0 = %00000000     ; Adder input #1 is the output of MUX0
=$40					FP_ADD_IN1_MUX1 = %01000000     ; Adder input #1 is the output of MUX1
=$80					FP_ADD_IN1_MULT = %10000000     ; Adder input #1 is the output of the multiplier
=$c0					FP_ADD_IN1_DIV  = %11000000     ; Adder input #1 is the output of the divider
=$afe201				FP_MATH_CTRL1 = $AFE201
=$00					FP_OUT_MULT = %00000000         ; Output is from the multiplier
=$01					FP_OUT_DIV  = %00000001         ; Output is from the divider
=$02					FP_OUT_ADD  = %00000010         ; Output is from the adder/subtracter
=$03					FP_OUT_ONE  = %00000011         ; Output is the constant '1.0'
=$afe202				FP_MATH_CTRL2 = $AFE202         ; Not Used - Reserved
=$afe203				FP_MATH_CTRL3 = $AFE203         ; Not Used - Reserved
=$afe204				FP_MATH_MULT_STAT = $AFE204     ; Status of the multiplier
=$01					FP_MULT_STAT_NAN  = $01         ; (NAN) Not a Number Status
=$02					FP_MULT_STAT_OVF  = $02         ; Overflow
=$04					FP_MULT_STAT_UDF  = $04         ; Underflow
=$08					FP_MULT_STAT_ZERO = $08         ; Zero
=$afe205				FP_MATH_DIV_STAT  = $AFE205     ; Status of the divider
=$01					FP_DIV_STAT_NAN       = $01     ; Not a number Status
=$02					FP_DIV_STAT_OVF       = $02     ; Overflow
=$04					FP_DIV_STAT_UDF       = $04     ; Underflow
=$08					FP_DIV_STAT_ZERO      = $08     ; Zero
=$10					FP_DIV_STAT_DIVBYZERO = $10     ; Division by Zero
=$afe206				FP_MATH_ADD_STAT  = $AFE206     ; Status of the adder/subtracter
=$01					FP_ADD_STAT_NAN  = $01          ; Not a number Status
=$02					FP_ADD_STAT_OVF  = $02          ; Overflow
=$04					FP_ADD_STAT_UDF  = $04          ; Underflow
=$08					FP_ADD_STAT_ZERO = $08          ; Zero
=$afe207				FP_MATH_CONV_STAT = $AFE207     ; Status of the fixed <=> float converters
=$01					FP_CONV_STAT_NAN  = $01         ; Not a number Status
=$02					FP_CONV_STAT_OVF  = $02         ; Overflow
=$04					FP_CONV_STAT_UDF  = $04         ; Underflow
=$afe208				FP_MATH_INPUT0_LL = $AFE208
=$afe209				FP_MATH_INPUT0_LH = $AFE209
=$afe20a				FP_MATH_INPUT0_HL = $AFE20A
=$afe20b				FP_MATH_INPUT0_HH = $AFE20B
=$afe20c				FP_MATH_INPUT1_LL = $AFE20C
=$afe20d				FP_MATH_INPUT1_LH = $AFE20D
=$afe20e				FP_MATH_INPUT1_HL = $AFE20E
=$afe20f				FP_MATH_INPUT1_HH = $AFE20F
=$afe208				FP_MATH_OUTPUT_FP_LL = $AFE208
=$afe209				FP_MATH_OUTPUT_FP_LH = $AFE209
=$afe20a				FP_MATH_OUTPUT_FP_HL = $AFE20A
=$afe20b				FP_MATH_OUTPUT_FP_HH = $AFE20B
=$afe20c				FP_MATH_OUTPUT_FIXED_LL = $AFE20C
=$afe20d				FP_MATH_OUTPUT_FIXED_LH = $AFE20D
=$afe20e				FP_MATH_OUTPUT_FIXED_HL = $AFE20E
=$afe20f				FP_MATH_OUTPUT_FIXED_HH = $AFE20F

;******  Return to file: src\C256/floats.s


;******  Processing file: src\C256/math_cop.s

.1a53e8					UINT_DIV_A_X
.1a53e8	08		php		                    PHP
.1a53e9	c2 20		rep #$20	            REP #$20
.1a53eb	8f 12 01 00	sta $000112	                    STA @l UNSIGNED_DIV_NUM_LO
.1a53ef	8a		txa		                    TXA
.1a53f0	8f 10 01 00	sta $000110	                    STA @l UNSIGNED_DIV_DEM_LO
.1a53f4	af 16 01 00	lda $000116	                    LDA @l UNSIGNED_DIV_REM_LO
.1a53f8	aa		tax		                    TAX
.1a53f9	af 14 01 00	lda $000114	                    LDA @l UNSIGNED_DIV_QUO_LO
.1a53fd	28		plp		                    PLP
.1a53fe	60		rts		            RTS

;******  Return to file: src\C256/floats.s

.1a53ff					FIXINT_TO_FP
.1a53ff	08		php		                    PHP
.1a5400	e2 20		sep #$20	            SEP #$20
.1a5402	a9 03		lda #$03	                    LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.1a5404	8f 00 e2 af	sta $afe200	                    STA @l FP_MATH_CTRL0
.1a5408	a9 00		lda #$00	                    LDA #FP_OUT_MULT
.1a540a	8f 01 e2 af	sta $afe201	                    STA @l FP_MATH_CTRL1
.1a540e	c2 20		rep #$20	            REP #$20
.1a5410	a5 23		lda $0823	                    LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a5412	8f 08 e2 af	sta $afe208	                    STA @l FP_MATH_INPUT0_LL
.1a5416	a5 25		lda $0825	                    LDA ARGUMENT1+2
.1a5418	8f 0a e2 af	sta $afe20a	                    STA @l FP_MATH_INPUT0_HL
.1a541c	a9 00 00	lda #$0000	                    LDA #0
.1a541f	8f 0c e2 af	sta $afe20c	                    STA @l FP_MATH_INPUT1_LL    ; ARGUMENT2 = 0100 0000 = 4096 in 20:12
.1a5423	a9 00 01	lda #$0100	                    LDA #$0100
.1a5426	8f 0e e2 af	sta $afe20e	                    STA @l FP_MATH_INPUT1_HL
.1a542a	ea		nop		                    NOP
.1a542b	ea		nop		                    NOP
.1a542c	ea		nop		                    NOP
.1a542d	ea		nop		                    NOP
.1a542e	ea		nop		                    NOP
.1a542f	ea		nop		                    NOP
.1a5430	af 08 e2 af	lda $afe208	                    LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.1a5434	85 23		sta $0823	                    STA ARGUMENT1
.1a5436	af 0a e2 af	lda $afe20a	                    LDA @l FP_MATH_OUTPUT_FP_HL
.1a543a	85 25		sta $0825	                    STA ARGUMENT1+2
.1a543c	a9 01 00	lda #$0001	                    LDA #TYPE_FLOAT
.1a543f	85 27		sta $0827	                    STA ARGTYPE1
.1a5441	28		plp		                    PLP
.1a5442	60		rts		            RTS
.1a5443	08		php		OP_FP_SUB       PHP
.1a5444	e2 20		sep #$20	            SEP #$20
.1a5446	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a5448	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a544c	80 09		bra $1a5457	                BRA FP_ADD_SUB
.1a544e	08		php		OP_FP_ADD       PHP
.1a544f	e2 20		sep #$20	            SEP #$20
.1a5451	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a5453	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a5457	a9 02		lda #$02	FP_ADD_SUB      LDA #FP_OUT_ADD
.1a5459	8f 01 e2 af	sta $afe201	                STA @lFP_MATH_CTRL1
.1a545d	c2 20		rep #$20	            REP #$20
.1a545f	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a5461	8f 08 e2 af	sta $afe208	                STA @lFP_MATH_INPUT0_LL
.1a5465	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5467	8f 0a e2 af	sta $afe20a	                STA @lFP_MATH_INPUT0_HL
.1a546b	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.1a546d	8f 0c e2 af	sta $afe20c	                STA @lFP_MATH_INPUT1_LL
.1a5471	a5 2b		lda $082b	                LDA ARGUMENT2+2
.1a5473	8f 0e e2 af	sta $afe20e	                STA @lFP_MATH_INPUT1_HL
.1a5477	ea		nop		                NOP
.1a5478	ea		nop		                NOP
.1a5479	ea		nop		                NOP
.1a547a	e2 20		sep #$20	            SEP #$20
.1a547c	af 06 e2 af	lda $afe206	                LDA @lFP_MATH_ADD_STAT      ; Check the status of the addition
.1a5480	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.1a5482	d0 10		bne $1a5494	                BNE fp_add_error            ; If an issue was raise, process the math error
.1a5484	c2 20		rep #$20	            REP #$20
.1a5486	af 08 e2 af	lda $afe208	                LDA @lFP_MATH_OUTPUT_FP_LL  ; Retrieve the results into ARGUMENT1
.1a548a	85 23		sta $0823	                STA ARGUMENT1
.1a548c	af 0a e2 af	lda $afe20a	                LDA @lFP_MATH_OUTPUT_FP_HL
.1a5490	85 25		sta $0825	                STA ARGUMENT1+2
.1a5492	28		plp		fp_add_done     PLP
.1a5493	60		rts		            RTS
.1a5494					fp_add_error
.1a5494	20 2f 55	jsr $1a552f	            JSR FP_MATH_ERROR
.1a5497	80 f9		bra $1a5492	                BRA fp_add_done
.1a5499	08		php		OP_FP_DIV       PHP
.1a549a	e2 20		sep #$20	            SEP #$20
.1a549c	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a549e	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a54a2	a9 00		lda #$00	                LDA #0
.1a54a4	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a54a8	c2 20		rep #$20	            REP #$20
.1a54aa	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a54ac	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a54b0	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a54b2	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a54b6	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.1a54b8	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a54bc	a5 2b		lda $082b	                LDA ARGUMENT2+2
.1a54be	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a54c2	ea		nop		                NOP
.1a54c3	ea		nop		                NOP
.1a54c4	ea		nop		                NOP
.1a54c5	e2 20		sep #$20	            SEP #$20
.1a54c7	af 05 e2 af	lda $afe205	                LDA @l FP_MATH_DIV_STAT     ; Check the status of the addition
.1a54cb	29 17		and #$17	                AND #%00010111              ; Filter out the ZERO status
.1a54cd	d0 10		bne $1a54df	                BNE fp_div_error            ; If an issue was raise, process the math error
.1a54cf	c2 20		rep #$20	            REP #$20
.1a54d1	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.1a54d5	85 23		sta $0823	                STA ARGUMENT1
.1a54d7	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a54db	85 25		sta $0825	                STA ARGUMENT1+2
.1a54dd	28		plp		fp_div_done     PLP
.1a54de	60		rts		            RTS
.1a54df					fp_div_error
.1a54df	20 2f 55	jsr $1a552f	            JSR FP_MATH_ERROR
.1a54e2	80 f9		bra $1a54dd	                BRA fp_div_done
.1a54e4	08		php		OP_FP_MUL       PHP
.1a54e5	e2 20		sep #$20	            SEP #$20
.1a54e7	a9 00		lda #$00	                LDA #FP_OUT_MULT
.1a54e9	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a54ed	a9 00		lda #$00	                LDA #0
.1a54ef	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.1a54f3	c2 20		rep #$20	            REP #$20
.1a54f5	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.1a54f7	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a54fb	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a54fd	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5501	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.1a5503	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5507	a5 2b		lda $082b	                LDA ARGUMENT2+2
.1a5509	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a550d	ea		nop		                NOP
.1a550e	ea		nop		                NOP
.1a550f	ea		nop		                NOP
.1a5510	e2 20		sep #$20	            SEP #$20
.1a5512	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT    ; Check the status of the addition
.1a5516	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.1a5518	d0 10		bne $1a552a	                BNE fp_mul_error            ; If an issue was raise, process the math error
.1a551a	c2 20		rep #$20	            REP #$20
.1a551c	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.1a5520	85 23		sta $0823	                STA ARGUMENT1
.1a5522	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5526	85 25		sta $0825	                STA ARGUMENT1+2
.1a5528	28		plp		fp_mul_done     PLP
.1a5529	60		rts		            RTS
.1a552a					fp_mul_error
.1a552a	20 2f 55	jsr $1a552f	            JSR FP_MATH_ERROR
.1a552d	80 f9		bra $1a5528	                BRA fp_mul_done
.1a552f					FP_MATH_ERROR
.1a552f	e2 20		sep #$20	            SEP #$20
.1a5531	89 01		bit #$01	                BIT #FP_ADD_STAT_NAN        ; Is there a NaN condition?
.1a5533	f0 20		beq $1a5555	                BEQ check_over              ; No: check for overflow
.1a5535	00		brk #		                BRK
.1a5536	08		php		            PHP
.1a5537	c2 20		rep #$20	            REP #$20
.1a5539	48		pha		            PHA
.1a553a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a553d	5b		tcd		            TCD
.1a553e	68		pla		            PLA
.1a553f	28		plp		            PLP
.1a5540	e2 20		sep #$20	            SEP #$20
.1a5542	a9 0c		lda #$0c	            LDA #ERR_NAN
.1a5544	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a5548	c2 20		rep #$20	            REP #$20
.1a554a	29 ff 00	and #$00ff	            AND #$00FF
.1a554d	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a5550	e2 20		sep #$20	            SEP #$20
.1a5552	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5555	89 02		bit #$02	check_over      BIT #FP_ADD_STAT_OVF        ; Is ther an overflow condition?
.1a5557	f0 1f		beq $1a5578	                BEQ check_under             ; No: check for underflow
.1a5559	08		php		            PHP
.1a555a	c2 20		rep #$20	            REP #$20
.1a555c	48		pha		            PHA
.1a555d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5560	5b		tcd		            TCD
.1a5561	68		pla		            PLA
.1a5562	28		plp		            PLP
.1a5563	e2 20		sep #$20	            SEP #$20
.1a5565	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.1a5567	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a556b	c2 20		rep #$20	            REP #$20
.1a556d	29 ff 00	and #$00ff	            AND #$00FF
.1a5570	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a5573	e2 20		sep #$20	            SEP #$20
.1a5575	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5578	89 04		bit #$04	check_under     BIT #FP_ADD_STAT_UDF        ; Is there an underflow condition?
.1a557a	f0 1f		beq $1a559b	                BEQ done                    ; No: we should just return... this probably shouldn't happen
.1a557c	08		php		            PHP
.1a557d	c2 20		rep #$20	            REP #$20
.1a557f	48		pha		            PHA
.1a5580	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a5583	5b		tcd		            TCD
.1a5584	68		pla		            PLA
.1a5585	28		plp		            PLP
.1a5586	e2 20		sep #$20	            SEP #$20
.1a5588	a9 0e		lda #$0e	            LDA #ERR_UNDERFLOW
.1a558a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a558e	c2 20		rep #$20	            REP #$20
.1a5590	29 ff 00	and #$00ff	            AND #$00FF
.1a5593	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a5596	e2 20		sep #$20	            SEP #$20
.1a5598	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a559b					done
.1a559b	60		rts		            RTS
.1a559c					FP_MUL10
.1a559c	08		php		                PHP
.1a559d	e2 20		sep #$20	            SEP #$20
.1a559f	a9 00		lda #$00	                LDA #FP_OUT_MULT                ; Set for multiplication
.1a55a1	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a55a5	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1            ; Input 1 is fixed point
.1a55a7	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a55ab	c2 20		rep #$20	            REP #$20
.1a55ad	a9 00 a0	lda #$a000	                LDA #$A000                      ; 10 is one factor
.1a55b0	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a55b4	a9 00 00	lda #$0000	                LDA #0
.1a55b7	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a55bb	a5 23		lda $0823	                LDA ARGUMENT1                   ; N is the other
.1a55bd	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a55c1	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a55c3	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a55c7	ea		nop		                NOP
.1a55c8	ea		nop		                NOP
.1a55c9	ea		nop		                NOP
.1a55ca	e2 20		sep #$20	            SEP #$20
.1a55cc	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT        ; Check the status
.1a55d0	89 07		bit #$07	                BIT #FP_MULT_STAT_NAN | FP_MULT_STAT_OVF | FP_MULT_STAT_UDF
.1a55d2	f0 01		beq $1a55d5	                BEQ ret_result
.1a55d4	00		brk #		                BRK                             ; There was an error...
.1a55d5					ret_result
.1a55d5	c2 20		rep #$20	            REP #$20
.1a55d7	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL     ; Save result back
.1a55db	85 23		sta $0823	                STA ARGUMENT1
.1a55dd	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a55e1	85 25		sta $0825	                STA ARGUMENT1+2
.1a55e3	28		plp		                PLP
.1a55e4	60		rts		            RTS
.1a55e5					FP_DIV10
.1a55e5	08		php		                PHP
.1a55e6	e2 20		sep #$20	            SEP #$20
.1a55e8	a9 01		lda #$01	                LDA #FP_OUT_DIV             ; Set for multiplication
.1a55ea	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a55ee	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1        ; Input 1 is fixed point
.1a55f0	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a55f4	c2 20		rep #$20	            REP #$20
.1a55f6	a9 00 a0	lda #$a000	                LDA #$A000                  ; 10 is one factor
.1a55f9	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a55fd	a9 00 00	lda #$0000	                LDA #0
.1a5600	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5604	a5 23		lda $0823	                LDA ARGUMENT1               ; N is the other
.1a5606	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a560a	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a560c	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5610	ea		nop		                NOP
.1a5611	ea		nop		                NOP
.1a5612	ea		nop		                NOP
.1a5613	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Save result back
.1a5617	85 23		sta $0823	                STA ARGUMENT1
.1a5619	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a561d	85 25		sta $0825	                STA ARGUMENT1+2
.1a561f	28		plp		                PLP
.1a5620	60		rts		            RTS

;******  Return to file: src\floats.s

.1a5621					FARG1EQ0
.1a5621	08		php		                PHP
.1a5622	c2 20		rep #$20	            REP #$20
.1a5624	a5 23		lda $0823	                LDA ARGUMENT1
.1a5626	d0 0a		bne $1a5632	                BNE return_false
.1a5628	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a562a	29 ff 7f	and #$7fff	                AND #$7FFF              ; Mask off the sign bit
.1a562d	d0 03		bne $1a5632	                BNE return_false
.1a562f	28		plp		return_true     PLP
.1a5630	38		sec		                SEC
.1a5631	60		rts		            RTS
.1a5632	28		plp		return_false    PLP
.1a5633	18		clc		                CLC
.1a5634	60		rts		            RTS
.1a5635					SHIFTDEC
.1a5635	08		php		                PHP
.1a5636	e2 20		sep #$20	            SEP #$20
.1a5638	38		sec		                SEC                     ; Convert '0'..'9' to it's number
.1a5639	e9 30		sbc #$30	                SBC #'0'
.1a563b	20 2c 04	jsr $1a042c	            JSR MULINT10
.1a563e	c2 20		rep #$20	            REP #$20
.1a5640	29 ff 00	and #$00ff	                AND #$00FF              ; Add the number to ARGUMENT1
.1a5643	18		clc		                CLC
.1a5644	65 23		adc $0823	                ADC ARGUMENT1
.1a5646	85 23		sta $0823	                STA ARGUMENT1
.1a5648	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a564a	69 00 00	adc #$0000	                ADC #0
.1a564d	85 25		sta $0825	                STA ARGUMENT1+2
.1a564f	28		plp		                PLP
.1a5650	60		rts		            RTS
.1a5651					SHIFTHEX
.1a5651	08		php		                PHP
.1a5652	e2 20		sep #$20	            SEP #$20
.1a5654	c9 30		cmp #$30	                CMP #'0'                ; Process 0-9
.1a5656	90 04		bcc $1a565c	                BLT not_09
.1a5658	c9 3a		cmp #$3a	                CMP #'9'+1
.1a565a	90 1c		bcc $1a5678	                BLT is_09
.1a565c	c9 61		cmp #$61	not_09          CMP #'a'                ; Process lowercase A-F
.1a565e	90 04		bcc $1a5664	                BLT not_lc
.1a5660	c9 67		cmp #$67	                CMP #'f'+1
.1a5662	90 0a		bcc $1a566e	                BLT is_lc
.1a5664	c9 41		cmp #$41	not_lc          CMP #'A'                ; Process uppercase A-F
.1a5666	90 04		bcc $1a566c	                BLT not_uc
.1a5668	c9 47		cmp #$47	                CMP #'F'+1
.1a566a	90 07		bcc $1a5673	                BLT is_uc
.1a566c	80 31		bra $1a569f	not_uc          BRA done                ; Just return if we couldn't convert... this shouldn't happen
.1a566e	38		sec		is_lc           SEC                     ; Convert 'a'-'f' to the actual number
.1a566f	e9 57		sbc #$57	                SBC #'a'-10
.1a5671	80 08		bra $1a567b	                BRA shift
.1a5673	38		sec		is_uc           SEC                     ; Convert 'A'-'F' to the actual number
.1a5674	e9 37		sbc #$37	                SBC #'A'-10
.1a5676	80 03		bra $1a567b	                BRA shift
.1a5678	38		sec		is_09           SEC                     ; Convert '0'-'9' to the actual number
.1a5679	e9 30		sbc #$30	                SBC #'0'
.1a567b					shift
.1a567b	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a567d	26 24		rol $0824	                ROL ARGUMENT1+1
.1a567f	26 25		rol $0825	                ROL ARGUMENT1+2
.1a5681	26 26		rol $0826	                ROL ARGUMENT1+3
.1a5683	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a5685	26 24		rol $0824	                ROL ARGUMENT1+1
.1a5687	26 25		rol $0825	                ROL ARGUMENT1+2
.1a5689	26 26		rol $0826	                ROL ARGUMENT1+3
.1a568b	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a568d	26 24		rol $0824	                ROL ARGUMENT1+1
.1a568f	26 25		rol $0825	                ROL ARGUMENT1+2
.1a5691	26 26		rol $0826	                ROL ARGUMENT1+3
.1a5693	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.1a5695	26 24		rol $0824	                ROL ARGUMENT1+1
.1a5697	26 25		rol $0825	                ROL ARGUMENT1+2
.1a5699	26 26		rol $0826	                ROL ARGUMENT1+3
.1a569b	05 23		ora $0823	                ORA ARGUMENT1           ; Add the number to it
.1a569d	85 23		sta $0823	                STA ARGUMENT1
.1a569f	28		plp		done            PLP
.1a56a0	60		rts		            RTS
.1a56a1					SHIFTBIN
.1a56a1	08		php		                PHP
.1a56a2	e2 20		sep #$20	            SEP #$20
.1a56a4	c9 30		cmp #$30	                CMP #'0'                ; If the character is '0'...
.1a56a6	f0 06		beq $1a56ae	                BEQ shift_0             ; Shift a 0 onto ARGUMENT1
.1a56a8	c9 31		cmp #$31	                CMP #'1'                ; If the character is '1'...
.1a56aa	f0 0a		beq $1a56b6	                BEQ shift_1             ; Shift a 1 onto ARGUMENT1
.1a56ac	80 0f		bra $1a56bd	                BRA done
.1a56ae					shift_0
.1a56ae	c2 20		rep #$20	            REP #$20
.1a56b0	06 23		asl $0823	                ASL ARGUMENT1
.1a56b2	26 25		rol $0825	                ROL ARGUMENT1+2
.1a56b4	80 07		bra $1a56bd	                BRA done
.1a56b6					shift_1
.1a56b6	c2 20		rep #$20	            REP #$20
.1a56b8	38		sec		                SEC
.1a56b9	26 23		rol $0823	                ROL ARGUMENT1
.1a56bb	26 25		rol $0825	                ROL ARGUMENT1+2
.1a56bd	28		plp		done            PLP
.1a56be	60		rts		            RTS
.1a56bf					FP_POW10
.1a56bf	08		php		                PHP
.1a56c0	e2 30		sep #$30	            SEP #$30
.1a56c2	a5 61		lda $0861	                LDA MARG4
.1a56c4	f0 0d		beq $1a56d3	                BEQ return_1
.1a56c6	aa		tax		                TAX
.1a56c7	a5 69		lda $0869	                LDA MARG6
.1a56c9	d0 15		bne $1a56e0	                BNE do_div
.1a56cb	a9 00		lda #$00	                LDA #FP_OUT_MULT                    ; We'll multiply
.1a56cd	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a56d1	80 15		bra $1a56e8	                BRA start_loop
.1a56d3					return_1
.1a56d3	e2 20		sep #$20	            SEP #$20
.1a56d5	a9 03		lda #$03	                LDA #FP_OUT_ONE                     ; We want to return a 1.0
.1a56d7	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a56db	ea		nop		                NOP
.1a56dc	ea		nop		                NOP
.1a56dd	ea		nop		                NOP
.1a56de	80 62		bra $1a5742	                BRA ret_result                      ; And return the result
.1a56e0					do_div
.1a56e0	e2 20		sep #$20	            SEP #$20
.1a56e2	a9 01		lda #$01	                LDA #FP_OUT_DIV                     ; We'll divide
.1a56e4	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a56e8					start_loop
.1a56e8	e2 20		sep #$20	            SEP #$20
.1a56ea	a9 43		lda #$43	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.1a56ec	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.1a56f0	c2 20		rep #$20	            REP #$20
.1a56f2	a9 00 10	lda #$1000	                LDA #$1000                          ; Input 0 = 1.0
.1a56f5	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a56f9	a9 00 00	lda #$0000	                LDA #0
.1a56fc	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5700					loop
.1a5700	c2 20		rep #$20	            REP #$20
.1a5702	a9 00 a0	lda #$a000	                LDA #$A000                          ; Input 1 = 10.0
.1a5705	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5709	a9 00 00	lda #$0000	                LDA #0
.1a570c	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5710	ea		nop		                NOP                                 ; Wait for the operation to complete
.1a5711	ea		nop		                NOP
.1a5712	ea		nop		                NOP
.1a5713	ca		dex		                DEX                                 ; Count down
.1a5714	f0 2c		beq $1a5742	                BEQ ret_result                      ; If 0, then we're done
.1a5716	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; SCRATCH <-- Result
.1a571a	8f 0c 08 00	sta $00080c	                STA @l SCRATCH
.1a571e	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5722	8f 0e 08 00	sta $00080e	                STA @l SCRATCH+2
.1a5726	e2 20		sep #$20	            SEP #$20
.1a5728	a9 42		lda #$42	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_1
.1a572a	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.1a572e	c2 20		rep #$20	            REP #$20
.1a5730	af 0c 08 00	lda $00080c	                LDA @l SCRATCH                      ; Input 0 <-- SCRATCH
.1a5734	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5738	af 0e 08 00	lda $00080e	                LDA @l SCRATCH+2
.1a573c	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5740	80 be		bra $1a5700	                BRA loop
.1a5742					ret_result
.1a5742	c2 20		rep #$20	            REP #$20
.1a5744	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; Return the result
.1a5748	85 23		sta $0823	                STA ARGUMENT1
.1a574a	af 0a e2 af	lda $afe20a	                LDA FP_MATH_OUTPUT_FP_HL
.1a574e	85 25		sta $0825	                STA ARGUMENT1+2
.1a5750	e2 20		sep #$20	            SEP #$20
.1a5752	a9 01		lda #$01	                LDA #TYPE_FLOAT
.1a5754	85 27		sta $0827	                STA ARGTYPE1
.1a5756	28		plp		done            PLP
.1a5757	60		rts		            RTS
.1a5758					PACKFLOAT
.1a5758	08		php		                PHP
.1a5759	c2 20		rep #$20	            REP #$20
.1a575b	a5 5d		lda $085d	            LDA MARG3
.1a575d	85 23		sta $0823	            STA ARGUMENT1
.1a575f	a5 5f		lda $085f	            LDA MARG3+2
.1a5761	85 25		sta $0825	            STA ARGUMENT1+2
.1a5763	20 71 59	jsr $1a5971	            JSR ITOF
.1a5766	c2 20		rep #$20	            REP #$20
.1a5768	a5 23		lda $0823	            LDA ARGUMENT1
.1a576a	85 29		sta $0829	            STA ARGUMENT2
.1a576c	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a576e	85 2b		sta $082b	            STA ARGUMENT2+2
.1a5770	c2 20		rep #$20	            REP #$20
.1a5772	a5 59		lda $0859	            LDA MARG2
.1a5774	85 23		sta $0823	            STA ARGUMENT1
.1a5776	a5 5b		lda $085b	            LDA MARG2+2
.1a5778	85 25		sta $0825	            STA ARGUMENT1+2
.1a577a	20 99 54	jsr $1a5499	            JSR OP_FP_DIV
.1a577d	c2 20		rep #$20	            REP #$20
.1a577f	a5 55		lda $0855	            LDA MARG1
.1a5781	85 29		sta $0829	            STA ARGUMENT2
.1a5783	a5 57		lda $0857	            LDA MARG1+2
.1a5785	85 2b		sta $082b	            STA ARGUMENT2+2
.1a5787	20 4e 54	jsr $1a544e	            JSR OP_FP_ADD
.1a578a	c2 20		rep #$20	            REP #$20
.1a578c	a5 23		lda $0823	            LDA ARGUMENT1
.1a578e	85 29		sta $0829	            STA ARGUMENT2
.1a5790	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5792	85 2b		sta $082b	            STA ARGUMENT2+2
.1a5794	20 bf 56	jsr $1a56bf	            JSR FP_POW10
.1a5797	20 e4 54	jsr $1a54e4	            JSR OP_FP_MUL
.1a579a	c2 20		rep #$20	            REP #$20
.1a579c	a5 65		lda $0865	                LDA MARG5                       ; Check to see if the float should be negative
.1a579e	f0 07		beq $1a57a7	                BEQ set_float_type              ; If not, just set the type
.1a57a0	a5 25		lda $0825	                LDA ARGUMENT1+2                 ; If so, set the sign bit
.1a57a2	09 00 80	ora #$8000	                ORA #$8000
.1a57a5	85 25		sta $0825	                STA ARGUMENT1+2
.1a57a7					set_float_type
.1a57a7	e2 20		sep #$20	            SEP #$20
.1a57a9	a9 01		lda #$01	                LDA #TYPE_FLOAT                 ; Set the type to float... ready for returning!
.1a57ab	85 27		sta $0827	                STA ARGTYPE1
.1a57ad	28		plp		                PLP
.1a57ae	60		rts		            RTS
.1a57af					PARSENUM
.1a57af	5a		phy		                PHY
.1a57b0	08		php		                PHP
.1a57b1	c2 30		rep #$30	            REP #$30
.1a57b3	64 23		stz $0823	                STZ ARGUMENT1       ; This will be the accumulator for building the number
.1a57b5	64 25		stz $0825	                STZ ARGUMENT1+2
.1a57b7	64 55		stz $0855	                STZ MARG1           ; This will be the integer portion of the mantissa for floats
.1a57b9	64 57		stz $0857	                STZ MARG1+2
.1a57bb	64 65		stz $0865	                STZ MARG5           ; MARG5 will be the negative flag for the number
.1a57bd	64 59		stz $0859	                STZ MARG2           ; This will be the denominator of the fractional part of the mantissa
.1a57bf	64 5b		stz $085b	                STZ MARG2+2
.1a57c1	a9 01 00	lda #$0001	                LDA #1
.1a57c4	85 5d		sta $085d	                STA MARG3           ; This will be the divisor of the fractional part of the mantissa
.1a57c6	64 5f		stz $085f	                STZ MARG3+2
.1a57c8	64 61		stz $0861	                STZ MARG4           ; This will be the exponent of a float
.1a57ca	64 63		stz $0863	                STZ MARG4+2
.1a57cc	64 69		stz $0869	                STZ MARG6           ; MARG6 will be the negative flag for the exponent
.1a57ce					s0
.1a57ce	e2 20		sep #$20	            SEP #$20
.1a57d0	a0 00 00	ldy #$0000	                LDY #0
.1a57d3	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the first byte
.1a57d5	c9 2b		cmp #$2b	                CMP #'+'
.1a57d7	f0 33		beq $1a580c	                BEQ s1_drop         ; '+' --> S1, drop
.1a57d9	c9 2d		cmp #$2d	                CMP #'-'
.1a57db	f0 2b		beq $1a5808	                BEQ s1_negative     ; Flag that the number is negative
.1a57dd	c9 26		cmp #$26	                CMP #'&'
.1a57df	f0 3a		beq $1a581b	                BEQ s2_drop         ; '&' --> S2, drop
.1a57e1	20 ad 03	jsr $1a03ad	            JSR ISNUMERAL
.1a57e4	90 03		bcc $1a57e9	                BCC syntax_err
.1a57e6	82 ac 00	brl $1a5895	                BRL s7_shift        ; '0'-'9' --> S7, emit
.1a57e9					syntax_err
.1a57e9	08		php		            PHP
.1a57ea	c2 20		rep #$20	            REP #$20
.1a57ec	48		pha		            PHA
.1a57ed	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a57f0	5b		tcd		            TCD
.1a57f1	68		pla		            PLA
.1a57f2	28		plp		            PLP
.1a57f3	e2 20		sep #$20	            SEP #$20
.1a57f5	a9 02		lda #$02	            LDA #ERR_SYNTAX
.1a57f7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a57fb	c2 20		rep #$20	            REP #$20
.1a57fd	29 ff 00	and #$00ff	            AND #$00FF
.1a5800	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a5803	e2 20		sep #$20	            SEP #$20
.1a5805	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a5808	a9 01		lda #$01	s1_negative     LDA #1              ; Set the negative flag for the mantissa
.1a580a	85 65		sta $0865	                STA MARG5
.1a580c	c8		iny		s1_drop         INY                 ; Drop the character...
.1a580d	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next
.1a580f	c9 26		cmp #$26	                CMP #'&'
.1a5811	f0 08		beq $1a581b	                BEQ s2_drop         ; '&' --> S2, drop the '&'
.1a5813	20 ad 03	jsr $1a03ad	            JSR ISNUMERAL
.1a5816	90 d1		bcc $1a57e9	                BCC syntax_err
.1a5818	82 7a 00	brl $1a5895	                BRL s7_shift        ; '0'-'9' --> S7, shift
.1a581b	c8		iny		s2_drop         INY                 ; Drop the character
.1a581c	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.1a581e	c9 68		cmp #$68	                CMP #'h'
.1a5820	f0 0e		beq $1a5830	                BEQ s3_drop         ; 'h', 'H' --> S3, drop
.1a5822	c9 48		cmp #$48	                CMP #'H'
.1a5824	f0 0a		beq $1a5830	                BEQ s3_drop
.1a5826	c9 62		cmp #$62	                CMP #'b'
.1a5828	f0 4c		beq $1a5876	                BEQ s5_drop         ; 'b', 'B' --> S5, drop
.1a582a	c9 42		cmp #$42	                CMP #'B'
.1a582c	f0 48		beq $1a5876	                BEQ s5_drop
.1a582e	80 b9		bra $1a57e9	                BRA syntax_err
.1a5830	c8		iny		s3_drop         INY                 ; Drop the character
.1a5831	b7 00		lda [$0800],y	s3              LDA [BIP],Y         ; Get the next character
.1a5833	20 be 03	jsr $1a03be	            JSR ISHEX
.1a5836	b0 02		bcs $1a583a	                BCS s4_shift
.1a5838	80 af		bra $1a57e9	                BRA syntax_err
.1a583a					s4_shift
.1a583a	20 51 56	jsr $1a5651	            JSR SHIFTHEX
.1a583d	c8		iny		                INY
.1a583e	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.1a5840	20 be 03	jsr $1a03be	            JSR ISHEX
.1a5843	b0 f5		bcs $1a583a	                BCS s4_shift        ; '0'-'9','A'-'F' --> S4, shift
.1a5845					ret_integer
.1a5845	e2 20		sep #$20	            SEP #$20
.1a5847	a5 65		lda $0865	                LDA MARG5           ; check if the number should be negative
.1a5849	f0 11		beq $1a585c	                BEQ set_int_type    ; If not, just set the type and return
.1a584b	c2 20		rep #$20	            REP #$20
.1a584d	38		sec		                SEC                 ; If so, negate it
.1a584e	a9 00 00	lda #$0000	                LDA #0
.1a5851	e5 23		sbc $0823	                SBC ARGUMENT1
.1a5853	85 23		sta $0823	                STA ARGUMENT1
.1a5855	a9 00 00	lda #$0000	                LDA #0
.1a5858	e5 25		sbc $0825	                SBC ARGUMENT1+2
.1a585a	85 25		sta $0825	                STA ARGUMENT1+2
.1a585c					set_int_type
.1a585c	e2 20		sep #$20	            SEP #$20
.1a585e	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; Return an integer
.1a5860	85 27		sta $0827	                STA ARGTYPE1
.1a5862					stop
.1a5862	c2 20		rep #$20	            REP #$20
.1a5864	18		clc		                CLC
.1a5865	98		tya		                TYA
.1a5866	65 00		adc $0800	                ADC BIP
.1a5868	85 00		sta $0800	                STA BIP
.1a586a	a5 02		lda $0802	                LDA BIP+2
.1a586c	69 00 00	adc #$0000	                ADC #0
.1a586f	85 02		sta $0802	                STA BIP+2
.1a5871	e2 20		sep #$20	            SEP #$20
.1a5873	28		plp		                PLP
.1a5874	7a		ply		                PLY
.1a5875	60		rts		            RTS
.1a5876	c8		iny		s5_drop         INY                     ; Drop the character
.1a5877	b7 00		lda [$0800],y	s5              LDA [BIP],Y             ; Get the next character
.1a5879	c9 30		cmp #$30	                CMP #'0'
.1a587b	f0 07		beq $1a5884	                BEQ s6_shift            ; '0', '1' --> S6, shift
.1a587d	c9 31		cmp #$31	                CMP #'1'
.1a587f	f0 03		beq $1a5884	                BEQ s6_shift
.1a5881	82 65 ff	brl $1a57e9	                BRL syntax_err
.1a5884					s6_shift
.1a5884	20 a1 56	jsr $1a56a1	            JSR SHIFTBIN
.1a5887	c8		iny		                INY
.1a5888	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a588a	c9 30		cmp #$30	                CMP #'0'                ; '0', '1' --> S6, shift
.1a588c	f0 f6		beq $1a5884	                BEQ s6_shift
.1a588e	c9 31		cmp #$31	                CMP #'1'
.1a5890	f0 f2		beq $1a5884	                BEQ s6_shift
.1a5892	82 b0 ff	brl $1a5845	                BRL ret_integer         ; Return integer
.1a5895					s7_shift
.1a5895	20 35 56	jsr $1a5635	            JSR SHIFTDEC
.1a5898	c8		iny		                INY
.1a5899	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a589b	c9 2e		cmp #$2e	                CMP #'.'                ; '.' --> S8, drop and preserve mantissa
.1a589d	f0 08		beq $1a58a7	                BEQ s8_mantissa
.1a589f	20 ad 03	jsr $1a03ad	            JSR ISNUMERAL
.1a58a2	b0 f1		bcs $1a5895	                BCS s7_shift
.1a58a4	82 9e ff	brl $1a5845	                BRL ret_integer         ; Return integer
.1a58a7					s8_mantissa
.1a58a7	c2 20		rep #$20	            REP #$20
.1a58a9	20 71 59	jsr $1a5971	            JSR ITOF
.1a58ac	c2 20		rep #$20	            REP #$20
.1a58ae	a5 23		lda $0823	            LDA ARGUMENT1
.1a58b0	85 55		sta $0855	            STA MARG1
.1a58b2	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a58b4	85 57		sta $0857	            STA MARG1+2
.1a58b6	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the decimal
.1a58b8	64 25		stz $0825	                STZ ARGUMENT1+2
.1a58ba	e2 20		sep #$20	            SEP #$20
.1a58bc	80 36		bra $1a58f4	                BRA s8_drop
.1a58be					s8_shift
.1a58be	20 35 56	jsr $1a5635	            JSR SHIFTDEC
.1a58c1	c2 20		rep #$20	            REP #$20
.1a58c3	a5 5f		lda $085f	                LDA MARG3+2             ; high 16 bits
.1a58c5	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.1a58c9	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.1a58cc	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.1a58d0	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to high 16 bits of MARG3
.1a58d4	85 5f		sta $085f	                STA MARG3+2
.1a58d6	a5 5d		lda $085d	                LDA MARG3
.1a58d8	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.1a58dc	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.1a58df	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.1a58e3	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to MARG3
.1a58e7	85 5d		sta $085d	                STA MARG3
.1a58e9	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.1a58ed	18		clc		                CLC
.1a58ee	65 5f		adc $085f	                ADC MARG3+2
.1a58f0	85 5f		sta $085f	                STA MARG3+2
.1a58f2	e2 20		sep #$20	            SEP #$20
.1a58f4					s8_drop
.1a58f4	c8		iny		                INY
.1a58f5	b7 00		lda [$0800],y	                LDA [BIP],Y
.1a58f7	c9 65		cmp #$65	                CMP #'e'                ; 'E' --> S9, drop
.1a58f9	f0 24		beq $1a591f	                BEQ s9_drop
.1a58fb	c9 45		cmp #$45	                CMP #'E'
.1a58fd	f0 20		beq $1a591f	                BEQ s9_drop
.1a58ff	20 ad 03	jsr $1a03ad	            JSR ISNUMERAL
.1a5902	b0 ba		bcs $1a58be	                BCS s8_shift
.1a5904	c2 20		rep #$20	            REP #$20
.1a5906	20 71 59	jsr $1a5971	            JSR ITOF
.1a5909	c2 20		rep #$20	            REP #$20
.1a590b	a5 23		lda $0823	            LDA ARGUMENT1
.1a590d	85 59		sta $0859	            STA MARG2
.1a590f	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5911	85 5b		sta $085b	            STA MARG2+2
.1a5913	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.1a5915	64 25		stz $0825	                STZ ARGUMENT1+2
.1a5917	20 58 57	jsr $1a5758	            JSR PACKFLOAT
.1a591a	e2 20		sep #$20	            SEP #$20
.1a591c	82 43 ff	brl $1a5862	                BRL stop
.1a591f					s9_drop
.1a591f	c2 20		rep #$20	            REP #$20
.1a5921	20 71 59	jsr $1a5971	            JSR ITOF
.1a5924	c2 20		rep #$20	            REP #$20
.1a5926	a5 23		lda $0823	            LDA ARGUMENT1
.1a5928	85 59		sta $0859	            STA MARG2
.1a592a	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a592c	85 5b		sta $085b	            STA MARG2+2
.1a592e	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.1a5930	64 25		stz $0825	                STZ ARGUMENT1+2
.1a5932	e2 20		sep #$20	            SEP #$20
.1a5934	c8		iny		                INY
.1a5935	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a5937	c9 2b		cmp #$2b	                CMP #'+'
.1a5939	f0 10		beq $1a594b	                BEQ s10_drop            ; '+' --> S10, drop
.1a593b	c9 2d		cmp #$2d	                CMP #'-'
.1a593d	f0 08		beq $1a5947	                BEQ s10_setneg          ; '-' --> S10, set exponent is negative
.1a593f	20 ad 03	jsr $1a03ad	            JSR ISNUMERAL
.1a5942	b0 12		bcs $1a5956	                BCS S11_shift           ; '0'-'9' --> S11, shift
.1a5944	82 a2 fe	brl $1a57e9	                BRL syntax_err
.1a5947					s10_setneg
.1a5947	a9 01		lda #$01	                LDA #1                  ; Set that the exponent should be negative
.1a5949	85 69		sta $0869	                STA MARG6
.1a594b					s10_drop
.1a594b	c8		iny		                INY
.1a594c	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a594e	20 ad 03	jsr $1a03ad	            JSR ISNUMERAL
.1a5951	b0 03		bcs $1a5956	                BCS s11_shift
.1a5953	82 93 fe	brl $1a57e9	                BRL syntax_err
.1a5956					s11_shift
.1a5956	20 35 56	jsr $1a5635	            JSR SHIFTDEC
.1a5959	c8		iny		                INY
.1a595a	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.1a595c	20 ad 03	jsr $1a03ad	            JSR ISNUMERAL
.1a595f	b0 f5		bcs $1a5956	                BCS s11_shift
.1a5961	c2 20		rep #$20	            REP #$20
.1a5963	a5 23		lda $0823	            LDA ARGUMENT1
.1a5965	85 61		sta $0861	            STA MARG4
.1a5967	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a5969	85 63		sta $0863	            STA MARG4+2
.1a596b	20 58 57	jsr $1a5758	            JSR PACKFLOAT
.1a596e	82 f1 fe	brl $1a5862	                BRL stop
.1a5971					ITOF
.1a5971	08		php		                PHP
.1a5972	20 ff 53	jsr $1a53ff	            JSR FIXINT_TO_FP
.1a5975	28		plp		done            PLP
.1a5976	60		rts		            RTS
.1a5977					FTOI
.1a5977	08		php		                PHP
.1a5978					LOCALS
>0001					l_sign          .byte ?
>0002					l_exponent      .byte ?
>0003					l_mantissa      .dword ?
.1a5978	c2 20		rep #$20	            REP #$20
.1a597a	a9 6e 5c	lda #$5c6e	                LDA #<>FP_1_0
.1a597d	85 29		sta $0829	                STA ARGUMENT2
.1a597f	a9 1a 00	lda #$001a	                LDA #(FP_1_0 >> 16)
.1a5982	85 2b		sta $082b	                STA ARGUMENT2+2
.1a5984	e2 20		sep #$20	            SEP #$20
.1a5986	a9 01		lda #$01	                LDA #TYPE_FLOAT
.1a5988	85 2d		sta $082d	                STA ARGTYPE2
.1a598a	c2 20		rep #$20	            REP #$20
.1a598c	20 4a 5a	jsr $1a5a4a	            JSR FP_COMPARE
.1a598f	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a5992	d0 0c		bne $1a59a0	                BNE alloc_locals        ; No: get ready to do the full conversion
.1a5994	a9 00 00	lda #$0000	                LDA #0
.1a5997	8d 23 08	sta $0823	                STA @w ARGUMENT1        ; Yes: Return 0
.1a599a	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.1a599d	82 a1 00	brl $1a5a41	                BRL done
.1a59a0	f4 00 00	pea #$0000	alloc_locals    PEA #0                  ; Reserve space for the locals
.1a59a3	f4 00 00	pea #$0000	                PEA #0
.1a59a6	f4 00 00	pea #$0000	                PEA #0
.1a59a9	e2 20		sep #$20	            SEP #$20
.1a59ab	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3      ; Preserve the sign bit
.1a59ae	29 80		and #$80	                AND #$80
.1a59b0	83 01		sta $01,s	                STA l_sign
.1a59b2	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2      ; Preserve the exponent
.1a59b5	2a		rol a		                ROL A
.1a59b6	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3
.1a59b9	2a		rol a		                ROL A
.1a59ba	83 02		sta $02,s	                STA l_exponent
.1a59bc	a9 00		lda #$00	save_mantissa   LDA #0                  ; Save the mantissa (with the implied 1)
.1a59be	83 06		sta $06,s	                STA l_mantissa+3
.1a59c0	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2
.1a59c3	09 80		ora #$80	                ORA #$80
.1a59c5	83 05		sta $05,s	                STA l_mantissa+2
.1a59c7	ad 24 08	lda $0824	                LDA @w ARGUMENT1+1
.1a59ca	83 04		sta $04,s	                STA l_mantissa+1
.1a59cc	ad 23 08	lda $0823	                LDA @w ARGUMENT1
.1a59cf	83 03		sta $03,s	                STA l_mantissa
.1a59d1	a3 02		lda $02,s	                LDA l_exponent
.1a59d3	c9 96		cmp #$96	loop            CMP #150
.1a59d5	f0 3a		beq $1a5a11	                BEQ adj_sign
.1a59d7	90 1f		bcc $1a59f8	                BLT shift_right
.1a59d9	08		php		            PHP
.1a59da	c2 20		rep #$20	            REP #$20
.1a59dc	48		pha		            PHA
.1a59dd	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a59e0	5b		tcd		            TCD
.1a59e1	68		pla		            PLA
.1a59e2	28		plp		            PLP
.1a59e3	e2 20		sep #$20	            SEP #$20
.1a59e5	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.1a59e7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a59eb	c2 20		rep #$20	            REP #$20
.1a59ed	29 ff 00	and #$00ff	            AND #$00FF
.1a59f0	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a59f3	e2 20		sep #$20	            SEP #$20
.1a59f5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a59f8					shift_right
.1a59f8	c2 20		rep #$20	            REP #$20
.1a59fa	a3 05		lda $05,s	                LDA l_mantissa+2
.1a59fc	4a		lsr a		                LSR A
.1a59fd	83 05		sta $05,s	                STA l_mantissa+2
.1a59ff	a3 03		lda $03,s	                LDA l_mantissa
.1a5a01	6a		ror a		                ROR A
.1a5a02	83 03		sta $03,s	                STA l_mantissa
.1a5a04	e2 20		sep #$20	            SEP #$20
.1a5a06	a3 02		lda $02,s	                LDA l_exponent
.1a5a08	1a		inc a		                INC A
.1a5a09	83 02		sta $02,s	                STA l_exponent
.1a5a0b	c9 96		cmp #$96	                CMP #150
.1a5a0d	f0 02		beq $1a5a11	                BEQ adj_sign
.1a5a0f	80 e7		bra $1a59f8	                BRA shift_right
.1a5a11	a3 01		lda $01,s	adj_sign        LDA l_sign
.1a5a13	f0 1b		beq $1a5a30	                BEQ ret_positive
.1a5a15	c2 20		rep #$20	            REP #$20
.1a5a17	a3 03		lda $03,s	                LDA l_mantissa
.1a5a19	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a5a1c	18		clc		                CLC
.1a5a1d	69 01 00	adc #$0001	                ADC #1
.1a5a20	8d 23 08	sta $0823	                STA @w ARGUMENT1
.1a5a23	a3 05		lda $05,s	                LDA l_mantissa+2
.1a5a25	49 ff ff	eor #$ffff	                EOR #$FFFF
.1a5a28	69 00 00	adc #$0000	                ADC #0
.1a5a2b	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.1a5a2e	80 0c		bra $1a5a3c	                BRA clean
.1a5a30					ret_positive
.1a5a30	c2 20		rep #$20	            REP #$20
.1a5a32	a3 03		lda $03,s	                LDA l_mantissa
.1a5a34	8d 23 08	sta $0823	                STA @w ARGUMENT1
.1a5a37	a3 05		lda $05,s	                LDA l_mantissa+2
.1a5a39	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.1a5a3c					clean
.1a5a3c	c2 20		rep #$20	            REP #$20
.1a5a3e	68		pla		                PLA                     ; Clean up the locals
.1a5a3f	68		pla		                PLA
.1a5a40	68		pla		                PLA
.1a5a41					done
.1a5a41	e2 20		sep #$20	            SEP #$20
.1a5a43	a9 00		lda #$00	                LDA #TYPE_INTEGER       ; Set the return type to integer
.1a5a45	8d 27 08	sta $0827	                STA @w ARGTYPE1
.1a5a48	28		plp		                PLP
.1a5a49	60		rts		            RTS
.1a5a4a					FP_COMPARE
.1a5a4a	da		phx		                PHX
.1a5a4b	08		php		                PHP
.1a5a4c	c2 20		rep #$20	            REP #$20
.1a5a4e	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save ARGUMENT1 so we don't destroy it
.1a5a50	48		pha		                PHA
.1a5a51	a5 23		lda $0823	                LDA ARGUMENT1
.1a5a53	48		pha		                PHA
.1a5a54	20 43 54	jsr $1a5443	            JSR OP_FP_SUB
.1a5a57	20 21 56	jsr $1a5621	            JSR FARG1EQ0
.1a5a5a	b0 11		bcs $1a5a6d	                BCS are_equal
.1a5a5c	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Check the high word
.1a5a5e	89 00 80	bit #$8000	                BIT #$8000
.1a5a61	d0 05		bne $1a5a68	                BNE is_lt                   ; ARGUMENT1 < ARGUMENT2
.1a5a63	a9 01 00	lda #$0001	is_gt           LDA #1                      ; ARGUMENT1 > ARGUMENT2: return 1
.1a5a66	80 08		bra $1a5a70	                BRA ret_result
.1a5a68	a9 ff ff	lda #$ffff	is_lt           LDA #$FFFF                  ; ARGUMENT1 > ARGUMENT2: return -1
.1a5a6b	80 03		bra $1a5a70	                BRA ret_result
.1a5a6d	a9 00 00	lda #$0000	are_equal       LDA #0                      ; Equal: return 0
.1a5a70	fa		plx		ret_result      PLX                         ; Restore ARGUMENT1
.1a5a71	86 23		stx $0823	                STX ARGUMENT1
.1a5a73	fa		plx		                PLX
.1a5a74	86 25		stx $0825	                STX ARGUMENT1+2
.1a5a76	28		plp		                PLP
.1a5a77	fa		plx		                PLX
.1a5a78	60		rts		            RTS
.1a5a79					OP_FP_LT
.1a5a79	08		php		                PHP
.1a5a7a	c2 30		rep #$30	            REP #$30
.1a5a7c	20 4a 5a	jsr $1a5a4a	            JSR FP_COMPARE
.1a5a7f	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a5a82	d0 05		bne $1a5a89	                BNE ret_false
.1a5a84	20 df 04	jsr $1a04df	            JSR SET_TRUE
.1a5a87	80 03		bra $1a5a8c	                BRA done
.1a5a89					ret_false
.1a5a89	20 f1 04	jsr $1a04f1	            JSR SET_FALSE
.1a5a8c	28		plp		done            PLP
.1a5a8d	60		rts		            RTS
.1a5a8e					OP_FP_GT
.1a5a8e	08		php		                PHP
.1a5a8f	c2 30		rep #$30	            REP #$30
.1a5a91	20 4a 5a	jsr $1a5a4a	            JSR FP_COMPARE
.1a5a94	c9 01 00	cmp #$0001	                CMP #1
.1a5a97	d0 05		bne $1a5a9e	                BNE ret_false
.1a5a99	20 df 04	jsr $1a04df	            JSR SET_TRUE
.1a5a9c	80 03		bra $1a5aa1	                BRA done
.1a5a9e					ret_false
.1a5a9e	20 f1 04	jsr $1a04f1	            JSR SET_FALSE
.1a5aa1	28		plp		done            PLP
.1a5aa2	60		rts		            RTS
.1a5aa3					OP_FP_EQ
.1a5aa3	08		php		                PHP
.1a5aa4	c2 30		rep #$30	            REP #$30
.1a5aa6	20 4a 5a	jsr $1a5a4a	            JSR FP_COMPARE
.1a5aa9	c9 00 00	cmp #$0000	                CMP #0
.1a5aac	d0 05		bne $1a5ab3	                BNE ret_false
.1a5aae	20 df 04	jsr $1a04df	            JSR SET_TRUE
.1a5ab1	80 03		bra $1a5ab6	                BRA done
.1a5ab3					ret_false
.1a5ab3	20 f1 04	jsr $1a04f1	            JSR SET_FALSE
.1a5ab6	28		plp		done            PLP
.1a5ab7	60		rts		            RTS
.1a5ab8					OP_FP_LTE
.1a5ab8	08		php		                PHP
.1a5ab9	c2 30		rep #$30	            REP #$30
.1a5abb	20 4a 5a	jsr $1a5a4a	            JSR FP_COMPARE
.1a5abe	c9 01 00	cmp #$0001	                CMP #1
.1a5ac1	f0 05		beq $1a5ac8	                BEQ ret_false
.1a5ac3	20 df 04	jsr $1a04df	            JSR SET_TRUE
.1a5ac6	80 03		bra $1a5acb	                BRA done
.1a5ac8					ret_false
.1a5ac8	20 f1 04	jsr $1a04f1	            JSR SET_FALSE
.1a5acb	28		plp		done            PLP
.1a5acc	60		rts		            RTS
.1a5acd					OP_FP_GTE
.1a5acd	08		php		                PHP
.1a5ace	c2 30		rep #$30	            REP #$30
.1a5ad0	20 4a 5a	jsr $1a5a4a	            JSR FP_COMPARE
.1a5ad3	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a5ad6	f0 05		beq $1a5add	                BEQ ret_false
.1a5ad8	20 df 04	jsr $1a04df	            JSR SET_TRUE
.1a5adb	80 03		bra $1a5ae0	                BRA done
.1a5add					ret_false
.1a5add	20 f1 04	jsr $1a04f1	            JSR SET_FALSE
.1a5ae0	28		plp		done            PLP
.1a5ae1	60		rts		            RTS
.1a5ae2					OP_FP_NE
.1a5ae2	08		php		                PHP
.1a5ae3	c2 30		rep #$30	            REP #$30
.1a5ae5	20 4a 5a	jsr $1a5a4a	            JSR FP_COMPARE
.1a5ae8	c9 00 00	cmp #$0000	                CMP #0
.1a5aeb	f0 05		beq $1a5af2	                BEQ ret_false
.1a5aed	20 df 04	jsr $1a04df	            JSR SET_TRUE
.1a5af0	80 03		bra $1a5af5	                BRA done
.1a5af2					ret_false
.1a5af2	20 f1 04	jsr $1a04f1	            JSR SET_FALSE
.1a5af5	28		plp		done            PLP
.1a5af6	60		rts		            RTS
.1a5af7					STREMIT
.1a5af7	08		php		                PHP
.1a5af8	e2 20		sep #$20	            SEP #$20
.1a5afa	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Append the character
.1a5afc	c8		iny		                INY                         ; Advance the character pointer in Y
.1a5afd	a9 00		lda #$00	                LDA #0                      ; And add the NULL
.1a5aff	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.1a5b01	28		plp		                PLP
.1a5b02	60		rts		            RTS
.1a5b03					STREMITB
.1a5b03	da		phx		                PHX
.1a5b04	08		php		                PHP
.1a5b05	e2 20		sep #$20	            SEP #$20
.1a5b07	c9 80		cmp #$80	                CMP #$80
.1a5b09	90 0a		bcc $1a5b15	                BLT emit_digits
.1a5b0b	48		pha		                PHA
.1a5b0c	a9 2d		lda #$2d	                LDA #'-'                    ; Print a minus sign
.1a5b0e	20 f7 5a	jsr $1a5af7	            JSR STREMIT
.1a5b11	68		pla		                PLA
.1a5b12	49 ff		eor #$ff	                EOR #$FF                    ; And negate it
.1a5b14	1a		inc a		                INC A
.1a5b15					emit_digits
.1a5b15	c2 30		rep #$30	            REP #$30
.1a5b17	29 ff 00	and #$00ff	                AND #$00FF
.1a5b1a	c9 64 00	cmp #$0064	                CMP #100
.1a5b1d	90 0e		bcc $1a5b2d	                BLT chk_tens
.1a5b1f	a2 64 00	ldx #$0064	                LDX #100
.1a5b22	20 e8 53	jsr $1a53e8	            JSR UINT_DIV_A_X
.1a5b25	18		clc		                CLC
.1a5b26	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.1a5b29	20 f7 5a	jsr $1a5af7	            JSR STREMIT
.1a5b2c	8a		txa		                TXA                         ; Put the remainder in A
.1a5b2d					chk_tens
.1a5b2d	a2 0a 00	ldx #$000a	                LDX #10
.1a5b30	20 e8 53	jsr $1a53e8	            JSR UINT_DIV_A_X
.1a5b33	18		clc		                CLC
.1a5b34	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.1a5b37	20 f7 5a	jsr $1a5af7	            JSR STREMIT
.1a5b3a	8a		txa		                TXA                         ; Put the remainder in A
.1a5b3b					ones_digit
.1a5b3b	18		clc		                CLC
.1a5b3c	69 30 00	adc #$0030	                ADC #'0'                    ; Convert it to ASCII
.1a5b3f	20 f7 5a	jsr $1a5af7	            JSR STREMIT
.1a5b42	28		plp		                PLP
.1a5b43	fa		plx		                PLX
.1a5b44	60		rts		            RTS
.1a5b45					STRFINDEND
.1a5b45	08		php		                PHP
.1a5b46	e2 20		sep #$20	            SEP #$20
.1a5b48	c2 10		rep #$10	            REP #$10
.1a5b4a	a0 00 00	ldy #$0000	                LDY #0
.1a5b4d	b7 23		lda [$0823],y	find_end        LDA [ARGUMENT1],Y           ; Scan to the end of the string
.1a5b4f	f0 03		beq $1a5b54	                BEQ done
.1a5b51	c8		iny		                INY
.1a5b52	80 f9		bra $1a5b4d	                BRA find_end
.1a5b54	28		plp		done            PLP
.1a5b55	60		rts		            RTS
=6					FP_D = 6        ; Number of mantissa digits
.1a5b56					FTOS
.1a5b56	08		php		                PHP
.1a5b57	e2 20		sep #$20	            SEP #$20
.1a5b59	c2 10		rep #$10	            REP #$10
.1a5b5b	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be the negative flag
.1a5b5e	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be K
.1a5b61	f4 00 00	pea #$0000	                PEA #0                      ; This spot will be for the exponents
>0001					L_NEGATIVE      .word ?
>0003					L_K             .word ?
>0005					L_X1            .byte ?                     ; The binary exponent
>0006					L_EXP           .byte ?                     ; The decimal exponent
.1a5b64	20 21 56	jsr $1a5621	            JSR FARG1EQ0
.1a5b67	90 19		bcc $1a5b82	                BCC chk_negative
.1a5b69	20 ae 13	jsr $1a13ae	            JSR TEMPSTRING
.1a5b6c	e2 20		sep #$20	            SEP #$20
.1a5b6e	a0 00 00	ldy #$0000	                LDY #0
.1a5b71	a9 20		lda #$20	                LDA #' '
.1a5b73	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a5b75	c8		iny		                INY
.1a5b76	a9 30		lda #$30	                LDA #'0'                    ; Return a "0"
.1a5b78	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a5b7a	c8		iny		                INY
.1a5b7b	a9 00		lda #$00	                LDA #0
.1a5b7d	97 16		sta [$0816],y	                STA [STRPTR],Y
.1a5b7f	82 ce 00	brl $1a5c50	                BRL ret_result
.1a5b82					chk_negative
.1a5b82	e2 20		sep #$20	            SEP #$20
.1a5b84	a5 26		lda $0826	                LDA ARGUMENT1+3             ; If N is negative, output a minus sign and negate N
.1a5b86	10 08		bpl $1a5b90	                BPL not_negative
.1a5b88	29 7f		and #$7f	                AND #$7F                    ; Negate the number
.1a5b8a	85 26		sta $0826	                STA ARGUMENT1+3
.1a5b8c	a9 01		lda #$01	                LDA #1
.1a5b8e	83 01		sta $01,s	                STA L_NEGATIVE              ; Set IsNegative to a TRUE value
.1a5b90					not_negative
.1a5b90	c2 20		rep #$20	            REP #$20
.1a5b92	a9 00 00	lda #$0000	                LDA #0                      ; Initialize K to 0, K is a 1-byte signed integer. (SCRATCH is K)
.1a5b95	83 03		sta $03,s	                STA L_K                     ; We're using a word here for convenience
.1a5b97	c2 20		rep #$20	            REP #$20
.1a5b99	af 6a 5c 1a	lda $1a5c6a	            LDA ten_d_1
.1a5b9d	85 29		sta $0829	            STA ARGUMENT2
.1a5b9f	af 6c 5c 1a	lda $1a5c6c	            LDA ten_d_1+2
.1a5ba3	85 2b		sta $082b	            STA ARGUMENT2+2
.1a5ba5	20 4a 5a	jsr $1a5a4a	            JSR FP_COMPARE
.1a5ba8	89 00 80	bit #$8000	                BIT #$8000                  ; Is N < 10^(D-1)?
.1a5bab	d0 12		bne $1a5bbf	                BNE shift_up
.1a5bad					shift_down
.1a5bad	20 e5 55	jsr $1a55e5	            JSR FP_DIV10
.1a5bb0	a3 03		lda $03,s	                LDA L_K
.1a5bb2	1a		inc a		                INC A
.1a5bb3	83 03		sta $03,s	                STA L_K                     ; Increment K
.1a5bb5	20 4a 5a	jsr $1a5a4a	            JSR FP_COMPARE
.1a5bb8	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N < 10^(D-1)?
.1a5bbb	f0 12		beq $1a5bcf	                BEQ do_digits               ; Yes: we're ready to process digits
.1a5bbd	80 ee		bra $1a5bad	                BRA shift_down              ; No: keep dividing
.1a5bbf					shift_up
.1a5bbf	20 9c 55	jsr $1a559c	            JSR FP_MUL10
.1a5bc2	a3 03		lda $03,s	                LDA L_K
.1a5bc4	3a		dec a		                DEC A
.1a5bc5	83 03		sta $03,s	                STA L_K                     ; Decrement K
.1a5bc7	20 4a 5a	jsr $1a5a4a	            JSR FP_COMPARE
.1a5bca	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N >= 10 ^ (D-1)?
.1a5bcd	f0 f0		beq $1a5bbf	                BEQ shift_up                ; No: keep multiplying
.1a5bcf					do_digits
.1a5bcf	e2 30		sep #$30	            SEP #$30
.1a5bd1	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5bd3	0a		asl a		                ASL A
.1a5bd4	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a5bd6	2a		rol a		                ROL A
.1a5bd7	83 05		sta $05,s	                STA L_X1
.1a5bd9	38		sec		                SEC
.1a5bda	a9 96		lda #$96	                LDA #150                    ; X := 150 - X1
.1a5bdc	e3 05		sbc $05,s	                SBC L_X1
.1a5bde	aa		tax		                TAX
.1a5bdf	f0 0f		beq $1a5bf0	                BEQ emit_digits             ; If X = 0, just emit the digits
.1a5be1	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Set the implied '1' MSB of the mantissa
.1a5be3	09 80		ora #$80	                ORA #$80
.1a5be5	85 25		sta $0825	                STA ARGUMENT1+2
.1a5be7	46 25		lsr $0825	shift_r         LSR ARGUMENT1+2             ; Shift the mantissa right
.1a5be9	66 24		ror $0824	                ROR ARGUMENT1+1
.1a5beb	66 23		ror $0823	                ROR ARGUMENT1
.1a5bed	ca		dex		                DEX
.1a5bee	d0 f7		bne $1a5be7	                BNE shift_r                 ; Until X = 0
.1a5bf0					emit_digits
.1a5bf0	c2 10		rep #$10	            REP #$10
.1a5bf2	e2 20		sep #$20	            SEP #$20
.1a5bf4	64 26		stz $0826	                STZ ARGUMENT1+3             ; Blank out the MSB
.1a5bf6	a9 00		lda #$00	                LDA #TYPE_INTEGER           ; Make it an integer
.1a5bf8	85 27		sta $0827	                STA ARGTYPE1
.1a5bfa	a3 01		lda $01,s	                LDA L_NEGATIVE              ; Check IsNegative
.1a5bfc	f0 11		beq $1a5c0f	                BEQ get_raw_digits          ; If FALSE, just convert the raw digits
.1a5bfe	c2 20		rep #$20	            REP #$20
.1a5c00	38		sec		                SEC                         ; Make the raw integer negative
.1a5c01	a9 00 00	lda #$0000	                LDA #0
.1a5c04	e5 23		sbc $0823	                SBC ARGUMENT1
.1a5c06	85 23		sta $0823	                STA ARGUMENT1
.1a5c08	a9 00 00	lda #$0000	                LDA #0
.1a5c0b	e5 25		sbc $0825	                SBC ARGUMENT1+2
.1a5c0d	85 25		sta $0825	                STA ARGUMENT1+2
.1a5c0f					get_raw_digits
.1a5c0f	20 0d 14	jsr $1a140d	            JSR ITOS
.1a5c12	c2 20		rep #$20	            REP #$20
.1a5c14	a5 16		lda $0816	            LDA STRPTR
.1a5c16	85 23		sta $0823	            STA ARGUMENT1
.1a5c18	a5 18		lda $0818	            LDA STRPTR+2
.1a5c1a	85 25		sta $0825	            STA ARGUMENT1+2
.1a5c1c	20 45 5b	jsr $1a5b45	            JSR STRFINDEND
.1a5c1f	e2 20		sep #$20	            SEP #$20
.1a5c21	c8		iny		                INY                         ; Move the NULL up one byte
.1a5c22	a9 00		lda #$00	                LDA #0
.1a5c24	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.1a5c26	88		dey		insert_loop     DEY                         ; Move to the character before the one we just moved
.1a5c27	88		dey		                DEY
.1a5c28	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y           ; Get the character
.1a5c2a	c8		iny		                INY                         ; Move to the next space
.1a5c2b	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Store the character here
.1a5c2d	c0 02 00	cpy #$0002	                CPY #2                      ; Check to see if we just moved the 2nd character
.1a5c30	d0 f4		bne $1a5c26	                BNE insert_loop             ; If not, keep moving the characters
.1a5c32	a9 2e		lda #$2e	                LDA #'.'                    ; Insert the '.' in the space we openned
.1a5c34	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.1a5c36	e2 20		sep #$20	            SEP #$20
.1a5c38	18		clc		                CLC                         ; Compute the exponent
.1a5c39	a3 03		lda $03,s	                LDA L_K
.1a5c3b	69 05		adc #$05	                ADC #(FP_D - 1)
.1a5c3d	83 06		sta $06,s	                STA L_EXP
.1a5c3f	f0 19		beq $1a5c5a	                BEQ done                    ; If it's 0, just return the number
.1a5c41	20 45 5b	jsr $1a5b45	            JSR STRFINDEND
.1a5c44	a9 45		lda #$45	                LDA #'E'                    ; Append the "E"
.1a5c46	20 f7 5a	jsr $1a5af7	            JSR STREMIT
.1a5c49	a3 06		lda $06,s	                LDA L_EXP
.1a5c4b	20 03 5b	jsr $1a5b03	            JSR STREMITB
.1a5c4e	80 0a		bra $1a5c5a	                BRA done                    ; TODO: reformat integer... add E and exponent...
.1a5c50					ret_result
.1a5c50	c2 20		rep #$20	            REP #$20
.1a5c52	a5 16		lda $0816	                LDA STRPTR                  ; Return the temporary string we've assembled
.1a5c54	85 23		sta $0823	                STA ARGUMENT1
.1a5c56	a5 18		lda $0818	                LDA STRPTR+2
.1a5c58	85 25		sta $0825	                STA ARGUMENT1+2
.1a5c5a					done
.1a5c5a	e2 20		sep #$20	            SEP #$20
.1a5c5c	a9 02		lda #$02	                LDA #TYPE_STRING
.1a5c5e	85 27		sta $0827	                STA ARGTYPE1
.1a5c60	c2 20		rep #$20	            REP #$20
.1a5c62	3b		tsc		                TSC                         ; Remove the locals from the stack
.1a5c63	18		clc		                CLC
.1a5c64	69 06 00	adc #$0006	                ADC #6
.1a5c67	1b		tcs		                TCS
.1a5c68	28		plp		                PLP
.1a5c69	60		rts		            RTS
>1a5c6a	00 50 c3 47			ten_d_1         .dword $47c35000            ; 10^(FP_D-1), where FP_D=5
>1a5c6e	00 00 80 3f			FP_1_0          .dword $3f800000    ; Floating point constant: 1.0
>1a5c72	f3 04 b5 3f			FP_SQR_2_0      .dword $3fb504f3    ; Floating point constant: sqrt(2.0)
>1a5c76	f3 04 35 3f			FP_SQR_0_5      .dword $3f3504f3    ; Floating point constant: sqrt(0.2)

;******  Return to file: src\basic816.s


;******  Processing file: src\transcendentals.s

.1a5c7a					Q_POLY_HR
.1a5c7a	e2 20		sep #$20	            SEP #$20
.1a5c7c	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a5c7e	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5c82	c2 20		rep #$20	            REP #$20
.1a5c84	bd 00 00	lda $0000,x	                LDA 0,X
.1a5c87	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5c8b	bd 02 00	lda $0002,x	                LDA 2,X
.1a5c8e	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5c92	88		dey		                DEY             ; (Y-1) more coefficients.
.1a5c93	e8		inx		loop            INX             ; point to the next coefficient
.1a5c94	e8		inx		                INX
.1a5c95	e8		inx		                INX
.1a5c96	e8		inx		                INX
.1a5c97	e2 20		sep #$20	            SEP #$20
.1a5c99	a9 00		lda #$00	                LDA #FP_OUT_MULT
.1a5c9b	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5c9f	c2 20		rep #$20	            REP #$20
.1a5ca1	af 23 08 00	lda $000823	                LDA @l ARGUMENT1
.1a5ca5	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5ca9	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a5cad	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5cb1	ea		nop		                NOP
.1a5cb2	ea		nop		                NOP
.1a5cb3	ea		nop		                NOP
.1a5cb4	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5cb8	48		pha		                PHA
.1a5cb9	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5cbd	8f 0a e2 af	sta $afe20a	                STA FP_MATH_INPUT0_HL
.1a5cc1	68		pla		                PLA
.1a5cc2	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5cc6	e2 20		sep #$20	            SEP #$20
.1a5cc8	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a5cca	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5cce	c2 20		rep #$20	            REP #$20
.1a5cd0	bd 00 00	lda $0000,x	                LDA 0,X
.1a5cd3	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5cd7	bd 02 00	lda $0002,x	                LDA 2,X
.1a5cda	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5cde	ea		nop		                NOP
.1a5cdf	ea		nop		                NOP
.1a5ce0	ea		nop		                NOP
.1a5ce1	88		dey		                DEY
.1a5ce2	f0 14		beq $1a5cf8	                BEQ done
.1a5ce4	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5ce8	48		pha		                PHA
.1a5ce9	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5ced	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5cf1	68		pla		                PLA
.1a5cf2	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5cf6	80 9b		bra $1a5c93	                BRA loop
.1a5cf8	af 08 e2 af	lda $afe208	done            LDA @l FP_MATH_OUTPUT_FP_LL
.1a5cfc	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.1a5d00	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5d04	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.1a5d08	60		rts		                RTS
.1a5d09					Q_SQ
.1a5d09	e2 20		sep #$20	            SEP #$20
.1a5d0b	a9 00		lda #$00	                LDA #0
.1a5d0d	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5d11	a9 00		lda #$00	                LDA #FP_OUT_MULT
.1a5d13	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5d17	c2 20		rep #$20	            REP #$20
.1a5d19	a5 23		lda $0823	                LDA ARGUMENT1
.1a5d1b	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5d1f	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5d23	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a5d27	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5d2b	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5d2f	ea		nop		                NOP
.1a5d30	ea		nop		                NOP
.1a5d31	ea		nop		                NOP
.1a5d32	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5d36	85 23		sta $0823	                STA ARGUMENT1
.1a5d38	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5d3c	85 25		sta $0825	                STA ARGUMENT1+2
.1a5d3e	60		rts		                RTS
.1a5d3f					Q_INV
.1a5d3f	e2 20		sep #$20	            SEP #$20
.1a5d41	a9 00		lda #$00	                LDA #0
.1a5d43	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5d47	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a5d49	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5d4d	c2 20		rep #$20	            REP #$20
.1a5d4f	a5 23		lda $0823	                LDA ARGUMENT1
.1a5d51	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5d55	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a5d59	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5d5d	af 93 63 1a	lda $1a6393	                LDA @l fp_one
.1a5d61	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5d65	af 95 63 1a	lda $1a6395	                LDA @l fp_one+2
.1a5d69	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5d6d	ea		nop		                NOP
.1a5d6e	ea		nop		                NOP
.1a5d6f	ea		nop		                NOP
.1a5d70	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5d74	85 23		sta $0823	                STA ARGUMENT1
.1a5d76	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5d7a	85 25		sta $0825	                STA ARGUMENT1+2
.1a5d7c	60		rts		                RTS
.1a5d7d					Q_FP_SCALE
.1a5d7d	a2 00 00	ldx #$0000	                LDX #0
.1a5d80	a5 23		lda $0823	loop            LDA ARGUMENT1
.1a5d82	c5 29		cmp $0829	                CMP ARGUMENT2
.1a5d84	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5d86	e5 2b		sbc $082b	                SBC ARGUMENT2+2
.1a5d88	90 1e		bcc $1a5da8	                BCC done
.1a5d8a	a5 23		lda $0823	                LDA ARGUMENT1
.1a5d8c	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5d90	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5d92	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5d96	ea		nop		                NOP
.1a5d97	ea		nop		                NOP
.1a5d98	ea		nop		                NOP
.1a5d99	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5d9d	85 23		sta $0823	                STA ARGUMENT1
.1a5d9f	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5da3	85 25		sta $0825	                STA ARGUMENT1+2
.1a5da5	e8		inx		                INX
.1a5da6	80 d8		bra $1a5d80	                BRA loop
.1a5da8					done
.1a5da8	60		rts		            RTS
.1a5da9					Q_FP_SCALE_TAU
.1a5da9	e2 20		sep #$20	            SEP #$20
.1a5dab	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a5dad	10 09		bpl $1a5db8	                BPL notneg
.1a5daf	29 7f		and #$7f	                AND #$7F
.1a5db1	85 26		sta $0826	                STA ARGUMENT1+3
.1a5db3	a9 01		lda #$01	                LDA #1
.1a5db5	48		pha		                PHA
.1a5db6	80 03		bra $1a5dbb	                BRA compute
.1a5db8	a9 00		lda #$00	notneg          LDA #0          ; not negative, so push 0.
.1a5dba	48		pha		                PHA
.1a5dbb	a9 40		lda #$40	compute         LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a5dbd	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5dc1	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a5dc3	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5dc7	c2 30		rep #$30	            REP #$30
.1a5dc9	af fb 63 1a	lda $1a63fb	                LDA @l twopi
.1a5dcd	85 29		sta $0829	                STA ARGUMENT2
.1a5dcf	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5dd3	af fd 63 1a	lda $1a63fd	                LDA @l twopi+2
.1a5dd7	85 2b		sta $082b	                STA ARGUMENT2+2
.1a5dd9	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5ddd	20 7d 5d	jsr $1a5d7d	            JSR Q_FP_SCALE
.1a5de0	e2 20		sep #$20	            SEP #$20
.1a5de2	68		pla		                PLA
.1a5de3	c2 20		rep #$20	            REP #$20
.1a5de5	f0 1e		beq $1a5e05	                BEQ done
.1a5de7	a5 23		lda $0823	                LDA ARGUMENT1
.1a5de9	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5ded	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5def	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5df3	ea		nop		                NOP
.1a5df4	ea		nop		                NOP
.1a5df5	ea		nop		                NOP
.1a5df6	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5dfa	85 23		sta $0823	                STA ARGUMENT1
.1a5dfc	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5e00	29 ff 7f	and #$7fff	                AND #$7fff
.1a5e03	85 25		sta $0825	                STA ARGUMENT1+2
.1a5e05					done
.1a5e05	60		rts		            RTS
.1a5e06					Q_FP_NORM_ANGLE
.1a5e06	5a		phy		                PHY
.1a5e07	a2 00 00	ldx #$0000	                LDX #0
.1a5e0a	a0 00 00	ldy #$0000	                LDY #0
.1a5e0d	a5 23		lda $0823	loop            LDA ARGUMENT1
.1a5e0f	df ff 63 1a	cmp $1a63ff,x	                CMP @l onepi,x
.1a5e13	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5e15	ff 01 64 1a	sbc $1a6401,x	                SBC @l onepi+2,x
.1a5e19	90 2c		bcc $1a5e47	                BCC less
.1a5e1b	bf fb 63 1a	lda $1a63fb,x	                LDA @l twopi,x
.1a5e1f	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5e23	bf fd 63 1a	lda $1a63fd,x	                LDA @l twopi+2,x
.1a5e27	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5e2b	a5 23		lda $0823	                LDA ARGUMENT1
.1a5e2d	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5e31	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5e33	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5e37	ea		nop		                NOP
.1a5e38	ea		nop		                NOP
.1a5e39	ea		nop		                NOP
.1a5e3a	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5e3e	85 23		sta $0823	                STA ARGUMENT1
.1a5e40	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5e44	85 25		sta $0825	                STA ARGUMENT1+2
.1a5e46	38		sec		                SEC             ; set carry to indicate a reflection
.1a5e47	98		tya		less            TYA             ; carry already cleared if we branched
.1a5e48	2a		rol a		                ROL             ; shift carry into flags...
.1a5e49	a8		tay		                TAY             ; and store back into y
.1a5e4a	e8		inx		                INX             ; next set of values
.1a5e4b	e8		inx		                INX
.1a5e4c	e8		inx		                INX
.1a5e4d	e8		inx		                INX
.1a5e4e	e0 0c 00	cpx #$000c	                CPX #12         ; check if we have already looked at 3
.1a5e51	d0 ba		bne $1a5e0d	                BNE loop
.1a5e53	98		tya		                TYA             ; copy Y to X, as that's what we have
.1a5e54	aa		tax		                TAX
.1a5e55	7a		ply		                PLY
.1a5e56	60		rts		            RTS
.1a5e57					Q_FP_COS
.1a5e57	08		php		                PHP
.1a5e58	c2 30		rep #$30	            REP #$30
.1a5e5a	48		pha		                PHA
.1a5e5b	da		phx		                PHX
.1a5e5c	20 09 5d	jsr $1a5d09	            JSR Q_SQ
.1a5e5f	8b		phb		                PHB
.1a5e60	e2 20		sep #$20	            SEP #$20
.1a5e62	a9 1a		lda #$1a	                LDA #`cos_coeff
.1a5e64	48		pha		                PHA
.1a5e65	ab		plb		                PLB
.1a5e66	c2 20		rep #$20	            REP #$20
.1a5e68	a2 3b 63	ldx #$633b	                LDX #<>cos_coeff
.1a5e6b	5a		phy		                PHY
.1a5e6c	a0 05 00	ldy #$0005	                LDY #5
.1a5e6f	20 7a 5c	jsr $1a5c7a	            JSR Q_POLY_HR
.1a5e72	7a		ply		                PLY
.1a5e73	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.1a5e76	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.1a5e7a	ab		plb		                PLB
.1a5e7b	fa		plx		                PLX
.1a5e7c	68		pla		                PLA
.1a5e7d	28		plp		                PLP
.1a5e7e	60		rts		            RTS
.1a5e7f					Q_FP_SIN
.1a5e7f	08		php		                PHP
.1a5e80	c2 30		rep #$30	            REP #$30
.1a5e82	48		pha		                PHA
.1a5e83	da		phx		                PHX
.1a5e84	a5 23		lda $0823	                LDA ARGUMENT1
.1a5e86	85 29		sta $0829	                STA ARGUMENT2
.1a5e88	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5e8a	85 2b		sta $082b	                STA ARGUMENT2+2
.1a5e8c	20 09 5d	jsr $1a5d09	            JSR Q_SQ
.1a5e8f	8b		phb		                PHB
.1a5e90	e2 20		sep #$20	            SEP #$20
.1a5e92	a9 1a		lda #$1a	                LDA #`sin_coeff
.1a5e94	48		pha		                PHA
.1a5e95	ab		plb		                PLB
.1a5e96	c2 20		rep #$20	            REP #$20
.1a5e98	a2 4f 63	ldx #$634f	                LDX #<>sin_coeff
.1a5e9b	5a		phy		                PHY
.1a5e9c	a0 05 00	ldy #$0005	                LDY #5
.1a5e9f	20 7a 5c	jsr $1a5c7a	            JSR Q_POLY_HR
.1a5ea2	7a		ply		                PLY
.1a5ea3	ab		plb		                PLB
.1a5ea4	20 e4 54	jsr $1a54e4	            JSR OP_FP_MUL
.1a5ea7	fa		plx		                PLX
.1a5ea8	68		pla		                PLA
.1a5ea9	28		plp		                PLP
.1a5eaa	60		rts		            RTS
.1a5eab					Q_FP_TAN
.1a5eab	08		php		                PHP
.1a5eac	c2 30		rep #$30	            REP #$30
.1a5eae	48		pha		                PHA
.1a5eaf	da		phx		                PHX
.1a5eb0	a5 23		lda $0823	                LDA ARGUMENT1
.1a5eb2	85 29		sta $0829	                STA ARGUMENT2
.1a5eb4	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5eb6	85 2b		sta $082b	                STA ARGUMENT2+2
.1a5eb8	20 09 5d	jsr $1a5d09	            JSR Q_SQ
.1a5ebb	8b		phb		                PHB
.1a5ebc	e2 20		sep #$20	            SEP #$20
.1a5ebe	a9 1a		lda #$1a	                LDA #`tan_coeff
.1a5ec0	48		pha		                PHA
.1a5ec1	ab		plb		                PLB
.1a5ec2	c2 20		rep #$20	            REP #$20
.1a5ec4	a2 63 63	ldx #$6363	                LDX #<>tan_coeff
.1a5ec7	5a		phy		                PHY
.1a5ec8	a0 05 00	ldy #$0005	                LDY #5
.1a5ecb	20 7a 5c	jsr $1a5c7a	            JSR Q_POLY_HR
.1a5ece	7a		ply		                PLY
.1a5ecf	ab		plb		                PLB
.1a5ed0	20 e4 54	jsr $1a54e4	            JSR OP_FP_MUL
.1a5ed3	fa		plx		                PLX
.1a5ed4	68		pla		                PLA
.1a5ed5	28		plp		                PLP
.1a5ed6	60		rts		            RTS
.1a5ed7					Q_FP_LN
.1a5ed7	08		php		                PHP
.1a5ed8	c2 30		rep #$30	            REP #$30
.1a5eda	48		pha		                PHA
.1a5edb	da		phx		                PHX
.1a5edc	e2 20		sep #$20	            SEP #$20
.1a5ede	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a5ee0	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5ee4	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a5ee6	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5eea	c2 20		rep #$20	            REP #$20
.1a5eec	a5 23		lda $0823	                LDA ARGUMENT1
.1a5eee	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5ef2	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5ef4	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5ef8	af 93 63 1a	lda $1a6393	                LDA @l fp_one
.1a5efc	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5f00	af 95 63 1a	lda $1a6395	                LDA @l fp_one+2
.1a5f04	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5f08	ea		nop		                NOP
.1a5f09	ea		nop		                NOP
.1a5f0a	ea		nop		                NOP
.1a5f0b	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5f0f	85 0c		sta $080c	                STA SCRATCH
.1a5f11	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5f15	85 0e		sta $080e	                STA SCRATCH+2
.1a5f17	e2 20		sep #$20	            SEP #$20
.1a5f19	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.1a5f1b	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5f1f	c2 20		rep #$20	            REP #$20
.1a5f21	ea		nop		                NOP
.1a5f22	ea		nop		                NOP
.1a5f23	ea		nop		                NOP
.1a5f24	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5f28	85 10		sta $0810	                STA SCRATCH2
.1a5f2a	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5f2e	85 12		sta $0812	                STA SCRATCH2+2
.1a5f30	e2 20		sep #$20	            SEP #$20
.1a5f32	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a5f34	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5f38	c2 20		rep #$20	            REP #$20
.1a5f3a	a5 0c		lda $080c	                LDA SCRATCH
.1a5f3c	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5f40	a5 0e		lda $080e	                LDA SCRATCH+2
.1a5f42	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5f46	a5 10		lda $0810	                LDA SCRATCH2
.1a5f48	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a5f4c	a5 12		lda $0812	                LDA SCRATCH2+2
.1a5f4e	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a5f52	ea		nop		                NOP
.1a5f53	ea		nop		                NOP
.1a5f54	ea		nop		                NOP
.1a5f55	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5f59	85 23		sta $0823	                STA ARGUMENT1
.1a5f5b	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5f5f	85 25		sta $0825	                STA ARGUMENT1+2
.1a5f61	e2 20		sep #$20	            SEP #$20
.1a5f63	a9 08		lda #$08	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX0
.1a5f65	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a5f69	a9 02		lda #$02	                LDA #FP_OUT_ADD
.1a5f6b	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a5f6f	c2 20		rep #$20	            REP #$20
.1a5f71	a5 23		lda $0823	                LDA ARGUMENT1
.1a5f73	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.1a5f77	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a5f79	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.1a5f7d	ea		nop		                NOP
.1a5f7e	ea		nop		                NOP
.1a5f7f	ea		nop		                NOP
.1a5f80	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.1a5f84	85 29		sta $0829	                STA ARGUMENT2
.1a5f86	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.1a5f8a	85 2b		sta $082b	                STA ARGUMENT2+2
.1a5f8c	20 09 5d	jsr $1a5d09	            JSR Q_SQ
.1a5f8f	8b		phb		                PHB
.1a5f90	e2 20		sep #$20	            SEP #$20
.1a5f92	a9 1a		lda #$1a	                LDA #`ln_coeff
.1a5f94	48		pha		                PHA
.1a5f95	ab		plb		                PLB
.1a5f96	c2 20		rep #$20	            REP #$20
.1a5f98	a2 77 63	ldx #$6377	                LDX #<>ln_coeff
.1a5f9b	5a		phy		                PHY
.1a5f9c	a0 08 00	ldy #$0008	                LDY #8
.1a5f9f	20 7a 5c	jsr $1a5c7a	            JSR Q_POLY_HR
.1a5fa2	7a		ply		                PLY
.1a5fa3	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.1a5fa6	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.1a5faa	8f 2d 08 00	sta $00082d	                STA @l ARGTYPE2
.1a5fae	20 e4 54	jsr $1a54e4	            JSR OP_FP_MUL
.1a5fb1	ab		plb		                PLB
.1a5fb2	fa		plx		                PLX
.1a5fb3	68		pla		                PLA
.1a5fb4	28		plp		                PLP
.1a5fb5	60		rts		            RTS
.1a5fb6					FP_SIN
.1a5fb6	08		php		                PHP
.1a5fb7	c2 30		rep #$30	            REP #$30
.1a5fb9	48		pha		                PHA
.1a5fba	da		phx		                PHX
.1a5fbb	20 a9 5d	jsr $1a5da9	            JSR Q_FP_SCALE_TAU
.1a5fbe	20 06 5e	jsr $1a5e06	            JSR Q_FP_NORM_ANGLE
.1a5fc1	da		phx		                PHX
.1a5fc2	8a		txa		                TXA
.1a5fc3	29 01 00	and #$0001	                AND #1
.1a5fc6	d0 05		bne $1a5fcd	                BNE do_cos
.1a5fc8	20 7f 5e	jsr $1a5e7f	            JSR Q_FP_SIN
.1a5fcb	80 03		bra $1a5fd0	                BRA maybe_neg
.1a5fcd					do_cos
.1a5fcd	20 57 5e	jsr $1a5e57	            JSR Q_FP_COS
.1a5fd0	fa		plx		maybe_neg       PLX
.1a5fd1	8a		txa		                TXA
.1a5fd2	29 04 00	and #$0004	                AND #4
.1a5fd5	f0 0a		beq $1a5fe1	                BEQ done
.1a5fd7	e2 20		sep #$20	            SEP #$20
.1a5fd9	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a5fdb	09 80		ora #$80	                ORA #$80
.1a5fdd	85 26		sta $0826	                STA ARGUMENT1+3
.1a5fdf	c2 20		rep #$20	            REP #$20
.1a5fe1	fa		plx		done            PLX
.1a5fe2	68		pla		                PLA
.1a5fe3	28		plp		                PLP
.1a5fe4	60		rts		            RTS
.1a5fe5					FP_COS
.1a5fe5	08		php		                PHP
.1a5fe6	c2 30		rep #$30	            REP #$30
.1a5fe8	48		pha		                PHA
.1a5fe9	da		phx		                PHX
.1a5fea	20 a9 5d	jsr $1a5da9	            JSR Q_FP_SCALE_TAU
.1a5fed	20 06 5e	jsr $1a5e06	            JSR Q_FP_NORM_ANGLE
.1a5ff0	da		phx		                PHX
.1a5ff1	8a		txa		                TXA
.1a5ff2	29 01 00	and #$0001	                AND #1
.1a5ff5	d0 05		bne $1a5ffc	                BNE do_sin
.1a5ff7	20 57 5e	jsr $1a5e57	            JSR Q_FP_COS
.1a5ffa	80 03		bra $1a5fff	                BRA maybe_neg
.1a5ffc					do_sin
.1a5ffc	20 7f 5e	jsr $1a5e7f	            JSR Q_FP_SIN
.1a5fff	fa		plx		maybe_neg       PLX
.1a6000	8a		txa		                TXA
.1a6001	29 02 00	and #$0002	                AND #2
.1a6004	f0 0a		beq $1a6010	                BEQ done
.1a6006	e2 20		sep #$20	            SEP #$20
.1a6008	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a600a	09 80		ora #$80	                ORA #$80
.1a600c	85 26		sta $0826	                STA ARGUMENT1+3
.1a600e	c2 20		rep #$20	            REP #$20
.1a6010	fa		plx		done            PLX
.1a6011	68		pla		                PLA
.1a6012	28		plp		                PLP
.1a6013	60		rts		            RTS
.1a6014					FP_TAN
.1a6014	08		php		                PHP
.1a6015	c2 30		rep #$30	            REP #$30
.1a6017	48		pha		                PHA
.1a6018	da		phx		                PHX
.1a6019	20 a9 5d	jsr $1a5da9	            JSR Q_FP_SCALE_TAU
.1a601c	20 06 5e	jsr $1a5e06	            JSR Q_FP_NORM_ANGLE
.1a601f	20 ab 5e	jsr $1a5eab	            JSR Q_FP_TAN
.1a6022	8a		txa		                TXA
.1a6023	29 01 00	and #$0001	                AND #1
.1a6026	f0 03		beq $1a602b	                BEQ no_inv
.1a6028	20 3f 5d	jsr $1a5d3f	            JSR Q_INV
.1a602b	8a		txa		no_inv          TXA
.1a602c	e2 20		sep #$20	            SEP #$20
.1a602e	4a		lsr a		                LSR
.1a602f	4a		lsr a		                LSR
.1a6030	69 00		adc #$00	                ADC #0
.1a6032	29 01		and #$01	                AND #1
.1a6034	f0 06		beq $1a603c	                BEQ no_neg
.1a6036	a5 26		lda $0826	                LDA ARGUMENT1+3
.1a6038	09 80		ora #$80	                ORA #$80
.1a603a	85 26		sta $0826	                STA ARGUMENT1+3
.1a603c					no_neg
.1a603c	c2 20		rep #$20	            REP #$20
.1a603e	fa		plx		                PLX
.1a603f	68		pla		                PLA
.1a6040	28		plp		                PLP
.1a6041	60		rts		            RTS
.1a6042					FP_LN
.1a6042	08		php		                PHP
.1a6043	c2 30		rep #$30	            REP #$30
.1a6045	48		pha		                PHA
.1a6046	da		phx		                PHX
.1a6047	5a		phy		                PHY
.1a6048	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a604a	10 1f		bpl $1a606b	                BPL arg_ok
.1a604c	08		php		            PHP
.1a604d	c2 20		rep #$20	            REP #$20
.1a604f	48		pha		            PHA
.1a6050	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6053	5b		tcd		            TCD
.1a6054	68		pla		            PLA
.1a6055	28		plp		            PLP
.1a6056	e2 20		sep #$20	            SEP #$20
.1a6058	a9 17		lda #$17	            LDA #ERR_DOMAIN
.1a605a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a605e	c2 20		rep #$20	            REP #$20
.1a6060	29 ff 00	and #$00ff	            AND #$00FF
.1a6063	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a6066	e2 20		sep #$20	            SEP #$20
.1a6068	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a606b					arg_ok
.1a606b	c2 30		rep #$30	            REP #$30
.1a606d	a5 23		lda $0823	                LDA ARGUMENT1
.1a606f	cf 93 63 1a	cmp $1a6393	                CMP @l fp_one
.1a6073	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6075	cf 95 63 1a	cmp $1a6395	                CMP @l fp_one+2
.1a6079	b0 04		bcs $1a607f	                BCS gtone
.1a607b	20 3f 5d	jsr $1a5d3f	            JSR Q_INV
.1a607e	18		clc		                CLC
.1a607f	a9 00 00	lda #$0000	gtone           LDA #0
.1a6082	a8		tay		                TAY
.1a6083	2a		rol a		                ROL             ; Rotate Carry into A; 0 means negate
.1a6084	48		pha		                PHA
.1a6085	e2 20		sep #$20	            SEP #$20
.1a6087	a9 00		lda #$00	                LDA #0
.1a6089	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.1a608d	a9 01		lda #$01	                LDA #FP_OUT_DIV
.1a608f	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.1a6093	c2 20		rep #$20	            REP #$20
.1a6095	af eb 63 1a	lda $1a63eb	                LDA @l eexp64
.1a6099	85 29		sta $0829	                STA ARGUMENT2
.1a609b	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a609f	af ed 63 1a	lda $1a63ed	                LDA @l eexp64+2
.1a60a3	85 2b		sta $082b	                STA ARGUMENT2+2
.1a60a5	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a60a9	20 7d 5d	jsr $1a5d7d	            JSR Q_FP_SCALE
.1a60ac	8a		txa		                TXA
.1a60ad	f0 07		beq $1a60b6	                BEQ chk16
.1a60af	0a		asl a		                ASL             ; multiply counter by 64
.1a60b0	0a		asl a		                ASL
.1a60b1	0a		asl a		                ASL
.1a60b2	0a		asl a		                ASL
.1a60b3	0a		asl a		                ASL
.1a60b4	0a		asl a		                ASL
.1a60b5	a8		tay		                TAY
.1a60b6	af ef 63 1a	lda $1a63ef	chk16           LDA @l eexp16
.1a60ba	85 29		sta $0829	                STA ARGUMENT2
.1a60bc	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a60c0	af f1 63 1a	lda $1a63f1	                LDA @l eexp16+2
.1a60c4	85 2b		sta $082b	                STA ARGUMENT2+2
.1a60c6	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a60ca	20 7d 5d	jsr $1a5d7d	            JSR Q_FP_SCALE
.1a60cd	8a		txa		                TXA
.1a60ce	f0 0b		beq $1a60db	                BEQ chk04
.1a60d0	0a		asl a		                ASL             ; multiply counter by 16
.1a60d1	0a		asl a		                ASL
.1a60d2	0a		asl a		                ASL
.1a60d3	0a		asl a		                ASL
.1a60d4	85 29		sta $0829	                STA ARGUMENT2   ; and add into total
.1a60d6	18		clc		                CLC
.1a60d7	98		tya		                TYA
.1a60d8	65 29		adc $0829	                ADC ARGUMENT2
.1a60da	a8		tay		                TAY
.1a60db	af f3 63 1a	lda $1a63f3	chk04           LDA @l eexp04
.1a60df	85 29		sta $0829	                STA ARGUMENT2
.1a60e1	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a60e5	af f5 63 1a	lda $1a63f5	                LDA @l eexp04+2
.1a60e9	85 2b		sta $082b	                STA ARGUMENT2+2
.1a60eb	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a60ef	20 7d 5d	jsr $1a5d7d	            JSR Q_FP_SCALE
.1a60f2	8a		txa		                TXA
.1a60f3	f0 09		beq $1a60fe	                BEQ chk01
.1a60f5	0a		asl a		                ASL             ;multiply counter by 4
.1a60f6	0a		asl a		                ASL
.1a60f7	85 29		sta $0829	                STA ARGUMENT2   ;and add to total
.1a60f9	18		clc		                CLC
.1a60fa	98		tya		                TYA
.1a60fb	65 29		adc $0829	                ADC ARGUMENT2
.1a60fd	a8		tay		                TAY
.1a60fe	af f7 63 1a	lda $1a63f7	chk01           LDA @l eexp01
.1a6102	85 29		sta $0829	                STA ARGUMENT2
.1a6104	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.1a6108	af f9 63 1a	lda $1a63f9	                LDA @l eexp01+2
.1a610c	85 2b		sta $082b	                STA ARGUMENT2+2
.1a610e	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.1a6112	20 7d 5d	jsr $1a5d7d	            JSR Q_FP_SCALE
.1a6115	86 29		stx $0829	                STX ARGUMENT2   ; add counter to total
.1a6117	18		clc		                CLC
.1a6118	98		tya		                TYA
.1a6119	65 29		adc $0829	                ADC ARGUMENT2
.1a611b	a8		tay		                TAY
.1a611c	20 d7 5e	jsr $1a5ed7	            JSR Q_FP_LN
.1a611f	a5 23		lda $0823	                LDA ARGUMENT1
.1a6121	85 29		sta $0829	                STA ARGUMENT2
.1a6123	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6125	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6127	98		tya		                TYA
.1a6128	85 23		sta $0823	                STA ARGUMENT1
.1a612a	64 25		stz $0825	                STZ ARGUMENT1+2
.1a612c	20 71 59	jsr $1a5971	            JSR ITOF
.1a612f	20 4e 54	jsr $1a544e	            JSR OP_FP_ADD
.1a6132	68		pla		                PLA
.1a6133	d0 07		bne $1a613c	                BNE done
.1a6135	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6137	09 00 80	ora #$8000	                ORA #$8000
.1a613a	85 25		sta $0825	                STA ARGUMENT1+2
.1a613c	7a		ply		done            PLY
.1a613d	fa		plx		                PLX
.1a613e	68		pla		                PLA
.1a613f	28		plp		                PLP
.1a6140	60		rts		            RTS
.1a6141					FP_ASIN
.1a6141	08		php		                PHP
.1a6142	c2 30		rep #$30	            REP #$30
.1a6144	48		pha		                PHA
.1a6145	da		phx		                PHX
.1a6146	a5 23		lda $0823	                LDA ARGUMENT1
.1a6148	85 29		sta $0829	                STA ARGUMENT2
.1a614a	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a614c	85 2b		sta $082b	                STA ARGUMENT2+2
.1a614e	20 09 5d	jsr $1a5d09	            JSR Q_SQ
.1a6151	8b		phb		                PHB
.1a6152	e2 20		sep #$20	            SEP #$20
.1a6154	a9 1a		lda #$1a	                LDA #`asin_coeff
.1a6156	48		pha		                PHA
.1a6157	ab		plb		                PLB
.1a6158	c2 20		rep #$20	            REP #$20
.1a615a	a2 9b 63	ldx #$639b	                LDX #<>asin_coeff
.1a615d	a0 05 00	ldy #$0005	                LDY #5
.1a6160	20 7a 5c	jsr $1a5c7a	            JSR Q_POLY_HR
.1a6163	ab		plb		                PLB
.1a6164	20 e4 54	jsr $1a54e4	            JSR OP_FP_MUL
.1a6167	fa		plx		                PLX
.1a6168	68		pla		                PLA
.1a6169	28		plp		                PLP
.1a616a	60		rts		            RTS
.1a616b					FP_ACOS
.1a616b	08		php		                PHP
.1a616c	c2 30		rep #$30	            REP #$30
.1a616e	48		pha		                PHA
.1a616f	da		phx		                PHX
.1a6170	20 41 61	jsr $1a6141	            JSR FP_ASIN
.1a6173	af 03 64 1a	lda $1a6403	                LDA @l halfpi
.1a6177	85 29		sta $0829	                STA ARGUMENT2
.1a6179	af 05 64 1a	lda $1a6405	                LDA @l halfpi+2
.1a617d	85 2b		sta $082b	                STA ARGUMENT2+2
.1a617f	20 43 54	jsr $1a5443	            JSR OP_FP_SUB
.1a6182	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6184	49 00 80	eor #$8000	                EOR #$8000
.1a6187	85 25		sta $0825	                STA ARGUMENT1+2
.1a6189	fa		plx		                PLX
.1a618a	68		pla		                PLA
.1a618b	28		plp		                PLP
.1a618c	60		rts		            RTS
.1a618d					FP_ATAN
.1a618d	08		php		                PHP
.1a618e	c2 30		rep #$30	            REP #$30
.1a6190	48		pha		                PHA
.1a6191	da		phx		                PHX
.1a6192	a5 23		lda $0823	                LDA ARGUMENT1
.1a6194	85 29		sta $0829	                STA ARGUMENT2
.1a6196	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6198	85 2b		sta $082b	                STA ARGUMENT2+2
.1a619a	20 09 5d	jsr $1a5d09	            JSR Q_SQ
.1a619d	8b		phb		                PHB
.1a619e	e2 20		sep #$20	            SEP #$20
.1a61a0	a9 1a		lda #$1a	                LDA #`atan_coeff
.1a61a2	48		pha		                PHA
.1a61a3	ab		plb		                PLB
.1a61a4	c2 20		rep #$20	            REP #$20
.1a61a6	a2 af 63	ldx #$63af	                LDX #<>atan_coeff
.1a61a9	a0 05 00	ldy #$0005	                LDY #5
.1a61ac	20 7a 5c	jsr $1a5c7a	            JSR Q_POLY_HR
.1a61af	ab		plb		                PLB
.1a61b0	20 e4 54	jsr $1a54e4	            JSR OP_FP_MUL
.1a61b3	fa		plx		                PLX
.1a61b4	68		pla		                PLA
.1a61b5	28		plp		                PLP
.1a61b6	60		rts		            RTS
.1a61b7					Q_FP_POW_INT
.1a61b7	c2 20		rep #$20	            REP #$20
.1a61b9	a5 23		lda $0823	            LDA ARGUMENT1
.1a61bb	85 29		sta $0829	            STA ARGUMENT2
.1a61bd	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a61bf	85 2b		sta $082b	            STA ARGUMENT2+2
.1a61c1	c2 20		rep #$20	            REP #$20
.1a61c3	af 93 63 1a	lda $1a6393	            LDA @l fp_one
.1a61c7	85 23		sta $0823	            STA ARGUMENT1
.1a61c9	af 95 63 1a	lda $1a6395	            LDA @l fp_one+2
.1a61cd	85 25		sta $0825	            STA ARGUMENT1+2
.1a61cf	8a		txa		loop            TXA
.1a61d0	f0 30		beq $1a6202	                BEQ done
.1a61d2	4a		lsr a		                LSR
.1a61d3	aa		tax		                TAX
.1a61d4	90 03		bcc $1a61d9	                BCC next
.1a61d6	20 e4 54	jsr $1a54e4	            JSR OP_FP_MUL
.1a61d9					next
.1a61d9	c2 20		rep #$20	            REP #$20
.1a61db	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a61dd	48		pha		            PHA
.1a61de	a5 23		lda $0823	            LDA ARGUMENT1
.1a61e0	48		pha		            PHA
.1a61e1	c2 20		rep #$20	            REP #$20
.1a61e3	a5 29		lda $0829	            LDA ARGUMENT2
.1a61e5	85 23		sta $0823	            STA ARGUMENT1
.1a61e7	a5 2b		lda $082b	            LDA ARGUMENT2+2
.1a61e9	85 25		sta $0825	            STA ARGUMENT1+2
.1a61eb	20 09 5d	jsr $1a5d09	            JSR Q_SQ
.1a61ee	c2 20		rep #$20	            REP #$20
.1a61f0	a5 23		lda $0823	            LDA ARGUMENT1
.1a61f2	85 29		sta $0829	            STA ARGUMENT2
.1a61f4	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a61f6	85 2b		sta $082b	            STA ARGUMENT2+2
.1a61f8	c2 20		rep #$20	            REP #$20
.1a61fa	68		pla		            PLA
.1a61fb	85 23		sta $0823	            STA ARGUMENT1
.1a61fd	68		pla		            PLA
.1a61fe	85 25		sta $0825	            STA ARGUMENT1+2
.1a6200	80 cd		bra $1a61cf	                BRA loop
.1a6202					done
.1a6202	60		rts		            RTS
.1a6203					Q_FP_EXP
.1a6203	08		php		                PHP
.1a6204	c2 30		rep #$30	            REP #$30
.1a6206	48		pha		                PHA
.1a6207	da		phx		                PHX
.1a6208	8b		phb		                PHB
.1a6209	e2 20		sep #$20	            SEP #$20
.1a620b	a9 1a		lda #$1a	                LDA #`exp_coeff
.1a620d	48		pha		                PHA
.1a620e	ab		plb		                PLB
.1a620f	c2 20		rep #$20	            REP #$20
.1a6211	a2 c3 63	ldx #$63c3	                LDX #<>exp_coeff
.1a6214	5a		phy		                PHY
.1a6215	a0 0a 00	ldy #$000a	                LDY #10
.1a6218	20 7a 5c	jsr $1a5c7a	            JSR Q_POLY_HR
.1a621b	7a		ply		                PLY
.1a621c	ab		plb		                PLB
.1a621d	fa		plx		                PLX
.1a621e	68		pla		                PLA
.1a621f	28		plp		                PLP
.1a6220	60		rts		            RTS
.1a6221					FP_EXP
.1a6221	08		php		                PHP
.1a6222	c2 30		rep #$30	            REP #$30
.1a6224	48		pha		                PHA
.1a6225	da		phx		                PHX
.1a6226	5a		phy		                PHY
.1a6227	a5 23		lda $0823	                LDA ARGUMENT1   ; special case for x==0
.1a6229	05 25		ora $0825	                ORA ARGUMENT1+2
.1a622b	d0 10		bne $1a623d	                BNE notzero
.1a622d	c2 20		rep #$20	            REP #$20
.1a622f	af 93 63 1a	lda $1a6393	            LDA @l fp_one
.1a6233	85 23		sta $0823	            STA ARGUMENT1
.1a6235	af 95 63 1a	lda $1a6395	            LDA @l fp_one+2
.1a6239	85 25		sta $0825	            STA ARGUMENT1+2
.1a623b	80 61		bra $1a629e	                BRA done
.1a623d	a5 25		lda $0825	notzero         LDA ARGUMENT1+2 ; check if negative
.1a623f	29 00 80	and #$8000	                AND #$8000
.1a6242	a8		tay		                TAY             ; Y != 0 -> arg was negative
.1a6243	f0 07		beq $1a624c	                BEQ notneg
.1a6245	a5 25		lda $0825	                LDA ARGUMENT1+2 ; negate x
.1a6247	29 ff 7f	and #$7fff	                AND #$7FFF
.1a624a	85 25		sta $0825	                STA ARGUMENT1+2
.1a624c					notneg
.1a624c	c2 20		rep #$20	            REP #$20
.1a624e	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6250	48		pha		            PHA
.1a6251	a5 23		lda $0823	            LDA ARGUMENT1
.1a6253	48		pha		            PHA
.1a6254	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a6257	a6 23		ldx $0823	                LDX ARGUMENT1              ; INT(x) now in ARGUMENT1; low 16 bits into X
.1a6259	20 71 06	jsr $1a0671	            JSR ASS_ARG1_FLOAT
.1a625c	c2 20		rep #$20	            REP #$20
.1a625e	a5 23		lda $0823	            LDA ARGUMENT1
.1a6260	85 29		sta $0829	            STA ARGUMENT2
.1a6262	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6264	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6266	c2 20		rep #$20	            REP #$20
.1a6268	68		pla		            PLA
.1a6269	85 23		sta $0823	            STA ARGUMENT1
.1a626b	68		pla		            PLA
.1a626c	85 25		sta $0825	            STA ARGUMENT1+2
.1a626e	20 43 54	jsr $1a5443	            JSR OP_FP_SUB
.1a6271	20 03 62	jsr $1a6203	            JSR Q_FP_EXP
.1a6274	c2 20		rep #$20	            REP #$20
.1a6276	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a6278	48		pha		            PHA
.1a6279	a5 23		lda $0823	            LDA ARGUMENT1
.1a627b	48		pha		            PHA
.1a627c	c2 20		rep #$20	            REP #$20
.1a627e	af f7 63 1a	lda $1a63f7	            LDA @leexp01
.1a6282	85 23		sta $0823	            STA ARGUMENT1
.1a6284	af f9 63 1a	lda $1a63f9	            LDA @leexp01+2
.1a6288	85 25		sta $0825	            STA ARGUMENT1+2
.1a628a	20 b7 61	jsr $1a61b7	            JSR Q_FP_POW_INT
.1a628d	c2 20		rep #$20	            REP #$20
.1a628f	68		pla		            PLA
.1a6290	85 29		sta $0829	            STA ARGUMENT2
.1a6292	68		pla		            PLA
.1a6293	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6295	20 e4 54	jsr $1a54e4	            JSR OP_FP_MUL
.1a6298	98		tya		                TYA
.1a6299	f0 03		beq $1a629e	                BEQ done
.1a629b	20 3f 5d	jsr $1a5d3f	            JSR Q_INV
.1a629e	7a		ply		done            PLY
.1a629f	fa		plx		                PLX
.1a62a0	68		pla		                PLA
.1a62a1	28		plp		                PLP
.1a62a2	60		rts		            RTS
.1a62a3					FP_SQR
.1a62a3	08		php		                PHP
.1a62a4	c2 30		rep #$30	            REP #$30
.1a62a6	48		pha		                PHA
.1a62a7	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a62a9	10 1f		bpl $1a62ca	                BPL arg_ok
.1a62ab	08		php		            PHP
.1a62ac	c2 20		rep #$20	            REP #$20
.1a62ae	48		pha		            PHA
.1a62af	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a62b2	5b		tcd		            TCD
.1a62b3	68		pla		            PLA
.1a62b4	28		plp		            PLP
.1a62b5	e2 20		sep #$20	            SEP #$20
.1a62b7	a9 17		lda #$17	            LDA #ERR_DOMAIN
.1a62b9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a62bd	c2 20		rep #$20	            REP #$20
.1a62bf	29 ff 00	and #$00ff	            AND #$00FF
.1a62c2	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a62c5	e2 20		sep #$20	            SEP #$20
.1a62c7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a62ca					arg_ok
.1a62ca	c2 30		rep #$30	            REP #$30
.1a62cc	05 23		ora $0823	                ORA ARGUMENT1
.1a62ce	f0 68		beq $1a6338	                BEQ done
.1a62d0	c2 20		rep #$20	            REP #$20
.1a62d2	af 97 63 1a	lda $1a6397	            LDA @l fp_two
.1a62d6	85 29		sta $0829	            STA ARGUMENT2
.1a62d8	af 99 63 1a	lda $1a6399	            LDA @l fp_two+2
.1a62dc	85 2b		sta $082b	            STA ARGUMENT2+2
.1a62de	e2 20		sep #$20	            SEP #$20
.1a62e0	a9 01		lda #$01	                LDA #TYPE_FLOAT
.1a62e2	85 2d		sta $082d	                STA ARGTYPE2
.1a62e4	c2 20		rep #$20	            REP #$20
.1a62e6	c2 20		rep #$20	            REP #$20
.1a62e8	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a62ea	48		pha		            PHA
.1a62eb	a5 23		lda $0823	            LDA ARGUMENT1
.1a62ed	48		pha		            PHA
.1a62ee					loop
.1a62ee	20 99 54	jsr $1a5499	            JSR OP_FP_DIV
.1a62f1	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a62f3	c5 2b		cmp $082b	                CMP ARGUMENT2+2
.1a62f5	d0 09		bne $1a6300	                BNE more
.1a62f7	a5 23		lda $0823	                LDA ARGUMENT1
.1a62f9	45 29		eor $0829	                EOR ARGUMENT2
.1a62fb	29 f8 ff	and #$fff8	                AND #$FFF8
.1a62fe	f0 30		beq $1a6330	                BEQ exitloop
.1a6300					more
.1a6300	20 4e 54	jsr $1a544e	            JSR OP_FP_ADD
.1a6303	c2 20		rep #$20	            REP #$20
.1a6305	af 97 63 1a	lda $1a6397	            LDA @l fp_two
.1a6309	85 29		sta $0829	            STA ARGUMENT2
.1a630b	af 99 63 1a	lda $1a6399	            LDA @l fp_two+2
.1a630f	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6311	20 99 54	jsr $1a5499	            JSR OP_FP_DIV
.1a6314	c2 20		rep #$20	            REP #$20
.1a6316	a5 23		lda $0823	            LDA ARGUMENT1
.1a6318	85 29		sta $0829	            STA ARGUMENT2
.1a631a	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a631c	85 2b		sta $082b	            STA ARGUMENT2+2
.1a631e	c2 20		rep #$20	            REP #$20
.1a6320	68		pla		            PLA
.1a6321	85 23		sta $0823	            STA ARGUMENT1
.1a6323	68		pla		            PLA
.1a6324	85 25		sta $0825	            STA ARGUMENT1+2
.1a6326	c2 20		rep #$20	            REP #$20
.1a6328	a5 25		lda $0825	            LDA ARGUMENT1+2
.1a632a	48		pha		            PHA
.1a632b	a5 23		lda $0823	            LDA ARGUMENT1
.1a632d	48		pha		            PHA
.1a632e	80 be		bra $1a62ee	                BRA loop
.1a6330					exitloop
.1a6330	c2 20		rep #$20	            REP #$20
.1a6332	68		pla		            PLA
.1a6333	85 29		sta $0829	            STA ARGUMENT2
.1a6335	68		pla		            PLA
.1a6336	85 2b		sta $082b	            STA ARGUMENT2+2
.1a6338	68		pla		done            PLA
.1a6339	28		plp		                PLP
.1a633a	60		rts		            RTS
.1a633b					cos_coeff
>1a633b	01 0d d0 37			                .dword $37D00D01
>1a633f	61 0b b6 ba			                .dword $BAB60B61
>1a6343	ab aa 2a 3d			                .dword $3D2AAAAB
>1a6347	00 00 00 bf			                .dword $BF000000
>1a634b	00 00 80 3f			                .dword $3F800000
.1a634f					sin_coeff
>1a634f	1d ef 38 36			                .dword $3638EF1D
>1a6353	01 0d 50 b9			                .dword $B9500D01
>1a6357	89 88 08 3c			                .dword $3C088889
>1a635b	ab aa 2a be			                .dword $BE2AAAAB
>1a635f	00 00 80 3f			                .dword $3F800000
.1a6363					tan_coeff
>1a6363	a4 27 b3 3c			                .dword $3CB327A4
>1a6367	d1 0d 5d 3d			                .dword $3D5D0DD1
>1a636b	89 88 08 3e			                .dword $3E088889
>1a636f	ab aa aa 3e			                .dword $3EAAAAAB
>1a6373	00 00 80 3f			                .dword $3F800000
.1a6377					ln_coeff
>1a6377	89 88 88 3d			                .dword $3D888889
>1a637b	d9 89 9d 3d			                .dword $3D9D89D9
>1a637f	8c 2e ba 3d			                .dword $3DBA2E8C
>1a6383	39 8e e3 3d			                .dword $3DE38E39
>1a6387	25 49 12 3e			                .dword $3E124925
>1a638b	cd cc 4c 3e			                .dword $3E4CCCCD
>1a638f	ab aa aa 3e			                .dword $3EAAAAAB
>1a6393	00 00 80 3f			fp_one          .dword $3F800000
>1a6397	00 00 00 40			fp_two          .dword $40000000
.1a639b					asin_coeff
>1a639b	8e e3 f8 3c			                .dword $3CF8E38E
>1a639f	6e db 36 3d			                .dword $3D36DB6E
>1a63a3	9a 99 99 3d			                .dword $3D99999A
>1a63a7	ab aa 2a 3e			                .dword $3E2AAAAB
>1a63ab	00 00 80 3f			                .dword $3F800000
.1a63af					atan_coeff
>1a63af	39 8e e3 3d			                .dword $3DE38E39
>1a63b3	25 49 12 be			                .dword $BE124925
>1a63b7	cd cc 4c 3e			                .dword $3E4CCCCD
>1a63bb	ab aa aa be			                .dword $BEAAAAAB
>1a63bf	00 00 80 3f			                .dword $3F800000
.1a63c3					exp_coeff
>1a63c3	1d ef 38 36			        .dword $3638EF1D
>1a63c7	01 0d d0 37			        .dword $37D00D01
>1a63cb	01 0d 50 39			        .dword $39500D01
>1a63cf	61 0b b6 3a			        .dword $3AB60B61
>1a63d3	89 88 08 3c			        .dword $3C088889
>1a63d7	ab aa 2a 3d			        .dword $3D2AAAAB
>1a63db	ab aa 2a 3e			        .dword $3E2AAAAB
>1a63df	00 00 00 3f			        .dword $3F000000
>1a63e3	00 00 80 3f			        .dword $3F800000
>1a63e7	00 00 80 3f			        .dword $3F800000
>1a63eb	c1 2c a1 6d			eexp64          .dword $6DA12CC1
>1a63ef	5f 97 07 4b			eexp16          .dword $4B07975F
>1a63f3	81 64 5a 42			eexp04          .dword $425A6481
>1a63f7	54 f8 2d 40			eexp01          .dword $402DF854
>1a63fb	db 0f c9 40			twopi           .dword $40C90FDB
>1a63ff	db 0f 49 40			onepi           .dword $40490FDB
>1a6403	db 0f c9 3f			halfpi          .dword $3FC90FDB
>1a6407	db 0f 49 3f			quarterpi       .dword $3F490FDB

;******  Return to file: src\basic816.s


;******  Processing file: src\arrays.s

.1a640b					ARR_ALLOC
.1a640b	08		php		                PHP
.1a640c	20 bc 11	jsr $1a11bc	            JSR HEAP_GETHED
.1a640f	c2 20		rep #$20	            REP #$20
.1a6411	a9 01 00	lda #$0001	                LDA #1                      ; ARGUMENT1 := 1
.1a6414	85 23		sta $0823	                STA ARGUMENT1
.1a6416	a9 00 00	lda #$0000	                LDA #0
.1a6419	85 25		sta $0825	                STA ARGUMENT1+2
.1a641b	e2 20		sep #$20	            SEP #$20
.1a641d	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.1a6421	c2 20		rep #$20	            REP #$20
.1a6423	29 ff 00	and #$00ff	                AND #$00FF
.1a6426	85 8f		sta $088f	                STA MCOUNT                  ; Save it to MCOUNT for later
.1a6428	a8		tay		                TAY                         ; Y := number of dimensions
.1a6429	a2 01 00	ldx #$0001	                LDX #1                      ; X := index to size 0
.1a642c					size_loop
.1a642c	c2 20		rep #$20	            REP #$20
.1a642e	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X           ; ARGUMENT2 := Ith dimension
.1a6432	85 29		sta $0829	                STA ARGUMENT2
.1a6434	a9 00 00	lda #$0000	                LDA #0
.1a6437	85 2b		sta $082b	                STA ARGUMENT2+2
.1a6439	20 94 26	jsr $1a2694	            JSR OP_MULTIPLY
.1a643c	e8		inx		                INX
.1a643d	e8		inx		                INX
.1a643e	88		dey		                DEY
.1a643f	d0 eb		bne $1a642c	                BNE size_loop               ; If there are more dimensions, take the next one
.1a6441	c2 20		rep #$20	            REP #$20
.1a6443	a9 04 00	lda #$0004	                LDA #ARGUMENT_SIZE-1        ; Size of a data item (don't include the type code)
.1a6446	85 29		sta $0829	                STA ARGUMENT2
.1a6448	a9 00 00	lda #$0000	                LDA #0
.1a644b	85 2b		sta $082b	                STA ARGUMENT2+2
.1a644d	20 94 26	jsr $1a2694	            JSR OP_MULTIPLY
.1a6450	e2 20		sep #$20	            SEP #$20
.1a6452	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF             ; SCRATCH := N * 2
.1a6456	85 0c		sta $080c	                STA SCRATCH
.1a6458	a9 00		lda #$00	                LDA #0
.1a645a	85 0d		sta $080d	                STA SCRATCH+1
.1a645c	c2 20		rep #$20	            REP #$20
.1a645e	06 0c		asl $080c	                ASL SCRATCH
.1a6460	38		sec		                SEC                         ; ARGUMENT1 := size of the complete block
.1a6461	a5 23		lda $0823	                LDA ARGUMENT1
.1a6463	65 0c		adc $080c	                ADC SCRATCH                 ; Size of data area + N*2 + 1 (in carry)
.1a6465	85 23		sta $0823	                STA ARGUMENT1
.1a6467	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6469	69 00 00	adc #$0000	                ADC #0
.1a646c	85 25		sta $0825	                STA ARGUMENT1+2
.1a646e	d0 29		bne $1a6499	                BNE too_big                 ; size > 16-bit? Yes: throw an error
.1a6470	e2 20		sep #$20	            SEP #$20
.1a6472	a5 ea		lda $08ea	                LDA TOFINDTYPE              ; Get the type
.1a6474	09 80		ora #$80	                ORA #$80                    ; Flip the flag to make it an array of that type
.1a6476	a6 23		ldx $0823	                LDX ARGUMENT1               ; Get the computed size
.1a6478	20 80 0f	jsr $1a0f80	            JSR ALLOC
.1a647b	e2 20		sep #$20	            SEP #$20
.1a647d	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.1a6481	87 c0		sta [$08c0]	                STA [CURRBLOCK]             ; Write the number of dimensions to the array's preamble
.1a6483	a0 01 00	ldy #$0001	                LDY #1
.1a6486	a2 00 00	ldx #$0000	                LDX #0
.1a6489					copy_loop
.1a6489	e2 20		sep #$20	            SEP #$20
.1a648b	bf 01 4d 00	lda $004d01,x	                LDA @lARRIDXBUF+1,X         ; ARGUMENT2 := Ith dimension
.1a648f	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y           ; And write the dimension to the array's preamble
.1a6491	e4 8f		cpx $088f	                CPX MCOUNT                  ; Have we written the last byte?
.1a6493	f0 23		beq $1a64b8	                BEQ null_array              ; Yes: clear the array
.1a6495	e8		inx		                INX                         ; No: move to the next byte
.1a6496	c8		iny		                INY
.1a6497	80 f0		bra $1a6489	                BRA copy_loop
.1a6499					too_big
.1a6499	08		php		            PHP
.1a649a	c2 20		rep #$20	            REP #$20
.1a649c	48		pha		            PHA
.1a649d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a64a0	5b		tcd		            TCD
.1a64a1	68		pla		            PLA
.1a64a2	28		plp		            PLP
.1a64a3	e2 20		sep #$20	            SEP #$20
.1a64a5	a9 09		lda #$09	            LDA #ERR_RANGE
.1a64a7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a64ab	c2 20		rep #$20	            REP #$20
.1a64ad	29 ff 00	and #$00ff	            AND #$00FF
.1a64b0	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a64b3	e2 20		sep #$20	            SEP #$20
.1a64b5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a64b8					null_array
.1a64b8	e2 20		sep #$20	            SEP #$20
.1a64ba	38		sec		                SEC                         ; INDEX := pointer to first value
.1a64bb	a5 c0		lda $08c0	                LDA CURRBLOCK
.1a64bd	67 c0		adc [$08c0]	                ADC [CURRBLOCK]
.1a64bf	85 08		sta $0808	                STA INDEX
.1a64c1	a5 c1		lda $08c1	                LDA CURRBLOCK+1
.1a64c3	69 00		adc #$00	                ADC #0
.1a64c5	85 09		sta $0809	                STA INDEX+1
.1a64c7	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.1a64c9	69 00		adc #$00	                ADC #0
.1a64cb	85 0a		sta $080a	                STA INDEX+2
.1a64cd	64 0b		stz $080b	                STZ INDEX+3
.1a64cf	c2 20		rep #$20	            REP #$20
.1a64d1	a0 05 00	ldy #$0005	                LDY #HEAPOBJ.END            ; SCRATCH := pointer the the first byte after the array
.1a64d4	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a64d6	85 0c		sta $080c	                STA SCRATCH
.1a64d8	e2 20		sep #$20	            SEP #$20
.1a64da	c8		iny		                INY
.1a64db	c8		iny		                INY
.1a64dc	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a64de	85 0e		sta $080e	                STA SCRATCH+2
.1a64e0	64 0f		stz $080f	                STZ SCRATCH+3
.1a64e2					clr_loop
.1a64e2	e2 20		sep #$20	            SEP #$20
.1a64e4	a9 00		lda #$00	                LDA #0
.1a64e6	87 08		sta [$0808]	                STA [INDEX]                 ; Clear the byte
.1a64e8	c2 20		rep #$20	            REP #$20
.1a64ea	18		clc		                CLC                         ; Increment INDEX
.1a64eb	a5 08		lda $0808	                LDA INDEX
.1a64ed	69 01 00	adc #$0001	                ADC #1
.1a64f0	85 08		sta $0808	                STA INDEX
.1a64f2	a5 0a		lda $080a	                LDA INDEX+2
.1a64f4	69 00 00	adc #$0000	                ADC #0
.1a64f7	85 0a		sta $080a	                STA INDEX+2
.1a64f9	c5 0e		cmp $080e	                CMP SCRATCH+2               ; INDEX == SCRATCH?
.1a64fb	d0 e5		bne $1a64e2	                BNE clr_loop                ; No: write to this next byte
.1a64fd	a5 08		lda $0808	                LDA INDEX
.1a64ff	c5 0c		cmp $080c	                CMP SCRATCH
.1a6501	d0 df		bne $1a64e2	                BNE clr_loop
.1a6503					done
.1a6503	28		plp		                PLP
.1a6504	60		rts		            RTS
.1a6505					ARR_CELL
.1a6505	08		php		                PHP
.1a6506	c2 20		rep #$20	            REP #$20
.1a6508	64 08		stz $0808	                STZ INDEX               ; INDEX := 0
.1a650a	64 0a		stz $080a	                STZ INDEX+2
.1a650c	e2 20		sep #$20	            SEP #$20
.1a650e	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF         ; MCOUNT := N (number of dimensions)
.1a6512	85 8f		sta $088f	                STA MCOUNT
.1a6514	64 90		stz $0890	                STZ MCOUNT+1
.1a6516	a2 01 00	ldx #$0001	                LDX #1                  ; X := index to dimension 0
.1a6519	e2 20		sep #$20	            SEP #$20
.1a651b	a7 c0		lda [$08c0]	                LDA [CURRBLOCK]         ; Make sure the dimensions of the array
.1a651d	c5 8f		cmp $088f	                CMP MCOUNT              ; ... match those requested
.1a651f	f0 1f		beq $1a6540	                BEQ dims_match          ; Yes: the dimensions match
.1a6521					arg_err
.1a6521	08		php		            PHP
.1a6522	c2 20		rep #$20	            REP #$20
.1a6524	48		pha		            PHA
.1a6525	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6528	5b		tcd		            TCD
.1a6529	68		pla		            PLA
.1a652a	28		plp		            PLP
.1a652b	e2 20		sep #$20	            SEP #$20
.1a652d	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a652f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6533	c2 20		rep #$20	            REP #$20
.1a6535	29 ff 00	and #$00ff	            AND #$00FF
.1a6538	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a653b	e2 20		sep #$20	            SEP #$20
.1a653d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6540	c9 01		cmp #$01	dims_match      CMP #1                  ; Check to see if this array is one dimensional
.1a6542	f0 3a		beq $1a657e	                BEQ add_last            ; If so, just add the index of the cell to INDEX
.1a6544	a0 01 00	ldy #$0001	                LDY #1
.1a6547					index_loop
.1a6547	e2 20		sep #$20	            SEP #$20
.1a6549	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; ARGUMENT1 := I_j
.1a654d	85 23		sta $0823	                STA ARGUMENT1
.1a654f	64 24		stz $0824	                STZ ARGUMENT1+1
.1a6551	64 25		stz $0825	                STZ ARGUMENT1+2
.1a6553	64 26		stz $0826	                STZ ARGUMENT1+3
.1a6555	b7 c0		lda [$08c0],y	                LDA [CURRBLOCK],Y       ; ARGUMENT2 := D_j
.1a6557	85 29		sta $0829	                STA ARGUMENT2
.1a6559	64 2a		stz $082a	                STZ ARGUMENT2+1
.1a655b	64 2b		stz $082b	                STZ ARGUMENT2+2
.1a655d	64 2c		stz $082c	                STZ ARGUMENT2+3
.1a655f	a5 23		lda $0823	                LDA ARGUMENT1
.1a6561	c5 29		cmp $0829	                CMP ARGUMENT2           ; Is I_j >= D_j
.1a6563	b0 68		bcs $1a65cd	                BGE range_err           ; Yes: throw an out-of-range error
.1a6565	20 94 26	jsr $1a2694	            JSR OP_MULTIPLY
.1a6568	c2 20		rep #$20	            REP #$20
.1a656a	18		clc		                CLC                     ; INDEX := INDEX + ARGUMENT1
.1a656b	a5 08		lda $0808	                LDA INDEX
.1a656d	65 23		adc $0823	                ADC ARGUMENT1
.1a656f	85 08		sta $0808	                STA INDEX
.1a6571	a5 0a		lda $080a	                LDA INDEX+2
.1a6573	65 25		adc $0825	                ADC ARGUMENT1+2
.1a6575	85 0a		sta $080a	                STA INDEX+2
.1a6577	e8		inx		                INX
.1a6578	e8		inx		                INX
.1a6579	c8		iny		                INY
.1a657a	c4 8f		cpy $088f	                CPY MCOUNT              ; Are we on the last index?
.1a657c	d0 c9		bne $1a6547	                BNE index_loop          ; No: move to the next index and try again
.1a657e					add_last
.1a657e	e2 20		sep #$20	            SEP #$20
.1a6580	18		clc		                CLC
.1a6581	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; INDEX := INDEX + I_(n-1)
.1a6585	85 90		sta $0890	                STA MCOUNT+1
.1a6587	65 08		adc $0808	                ADC INDEX
.1a6589	85 08		sta $0808	                STA INDEX
.1a658b	a5 09		lda $0809	                LDA INDEX+1
.1a658d	69 00		adc #$00	                ADC #0
.1a658f	85 09		sta $0809	                STA INDEX+1
.1a6591	c2 20		rep #$20	            REP #$20
.1a6593	a5 0a		lda $080a	                LDA INDEX+2
.1a6595	69 00 00	adc #$0000	                ADC #0
.1a6598	85 0a		sta $080a	                STA INDEX+2
.1a659a	c2 20		rep #$20	            REP #$20
.1a659c	06 08		asl $0808	                ASL INDEX               ; INDEX := INDEX * 4 (size of a value)
.1a659e	26 0a		rol $080a	                ROL INDEX+2
.1a65a0	06 08		asl $0808	                ASL INDEX
.1a65a2	26 0a		rol $080a	                ROL INDEX+2
.1a65a4	e2 20		sep #$20	            SEP #$20
.1a65a6	38		sec		                SEC
.1a65a7	a5 08		lda $0808	                LDA INDEX
.1a65a9	65 8f		adc $088f	                ADC MCOUNT
.1a65ab	85 08		sta $0808	                STA INDEX
.1a65ad	a5 09		lda $0809	                LDA INDEX+1
.1a65af	69 00		adc #$00	                ADC #0
.1a65b1	85 09		sta $0809	                STA INDEX+1
.1a65b3	c2 20		rep #$20	            REP #$20
.1a65b5	a5 0a		lda $080a	                LDA INDEX+2
.1a65b7	69 00 00	adc #$0000	                ADC #0
.1a65ba	85 0a		sta $080a	                STA INDEX+2
.1a65bc	18		clc		                CLC                     ; INDEX := INDEX + CURRBLOCK (point to the address desired)
.1a65bd	a5 08		lda $0808	                LDA INDEX
.1a65bf	65 c0		adc $08c0	                ADC CURRBLOCK
.1a65c1	85 08		sta $0808	                STA INDEX
.1a65c3	e2 20		sep #$20	            SEP #$20
.1a65c5	a5 0a		lda $080a	                LDA INDEX+2
.1a65c7	65 c2		adc $08c2	                ADC CURRBLOCK+2
.1a65c9	85 0a		sta $080a	                STA INDEX+2
.1a65cb	28		plp		                PLP
.1a65cc	60		rts		            RTS
.1a65cd					range_err
.1a65cd	08		php		            PHP
.1a65ce	c2 20		rep #$20	            REP #$20
.1a65d0	48		pha		            PHA
.1a65d1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a65d4	5b		tcd		            TCD
.1a65d5	68		pla		            PLA
.1a65d6	28		plp		            PLP
.1a65d7	e2 20		sep #$20	            SEP #$20
.1a65d9	a9 09		lda #$09	            LDA #ERR_RANGE
.1a65db	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a65df	c2 20		rep #$20	            REP #$20
.1a65e1	29 ff 00	and #$00ff	            AND #$00FF
.1a65e4	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a65e7	e2 20		sep #$20	            SEP #$20
.1a65e9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a65ec					ARR_SET
.1a65ec	08		php		                PHP
.1a65ed	20 bc 11	jsr $1a11bc	            JSR HEAP_GETHED
.1a65f0	e2 20		sep #$20	            SEP #$20
.1a65f2	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.1a65f5	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a65f7	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.1a65f9	c5 27		cmp $0827	                CMP ARGTYPE1        ; is it the same as the argument?
.1a65fb	d0 28		bne $1a6625	                BNE type_mismatch   ; No: throw a type mismatch error
.1a65fd	a5 27		lda $0827	                LDA ARGTYPE1        ; Save the type
.1a65ff	48		pha		                PHA
.1a6600	c2 20		rep #$20	            REP #$20
.1a6602	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Save ARGUMENT1
.1a6604	48		pha		                PHA
.1a6605	a5 23		lda $0823	                LDA ARGUMENT1
.1a6607	48		pha		                PHA
.1a6608	20 05 65	jsr $1a6505	            JSR ARR_CELL
.1a660b	68		pla		                PLA                 ; Restore ARGUMENT1
.1a660c	85 23		sta $0823	                STA ARGUMENT1
.1a660e	68		pla		                PLA
.1a660f	85 25		sta $0825	                STA ARGUMENT1+2
.1a6611	e2 20		sep #$20	            SEP #$20
.1a6613	68		pla		                PLA
.1a6614	85 27		sta $0827	                STA ARGTYPE1
.1a6616	c2 20		rep #$20	            REP #$20
.1a6618	a5 23		lda $0823	                LDA ARGUMENT1       ; Set the value in the cell
.1a661a	87 08		sta [$0808]	                STA [INDEX]
.1a661c	a0 02 00	ldy #$0002	                LDY #2
.1a661f	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6621	97 08		sta [$0808],y	                STA [INDEX],Y
.1a6623	28		plp		                PLP
.1a6624	60		rts		            RTS
.1a6625					type_mismatch
.1a6625	08		php		            PHP
.1a6626	c2 20		rep #$20	            REP #$20
.1a6628	48		pha		            PHA
.1a6629	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a662c	5b		tcd		            TCD
.1a662d	68		pla		            PLA
.1a662e	28		plp		            PLP
.1a662f	e2 20		sep #$20	            SEP #$20
.1a6631	a9 04		lda #$04	            LDA #ERR_TYPE
.1a6633	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6637	c2 20		rep #$20	            REP #$20
.1a6639	29 ff 00	and #$00ff	            AND #$00FF
.1a663c	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a663f	e2 20		sep #$20	            SEP #$20
.1a6641	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6644					ARR_REF
.1a6644	08		php		                PHP
.1a6645	20 bc 11	jsr $1a11bc	            JSR HEAP_GETHED
.1a6648	f4 00 00	pea #$0000	                PEA #0              ; Make room on the stack that ARR_CELL expects
.1a664b	f4 00 00	pea #$0000	                PEA #0
.1a664e	e2 20		sep #$20	            SEP #$20
.1a6650	48		pha		                PHA
.1a6651	20 05 65	jsr $1a6505	            JSR ARR_CELL
.1a6654	e2 20		sep #$20	            SEP #$20
.1a6656	68		pla		                PLA
.1a6657	c2 20		rep #$20	            REP #$20
.1a6659	68		pla		                PLA
.1a665a	68		pla		                PLA
.1a665b	c2 20		rep #$20	            REP #$20
.1a665d	a7 08		lda [$0808]	                LDA [INDEX]         ; Get the value in the cell
.1a665f	85 23		sta $0823	                STA ARGUMENT1
.1a6661	a0 02 00	ldy #$0002	                LDY #2
.1a6664	b7 08		lda [$0808],y	                LDA [INDEX],Y
.1a6666	85 25		sta $0825	                STA ARGUMENT1+2
.1a6668	e2 20		sep #$20	            SEP #$20
.1a666a	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.1a666d	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.1a666f	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.1a6671	85 27		sta $0827	                STA ARGTYPE1        ; Set the type of the return value
.1a6673	28		plp		                PLP
.1a6674	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\dos.s

.0000					DIRENTRY
>0000					SHORTNAME               .fill 11        ; $00 - The short name of the file (8 name, 3 extension)
>000b					ATTRIBUTE               .byte ?         ; $0B - The attribute bits
>000c					IGNORED1                .word ?         ; $0C - Unused (by us) bytes
>000e					CREATE_TIME             .word ?         ; $0E - Creation time
>0010					CREATE_DATE             .word ?         ; $10 - Creation date
>0012					ACCESS_DATE             .word ?         ; $12 - Last access date
>0014					CLUSTER_H               .word ?         ; $14 - High word of the first cluster #
>0016					MODIFIED_TIME           .word ?         ; $16 - Last modified time
>0018					MODIFIED_DATE           .word ?         ; $18 - Last modified date
>001a					CLUSTER_L               .word ?         ; $1A - Low word of the first cluster #
>001c					SIZE                    .dword ?        ; $1C - The size of the file (in bytes)
=$01					DOS_ATTR_RO = $01                       ; File is read-only
=$02					DOS_ATTR_HIDDEN = $02                   ; File is hidden
=$04					DOS_ATTR_SYSTEM = $04                   ; File is a system file
=$08					DOS_ATTR_VOLUME = $08                   ; Entry is the volume label
=$10					DOS_ATTR_DIR = $10                      ; Entry is a directory
=$20					DOS_ATTR_ARCH = $20                     ; Entry has changed since last backup
=$0f					DOS_ATTR_LONGNAME = $0F                 ; Entry is the long file name
=$e5					DOS_DIR_ENT_UNUSED = $E5                ; Marker for an unused directory entry
.0000					FILEDESC
>0000					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>0001					DEV                 .byte ?             ; The ID of the device holding the file
>0002					PATH                .dword ?            ; Pointer to a NULL terminated path string
>0006					CLUSTER             .dword ?            ; The current cluster of the file.
>000a					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>000e					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>0012					FILESIZE            .dword ?            ; The size of the file
>0016					CREATE_DATE         .word ?             ; The creation date of the file
>0018					CREATE_TIME         .word ?             ; The creation time of the file
>001a					MODIFIED_DATE       .word ?             ; The modification date of the file
>001c					MODIFIED_TIME       .word ?             ; The modification time of the file
=$01					FD_STAT_READ = $01                      ; The file is readable
=$02					FD_STAT_WRITE = $02                     ; The file is writable
=$40					FD_STAT_OPEN = $40                      ; The file is open
=$60					FD_STAT_ERROR = $60                     ; The file is in an error condition
=$80					FD_STAT_EOF = $80                       ; The file cursor is at the end of the file
>1af073					CLUSTER_BUFF    .fill 512           ; A buffer for cluster read/write operations
.1af273					FD_IN
>1af273					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>1af274					DEV                 .byte ?             ; The ID of the device holding the file
>1af275					PATH                .dword ?            ; Pointer to a NULL terminated path string
>1af279					CLUSTER             .dword ?            ; The current cluster of the file.
>1af27d					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>1af281					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>1af285					FILESIZE            .dword ?            ; The size of the file
>1af289					CREATE_DATE         .word ?             ; The creation date of the file
>1af28b					CREATE_TIME         .word ?             ; The creation time of the file
>1af28d					MODIFIED_DATE       .word ?             ; The modification date of the file
>1af28f					MODIFIED_TIME       .word ?             ; The modification time of the file
.1a6675					PR_FILESIZE
.1a6675	da		phx		                PHX
.1a6676	0b		phd		                PHD
.1a6677	08		php		                PHP
.1a6678	08		php		            PHP
.1a6679	c2 20		rep #$20	            REP #$20
.1a667b	48		pha		            PHA
.1a667c	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a667f	5b		tcd		            TCD
.1a6680	68		pla		            PLA
.1a6681	28		plp		            PLP
.1a6682	c2 30		rep #$30	            REP #$30
.1a6684	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6686	89 f0 ff	bit #$fff0	                BIT #$FFF0              ; Check to see if the amount is in MB range
.1a6689	d0 29		bne $1a66b4	                BNE pr_mb               ; If so, print it in MBs
.1a668b	89 0f 00	bit #$000f	                BIT #$000F              ; Check to see if the amount is in KB range
.1a668e	d0 0c		bne $1a669c	                BNE pr_kb
.1a6690	a5 23		lda $0823	                LDA ARGUMENT1
.1a6692	89 00 fc	bit #$fc00	                BIT #$FC00
.1a6695	d0 05		bne $1a669c	                BNE pr_kb               ; If so, print it in KBs
.1a6697					pr_regular
.1a6697	20 07 44	jsr $1a4407	            JSR PR_INTEGER
.1a669a	80 2e		bra $1a66ca	                BRA done
.1a669c	a2 0a 00	ldx #$000a	pr_kb           LDX #10                 ; Shift so the amount in KB is in ARGUMENT1
.1a669f	46 25		lsr $0825	kb_shift        LSR ARGUMENT1+2
.1a66a1	66 23		ror $0823	                ROR ARGUMENT1
.1a66a3	ca		dex		                DEX
.1a66a4	d0 f9		bne $1a669f	                BNE kb_shift
.1a66a6	20 07 44	jsr $1a4407	            JSR PR_INTEGER
.1a66a9	e2 20		sep #$20	            SEP #$20
.1a66ab	a9 4b		lda #$4b	                LDA #'K'
.1a66ad	20 18 00	jsr $1a0018	            JSR PRINTC
.1a66b0	c2 20		rep #$20	            REP #$20
.1a66b2	80 16		bra $1a66ca	                BRA done
.1a66b4	a2 14 00	ldx #$0014	pr_mb           LDX #20                 ; Shift so the amount in MB is in ARGUMENT1
.1a66b7	46 25		lsr $0825	mb_shift        LSR ARGUMENT1+2
.1a66b9	66 23		ror $0823	                ROR ARGUMENT1
.1a66bb	ca		dex		                DEX
.1a66bc	d0 f9		bne $1a66b7	                BNE mb_shift
.1a66be	20 07 44	jsr $1a4407	            JSR PR_INTEGER
.1a66c1	e2 20		sep #$20	            SEP #$20
.1a66c3	a9 4d		lda #$4d	                LDA #'M'
.1a66c5	20 18 00	jsr $1a0018	            JSR PRINTC
.1a66c8	c2 20		rep #$20	            REP #$20
.1a66ca	28		plp		done            PLP
.1a66cb	2b		pld		                PLD
.1a66cc	fa		plx		                PLX
.1a66cd	60		rts		            RTS
.1a66ce					CMD_DIR
.1a66ce	0b		phd		                PHD
.1a66cf	08		php		                PHP
.1a66d0	c2 30		rep #$30	            REP #$30
.1a66d2	a9 00 00	lda #$0000	                LDA #0                      ; Zero out the pagination line count
.1a66d5	8f b6 08 00	sta $0008b6	                STA @l LINECOUNT
.1a66d9	8f b8 08 00	sta $0008b8	                STA @l LINECOUNT+2
.1a66dd	e2 20		sep #$20	            SEP #$20
.1a66df	20 bf 20	jsr $1a20bf	            JSR PEEK_TOK
.1a66e2	c9 00		cmp #$00	                CMP #0
.1a66e4	f0 08		beq $1a66ee	                BEQ set_null                ; If none provided, set the path to empty
.1a66e6	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a66e9	20 95 05	jsr $1a0595	            JSR ASS_ARG1_STR
.1a66ec	80 11		bra $1a66ff	                BRA set_fd
.1a66ee					set_null
.1a66ee	c2 20		rep #$20	            REP #$20
.1a66f0	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT1 to the NULL string
.1a66f3	85 23		sta $0823	                STA ARGUMENT1
.1a66f5	85 25		sta $0825	                STA ARGUMENT1+2
.1a66f7	e2 20		sep #$20	            SEP #$20
.1a66f9	a9 02		lda #$02	                LDA #TYPE_STRING
.1a66fb	85 27		sta $0827	                STA ARGTYPE1
.1a66fd	c2 20		rep #$20	            REP #$20
.1a66ff					set_fd
.1a66ff	20 2f 68	jsr $1a682f	            JSR SETFILEDESC
.1a6702	22 08 11 00	jsl $001108	                JSL FK_DIROPEN              ; Open up the directory
.1a6706	b0 22		bcs $1a672a	                BCS pr_first
.1a6708	20 e0 68	jsr $1a68e0	            JSR SET_DOSSTAT
.1a670b	08		php		            PHP
.1a670c	c2 20		rep #$20	            REP #$20
.1a670e	48		pha		            PHA
.1a670f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6712	5b		tcd		            TCD
.1a6713	68		pla		            PLA
.1a6714	28		plp		            PLP
.1a6715	e2 20		sep #$20	            SEP #$20
.1a6717	a9 10		lda #$10	            LDA #ERR_DIRECTORY
.1a6719	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a671d	c2 20		rep #$20	            REP #$20
.1a671f	29 ff 00	and #$00ff	            AND #$00FF
.1a6722	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a6725	e2 20		sep #$20	            SEP #$20
.1a6727	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a672a					pr_first
.1a672a	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a672d					pr_entry
.1a672d	08		php		            PHP
.1a672e	c2 20		rep #$20	            REP #$20
.1a6730	48		pha		            PHA
.1a6731	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.1a6734	5b		tcd		            TCD
.1a6735	68		pla		            PLA
.1a6736	28		plp		            PLP
.1a6737	e2 20		sep #$20	            SEP #$20
.1a6739	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Start with the file name
.1a673c	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the initial character of the name
.1a673e	d0 03		bne $1a6743	                BNE chk_unused
.1a6740	82 a9 00	brl $1a67ec	                BRL done                    ; If it's NULL, we're done
.1a6743	c9 e5		cmp #$e5	chk_unused      CMP #DOS_DIR_ENT_UNUSED     ; Is it the unusued code?
.1a6745	d0 03		bne $1a674a	                BNE chk_attributes
.1a6747	82 96 00	brl $1a67e0	                BRL next_entry              ; Yes: go to the next entry
.1a674a	a0 0b 00	ldy #$000b	chk_attributes  LDY #DIRENTRY.ATTRIBUTE
.1a674d	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute byte
.1a674f	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.1a6751	f0 03		beq $1a6756	                BEQ chk_hidden
.1a6753	82 a9 00	brl $1a67ff	                BRL pr_volume               ; Print the volume label
.1a6756	89 02		bit #$02	chk_hidden      BIT #DOS_ATTR_HIDDEN        ; Is it a hidden file?
.1a6758	f0 03		beq $1a675d	                BEQ chk_long
.1a675a	82 83 00	brl $1a67e0	                BRL next_entry              ; Yes: go to the next entry
.1a675d	29 0f		and #$0f	chk_long        AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.1a675f	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.1a6761	d0 03		bne $1a6766	                BNE get_short_name
.1a6763	82 7a 00	brl $1a67e0	                BRL next_entry              ; Yes: go to the next entry
.1a6766	a0 00 00	ldy #$0000	get_short_name  LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.1a6769	b7 18		lda [$0338],y	pr_name_loop    LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.1a676b	20 18 00	jsr $1a0018	            JSR PRINTC
.1a676e	c8		iny		                INY                         ; Move to the next character
.1a676f	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.1a6772	d0 f5		bne $1a6769	                BNE pr_name_loop            ; No: print this new character
.1a6774	a9 20		lda #$20	                LDA #' '                    ; Print the separator
.1a6776	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6779	a0 08 00	ldy #$0008	                LDY #DIRENTRY.SHORTNAME+8   ; Move to the first of the extension characters
.1a677c	b7 18		lda [$0338],y	pr_ext_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.1a677e	20 18 00	jsr $1a0018	                JSR PRINTC                  ; Otherwise: print it.
.1a6781	c8		iny		                INY                         ; Move to the next character
.1a6782	c0 0b 00	cpy #$000b	                CPY #DIRENTRY.SHORTNAME+11  ; Are we at the end of the extension portion?
.1a6785	d0 f5		bne $1a677c	                BNE pr_ext_loop             ; No: print this new character
.1a6787	a9 09		lda #$09	pr_tab1         LDA #CHAR_TAB               ; Print a TAB
.1a6789	20 18 00	jsr $1a0018	            JSR PRINTC
.1a678c	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.1a678f	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.1a6791	89 10		bit #$10	                BIT #DOS_ATTR_DIR           ; Is it a directory?
.1a6793	d0 1e		bne $1a67b3	                BNE pr_attr                 ; Yes: skip printing a file size
.1a6795	c2 20		rep #$20	            REP #$20
.1a6797	a0 1c 00	ldy #$001c	                LDY #DIRENTRY.SIZE
.1a679a	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the file size
.1a679c	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.1a67a0	c8		iny		                INY
.1a67a1	c8		iny		                INY
.1a67a2	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y
.1a67a4	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.1a67a8	e2 20		sep #$20	            SEP #$20
.1a67aa	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a67ac	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.1a67b0	20 75 66	jsr $1a6675	            JSR PR_FILESIZE
.1a67b3	a9 09		lda #$09	pr_attr         LDA #CHAR_TAB               ; Print a TAB
.1a67b5	20 18 00	jsr $1a0018	            JSR PRINTC
.1a67b8	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.1a67bb	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.1a67bd	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.1a67bf	d0 1c		bne $1a67dd	                BNE end_entry               ; Yes: we're done printing this entry
.1a67c1	89 01		bit #$01	chk_read        BIT #DOS_ATTR_RO            ; Is it a read-only file?
.1a67c3	f0 05		beq $1a67ca	                BEQ chk_system
.1a67c5	a9 52		lda #$52	                LDA #'R'                    ; Yes: print an R
.1a67c7	20 18 00	jsr $1a0018	            JSR PRINTC
.1a67ca	89 04		bit #$04	chk_system      BIT #DOS_ATTR_SYSTEM        ; Is it System file?
.1a67cc	f0 05		beq $1a67d3	                BEQ chk_directory
.1a67ce	a9 53		lda #$53	                LDA #'S'                    ; Yes: print an S
.1a67d0	20 18 00	jsr $1a0018	            JSR PRINTC
.1a67d3	89 10		bit #$10	chk_directory   BIT #DOS_ATTR_DIR           ; Is it a directory?
.1a67d5	f0 05		beq $1a67dc	                BEQ pr_tab2
.1a67d7	a9 44		lda #$44	                LDA #'D'                    ; Yes: print a D
.1a67d9	20 18 00	jsr $1a0018	            JSR PRINTC
.1a67dc	ea		nop		pr_tab2         NOP
.1a67dd					end_entry
.1a67dd	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a67e0					next_entry
.1a67e0	20 a0 02	jsr $1a02a0	            JSR PAGINATE
.1a67e3	22 0c 11 00	jsl $00110c	                JSL FK_DIRNEXT
.1a67e7	90 03		bcc $1a67ec	                BCC done
.1a67e9	82 41 ff	brl $1a672d	                BRL pr_entry
.1a67ec					done
.1a67ec	20 e0 68	jsr $1a68e0	            JSR SET_DOSSTAT
.1a67ef	08		php		            PHP
.1a67f0	c2 20		rep #$20	            REP #$20
.1a67f2	48		pha		            PHA
.1a67f3	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a67f6	5b		tcd		            TCD
.1a67f7	68		pla		            PLA
.1a67f8	28		plp		            PLP
.1a67f9	20 a3 1f	jsr $1a1fa3	            JSR SKIPSTMT
.1a67fc	28		plp		                PLP
.1a67fd	2b		pld		                PLD
.1a67fe	60		rts		            RTS
.1a67ff					pr_volume
.1a67ff	08		php		            PHP
.1a6800	c2 20		rep #$20	            REP #$20
.1a6802	48		pha		            PHA
.1a6803	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.1a6806	5b		tcd		            TCD
.1a6807	68		pla		            PLA
.1a6808	28		plp		            PLP
.1a6809	e2 20		sep #$20	            SEP #$20
.1a680b	29 0f		and #$0f	                AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.1a680d	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.1a680f	f0 cf		beq $1a67e0	                BEQ next_entry              ; Yes: skip it
.1a6811	a9 5b		lda #$5b	pr_lbracket     LDA #'['
.1a6813	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6816	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.1a6819	b7 18		lda [$0338],y	pr_vol_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.1a681b	c9 20		cmp #$20	                CMP #CHAR_SP                ; Is it a blank?
.1a681d	f0 09		beq $1a6828	                BEQ pr_rbracket             ; Yes: end the name and print the dot
.1a681f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a6822	c8		iny		                INY                         ; Move to the next character
.1a6823	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.1a6826	d0 f1		bne $1a6819	                BNE pr_vol_loop             ; No: print this new character
.1a6828	a9 5d		lda #$5d	pr_rbracket     LDA #']'                    ; Print a close bracket
.1a682a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a682d	80 ae		bra $1a67dd	                BRA end_entry               ; And try to get the next entry
.1a682f					SETFILEDESC
.1a682f	0b		phd		                PHD
.1a6830	08		php		                PHP
.1a6831	08		php		            PHP
.1a6832	c2 20		rep #$20	            REP #$20
.1a6834	48		pha		            PHA
.1a6835	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.1a6838	5b		tcd		            TCD
.1a6839	68		pla		            PLA
.1a683a	28		plp		            PLP
.1a683b	c2 30		rep #$30	            REP #$30
.1a683d	a9 73 f2	lda #$f273	                LDA #<>FD_IN            ; Point to the file descriptor
.1a6840	85 20		sta $0340	                STA DOS_FD_PTR
.1a6842	a9 1a 00	lda #$001a	                LDA #`FD_IN
.1a6845	85 22		sta $0342	                STA DOS_FD_PTR+2
.1a6847	a0 00 00	ldy #$0000	                LDY #0                  ; Fille the file descriptor with 0
.1a684a	e2 20		sep #$20	            SEP #$20
.1a684c	a9 00		lda #$00	                LDA #0
.1a684e	97 20		sta [$0340],y	zero_loop       STA [DOS_FD_PTR],Y
.1a6850	c8		iny		                INY
.1a6851	c0 1e 00	cpy #$001e	                CPY #SIZE(FILEDESC)
.1a6854	d0 f8		bne $1a684e	                BNE zero_loop
.1a6856	c2 20		rep #$20	            REP #$20
.1a6858	a9 73 f0	lda #$f073	                LDA #<>CLUSTER_BUFF     ; Point to the cluster buffer
.1a685b	8f 81 f2 1a	sta $1af281	                STA @l FD_IN.BUFFER
.1a685f	a9 1a 00	lda #$001a	                LDA #`CLUSTER_BUFF
.1a6862	8f 83 f2 1a	sta $1af283	                STA @l FD_IN.BUFFER+2
.1a6866	af 23 08 00	lda $000823	                LDA @l ARGUMENT1        ; Point the file desriptor to the path
.1a686a	8f 75 f2 1a	sta $1af275	                STA @l FD_IN.PATH
.1a686e	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.1a6872	8f 77 f2 1a	sta $1af277	                STA @l FD_IN.PATH+2
.1a6876	28		plp		                PLP
.1a6877	2b		pld		                PLD
.1a6878	60		rts		            RTS
.1a6879					S_BLOAD
.1a6879	08		php		                PHP
.1a687a	c2 30		rep #$30	            REP #$30
.1a687c	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a687f	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a6882	20 95 05	jsr $1a0595	            JSR ASS_ARG1_STR
.1a6885	20 2f 68	jsr $1a682f	            JSR SETFILEDESC
.1a6888	e2 20		sep #$20	            SEP #$20
.1a688a	a9 2c		lda #$2c	                LDA #','
.1a688c	85 37		sta $0837	                STA TARGETTOK
.1a688e	20 a0 20	jsr $1a20a0	            JSR OPT_TOK
.1a6891	b0 0f		bcs $1a68a2	                BCS get_dest
.1a6893	c2 20		rep #$20	            REP #$20
.1a6895	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set destination address to something "safe"
.1a6898	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a689c	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a68a0	80 17		bra $1a68b9	                BRA do_load
.1a68a2					get_dest
.1a68a2	20 5e 1f	jsr $1a1f5e	            JSR INCBIP
.1a68a5	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a68a8	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a68ab	c2 20		rep #$20	            REP #$20
.1a68ad	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the destination address
.1a68af	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a68b3	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a68b5	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a68b9	22 18 11 00	jsl $001118	do_load         JSL FK_LOAD                 ; Attempt to load the file
.1a68bd	b0 1f		bcs $1a68de	                BCS done
.1a68bf	08		php		            PHP
.1a68c0	c2 20		rep #$20	            REP #$20
.1a68c2	48		pha		            PHA
.1a68c3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a68c6	5b		tcd		            TCD
.1a68c7	68		pla		            PLA
.1a68c8	28		plp		            PLP
.1a68c9	e2 20		sep #$20	            SEP #$20
.1a68cb	a9 11		lda #$11	            LDA #ERR_LOAD
.1a68cd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a68d1	c2 20		rep #$20	            REP #$20
.1a68d3	29 ff 00	and #$00ff	            AND #$00FF
.1a68d6	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a68d9	e2 20		sep #$20	            SEP #$20
.1a68db	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a68de	28		plp		done            PLP
.1a68df	60		rts		            RTS
.1a68e0					SET_DOSSTAT
.1a68e0	8b		phb		                PHB
.1a68e1	0b		phd		                PHD
.1a68e2	08		php		                PHP
.1a68e3	08		php		            PHP
.1a68e4	c2 20		rep #$20	            REP #$20
.1a68e6	48		pha		            PHA
.1a68e7	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a68ea	5b		tcd		            TCD
.1a68eb	68		pla		            PLA
.1a68ec	28		plp		            PLP
.1a68ed	08		php		            PHP
.1a68ee	e2 20		sep #$20	            SEP #$20
.1a68f0	48		pha		            PHA
.1a68f1	a9 00		lda #$00	            LDA #BASIC_BANK
.1a68f3	48		pha		            PHA
.1a68f4	ab		plb		            PLB
.1a68f5	68		pla		            PLA
.1a68f6	28		plp		            PLP
.1a68f7	e2 20		sep #$20	            SEP #$20
.1a68f9	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS           ; Get the DOS status code
.1a68fd	85 23		sta $0823	                STA ARGUMENT1
.1a68ff	a9 00		lda #$00	                LDA #0
.1a6901	85 24		sta $0824	                STA ARGUMENT1+1
.1a6903	85 25		sta $0825	                STA ARGUMENT1+2
.1a6905	85 26		sta $0826	                STA ARGUMENT1+3
.1a6907	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a6909	85 27		sta $0827	                STA ARGTYPE1
.1a690b	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (DOSSTAT)
.1a690d	a9 1a		lda #$1a	                LDA #`dosstat_name
.1a690f	85 e9		sta $08e9	                STA TOFIND+2
.1a6911	c2 20		rep #$20	            REP #$20
.1a6913	a9 43 69	lda #$6943	                LDA #<>dosstat_name
.1a6916	85 e7		sta $08e7	                STA TOFIND
.1a6918	20 f0 50	jsr $1a50f0	            JSR VAR_SET
.1a691b	e2 20		sep #$20	            SEP #$20
.1a691d	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS          ; Get the BIOS status code
.1a6921	85 23		sta $0823	                STA ARGUMENT1
.1a6923	a9 00		lda #$00	                LDA #0
.1a6925	85 24		sta $0824	                STA ARGUMENT1+1
.1a6927	85 25		sta $0825	                STA ARGUMENT1+2
.1a6929	85 26		sta $0826	                STA ARGUMENT1+3
.1a692b	a9 00		lda #$00	                LDA #TYPE_INTEGER
.1a692d	85 27		sta $0827	                STA ARGTYPE1
.1a692f	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BIOSSTAT)
.1a6931	a9 1a		lda #$1a	                LDA #`biosstat_name
.1a6933	85 e9		sta $08e9	                STA TOFIND+2
.1a6935	c2 20		rep #$20	            REP #$20
.1a6937	a9 4b 69	lda #$694b	                LDA #<>biosstat_name
.1a693a	85 e7		sta $08e7	                STA TOFIND
.1a693c	20 f0 50	jsr $1a50f0	            JSR VAR_SET
.1a693f	28		plp		                PLP
.1a6940	2b		pld		                PLD
.1a6941	ab		plb		                PLB
.1a6942	60		rts		            RTS
>1a6943	44 4f 53 53 54 41 54 00		dosstat_name    .null "DOSSTAT"
>1a694b	42 49 4f 53 53 54 41 54		biosstat_name   .null "BIOSSTAT"
>1a6953	00
.1a6954					CMD_BRUN
.1a6954	08		php		                PHP
.1a6955	c2 30		rep #$30	            REP #$30
.1a6957	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a695a	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a695d	20 95 05	jsr $1a0595	            JSR ASS_ARG1_STR
.1a6960	a5 23		lda $0823	                LDA ARGUMENT1
.1a6962	8f 60 03 00	sta $000360	                STA @l DOS_RUN_PARAM
.1a6966	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6968	8f 62 03 00	sta $000362	                STA @l DOS_RUN_PARAM+2
.1a696c	a9 ff ff	lda #$ffff	                LDA #$FFFF
.1a696f	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a6973	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a6977	22 24 11 00	jsl $001124	                JSL FK_RUN                  ; Attempt to run the file
.1a697b	b0 25		bcs $1a69a2	                BCS done                    ; If we got it: try to execute it
.1a697d	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a6980	20 e0 68	jsr $1a68e0	            JSR SET_DOSSTAT
.1a6983	08		php		            PHP
.1a6984	c2 20		rep #$20	            REP #$20
.1a6986	48		pha		            PHA
.1a6987	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a698a	5b		tcd		            TCD
.1a698b	68		pla		            PLA
.1a698c	28		plp		            PLP
.1a698d	e2 20		sep #$20	            SEP #$20
.1a698f	a9 11		lda #$11	            LDA #ERR_LOAD
.1a6991	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6995	c2 20		rep #$20	            REP #$20
.1a6997	29 ff 00	and #$00ff	            AND #$00FF
.1a699a	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a699d	e2 20		sep #$20	            SEP #$20
.1a699f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a69a2					done
.1a69a2	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a69a5	28		plp		                PLP
.1a69a6	60		rts		            RTS
.1a69a7					CMD_LOAD
.1a69a7	08		php		                PHP
.1a69a8	c2 30		rep #$30	            REP #$30
.1a69aa	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a69ad	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a69b0	20 95 05	jsr $1a0595	            JSR ASS_ARG1_STR
.1a69b3	20 2f 68	jsr $1a682f	            JSR SETFILEDESC
.1a69b6	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.1a69b9	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a69bd	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.1a69c0	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2        ; Set the destination address
.1a69c4	20 c1 4d	jsr $1a4dc1	            JSR CMD_NEW
.1a69c7	22 18 11 00	jsl $001118	                JSL FK_LOAD                 ; Attempt to load the file
.1a69cb	b0 22		bcs $1a69ef	                BCS start_tokenize          ; If we got it: start tokenizing
.1a69cd	20 e0 68	jsr $1a68e0	            JSR SET_DOSSTAT
.1a69d0	08		php		            PHP
.1a69d1	c2 20		rep #$20	            REP #$20
.1a69d3	48		pha		            PHA
.1a69d4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a69d7	5b		tcd		            TCD
.1a69d8	68		pla		            PLA
.1a69d9	28		plp		            PLP
.1a69da	e2 20		sep #$20	            SEP #$20
.1a69dc	a9 11		lda #$11	            LDA #ERR_LOAD
.1a69de	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a69e2	c2 20		rep #$20	            REP #$20
.1a69e4	29 ff 00	and #$00ff	            AND #$00FF
.1a69e7	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a69ea	e2 20		sep #$20	            SEP #$20
.1a69ec	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a69ef					start_tokenize
.1a69ef	20 e0 68	jsr $1a68e0	            JSR SET_DOSSTAT
.1a69f2	c2 20		rep #$20	            REP #$20
.1a69f4	a2 12 00	ldx #$0012	                LDX #FILEDESC.FILESIZE
.1a69f7	18		clc		                CLC                         ; Set MTEMP to point to the byte after the file
.1a69f8	bf 73 f2 1a	lda $1af273,x	                LDA FD_IN,X
.1a69fc	69 00 00	adc #$0000	                ADC #<>LOADBLOCK
.1a69ff	85 92		sta $0892	                STA MTEMP
.1a6a01	bf 75 f2 1a	lda $1af275,x	                LDA FD_IN+2,X
.1a6a05	69 01 00	adc #$0001	                ADC #`LOADBLOCK
.1a6a08	85 94		sta $0894	                STA MTEMP+2
.1a6a0a	e2 20		sep #$20	            SEP #$20
.1a6a0c	a9 00		lda #$00	                LDA #0
.1a6a0e	87 92		sta [$0892]	                STA [MTEMP]                 ; Write a NULL right after the file
.1a6a10	c2 20		rep #$20	            REP #$20
.1a6a12	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK            ; Set MCURSOR to the begining of the loaded data
.1a6a15	85 7a		sta $087a	                STA MCURSOR
.1a6a17	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.1a6a1a	85 7c		sta $087c	                STA MCURSOR+2
.1a6a1c	a2 00 00	ldx #$0000	copy_line       LDX #0
.1a6a1f					copy_char
.1a6a1f	e2 20		sep #$20	            SEP #$20
.1a6a21	a7 7a		lda [$087a]	                LDA [MCURSOR]
.1a6a23	f0 2a		beq $1a6a4f	                BEQ clean_up                ; If the character is 0, we're done
.1a6a25	c9 0d		cmp #$0d	                CMP #CHAR_CR                ; If it is new line...
.1a6a27	f0 12		beq $1a6a3b	                BEQ do_process              ; ... we want to process the line
.1a6a29	c9 0a		cmp #$0a	                CMP #CHAR_LF                ; If it is a line feed...
.1a6a2b	f0 04		beq $1a6a31	                BEQ next_char               ; ... we want to skip it
.1a6a2d	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X              ; Otherwise, copy the character to the input buffer
.1a6a30	e8		inx		                INX
.1a6a31					next_char
.1a6a31	c2 20		rep #$20	            REP #$20
.1a6a33	e6 7a		inc $087a	                INC MCURSOR                 ; Advance the input cursor
.1a6a35	d0 e8		bne $1a6a1f	                BNE copy_char
.1a6a37	e6 7c		inc $087c	                INC MCURSOR+2
.1a6a39	80 e4		bra $1a6a1f	                BRA copy_char
.1a6a3b					do_process
.1a6a3b	e2 20		sep #$20	            SEP #$20
.1a6a3d	a9 00		lda #$00	                LDA #0                      ; Put a 0 at the end of the input buffer
.1a6a3f	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a6a42	20 cb 25	jsr $1a25cb	            JSR PROCESS
.1a6a45	c2 20		rep #$20	            REP #$20
.1a6a47	e6 7a		inc $087a	                INC MCURSOR                 ; Try again with the next line
.1a6a49	d0 d1		bne $1a6a1c	                BNE copy_line
.1a6a4b	e6 7c		inc $087c	                INC MCURSOR+2
.1a6a4d	80 cd		bra $1a6a1c	                BRA copy_line
.1a6a4f	e0 00 00	cpx #$0000	clean_up        CPX #0                      ; Is there data in the INPUTBUF?
.1a6a52	f0 0a		beq $1a6a5e	                BEQ done                    ; No: just return
.1a6a54	e2 20		sep #$20	            SEP #$20
.1a6a56	a9 00		lda #$00	                LDA #0                      ; Make sure there is a trailing NULL
.1a6a58	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.1a6a5b	20 cb 25	jsr $1a25cb	            JSR PROCESS
.1a6a5e	28		plp		done            PLP
.1a6a5f	60		rts		            RTS
.1a6a60					S_BSAVE
.1a6a60	08		php		                PHP
.1a6a61	c2 30		rep #$30	            REP #$30
.1a6a63	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a6a66	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a6a69	20 95 05	jsr $1a0595	            JSR ASS_ARG1_STR
.1a6a6c	20 2f 68	jsr $1a682f	            JSR SETFILEDESC
.1a6a6f	e2 20		sep #$20	            SEP #$20
.1a6a71	a9 2c		lda #$2c	                LDA #','
.1a6a73	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a6a76	c2 20		rep #$20	            REP #$20
.1a6a78	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a6a7b	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a6a7e	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_SRC_PTR
.1a6a80	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.1a6a84	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6a86	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.1a6a8a	e2 20		sep #$20	            SEP #$20
.1a6a8c	a9 2c		lda #$2c	                LDA #','
.1a6a8e	c2 20		rep #$20	            REP #$20
.1a6a90	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a6a93	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a6a96	20 03 05	jsr $1a0503	            JSR ASS_ARG1_INT
.1a6a99	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_END_PTR
.1a6a9b	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.1a6a9f	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6aa1	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.1a6aa5	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                 ; Attempt to save the memory to file.
.1a6aa9	b0 22		bcs $1a6acd	                BCS done
.1a6aab	20 e0 68	jsr $1a68e0	            JSR SET_DOSSTAT
.1a6aae	08		php		            PHP
.1a6aaf	c2 20		rep #$20	            REP #$20
.1a6ab1	48		pha		            PHA
.1a6ab2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6ab5	5b		tcd		            TCD
.1a6ab6	68		pla		            PLA
.1a6ab7	28		plp		            PLP
.1a6ab8	e2 20		sep #$20	            SEP #$20
.1a6aba	a9 12		lda #$12	            LDA #ERR_SAVE
.1a6abc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6ac0	c2 20		rep #$20	            REP #$20
.1a6ac2	29 ff 00	and #$00ff	            AND #$00FF
.1a6ac5	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a6ac8	e2 20		sep #$20	            SEP #$20
.1a6aca	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6acd					done
.1a6acd	20 e0 68	jsr $1a68e0	            JSR SET_DOSSTAT
.1a6ad0	28		plp		                PLP
.1a6ad1	60		rts		            RTS
.1a6ad2					COPY2PATHBUF
.1a6ad2	da		phx		                PHX
.1a6ad3	5a		phy		                PHY
.1a6ad4	08		php		                PHP
.1a6ad5	a2 00 00	ldx #$0000	                LDX #0
.1a6ad8	a0 00 00	ldy #$0000	                LDY #0
.1a6adb	e2 20		sep #$20	            SEP #$20
.1a6add	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y           ; Copy the path to the DOS_PATH_BUFF
.1a6adf	9d 00 04	sta $0400,x	                STA DOS_PATH_BUFF,X
.1a6ae2	f0 04		beq $1a6ae8	                BEQ done
.1a6ae4	e8		inx		                INX
.1a6ae5	c8		iny		                INY
.1a6ae6	80 f5		bra $1a6add	                BRA loop
.1a6ae8	28		plp		done            PLP
.1a6ae9	7a		ply		                PLY
.1a6aea	fa		plx		                PLX
.1a6aeb	60		rts		            RTS
.1a6aec					CMD_SAVE
.1a6aec	08		php		                PHP
.1a6aed	c2 30		rep #$30	            REP #$30
.1a6aef	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a6af2	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a6af5	20 95 05	jsr $1a0595	            JSR ASS_ARG1_STR
.1a6af8	20 2f 68	jsr $1a682f	            JSR SETFILEDESC
.1a6afb	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.1a6afe	85 a6		sta $08a6	                STA OBUFFER
.1a6b00	e2 20		sep #$20	            SEP #$20
.1a6b02	a9 01		lda #$01	                LDA #`LOADBLOCK
.1a6b04	85 a8		sta $08a8	                STA OBUFFER+2
.1a6b06	a9 20		lda #$20	                LDA #DEV_BUFFER             ; Set up output for the buffer
.1a6b08	85 b4		sta $08b4	                STA BCONSOLE
.1a6b0a	c2 20		rep #$20	            REP #$20
.1a6b0c	a9 00 00	lda #$0000	                LDA #0
.1a6b0f	85 ab		sta $08ab	                STA OBUFFIDX
.1a6b11	a9 ff ff	lda #$ffff	                LDA #$FFFF
.1a6b14	85 a9		sta $08a9	                STA OBUFFSIZE
.1a6b16	c2 20		rep #$20	            REP #$20
.1a6b18	a9 00 00	lda #$0000	                LDA #0                      ; Set start line number to 0
.1a6b1b	85 55		sta $0855	                STA MARG1
.1a6b1d	85 57		sta $0857	                STA MARG1+2
.1a6b1f	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set end line number to MAXINT
.1a6b22	85 59		sta $0859	                STA MARG2
.1a6b24	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.1a6b27	85 5b		sta $085b	                STA MARG2+2
.1a6b29	20 10 17	jsr $1a1710	            JSR LISTPROG
.1a6b2c	e2 20		sep #$20	            SEP #$20
.1a6b2e	a9 80		lda #$80	                LDA #DEV_SCREEN             ; Restore output to the screen
.1a6b30	85 b4		sta $08b4	                STA BCONSOLE
.1a6b32	c2 20		rep #$20	            REP #$20
.1a6b34	c6 ab		dec $08ab	                DEC OBUFFIDX                ; OBUFFIDX points to the next free byte... so pull it in one
.1a6b36	18		clc		                CLC                         ; Set the range of memory to save
.1a6b37	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.1a6b3a	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.1a6b3e	65 ab		adc $08ab	                ADC OBUFFIDX
.1a6b40	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.1a6b44	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.1a6b47	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.1a6b4b	69 00 00	adc #$0000	                ADC #0
.1a6b4e	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.1a6b52	22 1c 11 00	jsl $00111c	do_save         JSL FK_SAVE                 ; Attempt to save the file
.1a6b56	b0 22		bcs $1a6b7a	                BCS done
.1a6b58	20 e0 68	jsr $1a68e0	            JSR SET_DOSSTAT
.1a6b5b	08		php		            PHP
.1a6b5c	c2 20		rep #$20	            REP #$20
.1a6b5e	48		pha		            PHA
.1a6b5f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6b62	5b		tcd		            TCD
.1a6b63	68		pla		            PLA
.1a6b64	28		plp		            PLP
.1a6b65	e2 20		sep #$20	            SEP #$20
.1a6b67	a9 12		lda #$12	            LDA #ERR_SAVE
.1a6b69	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6b6d	c2 20		rep #$20	            REP #$20
.1a6b6f	29 ff 00	and #$00ff	            AND #$00FF
.1a6b72	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a6b75	e2 20		sep #$20	            SEP #$20
.1a6b77	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6b7a					done
.1a6b7a	20 e0 68	jsr $1a68e0	            JSR SET_DOSSTAT
.1a6b7d	28		plp		                PLP
.1a6b7e	60		rts		            RTS
.1a6b7f					S_DEL
.1a6b7f	08		php		                PHP
.1a6b80	c2 30		rep #$30	            REP #$30
.1a6b82	20 7f 1f	jsr $1a1f7f	            JSR SKIPWS
.1a6b85	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a6b88	20 95 05	jsr $1a0595	            JSR ASS_ARG1_STR
.1a6b8b	20 d2 6a	jsr $1a6ad2	            JSR COPY2PATHBUF
.1a6b8e	22 04 11 00	jsl $001104	path_loaded     JSL FK_DELETE               ; Try to delete the file
.1a6b92	b0 22		bcs $1a6bb6	                BCS done
.1a6b94	20 e0 68	jsr $1a68e0	            JSR SET_DOSSTAT
.1a6b97	08		php		            PHP
.1a6b98	c2 20		rep #$20	            REP #$20
.1a6b9a	48		pha		            PHA
.1a6b9b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6b9e	5b		tcd		            TCD
.1a6b9f	68		pla		            PLA
.1a6ba0	28		plp		            PLP
.1a6ba1	e2 20		sep #$20	            SEP #$20
.1a6ba3	a9 13		lda #$13	            LDA #ERR_DELETE
.1a6ba5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6ba9	c2 20		rep #$20	            REP #$20
.1a6bab	29 ff 00	and #$00ff	            AND #$00FF
.1a6bae	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a6bb1	e2 20		sep #$20	            SEP #$20
.1a6bb3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6bb6					done
.1a6bb6	20 e0 68	jsr $1a68e0	            JSR SET_DOSSTAT
.1a6bb9	28		plp		                PLP
.1a6bba	60		rts		            RTS
.1a6bbb					VALIDFILECHAR
.1a6bbb	da		phx		                PHX
.1a6bbc	08		php		                PHP
.1a6bbd	e2 20		sep #$20	            SEP #$20
.1a6bbf	c9 61		cmp #$61	                CMP #'a'                    ; Is it lower case?
.1a6bc1	90 08		bcc $1a6bcb	                BLT chk_space
.1a6bc3	c9 7b		cmp #$7b	                CMP #'z'+1
.1a6bc5	b0 04		bcs $1a6bcb	                BGE chk_space
.1a6bc7	29 df		and #$df	                AND #%11011111              ; Yes: convert to upper case
.1a6bc9	80 13		bra $1a6bde	                BRA ret_valid
.1a6bcb	c9 20		cmp #$20	chk_space       CMP #CHAR_SP            ; Is it a control code?
.1a6bcd	90 13		bcc $1a6be2	                BLT is_invalid          ; Yes: it's invalid
.1a6bcf	a2 00 00	ldx #$0000	                LDX #0                  ; See if it's in the list of invalids
.1a6bd2	df e6 6b 1a	cmp $1a6be6,x	loop            CMP invalid_chars,X
.1a6bd6	f0 0a		beq $1a6be2	                BEQ is_invalid
.1a6bd8	e8		inx		                INX
.1a6bd9	e0 0f 00	cpx #$000f	                CPX #15                 ; # of invalid characters
.1a6bdc	d0 f4		bne $1a6bd2	                BNE loop
.1a6bde	28		plp		ret_valid       PLP
.1a6bdf	38		sec		                SEC
.1a6be0	fa		plx		                PLX
.1a6be1	6b		rtl		                RTL
.1a6be2	28		plp		is_invalid      PLP
.1a6be3	18		clc		                CLC
.1a6be4	fa		plx		                PLX
.1a6be5	6b		rtl		                RTL
>1a6be6	2a 2b 2c 2f 3a 3b 3c 3d		invalid_chars   .text "*+,/:;<=>?\[]|",CHAR_DQUOTE
>1a6bee	3e 3f 5c 5b 5d 7c 22
.1a6bf5					S_RENAME
.1a6bf5	08		php		                PHP
.1a6bf6	08		php		            PHP
.1a6bf7	c2 20		rep #$20	            REP #$20
.1a6bf9	48		pha		            PHA
.1a6bfa	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6bfd	5b		tcd		            TCD
.1a6bfe	68		pla		            PLA
.1a6bff	28		plp		            PLP
.1a6c00	c2 30		rep #$30	            REP #$30
.1a6c02	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a6c05	20 95 05	jsr $1a0595	            JSR ASS_ARG1_STR
.1a6c08	20 d2 6a	jsr $1a6ad2	            JSR COPY2PATHBUF
.1a6c0b	22 10 11 00	jsl $001110	                JSL FK_DIRREAD              ; Try to read the file
.1a6c0f	b0 22		bcs $1a6c33	                BCS get_new_name            ; If ok: get the new name
.1a6c11	20 e0 68	jsr $1a68e0	            JSR SET_DOSSTAT
.1a6c14	08		php		            PHP
.1a6c15	c2 20		rep #$20	            REP #$20
.1a6c17	48		pha		            PHA
.1a6c18	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6c1b	5b		tcd		            TCD
.1a6c1c	68		pla		            PLA
.1a6c1d	28		plp		            PLP
.1a6c1e	e2 20		sep #$20	            SEP #$20
.1a6c20	a9 14		lda #$14	            LDA #ERR_FILENOTFOUND
.1a6c22	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6c26	c2 20		rep #$20	            REP #$20
.1a6c28	29 ff 00	and #$00ff	            AND #$00FF
.1a6c2b	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a6c2e	e2 20		sep #$20	            SEP #$20
.1a6c30	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6c33					get_new_name
.1a6c33	e2 20		sep #$20	            SEP #$20
.1a6c35	a9 2c		lda #$2c	                LDA #','
.1a6c37	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a6c3a	c2 20		rep #$20	            REP #$20
.1a6c3c	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a6c3f	20 95 05	jsr $1a0595	            JSR ASS_ARG1_STR
.1a6c42	ad 38 03	lda $0338	                LDA DOS_DIR_PTR
.1a6c45	85 08		sta $0808	                STA INDEX
.1a6c47	ad 3a 03	lda $033a	                LDA DOS_DIR_PTR+2
.1a6c4a	85 0a		sta $080a	                STA INDEX+2
.1a6c4c	e2 20		sep #$20	            SEP #$20
.1a6c4e	a2 00 00	ldx #$0000	                LDX #0
.1a6c51	a9 20		lda #$20	                LDA #CHAR_SP                ; We'll use MLINEBUFF as temporary name storage
.1a6c53	95 7e		sta $087e,x	blank_loop      STA MLINEBUF,X              ; Fill it with blanks
.1a6c55	e8		inx		                INX
.1a6c56	e0 0b 00	cpx #$000b	                CPX #11
.1a6c59	d0 f8		bne $1a6c53	                BNE blank_loop
.1a6c5b	a2 00 00	ldx #$0000	                LDX #0
.1a6c5e	a0 00 00	ldy #$0000	                LDY #0
.1a6c61	b7 23		lda [$0823],y	name_loop       LDA [ARGUMENT1],Y           ; Get the character of the new name
.1a6c63	f0 76		beq $1a6cdb	                BEQ copy_short_name         ; If end-of-string: copy what we have
.1a6c65	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.1a6c67	f0 39		beq $1a6ca2	                BEQ skip_dot                ; Yes: move on to the extension characters
.1a6c69	22 bb 6b 1a	jsl $1a6bbb	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.1a6c6d	b0 1f		bcs $1a6c8e	                BCS save_nm_char
.1a6c6f	08		php		            PHP
.1a6c70	c2 20		rep #$20	            REP #$20
.1a6c72	48		pha		            PHA
.1a6c73	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6c76	5b		tcd		            TCD
.1a6c77	68		pla		            PLA
.1a6c78	28		plp		            PLP
.1a6c79	e2 20		sep #$20	            SEP #$20
.1a6c7b	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a6c7d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6c81	c2 20		rep #$20	            REP #$20
.1a6c83	29 ff 00	and #$00ff	            AND #$00FF
.1a6c86	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a6c89	e2 20		sep #$20	            SEP #$20
.1a6c8b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6c8e	95 7e		sta $087e,x	save_nm_char    STA MLINEBUF,X              ; Otherwise: copy it
.1a6c90	c8		iny		                INY
.1a6c91	e8		inx		                INX
.1a6c92	c0 08 00	cpy #$0008	                CPY #8
.1a6c95	d0 ca		bne $1a6c61	                BNE name_loop
.1a6c97	b7 23		lda [$0823],y	eat_name        LDA [ARGUMENT1],Y           ; Get the character
.1a6c99	f0 40		beq $1a6cdb	                BEQ copy_short_name         ; If null, we're done with the short name
.1a6c9b	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.1a6c9d	f0 03		beq $1a6ca2	                BEQ skip_dot                ; Yes: skip over it
.1a6c9f	c8		iny		                INY                         ; No: try again with the the next character
.1a6ca0	80 f5		bra $1a6c97	                BRA eat_name
.1a6ca2	c8		iny		skip_dot        INY                         ; Character at Y is '.', so skip over it
.1a6ca3	a2 08 00	ldx #$0008	do_ext          LDX #8
.1a6ca6	b7 23		lda [$0823],y	ext_loop        LDA [ARGUMENT1],Y           ; Get the character of the new extension
.1a6ca8	f0 31		beq $1a6cdb	                BEQ copy_short_name         ; If end-of-string: copy what we have
.1a6caa	22 bb 6b 1a	jsl $1a6bbb	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.1a6cae	b0 22		bcs $1a6cd2	                BCS save_ext_char
.1a6cb0	20 e0 68	jsr $1a68e0	            JSR SET_DOSSTAT
.1a6cb3	08		php		            PHP
.1a6cb4	c2 20		rep #$20	            REP #$20
.1a6cb6	48		pha		            PHA
.1a6cb7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6cba	5b		tcd		            TCD
.1a6cbb	68		pla		            PLA
.1a6cbc	28		plp		            PLP
.1a6cbd	e2 20		sep #$20	            SEP #$20
.1a6cbf	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.1a6cc1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6cc5	c2 20		rep #$20	            REP #$20
.1a6cc7	29 ff 00	and #$00ff	            AND #$00FF
.1a6cca	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a6ccd	e2 20		sep #$20	            SEP #$20
.1a6ccf	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6cd2	95 7e		sta $087e,x	save_ext_char   STA MLINEBUF,X              ; Otherwise: copy it
.1a6cd4	c8		iny		                INY
.1a6cd5	e8		inx		                INX
.1a6cd6	c0 0c 00	cpy #$000c	                CPY #12
.1a6cd9	d0 cb		bne $1a6ca6	                BNE ext_loop
.1a6cdb	a2 00 00	ldx #$0000	copy_short_name LDX #0                      ; Copy the short name we built to the directory entry
.1a6cde	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME
.1a6ce1	b5 7e		lda $087e,x	copy_loop       LDA MLINEBUF,X
.1a6ce3	97 08		sta [$0808],y	                STA [INDEX],Y
.1a6ce5	e8		inx		                INX
.1a6ce6	c8		iny		                INY
.1a6ce7	c0 0b 00	cpy #$000b	                CPY #11
.1a6cea	d0 f5		bne $1a6ce1	                BNE copy_loop
.1a6cec	22 14 11 00	jsl $001114	                JSL FK_DIRWRITE             ; Write the directory entry back
.1a6cf0	b0 22		bcs $1a6d14	                BCS done
.1a6cf2	20 e0 68	jsr $1a68e0	            JSR SET_DOSSTAT
.1a6cf5	08		php		            PHP
.1a6cf6	c2 20		rep #$20	            REP #$20
.1a6cf8	48		pha		            PHA
.1a6cf9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6cfc	5b		tcd		            TCD
.1a6cfd	68		pla		            PLA
.1a6cfe	28		plp		            PLP
.1a6cff	e2 20		sep #$20	            SEP #$20
.1a6d01	a9 15		lda #$15	            LDA #ERR_DIRNOTWRITE
.1a6d03	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6d07	c2 20		rep #$20	            REP #$20
.1a6d09	29 ff 00	and #$00ff	            AND #$00FF
.1a6d0c	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a6d0f	e2 20		sep #$20	            SEP #$20
.1a6d11	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6d14					done
.1a6d14	20 e0 68	jsr $1a68e0	            JSR SET_DOSSTAT
.1a6d17	28		plp		                PLP
.1a6d18	60		rts		            RTS
.1a6d19					S_COPY
.1a6d19	08		php		                PHP
.1a6d1a	08		php		            PHP
.1a6d1b	c2 20		rep #$20	            REP #$20
.1a6d1d	48		pha		            PHA
.1a6d1e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a6d21	5b		tcd		            TCD
.1a6d22	68		pla		            PLA
.1a6d23	28		plp		            PLP
.1a6d24	c2 30		rep #$30	            REP #$30
.1a6d26	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a6d29	20 95 05	jsr $1a0595	            JSR ASS_ARG1_STR
.1a6d2c	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.1a6d2e	8f 64 03 00	sta $000364	                STA @l DOS_STR1_PTR
.1a6d32	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6d34	8f 66 03 00	sta $000366	                STA @l DOS_STR1_PTR+2
.1a6d38	e2 20		sep #$20	            SEP #$20
.1a6d3a	a9 2c		lda #$2c	                LDA #','
.1a6d3c	20 6b 20	jsr $1a206b	            JSR EXPECT_TOK
.1a6d3f	c2 20		rep #$20	            REP #$20
.1a6d41	20 4d 1b	jsr $1a1b4d	            JSR EVALEXPR
.1a6d44	20 95 05	jsr $1a0595	            JSR ASS_ARG1_STR
.1a6d47	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.1a6d49	8f 68 03 00	sta $000368	                STA @l DOS_STR2_PTR
.1a6d4d	a5 25		lda $0825	                LDA ARGUMENT1+2
.1a6d4f	8f 6a 03 00	sta $00036a	                STA @l DOS_STR2_PTR+2
.1a6d53	22 30 11 00	jsl $001130	                JSL FK_COPY                 ; Attempt to copy the file
.1a6d57	b0 1f		bcs $1a6d78	                BCS done
.1a6d59	08		php		            PHP
.1a6d5a	c2 20		rep #$20	            REP #$20
.1a6d5c	48		pha		            PHA
.1a6d5d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.1a6d60	5b		tcd		            TCD
.1a6d61	68		pla		            PLA
.1a6d62	28		plp		            PLP
.1a6d63	e2 20		sep #$20	            SEP #$20
.1a6d65	a9 16		lda #$16	            LDA #ERR_NOTCOPIED
.1a6d67	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.1a6d6b	c2 20		rep #$20	            REP #$20
.1a6d6d	29 ff 00	and #$00ff	            AND #$00FF
.1a6d70	20 9f 1c	jsr $1a1c9f	            JSR SET_ERRERL
.1a6d73	e2 20		sep #$20	            SEP #$20
.1a6d75	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.1a6d78	28		plp		done            PLP
.1a6d79	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\monitor.s

.1a6d7a	5c 3a 87 1a	jmp $1a873a	MRETURN         JML IMRETURN
.1a6d7e	5c 8b 85 1a	jmp $1a858b	MPARSE          JML IMPARSE
.1a6d82	5c 3b 87 1a	jmp $1a873b	MPARSE1         JML IMPARSE1
.1a6d86	5c b7 76 1a	jmp $1a76b7	MEXECUTE        JML IMEXECUTE
.1a6d8a	5c 14 77 1a	jmp $1a7714	MASSEMBLE       JML IMASSEMBLE
.1a6d8e	5c 47 76 1a	jmp $1a7647	MRMODIFY        JML IMRMODIFY
.1a6d92	5c cd 75 1a	jmp $1a75cd	MCOMPARE        JML IMCOMPARE
.1a6d96	5c 4a 7b 1a	jmp $1a7b4a	MDISASSEMBLE    JML IMDISASSEMBLE
.1a6d9a	5c 38 72 1a	jmp $1a7238	MFILL           JML IMFILL
.1a6d9e	5c 65 75 1a	jmp $1a7565	MGO             JML IMGO
.1a6da2	5c 20 75 1a	jmp $1a7520	MJUMP           JML IMJUMP
.1a6da6	5c aa 74 1a	jmp $1a74aa	MHUNT           JML IMHUNT
.1a6daa	5c 49 86 1a	jmp $1a8649	MLOAD           JML IMLOAD
.1a6dae	5c 46 73 1a	jmp $1a7346	MMEMORY         JML IMMEMORY
.1a6db2	5c 99 71 1a	jmp $1a7199	MREGISTERS      JML IMREGISTERS
.1a6db6	5c c4 86 1a	jmp $1a86c4	MSAVE           JML IMSAVE
.1a6dba	5c 74 72 1a	jmp $1a7274	MTRANSFER       JML IMTRANSFER
.1a6dbe	5c 3d 87 1a	jmp $1a873d	MVERIFY         JML IMVERIFY
.1a6dc2	5c 36 87 1a	jmp $1a8736	MEXIT           JML IMEXIT
.1a6dc6	5c 63 74 1a	jmp $1a7463	MMODIFY         JML IMMODIFY
.1a6dca	5c 3e 87 1a	jmp $1a873e	MDOS            JML IMDOS
.1a6dce	18		clc		IMONITOR        CLC                 ; clear the carry flag
.1a6dcf	fb		xce		                XCE                 ; move carry to emulation flags
.1a6dd0	c2 20		rep #$20	            REP #$20
.1a6dd2	a9 ff fe	lda #$feff	                LDA #STACK_END      ; Reset the stack
.1a6dd5	1b		tcs		                TAS
.1a6dd6	58		cli		                CLI                 ; Re-enable interrupts
.1a6dd7	5c db 6d 1a	jmp $1a6ddb	                JML IMREADY
.1a6ddb					IMREADY
.1a6ddb	c2 30		rep #$30	            REP #$30
.1a6ddd	22 99 71 1a	jsl $1a7199	                JSL IMREGISTERS
.1a6de1					ready_loop
.1a6de1	20 08 00	jsr $1a0008	            JSR READLINE
.1a6de4	20 0c 00	jsr $1a000c	            JSR SCRCOPYLINE
.1a6de7	8b		phb		                PHB
.1a6de8	e2 20		sep #$20	            SEP #$20
.1a6dea	a9 00		lda #$00	                LDA #`INPUTBUF
.1a6dec	48		pha		                PHA
.1a6ded	ab		plb		                PLB
.1a6dee	a2 00 4f	ldx #$4f00	                LDX #<>INPUTBUF
.1a6df1	20 17 04	jsr $1a0417	            JSR TOUPPER
.1a6df4	ab		plb		                PLB
.1a6df5	22 7e 6d 1a	jsl $1a6d7e	                JSL MPARSE          ; Parse the command
.1a6df9	22 86 6d 1a	jsl $1a6d86	                JSL MEXECUTE        ; And execute the parsed command
.1a6dfd	80 e2		bra $1a6de1	                BRA ready_loop
.1a6dff					IMHELP
.1a6dff	08		php		                PHP
.1a6e00	8b		phb		                PHB
.1a6e01	e2 20		sep #$20	            SEP #$20
.1a6e03	a9 1a		lda #$1a	                LDA #`help_text
.1a6e05	48		pha		                PHA
.1a6e06	ab		plb		                PLB
.1a6e07	c2 10		rep #$10	            REP #$10
.1a6e09	a2 12 6e	ldx #$6e12	                LDX #<>help_text
.1a6e0c	20 16 03	jsr $1a0316	            JSR PRINTS
.1a6e0f	ab		plb		                PLB
.1a6e10	28		plp		                PLP
.1a6e11	6b		rtl		                RTL
>1a6e12	41 20 3c 73 74 61 72 74		help_text       .text "A <start> <assembly>",CHAR_CR
>1a6e1a	3e 20 3c 61 73 73 65 6d 62 6c 79 3e 0d
>1a6e27	20 20 41 73 73 65 6d 62		                .text "  Assemble a program",CHAR_CR,CHAR_CR
>1a6e2f	6c 65 20 61 20 70 72 6f 67 72 61 6d 0d 0d
>1a6e3d	43 20 3c 73 74 61 72 74		                .text "C <start1> <start2> [len (1 if blank)]",CHAR_CR
>1a6e45	31 3e 20 3c 73 74 61 72 74 32 3e 20 5b 6c 65 6e
>1a6e55	20 28 31 20 69 66 20 62 6c 61 6e 6b 29 5d 0d
>1a6e64	20 20 43 6f 6d 70 61 72		                .text "  Compare to sections of memory",CHAR_CR,CHAR_CR
>1a6e6c	65 20 74 6f 20 73 65 63 74 69 6f 6e 73 20 6f 66
>1a6e7c	20 6d 65 6d 6f 72 79 0d 0d
>1a6e85	44 20 3c 73 74 61 72 74		                .text "D <start> [end]",CHAR_CR
>1a6e8d	3e 20 5b 65 6e 64 5d 0d
>1a6e95	20 20 44 69 73 61 73 73		                .text "  Disassemble a program",CHAR_CR,CHAR_CR
>1a6e9d	65 6d 62 6c 65 20 61 20 70 72 6f 67 72 61 6d 0d
>1a6ead	0d
>1a6eae	46 20 3c 73 74 61 72 74		                .text "F <start> <end> <byte>",CHAR_CR
>1a6eb6	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 0d
>1a6ec5	20 20 46 69 6c 6c 20 61		                .text "  Fill a block of memory with a byte",CHAR_CR,CHAR_CR
>1a6ecd	20 62 6c 6f 63 6b 20 6f 66 20 6d 65 6d 6f 72 79
>1a6edd	20 77 69 74 68 20 61 20 62 79 74 65 0d 0d
>1a6eeb	47 20 5b 61 64 64 72 65		                .text "G [address]",CHAR_CR
>1a6ef3	73 73 5d 0d
>1a6ef7	20 20 53 74 61 72 74 20		                .text "  Start execution at a location",CHAR_CR,CHAR_CR
>1a6eff	65 78 65 63 75 74 69 6f 6e 20 61 74 20 61 20 6c
>1a6f0f	6f 63 61 74 69 6f 6e 0d 0d
>1a6f18	4a 20 5b 61 64 64 72 65		                .text "J [address] - Jump to a location in memory",CHAR_CR
>1a6f20	73 73 5d 20 2d 20 4a 75 6d 70 20 74 6f 20 61 20
>1a6f30	6c 6f 63 61 74 69 6f 6e 20 69 6e 20 6d 65 6d 6f
>1a6f40	72 79 0d
>1a6f43	20 20 4a 75 6d 70 20 74		                .text "  Jump to a location in memory",CHAR_CR,CHAR_CR
>1a6f4b	6f 20 61 20 6c 6f 63 61 74 69 6f 6e 20 69 6e 20
>1a6f5b	6d 65 6d 6f 72 79 0d 0d
>1a6f63	48 20 3c 73 74 61 72 74		                .text "H <start> <end> <byte> [byte]..",CHAR_CR
>1a6f6b	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 20 5b
>1a6f7b	62 79 74 65 5d 2e 2e 0d
>1a6f83	20 20 48 75 6e 74 20 66		                .text "  Hunt for values in memory",CHAR_CR,CHAR_CR
>1a6f8b	6f 72 20 76 61 6c 75 65 73 20 69 6e 20 6d 65 6d
>1a6f9b	6f 72 79 0d 0d
>1a6fa0	4c 20 20 20 20 20 4c 4f		                .text "L     LOAD         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," [destination]",CHAR_CR
>1a6fa8	41 44 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>1a6fb8	22 20 5b 64 65 73 74 69 6e 61 74 69 6f 6e 5d 0d
>1a6fc8	4d 20 3c 73 74 61 72 74		                .text "M <start> [end]",CHAR_CR
>1a6fd0	3e 20 5b 65 6e 64 5d 0d
>1a6fd8	20 20 44 75 6d 70 20 74		                .text "  Dump the value in memory",CHAR_CR,CHAR_CR
>1a6fe0	68 65 20 76 61 6c 75 65 20 69 6e 20 6d 65 6d 6f
>1a6ff0	72 79 0d 0d
>1a6ff4	52 20 2d 20 44 69 73 70		                .text "R - Display the values of the registers",CHAR_CR,CHAR_CR
>1a6ffc	6c 61 79 20 74 68 65 20 76 61 6c 75 65 73 20 6f
>1a700c	66 20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d
>1a701c	0d
>1a701d	3b 20 3c 50 43 3e 20 3c		                .text "; <PC> <A> <X> <Y> <SP> <DBR> <DP> <NVMXDIZC>",CHAR_CR
>1a7025	41 3e 20 3c 58 3e 20 3c 59 3e 20 3c 53 50 3e 20
>1a7035	3c 44 42 52 3e 20 3c 44 50 3e 20 3c 4e 56 4d 58
>1a7045	44 49 5a 43 3e 0d
>1a704b	20 20 43 68 61 6e 67 65		                .text "  Change the contents of the registers",CHAR_CR,CHAR_CR
>1a7053	20 74 68 65 20 63 6f 6e 74 65 6e 74 73 20 6f 66
>1a7063	20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d 0d
>1a7073	53 20 20 20 20 20 53 41		                .text "S     SAVE         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," <start> <end>",CHAR_CR
>1a707b	56 45 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>1a708b	22 20 3c 73 74 61 72 74 3e 20 3c 65 6e 64 3e 0d
>1a709b	54 20 3c 73 74 61 72 74		                .text "T <start> <end> <destination>",CHAR_CR
>1a70a3	3e 20 3c 65 6e 64 3e 20 3c 64 65 73 74 69 6e 61
>1a70b3	74 69 6f 6e 3e 0d
>1a70b9	20 20 54 72 61 6e 73 66		                .text "  Transfer (copy) data within memory",CHAR_CR,CHAR_CR
>1a70c1	65 72 20 28 63 6f 70 79 29 20 64 61 74 61 20 77
>1a70d1	69 74 68 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>1a70df	57 20 3c 62 79 74 65 3e		                .text "W <byte>",CHAR_CR
>1a70e7	0d
>1a70e8	20 20 53 65 74 20 74 68		                .text "  Set the register width flags for the disassembler",CHAR_CR,CHAR_CR
>1a70f0	65 20 72 65 67 69 73 74 65 72 20 77 69 64 74 68
>1a7100	20 66 6c 61 67 73 20 66 6f 72 20 74 68 65 20 64
>1a7110	69 73 61 73 73 65 6d 62 6c 65 72 0d 0d
>1a711d	58 20 2d 20 52 65 74 75		                .text "X - Return to BASIC",CHAR_CR,CHAR_CR
>1a7125	72 6e 20 74 6f 20 42 41 53 49 43 0d 0d
>1a7132	3e 20 3c 73 74 61 72 74		                .text "> <start> <byte> [byte]...",CHAR_CR
>1a713a	3e 20 3c 62 79 74 65 3e 20 5b 62 79 74 65 5d 2e
>1a714a	2e 2e 0d
>1a714d	20 20 45 64 69 74 20 64		                .text "  Edit data in memory",CHAR_CR,CHAR_CR
>1a7155	61 74 61 20 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>1a7164	3f 20 2d 20 44 69 73 70		                .null "? - Display a short help screen",CHAR_CR,CHAR_CR
>1a716c	6c 61 79 20 61 20 73 68 6f 72 74 20 68 65 6c 70
>1a717c	20 73 63 72 65 65 6e 0d 0d 00
.1a7186					IMWIDTH
.1a7186	08		php		                PHP
.1a7187	08		php		            PHP
.1a7188	c2 20		rep #$20	            REP #$20
.1a718a	48		pha		            PHA
.1a718b	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a718e	5b		tcd		            TCD
.1a718f	68		pla		            PLA
.1a7190	28		plp		            PLP
.1a7191	e2 20		sep #$20	            SEP #$20
.1a7193	a5 0d		lda $0855	                LDA MARG1
.1a7195	85 4e		sta $0896	                STA MCPUSTAT
.1a7197	28		plp		                PLP
.1a7198	6b		rtl		                RTL
.1a7199					IMREGISTERS
.1a7199	20 e4 00	jsr $1a00e4	            JSR ENSURETEXT
.1a719c	08		php		            PHP
.1a719d	e2 20		sep #$20	            SEP #$20
.1a719f	48		pha		            PHA
.1a71a0	a9 1a		lda #$1a	            LDA #`mregisters_msg
.1a71a2	48		pha		            PHA
.1a71a3	ab		plb		            PLB
.1a71a4	68		pla		            PLA
.1a71a5	28		plp		            PLP
.1a71a6	a2 7b 87	ldx #$877b	                LDX #<>mregisters_msg
.1a71a9	20 16 03	jsr $1a0316	            JSR PRINTS
.1a71ac	e2 20		sep #$20	            SEP #$20
.1a71ae	a9 3b		lda #$3b	                LDA #';'
.1a71b0	20 18 00	jsr $1a0018	            JSR PRINTC
.1a71b3	a9 20		lda #$20	                LDA #' '
.1a71b5	20 18 00	jsr $1a0018	            JSR PRINTC
.1a71b8	c2 30		rep #$30	            REP #$30
.1a71ba	08		php		            PHP
.1a71bb	e2 20		sep #$20	            SEP #$20
.1a71bd	48		pha		            PHA
.1a71be	a9 00		lda #$00	            LDA #$0
.1a71c0	48		pha		            PHA
.1a71c1	ab		plb		            PLB
.1a71c2	68		pla		            PLA
.1a71c3	28		plp		            PLP
.1a71c4	a0 03 00	ldy #$0003	                LDY #3
.1a71c7	a2 42 02	ldx #$0242	                LDX #CPUPC+2
.1a71ca	20 99 02	jsr $1a0299	            JSR PRINTH
.1a71cd	c2 20		rep #$20	            REP #$20
.1a71cf	a9 20 00	lda #$0020	                LDA #' '
.1a71d2	20 18 00	jsr $1a0018	            JSR PRINTC
.1a71d5	af 44 02 00	lda $000244	                LDA @lCPUA
.1a71d9	20 26 03	jsr $1a0326	            JSR PRHEXW
.1a71dc	a9 20 00	lda #$0020	                LDA #' '
.1a71df	20 18 00	jsr $1a0018	            JSR PRINTC
.1a71e2	af 46 02 00	lda $000246	                LDA @lCPUX
.1a71e6	20 26 03	jsr $1a0326	            JSR PRHEXW
.1a71e9	a9 20 00	lda #$0020	                LDA #' '
.1a71ec	20 18 00	jsr $1a0018	            JSR PRINTC
.1a71ef	af 48 02 00	lda $000248	                LDA @lCPUY
.1a71f3	20 26 03	jsr $1a0326	            JSR PRHEXW
.1a71f6	a9 20 00	lda #$0020	                LDA #' '
.1a71f9	20 18 00	jsr $1a0018	            JSR PRINTC
.1a71fc	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK
.1a7200	20 26 03	jsr $1a0326	            JSR PRHEXW
.1a7203	a9 20 00	lda #$0020	                LDA #' '
.1a7206	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7209	af 4e 02 00	lda $00024e	                LDA @lCPUDBR
.1a720d	20 40 03	jsr $1a0340	            JSR PRHEXB
.1a7210	a9 20 00	lda #$0020	                LDA #' '
.1a7213	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7216	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7219	af 4c 02 00	lda $00024c	                LDA @lCPUDP
.1a721d	20 26 03	jsr $1a0326	            JSR PRHEXW
.1a7220	a9 20 00	lda #$0020	                LDA #' '
.1a7223	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7226	08		php		                PHP
.1a7227	e2 20		sep #$20	            SEP #$20
.1a7229	ad 4f 02	lda $024f	                LDA CPUFLAGS
.1a722c	22 94 84 1a	jsl $1a8494	                JSL MPRINTB
.1a7230	28		plp		                PLP
.1a7231	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a7234	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a7237	6b		rtl		                RTL
.1a7238					IMFILL
.1a7238	08		php		                PHP                 ; Save the caller's context
.1a7239	0b		phd		                PHD
.1a723a	08		php		            PHP
.1a723b	c2 20		rep #$20	            REP #$20
.1a723d	48		pha		            PHA
.1a723e	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7241	5b		tcd		            TCD
.1a7242	68		pla		            PLA
.1a7243	28		plp		            PLP
.1a7244					do_copy
.1a7244	e2 20		sep #$20	            SEP #$20
.1a7246	a5 15		lda $085d	                LDA MARG3
.1a7248	87 0d		sta [$0855]	                STA [MARG1]
.1a724a	e2 20		sep #$20	            SEP #$20
.1a724c	a5 0f		lda $0857	                LDA MARG1+2
.1a724e	c5 13		cmp $085b	                CMP MARG2+2
.1a7250	d0 0e		bne $1a7260	                BNE go_next         ; No: we haven't reached end address yet
.1a7252	c2 20		rep #$20	            REP #$20
.1a7254	a5 0d		lda $0855	                LDA MARG1
.1a7256	c5 11		cmp $0859	                CMP MARG2           ; Are they equal?
.1a7258	d0 06		bne $1a7260	                BNE go_next         ; No: we haven't reached end address yet
.1a725a	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a725d	2b		pld		                PLD                 ; Restore the caller's context
.1a725e	28		plp		                PLP
.1a725f	6b		rtl		                RTL
.1a7260					go_next
.1a7260	c2 20		rep #$20	            REP #$20
.1a7262	18		clc		                CLC
.1a7263	a5 0d		lda $0855	                LDA MARG1
.1a7265	69 01 00	adc #$0001	                ADC #1
.1a7268	85 0d		sta $0855	                STA MARG1
.1a726a	e2 20		sep #$20	            SEP #$20
.1a726c	a5 0e		lda $0856	                LDA MARG1+1
.1a726e	69 00		adc #$00	                ADC #0
.1a7270	85 0e		sta $0856	                STA MARG1+1
.1a7272	80 d0		bra $1a7244	                BRA do_copy
.1a7274					IMTRANSFER
.1a7274	08		php		                PHP
.1a7275	0b		phd		                PHD
.1a7276	08		php		            PHP
.1a7277	c2 20		rep #$20	            REP #$20
.1a7279	48		pha		            PHA
.1a727a	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a727d	5b		tcd		            TCD
.1a727e	68		pla		            PLA
.1a727f	28		plp		            PLP
.1a7280	e2 20		sep #$20	            SEP #$20
.1a7282	a5 0f		lda $0857	                LDA MARG1+2
.1a7284	c5 17		cmp $085f	                CMP MARG3+2
.1a7286	90 45		bcc $1a72cd	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.1a7288	c2 20		rep #$20	            REP #$20
.1a728a	a5 0d		lda $0855	                LDA MARG1
.1a728c	c5 15		cmp $085d	                CMP MARG3
.1a728e	90 3d		bcc $1a72cd	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.1a7290					copy_byte_down
.1a7290	e2 20		sep #$20	            SEP #$20
.1a7292	a7 0d		lda [$0855]	                LDA [MARG1]         ; Copy the byte
.1a7294	87 15		sta [$085d]	                STA [MARG3]
.1a7296	a5 0f		lda $0857	                LDA MARG1+2         ; Are the source's current and end bank bytes equal?
.1a7298	c5 13		cmp $085b	                CMP MARG2+2
.1a729a	d0 0b		bne $1a72a7	                BNE inc_pointers    ; No: we're not done yet
.1a729c	c2 20		rep #$20	            REP #$20
.1a729e	a5 0d		lda $0855	                LDA MARG1           ; Are the rest of the bits equal?
.1a72a0	c5 11		cmp $0859	                CMP MARG2
.1a72a2	d0 03		bne $1a72a7	                BNE inc_pointers    ; No: we're not done yet
.1a72a4	4c 2b 73	jmp $1a732b	                JMP done            ; Yes: we've copied the last byte, exit
.1a72a7					inc_pointers
.1a72a7	c2 20		rep #$20	            REP #$20
.1a72a9	18		clc		                CLC
.1a72aa	a5 0d		lda $0855	                LDA MARG1
.1a72ac	69 01 00	adc #$0001	                ADC #1
.1a72af	85 0d		sta $0855	                STA MARG1
.1a72b1	e2 20		sep #$20	            SEP #$20
.1a72b3	a5 0e		lda $0856	                LDA MARG1+1
.1a72b5	69 00		adc #$00	                ADC #0
.1a72b7	85 0e		sta $0856	                STA MARG1+1
.1a72b9	c2 20		rep #$20	            REP #$20
.1a72bb	18		clc		                CLC
.1a72bc	a5 15		lda $085d	                LDA MARG3
.1a72be	69 01 00	adc #$0001	                ADC #1
.1a72c1	85 15		sta $085d	                STA MARG3
.1a72c3	e2 20		sep #$20	            SEP #$20
.1a72c5	a5 16		lda $085e	                LDA MARG3+1
.1a72c7	69 00		adc #$00	                ADC #0
.1a72c9	85 16		sta $085e	                STA MARG3+1
.1a72cb	80 c3		bra $1a7290	                BRA copy_byte_down  ; And copy that next byte over
.1a72cd					copy_up
.1a72cd	c2 20		rep #$20	            REP #$20
.1a72cf	38		sec		                SEC
.1a72d0	a5 11		lda $0859	                LDA MARG2
.1a72d2	e5 0d		sbc $0855	                SBC MARG1
.1a72d4	85 19		sta $0861	                STA MARG4
.1a72d6	e2 20		sep #$20	            SEP #$20
.1a72d8	a5 13		lda $085b	                LDA MARG2+2
.1a72da	e5 0f		sbc $0857	                SBC MARG1+2
.1a72dc	85 1b		sta $0863	                STA MARG4+2
.1a72de	c2 20		rep #$20	            REP #$20
.1a72e0	18		clc		                CLC
.1a72e1	a5 19		lda $0861	                LDA MARG4
.1a72e3	65 15		adc $085d	                ADC MARG3
.1a72e5	85 15		sta $085d	                STA MARG3
.1a72e7	e2 20		sep #$20	            SEP #$20
.1a72e9	a5 1b		lda $0863	                LDA MARG4+2
.1a72eb	65 17		adc $085f	                ADC MARG3+2
.1a72ed	85 17		sta $085f	                STA MARG3+2
.1a72ef					copy_byte_up
.1a72ef	e2 20		sep #$20	            SEP #$20
.1a72f1	a7 11		lda [$0859]	                LDA [MARG2]
.1a72f3	87 15		sta [$085d]	                STA [MARG3]
.1a72f5	a5 13		lda $085b	                LDA MARG2+2         ; Are the source's current and start bank bytes equal?
.1a72f7	c5 0f		cmp $0857	                CMP MARG1+2
.1a72f9	d0 0a		bne $1a7305	                BNE dec_pointers    ; No: we're not done yet
.1a72fb	c2 20		rep #$20	            REP #$20
.1a72fd	a5 11		lda $0859	                LDA MARG2           ; Are the rest of the bits equal?
.1a72ff	c5 0d		cmp $0855	                CMP MARG1
.1a7301	d0 02		bne $1a7305	                BNE dec_pointers    ; No: we're not done yet
.1a7303	80 26		bra $1a732b	                BRA done            ; Yes: we've copied the last byte, exit
.1a7305					dec_pointers
.1a7305	c2 20		rep #$20	            REP #$20
.1a7307	38		sec		                SEC
.1a7308	a5 11		lda $0859	                LDA MARG2
.1a730a	e9 01 00	sbc #$0001	                SBC #1
.1a730d	85 11		sta $0859	                STA MARG2
.1a730f	e2 20		sep #$20	            SEP #$20
.1a7311	a5 12		lda $085a	                LDA MARG2+1
.1a7313	e9 00		sbc #$00	                SBC #0
.1a7315	85 12		sta $085a	                STA MARG2+1
.1a7317	c2 20		rep #$20	            REP #$20
.1a7319	38		sec		                SEC                 ; Decrement the current destination pointer (MARG3)
.1a731a	a5 15		lda $085d	                LDA MARG3
.1a731c	e9 01 00	sbc #$0001	                SBC #1
.1a731f	85 15		sta $085d	                STA MARG3
.1a7321	e2 20		sep #$20	            SEP #$20
.1a7323	a5 16		lda $085e	                LDA MARG3+1
.1a7325	e9 00		sbc #$00	                SBC #0
.1a7327	85 16		sta $085e	                STA MARG3+1
.1a7329	80 c4		bra $1a72ef	                BRA copy_byte_up    ; And copy that next byte
.1a732b					done
.1a732b	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a732e	2b		pld		                PLD
.1a732f	28		plp		                PLP
.1a7330	6b		rtl		                RTL
.1a7331					IS_PRINTABLE
.1a7331	08		php		                PHP
.1a7332	e2 20		sep #$20	            SEP #$20
.1a7334	c9 21		cmp #$21	                CMP #33
.1a7336	90 0b		bcc $1a7343	                BLT not_printable   ; 0 .. 31 are not printable
.1a7338	c9 7f		cmp #$7f	                CMP #127
.1a733a	90 04		bcc $1a7340	                BLT printable       ; 32 .. 126 are printable
.1a733c	c9 a0		cmp #$a0	                CMP #160
.1a733e	90 03		bcc $1a7343	                BLT not_printable   ; 127 .. 159 are not printable (assuming Latin-1)
.1a7340	28		plp		printable       PLP
.1a7341	38		sec		                SEC
.1a7342	6b		rtl		                RTL
.1a7343	28		plp		not_printable   PLP
.1a7344	18		clc		                CLC
.1a7345	6b		rtl		                RTL
=256					MMEMDUMPSIZE = 256  ; Default number of bytes to dump
=8					MMEMROWSIZE = 8    ; Number of bytes to dump per-row
.1a7346					IMMEMORY
.1a7346	08		php		                PHP
.1a7347	8b		phb		                PHB
.1a7348	0b		phd		                PHD
.1a7349	08		php		            PHP
.1a734a	c2 20		rep #$20	            REP #$20
.1a734c	48		pha		            PHA
.1a734d	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7350	5b		tcd		            TCD
.1a7351	68		pla		            PLA
.1a7352	28		plp		            PLP
.1a7353	e2 20		sep #$20	            SEP #$20
.1a7355	a9 00		lda #$00	                LDA #0              ; Clear the pagination line counter
.1a7357	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT
.1a735b	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.1a735d	c9 02		cmp #$02	                CMP #2
.1a735f	b0 16		bcs $1a7377	                BGE set_cursor      ; 2>= arguments? Use them as-is
.1a7361	c9 01		cmp #$01	                CMP #1
.1a7363	90 20		bcc $1a7385	                BLT no_args         ; No arguments passed? Use defaults
.1a7365	c2 20		rep #$20	            REP #$20
.1a7367	18		clc		                CLC
.1a7368	a5 0d		lda $0855	                LDA MARG1
.1a736a	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a736d	85 11		sta $0859	                STA MARG2
.1a736f	e2 20		sep #$20	            SEP #$20
.1a7371	a5 0f		lda $0857	                LDA MARG1+2
.1a7373	69 00		adc #$00	                ADC #0
.1a7375	85 13		sta $085b	                STA MARG2+2
.1a7377					set_cursor
.1a7377	c2 20		rep #$20	            REP #$20
.1a7379	a5 0d		lda $0855	                LDA MARG1
.1a737b	85 32		sta $087a	                STA MCURSOR
.1a737d	e2 20		sep #$20	            SEP #$20
.1a737f	a5 0f		lda $0857	                LDA MARG1+2
.1a7381	85 34		sta $087c	                STA MCURSOR+2
.1a7383	80 12		bra $1a7397	                BRA dump_line
.1a7385					no_args
.1a7385	c2 20		rep #$20	            REP #$20
.1a7387	18		clc		                CLC
.1a7388	a5 32		lda $087a	                LDA MCURSOR
.1a738a	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a738d	85 11		sta $0859	                STA MARG2
.1a738f	e2 20		sep #$20	            SEP #$20
.1a7391	a5 34		lda $087c	                LDA MCURSOR+2
.1a7393	69 00		adc #$00	                ADC #0
.1a7395	85 13		sta $085b	                STA MARG2+2
.1a7397					dump_line
.1a7397	e2 20		sep #$20	            SEP #$20
.1a7399	a0 00 00	ldy #$0000	                LDY #0
.1a739c	c2 20		rep #$20	            REP #$20
.1a739e	a5 32		lda $087a	                LDA MCURSOR             ; NOTE: the use of MARG4 here is a temporary
.1a73a0	85 19		sta $0861	                STA MARG4               ; hack. the copy_loop instruction does not
.1a73a2	e2 20		sep #$20	            SEP #$20
.1a73a4	a5 34		lda $087c	                LDA MCURSOR+2
.1a73a6	85 1b		sta $0863	                STA MARG4+2
.1a73a8	e2 20		sep #$20	            SEP #$20
.1a73aa	a7 19		lda [$0861]	copy_loop       LDA [MARG4]             ; TODO: Should be LDA [MCURSOR],Y, which doesn't seem to be working
.1a73ac	22 31 73 1a	jsl $1a7331	                JSL IS_PRINTABLE        ; Is it printable?
.1a73b0	b0 02		bcs $1a73b4	                BCS buffer_char         ; Yes: go ahead and add it to the line buffer
.1a73b2	a9 3f		lda #$3f	                LDA #'?'                ; No: replace it with dot
.1a73b4	99 7e 08	sta $087e,y	buffer_char     STA #MLINEBUF,B,Y
.1a73b7	c2 20		rep #$20	            REP #$20
.1a73b9	18		clc		                CLC
.1a73ba	a5 19		lda $0861	                LDA MARG4
.1a73bc	69 01 00	adc #$0001	                ADC #1
.1a73bf	85 19		sta $0861	                STA MARG4
.1a73c1	e2 20		sep #$20	            SEP #$20
.1a73c3	a5 1b		lda $0863	                LDA MARG4+2
.1a73c5	69 00		adc #$00	                ADC #0
.1a73c7	85 1b		sta $0863	                STA MARG4+2
.1a73c9	c8		iny		                INY
.1a73ca	c0 08 00	cpy #$0008	                CPY #MMEMROWSIZE
.1a73cd	90 db		bcc $1a73aa	                BLT copy_loop
.1a73cf	a9 00		lda #$00	                LDA #0
.1a73d1	99 7e 08	sta $087e,y	                STA #MLINEBUF,B,Y
.1a73d4	a9 3e		lda #$3e	                LDA #'>'
.1a73d6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a73d9	a9 20		lda #$20	                LDA #' '
.1a73db	20 18 00	jsr $1a0018	            JSR PRINTC
.1a73de	e2 20		sep #$20	            SEP #$20
.1a73e0	a5 34		lda $087c	                LDA MCURSOR+2
.1a73e2	20 40 03	jsr $1a0340	            JSR PRHEXB
.1a73e5	a9 3a		lda #$3a	                LDA #':'                ; then a colon
.1a73e7	20 18 00	jsr $1a0018	            JSR PRINTC
.1a73ea	c2 20		rep #$20	            REP #$20
.1a73ec	a5 32		lda $087a	                LDA MCURSOR
.1a73ee	20 26 03	jsr $1a0326	            JSR PRHEXW
.1a73f1	c2 20		rep #$20	            REP #$20
.1a73f3	a9 08 00	lda #$0008	                LDA #MMEMROWSIZE
.1a73f6	85 47		sta $088f	                STA MCOUNT
.1a73f8					prhex_loop
.1a73f8	e2 20		sep #$20	            SEP #$20
.1a73fa	a9 20		lda #$20	                LDA #' '
.1a73fc	20 18 00	jsr $1a0018	            JSR PRINTC
.1a73ff	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a7401	20 40 03	jsr $1a0340	            JSR PRHEXB
.1a7404	22 73 84 1a	jsl $1a8473	                JSL M_INC_CURSOR        ; Point MCURSOR to the next byte
.1a7408					check_line
.1a7408	e2 20		sep #$20	            SEP #$20
.1a740a	c6 47		dec $088f	                DEC MCOUNT              ; Count down the number of bytes on the row
.1a740c	d0 ea		bne $1a73f8	                BNE prhex_loop          ; If we're not at zero, keep looping over the bytes
.1a740e	a9 20		lda #$20	                LDA #' '
.1a7410	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7413	a9 20		lda #$20	                LDA #' '
.1a7415	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7418	08		php		            PHP
.1a7419	e2 20		sep #$20	            SEP #$20
.1a741b	48		pha		            PHA
.1a741c	a9 00		lda #$00	            LDA #`MLINEBUF
.1a741e	48		pha		            PHA
.1a741f	ab		plb		            PLB
.1a7420	68		pla		            PLA
.1a7421	28		plp		            PLP
.1a7422	a2 7e 08	ldx #$087e	                LDX #MLINEBUF
.1a7425	20 16 03	jsr $1a0316	            JSR PRINTS
.1a7428	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a742b	20 a0 02	jsr $1a02a0	            JSR PAGINATE
.1a742e	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.1a7430	c5 13		cmp $085b	                CMP MARG2+2
.1a7432	90 0f		bcc $1a7443	                BLT continue            ; No: continue
.1a7434	c2 20		rep #$20	            REP #$20
.1a7436	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.1a7438	c5 11		cmp $0859	                CMP MARG2
.1a743a	90 07		bcc $1a7443	                BLT continue            ; Nope... keep going
.1a743c					done
.1a743c	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a743f	2b		pld		                PLD
.1a7440	ab		plb		                PLB
.1a7441	28		plp		                PLP
.1a7442	6b		rtl		                RTL
.1a7443	4c 97 73	jmp $1a7397	continue        JMP dump_line
.1a7446					M_COPY_ARGB
.1a7446	08		php		                PHP
.1a7447	8d 92 08	sta $0892	                STA MTEMP
.1a744a	e2 20		sep #$20	            SEP #$20
.1a744c	bd 00 00	lda $0000,x	loop            LDA #0,B,X
.1a744f	99 00 00	sta $0000,y	                STA #0,B,Y      ; Copy the byte
.1a7452	ad 92 08	lda $0892	                LDA MTEMP       ; Check the count of characters remaining
.1a7455	f0 0a		beq $1a7461	                BEQ done        ; If it's 0, we're done
.1a7457	c8		iny		                INY             ; Point to the next destination byte
.1a7458	e8		inx		                INX             ; Point to the next source byte (skip three bytes)
.1a7459	e8		inx		                INX
.1a745a	e8		inx		                INX
.1a745b	e8		inx		                INX
.1a745c	ce 92 08	dec $0892	                DEC MTEMP       ; Count down and see if we're done
.1a745f	80 eb		bra $1a744c	                BRA loop
.1a7461	28		plp		done            PLP
.1a7462	6b		rtl		                RTL
.1a7463					IMMODIFY
.1a7463	08		php		                PHP
.1a7464	0b		phd		                PHD
.1a7465	8b		phb		                PHB
.1a7466	08		php		            PHP
.1a7467	c2 20		rep #$20	            REP #$20
.1a7469	48		pha		            PHA
.1a746a	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a746d	5b		tcd		            TCD
.1a746e	68		pla		            PLA
.1a746f	28		plp		            PLP
.1a7470	08		php		            PHP
.1a7471	e2 20		sep #$20	            SEP #$20
.1a7473	48		pha		            PHA
.1a7474	a9 00		lda #$00	            LDA #0
.1a7476	48		pha		            PHA
.1a7477	ab		plb		            PLB
.1a7478	68		pla		            PLA
.1a7479	28		plp		            PLP
.1a747a	c2 30		rep #$30	            REP #$30
.1a747c	a5 0d		lda $0855	                LDA MARG1           ; Set MCURSOR to MARG1
.1a747e	85 32		sta $087a	                STA MCURSOR
.1a7480	a5 0f		lda $0857	                LDA MARG1+2
.1a7482	85 34		sta $087c	                STA MCURSOR+2
.1a7484	e2 20		sep #$20	            SEP #$20
.1a7486	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.1a7488	3a		dec a		                DEC A               ; (MARG_LEN - 1)
.1a7489	85 47		sta $088f	                STA MCOUNT
.1a748b	a2 59 08	ldx #$0859	                LDX #<>MARG2        ; Copy MCOUNT bytes from MARG2..MARG9
.1a748e	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF     ; to MLINEBUF
.1a7491	22 46 74 1a	jsl $1a7446	                JSL M_COPY_ARGB
.1a7495	a0 00 00	ldy #$0000	                LDY #0
.1a7498	b9 7e 08	lda $087e,y	loop            LDA MLINEBUF,Y      ; Copy the byte from the buffer
.1a749b	87 32		sta [$087a]	                STA [MCURSOR]       ; To the address indicated by MCURSOR
.1a749d	22 73 84 1a	jsl $1a8473	                JSL M_INC_CURSOR    ; Advance the cursor
.1a74a1	c8		iny		                INY                 ; Go to the next buffered byte
.1a74a2	c4 47		cpy $088f	                CPY MCOUNT          ; Did we just write the last one?
.1a74a4	d0 f2		bne $1a7498	                BNE loop            ; No: continue writing
.1a74a6	ab		plb		                PLB
.1a74a7	2b		pld		                PLD
.1a74a8	28		plp		                PLP
.1a74a9	6b		rtl		                RTL
.1a74aa					IMHUNT
.1a74aa	08		php		                PHP
.1a74ab	0b		phd		                PHD
.1a74ac	8b		phb		                PHB
.1a74ad	08		php		            PHP
.1a74ae	c2 20		rep #$20	            REP #$20
.1a74b0	48		pha		            PHA
.1a74b1	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a74b4	5b		tcd		            TCD
.1a74b5	68		pla		            PLA
.1a74b6	28		plp		            PLP
.1a74b7	08		php		            PHP
.1a74b8	e2 20		sep #$20	            SEP #$20
.1a74ba	48		pha		            PHA
.1a74bb	a9 00		lda #$00	            LDA #0
.1a74bd	48		pha		            PHA
.1a74be	ab		plb		            PLB
.1a74bf	68		pla		            PLA
.1a74c0	28		plp		            PLP
.1a74c1	e2 20		sep #$20	            SEP #$20
.1a74c3	c2 10		rep #$10	            REP #$10
.1a74c5	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.1a74c7	3a		dec a		                DEC A               ; (MARG_LEN - 2)
.1a74c8	3a		dec a		                DEC A
.1a74c9	85 47		sta $088f	                STA MCOUNT
.1a74cb	a2 5d 08	ldx #$085d	                LDX #<>MARG3
.1a74ce	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF
.1a74d1	22 46 74 1a	jsl $1a7446	                JSL M_COPY_ARGB
.1a74d5	c2 20		rep #$20	            REP #$20
.1a74d7	a5 0d		lda $0855	                LDA MARG1           ; Copy starting address to MCURSOR
.1a74d9	85 32		sta $087a	                STA MCURSOR
.1a74db	a5 0f		lda $0857	                LDA MARG1+2
.1a74dd	85 34		sta $087c	                STA MCURSOR+2
.1a74df					outer_loop
.1a74df	c2 20		rep #$20	            REP #$20
.1a74e1	a5 34		lda $087c	                LDA MCURSOR+2      ; If MCURSOR < MARG2, we're not done yet
.1a74e3	c5 13		cmp $085b	                CMP MARG2+2
.1a74e5	d0 06		bne $1a74ed	                BNE not_done
.1a74e7	a5 32		lda $087a	                LDA MCURSOR
.1a74e9	c5 11		cmp $0859	                CMP MARG2
.1a74eb	f0 2c		beq $1a7519	                BEQ done            ; MCURSOR = MARG2: we're done
.1a74ed					not_done
.1a74ed	e2 20		sep #$20	            SEP #$20
.1a74ef	a0 00 00	ldy #$0000	                LDY #0
.1a74f2	b7 32		lda [$087a],y	cmp_loop        LDA [MCURSOR],Y     ; Get the byte from the memory to check
.1a74f4	d9 7e 08	cmp $087e,y	                CMP MLINEBUF,Y      ; Compare it against our pattern
.1a74f7	d0 1a		bne $1a7513	                BNE advance         ; If not equal, we need to move on
.1a74f9	c8		iny		                INY                 ; Otherwise do we have more bytes to check?
.1a74fa	c4 47		cpy $088f	                CPY MCOUNT
.1a74fc	d0 f4		bne $1a74f2	                BNE cmp_loop        ; No: check more
.1a74fe	c2 20		rep #$20	            REP #$20
.1a7500	a5 32		lda $087a	                LDA MCURSOR         ; Print the address
.1a7502	85 4a		sta $0892	                STA MTEMP
.1a7504	a5 34		lda $087c	                LDA MCURSOR+2
.1a7506	85 4c		sta $0894	                STA MTEMP+2
.1a7508	22 1d 7f 1a	jsl $1a7f1d	                JSL M_PR_ADDR
.1a750c	e2 20		sep #$20	            SEP #$20
.1a750e	a9 20		lda #$20	                LDA #' '
.1a7510	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7513	22 73 84 1a	jsl $1a8473	advance         JSL M_INC_CURSOR    ; Move MCURSOR forward by one
.1a7517	80 c6		bra $1a74df	                BRA outer_loop      ; And try to compare that to the pattern
.1a7519					done
.1a7519	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a751c	ab		plb		                PLB
.1a751d	2b		pld		                PLD
.1a751e	28		plp		                PLP
.1a751f	6b		rtl		                RTL
.1a7520					IMJUMP
.1a7520	08		php		            PHP
.1a7521	c2 20		rep #$20	            REP #$20
.1a7523	48		pha		            PHA
.1a7524	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a7527	5b		tcd		            TCD
.1a7528	68		pla		            PLA
.1a7529	28		plp		            PLP
.1a752a	e2 20		sep #$20	            SEP #$20
.1a752c	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.1a752e	f0 0e		beq $1a753e	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.1a7530	c2 30		rep #$30	            REP #$30
.1a7532	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.1a7534	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.1a7538	a5 0f		lda $0857	                LDA MARG1+2
.1a753a	8f 42 02 00	sta $000242	                STA @lCPUPBR
.1a753e	af 46 02 00	lda $000246	MJUMPRESTORE    LDA @lCPUX          ; Restore X and Y
.1a7542	aa		tax		                TAX
.1a7543	af 48 02 00	lda $000248	                LDA @lCPUY
.1a7547	a8		tay		                TAY
.1a7548	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.1a754c	1b		tcs		                TCS
.1a754d	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.1a7551	5b		tcd		                TCD
.1a7552	e2 20		sep #$20	            SEP #$20
.1a7554	a9 1a		lda #$1a	                LDA #`MJUMPSTART
.1a7556	48		pha		                PHA
.1a7557	a9 75		lda #$75	                LDA #>MJUMPSTART
.1a7559	48		pha		                PHA
.1a755a	a9 60		lda #$60	                LDA #<MJUMPSTART
.1a755c	48		pha		                PHA
.1a755d	4c 97 75	jmp $1a7597	                JMP MGOSTACK        ; And push remaining registers and restart execution
.1a7560	ea		nop		MJUMPSTART      NOP                 ; RTL increments PC pulled from stack, NOP leaves space for that
.1a7561	5c 04 00 1a	jmp $1a0004	                JML MONITOR
.1a7565					IMGO
.1a7565	08		php		            PHP
.1a7566	c2 20		rep #$20	            REP #$20
.1a7568	48		pha		            PHA
.1a7569	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a756c	5b		tcd		            TCD
.1a756d	68		pla		            PLA
.1a756e	28		plp		            PLP
.1a756f	e2 20		sep #$20	            SEP #$20
.1a7571	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.1a7573	f0 c9		beq $1a753e	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.1a7575	c2 30		rep #$30	            REP #$30
.1a7577	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.1a7579	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.1a757d	a5 0f		lda $0857	                LDA MARG1+2
.1a757f	8f 42 02 00	sta $000242	                STA @lCPUPBR
.1a7583	af 46 02 00	lda $000246	MGORESTORE      LDA @lCPUX          ; Restore X and Y
.1a7587	aa		tax		                TAX
.1a7588	af 48 02 00	lda $000248	                LDA @lCPUY
.1a758c	a8		tay		                TAY
.1a758d	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.1a7591	1b		tcs		                TCS
.1a7592	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.1a7596	5b		tcd		                TCD
.1a7597					MGOSTACK
.1a7597	e2 20		sep #$20	            SEP #$20
.1a7599	af 4e 02 00	lda $00024e	                LDA @lCPUDBR        ; Restore the data bank register
.1a759d	48		pha		                PHA
.1a759e	ab		plb		                PLB
.1a759f	a9 5c		lda #$5c	                LDA #$5C            ; Save the JSL opcode
.1a75a1	8f a2 08 00	sta $0008a2	                STA @lMJUMPINST
.1a75a5	af 42 02 00	lda $000242	                LDA @lCPUPBR        ; Write PBR
.1a75a9	8f a5 08 00	sta $0008a5	                STA @lMJUMPADDR+2
.1a75ad	af 41 02 00	lda $000241	                LDA @lCPUPC+1       ; Write PCH
.1a75b1	8f a4 08 00	sta $0008a4	                STA @lMJUMPADDR+1
.1a75b5	af 40 02 00	lda $000240	                LDA @lCPUPC         ; Write PCL
.1a75b9	8f a3 08 00	sta $0008a3	                STA @lMJUMPADDR
.1a75bd	af 4f 02 00	lda $00024f	                LDA @lCPUFLAGS      ; Push processor status
.1a75c1	48		pha		                PHA
.1a75c2	c2 20		rep #$20	            REP #$20
.1a75c4	af 44 02 00	lda $000244	                LDA @lCPUA          ; Restore A
.1a75c8	28		plp		                PLP                 ; And the status register
.1a75c9	5c a2 08 00	jmp $0008a2	                JML MJUMPINST       ; And jump to the target address
.1a75cd					IMCOMPARE
.1a75cd	08		php		                PHP
.1a75ce	0b		phd		                PHD
.1a75cf	8b		phb		                PHB
.1a75d0	08		php		            PHP
.1a75d1	e2 20		sep #$20	            SEP #$20
.1a75d3	48		pha		            PHA
.1a75d4	a9 1a		lda #$1a	            LDA #`MERRARGS
.1a75d6	48		pha		            PHA
.1a75d7	ab		plb		            PLB
.1a75d8	68		pla		            PLA
.1a75d9	28		plp		            PLP
.1a75da	08		php		            PHP
.1a75db	c2 20		rep #$20	            REP #$20
.1a75dd	48		pha		            PHA
.1a75de	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a75e1	5b		tcd		            TCD
.1a75e2	68		pla		            PLA
.1a75e3	28		plp		            PLP
.1a75e4	c2 10		rep #$10	            REP #$10
.1a75e6	e2 20		sep #$20	            SEP #$20
.1a75e8	a5 31		lda $0879	                LDA MARG_LEN                ; Check the number of arguments provided
.1a75ea	c9 02		cmp #$02	                CMP #2
.1a75ec	f0 0c		beq $1a75fa	                BEQ default_len             ; If 2: set MCOUNT to default of 1
.1a75ee	c9 03		cmp #$03	                CMP #3
.1a75f0	d0 11		bne $1a7603	                BNE bad_arguments           ; Otherwise, if not 3: print an error
.1a75f2	c2 20		rep #$20	            REP #$20
.1a75f4	a5 15		lda $085d	                LDA MARG3                   ; If 3: set MCOUNT to MARG3
.1a75f6	85 47		sta $088f	                STA MCOUNT
.1a75f8	80 11		bra $1a760b	                BRA compare
.1a75fa					default_len
.1a75fa	c2 20		rep #$20	            REP #$20
.1a75fc	a9 01 00	lda #$0001	                LDA #1                      ; No length was provided, set MCOUNT to 1
.1a75ff	85 47		sta $088f	                STA MCOUNT
.1a7601	80 08		bra $1a760b	                BRA compare
.1a7603	a2 3f 87	ldx #$873f	bad_arguments   LDX #<>MERRARGS             ; The wrong number of arguments was provided
.1a7606	20 16 03	jsr $1a0316	            JSR PRINTS
.1a7609	80 35		bra $1a7640	                BRA done
.1a760b	a5 0d		lda $0855	compare         LDA MARG1                   ; Set MTEMP to MARG1
.1a760d	85 4a		sta $0892	                STA MTEMP
.1a760f	a5 0f		lda $0857	                LDA MARG1+2
.1a7611	85 4c		sta $0894	                STA MTEMP+2
.1a7613	a0 00 00	ldy #$0000	                LDY #0
.1a7616					loop
.1a7616	e2 20		sep #$20	            SEP #$20
.1a7618	a7 4a		lda [$0892]	                LDA [MTEMP]                 ; Compare the byte at MTEMP
.1a761a	d7 11		cmp [$0859],y	                CMP [MARG2],Y               ; To the Yth byte from MARG2
.1a761c	f0 09		beq $1a7627	                BEQ continue                ; If they're the same, keep going
.1a761e	22 1d 7f 1a	jsl $1a7f1d	mismatch        JSL M_PR_ADDR               ; If they're different, print MTEMP
.1a7622	a9 20		lda #$20	                LDA #' '
.1a7624	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7627					continue
.1a7627	c2 20		rep #$20	            REP #$20
.1a7629	18		clc		                CLC                         ; Either way, increment MTEMP
.1a762a	a5 4a		lda $0892	                LDA MTEMP
.1a762c	69 01 00	adc #$0001	                ADC #1
.1a762f	85 4a		sta $0892	                STA MTEMP
.1a7631	a5 4c		lda $0894	                LDA MTEMP+2
.1a7633	69 00 00	adc #$0000	                ADC #0
.1a7636	85 4c		sta $0894	                STA MTEMP+2
.1a7638	c8		iny		                INY                         ; Increment Y
.1a7639	c4 47		cpy $088f	                CPY MCOUNT                  ; Try again unless we've checked MCOUNT bytes
.1a763b	d0 d9		bne $1a7616	                BNE loop
.1a763d	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a7640					done
.1a7640	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a7643	ab		plb		                PLB
.1a7644	2b		pld		                PLD
.1a7645	28		plp		                PLP
.1a7646	6b		rtl		                RTL
.1a7647					IMRMODIFY
.1a7647	08		php		                PHP
.1a7648	0b		phd		                PHD
.1a7649	8b		phb		                PHB
.1a764a	08		php		            PHP
.1a764b	e2 20		sep #$20	            SEP #$20
.1a764d	48		pha		            PHA
.1a764e	a9 00		lda #$00	            LDA #0
.1a7650	48		pha		            PHA
.1a7651	ab		plb		            PLB
.1a7652	68		pla		            PLA
.1a7653	28		plp		            PLP
.1a7654	08		php		            PHP
.1a7655	c2 20		rep #$20	            REP #$20
.1a7657	48		pha		            PHA
.1a7658	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a765b	5b		tcd		            TCD
.1a765c	68		pla		            PLA
.1a765d	28		plp		            PLP
.1a765e	e2 20		sep #$20	            SEP #$20
.1a7660	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.1a7662	f0 4f		beq $1a76b3	                BEQ done            ; 0? Just quit
.1a7664	a6 0d		ldx $0855	                LDX MARG1           ; Set the PC and PBR
.1a7666	8e 40 02	stx $0240	                STX #CPUPC,B
.1a7669	a6 0f		ldx $0857	                LDX MARG1+2
.1a766b	8e 42 02	stx $0242	                STX #CPUPBR,B
.1a766e	c9 01		cmp #$01	                CMP #1              ; Check the number of arguments
.1a7670	f0 41		beq $1a76b3	                BEQ done            ; 1? Just quit
.1a7672	a6 11		ldx $0859	                LDX MARG2           ; Set A
.1a7674	8e 44 02	stx $0244	                STX #CPUA,B
.1a7677	c9 02		cmp #$02	                CMP #2              ; Check the number of arguments
.1a7679	f0 38		beq $1a76b3	                BEQ done            ; 2? Just quit
.1a767b	a6 15		ldx $085d	                LDX MARG3           ; Set X
.1a767d	8e 46 02	stx $0246	                STX #CPUX,B
.1a7680	c9 03		cmp #$03	                CMP #3              ; Check the number of arguments
.1a7682	f0 2f		beq $1a76b3	                BEQ done            ; 3? Just quit
.1a7684	a6 19		ldx $0861	                LDX MARG4           ; Set Y
.1a7686	8e 48 02	stx $0248	                STX #CPUY,B
.1a7689	c9 04		cmp #$04	                CMP #4              ; Check the number of arguments
.1a768b	f0 26		beq $1a76b3	                BEQ done            ; 4? Just quit
.1a768d	a6 1d		ldx $0865	                LDX MARG5           ; Set SP
.1a768f	8e 4a 02	stx $024a	                STX #CPUSTACK,B
.1a7692	c9 05		cmp #$05	                CMP #5              ; Check the number of arguments
.1a7694	f0 1d		beq $1a76b3	                BEQ done            ; 5? Just quit
.1a7696	e2 10		sep #$10	            SEP #$10
.1a7698	a6 21		ldx $0869	                LDX MARG6           ; Set DBR
.1a769a	8e 4e 02	stx $024e	                STX #CPUDBR,B
.1a769d	c9 06		cmp #$06	                CMP #6              ; Check the number of arguments
.1a769f	f0 12		beq $1a76b3	                BEQ done            ; 6? Just quit
.1a76a1	c2 10		rep #$10	            REP #$10
.1a76a3	a6 25		ldx $086d	                LDX MARG7           ; Set DP
.1a76a5	8e 4c 02	stx $024c	                STX #CPUDP,B
.1a76a8	c9 07		cmp #$07	                CMP #7              ; Check the number of arguments
.1a76aa	f0 07		beq $1a76b3	                BEQ done            ; 7? Just quit
.1a76ac	e2 10		sep #$10	            SEP #$10
.1a76ae	a6 29		ldx $0871	                LDX MARG8           ; Set flags
.1a76b0	8e 4f 02	stx $024f	                STX #CPUFLAGS,B
.1a76b3	ab		plb		done            PLB
.1a76b4	2b		pld		                PLD
.1a76b5	28		plp		                PLP
.1a76b6	6b		rtl		                RTL
.1a76b7					IMEXECUTE
.1a76b7	08		php		                PHP
.1a76b8	0b		phd		                PHD
.1a76b9	8b		phb		                PHB
.1a76ba	08		php		            PHP
.1a76bb	c2 20		rep #$20	            REP #$20
.1a76bd	48		pha		            PHA
.1a76be	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a76c1	5b		tcd		            TCD
.1a76c2	68		pla		            PLA
.1a76c3	28		plp		            PLP
.1a76c4	e2 20		sep #$20	            SEP #$20
.1a76c6	c2 10		rep #$10	            REP #$10
.1a76c8	a2 00 00	ldx #$0000	                LDX #0
.1a76cb	bf ac 87 1a	lda $1a87ac,x	loop            LDA @lMCOMMANDS,X
.1a76cf	f0 18		beq $1a76e9	                BEQ done
.1a76d1	c7 08		cmp [$0850]	                CMP [MCMD]
.1a76d3	f0 03		beq $1a76d8	                BEQ found
.1a76d5	e8		inx		                INX
.1a76d6	80 f3		bra $1a76cb	                BRA loop
.1a76d8					found
.1a76d8	c2 20		rep #$20	            REP #$20
.1a76da	8a		txa		                TXA
.1a76db	0a		asl a		                ASL A
.1a76dc	aa		tax		                TAX
.1a76dd	bf ed 76 1a	lda $1a76ed,x	                LDA dispatch,X
.1a76e1	8f 2f 08 00	sta $00082f	                STA @lJMP16PTR
.1a76e5	22 11 77 1a	jsl $1a7711	                JSL MDOCMD
.1a76e9	ab		plb		done            PLB
.1a76ea	2b		pld		                PLD
.1a76eb	28		plp		                PLP
.1a76ec	6b		rtl		                RTL
>1a76ed	8a 6d				dispatch        .word <>MASSEMBLE
>1a76ef	92 6d				                .word <>MCOMPARE
>1a76f1	96 6d				                .word <>MDISASSEMBLE
>1a76f3	9a 6d				                .word <>MFILL
>1a76f5	9e 6d				                .word <>MGO
>1a76f7	a2 6d				                .word <>MJUMP
>1a76f9	a6 6d				                .word <>MHUNT
>1a76fb	aa 6d				                .word <>MLOAD
>1a76fd	ae 6d				                .word <>MMEMORY
>1a76ff	b2 6d				                .word <>MREGISTERS
>1a7701	8e 6d				                .word <>MRMODIFY
>1a7703	b6 6d				                .word <>MSAVE
>1a7705	ba 6d				                .word <>MTRANSFER
>1a7707	be 6d				                .word <>MVERIFY
>1a7709	86 71				                .word <>IMWIDTH
>1a770b	c2 6d				                .word <>MEXIT
>1a770d	c6 6d				                .word <>MMODIFY
>1a770f	ff 6d				                .word <>IMHELP
.1a7711					MDOCMD
.1a7711	6c 2f 08	jmp ($082f)	                JMP (JMP16PTR)

;******  Processing file: src\assembler.s

=0					ADDR_DP_IND_X = 0       ; (dd,X)
=1					ADDR_DP = 1             ; dd
=2					ADDR_IMM = 2            ; #dd
=3					ADDR_ABS = 3            ; dddd
=4					ADDR_DP_IND_Y = 4       ; (dd),Y
=5					ADDR_DP_X = 5           ; dd,X
=6					ADDR_ABS_Y = 6          ; dddd,Y
=7					ADDR_ABS_X = 7          ; dddd,X
=8					ADDR_ACC = 8            ; A
=9					ADDR_SP_R = 9           ; #d,S
=10					ADDR_DP_LONG = 10       ; [dd]
=11					ADDR_ABS_LONG = 11      ; dddddd
=12					ADDR_SP_R_Y = 12        ; #dd,S,Y
=13					ADDR_DP_Y_LONG = 13     ; [dd],Y
=14					ADDR_ABS_X_LONG = 14    ; dddddd,X
=15					ADDR_DP_IND = 15        ; (dd)
=16					ADDR_ABS_X_ID = 16      ; (dddd,X)
=17					ADDR_DP_Y = 17          ; dd,Y
=18					ADDR_PC_REL = 18        ; PC relative
=19					ADDR_IMPLIED = 19       ; Implied (no operand)
=20					ADDR_XYC = 20           ; #dd, #dd
=21					ADDR_ABS_IND = 21       ; (dddd)
=22					ADDR_PC_REL_LONG = 22   ; PC relative ()
=23					ADDR_ABS_IND_LONG = 23  ; [dddd]
=$80					OP_M_EFFECT = $80       ; Flag to indicate instruction is modified by M
=$40					OP_X_EFFECT = $40       ; Flag to indicate instruction is modified by X
.1a7714					IMASSEMBLE
.1a7714	08		php		                PHP
.1a7715	8b		phb		                PHB
.1a7716	0b		phd		                PHD
.1a7717	08		php		            PHP
.1a7718	c2 20		rep #$20	            REP #$20
.1a771a	48		pha		            PHA
.1a771b	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a771e	5b		tcd		            TCD
.1a771f	68		pla		            PLA
.1a7720	28		plp		            PLP
.1a7721	e2 20		sep #$20	            SEP #$20
.1a7723	a5 31		lda $0879	                LDA MARG_LEN            ; Do we have at least 2 arguments?
.1a7725	c9 02		cmp #$02	                CMP #2
.1a7727	b0 03		bcs $1a772c	                BGE has_args            ; Yes: try to assemble the line
.1a7729	4c ba 78	jmp $1a78ba	                JMP done                ; No: just return
.1a772c					has_args
.1a772c	c2 20		rep #$20	            REP #$20
.1a772e	a5 0d		lda $0855	                LDA MARG1               ; Set the monitor cursor to the address
.1a7730	85 32		sta $087a	                STA MCURSOR
.1a7732	a5 0f		lda $0857	                LDA MARG1+2
.1a7734	85 34		sta $087c	                STA MCURSOR+2
.1a7736	c2 20		rep #$20	            REP #$20
.1a7738	22 bc 7a 1a	jsl $1a7abc	                JSL AS_FIND_MNEMO       ; Find the address of the mnemonic
.1a773c	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.1a773f	f0 10		beq $1a7751	                BEQ bad_mnemonic        ; If not found, print bad mnemonic error message
.1a7741	85 54		sta $089c	                STA MMNEMONIC
.1a7743	e2 20		sep #$20	            SEP #$20
.1a7745	a5 31		lda $0879	                LDA MARG_LEN            ; Check the number of arguments passed
.1a7747	c9 03		cmp #$03	                CMP #3                  ; Were all three arguments provided?
.1a7749	f0 36		beq $1a7781	                BEQ get_operand         ; Yes: parse the operand
.1a774b	a9 13		lda #$13	                LDA #ADDR_IMPLIED       ; No: assume address mode is implied
.1a774d	85 4f		sta $0897	                STA MADDR_MODE
.1a774f	80 4c		bra $1a779d	                BRA get_opcode
.1a7751					bad_mnemonic
.1a7751	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a7754	08		php		            PHP
.1a7755	e2 20		sep #$20	            SEP #$20
.1a7757	48		pha		            PHA
.1a7758	a9 1a		lda #$1a	            LDA #`MERRBADMNEMO
.1a775a	48		pha		            PHA
.1a775b	ab		plb		            PLB
.1a775c	68		pla		            PLA
.1a775d	28		plp		            PLP
.1a775e	c2 10		rep #$10	            REP #$10
.1a7760	a2 f1 78	ldx #$78f1	                LDX #<>MERRBADMNEMO
.1a7763	20 16 03	jsr $1a0316	            JSR PRINTS
.1a7766	4c ba 78	jmp $1a78ba	                JMP done
.1a7769					bad_operand
.1a7769	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a776c	08		php		            PHP
.1a776d	e2 20		sep #$20	            SEP #$20
.1a776f	48		pha		            PHA
.1a7770	a9 1a		lda #$1a	            LDA #`MERRBADOPER
.1a7772	48		pha		            PHA
.1a7773	ab		plb		            PLB
.1a7774	68		pla		            PLA
.1a7775	28		plp		            PLP
.1a7776	c2 10		rep #$10	            REP #$10
.1a7778	a2 00 79	ldx #$7900	                LDX #<>MERRBADOPER
.1a777b	20 16 03	jsr $1a0316	            JSR PRINTS
.1a777e	4c ba 78	jmp $1a78ba	                JMP done
.1a7781					get_operand
.1a7781	e2 20		sep #$20	            SEP #$20
.1a7783	22 f2 7a 1a	jsl $1a7af2	                JSL AS_FIND_MODE        ; Find the addressing mode of the operand
.1a7787	c9 ff		cmp #$ff	compare         CMP #$FF
.1a7789	f0 de		beq $1a7769	                BEQ bad_operand         ; If not found, print bad operand error message
.1a778b	85 4f		sta $0897	                STA MADDR_MODE
.1a778d	c9 03		cmp #$03	                CMP #ADDR_ABS           ; If mode is absolute or absolute long...
.1a778f	f0 62		beq $1a77f3	                BEQ check_for_pcrel     ; Check to see if the mnemonic is one of the branches
.1a7791	c9 0b		cmp #$0b	                CMP #ADDR_ABS_LONG
.1a7793	f0 5e		beq $1a77f3	                BEQ check_for_pcrel
.1a7795	c9 13		cmp #$13	                CMP #ADDR_IMPLIED       ; If mode is implied or accumulator, get the opcode
.1a7797	f0 04		beq $1a779d	                BEQ get_opcode
.1a7799	c9 08		cmp #$08	                CMP #ADDR_ACC
.1a779b	f0 00		beq $1a779d	                BEQ get_opcode
.1a779d	22 ea 79 1a	jsl $1a79ea	get_opcode      JSL AS_FIND_OPCODE      ; Find the opcode matching the two
.1a77a1	b0 03		bcs $1a77a6	                BCS save_opcode
.1a77a3	4c 83 78	jmp $1a7883	                JMP bad_mode            ; If opcode not found, print bad address mode error message
.1a77a6	87 32		sta [$087a]	save_opcode     STA [MCURSOR]           ; Write the opcode to the address
.1a77a8	22 73 84 1a	jsl $1a8473	                JSL M_INC_CURSOR        ; And point to the next byte
.1a77ac	08		php		            PHP
.1a77ad	e2 20		sep #$20	            SEP #$20
.1a77af	48		pha		            PHA
.1a77b0	a9 00		lda #$00	            LDA #0
.1a77b2	48		pha		            PHA
.1a77b3	ab		plb		            PLB
.1a77b4	68		pla		            PLA
.1a77b5	28		plp		            PLP
.1a77b6	c2 20		rep #$20	            REP #$20
.1a77b8	a5 32		lda $087a	                LDA MCURSOR             ; Make MTEMPPTR a pointer to the machine code we're assembling
.1a77ba	85 56		sta $089e	                STA MTEMPPTR
.1a77bc	a5 34		lda $087c	                LDA MCURSOR+2
.1a77be	85 58		sta $08a0	                STA MTEMPPTR+2
.1a77c0	e2 20		sep #$20	            SEP #$20
.1a77c2	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check the address mode again
.1a77c4	c9 12		cmp #$12	                CMP #ADDR_PC_REL        ; If it's PC relative
.1a77c6	f0 6c		beq $1a7834	                BEQ compute_rel         ; Convert the address to an offset
.1a77c8	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.1a77ca	f0 68		beq $1a7834	                BEQ compute_rel
.1a77cc	c9 14		cmp #$14	                CMP #ADDR_XYC           ; MVP/MVN addressing mode?
.1a77ce	f0 7c		beq $1a784c	                BEQ emit_2
.1a77d0	29 3f		and #$3f	                AND #%00111111          ; Filter out the mode bits
.1a77d2	c9 02		cmp #$02	                CMP #ADDR_IMM           ; Is it immediate?
.1a77d4	d0 03		bne $1a77d9	                BNE fixed_length        ; Yes: emit it as an immediate (variable length)
.1a77d6	4c b1 78	jmp $1a78b1	                JMP emit_imm
.1a77d9					fixed_length
.1a77d9	c2 20		rep #$20	            REP #$20
.1a77db	29 ff 00	and #$00ff	                AND #$00FF
.1a77de	aa		tax		                TAX
.1a77df	e2 20		sep #$20	            SEP #$20
.1a77e1	bf b9 83 1a	lda $1a83b9,x	get_length      LDA ADDR_LENGTH,X       ; Get the number of bytes in the addressing mode
.1a77e5	c9 03		cmp #$03	                CMP #$03
.1a77e7	f0 57		beq $1a7840	                BEQ emit_3
.1a77e9	c9 02		cmp #$02	                CMP #$02
.1a77eb	f0 5f		beq $1a784c	                BEQ emit_2
.1a77ed	c9 01		cmp #$01	                CMP #$01
.1a77ef	f0 67		beq $1a7858	                BEQ emit_1
.1a77f1	80 71		bra $1a7864	                BRA next_line
.1a77f3					check_for_pcrel
.1a77f3	c2 20		rep #$20	            REP #$20
.1a77f5	a5 54		lda $089c	                LDA MMNEMONIC
.1a77f7	c9 31 80	cmp #$8031	                CMP #<>MN_BRA
.1a77fa	f0 26		beq $1a7822	                BEQ is_pcrel
.1a77fc	c9 95 80	cmp #$8095	                CMP #<>MN_BRL
.1a77ff	f0 2a		beq $1a782b	                BEQ is_pcrel_long
.1a7801	c9 15 80	cmp #$8015	                CMP #<>MN_BCC
.1a7804	f0 1c		beq $1a7822	                BEQ is_pcrel
.1a7806	c9 19 80	cmp #$8019	                CMP #<>MN_BCS
.1a7809	f0 17		beq $1a7822	                BEQ is_pcrel
.1a780b	c9 21 80	cmp #$8021	                CMP #<>MN_BEQ
.1a780e	f0 12		beq $1a7822	                BEQ is_pcrel
.1a7810	c9 09 80	cmp #$8009	                CMP #<>MN_BMI
.1a7813	f0 0d		beq $1a7822	                BEQ is_pcrel
.1a7815	c9 1d 80	cmp #$801d	                CMP #<>MN_BNE
.1a7818	f0 08		beq $1a7822	                BEQ is_pcrel
.1a781a	c9 05 80	cmp #$8005	                CMP #<>MN_BPL
.1a781d	f0 03		beq $1a7822	                BEQ is_pcrel
.1a781f	4c 9d 77	jmp $1a779d	                JMP get_opcode
.1a7822					is_pcrel
.1a7822	e2 20		sep #$20	            SEP #$20
.1a7824	a9 12		lda #$12	                LDA #ADDR_PC_REL
.1a7826	85 4f		sta $0897	                STA MADDR_MODE
.1a7828	4c 9d 77	jmp $1a779d	                JMP get_opcode
.1a782b					is_pcrel_long
.1a782b	e2 20		sep #$20	            SEP #$20
.1a782d	a9 16		lda #$16	                LDA #ADDR_PC_REL_LONG
.1a782f	85 4f		sta $0897	                STA MADDR_MODE
.1a7831	4c 9d 77	jmp $1a779d	                JMP get_opcode
.1a7834	22 2d 79 1a	jsl $1a792d	compute_rel     JSL AS_PC_OFFSET        ; Try to compute the offset
.1a7838	90 60		bcc $1a789a	                BCC bad_offset          ; If failed, it's a bad offset operand
.1a783a	c9 02		cmp #$02	emit_rel        CMP #$02                ; If the offset is two bytes
.1a783c	f0 0e		beq $1a784c	                BEQ emit_2              ; Emit those two bytes
.1a783e	80 18		bra $1a7858	                BRA emit_1              ; Otherwise emit just the one
.1a7840	a0 02 00	ldy #$0002	emit_3          LDY #2                  ; Write bank byte of operand
.1a7843	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.1a7846	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.1a7848	22 73 84 1a	jsl $1a8473	                JSL M_INC_CURSOR
.1a784c	a0 01 00	ldy #$0001	emit_2          LDY #1                  ; Write high byte of operand
.1a784f	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.1a7852	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.1a7854	22 73 84 1a	jsl $1a8473	                JSL M_INC_CURSOR
.1a7858	a0 00 00	ldy #$0000	emit_1          LDY #0                  ; Write low byte of operand
.1a785b	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.1a785e	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.1a7860	22 73 84 1a	jsl $1a8473	                JSL M_INC_CURSOR
.1a7864					next_line
.1a7864	e2 20		sep #$20	            SEP #$20
.1a7866	a9 41		lda #$41	                LDA #'A'
.1a7868	20 18 00	jsr $1a0018	            JSR PRINTC
.1a786b	a9 20		lda #$20	                LDA #' '
.1a786d	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7870	a6 32		ldx $087a	                LDX MCURSOR
.1a7872	86 4a		stx $0892	                STX MTEMP
.1a7874	a6 34		ldx $087c	                LDX MCURSOR+2
.1a7876	86 4c		stx $0894	                STX MTEMP+2
.1a7878	22 1d 7f 1a	jsl $1a7f1d	                JSL M_PR_ADDR
.1a787c	a9 20		lda #$20	                LDA #' '
.1a787e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7881	80 37		bra $1a78ba	                BRA done
.1a7883					bad_mode
.1a7883	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a7886	08		php		            PHP
.1a7887	e2 20		sep #$20	            SEP #$20
.1a7889	48		pha		            PHA
.1a788a	a9 1a		lda #$1a	            LDA #`MERRBADMODE
.1a788c	48		pha		            PHA
.1a788d	ab		plb		            PLB
.1a788e	68		pla		            PLA
.1a788f	28		plp		            PLP
.1a7890	c2 10		rep #$10	            REP #$10
.1a7892	a2 be 78	ldx #$78be	                LDX #<>MERRBADMODE
.1a7895	20 16 03	jsr $1a0316	            JSR PRINTS
.1a7898	80 20		bra $1a78ba	                BRA done
.1a789a					bad_offset
.1a789a	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a789d	08		php		            PHP
.1a789e	e2 20		sep #$20	            SEP #$20
.1a78a0	48		pha		            PHA
.1a78a1	a9 1a		lda #$1a	            LDA #`MERRBADOFFSET
.1a78a3	48		pha		            PHA
.1a78a4	ab		plb		            PLB
.1a78a5	68		pla		            PLA
.1a78a6	28		plp		            PLP
.1a78a7	c2 10		rep #$10	            REP #$10
.1a78a9	a2 0e 79	ldx #$790e	                LDX #<>MERRBADOFFSET
.1a78ac	20 16 03	jsr $1a0316	            JSR PRINTS
.1a78af	80 09		bra $1a78ba	                BRA done
.1a78b1	a5 4f		lda $0897	emit_imm        LDA MADDR_MODE          ; Check to see if long immediate was used
.1a78b3	29 c0		and #$c0	                AND #%11000000
.1a78b5	d0 95		bne $1a784c	                BNE emit_2              ; Yes: emit two bytes
.1a78b7	4c 58 78	jmp $1a7858	                JMP emit_1              ; No: emit one byte
.1a78ba	2b		pld		done            PLD
.1a78bb	ab		plb		                PLB
.1a78bc	28		plp		                PLP
.1a78bd	6b		rtl		                RTL
>1a78be	41 64 64 72 65 73 73 69		MERRBADMODE     .null "Addressing mode not defined for that instruction.",CHAR_CR
>1a78c6	6e 67 20 6d 6f 64 65 20 6e 6f 74 20 64 65 66 69
>1a78d6	6e 65 64 20 66 6f 72 20 74 68 61 74 20 69 6e 73
>1a78e6	74 72 75 63 74 69 6f 6e 2e 0d 00
>1a78f1	42 61 64 20 6d 6e 65 6d		MERRBADMNEMO    .null "Bad mnemonic.",CHAR_CR
>1a78f9	6f 6e 69 63 2e 0d 00
>1a7900	42 61 64 20 6f 70 65 72		MERRBADOPER     .null "Bad operand.",CHAR_CR
>1a7908	61 6e 64 2e 0d 00
>1a790e	52 65 6c 61 74 69 76 65		MERRBADOFFSET   .null "Relative offset is too large.",CHAR_CR
>1a7916	20 6f 66 66 73 65 74 20 69 73 20 74 6f 6f 20 6c
>1a7926	61 72 67 65 2e 0d 00
.1a792d					AS_PC_OFFSET
.1a792d	08		php		                PHP
.1a792e	0b		phd		                PHD
.1a792f	08		php		            PHP
.1a7930	c2 20		rep #$20	            REP #$20
.1a7932	48		pha		            PHA
.1a7933	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7936	5b		tcd		            TCD
.1a7937	68		pla		            PLA
.1a7938	28		plp		            PLP
.1a7939	e2 20		sep #$20	            SEP #$20
.1a793b	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check to see if it 1 byte or 2 byte relative
.1a793d	c9 12		cmp #$12	                CMP #ADDR_PC_REL
.1a793f	f0 0a		beq $1a794b	                BEQ is_short
.1a7941	c2 20		rep #$20	            REP #$20
.1a7943	18		clc		                CLC                     ; Branch is long. Compute where MCURSOR will be
.1a7944	a5 32		lda $087a	                LDA MCURSOR             ; with two branch offset bytes
.1a7946	69 02 00	adc #$0002	                ADC #2
.1a7949	80 08		bra $1a7953	                BRA compute_cursor
.1a794b					is_short
.1a794b	c2 20		rep #$20	            REP #$20
.1a794d	18		clc		                CLC                     ; Branch is short. Computer where MCURSOR will be
.1a794e	a5 32		lda $087a	                LDA MCURSOR             ; with one branch offset byte
.1a7950	69 01 00	adc #$0001	                ADC #1
.1a7953	85 4a		sta $0892	compute_cursor  STA MTEMP
.1a7955	a5 34		lda $087c	                LDA MCURSOR+2
.1a7957	69 00 00	adc #$0000	                ADC #0
.1a795a	85 4c		sta $0894	                STA MTEMP+2
.1a795c	38		sec		                SEC                     ; MPARSEDNUM = MPARSEDNUM - MTEMP (MCURSOR after the instruction)
.1a795d	a5 50		lda $0898	                LDA MPARSEDNUM
.1a795f	e5 4a		sbc $0892	                SBC MTEMP
.1a7961	85 50		sta $0898	                STA MPARSEDNUM
.1a7963	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a7965	e5 4c		sbc $0894	                SBC MTEMP+2
.1a7967	85 52		sta $089a	                STA MPARSEDNUM+2
.1a7969	e2 20		sep #$20	            SEP #$20
.1a796b	a5 4f		lda $0897	                LDA MADDR_MODE
.1a796d	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.1a796f	f0 1e		beq $1a798f	                BEQ check_long
.1a7971	a5 50		lda $0898	                LDA MPARSEDNUM          ; Short offset... check if it's negative
.1a7973	30 0c		bmi $1a7981	                BMI check_short_neg
.1a7975	a5 51		lda $0899	                LDA MPARSEDNUM+1        ; Positive short offset... upper two bytes
.1a7977	d0 2a		bne $1a79a3	                BNE failure             ; Must be 0 or it's an overflow
.1a7979	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a797b	d0 26		bne $1a79a3	                BNE failure
.1a797d	a9 01		lda #$01	                LDA #1                  ; Short offset is 1 byte
.1a797f	80 26		bra $1a79a7	                BRA success
.1a7981	a5 51		lda $0899	check_short_neg LDA MPARSEDNUM+1        ; Negative short offset... upper two bytes
.1a7983	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's an  overflow
.1a7985	d0 1c		bne $1a79a3	                BNE failure
.1a7987	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a7989	c9 ff		cmp #$ff	                CMP #$FF
.1a798b	d0 16		bne $1a79a3	                BNE failure
.1a798d	80 18		bra $1a79a7	                BRA success
.1a798f	a5 51		lda $0899	check_long      LDA MPARSEDNUM+1        ; Long offset... check if it's negative
.1a7991	30 06		bmi $1a7999	                BMI check_long_neg
.1a7993	a5 52		lda $089a	                LDA MPARSEDNUM+2        ; Positive long offset... upper byte
.1a7995	d0 0c		bne $1a79a3	                BNE failure             ; Must be 0 or it's an overflow
.1a7997	80 0e		bra $1a79a7	                BRA success
.1a7999	a5 52		lda $089a	check_long_neg  LDA MPARSEDNUM+2        ; Negative offset... upper two bytes
.1a799b	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's and overflow
.1a799d	d0 04		bne $1a79a3	                BNE failure
.1a799f	a9 02		lda #$02	                LDA #2                  ; Long offset is 2 bytes
.1a79a1	80 04		bra $1a79a7	                BRA success
.1a79a3	2b		pld		failure         PLD
.1a79a4	28		plp		                PLP
.1a79a5	18		clc		                CLC
.1a79a6	6b		rtl		                RTL
.1a79a7	2b		pld		success         PLD
.1a79a8	28		plp		                PLP
.1a79a9	38		sec		                SEC
.1a79aa	6b		rtl		                RTL
.1a79ab					AS_SHIFT_HEX
.1a79ab	08		php		                PHP
.1a79ac	0b		phd		                PHD
.1a79ad	c2 10		rep #$10	            REP #$10
.1a79af	da		phx		                PHX
.1a79b0	08		php		            PHP
.1a79b1	c2 20		rep #$20	            REP #$20
.1a79b3	48		pha		            PHA
.1a79b4	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a79b7	5b		tcd		            TCD
.1a79b8	68		pla		            PLA
.1a79b9	28		plp		            PLP
.1a79ba	e2 20		sep #$20	            SEP #$20
.1a79bc	a2 00 00	ldx #$0000	                LDX #0
.1a79bf	df 00 d0 1a	cmp $1ad000,x	seek_loop       CMP @lHEXDIGITS,X   ; Check the passed character against the hex digits
.1a79c3	f0 08		beq $1a79cd	                BEQ found
.1a79c5	e8		inx		                INX                 ; Go to the next hex digit
.1a79c6	e0 10 00	cpx #$0010	                CPX #$10            ; Are we out of digits?
.1a79c9	f0 1b		beq $1a79e6	                BEQ done            ; Yes... just return
.1a79cb	80 f2		bra $1a79bf	                BRA seek_loop
.1a79cd					found
.1a79cd	c2 20		rep #$20	            REP #$20
.1a79cf	06 50		asl $0898	                ASL MPARSEDNUM
.1a79d1	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a79d3	06 50		asl $0898	                ASL MPARSEDNUM
.1a79d5	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a79d7	06 50		asl $0898	                ASL MPARSEDNUM
.1a79d9	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a79db	06 50		asl $0898	                ASL MPARSEDNUM
.1a79dd	26 52		rol $089a	                ROL MPARSEDNUM+2
.1a79df	e2 20		sep #$20	            SEP #$20
.1a79e1	8a		txa		                TXA
.1a79e2	05 50		ora $0898	                ORA MPARSEDNUM
.1a79e4	85 50		sta $0898	                STA MPARSEDNUM
.1a79e6	fa		plx		done            PLX
.1a79e7	2b		pld		                PLD
.1a79e8	28		plp		                PLP
.1a79e9	6b		rtl		                RTL
.1a79ea					AS_FIND_OPCODE
.1a79ea	0b		phd		                PHD
.1a79eb	8b		phb		                PHB
.1a79ec	08		php		            PHP
.1a79ed	c2 20		rep #$20	            REP #$20
.1a79ef	48		pha		            PHA
.1a79f0	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a79f3	5b		tcd		            TCD
.1a79f4	68		pla		            PLA
.1a79f5	28		plp		            PLP
.1a79f6	08		php		            PHP
.1a79f7	e2 20		sep #$20	            SEP #$20
.1a79f9	48		pha		            PHA
.1a79fa	a9 1a		lda #$1a	            LDA #`MNEMONIC_TAB
.1a79fc	48		pha		            PHA
.1a79fd	ab		plb		            PLB
.1a79fe	68		pla		            PLA
.1a79ff	28		plp		            PLP
.1a7a00	e2 20		sep #$20	            SEP #$20
.1a7a02	a5 4f		lda $0897	                LDA MADDR_MODE
.1a7a04	29 3f		and #$3f	                AND #%00111111
.1a7a06	85 4a		sta $0892	                STA MTEMP
.1a7a08	c2 30		rep #$30	            REP #$30
.1a7a0a	a2 00 00	ldx #$0000	                LDX #0
.1a7a0d	a0 00 00	ldy #$0000	                LDY #0
.1a7a10	bd b7 80	lda $1a80b7,x	mnemonic_loop   LDA MNEMONIC_TAB,X      ; Get the mnemonic from the opcode table
.1a7a13	f0 1b		beq $1a7a30	                BEQ not_found           ; If it's 0, we did not find the mnemonic
.1a7a15	c5 54		cmp $089c	                CMP MMNEMONIC           ; Does it match the passed mnemonic?
.1a7a17	d0 0d		bne $1a7a26	                BNE next_opcode         ; No: go to the next opcode
.1a7a19					check_mode
.1a7a19	e2 20		sep #$20	            SEP #$20
.1a7a1b	b9 b9 82	lda $1a82b9,y	                LDA ADDRESS_TAB,Y       ; Get the corresponding address mode
.1a7a1e	29 3f		and #$3f	                AND #%00111111          ; Filter out effect bits
.1a7a20	c5 4a		cmp $0892	                CMP MTEMP
.1a7a22	f0 07		beq $1a7a2b	                BEQ found               ; Yes: we found the opcode
.1a7a24	c2 20		rep #$20	            REP #$20
.1a7a26	e8		inx		next_opcode     INX                     ; Point to the next mnemonic in the table
.1a7a27	e8		inx		                INX
.1a7a28	c8		iny		                INY
.1a7a29	80 e5		bra $1a7a10	                BRA mnemonic_loop       ; And check it
.1a7a2b	98		tya		found           TYA
.1a7a2c	38		sec		                SEC                     ; Set carry to show success
.1a7a2d	ab		plb		                PLB
.1a7a2e	2b		pld		                PLD
.1a7a2f	6b		rtl		                RTL
.1a7a30	18		clc		not_found       CLC                     ; Clear carry to show failure
.1a7a31	ab		plb		                PLB
.1a7a32	2b		pld		                PLD
.1a7a33	6b		rtl		                RTL
.1a7a34					AS_STR_MATCH
.1a7a34	08		php		                PHP
.1a7a35	0b		phd		                PHD
.1a7a36	08		php		            PHP
.1a7a37	c2 20		rep #$20	            REP #$20
.1a7a39	48		pha		            PHA
.1a7a3a	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7a3d	5b		tcd		            TCD
.1a7a3e	68		pla		            PLA
.1a7a3f	28		plp		            PLP
.1a7a40	e2 20		sep #$20	            SEP #$20
.1a7a42	c2 10		rep #$10	            REP #$10
.1a7a44	a0 00 00	ldy #$0000	                LDY #0
.1a7a47	64 50		stz $0898	                STZ MPARSEDNUM      ; Set parsed number to 0 in anticipation of
.1a7a49	64 52		stz $089a	                STZ MPARSEDNUM+2    ; hex digits in the pattern
.1a7a4b	b7 03		lda [$084b],y	match_loop      LDA [MCMP_TEXT],Y   ; Get the pattern character
.1a7a4d	f0 11		beq $1a7a60	                BEQ nul_check       ; If at end of pattern, check for end of test string
.1a7a4f	c9 64		cmp #$64	                CMP #'d'            ; Is it a digit?
.1a7a51	f0 19		beq $1a7a6c	                BEQ check_digit     ; Yes: do special check for hex digit
.1a7a53	48		pha		compare         PHA
.1a7a54	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.1a7a56	85 4a		sta $0892	                STA MTEMP
.1a7a58	68		pla		                PLA
.1a7a59	c5 4a		cmp $0892	                CMP MTEMP           ; Does it match the character to test?
.1a7a5b	d0 0b		bne $1a7a68	                BNE return_false    ; No: return fail
.1a7a5d	c8		iny		next_char       INY                 ; Yes: test the next character
.1a7a5e	80 eb		bra $1a7a4b	                BRA match_loop
.1a7a60	b7 36		lda [$087e],y	nul_check       LDA [MLINEBUF],Y    ; Check to see that we're at the end of the test string
.1a7a62	d0 04		bne $1a7a68	                BNE return_false    ; If not: return false
.1a7a64	2b		pld		return_true     PLD
.1a7a65	28		plp		                PLP                 ; Return true
.1a7a66	38		sec		                SEC
.1a7a67	6b		rtl		                RTL
.1a7a68	2b		pld		return_false    PLD
.1a7a69	28		plp		                PLP                 ; Return false
.1a7a6a	18		clc		                CLC
.1a7a6b	6b		rtl		                RTL
.1a7a6c					check_digit
.1a7a6c	e2 20		sep #$20	            SEP #$20
.1a7a6e	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.1a7a70	c9 3a		cmp #$3a	                CMP #'9'+1
.1a7a72	b0 04		bcs $1a7a78	                BCS check_AF
.1a7a74	c9 30		cmp #$30	                CMP #'0'
.1a7a76	b0 14		bcs $1a7a8c	                BCS shift_digit     ; character is in [0..9]
.1a7a78	c9 47		cmp #$47	check_AF        CMP #'F'+1
.1a7a7a	b0 04		bcs $1a7a80	                BCS check_lc        ; check lower case
.1a7a7c	c9 41		cmp #$41	                CMP #'A'
.1a7a7e	b0 0c		bcs $1a7a8c	                BCS shift_digit     ; character is in [A..F]
.1a7a80	c9 67		cmp #$67	check_lc        CMP #'f'+1
.1a7a82	b0 e4		bcs $1a7a68	                BCS return_false    ; check lower case
.1a7a84	c9 61		cmp #$61	                CMP #'a'
.1a7a86	b0 02		bcs $1a7a8a	                BCS to_upcase       ; character is in [A..F]
.1a7a88	80 de		bra $1a7a68	                BRA return_false    ; No match found... return false
.1a7a8a	29 df		and #$df	to_upcase       AND #%11011111      ; Convert lower case to upper case
.1a7a8c	22 ab 79 1a	jsl $1a79ab	shift_digit     JSL AS_SHIFT_HEX    ; Shift the digit into MPARSEDNUM
.1a7a90	80 cb		bra $1a7a5d	                BRA next_char       ; And check the next character
.1a7a92					AS_MCMP_NEXT
.1a7a92	0b		phd		                PHD
.1a7a93	08		php		            PHP
.1a7a94	c2 20		rep #$20	            REP #$20
.1a7a96	48		pha		            PHA
.1a7a97	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7a9a	5b		tcd		            TCD
.1a7a9b	68		pla		            PLA
.1a7a9c	28		plp		            PLP
.1a7a9d	a0 00 00	ldy #$0000	                LDY #0
.1a7aa0	e2 20		sep #$20	            SEP #$20
.1a7aa2	b7 03		lda [$084b],y	loop            LDA [MCMP_TEXT],Y   ; Check to see if we have gotten to the NUL
.1a7aa4	f0 03		beq $1a7aa9	                BEQ found_nul
.1a7aa6	c8		iny		                INY
.1a7aa7	80 f9		bra $1a7aa2	                BRA loop
.1a7aa9					found_nul
.1a7aa9	c2 20		rep #$20	            REP #$20
.1a7aab	c8		iny		                INY                 ; Got to NUL... point to next byte
.1a7aac	5a		phy		                PHY
.1a7aad	68		pla		                PLA                 ; And add that index to MCMP_TEXT pointer
.1a7aae	18		clc		                CLC
.1a7aaf	65 03		adc $084b	                ADC MCMP_TEXT
.1a7ab1	85 03		sta $084b	                STA MCMP_TEXT
.1a7ab3	a5 05		lda $084d	                LDA MCMP_TEXT+2
.1a7ab5	69 00 00	adc #$0000	                ADC #0
.1a7ab8	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7aba	2b		pld		                PLD
.1a7abb	6b		rtl		                RTL
.1a7abc					AS_FIND_MNEMO
.1a7abc	0b		phd		                PHD
.1a7abd	08		php		            PHP
.1a7abe	c2 20		rep #$20	            REP #$20
.1a7ac0	48		pha		            PHA
.1a7ac1	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7ac4	5b		tcd		            TCD
.1a7ac5	68		pla		            PLA
.1a7ac6	28		plp		            PLP
.1a7ac7	c2 20		rep #$20	            REP #$20
.1a7ac9	a5 11		lda $0859	                LDA MARG2                   ; Point MLINEBUF to the text
.1a7acb	85 36		sta $087e	                STA MLINEBUF
.1a7acd	a5 13		lda $085b	                LDA MARG2+2
.1a7acf	85 38		sta $0880	                STA MLINEBUF+2
.1a7ad1	a9 45 7f	lda #$7f45	                LDA #<>MNEMONICS_TAB        ; Point to the first mnemonic
.1a7ad4	85 03		sta $084b	                STA MCMP_TEXT
.1a7ad6	a9 1a 00	lda #$001a	                LDA #`MNEMONICS_TAB
.1a7ad9	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7adb	22 34 7a 1a	jsl $1a7a34	match_loop      JSL AS_STR_MATCH            ; Check to see if the text matches the mnemonic
.1a7adf	b0 0d		bcs $1a7aee	                BCS found_mnemonic          ; If so: return that we found it
.1a7ae1	22 92 7a 1a	jsl $1a7a92	                JSL AS_MCMP_NEXT            ; Point to the next mnemonic
.1a7ae5	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Check to see if it's NUL
.1a7ae7	d0 f2		bne $1a7adb	                BNE match_loop              ; If not, check this next mnemonic
.1a7ae9	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Otherwise, return -1
.1a7aec	80 02		bra $1a7af0	                BRA done
.1a7aee	a5 03		lda $084b	found_mnemonic  LDA MCMP_TEXT               ; Found it: return the address
.1a7af0	2b		pld		done            PLD
.1a7af1	6b		rtl		                RTL
.1a7af2					AS_FIND_MODE
.1a7af2	08		php		                PHP
.1a7af3	0b		phd		                PHD
.1a7af4	08		php		            PHP
.1a7af5	c2 20		rep #$20	            REP #$20
.1a7af7	48		pha		            PHA
.1a7af8	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7afb	5b		tcd		            TCD
.1a7afc	68		pla		            PLA
.1a7afd	28		plp		            PLP
.1a7afe	c2 30		rep #$30	            REP #$30
.1a7b00	a5 15		lda $085d	                LDA MARG3                   ; Point MLINEBUF to the operand
.1a7b02	85 36		sta $087e	                STA MLINEBUF
.1a7b04	a5 17		lda $085f	                LDA MARG3+2
.1a7b06	85 38		sta $0880	                STA MLINEBUF+2
.1a7b08	a9 d1 83	lda #$83d1	                LDA #<>ADDR_PATTERNS        ; Point to the first address mode pattern to check
.1a7b0b	85 03		sta $084b	                STA MCMP_TEXT
.1a7b0d	a9 1a 00	lda #$001a	                LDA #`ADDR_PATTERNS
.1a7b10	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7b12	22 34 7a 1a	jsl $1a7a34	match_loop      JSL AS_STR_MATCH            ; Check to see if the pattern matches the operand
.1a7b16	b0 22		bcs $1a7b3a	                BCS is_match                ; Yes: Find address mode code
.1a7b18	22 92 7a 1a	jsl $1a7a92	                JSL AS_MCMP_NEXT            ; Point to the address mode
.1a7b1c	c2 20		rep #$20	            REP #$20
.1a7b1e	18		clc		                CLC                         ; Point to the first byte of the next pattern
.1a7b1f	a5 03		lda $084b	                LDA MCMP_TEXT
.1a7b21	69 01 00	adc #$0001	                ADC #1
.1a7b24	85 03		sta $084b	                STA MCMP_TEXT
.1a7b26	a5 05		lda $084d	                LDA MCMP_TEXT+2
.1a7b28	69 00 00	adc #$0000	                ADC #0
.1a7b2b	85 05		sta $084d	                STA MCMP_TEXT+2
.1a7b2d	e2 20		sep #$20	            SEP #$20
.1a7b2f	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Is the first byte 0?
.1a7b31	d0 df		bne $1a7b12	                BNE match_loop              ; No: check this next pattern
.1a7b33	c2 20		rep #$20	            REP #$20
.1a7b35	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Yes: we didn't find a matching pattern, return -1
.1a7b38	80 0d		bra $1a7b47	                BRA done
.1a7b3a	22 92 7a 1a	jsl $1a7a92	is_match        JSL AS_MCMP_NEXT            ; Point to the address mode
.1a7b3e	e2 20		sep #$20	            SEP #$20
.1a7b40	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Get the corresponding address mode code (a byte)
.1a7b42	c2 20		rep #$20	            REP #$20
.1a7b44	29 ff 00	and #$00ff	                AND #$00FF
.1a7b47	2b		pld		done            PLD
.1a7b48	28		plp		                PLP
.1a7b49	6b		rtl		                RTL
.1a7b4a					IMDISASSEMBLE
.1a7b4a	08		php		                PHP
.1a7b4b	8b		phb		                PHB
.1a7b4c	0b		phd		                PHD
.1a7b4d	08		php		            PHP
.1a7b4e	c2 20		rep #$20	            REP #$20
.1a7b50	48		pha		            PHA
.1a7b51	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7b54	5b		tcd		            TCD
.1a7b55	68		pla		            PLA
.1a7b56	28		plp		            PLP
.1a7b57	e2 20		sep #$20	            SEP #$20
.1a7b59	a9 00		lda #$00	                LDA #0
.1a7b5b	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT     ; Clear the pagination line counter
.1a7b5f	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.1a7b61	c9 02		cmp #$02	                CMP #2
.1a7b63	b0 16		bcs $1a7b7b	                BGE set_cursor      ; 2>= arguments? Use them as-is
.1a7b65	c9 01		cmp #$01	                CMP #1
.1a7b67	90 20		bcc $1a7b89	                BLT no_args         ; No arguments passed? Use defaults
.1a7b69	c2 20		rep #$20	            REP #$20
.1a7b6b	18		clc		                CLC
.1a7b6c	a5 0d		lda $0855	                LDA MARG1
.1a7b6e	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a7b71	85 11		sta $0859	                STA MARG2
.1a7b73	e2 20		sep #$20	            SEP #$20
.1a7b75	a5 0f		lda $0857	                LDA MARG1+2
.1a7b77	69 00		adc #$00	                ADC #0
.1a7b79	85 13		sta $085b	                STA MARG2+2
.1a7b7b					set_cursor
.1a7b7b	c2 20		rep #$20	            REP #$20
.1a7b7d	a5 0d		lda $0855	                LDA MARG1
.1a7b7f	85 32		sta $087a	                STA MCURSOR
.1a7b81	e2 20		sep #$20	            SEP #$20
.1a7b83	a5 0f		lda $0857	                LDA MARG1+2
.1a7b85	85 34		sta $087c	                STA MCURSOR+2
.1a7b87	80 12		bra $1a7b9b	                BRA dasm_loop
.1a7b89					no_args
.1a7b89	c2 20		rep #$20	            REP #$20
.1a7b8b	18		clc		                CLC
.1a7b8c	a5 32		lda $087a	                LDA MCURSOR
.1a7b8e	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.1a7b91	85 11		sta $0859	                STA MARG2
.1a7b93	e2 20		sep #$20	            SEP #$20
.1a7b95	a5 34		lda $087c	                LDA MCURSOR+2
.1a7b97	69 00		adc #$00	                ADC #0
.1a7b99	85 13		sta $085b	                STA MARG2+2
.1a7b9b	22 b6 7b 1a	jsl $1a7bb6	dasm_loop       JSL DS_PR_LINE
.1a7b9f	e2 20		sep #$20	            SEP #$20
.1a7ba1	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.1a7ba3	c5 13		cmp $085b	                CMP MARG2+2
.1a7ba5	90 f4		bcc $1a7b9b	                BLT dasm_loop           ; No: continue
.1a7ba7	c2 20		rep #$20	            REP #$20
.1a7ba9	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.1a7bab	c5 11		cmp $0859	                CMP MARG2
.1a7bad	90 ec		bcc $1a7b9b	                BLT dasm_loop           ; Nope... keep going
.1a7baf					done
.1a7baf	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a7bb2	2b		pld		                PLD
.1a7bb3	ab		plb		                PLB
.1a7bb4	28		plp		                PLP
.1a7bb5	6b		rtl		                RTL
.1a7bb6					DS_PR_LINE
.1a7bb6	08		php		                PHP
.1a7bb7	0b		phd		                PHD
.1a7bb8	e2 20		sep #$20	            SEP #$20
.1a7bba	a9 41		lda #$41	                LDA #'A'
.1a7bbc	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7bbf	a9 20		lda #$20	                LDA #' '
.1a7bc1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7bc4	08		php		            PHP
.1a7bc5	c2 20		rep #$20	            REP #$20
.1a7bc7	48		pha		            PHA
.1a7bc8	a9 7a 08	lda #$087a	            LDA #MCURSOR
.1a7bcb	5b		tcd		            TCD
.1a7bcc	68		pla		            PLA
.1a7bcd	28		plp		            PLP
.1a7bce	c2 20		rep #$20	            REP #$20
.1a7bd0	a5 00		lda $087a	                LDA MCURSOR
.1a7bd2	85 18		sta $0892	                STA MTEMP
.1a7bd4	e2 20		sep #$20	            SEP #$20
.1a7bd6	a5 02		lda $087c	                LDA MCURSOR+2
.1a7bd8	85 1a		sta $0894	                STA MTEMP+2
.1a7bda	22 1d 7f 1a	jsl $1a7f1d	                JSL M_PR_ADDR
.1a7bde	a9 20		lda #$20	                LDA #' '
.1a7be0	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7be3	c2 20		rep #$20	            REP #$20
.1a7be5	18		clc		                CLC
.1a7be6	a5 00		lda $087a	                LDA MCURSOR
.1a7be8	69 01 00	adc #$0001	                ADC #1
.1a7beb	85 18		sta $0892	                STA MTEMP
.1a7bed	e2 20		sep #$20	            SEP #$20
.1a7bef	a5 02		lda $087c	                LDA MCURSOR+2
.1a7bf1	69 00		adc #$00	                ADC #0
.1a7bf3	85 1a		sta $0894	                STA MTEMP+2
.1a7bf5	e2 20		sep #$20	            SEP #$20
.1a7bf7	c2 10		rep #$10	            REP #$10
.1a7bf9	a7 00		lda [$087a]	                LDA [MCURSOR]           ; Get the mnemonic
.1a7bfb	c9 c2		cmp #$c2	                CMP #$C2                ; Is it REP?
.1a7bfd	d0 0b		bne $1a7c0a	                BNE check_sep           ; No: check to see if it is SEP
.1a7bff	48		pha		handle_rep      PHA
.1a7c00	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.1a7c02	49 ff		eor #$ff	                EOR #$FF                ; Invert the bits
.1a7c04	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Mask off the bits in the CPUSTAT
.1a7c08	80 0b		bra $1a7c15	                BRA save_stat
.1a7c0a	c9 e2		cmp #$e2	check_sep       CMP #$E2                ; Is it SEP?
.1a7c0c	d0 0c		bne $1a7c1a	                BNE get_op_index        ; No: process the instruction regularly
.1a7c0e	48		pha		handle_sep      PHA
.1a7c0f	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.1a7c11	0f 96 08 00	ora $000896	                ORA @lMCPUSTAT          ; Activate the bits in the CPUSTAT
.1a7c15	8f 96 08 00	sta $000896	save_stat       STA @lMCPUSTAT          ; And save it back
.1a7c19	68		pla		                PLA
.1a7c1a					get_op_index
.1a7c1a	c2 20		rep #$20	            REP #$20
.1a7c1c	29 ff 00	and #$00ff	                AND #$00FF
.1a7c1f	0a		asl a		                ASL A
.1a7c20	aa		tax		                TAX                     ; Get the index into the mnemonic lookup table
.1a7c21	bf b7 80 1a	lda $1a80b7,x	                LDA @lMNEMONIC_TAB,X    ; Get the mnemonic
.1a7c25	aa		tax		                TAX
.1a7c26	22 97 7e 1a	jsl $1a7e97	                JSL DS_PR_MNEMONIC      ; And print it
.1a7c2a	e2 20		sep #$20	            SEP #$20
.1a7c2c	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a7c2e	aa		tax		                TAX
.1a7c2f	bf b9 82 1a	lda $1a82b9,x	pr_operand      LDA @lADDRESS_TAB,X     ; Get the addressing mode for the instruction
.1a7c33	22 73 84 1a	jsl $1a8473	                JSL M_INC_CURSOR        ; Advance the cursor to the next byte
.1a7c37	22 44 7c 1a	jsl $1a7c44	                JSL DS_PR_OPERAND       ; And print the correct operand
.1a7c3b	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a7c3e	20 a0 02	jsr $1a02a0	            JSR PAGINATE
.1a7c41	2b		pld		                PLD
.1a7c42	28		plp		                PLP
.1a7c43	6b		rtl		                RTL
.1a7c44					DS_PR_OPERAND
.1a7c44	08		php		                PHP
.1a7c45	e2 20		sep #$20	            SEP #$20
.1a7c47	48		pha		                PHA             ; Save the address mode so we can get to the M and X flags
.1a7c48	29 3f		and #$3f	                AND #%00111111  ; Filter out the mode flags
.1a7c4a	0a		asl a		                ASL A           ; Compute the index to the table
.1a7c4b	c2 10		rep #$10	            REP #$10
.1a7c4d	aa		tax		                TAX
.1a7c4e	68		pla		                PLA             ; Restore A
.1a7c4f	7c 52 7c	jmp ($1a7c52,x)	                JMP (dispatch,X)
>1a7c52	82 7c				dispatch        .word <>is_dp_ind_x
>1a7c54	9d 7c				                .word <>is_dp
>1a7c56	a4 7c				                .word <>is_imm
>1a7c58	c9 7c				                .word <>is_abs
>1a7c5a	d0 7c				                .word <>is_dp_ind_y
>1a7c5c	eb 7c				                .word <>is_dp_x
>1a7c5e	0d 7d				                .word <>is_abs_y
>1a7c60	1e 7d				                .word <>is_abs_x
>1a7c62	5b 7d				                .word <>is_accumulator
>1a7c64	63 7d				                .word <>is_stack_r
>1a7c66	74 7d				                .word <>is_dp_long
>1a7c68	85 7d				                .word <>is_abs_long
>1a7c6a	8c 7d				                .word <>is_stack_r_y
>1a7c6c	b1 7d				                .word <>is_dp_y_long
>1a7c6e	de 7d				                .word <>is_abs_x_long
>1a7c70	4a 7d				                .word <>is_dp_ind
>1a7c72	2f 7d				                .word <>is_abs_x_id
>1a7c74	fc 7c				                .word <>is_dp_y
>1a7c76	d1 7d				                .word <>is_pc_rel
>1a7c78	db 7d				                .word <>is_implied
>1a7c7a	ef 7d				                .word <>is_xyc
>1a7c7c	1e 7e				                .word <>is_abs_ind
>1a7c7e	cc 7d				                .word <>is_pc_rel_long
>1a7c80	2f 7e				                .word <>is_abs_ind_long
.1a7c82	a9 28		lda #$28	is_dp_ind_x     LDA #'('                ; Print (dd,X)
.1a7c84	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7c87	22 46 7e 1a	jsl $1a7e46	                JSL DS_PR_OPERAND1      ; Print dd
.1a7c8b	a9 2c		lda #$2c	                LDA #','
.1a7c8d	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7c90	a9 58		lda #$58	                LDA #'X'
.1a7c92	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7c95	a9 29		lda #$29	                LDA #')'
.1a7c97	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7c9a	4c 40 7e	jmp $1a7e40	                JMP done_1
.1a7c9d	22 46 7e 1a	jsl $1a7e46	is_dp           JSL DS_PR_OPERAND1      ; Print dd
.1a7ca1	4c 40 7e	jmp $1a7e40	                JMP done_1
.1a7ca4					is_imm
.1a7ca4	e2 20		sep #$20	            SEP #$20
.1a7ca6	48		pha		                PHA
.1a7ca7	a9 23		lda #$23	                LDA #'#'
.1a7ca9	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7cac	68		pla		                PLA
.1a7cad	29 c0		and #$c0	                AND #%11000000          ; Filter so we just look at the mode bits
.1a7caf	c9 00		cmp #$00	                CMP #$00                ; Are any set to check?
.1a7cb1	f0 0f		beq $1a7cc2	                BEQ is_imm_short        ; No: treat it as a short always
.1a7cb3	4a		lsr a		                LSR A                   ; Move the flag bits right by 2 to match
.1a7cb4	4a		lsr a		                LSR A                   ; the positions of the bits in the CPU status register
.1a7cb5	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Otherwise, filter the mode bit we care about
.1a7cb9	d0 07		bne $1a7cc2	                BNE is_imm_short        ; If it is set, immediate operation is short
.1a7cbb	22 50 7e 1a	jsl $1a7e50	                JSL DS_PR_OPERAND2      ; Print dddd
.1a7cbf	4c 40 7e	jmp $1a7e40	                JMP done_1
.1a7cc2	22 46 7e 1a	jsl $1a7e46	is_imm_short    JSL DS_PR_OPERAND1      ; Print dd
.1a7cc6	4c 40 7e	jmp $1a7e40	                JMP done_1
.1a7cc9	22 50 7e 1a	jsl $1a7e50	is_abs          JSL DS_PR_OPERAND2      ; Print dddd
.1a7ccd	4c 40 7e	jmp $1a7e40	                JMP done_1
.1a7cd0	a9 28		lda #$28	is_dp_ind_y     LDA #'('                ; Print (dd),Y
.1a7cd2	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7cd5	22 46 7e 1a	jsl $1a7e46	                JSL DS_PR_OPERAND1      ; Print dd
.1a7cd9	a9 29		lda #$29	                LDA #')'
.1a7cdb	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7cde	a9 2c		lda #$2c	                LDA #','
.1a7ce0	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ce3	a9 59		lda #$59	                LDA #'Y'
.1a7ce5	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ce8	4c 40 7e	jmp $1a7e40	                JMP done_1
.1a7ceb	22 46 7e 1a	jsl $1a7e46	is_dp_x         JSL DS_PR_OPERAND1      ; Print dd,X
.1a7cef	a9 2c		lda #$2c	                LDA #','
.1a7cf1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7cf4	a9 58		lda #$58	                LDA #'X'
.1a7cf6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7cf9	4c 40 7e	jmp $1a7e40	                JMP done_1
.1a7cfc	22 46 7e 1a	jsl $1a7e46	is_dp_y         JSL DS_PR_OPERAND1      ; Print dd,Y
.1a7d00	a9 2c		lda #$2c	                LDA #','
.1a7d02	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d05	a9 59		lda #$59	                LDA #'Y'
.1a7d07	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d0a	4c 40 7e	jmp $1a7e40	                JMP done_1
.1a7d0d	22 50 7e 1a	jsl $1a7e50	is_abs_y        JSL DS_PR_OPERAND2      ; Print dddd,Y
.1a7d11	a9 2c		lda #$2c	                LDA #','
.1a7d13	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d16	a9 59		lda #$59	                LDA #'Y'
.1a7d18	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d1b	4c 40 7e	jmp $1a7e40	                JMP done_1
.1a7d1e	22 50 7e 1a	jsl $1a7e50	is_abs_x        JSL DS_PR_OPERAND2      ; Print dddd,X
.1a7d22	a9 2c		lda #$2c	                LDA #','
.1a7d24	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d27	a9 58		lda #$58	                LDA #'X'
.1a7d29	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d2c	4c 40 7e	jmp $1a7e40	                JMP done_1
.1a7d2f	a9 28		lda #$28	is_abs_x_id     LDA #'('
.1a7d31	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d34	22 50 7e 1a	jsl $1a7e50	                JSL DS_PR_OPERAND2      ; Print (dddd,X)
.1a7d38	a9 2c		lda #$2c	                LDA #','
.1a7d3a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d3d	a9 58		lda #$58	                LDA #'X'
.1a7d3f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d42	a9 29		lda #$29	                LDA #')'
.1a7d44	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d47	4c 40 7e	jmp $1a7e40	                JMP done_1
.1a7d4a	a9 28		lda #$28	is_dp_ind       LDA #'('
.1a7d4c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d4f	22 46 7e 1a	jsl $1a7e46	                JSL DS_PR_OPERAND1      ; Print (dd)
.1a7d53	a9 29		lda #$29	                LDA #')'
.1a7d55	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d58	4c 40 7e	jmp $1a7e40	                JMP done_1
.1a7d5b	a9 41		lda #$41	is_accumulator  LDA #'A'                ; Print A
.1a7d5d	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d60	4c 44 7e	jmp $1a7e44	                JMP done
.1a7d63	22 46 7e 1a	jsl $1a7e46	is_stack_r      JSL DS_PR_OPERAND1      ; Print dd,S
.1a7d67	a9 2c		lda #$2c	                LDA #','
.1a7d69	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d6c	a9 53		lda #$53	                LDA #'S'
.1a7d6e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d71	4c 40 7e	jmp $1a7e40	                JMP done_1
.1a7d74	a9 5b		lda #$5b	is_dp_long      LDA #'['                ; [dd]
.1a7d76	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d79	22 46 7e 1a	jsl $1a7e46	                JSL DS_PR_OPERAND1      ; Print dd
.1a7d7d	a9 5d		lda #$5d	                LDA #']'
.1a7d7f	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d82	4c 40 7e	jmp $1a7e40	                JMP done_1
.1a7d85	22 5e 7e 1a	jsl $1a7e5e	is_abs_long     JSL DS_PR_OPERAND3      ; Print dddddd
.1a7d89	4c 44 7e	jmp $1a7e44	                JMP done
.1a7d8c	a9 28		lda #$28	is_stack_r_y    LDA #'('                ; (dd,S),Y
.1a7d8e	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d91	22 46 7e 1a	jsl $1a7e46	                JSL DS_PR_OPERAND1      ; Print dd
.1a7d95	a9 2c		lda #$2c	                LDA #','
.1a7d97	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d9a	a9 53		lda #$53	                LDA #'S'
.1a7d9c	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7d9f	a9 29		lda #$29	                LDA #')'
.1a7da1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7da4	a9 2c		lda #$2c	                LDA #','
.1a7da6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7da9	a9 59		lda #$59	                LDA #'Y'
.1a7dab	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7dae	4c 40 7e	jmp $1a7e40	                JMP done_1
.1a7db1	a9 5b		lda #$5b	is_dp_y_long    LDA #'['                ; [dd],Y
.1a7db3	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7db6	22 46 7e 1a	jsl $1a7e46	                JSL DS_PR_OPERAND1      ; Print dd
.1a7dba	a9 5d		lda #$5d	                LDA #']'
.1a7dbc	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7dbf	a9 2c		lda #$2c	                LDA #','
.1a7dc1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7dc4	a9 59		lda #$59	                LDA #'Y'
.1a7dc6	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7dc9	4c 40 7e	jmp $1a7e40	                JMP done_1
.1a7dcc	a0 02 00	ldy #$0002	is_pc_rel_long  LDY #2
.1a7dcf	80 03		bra $1a7dd4	                BRA do_pcrel
.1a7dd1	a0 01 00	ldy #$0001	is_pc_rel       LDY #1
.1a7dd4	22 c4 7e 1a	jsl $1a7ec4	do_pcrel        JSL DS_PR_PCREL
.1a7dd8	4c 44 7e	jmp $1a7e44	                JMP done
.1a7ddb	4c 44 7e	jmp $1a7e44	is_implied      JMP done
.1a7dde	22 5e 7e 1a	jsl $1a7e5e	is_abs_x_long   JSL DS_PR_OPERAND3      ; Print dddddd
.1a7de2	a9 2c		lda #$2c	                LDA #','
.1a7de4	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7de7	a9 58		lda #$58	                LDA #'X'
.1a7de9	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7dec	4c 44 7e	jmp $1a7e44	                JMP done
.1a7def	a9 23		lda #$23	is_xyc          LDA #'#'
.1a7df1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7df4	8b		phb		                PHB                     ; Make sure the databank is pointed to our number
.1a7df5	a5 02		lda $087c	                LDA MCURSOR+2
.1a7df7	48		pha		                PHA
.1a7df8	ab		plb		                PLB
.1a7df9	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.1a7dfb	e8		inx		                INX
.1a7dfc	a0 01 00	ldy #$0001	                LDY #1
.1a7dff	22 99 02 1a	jsl $1a0299	                JSL PRINTH
.1a7e03	a9 2c		lda #$2c	                LDA #','
.1a7e05	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e08	a9 23		lda #$23	                LDA #'#'
.1a7e0a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e0d	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.1a7e0f	a0 01 00	ldy #$0001	                LDY #1
.1a7e12	22 99 02 1a	jsl $1a0299	                JSL PRINTH
.1a7e16	ab		plb		                PLB                     ; Get our old data bank back
.1a7e17	22 73 84 1a	jsl $1a8473	                JSL M_INC_CURSOR
.1a7e1b	4c 40 7e	jmp $1a7e40	                JMP done_1
.1a7e1e	a9 28		lda #$28	is_abs_ind      LDA #'('
.1a7e20	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e23	22 50 7e 1a	jsl $1a7e50	                JSL DS_PR_OPERAND2      ; Print (dddd)
.1a7e27	a9 29		lda #$29	                LDA #')'
.1a7e29	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e2c	4c 40 7e	jmp $1a7e40	                JMP done_1
.1a7e2f	a9 5b		lda #$5b	is_abs_ind_long LDA #'['
.1a7e31	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e34	22 50 7e 1a	jsl $1a7e50	                JSL DS_PR_OPERAND2      ; Print [dddd]
.1a7e38	a9 5d		lda #$5d	                LDA #']'
.1a7e3a	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7e3d	4c 40 7e	jmp $1a7e40	                JMP done_1
.1a7e40	22 73 84 1a	jsl $1a8473	done_1          JSL M_INC_CURSOR    ; Skip over a single byte operand
.1a7e44	28		plp		done            PLP
.1a7e45	6b		rtl		                RTL
.1a7e46					DS_PR_OPERAND1
.1a7e46	08		php		                PHP
.1a7e47	e2 20		sep #$20	            SEP #$20
.1a7e49	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a7e4b	20 40 03	jsr $1a0340	            JSR PRHEXB
.1a7e4e	28		plp		                PLP
.1a7e4f	6b		rtl		                RTL
.1a7e50					DS_PR_OPERAND2
.1a7e50	08		php		                PHP
.1a7e51	c2 30		rep #$30	            REP #$30
.1a7e53	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a7e55	20 26 03	jsr $1a0326	            JSR PRHEXW
.1a7e58	22 73 84 1a	jsl $1a8473	                JSL M_INC_CURSOR
.1a7e5c	28		plp		                PLP
.1a7e5d	6b		rtl		                RTL
.1a7e5e					DS_PR_OPERAND3
.1a7e5e	08		php		                PHP
.1a7e5f	8b		phb		                PHB
.1a7e60	0b		phd		                PHD
.1a7e61	c2 30		rep #$30	            REP #$30
.1a7e63	5a		phy		                PHY
.1a7e64	08		php		            PHP
.1a7e65	c2 20		rep #$20	            REP #$20
.1a7e67	48		pha		            PHA
.1a7e68	a9 7a 08	lda #$087a	            LDA #MCURSOR
.1a7e6b	5b		tcd		            TCD
.1a7e6c	68		pla		            PLA
.1a7e6d	28		plp		            PLP
.1a7e6e	08		php		            PHP
.1a7e6f	e2 20		sep #$20	            SEP #$20
.1a7e71	48		pha		            PHA
.1a7e72	a9 00		lda #$00	            LDA #`MTEMP
.1a7e74	48		pha		            PHA
.1a7e75	ab		plb		            PLB
.1a7e76	68		pla		            PLA
.1a7e77	28		plp		            PLP
.1a7e78	e2 20		sep #$20	            SEP #$20
.1a7e7a	a0 00 00	ldy #$0000	                LDY #0
.1a7e7d	a7 00		lda [$087a]	copy_loop       LDA [MCURSOR]       ; Copy the address pointed to by MCURSOR
.1a7e7f	99 92 08	sta $0892,y	                STA MTEMP,Y         ; to MTEMP
.1a7e82	22 73 84 1a	jsl $1a8473	                JSL M_INC_CURSOR
.1a7e86	c8		iny		                INY
.1a7e87	c0 03 00	cpy #$0003	                CPY #3
.1a7e8a	d0 f1		bne $1a7e7d	                BNE copy_loop
.1a7e8c	22 1d 7f 1a	jsl $1a7f1d	                JSL M_PR_ADDR       ; Print the address
.1a7e90	c2 30		rep #$30	            REP #$30
.1a7e92	7a		ply		                PLY
.1a7e93	2b		pld		                PLD
.1a7e94	ab		plb		                PLB
.1a7e95	28		plp		                PLP
.1a7e96	6b		rtl		                RTL
.1a7e97					DS_PR_MNEMONIC
.1a7e97	08		php		                PHP
.1a7e98	8b		phb		                PHB
.1a7e99	e2 20		sep #$20	            SEP #$20
.1a7e9b	c2 10		rep #$10	            REP #$10
.1a7e9d	08		php		            PHP
.1a7e9e	e2 20		sep #$20	            SEP #$20
.1a7ea0	48		pha		            PHA
.1a7ea1	a9 1a		lda #$1a	            LDA #`MN_ORA
.1a7ea3	48		pha		            PHA
.1a7ea4	ab		plb		            PLB
.1a7ea5	68		pla		            PLA
.1a7ea6	28		plp		            PLP
.1a7ea7	bd 00 00	lda $1a0000,x	                LDA #0,B,X
.1a7eaa	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ead	e8		inx		                INX
.1a7eae	bd 00 00	lda $1a0000,x	                LDA #0,B,X
.1a7eb1	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7eb4	e8		inx		                INX
.1a7eb5	bd 00 00	lda $1a0000,x	                LDA #0,B,X
.1a7eb8	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ebb	e8		inx		                INX
.1a7ebc	a9 20		lda #$20	                LDA #' '            ; Print a space
.1a7ebe	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7ec1	ab		plb		                PLB
.1a7ec2	28		plp		                PLP
.1a7ec3	6b		rtl		                RTL
.1a7ec4					DS_PR_PCREL
.1a7ec4	08		php		                PHP
.1a7ec5	0b		phd		                PHD
.1a7ec6	08		php		            PHP
.1a7ec7	c2 20		rep #$20	            REP #$20
.1a7ec9	48		pha		            PHA
.1a7eca	a9 7a 08	lda #$087a	            LDA #MCURSOR
.1a7ecd	5b		tcd		            TCD
.1a7ece	68		pla		            PLA
.1a7ecf	28		plp		            PLP
.1a7ed0	e2 20		sep #$20	            SEP #$20
.1a7ed2	c0 02 00	cpy #$0002	                CPY #2
.1a7ed5	f0 14		beq $1a7eeb	                BEQ offset_2
.1a7ed7	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a7ed9	85 18		sta $0892	                STA MTEMP
.1a7edb	30 06		bmi $1a7ee3	                BMI is_negative
.1a7edd	64 19		stz $0893	                STZ MTEMP+1
.1a7edf	64 1a		stz $0894	                STZ MTEMP+2
.1a7ee1	80 1e		bra $1a7f01	                BRA add_offset
.1a7ee3	a9 ff		lda #$ff	is_negative     LDA #$FF
.1a7ee5	85 19		sta $0893	                STA MTEMP+1
.1a7ee7	85 1a		sta $0894	                STA MTEMP+2
.1a7ee9	80 16		bra $1a7f01	                BRA add_offset
.1a7eeb	a7 00		lda [$087a]	offset_2        LDA [MCURSOR]
.1a7eed	85 18		sta $0892	                STA MTEMP
.1a7eef	22 73 84 1a	jsl $1a8473	                JSL M_INC_CURSOR
.1a7ef3	a7 00		lda [$087a]	                LDA [MCURSOR]
.1a7ef5	85 19		sta $0893	                STA MTEMP+1
.1a7ef7	30 04		bmi $1a7efd	                BMI is_negative2
.1a7ef9	64 1a		stz $0894	                STZ MTEMP+2
.1a7efb	80 04		bra $1a7f01	                BRA add_offset
.1a7efd	a9 ff		lda #$ff	is_negative2    LDA #$FF
.1a7eff	85 1a		sta $0894	                STA MTEMP+2
.1a7f01					add_offset
.1a7f01	c2 20		rep #$20	            REP #$20
.1a7f03	38		sec		                SEC             ; Add 1 to the offset
.1a7f04	a5 00		lda $087a	                LDA MCURSOR
.1a7f06	65 18		adc $0892	                ADC MTEMP
.1a7f08	85 18		sta $0892	                STA MTEMP
.1a7f0a	e2 20		sep #$20	            SEP #$20
.1a7f0c	a5 02		lda $087c	                LDA MCURSOR+2
.1a7f0e	65 1a		adc $0894	                ADC MTEMP+2
.1a7f10	85 1a		sta $0894	                STA MTEMP+2
.1a7f12	22 1d 7f 1a	jsl $1a7f1d	                JSL M_PR_ADDR
.1a7f16	22 73 84 1a	jsl $1a8473	                JSL M_INC_CURSOR
.1a7f1a	2b		pld		                PLD
.1a7f1b	28		plp		                PLP
.1a7f1c	6b		rtl		                RTL
.1a7f1d					M_PR_ADDR
.1a7f1d	08		php		                PHP
.1a7f1e	0b		phd		                PHD
.1a7f1f	c2 20		rep #$20	            REP #$20
.1a7f21	48		pha		                PHA
.1a7f22	08		php		            PHP
.1a7f23	c2 20		rep #$20	            REP #$20
.1a7f25	48		pha		            PHA
.1a7f26	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a7f29	5b		tcd		            TCD
.1a7f2a	68		pla		            PLA
.1a7f2b	28		plp		            PLP
.1a7f2c	e2 20		sep #$20	            SEP #$20
.1a7f2e	a5 4c		lda $0894	                LDA MTEMP+2     ; Print the bank byte of the address
.1a7f30	20 40 03	jsr $1a0340	            JSR PRHEXB
.1a7f33	e2 20		sep #$20	            SEP #$20
.1a7f35	a9 3a		lda #$3a	                LDA #':'
.1a7f37	20 18 00	jsr $1a0018	            JSR PRINTC
.1a7f3a	c2 20		rep #$20	            REP #$20
.1a7f3c	a5 4a		lda $0892	                LDA MTEMP       ; Print the lower 16-bits of the address
.1a7f3e	20 26 03	jsr $1a0326	            JSR PRHEXW
.1a7f41	68		pla		                PLA
.1a7f42	2b		pld		                PLD
.1a7f43	28		plp		                PLP
.1a7f44	6b		rtl		                RTL
.1a7f45					MNEMONICS_TAB
.1a7f45					MN_ORA
>1a7f45	4f 52 41 00			            .null "ORA"
.1a7f49					MN_AND
>1a7f49	41 4e 44 00			            .null "AND"
.1a7f4d					MN_EOR
>1a7f4d	45 4f 52 00			            .null "EOR"
.1a7f51					MN_ADC
>1a7f51	41 44 43 00			            .null "ADC"
.1a7f55					MN_STA
>1a7f55	53 54 41 00			            .null "STA"
.1a7f59					MN_LDA
>1a7f59	4c 44 41 00			            .null "LDA"
.1a7f5d					MN_CMP
>1a7f5d	43 4d 50 00			            .null "CMP"
.1a7f61					MN_SBC
>1a7f61	53 42 43 00			            .null "SBC"
.1a7f65					MN_ASL
>1a7f65	41 53 4c 00			            .null "ASL"
.1a7f69					MN_ROL
>1a7f69	52 4f 4c 00			            .null "ROL"
.1a7f6d					MN_LSR
>1a7f6d	4c 53 52 00			            .null "LSR"
.1a7f71					MN_ROR
>1a7f71	52 4f 52 00			            .null "ROR"
.1a7f75					MN_STX
>1a7f75	53 54 58 00			            .null "STX"
.1a7f79					MN_LDX
>1a7f79	4c 44 58 00			            .null "LDX"
.1a7f7d					MN_DEC
>1a7f7d	44 45 43 00			            .null "DEC"
.1a7f81					MN_INC
>1a7f81	49 4e 43 00			            .null "INC"
.1a7f85					MN_BIT
>1a7f85	42 49 54 00			            .null "BIT"
.1a7f89					MN_JMP
>1a7f89	4a 4d 50 00			            .null "JMP"
.1a7f8d					MN_STY
>1a7f8d	53 54 59 00			            .null "STY"
.1a7f91					MN_LDY
>1a7f91	4c 44 59 00			            .null "LDY"
.1a7f95					MN_CPY
>1a7f95	43 50 59 00			            .null "CPY"
.1a7f99					MN_CPX
>1a7f99	43 50 58 00			            .null "CPX"
.1a7f9d					MN_BRK
>1a7f9d	42 52 4b 00			            .null "BRK"
.1a7fa1					MN_JSR
>1a7fa1	4a 53 52 00			            .null "JSR"
.1a7fa5					MN_RTI
>1a7fa5	52 54 49 00			            .null "RTI"
.1a7fa9					MN_RTS
>1a7fa9	52 54 53 00			            .null "RTS"
.1a7fad					MN_PHP
>1a7fad	50 48 50 00			            .null "PHP"
.1a7fb1					MN_PLP
>1a7fb1	50 4c 50 00			            .null "PLP"
.1a7fb5					MN_PHA
>1a7fb5	50 48 41 00			            .null "PHA"
.1a7fb9					MN_PLA
>1a7fb9	50 4c 41 00			            .null "PLA"
.1a7fbd					MN_DEY
>1a7fbd	44 45 59 00			            .null "DEY"
.1a7fc1					MN_TAY
>1a7fc1	54 41 59 00			            .null "TAY"
.1a7fc5					MN_INY
>1a7fc5	49 4e 59 00			            .null "INY"
.1a7fc9					MN_INX
>1a7fc9	49 4e 58 00			            .null "INX"
.1a7fcd					MN_CLC
>1a7fcd	43 4c 43 00			            .null "CLC"
.1a7fd1					MN_SEC
>1a7fd1	53 45 43 00			            .null "SEC"
.1a7fd5					MN_CLI
>1a7fd5	43 4c 49 00			            .null "CLI"
.1a7fd9					MN_SEI
>1a7fd9	53 45 49 00			            .null "SEI"
.1a7fdd					MN_TYA
>1a7fdd	54 59 41 00			            .null "TYA"
.1a7fe1					MN_CLV
>1a7fe1	43 4c 56 00			            .null "CLV"
.1a7fe5					MN_CLD
>1a7fe5	43 4c 44 00			            .null "CLD"
.1a7fe9					MN_SED
>1a7fe9	53 45 44 00			            .null "SED"
.1a7fed					MN_TXA
>1a7fed	54 58 41 00			            .null "TXA"
.1a7ff1					MN_TXS
>1a7ff1	54 58 53 00			            .null "TXS"
.1a7ff5					MN_TAX
>1a7ff5	54 41 58 00			            .null "TAX"
.1a7ff9					MN_TSX
>1a7ff9	54 53 58 00			            .null "TSX"
.1a7ffd					MN_DEX
>1a7ffd	44 45 58 00			            .null "DEX"
.1a8001					MN_NOP
>1a8001	4e 4f 50 00			            .null "NOP"
.1a8005					MN_BPL
>1a8005	42 50 4c 00			            .null "BPL"
.1a8009					MN_BMI
>1a8009	42 4d 49 00			            .null "BMI"
.1a800d					MN_BVC
>1a800d	42 56 43 00			            .null "BVC"
.1a8011					MN_BVS
>1a8011	42 56 53 00			            .null "BVS"
.1a8015					MN_BCC
>1a8015	42 43 43 00			            .null "BCC"
.1a8019					MN_BCS
>1a8019	42 43 53 00			            .null "BCS"
.1a801d					MN_BNE
>1a801d	42 4e 45 00			            .null "BNE"
.1a8021					MN_BEQ
>1a8021	42 45 51 00			            .null "BEQ"
.1a8025					MN_TSB
>1a8025	54 53 42 00			            .null "TSB"
.1a8029					MN_TRB
>1a8029	54 52 42 00			            .null "TRB"
.1a802d					MN_STZ
>1a802d	53 54 5a 00			            .null "STZ"
.1a8031					MN_BRA
>1a8031	42 52 41 00			            .null "BRA"
.1a8035					MN_PHY
>1a8035	50 48 59 00			            .null "PHY"
.1a8039					MN_PLY
>1a8039	50 4c 59 00			            .null "PLY"
.1a803d					MN_PHX
>1a803d	50 48 58 00			            .null "PHX"
.1a8041					MN_PLX
>1a8041	50 4c 58 00			            .null "PLX"
.1a8045					MN_PHD
>1a8045	50 48 44 00			            .null "PHD"
.1a8049					MN_PLD
>1a8049	50 4c 44 00			            .null "PLD"
.1a804d					MN_PHK
>1a804d	50 48 4b 00			            .null "PHK"
.1a8051					MN_RTL
>1a8051	52 54 4c 00			            .null "RTL"
.1a8055					MN_PHB
>1a8055	50 48 42 00			            .null "PHB"
.1a8059					MN_PLB
>1a8059	50 4c 42 00			            .null "PLB"
.1a805d					MN_WAI
>1a805d	57 41 49 00			            .null "WAI"
.1a8061					MN_XBA
>1a8061	58 42 41 00			            .null "XBA"
.1a8065					MN_TCS
>1a8065	54 43 53 00			            .null "TCS"
.1a8069					MN_TSC
>1a8069	54 53 43 00			            .null "TSC"
.1a806d					MN_TCD
>1a806d	54 43 44 00			            .null "TCD"
.1a8071					MN_TDC
>1a8071	54 44 43 00			            .null "TDC"
.1a8075					MN_TXY
>1a8075	54 58 59 00			            .null "TXY"
.1a8079					MN_TYX
>1a8079	54 59 58 00			            .null "TYX"
.1a807d					MN_STP
>1a807d	53 54 50 00			            .null "STP"
.1a8081					MN_XCE
>1a8081	58 43 45 00			            .null "XCE"
.1a8085					MN_COP
>1a8085	43 4f 50 00			            .null "COP"
.1a8089					MN_JSL
>1a8089	4a 53 4c 00			            .null "JSL"
.1a808d					MN_WDM
>1a808d	57 44 4d 00			            .null "WDM"
.1a8091					MN_PER
>1a8091	50 45 52 00			            .null "PER"
.1a8095					MN_BRL
>1a8095	42 52 4c 00			            .null "BRL"
.1a8099					MN_REP
>1a8099	52 45 50 00			            .null "REP"
.1a809d					MN_SEP
>1a809d	53 45 50 00			            .null "SEP"
.1a80a1					MN_MVP
>1a80a1	4d 56 50 00			            .null "MVP"
.1a80a5					MN_MVN
>1a80a5	4d 56 4e 00			            .null "MVN"
.1a80a9					MN_PEI
>1a80a9	50 45 49 00			            .null "PEI"
.1a80ad					MN_PEA
>1a80ad	50 45 41 00			            .null "PEA"
.1a80b1					MN_JML
>1a80b1	4a 4d 4c 00			            .null "JML"
>1a80b5	00 00				            .byte 0, 0
>1a80b7	9d 7f 45 7f 85 80 45 7f		MNEMONIC_TAB    .word <>MN_BRK, <>MN_ORA, <>MN_COP, <>MN_ORA, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 0x
>1a80bf	25 80 45 7f 65 7f 45 7f
>1a80c7	ad 7f 45 7f 65 7f 45 80		                .word <>MN_PHP, <>MN_ORA, <>MN_ASL, <>MN_PHD, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>1a80cf	25 80 45 7f 65 7f 45 7f
>1a80d7	05 80 45 7f 45 7f 45 7f		                .word <>MN_BPL, <>MN_ORA, <>MN_ORA, <>MN_ORA, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 1x
>1a80df	29 80 45 7f 65 7f 45 7f
>1a80e7	cd 7f 45 7f 81 7f 65 80		                .word <>MN_CLC, <>MN_ORA, <>MN_INC, <>MN_TCS, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>1a80ef	29 80 45 7f 65 7f 45 7f
>1a80f7	a1 7f 49 7f 89 80 49 7f		                .word <>MN_JSR, <>MN_AND, <>MN_JSL, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 2x
>1a80ff	85 7f 49 7f 69 7f 49 7f
>1a8107	b1 7f 49 7f 69 7f 49 80		                .word <>MN_PLP, <>MN_AND, <>MN_ROL, <>MN_PLD, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>1a810f	85 7f 49 7f 69 7f 49 7f
>1a8117	09 80 49 7f 49 7f 49 7f		                .word <>MN_BMI, <>MN_AND, <>MN_AND, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 3x
>1a811f	85 7f 49 7f 69 7f 49 7f
>1a8127	d1 7f 49 7f 7d 7f 69 80		                .word <>MN_SEC, <>MN_AND, <>MN_DEC, <>MN_TSC, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>1a812f	85 7f 49 7f 69 7f 49 7f
>1a8137	a5 7f 4d 7f 8d 80 4d 7f		                .word <>MN_RTI, <>MN_EOR, <>MN_WDM, <>MN_EOR, <>MN_MVP, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 4x
>1a813f	a1 80 4d 7f 6d 7f 4d 7f
>1a8147	b5 7f 4d 7f 6d 7f 4d 80		                .word <>MN_PHA, <>MN_EOR, <>MN_LSR, <>MN_PHK, <>MN_JMP, <>MN_EOR, <>MN_LSR, <>MN_EOR
>1a814f	89 7f 4d 7f 6d 7f 4d 7f
>1a8157	0d 80 4d 7f 4d 7f 4d 7f		                .word <>MN_BVC, <>MN_EOR, <>MN_EOR, <>MN_EOR, <>MN_MVN, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 5x
>1a815f	a5 80 4d 7f 6d 7f 4d 7f
>1a8167	d5 7f 4d 7f 35 80 6d 80		                .word <>MN_CLI, <>MN_EOR, <>MN_PHY, <>MN_TCD, <>MN_JML, <>MN_EOR, <>MN_LSR, <>MN_EOR
>1a816f	b1 80 4d 7f 6d 7f 4d 7f
>1a8177	a9 7f 51 7f 91 80 51 7f		                .word <>MN_RTS, <>MN_ADC, <>MN_PER, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 6x
>1a817f	2d 80 51 7f 71 7f 51 7f
>1a8187	b9 7f 51 7f 71 7f 51 80		                .word <>MN_PLA, <>MN_ADC, <>MN_ROR, <>MN_RTL, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>1a818f	89 7f 51 7f 71 7f 51 7f
>1a8197	11 80 51 7f 51 7f 51 7f		                .word <>MN_BVS, <>MN_ADC, <>MN_ADC, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 7x
>1a819f	2d 80 51 7f 71 7f 51 7f
>1a81a7	d9 7f 51 7f 39 80 71 80		                .word <>MN_SEI, <>MN_ADC, <>MN_PLY, <>MN_TDC, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>1a81af	89 7f 51 7f 71 7f 51 7f
>1a81b7	31 80 55 7f 95 80 55 7f		                .word <>MN_BRA, <>MN_STA, <>MN_BRL, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 8x
>1a81bf	8d 7f 55 7f 75 7f 55 7f
>1a81c7	bd 7f 85 7f ed 7f 55 80		                .word <>MN_DEY, <>MN_BIT, <>MN_TXA, <>MN_PHB, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA
>1a81cf	8d 7f 55 7f 75 7f 55 7f
>1a81d7	15 80 55 7f 55 7f 55 7f		                .word <>MN_BCC, <>MN_STA, <>MN_STA, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 9x
>1a81df	8d 7f 55 7f 75 7f 55 7f
>1a81e7	dd 7f 55 7f f1 7f 75 80		                .word <>MN_TYA, <>MN_STA, <>MN_TXS, <>MN_TXY, <>MN_STZ, <>MN_STA, <>MN_STZ, <>MN_STA
>1a81ef	2d 80 55 7f 2d 80 55 7f
>1a81f7	91 7f 59 7f 79 7f 59 7f		                .word <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Ax
>1a81ff	91 7f 59 7f 79 7f 59 7f
>1a8207	c1 7f 59 7f f5 7f 59 80		                .word <>MN_TAY, <>MN_LDA, <>MN_TAX, <>MN_PLB, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>1a820f	91 7f 59 7f 79 7f 59 7f
>1a8217	19 80 59 7f 59 7f 59 7f		                .word <>MN_BCS, <>MN_LDA, <>MN_LDA, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Bx
>1a821f	91 7f 59 7f 79 7f 59 7f
>1a8227	e1 7f 59 7f f9 7f 79 80		                .word <>MN_CLV, <>MN_LDA, <>MN_TSX, <>MN_TYX, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>1a822f	91 7f 59 7f 79 7f 59 7f
>1a8237	95 7f 5d 7f 99 80 5d 7f		                .word <>MN_CPY, <>MN_CMP, <>MN_REP, <>MN_CMP, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Cx
>1a823f	95 7f 5d 7f 7d 7f 5d 7f
>1a8247	c5 7f 5d 7f fd 7f 5d 80		                .word <>MN_INY, <>MN_CMP, <>MN_DEX, <>MN_WAI, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP
>1a824f	95 7f 5d 7f 7d 7f 5d 7f
>1a8257	1d 80 5d 7f 5d 7f 5d 7f		                .word <>MN_BNE, <>MN_CMP, <>MN_CMP, <>MN_CMP, <>MN_PEI, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Dx
>1a825f	a9 80 5d 7f 7d 7f 5d 7f
>1a8267	e5 7f 5d 7f 3d 80 7d 80		                .word <>MN_CLD, <>MN_CMP, <>MN_PHX, <>MN_STP, <>MN_JML, <>MN_CMP, <>MN_DEC, <>MN_CMP
>1a826f	b1 80 5d 7f 7d 7f 5d 7f
>1a8277	99 7f 61 7f 9d 80 61 7f		                .word <>MN_CPX, <>MN_SBC, <>MN_SEP, <>MN_SBC, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Ex
>1a827f	99 7f 61 7f 81 7f 61 7f
>1a8287	c9 7f 61 7f 01 80 61 80		                .word <>MN_INX, <>MN_SBC, <>MN_NOP, <>MN_XBA, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC
>1a828f	99 7f 61 7f 81 7f 61 7f
>1a8297	21 80 61 7f 61 7f 61 7f		                .word <>MN_BEQ, <>MN_SBC, <>MN_SBC, <>MN_SBC, <>MN_PEA, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Fx
>1a829f	ad 80 61 7f 81 7f 61 7f
>1a82a7	e9 7f 61 7f 41 80 81 80		                .word <>MN_SED, <>MN_SBC, <>MN_PLX, <>MN_XCE, <>MN_JSR, <>MN_SBC, <>MN_INC, <>MN_SBC
>1a82af	a1 7f 61 7f 81 7f 61 7f
>1a82b7	00 00				                .word 0
>1a82b9	13 00 02 09			ADDRESS_TAB     .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R                  ; 0x
>1a82bd	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a82c1	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a82c5	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a82c9	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 1x
>1a82cd	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a82d1	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>1a82d5	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a82d9	03 00 0b 09			                .byte ADDR_ABS, ADDR_DP_IND_X, ADDR_ABS_LONG, ADDR_SP_R                 ; 2x
>1a82dd	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a82e1	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a82e5	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a82e9	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 3x
>1a82ed	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a82f1	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>1a82f5	07 07 07 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a82f9	13 00 13 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMPLIED, ADDR_SP_R              ; 4x
>1a82fd	14 01 01 0a			                .byte ADDR_XYC, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8301	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a8305	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8309	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 5x
>1a830d	14 05 05 0d			                .byte ADDR_XYC, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8311	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a8315	0b 07 07 0b			                .byte ADDR_ABS_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_LONG
>1a8319	13 00 16 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R          ; 6x
>1a831d	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8321	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>1a8325	15 03 03 0b			                .byte ADDR_ABS_IND, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8329	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 7x
>1a832d	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8331	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a8335	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a8339	12 00 16 09			                .byte ADDR_PC_REL, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R           ; 8x
>1a833d	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8341	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a8345	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8349	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 9x
>1a834d	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>1a8351	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a8355	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a8359	82 00 42 09			                .byte ADDR_IMM | OP_M_EFFECT, ADDR_DP_IND_X, ADDR_IMM | OP_X_EFFECT, ADDR_SP_R  ; Ax
>1a835d	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8361	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a8365	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8369	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Bx
>1a836d	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>1a8371	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a8375	07 07 06 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_Y, ADDR_ABS_X_LONG
>1a8379	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Cx
>1a837d	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>1a8381	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a8385	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a8389	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Dx
>1a838d	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a8391	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a8395	17 07 07 0e			                .byte ADDR_ABS_IND_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a8399	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Ex
>1a839d	01 01 01 0f			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_IND
>1a83a1	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>1a83a5	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>1a83a9	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Fx
>1a83ad	03 05 05 0d			                .byte ADDR_ABS, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>1a83b1	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>1a83b5	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>1a83b9	01 01 01 02 01 01 02 02		ADDR_LENGTH     .byte 1, 1, 1, 2, 1, 1, 2, 2, 0, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 0, 2, 2, 2, 2
>1a83c1	00 01 01 03 01 01 03 01 02 01 01 00 02 02 02 02
.1a83d1					ADDR_PATTERNS
>1a83d1	41 00				            .null "A"
>1a83d3	08				            .byte ADDR_ACC
>1a83d4	64 64 3a 64 64 64 64 2c		            .null "dd:dddd,X"
>1a83dc	58 00
>1a83de	0e				            .byte ADDR_ABS_X_LONG
>1a83df	64 64 3a 64 64 64 64 00		            .null "dd:dddd"
>1a83e7	0b				            .byte ADDR_ABS_LONG
>1a83e8	64 64 64 64 2c 58 00		            .null "dddd,X"
>1a83ef	07				            .byte ADDR_ABS_X
>1a83f0	64 64 64 64 2c 59 00		            .null "dddd,Y"
>1a83f7	06				            .byte ADDR_ABS_Y
>1a83f8	64 64 64 64 00			            .null "dddd"
>1a83fd	03				            .byte ADDR_ABS
>1a83fe	64 64 2c 58 00			            .null "dd,X"
>1a8403	05				            .byte ADDR_DP_X
>1a8404	64 64 2c 59 00			            .null "dd,Y"
>1a8409	11				            .byte ADDR_DP_Y
>1a840a	64 64 2c 53 00			            .null "dd,S"
>1a840f	09				            .byte ADDR_SP_R
>1a8410	64 64 00			            .null "dd"
>1a8413	01				            .byte ADDR_DP
>1a8414	23 64 64 64 64 00		            .null "#dddd"
>1a841a	c2				            .byte ADDR_IMM | OP_M_EFFECT | OP_X_EFFECT
>1a841b	23 64 64 2c 23 64 64 00		            .null "#dd,#dd"
>1a8423	14				            .byte ADDR_XYC
>1a8424	23 64 64 00			            .null "#dd"
>1a8428	02				            .byte ADDR_IMM
>1a8429	28 64 64 2c 53 29 2c 59		            .null "(dd,S),Y"
>1a8431	00
>1a8432	0c				            .byte ADDR_SP_R_Y
>1a8433	28 64 64 64 64 2c 58 29		            .null "(dddd,X)"
>1a843b	00
>1a843c	10				            .byte ADDR_ABS_X_ID
>1a843d	28 64 64 64 64 29 00		            .null "(dddd)"
>1a8444	10				            .byte ADDR_ABS_X_ID
>1a8445	28 64 64 2c 58 29 00		            .null "(dd,X)"
>1a844c	00				            .byte ADDR_DP_IND_X
>1a844d	28 64 64 29 2c 59 00		            .null "(dd),Y"
>1a8454	04				            .byte ADDR_DP_IND_Y
>1a8455	28 64 64 29 00			            .null "(dd)"
>1a845a	0f				            .byte ADDR_DP_IND
>1a845b	5b 64 64 64 64 5d 00		            .null "[dddd]"
>1a8462	17				            .byte ADDR_ABS_IND_LONG
>1a8463	5b 64 64 5d 2c 59 00		            .null "[dd],Y"
>1a846a	0d				            .byte ADDR_DP_Y_LONG
>1a846b	5b 64 64 5d 00			            .null "[dd]"
>1a8470	0a				            .byte ADDR_DP_LONG
>1a8471	00 00				                .byte 0, 0

;******  Return to file: src\monitor.s

.1a8473					M_INC_CURSOR
.1a8473	08		php		                PHP
.1a8474	c2 20		rep #$20	            REP #$20
.1a8476	48		pha		                PHA
.1a8477	18		clc		                CLC
.1a8478	af 7a 08 00	lda $00087a	                LDA MCURSOR
.1a847c	69 01 00	adc #$0001	                ADC #1
.1a847f	8f 7a 08 00	sta $00087a	                STA MCURSOR
.1a8483	e2 20		sep #$20	            SEP #$20
.1a8485	af 7c 08 00	lda $00087c	                LDA MCURSOR+2
.1a8489	69 00		adc #$00	                ADC #0
.1a848b	8f 7c 08 00	sta $00087c	                STA MCURSOR+2
.1a848f	c2 20		rep #$20	            REP #$20
.1a8491	68		pla		                PLA
.1a8492	28		plp		                PLP
.1a8493	6b		rtl		                RTL
.1a8494					MPRINTB
.1a8494	08		php		                PHP
.1a8495	c2 10		rep #$10	            REP #$10
.1a8497	e2 20		sep #$20	            SEP #$20
.1a8499	da		phx		                PHX
.1a849a	a2 08 00	ldx #$0008	                LDX #8          ; Set number of bits to print to 8
.1a849d	0a		asl a		loop            ASL A           ; Shift MSB to C
.1a849e	b0 08		bcs $1a84a8	                BCS is_one
.1a84a0	48		pha		                PHA             ; Save value to print
.1a84a1	a9 30		lda #$30	                LDA #'0'        ; Print '0'
.1a84a3	20 18 00	jsr $1a0018	            JSR PRINTC
.1a84a6	80 06		bra $1a84ae	                BRA continue
.1a84a8	48		pha		is_one          PHA             ; Save value to print
.1a84a9	a9 31		lda #$31	                LDA #'1'        ; Print '1'
.1a84ab	20 18 00	jsr $1a0018	            JSR PRINTC
.1a84ae	68		pla		continue        PLA
.1a84af	ca		dex		                DEX             ; Count down the bits to shift
.1a84b0	d0 eb		bne $1a849d	                BNE loop        ; And try the next one if there is one
.1a84b2	fa		plx		                PLX             ; Otherwise, return
.1a84b3	28		plp		                PLP
.1a84b4	6b		rtl		                RTL
.1a84b5					MSKIPWS
.1a84b5	08		php		            PHP
.1a84b6	c2 20		rep #$20	            REP #$20
.1a84b8	48		pha		            PHA
.1a84b9	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a84bc	5b		tcd		            TCD
.1a84bd	68		pla		            PLA
.1a84be	28		plp		            PLP
.1a84bf	e2 20		sep #$20	            SEP #$20
.1a84c1	a7 32		lda [$087a]	loop            LDA [MCURSOR]       ; Check the current character
.1a84c3	f0 0a		beq $1a84cf	                BEQ done            ; If NULL, we're done
.1a84c5	c9 20		cmp #$20	                CMP #' '            ; Is it a space?
.1a84c7	d0 06		bne $1a84cf	                BNE done            ; No: we're done
.1a84c9	22 73 84 1a	jsl $1a8473	                JSL M_INC_CURSOR    ; Yes, try the next one
.1a84cd	80 f2		bra $1a84c1	                BRA loop
.1a84cf	6b		rtl		done            RTL
.1a84d0					MPARSESTR
.1a84d0	08		php		                PHP
.1a84d1	08		php		            PHP
.1a84d2	c2 20		rep #$20	            REP #$20
.1a84d4	48		pha		            PHA
.1a84d5	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a84d8	5b		tcd		            TCD
.1a84d9	68		pla		            PLA
.1a84da	28		plp		            PLP
.1a84db	22 73 84 1a	jsl $1a8473	                JSL M_INC_CURSOR                ; Point to the first character of the name
.1a84df	22 b5 84 1a	jsl $1a84b5	                JSL MSKIPWS                     ; Skip white space
.1a84e3	c2 30		rep #$30	            REP #$30
.1a84e5	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.1a84e7	c2 20		rep #$20	            REP #$20
.1a84e9	29 ff 00	and #$00ff	                AND #$00FF
.1a84ec	0a		asl a		                ASL A                           ; multiply it by forfour
.1a84ed	0a		asl a		                ASL A
.1a84ee	aa		tax		                TAX                             ; ... to get the index to the argument
.1a84ef	a5 32		lda $087a	                LDA MCURSOR                     ; Set the argument to the address of the first byte
.1a84f1	95 0d		sta $0855,x	                STA MARG1,X
.1a84f3	a5 34		lda $087c	                LDA MCURSOR+2
.1a84f5	95 0f		sta $0857,x	                STA MARG1+2,X
.1a84f7	e2 20		sep #$20	            SEP #$20
.1a84f9	a7 32		lda [$087a]	loop            LDA [MCURSOR]                   ; Scan to the closing double quote
.1a84fb	f0 14		beq $1a8511	                BEQ done                        ; If NULL... treat it as a closed argument
.1a84fd	c9 22		cmp #$22	                CMP #CHAR_DQUOTE
.1a84ff	f0 06		beq $1a8507	                BEQ close_string
.1a8501	22 73 84 1a	jsl $1a8473	                JSL M_INC_CURSOR
.1a8505	80 f2		bra $1a84f9	                BRA loop
.1a8507	a9 00		lda #$00	close_string    LDA #0                          ; Write a NULL to close the string
.1a8509	87 32		sta [$087a]	                STA [MCURSOR]
.1a850b	22 73 84 1a	jsl $1a8473	                JSL M_INC_CURSOR                ; And point to the next byte
.1a850f	e6 31		inc $0879	                INC MARG_LEN
.1a8511	28		plp		done            PLP
.1a8512	6b		rtl		                RTL
.1a8513					MPARSEARG
.1a8513	08		php		            PHP
.1a8514	c2 20		rep #$20	            REP #$20
.1a8516	48		pha		            PHA
.1a8517	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.1a851a	5b		tcd		            TCD
.1a851b	68		pla		            PLA
.1a851c	28		plp		            PLP
.1a851d	e2 20		sep #$20	            SEP #$20
.1a851f	64 4a		stz $0892	                STZ MTEMP                       ; Use MTEMP as a flag for having processed digits
.1a8521	c2 20		rep #$20	            REP #$20
.1a8523	64 50		stz $0898	                STZ MPARSEDNUM                  ; Clear the parsed number
.1a8525	64 52		stz $089a	                STZ MPARSEDNUM+2
.1a8527					pa_loop
.1a8527	e2 20		sep #$20	            SEP #$20
.1a8529	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Get the current character
.1a852b	c9 3a		cmp #$3a	                CMP #":"
.1a852d	f0 0d		beq $1a853c	                BEQ pa_next_char                ; Ignore any colons
.1a852f	20 be 03	jsr $1a03be	            JSR ISHEX
.1a8532	90 0e		bcc $1a8542	                BCC finished_arg                ; No? We're done with this argument
.1a8534	22 ab 79 1a	jsl $1a79ab	                JSL AS_SHIFT_HEX                ; Yes: shift it onto MPARSEDNUM
.1a8538	a9 01		lda #$01	                LDA #1                          ; Flag that we've processed a character
.1a853a	85 4a		sta $0892	                STA MTEMP
.1a853c	22 73 84 1a	jsl $1a8473	pa_next_char    JSL M_INC_CURSOR                ; And try the next character
.1a8540	80 e5		bra $1a8527	                BRA pa_loop
.1a8542	a5 4a		lda $0892	finished_arg    LDA MTEMP                       ; Check to see if we've processed any characters
.1a8544	f0 16		beq $1a855c	                BEQ done                        ; No: we're done
.1a8546	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.1a8548	c2 20		rep #$20	            REP #$20
.1a854a	29 ff 00	and #$00ff	                AND #$00FF
.1a854d	0a		asl a		                ASL A                           ; multiply it by forfour
.1a854e	0a		asl a		                ASL A
.1a854f	aa		tax		                TAX                             ; ... to get the index to the argument
.1a8550	a5 50		lda $0898	                LDA MPARSEDNUM                  ; Copy the value to the argument slot
.1a8552	95 0d		sta $0855,x	                STA MARG1,X
.1a8554	a5 52		lda $089a	                LDA MPARSEDNUM+2
.1a8556	95 0f		sta $0857,x	                STA MARG1+2,X
.1a8558	e2 20		sep #$20	            SEP #$20
.1a855a	e6 31		inc $0879	                INC MARG_LEN                    ; And bump up the argument count
.1a855c	6b		rtl		done            RTL
.1a855d					MPARSEALLARG
.1a855d	e2 20		sep #$20	            SEP #$20
.1a855f	64 31		stz $0879	                STZ MARG_LEN                    ; Set the arg count to 0
.1a8561	22 b5 84 1a	jsl $1a84b5	parse_arg       JSL MSKIPWS                     ; Otherwise, skip white space
.1a8565	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Check the current character
.1a8567	f0 21		beq $1a858a	                BEQ done                        ; If it is NULL, we're done
.1a8569	c9 22		cmp #$22	                CMP #CHAR_DQUOTE                ; Is it a double-quote?
.1a856b	d0 06		bne $1a8573	                BNE regular_arg
.1a856d	22 d0 84 1a	jsl $1a84d0	                JSL MPARSESTR                   ; Yes: parse it as a string argument
.1a8571	80 0a		bra $1a857d	                BRA check_rest
.1a8573	22 13 85 1a	jsl $1a8513	regular_arg     JSL MPARSEARG                   ; Attempt to parse the argument
.1a8577	a5 31		lda $0879	                LDA MARG_LEN                    ; Check how many arguments we've processed
.1a8579	c9 09		cmp #$09	                CMP #9
.1a857b	b0 0d		bcs $1a858a	                BGE done                        ; If >=9, then we're done
.1a857d	a7 32		lda [$087a]	check_rest      LDA [MCURSOR]                   ; Check the current character
.1a857f	f0 09		beq $1a858a	                BEQ done                        ; If EOL: we're done
.1a8581	c9 20		cmp #$20	                CMP #' '
.1a8583	f0 dc		beq $1a8561	                BEQ parse_arg                   ; If space: try to process another argument
.1a8585	20 be 03	jsr $1a03be	            JSR ISHEX
.1a8588	b0 d7		bcs $1a8561	                BCS parse_arg                   ; If hex digit: try to process another argument
.1a858a	6b		rtl		done            RTL
.1a858b					IMPARSE
.1a858b	08		php		                PHP
.1a858c	0b		phd		                PHD
.1a858d	08		php		            PHP
.1a858e	c2 20		rep #$20	            REP #$20
.1a8590	48		pha		            PHA
.1a8591	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.1a8594	5b		tcd		            TCD
.1a8595	68		pla		            PLA
.1a8596	28		plp		            PLP
.1a8597	c2 10		rep #$10	            REP #$10
.1a8599	e2 20		sep #$20	            SEP #$20
.1a859b	a2 31 00	ldx #$0031	                LDX #MARG_LEN - MONITOR_VARS    ; Clear the monitor command line parameters
.1a859e	74 00		stz $0848,x	clear_command   STZ MONITOR_VARS,X
.1a85a0	ca		dex		                DEX
.1a85a1	d0 fb		bne $1a859e	                BNE clear_command
.1a85a3	a9 00		lda #$00	                LDA #`INPUTBUF                  ; Point the command parser to the input buffer
.1a85a5	85 02		sta $084a	                STA MCMDADDR+2
.1a85a7	85 34		sta $087c	                STA MCURSOR+2                   ; And point MCURSOR there too
.1a85a9	c2 20		rep #$20	            REP #$20
.1a85ab	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF
.1a85ae	85 00		sta $0848	                STA MCMDADDR
.1a85b0	85 32		sta $087a	                STA MCURSOR
.1a85b2	e2 20		sep #$20	            SEP #$20
.1a85b4	22 b5 84 1a	jsl $1a84b5	                JSL MSKIPWS                     ; Skip to the first letter of the command
.1a85b8	c9 00		cmp #$00	                CMP #0                          ; Is the current character a NULL?
.1a85ba	f0 38		beq $1a85f4	                BEQ done                        ; Yes: there's no command here
.1a85bc	c2 20		rep #$20	            REP #$20
.1a85be	a5 32		lda $087a	                LDA MCURSOR
.1a85c0	85 08		sta $0850	                STA MCMD
.1a85c2	e2 20		sep #$20	            SEP #$20
.1a85c4	a5 34		lda $087c	                LDA MCURSOR+2
.1a85c6	85 0a		sta $0852	                STA MCMD+2
.1a85c8	a2 01 00	ldx #$0001	                LDX #1
.1a85cb	22 73 84 1a	jsl $1a8473	cmd_loop        JSL M_INC_CURSOR                ; Move to the next character
.1a85cf	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; What is that character?
.1a85d1	d0 06		bne $1a85d9	                BNE cmd_space                   ; If not NULL: check for a space
.1a85d3	86 0b		stx $0853	no_arguments    STX MCMD_LEN                    ; If NULL: Save the length of the command
.1a85d5	64 31		stz $0879	                STZ MARG_LEN                    ; ... And the fact there are no arguments
.1a85d7	80 1b		bra $1a85f4	                BRA done                        ; ... And return
.1a85d9	c9 20		cmp #$20	cmd_space       CMP #' '                        ; Is it a space?
.1a85db	f0 03		beq $1a85e0	                BEQ found_cmd                   ; Yes: save the length
.1a85dd	e8		inx		                INX                             ; No: go to the next character
.1a85de	80 eb		bra $1a85cb	                BRA cmd_loop
.1a85e0	86 0b		stx $0853	found_cmd       STX MCMD_LEN                    ; Save the length of the command
.1a85e2	a9 00		lda #$00	                LDA #0
.1a85e4	87 32		sta [$087a]	                STA [MCURSOR]                   ; Write a NULL to the end of the command
.1a85e6	22 73 84 1a	jsl $1a8473	                JSL M_INC_CURSOR                ; And skip to the next character
.1a85ea	a7 08		lda [$0850]	                LDA [MCMD]                      ; Check the command
.1a85ec	c9 41		cmp #$41	                CMP #'A'
.1a85ee	f0 07		beq $1a85f7	                BEQ parse_asm                   ; If 'A', parse the line for the assemble command
.1a85f0	22 5d 85 1a	jsl $1a855d	                JSL MPARSEALLARG
.1a85f4	2b		pld		done            PLD
.1a85f5	28		plp		                PLP
.1a85f6	6b		rtl		                RTL
.1a85f7	22 b5 84 1a	jsl $1a84b5	parse_asm       JSL MSKIPWS                     ; Skip to the first letter of the address
.1a85fb	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a85fd	f0 f5		beq $1a85f4	                BEQ done                        ; Exit if we got the end-of-line
.1a85ff	22 13 85 1a	jsl $1a8513	                JSL MPARSEARG                   ; Parse the first argument as the target address
.1a8603	22 b5 84 1a	jsl $1a84b5	                JSL MSKIPWS                     ; Skip to the first letter of the mnemonic
.1a8607	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a8609	f0 e9		beq $1a85f4	                BEQ done                        ; Exit if we got the end-of-line
.1a860b	c2 20		rep #$20	            REP #$20
.1a860d	a5 32		lda $087a	                LDA MCURSOR                     ; Save pointer to the start of the mnemonic
.1a860f	85 11		sta $0859	                STA MARG2
.1a8611	e2 20		sep #$20	            SEP #$20
.1a8613	a5 34		lda $087c	                LDA MCURSOR+2
.1a8615	85 13		sta $085b	                STA MARG2+2
.1a8617	22 73 84 1a	jsl $1a8473	asm_find_sp     JSL M_INC_CURSOR                ; Find the space at the end of the mnemonic
.1a861b	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a861d	f0 26		beq $1a8645	                BEQ asm_no_operand              ; If EOL: we have an instruction but no operand
.1a861f	c9 20		cmp #$20	                CMP #' '
.1a8621	d0 f4		bne $1a8617	                BNE asm_find_sp
.1a8623	a9 00		lda #$00	                LDA #0
.1a8625	87 32		sta [$087a]	                STA [MCURSOR]                   ; Null terminate the mnemonic
.1a8627	e6 31		inc $0879	                INC MARG_LEN                    ; Count the mnemonic as an argument
.1a8629	22 73 84 1a	jsl $1a8473	                JSL M_INC_CURSOR
.1a862d	22 b5 84 1a	jsl $1a84b5	                JSL MSKIPWS                     ; Skip to the addressing mode
.1a8631	a7 32		lda [$087a]	                LDA [MCURSOR]
.1a8633	f0 bf		beq $1a85f4	                BEQ done                        ; If EOL: we're done
.1a8635	c2 20		rep #$20	            REP #$20
.1a8637	a5 32		lda $087a	                LDA MCURSOR                     ; Set the pointer to the addressing mode
.1a8639	85 15		sta $085d	                STA MARG3
.1a863b	e2 20		sep #$20	            SEP #$20
.1a863d	a5 34		lda $087c	                LDA MCURSOR+2
.1a863f	85 17		sta $085f	                STA MARG3+2
.1a8641	e6 31		inc $0879	                INC MARG_LEN                    ; And count it as the second argument
.1a8643	80 af		bra $1a85f4	                BRA done                        ; and return
.1a8645	e6 31		inc $0879	asm_no_operand  INC MARG_LEN                    ; Increment the argument count
.1a8647	80 ab		bra $1a85f4	                BRA done                        ; And quit
.1a8649					IMLOAD
.1a8649	08		php		                PHP
.1a864a	c2 10		rep #$10	            REP #$10
.1a864c	e2 20		sep #$20	            SEP #$20
.1a864e	a5 31		lda $0879	                LDA MARG_LEN
.1a8650	d0 0f		bne $1a8661	                BNE get_arguments
.1a8652	a2 3f 87	ldx #$873f	bad_arguments   LDX #<>MERRARGS                 ; Print bad arguments error
.1a8655	a9 1a		lda #$1a	                LDA #`MERRARGS
.1a8657	48		pha		                PHA
.1a8658	ab		plb		                PLB
.1a8659	20 16 03	jsr $1a0316	            JSR PRINTS
.1a865c	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a865f	80 61		bra $1a86c2	                BRA done
.1a8661					get_arguments
.1a8661	c2 20		rep #$20	            REP #$20
.1a8663	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.1a8665	8f 23 08 00	sta $000823	                STA ARGUMENT1
.1a8669	a5 0f		lda $0857	                LDA MARG1+2
.1a866b	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.1a866f	20 2f 68	jsr $1a682f	            JSR SETFILEDESC
.1a8672	e2 20		sep #$20	            SEP #$20
.1a8674	a5 31		lda $0879	                LDA MARG_LEN
.1a8676	c9 01		cmp #$01	                CMP #1
.1a8678	d0 0f		bne $1a8689	                BNE get_dest
.1a867a	c2 20		rep #$20	            REP #$20
.1a867c	a9 ff ff	lda #$ffff	                LDA #$FFFF                      ; Destination address not provided...
.1a867f	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR              ; ... set it to something sane
.1a8683	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a8687	80 0e		bra $1a8697	                BRA try_load
.1a8689					get_dest
.1a8689	c2 20		rep #$20	            REP #$20
.1a868b	a5 11		lda $0859	                LDA MARG2                       ; Set the destination address from the arguments
.1a868d	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.1a8691	a5 13		lda $085b	                LDA MARG2+2
.1a8693	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.1a8697	22 18 11 00	jsl $001118	try_load        JSL FK_LOAD                     ; Try to load the file
.1a869b	b0 25		bcs $1a86c2	                BCS done
.1a869d					error
.1a869d	e2 20		sep #$20	            SEP #$20
.1a869f	a2 65 87	ldx #$8765	                LDX #<>MCANTLOAD                ; Print bad arguments error
.1a86a2	a9 1a		lda #$1a	                LDA #`MCANTLOAD
.1a86a4	48		pha		                PHA
.1a86a5	ab		plb		                PLB
.1a86a6	20 16 03	jsr $1a0316	            JSR PRINTS
.1a86a9	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.1a86ad	20 40 03	jsr $1a0340	            JSR PRHEXB
.1a86b0	a9 20		lda #$20	                LDA #' '
.1a86b2	20 18 00	jsr $1a0018	            JSR PRINTC
.1a86b5	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.1a86b9	20 40 03	jsr $1a0340	            JSR PRHEXB
.1a86bc	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a86bf	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a86c2	28		plp		done            PLP
.1a86c3	6b		rtl		                RTL
.1a86c4					IMSAVE
.1a86c4	8b		phb		                PHB
.1a86c5	08		php		                PHP
.1a86c6	c2 10		rep #$10	            REP #$10
.1a86c8	e2 20		sep #$20	            SEP #$20
.1a86ca	a5 31		lda $0879	                LDA MARG_LEN
.1a86cc	c9 03		cmp #$03	                CMP #3
.1a86ce	f0 0f		beq $1a86df	                BEQ get_arguments
.1a86d0	a2 3f 87	ldx #$873f	                LDX #<>MERRARGS                 ; Print bad arguments error
.1a86d3	a9 1a		lda #$1a	                LDA #`MERRARGS
.1a86d5	48		pha		                PHA
.1a86d6	ab		plb		                PLB
.1a86d7	20 16 03	jsr $1a0316	            JSR PRINTS
.1a86da	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a86dd	80 54		bra $1a8733	                BRA done
.1a86df					get_arguments
.1a86df	c2 20		rep #$20	            REP #$20
.1a86e1	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.1a86e3	8f 23 08 00	sta $000823	                STA ARGUMENT1
.1a86e7	a5 0f		lda $0857	                LDA MARG1+2
.1a86e9	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.1a86ed	20 2f 68	jsr $1a682f	            JSR SETFILEDESC
.1a86f0	a5 11		lda $0859	                LDA MARG2                       ; Set the starting address
.1a86f2	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.1a86f6	a5 13		lda $085b	                LDA MARG2+2
.1a86f8	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.1a86fc	a5 15		lda $085d	                LDA MARG3                       ; Set the ending address
.1a86fe	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.1a8702	a5 17		lda $085f	                LDA MARG3+2
.1a8704	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.1a8708	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                     ; Save the data
.1a870c	b0 25		bcs $1a8733	                BCS done
.1a870e					error
.1a870e	e2 20		sep #$20	            SEP #$20
.1a8710	a2 4f 87	ldx #$874f	                LDX #<>MCANTSAVE                ; Print bad arguments error
.1a8713	a9 1a		lda #$1a	                LDA #`MCANTSAVE
.1a8715	48		pha		                PHA
.1a8716	ab		plb		                PLB
.1a8717	20 16 03	jsr $1a0316	            JSR PRINTS
.1a871a	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.1a871e	20 40 03	jsr $1a0340	            JSR PRHEXB
.1a8721	a9 20		lda #$20	                LDA #' '
.1a8723	20 18 00	jsr $1a0018	            JSR PRINTC
.1a8726	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.1a872a	20 40 03	jsr $1a0340	            JSR PRHEXB
.1a872d	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a8730	20 89 02	jsr $1a0289	            JSR PRINTCR
.1a8733	28		plp		done            PLP
.1a8734	ab		plb		                PLB
.1a8735	6b		rtl		                RTL
.1a8736	5c fe 25 1a	jmp $1a25fe	IMEXIT          JML INTERACT
.1a873a	6b		rtl		IMRETURN        RTL ; Handle RETURN key (ie: execute command)
.1a873b	00		brk #		IMPARSE1        BRK ; Parse one word on the current command line
.1a873c	00		brk #		IMASSEMBLEA     BRK ; Assemble a line of text.
.1a873d	00		brk #		IMVERIFY        BRK ; Verify memory and file on disk
.1a873e	00		brk #		IMDOS           BRK ; Execute DOS command
.1a873f					MMESSAGES
>1a873f	42 61 64 20 61 72 67 75		MERRARGS        .null "Bad arguments",CHAR_CR,CHAR_CR
>1a8747	6d 65 6e 74 73 0d 0d 00
>1a874f	55 6e 61 62 6c 65 20 74		MCANTSAVE       .null "Unable to save file: "
>1a8757	6f 20 73 61 76 65 20 66 69 6c 65 3a 20 00
>1a8765	55 6e 61 62 6c 65 20 74		MCANTLOAD       .null "Unable to load file: "
>1a876d	6f 20 6c 6f 61 64 20 66 69 6c 65 3a 20 00
>1a877b	0d 20 20 50 43 20 20 20		mregisters_msg  .null $0D,"  PC     A    X    Y    SP   DBR DP   NVMXDIZC",CHAR_CR
>1a8783	20 20 41 20 20 20 20 58 20 20 20 20 59 20 20 20
>1a8793	20 53 50 20 20 20 44 42 52 20 44 50 20 20 20 4e
>1a87a3	56 4d 58 44 49 5a 43 0d 00
>1a87ac	41 43 44 46 47 4a 48 4c		MCOMMANDS       .null "ACDFGJHLMR;STVWX>?"
>1a87b4	4d 52 3b 53 54 56 57 58 3e 3f 00

;******  Return to file: src\basic816.s

.1a87bf	18		clc		START       CLC                 ; Go to native mode
.1a87c0	fb		xce		            XCE
.1a87c1	08		php		            PHP
.1a87c2	c2 20		rep #$20	            REP #$20
.1a87c4	48		pha		            PHA
.1a87c5	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.1a87c8	5b		tcd		            TCD
.1a87c9	68		pla		            PLA
.1a87ca	28		plp		            PLP
.1a87cb	08		php		            PHP
.1a87cc	e2 20		sep #$20	            SEP #$20
.1a87ce	48		pha		            PHA
.1a87cf	a9 00		lda #$00	            LDA #BASIC_BANK
.1a87d1	48		pha		            PHA
.1a87d2	ab		plb		            PLB
.1a87d3	68		pla		            PLA
.1a87d4	28		plp		            PLP
.1a87d5	c2 30		rep #$30	            REP #$30
.1a87d7	20 fe 87	jsr $1a87fe	            JSR INITBASIC
.1a87da	a9 ff fe	lda #$feff	            LDA #STACK_END      ; Set the system stack
.1a87dd	1b		tcs		            TCS
.1a87de	08		php		            PHP
.1a87df	e2 20		sep #$20	            SEP #$20
.1a87e1	48		pha		            PHA
.1a87e2	a9 1a		lda #$1a	            LDA #`GREET
.1a87e4	48		pha		            PHA
.1a87e5	ab		plb		            PLB
.1a87e6	68		pla		            PLA
.1a87e7	28		plp		            PLP
.1a87e8	a2 71 d2	ldx #$d271	            LDX #<>GREET
.1a87eb	20 16 03	jsr $1a0316	            JSR PRINTS
.1a87ee	08		php		            PHP
.1a87ef	e2 20		sep #$20	            SEP #$20
.1a87f1	48		pha		            PHA
.1a87f2	a9 00		lda #$00	            LDA #BASIC_BANK
.1a87f4	48		pha		            PHA
.1a87f5	ab		plb		            PLB
.1a87f6	68		pla		            PLA
.1a87f7	28		plp		            PLP
.1a87f8	4c fe 25	jmp $1a25fe	            JMP INTERACT        ; Start accepting input from the user
.1a87fb	4c fb 87	jmp $1a87fb	WAIT        JMP WAIT
.1a87fe					INITBASIC
.1a87fe	08		php		            PHP
.1a87ff	20 d0 01	jsr $1a01d0	            JSR INITIO
.1a8802	20 c1 4d	jsr $1a4dc1	            JSR CMD_NEW
.1a8805	28		plp		            PLP
.1a8806	60		rts		            RTS
>1ad271	43 32 35 36 20 46 6f 65		GREET       .text "C256 Foenix BASIC816 "
>1ad279	6e 69 78 20 42 41 53 49 43 38 31 36 20

;******  Processing file: src\version.s

>1ad286	76 30 2e 32 2e 30 2d 61		.text "v0.2.0-alpha+254"
>1ad28e	6c 70 68 61 2b 32 35 34

;******  Return to file: src\basic816.s

>1ad296	0d 00				            .byte 13,0

;******  End of listing
