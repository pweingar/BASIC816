
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -D SYSTEM=2 -D C256_SKU=1 -D UARTSUPPORT= -D UNITTEST=0 -D TRACE_LEVEL=0 --long-address --flat -b --m65816 --intel-hex -o basic816_3A0000.hex --list=basic816_3A0000.lst --labels=basic816_3A0000.lbl src\basic816.s
; Fri Apr 30 12:54:34 2021

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=2					SYSTEM=2
=1					C256_SKU=1
=					UARTSUPPORT=
=0					UNITTEST=0
=0					TRACE_LEVEL=0

;******  Processing input file: src\basic816.s


;******  Processing file: src\constants.s

=2					SYSTEM_C256 = 2         ; C256 Foenix
=1					SYSTEM_C64 = 1          ; Commodore 64 with SuperCPU
=$03					CHAR_CTRL_C = $03       ; CTRL-C: used as a program interrupt key
=$07					CHAR_BELL = $07         ; Ring the console bell
=$08					CHAR_BS = $08           ; Backspace
=$09					CHAR_TAB = $09          ; TAB
=$0a					CHAR_LF = $0A           ; Linefeed
=$0d					CHAR_CR = $0D           ; Carriage Return
=$0f					CHAR_INS = $0F          ; Insert
=$1b					CHAR_ESC = $1B          ; Escape
=$22					CHAR_DQUOTE = $22       ; Double quote
=$20					CHAR_SP = $20           ; Space
=$7f					CHAR_DEL = $7F          ; Delete
=5					ARGUMENT_SIZE = 5       ; Number of bytes in an argument
=8					VAR_NAME_SIZE = 8       ; Maximum number of characters in a variable name
=0					TYPE_INTEGER = 0        ; 32-bit integer
=1					TYPE_FLOAT = 1          ; Single-precision floating point
=2					TYPE_STRING = 2         ; ASCII string
=$80					TYPE_ARR_INTEGER = $80  ; Array of 32-bit integers
=$81					TYPE_ARR_FLOAT = $81    ; Array of 32-bit floats
=$82					TYPE_ARR_STRING = $82   ; Array of strings
=$7f					TYPE_BINDING = $7F      ; A variable name binding
=$ff					TYPE_NAV = $FF          ; Not-A-Value
=0					ERR_OK = 0              ; No error
=1					ERR_BREAK = 1           ; The user pressed an interrupt key
=2					ERR_SYNTAX = 2          ; A syntax error was found on the current line
=3					ERR_MEMORY = 3          ; Out of memory
=4					ERR_TYPE = 4            ; Type mismatch error
=5					ERR_NOTFOUND = 5        ; Variable not found error
=6					ERR_NOLINE = 6          ; Line number not found
=7					ERR_STACKUNDER = 7      ; Stack underflow error
=8					ERR_STACKOVER = 8       ; Stack overflow error
=9					ERR_RANGE = 9           ; Out-of-range error
=10					ERR_ARGUMENT = 10       ; Bad argument error
=11					ERR_NOFILE = 11         ; File not found error
=12					ERR_NAN = 12            ; Floating point math resulted in something that is not a number
=13					ERR_OVERFLOW = 13       ; Math operation overflowed
=14					ERR_UNDERFLOW = 14      ; Math operation underflowed
=15					ERR_DIV0 = 15           ; Math operation involved a division by zero
=16					ERR_DIRECTORY = 16      ; Error reading the directory
=17					ERR_LOAD = 17           ; Could not load file
=18					ERR_SAVE = 18           ; Could not save a file
=19					ERR_DELETE = 19         ; Could not delete a file
=20					ERR_FILENOTFOUND = 20   ; Could not find the file
=21					ERR_DIRNOTWRITE = 21    ; Could not update the directory entry
=22					ERR_NOTCOPIED = 22      ; Could not copy the file
=23					ERR_DOMAIN = 23         ; Mathematical functions domain error

;******  Return to file: src\basic816.s


;******  Processing file: src\memorymap.s


;******  Processing file: src\C256/mmap_c256.s

=1					SYS_C256_FMX = 1        ; System SKU for C256 Foenix FMX
=2					SYS_C256_USER = 2       ; System SKU for C256 Foenix User

;******  Processing file: src\C256/page_00_inc.s

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				unused_0000      = $000000 ;12 Bytes unused
=$000008				OPL2_ADDY_PTR_LO = $000008  ; THis Points towards the Instruments Database
=$000009				OPL2_ADDY_PTR_MD = $000009
=$00000a				OPL2_ADDY_PTR_HI = $00000A
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;1 Byte Color of next character to be printed to the screen.
=$00001f				COLORPOS         = $00001F ;3 Byte address of cursor's position in the color matrix
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$000026				OPL2_OPERATOR    = $000026 ;
=$000027				OPL2_CHANNEL     = $000027 ;
=$000028				OPL2_REG_REGION  = $000028 ; Offset to the Group of Registers
=$00002a				OPL2_REG_OFFSET  = $00002A ; 2 Bytes (16Bits)
=$00002c				OPL2_IND_ADDY_LL = $00002C ; 2 Bytes Reserved (Only need 3)
=$00002e				OPL2_IND_ADDY_HL = $00002E ; 2 Bytes Reserved (Only need 3)
=$000030				OPL2_NOTE        = $000030 ; 1 Byte
=$000031				OPL2_OCTAVE      = $000031 ; 1 Byte
=$000032				OPL2_PARAMETER0  = $000032 ; 1 Byte - Key On/Feedback
=$000033				OPL2_PARAMETER1  = $000033 ; 1 Byte
=$000034				OPL2_PARAMETER2  = $000034 ; 1 Byte
=$000035				OPL2_PARAMETER3  = $000035 ; 1 Byte
=$000036				OPL2_LOOP        = $000036 ;
=$000036				OPL2_BLOCK       = $000036
=$000038				SDCARD_FILE_PTR  = $000038 ; 3 Bytes Pointer to Filename to open
=$00003c				SDCARD_BYTE_NUM  = $00003C ; 2Bytes
=$00003f				SDCARD_PRSNT_MNT = $00003F ; 1 Byte, Indicate that the SDCard is Present and that it is Mounted
=$000040				BM_CLEAR_SCRN_X  = $000040
=$000042				BM_CLEAR_SCRN_Y  = $000042
=$000040				RAD_STARTLINE    = $000040 ; 1 Byte
=$000041				RAD_PATTERN_IDX  = $000041 ; 1 Byte
=$000042				RAD_LINE         = $000042 ; 1 Byte
=$000043				RAD_LINENUMBER   = $000043 ; 1 Byte
=$000044				RAD_CHANNEL_NUM  = $000044 ; 1 Byte
=$000045				RAD_ISLASTCHAN   = $000045 ; 1 Byte
=$000046				RAD_Y_POINTER    = $000046 ; 2 Bytes
=$000048				RAD_TICK         = $000048
=$00004a				RAD_CHANNEL_DATA = $00004A ; 2 Bytes
=$00004c				RAD_CHANNE_EFFCT = $00004C
=$00004d				RAD_TEMP         = $00004D
=$000050				RAD_ADDR         = $000050 ; 3 bytes to avoid OPL2 errors.
=$000053				RAD_PATTRN       = $000053 ; 1 bytes - offset to patter
=$000054				RAD_PTN_DEST     = $000054 ; 3 bytes - where to write the pattern data
=$000057				RAD_CHANNEL      = $000057 ; 2 bytes - 0 to 8
=$000059				RAD_LAST_NOTE    = $000059 ; 1 if this is the last note
=$00005a				RAD_LINE_PTR     = $00005A ; 2 bytes - offset to memory location
=$000040				BMP_X_SIZE       = $000040 ; 2 Bytes
=$000042				BMP_Y_SIZE       = $000042 ; 2 Bytes
=$000044				BMP_PRSE_SRC_PTR = $000044 ; 3 Bytes
=$000048				BMP_PRSE_DST_PTR = $000048 ; 3 Bytes
=$00004c				BMP_COLOR_PALET  = $00004C ; 2 Bytes
=$00004e				SCRN_X_STRIDE    = $00004E ; 2 Bytes, Basically How many Pixel Accross in Bitmap Mode
=$000050				BMP_FILE_SIZE    = $000050 ; 4 Bytes
=$000054				BMP_POSITION_X   = $000054 ; 2 Bytes Where, the BMP will be position on the X Axis
=$000056				BMP_POSITION_Y   = $000056 ; 2 Bytes Where, the BMP will be position on the Y Axis
=$000058				BMP_PALET_CHOICE = $000058 ;
=$0000e0				MOUSE_PTR        = $0000E0
=$0000e1				MOUSE_POS_X_LO   = $0000E1
=$0000e2				MOUSE_POS_X_HI   = $0000E2
=$0000e3				MOUSE_POS_Y_LO   = $0000E3
=$0000e4				MOUSE_POS_Y_HI   = $0000E4
=$0000f0				USER_TEMP        = $0000F0 ;32 Bytes Temp space for user programs
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000110				DIVIDER_0        = $000110 ;0 Byte  Unsigned divider
=$000110				D0_OPERAND_A     = $000110 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$000112				D0_OPERAND_B     = $000112 ;2 Bytes Divider 0 Divisor ex B in A/B
=$000114				D0_RESULT        = $000114 ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D0_REMAINDER     = $000116 ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000118				DIVIDER_1        = $000118 ;0 Byte  Signed divider
=$000118				D1_OPERAND_A     = $000118 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$00011a				D1_OPERAND_B     = $00011A ;2 Bytes Divider 1 Divisor ex B in A/B
=$00011c				D1_RESULT        = $00011C ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$00011e				D1_REMAINDER     = $00011E ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$000120				ADDER_SIGNED_32  = $000120 ; The 32 Bit Adders takes 12Byte that are NOT RAM Location
=$000140				INT_CONTROLLER   = $000140 ; $000140...$00015F Interrupt Controller
=$000160				TIMER_CONTROLLER = $000160 ; $000160...$00017F Timer0/Timer1/Timer2 Block
=$000160				TIMER_CTRL_REGLL = $000160 ;
=$000161				TIMER_CTRL_REGLH = $000161 ;
=$000162				TIMER_CTRL_REGHL = $000162 ;
=$000163				TIMER_CTRL_REGHH = $000163 ;
=$000240				CPU_REGISTERS    = $000240 ; Byte
=$000240				CPUPC            = $000240 ;2 Bytes Program Counter (PC)
=$000242				CPUPBR           = $000242 ;2 Bytes Program Bank Register (K)
=$000244				CPUA             = $000244 ;2 Bytes Accumulator (A)
=$000246				CPUX             = $000246 ;2 Bytes X Register (X)
=$000248				CPUY             = $000248 ;2 Bytes Y Register (Y)
=$00024a				CPUSTACK         = $00024A ;2 Bytes Stack Pointer (S)
=$00024c				CPUDP            = $00024C ;2 Bytes Direct Page Register (D)
=$00024e				CPUDBR           = $00024E ;1 Byte  Data Bank Register (B)
=$00024f				CPUFLAGS         = $00024F ;1 Byte  Flags (P)
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$000300				FDC_DRIVE        = $000300 ;1 byte - The number of the selected drive
=$000301				FDC_HEAD         = $000301 ;1 byte - The head number (0 or 1)
=$000302				FDC_CYLINDER     = $000302 ;1 byte - The cylinder number
=$000303				FDC_SECTOR       = $000303 ;1 byte - The sector number
=$000304				FDC_SECTOR_SIZE  = $000304 ;1 byte - The sector size code (2 = 512)
=$000305				FDC_SECPERTRK    = $000305 ;1 byte - The number of sectors per track (18 for 1.44 MB floppy)
=$000306				FDC_ST0          = $000306 ;1 byte - Status Register 0
=$000307				FDC_ST1          = $000307 ;1 byte - Status Register 1
=$000308				FDC_ST2          = $000308 ;1 byte - Status Register 2
=$000309				FDC_ST3          = $000309 ;1 byte - Status Register 3
=$00030a				FDC_PCN          = $00030A ;1 byte - Present Cylinder Number
=$00030b				FDC_STATUS       = $00030B ;1 byte - Status of what we think is going on with the FDC:
=$00030c				DIVIDEND         = $00030C ;4 bytes - Dividend for 32-bit division
=$000310				DIVISOR          = $000310 ;4 bytes - Divisor for 32-bit division
=$000314				REMAINDER        = $000314 ;4 bytes - Remainder for 32-bit division
=$000320				SDOS_VARIABLES   = $000320
=$000320				BIOS_STATUS      = $000320      ; 1 byte - Status of any BIOS operation
=$000321				BIOS_DEV         = $000321      ; 1 byte - Block device number for block operations
=$000322				BIOS_LBA         = $000322      ; 4 bytes - Address of block to read/write (this is the physical block, w/o reference to partition)
=$000326				BIOS_BUFF_PTR    = $000326      ; 4 bytes - 24-bit pointer to memory for read/write operations
=$00032a				BIOS_FIFO_COUNT  = $00032A      ; 2 bytes - The number of bytes read on the last block read
=$00032e				DOS_STATUS       = $00032E      ; 1 byte - The error code describing any error with file access
=$000330				DOS_CLUS_ID      = $000330      ; 4 bytes - The cluster desired for a DOS operation
=$000338				DOS_DIR_PTR      = $000338      ; 4 bytes - Pointer to a directory entry (assumed to be within DOS_SECTOR)
=$00033c				DOS_BUFF_PTR     = $00033C      ; 4 bytes - A pointer for DOS cluster read/write operations
=$000340				DOS_FD_PTR       = $000340      ; 4 bytes - A pointer to a file descriptor
=$000344				DOS_FAT_LBA      = $000344      ; 4 bytes - The LBA for a sector of the FAT we need to read/write
=$000348				DOS_TEMP         = $000348      ; 4 bytes - Temporary storage for DOS operations
=$00034c				DOS_FILE_SIZE    = $00034C      ; 4 bytes - The size of a file
=$000350				DOS_SRC_PTR      = $000350      ; 4 bytes - Pointer for transferring data
=$000354				DOS_DST_PTR      = $000354      ; 4 bytes - Pointer for transferring data
=$000358				DOS_END_PTR      = $000358      ; 4 bytes - Pointer to the last byte to save
=$00035c				DOS_RUN_PTR      = $00035C      ; 4 bytes - Pointer for starting a loaded program
=$000360				DOS_RUN_PARAM    = $000360      ; 4 bytes - Pointer to the ASCIIZ string for arguments in loading a program
=$000364				DOS_STR1_PTR     = $000364      ; 4 bytes - pointer to a string
=$000368				DOS_STR2_PTR     = $000368      ; 4 bytes - pointer to a string
=$00036b				DOS_SCRATCH      = $00036B      ; 4 bytes - general purpose short term storage
=$000400				DOS_PATH_BUFF    = $000400      ; 256 bytes - A buffer for path names
=$000500				FDC_PARAMETERS   = $000500      ; 16 bytes - a buffer of parameter data for the FDC
=$000510				FDC_RESULTS      = $000510      ; 16 bytes - Buffer for results of FDC commands
=$000530				FDC_PARAM_NUM    = $000530      ; 1 byte - The number of parameters to send to the FDC (including command)
=$000532				FDC_RESULT_NUM   = $000532      ; 1 byte - The number of results expected
=$000533				FDC_EXPECT_DAT   = $000533      ; 1 byte - 0 = the command expects no data, otherwise expects data
=$000534				FDC_CMD_RETRY    = $000534      ; 1 byte - a retry counter for commands
=$000700				CURRUART         = $000700 ; 3-bytes: the base address of the current UART
=$000703				CHAN_OUT         = $000703 ; 1-byte: the number of the current output channel (for PUTC, etc.)
=$000704				CHAN_IN          = $000704 ; 1-byte: the number of the current input channel (for GETCH, etc.)
=$000705				TIMERFLAGS       = $000705 ; 1-byte: flags to indicate that one of the timer interupts has triggered
=$80					TIMER0TRIGGER    = $80
=$40					TIMER1TRIGGER    = $40
=$20					TIMER2TRIGGER    = $20
=$000f00				KEY_BUFFER       = $000F00 ; 64 Bytes keyboard buffer
=$0080					KEY_BUFFER_SIZE  = $0080   ;128 Bytes (constant) keyboard buffer length
=$000f7f				KEY_BUFFER_END   = $000F7F ;  1 Byte  Last byte of keyboard buffer
=$000f83				KEY_BUFFER_CMD   = $000F83 ;  1 Byte  Indicates the Command Process Status
=$000f84				COMMAND_SIZE_STR = $000F84 ;  1 Byte
=$000f86				COMMAND_COMP_TMP = $000F86 ;  2 Bytes
=$000f87				KEYBOARD_SC_FLG  = $000F87 ;  1 Bytes that indicate the Status of Left Shift, Left CTRL, Left ALT, Right Shift
=$000f88				KEYBOARD_SC_TMP  = $000F88 ;  1 Byte, Interrupt Save Scan Code while Processing
=$000f89				KEYBOARD_LOCKS   = $000F89 ;  1 Byte, the status of the various lock keys
=$000f8a				KEYFLAG          = $000F8A ;  1 Byte, flag to indicate if CTRL-C has been pressed
=$000f8b				KEY_BUFFER_RPOS  = $000F8B ;  2 Byte, position of the character to read from the KEY_BUFFER
=$000f8d				KEY_BUFFER_WPOS  = $000F8D ;  2 Byte, position of the character to write to the KEY_BUFFER
=$001000				KERNEL_JMP_BEGIN = $001000 ; Reserved for the Kernel jump table
=$001fff				KERNEL_JMP_END   = $001FFF
=$002000				TEST_BEGIN       = $002000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/int_math_defs.s

=$000100				UNSIGNED_MULT_A_LO  = $000100
=$000101				UNSIGNED_MULT_A_HI  = $000101
=$000102				UNSIGNED_MULT_B_LO  = $000102
=$000103				UNSIGNED_MULT_B_HI  = $000103
=$000104				UNSIGNED_MULT_AL_LO = $000104
=$000105				UNSIGNED_MULT_AL_HI = $000105
=$000106				UNSIGNED_MULT_AH_LO = $000106
=$000107				UNSIGNED_MULT_AH_HI = $000107
=$000108				SIGNED_MULT_A_LO    = $000108
=$000109				SIGNED_MULT_A_HI    = $000109
=$00010a				SIGNED_MULT_B_LO    = $00010A
=$00010b				SIGNED_MULT_B_HI    = $00010B
=$00010c				SIGNED_MULT_AL_LO   = $00010C
=$00010d				SIGNED_MULT_AL_HI   = $00010D
=$00010e				SIGNED_MULT_AH_LO   = $00010E
=$00010f				SIGNED_MULT_AH_HI   = $00010F
=$000110				UNSIGNED_DIV_DEM_LO = $000110
=$000111				UNSIGNED_DIV_DEM_HI = $000111
=$000112				UNSIGNED_DIV_NUM_LO = $000112
=$000113				UNSIGNED_DIV_NUM_HI = $000113
=$000114				UNSIGNED_DIV_QUO_LO = $000114
=$000115				UNSIGNED_DIV_QUO_HI = $000115
=$000116				UNSIGNED_DIV_REM_LO = $000116
=$000117				UNSIGNED_DIV_REM_HI = $000117
=$000118				SIGNED_DIV_DEM_LO   = $000118
=$000119				SIGNED_DIV_DEM_HI   = $000119
=$00011a				SIGNED_DIV_NUM_LO   = $00011A
=$00011b				SIGNED_DIV_NUM_HI   = $00011B
=$00011c				SIGNED_DIV_QUO_LO   = $00011C
=$00011d				SIGNED_DIV_QUO_HI   = $00011D
=$00011e				SIGNED_DIV_REM_LO   = $00011E
=$00011f				SIGNED_DIV_REM_HI   = $00011F
=$000120				ADDER32_A_LL        = $000120
=$000121				ADDER32_A_LH        = $000121
=$000122				ADDER32_A_HL        = $000122
=$000123				ADDER32_A_HH        = $000123
=$000124				ADDER32_B_LL        = $000124
=$000125				ADDER32_B_LH        = $000125
=$000126				ADDER32_B_HL        = $000126
=$000127				ADDER32_B_HH        = $000127
=$000128				ADDER32_R_LL        = $000128
=$000129				ADDER32_R_LH        = $000129
=$00012a				ADDER32_R_HL        = $00012A
=$00012b				ADDER32_R_HH        = $00012B
=$af1400				SIGNED32_MULT_A     = $AF1400
=$af1404				SIGNED32_MULT_B     = $AF1404
=$af1408				SIGNED32_MULT_OUT   = $AF1408

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/vicky_def.s

=$af0000				MASTER_CTRL_REG_L	      = $AF0000
=$01					Mstr_Ctrl_Text_Mode_En  = $01       ; Enable the Text Mode
=$02					Mstr_Ctrl_Text_Overlay  = $02       ; Enable the Overlay of the text mode on top of Graphic Mode (the Background Color is ignored)
=$04					Mstr_Ctrl_Graph_Mode_En = $04       ; Enable the Graphic Mode
=$08					Mstr_Ctrl_Bitmap_En     = $08       ; Enable the Bitmap Module In Vicky
=$10					Mstr_Ctrl_TileMap_En    = $10       ; Enable the Tile Module in Vicky
=$20					Mstr_Ctrl_Sprite_En     = $20       ; Enable the Sprite Module in Vicky
=$40					Mstr_Ctrl_GAMMA_En      = $40       ; this Enable the GAMMA correction - The Analog and DVI have different color value, the GAMMA is great to correct the difference
=$80					Mstr_Ctrl_Disable_Vid   = $80       ; This will disable the Scanning of the Video hence giving 100% bandwith to the CPU
=$af0001				MASTER_CTRL_REG_H       = $AF0001
=$01					Mstr_Ctrl_Video_Mode0   = $01       ; 0 - 640x480 (Clock @ 25.175Mhz), 1 - 800x600 (Clock @ 40Mhz)
=$02					Mstr_Ctrl_Video_Mode1   = $02       ; 0 - No Pixel Doubling, 1- Pixel Doubling (Reduce the Pixel Resolution by 2)
=$af0002				GAMMA_CTRL_REG          = $AF0002
=$01					GAMMA_Ctrl_Input        = $01 ; 0 = DipSwitch Chooses GAMMA on/off , 1- Software Control
=$02					GAMMA_Ctrl_Soft         = $02 ; 0 = GAMMA Table is not Applied, 1 = GAMMA Table is Applied
=$08					GAMMA_DP_SW_VAL         = $08 ; READ ONLY - Actual DIP Switch Value
=$10					HIRES_DP_SW_VAL         = $10 ; READ ONLY - 0 = Hi-Res on BOOT ON, 1 = Hi-Res on BOOT OFF
=$af0003				VKY_RESERVED_01         = $AF0003
=$01					Border_Ctrl_Enable      = $01
=$af0004				BORDER_CTRL_REG         = $AF0004 ; Bit[0] - Enable (1 by default)  Bit[4..6]: X Scroll Offset ( Will scroll Left) (Acceptable Value: 0..7)
=$af0005				BORDER_COLOR_B          = $AF0005
=$af0006				BORDER_COLOR_G          = $AF0006
=$af0007				BORDER_COLOR_R          = $AF0007
=$af0008				BORDER_X_SIZE           = $AF0008; X-  Values: 0 - 32 (Default: 32)
=$af0009				BORDER_Y_SIZE           = $AF0009; Y- Values 0 -32 (Default: 32)
=$af000d				BACKGROUND_COLOR_B      = $AF000D ; When in Graphic Mode, if a pixel is "0" then the Background pixel is chosen
=$af000e				BACKGROUND_COLOR_G      = $AF000E
=$af000f				BACKGROUND_COLOR_R      = $AF000F ;
=$af0010				VKY_TXT_CURSOR_CTRL_REG = $AF0010   ;[0]  Enable Text Mode
=$01					Vky_Cursor_Enable       = $01
=$02					Vky_Cursor_Flash_Rate0  = $02       ; 00 - 1/Sec, 01 - 2/Sec, 10 - 4/Sec, 11 - 5/Sec
=$04					Vky_Cursor_Flash_Rate1  = $04
=$08					Vky_Cursor_FONT_Page0   = $08       ; Pick Font Page 0 or Font Page 1
=$10					Vky_Cursor_FONT_Page1   = $10       ; Pick Font Page 0 or Font Page 1
=$af0011				VKY_TXT_START_ADD_PTR   = $AF0011   ; This is an offset to change the Starting address of the Text Mode Buffer (in x)
=$af0012				VKY_TXT_CURSOR_CHAR_REG = $AF0012
=$af0013				VKY_TXT_CURSOR_COLR_REG = $AF0013
=$af0014				VKY_TXT_CURSOR_X_REG_L  = $AF0014
=$af0015				VKY_TXT_CURSOR_X_REG_H  = $AF0015
=$af0016				VKY_TXT_CURSOR_Y_REG_L  = $AF0016
=$af0017				VKY_TXT_CURSOR_Y_REG_H  = $AF0017
=$af001b				VKY_LINE_IRQ_CTRL_REG   = $AF001B ;[0] - Enable Line 0, [1] -Enable Line 1
=$af001c				VKY_LINE0_CMP_VALUE_LO  = $AF001C ;Write Only [7:0]
=$af001d				VKY_LINE0_CMP_VALUE_HI  = $AF001D ;Write Only [3:0]
=$af001e				VKY_LINE1_CMP_VALUE_LO  = $AF001E ;Write Only [7:0]
=$af001f				VKY_LINE1_CMP_VALUE_HI  = $AF001F ;Write Only [3:0]
=$af001c				VKY_INFO_CHIP_NUM_L     = $AF001C   ; VErsion
=$af001d				VKY_INFO_CHIP_NUM_H     = $AF001D   ; Version
=$af001e				VKY_INFO_CHIP_VER_L     = $AF001E   ; Sub-Version
=$af001f				VKY_INFO_CHIP_VER_H     = $AF001F   ; Sub-Version
=$af0500				MOUSE_PTR_GRAP0_START    = $AF0500 ; 16 x 16 = 256 Pixels (Grey Scale) 0 = Transparent, 1 = Black , 255 = White
=$af05ff				MOUSE_PTR_GRAP0_END      = $AF05FF ; Pointer 0
=$af0600				MOUSE_PTR_GRAP1_START    = $AF0600 ;
=$af06ff				MOUSE_PTR_GRAP1_END      = $AF06FF ; Pointer 1
=$af0700				MOUSE_PTR_CTRL_REG_L    = $AF0700 ; Bit[0] Enable, Bit[1] = 0  ( 0 = Pointer0, 1 = Pointer1)
=$af0701				MOUSE_PTR_CTRL_REG_H    = $AF0701 ;
=$af0702				MOUSE_PTR_X_POS_L       = $AF0702 ; X Position (0 - 639) (Can only read now) Writing will have no effect
=$af0703				MOUSE_PTR_X_POS_H       = $AF0703 ;
=$af0704				MOUSE_PTR_Y_POS_L       = $AF0704 ; Y Position (0 - 479) (Can only read now) Writing will have no effect
=$af0705				MOUSE_PTR_Y_POS_H       = $AF0705 ;
=$af0706				MOUSE_PTR_BYTE0         = $AF0706 ; Byte 0 of Mouse Packet (you must write 3 Bytes)
=$af0707				MOUSE_PTR_BYTE1         = $AF0707 ; Byte 1 of Mouse Packet (if you don't, then )
=$af0708				MOUSE_PTR_BYTE2         = $AF0708 ; Byte 2 of Mouse Packet (state Machine will be jammed in 1 state)
=$af070b				C256F_MODEL_MAJOR       = $AF070B ;
=$af070c				C256F_MODEL_MINOR       = $AF070C ;
=$af070d				FPGA_DOR                = $AF070D ;
=$af070e				FPGA_MOR                = $AF070E ;
=$af070f				FPGA_YOR                = $AF070F ;
=$af0900				VMEM2CPU_CTRL_REG      = $AF0900  ;
=$01					VMEM2CPU_Clear_FIFO    = $01        ; Setting this to 1 will flush (Reset) the FIFO, clear it after to return to normal function
=$02					VMEM2CPU_Intterupt     = $02        ; This is not implemented because there is not enough Interrupt line on the FMX
=$af0901				VMEM2CPU_Data_Port     = $AF0901    ; This is a Byte Port of the data that you have requested. (Output of the FIFO)
=$af0902				VMEM2CPU_Fifo_Count_LO = $AF0902    ; FIFO Count Lo (number of byte in the FIFO) FIFO Count is 10bits, Count_Bit0 to Count_Bit7 of Count
=$af0903				VMEM2CPU_Fifo_Count_HI = $AF0903    ; FIFO Count Hi, Bit 0 = Count_Bit8, Bit 1 = Count_Bit9
=$80					VMEM2CPU_Fifo_Empty    = $80        ; Bit 7 of VMEM2CPU_Fifo_Count_HI, when 1, the FIFO is empty.
=$af1f40				FG_CHAR_LUT_PTR         = $AF1F40
=$af1f80				BG_CHAR_LUT_PTR		    = $AF1F80
=$af2000				GRPH_LUT0_PTR		    = $AF2000
=$af2400				GRPH_LUT1_PTR		    = $AF2400
=$af2800				GRPH_LUT2_PTR		    = $AF2800
=$af2c00				GRPH_LUT3_PTR		    = $AF2C00
=$af3000				GRPH_LUT4_PTR		    = $AF3000
=$af3400				GRPH_LUT5_PTR		    = $AF3400
=$af3800				GRPH_LUT6_PTR		    = $AF3800
=$af3c00				GRPH_LUT7_PTR		    = $AF3C00
=$af4000				GAMMA_B_LUT_PTR		    = $AF4000
=$af4100				GAMMA_G_LUT_PTR		    = $AF4100
=$af4200				GAMMA_R_LUT_PTR		    = $AF4200
=$af8000				FONT_MEMORY_BANK0       = $AF8000     ;$AF8000 - $AF87FF
=$afa000				CS_TEXT_MEM_PTR         = $AFA000
=$afc000				CS_COLOR_MEM_PTR        = $AFC000

;******  Processing file: src\C256/VKYII_CFP9553_BITMAP_def.s

=$01					BM_Enable             = $01
=$00					BM_LUT0               = $00 ;
=$02					BM_LUT1               = $02 ;
=$04					BM_LUT2               = $04 ;
=$06					BM_LUT3               = $06 ;
=$08					BM_LUT4               = $08 ;
=$0a					BM_LUT5               = $0A ;
=$0c					BM_LUT6               = $0C ;
=$0e					BM_LUT7               = $0E ;
=$af0100				BM0_CONTROL_REG     = $AF0100
=$af0101				BM0_START_ADDY_L    = $AF0101
=$af0102				BM0_START_ADDY_M    = $AF0102
=$af0103				BM0_START_ADDY_H    = $AF0103
=$af0104				BM0_X_OFFSET        = $AF0104   ; Not Implemented
=$af0105				BM0_Y_OFFSET        = $AF0105   ; Not Implemented
=$af0106				BM0_RESERVED_6      = $AF0106
=$af0107				BM0_RESERVED_7      = $AF0107
=$af0108				BM1_CONTROL_REG     = $AF0108
=$af0109				BM1_START_ADDY_L    = $AF0109
=$af010a				BM1_START_ADDY_M    = $AF010A
=$af010b				BM1_START_ADDY_H    = $AF010B
=$af010c				BM1_X_OFFSET        = $AF010C   ; Not Implemented
=$af010d				BM1_Y_OFFSET        = $AF010D   ; Not Implemented
=$af010e				BM1_RESERVED_6      = $AF010E
=$af010f				BM1_RESERVED_7      = $AF010F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_TILEMAP_def.s

=$01					TILE_Enable             = $01
=0					TILEMAP_CONTROL         = 0             ; Offset to a tile map's control register
=1					TILEMAP_START_ADDY      = 1             ; Offset to a tile map's address
=4					TILEMAP_TOTAL_X         = 4             ; Offset to a tile map's width
=6					TILEMAP_TOTAL_Y         = 6             ; Offset to a tile map's height
=8					TILEMAP_WINDOW_X        = 8             ; Offset to a tile map's X position
=10					TILEMAP_WINDOW_Y        = 10            ; Offset to a tile map's Y position
=1					TILEMAP_VISIBLE         = 1             ; Tile map is visible flag
=$af0200				TL0_CONTROL_REG         = $AF0200       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0201				TL0_START_ADDY_L        = $AF0201       ; Not USed right now - Starting Address to where is the MAP
=$af0202				TL0_START_ADDY_M        = $AF0202
=$af0203				TL0_START_ADDY_H        = $AF0203
=$af0204				TL0_TOTAL_X_SIZE_L      = $AF0204       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0205				TL0_TOTAL_X_SIZE_H      = $AF0205
=$af0206				TL0_TOTAL_Y_SIZE_L      = $AF0206       ; Size of the Map in Y Tile Count [9:0]
=$af0207				TL0_TOTAL_Y_SIZE_H      = $AF0207
=$af0208				TL0_WINDOW_X_POS_L      = $AF0208       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0209				TL0_WINDOW_X_POS_H      = $AF0209       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af020a				TL0_WINDOW_Y_POS_L      = $AF020A       ; Top Left Corner Position of the TileMAp Window in Y
=$af020b				TL0_WINDOW_Y_POS_H      = $AF020B       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af020c				TL1_CONTROL_REG         = $AF020C       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af020d				TL1_START_ADDY_L        = $AF020D       ; Not USed right now - Starting Address to where is the MAP
=$af020e				TL1_START_ADDY_M        = $AF020E
=$af020f				TL1_START_ADDY_H        = $AF020F
=$af0210				TL1_TOTAL_X_SIZE_L      = $AF0210       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0211				TL1_TOTAL_X_SIZE_H      = $AF0211
=$af0212				TL1_TOTAL_Y_SIZE_L      = $AF0212       ; Size of the Map in Y Tile Count [9:0]
=$af0213				TL1_TOTAL_Y_SIZE_H      = $AF0213
=$af0214				TL1_WINDOW_X_POS_L      = $AF0214       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0215				TL1_WINDOW_X_POS_H      = $AF0215       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0216				TL1_WINDOW_Y_POS_L      = $AF0216       ; Top Left Corner Position of the TileMAp Window in Y
=$af0217				TL1_WINDOW_Y_POS_H      = $AF0217       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0218				TL2_CONTROL_REG         = $AF0218       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0219				TL2_START_ADDY_L        = $AF0219       ; Not USed right now - Starting Address to where is the MAP
=$af021a				TL2_START_ADDY_M        = $AF021A
=$af021b				TL2_START_ADDY_H        = $AF021B
=$af021c				TL2_TOTAL_X_SIZE_L      = $AF021C       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af021d				TL2_TOTAL_X_SIZE_H      = $AF021D
=$af021e				TL2_TOTAL_Y_SIZE_L      = $AF021E       ; Size of the Map in Y Tile Count [9:0]
=$af021f				TL2_TOTAL_Y_SIZE_H      = $AF021F
=$af0220				TL2_WINDOW_X_POS_L      = $AF0220       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0221				TL2_WINDOW_X_POS_H      = $AF0221       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0222				TL2_WINDOW_Y_POS_L      = $AF0222       ; Top Left Corner Position of the TileMAp Window in Y
=$af0223				TL2_WINDOW_Y_POS_H      = $AF0223       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0224				TL3_CONTROL_REG         = $AF0224       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0225				TL3_START_ADDY_L        = $AF0225       ; Not USed right now - Starting Address to where is the MAP
=$af0226				TL3_START_ADDY_M        = $AF0226
=$af0227				TL3_START_ADDY_H        = $AF0227
=$af0228				TL3_TOTAL_X_SIZE_L      = $AF0228       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0229				TL3_TOTAL_X_SIZE_H      = $AF0229
=$af022a				TL3_TOTAL_Y_SIZE_L      = $AF022A       ; Size of the Map in Y Tile Count [9:0]
=$af022b				TL3_TOTAL_Y_SIZE_H      = $AF022B
=$af022c				TL3_WINDOW_X_POS_L      = $AF022C       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af022d				TL3_WINDOW_X_POS_H      = $AF022D       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af022e				TL3_WINDOW_Y_POS_L      = $AF022E       ; Top Left Corner Position of the TileMAp Window in Y
=$af022f				TL3_WINDOW_Y_POS_H      = $AF022F       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0280				TILESET0_ADDY_L         = $AF0280   ; Pointer to Tileset 0 [21:0]
=$af0281				TILESET0_ADDY_M         = $AF0281
=$af0282				TILESET0_ADDY_H         = $AF0282
=$af0283				TILESET0_ADDY_CFG       = $AF0283   ; [3] - TileStride256x256 [2:0] LUT
=2					TILESET_ADDY_H          = 2             ; Offset to high byte of tile set address
=3					TILESET_ADDY_CFG        = 3             ; Offset to the tile set address configuration
=$08					TILESET_SQUARE_256      = $08
=$af0284				TILESET1_ADDY_L         = $AF0284
=$af0285				TILESET1_ADDY_M         = $AF0285
=$af0286				TILESET1_ADDY_H         = $AF0286
=$af0287				TILESET1_ADDY_CFG       = $AF0287
=$af0288				TILESET2_ADDY_L         = $AF0288
=$af0289				TILESET2_ADDY_M         = $AF0289
=$af028a				TILESET2_ADDY_H         = $AF028A
=$af028b				TILESET2_ADDY_CFG       = $AF028B
=$af028c				TILESET3_ADDY_L         = $AF028C
=$af028d				TILESET3_ADDY_M         = $AF028D
=$af028e				TILESET3_ADDY_H         = $AF028E
=$af028f				TILESET3_ADDY_CFG       = $AF028F
=$af0290				TILESET4_ADDY_L         = $AF0290
=$af0291				TILESET4_ADDY_M         = $AF0291
=$af0292				TILESET4_ADDY_H         = $AF0292
=$af0293				TILESET4_ADDY_CFG       = $AF0293
=$af0294				TILESET5_ADDY_L         = $AF0294
=$af0295				TILESET5_ADDY_M         = $AF0295
=$af0296				TILESET5_ADDY_H         = $AF0296
=$af0297				TILESET5_ADDY_CFG       = $AF0297
=$af0298				TILESET6_ADDY_L         = $AF0298
=$af0299				TILESET6_ADDY_M         = $AF0299
=$af029a				TILESET6_ADDY_H         = $AF029A
=$af029b				TILESET6_ADDY_CFG       = $AF029B
=$af029c				TILESET7_ADDY_L         = $AF029C
=$af029d				TILESET7_ADDY_M         = $AF029D
=$af029e				TILESET7_ADDY_H         = $AF029E
=$af029f				TILESET7_ADDY_CFG       = $AF029F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SDMA_def.s

=$af0420				SDMA_CTRL_REG0           = $AF0420
=$01					SDMA_CTRL0_Enable        = $01
=$02					SDMA_CTRL0_1D_2D         = $02     ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					SDMA_CTRL0_TRF_Fill      = $04     ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					SDMA_CTRL0_Int_Enable    = $08     ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					SDMA_CTRL0_SysRAM_Src    = $10     ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					SDMA_CTRL0_SysRAM_Dst    = $20     ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$00					SDMA_XFER_SRAM2SRAM = $00           ; SRAM -> SRAM transfer
=$10					SDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					SDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$30					SDMA_XFER_SRAMIO = $30              ; SRAM <-> IO transfer (see: SDMA_CONTROL_REG1 for config and direction)
=$40					SDMA_CTLR0_RSVD          = $40      ; Reserved
=$80					SDMA_CTRL0_Start_TRF     = $80      ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$af0421				SDMA_CTRL_REG1           = $AF0421  ; Write Only - Byte to Write in the Fill Function
=$01					SDMA_CTRL1_IO_Src		 = $01		; 1 = Source is an IO Address (ADC, SuperIO, IDE)
=$02					SDMA_CTRL1_IO_Src16		 = $02		; 0 = Src 8Bits Transfer / 1= 16Bits Transfer
=$04					SDMA_CTRL1_IO_Dst		 = $04		; 1 = Destination is an IO Address (DAC, SuperIO, IDE)
=$08					SDMA_CTRL1_IO_Dst16      = $08      ; 0 = Dst 8bits Transfer / 1= 16bits
=$af0422				SDMA_SRC_ADDY_L         = $AF0422   ; Pointer to the Source of the Data to be stransfered
=$af0423				SDMA_SRC_ADDY_M         = $AF0423   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0424				SDMA_SRC_ADDY_H         = $AF0424
=$af0425				SDMA_DST_ADDY_L         = $AF0425   ; Destination Pointer within CPU's video memory Range
=$af0426				SDMA_DST_ADDY_M         = $AF0426   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0427				SDMA_DST_ADDY_H         = $AF0427
=$af0428				SDMA_SIZE_L             = $AF0428   ; Maximum Value: $40:0000 (4Megs)
=$af0429				SDMA_SIZE_M             = $AF0429
=$af042a				SDMA_SIZE_H             = $AF042A
=$af042b				SDMA_IGNORED            = $AF042B
=$af0428				SDMA_X_SIZE_L           = $AF0428   ; Maximum Value: 65535
=$af0429				SDMA_X_SIZE_H           = $AF0429
=$af042a				SDMA_Y_SIZE_L           = $AF042A   ; Maximum Value: 65535
=$af042b				SDMA_Y_SIZE_H           = $AF042B
=$af042c				SDMA_SRC_STRIDE_L       = $AF042C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042d				SDMA_SRC_STRIDE_H       = $AF042D   ;
=$af042e				SDMA_DST_STRIDE_L       = $AF042E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042f				SDMA_DST_STRIDE_H       = $AF042F   ;
=$af0430				SDMA_BYTE_2_WRITE       = $AF0430   ; Write Only - Byte to Write in the Fill Function
=$af0430				SDMA_STATUS_REG         = $AF0430   ; Read only
=$01					SDMA_STAT_Size_Err       = $01      ; If Set to 1, Overall Size is Invalid
=$02					SDMA_STAT_Dst_Add_Err    = $02      ; If Set to 1, Destination Address Invalid
=$04					SDMA_STAT_Src_Add_Err    = $04      ; If Set to 1, Source Address Invalid
=$08					SDMA_STAT_TimeOut_Err    = $08      ; will be set to 1 if a Timeout occur when transfering between data from and to VRAM

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_VDMA_def.s

=$af0400				VDMA_CONTROL_REG        = $AF0400
=$01					VDMA_CTRL_Enable        = $01
=$02					VDMA_CTRL_1D_2D         = $02       ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					VDMA_CTRL_TRF_Fill      = $04       ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					VDMA_CTRL_Int_Enable    = $08       ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					VDMA_CTRL_SysRAM_Src    = $10       ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					VDMA_CTRL_SysRAM_Dst    = $20       ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$80					VDMA_CTRL_Start_TRF     = $80       ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$00					VDMA_XFER_VRAM2VRAM = $00           ; VRAM -> VRAM transfer
=$10					VDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					VDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$af0401				VDMA_BYTE_2_WRITE       = $AF0401   ; Write Only - Byte to Write in the Fill Function
=$af0401				VDMA_STATUS_REG         = $AF0401   ; Read only
=$01					VDMA_STAT_Size_Err      = $01       ; If Set to 1, Overall Size is Invalid
=$02					VDMA_STAT_Dst_Add_Err   = $02       ; If Set to 1, Destination Address Invalid
=$04					VDMA_STAT_Src_Add_Err   = $04       ; If Set to 1, Source Address Invalid
=$80					VDMA_STAT_VDMA_IPS      = $80       ; If Set to 1, VDMA Transfer in Progress (this Inhibit CPU Access to Mem)
=$af0402				VDMA_SRC_ADDY_L         = $AF0402   ; Pointer to the Source of the Data to be stransfered
=$af0403				VDMA_SRC_ADDY_M         = $AF0403   ; This needs to be within Vicky's Range ($00_0000 - $3F_0000)
=$af0404				VDMA_SRC_ADDY_H         = $AF0404
=$af0405				VDMA_DST_ADDY_L         = $AF0405   ; Destination Pointer within Vicky's video memory Range
=$af0406				VDMA_DST_ADDY_M         = $AF0406   ; ($00_0000 - $3F_0000)
=$af0407				VDMA_DST_ADDY_H         = $AF0407
=$af0408				VDMA_SIZE_L             = $AF0408   ; Maximum Value: $40:0000 (4Megs)
=$af0409				VDMA_SIZE_M             = $AF0409
=$af040a				VDMA_SIZE_H             = $AF040A
=$af040b				VDMA_IGNORED            = $AF040B
=$af0408				VDMA_X_SIZE_L           = $AF0408   ; Maximum Value: 65535
=$af0409				VDMA_X_SIZE_H           = $AF0409
=$af040a				VDMA_Y_SIZE_L           = $AF040A   ; Maximum Value: 65535
=$af040b				VDMA_Y_SIZE_H           = $AF040B
=$af040c				VDMA_SRC_STRIDE_L       = $AF040C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040d				VDMA_SRC_STRIDE_H       = $AF040D   ;
=$af040e				VDMA_DST_STRIDE_L       = $AF040E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040f				VDMA_DST_STRIDE_H       = $AF040F   ;

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SPRITE_def.s

=$01					SPRITE_Enable             = $01
=$00					SPRITE_LUT0               = $00 ; This is the LUT that the Sprite will use
=$02					SPRITE_LUT1               = $02
=$04					SPRITE_LUT2               = $04 ; Only 4 LUT for Now, So this bit is not used.
=$06					SPRITE_LUT3               = $06 ; Only 4 LUT for Now, So this bit is not used.
=$08					SPRITE_LUT4               = $08 ; Only 4 LUT for Now, So this bit is not used.
=$0a					SPRITE_LUT5               = $0A ; Only 4 LUT for Now, So this bit is not used.
=$0c					SPRITE_LUT6               = $0C ; Only 4 LUT for Now, So this bit is not used.
=$0e					SPRITE_LUT7               = $0E ; Only 4 LUT for Now, So this bit is not used.
=$00					SPRITE_DEPTH0             = $00
=$10					SPRITE_DEPTH1             = $10
=$20					SPRITE_DEPTH2             = $20
=$30					SPRITE_DEPTH3             = $30
=$40					SPRITE_DEPTH4             = $40
=$50					SPRITE_DEPTH5             = $50
=$60					SPRITE_DEPTH6             = $60
=$af0c00				SP00_CONTROL_REG        = $AF0C00
=$af0c01				SP00_ADDY_PTR_L         = $AF0C01
=$af0c02				SP00_ADDY_PTR_M         = $AF0C02
=$af0c03				SP00_ADDY_PTR_H         = $AF0C03
=$af0c04				SP00_X_POS_L            = $AF0C04
=$af0c05				SP00_X_POS_H            = $AF0C05
=$af0c06				SP00_Y_POS_L            = $AF0C06
=$af0c07				SP00_Y_POS_H            = $AF0C07
=$af0c08				SP01_CONTROL_REG        = $AF0C08
=$af0c09				SP01_ADDY_PTR_L         = $AF0C09
=$af0c0a				SP01_ADDY_PTR_M         = $AF0C0A
=$af0c0b				SP01_ADDY_PTR_H         = $AF0C0B
=$af0c0c				SP01_X_POS_L            = $AF0C0C
=$af0c0d				SP01_X_POS_H            = $AF0C0D
=$af0c0e				SP01_Y_POS_L            = $AF0C0E
=$af0c0f				SP01_Y_POS_H            = $AF0C0F
=$af0c10				SP02_CONTROL_REG        = $AF0C10
=$af0c11				SP02_ADDY_PTR_L         = $AF0C11
=$af0c12				SP02_ADDY_PTR_M         = $AF0C12
=$af0c13				SP02_ADDY_PTR_H         = $AF0C13
=$af0c14				SP02_X_POS_L            = $AF0C14
=$af0c15				SP02_X_POS_H            = $AF0C15
=$af0c16				SP02_Y_POS_L            = $AF0C16
=$af0c17				SP02_Y_POS_H            = $AF0C17
=$af0c18				SP03_CONTROL_REG        = $AF0C18
=$af0c19				SP03_ADDY_PTR_L         = $AF0C19
=$af0c1a				SP03_ADDY_PTR_M         = $AF0C1A
=$af0c1b				SP03_ADDY_PTR_H         = $AF0C1B
=$af0c1c				SP03_X_POS_L            = $AF0C1C
=$af0c1d				SP03_X_POS_H            = $AF0C1D
=$af0c1e				SP03_Y_POS_L            = $AF0C1E
=$af0c1f				SP03_Y_POS_H            = $AF0C1F
=$af0c20				SP04_CONTROL_REG        = $AF0C20
=$af0c21				SP04_ADDY_PTR_L         = $AF0C21
=$af0c22				SP04_ADDY_PTR_M         = $AF0C22
=$af0c23				SP04_ADDY_PTR_H         = $AF0C23
=$af0c24				SP04_X_POS_L            = $AF0C24
=$af0c25				SP04_X_POS_H            = $AF0C25
=$af0c26				SP04_Y_POS_L            = $AF0C26
=$af0c27				SP04_Y_POS_H            = $AF0C27
=$af0c28				SP05_CONTROL_REG        = $AF0C28
=$af0c29				SP05_ADDY_PTR_L         = $AF0C29
=$af0c2a				SP05_ADDY_PTR_M         = $AF0C2A
=$af0c2b				SP05_ADDY_PTR_H         = $AF0C2B
=$af0c2c				SP05_X_POS_L            = $AF0C2C
=$af0c2d				SP05_X_POS_H            = $AF0C2D
=$af0c2e				SP05_Y_POS_L            = $AF0C2E
=$af0c2f				SP05_Y_POS_H            = $AF0C2F
=$af0c30				SP06_CONTROL_REG        = $AF0C30
=$af0c31				SP06_ADDY_PTR_L         = $AF0C31
=$af0c32				SP06_ADDY_PTR_M         = $AF0C32
=$af0c33				SP06_ADDY_PTR_H         = $AF0C33
=$af0c34				SP06_X_POS_L            = $AF0C34
=$af0c35				SP06_X_POS_H            = $AF0C35
=$af0c36				SP06_Y_POS_L            = $AF0C36
=$af0c37				SP06_Y_POS_H            = $AF0C37
=$af0c38				SP07_CONTROL_REG        = $AF0C38
=$af0c39				SP07_ADDY_PTR_L         = $AF0C39
=$af0c3a				SP07_ADDY_PTR_M         = $AF0C3A
=$af0c3b				SP07_ADDY_PTR_H         = $AF0C3B
=$af0c3c				SP07_X_POS_L            = $AF0C3C
=$af0c3d				SP07_X_POS_H            = $AF0C3D
=$af0c3e				SP07_Y_POS_L            = $AF0C3E
=$af0c3f				SP07_Y_POS_H            = $AF0C3F
=$af0c40				SP08_CONTROL_REG        = $AF0C40
=$af0c41				SP08_ADDY_PTR_L         = $AF0C41
=$af0c42				SP08_ADDY_PTR_M         = $AF0C42
=$af0c43				SP08_ADDY_PTR_H         = $AF0C43
=$af0c44				SP08_X_POS_L            = $AF0C44
=$af0c45				SP08_X_POS_H            = $AF0C45
=$af0c46				SP08_Y_POS_L            = $AF0C46
=$af0c47				SP08_Y_POS_H            = $AF0C47
=$af0c48				SP09_CONTROL_REG        = $AF0C48
=$af0c49				SP09_ADDY_PTR_L         = $AF0C49
=$af0c4a				SP09_ADDY_PTR_M         = $AF0C4A
=$af0c4b				SP09_ADDY_PTR_H         = $AF0C4B
=$af0c4c				SP09_X_POS_L            = $AF0C4C
=$af0c4d				SP09_X_POS_H            = $AF0C4D
=$af0c4e				SP09_Y_POS_L            = $AF0C4E
=$af0c4f				SP09_Y_POS_H            = $AF0C4F
=$af0c50				SP10_CONTROL_REG        = $AF0C50
=$af0c51				SP10_ADDY_PTR_L         = $AF0C51
=$af0c52				SP10_ADDY_PTR_M         = $AF0C52
=$af0c53				SP10_ADDY_PTR_H         = $AF0C53
=$af0c54				SP10_X_POS_L            = $AF0C54
=$af0c55				SP10_X_POS_H            = $AF0C55
=$af0c56				SP10_Y_POS_L            = $AF0C56
=$af0c57				SP10_Y_POS_H            = $AF0C57
=$af0c58				SP11_CONTROL_REG        = $AF0C58
=$af0c59				SP11_ADDY_PTR_L         = $AF0C59
=$af0c5a				SP11_ADDY_PTR_M         = $AF0C5A
=$af0c5b				SP11_ADDY_PTR_H         = $AF0C5B
=$af0c5c				SP11_X_POS_L            = $AF0C5C
=$af0c5d				SP11_X_POS_H            = $AF0C5D
=$af0c5e				SP11_Y_POS_L            = $AF0C5E
=$af0c5f				SP11_Y_POS_H            = $AF0C5F
=$af0c60				SP12_CONTROL_REG        = $AF0C60
=$af0c61				SP12_ADDY_PTR_L         = $AF0C61
=$af0c62				SP12_ADDY_PTR_M         = $AF0C62
=$af0c63				SP12_ADDY_PTR_H         = $AF0C63
=$af0c64				SP12_X_POS_L            = $AF0C64
=$af0c65				SP12_X_POS_H            = $AF0C65
=$af0c66				SP12_Y_POS_L            = $AF0C66
=$af0c67				SP12_Y_POS_H            = $AF0C67
=$af0c68				SP13_CONTROL_REG        = $AF0C68
=$af0c69				SP13_ADDY_PTR_L         = $AF0C69
=$af0c6a				SP13_ADDY_PTR_M         = $AF0C6A
=$af0c6b				SP13_ADDY_PTR_H         = $AF0C6B
=$af0c6c				SP13_X_POS_L            = $AF0C6C
=$af0c6d				SP13_X_POS_H            = $AF0C6D
=$af0c6e				SP13_Y_POS_L            = $AF0C6E
=$af0c6f				SP13_Y_POS_H            = $AF0C6F
=$af0c70				SP14_CONTROL_REG        = $AF0C70
=$af0c71				SP14_ADDY_PTR_L         = $AF0C71
=$af0c72				SP14_ADDY_PTR_M         = $AF0C72
=$af0c73				SP14_ADDY_PTR_H         = $AF0C73
=$af0c74				SP14_X_POS_L            = $AF0C74
=$af0c75				SP14_X_POS_H            = $AF0C75
=$af0c76				SP14_Y_POS_L            = $AF0C76
=$af0c77				SP14_Y_POS_H            = $AF0C77
=$af0c78				SP15_CONTROL_REG        = $AF0C78
=$af0c79				SP15_ADDY_PTR_L         = $AF0C79
=$af0c7a				SP15_ADDY_PTR_M         = $AF0C7A
=$af0c7b				SP15_ADDY_PTR_H         = $AF0C7B
=$af0c7c				SP15_X_POS_L            = $AF0C7C
=$af0c7d				SP15_X_POS_H            = $AF0C7D
=$af0c7e				SP15_Y_POS_L            = $AF0C7E
=$af0c7f				SP15_Y_POS_H            = $AF0C7F
=$af0c80				SP16_CONTROL_REG        = $AF0C80
=$af0c81				SP16_ADDY_PTR_L         = $AF0C81
=$af0c82				SP16_ADDY_PTR_M         = $AF0C82
=$af0c83				SP16_ADDY_PTR_H         = $AF0C83
=$af0c84				SP16_X_POS_L            = $AF0C84
=$af0c85				SP16_X_POS_H            = $AF0C85
=$af0c86				SP16_Y_POS_L            = $AF0C86
=$af0c87				SP16_Y_POS_H            = $AF0C87
=$af0c88				SP17_CONTROL_REG        = $AF0C88
=$af0c89				SP17_ADDY_PTR_L         = $AF0C89
=$af0c8a				SP17_ADDY_PTR_M         = $AF0C8A
=$af0c8b				SP17_ADDY_PTR_H         = $AF0C8B
=$af0c8c				SP17_X_POS_L            = $AF0C8C
=$af0c8d				SP17_X_POS_H            = $AF0C8D
=$af0c8e				SP17_Y_POS_L            = $AF0C8E
=$af0c8f				SP17_Y_POS_H            = $AF0C8F
=$af0c90				SP18_CONTROL_REG        = $AF0C90
=$af0c91				SP18_ADDY_PTR_L         = $AF0C91
=$af0c92				SP18_ADDY_PTR_M         = $AF0C92
=$af0c93				SP18_ADDY_PTR_H         = $AF0C93
=$af0c94				SP18_X_POS_L            = $AF0C94
=$af0c95				SP18_X_POS_H            = $AF0C95
=$af0c96				SP18_Y_POS_L            = $AF0C96
=$af0c97				SP18_Y_POS_H            = $AF0C97
=$af0c98				SP19_CONTROL_REG        = $AF0C98
=$af0c99				SP19_ADDY_PTR_L         = $AF0C99
=$af0c9a				SP19_ADDY_PTR_M         = $AF0C9A
=$af0c9b				SP19_ADDY_PTR_H         = $AF0C9B
=$af0c9c				SP19_X_POS_L            = $AF0C9C
=$af0c9d				SP19_X_POS_H            = $AF0C9D
=$af0c9e				SP19_Y_POS_L            = $AF0C9E
=$af0c9f				SP19_Y_POS_H            = $AF0C9F
=$af0ca0				SP20_CONTROL_REG        = $AF0CA0
=$af0ca1				SP20_ADDY_PTR_L         = $AF0CA1
=$af0ca2				SP20_ADDY_PTR_M         = $AF0CA2
=$af0ca3				SP20_ADDY_PTR_H         = $AF0CA3
=$af0ca4				SP20_X_POS_L            = $AF0CA4
=$af0ca5				SP20_X_POS_H            = $AF0CA5
=$af0ca6				SP20_Y_POS_L            = $AF0CA6
=$af0ca7				SP20_Y_POS_H            = $AF0CA7
=$af0ca8				SP21_CONTROL_REG        = $AF0CA8
=$af0ca9				SP21_ADDY_PTR_L         = $AF0CA9
=$af0caa				SP21_ADDY_PTR_M         = $AF0CAA
=$af0cab				SP21_ADDY_PTR_H         = $AF0CAB
=$af0cac				SP21_X_POS_L            = $AF0CAC
=$af0cad				SP21_X_POS_H            = $AF0CAD
=$af0cae				SP21_Y_POS_L            = $AF0CAE
=$af0caf				SP21_Y_POS_H            = $AF0CAF
=$af0cb0				SP22_CONTROL_REG        = $AF0CB0
=$af0cb1				SP22_ADDY_PTR_L         = $AF0CB1
=$af0cb2				SP22_ADDY_PTR_M         = $AF0CB2
=$af0cb3				SP22_ADDY_PTR_H         = $AF0CB3
=$af0cb4				SP22_X_POS_L            = $AF0CB4
=$af0cb5				SP22_X_POS_H            = $AF0CB5
=$af0cb6				SP22_Y_POS_L            = $AF0CB6
=$af0cb7				SP22_Y_POS_H            = $AF0CB7
=$af0cb8				SP23_CONTROL_REG        = $AF0CB8
=$af0cb9				SP23_ADDY_PTR_L         = $AF0CB9
=$af0cba				SP23_ADDY_PTR_M         = $AF0CBA
=$af0cbb				SP23_ADDY_PTR_H         = $AF0CBB
=$af0cbc				SP23_X_POS_L            = $AF0CBC
=$af0cbd				SP23_X_POS_H            = $AF0CBD
=$af0cbe				SP23_Y_POS_L            = $AF0CBE
=$af0cbf				SP23_Y_POS_H            = $AF0CBF
=$af0cc0				SP24_CONTROL_REG        = $AF0CC0
=$af0cc1				SP24_ADDY_PTR_L         = $AF0CC1
=$af0cc2				SP24_ADDY_PTR_M         = $AF0CC2
=$af0cc3				SP24_ADDY_PTR_H         = $AF0CC3
=$af0cc4				SP24_X_POS_L            = $AF0CC4
=$af0cc5				SP24_X_POS_H            = $AF0CC5
=$af0cc6				SP24_Y_POS_L            = $AF0CC6
=$af0cc7				SP24_Y_POS_H            = $AF0CC7
=$af0cc8				SP25_CONTROL_REG        = $AF0CC8
=$af0cc9				SP25_ADDY_PTR_L         = $AF0CC9
=$af0cca				SP25_ADDY_PTR_M         = $AF0CCA
=$af0ccb				SP25_ADDY_PTR_H         = $AF0CCB
=$af0ccc				SP25_X_POS_L            = $AF0CCC
=$af0ccd				SP25_X_POS_H            = $AF0CCD
=$af0cce				SP25_Y_POS_L            = $AF0CCE
=$af0ccf				SP25_Y_POS_H            = $AF0CCF
=$af0cd0				SP26_CONTROL_REG        = $AF0CD0
=$af0cd1				SP26_ADDY_PTR_L         = $AF0CD1
=$af0cd2				SP26_ADDY_PTR_M         = $AF0CD2
=$af0cd3				SP26_ADDY_PTR_H         = $AF0CD3
=$af0cd4				SP26_X_POS_L            = $AF0CD4
=$af0cd5				SP26_X_POS_H            = $AF0CD5
=$af0cd6				SP26_Y_POS_L            = $AF0CD6
=$af0cd7				SP26_Y_POS_H            = $AF0CD7
=$af0cd8				SP27_CONTROL_REG        = $AF0CD8
=$af0cd9				SP27_ADDY_PTR_L         = $AF0CD9
=$af0cda				SP27_ADDY_PTR_M         = $AF0CDA
=$af0cdb				SP27_ADDY_PTR_H         = $AF0CDB
=$af0cdc				SP27_X_POS_L            = $AF0CDC
=$af0cdd				SP27_X_POS_H            = $AF0CDD
=$af0cde				SP27_Y_POS_L            = $AF0CDE
=$af0cdf				SP27_Y_POS_H            = $AF0CDF
=$af0ce0				SP28_CONTROL_REG        = $AF0CE0
=$af0ce1				SP28_ADDY_PTR_L         = $AF0CE1
=$af0ce2				SP28_ADDY_PTR_M         = $AF0CE2
=$af0ce3				SP28_ADDY_PTR_H         = $AF0CE3
=$af0ce4				SP28_X_POS_L            = $AF0CE4
=$af0ce5				SP28_X_POS_H            = $AF0CE5
=$af0ce6				SP28_Y_POS_L            = $AF0CE6
=$af0ce7				SP28_Y_POS_H            = $AF0CE7
=$af0ce8				SP29_CONTROL_REG        = $AF0CE8
=$af0ce9				SP29_ADDY_PTR_L         = $AF0CE9
=$af0cea				SP29_ADDY_PTR_M         = $AF0CEA
=$af0ceb				SP29_ADDY_PTR_H         = $AF0CEB
=$af0cec				SP29_X_POS_L            = $AF0CEC
=$af0ced				SP29_X_POS_H            = $AF0CED
=$af0cee				SP29_Y_POS_L            = $AF0CEE
=$af0cef				SP29_Y_POS_H            = $AF0CEF
=$af0cf0				SP30_CONTROL_REG        = $AF0CF0
=$af0cf1				SP30_ADDY_PTR_L         = $AF0CF1
=$af0cf2				SP30_ADDY_PTR_M         = $AF0CF2
=$af0cf3				SP30_ADDY_PTR_H         = $AF0CF3
=$af0cf4				SP30_X_POS_L            = $AF0CF4
=$af0cf5				SP30_X_POS_H            = $AF0CF5
=$af0cf6				SP30_Y_POS_L            = $AF0CF6
=$af0cf7				SP30_Y_POS_H            = $AF0CF7
=$af0cf8				SP31_CONTROL_REG        = $AF0CF8
=$af0cf9				SP31_ADDY_PTR_L         = $AF0CF9
=$af0cfa				SP31_ADDY_PTR_M         = $AF0CFA
=$af0cfb				SP31_ADDY_PTR_H         = $AF0CFB
=$af0cfc				SP31_X_POS_L            = $AF0CFC
=$af0cfd				SP31_X_POS_H            = $AF0CFD
=$af0cfe				SP31_Y_POS_L            = $AF0CFE
=$af0cff				SP31_Y_POS_H            = $AF0CFF
=$af0d00				SP32_CONTROL_REG        = $AF0D00
=$af0d01				SP32_ADDY_PTR_L         = $AF0D01
=$af0d02				SP32_ADDY_PTR_M         = $AF0D02
=$af0d03				SP32_ADDY_PTR_H         = $AF0D03
=$af0d04				SP32_X_POS_L            = $AF0D04
=$af0d05				SP32_X_POS_H            = $AF0D05
=$af0d06				SP32_Y_POS_L            = $AF0D06
=$af0d07				SP32_Y_POS_H            = $AF0D07
=$af0d08				SP33_CONTROL_REG        = $AF0D08
=$af0d09				SP33_ADDY_PTR_L         = $AF0D09
=$af0d0a				SP33_ADDY_PTR_M         = $AF0D0A
=$af0d0b				SP33_ADDY_PTR_H         = $AF0D0B
=$af0d0c				SP33_X_POS_L            = $AF0D0C
=$af0d0d				SP33_X_POS_H            = $AF0D0D
=$af0d0e				SP33_Y_POS_L            = $AF0D0E
=$af0d0f				SP33_Y_POS_H            = $AF0D0F
=$af0d10				SP34_CONTROL_REG        = $AF0D10
=$af0d11				SP34_ADDY_PTR_L         = $AF0D11
=$af0d12				SP34_ADDY_PTR_M         = $AF0D12
=$af0d13				SP34_ADDY_PTR_H         = $AF0D13
=$af0d14				SP34_X_POS_L            = $AF0D14
=$af0d15				SP34_X_POS_H            = $AF0D15
=$af0d16				SP34_Y_POS_L            = $AF0D16
=$af0d17				SP34_Y_POS_H            = $AF0D17
=$af0d18				SP35_CONTROL_REG        = $AF0D18
=$af0d19				SP35_ADDY_PTR_L         = $AF0D19
=$af0d1a				SP35_ADDY_PTR_M         = $AF0D1A
=$af0d1b				SP35_ADDY_PTR_H         = $AF0D1B
=$af0d1c				SP35_X_POS_L            = $AF0D1C
=$af0d1d				SP35_X_POS_H            = $AF0D1D
=$af0d1e				SP35_Y_POS_L            = $AF0D1E
=$af0d1f				SP35_Y_POS_H            = $AF0D1F
=$af0d20				SP36_CONTROL_REG        = $AF0D20
=$af0d21				SP36_ADDY_PTR_L         = $AF0D21
=$af0d22				SP36_ADDY_PTR_M         = $AF0D22
=$af0d23				SP36_ADDY_PTR_H         = $AF0D23
=$af0d24				SP36_X_POS_L            = $AF0D24
=$af0d25				SP36_X_POS_H            = $AF0D25
=$af0d26				SP36_Y_POS_L            = $AF0D26
=$af0d27				SP36_Y_POS_H            = $AF0D27
=$af0d28				SP37_CONTROL_REG        = $AF0D28
=$af0d29				SP37_ADDY_PTR_L         = $AF0D29
=$af0d2a				SP37_ADDY_PTR_M         = $AF0D2A
=$af0d2b				SP37_ADDY_PTR_H         = $AF0D2B
=$af0d2c				SP37_X_POS_L            = $AF0D2C
=$af0d2d				SP37_X_POS_H            = $AF0D2D
=$af0d2e				SP37_Y_POS_L            = $AF0D2E
=$af0d2f				SP37_Y_POS_H            = $AF0D2F
=$af0d30				SP38_CONTROL_REG        = $AF0D30
=$af0d31				SP38_ADDY_PTR_L         = $AF0D31
=$af0d32				SP38_ADDY_PTR_M         = $AF0D32
=$af0d33				SP38_ADDY_PTR_H         = $AF0D33
=$af0d34				SP38_X_POS_L            = $AF0D34
=$af0d35				SP38_X_POS_H            = $AF0D35
=$af0d36				SP38_Y_POS_L            = $AF0D36
=$af0d37				SP38_Y_POS_H            = $AF0D37
=$af0d38				SP39_CONTROL_REG        = $AF0D38
=$af0d39				SP39_ADDY_PTR_L         = $AF0D39
=$af0d3a				SP39_ADDY_PTR_M         = $AF0D3A
=$af0d3b				SP39_ADDY_PTR_H         = $AF0D3B
=$af0d3c				SP39_X_POS_L            = $AF0D3C
=$af0d3d				SP39_X_POS_H            = $AF0D3D
=$af0d3e				SP39_Y_POS_L            = $AF0D3E
=$af0d3f				SP39_Y_POS_H            = $AF0D3F
=$af0d40				SP40_CONTROL_REG        = $AF0D40
=$af0d41				SP40_ADDY_PTR_L         = $AF0D41
=$af0d42				SP40_ADDY_PTR_M         = $AF0D42
=$af0d43				SP40_ADDY_PTR_H         = $AF0D43
=$af0d44				SP40_X_POS_L            = $AF0D44
=$af0d45				SP40_X_POS_H            = $AF0D45
=$af0d46				SP40_Y_POS_L            = $AF0D46
=$af0d47				SP40_Y_POS_H            = $AF0D47
=$af0d48				SP41_CONTROL_REG        = $AF0D48
=$af0d49				SP41_ADDY_PTR_L         = $AF0D49
=$af0d4a				SP41_ADDY_PTR_M         = $AF0D4A
=$af0d4b				SP41_ADDY_PTR_H         = $AF0D4B
=$af0d4c				SP41_X_POS_L            = $AF0D4C
=$af0d4d				SP41_X_POS_H            = $AF0D4D
=$af0d4e				SP41_Y_POS_L            = $AF0D4E
=$af0d4f				SP41_Y_POS_H            = $AF0D4F
=$af0d50				SP42_CONTROL_REG        = $AF0D50
=$af0d51				SP42_ADDY_PTR_L         = $AF0D51
=$af0d52				SP42_ADDY_PTR_M         = $AF0D52
=$af0d53				SP42_ADDY_PTR_H         = $AF0D53
=$af0d54				SP42_X_POS_L            = $AF0D54
=$af0d55				SP42_X_POS_H            = $AF0D55
=$af0d56				SP42_Y_POS_L            = $AF0D56
=$af0d57				SP42_Y_POS_H            = $AF0D57
=$af0d58				SP43_CONTROL_REG        = $AF0D58
=$af0d59				SP43_ADDY_PTR_L         = $AF0D59
=$af0d5a				SP43_ADDY_PTR_M         = $AF0D5A
=$af0d5b				SP43_ADDY_PTR_H         = $AF0D5B
=$af0d5c				SP43_X_POS_L            = $AF0D5C
=$af0d5d				SP43_X_POS_H            = $AF0D5D
=$af0d5e				SP43_Y_POS_L            = $AF0D5E
=$af0d5f				SP43_Y_POS_H            = $AF0D5F
=$af0d60				SP44_CONTROL_REG        = $AF0D60
=$af0d61				SP44_ADDY_PTR_L         = $AF0D61
=$af0d62				SP44_ADDY_PTR_M         = $AF0D62
=$af0d63				SP44_ADDY_PTR_H         = $AF0D63
=$af0d64				SP44_X_POS_L            = $AF0D64
=$af0d65				SP44_X_POS_H            = $AF0D65
=$af0d66				SP44_Y_POS_L            = $AF0D66
=$af0d67				SP44_Y_POS_H            = $AF0D67
=$af0d68				SP45_CONTROL_REG        = $AF0D68
=$af0d69				SP45_ADDY_PTR_L         = $AF0D69
=$af0d6a				SP45_ADDY_PTR_M         = $AF0D6A
=$af0d6b				SP45_ADDY_PTR_H         = $AF0D6B
=$af0d6c				SP45_X_POS_L            = $AF0D6C
=$af0d6d				SP45_X_POS_H            = $AF0D6D
=$af0d6e				SP45_Y_POS_L            = $AF0D6E
=$af0d6f				SP45_Y_POS_H            = $AF0D6F
=$af0d70				SP46_CONTROL_REG        = $AF0D70
=$af0d71				SP46_ADDY_PTR_L         = $AF0D71
=$af0d72				SP46_ADDY_PTR_M         = $AF0D72
=$af0d73				SP46_ADDY_PTR_H         = $AF0D73
=$af0d74				SP46_X_POS_L            = $AF0D74
=$af0d75				SP46_X_POS_H            = $AF0D75
=$af0d76				SP46_Y_POS_L            = $AF0D76
=$af0d77				SP46_Y_POS_H            = $AF0D77
=$af0d78				SP47_CONTROL_REG        = $AF0D78
=$af0d79				SP47_ADDY_PTR_L         = $AF0D79
=$af0d7a				SP47_ADDY_PTR_M         = $AF0D7A
=$af0d7b				SP47_ADDY_PTR_H         = $AF0D7B
=$af0d7c				SP47_X_POS_L            = $AF0D7C
=$af0d7d				SP47_X_POS_H            = $AF0D7D
=$af0d7e				SP47_Y_POS_L            = $AF0D7E
=$af0d7f				SP47_Y_POS_H            = $AF0D7F
=$af0d80				SP48_CONTROL_REG        = $AF0D80
=$af0d81				SP48_ADDY_PTR_L         = $AF0D81
=$af0d82				SP48_ADDY_PTR_M         = $AF0D82
=$af0d83				SP48_ADDY_PTR_H         = $AF0D83
=$af0d84				SP48_X_POS_L            = $AF0D84
=$af0d85				SP48_X_POS_H            = $AF0D85
=$af0d86				SP48_Y_POS_L            = $AF0D86
=$af0d87				SP48_Y_POS_H            = $AF0D87
=$af0d88				SP49_CONTROL_REG        = $AF0D88
=$af0d89				SP49_ADDY_PTR_L         = $AF0D89
=$af0d8a				SP49_ADDY_PTR_M         = $AF0D8A
=$af0d8b				SP49_ADDY_PTR_H         = $AF0D8B
=$af0d8c				SP49_X_POS_L            = $AF0D8C
=$af0d8d				SP49_X_POS_H            = $AF0D8D
=$af0d8e				SP49_Y_POS_L            = $AF0D8E
=$af0d8f				SP49_Y_POS_H            = $AF0D8F
=$af0d90				SP50_CONTROL_REG        = $AF0D90
=$af0d91				SP50_ADDY_PTR_L         = $AF0D91
=$af0d92				SP50_ADDY_PTR_M         = $AF0D92
=$af0d93				SP50_ADDY_PTR_H         = $AF0D93
=$af0d94				SP50_X_POS_L            = $AF0D94
=$af0d95				SP50_X_POS_H            = $AF0D95
=$af0d96				SP50_Y_POS_L            = $AF0D96
=$af0d97				SP50_Y_POS_H            = $AF0D97
=$af0d98				SP51_CONTROL_REG        = $AF0D98
=$af0d99				SP51_ADDY_PTR_L         = $AF0D99
=$af0d9a				SP51_ADDY_PTR_M         = $AF0D9A
=$af0d9b				SP51_ADDY_PTR_H         = $AF0D9B
=$af0d9c				SP51_X_POS_L            = $AF0D9C
=$af0d9d				SP51_X_POS_H            = $AF0D9D
=$af0d9e				SP51_Y_POS_L            = $AF0D9E
=$af0d9f				SP51_Y_POS_H            = $AF0D9F
=$af0da0				SP52_CONTROL_REG        = $AF0DA0
=$af0da1				SP52_ADDY_PTR_L         = $AF0DA1
=$af0da2				SP52_ADDY_PTR_M         = $AF0DA2
=$af0da3				SP52_ADDY_PTR_H         = $AF0DA3
=$af0da4				SP52_X_POS_L            = $AF0DA4
=$af0da5				SP52_X_POS_H            = $AF0DA5
=$af0da6				SP52_Y_POS_L            = $AF0DA6
=$af0da7				SP52_Y_POS_H            = $AF0DA7
=$af0da8				SP53_CONTROL_REG        = $AF0DA8
=$af0da9				SP53_ADDY_PTR_L         = $AF0DA9
=$af0daa				SP53_ADDY_PTR_M         = $AF0DAA
=$af0dab				SP53_ADDY_PTR_H         = $AF0DAB
=$af0dac				SP53_X_POS_L            = $AF0DAC
=$af0dad				SP53_X_POS_H            = $AF0DAD
=$af0dae				SP53_Y_POS_L            = $AF0DAE
=$af0daf				SP53_Y_POS_H            = $AF0DAF
=$af0db0				SP54_CONTROL_REG        = $AF0DB0
=$af0db1				SP54_ADDY_PTR_L         = $AF0DB1
=$af0db2				SP54_ADDY_PTR_M         = $AF0DB2
=$af0db3				SP54_ADDY_PTR_H         = $AF0DB3
=$af0db4				SP54_X_POS_L            = $AF0DB4
=$af0db5				SP54_X_POS_H            = $AF0DB5
=$af0db6				SP54_Y_POS_L            = $AF0DB6
=$af0db7				SP54_Y_POS_H            = $AF0DB7
=$af0db8				SP55_CONTROL_REG        = $AF0DB8
=$af0db9				SP55_ADDY_PTR_L         = $AF0DB9
=$af0dba				SP55_ADDY_PTR_M         = $AF0DBA
=$af0dbb				SP55_ADDY_PTR_H         = $AF0DBB
=$af0dbc				SP55_X_POS_L            = $AF0DBC
=$af0dbd				SP55_X_POS_H            = $AF0DBD
=$af0dbe				SP55_Y_POS_L            = $AF0DBE
=$af0dbf				SP55_Y_POS_H            = $AF0DBF
=$af0dc0				SP56_CONTROL_REG        = $AF0DC0
=$af0dc1				SP56_ADDY_PTR_L         = $AF0DC1
=$af0dc2				SP56_ADDY_PTR_M         = $AF0DC2
=$af0dc3				SP56_ADDY_PTR_H         = $AF0DC3
=$af0dc4				SP56_X_POS_L            = $AF0DC4
=$af0dc5				SP56_X_POS_H            = $AF0DC5
=$af0dc6				SP56_Y_POS_L            = $AF0DC6
=$af0dc7				SP56_Y_POS_H            = $AF0DC7
=$af0dc8				SP57_CONTROL_REG        = $AF0DC8
=$af0dc9				SP57_ADDY_PTR_L         = $AF0DC9
=$af0dca				SP57_ADDY_PTR_M         = $AF0DCA
=$af0dcb				SP57_ADDY_PTR_H         = $AF0DCB
=$af0dcc				SP57_X_POS_L            = $AF0DCC
=$af0dcd				SP57_X_POS_H            = $AF0DCD
=$af0dce				SP57_Y_POS_L            = $AF0DCE
=$af0dcf				SP57_Y_POS_H            = $AF0DCF
=$af0dd0				SP58_CONTROL_REG        = $AF0DD0
=$af0dd1				SP58_ADDY_PTR_L         = $AF0DD1
=$af0dd2				SP58_ADDY_PTR_M         = $AF0DD2
=$af0dd3				SP58_ADDY_PTR_H         = $AF0DD3
=$af0dd4				SP58_X_POS_L            = $AF0DD4
=$af0dd5				SP58_X_POS_H            = $AF0DD5
=$af0dd6				SP58_Y_POS_L            = $AF0DD6
=$af0dd7				SP58_Y_POS_H            = $AF0DD7
=$af0dd8				SP59_CONTROL_REG        = $AF0DD8
=$af0dd9				SP59_ADDY_PTR_L         = $AF0DD9
=$af0dda				SP59_ADDY_PTR_M         = $AF0DDA
=$af0ddb				SP59_ADDY_PTR_H         = $AF0DDB
=$af0ddc				SP59_X_POS_L            = $AF0DDC
=$af0ddd				SP59_X_POS_H            = $AF0DDD
=$af0dde				SP59_Y_POS_L            = $AF0DDE
=$af0ddf				SP59_Y_POS_H            = $AF0DDF
=$af0de0				SP60_CONTROL_REG        = $AF0DE0
=$af0de1				SP60_ADDY_PTR_L         = $AF0DE1
=$af0de2				SP60_ADDY_PTR_M         = $AF0DE2
=$af0de3				SP60_ADDY_PTR_H         = $AF0DE3
=$af0de4				SP60_X_POS_L            = $AF0DE4
=$af0de5				SP60_X_POS_H            = $AF0DE5
=$af0de6				SP60_Y_POS_L            = $AF0DE6
=$af0de7				SP60_Y_POS_H            = $AF0DE7
=$af0de8				SP61_CONTROL_REG        = $AF0DE8
=$af0de9				SP61_ADDY_PTR_L         = $AF0DE9
=$af0dea				SP61_ADDY_PTR_M         = $AF0DEA
=$af0deb				SP61_ADDY_PTR_H         = $AF0DEB
=$af0dec				SP61_X_POS_L            = $AF0DEC
=$af0ded				SP61_X_POS_H            = $AF0DED
=$af0dee				SP61_Y_POS_L            = $AF0DEE
=$af0def				SP61_Y_POS_H            = $AF0DEF
=$af0df0				SP62_CONTROL_REG        = $AF0DF0
=$af0df1				SP62_ADDY_PTR_L         = $AF0DF1
=$af0df2				SP62_ADDY_PTR_M         = $AF0DF2
=$af0df3				SP62_ADDY_PTR_H         = $AF0DF3
=$af0df4				SP62_X_POS_L            = $AF0DF4
=$af0df5				SP62_X_POS_H            = $AF0DF5
=$af0df6				SP62_Y_POS_L            = $AF0DF6
=$af0df7				SP62_Y_POS_H            = $AF0DF7
=$af0df8				SP63_CONTROL_REG        = $AF0DF8
=$af0df9				SP63_ADDY_PTR_L         = $AF0DF9
=$af0dfa				SP63_ADDY_PTR_M         = $AF0DFA
=$af0dfb				SP63_ADDY_PTR_H         = $AF0DFB
=$af0dfc				SP63_X_POS_L            = $AF0DFC
=$af0dfd				SP63_X_POS_H            = $AF0DFD
=$af0dfe				SP63_Y_POS_L            = $AF0DFE
=$af0dff				SP63_Y_POS_H            = $AF0DFF

;******  Return to file: src\C256/vicky_def.s


;******  Return to file: src\C256/mmap_c256.s

=$00					BASIC_BANK = $00            ; Memory bank for default purposes
=$004c00				IOBUF = $004C00             ; A buffer for I/O operations
=$004d00				ARRIDXBUF = $004D00         ; The array index buffer used for array references
=$004e00				TEMPBUF = $004E00           ; Temporary buffer for string processing, etc.
=$004f00				INPUTBUF = $004F00          ; Starting address of the line input buffer (one page)
=$005000				RETURN_BOT = $005000        ; Starting address of the return stack
=$005fff				RETURN_TOP = $005FFF        ; Ending address of the return stack
=$006000				ARGUMENT_BOT = $006000      ; Starting address of the argument stack
=$006fff				ARGUMENT_TOP = $006FFF      ; Ending address of the argument stack
=$007000				OPERATOR_BOT = $007000      ; Starting address of the operator stack
=$007fff				OPERATOR_TOP = $007FFF      ; Ending address of the operator stack
=$b00000				VRAM = $B00000              ; Start of video RAM
=$010000				LOADBLOCK = $010000         ; File loading will start here
=$360000				BASIC_BOT := $360000         ; Starting point for BASIC programs
=$37ffff				HEAP_TOP := $37FFFF          ; Starting point of the heap

;******  Return to file: src\memorymap.s

=$00ffe6				VBRK = $00FFE6          ; Vector for the native-mode BRK vector
=$3ad000				DATA_BLOCK = *
=$000800				GLOBAL_VARS = *
>0800					BIP         .dword ?    ; Pointer to the current byte in the current BASIC program
>0804					BIPPREV     .dword ?    ; Pointer to the previous bytein the current BASIC program
>0808					INDEX       .dword ?    ; A temporary pointer
>080c					SCRATCH     .dword ?    ; A temporary scratch variable
>0810					SCRATCH2    .dword ?    ; A temporary scratch variable
>0814					            .word  ?	; Need a few more bits for BCD conversion
>0816					STRPTR      .dword ?    ; A temporary pointer for strings
>081a					CURLINE     .dword ?    ; Pointer to the current input line needing tokenization
>081e					CURTOKLEN   .byte ?     ; Length of the text of the current token
>081f					ARGUMENTSP  .word ?     ; Pointer to the top of the argument stack
>0821					OPERATORSP  .word ?     ; Pointer to the top of the operator stack
>0823					ARGUMENT1   .dword ?    ; Argument 1 for expression calculations
>0827					ARGTYPE1    .byte ?     ; Type code for argument 1 (integer, float, string)
>0828					SIGN1       .byte ?     ; Temporary sign marker for argument 1
>0829					ARGUMENT2   .dword ?    ; Argument 2 for expression calculations
>082d					ARGTYPE2    .byte ?     ; Type code for argument 2 (integer, float, string)
>082e					SIGN2       .byte ?     ; Temporary sign marker for argument 1
>082f					JMP16PTR    .word ?     ; Pointer for 16-bit indirect jumps (within BASIC816's code base)
>0831					GOSUBDEPTH  .word ?     ; Number of GOSUBs on the stack
>0833					RETURNSP    .word ?     ; Pointer to the top of the return stack
>0835					SKIPNEST    .byte ?     ; Flag to indicate if token seeking should respect nesting (MSB set if so)
>0836					NESTING     .byte ?     ; Counter of the depth of lexical nesting for FOR/NEXT, DO/LOOP
>0837					TARGETTOK   .byte ?     ; When searching for a token, TARGETTOK is the token to find
>0838					DATABIP     .dword ?    ; Pointer to the next data element for READ statements
>083c					DATALINE    .dword ?    ; Pointer to the current line for a DATA statement
>0840					SAVEBIP     .dword ?    ; Spot to save BIP temporarily
>0844					SAVELINE    .dword ?    ; Spot to save CURLINE temporarily
=$000848				MONITOR_VARS = *
>0848					MCMDADDR    .long ?     ;3 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
>084b					MCMP_TEXT   .long ?     ;3 Bytes Address of symbol being evaluated for COMPARE routine
>084e					MCMP_LEN    .word ?     ;2 Bytes Length of symbol being evaluated for COMPARE routine
>0850					MCMD        .long ?     ;3 Bytes Address of the current command/function string
>0853					MCMD_LEN    .word ?     ;2 Bytes Length of the current command/function string
>0855					MARG1       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command
>0859					MARG2       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>085d					MARG3       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0861					MARG4       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0865					MARG5       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0869					MARG6       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>086d					MARG7       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0871					MARG8       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0875					MARG9       .dword ?    ;4 Bytes First command argument.
>0879					MARG_LEN    .byte ?     ;1 Byte count of the number of arguments passed
>087a					MCURSOR     .dword ?    ;4 Bytes Pointer to the current memory location for disassembly, memory dump, etc.
>087e					MLINEBUF    .fill 17    ;17 Byte buffer for dumping memory (TODO: could be moved to a general string scratch area)
>088f					MCOUNT      .long ?     ;2 Byte counter
>0892					MTEMP       .dword ?    ;4 Bytes of temporary space
>0896					MCPUSTAT    .byte ?     ;1 Byte to represent what the disassembler thinks the processor MX bits are
>0897					MADDR_MODE  .byte ?     ;1 Byte address mode found by the assembler
>0898					MPARSEDNUM  .dword ?    ;4 Bytes to store a parsed number
>089c					MMNEMONIC   .word ?     ;2 Byte address of mnemonic found by the assembler
>089e					MTEMPPTR    .dword ?    ;4 Byte temporary pointer
>08a2					MJUMPINST   .byte ?     ;1 Byte JSL opcode
>08a3					MJUMPADDR   .long ?     ;3 Byte address for JSL
=$000823				MANTISSA1 = ARGUMENT1
=$000826				EXPONENT1 = ARGUMENT1+3

;******  Return to file: src\basic816.s


;******  Processing file: src\macros.s


;******  Return to file: src\basic816.s

.3a0000	5c 9a 87 3a	jmp $3a879a	COLDBOOT        JML START               ; Entry point to boot up BASIC from scratch
.3a0004	5c a9 6d 3a	jmp $3a6da9	MONITOR         JML IMONITOR            ; Entry point to the machine language monitor
.3a0008	5c b6 25 3a	jmp $3a25b6	READLINE        JML IREADLINE           ; Wait for the user to enter a line of text (for programming input)
.3a000c	5c 5b 01 3a	jmp $3a015b	SCRCOPYLINE     JML ISCRCPYLINE         ; Copy the line on the screen the user just input to INPUTBUF
.3a0010	5c 58 00 3a	jmp $3a0058	INPUTLINE       JML IINPUTLINE          ; Read a single line of text from the user, and copy it to TEMPBUF (for INPUT statement)
.3a0014	5c d6 00 3a	jmp $3a00d6	GETKEY          JML IGETKEY             ; Wait for a keypress by the user and return the ASCII code in A
.3a0018	5c c1 02 3a	jmp $3a02c1	PRINTC          JML IPRINTC             ; Print the character in A to the console
.3a001c	5c ff 00 3a	jmp $3a00ff	SHOWCURSOR      JML ISHOWCURSOR         ; Set cursor visibility: A=0, hide... A<>0, show.
.3a0020	5c 1a 01 3a	jmp $3a011a	CURSORXY        JML ICURSORXY           ; Set the position of the cursor to (X, Y)
.3a0024	5c 21 01 3a	jmp $3a0121	CLSCREEN        JML ICLSCREEN           ; Clear the screen

;******  Processing file: src\bios.s


;******  Processing file: src\membuffers.s

>08a6					OBUFFER     .long ?     ; Pointer to the current text memory buffer for output
>08a9					OBUFFSIZE   .word ?     ; Maximum size of output text memory buffer
>08ab					OBUFFIDX    .word ?     ; Index into the current output buffer
>08ad					IBUFFER     .long ?     ; Pointer to the current text memory buffer for input
>08b0					IBUFFSIZE   .word ?     ; Number of bytes written to the buffer
>08b2					IBUFFIDX    .word ?     ; Index into the current input buffer (next available character)
.3a0028					OBUFF_PUTC
.3a0028	0b		phd		                PHD
.3a0029	08		php		                PHP
.3a002a	08		php		            PHP
.3a002b	c2 20		rep #$20	            REP #$20
.3a002d	48		pha		            PHA
.3a002e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0031	5b		tcd		            TCD
.3a0032	68		pla		            PLA
.3a0033	28		plp		            PLP
.3a0034	e2 20		sep #$20	            SEP #$20
.3a0036	85 b5		sta $08b5	                STA SAVE_A
.3a0038	c2 20		rep #$20	            REP #$20
.3a003a	a5 a6		lda $08a6	                LDA OBUFFER
.3a003c	d0 06		bne $3a0044	                BNE has_buffer
.3a003e	e2 20		sep #$20	            SEP #$20
.3a0040	a5 a8		lda $08a8	                LDA OBUFFER+2
.3a0042	f0 11		beq $3a0055	                BEQ done
.3a0044					has_buffer
.3a0044	c2 10		rep #$10	            REP #$10
.3a0046	a4 ab		ldy $08ab	                LDY OBUFFIDX        ; Check to make sure there is room
.3a0048	c4 a9		cpy $08a9	                CPY OBUFFSIZE
.3a004a	f0 09		beq $3a0055	                BEQ done            ; If not, exit silently
.3a004c	e2 20		sep #$20	            SEP #$20
.3a004e	a5 b5		lda $08b5	                LDA SAVE_A
.3a0050	97 a6		sta [$08a6],y	                STA [OBUFFER],Y     ; Write the character to the buffer
.3a0052	c8		iny		                INY                 ; Increment the index
.3a0053	84 ab		sty $08ab	                STY OBUFFIDX
.3a0055	28		plp		done            PLP
.3a0056	2b		pld		                PLD
.3a0057	60		rts		            RTS

;******  Return to file: src\bios.s


;******  Processing file: src\C256/io_c256.s


;******  Processing file: src\C256/kernel_c256.s

=$00104c				FK_GETCHW           = $00104c ; Get a character from the input channel. Waits until data received. A=0 and Carry=1 if no data is wating
=$001018				FK_PUTC             = $001018 ; Print a character to the currently selected channel
=$00101c				FK_PUTS             = $00101C ; Print a string to the currently selected channel
=$001084				FK_LOCATE           = $001084 ; Reposition the cursor to row Y column X
=$001078				FK_IPRINTH          = $001078 ; Print a HEX string
=$00103c				FK_SETOUT           = $00103c ; Select an output channel
=$00112c				FK_SETSIZES         = $00112C ; Set the text screen size variables based on the border and screen resolution.
=$0010f0				FK_OPEN             = $0010F0 ; open a file for reading/writing/creating
=$0010f4				FK_CREATE           = $0010F4 ; create a new file
=$0010f8				FK_CLOSE            = $0010F8 ; close a file (make sure last cluster is written)
=$0010fc				FK_WRITE            = $0010FC ; write the current cluster to the file
=$001100				FK_READ             = $001100 ; read the next cluster from the file
=$001104				FK_DELETE           = $001104 ; delete a file / directory
=$001108				FK_DIROPEN          = $001108 ; open a directory and seek the first directory entry
=$00110c				FK_DIRNEXT          = $00110C ; seek to the next directory of an open directory
=$001110				FK_DIRREAD          = $001110 ; Read the directory entry for the specified file
=$001114				FK_DIRWRITE         = $001114 ; Write any changes in the current directory cluster back to the drive
=$001118				FK_LOAD             = $001118 ; load a binary file into memory, supports multiple file formats
=$00111c				FK_SAVE             = $00111C ; Save memory to a binary file
=$001124				FK_RUN              = $001124 ; Load and run an executable binary file
=$001130				FK_COPY             = $001130 ; Copy a file
=$001120				FK_CMDBLOCK         = $001120 ; Send a command to a block device
=0					CHAN_CONSOLE = 0
=1					CHAN_COM1 = 1
=2					CHAN_COM2 = 2

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/RTC_inc.s

=$af0800				RTC_SEC       = $AF0800 ;Seconds Register
=$af0801				RTC_SEC_ALARM = $AF0801 ;Seconds Alarm Register
=$af0802				RTC_MIN       = $AF0802 ;Minutes Register
=$af0803				RTC_MIN_ALARM = $AF0803 ;Minutes Alarm Register
=$af0804				RTC_HRS       = $AF0804 ;Hours Register
=$af0805				RTC_HRS_ALARM = $AF0805 ;Hours Alarm Register
=$af0806				RTC_DAY       = $AF0806 ;Day Register
=$af0807				RTC_DAY_ALARM = $AF0807 ;Day Alarm Register
=$af0808				RTC_DOW       = $AF0808 ;Day of Week Register
=$af0809				RTC_MONTH     = $AF0809 ;Month Register
=$af080a				RTC_YEAR      = $AF080A ;Year Register
=$af080b				RTC_RATES     = $AF080B ;Rates Register
=$af080c				RTC_ENABLE    = $AF080C ;Enables Register
=$af080d				RTC_FLAGS     = $AF080D ;Flags Register
=$af080e				RTC_CTRL      = $AF080E ;Control Register
=$af080f				RTC_CENTURY   = $AF080F ;Century Register

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/keyboard.s


;******  Processing file: src\C256/keyboard_def.s

=$af1064				STATUS_PORT 	        =	$AF1064
=$af1060				KBD_OUT_BUF 	        =	$AF1060
=$af1060				KBD_INPT_BUF	        = $AF1060
=$af1064				KBD_CMD_BUF		        = $AF1064
=$af1060				KBD_DATA_BUF	        = $AF1060
=$af1060				PORT_A			          =	$AF1060
=$af1061				PORT_B			          =	$AF1061
=$01					OUT_BUF_FULL  =	$01
=$02					INPT_BUF_FULL	=	$02
=$04					SYS_FLAG		  =	$04
=$08					CMD_DATA		  =	$08
=$10					KEYBD_INH     =	$10
=$20					TRANS_TMOUT	  =	$20
=$40					RCV_TMOUT		  =	$40
=$80					PARITY_EVEN		=	$80
=$10					INH_KEYBOARD	=	$10
=$ae					KBD_ENA			  =	$AE
=$ad					KBD_DIS			  =	$AD
=$f1					KB_MENU			  =	$F1
=$f4					KB_ENABLE		  =	$F4
=$f7					KB_MAKEBREAK  =	$F7
=$fe					KB_ECHO			  =	$FE
=$ff					KB_RESET		  =	$FF
=$ed					KB_LED_CMD		=	$ED
=$aa					KB_OK			    =	$AA
=$fa					KB_ACK			  =	$FA
=$ff					KB_OVERRUN		=	$FF
=$fe					KB_RESEND		  =	$FE
=$f0					KB_BREAK		  =	$F0
=$10					KB_FA			    =	$10
=$20					KB_FE			    =	$20
=$40					KB_PR_LED		  =	$40
=$01					KB_SCROLL_LOCK      = $01
=$02					KB_NUM_LOCK         = $02
=$04					KB_CAPS_LOCK        = $04

;******  Return to file: src\C256/keyboard.s

.3a0058					IINPUTLINE
.3a0058	08		php		                PHP
.3a0059	c2 10		rep #$10	            REP #$10
.3a005b	e2 20		sep #$20	            SEP #$20
.3a005d	a9 01		lda #$01	                LDA #1              ; Show the cursor
.3a005f	20 1c 00	jsr $3a001c	            JSR SHOWCURSOR
.3a0062	a2 00 00	ldx #$0000	                LDX #0
.3a0065	a9 00		lda #$00	                LDA #0
.3a0067	9f 00 4c 00	sta $004c00,x	zero_loop       STA @lIOBUF,X
.3a006b	e8		inx		                INX
.3a006c	e0 00 01	cpx #$0100	                CPX #$100
.3a006f	d0 f6		bne $3a0067	                BNE zero_loop
.3a0071	a2 00 00	ldx #$0000	                LDX #0
.3a0074					getchar
.3a0074	20 14 00	jsr $3a0014	            JSR GETKEY
.3a0077	c9 0d		cmp #$0d	                CMP #CHAR_CR        ; Got a CR?
.3a0079	d0 03		bne $3a007e	                BNE not_cr
.3a007b	4c cf 00	jmp $3a00cf	                JMP endofline       ; Yes: we're done
.3a007e	c9 9d		cmp #$9d	not_cr          CMP #K_LEFT         ; Is it the left cursor?
.3a0080	d0 08		bne $3a008a	                BNE not_left
.3a0082	e0 00 00	cpx #$0000	                CPX #0              ; Are we all the way to the left?
.3a0085	f0 ed		beq $3a0074	                BEQ getchar         ; Yes: ignore it
.3a0087	ca		dex		                DEX                 ; Move the cursor back
.3a0088	80 39		bra $3a00c3	                BRA echo            ; And echo it
.3a008a	c9 1d		cmp #$1d	not_left        CMP #K_RIGHT        ; Is it the right arrow?
.3a008c	d0 0e		bne $3a009c	                BNE not_right
.3a008e	bf 00 4c 00	lda $004c00,x	                LDA @lIOBUF,X       ; Check the current character
.3a0092	f0 e0		beq $3a0074	                BEQ getchar         ; If it's already blank, we're as far right as we go
.3a0094	e0 4f 00	cpx #$004f	                CPX #79             ; Are we at the end of the line?
.3a0097	f0 db		beq $3a0074	                BEQ getchar         ; Yes: ignore it
.3a0099	e8		inx		                INX                 ; Otherwise: advance the cursor
.3a009a	80 27		bra $3a00c3	                BRA echo            ; And print the code
.3a009c	c9 08		cmp #$08	not_right       CMP #CHAR_BS        ; Is it a backspace?
.3a009e	d0 1a		bne $3a00ba	                BNE not_bs
.3a00a0	e0 00 00	cpx #$0000	                CPX #0              ; Are we at the beginning of the line?
.3a00a3	f0 cf		beq $3a0074	                BEQ getchar         ; yes: ignore the backspace
.3a00a5	da		phx		                PHX                 ; Save the cursor position
.3a00a6	bf 01 4c 00	lda $004c01,x	clr_loop        LDA @lIOBUF+1,X     ; Get the character above
.3a00aa	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the current position
.3a00ae	f0 06		beq $3a00b6	                BEQ done_clr        ; If we copied a NUL, we're done copying
.3a00b0	e8		inx		                INX                 ; Otherwise, keep copying down
.3a00b1	e0 ff 00	cpx #$00ff	                CPX #$FF            ; Until we're at the end of the buffer
.3a00b4	d0 f0		bne $3a00a6	                BNE clr_loop
.3a00b6	fa		plx		done_clr        PLX                 ; Restore the cursor position
.3a00b7	ca		dex		                DEX                 ; No: move the cursor left
.3a00b8	80 0e		bra $3a00c8	                BRA print_bs        ; And print the backspace
.3a00ba	c9 20		cmp #$20	not_bs          CMP #$20            ; Is it in range 00 -- 1F?
.3a00bc	90 b6		bcc $3a0074	                BLT getchar         ; Yes: ignore it
.3a00be	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the input buffer
.3a00c2	e8		inx		                INX                 ; Move the cursor forward
.3a00c3					echo
.3a00c3	20 18 00	jsr $3a0018	            JSR PRINTC
.3a00c6	80 ac		bra $3a0074	                BRA getchar         ; And get another...
.3a00c8	a9 08		lda #$08	print_bs        LDA #CHAR_BS        ; Backspace character...
.3a00ca	20 18 00	jsr $3a0018	            JSR PRINTC
.3a00cd	80 a5		bra $3a0074	                BRA getchar         ; And get another...
.3a00cf	a9 00		lda #$00	endofline       LDA #0              ; Hide the cursor
.3a00d1	20 1c 00	jsr $3a001c	            JSR SHOWCURSOR
.3a00d4	28		plp		                PLP
.3a00d5	60		rts		            RTS
.3a00d6					IGETKEY
.3a00d6	22 4c 10 00	jsl $00104c	                JSL FK_GETCHW
.3a00da	60		rts		            RTS
.3a00db					GETKEYE
.3a00db	20 14 00	jsr $3a0014	            JSR GETKEY
.3a00de	48		pha		                PHA
.3a00df	20 18 00	jsr $3a0018	            JSR PRINTC
.3a00e2	68		pla		                PLA
.3a00e3	60		rts		            RTS
=$11					K_UP = $11      ; Keypad UP
=$1d					K_RIGHT = $1D   ; Keypad Right
=$91					K_DOWN = $91    ; Keypad Down
=$9d					K_LEFT = $9D    ; Keypad Left

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/screen.s

.3a00e4					ENSURETEXT
.3a00e4	08		php		            PHP
.3a00e5	e2 20		sep #$20	            SEP #$20
.3a00e7	af 00 00 af	lda $af0000	            LDA @l MASTER_CTRL_REG_L            ; Get the current display mode
.3a00eb	89 3c		bit #$3c	            BIT #Mstr_Ctrl_Graph_Mode_En | Mstr_Ctrl_Bitmap_En | Mstr_Ctrl_TileMap_En | Mstr_Ctrl_Sprite_En
.3a00ed	f0 08		beq $3a00f7	            BEQ textonly                        ; If not, make sure text is enabled
.3a00ef					overlay
.3a00ef	09 03		ora #$03	            ORA #Mstr_Ctrl_Text_Mode_En | Mstr_Ctrl_Text_Overlay
.3a00f1	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.3a00f5	80 06		bra $3a00fd	            BRA done
.3a00f7					textonly
.3a00f7	09 01		ora #$01	            ORA #Mstr_Ctrl_Text_Mode_En
.3a00f9	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.3a00fd	28		plp		done        PLP
.3a00fe	60		rts		            RTS
.3a00ff					ISHOWCURSOR
.3a00ff	08		php		            PHP
.3a0100	e2 20		sep #$20	            SEP #$20
.3a0102	c9 00		cmp #$00	            CMP #0
.3a0104	f0 08		beq $3a010e	            BEQ hide
.3a0106	af 10 00 af	lda $af0010	show        LDA @lVKY_TXT_CURSOR_CTRL_REG
.3a010a	09 01		ora #$01	            ORA #Vky_Cursor_Enable
.3a010c	80 06		bra $3a0114	            BRA setit
.3a010e	af 10 00 af	lda $af0010	hide        LDA @lVKY_TXT_CURSOR_CTRL_REG
.3a0112	29 fe		and #$fe	            AND #~Vky_Cursor_Enable
.3a0114	8f 10 00 af	sta $af0010	setit       STA @lVKY_TXT_CURSOR_CTRL_REG
.3a0118	28		plp		            PLP
.3a0119	60		rts		            RTS
.3a011a					ICURSORXY
.3a011a	08		php		            PHP
.3a011b	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.3a011f	28		plp		            PLP
.3a0120	60		rts		            RTS
.3a0121					ICLSCREEN
.3a0121	48		pha		            PHA
.3a0122	da		phx		            PHX
.3a0123	5a		phy		            PHY
.3a0124	0b		phd		            PHD
.3a0125	08		php		            PHP
.3a0126	e2 20		sep #$20	            SEP #$20
.3a0128	c2 10		rep #$10	            REP #$10
.3a012a	a2 00 00	ldx #$0000	            LDX #0
.3a012d	a9 20		lda #$20	loop        LDA #$20
.3a012f	9f 00 a0 af	sta $afa000,x	            STA @lCS_TEXT_MEM_PTR,X     ; Write a space in the text cell
.3a0133	af 1e 00 00	lda $00001e	            LDA @lCURCOLOR
.3a0137	9f 00 c0 af	sta $afc000,x	            STA @lCS_COLOR_MEM_PTR,X    ; Set the color to green on black
.3a013b	e8		inx		            INX                         ; Move to the next character cell
.3a013c	e0 00 20	cpx #$2000	            CPX #$2000
.3a013f	d0 ec		bne $3a012d	            BNE loop
.3a0141	08		php		            PHP
.3a0142	c2 20		rep #$20	            REP #$20
.3a0144	48		pha		            PHA
.3a0145	a9 00 00	lda #$0000	            LDA #0
.3a0148	5b		tcd		            TCD
.3a0149	68		pla		            PLA
.3a014a	28		plp		            PLP
.3a014b	a2 00 00	ldx #$0000	            LDX #0                      ; Set cursor to upper-left corner
.3a014e	a0 00 00	ldy #$0000	            LDY #0
.3a0151	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.3a0155	28		plp		            PLP
.3a0156	2b		pld		            PLD
.3a0157	7a		ply		            PLY
.3a0158	fa		plx		            PLX
.3a0159	68		pla		            PLA
.3a015a	60		rts		            RTS
.3a015b					ISCRCPYLINE
.3a015b	da		phx		            PHX
.3a015c	5a		phy		            PHY
.3a015d	0b		phd		            PHD
.3a015e	08		php		            PHP
.3a015f	08		php		            PHP
.3a0160	c2 20		rep #$20	            REP #$20
.3a0162	48		pha		            PHA
.3a0163	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0166	5b		tcd		            TCD
.3a0167	68		pla		            PLA
.3a0168	28		plp		            PLP
.3a0169	c2 30		rep #$30	            REP #$30
.3a016b	af 0c 00 00	lda $00000c	            LDA @lSCREENBEGIN       ; Set INDEX to the first byte of the text screen
.3a016f	85 08		sta $0808	            STA INDEX
.3a0171	e2 20		sep #$20	            SEP #$20
.3a0173	af 0e 00 00	lda $00000e	            LDA @lSCREENBEGIN+2
.3a0177	c2 20		rep #$20	            REP #$20
.3a0179	29 ff 00	and #$00ff	            AND #$00FF
.3a017c	85 0a		sta $080a	            STA INDEX+2
.3a017e	af 11 00 00	lda $000011	            LDA @lCOLS_PER_LINE     ; Calculate the offset to the current line
.3a0182	8f 08 01 00	sta $000108	            STA @lM1_OPERAND_A
.3a0186	af 1c 00 00	lda $00001c	            LDA @lCURSORY
.3a018a	3a		dec a		            DEC A
.3a018b	8f 0a 01 00	sta $00010a	            STA @lM1_OPERAND_B
.3a018f	18		clc		            CLC                     ; And add it to INDEX
.3a0190	a5 08		lda $0808	            LDA INDEX
.3a0192	6f 0c 01 00	adc $00010c	            ADC @lM1_RESULT
.3a0196	85 08		sta $0808	            STA INDEX
.3a0198	a5 0a		lda $080a	            LDA INDEX+2
.3a019a	69 00 00	adc #$0000	            ADC #0
.3a019d	85 0a		sta $080a	            STA INDEX+2
.3a019f	e2 20		sep #$20	            SEP #$20
.3a01a1	af 0f 00 00	lda $00000f	            LDA @lCOLS_VISIBLE
.3a01a5	85 8f		sta $088f	            STA MCOUNT
.3a01a7	a0 00 00	ldy #$0000	            LDY #0
.3a01aa	a2 00 00	ldx #$0000	            LDX #0
.3a01ad	b7 08		lda [$0808],y	copy_loop   LDA [INDEX],Y           ; Copy a byte from the screen to the input buffer
.3a01af	9f 00 4f 00	sta $004f00,x	            STA @lINPUTBUF,X
.3a01b3	e8		inx		            INX
.3a01b4	c8		iny		            INY
.3a01b5	c4 8f		cpy $088f	            CPY MCOUNT
.3a01b7	d0 f4		bne $3a01ad	            BNE copy_loop
.3a01b9	ca		dex		            DEX
.3a01ba	bf 00 4f 00	lda $004f00,x	trim_loop   LDA @lINPUTBUF,X        ; Replace spaces at the end with NULLs
.3a01be	c9 20		cmp #$20	            CMP #CHAR_SP
.3a01c0	d0 09		bne $3a01cb	            BNE done
.3a01c2	a9 00		lda #$00	            LDA #0
.3a01c4	9f 00 4f 00	sta $004f00,x	            STA @lINPUTBUF,X
.3a01c8	ca		dex		            DEX
.3a01c9	10 ef		bpl $3a01ba	            BPL trim_loop
.3a01cb	28		plp		done        PLP
.3a01cc	2b		pld		            PLD
.3a01cd	7a		ply		            PLY
.3a01ce	fa		plx		            PLX
.3a01cf	60		rts		            RTS

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/gabe_defs.s

=$afe880				GABE_MSTR_CTRL      = $AFE880
=$01					GABE_CTRL_PWR_LED   = $01     ; Controls the LED in the Front of the case (Next to the reset button)
=$02					GABE_CTRL_SDC_LED   = $02     ; Controls the LED in the Front of the Case (Next to SDCard)
=$04					GABE_CTRL_STS_LED0  = $04     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$08					GABE_CTRL_STS_LED1  = $08     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$10					GABE_CTRL_BUZZER    = $10     ; Controls the Buzzer
=$80					GABE_CTRL_WRM_RST   = $80     ; Warm Reset (needs to Setup other registers)
=$afe881				GABE_LED_FLASH_CTRL = $AFE881  ; Flashing LED Control
=$01					GABE_LED0_FLASH_CTRL = $01     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$02					GABE_LED1_FLASH_CTRL = $02     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED1 to manually control)
=$10					GABE_LD0_FLASH_FRQ0   = $10     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$20					GABE_LD0_FLASH_FRQ1   = $20     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$40					GABE_LD1_FLASH_FRQ0   = $40     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$80					GABE_LD1_FLASH_FRQ1   = $80     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$afe882				GABE_RST_AUTH0      = $AFE882 ; Must Contain the BYTE $AD for Reset to Activate
=$afe883				GABE_RST_AUTH1      = $AFE883 ; Must Contain the BYTE $DE for Reset to Activate
=$afe884				GABE_RNG_DAT_LO     = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_DAT_HI     = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe884				GABE_RNG_SEED_LO    = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_SEED_HI    = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe886				GABE_RNG_STAT       = $AFE886 ;
=$80					GABE_RNG_LFSR_DONE  = $80     ; indicates that Output = SEED Database
=$afe886				GABE_RNG_CTRL       = $AFE886 ;
=$01					GABE_RNG_CTRL_EN    = $01     ; Enable the LFSR BLOCK_LEN
=$02					GABE_RNG_CTRL_DV    = $02     ; After Setting the Seed Value, Toggle that Bit for it be registered
=$afe887				GABE_SYS_STAT       = $AFE887 ;
=$01					GABE_SYS_STAT_MID0  = $01     ; Machine ID -- LSB
=$02					GABE_SYS_STAT_MID1  = $02     ; Machine ID --
=$04					GABE_SYS_STAT_MID2  = $04     ; Machine ID -- MSB
=$10					GABE_SYS_STAT_EXP   = $10     ; if Zero, there is an Expansion Card Preset
=$40					GABE_SYS_STAT_CPUA  = $40     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$80					GABE_SYS_STAT_CPUX  = $80     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$afe88a				GABE_SUBVERSION_LO  = $AFE88A
=$afe88b				GABE_SUBVERSION_HI  = $AFE88B
=$afe88c				GABE_VERSION_LO     = $AFE88C
=$afe88d				GABE_VERSION_HI     = $AFE88D
=$afe88e				GABE_MODEL_LO       = $AFE88E
=$afe88f				GABE_MODEL_HI       = $AFE88F

;******  Return to file: src\C256/io_c256.s

=32					BORDER_WIDTH = 32               ; The width of the border (when it is on)
=72					TEXT_COLS_WB = 72               ; Number of columns of text with the border enabled
=52					TEXT_ROWS_WB = 52               ; Number of rows of text with the border enabled
=80					TEXT_COLS_WOB = 80              ; Number of columns of text with no border enabled
=60					TEXT_ROWS_WOB = 60              ; Number of rows of text with no border enabled
.3a01d0					INITIO
.3a01d0	e2 20		sep #$20	            SEP #$20
.3a01d2	20 1b 02	jsr $3a021b	            JSR INITRNG
.3a01d5	a9 48		lda #$48	            LDA #TEXT_COLS_WB   ; Make sure the screen size is right
.3a01d7	8f 0f 00 00	sta $00000f	            STA @lCOLS_VISIBLE  ; TODO: remove this when the kernel is correct
.3a01db	a9 34		lda #$34	            LDA #TEXT_ROWS_WB
.3a01dd	8f 13 00 00	sta $000013	            STA @lLINES_VISIBLE
.3a01e1	a9 20		lda #$20	            LDA #BORDER_WIDTH   ; Set the border width
.3a01e3	8f 08 00 af	sta $af0008	            STA BORDER_X_SIZE
.3a01e7	8f 09 00 af	sta $af0009	            STA BORDER_Y_SIZE
.3a01eb	a2 00 00	ldx #$0000	            LDX #0              ; Clear all the sprite control shadow registers
.3a01ee	a9 00		lda #$00	            LDA #0
.3a01f0	9f 18 f0 3a	sta $3af018,x	sp_loop     STA GS_SP_CONTROL,X
.3a01f4	e8		inx		            INX
.3a01f5	e0 40 00	cpx #$0040	            CPX #SP_MAX
.3a01f8	d0 f6		bne $3a01f0	            BNE sp_loop
.3a01fa	a9 80		lda #$80	            LDA #DEV_SCREEN
.3a01fc	8f b4 08 00	sta $0008b4	            STA @lBCONSOLE
.3a0200	e2 20		sep #$20	            SEP #$20
.3a0202	a9 00		lda #$00	            LDA #0                  ; Clear the lock key flags
.3a0204	8f 89 0f 00	sta $000f89	            STA @lKEYBOARD_LOCKS
.3a0208	a9 00		lda #$00	            LDA #0
.3a020a	8f 00 02 af	sta $af0200	            STA @l TL0_CONTROL_REG
.3a020e	8f 0c 02 af	sta $af020c	            STA @l TL1_CONTROL_REG
.3a0212	8f 18 02 af	sta $af0218	            STA @l TL2_CONTROL_REG
.3a0216	8f 24 02 af	sta $af0224	            STA @l TL3_CONTROL_REG
.3a021a					done
.3a021a	60		rts		            RTS
.3a021b					INITRNG
.3a021b	08		php		            PHP
.3a021c	e2 20		sep #$20	            SEP #$20
.3a021e	af 0e 08 af	lda $af080e	            LDA @l RTC_CTRL         ; Pause updates to the clock registers
.3a0222	09 08		ora #$08	            ORA #%00001000
.3a0224	8f 0e 08 af	sta $af080e	            STA @l RTC_CTRL
.3a0228	af 00 08 af	lda $af0800	            LDA @l RTC_SEC          ; Set the random number generator seed
.3a022c	8f 84 e8 af	sta $afe884	            STA @l GABE_RNG_SEED_LO
.3a0230	af 02 08 af	lda $af0802	            LDA @l RTC_MIN
.3a0234	8f 85 e8 af	sta $afe885	            STA @l GABE_RNG_SEED_HI
.3a0238	a9 03		lda #$03	            LDA #GABE_RNG_CTRL_DV | GABE_RNG_CTRL_EN
.3a023a	8f 86 e8 af	sta $afe886	            STA @l GABE_RNG_CTRL    ; Load the seed into the RNG
.3a023e	af 0e 08 af	lda $af080e	            LDA @l RTC_CTRL         ; Re-enable updates to the clock registers
.3a0242	29 f7		and #$f7	            AND #%11110111
.3a0244	8f 0e 08 af	sta $af080e	            STA @l RTC_CTRL
.3a0248	ea		nop		            NOP                     ; Give the RNG some time... not sure if needed, really
.3a0249	ea		nop		            NOP
.3a024a	ea		nop		            NOP
.3a024b	a9 01		lda #$01	            LDA #GABE_RNG_CTRL_EN   ; Turn on the random number genertator
.3a024d	8f 86 e8 af	sta $afe886	            STA @l GABE_RNG_CTRL
.3a0251	28		plp		            PLP
.3a0252	60		rts		            RTS
.3a0253					SCREEN_PUTC
.3a0253	08		php		            PHP
.3a0254	e2 20		sep #$20	            SEP #$20
.3a0256	48		pha		            PHA
.3a0257	48		pha		            PHA
.3a0258	a9 00		lda #$00	            LDA #CHAN_CONSOLE       ; Switch to the console device
.3a025a	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.3a025e	68		pla		            PLA
.3a025f	22 18 10 00	jsl $001018	            JSL FK_PUTC
.3a0263	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.3a0267	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.3a0269	d0 f8		bne $3a0263	            BNE loop                ; Yes: wait until it's released
.3a026b	68		pla		            PLA
.3a026c	28		plp		            PLP
.3a026d	60		rts		            RTS
.3a026e					UART_PUTC
.3a026e	08		php		            PHP
.3a026f	e2 20		sep #$20	            SEP #$20
.3a0271	48		pha		            PHA
.3a0272	48		pha		            PHA
.3a0273	a9 01		lda #$01	            LDA #CHAN_COM1          ; Switch to COM1
.3a0275	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.3a0279	68		pla		            PLA
.3a027a	22 18 10 00	jsl $001018	            JSL FK_PUTC
.3a027e	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.3a0282	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.3a0284	d0 f8		bne $3a027e	            BNE loop                ; Yes: wait until it's released
.3a0286	68		pla		            PLA
.3a0287	28		plp		            PLP
.3a0288	60		rts		            RTS
.3a0289					PRINTCR
.3a0289	08		php		            PHP
.3a028a	c2 20		rep #$20	            REP #$20
.3a028c	48		pha		            PHA
.3a028d	e2 20		sep #$20	            SEP #$20
.3a028f	a9 0d		lda #$0d	            LDA #CHAR_CR
.3a0291	20 18 00	jsr $3a0018	            JSR PRINTC
.3a0294	c2 20		rep #$20	            REP #$20
.3a0296	68		pla		            PLA
.3a0297	28		plp		            PLP
.3a0298	60		rts		            RTS
.3a0299					PRINTH
.3a0299	08		php		            PHP
.3a029a	22 78 10 00	jsl $001078	            JSL FK_IPRINTH
.3a029e	28		plp		            PLP
.3a029f	60		rts		            RTS

;******  Return to file: src\bios.s

=10					LINES_PER_PAGE = 10     ; The number of lines to print on a page before pausing
=$80					DEV_SCREEN = $80        ; Use the screen and keyboard for the console device
=$40					DEV_UART = $40          ; Use UART for console device
=$20					DEV_BUFFER = $20        ; Use the current text memory buffer for output or input
>08b4					BCONSOLE    .byte ?     ; Device for BASIC console
>08b5					SAVE_A      .byte ?     ; Save spot for the A register
>08b6					LINECOUNT   .byte ?     ; Counter for new lines to support pagination
.3a02a0					PAGINATE
.3a02a0	08		php		            PHP
.3a02a1	0b		phd		            PHD
.3a02a2	08		php		            PHP
.3a02a3	c2 20		rep #$20	            REP #$20
.3a02a5	48		pha		            PHA
.3a02a6	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a02a9	5b		tcd		            TCD
.3a02aa	68		pla		            PLA
.3a02ab	28		plp		            PLP
.3a02ac	e2 20		sep #$20	            SEP #$20
.3a02ae	a5 b6		lda $08b6	            LDA LINECOUNT           ; Check the line count
.3a02b0	1a		inc a		            INC A
.3a02b1	85 b6		sta $08b6	            STA LINECOUNT
.3a02b3	cf 13 00 00	cmp $000013	            CMP @l LINES_VISIBLE
.3a02b7	90 05		bcc $3a02be	            BLT done                ; If < limit, just return
.3a02b9	20 14 00	jsr $3a0014	            JSR GETKEY
.3a02bc	64 b6		stz $08b6	            STZ LINECOUNT           ; And reset the line count
.3a02be	2b		pld		done        PLD
.3a02bf	28		plp		            PLP
.3a02c0	60		rts		            RTS
.3a02c1					IPRINTC
.3a02c1	da		phx		            PHX
.3a02c2	5a		phy		            PHY
.3a02c3	0b		phd		            PHD
.3a02c4	08		php		            PHP
.3a02c5	08		php		            PHP
.3a02c6	c2 20		rep #$20	            REP #$20
.3a02c8	48		pha		            PHA
.3a02c9	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a02cc	5b		tcd		            TCD
.3a02cd	68		pla		            PLA
.3a02ce	28		plp		            PLP
.3a02cf	e2 20		sep #$20	            SEP #$20
.3a02d1	c2 10		rep #$10	            REP #$10
.3a02d3	8f b5 08 00	sta $0008b5	            STA @lSAVE_A
.3a02d7	af b4 08 00	lda $0008b4	chk_out     LDA @lBCONSOLE      ; Check to see if we should send to an output buffer
.3a02db	29 20		and #$20	            AND #DEV_BUFFER
.3a02dd	f0 07		beq $3a02e6	            BEQ check_scrn      ; No... move on to the hardware screen
.3a02df	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.3a02e3	20 28 00	jsr $3a0028	            JSR OBUFF_PUTC
.3a02e6	af b4 08 00	lda $0008b4	check_scrn  LDA @lBCONSOLE
.3a02ea	29 80		and #$80	            AND #DEV_SCREEN     ; Check to see if the screen is selected
.3a02ec	f0 07		beq $3a02f5	            BEQ send_uart
.3a02ee	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.3a02f2	20 53 02	jsr $3a0253	            JSR SCREEN_PUTC
.3a02f5	af b4 08 00	lda $0008b4	send_uart   LDA @lBCONSOLE
.3a02f9	29 40		and #$40	            AND #DEV_UART       ; Check to see if the UART is active
.3a02fb	f0 14		beq $3a0311	            BEQ done
.3a02fd	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.3a0301	20 6e 02	jsr $3a026e	            JSR UART_PUTC
.3a0304	af b5 08 00	lda $0008b5	            LDA @lSAVE_A        ; If sending a CR to the serial port
.3a0308	c9 0d		cmp #$0d	            CMP #CHAR_CR
.3a030a	d0 05		bne $3a0311	            BNE done
.3a030c	a9 0a		lda #$0a	            LDA #CHAR_LF        ; Send a linefeed after
.3a030e	20 6e 02	jsr $3a026e	            JSR UART_PUTC
.3a0311	28		plp		done        PLP
.3a0312	2b		pld		            PLD
.3a0313	7a		ply		            PLY
.3a0314	fa		plx		            PLX
.3a0315	60		rts		            RTS
.3a0316					PRINTS
.3a0316	08		php		            PHP
.3a0317	e2 20		sep #$20	            SEP #$20
.3a0319	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.3a031c	f0 06		beq $3a0324	            BEQ done
.3a031e	20 18 00	jsr $3a0018	            JSR PRINTC
.3a0321	e8		inx		            INX
.3a0322	80 f5		bra $3a0319	            BRA loop
.3a0324	28		plp		done        PLP
.3a0325	60		rts		            RTS
.3a0326					PRHEXW
.3a0326	08		php		            PHP
.3a0327	c2 20		rep #$20	            REP #$20
.3a0329	48		pha		            PHA
.3a032a	48		pha		            PHA
.3a032b	4a		lsr a		            LSR A
.3a032c	4a		lsr a		            LSR A
.3a032d	4a		lsr a		            LSR A
.3a032e	4a		lsr a		            LSR A
.3a032f	4a		lsr a		            LSR A
.3a0330	4a		lsr a		            LSR A
.3a0331	4a		lsr a		            LSR A
.3a0332	4a		lsr a		            LSR A
.3a0333	20 40 03	jsr $3a0340	            JSR PRHEXB
.3a0336	68		pla		            PLA
.3a0337	29 ff 00	and #$00ff	            AND #$00FF
.3a033a	20 40 03	jsr $3a0340	            JSR PRHEXB
.3a033d	68		pla		            PLA
.3a033e	28		plp		            PLP
.3a033f	60		rts		            RTS
.3a0340					PRHEXB
.3a0340	08		php		            PHP
.3a0341	c2 20		rep #$20	            REP #$20
.3a0343	48		pha		            PHA
.3a0344	e2 20		sep #$20	            SEP #$20
.3a0346	48		pha		            PHA
.3a0347	4a		lsr a		            LSR A
.3a0348	4a		lsr a		            LSR A
.3a0349	4a		lsr a		            LSR A
.3a034a	4a		lsr a		            LSR A
.3a034b	20 57 03	jsr $3a0357	            JSR PRHEXN
.3a034e	68		pla		            PLA
.3a034f	20 57 03	jsr $3a0357	            JSR PRHEXN
.3a0352	c2 20		rep #$20	            REP #$20
.3a0354	68		pla		            PLA
.3a0355	28		plp		            PLP
.3a0356	60		rts		            RTS
.3a0357					PRHEXN
.3a0357	08		php		            PHP
.3a0358	c2 30		rep #$30	            REP #$30
.3a035a	da		phx		            PHX
.3a035b	29 0f 00	and #$000f	            AND #$000F
.3a035e	aa		tax		            TAX
.3a035f	bf 00 d0 3a	lda $3ad000,x	            LDA @lHEXDIGITS,X
.3a0363	20 18 00	jsr $3a0018	            JSR PRINTC
.3a0366	fa		plx		            PLX
.3a0367	28		plp		            PLP
.3a0368	60		rts		            RTS
>3ad000	30 31 32 33 34 35 36 37		HEXDIGITS   .text "0123456789ABCDEF"
>3ad008	38 39 41 42 43 44 45 46

;******  Return to file: src\basic816.s


;******  Processing file: src\utilities.s

.3a0369					PRTRACE
.3a0369	08		php		            PHP
.3a036a	c2 30		rep #$30	            REP #$30
.3a036c	48		pha		            PHA
.3a036d	da		phx		            PHX
.3a036e	5a		phy		            PHY
.3a036f	8b		phb		            PHB
.3a0370	0b		phd		            PHD
.3a0371	c2 30		rep #$30	            REP #$30
.3a0373	a3 0b		lda $0b,s	            LDA 11,S        ; Get the return address
.3a0375	18		clc		calc_addr   CLC
.3a0376	69 03 00	adc #$0003	            ADC #3          ; Add 3 to skip over the following branch
.3a0379	aa		tax		            TAX
.3a037a	e2 20		sep #$20	            SEP #$20
.3a037c	a9 3a		lda #$3a	            LDA #`PRTRACE
.3a037e	48		pha		            PHA
.3a037f	ab		plb		            PLB
.3a0380	bd 00 00	lda $0000,x	pr_loop     LDA #0,B,X
.3a0383	f0 06		beq $3a038b	            BEQ done
.3a0385	20 53 02	jsr $3a0253	            JSR SCREEN_PUTC
.3a0388	e8		inx		            INX
.3a0389	80 f5		bra $3a0380	            BRA pr_loop
.3a038b					done
.3a038b	c2 30		rep #$30	            REP #$30
.3a038d	2b		pld		            PLD
.3a038e	ab		plb		            PLB
.3a038f	7a		ply		            PLY
.3a0390	fa		plx		            PLX
.3a0391	68		pla		            PLA
.3a0392	28		plp		            PLP
.3a0393	60		rts		            RTS
.3a0394					ISALPHA
.3a0394	08		php		            PHP
.3a0395	e2 20		sep #$20	            SEP #$20
.3a0397	c9 5b		cmp #$5b	            CMP #'Z'+1
.3a0399	b0 04		bcs $3a039f	            BGE not_upper
.3a039b	c9 41		cmp #$41	            CMP #'A'
.3a039d	b0 0b		bcs $3a03aa	            BGE is_alpha
.3a039f	c9 7b		cmp #$7b	not_upper   CMP #'z'+1
.3a03a1	b0 04		bcs $3a03a7	            BGE not_alpha
.3a03a3	c9 61		cmp #$61	            CMP #'a'
.3a03a5	b0 03		bcs $3a03aa	            BGE is_alpha
.3a03a7					not_alpha
.3a03a7	28		plp		            PLP
.3a03a8	18		clc		            CLC
.3a03a9	60		rts		            RTS
.3a03aa					is_alpha
.3a03aa	28		plp		            PLP
.3a03ab	38		sec		            SEC
.3a03ac	60		rts		            RTS
.3a03ad					ISNUMERAL
.3a03ad	08		php		            PHP
.3a03ae	e2 20		sep #$20	            SEP #$20
.3a03b0	c9 3a		cmp #$3a	            CMP #'9'+1
.3a03b2	b0 04		bcs $3a03b8	            BGE ret_false
.3a03b4	c9 30		cmp #$30	            CMP #'0'
.3a03b6	b0 03		bcs $3a03bb	            BGE ret_true
.3a03b8	28		plp		ret_false   PLP
.3a03b9	18		clc		            CLC
.3a03ba	60		rts		            RTS
.3a03bb	28		plp		ret_true    PLP
.3a03bc	38		sec		            SEC
.3a03bd	60		rts		            RTS
.3a03be					ISHEX
.3a03be	08		php		            PHP
.3a03bf	e2 20		sep #$20	            SEP #$20
.3a03c1	c9 3a		cmp #$3a	            CMP #'9'+1
.3a03c3	b0 04		bcs $3a03c9	            BGE chk_lca2f
.3a03c5	c9 30		cmp #$30	            CMP #'0'
.3a03c7	b0 13		bcs $3a03dc	            BGE ret_true
.3a03c9	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.3a03cb	b0 04		bcs $3a03d1	            BGE chk_uca2f
.3a03cd	c9 61		cmp #$61	            CMP #'a'
.3a03cf	b0 0b		bcs $3a03dc	            BGE ret_true
.3a03d1	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.3a03d3	b0 04		bcs $3a03d9	            BGE ret_false
.3a03d5	c9 41		cmp #$41	            CMP #'A'
.3a03d7	b0 03		bcs $3a03dc	            BGE ret_true
.3a03d9	28		plp		ret_false   PLP
.3a03da	18		clc		            CLC
.3a03db	60		rts		            RTS
.3a03dc	28		plp		ret_true    PLP
.3a03dd	38		sec		            SEC
.3a03de	60		rts		            RTS
.3a03df					HEX2BIN
.3a03df	08		php		            PHP
.3a03e0	e2 20		sep #$20	            SEP #$20
.3a03e2	c9 3a		cmp #$3a	            CMP #'9'+1          ; Check to see if '0'..'9'
.3a03e4	b0 04		bcs $3a03ea	            BGE chk_lca2f
.3a03e6	c9 30		cmp #$30	            CMP #'0'
.3a03e8	b0 12		bcs $3a03fc	            BGE conv_09         ; Yes: convert it
.3a03ea	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.3a03ec	b0 04		bcs $3a03f2	            BGE chk_uca2f
.3a03ee	c9 61		cmp #$61	            CMP #'a'
.3a03f0	b0 0f		bcs $3a0401	            BGE conv_lcaf
.3a03f2	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.3a03f4	b0 04		bcs $3a03fa	            BGE done
.3a03f6	c9 41		cmp #$41	            CMP #'A'
.3a03f8	b0 09		bcs $3a0403	            BGE conv_ucaf
.3a03fa	28		plp		done        PLP
.3a03fb	60		rts		            RTS
.3a03fc	38		sec		conv_09     SEC                 ; Convert digits '0'..'9'
.3a03fd	e9 30		sbc #$30	            SBC #'0'
.3a03ff	80 f9		bra $3a03fa	            BRA done
.3a0401	29 df		and #$df	conv_lcaf   AND #%11011111      ; Convert to upper case
.3a0403	38		sec		conv_ucaf   SEC
.3a0404	e9 37		sbc #$37	            SBC #'A'-10         ; Convert 'A'..'F'
.3a0406	80 f2		bra $3a03fa	            BRA done
.3a0408					TOUPPERA
.3a0408	08		php		            PHP
.3a0409	e2 20		sep #$20	            SEP #$20
.3a040b	c9 7b		cmp #$7b	            CMP #'z'+1
.3a040d	b0 06		bcs $3a0415	            BCS done
.3a040f	c9 61		cmp #$61	            CMP #'a'
.3a0411	90 02		bcc $3a0415	            BCC done
.3a0413	29 df		and #$df	            AND #%11011111
.3a0415	28		plp		done        PLP
.3a0416	60		rts		            RTS
.3a0417					TOUPPER
.3a0417	08		php		            PHP
.3a0418	e2 20		sep #$20	            SEP #$20
.3a041a	c2 10		rep #$10	            REP #$10
.3a041c	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.3a041f	f0 09		beq $3a042a	            BEQ done
.3a0421	20 08 04	jsr $3a0408	            JSR TOUPPERA
.3a0424	9d 00 00	sta $0000,x	            STA #0,B,X
.3a0427	e8		inx		continue    INX
.3a0428	80 f2		bra $3a041c	            BRA loop
.3a042a	28		plp		done        PLP
.3a042b	60		rts		            RTS
.3a042c					MULINT10
.3a042c	08		php		                PHP
.3a042d	0b		phd		                PHD
.3a042e	08		php		            PHP
.3a042f	c2 20		rep #$20	            REP #$20
.3a0431	48		pha		            PHA
.3a0432	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0435	5b		tcd		            TCD
.3a0436	68		pla		            PLA
.3a0437	28		plp		            PLP
.3a0438	c2 20		rep #$20	            REP #$20
.3a043a	48		pha		                PHA
.3a043b	06 23		asl $0823	                ASL ARGUMENT1           ; 7 -- 20 -- 74
.3a043d	26 25		rol $0825	                ROL ARGUMENT1+2         ; 7
.3a043f	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.3a0441	85 0c		sta $080c	                STA SCRATCH             ; 4
.3a0443	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.3a0445	85 0e		sta $080e	                STA SCRATCH+2           ; 4
.3a0447	06 0c		asl $080c	                ASL SCRATCH             ; 7 -- 28
.3a0449	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.3a044b	06 0c		asl $080c	                ASL SCRATCH             ; 7
.3a044d	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.3a044f	18		clc		                CLC                     ; 2 -- 26
.3a0450	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.3a0452	65 0c		adc $080c	                ADC SCRATCH             ; 4
.3a0454	85 23		sta $0823	                STA ARGUMENT1           ; 4
.3a0456	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.3a0458	65 0e		adc $080e	                ADC SCRATCH+2           ; 4
.3a045a	85 25		sta $0825	                STA ARGUMENT1+2         ; 4
.3a045c	68		pla		                PLA
.3a045d	2b		pld		                PLD
.3a045e	28		plp		                PLP
.3a045f	60		rts		            RTS
.3a0460					DIVINT10
.3a0460	08		php		                PHP
.3a0461	0b		phd		                PHD
.3a0462	08		php		            PHP
.3a0463	c2 20		rep #$20	            REP #$20
.3a0465	48		pha		            PHA
.3a0466	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0469	5b		tcd		            TCD
.3a046a	68		pla		            PLA
.3a046b	28		plp		            PLP
.3a046c	c2 20		rep #$20	            REP #$20
.3a046e	a5 23		lda $0823	                LDA ARGUMENT1
.3a0470	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.3a0474	a9 0a 00	lda #$000a	                LDA #10
.3a0477	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.3a047b	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.3a047f	85 23		sta $0823	                STA ARGUMENT1
.3a0481	64 25		stz $0825	                STZ ARGUMENT1+2
.3a0483	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.3a0487	85 29		sta $0829	                STA ARGUMENT2
.3a0489	64 2b		stz $082b	                STZ ARGUMENT2+2
.3a048b	e2 20		sep #$20	            SEP #$20
.3a048d	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a048f	85 27		sta $0827	                STA ARGTYPE1
.3a0491	85 2d		sta $082d	                STA ARGTYPE2
.3a0493	2b		pld		                PLD
.3a0494	28		plp		                PLP
.3a0495	60		rts		            RTS
.3a0496					DIVINT100
.3a0496	08		php		                PHP
.3a0497	0b		phd		                PHD
.3a0498	08		php		            PHP
.3a0499	c2 20		rep #$20	            REP #$20
.3a049b	48		pha		            PHA
.3a049c	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a049f	5b		tcd		            TCD
.3a04a0	68		pla		            PLA
.3a04a1	28		plp		            PLP
.3a04a2	c2 20		rep #$20	            REP #$20
.3a04a4	a5 23		lda $0823	                LDA ARGUMENT1
.3a04a6	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.3a04aa	a9 64 00	lda #$0064	                LDA #100
.3a04ad	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.3a04b1	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.3a04b5	85 23		sta $0823	                STA ARGUMENT1
.3a04b7	64 25		stz $0825	                STZ ARGUMENT1+2
.3a04b9	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.3a04bd	85 29		sta $0829	                STA ARGUMENT2
.3a04bf	64 2b		stz $082b	                STZ ARGUMENT2+2
.3a04c1	e2 20		sep #$20	            SEP #$20
.3a04c3	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a04c5	85 27		sta $0827	                STA ARGTYPE1
.3a04c7	85 2d		sta $082d	                STA ARGTYPE2
.3a04c9	2b		pld		                PLD
.3a04ca	28		plp		                PLP
.3a04cb	60		rts		            RTS
.3a04cc					IS_ARG1_Z
.3a04cc	08		php		                PHP
.3a04cd	c2 20		rep #$20	            REP #$20
.3a04cf	a5 23		lda $0823	                LDA ARGUMENT1
.3a04d1	d0 08		bne $3a04db	                BNE return_false
.3a04d3	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a04d5	d0 04		bne $3a04db	                BNE return_false
.3a04d7	28		plp		return_true     PLP
.3a04d8	e2 02		sep #$02	                SEP #$02        ; Set Z
.3a04da	60		rts		            RTS
.3a04db	28		plp		return_false    PLP
.3a04dc	c2 02		rep #$02	                REP #$02        ; Clear Z
.3a04de	60		rts		            RTS
.3a04df					SET_TRUE
.3a04df	08		php		                PHP
.3a04e0	c2 30		rep #$30	            REP #$30
.3a04e2	a9 ff ff	lda #$ffff	                LDA #$FFFF
.3a04e5	85 23		sta $0823	                STA ARGUMENT1
.3a04e7	85 25		sta $0825	                STA ARGUMENT1+2
.3a04e9	e2 20		sep #$20	            SEP #$20
.3a04eb	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a04ed	85 27		sta $0827	                STA ARGTYPE1
.3a04ef	28		plp		                PLP
.3a04f0	60		rts		            RTS
.3a04f1					SET_FALSE
.3a04f1	08		php		                PHP
.3a04f2	c2 30		rep #$30	            REP #$30
.3a04f4	a9 00 00	lda #$0000	                LDA #0
.3a04f7	85 23		sta $0823	                STA ARGUMENT1
.3a04f9	85 25		sta $0825	                STA ARGUMENT1+2
.3a04fb	e2 20		sep #$20	            SEP #$20
.3a04fd	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a04ff	85 27		sta $0827	                STA ARGTYPE1
.3a0501	28		plp		                PLP
.3a0502	60		rts		            RTS
.3a0503					ASS_ARG1_INT
.3a0503	08		php		                PHP
.3a0504	e2 20		sep #$20	            SEP #$20
.3a0506	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.3a0508	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a050a	f0 07		beq $3a0513	                BEQ done                ; If so: just return
.3a050c	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.3a050e	d0 05		bne $3a0515	                BNE TYPE_ERR            ; If not: throw an error
.3a0510	20 52 59	jsr $3a5952	            JSR FTOI
.3a0513	28		plp		done            PLP
.3a0514	60		rts		            RTS
.3a0515					TYPE_ERR
.3a0515	08		php		            PHP
.3a0516	c2 20		rep #$20	            REP #$20
.3a0518	48		pha		            PHA
.3a0519	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a051c	5b		tcd		            TCD
.3a051d	68		pla		            PLA
.3a051e	28		plp		            PLP
.3a051f	e2 20		sep #$20	            SEP #$20
.3a0521	a9 04		lda #$04	            LDA #ERR_TYPE
.3a0523	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0527	c2 20		rep #$20	            REP #$20
.3a0529	29 ff 00	and #$00ff	            AND #$00FF
.3a052c	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a052f	e2 20		sep #$20	            SEP #$20
.3a0531	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0534					ASS_ARG2_INT
.3a0534	08		php		                PHP
.3a0535	e2 20		sep #$20	            SEP #$20
.3a0537	a5 2d		lda $082d	                LDA ARGTYPE2                ; Verify that the type is INTEGER
.3a0539	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a053b	f0 37		beq $3a0574	                BEQ done                    ; If so: just return
.3a053d	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; Check if it's a float
.3a053f	d0 35		bne $3a0576	                BNE TYPE_ERR                ; If not: throw an error
.3a0541	c2 20		rep #$20	            REP #$20
.3a0543	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a0545	48		pha		            PHA
.3a0546	a5 23		lda $0823	            LDA ARGUMENT1
.3a0548	48		pha		            PHA
.3a0549	c2 20		rep #$20	            REP #$20
.3a054b	a5 29		lda $0829	            LDA ARGUMENT2
.3a054d	85 23		sta $0823	            STA ARGUMENT1
.3a054f	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a0551	85 25		sta $0825	            STA ARGUMENT1+2
.3a0553	e2 20		sep #$20	            SEP #$20
.3a0555	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.3a0557	85 27		sta $0827	            STA ARGTYPE1
.3a0559	20 52 59	jsr $3a5952	            JSR FTOI
.3a055c	c2 20		rep #$20	            REP #$20
.3a055e	a5 23		lda $0823	            LDA ARGUMENT1
.3a0560	85 29		sta $0829	            STA ARGUMENT2
.3a0562	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a0564	85 2b		sta $082b	            STA ARGUMENT2+2
.3a0566	e2 20		sep #$20	            SEP #$20
.3a0568	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.3a056a	85 2d		sta $082d	            STA ARGTYPE2
.3a056c	c2 20		rep #$20	            REP #$20
.3a056e	68		pla		            PLA
.3a056f	85 23		sta $0823	            STA ARGUMENT1
.3a0571	68		pla		            PLA
.3a0572	85 25		sta $0825	            STA ARGUMENT1+2
.3a0574	28		plp		done            PLP
.3a0575	60		rts		            RTS
.3a0576					TYPE_ERR
.3a0576	08		php		            PHP
.3a0577	c2 20		rep #$20	            REP #$20
.3a0579	48		pha		            PHA
.3a057a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a057d	5b		tcd		            TCD
.3a057e	68		pla		            PLA
.3a057f	28		plp		            PLP
.3a0580	e2 20		sep #$20	            SEP #$20
.3a0582	a9 04		lda #$04	            LDA #ERR_TYPE
.3a0584	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0588	c2 20		rep #$20	            REP #$20
.3a058a	29 ff 00	and #$00ff	            AND #$00FF
.3a058d	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a0590	e2 20		sep #$20	            SEP #$20
.3a0592	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0595					ASS_ARG1_STR
.3a0595	08		php		                PHP
.3a0596	e2 20		sep #$20	            SEP #$20
.3a0598	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is STRING
.3a059a	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a059c	d0 02		bne $3a05a0	                BNE TYPE_ERR
.3a059e	28		plp		                PLP
.3a059f	60		rts		            RTS
.3a05a0					TYPE_ERR
.3a05a0	08		php		            PHP
.3a05a1	c2 20		rep #$20	            REP #$20
.3a05a3	48		pha		            PHA
.3a05a4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a05a7	5b		tcd		            TCD
.3a05a8	68		pla		            PLA
.3a05a9	28		plp		            PLP
.3a05aa	e2 20		sep #$20	            SEP #$20
.3a05ac	a9 04		lda #$04	            LDA #ERR_TYPE
.3a05ae	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a05b2	c2 20		rep #$20	            REP #$20
.3a05b4	29 ff 00	and #$00ff	            AND #$00FF
.3a05b7	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a05ba	e2 20		sep #$20	            SEP #$20
.3a05bc	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a05bf					ASS_ARG1_INT16
.3a05bf	08		php		                PHP
.3a05c0	e2 20		sep #$20	            SEP #$20
.3a05c2	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.3a05c4	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a05c6	f0 07		beq $3a05cf	                BEQ check_range         ; If so: check the range
.3a05c8	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.3a05ca	d0 0b		bne $3a05d7	                BNE TYPE_ERR            ; If not: throw an error
.3a05cc	20 52 59	jsr $3a5952	            JSR FTOI
.3a05cf					check_range
.3a05cf	c2 20		rep #$20	            REP #$20
.3a05d1	a5 25		lda $0825	                LDA ARGUMENT1+2         ; Validate it is 16-bit
.3a05d3	d0 21		bne $3a05f6	                BNE range_err
.3a05d5	28		plp		                PLP
.3a05d6	60		rts		            RTS
.3a05d7					TYPE_ERR
.3a05d7	08		php		            PHP
.3a05d8	c2 20		rep #$20	            REP #$20
.3a05da	48		pha		            PHA
.3a05db	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a05de	5b		tcd		            TCD
.3a05df	68		pla		            PLA
.3a05e0	28		plp		            PLP
.3a05e1	e2 20		sep #$20	            SEP #$20
.3a05e3	a9 04		lda #$04	            LDA #ERR_TYPE
.3a05e5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a05e9	c2 20		rep #$20	            REP #$20
.3a05eb	29 ff 00	and #$00ff	            AND #$00FF
.3a05ee	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a05f1	e2 20		sep #$20	            SEP #$20
.3a05f3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a05f6					RANGE_ERR
.3a05f6	08		php		            PHP
.3a05f7	c2 20		rep #$20	            REP #$20
.3a05f9	48		pha		            PHA
.3a05fa	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a05fd	5b		tcd		            TCD
.3a05fe	68		pla		            PLA
.3a05ff	28		plp		            PLP
.3a0600	e2 20		sep #$20	            SEP #$20
.3a0602	a9 09		lda #$09	            LDA #ERR_RANGE
.3a0604	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0608	c2 20		rep #$20	            REP #$20
.3a060a	29 ff 00	and #$00ff	            AND #$00FF
.3a060d	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a0610	e2 20		sep #$20	            SEP #$20
.3a0612	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0615					ASS_ARG1_BYTE
.3a0615	08		php		                PHP
.3a0616	e2 20		sep #$20	            SEP #$20
.3a0618	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.3a061a	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a061c	f0 07		beq $3a0625	                BEQ check_range         ; If so: check the range
.3a061e	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.3a0620	d0 11		bne $3a0633	                BNE TYPE_ERR            ; If not: throw an error
.3a0622	20 52 59	jsr $3a5952	            JSR FTOI
.3a0625	a5 26		lda $0826	check_range     LDA ARGUMENT1+3         ; Validate that the value is in byte range
.3a0627	d0 29		bne $3a0652	                BNE RANGE_ERR           ; If not... throw a range error
.3a0629	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a062b	d0 25		bne $3a0652	                BNE RANGE_ERR
.3a062d	a5 24		lda $0824	                LDA ARGUMENT1+1
.3a062f	d0 21		bne $3a0652	                BNE RANGE_ERR
.3a0631	28		plp		                PLP
.3a0632	60		rts		            RTS
.3a0633					TYPE_ERR
.3a0633	08		php		            PHP
.3a0634	c2 20		rep #$20	            REP #$20
.3a0636	48		pha		            PHA
.3a0637	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a063a	5b		tcd		            TCD
.3a063b	68		pla		            PLA
.3a063c	28		plp		            PLP
.3a063d	e2 20		sep #$20	            SEP #$20
.3a063f	a9 04		lda #$04	            LDA #ERR_TYPE
.3a0641	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0645	c2 20		rep #$20	            REP #$20
.3a0647	29 ff 00	and #$00ff	            AND #$00FF
.3a064a	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a064d	e2 20		sep #$20	            SEP #$20
.3a064f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0652					RANGE_ERR
.3a0652	08		php		            PHP
.3a0653	c2 20		rep #$20	            REP #$20
.3a0655	48		pha		            PHA
.3a0656	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a0659	5b		tcd		            TCD
.3a065a	68		pla		            PLA
.3a065b	28		plp		            PLP
.3a065c	e2 20		sep #$20	            SEP #$20
.3a065e	a9 09		lda #$09	            LDA #ERR_RANGE
.3a0660	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0664	c2 20		rep #$20	            REP #$20
.3a0666	29 ff 00	and #$00ff	            AND #$00FF
.3a0669	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a066c	e2 20		sep #$20	            SEP #$20
.3a066e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0671					ASS_ARG1_FLOAT
.3a0671	08		php		                PHP
.3a0672	e2 20		sep #$20	            SEP #$20
.3a0674	a5 27		lda $0827	                LDA ARGTYPE1            ; Check the type
.3a0676	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.3a0678	f0 26		beq $3a06a0	                BEQ done                ; Then we're done
.3a067a	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.3a067c	f0 1f		beq $3a069d	                BEQ cast                ; Then cast it to float
.3a067e					type_err
.3a067e	08		php		            PHP
.3a067f	c2 20		rep #$20	            REP #$20
.3a0681	48		pha		            PHA
.3a0682	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a0685	5b		tcd		            TCD
.3a0686	68		pla		            PLA
.3a0687	28		plp		            PLP
.3a0688	e2 20		sep #$20	            SEP #$20
.3a068a	a9 04		lda #$04	            LDA #ERR_TYPE
.3a068c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0690	c2 20		rep #$20	            REP #$20
.3a0692	29 ff 00	and #$00ff	            AND #$00FF
.3a0695	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a0698	e2 20		sep #$20	            SEP #$20
.3a069a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a069d					cast
.3a069d	20 4c 59	jsr $3a594c	            JSR ITOF
.3a06a0	28		plp		done            PLP
.3a06a1	60		rts		            RTS
.3a06a2					ASS_ARG2_FLOAT
.3a06a2	08		php		                PHP
.3a06a3	e2 20		sep #$20	            SEP #$20
.3a06a5	a5 2d		lda $082d	                LDA ARGTYPE2            ; Check the type
.3a06a7	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.3a06a9	f0 26		beq $3a06d1	                BEQ done                ; Then we're done
.3a06ab	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.3a06ad	f0 1f		beq $3a06ce	                BEQ cast                ; Then cast it to float
.3a06af					type_err
.3a06af	08		php		            PHP
.3a06b0	c2 20		rep #$20	            REP #$20
.3a06b2	48		pha		            PHA
.3a06b3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a06b6	5b		tcd		            TCD
.3a06b7	68		pla		            PLA
.3a06b8	28		plp		            PLP
.3a06b9	e2 20		sep #$20	            SEP #$20
.3a06bb	a9 04		lda #$04	            LDA #ERR_TYPE
.3a06bd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a06c1	c2 20		rep #$20	            REP #$20
.3a06c3	29 ff 00	and #$00ff	            AND #$00FF
.3a06c6	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a06c9	e2 20		sep #$20	            SEP #$20
.3a06cb	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a06ce					cast
.3a06ce	20 d3 06	jsr $3a06d3	            JSR CAST_ARG2_FLOAT
.3a06d1	28		plp		done            PLP
.3a06d2	60		rts		            RTS
.3a06d3					CAST_ARG2_FLOAT
.3a06d3	c2 20		rep #$20	            REP #$20
.3a06d5	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a06d7	48		pha		            PHA
.3a06d8	a5 23		lda $0823	            LDA ARGUMENT1
.3a06da	48		pha		            PHA
.3a06db	c2 20		rep #$20	            REP #$20
.3a06dd	a5 29		lda $0829	            LDA ARGUMENT2
.3a06df	85 23		sta $0823	            STA ARGUMENT1
.3a06e1	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a06e3	85 25		sta $0825	            STA ARGUMENT1+2
.3a06e5	e2 20		sep #$20	            SEP #$20
.3a06e7	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.3a06e9	85 27		sta $0827	            STA ARGTYPE1
.3a06eb	20 4c 59	jsr $3a594c	            JSR ITOF
.3a06ee	c2 20		rep #$20	            REP #$20
.3a06f0	a5 23		lda $0823	            LDA ARGUMENT1
.3a06f2	85 29		sta $0829	            STA ARGUMENT2
.3a06f4	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a06f6	85 2b		sta $082b	            STA ARGUMENT2+2
.3a06f8	e2 20		sep #$20	            SEP #$20
.3a06fa	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.3a06fc	85 2d		sta $082d	            STA ARGTYPE2
.3a06fe	c2 20		rep #$20	            REP #$20
.3a0700	68		pla		            PLA
.3a0701	85 23		sta $0823	            STA ARGUMENT1
.3a0703	68		pla		            PLA
.3a0704	85 25		sta $0825	            STA ARGUMENT1+2
.3a0706	60		rts		            RTS
.3a0707					ASS_ARGS_NUM
.3a0707	08		php		                PHP
.3a0708	e2 20		sep #$20	            SEP #$20
.3a070a	a5 27		lda $0827	                LDA ARGTYPE1                ; Check ARGUMENT1
.3a070c	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a070e	f0 23		beq $3a0733	                BEQ arg1_int
.3a0710	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.3a0712	f0 2e		beq $3a0742	                BEQ arg1_float
.3a0714					type_err
.3a0714	08		php		            PHP
.3a0715	c2 20		rep #$20	            REP #$20
.3a0717	48		pha		            PHA
.3a0718	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a071b	5b		tcd		            TCD
.3a071c	68		pla		            PLA
.3a071d	28		plp		            PLP
.3a071e	e2 20		sep #$20	            SEP #$20
.3a0720	a9 04		lda #$04	            LDA #ERR_TYPE
.3a0722	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0726	c2 20		rep #$20	            REP #$20
.3a0728	29 ff 00	and #$00ff	            AND #$00FF
.3a072b	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a072e	e2 20		sep #$20	            SEP #$20
.3a0730	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0733	a5 2d		lda $082d	arg1_int        LDA ARGTYPE2                ; Check argument 2
.3a0735	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If integer, we're done
.3a0737	f0 16		beq $3a074f	                BEQ done
.3a0739	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If not float, throw an error
.3a073b	d0 d7		bne $3a0714	                BNE type_err
.3a073d	20 4c 59	jsr $3a594c	            JSR ITOF
.3a0740	80 0d		bra $3a074f	                BRA done
.3a0742	a5 2d		lda $082d	arg1_float      LDA ARGTYPE2                ; Check argument 2
.3a0744	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If it's float
.3a0746	f0 07		beq $3a074f	                BEQ done                    ; Then we're done
.3a0748	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If it's not integer
.3a074a	d0 c8		bne $3a0714	                BNE type_err                ; Thrown an error
.3a074c	20 d3 06	jsr $3a06d3	            JSR CAST_ARG2_FLOAT
.3a074f					done
.3a074f	e2 20		sep #$20	            SEP #$20
.3a0751	a5 27		lda $0827	                LDA ARGTYPE1                ; Return the type code in A
.3a0753	28		plp		                PLP
.3a0754	60		rts		            RTS
.3a0755					ASS_ARGS_NUMSTR
.3a0755	08		php		                PHP
.3a0756	e2 20		sep #$20	            SEP #$20
.3a0758	a5 27		lda $0827	                LDA ARGTYPE1                ; Check to see if ARGUMENT1 is a string
.3a075a	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a075c	d0 25		bne $3a0783	                BNE numbers
.3a075e	a5 2d		lda $082d	                LDA ARGTYPE2                ; If ARGUMENT1 is a string, make sure ARGUMENT2 is
.3a0760	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a0762	f0 24		beq $3a0788	                BEQ done
.3a0764					TYPE_ERR
.3a0764	08		php		            PHP
.3a0765	c2 20		rep #$20	            REP #$20
.3a0767	48		pha		            PHA
.3a0768	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a076b	5b		tcd		            TCD
.3a076c	68		pla		            PLA
.3a076d	28		plp		            PLP
.3a076e	e2 20		sep #$20	            SEP #$20
.3a0770	a9 04		lda #$04	            LDA #ERR_TYPE
.3a0772	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0776	c2 20		rep #$20	            REP #$20
.3a0778	29 ff 00	and #$00ff	            AND #$00FF
.3a077b	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a077e	e2 20		sep #$20	            SEP #$20
.3a0780	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0783					numbers
.3a0783	20 07 07	jsr $3a0707	            JSR ASS_ARGS_NUM
.3a0786	a5 27		lda $0827	                LDA ARGTYPE1                ; Make sure A is the type
.3a0788	28		plp		done            PLP
.3a0789	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\tokens.s

.0000					TOKEN
>0000					precedence  .byte ?
>0001					length      .byte ?
>0002					name        .word <>?
>0004					eval        .word <>?
>0006					arity       .word <>?
.3a078a					PARSEINT
.3a078a	08		php		            PHP
.3a078b	0b		phd		            PHD
.3a078c	08		php		            PHP
.3a078d	c2 20		rep #$20	            REP #$20
.3a078f	48		pha		            PHA
.3a0790	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0793	5b		tcd		            TCD
.3a0794	68		pla		            PLA
.3a0795	28		plp		            PLP
.3a0796	c2 30		rep #$30	            REP #$30
.3a0798	64 23		stz $0823	            STZ ARGUMENT1       ; Default to Not-a-value
.3a079a	64 25		stz $0825	            STZ ARGUMENT1+2
.3a079c	e2 20		sep #$20	            SEP #$20
.3a079e	64 27		stz $0827	            STZ ARGTYPE1
.3a07a0	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it starts with '$'
.3a07a2	c9 26		cmp #$26	            CMP #'&'
.3a07a4	f0 44		beq $3a07ea	            BEQ check_hex       ; Yes: parse it as a hexadecimal number
.3a07a6					loop
.3a07a6	e2 20		sep #$20	            SEP #$20
.3a07a8	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.3a07aa	20 ad 03	jsr $3a03ad	            JSR ISNUMERAL
.3a07ad	90 76		bcc $3a0825	            BCC done            ; No, we're done parsing
.3a07af	20 2c 04	jsr $3a042c	            JSR MULINT10
.3a07b2	38		sec		            SEC                 ; Convert the ASCII code to a number
.3a07b3	e9 30		sbc #$30	            SBC #'0'
.3a07b5	c2 20		rep #$20	            REP #$20
.3a07b7	29 ff 00	and #$00ff	            AND #$00FF
.3a07ba	18		clc		            CLC
.3a07bb	65 23		adc $0823	            ADC ARGUMENT1
.3a07bd	85 23		sta $0823	            STA ARGUMENT1
.3a07bf	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a07c1	69 00 00	adc #$0000	            ADC #0
.3a07c4	85 25		sta $0825	            STA ARGUMENT1+2
.3a07c6	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a07c9	80 db		bra $3a07a6	            BRA loop            ; And try to process it
.3a07cb					syntaxerr
.3a07cb	08		php		            PHP
.3a07cc	c2 20		rep #$20	            REP #$20
.3a07ce	48		pha		            PHA
.3a07cf	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a07d2	5b		tcd		            TCD
.3a07d3	68		pla		            PLA
.3a07d4	28		plp		            PLP
.3a07d5	e2 20		sep #$20	            SEP #$20
.3a07d7	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a07d9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a07dd	c2 20		rep #$20	            REP #$20
.3a07df	29 ff 00	and #$00ff	            AND #$00FF
.3a07e2	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a07e5	e2 20		sep #$20	            SEP #$20
.3a07e7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a07ea					check_hex
.3a07ea	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a07ed	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.3a07ef	c9 48		cmp #$48	            CMP #'H'            ; Is it 'H'?
.3a07f1	f0 04		beq $3a07f7	            BEQ parse_hex       ; Yes: skip it and parse hex
.3a07f3	c9 68		cmp #$68	            CMP #'h'            ; Is it 'h'?
.3a07f5	d0 d4		bne $3a07cb	            BNE syntaxerr       ; No: throw an error
.3a07f7					parse_hex
.3a07f7	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a07fa					hexloop
.3a07fa	e2 20		sep #$20	            SEP #$20
.3a07fc	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.3a07fe	20 be 03	jsr $3a03be	            JSR ISHEX
.3a0801	90 22		bcc $3a0825	            BCC done            ; No, we're done parsing
.3a0803	20 df 03	jsr $3a03df	            JSR HEX2BIN
.3a0806	c2 20		rep #$20	            REP #$20
.3a0808	06 23		asl $0823	            ASL ARGUMENT1
.3a080a	26 25		rol $0825	            ROL ARGUMENT1+2
.3a080c	06 23		asl $0823	            ASL ARGUMENT1
.3a080e	26 25		rol $0825	            ROL ARGUMENT1+2
.3a0810	06 23		asl $0823	            ASL ARGUMENT1
.3a0812	26 25		rol $0825	            ROL ARGUMENT1+2
.3a0814	06 23		asl $0823	            ASL ARGUMENT1
.3a0816	26 25		rol $0825	            ROL ARGUMENT1+2
.3a0818	29 ff 00	and #$00ff	            AND #$00FF          ; Add binary number to ARGUMENT1
.3a081b	18		clc		            CLC
.3a081c	65 23		adc $0823	            ADC ARGUMENT1
.3a081e	85 23		sta $0823	            STA ARGUMENT1
.3a0820	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a0823	80 d5		bra $3a07fa	            BRA hexloop         ; And try to process it
.3a0825	2b		pld		done        PLD
.3a0826	28		plp		            PLP
.3a0827	60		rts		            RTS
.3a0828					PREVCHAR
.3a0828	08		php		            PHP
.3a0829	c2 30		rep #$30	            REP #$30
.3a082b	a5 04		lda $0804	            LDA BIPPREV
.3a082d	f0 1c		beq $3a084b	            BEQ ret_false
.3a082f	38		sec		            SEC
.3a0830	a5 04		lda $0804	            LDA BIPPREV
.3a0832	e5 1a		sbc $081a	            SBC CURLINE
.3a0834	a8		tay		            TAY
.3a0835	e2 20		sep #$20	            SEP #$20
.3a0837	b7 1a		lda [$081a],y	loop        LDA [CURLINE],Y
.3a0839	f0 10		beq $3a084b	            BEQ ret_false
.3a083b	c9 20		cmp #$20	            CMP #CHAR_SP
.3a083d	f0 06		beq $3a0845	            BEQ go_back
.3a083f	c9 09		cmp #$09	            CMP #CHAR_TAB
.3a0841	f0 02		beq $3a0845	            BEQ go_back
.3a0843	28		plp		            PLP
.3a0844	60		rts		            RTS
.3a0845	88		dey		go_back     DEY
.3a0846	c0 ff ff	cpy #$ffff	            CPY #$FFFF
.3a0849	d0 ec		bne $3a0837	            BNE loop
.3a084b					ret_false
.3a084b	a9 00		lda #$00	            LDA #0
.3a084d	60		rts		            RTS
.3a084e					TOKENIZE
.3a084e	08		php		            PHP
.3a084f	0b		phd		            PHD
.3a0850	08		php		            PHP
.3a0851	c2 20		rep #$20	            REP #$20
.3a0853	48		pha		            PHA
.3a0854	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0857	5b		tcd		            TCD
.3a0858	68		pla		            PLA
.3a0859	28		plp		            PLP
.3a085a	c2 30		rep #$30	            REP #$30
.3a085c	a5 1a		lda $081a	            LDA CURLINE
.3a085e	85 00		sta $0800	            STA BIP
.3a0860	e2 20		sep #$20	            SEP #$20
.3a0862	a5 1c		lda $081c	            LDA CURLINE+2
.3a0864	85 02		sta $0802	            STA BIP+2
.3a0866	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a0869	a7 00		lda [$0800]	            LDA [BIP]               ; Do we have a numeral?
.3a086b	20 ad 03	jsr $3a03ad	            JSR ISNUMERAL
.3a086e	90 0c		bcc $3a087c	            BCC mv_curline          ; No: adjust CURLINE and tokenize
.3a0870	20 8a 07	jsr $3a078a	            JSR PARSEINT
.3a0873	c2 20		rep #$20	            REP #$20
.3a0875	a5 23		lda $0823	            LDA ARGUMENT1
.3a0877	85 d7		sta $08d7	            STA LINENUM
.3a0879	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a087c					mv_curline
.3a087c	c2 20		rep #$20	            REP #$20
.3a087e	a5 00		lda $0800	            LDA BIP
.3a0880	85 1a		sta $081a	            STA CURLINE
.3a0882	e2 20		sep #$20	            SEP #$20
.3a0884	a5 02		lda $0802	            LDA BIP+2
.3a0886	85 1c		sta $081c	            STA CURLINE+2
.3a0888	20 9c 08	jsr $3a089c	            JSR FINDREM
.3a088b	e2 20		sep #$20	            SEP #$20
.3a088d					loop
.3a088d	20 0d 09	jsr $3a090d	            JSR TKFINDTOKEN
.3a0890	c9 00		cmp #$00	            CMP #0                  ; Did we find a token?
.3a0892	f0 05		beq $3a0899	            BEQ done                ; No: return
.3a0894	20 bb 0a	jsr $3a0abb	            JSR TKWRITE
.3a0897	80 f4		bra $3a088d	            BRA loop                ; And try again
.3a0899	2b		pld		done        PLD
.3a089a	28		plp		            PLP
.3a089b	60		rts		            RTS
.3a089c					FINDREM
.3a089c	08		php		            PHP
.3a089d	c2 20		rep #$20	            REP #$20
.3a089f	a5 1a		lda $081a	            LDA CURLINE             ; Point BIP to the beginning of the line
.3a08a1	85 00		sta $0800	            STA BIP
.3a08a3	a5 1c		lda $081c	            LDA CURLINE+2
.3a08a5	85 02		sta $0802	            STA BIP+2
.3a08a7	a2 00 00	ldx #$0000	            LDX #0                  ; X will be a flag that we're at the beginning
.3a08aa	e2 20		sep #$20	            SEP #$20
.3a08ac	a0 00 00	ldy #$0000	loop        LDY #0
.3a08af	e0 00 00	cpx #$0000	            CPX #0                  ; If we are at the first space on the line
.3a08b2	f0 0d		beq $3a08c1	            BEQ skip_delim          ; ... skip looking for a delimiter
.3a08b4	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.3a08b6	f0 53		beq $3a090b	            BEQ done                ; Is it null? Then we're done
.3a08b8	c9 3a		cmp #$3a	            CMP #':'                ; Is it ":"
.3a08ba	f0 04		beq $3a08c0	            BEQ found_delim         ; Yes: we might have a REM... look for E
.3a08bc	c9 20		cmp #$20	            CMP #CHAR_SP
.3a08be	d0 33		bne $3a08f3	            BNE next_pos            ; No: we didn't find REM here... check next position
.3a08c0	c8		iny		found_delim INY
.3a08c1	b7 00		lda [$0800],y	skip_delim  LDA [BIP],Y             ; Get the first character
.3a08c3	f0 46		beq $3a090b	            BEQ done                ; Is it null? Then we're done
.3a08c5	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.3a08c7	f0 10		beq $3a08d9	            BEQ found_R             ; Yes: we might have a REM... look for E
.3a08c9	c9 72		cmp #$72	            CMP #'r'
.3a08cb	d0 26		bne $3a08f3	            BNE next_pos            ; No: we didn't find REM here... check next position
.3a08cd	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.3a08cf	f0 3a		beq $3a090b	            BEQ done                ; Is it null? Then we're done
.3a08d1	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.3a08d3	f0 04		beq $3a08d9	            BEQ found_R             ; Yes: we might have a REM... look for E
.3a08d5	c9 72		cmp #$72	            CMP #'r'
.3a08d7	d0 1a		bne $3a08f3	            BNE next_pos            ; No: we didn't find REM here... check next position
.3a08d9	c8		iny		found_R     INY
.3a08da	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.3a08dc	f0 2d		beq $3a090b	            BEQ done                ; Is it null? Then we're done
.3a08de	c9 45		cmp #$45	            CMP #'E'                ; Is it "E"
.3a08e0	f0 04		beq $3a08e6	            BEQ found_E             ; Yes: we might have a REM... look for M
.3a08e2	c9 65		cmp #$65	            CMP #'e'
.3a08e4	d0 0d		bne $3a08f3	            BNE next_pos            ; No: we didn't find REM here... check next position
.3a08e6	c8		iny		found_E     INY
.3a08e7	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.3a08e9	f0 20		beq $3a090b	            BEQ done                ; Is it null? Then we're done
.3a08eb	c9 4d		cmp #$4d	            CMP #'M'                ; Is it "E"
.3a08ed	f0 0a		beq $3a08f9	            BEQ found_REM           ; Yes: we might have a REM... look for M
.3a08ef	c9 6d		cmp #$6d	            CMP #'m'
.3a08f1	f0 06		beq $3a08f9	            BEQ found_REM
.3a08f3	e8		inx		next_pos    INX                     ; Indicate we're no longer at the first position
.3a08f4	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a08f7	80 b3		bra $3a08ac	            BRA loop
.3a08f9	a7 00		lda [$0800]	found_REM   LDA [BIP]               ; Get the current character
.3a08fb	c9 3a		cmp #$3a	            CMP #':'                ; Is it the delimiter?
.3a08fd	d0 03		bne $3a0902	            BNE ret_REM             ; No: go ahead and return REM at that location
.3a08ff	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a0902	a9 03		lda #$03	ret_REM     LDA #3
.3a0904	85 1e		sta $081e	            STA CURTOKLEN           ; Set the size
.3a0906	a9 91		lda #$91	            LDA #TOK_REM            ; And the token to write
.3a0908	20 bb 0a	jsr $3a0abb	            JSR TKWRITE
.3a090b	28		plp		done        PLP
.3a090c	60		rts		            RTS
.3a090d					TKFINDTOKEN
.3a090d	08		php		            PHP
.3a090e	0b		phd		            PHD
.3a090f	08		php		            PHP
.3a0910	c2 20		rep #$20	            REP #$20
.3a0912	48		pha		            PHA
.3a0913	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0916	5b		tcd		            TCD
.3a0917	68		pla		            PLA
.3a0918	28		plp		            PLP
.3a0919	e2 20		sep #$20	            SEP #$20
.3a091b	a9 7f		lda #$7f	            LDA #$7F                ; Start off looking for any size token
.3a091d	85 1e		sta $081e	            STA CURTOKLEN
.3a091f					next_size
.3a091f	c2 10		rep #$10	            REP #$10
.3a0921	20 70 0a	jsr $3a0a70	            JSR TKNEXTBIG
.3a0924	a5 1e		lda $081e	            LDA CURTOKLEN           ; Are there any keywords left?
.3a0926	d0 03		bne $3a092b	            BNE else
.3a0928	4c b0 09	jmp $3a09b0	            JMP done                ; No: return to caller
.3a092b					else
.3a092b	c2 20		rep #$20	            REP #$20
.3a092d	a5 1a		lda $081a	            LDA CURLINE
.3a092f	85 00		sta $0800	            STA BIP
.3a0931	e2 20		sep #$20	            SEP #$20
.3a0933	a5 1c		lda $081c	            LDA CURLINE+2
.3a0935	85 02		sta $0802	            STA BIP+2
.3a0937	c2 20		rep #$20	            REP #$20
.3a0939	64 04		stz $0804	            STZ BIPPREV             ; Clear BIPPREV (point to the previous character)
.3a093b	64 06		stz $0806	            STZ BIPPREV+2
.3a093d					check_len
.3a093d	e2 30		sep #$30	            SEP #$30
.3a093f	a0 00		ldy #$00	            LDY #0
.3a0941	b7 00		lda [$0800],y	nul_scan    LDA [BIP],Y
.3a0943	f0 da		beq $3a091f	            BEQ next_size
.3a0945	c9 91		cmp #$91	            CMP #TOK_REM            ; Tokenization stops at REMarks too
.3a0947	f0 d6		beq $3a091f	            BEQ next_size
.3a0949	c8		iny		            INY
.3a094a	c4 1e		cpy $081e	            CPY CURTOKLEN
.3a094c	90 f3		bcc $3a0941	            BCC nul_scan
.3a094e	c2 10		rep #$10	            REP #$10
.3a0950	a7 00		lda [$0800]	            LDA [BIP]               ; Check the current character
.3a0952	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.3a0954	d0 05		bne $3a095b	            BNE chk_keyword         ; No: check to see if we are at the start of a possible keyword
.3a0956	20 d2 09	jsr $3a09d2	            JSR SKIPQUOTED
.3a0959	80 28		bra $3a0983	            BRA go_next             ; And move on to the next character
.3a095b	a5 1e		lda $081e	chk_keyword LDA CURTOKLEN           ; If the token length is <=2
.3a095d	c9 03		cmp #$03	            CMP #3
.3a095f	90 19		bcc $3a097a	            BLT try_match           ; ... we don't need a delimiter, go ahead and convert it
.3a0961	c2 20		rep #$20	            REP #$20
.3a0963	a5 00		lda $0800	            LDA BIP                 ; Check to see if we're at the start of the line
.3a0965	c5 1a		cmp $081a	            CMP CURLINE
.3a0967	d0 08		bne $3a0971	            BNE chk_delim           ; No: we need to check for a delimiters
.3a0969	e2 20		sep #$20	            SEP #$20
.3a096b	a5 02		lda $0802	            LDA BIP+2
.3a096d	c5 1c		cmp $081c	            CMP CURLINE+2
.3a096f	f0 09		beq $3a097a	            BEQ try_match           ; Yes: this can be a keyword
.3a0971					chk_delim
.3a0971	e2 20		sep #$20	            SEP #$20
.3a0973	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.3a0975	20 95 4e	jsr $3a4e95	            JSR ISVARCHAR
.3a0978	b0 09		bcs $3a0983	            BCS go_next             ; Yes: we can't start a keyword here
.3a097a					try_match
.3a097a	e2 20		sep #$20	            SEP #$20
.3a097c	20 e2 09	jsr $3a09e2	            JSR TKMATCH
.3a097f	c9 00		cmp #$00	            CMP #0                  ; Did we get one?
.3a0981	d0 11		bne $3a0994	            BNE found               ; Yes: return it
.3a0983					go_next
.3a0983	c2 20		rep #$20	            REP #$20
.3a0985	a5 00		lda $0800	            LDA BIP                 ; Update BIPPREV as the point to the previous character
.3a0987	85 04		sta $0804	            STA BIPPREV
.3a0989	e2 20		sep #$20	            SEP #$20
.3a098b	a5 02		lda $0802	            LDA BIP+2
.3a098d	85 06		sta $0806	            STA BIPPREV+2
.3a098f	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a0992	80 a9		bra $3a093d	            BRA check_len           ; And try there
.3a0994					found
.3a0994	c9 81		cmp #$81	            CMP #TOK_MINUS          ; Found a token... is it minus?
.3a0996	d0 18		bne $3a09b0	            BNE done                ; Nope: go ahead and return it
.3a0998	20 28 08	jsr $3a0828	            JSR PREVCHAR
.3a099b	c9 00		cmp #$00	            CMP #0                  ; Did we get anything?
.3a099d	f0 14		beq $3a09b3	            BEQ syntax              ; No: line cannot start with minus... throw error
.3a099f	89 80		bit #$80	            BIT #$80                ; Is it a token?
.3a09a1	10 0b		bpl $3a09ae	            BPL binaryminus         ; No: leave token unchanged
.3a09a3	20 5c 0b	jsr $3a0b5c	            JSR TOKTYPE
.3a09a6	c9 30		cmp #$30	            CMP #TOK_TY_FUNC        ; Is it a function?
.3a09a8	f0 04		beq $3a09ae	            BEQ binaryminus         ; Yes: then this should be a binary minus operator
.3a09aa	a9 af		lda #$af	            LDA #TOK_NEGATIVE       ; Otherwise: this should be a unary minus (negation)
.3a09ac	80 02		bra $3a09b0	            BRA done
.3a09ae	a9 81		lda #$81	binaryminus LDA #TOK_MINUS          ; It's data... so token should be for binary minus
.3a09b0					done
.3a09b0	2b		pld		            PLD
.3a09b1	28		plp		            PLP
.3a09b2	60		rts		            RTS
.3a09b3					syntax
.3a09b3	08		php		            PHP
.3a09b4	c2 20		rep #$20	            REP #$20
.3a09b6	48		pha		            PHA
.3a09b7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a09ba	5b		tcd		            TCD
.3a09bb	68		pla		            PLA
.3a09bc	28		plp		            PLP
.3a09bd	e2 20		sep #$20	            SEP #$20
.3a09bf	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a09c1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a09c5	c2 20		rep #$20	            REP #$20
.3a09c7	29 ff 00	and #$00ff	            AND #$00FF
.3a09ca	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a09cd	e2 20		sep #$20	            SEP #$20
.3a09cf	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a09d2					SKIPQUOTED
.3a09d2	08		php		            PHP
.3a09d3	e2 20		sep #$20	            SEP #$20
.3a09d5					loop
.3a09d5	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a09d8	a7 00		lda [$0800]	            LDA [BIP]
.3a09da	f0 04		beq $3a09e0	            BEQ done                ; If EOL, just return
.3a09dc	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.3a09de	d0 f5		bne $3a09d5	            BNE loop                ; No: keep skipping
.3a09e0	28		plp		done        PLP
.3a09e1	60		rts		            RTS
.3a09e2					TKMATCH
.3a09e2	da		phx		            PHX
.3a09e3	5a		phy		            PHY
.3a09e4	08		php		            PHP
.3a09e5	0b		phd		            PHD
.3a09e6	08		php		            PHP
.3a09e7	c2 20		rep #$20	            REP #$20
.3a09e9	48		pha		            PHA
.3a09ea	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a09ed	5b		tcd		            TCD
.3a09ee	68		pla		            PLA
.3a09ef	28		plp		            PLP
.3a09f0	c2 20		rep #$20	            REP #$20
.3a09f2	a5 04		lda $0804	            LDA BIPPREV
.3a09f4	d0 0a		bne $3a0a00	            BNE check_prev
.3a09f6	e2 20		sep #$20	            SEP #$20
.3a09f8	a5 04		lda $0804	            LDA BIPPREV
.3a09fa	d0 04		bne $3a0a00	            BNE check_prev
.3a09fc	a9 00		lda #$00	            LDA #0
.3a09fe	80 0a		bra $3a0a0a	            BRA save_delim
.3a0a00					check_prev
.3a0a00	e2 20		sep #$20	            SEP #$20
.3a0a02	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.3a0a04	20 95 4e	jsr $3a4e95	            JSR ISVARCHAR
.3a0a07	a9 00		lda #$00	            LDA #0
.3a0a09	2a		rol a		            ROL A
.3a0a0a	85 28		sta $0828	save_delim  STA SIGN1               ; SIGN1 := 1 if it is a variable name character
.3a0a0c	c2 30		rep #$30	            REP #$30
.3a0a0e	a9 b0 0b	lda #$0bb0	            LDA #<>TOKENS           ; Set INDEX to point to the first token record
.3a0a11	85 08		sta $0808	            STA INDEX
.3a0a13	e2 20		sep #$20	            SEP #$20
.3a0a15	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0a17	85 0a		sta $080a	            STA INDEX+2
.3a0a19	a2 80 00	ldx #$0080	            LDX #$80                ; Set the initial token ID
.3a0a1c					token_loop
.3a0a1c	e2 20		sep #$20	            SEP #$20
.3a0a1e	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.3a0a21	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the current token
.3a0a23	f0 31		beq $3a0a56	            BEQ no_match            ; Is it 0? We're out of tokens... no match found
.3a0a25	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it the same as the size of the window?
.3a0a27	d0 32		bne $3a0a5b	            BNE next_token          ; No: try the next token
.3a0a29	c2 30		rep #$30	            REP #$30
.3a0a2b	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.3a0a2e	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the pointer to the token's name
.3a0a30	85 0c		sta $080c	            STA SCRATCH             ; Set SCRATCH to point to the token's name
.3a0a32	e2 20		sep #$20	            SEP #$20
.3a0a34	a9 3a		lda #$3a	            LDA #`DATA_BLOCK
.3a0a36	85 0e		sta $080e	            STA SCRATCH+2
.3a0a38	a5 28		lda $0828	            LDA SIGN1               ; Is previous character a variable name character?
.3a0a3a	f0 07		beq $3a0a43	            BEQ cmp_keyword         ; No: we can check for this token
.3a0a3c	a7 0c		lda [$080c]	            LDA [SCRATCH]           ; Get the token's first character
.3a0a3e	20 95 4e	jsr $3a4e95	            JSR ISVARCHAR
.3a0a41	b0 18		bcs $3a0a5b	            BCS next_token          ; Yes: skip this token
.3a0a43					cmp_keyword
.3a0a43	e2 10		sep #$10	            SEP #$10
.3a0a45	a0 00		ldy #$00	            LDY #0
.3a0a47	b7 00		lda [$0800],y	cmp_loop    LDA [BIP],Y             ; Get the character in the window
.3a0a49	20 08 04	jsr $3a0408	            JSR TOUPPERA
.3a0a4c	d7 0c		cmp [$080c],y	            CMP [SCRATCH],Y         ; Compare to the character in the token
.3a0a4e	d0 0b		bne $3a0a5b	            BNE next_token          ; If they don't match, try the next token
.3a0a50	c8		iny		            INY                     ; Move to the next character in the window
.3a0a51	c4 1e		cpy $081e	            CPY CURTOKLEN           ; Have we checked the whole window?
.3a0a53	90 f2		bcc $3a0a47	            BCC cmp_loop            ; No: check this next character
.3a0a55	8a		txa		            TXA                     ; Move the token ID to A
.3a0a56	2b		pld		no_match    PLD
.3a0a57	28		plp		            PLP
.3a0a58	7a		ply		            PLY
.3a0a59	fa		plx		            PLX
.3a0a5a	60		rts		            RTS
.3a0a5b					next_token
.3a0a5b	c2 30		rep #$30	            REP #$30
.3a0a5d	18		clc		            CLC
.3a0a5e	a5 08		lda $0808	            LDA INDEX
.3a0a60	69 08 00	adc #$0008	            ADC #size(TOKEN)
.3a0a63	85 08		sta $0808	            STA INDEX
.3a0a65	e2 20		sep #$20	            SEP #$20
.3a0a67	a5 0a		lda $080a	            LDA INDEX+2
.3a0a69	69 00		adc #$00	            ADC #0
.3a0a6b	85 0a		sta $080a	            STA INDEX+2
.3a0a6d	e8		inx		            INX                     ; Increment the token ID
.3a0a6e	80 ac		bra $3a0a1c	            BRA token_loop          ; And check that token
.3a0a70					TKNEXTBIG
.3a0a70	08		php		            PHP
.3a0a71	0b		phd		            PHD
.3a0a72	8b		phb		            PHB
.3a0a73	08		php		            PHP
.3a0a74	c2 20		rep #$20	            REP #$20
.3a0a76	48		pha		            PHA
.3a0a77	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0a7a	5b		tcd		            TCD
.3a0a7b	68		pla		            PLA
.3a0a7c	28		plp		            PLP
.3a0a7d	c2 30		rep #$30	            REP #$30
.3a0a7f	a9 b0 0b	lda #$0bb0	            LDA #<>TOKENS
.3a0a82	85 08		sta $0808	            STA INDEX
.3a0a84	a9 3a 00	lda #$003a	            LDA #`TOKENS
.3a0a87	85 0a		sta $080a	            STA INDEX+2
.3a0a89	64 0c		stz $080c	            STZ SCRATCH             ; Clear SCRATCH
.3a0a8b					loop
.3a0a8b	e2 20		sep #$20	            SEP #$20
.3a0a8d	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.3a0a90	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the token
.3a0a92	f0 1d		beq $3a0ab1	            BEQ done                ; If length is 0, we're done
.3a0a94	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it >= CURTOKLEN?
.3a0a96	b0 06		bcs $3a0a9e	            BGE skip                ; Yes: skip to the next token
.3a0a98	c5 0c		cmp $080c	            CMP SCRATCH             ; No: is it < SCRATCH?
.3a0a9a	90 02		bcc $3a0a9e	            BLT skip                ; Yes: skip to the next token
.3a0a9c	85 0c		sta $080c	            STA SCRATCH             ; No: it's our new longest token!
.3a0a9e					skip
.3a0a9e	c2 20		rep #$20	            REP #$20
.3a0aa0	18		clc		            CLC
.3a0aa1	a5 08		lda $0808	            LDA INDEX
.3a0aa3	69 08 00	adc #$0008	            ADC #size(TOKEN)
.3a0aa6	85 08		sta $0808	            STA INDEX
.3a0aa8	a5 0a		lda $080a	            LDA INDEX+2
.3a0aaa	69 00 00	adc #$0000	            ADC #0
.3a0aad	85 0a		sta $080a	            STA INDEX+2
.3a0aaf	80 da		bra $3a0a8b	            BRA loop                ; And go around for another pass
.3a0ab1					done
.3a0ab1	e2 20		sep #$20	            SEP #$20
.3a0ab3	a5 0c		lda $080c	            LDA SCRATCH
.3a0ab5	85 1e		sta $081e	            STA CURTOKLEN
.3a0ab7	ab		plb		            PLB
.3a0ab8	2b		pld		            PLD
.3a0ab9	28		plp		            PLP
.3a0aba	60		rts		            RTS
.3a0abb					TKWRITE
.3a0abb	08		php		            PHP
.3a0abc	0b		phd		            PHD
.3a0abd	08		php		            PHP
.3a0abe	c2 20		rep #$20	            REP #$20
.3a0ac0	48		pha		            PHA
.3a0ac1	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0ac4	5b		tcd		            TCD
.3a0ac5	68		pla		            PLA
.3a0ac6	28		plp		            PLP
.3a0ac7	e2 20		sep #$20	            SEP #$20
.3a0ac9	87 00		sta [$0800]	            STA [BIP]               ; Write the token to the line
.3a0acb	c2 20		rep #$20	            REP #$20
.3a0acd	18		clc		            CLC
.3a0ace	a5 00		lda $0800	            LDA BIP
.3a0ad0	69 01 00	adc #$0001	            ADC #1
.3a0ad3	85 08		sta $0808	            STA INDEX
.3a0ad5	a5 02		lda $0802	            LDA BIP+2
.3a0ad7	69 00 00	adc #$0000	            ADC #0
.3a0ada	85 0a		sta $080a	            STA INDEX+2
.3a0adc	e2 10		sep #$10	            SEP #$10
.3a0ade	a4 1e		ldy $081e	            LDY CURTOKLEN           ; Y will be the number of characters to move down
.3a0ae0	88		dey		            DEY
.3a0ae1					copy_down
.3a0ae1	e2 20		sep #$20	            SEP #$20
.3a0ae3	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the byte to move down
.3a0ae5	87 08		sta [$0808]	            STA [INDEX]             ; Move it down
.3a0ae7	f0 13		beq $3a0afc	            BEQ done                ; We've reached the end of the line
.3a0ae9	c2 20		rep #$20	            REP #$20
.3a0aeb	18		clc		            CLC
.3a0aec	a5 08		lda $0808	            LDA INDEX
.3a0aee	69 01 00	adc #$0001	            ADC #1
.3a0af1	85 08		sta $0808	            STA INDEX
.3a0af3	a5 0a		lda $080a	            LDA INDEX+2
.3a0af5	69 00 00	adc #$0000	            ADC #0
.3a0af8	85 0a		sta $080a	            STA INDEX+2
.3a0afa	80 e5		bra $3a0ae1	            BRA copy_down
.3a0afc	2b		pld		done        PLD
.3a0afd	28		plp		            PLP
.3a0afe	60		rts		            RTS
.3a0aff					GETTOKREC
.3a0aff	08		php		            PHP
.3a0b00	c2 30		rep #$30	            REP #$30
.3a0b02	29 7f 00	and #$007f	            AND #$007F
.3a0b05	0a		asl a		            ASL A
.3a0b06	0a		asl a		            ASL A
.3a0b07	0a		asl a		            ASL A
.3a0b08	18		clc		            CLC
.3a0b09	69 b0 0b	adc #$0bb0	            ADC #<>TOKENS
.3a0b0c	aa		tax		            TAX                         ; X is now the data bank relative address of the token record
.3a0b0d	28		plp		            PLP
.3a0b0e	60		rts		            RTS
.3a0b0f					TOKPRECED
.3a0b0f	08		php		            PHP
.3a0b10	8b		phb		            PHB
.3a0b11	0b		phd		            PHD
.3a0b12	08		php		            PHP
.3a0b13	c2 20		rep #$20	            REP #$20
.3a0b15	48		pha		            PHA
.3a0b16	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0b19	5b		tcd		            TCD
.3a0b1a	68		pla		            PLA
.3a0b1b	28		plp		            PLP
.3a0b1c	08		php		            PHP
.3a0b1d	e2 20		sep #$20	            SEP #$20
.3a0b1f	48		pha		            PHA
.3a0b20	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0b22	48		pha		            PHA
.3a0b23	ab		plb		            PLB
.3a0b24	68		pla		            PLA
.3a0b25	28		plp		            PLP
.3a0b26	e2 20		sep #$20	            SEP #$20
.3a0b28	c2 10		rep #$10	            REP #$10
.3a0b2a	20 ff 0a	jsr $3a0aff	            JSR GETTOKREC
.3a0b2d	bd 00 00	lda $3a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.3a0b30	c2 20		rep #$20	            REP #$20
.3a0b32	29 0f 00	and #$000f	            AND #$000F                  ; Mask off the type code
.3a0b35	2b		pld		            PLD
.3a0b36	ab		plb		            PLB
.3a0b37	28		plp		            PLP
.3a0b38	60		rts		            RTS
.3a0b39					TOKEVAL
.3a0b39	08		php		            PHP
.3a0b3a	8b		phb		            PHB
.3a0b3b	0b		phd		            PHD
.3a0b3c	08		php		            PHP
.3a0b3d	c2 20		rep #$20	            REP #$20
.3a0b3f	48		pha		            PHA
.3a0b40	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0b43	5b		tcd		            TCD
.3a0b44	68		pla		            PLA
.3a0b45	28		plp		            PLP
.3a0b46	08		php		            PHP
.3a0b47	e2 20		sep #$20	            SEP #$20
.3a0b49	48		pha		            PHA
.3a0b4a	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0b4c	48		pha		            PHA
.3a0b4d	ab		plb		            PLB
.3a0b4e	68		pla		            PLA
.3a0b4f	28		plp		            PLP
.3a0b50	c2 30		rep #$30	            REP #$30
.3a0b52	20 ff 0a	jsr $3a0aff	            JSR GETTOKREC
.3a0b55	bd 04 00	lda $3a0004,x	            LDA #TOKEN.eval,B,X         ; Get the address of the evaluation function
.3a0b58	2b		pld		            PLD
.3a0b59	ab		plb		            PLB
.3a0b5a	28		plp		            PLP
.3a0b5b	60		rts		            RTS
.3a0b5c					TOKTYPE
.3a0b5c	08		php		            PHP
.3a0b5d	8b		phb		            PHB
.3a0b5e	0b		phd		            PHD
.3a0b5f	08		php		            PHP
.3a0b60	c2 20		rep #$20	            REP #$20
.3a0b62	48		pha		            PHA
.3a0b63	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0b66	5b		tcd		            TCD
.3a0b67	68		pla		            PLA
.3a0b68	28		plp		            PLP
.3a0b69	08		php		            PHP
.3a0b6a	e2 20		sep #$20	            SEP #$20
.3a0b6c	48		pha		            PHA
.3a0b6d	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0b6f	48		pha		            PHA
.3a0b70	ab		plb		            PLB
.3a0b71	68		pla		            PLA
.3a0b72	28		plp		            PLP
.3a0b73	e2 20		sep #$20	            SEP #$20
.3a0b75	c2 10		rep #$10	            REP #$10
.3a0b77	20 ff 0a	jsr $3a0aff	            JSR GETTOKREC
.3a0b7a	bd 00 00	lda $3a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.3a0b7d	c2 20		rep #$20	            REP #$20
.3a0b7f	29 f0 00	and #$00f0	            AND #$00F0                  ; Mask off the type code
.3a0b82	2b		pld		            PLD
.3a0b83	ab		plb		            PLB
.3a0b84	28		plp		            PLP
.3a0b85	60		rts		            RTS
.3a0b86					TOKARITY
.3a0b86	08		php		            PHP
.3a0b87	8b		phb		            PHB
.3a0b88	0b		phd		            PHD
.3a0b89	08		php		            PHP
.3a0b8a	c2 20		rep #$20	            REP #$20
.3a0b8c	48		pha		            PHA
.3a0b8d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0b90	5b		tcd		            TCD
.3a0b91	68		pla		            PLA
.3a0b92	28		plp		            PLP
.3a0b93	08		php		            PHP
.3a0b94	e2 20		sep #$20	            SEP #$20
.3a0b96	48		pha		            PHA
.3a0b97	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0b99	48		pha		            PHA
.3a0b9a	ab		plb		            PLB
.3a0b9b	68		pla		            PLA
.3a0b9c	28		plp		            PLP
.3a0b9d	e2 20		sep #$20	            SEP #$20
.3a0b9f	c2 10		rep #$10	            REP #$10
.3a0ba1	20 ff 0a	jsr $3a0aff	            JSR GETTOKREC
.3a0ba4	bd 06 00	lda $3a0006,x	            LDA #TOKEN.arity,B,X        ; Get the arity
.3a0ba7	c2 20		rep #$20	            REP #$20
.3a0ba9	29 ff 00	and #$00ff	            AND #$00FF
.3a0bac	2b		pld		            PLD
.3a0bad	ab		plb		            PLB
.3a0bae	28		plp		            PLP
.3a0baf	60		rts		            RTS
=$00					TOK_EOL = $00
=$01					TOK_FUNC_OPEN = $01     ; A pseudo-token to push to the operator stack to mark
=$00					TOK_TY_OP = $00         ; The token is an operator
=$10					TOK_TY_CMD = $10        ; The token is a command (e.g. RUN, LIST, etc.)
=$20					TOK_TY_STMNT = $20      ; The token is a statement (e.g. INPUT, PRINT, DIM, etc.)
=$30					TOK_TY_FUNC = $30       ; The token is a function (e.g. SIN, COS, TAB, etc.)
=$40					TOK_TY_PUNCT = $40      ; The token is a punctuation mark (e.g. "(", ")")
=$50					TOK_TY_BYWRD = $50      ; The token is a by-word (e.g. STEP, TO, WEND, etc.)
.3a0bb0					TOKENS
=$80					TOK_PLUS = $80
>3ad010	2b 00				TOKEN_TEXT  .null "+"
>3a0bb0	03				precedence  .byte TOK_TY_OP | 3
>3a0bb1	01				length      .byte len("+")
>3a0bb2	10 d0				name        .word <>TOKEN_TEXT
>3a0bb4	1d 26				eval        .word <>OP_PLUS
>3a0bb6	02 00				arity       .word <>2
=$81					TOK_MINUS = $81
>3ad012	2d 00				TOKEN_TEXT  .null "-"
>3a0bb8	03				precedence  .byte TOK_TY_OP | 3
>3a0bb9	01				length      .byte len("-")
>3a0bba	12 d0				name        .word <>TOKEN_TEXT
>3a0bbc	5d 26				eval        .word <>OP_MINUS
>3a0bbe	02 00				arity       .word <>2
=$82					TOK_MULT = $82
>3ad014	2a 00				TOKEN_TEXT  .null "*"
>3a0bc0	02				precedence  .byte TOK_TY_OP | 2
>3a0bc1	01				length      .byte len("*")
>3a0bc2	14 d0				name        .word <>TOKEN_TEXT
>3a0bc4	94 26				eval        .word <>OP_MULTIPLY
>3a0bc6	02 00				arity       .word <>2
=$83					TOK_DIVIDE = $83
>3ad016	2f 00				TOKEN_TEXT  .null "/"
>3a0bc8	02				precedence  .byte TOK_TY_OP | 2
>3a0bc9	01				length      .byte len("/")
>3a0bca	16 d0				name        .word <>TOKEN_TEXT
>3a0bcc	cb 26				eval        .word <>OP_DIVIDE
>3a0bce	02 00				arity       .word <>2
=$84					TOK_MOD = $84
>3ad018	4d 4f 44 00			TOKEN_TEXT  .null "MOD"
>3a0bd0	02				precedence  .byte TOK_TY_OP | 2
>3a0bd1	03				length      .byte len("MOD")
>3a0bd2	18 d0				name        .word <>TOKEN_TEXT
>3a0bd4	d5 26				eval        .word <>OP_MOD
>3a0bd6	02 00				arity       .word <>2
>3ad01c	5e 00				TOKEN_TEXT  .null "^"
>3a0bd8	00				precedence  .byte TOK_TY_OP | 0
>3a0bd9	01				length      .byte len("^")
>3a0bda	1c d0				name        .word <>TOKEN_TEXT
>3a0bdc	e8 26				eval        .word <>OP_POW
>3a0bde	02 00				arity       .word <>2
=$86					TOK_LE = $86
>3ad01e	3c 3d 00			TOKEN_TEXT  .null "<="
>3a0be0	04				precedence  .byte TOK_TY_OP | 4
>3a0be1	02				length      .byte len("<=")
>3a0be2	1e d0				name        .word <>TOKEN_TEXT
>3a0be4	a6 28				eval        .word <>OP_LTE
>3a0be6	02 00				arity       .word <>2
=$87					TOK_GE = $87
>3ad021	3e 3d 00			TOKEN_TEXT  .null ">="
>3a0be8	04				precedence  .byte TOK_TY_OP | 4
>3a0be9	02				length      .byte len(">=")
>3a0bea	21 d0				name        .word <>TOKEN_TEXT
>3a0bec	66 28				eval        .word <>OP_GTE
>3a0bee	02 00				arity       .word <>2
=$88					TOK_NE = $88
>3ad024	3c 3e 00			TOKEN_TEXT  .null "<>"
>3a0bf0	04				precedence  .byte TOK_TY_OP | 4
>3a0bf1	02				length      .byte len("<>")
>3a0bf2	24 d0				name        .word <>TOKEN_TEXT
>3a0bf4	26 28				eval        .word <>OP_NE
>3a0bf6	02 00				arity       .word <>2
>3ad027	3c 00				TOKEN_TEXT  .null "<"
>3a0bf8	04				precedence  .byte TOK_TY_OP | 4
>3a0bf9	01				length      .byte len("<")
>3a0bfa	27 d0				name        .word <>TOKEN_TEXT
>3a0bfc	66 27				eval        .word <>OP_LT
>3a0bfe	02 00				arity       .word <>2
=$8a					TOK_EQ = $8A
>3ad029	3d 00				TOKEN_TEXT  .null "="
>3a0c00	04				precedence  .byte TOK_TY_OP | 4
>3a0c01	01				length      .byte len("=")
>3a0c02	29 d0				name        .word <>TOKEN_TEXT
>3a0c04	e6 27				eval        .word <>OP_EQ
>3a0c06	02 00				arity       .word <>2
>3ad02b	3e 00				TOKEN_TEXT  .null ">"
>3a0c08	04				precedence  .byte TOK_TY_OP | 4
>3a0c09	01				length      .byte len(">")
>3a0c0a	2b d0				name        .word <>TOKEN_TEXT
>3a0c0c	a6 27				eval        .word <>OP_GT
>3a0c0e	02 00				arity       .word <>2
>3ad02d	4e 4f 54 00			TOKEN_TEXT  .null "NOT"
>3a0c10	05				precedence  .byte TOK_TY_OP | 5
>3a0c11	03				length      .byte len("NOT")
>3a0c12	2d d0				name        .word <>TOKEN_TEXT
>3a0c14	50 27				eval        .word <>OP_NOT
>3a0c16	01 00				arity       .word <>1
>3ad031	41 4e 44 00			TOKEN_TEXT  .null "AND"
>3a0c18	06				precedence  .byte TOK_TY_OP | 6
>3a0c19	03				length      .byte len("AND")
>3a0c1a	31 d0				name        .word <>TOKEN_TEXT
>3a0c1c	22 27				eval        .word <>OP_AND
>3a0c1e	02 00				arity       .word <>2
>3ad035	4f 52 00			TOKEN_TEXT  .null "OR"
>3a0c20	07				precedence  .byte TOK_TY_OP | 7
>3a0c21	02				length      .byte len("OR")
>3a0c22	35 d0				name        .word <>TOKEN_TEXT
>3a0c24	39 27				eval        .word <>OP_OR
>3a0c26	02 00				arity       .word <>2
=$8f					TOK_LPAREN = $8F
>3ad038	28 00				TOKEN_TEXT  .null "("
>3a0c28	ff				precedence  .byte TOK_TY_PUNCT | $FF
>3a0c29	01				length      .byte len("(")
>3a0c2a	38 d0				name        .word <>TOKEN_TEXT
>3a0c2c	00 00				eval        .word <>0
>3a0c2e	00 00				arity       .word <>0
=$90					TOK_RPAREN = $90
>3ad03a	29 00				TOKEN_TEXT  .null ")"
>3a0c30	40				precedence  .byte TOK_TY_PUNCT | 0
>3a0c31	01				length      .byte len(")")
>3a0c32	3a d0				name        .word <>TOKEN_TEXT
>3a0c34	00 00				eval        .word <>0
>3a0c36	00 00				arity       .word <>0
=$91					TOK_REM = $91
>3ad03c	52 45 4d 00			TOKEN_TEXT  .null "REM"
>3a0c38	20				precedence  .byte TOK_TY_STMNT | 0
>3a0c39	03				length      .byte len("REM")
>3a0c3a	3c d0				name        .word <>TOKEN_TEXT
>3a0c3c	41 3f				eval        .word <>S_REM
>3a0c3e	00 00				arity       .word <>0
=$92					TOK_PRINT = $92
>3ad040	50 52 49 4e 54 00		TOKEN_TEXT  .null "PRINT"
>3a0c40	20				precedence  .byte TOK_TY_STMNT | 0
>3a0c41	05				length      .byte len("PRINT")
>3a0c42	40 d0				name        .word <>TOKEN_TEXT
>3a0c44	46 43				eval        .word <>S_PRINT
>3a0c46	00 00				arity       .word <>0
=$93					TOK_LET = $93
>3ad046	4c 45 54 00			TOKEN_TEXT  .null "LET"
>3a0c48	20				precedence  .byte TOK_TY_STMNT | 0
>3a0c49	03				length      .byte len("LET")
>3a0c4a	46 d0				name        .word <>TOKEN_TEXT
>3a0c4c	91 42				eval        .word <>S_LET
>3a0c4e	00 00				arity       .word <>0
>3ad04a	47 4f 54 4f 00			TOKEN_TEXT  .null "GOTO"
>3a0c50	20				precedence  .byte TOK_TY_STMNT | 0
>3a0c51	04				length      .byte len("GOTO")
>3a0c52	4a d0				name        .word <>TOKEN_TEXT
>3a0c54	31 42				eval        .word <>S_GOTO
>3a0c56	00 00				arity       .word <>0
=$95					TOK_END = $95
>3ad04f	45 4e 44 00			TOKEN_TEXT  .null "END"
>3a0c58	20				precedence  .byte TOK_TY_STMNT | 0
>3a0c59	03				length      .byte len("END")
>3a0c5a	4f d0				name        .word <>TOKEN_TEXT
>3a0c5c	28 42				eval        .word <>S_END
>3a0c5e	00 00				arity       .word <>0
>3ad053	49 46 00			TOKEN_TEXT  .null "IF"
>3a0c60	20				precedence  .byte TOK_TY_STMNT | 0
>3a0c61	02				length      .byte len("IF")
>3a0c62	53 d0				name        .word <>TOKEN_TEXT
>3a0c64	c0 41				eval        .word <>S_IF
>3a0c66	00 00				arity       .word <>0
=$97					TOK_THEN = $97
>3ad056	54 48 45 4e 00			TOKEN_TEXT  .null "THEN"
>3a0c68	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0c69	04				length      .byte len("THEN")
>3a0c6a	56 d0				name        .word <>TOKEN_TEXT
>3a0c6c	00 00				eval        .word <>0
>3a0c6e	00 00				arity       .word <>0
>3ad05b	45 4c 53 45 00			TOKEN_TEXT  .null "ELSE"
>3a0c70	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0c71	04				length      .byte len("ELSE")
>3a0c72	5b d0				name        .word <>TOKEN_TEXT
>3a0c74	00 00				eval        .word <>0
>3a0c76	00 00				arity       .word <>0
>3ad060	47 4f 53 55 42 00		TOKEN_TEXT  .null "GOSUB"
>3a0c78	20				precedence  .byte TOK_TY_STMNT | 0
>3a0c79	05				length      .byte len("GOSUB")
>3a0c7a	60 d0				name        .word <>TOKEN_TEXT
>3a0c7c	03 41				eval        .word <>S_GOSUB
>3a0c7e	00 00				arity       .word <>0
>3ad066	52 45 54 55 52 4e 00		TOKEN_TEXT  .null "RETURN"
>3a0c80	20				precedence  .byte TOK_TY_STMNT | 0
>3a0c81	06				length      .byte len("RETURN")
>3a0c82	66 d0				name        .word <>TOKEN_TEXT
>3a0c84	7c 41				eval        .word <>S_RETURN
>3a0c86	00 00				arity       .word <>0
=$9b					TOK_FOR = $9B
>3ad06d	46 4f 52 00			TOKEN_TEXT  .null "FOR"
>3a0c88	20				precedence  .byte TOK_TY_STMNT | 0
>3a0c89	03				length      .byte len("FOR")
>3a0c8a	6d d0				name        .word <>TOKEN_TEXT
>3a0c8c	58 3f				eval        .word <>S_FOR
>3a0c8e	00 00				arity       .word <>0
=$9c					TOK_TO = $9C
>3ad071	54 4f 00			TOKEN_TEXT  .null "TO"
>3a0c90	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0c91	02				length      .byte len("TO")
>3a0c92	71 d0				name        .word <>TOKEN_TEXT
>3a0c94	00 00				eval        .word <>0
>3a0c96	00 00				arity       .word <>0
=$9d					TOK_STEP = $9D
>3ad074	53 54 45 50 00			TOKEN_TEXT  .null "STEP"
>3a0c98	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0c99	04				length      .byte len("STEP")
>3a0c9a	74 d0				name        .word <>TOKEN_TEXT
>3a0c9c	00 00				eval        .word <>0
>3a0c9e	00 00				arity       .word <>0
=$9e					TOK_NEXT = $9E
>3ad079	4e 45 58 54 00			TOKEN_TEXT  .null "NEXT"
>3a0ca0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ca1	04				length      .byte len("NEXT")
>3a0ca2	79 d0				name        .word <>TOKEN_TEXT
>3a0ca4	4c 40				eval        .word <>S_NEXT
>3a0ca6	00 00				arity       .word <>0
=$9f					TOK_DO = $9F
>3ad07e	44 4f 00			TOKEN_TEXT  .null "DO"
>3a0ca8	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ca9	02				length      .byte len("DO")
>3a0caa	7e d0				name        .word <>TOKEN_TEXT
>3a0cac	52 3f				eval        .word <>S_DO
>3a0cae	00 00				arity       .word <>0
=$a0					TOK_LOOP = $A0
>3ad081	4c 4f 4f 50 00			TOKEN_TEXT  .null "LOOP"
>3a0cb0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0cb1	04				length      .byte len("LOOP")
>3a0cb2	81 d0				name        .word <>TOKEN_TEXT
>3a0cb4	55 3f				eval        .word <>S_LOOP
>3a0cb6	00 00				arity       .word <>0
>3ad086	57 48 49 4c 45 00		TOKEN_TEXT  .null "WHILE"
>3a0cb8	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0cb9	05				length      .byte len("WHILE")
>3a0cba	86 d0				name        .word <>TOKEN_TEXT
>3a0cbc	00 00				eval        .word <>0
>3a0cbe	00 00				arity       .word <>0
>3ad08c	55 4e 54 49 4c 00		TOKEN_TEXT  .null "UNTIL"
>3a0cc0	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0cc1	05				length      .byte len("UNTIL")
>3a0cc2	8c d0				name        .word <>TOKEN_TEXT
>3a0cc4	00 00				eval        .word <>0
>3a0cc6	00 00				arity       .word <>0
>3ad092	45 58 49 54 00			TOKEN_TEXT  .null "EXIT"
>3a0cc8	20				precedence  .byte TOK_TY_STMNT | 0
>3a0cc9	04				length      .byte len("EXIT")
>3a0cca	92 d0				name        .word <>TOKEN_TEXT
>3a0ccc	4f 3f				eval        .word <>S_EXIT
>3a0cce	00 00				arity       .word <>0
>3ad097	43 4c 52 00			TOKEN_TEXT  .null "CLR"
>3a0cd0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0cd1	03				length      .byte len("CLR")
>3a0cd2	97 d0				name        .word <>TOKEN_TEXT
>3a0cd4	87 42				eval        .word <>S_CLR
>3a0cd6	00 00				arity       .word <>0
>3ad09b	53 54 4f 50 00			TOKEN_TEXT  .null "STOP"
>3a0cd8	20				precedence  .byte TOK_TY_STMNT | 0
>3a0cd9	04				length      .byte len("STOP")
>3a0cda	9b d0				name        .word <>TOKEN_TEXT
>3a0cdc	22 3f				eval        .word <>S_STOP
>3a0cde	00 00				arity       .word <>0
>3ad0a0	50 4f 4b 45 00			TOKEN_TEXT  .null "POKE"
>3a0ce0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ce1	04				length      .byte len("POKE")
>3a0ce2	a0 d0				name        .word <>TOKEN_TEXT
>3a0ce4	b2 3e				eval        .word <>S_POKE
>3a0ce6	00 00				arity       .word <>0
>3ad0a5	50 4f 4b 45 57 00		TOKEN_TEXT  .null "POKEW"
>3a0ce8	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ce9	05				length      .byte len("POKEW")
>3a0cea	a5 d0				name        .word <>TOKEN_TEXT
>3a0cec	48 3e				eval        .word <>S_POKEW
>3a0cee	00 00				arity       .word <>0
>3ad0ab	50 4f 4b 45 4c 00		TOKEN_TEXT  .null "POKEL"
>3a0cf0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0cf1	05				length      .byte len("POKEL")
>3a0cf2	ab d0				name        .word <>TOKEN_TEXT
>3a0cf4	d5 3d				eval        .word <>S_POKEL
>3a0cf6	00 00				arity       .word <>0
>3ad0b1	43 4c 53 00			TOKEN_TEXT  .null "CLS"
>3a0cf8	20				precedence  .byte TOK_TY_STMNT | 0
>3a0cf9	03				length      .byte len("CLS")
>3a0cfa	b1 d0				name        .word <>TOKEN_TEXT
>3a0cfc	d1 3d				eval        .word <>S_CLS
>3a0cfe	00 00				arity       .word <>0
>3ad0b5	52 45 41 44 00			TOKEN_TEXT  .null "READ"
>3a0d00	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d01	04				length      .byte len("READ")
>3a0d02	b5 d0				name        .word <>TOKEN_TEXT
>3a0d04	b2 3c				eval        .word <>S_READ
>3a0d06	00 00				arity       .word <>0
=$ab					TOK_DATA = $AB
>3ad0ba	44 41 54 41 00			TOKEN_TEXT  .null "DATA"
>3a0d08	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d09	04				length      .byte len("DATA")
>3a0d0a	ba d0				name        .word <>TOKEN_TEXT
>3a0d0c	c4 3d				eval        .word <>S_DATA
>3a0d0e	00 00				arity       .word <>0
>3ad0bf	52 45 53 54 4f 52 45 00		TOKEN_TEXT  .null "RESTORE"
>3a0d10	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d11	07				length      .byte len("RESTORE")
>3a0d12	bf d0				name        .word <>TOKEN_TEXT
>3a0d14	c8 3d				eval        .word <>S_RESTORE
>3a0d16	00 00				arity       .word <>0
>3ad0c7	44 49 4d 00			TOKEN_TEXT  .null "DIM"
>3a0d18	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d19	03				length      .byte len("DIM")
>3a0d1a	c7 d0				name        .word <>TOKEN_TEXT
>3a0d1c	05 3c				eval        .word <>S_DIM
>3a0d1e	00 00				arity       .word <>0
>3ad0cb	43 41 4c 4c 00			TOKEN_TEXT  .null "CALL"
>3a0d20	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d21	04				length      .byte len("CALL")
>3a0d22	cb d0				name        .word <>TOKEN_TEXT
>3a0d24	6e 3b				eval        .word <>S_CALL
>3a0d26	00 00				arity       .word <>0
=$af					TOK_NEGATIVE = $AF
>3ad0d0	2d 00				TOKEN_TEXT  .null "-"
>3a0d28	00				precedence  .byte TOK_TY_OP | 0
>3a0d29	01				length      .byte len("-")
>3a0d2a	d0 d0				name        .word <>TOKEN_TEXT
>3a0d2c	e6 28				eval        .word <>OP_NEGATIVE
>3a0d2e	01 00				arity       .word <>1
>3ad0d2	4c 45 4e 00			TOKEN_TEXT  .null "LEN"
>3a0d30	30				precedence  .byte TOK_TY_FUNC | 0
>3a0d31	03				length      .byte len("LEN")
>3a0d32	d2 d0				name        .word <>TOKEN_TEXT
>3a0d34	3c 49				eval        .word <>FN_LEN
>3a0d36	00 00				arity       .word <>0
>3ad0d6	50 45 45 4b 00			TOKEN_TEXT  .null "PEEK"
>3a0d38	30				precedence  .byte TOK_TY_FUNC | 0
>3a0d39	04				length      .byte len("PEEK")
>3a0d3a	d6 d0				name        .word <>TOKEN_TEXT
>3a0d3c	8c 49				eval        .word <>FN_PEEK
>3a0d3e	00 00				arity       .word <>0
>3ad0db	50 45 45 4b 57 00		TOKEN_TEXT  .null "PEEKW"
>3a0d40	30				precedence  .byte TOK_TY_FUNC | 0
>3a0d41	05				length      .byte len("PEEKW")
>3a0d42	db d0				name        .word <>TOKEN_TEXT
>3a0d44	1d 4a				eval        .word <>FN_PEEKW
>3a0d46	00 00				arity       .word <>0
>3ad0e1	50 45 45 4b 4c 00		TOKEN_TEXT  .null "PEEKL"
>3a0d48	30				precedence  .byte TOK_TY_FUNC | 0
>3a0d49	05				length      .byte len("PEEKL")
>3a0d4a	e1 d0				name        .word <>TOKEN_TEXT
>3a0d4c	cf 49				eval        .word <>FN_PEEKL
>3a0d4e	00 00				arity       .word <>0
>3ad0e7	43 48 52 24 00			TOKEN_TEXT  .null "CHR$"
>3a0d50	30				precedence  .byte TOK_TY_FUNC | 0
>3a0d51	04				length      .byte len("CHR$")
>3a0d52	e7 d0				name        .word <>TOKEN_TEXT
>3a0d54	5c 4a				eval        .word <>FN_CHR
>3a0d56	00 00				arity       .word <>0
>3ad0ec	41 53 43 00			TOKEN_TEXT  .null "ASC"
>3a0d58	30				precedence  .byte TOK_TY_FUNC | 0
>3a0d59	03				length      .byte len("ASC")
>3a0d5a	ec d0				name        .word <>TOKEN_TEXT
>3a0d5c	b1 4a				eval        .word <>FN_ASC
>3a0d5e	00 00				arity       .word <>0
>3ad0f0	53 50 43 00			TOKEN_TEXT  .null "SPC"
>3a0d60	30				precedence  .byte TOK_TY_FUNC | 0
>3a0d61	03				length      .byte len("SPC")
>3a0d62	f0 d0				name        .word <>TOKEN_TEXT
>3a0d64	f6 4a				eval        .word <>FN_SPC
>3a0d66	00 00				arity       .word <>0
>3ad0f4	54 41 42 00			TOKEN_TEXT  .null "TAB"
>3a0d68	30				precedence  .byte TOK_TY_FUNC | 0
>3a0d69	03				length      .byte len("TAB")
>3a0d6a	f4 d0				name        .word <>TOKEN_TEXT
>3a0d6c	7f 4b				eval        .word <>FN_TAB
>3a0d6e	00 00				arity       .word <>0
>3ad0f8	41 42 53 00			TOKEN_TEXT  .null "ABS"
>3a0d70	30				precedence  .byte TOK_TY_FUNC | 0
>3a0d71	03				length      .byte len("ABS")
>3a0d72	f8 d0				name        .word <>TOKEN_TEXT
>3a0d74	08 4c				eval        .word <>FN_ABS
>3a0d76	00 00				arity       .word <>0
>3ad0fc	53 47 4e 00			TOKEN_TEXT  .null "SGN"
>3a0d78	30				precedence  .byte TOK_TY_FUNC | 0
>3a0d79	03				length      .byte len("SGN")
>3a0d7a	fc d0				name        .word <>TOKEN_TEXT
>3a0d7c	6a 4c				eval        .word <>FN_SGN
>3a0d7e	00 00				arity       .word <>0
>3ad100	48 45 58 24 00			TOKEN_TEXT  .null "HEX$"
>3a0d80	30				precedence  .byte TOK_TY_FUNC | 0
>3a0d81	04				length      .byte len("HEX$")
>3a0d82	00 d1				name        .word <>TOKEN_TEXT
>3a0d84	ae 48				eval        .word <>FN_HEX
>3a0d86	00 00				arity       .word <>0
>3ad105	44 45 43 00			TOKEN_TEXT  .null "DEC"
>3a0d88	30				precedence  .byte TOK_TY_FUNC | 0
>3a0d89	03				length      .byte len("DEC")
>3a0d8a	05 d1				name        .word <>TOKEN_TEXT
>3a0d8c	4d 48				eval        .word <>FN_DEC
>3a0d8e	00 00				arity       .word <>0
>3ad109	53 54 52 24 00			TOKEN_TEXT  .null "STR$"
>3a0d90	30				precedence  .byte TOK_TY_FUNC | 0
>3a0d91	04				length      .byte len("STR$")
>3a0d92	09 d1				name        .word <>TOKEN_TEXT
>3a0d94	ff 47				eval        .word <>FN_STR
>3a0d96	00 00				arity       .word <>0
>3ad10e	56 41 4c 00			TOKEN_TEXT  .null "VAL"
>3a0d98	30				precedence  .byte TOK_TY_FUNC | 0
>3a0d99	03				length      .byte len("VAL")
>3a0d9a	0e d1				name        .word <>TOKEN_TEXT
>3a0d9c	a9 47				eval        .word <>FN_VAL
>3a0d9e	00 00				arity       .word <>0
>3ad112	4c 45 46 54 24 00		TOKEN_TEXT  .null "LEFT$"
>3a0da0	30				precedence  .byte TOK_TY_FUNC | 0
>3a0da1	05				length      .byte len("LEFT$")
>3a0da2	12 d1				name        .word <>TOKEN_TEXT
>3a0da4	e0 46				eval        .word <>FN_LEFT
>3a0da6	00 00				arity       .word <>0
>3ad118	52 49 47 48 54 24 00		TOKEN_TEXT  .null "RIGHT$"
>3a0da8	30				precedence  .byte TOK_TY_FUNC | 0
>3a0da9	06				length      .byte len("RIGHT$")
>3a0daa	18 d1				name        .word <>TOKEN_TEXT
>3a0dac	ff 45				eval        .word <>FN_RIGHT
>3a0dae	00 00				arity       .word <>0
>3ad11f	4d 49 44 24 00			TOKEN_TEXT  .null "MID$"
>3a0db0	30				precedence  .byte TOK_TY_FUNC | 0
>3a0db1	04				length      .byte len("MID$")
>3a0db2	1f d1				name        .word <>TOKEN_TEXT
>3a0db4	4a 45				eval        .word <>FN_MID
>3a0db6	00 00				arity       .word <>0
>3ad124	52 55 4e 00			TOKEN_TEXT  .null "RUN"
>3a0db8	10				precedence  .byte TOK_TY_CMD | 0
>3a0db9	03				length      .byte len("RUN")
>3a0dba	24 d1				name        .word <>TOKEN_TEXT
>3a0dbc	d1 4d				eval        .word <>CMD_RUN
>3a0dbe	00 00				arity       .word <>0
>3ad128	4e 45 57 00			TOKEN_TEXT  .null "NEW"
>3a0dc0	10				precedence  .byte TOK_TY_CMD | 0
>3a0dc1	03				length      .byte len("NEW")
>3a0dc2	28 d1				name        .word <>TOKEN_TEXT
>3a0dc4	9c 4d				eval        .word <>CMD_NEW
>3a0dc6	00 00				arity       .word <>0
>3ad12c	4c 4f 41 44 00			TOKEN_TEXT  .null "LOAD"
>3a0dc8	10				precedence  .byte TOK_TY_CMD | 0
>3a0dc9	04				length      .byte len("LOAD")
>3a0dca	2c d1				name        .word <>TOKEN_TEXT
>3a0dcc	82 69				eval        .word <>CMD_LOAD
>3a0dce	00 00				arity       .word <>0
>3ad131	4c 49 53 54 00			TOKEN_TEXT  .null "LIST"
>3a0dd0	10				precedence  .byte TOK_TY_CMD | 0
>3a0dd1	04				length      .byte len("LIST")
>3a0dd2	31 d1				name        .word <>TOKEN_TEXT
>3a0dd4	e8 4d				eval        .word <>CMD_LIST
>3a0dd6	00 00				arity       .word <>0
>3ad136	44 49 52 00			TOKEN_TEXT  .null "DIR"
>3a0dd8	10				precedence  .byte TOK_TY_CMD | 0
>3a0dd9	03				length      .byte len("DIR")
>3a0dda	36 d1				name        .word <>TOKEN_TEXT
>3a0ddc	a9 66				eval        .word <>CMD_DIR
>3a0dde	00 00				arity       .word <>0
>3ad13a	42 4c 4f 41 44 00		TOKEN_TEXT  .null "BLOAD"
>3a0de0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0de1	05				length      .byte len("BLOAD")
>3a0de2	3a d1				name        .word <>TOKEN_TEXT
>3a0de4	54 68				eval        .word <>S_BLOAD
>3a0de6	00 00				arity       .word <>0
>3ad140	42 52 55 4e 00			TOKEN_TEXT  .null "BRUN"
>3a0de8	10				precedence  .byte TOK_TY_CMD | 0
>3a0de9	04				length      .byte len("BRUN")
>3a0dea	40 d1				name        .word <>TOKEN_TEXT
>3a0dec	2f 69				eval        .word <>CMD_BRUN
>3a0dee	00 00				arity       .word <>0
>3ad145	42 53 41 56 45 00		TOKEN_TEXT  .null "BSAVE"
>3a0df0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0df1	05				length      .byte len("BSAVE")
>3a0df2	45 d1				name        .word <>TOKEN_TEXT
>3a0df4	3b 6a				eval        .word <>S_BSAVE
>3a0df6	00 00				arity       .word <>0
>3ad14b	44 45 4c 00			TOKEN_TEXT  .null "DEL"
>3a0df8	20				precedence  .byte TOK_TY_STMNT | 0
>3a0df9	03				length      .byte len("DEL")
>3a0dfa	4b d1				name        .word <>TOKEN_TEXT
>3a0dfc	5a 6b				eval        .word <>S_DEL
>3a0dfe	00 00				arity       .word <>0
>3ad14f	53 41 56 45 00			TOKEN_TEXT  .null "SAVE"
>3a0e00	10				precedence  .byte TOK_TY_CMD | 0
>3a0e01	04				length      .byte len("SAVE")
>3a0e02	4f d1				name        .word <>TOKEN_TEXT
>3a0e04	c7 6a				eval        .word <>CMD_SAVE
>3a0e06	00 00				arity       .word <>0
>3ad154	52 45 4e 41 4d 45 00		TOKEN_TEXT  .null "RENAME"
>3a0e08	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e09	06				length      .byte len("RENAME")
>3a0e0a	54 d1				name        .word <>TOKEN_TEXT
>3a0e0c	d0 6b				eval        .word <>S_RENAME
>3a0e0e	00 00				arity       .word <>0
>3ad15b	43 4f 50 59 00			TOKEN_TEXT  .null "COPY"
>3a0e10	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e11	04				length      .byte len("COPY")
>3a0e12	5b d1				name        .word <>TOKEN_TEXT
>3a0e14	f4 6c				eval        .word <>S_COPY
>3a0e16	00 00				arity       .word <>0
>3ad160	4d 4f 4e 49 54 4f 52 00		TOKEN_TEXT  .null "MONITOR"
>3a0e18	10				precedence  .byte TOK_TY_CMD | 0
>3a0e19	07				length      .byte len("MONITOR")
>3a0e1a	60 d1				name        .word <>TOKEN_TEXT
>3a0e1c	99 4d				eval        .word <>CMD_MONITOR
>3a0e1e	00 00				arity       .word <>0
>3ad168	47 45 54 00			TOKEN_TEXT  .null "GET"
>3a0e20	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e21	03				length      .byte len("GET")
>3a0e22	68 d1				name        .word <>TOKEN_TEXT
>3a0e24	fc 3a				eval        .word <>S_GET
>3a0e26	00 00				arity       .word <>0
>3ad16c	49 4e 50 55 54 00		TOKEN_TEXT  .null "INPUT"
>3a0e28	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e29	05				length      .byte len("INPUT")
>3a0e2a	6c d1				name        .word <>TOKEN_TEXT
>3a0e2c	31 3a				eval        .word <>S_INPUT
>3a0e2e	00 00				arity       .word <>0
>3ad172	53 45 54 42 4f 52 44 45		TOKEN_TEXT  .null "SETBORDER"
>3ad17a	52 00
>3a0e30	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e31	09				length      .byte len("SETBORDER")
>3a0e32	72 d1				name        .word <>TOKEN_TEXT
>3a0e34	a5 2a				eval        .word <>S_SETBORDER
>3a0e36	00 00				arity       .word <>0
>3ad17c	54 45 58 54 43 4f 4c 4f		TOKEN_TEXT  .null "TEXTCOLOR"
>3ad184	52 00
>3a0e38	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e39	09				length      .byte len("TEXTCOLOR")
>3a0e3a	7c d1				name        .word <>TOKEN_TEXT
>3a0e3c	32 2a				eval        .word <>S_TEXTCOLOR
>3a0e3e	00 00				arity       .word <>0
>3ad186	53 45 54 42 47 43 4f 4c		TOKEN_TEXT  .null "SETBGCOLOR"
>3ad18e	4f 52 00
>3a0e40	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e41	0a				length      .byte len("SETBGCOLOR")
>3a0e42	86 d1				name        .word <>TOKEN_TEXT
>3a0e44	62 2a				eval        .word <>S_SETBGCOLOR
>3a0e46	00 00				arity       .word <>0
>3ad191	53 45 54 44 41 54 45 00		TOKEN_TEXT  .null "SETDATE"
>3a0e48	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e49	07				length      .byte len("SETDATE")
>3a0e4a	91 d1				name        .word <>TOKEN_TEXT
>3a0e4c	9f 29				eval        .word <>S_SETDATE
>3a0e4e	00 00				arity       .word <>0
>3ad199	47 45 54 44 41 54 45 24		TOKEN_TEXT  .null "GETDATE$"
>3ad1a1	00
>3a0e50	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e51	08				length      .byte len("GETDATE$")
>3a0e52	99 d1				name        .word <>TOKEN_TEXT
>3a0e54	25 44				eval        .word <>F_GETDATE
>3a0e56	00 00				arity       .word <>0
>3ad1a2	53 45 54 54 49 4d 45 00		TOKEN_TEXT  .null "SETTIME"
>3a0e58	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e59	07				length      .byte len("SETTIME")
>3a0e5a	a2 d1				name        .word <>TOKEN_TEXT
>3a0e5c	34 29				eval        .word <>S_SETTIME
>3a0e5e	00 00				arity       .word <>0
>3ad1aa	47 45 54 54 49 4d 45 24		TOKEN_TEXT  .null "GETTIME$"
>3ad1b2	00
>3a0e60	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e61	08				length      .byte len("GETTIME$")
>3a0e62	aa d1				name        .word <>TOKEN_TEXT
>3a0e64	8f 44				eval        .word <>F_GETTIME
>3a0e66	00 00				arity       .word <>0
>3ad1b3	47 52 41 50 48 49 43 53		TOKEN_TEXT  .null "GRAPHICS"
>3ad1bb	00
>3a0e68	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e69	08				length      .byte len("GRAPHICS")
>3a0e6a	b3 d1				name        .word <>TOKEN_TEXT
>3a0e6c	ea 2b				eval        .word <>S_GRAPHICS
>3a0e6e	00 00				arity       .word <>0
>3ad1bc	53 45 54 43 4f 4c 4f 52		TOKEN_TEXT  .null "SETCOLOR"
>3ad1c4	00
>3a0e70	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e71	08				length      .byte len("SETCOLOR")
>3a0e72	bc d1				name        .word <>TOKEN_TEXT
>3a0e74	1e 2b				eval        .word <>S_SETCOLOR
>3a0e76	00 00				arity       .word <>0
>3ad1c5	42 49 54 4d 41 50 00		TOKEN_TEXT  .null "BITMAP"
>3a0e78	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e79	06				length      .byte len("BITMAP")
>3a0e7a	c5 d1				name        .word <>TOKEN_TEXT
>3a0e7c	24 2d				eval        .word <>S_BITMAP
>3a0e7e	00 00				arity       .word <>0
>3ad1cc	43 4c 52 42 49 54 4d 41		TOKEN_TEXT  .null "CLRBITMAP"
>3ad1d4	50 00
>3a0e80	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e81	09				length      .byte len("CLRBITMAP")
>3a0e82	cc d1				name        .word <>TOKEN_TEXT
>3a0e84	2c 2e				eval        .word <>S_CLRBITMAP
>3a0e86	00 00				arity       .word <>0
>3ad1d6	50 4c 4f 54 00			TOKEN_TEXT  .null "PLOT"
>3a0e88	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e89	04				length      .byte len("PLOT")
>3a0e8a	d6 d1				name        .word <>TOKEN_TEXT
>3a0e8c	3c 2f				eval        .word <>S_PLOT
>3a0e8e	00 00				arity       .word <>0
>3ad1db	4c 49 4e 45 00			TOKEN_TEXT  .null "LINE"
>3a0e90	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e91	04				length      .byte len("LINE")
>3a0e92	db d1				name        .word <>TOKEN_TEXT
>3a0e94	ad 2f				eval        .word <>S_LINE
>3a0e96	00 00				arity       .word <>0
>3ad1e0	46 49 4c 4c 00			TOKEN_TEXT  .null "FILL"
>3a0e98	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e99	04				length      .byte len("FILL")
>3a0e9a	e0 d1				name        .word <>TOKEN_TEXT
>3a0e9c	46 30				eval        .word <>S_FILL
>3a0e9e	00 00				arity       .word <>0
>3ad1e5	53 50 52 49 54 45 00		TOKEN_TEXT  .null "SPRITE"
>3a0ea0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ea1	06				length      .byte len("SPRITE")
>3a0ea2	e5 d1				name        .word <>TOKEN_TEXT
>3a0ea4	82 31				eval        .word <>S_SPRITE
>3a0ea6	00 00				arity       .word <>0
>3ad1ec	53 50 52 49 54 45 41 54		TOKEN_TEXT  .null "SPRITEAT"
>3ad1f4	00
>3a0ea8	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ea9	08				length      .byte len("SPRITEAT")
>3a0eaa	ec d1				name        .word <>TOKEN_TEXT
>3a0eac	1e 32				eval        .word <>S_SPRITEAT
>3a0eae	00 00				arity       .word <>0
>3ad1f5	53 50 52 49 54 45 53 48		TOKEN_TEXT  .null "SPRITESHOW"
>3ad1fd	4f 57 00
>3a0eb0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0eb1	0a				length      .byte len("SPRITESHOW")
>3a0eb2	f5 d1				name        .word <>TOKEN_TEXT
>3a0eb4	6a 32				eval        .word <>S_SPRITESHOW
>3a0eb6	00 00				arity       .word <>0
>3ad200	54 49 4c 45 53 45 54 00		TOKEN_TEXT  .null "TILESET"
>3a0eb8	20				precedence  .byte TOK_TY_STMNT | 0
>3a0eb9	07				length      .byte len("TILESET")
>3a0eba	00 d2				name        .word <>TOKEN_TEXT
>3a0ebc	9f 33				eval        .word <>S_TILESET
>3a0ebe	00 00				arity       .word <>0
>3ad208	54 49 4c 45 4d 41 50 00		TOKEN_TEXT  .null "TILEMAP"
>3a0ec0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ec1	07				length      .byte len("TILEMAP")
>3a0ec2	08 d2				name        .word <>TOKEN_TEXT
>3a0ec4	1d 34				eval        .word <>S_TILEMAP
>3a0ec6	00 00				arity       .word <>0
>3ad210	54 49 4c 45 53 48 4f 57		TOKEN_TEXT  .null "TILESHOW"
>3ad218	00
>3a0ec8	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ec9	08				length      .byte len("TILESHOW")
>3a0eca	10 d2				name        .word <>TOKEN_TEXT
>3a0ecc	8f 34				eval        .word <>S_TILESHOW
>3a0ece	00 00				arity       .word <>0
>3ad219	54 49 4c 45 41 54 00		TOKEN_TEXT  .null "TILEAT"
>3a0ed0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ed1	06				length      .byte len("TILEAT")
>3a0ed2	19 d2				name        .word <>TOKEN_TEXT
>3a0ed4	cc 34				eval        .word <>S_TILEAT
>3a0ed6	00 00				arity       .word <>0
>3ad220	4d 45 4d 43 4f 50 59 00		TOKEN_TEXT  .null "MEMCOPY"
>3a0ed8	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ed9	07				length      .byte len("MEMCOPY")
>3a0eda	20 d2				name        .word <>TOKEN_TEXT
>3a0edc	fc 37				eval        .word <>S_MEMCOPY
>3a0ede	00 00				arity       .word <>0
=$e6					TOK_LINEAR = $E6
>3ad228	4c 49 4e 45 41 52 00		TOKEN_TEXT  .null "LINEAR"
>3a0ee0	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0ee1	06				length      .byte len("LINEAR")
>3a0ee2	28 d2				name        .word <>TOKEN_TEXT
>3a0ee4	00 00				eval        .word <>0
>3a0ee6	00 00				arity       .word <>0
=$e7					TOK_RECT = $E7
>3ad22f	52 45 43 54 00			TOKEN_TEXT  .null "RECT"
>3a0ee8	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0ee9	04				length      .byte len("RECT")
>3a0eea	2f d2				name        .word <>TOKEN_TEXT
>3a0eec	00 00				eval        .word <>0
>3a0eee	00 00				arity       .word <>0
>3ad234	4c 4f 43 41 54 45 00		TOKEN_TEXT  .null "LOCATE"
>3a0ef0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ef1	06				length      .byte len("LOCATE")
>3a0ef2	34 d2				name        .word <>TOKEN_TEXT
>3a0ef4	11 3a				eval        .word <>S_LOCATE
>3a0ef6	00 00				arity       .word <>0
>3ad23b	49 4e 54 00			TOKEN_TEXT  .null "INT"
>3a0ef8	30				precedence  .byte TOK_TY_FUNC | 0
>3a0ef9	03				length      .byte len("INT")
>3a0efa	3b d2				name        .word <>TOKEN_TEXT
>3a0efc	c0 4c				eval        .word <>FN_INT
>3a0efe	00 00				arity       .word <>0
>3ad23f	52 4e 44 00			TOKEN_TEXT  .null "RND"
>3a0f00	30				precedence  .byte TOK_TY_FUNC | 0
>3a0f01	03				length      .byte len("RND")
>3a0f02	3f d2				name        .word <>TOKEN_TEXT
>3a0f04	f4 44				eval        .word <>FN_RND
>3a0f06	00 00				arity       .word <>0
>3ad243	53 49 4e 00			TOKEN_TEXT  .null "SIN"
>3a0f08	30				precedence  .byte TOK_TY_FUNC | 0
>3a0f09	03				length      .byte len("SIN")
>3a0f0a	43 d2				name        .word <>TOKEN_TEXT
>3a0f0c	d3 4c				eval        .word <>FN_SIN
>3a0f0e	00 00				arity       .word <>0
>3ad247	43 4f 53 00			TOKEN_TEXT  .null "COS"
>3a0f10	30				precedence  .byte TOK_TY_FUNC | 0
>3a0f11	03				length      .byte len("COS")
>3a0f12	47 d2				name        .word <>TOKEN_TEXT
>3a0f14	e9 4c				eval        .word <>FN_COS
>3a0f16	00 00				arity       .word <>0
>3ad24b	54 41 4e 00			TOKEN_TEXT  .null "TAN"
>3a0f18	30				precedence  .byte TOK_TY_FUNC | 0
>3a0f19	03				length      .byte len("TAN")
>3a0f1a	4b d2				name        .word <>TOKEN_TEXT
>3a0f1c	ff 4c				eval        .word <>FN_TAN
>3a0f1e	00 00				arity       .word <>0
>3ad24f	4c 4e 00			TOKEN_TEXT  .null "LN"
>3a0f20	30				precedence  .byte TOK_TY_FUNC | 0
>3a0f21	02				length      .byte len("LN")
>3a0f22	4f d2				name        .word <>TOKEN_TEXT
>3a0f24	15 4d				eval        .word <>FN_LN
>3a0f26	00 00				arity       .word <>0
>3ad252	41 43 4f 53 00			TOKEN_TEXT  .null "ACOS"
>3a0f28	30				precedence  .byte TOK_TY_FUNC | 0
>3a0f29	04				length      .byte len("ACOS")
>3a0f2a	52 d2				name        .word <>TOKEN_TEXT
>3a0f2c	2b 4d				eval        .word <>FN_ACOS
>3a0f2e	00 00				arity       .word <>0
>3ad257	41 53 49 4e 00			TOKEN_TEXT  .null "ASIN"
>3a0f30	30				precedence  .byte TOK_TY_FUNC | 0
>3a0f31	04				length      .byte len("ASIN")
>3a0f32	57 d2				name        .word <>TOKEN_TEXT
>3a0f34	41 4d				eval        .word <>FN_ASIN
>3a0f36	00 00				arity       .word <>0
>3ad25c	41 54 41 4e 00			TOKEN_TEXT  .null "ATAN"
>3a0f38	30				precedence  .byte TOK_TY_FUNC | 0
>3a0f39	04				length      .byte len("ATAN")
>3a0f3a	5c d2				name        .word <>TOKEN_TEXT
>3a0f3c	57 4d				eval        .word <>FN_ATAN
>3a0f3e	00 00				arity       .word <>0
>3ad261	45 58 50 00			TOKEN_TEXT  .null "EXP"
>3a0f40	30				precedence  .byte TOK_TY_FUNC | 0
>3a0f41	03				length      .byte len("EXP")
>3a0f42	61 d2				name        .word <>TOKEN_TEXT
>3a0f44	6d 4d				eval        .word <>FN_EXP
>3a0f46	00 00				arity       .word <>0
>3ad265	53 51 52 00			TOKEN_TEXT  .null "SQR"
>3a0f48	30				precedence  .byte TOK_TY_FUNC | 0
>3a0f49	03				length      .byte len("SQR")
>3a0f4a	65 d2				name        .word <>TOKEN_TEXT
>3a0f4c	83 4d				eval        .word <>FN_SQR
>3a0f4e	00 00				arity       .word <>0
>3a0f50	00 00 00 00 00 00 00 00		            .word 0, 0, 0, 0

;******  Return to file: src\basic816.s


;******  Processing file: src\heap.s

>08b7					ALLOCATED   .long ?     ; Pointer to the most recently allocated object
>08ba					HEAP        .long ?     ; Pointer to the top of the heap (next empty byte)
>08bd					FREED       .long ?     ; Pointer to a linked list of freed heap objects
>08c0					CURRBLOCK   .long ?     ; Pointer to the current heap allocated block
>08c3					CURRHEADER  .long ?     ; Pointer to the header of the current block
>08c6					CURREND     .long ?     ; Pointer to the byte immediately after the current block
>08c9					CURRFREED   .long ?     ; Pointer to the current freed block
>08cc					FREEDEND    .long ?     ; Pointer to the byte immediately after the current freed block
>08cf					LASTFREED   .long ?     ;
.0000					HEAPOBJ
>0000					TYPE        .byte ?     ; Code for the type of object allocated
>0001					COUNT       .byte ?     ; Number of references to the heap object
>0002					NEXT        .long ?     ; Pointer to the next object in the list (used when freed)
>0005					END         .long ?     ; Pointer to the next byte after the block
.3a0f58					INITHEAP
.3a0f58	08		php		            PHP
.3a0f59	0b		phd		            PHD
.3a0f5a	08		php		            PHP
.3a0f5b	c2 20		rep #$20	            REP #$20
.3a0f5d	48		pha		            PHA
.3a0f5e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0f61	5b		tcd		            TCD
.3a0f62	68		pla		            PLA
.3a0f63	28		plp		            PLP
.3a0f64	c2 30		rep #$30	            REP #$30
.3a0f66	a9 ff ff	lda #$ffff	            LDA #<>HEAP_TOP         ; Set the HEAP to the top
.3a0f69	85 ba		sta $08ba	            STA HEAP
.3a0f6b	e2 20		sep #$20	            SEP #$20
.3a0f6d	a9 37		lda #$37	            LDA #`HEAP_TOP
.3a0f6f	85 bc		sta $08bc	            STA HEAP+2
.3a0f71	c2 20		rep #$20	            REP #$20
.3a0f73	64 b7		stz $08b7	            STZ ALLOCATED           ; And clear the pointer to the allocated objects
.3a0f75	64 bd		stz $08bd	            STZ FREED               ; as well as the list of freed objects
.3a0f77	e2 20		sep #$20	            SEP #$20
.3a0f79	64 b9		stz $08b9	            STZ ALLOCATED+2
.3a0f7b	64 bf		stz $08bf	            STZ FREED+2
.3a0f7d	2b		pld		            PLD
.3a0f7e	28		plp		            PLP
.3a0f7f	60		rts		            RTS
.3a0f80					ALLOC
.3a0f80	5a		phy		            PHY
.3a0f81	08		php		            PHP
.3a0f82	e2 20		sep #$20	            SEP #$20
.3a0f84	85 ea		sta $08ea	            STA TOFINDTYPE      ; Save the type of the block to TOFINDTYPE
.3a0f86	c2 10		rep #$10	            REP #$10
.3a0f88	86 8f		stx $088f	            STX MCOUNT           ; And the length of the block needed to MCOUNT
.3a0f8a	c2 20		rep #$20	            REP #$20
.3a0f8c	a5 0e		lda $080e	            LDA SCRATCH+2
.3a0f8e	48		pha		            PHA
.3a0f8f	a5 0c		lda $080c	            LDA SCRATCH
.3a0f91	48		pha		            PHA
.3a0f92	a5 12		lda $0812	            LDA SCRATCH2+2
.3a0f94	48		pha		            PHA
.3a0f95	a5 10		lda $0810	            LDA SCRATCH2
.3a0f97	48		pha		            PHA
.3a0f98	20 30 10	jsr $3a1030	            JSR ALLOCFREED
.3a0f9b	b0 03		bcs $3a0fa0	            BCS done            ; Return, if we got something back
.3a0f9d	20 b4 0f	jsr $3a0fb4	            JSR ALLOCHEAP
.3a0fa0					done
.3a0fa0	20 bc 11	jsr $3a11bc	            JSR HEAP_GETHED
.3a0fa3	c2 20		rep #$20	            REP #$20
.3a0fa5	68		pla		            PLA
.3a0fa6	85 10		sta $0810	            STA SCRATCH2
.3a0fa8	68		pla		            PLA
.3a0fa9	85 12		sta $0812	            STA SCRATCH2+2
.3a0fab	68		pla		            PLA
.3a0fac	85 0c		sta $080c	            STA SCRATCH
.3a0fae	68		pla		            PLA
.3a0faf	85 0e		sta $080e	            STA SCRATCH+2
.3a0fb1	28		plp		            PLP
.3a0fb2	7a		ply		            PLY
.3a0fb3	60		rts		            RTS
.3a0fb4					ALLOCHEAP
.3a0fb4	08		php		            PHP
.3a0fb5	0b		phd		            PHD
.3a0fb6	08		php		            PHP
.3a0fb7	c2 20		rep #$20	            REP #$20
.3a0fb9	48		pha		            PHA
.3a0fba	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0fbd	5b		tcd		            TCD
.3a0fbe	68		pla		            PLA
.3a0fbf	28		plp		            PLP
.3a0fc0	e2 20		sep #$20	            SEP #$20
.3a0fc2	a6 8f		ldx $088f	            LDX MCOUNT
.3a0fc4	ca		dex		            DEX
.3a0fc5	86 0c		stx $080c	            STX SCRATCH             ; SCRATCH := size - 1
.3a0fc7	e8		inx		            INX
.3a0fc8	c2 30		rep #$30	            REP #$30
.3a0fca	38		sec		            SEC
.3a0fcb	a5 ba		lda $08ba	            LDA HEAP
.3a0fcd	e5 0c		sbc $080c	            SBC SCRATCH
.3a0fcf	85 c0		sta $08c0	            STA CURRBLOCK
.3a0fd1	e2 20		sep #$20	            SEP #$20
.3a0fd3	a5 bc		lda $08bc	            LDA HEAP+2
.3a0fd5	e9 00		sbc #$00	            SBC #0
.3a0fd7	85 c2		sta $08c2	            STA CURRBLOCK+2
.3a0fd9	20 bc 11	jsr $3a11bc	            JSR HEAP_GETHED
.3a0fdc	e2 20		sep #$20	            SEP #$20
.3a0fde	a5 ea		lda $08ea	            LDA TOFINDTYPE
.3a0fe0	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE       ; Set the type of the object
.3a0fe3	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a0fe5	a9 00		lda #$00	            LDA #0                  ; Set the count to zero
.3a0fe7	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.3a0fea	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a0fec	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a0fef	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a0ff1	c2 20		rep #$20	            REP #$20
.3a0ff3	a9 00 00	lda #$0000	            LDA #0
.3a0ff6	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a0ff8	c2 20		rep #$20	            REP #$20
.3a0ffa	18		clc		            CLC
.3a0ffb	a5 ba		lda $08ba	            LDA HEAP
.3a0ffd	69 01 00	adc #$0001	            ADC #1
.3a1000	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; To get the address of the next byte
.3a1003	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y      ; after the block
.3a1005	e2 20		sep #$20	            SEP #$20
.3a1007	c8		iny		            INY
.3a1008	c8		iny		            INY
.3a1009	a5 bc		lda $08bc	            LDA HEAP+2
.3a100b	69 00		adc #$00	            ADC #0
.3a100d	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a100f	c2 20		rep #$20	            REP #$20
.3a1011	a5 c0		lda $08c0	            LDA CURRBLOCK
.3a1013	85 b7		sta $08b7	            STA ALLOCATED
.3a1015	e2 20		sep #$20	            SEP #$20
.3a1017	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.3a1019	85 b9		sta $08b9	            STA ALLOCATED+2
.3a101b	c2 20		rep #$20	            REP #$20
.3a101d	38		sec		            SEC                     ; Move the HEAP pointer to the first free byte under the header
.3a101e	a5 c3		lda $08c3	            LDA CURRHEADER
.3a1020	e9 01 00	sbc #$0001	            SBC #1
.3a1023	85 ba		sta $08ba	            STA HEAP
.3a1025	e2 20		sep #$20	            SEP #$20
.3a1027	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a1029	e9 00		sbc #$00	            SBC #0
.3a102b	85 bc		sta $08bc	            STA HEAP+2
.3a102d	2b		pld		            PLD
.3a102e	28		plp		            PLP
.3a102f	60		rts		            RTS
.3a1030					ALLOCFREED
.3a1030	08		php		            PHP
.3a1031	0b		phd		            PHD
.3a1032	08		php		            PHP
.3a1033	c2 20		rep #$20	            REP #$20
.3a1035	48		pha		            PHA
.3a1036	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1039	5b		tcd		            TCD
.3a103a	68		pla		            PLA
.3a103b	28		plp		            PLP
.3a103c	c2 30		rep #$30	            REP #$30
.3a103e	c2 20		rep #$20	            REP #$20
.3a1040	a5 bd		lda $08bd	            LDA FREED
.3a1042	85 c9		sta $08c9	            STA CURRFREED
.3a1044	e2 20		sep #$20	            SEP #$20
.3a1046	a5 bf		lda $08bf	            LDA FREED+2
.3a1048	85 cb		sta $08cb	            STA CURRFREED+2
.3a104a	a5 c9		lda $08c9	loop        LDA CURRFREED           ; Has anything been freed?
.3a104c	d0 17		bne $3a1065	            BNE has_block           ; Yes: check to see if there's a big enough block
.3a104e	e2 20		sep #$20	            SEP #$20
.3a1050	a5 cb		lda $08cb	            LDA CURRFREED+2
.3a1052	d0 11		bne $3a1065	            BNE has_block           ; Yes: check to see if there's a big enough block
.3a1054	c2 20		rep #$20	            REP #$20
.3a1056	a9 00 00	lda #$0000	            LDA #<>0
.3a1059	85 cf		sta $08cf	            STA LASTFREED
.3a105b	e2 20		sep #$20	            SEP #$20
.3a105d	a9 00		lda #$00	            LDA #`0
.3a105f	85 d1		sta $08d1	            STA LASTFREED+2
.3a1061	2b		pld		ret_false   PLD                     ; Return that we didn't find anything
.3a1062	28		plp		            PLP
.3a1063	18		clc		            CLC
.3a1064	60		rts		            RTS
.3a1065					has_block
.3a1065	c2 20		rep #$20	            REP #$20
.3a1067	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.3a106a	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a106c	85 cc		sta $08cc	            STA FREEDEND
.3a106e	e2 20		sep #$20	            SEP #$20
.3a1070	c8		iny		            INY
.3a1071	c8		iny		            INY
.3a1072	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a1074	85 ce		sta $08ce	            STA FREEDEND+2
.3a1076	c2 20		rep #$20	            REP #$20
.3a1078	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required
.3a1079	a5 c9		lda $08c9	            LDA CURRFREED
.3a107b	65 8f		adc $088f	            ADC MCOUNT
.3a107d	85 0c		sta $080c	            STA SCRATCH
.3a107f	e2 20		sep #$20	            SEP #$20
.3a1081	a5 cb		lda $08cb	            LDA CURRFREED+2
.3a1083	69 00		adc #$00	            ADC #0
.3a1085	85 0e		sta $080e	            STA SCRATCH+2
.3a1087	c2 20		rep #$20	            REP #$20
.3a1089	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required + size of header
.3a108a	a5 0c		lda $080c	            LDA SCRATCH                 ; (that is, it's a pointer to the byte immediately after the block desired)
.3a108c	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)
.3a108f	85 0c		sta $080c	            STA SCRATCH
.3a1091	e2 20		sep #$20	            SEP #$20
.3a1093	a5 0e		lda $080e	            LDA SCRATCH+2
.3a1095	69 00		adc #$00	            ADC #0
.3a1097	85 0e		sta $080e	            STA SCRATCH+2
.3a1099	c2 20		rep #$20	            REP #$20
.3a109b	a5 0c		lda $080c	            LDA SCRATCH                 ; Is SCRATCH == FREEDEND?
.3a109d	c5 cc		cmp $08cc	            CMP FREEDEND
.3a109f	d0 28		bne $3a10c9	            BNE not_exact               ; No: check if this block is bigger than needed
.3a10a1	e2 20		sep #$20	            SEP #$20
.3a10a3	a5 0e		lda $080e	            LDA SCRATCH+2
.3a10a5	c5 ce		cmp $08ce	            CMP FREEDEND+2
.3a10a7	d0 20		bne $3a10c9	            BNE not_exact
.3a10a9	c2 20		rep #$20	            REP #$20
.3a10ab	a5 cf		lda $08cf	            LDA LASTFREED               ; LASTFREED == 0?
.3a10ad	d0 5d		bne $3a110c	            BNE adj_last1               ; No: point LASTFREED->NEXT to skip this block
.3a10af	e2 20		sep #$20	            SEP #$20
.3a10b1	a5 d1		lda $08d1	            LDA LASTFREED+2
.3a10b3	d0 57		bne $3a110c	            BNE adj_last1
.3a10b5	c2 20		rep #$20	            REP #$20
.3a10b7	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a10ba	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a10bc	85 bd		sta $08bd	            STA FREED
.3a10be	e2 20		sep #$20	            SEP #$20
.3a10c0	c8		iny		            INY
.3a10c1	c8		iny		            INY
.3a10c2	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a10c4	85 bf		sta $08bf	            STA FREED+2
.3a10c6	4c 6d 11	jmp $3a116d	            JMP init_block              ; And return CURRFREED as our reallocated memory
.3a10c9					not_exact
.3a10c9	c2 20		rep #$20	            REP #$20
.3a10cb	a5 0c		lda $080c	            LDA SCRATCH                 ; Add a buffer to the room needed
.3a10cd	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)          ; So we have room to track the memory still freed
.3a10d0	85 10		sta $0810	            STA SCRATCH2
.3a10d2	e2 20		sep #$20	            SEP #$20
.3a10d4	a5 0e		lda $080e	            LDA SCRATCH+2
.3a10d6	69 00		adc #$00	            ADC #0
.3a10d8	85 12		sta $0812	            STA SCRATCH2+2
.3a10da	e2 20		sep #$20	            SEP #$20
.3a10dc	a5 c6		lda $08c6	            LDA CURREND                 ; Is CURREND > SCRATCH2
.3a10de	c5 10		cmp $0810	            CMP SCRATCH2
.3a10e0	b0 3e		bcs $3a1120	            BGE has_room                ; Yes: there is room in this block to allocate some memory
.3a10e2	90 08		bcc $3a10ec	            BLT try_next
.3a10e4	c2 20		rep #$20	            REP #$20
.3a10e6	a5 c6		lda $08c6	            LDA CURREND
.3a10e8	c5 10		cmp $0810	            CMP SCRATCH2
.3a10ea	b0 34		bcs $3a1120	            BGE has_room
.3a10ec					try_next
.3a10ec	c2 20		rep #$20	            REP #$20
.3a10ee	a5 c9		lda $08c9	            LDA CURRFREED
.3a10f0	85 cf		sta $08cf	            STA LASTFREED
.3a10f2	e2 20		sep #$20	            SEP #$20
.3a10f4	a5 cb		lda $08cb	            LDA CURRFREED+2
.3a10f6	85 d1		sta $08d1	            STA LASTFREED+2
.3a10f8	c2 20		rep #$20	            REP #$20
.3a10fa	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a10fd	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.3a10ff	85 c9		sta $08c9	            STA CURRFREED
.3a1101	e2 20		sep #$20	            SEP #$20
.3a1103	c8		iny		            INY
.3a1104	c8		iny		            INY
.3a1105	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.3a1107	85 cb		sta $08cb	            STA CURRFREED+2
.3a1109	4c 4a 10	jmp $3a104a	            JMP loop                                    ; And try the next header
.3a110c					adj_last1
.3a110c	c2 20		rep #$20	            REP #$20
.3a110e	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := CURRFREED->NEXT
.3a1111	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a1113	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.3a1115	e2 20		sep #$20	            SEP #$20
.3a1117	c8		iny		            INY
.3a1118	c8		iny		            INY
.3a1119	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a111b	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.3a111d	4c 6d 11	jmp $3a116d	            JMP init_block              ; And get CURRFREED ready to return
.3a1120					has_room
.3a1120	c2 20		rep #$20	            REP #$20
.3a1122	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END            ; SCRATCH->END := CURRFREED->END
.3a1125	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a1127	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.3a1129	e2 20		sep #$20	            SEP #$20
.3a112b	c8		iny		            INY
.3a112c	c8		iny		            INY
.3a112d	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a112f	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.3a1131	c2 20		rep #$20	            REP #$20
.3a1133	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; CURREND->NEXT := CURRFREED->NEXT
.3a1136	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a1138	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.3a113a	e2 20		sep #$20	            SEP #$20
.3a113c	c8		iny		            INY
.3a113d	c8		iny		            INY
.3a113e	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a1140	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.3a1142	c2 20		rep #$20	            REP #$20
.3a1144	a5 cf		lda $08cf	            LDA LASTFREED               ; Is this the first object we've examined?
.3a1146	d0 14		bne $3a115c	            BNE adj_last2               ; No: we'll need to adjust the previously examined block
.3a1148	e2 20		sep #$20	            SEP #$20
.3a114a	a5 cf		lda $08cf	            LDA LASTFREED
.3a114c	d0 0e		bne $3a115c	            BNE adj_last2
.3a114e	c2 20		rep #$20	            REP #$20
.3a1150	a5 0c		lda $080c	            LDA SCRATCH
.3a1152	85 bd		sta $08bd	            STA FREED
.3a1154	e2 20		sep #$20	            SEP #$20
.3a1156	a5 0e		lda $080e	            LDA SCRATCH+2
.3a1158	85 bf		sta $08bf	            STA FREED+2
.3a115a	80 11		bra $3a116d	            BRA init_block              ; ... and return the block we've sliced off
.3a115c					adj_last2
.3a115c	c2 20		rep #$20	            REP #$20
.3a115e	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := SCRATCH
.3a1161	a5 0c		lda $080c	            LDA SCRATCH                 ; (point the previous freed block to the newly sliced
.3a1163	97 cf		sta [$08cf],y	            STA [LASTFREED],Y           ;  off part of the current block)
.3a1165	e2 20		sep #$20	            SEP #$20
.3a1167	c8		iny		            INY
.3a1168	c8		iny		            INY
.3a1169	a5 0e		lda $080e	            LDA SCRATCH+2
.3a116b	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.3a116d					init_block
.3a116d	c2 20		rep #$20	            REP #$20
.3a116f	a5 c9		lda $08c9	            LDA CURRFREED
.3a1171	85 c3		sta $08c3	            STA CURRHEADER
.3a1173	e2 20		sep #$20	            SEP #$20
.3a1175	a5 cb		lda $08cb	            LDA CURRFREED+2
.3a1177	85 c5		sta $08c5	            STA CURRHEADER+2
.3a1179	c2 20		rep #$20	            REP #$20
.3a117b	a5 c3		lda $08c3	            LDA CURRHEADER
.3a117d	85 b7		sta $08b7	            STA ALLOCATED
.3a117f	e2 20		sep #$20	            SEP #$20
.3a1181	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a1183	85 b9		sta $08b9	            STA ALLOCATED+2
.3a1185	c2 20		rep #$20	            REP #$20
.3a1187	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; Set CURRHEADER->END to the byte after the block
.3a118a	a5 0c		lda $080c	            LDA SCRATCH
.3a118c	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a118e	e2 20		sep #$20	            SEP #$20
.3a1190	c8		iny		            INY
.3a1191	c8		iny		            INY
.3a1192	a5 0e		lda $080e	            LDA SCRATCH+2
.3a1194	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1196	c2 20		rep #$20	            REP #$20
.3a1198	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Set CURRHEADER->NEXT to NULL
.3a119b	a9 00 00	lda #$0000	            LDA #0
.3a119e	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a11a0	e2 20		sep #$20	            SEP #$20
.3a11a2	c8		iny		            INY
.3a11a3	c8		iny		            INY
.3a11a4	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a11a6	e2 20		sep #$20	            SEP #$20
.3a11a8	a5 ea		lda $08ea	            LDA TOFINDTYPE          ; Get the type code back
.3a11aa	e2 20		sep #$20	            SEP #$20
.3a11ac	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE
.3a11af	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a11b1	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT      ; Set its reference count to 0
.3a11b4	a9 00		lda #$00	            LDA #0
.3a11b6	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a11b8	2b		pld		done        PLD
.3a11b9	28		plp		            PLP
.3a11ba	38		sec		            SEC
.3a11bb	60		rts		            RTS
.3a11bc					HEAP_GETHED
.3a11bc	08		php		            PHP
.3a11bd	c2 20		rep #$20	            REP #$20
.3a11bf	38		sec		            SEC
.3a11c0	a5 c0		lda $08c0	            LDA CURRBLOCK
.3a11c2	e9 08 00	sbc #$0008	            SBC #size(HEAPOBJ)
.3a11c5	85 c3		sta $08c3	            STA CURRHEADER
.3a11c7	e2 20		sep #$20	            SEP #$20
.3a11c9	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.3a11cb	e9 00		sbc #$00	            SBC #0
.3a11cd	85 c5		sta $08c5	            STA CURRHEADER+2
.3a11cf	28		plp		            PLP
.3a11d0	60		rts		            RTS
.3a11d1					HEAP_ADDREF
.3a11d1	08		php		            PHP
.3a11d2	e2 20		sep #$20	            SEP #$20
.3a11d4	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a11d6	f0 04		beq $3a11dc	            BEQ chk_null
.3a11d8	c9 38		cmp #$38	            CMP #`(HEAP_TOP + 1)
.3a11da	b0 12		bcs $3a11ee	            BGE out_of_bnds
.3a11dc					chk_null
.3a11dc	c2 20		rep #$20	            REP #$20
.3a11de	a5 c3		lda $08c3	            LDA CURRHEADER
.3a11e0	f0 0c		beq $3a11ee	            BEQ out_of_bnds
.3a11e2					is_ok
.3a11e2	e2 20		sep #$20	            SEP #$20
.3a11e4	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.3a11e7	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a11e9	1a		inc a		            INC A
.3a11ea	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a11ec	28		plp		            PLP
.3a11ed	60		rts		            RTS
.3a11ee	00		brk #		out_of_bnds BRK
.3a11ef	ea		nop		            NOP
.3a11f0					HEAP_REMREF
.3a11f0	08		php		            PHP
.3a11f1	e2 20		sep #$20	            SEP #$20
.3a11f3	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a11f5	f0 04		beq $3a11fb	            BEQ chk_null
.3a11f7	c9 38		cmp #$38	            CMP #`(HEAP_TOP + 1)
.3a11f9	b0 17		bcs $3a1212	            BGE out_of_bnds
.3a11fb					chk_null
.3a11fb	c2 20		rep #$20	            REP #$20
.3a11fd	a5 c3		lda $08c3	            LDA CURRHEADER
.3a11ff	f0 11		beq $3a1212	            BEQ out_of_bnds
.3a1201	e2 20		sep #$20	            SEP #$20
.3a1203	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT  ; Decrement the reference count
.3a1206	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a1208	3a		dec a		            DEC A
.3a1209	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a120b	d0 03		bne $3a1210	            BNE done            ; If it's still >0, we are done
.3a120d	20 14 12	jsr $3a1214	            JSR HEAP_FREE
.3a1210	28		plp		done        PLP
.3a1211	60		rts		            RTS
.3a1212	00		brk #		out_of_bnds BRK
.3a1213	ea		nop		            NOP
.3a1214					HEAP_FREE
.3a1214	08		php		            PHP
.3a1215	c2 20		rep #$20	            REP #$20
.3a1217	a5 bd		lda $08bd	            LDA FREED           ; Check to see if blocks are already on the freed list
.3a1219	d0 21		bne $3a123c	            BNE has_objects
.3a121b	e2 20		sep #$20	            SEP #$20
.3a121d	a5 bf		lda $08bf	            LDA FREED+2
.3a121f	d0 1b		bne $3a123c	            BNE has_objects
.3a1221	a5 c5		lda $08c5	            LDA CURRHEADER+2    ; No: this block is the first one
.3a1223	85 bf		sta $08bf	            STA FREED+2         ; Just make it the freed list
.3a1225	c2 20		rep #$20	            REP #$20
.3a1227	a5 c3		lda $08c3	            LDA CURRHEADER
.3a1229	85 bd		sta $08bd	            STA FREED
.3a122b	a9 00 00	lda #$0000	            LDA #0
.3a122e	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT   ; And clear its next link
.3a1231	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1233	c8		iny		            INY
.3a1234	c8		iny		            INY
.3a1235	e2 20		sep #$20	            SEP #$20
.3a1237	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1239	4c fb 12	jmp $3a12fb	            JMP done
.3a123c					has_objects
.3a123c	e2 20		sep #$20	            SEP #$20
.3a123e	a5 bf		lda $08bf	            LDA FREED+2
.3a1240	c5 c5		cmp $08c5	            CMP CURRHEADER+2
.3a1242	90 28		bcc $3a126c	            BLT start_scan
.3a1244	c2 20		rep #$20	            REP #$20
.3a1246	a5 bd		lda $08bd	            LDA FREED
.3a1248	c5 c3		cmp $08c3	            CMP CURRHEADER
.3a124a	90 20		bcc $3a126c	            BLT start_scan
.3a124c					ins_first
.3a124c	c2 20		rep #$20	            REP #$20
.3a124e	a5 bd		lda $08bd	            LDA FREED               ; CURRHEADER->NEXT := FREED
.3a1250	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a1253	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1255	e2 20		sep #$20	            SEP #$20
.3a1257	c8		iny		            INY
.3a1258	c8		iny		            INY
.3a1259	a5 bf		lda $08bf	            LDA FREED+2
.3a125b	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a125d	c2 20		rep #$20	            REP #$20
.3a125f	a5 c3		lda $08c3	            LDA CURRHEADER
.3a1261	85 bd		sta $08bd	            STA FREED
.3a1263	e2 20		sep #$20	            SEP #$20
.3a1265	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a1267	85 bf		sta $08bf	            STA FREED+2
.3a1269	4c fb 12	jmp $3a12fb	            JMP done
.3a126c					start_scan
.3a126c	c2 20		rep #$20	            REP #$20
.3a126e	a5 bd		lda $08bd	            LDA FREED
.3a1270	85 08		sta $0808	            STA INDEX
.3a1272	e2 20		sep #$20	            SEP #$20
.3a1274	a5 bf		lda $08bf	            LDA FREED+2
.3a1276	85 0a		sta $080a	            STA INDEX+2
.3a1278					loop
.3a1278	e2 20		sep #$20	            SEP #$20
.3a127a	a0 04 00	ldy #$0004	            LDY #HEAPOBJ.NEXT+2
.3a127d	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a127f	c5 c8		cmp $08c8	            CMP CURREND+2
.3a1281	90 32		bcc $3a12b5	            BLT go_next             ; No: check the next spot
.3a1283	d0 0b		bne $3a1290	            BNE ins_next
.3a1285	c2 20		rep #$20	            REP #$20
.3a1287	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a128a	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a128c	c5 c6		cmp $08c6	            CMP CURREND
.3a128e	90 25		bcc $3a12b5	            BLT go_next             ; No: check the next spot
.3a1290					ins_next
.3a1290	c2 20		rep #$20	            REP #$20
.3a1292	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := INDEX->NEXT
.3a1295	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a1297	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1299	e2 20		sep #$20	            SEP #$20
.3a129b	c8		iny		            INY
.3a129c	c8		iny		            INY
.3a129d	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a129f	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a12a1	c2 20		rep #$20	            REP #$20
.3a12a3	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.3a12a5	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a12a8	97 08		sta [$0808],y	            STA [INDEX],Y
.3a12aa	e2 20		sep #$20	            SEP #$20
.3a12ac	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a12ae	c8		iny		            INY
.3a12af	c8		iny		            INY
.3a12b0	97 08		sta [$0808],y	            STA [INDEX],Y
.3a12b2	4c fb 12	jmp $3a12fb	            JMP done
.3a12b5					go_next
.3a12b5	c2 20		rep #$20	            REP #$20
.3a12b7	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Is INDEX->NEXT = 0
.3a12ba	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a12bc	d0 08		bne $3a12c6	            BNE not_at_end          ; No: load up the next object
.3a12be	e2 20		sep #$20	            SEP #$20
.3a12c0	c8		iny		            INY
.3a12c1	c8		iny		            INY
.3a12c2	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a12c4	f0 19		beq $3a12df	            BEQ at_end
.3a12c6					not_at_end
.3a12c6	c2 20		rep #$20	            REP #$20
.3a12c8	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; INDEX := INDEX->NEXT
.3a12cb	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a12cd	85 0c		sta $080c	            STA SCRATCH
.3a12cf	e2 20		sep #$20	            SEP #$20
.3a12d1	c8		iny		            INY
.3a12d2	c8		iny		            INY
.3a12d3	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a12d5	85 0a		sta $080a	            STA INDEX+2
.3a12d7	c2 20		rep #$20	            REP #$20
.3a12d9	a5 0c		lda $080c	            LDA SCRATCH
.3a12db	85 08		sta $0808	            STA INDEX
.3a12dd	80 99		bra $3a1278	            BRA loop
.3a12df					at_end
.3a12df	c2 20		rep #$20	            REP #$20
.3a12e1	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.3a12e3	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a12e6	97 08		sta [$0808],y	            STA [INDEX],Y
.3a12e8	e2 20		sep #$20	            SEP #$20
.3a12ea	c8		iny		            INY
.3a12eb	c8		iny		            INY
.3a12ec	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a12ee	97 08		sta [$0808],y	            STA [INDEX],Y
.3a12f0	a9 00		lda #$00	            LDA #0                  ; CURRHEADER->NEXT := 0
.3a12f2	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a12f4	c2 20		rep #$20	            REP #$20
.3a12f6	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a12f9	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a12fb					done
.3a12fb	20 00 13	jsr $3a1300	            JSR COALLESCE
.3a12fe	28		plp		            PLP
.3a12ff	60		rts		            RTS
.3a1300					COALLESCE
.3a1300	08		php		            PHP
.3a1301	c2 20		rep #$20	            REP #$20
.3a1303	a5 bd		lda $08bd	            LDA FREED
.3a1305	85 c3		sta $08c3	            STA CURRHEADER
.3a1307	e2 20		sep #$20	            SEP #$20
.3a1309	a5 bf		lda $08bf	            LDA FREED+2
.3a130b	85 c5		sta $08c5	            STA CURRHEADER+2
.3a130d					next_head
.3a130d	c2 20		rep #$20	            REP #$20
.3a130f	a5 c3		lda $08c3	            LDA CURRHEADER          ; Is CURRHEADER == 0?
.3a1311	d0 09		bne $3a131c	            BNE check_next          ; No: check if NEXT is contiguous
.3a1313	e2 20		sep #$20	            SEP #$20
.3a1315	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a1317	d0 03		bne $3a131c	            BNE check_next
.3a1319	4c a3 13	jmp $3a13a3	            JMP done                ; Yes: we're done
.3a131c					check_next
.3a131c	c2 20		rep #$20	            REP #$20
.3a131e	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a1321	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a1323	85 0c		sta $080c	            STA SCRATCH
.3a1325	e2 20		sep #$20	            SEP #$20
.3a1327	c8		iny		            INY
.3a1328	c8		iny		            INY
.3a1329	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a132b	85 0e		sta $080e	            STA SCRATCH+2
.3a132d	c2 20		rep #$20	            REP #$20
.3a132f	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.3a1332	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a1334	85 10		sta $0810	            STA SCRATCH2
.3a1336	e2 20		sep #$20	            SEP #$20
.3a1338	c8		iny		            INY
.3a1339	c8		iny		            INY
.3a133a	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a133c	85 12		sta $0812	            STA SCRATCH2+2
.3a133e	c2 20		rep #$20	            REP #$20
.3a1340	a5 0c		lda $080c	            LDA SCRATCH
.3a1342	c5 10		cmp $0810	            CMP SCRATCH2            ; Is CURRHEADER->END = CURRHEADER->NEXT?
.3a1344	d0 08		bne $3a134e	            BNE go_next             ; No: go to the next block
.3a1346	e2 20		sep #$20	            SEP #$20
.3a1348	a5 0e		lda $080e	            LDA SCRATCH+2
.3a134a	c5 12		cmp $0812	            CMP SCRATCH2+2
.3a134c	f0 1f		beq $3a136d	            BEQ combine             ; Yes: combine the two blocks
.3a134e					go_next
.3a134e	c2 20		rep #$20	            REP #$20
.3a1350	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a1353	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a1355	85 0c		sta $080c	            STA SCRATCH
.3a1357	e2 20		sep #$20	            SEP #$20
.3a1359	c8		iny		            INY
.3a135a	c8		iny		            INY
.3a135b	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a135d	85 0e		sta $080e	            STA SCRATCH+2
.3a135f	c2 20		rep #$20	            REP #$20
.3a1361	a5 0c		lda $080c	            LDA SCRATCH
.3a1363	85 c3		sta $08c3	            STA CURRHEADER
.3a1365	e2 20		sep #$20	            SEP #$20
.3a1367	a5 0e		lda $080e	            LDA SCRATCH+2
.3a1369	85 c5		sta $08c5	            STA CURRHEADER+2
.3a136b	80 a0		bra $3a130d	            BRA next_head                               ; And loop back to next_head
.3a136d					combine
.3a136d	c2 20		rep #$20	            REP #$20
.3a136f	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a1372	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a1374	85 0c		sta $080c	            STA SCRATCH
.3a1376	e2 20		sep #$20	            SEP #$20
.3a1378	c8		iny		            INY
.3a1379	c8		iny		            INY
.3a137a	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a137c	85 0e		sta $080e	            STA SCRATCH+2
.3a137e	c2 20		rep #$20	            REP #$20
.3a1380	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := SCRATCH->NEXT
.3a1383	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.3a1385	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1387	e2 20		sep #$20	            SEP #$20
.3a1389	c8		iny		            INY
.3a138a	c8		iny		            INY
.3a138b	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.3a138d	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a138f	c2 20		rep #$20	            REP #$20
.3a1391	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END       ; CURRHEADER->END := SCRATCH->END
.3a1394	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.3a1396	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1398	e2 20		sep #$20	            SEP #$20
.3a139a	c8		iny		            INY
.3a139b	c8		iny		            INY
.3a139c	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.3a139e	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a13a0	4c 1c 13	jmp $3a131c	            JMP check_next          ; And loop back to check_next
.3a13a3	28		plp		done        PLP
.3a13a4	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\strings.s

.3a13a5					CLRTMPSTR
.3a13a5	08		php		            PHP
.3a13a6	c2 20		rep #$20	            REP #$20
.3a13a8	64 16		stz $0816	            STZ STRPTR
.3a13aa	64 18		stz $0818	            STZ STRPTR+2
.3a13ac	28		plp		            PLP
.3a13ad	60		rts		            RTS
.3a13ae					TEMPSTRING
.3a13ae	08		php		            PHP
.3a13af	c2 30		rep #$30	            REP #$30
.3a13b1	a5 16		lda $0816	            LDA STRPTR          ; Is STRPTR == 0?
.3a13b3	d0 16		bne $3a13cb	            BNE add_256         ; No: add 256 to it
.3a13b5	a5 18		lda $0818	            LDA STRPTR+2
.3a13b7	d0 12		bne $3a13cb	            BNE add_256
.3a13b9	e2 20		sep #$20	            SEP #$20
.3a13bb	64 16		stz $0816	            STZ STRPTR
.3a13bd	a5 e2		lda $08e2	            LDA NEXTVAR+1
.3a13bf	1a		inc a		            INC A
.3a13c0	1a		inc a		            INC A
.3a13c1	85 17		sta $0817	            STA STRPTR+1
.3a13c3	a5 e3		lda $08e3	            LDA NEXTVAR+2
.3a13c5	85 18		sta $0818	            STA STRPTR+2
.3a13c7	64 19		stz $0819	            STZ STRPTR+3
.3a13c9	80 07		bra $3a13d2	            BRA chk_room
.3a13cb					add_256
.3a13cb	c2 20		rep #$20	            REP #$20
.3a13cd	a5 17		lda $0817	            LDA STRPTR+1        ; There was already a temporary string...
.3a13cf	1a		inc a		            INC A               ; Leave 256 bytes for it
.3a13d0	85 17		sta $0817	            STA STRPTR+1
.3a13d2					chk_room
.3a13d2	c2 20		rep #$20	            REP #$20
.3a13d4	a5 bb		lda $08bb	            LDA HEAP+1          ; Check to make sure that STRPTR and HEAP haven't touched
.3a13d6	3a		dec a		            DEC A
.3a13d7	c5 17		cmp $0817	            CMP STRPTR+1
.3a13d9	f0 02		beq $3a13dd	            BEQ no_room         ; If they have, throw an error
.3a13db	b0 1f		bcs $3a13fc	            BGE done
.3a13dd					no_room
.3a13dd	08		php		            PHP
.3a13de	c2 20		rep #$20	            REP #$20
.3a13e0	48		pha		            PHA
.3a13e1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a13e4	5b		tcd		            TCD
.3a13e5	68		pla		            PLA
.3a13e6	28		plp		            PLP
.3a13e7	e2 20		sep #$20	            SEP #$20
.3a13e9	a9 03		lda #$03	            LDA #ERR_MEMORY
.3a13eb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a13ef	c2 20		rep #$20	            REP #$20
.3a13f1	29 ff 00	and #$00ff	            AND #$00FF
.3a13f4	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a13f7	e2 20		sep #$20	            SEP #$20
.3a13f9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a13fc	28		plp		done        PLP
.3a13fd	60		rts		            RTS
.3a13fe					ITOS_DIGIT
.3a13fe	c9 00		cmp #$00	            CMP #0          ; Is it 0?
.3a1400	d0 05		bne $3a1407	            BNE add_digit   ; No: go ahead and add it
.3a1402	c0 01 00	cpy #$0001	            CPY #1          ; Are we on the first digit?
.3a1405	f0 05		beq $3a140c	            BEQ done        ; Yes: ignore this leading 0
.3a1407	09 30		ora #$30	add_digit   ORA #$30        ; Convert it to ASCII
.3a1409	97 16		sta [$0816],y	            STA [STRPTR],Y  ; Save it to the string
.3a140b	c8		iny		            INY             ; And point to the next location
.3a140c					done
.3a140c	60		rts		            RTS
.3a140d					ITOS
.3a140d	08		php		            PHP
.3a140e	c2 30		rep #$30	            REP #$30
.3a1410	64 0c		stz $080c	            STZ SCRATCH         ; Use scratch to store if negative
.3a1412	a5 25		lda $0825	            LDA ARGUMENT1+2     ; Check to see if the number is negative
.3a1414	10 1a		bpl $3a1430	            BPL start_cnvt
.3a1416	18		clc		            CLC                 ; Yes: make ARGUMENT1 positive
.3a1417	a5 23		lda $0823	            LDA ARGUMENT1
.3a1419	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a141c	69 01 00	adc #$0001	            ADC #1
.3a141f	85 23		sta $0823	            STA ARGUMENT1
.3a1421	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a1423	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a1426	69 00 00	adc #$0000	            ADC #0
.3a1429	85 25		sta $0825	            STA ARGUMENT1+2
.3a142b	a9 ff ff	lda #$ffff	            LDA #$FFFF          ; Record that the number was negative
.3a142e	85 0c		sta $080c	            STA SCRATCH
.3a1430					start_cnvt
.3a1430	64 10		stz $0810	            STZ SCRATCH2        ; SCRATCH2 will be our BCD version of the number
.3a1432	64 12		stz $0812	            STZ SCRATCH2+2
.3a1434	64 14		stz $0814	            STZ SCRATCH2+4
.3a1436	a2 1f 00	ldx #$001f	            LDX #31
.3a1439	f8		sed		            SED                 ; Yes, we're really using BCD mode
.3a143a	06 23		asl $0823	shift_loop  ASL ARGUMENT1       ; Shift ARGUMENT1 left one bit
.3a143c	26 25		rol $0825	            ROL ARGUMENT1+2
.3a143e	a5 10		lda $0810	            LDA SCRATCH2        ; SCRATCH2 := SCRATCH2 + SCRATCH2 + Carry
.3a1440	65 10		adc $0810	            ADC SCRATCH2
.3a1442	85 10		sta $0810	            STA SCRATCH2
.3a1444	a5 12		lda $0812	            LDA SCRATCH2+2
.3a1446	65 12		adc $0812	            ADC SCRATCH2+2
.3a1448	85 12		sta $0812	            STA SCRATCH2+2
.3a144a	a5 14		lda $0814	            LDA SCRATCH2+4
.3a144c	65 14		adc $0814	            ADC SCRATCH2+4
.3a144e	85 14		sta $0814	            STA SCRATCH2+4
.3a1450	ca		dex		            DEX
.3a1451	10 e7		bpl $3a143a	            BPL shift_loop      ; Loop through all 32 bits of ARGUMENT1
.3a1453	d8		cld		            CLD                 ; Switch back out of BCD mode
.3a1454	e2 20		sep #$20	            SEP #$20
.3a1456	20 ae 13	jsr $3a13ae	            JSR TEMPSTRING
.3a1459	a0 00 00	ldy #$0000	            LDY #0              ; Y will be index into the temporary string
.3a145c	a5 0c		lda $080c	            LDA SCRATCH         ; Check to see if the number was negative
.3a145e	f0 04		beq $3a1464	            BEQ is_pos          ; No: write a leading space
.3a1460	a9 2d		lda #$2d	            LDA #'-'            ; If negative, write the minus sign
.3a1462	80 02		bra $3a1466	            BRA wr_lead
.3a1464	a9 20		lda #$20	is_pos      LDA #CHAR_SP        ; Write a leading space
.3a1466	97 16		sta [$0816],y	wr_lead     STA [STRPTR],Y
.3a1468	c8		iny		            INY
.3a1469	a2 05 00	ldx #$0005	            LDX #5
.3a146c	b5 10		lda $0810,x	ascii_loop  LDA SCRATCH2,X
.3a146e	29 f0		and #$f0	            AND #$F0
.3a1470	4a		lsr a		            LSR A
.3a1471	4a		lsr a		            LSR A
.3a1472	4a		lsr a		            LSR A
.3a1473	4a		lsr a		            LSR A
.3a1474	20 fe 13	jsr $3a13fe	            JSR ITOS_DIGIT
.3a1477	b5 10		lda $0810,x	            LDA SCRATCH2,X
.3a1479	29 0f		and #$0f	            AND #$0F
.3a147b	20 fe 13	jsr $3a13fe	            JSR ITOS_DIGIT
.3a147e	ca		dex		            DEX
.3a147f	10 eb		bpl $3a146c	            BPL ascii_loop
.3a1481	c0 01 00	cpy #$0001	            CPY #1              ; Did we write anything?
.3a1484	d0 0c		bne $3a1492	            BNE null_term       ; Yes: add a NULL to terminate
.3a1486	a9 20		lda #$20	            LDA #' '            ; No: write a " 0" to the string
.3a1488	87 16		sta [$0816]	            STA [STRPTR]
.3a148a	a0 01 00	ldy #$0001	            LDY #1
.3a148d	a9 30		lda #$30	            LDA #'0'
.3a148f	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a1491	c8		iny		            INY
.3a1492	a9 00		lda #$00	null_term   LDA #0
.3a1494	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And terminate the string
.3a1496	28		plp		done        PLP
.3a1497	60		rts		            RTS
.3a1498	00		brk #		fault       BRK
.3a1499	ea		nop		            NOP
.3a149a					STRLEN
.3a149a	08		php		            PHP
.3a149b	e2 20		sep #$20	            SEP #$20
.3a149d	c2 10		rep #$10	            REP #$10
.3a149f	a0 00 00	ldy #$0000	            LDY #0
.3a14a2	bd 00 00	lda $3a0000,x	loop        LDA #0,B,X
.3a14a5	f0 04		beq $3a14ab	            BEQ done
.3a14a7	e8		inx		            INX
.3a14a8	c8		iny		            INY
.3a14a9	80 f7		bra $3a14a2	            BRA loop
.3a14ab	28		plp		done        PLP
.3a14ac	60		rts		            RTS
.3a14ad					STRCMP
.3a14ad	08		php		            PHP
.3a14ae	0b		phd		            PHD
.3a14af	08		php		            PHP
.3a14b0	c2 20		rep #$20	            REP #$20
.3a14b2	48		pha		            PHA
.3a14b3	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a14b6	5b		tcd		            TCD
.3a14b7	68		pla		            PLA
.3a14b8	28		plp		            PLP
.3a14b9	e2 20		sep #$20	            SEP #$20
.3a14bb	c2 10		rep #$10	            REP #$10
.3a14bd	a0 00 00	ldy #$0000	            LDY #0
.3a14c0	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Check if the character 1 is 0
.3a14c2	d0 04		bne $3a14c8	            BNE comp_mag            ; If not, check the magnitudes
.3a14c4	b7 29		lda [$0829],y	            LDA [ARGUMENT2],Y       ; If so, check if the character 2 is 0
.3a14c6	f0 25		beq $3a14ed	            BEQ are_equal           ; If so, the strings are equal
.3a14c8	b7 23		lda [$0823],y	comp_mag    LDA [ARGUMENT1],Y       ; Otherwise, get character 1 again
.3a14ca	d7 29		cmp [$0829],y	            CMP [ARGUMENT2],Y       ; And compare it to character 2
.3a14cc	90 12		bcc $3a14e0	            BLT is_less             ; Check if character 1 < character 2
.3a14ce	d0 03		bne $3a14d3	            BNE is_greater          ; Check if character 1 > character 2
.3a14d0	c8		iny		            INY                     ; Equal so far... so go to the next pair of characters
.3a14d1	80 ed		bra $3a14c0	            BRA loop
.3a14d3					is_greater
.3a14d3	c2 20		rep #$20	            REP #$20
.3a14d5	a9 01 00	lda #$0001	            LDA #1                  ; So return 1
.3a14d8	85 23		sta $0823	            STA ARGUMENT1
.3a14da	e2 20		sep #$20	            SEP #$20
.3a14dc	64 25		stz $0825	            STZ ARGUMENT1+2
.3a14de	80 15		bra $3a14f5	            BRA done
.3a14e0					is_less
.3a14e0	c2 20		rep #$20	            REP #$20
.3a14e2	a9 ff ff	lda #$ffff	            LDA #$FFFF              ; So return -1
.3a14e5	85 23		sta $0823	            STA ARGUMENT1
.3a14e7	e2 20		sep #$20	            SEP #$20
.3a14e9	85 25		sta $0825	            STA ARGUMENT1+2
.3a14eb	80 08		bra $3a14f5	            BRA done
.3a14ed					are_equal
.3a14ed	c2 20		rep #$20	            REP #$20
.3a14ef	64 23		stz $0823	            STZ ARGUMENT1           ; So return 0
.3a14f1	e2 20		sep #$20	            SEP #$20
.3a14f3	64 25		stz $0825	            STZ ARGUMENT1+2
.3a14f5					done
.3a14f5	e2 20		sep #$20	            SEP #$20
.3a14f7	a9 00		lda #$00	            LDA #TYPE_INTEGER
.3a14f9	85 27		sta $0827	            STA ARGTYPE1
.3a14fb	2b		pld		            PLD
.3a14fc	28		plp		            PLP
.3a14fd	60		rts		            RTS
.3a14fe					STRCONCAT
.3a14fe	08		php		            PHP
.3a14ff	0b		phd		            PHD
.3a1500	8b		phb		            PHB
.3a1501	08		php		            PHP
.3a1502	c2 20		rep #$20	            REP #$20
.3a1504	48		pha		            PHA
.3a1505	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1508	5b		tcd		            TCD
.3a1509	68		pla		            PLA
.3a150a	28		plp		            PLP
.3a150b	e2 20		sep #$20	            SEP #$20
.3a150d	c2 10		rep #$10	            REP #$10
.3a150f	08		php		            PHP
.3a1510	c2 20		rep #$20	            REP #$20
.3a1512	48		pha		            PHA
.3a1513	e2 20		sep #$20	            SEP #$20
.3a1515	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a1517	48		pha		            PHA
.3a1518	ab		plb		            PLB
.3a1519	c2 20		rep #$20	            REP #$20
.3a151b	68		pla		            PLA
.3a151c	28		plp		            PLP
.3a151d	a6 23		ldx $0823	            LDX ARGUMENT1
.3a151f	20 9a 14	jsr $3a149a	            JSR STRLEN
.3a1522	84 0c		sty $080c	            STY SCRATCH
.3a1524	08		php		            PHP
.3a1525	c2 20		rep #$20	            REP #$20
.3a1527	48		pha		            PHA
.3a1528	e2 20		sep #$20	            SEP #$20
.3a152a	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a152c	48		pha		            PHA
.3a152d	ab		plb		            PLB
.3a152e	c2 20		rep #$20	            REP #$20
.3a1530	68		pla		            PLA
.3a1531	28		plp		            PLP
.3a1532	a6 29		ldx $0829	            LDX ARGUMENT2
.3a1534	20 9a 14	jsr $3a149a	            JSR STRLEN
.3a1537	c2 20		rep #$20	            REP #$20
.3a1539	98		tya		            TYA
.3a153a	38		sec		            SEC                     ; X := LEN(ARGUMENT1) + LEN(ARGUMENT2) + 1
.3a153b	65 0c		adc $080c	            ADC SCRATCH
.3a153d	aa		tax		            TAX
.3a153e	e2 20		sep #$20	            SEP #$20
.3a1540	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set type to STRING
.3a1542	20 80 0f	jsr $3a0f80	            JSR ALLOC
.3a1545	c2 20		rep #$20	            REP #$20
.3a1547	a5 b7		lda $08b7	            LDA ALLOCATED           ; INDEX := pointer to the string
.3a1549	85 08		sta $0808	            STA INDEX
.3a154b	e2 20		sep #$20	            SEP #$20
.3a154d	a5 b9		lda $08b9	            LDA ALLOCATED+2
.3a154f	85 0a		sta $080a	            STA INDEX+2
.3a1551	a0 00 00	ldy #$0000	            LDY #0                  ; Set the target index to the beginning
.3a1554	08		php		            PHP
.3a1555	c2 20		rep #$20	            REP #$20
.3a1557	48		pha		            PHA
.3a1558	e2 20		sep #$20	            SEP #$20
.3a155a	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a155c	48		pha		            PHA
.3a155d	ab		plb		            PLB
.3a155e	c2 20		rep #$20	            REP #$20
.3a1560	68		pla		            PLA
.3a1561	28		plp		            PLP
.3a1562	a6 23		ldx $0823	            LDX ARGUMENT1
.3a1564	bd 00 00	lda $3a0000,x	loop1       LDA #0,B,X              ; Get the Xth byte of ARGUMENT1
.3a1567	f0 06		beq $3a156f	            BEQ copy_2              ; Is it null? Yes: move on to the next string
.3a1569	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.3a156b	e8		inx		            INX                     ; Point to the next characters
.3a156c	c8		iny		            INY
.3a156d	80 f5		bra $3a1564	            BRA loop1               ; And do again
.3a156f					copy_2
.3a156f	e2 20		sep #$20	            SEP #$20
.3a1571	08		php		            PHP
.3a1572	c2 20		rep #$20	            REP #$20
.3a1574	48		pha		            PHA
.3a1575	e2 20		sep #$20	            SEP #$20
.3a1577	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a1579	48		pha		            PHA
.3a157a	ab		plb		            PLB
.3a157b	c2 20		rep #$20	            REP #$20
.3a157d	68		pla		            PLA
.3a157e	28		plp		            PLP
.3a157f	a6 29		ldx $0829	            LDX ARGUMENT2
.3a1581	bd 00 00	lda $3a0000,x	loop2       LDA #0,B,X              ; Get the Xth byte of ARGUMENT2
.3a1584	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.3a1586	f0 04		beq $3a158c	            BEQ terminate           ; Is it null? Yes: move on to the next string
.3a1588	e8		inx		            INX                     ; Point to the next characters
.3a1589	c8		iny		            INY
.3a158a	80 f5		bra $3a1581	            BRA loop2               ; And do again
.3a158c					terminate
.3a158c	c2 20		rep #$20	            REP #$20
.3a158e	a5 08		lda $0808	            LDA INDEX               ; Set ARGUMENT1 to the new string
.3a1590	85 23		sta $0823	            STA ARGUMENT1
.3a1592	e2 20		sep #$20	            SEP #$20
.3a1594	a5 0a		lda $080a	            LDA INDEX+2
.3a1596	85 25		sta $0825	            STA ARGUMENT1+2
.3a1598	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set ARGUMENT1's type to STRING
.3a159a	85 27		sta $0827	            STA ARGTYPE1
.3a159c	ab		plb		            PLB
.3a159d	2b		pld		            PLD
.3a159e	28		plp		            PLP
.3a159f	60		rts		            RTS
.3a15a0					STRCPY
.3a15a0	da		phx		            PHX
.3a15a1	5a		phy		            PHY
.3a15a2	08		php		            PHP
.3a15a3	0b		phd		            PHD
.3a15a4	8b		phb		            PHB
.3a15a5	08		php		            PHP
.3a15a6	c2 20		rep #$20	            REP #$20
.3a15a8	48		pha		            PHA
.3a15a9	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a15ac	5b		tcd		            TCD
.3a15ad	68		pla		            PLA
.3a15ae	28		plp		            PLP
.3a15af	c2 20		rep #$20	            REP #$20
.3a15b1	a5 0a		lda $080a	            LDA INDEX+2
.3a15b3	48		pha		            PHA
.3a15b4	a5 08		lda $0808	            LDA INDEX
.3a15b6	48		pha		            PHA
.3a15b7	c2 30		rep #$30	            REP #$30
.3a15b9	08		php		            PHP
.3a15ba	c2 20		rep #$20	            REP #$20
.3a15bc	48		pha		            PHA
.3a15bd	e2 20		sep #$20	            SEP #$20
.3a15bf	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a15c1	48		pha		            PHA
.3a15c2	ab		plb		            PLB
.3a15c3	c2 20		rep #$20	            REP #$20
.3a15c5	68		pla		            PLA
.3a15c6	28		plp		            PLP
.3a15c7	a6 23		ldx $0823	            LDX ARGUMENT1
.3a15c9	20 9a 14	jsr $3a149a	            JSR STRLEN
.3a15cc	98		tya		            TYA
.3a15cd	aa		tax		            TAX
.3a15ce	e8		inx		            INX                     ; Put length of string (plus NUL) in X
.3a15cf	e2 20		sep #$20	            SEP #$20
.3a15d1	a9 02		lda #$02	            LDA #TYPE_STRING
.3a15d3	20 80 0f	jsr $3a0f80	            JSR ALLOC
.3a15d6	c2 20		rep #$20	            REP #$20
.3a15d8	a5 c0		lda $08c0	            LDA CURRBLOCK
.3a15da	85 08		sta $0808	            STA INDEX
.3a15dc	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.3a15de	85 0a		sta $080a	            STA INDEX+2
.3a15e0	a0 00 00	ldy #$0000	            LDY #0
.3a15e3	e2 20		sep #$20	            SEP #$20
.3a15e5	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Copy the data to the allocated string
.3a15e7	97 08		sta [$0808],y	            STA [INDEX],Y
.3a15e9	f0 03		beq $3a15ee	            BEQ ret_copy
.3a15eb	c8		iny		            INY
.3a15ec	80 f7		bra $3a15e5	            BRA loop
.3a15ee					ret_copy
.3a15ee	c2 20		rep #$20	            REP #$20
.3a15f0	a5 08		lda $0808	            LDA INDEX
.3a15f2	85 23		sta $0823	            STA ARGUMENT1
.3a15f4	a5 0a		lda $080a	            LDA INDEX+2
.3a15f6	85 25		sta $0825	            STA ARGUMENT1+2
.3a15f8	c2 20		rep #$20	            REP #$20
.3a15fa	68		pla		            PLA
.3a15fb	85 08		sta $0808	            STA INDEX
.3a15fd	68		pla		            PLA
.3a15fe	85 0a		sta $080a	            STA INDEX+2
.3a1600	ab		plb		            PLB
.3a1601	2b		pld		            PLD
.3a1602	28		plp		            PLP
.3a1603	7a		ply		            PLY
.3a1604	fa		plx		            PLX
.3a1605	60		rts		            RTS
.3a1606					STRSUBSTR
.3a1606	08		php		            PHP
.3a1607	e2 20		sep #$20	            SEP #$20
.3a1609	c2 10		rep #$10	            REP #$10
.3a160b	a0 00 00	ldy #$0000	            LDY #0
.3a160e	b7 23		lda [$0823],y	count_loop  LDA [ARGUMENT1],Y
.3a1610	f0 05		beq $3a1617	            BEQ counted
.3a1612	c8		iny		            INY
.3a1613	80 f9		bra $3a160e	            BRA count_loop
.3a1615	84 92		sty $0892	            STY MTEMP               ; MTEMP := length of the source string
.3a1617					counted
.3a1617	c2 30		rep #$30	            REP #$30
.3a1619	c4 29		cpy $0829	            CPY ARGUMENT2           ; length of string <= index?
.3a161b	90 13		bcc $3a1630	            BLT ret_empty           ; Yes: return empty string
.3a161d	f0 11		beq $3a1630	            BEQ ret_empty
.3a161f	a5 8f		lda $088f	            LDA MCOUNT              ; Is the desired count <= 0?
.3a1621	30 0d		bmi $3a1630	            BMI ret_empty
.3a1623	f0 0b		beq $3a1630	            BEQ ret_empty           ; Yes: return the empty string
.3a1625	c4 8f		cpy $088f	            CPY MCOUNT              ; Is the desired length < the length of the source?
.3a1627	b0 12		bcs $3a163b	            BGE do_slice            ; Yes: go ahead and get the substring
.3a1629	a5 29		lda $0829	            LDA ARGUMENT2           ; Is INDEX == 0?
.3a162b	d0 0e		bne $3a163b	            BNE do_slice            ; No: do a slice
.3a162d	4c 84 16	jmp $3a1684	            JMP done                ; Yes: just return the source string
.3a1630					ret_empty
.3a1630	20 ae 13	jsr $3a13ae	            JSR TEMPSTRING
.3a1633	e2 20		sep #$20	            SEP #$20
.3a1635	a9 00		lda #$00	            LDA #0
.3a1637	87 16		sta [$0816]	            STA [STRPTR]
.3a1639	80 39		bra $3a1674	            BRA finish_copy
.3a163b					do_slice
.3a163b	20 ae 13	jsr $3a13ae	            JSR TEMPSTRING
.3a163e	c2 30		rep #$30	            REP #$30
.3a1640	18		clc		            CLC                     ; ARGUMENT1 := ARGUMENT1 + index
.3a1641	a5 23		lda $0823	            LDA ARGUMENT1
.3a1643	65 29		adc $0829	            ADC ARGUMENT2
.3a1645	85 23		sta $0823	            STA ARGUMENT1
.3a1647	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a1649	69 00 00	adc #$0000	            ADC #0
.3a164c	85 25		sta $0825	            STA ARGUMENT1+2
.3a164e	a0 00 00	ldy #$0000	            LDY #0
.3a1651					copy_loop
.3a1651	e2 20		sep #$20	            SEP #$20
.3a1653	a7 23		lda [$0823]	            LDA [ARGUMENT1]         ; Copy a character from the substring to the temporary string
.3a1655	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a1657	f0 1b		beq $3a1674	            BEQ finish_copy         ; If it is a NULL, we're done
.3a1659	c2 20		rep #$20	            REP #$20
.3a165b	18		clc		            CLC                     ; Move to the next character
.3a165c	a5 23		lda $0823	            LDA ARGUMENT1
.3a165e	69 01 00	adc #$0001	            ADC #1
.3a1661	85 23		sta $0823	            STA ARGUMENT1
.3a1663	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a1665	69 00 00	adc #$0000	            ADC #0
.3a1668	85 25		sta $0825	            STA ARGUMENT1+2
.3a166a	c8		iny		            INY
.3a166b	c4 8f		cpy $088f	            CPY MCOUNT              ; Have we reached the limit to copy?
.3a166d	d0 e2		bne $3a1651	            BNE copy_loop           ; No: copy the next byte
.3a166f	a9 00 00	lda #$0000	            LDA #0                  ; Null terminate string
.3a1672	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a1674					finish_copy
.3a1674	c2 20		rep #$20	            REP #$20
.3a1676	a5 16		lda $0816	            LDA STRPTR
.3a1678	85 23		sta $0823	            STA ARGUMENT1
.3a167a	a5 18		lda $0818	            LDA STRPTR+2
.3a167c	85 25		sta $0825	            STA ARGUMENT1+2
.3a167e	e2 20		sep #$20	            SEP #$20
.3a1680	a9 02		lda #$02	            LDA #<TYPE_STRING
.3a1682	85 27		sta $0827	            STA ARGTYPE1
.3a1684					done
.3a1684	28		plp		            PLP
.3a1685	60		rts		            RTS
.3a1686					OP_STR_LT
.3a1686	08		php		            PHP
.3a1687	c2 30		rep #$30	            REP #$30
.3a1689	20 ad 14	jsr $3a14ad	            JSR STRCMP
.3a168c	a5 23		lda $0823	            LDA ARGUMENT1
.3a168e	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.3a1691	d0 05		bne $3a1698	            BNE ret_false               ; No: return false
.3a1693					ret_true
.3a1693	20 df 04	jsr $3a04df	            JSR SET_TRUE
.3a1696	80 03		bra $3a169b	            BRA done
.3a1698					ret_false
.3a1698	20 f1 04	jsr $3a04f1	            JSR SET_FALSE
.3a169b	28		plp		done        PLP
.3a169c	60		rts		            RTS
.3a169d					OP_STR_GT
.3a169d	08		php		            PHP
.3a169e	c2 30		rep #$30	            REP #$30
.3a16a0	20 ad 14	jsr $3a14ad	            JSR STRCMP
.3a16a3	a5 23		lda $0823	            LDA ARGUMENT1
.3a16a5	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.3a16a8	d0 05		bne $3a16af	            BNE ret_false               ; No: return false
.3a16aa					ret_true
.3a16aa	20 df 04	jsr $3a04df	            JSR SET_TRUE
.3a16ad	80 03		bra $3a16b2	            BRA done
.3a16af					ret_false
.3a16af	20 f1 04	jsr $3a04f1	            JSR SET_FALSE
.3a16b2	28		plp		done        PLP
.3a16b3	60		rts		            RTS
.3a16b4					OP_STR_EQ
.3a16b4	08		php		            PHP
.3a16b5	c2 30		rep #$30	            REP #$30
.3a16b7	20 ad 14	jsr $3a14ad	            JSR STRCMP
.3a16ba	a5 23		lda $0823	            LDA ARGUMENT1
.3a16bc	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.3a16bf	d0 05		bne $3a16c6	            BNE ret_false               ; No: return false
.3a16c1					ret_true
.3a16c1	20 df 04	jsr $3a04df	            JSR SET_TRUE
.3a16c4	80 03		bra $3a16c9	            BRA done
.3a16c6					ret_false
.3a16c6	20 f1 04	jsr $3a04f1	            JSR SET_FALSE
.3a16c9	28		plp		done        PLP
.3a16ca	60		rts		            RTS
.3a16cb					OP_STR_NE
.3a16cb	08		php		            PHP
.3a16cc	c2 30		rep #$30	            REP #$30
.3a16ce	20 ad 14	jsr $3a14ad	            JSR STRCMP
.3a16d1	a5 23		lda $0823	            LDA ARGUMENT1
.3a16d3	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.3a16d6	f0 05		beq $3a16dd	            BEQ ret_false               ; Yes: return false
.3a16d8					ret_true
.3a16d8	20 df 04	jsr $3a04df	            JSR SET_TRUE
.3a16db	80 03		bra $3a16e0	            BRA done
.3a16dd					ret_false
.3a16dd	20 f1 04	jsr $3a04f1	            JSR SET_FALSE
.3a16e0	28		plp		done        PLP
.3a16e1	60		rts		            RTS
.3a16e2					OP_STR_GTE
.3a16e2	08		php		            PHP
.3a16e3	c2 30		rep #$30	            REP #$30
.3a16e5	20 ad 14	jsr $3a14ad	            JSR STRCMP
.3a16e8	a5 23		lda $0823	            LDA ARGUMENT1
.3a16ea	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.3a16ed	f0 05		beq $3a16f4	            BEQ ret_false               ; Yes: return false
.3a16ef					ret_true
.3a16ef	20 df 04	jsr $3a04df	            JSR SET_TRUE
.3a16f2	80 03		bra $3a16f7	            BRA done
.3a16f4					ret_false
.3a16f4	20 f1 04	jsr $3a04f1	            JSR SET_FALSE
.3a16f7	28		plp		done        PLP
.3a16f8	60		rts		            RTS
.3a16f9					OP_STR_LTE
.3a16f9	08		php		            PHP
.3a16fa	c2 30		rep #$30	            REP #$30
.3a16fc	20 ad 14	jsr $3a14ad	            JSR STRCMP
.3a16ff	a5 23		lda $0823	            LDA ARGUMENT1
.3a1701	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.3a1704	f0 05		beq $3a170b	            BEQ ret_false               ; Yes: return false
.3a1706					ret_true
.3a1706	20 df 04	jsr $3a04df	            JSR SET_TRUE
.3a1709	80 03		bra $3a170e	            BRA done
.3a170b					ret_false
.3a170b	20 f1 04	jsr $3a04f1	            JSR SET_FALSE
.3a170e	28		plp		done        PLP
.3a170f	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\listing.s

.3a1710					LISTPROG
.3a1710	48		pha		            PHA
.3a1711	5a		phy		            PHY
.3a1712	0b		phd		            PHD
.3a1713	08		php		            PHP
.3a1714	08		php		            PHP
.3a1715	c2 20		rep #$20	            REP #$20
.3a1717	48		pha		            PHA
.3a1718	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a171b	5b		tcd		            TCD
.3a171c	68		pla		            PLA
.3a171d	28		plp		            PLP
.3a171e	c2 30		rep #$30	            REP #$30
.3a1720	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.3a1723	85 00		sta $0800	            STA BIP
.3a1725	85 1a		sta $081a	            STA CURLINE
.3a1727	a9 36 00	lda #$0036	            LDA #`BASIC_BOT
.3a172a	85 02		sta $0802	            STA BIP+2
.3a172c	85 1c		sta $081c	            STA CURLINE+2
.3a172e	ad 8a 0f	lda $0f8a	list_loop   LDA KEYFLAG         ; Check the keyboard flags
.3a1731	30 20		bmi $3a1753	            BMI throw_break     ; If MSB: user pressed an interrupt key, stop the listing
.3a1733	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.3a1736	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.3a1738	f0 0f		beq $3a1749	            BEQ done
.3a173a	c5 55		cmp $0855	            CMP MARG1
.3a173c	90 10		bcc $3a174e	            BLT skip_line
.3a173e	c5 59		cmp $0859	            CMP MARG2
.3a1740	f0 02		beq $3a1744	            BEQ print_line
.3a1742	b0 05		bcs $3a1749	            BGE done
.3a1744					print_line
.3a1744	20 72 17	jsr $3a1772	            JSR LISTLINE
.3a1747	80 e5		bra $3a172e	            BRA list_loop
.3a1749	28		plp		done        PLP
.3a174a	2b		pld		            PLD
.3a174b	7a		ply		            PLY
.3a174c	68		pla		            PLA
.3a174d	60		rts		            RTS
.3a174e					skip_line
.3a174e	20 3b 20	jsr $3a203b	            JSR NEXTLINE
.3a1751	80 db		bra $3a172e	            BRA list_loop           ; And try again
.3a1753					throw_break
.3a1753	08		php		            PHP
.3a1754	c2 20		rep #$20	            REP #$20
.3a1756	48		pha		            PHA
.3a1757	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a175a	5b		tcd		            TCD
.3a175b	68		pla		            PLA
.3a175c	28		plp		            PLP
.3a175d	e2 20		sep #$20	            SEP #$20
.3a175f	a9 01		lda #$01	            LDA #ERR_BREAK
.3a1761	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1765	c2 20		rep #$20	            REP #$20
.3a1767	29 ff 00	and #$00ff	            AND #$00FF
.3a176a	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a176d	e2 20		sep #$20	            SEP #$20
.3a176f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1772					LISTLINE
.3a1772	08		php		            PHP
.3a1773	c2 30		rep #$30	            REP #$30
.3a1775	85 23		sta $0823	            STA ARGUMENT1
.3a1777	64 25		stz $0825	            STZ ARGUMENT1+2
.3a1779	20 0d 14	jsr $3a140d	            JSR ITOS
.3a177c	a5 16		lda $0816	            LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.3a177e	1a		inc a		            INC A
.3a177f	85 23		sta $0823	            STA ARGUMENT1
.3a1781	a5 18		lda $0818	            LDA STRPTR+2
.3a1783	85 25		sta $0825	            STA ARGUMENT1+2
.3a1785	20 c2 43	jsr $3a43c2	            JSR PR_STRING
.3a1788	18		clc		            CLC                 ; Move the BIP to the first byte of the line
.3a1789	a5 1a		lda $081a	            LDA CURLINE
.3a178b	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a178e	85 00		sta $0800	            STA BIP
.3a1790	a5 1c		lda $081c	            LDA CURLINE+2
.3a1792	69 00 00	adc #$0000	            ADC #0
.3a1795	85 02		sta $0802	            STA BIP+2
.3a1797	e2 20		sep #$20	            SEP #$20
.3a1799	a9 20		lda #$20	            LDA #CHAR_SP
.3a179b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a179e	c2 20		rep #$20	            REP #$20
.3a17a0					loop
.3a17a0	20 b1 17	jsr $3a17b1	            JSR LISTBYTE
.3a17a3	90 fb		bcc $3a17a0	            BCC loop
.3a17a5	e2 20		sep #$20	            SEP #$20
.3a17a7	a9 0d		lda #$0d	            LDA #CHAR_CR
.3a17a9	20 18 00	jsr $3a0018	            JSR PRINTC
.3a17ac	20 3b 20	jsr $3a203b	            JSR NEXTLINE
.3a17af	28		plp		            PLP
.3a17b0	60		rts		            RTS
.3a17b1					LISTBYTE
.3a17b1	08		php		            PHP
.3a17b2	0b		phd		            PHD
.3a17b3	8b		phb		            PHB
.3a17b4	08		php		            PHP
.3a17b5	c2 20		rep #$20	            REP #$20
.3a17b7	48		pha		            PHA
.3a17b8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a17bb	5b		tcd		            TCD
.3a17bc	68		pla		            PLA
.3a17bd	28		plp		            PLP
.3a17be	08		php		            PHP
.3a17bf	e2 20		sep #$20	            SEP #$20
.3a17c1	48		pha		            PHA
.3a17c2	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a17c4	48		pha		            PHA
.3a17c5	ab		plb		            PLB
.3a17c6	68		pla		            PLA
.3a17c7	28		plp		            PLP
.3a17c8	e2 20		sep #$20	            SEP #$20
.3a17ca	c2 10		rep #$10	            REP #$10
.3a17cc	a7 00		lda [$0800]	            LDA [BIP]           ; Get the current byte
.3a17ce	f0 3a		beq $3a180a	            BEQ end_of_line     ; If it's 0, return with C set
.3a17d0	30 05		bmi $3a17d7	            BMI is_token        ; If it's 0x80 - 0xFF, it's a token
.3a17d2	20 18 00	jsr $3a0018	            JSR PRINTC
.3a17d5	80 29		bra $3a1800	            BRA done            ; And return
.3a17d7					is_token
.3a17d7	c2 20		rep #$20	            REP #$20
.3a17d9	29 7f 00	and #$007f	            AND #$007F          ; Compute the index of the token
.3a17dc	0a		asl a		            ASL A               ; In the token table
.3a17dd	0a		asl a		            ASL A
.3a17de	0a		asl a		            ASL A
.3a17df	18		clc		            CLC
.3a17e0	69 b0 0b	adc #$0bb0	            ADC #<>TOKENS       ; Set INDEX to the address of the token
.3a17e3	85 08		sta $0808	            STA INDEX
.3a17e5	a9 3a 00	lda #$003a	            LDA #`TOKENS
.3a17e8	69 00 00	adc #$0000	            ADC #0
.3a17eb	85 0a		sta $080a	            STA INDEX+2
.3a17ed					pr_default
.3a17ed	08		php		            PHP
.3a17ee	e2 20		sep #$20	            SEP #$20
.3a17f0	48		pha		            PHA
.3a17f1	a9 3a		lda #$3a	            LDA #`TOKENS
.3a17f3	48		pha		            PHA
.3a17f4	ab		plb		            PLB
.3a17f5	68		pla		            PLA
.3a17f6	28		plp		            PLP
.3a17f7	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.3a17fa	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a17fc	aa		tax		            TAX
.3a17fd	20 16 03	jsr $3a0316	            JSR PRINTS
.3a1800					done
.3a1800	c2 20		rep #$20	            REP #$20
.3a1802	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a1805	ab		plb		            PLB
.3a1806	2b		pld		            PLD
.3a1807	28		plp		            PLP
.3a1808	18		clc		            CLC
.3a1809	60		rts		            RTS
.3a180a	ab		plb		end_of_line PLB
.3a180b	2b		pld		            PLD
.3a180c	28		plp		            PLP
.3a180d	38		sec		            SEC
.3a180e	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\eval.s

.3a180f					INITEVALSP
.3a180f	08		php		            PHP
.3a1810	c2 20		rep #$20	            REP #$20
.3a1812	a9 ff 6f	lda #$6fff	            LDA #ARGUMENT_TOP
.3a1815	85 1f		sta $081f	            STA ARGUMENTSP
.3a1817	a9 ff 7f	lda #$7fff	            LDA #OPERATOR_TOP
.3a181a	85 21		sta $0821	            STA OPERATORSP
.3a181c	a9 ff ff	lda #$ffff	            LDA #$FFFF
.3a181f	85 23		sta $0823	            STA ARGUMENT1
.3a1821	85 25		sta $0825	            STA ARGUMENT1+2
.3a1823	85 29		sta $0829	            STA ARGUMENT2
.3a1825	85 2b		sta $082b	            STA ARGUMENT2+2
.3a1827	e2 20		sep #$20	            SEP #$20
.3a1829	85 27		sta $0827	            STA ARGTYPE1
.3a182b	85 2d		sta $082d	            STA ARGTYPE2
.3a182d	28		plp		            PLP
.3a182e	60		rts		            RTS
.3a182f					PHARGUMENT
.3a182f	08		php		            PHP
.3a1830	0b		phd		            PHD
.3a1831	8b		phb		            PHB
.3a1832	08		php		            PHP
.3a1833	c2 20		rep #$20	            REP #$20
.3a1835	48		pha		            PHA
.3a1836	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1839	5b		tcd		            TCD
.3a183a	68		pla		            PLA
.3a183b	28		plp		            PLP
.3a183c	08		php		            PHP
.3a183d	e2 20		sep #$20	            SEP #$20
.3a183f	48		pha		            PHA
.3a1840	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a1842	48		pha		            PHA
.3a1843	ab		plb		            PLB
.3a1844	68		pla		            PLA
.3a1845	28		plp		            PLP
.3a1846	c2 30		rep #$30	            REP #$30
.3a1848	5a		phy		            PHY
.3a1849	a4 1f		ldy $081f	            LDY ARGUMENTSP
.3a184b	bd 00 00	lda $0000,x	            LDA #0,B,X
.3a184e	99 00 00	sta $0000,y	            STA #0,B,Y
.3a1851	bd 02 00	lda $0002,x	            LDA #2,B,X
.3a1854	99 02 00	sta $0002,y	            STA #2,B,Y
.3a1857	e2 20		sep #$20	            SEP #$20
.3a1859	bd 04 00	lda $0004,x	            LDA #4,B,X
.3a185c	99 04 00	sta $0004,y	            STA #4,B,Y
.3a185f	c2 20		rep #$20	            REP #$20
.3a1861	38		sec		            SEC
.3a1862	98		tya		            TYA
.3a1863	e9 05 00	sbc #$0005	            SBC #ARGUMENT_SIZE
.3a1866	85 1f		sta $081f	            STA ARGUMENTSP
.3a1868	7a		ply		            PLY
.3a1869	ab		plb		            PLB
.3a186a	2b		pld		            PLD
.3a186b	28		plp		            PLP
.3a186c	60		rts		            RTS
.3a186d					PLARGUMENT
.3a186d	08		php		            PHP
.3a186e	0b		phd		            PHD
.3a186f	8b		phb		            PHB
.3a1870	08		php		            PHP
.3a1871	c2 20		rep #$20	            REP #$20
.3a1873	48		pha		            PHA
.3a1874	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1877	5b		tcd		            TCD
.3a1878	68		pla		            PLA
.3a1879	28		plp		            PLP
.3a187a	08		php		            PHP
.3a187b	e2 20		sep #$20	            SEP #$20
.3a187d	48		pha		            PHA
.3a187e	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a1880	48		pha		            PHA
.3a1881	ab		plb		            PLB
.3a1882	68		pla		            PLA
.3a1883	28		plp		            PLP
.3a1884	c2 30		rep #$30	            REP #$30
.3a1886	5a		phy		            PHY
.3a1887	18		clc		            CLC
.3a1888	a5 1f		lda $081f	            LDA ARGUMENTSP
.3a188a	69 05 00	adc #$0005	            ADC #ARGUMENT_SIZE
.3a188d	85 1f		sta $081f	            STA ARGUMENTSP
.3a188f	a8		tay		            TAY
.3a1890	b9 00 00	lda $0000,y	            LDA #0,B,Y
.3a1893	9d 00 00	sta $0000,x	            STA #0,B,X
.3a1896	b9 02 00	lda $0002,y	            LDA #2,B,Y
.3a1899	9d 02 00	sta $0002,x	            STA #2,B,X
.3a189c	e2 20		sep #$20	            SEP #$20
.3a189e	b9 04 00	lda $0004,y	            LDA #4,B,Y
.3a18a1	9d 04 00	sta $0004,x	            STA #4,B,X
.3a18a4	bd 00 00	lda $0000,x	            LDA #0,B,X
.3a18a7	7a		ply		            PLY
.3a18a8	ab		plb		            PLB
.3a18a9	2b		pld		            PLD
.3a18aa	28		plp		            PLP
.3a18ab	60		rts		            RTS
.3a18ac					PHOPERATOR
.3a18ac	08		php		            PHP
.3a18ad	0b		phd		            PHD
.3a18ae	8b		phb		            PHB
.3a18af	08		php		            PHP
.3a18b0	c2 20		rep #$20	            REP #$20
.3a18b2	48		pha		            PHA
.3a18b3	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a18b6	5b		tcd		            TCD
.3a18b7	68		pla		            PLA
.3a18b8	28		plp		            PLP
.3a18b9	08		php		            PHP
.3a18ba	e2 20		sep #$20	            SEP #$20
.3a18bc	48		pha		            PHA
.3a18bd	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a18bf	48		pha		            PHA
.3a18c0	ab		plb		            PLB
.3a18c1	68		pla		            PLA
.3a18c2	28		plp		            PLP
.3a18c3	e2 20		sep #$20	            SEP #$20
.3a18c5	c2 10		rep #$10	            REP #$10
.3a18c7	5a		phy		            PHY
.3a18c8	a4 21		ldy $0821	            LDY OPERATORSP
.3a18ca	99 00 00	sta $0000,y	            STA #0,B,Y
.3a18cd	88		dey		            DEY
.3a18ce	84 21		sty $0821	            STY OPERATORSP
.3a18d0	7a		ply		done        PLY
.3a18d1	ab		plb		            PLB
.3a18d2	2b		pld		            PLD
.3a18d3	28		plp		            PLP
.3a18d4	60		rts		            RTS
.3a18d5					PLOPERATOR
.3a18d5	08		php		            PHP
.3a18d6	0b		phd		            PHD
.3a18d7	8b		phb		            PHB
.3a18d8	08		php		            PHP
.3a18d9	c2 20		rep #$20	            REP #$20
.3a18db	48		pha		            PHA
.3a18dc	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a18df	5b		tcd		            TCD
.3a18e0	68		pla		            PLA
.3a18e1	28		plp		            PLP
.3a18e2	08		php		            PHP
.3a18e3	e2 20		sep #$20	            SEP #$20
.3a18e5	48		pha		            PHA
.3a18e6	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a18e8	48		pha		            PHA
.3a18e9	ab		plb		            PLB
.3a18ea	68		pla		            PLA
.3a18eb	28		plp		            PLP
.3a18ec	e2 20		sep #$20	            SEP #$20
.3a18ee	c2 10		rep #$10	            REP #$10
.3a18f0	5a		phy		            PHY
.3a18f1	a4 21		ldy $0821	            LDY OPERATORSP
.3a18f3	c8		iny		            INY
.3a18f4	84 21		sty $0821	            STY OPERATORSP
.3a18f6	b9 00 00	lda $0000,y	            LDA #0,B,Y
.3a18f9	c2 20		rep #$20	            REP #$20
.3a18fb	29 ff 00	and #$00ff	            AND #$00FF
.3a18fe	7a		ply		            PLY
.3a18ff	ab		plb		            PLB
.3a1900	2b		pld		            PLD
.3a1901	28		plp		            PLP
.3a1902	60		rts		            RTS
.3a1903					OPENPARAMS
.3a1903	08		php		            PHP
.3a1904	e2 20		sep #$20	            SEP #$20
.3a1906	a9 01		lda #$01	            LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.3a1908	20 ac 18	jsr $3a18ac	            JSR PHOPERATOR
.3a190b	28		plp		            PLP
.3a190c	60		rts		            RTS
.3a190d					CLOSEPARAMS
.3a190d	5a		phy		            PHY
.3a190e	08		php		            PHP
.3a190f	8b		phb		            PHB
.3a1910	08		php		            PHP
.3a1911	e2 20		sep #$20	            SEP #$20
.3a1913	48		pha		            PHA
.3a1914	a9 00		lda #$00	            LDA #0
.3a1916	48		pha		            PHA
.3a1917	ab		plb		            PLB
.3a1918	68		pla		            PLA
.3a1919	28		plp		            PLP
.3a191a	e2 20		sep #$20	            SEP #$20
.3a191c	a4 21		ldy $0821	            LDY OPERATORSP      ; Peek at the top operator
.3a191e	b9 01 00	lda $0001,y	            LDA #1,B,Y
.3a1921	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the marker for the start of a parameter list
.3a1923	d0 08		bne $3a192d	            BNE error           ; No: there's a problem
.3a1925	c2 20		rep #$20	            REP #$20
.3a1927	e6 21		inc $0821	            INC OPERATORSP      ; Yes: remove it from the operator stack.
.3a1929	ab		plb		            PLB
.3a192a	28		plp		            PLP
.3a192b	7a		ply		            PLY
.3a192c	60		rts		            RTS
.3a192d					error
.3a192d	08		php		            PHP
.3a192e	c2 20		rep #$20	            REP #$20
.3a1930	48		pha		            PHA
.3a1931	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1934	5b		tcd		            TCD
.3a1935	68		pla		            PLA
.3a1936	28		plp		            PLP
.3a1937	e2 20		sep #$20	            SEP #$20
.3a1939	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a193b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a193f	c2 20		rep #$20	            REP #$20
.3a1941	29 ff 00	and #$00ff	            AND #$00FF
.3a1944	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a1947	e2 20		sep #$20	            SEP #$20
.3a1949	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a194c					OPHIGHPREC
.3a194c	48		pha		            PHA
.3a194d	08		php		            PHP
.3a194e	0b		phd		            PHD
.3a194f	8b		phb		            PHB
.3a1950	08		php		            PHP
.3a1951	c2 20		rep #$20	            REP #$20
.3a1953	48		pha		            PHA
.3a1954	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1957	5b		tcd		            TCD
.3a1958	68		pla		            PLA
.3a1959	28		plp		            PLP
.3a195a	08		php		            PHP
.3a195b	e2 20		sep #$20	            SEP #$20
.3a195d	48		pha		            PHA
.3a195e	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a1960	48		pha		            PHA
.3a1961	ab		plb		            PLB
.3a1962	68		pla		            PLA
.3a1963	28		plp		            PLP
.3a1964	e2 20		sep #$20	            SEP #$20
.3a1966	a4 21		ldy $0821	            LDY OPERATORSP
.3a1968	c0 ff 7f	cpy #$7fff	            CPY #OPERATOR_TOP       ; Is the stack empty?
.3a196b	f0 11		beq $3a197e	            BEQ is_false            ; Yes: return false
.3a196d	20 0f 0b	jsr $3a0b0f	            JSR TOKPRECED
.3a1970	85 0c		sta $080c	            STA SCRATCH             ; Save it for later comparison
.3a1972	b9 01 00	lda $0001,y	            LDA #1,B,Y              ; Get the operator at the top of the stack
.3a1975	20 0f 0b	jsr $3a0b0f	            JSR TOKPRECED
.3a1978	c5 0c		cmp $080c	            CMP SCRATCH             ; Compare the priorities (0 = highest priority)
.3a197a	f0 02		beq $3a197e	            BEQ is_false            ; A = SCRATCH, return false
.3a197c	90 08		bcc $3a1986	            BCC is_true             ; A < SCRATCH (A is higher priority), return false
.3a197e					is_false
.3a197e	c2 20		rep #$20	            REP #$20
.3a1980	ab		plb		            PLB
.3a1981	2b		pld		            PLD
.3a1982	28		plp		            PLP
.3a1983	68		pla		            PLA
.3a1984	18		clc		            CLC
.3a1985	60		rts		            RTS
.3a1986					is_true
.3a1986	c2 20		rep #$20	            REP #$20
.3a1988	ab		plb		            PLB                     ; A > SCRATCH (A is lower priority), return true
.3a1989	2b		pld		            PLD
.3a198a	28		plp		            PLP
.3a198b	68		pla		            PLA
.3a198c	38		sec		            SEC
.3a198d	60		rts		            RTS
.3a198e					EVALNUMBER
.3a198e	4c 8a 07	jmp $3a078a	            JMP PARSEINT
.3a1991					ARR_GETIDX
.3a1991	08		php		            PHP
.3a1992	e2 20		sep #$20	            SEP #$20
.3a1994	a9 00		lda #$00	            LDA #0
.3a1996	8f 00 4d 00	sta $004d00	            STA @lARRIDXBUF     ; Set the dimension to 0
.3a199a	a2 01 00	ldx #$0001	            LDX #1
.3a199d					eval_index
.3a199d	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a19a0	20 bf 05	jsr $3a05bf	            JSR ASS_ARG1_INT16
.3a19a3	c2 20		rep #$20	            REP #$20
.3a19a5	a5 23		lda $0823	            LDA ARGUMENT1       ; Save the index to the array index buffer
.3a19a7	9f 00 4d 00	sta $004d00,x	            STA @lARRIDXBUF,X
.3a19ab	e2 20		sep #$20	            SEP #$20
.3a19ad	af 00 4d 00	lda $004d00	            LDA @lARRIDXBUF     ; Increment the index count
.3a19b1	1a		inc a		            INC A
.3a19b2	30 3e		bmi $3a19f2	            BMI arg_err         ; If more than 127 dimensions, throw a range error
.3a19b4	8f 00 4d 00	sta $004d00	            STA @lARRIDXBUF
.3a19b8	e8		inx		            INX
.3a19b9	e8		inx		            INX
.3a19ba	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a19bd	e2 20		sep #$20	            SEP #$20
.3a19bf	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.3a19c1	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it ")"
.3a19c3	f0 09		beq $3a19ce	            BEQ clean_op        ; Yes: cleanup the argument stack
.3a19c5	c9 2c		cmp #$2c	            CMP #','            ; Is it a comma?
.3a19c7	d0 0a		bne $3a19d3	            BNE syntax_err      ; No: throw a syntax error
.3a19c9					skip_comma
.3a19c9	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a19cc	80 cf		bra $3a199d	            BRA eval_index      ; And grab the next index
.3a19ce					clean_op
.3a19ce	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a19d1	28		plp		            PLP
.3a19d2	60		rts		            RTS
.3a19d3					syntax_err
.3a19d3	08		php		            PHP
.3a19d4	c2 20		rep #$20	            REP #$20
.3a19d6	48		pha		            PHA
.3a19d7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a19da	5b		tcd		            TCD
.3a19db	68		pla		            PLA
.3a19dc	28		plp		            PLP
.3a19dd	e2 20		sep #$20	            SEP #$20
.3a19df	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a19e1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a19e5	c2 20		rep #$20	            REP #$20
.3a19e7	29 ff 00	and #$00ff	            AND #$00FF
.3a19ea	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a19ed	e2 20		sep #$20	            SEP #$20
.3a19ef	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a19f2					arg_err
.3a19f2	08		php		            PHP
.3a19f3	c2 20		rep #$20	            REP #$20
.3a19f5	48		pha		            PHA
.3a19f6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a19f9	5b		tcd		            TCD
.3a19fa	68		pla		            PLA
.3a19fb	28		plp		            PLP
.3a19fc	e2 20		sep #$20	            SEP #$20
.3a19fe	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a1a00	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1a04	c2 20		rep #$20	            REP #$20
.3a1a06	29 ff 00	and #$00ff	            AND #$00FF
.3a1a09	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a1a0c	e2 20		sep #$20	            SEP #$20
.3a1a0e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1a11					EVALREF
.3a1a11	08		php		            PHP
.3a1a12					get_name
.3a1a12	20 68 51	jsr $3a5168	            JSR VAR_FINDNAME
.3a1a15	90 23		bcc $3a1a3a	            BCC syntax_err      ; If we didn't find a name, thrown an error
.3a1a17	e2 20		sep #$20	            SEP #$20
.3a1a19	a5 ea		lda $08ea	            LDA TOFINDTYPE      ; Check the type of the variable
.3a1a1b	29 80		and #$80	            AND #$80            ; Is it an array?
.3a1a1d	d0 06		bne $3a1a25	            BNE is_array        ; Yes: look for the indexes
.3a1a1f	20 69 4f	jsr $3a4f69	            JSR VAR_REF
.3a1a22	4c 38 1a	jmp $3a1a38	            JMP done
.3a1a25					is_array
.3a1a25	e2 20		sep #$20	            SEP #$20
.3a1a27	a9 8f		lda #$8f	            LDA #TOK_LPAREN
.3a1a29	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a1a2c	20 03 19	jsr $3a1903	            JSR OPENPARAMS
.3a1a2f					            PHARRIDX
.3a1a2f	20 91 19	jsr $3a1991	            JSR ARR_GETIDX
.3a1a32	20 1f 66	jsr $3a661f	            JSR ARR_REF
.3a1a35					            PLARRIDX
.3a1a35	20 0d 19	jsr $3a190d	            JSR CLOSEPARAMS
.3a1a38	28		plp		done        PLP
.3a1a39	60		rts		            RTS
.3a1a3a					syntax_err
.3a1a3a	08		php		            PHP
.3a1a3b	c2 20		rep #$20	            REP #$20
.3a1a3d	48		pha		            PHA
.3a1a3e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1a41	5b		tcd		            TCD
.3a1a42	68		pla		            PLA
.3a1a43	28		plp		            PLP
.3a1a44	e2 20		sep #$20	            SEP #$20
.3a1a46	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a1a48	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1a4c	c2 20		rep #$20	            REP #$20
.3a1a4e	29 ff 00	and #$00ff	            AND #$00FF
.3a1a51	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a1a54	e2 20		sep #$20	            SEP #$20
.3a1a56	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1a59					EVALSTRING
.3a1a59	08		php		            PHP
.3a1a5a	0b		phd		            PHD
.3a1a5b	08		php		            PHP
.3a1a5c	c2 20		rep #$20	            REP #$20
.3a1a5e	48		pha		            PHA
.3a1a5f	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1a62	5b		tcd		            TCD
.3a1a63	68		pla		            PLA
.3a1a64	28		plp		            PLP
.3a1a65	e2 20		sep #$20	            SEP #$20
.3a1a67	c2 10		rep #$10	            REP #$10
.3a1a69	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a1a6c	a0 00 00	ldy #$0000	            LDY #0              ; Ywill be our length counter
.3a1a6f	b7 00		lda [$0800],y	count_loop  LDA [BIP],Y         ; Get the character
.3a1a71	f0 24		beq $3a1a97	            BEQ error           ; If it's end-of-line, throw an error
.3a1a73	c9 22		cmp #$22	            CMP #CHAR_DQUOTE    ; Is it the ending double-quote?
.3a1a75	f0 03		beq $3a1a7a	            BEQ found_end       ; Yes: Y should be the length
.3a1a77	c8		iny		            INY
.3a1a78	80 f5		bra $3a1a6f	            BRA count_loop
.3a1a7a	84 0c		sty $080c	found_end   STY SCRATCH         ; Save the length to SCRATCH
.3a1a7c	e2 20		sep #$20	            SEP #$20
.3a1a7e	a9 02		lda #$02	            LDA #TYPE_STRING    ; Set the type to allocate to STRING
.3a1a80	a6 0c		ldx $080c	            LDX SCRATCH         ; And the length to the length of the string literal
.3a1a82	e8		inx		            INX
.3a1a83	20 ae 13	jsr $3a13ae	            JSR TEMPSTRING
.3a1a86	a0 00 00	ldy #$0000	            LDY #0
.3a1a89	c4 0c		cpy $080c	copy_loop   CPY SCRATCH         ; Have we copied all the characters?
.3a1a8b	f0 29		beq $3a1ab6	            BEQ done            ; Yes: we're done
.3a1a8d	a7 00		lda [$0800]	            LDA [BIP]           ; No: get the next character
.3a1a8f	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And copy it to the allocated string
.3a1a91	c8		iny		            INY
.3a1a92	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a1a95	80 f2		bra $3a1a89	            BRA copy_loop       ; And try the next character
.3a1a97					error
.3a1a97	08		php		            PHP
.3a1a98	c2 20		rep #$20	            REP #$20
.3a1a9a	48		pha		            PHA
.3a1a9b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1a9e	5b		tcd		            TCD
.3a1a9f	68		pla		            PLA
.3a1aa0	28		plp		            PLP
.3a1aa1	e2 20		sep #$20	            SEP #$20
.3a1aa3	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a1aa5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1aa9	c2 20		rep #$20	            REP #$20
.3a1aab	29 ff 00	and #$00ff	            AND #$00FF
.3a1aae	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a1ab1	e2 20		sep #$20	            SEP #$20
.3a1ab3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1ab6	a9 00		lda #$00	done        LDA #0
.3a1ab8	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a1aba	c2 20		rep #$20	            REP #$20
.3a1abc	a5 16		lda $0816	            LDA STRPTR
.3a1abe	85 23		sta $0823	            STA ARGUMENT1
.3a1ac0	a5 18		lda $0818	            LDA STRPTR+2
.3a1ac2	85 25		sta $0825	            STA ARGUMENT1+2
.3a1ac4	a9 02 00	lda #$0002	            LDA #TYPE_STRING    ; And set the type of ARGUMENT1 to string
.3a1ac7	85 27		sta $0827	            STA ARGTYPE1
.3a1ac9	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a1acc	2b		pld		            PLD
.3a1acd	28		plp		            PLP
.3a1ace	60		rts		            RTS
.3a1acf					EVAL_FUNC
.3a1acf	08		php		            PHP
.3a1ad0	e2 20		sep #$20	            SEP #$20
.3a1ad2	a7 00		lda [$0800]	            LDA [BIP]           ; Get the token
.3a1ad4	c2 20		rep #$20	            REP #$20
.3a1ad6	29 ff 00	and #$00ff	            AND #$00FF
.3a1ad9	20 39 0b	jsr $3a0b39	            JSR TOKEVAL
.3a1adc	85 2f		sta $082f	            STA JMP16PTR
.3a1ade	20 03 19	jsr $3a1903	            JSR OPENPARAMS
.3a1ae1	08		php		            PHP
.3a1ae2	e2 20		sep #$20	            SEP #$20
.3a1ae4	48		pha		            PHA
.3a1ae5	a9 00		lda #$00	            LDA #0
.3a1ae7	48		pha		            PHA
.3a1ae8	ab		plb		            PLB
.3a1ae9	68		pla		            PLA
.3a1aea	28		plp		            PLP
.3a1aeb	20 f3 1a	jsr $3a1af3	            JSR OPSTUB
.3a1aee	20 0d 19	jsr $3a190d	            JSR CLOSEPARAMS
.3a1af1	28		plp		            PLP
.3a1af2	60		rts		            RTS
.3a1af3					OPSTUB
.3a1af3	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a1af6	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.3a1af9					PROCESSOP
.3a1af9	48		pha		            PHA
.3a1afa	08		php		            PHP
.3a1afb	0b		phd		            PHD
.3a1afc	8b		phb		            PHB
.3a1afd	08		php		            PHP
.3a1afe	c2 20		rep #$20	            REP #$20
.3a1b00	48		pha		            PHA
.3a1b01	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1b04	5b		tcd		            TCD
.3a1b05	68		pla		            PLA
.3a1b06	28		plp		            PLP
.3a1b07	c2 30		rep #$30	            REP #$30
.3a1b09	20 d5 18	jsr $3a18d5	            JSR PLOPERATOR
.3a1b0c	89 80 00	bit #$0080	            BIT #$80            ; Check if it's really a token
.3a1b0f	f0 37		beq $3a1b48	            BEQ bad_token       ; No: it's a bad token
.3a1b11	48		pha		            PHA
.3a1b12	20 39 0b	jsr $3a0b39	            JSR TOKEVAL
.3a1b15	85 2f		sta $082f	            STA JMP16PTR
.3a1b17	68		pla		            PLA
.3a1b18	20 86 0b	jsr $3a0b86	            JSR TOKARITY
.3a1b1b	c9 01 00	cmp #$0001	            CMP #1              ; Check the operator's arity
.3a1b1e	f0 08		beq $3a1b28	            BEQ pull_arg1       ; If it's 1 just pull one argument from the stack
.3a1b20	c2 30		rep #$30	            REP #$30
.3a1b22	a2 29 08	ldx #$0829	            LDX #<>ARGUMENT2    ; Pull argument 2 from the stack
.3a1b25	20 6d 18	jsr $3a186d	            JSR PLARGUMENT
.3a1b28					pull_arg1
.3a1b28	c2 30		rep #$30	            REP #$30
.3a1b2a	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Pull argument 1 from the stack
.3a1b2d	20 6d 18	jsr $3a186d	            JSR PLARGUMENT
.3a1b30	08		php		            PHP
.3a1b31	e2 20		sep #$20	            SEP #$20
.3a1b33	48		pha		            PHA
.3a1b34	a9 00		lda #$00	            LDA #0
.3a1b36	48		pha		            PHA
.3a1b37	ab		plb		            PLB
.3a1b38	68		pla		            PLA
.3a1b39	28		plp		            PLP
.3a1b3a	20 4a 1b	jsr $3a1b4a	            JSR OPSTUB
.3a1b3d	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Get return result in argument 1
.3a1b40	20 2f 18	jsr $3a182f	            JSR PHARGUMENT
.3a1b43	ab		plb		            PLB
.3a1b44	2b		pld		            PLD
.3a1b45	28		plp		            PLP
.3a1b46	68		pla		            PLA
.3a1b47	60		rts		            RTS
.3a1b48	00		brk #		bad_token   BRK
.3a1b49	ea		nop		            NOP
.3a1b4a	6c 2f 08	jmp ($082f)	OPSTUB      JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.3a1b4d					EVALEXPR
.3a1b4d	08		php		            PHP
.3a1b4e	08		php		            PHP
.3a1b4f	c2 20		rep #$20	            REP #$20
.3a1b51	48		pha		            PHA
.3a1b52	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1b55	5b		tcd		            TCD
.3a1b56	68		pla		            PLA
.3a1b57	28		plp		            PLP
.3a1b58	08		php		            PHP
.3a1b59	e2 20		sep #$20	            SEP #$20
.3a1b5b	48		pha		            PHA
.3a1b5c	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a1b5e	48		pha		            PHA
.3a1b5f	ab		plb		            PLB
.3a1b60	68		pla		            PLA
.3a1b61	28		plp		            PLP
.3a1b62	c2 10		rep #$10	            REP #$10
.3a1b64	da		phx		            PHX
.3a1b65					get_char
.3a1b65	e2 20		sep #$20	            SEP #$20
.3a1b67	a7 00		lda [$0800]	            LDA [BIP]           ; Get the character
.3a1b69	d0 03		bne $3a1b6e	            BNE else1
.3a1b6b	4c 10 1c	jmp $3a1c10	            JMP proc_stack      ; Handle end of line, if we see it
.3a1b6e	30 33		bmi $3a1ba3	else1       BMI is_token        ; If MSB is set, it's a token
.3a1b70	c9 20		cmp #$20	            CMP #' '            ; Is it a space?
.3a1b72	d0 03		bne $3a1b77	            BNE else2
.3a1b74	4c 0a 1c	jmp $3a1c0a	            JMP next_char       ; Yes: Skip to the next character
.3a1b77	c9 3a		cmp #$3a	else2       CMP #'9'+1          ; Check to see if we have digits
.3a1b79	b0 04		bcs $3a1b7f	            BCS else3           ; No: treat as the end of the line
.3a1b7b	c9 30		cmp #$30	            CMP #'0'
.3a1b7d	b0 56		bcs $3a1bd5	            BCS is_digit
.3a1b7f	c9 26		cmp #$26	else3       CMP #'&'            ; Check for a hexadecimal prefix
.3a1b81	f0 52		beq $3a1bd5	            BEQ is_digit
.3a1b83	c9 22		cmp #$22	            CMP #'"'            ; Is it a double-quote?
.3a1b85	d0 03		bne $3a1b8a	            BNE else4
.3a1b87	4c 23 1c	jmp $3a1c23	            JMP is_string       ; Yes: process the string
.3a1b8a	c9 5b		cmp #$5b	else4       CMP #'Z'+1          ; Check to see if we have upper case alphabetics
.3a1b8c	b0 07		bcs $3a1b95	            BCS check_lc        ; No: check for lower case
.3a1b8e	c9 41		cmp #$41	            CMP #'A'
.3a1b90	90 03		bcc $3a1b95	            BCC check_lc
.3a1b92	4c 2f 1c	jmp $3a1c2f	            JMP is_alpha
.3a1b95	c9 7b		cmp #$7b	check_lc    CMP #'z'+1          ; Check to see if we have lower case alphabetics
.3a1b97	b0 07		bcs $3a1ba0	            BCS else5           ; No: treat as the end of the line
.3a1b99	c9 61		cmp #$61	            CMP #'a'
.3a1b9b	90 03		bcc $3a1ba0	            BCC else5
.3a1b9d	4c 2f 1c	jmp $3a1c2f	            JMP is_alpha
.3a1ba0	4c 10 1c	jmp $3a1c10	else5       JMP proc_stack
.3a1ba3	c9 8f		cmp #$8f	is_token    CMP #TOK_LPAREN     ; Is it an LPAREN
.3a1ba5	f0 40		beq $3a1be7	            BEQ is_lparen       ; Yes: handle the LPAREN
.3a1ba7	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it an RPAREN?
.3a1ba9	f0 41		beq $3a1bec	            BEQ is_rparen       ; Yes: handle the RPAREN
.3a1bab	20 5c 0b	jsr $3a0b5c	            JSR TOKTYPE
.3a1bae	c9 30		cmp #$30	            CMP #TOK_TY_FUNC    ; Is it a function?
.3a1bb0	d0 0c		bne $3a1bbe	            BNE chk_op          ; No: check if it's an operator
.3a1bb2	20 cf 1a	jsr $3a1acf	            JSR EVAL_FUNC
.3a1bb5	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.3a1bb8	20 2f 18	jsr $3a182f	            JSR PHARGUMENT
.3a1bbb	4c 65 1b	jmp $3a1b65	            JMP get_char
.3a1bbe	c9 00		cmp #$00	chk_op      CMP #TOK_TY_OP      ; Is it an operator?
.3a1bc0	d0 4e		bne $3a1c10	            BNE proc_stack      ; No: we're finished processing
.3a1bc2	a7 00		lda [$0800]	            LDA [BIP]           ; Yes: Get the token back
.3a1bc4	a6 21		ldx $0821	chk_prec    LDX OPERATORSP      ; Is the operator stack empty?
.3a1bc6	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.3a1bc9	f0 05		beq $3a1bd0	            BEQ push_op         ; Yes: push the operator
.3a1bcb	20 4c 19	jsr $3a194c	            JSR OPHIGHPREC
.3a1bce	b0 12		bcs $3a1be2	            BCS process1        ; No: we should process the top operator
.3a1bd0					push_op
.3a1bd0	20 ac 18	jsr $3a18ac	            JSR PHOPERATOR
.3a1bd3	80 35		bra $3a1c0a	            BRA next_char       ; And go to the next character
.3a1bd5					is_digit
.3a1bd5	c2 20		rep #$20	            REP #$20
.3a1bd7	20 8a 57	jsr $3a578a	            JSR PARSENUM
.3a1bda	a2 23 08	ldx #$0823	got_number  LDX #<>ARGUMENT1
.3a1bdd	20 2f 18	jsr $3a182f	            JSR PHARGUMENT
.3a1be0	80 83		bra $3a1b65	            BRA get_char
.3a1be2					process1
.3a1be2	20 f9 1a	jsr $3a1af9	            JSR PROCESSOP
.3a1be5	80 dd		bra $3a1bc4	            BRA chk_prec        ; And check what to do with the current operator
.3a1be7					is_lparen
.3a1be7	20 ac 18	jsr $3a18ac	            JSR PHOPERATOR
.3a1bea	80 1e		bra $3a1c0a	            BRA next_char
.3a1bec					is_rparen
.3a1bec	e2 20		sep #$20	            SEP #$20
.3a1bee	a4 21		ldy $0821	            LDY OPERATORSP      ; Is the operator stack empty?
.3a1bf0	c0 ff 7f	cpy #$7fff	            CPY #<>OPERATOR_TOP
.3a1bf3	f0 46		beq $3a1c3b	            BEQ done            ; Yes: we're done evaluating things
.3a1bf5	a4 21		ldy $0821	paren_loop  LDY OPERATORSP      ; Peek at the top operator
.3a1bf7	b9 01 00	lda $0001,y	            LDA #1,B,Y
.3a1bfa	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the LPAREN of a function?
.3a1bfc	f0 3d		beq $3a1c3b	            BEQ done            ; Yes: treat it as an empty stack
.3a1bfe	c9 8f		cmp #$8f	            CMP #TOK_LPAREN     ; Is it an LPAREN?
.3a1c00	f0 05		beq $3a1c07	            BEQ done_rparen     ; Yes: we're finished processing
.3a1c02	20 f9 1a	jsr $3a1af9	            JSR PROCESSOP
.3a1c05	80 ee		bra $3a1bf5	            BRA paren_loop
.3a1c07					done_rparen
.3a1c07	20 d5 18	jsr $3a18d5	            JSR PLOPERATOR
.3a1c0a					next_char
.3a1c0a	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a1c0d	4c 65 1b	jmp $3a1b65	            JMP get_char
.3a1c10					proc_stack
.3a1c10	a6 21		ldx $0821	            LDX OPERATORSP      ; Is the operator stack empty?
.3a1c12	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.3a1c15	b0 24		bcs $3a1c3b	            BGE done            ; Yes: return to the caller
.3a1c17	bd 01 00	lda $0001,x	            LDA #1,B,X
.3a1c1a	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is top operator a function open?
.3a1c1c	f0 1d		beq $3a1c3b	            BEQ done            ; Yes: treat as end of expression
.3a1c1e	20 f9 1a	jsr $3a1af9	            JSR PROCESSOP
.3a1c21	80 ed		bra $3a1c10	            BRA proc_stack
.3a1c23					is_string
.3a1c23	20 59 1a	jsr $3a1a59	            JSR EVALSTRING
.3a1c26	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.3a1c29	20 2f 18	jsr $3a182f	            JSR PHARGUMENT
.3a1c2c	4c 65 1b	jmp $3a1b65	            JMP get_char
.3a1c2f					is_alpha
.3a1c2f	20 11 1a	jsr $3a1a11	            JSR EVALREF
.3a1c32	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.3a1c35	20 2f 18	jsr $3a182f	            JSR PHARGUMENT
.3a1c38	4c 65 1b	jmp $3a1b65	            JMP get_char
.3a1c3b	a2 23 08	ldx #$0823	done        LDX #<>ARGUMENT1    ; Make sure the result is off the stack
.3a1c3e	20 6d 18	jsr $3a186d	            JSR PLARGUMENT
.3a1c41	fa		plx		            PLX
.3a1c42	28		plp		            PLP
.3a1c43	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\returnstack.s

.3a1c44					INITRETURN
.3a1c44	08		php		                PHP
.3a1c45	0b		phd		                PHD
.3a1c46	8b		phb		                PHB
.3a1c47	08		php		            PHP
.3a1c48	e2 20		sep #$20	            SEP #$20
.3a1c4a	48		pha		            PHA
.3a1c4b	a9 00		lda #$00	            LDA #0
.3a1c4d	48		pha		            PHA
.3a1c4e	ab		plb		            PLB
.3a1c4f	68		pla		            PLA
.3a1c50	28		plp		            PLP
.3a1c51	08		php		            PHP
.3a1c52	c2 20		rep #$20	            REP #$20
.3a1c54	48		pha		            PHA
.3a1c55	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1c58	5b		tcd		            TCD
.3a1c59	68		pla		            PLA
.3a1c5a	28		plp		            PLP
.3a1c5b	c2 30		rep #$30	            REP #$30
.3a1c5d	a9 fd 5f	lda #$5ffd	                LDA #RETURN_TOP-2
.3a1c60	85 33		sta $0833	                STA RETURNSP
.3a1c62	ab		plb		                PLB
.3a1c63	2b		pld		                PLD
.3a1c64	28		plp		                PLP
.3a1c65	60		rts		            RTS
.3a1c66					PHRETURN
.3a1c66	08		php		                PHP
.3a1c67	0b		phd		                PHD
.3a1c68	08		php		            PHP
.3a1c69	c2 20		rep #$20	            REP #$20
.3a1c6b	48		pha		            PHA
.3a1c6c	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1c6f	5b		tcd		            TCD
.3a1c70	68		pla		            PLA
.3a1c71	28		plp		            PLP
.3a1c72	c2 30		rep #$30	            REP #$30
.3a1c74	92 33		sta ($0833)	                STA (RETURNSP)
.3a1c76	c6 33		dec $0833	                DEC RETURNSP
.3a1c78	c6 33		dec $0833	                DEC RETURNSP
.3a1c7a	2b		pld		                PLD
.3a1c7b	28		plp		                PLP
.3a1c7c	60		rts		            RTS
.3a1c7d					PHRETURNB
.3a1c7d	08		php		                PHP
.3a1c7e	c2 30		rep #$30	            REP #$30
.3a1c80	29 ff 00	and #$00ff	                AND #$00FF
.3a1c83	20 66 1c	jsr $3a1c66	            JSR PHRETURN
.3a1c86	28		plp		                PLP
.3a1c87	60		rts		            RTS
.3a1c88					PLRETURN
.3a1c88	08		php		                PHP
.3a1c89	0b		phd		                PHD
.3a1c8a	08		php		            PHP
.3a1c8b	c2 20		rep #$20	            REP #$20
.3a1c8d	48		pha		            PHA
.3a1c8e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1c91	5b		tcd		            TCD
.3a1c92	68		pla		            PLA
.3a1c93	28		plp		            PLP
.3a1c94	c2 30		rep #$30	            REP #$30
.3a1c96	e6 33		inc $0833	                INC RETURNSP
.3a1c98	e6 33		inc $0833	                INC RETURNSP
.3a1c9a	b2 33		lda ($0833)	                LDA (RETURNSP)
.3a1c9c	2b		pld		                PLD
.3a1c9d	28		plp		                PLP
.3a1c9e	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\interpreter.s

=$80					ST_RUNNING = $80            ; The interpreter is running a full program
=$00					ST_INTERACT = $00           ; The interpreter is in interactive mode
>08d2					STATE       .byte ?         ; The state of the interpreter ()
>08d3					ERROR_NUM   .byte ?         ; The type of the error
>08d4					HANDLEERR   .long ?         ; Pointer to the error handler
>08d7					LINENUM     .word ?         ; The current line number
>08d9					LASTLINE    .long ?         ; Pointer to the next free space over the BASIC program
>08dc					EXECACTION  .byte ?         ; The action the exection routines should take to get their next statement
=0					LINE_LINK = 0               ; Offset to the link to the next line
=2					LINE_NUMBER = 2             ; Offset to the line number
=4					LINE_TOKENS = 4             ; Offset to the first token
=6					LINE_MINLEN = 6             ; Minimum length of a line
=0					EXEC_CONT = 0               ; Continue advancing the current line
=1					EXEC_STOP = 1               ; Stop execution of the program
=2					EXEC_GOTO = 2               ; Transfer execution to a new CURLINE that is already set
=3					EXEC_RETURN = 3             ; Transfer execution back to a line that was on the stack
.3a1c9f					SET_ERRERL
.3a1c9f	8b		phb		                PHB
.3a1ca0	0b		phd		                PHD
.3a1ca1	08		php		                PHP
.3a1ca2	08		php		            PHP
.3a1ca3	c2 20		rep #$20	            REP #$20
.3a1ca5	48		pha		            PHA
.3a1ca6	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1ca9	5b		tcd		            TCD
.3a1caa	68		pla		            PLA
.3a1cab	28		plp		            PLP
.3a1cac	08		php		            PHP
.3a1cad	e2 20		sep #$20	            SEP #$20
.3a1caf	48		pha		            PHA
.3a1cb0	a9 00		lda #$00	            LDA #BASIC_BANK
.3a1cb2	48		pha		            PHA
.3a1cb3	ab		plb		            PLB
.3a1cb4	68		pla		            PLA
.3a1cb5	28		plp		            PLP
.3a1cb6	c2 20		rep #$20	            REP #$20
.3a1cb8	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.3a1cba	a9 00 00	lda #$0000	                LDA #0
.3a1cbd	85 25		sta $0825	                STA ARGUMENT1+2
.3a1cbf	e2 20		sep #$20	            SEP #$20
.3a1cc1	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a1cc3	85 27		sta $0827	                STA ARGTYPE1
.3a1cc5	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.3a1cc7	a9 3a		lda #$3a	                LDA #`err_name
.3a1cc9	85 e9		sta $08e9	                STA TOFIND+2
.3a1ccb	c2 20		rep #$20	            REP #$20
.3a1ccd	a9 f9 1c	lda #$1cf9	                LDA #<>err_name
.3a1cd0	85 e7		sta $08e7	                STA TOFIND
.3a1cd2	20 cb 50	jsr $3a50cb	            JSR VAR_SET
.3a1cd5	c2 20		rep #$20	            REP #$20
.3a1cd7	a5 d7		lda $08d7	                LDA LINENUM
.3a1cd9	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.3a1cdb	a5 d9		lda $08d9	                LDA LINENUM+2
.3a1cdd	85 25		sta $0825	                STA ARGUMENT1+2
.3a1cdf	e2 20		sep #$20	            SEP #$20
.3a1ce1	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a1ce3	85 27		sta $0827	                STA ARGTYPE1
.3a1ce5	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.3a1ce7	a9 3a		lda #$3a	                LDA #`erl_name
.3a1ce9	85 e9		sta $08e9	                STA TOFIND+2
.3a1ceb	c2 20		rep #$20	            REP #$20
.3a1ced	a9 fd 1c	lda #$1cfd	                LDA #<>erl_name
.3a1cf0	85 e7		sta $08e7	                STA TOFIND
.3a1cf2	20 cb 50	jsr $3a50cb	            JSR VAR_SET
.3a1cf5	28		plp		                PLP
.3a1cf6	2b		pld		                PLD
.3a1cf7	ab		plb		                PLB
.3a1cf8	60		rts		            RTS
>3a1cf9	45 52 52 00			err_name        .null "ERR"
>3a1cfd	45 52 4c 00			erl_name        .null "ERL"
.3a1d01					ON_ERROR
.3a1d01	e2 20		sep #$20	            SEP #$20
.3a1d03	c2 10		rep #$10	            REP #$10
.3a1d05	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a1d08	af d3 08 00	lda $0008d3	            LDA @lERROR_NUM         ; Calculate index to the error message pointer
.3a1d0c	0a		asl a		            ASL A
.3a1d0d	c2 20		rep #$20	            REP #$20
.3a1d0f	29 ff 00	and #$00ff	            AND #$00FF
.3a1d12	a8		tay		            TAY
.3a1d13	08		php		            PHP
.3a1d14	e2 20		sep #$20	            SEP #$20
.3a1d16	48		pha		            PHA
.3a1d17	a9 3a		lda #$3a	            LDA #`ERRORMSG
.3a1d19	48		pha		            PHA
.3a1d1a	ab		plb		            PLB
.3a1d1b	68		pla		            PLA
.3a1d1c	28		plp		            PLP
.3a1d1d	be 53 1d	ldx $3a1d53,y	            LDX ERRORMSG,Y
.3a1d20	20 16 03	jsr $3a0316	            JSR PRINTS
.3a1d23	c2 20		rep #$20	            REP #$20
.3a1d25	a5 d7		lda $08d7	            LDA LINENUM
.3a1d27	f0 27		beq $3a1d50	            BEQ skip_at
.3a1d29	a2 83 1d	ldx #$1d83	            LDX #<>MSG_AT           ; If so... print " AT "
.3a1d2c	20 16 03	jsr $3a0316	            JSR PRINTS
.3a1d2f	08		php		            PHP
.3a1d30	e2 20		sep #$20	            SEP #$20
.3a1d32	48		pha		            PHA
.3a1d33	a9 00		lda #$00	            LDA #BASIC_BANK
.3a1d35	48		pha		            PHA
.3a1d36	ab		plb		            PLB
.3a1d37	68		pla		            PLA
.3a1d38	28		plp		            PLP
.3a1d39	c2 20		rep #$20	            REP #$20
.3a1d3b	af d7 08 00	lda $0008d7	            LDA @lLINENUM           ; ... and then the line number
.3a1d3f	8f 23 08 00	sta $000823	            STA @lARGUMENT1
.3a1d43	a9 00 00	lda #$0000	            LDA #0
.3a1d46	8f 25 08 00	sta $000825	            STA @lARGUMENT1+2
.3a1d4a	20 e2 43	jsr $3a43e2	            JSR PR_INTEGER
.3a1d4d	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a1d50					skip_at
.3a1d50	4c fe 25	jmp $3a25fe	            JMP INTERACT
>3a1d53	87 1d				ERRORMSG    .word <>MSG_OK
>3a1d55	8a 1d				            .word <>MSG_BREAK
>3a1d57	90 1d				            .word <>MSG_SYNTAX
>3a1d59	9d 1d				            .word <>MSG_MEMORY
>3a1d5b	ab 1d				            .word <>MSG_TYPE
>3a1d5d	b9 1d				            .word <>MSG_NOTFND
>3a1d5f	cc 1d				            .word <>MSG_NOLINE
>3a1d61	e2 1d				            .word <>MSG_UNDFLOW
>3a1d63	f2 1d				            .word <>MSG_OVRFLOW
>3a1d65	01 1e				            .word <>MSG_RANGE
>3a1d67	0e 1e				            .word <>MSG_ARG
>3a1d69	1f 1e				            .word <>MSG_NOFILE
>3a1d6b	2e 1e				            .word <>MSG_NAN
>3a1d6d	3b 1e				            .word <>MSG_OVERFLOW
>3a1d6f	49 1e				            .word <>MSG_UNDERFLOW
>3a1d71	58 1e				            .word <>MSG_DIV0
>3a1d73	69 1e				            .word <>MSG_DIRECTORY
>3a1d75	82 1e				            .word <>MSG_LOAD
>3a1d77	96 1e				            .word <>MSG_SAVE
>3a1d79	aa 1e				            .word <>MSG_DELETE
>3a1d7b	c0 1e				            .word <>MSG_FILENOTFND
>3a1d7d	d4 1e				            .word <>MSG_DIRNOTWRITE
>3a1d7f	ef 1e				            .word <>MSG_NOTCOPIED
>3a1d81	07 1f				            .word <>MSG_DOMAIN
>3a1d83	20 61 74 00			MSG_AT          .null " at"
>3a1d87	4f 4b 00			MSG_OK          .null "OK"
>3a1d8a	42 72 65 61 6b 00		MSG_BREAK       .null "Break"
>3a1d90	53 79 6e 74 61 78 20 65		MSG_SYNTAX      .null "Syntax error"
>3a1d98	72 72 6f 72 00
>3a1d9d	4f 75 74 20 6f 66 20 6d		MSG_MEMORY      .null "Out of memory"
>3a1da5	65 6d 6f 72 79 00
>3a1dab	54 79 70 65 20 6d 69 73		MSG_TYPE        .null "Type mismatch"
>3a1db3	6d 61 74 63 68 00
>3a1db9	56 61 72 69 61 62 6c 65		MSG_NOTFND      .null "Variable not found"
>3a1dc1	20 6e 6f 74 20 66 6f 75 6e 64 00
>3a1dcc	4c 69 6e 65 20 6e 75 6d		MSG_NOLINE      .null "Line number not found"
>3a1dd4	62 65 72 20 6e 6f 74 20 66 6f 75 6e 64 00
>3a1de2	53 74 61 63 6b 20 75 6e		MSG_UNDFLOW     .null "Stack underflow"
>3a1dea	64 65 72 66 6c 6f 77 00
>3a1df2	53 74 61 63 6b 20 6f 76		MSG_OVRFLOW     .null "Stack overflow"
>3a1dfa	65 72 66 6c 6f 77 00
>3a1e01	4f 75 74 20 6f 66 20 72		MSG_RANGE       .null "Out of range"
>3a1e09	61 6e 67 65 00
>3a1e0e	49 6c 6c 65 67 61 6c 20		MSG_ARG         .null "Illegal argument"
>3a1e16	61 72 67 75 6d 65 6e 74 00
>3a1e1f	46 69 6c 65 20 6e 6f 74		MSG_NOFILE      .null "File not found"
>3a1e27	20 66 6f 75 6e 64 00
>3a1e2e	4e 6f 74 20 61 20 6e 75		MSG_NAN         .null "Not a number"
>3a1e36	6d 62 65 72 00
>3a1e3b	4d 61 74 68 20 6f 76 65		MSG_OVERFLOW    .null "Math overflow"
>3a1e43	72 66 6c 6f 77 00
>3a1e49	4d 61 74 68 20 75 6e 64		MSG_UNDERFLOW   .null "Math underflow"
>3a1e51	65 72 66 6c 6f 77 00
>3a1e58	44 69 76 69 73 69 6f 6e		MSG_DIV0        .null "Division by zero"
>3a1e60	20 62 79 20 7a 65 72 6f 00
>3a1e69	55 6e 61 62 6c 65 20 74		MSG_DIRECTORY   .null "Unable to read directory"
>3a1e71	6f 20 72 65 61 64 20 64 69 72 65 63 74 6f 72 79
>3a1e81	00
>3a1e82	55 6e 61 62 6c 65 20 74		MSG_LOAD        .null "Unable to load file"
>3a1e8a	6f 20 6c 6f 61 64 20 66 69 6c 65 00
>3a1e96	55 6e 61 62 6c 65 20 74		MSG_SAVE        .null "Unable to save file"
>3a1e9e	6f 20 73 61 76 65 20 66 69 6c 65 00
>3a1eaa	55 6e 61 62 6c 65 20 74		MSG_DELETE      .null "Unable to delete file"
>3a1eb2	6f 20 64 65 6c 65 74 65 20 66 69 6c 65 00
>3a1ec0	43 6f 75 6c 64 20 6e 6f		MSG_FILENOTFND  .null "Could not find file"
>3a1ec8	74 20 66 69 6e 64 20 66 69 6c 65 00
>3a1ed4	43 6f 75 6c 64 20 6e 6f		MSG_DIRNOTWRITE .null "Could not update directory"
>3a1edc	74 20 75 70 64 61 74 65 20 64 69 72 65 63 74 6f
>3a1eec	72 79 00
>3a1eef	43 6f 75 6c 64 20 6e 6f		MSG_NOTCOPIED   .null "Could not copy the file"
>3a1ef7	74 20 63 6f 70 79 20 74 68 65 20 66 69 6c 65 00
>3a1f07	41 72 67 75 6d 65 6e 74		MSG_DOMAIN      .null "Argument outside domain"
>3a1f0f	20 6f 75 74 73 69 64 65 20 64 6f 6d 61 69 6e 00
.3a1f1f					SETINTERACT
.3a1f1f	08		php		            PHP
.3a1f20	0b		phd		            PHD
.3a1f21	08		php		            PHP
.3a1f22	c2 20		rep #$20	            REP #$20
.3a1f24	48		pha		            PHA
.3a1f25	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1f28	5b		tcd		            TCD
.3a1f29	68		pla		            PLA
.3a1f2a	28		plp		            PLP
.3a1f2b	e2 20		sep #$20	            SEP #$20
.3a1f2d	a9 00		lda #$00	            LDA #ST_INTERACT
.3a1f2f	85 d2		sta $08d2	            STA STATE
.3a1f31	2b		pld		            PLD
.3a1f32	28		plp		            PLP
.3a1f33	60		rts		            RTS
.3a1f34					CLRINTERP
.3a1f34	0b		phd		            PHD
.3a1f35	08		php		            PHP
.3a1f36	08		php		            PHP
.3a1f37	c2 20		rep #$20	            REP #$20
.3a1f39	48		pha		            PHA
.3a1f3a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1f3d	5b		tcd		            TCD
.3a1f3e	68		pla		            PLA
.3a1f3f	28		plp		            PLP
.3a1f40	08		php		            PHP
.3a1f41	c2 20		rep #$20	            REP #$20
.3a1f43	a9 01 1d	lda #$1d01	            LDA #<>ON_ERROR
.3a1f46	8f d4 08 00	sta $0008d4	            STA @lHANDLEERR
.3a1f4a	e2 20		sep #$20	            SEP #$20
.3a1f4c	a9 3a		lda #$3a	            LDA #`ON_ERROR
.3a1f4e	8f d6 08 00	sta $0008d6	            STA @lHANDLEERR+2
.3a1f52	28		plp		            PLP
.3a1f53	20 87 42	jsr $3a4287	            JSR S_CLR
.3a1f56	20 c8 3d	jsr $3a3dc8	            JSR S_RESTORE
.3a1f59	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the depth of the GOSUB stack
.3a1f5b	28		plp		            PLP
.3a1f5c	2b		pld		            PLD
.3a1f5d	60		rts		            RTS
.3a1f5e					INCBIP
.3a1f5e	08		php		            PHP
.3a1f5f	0b		phd		            PHD
.3a1f60	08		php		            PHP
.3a1f61	c2 20		rep #$20	            REP #$20
.3a1f63	48		pha		            PHA
.3a1f64	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1f67	5b		tcd		            TCD
.3a1f68	68		pla		            PLA
.3a1f69	28		plp		            PLP
.3a1f6a	c2 20		rep #$20	            REP #$20
.3a1f6c	18		clc		            CLC
.3a1f6d	a5 00		lda $0800	            LDA BIP
.3a1f6f	69 01 00	adc #$0001	            ADC #1
.3a1f72	85 00		sta $0800	            STA BIP
.3a1f74	e2 20		sep #$20	            SEP #$20
.3a1f76	a5 02		lda $0802	            LDA BIP+2
.3a1f78	69 00		adc #$00	            ADC #0
.3a1f7a	85 02		sta $0802	            STA BIP+2
.3a1f7c	2b		pld		            PLD
.3a1f7d	28		plp		            PLP
.3a1f7e	60		rts		            RTS
.3a1f7f					SKIPWS
.3a1f7f	08		php		            PHP
.3a1f80	0b		phd		            PHD
.3a1f81	08		php		            PHP
.3a1f82	c2 20		rep #$20	            REP #$20
.3a1f84	48		pha		            PHA
.3a1f85	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1f88	5b		tcd		            TCD
.3a1f89	68		pla		            PLA
.3a1f8a	28		plp		            PLP
.3a1f8b	e2 20		sep #$20	            SEP #$20
.3a1f8d	a7 00		lda [$0800]	loop        LDA [BIP]
.3a1f8f	f0 0f		beq $3a1fa0	            BEQ done            ; If character is 0, we've reached the end of the line
.3a1f91	c9 20		cmp #$20	            CMP #CHAR_SP        ; Skip if it's a space
.3a1f93	f0 06		beq $3a1f9b	            BEQ skip_char
.3a1f95	c9 09		cmp #$09	            CMP #CHAR_TAB       ; Skip if it's a TAB
.3a1f97	f0 02		beq $3a1f9b	            BEQ skip_char
.3a1f99	80 05		bra $3a1fa0	            BRA done            ; Otherwise, we're done and BIP points to a non-whitespace
.3a1f9b					skip_char
.3a1f9b	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a1f9e	80 ed		bra $3a1f8d	            BRA loop
.3a1fa0	2b		pld		done        PLD
.3a1fa1	28		plp		            PLP
.3a1fa2	60		rts		            RTS
.3a1fa3					SKIPSTMT
.3a1fa3	08		php		            PHP
.3a1fa4	e2 20		sep #$20	            SEP #$20
.3a1fa6	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the current character
.3a1fa8	f0 09		beq $3a1fb3	            BEQ done            ; Is it EOL? Yes, we're done
.3a1faa	c9 3a		cmp #$3a	            CMP #':'            ; Is it a colon?
.3a1fac	f0 05		beq $3a1fb3	            BEQ done            ; Yes, we're done
.3a1fae	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a1fb1	80 f3		bra $3a1fa6	            BRA loop            ; and check it...
.3a1fb3	28		plp		done        PLP
.3a1fb4	60		rts		            RTS
.3a1fb5					SKIPTOTOK
.3a1fb5	08		php		            PHP
.3a1fb6	e2 20		sep #$20	            SEP #$20
.3a1fb8	64 36		stz $0836	            STZ NESTING
.3a1fba	a7 00		lda [$0800]	loop        LDA [BIP]           ; Get the character
.3a1fbc	f0 19		beq $3a1fd7	            BEQ end_of_line     ; EOL? Yes: move to the next line
.3a1fbe	c5 37		cmp $0837	            CMP TARGETTOK       ; Is it the one we want?
.3a1fc0	f0 2c		beq $3a1fee	            BEQ check_depth     ; Yes: check the depth
.3a1fc2	c9 9b		cmp #$9b	            CMP #TOK_FOR        ; Is it a FOR?
.3a1fc4	f0 1e		beq $3a1fe4	            BEQ inc_nesting     ; Yes: increment NESTING
.3a1fc6	c9 9f		cmp #$9f	            CMP #TOK_DO         ; Is it a DO?
.3a1fc8	f0 1a		beq $3a1fe4	            BEQ inc_nesting     ; Yes: increment NESTING
.3a1fca	c9 9e		cmp #$9e	            CMP #TOK_NEXT       ; Is it a NEXT?
.3a1fcc	f0 1a		beq $3a1fe8	            BEQ dec_nesting     ; Yes: decrement NESTING
.3a1fce	c9 a0		cmp #$a0	            CMP #TOK_LOOP       ; Is it a LOOP?
.3a1fd0	f0 16		beq $3a1fe8	            BEQ dec_nesting     ; Yes: decrement NESTING
.3a1fd2					incloop
.3a1fd2	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a1fd5	80 e3		bra $3a1fba	            BRA loop            ; and keep scanning
.3a1fd7					end_of_line
.3a1fd7	20 3b 20	jsr $3a203b	            JSR NEXTLINE
.3a1fda	c2 20		rep #$20	            REP #$20
.3a1fdc	a5 d7		lda $08d7	            LDA LINENUM         ; Check the line number
.3a1fde	f0 1d		beq $3a1ffd	            BEQ syntax_err1     ; If it's zero, we reached the end of the program
.3a1fe0	e2 20		sep #$20	            SEP #$20
.3a1fe2	80 d6		bra $3a1fba	            BRA loop            ; And keep scanning
.3a1fe4					inc_nesting
.3a1fe4	e6 36		inc $0836	            INC NESTING         ; Track that we have entered a lexical scope for a FOR/DO
.3a1fe6	80 ea		bra $3a1fd2	            BRA incloop
.3a1fe8					dec_nesting
.3a1fe8	c6 36		dec $0836	            DEC NESTING         ; Track that we have left a lexical scope for a FOR/DO
.3a1fea	30 30		bmi $3a201c	            BMI syntax_err2     ; If the depth goes <0, throw a syntax error
.3a1fec	80 e4		bra $3a1fd2	            BRA incloop
.3a1fee					check_depth
.3a1fee	a5 35		lda $0835	            LDA SKIPNEST        ; Check to see if nesting matters
.3a1ff0	30 06		bmi $3a1ff8	            BMI found           ; No: just return that we found the token
.3a1ff2	a5 36		lda $0836	            LDA NESTING         ; Get the nesting depth
.3a1ff4	f0 02		beq $3a1ff8	            BEQ found           ; If it's zero, we found our token
.3a1ff6	80 da		bra $3a1fd2	            BRA incloop         ; Otherwise: it's a token for an enclosed FOR/DO, keep scanning
.3a1ff8					found
.3a1ff8	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a1ffb	28		plp		            PLP
.3a1ffc	60		rts		            RTS
.3a1ffd					syntax_err1
.3a1ffd	08		php		            PHP
.3a1ffe	c2 20		rep #$20	            REP #$20
.3a2000	48		pha		            PHA
.3a2001	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2004	5b		tcd		            TCD
.3a2005	68		pla		            PLA
.3a2006	28		plp		            PLP
.3a2007	e2 20		sep #$20	            SEP #$20
.3a2009	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a200b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a200f	c2 20		rep #$20	            REP #$20
.3a2011	29 ff 00	and #$00ff	            AND #$00FF
.3a2014	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a2017	e2 20		sep #$20	            SEP #$20
.3a2019	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a201c					syntax_err2
.3a201c	08		php		            PHP
.3a201d	c2 20		rep #$20	            REP #$20
.3a201f	48		pha		            PHA
.3a2020	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2023	5b		tcd		            TCD
.3a2024	68		pla		            PLA
.3a2025	28		plp		            PLP
.3a2026	e2 20		sep #$20	            SEP #$20
.3a2028	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a202a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a202e	c2 20		rep #$20	            REP #$20
.3a2030	29 ff 00	and #$00ff	            AND #$00FF
.3a2033	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a2036	e2 20		sep #$20	            SEP #$20
.3a2038	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a203b					NEXTLINE
.3a203b	08		php		            PHP
.3a203c	c2 30		rep #$30	            REP #$30
.3a203e	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.3a2041	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the offset to the next line
.3a2043	85 0c		sta $080c	            STA SCRATCH
.3a2045	18		clc		            CLC                 ; Compute the new CURLINE
.3a2046	a5 1a		lda $081a	            LDA CURLINE         ; CURLINE := [CURLINE].LINE_LINK
.3a2048	65 0c		adc $080c	            ADC SCRATCH
.3a204a	85 1a		sta $081a	            STA CURLINE
.3a204c	a5 1c		lda $081c	            LDA CURLINE+2
.3a204e	69 00 00	adc #$0000	            ADC #0
.3a2051	85 1c		sta $081c	            STA CURLINE+2
.3a2053	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the LINENUM to the new current line's number
.3a2056	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; LINENUM := [CURLINE].LINE_NUMBER
.3a2058	85 d7		sta $08d7	            STA LINENUM
.3a205a	18		clc		            CLC                 ; Point BIP to the first character of the line
.3a205b	a5 1a		lda $081a	            LDA CURLINE         ; BIP := CURLINE + LINE_TOKENS
.3a205d	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a2060	85 00		sta $0800	            STA BIP
.3a2062	a5 1c		lda $081c	            LDA CURLINE+2
.3a2064	69 00 00	adc #$0000	            ADC #0
.3a2067	85 02		sta $0802	            STA BIP+2
.3a2069	28		plp		            PLP
.3a206a	60		rts		            RTS
.3a206b					EXPECT_TOK
.3a206b	08		php		            PHP
.3a206c	e2 20		sep #$20	            SEP #$20
.3a206e	48		pha		            PHA
.3a206f	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a2072	68		pla		            PLA
.3a2073	e2 20		sep #$20	            SEP #$20
.3a2075	c7 00		cmp [$0800]	            CMP [BIP]           ; Check the character at BIP
.3a2077	d0 08		bne $3a2081	            BNE syntax_err      ; Throw a syntax error
.3a2079	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a207c	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a207f	28		plp		            PLP
.3a2080	60		rts		            RTS
.3a2081					syntax_err
.3a2081	08		php		            PHP
.3a2082	c2 20		rep #$20	            REP #$20
.3a2084	48		pha		            PHA
.3a2085	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2088	5b		tcd		            TCD
.3a2089	68		pla		            PLA
.3a208a	28		plp		            PLP
.3a208b	e2 20		sep #$20	            SEP #$20
.3a208d	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a208f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2093	c2 20		rep #$20	            REP #$20
.3a2095	29 ff 00	and #$00ff	            AND #$00FF
.3a2098	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a209b	e2 20		sep #$20	            SEP #$20
.3a209d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a20a0					OPT_TOK
.3a20a0	08		php		            PHP
.3a20a1	e2 20		sep #$20	            SEP #$20
.3a20a3	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a20a6	e2 20		sep #$20	            SEP #$20
.3a20a8	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the character at BIP
.3a20aa	f0 10		beq $3a20bc	            BEQ ret_false       ; If end-of-line, return false
.3a20ac	c9 3a		cmp #$3a	            CMP #':'
.3a20ae	f0 0c		beq $3a20bc	            BEQ ret_false       ; If colon, return false
.3a20b0	c5 37		cmp $0837	            CMP TARGETTOK
.3a20b2	f0 05		beq $3a20b9	            BEQ ret_true        ; If matches, return true
.3a20b4	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a20b7	80 ef		bra $3a20a8	            BRA loop
.3a20b9	28		plp		ret_true    PLP
.3a20ba	38		sec		            SEC
.3a20bb	60		rts		            RTS
.3a20bc	28		plp		ret_false   PLP
.3a20bd	18		clc		            CLC
.3a20be	60		rts		            RTS
.3a20bf					PEEK_TOK
.3a20bf	5a		phy		            PHY
.3a20c0	08		php		            PHP
.3a20c1	e2 20		sep #$20	            SEP #$20
.3a20c3	a0 00 00	ldy #$0000	            LDY #0
.3a20c6	b7 00		lda [$0800],y	loop        LDA [BIP],Y
.3a20c8	f0 0d		beq $3a20d7	            BEQ done
.3a20ca	c9 3a		cmp #$3a	            CMP #':'
.3a20cc	f0 07		beq $3a20d5	            BEQ ret_null
.3a20ce	c9 20		cmp #$20	            CMP #CHAR_SP
.3a20d0	d0 05		bne $3a20d7	            BNE done
.3a20d2	c8		iny		            INY
.3a20d3	80 f1		bra $3a20c6	            BRA loop
.3a20d5	a9 00		lda #$00	ret_null    LDA #0
.3a20d7	28		plp		done        PLP
.3a20d8	7a		ply		            PLY
.3a20d9	60		rts		            RTS
.3a20da					EXECSTMT
.3a20da	08		php		            PHP
.3a20db	0b		phd		            PHD
.3a20dc	8b		phb		            PHB
.3a20dd	08		php		            PHP
.3a20de	c2 20		rep #$20	            REP #$20
.3a20e0	48		pha		            PHA
.3a20e1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a20e4	5b		tcd		            TCD
.3a20e5	68		pla		            PLA
.3a20e6	28		plp		            PLP
.3a20e7	20 0f 18	jsr $3a180f	            JSR INITEVALSP
.3a20ea	e2 20		sep #$20	            SEP #$20
.3a20ec	a9 00		lda #$00	            LDA #EXEC_CONT      ; This will tell EXECLINE and EXECPROG to procede in a
.3a20ee	85 dc		sta $08dc	            STA EXECACTION      ; linear fashion through the program
.3a20f0	ad 8a 0f	lda $0f8a	check_break LDA KEYFLAG         ; Check the keyboard flags
.3a20f3	30 4b		bmi $3a2140	            BMI throw_break     ; If MSB: user pressed an interrupt key, stop the program
.3a20f5	a7 00		lda [$0800]	            LDA [BIP]           ; If we happen to have a colon, just skip over it.
.3a20f7	c9 3a		cmp #$3a	            CMP #':'            ; This can happen with FOR/NEXT
.3a20f9	d0 03		bne $3a20fe	            BNE eat_ws
.3a20fb	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a20fe					eat_ws
.3a20fe	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a2101	a7 00		lda [$0800]	            LDA [BIP]
.3a2103	d0 03		bne $3a2108	            BNE else
.3a2105	4c 8a 21	jmp $3a218a	            JMP done            ; If the current byte is 0, we're at the end of the line, just return
.3a2108					else
.3a2108	20 94 03	jsr $3a0394	            JSR ISALPHA
.3a210b	b0 52		bcs $3a215f	            BCS is_variable     ; Yes: we may have a LET statement
.3a210d	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it's any other non-token
.3a210f	10 10		bpl $3a2121	            BPL error           ; Yes: it's a syntax error
.3a2111	20 5c 0b	jsr $3a0b5c	            JSR TOKTYPE
.3a2114	85 0c		sta $080c	            STA SCRATCH         ; Save the type for later
.3a2116	c9 20		cmp #$20	            CMP #TOK_TY_STMNT   ; Is it a statement?
.3a2118	d0 03		bne $3a211d	            BNE else2
.3a211a	4c 78 21	jmp $3a2178	            JMP ok_to_exec      ; Yes: it's ok to try to execute it
.3a211d	a5 d2		lda $08d2	else2       LDA STATE           ; Check to see if we're in interactive mode
.3a211f	f0 51		beq $3a2172	            BEQ is_interact
.3a2121					error
.3a2121	08		php		            PHP
.3a2122	c2 20		rep #$20	            REP #$20
.3a2124	48		pha		            PHA
.3a2125	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2128	5b		tcd		            TCD
.3a2129	68		pla		            PLA
.3a212a	28		plp		            PLP
.3a212b	e2 20		sep #$20	            SEP #$20
.3a212d	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a212f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2133	c2 20		rep #$20	            REP #$20
.3a2135	29 ff 00	and #$00ff	            AND #$00FF
.3a2138	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a213b	e2 20		sep #$20	            SEP #$20
.3a213d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2140					throw_break
.3a2140	08		php		            PHP
.3a2141	c2 20		rep #$20	            REP #$20
.3a2143	48		pha		            PHA
.3a2144	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2147	5b		tcd		            TCD
.3a2148	68		pla		            PLA
.3a2149	28		plp		            PLP
.3a214a	e2 20		sep #$20	            SEP #$20
.3a214c	a9 01		lda #$01	            LDA #ERR_BREAK
.3a214e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2152	c2 20		rep #$20	            REP #$20
.3a2154	29 ff 00	and #$00ff	            AND #$00FF
.3a2157	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a215a	e2 20		sep #$20	            SEP #$20
.3a215c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a215f					is_variable
.3a215f	20 91 42	jsr $3a4291	            JSR S_LET
.3a2162	4c 8a 21	jmp $3a218a	            JMP done
.3a2165					STSTUB
.3a2165	08		php		            PHP
.3a2166	e2 20		sep #$20	            SEP #$20
.3a2168	48		pha		            PHA
.3a2169	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a216b	48		pha		            PHA
.3a216c	ab		plb		            PLB
.3a216d	68		pla		            PLA
.3a216e	28		plp		            PLP
.3a216f	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.3a2172	a5 0c		lda $080c	is_interact LDA SCRATCH         ; Get the token type
.3a2174	c9 10		cmp #$10	            CMP #TOK_TY_CMD     ; Is it a command?
.3a2176	d0 a9		bne $3a2121	            BNE error           ; If not, it's an error
.3a2178					ok_to_exec
.3a2178	a7 00		lda [$0800]	            LDA [BIP]           ; Get the original token again
.3a217a	20 39 0b	jsr $3a0b39	            JSR TOKEVAL
.3a217d	c2 20		rep #$20	            REP #$20
.3a217f	85 2f		sta $082f	            STA JMP16PTR        ; Store it in the jump pointer
.3a2181	20 0f 18	jsr $3a180f	            JSR INITEVALSP
.3a2184	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a2187	20 65 21	jsr $3a2165	            JSR STSTUB
.3a218a	ab		plb		done        PLB
.3a218b	2b		pld		            PLD
.3a218c	28		plp		            PLP
.3a218d	60		rts		            RTS
.3a218e					EXECCMD
.3a218e	08		php		            PHP
.3a218f	58		cli		            CLI
.3a2190	20 1f 1f	jsr $3a1f1f	            JSR SETINTERACT
.3a2193	20 44 1c	jsr $3a1c44	            JSR INITRETURN
.3a2196	e2 20		sep #$20	            SEP #$20
.3a2198	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.3a219b	c2 20		rep #$20	            REP #$20
.3a219d	a5 1a		lda $081a	            LDA CURLINE         ; Set the BASIC Instruction Pointer to the first byte of the line
.3a219f	85 00		sta $0800	            STA BIP
.3a21a1	a5 1c		lda $081c	            LDA CURLINE+2
.3a21a3	85 02		sta $0802	            STA BIP+2
.3a21a5	4c cf 21	jmp $3a21cf	            JMP exec_loop
.3a21a8	08		php		EXECLINE    PHP
.3a21a9	c2 20		rep #$20	            REP #$20
.3a21ab	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER            ; Set the current line number
.3a21ae	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.3a21b0	85 d7		sta $08d7	            STA LINENUM
.3a21b2	20 a5 13	jsr $3a13a5	            JSR CLRTMPSTR
.3a21b5	e2 20		sep #$20	            SEP #$20
.3a21b7	a5 dc		lda $08dc	            LDA EXECACTION              ; If the last EXEC action was RETURN
.3a21b9	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; BIP has already been set, so...
.3a21bb	f0 12		beq $3a21cf	            BEQ exec_loop               ; Skip over setting the BIP to the beginning of the line
.3a21bd	c2 20		rep #$20	            REP #$20
.3a21bf	18		clc		            CLC                         ; Set the BASIC Instruction Pointer to the first byte of the line
.3a21c0	a5 1a		lda $081a	            LDA CURLINE
.3a21c2	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a21c5	85 00		sta $0800	            STA BIP
.3a21c7	e2 20		sep #$20	            SEP #$20
.3a21c9	a5 1c		lda $081c	            LDA CURLINE+2
.3a21cb	69 00		adc #$00	            ADC #0
.3a21cd	85 02		sta $0802	            STA BIP+2
.3a21cf					exec_loop
.3a21cf	c2 20		rep #$20	            REP #$20
.3a21d1	20 da 20	jsr $3a20da	            JSR EXECSTMT
.3a21d4	e2 20		sep #$20	            SEP #$20
.3a21d6	a5 dc		lda $08dc	            LDA EXECACTION
.3a21d8	c9 03		cmp #$03	            CMP #EXEC_RETURN
.3a21da	f0 f3		beq $3a21cf	            BEQ exec_loop
.3a21dc	c9 00		cmp #$00	            CMP #EXEC_CONT              ; If it's not EXEC_CONT, exit to the caller
.3a21de	d0 31		bne $3a2211	            BNE exec_done
.3a21e0	e2 20		sep #$20	            SEP #$20
.3a21e2	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a21e5	a7 00		lda [$0800]	            LDA [BIP]                   ; Get the current character in the line
.3a21e7	f0 28		beq $3a2211	            BEQ exec_done               ; If it's NULL, we're done
.3a21e9	c9 3a		cmp #$3a	            CMP #':'                    ; If it's colon, we have more statements
.3a21eb	f0 1f		beq $3a220c	            BEQ skip_loop               ; Skip over it and try to execute the next one
.3a21ed	08		php		            PHP
.3a21ee	c2 20		rep #$20	            REP #$20
.3a21f0	48		pha		            PHA
.3a21f1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a21f4	5b		tcd		            TCD
.3a21f5	68		pla		            PLA
.3a21f6	28		plp		            PLP
.3a21f7	e2 20		sep #$20	            SEP #$20
.3a21f9	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a21fb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a21ff	c2 20		rep #$20	            REP #$20
.3a2201	29 ff 00	and #$00ff	            AND #$00FF
.3a2204	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a2207	e2 20		sep #$20	            SEP #$20
.3a2209	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a220c					skip_loop
.3a220c	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a220f	80 be		bra $3a21cf	            BRA exec_loop               ; And try to execute another statement
.3a2211					exec_done
.3a2211	28		plp		            PLP
.3a2212	60		rts		            RTS
.3a2213					EXECPROGRAM
.3a2213	08		php		            PHP
.3a2214	58		cli		            CLI
.3a2215	e2 20		sep #$20	            SEP #$20
.3a2217	a9 80		lda #$80	            LDA #ST_RUNNING
.3a2219	85 d2		sta $08d2	            STA STATE
.3a221b	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.3a221e	20 44 1c	jsr $3a1c44	            JSR INITRETURN
.3a2221	c2 30		rep #$30	            REP #$30
.3a2223	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the count of GOSUBs
.3a2225	a0 02 00	ldy #$0002	exec_loop   LDY #LINE_NUMBER
.3a2228	b7 1a		lda [$081a],y	            LDA [CURLINE],Y             ; Get the line number of the current line
.3a222a	f0 29		beq $3a2255	            BEQ done                    ; If it's 0, we are finished running code (implicit END)
.3a222c	20 a8 21	jsr $3a21a8	            JSR EXECLINE
.3a222f	e2 20		sep #$20	            SEP #$20
.3a2231	a5 dc		lda $08dc	            LDA EXECACTION              ; Check the EXECACTION from the last line
.3a2233	c9 01		cmp #$01	            CMP #EXEC_STOP              ; Stop execution of the program?
.3a2235	f0 1e		beq $3a2255	            BEQ done
.3a2237	c9 02		cmp #$02	            CMP #EXEC_GOTO              ; Transfer execution to a new CURLINE that is already set
.3a2239	f0 ea		beq $3a2225	            BEQ exec_loop
.3a223b	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; Transfer execution to the CURLINE and BIP that is already set
.3a223d	f0 e6		beq $3a2225	            BEQ exec_loop
.3a223f	c2 20		rep #$20	            REP #$20
.3a2241	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.3a2244	18		clc		            CLC
.3a2245	a5 1a		lda $081a	            LDA CURLINE
.3a2247	77 1a		adc [$081a],y	            ADC [CURLINE],Y
.3a2249	85 1a		sta $081a	            STA CURLINE
.3a224b	e2 20		sep #$20	            SEP #$20
.3a224d	a5 1c		lda $081c	            LDA CURLINE+2
.3a224f	69 00		adc #$00	            ADC #0
.3a2251	85 1c		sta $081c	            STA CURLINE+2
.3a2253	80 d0		bra $3a2225	            BRA exec_loop               ; And try to execute that line
.3a2255					done
.3a2255	e2 20		sep #$20	            SEP #$20
.3a2257	a9 00		lda #$00	            LDA #ST_INTERACT            ; Set interpreter state to RUNNING
.3a2259	85 d2		sta $08d2	            STA STATE
.3a225b	28		plp		            PLP
.3a225c	60		rts		            RTS
.3a225d					FINDLINE
.3a225d	08		php		            PHP
.3a225e	c2 30		rep #$30	            REP #$30
.3a2260	c2 20		rep #$20	            REP #$20
.3a2262	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT            ; INDEX points to the first line of the program
.3a2265	85 08		sta $0808	            STA INDEX
.3a2267	a9 36 00	lda #$0036	            LDA #`BASIC_BOT
.3a226a	85 0a		sta $080a	            STA INDEX+2
.3a226c	c2 20		rep #$20	            REP #$20
.3a226e	a0 02 00	ldy #$0002	check_nmbrs LDY #LINE_NUMBER            ; Get the number of the possible target line
.3a2271	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a2273	f0 31		beq $3a22a6	            BEQ ret_false               ; If new line number is 0, we got to the
.3a2275	c5 23		cmp $0823	            CMP ARGUMENT1               ; Compare it to the target line number
.3a2277	f0 1e		beq $3a2297	            BEQ found
.3a2279	b0 2b		bcs $3a22a6	            BGE ret_false               ; If the line number > target line number, the line is not present
.3a227b					next_line
.3a227b	c2 20		rep #$20	            REP #$20
.3a227d	a0 00 00	ldy #$0000	            LDY #LINE_LINK              ; INDEX := INDEX + [INDEX].LINK
.3a2280	18		clc		            CLC
.3a2281	a5 08		lda $0808	            LDA INDEX
.3a2283	77 08		adc [$0808],y	            ADC [INDEX],Y
.3a2285	85 0c		sta $080c	            STA SCRATCH
.3a2287	e2 20		sep #$20	            SEP #$20
.3a2289	a5 0a		lda $080a	            LDA INDEX+2
.3a228b	69 00		adc #$00	            ADC #0
.3a228d	85 0a		sta $080a	            STA INDEX+2
.3a228f	c2 20		rep #$20	            REP #$20
.3a2291	a5 0c		lda $080c	            LDA SCRATCH
.3a2293	85 08		sta $0808	            STA INDEX
.3a2295	80 d7		bra $3a226e	            BRA check_nmbrs             ; And go back to check the new line INDEX is pointing to
.3a2297					found
.3a2297	c2 20		rep #$20	            REP #$20
.3a2299	a5 08		lda $0808	            LDA INDEX
.3a229b	85 1a		sta $081a	            STA CURLINE
.3a229d	e2 20		sep #$20	            SEP #$20
.3a229f	a5 0a		lda $080a	            LDA INDEX+2
.3a22a1	85 1c		sta $081c	            STA CURLINE+2
.3a22a3	28		plp		ret_true    PLP                         ; Return true to indicate we've found the line
.3a22a4	38		sec		            SEC
.3a22a5	60		rts		            RTS
.3a22a6	28		plp		ret_false   PLP
.3a22a7	18		clc		            CLC
.3a22a8	60		rts		            RTS
.3a22a9					MVPROGDN
.3a22a9	08		php		            PHP
.3a22aa					mvd_loop
.3a22aa	e2 20		sep #$20	            SEP #$20
.3a22ac	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.3a22ae	87 08		sta [$0808]	            STA [INDEX]
.3a22b0	c2 20		rep #$20	            REP #$20
.3a22b2	a5 0c		lda $080c	            LDA SCRATCH
.3a22b4	c5 00		cmp $0800	            CMP BIP
.3a22b6	d0 08		bne $3a22c0	            BNE increment
.3a22b8	e2 20		sep #$20	            SEP #$20
.3a22ba	a5 0e		lda $080e	            LDA SCRATCH+2
.3a22bc	c5 02		cmp $0802	            CMP BIP+2
.3a22be	f0 26		beq $3a22e6	            BEQ done            ; Yes: return
.3a22c0					increment
.3a22c0	c2 20		rep #$20	            REP #$20
.3a22c2	18		clc		            CLC
.3a22c3	a5 0c		lda $080c	            LDA SCRATCH
.3a22c5	69 01 00	adc #$0001	            ADC #1
.3a22c8	85 0c		sta $080c	            STA SCRATCH
.3a22ca	e2 20		sep #$20	            SEP #$20
.3a22cc	a5 0e		lda $080e	            LDA SCRATCH+2
.3a22ce	69 00		adc #$00	            ADC #0
.3a22d0	85 0e		sta $080e	            STA SCRATCH+2
.3a22d2	c2 20		rep #$20	            REP #$20
.3a22d4	18		clc		            CLC
.3a22d5	a5 08		lda $0808	            LDA INDEX
.3a22d7	69 01 00	adc #$0001	            ADC #1
.3a22da	85 08		sta $0808	            STA INDEX
.3a22dc	e2 20		sep #$20	            SEP #$20
.3a22de	a5 0a		lda $080a	            LDA INDEX+2
.3a22e0	69 00		adc #$00	            ADC #0
.3a22e2	85 0a		sta $080a	            STA INDEX+2
.3a22e4	80 c4		bra $3a22aa	            BRA mvd_loop        ; And try again
.3a22e6	28		plp		done        PLP
.3a22e7	60		rts		            RTS
.3a22e8					MVPROGUP
.3a22e8	08		php		            PHP
.3a22e9					mvu_loop
.3a22e9	e2 20		sep #$20	            SEP #$20
.3a22eb	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.3a22ed	87 08		sta [$0808]	            STA [INDEX]
.3a22ef	c2 20		rep #$20	            REP #$20
.3a22f1	a5 0c		lda $080c	            LDA SCRATCH
.3a22f3	c5 00		cmp $0800	            CMP BIP
.3a22f5	d0 06		bne $3a22fd	            BNE decrement
.3a22f7	a5 0e		lda $080e	            LDA SCRATCH+2
.3a22f9	c5 02		cmp $0802	            CMP BIP+2
.3a22fb	f0 26		beq $3a2323	            BEQ done            ; Yes: return
.3a22fd					decrement
.3a22fd	c2 20		rep #$20	            REP #$20
.3a22ff	38		sec		            SEC
.3a2300	a5 0c		lda $080c	            LDA SCRATCH
.3a2302	e9 01 00	sbc #$0001	            SBC #1
.3a2305	85 0c		sta $080c	            STA SCRATCH
.3a2307	e2 20		sep #$20	            SEP #$20
.3a2309	a5 0e		lda $080e	            LDA SCRATCH+2
.3a230b	e9 00		sbc #$00	            SBC #0
.3a230d	85 0e		sta $080e	            STA SCRATCH+2
.3a230f	c2 20		rep #$20	            REP #$20
.3a2311	38		sec		            SEC
.3a2312	a5 08		lda $0808	            LDA INDEX
.3a2314	e9 01 00	sbc #$0001	            SBC #1
.3a2317	85 08		sta $0808	            STA INDEX
.3a2319	e2 20		sep #$20	            SEP #$20
.3a231b	a5 0a		lda $080a	            LDA INDEX+2
.3a231d	e9 00		sbc #$00	            SBC #0
.3a231f	85 0a		sta $080a	            STA INDEX+2
.3a2321	80 c6		bra $3a22e9	            BRA mvu_loop        ; And try again
.3a2323	28		plp		done        PLP
.3a2324	60		rts		            RTS
.3a2325					DELLINE
.3a2325	08		php		            PHP
.3a2326	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; SCRATCH := INDEX + [INDEX].LINK (address of the following line)
.3a2329	c2 20		rep #$20	            REP #$20
.3a232b	18		clc		            CLC
.3a232c	a5 08		lda $0808	            LDA INDEX
.3a232e	77 08		adc [$0808],y	            ADC [INDEX],Y
.3a2330	85 0c		sta $080c	            STA SCRATCH
.3a2332	e2 20		sep #$20	            SEP #$20
.3a2334	a5 0a		lda $080a	            LDA INDEX+2
.3a2336	69 00		adc #$00	            ADC #0
.3a2338	85 0e		sta $080e	            STA SCRATCH+2
.3a233a	c2 20		rep #$20	            REP #$20
.3a233c	18		clc		            CLC
.3a233d	a5 d9		lda $08d9	            LDA LASTLINE
.3a233f	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a2342	85 00		sta $0800	            STA BIP
.3a2344	e2 20		sep #$20	            SEP #$20
.3a2346	a5 db		lda $08db	            LDA LASTLINE+2
.3a2348	69 00		adc #$00	            ADC #0
.3a234a	85 02		sta $0802	            STA BIP+2
.3a234c	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; LASTLINE := LASTLINE - [INDEX].LINK
.3a234f	c2 20		rep #$20	            REP #$20
.3a2351	38		sec		            SEC
.3a2352	a5 d9		lda $08d9	            LDA LASTLINE
.3a2354	f7 08		sbc [$0808],y	            SBC [INDEX],Y
.3a2356	85 d9		sta $08d9	            STA LASTLINE
.3a2358	e2 20		sep #$20	            SEP #$20
.3a235a	a5 db		lda $08db	            LDA LASTLINE+2
.3a235c	e9 00		sbc #$00	            SBC #0
.3a235e	85 db		sta $08db	            STA LASTLINE+2
.3a2360	20 a9 22	jsr $3a22a9	            JSR MVPROGDN
.3a2363					done
.3a2363	20 87 42	jsr $3a4287	            JSR S_CLR
.3a2366	28		plp		            PLP
.3a2367	60		rts		            RTS
.3a2368					APPLINE
.3a2368	08		php		            PHP
.3a2369	08		php		            PHP
.3a236a	c2 20		rep #$20	            REP #$20
.3a236c	48		pha		            PHA
.3a236d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a2370	5b		tcd		            TCD
.3a2371	68		pla		            PLA
.3a2372	28		plp		            PLP
.3a2373	c2 30		rep #$30	            REP #$30
.3a2375	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the line number of the new line
.3a2378	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.3a237a	18		clc		            CLC                 ; Point INDEX to the position to store the tokens
.3a237b	a5 d9		lda $08d9	            LDA LASTLINE
.3a237d	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a2380	85 08		sta $0808	            STA INDEX
.3a2382	e2 20		sep #$20	            SEP #$20
.3a2384	a5 db		lda $08db	            LDA LASTLINE+2
.3a2386	69 00		adc #$00	            ADC #0
.3a2388	85 0a		sta $080a	            STA INDEX+2
.3a238a	e2 20		sep #$20	            SEP #$20
.3a238c	a0 00 00	ldy #$0000	            LDY #0
.3a238f	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Copy the tokenized line to its place in the code
.3a2391	97 08		sta [$0808],y	            STA [INDEX],Y
.3a2393	f0 03		beq $3a2398	            BEQ copy_done
.3a2395	c8		iny		            INY
.3a2396	80 f7		bra $3a238f	            BRA copy_loop
.3a2398					copy_done
.3a2398	c2 20		rep #$20	            REP #$20
.3a239a	98		tya		            TYA
.3a239b	18		clc		            CLC
.3a239c	69 05 00	adc #$0005	            ADC #LINE_TOKENS+1
.3a239f	85 0c		sta $080c	            STA SCRATCH
.3a23a1	c2 20		rep #$20	            REP #$20
.3a23a3	a0 00 00	ldy #$0000	            LDY #LINE_LINK      ; Set link to the offset to the next line
.3a23a6	a5 0c		lda $080c	            LDA SCRATCH
.3a23a8	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.3a23aa	c2 20		rep #$20	            REP #$20
.3a23ac	18		clc		            CLC
.3a23ad	a5 d9		lda $08d9	            LDA LASTLINE
.3a23af	65 0c		adc $080c	            ADC SCRATCH
.3a23b1	85 0c		sta $080c	            STA SCRATCH
.3a23b3	e2 20		sep #$20	            SEP #$20
.3a23b5	a5 db		lda $08db	            LDA LASTLINE+2
.3a23b7	69 00		adc #$00	            ADC #0
.3a23b9	85 db		sta $08db	            STA LASTLINE+2
.3a23bb	c2 20		rep #$20	            REP #$20
.3a23bd	a5 0c		lda $080c	            LDA SCRATCH
.3a23bf	85 d9		sta $08d9	            STA LASTLINE
.3a23c1	c2 20		rep #$20	            REP #$20
.3a23c3	a0 00 00	ldy #$0000	            LDY #0
.3a23c6	a9 00 00	lda #$0000	            LDA #0
.3a23c9	97 d9		sta [$08d9],y	blank_loop  STA [LASTLINE],Y    ; Set the "line" after the last line to nulls
.3a23cb	c8		iny		            INY
.3a23cc	c0 05 00	cpy #$0005	            CPY #LINE_TOKENS+1
.3a23cf	d0 f8		bne $3a23c9	            BNE blank_loop
.3a23d1	20 87 42	jsr $3a4287	            JSR S_CLR
.3a23d4	28		plp		            PLP
.3a23d5	60		rts		            RTS
.3a23d6					FINDINSPT
.3a23d6	0b		phd		            PHD
.3a23d7	08		php		            PHP
.3a23d8	08		php		            PHP
.3a23d9	c2 20		rep #$20	            REP #$20
.3a23db	48		pha		            PHA
.3a23dc	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a23df	5b		tcd		            TCD
.3a23e0	68		pla		            PLA
.3a23e1	28		plp		            PLP
.3a23e2	c2 30		rep #$30	            REP #$30
.3a23e4	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.3a23e7	85 08		sta $0808	            STA INDEX
.3a23e9	a9 36 00	lda #$0036	            LDA #`BASIC_BOT
.3a23ec	85 0a		sta $080a	            STA INDEX+2
.3a23ee	a0 02 00	ldy #$0002	loop        LDY #LINE_NUMBER
.3a23f1	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a23f3	f0 1d		beq $3a2412	            BEQ found_end           ; Got to end without finding it
.3a23f5	c5 d7		cmp $08d7	            CMP LINENUM
.3a23f7	f0 25		beq $3a241e	            BEQ found_line          ; LINENUM = [INDEX].LINE_NUMBER: return we found the exact line
.3a23f9	b0 1d		bcs $3a2418	            BGE found_spot          ; LINENUM > [INDEX].LINE_NUMBER: return we found spot to insert
.3a23fb	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.3a23fe	18		clc		            CLC                     ; Move INDEX to the next line
.3a23ff	a5 08		lda $0808	            LDA INDEX
.3a2401	77 08		adc [$0808],y	            ADC [INDEX],Y
.3a2403	85 0c		sta $080c	            STA SCRATCH
.3a2405	a5 0a		lda $080a	            LDA INDEX+2
.3a2407	69 00 00	adc #$0000	            ADC #0
.3a240a	85 0a		sta $080a	            STA INDEX+2
.3a240c	a5 0c		lda $080c	            LDA SCRATCH
.3a240e	85 08		sta $0808	            STA INDEX
.3a2410	80 dc		bra $3a23ee	            BRA loop                ; And check that line
.3a2412	a9 00 00	lda #$0000	found_end   LDA #0                  ; Return that we reached the end of the program
.3a2415	28		plp		            PLP
.3a2416	2b		pld		            PLD
.3a2417	60		rts		            RTS
.3a2418	a9 01 00	lda #$0001	found_spot  LDA #1                  ; Return that we the found the spot to insert the line
.3a241b	28		plp		            PLP                     ; But that it wasn't already there
.3a241c	2b		pld		            PLD
.3a241d	60		rts		            RTS
.3a241e	a9 02 00	lda #$0002	found_line  LDA #2                  ; Return that we found the line
.3a2421	28		plp		            PLP
.3a2422	2b		pld		            PLD
.3a2423	60		rts		            RTS
.3a2424					INSLINE
.3a2424	08		php		            PHP
.3a2425	c2 30		rep #$30	            REP #$30
.3a2427	a9 05 00	lda #$0005	            LDA #LINE_TOKENS+1  ; Set SCRATCH2 to the size of the line header with the end-of-line
.3a242a	85 10		sta $0810	            STA SCRATCH2
.3a242c	a0 00 00	ldy #$0000	            LDY #0
.3a242f					count_loop
.3a242f	e2 20		sep #$20	            SEP #$20
.3a2431	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the byte of the line
.3a2433	f0 07		beq $3a243c	            BEQ shift_prog      ; If it's end-of-line, SCRATCH2 is the length
.3a2435	c2 20		rep #$20	            REP #$20
.3a2437	e6 10		inc $0810	            INC SCRATCH2
.3a2439	c8		iny		            INY
.3a243a	80 f3		bra $3a242f	            BRA count_loop      ; Count and continue
.3a243c					shift_prog
.3a243c	c2 20		rep #$20	            REP #$20
.3a243e	a5 08		lda $0808	            LDA INDEX           ; BIP = the address of the first byte for the new line
.3a2440	85 00		sta $0800	            STA BIP
.3a2442	a5 0a		lda $080a	            LDA INDEX+2
.3a2444	85 02		sta $0802	            STA BIP+2
.3a2446	18		clc		            CLC                 ; SCRATCH = address of highest byte to copy
.3a2447	a5 d9		lda $08d9	            LDA LASTLINE
.3a2449	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a244c	85 0c		sta $080c	            STA SCRATCH
.3a244e	a5 db		lda $08db	            LDA LASTLINE+2
.3a2450	69 00 00	adc #$0000	            ADC #0
.3a2453	85 0e		sta $080e	            STA SCRATCH+2
.3a2455	18		clc		            CLC                 ; Adjust LASTLINE to its new position after the insert
.3a2456	a5 d9		lda $08d9	            LDA LASTLINE
.3a2458	65 10		adc $0810	            ADC SCRATCH2
.3a245a	85 d9		sta $08d9	            STA LASTLINE
.3a245c	a5 db		lda $08db	            LDA LASTLINE+2
.3a245e	69 00 00	adc #$0000	            ADC #0
.3a2461	85 db		sta $08db	            STA LASTLINE+2
.3a2463	18		clc		            CLC                 ; INDEX = address of the highest location to copy into
.3a2464	a5 d9		lda $08d9	            LDA LASTLINE
.3a2466	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a2469	85 08		sta $0808	            STA INDEX
.3a246b	a5 db		lda $08db	            LDA LASTLINE+2
.3a246d	69 00 00	adc #$0000	            ADC #0
.3a2470	85 0a		sta $080a	            STA INDEX+2
.3a2472	20 e8 22	jsr $3a22e8	            JSR MVPROGUP
.3a2475	c2 20		rep #$20	            REP #$20
.3a2477	a5 10		lda $0810	            LDA SCRATCH2
.3a2479	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.3a247c	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINK_LINK = length of the new line
.3a247e	a5 d7		lda $08d7	            LDA LINENUM
.3a2480	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.3a2483	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINE_NUMBER = number of the new line
.3a2485	18		clc		            CLC                 ; Point BIP to the first byte of the new line
.3a2486	a5 00		lda $0800	            LDA BIP
.3a2488	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a248b	85 00		sta $0800	            STA BIP
.3a248d	a5 02		lda $0802	            LDA BIP+2
.3a248f	69 00 00	adc #$0000	            ADC #0
.3a2492	85 02		sta $0802	            STA BIP+2
.3a2494	a0 00 00	ldy #$0000	            LDY #0
.3a2497	e2 20		sep #$20	            SEP #$20
.3a2499	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Get the byte of the tokenized line
.3a249b	97 00		sta [$0800],y	            STA [BIP],Y         ; Copy it to its correct location in the program
.3a249d	f0 03		beq $3a24a2	            BEQ done            ; If it was end-of-line byte, we're done
.3a249f	c8		iny		            INY
.3a24a0	80 f7		bra $3a2499	            BRA copy_loop       ; Otherwise, continue with the next
.3a24a2					done
.3a24a2	20 87 42	jsr $3a4287	            JSR S_CLR
.3a24a5	28		plp		            PLP
.3a24a6	60		rts		            RTS
.3a24a7					ADDLINE
.3a24a7	08		php		            PHP
.3a24a8	c2 30		rep #$30	            REP #$30
.3a24aa	85 d7		sta $08d7	            STA LINENUM
.3a24ac	20 d6 23	jsr $3a23d6	            JSR FINDINSPT
.3a24af	c9 00 00	cmp #$0000	            CMP #0
.3a24b2	f0 2c		beq $3a24e0	            BEQ do_append       ; End-of-program found, add the line to the end
.3a24b4	c9 01 00	cmp #$0001	            CMP #1
.3a24b7	f0 22		beq $3a24db	            BEQ do_insert       ; Spot was found: insertion required
.3a24b9	c2 20		rep #$20	            REP #$20
.3a24bb	a5 08		lda $0808	            LDA INDEX
.3a24bd	48		pha		            PHA
.3a24be	a5 0a		lda $080a	            LDA INDEX+2
.3a24c0	48		pha		            PHA
.3a24c1	20 25 23	jsr $3a2325	            JSR DELLINE
.3a24c4	68		pla		            PLA
.3a24c5	85 0a		sta $080a	            STA INDEX+2
.3a24c7	68		pla		            PLA
.3a24c8	85 08		sta $0808	            STA INDEX
.3a24ca	a5 1a		lda $081a	            LDA CURLINE         ; Check to see if there is any non-whitespace on the line
.3a24cc	85 00		sta $0800	            STA BIP
.3a24ce	a5 1c		lda $081c	            LDA CURLINE+2
.3a24d0	85 02		sta $0802	            STA BIP+2
.3a24d2	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a24d5	e2 20		sep #$20	            SEP #$20
.3a24d7	a7 00		lda [$0800]	            LDA [BIP]
.3a24d9	f0 0a		beq $3a24e5	            BEQ done            ; If not, we're done
.3a24db					do_insert
.3a24db	20 24 24	jsr $3a2424	            JSR INSLINE
.3a24de	80 05		bra $3a24e5	            BRA done
.3a24e0	a5 d7		lda $08d7	do_append   LDA LINENUM
.3a24e2	20 68 23	jsr $3a2368	            JSR APPLINE
.3a24e5	28		plp		done        PLP
.3a24e6	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\repl.s

="#"					CHAR_DIR = '#'
="|"					CHAR_BRUN = '|'
.3a24e7					EXPANDLINE
.3a24e7	0b		phd		                PHD
.3a24e8	08		php		                PHP
.3a24e9	08		php		            PHP
.3a24ea	c2 20		rep #$20	            REP #$20
.3a24ec	48		pha		            PHA
.3a24ed	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a24f0	5b		tcd		            TCD
.3a24f1	68		pla		            PLA
.3a24f2	28		plp		            PLP
.3a24f3	e2 20		sep #$20	            SEP #$20
.3a24f5	c2 10		rep #$10	            REP #$10
.3a24f7	a2 00 00	ldx #$0000	                LDX #0
.3a24fa	bd 00 4f	lda $4f00,x	count_loop      LDA INPUTBUF,X              ; Count the number of characters in the input
.3a24fd	f0 03		beq $3a2502	                BEQ save_size
.3a24ff	e8		inx		                INX
.3a2500	80 f8		bra $3a24fa	                BRA count_loop
.3a2502	86 0c		stx $080c	save_size       STX SCRATCH                 ; Save the size in SCRATCH
.3a2504	c2 30		rep #$30	            REP #$30
.3a2506	8a		txa		                TXA
.3a2507	c9 02 00	cmp #$0002	                CMP #2                      ; Are there arguments?
.3a250a	90 12		bcc $3a251e	                BLT start_copy              ; No: just replace the whole string
.3a250c	3a		dec a		                DEC A
.3a250d	18		clc		                CLC
.3a250e	69 00 4f	adc #$4f00	                ADC #<>INPUTBUF
.3a2511	aa		tax		                TAX                         ; X <-- INPUTBUF + len(INPUTBUF) - 1
.3a2512	18		clc		                CLC                         ; Y <-- INPUTBUF + len(INPUTBUF) - 1 + len(substitution)
.3a2513	65 8f		adc $088f	                ADC MCOUNT
.3a2515	a8		tay		                TAY
.3a2516	a5 0c		lda $080c	                LDA SCRATCH
.3a2518	3a		dec a		                DEC A
.3a2519	8b		phb		                PHB
.3a251a	44 00 00	mvp #$00,#$00	                MVP #`INPUTBUF,#`INPUTBUF   ; Make room for the substitition
.3a251d	ab		plb		                PLB
.3a251e					start_copy
.3a251e	c2 20		rep #$20	            REP #$20
.3a2520	a6 55		ldx $0855	                LDX MARG1                   ; Source is data to copy
.3a2522	a0 00 4f	ldy #$4f00	                LDY #<>INPUTBUF             ; Destination is input buffer
.3a2525	a5 8f		lda $088f	                LDA MCOUNT                  ; Number of bytes to copy
.3a2527	8b		phb		                PHB
.3a2528	54 00 3a	mvn #$3a,#$00	                MVN #`EXPANDLINE,#`INPUTBUF ; Copy the data
.3a252b	ab		plb		                PLB
.3a252c	e2 20		sep #$20	            SEP #$20
.3a252e	a5 0c		lda $080c	                LDA SCRATCH                 ; Check again to see if we need quotes
.3a2530	c9 02		cmp #$02	                CMP #2
.3a2532	90 18		bcc $3a254c	                BLT done
.3a2534	a6 8f		ldx $088f	                LDX MCOUNT                  ; If so, add a quote mark here
.3a2536	a9 22		lda #$22	                LDA #CHAR_DQUOTE
.3a2538	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a253b	e8		inx		skip_to_end     INX                         ; Move to the end of the input string
.3a253c	bd 00 4f	lda $4f00,x	                LDA INPUTBUF,X
.3a253f	d0 fa		bne $3a253b	                BNE skip_to_end
.3a2541	a9 22		lda #$22	                LDA #CHAR_DQUOTE            ; Add the quote to the end of the string
.3a2543	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a2546	a9 00		lda #$00	                LDA #0                      ; And terminate with a NULL
.3a2548	e8		inx		                INX
.3a2549	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a254c	28		plp		done            PLP
.3a254d	2b		pld		                PLD
.3a254e	60		rts		            RTS
.3a254f					PREPROCESS
.3a254f	da		phx		                PHX
.3a2550	5a		phy		                PHY
.3a2551	8b		phb		                PHB
.3a2552	0b		phd		                PHD
.3a2553	08		php		                PHP
.3a2554	08		php		            PHP
.3a2555	c2 20		rep #$20	            REP #$20
.3a2557	48		pha		            PHA
.3a2558	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a255b	5b		tcd		            TCD
.3a255c	68		pla		            PLA
.3a255d	28		plp		            PLP
.3a255e	e2 20		sep #$20	            SEP #$20
.3a2560	c2 10		rep #$10	            REP #$10
.3a2562	ad 00 4f	lda $4f00	                LDA INPUTBUF            ; Check the first character
.3a2565	c9 23		cmp #$23	                CMP #CHAR_DIR           ; Is it the DIR character?
.3a2567	f0 0a		beq $3a2573	                BEQ expand_dir          ; Yes: expand the DIR command into place
.3a2569	c9 7c		cmp #$7c	                CMP #CHAR_BRUN          ; Is it the BRUN character?
.3a256b	f0 17		beq $3a2584	                BEQ expand_brun         ; Yes: expand the BRUN command into place
.3a256d	28		plp		done            PLP
.3a256e	2b		pld		                PLD
.3a256f	ab		plb		                PLB
.3a2570	7a		ply		                PLY
.3a2571	fa		plx		                PLX
.3a2572	60		rts		            RTS
.3a2573					expand_dir
.3a2573	c2 20		rep #$20	            REP #$20
.3a2575	a9 03 00	lda #$0003	                LDA #3                  ; Set size of substitution value
.3a2578	85 8f		sta $088f	                STA MCOUNT
.3a257a	a9 95 25	lda #$2595	                LDA #<>dir_text         ; Set pointer to substitution value
.3a257d	85 55		sta $0855	                STA MARG1
.3a257f	20 e7 24	jsr $3a24e7	            JSR EXPANDLINE
.3a2582	80 e9		bra $3a256d	                BRA done
.3a2584					expand_brun
.3a2584	c2 20		rep #$20	            REP #$20
.3a2586	a9 04 00	lda #$0004	                LDA #4                  ; Set size of substitution value
.3a2589	85 8f		sta $088f	                STA MCOUNT
.3a258b	a9 99 25	lda #$2599	                LDA #<>brun_text        ; Set pointer to substitution value
.3a258e	85 55		sta $0855	                STA MARG1
.3a2590	20 e7 24	jsr $3a24e7	            JSR EXPANDLINE
.3a2593	80 d8		bra $3a256d	                BRA done
>3a2595	44 49 52 00			dir_text        .null "DIR"             ; Expansion of the DIR character
>3a2599	42 52 55 4e 00			brun_text       .null "BRUN"            ; Expansion of the BRUN character
.3a259e					PRREADY
.3a259e	8b		phb		                PHB
.3a259f	08		php		                PHP
.3a25a0	20 e4 00	jsr $3a00e4	            JSR ENSURETEXT
.3a25a3	08		php		            PHP
.3a25a4	e2 20		sep #$20	            SEP #$20
.3a25a6	48		pha		            PHA
.3a25a7	a9 3a		lda #$3a	            LDA #`MPROMPT
.3a25a9	48		pha		            PHA
.3a25aa	ab		plb		            PLB
.3a25ab	68		pla		            PLA
.3a25ac	28		plp		            PLP
.3a25ad	a2 69 d2	ldx #$d269	                LDX #<>MPROMPT
.3a25b0	20 16 03	jsr $3a0316	            JSR PRINTS
.3a25b3	28		plp		                PLP
.3a25b4	ab		plb		                PLB
.3a25b5	60		rts		            RTS
.3a25b6					IREADLINE
.3a25b6	08		php		                PHP
.3a25b7	e2 30		sep #$30	            SEP #$30
.3a25b9	a9 01		lda #$01	                LDA #1
.3a25bb	20 1c 00	jsr $3a001c	            JSR SHOWCURSOR
.3a25be					read_loop
.3a25be	20 db 00	jsr $3a00db	            JSR GETKEYE
.3a25c1	f0 06		beq $3a25c9	                BEQ done
.3a25c3	c9 0d		cmp #$0d	                CMP #CHAR_CR
.3a25c5	f0 02		beq $3a25c9	                BEQ done
.3a25c7	80 f5		bra $3a25be	                BRA read_loop
.3a25c9	28		plp		done            PLP
.3a25ca	60		rts		            RTS
.3a25cb					PROCESS
.3a25cb	0b		phd		                PHD
.3a25cc	08		php		                PHP
.3a25cd	08		php		            PHP
.3a25ce	c2 20		rep #$20	            REP #$20
.3a25d0	48		pha		            PHA
.3a25d1	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a25d4	5b		tcd		            TCD
.3a25d5	68		pla		            PLA
.3a25d6	28		plp		            PLP
.3a25d7	c2 30		rep #$30	            REP #$30
.3a25d9	64 d7		stz $08d7	                STZ LINENUM
.3a25db	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF         ; Attempt to tokenize the line that was read
.3a25de	85 1a		sta $081a	                STA CURLINE
.3a25e0	a9 00 00	lda #$0000	                LDA #`CURLINE
.3a25e3	85 1c		sta $081c	                STA CURLINE+2
.3a25e5	20 4e 08	jsr $3a084e	            JSR TOKENIZE
.3a25e8	c2 20		rep #$20	            REP #$20
.3a25ea	a5 d7		lda $08d7	                LDA LINENUM             ; Did we get a line number?
.3a25ec	d0 05		bne $3a25f3	                BNE update_line         ; Yes: attempt to add it to the program
.3a25ee	20 8e 21	jsr $3a218e	            JSR EXECCMD
.3a25f1	80 07		bra $3a25fa	                BRA done
.3a25f3					update_line
.3a25f3	20 a7 24	jsr $3a24a7	            JSR ADDLINE
.3a25f6	28		plp		no_prompt       PLP
.3a25f7	2b		pld		                PLD
.3a25f8	38		sec		                SEC
.3a25f9	60		rts		            RTS
.3a25fa	28		plp		done            PLP
.3a25fb	2b		pld		                PLD
.3a25fc	18		clc		                CLC
.3a25fd	60		rts		            RTS
.3a25fe					INTERACT
.3a25fe	c2 30		rep #$30	            REP #$30
.3a2600	a2 ff fe	ldx #$feff	                LDX #<>STACK_END
.3a2603	9a		txs		                TXS
.3a2604					ready_loop
.3a2604	20 9e 25	jsr $3a259e	            JSR PRREADY
.3a2607					no_ready_loop
.3a2607	20 08 00	jsr $3a0008	            JSR READLINE
.3a260a	20 0c 00	jsr $3a000c	            JSR SCRCOPYLINE
.3a260d	a9 00 00	lda #$0000	                LDA #0              ; Hide the cursor
.3a2610	20 1c 00	jsr $3a001c	            JSR SHOWCURSOR
.3a2613	20 4f 25	jsr $3a254f	            JSR PREPROCESS
.3a2616	20 cb 25	jsr $3a25cb	            JSR PROCESS
.3a2619	b0 ec		bcs $3a2607	                BCS no_ready_loop
.3a261b	80 e7		bra $3a2604	                BRA ready_loop
>3ad269	0d 52 45 41 44 59 0d 00		MPROMPT         .null 13,"READY",13

;******  Return to file: src\basic816.s


;******  Processing file: src\operators.s

.3a261d					OP_PLUS
.3a261d	08		php		            PHP
.3a261e	e2 20		sep #$20	            SEP #$20
.3a2620	20 55 07	jsr $3a0755	            JSR ASS_ARGS_NUMSTR
.3a2623	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a2625	f0 2c		beq $3a2653	            BEQ is_integer
.3a2627	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a2629	f0 2d		beq $3a2658	            BEQ is_float
.3a262b	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a262d	f0 1f		beq $3a264e	            BEQ is_string
.3a262f					type_error
.3a262f	08		php		            PHP
.3a2630	c2 20		rep #$20	            REP #$20
.3a2632	48		pha		            PHA
.3a2633	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2636	5b		tcd		            TCD
.3a2637	68		pla		            PLA
.3a2638	28		plp		            PLP
.3a2639	e2 20		sep #$20	            SEP #$20
.3a263b	a9 04		lda #$04	            LDA #ERR_TYPE
.3a263d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2641	c2 20		rep #$20	            REP #$20
.3a2643	29 ff 00	and #$00ff	            AND #$00FF
.3a2646	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a2649	e2 20		sep #$20	            SEP #$20
.3a264b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a264e					is_string
.3a264e	20 fe 14	jsr $3a14fe	            JSR STRCONCAT
.3a2651	80 08		bra $3a265b	            BRA done
.3a2653					is_integer
.3a2653	20 ba 51	jsr $3a51ba	            JSR OP_INT_ADD
.3a2656	80 03		bra $3a265b	            BRA done
.3a2658					is_float
.3a2658	20 29 54	jsr $3a5429	            JSR OP_FP_ADD
.3a265b	28		plp		done        PLP
.3a265c	60		rts		            RTS
.3a265d					OP_MINUS
.3a265d	08		php		            PHP
.3a265e	e2 20		sep #$20	            SEP #$20
.3a2660	20 07 07	jsr $3a0707	            JSR ASS_ARGS_NUM
.3a2663	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a2665	f0 23		beq $3a268a	            BEQ is_integer
.3a2667	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a2669	f0 24		beq $3a268f	            BEQ is_float
.3a266b					type_error
.3a266b	08		php		            PHP
.3a266c	c2 20		rep #$20	            REP #$20
.3a266e	48		pha		            PHA
.3a266f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2672	5b		tcd		            TCD
.3a2673	68		pla		            PLA
.3a2674	28		plp		            PLP
.3a2675	e2 20		sep #$20	            SEP #$20
.3a2677	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2679	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a267d	c2 20		rep #$20	            REP #$20
.3a267f	29 ff 00	and #$00ff	            AND #$00FF
.3a2682	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a2685	e2 20		sep #$20	            SEP #$20
.3a2687	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a268a					is_integer
.3a268a	20 cc 51	jsr $3a51cc	            JSR OP_INT_SUB
.3a268d	80 03		bra $3a2692	            BRA done
.3a268f					is_float
.3a268f	20 1e 54	jsr $3a541e	            JSR OP_FP_SUB
.3a2692	28		plp		done        PLP
.3a2693	60		rts		            RTS
.3a2694					OP_MULTIPLY
.3a2694	08		php		            PHP
.3a2695	e2 20		sep #$20	            SEP #$20
.3a2697	20 07 07	jsr $3a0707	            JSR ASS_ARGS_NUM
.3a269a	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a269c	f0 23		beq $3a26c1	            BEQ is_integer
.3a269e	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a26a0	f0 24		beq $3a26c6	            BEQ is_float
.3a26a2					type_error
.3a26a2	08		php		            PHP
.3a26a3	c2 20		rep #$20	            REP #$20
.3a26a5	48		pha		            PHA
.3a26a6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a26a9	5b		tcd		            TCD
.3a26aa	68		pla		            PLA
.3a26ab	28		plp		            PLP
.3a26ac	e2 20		sep #$20	            SEP #$20
.3a26ae	a9 04		lda #$04	            LDA #ERR_TYPE
.3a26b0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a26b4	c2 20		rep #$20	            REP #$20
.3a26b6	29 ff 00	and #$00ff	            AND #$00FF
.3a26b9	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a26bc	e2 20		sep #$20	            SEP #$20
.3a26be	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a26c1					is_integer
.3a26c1	20 de 51	jsr $3a51de	            JSR OP_INT_MUL
.3a26c4	80 03		bra $3a26c9	            BRA done
.3a26c6					is_float
.3a26c6	20 bf 54	jsr $3a54bf	            JSR OP_FP_MUL
.3a26c9	28		plp		done        PLP
.3a26ca	60		rts		            RTS
.3a26cb					OP_DIVIDE
.3a26cb	20 71 06	jsr $3a0671	            JSR ASS_ARG1_FLOAT
.3a26ce	20 a2 06	jsr $3a06a2	            JSR ASS_ARG2_FLOAT
.3a26d1	20 74 54	jsr $3a5474	            JSR OP_FP_DIV
.3a26d4	60		rts		            RTS
.3a26d5					OP_MOD
.3a26d5	a5 23		lda $0823	            LDA ARGUMENT1
.3a26d7	8f 1a 01 00	sta $00011a	            STA @lD1_OPERAND_B
.3a26db	a5 29		lda $0829	            LDA ARGUMENT2
.3a26dd	8f 18 01 00	sta $000118	            STA @lD1_OPERAND_A
.3a26e1	af 1e 01 00	lda $00011e	            LDA @lD1_REMAINDER
.3a26e5	85 23		sta $0823	            STA ARGUMENT1
.3a26e7	60		rts		            RTS
.3a26e8					OP_POW
.3a26e8	08		php		            PHP
.3a26e9	c2 30		rep #$30	            REP #$30
.3a26eb	48		pha		            PHA
.3a26ec	20 71 06	jsr $3a0671	            JSR ASS_ARG1_FLOAT
.3a26ef	a5 2d		lda $082d	            LDA ARGTYPE2
.3a26f1	c9 00 00	cmp #$0000	            CMP #TYPE_INTEGER
.3a26f4	d0 0d		bne $3a2703	            BNE flt_exp
.3a26f6	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a26f8	d0 09		bne $3a2703	            BNE flt_exp
.3a26fa	da		phx		            PHX
.3a26fb	a6 29		ldx $0829	            LDX ARGUMENT2
.3a26fd	20 92 61	jsr $3a6192	            JSR Q_FP_POW_INT
.3a2700	fa		plx		            PLX
.3a2701	80 1c		bra $3a271f	            BRA done
.3a2703					flt_exp
.3a2703	20 a2 06	jsr $3a06a2	            JSR ASS_ARG2_FLOAT
.3a2706	c2 20		rep #$20	            REP #$20
.3a2708	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a270a	48		pha		            PHA
.3a270b	a5 29		lda $0829	            LDA ARGUMENT2
.3a270d	48		pha		            PHA
.3a270e	20 1d 60	jsr $3a601d	            JSR FP_LN
.3a2711	c2 20		rep #$20	            REP #$20
.3a2713	68		pla		            PLA
.3a2714	85 29		sta $0829	            STA ARGUMENT2
.3a2716	68		pla		            PLA
.3a2717	85 2b		sta $082b	            STA ARGUMENT2+2
.3a2719	20 bf 54	jsr $3a54bf	            JSR OP_FP_MUL
.3a271c	20 fc 61	jsr $3a61fc	            JSR FP_EXP
.3a271f	68		pla		done        PLA
.3a2720	28		plp		            PLP
.3a2721	60		rts		            RTS
.3a2722					OP_AND
.3a2722	08		php		            PHP
.3a2723	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a2726	20 34 05	jsr $3a0534	            JSR ASS_ARG2_INT
.3a2729	c2 20		rep #$20	            REP #$20
.3a272b	a5 23		lda $0823	            LDA ARGUMENT1
.3a272d	25 29		and $0829	            AND ARGUMENT2
.3a272f	85 23		sta $0823	            STA ARGUMENT1
.3a2731	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a2733	25 2b		and $082b	            AND ARGUMENT2+2
.3a2735	85 25		sta $0825	            STA ARGUMENT1+2
.3a2737	28		plp		            PLP
.3a2738	60		rts		            RTS
.3a2739					OP_OR
.3a2739	08		php		            PHP
.3a273a	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a273d	20 34 05	jsr $3a0534	            JSR ASS_ARG2_INT
.3a2740	c2 20		rep #$20	            REP #$20
.3a2742	a5 23		lda $0823	            LDA ARGUMENT1
.3a2744	05 29		ora $0829	            ORA ARGUMENT2
.3a2746	85 23		sta $0823	            STA ARGUMENT1
.3a2748	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a274a	05 2b		ora $082b	            ORA ARGUMENT2+2
.3a274c	85 25		sta $0825	            STA ARGUMENT1+2
.3a274e	28		plp		done        PLP
.3a274f	60		rts		            RTS
.3a2750					OP_NOT
.3a2750	08		php		            PHP
.3a2751	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a2754	c2 20		rep #$20	            REP #$20
.3a2756	a5 23		lda $0823	            LDA ARGUMENT1
.3a2758	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a275b	85 23		sta $0823	            STA ARGUMENT1
.3a275d	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a275f	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a2762	85 25		sta $0825	            STA ARGUMENT1+2
.3a2764	28		plp		done        PLP
.3a2765	60		rts		            RTS
.3a2766					OP_LT
.3a2766	08		php		            PHP
.3a2767	e2 20		sep #$20	            SEP #$20
.3a2769	20 55 07	jsr $3a0755	            JSR ASS_ARGS_NUMSTR
.3a276c	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a276e	f0 2c		beq $3a279c	            BEQ is_integer
.3a2770	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a2772	f0 2d		beq $3a27a1	            BEQ is_float
.3a2774	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a2776	f0 1f		beq $3a2797	            BEQ is_string
.3a2778					type_error
.3a2778	08		php		            PHP
.3a2779	c2 20		rep #$20	            REP #$20
.3a277b	48		pha		            PHA
.3a277c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a277f	5b		tcd		            TCD
.3a2780	68		pla		            PLA
.3a2781	28		plp		            PLP
.3a2782	e2 20		sep #$20	            SEP #$20
.3a2784	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2786	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a278a	c2 20		rep #$20	            REP #$20
.3a278c	29 ff 00	and #$00ff	            AND #$00FF
.3a278f	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a2792	e2 20		sep #$20	            SEP #$20
.3a2794	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2797					is_string
.3a2797	20 86 16	jsr $3a1686	            JSR OP_STR_LT
.3a279a	80 08		bra $3a27a4	            BRA done
.3a279c					is_integer
.3a279c	20 df 52	jsr $3a52df	            JSR OP_INT_LT
.3a279f	80 03		bra $3a27a4	            BRA done
.3a27a1					is_float
.3a27a1	20 54 5a	jsr $3a5a54	            JSR OP_FP_LT
.3a27a4	28		plp		done        PLP
.3a27a5	60		rts		            RTS
.3a27a6					OP_GT
.3a27a6	08		php		            PHP
.3a27a7	e2 20		sep #$20	            SEP #$20
.3a27a9	20 55 07	jsr $3a0755	            JSR ASS_ARGS_NUMSTR
.3a27ac	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a27ae	f0 2c		beq $3a27dc	            BEQ is_integer
.3a27b0	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a27b2	f0 2d		beq $3a27e1	            BEQ is_float
.3a27b4	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a27b6	f0 1f		beq $3a27d7	            BEQ is_string
.3a27b8					type_error
.3a27b8	08		php		            PHP
.3a27b9	c2 20		rep #$20	            REP #$20
.3a27bb	48		pha		            PHA
.3a27bc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a27bf	5b		tcd		            TCD
.3a27c0	68		pla		            PLA
.3a27c1	28		plp		            PLP
.3a27c2	e2 20		sep #$20	            SEP #$20
.3a27c4	a9 04		lda #$04	            LDA #ERR_TYPE
.3a27c6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a27ca	c2 20		rep #$20	            REP #$20
.3a27cc	29 ff 00	and #$00ff	            AND #$00FF
.3a27cf	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a27d2	e2 20		sep #$20	            SEP #$20
.3a27d4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a27d7					is_string
.3a27d7	20 9d 16	jsr $3a169d	            JSR OP_STR_GT
.3a27da	80 08		bra $3a27e4	            BRA done
.3a27dc					is_integer
.3a27dc	20 00 53	jsr $3a5300	            JSR OP_INT_GT
.3a27df	80 03		bra $3a27e4	            BRA done
.3a27e1					is_float
.3a27e1	20 69 5a	jsr $3a5a69	            JSR OP_FP_GT
.3a27e4	28		plp		done        PLP
.3a27e5	60		rts		            RTS
.3a27e6					OP_EQ
.3a27e6	08		php		            PHP
.3a27e7	e2 20		sep #$20	            SEP #$20
.3a27e9	20 55 07	jsr $3a0755	            JSR ASS_ARGS_NUMSTR
.3a27ec	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a27ee	f0 2c		beq $3a281c	            BEQ is_integer
.3a27f0	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a27f2	f0 2d		beq $3a2821	            BEQ is_float
.3a27f4	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a27f6	f0 1f		beq $3a2817	            BEQ is_string
.3a27f8					type_error
.3a27f8	08		php		            PHP
.3a27f9	c2 20		rep #$20	            REP #$20
.3a27fb	48		pha		            PHA
.3a27fc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a27ff	5b		tcd		            TCD
.3a2800	68		pla		            PLA
.3a2801	28		plp		            PLP
.3a2802	e2 20		sep #$20	            SEP #$20
.3a2804	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2806	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a280a	c2 20		rep #$20	            REP #$20
.3a280c	29 ff 00	and #$00ff	            AND #$00FF
.3a280f	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a2812	e2 20		sep #$20	            SEP #$20
.3a2814	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2817					is_string
.3a2817	20 b4 16	jsr $3a16b4	            JSR OP_STR_EQ
.3a281a	80 08		bra $3a2824	            BRA done
.3a281c					is_integer
.3a281c	20 2d 53	jsr $3a532d	            JSR OP_INT_EQ
.3a281f	80 03		bra $3a2824	            BRA done
.3a2821					is_float
.3a2821	20 7e 5a	jsr $3a5a7e	            JSR OP_FP_EQ
.3a2824	28		plp		done        PLP
.3a2825	60		rts		            RTS
.3a2826					OP_NE
.3a2826	08		php		            PHP
.3a2827	e2 20		sep #$20	            SEP #$20
.3a2829	20 55 07	jsr $3a0755	            JSR ASS_ARGS_NUMSTR
.3a282c	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a282e	f0 2c		beq $3a285c	            BEQ is_integer
.3a2830	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a2832	f0 2d		beq $3a2861	            BEQ is_float
.3a2834	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a2836	f0 1f		beq $3a2857	            BEQ is_string
.3a2838					type_error
.3a2838	08		php		            PHP
.3a2839	c2 20		rep #$20	            REP #$20
.3a283b	48		pha		            PHA
.3a283c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a283f	5b		tcd		            TCD
.3a2840	68		pla		            PLA
.3a2841	28		plp		            PLP
.3a2842	e2 20		sep #$20	            SEP #$20
.3a2844	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2846	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a284a	c2 20		rep #$20	            REP #$20
.3a284c	29 ff 00	and #$00ff	            AND #$00FF
.3a284f	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a2852	e2 20		sep #$20	            SEP #$20
.3a2854	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2857					is_string
.3a2857	20 cb 16	jsr $3a16cb	            JSR OP_STR_NE
.3a285a	80 08		bra $3a2864	            BRA done
.3a285c					is_integer
.3a285c	20 4b 53	jsr $3a534b	            JSR OP_INT_NE
.3a285f	80 03		bra $3a2864	            BRA done
.3a2861					is_float
.3a2861	20 bd 5a	jsr $3a5abd	            JSR OP_FP_NE
.3a2864	28		plp		done        PLP
.3a2865	60		rts		            RTS
.3a2866					OP_GTE
.3a2866	08		php		            PHP
.3a2867	e2 20		sep #$20	            SEP #$20
.3a2869	20 55 07	jsr $3a0755	            JSR ASS_ARGS_NUMSTR
.3a286c	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a286e	f0 2c		beq $3a289c	            BEQ is_integer
.3a2870	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a2872	f0 2d		beq $3a28a1	            BEQ is_float
.3a2874	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a2876	f0 1f		beq $3a2897	            BEQ is_string
.3a2878					type_error
.3a2878	08		php		            PHP
.3a2879	c2 20		rep #$20	            REP #$20
.3a287b	48		pha		            PHA
.3a287c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a287f	5b		tcd		            TCD
.3a2880	68		pla		            PLA
.3a2881	28		plp		            PLP
.3a2882	e2 20		sep #$20	            SEP #$20
.3a2884	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2886	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a288a	c2 20		rep #$20	            REP #$20
.3a288c	29 ff 00	and #$00ff	            AND #$00FF
.3a288f	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a2892	e2 20		sep #$20	            SEP #$20
.3a2894	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2897					is_string
.3a2897	20 e2 16	jsr $3a16e2	            JSR OP_STR_GTE
.3a289a	80 08		bra $3a28a4	            BRA done
.3a289c					is_integer
.3a289c	20 69 53	jsr $3a5369	            JSR OP_INT_GTE
.3a289f	80 03		bra $3a28a4	            BRA done
.3a28a1					is_float
.3a28a1	20 a8 5a	jsr $3a5aa8	            JSR OP_FP_GTE
.3a28a4	28		plp		done        PLP
.3a28a5	60		rts		            RTS
.3a28a6					OP_LTE
.3a28a6	08		php		            PHP
.3a28a7	e2 20		sep #$20	            SEP #$20
.3a28a9	20 55 07	jsr $3a0755	            JSR ASS_ARGS_NUMSTR
.3a28ac	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a28ae	f0 2c		beq $3a28dc	            BEQ is_integer
.3a28b0	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a28b2	f0 2d		beq $3a28e1	            BEQ is_float
.3a28b4	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a28b6	f0 1f		beq $3a28d7	            BEQ is_string
.3a28b8					type_error
.3a28b8	08		php		            PHP
.3a28b9	c2 20		rep #$20	            REP #$20
.3a28bb	48		pha		            PHA
.3a28bc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a28bf	5b		tcd		            TCD
.3a28c0	68		pla		            PLA
.3a28c1	28		plp		            PLP
.3a28c2	e2 20		sep #$20	            SEP #$20
.3a28c4	a9 04		lda #$04	            LDA #ERR_TYPE
.3a28c6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a28ca	c2 20		rep #$20	            REP #$20
.3a28cc	29 ff 00	and #$00ff	            AND #$00FF
.3a28cf	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a28d2	e2 20		sep #$20	            SEP #$20
.3a28d4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a28d7					is_string
.3a28d7	20 f9 16	jsr $3a16f9	            JSR OP_STR_LTE
.3a28da	80 08		bra $3a28e4	            BRA done
.3a28dc					is_integer
.3a28dc	20 96 53	jsr $3a5396	            JSR OP_INT_LTE
.3a28df	80 03		bra $3a28e4	            BRA done
.3a28e1					is_float
.3a28e1	20 93 5a	jsr $3a5a93	            JSR OP_FP_LTE
.3a28e4	28		plp		done        PLP
.3a28e5	60		rts		            RTS
.3a28e6					OP_NEGATIVE
.3a28e6	08		php		                PHP
.3a28e7	e2 20		sep #$20	            SEP #$20
.3a28e9	a5 27		lda $0827	                LDA ARGTYPE1                ; Check the type of the argument
.3a28eb	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a28ed	f0 2d		beq $3a291c	                BEQ int_negate              ; If integer: negate the integer
.3a28ef	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.3a28f1	f0 1f		beq $3a2912	                BEQ float_negate            ; If floating point: negate the floating point
.3a28f3					type_error
.3a28f3	08		php		            PHP
.3a28f4	c2 20		rep #$20	            REP #$20
.3a28f6	48		pha		            PHA
.3a28f7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a28fa	5b		tcd		            TCD
.3a28fb	68		pla		            PLA
.3a28fc	28		plp		            PLP
.3a28fd	e2 20		sep #$20	            SEP #$20
.3a28ff	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2901	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2905	c2 20		rep #$20	            REP #$20
.3a2907	29 ff 00	and #$00ff	            AND #$00FF
.3a290a	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a290d	e2 20		sep #$20	            SEP #$20
.3a290f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2912					float_negate
.3a2912	e2 20		sep #$20	            SEP #$20
.3a2914	a5 26		lda $0826	                LDA ARGUMENT1+3             ; Flip the sign bit of the floating point number
.3a2916	49 80		eor #$80	                EOR #$80
.3a2918	85 26		sta $0826	                STA ARGUMENT1+3
.3a291a	80 16		bra $3a2932	                BRA done
.3a291c					int_negate
.3a291c	c2 20		rep #$20	            REP #$20
.3a291e	a5 23		lda $0823	                LDA ARGUMENT1               ; Invert ARGUMENT1
.3a2920	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a2923	85 23		sta $0823	                STA ARGUMENT1
.3a2925	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a2927	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a292a	85 25		sta $0825	                STA ARGUMENT1+2
.3a292c	e6 23		inc $0823	                INC ARGUMENT1               ; And increment to get two's complement
.3a292e	d0 02		bne $3a2932	                BNE done
.3a2930	e6 25		inc $0825	                INC ARGUMENT1+2
.3a2932					done
.3a2932	28		plp		                PLP
.3a2933	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\statements.s


;******  Processing file: src\C256/statements_c256.s

=0					GR_LUT_BLUE = 0
=1					GR_LUT_GREEN = 1
=2					GR_LUT_RED = 2
=3					GR_LUT_ALPHA = 3
=640					GR_DEFAULT_COLS = 640               ; Default number of columns in the display
=480					GR_DEFAULT_ROWS = 480               ; Default number of rows in the display
=8					GR_MAX_LUT = 8                      ; The number of LUTs Vicky supports
=64					SP_MAX = 64                         ; The number of sprites Vicky supports
=8					SP_REG_SIZE = 8                     ; The number of bytes in a sprite's register block
=0					SP_CONTROL = 0                      ; Offset of the control regsiter for a sprite
=1					SP_ADDR = 1                         ; Offset of the pixmap address for a sprite
=4					SP_X_COORD = 4                      ; Offset of the X coordinate for a sprite
=6					SP_Y_COORD = 6                      ; Offset of the Y coordinate for a sprite
=12					TILEMAP_REG_SIZE = 12               ; The number of bytes in a tile map's register set
=4					TILESET_REG_SIZE = 4                ; The number of bytes in a tile set's register set
=2					BM_MAX = 2                          ; Maximum number of bitmaps we support
=$0040					MAX_VRAM_VICKY = $0040              ; Upper limit (exclusive) bank address for VRAM in Vicky address space
=$00f0					MAX_VRAM_CPU = $00F0                ; Upper limit (exclusive) bank address for VRAM in CPU address space
=$00b0					MIN_VRAM_CPU = $00B0                ; Lower limit (inclusive) bank address for VRAM in CPU address space
>3af000					GR_BM0_ADDR     .dword ?            ; Address of bitmap 0 (from CPU's perspective)
>3af004					GR_BM1_ADDR     .dword ?            ; Address of bitmap 1 (from CPU's perspective)
>3af008					GR_BM0_VRAM     .dword ?            ; Address of bitmap 0 (relative to start of VRAM)
>3af00c					GR_BM1_VRAM     .dword ?            ; Address of bitmap 1 (relative to start of VRAM)
>3af010					GR_MAX_COLS     .word ?             ; Width the display in pixels
>3af012					GR_MAX_ROWS     .word ?             ; Height of the display in pixels
>3af014					GR_TOTAL_PIXELS .word ?             ; Total number of pixels in the display
>3af016					GR_TEMP         .word ?             ; A temporary word for graphics commands
>3af018					GS_SP_CONTROL   .fill SP_MAX        ; Shadow registers for the sprite controls
.3a2934					S_SETTIME
.3a2934	08		php		                PHP
.3a2935	e2 20		sep #$20	            SEP #$20
.3a2937	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a293a	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a293d	20 60 04	jsr $3a0460	            JSR DIVINT10
.3a2940	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2942	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2943	0a		asl a		                ASL A
.3a2944	0a		asl a		                ASL A
.3a2945	0a		asl a		                ASL A
.3a2946	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2948	48		pha		                PHA
.3a2949	a9 2c		lda #$2c	                LDA #','
.3a294b	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a294e	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2951	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2954	20 60 04	jsr $3a0460	            JSR DIVINT10
.3a2957	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2959	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a295a	0a		asl a		                ASL A
.3a295b	0a		asl a		                ASL A
.3a295c	0a		asl a		                ASL A
.3a295d	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a295f	48		pha		                PHA
.3a2960	a9 2c		lda #$2c	                LDA #','
.3a2962	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a2965	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2968	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a296b	20 60 04	jsr $3a0460	            JSR DIVINT10
.3a296e	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2970	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2971	0a		asl a		                ASL A
.3a2972	0a		asl a		                ASL A
.3a2973	0a		asl a		                ASL A
.3a2974	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2976	48		pha		                PHA
.3a2977	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.3a297b	09 0c		ora #$0c	                ORA #%00001100
.3a297d	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.3a2981	68		pla		                PLA                     ; And seconds to the RTC
.3a2982	8f 00 08 af	sta $af0800	                STA @lRTC_SEC
.3a2986	68		pla		                PLA                     ; Minutes...
.3a2987	8f 02 08 af	sta $af0802	                STA @lRTC_MIN
.3a298b	68		pla		                PLA                     ; Save the hour...
.3a298c	8f 04 08 af	sta $af0804	                STA @lRTC_HRS
.3a2990	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.3a2994	29 f7		and #$f7	                AND #%11110111
.3a2996	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.3a299a	20 a3 1f	jsr $3a1fa3	            JSR SKIPSTMT
.3a299d	28		plp		                PLP
.3a299e	60		rts		            RTS
.3a299f					S_SETDATE
.3a299f	08		php		                PHP
.3a29a0	e2 20		sep #$20	            SEP #$20
.3a29a2	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a29a5	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a29a8	20 60 04	jsr $3a0460	            JSR DIVINT10
.3a29ab	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a29ad	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a29ae	0a		asl a		                ASL A
.3a29af	0a		asl a		                ASL A
.3a29b0	0a		asl a		                ASL A
.3a29b1	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a29b3	48		pha		                PHA
.3a29b4	a9 2c		lda #$2c	                LDA #','
.3a29b6	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a29b9	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a29bc	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a29bf	20 60 04	jsr $3a0460	            JSR DIVINT10
.3a29c2	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a29c4	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a29c5	0a		asl a		                ASL A
.3a29c6	0a		asl a		                ASL A
.3a29c7	0a		asl a		                ASL A
.3a29c8	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a29ca	48		pha		                PHA
.3a29cb	a9 2c		lda #$2c	                LDA #','
.3a29cd	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a29d0	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a29d3	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a29d6	20 96 04	jsr $3a0496	            JSR DIVINT100
.3a29d9	c2 20		rep #$20	            REP #$20
.3a29db	a5 23		lda $0823	                LDA ARGUMENT1           ; Get the century
.3a29dd	85 92		sta $0892	                STA MTEMP               ; Save it in MTEMP
.3a29df	a5 29		lda $0829	                LDA ARGUMENT2           ; Separate the 10s from the 1s digits
.3a29e1	85 23		sta $0823	                STA ARGUMENT1
.3a29e3	20 60 04	jsr $3a0460	            JSR DIVINT10
.3a29e6	e2 20		sep #$20	            SEP #$20
.3a29e8	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a29ea	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a29eb	0a		asl a		                ASL A
.3a29ec	0a		asl a		                ASL A
.3a29ed	0a		asl a		                ASL A
.3a29ee	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a29f0	48		pha		                PHA                     ; Save the 10s and 1s in BCD
.3a29f1	c2 20		rep #$20	            REP #$20
.3a29f3	a5 92		lda $0892	                LDA MTEMP               ; Separate the 100s from the 1000s digits
.3a29f5	85 23		sta $0823	                STA ARGUMENT1
.3a29f7	20 60 04	jsr $3a0460	            JSR DIVINT10
.3a29fa	e2 20		sep #$20	            SEP #$20
.3a29fc	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a29fe	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a29ff	0a		asl a		                ASL A
.3a2a00	0a		asl a		                ASL A
.3a2a01	0a		asl a		                ASL A
.3a2a02	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2a04	48		pha		                PHA                     ; Save the 100s and 1000s in BCD
.3a2a05	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.3a2a09	09 0c		ora #$0c	                ORA #%00001100
.3a2a0b	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.3a2a0f	68		pla		                PLA                     ; Set the century
.3a2a10	8f 0f 08 af	sta $af080f	                STA @lRTC_CENTURY
.3a2a14	68		pla		                PLA                     ; And year to the RTC
.3a2a15	8f 0a 08 af	sta $af080a	                STA @lRTC_YEAR
.3a2a19	68		pla		                PLA                     ; Month...
.3a2a1a	8f 09 08 af	sta $af0809	                STA @lRTC_MONTH
.3a2a1e	68		pla		                PLA                     ; Save the day...
.3a2a1f	8f 06 08 af	sta $af0806	                STA @lRTC_DAY
.3a2a23	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.3a2a27	29 f7		and #$f7	                AND #%11110111
.3a2a29	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.3a2a2d	20 a3 1f	jsr $3a1fa3	            JSR SKIPSTMT
.3a2a30	28		plp		                PLP
.3a2a31	60		rts		            RTS
.3a2a32					S_TEXTCOLOR
.3a2a32	08		php		                PHP
.3a2a33					locals
>0001					L_FOREGROUND    .byte ?
.3a2a33	e2 20		sep #$20	            SEP #$20
.3a2a35	48		pha		            PHA
.3a2a36	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2a39	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2a3c	e2 20		sep #$20	            SEP #$20
.3a2a3e	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the foreground position
.3a2a40	29 0f		and #$0f	                AND #$0F
.3a2a42	0a		asl a		                ASL A
.3a2a43	0a		asl a		                ASL A
.3a2a44	0a		asl a		                ASL A
.3a2a45	0a		asl a		                ASL A
.3a2a46	83 01		sta $01,s	                STA L_FOREGROUND    ; Save the foreground color
.3a2a48	a9 2c		lda #$2c	                LDA #','
.3a2a4a	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a2a4d	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2a50	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2a53	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the background position
.3a2a55	29 0f		and #$0f	                AND #$0F
.3a2a57	03 01		ora $01,s	                ORA L_FOREGROUND    ; Add in the foreground
.3a2a59	8f 1e 00 00	sta $00001e	                STA @lCURCOLOR      ; And save the new color combination
.3a2a5d	e2 20		sep #$20	            SEP #$20
.3a2a5f	68		pla		            PLA
.3a2a60	28		plp		                PLP
.3a2a61	60		rts		            RTS
.3a2a62					S_SETBGCOLOR
.3a2a62	08		php		                PHP
.3a2a63					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.3a2a63	c2 20		rep #$20	            REP #$20
.3a2a65	f4 00 00	pea #$0000	            PEA #0
.3a2a68	e2 20		sep #$20	            SEP #$20
.3a2a6a	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2a6d	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2a70	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.3a2a72	83 01		sta $01,s	                STA L_RED
.3a2a74	a9 2c		lda #$2c	                LDA #','
.3a2a76	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a2a79	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2a7c	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2a7f	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.3a2a81	83 02		sta $02,s	                STA L_GREEN
.3a2a83	a9 2c		lda #$2c	                LDA #','
.3a2a85	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a2a88	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2a8b	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2a8e	a5 23		lda $0823	                LDA ARGUMENT1               ; And set the actual color
.3a2a90	8f 0d 00 af	sta $af000d	                STA @lBACKGROUND_COLOR_B
.3a2a94	a3 02		lda $02,s	                LDA L_GREEN
.3a2a96	8f 0e 00 af	sta $af000e	                STA @lBACKGROUND_COLOR_G
.3a2a9a	a3 01		lda $01,s	                LDA L_RED
.3a2a9c	8f 0f 00 af	sta $af000f	                STA @lBACKGROUND_COLOR_R
.3a2aa0	c2 20		rep #$20	            REP #$20
.3a2aa2	68		pla		            PLA
.3a2aa3	28		plp		                PLP
.3a2aa4	60		rts		            RTS
.3a2aa5					S_SETBORDER
.3a2aa5	08		php		                PHP
.3a2aa6					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.3a2aa6	c2 20		rep #$20	            REP #$20
.3a2aa8	f4 00 00	pea #$0000	            PEA #0
.3a2aab	e2 20		sep #$20	            SEP #$20
.3a2aad	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2ab0	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a2ab3	a5 23		lda $0823	                LDA ARGUMENT1
.3a2ab5	f0 16		beq $3a2acd	                BEQ hide_border
.3a2ab7	a9 01		lda #$01	                LDA #Border_Ctrl_Enable     ; Enable the border
.3a2ab9	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.3a2abd	a9 20		lda #$20	                LDA #BORDER_WIDTH           ; Set the border width
.3a2abf	8f 08 00 af	sta $af0008	                STA BORDER_X_SIZE
.3a2ac3	8f 09 00 af	sta $af0009	                STA BORDER_Y_SIZE
.3a2ac7	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.3a2acb	80 0a		bra $3a2ad7	                BRA get_color
.3a2acd	a9 00		lda #$00	hide_border     LDA #0                      ; Hide the border
.3a2acf	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.3a2ad3	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.3a2ad7	a9 2c		lda #$2c	get_color       LDA #','
.3a2ad9	85 37		sta $0837	                STA TARGETTOK
.3a2adb	20 a0 20	jsr $3a20a0	            JSR OPT_TOK
.3a2ade	90 39		bcc $3a2b19	                BCC done                    ; No: we're done
.3a2ae0	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a2ae3	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2ae6	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2ae9	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.3a2aeb	83 01		sta $01,s	                STA L_RED
.3a2aed	a9 2c		lda #$2c	                LDA #','
.3a2aef	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a2af2	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2af5	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2af8	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.3a2afa	83 02		sta $02,s	                STA L_GREEN
.3a2afc	a9 2c		lda #$2c	                LDA #','
.3a2afe	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a2b01	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2b04	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2b07	a5 23		lda $0823	                LDA ARGUMENT1
.3a2b09	8f 05 00 af	sta $af0005	                STA @lBORDER_COLOR_B        ; Set the border color
.3a2b0d	a3 02		lda $02,s	                LDA L_GREEN
.3a2b0f	8f 06 00 af	sta $af0006	                STA @lBORDER_COLOR_G
.3a2b13	a3 01		lda $01,s	                LDA L_RED
.3a2b15	8f 07 00 af	sta $af0007	                STA @lBORDER_COLOR_R
.3a2b19					done
.3a2b19	c2 20		rep #$20	            REP #$20
.3a2b1b	68		pla		            PLA
.3a2b1c	28		plp		                PLP
.3a2b1d	60		rts		            RTS
.3a2b1e					S_SETCOLOR
.3a2b1e	08		php		                PHP
.3a2b1f					locals
>0001					L_LUT           .byte ?
>0002					L_COLOR         .byte ?
>0003					L_RED           .byte ?
>0004					L_GREEN         .byte ?
>0005					L_BLUE          .byte ?
.3a2b1f	c2 20		rep #$20	            REP #$20
.3a2b21	3b		tsc		            TSC
.3a2b22	38		sec		            SEC
.3a2b23	e9 05 00	sbc #$0005	            SBC #SIZE(locals)
.3a2b26	1b		tcs		            TCS
.3a2b27	e2 20		sep #$20	            SEP #$20
.3a2b29	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2b2c	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2b2f	a5 23		lda $0823	                LDA ARGUMENT1
.3a2b31	c9 0a		cmp #$0a	                CMP #10             ; And in range
.3a2b33	90 1f		bcc $3a2b54	                BLT save_lut
.3a2b35					bad_argument
.3a2b35	08		php		            PHP
.3a2b36	c2 20		rep #$20	            REP #$20
.3a2b38	48		pha		            PHA
.3a2b39	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2b3c	5b		tcd		            TCD
.3a2b3d	68		pla		            PLA
.3a2b3e	28		plp		            PLP
.3a2b3f	e2 20		sep #$20	            SEP #$20
.3a2b41	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a2b43	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2b47	c2 20		rep #$20	            REP #$20
.3a2b49	29 ff 00	and #$00ff	            AND #$00FF
.3a2b4c	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a2b4f	e2 20		sep #$20	            SEP #$20
.3a2b51	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2b54	83 01		sta $01,s	save_lut        STA L_LUT           ; Save as LUT
.3a2b56	a9 2c		lda #$2c	                LDA #','
.3a2b58	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a2b5b	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2b5e	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2b61	a5 23		lda $0823	                LDA ARGUMENT1
.3a2b63	83 02		sta $02,s	                STA L_COLOR         ; Save as COLOR
.3a2b65	a9 2c		lda #$2c	                LDA #','
.3a2b67	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a2b6a	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2b6d	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2b70	a5 23		lda $0823	                LDA ARGUMENT1
.3a2b72	83 03		sta $03,s	                STA L_RED           ; Save as RED
.3a2b74	a9 2c		lda #$2c	                LDA #','
.3a2b76	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a2b79	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2b7c	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2b7f	a5 23		lda $0823	                LDA ARGUMENT1
.3a2b81	83 04		sta $04,s	                STA L_GREEN         ; Save it as GREEN
.3a2b83	a9 2c		lda #$2c	                LDA #','
.3a2b85	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a2b88	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2b8b	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2b8e	a5 23		lda $0823	                LDA ARGUMENT1
.3a2b90	83 05		sta $05,s	                STA L_BLUE          ; Save it as BLUE
.3a2b92	a9 af		lda #$af	                LDA #`GRPH_LUT0_PTR ; Get the bank Vicky is in (should always be $AF)
.3a2b94	85 a0		sta $08a0	                STA MTEMPPTR+2      ; MTEMPPTR will be our pointer to the LUT entry
.3a2b96	a3 01		lda $01,s	                LDA L_LUT           ; Compute the offset to the LUT address
.3a2b98	0a		asl a		                ASL A
.3a2b99	c2 20		rep #$20	            REP #$20
.3a2b9b	29 ff 00	and #$00ff	                AND #$00FF
.3a2b9e	aa		tax		                TAX                 ; Put it in X
.3a2b9f	bf d6 2b 3a	lda $3a2bd6,x	                LDA @llut_address,X ; Get the address of the LUT
.3a2ba3	85 9e		sta $089e	                STA MTEMPPTR        ; Put it in MTEMPPTR
.3a2ba5	e2 20		sep #$20	            SEP #$20
.3a2ba7	a3 02		lda $02,s	                LDA L_COLOR         ; color index *= 4
.3a2ba9	c2 20		rep #$20	            REP #$20
.3a2bab	29 ff 00	and #$00ff	                AND #$00FF
.3a2bae	0a		asl a		                ASL A               ; Since each color has four bytes of data
.3a2baf	0a		asl a		                ASL A
.3a2bb0	18		clc		                CLC                 ; Add the color offset to MTEMPPTR
.3a2bb1	65 9e		adc $089e	                ADC MTEMPPTR
.3a2bb3	85 9e		sta $089e	                STA MTEMPPTR
.3a2bb5	e2 20		sep #$20	            SEP #$20
.3a2bb7	a0 02 00	ldy #$0002	                LDY #GR_LUT_RED
.3a2bba	a3 03		lda $03,s	                LDA L_RED
.3a2bbc	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the red component to the color entry
.3a2bbe	a0 01 00	ldy #$0001	                LDY #GR_LUT_GREEN
.3a2bc1	a3 04		lda $04,s	                LDA L_GREEN
.3a2bc3	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the green component to the color entry
.3a2bc5	a0 00 00	ldy #$0000	                LDY #GR_LUT_BLUE
.3a2bc8	a3 05		lda $05,s	                LDA L_BLUE
.3a2bca	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the blue component to the color entry
.3a2bcc					done
.3a2bcc	c2 20		rep #$20	            REP #$20
.3a2bce	3b		tsc		            TSC
.3a2bcf	18		clc		            CLC
.3a2bd0	69 05 00	adc #$0005	            ADC #SIZE(locals)
.3a2bd3	1b		tcs		            TCS
.3a2bd4	28		plp		                PLP
.3a2bd5	60		rts		            RTS
>3a2bd6	00 20				lut_address     .word <>GRPH_LUT0_PTR
>3a2bd8	00 24				                .word <>GRPH_LUT1_PTR
>3a2bda	00 28				                .word <>GRPH_LUT2_PTR
>3a2bdc	00 2c				                .word <>GRPH_LUT3_PTR
>3a2bde	00 30				                .word <>GRPH_LUT4_PTR
>3a2be0	00 34				                .word <>GRPH_LUT5_PTR
>3a2be2	00 38				                .word <>GRPH_LUT6_PTR
>3a2be4	00 3c				                .word <>GRPH_LUT7_PTR
>3a2be6	40 1f				                .word <>FG_CHAR_LUT_PTR
>3a2be8	80 1f				                .word <>BG_CHAR_LUT_PTR
.3a2bea					S_GRAPHICS
.3a2bea	da		phx		                PHX
.3a2beb	5a		phy		                PHY
.3a2bec	08		php		                PHP
.3a2bed	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2bf0	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a2bf3	c2 20		rep #$20	            REP #$20
.3a2bf5	a5 23		lda $0823	                LDA ARGUMENT1               ; Check to see if we're setting mode to 800x600 or 400x300
.3a2bf7	89 00 01	bit #$0100	                BIT #$0100
.3a2bfa	d0 17		bne $3a2c13	                BNE set_mode                ; Yes: go ahead and set it
.3a2bfc	af 00 00 af	lda $af0000	                LDA @l MASTER_CTRL_REG_L    ; Otherwise, check to see if we're already in 800x600 or 400x300
.3a2c00	89 00 01	bit #$0100	                BIT #$0100
.3a2c03	f0 0e		beq $3a2c13	                BEQ set_mode                ; No: just go ahead and set the mode
.3a2c05	e2 20		sep #$20	            SEP #$20
.3a2c07	a9 00		lda #$00	                LDA #0                      ; Yes: toggle back to 640x480...
.3a2c09	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.3a2c0d	a9 01		lda #$01	                LDA #1                      ; And back to 800x600....
.3a2c0f	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.3a2c13					set_mode
.3a2c13	c2 20		rep #$20	            REP #$20
.3a2c15	a5 23		lda $0823	                LDA ARGUMENT1
.3a2c17	8f 00 00 af	sta $af0000	                STA @l MASTER_CTRL_REG_L    ; Set the graphics mode
.3a2c1b	e2 20		sep #$20	            SEP #$20
.3a2c1d	a5 24		lda $0824	                LDA ARGUMENT1+1             ; Get the screen size bits
.3a2c1f	c2 20		rep #$20	            REP #$20
.3a2c21	29 03 00	and #$0003	                AND #$0003
.3a2c24	0a		asl a		                ASL A                       ; Multiply by two to get the index
.3a2c25	aa		tax		                TAX                         ; X is index into the size tables
.3a2c26	c2 20		rep #$20	            REP #$20
.3a2c28	bf 71 2c 3a	lda $3a2c71,x	                LDA gr_columns,X            ; Set the columns
.3a2c2c	8f 10 f0 3a	sta $3af010	                STA @lGR_MAX_COLS
.3a2c30	bf 79 2c 3a	lda $3a2c79,x	                LDA gr_rows,X               ; Set the rows
.3a2c34	8f 12 f0 3a	sta $3af012	                STA @lGR_MAX_ROWS
.3a2c38	af 10 f0 3a	lda $3af010	                LDA @lGR_MAX_COLS           ; Get the current columns
.3a2c3c	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.3a2c40	af 12 f0 3a	lda $3af012	                LDA @lGR_MAX_ROWS           ; Get the current rows
.3a2c44	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B
.3a2c48	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT             ; Multiply them to get the total pixels
.3a2c4c	8f 14 f0 3a	sta $3af014	                STA @lGR_TOTAL_PIXELS
.3a2c50	e2 20		sep #$20	            SEP #$20
.3a2c52	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.3a2c56	8f 16 f0 3a	sta $3af016	                STA @lGR_TOTAL_PIXELS+2
.3a2c5a	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.3a2c5e					reset_cursor
.3a2c5e	c2 20		rep #$20	            REP #$20
.3a2c60	af 1a 00 00	lda $00001a	                LDA @lCURSORX
.3a2c64	aa		tax		                TAX
.3a2c65	af 1c 00 00	lda $00001c	                LDA @lCURSORY
.3a2c69	a8		tay		                TAY
.3a2c6a	20 20 00	jsr $3a0020	            JSR CURSORXY
.3a2c6d	28		plp		                PLP
.3a2c6e	7a		ply		                PLY
.3a2c6f	fa		plx		                PLX
.3a2c70	60		rts		            RTS
>3a2c71	80 02 20 03 40 01 90 01		gr_columns      .word 640,800,320,400
>3a2c79	e0 01 58 02 f0 00 2c 01		gr_rows         .word 480,600,240,300
>3a2c81	50 00 64 00 28 00 32 00		col_count       .word 80,100,40,50
>3a2c89	3c 00 4b 00 1e 00 32 00		row_count       .word 60,75,30,50
>3a2c91	48 00 5c 00 20 00 2a 00		colb_count      .word 72,92,32,42
>3a2c99	34 00 43 00 16 00 34 00		rowb_count      .word 52,67,22,52
.3a2ca1					BITMAP_SRAM
.3a2ca1	da		phx		                PHX
.3a2ca2	08		php		                PHP
.3a2ca3	c2 30		rep #$30	            REP #$30
.3a2ca5	c9 02 00	cmp #$0002	                CMP #BM_MAX
.3a2ca8	b0 1c		bcs $3a2cc6	                BGE range_err           ; Make sure it's within range
.3a2caa	0a		asl a		                ASL A
.3a2cab	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.3a2cac	aa		tax		                TAX
.3a2cad	bf 00 f0 3a	lda $3af000,x	                LDA @l GR_BM0_ADDR,X    ; Get the low 16-bits of the address
.3a2cb1	85 9e		sta $089e	                STA MTEMPPTR
.3a2cb3	bf 02 f0 3a	lda $3af002,x	                LDA @l GR_BM0_ADDR+2,X  ; Get the high bits of the address
.3a2cb7	85 a0		sta $08a0	                STA MTEMPPTR+2
.3a2cb9	c9 f0 00	cmp #$00f0	                CMP #MAX_VRAM_CPU       ; Check to make sure address is within VRAM
.3a2cbc	b0 08		bcs $3a2cc6	                BGE range_err
.3a2cbe	c9 b0 00	cmp #$00b0	                CMP #MIN_VRAM_CPU
.3a2cc1	90 03		bcc $3a2cc6	                BLT range_err
.3a2cc3	28		plp		                PLP
.3a2cc4	fa		plx		                PLX
.3a2cc5	60		rts		            RTS
.3a2cc6					range_err
.3a2cc6	08		php		            PHP
.3a2cc7	c2 20		rep #$20	            REP #$20
.3a2cc9	48		pha		            PHA
.3a2cca	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2ccd	5b		tcd		            TCD
.3a2cce	68		pla		            PLA
.3a2ccf	28		plp		            PLP
.3a2cd0	e2 20		sep #$20	            SEP #$20
.3a2cd2	a9 09		lda #$09	            LDA #ERR_RANGE
.3a2cd4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2cd8	c2 20		rep #$20	            REP #$20
.3a2cda	29 ff 00	and #$00ff	            AND #$00FF
.3a2cdd	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a2ce0	e2 20		sep #$20	            SEP #$20
.3a2ce2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2ce5					BITMAP_VRAM
.3a2ce5	da		phx		                PHX
.3a2ce6	08		php		                PHP
.3a2ce7	c2 30		rep #$30	            REP #$30
.3a2ce9	c9 02 00	cmp #$0002	                CMP #BM_MAX
.3a2cec	b0 17		bcs $3a2d05	                BGE range_err           ; Make sure it's within range
.3a2cee	0a		asl a		                ASL A
.3a2cef	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.3a2cf0	aa		tax		                TAX
.3a2cf1	bf 08 f0 3a	lda $3af008,x	                LDA @l GR_BM0_VRAM,X    ; Get the low 16-bits of the address
.3a2cf5	85 9e		sta $089e	                STA MTEMPPTR
.3a2cf7	bf 0a f0 3a	lda $3af00a,x	                LDA @l GR_BM0_VRAM+2,X  ; Get the high bits of the address
.3a2cfb	85 a0		sta $08a0	                STA MTEMPPTR+2
.3a2cfd	c9 40 00	cmp #$0040	                CMP #MAX_VRAM_VICKY     ; Check to make sure the address is from $00:0000 - $3F:FFFF
.3a2d00	b0 03		bcs $3a2d05	                BGE range_err           ; If not, throw a range error
.3a2d02	28		plp		                PLP
.3a2d03	fa		plx		                PLX
.3a2d04	60		rts		            RTS
.3a2d05					range_err
.3a2d05	08		php		            PHP
.3a2d06	c2 20		rep #$20	            REP #$20
.3a2d08	48		pha		            PHA
.3a2d09	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2d0c	5b		tcd		            TCD
.3a2d0d	68		pla		            PLA
.3a2d0e	28		plp		            PLP
.3a2d0f	e2 20		sep #$20	            SEP #$20
.3a2d11	a9 09		lda #$09	            LDA #ERR_RANGE
.3a2d13	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2d17	c2 20		rep #$20	            REP #$20
.3a2d19	29 ff 00	and #$00ff	            AND #$00FF
.3a2d1c	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a2d1f	e2 20		sep #$20	            SEP #$20
.3a2d21	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2d24					S_BITMAP
.3a2d24	08		php		                PHP
.3a2d25					locals
>0001					L_PLANE         .word ?
>0003					L_VISIBLE       .byte ?
>0004					L_ADDRESS       .dword ?
.3a2d25	c2 30		rep #$30	            REP #$30
.3a2d27	3b		tsc		                TSC                         ; Allocate space for the locals on the stack
.3a2d28	38		sec		                SEC
.3a2d29	e9 07 00	sbc #$0007	                SBC #SIZE(locals)
.3a2d2c	1b		tcs		                TCS
.3a2d2d	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2d30	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2d33	c2 20		rep #$20	            REP #$20
.3a2d35	a5 23		lda $0823	                LDA ARGUMENT1               ; Make sure it's in range
.3a2d37	c9 02 00	cmp #$0002	                CMP #BM_MAX
.3a2d3a	b0 59		bcs $3a2d95	                BGE range_err               ; If not, throw an error
.3a2d3c	83 01		sta $01,s	                STA L_PLANE                 ; If so, save it to MARG1
.3a2d3e	e2 20		sep #$20	            SEP #$20
.3a2d40	a9 2c		lda #$2c	                LDA #','
.3a2d42	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a2d45	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2d48	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2d4b	a5 23		lda $0823	                LDA ARGUMENT1
.3a2d4d	83 03		sta $03,s	                STA L_VISIBLE
.3a2d4f	a9 2c		lda #$2c	                LDA #','
.3a2d51	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a2d54	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2d57	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2d5a	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the number back
.3a2d5c	0a		asl a		                ASL A                       ; Multiply by 8 to get the offset to the registers
.3a2d5d	0a		asl a		                ASL A
.3a2d5e	0a		asl a		                ASL A
.3a2d5f	aa		tax		                TAX                         ; And save that offset to X
.3a2d60	a3 03		lda $03,s	                LDA L_VISIBLE               ; Check the visible flag
.3a2d62	d0 05		bne $3a2d69	                BNE is_visible              ; If <> 0, it's visible
.3a2d64	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the LUT #
.3a2d66	0a		asl a		                ASL A                       ; Shift it into position for the register
.3a2d67	80 04		bra $3a2d6d	                BRA wr_bm_reg               ; And go to write it
.3a2d69	a5 23		lda $0823	is_visible      LDA ARGUMENT1               ; Get the LUT #
.3a2d6b	38		sec		                SEC
.3a2d6c	2a		rol a		                ROL A                       ; And shift it into position, and set enable bit
.3a2d6d	9f 00 01 af	sta $af0100,x	wr_bm_reg       STA @l BM0_CONTROL_REG,X    ; Write to the bitmap control register
.3a2d71	c2 20		rep #$20	            REP #$20
.3a2d73	a9 2c 00	lda #$002c	                LDA #','
.3a2d76	85 37		sta $0837	                STA TARGETTOK
.3a2d78	20 a0 20	jsr $3a20a0	            JSR OPT_TOK
.3a2d7b	b0 37		bcs $3a2db4	                BCS get_address             ; Yes: parse the address
.3a2d7d	c2 20		rep #$20	            REP #$20
.3a2d7f	08		php		            PHP
.3a2d80	c2 20		rep #$20	            REP #$20
.3a2d82	a9 00 00	lda #$0000	            LDA #<>VRAM
.3a2d85	85 23		sta $0823	            STA ARGUMENT1
.3a2d87	a9 b0 00	lda #$00b0	            LDA #(VRAM >> 16)
.3a2d8a	85 25		sta $0825	            STA ARGUMENT1+2
.3a2d8c	e2 20		sep #$20	            SEP #$20
.3a2d8e	a9 00		lda #$00	            LDA #TYPE_INTEGER
.3a2d90	85 27		sta $0827	            STA ARGUMENT1+4
.3a2d92	28		plp		            PLP
.3a2d93	80 27		bra $3a2dbc	                BRA set_address
.3a2d95					range_err
.3a2d95	08		php		            PHP
.3a2d96	c2 20		rep #$20	            REP #$20
.3a2d98	48		pha		            PHA
.3a2d99	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2d9c	5b		tcd		            TCD
.3a2d9d	68		pla		            PLA
.3a2d9e	28		plp		            PLP
.3a2d9f	e2 20		sep #$20	            SEP #$20
.3a2da1	a9 09		lda #$09	            LDA #ERR_RANGE
.3a2da3	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2da7	c2 20		rep #$20	            REP #$20
.3a2da9	29 ff 00	and #$00ff	            AND #$00FF
.3a2dac	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a2daf	e2 20		sep #$20	            SEP #$20
.3a2db1	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2db4					get_address
.3a2db4	c2 20		rep #$20	            REP #$20
.3a2db6	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a2db9	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2dbc					set_address
.3a2dbc	c2 20		rep #$20	            REP #$20
.3a2dbe	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.3a2dc0	0a		asl a		                ASL A                       ; Multiply by four to get the offset to the address variable
.3a2dc1	0a		asl a		                ASL A
.3a2dc2	aa		tax		                TAX                         ; And put it in X
.3a2dc3	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the CPU-space address
.3a2dc5	9f 00 f0 3a	sta $3af000,x	                STA @l GR_BM0_ADDR,X        ; And save it to the correct GR_BM?_ADDR variable
.3a2dc9	9f 08 f0 3a	sta $3af008,x	                STA @l GR_BM0_VRAM,X
.3a2dcd	83 04		sta $04,s	                STA L_ADDRESS               ; And L_ADDRESS, temporarily
.3a2dcf	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a2dd1	9f 02 f0 3a	sta $3af002,x	                STA @l GR_BM0_ADDR+2,X
.3a2dd5	38		sec		                SEC
.3a2dd6	e9 b0 00	sbc #$00b0	                SBC #`VRAM                  ; Rebase the upper half of the address to Vicky memory space
.3a2dd9	9f 0a f0 3a	sta $3af00a,x	                STA @l GR_BM0_VRAM+2,X
.3a2ddd	83 06		sta $06,s	                STA L_ADDRESS+2             ; And to L_ADDRESS
.3a2ddf	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.3a2de1	0a		asl a		                ASL A                       ; Multiply by eight to get the offset to the registers
.3a2de2	0a		asl a		                ASL A
.3a2de3	0a		asl a		                ASL A
.3a2de4	aa		tax		                TAX                         ; And put it in X
.3a2de5	e2 20		sep #$20	            SEP #$20
.3a2de7	a3 04		lda $04,s	                LDA L_ADDRESS               ; Get the address in Vicky space...
.3a2de9	9f 01 01 af	sta $af0101,x	                STA @l BM0_START_ADDY_L,X   ; Save it to the Vicky registers
.3a2ded	a3 05		lda $05,s	                LDA L_ADDRESS+1
.3a2def	9f 02 01 af	sta $af0102,x	                STA @l BM0_START_ADDY_M,X
.3a2df3	a3 06		lda $06,s	                LDA L_ADDRESS+2
.3a2df5	9f 03 01 af	sta $af0103,x	                STA @l BM0_START_ADDY_H,X
.3a2df9	a9 00		lda #$00	                LDA #0                      ; Default offset to (0, 0)
.3a2dfb	9f 04 01 af	sta $af0104,x	                STA @l BM0_X_OFFSET,X
.3a2dff	9f 05 01 af	sta $af0105,x	                STA @l BM0_Y_OFFSET,X
.3a2e03	c2 30		rep #$30	            REP #$30
.3a2e05	3b		tsc		                TSC                         ; Remove the space for the locals from the stack
.3a2e06	18		clc		                CLC
.3a2e07	69 07 00	adc #$0007	                ADC #SIZE(locals)
.3a2e0a	1b		tcs		                TCS
.3a2e0b	28		plp		                PLP
.3a2e0c	60		rts		            RTS
.3a2e0d					bad_address
.3a2e0d	08		php		            PHP
.3a2e0e	c2 20		rep #$20	            REP #$20
.3a2e10	48		pha		            PHA
.3a2e11	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2e14	5b		tcd		            TCD
.3a2e15	68		pla		            PLA
.3a2e16	28		plp		            PLP
.3a2e17	e2 20		sep #$20	            SEP #$20
.3a2e19	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a2e1b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2e1f	c2 20		rep #$20	            REP #$20
.3a2e21	29 ff 00	and #$00ff	            AND #$00FF
.3a2e24	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a2e27	e2 20		sep #$20	            SEP #$20
.3a2e29	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2e2c					S_CLRBITMAP
.3a2e2c	08		php		                PHP
.3a2e2d	c2 20		rep #$20	            REP #$20
.3a2e2f	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2e32	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2e35	a5 23		lda $0823	                LDA ARGUMENT1
.3a2e37	20 e5 2c	jsr $3a2ce5	            JSR BITMAP_VRAM
.3a2e3a	c2 20		rep #$20	            REP #$20
.3a2e3c	a5 9e		lda $089e	                LDA MTEMPPTR                ; Set the start address and the # of pixels to write
.3a2e3e	8f 05 04 af	sta $af0405	                STA @lVDMA_DST_ADDY_L
.3a2e42	af 14 f0 3a	lda $3af014	                LDA @lGR_TOTAL_PIXELS       ; Set the size
.3a2e46	8f 08 04 af	sta $af0408	                STA @lVDMA_SIZE_L
.3a2e4a	e2 20		sep #$20	            SEP #$20
.3a2e4c	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.3a2e4e	8f 07 04 af	sta $af0407	                STA @lVDMA_DST_ADDY_H
.3a2e52	af 16 f0 3a	lda $3af016	                LDA @lGR_TOTAL_PIXELS+2
.3a2e56	8f 0a 04 af	sta $af040a	                STA @lVDMA_SIZE_H
.3a2e5a	a9 00		lda #$00	                LDA #0                      ; Set the color to write
.3a2e5c	8f 01 04 af	sta $af0401	                STA @lVDMA_BYTE_2_WRITE
.3a2e60	a9 85		lda #$85	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_Start_TRF
.3a2e62	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.3a2e66	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.3a2e6a	30 fa		bmi $3a2e66	                BMI wait
.3a2e6c	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.3a2e6e	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.3a2e72	28		plp		done            PLP
.3a2e73	60		rts		            RTS
=$000855				COLOR = MARG1
=$000859				X0 = MARG2
=$00085d				Y0 = MARG3
=$000861				X1 = MARG4
=$000865				Y1 = MARG5
=$000869				DX = MARG6
=$00086d				DY = MARG7
=$000871				ERR = MARG8
=$000875				ERR2 = MARG9
>08dd					SX      .word ?
>08df					SY      .word ?
.3a2e74					PLOT
.3a2e74	08		php		                PHP
.3a2e75	c2 20		rep #$20	            REP #$20
.3a2e77	a5 5d		lda $085d	                LDA Y0                      ; Get the row
.3a2e79	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.3a2e7d	af 10 f0 3a	lda $3af010	                LDA @lGR_MAX_COLS
.3a2e81	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B          ; Multiply by the number of columns in the pixmap
.3a2e85	18		clc		                CLC                         ; Add the column
.3a2e86	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT
.3a2e8a	65 59		adc $0859	                ADC X0
.3a2e8c	85 0c		sta $080c	                STA SCRATCH
.3a2e8e	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.3a2e92	69 00 00	adc #$0000	                ADC #0
.3a2e95	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH is offset of pixel in the pixmap
.3a2e97	18		clc		                CLC                         ; Add the address of the first pixel
.3a2e98	a5 0c		lda $080c	                LDA SCRATCH
.3a2e9a	65 9e		adc $089e	                ADC MTEMPPTR
.3a2e9c	85 0c		sta $080c	                STA SCRATCH
.3a2e9e	a5 0e		lda $080e	                LDA SCRATCH+2
.3a2ea0	65 a0		adc $08a0	                ADC MTEMPPTR+2
.3a2ea2	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH := pixmap + pixel offset
.3a2ea4	e2 20		sep #$20	            SEP #$20
.3a2ea6	a5 55		lda $0855	                LDA COLOR                   ; Get the color
.3a2ea8	87 0c		sta [$080c]	                STA [SCRATCH]               ; And write the color to the pixel
.3a2eaa	28		plp		                PLP
.3a2eab	60		rts		            RTS
.3a2eac					LINE
.3a2eac	c2 20		rep #$20	            REP #$20
.3a2eae	a9 01 00	lda #$0001	                LDA #1                      ; Assume SX = 1
.3a2eb1	85 dd		sta $08dd	                STA SX
.3a2eb3	38		sec		                SEC                         ; DX := ABS(X1 - X0)
.3a2eb4	a5 61		lda $0861	                LDA X1
.3a2eb6	e5 59		sbc $0859	                SBC X0
.3a2eb8	85 69		sta $0869	                STA DX
.3a2eba	10 0b		bpl $3a2ec7	                BPL abs_Y                   ; If DX < 0 {
.3a2ebc	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DX := -DX
.3a2ebf	1a		inc a		                INC A
.3a2ec0	85 69		sta $0869	                STA DX
.3a2ec2	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SX := -1
.3a2ec5	85 dd		sta $08dd	                STA SX                      ; }
.3a2ec7	a9 01 00	lda #$0001	abs_Y           LDA #1                      ; Assume SY = 1
.3a2eca	85 df		sta $08df	                STA SY
.3a2ecc	38		sec		                SEC                         ; DY := ABS(Y1 - Y0)
.3a2ecd	a5 65		lda $0865	                LDA Y1
.3a2ecf	e5 5d		sbc $085d	                SBC Y0
.3a2ed1	85 6d		sta $086d	                STA DY
.3a2ed3	10 0b		bpl $3a2ee0	                BPL calc_ERR                ; If DY < 0 {
.3a2ed5	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DY := -DY
.3a2ed8	1a		inc a		                INC A
.3a2ed9	85 6d		sta $086d	                STA DY
.3a2edb	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SY := -1
.3a2ede	85 df		sta $08df	                STA SY                      ; }
.3a2ee0	a5 6d		lda $086d	calc_ERR        LDA DY                      ; (DY < DX)
.3a2ee2	c5 69		cmp $0869	                CMP DX
.3a2ee4	b0 04		bcs $3a2eea	                BGE else
.3a2ee6	a5 69		lda $0869	                LDA DX                      ; TRUE CASE: ERR := DX
.3a2ee8	80 06		bra $3a2ef0	                BRA shiftERR
.3a2eea	a5 6d		lda $086d	else            LDA DY                      ; FALSE CASE: ERR := -DY
.3a2eec	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a2eef	1a		inc a		                INC A
.3a2ef0	48		pha		shiftERR        PHA
.3a2ef1	0a		asl a		                ASL A
.3a2ef2	68		pla		                PLA
.3a2ef3	6a		ror a		                ROR A                       ; ERR := ERR / 2
.3a2ef4	85 71		sta $0871	                STA ERR
.3a2ef6					loop
.3a2ef6	20 74 2e	jsr $3a2e74	            JSR PLOT
.3a2ef9	a5 59		lda $0859	                LDA X0                      ; break if X0=X1 and Y0=Y1
.3a2efb	c5 61		cmp $0861	                CMP X1
.3a2efd	d0 06		bne $3a2f05	                BNE calc_ERR2
.3a2eff	a5 5d		lda $085d	                LDA Y0
.3a2f01	c5 65		cmp $0865	                CMP Y1
.3a2f03	f0 36		beq $3a2f3b	                BEQ done
.3a2f05	a5 71		lda $0871	calc_ERR2       LDA ERR                     ; ERR2 := ERR
.3a2f07	85 75		sta $0875	                STA ERR2
.3a2f09	a5 69		lda $0869	                LDA DX                      ; if (ERR2 > -DX) {
.3a2f0b	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a2f0e	1a		inc a		                INC A
.3a2f0f	c5 75		cmp $0875	                CMP ERR2
.3a2f11	10 10		bpl $3a2f23	                BPL check_DY
.3a2f13	f0 0e		beq $3a2f23	                BEQ check_DY
.3a2f15	38		sec		                SEC                         ; ERR -= DY
.3a2f16	a5 71		lda $0871	                LDA ERR
.3a2f18	e5 6d		sbc $086d	                SBC DY
.3a2f1a	85 71		sta $0871	                STA ERR
.3a2f1c	18		clc		                CLC                         ; X0 += SX
.3a2f1d	a5 59		lda $0859	                LDA X0
.3a2f1f	65 dd		adc $08dd	                ADC SX
.3a2f21	85 59		sta $0859	                STA X0                      ; }
.3a2f23	a5 75		lda $0875	check_DY        LDA ERR2                    ; if (ERR2 < DY) {
.3a2f25	c5 6d		cmp $086d	                CMP DY
.3a2f27	10 cd		bpl $3a2ef6	                BPL loop
.3a2f29	f0 cb		beq $3a2ef6	                BEQ loop
.3a2f2b	18		clc		                CLC                         ; ERR += DX
.3a2f2c	a5 71		lda $0871	                LDA ERR
.3a2f2e	65 69		adc $0869	                ADC DX
.3a2f30	85 71		sta $0871	                STA ERR
.3a2f32	18		clc		                CLC                         ; Y0 += SY
.3a2f33	a5 5d		lda $085d	                LDA Y0
.3a2f35	65 df		adc $08df	                ADC SY
.3a2f37	85 5d		sta $085d	                STA Y0                      ; }
.3a2f39	80 bb		bra $3a2ef6	                BRA loop                    ; }
.3a2f3b					done
.3a2f3b	60		rts		            RTS
.3a2f3c					S_PLOT
.3a2f3c	08		php		                PHP
.3a2f3d					locals
>0001					L_PLANE         .word ?
>0003					L_X             .word ?
>0005					L_Y             .word ?
.3a2f3d	c2 20		rep #$20	            REP #$20
.3a2f3f	3b		tsc		            TSC
.3a2f40	38		sec		            SEC
.3a2f41	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.3a2f44	1b		tcs		            TCS
.3a2f45	08		php		            PHP
.3a2f46	c2 20		rep #$20	            REP #$20
.3a2f48	48		pha		            PHA
.3a2f49	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2f4c	5b		tcd		            TCD
.3a2f4d	68		pla		            PLA
.3a2f4e	28		plp		            PLP
.3a2f4f	08		php		            PHP
.3a2f50	e2 20		sep #$20	            SEP #$20
.3a2f52	48		pha		            PHA
.3a2f53	a9 00		lda #$00	            LDA #0
.3a2f55	48		pha		            PHA
.3a2f56	ab		plb		            PLB
.3a2f57	68		pla		            PLA
.3a2f58	28		plp		            PLP
.3a2f59	c2 30		rep #$30	            REP #$30
.3a2f5b	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2f5e	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2f61	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.3a2f63	a9 2c 00	lda #$002c	                LDA #','
.3a2f66	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a2f69	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2f6c	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a2f6f	a5 23		lda $0823	                LDA ARGUMENT1
.3a2f71	83 03		sta $03,s	                STA L_X                     ; Save it to X
.3a2f73	a9 2c 00	lda #$002c	                LDA #','
.3a2f76	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a2f79	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2f7c	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a2f7f	a5 23		lda $0823	                LDA ARGUMENT1
.3a2f81	83 05		sta $05,s	                STA L_Y                     ; Save it to Y
.3a2f83	a9 2c 00	lda #$002c	                LDA #','
.3a2f86	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a2f89	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2f8c	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2f8f	a5 23		lda $0823	                LDA ARGUMENT1
.3a2f91	85 55		sta $0855	                STA COLOR                   ; Save it to MARG1
.3a2f93	a3 03		lda $03,s	                LDA L_X                     ; Set the (X0, Y0) coordinates
.3a2f95	85 59		sta $0859	                STA X0
.3a2f97	a3 05		lda $05,s	                LDA L_Y
.3a2f99	85 5d		sta $085d	                STA Y0
.3a2f9b	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.3a2f9d	20 a1 2c	jsr $3a2ca1	            JSR BITMAP_SRAM
.3a2fa0	20 74 2e	jsr $3a2e74	            JSR PLOT
.3a2fa3	c2 20		rep #$20	            REP #$20
.3a2fa5	3b		tsc		            TSC
.3a2fa6	18		clc		            CLC
.3a2fa7	69 06 00	adc #$0006	            ADC #SIZE(locals)
.3a2faa	1b		tcs		            TCS
.3a2fab	28		plp		                PLP
.3a2fac	60		rts		            RTS
.3a2fad					S_LINE
.3a2fad	08		php		                PHP
.3a2fae					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
.3a2fae	c2 20		rep #$20	            REP #$20
.3a2fb0	3b		tsc		            TSC
.3a2fb1	38		sec		            SEC
.3a2fb2	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.3a2fb5	1b		tcs		            TCS
.3a2fb6	08		php		            PHP
.3a2fb7	c2 20		rep #$20	            REP #$20
.3a2fb9	48		pha		            PHA
.3a2fba	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2fbd	5b		tcd		            TCD
.3a2fbe	68		pla		            PLA
.3a2fbf	28		plp		            PLP
.3a2fc0	08		php		            PHP
.3a2fc1	e2 20		sep #$20	            SEP #$20
.3a2fc3	48		pha		            PHA
.3a2fc4	a9 00		lda #$00	            LDA #0
.3a2fc6	48		pha		            PHA
.3a2fc7	ab		plb		            PLB
.3a2fc8	68		pla		            PLA
.3a2fc9	28		plp		            PLP
.3a2fca	c2 30		rep #$30	            REP #$30
.3a2fcc	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2fcf	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a2fd2	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.3a2fd4	a9 2c 00	lda #$002c	                LDA #','
.3a2fd7	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a2fda	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2fdd	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a2fe0	a5 23		lda $0823	                LDA ARGUMENT1
.3a2fe2	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.3a2fe4	a9 2c 00	lda #$002c	                LDA #','
.3a2fe7	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a2fea	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2fed	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a2ff0	a5 23		lda $0823	                LDA ARGUMENT1
.3a2ff2	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.3a2ff4	a9 2c 00	lda #$002c	                LDA #','
.3a2ff7	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a2ffa	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a2ffd	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a3000	a5 23		lda $0823	                LDA ARGUMENT1
.3a3002	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.3a3004	a9 2c 00	lda #$002c	                LDA #','
.3a3007	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a300a	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a300d	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a3010	a5 23		lda $0823	                LDA ARGUMENT1
.3a3012	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.3a3014	a9 2c 00	lda #$002c	                LDA #','
.3a3017	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a301a	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a301d	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a3020	a5 23		lda $0823	                LDA ARGUMENT1
.3a3022	85 55		sta $0855	                STA COLOR                   ; Save it to COLOR
.3a3024	a3 03		lda $03,s	                LDA L_X0                    ; Set the (X0, Y0) coordinates
.3a3026	85 59		sta $0859	                STA X0
.3a3028	a3 05		lda $05,s	                LDA L_Y0
.3a302a	85 5d		sta $085d	                STA Y0
.3a302c	a3 07		lda $07,s	                LDA L_X1                    ; Set the (X1, Y1) coordinates
.3a302e	85 61		sta $0861	                STA X1
.3a3030	a3 09		lda $09,s	                LDA L_Y1
.3a3032	85 65		sta $0865	                STA Y1
.3a3034	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.3a3036	20 a1 2c	jsr $3a2ca1	            JSR BITMAP_SRAM
.3a3039	20 ac 2e	jsr $3a2eac	            JSR LINE
.3a303c					done
.3a303c	c2 20		rep #$20	            REP #$20
.3a303e	3b		tsc		            TSC
.3a303f	18		clc		            CLC
.3a3040	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.3a3043	1b		tcs		            TCS
.3a3044	28		plp		                PLP
.3a3045	60		rts		            RTS
.3a3046					S_FILL
.3a3046	08		php		                PHP
.3a3047					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
>000b					L_COLOR         .word ?
.3a3047	c2 20		rep #$20	            REP #$20
.3a3049	3b		tsc		            TSC
.3a304a	38		sec		            SEC
.3a304b	e9 0c 00	sbc #$000c	            SBC #SIZE(locals)
.3a304e	1b		tcs		            TCS
.3a304f	08		php		            PHP
.3a3050	c2 20		rep #$20	            REP #$20
.3a3052	48		pha		            PHA
.3a3053	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3056	5b		tcd		            TCD
.3a3057	68		pla		            PLA
.3a3058	28		plp		            PLP
.3a3059	08		php		            PHP
.3a305a	e2 20		sep #$20	            SEP #$20
.3a305c	48		pha		            PHA
.3a305d	a9 00		lda #$00	            LDA #0
.3a305f	48		pha		            PHA
.3a3060	ab		plb		            PLB
.3a3061	68		pla		            PLA
.3a3062	28		plp		            PLP
.3a3063	c2 30		rep #$30	            REP #$30
.3a3065	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3068	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a306b	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.3a306d	a9 2c 00	lda #$002c	                LDA #','
.3a3070	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a3073	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3076	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a3079	a5 23		lda $0823	                LDA ARGUMENT1
.3a307b	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.3a307d	a9 2c 00	lda #$002c	                LDA #','
.3a3080	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a3083	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3086	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a3089	a5 23		lda $0823	                LDA ARGUMENT1
.3a308b	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.3a308d	a9 2c 00	lda #$002c	                LDA #','
.3a3090	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a3093	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3096	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a3099	a5 23		lda $0823	                LDA ARGUMENT1
.3a309b	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.3a309d	a9 2c 00	lda #$002c	                LDA #','
.3a30a0	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a30a3	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a30a6	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a30a9	a5 23		lda $0823	                LDA ARGUMENT1
.3a30ab	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.3a30ad	a9 2c 00	lda #$002c	                LDA #','
.3a30b0	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a30b3	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a30b6	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a30b9	a5 23		lda $0823	                LDA ARGUMENT1
.3a30bb	83 0b		sta $0b,s	                STA L_COLOR                 ; Save it to COLOR
.3a30bd	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.3a30bf	20 e5 2c	jsr $3a2ce5	            JSR BITMAP_VRAM
.3a30c2	a9 07 00	lda #$0007	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_1D_2D
.3a30c5	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a30c9	c2 20		rep #$20	            REP #$20
.3a30cb	a3 05		lda $05,s	                LDA L_Y0                    ; Get the row
.3a30cd	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.3a30d1	af 10 f0 3a	lda $3af010	                LDA @l GR_MAX_COLS
.3a30d5	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B         ; Multiply by the number of columns in the pixmap
.3a30d9	18		clc		                CLC                         ; Add the column
.3a30da	af 04 01 00	lda $000104	                LDA @l M0_RESULT
.3a30de	63 03		adc $03,s	                ADC L_X0
.3a30e0	85 0c		sta $080c	                STA SCRATCH
.3a30e2	e2 20		sep #$20	            SEP #$20
.3a30e4	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.3a30e8	69 00		adc #$00	                ADC #0
.3a30ea	85 0e		sta $080e	                STA SCRATCH+2
.3a30ec	c2 20		rep #$20	            REP #$20
.3a30ee	18		clc		                CLC                         ; Set the destination address
.3a30ef	a5 9e		lda $089e	                LDA MTEMPPTR
.3a30f1	65 0c		adc $080c	                ADC SCRATCH
.3a30f3	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.3a30f7	e2 20		sep #$20	            SEP #$20
.3a30f9	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.3a30fb	65 0e		adc $080e	                ADC SCRATCH+2
.3a30fd	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H
.3a3101	c2 20		rep #$20	            REP #$20
.3a3103	38		sec		                SEC                         ; Set the width of the FILL operation
.3a3104	a3 07		lda $07,s	                LDA L_X1
.3a3106	e3 03		sbc $03,s	                SBC L_X0
.3a3108	85 0c		sta $080c	                STA SCRATCH
.3a310a	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.3a310e	38		sec		                SEC
.3a310f	af 10 f0 3a	lda $3af010	                LDA @l GR_MAX_COLS
.3a3113	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L    ; And the destination stride
.3a3117	38		sec		                SEC                         ; Set the height of the FILL operation
.3a3118	a3 09		lda $09,s	                LDA L_Y1
.3a311a	e3 05		sbc $05,s	                SBC L_Y0
.3a311c	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.3a3120	e2 20		sep #$20	            SEP #$20
.3a3122	a3 0b		lda $0b,s	                LDA L_COLOR                 ; Set the color to write
.3a3124	8f 01 04 af	sta $af0401	                STA @l VDMA_BYTE_2_WRITE
.3a3128	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.3a312c	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF
.3a312e	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a3132	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.3a3136	30 fa		bmi $3a3132	                BMI wait
.3a3138	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.3a313a	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a313e					done
.3a313e	c2 20		rep #$20	            REP #$20
.3a3140	3b		tsc		            TSC
.3a3141	18		clc		            CLC
.3a3142	69 0c 00	adc #$000c	            ADC #SIZE(locals)
.3a3145	1b		tcs		            TCS
.3a3146	28		plp		                PLP
.3a3147	60		rts		            RTS
.3a3148					SPADDR
.3a3148	08		php		                PHP
.3a3149	c2 20		rep #$20	            REP #$20
.3a314b	c9 40 00	cmp #$0040	                CMP #SP_MAX
.3a314e	b0 13		bcs $3a3163	                BGE error
.3a3150	0a		asl a		                ASL A                       ; Multiply it by 8 (the size of s sprite block)
.3a3151	0a		asl a		                ASL A
.3a3152	0a		asl a		                ASL A
.3a3153	18		clc		                CLC                         ; Add it to the address of the first
.3a3154	69 00 0c	adc #$0c00	                ADC #<>SP00_CONTROL_REG     ; sprite block
.3a3157	85 9e		sta $089e	                STA MTEMPPTR
.3a3159	a9 af 00	lda #$00af	                LDA #`SP00_CONTROL_REG
.3a315c	69 00 00	adc #$0000	                ADC #0
.3a315f	85 a0		sta $08a0	                STA MTEMPPTR+2              ; And save that to MTEMPPTR
.3a3161	28		plp		                PLP
.3a3162	60		rts		            RTS
.3a3163					error
.3a3163	08		php		            PHP
.3a3164	c2 20		rep #$20	            REP #$20
.3a3166	48		pha		            PHA
.3a3167	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a316a	5b		tcd		            TCD
.3a316b	68		pla		            PLA
.3a316c	28		plp		            PLP
.3a316d	e2 20		sep #$20	            SEP #$20
.3a316f	a9 09		lda #$09	            LDA #ERR_RANGE
.3a3171	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3175	c2 20		rep #$20	            REP #$20
.3a3177	29 ff 00	and #$00ff	            AND #$00FF
.3a317a	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a317d	e2 20		sep #$20	            SEP #$20
.3a317f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3182					S_SPRITE
.3a3182	08		php		                PHP
.3a3183					locals
>0001					L_SPRITE        .word ?
>0003					L_LUT           .byte ?
.3a3183	c2 20		rep #$20	            REP #$20
.3a3185	3b		tsc		            TSC
.3a3186	38		sec		            SEC
.3a3187	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.3a318a	1b		tcs		            TCS
.3a318b	c2 30		rep #$30	            REP #$30
.3a318d	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3190	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a3193	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.3a3195	a9 2c 00	lda #$002c	                LDA #','
.3a3198	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a319b	e2 20		sep #$20	            SEP #$20
.3a319d	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a31a0	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a31a3	a5 23		lda $0823	                LDA ARGUMENT1
.3a31a5	c9 08		cmp #$08	                CMP #GR_MAX_LUT             ; Check that it's in range
.3a31a7	b0 56		bcs $3a31ff	                BGE error                   ; If not: throw an error
.3a31a9	83 03		sta $03,s	                STA L_LUT                   ; Save it as lut
.3a31ab	a9 2c		lda #$2c	                LDA #','
.3a31ad	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a31b0	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a31b3	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a31b6	c2 20		rep #$20	            REP #$20
.3a31b8	38		sec		                SEC                         ; Adjust address to be in Vicky's space
.3a31b9	a5 23		lda $0823	                LDA ARGUMENT1
.3a31bb	e9 00 00	sbc #$0000	                SBC #<>VRAM
.3a31be	85 23		sta $0823	                STA ARGUMENT1
.3a31c0	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a31c2	e9 b0 00	sbc #$00b0	                SBC #`VRAM
.3a31c5	85 25		sta $0825	                STA ARGUMENT1+2
.3a31c7	30 36		bmi $3a31ff	                BMI error                   ; If negative, throw an error
.3a31c9	c2 20		rep #$20	            REP #$20
.3a31cb	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.3a31cd	aa		tax		                TAX
.3a31ce	20 48 31	jsr $3a3148	            JSR SPADDR
.3a31d1	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the lower word of the address
.3a31d3	a0 01 00	ldy #$0001	                LDY #SP_ADDR
.3a31d6	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a31d8	e2 20		sep #$20	            SEP #$20
.3a31da	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a31dc	c8		iny		                INY
.3a31dd	c8		iny		                INY
.3a31de	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save the upper byte of the address
.3a31e0	bf 18 f0 3a	lda $3af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the sprite control register
.3a31e4	29 f1		and #$f1	                AND #%11110001              ; Filter off the current LUT
.3a31e6	85 0c		sta $080c	                STA SCRATCH
.3a31e8	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT back
.3a31ea	0a		asl a		                ASL A                       ; Sift it into the LUT position
.3a31eb	29 0e		and #$0e	                AND #%00001110              ; Make sure we don't have anything wrong there
.3a31ed	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with what's in the sprite's control
.3a31ef	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the register's bits
.3a31f1	9f 18 f0 3a	sta $3af018,x	                STA @l GS_SP_CONTROL,X      ; And the shadow register
.3a31f5					done
.3a31f5	c2 20		rep #$20	            REP #$20
.3a31f7	3b		tsc		            TSC
.3a31f8	18		clc		            CLC
.3a31f9	69 03 00	adc #$0003	            ADC #SIZE(locals)
.3a31fc	1b		tcs		            TCS
.3a31fd	28		plp		                PLP
.3a31fe	60		rts		            RTS
.3a31ff					error
.3a31ff	08		php		            PHP
.3a3200	c2 20		rep #$20	            REP #$20
.3a3202	48		pha		            PHA
.3a3203	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3206	5b		tcd		            TCD
.3a3207	68		pla		            PLA
.3a3208	28		plp		            PLP
.3a3209	e2 20		sep #$20	            SEP #$20
.3a320b	a9 09		lda #$09	            LDA #ERR_RANGE
.3a320d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3211	c2 20		rep #$20	            REP #$20
.3a3213	29 ff 00	and #$00ff	            AND #$00FF
.3a3216	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3219	e2 20		sep #$20	            SEP #$20
.3a321b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a321e					S_SPRITEAT
.3a321e	08		php		                PHP
.3a321f					locals
>0001					L_SPRITE        .word ?
>0003					L_X             .word ?
.3a321f	c2 20		rep #$20	            REP #$20
.3a3221	3b		tsc		            TSC
.3a3222	38		sec		            SEC
.3a3223	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.3a3226	1b		tcs		            TCS
.3a3227	c2 30		rep #$30	            REP #$30
.3a3229	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a322c	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a322f	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.3a3231	a9 2c 00	lda #$002c	                LDA #','
.3a3234	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a3237	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a323a	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a323d	a5 23		lda $0823	                LDA ARGUMENT1
.3a323f	83 03		sta $03,s	                STA L_X                     ; Save it as X
.3a3241	a9 2c 00	lda #$002c	                LDA #','
.3a3244	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a3247	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a324a	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a324d	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.3a324f	20 48 31	jsr $3a3148	            JSR SPADDR
.3a3252	a3 03		lda $03,s	                LDA L_X                     ; Get the X coordinate
.3a3254	a0 04 00	ldy #$0004	                LDY #SP_X_COORD             ; Save the X coordinate for the sprite
.3a3257	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a3259	a5 23		lda $0823	                LDA ARGUMENT1
.3a325b	a0 06 00	ldy #$0006	                LDY #SP_Y_COORD             ; Save the Y coordinate for the sprite
.3a325e	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a3260					done
.3a3260	c2 20		rep #$20	            REP #$20
.3a3262	3b		tsc		            TSC
.3a3263	18		clc		            CLC
.3a3264	69 04 00	adc #$0004	            ADC #SIZE(locals)
.3a3267	1b		tcs		            TCS
.3a3268	28		plp		                PLP
.3a3269	60		rts		            RTS
.3a326a					S_SPRITESHOW
.3a326a	08		php		                PHP
.3a326b					locals
>0001					L_SPRITE        .word ?
>0003					L_VISIBLE       .byte ?
.3a326b	c2 20		rep #$20	            REP #$20
.3a326d	3b		tsc		            TSC
.3a326e	38		sec		            SEC
.3a326f	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.3a3272	1b		tcs		            TCS
.3a3273	c2 30		rep #$30	            REP #$30
.3a3275	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3278	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a327b	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.3a327d	a9 2c 00	lda #$002c	                LDA #','
.3a3280	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a3283	e2 20		sep #$20	            SEP #$20
.3a3285	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3288	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a328b	a5 23		lda $0823	                LDA ARGUMENT1
.3a328d	d0 04		bne $3a3293	                BNE is_visible
.3a328f	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 0 (not visible)
.3a3291	80 04		bra $3a3297	                BRA chk_layer
.3a3293	a9 01		lda #$01	is_visible      LDA #1
.3a3295	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 1 (visible)
.3a3297	a9 2c		lda #$2c	chk_layer       LDA #','
.3a3299	85 37		sta $0837	                STA TARGETTOK
.3a329b	20 a0 20	jsr $3a20a0	            JSR OPT_TOK
.3a329e	b0 20		bcs $3a32c0	                BCS get_layer               ; Yes: get the layer
.3a32a0					no_layer
.3a32a0	c2 30		rep #$30	            REP #$30
.3a32a2	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.3a32a4	aa		tax		                TAX
.3a32a5	20 48 31	jsr $3a3148	            JSR SPADDR
.3a32a8	e2 20		sep #$20	            SEP #$20
.3a32aa	bf 18 f0 3a	lda $3af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.3a32ae	29 fe		and #$fe	                AND #$FE                    ; Filter out the enable bit
.3a32b0	85 0c		sta $080c	                STA SCRATCH
.3a32b2	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.3a32b4	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.3a32b6	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.3a32b8	9f 18 f0 3a	sta $3af018,x	                STA @l GS_SP_CONTROL,X      ; And save it
.3a32bc	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; ... and to Vicky
.3a32be	80 36		bra $3a32f6	                BRA done
.3a32c0					get_layer
.3a32c0	c2 30		rep #$30	            REP #$30
.3a32c2	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a32c5	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a32c8	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a32cb	a5 23		lda $0823	                LDA ARGUMENT1
.3a32cd	c9 08 00	cmp #$0008	                CMP #8                      ; Make sure it's in range
.3a32d0	b0 2e		bcs $3a3300	                BGE error                   ; If not, throw an out of range error
.3a32d2	0a		asl a		                ASL A                       ; If it's ok... shift it into position
.3a32d3	0a		asl a		                ASL A
.3a32d4	0a		asl a		                ASL A
.3a32d5	0a		asl a		                ASL A
.3a32d6	85 0c		sta $080c	                STA SCRATCH                 ; And save it in SCRATCH
.3a32d8	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.3a32da	aa		tax		                TAX
.3a32db	20 48 31	jsr $3a3148	            JSR SPADDR
.3a32de	e2 20		sep #$20	            SEP #$20
.3a32e0	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.3a32e2	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.3a32e4	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.3a32e6	85 0c		sta $080c	                STA SCRATCH
.3a32e8	bf 18 f0 3a	lda $3af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.3a32ec	29 8e		and #$8e	                AND #%10001110              ; Filter out the enable and layer bits
.3a32ee	05 0c		ora $080c	                ORA SCRATCH                 ; Combine with the provided layer and enable
.3a32f0	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the bits in Vicky
.3a32f2	9f 18 f0 3a	sta $3af018,x	                STA @l GS_SP_CONTROL,X      ; And to the shadow registers
.3a32f6					done
.3a32f6	c2 20		rep #$20	            REP #$20
.3a32f8	3b		tsc		            TSC
.3a32f9	18		clc		            CLC
.3a32fa	69 03 00	adc #$0003	            ADC #SIZE(locals)
.3a32fd	1b		tcs		            TCS
.3a32fe	28		plp		                PLP
.3a32ff	60		rts		            RTS
.3a3300					error
.3a3300	08		php		            PHP
.3a3301	c2 20		rep #$20	            REP #$20
.3a3303	48		pha		            PHA
.3a3304	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3307	5b		tcd		            TCD
.3a3308	68		pla		            PLA
.3a3309	28		plp		            PLP
.3a330a	e2 20		sep #$20	            SEP #$20
.3a330c	a9 09		lda #$09	            LDA #ERR_RANGE
.3a330e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3312	c2 20		rep #$20	            REP #$20
.3a3314	29 ff 00	and #$00ff	            AND #$00FF
.3a3317	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a331a	e2 20		sep #$20	            SEP #$20
.3a331c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a331f					TILESET_ADDR
.3a331f	08		php		                PHP
.3a3320	c2 20		rep #$20	            REP #$20
.3a3322	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.3a3325	b0 19		bcs $3a3340	                BGE out_of_range            ; If not, throw a range error
.3a3327	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.3a332a	a9 04 00	lda #$0004	                LDA #TILESET_REG_SIZE       ; Multiply it by the number of bytes in a tile set register set
.3a332d	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.3a3330	18		clc		                CLC                         ; Add to TILESET0_ADDY_L to get the final address
.3a3331	ad 04 01	lda $0104	                LDA @w M0_RESULT
.3a3334	69 80 02	adc #$0280	                ADC #<>TILESET0_ADDY_L
.3a3337	85 9e		sta $089e	                STA MTEMPPTR
.3a3339	a9 af 00	lda #$00af	                LDA #`TILESET0_ADDY_L
.3a333c	85 a0		sta $08a0	                STA MTEMPPTR+2
.3a333e	28		plp		                PLP
.3a333f	60		rts		            RTS
.3a3340					out_of_range
.3a3340	08		php		            PHP
.3a3341	c2 20		rep #$20	            REP #$20
.3a3343	48		pha		            PHA
.3a3344	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3347	5b		tcd		            TCD
.3a3348	68		pla		            PLA
.3a3349	28		plp		            PLP
.3a334a	e2 20		sep #$20	            SEP #$20
.3a334c	a9 09		lda #$09	            LDA #ERR_RANGE
.3a334e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3352	c2 20		rep #$20	            REP #$20
.3a3354	29 ff 00	and #$00ff	            AND #$00FF
.3a3357	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a335a	e2 20		sep #$20	            SEP #$20
.3a335c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a335f					TILEMAP_ADDR
.3a335f	08		php		                PHP
.3a3360	c2 20		rep #$20	            REP #$20
.3a3362	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.3a3365	b0 19		bcs $3a3380	                BGE out_of_range            ; If not, throw a range error
.3a3367	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.3a336a	a9 0c 00	lda #$000c	                LDA #TILEMAP_REG_SIZE       ; Multiply it by the number of bytes in a tile map register set
.3a336d	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.3a3370	18		clc		                CLC
.3a3371	ad 04 01	lda $0104	                LDA @w M0_RESULT            ; Add to TL0_CONTROL_REG to get the final address
.3a3374	69 00 02	adc #$0200	                ADC #<>TL0_CONTROL_REG
.3a3377	85 9e		sta $089e	                STA MTEMPPTR
.3a3379	a9 af 00	lda #$00af	                LDA #`TL0_CONTROL_REG
.3a337c	85 a0		sta $08a0	                STA MTEMPPTR+2
.3a337e	28		plp		                PLP
.3a337f	60		rts		            RTS
.3a3380					out_of_range
.3a3380	08		php		            PHP
.3a3381	c2 20		rep #$20	            REP #$20
.3a3383	48		pha		            PHA
.3a3384	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3387	5b		tcd		            TCD
.3a3388	68		pla		            PLA
.3a3389	28		plp		            PLP
.3a338a	e2 20		sep #$20	            SEP #$20
.3a338c	a9 09		lda #$09	            LDA #ERR_RANGE
.3a338e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3392	c2 20		rep #$20	            REP #$20
.3a3394	29 ff 00	and #$00ff	            AND #$00FF
.3a3397	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a339a	e2 20		sep #$20	            SEP #$20
.3a339c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a339f					S_TILESET
.3a339f	08		php		                PHP
.3a33a0					locals
>0001					L_TILENUM       .word ?
>0003					L_LUT           .word ?
>0005					L_IS_SQUARE     .word ?
.3a33a0	c2 20		rep #$20	            REP #$20
.3a33a2	3b		tsc		            TSC
.3a33a3	38		sec		            SEC
.3a33a4	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.3a33a7	1b		tcs		            TCS
.3a33a8	c2 20		rep #$20	            REP #$20
.3a33aa	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a33ad	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a33b0	a5 23		lda $0823	                LDA ARGUMENT1
.3a33b2	83 01		sta $01,s	                STA L_TILENUM               ; Save it as the tile set/map number
.3a33b4	a9 2c 00	lda #$002c	                LDA #','
.3a33b7	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a33ba	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a33bd	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a33c0	a5 23		lda $0823	                LDA ARGUMENT1
.3a33c2	83 03		sta $03,s	                STA L_LUT                   ; Save it as LUT
.3a33c4	a9 2c 00	lda #$002c	                LDA #','
.3a33c7	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a33ca	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a33cd	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a33d0	a5 23		lda $0823	                LDA ARGUMENT1
.3a33d2	83 05		sta $05,s	                STA L_IS_SQUARE             ; Save it as IS_SQUARE
.3a33d4	a9 2c 00	lda #$002c	                LDA #','
.3a33d7	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a33da	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a33dd	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a33e0	a3 01		lda $01,s	                LDA L_TILENUM
.3a33e2	20 1f 33	jsr $3a331f	            JSR TILESET_ADDR
.3a33e5	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the bitmap address - the address of the start of VRAM
.3a33e7	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And save it to the registers
.3a33e9	e2 20		sep #$20	            SEP #$20
.3a33eb	38		sec		                SEC
.3a33ec	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a33ee	e9 b0		sbc #$b0	                SBC #`VRAM
.3a33f0	a0 02 00	ldy #$0002	                LDY #TILESET_ADDY_H
.3a33f3	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a33f5	a3 05		lda $05,s	                LDA L_IS_SQUARE             ; Check if is_square == 0?
.3a33f7	d0 0d		bne $3a3406	                BNE is_square
.3a33f9					not_square
.3a33f9	e2 20		sep #$20	            SEP #$20
.3a33fb	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.3a33fd	29 07		and #$07	                AND #$07                    ; Force it to be in range
.3a33ff	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.3a3402	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.3a3404	80 0d		bra $3a3413	                BRA done
.3a3406					is_square
.3a3406	e2 20		sep #$20	            SEP #$20
.3a3408	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.3a340a	29 07		and #$07	                AND #$07                    ; Force it to be in range
.3a340c	09 08		ora #$08	                ORA #TILESET_SQUARE_256     ; Turn on the 256x256 flag
.3a340e	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.3a3411	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.3a3413					done
.3a3413	c2 20		rep #$20	            REP #$20
.3a3415	3b		tsc		            TSC
.3a3416	18		clc		            CLC
.3a3417	69 06 00	adc #$0006	            ADC #SIZE(locals)
.3a341a	1b		tcs		            TCS
.3a341b	28		plp		                PLP
.3a341c	60		rts		            RTS
.3a341d					S_TILEMAP
.3a341d	08		php		                PHP
.3a341e					locals
>0001					L_TILENUM       .word ?
>0003					L_WIDTH         .word ?
>0005					L_HEIGHT        .word ?
.3a341e	c2 20		rep #$20	            REP #$20
.3a3420	3b		tsc		            TSC
.3a3421	38		sec		            SEC
.3a3422	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.3a3425	1b		tcs		            TCS
.3a3426	c2 20		rep #$20	            REP #$20
.3a3428	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a342b	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a342e	a5 23		lda $0823	                LDA ARGUMENT1
.3a3430	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.3a3432	a9 2c 00	lda #$002c	                LDA #','
.3a3435	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a3438	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a343b	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a343e	a5 23		lda $0823	                LDA ARGUMENT1
.3a3440	83 03		sta $03,s	                STA L_WIDTH                 ; Save it as WIDTH
.3a3442	a9 2c 00	lda #$002c	                LDA #','
.3a3445	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a3448	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a344b	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a344e	a5 23		lda $0823	                LDA ARGUMENT1
.3a3450	83 05		sta $05,s	                STA L_HEIGHT                ; Save it as HEIGHT
.3a3452	a9 2c 00	lda #$002c	                LDA #','
.3a3455	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a3458	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a345b	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a345e	a3 01		lda $01,s	                LDA L_TILENUM
.3a3460	20 5f 33	jsr $3a335f	            JSR TILEMAP_ADDR
.3a3463	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the map address - the address of the start of VRAM
.3a3465	a0 01 00	ldy #$0001	                LDY #TILEMAP_START_ADDY
.3a3468	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; And save it to the registers
.3a346a	e2 20		sep #$20	            SEP #$20
.3a346c	38		sec		                SEC
.3a346d	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a346f	e9 b0		sbc #$b0	                SBC #`VRAM
.3a3471	c8		iny		                INY
.3a3472	c8		iny		                INY
.3a3473	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a3475	c2 20		rep #$20	            REP #$20
.3a3477	a3 03		lda $03,s	                LDA L_WIDTH                 ; Set the width
.3a3479	a0 04 00	ldy #$0004	                LDY #TILEMAP_TOTAL_X
.3a347c	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a347e	a3 05		lda $05,s	                LDA L_HEIGHT                ; Set the height
.3a3480	a0 06 00	ldy #$0006	                LDY #TILEMAP_TOTAL_Y
.3a3483	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a3485					done
.3a3485	c2 20		rep #$20	            REP #$20
.3a3487	3b		tsc		            TSC
.3a3488	18		clc		            CLC
.3a3489	69 06 00	adc #$0006	            ADC #SIZE(locals)
.3a348c	1b		tcs		            TCS
.3a348d	28		plp		                PLP
.3a348e	60		rts		            RTS
.3a348f					S_TILESHOW
.3a348f	08		php		                PHP
.3a3490					locals
>0001					L_TILENUM       .word ?
.3a3490	c2 20		rep #$20	            REP #$20
.3a3492	f4 00 00	pea #$0000	            PEA #0
.3a3495	c2 20		rep #$20	            REP #$20
.3a3497	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a349a	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a349d	a5 23		lda $0823	                LDA ARGUMENT1
.3a349f	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.3a34a1	a9 2c 00	lda #$002c	                LDA #','
.3a34a4	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a34a7	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a34aa	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a34ad	a3 01		lda $01,s	                LDA L_TILENUM
.3a34af	20 5f 33	jsr $3a335f	            JSR TILEMAP_ADDR
.3a34b2	a5 23		lda $0823	                LDA ARGUMENT1               ; CHeck the visible parameter
.3a34b4	d0 06		bne $3a34bc	                BNE is_visible              ; If it's <> 0, make it visible
.3a34b6	e2 20		sep #$20	            SEP #$20
.3a34b8	a9 00		lda #$00	                LDA #0                      ; Control value for invisible
.3a34ba	80 04		bra $3a34c0	                BRA set_control
.3a34bc					is_visible
.3a34bc	e2 20		sep #$20	            SEP #$20
.3a34be	a9 01		lda #$01	                LDA #TILEMAP_VISIBLE        ; Control value for visible
.3a34c0					set_control
.3a34c0	e2 20		sep #$20	            SEP #$20
.3a34c2	a0 00 00	ldy #$0000	                LDY #TILEMAP_CONTROL        ; Set the control register
.3a34c5	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a34c7					done
.3a34c7	c2 20		rep #$20	            REP #$20
.3a34c9	68		pla		            PLA
.3a34ca	28		plp		                PLP
.3a34cb	60		rts		            RTS
.3a34cc					S_TILEAT
.3a34cc	08		php		                PHP
.3a34cd					locals
>0001					L_TILENUM       .word ?
>0003					L_X             .word ?
.3a34cd	c2 20		rep #$20	            REP #$20
.3a34cf	3b		tsc		            TSC
.3a34d0	38		sec		            SEC
.3a34d1	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.3a34d4	1b		tcs		            TCS
.3a34d5	c2 20		rep #$20	            REP #$20
.3a34d7	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a34da	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a34dd	a5 23		lda $0823	                LDA ARGUMENT1
.3a34df	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.3a34e1	a9 2c 00	lda #$002c	                LDA #','
.3a34e4	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a34e7	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a34ea	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a34ed	a5 23		lda $0823	                LDA ARGUMENT1
.3a34ef	83 03		sta $03,s	                STA L_X                     ; Save as X
.3a34f1	a9 2c 00	lda #$002c	                LDA #','
.3a34f4	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a34f7	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a34fa	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a34fd	a3 01		lda $01,s	                LDA L_TILENUM
.3a34ff	20 5f 33	jsr $3a335f	            JSR TILEMAP_ADDR
.3a3502	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the Y position
.3a3504	a0 0a 00	ldy #$000a	                LDY #TILEMAP_WINDOW_Y
.3a3507	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a3509	a3 03		lda $03,s	                LDA L_X                     ; Set the X position
.3a350b	a0 08 00	ldy #$0008	                LDY #TILEMAP_WINDOW_X
.3a350e	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a3510					done
.3a3510	c2 20		rep #$20	            REP #$20
.3a3512	3b		tsc		            TSC
.3a3513	18		clc		            CLC
.3a3514	69 04 00	adc #$0004	            ADC #SIZE(locals)
.3a3517	1b		tcs		            TCS
.3a3518	28		plp		                PLP
.3a3519	60		rts		            RTS
=0					DMA_LINEAR = 0                              ; Memory to copy is a continguous, linear range
=1					DMA_RECT = 1                                ; Memory to copy is a rectangular block
.0000					DMA_BLOCK
>0000					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>0001					ADDR            .long ?                     ; The starting address for the data to transfer
>0004					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>0007					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>0009					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>000b					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
=$01					DMA_SRC_2D = $01                            ; Source transfer should be 2D
=$02					DMA_DST_2D = $02                            ; Destination transfer should be 2D
=$10					DMA_SRC_SRAM = $10                          ; Flag indicating that the source is in SRAM ($00:0000 - $3F:FFFF)
=$20					DMA_DST_SRAM = $20                          ; Flag indicating that the destination is in SRAM ($00:0000 - $3F:FFFF)
>3af058					DMA_BLOCKS      .byte ?                     ; What blocks are involved
.3af059					DMA_SRC
>3af059					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>3af05a					ADDR            .long ?                     ; The starting address for the data to transfer
>3af05d					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>3af060					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>3af062					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>3af064					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.3af066					DMA_DEST
>3af066					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>3af067					ADDR            .long ?                     ; The starting address for the data to transfer
>3af06a					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>3af06d					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>3af06f					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>3af071					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.3a351a					DO_DMA
.3a351a	0b		phd		                PHD
.3a351b	08		php		                PHP
.3a351c	08		php		            PHP
.3a351d	c2 20		rep #$20	            REP #$20
.3a351f	48		pha		            PHA
.3a3520	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a3523	5b		tcd		            TCD
.3a3524	68		pla		            PLA
.3a3525	28		plp		            PLP
.3a3526	e2 20		sep #$20	            SEP #$20
.3a3528	a9 00		lda #$00	                LDA #0
.3a352a	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS           ; Set mode to something neutral
.3a352e	af 5c f0 3a	lda $3af05c	                LDA @l DMA_SRC.ADDR+2       ; Check the bank
.3a3532	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.3a3534	b0 1c		bcs $3a3552	                BGE src_vram                ; Yes: leave the DMA_BLOCK bit alone
.3a3536	8f 24 04 af	sta $af0424	src_sram        STA @l SDMA_SRC_ADDY_H      ; Set the SDMA source address
.3a353a	af 5b f0 3a	lda $3af05b	                LDA @l DMA_SRC.ADDR+1
.3a353e	8f 23 04 af	sta $af0423	                STA @l SDMA_SRC_ADDY_M
.3a3542	af 5a f0 3a	lda $3af05a	                LDA @l DMA_SRC.ADDR
.3a3546	8f 22 04 af	sta $af0422	                STA @l SDMA_SRC_ADDY_L
.3a354a	a9 10		lda #$10	                LDA #DMA_SRC_SRAM           ; Set the SRAM source block bit
.3a354c	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS
.3a3550	80 17		bra $3a3569	                BRA src_mode
.3a3552	38		sec		src_vram        SEC                         ; Convert to VRAM relative address
.3a3553	e9 b0		sbc #$b0	                SBC #`VRAM
.3a3555	8f 04 04 af	sta $af0404	                STA @l VDMA_SRC_ADDY_H      ; Set the VDMA source address
.3a3559	af 5b f0 3a	lda $3af05b	                LDA @l DMA_SRC.ADDR+1
.3a355d	8f 03 04 af	sta $af0403	                STA @l VDMA_SRC_ADDY_M
.3a3561	af 5a f0 3a	lda $3af05a	                LDA @l DMA_SRC.ADDR
.3a3565	8f 02 04 af	sta $af0402	                STA @l VDMA_SRC_ADDY_L
.3a3569	af 59 f0 3a	lda $3af059	src_mode        LDA @l DMA_SRC.MODE         ; Determine if source is 1D or 2D
.3a356d	d0 3c		bne $3a35ab	                BNE src_2d
.3a356f	af 58 f0 3a	lda $3af058	src_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.3a3573	f0 1b		beq $3a3590	                BEQ src_1d_vram
.3a3575	af 5d f0 3a	lda $3af05d	src_1d_sram     LDA @l DMA_SRC.SIZE         ; It's SRAM, so set the SDMA size
.3a3579	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.3a357d	af 5e f0 3a	lda $3af05e	                LDA @l DMA_SRC.SIZE+1
.3a3581	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_M
.3a3585	af 5f f0 3a	lda $3af05f	                LDA @l DMA_SRC.SIZE+2
.3a3589	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.3a358d	82 8b 00	brl $3a361b	                BRL set_dst                 ; Go to set up the destination
.3a3590	af 5d f0 3a	lda $3af05d	src_1d_vram     LDA @l DMA_SRC.SIZE         ; It's VRAM, so set the VDMA size
.3a3594	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.3a3598	af 5e f0 3a	lda $3af05e	                LDA @l DMA_SRC.SIZE+1
.3a359c	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_M
.3a35a0	af 5f f0 3a	lda $3af05f	                LDA @l DMA_SRC.SIZE+2
.3a35a4	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.3a35a8	82 70 00	brl $3a361b	                BRL set_dst                 ; Go to set up the destination
.3a35ab	af 58 f0 3a	lda $3af058	src_2d          LDA @l DMA_BLOCKS
.3a35af	09 01		ora #$01	                ORA #DMA_SRC_2D             ; Set the bit to make the source a 2D transfer
.3a35b1	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS
.3a35b5	89 10		bit #$10	                BIT #DMA_SRC_SRAM           ; Are we writing to SRAM
.3a35b7	f0 32		beq $3a35eb	                BEQ src_2d_vram             ; No: set the 2d values in the VRAM source
.3a35b9	af 60 f0 3a	lda $3af060	src_2d_sram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.3a35bd	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.3a35c1	af 61 f0 3a	lda $3af061	                LDA @l DMA_SRC.WIDTH+1
.3a35c5	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.3a35c9	af 62 f0 3a	lda $3af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.3a35cd	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.3a35d1	af 63 f0 3a	lda $3af063	                LDA @l DMA_SRC.HEIGHT+1
.3a35d5	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.3a35d9	af 64 f0 3a	lda $3af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.3a35dd	8f 2c 04 af	sta $af042c	                STA @l SDMA_SRC_STRIDE_L
.3a35e1	af 65 f0 3a	lda $3af065	                LDA @l DMA_SRC.STRIDE+1
.3a35e5	8f 2d 04 af	sta $af042d	                STA @l SDMA_SRC_STRIDE_L+1
.3a35e9	80 30		bra $3a361b	                BRA set_dst
.3a35eb	af 60 f0 3a	lda $3af060	src_2d_vram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.3a35ef	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.3a35f3	af 61 f0 3a	lda $3af061	                LDA @l DMA_SRC.WIDTH+1
.3a35f7	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.3a35fb	af 62 f0 3a	lda $3af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.3a35ff	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.3a3603	af 63 f0 3a	lda $3af063	                LDA @l DMA_SRC.HEIGHT+1
.3a3607	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.3a360b	af 64 f0 3a	lda $3af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.3a360f	8f 0c 04 af	sta $af040c	                STA @l VDMA_SRC_STRIDE_L
.3a3613	af 65 f0 3a	lda $3af065	                LDA @l DMA_SRC.STRIDE+1
.3a3617	8f 0d 04 af	sta $af040d	                STA @l VDMA_SRC_STRIDE_L+1
.3a361b					set_dst
.3a361b	e2 20		sep #$20	            SEP #$20
.3a361d	af 69 f0 3a	lda $3af069	                LDA @l DMA_DEST.ADDR+2      ; Check the bank
.3a3621	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.3a3623	b0 20		bcs $3a3645	                BGE dst_vram                ; Yes: leave the DMA_BLOCK bit alone
.3a3625	8f 27 04 af	sta $af0427	dst_sram        STA @l SDMA_DST_ADDY_H      ; Set the SDMA destination address
.3a3629	af 68 f0 3a	lda $3af068	                LDA @l DMA_DEST.ADDR+1
.3a362d	8f 26 04 af	sta $af0426	                STA @l SDMA_DST_ADDY_M
.3a3631	af 67 f0 3a	lda $3af067	                LDA @l DMA_DEST.ADDR
.3a3635	8f 25 04 af	sta $af0425	                STA @l SDMA_DST_ADDY_L
.3a3639	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS
.3a363d	09 20		ora #$20	                ORA #DMA_DST_SRAM           ; Set the bit to indicate the destination is SRAM
.3a363f	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS
.3a3643	80 17		bra $3a365c	                BRA dst_mode
.3a3645	38		sec		dst_vram        SEC                         ; Convert to VRAM relative address
.3a3646	e9 b0		sbc #$b0	                SBC #`VRAM
.3a3648	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H      ; Set the VDMA destination address
.3a364c	af 68 f0 3a	lda $3af068	                LDA @l DMA_DEST.ADDR+1
.3a3650	8f 06 04 af	sta $af0406	                STA @l VDMA_DST_ADDY_M
.3a3654	af 67 f0 3a	lda $3af067	                LDA @l DMA_DEST.ADDR
.3a3658	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.3a365c	af 66 f0 3a	lda $3af066	dst_mode        LDA @l DMA_DEST.MODE
.3a3660	d0 3e		bne $3a36a0	                BNE dst_2d                  ; If 2D, set up the 2D destination parameters
.3a3662	af 58 f0 3a	lda $3af058	dst_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.3a3666	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Is the destination SRAM?
.3a3668	f0 1b		beq $3a3685	                BEQ dst_1d_vram
.3a366a	af 6a f0 3a	lda $3af06a	dst_1d_sram     LDA @l DMA_DEST.SIZE
.3a366e	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.3a3672	af 6b f0 3a	lda $3af06b	                LDA @l DMA_DEST.SIZE+1
.3a3676	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_L+1
.3a367a	af 6c f0 3a	lda $3af06c	                LDA @l DMA_DEST.SIZE+2
.3a367e	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.3a3682	82 8b 00	brl $3a3710	                BRL start_xfer
.3a3685	af 6a f0 3a	lda $3af06a	dst_1d_vram     LDA @l DMA_DEST.SIZE
.3a3689	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.3a368d	af 6b f0 3a	lda $3af06b	                LDA @l DMA_DEST.SIZE+1
.3a3691	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_L+1
.3a3695	af 6c f0 3a	lda $3af06c	                LDA @l DMA_DEST.SIZE+2
.3a3699	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.3a369d	82 70 00	brl $3a3710	                BRL start_xfer
.3a36a0	af 58 f0 3a	lda $3af058	dst_2d          LDA @l DMA_BLOCKS
.3a36a4	09 02		ora #$02	                ORA #DMA_DST_2D             ; Set the bit to make the source a 2D transfer
.3a36a6	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS
.3a36aa	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Are we writing to the SRAM?
.3a36ac	f0 32		beq $3a36e0	                BEQ dst_2d_vram             ; No: set the 2D parameters for VRAM
.3a36ae	af 6d f0 3a	lda $3af06d	dst_2d_sram     LDA @l DMA_DEST.WIDTH       ; Set the SRAM width
.3a36b2	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.3a36b6	af 6e f0 3a	lda $3af06e	                LDA @L DMA_DEST.WIDTH+1
.3a36ba	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.3a36be	af 6f f0 3a	lda $3af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the SRAM height
.3a36c2	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.3a36c6	af 70 f0 3a	lda $3af070	                LDA @L DMA_DEST.HEIGHT+1
.3a36ca	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.3a36ce	af 71 f0 3a	lda $3af071	                LDA @l DMA_DEST.STRIDE      ; Set the SRAM stride
.3a36d2	8f 2e 04 af	sta $af042e	                STA @l SDMA_DST_STRIDE_L
.3a36d6	af 72 f0 3a	lda $3af072	                LDA @L DMA_DEST.STRIDE+1
.3a36da	8f 2f 04 af	sta $af042f	                STA @l SDMA_DST_STRIDE_L+1
.3a36de	80 30		bra $3a3710	                BRA start_xfer
.3a36e0	af 6d f0 3a	lda $3af06d	dst_2d_vram     LDA @l DMA_DEST.WIDTH       ; Set the VRAM width
.3a36e4	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.3a36e8	af 6e f0 3a	lda $3af06e	                LDA @L DMA_DEST.WIDTH+1
.3a36ec	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.3a36f0	af 6f f0 3a	lda $3af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the VRAM height
.3a36f4	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.3a36f8	af 70 f0 3a	lda $3af070	                LDA @L DMA_DEST.HEIGHT+1
.3a36fc	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.3a3700	af 71 f0 3a	lda $3af071	                LDA @l DMA_DEST.STRIDE      ; Set the VRAM stride
.3a3704	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L
.3a3708	af 72 f0 3a	lda $3af072	                LDA @L DMA_DEST.STRIDE+1
.3a370c	8f 0f 04 af	sta $af040f	                STA @l VDMA_DST_STRIDE_L+1
.3a3710	af 58 f0 3a	lda $3af058	start_xfer      LDA @l DMA_BLOCKS
.3a3714	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.3a3716	f0 43		beq $3a375b	                BEQ start_vdma_only
.3a3718	c9 10		cmp #$10	                CMP #DMA_SRC_SRAM
.3a371a	f0 76		beq $3a3792	                BEQ start_s2v
.3a371c	c9 20		cmp #$20	                CMP #DMA_DST_SRAM
.3a371e	d0 03		bne $3a3723	                BNE start_sdma_only
.3a3720	82 8a 00	brl $3a37ad	                BRL start_v2s
.3a3723					start_sdma_only
.3a3723	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.3a3727	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.3a3729	f0 23		beq $3a374e	                BEQ sdma_1d_only            ; Source and Destination 1D...
.3a372b	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.3a372d	f0 23		beq $3a3752	                BEQ sdma_2d_only            ; Source and Destination 2D
.3a372f	08		php		            PHP
.3a3730	c2 20		rep #$20	            REP #$20
.3a3732	48		pha		            PHA
.3a3733	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3736	5b		tcd		            TCD
.3a3737	68		pla		            PLA
.3a3738	28		plp		            PLP
.3a3739	e2 20		sep #$20	            SEP #$20
.3a373b	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a373d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3741	c2 20		rep #$20	            REP #$20
.3a3743	29 ff 00	and #$00ff	            AND #$00FF
.3a3746	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3749	e2 20		sep #$20	            SEP #$20
.3a374b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a374e	a9 01		lda #$01	sdma_1d_only    LDA #SDMA_CTRL0_Enable      ; Set the bits for 1D, SRAM->SRAM
.3a3750	80 02		bra $3a3754	                BRA sdma_set_ctrl
.3a3752	a9 03		lda #$03	sdma_2d_only    LDA #SDMA_CTRL0_Enable | SDMA_CTRL0_1D_2D
.3a3754	8f 20 04 af	sta $af0420	sdma_set_ctrl   STA @l SDMA_CTRL_REG0
.3a3758	82 7d 00	brl $3a37d8	                BRL trig_sdma               ; And trigger the SDMA
.3a375b					start_vdma_only
.3a375b	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.3a375f	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.3a3761	f0 23		beq $3a3786	                BEQ vdma_1d_only            ; Source and Destination 1D...
.3a3763	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.3a3765	f0 23		beq $3a378a	                BEQ vdma_2d_only            ; Source and Destination 2D...
.3a3767	08		php		            PHP
.3a3768	c2 20		rep #$20	            REP #$20
.3a376a	48		pha		            PHA
.3a376b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a376e	5b		tcd		            TCD
.3a376f	68		pla		            PLA
.3a3770	28		plp		            PLP
.3a3771	e2 20		sep #$20	            SEP #$20
.3a3773	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a3775	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3779	c2 20		rep #$20	            REP #$20
.3a377b	29 ff 00	and #$00ff	            AND #$00FF
.3a377e	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3781	e2 20		sep #$20	            SEP #$20
.3a3783	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3786	a9 01		lda #$01	vdma_1d_only    LDA #VDMA_CTRL_Enable       ; Set the bits for 1D, VRAM->VRAM
.3a3788	80 02		bra $3a378c	                BRA vdma_set_ctrl
.3a378a	a9 03		lda #$03	vdma_2d_only    LDA #VDMA_CTRL_Enable | VDMA_CTRL_1D_2D
.3a378c	8f 00 04 af	sta $af0400	vdma_set_ctrl   STA @l VDMA_CONTROL_REG
.3a3790	80 34		bra $3a37c6	                BRA trig_vdma               ; And trigger the VDMA
.3a3792					start_s2v
.3a3792	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.3a3796	29 01		and #$01	                AND #DMA_SRC_2D
.3a3798	0a		asl a		                ASL A
.3a3799	09 11		ora #$11	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Src
.3a379b	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.3a379f	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.3a37a3	29 02		and #$02	                AND #DMA_DST_2D
.3a37a5	09 11		ora #$11	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Src
.3a37a7	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a37ab	80 19		bra $3a37c6	                BRA trig_vdma               ; And trigger the VDMA
.3a37ad					start_v2s
.3a37ad	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.3a37b1	29 02		and #$02	                AND #DMA_DST_2D
.3a37b3	09 21		ora #$21	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Dst
.3a37b5	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.3a37b9	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.3a37bd	29 01		and #$01	                AND #DMA_SRC_2D
.3a37bf	0a		asl a		                ASL A
.3a37c0	09 21		ora #$21	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Dst
.3a37c2	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a37c6					trig_vdma
.3a37c6	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.3a37ca	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF    ; Trigger the VDMA
.3a37cc	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a37d0	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Check if we need SDMA
.3a37d4	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.3a37d6	f0 0f		beq $3a37e7	                BEQ wait_vdma               ; No: wait for VDMA to complete
.3a37d8					trig_sdma
.3a37d8	af 20 04 af	lda $af0420	                LDA @l SDMA_CTRL_REG0
.3a37dc	09 80		ora #$80	                ORA #SDMA_CTRL0_Start_TRF   ; Trigger the SDMA
.3a37de	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.3a37e2	ea		nop		                NOP                         ; When the transfer is started the CPU will be put on Hold (RDYn)...
.3a37e3	ea		nop		                NOP                         ; Before it actually gets to stop it will execute a couple more instructions
.3a37e4	ea		nop		                NOP                         ; From that point on, the CPU is halted (keep that in mind)
.3a37e5	ea		nop		                NOP                         ; No IRQ will be processed either during that time
.3a37e6	ea		nop		                NOP
.3a37e7	af 01 04 af	lda $af0401	wait_vdma       LDA @l VDMA_STATUS_REG      ; Check the VDMA status
.3a37eb	89 80		bit #$80	                BIT #VDMA_STAT_VDMA_IPS     ; If the transfer is still in process...
.3a37ed	d0 f8		bne $3a37e7	                BNE wait_vdma               ; Wait until it stops.
.3a37ef	a9 00		lda #$00	                LDA #$00                    ; Clear the TRF bits
.3a37f1	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.3a37f5	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a37f9	28		plp		                PLP
.3a37fa	2b		pld		                PLD
.3a37fb	60		rts		            RTS
.3a37fc					S_MEMCOPY
.3a37fc	0b		phd		                PHD
.3a37fd	08		php		                PHP
.3a37fe	e2 20		sep #$20	            SEP #$20
.3a3800	c2 10		rep #$10	            REP #$10
.3a3802	a9 00		lda #$00	                LDA #0
.3a3804	a2 00 00	ldx #$0000	                LDX #0
.3a3807	8f 59 f0 3a	sta $3af059	clr_loop        STA @l DMA_SRC
.3a380b	e8		inx		                INX
.3a380c	e0 1a 00	cpx #$001a	                CPX #SIZE(DMA_BLOCK) * 2
.3a380f	d0 f6		bne $3a3807	                BNE clr_loop
.3a3811	20 bf 20	jsr $3a20bf	            JSR PEEK_TOK
.3a3814	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.3a3816	f0 23		beq $3a383b	                BEQ src_linear                      ; Yes: go to process a linear source
.3a3818	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.3a381a	f0 5e		beq $3a387a	                BEQ src_rect                        ; Yes: go to process a rectangular source
.3a381c					syntax_err
.3a381c	08		php		            PHP
.3a381d	c2 20		rep #$20	            REP #$20
.3a381f	48		pha		            PHA
.3a3820	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3823	5b		tcd		            TCD
.3a3824	68		pla		            PLA
.3a3825	28		plp		            PLP
.3a3826	e2 20		sep #$20	            SEP #$20
.3a3828	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a382a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a382e	c2 20		rep #$20	            REP #$20
.3a3830	29 ff 00	and #$00ff	            AND #$00FF
.3a3833	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3836	e2 20		sep #$20	            SEP #$20
.3a3838	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a383b					src_linear
.3a383b	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a383e	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3841	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a3844	c2 20		rep #$20	            REP #$20
.3a3846	a5 23		lda $0823	            LDA ARGUMENT1
.3a3848	8f 5a f0 3a	sta $3af05a	            STA DMA_SRC.ADDR
.3a384c	e2 20		sep #$20	            SEP #$20
.3a384e	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a3850	8f 5c f0 3a	sta $3af05c	            STA DMA_SRC.ADDR+2
.3a3854	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.3a3856	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a3859	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a385c	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a385f	c2 20		rep #$20	            REP #$20
.3a3861	a5 23		lda $0823	            LDA ARGUMENT1
.3a3863	8f 5d f0 3a	sta $3af05d	            STA DMA_SRC.SIZE
.3a3867	e2 20		sep #$20	            SEP #$20
.3a3869	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a386b	8f 5f f0 3a	sta $3af05f	            STA DMA_SRC.SIZE+2
.3a386f	e2 20		sep #$20	            SEP #$20
.3a3871	a9 00		lda #$00	            LDA #<DMA_LINEAR
.3a3873	8f 59 f0 3a	sta $3af059	            STA DMA_SRC.MODE
.3a3877	82 74 00	brl $3a38ee	                BRL process_to
.3a387a					src_rect
.3a387a	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a387d	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3880	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a3883	c2 20		rep #$20	            REP #$20
.3a3885	a5 23		lda $0823	            LDA ARGUMENT1
.3a3887	8f 5a f0 3a	sta $3af05a	            STA DMA_SRC.ADDR
.3a388b	e2 20		sep #$20	            SEP #$20
.3a388d	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a388f	8f 5c f0 3a	sta $3af05c	            STA DMA_SRC.ADDR+2
.3a3893	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.3a3895	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a3898	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a389b	20 bf 05	jsr $3a05bf	            JSR ASS_ARG1_INT16
.3a389e	c2 20		rep #$20	            REP #$20
.3a38a0	a5 23		lda $0823	            LDA ARGUMENT1
.3a38a2	8f 60 f0 3a	sta $3af060	            STA DMA_SRC.WIDTH
.3a38a6	8d 00 01	sta $0100	            STA M0_OPERAND_A
.3a38a9	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.3a38ac	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a38af	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a38b2	20 bf 05	jsr $3a05bf	            JSR ASS_ARG1_INT16
.3a38b5	c2 20		rep #$20	            REP #$20
.3a38b7	a5 23		lda $0823	            LDA ARGUMENT1
.3a38b9	8f 62 f0 3a	sta $3af062	            STA DMA_SRC.HEIGHT
.3a38bd	8d 02 01	sta $0102	            STA M0_OPERAND_B
.3a38c0	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.3a38c3	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a38c6	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a38c9	20 bf 05	jsr $3a05bf	            JSR ASS_ARG1_INT16
.3a38cc	c2 20		rep #$20	            REP #$20
.3a38ce	a5 23		lda $0823	            LDA ARGUMENT1
.3a38d0	8f 64 f0 3a	sta $3af064	            STA DMA_SRC.STRIDE
.3a38d4	c2 20		rep #$20	            REP #$20
.3a38d6	ad 04 01	lda $0104	            LDA M0_RESULT
.3a38d9	8f 5d f0 3a	sta $3af05d	            STA DMA_SRC.SIZE
.3a38dd	e2 20		sep #$20	            SEP #$20
.3a38df	ad 06 01	lda $0106	            LDA M0_RESULT+2
.3a38e2	8f 5f f0 3a	sta $3af05f	            STA DMA_SRC.SIZE+2
.3a38e6	e2 20		sep #$20	            SEP #$20
.3a38e8	a9 01		lda #$01	            LDA #<DMA_RECT
.3a38ea	8f 59 f0 3a	sta $3af059	            STA DMA_SRC.MODE
.3a38ee					process_to
.3a38ee	e2 20		sep #$20	            SEP #$20
.3a38f0	a9 9c		lda #$9c	                LDA #TOK_TO
.3a38f2	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a38f5	20 bf 20	jsr $3a20bf	            JSR PEEK_TOK
.3a38f8	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.3a38fa	f0 23		beq $3a391f	                BEQ dest_linear                     ; Yes: go to process a linear destination
.3a38fc	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.3a38fe	f0 5e		beq $3a395e	                BEQ dest_rect                       ; Yes: go to process a rectangular source
.3a3900					syntax_err2
.3a3900	08		php		            PHP
.3a3901	c2 20		rep #$20	            REP #$20
.3a3903	48		pha		            PHA
.3a3904	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3907	5b		tcd		            TCD
.3a3908	68		pla		            PLA
.3a3909	28		plp		            PLP
.3a390a	e2 20		sep #$20	            SEP #$20
.3a390c	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a390e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3912	c2 20		rep #$20	            REP #$20
.3a3914	29 ff 00	and #$00ff	            AND #$00FF
.3a3917	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a391a	e2 20		sep #$20	            SEP #$20
.3a391c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a391f					dest_linear
.3a391f	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a3922	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3925	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a3928	c2 20		rep #$20	            REP #$20
.3a392a	a5 23		lda $0823	            LDA ARGUMENT1
.3a392c	8f 67 f0 3a	sta $3af067	            STA DMA_DEST.ADDR
.3a3930	e2 20		sep #$20	            SEP #$20
.3a3932	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a3934	8f 69 f0 3a	sta $3af069	            STA DMA_DEST.ADDR+2
.3a3938	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.3a393a	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a393d	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3940	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a3943	c2 20		rep #$20	            REP #$20
.3a3945	a5 23		lda $0823	            LDA ARGUMENT1
.3a3947	8f 6a f0 3a	sta $3af06a	            STA DMA_DEST.SIZE
.3a394b	e2 20		sep #$20	            SEP #$20
.3a394d	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a394f	8f 6c f0 3a	sta $3af06c	            STA DMA_DEST.SIZE+2
.3a3953	e2 20		sep #$20	            SEP #$20
.3a3955	a9 00		lda #$00	            LDA #<DMA_LINEAR
.3a3957	8f 66 f0 3a	sta $3af066	            STA DMA_DEST.MODE
.3a395b	82 74 00	brl $3a39d2	                BRL verify
.3a395e					dest_rect
.3a395e	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a3961	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3964	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a3967	c2 20		rep #$20	            REP #$20
.3a3969	a5 23		lda $0823	            LDA ARGUMENT1
.3a396b	8f 67 f0 3a	sta $3af067	            STA DMA_DEST.ADDR
.3a396f	e2 20		sep #$20	            SEP #$20
.3a3971	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a3973	8f 69 f0 3a	sta $3af069	            STA DMA_DEST.ADDR+2
.3a3977	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.3a3979	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a397c	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a397f	20 bf 05	jsr $3a05bf	            JSR ASS_ARG1_INT16
.3a3982	c2 20		rep #$20	            REP #$20
.3a3984	a5 23		lda $0823	            LDA ARGUMENT1
.3a3986	8f 6d f0 3a	sta $3af06d	            STA DMA_DEST.WIDTH
.3a398a	8d 00 01	sta $0100	            STA M0_OPERAND_A
.3a398d	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.3a3990	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a3993	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3996	20 bf 05	jsr $3a05bf	            JSR ASS_ARG1_INT16
.3a3999	c2 20		rep #$20	            REP #$20
.3a399b	a5 23		lda $0823	            LDA ARGUMENT1
.3a399d	8f 6f f0 3a	sta $3af06f	            STA DMA_DEST.HEIGHT
.3a39a1	8d 02 01	sta $0102	            STA M0_OPERAND_B
.3a39a4	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.3a39a7	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a39aa	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a39ad	20 bf 05	jsr $3a05bf	            JSR ASS_ARG1_INT16
.3a39b0	c2 20		rep #$20	            REP #$20
.3a39b2	a5 23		lda $0823	            LDA ARGUMENT1
.3a39b4	8f 71 f0 3a	sta $3af071	            STA DMA_DEST.STRIDE
.3a39b8	c2 20		rep #$20	            REP #$20
.3a39ba	ad 04 01	lda $0104	            LDA M0_RESULT
.3a39bd	8f 6a f0 3a	sta $3af06a	            STA DMA_DEST.SIZE
.3a39c1	e2 20		sep #$20	            SEP #$20
.3a39c3	ad 06 01	lda $0106	            LDA M0_RESULT+2
.3a39c6	8f 6c f0 3a	sta $3af06c	            STA DMA_DEST.SIZE+2
.3a39ca	e2 20		sep #$20	            SEP #$20
.3a39cc	a9 01		lda #$01	            LDA #<DMA_RECT
.3a39ce	8f 66 f0 3a	sta $3af066	            STA DMA_DEST.MODE
.3a39d2					verify
.3a39d2	c2 20		rep #$20	            REP #$20
.3a39d4	af 5d f0 3a	lda $3af05d	                LDA @l DMA_SRC.SIZE
.3a39d8	cf 6a f0 3a	cmp $3af06a	                CMP @l DMA_DEST.SIZE
.3a39dc	d0 14		bne $3a39f2	                BNE size_err
.3a39de	e2 20		sep #$20	            SEP #$20
.3a39e0	af 5f f0 3a	lda $3af05f	                LDA @l DMA_SRC.SIZE+2
.3a39e4	cf 6c f0 3a	cmp $3af06c	                CMP @l DMA_DEST.SIZE+2
.3a39e8	d0 08		bne $3a39f2	                BNE size_err
.3a39ea	c2 20		rep #$20	            REP #$20
.3a39ec	20 1a 35	jsr $3a351a	            JSR DO_DMA
.3a39ef	28		plp		                PLP
.3a39f0	2b		pld		                PLD
.3a39f1	60		rts		            RTS
.3a39f2					size_err
.3a39f2	08		php		            PHP
.3a39f3	c2 20		rep #$20	            REP #$20
.3a39f5	48		pha		            PHA
.3a39f6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a39f9	5b		tcd		            TCD
.3a39fa	68		pla		            PLA
.3a39fb	28		plp		            PLP
.3a39fc	e2 20		sep #$20	            SEP #$20
.3a39fe	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a3a00	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3a04	c2 20		rep #$20	            REP #$20
.3a3a06	29 ff 00	and #$00ff	            AND #$00FF
.3a3a09	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3a0c	e2 20		sep #$20	            SEP #$20
.3a3a0e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3a11					S_LOCATE
.3a3a11	08		php		                PHP
.3a3a12	c2 30		rep #$30	            REP #$30
.3a3a14	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3a17	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a3a1a	a5 23		lda $0823	                LDA ARGUMENT1
.3a3a1c	48		pha		                PHA                         ; Save it for later
.3a3a1d	a9 2c 00	lda #$002c	                LDA #','                    ; Check for the comma separator
.3a3a20	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a3a23	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3a26	20 15 06	jsr $3a0615	            JSR ASS_ARG1_BYTE
.3a3a29	a4 23		ldy $0823	                LDY ARGUMENT1               ; Set Y to the row
.3a3a2b	fa		plx		                PLX                         ; Set X to the column
.3a3a2c	20 20 00	jsr $3a0020	            JSR CURSORXY
.3a3a2f	28		plp		                PLP
.3a3a30	60		rts		            RTS

;******  Return to file: src\statements.s

.3a3a31					S_INPUT
.3a3a31	08		php		                PHP
.3a3a32					varloop
.3a3a32	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a3a35	e2 20		sep #$20	            SEP #$20
.3a3a37	a7 00		lda [$0800]	                LDA [BIP]
.3a3a39	d0 03		bne $3a3a3e	                BNE check_colon
.3a3a3b	4c d6 3a	jmp $3a3ad6	                JMP done            ; If EOL, we're done
.3a3a3e	c9 3a		cmp #$3a	check_colon     CMP #':'
.3a3a40	d0 03		bne $3a3a45	                BNE check_string
.3a3a42	4c d6 3a	jmp $3a3ad6	                JMP done            ; If colon, we're done
.3a3a45	c9 22		cmp #$22	check_string    CMP #CHAR_DQUOTE    ; Is it the start of a string?
.3a3a47	d0 0b		bne $3a3a54	                BNE check_var       ; No: then it should be a variable name
.3a3a49	20 59 1a	jsr $3a1a59	            JSR EVALSTRING
.3a3a4c	20 c2 43	jsr $3a43c2	            JSR PR_STRING
.3a3a4f	a9 3b		lda #$3b	                LDA #';'            ; Look for a semicolon
.3a3a51	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a3a54					check_var
.3a3a54	20 94 03	jsr $3a0394	            JSR ISALPHA
.3a3a57	90 41		bcc $3a3a9a	                BCC syntax_err      ; No: it's a syntax error
.3a3a59	20 68 51	jsr $3a5168	            JSR VAR_FINDNAME
.3a3a5c	90 3c		bcc $3a3a9a	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.3a3a5e	a9 3f		lda #$3f	                LDA #"?"            ; Print a "? " to follow
.3a3a60	20 18 00	jsr $3a0018	            JSR PRINTC
.3a3a63	a9 20		lda #$20	                LDA #CHAR_SP
.3a3a65	20 18 00	jsr $3a0018	            JSR PRINTC
.3a3a68	20 10 00	jsr $3a0010	            JSR INPUTLINE
.3a3a6b	e2 20		sep #$20	            SEP #$20
.3a3a6d	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Check the type of the variable
.3a3a6f	c9 02		cmp #$02	                CMP #TYPE_STRING    ; If it's a string...
.3a3a71	f0 46		beq $3a3ab9	                BEQ in_string       ; ... go to copy the string data
.3a3a73	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; If it's an integer...
.3a3a75	f0 62		beq $3a3ad9	                BEQ in_integer      ; ... go to parse the integer
.3a3a77	c9 01		cmp #$01	                CMP #TYPE_FLOAT     ; If it's a float...
.3a3a79	f0 5d		beq $3a3ad8	                BEQ in_float        ; ... go to parse the float
.3a3a7b	08		php		            PHP
.3a3a7c	c2 20		rep #$20	            REP #$20
.3a3a7e	48		pha		            PHA
.3a3a7f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3a82	5b		tcd		            TCD
.3a3a83	68		pla		            PLA
.3a3a84	28		plp		            PLP
.3a3a85	e2 20		sep #$20	            SEP #$20
.3a3a87	a9 04		lda #$04	            LDA #ERR_TYPE
.3a3a89	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3a8d	c2 20		rep #$20	            REP #$20
.3a3a8f	29 ff 00	and #$00ff	            AND #$00FF
.3a3a92	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3a95	e2 20		sep #$20	            SEP #$20
.3a3a97	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3a9a					syntax_err
.3a3a9a	08		php		            PHP
.3a3a9b	c2 20		rep #$20	            REP #$20
.3a3a9d	48		pha		            PHA
.3a3a9e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3aa1	5b		tcd		            TCD
.3a3aa2	68		pla		            PLA
.3a3aa3	28		plp		            PLP
.3a3aa4	e2 20		sep #$20	            SEP #$20
.3a3aa6	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3aa8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3aac	c2 20		rep #$20	            REP #$20
.3a3aae	29 ff 00	and #$00ff	            AND #$00FF
.3a3ab1	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3ab4	e2 20		sep #$20	            SEP #$20
.3a3ab6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3ab9					in_string
.3a3ab9	c2 20		rep #$20	            REP #$20
.3a3abb	a9 00 4c	lda #$4c00	                LDA #<>IOBUF
.3a3abe	85 23		sta $0823	                STA ARGUMENT1
.3a3ac0	a9 00 00	lda #$0000	                LDA #`IOBUF
.3a3ac3	85 25		sta $0825	                STA ARGUMENT1+2
.3a3ac5	e2 20		sep #$20	            SEP #$20
.3a3ac7	a9 02		lda #$02	                LDA #TYPE_STRING
.3a3ac9	85 27		sta $0827	                STA ARGTYPE1
.3a3acb					save_input
.3a3acb	c2 20		rep #$20	            REP #$20
.3a3acd	20 cb 50	jsr $3a50cb	            JSR VAR_SET
.3a3ad0	a9 0d 00	lda #$000d	                LDA #CHAR_CR        ; Print a newline
.3a3ad3	20 18 00	jsr $3a0018	            JSR PRINTC
.3a3ad6	28		plp		done            PLP
.3a3ad7	60		rts		            RTS
.3a3ad8	ea		nop		in_float        NOP                 ; TODO: flesh out floating point input
.3a3ad9					in_integer
.3a3ad9	c2 20		rep #$20	            REP #$20
.3a3adb	a5 00		lda $0800	                LDA BIP             ; Save the BIP for later use
.3a3add	85 40		sta $0840	                STA SAVEBIP
.3a3adf	a5 02		lda $0802	                LDA BIP+2
.3a3ae1	85 42		sta $0842	                STA SAVEBIP+2
.3a3ae3	a9 00 4c	lda #$4c00	                LDA #<>IOBUF        ; Point to the line that was just input
.3a3ae6	85 00		sta $0800	                STA BIP
.3a3ae8	a9 00 00	lda #$0000	                LDA #`IOBUF
.3a3aeb	85 02		sta $0802	                STA BIP+2
.3a3aed	20 8a 07	jsr $3a078a	            JSR PARSEINT
.3a3af0	c2 20		rep #$20	            REP #$20
.3a3af2	a5 40		lda $0840	                LDA SAVEBIP         ; Restore the BIP
.3a3af4	85 00		sta $0800	                STA BIP
.3a3af6	a5 42		lda $0842	                LDA SAVEBIP+2
.3a3af8	85 02		sta $0802	                STA BIP+2
.3a3afa	80 cf		bra $3a3acb	                BRA save_input
.3a3afc					S_GET
.3a3afc	08		php		                PHP
.3a3afd					varloop
.3a3afd	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a3b00	e2 20		sep #$20	            SEP #$20
.3a3b02	a7 00		lda [$0800]	                LDA [BIP]
.3a3b04	f0 47		beq $3a3b4d	                BEQ done            ; If EOL, we're done
.3a3b06	c9 3a		cmp #$3a	                CMP #':'
.3a3b08	f0 43		beq $3a3b4d	                BEQ done            ; If colon, we're done
.3a3b0a	20 94 03	jsr $3a0394	            JSR ISALPHA
.3a3b0d	90 40		bcc $3a3b4f	                BCC syntax_err      ; No: it's a syntax error
.3a3b0f	20 68 51	jsr $3a5168	            JSR VAR_FINDNAME
.3a3b12	90 3b		bcc $3a3b4f	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.3a3b14	20 ae 13	jsr $3a13ae	            JSR TEMPSTRING
.3a3b17	20 14 00	jsr $3a0014	            JSR GETKEY
.3a3b1a	e2 20		sep #$20	            SEP #$20
.3a3b1c	a0 00 00	ldy #$0000	                LDY #0
.3a3b1f	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a3b21	a9 00		lda #$00	                LDA #0
.3a3b23	c8		iny		                INY
.3a3b24	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a3b26	c2 20		rep #$20	            REP #$20
.3a3b28	a5 16		lda $0816	                LDA STRPTR
.3a3b2a	85 23		sta $0823	                STA ARGUMENT1
.3a3b2c	a5 18		lda $0818	                LDA STRPTR+2
.3a3b2e	85 25		sta $0825	                STA ARGUMENT1+2
.3a3b30	e2 20		sep #$20	            SEP #$20
.3a3b32	a9 02		lda #$02	                LDA #TYPE_STRING
.3a3b34	85 27		sta $0827	                STA ARGTYPE1
.3a3b36	20 cb 50	jsr $3a50cb	            JSR VAR_SET
.3a3b39	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a3b3c	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.3a3b3e	f0 0d		beq $3a3b4d	                BEQ done            ; EOL? We're done
.3a3b40	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.3a3b42	f0 09		beq $3a3b4d	                BEQ done
.3a3b44	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.3a3b46	d0 07		bne $3a3b4f	                BNE syntax_err      ; Nope: syntax error
.3a3b48	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a3b4b	80 b0		bra $3a3afd	                BRA varloop
.3a3b4d	28		plp		done            PLP
.3a3b4e	60		rts		            RTS
.3a3b4f					syntax_err
.3a3b4f	08		php		            PHP
.3a3b50	c2 20		rep #$20	            REP #$20
.3a3b52	48		pha		            PHA
.3a3b53	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3b56	5b		tcd		            TCD
.3a3b57	68		pla		            PLA
.3a3b58	28		plp		            PLP
.3a3b59	e2 20		sep #$20	            SEP #$20
.3a3b5b	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3b5d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3b61	c2 20		rep #$20	            REP #$20
.3a3b63	29 ff 00	and #$00ff	            AND #$00FF
.3a3b66	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3b69	e2 20		sep #$20	            SEP #$20
.3a3b6b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3b6e					S_CALL
.3a3b6e	08		php		                PHP
.3a3b6f	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3b72	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a3b75	e2 20		sep #$20	            SEP #$20
.3a3b77	a9 5c		lda #$5c	                LDA #$5C            ; Set the opcode for JML
.3a3b79	85 a2		sta $08a2	                STA MJUMPINST
.3a3b7b	c2 20		rep #$20	            REP #$20
.3a3b7d	a5 23		lda $0823	                LDA ARGUMENT1
.3a3b7f	85 a3		sta $08a3	                STA MJUMPADDR
.3a3b81	e2 20		sep #$20	            SEP #$20
.3a3b83	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a3b85	85 a5		sta $08a5	                STA MJUMPADDR+2
.3a3b87	e2 20		sep #$20	            SEP #$20
.3a3b89	a9 2c		lda #$2c	                LDA #','
.3a3b8b	85 37		sta $0837	                STA TARGETTOK
.3a3b8d	20 a0 20	jsr $3a20a0	            JSR OPT_TOK
.3a3b90	90 41		bcc $3a3bd3	                BCC launch          ; Not present... go ahead and launch
.3a3b92	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a3b95	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3b98	20 bf 05	jsr $3a05bf	            JSR ASS_ARG1_INT16
.3a3b9b	c2 20		rep #$20	            REP #$20
.3a3b9d	a5 23		lda $0823	                LDA ARGUMENT1
.3a3b9f	85 55		sta $0855	                STA MARG1           ; Save it to MARG1
.3a3ba1	e2 20		sep #$20	            SEP #$20
.3a3ba3	a9 2c		lda #$2c	                LDA #','
.3a3ba5	85 37		sta $0837	                STA TARGETTOK
.3a3ba7	20 a0 20	jsr $3a20a0	            JSR OPT_TOK
.3a3baa	90 27		bcc $3a3bd3	                BCC launch          ; Not present... go ahead and launch
.3a3bac	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a3baf	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3bb2	20 bf 05	jsr $3a05bf	            JSR ASS_ARG1_INT16
.3a3bb5	c2 20		rep #$20	            REP #$20
.3a3bb7	a5 23		lda $0823	                LDA ARGUMENT1
.3a3bb9	85 59		sta $0859	                STA MARG2           ; Save it to MARG2
.3a3bbb	e2 20		sep #$20	            SEP #$20
.3a3bbd	a9 2c		lda #$2c	                LDA #','
.3a3bbf	85 37		sta $0837	                STA TARGETTOK
.3a3bc1	20 a0 20	jsr $3a20a0	            JSR OPT_TOK
.3a3bc4	90 0d		bcc $3a3bd3	                BCC launch          ; Not present... go ahead and launch
.3a3bc6	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a3bc9	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3bcc	20 bf 05	jsr $3a05bf	            JSR ASS_ARG1_INT16
.3a3bcf	c2 20		rep #$20	            REP #$20
.3a3bd1	a4 23		ldy $0823	                LDY ARGUMENT1
.3a3bd3	a6 59		ldx $0859	launch          LDX MARG2
.3a3bd5	a5 55		lda $0855	                LDA MARG1
.3a3bd7	0b		phd		                PHD
.3a3bd8	8b		phb		                PHB
.3a3bd9	08		php		                PHP
.3a3bda	22 a2 08 00	jsl $0008a2	                JSL MJUMPINST       ; Call the subroutine indicated
.3a3bde	28		plp		                PLP
.3a3bdf	ab		plb		                PLB
.3a3be0	2b		pld		                PLD
.3a3be1	20 a3 1f	jsr $3a1fa3	            JSR SKIPSTMT
.3a3be4	28		plp		                PLP
.3a3be5	60		rts		            RTS
.3a3be6					type_err
.3a3be6	08		php		            PHP
.3a3be7	c2 20		rep #$20	            REP #$20
.3a3be9	48		pha		            PHA
.3a3bea	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3bed	5b		tcd		            TCD
.3a3bee	68		pla		            PLA
.3a3bef	28		plp		            PLP
.3a3bf0	e2 20		sep #$20	            SEP #$20
.3a3bf2	a9 04		lda #$04	            LDA #ERR_TYPE
.3a3bf4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3bf8	c2 20		rep #$20	            REP #$20
.3a3bfa	29 ff 00	and #$00ff	            AND #$00FF
.3a3bfd	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3c00	e2 20		sep #$20	            SEP #$20
.3a3c02	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3c05					S_DIM
.3a3c05	08		php		                PHP
.3a3c06	e2 20		sep #$20	            SEP #$20
.3a3c08	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a3c0b	20 68 51	jsr $3a5168	            JSR VAR_FINDNAME
.3a3c0e	90 64		bcc $3a3c74	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.3a3c10	a9 8f		lda #$8f	                LDA #TOK_LPAREN     ; Verify we have a left parenthesis
.3a3c12	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a3c15	a9 01		lda #$01	                LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.3a3c17	20 ac 18	jsr $3a18ac	            JSR PHOPERATOR
.3a3c1a	a2 01 00	ldx #$0001	                LDX #1
.3a3c1d	a9 00		lda #$00	                LDA #0
.3a3c1f	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF     ; Set the dimension count to 0
.3a3c23					dim_loop
.3a3c23	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3c26	20 bf 05	jsr $3a05bf	            JSR ASS_ARG1_INT16
.3a3c29	c2 20		rep #$20	            REP #$20
.3a3c2b	a5 23		lda $0823	                LDA ARGUMENT1
.3a3c2d	9f 00 4d 00	sta $004d00,x	                STA @lARRIDXBUF,X   ; And store it in the buffer
.3a3c31	e2 20		sep #$20	            SEP #$20
.3a3c33	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF     ; Add to the dimension count
.3a3c37	1a		inc a		                INC A
.3a3c38	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF
.3a3c3c	30 55		bmi $3a3c93	                BMI overflow        ; If > 127 throw an error
.3a3c3e	e8		inx		                INX
.3a3c3f	e8		inx		                INX
.3a3c40	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a3c43	a7 00		lda [$0800]	                LDA [BIP]           ; Check the character
.3a3c45	c9 2c		cmp #$2c	                CMP #','            ; Is it a comma?
.3a3c47	f0 25		beq $3a3c6e	                BEQ skip_comma      ; Yes: get the next dimension
.3a3c49	c9 90		cmp #$90	                CMP #TOK_RPAREN     ; No: is it a ")"?
.3a3c4b	d0 27		bne $3a3c74	                BNE syntax_err      ; No: throw a syntax error
.3a3c4d	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a3c50	20 e6 63	jsr $3a63e6	            JSR ARR_ALLOC
.3a3c53	c2 20		rep #$20	            REP #$20
.3a3c55	a5 c0		lda $08c0	                LDA CURRBLOCK       ; Set up the pointer to the array
.3a3c57	85 23		sta $0823	                STA ARGUMENT1
.3a3c59	e2 20		sep #$20	            SEP #$20
.3a3c5b	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.3a3c5d	85 25		sta $0825	                STA ARGUMENT1+2
.3a3c5f	64 26		stz $0826	                STZ ARGUMENT1+3
.3a3c61	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Get the type of the values
.3a3c63	09 80		ora #$80	                ORA #$80            ; Make sure we change the type to array
.3a3c65	85 ea		sta $08ea	                STA TOFINDTYPE      ; And save it back for searching
.3a3c67	85 27		sta $0827	                STA ARGTYPE1        ; And for the value to set
.3a3c69	20 cb 50	jsr $3a50cb	            JSR VAR_SET
.3a3c6c	28		plp		                PLP
.3a3c6d	60		rts		            RTS
.3a3c6e					skip_comma
.3a3c6e	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a3c71	4c 23 3c	jmp $3a3c23	                JMP dim_loop
.3a3c74					syntax_err
.3a3c74	08		php		            PHP
.3a3c75	c2 20		rep #$20	            REP #$20
.3a3c77	48		pha		            PHA
.3a3c78	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3c7b	5b		tcd		            TCD
.3a3c7c	68		pla		            PLA
.3a3c7d	28		plp		            PLP
.3a3c7e	e2 20		sep #$20	            SEP #$20
.3a3c80	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3c82	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3c86	c2 20		rep #$20	            REP #$20
.3a3c88	29 ff 00	and #$00ff	            AND #$00FF
.3a3c8b	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3c8e	e2 20		sep #$20	            SEP #$20
.3a3c90	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3c93					overflow
.3a3c93	08		php		            PHP
.3a3c94	c2 20		rep #$20	            REP #$20
.3a3c96	48		pha		            PHA
.3a3c97	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3c9a	5b		tcd		            TCD
.3a3c9b	68		pla		            PLA
.3a3c9c	28		plp		            PLP
.3a3c9d	e2 20		sep #$20	            SEP #$20
.3a3c9f	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a3ca1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3ca5	c2 20		rep #$20	            REP #$20
.3a3ca7	29 ff 00	and #$00ff	            AND #$00FF
.3a3caa	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3cad	e2 20		sep #$20	            SEP #$20
.3a3caf	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3cb2					S_READ
.3a3cb2	08		php		                PHP
.3a3cb3					varloop
.3a3cb3	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a3cb6	e2 20		sep #$20	            SEP #$20
.3a3cb8	a7 00		lda [$0800]	                LDA [BIP]
.3a3cba	f0 28		beq $3a3ce4	                BEQ done            ; If EOL, we're done
.3a3cbc	c9 3a		cmp #$3a	                CMP #':'
.3a3cbe	f0 24		beq $3a3ce4	                BEQ done            ; If colon, we're done
.3a3cc0	20 94 03	jsr $3a0394	            JSR ISALPHA
.3a3cc3	90 21		bcc $3a3ce6	                BCC syntax_err      ; No: it's a syntax error
.3a3cc5	20 68 51	jsr $3a5168	            JSR VAR_FINDNAME
.3a3cc8	90 1c		bcc $3a3ce6	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.3a3cca	20 05 3d	jsr $3a3d05	            JSR NEXTDATA
.3a3ccd	20 cb 50	jsr $3a50cb	            JSR VAR_SET
.3a3cd0	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a3cd3	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.3a3cd5	f0 0d		beq $3a3ce4	                BEQ done            ; EOL? We're done
.3a3cd7	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.3a3cd9	f0 09		beq $3a3ce4	                BEQ done
.3a3cdb	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.3a3cdd	d0 07		bne $3a3ce6	                BNE syntax_err      ; Nope: syntax error
.3a3cdf	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a3ce2	80 cf		bra $3a3cb3	                BRA varloop
.3a3ce4	28		plp		done            PLP
.3a3ce5	60		rts		            RTS
.3a3ce6					syntax_err
.3a3ce6	08		php		            PHP
.3a3ce7	c2 20		rep #$20	            REP #$20
.3a3ce9	48		pha		            PHA
.3a3cea	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3ced	5b		tcd		            TCD
.3a3cee	68		pla		            PLA
.3a3cef	28		plp		            PLP
.3a3cf0	e2 20		sep #$20	            SEP #$20
.3a3cf2	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3cf4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3cf8	c2 20		rep #$20	            REP #$20
.3a3cfa	29 ff 00	and #$00ff	            AND #$00FF
.3a3cfd	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3d00	e2 20		sep #$20	            SEP #$20
.3a3d02	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3d05					NEXTDATA
.3a3d05	08		php		                PHP
.3a3d06	a5 02		lda $0802	                LDA BIP+2           ; Save BIP
.3a3d08	85 42		sta $0842	                STA SAVEBIP+2
.3a3d0a	a5 00		lda $0800	                LDA BIP
.3a3d0c	85 40		sta $0840	                STA SAVEBIP
.3a3d0e	a5 1c		lda $081c	                LDA CURLINE+2       ; Save CURLINE
.3a3d10	85 46		sta $0846	                STA SAVELINE+2
.3a3d12	a5 1a		lda $081a	                LDA CURLINE
.3a3d14	85 44		sta $0844	                STA SAVELINE
.3a3d16	c2 20		rep #$20	            REP #$20
.3a3d18	a5 3a		lda $083a	                LDA DATABIP+2
.3a3d1a	d0 04		bne $3a3d20	                BNE data_set
.3a3d1c	a5 38		lda $0838	                LDA DATABIP
.3a3d1e	f0 4e		beq $3a3d6e	                BEQ scan_start      ; No: scan for a DATA statement
.3a3d20	a5 38		lda $0838	data_set        LDA DATABIP         ; Move BIP to the DATA statement
.3a3d22	85 00		sta $0800	                STA BIP
.3a3d24	a5 3a		lda $083a	                LDA DATABIP+2
.3a3d26	85 02		sta $0802	                STA BIP+2
.3a3d28	a5 3c		lda $083c	                LDA DATALINE        ; Set CURLINE from DATALINE
.3a3d2a	85 1a		sta $081a	                STA CURLINE
.3a3d2c	a5 3e		lda $083e	                LDA DATALINE+2
.3a3d2e	85 1c		sta $081c	                STA CURLINE+2
.3a3d30	e2 20		sep #$20	            SEP #$20
.3a3d32	a7 00		lda [$0800]	                LDA [BIP]           ; Check character at BIP
.3a3d34	f0 53		beq $3a3d89	                BEQ scan_DATA       ; EOL? scan for a DATA statement
.3a3d36	c9 3a		cmp #$3a	                CMP #':'            ; Colon?
.3a3d38	f0 4f		beq $3a3d89	                BEQ scan_DATA       ; ... scan for a DATA statement
.3a3d3a	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.3a3d3c	d0 03		bne $3a3d41	                BNE skip_parse      ; No: skip leading WS and try to parse
.3a3d3e	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a3d41					skip_parse
.3a3d41	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a3d44	a7 00		lda [$0800]	                LDA [BIP]
.3a3d46	c9 22		cmp #$22	                CMP #CHAR_DQUOTE    ; Is it a quote?
.3a3d48	f0 4e		beq $3a3d98	                BEQ read_string     ; Yes: process the string
.3a3d4a	20 ad 03	jsr $3a03ad	            JSR ISNUMERAL
.3a3d4d	b0 4e		bcs $3a3d9d	                BCS read_number     ; Yes: process the number
.3a3d4f					syntax_err
.3a3d4f	08		php		            PHP
.3a3d50	c2 20		rep #$20	            REP #$20
.3a3d52	48		pha		            PHA
.3a3d53	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3d56	5b		tcd		            TCD
.3a3d57	68		pla		            PLA
.3a3d58	28		plp		            PLP
.3a3d59	e2 20		sep #$20	            SEP #$20
.3a3d5b	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3d5d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3d61	c2 20		rep #$20	            REP #$20
.3a3d63	29 ff 00	and #$00ff	            AND #$00FF
.3a3d66	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3d69	e2 20		sep #$20	            SEP #$20
.3a3d6b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3d6e					scan_start
.3a3d6e	c2 20		rep #$20	            REP #$20
.3a3d70	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT    ; Point CURLINE to the first line
.3a3d73	85 1a		sta $081a	                STA CURLINE
.3a3d75	a9 36 00	lda #$0036	                LDA #`BASIC_BOT
.3a3d78	85 1c		sta $081c	                STA CURLINE+2
.3a3d7a	18		clc		                CLC
.3a3d7b	a5 1a		lda $081a	                LDA CURLINE         ; Point BIP to the first possible token
.3a3d7d	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.3a3d80	85 00		sta $0800	                STA BIP
.3a3d82	a5 1c		lda $081c	                LDA CURLINE+2
.3a3d84	69 00 00	adc #$0000	                ADC #0
.3a3d87	85 02		sta $0802	                STA BIP+2
.3a3d89					scan_data
.3a3d89	e2 20		sep #$20	            SEP #$20
.3a3d8b	a9 80		lda #$80	                LDA #$80            ; We don't want to process nesting
.3a3d8d	85 35		sta $0835	                STA SKIPNEST
.3a3d8f	a9 ab		lda #$ab	                LDA #TOK_DATA       ; We're looking for a DATA token
.3a3d91	85 37		sta $0837	                STA TARGETTOK
.3a3d93	20 b5 1f	jsr $3a1fb5	            JSR SKIPTOTOK
.3a3d96	80 a9		bra $3a3d41	                BRA skip_parse
.3a3d98					read_string
.3a3d98	20 59 1a	jsr $3a1a59	            JSR EVALSTRING
.3a3d9b	80 03		bra $3a3da0	                BRA done
.3a3d9d					read_number
.3a3d9d	20 8e 19	jsr $3a198e	            JSR EVALNUMBER
.3a3da0					done
.3a3da0	c2 20		rep #$20	            REP #$20
.3a3da2	a5 00		lda $0800	                LDA BIP             ; Save BIP to DATABIP
.3a3da4	85 38		sta $0838	                STA DATABIP
.3a3da6	a5 02		lda $0802	                LDA BIP+2
.3a3da8	85 3a		sta $083a	                STA DATABIP+2
.3a3daa	a5 1a		lda $081a	                LDA CURLINE         ; Save CURLINE to DATALINE
.3a3dac	85 3c		sta $083c	                STA DATALINE
.3a3dae	a5 1c		lda $081c	                LDA CURLINE+2
.3a3db0	85 3e		sta $083e	                STA DATALINE+2
.3a3db2	a5 44		lda $0844	                LDA SAVELINE        ; Restore CURLINE
.3a3db4	85 1a		sta $081a	                STA CURLINE
.3a3db6	a5 46		lda $0846	                LDA SAVELINE+2
.3a3db8	85 1c		sta $081c	                STA CURLINE+2
.3a3dba	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.3a3dbc	85 00		sta $0800	                STA BIP
.3a3dbe	a5 42		lda $0842	                LDA SAVEBIP+2
.3a3dc0	85 02		sta $0802	                STA BIP+2
.3a3dc2	28		plp		                PLP
.3a3dc3	60		rts		            RTS
.3a3dc4					S_DATA
.3a3dc4	20 a3 1f	jsr $3a1fa3	            JSR SKIPSTMT
.3a3dc7	60		rts		            RTS
.3a3dc8					S_RESTORE
.3a3dc8	64 38		stz $0838	                STZ DATABIP         ; Just set DATABIP to 0
.3a3dca	64 3a		stz $083a	                STZ DATABIP+2       ; The next READ will move it to the first DATA
.3a3dcc	64 3c		stz $083c	                STZ DATALINE        ; Set DATALINE to 0
.3a3dce	64 3e		stz $083e	                STZ DATALINE+2
.3a3dd0	60		rts		            RTS
.3a3dd1					S_CLS
.3a3dd1	20 24 00	jsr $3a0024	            JSR CLSCREEN
.3a3dd4	60		rts		            RTS
.3a3dd5					S_POKEL
.3a3dd5	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3dd8	c2 20		rep #$20	            REP #$20
.3a3dda	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.3a3ddc	48		pha		                PHA
.3a3ddd	a5 23		lda $0823	                LDA ARGUMENT1
.3a3ddf	48		pha		                PHA
.3a3de0	e2 20		sep #$20	            SEP #$20
.3a3de2	a7 00		lda [$0800]	                LDA [BIP]
.3a3de4	c9 2c		cmp #$2c	                CMP #','
.3a3de6	d0 22		bne $3a3e0a	                BNE syntax_err
.3a3de8	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a3deb	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3dee	c2 20		rep #$20	            REP #$20
.3a3df0	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a3df2	d0 35		bne $3a3e29	                BNE range_err
.3a3df4	68		pla		                PLA                 ; Pull the target address from the stack
.3a3df5	85 08		sta $0808	                STA INDEX           ; and into INDEX
.3a3df7	68		pla		                PLA
.3a3df8	85 0a		sta $080a	                STA INDEX+2
.3a3dfa	c2 20		rep #$20	            REP #$20
.3a3dfc	a5 23		lda $0823	                LDA ARGUMENT1
.3a3dfe	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.3a3e00	e2 20		sep #$20	            SEP #$20
.3a3e02	a0 02 00	ldy #$0002	                LDY #2
.3a3e05	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a3e07	97 08		sta [$0808],y	                STA [INDEX],Y
.3a3e09	60		rts		            RTS
.3a3e0a					syntax_err
.3a3e0a	08		php		            PHP
.3a3e0b	c2 20		rep #$20	            REP #$20
.3a3e0d	48		pha		            PHA
.3a3e0e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3e11	5b		tcd		            TCD
.3a3e12	68		pla		            PLA
.3a3e13	28		plp		            PLP
.3a3e14	e2 20		sep #$20	            SEP #$20
.3a3e16	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3e18	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3e1c	c2 20		rep #$20	            REP #$20
.3a3e1e	29 ff 00	and #$00ff	            AND #$00FF
.3a3e21	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3e24	e2 20		sep #$20	            SEP #$20
.3a3e26	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3e29					range_err
.3a3e29	08		php		            PHP
.3a3e2a	c2 20		rep #$20	            REP #$20
.3a3e2c	48		pha		            PHA
.3a3e2d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3e30	5b		tcd		            TCD
.3a3e31	68		pla		            PLA
.3a3e32	28		plp		            PLP
.3a3e33	e2 20		sep #$20	            SEP #$20
.3a3e35	a9 09		lda #$09	            LDA #ERR_RANGE
.3a3e37	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3e3b	c2 20		rep #$20	            REP #$20
.3a3e3d	29 ff 00	and #$00ff	            AND #$00FF
.3a3e40	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3e43	e2 20		sep #$20	            SEP #$20
.3a3e45	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3e48					S_POKEW
.3a3e48	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3e4b	c2 20		rep #$20	            REP #$20
.3a3e4d	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.3a3e4f	48		pha		                PHA
.3a3e50	a5 23		lda $0823	                LDA ARGUMENT1
.3a3e52	48		pha		                PHA
.3a3e53	e2 20		sep #$20	            SEP #$20
.3a3e55	a7 00		lda [$0800]	                LDA [BIP]
.3a3e57	c9 2c		cmp #$2c	                CMP #','
.3a3e59	d0 19		bne $3a3e74	                BNE syntax_err
.3a3e5b	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a3e5e	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3e61	c2 20		rep #$20	            REP #$20
.3a3e63	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a3e65	d0 2c		bne $3a3e93	                BNE range_err
.3a3e67	68		pla		                PLA                 ; Pull the target address from the stack
.3a3e68	85 08		sta $0808	                STA INDEX           ; and into INDEX
.3a3e6a	68		pla		                PLA
.3a3e6b	85 0a		sta $080a	                STA INDEX+2
.3a3e6d	c2 20		rep #$20	            REP #$20
.3a3e6f	a5 23		lda $0823	                LDA ARGUMENT1
.3a3e71	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.3a3e73	60		rts		            RTS
.3a3e74					syntax_err
.3a3e74	08		php		            PHP
.3a3e75	c2 20		rep #$20	            REP #$20
.3a3e77	48		pha		            PHA
.3a3e78	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3e7b	5b		tcd		            TCD
.3a3e7c	68		pla		            PLA
.3a3e7d	28		plp		            PLP
.3a3e7e	e2 20		sep #$20	            SEP #$20
.3a3e80	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3e82	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3e86	c2 20		rep #$20	            REP #$20
.3a3e88	29 ff 00	and #$00ff	            AND #$00FF
.3a3e8b	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3e8e	e2 20		sep #$20	            SEP #$20
.3a3e90	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3e93					range_err
.3a3e93	08		php		            PHP
.3a3e94	c2 20		rep #$20	            REP #$20
.3a3e96	48		pha		            PHA
.3a3e97	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3e9a	5b		tcd		            TCD
.3a3e9b	68		pla		            PLA
.3a3e9c	28		plp		            PLP
.3a3e9d	e2 20		sep #$20	            SEP #$20
.3a3e9f	a9 09		lda #$09	            LDA #ERR_RANGE
.3a3ea1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3ea5	c2 20		rep #$20	            REP #$20
.3a3ea7	29 ff 00	and #$00ff	            AND #$00FF
.3a3eaa	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3ead	e2 20		sep #$20	            SEP #$20
.3a3eaf	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3eb2					S_POKE
.3a3eb2	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3eb5	c2 20		rep #$20	            REP #$20
.3a3eb7	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.3a3eb9	48		pha		                PHA
.3a3eba	a5 23		lda $0823	                LDA ARGUMENT1
.3a3ebc	48		pha		                PHA
.3a3ebd	e2 20		sep #$20	            SEP #$20
.3a3ebf	a7 00		lda [$0800]	                LDA [BIP]
.3a3ec1	c9 2c		cmp #$2c	                CMP #','
.3a3ec3	d0 1f		bne $3a3ee4	                BNE syntax_err
.3a3ec5	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a3ec8	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3ecb	e2 20		sep #$20	            SEP #$20
.3a3ecd	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Make sure the value is from 0 - 255
.3a3ecf	d0 32		bne $3a3f03	                BNE range_err
.3a3ed1	c2 20		rep #$20	            REP #$20
.3a3ed3	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a3ed5	d0 2c		bne $3a3f03	                BNE range_err
.3a3ed7	68		pla		                PLA                 ; Pull the target address from the stack
.3a3ed8	85 08		sta $0808	                STA INDEX           ; and into INDEX
.3a3eda	68		pla		                PLA
.3a3edb	85 0a		sta $080a	                STA INDEX+2
.3a3edd	e2 20		sep #$20	            SEP #$20
.3a3edf	a5 23		lda $0823	                LDA ARGUMENT1
.3a3ee1	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.3a3ee3	60		rts		            RTS
.3a3ee4					syntax_err
.3a3ee4	08		php		            PHP
.3a3ee5	c2 20		rep #$20	            REP #$20
.3a3ee7	48		pha		            PHA
.3a3ee8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3eeb	5b		tcd		            TCD
.3a3eec	68		pla		            PLA
.3a3eed	28		plp		            PLP
.3a3eee	e2 20		sep #$20	            SEP #$20
.3a3ef0	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3ef2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3ef6	c2 20		rep #$20	            REP #$20
.3a3ef8	29 ff 00	and #$00ff	            AND #$00FF
.3a3efb	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3efe	e2 20		sep #$20	            SEP #$20
.3a3f00	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3f03					range_err
.3a3f03	08		php		            PHP
.3a3f04	c2 20		rep #$20	            REP #$20
.3a3f06	48		pha		            PHA
.3a3f07	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3f0a	5b		tcd		            TCD
.3a3f0b	68		pla		            PLA
.3a3f0c	28		plp		            PLP
.3a3f0d	e2 20		sep #$20	            SEP #$20
.3a3f0f	a9 09		lda #$09	            LDA #ERR_RANGE
.3a3f11	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3f15	c2 20		rep #$20	            REP #$20
.3a3f17	29 ff 00	and #$00ff	            AND #$00FF
.3a3f1a	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3f1d	e2 20		sep #$20	            SEP #$20
.3a3f1f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3f22					S_STOP
.3a3f22	08		php		            PHP
.3a3f23	c2 20		rep #$20	            REP #$20
.3a3f25	48		pha		            PHA
.3a3f26	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3f29	5b		tcd		            TCD
.3a3f2a	68		pla		            PLA
.3a3f2b	28		plp		            PLP
.3a3f2c	e2 20		sep #$20	            SEP #$20
.3a3f2e	a9 01		lda #$01	            LDA #ERR_BREAK
.3a3f30	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3f34	c2 20		rep #$20	            REP #$20
.3a3f36	29 ff 00	and #$00ff	            AND #$00FF
.3a3f39	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3f3c	e2 20		sep #$20	            SEP #$20
.3a3f3e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3f41					S_REM
.3a3f41	08		php		                PHP
.3a3f42	e2 20		sep #$20	            SEP #$20
.3a3f44	a7 00		lda [$0800]	rem_loop        LDA [BIP]
.3a3f46	f0 05		beq $3a3f4d	                BEQ done
.3a3f48	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a3f4b	80 f7		bra $3a3f44	                BRA rem_loop
.3a3f4d	28		plp		done            PLP
.3a3f4e	60		rts		            RTS
.3a3f4f					S_EXIT
.3a3f4f	08		php		                PHP
.3a3f50	28		plp		                PLP
.3a3f51	60		rts		            RTS
.3a3f52					S_DO
.3a3f52	08		php		                PHP
.3a3f53	28		plp		                PLP
.3a3f54	60		rts		            RTS
.0000					DO_RECORD
>0000					BIP             .dword  ?
>0004					CURLINE         .dword  ?
.3a3f55					S_LOOP
.3a3f55	08		php		                PHP
.3a3f56	28		plp		                PLP
.3a3f57	60		rts		            RTS
.3a3f58					S_FOR
.3a3f58	08		php		                PHP
.3a3f59	c2 20		rep #$20	            REP #$20
.3a3f5b	a5 1c		lda $081c	                LDA CURLINE+2
.3a3f5d	20 66 1c	jsr $3a1c66	            JSR PHRETURN
.3a3f60	a5 1a		lda $081a	                LDA CURLINE
.3a3f62	20 66 1c	jsr $3a1c66	            JSR PHRETURN
.3a3f65	a5 02		lda $0802	                LDA BIP+2           ; Save current BIP
.3a3f67	48		pha		                PHA
.3a3f68	a5 00		lda $0800	                LDA BIP
.3a3f6a	48		pha		                PHA
.3a3f6b	20 a3 1f	jsr $3a1fa3	            JSR SKIPSTMT
.3a3f6e	a5 02		lda $0802	                LDA BIP+2           ; Save the BIP for the next statement to the RETURN stack
.3a3f70	20 66 1c	jsr $3a1c66	            JSR PHRETURN
.3a3f73	a5 00		lda $0800	                LDA BIP
.3a3f75	20 66 1c	jsr $3a1c66	            JSR PHRETURN
.3a3f78	68		pla		                PLA                 ; Restore the original BIP
.3a3f79	85 00		sta $0800	                STA BIP
.3a3f7b	68		pla		                PLA
.3a3f7c	85 02		sta $0802	                STA BIP+2
.3a3f7e	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a3f81					get_name
.3a3f81	20 68 51	jsr $3a5168	            JSR VAR_FINDNAME
.3a3f84	b0 1f		bcs $3a3fa5	                BCS push_name       ; If we didn't find a name, thrown an error
.3a3f86	08		php		            PHP
.3a3f87	c2 20		rep #$20	            REP #$20
.3a3f89	48		pha		            PHA
.3a3f8a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3f8d	5b		tcd		            TCD
.3a3f8e	68		pla		            PLA
.3a3f8f	28		plp		            PLP
.3a3f90	e2 20		sep #$20	            SEP #$20
.3a3f92	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.3a3f94	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3f98	c2 20		rep #$20	            REP #$20
.3a3f9a	29 ff 00	and #$00ff	            AND #$00FF
.3a3f9d	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a3fa0	e2 20		sep #$20	            SEP #$20
.3a3fa2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3fa5					push_name
.3a3fa5	e2 20		sep #$20	            SEP #$20
.3a3fa7	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; To the return stack
.3a3fa9	20 7d 1c	jsr $3a1c7d	            JSR PHRETURNB
.3a3fac	a5 e9		lda $08e9	                LDA TOFIND+2
.3a3fae	20 7d 1c	jsr $3a1c7d	            JSR PHRETURNB
.3a3fb1	c2 20		rep #$20	            REP #$20
.3a3fb3	a5 e7		lda $08e7	                LDA TOFIND
.3a3fb5	20 66 1c	jsr $3a1c66	            JSR PHRETURN
.3a3fb8					else
.3a3fb8	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a3fbb	e2 20		sep #$20	            SEP #$20
.3a3fbd	a7 00		lda [$0800]	                LDA [BIP]
.3a3fbf	c9 8a		cmp #$8a	                CMP #TOK_EQ
.3a3fc1	d0 6a		bne $3a402d	                BNE syntax_err      ; If not found: signal an syntax error
.3a3fc3	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Verify type of variable
.3a3fc5	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; Is it integer?
.3a3fc7	f0 04		beq $3a3fcd	                BEQ process_initial ; Yes: it's ok
.3a3fc9	c9 01		cmp #$01	                CMP #TYPE_FLOAT     ; Is it floating point?
.3a3fcb	f0 00		beq $3a3fcd	                BEQ process_initial ; Yes: it's ok
.3a3fcd					process_initial
.3a3fcd	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a3fd0	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3fd3	20 cb 50	jsr $3a50cb	            JSR VAR_SET
.3a3fd6	e2 20		sep #$20	            SEP #$20
.3a3fd8	a9 9c		lda #$9c	                LDA #TOK_TO         ; Expect the next token to be TO
.3a3fda	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a3fdd	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a3fe0	c2 20		rep #$20	            REP #$20
.3a3fe2	a5 27		lda $0827	                LDA ARGTYPE1
.3a3fe4	20 66 1c	jsr $3a1c66	            JSR PHRETURN
.3a3fe7	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a3fe9	20 66 1c	jsr $3a1c66	            JSR PHRETURN
.3a3fec	a5 23		lda $0823	                LDA ARGUMENT1
.3a3fee	20 66 1c	jsr $3a1c66	            JSR PHRETURN
.3a3ff1	e2 20		sep #$20	            SEP #$20
.3a3ff3	a9 9d		lda #$9d	                LDA #TOK_STEP
.3a3ff5	85 37		sta $0837	                STA TARGETTOK
.3a3ff7	20 a0 20	jsr $3a20a0	            JSR OPT_TOK
.3a3ffa	90 1b		bcc $3a4017	                BCC default_inc     ; Not found: set a default increment of 1
.3a3ffc	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a3fff	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4002	e2 20		sep #$20	            SEP #$20
.3a4004	a5 27		lda $0827	                LDA ARGTYPE1        ; Push the result as the increment
.3a4006	20 66 1c	jsr $3a1c66	            JSR PHRETURN
.3a4009	c2 20		rep #$20	            REP #$20
.3a400b	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a400d	20 66 1c	jsr $3a1c66	            JSR PHRETURN
.3a4010	a5 23		lda $0823	                LDA ARGUMENT1
.3a4012	20 66 1c	jsr $3a1c66	            JSR PHRETURN
.3a4015	80 14		bra $3a402b	                BRA done
.3a4017					default_inc
.3a4017	c2 20		rep #$20	            REP #$20
.3a4019	a9 00 00	lda #$0000	                LDA #TYPE_INTEGER
.3a401c	20 66 1c	jsr $3a1c66	            JSR PHRETURN
.3a401f	a9 00 00	lda #$0000	                LDA #0
.3a4022	20 66 1c	jsr $3a1c66	            JSR PHRETURN
.3a4025	a9 01 00	lda #$0001	                LDA #1
.3a4028	20 66 1c	jsr $3a1c66	            JSR PHRETURN
.3a402b	28		plp		done            PLP
.3a402c	60		rts		            RTS
.3a402d					syntax_err
.3a402d	08		php		            PHP
.3a402e	c2 20		rep #$20	            REP #$20
.3a4030	48		pha		            PHA
.3a4031	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4034	5b		tcd		            TCD
.3a4035	68		pla		            PLA
.3a4036	28		plp		            PLP
.3a4037	e2 20		sep #$20	            SEP #$20
.3a4039	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a403b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a403f	c2 20		rep #$20	            REP #$20
.3a4041	29 ff 00	and #$00ff	            AND #$00FF
.3a4044	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4047	e2 20		sep #$20	            SEP #$20
.3a4049	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.0000					FOR_RECORD
>0000					INCREMENT       .dword  ?
>0004					INCTYPE         .word   ?
>0006					FINAL           .dword  ?
>000a					FINALTYPE       .word   ?
>000c					VARIBLE         .dword  ?
>0010					VARTYPE         .word   ?
>0012					BIP             .dword  ?
>0016					CURLINE         .dword  ?
.3a404c					S_NEXT
.3a404c	08		php		                PHP
.3a404d	8b		phb		                PHB
.3a404e	08		php		            PHP
.3a404f	e2 20		sep #$20	            SEP #$20
.3a4051	48		pha		            PHA
.3a4052	a9 00		lda #$00	            LDA #0
.3a4054	48		pha		            PHA
.3a4055	ab		plb		            PLB
.3a4056	68		pla		            PLA
.3a4057	28		plp		            PLP
.3a4058	08		php		            PHP
.3a4059	c2 20		rep #$20	            REP #$20
.3a405b	48		pha		            PHA
.3a405c	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a405f	5b		tcd		            TCD
.3a4060	68		pla		            PLA
.3a4061	28		plp		            PLP
.3a4062	c2 30		rep #$30	            REP #$30
.3a4064	a4 33		ldy $0833	                LDY RETURNSP                    ; Y := pointer to first byte of the FOR record
.3a4066	c8		iny		                INY                             ; RETURNSP points to the first free slot, so move up 2 bytes
.3a4067	c8		iny		                INY
.3a4068	c2 20		rep #$20	            REP #$20
.3a406a	b9 0c 00	lda $000c,y	                LDA #FOR_RECORD.VARIBLE,B,Y     ; TOFIND := FOR_RECORD.VARIABLE
.3a406d	85 e7		sta $08e7	                STA TOFIND
.3a406f	b9 0e 00	lda $000e,y	                LDA #FOR_RECORD.VARIBLE+2,B,Y
.3a4072	e2 20		sep #$20	            SEP #$20
.3a4074	85 e9		sta $08e9	                STA TOFIND+2
.3a4076	b9 10 00	lda $0010,y	                LDA #FOR_RECORD.VARTYPE,B,Y
.3a4079	85 ea		sta $08ea	                STA TOFINDTYPE
.3a407b	c2 20		rep #$20	            REP #$20
.3a407d	5a		phy		                PHY
.3a407e	20 69 4f	jsr $3a4f69	            JSR VAR_REF
.3a4081	7a		ply		                PLY
.3a4082	c2 20		rep #$20	            REP #$20
.3a4084	b9 00 00	lda $0000,y	                LDA #FOR_RECORD.INCREMENT,B,Y   ; ARGUMENT2 := FOR_RECORD.INCREMENT
.3a4087	85 29		sta $0829	                STA ARGUMENT2
.3a4089	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y
.3a408c	85 2b		sta $082b	                STA ARGUMENT2+2
.3a408e	e2 20		sep #$20	            SEP #$20
.3a4090	b9 04 00	lda $0004,y	                LDA #FOR_RECORD.INCTYPE,B,Y
.3a4093	85 2d		sta $082d	                STA ARGTYPE2
.3a4095	c2 20		rep #$20	            REP #$20
.3a4097	5a		phy		                PHY
.3a4098	20 1d 26	jsr $3a261d	            JSR OP_PLUS
.3a409b	20 cb 50	jsr $3a50cb	            JSR VAR_SET
.3a409e	7a		ply		                PLY
.3a409f	c2 20		rep #$20	            REP #$20
.3a40a1	b9 06 00	lda $0006,y	                LDA #FOR_RECORD.FINAL,B,Y       ; ARGUMENT2 := FOR_RECORD.FINAL
.3a40a4	85 29		sta $0829	                STA ARGUMENT2
.3a40a6	b9 08 00	lda $0008,y	                LDA #FOR_RECORD.FINAL+2,B,Y
.3a40a9	85 2b		sta $082b	                STA ARGUMENT2+2
.3a40ab	e2 20		sep #$20	            SEP #$20
.3a40ad	b9 0a 00	lda $000a,y	                LDA #FOR_RECORD.FINALTYPE,B,Y
.3a40b0	85 2d		sta $082d	                STA ARGTYPE2
.3a40b2	c2 20		rep #$20	            REP #$20
.3a40b4	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y ; Check the increment's sign
.3a40b7	30 0a		bmi $3a40c3	                BMI going_down
.3a40b9					going_up
.3a40b9	20 a6 28	jsr $3a28a6	            JSR OP_LTE
.3a40bc	20 cc 04	jsr $3a04cc	            JSR IS_ARG1_Z
.3a40bf	f0 28		beq $3a40e9	                BEQ end_loop                    ; No: end the loop
.3a40c1	80 08		bra $3a40cb	                BRA loop_back                   ; Yes: loop back
.3a40c3					going_down
.3a40c3	20 66 28	jsr $3a2866	            JSR OP_GTE
.3a40c6	20 cc 04	jsr $3a04cc	            JSR IS_ARG1_Z
.3a40c9	f0 1e		beq $3a40e9	                BEQ end_loop                    ; No: end the loop
.3a40cb					loop_back
.3a40cb	c2 20		rep #$20	            REP #$20
.3a40cd	b9 12 00	lda $0012,y	                LDA #FOR_RECORD.BIP,B,Y
.3a40d0	85 00		sta $0800	                STA BIP
.3a40d2	b9 14 00	lda $0014,y	                LDA #FOR_RECORD.BIP+2,B,Y
.3a40d5	85 02		sta $0802	                STA BIP+2
.3a40d7	b9 16 00	lda $0016,y	                LDA #FOR_RECORD.CURLINE,B,Y     ; CURLINE := FOR_RECORD.CURLINE
.3a40da	85 1a		sta $081a	                STA CURLINE
.3a40dc	b9 18 00	lda $0018,y	                LDA #FOR_RECORD.CURLINE+2,B,Y
.3a40df	85 1c		sta $081c	                STA CURLINE+2
.3a40e1	e2 20		sep #$20	            SEP #$20
.3a40e3	a9 03		lda #$03	                LDA #EXEC_RETURN
.3a40e5	85 dc		sta $08dc	                STA EXECACTION
.3a40e7	80 17		bra $3a4100	                BRA done
.3a40e9					end_loop
.3a40e9	a2 23 08	ldx #$0823	                LDX #ARGUMENT1
.3a40ec	20 6d 18	jsr $3a186d	            JSR PLARGUMENT
.3a40ef	c2 20		rep #$20	            REP #$20
.3a40f1	18		clc		                CLC
.3a40f2	a5 33		lda $0833	                LDA RETURNSP
.3a40f4	69 1a 00	adc #$001a	                ADC #size(FOR_RECORD)           ; Move pointer by number of bytes in a FOR record
.3a40f7	85 33		sta $0833	                STA RETURNSP
.3a40f9	a5 35		lda $0835	                LDA RETURNSP+2
.3a40fb	69 00 00	adc #$0000	                ADC #0
.3a40fe	85 35		sta $0835	                STA RETURNSP+2
.3a4100	ab		plb		done            PLB
.3a4101	28		plp		                PLP
.3a4102	60		rts		            RTS
.3a4103					S_GOSUB
.3a4103	08		php		                PHP
.3a4104	a5 1a		lda $081a	                LDA CURLINE                 ; Save the current line for later
.3a4106	48		pha		                PHA
.3a4107	a5 1c		lda $081c	                LDA CURLINE+2
.3a4109	48		pha		                PHA
.3a410a	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a410d	20 8a 07	jsr $3a078a	            JSR PARSEINT
.3a4110	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.3a4112	f0 26		beq $3a413a	                BEQ syntax_err              ; If 0, no number was found... syntax error
.3a4114	20 5d 22	jsr $3a225d	            JSR FINDLINE
.3a4117	90 42		bcc $3a415b	                BCC not_found               ; If not found... LINE NOT FOUND error
.3a4119	e2 20		sep #$20	            SEP #$20
.3a411b	a9 02		lda #$02	                LDA #EXEC_GOTO
.3a411d	85 dc		sta $08dc	                STA EXECACTION
.3a411f	20 a3 1f	jsr $3a1fa3	            JSR SKIPSTMT
.3a4122	c2 20		rep #$20	            REP #$20
.3a4124	68		pla		                PLA                         ; Save the old value of CURLINE to the RETURN stack
.3a4125	20 66 1c	jsr $3a1c66	            JSR PHRETURN
.3a4128	68		pla		                PLA
.3a4129	20 66 1c	jsr $3a1c66	            JSR PHRETURN
.3a412c	a5 02		lda $0802	                LDA BIP+2                   ; Save the BASIC Instruction Pointer to the RETURN stack
.3a412e	20 66 1c	jsr $3a1c66	            JSR PHRETURN
.3a4131	a5 00		lda $0800	                LDA BIP
.3a4133	20 66 1c	jsr $3a1c66	            JSR PHRETURN
.3a4136	e6 31		inc $0831	                INC GOSUBDEPTH              ; Increase the count of GOSUBs on the stack
.3a4138	28		plp		                PLP
.3a4139	60		rts		            RTS
.3a413a	68		pla		syntax_err      PLA
.3a413b	68		pla		                PLA
.3a413c	08		php		            PHP
.3a413d	c2 20		rep #$20	            REP #$20
.3a413f	48		pha		            PHA
.3a4140	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4143	5b		tcd		            TCD
.3a4144	68		pla		            PLA
.3a4145	28		plp		            PLP
.3a4146	e2 20		sep #$20	            SEP #$20
.3a4148	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a414a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a414e	c2 20		rep #$20	            REP #$20
.3a4150	29 ff 00	and #$00ff	            AND #$00FF
.3a4153	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4156	e2 20		sep #$20	            SEP #$20
.3a4158	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a415b	68		pla		not_found       PLA
.3a415c	68		pla		                PLA
.3a415d	08		php		            PHP
.3a415e	c2 20		rep #$20	            REP #$20
.3a4160	48		pha		            PHA
.3a4161	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4164	5b		tcd		            TCD
.3a4165	68		pla		            PLA
.3a4166	28		plp		            PLP
.3a4167	e2 20		sep #$20	            SEP #$20
.3a4169	a9 06		lda #$06	            LDA #ERR_NOLINE
.3a416b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a416f	c2 20		rep #$20	            REP #$20
.3a4171	29 ff 00	and #$00ff	            AND #$00FF
.3a4174	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4177	e2 20		sep #$20	            SEP #$20
.3a4179	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a417c					S_RETURN
.3a417c	08		php		                PHP
.3a417d	c2 30		rep #$30	            REP #$30
.3a417f	a5 31		lda $0831	                LDA GOSUBDEPTH              ; Check that there is at least on GOSUB on the stack
.3a4181	f0 1e		beq $3a41a1	                BEQ underflow               ; No? It's a stack underflow error
.3a4183	20 88 1c	jsr $3a1c88	            JSR PLRETURN
.3a4186	85 00		sta $0800	                STA BIP
.3a4188	20 88 1c	jsr $3a1c88	            JSR PLRETURN
.3a418b	85 02		sta $0802	                STA BIP+2
.3a418d	20 88 1c	jsr $3a1c88	            JSR PLRETURN
.3a4190	85 1a		sta $081a	                STA CURLINE
.3a4192	20 88 1c	jsr $3a1c88	            JSR PLRETURN
.3a4195	85 1c		sta $081c	                STA CURLINE+2
.3a4197	c6 31		dec $0831	                DEC GOSUBDEPTH              ; Indicate we've popped that GOSUB off the stack
.3a4199	e2 20		sep #$20	            SEP #$20
.3a419b	a9 03		lda #$03	                LDA #EXEC_RETURN
.3a419d	85 dc		sta $08dc	                STA EXECACTION
.3a419f	28		plp		                PLP
.3a41a0	60		rts		            RTS
.3a41a1					underflow
.3a41a1	08		php		            PHP
.3a41a2	c2 20		rep #$20	            REP #$20
.3a41a4	48		pha		            PHA
.3a41a5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a41a8	5b		tcd		            TCD
.3a41a9	68		pla		            PLA
.3a41aa	28		plp		            PLP
.3a41ab	e2 20		sep #$20	            SEP #$20
.3a41ad	a9 07		lda #$07	            LDA #ERR_STACKUNDER
.3a41af	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a41b3	c2 20		rep #$20	            REP #$20
.3a41b5	29 ff 00	and #$00ff	            AND #$00FF
.3a41b8	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a41bb	e2 20		sep #$20	            SEP #$20
.3a41bd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a41c0					S_IF
.3a41c0	08		php		                PHP
.3a41c1	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a41c4	20 cc 04	jsr $3a04cc	            JSR IS_ARG1_Z
.3a41c7	f0 1c		beq $3a41e5	                BEQ is_false                ; If so, handle the FALSE case
.3a41c9	e2 20		sep #$20	            SEP #$20
.3a41cb	a9 97		lda #$97	                LDA #TOK_THEN               ; Verify that the next token is THEN and eat it
.3a41cd	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a41d0	20 8a 07	jsr $3a078a	            JSR PARSEINT
.3a41d3	20 cc 04	jsr $3a04cc	            JSR IS_ARG1_Z
.3a41d6	f0 12		beq $3a41ea	                BEQ syntax_err              ; If not, we have a syntax error
.3a41d8	20 5d 22	jsr $3a225d	            JSR FINDLINE
.3a41db	90 2c		bcc $3a4209	                BCC not_found               ; If not found... LINE NOT FOUND error
.3a41dd	e2 20		sep #$20	            SEP #$20
.3a41df	a9 02		lda #$02	                LDA #EXEC_GOTO
.3a41e1	85 dc		sta $08dc	                STA EXECACTION
.3a41e3	80 03		bra $3a41e8	                BRA done
.3a41e5					is_false
.3a41e5	20 a3 1f	jsr $3a1fa3	            JSR SKIPSTMT
.3a41e8	28		plp		done            PLP
.3a41e9	60		rts		            RTS
.3a41ea					syntax_err
.3a41ea	08		php		            PHP
.3a41eb	c2 20		rep #$20	            REP #$20
.3a41ed	48		pha		            PHA
.3a41ee	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a41f1	5b		tcd		            TCD
.3a41f2	68		pla		            PLA
.3a41f3	28		plp		            PLP
.3a41f4	e2 20		sep #$20	            SEP #$20
.3a41f6	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a41f8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a41fc	c2 20		rep #$20	            REP #$20
.3a41fe	29 ff 00	and #$00ff	            AND #$00FF
.3a4201	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4204	e2 20		sep #$20	            SEP #$20
.3a4206	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4209					not_found
.3a4209	08		php		            PHP
.3a420a	c2 20		rep #$20	            REP #$20
.3a420c	48		pha		            PHA
.3a420d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4210	5b		tcd		            TCD
.3a4211	68		pla		            PLA
.3a4212	28		plp		            PLP
.3a4213	e2 20		sep #$20	            SEP #$20
.3a4215	a9 06		lda #$06	            LDA #ERR_NOLINE
.3a4217	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a421b	c2 20		rep #$20	            REP #$20
.3a421d	29 ff 00	and #$00ff	            AND #$00FF
.3a4220	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4223	e2 20		sep #$20	            SEP #$20
.3a4225	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4228					S_END
.3a4228	08		php		                PHP
.3a4229	e2 20		sep #$20	            SEP #$20
.3a422b	a9 01		lda #$01	                LDA #EXEC_STOP
.3a422d	85 dc		sta $08dc	                STA EXECACTION
.3a422f	28		plp		                PLP
.3a4230	60		rts		            RTS
.3a4231					S_GOTO
.3a4231	08		php		                PHP
.3a4232	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a4235	20 8a 07	jsr $3a078a	            JSR PARSEINT
.3a4238	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.3a423a	f0 0d		beq $3a4249	                BEQ syntax_err              ; If 0, no number was found... syntax error
.3a423c	20 5d 22	jsr $3a225d	            JSR FINDLINE
.3a423f	90 27		bcc $3a4268	                BCC not_found               ; If not found... LINE NOT FOUND error
.3a4241	e2 20		sep #$20	            SEP #$20
.3a4243	a9 02		lda #$02	                LDA #EXEC_GOTO
.3a4245	85 dc		sta $08dc	                STA EXECACTION
.3a4247	28		plp		                PLP
.3a4248	60		rts		            RTS
.3a4249					syntax_err
.3a4249	08		php		            PHP
.3a424a	c2 20		rep #$20	            REP #$20
.3a424c	48		pha		            PHA
.3a424d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4250	5b		tcd		            TCD
.3a4251	68		pla		            PLA
.3a4252	28		plp		            PLP
.3a4253	e2 20		sep #$20	            SEP #$20
.3a4255	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4257	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a425b	c2 20		rep #$20	            REP #$20
.3a425d	29 ff 00	and #$00ff	            AND #$00FF
.3a4260	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4263	e2 20		sep #$20	            SEP #$20
.3a4265	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4268					not_found
.3a4268	08		php		            PHP
.3a4269	c2 20		rep #$20	            REP #$20
.3a426b	48		pha		            PHA
.3a426c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a426f	5b		tcd		            TCD
.3a4270	68		pla		            PLA
.3a4271	28		plp		            PLP
.3a4272	e2 20		sep #$20	            SEP #$20
.3a4274	a9 06		lda #$06	            LDA #ERR_NOLINE
.3a4276	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a427a	c2 20		rep #$20	            REP #$20
.3a427c	29 ff 00	and #$00ff	            AND #$00FF
.3a427f	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4282	e2 20		sep #$20	            SEP #$20
.3a4284	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4287					S_CLR
.3a4287	20 0f 18	jsr $3a180f	            JSR INITEVALSP
.3a428a	20 58 0f	jsr $3a0f58	            JSR INITHEAP
.3a428d	20 68 4e	jsr $3a4e68	            JSR INITVARS
.3a4290	60		rts		            RTS
.3a4291					S_LET
.3a4291	08		php		                PHP
.3a4292	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.3a4294	10 03		bpl $3a4299	                BPL get_name        ; If it's not a token, try to find the variable name
.3a4296	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4299					get_name
.3a4299	20 68 51	jsr $3a5168	            JSR VAR_FINDNAME
.3a429c	b0 03		bcs $3a42a1	                BCS check_array     ; If we didn't find a name, thrown an error
.3a429e	4c 08 43	jmp $3a4308	                JMP syntax_err
.3a42a1					check_array
.3a42a1	e2 20		sep #$20	            SEP #$20
.3a42a3	20 bf 20	jsr $3a20bf	            JSR PEEK_TOK
.3a42a6	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it a "("
.3a42a8	d0 0e		bne $3a42b8	                BNE get_value       ; No: it's a scalar assignment, look for the "="
.3a42aa	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a42ac	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a42af	a9 00		lda #$00	                LDA #0
.3a42b1	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF     ; Blank out the array index buffer
.3a42b5	20 91 19	jsr $3a1991	            JSR ARR_GETIDX
.3a42b8					get_value
.3a42b8	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a42bb	e2 20		sep #$20	            SEP #$20
.3a42bd	a7 00		lda [$0800]	                LDA [BIP]
.3a42bf	c9 8a		cmp #$8a	                CMP #TOK_EQ
.3a42c1	f0 03		beq $3a42c6	                BEQ found_eq        ; If not found: signal an syntax error
.3a42c3	4c 08 43	jmp $3a4308	                JMP syntax_err
.3a42c6					found_eq
.3a42c6	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a42c9	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Save the variable name for later
.3a42cb	48		pha		                PHA                 ; (it will get over-written by variable references)
.3a42cc	a5 e9		lda $08e9	                LDA TOFIND+2
.3a42ce	48		pha		                PHA
.3a42cf	a5 e8		lda $08e8	                LDA TOFIND+1
.3a42d1	48		pha		                PHA
.3a42d2	a5 e7		lda $08e7	                LDA TOFIND
.3a42d4	48		pha		                PHA
.3a42d5	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a42d8	68		pla		                PLA                 ; Restore the variable name
.3a42d9	85 e7		sta $08e7	                STA TOFIND
.3a42db	68		pla		                PLA
.3a42dc	85 e8		sta $08e8	                STA TOFIND+1
.3a42de	68		pla		                PLA
.3a42df	85 e9		sta $08e9	                STA TOFIND+2
.3a42e1	68		pla		                PLA
.3a42e2	85 ea		sta $08ea	                STA TOFINDTYPE
.3a42e4	29 80		and #$80	                AND #$80            ; Is it an array we're setting?
.3a42e6	f0 1b		beq $3a4303	                BEQ set_scalar      ; No: do a scalar variable set
.3a42e8	20 db 4e	jsr $3a4edb	            JSR VAR_FIND
.3a42eb	90 3a		bcc $3a4327	                BCC notfound_err
.3a42ed	c2 20		rep #$20	            REP #$20
.3a42ef	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.3a42f2	b7 08		lda [$0808],y	                LDA [INDEX],Y       ; Save the pointer to the array to CURRBLOCK
.3a42f4	85 c0		sta $08c0	                STA CURRBLOCK
.3a42f6	e2 20		sep #$20	            SEP #$20
.3a42f8	c8		iny		                INY
.3a42f9	c8		iny		                INY
.3a42fa	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a42fc	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a42fe	20 c7 65	jsr $3a65c7	            JSR ARR_SET
.3a4301	80 03		bra $3a4306	                BRA done            ; and we're finished!
.3a4303					set_scalar
.3a4303	20 cb 50	jsr $3a50cb	            JSR VAR_SET
.3a4306					done
.3a4306	28		plp		                PLP
.3a4307	60		rts		            RTS
.3a4308					syntax_err
.3a4308	08		php		            PHP
.3a4309	c2 20		rep #$20	            REP #$20
.3a430b	48		pha		            PHA
.3a430c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a430f	5b		tcd		            TCD
.3a4310	68		pla		            PLA
.3a4311	28		plp		            PLP
.3a4312	e2 20		sep #$20	            SEP #$20
.3a4314	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4316	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a431a	c2 20		rep #$20	            REP #$20
.3a431c	29 ff 00	and #$00ff	            AND #$00FF
.3a431f	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4322	e2 20		sep #$20	            SEP #$20
.3a4324	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4327					notfound_err
.3a4327	08		php		            PHP
.3a4328	c2 20		rep #$20	            REP #$20
.3a432a	48		pha		            PHA
.3a432b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a432e	5b		tcd		            TCD
.3a432f	68		pla		            PLA
.3a4330	28		plp		            PLP
.3a4331	e2 20		sep #$20	            SEP #$20
.3a4333	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.3a4335	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4339	c2 20		rep #$20	            REP #$20
.3a433b	29 ff 00	and #$00ff	            AND #$00FF
.3a433e	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4341	e2 20		sep #$20	            SEP #$20
.3a4343	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4346					S_PRINT
.3a4346	08		php		                PHP
.3a4347	e2 20		sep #$20	            SEP #$20
.3a4349	20 bf 20	jsr $3a20bf	            JSR PEEK_TOK
.3a434c	c9 00		cmp #$00	                CMP #0              ; Is it EOL or :?
.3a434e	f0 6d		beq $3a43bd	                BEQ pr_nl_exit      ; Yes: just print return
.3a4350					pr_loop
.3a4350	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4353	e2 20		sep #$20	            SEP #$20
.3a4355	a5 27		lda $0827	                LDA ARGTYPE1        ; Get the type of the result
.3a4357	c9 ff		cmp #$ff	                CMP #TYPE_NAV       ; Is is NAV?
.3a4359	f0 1b		beq $3a4376	                BEQ check_nl        ; Yes: we are probably just printing a newline
.3a435b	c9 02		cmp #$02	                CMP #TYPE_STRING    ; Is it a string?
.3a435d	d0 05		bne $3a4364	                BNE check_int       ; No: check to see if it's an integer
.3a435f	20 c2 43	jsr $3a43c2	            JSR PR_STRING
.3a4362	80 12		bra $3a4376	                BRA check_nl
.3a4364	c9 00		cmp #$00	check_int       CMP #TYPE_INTEGER   ; Is it an integer?
.3a4366	d0 05		bne $3a436d	                BNE check_float     ; No: check to see if it is a float
.3a4368	20 e2 43	jsr $3a43e2	            JSR PR_INTEGER
.3a436b	80 09		bra $3a4376	                BRA check_nl
.3a436d	c9 01		cmp #$01	check_float     CMP #TYPE_FLOAT     ; Is it a float?
.3a436f	d0 4f		bne $3a43c0	                BNE done            ; No: just quit
.3a4371	20 f5 43	jsr $3a43f5	            JSR PR_FLOAT
.3a4374	80 00		bra $3a4376	                BRA check_nl
.3a4376					check_nl
.3a4376	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a4379	a7 00		lda [$0800]	                LDA [BIP]
.3a437b	f0 40		beq $3a43bd	                BEQ pr_nl_exit      ; If it's nul, print a newline and return
.3a437d	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.3a437f	f0 3c		beq $3a43bd	                BEQ pr_nl_exit      ; print a newline and return
.3a4381	c9 2c		cmp #$2c	                CMP #','            ; If it's a comma
.3a4383	f0 23		beq $3a43a8	                BEQ pr_comma        ; Print a TAB and try another expression
.3a4385	c9 3b		cmp #$3b	                CMP #';'            ; If it's a semicolon...
.3a4387	f0 24		beq $3a43ad	                BEQ is_more         ; Print nothing, and try another expression
.3a4389	08		php		            PHP
.3a438a	c2 20		rep #$20	            REP #$20
.3a438c	48		pha		            PHA
.3a438d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4390	5b		tcd		            TCD
.3a4391	68		pla		            PLA
.3a4392	28		plp		            PLP
.3a4393	e2 20		sep #$20	            SEP #$20
.3a4395	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4397	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a439b	c2 20		rep #$20	            REP #$20
.3a439d	29 ff 00	and #$00ff	            AND #$00FF
.3a43a0	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a43a3	e2 20		sep #$20	            SEP #$20
.3a43a5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a43a8	a9 09		lda #$09	pr_comma        LDA #CHAR_TAB       ; Print a TAB
.3a43aa	20 18 00	jsr $3a0018	            JSR PRINTC
.3a43ad					is_more
.3a43ad	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a43b0	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a43b3	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.3a43b5	f0 09		beq $3a43c0	                BEQ done            ; If it's NULL, return without printing a newline
.3a43b7	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.3a43b9	f0 05		beq $3a43c0	                BEQ done            ; ... return without printing a newline
.3a43bb	80 93		bra $3a4350	                BRA pr_loop         ; Otherwise, we should have another expression, try to handle it
.3a43bd					pr_nl_exit
.3a43bd	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a43c0	28		plp		done            PLP
.3a43c1	60		rts		            RTS
.3a43c2					PR_STRING
.3a43c2	08		php		                PHP
.3a43c3	8b		phb		                PHB
.3a43c4	08		php		            PHP
.3a43c5	c2 20		rep #$20	            REP #$20
.3a43c7	48		pha		            PHA
.3a43c8	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a43cb	5b		tcd		            TCD
.3a43cc	68		pla		            PLA
.3a43cd	28		plp		            PLP
.3a43ce	e2 20		sep #$20	            SEP #$20
.3a43d0	c2 10		rep #$10	            REP #$10
.3a43d2	a0 00 00	ldy #$0000	                LDY #0
.3a43d5	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y
.3a43d7	f0 06		beq $3a43df	                BEQ done
.3a43d9	20 18 00	jsr $3a0018	            JSR PRINTC
.3a43dc	c8		iny		                INY
.3a43dd	80 f6		bra $3a43d5	                BRA loop
.3a43df	ab		plb		done            PLB
.3a43e0	28		plp		                PLP
.3a43e1	60		rts		            RTS
.3a43e2					PR_INTEGER
.3a43e2	08		php		                PHP
.3a43e3	c2 20		rep #$20	            REP #$20
.3a43e5	20 0d 14	jsr $3a140d	            JSR ITOS
.3a43e8	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.3a43ea	85 23		sta $0823	                STA ARGUMENT1
.3a43ec	a5 18		lda $0818	                LDA STRPTR+2
.3a43ee	85 25		sta $0825	                STA ARGUMENT1+2
.3a43f0	20 c2 43	jsr $3a43c2	            JSR PR_STRING
.3a43f3	28		plp		                PLP
.3a43f4	60		rts		            RTS
.3a43f5					PR_FLOAT
.3a43f5	08		php		                PHP
.3a43f6	20 31 5b	jsr $3a5b31	            JSR FTOS
.3a43f9	c2 20		rep #$20	            REP #$20
.3a43fb	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.3a43fd	85 23		sta $0823	                STA ARGUMENT1
.3a43ff	a5 18		lda $0818	                LDA STRPTR+2
.3a4401	85 25		sta $0825	                STA ARGUMENT1+2
.3a4403	20 c2 43	jsr $3a43c2	            JSR PR_STRING
.3a4406	28		plp		                PLP
.3a4407	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\functions.s


;******  Processing file: src\C256/functions_c256.s

.3a4408					BCD2STR
.3a4408	08		php		            PHP
.3a4409	e2 20		sep #$20	            SEP #$20
.3a440b	85 b5		sta $08b5	            STA SAVE_A
.3a440d	4a		lsr a		            LSR A
.3a440e	4a		lsr a		            LSR A
.3a440f	4a		lsr a		            LSR A
.3a4410	4a		lsr a		            LSR A
.3a4411	29 0f		and #$0f	            AND #$0F
.3a4413	18		clc		            CLC
.3a4414	69 30		adc #$30	            ADC #'0'
.3a4416	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a4418	c8		iny		            INY
.3a4419	a5 b5		lda $08b5	            LDA SAVE_A
.3a441b	29 0f		and #$0f	            AND #$0F
.3a441d	18		clc		            CLC
.3a441e	69 30		adc #$30	            ADC #'0'
.3a4420	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a4422	c8		iny		            INY
.3a4423	28		plp		            PLP
.3a4424	60		rts		            RTS
.3a4425					F_GETDATE
.3a4425	e2 20		sep #$20	            SEP #$20
.3a4427	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4429	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a442c	08		php		            PHP
.3a442d	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4430	e2 20		sep #$20	            SEP #$20
.3a4432	c2 10		rep #$10	            REP #$10
.3a4434	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.3a4438	09 08		ora #$08	            ORA #%00001000
.3a443a	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.3a443e	20 ae 13	jsr $3a13ae	            JSR TEMPSTRING
.3a4441	a0 00 00	ldy #$0000	            LDY #0
.3a4444	af 06 08 af	lda $af0806	            LDA @lRTC_DAY           ; Write the day of the month
.3a4448	20 08 44	jsr $3a4408	            JSR BCD2STR
.3a444b	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.3a444d	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a444f	c8		iny		            INY
.3a4450	af 09 08 af	lda $af0809	            LDA @lRTC_MONTH         ; Write the month
.3a4454	20 08 44	jsr $3a4408	            JSR BCD2STR
.3a4457	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.3a4459	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a445b	c8		iny		            INY
.3a445c	af 0f 08 af	lda $af080f	            LDA @lRTC_CENTURY       ; Write the year
.3a4460	20 08 44	jsr $3a4408	            JSR BCD2STR
.3a4463	af 0a 08 af	lda $af080a	            LDA @lRTC_YEAR          ; Write the year
.3a4467	20 08 44	jsr $3a4408	            JSR BCD2STR
.3a446a	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.3a446c	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a446e	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.3a4472	29 f7		and #$f7	            AND #%11110111
.3a4474	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.3a4478	c2 20		rep #$20	            REP #$20
.3a447a	a5 16		lda $0816	            LDA STRPTR
.3a447c	85 23		sta $0823	            STA ARGUMENT1
.3a447e	a5 18		lda $0818	            LDA STRPTR+2
.3a4480	85 25		sta $0825	            STA ARGUMENT1+2
.3a4482	e2 20		sep #$20	            SEP #$20
.3a4484	a9 02		lda #$02	            LDA #TYPE_STRING
.3a4486	85 27		sta $0827	            STA ARGTYPE1
.3a4488	28		plp		            PLP
.3a4489	e2 20		sep #$20	            SEP #$20
.3a448b	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a448e	60		rts		            RTS
.3a448f					F_GETTIME
.3a448f	e2 20		sep #$20	            SEP #$20
.3a4491	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4493	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4496	08		php		            PHP
.3a4497	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a449a	e2 20		sep #$20	            SEP #$20
.3a449c	c2 10		rep #$10	            REP #$10
.3a449e	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.3a44a2	09 08		ora #$08	            ORA #%00001000
.3a44a4	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.3a44a8	20 ae 13	jsr $3a13ae	            JSR TEMPSTRING
.3a44ab	a0 00 00	ldy #$0000	            LDY #0
.3a44ae	af 04 08 af	lda $af0804	            LDA @lRTC_HRS           ; Write the hour
.3a44b2	29 7f		and #$7f	            AND #$7F                ; Trim out the AM/PM indicator
.3a44b4	20 08 44	jsr $3a4408	            JSR BCD2STR
.3a44b7	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.3a44b9	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a44bb	c8		iny		            INY
.3a44bc	af 02 08 af	lda $af0802	            LDA @lRTC_MIN           ; Write the minute
.3a44c0	20 08 44	jsr $3a4408	            JSR BCD2STR
.3a44c3	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.3a44c5	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a44c7	c8		iny		            INY
.3a44c8	af 00 08 af	lda $af0800	            LDA @lRTC_SEC           ; Write the second
.3a44cc	20 08 44	jsr $3a4408	            JSR BCD2STR
.3a44cf	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.3a44d1	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a44d3	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.3a44d7	29 f7		and #$f7	            AND #%11110111
.3a44d9	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.3a44dd	c2 20		rep #$20	            REP #$20
.3a44df	a5 16		lda $0816	            LDA STRPTR
.3a44e1	85 23		sta $0823	            STA ARGUMENT1
.3a44e3	a5 18		lda $0818	            LDA STRPTR+2
.3a44e5	85 25		sta $0825	            STA ARGUMENT1+2
.3a44e7	e2 20		sep #$20	            SEP #$20
.3a44e9	a9 02		lda #$02	            LDA #TYPE_STRING
.3a44eb	85 27		sta $0827	            STA ARGTYPE1
.3a44ed	28		plp		            PLP
.3a44ee	e2 20		sep #$20	            SEP #$20
.3a44f0	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a44f3	60		rts		            RTS
.3a44f4					FN_RND
.3a44f4	e2 20		sep #$20	            SEP #$20
.3a44f6	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a44f8	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a44fb	08		php		            PHP
.3a44fc	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a44ff	e2 20		sep #$20	            SEP #$20
.3a4501	a9 01		lda #$01	            LDA #TYPE_FLOAT             ; We'll return a floating point number
.3a4503	85 27		sta $0827	            STA ARGTYPE1
.3a4505	a9 03		lda #$03	            LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.3a4507	8f 00 e2 af	sta $afe200	            STA @l FP_MATH_CTRL0        ; Expect fixed point numbers
.3a450b	a9 01		lda #$01	            LDA #FP_OUT_DIV             ; Set us to do a division
.3a450d	8f 01 e2 af	sta $afe201	            STA @l FP_MATH_CTRL1
.3a4511	c2 30		rep #$30	            REP #$30
.3a4513	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get a random 16-bits
.3a4517	8f 08 e2 af	sta $afe208	            STA @l FP_MATH_INPUT0_LL    ; Send them to the FP unit
.3a451b	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get another random 16-bits
.3a451f	29 ff 7f	and #$7fff	            AND #$7FFF                  ; Make sure it's positive
.3a4522	8f 0a e2 af	sta $afe20a	            STA @l FP_MATH_INPUT0_LL+2  ; Send them to the FP unit
.3a4526	a9 ff ff	lda #$ffff	            LDA #$FFFF                  ; Get the maximum value
.3a4529	8f 0c e2 af	sta $afe20c	            STA @l FP_MATH_INPUT1_LL    ; Send it to the FP unit
.3a452d	a9 ff 7f	lda #$7fff	            LDA #$7FFF
.3a4530	8f 0e e2 af	sta $afe20e	            STA @l FP_MATH_INPUT1_LL+2
.3a4534	ea		nop		            NOP
.3a4535	ea		nop		            NOP
.3a4536	ea		nop		            NOP
.3a4537	af 08 e2 af	lda $afe208	            LDA @l FP_MATH_OUTPUT_FP_LL     ; Get the normalized result
.3a453b	85 23		sta $0823	            STA ARGUMENT1
.3a453d	af 0a e2 af	lda $afe20a	            LDA @l FP_MATH_OUTPUT_FP_LL+2
.3a4541	85 25		sta $0825	            STA ARGUMENT1+2
.3a4543	28		plp		            PLP
.3a4544	e2 20		sep #$20	            SEP #$20
.3a4546	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4549	60		rts		            RTS

;******  Return to file: src\functions.s

.3a454a					FN_MID
.3a454a	e2 20		sep #$20	            SEP #$20
.3a454c	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a454e	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4551	08		php		                PHP
.3a4552	c2 30		rep #$30	            REP #$30
.3a4554	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4557	20 95 05	jsr $3a0595	            JSR ASS_ARG1_STR
.3a455a					save_string
.3a455a	c2 20		rep #$20	            REP #$20
.3a455c	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.3a455e	48		pha		                PHA
.3a455f	a5 23		lda $0823	                LDA ARGUMENT1
.3a4561	48		pha		                PHA
.3a4562	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a4565	e2 20		sep #$20	            SEP #$20
.3a4567	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.3a4569	c9 2c		cmp #$2c	                CMP #','
.3a456b	f0 03		beq $3a4570	                BEQ skip_comma1
.3a456d	4c c1 45	jmp $3a45c1	                JMP syntax_err
.3a4570					skip_comma1
.3a4570	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4573	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4576	20 bf 05	jsr $3a05bf	            JSR ASS_ARG1_INT16
.3a4579	c2 20		rep #$20	            REP #$20
.3a457b	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the index
.3a457d	48		pha		                PHA
.3a457e	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a4581	e2 20		sep #$20	            SEP #$20
.3a4583	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.3a4585	c9 2c		cmp #$2c	                CMP #','
.3a4587	f0 03		beq $3a458c	                BEQ skip_comma2
.3a4589	4c c1 45	jmp $3a45c1	                JMP syntax_err
.3a458c					skip_comma2
.3a458c	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a458f	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4592	20 bf 05	jsr $3a05bf	            JSR ASS_ARG1_INT16
.3a4595	c2 20		rep #$20	            REP #$20
.3a4597	a5 23		lda $0823	            LDA ARGUMENT1
.3a4599	85 8f		sta $088f	            STA MCOUNT
.3a459b	e2 20		sep #$20	            SEP #$20
.3a459d	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a459f	85 91		sta $0891	            STA MCOUNT+2
.3a45a1	c2 20		rep #$20	            REP #$20
.3a45a3	68		pla		                PLA                         ; Restore index
.3a45a4	85 29		sta $0829	                STA ARGUMENT2               ; ... to ARGUMENT2
.3a45a6	a9 00 00	lda #$0000	                LDA #0
.3a45a9	85 2b		sta $082b	                STA ARGUMENT2+2
.3a45ab	68		pla		                PLA                         ; Restore string
.3a45ac	85 23		sta $0823	                STA ARGUMENT1               ; ... to ARGUMENT1
.3a45ae	68		pla		                PLA
.3a45af	85 25		sta $0825	                STA ARGUMENT1+2
.3a45b1	e2 20		sep #$20	            SEP #$20
.3a45b3	a9 02		lda #$02	            LDA #<TYPE_STRING
.3a45b5	85 27		sta $0827	            STA ARGTYPE1
.3a45b7	20 06 16	jsr $3a1606	            JSR STRSUBSTR
.3a45ba					done
.3a45ba	e2 20		sep #$20	            SEP #$20
.3a45bc	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a45bf	28		plp		                PLP
.3a45c0	60		rts		            RTS
.3a45c1					syntax_err
.3a45c1	08		php		            PHP
.3a45c2	c2 20		rep #$20	            REP #$20
.3a45c4	48		pha		            PHA
.3a45c5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a45c8	5b		tcd		            TCD
.3a45c9	68		pla		            PLA
.3a45ca	28		plp		            PLP
.3a45cb	e2 20		sep #$20	            SEP #$20
.3a45cd	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a45cf	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a45d3	c2 20		rep #$20	            REP #$20
.3a45d5	29 ff 00	and #$00ff	            AND #$00FF
.3a45d8	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a45db	e2 20		sep #$20	            SEP #$20
.3a45dd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a45e0					range_err
.3a45e0	08		php		            PHP
.3a45e1	c2 20		rep #$20	            REP #$20
.3a45e3	48		pha		            PHA
.3a45e4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a45e7	5b		tcd		            TCD
.3a45e8	68		pla		            PLA
.3a45e9	28		plp		            PLP
.3a45ea	e2 20		sep #$20	            SEP #$20
.3a45ec	a9 09		lda #$09	            LDA #ERR_RANGE
.3a45ee	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a45f2	c2 20		rep #$20	            REP #$20
.3a45f4	29 ff 00	and #$00ff	            AND #$00FF
.3a45f7	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a45fa	e2 20		sep #$20	            SEP #$20
.3a45fc	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a45ff					FN_RIGHT
.3a45ff	e2 20		sep #$20	            SEP #$20
.3a4601	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4603	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4606	08		php		                PHP
.3a4607	c2 30		rep #$30	            REP #$30
.3a4609	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a460c	e2 20		sep #$20	            SEP #$20
.3a460e	a5 27		lda $0827	                LDA ARGTYPE1
.3a4610	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a4612	f0 03		beq $3a4617	                BEQ save_string
.3a4614	4c 83 46	jmp $3a4683	                JMP type_mismatch           ; Type mismatch if it's not a string
.3a4617					save_string
.3a4617	c2 20		rep #$20	            REP #$20
.3a4619	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.3a461b	48		pha		                PHA
.3a461c	a5 23		lda $0823	                LDA ARGUMENT1
.3a461e	48		pha		                PHA
.3a461f	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a4622	e2 20		sep #$20	            SEP #$20
.3a4624	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.3a4626	c9 2c		cmp #$2c	                CMP #','
.3a4628	f0 03		beq $3a462d	                BEQ skip_comma
.3a462a	4c a2 46	jmp $3a46a2	                JMP syntax_err
.3a462d					skip_comma
.3a462d	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4630	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4633	e2 20		sep #$20	            SEP #$20
.3a4635	a5 27		lda $0827	                LDA ARGTYPE1
.3a4637	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4639	d0 48		bne $3a4683	                BNE type_mismatch           ; Type mismatch if it's not an integer
.3a463b	c2 20		rep #$20	            REP #$20
.3a463d	a5 23		lda $0823	            LDA ARGUMENT1
.3a463f	85 8f		sta $088f	            STA MCOUNT
.3a4641	c2 20		rep #$20	            REP #$20
.3a4643	68		pla		                PLA                         ; Recover the string pointer
.3a4644	85 23		sta $0823	                STA ARGUMENT1
.3a4646	68		pla		                PLA
.3a4647	85 25		sta $0825	                STA ARGUMENT1+2
.3a4649	e2 20		sep #$20	            SEP #$20
.3a464b	a9 02		lda #$02	            LDA #<TYPE_STRING
.3a464d	85 27		sta $0827	            STA ARGTYPE1
.3a464f	e2 20		sep #$20	            SEP #$20
.3a4651	a0 00 00	ldy #$0000	                LDY #0
.3a4654	b7 23		lda [$0823],y	count_loop      LDA [ARGUMENT1],Y
.3a4656	f0 03		beq $3a465b	                BEQ count_done
.3a4658	c8		iny		                INY
.3a4659	80 f9		bra $3a4654	                BRA count_loop
.3a465b					count_done
.3a465b	c2 20		rep #$20	            REP #$20
.3a465d	98		tya		                TYA                         ; ARGUMENT2 := LENGTH - MCOUNT
.3a465e	38		sec		                SEC
.3a465f	e5 8f		sbc $088f	                SBC MCOUNT
.3a4661	30 09		bmi $3a466c	                BMI index0                  ; if ARGUMENT2 < 0, set ARGUMENT2 := 0
.3a4663	85 29		sta $0829	                STA ARGUMENT2
.3a4665	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT2[23..16] := 0
.3a4668	85 2b		sta $082b	                STA ARGUMENT2+2
.3a466a	80 07		bra $3a4673	                BRA slice
.3a466c	a9 00 00	lda #$0000	index0          LDA #0                      ; 0 is the floor for the index
.3a466f	85 29		sta $0829	                STA ARGUMENT2
.3a4671	85 2b		sta $082b	                STA ARGUMENT2+2
.3a4673					slice
.3a4673	e2 20		sep #$20	            SEP #$20
.3a4675	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.3a4677	85 2d		sta $082d	            STA ARGTYPE2
.3a4679	20 06 16	jsr $3a1606	            JSR STRSUBSTR
.3a467c					done
.3a467c	e2 20		sep #$20	            SEP #$20
.3a467e	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4681	28		plp		                PLP
.3a4682	60		rts		            RTS
.3a4683					type_mismatch
.3a4683	08		php		            PHP
.3a4684	c2 20		rep #$20	            REP #$20
.3a4686	48		pha		            PHA
.3a4687	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a468a	5b		tcd		            TCD
.3a468b	68		pla		            PLA
.3a468c	28		plp		            PLP
.3a468d	e2 20		sep #$20	            SEP #$20
.3a468f	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4691	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4695	c2 20		rep #$20	            REP #$20
.3a4697	29 ff 00	and #$00ff	            AND #$00FF
.3a469a	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a469d	e2 20		sep #$20	            SEP #$20
.3a469f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a46a2					syntax_err
.3a46a2	08		php		            PHP
.3a46a3	c2 20		rep #$20	            REP #$20
.3a46a5	48		pha		            PHA
.3a46a6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a46a9	5b		tcd		            TCD
.3a46aa	68		pla		            PLA
.3a46ab	28		plp		            PLP
.3a46ac	e2 20		sep #$20	            SEP #$20
.3a46ae	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a46b0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a46b4	c2 20		rep #$20	            REP #$20
.3a46b6	29 ff 00	and #$00ff	            AND #$00FF
.3a46b9	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a46bc	e2 20		sep #$20	            SEP #$20
.3a46be	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a46c1					range_err
.3a46c1	08		php		            PHP
.3a46c2	c2 20		rep #$20	            REP #$20
.3a46c4	48		pha		            PHA
.3a46c5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a46c8	5b		tcd		            TCD
.3a46c9	68		pla		            PLA
.3a46ca	28		plp		            PLP
.3a46cb	e2 20		sep #$20	            SEP #$20
.3a46cd	a9 09		lda #$09	            LDA #ERR_RANGE
.3a46cf	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a46d3	c2 20		rep #$20	            REP #$20
.3a46d5	29 ff 00	and #$00ff	            AND #$00FF
.3a46d8	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a46db	e2 20		sep #$20	            SEP #$20
.3a46dd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a46e0					FN_LEFT
.3a46e0	e2 20		sep #$20	            SEP #$20
.3a46e2	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a46e4	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a46e7	08		php		                PHP
.3a46e8	c2 30		rep #$30	            REP #$30
.3a46ea	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a46ed	e2 20		sep #$20	            SEP #$20
.3a46ef	a5 27		lda $0827	                LDA ARGTYPE1
.3a46f1	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a46f3	f0 03		beq $3a46f8	                BEQ save_string
.3a46f5	4c 4c 47	jmp $3a474c	                JMP type_mismatch           ; Type mismatch if it's not a string
.3a46f8					save_string
.3a46f8	c2 20		rep #$20	            REP #$20
.3a46fa	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.3a46fc	48		pha		                PHA
.3a46fd	a5 23		lda $0823	                LDA ARGUMENT1
.3a46ff	48		pha		                PHA
.3a4700	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a4703	e2 20		sep #$20	            SEP #$20
.3a4705	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.3a4707	c9 2c		cmp #$2c	                CMP #','
.3a4709	f0 03		beq $3a470e	                BEQ skip_comma
.3a470b	4c 6b 47	jmp $3a476b	                JMP syntax_err
.3a470e					skip_comma
.3a470e	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4711	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4714	e2 20		sep #$20	            SEP #$20
.3a4716	a5 27		lda $0827	                LDA ARGTYPE1
.3a4718	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a471a	d0 30		bne $3a474c	                BNE type_mismatch           ; Type mismatch if it's not an integer
.3a471c	c2 20		rep #$20	            REP #$20
.3a471e	a5 23		lda $0823	            LDA ARGUMENT1
.3a4720	85 8f		sta $088f	            STA MCOUNT
.3a4722	c2 20		rep #$20	            REP #$20
.3a4724	a9 00 00	lda #$0000	            LDA #<>0
.3a4727	85 29		sta $0829	            STA ARGUMENT2
.3a4729	a9 00 00	lda #$0000	            LDA #(0 >> 16)
.3a472c	85 2b		sta $082b	            STA ARGUMENT2+2
.3a472e	e2 20		sep #$20	            SEP #$20
.3a4730	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.3a4732	85 2d		sta $082d	            STA ARGTYPE2
.3a4734	c2 20		rep #$20	            REP #$20
.3a4736	68		pla		                PLA                         ; Recover the string pointer
.3a4737	85 23		sta $0823	                STA ARGUMENT1
.3a4739	68		pla		                PLA
.3a473a	85 25		sta $0825	                STA ARGUMENT1+2
.3a473c	e2 20		sep #$20	            SEP #$20
.3a473e	a9 02		lda #$02	            LDA #<TYPE_STRING
.3a4740	85 27		sta $0827	            STA ARGTYPE1
.3a4742	20 06 16	jsr $3a1606	            JSR STRSUBSTR
.3a4745					done
.3a4745	e2 20		sep #$20	            SEP #$20
.3a4747	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a474a	28		plp		                PLP
.3a474b	60		rts		            RTS
.3a474c					type_mismatch
.3a474c	08		php		            PHP
.3a474d	c2 20		rep #$20	            REP #$20
.3a474f	48		pha		            PHA
.3a4750	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4753	5b		tcd		            TCD
.3a4754	68		pla		            PLA
.3a4755	28		plp		            PLP
.3a4756	e2 20		sep #$20	            SEP #$20
.3a4758	a9 04		lda #$04	            LDA #ERR_TYPE
.3a475a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a475e	c2 20		rep #$20	            REP #$20
.3a4760	29 ff 00	and #$00ff	            AND #$00FF
.3a4763	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4766	e2 20		sep #$20	            SEP #$20
.3a4768	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a476b					syntax_err
.3a476b	08		php		            PHP
.3a476c	c2 20		rep #$20	            REP #$20
.3a476e	48		pha		            PHA
.3a476f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4772	5b		tcd		            TCD
.3a4773	68		pla		            PLA
.3a4774	28		plp		            PLP
.3a4775	e2 20		sep #$20	            SEP #$20
.3a4777	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4779	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a477d	c2 20		rep #$20	            REP #$20
.3a477f	29 ff 00	and #$00ff	            AND #$00FF
.3a4782	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4785	e2 20		sep #$20	            SEP #$20
.3a4787	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a478a					range_err
.3a478a	08		php		            PHP
.3a478b	c2 20		rep #$20	            REP #$20
.3a478d	48		pha		            PHA
.3a478e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4791	5b		tcd		            TCD
.3a4792	68		pla		            PLA
.3a4793	28		plp		            PLP
.3a4794	e2 20		sep #$20	            SEP #$20
.3a4796	a9 09		lda #$09	            LDA #ERR_RANGE
.3a4798	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a479c	c2 20		rep #$20	            REP #$20
.3a479e	29 ff 00	and #$00ff	            AND #$00FF
.3a47a1	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a47a4	e2 20		sep #$20	            SEP #$20
.3a47a6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a47a9					FN_VAL
.3a47a9	e2 20		sep #$20	            SEP #$20
.3a47ab	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a47ad	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a47b0	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a47b3	c2 10		rep #$10	            REP #$10
.3a47b5	e2 20		sep #$20	            SEP #$20
.3a47b7	a5 27		lda $0827	                LDA ARGTYPE1
.3a47b9	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a47bb	d0 23		bne $3a47e0	                BNE type_mismatch
.3a47bd	c2 20		rep #$20	            REP #$20
.3a47bf	a5 00		lda $0800	                LDA BIP             ; preserve BIP for later
.3a47c1	85 40		sta $0840	                STA SAVEBIP
.3a47c3	a5 02		lda $0802	                LDA BIP+2
.3a47c5	85 42		sta $0842	                STA SAVEBIP+2
.3a47c7	a5 23		lda $0823	                LDA ARGUMENT1       ; Temporarily point BIP to the string to parse
.3a47c9	85 00		sta $0800	                STA BIP
.3a47cb	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a47cd	85 02		sta $0802	                STA BIP+2
.3a47cf	20 8a 07	jsr $3a078a	            JSR PARSEINT
.3a47d2	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.3a47d4	85 00		sta $0800	                STA BIP
.3a47d6	a5 42		lda $0842	                LDA SAVEBIP+2
.3a47d8	85 02		sta $0802	                STA BIP+2
.3a47da	e2 20		sep #$20	            SEP #$20
.3a47dc	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a47df	60		rts		            RTS
.3a47e0					type_mismatch
.3a47e0	08		php		            PHP
.3a47e1	c2 20		rep #$20	            REP #$20
.3a47e3	48		pha		            PHA
.3a47e4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a47e7	5b		tcd		            TCD
.3a47e8	68		pla		            PLA
.3a47e9	28		plp		            PLP
.3a47ea	e2 20		sep #$20	            SEP #$20
.3a47ec	a9 04		lda #$04	            LDA #ERR_TYPE
.3a47ee	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a47f2	c2 20		rep #$20	            REP #$20
.3a47f4	29 ff 00	and #$00ff	            AND #$00FF
.3a47f7	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a47fa	e2 20		sep #$20	            SEP #$20
.3a47fc	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a47ff					FN_STR
.3a47ff	e2 20		sep #$20	            SEP #$20
.3a4801	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4803	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4806	08		php		                PHP
.3a4807	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a480a	c2 10		rep #$10	            REP #$10
.3a480c	e2 20		sep #$20	            SEP #$20
.3a480e	a5 27		lda $0827	                LDA ARGTYPE1
.3a4810	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4812	d0 1a		bne $3a482e	                BNE type_mismatch
.3a4814	20 0d 14	jsr $3a140d	            JSR ITOS
.3a4817	c2 20		rep #$20	            REP #$20
.3a4819	a5 16		lda $0816	                LDA STRPTR          ; Prepare the return result
.3a481b	85 23		sta $0823	                STA ARGUMENT1
.3a481d	a5 18		lda $0818	                LDA STRPTR+2
.3a481f	85 25		sta $0825	                STA ARGUMENT1+2
.3a4821	e2 20		sep #$20	            SEP #$20
.3a4823	a9 02		lda #$02	                LDA #TYPE_STRING
.3a4825	85 27		sta $0827	                STA ARGTYPE1
.3a4827	28		plp		                PLP
.3a4828	e2 20		sep #$20	            SEP #$20
.3a482a	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a482d	60		rts		            RTS
.3a482e					type_mismatch
.3a482e	08		php		            PHP
.3a482f	c2 20		rep #$20	            REP #$20
.3a4831	48		pha		            PHA
.3a4832	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4835	5b		tcd		            TCD
.3a4836	68		pla		            PLA
.3a4837	28		plp		            PLP
.3a4838	e2 20		sep #$20	            SEP #$20
.3a483a	a9 04		lda #$04	            LDA #ERR_TYPE
.3a483c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4840	c2 20		rep #$20	            REP #$20
.3a4842	29 ff 00	and #$00ff	            AND #$00FF
.3a4845	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4848	e2 20		sep #$20	            SEP #$20
.3a484a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a484d					FN_DEC
.3a484d	e2 20		sep #$20	            SEP #$20
.3a484f	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4851	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4854	08		php		                PHP
.3a4855	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4858	20 95 05	jsr $3a0595	            JSR ASS_ARG1_STR
.3a485b	c2 20		rep #$20	            REP #$20
.3a485d	64 0c		stz $080c	                STZ SCRATCH
.3a485f	64 0e		stz $080e	                STZ SCRATCH+2
.3a4861	e2 30		sep #$30	            SEP #$30
.3a4863	a0 00		ldy #$00	                LDY #0
.3a4865	b7 23		lda [$0823],y	skip_loop       LDA [ARGUMENT1],Y
.3a4867	c9 20		cmp #$20	                CMP #CHAR_SP
.3a4869	f0 04		beq $3a486f	                BEQ skip_char
.3a486b	c9 24		cmp #$24	                CMP #'$'
.3a486d	d0 03		bne $3a4872	                BNE loop
.3a486f	c8		iny		skip_char       INY
.3a4870	80 f3		bra $3a4865	                BRA skip_loop
.3a4872	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y   ; Check the character
.3a4874	20 be 03	jsr $3a03be	            JSR ISHEX
.3a4877	90 1e		bcc $3a4897	                BCC ret_result      ; No: return what we have so far
.3a4879	c2 20		rep #$20	            REP #$20
.3a487b	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.3a487d	26 0e		rol $080e	                ROL SCRATCH+2
.3a487f	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.3a4881	26 0e		rol $080e	                ROL SCRATCH+2
.3a4883	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.3a4885	26 0e		rol $080e	                ROL SCRATCH+2
.3a4887	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.3a4889	26 0e		rol $080e	                ROL SCRATCH+2
.3a488b	e2 20		sep #$20	            SEP #$20
.3a488d	20 df 03	jsr $3a03df	            JSR HEX2BIN
.3a4890	05 0c		ora $080c	                ORA SCRATCH
.3a4892	85 0c		sta $080c	                STA SCRATCH         ; And add it to the result
.3a4894	c8		iny		                INY
.3a4895	80 db		bra $3a4872	                BRA loop            ; And try the next character
.3a4897					ret_result
.3a4897	c2 20		rep #$20	            REP #$20
.3a4899	a5 0c		lda $080c	                LDA SCRATCH         ; Return the result
.3a489b	85 23		sta $0823	                STA ARGUMENT1
.3a489d	a5 0e		lda $080e	                LDA SCRATCH+2
.3a489f	85 25		sta $0825	                STA ARGUMENT1+2
.3a48a1	e2 20		sep #$20	            SEP #$20
.3a48a3	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a48a5	85 27		sta $0827	                STA ARGTYPE1
.3a48a7	28		plp		                PLP
.3a48a8	e2 20		sep #$20	            SEP #$20
.3a48aa	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a48ad	60		rts		            RTS
.3a48ae					FN_HEX
.3a48ae	e2 20		sep #$20	            SEP #$20
.3a48b0	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a48b2	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a48b5	08		php		                PHP
.3a48b6	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a48b9	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a48bc	20 ae 13	jsr $3a13ae	            JSR TEMPSTRING
.3a48bf	e2 30		sep #$30	            SEP #$30
.3a48c1	a0 ff		ldy #$ff	                LDY #$FF            ; Terminate the string
.3a48c3	a9 00		lda #$00	                LDA #0
.3a48c5	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a48c7	88		dey		                DEY
.3a48c8	a5 23		lda $0823	loop            LDA ARGUMENT1       ; Write the low digit
.3a48ca	29 0f		and #$0f	                AND #$0F
.3a48cc	aa		tax		                TAX
.3a48cd	bf 00 d0 3a	lda $3ad000,x	                LDA @lHEXDIGITS,X
.3a48d1	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a48d3	88		dey		                DEY
.3a48d4	a5 23		lda $0823	                LDA ARGUMENT1       ; Write the high digit
.3a48d6	29 f0		and #$f0	                AND #$F0
.3a48d8	4a		lsr a		                LSR A
.3a48d9	4a		lsr a		                LSR A
.3a48da	4a		lsr a		                LSR A
.3a48db	4a		lsr a		                LSR A
.3a48dc	aa		tax		                TAX
.3a48dd	bf 00 d0 3a	lda $3ad000,x	                LDA @lHEXDIGITS,X
.3a48e1	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a48e3	88		dey		                DEY
.3a48e4	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Shift value by one byte
.3a48e6	85 23		sta $0823	                STA ARGUMENT1
.3a48e8	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a48ea	85 24		sta $0824	                STA ARGUMENT1+1
.3a48ec	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a48ee	85 25		sta $0825	                STA ARGUMENT1+2
.3a48f0	a9 00		lda #$00	                LDA #0
.3a48f2	85 26		sta $0826	                STA ARGUMENT1+3
.3a48f4	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the argument 0?
.3a48f6	d0 d0		bne $3a48c8	                BNE loop            ; No: keep converting
.3a48f8	a5 24		lda $0824	                LDA ARGUMENT1+1
.3a48fa	d0 cc		bne $3a48c8	                BNE loop
.3a48fc	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a48fe	d0 c8		bne $3a48c8	                BNE loop
.3a4900	98		tya		                TYA                 ; Get the index of the first free char
.3a4901	38		sec		                SEC                 ; Add 1 to get to the first character of the string
.3a4902	65 16		adc $0816	                ADC STRPTR          ; And add the whole thing to the temp string pointer
.3a4904	85 23		sta $0823	                STA ARGUMENT1       ; And return it as the result
.3a4906	a5 17		lda $0817	                LDA STRPTR+1
.3a4908	85 24		sta $0824	                STA ARGUMENT1+1
.3a490a	a5 18		lda $0818	                LDA STRPTR+2
.3a490c	85 25		sta $0825	                STA ARGUMENT1+2
.3a490e	a5 19		lda $0819	                LDA STRPTR+3
.3a4910	85 26		sta $0826	                STA ARGUMENT1+3
.3a4912	a9 02		lda #$02	                LDA #TYPE_STRING    ; And make the type STRING
.3a4914	85 27		sta $0827	                STA ARGTYPE1
.3a4916	28		plp		                PLP
.3a4917	e2 20		sep #$20	            SEP #$20
.3a4919	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a491c	60		rts		            RTS
.3a491d					type_mismatch
.3a491d	08		php		            PHP
.3a491e	c2 20		rep #$20	            REP #$20
.3a4920	48		pha		            PHA
.3a4921	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4924	5b		tcd		            TCD
.3a4925	68		pla		            PLA
.3a4926	28		plp		            PLP
.3a4927	e2 20		sep #$20	            SEP #$20
.3a4929	a9 04		lda #$04	            LDA #ERR_TYPE
.3a492b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a492f	c2 20		rep #$20	            REP #$20
.3a4931	29 ff 00	and #$00ff	            AND #$00FF
.3a4934	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4937	e2 20		sep #$20	            SEP #$20
.3a4939	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a493c					FN_LEN
.3a493c	e2 20		sep #$20	            SEP #$20
.3a493e	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4940	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4943	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4946	e2 20		sep #$20	            SEP #$20
.3a4948	a5 27		lda $0827	                LDA ARGTYPE1
.3a494a	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a494c	d0 1f		bne $3a496d	                BNE type_mismatch
.3a494e	8b		phb		                PHB                 ; Set the data bank to the data bank of the string
.3a494f	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4951	48		pha		                PHA
.3a4952	ab		plb		                PLB
.3a4953	c2 10		rep #$10	            REP #$10
.3a4955	a6 23		ldx $0823	                LDX ARGUMENT1       ; And point X to the string data
.3a4957	20 9a 14	jsr $3a149a	            JSR STRLEN
.3a495a	ab		plb		                PLB                 ; Restore the old data bank
.3a495b	84 23		sty $0823	                STY ARGUMENT1       ; Save the length to ARGUMENT1
.3a495d	c2 20		rep #$20	            REP #$20
.3a495f	64 25		stz $0825	                STZ ARGUMENT1+2
.3a4961	e2 20		sep #$20	            SEP #$20
.3a4963	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the type to INTEGER
.3a4965	85 27		sta $0827	                STA ARGTYPE1
.3a4967	e2 20		sep #$20	            SEP #$20
.3a4969	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a496c	60		rts		            RTS
.3a496d					type_mismatch
.3a496d	08		php		            PHP
.3a496e	c2 20		rep #$20	            REP #$20
.3a4970	48		pha		            PHA
.3a4971	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4974	5b		tcd		            TCD
.3a4975	68		pla		            PLA
.3a4976	28		plp		            PLP
.3a4977	e2 20		sep #$20	            SEP #$20
.3a4979	a9 04		lda #$04	            LDA #ERR_TYPE
.3a497b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a497f	c2 20		rep #$20	            REP #$20
.3a4981	29 ff 00	and #$00ff	            AND #$00FF
.3a4984	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4987	e2 20		sep #$20	            SEP #$20
.3a4989	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a498c					FN_PEEK
.3a498c	e2 20		sep #$20	            SEP #$20
.3a498e	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4990	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4993	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4996	e2 20		sep #$20	            SEP #$20
.3a4998	a5 27		lda $0827	                LDA ARGTYPE1
.3a499a	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a499c	d0 12		bne $3a49b0	                BNE type_mismatch
.3a499e	e2 20		sep #$20	            SEP #$20
.3a49a0	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.3a49a2	85 23		sta $0823	                STA ARGUMENT1
.3a49a4	64 24		stz $0824	                STZ ARGUMENT1+1
.3a49a6	64 25		stz $0825	                STZ ARGUMENT1+2
.3a49a8	64 30		stz $0830	                STZ ARGUMENT1+13
.3a49aa	e2 20		sep #$20	            SEP #$20
.3a49ac	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a49af	60		rts		            RTS
.3a49b0					type_mismatch
.3a49b0	08		php		            PHP
.3a49b1	c2 20		rep #$20	            REP #$20
.3a49b3	48		pha		            PHA
.3a49b4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a49b7	5b		tcd		            TCD
.3a49b8	68		pla		            PLA
.3a49b9	28		plp		            PLP
.3a49ba	e2 20		sep #$20	            SEP #$20
.3a49bc	a9 04		lda #$04	            LDA #ERR_TYPE
.3a49be	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a49c2	c2 20		rep #$20	            REP #$20
.3a49c4	29 ff 00	and #$00ff	            AND #$00FF
.3a49c7	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a49ca	e2 20		sep #$20	            SEP #$20
.3a49cc	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a49cf					FN_PEEKL
.3a49cf	e2 20		sep #$20	            SEP #$20
.3a49d1	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a49d3	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a49d6	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a49d9	e2 20		sep #$20	            SEP #$20
.3a49db	a5 27		lda $0827	                LDA ARGTYPE1
.3a49dd	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a49df	d0 1d		bne $3a49fe	                BNE type_mismatch
.3a49e1	c2 20		rep #$20	            REP #$20
.3a49e3	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.3a49e5	85 0c		sta $080c	                STA SCRATCH
.3a49e7	e2 20		sep #$20	            SEP #$20
.3a49e9	a0 02 00	ldy #$0002	                LDY #2
.3a49ec	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y
.3a49ee	85 25		sta $0825	                STA ARGUMENT1+2
.3a49f0	64 26		stz $0826	                STZ ARGUMENT1+3
.3a49f2	c2 20		rep #$20	            REP #$20
.3a49f4	a5 0c		lda $080c	                LDA SCRATCH
.3a49f6	85 23		sta $0823	                STA ARGUMENT1
.3a49f8	e2 20		sep #$20	            SEP #$20
.3a49fa	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a49fd	60		rts		            RTS
.3a49fe					type_mismatch
.3a49fe	08		php		            PHP
.3a49ff	c2 20		rep #$20	            REP #$20
.3a4a01	48		pha		            PHA
.3a4a02	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4a05	5b		tcd		            TCD
.3a4a06	68		pla		            PLA
.3a4a07	28		plp		            PLP
.3a4a08	e2 20		sep #$20	            SEP #$20
.3a4a0a	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4a0c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4a10	c2 20		rep #$20	            REP #$20
.3a4a12	29 ff 00	and #$00ff	            AND #$00FF
.3a4a15	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4a18	e2 20		sep #$20	            SEP #$20
.3a4a1a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4a1d					FN_PEEKW
.3a4a1d	e2 20		sep #$20	            SEP #$20
.3a4a1f	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4a21	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4a24	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4a27	e2 20		sep #$20	            SEP #$20
.3a4a29	a5 27		lda $0827	                LDA ARGTYPE1
.3a4a2b	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4a2d	d0 0e		bne $3a4a3d	                BNE type_mismatch
.3a4a2f	c2 20		rep #$20	            REP #$20
.3a4a31	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.3a4a33	85 23		sta $0823	                STA ARGUMENT1
.3a4a35	64 25		stz $0825	                STZ ARGUMENT1+2
.3a4a37	e2 20		sep #$20	            SEP #$20
.3a4a39	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4a3c	60		rts		            RTS
.3a4a3d					type_mismatch
.3a4a3d	08		php		            PHP
.3a4a3e	c2 20		rep #$20	            REP #$20
.3a4a40	48		pha		            PHA
.3a4a41	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4a44	5b		tcd		            TCD
.3a4a45	68		pla		            PLA
.3a4a46	28		plp		            PLP
.3a4a47	e2 20		sep #$20	            SEP #$20
.3a4a49	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4a4b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4a4f	c2 20		rep #$20	            REP #$20
.3a4a51	29 ff 00	and #$00ff	            AND #$00FF
.3a4a54	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4a57	e2 20		sep #$20	            SEP #$20
.3a4a59	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4a5c					FN_CHR
.3a4a5c	e2 20		sep #$20	            SEP #$20
.3a4a5e	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4a60	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4a63	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4a66	e2 20		sep #$20	            SEP #$20
.3a4a68	a5 27		lda $0827	                LDA ARGTYPE1
.3a4a6a	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4a6c	d0 24		bne $3a4a92	                BNE type_mismatch
.3a4a6e	20 ae 13	jsr $3a13ae	            JSR TEMPSTRING
.3a4a71	a5 23		lda $0823	                LDA ARGUMENT1       ; Get the numberic value
.3a4a73	87 16		sta [$0816]	                STA [STRPTR]        ; And save it as the first character
.3a4a75	a9 00		lda #$00	                LDA #0              ; Null terminate the string
.3a4a77	a0 01 00	ldy #$0001	                LDY #1
.3a4a7a	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a4a7c	c2 20		rep #$20	            REP #$20
.3a4a7e	a5 16		lda $0816	                LDA STRPTR
.3a4a80	85 23		sta $0823	                STA ARGUMENT1
.3a4a82	a5 18		lda $0818	                LDA STRPTR+2
.3a4a84	85 25		sta $0825	                STA ARGUMENT1+2
.3a4a86	e2 20		sep #$20	            SEP #$20
.3a4a88	a9 02		lda #$02	                LDA #TYPE_STRING
.3a4a8a	85 27		sta $0827	                STA ARGTYPE1
.3a4a8c	e2 20		sep #$20	            SEP #$20
.3a4a8e	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4a91	60		rts		            RTS
.3a4a92					type_mismatch
.3a4a92	08		php		            PHP
.3a4a93	c2 20		rep #$20	            REP #$20
.3a4a95	48		pha		            PHA
.3a4a96	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4a99	5b		tcd		            TCD
.3a4a9a	68		pla		            PLA
.3a4a9b	28		plp		            PLP
.3a4a9c	e2 20		sep #$20	            SEP #$20
.3a4a9e	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4aa0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4aa4	c2 20		rep #$20	            REP #$20
.3a4aa6	29 ff 00	and #$00ff	            AND #$00FF
.3a4aa9	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4aac	e2 20		sep #$20	            SEP #$20
.3a4aae	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4ab1					FN_ASC
.3a4ab1	e2 20		sep #$20	            SEP #$20
.3a4ab3	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4ab5	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4ab8	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4abb	e2 20		sep #$20	            SEP #$20
.3a4abd	a5 27		lda $0827	                LDA ARGTYPE1
.3a4abf	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a4ac1	d0 14		bne $3a4ad7	                BNE type_mismatch
.3a4ac3	a7 23		lda [$0823]	                LDA [ARGUMENT1]     ; Get the character
.3a4ac5	85 23		sta $0823	                STA ARGUMENT1       ; Save its code to ARGUMENT1
.3a4ac7	64 24		stz $0824	                STZ ARGUMENT1+1
.3a4ac9	64 25		stz $0825	                STZ ARGUMENT1+2
.3a4acb	64 26		stz $0826	                STZ ARGUMENT1+3
.3a4acd	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the return type to integer
.3a4acf	85 27		sta $0827	                STA ARGTYPE1
.3a4ad1	e2 20		sep #$20	            SEP #$20
.3a4ad3	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4ad6	60		rts		            RTS
.3a4ad7					type_mismatch
.3a4ad7	08		php		            PHP
.3a4ad8	c2 20		rep #$20	            REP #$20
.3a4ada	48		pha		            PHA
.3a4adb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4ade	5b		tcd		            TCD
.3a4adf	68		pla		            PLA
.3a4ae0	28		plp		            PLP
.3a4ae1	e2 20		sep #$20	            SEP #$20
.3a4ae3	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4ae5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4ae9	c2 20		rep #$20	            REP #$20
.3a4aeb	29 ff 00	and #$00ff	            AND #$00FF
.3a4aee	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4af1	e2 20		sep #$20	            SEP #$20
.3a4af3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4af6					FN_SPC
.3a4af6	e2 20		sep #$20	            SEP #$20
.3a4af8	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4afa	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4afd	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4b00	e2 20		sep #$20	            SEP #$20
.3a4b02	a5 27		lda $0827	                LDA ARGTYPE1
.3a4b04	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4b06	d0 39		bne $3a4b41	                BNE type_mismatch
.3a4b08	e2 20		sep #$20	            SEP #$20
.3a4b0a	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.3a4b0c	d0 52		bne $3a4b60	                BNE err_limit
.3a4b0e	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4b10	d0 4e		bne $3a4b60	                BNE err_limit
.3a4b12	a5 24		lda $0824	                LDA ARGUMENT1+1
.3a4b14	d0 4a		bne $3a4b60	                BNE err_limit
.3a4b16	c2 10		rep #$10	            REP #$10
.3a4b18	20 ae 13	jsr $3a13ae	            JSR TEMPSTRING
.3a4b1b	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.3a4b1d	e2 20		sep #$20	            SEP #$20
.3a4b1f	a9 00		lda #$00	                LDA #0
.3a4b21	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.3a4b23	88		dey		                DEY
.3a4b24	30 07		bmi $3a4b2d	                BMI done
.3a4b26	a9 20		lda #$20	                LDA #CHAR_SP
.3a4b28	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.3a4b2a	88		dey		                DEY
.3a4b2b	10 fb		bpl $3a4b28	                BPL loop            ; And keep writing until we're done
.3a4b2d	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.3a4b2f	85 27		sta $0827	                STA ARGTYPE1
.3a4b31	c2 20		rep #$20	            REP #$20
.3a4b33	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.3a4b35	85 23		sta $0823	                STA ARGUMENT1
.3a4b37	a5 18		lda $0818	                LDA STRPTR+2
.3a4b39	85 25		sta $0825	                STA ARGUMENT1+2
.3a4b3b	e2 20		sep #$20	            SEP #$20
.3a4b3d	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4b40	60		rts		            RTS
.3a4b41					type_mismatch
.3a4b41	08		php		            PHP
.3a4b42	c2 20		rep #$20	            REP #$20
.3a4b44	48		pha		            PHA
.3a4b45	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4b48	5b		tcd		            TCD
.3a4b49	68		pla		            PLA
.3a4b4a	28		plp		            PLP
.3a4b4b	e2 20		sep #$20	            SEP #$20
.3a4b4d	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4b4f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4b53	c2 20		rep #$20	            REP #$20
.3a4b55	29 ff 00	and #$00ff	            AND #$00FF
.3a4b58	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4b5b	e2 20		sep #$20	            SEP #$20
.3a4b5d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4b60					err_limit
.3a4b60	08		php		            PHP
.3a4b61	c2 20		rep #$20	            REP #$20
.3a4b63	48		pha		            PHA
.3a4b64	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4b67	5b		tcd		            TCD
.3a4b68	68		pla		            PLA
.3a4b69	28		plp		            PLP
.3a4b6a	e2 20		sep #$20	            SEP #$20
.3a4b6c	a9 09		lda #$09	            LDA #ERR_RANGE
.3a4b6e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4b72	c2 20		rep #$20	            REP #$20
.3a4b74	29 ff 00	and #$00ff	            AND #$00FF
.3a4b77	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4b7a	e2 20		sep #$20	            SEP #$20
.3a4b7c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4b7f					FN_TAB
.3a4b7f	e2 20		sep #$20	            SEP #$20
.3a4b81	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4b83	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4b86	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4b89	e2 20		sep #$20	            SEP #$20
.3a4b8b	a5 27		lda $0827	                LDA ARGTYPE1
.3a4b8d	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4b8f	d0 39		bne $3a4bca	                BNE type_mismatch
.3a4b91	e2 20		sep #$20	            SEP #$20
.3a4b93	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.3a4b95	d0 52		bne $3a4be9	                BNE err_limit
.3a4b97	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4b99	d0 4e		bne $3a4be9	                BNE err_limit
.3a4b9b	a5 24		lda $0824	                LDA ARGUMENT1+1
.3a4b9d	d0 4a		bne $3a4be9	                BNE err_limit
.3a4b9f	c2 10		rep #$10	            REP #$10
.3a4ba1	20 ae 13	jsr $3a13ae	            JSR TEMPSTRING
.3a4ba4	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.3a4ba6	e2 20		sep #$20	            SEP #$20
.3a4ba8	a9 00		lda #$00	                LDA #0
.3a4baa	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.3a4bac	88		dey		                DEY
.3a4bad	30 07		bmi $3a4bb6	                BMI done
.3a4baf	a9 09		lda #$09	                LDA #CHAR_TAB
.3a4bb1	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.3a4bb3	88		dey		                DEY
.3a4bb4	10 fb		bpl $3a4bb1	                BPL loop            ; And keep writing until we're done
.3a4bb6	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.3a4bb8	85 27		sta $0827	                STA ARGTYPE1
.3a4bba	c2 20		rep #$20	            REP #$20
.3a4bbc	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.3a4bbe	85 23		sta $0823	                STA ARGUMENT1
.3a4bc0	a5 18		lda $0818	                LDA STRPTR+2
.3a4bc2	85 25		sta $0825	                STA ARGUMENT1+2
.3a4bc4	e2 20		sep #$20	            SEP #$20
.3a4bc6	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4bc9	60		rts		            RTS
.3a4bca					type_mismatch
.3a4bca	08		php		            PHP
.3a4bcb	c2 20		rep #$20	            REP #$20
.3a4bcd	48		pha		            PHA
.3a4bce	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4bd1	5b		tcd		            TCD
.3a4bd2	68		pla		            PLA
.3a4bd3	28		plp		            PLP
.3a4bd4	e2 20		sep #$20	            SEP #$20
.3a4bd6	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4bd8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4bdc	c2 20		rep #$20	            REP #$20
.3a4bde	29 ff 00	and #$00ff	            AND #$00FF
.3a4be1	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4be4	e2 20		sep #$20	            SEP #$20
.3a4be6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4be9					err_limit
.3a4be9	08		php		            PHP
.3a4bea	c2 20		rep #$20	            REP #$20
.3a4bec	48		pha		            PHA
.3a4bed	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4bf0	5b		tcd		            TCD
.3a4bf1	68		pla		            PLA
.3a4bf2	28		plp		            PLP
.3a4bf3	e2 20		sep #$20	            SEP #$20
.3a4bf5	a9 09		lda #$09	            LDA #ERR_RANGE
.3a4bf7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4bfb	c2 20		rep #$20	            REP #$20
.3a4bfd	29 ff 00	and #$00ff	            AND #$00FF
.3a4c00	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4c03	e2 20		sep #$20	            SEP #$20
.3a4c05	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4c08					FN_ABS
.3a4c08	e2 20		sep #$20	            SEP #$20
.3a4c0a	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4c0c	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4c0f	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4c12	e2 20		sep #$20	            SEP #$20
.3a4c14	a5 27		lda $0827	                LDA ARGTYPE1        ; Check the type
.3a4c16	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4c18	f0 23		beq $3a4c3d	                BEQ abs_int         ; If integer, get the absolute value of the integer
.3a4c1a	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.3a4c1c	f0 3e		beq $3a4c5c	                BEQ abs_float       ; If float, get the absolute value of the float
.3a4c1e					type_err
.3a4c1e	08		php		            PHP
.3a4c1f	c2 20		rep #$20	            REP #$20
.3a4c21	48		pha		            PHA
.3a4c22	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4c25	5b		tcd		            TCD
.3a4c26	68		pla		            PLA
.3a4c27	28		plp		            PLP
.3a4c28	e2 20		sep #$20	            SEP #$20
.3a4c2a	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4c2c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4c30	c2 20		rep #$20	            REP #$20
.3a4c32	29 ff 00	and #$00ff	            AND #$00FF
.3a4c35	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4c38	e2 20		sep #$20	            SEP #$20
.3a4c3a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4c3d					abs_int
.3a4c3d	c2 20		rep #$20	            REP #$20
.3a4c3f	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Is it positive already?
.3a4c41	10 21		bpl $3a4c64	                BPL done            ; Yes: we don't need to do anythign further
.3a4c43	49 ff ff	eor #$ffff	                EOR #$FFFF          ; Otherwise, take the two's compliment
.3a4c46	85 25		sta $0825	                STA ARGUMENT1+2     ; Of ARGUMENT1
.3a4c48	a5 23		lda $0823	                LDA ARGUMENT1
.3a4c4a	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a4c4d	18		clc		                CLC
.3a4c4e	69 01 00	adc #$0001	                ADC #1
.3a4c51	85 23		sta $0823	                STA ARGUMENT1       ; And save it back to ARGUMENT1
.3a4c53	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4c55	69 00 00	adc #$0000	                ADC #0
.3a4c58	85 25		sta $0825	                STA ARGUMENT1+2
.3a4c5a	80 08		bra $3a4c64	                BRA done
.3a4c5c					abs_float
.3a4c5c	e2 20		sep #$20	            SEP #$20
.3a4c5e	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Just clear the sign bit
.3a4c60	29 7f		and #$7f	                AND #$7F
.3a4c62	85 26		sta $0826	                STA ARGUMENT1+3
.3a4c64					done
.3a4c64	e2 20		sep #$20	            SEP #$20
.3a4c66	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4c69	60		rts		            RTS
.3a4c6a					FN_SGN
.3a4c6a	e2 20		sep #$20	            SEP #$20
.3a4c6c	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4c6e	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4c71	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4c74	e2 20		sep #$20	            SEP #$20
.3a4c76	a5 27		lda $0827	                LDA ARGTYPE1
.3a4c78	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4c7a	d0 25		bne $3a4ca1	                BNE type_mismatch
.3a4c7c	c2 20		rep #$20	            REP #$20
.3a4c7e	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4c80	30 12		bmi $3a4c94	                BMI is_negative     ; Negative: return -1
.3a4c82	d0 04		bne $3a4c88	                BNE is_positive     ; Is it not 0? Then return 1
.3a4c84	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the lower word 0?
.3a4c86	f0 13		beq $3a4c9b	                BEQ done            ; Yes: the whole thing is zero: return 0
.3a4c88	a9 00 00	lda #$0000	is_positive     LDA #0              ; It's positive: return 1
.3a4c8b	85 25		sta $0825	                STA ARGUMENT1+2
.3a4c8d	a9 01 00	lda #$0001	                LDA #1
.3a4c90	85 23		sta $0823	                STA ARGUMENT1
.3a4c92	80 07		bra $3a4c9b	                BRA done
.3a4c94	a9 ff ff	lda #$ffff	is_negative     LDA #$FFFF          ; It's negative: return -1
.3a4c97	85 25		sta $0825	                STA ARGUMENT1+2
.3a4c99	85 23		sta $0823	                STA ARGUMENT1
.3a4c9b					done
.3a4c9b	e2 20		sep #$20	            SEP #$20
.3a4c9d	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4ca0	60		rts		            RTS
.3a4ca1					type_mismatch
.3a4ca1	08		php		            PHP
.3a4ca2	c2 20		rep #$20	            REP #$20
.3a4ca4	48		pha		            PHA
.3a4ca5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4ca8	5b		tcd		            TCD
.3a4ca9	68		pla		            PLA
.3a4caa	28		plp		            PLP
.3a4cab	e2 20		sep #$20	            SEP #$20
.3a4cad	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4caf	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4cb3	c2 20		rep #$20	            REP #$20
.3a4cb5	29 ff 00	and #$00ff	            AND #$00FF
.3a4cb8	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4cbb	e2 20		sep #$20	            SEP #$20
.3a4cbd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4cc0					FN_INT
.3a4cc0	e2 20		sep #$20	            SEP #$20
.3a4cc2	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4cc4	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4cc7	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4cca	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a4ccd					done
.3a4ccd	e2 20		sep #$20	            SEP #$20
.3a4ccf	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4cd2	60		rts		            RTS
.3a4cd3					FN_SIN
.3a4cd3	e2 20		sep #$20	            SEP #$20
.3a4cd5	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4cd7	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4cda	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4cdd	20 71 06	jsr $3a0671	            JSR ASS_ARG1_FLOAT
.3a4ce0	20 91 5f	jsr $3a5f91	            JSR FP_SIN
.3a4ce3					done
.3a4ce3	e2 20		sep #$20	            SEP #$20
.3a4ce5	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4ce8	60		rts		            RTS
.3a4ce9					FN_COS
.3a4ce9	e2 20		sep #$20	            SEP #$20
.3a4ceb	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4ced	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4cf0	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4cf3	20 71 06	jsr $3a0671	            JSR ASS_ARG1_FLOAT
.3a4cf6	20 c0 5f	jsr $3a5fc0	            JSR FP_COS
.3a4cf9					done
.3a4cf9	e2 20		sep #$20	            SEP #$20
.3a4cfb	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4cfe	60		rts		            RTS
.3a4cff					FN_TAN
.3a4cff	e2 20		sep #$20	            SEP #$20
.3a4d01	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4d03	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4d06	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4d09	20 71 06	jsr $3a0671	            JSR ASS_ARG1_FLOAT
.3a4d0c	20 ef 5f	jsr $3a5fef	            JSR FP_TAN
.3a4d0f					done
.3a4d0f	e2 20		sep #$20	            SEP #$20
.3a4d11	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4d14	60		rts		            RTS
.3a4d15					FN_LN
.3a4d15	e2 20		sep #$20	            SEP #$20
.3a4d17	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4d19	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4d1c	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4d1f	20 71 06	jsr $3a0671	            JSR ASS_ARG1_FLOAT
.3a4d22	20 1d 60	jsr $3a601d	            JSR FP_LN
.3a4d25					done
.3a4d25	e2 20		sep #$20	            SEP #$20
.3a4d27	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4d2a	60		rts		            RTS
.3a4d2b					FN_ACOS
.3a4d2b	e2 20		sep #$20	            SEP #$20
.3a4d2d	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4d2f	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4d32	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4d35	20 71 06	jsr $3a0671	            JSR ASS_ARG1_FLOAT
.3a4d38	20 46 61	jsr $3a6146	            JSR FP_ACOS
.3a4d3b					done
.3a4d3b	e2 20		sep #$20	            SEP #$20
.3a4d3d	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4d40	60		rts		            RTS
.3a4d41					FN_ASIN
.3a4d41	e2 20		sep #$20	            SEP #$20
.3a4d43	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4d45	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4d48	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4d4b	20 71 06	jsr $3a0671	            JSR ASS_ARG1_FLOAT
.3a4d4e	20 1c 61	jsr $3a611c	            JSR FP_ASIN
.3a4d51					done
.3a4d51	e2 20		sep #$20	            SEP #$20
.3a4d53	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4d56	60		rts		            RTS
.3a4d57					FN_ATAN
.3a4d57	e2 20		sep #$20	            SEP #$20
.3a4d59	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4d5b	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4d5e	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4d61	20 71 06	jsr $3a0671	            JSR ASS_ARG1_FLOAT
.3a4d64	20 68 61	jsr $3a6168	            JSR FP_ATAN
.3a4d67					done
.3a4d67	e2 20		sep #$20	            SEP #$20
.3a4d69	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4d6c	60		rts		            RTS
.3a4d6d					FN_EXP
.3a4d6d	e2 20		sep #$20	            SEP #$20
.3a4d6f	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4d71	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4d74	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4d77	20 71 06	jsr $3a0671	            JSR ASS_ARG1_FLOAT
.3a4d7a	20 fc 61	jsr $3a61fc	            JSR FP_EXP
.3a4d7d					done
.3a4d7d	e2 20		sep #$20	            SEP #$20
.3a4d7f	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4d82	60		rts		            RTS
.3a4d83					FN_SQR
.3a4d83	e2 20		sep #$20	            SEP #$20
.3a4d85	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4d87	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4d8a	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a4d8d	20 71 06	jsr $3a0671	            JSR ASS_ARG1_FLOAT
.3a4d90	20 7e 62	jsr $3a627e	            JSR FP_SQR
.3a4d93					done
.3a4d93	e2 20		sep #$20	            SEP #$20
.3a4d95	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a4d98	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\commands.s

.3a4d99	00		brk #		CMD_MONITOR     BRK
.3a4d9a	ea		nop		                NOP
.3a4d9b	60		rts		            RTS
.3a4d9c					CMD_NEW
.3a4d9c	08		php		                PHP
.3a4d9d	0b		phd		                PHD
.3a4d9e	08		php		            PHP
.3a4d9f	c2 20		rep #$20	            REP #$20
.3a4da1	48		pha		            PHA
.3a4da2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a4da5	5b		tcd		            TCD
.3a4da6	68		pla		            PLA
.3a4da7	28		plp		            PLP
.3a4da8	c2 30		rep #$30	            REP #$30
.3a4daa	c2 20		rep #$20	            REP #$20
.3a4dac	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.3a4daf	85 d9		sta $08d9	            STA LASTLINE
.3a4db1	e2 20		sep #$20	            SEP #$20
.3a4db3	a9 36		lda #$36	            LDA #`BASIC_BOT
.3a4db5	85 db		sta $08db	            STA LASTLINE+2
.3a4db7	c2 30		rep #$30	            REP #$30
.3a4db9	a9 00 00	lda #$0000	                LDA #0
.3a4dbc	a0 00 00	ldy #$0000	                LDY #LINE_LINK
.3a4dbf	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.3a4dc1	a0 02 00	ldy #$0002	                LDY #LINE_NUMBER
.3a4dc4	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.3a4dc6	a0 04 00	ldy #$0004	                LDY #LINE_TOKENS
.3a4dc9	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.3a4dcb	20 34 1f	jsr $3a1f34	            JSR CLRINTERP
.3a4dce	2b		pld		                PLD
.3a4dcf	28		plp		                PLP
.3a4dd0	60		rts		            RTS
.3a4dd1					CMD_RUN
.3a4dd1	8b		phb		                PHB
.3a4dd2	08		php		                PHP
.3a4dd3	c2 20		rep #$20	            REP #$20
.3a4dd5	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT            ; Point to the first line of the program
.3a4dd8	85 1a		sta $081a	                STA CURLINE
.3a4dda	a9 36 00	lda #$0036	                LDA #`BASIC_BOT
.3a4ddd	85 1c		sta $081c	                STA CURLINE + 2
.3a4ddf	20 34 1f	jsr $3a1f34	            JSR CLRINTERP
.3a4de2	20 13 22	jsr $3a2213	            JSR EXECPROGRAM
.3a4de5	28		plp		                PLP
.3a4de6	ab		plb		                PLB
.3a4de7	60		rts		            RTS
.3a4de8					CMD_LIST
.3a4de8	08		php		                PHP
.3a4de9	c2 20		rep #$20	            REP #$20
.3a4deb	64 55		stz $0855	                STZ MARG1               ; MARG1 is starting line number, default 0
.3a4ded	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.3a4df0	85 59		sta $0859	                STA MARG2               ; MARG2 is ending line number, default MAXINT
.3a4df2	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a4df5	20 bf 20	jsr $3a20bf	            JSR PEEK_TOK
.3a4df8	29 ff 00	and #$00ff	                AND #$00FF
.3a4dfb	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.3a4dfe	f0 2c		beq $3a4e2c	                BEQ call_list           ; ... just list with the defaults
.3a4e00	c9 81 00	cmp #$0081	                CMP #TOK_MINUS          ; If just "- ###"...
.3a4e03	f0 1a		beq $3a4e1f	                BEQ parse_endline       ; ... try to parse the end line number
.3a4e05	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a4e08	20 8a 07	jsr $3a078a	            JSR PARSEINT
.3a4e0b	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG1
.3a4e0d	85 55		sta $0855	                STA MARG1
.3a4e0f	20 bf 20	jsr $3a20bf	            JSR PEEK_TOK
.3a4e12	29 ff 00	and #$00ff	                AND #$00FF
.3a4e15	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.3a4e18	f0 12		beq $3a4e2c	                BEQ call_list           ; ... just list with the defaults
.3a4e1a	c9 81 00	cmp #$0081	                CMP #TOK_MINUS
.3a4e1d	d0 2a		bne $3a4e49	                BNE error               ; At this point, if not '-', it's a syntax error
.3a4e1f					parse_endline
.3a4e1f	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a4e22	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a4e25	20 8a 07	jsr $3a078a	            JSR PARSEINT
.3a4e28	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG2
.3a4e2a	85 59		sta $0859	                STA MARG2
.3a4e2c	a5 1c		lda $081c	call_list       LDA CURLINE+2           ; Save CURLINE
.3a4e2e	48		pha		                PHA
.3a4e2f	a5 1a		lda $081a	                LDA CURLINE
.3a4e31	48		pha		                PHA
.3a4e32	a5 02		lda $0802	                LDA BIP+2               ; Save BIP
.3a4e34	48		pha		                PHA
.3a4e35	a5 00		lda $0800	                LDA BIP
.3a4e37	48		pha		                PHA
.3a4e38	20 10 17	jsr $3a1710	            JSR LISTPROG
.3a4e3b	68		pla		                PLA
.3a4e3c	85 00		sta $0800	                STA BIP
.3a4e3e	68		pla		                PLA
.3a4e3f	85 02		sta $0802	                STA BIP+2
.3a4e41	68		pla		                PLA
.3a4e42	85 1a		sta $081a	                STA CURLINE
.3a4e44	68		pla		                PLA
.3a4e45	85 1c		sta $081c	                STA CURLINE+2
.3a4e47	28		plp		                PLP
.3a4e48	60		rts		            RTS
.3a4e49					error
.3a4e49	08		php		            PHP
.3a4e4a	c2 20		rep #$20	            REP #$20
.3a4e4c	48		pha		            PHA
.3a4e4d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4e50	5b		tcd		            TCD
.3a4e51	68		pla		            PLA
.3a4e52	28		plp		            PLP
.3a4e53	e2 20		sep #$20	            SEP #$20
.3a4e55	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4e57	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4e5b	c2 20		rep #$20	            REP #$20
.3a4e5d	29 ff 00	and #$00ff	            AND #$00FF
.3a4e60	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4e63	e2 20		sep #$20	            SEP #$20
.3a4e65	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]

;******  Return to file: src\basic816.s


;******  Processing file: src\variables.s

>08e1					NEXTVAR         .long ?         ; Pointer to the the next available byte for variable bindings
>08e4					VARIABLES       .long ?         ; Pointer to the most recently allocated variable
>08e7					TOFIND          .long ?         ; Pointer to the variable name to find
>08ea					TOFINDTYPE      .byte ?         ; The type to find
.0000					BINDING
>0000					TYPE            .fill 1                 ; The type of the data stored in the variable
>0001					NAME            .fill VAR_NAME_SIZE     ; The name of the variable
>0009					VALUE           .fill 4                 ; The data stored in the variable
>000d					NEXT            .fill 3                 ; The pointer to the next allocated variable of this type
.3a4e68					INITVARS
.3a4e68	08		php		                PHP
.3a4e69	08		php		            PHP
.3a4e6a	c2 20		rep #$20	            REP #$20
.3a4e6c	48		pha		            PHA
.3a4e6d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4e70	5b		tcd		            TCD
.3a4e71	68		pla		            PLA
.3a4e72	28		plp		            PLP
.3a4e73	c2 20		rep #$20	            REP #$20
.3a4e75	64 e4		stz $08e4	                STZ VARIABLES           ; Clear the pointer to the variables
.3a4e77	64 e7		stz $08e7	                STZ TOFIND
.3a4e79	e2 20		sep #$20	            SEP #$20
.3a4e7b	64 e6		stz $08e6	                STZ VARIABLES+2
.3a4e7d	64 e9		stz $08e9	                STZ TOFIND+2
.3a4e7f	64 ea		stz $08ea	                STZ TOFINDTYPE
.3a4e81	c2 20		rep #$20	            REP #$20
.3a4e83	38		sec		                SEC                     ; Compute the position of the first variable
.3a4e84	a5 d9		lda $08d9	                LDA LASTLINE
.3a4e86	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.3a4e89	85 e1		sta $08e1	                STA NEXTVAR
.3a4e8b	e2 20		sep #$20	            SEP #$20
.3a4e8d	a5 db		lda $08db	                LDA LASTLINE+2
.3a4e8f	69 00		adc #$00	                ADC #0
.3a4e91	85 e3		sta $08e3	                STA NEXTVAR+2
.3a4e93	28		plp		                PLP
.3a4e94	60		rts		            RTS
.3a4e95					ISVARCHAR
.3a4e95	c9 5f		cmp #$5f	                CMP #'_'            ; Check if it's an underscore
.3a4e97	f0 1a		beq $3a4eb3	                BEQ return_true     ; Yes: return true
.3a4e99	c9 3a		cmp #$3a	                CMP #'9'+1          ; Check if its in [0-9]
.3a4e9b	b0 04		bcs $3a4ea1	                BGE else1           ; No: check something else
.3a4e9d	c9 30		cmp #$30	                CMP #'0'
.3a4e9f	b0 12		bcs $3a4eb3	                BGE return_true     ; Yes: return true
.3a4ea1	c9 5b		cmp #$5b	else1           CMP #'Z'+1          ; Check if its in [A-Z]
.3a4ea3	b0 04		bcs $3a4ea9	                BGE not_upper       ; No: check lower case
.3a4ea5	c9 41		cmp #$41	                CMP #'A'
.3a4ea7	b0 0a		bcs $3a4eb3	                BGE return_true     ; Yes: return true
.3a4ea9	c9 7b		cmp #$7b	not_upper       CMP #'z'+1          ; Check if its in [a-z]
.3a4eab	b0 04		bcs $3a4eb1	                BGE return_false    ; No: return false
.3a4ead	c9 61		cmp #$61	                CMP #'a'
.3a4eaf	b0 02		bcs $3a4eb3	                BGE return_true     ; Yes: return true
.3a4eb1	18		clc		return_false    CLC
.3a4eb2	60		rts		            RTS
.3a4eb3	38		sec		return_true     SEC
.3a4eb4	60		rts		            RTS
.3a4eb5					VARNAMECMP
.3a4eb5	08		php		                PHP
.3a4eb6	e2 20		sep #$20	            SEP #$20
.3a4eb8	c2 10		rep #$10	            REP #$10
.3a4eba	a0 00 00	ldy #$0000	                LDY #0
.3a4ebd	b7 0c		lda [$080c],y	cmp_loop        LDA [SCRATCH],Y         ; Check the character in the variable name
.3a4ebf	f0 0a		beq $3a4ecb	                BEQ is_end
.3a4ec1	d7 e7		cmp [$08e7],y	                CMP [TOFIND],Y          ; Compare the character to the one TOFIND
.3a4ec3	d0 13		bne $3a4ed8	                BNE return_false        ; Not equal? Then this is not a match
.3a4ec5	c8		iny		                INY
.3a4ec6	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.3a4ec9	d0 f2		bne $3a4ebd	                BNE cmp_loop
.3a4ecb	b7 e7		lda [$08e7],y	is_end          LDA [TOFIND],Y          ; Check the character in the name to find
.3a4ecd	20 08 04	jsr $3a0408	            JSR TOUPPERA
.3a4ed0	20 95 4e	jsr $3a4e95	            JSR ISVARCHAR
.3a4ed3	b0 03		bcs $3a4ed8	                BCS return_false        ; YES: we do not have a match
.3a4ed5					return_true
.3a4ed5	28		plp		                PLP
.3a4ed6	38		sec		                SEC
.3a4ed7	60		rts		            RTS
.3a4ed8					return_false
.3a4ed8	28		plp		                PLP
.3a4ed9	18		clc		                CLC
.3a4eda	60		rts		            RTS
.3a4edb					VAR_FIND
.3a4edb	08		php		                PHP
.3a4edc	e2 20		sep #$20	            SEP #$20
.3a4ede	c2 10		rep #$10	            REP #$10
.3a4ee0	a0 00 00	ldy #$0000	                LDY #0
.3a4ee3	a2 00 00	ldx #$0000	                LDX #0
.3a4ee6	b7 e7		lda [$08e7],y	upper_loop      LDA [TOFIND],Y          ; Get a character
.3a4ee8	f0 0b		beq $3a4ef5	                BEQ done_upper
.3a4eea	20 08 04	jsr $3a0408	            JSR TOUPPERA
.3a4eed	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; And save it to the temp
.3a4ef1	c8		iny		                INY
.3a4ef2	e8		inx		                INX
.3a4ef3	80 f1		bra $3a4ee6	                BRA upper_loop          ; Go back for another
.3a4ef5	a9 00		lda #$00	done_upper      LDA #0
.3a4ef7	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; NULL terminate the temporary string
.3a4efb	c2 20		rep #$20	            REP #$20
.3a4efd	a9 00 4e	lda #$4e00	                LDA #<>TEMPBUF          ; Make the temporary string the string
.3a4f00	85 e7		sta $08e7	                STA TOFIND              ; the variable name to find
.3a4f02	e2 20		sep #$20	            SEP #$20
.3a4f04	a9 00		lda #$00	                LDA #`TEMPBUF
.3a4f06	85 e9		sta $08e9	                STA TOFIND+2
.3a4f08	c2 20		rep #$20	            REP #$20
.3a4f0a	a5 e4		lda $08e4	                LDA VARIABLES           ; Point INDEX to the first variable to check
.3a4f0c	85 08		sta $0808	                STA INDEX
.3a4f0e	d0 06		bne $3a4f16	                BNE set_index_h         ; If the low word is not 0, copy the high byte
.3a4f10	e2 20		sep #$20	            SEP #$20
.3a4f12	a5 e6		lda $08e6	                LDA VARIABLES+2
.3a4f14	f0 4d		beq $3a4f63	                BEQ not_found           ; If it is, we have no variables yet.
.3a4f16					set_index_h
.3a4f16	e2 20		sep #$20	            SEP #$20
.3a4f18	a5 e6		lda $08e6	                LDA VARIABLES+2
.3a4f1a	85 0a		sta $080a	                STA INDEX+2
.3a4f1c	a5 ea		lda $08ea	check_binding   LDA TOFINDTYPE
.3a4f1e	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Get the type of the variable
.3a4f21	d7 08		cmp [$0808],y	                CMP [INDEX],Y
.3a4f23	d0 17		bne $3a4f3c	                BNE check_next          ; If it's not a match, check the next binding
.3a4f25	c2 20		rep #$20	            REP #$20
.3a4f27	18		clc		                CLC
.3a4f28	a5 08		lda $0808	                LDA INDEX
.3a4f2a	69 01 00	adc #$0001	                ADC #BINDING.NAME
.3a4f2d	85 0c		sta $080c	                STA SCRATCH
.3a4f2f	e2 20		sep #$20	            SEP #$20
.3a4f31	a5 0a		lda $080a	                LDA INDEX+2
.3a4f33	69 00		adc #$00	                ADC #0
.3a4f35	85 0e		sta $080e	                STA SCRATCH+2
.3a4f37	20 b5 4e	jsr $3a4eb5	            JSR VARNAMECMP
.3a4f3a	b0 2a		bcs $3a4f66	                BCS found               ; If they match, return that we've found the variable
.3a4f3c	a0 0d 00	ldy #$000d	check_next      LDY #BINDING.NEXT       ; SCRATCH := [INDEX].NEXT
.3a4f3f	c2 20		rep #$20	            REP #$20
.3a4f41	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a4f43	85 0c		sta $080c	                STA SCRATCH
.3a4f45	c8		iny		                INY
.3a4f46	c8		iny		                INY
.3a4f47	e2 20		sep #$20	            SEP #$20
.3a4f49	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a4f4b	85 0e		sta $080e	                STA SCRATCH+2
.3a4f4d	d0 06		bne $3a4f55	                BNE set_index           ; If SCRATCH == 0, the variable wasn't found
.3a4f4f	c2 20		rep #$20	            REP #$20
.3a4f51	a5 0c		lda $080c	                LDA SCRATCH
.3a4f53	f0 0e		beq $3a4f63	                BEQ not_found
.3a4f55					set_index
.3a4f55	c2 20		rep #$20	            REP #$20
.3a4f57	a5 0c		lda $080c	                LDA SCRATCH
.3a4f59	85 08		sta $0808	                STA INDEX
.3a4f5b	e2 20		sep #$20	            SEP #$20
.3a4f5d	a5 0e		lda $080e	                LDA SCRATCH+2
.3a4f5f	85 0a		sta $080a	                STA INDEX+2
.3a4f61	80 b9		bra $3a4f1c	                BRA check_binding       ; And check this next variable for a match
.3a4f63					not_found
.3a4f63	28		plp		                PLP
.3a4f64	18		clc		                CLC
.3a4f65	60		rts		            RTS
.3a4f66					found
.3a4f66	28		plp		                PLP
.3a4f67	38		sec		                SEC
.3a4f68	60		rts		            RTS
.3a4f69					VAR_REF
.3a4f69	08		php		                PHP
.3a4f6a	20 db 4e	jsr $3a4edb	            JSR VAR_FIND
.3a4f6d	b0 1f		bcs $3a4f8e	                BCS found
.3a4f6f	08		php		            PHP
.3a4f70	c2 20		rep #$20	            REP #$20
.3a4f72	48		pha		            PHA
.3a4f73	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4f76	5b		tcd		            TCD
.3a4f77	68		pla		            PLA
.3a4f78	28		plp		            PLP
.3a4f79	e2 20		sep #$20	            SEP #$20
.3a4f7b	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.3a4f7d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4f81	c2 20		rep #$20	            REP #$20
.3a4f83	29 ff 00	and #$00ff	            AND #$00FF
.3a4f86	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4f89	e2 20		sep #$20	            SEP #$20
.3a4f8b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4f8e					found
.3a4f8e	c2 30		rep #$30	            REP #$30
.3a4f90	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.3a4f93	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a4f95	85 23		sta $0823	                STA ARGUMENT1
.3a4f97	c8		iny		                INY
.3a4f98	c8		iny		                INY
.3a4f99	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a4f9b	85 25		sta $0825	                STA ARGUMENT1+2
.3a4f9d	e2 20		sep #$20	            SEP #$20
.3a4f9f	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE
.3a4fa2	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a4fa4	85 27		sta $0827	                STA ARGTYPE1
.3a4fa6	28		plp		done            PLP
.3a4fa7	60		rts		            RTS
.3a4fa8					VAR_ALLOC
.3a4fa8	08		php		                PHP
.3a4fa9	c2 20		rep #$20	            REP #$20
.3a4fab	18		clc		                CLC                     ; Compute extent of the binding
.3a4fac	a5 e1		lda $08e1	                LDA NEXTVAR
.3a4fae	69 10 00	adc #$0010	                ADC #size(BINDING)
.3a4fb1	85 08		sta $0808	                STA INDEX
.3a4fb3	e2 20		sep #$20	            SEP #$20
.3a4fb5	a5 e3		lda $08e3	                LDA NEXTVAR+2
.3a4fb7	69 00		adc #$00	                ADC #0
.3a4fb9	85 0a		sta $080a	                STA INDEX+2
.3a4fbb	c5 bc		cmp $08bc	                CMP HEAP+2              ; Check to see if HEAP > INDEX
.3a4fbd	90 27		bcc $3a4fe6	                BLT has_room
.3a4fbf	c2 20		rep #$20	            REP #$20
.3a4fc1	a5 08		lda $0808	                LDA INDEX
.3a4fc3	c5 ba		cmp $08ba	                CMP HEAP
.3a4fc5	90 1f		bcc $3a4fe6	                BLT has_room
.3a4fc7	08		php		            PHP
.3a4fc8	c2 20		rep #$20	            REP #$20
.3a4fca	48		pha		            PHA
.3a4fcb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4fce	5b		tcd		            TCD
.3a4fcf	68		pla		            PLA
.3a4fd0	28		plp		            PLP
.3a4fd1	e2 20		sep #$20	            SEP #$20
.3a4fd3	a9 09		lda #$09	            LDA #ERR_RANGE
.3a4fd5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4fd9	c2 20		rep #$20	            REP #$20
.3a4fdb	29 ff 00	and #$00ff	            AND #$00FF
.3a4fde	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a4fe1	e2 20		sep #$20	            SEP #$20
.3a4fe3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4fe6					has_room
.3a4fe6	c2 20		rep #$20	            REP #$20
.3a4fe8	a5 e1		lda $08e1	                LDA NEXTVAR             ; Yes: we can allocate the variable
.3a4fea	85 c0		sta $08c0	                STA CURRBLOCK           ; Point CURRBLOCK to it
.3a4fec	e2 20		sep #$20	            SEP #$20
.3a4fee	a5 e3		lda $08e3	                LDA NEXTVAR+2
.3a4ff0	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a4ff2	c2 20		rep #$20	            REP #$20
.3a4ff4	a5 08		lda $0808	                LDA INDEX               ; And point NEXTVAR to the next possible spot
.3a4ff6	85 e1		sta $08e1	                STA NEXTVAR
.3a4ff8	e2 20		sep #$20	            SEP #$20
.3a4ffa	a5 0a		lda $080a	                LDA INDEX+2
.3a4ffc	85 e3		sta $08e3	                STA NEXTVAR+2
.3a4ffe	28		plp		                PLP
.3a4fff	60		rts		            RTS
.3a5000					VAR_CREATE
.3a5000	08		php		                PHP
.3a5001	e2 20		sep #$20	            SEP #$20
.3a5003	a5 27		lda $0827	                LDA ARGTYPE1            ; Validate that our types match
.3a5005	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.3a5007	f0 33		beq $3a503c	                BEQ chk_string          ; If so: check to see if it's a string
.3a5009	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable type
.3a500b	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's INTEGER
.3a500d	d0 05		bne $3a5014	                BNE chk_float
.3a500f	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a5012	80 2f		bra $3a5043	                BRA alloc_binding       ; And bind the variable
.3a5014	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; If it's FLOAT
.3a5016	d0 05		bne $3a501d	                BNE type_error
.3a5018	20 71 06	jsr $3a0671	            JSR ASS_ARG1_FLOAT
.3a501b	80 26		bra $3a5043	                BRA alloc_binding       ; And bind the variable
.3a501d					type_error
.3a501d	08		php		            PHP
.3a501e	c2 20		rep #$20	            REP #$20
.3a5020	48		pha		            PHA
.3a5021	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a5024	5b		tcd		            TCD
.3a5025	68		pla		            PLA
.3a5026	28		plp		            PLP
.3a5027	e2 20		sep #$20	            SEP #$20
.3a5029	a9 04		lda #$04	            LDA #ERR_TYPE
.3a502b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a502f	c2 20		rep #$20	            REP #$20
.3a5031	29 ff 00	and #$00ff	            AND #$00FF
.3a5034	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a5037	e2 20		sep #$20	            SEP #$20
.3a5039	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a503c	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING        ; Is it a string?
.3a503e	d0 03		bne $3a5043	                BNE alloc_binding       ; No: just go ahead and bind it
.3a5040	20 a0 15	jsr $3a15a0	            JSR STRCPY
.3a5043					alloc_binding
.3a5043	c2 10		rep #$10	            REP #$10
.3a5045	20 a8 4f	jsr $3a4fa8	            JSR VAR_ALLOC
.3a5048	c2 30		rep #$30	            REP #$30
.3a504a	18		clc		                CLC
.3a504b	a5 c0		lda $08c0	                LDA CURRBLOCK
.3a504d	69 01 00	adc #$0001	                ADC #BINDING.NAME
.3a5050	85 08		sta $0808	                STA INDEX
.3a5052	e2 20		sep #$20	            SEP #$20
.3a5054	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.3a5056	69 00		adc #$00	                ADC #0
.3a5058	85 0a		sta $080a	                STA INDEX+2
.3a505a	a0 00 00	ldy #$0000	                LDY #0                  ; Ensure that the name field is blank
.3a505d	a9 00		lda #$00	                LDA #0
.3a505f	97 08		sta [$0808],y	blank_loop      STA [INDEX],Y
.3a5061	c8		iny		                INY
.3a5062	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.3a5065	d0 f8		bne $3a505f	                BNE blank_loop
.3a5067	a0 00 00	ldy #$0000	                LDY #0
.3a506a	b7 e7		lda [$08e7],y	name_loop       LDA [TOFIND],Y          ; Copy TOFIND to the NAME field
.3a506c	f0 10		beq $3a507e	                BEQ set_type
.3a506e	20 08 04	jsr $3a0408	            JSR TOUPPERA
.3a5071	20 95 4e	jsr $3a4e95	            JSR ISVARCHAR
.3a5074	90 08		bcc $3a507e	                BCC set_type
.3a5076	97 08		sta [$0808],y	                STA [INDEX],Y
.3a5078	c8		iny		                INY
.3a5079	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.3a507c	d0 ec		bne $3a506a	                BNE name_loop
.3a507e					set_type
.3a507e	c2 20		rep #$20	            REP #$20
.3a5080	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE      ; Copy the value to the variable
.3a5083	a5 23		lda $0823	                LDA ARGUMENT1
.3a5085	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a5087	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5089	c8		iny		                INY
.3a508a	c8		iny		                INY
.3a508b	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a508d	a5 e4		lda $08e4	                LDA VARIABLES           ; Point NEXT to the current top of variables
.3a508f	a0 0d 00	ldy #$000d	                LDY #BINDING.NEXT
.3a5092	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a5094	c8		iny		                INY
.3a5095	c8		iny		                INY
.3a5096	e2 20		sep #$20	            SEP #$20
.3a5098	a5 e6		lda $08e6	                LDA VARIABLES+2
.3a509a	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a509c	c2 20		rep #$20	            REP #$20
.3a509e	a5 c0		lda $08c0	                LDA CURRBLOCK
.3a50a0	85 e4		sta $08e4	                STA VARIABLES
.3a50a2	e2 20		sep #$20	            SEP #$20
.3a50a4	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.3a50a6	85 e6		sta $08e6	                STA VARIABLES+2
.3a50a8	e2 20		sep #$20	            SEP #$20
.3a50aa	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Set the type of the variable
.3a50ad	a5 27		lda $0827	                LDA ARGTYPE1
.3a50af	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a50b1	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is it a string?
.3a50b3	f0 02		beq $3a50b7	                BEQ set_ref             ; Yes: add a reference count to it
.3a50b5	28		plp		done            PLP
.3a50b6	60		rts		            RTS
.3a50b7					set_ref
.3a50b7	c2 20		rep #$20	            REP #$20
.3a50b9	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the a heap allocated value
.3a50bb	85 c0		sta $08c0	                STA CURRBLOCK
.3a50bd	e2 20		sep #$20	            SEP #$20
.3a50bf	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a50c1	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a50c3	20 bc 11	jsr $3a11bc	            JSR HEAP_GETHED
.3a50c6	20 d1 11	jsr $3a11d1	            JSR HEAP_ADDREF
.3a50c9	80 ea		bra $3a50b5	                BRA done
.3a50cb					VAR_SET
.3a50cb	08		php		                PHP
.3a50cc	c2 30		rep #$30	            REP #$30
.3a50ce	a5 e4		lda $08e4	                LDA VARIABLES          ; If VARIABLES = 0, use VAR_CREATE
.3a50d0	d0 06		bne $3a50d8	                BNE use_find
.3a50d2	e2 20		sep #$20	            SEP #$20
.3a50d4	a5 e6		lda $08e6	                LDA VARIABLES+2
.3a50d6	f0 05		beq $3a50dd	                BEQ use_create
.3a50d8					use_find
.3a50d8	20 db 4e	jsr $3a4edb	            JSR VAR_FIND
.3a50db	b0 05		bcs $3a50e2	                BCS found
.3a50dd					use_create
.3a50dd	20 00 50	jsr $3a5000	            JSR VAR_CREATE
.3a50e0	80 4e		bra $3a5130	                BRA done
.3a50e2					found
.3a50e2	e2 20		sep #$20	            SEP #$20
.3a50e4	a5 27		lda $0827	                LDA ARGTYPE1            ; Do the types match?
.3a50e6	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.3a50e8	f0 33		beq $3a511d	                BEQ chk_string          ; Yes: check to see if it's string
.3a50ea	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable
.3a50ec	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; Is it INTEGER?
.3a50ee	d0 05		bne $3a50f5	                BNE chk_float
.3a50f0	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a50f3	80 2c		bra $3a5121	                BRA set_val
.3a50f5	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; Is it FLOAT?
.3a50f7	d0 05		bne $3a50fe	                BNE type_error          ; No: throw an error
.3a50f9	20 71 06	jsr $3a0671	            JSR ASS_ARG1_FLOAT
.3a50fc	80 23		bra $3a5121	                BRA set_val
.3a50fe					type_error
.3a50fe	08		php		            PHP
.3a50ff	c2 20		rep #$20	            REP #$20
.3a5101	48		pha		            PHA
.3a5102	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a5105	5b		tcd		            TCD
.3a5106	68		pla		            PLA
.3a5107	28		plp		            PLP
.3a5108	e2 20		sep #$20	            SEP #$20
.3a510a	a9 04		lda #$04	            LDA #ERR_TYPE
.3a510c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a5110	c2 20		rep #$20	            REP #$20
.3a5112	29 ff 00	and #$00ff	            AND #$00FF
.3a5115	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a5118	e2 20		sep #$20	            SEP #$20
.3a511a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a511d	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING
.3a511f	f0 11		beq $3a5132	                BEQ set_string          ; Yes: set the string value of the variable
.3a5121					set_val
.3a5121	c2 30		rep #$30	            REP #$30
.3a5123	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.3a5126	a5 23		lda $0823	                LDA ARGUMENT1
.3a5128	97 08		sta [$0808],y	                STA [INDEX],Y
.3a512a	c8		iny		                INY
.3a512b	c8		iny		                INY
.3a512c	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a512e	97 08		sta [$0808],y	                STA [INDEX],Y
.3a5130					done
.3a5130	28		plp		                PLP
.3a5131	60		rts		            RTS
.3a5132					set_string
.3a5132	20 a0 15	jsr $3a15a0	            JSR STRCPY
.3a5135	a0 09 00	ldy #$0009	set_ref         LDY #BINDING.VALUE      ; Set CURRBLOCK to the current string value
.3a5138	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a513a	85 c0		sta $08c0	                STA CURRBLOCK
.3a513c	c8		iny		                INY
.3a513d	c8		iny		                INY
.3a513e	e2 20		sep #$20	            SEP #$20
.3a5140	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a5142	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a5144	20 bc 11	jsr $3a11bc	            JSR HEAP_GETHED
.3a5147	20 f0 11	jsr $3a11f0	            JSR HEAP_REMREF
.3a514a	e2 20		sep #$20	            SEP #$20
.3a514c	a5 27		lda $0827	                LDA ARGTYPE1
.3a514e	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is the new value a string?
.3a5150	f0 02		beq $3a5154	                BEQ add_ref             ; Yes: add a reference to it
.3a5152	80 cd		bra $3a5121	                BRA set_val             ; No: go back to set the value... this probably shouldn't happen
.3a5154					add_ref
.3a5154	c2 20		rep #$20	            REP #$20
.3a5156	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the new string value
.3a5158	85 c0		sta $08c0	                STA CURRBLOCK
.3a515a	e2 20		sep #$20	            SEP #$20
.3a515c	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a515e	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a5160	20 bc 11	jsr $3a11bc	            JSR HEAP_GETHED
.3a5163	20 d1 11	jsr $3a11d1	            JSR HEAP_ADDREF
.3a5166	80 b9		bra $3a5121	                BRA set_val
.3a5168					VAR_FINDNAME
.3a5168	08		php		                PHP
.3a5169	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a516c	e2 20		sep #$20	            SEP #$20
.3a516e	a7 00		lda [$0800]	                LDA [BIP]           ; Get the first character
.3a5170	20 94 03	jsr $3a0394	            JSR ISALPHA
.3a5173	90 42		bcc $3a51b7	                BCC not_found
.3a5175	c2 20		rep #$20	            REP #$20
.3a5177	a5 00		lda $0800	                LDA BIP
.3a5179	85 e7		sta $08e7	                STA TOFIND
.3a517b	e2 20		sep #$20	            SEP #$20
.3a517d	a5 02		lda $0802	                LDA BIP+2
.3a517f	85 e9		sta $08e9	                STA TOFIND+2
.3a5181					loop
.3a5181	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a5184	a7 00		lda [$0800]	                LDA [BIP]
.3a5186	f0 0d		beq $3a5195	                BEQ is_float        ; If it's EOL, the variable is a float
.3a5188	c9 24		cmp #$24	                CMP #'$'            ; If it's $, the variable is a string
.3a518a	f0 14		beq $3a51a0	                BEQ is_string
.3a518c	c9 25		cmp #$25	                CMP #'%'            ; If it's %, the variable is an integer
.3a518e	f0 09		beq $3a5199	                BEQ is_integer
.3a5190	20 95 4e	jsr $3a4e95	            JSR ISVARCHAR
.3a5193	b0 ec		bcs $3a5181	                BCS loop            ; Check the next one
.3a5195	a9 01		lda #$01	is_float        LDA #TYPE_FLOAT     ; Otherwise it's a float
.3a5197	80 0c		bra $3a51a5	                BRA set_type
.3a5199					is_integer
.3a5199	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a519c	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a519e	80 05		bra $3a51a5	                BRA set_type
.3a51a0					is_string
.3a51a0	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a51a3	a9 02		lda #$02	                LDA #TYPE_STRING
.3a51a5	85 ea		sta $08ea	set_type        STA TOFINDTYPE
.3a51a7	20 bf 20	jsr $3a20bf	            JSR PEEK_TOK
.3a51aa	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it "("?
.3a51ac	d0 06		bne $3a51b4	                BNE done            ; No: we're done... it's just a scalar variable
.3a51ae	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Yes: this is an array reference
.3a51b0	09 80		ora #$80	                ORA #$80            ; ... turn on the "Array of..." bit
.3a51b2	85 ea		sta $08ea	                STA TOFINDTYPE
.3a51b4					done
.3a51b4	28		plp		                PLP
.3a51b5	38		sec		                SEC
.3a51b6	60		rts		            RTS
.3a51b7	28		plp		not_found       PLP
.3a51b8	18		clc		                CLC
.3a51b9	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\integers.s

.3a51ba					OP_INT_ADD
.3a51ba	08		php		            PHP
.3a51bb	c2 20		rep #$20	            REP #$20
.3a51bd	18		clc		            CLC
.3a51be	a5 23		lda $0823	            LDA ARGUMENT1
.3a51c0	65 29		adc $0829	            ADC ARGUMENT2
.3a51c2	85 23		sta $0823	            STA ARGUMENT1
.3a51c4	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a51c6	65 2b		adc $082b	            ADC ARGUMENT2+2
.3a51c8	85 25		sta $0825	            STA ARGUMENT1+2
.3a51ca	28		plp		            PLP
.3a51cb	60		rts		            RTS
.3a51cc					OP_INT_SUB
.3a51cc	08		php		            PHP
.3a51cd	c2 20		rep #$20	            REP #$20
.3a51cf	38		sec		            SEC
.3a51d0	a5 23		lda $0823	            LDA ARGUMENT1
.3a51d2	e5 29		sbc $0829	            SBC ARGUMENT2
.3a51d4	85 23		sta $0823	            STA ARGUMENT1
.3a51d6	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a51d8	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.3a51da	85 25		sta $0825	            STA ARGUMENT1+2
.3a51dc	28		plp		            PLP
.3a51dd	60		rts		            RTS
.3a51de					OP_INT_MUL
.3a51de	08		php		            PHP
.3a51df					locals
>0001					L_SIGN      .word ?
>0003					L_RESULT    .dword ?
>0007					            .dword ?
.3a51df	c2 20		rep #$20	            REP #$20
.3a51e1	3b		tsc		            TSC
.3a51e2	38		sec		            SEC
.3a51e3	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.3a51e6	1b		tcs		            TCS
.3a51e7	c2 30		rep #$30	            REP #$30
.3a51e9	a9 00 00	lda #$0000	            LDA #0                  ; Start by assuming positive numbers
.3a51ec	83 01		sta $01,s	            STA L_SIGN
.3a51ee	83 03		sta $03,s	            STA L_RESULT            ; Clear result
.3a51f0	83 05		sta $05,s	            STA L_RESULT+2
.3a51f2	83 07		sta $07,s	            STA L_RESULT+4
.3a51f4	83 09		sta $09,s	            STA L_RESULT+6
.3a51f6	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Ensure ARGUMENT1 is positive
.3a51f8	10 18		bpl $3a5212	            BPL chk_sign2
.3a51fa	a9 00 80	lda #$8000	            LDA #$8000              ; Record that ARGUMENT1 is negative
.3a51fd	83 01		sta $01,s	            STA L_SIGN
.3a51ff	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Take the two's complement of ARGUMENT1
.3a5201	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a5204	85 25		sta $0825	            STA ARGUMENT1+2
.3a5206	a5 23		lda $0823	            LDA ARGUMENT1
.3a5208	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a520b	1a		inc a		            INC A
.3a520c	85 23		sta $0823	            STA ARGUMENT1
.3a520e	d0 02		bne $3a5212	            BNE chk_sign2
.3a5210	e6 25		inc $0825	            INC ARGUMENT1+2
.3a5212	a5 2b		lda $082b	chk_sign2   LDA ARGUMENT2+2         ; Ensure ARGUMENT2 is positive
.3a5214	10 1a		bpl $3a5230	            BPL chk_over
.3a5216	a3 01		lda $01,s	            LDA L_SIGN              ; Flip the sign
.3a5218	49 00 80	eor #$8000	            EOR #$8000
.3a521b	83 01		sta $01,s	            STA L_SIGN
.3a521d	a5 2b		lda $082b	            LDA ARGUMENT2+2         ; Take the two's complement of ARGUMENT2
.3a521f	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a5222	85 2b		sta $082b	            STA ARGUMENT2+2
.3a5224	a5 29		lda $0829	            LDA ARGUMENT2
.3a5226	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a5229	1a		inc a		            INC A
.3a522a	85 29		sta $0829	            STA ARGUMENT2
.3a522c	d0 02		bne $3a5230	            BNE chk_over
.3a522e	e6 2b		inc $082b	            INC ARGUMENT2+2
.3a5230					chk_over
.3a5230	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5232	f0 04		beq $3a5238	            BEQ do_mult
.3a5234	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a5236	d0 5a		bne $3a5292	            BNE overflow
.3a5238					do_mult
.3a5238	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*D
.3a523a	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.3a523e	a5 29		lda $0829	            LDA ARGUMENT2
.3a5240	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.3a5244	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.3a5248	83 03		sta $03,s	            STA L_RESULT
.3a524a	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.3a524e	83 05		sta $05,s	            STA L_RESULT+2
.3a5250	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Calculate A*D << 16 + B*D
.3a5252	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.3a5256	a5 29		lda $0829	            LDA ARGUMENT2
.3a5258	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.3a525c	18		clc		            CLC
.3a525d	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.3a5261	63 05		adc $05,s	            ADC L_RESULT+2
.3a5263	83 05		sta $05,s	            STA L_RESULT+2
.3a5265	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.3a5269	63 07		adc $07,s	            ADC L_RESULT+4
.3a526b	83 07		sta $07,s	            STA L_RESULT+4
.3a526d	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*C << 16 + A*D << 16 + B*D
.3a526f	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.3a5273	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a5275	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.3a5279	18		clc		            CLC
.3a527a	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.3a527e	63 05		adc $05,s	            ADC L_RESULT+2
.3a5280	83 05		sta $05,s	            STA L_RESULT+2
.3a5282	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.3a5286	63 07		adc $07,s	            ADC L_RESULT+4
.3a5288	83 07		sta $07,s	            STA L_RESULT+4
.3a528a	a3 07		lda $07,s	            LDA L_RESULT+4
.3a528c	f0 23		beq $3a52b1	            BEQ no_overflow
.3a528e	a3 09		lda $09,s	            LDA L_RESULT+6
.3a5290	f0 1f		beq $3a52b1	            BEQ no_overflow
.3a5292					overflow
.3a5292	08		php		            PHP
.3a5293	c2 20		rep #$20	            REP #$20
.3a5295	48		pha		            PHA
.3a5296	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a5299	5b		tcd		            TCD
.3a529a	68		pla		            PLA
.3a529b	28		plp		            PLP
.3a529c	e2 20		sep #$20	            SEP #$20
.3a529e	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.3a52a0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a52a4	c2 20		rep #$20	            REP #$20
.3a52a6	29 ff 00	and #$00ff	            AND #$00FF
.3a52a9	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a52ac	e2 20		sep #$20	            SEP #$20
.3a52ae	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a52b1					no_overflow
.3a52b1	c2 30		rep #$30	            REP #$30
.3a52b3	a3 01		lda $01,s	            LDA L_SIGN              ; Check the sign
.3a52b5	10 16		bpl $3a52cd	            BPL ret_result          ; If positive: just return the result
.3a52b7	a3 05		lda $05,s	            LDA L_RESULT+2          ; Compute the two's complement of the result
.3a52b9	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a52bc	83 05		sta $05,s	            STA L_RESULT+2
.3a52be	a3 03		lda $03,s	            LDA L_RESULT
.3a52c0	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a52c3	1a		inc a		            INC A
.3a52c4	83 03		sta $03,s	            STA L_RESULT
.3a52c6	d0 05		bne $3a52cd	            BNE ret_result
.3a52c8	a3 05		lda $05,s	            LDA L_RESULT+2
.3a52ca	1a		inc a		            INC A
.3a52cb	83 05		sta $05,s	            STA L_RESULT+2
.3a52cd					ret_result
.3a52cd	a3 03		lda $03,s	            LDA L_RESULT
.3a52cf	85 23		sta $0823	            STA ARGUMENT1
.3a52d1	a3 05		lda $05,s	            LDA L_RESULT+2
.3a52d3	85 25		sta $0825	            STA ARGUMENT1+2
.3a52d5	c2 20		rep #$20	            REP #$20
.3a52d7	3b		tsc		            TSC
.3a52d8	18		clc		            CLC
.3a52d9	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.3a52dc	1b		tcs		            TCS
.3a52dd	28		plp		            PLP
.3a52de	60		rts		            RTS
.3a52df					OP_INT_LT
.3a52df	08		php		            PHP
.3a52e0	c2 20		rep #$20	            REP #$20
.3a52e2	a5 23		lda $0823	            LDA ARGUMENT1
.3a52e4	c5 29		cmp $0829	            CMP ARGUMENT2
.3a52e6	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a52e8	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.3a52ea	50 03		bvc $3a52ef	            BVC skip_eor
.3a52ec	49 00 80	eor #$8000	            EOR #$8000
.3a52ef	30 06		bmi $3a52f7	skip_eor    BMI ret_true
.3a52f1	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a52f3	64 25		stz $0825	            STZ ARGUMENT1+2
.3a52f5	80 07		bra $3a52fe	            BRA done
.3a52f7	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a52fa	85 23		sta $0823	            STA ARGUMENT1
.3a52fc	85 25		sta $0825	            STA ARGUMENT1+2
.3a52fe	28		plp		done        PLP
.3a52ff	60		rts		            RTS
.3a5300					OP_INT_GT
.3a5300	08		php		            PHP
.3a5301	c2 20		rep #$20	            REP #$20
.3a5303	a5 23		lda $0823	            LDA ARGUMENT1
.3a5305	c5 29		cmp $0829	            CMP ARGUMENT2
.3a5307	d0 0c		bne $3a5315	            BNE test_fully
.3a5309	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a530b	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.3a530d	d0 06		bne $3a5315	            BNE test_fully
.3a530f	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a5311	64 25		stz $0825	            STZ ARGUMENT1+2
.3a5313	80 16		bra $3a532b	            BRA done
.3a5315	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.3a5317	c5 23		cmp $0823	            CMP ARGUMENT1
.3a5319	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a531b	e5 25		sbc $0825	            SBC ARGUMENT1+2
.3a531d	50 03		bvc $3a5322	            BVC skip_eor
.3a531f	49 00 80	eor #$8000	            EOR #$8000
.3a5322	10 eb		bpl $3a530f	skip_eor    BPL ret_false
.3a5324	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a5327	85 23		sta $0823	            STA ARGUMENT1
.3a5329	85 25		sta $0825	            STA ARGUMENT1+2
.3a532b	28		plp		done        PLP
.3a532c	60		rts		            RTS
.3a532d					OP_INT_EQ
.3a532d	08		php		            PHP
.3a532e	c2 20		rep #$20	            REP #$20
.3a5330	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a5332	c5 25		cmp $0825	            CMP ARGUMENT1+2
.3a5334	d0 0f		bne $3a5345	            BNE ret_false
.3a5336	a5 29		lda $0829	            LDA ARGUMENT2
.3a5338	c5 23		cmp $0823	            CMP ARGUMENT1
.3a533a	d0 09		bne $3a5345	            BNE ret_false
.3a533c	a9 ff ff	lda #$ffff	            LDA #$FFFF
.3a533f	85 23		sta $0823	            STA ARGUMENT1
.3a5341	85 25		sta $0825	            STA ARGUMENT1+2
.3a5343	80 04		bra $3a5349	            BRA done
.3a5345	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a5347	64 25		stz $0825	            STZ ARGUMENT1+2
.3a5349	28		plp		done        PLP
.3a534a	60		rts		            RTS
.3a534b					OP_INT_NE
.3a534b	08		php		            PHP
.3a534c	c2 20		rep #$20	            REP #$20
.3a534e	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a5350	c5 25		cmp $0825	            CMP ARGUMENT1+2
.3a5352	d0 0c		bne $3a5360	            BNE ret_true
.3a5354	a5 29		lda $0829	            LDA ARGUMENT2
.3a5356	c5 23		cmp $0823	            CMP ARGUMENT1
.3a5358	d0 06		bne $3a5360	            BNE ret_true
.3a535a	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a535c	64 25		stz $0825	            STZ ARGUMENT1+2
.3a535e	80 07		bra $3a5367	            BRA done
.3a5360	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a5363	85 23		sta $0823	            STA ARGUMENT1
.3a5365	85 25		sta $0825	            STA ARGUMENT1+2
.3a5367	28		plp		done        PLP
.3a5368	60		rts		            RTS
.3a5369					OP_INT_GTE
.3a5369	08		php		            PHP
.3a536a	c2 20		rep #$20	            REP #$20
.3a536c	a5 23		lda $0823	            LDA ARGUMENT1
.3a536e	c5 29		cmp $0829	            CMP ARGUMENT2
.3a5370	d0 0f		bne $3a5381	            BNE test_fully
.3a5372	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5374	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.3a5376	d0 09		bne $3a5381	            BNE test_fully
.3a5378	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a537b	85 23		sta $0823	            STA ARGUMENT1
.3a537d	85 25		sta $0825	            STA ARGUMENT1+2
.3a537f	80 13		bra $3a5394	            BRA done
.3a5381	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.3a5383	c5 23		cmp $0823	            CMP ARGUMENT1
.3a5385	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a5387	e5 25		sbc $0825	            SBC ARGUMENT1+2
.3a5389	50 03		bvc $3a538e	            BVC skip_eor
.3a538b	49 00 80	eor #$8000	            EOR #$8000
.3a538e	30 e8		bmi $3a5378	skip_eor    BMI ret_true
.3a5390	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a5392	64 25		stz $0825	            STZ ARGUMENT1+2
.3a5394	28		plp		done        PLP
.3a5395	60		rts		            RTS
.3a5396					OP_INT_LTE
.3a5396	08		php		            PHP
.3a5397	c2 20		rep #$20	            REP #$20
.3a5399	a5 23		lda $0823	            LDA ARGUMENT1
.3a539b	c5 29		cmp $0829	            CMP ARGUMENT2
.3a539d	d0 0f		bne $3a53ae	            BNE test_fully
.3a539f	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a53a1	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.3a53a3	d0 09		bne $3a53ae	            BNE test_fully
.3a53a5	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a53a8	85 23		sta $0823	            STA ARGUMENT1
.3a53aa	85 25		sta $0825	            STA ARGUMENT1+2
.3a53ac	80 13		bra $3a53c1	            BRA done
.3a53ae	a5 23		lda $0823	test_fully  LDA ARGUMENT1
.3a53b0	c5 29		cmp $0829	            CMP ARGUMENT2
.3a53b2	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a53b4	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.3a53b6	50 03		bvc $3a53bb	            BVC skip_eor
.3a53b8	49 00 80	eor #$8000	            EOR #$8000
.3a53bb	30 e8		bmi $3a53a5	skip_eor    BMI ret_true
.3a53bd	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a53bf	64 25		stz $0825	            STZ ARGUMENT1+2
.3a53c1	28		plp		done        PLP
.3a53c2	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\floats.s


;******  Processing file: src\C256/floats.s


;******  Processing file: src\C256/fp_math_defs.s

=$afe200				FP_MATH_CTRL0 = $AFE200         ; Read/write
=$08					FP_MATH_CTRL0_ADD = $08         ; 0: Substraction - 1: Addition
=$01					FP_CTRL0_CONV_0 = %00000001     ; Input 0 should be converted from 24.12 fixed point to floating point
=$02					FP_CTRL0_CONV_1 = %00000010     ; Input 1 should be converted from 24.12 fixed point to floating point
=$00					FP_ADD_IN0_MUX0 = %00000000     ; Adder input #0 is the output of MUX0
=$10					FP_ADD_IN0_MUX1 = %00010000     ; Adder input #0 is the output of MUX1
=$20					FP_ADD_IN0_MULT = %00100000     ; Adder input #0 is the output of the multiplier
=$30					FP_ADD_IN0_DIV  = %00110000     ; Adder input #0 is the output of the divider
=$00					FP_ADD_IN1_MUX0 = %00000000     ; Adder input #1 is the output of MUX0
=$40					FP_ADD_IN1_MUX1 = %01000000     ; Adder input #1 is the output of MUX1
=$80					FP_ADD_IN1_MULT = %10000000     ; Adder input #1 is the output of the multiplier
=$c0					FP_ADD_IN1_DIV  = %11000000     ; Adder input #1 is the output of the divider
=$afe201				FP_MATH_CTRL1 = $AFE201
=$00					FP_OUT_MULT = %00000000         ; Output is from the multiplier
=$01					FP_OUT_DIV  = %00000001         ; Output is from the divider
=$02					FP_OUT_ADD  = %00000010         ; Output is from the adder/subtracter
=$03					FP_OUT_ONE  = %00000011         ; Output is the constant '1.0'
=$afe202				FP_MATH_CTRL2 = $AFE202         ; Not Used - Reserved
=$afe203				FP_MATH_CTRL3 = $AFE203         ; Not Used - Reserved
=$afe204				FP_MATH_MULT_STAT = $AFE204     ; Status of the multiplier
=$01					FP_MULT_STAT_NAN  = $01         ; (NAN) Not a Number Status
=$02					FP_MULT_STAT_OVF  = $02         ; Overflow
=$04					FP_MULT_STAT_UDF  = $04         ; Underflow
=$08					FP_MULT_STAT_ZERO = $08         ; Zero
=$afe205				FP_MATH_DIV_STAT  = $AFE205     ; Status of the divider
=$01					FP_DIV_STAT_NAN       = $01     ; Not a number Status
=$02					FP_DIV_STAT_OVF       = $02     ; Overflow
=$04					FP_DIV_STAT_UDF       = $04     ; Underflow
=$08					FP_DIV_STAT_ZERO      = $08     ; Zero
=$10					FP_DIV_STAT_DIVBYZERO = $10     ; Division by Zero
=$afe206				FP_MATH_ADD_STAT  = $AFE206     ; Status of the adder/subtracter
=$01					FP_ADD_STAT_NAN  = $01          ; Not a number Status
=$02					FP_ADD_STAT_OVF  = $02          ; Overflow
=$04					FP_ADD_STAT_UDF  = $04          ; Underflow
=$08					FP_ADD_STAT_ZERO = $08          ; Zero
=$afe207				FP_MATH_CONV_STAT = $AFE207     ; Status of the fixed <=> float converters
=$01					FP_CONV_STAT_NAN  = $01         ; Not a number Status
=$02					FP_CONV_STAT_OVF  = $02         ; Overflow
=$04					FP_CONV_STAT_UDF  = $04         ; Underflow
=$afe208				FP_MATH_INPUT0_LL = $AFE208
=$afe209				FP_MATH_INPUT0_LH = $AFE209
=$afe20a				FP_MATH_INPUT0_HL = $AFE20A
=$afe20b				FP_MATH_INPUT0_HH = $AFE20B
=$afe20c				FP_MATH_INPUT1_LL = $AFE20C
=$afe20d				FP_MATH_INPUT1_LH = $AFE20D
=$afe20e				FP_MATH_INPUT1_HL = $AFE20E
=$afe20f				FP_MATH_INPUT1_HH = $AFE20F
=$afe208				FP_MATH_OUTPUT_FP_LL = $AFE208
=$afe209				FP_MATH_OUTPUT_FP_LH = $AFE209
=$afe20a				FP_MATH_OUTPUT_FP_HL = $AFE20A
=$afe20b				FP_MATH_OUTPUT_FP_HH = $AFE20B
=$afe20c				FP_MATH_OUTPUT_FIXED_LL = $AFE20C
=$afe20d				FP_MATH_OUTPUT_FIXED_LH = $AFE20D
=$afe20e				FP_MATH_OUTPUT_FIXED_HL = $AFE20E
=$afe20f				FP_MATH_OUTPUT_FIXED_HH = $AFE20F

;******  Return to file: src\C256/floats.s


;******  Processing file: src\C256/math_cop.s

.3a53c3					UINT_DIV_A_X
.3a53c3	08		php		                    PHP
.3a53c4	c2 20		rep #$20	            REP #$20
.3a53c6	8f 12 01 00	sta $000112	                    STA @l UNSIGNED_DIV_NUM_LO
.3a53ca	8a		txa		                    TXA
.3a53cb	8f 10 01 00	sta $000110	                    STA @l UNSIGNED_DIV_DEM_LO
.3a53cf	af 16 01 00	lda $000116	                    LDA @l UNSIGNED_DIV_REM_LO
.3a53d3	aa		tax		                    TAX
.3a53d4	af 14 01 00	lda $000114	                    LDA @l UNSIGNED_DIV_QUO_LO
.3a53d8	28		plp		                    PLP
.3a53d9	60		rts		            RTS

;******  Return to file: src\C256/floats.s

.3a53da					FIXINT_TO_FP
.3a53da	08		php		                    PHP
.3a53db	e2 20		sep #$20	            SEP #$20
.3a53dd	a9 03		lda #$03	                    LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.3a53df	8f 00 e2 af	sta $afe200	                    STA @l FP_MATH_CTRL0
.3a53e3	a9 00		lda #$00	                    LDA #FP_OUT_MULT
.3a53e5	8f 01 e2 af	sta $afe201	                    STA @l FP_MATH_CTRL1
.3a53e9	c2 20		rep #$20	            REP #$20
.3a53eb	a5 23		lda $0823	                    LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.3a53ed	8f 08 e2 af	sta $afe208	                    STA @l FP_MATH_INPUT0_LL
.3a53f1	a5 25		lda $0825	                    LDA ARGUMENT1+2
.3a53f3	8f 0a e2 af	sta $afe20a	                    STA @l FP_MATH_INPUT0_HL
.3a53f7	a9 00 00	lda #$0000	                    LDA #0
.3a53fa	8f 0c e2 af	sta $afe20c	                    STA @l FP_MATH_INPUT1_LL    ; ARGUMENT2 = 0100 0000 = 4096 in 20:12
.3a53fe	a9 00 01	lda #$0100	                    LDA #$0100
.3a5401	8f 0e e2 af	sta $afe20e	                    STA @l FP_MATH_INPUT1_HL
.3a5405	ea		nop		                    NOP
.3a5406	ea		nop		                    NOP
.3a5407	ea		nop		                    NOP
.3a5408	ea		nop		                    NOP
.3a5409	ea		nop		                    NOP
.3a540a	ea		nop		                    NOP
.3a540b	af 08 e2 af	lda $afe208	                    LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.3a540f	85 23		sta $0823	                    STA ARGUMENT1
.3a5411	af 0a e2 af	lda $afe20a	                    LDA @l FP_MATH_OUTPUT_FP_HL
.3a5415	85 25		sta $0825	                    STA ARGUMENT1+2
.3a5417	a9 01 00	lda #$0001	                    LDA #TYPE_FLOAT
.3a541a	85 27		sta $0827	                    STA ARGTYPE1
.3a541c	28		plp		                    PLP
.3a541d	60		rts		            RTS
.3a541e	08		php		OP_FP_SUB       PHP
.3a541f	e2 20		sep #$20	            SEP #$20
.3a5421	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a5423	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.3a5427	80 09		bra $3a5432	                BRA FP_ADD_SUB
.3a5429	08		php		OP_FP_ADD       PHP
.3a542a	e2 20		sep #$20	            SEP #$20
.3a542c	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a542e	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.3a5432	a9 02		lda #$02	FP_ADD_SUB      LDA #FP_OUT_ADD
.3a5434	8f 01 e2 af	sta $afe201	                STA @lFP_MATH_CTRL1
.3a5438	c2 20		rep #$20	            REP #$20
.3a543a	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.3a543c	8f 08 e2 af	sta $afe208	                STA @lFP_MATH_INPUT0_LL
.3a5440	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5442	8f 0a e2 af	sta $afe20a	                STA @lFP_MATH_INPUT0_HL
.3a5446	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.3a5448	8f 0c e2 af	sta $afe20c	                STA @lFP_MATH_INPUT1_LL
.3a544c	a5 2b		lda $082b	                LDA ARGUMENT2+2
.3a544e	8f 0e e2 af	sta $afe20e	                STA @lFP_MATH_INPUT1_HL
.3a5452	ea		nop		                NOP
.3a5453	ea		nop		                NOP
.3a5454	ea		nop		                NOP
.3a5455	e2 20		sep #$20	            SEP #$20
.3a5457	af 06 e2 af	lda $afe206	                LDA @lFP_MATH_ADD_STAT      ; Check the status of the addition
.3a545b	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.3a545d	d0 10		bne $3a546f	                BNE fp_add_error            ; If an issue was raise, process the math error
.3a545f	c2 20		rep #$20	            REP #$20
.3a5461	af 08 e2 af	lda $afe208	                LDA @lFP_MATH_OUTPUT_FP_LL  ; Retrieve the results into ARGUMENT1
.3a5465	85 23		sta $0823	                STA ARGUMENT1
.3a5467	af 0a e2 af	lda $afe20a	                LDA @lFP_MATH_OUTPUT_FP_HL
.3a546b	85 25		sta $0825	                STA ARGUMENT1+2
.3a546d	28		plp		fp_add_done     PLP
.3a546e	60		rts		            RTS
.3a546f					fp_add_error
.3a546f	20 0a 55	jsr $3a550a	            JSR FP_MATH_ERROR
.3a5472	80 f9		bra $3a546d	                BRA fp_add_done
.3a5474	08		php		OP_FP_DIV       PHP
.3a5475	e2 20		sep #$20	            SEP #$20
.3a5477	a9 01		lda #$01	                LDA #FP_OUT_DIV
.3a5479	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a547d	a9 00		lda #$00	                LDA #0
.3a547f	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.3a5483	c2 20		rep #$20	            REP #$20
.3a5485	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.3a5487	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a548b	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a548d	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5491	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.3a5493	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5497	a5 2b		lda $082b	                LDA ARGUMENT2+2
.3a5499	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a549d	ea		nop		                NOP
.3a549e	ea		nop		                NOP
.3a549f	ea		nop		                NOP
.3a54a0	e2 20		sep #$20	            SEP #$20
.3a54a2	af 05 e2 af	lda $afe205	                LDA @l FP_MATH_DIV_STAT     ; Check the status of the addition
.3a54a6	29 17		and #$17	                AND #%00010111              ; Filter out the ZERO status
.3a54a8	d0 10		bne $3a54ba	                BNE fp_div_error            ; If an issue was raise, process the math error
.3a54aa	c2 20		rep #$20	            REP #$20
.3a54ac	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.3a54b0	85 23		sta $0823	                STA ARGUMENT1
.3a54b2	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a54b6	85 25		sta $0825	                STA ARGUMENT1+2
.3a54b8	28		plp		fp_div_done     PLP
.3a54b9	60		rts		            RTS
.3a54ba					fp_div_error
.3a54ba	20 0a 55	jsr $3a550a	            JSR FP_MATH_ERROR
.3a54bd	80 f9		bra $3a54b8	                BRA fp_div_done
.3a54bf	08		php		OP_FP_MUL       PHP
.3a54c0	e2 20		sep #$20	            SEP #$20
.3a54c2	a9 00		lda #$00	                LDA #FP_OUT_MULT
.3a54c4	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a54c8	a9 00		lda #$00	                LDA #0
.3a54ca	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.3a54ce	c2 20		rep #$20	            REP #$20
.3a54d0	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.3a54d2	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a54d6	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a54d8	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a54dc	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.3a54de	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a54e2	a5 2b		lda $082b	                LDA ARGUMENT2+2
.3a54e4	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a54e8	ea		nop		                NOP
.3a54e9	ea		nop		                NOP
.3a54ea	ea		nop		                NOP
.3a54eb	e2 20		sep #$20	            SEP #$20
.3a54ed	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT    ; Check the status of the addition
.3a54f1	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.3a54f3	d0 10		bne $3a5505	                BNE fp_mul_error            ; If an issue was raise, process the math error
.3a54f5	c2 20		rep #$20	            REP #$20
.3a54f7	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.3a54fb	85 23		sta $0823	                STA ARGUMENT1
.3a54fd	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5501	85 25		sta $0825	                STA ARGUMENT1+2
.3a5503	28		plp		fp_mul_done     PLP
.3a5504	60		rts		            RTS
.3a5505					fp_mul_error
.3a5505	20 0a 55	jsr $3a550a	            JSR FP_MATH_ERROR
.3a5508	80 f9		bra $3a5503	                BRA fp_mul_done
.3a550a					FP_MATH_ERROR
.3a550a	e2 20		sep #$20	            SEP #$20
.3a550c	89 01		bit #$01	                BIT #FP_ADD_STAT_NAN        ; Is there a NaN condition?
.3a550e	f0 20		beq $3a5530	                BEQ check_over              ; No: check for overflow
.3a5510	00		brk #		                BRK
.3a5511	08		php		            PHP
.3a5512	c2 20		rep #$20	            REP #$20
.3a5514	48		pha		            PHA
.3a5515	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a5518	5b		tcd		            TCD
.3a5519	68		pla		            PLA
.3a551a	28		plp		            PLP
.3a551b	e2 20		sep #$20	            SEP #$20
.3a551d	a9 0c		lda #$0c	            LDA #ERR_NAN
.3a551f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a5523	c2 20		rep #$20	            REP #$20
.3a5525	29 ff 00	and #$00ff	            AND #$00FF
.3a5528	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a552b	e2 20		sep #$20	            SEP #$20
.3a552d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a5530	89 02		bit #$02	check_over      BIT #FP_ADD_STAT_OVF        ; Is ther an overflow condition?
.3a5532	f0 1f		beq $3a5553	                BEQ check_under             ; No: check for underflow
.3a5534	08		php		            PHP
.3a5535	c2 20		rep #$20	            REP #$20
.3a5537	48		pha		            PHA
.3a5538	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a553b	5b		tcd		            TCD
.3a553c	68		pla		            PLA
.3a553d	28		plp		            PLP
.3a553e	e2 20		sep #$20	            SEP #$20
.3a5540	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.3a5542	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a5546	c2 20		rep #$20	            REP #$20
.3a5548	29 ff 00	and #$00ff	            AND #$00FF
.3a554b	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a554e	e2 20		sep #$20	            SEP #$20
.3a5550	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a5553	89 04		bit #$04	check_under     BIT #FP_ADD_STAT_UDF        ; Is there an underflow condition?
.3a5555	f0 1f		beq $3a5576	                BEQ done                    ; No: we should just return... this probably shouldn't happen
.3a5557	08		php		            PHP
.3a5558	c2 20		rep #$20	            REP #$20
.3a555a	48		pha		            PHA
.3a555b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a555e	5b		tcd		            TCD
.3a555f	68		pla		            PLA
.3a5560	28		plp		            PLP
.3a5561	e2 20		sep #$20	            SEP #$20
.3a5563	a9 0e		lda #$0e	            LDA #ERR_UNDERFLOW
.3a5565	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a5569	c2 20		rep #$20	            REP #$20
.3a556b	29 ff 00	and #$00ff	            AND #$00FF
.3a556e	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a5571	e2 20		sep #$20	            SEP #$20
.3a5573	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a5576					done
.3a5576	60		rts		            RTS
.3a5577					FP_MUL10
.3a5577	08		php		                PHP
.3a5578	e2 20		sep #$20	            SEP #$20
.3a557a	a9 00		lda #$00	                LDA #FP_OUT_MULT                ; Set for multiplication
.3a557c	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5580	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1            ; Input 1 is fixed point
.3a5582	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5586	c2 20		rep #$20	            REP #$20
.3a5588	a9 00 a0	lda #$a000	                LDA #$A000                      ; 10 is one factor
.3a558b	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a558f	a9 00 00	lda #$0000	                LDA #0
.3a5592	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5596	a5 23		lda $0823	                LDA ARGUMENT1                   ; N is the other
.3a5598	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a559c	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a559e	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a55a2	ea		nop		                NOP
.3a55a3	ea		nop		                NOP
.3a55a4	ea		nop		                NOP
.3a55a5	e2 20		sep #$20	            SEP #$20
.3a55a7	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT        ; Check the status
.3a55ab	89 07		bit #$07	                BIT #FP_MULT_STAT_NAN | FP_MULT_STAT_OVF | FP_MULT_STAT_UDF
.3a55ad	f0 01		beq $3a55b0	                BEQ ret_result
.3a55af	00		brk #		                BRK                             ; There was an error...
.3a55b0					ret_result
.3a55b0	c2 20		rep #$20	            REP #$20
.3a55b2	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL     ; Save result back
.3a55b6	85 23		sta $0823	                STA ARGUMENT1
.3a55b8	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a55bc	85 25		sta $0825	                STA ARGUMENT1+2
.3a55be	28		plp		                PLP
.3a55bf	60		rts		            RTS
.3a55c0					FP_DIV10
.3a55c0	08		php		                PHP
.3a55c1	e2 20		sep #$20	            SEP #$20
.3a55c3	a9 01		lda #$01	                LDA #FP_OUT_DIV             ; Set for multiplication
.3a55c5	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a55c9	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1        ; Input 1 is fixed point
.3a55cb	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a55cf	c2 20		rep #$20	            REP #$20
.3a55d1	a9 00 a0	lda #$a000	                LDA #$A000                  ; 10 is one factor
.3a55d4	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a55d8	a9 00 00	lda #$0000	                LDA #0
.3a55db	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a55df	a5 23		lda $0823	                LDA ARGUMENT1               ; N is the other
.3a55e1	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a55e5	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a55e7	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a55eb	ea		nop		                NOP
.3a55ec	ea		nop		                NOP
.3a55ed	ea		nop		                NOP
.3a55ee	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Save result back
.3a55f2	85 23		sta $0823	                STA ARGUMENT1
.3a55f4	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a55f8	85 25		sta $0825	                STA ARGUMENT1+2
.3a55fa	28		plp		                PLP
.3a55fb	60		rts		            RTS

;******  Return to file: src\floats.s

.3a55fc					FARG1EQ0
.3a55fc	08		php		                PHP
.3a55fd	c2 20		rep #$20	            REP #$20
.3a55ff	a5 23		lda $0823	                LDA ARGUMENT1
.3a5601	d0 0a		bne $3a560d	                BNE return_false
.3a5603	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5605	29 ff 7f	and #$7fff	                AND #$7FFF              ; Mask off the sign bit
.3a5608	d0 03		bne $3a560d	                BNE return_false
.3a560a	28		plp		return_true     PLP
.3a560b	38		sec		                SEC
.3a560c	60		rts		            RTS
.3a560d	28		plp		return_false    PLP
.3a560e	18		clc		                CLC
.3a560f	60		rts		            RTS
.3a5610					SHIFTDEC
.3a5610	08		php		                PHP
.3a5611	e2 20		sep #$20	            SEP #$20
.3a5613	38		sec		                SEC                     ; Convert '0'..'9' to it's number
.3a5614	e9 30		sbc #$30	                SBC #'0'
.3a5616	20 2c 04	jsr $3a042c	            JSR MULINT10
.3a5619	c2 20		rep #$20	            REP #$20
.3a561b	29 ff 00	and #$00ff	                AND #$00FF              ; Add the number to ARGUMENT1
.3a561e	18		clc		                CLC
.3a561f	65 23		adc $0823	                ADC ARGUMENT1
.3a5621	85 23		sta $0823	                STA ARGUMENT1
.3a5623	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5625	69 00 00	adc #$0000	                ADC #0
.3a5628	85 25		sta $0825	                STA ARGUMENT1+2
.3a562a	28		plp		                PLP
.3a562b	60		rts		            RTS
.3a562c					SHIFTHEX
.3a562c	08		php		                PHP
.3a562d	e2 20		sep #$20	            SEP #$20
.3a562f	c9 30		cmp #$30	                CMP #'0'                ; Process 0-9
.3a5631	90 04		bcc $3a5637	                BLT not_09
.3a5633	c9 3a		cmp #$3a	                CMP #'9'+1
.3a5635	90 1c		bcc $3a5653	                BLT is_09
.3a5637	c9 61		cmp #$61	not_09          CMP #'a'                ; Process lowercase A-F
.3a5639	90 04		bcc $3a563f	                BLT not_lc
.3a563b	c9 67		cmp #$67	                CMP #'f'+1
.3a563d	90 0a		bcc $3a5649	                BLT is_lc
.3a563f	c9 41		cmp #$41	not_lc          CMP #'A'                ; Process uppercase A-F
.3a5641	90 04		bcc $3a5647	                BLT not_uc
.3a5643	c9 47		cmp #$47	                CMP #'F'+1
.3a5645	90 07		bcc $3a564e	                BLT is_uc
.3a5647	80 31		bra $3a567a	not_uc          BRA done                ; Just return if we couldn't convert... this shouldn't happen
.3a5649	38		sec		is_lc           SEC                     ; Convert 'a'-'f' to the actual number
.3a564a	e9 57		sbc #$57	                SBC #'a'-10
.3a564c	80 08		bra $3a5656	                BRA shift
.3a564e	38		sec		is_uc           SEC                     ; Convert 'A'-'F' to the actual number
.3a564f	e9 37		sbc #$37	                SBC #'A'-10
.3a5651	80 03		bra $3a5656	                BRA shift
.3a5653	38		sec		is_09           SEC                     ; Convert '0'-'9' to the actual number
.3a5654	e9 30		sbc #$30	                SBC #'0'
.3a5656					shift
.3a5656	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.3a5658	26 24		rol $0824	                ROL ARGUMENT1+1
.3a565a	26 25		rol $0825	                ROL ARGUMENT1+2
.3a565c	26 26		rol $0826	                ROL ARGUMENT1+3
.3a565e	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.3a5660	26 24		rol $0824	                ROL ARGUMENT1+1
.3a5662	26 25		rol $0825	                ROL ARGUMENT1+2
.3a5664	26 26		rol $0826	                ROL ARGUMENT1+3
.3a5666	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.3a5668	26 24		rol $0824	                ROL ARGUMENT1+1
.3a566a	26 25		rol $0825	                ROL ARGUMENT1+2
.3a566c	26 26		rol $0826	                ROL ARGUMENT1+3
.3a566e	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.3a5670	26 24		rol $0824	                ROL ARGUMENT1+1
.3a5672	26 25		rol $0825	                ROL ARGUMENT1+2
.3a5674	26 26		rol $0826	                ROL ARGUMENT1+3
.3a5676	05 23		ora $0823	                ORA ARGUMENT1           ; Add the number to it
.3a5678	85 23		sta $0823	                STA ARGUMENT1
.3a567a	28		plp		done            PLP
.3a567b	60		rts		            RTS
.3a567c					SHIFTBIN
.3a567c	08		php		                PHP
.3a567d	e2 20		sep #$20	            SEP #$20
.3a567f	c9 30		cmp #$30	                CMP #'0'                ; If the character is '0'...
.3a5681	f0 06		beq $3a5689	                BEQ shift_0             ; Shift a 0 onto ARGUMENT1
.3a5683	c9 31		cmp #$31	                CMP #'1'                ; If the character is '1'...
.3a5685	f0 0a		beq $3a5691	                BEQ shift_1             ; Shift a 1 onto ARGUMENT1
.3a5687	80 0f		bra $3a5698	                BRA done
.3a5689					shift_0
.3a5689	c2 20		rep #$20	            REP #$20
.3a568b	06 23		asl $0823	                ASL ARGUMENT1
.3a568d	26 25		rol $0825	                ROL ARGUMENT1+2
.3a568f	80 07		bra $3a5698	                BRA done
.3a5691					shift_1
.3a5691	c2 20		rep #$20	            REP #$20
.3a5693	38		sec		                SEC
.3a5694	26 23		rol $0823	                ROL ARGUMENT1
.3a5696	26 25		rol $0825	                ROL ARGUMENT1+2
.3a5698	28		plp		done            PLP
.3a5699	60		rts		            RTS
.3a569a					FP_POW10
.3a569a	08		php		                PHP
.3a569b	e2 30		sep #$30	            SEP #$30
.3a569d	a5 61		lda $0861	                LDA MARG4
.3a569f	f0 0d		beq $3a56ae	                BEQ return_1
.3a56a1	aa		tax		                TAX
.3a56a2	a5 69		lda $0869	                LDA MARG6
.3a56a4	d0 15		bne $3a56bb	                BNE do_div
.3a56a6	a9 00		lda #$00	                LDA #FP_OUT_MULT                    ; We'll multiply
.3a56a8	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a56ac	80 15		bra $3a56c3	                BRA start_loop
.3a56ae					return_1
.3a56ae	e2 20		sep #$20	            SEP #$20
.3a56b0	a9 03		lda #$03	                LDA #FP_OUT_ONE                     ; We want to return a 1.0
.3a56b2	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a56b6	ea		nop		                NOP
.3a56b7	ea		nop		                NOP
.3a56b8	ea		nop		                NOP
.3a56b9	80 62		bra $3a571d	                BRA ret_result                      ; And return the result
.3a56bb					do_div
.3a56bb	e2 20		sep #$20	            SEP #$20
.3a56bd	a9 01		lda #$01	                LDA #FP_OUT_DIV                     ; We'll divide
.3a56bf	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a56c3					start_loop
.3a56c3	e2 20		sep #$20	            SEP #$20
.3a56c5	a9 43		lda #$43	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.3a56c7	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.3a56cb	c2 20		rep #$20	            REP #$20
.3a56cd	a9 00 10	lda #$1000	                LDA #$1000                          ; Input 0 = 1.0
.3a56d0	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a56d4	a9 00 00	lda #$0000	                LDA #0
.3a56d7	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a56db					loop
.3a56db	c2 20		rep #$20	            REP #$20
.3a56dd	a9 00 a0	lda #$a000	                LDA #$A000                          ; Input 1 = 10.0
.3a56e0	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a56e4	a9 00 00	lda #$0000	                LDA #0
.3a56e7	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a56eb	ea		nop		                NOP                                 ; Wait for the operation to complete
.3a56ec	ea		nop		                NOP
.3a56ed	ea		nop		                NOP
.3a56ee	ca		dex		                DEX                                 ; Count down
.3a56ef	f0 2c		beq $3a571d	                BEQ ret_result                      ; If 0, then we're done
.3a56f1	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; SCRATCH <-- Result
.3a56f5	8f 0c 08 00	sta $00080c	                STA @l SCRATCH
.3a56f9	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a56fd	8f 0e 08 00	sta $00080e	                STA @l SCRATCH+2
.3a5701	e2 20		sep #$20	            SEP #$20
.3a5703	a9 42		lda #$42	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_1
.3a5705	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.3a5709	c2 20		rep #$20	            REP #$20
.3a570b	af 0c 08 00	lda $00080c	                LDA @l SCRATCH                      ; Input 0 <-- SCRATCH
.3a570f	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5713	af 0e 08 00	lda $00080e	                LDA @l SCRATCH+2
.3a5717	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a571b	80 be		bra $3a56db	                BRA loop
.3a571d					ret_result
.3a571d	c2 20		rep #$20	            REP #$20
.3a571f	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; Return the result
.3a5723	85 23		sta $0823	                STA ARGUMENT1
.3a5725	af 0a e2 af	lda $afe20a	                LDA FP_MATH_OUTPUT_FP_HL
.3a5729	85 25		sta $0825	                STA ARGUMENT1+2
.3a572b	e2 20		sep #$20	            SEP #$20
.3a572d	a9 01		lda #$01	                LDA #TYPE_FLOAT
.3a572f	85 27		sta $0827	                STA ARGTYPE1
.3a5731	28		plp		done            PLP
.3a5732	60		rts		            RTS
.3a5733					PACKFLOAT
.3a5733	08		php		                PHP
.3a5734	c2 20		rep #$20	            REP #$20
.3a5736	a5 5d		lda $085d	            LDA MARG3
.3a5738	85 23		sta $0823	            STA ARGUMENT1
.3a573a	a5 5f		lda $085f	            LDA MARG3+2
.3a573c	85 25		sta $0825	            STA ARGUMENT1+2
.3a573e	20 4c 59	jsr $3a594c	            JSR ITOF
.3a5741	c2 20		rep #$20	            REP #$20
.3a5743	a5 23		lda $0823	            LDA ARGUMENT1
.3a5745	85 29		sta $0829	            STA ARGUMENT2
.3a5747	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5749	85 2b		sta $082b	            STA ARGUMENT2+2
.3a574b	c2 20		rep #$20	            REP #$20
.3a574d	a5 59		lda $0859	            LDA MARG2
.3a574f	85 23		sta $0823	            STA ARGUMENT1
.3a5751	a5 5b		lda $085b	            LDA MARG2+2
.3a5753	85 25		sta $0825	            STA ARGUMENT1+2
.3a5755	20 74 54	jsr $3a5474	            JSR OP_FP_DIV
.3a5758	c2 20		rep #$20	            REP #$20
.3a575a	a5 55		lda $0855	            LDA MARG1
.3a575c	85 29		sta $0829	            STA ARGUMENT2
.3a575e	a5 57		lda $0857	            LDA MARG1+2
.3a5760	85 2b		sta $082b	            STA ARGUMENT2+2
.3a5762	20 29 54	jsr $3a5429	            JSR OP_FP_ADD
.3a5765	c2 20		rep #$20	            REP #$20
.3a5767	a5 23		lda $0823	            LDA ARGUMENT1
.3a5769	85 29		sta $0829	            STA ARGUMENT2
.3a576b	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a576d	85 2b		sta $082b	            STA ARGUMENT2+2
.3a576f	20 9a 56	jsr $3a569a	            JSR FP_POW10
.3a5772	20 bf 54	jsr $3a54bf	            JSR OP_FP_MUL
.3a5775	c2 20		rep #$20	            REP #$20
.3a5777	a5 65		lda $0865	                LDA MARG5                       ; Check to see if the float should be negative
.3a5779	f0 07		beq $3a5782	                BEQ set_float_type              ; If not, just set the type
.3a577b	a5 25		lda $0825	                LDA ARGUMENT1+2                 ; If so, set the sign bit
.3a577d	09 00 80	ora #$8000	                ORA #$8000
.3a5780	85 25		sta $0825	                STA ARGUMENT1+2
.3a5782					set_float_type
.3a5782	e2 20		sep #$20	            SEP #$20
.3a5784	a9 01		lda #$01	                LDA #TYPE_FLOAT                 ; Set the type to float... ready for returning!
.3a5786	85 27		sta $0827	                STA ARGTYPE1
.3a5788	28		plp		                PLP
.3a5789	60		rts		            RTS
.3a578a					PARSENUM
.3a578a	5a		phy		                PHY
.3a578b	08		php		                PHP
.3a578c	c2 30		rep #$30	            REP #$30
.3a578e	64 23		stz $0823	                STZ ARGUMENT1       ; This will be the accumulator for building the number
.3a5790	64 25		stz $0825	                STZ ARGUMENT1+2
.3a5792	64 55		stz $0855	                STZ MARG1           ; This will be the integer portion of the mantissa for floats
.3a5794	64 57		stz $0857	                STZ MARG1+2
.3a5796	64 65		stz $0865	                STZ MARG5           ; MARG5 will be the negative flag for the number
.3a5798	64 59		stz $0859	                STZ MARG2           ; This will be the denominator of the fractional part of the mantissa
.3a579a	64 5b		stz $085b	                STZ MARG2+2
.3a579c	a9 01 00	lda #$0001	                LDA #1
.3a579f	85 5d		sta $085d	                STA MARG3           ; This will be the divisor of the fractional part of the mantissa
.3a57a1	64 5f		stz $085f	                STZ MARG3+2
.3a57a3	64 61		stz $0861	                STZ MARG4           ; This will be the exponent of a float
.3a57a5	64 63		stz $0863	                STZ MARG4+2
.3a57a7	64 69		stz $0869	                STZ MARG6           ; MARG6 will be the negative flag for the exponent
.3a57a9					s0
.3a57a9	e2 20		sep #$20	            SEP #$20
.3a57ab	a0 00 00	ldy #$0000	                LDY #0
.3a57ae	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the first byte
.3a57b0	c9 2b		cmp #$2b	                CMP #'+'
.3a57b2	f0 33		beq $3a57e7	                BEQ s1_drop         ; '+' --> S1, drop
.3a57b4	c9 2d		cmp #$2d	                CMP #'-'
.3a57b6	f0 2b		beq $3a57e3	                BEQ s1_negative     ; Flag that the number is negative
.3a57b8	c9 26		cmp #$26	                CMP #'&'
.3a57ba	f0 3a		beq $3a57f6	                BEQ s2_drop         ; '&' --> S2, drop
.3a57bc	20 ad 03	jsr $3a03ad	            JSR ISNUMERAL
.3a57bf	90 03		bcc $3a57c4	                BCC syntax_err
.3a57c1	82 ac 00	brl $3a5870	                BRL s7_shift        ; '0'-'9' --> S7, emit
.3a57c4					syntax_err
.3a57c4	08		php		            PHP
.3a57c5	c2 20		rep #$20	            REP #$20
.3a57c7	48		pha		            PHA
.3a57c8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a57cb	5b		tcd		            TCD
.3a57cc	68		pla		            PLA
.3a57cd	28		plp		            PLP
.3a57ce	e2 20		sep #$20	            SEP #$20
.3a57d0	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a57d2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a57d6	c2 20		rep #$20	            REP #$20
.3a57d8	29 ff 00	and #$00ff	            AND #$00FF
.3a57db	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a57de	e2 20		sep #$20	            SEP #$20
.3a57e0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a57e3	a9 01		lda #$01	s1_negative     LDA #1              ; Set the negative flag for the mantissa
.3a57e5	85 65		sta $0865	                STA MARG5
.3a57e7	c8		iny		s1_drop         INY                 ; Drop the character...
.3a57e8	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next
.3a57ea	c9 26		cmp #$26	                CMP #'&'
.3a57ec	f0 08		beq $3a57f6	                BEQ s2_drop         ; '&' --> S2, drop the '&'
.3a57ee	20 ad 03	jsr $3a03ad	            JSR ISNUMERAL
.3a57f1	90 d1		bcc $3a57c4	                BCC syntax_err
.3a57f3	82 7a 00	brl $3a5870	                BRL s7_shift        ; '0'-'9' --> S7, shift
.3a57f6	c8		iny		s2_drop         INY                 ; Drop the character
.3a57f7	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.3a57f9	c9 68		cmp #$68	                CMP #'h'
.3a57fb	f0 0e		beq $3a580b	                BEQ s3_drop         ; 'h', 'H' --> S3, drop
.3a57fd	c9 48		cmp #$48	                CMP #'H'
.3a57ff	f0 0a		beq $3a580b	                BEQ s3_drop
.3a5801	c9 62		cmp #$62	                CMP #'b'
.3a5803	f0 4c		beq $3a5851	                BEQ s5_drop         ; 'b', 'B' --> S5, drop
.3a5805	c9 42		cmp #$42	                CMP #'B'
.3a5807	f0 48		beq $3a5851	                BEQ s5_drop
.3a5809	80 b9		bra $3a57c4	                BRA syntax_err
.3a580b	c8		iny		s3_drop         INY                 ; Drop the character
.3a580c	b7 00		lda [$0800],y	s3              LDA [BIP],Y         ; Get the next character
.3a580e	20 be 03	jsr $3a03be	            JSR ISHEX
.3a5811	b0 02		bcs $3a5815	                BCS s4_shift
.3a5813	80 af		bra $3a57c4	                BRA syntax_err
.3a5815					s4_shift
.3a5815	20 2c 56	jsr $3a562c	            JSR SHIFTHEX
.3a5818	c8		iny		                INY
.3a5819	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.3a581b	20 be 03	jsr $3a03be	            JSR ISHEX
.3a581e	b0 f5		bcs $3a5815	                BCS s4_shift        ; '0'-'9','A'-'F' --> S4, shift
.3a5820					ret_integer
.3a5820	e2 20		sep #$20	            SEP #$20
.3a5822	a5 65		lda $0865	                LDA MARG5           ; check if the number should be negative
.3a5824	f0 11		beq $3a5837	                BEQ set_int_type    ; If not, just set the type and return
.3a5826	c2 20		rep #$20	            REP #$20
.3a5828	38		sec		                SEC                 ; If so, negate it
.3a5829	a9 00 00	lda #$0000	                LDA #0
.3a582c	e5 23		sbc $0823	                SBC ARGUMENT1
.3a582e	85 23		sta $0823	                STA ARGUMENT1
.3a5830	a9 00 00	lda #$0000	                LDA #0
.3a5833	e5 25		sbc $0825	                SBC ARGUMENT1+2
.3a5835	85 25		sta $0825	                STA ARGUMENT1+2
.3a5837					set_int_type
.3a5837	e2 20		sep #$20	            SEP #$20
.3a5839	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; Return an integer
.3a583b	85 27		sta $0827	                STA ARGTYPE1
.3a583d					stop
.3a583d	c2 20		rep #$20	            REP #$20
.3a583f	18		clc		                CLC
.3a5840	98		tya		                TYA
.3a5841	65 00		adc $0800	                ADC BIP
.3a5843	85 00		sta $0800	                STA BIP
.3a5845	a5 02		lda $0802	                LDA BIP+2
.3a5847	69 00 00	adc #$0000	                ADC #0
.3a584a	85 02		sta $0802	                STA BIP+2
.3a584c	e2 20		sep #$20	            SEP #$20
.3a584e	28		plp		                PLP
.3a584f	7a		ply		                PLY
.3a5850	60		rts		            RTS
.3a5851	c8		iny		s5_drop         INY                     ; Drop the character
.3a5852	b7 00		lda [$0800],y	s5              LDA [BIP],Y             ; Get the next character
.3a5854	c9 30		cmp #$30	                CMP #'0'
.3a5856	f0 07		beq $3a585f	                BEQ s6_shift            ; '0', '1' --> S6, shift
.3a5858	c9 31		cmp #$31	                CMP #'1'
.3a585a	f0 03		beq $3a585f	                BEQ s6_shift
.3a585c	82 65 ff	brl $3a57c4	                BRL syntax_err
.3a585f					s6_shift
.3a585f	20 7c 56	jsr $3a567c	            JSR SHIFTBIN
.3a5862	c8		iny		                INY
.3a5863	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a5865	c9 30		cmp #$30	                CMP #'0'                ; '0', '1' --> S6, shift
.3a5867	f0 f6		beq $3a585f	                BEQ s6_shift
.3a5869	c9 31		cmp #$31	                CMP #'1'
.3a586b	f0 f2		beq $3a585f	                BEQ s6_shift
.3a586d	82 b0 ff	brl $3a5820	                BRL ret_integer         ; Return integer
.3a5870					s7_shift
.3a5870	20 10 56	jsr $3a5610	            JSR SHIFTDEC
.3a5873	c8		iny		                INY
.3a5874	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a5876	c9 2e		cmp #$2e	                CMP #'.'                ; '.' --> S8, drop and preserve mantissa
.3a5878	f0 08		beq $3a5882	                BEQ s8_mantissa
.3a587a	20 ad 03	jsr $3a03ad	            JSR ISNUMERAL
.3a587d	b0 f1		bcs $3a5870	                BCS s7_shift
.3a587f	82 9e ff	brl $3a5820	                BRL ret_integer         ; Return integer
.3a5882					s8_mantissa
.3a5882	c2 20		rep #$20	            REP #$20
.3a5884	20 4c 59	jsr $3a594c	            JSR ITOF
.3a5887	c2 20		rep #$20	            REP #$20
.3a5889	a5 23		lda $0823	            LDA ARGUMENT1
.3a588b	85 55		sta $0855	            STA MARG1
.3a588d	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a588f	85 57		sta $0857	            STA MARG1+2
.3a5891	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the decimal
.3a5893	64 25		stz $0825	                STZ ARGUMENT1+2
.3a5895	e2 20		sep #$20	            SEP #$20
.3a5897	80 36		bra $3a58cf	                BRA s8_drop
.3a5899					s8_shift
.3a5899	20 10 56	jsr $3a5610	            JSR SHIFTDEC
.3a589c	c2 20		rep #$20	            REP #$20
.3a589e	a5 5f		lda $085f	                LDA MARG3+2             ; high 16 bits
.3a58a0	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.3a58a4	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.3a58a7	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.3a58ab	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to high 16 bits of MARG3
.3a58af	85 5f		sta $085f	                STA MARG3+2
.3a58b1	a5 5d		lda $085d	                LDA MARG3
.3a58b3	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.3a58b7	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.3a58ba	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.3a58be	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to MARG3
.3a58c2	85 5d		sta $085d	                STA MARG3
.3a58c4	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.3a58c8	18		clc		                CLC
.3a58c9	65 5f		adc $085f	                ADC MARG3+2
.3a58cb	85 5f		sta $085f	                STA MARG3+2
.3a58cd	e2 20		sep #$20	            SEP #$20
.3a58cf					s8_drop
.3a58cf	c8		iny		                INY
.3a58d0	b7 00		lda [$0800],y	                LDA [BIP],Y
.3a58d2	c9 65		cmp #$65	                CMP #'e'                ; 'E' --> S9, drop
.3a58d4	f0 24		beq $3a58fa	                BEQ s9_drop
.3a58d6	c9 45		cmp #$45	                CMP #'E'
.3a58d8	f0 20		beq $3a58fa	                BEQ s9_drop
.3a58da	20 ad 03	jsr $3a03ad	            JSR ISNUMERAL
.3a58dd	b0 ba		bcs $3a5899	                BCS s8_shift
.3a58df	c2 20		rep #$20	            REP #$20
.3a58e1	20 4c 59	jsr $3a594c	            JSR ITOF
.3a58e4	c2 20		rep #$20	            REP #$20
.3a58e6	a5 23		lda $0823	            LDA ARGUMENT1
.3a58e8	85 59		sta $0859	            STA MARG2
.3a58ea	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a58ec	85 5b		sta $085b	            STA MARG2+2
.3a58ee	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.3a58f0	64 25		stz $0825	                STZ ARGUMENT1+2
.3a58f2	20 33 57	jsr $3a5733	            JSR PACKFLOAT
.3a58f5	e2 20		sep #$20	            SEP #$20
.3a58f7	82 43 ff	brl $3a583d	                BRL stop
.3a58fa					s9_drop
.3a58fa	c2 20		rep #$20	            REP #$20
.3a58fc	20 4c 59	jsr $3a594c	            JSR ITOF
.3a58ff	c2 20		rep #$20	            REP #$20
.3a5901	a5 23		lda $0823	            LDA ARGUMENT1
.3a5903	85 59		sta $0859	            STA MARG2
.3a5905	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5907	85 5b		sta $085b	            STA MARG2+2
.3a5909	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.3a590b	64 25		stz $0825	                STZ ARGUMENT1+2
.3a590d	e2 20		sep #$20	            SEP #$20
.3a590f	c8		iny		                INY
.3a5910	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a5912	c9 2b		cmp #$2b	                CMP #'+'
.3a5914	f0 10		beq $3a5926	                BEQ s10_drop            ; '+' --> S10, drop
.3a5916	c9 2d		cmp #$2d	                CMP #'-'
.3a5918	f0 08		beq $3a5922	                BEQ s10_setneg          ; '-' --> S10, set exponent is negative
.3a591a	20 ad 03	jsr $3a03ad	            JSR ISNUMERAL
.3a591d	b0 12		bcs $3a5931	                BCS S11_shift           ; '0'-'9' --> S11, shift
.3a591f	82 a2 fe	brl $3a57c4	                BRL syntax_err
.3a5922					s10_setneg
.3a5922	a9 01		lda #$01	                LDA #1                  ; Set that the exponent should be negative
.3a5924	85 69		sta $0869	                STA MARG6
.3a5926					s10_drop
.3a5926	c8		iny		                INY
.3a5927	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a5929	20 ad 03	jsr $3a03ad	            JSR ISNUMERAL
.3a592c	b0 03		bcs $3a5931	                BCS s11_shift
.3a592e	82 93 fe	brl $3a57c4	                BRL syntax_err
.3a5931					s11_shift
.3a5931	20 10 56	jsr $3a5610	            JSR SHIFTDEC
.3a5934	c8		iny		                INY
.3a5935	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a5937	20 ad 03	jsr $3a03ad	            JSR ISNUMERAL
.3a593a	b0 f5		bcs $3a5931	                BCS s11_shift
.3a593c	c2 20		rep #$20	            REP #$20
.3a593e	a5 23		lda $0823	            LDA ARGUMENT1
.3a5940	85 61		sta $0861	            STA MARG4
.3a5942	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5944	85 63		sta $0863	            STA MARG4+2
.3a5946	20 33 57	jsr $3a5733	            JSR PACKFLOAT
.3a5949	82 f1 fe	brl $3a583d	                BRL stop
.3a594c					ITOF
.3a594c	08		php		                PHP
.3a594d	20 da 53	jsr $3a53da	            JSR FIXINT_TO_FP
.3a5950	28		plp		done            PLP
.3a5951	60		rts		            RTS
.3a5952					FTOI
.3a5952	08		php		                PHP
.3a5953					LOCALS
>0001					l_sign          .byte ?
>0002					l_exponent      .byte ?
>0003					l_mantissa      .dword ?
.3a5953	c2 20		rep #$20	            REP #$20
.3a5955	a9 49 5c	lda #$5c49	                LDA #<>FP_1_0
.3a5958	85 29		sta $0829	                STA ARGUMENT2
.3a595a	a9 3a 00	lda #$003a	                LDA #(FP_1_0 >> 16)
.3a595d	85 2b		sta $082b	                STA ARGUMENT2+2
.3a595f	e2 20		sep #$20	            SEP #$20
.3a5961	a9 01		lda #$01	                LDA #TYPE_FLOAT
.3a5963	85 2d		sta $082d	                STA ARGTYPE2
.3a5965	c2 20		rep #$20	            REP #$20
.3a5967	20 25 5a	jsr $3a5a25	            JSR FP_COMPARE
.3a596a	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.3a596d	d0 0c		bne $3a597b	                BNE alloc_locals        ; No: get ready to do the full conversion
.3a596f	a9 00 00	lda #$0000	                LDA #0
.3a5972	8d 23 08	sta $0823	                STA @w ARGUMENT1        ; Yes: Return 0
.3a5975	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.3a5978	82 a1 00	brl $3a5a1c	                BRL done
.3a597b	f4 00 00	pea #$0000	alloc_locals    PEA #0                  ; Reserve space for the locals
.3a597e	f4 00 00	pea #$0000	                PEA #0
.3a5981	f4 00 00	pea #$0000	                PEA #0
.3a5984	e2 20		sep #$20	            SEP #$20
.3a5986	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3      ; Preserve the sign bit
.3a5989	29 80		and #$80	                AND #$80
.3a598b	83 01		sta $01,s	                STA l_sign
.3a598d	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2      ; Preserve the exponent
.3a5990	2a		rol a		                ROL A
.3a5991	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3
.3a5994	2a		rol a		                ROL A
.3a5995	83 02		sta $02,s	                STA l_exponent
.3a5997	a9 00		lda #$00	save_mantissa   LDA #0                  ; Save the mantissa (with the implied 1)
.3a5999	83 06		sta $06,s	                STA l_mantissa+3
.3a599b	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2
.3a599e	09 80		ora #$80	                ORA #$80
.3a59a0	83 05		sta $05,s	                STA l_mantissa+2
.3a59a2	ad 24 08	lda $0824	                LDA @w ARGUMENT1+1
.3a59a5	83 04		sta $04,s	                STA l_mantissa+1
.3a59a7	ad 23 08	lda $0823	                LDA @w ARGUMENT1
.3a59aa	83 03		sta $03,s	                STA l_mantissa
.3a59ac	a3 02		lda $02,s	                LDA l_exponent
.3a59ae	c9 96		cmp #$96	loop            CMP #150
.3a59b0	f0 3a		beq $3a59ec	                BEQ adj_sign
.3a59b2	90 1f		bcc $3a59d3	                BLT shift_right
.3a59b4	08		php		            PHP
.3a59b5	c2 20		rep #$20	            REP #$20
.3a59b7	48		pha		            PHA
.3a59b8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a59bb	5b		tcd		            TCD
.3a59bc	68		pla		            PLA
.3a59bd	28		plp		            PLP
.3a59be	e2 20		sep #$20	            SEP #$20
.3a59c0	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.3a59c2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a59c6	c2 20		rep #$20	            REP #$20
.3a59c8	29 ff 00	and #$00ff	            AND #$00FF
.3a59cb	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a59ce	e2 20		sep #$20	            SEP #$20
.3a59d0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a59d3					shift_right
.3a59d3	c2 20		rep #$20	            REP #$20
.3a59d5	a3 05		lda $05,s	                LDA l_mantissa+2
.3a59d7	4a		lsr a		                LSR A
.3a59d8	83 05		sta $05,s	                STA l_mantissa+2
.3a59da	a3 03		lda $03,s	                LDA l_mantissa
.3a59dc	6a		ror a		                ROR A
.3a59dd	83 03		sta $03,s	                STA l_mantissa
.3a59df	e2 20		sep #$20	            SEP #$20
.3a59e1	a3 02		lda $02,s	                LDA l_exponent
.3a59e3	1a		inc a		                INC A
.3a59e4	83 02		sta $02,s	                STA l_exponent
.3a59e6	c9 96		cmp #$96	                CMP #150
.3a59e8	f0 02		beq $3a59ec	                BEQ adj_sign
.3a59ea	80 e7		bra $3a59d3	                BRA shift_right
.3a59ec	a3 01		lda $01,s	adj_sign        LDA l_sign
.3a59ee	f0 1b		beq $3a5a0b	                BEQ ret_positive
.3a59f0	c2 20		rep #$20	            REP #$20
.3a59f2	a3 03		lda $03,s	                LDA l_mantissa
.3a59f4	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a59f7	18		clc		                CLC
.3a59f8	69 01 00	adc #$0001	                ADC #1
.3a59fb	8d 23 08	sta $0823	                STA @w ARGUMENT1
.3a59fe	a3 05		lda $05,s	                LDA l_mantissa+2
.3a5a00	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a5a03	69 00 00	adc #$0000	                ADC #0
.3a5a06	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.3a5a09	80 0c		bra $3a5a17	                BRA clean
.3a5a0b					ret_positive
.3a5a0b	c2 20		rep #$20	            REP #$20
.3a5a0d	a3 03		lda $03,s	                LDA l_mantissa
.3a5a0f	8d 23 08	sta $0823	                STA @w ARGUMENT1
.3a5a12	a3 05		lda $05,s	                LDA l_mantissa+2
.3a5a14	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.3a5a17					clean
.3a5a17	c2 20		rep #$20	            REP #$20
.3a5a19	68		pla		                PLA                     ; Clean up the locals
.3a5a1a	68		pla		                PLA
.3a5a1b	68		pla		                PLA
.3a5a1c					done
.3a5a1c	e2 20		sep #$20	            SEP #$20
.3a5a1e	a9 00		lda #$00	                LDA #TYPE_INTEGER       ; Set the return type to integer
.3a5a20	8d 27 08	sta $0827	                STA @w ARGTYPE1
.3a5a23	28		plp		                PLP
.3a5a24	60		rts		            RTS
.3a5a25					FP_COMPARE
.3a5a25	da		phx		                PHX
.3a5a26	08		php		                PHP
.3a5a27	c2 20		rep #$20	            REP #$20
.3a5a29	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save ARGUMENT1 so we don't destroy it
.3a5a2b	48		pha		                PHA
.3a5a2c	a5 23		lda $0823	                LDA ARGUMENT1
.3a5a2e	48		pha		                PHA
.3a5a2f	20 1e 54	jsr $3a541e	            JSR OP_FP_SUB
.3a5a32	20 fc 55	jsr $3a55fc	            JSR FARG1EQ0
.3a5a35	b0 11		bcs $3a5a48	                BCS are_equal
.3a5a37	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Check the high word
.3a5a39	89 00 80	bit #$8000	                BIT #$8000
.3a5a3c	d0 05		bne $3a5a43	                BNE is_lt                   ; ARGUMENT1 < ARGUMENT2
.3a5a3e	a9 01 00	lda #$0001	is_gt           LDA #1                      ; ARGUMENT1 > ARGUMENT2: return 1
.3a5a41	80 08		bra $3a5a4b	                BRA ret_result
.3a5a43	a9 ff ff	lda #$ffff	is_lt           LDA #$FFFF                  ; ARGUMENT1 > ARGUMENT2: return -1
.3a5a46	80 03		bra $3a5a4b	                BRA ret_result
.3a5a48	a9 00 00	lda #$0000	are_equal       LDA #0                      ; Equal: return 0
.3a5a4b	fa		plx		ret_result      PLX                         ; Restore ARGUMENT1
.3a5a4c	86 23		stx $0823	                STX ARGUMENT1
.3a5a4e	fa		plx		                PLX
.3a5a4f	86 25		stx $0825	                STX ARGUMENT1+2
.3a5a51	28		plp		                PLP
.3a5a52	fa		plx		                PLX
.3a5a53	60		rts		            RTS
.3a5a54					OP_FP_LT
.3a5a54	08		php		                PHP
.3a5a55	c2 30		rep #$30	            REP #$30
.3a5a57	20 25 5a	jsr $3a5a25	            JSR FP_COMPARE
.3a5a5a	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.3a5a5d	d0 05		bne $3a5a64	                BNE ret_false
.3a5a5f	20 df 04	jsr $3a04df	            JSR SET_TRUE
.3a5a62	80 03		bra $3a5a67	                BRA done
.3a5a64					ret_false
.3a5a64	20 f1 04	jsr $3a04f1	            JSR SET_FALSE
.3a5a67	28		plp		done            PLP
.3a5a68	60		rts		            RTS
.3a5a69					OP_FP_GT
.3a5a69	08		php		                PHP
.3a5a6a	c2 30		rep #$30	            REP #$30
.3a5a6c	20 25 5a	jsr $3a5a25	            JSR FP_COMPARE
.3a5a6f	c9 01 00	cmp #$0001	                CMP #1
.3a5a72	d0 05		bne $3a5a79	                BNE ret_false
.3a5a74	20 df 04	jsr $3a04df	            JSR SET_TRUE
.3a5a77	80 03		bra $3a5a7c	                BRA done
.3a5a79					ret_false
.3a5a79	20 f1 04	jsr $3a04f1	            JSR SET_FALSE
.3a5a7c	28		plp		done            PLP
.3a5a7d	60		rts		            RTS
.3a5a7e					OP_FP_EQ
.3a5a7e	08		php		                PHP
.3a5a7f	c2 30		rep #$30	            REP #$30
.3a5a81	20 25 5a	jsr $3a5a25	            JSR FP_COMPARE
.3a5a84	c9 00 00	cmp #$0000	                CMP #0
.3a5a87	d0 05		bne $3a5a8e	                BNE ret_false
.3a5a89	20 df 04	jsr $3a04df	            JSR SET_TRUE
.3a5a8c	80 03		bra $3a5a91	                BRA done
.3a5a8e					ret_false
.3a5a8e	20 f1 04	jsr $3a04f1	            JSR SET_FALSE
.3a5a91	28		plp		done            PLP
.3a5a92	60		rts		            RTS
.3a5a93					OP_FP_LTE
.3a5a93	08		php		                PHP
.3a5a94	c2 30		rep #$30	            REP #$30
.3a5a96	20 25 5a	jsr $3a5a25	            JSR FP_COMPARE
.3a5a99	c9 01 00	cmp #$0001	                CMP #1
.3a5a9c	f0 05		beq $3a5aa3	                BEQ ret_false
.3a5a9e	20 df 04	jsr $3a04df	            JSR SET_TRUE
.3a5aa1	80 03		bra $3a5aa6	                BRA done
.3a5aa3					ret_false
.3a5aa3	20 f1 04	jsr $3a04f1	            JSR SET_FALSE
.3a5aa6	28		plp		done            PLP
.3a5aa7	60		rts		            RTS
.3a5aa8					OP_FP_GTE
.3a5aa8	08		php		                PHP
.3a5aa9	c2 30		rep #$30	            REP #$30
.3a5aab	20 25 5a	jsr $3a5a25	            JSR FP_COMPARE
.3a5aae	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.3a5ab1	f0 05		beq $3a5ab8	                BEQ ret_false
.3a5ab3	20 df 04	jsr $3a04df	            JSR SET_TRUE
.3a5ab6	80 03		bra $3a5abb	                BRA done
.3a5ab8					ret_false
.3a5ab8	20 f1 04	jsr $3a04f1	            JSR SET_FALSE
.3a5abb	28		plp		done            PLP
.3a5abc	60		rts		            RTS
.3a5abd					OP_FP_NE
.3a5abd	08		php		                PHP
.3a5abe	c2 30		rep #$30	            REP #$30
.3a5ac0	20 25 5a	jsr $3a5a25	            JSR FP_COMPARE
.3a5ac3	c9 00 00	cmp #$0000	                CMP #0
.3a5ac6	f0 05		beq $3a5acd	                BEQ ret_false
.3a5ac8	20 df 04	jsr $3a04df	            JSR SET_TRUE
.3a5acb	80 03		bra $3a5ad0	                BRA done
.3a5acd					ret_false
.3a5acd	20 f1 04	jsr $3a04f1	            JSR SET_FALSE
.3a5ad0	28		plp		done            PLP
.3a5ad1	60		rts		            RTS
.3a5ad2					STREMIT
.3a5ad2	08		php		                PHP
.3a5ad3	e2 20		sep #$20	            SEP #$20
.3a5ad5	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Append the character
.3a5ad7	c8		iny		                INY                         ; Advance the character pointer in Y
.3a5ad8	a9 00		lda #$00	                LDA #0                      ; And add the NULL
.3a5ada	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.3a5adc	28		plp		                PLP
.3a5add	60		rts		            RTS
.3a5ade					STREMITB
.3a5ade	da		phx		                PHX
.3a5adf	08		php		                PHP
.3a5ae0	e2 20		sep #$20	            SEP #$20
.3a5ae2	c9 80		cmp #$80	                CMP #$80
.3a5ae4	90 0a		bcc $3a5af0	                BLT emit_digits
.3a5ae6	48		pha		                PHA
.3a5ae7	a9 2d		lda #$2d	                LDA #'-'                    ; Print a minus sign
.3a5ae9	20 d2 5a	jsr $3a5ad2	            JSR STREMIT
.3a5aec	68		pla		                PLA
.3a5aed	49 ff		eor #$ff	                EOR #$FF                    ; And negate it
.3a5aef	1a		inc a		                INC A
.3a5af0					emit_digits
.3a5af0	c2 30		rep #$30	            REP #$30
.3a5af2	29 ff 00	and #$00ff	                AND #$00FF
.3a5af5	c9 64 00	cmp #$0064	                CMP #100
.3a5af8	90 0e		bcc $3a5b08	                BLT chk_tens
.3a5afa	a2 64 00	ldx #$0064	                LDX #100
.3a5afd	20 c3 53	jsr $3a53c3	            JSR UINT_DIV_A_X
.3a5b00	18		clc		                CLC
.3a5b01	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.3a5b04	20 d2 5a	jsr $3a5ad2	            JSR STREMIT
.3a5b07	8a		txa		                TXA                         ; Put the remainder in A
.3a5b08					chk_tens
.3a5b08	a2 0a 00	ldx #$000a	                LDX #10
.3a5b0b	20 c3 53	jsr $3a53c3	            JSR UINT_DIV_A_X
.3a5b0e	18		clc		                CLC
.3a5b0f	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.3a5b12	20 d2 5a	jsr $3a5ad2	            JSR STREMIT
.3a5b15	8a		txa		                TXA                         ; Put the remainder in A
.3a5b16					ones_digit
.3a5b16	18		clc		                CLC
.3a5b17	69 30 00	adc #$0030	                ADC #'0'                    ; Convert it to ASCII
.3a5b1a	20 d2 5a	jsr $3a5ad2	            JSR STREMIT
.3a5b1d	28		plp		                PLP
.3a5b1e	fa		plx		                PLX
.3a5b1f	60		rts		            RTS
.3a5b20					STRFINDEND
.3a5b20	08		php		                PHP
.3a5b21	e2 20		sep #$20	            SEP #$20
.3a5b23	c2 10		rep #$10	            REP #$10
.3a5b25	a0 00 00	ldy #$0000	                LDY #0
.3a5b28	b7 23		lda [$0823],y	find_end        LDA [ARGUMENT1],Y           ; Scan to the end of the string
.3a5b2a	f0 03		beq $3a5b2f	                BEQ done
.3a5b2c	c8		iny		                INY
.3a5b2d	80 f9		bra $3a5b28	                BRA find_end
.3a5b2f	28		plp		done            PLP
.3a5b30	60		rts		            RTS
=6					FP_D = 6        ; Number of mantissa digits
.3a5b31					FTOS
.3a5b31	08		php		                PHP
.3a5b32	e2 20		sep #$20	            SEP #$20
.3a5b34	c2 10		rep #$10	            REP #$10
.3a5b36	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be the negative flag
.3a5b39	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be K
.3a5b3c	f4 00 00	pea #$0000	                PEA #0                      ; This spot will be for the exponents
>0001					L_NEGATIVE      .word ?
>0003					L_K             .word ?
>0005					L_X1            .byte ?                     ; The binary exponent
>0006					L_EXP           .byte ?                     ; The decimal exponent
.3a5b3f	20 fc 55	jsr $3a55fc	            JSR FARG1EQ0
.3a5b42	90 19		bcc $3a5b5d	                BCC chk_negative
.3a5b44	20 ae 13	jsr $3a13ae	            JSR TEMPSTRING
.3a5b47	e2 20		sep #$20	            SEP #$20
.3a5b49	a0 00 00	ldy #$0000	                LDY #0
.3a5b4c	a9 20		lda #$20	                LDA #' '
.3a5b4e	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a5b50	c8		iny		                INY
.3a5b51	a9 30		lda #$30	                LDA #'0'                    ; Return a "0"
.3a5b53	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a5b55	c8		iny		                INY
.3a5b56	a9 00		lda #$00	                LDA #0
.3a5b58	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a5b5a	82 ce 00	brl $3a5c2b	                BRL ret_result
.3a5b5d					chk_negative
.3a5b5d	e2 20		sep #$20	            SEP #$20
.3a5b5f	a5 26		lda $0826	                LDA ARGUMENT1+3             ; If N is negative, output a minus sign and negate N
.3a5b61	10 08		bpl $3a5b6b	                BPL not_negative
.3a5b63	29 7f		and #$7f	                AND #$7F                    ; Negate the number
.3a5b65	85 26		sta $0826	                STA ARGUMENT1+3
.3a5b67	a9 01		lda #$01	                LDA #1
.3a5b69	83 01		sta $01,s	                STA L_NEGATIVE              ; Set IsNegative to a TRUE value
.3a5b6b					not_negative
.3a5b6b	c2 20		rep #$20	            REP #$20
.3a5b6d	a9 00 00	lda #$0000	                LDA #0                      ; Initialize K to 0, K is a 1-byte signed integer. (SCRATCH is K)
.3a5b70	83 03		sta $03,s	                STA L_K                     ; We're using a word here for convenience
.3a5b72	c2 20		rep #$20	            REP #$20
.3a5b74	af 45 5c 3a	lda $3a5c45	            LDA ten_d_1
.3a5b78	85 29		sta $0829	            STA ARGUMENT2
.3a5b7a	af 47 5c 3a	lda $3a5c47	            LDA ten_d_1+2
.3a5b7e	85 2b		sta $082b	            STA ARGUMENT2+2
.3a5b80	20 25 5a	jsr $3a5a25	            JSR FP_COMPARE
.3a5b83	89 00 80	bit #$8000	                BIT #$8000                  ; Is N < 10^(D-1)?
.3a5b86	d0 12		bne $3a5b9a	                BNE shift_up
.3a5b88					shift_down
.3a5b88	20 c0 55	jsr $3a55c0	            JSR FP_DIV10
.3a5b8b	a3 03		lda $03,s	                LDA L_K
.3a5b8d	1a		inc a		                INC A
.3a5b8e	83 03		sta $03,s	                STA L_K                     ; Increment K
.3a5b90	20 25 5a	jsr $3a5a25	            JSR FP_COMPARE
.3a5b93	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N < 10^(D-1)?
.3a5b96	f0 12		beq $3a5baa	                BEQ do_digits               ; Yes: we're ready to process digits
.3a5b98	80 ee		bra $3a5b88	                BRA shift_down              ; No: keep dividing
.3a5b9a					shift_up
.3a5b9a	20 77 55	jsr $3a5577	            JSR FP_MUL10
.3a5b9d	a3 03		lda $03,s	                LDA L_K
.3a5b9f	3a		dec a		                DEC A
.3a5ba0	83 03		sta $03,s	                STA L_K                     ; Decrement K
.3a5ba2	20 25 5a	jsr $3a5a25	            JSR FP_COMPARE
.3a5ba5	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N >= 10 ^ (D-1)?
.3a5ba8	f0 f0		beq $3a5b9a	                BEQ shift_up                ; No: keep multiplying
.3a5baa					do_digits
.3a5baa	e2 30		sep #$30	            SEP #$30
.3a5bac	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5bae	0a		asl a		                ASL A
.3a5baf	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a5bb1	2a		rol a		                ROL A
.3a5bb2	83 05		sta $05,s	                STA L_X1
.3a5bb4	38		sec		                SEC
.3a5bb5	a9 96		lda #$96	                LDA #150                    ; X := 150 - X1
.3a5bb7	e3 05		sbc $05,s	                SBC L_X1
.3a5bb9	aa		tax		                TAX
.3a5bba	f0 0f		beq $3a5bcb	                BEQ emit_digits             ; If X = 0, just emit the digits
.3a5bbc	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Set the implied '1' MSB of the mantissa
.3a5bbe	09 80		ora #$80	                ORA #$80
.3a5bc0	85 25		sta $0825	                STA ARGUMENT1+2
.3a5bc2	46 25		lsr $0825	shift_r         LSR ARGUMENT1+2             ; Shift the mantissa right
.3a5bc4	66 24		ror $0824	                ROR ARGUMENT1+1
.3a5bc6	66 23		ror $0823	                ROR ARGUMENT1
.3a5bc8	ca		dex		                DEX
.3a5bc9	d0 f7		bne $3a5bc2	                BNE shift_r                 ; Until X = 0
.3a5bcb					emit_digits
.3a5bcb	c2 10		rep #$10	            REP #$10
.3a5bcd	e2 20		sep #$20	            SEP #$20
.3a5bcf	64 26		stz $0826	                STZ ARGUMENT1+3             ; Blank out the MSB
.3a5bd1	a9 00		lda #$00	                LDA #TYPE_INTEGER           ; Make it an integer
.3a5bd3	85 27		sta $0827	                STA ARGTYPE1
.3a5bd5	a3 01		lda $01,s	                LDA L_NEGATIVE              ; Check IsNegative
.3a5bd7	f0 11		beq $3a5bea	                BEQ get_raw_digits          ; If FALSE, just convert the raw digits
.3a5bd9	c2 20		rep #$20	            REP #$20
.3a5bdb	38		sec		                SEC                         ; Make the raw integer negative
.3a5bdc	a9 00 00	lda #$0000	                LDA #0
.3a5bdf	e5 23		sbc $0823	                SBC ARGUMENT1
.3a5be1	85 23		sta $0823	                STA ARGUMENT1
.3a5be3	a9 00 00	lda #$0000	                LDA #0
.3a5be6	e5 25		sbc $0825	                SBC ARGUMENT1+2
.3a5be8	85 25		sta $0825	                STA ARGUMENT1+2
.3a5bea					get_raw_digits
.3a5bea	20 0d 14	jsr $3a140d	            JSR ITOS
.3a5bed	c2 20		rep #$20	            REP #$20
.3a5bef	a5 16		lda $0816	            LDA STRPTR
.3a5bf1	85 23		sta $0823	            STA ARGUMENT1
.3a5bf3	a5 18		lda $0818	            LDA STRPTR+2
.3a5bf5	85 25		sta $0825	            STA ARGUMENT1+2
.3a5bf7	20 20 5b	jsr $3a5b20	            JSR STRFINDEND
.3a5bfa	e2 20		sep #$20	            SEP #$20
.3a5bfc	c8		iny		                INY                         ; Move the NULL up one byte
.3a5bfd	a9 00		lda #$00	                LDA #0
.3a5bff	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.3a5c01	88		dey		insert_loop     DEY                         ; Move to the character before the one we just moved
.3a5c02	88		dey		                DEY
.3a5c03	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y           ; Get the character
.3a5c05	c8		iny		                INY                         ; Move to the next space
.3a5c06	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Store the character here
.3a5c08	c0 02 00	cpy #$0002	                CPY #2                      ; Check to see if we just moved the 2nd character
.3a5c0b	d0 f4		bne $3a5c01	                BNE insert_loop             ; If not, keep moving the characters
.3a5c0d	a9 2e		lda #$2e	                LDA #'.'                    ; Insert the '.' in the space we openned
.3a5c0f	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.3a5c11	e2 20		sep #$20	            SEP #$20
.3a5c13	18		clc		                CLC                         ; Compute the exponent
.3a5c14	a3 03		lda $03,s	                LDA L_K
.3a5c16	69 05		adc #$05	                ADC #(FP_D - 1)
.3a5c18	83 06		sta $06,s	                STA L_EXP
.3a5c1a	f0 19		beq $3a5c35	                BEQ done                    ; If it's 0, just return the number
.3a5c1c	20 20 5b	jsr $3a5b20	            JSR STRFINDEND
.3a5c1f	a9 45		lda #$45	                LDA #'E'                    ; Append the "E"
.3a5c21	20 d2 5a	jsr $3a5ad2	            JSR STREMIT
.3a5c24	a3 06		lda $06,s	                LDA L_EXP
.3a5c26	20 de 5a	jsr $3a5ade	            JSR STREMITB
.3a5c29	80 0a		bra $3a5c35	                BRA done                    ; TODO: reformat integer... add E and exponent...
.3a5c2b					ret_result
.3a5c2b	c2 20		rep #$20	            REP #$20
.3a5c2d	a5 16		lda $0816	                LDA STRPTR                  ; Return the temporary string we've assembled
.3a5c2f	85 23		sta $0823	                STA ARGUMENT1
.3a5c31	a5 18		lda $0818	                LDA STRPTR+2
.3a5c33	85 25		sta $0825	                STA ARGUMENT1+2
.3a5c35					done
.3a5c35	e2 20		sep #$20	            SEP #$20
.3a5c37	a9 02		lda #$02	                LDA #TYPE_STRING
.3a5c39	85 27		sta $0827	                STA ARGTYPE1
.3a5c3b	c2 20		rep #$20	            REP #$20
.3a5c3d	3b		tsc		                TSC                         ; Remove the locals from the stack
.3a5c3e	18		clc		                CLC
.3a5c3f	69 06 00	adc #$0006	                ADC #6
.3a5c42	1b		tcs		                TCS
.3a5c43	28		plp		                PLP
.3a5c44	60		rts		            RTS
>3a5c45	00 50 c3 47			ten_d_1         .dword $47c35000            ; 10^(FP_D-1), where FP_D=5
>3a5c49	00 00 80 3f			FP_1_0          .dword $3f800000    ; Floating point constant: 1.0
>3a5c4d	f3 04 b5 3f			FP_SQR_2_0      .dword $3fb504f3    ; Floating point constant: sqrt(2.0)
>3a5c51	f3 04 35 3f			FP_SQR_0_5      .dword $3f3504f3    ; Floating point constant: sqrt(0.2)

;******  Return to file: src\basic816.s


;******  Processing file: src\transcendentals.s

.3a5c55					Q_POLY_HR
.3a5c55	e2 20		sep #$20	            SEP #$20
.3a5c57	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a5c59	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5c5d	c2 20		rep #$20	            REP #$20
.3a5c5f	bd 00 00	lda $0000,x	                LDA 0,X
.3a5c62	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5c66	bd 02 00	lda $0002,x	                LDA 2,X
.3a5c69	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5c6d	88		dey		                DEY             ; (Y-1) more coefficients.
.3a5c6e	e8		inx		loop            INX             ; point to the next coefficient
.3a5c6f	e8		inx		                INX
.3a5c70	e8		inx		                INX
.3a5c71	e8		inx		                INX
.3a5c72	e2 20		sep #$20	            SEP #$20
.3a5c74	a9 00		lda #$00	                LDA #FP_OUT_MULT
.3a5c76	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5c7a	c2 20		rep #$20	            REP #$20
.3a5c7c	af 23 08 00	lda $000823	                LDA @l ARGUMENT1
.3a5c80	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5c84	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.3a5c88	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5c8c	ea		nop		                NOP
.3a5c8d	ea		nop		                NOP
.3a5c8e	ea		nop		                NOP
.3a5c8f	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5c93	48		pha		                PHA
.3a5c94	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5c98	8f 0a e2 af	sta $afe20a	                STA FP_MATH_INPUT0_HL
.3a5c9c	68		pla		                PLA
.3a5c9d	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5ca1	e2 20		sep #$20	            SEP #$20
.3a5ca3	a9 02		lda #$02	                LDA #FP_OUT_ADD
.3a5ca5	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5ca9	c2 20		rep #$20	            REP #$20
.3a5cab	bd 00 00	lda $0000,x	                LDA 0,X
.3a5cae	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5cb2	bd 02 00	lda $0002,x	                LDA 2,X
.3a5cb5	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5cb9	ea		nop		                NOP
.3a5cba	ea		nop		                NOP
.3a5cbb	ea		nop		                NOP
.3a5cbc	88		dey		                DEY
.3a5cbd	f0 14		beq $3a5cd3	                BEQ done
.3a5cbf	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5cc3	48		pha		                PHA
.3a5cc4	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5cc8	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5ccc	68		pla		                PLA
.3a5ccd	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5cd1	80 9b		bra $3a5c6e	                BRA loop
.3a5cd3	af 08 e2 af	lda $afe208	done            LDA @l FP_MATH_OUTPUT_FP_LL
.3a5cd7	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.3a5cdb	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5cdf	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.3a5ce3	60		rts		                RTS
.3a5ce4					Q_SQ
.3a5ce4	e2 20		sep #$20	            SEP #$20
.3a5ce6	a9 00		lda #$00	                LDA #0
.3a5ce8	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5cec	a9 00		lda #$00	                LDA #FP_OUT_MULT
.3a5cee	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5cf2	c2 20		rep #$20	            REP #$20
.3a5cf4	a5 23		lda $0823	                LDA ARGUMENT1
.3a5cf6	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5cfa	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5cfe	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.3a5d02	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5d06	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5d0a	ea		nop		                NOP
.3a5d0b	ea		nop		                NOP
.3a5d0c	ea		nop		                NOP
.3a5d0d	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5d11	85 23		sta $0823	                STA ARGUMENT1
.3a5d13	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5d17	85 25		sta $0825	                STA ARGUMENT1+2
.3a5d19	60		rts		                RTS
.3a5d1a					Q_INV
.3a5d1a	e2 20		sep #$20	            SEP #$20
.3a5d1c	a9 00		lda #$00	                LDA #0
.3a5d1e	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5d22	a9 01		lda #$01	                LDA #FP_OUT_DIV
.3a5d24	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5d28	c2 20		rep #$20	            REP #$20
.3a5d2a	a5 23		lda $0823	                LDA ARGUMENT1
.3a5d2c	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5d30	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.3a5d34	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5d38	af 6e 63 3a	lda $3a636e	                LDA @l fp_one
.3a5d3c	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5d40	af 70 63 3a	lda $3a6370	                LDA @l fp_one+2
.3a5d44	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5d48	ea		nop		                NOP
.3a5d49	ea		nop		                NOP
.3a5d4a	ea		nop		                NOP
.3a5d4b	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5d4f	85 23		sta $0823	                STA ARGUMENT1
.3a5d51	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5d55	85 25		sta $0825	                STA ARGUMENT1+2
.3a5d57	60		rts		                RTS
.3a5d58					Q_FP_SCALE
.3a5d58	a2 00 00	ldx #$0000	                LDX #0
.3a5d5b	a5 23		lda $0823	loop            LDA ARGUMENT1
.3a5d5d	c5 29		cmp $0829	                CMP ARGUMENT2
.3a5d5f	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5d61	e5 2b		sbc $082b	                SBC ARGUMENT2+2
.3a5d63	90 1e		bcc $3a5d83	                BCC done
.3a5d65	a5 23		lda $0823	                LDA ARGUMENT1
.3a5d67	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5d6b	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5d6d	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5d71	ea		nop		                NOP
.3a5d72	ea		nop		                NOP
.3a5d73	ea		nop		                NOP
.3a5d74	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5d78	85 23		sta $0823	                STA ARGUMENT1
.3a5d7a	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5d7e	85 25		sta $0825	                STA ARGUMENT1+2
.3a5d80	e8		inx		                INX
.3a5d81	80 d8		bra $3a5d5b	                BRA loop
.3a5d83					done
.3a5d83	60		rts		            RTS
.3a5d84					Q_FP_SCALE_TAU
.3a5d84	e2 20		sep #$20	            SEP #$20
.3a5d86	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a5d88	10 09		bpl $3a5d93	                BPL notneg
.3a5d8a	29 7f		and #$7f	                AND #$7F
.3a5d8c	85 26		sta $0826	                STA ARGUMENT1+3
.3a5d8e	a9 01		lda #$01	                LDA #1
.3a5d90	48		pha		                PHA
.3a5d91	80 03		bra $3a5d96	                BRA compute
.3a5d93	a9 00		lda #$00	notneg          LDA #0          ; not negative, so push 0.
.3a5d95	48		pha		                PHA
.3a5d96	a9 40		lda #$40	compute         LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a5d98	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5d9c	a9 02		lda #$02	                LDA #FP_OUT_ADD
.3a5d9e	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5da2	c2 30		rep #$30	            REP #$30
.3a5da4	af d6 63 3a	lda $3a63d6	                LDA @l twopi
.3a5da8	85 29		sta $0829	                STA ARGUMENT2
.3a5daa	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5dae	af d8 63 3a	lda $3a63d8	                LDA @l twopi+2
.3a5db2	85 2b		sta $082b	                STA ARGUMENT2+2
.3a5db4	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5db8	20 58 5d	jsr $3a5d58	            JSR Q_FP_SCALE
.3a5dbb	e2 20		sep #$20	            SEP #$20
.3a5dbd	68		pla		                PLA
.3a5dbe	c2 20		rep #$20	            REP #$20
.3a5dc0	f0 1e		beq $3a5de0	                BEQ done
.3a5dc2	a5 23		lda $0823	                LDA ARGUMENT1
.3a5dc4	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5dc8	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5dca	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5dce	ea		nop		                NOP
.3a5dcf	ea		nop		                NOP
.3a5dd0	ea		nop		                NOP
.3a5dd1	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5dd5	85 23		sta $0823	                STA ARGUMENT1
.3a5dd7	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5ddb	29 ff 7f	and #$7fff	                AND #$7fff
.3a5dde	85 25		sta $0825	                STA ARGUMENT1+2
.3a5de0					done
.3a5de0	60		rts		            RTS
.3a5de1					Q_FP_NORM_ANGLE
.3a5de1	5a		phy		                PHY
.3a5de2	a2 00 00	ldx #$0000	                LDX #0
.3a5de5	a0 00 00	ldy #$0000	                LDY #0
.3a5de8	a5 23		lda $0823	loop            LDA ARGUMENT1
.3a5dea	df da 63 3a	cmp $3a63da,x	                CMP @l onepi,x
.3a5dee	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5df0	ff dc 63 3a	sbc $3a63dc,x	                SBC @l onepi+2,x
.3a5df4	90 2c		bcc $3a5e22	                BCC less
.3a5df6	bf d6 63 3a	lda $3a63d6,x	                LDA @l twopi,x
.3a5dfa	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5dfe	bf d8 63 3a	lda $3a63d8,x	                LDA @l twopi+2,x
.3a5e02	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5e06	a5 23		lda $0823	                LDA ARGUMENT1
.3a5e08	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5e0c	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5e0e	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5e12	ea		nop		                NOP
.3a5e13	ea		nop		                NOP
.3a5e14	ea		nop		                NOP
.3a5e15	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5e19	85 23		sta $0823	                STA ARGUMENT1
.3a5e1b	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5e1f	85 25		sta $0825	                STA ARGUMENT1+2
.3a5e21	38		sec		                SEC             ; set carry to indicate a reflection
.3a5e22	98		tya		less            TYA             ; carry already cleared if we branched
.3a5e23	2a		rol a		                ROL             ; shift carry into flags...
.3a5e24	a8		tay		                TAY             ; and store back into y
.3a5e25	e8		inx		                INX             ; next set of values
.3a5e26	e8		inx		                INX
.3a5e27	e8		inx		                INX
.3a5e28	e8		inx		                INX
.3a5e29	e0 0c 00	cpx #$000c	                CPX #12         ; check if we have already looked at 3
.3a5e2c	d0 ba		bne $3a5de8	                BNE loop
.3a5e2e	98		tya		                TYA             ; copy Y to X, as that's what we have
.3a5e2f	aa		tax		                TAX
.3a5e30	7a		ply		                PLY
.3a5e31	60		rts		            RTS
.3a5e32					Q_FP_COS
.3a5e32	08		php		                PHP
.3a5e33	c2 30		rep #$30	            REP #$30
.3a5e35	48		pha		                PHA
.3a5e36	da		phx		                PHX
.3a5e37	20 e4 5c	jsr $3a5ce4	            JSR Q_SQ
.3a5e3a	8b		phb		                PHB
.3a5e3b	e2 20		sep #$20	            SEP #$20
.3a5e3d	a9 3a		lda #$3a	                LDA #`cos_coeff
.3a5e3f	48		pha		                PHA
.3a5e40	ab		plb		                PLB
.3a5e41	c2 20		rep #$20	            REP #$20
.3a5e43	a2 16 63	ldx #$6316	                LDX #<>cos_coeff
.3a5e46	5a		phy		                PHY
.3a5e47	a0 05 00	ldy #$0005	                LDY #5
.3a5e4a	20 55 5c	jsr $3a5c55	            JSR Q_POLY_HR
.3a5e4d	7a		ply		                PLY
.3a5e4e	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.3a5e51	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.3a5e55	ab		plb		                PLB
.3a5e56	fa		plx		                PLX
.3a5e57	68		pla		                PLA
.3a5e58	28		plp		                PLP
.3a5e59	60		rts		            RTS
.3a5e5a					Q_FP_SIN
.3a5e5a	08		php		                PHP
.3a5e5b	c2 30		rep #$30	            REP #$30
.3a5e5d	48		pha		                PHA
.3a5e5e	da		phx		                PHX
.3a5e5f	a5 23		lda $0823	                LDA ARGUMENT1
.3a5e61	85 29		sta $0829	                STA ARGUMENT2
.3a5e63	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5e65	85 2b		sta $082b	                STA ARGUMENT2+2
.3a5e67	20 e4 5c	jsr $3a5ce4	            JSR Q_SQ
.3a5e6a	8b		phb		                PHB
.3a5e6b	e2 20		sep #$20	            SEP #$20
.3a5e6d	a9 3a		lda #$3a	                LDA #`sin_coeff
.3a5e6f	48		pha		                PHA
.3a5e70	ab		plb		                PLB
.3a5e71	c2 20		rep #$20	            REP #$20
.3a5e73	a2 2a 63	ldx #$632a	                LDX #<>sin_coeff
.3a5e76	5a		phy		                PHY
.3a5e77	a0 05 00	ldy #$0005	                LDY #5
.3a5e7a	20 55 5c	jsr $3a5c55	            JSR Q_POLY_HR
.3a5e7d	7a		ply		                PLY
.3a5e7e	ab		plb		                PLB
.3a5e7f	20 bf 54	jsr $3a54bf	            JSR OP_FP_MUL
.3a5e82	fa		plx		                PLX
.3a5e83	68		pla		                PLA
.3a5e84	28		plp		                PLP
.3a5e85	60		rts		            RTS
.3a5e86					Q_FP_TAN
.3a5e86	08		php		                PHP
.3a5e87	c2 30		rep #$30	            REP #$30
.3a5e89	48		pha		                PHA
.3a5e8a	da		phx		                PHX
.3a5e8b	a5 23		lda $0823	                LDA ARGUMENT1
.3a5e8d	85 29		sta $0829	                STA ARGUMENT2
.3a5e8f	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5e91	85 2b		sta $082b	                STA ARGUMENT2+2
.3a5e93	20 e4 5c	jsr $3a5ce4	            JSR Q_SQ
.3a5e96	8b		phb		                PHB
.3a5e97	e2 20		sep #$20	            SEP #$20
.3a5e99	a9 3a		lda #$3a	                LDA #`tan_coeff
.3a5e9b	48		pha		                PHA
.3a5e9c	ab		plb		                PLB
.3a5e9d	c2 20		rep #$20	            REP #$20
.3a5e9f	a2 3e 63	ldx #$633e	                LDX #<>tan_coeff
.3a5ea2	5a		phy		                PHY
.3a5ea3	a0 05 00	ldy #$0005	                LDY #5
.3a5ea6	20 55 5c	jsr $3a5c55	            JSR Q_POLY_HR
.3a5ea9	7a		ply		                PLY
.3a5eaa	ab		plb		                PLB
.3a5eab	20 bf 54	jsr $3a54bf	            JSR OP_FP_MUL
.3a5eae	fa		plx		                PLX
.3a5eaf	68		pla		                PLA
.3a5eb0	28		plp		                PLP
.3a5eb1	60		rts		            RTS
.3a5eb2					Q_FP_LN
.3a5eb2	08		php		                PHP
.3a5eb3	c2 30		rep #$30	            REP #$30
.3a5eb5	48		pha		                PHA
.3a5eb6	da		phx		                PHX
.3a5eb7	e2 20		sep #$20	            SEP #$20
.3a5eb9	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a5ebb	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5ebf	a9 02		lda #$02	                LDA #FP_OUT_ADD
.3a5ec1	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5ec5	c2 20		rep #$20	            REP #$20
.3a5ec7	a5 23		lda $0823	                LDA ARGUMENT1
.3a5ec9	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5ecd	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5ecf	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5ed3	af 6e 63 3a	lda $3a636e	                LDA @l fp_one
.3a5ed7	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5edb	af 70 63 3a	lda $3a6370	                LDA @l fp_one+2
.3a5edf	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5ee3	ea		nop		                NOP
.3a5ee4	ea		nop		                NOP
.3a5ee5	ea		nop		                NOP
.3a5ee6	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5eea	85 0c		sta $080c	                STA SCRATCH
.3a5eec	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5ef0	85 0e		sta $080e	                STA SCRATCH+2
.3a5ef2	e2 20		sep #$20	            SEP #$20
.3a5ef4	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a5ef6	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5efa	c2 20		rep #$20	            REP #$20
.3a5efc	ea		nop		                NOP
.3a5efd	ea		nop		                NOP
.3a5efe	ea		nop		                NOP
.3a5eff	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5f03	85 10		sta $0810	                STA SCRATCH2
.3a5f05	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5f09	85 12		sta $0812	                STA SCRATCH2+2
.3a5f0b	e2 20		sep #$20	            SEP #$20
.3a5f0d	a9 01		lda #$01	                LDA #FP_OUT_DIV
.3a5f0f	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5f13	c2 20		rep #$20	            REP #$20
.3a5f15	a5 0c		lda $080c	                LDA SCRATCH
.3a5f17	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5f1b	a5 0e		lda $080e	                LDA SCRATCH+2
.3a5f1d	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5f21	a5 10		lda $0810	                LDA SCRATCH2
.3a5f23	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5f27	a5 12		lda $0812	                LDA SCRATCH2+2
.3a5f29	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5f2d	ea		nop		                NOP
.3a5f2e	ea		nop		                NOP
.3a5f2f	ea		nop		                NOP
.3a5f30	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5f34	85 23		sta $0823	                STA ARGUMENT1
.3a5f36	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5f3a	85 25		sta $0825	                STA ARGUMENT1+2
.3a5f3c	e2 20		sep #$20	            SEP #$20
.3a5f3e	a9 08		lda #$08	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX0
.3a5f40	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5f44	a9 02		lda #$02	                LDA #FP_OUT_ADD
.3a5f46	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5f4a	c2 20		rep #$20	            REP #$20
.3a5f4c	a5 23		lda $0823	                LDA ARGUMENT1
.3a5f4e	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5f52	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5f54	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5f58	ea		nop		                NOP
.3a5f59	ea		nop		                NOP
.3a5f5a	ea		nop		                NOP
.3a5f5b	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5f5f	85 29		sta $0829	                STA ARGUMENT2
.3a5f61	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5f65	85 2b		sta $082b	                STA ARGUMENT2+2
.3a5f67	20 e4 5c	jsr $3a5ce4	            JSR Q_SQ
.3a5f6a	8b		phb		                PHB
.3a5f6b	e2 20		sep #$20	            SEP #$20
.3a5f6d	a9 3a		lda #$3a	                LDA #`ln_coeff
.3a5f6f	48		pha		                PHA
.3a5f70	ab		plb		                PLB
.3a5f71	c2 20		rep #$20	            REP #$20
.3a5f73	a2 52 63	ldx #$6352	                LDX #<>ln_coeff
.3a5f76	5a		phy		                PHY
.3a5f77	a0 08 00	ldy #$0008	                LDY #8
.3a5f7a	20 55 5c	jsr $3a5c55	            JSR Q_POLY_HR
.3a5f7d	7a		ply		                PLY
.3a5f7e	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.3a5f81	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.3a5f85	8f 2d 08 00	sta $00082d	                STA @l ARGTYPE2
.3a5f89	20 bf 54	jsr $3a54bf	            JSR OP_FP_MUL
.3a5f8c	ab		plb		                PLB
.3a5f8d	fa		plx		                PLX
.3a5f8e	68		pla		                PLA
.3a5f8f	28		plp		                PLP
.3a5f90	60		rts		            RTS
.3a5f91					FP_SIN
.3a5f91	08		php		                PHP
.3a5f92	c2 30		rep #$30	            REP #$30
.3a5f94	48		pha		                PHA
.3a5f95	da		phx		                PHX
.3a5f96	20 84 5d	jsr $3a5d84	            JSR Q_FP_SCALE_TAU
.3a5f99	20 e1 5d	jsr $3a5de1	            JSR Q_FP_NORM_ANGLE
.3a5f9c	da		phx		                PHX
.3a5f9d	8a		txa		                TXA
.3a5f9e	29 01 00	and #$0001	                AND #1
.3a5fa1	d0 05		bne $3a5fa8	                BNE do_cos
.3a5fa3	20 5a 5e	jsr $3a5e5a	            JSR Q_FP_SIN
.3a5fa6	80 03		bra $3a5fab	                BRA maybe_neg
.3a5fa8					do_cos
.3a5fa8	20 32 5e	jsr $3a5e32	            JSR Q_FP_COS
.3a5fab	fa		plx		maybe_neg       PLX
.3a5fac	8a		txa		                TXA
.3a5fad	29 04 00	and #$0004	                AND #4
.3a5fb0	f0 0a		beq $3a5fbc	                BEQ done
.3a5fb2	e2 20		sep #$20	            SEP #$20
.3a5fb4	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a5fb6	09 80		ora #$80	                ORA #$80
.3a5fb8	85 26		sta $0826	                STA ARGUMENT1+3
.3a5fba	c2 20		rep #$20	            REP #$20
.3a5fbc	fa		plx		done            PLX
.3a5fbd	68		pla		                PLA
.3a5fbe	28		plp		                PLP
.3a5fbf	60		rts		            RTS
.3a5fc0					FP_COS
.3a5fc0	08		php		                PHP
.3a5fc1	c2 30		rep #$30	            REP #$30
.3a5fc3	48		pha		                PHA
.3a5fc4	da		phx		                PHX
.3a5fc5	20 84 5d	jsr $3a5d84	            JSR Q_FP_SCALE_TAU
.3a5fc8	20 e1 5d	jsr $3a5de1	            JSR Q_FP_NORM_ANGLE
.3a5fcb	da		phx		                PHX
.3a5fcc	8a		txa		                TXA
.3a5fcd	29 01 00	and #$0001	                AND #1
.3a5fd0	d0 05		bne $3a5fd7	                BNE do_sin
.3a5fd2	20 32 5e	jsr $3a5e32	            JSR Q_FP_COS
.3a5fd5	80 03		bra $3a5fda	                BRA maybe_neg
.3a5fd7					do_sin
.3a5fd7	20 5a 5e	jsr $3a5e5a	            JSR Q_FP_SIN
.3a5fda	fa		plx		maybe_neg       PLX
.3a5fdb	8a		txa		                TXA
.3a5fdc	29 02 00	and #$0002	                AND #2
.3a5fdf	f0 0a		beq $3a5feb	                BEQ done
.3a5fe1	e2 20		sep #$20	            SEP #$20
.3a5fe3	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a5fe5	09 80		ora #$80	                ORA #$80
.3a5fe7	85 26		sta $0826	                STA ARGUMENT1+3
.3a5fe9	c2 20		rep #$20	            REP #$20
.3a5feb	fa		plx		done            PLX
.3a5fec	68		pla		                PLA
.3a5fed	28		plp		                PLP
.3a5fee	60		rts		            RTS
.3a5fef					FP_TAN
.3a5fef	08		php		                PHP
.3a5ff0	c2 30		rep #$30	            REP #$30
.3a5ff2	48		pha		                PHA
.3a5ff3	da		phx		                PHX
.3a5ff4	20 84 5d	jsr $3a5d84	            JSR Q_FP_SCALE_TAU
.3a5ff7	20 e1 5d	jsr $3a5de1	            JSR Q_FP_NORM_ANGLE
.3a5ffa	20 86 5e	jsr $3a5e86	            JSR Q_FP_TAN
.3a5ffd	8a		txa		                TXA
.3a5ffe	29 01 00	and #$0001	                AND #1
.3a6001	f0 03		beq $3a6006	                BEQ no_inv
.3a6003	20 1a 5d	jsr $3a5d1a	            JSR Q_INV
.3a6006	8a		txa		no_inv          TXA
.3a6007	e2 20		sep #$20	            SEP #$20
.3a6009	4a		lsr a		                LSR
.3a600a	4a		lsr a		                LSR
.3a600b	69 00		adc #$00	                ADC #0
.3a600d	29 01		and #$01	                AND #1
.3a600f	f0 06		beq $3a6017	                BEQ no_neg
.3a6011	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a6013	09 80		ora #$80	                ORA #$80
.3a6015	85 26		sta $0826	                STA ARGUMENT1+3
.3a6017					no_neg
.3a6017	c2 20		rep #$20	            REP #$20
.3a6019	fa		plx		                PLX
.3a601a	68		pla		                PLA
.3a601b	28		plp		                PLP
.3a601c	60		rts		            RTS
.3a601d					FP_LN
.3a601d	08		php		                PHP
.3a601e	c2 30		rep #$30	            REP #$30
.3a6020	48		pha		                PHA
.3a6021	da		phx		                PHX
.3a6022	5a		phy		                PHY
.3a6023	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6025	10 1f		bpl $3a6046	                BPL arg_ok
.3a6027	08		php		            PHP
.3a6028	c2 20		rep #$20	            REP #$20
.3a602a	48		pha		            PHA
.3a602b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a602e	5b		tcd		            TCD
.3a602f	68		pla		            PLA
.3a6030	28		plp		            PLP
.3a6031	e2 20		sep #$20	            SEP #$20
.3a6033	a9 17		lda #$17	            LDA #ERR_DOMAIN
.3a6035	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6039	c2 20		rep #$20	            REP #$20
.3a603b	29 ff 00	and #$00ff	            AND #$00FF
.3a603e	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a6041	e2 20		sep #$20	            SEP #$20
.3a6043	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6046					arg_ok
.3a6046	c2 30		rep #$30	            REP #$30
.3a6048	a5 23		lda $0823	                LDA ARGUMENT1
.3a604a	cf 6e 63 3a	cmp $3a636e	                CMP @l fp_one
.3a604e	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6050	cf 70 63 3a	cmp $3a6370	                CMP @l fp_one+2
.3a6054	b0 04		bcs $3a605a	                BCS gtone
.3a6056	20 1a 5d	jsr $3a5d1a	            JSR Q_INV
.3a6059	18		clc		                CLC
.3a605a	a9 00 00	lda #$0000	gtone           LDA #0
.3a605d	a8		tay		                TAY
.3a605e	2a		rol a		                ROL             ; Rotate Carry into A; 0 means negate
.3a605f	48		pha		                PHA
.3a6060	e2 20		sep #$20	            SEP #$20
.3a6062	a9 00		lda #$00	                LDA #0
.3a6064	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a6068	a9 01		lda #$01	                LDA #FP_OUT_DIV
.3a606a	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a606e	c2 20		rep #$20	            REP #$20
.3a6070	af c6 63 3a	lda $3a63c6	                LDA @l eexp64
.3a6074	85 29		sta $0829	                STA ARGUMENT2
.3a6076	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a607a	af c8 63 3a	lda $3a63c8	                LDA @l eexp64+2
.3a607e	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6080	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a6084	20 58 5d	jsr $3a5d58	            JSR Q_FP_SCALE
.3a6087	8a		txa		                TXA
.3a6088	f0 07		beq $3a6091	                BEQ chk16
.3a608a	0a		asl a		                ASL             ; multiply counter by 64
.3a608b	0a		asl a		                ASL
.3a608c	0a		asl a		                ASL
.3a608d	0a		asl a		                ASL
.3a608e	0a		asl a		                ASL
.3a608f	0a		asl a		                ASL
.3a6090	a8		tay		                TAY
.3a6091	af ca 63 3a	lda $3a63ca	chk16           LDA @l eexp16
.3a6095	85 29		sta $0829	                STA ARGUMENT2
.3a6097	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a609b	af cc 63 3a	lda $3a63cc	                LDA @l eexp16+2
.3a609f	85 2b		sta $082b	                STA ARGUMENT2+2
.3a60a1	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a60a5	20 58 5d	jsr $3a5d58	            JSR Q_FP_SCALE
.3a60a8	8a		txa		                TXA
.3a60a9	f0 0b		beq $3a60b6	                BEQ chk04
.3a60ab	0a		asl a		                ASL             ; multiply counter by 16
.3a60ac	0a		asl a		                ASL
.3a60ad	0a		asl a		                ASL
.3a60ae	0a		asl a		                ASL
.3a60af	85 29		sta $0829	                STA ARGUMENT2   ; and add into total
.3a60b1	18		clc		                CLC
.3a60b2	98		tya		                TYA
.3a60b3	65 29		adc $0829	                ADC ARGUMENT2
.3a60b5	a8		tay		                TAY
.3a60b6	af ce 63 3a	lda $3a63ce	chk04           LDA @l eexp04
.3a60ba	85 29		sta $0829	                STA ARGUMENT2
.3a60bc	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a60c0	af d0 63 3a	lda $3a63d0	                LDA @l eexp04+2
.3a60c4	85 2b		sta $082b	                STA ARGUMENT2+2
.3a60c6	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a60ca	20 58 5d	jsr $3a5d58	            JSR Q_FP_SCALE
.3a60cd	8a		txa		                TXA
.3a60ce	f0 09		beq $3a60d9	                BEQ chk01
.3a60d0	0a		asl a		                ASL             ;multiply counter by 4
.3a60d1	0a		asl a		                ASL
.3a60d2	85 29		sta $0829	                STA ARGUMENT2   ;and add to total
.3a60d4	18		clc		                CLC
.3a60d5	98		tya		                TYA
.3a60d6	65 29		adc $0829	                ADC ARGUMENT2
.3a60d8	a8		tay		                TAY
.3a60d9	af d2 63 3a	lda $3a63d2	chk01           LDA @l eexp01
.3a60dd	85 29		sta $0829	                STA ARGUMENT2
.3a60df	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a60e3	af d4 63 3a	lda $3a63d4	                LDA @l eexp01+2
.3a60e7	85 2b		sta $082b	                STA ARGUMENT2+2
.3a60e9	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a60ed	20 58 5d	jsr $3a5d58	            JSR Q_FP_SCALE
.3a60f0	86 29		stx $0829	                STX ARGUMENT2   ; add counter to total
.3a60f2	18		clc		                CLC
.3a60f3	98		tya		                TYA
.3a60f4	65 29		adc $0829	                ADC ARGUMENT2
.3a60f6	a8		tay		                TAY
.3a60f7	20 b2 5e	jsr $3a5eb2	            JSR Q_FP_LN
.3a60fa	a5 23		lda $0823	                LDA ARGUMENT1
.3a60fc	85 29		sta $0829	                STA ARGUMENT2
.3a60fe	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6100	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6102	98		tya		                TYA
.3a6103	85 23		sta $0823	                STA ARGUMENT1
.3a6105	64 25		stz $0825	                STZ ARGUMENT1+2
.3a6107	20 4c 59	jsr $3a594c	            JSR ITOF
.3a610a	20 29 54	jsr $3a5429	            JSR OP_FP_ADD
.3a610d	68		pla		                PLA
.3a610e	d0 07		bne $3a6117	                BNE done
.3a6110	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6112	09 00 80	ora #$8000	                ORA #$8000
.3a6115	85 25		sta $0825	                STA ARGUMENT1+2
.3a6117	7a		ply		done            PLY
.3a6118	fa		plx		                PLX
.3a6119	68		pla		                PLA
.3a611a	28		plp		                PLP
.3a611b	60		rts		            RTS
.3a611c					FP_ASIN
.3a611c	08		php		                PHP
.3a611d	c2 30		rep #$30	            REP #$30
.3a611f	48		pha		                PHA
.3a6120	da		phx		                PHX
.3a6121	a5 23		lda $0823	                LDA ARGUMENT1
.3a6123	85 29		sta $0829	                STA ARGUMENT2
.3a6125	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6127	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6129	20 e4 5c	jsr $3a5ce4	            JSR Q_SQ
.3a612c	8b		phb		                PHB
.3a612d	e2 20		sep #$20	            SEP #$20
.3a612f	a9 3a		lda #$3a	                LDA #`asin_coeff
.3a6131	48		pha		                PHA
.3a6132	ab		plb		                PLB
.3a6133	c2 20		rep #$20	            REP #$20
.3a6135	a2 76 63	ldx #$6376	                LDX #<>asin_coeff
.3a6138	a0 05 00	ldy #$0005	                LDY #5
.3a613b	20 55 5c	jsr $3a5c55	            JSR Q_POLY_HR
.3a613e	ab		plb		                PLB
.3a613f	20 bf 54	jsr $3a54bf	            JSR OP_FP_MUL
.3a6142	fa		plx		                PLX
.3a6143	68		pla		                PLA
.3a6144	28		plp		                PLP
.3a6145	60		rts		            RTS
.3a6146					FP_ACOS
.3a6146	08		php		                PHP
.3a6147	c2 30		rep #$30	            REP #$30
.3a6149	48		pha		                PHA
.3a614a	da		phx		                PHX
.3a614b	20 1c 61	jsr $3a611c	            JSR FP_ASIN
.3a614e	af de 63 3a	lda $3a63de	                LDA @l halfpi
.3a6152	85 29		sta $0829	                STA ARGUMENT2
.3a6154	af e0 63 3a	lda $3a63e0	                LDA @l halfpi+2
.3a6158	85 2b		sta $082b	                STA ARGUMENT2+2
.3a615a	20 1e 54	jsr $3a541e	            JSR OP_FP_SUB
.3a615d	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a615f	49 00 80	eor #$8000	                EOR #$8000
.3a6162	85 25		sta $0825	                STA ARGUMENT1+2
.3a6164	fa		plx		                PLX
.3a6165	68		pla		                PLA
.3a6166	28		plp		                PLP
.3a6167	60		rts		            RTS
.3a6168					FP_ATAN
.3a6168	08		php		                PHP
.3a6169	c2 30		rep #$30	            REP #$30
.3a616b	48		pha		                PHA
.3a616c	da		phx		                PHX
.3a616d	a5 23		lda $0823	                LDA ARGUMENT1
.3a616f	85 29		sta $0829	                STA ARGUMENT2
.3a6171	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6173	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6175	20 e4 5c	jsr $3a5ce4	            JSR Q_SQ
.3a6178	8b		phb		                PHB
.3a6179	e2 20		sep #$20	            SEP #$20
.3a617b	a9 3a		lda #$3a	                LDA #`atan_coeff
.3a617d	48		pha		                PHA
.3a617e	ab		plb		                PLB
.3a617f	c2 20		rep #$20	            REP #$20
.3a6181	a2 8a 63	ldx #$638a	                LDX #<>atan_coeff
.3a6184	a0 05 00	ldy #$0005	                LDY #5
.3a6187	20 55 5c	jsr $3a5c55	            JSR Q_POLY_HR
.3a618a	ab		plb		                PLB
.3a618b	20 bf 54	jsr $3a54bf	            JSR OP_FP_MUL
.3a618e	fa		plx		                PLX
.3a618f	68		pla		                PLA
.3a6190	28		plp		                PLP
.3a6191	60		rts		            RTS
.3a6192					Q_FP_POW_INT
.3a6192	c2 20		rep #$20	            REP #$20
.3a6194	a5 23		lda $0823	            LDA ARGUMENT1
.3a6196	85 29		sta $0829	            STA ARGUMENT2
.3a6198	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a619a	85 2b		sta $082b	            STA ARGUMENT2+2
.3a619c	c2 20		rep #$20	            REP #$20
.3a619e	af 6e 63 3a	lda $3a636e	            LDA @l fp_one
.3a61a2	85 23		sta $0823	            STA ARGUMENT1
.3a61a4	af 70 63 3a	lda $3a6370	            LDA @l fp_one+2
.3a61a8	85 25		sta $0825	            STA ARGUMENT1+2
.3a61aa	8a		txa		loop            TXA
.3a61ab	f0 30		beq $3a61dd	                BEQ done
.3a61ad	4a		lsr a		                LSR
.3a61ae	aa		tax		                TAX
.3a61af	90 03		bcc $3a61b4	                BCC next
.3a61b1	20 bf 54	jsr $3a54bf	            JSR OP_FP_MUL
.3a61b4					next
.3a61b4	c2 20		rep #$20	            REP #$20
.3a61b6	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a61b8	48		pha		            PHA
.3a61b9	a5 23		lda $0823	            LDA ARGUMENT1
.3a61bb	48		pha		            PHA
.3a61bc	c2 20		rep #$20	            REP #$20
.3a61be	a5 29		lda $0829	            LDA ARGUMENT2
.3a61c0	85 23		sta $0823	            STA ARGUMENT1
.3a61c2	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a61c4	85 25		sta $0825	            STA ARGUMENT1+2
.3a61c6	20 e4 5c	jsr $3a5ce4	            JSR Q_SQ
.3a61c9	c2 20		rep #$20	            REP #$20
.3a61cb	a5 23		lda $0823	            LDA ARGUMENT1
.3a61cd	85 29		sta $0829	            STA ARGUMENT2
.3a61cf	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a61d1	85 2b		sta $082b	            STA ARGUMENT2+2
.3a61d3	c2 20		rep #$20	            REP #$20
.3a61d5	68		pla		            PLA
.3a61d6	85 23		sta $0823	            STA ARGUMENT1
.3a61d8	68		pla		            PLA
.3a61d9	85 25		sta $0825	            STA ARGUMENT1+2
.3a61db	80 cd		bra $3a61aa	                BRA loop
.3a61dd					done
.3a61dd	60		rts		            RTS
.3a61de					Q_FP_EXP
.3a61de	08		php		                PHP
.3a61df	c2 30		rep #$30	            REP #$30
.3a61e1	48		pha		                PHA
.3a61e2	da		phx		                PHX
.3a61e3	8b		phb		                PHB
.3a61e4	e2 20		sep #$20	            SEP #$20
.3a61e6	a9 3a		lda #$3a	                LDA #`exp_coeff
.3a61e8	48		pha		                PHA
.3a61e9	ab		plb		                PLB
.3a61ea	c2 20		rep #$20	            REP #$20
.3a61ec	a2 9e 63	ldx #$639e	                LDX #<>exp_coeff
.3a61ef	5a		phy		                PHY
.3a61f0	a0 0a 00	ldy #$000a	                LDY #10
.3a61f3	20 55 5c	jsr $3a5c55	            JSR Q_POLY_HR
.3a61f6	7a		ply		                PLY
.3a61f7	ab		plb		                PLB
.3a61f8	fa		plx		                PLX
.3a61f9	68		pla		                PLA
.3a61fa	28		plp		                PLP
.3a61fb	60		rts		            RTS
.3a61fc					FP_EXP
.3a61fc	08		php		                PHP
.3a61fd	c2 30		rep #$30	            REP #$30
.3a61ff	48		pha		                PHA
.3a6200	da		phx		                PHX
.3a6201	5a		phy		                PHY
.3a6202	a5 23		lda $0823	                LDA ARGUMENT1   ; special case for x==0
.3a6204	05 25		ora $0825	                ORA ARGUMENT1+2
.3a6206	d0 10		bne $3a6218	                BNE notzero
.3a6208	c2 20		rep #$20	            REP #$20
.3a620a	af 6e 63 3a	lda $3a636e	            LDA @l fp_one
.3a620e	85 23		sta $0823	            STA ARGUMENT1
.3a6210	af 70 63 3a	lda $3a6370	            LDA @l fp_one+2
.3a6214	85 25		sta $0825	            STA ARGUMENT1+2
.3a6216	80 61		bra $3a6279	                BRA done
.3a6218	a5 25		lda $0825	notzero         LDA ARGUMENT1+2 ; check if negative
.3a621a	29 00 80	and #$8000	                AND #$8000
.3a621d	a8		tay		                TAY             ; Y != 0 -> arg was negative
.3a621e	f0 07		beq $3a6227	                BEQ notneg
.3a6220	a5 25		lda $0825	                LDA ARGUMENT1+2 ; negate x
.3a6222	29 ff 7f	and #$7fff	                AND #$7FFF
.3a6225	85 25		sta $0825	                STA ARGUMENT1+2
.3a6227					notneg
.3a6227	c2 20		rep #$20	            REP #$20
.3a6229	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a622b	48		pha		            PHA
.3a622c	a5 23		lda $0823	            LDA ARGUMENT1
.3a622e	48		pha		            PHA
.3a622f	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a6232	a6 23		ldx $0823	                LDX ARGUMENT1              ; INT(x) now in ARGUMENT1; low 16 bits into X
.3a6234	20 71 06	jsr $3a0671	            JSR ASS_ARG1_FLOAT
.3a6237	c2 20		rep #$20	            REP #$20
.3a6239	a5 23		lda $0823	            LDA ARGUMENT1
.3a623b	85 29		sta $0829	            STA ARGUMENT2
.3a623d	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a623f	85 2b		sta $082b	            STA ARGUMENT2+2
.3a6241	c2 20		rep #$20	            REP #$20
.3a6243	68		pla		            PLA
.3a6244	85 23		sta $0823	            STA ARGUMENT1
.3a6246	68		pla		            PLA
.3a6247	85 25		sta $0825	            STA ARGUMENT1+2
.3a6249	20 1e 54	jsr $3a541e	            JSR OP_FP_SUB
.3a624c	20 de 61	jsr $3a61de	            JSR Q_FP_EXP
.3a624f	c2 20		rep #$20	            REP #$20
.3a6251	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a6253	48		pha		            PHA
.3a6254	a5 23		lda $0823	            LDA ARGUMENT1
.3a6256	48		pha		            PHA
.3a6257	c2 20		rep #$20	            REP #$20
.3a6259	af d2 63 3a	lda $3a63d2	            LDA @leexp01
.3a625d	85 23		sta $0823	            STA ARGUMENT1
.3a625f	af d4 63 3a	lda $3a63d4	            LDA @leexp01+2
.3a6263	85 25		sta $0825	            STA ARGUMENT1+2
.3a6265	20 92 61	jsr $3a6192	            JSR Q_FP_POW_INT
.3a6268	c2 20		rep #$20	            REP #$20
.3a626a	68		pla		            PLA
.3a626b	85 29		sta $0829	            STA ARGUMENT2
.3a626d	68		pla		            PLA
.3a626e	85 2b		sta $082b	            STA ARGUMENT2+2
.3a6270	20 bf 54	jsr $3a54bf	            JSR OP_FP_MUL
.3a6273	98		tya		                TYA
.3a6274	f0 03		beq $3a6279	                BEQ done
.3a6276	20 1a 5d	jsr $3a5d1a	            JSR Q_INV
.3a6279	7a		ply		done            PLY
.3a627a	fa		plx		                PLX
.3a627b	68		pla		                PLA
.3a627c	28		plp		                PLP
.3a627d	60		rts		            RTS
.3a627e					FP_SQR
.3a627e	08		php		                PHP
.3a627f	c2 30		rep #$30	            REP #$30
.3a6281	48		pha		                PHA
.3a6282	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6284	10 1f		bpl $3a62a5	                BPL arg_ok
.3a6286	08		php		            PHP
.3a6287	c2 20		rep #$20	            REP #$20
.3a6289	48		pha		            PHA
.3a628a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a628d	5b		tcd		            TCD
.3a628e	68		pla		            PLA
.3a628f	28		plp		            PLP
.3a6290	e2 20		sep #$20	            SEP #$20
.3a6292	a9 17		lda #$17	            LDA #ERR_DOMAIN
.3a6294	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6298	c2 20		rep #$20	            REP #$20
.3a629a	29 ff 00	and #$00ff	            AND #$00FF
.3a629d	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a62a0	e2 20		sep #$20	            SEP #$20
.3a62a2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a62a5					arg_ok
.3a62a5	c2 30		rep #$30	            REP #$30
.3a62a7	05 23		ora $0823	                ORA ARGUMENT1
.3a62a9	f0 68		beq $3a6313	                BEQ done
.3a62ab	c2 20		rep #$20	            REP #$20
.3a62ad	af 72 63 3a	lda $3a6372	            LDA @l fp_two
.3a62b1	85 29		sta $0829	            STA ARGUMENT2
.3a62b3	af 74 63 3a	lda $3a6374	            LDA @l fp_two+2
.3a62b7	85 2b		sta $082b	            STA ARGUMENT2+2
.3a62b9	e2 20		sep #$20	            SEP #$20
.3a62bb	a9 01		lda #$01	                LDA #TYPE_FLOAT
.3a62bd	85 2d		sta $082d	                STA ARGTYPE2
.3a62bf	c2 20		rep #$20	            REP #$20
.3a62c1	c2 20		rep #$20	            REP #$20
.3a62c3	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a62c5	48		pha		            PHA
.3a62c6	a5 23		lda $0823	            LDA ARGUMENT1
.3a62c8	48		pha		            PHA
.3a62c9					loop
.3a62c9	20 74 54	jsr $3a5474	            JSR OP_FP_DIV
.3a62cc	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a62ce	c5 2b		cmp $082b	                CMP ARGUMENT2+2
.3a62d0	d0 09		bne $3a62db	                BNE more
.3a62d2	a5 23		lda $0823	                LDA ARGUMENT1
.3a62d4	45 29		eor $0829	                EOR ARGUMENT2
.3a62d6	29 f8 ff	and #$fff8	                AND #$FFF8
.3a62d9	f0 30		beq $3a630b	                BEQ exitloop
.3a62db					more
.3a62db	20 29 54	jsr $3a5429	            JSR OP_FP_ADD
.3a62de	c2 20		rep #$20	            REP #$20
.3a62e0	af 72 63 3a	lda $3a6372	            LDA @l fp_two
.3a62e4	85 29		sta $0829	            STA ARGUMENT2
.3a62e6	af 74 63 3a	lda $3a6374	            LDA @l fp_two+2
.3a62ea	85 2b		sta $082b	            STA ARGUMENT2+2
.3a62ec	20 74 54	jsr $3a5474	            JSR OP_FP_DIV
.3a62ef	c2 20		rep #$20	            REP #$20
.3a62f1	a5 23		lda $0823	            LDA ARGUMENT1
.3a62f3	85 29		sta $0829	            STA ARGUMENT2
.3a62f5	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a62f7	85 2b		sta $082b	            STA ARGUMENT2+2
.3a62f9	c2 20		rep #$20	            REP #$20
.3a62fb	68		pla		            PLA
.3a62fc	85 23		sta $0823	            STA ARGUMENT1
.3a62fe	68		pla		            PLA
.3a62ff	85 25		sta $0825	            STA ARGUMENT1+2
.3a6301	c2 20		rep #$20	            REP #$20
.3a6303	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a6305	48		pha		            PHA
.3a6306	a5 23		lda $0823	            LDA ARGUMENT1
.3a6308	48		pha		            PHA
.3a6309	80 be		bra $3a62c9	                BRA loop
.3a630b					exitloop
.3a630b	c2 20		rep #$20	            REP #$20
.3a630d	68		pla		            PLA
.3a630e	85 29		sta $0829	            STA ARGUMENT2
.3a6310	68		pla		            PLA
.3a6311	85 2b		sta $082b	            STA ARGUMENT2+2
.3a6313	68		pla		done            PLA
.3a6314	28		plp		                PLP
.3a6315	60		rts		            RTS
.3a6316					cos_coeff
>3a6316	01 0d d0 37			                .dword $37D00D01
>3a631a	61 0b b6 ba			                .dword $BAB60B61
>3a631e	ab aa 2a 3d			                .dword $3D2AAAAB
>3a6322	00 00 00 bf			                .dword $BF000000
>3a6326	00 00 80 3f			                .dword $3F800000
.3a632a					sin_coeff
>3a632a	1d ef 38 36			                .dword $3638EF1D
>3a632e	01 0d 50 b9			                .dword $B9500D01
>3a6332	89 88 08 3c			                .dword $3C088889
>3a6336	ab aa 2a be			                .dword $BE2AAAAB
>3a633a	00 00 80 3f			                .dword $3F800000
.3a633e					tan_coeff
>3a633e	a4 27 b3 3c			                .dword $3CB327A4
>3a6342	d1 0d 5d 3d			                .dword $3D5D0DD1
>3a6346	89 88 08 3e			                .dword $3E088889
>3a634a	ab aa aa 3e			                .dword $3EAAAAAB
>3a634e	00 00 80 3f			                .dword $3F800000
.3a6352					ln_coeff
>3a6352	89 88 88 3d			                .dword $3D888889
>3a6356	d9 89 9d 3d			                .dword $3D9D89D9
>3a635a	8c 2e ba 3d			                .dword $3DBA2E8C
>3a635e	39 8e e3 3d			                .dword $3DE38E39
>3a6362	25 49 12 3e			                .dword $3E124925
>3a6366	cd cc 4c 3e			                .dword $3E4CCCCD
>3a636a	ab aa aa 3e			                .dword $3EAAAAAB
>3a636e	00 00 80 3f			fp_one          .dword $3F800000
>3a6372	00 00 00 40			fp_two          .dword $40000000
.3a6376					asin_coeff
>3a6376	8e e3 f8 3c			                .dword $3CF8E38E
>3a637a	6e db 36 3d			                .dword $3D36DB6E
>3a637e	9a 99 99 3d			                .dword $3D99999A
>3a6382	ab aa 2a 3e			                .dword $3E2AAAAB
>3a6386	00 00 80 3f			                .dword $3F800000
.3a638a					atan_coeff
>3a638a	39 8e e3 3d			                .dword $3DE38E39
>3a638e	25 49 12 be			                .dword $BE124925
>3a6392	cd cc 4c 3e			                .dword $3E4CCCCD
>3a6396	ab aa aa be			                .dword $BEAAAAAB
>3a639a	00 00 80 3f			                .dword $3F800000
.3a639e					exp_coeff
>3a639e	1d ef 38 36			        .dword $3638EF1D
>3a63a2	01 0d d0 37			        .dword $37D00D01
>3a63a6	01 0d 50 39			        .dword $39500D01
>3a63aa	61 0b b6 3a			        .dword $3AB60B61
>3a63ae	89 88 08 3c			        .dword $3C088889
>3a63b2	ab aa 2a 3d			        .dword $3D2AAAAB
>3a63b6	ab aa 2a 3e			        .dword $3E2AAAAB
>3a63ba	00 00 00 3f			        .dword $3F000000
>3a63be	00 00 80 3f			        .dword $3F800000
>3a63c2	00 00 80 3f			        .dword $3F800000
>3a63c6	c1 2c a1 6d			eexp64          .dword $6DA12CC1
>3a63ca	5f 97 07 4b			eexp16          .dword $4B07975F
>3a63ce	81 64 5a 42			eexp04          .dword $425A6481
>3a63d2	54 f8 2d 40			eexp01          .dword $402DF854
>3a63d6	db 0f c9 40			twopi           .dword $40C90FDB
>3a63da	db 0f 49 40			onepi           .dword $40490FDB
>3a63de	db 0f c9 3f			halfpi          .dword $3FC90FDB
>3a63e2	db 0f 49 3f			quarterpi       .dword $3F490FDB

;******  Return to file: src\basic816.s


;******  Processing file: src\arrays.s

.3a63e6					ARR_ALLOC
.3a63e6	08		php		                PHP
.3a63e7	20 bc 11	jsr $3a11bc	            JSR HEAP_GETHED
.3a63ea	c2 20		rep #$20	            REP #$20
.3a63ec	a9 01 00	lda #$0001	                LDA #1                      ; ARGUMENT1 := 1
.3a63ef	85 23		sta $0823	                STA ARGUMENT1
.3a63f1	a9 00 00	lda #$0000	                LDA #0
.3a63f4	85 25		sta $0825	                STA ARGUMENT1+2
.3a63f6	e2 20		sep #$20	            SEP #$20
.3a63f8	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.3a63fc	c2 20		rep #$20	            REP #$20
.3a63fe	29 ff 00	and #$00ff	                AND #$00FF
.3a6401	85 8f		sta $088f	                STA MCOUNT                  ; Save it to MCOUNT for later
.3a6403	a8		tay		                TAY                         ; Y := number of dimensions
.3a6404	a2 01 00	ldx #$0001	                LDX #1                      ; X := index to size 0
.3a6407					size_loop
.3a6407	c2 20		rep #$20	            REP #$20
.3a6409	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X           ; ARGUMENT2 := Ith dimension
.3a640d	85 29		sta $0829	                STA ARGUMENT2
.3a640f	a9 00 00	lda #$0000	                LDA #0
.3a6412	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6414	20 94 26	jsr $3a2694	            JSR OP_MULTIPLY
.3a6417	e8		inx		                INX
.3a6418	e8		inx		                INX
.3a6419	88		dey		                DEY
.3a641a	d0 eb		bne $3a6407	                BNE size_loop               ; If there are more dimensions, take the next one
.3a641c	c2 20		rep #$20	            REP #$20
.3a641e	a9 04 00	lda #$0004	                LDA #ARGUMENT_SIZE-1        ; Size of a data item (don't include the type code)
.3a6421	85 29		sta $0829	                STA ARGUMENT2
.3a6423	a9 00 00	lda #$0000	                LDA #0
.3a6426	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6428	20 94 26	jsr $3a2694	            JSR OP_MULTIPLY
.3a642b	e2 20		sep #$20	            SEP #$20
.3a642d	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF             ; SCRATCH := N * 2
.3a6431	85 0c		sta $080c	                STA SCRATCH
.3a6433	a9 00		lda #$00	                LDA #0
.3a6435	85 0d		sta $080d	                STA SCRATCH+1
.3a6437	c2 20		rep #$20	            REP #$20
.3a6439	06 0c		asl $080c	                ASL SCRATCH
.3a643b	38		sec		                SEC                         ; ARGUMENT1 := size of the complete block
.3a643c	a5 23		lda $0823	                LDA ARGUMENT1
.3a643e	65 0c		adc $080c	                ADC SCRATCH                 ; Size of data area + N*2 + 1 (in carry)
.3a6440	85 23		sta $0823	                STA ARGUMENT1
.3a6442	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6444	69 00 00	adc #$0000	                ADC #0
.3a6447	85 25		sta $0825	                STA ARGUMENT1+2
.3a6449	d0 29		bne $3a6474	                BNE too_big                 ; size > 16-bit? Yes: throw an error
.3a644b	e2 20		sep #$20	            SEP #$20
.3a644d	a5 ea		lda $08ea	                LDA TOFINDTYPE              ; Get the type
.3a644f	09 80		ora #$80	                ORA #$80                    ; Flip the flag to make it an array of that type
.3a6451	a6 23		ldx $0823	                LDX ARGUMENT1               ; Get the computed size
.3a6453	20 80 0f	jsr $3a0f80	            JSR ALLOC
.3a6456	e2 20		sep #$20	            SEP #$20
.3a6458	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.3a645c	87 c0		sta [$08c0]	                STA [CURRBLOCK]             ; Write the number of dimensions to the array's preamble
.3a645e	a0 01 00	ldy #$0001	                LDY #1
.3a6461	a2 00 00	ldx #$0000	                LDX #0
.3a6464					copy_loop
.3a6464	e2 20		sep #$20	            SEP #$20
.3a6466	bf 01 4d 00	lda $004d01,x	                LDA @lARRIDXBUF+1,X         ; ARGUMENT2 := Ith dimension
.3a646a	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y           ; And write the dimension to the array's preamble
.3a646c	e4 8f		cpx $088f	                CPX MCOUNT                  ; Have we written the last byte?
.3a646e	f0 23		beq $3a6493	                BEQ null_array              ; Yes: clear the array
.3a6470	e8		inx		                INX                         ; No: move to the next byte
.3a6471	c8		iny		                INY
.3a6472	80 f0		bra $3a6464	                BRA copy_loop
.3a6474					too_big
.3a6474	08		php		            PHP
.3a6475	c2 20		rep #$20	            REP #$20
.3a6477	48		pha		            PHA
.3a6478	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a647b	5b		tcd		            TCD
.3a647c	68		pla		            PLA
.3a647d	28		plp		            PLP
.3a647e	e2 20		sep #$20	            SEP #$20
.3a6480	a9 09		lda #$09	            LDA #ERR_RANGE
.3a6482	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6486	c2 20		rep #$20	            REP #$20
.3a6488	29 ff 00	and #$00ff	            AND #$00FF
.3a648b	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a648e	e2 20		sep #$20	            SEP #$20
.3a6490	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6493					null_array
.3a6493	e2 20		sep #$20	            SEP #$20
.3a6495	38		sec		                SEC                         ; INDEX := pointer to first value
.3a6496	a5 c0		lda $08c0	                LDA CURRBLOCK
.3a6498	67 c0		adc [$08c0]	                ADC [CURRBLOCK]
.3a649a	85 08		sta $0808	                STA INDEX
.3a649c	a5 c1		lda $08c1	                LDA CURRBLOCK+1
.3a649e	69 00		adc #$00	                ADC #0
.3a64a0	85 09		sta $0809	                STA INDEX+1
.3a64a2	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.3a64a4	69 00		adc #$00	                ADC #0
.3a64a6	85 0a		sta $080a	                STA INDEX+2
.3a64a8	64 0b		stz $080b	                STZ INDEX+3
.3a64aa	c2 20		rep #$20	            REP #$20
.3a64ac	a0 05 00	ldy #$0005	                LDY #HEAPOBJ.END            ; SCRATCH := pointer the the first byte after the array
.3a64af	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.3a64b1	85 0c		sta $080c	                STA SCRATCH
.3a64b3	e2 20		sep #$20	            SEP #$20
.3a64b5	c8		iny		                INY
.3a64b6	c8		iny		                INY
.3a64b7	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.3a64b9	85 0e		sta $080e	                STA SCRATCH+2
.3a64bb	64 0f		stz $080f	                STZ SCRATCH+3
.3a64bd					clr_loop
.3a64bd	e2 20		sep #$20	            SEP #$20
.3a64bf	a9 00		lda #$00	                LDA #0
.3a64c1	87 08		sta [$0808]	                STA [INDEX]                 ; Clear the byte
.3a64c3	c2 20		rep #$20	            REP #$20
.3a64c5	18		clc		                CLC                         ; Increment INDEX
.3a64c6	a5 08		lda $0808	                LDA INDEX
.3a64c8	69 01 00	adc #$0001	                ADC #1
.3a64cb	85 08		sta $0808	                STA INDEX
.3a64cd	a5 0a		lda $080a	                LDA INDEX+2
.3a64cf	69 00 00	adc #$0000	                ADC #0
.3a64d2	85 0a		sta $080a	                STA INDEX+2
.3a64d4	c5 0e		cmp $080e	                CMP SCRATCH+2               ; INDEX == SCRATCH?
.3a64d6	d0 e5		bne $3a64bd	                BNE clr_loop                ; No: write to this next byte
.3a64d8	a5 08		lda $0808	                LDA INDEX
.3a64da	c5 0c		cmp $080c	                CMP SCRATCH
.3a64dc	d0 df		bne $3a64bd	                BNE clr_loop
.3a64de					done
.3a64de	28		plp		                PLP
.3a64df	60		rts		            RTS
.3a64e0					ARR_CELL
.3a64e0	08		php		                PHP
.3a64e1	c2 20		rep #$20	            REP #$20
.3a64e3	64 08		stz $0808	                STZ INDEX               ; INDEX := 0
.3a64e5	64 0a		stz $080a	                STZ INDEX+2
.3a64e7	e2 20		sep #$20	            SEP #$20
.3a64e9	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF         ; MCOUNT := N (number of dimensions)
.3a64ed	85 8f		sta $088f	                STA MCOUNT
.3a64ef	64 90		stz $0890	                STZ MCOUNT+1
.3a64f1	a2 01 00	ldx #$0001	                LDX #1                  ; X := index to dimension 0
.3a64f4	e2 20		sep #$20	            SEP #$20
.3a64f6	a7 c0		lda [$08c0]	                LDA [CURRBLOCK]         ; Make sure the dimensions of the array
.3a64f8	c5 8f		cmp $088f	                CMP MCOUNT              ; ... match those requested
.3a64fa	f0 1f		beq $3a651b	                BEQ dims_match          ; Yes: the dimensions match
.3a64fc					arg_err
.3a64fc	08		php		            PHP
.3a64fd	c2 20		rep #$20	            REP #$20
.3a64ff	48		pha		            PHA
.3a6500	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6503	5b		tcd		            TCD
.3a6504	68		pla		            PLA
.3a6505	28		plp		            PLP
.3a6506	e2 20		sep #$20	            SEP #$20
.3a6508	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a650a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a650e	c2 20		rep #$20	            REP #$20
.3a6510	29 ff 00	and #$00ff	            AND #$00FF
.3a6513	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a6516	e2 20		sep #$20	            SEP #$20
.3a6518	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a651b	c9 01		cmp #$01	dims_match      CMP #1                  ; Check to see if this array is one dimensional
.3a651d	f0 3a		beq $3a6559	                BEQ add_last            ; If so, just add the index of the cell to INDEX
.3a651f	a0 01 00	ldy #$0001	                LDY #1
.3a6522					index_loop
.3a6522	e2 20		sep #$20	            SEP #$20
.3a6524	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; ARGUMENT1 := I_j
.3a6528	85 23		sta $0823	                STA ARGUMENT1
.3a652a	64 24		stz $0824	                STZ ARGUMENT1+1
.3a652c	64 25		stz $0825	                STZ ARGUMENT1+2
.3a652e	64 26		stz $0826	                STZ ARGUMENT1+3
.3a6530	b7 c0		lda [$08c0],y	                LDA [CURRBLOCK],Y       ; ARGUMENT2 := D_j
.3a6532	85 29		sta $0829	                STA ARGUMENT2
.3a6534	64 2a		stz $082a	                STZ ARGUMENT2+1
.3a6536	64 2b		stz $082b	                STZ ARGUMENT2+2
.3a6538	64 2c		stz $082c	                STZ ARGUMENT2+3
.3a653a	a5 23		lda $0823	                LDA ARGUMENT1
.3a653c	c5 29		cmp $0829	                CMP ARGUMENT2           ; Is I_j >= D_j
.3a653e	b0 68		bcs $3a65a8	                BGE range_err           ; Yes: throw an out-of-range error
.3a6540	20 94 26	jsr $3a2694	            JSR OP_MULTIPLY
.3a6543	c2 20		rep #$20	            REP #$20
.3a6545	18		clc		                CLC                     ; INDEX := INDEX + ARGUMENT1
.3a6546	a5 08		lda $0808	                LDA INDEX
.3a6548	65 23		adc $0823	                ADC ARGUMENT1
.3a654a	85 08		sta $0808	                STA INDEX
.3a654c	a5 0a		lda $080a	                LDA INDEX+2
.3a654e	65 25		adc $0825	                ADC ARGUMENT1+2
.3a6550	85 0a		sta $080a	                STA INDEX+2
.3a6552	e8		inx		                INX
.3a6553	e8		inx		                INX
.3a6554	c8		iny		                INY
.3a6555	c4 8f		cpy $088f	                CPY MCOUNT              ; Are we on the last index?
.3a6557	d0 c9		bne $3a6522	                BNE index_loop          ; No: move to the next index and try again
.3a6559					add_last
.3a6559	e2 20		sep #$20	            SEP #$20
.3a655b	18		clc		                CLC
.3a655c	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; INDEX := INDEX + I_(n-1)
.3a6560	85 90		sta $0890	                STA MCOUNT+1
.3a6562	65 08		adc $0808	                ADC INDEX
.3a6564	85 08		sta $0808	                STA INDEX
.3a6566	a5 09		lda $0809	                LDA INDEX+1
.3a6568	69 00		adc #$00	                ADC #0
.3a656a	85 09		sta $0809	                STA INDEX+1
.3a656c	c2 20		rep #$20	            REP #$20
.3a656e	a5 0a		lda $080a	                LDA INDEX+2
.3a6570	69 00 00	adc #$0000	                ADC #0
.3a6573	85 0a		sta $080a	                STA INDEX+2
.3a6575	c2 20		rep #$20	            REP #$20
.3a6577	06 08		asl $0808	                ASL INDEX               ; INDEX := INDEX * 4 (size of a value)
.3a6579	26 0a		rol $080a	                ROL INDEX+2
.3a657b	06 08		asl $0808	                ASL INDEX
.3a657d	26 0a		rol $080a	                ROL INDEX+2
.3a657f	e2 20		sep #$20	            SEP #$20
.3a6581	38		sec		                SEC
.3a6582	a5 08		lda $0808	                LDA INDEX
.3a6584	65 8f		adc $088f	                ADC MCOUNT
.3a6586	85 08		sta $0808	                STA INDEX
.3a6588	a5 09		lda $0809	                LDA INDEX+1
.3a658a	69 00		adc #$00	                ADC #0
.3a658c	85 09		sta $0809	                STA INDEX+1
.3a658e	c2 20		rep #$20	            REP #$20
.3a6590	a5 0a		lda $080a	                LDA INDEX+2
.3a6592	69 00 00	adc #$0000	                ADC #0
.3a6595	85 0a		sta $080a	                STA INDEX+2
.3a6597	18		clc		                CLC                     ; INDEX := INDEX + CURRBLOCK (point to the address desired)
.3a6598	a5 08		lda $0808	                LDA INDEX
.3a659a	65 c0		adc $08c0	                ADC CURRBLOCK
.3a659c	85 08		sta $0808	                STA INDEX
.3a659e	e2 20		sep #$20	            SEP #$20
.3a65a0	a5 0a		lda $080a	                LDA INDEX+2
.3a65a2	65 c2		adc $08c2	                ADC CURRBLOCK+2
.3a65a4	85 0a		sta $080a	                STA INDEX+2
.3a65a6	28		plp		                PLP
.3a65a7	60		rts		            RTS
.3a65a8					range_err
.3a65a8	08		php		            PHP
.3a65a9	c2 20		rep #$20	            REP #$20
.3a65ab	48		pha		            PHA
.3a65ac	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a65af	5b		tcd		            TCD
.3a65b0	68		pla		            PLA
.3a65b1	28		plp		            PLP
.3a65b2	e2 20		sep #$20	            SEP #$20
.3a65b4	a9 09		lda #$09	            LDA #ERR_RANGE
.3a65b6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a65ba	c2 20		rep #$20	            REP #$20
.3a65bc	29 ff 00	and #$00ff	            AND #$00FF
.3a65bf	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a65c2	e2 20		sep #$20	            SEP #$20
.3a65c4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a65c7					ARR_SET
.3a65c7	08		php		                PHP
.3a65c8	20 bc 11	jsr $3a11bc	            JSR HEAP_GETHED
.3a65cb	e2 20		sep #$20	            SEP #$20
.3a65cd	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.3a65d0	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.3a65d2	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.3a65d4	c5 27		cmp $0827	                CMP ARGTYPE1        ; is it the same as the argument?
.3a65d6	d0 28		bne $3a6600	                BNE type_mismatch   ; No: throw a type mismatch error
.3a65d8	a5 27		lda $0827	                LDA ARGTYPE1        ; Save the type
.3a65da	48		pha		                PHA
.3a65db	c2 20		rep #$20	            REP #$20
.3a65dd	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Save ARGUMENT1
.3a65df	48		pha		                PHA
.3a65e0	a5 23		lda $0823	                LDA ARGUMENT1
.3a65e2	48		pha		                PHA
.3a65e3	20 e0 64	jsr $3a64e0	            JSR ARR_CELL
.3a65e6	68		pla		                PLA                 ; Restore ARGUMENT1
.3a65e7	85 23		sta $0823	                STA ARGUMENT1
.3a65e9	68		pla		                PLA
.3a65ea	85 25		sta $0825	                STA ARGUMENT1+2
.3a65ec	e2 20		sep #$20	            SEP #$20
.3a65ee	68		pla		                PLA
.3a65ef	85 27		sta $0827	                STA ARGTYPE1
.3a65f1	c2 20		rep #$20	            REP #$20
.3a65f3	a5 23		lda $0823	                LDA ARGUMENT1       ; Set the value in the cell
.3a65f5	87 08		sta [$0808]	                STA [INDEX]
.3a65f7	a0 02 00	ldy #$0002	                LDY #2
.3a65fa	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a65fc	97 08		sta [$0808],y	                STA [INDEX],Y
.3a65fe	28		plp		                PLP
.3a65ff	60		rts		            RTS
.3a6600					type_mismatch
.3a6600	08		php		            PHP
.3a6601	c2 20		rep #$20	            REP #$20
.3a6603	48		pha		            PHA
.3a6604	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6607	5b		tcd		            TCD
.3a6608	68		pla		            PLA
.3a6609	28		plp		            PLP
.3a660a	e2 20		sep #$20	            SEP #$20
.3a660c	a9 04		lda #$04	            LDA #ERR_TYPE
.3a660e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6612	c2 20		rep #$20	            REP #$20
.3a6614	29 ff 00	and #$00ff	            AND #$00FF
.3a6617	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a661a	e2 20		sep #$20	            SEP #$20
.3a661c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a661f					ARR_REF
.3a661f	08		php		                PHP
.3a6620	20 bc 11	jsr $3a11bc	            JSR HEAP_GETHED
.3a6623	f4 00 00	pea #$0000	                PEA #0              ; Make room on the stack that ARR_CELL expects
.3a6626	f4 00 00	pea #$0000	                PEA #0
.3a6629	e2 20		sep #$20	            SEP #$20
.3a662b	48		pha		                PHA
.3a662c	20 e0 64	jsr $3a64e0	            JSR ARR_CELL
.3a662f	e2 20		sep #$20	            SEP #$20
.3a6631	68		pla		                PLA
.3a6632	c2 20		rep #$20	            REP #$20
.3a6634	68		pla		                PLA
.3a6635	68		pla		                PLA
.3a6636	c2 20		rep #$20	            REP #$20
.3a6638	a7 08		lda [$0808]	                LDA [INDEX]         ; Get the value in the cell
.3a663a	85 23		sta $0823	                STA ARGUMENT1
.3a663c	a0 02 00	ldy #$0002	                LDY #2
.3a663f	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a6641	85 25		sta $0825	                STA ARGUMENT1+2
.3a6643	e2 20		sep #$20	            SEP #$20
.3a6645	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.3a6648	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.3a664a	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.3a664c	85 27		sta $0827	                STA ARGTYPE1        ; Set the type of the return value
.3a664e	28		plp		                PLP
.3a664f	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\dos.s

.0000					DIRENTRY
>0000					SHORTNAME               .fill 11        ; $00 - The short name of the file (8 name, 3 extension)
>000b					ATTRIBUTE               .byte ?         ; $0B - The attribute bits
>000c					IGNORED1                .word ?         ; $0C - Unused (by us) bytes
>000e					CREATE_TIME             .word ?         ; $0E - Creation time
>0010					CREATE_DATE             .word ?         ; $10 - Creation date
>0012					ACCESS_DATE             .word ?         ; $12 - Last access date
>0014					CLUSTER_H               .word ?         ; $14 - High word of the first cluster #
>0016					MODIFIED_TIME           .word ?         ; $16 - Last modified time
>0018					MODIFIED_DATE           .word ?         ; $18 - Last modified date
>001a					CLUSTER_L               .word ?         ; $1A - Low word of the first cluster #
>001c					SIZE                    .dword ?        ; $1C - The size of the file (in bytes)
=$01					DOS_ATTR_RO = $01                       ; File is read-only
=$02					DOS_ATTR_HIDDEN = $02                   ; File is hidden
=$04					DOS_ATTR_SYSTEM = $04                   ; File is a system file
=$08					DOS_ATTR_VOLUME = $08                   ; Entry is the volume label
=$10					DOS_ATTR_DIR = $10                      ; Entry is a directory
=$20					DOS_ATTR_ARCH = $20                     ; Entry has changed since last backup
=$0f					DOS_ATTR_LONGNAME = $0F                 ; Entry is the long file name
=$e5					DOS_DIR_ENT_UNUSED = $E5                ; Marker for an unused directory entry
.0000					FILEDESC
>0000					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>0001					DEV                 .byte ?             ; The ID of the device holding the file
>0002					PATH                .dword ?            ; Pointer to a NULL terminated path string
>0006					CLUSTER             .dword ?            ; The current cluster of the file.
>000a					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>000e					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>0012					FILESIZE            .dword ?            ; The size of the file
>0016					CREATE_DATE         .word ?             ; The creation date of the file
>0018					CREATE_TIME         .word ?             ; The creation time of the file
>001a					MODIFIED_DATE       .word ?             ; The modification date of the file
>001c					MODIFIED_TIME       .word ?             ; The modification time of the file
=$01					FD_STAT_READ = $01                      ; The file is readable
=$02					FD_STAT_WRITE = $02                     ; The file is writable
=$40					FD_STAT_OPEN = $40                      ; The file is open
=$60					FD_STAT_ERROR = $60                     ; The file is in an error condition
=$80					FD_STAT_EOF = $80                       ; The file cursor is at the end of the file
>3af073					CLUSTER_BUFF    .fill 512           ; A buffer for cluster read/write operations
.3af273					FD_IN
>3af273					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>3af274					DEV                 .byte ?             ; The ID of the device holding the file
>3af275					PATH                .dword ?            ; Pointer to a NULL terminated path string
>3af279					CLUSTER             .dword ?            ; The current cluster of the file.
>3af27d					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>3af281					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>3af285					FILESIZE            .dword ?            ; The size of the file
>3af289					CREATE_DATE         .word ?             ; The creation date of the file
>3af28b					CREATE_TIME         .word ?             ; The creation time of the file
>3af28d					MODIFIED_DATE       .word ?             ; The modification date of the file
>3af28f					MODIFIED_TIME       .word ?             ; The modification time of the file
.3a6650					PR_FILESIZE
.3a6650	da		phx		                PHX
.3a6651	0b		phd		                PHD
.3a6652	08		php		                PHP
.3a6653	08		php		            PHP
.3a6654	c2 20		rep #$20	            REP #$20
.3a6656	48		pha		            PHA
.3a6657	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a665a	5b		tcd		            TCD
.3a665b	68		pla		            PLA
.3a665c	28		plp		            PLP
.3a665d	c2 30		rep #$30	            REP #$30
.3a665f	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6661	89 f0 ff	bit #$fff0	                BIT #$FFF0              ; Check to see if the amount is in MB range
.3a6664	d0 29		bne $3a668f	                BNE pr_mb               ; If so, print it in MBs
.3a6666	89 0f 00	bit #$000f	                BIT #$000F              ; Check to see if the amount is in KB range
.3a6669	d0 0c		bne $3a6677	                BNE pr_kb
.3a666b	a5 23		lda $0823	                LDA ARGUMENT1
.3a666d	89 00 fc	bit #$fc00	                BIT #$FC00
.3a6670	d0 05		bne $3a6677	                BNE pr_kb               ; If so, print it in KBs
.3a6672					pr_regular
.3a6672	20 e2 43	jsr $3a43e2	            JSR PR_INTEGER
.3a6675	80 2e		bra $3a66a5	                BRA done
.3a6677	a2 0a 00	ldx #$000a	pr_kb           LDX #10                 ; Shift so the amount in KB is in ARGUMENT1
.3a667a	46 25		lsr $0825	kb_shift        LSR ARGUMENT1+2
.3a667c	66 23		ror $0823	                ROR ARGUMENT1
.3a667e	ca		dex		                DEX
.3a667f	d0 f9		bne $3a667a	                BNE kb_shift
.3a6681	20 e2 43	jsr $3a43e2	            JSR PR_INTEGER
.3a6684	e2 20		sep #$20	            SEP #$20
.3a6686	a9 4b		lda #$4b	                LDA #'K'
.3a6688	20 18 00	jsr $3a0018	            JSR PRINTC
.3a668b	c2 20		rep #$20	            REP #$20
.3a668d	80 16		bra $3a66a5	                BRA done
.3a668f	a2 14 00	ldx #$0014	pr_mb           LDX #20                 ; Shift so the amount in MB is in ARGUMENT1
.3a6692	46 25		lsr $0825	mb_shift        LSR ARGUMENT1+2
.3a6694	66 23		ror $0823	                ROR ARGUMENT1
.3a6696	ca		dex		                DEX
.3a6697	d0 f9		bne $3a6692	                BNE mb_shift
.3a6699	20 e2 43	jsr $3a43e2	            JSR PR_INTEGER
.3a669c	e2 20		sep #$20	            SEP #$20
.3a669e	a9 4d		lda #$4d	                LDA #'M'
.3a66a0	20 18 00	jsr $3a0018	            JSR PRINTC
.3a66a3	c2 20		rep #$20	            REP #$20
.3a66a5	28		plp		done            PLP
.3a66a6	2b		pld		                PLD
.3a66a7	fa		plx		                PLX
.3a66a8	60		rts		            RTS
.3a66a9					CMD_DIR
.3a66a9	0b		phd		                PHD
.3a66aa	08		php		                PHP
.3a66ab	c2 30		rep #$30	            REP #$30
.3a66ad	a9 00 00	lda #$0000	                LDA #0                      ; Zero out the pagination line count
.3a66b0	8f b6 08 00	sta $0008b6	                STA @l LINECOUNT
.3a66b4	8f b8 08 00	sta $0008b8	                STA @l LINECOUNT+2
.3a66b8	e2 20		sep #$20	            SEP #$20
.3a66ba	20 bf 20	jsr $3a20bf	            JSR PEEK_TOK
.3a66bd	c9 00		cmp #$00	                CMP #0
.3a66bf	f0 08		beq $3a66c9	                BEQ set_null                ; If none provided, set the path to empty
.3a66c1	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a66c4	20 95 05	jsr $3a0595	            JSR ASS_ARG1_STR
.3a66c7	80 11		bra $3a66da	                BRA set_fd
.3a66c9					set_null
.3a66c9	c2 20		rep #$20	            REP #$20
.3a66cb	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT1 to the NULL string
.3a66ce	85 23		sta $0823	                STA ARGUMENT1
.3a66d0	85 25		sta $0825	                STA ARGUMENT1+2
.3a66d2	e2 20		sep #$20	            SEP #$20
.3a66d4	a9 02		lda #$02	                LDA #TYPE_STRING
.3a66d6	85 27		sta $0827	                STA ARGTYPE1
.3a66d8	c2 20		rep #$20	            REP #$20
.3a66da					set_fd
.3a66da	20 0a 68	jsr $3a680a	            JSR SETFILEDESC
.3a66dd	22 08 11 00	jsl $001108	                JSL FK_DIROPEN              ; Open up the directory
.3a66e1	b0 22		bcs $3a6705	                BCS pr_first
.3a66e3	20 bb 68	jsr $3a68bb	            JSR SET_DOSSTAT
.3a66e6	08		php		            PHP
.3a66e7	c2 20		rep #$20	            REP #$20
.3a66e9	48		pha		            PHA
.3a66ea	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a66ed	5b		tcd		            TCD
.3a66ee	68		pla		            PLA
.3a66ef	28		plp		            PLP
.3a66f0	e2 20		sep #$20	            SEP #$20
.3a66f2	a9 10		lda #$10	            LDA #ERR_DIRECTORY
.3a66f4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a66f8	c2 20		rep #$20	            REP #$20
.3a66fa	29 ff 00	and #$00ff	            AND #$00FF
.3a66fd	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a6700	e2 20		sep #$20	            SEP #$20
.3a6702	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6705					pr_first
.3a6705	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a6708					pr_entry
.3a6708	08		php		            PHP
.3a6709	c2 20		rep #$20	            REP #$20
.3a670b	48		pha		            PHA
.3a670c	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.3a670f	5b		tcd		            TCD
.3a6710	68		pla		            PLA
.3a6711	28		plp		            PLP
.3a6712	e2 20		sep #$20	            SEP #$20
.3a6714	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Start with the file name
.3a6717	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the initial character of the name
.3a6719	d0 03		bne $3a671e	                BNE chk_unused
.3a671b	82 a9 00	brl $3a67c7	                BRL done                    ; If it's NULL, we're done
.3a671e	c9 e5		cmp #$e5	chk_unused      CMP #DOS_DIR_ENT_UNUSED     ; Is it the unusued code?
.3a6720	d0 03		bne $3a6725	                BNE chk_attributes
.3a6722	82 96 00	brl $3a67bb	                BRL next_entry              ; Yes: go to the next entry
.3a6725	a0 0b 00	ldy #$000b	chk_attributes  LDY #DIRENTRY.ATTRIBUTE
.3a6728	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute byte
.3a672a	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.3a672c	f0 03		beq $3a6731	                BEQ chk_hidden
.3a672e	82 a9 00	brl $3a67da	                BRL pr_volume               ; Print the volume label
.3a6731	89 02		bit #$02	chk_hidden      BIT #DOS_ATTR_HIDDEN        ; Is it a hidden file?
.3a6733	f0 03		beq $3a6738	                BEQ chk_long
.3a6735	82 83 00	brl $3a67bb	                BRL next_entry              ; Yes: go to the next entry
.3a6738	29 0f		and #$0f	chk_long        AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.3a673a	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.3a673c	d0 03		bne $3a6741	                BNE get_short_name
.3a673e	82 7a 00	brl $3a67bb	                BRL next_entry              ; Yes: go to the next entry
.3a6741	a0 00 00	ldy #$0000	get_short_name  LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.3a6744	b7 18		lda [$0338],y	pr_name_loop    LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.3a6746	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6749	c8		iny		                INY                         ; Move to the next character
.3a674a	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.3a674d	d0 f5		bne $3a6744	                BNE pr_name_loop            ; No: print this new character
.3a674f	a9 20		lda #$20	                LDA #' '                    ; Print the separator
.3a6751	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6754	a0 08 00	ldy #$0008	                LDY #DIRENTRY.SHORTNAME+8   ; Move to the first of the extension characters
.3a6757	b7 18		lda [$0338],y	pr_ext_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.3a6759	20 18 00	jsr $3a0018	                JSR PRINTC                  ; Otherwise: print it.
.3a675c	c8		iny		                INY                         ; Move to the next character
.3a675d	c0 0b 00	cpy #$000b	                CPY #DIRENTRY.SHORTNAME+11  ; Are we at the end of the extension portion?
.3a6760	d0 f5		bne $3a6757	                BNE pr_ext_loop             ; No: print this new character
.3a6762	a9 09		lda #$09	pr_tab1         LDA #CHAR_TAB               ; Print a TAB
.3a6764	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6767	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.3a676a	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.3a676c	89 10		bit #$10	                BIT #DOS_ATTR_DIR           ; Is it a directory?
.3a676e	d0 1e		bne $3a678e	                BNE pr_attr                 ; Yes: skip printing a file size
.3a6770	c2 20		rep #$20	            REP #$20
.3a6772	a0 1c 00	ldy #$001c	                LDY #DIRENTRY.SIZE
.3a6775	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the file size
.3a6777	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.3a677b	c8		iny		                INY
.3a677c	c8		iny		                INY
.3a677d	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y
.3a677f	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.3a6783	e2 20		sep #$20	            SEP #$20
.3a6785	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a6787	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.3a678b	20 50 66	jsr $3a6650	            JSR PR_FILESIZE
.3a678e	a9 09		lda #$09	pr_attr         LDA #CHAR_TAB               ; Print a TAB
.3a6790	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6793	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.3a6796	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.3a6798	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.3a679a	d0 1c		bne $3a67b8	                BNE end_entry               ; Yes: we're done printing this entry
.3a679c	89 01		bit #$01	chk_read        BIT #DOS_ATTR_RO            ; Is it a read-only file?
.3a679e	f0 05		beq $3a67a5	                BEQ chk_system
.3a67a0	a9 52		lda #$52	                LDA #'R'                    ; Yes: print an R
.3a67a2	20 18 00	jsr $3a0018	            JSR PRINTC
.3a67a5	89 04		bit #$04	chk_system      BIT #DOS_ATTR_SYSTEM        ; Is it System file?
.3a67a7	f0 05		beq $3a67ae	                BEQ chk_directory
.3a67a9	a9 53		lda #$53	                LDA #'S'                    ; Yes: print an S
.3a67ab	20 18 00	jsr $3a0018	            JSR PRINTC
.3a67ae	89 10		bit #$10	chk_directory   BIT #DOS_ATTR_DIR           ; Is it a directory?
.3a67b0	f0 05		beq $3a67b7	                BEQ pr_tab2
.3a67b2	a9 44		lda #$44	                LDA #'D'                    ; Yes: print a D
.3a67b4	20 18 00	jsr $3a0018	            JSR PRINTC
.3a67b7	ea		nop		pr_tab2         NOP
.3a67b8					end_entry
.3a67b8	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a67bb					next_entry
.3a67bb	20 a0 02	jsr $3a02a0	            JSR PAGINATE
.3a67be	22 0c 11 00	jsl $00110c	                JSL FK_DIRNEXT
.3a67c2	90 03		bcc $3a67c7	                BCC done
.3a67c4	82 41 ff	brl $3a6708	                BRL pr_entry
.3a67c7					done
.3a67c7	20 bb 68	jsr $3a68bb	            JSR SET_DOSSTAT
.3a67ca	08		php		            PHP
.3a67cb	c2 20		rep #$20	            REP #$20
.3a67cd	48		pha		            PHA
.3a67ce	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a67d1	5b		tcd		            TCD
.3a67d2	68		pla		            PLA
.3a67d3	28		plp		            PLP
.3a67d4	20 a3 1f	jsr $3a1fa3	            JSR SKIPSTMT
.3a67d7	28		plp		                PLP
.3a67d8	2b		pld		                PLD
.3a67d9	60		rts		            RTS
.3a67da					pr_volume
.3a67da	08		php		            PHP
.3a67db	c2 20		rep #$20	            REP #$20
.3a67dd	48		pha		            PHA
.3a67de	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.3a67e1	5b		tcd		            TCD
.3a67e2	68		pla		            PLA
.3a67e3	28		plp		            PLP
.3a67e4	e2 20		sep #$20	            SEP #$20
.3a67e6	29 0f		and #$0f	                AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.3a67e8	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.3a67ea	f0 cf		beq $3a67bb	                BEQ next_entry              ; Yes: skip it
.3a67ec	a9 5b		lda #$5b	pr_lbracket     LDA #'['
.3a67ee	20 18 00	jsr $3a0018	            JSR PRINTC
.3a67f1	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.3a67f4	b7 18		lda [$0338],y	pr_vol_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.3a67f6	c9 20		cmp #$20	                CMP #CHAR_SP                ; Is it a blank?
.3a67f8	f0 09		beq $3a6803	                BEQ pr_rbracket             ; Yes: end the name and print the dot
.3a67fa	20 18 00	jsr $3a0018	            JSR PRINTC
.3a67fd	c8		iny		                INY                         ; Move to the next character
.3a67fe	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.3a6801	d0 f1		bne $3a67f4	                BNE pr_vol_loop             ; No: print this new character
.3a6803	a9 5d		lda #$5d	pr_rbracket     LDA #']'                    ; Print a close bracket
.3a6805	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6808	80 ae		bra $3a67b8	                BRA end_entry               ; And try to get the next entry
.3a680a					SETFILEDESC
.3a680a	0b		phd		                PHD
.3a680b	08		php		                PHP
.3a680c	08		php		            PHP
.3a680d	c2 20		rep #$20	            REP #$20
.3a680f	48		pha		            PHA
.3a6810	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.3a6813	5b		tcd		            TCD
.3a6814	68		pla		            PLA
.3a6815	28		plp		            PLP
.3a6816	c2 30		rep #$30	            REP #$30
.3a6818	a9 73 f2	lda #$f273	                LDA #<>FD_IN            ; Point to the file descriptor
.3a681b	85 20		sta $0340	                STA DOS_FD_PTR
.3a681d	a9 3a 00	lda #$003a	                LDA #`FD_IN
.3a6820	85 22		sta $0342	                STA DOS_FD_PTR+2
.3a6822	a0 00 00	ldy #$0000	                LDY #0                  ; Fille the file descriptor with 0
.3a6825	e2 20		sep #$20	            SEP #$20
.3a6827	a9 00		lda #$00	                LDA #0
.3a6829	97 20		sta [$0340],y	zero_loop       STA [DOS_FD_PTR],Y
.3a682b	c8		iny		                INY
.3a682c	c0 1e 00	cpy #$001e	                CPY #SIZE(FILEDESC)
.3a682f	d0 f8		bne $3a6829	                BNE zero_loop
.3a6831	c2 20		rep #$20	            REP #$20
.3a6833	a9 73 f0	lda #$f073	                LDA #<>CLUSTER_BUFF     ; Point to the cluster buffer
.3a6836	8f 81 f2 3a	sta $3af281	                STA @l FD_IN.BUFFER
.3a683a	a9 3a 00	lda #$003a	                LDA #`CLUSTER_BUFF
.3a683d	8f 83 f2 3a	sta $3af283	                STA @l FD_IN.BUFFER+2
.3a6841	af 23 08 00	lda $000823	                LDA @l ARGUMENT1        ; Point the file desriptor to the path
.3a6845	8f 75 f2 3a	sta $3af275	                STA @l FD_IN.PATH
.3a6849	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.3a684d	8f 77 f2 3a	sta $3af277	                STA @l FD_IN.PATH+2
.3a6851	28		plp		                PLP
.3a6852	2b		pld		                PLD
.3a6853	60		rts		            RTS
.3a6854					S_BLOAD
.3a6854	08		php		                PHP
.3a6855	c2 30		rep #$30	            REP #$30
.3a6857	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a685a	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a685d	20 95 05	jsr $3a0595	            JSR ASS_ARG1_STR
.3a6860	20 0a 68	jsr $3a680a	            JSR SETFILEDESC
.3a6863	e2 20		sep #$20	            SEP #$20
.3a6865	a9 2c		lda #$2c	                LDA #','
.3a6867	85 37		sta $0837	                STA TARGETTOK
.3a6869	20 a0 20	jsr $3a20a0	            JSR OPT_TOK
.3a686c	b0 0f		bcs $3a687d	                BCS get_dest
.3a686e	c2 20		rep #$20	            REP #$20
.3a6870	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set destination address to something "safe"
.3a6873	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a6877	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a687b	80 17		bra $3a6894	                BRA do_load
.3a687d					get_dest
.3a687d	20 5e 1f	jsr $3a1f5e	            JSR INCBIP
.3a6880	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a6883	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a6886	c2 20		rep #$20	            REP #$20
.3a6888	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the destination address
.3a688a	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a688e	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6890	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a6894	22 18 11 00	jsl $001118	do_load         JSL FK_LOAD                 ; Attempt to load the file
.3a6898	b0 1f		bcs $3a68b9	                BCS done
.3a689a	08		php		            PHP
.3a689b	c2 20		rep #$20	            REP #$20
.3a689d	48		pha		            PHA
.3a689e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a68a1	5b		tcd		            TCD
.3a68a2	68		pla		            PLA
.3a68a3	28		plp		            PLP
.3a68a4	e2 20		sep #$20	            SEP #$20
.3a68a6	a9 11		lda #$11	            LDA #ERR_LOAD
.3a68a8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a68ac	c2 20		rep #$20	            REP #$20
.3a68ae	29 ff 00	and #$00ff	            AND #$00FF
.3a68b1	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a68b4	e2 20		sep #$20	            SEP #$20
.3a68b6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a68b9	28		plp		done            PLP
.3a68ba	60		rts		            RTS
.3a68bb					SET_DOSSTAT
.3a68bb	8b		phb		                PHB
.3a68bc	0b		phd		                PHD
.3a68bd	08		php		                PHP
.3a68be	08		php		            PHP
.3a68bf	c2 20		rep #$20	            REP #$20
.3a68c1	48		pha		            PHA
.3a68c2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a68c5	5b		tcd		            TCD
.3a68c6	68		pla		            PLA
.3a68c7	28		plp		            PLP
.3a68c8	08		php		            PHP
.3a68c9	e2 20		sep #$20	            SEP #$20
.3a68cb	48		pha		            PHA
.3a68cc	a9 00		lda #$00	            LDA #BASIC_BANK
.3a68ce	48		pha		            PHA
.3a68cf	ab		plb		            PLB
.3a68d0	68		pla		            PLA
.3a68d1	28		plp		            PLP
.3a68d2	e2 20		sep #$20	            SEP #$20
.3a68d4	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS           ; Get the DOS status code
.3a68d8	85 23		sta $0823	                STA ARGUMENT1
.3a68da	a9 00		lda #$00	                LDA #0
.3a68dc	85 24		sta $0824	                STA ARGUMENT1+1
.3a68de	85 25		sta $0825	                STA ARGUMENT1+2
.3a68e0	85 26		sta $0826	                STA ARGUMENT1+3
.3a68e2	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a68e4	85 27		sta $0827	                STA ARGTYPE1
.3a68e6	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (DOSSTAT)
.3a68e8	a9 3a		lda #$3a	                LDA #`dosstat_name
.3a68ea	85 e9		sta $08e9	                STA TOFIND+2
.3a68ec	c2 20		rep #$20	            REP #$20
.3a68ee	a9 1e 69	lda #$691e	                LDA #<>dosstat_name
.3a68f1	85 e7		sta $08e7	                STA TOFIND
.3a68f3	20 cb 50	jsr $3a50cb	            JSR VAR_SET
.3a68f6	e2 20		sep #$20	            SEP #$20
.3a68f8	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS          ; Get the BIOS status code
.3a68fc	85 23		sta $0823	                STA ARGUMENT1
.3a68fe	a9 00		lda #$00	                LDA #0
.3a6900	85 24		sta $0824	                STA ARGUMENT1+1
.3a6902	85 25		sta $0825	                STA ARGUMENT1+2
.3a6904	85 26		sta $0826	                STA ARGUMENT1+3
.3a6906	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a6908	85 27		sta $0827	                STA ARGTYPE1
.3a690a	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BIOSSTAT)
.3a690c	a9 3a		lda #$3a	                LDA #`biosstat_name
.3a690e	85 e9		sta $08e9	                STA TOFIND+2
.3a6910	c2 20		rep #$20	            REP #$20
.3a6912	a9 26 69	lda #$6926	                LDA #<>biosstat_name
.3a6915	85 e7		sta $08e7	                STA TOFIND
.3a6917	20 cb 50	jsr $3a50cb	            JSR VAR_SET
.3a691a	28		plp		                PLP
.3a691b	2b		pld		                PLD
.3a691c	ab		plb		                PLB
.3a691d	60		rts		            RTS
>3a691e	44 4f 53 53 54 41 54 00		dosstat_name    .null "DOSSTAT"
>3a6926	42 49 4f 53 53 54 41 54		biosstat_name   .null "BIOSSTAT"
>3a692e	00
.3a692f					CMD_BRUN
.3a692f	08		php		                PHP
.3a6930	c2 30		rep #$30	            REP #$30
.3a6932	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a6935	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a6938	20 95 05	jsr $3a0595	            JSR ASS_ARG1_STR
.3a693b	a5 23		lda $0823	                LDA ARGUMENT1
.3a693d	8f 60 03 00	sta $000360	                STA @l DOS_RUN_PARAM
.3a6941	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6943	8f 62 03 00	sta $000362	                STA @l DOS_RUN_PARAM+2
.3a6947	a9 ff ff	lda #$ffff	                LDA #$FFFF
.3a694a	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a694e	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a6952	22 24 11 00	jsl $001124	                JSL FK_RUN                  ; Attempt to run the file
.3a6956	b0 25		bcs $3a697d	                BCS done                    ; If we got it: try to execute it
.3a6958	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a695b	20 bb 68	jsr $3a68bb	            JSR SET_DOSSTAT
.3a695e	08		php		            PHP
.3a695f	c2 20		rep #$20	            REP #$20
.3a6961	48		pha		            PHA
.3a6962	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6965	5b		tcd		            TCD
.3a6966	68		pla		            PLA
.3a6967	28		plp		            PLP
.3a6968	e2 20		sep #$20	            SEP #$20
.3a696a	a9 11		lda #$11	            LDA #ERR_LOAD
.3a696c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6970	c2 20		rep #$20	            REP #$20
.3a6972	29 ff 00	and #$00ff	            AND #$00FF
.3a6975	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a6978	e2 20		sep #$20	            SEP #$20
.3a697a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a697d					done
.3a697d	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a6980	28		plp		                PLP
.3a6981	60		rts		            RTS
.3a6982					CMD_LOAD
.3a6982	08		php		                PHP
.3a6983	c2 30		rep #$30	            REP #$30
.3a6985	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a6988	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a698b	20 95 05	jsr $3a0595	            JSR ASS_ARG1_STR
.3a698e	20 0a 68	jsr $3a680a	            JSR SETFILEDESC
.3a6991	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.3a6994	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a6998	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.3a699b	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2        ; Set the destination address
.3a699f	20 9c 4d	jsr $3a4d9c	            JSR CMD_NEW
.3a69a2	22 18 11 00	jsl $001118	                JSL FK_LOAD                 ; Attempt to load the file
.3a69a6	b0 22		bcs $3a69ca	                BCS start_tokenize          ; If we got it: start tokenizing
.3a69a8	20 bb 68	jsr $3a68bb	            JSR SET_DOSSTAT
.3a69ab	08		php		            PHP
.3a69ac	c2 20		rep #$20	            REP #$20
.3a69ae	48		pha		            PHA
.3a69af	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a69b2	5b		tcd		            TCD
.3a69b3	68		pla		            PLA
.3a69b4	28		plp		            PLP
.3a69b5	e2 20		sep #$20	            SEP #$20
.3a69b7	a9 11		lda #$11	            LDA #ERR_LOAD
.3a69b9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a69bd	c2 20		rep #$20	            REP #$20
.3a69bf	29 ff 00	and #$00ff	            AND #$00FF
.3a69c2	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a69c5	e2 20		sep #$20	            SEP #$20
.3a69c7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a69ca					start_tokenize
.3a69ca	20 bb 68	jsr $3a68bb	            JSR SET_DOSSTAT
.3a69cd	c2 20		rep #$20	            REP #$20
.3a69cf	a2 12 00	ldx #$0012	                LDX #FILEDESC.FILESIZE
.3a69d2	18		clc		                CLC                         ; Set MTEMP to point to the byte after the file
.3a69d3	bf 73 f2 3a	lda $3af273,x	                LDA FD_IN,X
.3a69d7	69 00 00	adc #$0000	                ADC #<>LOADBLOCK
.3a69da	85 92		sta $0892	                STA MTEMP
.3a69dc	bf 75 f2 3a	lda $3af275,x	                LDA FD_IN+2,X
.3a69e0	69 01 00	adc #$0001	                ADC #`LOADBLOCK
.3a69e3	85 94		sta $0894	                STA MTEMP+2
.3a69e5	e2 20		sep #$20	            SEP #$20
.3a69e7	a9 00		lda #$00	                LDA #0
.3a69e9	87 92		sta [$0892]	                STA [MTEMP]                 ; Write a NULL right after the file
.3a69eb	c2 20		rep #$20	            REP #$20
.3a69ed	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK            ; Set MCURSOR to the begining of the loaded data
.3a69f0	85 7a		sta $087a	                STA MCURSOR
.3a69f2	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.3a69f5	85 7c		sta $087c	                STA MCURSOR+2
.3a69f7	a2 00 00	ldx #$0000	copy_line       LDX #0
.3a69fa					copy_char
.3a69fa	e2 20		sep #$20	            SEP #$20
.3a69fc	a7 7a		lda [$087a]	                LDA [MCURSOR]
.3a69fe	f0 2a		beq $3a6a2a	                BEQ clean_up                ; If the character is 0, we're done
.3a6a00	c9 0d		cmp #$0d	                CMP #CHAR_CR                ; If it is new line...
.3a6a02	f0 12		beq $3a6a16	                BEQ do_process              ; ... we want to process the line
.3a6a04	c9 0a		cmp #$0a	                CMP #CHAR_LF                ; If it is a line feed...
.3a6a06	f0 04		beq $3a6a0c	                BEQ next_char               ; ... we want to skip it
.3a6a08	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X              ; Otherwise, copy the character to the input buffer
.3a6a0b	e8		inx		                INX
.3a6a0c					next_char
.3a6a0c	c2 20		rep #$20	            REP #$20
.3a6a0e	e6 7a		inc $087a	                INC MCURSOR                 ; Advance the input cursor
.3a6a10	d0 e8		bne $3a69fa	                BNE copy_char
.3a6a12	e6 7c		inc $087c	                INC MCURSOR+2
.3a6a14	80 e4		bra $3a69fa	                BRA copy_char
.3a6a16					do_process
.3a6a16	e2 20		sep #$20	            SEP #$20
.3a6a18	a9 00		lda #$00	                LDA #0                      ; Put a 0 at the end of the input buffer
.3a6a1a	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a6a1d	20 cb 25	jsr $3a25cb	            JSR PROCESS
.3a6a20	c2 20		rep #$20	            REP #$20
.3a6a22	e6 7a		inc $087a	                INC MCURSOR                 ; Try again with the next line
.3a6a24	d0 d1		bne $3a69f7	                BNE copy_line
.3a6a26	e6 7c		inc $087c	                INC MCURSOR+2
.3a6a28	80 cd		bra $3a69f7	                BRA copy_line
.3a6a2a	e0 00 00	cpx #$0000	clean_up        CPX #0                      ; Is there data in the INPUTBUF?
.3a6a2d	f0 0a		beq $3a6a39	                BEQ done                    ; No: just return
.3a6a2f	e2 20		sep #$20	            SEP #$20
.3a6a31	a9 00		lda #$00	                LDA #0                      ; Make sure there is a trailing NULL
.3a6a33	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a6a36	20 cb 25	jsr $3a25cb	            JSR PROCESS
.3a6a39	28		plp		done            PLP
.3a6a3a	60		rts		            RTS
.3a6a3b					S_BSAVE
.3a6a3b	08		php		                PHP
.3a6a3c	c2 30		rep #$30	            REP #$30
.3a6a3e	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a6a41	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a6a44	20 95 05	jsr $3a0595	            JSR ASS_ARG1_STR
.3a6a47	20 0a 68	jsr $3a680a	            JSR SETFILEDESC
.3a6a4a	e2 20		sep #$20	            SEP #$20
.3a6a4c	a9 2c		lda #$2c	                LDA #','
.3a6a4e	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a6a51	c2 20		rep #$20	            REP #$20
.3a6a53	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a6a56	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a6a59	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_SRC_PTR
.3a6a5b	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.3a6a5f	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6a61	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.3a6a65	e2 20		sep #$20	            SEP #$20
.3a6a67	a9 2c		lda #$2c	                LDA #','
.3a6a69	c2 20		rep #$20	            REP #$20
.3a6a6b	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a6a6e	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a6a71	20 03 05	jsr $3a0503	            JSR ASS_ARG1_INT
.3a6a74	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_END_PTR
.3a6a76	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.3a6a7a	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6a7c	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.3a6a80	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                 ; Attempt to save the memory to file.
.3a6a84	b0 22		bcs $3a6aa8	                BCS done
.3a6a86	20 bb 68	jsr $3a68bb	            JSR SET_DOSSTAT
.3a6a89	08		php		            PHP
.3a6a8a	c2 20		rep #$20	            REP #$20
.3a6a8c	48		pha		            PHA
.3a6a8d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6a90	5b		tcd		            TCD
.3a6a91	68		pla		            PLA
.3a6a92	28		plp		            PLP
.3a6a93	e2 20		sep #$20	            SEP #$20
.3a6a95	a9 12		lda #$12	            LDA #ERR_SAVE
.3a6a97	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6a9b	c2 20		rep #$20	            REP #$20
.3a6a9d	29 ff 00	and #$00ff	            AND #$00FF
.3a6aa0	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a6aa3	e2 20		sep #$20	            SEP #$20
.3a6aa5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6aa8					done
.3a6aa8	20 bb 68	jsr $3a68bb	            JSR SET_DOSSTAT
.3a6aab	28		plp		                PLP
.3a6aac	60		rts		            RTS
.3a6aad					COPY2PATHBUF
.3a6aad	da		phx		                PHX
.3a6aae	5a		phy		                PHY
.3a6aaf	08		php		                PHP
.3a6ab0	a2 00 00	ldx #$0000	                LDX #0
.3a6ab3	a0 00 00	ldy #$0000	                LDY #0
.3a6ab6	e2 20		sep #$20	            SEP #$20
.3a6ab8	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y           ; Copy the path to the DOS_PATH_BUFF
.3a6aba	9d 00 04	sta $0400,x	                STA DOS_PATH_BUFF,X
.3a6abd	f0 04		beq $3a6ac3	                BEQ done
.3a6abf	e8		inx		                INX
.3a6ac0	c8		iny		                INY
.3a6ac1	80 f5		bra $3a6ab8	                BRA loop
.3a6ac3	28		plp		done            PLP
.3a6ac4	7a		ply		                PLY
.3a6ac5	fa		plx		                PLX
.3a6ac6	60		rts		            RTS
.3a6ac7					CMD_SAVE
.3a6ac7	08		php		                PHP
.3a6ac8	c2 30		rep #$30	            REP #$30
.3a6aca	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a6acd	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a6ad0	20 95 05	jsr $3a0595	            JSR ASS_ARG1_STR
.3a6ad3	20 0a 68	jsr $3a680a	            JSR SETFILEDESC
.3a6ad6	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.3a6ad9	85 a6		sta $08a6	                STA OBUFFER
.3a6adb	e2 20		sep #$20	            SEP #$20
.3a6add	a9 01		lda #$01	                LDA #`LOADBLOCK
.3a6adf	85 a8		sta $08a8	                STA OBUFFER+2
.3a6ae1	a9 20		lda #$20	                LDA #DEV_BUFFER             ; Set up output for the buffer
.3a6ae3	85 b4		sta $08b4	                STA BCONSOLE
.3a6ae5	c2 20		rep #$20	            REP #$20
.3a6ae7	a9 00 00	lda #$0000	                LDA #0
.3a6aea	85 ab		sta $08ab	                STA OBUFFIDX
.3a6aec	a9 ff ff	lda #$ffff	                LDA #$FFFF
.3a6aef	85 a9		sta $08a9	                STA OBUFFSIZE
.3a6af1	c2 20		rep #$20	            REP #$20
.3a6af3	a9 00 00	lda #$0000	                LDA #0                      ; Set start line number to 0
.3a6af6	85 55		sta $0855	                STA MARG1
.3a6af8	85 57		sta $0857	                STA MARG1+2
.3a6afa	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set end line number to MAXINT
.3a6afd	85 59		sta $0859	                STA MARG2
.3a6aff	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.3a6b02	85 5b		sta $085b	                STA MARG2+2
.3a6b04	20 10 17	jsr $3a1710	            JSR LISTPROG
.3a6b07	e2 20		sep #$20	            SEP #$20
.3a6b09	a9 80		lda #$80	                LDA #DEV_SCREEN             ; Restore output to the screen
.3a6b0b	85 b4		sta $08b4	                STA BCONSOLE
.3a6b0d	c2 20		rep #$20	            REP #$20
.3a6b0f	c6 ab		dec $08ab	                DEC OBUFFIDX                ; OBUFFIDX points to the next free byte... so pull it in one
.3a6b11	18		clc		                CLC                         ; Set the range of memory to save
.3a6b12	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.3a6b15	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.3a6b19	65 ab		adc $08ab	                ADC OBUFFIDX
.3a6b1b	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.3a6b1f	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.3a6b22	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.3a6b26	69 00 00	adc #$0000	                ADC #0
.3a6b29	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.3a6b2d	22 1c 11 00	jsl $00111c	do_save         JSL FK_SAVE                 ; Attempt to save the file
.3a6b31	b0 22		bcs $3a6b55	                BCS done
.3a6b33	20 bb 68	jsr $3a68bb	            JSR SET_DOSSTAT
.3a6b36	08		php		            PHP
.3a6b37	c2 20		rep #$20	            REP #$20
.3a6b39	48		pha		            PHA
.3a6b3a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6b3d	5b		tcd		            TCD
.3a6b3e	68		pla		            PLA
.3a6b3f	28		plp		            PLP
.3a6b40	e2 20		sep #$20	            SEP #$20
.3a6b42	a9 12		lda #$12	            LDA #ERR_SAVE
.3a6b44	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6b48	c2 20		rep #$20	            REP #$20
.3a6b4a	29 ff 00	and #$00ff	            AND #$00FF
.3a6b4d	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a6b50	e2 20		sep #$20	            SEP #$20
.3a6b52	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6b55					done
.3a6b55	20 bb 68	jsr $3a68bb	            JSR SET_DOSSTAT
.3a6b58	28		plp		                PLP
.3a6b59	60		rts		            RTS
.3a6b5a					S_DEL
.3a6b5a	08		php		                PHP
.3a6b5b	c2 30		rep #$30	            REP #$30
.3a6b5d	20 7f 1f	jsr $3a1f7f	            JSR SKIPWS
.3a6b60	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a6b63	20 95 05	jsr $3a0595	            JSR ASS_ARG1_STR
.3a6b66	20 ad 6a	jsr $3a6aad	            JSR COPY2PATHBUF
.3a6b69	22 04 11 00	jsl $001104	path_loaded     JSL FK_DELETE               ; Try to delete the file
.3a6b6d	b0 22		bcs $3a6b91	                BCS done
.3a6b6f	20 bb 68	jsr $3a68bb	            JSR SET_DOSSTAT
.3a6b72	08		php		            PHP
.3a6b73	c2 20		rep #$20	            REP #$20
.3a6b75	48		pha		            PHA
.3a6b76	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6b79	5b		tcd		            TCD
.3a6b7a	68		pla		            PLA
.3a6b7b	28		plp		            PLP
.3a6b7c	e2 20		sep #$20	            SEP #$20
.3a6b7e	a9 13		lda #$13	            LDA #ERR_DELETE
.3a6b80	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6b84	c2 20		rep #$20	            REP #$20
.3a6b86	29 ff 00	and #$00ff	            AND #$00FF
.3a6b89	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a6b8c	e2 20		sep #$20	            SEP #$20
.3a6b8e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6b91					done
.3a6b91	20 bb 68	jsr $3a68bb	            JSR SET_DOSSTAT
.3a6b94	28		plp		                PLP
.3a6b95	60		rts		            RTS
.3a6b96					VALIDFILECHAR
.3a6b96	da		phx		                PHX
.3a6b97	08		php		                PHP
.3a6b98	e2 20		sep #$20	            SEP #$20
.3a6b9a	c9 61		cmp #$61	                CMP #'a'                    ; Is it lower case?
.3a6b9c	90 08		bcc $3a6ba6	                BLT chk_space
.3a6b9e	c9 7b		cmp #$7b	                CMP #'z'+1
.3a6ba0	b0 04		bcs $3a6ba6	                BGE chk_space
.3a6ba2	29 df		and #$df	                AND #%11011111              ; Yes: convert to upper case
.3a6ba4	80 13		bra $3a6bb9	                BRA ret_valid
.3a6ba6	c9 20		cmp #$20	chk_space       CMP #CHAR_SP            ; Is it a control code?
.3a6ba8	90 13		bcc $3a6bbd	                BLT is_invalid          ; Yes: it's invalid
.3a6baa	a2 00 00	ldx #$0000	                LDX #0                  ; See if it's in the list of invalids
.3a6bad	df c1 6b 3a	cmp $3a6bc1,x	loop            CMP invalid_chars,X
.3a6bb1	f0 0a		beq $3a6bbd	                BEQ is_invalid
.3a6bb3	e8		inx		                INX
.3a6bb4	e0 0f 00	cpx #$000f	                CPX #15                 ; # of invalid characters
.3a6bb7	d0 f4		bne $3a6bad	                BNE loop
.3a6bb9	28		plp		ret_valid       PLP
.3a6bba	38		sec		                SEC
.3a6bbb	fa		plx		                PLX
.3a6bbc	6b		rtl		                RTL
.3a6bbd	28		plp		is_invalid      PLP
.3a6bbe	18		clc		                CLC
.3a6bbf	fa		plx		                PLX
.3a6bc0	6b		rtl		                RTL
>3a6bc1	2a 2b 2c 2f 3a 3b 3c 3d		invalid_chars   .text "*+,/:;<=>?\[]|",CHAR_DQUOTE
>3a6bc9	3e 3f 5c 5b 5d 7c 22
.3a6bd0					S_RENAME
.3a6bd0	08		php		                PHP
.3a6bd1	08		php		            PHP
.3a6bd2	c2 20		rep #$20	            REP #$20
.3a6bd4	48		pha		            PHA
.3a6bd5	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a6bd8	5b		tcd		            TCD
.3a6bd9	68		pla		            PLA
.3a6bda	28		plp		            PLP
.3a6bdb	c2 30		rep #$30	            REP #$30
.3a6bdd	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a6be0	20 95 05	jsr $3a0595	            JSR ASS_ARG1_STR
.3a6be3	20 ad 6a	jsr $3a6aad	            JSR COPY2PATHBUF
.3a6be6	22 10 11 00	jsl $001110	                JSL FK_DIRREAD              ; Try to read the file
.3a6bea	b0 22		bcs $3a6c0e	                BCS get_new_name            ; If ok: get the new name
.3a6bec	20 bb 68	jsr $3a68bb	            JSR SET_DOSSTAT
.3a6bef	08		php		            PHP
.3a6bf0	c2 20		rep #$20	            REP #$20
.3a6bf2	48		pha		            PHA
.3a6bf3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6bf6	5b		tcd		            TCD
.3a6bf7	68		pla		            PLA
.3a6bf8	28		plp		            PLP
.3a6bf9	e2 20		sep #$20	            SEP #$20
.3a6bfb	a9 14		lda #$14	            LDA #ERR_FILENOTFOUND
.3a6bfd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6c01	c2 20		rep #$20	            REP #$20
.3a6c03	29 ff 00	and #$00ff	            AND #$00FF
.3a6c06	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a6c09	e2 20		sep #$20	            SEP #$20
.3a6c0b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6c0e					get_new_name
.3a6c0e	e2 20		sep #$20	            SEP #$20
.3a6c10	a9 2c		lda #$2c	                LDA #','
.3a6c12	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a6c15	c2 20		rep #$20	            REP #$20
.3a6c17	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a6c1a	20 95 05	jsr $3a0595	            JSR ASS_ARG1_STR
.3a6c1d	ad 38 03	lda $0338	                LDA DOS_DIR_PTR
.3a6c20	85 08		sta $0808	                STA INDEX
.3a6c22	ad 3a 03	lda $033a	                LDA DOS_DIR_PTR+2
.3a6c25	85 0a		sta $080a	                STA INDEX+2
.3a6c27	e2 20		sep #$20	            SEP #$20
.3a6c29	a2 00 00	ldx #$0000	                LDX #0
.3a6c2c	a9 20		lda #$20	                LDA #CHAR_SP                ; We'll use MLINEBUFF as temporary name storage
.3a6c2e	95 7e		sta $087e,x	blank_loop      STA MLINEBUF,X              ; Fill it with blanks
.3a6c30	e8		inx		                INX
.3a6c31	e0 0b 00	cpx #$000b	                CPX #11
.3a6c34	d0 f8		bne $3a6c2e	                BNE blank_loop
.3a6c36	a2 00 00	ldx #$0000	                LDX #0
.3a6c39	a0 00 00	ldy #$0000	                LDY #0
.3a6c3c	b7 23		lda [$0823],y	name_loop       LDA [ARGUMENT1],Y           ; Get the character of the new name
.3a6c3e	f0 76		beq $3a6cb6	                BEQ copy_short_name         ; If end-of-string: copy what we have
.3a6c40	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.3a6c42	f0 39		beq $3a6c7d	                BEQ skip_dot                ; Yes: move on to the extension characters
.3a6c44	22 96 6b 3a	jsl $3a6b96	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.3a6c48	b0 1f		bcs $3a6c69	                BCS save_nm_char
.3a6c4a	08		php		            PHP
.3a6c4b	c2 20		rep #$20	            REP #$20
.3a6c4d	48		pha		            PHA
.3a6c4e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6c51	5b		tcd		            TCD
.3a6c52	68		pla		            PLA
.3a6c53	28		plp		            PLP
.3a6c54	e2 20		sep #$20	            SEP #$20
.3a6c56	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a6c58	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6c5c	c2 20		rep #$20	            REP #$20
.3a6c5e	29 ff 00	and #$00ff	            AND #$00FF
.3a6c61	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a6c64	e2 20		sep #$20	            SEP #$20
.3a6c66	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6c69	95 7e		sta $087e,x	save_nm_char    STA MLINEBUF,X              ; Otherwise: copy it
.3a6c6b	c8		iny		                INY
.3a6c6c	e8		inx		                INX
.3a6c6d	c0 08 00	cpy #$0008	                CPY #8
.3a6c70	d0 ca		bne $3a6c3c	                BNE name_loop
.3a6c72	b7 23		lda [$0823],y	eat_name        LDA [ARGUMENT1],Y           ; Get the character
.3a6c74	f0 40		beq $3a6cb6	                BEQ copy_short_name         ; If null, we're done with the short name
.3a6c76	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.3a6c78	f0 03		beq $3a6c7d	                BEQ skip_dot                ; Yes: skip over it
.3a6c7a	c8		iny		                INY                         ; No: try again with the the next character
.3a6c7b	80 f5		bra $3a6c72	                BRA eat_name
.3a6c7d	c8		iny		skip_dot        INY                         ; Character at Y is '.', so skip over it
.3a6c7e	a2 08 00	ldx #$0008	do_ext          LDX #8
.3a6c81	b7 23		lda [$0823],y	ext_loop        LDA [ARGUMENT1],Y           ; Get the character of the new extension
.3a6c83	f0 31		beq $3a6cb6	                BEQ copy_short_name         ; If end-of-string: copy what we have
.3a6c85	22 96 6b 3a	jsl $3a6b96	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.3a6c89	b0 22		bcs $3a6cad	                BCS save_ext_char
.3a6c8b	20 bb 68	jsr $3a68bb	            JSR SET_DOSSTAT
.3a6c8e	08		php		            PHP
.3a6c8f	c2 20		rep #$20	            REP #$20
.3a6c91	48		pha		            PHA
.3a6c92	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6c95	5b		tcd		            TCD
.3a6c96	68		pla		            PLA
.3a6c97	28		plp		            PLP
.3a6c98	e2 20		sep #$20	            SEP #$20
.3a6c9a	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a6c9c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6ca0	c2 20		rep #$20	            REP #$20
.3a6ca2	29 ff 00	and #$00ff	            AND #$00FF
.3a6ca5	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a6ca8	e2 20		sep #$20	            SEP #$20
.3a6caa	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6cad	95 7e		sta $087e,x	save_ext_char   STA MLINEBUF,X              ; Otherwise: copy it
.3a6caf	c8		iny		                INY
.3a6cb0	e8		inx		                INX
.3a6cb1	c0 0c 00	cpy #$000c	                CPY #12
.3a6cb4	d0 cb		bne $3a6c81	                BNE ext_loop
.3a6cb6	a2 00 00	ldx #$0000	copy_short_name LDX #0                      ; Copy the short name we built to the directory entry
.3a6cb9	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME
.3a6cbc	b5 7e		lda $087e,x	copy_loop       LDA MLINEBUF,X
.3a6cbe	97 08		sta [$0808],y	                STA [INDEX],Y
.3a6cc0	e8		inx		                INX
.3a6cc1	c8		iny		                INY
.3a6cc2	c0 0b 00	cpy #$000b	                CPY #11
.3a6cc5	d0 f5		bne $3a6cbc	                BNE copy_loop
.3a6cc7	22 14 11 00	jsl $001114	                JSL FK_DIRWRITE             ; Write the directory entry back
.3a6ccb	b0 22		bcs $3a6cef	                BCS done
.3a6ccd	20 bb 68	jsr $3a68bb	            JSR SET_DOSSTAT
.3a6cd0	08		php		            PHP
.3a6cd1	c2 20		rep #$20	            REP #$20
.3a6cd3	48		pha		            PHA
.3a6cd4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6cd7	5b		tcd		            TCD
.3a6cd8	68		pla		            PLA
.3a6cd9	28		plp		            PLP
.3a6cda	e2 20		sep #$20	            SEP #$20
.3a6cdc	a9 15		lda #$15	            LDA #ERR_DIRNOTWRITE
.3a6cde	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6ce2	c2 20		rep #$20	            REP #$20
.3a6ce4	29 ff 00	and #$00ff	            AND #$00FF
.3a6ce7	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a6cea	e2 20		sep #$20	            SEP #$20
.3a6cec	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6cef					done
.3a6cef	20 bb 68	jsr $3a68bb	            JSR SET_DOSSTAT
.3a6cf2	28		plp		                PLP
.3a6cf3	60		rts		            RTS
.3a6cf4					S_COPY
.3a6cf4	08		php		                PHP
.3a6cf5	08		php		            PHP
.3a6cf6	c2 20		rep #$20	            REP #$20
.3a6cf8	48		pha		            PHA
.3a6cf9	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a6cfc	5b		tcd		            TCD
.3a6cfd	68		pla		            PLA
.3a6cfe	28		plp		            PLP
.3a6cff	c2 30		rep #$30	            REP #$30
.3a6d01	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a6d04	20 95 05	jsr $3a0595	            JSR ASS_ARG1_STR
.3a6d07	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.3a6d09	8f 64 03 00	sta $000364	                STA @l DOS_STR1_PTR
.3a6d0d	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6d0f	8f 66 03 00	sta $000366	                STA @l DOS_STR1_PTR+2
.3a6d13	e2 20		sep #$20	            SEP #$20
.3a6d15	a9 2c		lda #$2c	                LDA #','
.3a6d17	20 6b 20	jsr $3a206b	            JSR EXPECT_TOK
.3a6d1a	c2 20		rep #$20	            REP #$20
.3a6d1c	20 4d 1b	jsr $3a1b4d	            JSR EVALEXPR
.3a6d1f	20 95 05	jsr $3a0595	            JSR ASS_ARG1_STR
.3a6d22	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.3a6d24	8f 68 03 00	sta $000368	                STA @l DOS_STR2_PTR
.3a6d28	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6d2a	8f 6a 03 00	sta $00036a	                STA @l DOS_STR2_PTR+2
.3a6d2e	22 30 11 00	jsl $001130	                JSL FK_COPY                 ; Attempt to copy the file
.3a6d32	b0 1f		bcs $3a6d53	                BCS done
.3a6d34	08		php		            PHP
.3a6d35	c2 20		rep #$20	            REP #$20
.3a6d37	48		pha		            PHA
.3a6d38	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6d3b	5b		tcd		            TCD
.3a6d3c	68		pla		            PLA
.3a6d3d	28		plp		            PLP
.3a6d3e	e2 20		sep #$20	            SEP #$20
.3a6d40	a9 16		lda #$16	            LDA #ERR_NOTCOPIED
.3a6d42	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6d46	c2 20		rep #$20	            REP #$20
.3a6d48	29 ff 00	and #$00ff	            AND #$00FF
.3a6d4b	20 9f 1c	jsr $3a1c9f	            JSR SET_ERRERL
.3a6d4e	e2 20		sep #$20	            SEP #$20
.3a6d50	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6d53	28		plp		done            PLP
.3a6d54	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\monitor.s

.3a6d55	5c 15 87 3a	jmp $3a8715	MRETURN         JML IMRETURN
.3a6d59	5c 66 85 3a	jmp $3a8566	MPARSE          JML IMPARSE
.3a6d5d	5c 16 87 3a	jmp $3a8716	MPARSE1         JML IMPARSE1
.3a6d61	5c 92 76 3a	jmp $3a7692	MEXECUTE        JML IMEXECUTE
.3a6d65	5c ef 76 3a	jmp $3a76ef	MASSEMBLE       JML IMASSEMBLE
.3a6d69	5c 22 76 3a	jmp $3a7622	MRMODIFY        JML IMRMODIFY
.3a6d6d	5c a8 75 3a	jmp $3a75a8	MCOMPARE        JML IMCOMPARE
.3a6d71	5c 25 7b 3a	jmp $3a7b25	MDISASSEMBLE    JML IMDISASSEMBLE
.3a6d75	5c 13 72 3a	jmp $3a7213	MFILL           JML IMFILL
.3a6d79	5c 40 75 3a	jmp $3a7540	MGO             JML IMGO
.3a6d7d	5c fb 74 3a	jmp $3a74fb	MJUMP           JML IMJUMP
.3a6d81	5c 85 74 3a	jmp $3a7485	MHUNT           JML IMHUNT
.3a6d85	5c 24 86 3a	jmp $3a8624	MLOAD           JML IMLOAD
.3a6d89	5c 21 73 3a	jmp $3a7321	MMEMORY         JML IMMEMORY
.3a6d8d	5c 74 71 3a	jmp $3a7174	MREGISTERS      JML IMREGISTERS
.3a6d91	5c 9f 86 3a	jmp $3a869f	MSAVE           JML IMSAVE
.3a6d95	5c 4f 72 3a	jmp $3a724f	MTRANSFER       JML IMTRANSFER
.3a6d99	5c 18 87 3a	jmp $3a8718	MVERIFY         JML IMVERIFY
.3a6d9d	5c 11 87 3a	jmp $3a8711	MEXIT           JML IMEXIT
.3a6da1	5c 3e 74 3a	jmp $3a743e	MMODIFY         JML IMMODIFY
.3a6da5	5c 19 87 3a	jmp $3a8719	MDOS            JML IMDOS
.3a6da9	18		clc		IMONITOR        CLC                 ; clear the carry flag
.3a6daa	fb		xce		                XCE                 ; move carry to emulation flags
.3a6dab	c2 20		rep #$20	            REP #$20
.3a6dad	a9 ff fe	lda #$feff	                LDA #STACK_END      ; Reset the stack
.3a6db0	1b		tcs		                TAS
.3a6db1	58		cli		                CLI                 ; Re-enable interrupts
.3a6db2	5c b6 6d 3a	jmp $3a6db6	                JML IMREADY
.3a6db6					IMREADY
.3a6db6	c2 30		rep #$30	            REP #$30
.3a6db8	22 74 71 3a	jsl $3a7174	                JSL IMREGISTERS
.3a6dbc					ready_loop
.3a6dbc	20 08 00	jsr $3a0008	            JSR READLINE
.3a6dbf	20 0c 00	jsr $3a000c	            JSR SCRCOPYLINE
.3a6dc2	8b		phb		                PHB
.3a6dc3	e2 20		sep #$20	            SEP #$20
.3a6dc5	a9 00		lda #$00	                LDA #`INPUTBUF
.3a6dc7	48		pha		                PHA
.3a6dc8	ab		plb		                PLB
.3a6dc9	a2 00 4f	ldx #$4f00	                LDX #<>INPUTBUF
.3a6dcc	20 17 04	jsr $3a0417	            JSR TOUPPER
.3a6dcf	ab		plb		                PLB
.3a6dd0	22 59 6d 3a	jsl $3a6d59	                JSL MPARSE          ; Parse the command
.3a6dd4	22 61 6d 3a	jsl $3a6d61	                JSL MEXECUTE        ; And execute the parsed command
.3a6dd8	80 e2		bra $3a6dbc	                BRA ready_loop
.3a6dda					IMHELP
.3a6dda	08		php		                PHP
.3a6ddb	8b		phb		                PHB
.3a6ddc	e2 20		sep #$20	            SEP #$20
.3a6dde	a9 3a		lda #$3a	                LDA #`help_text
.3a6de0	48		pha		                PHA
.3a6de1	ab		plb		                PLB
.3a6de2	c2 10		rep #$10	            REP #$10
.3a6de4	a2 ed 6d	ldx #$6ded	                LDX #<>help_text
.3a6de7	20 16 03	jsr $3a0316	            JSR PRINTS
.3a6dea	ab		plb		                PLB
.3a6deb	28		plp		                PLP
.3a6dec	6b		rtl		                RTL
>3a6ded	41 20 3c 73 74 61 72 74		help_text       .text "A <start> <assembly>",CHAR_CR
>3a6df5	3e 20 3c 61 73 73 65 6d 62 6c 79 3e 0d
>3a6e02	20 20 41 73 73 65 6d 62		                .text "  Assemble a program",CHAR_CR,CHAR_CR
>3a6e0a	6c 65 20 61 20 70 72 6f 67 72 61 6d 0d 0d
>3a6e18	43 20 3c 73 74 61 72 74		                .text "C <start1> <start2> [len (1 if blank)]",CHAR_CR
>3a6e20	31 3e 20 3c 73 74 61 72 74 32 3e 20 5b 6c 65 6e
>3a6e30	20 28 31 20 69 66 20 62 6c 61 6e 6b 29 5d 0d
>3a6e3f	20 20 43 6f 6d 70 61 72		                .text "  Compare to sections of memory",CHAR_CR,CHAR_CR
>3a6e47	65 20 74 6f 20 73 65 63 74 69 6f 6e 73 20 6f 66
>3a6e57	20 6d 65 6d 6f 72 79 0d 0d
>3a6e60	44 20 3c 73 74 61 72 74		                .text "D <start> [end]",CHAR_CR
>3a6e68	3e 20 5b 65 6e 64 5d 0d
>3a6e70	20 20 44 69 73 61 73 73		                .text "  Disassemble a program",CHAR_CR,CHAR_CR
>3a6e78	65 6d 62 6c 65 20 61 20 70 72 6f 67 72 61 6d 0d
>3a6e88	0d
>3a6e89	46 20 3c 73 74 61 72 74		                .text "F <start> <end> <byte>",CHAR_CR
>3a6e91	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 0d
>3a6ea0	20 20 46 69 6c 6c 20 61		                .text "  Fill a block of memory with a byte",CHAR_CR,CHAR_CR
>3a6ea8	20 62 6c 6f 63 6b 20 6f 66 20 6d 65 6d 6f 72 79
>3a6eb8	20 77 69 74 68 20 61 20 62 79 74 65 0d 0d
>3a6ec6	47 20 5b 61 64 64 72 65		                .text "G [address]",CHAR_CR
>3a6ece	73 73 5d 0d
>3a6ed2	20 20 53 74 61 72 74 20		                .text "  Start execution at a location",CHAR_CR,CHAR_CR
>3a6eda	65 78 65 63 75 74 69 6f 6e 20 61 74 20 61 20 6c
>3a6eea	6f 63 61 74 69 6f 6e 0d 0d
>3a6ef3	4a 20 5b 61 64 64 72 65		                .text "J [address] - Jump to a location in memory",CHAR_CR
>3a6efb	73 73 5d 20 2d 20 4a 75 6d 70 20 74 6f 20 61 20
>3a6f0b	6c 6f 63 61 74 69 6f 6e 20 69 6e 20 6d 65 6d 6f
>3a6f1b	72 79 0d
>3a6f1e	20 20 4a 75 6d 70 20 74		                .text "  Jump to a location in memory",CHAR_CR,CHAR_CR
>3a6f26	6f 20 61 20 6c 6f 63 61 74 69 6f 6e 20 69 6e 20
>3a6f36	6d 65 6d 6f 72 79 0d 0d
>3a6f3e	48 20 3c 73 74 61 72 74		                .text "H <start> <end> <byte> [byte]..",CHAR_CR
>3a6f46	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 20 5b
>3a6f56	62 79 74 65 5d 2e 2e 0d
>3a6f5e	20 20 48 75 6e 74 20 66		                .text "  Hunt for values in memory",CHAR_CR,CHAR_CR
>3a6f66	6f 72 20 76 61 6c 75 65 73 20 69 6e 20 6d 65 6d
>3a6f76	6f 72 79 0d 0d
>3a6f7b	4c 20 20 20 20 20 4c 4f		                .text "L     LOAD         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," [destination]",CHAR_CR
>3a6f83	41 44 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>3a6f93	22 20 5b 64 65 73 74 69 6e 61 74 69 6f 6e 5d 0d
>3a6fa3	4d 20 3c 73 74 61 72 74		                .text "M <start> [end]",CHAR_CR
>3a6fab	3e 20 5b 65 6e 64 5d 0d
>3a6fb3	20 20 44 75 6d 70 20 74		                .text "  Dump the value in memory",CHAR_CR,CHAR_CR
>3a6fbb	68 65 20 76 61 6c 75 65 20 69 6e 20 6d 65 6d 6f
>3a6fcb	72 79 0d 0d
>3a6fcf	52 20 2d 20 44 69 73 70		                .text "R - Display the values of the registers",CHAR_CR,CHAR_CR
>3a6fd7	6c 61 79 20 74 68 65 20 76 61 6c 75 65 73 20 6f
>3a6fe7	66 20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d
>3a6ff7	0d
>3a6ff8	3b 20 3c 50 43 3e 20 3c		                .text "; <PC> <A> <X> <Y> <SP> <DBR> <DP> <NVMXDIZC>",CHAR_CR
>3a7000	41 3e 20 3c 58 3e 20 3c 59 3e 20 3c 53 50 3e 20
>3a7010	3c 44 42 52 3e 20 3c 44 50 3e 20 3c 4e 56 4d 58
>3a7020	44 49 5a 43 3e 0d
>3a7026	20 20 43 68 61 6e 67 65		                .text "  Change the contents of the registers",CHAR_CR,CHAR_CR
>3a702e	20 74 68 65 20 63 6f 6e 74 65 6e 74 73 20 6f 66
>3a703e	20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d 0d
>3a704e	53 20 20 20 20 20 53 41		                .text "S     SAVE         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," <start> <end>",CHAR_CR
>3a7056	56 45 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>3a7066	22 20 3c 73 74 61 72 74 3e 20 3c 65 6e 64 3e 0d
>3a7076	54 20 3c 73 74 61 72 74		                .text "T <start> <end> <destination>",CHAR_CR
>3a707e	3e 20 3c 65 6e 64 3e 20 3c 64 65 73 74 69 6e 61
>3a708e	74 69 6f 6e 3e 0d
>3a7094	20 20 54 72 61 6e 73 66		                .text "  Transfer (copy) data within memory",CHAR_CR,CHAR_CR
>3a709c	65 72 20 28 63 6f 70 79 29 20 64 61 74 61 20 77
>3a70ac	69 74 68 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>3a70ba	57 20 3c 62 79 74 65 3e		                .text "W <byte>",CHAR_CR
>3a70c2	0d
>3a70c3	20 20 53 65 74 20 74 68		                .text "  Set the register width flags for the disassembler",CHAR_CR,CHAR_CR
>3a70cb	65 20 72 65 67 69 73 74 65 72 20 77 69 64 74 68
>3a70db	20 66 6c 61 67 73 20 66 6f 72 20 74 68 65 20 64
>3a70eb	69 73 61 73 73 65 6d 62 6c 65 72 0d 0d
>3a70f8	58 20 2d 20 52 65 74 75		                .text "X - Return to BASIC",CHAR_CR,CHAR_CR
>3a7100	72 6e 20 74 6f 20 42 41 53 49 43 0d 0d
>3a710d	3e 20 3c 73 74 61 72 74		                .text "> <start> <byte> [byte]...",CHAR_CR
>3a7115	3e 20 3c 62 79 74 65 3e 20 5b 62 79 74 65 5d 2e
>3a7125	2e 2e 0d
>3a7128	20 20 45 64 69 74 20 64		                .text "  Edit data in memory",CHAR_CR,CHAR_CR
>3a7130	61 74 61 20 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>3a713f	3f 20 2d 20 44 69 73 70		                .null "? - Display a short help screen",CHAR_CR,CHAR_CR
>3a7147	6c 61 79 20 61 20 73 68 6f 72 74 20 68 65 6c 70
>3a7157	20 73 63 72 65 65 6e 0d 0d 00
.3a7161					IMWIDTH
.3a7161	08		php		                PHP
.3a7162	08		php		            PHP
.3a7163	c2 20		rep #$20	            REP #$20
.3a7165	48		pha		            PHA
.3a7166	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7169	5b		tcd		            TCD
.3a716a	68		pla		            PLA
.3a716b	28		plp		            PLP
.3a716c	e2 20		sep #$20	            SEP #$20
.3a716e	a5 0d		lda $0855	                LDA MARG1
.3a7170	85 4e		sta $0896	                STA MCPUSTAT
.3a7172	28		plp		                PLP
.3a7173	6b		rtl		                RTL
.3a7174					IMREGISTERS
.3a7174	20 e4 00	jsr $3a00e4	            JSR ENSURETEXT
.3a7177	08		php		            PHP
.3a7178	e2 20		sep #$20	            SEP #$20
.3a717a	48		pha		            PHA
.3a717b	a9 3a		lda #$3a	            LDA #`mregisters_msg
.3a717d	48		pha		            PHA
.3a717e	ab		plb		            PLB
.3a717f	68		pla		            PLA
.3a7180	28		plp		            PLP
.3a7181	a2 56 87	ldx #$8756	                LDX #<>mregisters_msg
.3a7184	20 16 03	jsr $3a0316	            JSR PRINTS
.3a7187	e2 20		sep #$20	            SEP #$20
.3a7189	a9 3b		lda #$3b	                LDA #';'
.3a718b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a718e	a9 20		lda #$20	                LDA #' '
.3a7190	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7193	c2 30		rep #$30	            REP #$30
.3a7195	08		php		            PHP
.3a7196	e2 20		sep #$20	            SEP #$20
.3a7198	48		pha		            PHA
.3a7199	a9 00		lda #$00	            LDA #$0
.3a719b	48		pha		            PHA
.3a719c	ab		plb		            PLB
.3a719d	68		pla		            PLA
.3a719e	28		plp		            PLP
.3a719f	a0 03 00	ldy #$0003	                LDY #3
.3a71a2	a2 42 02	ldx #$0242	                LDX #CPUPC+2
.3a71a5	20 99 02	jsr $3a0299	            JSR PRINTH
.3a71a8	c2 20		rep #$20	            REP #$20
.3a71aa	a9 20 00	lda #$0020	                LDA #' '
.3a71ad	20 18 00	jsr $3a0018	            JSR PRINTC
.3a71b0	af 44 02 00	lda $000244	                LDA @lCPUA
.3a71b4	20 26 03	jsr $3a0326	            JSR PRHEXW
.3a71b7	a9 20 00	lda #$0020	                LDA #' '
.3a71ba	20 18 00	jsr $3a0018	            JSR PRINTC
.3a71bd	af 46 02 00	lda $000246	                LDA @lCPUX
.3a71c1	20 26 03	jsr $3a0326	            JSR PRHEXW
.3a71c4	a9 20 00	lda #$0020	                LDA #' '
.3a71c7	20 18 00	jsr $3a0018	            JSR PRINTC
.3a71ca	af 48 02 00	lda $000248	                LDA @lCPUY
.3a71ce	20 26 03	jsr $3a0326	            JSR PRHEXW
.3a71d1	a9 20 00	lda #$0020	                LDA #' '
.3a71d4	20 18 00	jsr $3a0018	            JSR PRINTC
.3a71d7	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK
.3a71db	20 26 03	jsr $3a0326	            JSR PRHEXW
.3a71de	a9 20 00	lda #$0020	                LDA #' '
.3a71e1	20 18 00	jsr $3a0018	            JSR PRINTC
.3a71e4	af 4e 02 00	lda $00024e	                LDA @lCPUDBR
.3a71e8	20 40 03	jsr $3a0340	            JSR PRHEXB
.3a71eb	a9 20 00	lda #$0020	                LDA #' '
.3a71ee	20 18 00	jsr $3a0018	            JSR PRINTC
.3a71f1	20 18 00	jsr $3a0018	            JSR PRINTC
.3a71f4	af 4c 02 00	lda $00024c	                LDA @lCPUDP
.3a71f8	20 26 03	jsr $3a0326	            JSR PRHEXW
.3a71fb	a9 20 00	lda #$0020	                LDA #' '
.3a71fe	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7201	08		php		                PHP
.3a7202	e2 20		sep #$20	            SEP #$20
.3a7204	ad 4f 02	lda $024f	                LDA CPUFLAGS
.3a7207	22 6f 84 3a	jsl $3a846f	                JSL MPRINTB
.3a720b	28		plp		                PLP
.3a720c	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a720f	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a7212	6b		rtl		                RTL
.3a7213					IMFILL
.3a7213	08		php		                PHP                 ; Save the caller's context
.3a7214	0b		phd		                PHD
.3a7215	08		php		            PHP
.3a7216	c2 20		rep #$20	            REP #$20
.3a7218	48		pha		            PHA
.3a7219	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a721c	5b		tcd		            TCD
.3a721d	68		pla		            PLA
.3a721e	28		plp		            PLP
.3a721f					do_copy
.3a721f	e2 20		sep #$20	            SEP #$20
.3a7221	a5 15		lda $085d	                LDA MARG3
.3a7223	87 0d		sta [$0855]	                STA [MARG1]
.3a7225	e2 20		sep #$20	            SEP #$20
.3a7227	a5 0f		lda $0857	                LDA MARG1+2
.3a7229	c5 13		cmp $085b	                CMP MARG2+2
.3a722b	d0 0e		bne $3a723b	                BNE go_next         ; No: we haven't reached end address yet
.3a722d	c2 20		rep #$20	            REP #$20
.3a722f	a5 0d		lda $0855	                LDA MARG1
.3a7231	c5 11		cmp $0859	                CMP MARG2           ; Are they equal?
.3a7233	d0 06		bne $3a723b	                BNE go_next         ; No: we haven't reached end address yet
.3a7235	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a7238	2b		pld		                PLD                 ; Restore the caller's context
.3a7239	28		plp		                PLP
.3a723a	6b		rtl		                RTL
.3a723b					go_next
.3a723b	c2 20		rep #$20	            REP #$20
.3a723d	18		clc		                CLC
.3a723e	a5 0d		lda $0855	                LDA MARG1
.3a7240	69 01 00	adc #$0001	                ADC #1
.3a7243	85 0d		sta $0855	                STA MARG1
.3a7245	e2 20		sep #$20	            SEP #$20
.3a7247	a5 0e		lda $0856	                LDA MARG1+1
.3a7249	69 00		adc #$00	                ADC #0
.3a724b	85 0e		sta $0856	                STA MARG1+1
.3a724d	80 d0		bra $3a721f	                BRA do_copy
.3a724f					IMTRANSFER
.3a724f	08		php		                PHP
.3a7250	0b		phd		                PHD
.3a7251	08		php		            PHP
.3a7252	c2 20		rep #$20	            REP #$20
.3a7254	48		pha		            PHA
.3a7255	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7258	5b		tcd		            TCD
.3a7259	68		pla		            PLA
.3a725a	28		plp		            PLP
.3a725b	e2 20		sep #$20	            SEP #$20
.3a725d	a5 0f		lda $0857	                LDA MARG1+2
.3a725f	c5 17		cmp $085f	                CMP MARG3+2
.3a7261	90 45		bcc $3a72a8	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.3a7263	c2 20		rep #$20	            REP #$20
.3a7265	a5 0d		lda $0855	                LDA MARG1
.3a7267	c5 15		cmp $085d	                CMP MARG3
.3a7269	90 3d		bcc $3a72a8	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.3a726b					copy_byte_down
.3a726b	e2 20		sep #$20	            SEP #$20
.3a726d	a7 0d		lda [$0855]	                LDA [MARG1]         ; Copy the byte
.3a726f	87 15		sta [$085d]	                STA [MARG3]
.3a7271	a5 0f		lda $0857	                LDA MARG1+2         ; Are the source's current and end bank bytes equal?
.3a7273	c5 13		cmp $085b	                CMP MARG2+2
.3a7275	d0 0b		bne $3a7282	                BNE inc_pointers    ; No: we're not done yet
.3a7277	c2 20		rep #$20	            REP #$20
.3a7279	a5 0d		lda $0855	                LDA MARG1           ; Are the rest of the bits equal?
.3a727b	c5 11		cmp $0859	                CMP MARG2
.3a727d	d0 03		bne $3a7282	                BNE inc_pointers    ; No: we're not done yet
.3a727f	4c 06 73	jmp $3a7306	                JMP done            ; Yes: we've copied the last byte, exit
.3a7282					inc_pointers
.3a7282	c2 20		rep #$20	            REP #$20
.3a7284	18		clc		                CLC
.3a7285	a5 0d		lda $0855	                LDA MARG1
.3a7287	69 01 00	adc #$0001	                ADC #1
.3a728a	85 0d		sta $0855	                STA MARG1
.3a728c	e2 20		sep #$20	            SEP #$20
.3a728e	a5 0e		lda $0856	                LDA MARG1+1
.3a7290	69 00		adc #$00	                ADC #0
.3a7292	85 0e		sta $0856	                STA MARG1+1
.3a7294	c2 20		rep #$20	            REP #$20
.3a7296	18		clc		                CLC
.3a7297	a5 15		lda $085d	                LDA MARG3
.3a7299	69 01 00	adc #$0001	                ADC #1
.3a729c	85 15		sta $085d	                STA MARG3
.3a729e	e2 20		sep #$20	            SEP #$20
.3a72a0	a5 16		lda $085e	                LDA MARG3+1
.3a72a2	69 00		adc #$00	                ADC #0
.3a72a4	85 16		sta $085e	                STA MARG3+1
.3a72a6	80 c3		bra $3a726b	                BRA copy_byte_down  ; And copy that next byte over
.3a72a8					copy_up
.3a72a8	c2 20		rep #$20	            REP #$20
.3a72aa	38		sec		                SEC
.3a72ab	a5 11		lda $0859	                LDA MARG2
.3a72ad	e5 0d		sbc $0855	                SBC MARG1
.3a72af	85 19		sta $0861	                STA MARG4
.3a72b1	e2 20		sep #$20	            SEP #$20
.3a72b3	a5 13		lda $085b	                LDA MARG2+2
.3a72b5	e5 0f		sbc $0857	                SBC MARG1+2
.3a72b7	85 1b		sta $0863	                STA MARG4+2
.3a72b9	c2 20		rep #$20	            REP #$20
.3a72bb	18		clc		                CLC
.3a72bc	a5 19		lda $0861	                LDA MARG4
.3a72be	65 15		adc $085d	                ADC MARG3
.3a72c0	85 15		sta $085d	                STA MARG3
.3a72c2	e2 20		sep #$20	            SEP #$20
.3a72c4	a5 1b		lda $0863	                LDA MARG4+2
.3a72c6	65 17		adc $085f	                ADC MARG3+2
.3a72c8	85 17		sta $085f	                STA MARG3+2
.3a72ca					copy_byte_up
.3a72ca	e2 20		sep #$20	            SEP #$20
.3a72cc	a7 11		lda [$0859]	                LDA [MARG2]
.3a72ce	87 15		sta [$085d]	                STA [MARG3]
.3a72d0	a5 13		lda $085b	                LDA MARG2+2         ; Are the source's current and start bank bytes equal?
.3a72d2	c5 0f		cmp $0857	                CMP MARG1+2
.3a72d4	d0 0a		bne $3a72e0	                BNE dec_pointers    ; No: we're not done yet
.3a72d6	c2 20		rep #$20	            REP #$20
.3a72d8	a5 11		lda $0859	                LDA MARG2           ; Are the rest of the bits equal?
.3a72da	c5 0d		cmp $0855	                CMP MARG1
.3a72dc	d0 02		bne $3a72e0	                BNE dec_pointers    ; No: we're not done yet
.3a72de	80 26		bra $3a7306	                BRA done            ; Yes: we've copied the last byte, exit
.3a72e0					dec_pointers
.3a72e0	c2 20		rep #$20	            REP #$20
.3a72e2	38		sec		                SEC
.3a72e3	a5 11		lda $0859	                LDA MARG2
.3a72e5	e9 01 00	sbc #$0001	                SBC #1
.3a72e8	85 11		sta $0859	                STA MARG2
.3a72ea	e2 20		sep #$20	            SEP #$20
.3a72ec	a5 12		lda $085a	                LDA MARG2+1
.3a72ee	e9 00		sbc #$00	                SBC #0
.3a72f0	85 12		sta $085a	                STA MARG2+1
.3a72f2	c2 20		rep #$20	            REP #$20
.3a72f4	38		sec		                SEC                 ; Decrement the current destination pointer (MARG3)
.3a72f5	a5 15		lda $085d	                LDA MARG3
.3a72f7	e9 01 00	sbc #$0001	                SBC #1
.3a72fa	85 15		sta $085d	                STA MARG3
.3a72fc	e2 20		sep #$20	            SEP #$20
.3a72fe	a5 16		lda $085e	                LDA MARG3+1
.3a7300	e9 00		sbc #$00	                SBC #0
.3a7302	85 16		sta $085e	                STA MARG3+1
.3a7304	80 c4		bra $3a72ca	                BRA copy_byte_up    ; And copy that next byte
.3a7306					done
.3a7306	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a7309	2b		pld		                PLD
.3a730a	28		plp		                PLP
.3a730b	6b		rtl		                RTL
.3a730c					IS_PRINTABLE
.3a730c	08		php		                PHP
.3a730d	e2 20		sep #$20	            SEP #$20
.3a730f	c9 21		cmp #$21	                CMP #33
.3a7311	90 0b		bcc $3a731e	                BLT not_printable   ; 0 .. 31 are not printable
.3a7313	c9 7f		cmp #$7f	                CMP #127
.3a7315	90 04		bcc $3a731b	                BLT printable       ; 32 .. 126 are printable
.3a7317	c9 a0		cmp #$a0	                CMP #160
.3a7319	90 03		bcc $3a731e	                BLT not_printable   ; 127 .. 159 are not printable (assuming Latin-1)
.3a731b	28		plp		printable       PLP
.3a731c	38		sec		                SEC
.3a731d	6b		rtl		                RTL
.3a731e	28		plp		not_printable   PLP
.3a731f	18		clc		                CLC
.3a7320	6b		rtl		                RTL
=256					MMEMDUMPSIZE = 256  ; Default number of bytes to dump
=8					MMEMROWSIZE = 8    ; Number of bytes to dump per-row
.3a7321					IMMEMORY
.3a7321	08		php		                PHP
.3a7322	8b		phb		                PHB
.3a7323	0b		phd		                PHD
.3a7324	08		php		            PHP
.3a7325	c2 20		rep #$20	            REP #$20
.3a7327	48		pha		            PHA
.3a7328	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a732b	5b		tcd		            TCD
.3a732c	68		pla		            PLA
.3a732d	28		plp		            PLP
.3a732e	e2 20		sep #$20	            SEP #$20
.3a7330	a9 00		lda #$00	                LDA #0              ; Clear the pagination line counter
.3a7332	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT
.3a7336	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.3a7338	c9 02		cmp #$02	                CMP #2
.3a733a	b0 16		bcs $3a7352	                BGE set_cursor      ; 2>= arguments? Use them as-is
.3a733c	c9 01		cmp #$01	                CMP #1
.3a733e	90 20		bcc $3a7360	                BLT no_args         ; No arguments passed? Use defaults
.3a7340	c2 20		rep #$20	            REP #$20
.3a7342	18		clc		                CLC
.3a7343	a5 0d		lda $0855	                LDA MARG1
.3a7345	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.3a7348	85 11		sta $0859	                STA MARG2
.3a734a	e2 20		sep #$20	            SEP #$20
.3a734c	a5 0f		lda $0857	                LDA MARG1+2
.3a734e	69 00		adc #$00	                ADC #0
.3a7350	85 13		sta $085b	                STA MARG2+2
.3a7352					set_cursor
.3a7352	c2 20		rep #$20	            REP #$20
.3a7354	a5 0d		lda $0855	                LDA MARG1
.3a7356	85 32		sta $087a	                STA MCURSOR
.3a7358	e2 20		sep #$20	            SEP #$20
.3a735a	a5 0f		lda $0857	                LDA MARG1+2
.3a735c	85 34		sta $087c	                STA MCURSOR+2
.3a735e	80 12		bra $3a7372	                BRA dump_line
.3a7360					no_args
.3a7360	c2 20		rep #$20	            REP #$20
.3a7362	18		clc		                CLC
.3a7363	a5 32		lda $087a	                LDA MCURSOR
.3a7365	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.3a7368	85 11		sta $0859	                STA MARG2
.3a736a	e2 20		sep #$20	            SEP #$20
.3a736c	a5 34		lda $087c	                LDA MCURSOR+2
.3a736e	69 00		adc #$00	                ADC #0
.3a7370	85 13		sta $085b	                STA MARG2+2
.3a7372					dump_line
.3a7372	e2 20		sep #$20	            SEP #$20
.3a7374	a0 00 00	ldy #$0000	                LDY #0
.3a7377	c2 20		rep #$20	            REP #$20
.3a7379	a5 32		lda $087a	                LDA MCURSOR             ; NOTE: the use of MARG4 here is a temporary
.3a737b	85 19		sta $0861	                STA MARG4               ; hack. the copy_loop instruction does not
.3a737d	e2 20		sep #$20	            SEP #$20
.3a737f	a5 34		lda $087c	                LDA MCURSOR+2
.3a7381	85 1b		sta $0863	                STA MARG4+2
.3a7383	e2 20		sep #$20	            SEP #$20
.3a7385	a7 19		lda [$0861]	copy_loop       LDA [MARG4]             ; TODO: Should be LDA [MCURSOR],Y, which doesn't seem to be working
.3a7387	22 0c 73 3a	jsl $3a730c	                JSL IS_PRINTABLE        ; Is it printable?
.3a738b	b0 02		bcs $3a738f	                BCS buffer_char         ; Yes: go ahead and add it to the line buffer
.3a738d	a9 3f		lda #$3f	                LDA #'?'                ; No: replace it with dot
.3a738f	99 7e 08	sta $087e,y	buffer_char     STA #MLINEBUF,B,Y
.3a7392	c2 20		rep #$20	            REP #$20
.3a7394	18		clc		                CLC
.3a7395	a5 19		lda $0861	                LDA MARG4
.3a7397	69 01 00	adc #$0001	                ADC #1
.3a739a	85 19		sta $0861	                STA MARG4
.3a739c	e2 20		sep #$20	            SEP #$20
.3a739e	a5 1b		lda $0863	                LDA MARG4+2
.3a73a0	69 00		adc #$00	                ADC #0
.3a73a2	85 1b		sta $0863	                STA MARG4+2
.3a73a4	c8		iny		                INY
.3a73a5	c0 08 00	cpy #$0008	                CPY #MMEMROWSIZE
.3a73a8	90 db		bcc $3a7385	                BLT copy_loop
.3a73aa	a9 00		lda #$00	                LDA #0
.3a73ac	99 7e 08	sta $087e,y	                STA #MLINEBUF,B,Y
.3a73af	a9 3e		lda #$3e	                LDA #'>'
.3a73b1	20 18 00	jsr $3a0018	            JSR PRINTC
.3a73b4	a9 20		lda #$20	                LDA #' '
.3a73b6	20 18 00	jsr $3a0018	            JSR PRINTC
.3a73b9	e2 20		sep #$20	            SEP #$20
.3a73bb	a5 34		lda $087c	                LDA MCURSOR+2
.3a73bd	20 40 03	jsr $3a0340	            JSR PRHEXB
.3a73c0	a9 3a		lda #$3a	                LDA #':'                ; then a colon
.3a73c2	20 18 00	jsr $3a0018	            JSR PRINTC
.3a73c5	c2 20		rep #$20	            REP #$20
.3a73c7	a5 32		lda $087a	                LDA MCURSOR
.3a73c9	20 26 03	jsr $3a0326	            JSR PRHEXW
.3a73cc	c2 20		rep #$20	            REP #$20
.3a73ce	a9 08 00	lda #$0008	                LDA #MMEMROWSIZE
.3a73d1	85 47		sta $088f	                STA MCOUNT
.3a73d3					prhex_loop
.3a73d3	e2 20		sep #$20	            SEP #$20
.3a73d5	a9 20		lda #$20	                LDA #' '
.3a73d7	20 18 00	jsr $3a0018	            JSR PRINTC
.3a73da	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a73dc	20 40 03	jsr $3a0340	            JSR PRHEXB
.3a73df	22 4e 84 3a	jsl $3a844e	                JSL M_INC_CURSOR        ; Point MCURSOR to the next byte
.3a73e3					check_line
.3a73e3	e2 20		sep #$20	            SEP #$20
.3a73e5	c6 47		dec $088f	                DEC MCOUNT              ; Count down the number of bytes on the row
.3a73e7	d0 ea		bne $3a73d3	                BNE prhex_loop          ; If we're not at zero, keep looping over the bytes
.3a73e9	a9 20		lda #$20	                LDA #' '
.3a73eb	20 18 00	jsr $3a0018	            JSR PRINTC
.3a73ee	a9 20		lda #$20	                LDA #' '
.3a73f0	20 18 00	jsr $3a0018	            JSR PRINTC
.3a73f3	08		php		            PHP
.3a73f4	e2 20		sep #$20	            SEP #$20
.3a73f6	48		pha		            PHA
.3a73f7	a9 00		lda #$00	            LDA #`MLINEBUF
.3a73f9	48		pha		            PHA
.3a73fa	ab		plb		            PLB
.3a73fb	68		pla		            PLA
.3a73fc	28		plp		            PLP
.3a73fd	a2 7e 08	ldx #$087e	                LDX #MLINEBUF
.3a7400	20 16 03	jsr $3a0316	            JSR PRINTS
.3a7403	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a7406	20 a0 02	jsr $3a02a0	            JSR PAGINATE
.3a7409	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.3a740b	c5 13		cmp $085b	                CMP MARG2+2
.3a740d	90 0f		bcc $3a741e	                BLT continue            ; No: continue
.3a740f	c2 20		rep #$20	            REP #$20
.3a7411	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.3a7413	c5 11		cmp $0859	                CMP MARG2
.3a7415	90 07		bcc $3a741e	                BLT continue            ; Nope... keep going
.3a7417					done
.3a7417	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a741a	2b		pld		                PLD
.3a741b	ab		plb		                PLB
.3a741c	28		plp		                PLP
.3a741d	6b		rtl		                RTL
.3a741e	4c 72 73	jmp $3a7372	continue        JMP dump_line
.3a7421					M_COPY_ARGB
.3a7421	08		php		                PHP
.3a7422	8d 92 08	sta $0892	                STA MTEMP
.3a7425	e2 20		sep #$20	            SEP #$20
.3a7427	bd 00 00	lda $0000,x	loop            LDA #0,B,X
.3a742a	99 00 00	sta $0000,y	                STA #0,B,Y      ; Copy the byte
.3a742d	ad 92 08	lda $0892	                LDA MTEMP       ; Check the count of characters remaining
.3a7430	f0 0a		beq $3a743c	                BEQ done        ; If it's 0, we're done
.3a7432	c8		iny		                INY             ; Point to the next destination byte
.3a7433	e8		inx		                INX             ; Point to the next source byte (skip three bytes)
.3a7434	e8		inx		                INX
.3a7435	e8		inx		                INX
.3a7436	e8		inx		                INX
.3a7437	ce 92 08	dec $0892	                DEC MTEMP       ; Count down and see if we're done
.3a743a	80 eb		bra $3a7427	                BRA loop
.3a743c	28		plp		done            PLP
.3a743d	6b		rtl		                RTL
.3a743e					IMMODIFY
.3a743e	08		php		                PHP
.3a743f	0b		phd		                PHD
.3a7440	8b		phb		                PHB
.3a7441	08		php		            PHP
.3a7442	c2 20		rep #$20	            REP #$20
.3a7444	48		pha		            PHA
.3a7445	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7448	5b		tcd		            TCD
.3a7449	68		pla		            PLA
.3a744a	28		plp		            PLP
.3a744b	08		php		            PHP
.3a744c	e2 20		sep #$20	            SEP #$20
.3a744e	48		pha		            PHA
.3a744f	a9 00		lda #$00	            LDA #0
.3a7451	48		pha		            PHA
.3a7452	ab		plb		            PLB
.3a7453	68		pla		            PLA
.3a7454	28		plp		            PLP
.3a7455	c2 30		rep #$30	            REP #$30
.3a7457	a5 0d		lda $0855	                LDA MARG1           ; Set MCURSOR to MARG1
.3a7459	85 32		sta $087a	                STA MCURSOR
.3a745b	a5 0f		lda $0857	                LDA MARG1+2
.3a745d	85 34		sta $087c	                STA MCURSOR+2
.3a745f	e2 20		sep #$20	            SEP #$20
.3a7461	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.3a7463	3a		dec a		                DEC A               ; (MARG_LEN - 1)
.3a7464	85 47		sta $088f	                STA MCOUNT
.3a7466	a2 59 08	ldx #$0859	                LDX #<>MARG2        ; Copy MCOUNT bytes from MARG2..MARG9
.3a7469	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF     ; to MLINEBUF
.3a746c	22 21 74 3a	jsl $3a7421	                JSL M_COPY_ARGB
.3a7470	a0 00 00	ldy #$0000	                LDY #0
.3a7473	b9 7e 08	lda $087e,y	loop            LDA MLINEBUF,Y      ; Copy the byte from the buffer
.3a7476	87 32		sta [$087a]	                STA [MCURSOR]       ; To the address indicated by MCURSOR
.3a7478	22 4e 84 3a	jsl $3a844e	                JSL M_INC_CURSOR    ; Advance the cursor
.3a747c	c8		iny		                INY                 ; Go to the next buffered byte
.3a747d	c4 47		cpy $088f	                CPY MCOUNT          ; Did we just write the last one?
.3a747f	d0 f2		bne $3a7473	                BNE loop            ; No: continue writing
.3a7481	ab		plb		                PLB
.3a7482	2b		pld		                PLD
.3a7483	28		plp		                PLP
.3a7484	6b		rtl		                RTL
.3a7485					IMHUNT
.3a7485	08		php		                PHP
.3a7486	0b		phd		                PHD
.3a7487	8b		phb		                PHB
.3a7488	08		php		            PHP
.3a7489	c2 20		rep #$20	            REP #$20
.3a748b	48		pha		            PHA
.3a748c	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a748f	5b		tcd		            TCD
.3a7490	68		pla		            PLA
.3a7491	28		plp		            PLP
.3a7492	08		php		            PHP
.3a7493	e2 20		sep #$20	            SEP #$20
.3a7495	48		pha		            PHA
.3a7496	a9 00		lda #$00	            LDA #0
.3a7498	48		pha		            PHA
.3a7499	ab		plb		            PLB
.3a749a	68		pla		            PLA
.3a749b	28		plp		            PLP
.3a749c	e2 20		sep #$20	            SEP #$20
.3a749e	c2 10		rep #$10	            REP #$10
.3a74a0	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.3a74a2	3a		dec a		                DEC A               ; (MARG_LEN - 2)
.3a74a3	3a		dec a		                DEC A
.3a74a4	85 47		sta $088f	                STA MCOUNT
.3a74a6	a2 5d 08	ldx #$085d	                LDX #<>MARG3
.3a74a9	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF
.3a74ac	22 21 74 3a	jsl $3a7421	                JSL M_COPY_ARGB
.3a74b0	c2 20		rep #$20	            REP #$20
.3a74b2	a5 0d		lda $0855	                LDA MARG1           ; Copy starting address to MCURSOR
.3a74b4	85 32		sta $087a	                STA MCURSOR
.3a74b6	a5 0f		lda $0857	                LDA MARG1+2
.3a74b8	85 34		sta $087c	                STA MCURSOR+2
.3a74ba					outer_loop
.3a74ba	c2 20		rep #$20	            REP #$20
.3a74bc	a5 34		lda $087c	                LDA MCURSOR+2      ; If MCURSOR < MARG2, we're not done yet
.3a74be	c5 13		cmp $085b	                CMP MARG2+2
.3a74c0	d0 06		bne $3a74c8	                BNE not_done
.3a74c2	a5 32		lda $087a	                LDA MCURSOR
.3a74c4	c5 11		cmp $0859	                CMP MARG2
.3a74c6	f0 2c		beq $3a74f4	                BEQ done            ; MCURSOR = MARG2: we're done
.3a74c8					not_done
.3a74c8	e2 20		sep #$20	            SEP #$20
.3a74ca	a0 00 00	ldy #$0000	                LDY #0
.3a74cd	b7 32		lda [$087a],y	cmp_loop        LDA [MCURSOR],Y     ; Get the byte from the memory to check
.3a74cf	d9 7e 08	cmp $087e,y	                CMP MLINEBUF,Y      ; Compare it against our pattern
.3a74d2	d0 1a		bne $3a74ee	                BNE advance         ; If not equal, we need to move on
.3a74d4	c8		iny		                INY                 ; Otherwise do we have more bytes to check?
.3a74d5	c4 47		cpy $088f	                CPY MCOUNT
.3a74d7	d0 f4		bne $3a74cd	                BNE cmp_loop        ; No: check more
.3a74d9	c2 20		rep #$20	            REP #$20
.3a74db	a5 32		lda $087a	                LDA MCURSOR         ; Print the address
.3a74dd	85 4a		sta $0892	                STA MTEMP
.3a74df	a5 34		lda $087c	                LDA MCURSOR+2
.3a74e1	85 4c		sta $0894	                STA MTEMP+2
.3a74e3	22 f8 7e 3a	jsl $3a7ef8	                JSL M_PR_ADDR
.3a74e7	e2 20		sep #$20	            SEP #$20
.3a74e9	a9 20		lda #$20	                LDA #' '
.3a74eb	20 18 00	jsr $3a0018	            JSR PRINTC
.3a74ee	22 4e 84 3a	jsl $3a844e	advance         JSL M_INC_CURSOR    ; Move MCURSOR forward by one
.3a74f2	80 c6		bra $3a74ba	                BRA outer_loop      ; And try to compare that to the pattern
.3a74f4					done
.3a74f4	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a74f7	ab		plb		                PLB
.3a74f8	2b		pld		                PLD
.3a74f9	28		plp		                PLP
.3a74fa	6b		rtl		                RTL
.3a74fb					IMJUMP
.3a74fb	08		php		            PHP
.3a74fc	c2 20		rep #$20	            REP #$20
.3a74fe	48		pha		            PHA
.3a74ff	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a7502	5b		tcd		            TCD
.3a7503	68		pla		            PLA
.3a7504	28		plp		            PLP
.3a7505	e2 20		sep #$20	            SEP #$20
.3a7507	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.3a7509	f0 0e		beq $3a7519	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.3a750b	c2 30		rep #$30	            REP #$30
.3a750d	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.3a750f	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.3a7513	a5 0f		lda $0857	                LDA MARG1+2
.3a7515	8f 42 02 00	sta $000242	                STA @lCPUPBR
.3a7519	af 46 02 00	lda $000246	MJUMPRESTORE    LDA @lCPUX          ; Restore X and Y
.3a751d	aa		tax		                TAX
.3a751e	af 48 02 00	lda $000248	                LDA @lCPUY
.3a7522	a8		tay		                TAY
.3a7523	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.3a7527	1b		tcs		                TCS
.3a7528	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.3a752c	5b		tcd		                TCD
.3a752d	e2 20		sep #$20	            SEP #$20
.3a752f	a9 3a		lda #$3a	                LDA #`MJUMPSTART
.3a7531	48		pha		                PHA
.3a7532	a9 75		lda #$75	                LDA #>MJUMPSTART
.3a7534	48		pha		                PHA
.3a7535	a9 3b		lda #$3b	                LDA #<MJUMPSTART
.3a7537	48		pha		                PHA
.3a7538	4c 72 75	jmp $3a7572	                JMP MGOSTACK        ; And push remaining registers and restart execution
.3a753b	ea		nop		MJUMPSTART      NOP                 ; RTL increments PC pulled from stack, NOP leaves space for that
.3a753c	5c 04 00 3a	jmp $3a0004	                JML MONITOR
.3a7540					IMGO
.3a7540	08		php		            PHP
.3a7541	c2 20		rep #$20	            REP #$20
.3a7543	48		pha		            PHA
.3a7544	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a7547	5b		tcd		            TCD
.3a7548	68		pla		            PLA
.3a7549	28		plp		            PLP
.3a754a	e2 20		sep #$20	            SEP #$20
.3a754c	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.3a754e	f0 c9		beq $3a7519	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.3a7550	c2 30		rep #$30	            REP #$30
.3a7552	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.3a7554	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.3a7558	a5 0f		lda $0857	                LDA MARG1+2
.3a755a	8f 42 02 00	sta $000242	                STA @lCPUPBR
.3a755e	af 46 02 00	lda $000246	MGORESTORE      LDA @lCPUX          ; Restore X and Y
.3a7562	aa		tax		                TAX
.3a7563	af 48 02 00	lda $000248	                LDA @lCPUY
.3a7567	a8		tay		                TAY
.3a7568	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.3a756c	1b		tcs		                TCS
.3a756d	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.3a7571	5b		tcd		                TCD
.3a7572					MGOSTACK
.3a7572	e2 20		sep #$20	            SEP #$20
.3a7574	af 4e 02 00	lda $00024e	                LDA @lCPUDBR        ; Restore the data bank register
.3a7578	48		pha		                PHA
.3a7579	ab		plb		                PLB
.3a757a	a9 5c		lda #$5c	                LDA #$5C            ; Save the JSL opcode
.3a757c	8f a2 08 00	sta $0008a2	                STA @lMJUMPINST
.3a7580	af 42 02 00	lda $000242	                LDA @lCPUPBR        ; Write PBR
.3a7584	8f a5 08 00	sta $0008a5	                STA @lMJUMPADDR+2
.3a7588	af 41 02 00	lda $000241	                LDA @lCPUPC+1       ; Write PCH
.3a758c	8f a4 08 00	sta $0008a4	                STA @lMJUMPADDR+1
.3a7590	af 40 02 00	lda $000240	                LDA @lCPUPC         ; Write PCL
.3a7594	8f a3 08 00	sta $0008a3	                STA @lMJUMPADDR
.3a7598	af 4f 02 00	lda $00024f	                LDA @lCPUFLAGS      ; Push processor status
.3a759c	48		pha		                PHA
.3a759d	c2 20		rep #$20	            REP #$20
.3a759f	af 44 02 00	lda $000244	                LDA @lCPUA          ; Restore A
.3a75a3	28		plp		                PLP                 ; And the status register
.3a75a4	5c a2 08 00	jmp $0008a2	                JML MJUMPINST       ; And jump to the target address
.3a75a8					IMCOMPARE
.3a75a8	08		php		                PHP
.3a75a9	0b		phd		                PHD
.3a75aa	8b		phb		                PHB
.3a75ab	08		php		            PHP
.3a75ac	e2 20		sep #$20	            SEP #$20
.3a75ae	48		pha		            PHA
.3a75af	a9 3a		lda #$3a	            LDA #`MERRARGS
.3a75b1	48		pha		            PHA
.3a75b2	ab		plb		            PLB
.3a75b3	68		pla		            PLA
.3a75b4	28		plp		            PLP
.3a75b5	08		php		            PHP
.3a75b6	c2 20		rep #$20	            REP #$20
.3a75b8	48		pha		            PHA
.3a75b9	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a75bc	5b		tcd		            TCD
.3a75bd	68		pla		            PLA
.3a75be	28		plp		            PLP
.3a75bf	c2 10		rep #$10	            REP #$10
.3a75c1	e2 20		sep #$20	            SEP #$20
.3a75c3	a5 31		lda $0879	                LDA MARG_LEN                ; Check the number of arguments provided
.3a75c5	c9 02		cmp #$02	                CMP #2
.3a75c7	f0 0c		beq $3a75d5	                BEQ default_len             ; If 2: set MCOUNT to default of 1
.3a75c9	c9 03		cmp #$03	                CMP #3
.3a75cb	d0 11		bne $3a75de	                BNE bad_arguments           ; Otherwise, if not 3: print an error
.3a75cd	c2 20		rep #$20	            REP #$20
.3a75cf	a5 15		lda $085d	                LDA MARG3                   ; If 3: set MCOUNT to MARG3
.3a75d1	85 47		sta $088f	                STA MCOUNT
.3a75d3	80 11		bra $3a75e6	                BRA compare
.3a75d5					default_len
.3a75d5	c2 20		rep #$20	            REP #$20
.3a75d7	a9 01 00	lda #$0001	                LDA #1                      ; No length was provided, set MCOUNT to 1
.3a75da	85 47		sta $088f	                STA MCOUNT
.3a75dc	80 08		bra $3a75e6	                BRA compare
.3a75de	a2 1a 87	ldx #$871a	bad_arguments   LDX #<>MERRARGS             ; The wrong number of arguments was provided
.3a75e1	20 16 03	jsr $3a0316	            JSR PRINTS
.3a75e4	80 35		bra $3a761b	                BRA done
.3a75e6	a5 0d		lda $0855	compare         LDA MARG1                   ; Set MTEMP to MARG1
.3a75e8	85 4a		sta $0892	                STA MTEMP
.3a75ea	a5 0f		lda $0857	                LDA MARG1+2
.3a75ec	85 4c		sta $0894	                STA MTEMP+2
.3a75ee	a0 00 00	ldy #$0000	                LDY #0
.3a75f1					loop
.3a75f1	e2 20		sep #$20	            SEP #$20
.3a75f3	a7 4a		lda [$0892]	                LDA [MTEMP]                 ; Compare the byte at MTEMP
.3a75f5	d7 11		cmp [$0859],y	                CMP [MARG2],Y               ; To the Yth byte from MARG2
.3a75f7	f0 09		beq $3a7602	                BEQ continue                ; If they're the same, keep going
.3a75f9	22 f8 7e 3a	jsl $3a7ef8	mismatch        JSL M_PR_ADDR               ; If they're different, print MTEMP
.3a75fd	a9 20		lda #$20	                LDA #' '
.3a75ff	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7602					continue
.3a7602	c2 20		rep #$20	            REP #$20
.3a7604	18		clc		                CLC                         ; Either way, increment MTEMP
.3a7605	a5 4a		lda $0892	                LDA MTEMP
.3a7607	69 01 00	adc #$0001	                ADC #1
.3a760a	85 4a		sta $0892	                STA MTEMP
.3a760c	a5 4c		lda $0894	                LDA MTEMP+2
.3a760e	69 00 00	adc #$0000	                ADC #0
.3a7611	85 4c		sta $0894	                STA MTEMP+2
.3a7613	c8		iny		                INY                         ; Increment Y
.3a7614	c4 47		cpy $088f	                CPY MCOUNT                  ; Try again unless we've checked MCOUNT bytes
.3a7616	d0 d9		bne $3a75f1	                BNE loop
.3a7618	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a761b					done
.3a761b	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a761e	ab		plb		                PLB
.3a761f	2b		pld		                PLD
.3a7620	28		plp		                PLP
.3a7621	6b		rtl		                RTL
.3a7622					IMRMODIFY
.3a7622	08		php		                PHP
.3a7623	0b		phd		                PHD
.3a7624	8b		phb		                PHB
.3a7625	08		php		            PHP
.3a7626	e2 20		sep #$20	            SEP #$20
.3a7628	48		pha		            PHA
.3a7629	a9 00		lda #$00	            LDA #0
.3a762b	48		pha		            PHA
.3a762c	ab		plb		            PLB
.3a762d	68		pla		            PLA
.3a762e	28		plp		            PLP
.3a762f	08		php		            PHP
.3a7630	c2 20		rep #$20	            REP #$20
.3a7632	48		pha		            PHA
.3a7633	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a7636	5b		tcd		            TCD
.3a7637	68		pla		            PLA
.3a7638	28		plp		            PLP
.3a7639	e2 20		sep #$20	            SEP #$20
.3a763b	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.3a763d	f0 4f		beq $3a768e	                BEQ done            ; 0? Just quit
.3a763f	a6 0d		ldx $0855	                LDX MARG1           ; Set the PC and PBR
.3a7641	8e 40 02	stx $0240	                STX #CPUPC,B
.3a7644	a6 0f		ldx $0857	                LDX MARG1+2
.3a7646	8e 42 02	stx $0242	                STX #CPUPBR,B
.3a7649	c9 01		cmp #$01	                CMP #1              ; Check the number of arguments
.3a764b	f0 41		beq $3a768e	                BEQ done            ; 1? Just quit
.3a764d	a6 11		ldx $0859	                LDX MARG2           ; Set A
.3a764f	8e 44 02	stx $0244	                STX #CPUA,B
.3a7652	c9 02		cmp #$02	                CMP #2              ; Check the number of arguments
.3a7654	f0 38		beq $3a768e	                BEQ done            ; 2? Just quit
.3a7656	a6 15		ldx $085d	                LDX MARG3           ; Set X
.3a7658	8e 46 02	stx $0246	                STX #CPUX,B
.3a765b	c9 03		cmp #$03	                CMP #3              ; Check the number of arguments
.3a765d	f0 2f		beq $3a768e	                BEQ done            ; 3? Just quit
.3a765f	a6 19		ldx $0861	                LDX MARG4           ; Set Y
.3a7661	8e 48 02	stx $0248	                STX #CPUY,B
.3a7664	c9 04		cmp #$04	                CMP #4              ; Check the number of arguments
.3a7666	f0 26		beq $3a768e	                BEQ done            ; 4? Just quit
.3a7668	a6 1d		ldx $0865	                LDX MARG5           ; Set SP
.3a766a	8e 4a 02	stx $024a	                STX #CPUSTACK,B
.3a766d	c9 05		cmp #$05	                CMP #5              ; Check the number of arguments
.3a766f	f0 1d		beq $3a768e	                BEQ done            ; 5? Just quit
.3a7671	e2 10		sep #$10	            SEP #$10
.3a7673	a6 21		ldx $0869	                LDX MARG6           ; Set DBR
.3a7675	8e 4e 02	stx $024e	                STX #CPUDBR,B
.3a7678	c9 06		cmp #$06	                CMP #6              ; Check the number of arguments
.3a767a	f0 12		beq $3a768e	                BEQ done            ; 6? Just quit
.3a767c	c2 10		rep #$10	            REP #$10
.3a767e	a6 25		ldx $086d	                LDX MARG7           ; Set DP
.3a7680	8e 4c 02	stx $024c	                STX #CPUDP,B
.3a7683	c9 07		cmp #$07	                CMP #7              ; Check the number of arguments
.3a7685	f0 07		beq $3a768e	                BEQ done            ; 7? Just quit
.3a7687	e2 10		sep #$10	            SEP #$10
.3a7689	a6 29		ldx $0871	                LDX MARG8           ; Set flags
.3a768b	8e 4f 02	stx $024f	                STX #CPUFLAGS,B
.3a768e	ab		plb		done            PLB
.3a768f	2b		pld		                PLD
.3a7690	28		plp		                PLP
.3a7691	6b		rtl		                RTL
.3a7692					IMEXECUTE
.3a7692	08		php		                PHP
.3a7693	0b		phd		                PHD
.3a7694	8b		phb		                PHB
.3a7695	08		php		            PHP
.3a7696	c2 20		rep #$20	            REP #$20
.3a7698	48		pha		            PHA
.3a7699	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a769c	5b		tcd		            TCD
.3a769d	68		pla		            PLA
.3a769e	28		plp		            PLP
.3a769f	e2 20		sep #$20	            SEP #$20
.3a76a1	c2 10		rep #$10	            REP #$10
.3a76a3	a2 00 00	ldx #$0000	                LDX #0
.3a76a6	bf 87 87 3a	lda $3a8787,x	loop            LDA @lMCOMMANDS,X
.3a76aa	f0 18		beq $3a76c4	                BEQ done
.3a76ac	c7 08		cmp [$0850]	                CMP [MCMD]
.3a76ae	f0 03		beq $3a76b3	                BEQ found
.3a76b0	e8		inx		                INX
.3a76b1	80 f3		bra $3a76a6	                BRA loop
.3a76b3					found
.3a76b3	c2 20		rep #$20	            REP #$20
.3a76b5	8a		txa		                TXA
.3a76b6	0a		asl a		                ASL A
.3a76b7	aa		tax		                TAX
.3a76b8	bf c8 76 3a	lda $3a76c8,x	                LDA dispatch,X
.3a76bc	8f 2f 08 00	sta $00082f	                STA @lJMP16PTR
.3a76c0	22 ec 76 3a	jsl $3a76ec	                JSL MDOCMD
.3a76c4	ab		plb		done            PLB
.3a76c5	2b		pld		                PLD
.3a76c6	28		plp		                PLP
.3a76c7	6b		rtl		                RTL
>3a76c8	65 6d				dispatch        .word <>MASSEMBLE
>3a76ca	6d 6d				                .word <>MCOMPARE
>3a76cc	71 6d				                .word <>MDISASSEMBLE
>3a76ce	75 6d				                .word <>MFILL
>3a76d0	79 6d				                .word <>MGO
>3a76d2	7d 6d				                .word <>MJUMP
>3a76d4	81 6d				                .word <>MHUNT
>3a76d6	85 6d				                .word <>MLOAD
>3a76d8	89 6d				                .word <>MMEMORY
>3a76da	8d 6d				                .word <>MREGISTERS
>3a76dc	69 6d				                .word <>MRMODIFY
>3a76de	91 6d				                .word <>MSAVE
>3a76e0	95 6d				                .word <>MTRANSFER
>3a76e2	99 6d				                .word <>MVERIFY
>3a76e4	61 71				                .word <>IMWIDTH
>3a76e6	9d 6d				                .word <>MEXIT
>3a76e8	a1 6d				                .word <>MMODIFY
>3a76ea	da 6d				                .word <>IMHELP
.3a76ec					MDOCMD
.3a76ec	6c 2f 08	jmp ($082f)	                JMP (JMP16PTR)

;******  Processing file: src\assembler.s

=0					ADDR_DP_IND_X = 0       ; (dd,X)
=1					ADDR_DP = 1             ; dd
=2					ADDR_IMM = 2            ; #dd
=3					ADDR_ABS = 3            ; dddd
=4					ADDR_DP_IND_Y = 4       ; (dd),Y
=5					ADDR_DP_X = 5           ; dd,X
=6					ADDR_ABS_Y = 6          ; dddd,Y
=7					ADDR_ABS_X = 7          ; dddd,X
=8					ADDR_ACC = 8            ; A
=9					ADDR_SP_R = 9           ; #d,S
=10					ADDR_DP_LONG = 10       ; [dd]
=11					ADDR_ABS_LONG = 11      ; dddddd
=12					ADDR_SP_R_Y = 12        ; #dd,S,Y
=13					ADDR_DP_Y_LONG = 13     ; [dd],Y
=14					ADDR_ABS_X_LONG = 14    ; dddddd,X
=15					ADDR_DP_IND = 15        ; (dd)
=16					ADDR_ABS_X_ID = 16      ; (dddd,X)
=17					ADDR_DP_Y = 17          ; dd,Y
=18					ADDR_PC_REL = 18        ; PC relative
=19					ADDR_IMPLIED = 19       ; Implied (no operand)
=20					ADDR_XYC = 20           ; #dd, #dd
=21					ADDR_ABS_IND = 21       ; (dddd)
=22					ADDR_PC_REL_LONG = 22   ; PC relative ()
=23					ADDR_ABS_IND_LONG = 23  ; [dddd]
=$80					OP_M_EFFECT = $80       ; Flag to indicate instruction is modified by M
=$40					OP_X_EFFECT = $40       ; Flag to indicate instruction is modified by X
.3a76ef					IMASSEMBLE
.3a76ef	08		php		                PHP
.3a76f0	8b		phb		                PHB
.3a76f1	0b		phd		                PHD
.3a76f2	08		php		            PHP
.3a76f3	c2 20		rep #$20	            REP #$20
.3a76f5	48		pha		            PHA
.3a76f6	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a76f9	5b		tcd		            TCD
.3a76fa	68		pla		            PLA
.3a76fb	28		plp		            PLP
.3a76fc	e2 20		sep #$20	            SEP #$20
.3a76fe	a5 31		lda $0879	                LDA MARG_LEN            ; Do we have at least 2 arguments?
.3a7700	c9 02		cmp #$02	                CMP #2
.3a7702	b0 03		bcs $3a7707	                BGE has_args            ; Yes: try to assemble the line
.3a7704	4c 95 78	jmp $3a7895	                JMP done                ; No: just return
.3a7707					has_args
.3a7707	c2 20		rep #$20	            REP #$20
.3a7709	a5 0d		lda $0855	                LDA MARG1               ; Set the monitor cursor to the address
.3a770b	85 32		sta $087a	                STA MCURSOR
.3a770d	a5 0f		lda $0857	                LDA MARG1+2
.3a770f	85 34		sta $087c	                STA MCURSOR+2
.3a7711	c2 20		rep #$20	            REP #$20
.3a7713	22 97 7a 3a	jsl $3a7a97	                JSL AS_FIND_MNEMO       ; Find the address of the mnemonic
.3a7717	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.3a771a	f0 10		beq $3a772c	                BEQ bad_mnemonic        ; If not found, print bad mnemonic error message
.3a771c	85 54		sta $089c	                STA MMNEMONIC
.3a771e	e2 20		sep #$20	            SEP #$20
.3a7720	a5 31		lda $0879	                LDA MARG_LEN            ; Check the number of arguments passed
.3a7722	c9 03		cmp #$03	                CMP #3                  ; Were all three arguments provided?
.3a7724	f0 36		beq $3a775c	                BEQ get_operand         ; Yes: parse the operand
.3a7726	a9 13		lda #$13	                LDA #ADDR_IMPLIED       ; No: assume address mode is implied
.3a7728	85 4f		sta $0897	                STA MADDR_MODE
.3a772a	80 4c		bra $3a7778	                BRA get_opcode
.3a772c					bad_mnemonic
.3a772c	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a772f	08		php		            PHP
.3a7730	e2 20		sep #$20	            SEP #$20
.3a7732	48		pha		            PHA
.3a7733	a9 3a		lda #$3a	            LDA #`MERRBADMNEMO
.3a7735	48		pha		            PHA
.3a7736	ab		plb		            PLB
.3a7737	68		pla		            PLA
.3a7738	28		plp		            PLP
.3a7739	c2 10		rep #$10	            REP #$10
.3a773b	a2 cc 78	ldx #$78cc	                LDX #<>MERRBADMNEMO
.3a773e	20 16 03	jsr $3a0316	            JSR PRINTS
.3a7741	4c 95 78	jmp $3a7895	                JMP done
.3a7744					bad_operand
.3a7744	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a7747	08		php		            PHP
.3a7748	e2 20		sep #$20	            SEP #$20
.3a774a	48		pha		            PHA
.3a774b	a9 3a		lda #$3a	            LDA #`MERRBADOPER
.3a774d	48		pha		            PHA
.3a774e	ab		plb		            PLB
.3a774f	68		pla		            PLA
.3a7750	28		plp		            PLP
.3a7751	c2 10		rep #$10	            REP #$10
.3a7753	a2 db 78	ldx #$78db	                LDX #<>MERRBADOPER
.3a7756	20 16 03	jsr $3a0316	            JSR PRINTS
.3a7759	4c 95 78	jmp $3a7895	                JMP done
.3a775c					get_operand
.3a775c	e2 20		sep #$20	            SEP #$20
.3a775e	22 cd 7a 3a	jsl $3a7acd	                JSL AS_FIND_MODE        ; Find the addressing mode of the operand
.3a7762	c9 ff		cmp #$ff	compare         CMP #$FF
.3a7764	f0 de		beq $3a7744	                BEQ bad_operand         ; If not found, print bad operand error message
.3a7766	85 4f		sta $0897	                STA MADDR_MODE
.3a7768	c9 03		cmp #$03	                CMP #ADDR_ABS           ; If mode is absolute or absolute long...
.3a776a	f0 62		beq $3a77ce	                BEQ check_for_pcrel     ; Check to see if the mnemonic is one of the branches
.3a776c	c9 0b		cmp #$0b	                CMP #ADDR_ABS_LONG
.3a776e	f0 5e		beq $3a77ce	                BEQ check_for_pcrel
.3a7770	c9 13		cmp #$13	                CMP #ADDR_IMPLIED       ; If mode is implied or accumulator, get the opcode
.3a7772	f0 04		beq $3a7778	                BEQ get_opcode
.3a7774	c9 08		cmp #$08	                CMP #ADDR_ACC
.3a7776	f0 00		beq $3a7778	                BEQ get_opcode
.3a7778	22 c5 79 3a	jsl $3a79c5	get_opcode      JSL AS_FIND_OPCODE      ; Find the opcode matching the two
.3a777c	b0 03		bcs $3a7781	                BCS save_opcode
.3a777e	4c 5e 78	jmp $3a785e	                JMP bad_mode            ; If opcode not found, print bad address mode error message
.3a7781	87 32		sta [$087a]	save_opcode     STA [MCURSOR]           ; Write the opcode to the address
.3a7783	22 4e 84 3a	jsl $3a844e	                JSL M_INC_CURSOR        ; And point to the next byte
.3a7787	08		php		            PHP
.3a7788	e2 20		sep #$20	            SEP #$20
.3a778a	48		pha		            PHA
.3a778b	a9 00		lda #$00	            LDA #0
.3a778d	48		pha		            PHA
.3a778e	ab		plb		            PLB
.3a778f	68		pla		            PLA
.3a7790	28		plp		            PLP
.3a7791	c2 20		rep #$20	            REP #$20
.3a7793	a5 32		lda $087a	                LDA MCURSOR             ; Make MTEMPPTR a pointer to the machine code we're assembling
.3a7795	85 56		sta $089e	                STA MTEMPPTR
.3a7797	a5 34		lda $087c	                LDA MCURSOR+2
.3a7799	85 58		sta $08a0	                STA MTEMPPTR+2
.3a779b	e2 20		sep #$20	            SEP #$20
.3a779d	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check the address mode again
.3a779f	c9 12		cmp #$12	                CMP #ADDR_PC_REL        ; If it's PC relative
.3a77a1	f0 6c		beq $3a780f	                BEQ compute_rel         ; Convert the address to an offset
.3a77a3	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.3a77a5	f0 68		beq $3a780f	                BEQ compute_rel
.3a77a7	c9 14		cmp #$14	                CMP #ADDR_XYC           ; MVP/MVN addressing mode?
.3a77a9	f0 7c		beq $3a7827	                BEQ emit_2
.3a77ab	29 3f		and #$3f	                AND #%00111111          ; Filter out the mode bits
.3a77ad	c9 02		cmp #$02	                CMP #ADDR_IMM           ; Is it immediate?
.3a77af	d0 03		bne $3a77b4	                BNE fixed_length        ; Yes: emit it as an immediate (variable length)
.3a77b1	4c 8c 78	jmp $3a788c	                JMP emit_imm
.3a77b4					fixed_length
.3a77b4	c2 20		rep #$20	            REP #$20
.3a77b6	29 ff 00	and #$00ff	                AND #$00FF
.3a77b9	aa		tax		                TAX
.3a77ba	e2 20		sep #$20	            SEP #$20
.3a77bc	bf 94 83 3a	lda $3a8394,x	get_length      LDA ADDR_LENGTH,X       ; Get the number of bytes in the addressing mode
.3a77c0	c9 03		cmp #$03	                CMP #$03
.3a77c2	f0 57		beq $3a781b	                BEQ emit_3
.3a77c4	c9 02		cmp #$02	                CMP #$02
.3a77c6	f0 5f		beq $3a7827	                BEQ emit_2
.3a77c8	c9 01		cmp #$01	                CMP #$01
.3a77ca	f0 67		beq $3a7833	                BEQ emit_1
.3a77cc	80 71		bra $3a783f	                BRA next_line
.3a77ce					check_for_pcrel
.3a77ce	c2 20		rep #$20	            REP #$20
.3a77d0	a5 54		lda $089c	                LDA MMNEMONIC
.3a77d2	c9 0c 80	cmp #$800c	                CMP #<>MN_BRA
.3a77d5	f0 26		beq $3a77fd	                BEQ is_pcrel
.3a77d7	c9 70 80	cmp #$8070	                CMP #<>MN_BRL
.3a77da	f0 2a		beq $3a7806	                BEQ is_pcrel_long
.3a77dc	c9 f0 7f	cmp #$7ff0	                CMP #<>MN_BCC
.3a77df	f0 1c		beq $3a77fd	                BEQ is_pcrel
.3a77e1	c9 f4 7f	cmp #$7ff4	                CMP #<>MN_BCS
.3a77e4	f0 17		beq $3a77fd	                BEQ is_pcrel
.3a77e6	c9 fc 7f	cmp #$7ffc	                CMP #<>MN_BEQ
.3a77e9	f0 12		beq $3a77fd	                BEQ is_pcrel
.3a77eb	c9 e4 7f	cmp #$7fe4	                CMP #<>MN_BMI
.3a77ee	f0 0d		beq $3a77fd	                BEQ is_pcrel
.3a77f0	c9 f8 7f	cmp #$7ff8	                CMP #<>MN_BNE
.3a77f3	f0 08		beq $3a77fd	                BEQ is_pcrel
.3a77f5	c9 e0 7f	cmp #$7fe0	                CMP #<>MN_BPL
.3a77f8	f0 03		beq $3a77fd	                BEQ is_pcrel
.3a77fa	4c 78 77	jmp $3a7778	                JMP get_opcode
.3a77fd					is_pcrel
.3a77fd	e2 20		sep #$20	            SEP #$20
.3a77ff	a9 12		lda #$12	                LDA #ADDR_PC_REL
.3a7801	85 4f		sta $0897	                STA MADDR_MODE
.3a7803	4c 78 77	jmp $3a7778	                JMP get_opcode
.3a7806					is_pcrel_long
.3a7806	e2 20		sep #$20	            SEP #$20
.3a7808	a9 16		lda #$16	                LDA #ADDR_PC_REL_LONG
.3a780a	85 4f		sta $0897	                STA MADDR_MODE
.3a780c	4c 78 77	jmp $3a7778	                JMP get_opcode
.3a780f	22 08 79 3a	jsl $3a7908	compute_rel     JSL AS_PC_OFFSET        ; Try to compute the offset
.3a7813	90 60		bcc $3a7875	                BCC bad_offset          ; If failed, it's a bad offset operand
.3a7815	c9 02		cmp #$02	emit_rel        CMP #$02                ; If the offset is two bytes
.3a7817	f0 0e		beq $3a7827	                BEQ emit_2              ; Emit those two bytes
.3a7819	80 18		bra $3a7833	                BRA emit_1              ; Otherwise emit just the one
.3a781b	a0 02 00	ldy #$0002	emit_3          LDY #2                  ; Write bank byte of operand
.3a781e	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.3a7821	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.3a7823	22 4e 84 3a	jsl $3a844e	                JSL M_INC_CURSOR
.3a7827	a0 01 00	ldy #$0001	emit_2          LDY #1                  ; Write high byte of operand
.3a782a	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.3a782d	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.3a782f	22 4e 84 3a	jsl $3a844e	                JSL M_INC_CURSOR
.3a7833	a0 00 00	ldy #$0000	emit_1          LDY #0                  ; Write low byte of operand
.3a7836	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.3a7839	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.3a783b	22 4e 84 3a	jsl $3a844e	                JSL M_INC_CURSOR
.3a783f					next_line
.3a783f	e2 20		sep #$20	            SEP #$20
.3a7841	a9 41		lda #$41	                LDA #'A'
.3a7843	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7846	a9 20		lda #$20	                LDA #' '
.3a7848	20 18 00	jsr $3a0018	            JSR PRINTC
.3a784b	a6 32		ldx $087a	                LDX MCURSOR
.3a784d	86 4a		stx $0892	                STX MTEMP
.3a784f	a6 34		ldx $087c	                LDX MCURSOR+2
.3a7851	86 4c		stx $0894	                STX MTEMP+2
.3a7853	22 f8 7e 3a	jsl $3a7ef8	                JSL M_PR_ADDR
.3a7857	a9 20		lda #$20	                LDA #' '
.3a7859	20 18 00	jsr $3a0018	            JSR PRINTC
.3a785c	80 37		bra $3a7895	                BRA done
.3a785e					bad_mode
.3a785e	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a7861	08		php		            PHP
.3a7862	e2 20		sep #$20	            SEP #$20
.3a7864	48		pha		            PHA
.3a7865	a9 3a		lda #$3a	            LDA #`MERRBADMODE
.3a7867	48		pha		            PHA
.3a7868	ab		plb		            PLB
.3a7869	68		pla		            PLA
.3a786a	28		plp		            PLP
.3a786b	c2 10		rep #$10	            REP #$10
.3a786d	a2 99 78	ldx #$7899	                LDX #<>MERRBADMODE
.3a7870	20 16 03	jsr $3a0316	            JSR PRINTS
.3a7873	80 20		bra $3a7895	                BRA done
.3a7875					bad_offset
.3a7875	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a7878	08		php		            PHP
.3a7879	e2 20		sep #$20	            SEP #$20
.3a787b	48		pha		            PHA
.3a787c	a9 3a		lda #$3a	            LDA #`MERRBADOFFSET
.3a787e	48		pha		            PHA
.3a787f	ab		plb		            PLB
.3a7880	68		pla		            PLA
.3a7881	28		plp		            PLP
.3a7882	c2 10		rep #$10	            REP #$10
.3a7884	a2 e9 78	ldx #$78e9	                LDX #<>MERRBADOFFSET
.3a7887	20 16 03	jsr $3a0316	            JSR PRINTS
.3a788a	80 09		bra $3a7895	                BRA done
.3a788c	a5 4f		lda $0897	emit_imm        LDA MADDR_MODE          ; Check to see if long immediate was used
.3a788e	29 c0		and #$c0	                AND #%11000000
.3a7890	d0 95		bne $3a7827	                BNE emit_2              ; Yes: emit two bytes
.3a7892	4c 33 78	jmp $3a7833	                JMP emit_1              ; No: emit one byte
.3a7895	2b		pld		done            PLD
.3a7896	ab		plb		                PLB
.3a7897	28		plp		                PLP
.3a7898	6b		rtl		                RTL
>3a7899	41 64 64 72 65 73 73 69		MERRBADMODE     .null "Addressing mode not defined for that instruction.",CHAR_CR
>3a78a1	6e 67 20 6d 6f 64 65 20 6e 6f 74 20 64 65 66 69
>3a78b1	6e 65 64 20 66 6f 72 20 74 68 61 74 20 69 6e 73
>3a78c1	74 72 75 63 74 69 6f 6e 2e 0d 00
>3a78cc	42 61 64 20 6d 6e 65 6d		MERRBADMNEMO    .null "Bad mnemonic.",CHAR_CR
>3a78d4	6f 6e 69 63 2e 0d 00
>3a78db	42 61 64 20 6f 70 65 72		MERRBADOPER     .null "Bad operand.",CHAR_CR
>3a78e3	61 6e 64 2e 0d 00
>3a78e9	52 65 6c 61 74 69 76 65		MERRBADOFFSET   .null "Relative offset is too large.",CHAR_CR
>3a78f1	20 6f 66 66 73 65 74 20 69 73 20 74 6f 6f 20 6c
>3a7901	61 72 67 65 2e 0d 00
.3a7908					AS_PC_OFFSET
.3a7908	08		php		                PHP
.3a7909	0b		phd		                PHD
.3a790a	08		php		            PHP
.3a790b	c2 20		rep #$20	            REP #$20
.3a790d	48		pha		            PHA
.3a790e	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7911	5b		tcd		            TCD
.3a7912	68		pla		            PLA
.3a7913	28		plp		            PLP
.3a7914	e2 20		sep #$20	            SEP #$20
.3a7916	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check to see if it 1 byte or 2 byte relative
.3a7918	c9 12		cmp #$12	                CMP #ADDR_PC_REL
.3a791a	f0 0a		beq $3a7926	                BEQ is_short
.3a791c	c2 20		rep #$20	            REP #$20
.3a791e	18		clc		                CLC                     ; Branch is long. Compute where MCURSOR will be
.3a791f	a5 32		lda $087a	                LDA MCURSOR             ; with two branch offset bytes
.3a7921	69 02 00	adc #$0002	                ADC #2
.3a7924	80 08		bra $3a792e	                BRA compute_cursor
.3a7926					is_short
.3a7926	c2 20		rep #$20	            REP #$20
.3a7928	18		clc		                CLC                     ; Branch is short. Computer where MCURSOR will be
.3a7929	a5 32		lda $087a	                LDA MCURSOR             ; with one branch offset byte
.3a792b	69 01 00	adc #$0001	                ADC #1
.3a792e	85 4a		sta $0892	compute_cursor  STA MTEMP
.3a7930	a5 34		lda $087c	                LDA MCURSOR+2
.3a7932	69 00 00	adc #$0000	                ADC #0
.3a7935	85 4c		sta $0894	                STA MTEMP+2
.3a7937	38		sec		                SEC                     ; MPARSEDNUM = MPARSEDNUM - MTEMP (MCURSOR after the instruction)
.3a7938	a5 50		lda $0898	                LDA MPARSEDNUM
.3a793a	e5 4a		sbc $0892	                SBC MTEMP
.3a793c	85 50		sta $0898	                STA MPARSEDNUM
.3a793e	a5 52		lda $089a	                LDA MPARSEDNUM+2
.3a7940	e5 4c		sbc $0894	                SBC MTEMP+2
.3a7942	85 52		sta $089a	                STA MPARSEDNUM+2
.3a7944	e2 20		sep #$20	            SEP #$20
.3a7946	a5 4f		lda $0897	                LDA MADDR_MODE
.3a7948	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.3a794a	f0 1e		beq $3a796a	                BEQ check_long
.3a794c	a5 50		lda $0898	                LDA MPARSEDNUM          ; Short offset... check if it's negative
.3a794e	30 0c		bmi $3a795c	                BMI check_short_neg
.3a7950	a5 51		lda $0899	                LDA MPARSEDNUM+1        ; Positive short offset... upper two bytes
.3a7952	d0 2a		bne $3a797e	                BNE failure             ; Must be 0 or it's an overflow
.3a7954	a5 52		lda $089a	                LDA MPARSEDNUM+2
.3a7956	d0 26		bne $3a797e	                BNE failure
.3a7958	a9 01		lda #$01	                LDA #1                  ; Short offset is 1 byte
.3a795a	80 26		bra $3a7982	                BRA success
.3a795c	a5 51		lda $0899	check_short_neg LDA MPARSEDNUM+1        ; Negative short offset... upper two bytes
.3a795e	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's an  overflow
.3a7960	d0 1c		bne $3a797e	                BNE failure
.3a7962	a5 52		lda $089a	                LDA MPARSEDNUM+2
.3a7964	c9 ff		cmp #$ff	                CMP #$FF
.3a7966	d0 16		bne $3a797e	                BNE failure
.3a7968	80 18		bra $3a7982	                BRA success
.3a796a	a5 51		lda $0899	check_long      LDA MPARSEDNUM+1        ; Long offset... check if it's negative
.3a796c	30 06		bmi $3a7974	                BMI check_long_neg
.3a796e	a5 52		lda $089a	                LDA MPARSEDNUM+2        ; Positive long offset... upper byte
.3a7970	d0 0c		bne $3a797e	                BNE failure             ; Must be 0 or it's an overflow
.3a7972	80 0e		bra $3a7982	                BRA success
.3a7974	a5 52		lda $089a	check_long_neg  LDA MPARSEDNUM+2        ; Negative offset... upper two bytes
.3a7976	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's and overflow
.3a7978	d0 04		bne $3a797e	                BNE failure
.3a797a	a9 02		lda #$02	                LDA #2                  ; Long offset is 2 bytes
.3a797c	80 04		bra $3a7982	                BRA success
.3a797e	2b		pld		failure         PLD
.3a797f	28		plp		                PLP
.3a7980	18		clc		                CLC
.3a7981	6b		rtl		                RTL
.3a7982	2b		pld		success         PLD
.3a7983	28		plp		                PLP
.3a7984	38		sec		                SEC
.3a7985	6b		rtl		                RTL
.3a7986					AS_SHIFT_HEX
.3a7986	08		php		                PHP
.3a7987	0b		phd		                PHD
.3a7988	c2 10		rep #$10	            REP #$10
.3a798a	da		phx		                PHX
.3a798b	08		php		            PHP
.3a798c	c2 20		rep #$20	            REP #$20
.3a798e	48		pha		            PHA
.3a798f	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7992	5b		tcd		            TCD
.3a7993	68		pla		            PLA
.3a7994	28		plp		            PLP
.3a7995	e2 20		sep #$20	            SEP #$20
.3a7997	a2 00 00	ldx #$0000	                LDX #0
.3a799a	df 00 d0 3a	cmp $3ad000,x	seek_loop       CMP @lHEXDIGITS,X   ; Check the passed character against the hex digits
.3a799e	f0 08		beq $3a79a8	                BEQ found
.3a79a0	e8		inx		                INX                 ; Go to the next hex digit
.3a79a1	e0 10 00	cpx #$0010	                CPX #$10            ; Are we out of digits?
.3a79a4	f0 1b		beq $3a79c1	                BEQ done            ; Yes... just return
.3a79a6	80 f2		bra $3a799a	                BRA seek_loop
.3a79a8					found
.3a79a8	c2 20		rep #$20	            REP #$20
.3a79aa	06 50		asl $0898	                ASL MPARSEDNUM
.3a79ac	26 52		rol $089a	                ROL MPARSEDNUM+2
.3a79ae	06 50		asl $0898	                ASL MPARSEDNUM
.3a79b0	26 52		rol $089a	                ROL MPARSEDNUM+2
.3a79b2	06 50		asl $0898	                ASL MPARSEDNUM
.3a79b4	26 52		rol $089a	                ROL MPARSEDNUM+2
.3a79b6	06 50		asl $0898	                ASL MPARSEDNUM
.3a79b8	26 52		rol $089a	                ROL MPARSEDNUM+2
.3a79ba	e2 20		sep #$20	            SEP #$20
.3a79bc	8a		txa		                TXA
.3a79bd	05 50		ora $0898	                ORA MPARSEDNUM
.3a79bf	85 50		sta $0898	                STA MPARSEDNUM
.3a79c1	fa		plx		done            PLX
.3a79c2	2b		pld		                PLD
.3a79c3	28		plp		                PLP
.3a79c4	6b		rtl		                RTL
.3a79c5					AS_FIND_OPCODE
.3a79c5	0b		phd		                PHD
.3a79c6	8b		phb		                PHB
.3a79c7	08		php		            PHP
.3a79c8	c2 20		rep #$20	            REP #$20
.3a79ca	48		pha		            PHA
.3a79cb	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a79ce	5b		tcd		            TCD
.3a79cf	68		pla		            PLA
.3a79d0	28		plp		            PLP
.3a79d1	08		php		            PHP
.3a79d2	e2 20		sep #$20	            SEP #$20
.3a79d4	48		pha		            PHA
.3a79d5	a9 3a		lda #$3a	            LDA #`MNEMONIC_TAB
.3a79d7	48		pha		            PHA
.3a79d8	ab		plb		            PLB
.3a79d9	68		pla		            PLA
.3a79da	28		plp		            PLP
.3a79db	e2 20		sep #$20	            SEP #$20
.3a79dd	a5 4f		lda $0897	                LDA MADDR_MODE
.3a79df	29 3f		and #$3f	                AND #%00111111
.3a79e1	85 4a		sta $0892	                STA MTEMP
.3a79e3	c2 30		rep #$30	            REP #$30
.3a79e5	a2 00 00	ldx #$0000	                LDX #0
.3a79e8	a0 00 00	ldy #$0000	                LDY #0
.3a79eb	bd 92 80	lda $3a8092,x	mnemonic_loop   LDA MNEMONIC_TAB,X      ; Get the mnemonic from the opcode table
.3a79ee	f0 1b		beq $3a7a0b	                BEQ not_found           ; If it's 0, we did not find the mnemonic
.3a79f0	c5 54		cmp $089c	                CMP MMNEMONIC           ; Does it match the passed mnemonic?
.3a79f2	d0 0d		bne $3a7a01	                BNE next_opcode         ; No: go to the next opcode
.3a79f4					check_mode
.3a79f4	e2 20		sep #$20	            SEP #$20
.3a79f6	b9 94 82	lda $3a8294,y	                LDA ADDRESS_TAB,Y       ; Get the corresponding address mode
.3a79f9	29 3f		and #$3f	                AND #%00111111          ; Filter out effect bits
.3a79fb	c5 4a		cmp $0892	                CMP MTEMP
.3a79fd	f0 07		beq $3a7a06	                BEQ found               ; Yes: we found the opcode
.3a79ff	c2 20		rep #$20	            REP #$20
.3a7a01	e8		inx		next_opcode     INX                     ; Point to the next mnemonic in the table
.3a7a02	e8		inx		                INX
.3a7a03	c8		iny		                INY
.3a7a04	80 e5		bra $3a79eb	                BRA mnemonic_loop       ; And check it
.3a7a06	98		tya		found           TYA
.3a7a07	38		sec		                SEC                     ; Set carry to show success
.3a7a08	ab		plb		                PLB
.3a7a09	2b		pld		                PLD
.3a7a0a	6b		rtl		                RTL
.3a7a0b	18		clc		not_found       CLC                     ; Clear carry to show failure
.3a7a0c	ab		plb		                PLB
.3a7a0d	2b		pld		                PLD
.3a7a0e	6b		rtl		                RTL
.3a7a0f					AS_STR_MATCH
.3a7a0f	08		php		                PHP
.3a7a10	0b		phd		                PHD
.3a7a11	08		php		            PHP
.3a7a12	c2 20		rep #$20	            REP #$20
.3a7a14	48		pha		            PHA
.3a7a15	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7a18	5b		tcd		            TCD
.3a7a19	68		pla		            PLA
.3a7a1a	28		plp		            PLP
.3a7a1b	e2 20		sep #$20	            SEP #$20
.3a7a1d	c2 10		rep #$10	            REP #$10
.3a7a1f	a0 00 00	ldy #$0000	                LDY #0
.3a7a22	64 50		stz $0898	                STZ MPARSEDNUM      ; Set parsed number to 0 in anticipation of
.3a7a24	64 52		stz $089a	                STZ MPARSEDNUM+2    ; hex digits in the pattern
.3a7a26	b7 03		lda [$084b],y	match_loop      LDA [MCMP_TEXT],Y   ; Get the pattern character
.3a7a28	f0 11		beq $3a7a3b	                BEQ nul_check       ; If at end of pattern, check for end of test string
.3a7a2a	c9 64		cmp #$64	                CMP #'d'            ; Is it a digit?
.3a7a2c	f0 19		beq $3a7a47	                BEQ check_digit     ; Yes: do special check for hex digit
.3a7a2e	48		pha		compare         PHA
.3a7a2f	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.3a7a31	85 4a		sta $0892	                STA MTEMP
.3a7a33	68		pla		                PLA
.3a7a34	c5 4a		cmp $0892	                CMP MTEMP           ; Does it match the character to test?
.3a7a36	d0 0b		bne $3a7a43	                BNE return_false    ; No: return fail
.3a7a38	c8		iny		next_char       INY                 ; Yes: test the next character
.3a7a39	80 eb		bra $3a7a26	                BRA match_loop
.3a7a3b	b7 36		lda [$087e],y	nul_check       LDA [MLINEBUF],Y    ; Check to see that we're at the end of the test string
.3a7a3d	d0 04		bne $3a7a43	                BNE return_false    ; If not: return false
.3a7a3f	2b		pld		return_true     PLD
.3a7a40	28		plp		                PLP                 ; Return true
.3a7a41	38		sec		                SEC
.3a7a42	6b		rtl		                RTL
.3a7a43	2b		pld		return_false    PLD
.3a7a44	28		plp		                PLP                 ; Return false
.3a7a45	18		clc		                CLC
.3a7a46	6b		rtl		                RTL
.3a7a47					check_digit
.3a7a47	e2 20		sep #$20	            SEP #$20
.3a7a49	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.3a7a4b	c9 3a		cmp #$3a	                CMP #'9'+1
.3a7a4d	b0 04		bcs $3a7a53	                BCS check_AF
.3a7a4f	c9 30		cmp #$30	                CMP #'0'
.3a7a51	b0 14		bcs $3a7a67	                BCS shift_digit     ; character is in [0..9]
.3a7a53	c9 47		cmp #$47	check_AF        CMP #'F'+1
.3a7a55	b0 04		bcs $3a7a5b	                BCS check_lc        ; check lower case
.3a7a57	c9 41		cmp #$41	                CMP #'A'
.3a7a59	b0 0c		bcs $3a7a67	                BCS shift_digit     ; character is in [A..F]
.3a7a5b	c9 67		cmp #$67	check_lc        CMP #'f'+1
.3a7a5d	b0 e4		bcs $3a7a43	                BCS return_false    ; check lower case
.3a7a5f	c9 61		cmp #$61	                CMP #'a'
.3a7a61	b0 02		bcs $3a7a65	                BCS to_upcase       ; character is in [A..F]
.3a7a63	80 de		bra $3a7a43	                BRA return_false    ; No match found... return false
.3a7a65	29 df		and #$df	to_upcase       AND #%11011111      ; Convert lower case to upper case
.3a7a67	22 86 79 3a	jsl $3a7986	shift_digit     JSL AS_SHIFT_HEX    ; Shift the digit into MPARSEDNUM
.3a7a6b	80 cb		bra $3a7a38	                BRA next_char       ; And check the next character
.3a7a6d					AS_MCMP_NEXT
.3a7a6d	0b		phd		                PHD
.3a7a6e	08		php		            PHP
.3a7a6f	c2 20		rep #$20	            REP #$20
.3a7a71	48		pha		            PHA
.3a7a72	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7a75	5b		tcd		            TCD
.3a7a76	68		pla		            PLA
.3a7a77	28		plp		            PLP
.3a7a78	a0 00 00	ldy #$0000	                LDY #0
.3a7a7b	e2 20		sep #$20	            SEP #$20
.3a7a7d	b7 03		lda [$084b],y	loop            LDA [MCMP_TEXT],Y   ; Check to see if we have gotten to the NUL
.3a7a7f	f0 03		beq $3a7a84	                BEQ found_nul
.3a7a81	c8		iny		                INY
.3a7a82	80 f9		bra $3a7a7d	                BRA loop
.3a7a84					found_nul
.3a7a84	c2 20		rep #$20	            REP #$20
.3a7a86	c8		iny		                INY                 ; Got to NUL... point to next byte
.3a7a87	5a		phy		                PHY
.3a7a88	68		pla		                PLA                 ; And add that index to MCMP_TEXT pointer
.3a7a89	18		clc		                CLC
.3a7a8a	65 03		adc $084b	                ADC MCMP_TEXT
.3a7a8c	85 03		sta $084b	                STA MCMP_TEXT
.3a7a8e	a5 05		lda $084d	                LDA MCMP_TEXT+2
.3a7a90	69 00 00	adc #$0000	                ADC #0
.3a7a93	85 05		sta $084d	                STA MCMP_TEXT+2
.3a7a95	2b		pld		                PLD
.3a7a96	6b		rtl		                RTL
.3a7a97					AS_FIND_MNEMO
.3a7a97	0b		phd		                PHD
.3a7a98	08		php		            PHP
.3a7a99	c2 20		rep #$20	            REP #$20
.3a7a9b	48		pha		            PHA
.3a7a9c	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7a9f	5b		tcd		            TCD
.3a7aa0	68		pla		            PLA
.3a7aa1	28		plp		            PLP
.3a7aa2	c2 20		rep #$20	            REP #$20
.3a7aa4	a5 11		lda $0859	                LDA MARG2                   ; Point MLINEBUF to the text
.3a7aa6	85 36		sta $087e	                STA MLINEBUF
.3a7aa8	a5 13		lda $085b	                LDA MARG2+2
.3a7aaa	85 38		sta $0880	                STA MLINEBUF+2
.3a7aac	a9 20 7f	lda #$7f20	                LDA #<>MNEMONICS_TAB        ; Point to the first mnemonic
.3a7aaf	85 03		sta $084b	                STA MCMP_TEXT
.3a7ab1	a9 3a 00	lda #$003a	                LDA #`MNEMONICS_TAB
.3a7ab4	85 05		sta $084d	                STA MCMP_TEXT+2
.3a7ab6	22 0f 7a 3a	jsl $3a7a0f	match_loop      JSL AS_STR_MATCH            ; Check to see if the text matches the mnemonic
.3a7aba	b0 0d		bcs $3a7ac9	                BCS found_mnemonic          ; If so: return that we found it
.3a7abc	22 6d 7a 3a	jsl $3a7a6d	                JSL AS_MCMP_NEXT            ; Point to the next mnemonic
.3a7ac0	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Check to see if it's NUL
.3a7ac2	d0 f2		bne $3a7ab6	                BNE match_loop              ; If not, check this next mnemonic
.3a7ac4	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Otherwise, return -1
.3a7ac7	80 02		bra $3a7acb	                BRA done
.3a7ac9	a5 03		lda $084b	found_mnemonic  LDA MCMP_TEXT               ; Found it: return the address
.3a7acb	2b		pld		done            PLD
.3a7acc	6b		rtl		                RTL
.3a7acd					AS_FIND_MODE
.3a7acd	08		php		                PHP
.3a7ace	0b		phd		                PHD
.3a7acf	08		php		            PHP
.3a7ad0	c2 20		rep #$20	            REP #$20
.3a7ad2	48		pha		            PHA
.3a7ad3	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7ad6	5b		tcd		            TCD
.3a7ad7	68		pla		            PLA
.3a7ad8	28		plp		            PLP
.3a7ad9	c2 30		rep #$30	            REP #$30
.3a7adb	a5 15		lda $085d	                LDA MARG3                   ; Point MLINEBUF to the operand
.3a7add	85 36		sta $087e	                STA MLINEBUF
.3a7adf	a5 17		lda $085f	                LDA MARG3+2
.3a7ae1	85 38		sta $0880	                STA MLINEBUF+2
.3a7ae3	a9 ac 83	lda #$83ac	                LDA #<>ADDR_PATTERNS        ; Point to the first address mode pattern to check
.3a7ae6	85 03		sta $084b	                STA MCMP_TEXT
.3a7ae8	a9 3a 00	lda #$003a	                LDA #`ADDR_PATTERNS
.3a7aeb	85 05		sta $084d	                STA MCMP_TEXT+2
.3a7aed	22 0f 7a 3a	jsl $3a7a0f	match_loop      JSL AS_STR_MATCH            ; Check to see if the pattern matches the operand
.3a7af1	b0 22		bcs $3a7b15	                BCS is_match                ; Yes: Find address mode code
.3a7af3	22 6d 7a 3a	jsl $3a7a6d	                JSL AS_MCMP_NEXT            ; Point to the address mode
.3a7af7	c2 20		rep #$20	            REP #$20
.3a7af9	18		clc		                CLC                         ; Point to the first byte of the next pattern
.3a7afa	a5 03		lda $084b	                LDA MCMP_TEXT
.3a7afc	69 01 00	adc #$0001	                ADC #1
.3a7aff	85 03		sta $084b	                STA MCMP_TEXT
.3a7b01	a5 05		lda $084d	                LDA MCMP_TEXT+2
.3a7b03	69 00 00	adc #$0000	                ADC #0
.3a7b06	85 05		sta $084d	                STA MCMP_TEXT+2
.3a7b08	e2 20		sep #$20	            SEP #$20
.3a7b0a	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Is the first byte 0?
.3a7b0c	d0 df		bne $3a7aed	                BNE match_loop              ; No: check this next pattern
.3a7b0e	c2 20		rep #$20	            REP #$20
.3a7b10	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Yes: we didn't find a matching pattern, return -1
.3a7b13	80 0d		bra $3a7b22	                BRA done
.3a7b15	22 6d 7a 3a	jsl $3a7a6d	is_match        JSL AS_MCMP_NEXT            ; Point to the address mode
.3a7b19	e2 20		sep #$20	            SEP #$20
.3a7b1b	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Get the corresponding address mode code (a byte)
.3a7b1d	c2 20		rep #$20	            REP #$20
.3a7b1f	29 ff 00	and #$00ff	                AND #$00FF
.3a7b22	2b		pld		done            PLD
.3a7b23	28		plp		                PLP
.3a7b24	6b		rtl		                RTL
.3a7b25					IMDISASSEMBLE
.3a7b25	08		php		                PHP
.3a7b26	8b		phb		                PHB
.3a7b27	0b		phd		                PHD
.3a7b28	08		php		            PHP
.3a7b29	c2 20		rep #$20	            REP #$20
.3a7b2b	48		pha		            PHA
.3a7b2c	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7b2f	5b		tcd		            TCD
.3a7b30	68		pla		            PLA
.3a7b31	28		plp		            PLP
.3a7b32	e2 20		sep #$20	            SEP #$20
.3a7b34	a9 00		lda #$00	                LDA #0
.3a7b36	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT     ; Clear the pagination line counter
.3a7b3a	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.3a7b3c	c9 02		cmp #$02	                CMP #2
.3a7b3e	b0 16		bcs $3a7b56	                BGE set_cursor      ; 2>= arguments? Use them as-is
.3a7b40	c9 01		cmp #$01	                CMP #1
.3a7b42	90 20		bcc $3a7b64	                BLT no_args         ; No arguments passed? Use defaults
.3a7b44	c2 20		rep #$20	            REP #$20
.3a7b46	18		clc		                CLC
.3a7b47	a5 0d		lda $0855	                LDA MARG1
.3a7b49	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.3a7b4c	85 11		sta $0859	                STA MARG2
.3a7b4e	e2 20		sep #$20	            SEP #$20
.3a7b50	a5 0f		lda $0857	                LDA MARG1+2
.3a7b52	69 00		adc #$00	                ADC #0
.3a7b54	85 13		sta $085b	                STA MARG2+2
.3a7b56					set_cursor
.3a7b56	c2 20		rep #$20	            REP #$20
.3a7b58	a5 0d		lda $0855	                LDA MARG1
.3a7b5a	85 32		sta $087a	                STA MCURSOR
.3a7b5c	e2 20		sep #$20	            SEP #$20
.3a7b5e	a5 0f		lda $0857	                LDA MARG1+2
.3a7b60	85 34		sta $087c	                STA MCURSOR+2
.3a7b62	80 12		bra $3a7b76	                BRA dasm_loop
.3a7b64					no_args
.3a7b64	c2 20		rep #$20	            REP #$20
.3a7b66	18		clc		                CLC
.3a7b67	a5 32		lda $087a	                LDA MCURSOR
.3a7b69	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.3a7b6c	85 11		sta $0859	                STA MARG2
.3a7b6e	e2 20		sep #$20	            SEP #$20
.3a7b70	a5 34		lda $087c	                LDA MCURSOR+2
.3a7b72	69 00		adc #$00	                ADC #0
.3a7b74	85 13		sta $085b	                STA MARG2+2
.3a7b76	22 91 7b 3a	jsl $3a7b91	dasm_loop       JSL DS_PR_LINE
.3a7b7a	e2 20		sep #$20	            SEP #$20
.3a7b7c	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.3a7b7e	c5 13		cmp $085b	                CMP MARG2+2
.3a7b80	90 f4		bcc $3a7b76	                BLT dasm_loop           ; No: continue
.3a7b82	c2 20		rep #$20	            REP #$20
.3a7b84	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.3a7b86	c5 11		cmp $0859	                CMP MARG2
.3a7b88	90 ec		bcc $3a7b76	                BLT dasm_loop           ; Nope... keep going
.3a7b8a					done
.3a7b8a	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a7b8d	2b		pld		                PLD
.3a7b8e	ab		plb		                PLB
.3a7b8f	28		plp		                PLP
.3a7b90	6b		rtl		                RTL
.3a7b91					DS_PR_LINE
.3a7b91	08		php		                PHP
.3a7b92	0b		phd		                PHD
.3a7b93	e2 20		sep #$20	            SEP #$20
.3a7b95	a9 41		lda #$41	                LDA #'A'
.3a7b97	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7b9a	a9 20		lda #$20	                LDA #' '
.3a7b9c	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7b9f	08		php		            PHP
.3a7ba0	c2 20		rep #$20	            REP #$20
.3a7ba2	48		pha		            PHA
.3a7ba3	a9 7a 08	lda #$087a	            LDA #MCURSOR
.3a7ba6	5b		tcd		            TCD
.3a7ba7	68		pla		            PLA
.3a7ba8	28		plp		            PLP
.3a7ba9	c2 20		rep #$20	            REP #$20
.3a7bab	a5 00		lda $087a	                LDA MCURSOR
.3a7bad	85 18		sta $0892	                STA MTEMP
.3a7baf	e2 20		sep #$20	            SEP #$20
.3a7bb1	a5 02		lda $087c	                LDA MCURSOR+2
.3a7bb3	85 1a		sta $0894	                STA MTEMP+2
.3a7bb5	22 f8 7e 3a	jsl $3a7ef8	                JSL M_PR_ADDR
.3a7bb9	a9 20		lda #$20	                LDA #' '
.3a7bbb	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7bbe	c2 20		rep #$20	            REP #$20
.3a7bc0	18		clc		                CLC
.3a7bc1	a5 00		lda $087a	                LDA MCURSOR
.3a7bc3	69 01 00	adc #$0001	                ADC #1
.3a7bc6	85 18		sta $0892	                STA MTEMP
.3a7bc8	e2 20		sep #$20	            SEP #$20
.3a7bca	a5 02		lda $087c	                LDA MCURSOR+2
.3a7bcc	69 00		adc #$00	                ADC #0
.3a7bce	85 1a		sta $0894	                STA MTEMP+2
.3a7bd0	e2 20		sep #$20	            SEP #$20
.3a7bd2	c2 10		rep #$10	            REP #$10
.3a7bd4	a7 00		lda [$087a]	                LDA [MCURSOR]           ; Get the mnemonic
.3a7bd6	c9 c2		cmp #$c2	                CMP #$C2                ; Is it REP?
.3a7bd8	d0 0b		bne $3a7be5	                BNE check_sep           ; No: check to see if it is SEP
.3a7bda	48		pha		handle_rep      PHA
.3a7bdb	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.3a7bdd	49 ff		eor #$ff	                EOR #$FF                ; Invert the bits
.3a7bdf	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Mask off the bits in the CPUSTAT
.3a7be3	80 0b		bra $3a7bf0	                BRA save_stat
.3a7be5	c9 e2		cmp #$e2	check_sep       CMP #$E2                ; Is it SEP?
.3a7be7	d0 0c		bne $3a7bf5	                BNE get_op_index        ; No: process the instruction regularly
.3a7be9	48		pha		handle_sep      PHA
.3a7bea	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.3a7bec	0f 96 08 00	ora $000896	                ORA @lMCPUSTAT          ; Activate the bits in the CPUSTAT
.3a7bf0	8f 96 08 00	sta $000896	save_stat       STA @lMCPUSTAT          ; And save it back
.3a7bf4	68		pla		                PLA
.3a7bf5					get_op_index
.3a7bf5	c2 20		rep #$20	            REP #$20
.3a7bf7	29 ff 00	and #$00ff	                AND #$00FF
.3a7bfa	0a		asl a		                ASL A
.3a7bfb	aa		tax		                TAX                     ; Get the index into the mnemonic lookup table
.3a7bfc	bf 92 80 3a	lda $3a8092,x	                LDA @lMNEMONIC_TAB,X    ; Get the mnemonic
.3a7c00	aa		tax		                TAX
.3a7c01	22 72 7e 3a	jsl $3a7e72	                JSL DS_PR_MNEMONIC      ; And print it
.3a7c05	e2 20		sep #$20	            SEP #$20
.3a7c07	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a7c09	aa		tax		                TAX
.3a7c0a	bf 94 82 3a	lda $3a8294,x	pr_operand      LDA @lADDRESS_TAB,X     ; Get the addressing mode for the instruction
.3a7c0e	22 4e 84 3a	jsl $3a844e	                JSL M_INC_CURSOR        ; Advance the cursor to the next byte
.3a7c12	22 1f 7c 3a	jsl $3a7c1f	                JSL DS_PR_OPERAND       ; And print the correct operand
.3a7c16	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a7c19	20 a0 02	jsr $3a02a0	            JSR PAGINATE
.3a7c1c	2b		pld		                PLD
.3a7c1d	28		plp		                PLP
.3a7c1e	6b		rtl		                RTL
.3a7c1f					DS_PR_OPERAND
.3a7c1f	08		php		                PHP
.3a7c20	e2 20		sep #$20	            SEP #$20
.3a7c22	48		pha		                PHA             ; Save the address mode so we can get to the M and X flags
.3a7c23	29 3f		and #$3f	                AND #%00111111  ; Filter out the mode flags
.3a7c25	0a		asl a		                ASL A           ; Compute the index to the table
.3a7c26	c2 10		rep #$10	            REP #$10
.3a7c28	aa		tax		                TAX
.3a7c29	68		pla		                PLA             ; Restore A
.3a7c2a	7c 2d 7c	jmp ($3a7c2d,x)	                JMP (dispatch,X)
>3a7c2d	5d 7c				dispatch        .word <>is_dp_ind_x
>3a7c2f	78 7c				                .word <>is_dp
>3a7c31	7f 7c				                .word <>is_imm
>3a7c33	a4 7c				                .word <>is_abs
>3a7c35	ab 7c				                .word <>is_dp_ind_y
>3a7c37	c6 7c				                .word <>is_dp_x
>3a7c39	e8 7c				                .word <>is_abs_y
>3a7c3b	f9 7c				                .word <>is_abs_x
>3a7c3d	36 7d				                .word <>is_accumulator
>3a7c3f	3e 7d				                .word <>is_stack_r
>3a7c41	4f 7d				                .word <>is_dp_long
>3a7c43	60 7d				                .word <>is_abs_long
>3a7c45	67 7d				                .word <>is_stack_r_y
>3a7c47	8c 7d				                .word <>is_dp_y_long
>3a7c49	b9 7d				                .word <>is_abs_x_long
>3a7c4b	25 7d				                .word <>is_dp_ind
>3a7c4d	0a 7d				                .word <>is_abs_x_id
>3a7c4f	d7 7c				                .word <>is_dp_y
>3a7c51	ac 7d				                .word <>is_pc_rel
>3a7c53	b6 7d				                .word <>is_implied
>3a7c55	ca 7d				                .word <>is_xyc
>3a7c57	f9 7d				                .word <>is_abs_ind
>3a7c59	a7 7d				                .word <>is_pc_rel_long
>3a7c5b	0a 7e				                .word <>is_abs_ind_long
.3a7c5d	a9 28		lda #$28	is_dp_ind_x     LDA #'('                ; Print (dd,X)
.3a7c5f	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7c62	22 21 7e 3a	jsl $3a7e21	                JSL DS_PR_OPERAND1      ; Print dd
.3a7c66	a9 2c		lda #$2c	                LDA #','
.3a7c68	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7c6b	a9 58		lda #$58	                LDA #'X'
.3a7c6d	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7c70	a9 29		lda #$29	                LDA #')'
.3a7c72	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7c75	4c 1b 7e	jmp $3a7e1b	                JMP done_1
.3a7c78	22 21 7e 3a	jsl $3a7e21	is_dp           JSL DS_PR_OPERAND1      ; Print dd
.3a7c7c	4c 1b 7e	jmp $3a7e1b	                JMP done_1
.3a7c7f					is_imm
.3a7c7f	e2 20		sep #$20	            SEP #$20
.3a7c81	48		pha		                PHA
.3a7c82	a9 23		lda #$23	                LDA #'#'
.3a7c84	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7c87	68		pla		                PLA
.3a7c88	29 c0		and #$c0	                AND #%11000000          ; Filter so we just look at the mode bits
.3a7c8a	c9 00		cmp #$00	                CMP #$00                ; Are any set to check?
.3a7c8c	f0 0f		beq $3a7c9d	                BEQ is_imm_short        ; No: treat it as a short always
.3a7c8e	4a		lsr a		                LSR A                   ; Move the flag bits right by 2 to match
.3a7c8f	4a		lsr a		                LSR A                   ; the positions of the bits in the CPU status register
.3a7c90	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Otherwise, filter the mode bit we care about
.3a7c94	d0 07		bne $3a7c9d	                BNE is_imm_short        ; If it is set, immediate operation is short
.3a7c96	22 2b 7e 3a	jsl $3a7e2b	                JSL DS_PR_OPERAND2      ; Print dddd
.3a7c9a	4c 1b 7e	jmp $3a7e1b	                JMP done_1
.3a7c9d	22 21 7e 3a	jsl $3a7e21	is_imm_short    JSL DS_PR_OPERAND1      ; Print dd
.3a7ca1	4c 1b 7e	jmp $3a7e1b	                JMP done_1
.3a7ca4	22 2b 7e 3a	jsl $3a7e2b	is_abs          JSL DS_PR_OPERAND2      ; Print dddd
.3a7ca8	4c 1b 7e	jmp $3a7e1b	                JMP done_1
.3a7cab	a9 28		lda #$28	is_dp_ind_y     LDA #'('                ; Print (dd),Y
.3a7cad	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7cb0	22 21 7e 3a	jsl $3a7e21	                JSL DS_PR_OPERAND1      ; Print dd
.3a7cb4	a9 29		lda #$29	                LDA #')'
.3a7cb6	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7cb9	a9 2c		lda #$2c	                LDA #','
.3a7cbb	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7cbe	a9 59		lda #$59	                LDA #'Y'
.3a7cc0	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7cc3	4c 1b 7e	jmp $3a7e1b	                JMP done_1
.3a7cc6	22 21 7e 3a	jsl $3a7e21	is_dp_x         JSL DS_PR_OPERAND1      ; Print dd,X
.3a7cca	a9 2c		lda #$2c	                LDA #','
.3a7ccc	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7ccf	a9 58		lda #$58	                LDA #'X'
.3a7cd1	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7cd4	4c 1b 7e	jmp $3a7e1b	                JMP done_1
.3a7cd7	22 21 7e 3a	jsl $3a7e21	is_dp_y         JSL DS_PR_OPERAND1      ; Print dd,Y
.3a7cdb	a9 2c		lda #$2c	                LDA #','
.3a7cdd	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7ce0	a9 59		lda #$59	                LDA #'Y'
.3a7ce2	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7ce5	4c 1b 7e	jmp $3a7e1b	                JMP done_1
.3a7ce8	22 2b 7e 3a	jsl $3a7e2b	is_abs_y        JSL DS_PR_OPERAND2      ; Print dddd,Y
.3a7cec	a9 2c		lda #$2c	                LDA #','
.3a7cee	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7cf1	a9 59		lda #$59	                LDA #'Y'
.3a7cf3	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7cf6	4c 1b 7e	jmp $3a7e1b	                JMP done_1
.3a7cf9	22 2b 7e 3a	jsl $3a7e2b	is_abs_x        JSL DS_PR_OPERAND2      ; Print dddd,X
.3a7cfd	a9 2c		lda #$2c	                LDA #','
.3a7cff	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d02	a9 58		lda #$58	                LDA #'X'
.3a7d04	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d07	4c 1b 7e	jmp $3a7e1b	                JMP done_1
.3a7d0a	a9 28		lda #$28	is_abs_x_id     LDA #'('
.3a7d0c	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d0f	22 2b 7e 3a	jsl $3a7e2b	                JSL DS_PR_OPERAND2      ; Print (dddd,X)
.3a7d13	a9 2c		lda #$2c	                LDA #','
.3a7d15	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d18	a9 58		lda #$58	                LDA #'X'
.3a7d1a	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d1d	a9 29		lda #$29	                LDA #')'
.3a7d1f	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d22	4c 1b 7e	jmp $3a7e1b	                JMP done_1
.3a7d25	a9 28		lda #$28	is_dp_ind       LDA #'('
.3a7d27	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d2a	22 21 7e 3a	jsl $3a7e21	                JSL DS_PR_OPERAND1      ; Print (dd)
.3a7d2e	a9 29		lda #$29	                LDA #')'
.3a7d30	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d33	4c 1b 7e	jmp $3a7e1b	                JMP done_1
.3a7d36	a9 41		lda #$41	is_accumulator  LDA #'A'                ; Print A
.3a7d38	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d3b	4c 1f 7e	jmp $3a7e1f	                JMP done
.3a7d3e	22 21 7e 3a	jsl $3a7e21	is_stack_r      JSL DS_PR_OPERAND1      ; Print dd,S
.3a7d42	a9 2c		lda #$2c	                LDA #','
.3a7d44	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d47	a9 53		lda #$53	                LDA #'S'
.3a7d49	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d4c	4c 1b 7e	jmp $3a7e1b	                JMP done_1
.3a7d4f	a9 5b		lda #$5b	is_dp_long      LDA #'['                ; [dd]
.3a7d51	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d54	22 21 7e 3a	jsl $3a7e21	                JSL DS_PR_OPERAND1      ; Print dd
.3a7d58	a9 5d		lda #$5d	                LDA #']'
.3a7d5a	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d5d	4c 1b 7e	jmp $3a7e1b	                JMP done_1
.3a7d60	22 39 7e 3a	jsl $3a7e39	is_abs_long     JSL DS_PR_OPERAND3      ; Print dddddd
.3a7d64	4c 1f 7e	jmp $3a7e1f	                JMP done
.3a7d67	a9 28		lda #$28	is_stack_r_y    LDA #'('                ; (dd,S),Y
.3a7d69	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d6c	22 21 7e 3a	jsl $3a7e21	                JSL DS_PR_OPERAND1      ; Print dd
.3a7d70	a9 2c		lda #$2c	                LDA #','
.3a7d72	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d75	a9 53		lda #$53	                LDA #'S'
.3a7d77	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d7a	a9 29		lda #$29	                LDA #')'
.3a7d7c	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d7f	a9 2c		lda #$2c	                LDA #','
.3a7d81	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d84	a9 59		lda #$59	                LDA #'Y'
.3a7d86	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d89	4c 1b 7e	jmp $3a7e1b	                JMP done_1
.3a7d8c	a9 5b		lda #$5b	is_dp_y_long    LDA #'['                ; [dd],Y
.3a7d8e	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d91	22 21 7e 3a	jsl $3a7e21	                JSL DS_PR_OPERAND1      ; Print dd
.3a7d95	a9 5d		lda #$5d	                LDA #']'
.3a7d97	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d9a	a9 2c		lda #$2c	                LDA #','
.3a7d9c	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7d9f	a9 59		lda #$59	                LDA #'Y'
.3a7da1	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7da4	4c 1b 7e	jmp $3a7e1b	                JMP done_1
.3a7da7	a0 02 00	ldy #$0002	is_pc_rel_long  LDY #2
.3a7daa	80 03		bra $3a7daf	                BRA do_pcrel
.3a7dac	a0 01 00	ldy #$0001	is_pc_rel       LDY #1
.3a7daf	22 9f 7e 3a	jsl $3a7e9f	do_pcrel        JSL DS_PR_PCREL
.3a7db3	4c 1f 7e	jmp $3a7e1f	                JMP done
.3a7db6	4c 1f 7e	jmp $3a7e1f	is_implied      JMP done
.3a7db9	22 39 7e 3a	jsl $3a7e39	is_abs_x_long   JSL DS_PR_OPERAND3      ; Print dddddd
.3a7dbd	a9 2c		lda #$2c	                LDA #','
.3a7dbf	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7dc2	a9 58		lda #$58	                LDA #'X'
.3a7dc4	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7dc7	4c 1f 7e	jmp $3a7e1f	                JMP done
.3a7dca	a9 23		lda #$23	is_xyc          LDA #'#'
.3a7dcc	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7dcf	8b		phb		                PHB                     ; Make sure the databank is pointed to our number
.3a7dd0	a5 02		lda $087c	                LDA MCURSOR+2
.3a7dd2	48		pha		                PHA
.3a7dd3	ab		plb		                PLB
.3a7dd4	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.3a7dd6	e8		inx		                INX
.3a7dd7	a0 01 00	ldy #$0001	                LDY #1
.3a7dda	22 99 02 3a	jsl $3a0299	                JSL PRINTH
.3a7dde	a9 2c		lda #$2c	                LDA #','
.3a7de0	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7de3	a9 23		lda #$23	                LDA #'#'
.3a7de5	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7de8	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.3a7dea	a0 01 00	ldy #$0001	                LDY #1
.3a7ded	22 99 02 3a	jsl $3a0299	                JSL PRINTH
.3a7df1	ab		plb		                PLB                     ; Get our old data bank back
.3a7df2	22 4e 84 3a	jsl $3a844e	                JSL M_INC_CURSOR
.3a7df6	4c 1b 7e	jmp $3a7e1b	                JMP done_1
.3a7df9	a9 28		lda #$28	is_abs_ind      LDA #'('
.3a7dfb	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7dfe	22 2b 7e 3a	jsl $3a7e2b	                JSL DS_PR_OPERAND2      ; Print (dddd)
.3a7e02	a9 29		lda #$29	                LDA #')'
.3a7e04	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e07	4c 1b 7e	jmp $3a7e1b	                JMP done_1
.3a7e0a	a9 5b		lda #$5b	is_abs_ind_long LDA #'['
.3a7e0c	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e0f	22 2b 7e 3a	jsl $3a7e2b	                JSL DS_PR_OPERAND2      ; Print [dddd]
.3a7e13	a9 5d		lda #$5d	                LDA #']'
.3a7e15	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e18	4c 1b 7e	jmp $3a7e1b	                JMP done_1
.3a7e1b	22 4e 84 3a	jsl $3a844e	done_1          JSL M_INC_CURSOR    ; Skip over a single byte operand
.3a7e1f	28		plp		done            PLP
.3a7e20	6b		rtl		                RTL
.3a7e21					DS_PR_OPERAND1
.3a7e21	08		php		                PHP
.3a7e22	e2 20		sep #$20	            SEP #$20
.3a7e24	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a7e26	20 40 03	jsr $3a0340	            JSR PRHEXB
.3a7e29	28		plp		                PLP
.3a7e2a	6b		rtl		                RTL
.3a7e2b					DS_PR_OPERAND2
.3a7e2b	08		php		                PHP
.3a7e2c	c2 30		rep #$30	            REP #$30
.3a7e2e	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a7e30	20 26 03	jsr $3a0326	            JSR PRHEXW
.3a7e33	22 4e 84 3a	jsl $3a844e	                JSL M_INC_CURSOR
.3a7e37	28		plp		                PLP
.3a7e38	6b		rtl		                RTL
.3a7e39					DS_PR_OPERAND3
.3a7e39	08		php		                PHP
.3a7e3a	8b		phb		                PHB
.3a7e3b	0b		phd		                PHD
.3a7e3c	c2 30		rep #$30	            REP #$30
.3a7e3e	5a		phy		                PHY
.3a7e3f	08		php		            PHP
.3a7e40	c2 20		rep #$20	            REP #$20
.3a7e42	48		pha		            PHA
.3a7e43	a9 7a 08	lda #$087a	            LDA #MCURSOR
.3a7e46	5b		tcd		            TCD
.3a7e47	68		pla		            PLA
.3a7e48	28		plp		            PLP
.3a7e49	08		php		            PHP
.3a7e4a	e2 20		sep #$20	            SEP #$20
.3a7e4c	48		pha		            PHA
.3a7e4d	a9 00		lda #$00	            LDA #`MTEMP
.3a7e4f	48		pha		            PHA
.3a7e50	ab		plb		            PLB
.3a7e51	68		pla		            PLA
.3a7e52	28		plp		            PLP
.3a7e53	e2 20		sep #$20	            SEP #$20
.3a7e55	a0 00 00	ldy #$0000	                LDY #0
.3a7e58	a7 00		lda [$087a]	copy_loop       LDA [MCURSOR]       ; Copy the address pointed to by MCURSOR
.3a7e5a	99 92 08	sta $0892,y	                STA MTEMP,Y         ; to MTEMP
.3a7e5d	22 4e 84 3a	jsl $3a844e	                JSL M_INC_CURSOR
.3a7e61	c8		iny		                INY
.3a7e62	c0 03 00	cpy #$0003	                CPY #3
.3a7e65	d0 f1		bne $3a7e58	                BNE copy_loop
.3a7e67	22 f8 7e 3a	jsl $3a7ef8	                JSL M_PR_ADDR       ; Print the address
.3a7e6b	c2 30		rep #$30	            REP #$30
.3a7e6d	7a		ply		                PLY
.3a7e6e	2b		pld		                PLD
.3a7e6f	ab		plb		                PLB
.3a7e70	28		plp		                PLP
.3a7e71	6b		rtl		                RTL
.3a7e72					DS_PR_MNEMONIC
.3a7e72	08		php		                PHP
.3a7e73	8b		phb		                PHB
.3a7e74	e2 20		sep #$20	            SEP #$20
.3a7e76	c2 10		rep #$10	            REP #$10
.3a7e78	08		php		            PHP
.3a7e79	e2 20		sep #$20	            SEP #$20
.3a7e7b	48		pha		            PHA
.3a7e7c	a9 3a		lda #$3a	            LDA #`MN_ORA
.3a7e7e	48		pha		            PHA
.3a7e7f	ab		plb		            PLB
.3a7e80	68		pla		            PLA
.3a7e81	28		plp		            PLP
.3a7e82	bd 00 00	lda $3a0000,x	                LDA #0,B,X
.3a7e85	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e88	e8		inx		                INX
.3a7e89	bd 00 00	lda $3a0000,x	                LDA #0,B,X
.3a7e8c	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e8f	e8		inx		                INX
.3a7e90	bd 00 00	lda $3a0000,x	                LDA #0,B,X
.3a7e93	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e96	e8		inx		                INX
.3a7e97	a9 20		lda #$20	                LDA #' '            ; Print a space
.3a7e99	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e9c	ab		plb		                PLB
.3a7e9d	28		plp		                PLP
.3a7e9e	6b		rtl		                RTL
.3a7e9f					DS_PR_PCREL
.3a7e9f	08		php		                PHP
.3a7ea0	0b		phd		                PHD
.3a7ea1	08		php		            PHP
.3a7ea2	c2 20		rep #$20	            REP #$20
.3a7ea4	48		pha		            PHA
.3a7ea5	a9 7a 08	lda #$087a	            LDA #MCURSOR
.3a7ea8	5b		tcd		            TCD
.3a7ea9	68		pla		            PLA
.3a7eaa	28		plp		            PLP
.3a7eab	e2 20		sep #$20	            SEP #$20
.3a7ead	c0 02 00	cpy #$0002	                CPY #2
.3a7eb0	f0 14		beq $3a7ec6	                BEQ offset_2
.3a7eb2	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a7eb4	85 18		sta $0892	                STA MTEMP
.3a7eb6	30 06		bmi $3a7ebe	                BMI is_negative
.3a7eb8	64 19		stz $0893	                STZ MTEMP+1
.3a7eba	64 1a		stz $0894	                STZ MTEMP+2
.3a7ebc	80 1e		bra $3a7edc	                BRA add_offset
.3a7ebe	a9 ff		lda #$ff	is_negative     LDA #$FF
.3a7ec0	85 19		sta $0893	                STA MTEMP+1
.3a7ec2	85 1a		sta $0894	                STA MTEMP+2
.3a7ec4	80 16		bra $3a7edc	                BRA add_offset
.3a7ec6	a7 00		lda [$087a]	offset_2        LDA [MCURSOR]
.3a7ec8	85 18		sta $0892	                STA MTEMP
.3a7eca	22 4e 84 3a	jsl $3a844e	                JSL M_INC_CURSOR
.3a7ece	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a7ed0	85 19		sta $0893	                STA MTEMP+1
.3a7ed2	30 04		bmi $3a7ed8	                BMI is_negative2
.3a7ed4	64 1a		stz $0894	                STZ MTEMP+2
.3a7ed6	80 04		bra $3a7edc	                BRA add_offset
.3a7ed8	a9 ff		lda #$ff	is_negative2    LDA #$FF
.3a7eda	85 1a		sta $0894	                STA MTEMP+2
.3a7edc					add_offset
.3a7edc	c2 20		rep #$20	            REP #$20
.3a7ede	38		sec		                SEC             ; Add 1 to the offset
.3a7edf	a5 00		lda $087a	                LDA MCURSOR
.3a7ee1	65 18		adc $0892	                ADC MTEMP
.3a7ee3	85 18		sta $0892	                STA MTEMP
.3a7ee5	e2 20		sep #$20	            SEP #$20
.3a7ee7	a5 02		lda $087c	                LDA MCURSOR+2
.3a7ee9	65 1a		adc $0894	                ADC MTEMP+2
.3a7eeb	85 1a		sta $0894	                STA MTEMP+2
.3a7eed	22 f8 7e 3a	jsl $3a7ef8	                JSL M_PR_ADDR
.3a7ef1	22 4e 84 3a	jsl $3a844e	                JSL M_INC_CURSOR
.3a7ef5	2b		pld		                PLD
.3a7ef6	28		plp		                PLP
.3a7ef7	6b		rtl		                RTL
.3a7ef8					M_PR_ADDR
.3a7ef8	08		php		                PHP
.3a7ef9	0b		phd		                PHD
.3a7efa	c2 20		rep #$20	            REP #$20
.3a7efc	48		pha		                PHA
.3a7efd	08		php		            PHP
.3a7efe	c2 20		rep #$20	            REP #$20
.3a7f00	48		pha		            PHA
.3a7f01	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7f04	5b		tcd		            TCD
.3a7f05	68		pla		            PLA
.3a7f06	28		plp		            PLP
.3a7f07	e2 20		sep #$20	            SEP #$20
.3a7f09	a5 4c		lda $0894	                LDA MTEMP+2     ; Print the bank byte of the address
.3a7f0b	20 40 03	jsr $3a0340	            JSR PRHEXB
.3a7f0e	e2 20		sep #$20	            SEP #$20
.3a7f10	a9 3a		lda #$3a	                LDA #':'
.3a7f12	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f15	c2 20		rep #$20	            REP #$20
.3a7f17	a5 4a		lda $0892	                LDA MTEMP       ; Print the lower 16-bits of the address
.3a7f19	20 26 03	jsr $3a0326	            JSR PRHEXW
.3a7f1c	68		pla		                PLA
.3a7f1d	2b		pld		                PLD
.3a7f1e	28		plp		                PLP
.3a7f1f	6b		rtl		                RTL
.3a7f20					MNEMONICS_TAB
.3a7f20					MN_ORA
>3a7f20	4f 52 41 00			            .null "ORA"
.3a7f24					MN_AND
>3a7f24	41 4e 44 00			            .null "AND"
.3a7f28					MN_EOR
>3a7f28	45 4f 52 00			            .null "EOR"
.3a7f2c					MN_ADC
>3a7f2c	41 44 43 00			            .null "ADC"
.3a7f30					MN_STA
>3a7f30	53 54 41 00			            .null "STA"
.3a7f34					MN_LDA
>3a7f34	4c 44 41 00			            .null "LDA"
.3a7f38					MN_CMP
>3a7f38	43 4d 50 00			            .null "CMP"
.3a7f3c					MN_SBC
>3a7f3c	53 42 43 00			            .null "SBC"
.3a7f40					MN_ASL
>3a7f40	41 53 4c 00			            .null "ASL"
.3a7f44					MN_ROL
>3a7f44	52 4f 4c 00			            .null "ROL"
.3a7f48					MN_LSR
>3a7f48	4c 53 52 00			            .null "LSR"
.3a7f4c					MN_ROR
>3a7f4c	52 4f 52 00			            .null "ROR"
.3a7f50					MN_STX
>3a7f50	53 54 58 00			            .null "STX"
.3a7f54					MN_LDX
>3a7f54	4c 44 58 00			            .null "LDX"
.3a7f58					MN_DEC
>3a7f58	44 45 43 00			            .null "DEC"
.3a7f5c					MN_INC
>3a7f5c	49 4e 43 00			            .null "INC"
.3a7f60					MN_BIT
>3a7f60	42 49 54 00			            .null "BIT"
.3a7f64					MN_JMP
>3a7f64	4a 4d 50 00			            .null "JMP"
.3a7f68					MN_STY
>3a7f68	53 54 59 00			            .null "STY"
.3a7f6c					MN_LDY
>3a7f6c	4c 44 59 00			            .null "LDY"
.3a7f70					MN_CPY
>3a7f70	43 50 59 00			            .null "CPY"
.3a7f74					MN_CPX
>3a7f74	43 50 58 00			            .null "CPX"
.3a7f78					MN_BRK
>3a7f78	42 52 4b 00			            .null "BRK"
.3a7f7c					MN_JSR
>3a7f7c	4a 53 52 00			            .null "JSR"
.3a7f80					MN_RTI
>3a7f80	52 54 49 00			            .null "RTI"
.3a7f84					MN_RTS
>3a7f84	52 54 53 00			            .null "RTS"
.3a7f88					MN_PHP
>3a7f88	50 48 50 00			            .null "PHP"
.3a7f8c					MN_PLP
>3a7f8c	50 4c 50 00			            .null "PLP"
.3a7f90					MN_PHA
>3a7f90	50 48 41 00			            .null "PHA"
.3a7f94					MN_PLA
>3a7f94	50 4c 41 00			            .null "PLA"
.3a7f98					MN_DEY
>3a7f98	44 45 59 00			            .null "DEY"
.3a7f9c					MN_TAY
>3a7f9c	54 41 59 00			            .null "TAY"
.3a7fa0					MN_INY
>3a7fa0	49 4e 59 00			            .null "INY"
.3a7fa4					MN_INX
>3a7fa4	49 4e 58 00			            .null "INX"
.3a7fa8					MN_CLC
>3a7fa8	43 4c 43 00			            .null "CLC"
.3a7fac					MN_SEC
>3a7fac	53 45 43 00			            .null "SEC"
.3a7fb0					MN_CLI
>3a7fb0	43 4c 49 00			            .null "CLI"
.3a7fb4					MN_SEI
>3a7fb4	53 45 49 00			            .null "SEI"
.3a7fb8					MN_TYA
>3a7fb8	54 59 41 00			            .null "TYA"
.3a7fbc					MN_CLV
>3a7fbc	43 4c 56 00			            .null "CLV"
.3a7fc0					MN_CLD
>3a7fc0	43 4c 44 00			            .null "CLD"
.3a7fc4					MN_SED
>3a7fc4	53 45 44 00			            .null "SED"
.3a7fc8					MN_TXA
>3a7fc8	54 58 41 00			            .null "TXA"
.3a7fcc					MN_TXS
>3a7fcc	54 58 53 00			            .null "TXS"
.3a7fd0					MN_TAX
>3a7fd0	54 41 58 00			            .null "TAX"
.3a7fd4					MN_TSX
>3a7fd4	54 53 58 00			            .null "TSX"
.3a7fd8					MN_DEX
>3a7fd8	44 45 58 00			            .null "DEX"
.3a7fdc					MN_NOP
>3a7fdc	4e 4f 50 00			            .null "NOP"
.3a7fe0					MN_BPL
>3a7fe0	42 50 4c 00			            .null "BPL"
.3a7fe4					MN_BMI
>3a7fe4	42 4d 49 00			            .null "BMI"
.3a7fe8					MN_BVC
>3a7fe8	42 56 43 00			            .null "BVC"
.3a7fec					MN_BVS
>3a7fec	42 56 53 00			            .null "BVS"
.3a7ff0					MN_BCC
>3a7ff0	42 43 43 00			            .null "BCC"
.3a7ff4					MN_BCS
>3a7ff4	42 43 53 00			            .null "BCS"
.3a7ff8					MN_BNE
>3a7ff8	42 4e 45 00			            .null "BNE"
.3a7ffc					MN_BEQ
>3a7ffc	42 45 51 00			            .null "BEQ"
.3a8000					MN_TSB
>3a8000	54 53 42 00			            .null "TSB"
.3a8004					MN_TRB
>3a8004	54 52 42 00			            .null "TRB"
.3a8008					MN_STZ
>3a8008	53 54 5a 00			            .null "STZ"
.3a800c					MN_BRA
>3a800c	42 52 41 00			            .null "BRA"
.3a8010					MN_PHY
>3a8010	50 48 59 00			            .null "PHY"
.3a8014					MN_PLY
>3a8014	50 4c 59 00			            .null "PLY"
.3a8018					MN_PHX
>3a8018	50 48 58 00			            .null "PHX"
.3a801c					MN_PLX
>3a801c	50 4c 58 00			            .null "PLX"
.3a8020					MN_PHD
>3a8020	50 48 44 00			            .null "PHD"
.3a8024					MN_PLD
>3a8024	50 4c 44 00			            .null "PLD"
.3a8028					MN_PHK
>3a8028	50 48 4b 00			            .null "PHK"
.3a802c					MN_RTL
>3a802c	52 54 4c 00			            .null "RTL"
.3a8030					MN_PHB
>3a8030	50 48 42 00			            .null "PHB"
.3a8034					MN_PLB
>3a8034	50 4c 42 00			            .null "PLB"
.3a8038					MN_WAI
>3a8038	57 41 49 00			            .null "WAI"
.3a803c					MN_XBA
>3a803c	58 42 41 00			            .null "XBA"
.3a8040					MN_TCS
>3a8040	54 43 53 00			            .null "TCS"
.3a8044					MN_TSC
>3a8044	54 53 43 00			            .null "TSC"
.3a8048					MN_TCD
>3a8048	54 43 44 00			            .null "TCD"
.3a804c					MN_TDC
>3a804c	54 44 43 00			            .null "TDC"
.3a8050					MN_TXY
>3a8050	54 58 59 00			            .null "TXY"
.3a8054					MN_TYX
>3a8054	54 59 58 00			            .null "TYX"
.3a8058					MN_STP
>3a8058	53 54 50 00			            .null "STP"
.3a805c					MN_XCE
>3a805c	58 43 45 00			            .null "XCE"
.3a8060					MN_COP
>3a8060	43 4f 50 00			            .null "COP"
.3a8064					MN_JSL
>3a8064	4a 53 4c 00			            .null "JSL"
.3a8068					MN_WDM
>3a8068	57 44 4d 00			            .null "WDM"
.3a806c					MN_PER
>3a806c	50 45 52 00			            .null "PER"
.3a8070					MN_BRL
>3a8070	42 52 4c 00			            .null "BRL"
.3a8074					MN_REP
>3a8074	52 45 50 00			            .null "REP"
.3a8078					MN_SEP
>3a8078	53 45 50 00			            .null "SEP"
.3a807c					MN_MVP
>3a807c	4d 56 50 00			            .null "MVP"
.3a8080					MN_MVN
>3a8080	4d 56 4e 00			            .null "MVN"
.3a8084					MN_PEI
>3a8084	50 45 49 00			            .null "PEI"
.3a8088					MN_PEA
>3a8088	50 45 41 00			            .null "PEA"
.3a808c					MN_JML
>3a808c	4a 4d 4c 00			            .null "JML"
>3a8090	00 00				            .byte 0, 0
>3a8092	78 7f 20 7f 60 80 20 7f		MNEMONIC_TAB    .word <>MN_BRK, <>MN_ORA, <>MN_COP, <>MN_ORA, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 0x
>3a809a	00 80 20 7f 40 7f 20 7f
>3a80a2	88 7f 20 7f 40 7f 20 80		                .word <>MN_PHP, <>MN_ORA, <>MN_ASL, <>MN_PHD, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>3a80aa	00 80 20 7f 40 7f 20 7f
>3a80b2	e0 7f 20 7f 20 7f 20 7f		                .word <>MN_BPL, <>MN_ORA, <>MN_ORA, <>MN_ORA, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 1x
>3a80ba	04 80 20 7f 40 7f 20 7f
>3a80c2	a8 7f 20 7f 5c 7f 40 80		                .word <>MN_CLC, <>MN_ORA, <>MN_INC, <>MN_TCS, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>3a80ca	04 80 20 7f 40 7f 20 7f
>3a80d2	7c 7f 24 7f 64 80 24 7f		                .word <>MN_JSR, <>MN_AND, <>MN_JSL, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 2x
>3a80da	60 7f 24 7f 44 7f 24 7f
>3a80e2	8c 7f 24 7f 44 7f 24 80		                .word <>MN_PLP, <>MN_AND, <>MN_ROL, <>MN_PLD, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>3a80ea	60 7f 24 7f 44 7f 24 7f
>3a80f2	e4 7f 24 7f 24 7f 24 7f		                .word <>MN_BMI, <>MN_AND, <>MN_AND, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 3x
>3a80fa	60 7f 24 7f 44 7f 24 7f
>3a8102	ac 7f 24 7f 58 7f 44 80		                .word <>MN_SEC, <>MN_AND, <>MN_DEC, <>MN_TSC, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>3a810a	60 7f 24 7f 44 7f 24 7f
>3a8112	80 7f 28 7f 68 80 28 7f		                .word <>MN_RTI, <>MN_EOR, <>MN_WDM, <>MN_EOR, <>MN_MVP, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 4x
>3a811a	7c 80 28 7f 48 7f 28 7f
>3a8122	90 7f 28 7f 48 7f 28 80		                .word <>MN_PHA, <>MN_EOR, <>MN_LSR, <>MN_PHK, <>MN_JMP, <>MN_EOR, <>MN_LSR, <>MN_EOR
>3a812a	64 7f 28 7f 48 7f 28 7f
>3a8132	e8 7f 28 7f 28 7f 28 7f		                .word <>MN_BVC, <>MN_EOR, <>MN_EOR, <>MN_EOR, <>MN_MVN, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 5x
>3a813a	80 80 28 7f 48 7f 28 7f
>3a8142	b0 7f 28 7f 10 80 48 80		                .word <>MN_CLI, <>MN_EOR, <>MN_PHY, <>MN_TCD, <>MN_JML, <>MN_EOR, <>MN_LSR, <>MN_EOR
>3a814a	8c 80 28 7f 48 7f 28 7f
>3a8152	84 7f 2c 7f 6c 80 2c 7f		                .word <>MN_RTS, <>MN_ADC, <>MN_PER, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 6x
>3a815a	08 80 2c 7f 4c 7f 2c 7f
>3a8162	94 7f 2c 7f 4c 7f 2c 80		                .word <>MN_PLA, <>MN_ADC, <>MN_ROR, <>MN_RTL, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>3a816a	64 7f 2c 7f 4c 7f 2c 7f
>3a8172	ec 7f 2c 7f 2c 7f 2c 7f		                .word <>MN_BVS, <>MN_ADC, <>MN_ADC, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 7x
>3a817a	08 80 2c 7f 4c 7f 2c 7f
>3a8182	b4 7f 2c 7f 14 80 4c 80		                .word <>MN_SEI, <>MN_ADC, <>MN_PLY, <>MN_TDC, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>3a818a	64 7f 2c 7f 4c 7f 2c 7f
>3a8192	0c 80 30 7f 70 80 30 7f		                .word <>MN_BRA, <>MN_STA, <>MN_BRL, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 8x
>3a819a	68 7f 30 7f 50 7f 30 7f
>3a81a2	98 7f 60 7f c8 7f 30 80		                .word <>MN_DEY, <>MN_BIT, <>MN_TXA, <>MN_PHB, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA
>3a81aa	68 7f 30 7f 50 7f 30 7f
>3a81b2	f0 7f 30 7f 30 7f 30 7f		                .word <>MN_BCC, <>MN_STA, <>MN_STA, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 9x
>3a81ba	68 7f 30 7f 50 7f 30 7f
>3a81c2	b8 7f 30 7f cc 7f 50 80		                .word <>MN_TYA, <>MN_STA, <>MN_TXS, <>MN_TXY, <>MN_STZ, <>MN_STA, <>MN_STZ, <>MN_STA
>3a81ca	08 80 30 7f 08 80 30 7f
>3a81d2	6c 7f 34 7f 54 7f 34 7f		                .word <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Ax
>3a81da	6c 7f 34 7f 54 7f 34 7f
>3a81e2	9c 7f 34 7f d0 7f 34 80		                .word <>MN_TAY, <>MN_LDA, <>MN_TAX, <>MN_PLB, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>3a81ea	6c 7f 34 7f 54 7f 34 7f
>3a81f2	f4 7f 34 7f 34 7f 34 7f		                .word <>MN_BCS, <>MN_LDA, <>MN_LDA, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Bx
>3a81fa	6c 7f 34 7f 54 7f 34 7f
>3a8202	bc 7f 34 7f d4 7f 54 80		                .word <>MN_CLV, <>MN_LDA, <>MN_TSX, <>MN_TYX, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>3a820a	6c 7f 34 7f 54 7f 34 7f
>3a8212	70 7f 38 7f 74 80 38 7f		                .word <>MN_CPY, <>MN_CMP, <>MN_REP, <>MN_CMP, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Cx
>3a821a	70 7f 38 7f 58 7f 38 7f
>3a8222	a0 7f 38 7f d8 7f 38 80		                .word <>MN_INY, <>MN_CMP, <>MN_DEX, <>MN_WAI, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP
>3a822a	70 7f 38 7f 58 7f 38 7f
>3a8232	f8 7f 38 7f 38 7f 38 7f		                .word <>MN_BNE, <>MN_CMP, <>MN_CMP, <>MN_CMP, <>MN_PEI, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Dx
>3a823a	84 80 38 7f 58 7f 38 7f
>3a8242	c0 7f 38 7f 18 80 58 80		                .word <>MN_CLD, <>MN_CMP, <>MN_PHX, <>MN_STP, <>MN_JML, <>MN_CMP, <>MN_DEC, <>MN_CMP
>3a824a	8c 80 38 7f 58 7f 38 7f
>3a8252	74 7f 3c 7f 78 80 3c 7f		                .word <>MN_CPX, <>MN_SBC, <>MN_SEP, <>MN_SBC, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Ex
>3a825a	74 7f 3c 7f 5c 7f 3c 7f
>3a8262	a4 7f 3c 7f dc 7f 3c 80		                .word <>MN_INX, <>MN_SBC, <>MN_NOP, <>MN_XBA, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC
>3a826a	74 7f 3c 7f 5c 7f 3c 7f
>3a8272	fc 7f 3c 7f 3c 7f 3c 7f		                .word <>MN_BEQ, <>MN_SBC, <>MN_SBC, <>MN_SBC, <>MN_PEA, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Fx
>3a827a	88 80 3c 7f 5c 7f 3c 7f
>3a8282	c4 7f 3c 7f 1c 80 5c 80		                .word <>MN_SED, <>MN_SBC, <>MN_PLX, <>MN_XCE, <>MN_JSR, <>MN_SBC, <>MN_INC, <>MN_SBC
>3a828a	7c 7f 3c 7f 5c 7f 3c 7f
>3a8292	00 00				                .word 0
>3a8294	13 00 02 09			ADDRESS_TAB     .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R                  ; 0x
>3a8298	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a829c	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>3a82a0	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a82a4	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 1x
>3a82a8	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a82ac	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>3a82b0	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a82b4	03 00 0b 09			                .byte ADDR_ABS, ADDR_DP_IND_X, ADDR_ABS_LONG, ADDR_SP_R                 ; 2x
>3a82b8	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a82bc	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>3a82c0	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a82c4	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 3x
>3a82c8	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a82cc	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>3a82d0	07 07 07 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a82d4	13 00 13 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMPLIED, ADDR_SP_R              ; 4x
>3a82d8	14 01 01 0a			                .byte ADDR_XYC, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a82dc	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>3a82e0	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a82e4	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 5x
>3a82e8	14 05 05 0d			                .byte ADDR_XYC, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a82ec	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a82f0	0b 07 07 0b			                .byte ADDR_ABS_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_LONG
>3a82f4	13 00 16 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R          ; 6x
>3a82f8	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a82fc	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>3a8300	15 03 03 0b			                .byte ADDR_ABS_IND, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a8304	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 7x
>3a8308	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a830c	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a8310	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a8314	12 00 16 09			                .byte ADDR_PC_REL, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R           ; 8x
>3a8318	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a831c	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>3a8320	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a8324	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 9x
>3a8328	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>3a832c	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a8330	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a8334	82 00 42 09			                .byte ADDR_IMM | OP_M_EFFECT, ADDR_DP_IND_X, ADDR_IMM | OP_X_EFFECT, ADDR_SP_R  ; Ax
>3a8338	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a833c	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>3a8340	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a8344	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Bx
>3a8348	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>3a834c	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a8350	07 07 06 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_Y, ADDR_ABS_X_LONG
>3a8354	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Cx
>3a8358	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a835c	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>3a8360	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a8364	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Dx
>3a8368	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a836c	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a8370	17 07 07 0e			                .byte ADDR_ABS_IND_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a8374	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Ex
>3a8378	01 01 01 0f			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_IND
>3a837c	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>3a8380	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a8384	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Fx
>3a8388	03 05 05 0d			                .byte ADDR_ABS, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a838c	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a8390	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a8394	01 01 01 02 01 01 02 02		ADDR_LENGTH     .byte 1, 1, 1, 2, 1, 1, 2, 2, 0, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 0, 2, 2, 2, 2
>3a839c	00 01 01 03 01 01 03 01 02 01 01 00 02 02 02 02
.3a83ac					ADDR_PATTERNS
>3a83ac	41 00				            .null "A"
>3a83ae	08				            .byte ADDR_ACC
>3a83af	64 64 3a 64 64 64 64 2c		            .null "dd:dddd,X"
>3a83b7	58 00
>3a83b9	0e				            .byte ADDR_ABS_X_LONG
>3a83ba	64 64 3a 64 64 64 64 00		            .null "dd:dddd"
>3a83c2	0b				            .byte ADDR_ABS_LONG
>3a83c3	64 64 64 64 2c 58 00		            .null "dddd,X"
>3a83ca	07				            .byte ADDR_ABS_X
>3a83cb	64 64 64 64 2c 59 00		            .null "dddd,Y"
>3a83d2	06				            .byte ADDR_ABS_Y
>3a83d3	64 64 64 64 00			            .null "dddd"
>3a83d8	03				            .byte ADDR_ABS
>3a83d9	64 64 2c 58 00			            .null "dd,X"
>3a83de	05				            .byte ADDR_DP_X
>3a83df	64 64 2c 59 00			            .null "dd,Y"
>3a83e4	11				            .byte ADDR_DP_Y
>3a83e5	64 64 2c 53 00			            .null "dd,S"
>3a83ea	09				            .byte ADDR_SP_R
>3a83eb	64 64 00			            .null "dd"
>3a83ee	01				            .byte ADDR_DP
>3a83ef	23 64 64 64 64 00		            .null "#dddd"
>3a83f5	c2				            .byte ADDR_IMM | OP_M_EFFECT | OP_X_EFFECT
>3a83f6	23 64 64 2c 23 64 64 00		            .null "#dd,#dd"
>3a83fe	14				            .byte ADDR_XYC
>3a83ff	23 64 64 00			            .null "#dd"
>3a8403	02				            .byte ADDR_IMM
>3a8404	28 64 64 2c 53 29 2c 59		            .null "(dd,S),Y"
>3a840c	00
>3a840d	0c				            .byte ADDR_SP_R_Y
>3a840e	28 64 64 64 64 2c 58 29		            .null "(dddd,X)"
>3a8416	00
>3a8417	10				            .byte ADDR_ABS_X_ID
>3a8418	28 64 64 64 64 29 00		            .null "(dddd)"
>3a841f	10				            .byte ADDR_ABS_X_ID
>3a8420	28 64 64 2c 58 29 00		            .null "(dd,X)"
>3a8427	00				            .byte ADDR_DP_IND_X
>3a8428	28 64 64 29 2c 59 00		            .null "(dd),Y"
>3a842f	04				            .byte ADDR_DP_IND_Y
>3a8430	28 64 64 29 00			            .null "(dd)"
>3a8435	0f				            .byte ADDR_DP_IND
>3a8436	5b 64 64 64 64 5d 00		            .null "[dddd]"
>3a843d	17				            .byte ADDR_ABS_IND_LONG
>3a843e	5b 64 64 5d 2c 59 00		            .null "[dd],Y"
>3a8445	0d				            .byte ADDR_DP_Y_LONG
>3a8446	5b 64 64 5d 00			            .null "[dd]"
>3a844b	0a				            .byte ADDR_DP_LONG
>3a844c	00 00				                .byte 0, 0

;******  Return to file: src\monitor.s

.3a844e					M_INC_CURSOR
.3a844e	08		php		                PHP
.3a844f	c2 20		rep #$20	            REP #$20
.3a8451	48		pha		                PHA
.3a8452	18		clc		                CLC
.3a8453	af 7a 08 00	lda $00087a	                LDA MCURSOR
.3a8457	69 01 00	adc #$0001	                ADC #1
.3a845a	8f 7a 08 00	sta $00087a	                STA MCURSOR
.3a845e	e2 20		sep #$20	            SEP #$20
.3a8460	af 7c 08 00	lda $00087c	                LDA MCURSOR+2
.3a8464	69 00		adc #$00	                ADC #0
.3a8466	8f 7c 08 00	sta $00087c	                STA MCURSOR+2
.3a846a	c2 20		rep #$20	            REP #$20
.3a846c	68		pla		                PLA
.3a846d	28		plp		                PLP
.3a846e	6b		rtl		                RTL
.3a846f					MPRINTB
.3a846f	08		php		                PHP
.3a8470	c2 10		rep #$10	            REP #$10
.3a8472	e2 20		sep #$20	            SEP #$20
.3a8474	da		phx		                PHX
.3a8475	a2 08 00	ldx #$0008	                LDX #8          ; Set number of bits to print to 8
.3a8478	0a		asl a		loop            ASL A           ; Shift MSB to C
.3a8479	b0 08		bcs $3a8483	                BCS is_one
.3a847b	48		pha		                PHA             ; Save value to print
.3a847c	a9 30		lda #$30	                LDA #'0'        ; Print '0'
.3a847e	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8481	80 06		bra $3a8489	                BRA continue
.3a8483	48		pha		is_one          PHA             ; Save value to print
.3a8484	a9 31		lda #$31	                LDA #'1'        ; Print '1'
.3a8486	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8489	68		pla		continue        PLA
.3a848a	ca		dex		                DEX             ; Count down the bits to shift
.3a848b	d0 eb		bne $3a8478	                BNE loop        ; And try the next one if there is one
.3a848d	fa		plx		                PLX             ; Otherwise, return
.3a848e	28		plp		                PLP
.3a848f	6b		rtl		                RTL
.3a8490					MSKIPWS
.3a8490	08		php		            PHP
.3a8491	c2 20		rep #$20	            REP #$20
.3a8493	48		pha		            PHA
.3a8494	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a8497	5b		tcd		            TCD
.3a8498	68		pla		            PLA
.3a8499	28		plp		            PLP
.3a849a	e2 20		sep #$20	            SEP #$20
.3a849c	a7 32		lda [$087a]	loop            LDA [MCURSOR]       ; Check the current character
.3a849e	f0 0a		beq $3a84aa	                BEQ done            ; If NULL, we're done
.3a84a0	c9 20		cmp #$20	                CMP #' '            ; Is it a space?
.3a84a2	d0 06		bne $3a84aa	                BNE done            ; No: we're done
.3a84a4	22 4e 84 3a	jsl $3a844e	                JSL M_INC_CURSOR    ; Yes, try the next one
.3a84a8	80 f2		bra $3a849c	                BRA loop
.3a84aa	6b		rtl		done            RTL
.3a84ab					MPARSESTR
.3a84ab	08		php		                PHP
.3a84ac	08		php		            PHP
.3a84ad	c2 20		rep #$20	            REP #$20
.3a84af	48		pha		            PHA
.3a84b0	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a84b3	5b		tcd		            TCD
.3a84b4	68		pla		            PLA
.3a84b5	28		plp		            PLP
.3a84b6	22 4e 84 3a	jsl $3a844e	                JSL M_INC_CURSOR                ; Point to the first character of the name
.3a84ba	22 90 84 3a	jsl $3a8490	                JSL MSKIPWS                     ; Skip white space
.3a84be	c2 30		rep #$30	            REP #$30
.3a84c0	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.3a84c2	c2 20		rep #$20	            REP #$20
.3a84c4	29 ff 00	and #$00ff	                AND #$00FF
.3a84c7	0a		asl a		                ASL A                           ; multiply it by forfour
.3a84c8	0a		asl a		                ASL A
.3a84c9	aa		tax		                TAX                             ; ... to get the index to the argument
.3a84ca	a5 32		lda $087a	                LDA MCURSOR                     ; Set the argument to the address of the first byte
.3a84cc	95 0d		sta $0855,x	                STA MARG1,X
.3a84ce	a5 34		lda $087c	                LDA MCURSOR+2
.3a84d0	95 0f		sta $0857,x	                STA MARG1+2,X
.3a84d2	e2 20		sep #$20	            SEP #$20
.3a84d4	a7 32		lda [$087a]	loop            LDA [MCURSOR]                   ; Scan to the closing double quote
.3a84d6	f0 14		beq $3a84ec	                BEQ done                        ; If NULL... treat it as a closed argument
.3a84d8	c9 22		cmp #$22	                CMP #CHAR_DQUOTE
.3a84da	f0 06		beq $3a84e2	                BEQ close_string
.3a84dc	22 4e 84 3a	jsl $3a844e	                JSL M_INC_CURSOR
.3a84e0	80 f2		bra $3a84d4	                BRA loop
.3a84e2	a9 00		lda #$00	close_string    LDA #0                          ; Write a NULL to close the string
.3a84e4	87 32		sta [$087a]	                STA [MCURSOR]
.3a84e6	22 4e 84 3a	jsl $3a844e	                JSL M_INC_CURSOR                ; And point to the next byte
.3a84ea	e6 31		inc $0879	                INC MARG_LEN
.3a84ec	28		plp		done            PLP
.3a84ed	6b		rtl		                RTL
.3a84ee					MPARSEARG
.3a84ee	08		php		            PHP
.3a84ef	c2 20		rep #$20	            REP #$20
.3a84f1	48		pha		            PHA
.3a84f2	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a84f5	5b		tcd		            TCD
.3a84f6	68		pla		            PLA
.3a84f7	28		plp		            PLP
.3a84f8	e2 20		sep #$20	            SEP #$20
.3a84fa	64 4a		stz $0892	                STZ MTEMP                       ; Use MTEMP as a flag for having processed digits
.3a84fc	c2 20		rep #$20	            REP #$20
.3a84fe	64 50		stz $0898	                STZ MPARSEDNUM                  ; Clear the parsed number
.3a8500	64 52		stz $089a	                STZ MPARSEDNUM+2
.3a8502					pa_loop
.3a8502	e2 20		sep #$20	            SEP #$20
.3a8504	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Get the current character
.3a8506	c9 3a		cmp #$3a	                CMP #":"
.3a8508	f0 0d		beq $3a8517	                BEQ pa_next_char                ; Ignore any colons
.3a850a	20 be 03	jsr $3a03be	            JSR ISHEX
.3a850d	90 0e		bcc $3a851d	                BCC finished_arg                ; No? We're done with this argument
.3a850f	22 86 79 3a	jsl $3a7986	                JSL AS_SHIFT_HEX                ; Yes: shift it onto MPARSEDNUM
.3a8513	a9 01		lda #$01	                LDA #1                          ; Flag that we've processed a character
.3a8515	85 4a		sta $0892	                STA MTEMP
.3a8517	22 4e 84 3a	jsl $3a844e	pa_next_char    JSL M_INC_CURSOR                ; And try the next character
.3a851b	80 e5		bra $3a8502	                BRA pa_loop
.3a851d	a5 4a		lda $0892	finished_arg    LDA MTEMP                       ; Check to see if we've processed any characters
.3a851f	f0 16		beq $3a8537	                BEQ done                        ; No: we're done
.3a8521	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.3a8523	c2 20		rep #$20	            REP #$20
.3a8525	29 ff 00	and #$00ff	                AND #$00FF
.3a8528	0a		asl a		                ASL A                           ; multiply it by forfour
.3a8529	0a		asl a		                ASL A
.3a852a	aa		tax		                TAX                             ; ... to get the index to the argument
.3a852b	a5 50		lda $0898	                LDA MPARSEDNUM                  ; Copy the value to the argument slot
.3a852d	95 0d		sta $0855,x	                STA MARG1,X
.3a852f	a5 52		lda $089a	                LDA MPARSEDNUM+2
.3a8531	95 0f		sta $0857,x	                STA MARG1+2,X
.3a8533	e2 20		sep #$20	            SEP #$20
.3a8535	e6 31		inc $0879	                INC MARG_LEN                    ; And bump up the argument count
.3a8537	6b		rtl		done            RTL
.3a8538					MPARSEALLARG
.3a8538	e2 20		sep #$20	            SEP #$20
.3a853a	64 31		stz $0879	                STZ MARG_LEN                    ; Set the arg count to 0
.3a853c	22 90 84 3a	jsl $3a8490	parse_arg       JSL MSKIPWS                     ; Otherwise, skip white space
.3a8540	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Check the current character
.3a8542	f0 21		beq $3a8565	                BEQ done                        ; If it is NULL, we're done
.3a8544	c9 22		cmp #$22	                CMP #CHAR_DQUOTE                ; Is it a double-quote?
.3a8546	d0 06		bne $3a854e	                BNE regular_arg
.3a8548	22 ab 84 3a	jsl $3a84ab	                JSL MPARSESTR                   ; Yes: parse it as a string argument
.3a854c	80 0a		bra $3a8558	                BRA check_rest
.3a854e	22 ee 84 3a	jsl $3a84ee	regular_arg     JSL MPARSEARG                   ; Attempt to parse the argument
.3a8552	a5 31		lda $0879	                LDA MARG_LEN                    ; Check how many arguments we've processed
.3a8554	c9 09		cmp #$09	                CMP #9
.3a8556	b0 0d		bcs $3a8565	                BGE done                        ; If >=9, then we're done
.3a8558	a7 32		lda [$087a]	check_rest      LDA [MCURSOR]                   ; Check the current character
.3a855a	f0 09		beq $3a8565	                BEQ done                        ; If EOL: we're done
.3a855c	c9 20		cmp #$20	                CMP #' '
.3a855e	f0 dc		beq $3a853c	                BEQ parse_arg                   ; If space: try to process another argument
.3a8560	20 be 03	jsr $3a03be	            JSR ISHEX
.3a8563	b0 d7		bcs $3a853c	                BCS parse_arg                   ; If hex digit: try to process another argument
.3a8565	6b		rtl		done            RTL
.3a8566					IMPARSE
.3a8566	08		php		                PHP
.3a8567	0b		phd		                PHD
.3a8568	08		php		            PHP
.3a8569	c2 20		rep #$20	            REP #$20
.3a856b	48		pha		            PHA
.3a856c	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a856f	5b		tcd		            TCD
.3a8570	68		pla		            PLA
.3a8571	28		plp		            PLP
.3a8572	c2 10		rep #$10	            REP #$10
.3a8574	e2 20		sep #$20	            SEP #$20
.3a8576	a2 31 00	ldx #$0031	                LDX #MARG_LEN - MONITOR_VARS    ; Clear the monitor command line parameters
.3a8579	74 00		stz $0848,x	clear_command   STZ MONITOR_VARS,X
.3a857b	ca		dex		                DEX
.3a857c	d0 fb		bne $3a8579	                BNE clear_command
.3a857e	a9 00		lda #$00	                LDA #`INPUTBUF                  ; Point the command parser to the input buffer
.3a8580	85 02		sta $084a	                STA MCMDADDR+2
.3a8582	85 34		sta $087c	                STA MCURSOR+2                   ; And point MCURSOR there too
.3a8584	c2 20		rep #$20	            REP #$20
.3a8586	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF
.3a8589	85 00		sta $0848	                STA MCMDADDR
.3a858b	85 32		sta $087a	                STA MCURSOR
.3a858d	e2 20		sep #$20	            SEP #$20
.3a858f	22 90 84 3a	jsl $3a8490	                JSL MSKIPWS                     ; Skip to the first letter of the command
.3a8593	c9 00		cmp #$00	                CMP #0                          ; Is the current character a NULL?
.3a8595	f0 38		beq $3a85cf	                BEQ done                        ; Yes: there's no command here
.3a8597	c2 20		rep #$20	            REP #$20
.3a8599	a5 32		lda $087a	                LDA MCURSOR
.3a859b	85 08		sta $0850	                STA MCMD
.3a859d	e2 20		sep #$20	            SEP #$20
.3a859f	a5 34		lda $087c	                LDA MCURSOR+2
.3a85a1	85 0a		sta $0852	                STA MCMD+2
.3a85a3	a2 01 00	ldx #$0001	                LDX #1
.3a85a6	22 4e 84 3a	jsl $3a844e	cmd_loop        JSL M_INC_CURSOR                ; Move to the next character
.3a85aa	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; What is that character?
.3a85ac	d0 06		bne $3a85b4	                BNE cmd_space                   ; If not NULL: check for a space
.3a85ae	86 0b		stx $0853	no_arguments    STX MCMD_LEN                    ; If NULL: Save the length of the command
.3a85b0	64 31		stz $0879	                STZ MARG_LEN                    ; ... And the fact there are no arguments
.3a85b2	80 1b		bra $3a85cf	                BRA done                        ; ... And return
.3a85b4	c9 20		cmp #$20	cmd_space       CMP #' '                        ; Is it a space?
.3a85b6	f0 03		beq $3a85bb	                BEQ found_cmd                   ; Yes: save the length
.3a85b8	e8		inx		                INX                             ; No: go to the next character
.3a85b9	80 eb		bra $3a85a6	                BRA cmd_loop
.3a85bb	86 0b		stx $0853	found_cmd       STX MCMD_LEN                    ; Save the length of the command
.3a85bd	a9 00		lda #$00	                LDA #0
.3a85bf	87 32		sta [$087a]	                STA [MCURSOR]                   ; Write a NULL to the end of the command
.3a85c1	22 4e 84 3a	jsl $3a844e	                JSL M_INC_CURSOR                ; And skip to the next character
.3a85c5	a7 08		lda [$0850]	                LDA [MCMD]                      ; Check the command
.3a85c7	c9 41		cmp #$41	                CMP #'A'
.3a85c9	f0 07		beq $3a85d2	                BEQ parse_asm                   ; If 'A', parse the line for the assemble command
.3a85cb	22 38 85 3a	jsl $3a8538	                JSL MPARSEALLARG
.3a85cf	2b		pld		done            PLD
.3a85d0	28		plp		                PLP
.3a85d1	6b		rtl		                RTL
.3a85d2	22 90 84 3a	jsl $3a8490	parse_asm       JSL MSKIPWS                     ; Skip to the first letter of the address
.3a85d6	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a85d8	f0 f5		beq $3a85cf	                BEQ done                        ; Exit if we got the end-of-line
.3a85da	22 ee 84 3a	jsl $3a84ee	                JSL MPARSEARG                   ; Parse the first argument as the target address
.3a85de	22 90 84 3a	jsl $3a8490	                JSL MSKIPWS                     ; Skip to the first letter of the mnemonic
.3a85e2	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a85e4	f0 e9		beq $3a85cf	                BEQ done                        ; Exit if we got the end-of-line
.3a85e6	c2 20		rep #$20	            REP #$20
.3a85e8	a5 32		lda $087a	                LDA MCURSOR                     ; Save pointer to the start of the mnemonic
.3a85ea	85 11		sta $0859	                STA MARG2
.3a85ec	e2 20		sep #$20	            SEP #$20
.3a85ee	a5 34		lda $087c	                LDA MCURSOR+2
.3a85f0	85 13		sta $085b	                STA MARG2+2
.3a85f2	22 4e 84 3a	jsl $3a844e	asm_find_sp     JSL M_INC_CURSOR                ; Find the space at the end of the mnemonic
.3a85f6	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a85f8	f0 26		beq $3a8620	                BEQ asm_no_operand              ; If EOL: we have an instruction but no operand
.3a85fa	c9 20		cmp #$20	                CMP #' '
.3a85fc	d0 f4		bne $3a85f2	                BNE asm_find_sp
.3a85fe	a9 00		lda #$00	                LDA #0
.3a8600	87 32		sta [$087a]	                STA [MCURSOR]                   ; Null terminate the mnemonic
.3a8602	e6 31		inc $0879	                INC MARG_LEN                    ; Count the mnemonic as an argument
.3a8604	22 4e 84 3a	jsl $3a844e	                JSL M_INC_CURSOR
.3a8608	22 90 84 3a	jsl $3a8490	                JSL MSKIPWS                     ; Skip to the addressing mode
.3a860c	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a860e	f0 bf		beq $3a85cf	                BEQ done                        ; If EOL: we're done
.3a8610	c2 20		rep #$20	            REP #$20
.3a8612	a5 32		lda $087a	                LDA MCURSOR                     ; Set the pointer to the addressing mode
.3a8614	85 15		sta $085d	                STA MARG3
.3a8616	e2 20		sep #$20	            SEP #$20
.3a8618	a5 34		lda $087c	                LDA MCURSOR+2
.3a861a	85 17		sta $085f	                STA MARG3+2
.3a861c	e6 31		inc $0879	                INC MARG_LEN                    ; And count it as the second argument
.3a861e	80 af		bra $3a85cf	                BRA done                        ; and return
.3a8620	e6 31		inc $0879	asm_no_operand  INC MARG_LEN                    ; Increment the argument count
.3a8622	80 ab		bra $3a85cf	                BRA done                        ; And quit
.3a8624					IMLOAD
.3a8624	08		php		                PHP
.3a8625	c2 10		rep #$10	            REP #$10
.3a8627	e2 20		sep #$20	            SEP #$20
.3a8629	a5 31		lda $0879	                LDA MARG_LEN
.3a862b	d0 0f		bne $3a863c	                BNE get_arguments
.3a862d	a2 1a 87	ldx #$871a	bad_arguments   LDX #<>MERRARGS                 ; Print bad arguments error
.3a8630	a9 3a		lda #$3a	                LDA #`MERRARGS
.3a8632	48		pha		                PHA
.3a8633	ab		plb		                PLB
.3a8634	20 16 03	jsr $3a0316	            JSR PRINTS
.3a8637	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a863a	80 61		bra $3a869d	                BRA done
.3a863c					get_arguments
.3a863c	c2 20		rep #$20	            REP #$20
.3a863e	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.3a8640	8f 23 08 00	sta $000823	                STA ARGUMENT1
.3a8644	a5 0f		lda $0857	                LDA MARG1+2
.3a8646	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.3a864a	20 0a 68	jsr $3a680a	            JSR SETFILEDESC
.3a864d	e2 20		sep #$20	            SEP #$20
.3a864f	a5 31		lda $0879	                LDA MARG_LEN
.3a8651	c9 01		cmp #$01	                CMP #1
.3a8653	d0 0f		bne $3a8664	                BNE get_dest
.3a8655	c2 20		rep #$20	            REP #$20
.3a8657	a9 ff ff	lda #$ffff	                LDA #$FFFF                      ; Destination address not provided...
.3a865a	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR              ; ... set it to something sane
.3a865e	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a8662	80 0e		bra $3a8672	                BRA try_load
.3a8664					get_dest
.3a8664	c2 20		rep #$20	            REP #$20
.3a8666	a5 11		lda $0859	                LDA MARG2                       ; Set the destination address from the arguments
.3a8668	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a866c	a5 13		lda $085b	                LDA MARG2+2
.3a866e	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a8672	22 18 11 00	jsl $001118	try_load        JSL FK_LOAD                     ; Try to load the file
.3a8676	b0 25		bcs $3a869d	                BCS done
.3a8678					error
.3a8678	e2 20		sep #$20	            SEP #$20
.3a867a	a2 40 87	ldx #$8740	                LDX #<>MCANTLOAD                ; Print bad arguments error
.3a867d	a9 3a		lda #$3a	                LDA #`MCANTLOAD
.3a867f	48		pha		                PHA
.3a8680	ab		plb		                PLB
.3a8681	20 16 03	jsr $3a0316	            JSR PRINTS
.3a8684	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.3a8688	20 40 03	jsr $3a0340	            JSR PRHEXB
.3a868b	a9 20		lda #$20	                LDA #' '
.3a868d	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8690	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.3a8694	20 40 03	jsr $3a0340	            JSR PRHEXB
.3a8697	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a869a	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a869d	28		plp		done            PLP
.3a869e	6b		rtl		                RTL
.3a869f					IMSAVE
.3a869f	8b		phb		                PHB
.3a86a0	08		php		                PHP
.3a86a1	c2 10		rep #$10	            REP #$10
.3a86a3	e2 20		sep #$20	            SEP #$20
.3a86a5	a5 31		lda $0879	                LDA MARG_LEN
.3a86a7	c9 03		cmp #$03	                CMP #3
.3a86a9	f0 0f		beq $3a86ba	                BEQ get_arguments
.3a86ab	a2 1a 87	ldx #$871a	                LDX #<>MERRARGS                 ; Print bad arguments error
.3a86ae	a9 3a		lda #$3a	                LDA #`MERRARGS
.3a86b0	48		pha		                PHA
.3a86b1	ab		plb		                PLB
.3a86b2	20 16 03	jsr $3a0316	            JSR PRINTS
.3a86b5	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a86b8	80 54		bra $3a870e	                BRA done
.3a86ba					get_arguments
.3a86ba	c2 20		rep #$20	            REP #$20
.3a86bc	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.3a86be	8f 23 08 00	sta $000823	                STA ARGUMENT1
.3a86c2	a5 0f		lda $0857	                LDA MARG1+2
.3a86c4	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.3a86c8	20 0a 68	jsr $3a680a	            JSR SETFILEDESC
.3a86cb	a5 11		lda $0859	                LDA MARG2                       ; Set the starting address
.3a86cd	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.3a86d1	a5 13		lda $085b	                LDA MARG2+2
.3a86d3	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.3a86d7	a5 15		lda $085d	                LDA MARG3                       ; Set the ending address
.3a86d9	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.3a86dd	a5 17		lda $085f	                LDA MARG3+2
.3a86df	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.3a86e3	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                     ; Save the data
.3a86e7	b0 25		bcs $3a870e	                BCS done
.3a86e9					error
.3a86e9	e2 20		sep #$20	            SEP #$20
.3a86eb	a2 2a 87	ldx #$872a	                LDX #<>MCANTSAVE                ; Print bad arguments error
.3a86ee	a9 3a		lda #$3a	                LDA #`MCANTSAVE
.3a86f0	48		pha		                PHA
.3a86f1	ab		plb		                PLB
.3a86f2	20 16 03	jsr $3a0316	            JSR PRINTS
.3a86f5	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.3a86f9	20 40 03	jsr $3a0340	            JSR PRHEXB
.3a86fc	a9 20		lda #$20	                LDA #' '
.3a86fe	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8701	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.3a8705	20 40 03	jsr $3a0340	            JSR PRHEXB
.3a8708	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a870b	20 89 02	jsr $3a0289	            JSR PRINTCR
.3a870e	28		plp		done            PLP
.3a870f	ab		plb		                PLB
.3a8710	6b		rtl		                RTL
.3a8711	5c fe 25 3a	jmp $3a25fe	IMEXIT          JML INTERACT
.3a8715	6b		rtl		IMRETURN        RTL ; Handle RETURN key (ie: execute command)
.3a8716	00		brk #		IMPARSE1        BRK ; Parse one word on the current command line
.3a8717	00		brk #		IMASSEMBLEA     BRK ; Assemble a line of text.
.3a8718	00		brk #		IMVERIFY        BRK ; Verify memory and file on disk
.3a8719	00		brk #		IMDOS           BRK ; Execute DOS command
.3a871a					MMESSAGES
>3a871a	42 61 64 20 61 72 67 75		MERRARGS        .null "Bad arguments",CHAR_CR,CHAR_CR
>3a8722	6d 65 6e 74 73 0d 0d 00
>3a872a	55 6e 61 62 6c 65 20 74		MCANTSAVE       .null "Unable to save file: "
>3a8732	6f 20 73 61 76 65 20 66 69 6c 65 3a 20 00
>3a8740	55 6e 61 62 6c 65 20 74		MCANTLOAD       .null "Unable to load file: "
>3a8748	6f 20 6c 6f 61 64 20 66 69 6c 65 3a 20 00
>3a8756	0d 20 20 50 43 20 20 20		mregisters_msg  .null $0D,"  PC     A    X    Y    SP   DBR DP   NVMXDIZC",CHAR_CR
>3a875e	20 20 41 20 20 20 20 58 20 20 20 20 59 20 20 20
>3a876e	20 53 50 20 20 20 44 42 52 20 44 50 20 20 20 4e
>3a877e	56 4d 58 44 49 5a 43 0d 00
>3a8787	41 43 44 46 47 4a 48 4c		MCOMMANDS       .null "ACDFGJHLMR;STVWX>?"
>3a878f	4d 52 3b 53 54 56 57 58 3e 3f 00

;******  Return to file: src\basic816.s

.3a879a	18		clc		START       CLC                 ; Go to native mode
.3a879b	fb		xce		            XCE
.3a879c	08		php		            PHP
.3a879d	c2 20		rep #$20	            REP #$20
.3a879f	48		pha		            PHA
.3a87a0	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a87a3	5b		tcd		            TCD
.3a87a4	68		pla		            PLA
.3a87a5	28		plp		            PLP
.3a87a6	08		php		            PHP
.3a87a7	e2 20		sep #$20	            SEP #$20
.3a87a9	48		pha		            PHA
.3a87aa	a9 00		lda #$00	            LDA #BASIC_BANK
.3a87ac	48		pha		            PHA
.3a87ad	ab		plb		            PLB
.3a87ae	68		pla		            PLA
.3a87af	28		plp		            PLP
.3a87b0	c2 30		rep #$30	            REP #$30
.3a87b2	20 d9 87	jsr $3a87d9	            JSR INITBASIC
.3a87b5	a9 ff fe	lda #$feff	            LDA #STACK_END      ; Set the system stack
.3a87b8	1b		tcs		            TCS
.3a87b9	08		php		            PHP
.3a87ba	e2 20		sep #$20	            SEP #$20
.3a87bc	48		pha		            PHA
.3a87bd	a9 3a		lda #$3a	            LDA #`GREET
.3a87bf	48		pha		            PHA
.3a87c0	ab		plb		            PLB
.3a87c1	68		pla		            PLA
.3a87c2	28		plp		            PLP
.3a87c3	a2 71 d2	ldx #$d271	            LDX #<>GREET
.3a87c6	20 16 03	jsr $3a0316	            JSR PRINTS
.3a87c9	08		php		            PHP
.3a87ca	e2 20		sep #$20	            SEP #$20
.3a87cc	48		pha		            PHA
.3a87cd	a9 00		lda #$00	            LDA #BASIC_BANK
.3a87cf	48		pha		            PHA
.3a87d0	ab		plb		            PLB
.3a87d1	68		pla		            PLA
.3a87d2	28		plp		            PLP
.3a87d3	4c fe 25	jmp $3a25fe	            JMP INTERACT        ; Start accepting input from the user
.3a87d6	4c d6 87	jmp $3a87d6	WAIT        JMP WAIT
.3a87d9					INITBASIC
.3a87d9	08		php		            PHP
.3a87da	20 d0 01	jsr $3a01d0	            JSR INITIO
.3a87dd	20 9c 4d	jsr $3a4d9c	            JSR CMD_NEW
.3a87e0	28		plp		            PLP
.3a87e1	60		rts		            RTS
>3ad271	43 32 35 36 20 46 6f 65		GREET       .text "C256 Foenix BASIC816 "
>3ad279	6e 69 78 20 42 41 53 49 43 38 31 36 20

;******  Processing file: src\version.s

>3ad286	76 30 2e 32 2e 30 2d 61		.text "v0.2.0-alpha+252"
>3ad28e	6c 70 68 61 2b 32 35 32

;******  Return to file: src\basic816.s

>3ad296	0d 00				            .byte 13,0

;******  End of listing
