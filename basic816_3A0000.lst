
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -D SYSTEM=2 -D C256_SKU=1 -D UARTSUPPORT= -D UNITTEST=0 -D TRACE_LEVEL=0 --long-address --flat -b --m65816 --intel-hex -o basic816_3A0000.hex --list=basic816_3A0000.lst --labels=basic816_3A0000.lbl src\basic816.s
; Thu May 13 16:41:06 2021

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=2					SYSTEM=2
=1					C256_SKU=1
=					UARTSUPPORT=
=0					UNITTEST=0
=0					TRACE_LEVEL=0

;******  Processing input file: src\basic816.s


;******  Processing file: src\constants.s

=2					SYSTEM_C256 = 2         ; C256 Foenix
=1					SYSTEM_C64 = 1          ; Commodore 64 with SuperCPU
=$03					CHAR_CTRL_C = $03       ; CTRL-C: used as a program interrupt key
=$07					CHAR_BELL = $07         ; Ring the console bell
=$08					CHAR_BS = $08           ; Backspace
=$09					CHAR_TAB = $09          ; TAB
=$0a					CHAR_LF = $0A           ; Linefeed
=$0d					CHAR_CR = $0D           ; Carriage Return
=$0f					CHAR_INS = $0F          ; Insert
=$1b					CHAR_ESC = $1B          ; Escape
=$22					CHAR_DQUOTE = $22       ; Double quote
=$20					CHAR_SP = $20           ; Space
=$7f					CHAR_DEL = $7F          ; Delete
=5					ARGUMENT_SIZE = 5       ; Number of bytes in an argument
=8					VAR_NAME_SIZE = 8       ; Maximum number of characters in a variable name
=0					TYPE_INTEGER = 0        ; 32-bit integer
=1					TYPE_FLOAT = 1          ; Single-precision floating point
=2					TYPE_STRING = 2         ; ASCII string
=$80					TYPE_ARR_INTEGER = $80  ; Array of 32-bit integers
=$81					TYPE_ARR_FLOAT = $81    ; Array of 32-bit floats
=$82					TYPE_ARR_STRING = $82   ; Array of strings
=$7f					TYPE_BINDING = $7F      ; A variable name binding
=$ff					TYPE_NAV = $FF          ; Not-A-Value
=0					ERR_OK = 0              ; No error
=1					ERR_BREAK = 1           ; The user pressed an interrupt key
=2					ERR_SYNTAX = 2          ; A syntax error was found on the current line
=3					ERR_MEMORY = 3          ; Out of memory
=4					ERR_TYPE = 4            ; Type mismatch error
=5					ERR_NOTFOUND = 5        ; Variable not found error
=6					ERR_NOLINE = 6          ; Line number not found
=7					ERR_STACKUNDER = 7      ; Stack underflow error
=8					ERR_STACKOVER = 8       ; Stack overflow error
=9					ERR_RANGE = 9           ; Out-of-range error
=10					ERR_ARGUMENT = 10       ; Bad argument error
=11					ERR_NOFILE = 11         ; File not found error
=12					ERR_NAN = 12            ; Floating point math resulted in something that is not a number
=13					ERR_OVERFLOW = 13       ; Math operation overflowed
=14					ERR_UNDERFLOW = 14      ; Math operation underflowed
=15					ERR_DIV0 = 15           ; Math operation involved a division by zero
=16					ERR_DIRECTORY = 16      ; Error reading the directory
=17					ERR_LOAD = 17           ; Could not load file
=18					ERR_SAVE = 18           ; Could not save a file
=19					ERR_DELETE = 19         ; Could not delete a file
=20					ERR_FILENOTFOUND = 20   ; Could not find the file
=21					ERR_DIRNOTWRITE = 21    ; Could not update the directory entry
=22					ERR_NOTCOPIED = 22      ; Could not copy the file
=23					ERR_DOMAIN = 23         ; Mathematical functions domain error

;******  Return to file: src\basic816.s


;******  Processing file: src\memorymap.s


;******  Processing file: src\C256/mmap_c256.s

=1					SYS_C256_FMX = 1        ; System SKU for C256 Foenix FMX
=2					SYS_C256_USER = 2       ; System SKU for C256 Foenix User

;******  Processing file: src\C256/page_00_inc.s

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				unused_0000      = $000000 ;12 Bytes unused
=$000008				OPL2_ADDY_PTR_LO = $000008  ; THis Points towards the Instruments Database
=$000009				OPL2_ADDY_PTR_MD = $000009
=$00000a				OPL2_ADDY_PTR_HI = $00000A
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;1 Byte Color of next character to be printed to the screen.
=$00001f				COLORPOS         = $00001F ;3 Byte address of cursor's position in the color matrix
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$000026				OPL2_OPERATOR    = $000026 ;
=$000027				OPL2_CHANNEL     = $000027 ;
=$000028				OPL2_REG_REGION  = $000028 ; Offset to the Group of Registers
=$00002a				OPL2_REG_OFFSET  = $00002A ; 2 Bytes (16Bits)
=$00002c				OPL2_IND_ADDY_LL = $00002C ; 2 Bytes Reserved (Only need 3)
=$00002e				OPL2_IND_ADDY_HL = $00002E ; 2 Bytes Reserved (Only need 3)
=$000030				OPL2_NOTE        = $000030 ; 1 Byte
=$000031				OPL2_OCTAVE      = $000031 ; 1 Byte
=$000032				OPL2_PARAMETER0  = $000032 ; 1 Byte - Key On/Feedback
=$000033				OPL2_PARAMETER1  = $000033 ; 1 Byte
=$000034				OPL2_PARAMETER2  = $000034 ; 1 Byte
=$000035				OPL2_PARAMETER3  = $000035 ; 1 Byte
=$000036				OPL2_LOOP        = $000036 ;
=$000036				OPL2_BLOCK       = $000036
=$000038				SDCARD_FILE_PTR  = $000038 ; 3 Bytes Pointer to Filename to open
=$00003c				SDCARD_BYTE_NUM  = $00003C ; 2Bytes
=$00003f				SDCARD_PRSNT_MNT = $00003F ; 1 Byte, Indicate that the SDCard is Present and that it is Mounted
=$000040				BM_CLEAR_SCRN_X  = $000040
=$000042				BM_CLEAR_SCRN_Y  = $000042
=$000040				RAD_STARTLINE    = $000040 ; 1 Byte
=$000041				RAD_PATTERN_IDX  = $000041 ; 1 Byte
=$000042				RAD_LINE         = $000042 ; 1 Byte
=$000043				RAD_LINENUMBER   = $000043 ; 1 Byte
=$000044				RAD_CHANNEL_NUM  = $000044 ; 1 Byte
=$000045				RAD_ISLASTCHAN   = $000045 ; 1 Byte
=$000046				RAD_Y_POINTER    = $000046 ; 2 Bytes
=$000048				RAD_TICK         = $000048
=$00004a				RAD_CHANNEL_DATA = $00004A ; 2 Bytes
=$00004c				RAD_CHANNE_EFFCT = $00004C
=$00004d				RAD_TEMP         = $00004D
=$000050				RAD_ADDR         = $000050 ; 3 bytes to avoid OPL2 errors.
=$000053				RAD_PATTRN       = $000053 ; 1 bytes - offset to patter
=$000054				RAD_PTN_DEST     = $000054 ; 3 bytes - where to write the pattern data
=$000057				RAD_CHANNEL      = $000057 ; 2 bytes - 0 to 8
=$000059				RAD_LAST_NOTE    = $000059 ; 1 if this is the last note
=$00005a				RAD_LINE_PTR     = $00005A ; 2 bytes - offset to memory location
=$000040				BMP_X_SIZE       = $000040 ; 2 Bytes
=$000042				BMP_Y_SIZE       = $000042 ; 2 Bytes
=$000044				BMP_PRSE_SRC_PTR = $000044 ; 3 Bytes
=$000048				BMP_PRSE_DST_PTR = $000048 ; 3 Bytes
=$00004c				BMP_COLOR_PALET  = $00004C ; 2 Bytes
=$00004e				SCRN_X_STRIDE    = $00004E ; 2 Bytes, Basically How many Pixel Accross in Bitmap Mode
=$000050				BMP_FILE_SIZE    = $000050 ; 4 Bytes
=$000054				BMP_POSITION_X   = $000054 ; 2 Bytes Where, the BMP will be position on the X Axis
=$000056				BMP_POSITION_Y   = $000056 ; 2 Bytes Where, the BMP will be position on the Y Axis
=$000058				BMP_PALET_CHOICE = $000058 ;
=$0000e0				MOUSE_PTR        = $0000E0
=$0000e1				MOUSE_POS_X_LO   = $0000E1
=$0000e2				MOUSE_POS_X_HI   = $0000E2
=$0000e3				MOUSE_POS_Y_LO   = $0000E3
=$0000e4				MOUSE_POS_Y_HI   = $0000E4
=$0000f0				USER_TEMP        = $0000F0 ;32 Bytes Temp space for user programs
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000110				DIVIDER_0        = $000110 ;0 Byte  Unsigned divider
=$000110				D0_OPERAND_A     = $000110 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$000112				D0_OPERAND_B     = $000112 ;2 Bytes Divider 0 Divisor ex B in A/B
=$000114				D0_RESULT        = $000114 ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D0_REMAINDER     = $000116 ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000118				DIVIDER_1        = $000118 ;0 Byte  Signed divider
=$000118				D1_OPERAND_A     = $000118 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$00011a				D1_OPERAND_B     = $00011A ;2 Bytes Divider 1 Divisor ex B in A/B
=$00011c				D1_RESULT        = $00011C ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$00011e				D1_REMAINDER     = $00011E ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$000120				ADDER_SIGNED_32  = $000120 ; The 32 Bit Adders takes 12Byte that are NOT RAM Location
=$000140				INT_CONTROLLER   = $000140 ; $000140...$00015F Interrupt Controller
=$000160				TIMER_CONTROLLER = $000160 ; $000160...$00017F Timer0/Timer1/Timer2 Block
=$000160				TIMER_CTRL_REGLL = $000160 ;
=$000161				TIMER_CTRL_REGLH = $000161 ;
=$000162				TIMER_CTRL_REGHL = $000162 ;
=$000163				TIMER_CTRL_REGHH = $000163 ;
=$000240				CPU_REGISTERS    = $000240 ; Byte
=$000240				CPUPC            = $000240 ;2 Bytes Program Counter (PC)
=$000242				CPUPBR           = $000242 ;2 Bytes Program Bank Register (K)
=$000244				CPUA             = $000244 ;2 Bytes Accumulator (A)
=$000246				CPUX             = $000246 ;2 Bytes X Register (X)
=$000248				CPUY             = $000248 ;2 Bytes Y Register (Y)
=$00024a				CPUSTACK         = $00024A ;2 Bytes Stack Pointer (S)
=$00024c				CPUDP            = $00024C ;2 Bytes Direct Page Register (D)
=$00024e				CPUDBR           = $00024E ;1 Byte  Data Bank Register (B)
=$00024f				CPUFLAGS         = $00024F ;1 Byte  Flags (P)
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$000300				FDC_DRIVE        = $000300 ;1 byte - The number of the selected drive
=$000301				FDC_HEAD         = $000301 ;1 byte - The head number (0 or 1)
=$000302				FDC_CYLINDER     = $000302 ;1 byte - The cylinder number
=$000303				FDC_SECTOR       = $000303 ;1 byte - The sector number
=$000304				FDC_SECTOR_SIZE  = $000304 ;1 byte - The sector size code (2 = 512)
=$000305				FDC_SECPERTRK    = $000305 ;1 byte - The number of sectors per track (18 for 1.44 MB floppy)
=$000306				FDC_ST0          = $000306 ;1 byte - Status Register 0
=$000307				FDC_ST1          = $000307 ;1 byte - Status Register 1
=$000308				FDC_ST2          = $000308 ;1 byte - Status Register 2
=$000309				FDC_ST3          = $000309 ;1 byte - Status Register 3
=$00030a				FDC_PCN          = $00030A ;1 byte - Present Cylinder Number
=$00030b				FDC_STATUS       = $00030B ;1 byte - Status of what we think is going on with the FDC:
=$00030c				DIVIDEND         = $00030C ;4 bytes - Dividend for 32-bit division
=$000310				DIVISOR          = $000310 ;4 bytes - Divisor for 32-bit division
=$000314				REMAINDER        = $000314 ;4 bytes - Remainder for 32-bit division
=$000320				SDOS_VARIABLES   = $000320
=$000320				BIOS_STATUS      = $000320      ; 1 byte - Status of any BIOS operation
=$000321				BIOS_DEV         = $000321      ; 1 byte - Block device number for block operations
=$000322				BIOS_LBA         = $000322      ; 4 bytes - Address of block to read/write (this is the physical block, w/o reference to partition)
=$000326				BIOS_BUFF_PTR    = $000326      ; 4 bytes - 24-bit pointer to memory for read/write operations
=$00032a				BIOS_FIFO_COUNT  = $00032A      ; 2 bytes - The number of bytes read on the last block read
=$00032e				DOS_STATUS       = $00032E      ; 1 byte - The error code describing any error with file access
=$000330				DOS_CLUS_ID      = $000330      ; 4 bytes - The cluster desired for a DOS operation
=$000338				DOS_DIR_PTR      = $000338      ; 4 bytes - Pointer to a directory entry (assumed to be within DOS_SECTOR)
=$00033c				DOS_BUFF_PTR     = $00033C      ; 4 bytes - A pointer for DOS cluster read/write operations
=$000340				DOS_FD_PTR       = $000340      ; 4 bytes - A pointer to a file descriptor
=$000344				DOS_FAT_LBA      = $000344      ; 4 bytes - The LBA for a sector of the FAT we need to read/write
=$000348				DOS_TEMP         = $000348      ; 4 bytes - Temporary storage for DOS operations
=$00034c				DOS_FILE_SIZE    = $00034C      ; 4 bytes - The size of a file
=$000350				DOS_SRC_PTR      = $000350      ; 4 bytes - Pointer for transferring data
=$000354				DOS_DST_PTR      = $000354      ; 4 bytes - Pointer for transferring data
=$000358				DOS_END_PTR      = $000358      ; 4 bytes - Pointer to the last byte to save
=$00035c				DOS_RUN_PTR      = $00035C      ; 4 bytes - Pointer for starting a loaded program
=$000360				DOS_RUN_PARAM    = $000360      ; 4 bytes - Pointer to the ASCIIZ string for arguments in loading a program
=$000364				DOS_STR1_PTR     = $000364      ; 4 bytes - pointer to a string
=$000368				DOS_STR2_PTR     = $000368      ; 4 bytes - pointer to a string
=$00036b				DOS_SCRATCH      = $00036B      ; 4 bytes - general purpose short term storage
=$000400				DOS_PATH_BUFF    = $000400      ; 256 bytes - A buffer for path names
=$000500				FDC_PARAMETERS   = $000500      ; 16 bytes - a buffer of parameter data for the FDC
=$000510				FDC_RESULTS      = $000510      ; 16 bytes - Buffer for results of FDC commands
=$000530				FDC_PARAM_NUM    = $000530      ; 1 byte - The number of parameters to send to the FDC (including command)
=$000532				FDC_RESULT_NUM   = $000532      ; 1 byte - The number of results expected
=$000533				FDC_EXPECT_DAT   = $000533      ; 1 byte - 0 = the command expects no data, otherwise expects data
=$000534				FDC_CMD_RETRY    = $000534      ; 1 byte - a retry counter for commands
=$000700				CURRUART         = $000700 ; 3-bytes: the base address of the current UART
=$000703				CHAN_OUT         = $000703 ; 1-byte: the number of the current output channel (for PUTC, etc.)
=$000704				CHAN_IN          = $000704 ; 1-byte: the number of the current input channel (for GETCH, etc.)
=$000705				TIMERFLAGS       = $000705 ; 1-byte: flags to indicate that one of the timer interupts has triggered
=$80					TIMER0TRIGGER    = $80
=$40					TIMER1TRIGGER    = $40
=$20					TIMER2TRIGGER    = $20
=$000f00				KEY_BUFFER       = $000F00 ; 64 Bytes keyboard buffer
=$0080					KEY_BUFFER_SIZE  = $0080   ;128 Bytes (constant) keyboard buffer length
=$000f7f				KEY_BUFFER_END   = $000F7F ;  1 Byte  Last byte of keyboard buffer
=$000f83				KEY_BUFFER_CMD   = $000F83 ;  1 Byte  Indicates the Command Process Status
=$000f84				COMMAND_SIZE_STR = $000F84 ;  1 Byte
=$000f86				COMMAND_COMP_TMP = $000F86 ;  2 Bytes
=$000f87				KEYBOARD_SC_FLG  = $000F87 ;  1 Bytes that indicate the Status of Left Shift, Left CTRL, Left ALT, Right Shift
=$000f88				KEYBOARD_SC_TMP  = $000F88 ;  1 Byte, Interrupt Save Scan Code while Processing
=$000f89				KEYBOARD_LOCKS   = $000F89 ;  1 Byte, the status of the various lock keys
=$000f8a				KEYFLAG          = $000F8A ;  1 Byte, flag to indicate if CTRL-C has been pressed
=$000f8b				KEY_BUFFER_RPOS  = $000F8B ;  2 Byte, position of the character to read from the KEY_BUFFER
=$000f8d				KEY_BUFFER_WPOS  = $000F8D ;  2 Byte, position of the character to write to the KEY_BUFFER
=$001000				KERNEL_JMP_BEGIN = $001000 ; Reserved for the Kernel jump table
=$001fff				KERNEL_JMP_END   = $001FFF
=$002000				TEST_BEGIN       = $002000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/int_math_defs.s

=$000100				UNSIGNED_MULT_A_LO  = $000100
=$000101				UNSIGNED_MULT_A_HI  = $000101
=$000102				UNSIGNED_MULT_B_LO  = $000102
=$000103				UNSIGNED_MULT_B_HI  = $000103
=$000104				UNSIGNED_MULT_AL_LO = $000104
=$000105				UNSIGNED_MULT_AL_HI = $000105
=$000106				UNSIGNED_MULT_AH_LO = $000106
=$000107				UNSIGNED_MULT_AH_HI = $000107
=$000108				SIGNED_MULT_A_LO    = $000108
=$000109				SIGNED_MULT_A_HI    = $000109
=$00010a				SIGNED_MULT_B_LO    = $00010A
=$00010b				SIGNED_MULT_B_HI    = $00010B
=$00010c				SIGNED_MULT_AL_LO   = $00010C
=$00010d				SIGNED_MULT_AL_HI   = $00010D
=$00010e				SIGNED_MULT_AH_LO   = $00010E
=$00010f				SIGNED_MULT_AH_HI   = $00010F
=$000110				UNSIGNED_DIV_DEM_LO = $000110
=$000111				UNSIGNED_DIV_DEM_HI = $000111
=$000112				UNSIGNED_DIV_NUM_LO = $000112
=$000113				UNSIGNED_DIV_NUM_HI = $000113
=$000114				UNSIGNED_DIV_QUO_LO = $000114
=$000115				UNSIGNED_DIV_QUO_HI = $000115
=$000116				UNSIGNED_DIV_REM_LO = $000116
=$000117				UNSIGNED_DIV_REM_HI = $000117
=$000118				SIGNED_DIV_DEM_LO   = $000118
=$000119				SIGNED_DIV_DEM_HI   = $000119
=$00011a				SIGNED_DIV_NUM_LO   = $00011A
=$00011b				SIGNED_DIV_NUM_HI   = $00011B
=$00011c				SIGNED_DIV_QUO_LO   = $00011C
=$00011d				SIGNED_DIV_QUO_HI   = $00011D
=$00011e				SIGNED_DIV_REM_LO   = $00011E
=$00011f				SIGNED_DIV_REM_HI   = $00011F
=$000120				ADDER32_A_LL        = $000120
=$000121				ADDER32_A_LH        = $000121
=$000122				ADDER32_A_HL        = $000122
=$000123				ADDER32_A_HH        = $000123
=$000124				ADDER32_B_LL        = $000124
=$000125				ADDER32_B_LH        = $000125
=$000126				ADDER32_B_HL        = $000126
=$000127				ADDER32_B_HH        = $000127
=$000128				ADDER32_R_LL        = $000128
=$000129				ADDER32_R_LH        = $000129
=$00012a				ADDER32_R_HL        = $00012A
=$00012b				ADDER32_R_HH        = $00012B
=$af1400				SIGNED32_MULT_A     = $AF1400
=$af1404				SIGNED32_MULT_B     = $AF1404
=$af1408				SIGNED32_MULT_OUT   = $AF1408

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/vicky_def.s

=$af0000				MASTER_CTRL_REG_L	      = $AF0000
=$01					Mstr_Ctrl_Text_Mode_En  = $01       ; Enable the Text Mode
=$02					Mstr_Ctrl_Text_Overlay  = $02       ; Enable the Overlay of the text mode on top of Graphic Mode (the Background Color is ignored)
=$04					Mstr_Ctrl_Graph_Mode_En = $04       ; Enable the Graphic Mode
=$08					Mstr_Ctrl_Bitmap_En     = $08       ; Enable the Bitmap Module In Vicky
=$10					Mstr_Ctrl_TileMap_En    = $10       ; Enable the Tile Module in Vicky
=$20					Mstr_Ctrl_Sprite_En     = $20       ; Enable the Sprite Module in Vicky
=$40					Mstr_Ctrl_GAMMA_En      = $40       ; this Enable the GAMMA correction - The Analog and DVI have different color value, the GAMMA is great to correct the difference
=$80					Mstr_Ctrl_Disable_Vid   = $80       ; This will disable the Scanning of the Video hence giving 100% bandwith to the CPU
=$af0001				MASTER_CTRL_REG_H       = $AF0001
=$01					Mstr_Ctrl_Video_Mode0   = $01       ; 0 - 640x480 (Clock @ 25.175Mhz), 1 - 800x600 (Clock @ 40Mhz)
=$02					Mstr_Ctrl_Video_Mode1   = $02       ; 0 - No Pixel Doubling, 1- Pixel Doubling (Reduce the Pixel Resolution by 2)
=$af0002				GAMMA_CTRL_REG          = $AF0002
=$01					GAMMA_Ctrl_Input        = $01 ; 0 = DipSwitch Chooses GAMMA on/off , 1- Software Control
=$02					GAMMA_Ctrl_Soft         = $02 ; 0 = GAMMA Table is not Applied, 1 = GAMMA Table is Applied
=$08					GAMMA_DP_SW_VAL         = $08 ; READ ONLY - Actual DIP Switch Value
=$10					HIRES_DP_SW_VAL         = $10 ; READ ONLY - 0 = Hi-Res on BOOT ON, 1 = Hi-Res on BOOT OFF
=$af0003				VKY_RESERVED_01         = $AF0003
=$01					Border_Ctrl_Enable      = $01
=$af0004				BORDER_CTRL_REG         = $AF0004 ; Bit[0] - Enable (1 by default)  Bit[4..6]: X Scroll Offset ( Will scroll Left) (Acceptable Value: 0..7)
=$af0005				BORDER_COLOR_B          = $AF0005
=$af0006				BORDER_COLOR_G          = $AF0006
=$af0007				BORDER_COLOR_R          = $AF0007
=$af0008				BORDER_X_SIZE           = $AF0008; X-  Values: 0 - 32 (Default: 32)
=$af0009				BORDER_Y_SIZE           = $AF0009; Y- Values 0 -32 (Default: 32)
=$af000d				BACKGROUND_COLOR_B      = $AF000D ; When in Graphic Mode, if a pixel is "0" then the Background pixel is chosen
=$af000e				BACKGROUND_COLOR_G      = $AF000E
=$af000f				BACKGROUND_COLOR_R      = $AF000F ;
=$af0010				VKY_TXT_CURSOR_CTRL_REG = $AF0010   ;[0]  Enable Text Mode
=$01					Vky_Cursor_Enable       = $01
=$02					Vky_Cursor_Flash_Rate0  = $02       ; 00 - 1/Sec, 01 - 2/Sec, 10 - 4/Sec, 11 - 5/Sec
=$04					Vky_Cursor_Flash_Rate1  = $04
=$08					Vky_Cursor_FONT_Page0   = $08       ; Pick Font Page 0 or Font Page 1
=$10					Vky_Cursor_FONT_Page1   = $10       ; Pick Font Page 0 or Font Page 1
=$af0011				VKY_TXT_START_ADD_PTR   = $AF0011   ; This is an offset to change the Starting address of the Text Mode Buffer (in x)
=$af0012				VKY_TXT_CURSOR_CHAR_REG = $AF0012
=$af0013				VKY_TXT_CURSOR_COLR_REG = $AF0013
=$af0014				VKY_TXT_CURSOR_X_REG_L  = $AF0014
=$af0015				VKY_TXT_CURSOR_X_REG_H  = $AF0015
=$af0016				VKY_TXT_CURSOR_Y_REG_L  = $AF0016
=$af0017				VKY_TXT_CURSOR_Y_REG_H  = $AF0017
=$af001b				VKY_LINE_IRQ_CTRL_REG   = $AF001B ;[0] - Enable Line 0, [1] -Enable Line 1
=$af001c				VKY_LINE0_CMP_VALUE_LO  = $AF001C ;Write Only [7:0]
=$af001d				VKY_LINE0_CMP_VALUE_HI  = $AF001D ;Write Only [3:0]
=$af001e				VKY_LINE1_CMP_VALUE_LO  = $AF001E ;Write Only [7:0]
=$af001f				VKY_LINE1_CMP_VALUE_HI  = $AF001F ;Write Only [3:0]
=$af001c				VKY_INFO_CHIP_NUM_L     = $AF001C   ; VErsion
=$af001d				VKY_INFO_CHIP_NUM_H     = $AF001D   ; Version
=$af001e				VKY_INFO_CHIP_VER_L     = $AF001E   ; Sub-Version
=$af001f				VKY_INFO_CHIP_VER_H     = $AF001F   ; Sub-Version
=$af0500				MOUSE_PTR_GRAP0_START    = $AF0500 ; 16 x 16 = 256 Pixels (Grey Scale) 0 = Transparent, 1 = Black , 255 = White
=$af05ff				MOUSE_PTR_GRAP0_END      = $AF05FF ; Pointer 0
=$af0600				MOUSE_PTR_GRAP1_START    = $AF0600 ;
=$af06ff				MOUSE_PTR_GRAP1_END      = $AF06FF ; Pointer 1
=$af0700				MOUSE_PTR_CTRL_REG_L    = $AF0700 ; Bit[0] Enable, Bit[1] = 0  ( 0 = Pointer0, 1 = Pointer1)
=$af0701				MOUSE_PTR_CTRL_REG_H    = $AF0701 ;
=$af0702				MOUSE_PTR_X_POS_L       = $AF0702 ; X Position (0 - 639) (Can only read now) Writing will have no effect
=$af0703				MOUSE_PTR_X_POS_H       = $AF0703 ;
=$af0704				MOUSE_PTR_Y_POS_L       = $AF0704 ; Y Position (0 - 479) (Can only read now) Writing will have no effect
=$af0705				MOUSE_PTR_Y_POS_H       = $AF0705 ;
=$af0706				MOUSE_PTR_BYTE0         = $AF0706 ; Byte 0 of Mouse Packet (you must write 3 Bytes)
=$af0707				MOUSE_PTR_BYTE1         = $AF0707 ; Byte 1 of Mouse Packet (if you don't, then )
=$af0708				MOUSE_PTR_BYTE2         = $AF0708 ; Byte 2 of Mouse Packet (state Machine will be jammed in 1 state)
=$af070b				C256F_MODEL_MAJOR       = $AF070B ;
=$af070c				C256F_MODEL_MINOR       = $AF070C ;
=$af070d				FPGA_DOR                = $AF070D ;
=$af070e				FPGA_MOR                = $AF070E ;
=$af070f				FPGA_YOR                = $AF070F ;
=$af0900				VMEM2CPU_CTRL_REG      = $AF0900  ;
=$01					VMEM2CPU_Clear_FIFO    = $01        ; Setting this to 1 will flush (Reset) the FIFO, clear it after to return to normal function
=$02					VMEM2CPU_Intterupt     = $02        ; This is not implemented because there is not enough Interrupt line on the FMX
=$af0901				VMEM2CPU_Data_Port     = $AF0901    ; This is a Byte Port of the data that you have requested. (Output of the FIFO)
=$af0902				VMEM2CPU_Fifo_Count_LO = $AF0902    ; FIFO Count Lo (number of byte in the FIFO) FIFO Count is 10bits, Count_Bit0 to Count_Bit7 of Count
=$af0903				VMEM2CPU_Fifo_Count_HI = $AF0903    ; FIFO Count Hi, Bit 0 = Count_Bit8, Bit 1 = Count_Bit9
=$80					VMEM2CPU_Fifo_Empty    = $80        ; Bit 7 of VMEM2CPU_Fifo_Count_HI, when 1, the FIFO is empty.
=$af1f40				FG_CHAR_LUT_PTR         = $AF1F40
=$af1f80				BG_CHAR_LUT_PTR		    = $AF1F80
=$af2000				GRPH_LUT0_PTR		    = $AF2000
=$af2400				GRPH_LUT1_PTR		    = $AF2400
=$af2800				GRPH_LUT2_PTR		    = $AF2800
=$af2c00				GRPH_LUT3_PTR		    = $AF2C00
=$af3000				GRPH_LUT4_PTR		    = $AF3000
=$af3400				GRPH_LUT5_PTR		    = $AF3400
=$af3800				GRPH_LUT6_PTR		    = $AF3800
=$af3c00				GRPH_LUT7_PTR		    = $AF3C00
=$af4000				GAMMA_B_LUT_PTR		    = $AF4000
=$af4100				GAMMA_G_LUT_PTR		    = $AF4100
=$af4200				GAMMA_R_LUT_PTR		    = $AF4200
=$af8000				FONT_MEMORY_BANK0       = $AF8000     ;$AF8000 - $AF87FF
=$afa000				CS_TEXT_MEM_PTR         = $AFA000
=$afc000				CS_COLOR_MEM_PTR        = $AFC000

;******  Processing file: src\C256/VKYII_CFP9553_BITMAP_def.s

=$01					BM_Enable             = $01
=$00					BM_LUT0               = $00 ;
=$02					BM_LUT1               = $02 ;
=$04					BM_LUT2               = $04 ;
=$06					BM_LUT3               = $06 ;
=$08					BM_LUT4               = $08 ;
=$0a					BM_LUT5               = $0A ;
=$0c					BM_LUT6               = $0C ;
=$0e					BM_LUT7               = $0E ;
=$af0100				BM0_CONTROL_REG     = $AF0100
=$af0101				BM0_START_ADDY_L    = $AF0101
=$af0102				BM0_START_ADDY_M    = $AF0102
=$af0103				BM0_START_ADDY_H    = $AF0103
=$af0104				BM0_X_OFFSET        = $AF0104   ; Not Implemented
=$af0105				BM0_Y_OFFSET        = $AF0105   ; Not Implemented
=$af0106				BM0_RESERVED_6      = $AF0106
=$af0107				BM0_RESERVED_7      = $AF0107
=$af0108				BM1_CONTROL_REG     = $AF0108
=$af0109				BM1_START_ADDY_L    = $AF0109
=$af010a				BM1_START_ADDY_M    = $AF010A
=$af010b				BM1_START_ADDY_H    = $AF010B
=$af010c				BM1_X_OFFSET        = $AF010C   ; Not Implemented
=$af010d				BM1_Y_OFFSET        = $AF010D   ; Not Implemented
=$af010e				BM1_RESERVED_6      = $AF010E
=$af010f				BM1_RESERVED_7      = $AF010F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_TILEMAP_def.s

=$01					TILE_Enable             = $01
=0					TILEMAP_CONTROL         = 0             ; Offset to a tile map's control register
=1					TILEMAP_START_ADDY      = 1             ; Offset to a tile map's address
=4					TILEMAP_TOTAL_X         = 4             ; Offset to a tile map's width
=6					TILEMAP_TOTAL_Y         = 6             ; Offset to a tile map's height
=8					TILEMAP_WINDOW_X        = 8             ; Offset to a tile map's X position
=10					TILEMAP_WINDOW_Y        = 10            ; Offset to a tile map's Y position
=1					TILEMAP_VISIBLE         = 1             ; Tile map is visible flag
=$af0200				TL0_CONTROL_REG         = $AF0200       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0201				TL0_START_ADDY_L        = $AF0201       ; Not USed right now - Starting Address to where is the MAP
=$af0202				TL0_START_ADDY_M        = $AF0202
=$af0203				TL0_START_ADDY_H        = $AF0203
=$af0204				TL0_TOTAL_X_SIZE_L      = $AF0204       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0205				TL0_TOTAL_X_SIZE_H      = $AF0205
=$af0206				TL0_TOTAL_Y_SIZE_L      = $AF0206       ; Size of the Map in Y Tile Count [9:0]
=$af0207				TL0_TOTAL_Y_SIZE_H      = $AF0207
=$af0208				TL0_WINDOW_X_POS_L      = $AF0208       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0209				TL0_WINDOW_X_POS_H      = $AF0209       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af020a				TL0_WINDOW_Y_POS_L      = $AF020A       ; Top Left Corner Position of the TileMAp Window in Y
=$af020b				TL0_WINDOW_Y_POS_H      = $AF020B       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af020c				TL1_CONTROL_REG         = $AF020C       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af020d				TL1_START_ADDY_L        = $AF020D       ; Not USed right now - Starting Address to where is the MAP
=$af020e				TL1_START_ADDY_M        = $AF020E
=$af020f				TL1_START_ADDY_H        = $AF020F
=$af0210				TL1_TOTAL_X_SIZE_L      = $AF0210       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0211				TL1_TOTAL_X_SIZE_H      = $AF0211
=$af0212				TL1_TOTAL_Y_SIZE_L      = $AF0212       ; Size of the Map in Y Tile Count [9:0]
=$af0213				TL1_TOTAL_Y_SIZE_H      = $AF0213
=$af0214				TL1_WINDOW_X_POS_L      = $AF0214       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0215				TL1_WINDOW_X_POS_H      = $AF0215       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0216				TL1_WINDOW_Y_POS_L      = $AF0216       ; Top Left Corner Position of the TileMAp Window in Y
=$af0217				TL1_WINDOW_Y_POS_H      = $AF0217       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0218				TL2_CONTROL_REG         = $AF0218       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0219				TL2_START_ADDY_L        = $AF0219       ; Not USed right now - Starting Address to where is the MAP
=$af021a				TL2_START_ADDY_M        = $AF021A
=$af021b				TL2_START_ADDY_H        = $AF021B
=$af021c				TL2_TOTAL_X_SIZE_L      = $AF021C       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af021d				TL2_TOTAL_X_SIZE_H      = $AF021D
=$af021e				TL2_TOTAL_Y_SIZE_L      = $AF021E       ; Size of the Map in Y Tile Count [9:0]
=$af021f				TL2_TOTAL_Y_SIZE_H      = $AF021F
=$af0220				TL2_WINDOW_X_POS_L      = $AF0220       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0221				TL2_WINDOW_X_POS_H      = $AF0221       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0222				TL2_WINDOW_Y_POS_L      = $AF0222       ; Top Left Corner Position of the TileMAp Window in Y
=$af0223				TL2_WINDOW_Y_POS_H      = $AF0223       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0224				TL3_CONTROL_REG         = $AF0224       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0225				TL3_START_ADDY_L        = $AF0225       ; Not USed right now - Starting Address to where is the MAP
=$af0226				TL3_START_ADDY_M        = $AF0226
=$af0227				TL3_START_ADDY_H        = $AF0227
=$af0228				TL3_TOTAL_X_SIZE_L      = $AF0228       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0229				TL3_TOTAL_X_SIZE_H      = $AF0229
=$af022a				TL3_TOTAL_Y_SIZE_L      = $AF022A       ; Size of the Map in Y Tile Count [9:0]
=$af022b				TL3_TOTAL_Y_SIZE_H      = $AF022B
=$af022c				TL3_WINDOW_X_POS_L      = $AF022C       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af022d				TL3_WINDOW_X_POS_H      = $AF022D       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af022e				TL3_WINDOW_Y_POS_L      = $AF022E       ; Top Left Corner Position of the TileMAp Window in Y
=$af022f				TL3_WINDOW_Y_POS_H      = $AF022F       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0280				TILESET0_ADDY_L         = $AF0280   ; Pointer to Tileset 0 [21:0]
=$af0281				TILESET0_ADDY_M         = $AF0281
=$af0282				TILESET0_ADDY_H         = $AF0282
=$af0283				TILESET0_ADDY_CFG       = $AF0283   ; [3] - TileStride256x256 [2:0] LUT
=2					TILESET_ADDY_H          = 2             ; Offset to high byte of tile set address
=3					TILESET_ADDY_CFG        = 3             ; Offset to the tile set address configuration
=$08					TILESET_SQUARE_256      = $08
=$af0284				TILESET1_ADDY_L         = $AF0284
=$af0285				TILESET1_ADDY_M         = $AF0285
=$af0286				TILESET1_ADDY_H         = $AF0286
=$af0287				TILESET1_ADDY_CFG       = $AF0287
=$af0288				TILESET2_ADDY_L         = $AF0288
=$af0289				TILESET2_ADDY_M         = $AF0289
=$af028a				TILESET2_ADDY_H         = $AF028A
=$af028b				TILESET2_ADDY_CFG       = $AF028B
=$af028c				TILESET3_ADDY_L         = $AF028C
=$af028d				TILESET3_ADDY_M         = $AF028D
=$af028e				TILESET3_ADDY_H         = $AF028E
=$af028f				TILESET3_ADDY_CFG       = $AF028F
=$af0290				TILESET4_ADDY_L         = $AF0290
=$af0291				TILESET4_ADDY_M         = $AF0291
=$af0292				TILESET4_ADDY_H         = $AF0292
=$af0293				TILESET4_ADDY_CFG       = $AF0293
=$af0294				TILESET5_ADDY_L         = $AF0294
=$af0295				TILESET5_ADDY_M         = $AF0295
=$af0296				TILESET5_ADDY_H         = $AF0296
=$af0297				TILESET5_ADDY_CFG       = $AF0297
=$af0298				TILESET6_ADDY_L         = $AF0298
=$af0299				TILESET6_ADDY_M         = $AF0299
=$af029a				TILESET6_ADDY_H         = $AF029A
=$af029b				TILESET6_ADDY_CFG       = $AF029B
=$af029c				TILESET7_ADDY_L         = $AF029C
=$af029d				TILESET7_ADDY_M         = $AF029D
=$af029e				TILESET7_ADDY_H         = $AF029E
=$af029f				TILESET7_ADDY_CFG       = $AF029F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SDMA_def.s

=$af0420				SDMA_CTRL_REG0           = $AF0420
=$01					SDMA_CTRL0_Enable        = $01
=$02					SDMA_CTRL0_1D_2D         = $02     ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					SDMA_CTRL0_TRF_Fill      = $04     ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					SDMA_CTRL0_Int_Enable    = $08     ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					SDMA_CTRL0_SysRAM_Src    = $10     ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					SDMA_CTRL0_SysRAM_Dst    = $20     ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$00					SDMA_XFER_SRAM2SRAM = $00           ; SRAM -> SRAM transfer
=$10					SDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					SDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$30					SDMA_XFER_SRAMIO = $30              ; SRAM <-> IO transfer (see: SDMA_CONTROL_REG1 for config and direction)
=$40					SDMA_CTLR0_RSVD          = $40      ; Reserved
=$80					SDMA_CTRL0_Start_TRF     = $80      ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$af0421				SDMA_CTRL_REG1           = $AF0421  ; Write Only - Byte to Write in the Fill Function
=$01					SDMA_CTRL1_IO_Src		 = $01		; 1 = Source is an IO Address (ADC, SuperIO, IDE)
=$02					SDMA_CTRL1_IO_Src16		 = $02		; 0 = Src 8Bits Transfer / 1= 16Bits Transfer
=$04					SDMA_CTRL1_IO_Dst		 = $04		; 1 = Destination is an IO Address (DAC, SuperIO, IDE)
=$08					SDMA_CTRL1_IO_Dst16      = $08      ; 0 = Dst 8bits Transfer / 1= 16bits
=$af0422				SDMA_SRC_ADDY_L         = $AF0422   ; Pointer to the Source of the Data to be stransfered
=$af0423				SDMA_SRC_ADDY_M         = $AF0423   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0424				SDMA_SRC_ADDY_H         = $AF0424
=$af0425				SDMA_DST_ADDY_L         = $AF0425   ; Destination Pointer within CPU's video memory Range
=$af0426				SDMA_DST_ADDY_M         = $AF0426   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0427				SDMA_DST_ADDY_H         = $AF0427
=$af0428				SDMA_SIZE_L             = $AF0428   ; Maximum Value: $40:0000 (4Megs)
=$af0429				SDMA_SIZE_M             = $AF0429
=$af042a				SDMA_SIZE_H             = $AF042A
=$af042b				SDMA_IGNORED            = $AF042B
=$af0428				SDMA_X_SIZE_L           = $AF0428   ; Maximum Value: 65535
=$af0429				SDMA_X_SIZE_H           = $AF0429
=$af042a				SDMA_Y_SIZE_L           = $AF042A   ; Maximum Value: 65535
=$af042b				SDMA_Y_SIZE_H           = $AF042B
=$af042c				SDMA_SRC_STRIDE_L       = $AF042C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042d				SDMA_SRC_STRIDE_H       = $AF042D   ;
=$af042e				SDMA_DST_STRIDE_L       = $AF042E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042f				SDMA_DST_STRIDE_H       = $AF042F   ;
=$af0430				SDMA_BYTE_2_WRITE       = $AF0430   ; Write Only - Byte to Write in the Fill Function
=$af0430				SDMA_STATUS_REG         = $AF0430   ; Read only
=$01					SDMA_STAT_Size_Err       = $01      ; If Set to 1, Overall Size is Invalid
=$02					SDMA_STAT_Dst_Add_Err    = $02      ; If Set to 1, Destination Address Invalid
=$04					SDMA_STAT_Src_Add_Err    = $04      ; If Set to 1, Source Address Invalid
=$08					SDMA_STAT_TimeOut_Err    = $08      ; will be set to 1 if a Timeout occur when transfering between data from and to VRAM

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_VDMA_def.s

=$af0400				VDMA_CONTROL_REG        = $AF0400
=$01					VDMA_CTRL_Enable        = $01
=$02					VDMA_CTRL_1D_2D         = $02       ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					VDMA_CTRL_TRF_Fill      = $04       ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					VDMA_CTRL_Int_Enable    = $08       ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					VDMA_CTRL_SysRAM_Src    = $10       ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					VDMA_CTRL_SysRAM_Dst    = $20       ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$80					VDMA_CTRL_Start_TRF     = $80       ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$00					VDMA_XFER_VRAM2VRAM = $00           ; VRAM -> VRAM transfer
=$10					VDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					VDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$af0401				VDMA_BYTE_2_WRITE       = $AF0401   ; Write Only - Byte to Write in the Fill Function
=$af0401				VDMA_STATUS_REG         = $AF0401   ; Read only
=$01					VDMA_STAT_Size_Err      = $01       ; If Set to 1, Overall Size is Invalid
=$02					VDMA_STAT_Dst_Add_Err   = $02       ; If Set to 1, Destination Address Invalid
=$04					VDMA_STAT_Src_Add_Err   = $04       ; If Set to 1, Source Address Invalid
=$80					VDMA_STAT_VDMA_IPS      = $80       ; If Set to 1, VDMA Transfer in Progress (this Inhibit CPU Access to Mem)
=$af0402				VDMA_SRC_ADDY_L         = $AF0402   ; Pointer to the Source of the Data to be stransfered
=$af0403				VDMA_SRC_ADDY_M         = $AF0403   ; This needs to be within Vicky's Range ($00_0000 - $3F_0000)
=$af0404				VDMA_SRC_ADDY_H         = $AF0404
=$af0405				VDMA_DST_ADDY_L         = $AF0405   ; Destination Pointer within Vicky's video memory Range
=$af0406				VDMA_DST_ADDY_M         = $AF0406   ; ($00_0000 - $3F_0000)
=$af0407				VDMA_DST_ADDY_H         = $AF0407
=$af0408				VDMA_SIZE_L             = $AF0408   ; Maximum Value: $40:0000 (4Megs)
=$af0409				VDMA_SIZE_M             = $AF0409
=$af040a				VDMA_SIZE_H             = $AF040A
=$af040b				VDMA_IGNORED            = $AF040B
=$af0408				VDMA_X_SIZE_L           = $AF0408   ; Maximum Value: 65535
=$af0409				VDMA_X_SIZE_H           = $AF0409
=$af040a				VDMA_Y_SIZE_L           = $AF040A   ; Maximum Value: 65535
=$af040b				VDMA_Y_SIZE_H           = $AF040B
=$af040c				VDMA_SRC_STRIDE_L       = $AF040C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040d				VDMA_SRC_STRIDE_H       = $AF040D   ;
=$af040e				VDMA_DST_STRIDE_L       = $AF040E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040f				VDMA_DST_STRIDE_H       = $AF040F   ;

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SPRITE_def.s

=$01					SPRITE_Enable             = $01
=$00					SPRITE_LUT0               = $00 ; This is the LUT that the Sprite will use
=$02					SPRITE_LUT1               = $02
=$04					SPRITE_LUT2               = $04 ; Only 4 LUT for Now, So this bit is not used.
=$06					SPRITE_LUT3               = $06 ; Only 4 LUT for Now, So this bit is not used.
=$08					SPRITE_LUT4               = $08 ; Only 4 LUT for Now, So this bit is not used.
=$0a					SPRITE_LUT5               = $0A ; Only 4 LUT for Now, So this bit is not used.
=$0c					SPRITE_LUT6               = $0C ; Only 4 LUT for Now, So this bit is not used.
=$0e					SPRITE_LUT7               = $0E ; Only 4 LUT for Now, So this bit is not used.
=$00					SPRITE_DEPTH0             = $00
=$10					SPRITE_DEPTH1             = $10
=$20					SPRITE_DEPTH2             = $20
=$30					SPRITE_DEPTH3             = $30
=$40					SPRITE_DEPTH4             = $40
=$50					SPRITE_DEPTH5             = $50
=$60					SPRITE_DEPTH6             = $60
=$af0c00				SP00_CONTROL_REG        = $AF0C00
=$af0c01				SP00_ADDY_PTR_L         = $AF0C01
=$af0c02				SP00_ADDY_PTR_M         = $AF0C02
=$af0c03				SP00_ADDY_PTR_H         = $AF0C03
=$af0c04				SP00_X_POS_L            = $AF0C04
=$af0c05				SP00_X_POS_H            = $AF0C05
=$af0c06				SP00_Y_POS_L            = $AF0C06
=$af0c07				SP00_Y_POS_H            = $AF0C07
=$af0c08				SP01_CONTROL_REG        = $AF0C08
=$af0c09				SP01_ADDY_PTR_L         = $AF0C09
=$af0c0a				SP01_ADDY_PTR_M         = $AF0C0A
=$af0c0b				SP01_ADDY_PTR_H         = $AF0C0B
=$af0c0c				SP01_X_POS_L            = $AF0C0C
=$af0c0d				SP01_X_POS_H            = $AF0C0D
=$af0c0e				SP01_Y_POS_L            = $AF0C0E
=$af0c0f				SP01_Y_POS_H            = $AF0C0F
=$af0c10				SP02_CONTROL_REG        = $AF0C10
=$af0c11				SP02_ADDY_PTR_L         = $AF0C11
=$af0c12				SP02_ADDY_PTR_M         = $AF0C12
=$af0c13				SP02_ADDY_PTR_H         = $AF0C13
=$af0c14				SP02_X_POS_L            = $AF0C14
=$af0c15				SP02_X_POS_H            = $AF0C15
=$af0c16				SP02_Y_POS_L            = $AF0C16
=$af0c17				SP02_Y_POS_H            = $AF0C17
=$af0c18				SP03_CONTROL_REG        = $AF0C18
=$af0c19				SP03_ADDY_PTR_L         = $AF0C19
=$af0c1a				SP03_ADDY_PTR_M         = $AF0C1A
=$af0c1b				SP03_ADDY_PTR_H         = $AF0C1B
=$af0c1c				SP03_X_POS_L            = $AF0C1C
=$af0c1d				SP03_X_POS_H            = $AF0C1D
=$af0c1e				SP03_Y_POS_L            = $AF0C1E
=$af0c1f				SP03_Y_POS_H            = $AF0C1F
=$af0c20				SP04_CONTROL_REG        = $AF0C20
=$af0c21				SP04_ADDY_PTR_L         = $AF0C21
=$af0c22				SP04_ADDY_PTR_M         = $AF0C22
=$af0c23				SP04_ADDY_PTR_H         = $AF0C23
=$af0c24				SP04_X_POS_L            = $AF0C24
=$af0c25				SP04_X_POS_H            = $AF0C25
=$af0c26				SP04_Y_POS_L            = $AF0C26
=$af0c27				SP04_Y_POS_H            = $AF0C27
=$af0c28				SP05_CONTROL_REG        = $AF0C28
=$af0c29				SP05_ADDY_PTR_L         = $AF0C29
=$af0c2a				SP05_ADDY_PTR_M         = $AF0C2A
=$af0c2b				SP05_ADDY_PTR_H         = $AF0C2B
=$af0c2c				SP05_X_POS_L            = $AF0C2C
=$af0c2d				SP05_X_POS_H            = $AF0C2D
=$af0c2e				SP05_Y_POS_L            = $AF0C2E
=$af0c2f				SP05_Y_POS_H            = $AF0C2F
=$af0c30				SP06_CONTROL_REG        = $AF0C30
=$af0c31				SP06_ADDY_PTR_L         = $AF0C31
=$af0c32				SP06_ADDY_PTR_M         = $AF0C32
=$af0c33				SP06_ADDY_PTR_H         = $AF0C33
=$af0c34				SP06_X_POS_L            = $AF0C34
=$af0c35				SP06_X_POS_H            = $AF0C35
=$af0c36				SP06_Y_POS_L            = $AF0C36
=$af0c37				SP06_Y_POS_H            = $AF0C37
=$af0c38				SP07_CONTROL_REG        = $AF0C38
=$af0c39				SP07_ADDY_PTR_L         = $AF0C39
=$af0c3a				SP07_ADDY_PTR_M         = $AF0C3A
=$af0c3b				SP07_ADDY_PTR_H         = $AF0C3B
=$af0c3c				SP07_X_POS_L            = $AF0C3C
=$af0c3d				SP07_X_POS_H            = $AF0C3D
=$af0c3e				SP07_Y_POS_L            = $AF0C3E
=$af0c3f				SP07_Y_POS_H            = $AF0C3F
=$af0c40				SP08_CONTROL_REG        = $AF0C40
=$af0c41				SP08_ADDY_PTR_L         = $AF0C41
=$af0c42				SP08_ADDY_PTR_M         = $AF0C42
=$af0c43				SP08_ADDY_PTR_H         = $AF0C43
=$af0c44				SP08_X_POS_L            = $AF0C44
=$af0c45				SP08_X_POS_H            = $AF0C45
=$af0c46				SP08_Y_POS_L            = $AF0C46
=$af0c47				SP08_Y_POS_H            = $AF0C47
=$af0c48				SP09_CONTROL_REG        = $AF0C48
=$af0c49				SP09_ADDY_PTR_L         = $AF0C49
=$af0c4a				SP09_ADDY_PTR_M         = $AF0C4A
=$af0c4b				SP09_ADDY_PTR_H         = $AF0C4B
=$af0c4c				SP09_X_POS_L            = $AF0C4C
=$af0c4d				SP09_X_POS_H            = $AF0C4D
=$af0c4e				SP09_Y_POS_L            = $AF0C4E
=$af0c4f				SP09_Y_POS_H            = $AF0C4F
=$af0c50				SP10_CONTROL_REG        = $AF0C50
=$af0c51				SP10_ADDY_PTR_L         = $AF0C51
=$af0c52				SP10_ADDY_PTR_M         = $AF0C52
=$af0c53				SP10_ADDY_PTR_H         = $AF0C53
=$af0c54				SP10_X_POS_L            = $AF0C54
=$af0c55				SP10_X_POS_H            = $AF0C55
=$af0c56				SP10_Y_POS_L            = $AF0C56
=$af0c57				SP10_Y_POS_H            = $AF0C57
=$af0c58				SP11_CONTROL_REG        = $AF0C58
=$af0c59				SP11_ADDY_PTR_L         = $AF0C59
=$af0c5a				SP11_ADDY_PTR_M         = $AF0C5A
=$af0c5b				SP11_ADDY_PTR_H         = $AF0C5B
=$af0c5c				SP11_X_POS_L            = $AF0C5C
=$af0c5d				SP11_X_POS_H            = $AF0C5D
=$af0c5e				SP11_Y_POS_L            = $AF0C5E
=$af0c5f				SP11_Y_POS_H            = $AF0C5F
=$af0c60				SP12_CONTROL_REG        = $AF0C60
=$af0c61				SP12_ADDY_PTR_L         = $AF0C61
=$af0c62				SP12_ADDY_PTR_M         = $AF0C62
=$af0c63				SP12_ADDY_PTR_H         = $AF0C63
=$af0c64				SP12_X_POS_L            = $AF0C64
=$af0c65				SP12_X_POS_H            = $AF0C65
=$af0c66				SP12_Y_POS_L            = $AF0C66
=$af0c67				SP12_Y_POS_H            = $AF0C67
=$af0c68				SP13_CONTROL_REG        = $AF0C68
=$af0c69				SP13_ADDY_PTR_L         = $AF0C69
=$af0c6a				SP13_ADDY_PTR_M         = $AF0C6A
=$af0c6b				SP13_ADDY_PTR_H         = $AF0C6B
=$af0c6c				SP13_X_POS_L            = $AF0C6C
=$af0c6d				SP13_X_POS_H            = $AF0C6D
=$af0c6e				SP13_Y_POS_L            = $AF0C6E
=$af0c6f				SP13_Y_POS_H            = $AF0C6F
=$af0c70				SP14_CONTROL_REG        = $AF0C70
=$af0c71				SP14_ADDY_PTR_L         = $AF0C71
=$af0c72				SP14_ADDY_PTR_M         = $AF0C72
=$af0c73				SP14_ADDY_PTR_H         = $AF0C73
=$af0c74				SP14_X_POS_L            = $AF0C74
=$af0c75				SP14_X_POS_H            = $AF0C75
=$af0c76				SP14_Y_POS_L            = $AF0C76
=$af0c77				SP14_Y_POS_H            = $AF0C77
=$af0c78				SP15_CONTROL_REG        = $AF0C78
=$af0c79				SP15_ADDY_PTR_L         = $AF0C79
=$af0c7a				SP15_ADDY_PTR_M         = $AF0C7A
=$af0c7b				SP15_ADDY_PTR_H         = $AF0C7B
=$af0c7c				SP15_X_POS_L            = $AF0C7C
=$af0c7d				SP15_X_POS_H            = $AF0C7D
=$af0c7e				SP15_Y_POS_L            = $AF0C7E
=$af0c7f				SP15_Y_POS_H            = $AF0C7F
=$af0c80				SP16_CONTROL_REG        = $AF0C80
=$af0c81				SP16_ADDY_PTR_L         = $AF0C81
=$af0c82				SP16_ADDY_PTR_M         = $AF0C82
=$af0c83				SP16_ADDY_PTR_H         = $AF0C83
=$af0c84				SP16_X_POS_L            = $AF0C84
=$af0c85				SP16_X_POS_H            = $AF0C85
=$af0c86				SP16_Y_POS_L            = $AF0C86
=$af0c87				SP16_Y_POS_H            = $AF0C87
=$af0c88				SP17_CONTROL_REG        = $AF0C88
=$af0c89				SP17_ADDY_PTR_L         = $AF0C89
=$af0c8a				SP17_ADDY_PTR_M         = $AF0C8A
=$af0c8b				SP17_ADDY_PTR_H         = $AF0C8B
=$af0c8c				SP17_X_POS_L            = $AF0C8C
=$af0c8d				SP17_X_POS_H            = $AF0C8D
=$af0c8e				SP17_Y_POS_L            = $AF0C8E
=$af0c8f				SP17_Y_POS_H            = $AF0C8F
=$af0c90				SP18_CONTROL_REG        = $AF0C90
=$af0c91				SP18_ADDY_PTR_L         = $AF0C91
=$af0c92				SP18_ADDY_PTR_M         = $AF0C92
=$af0c93				SP18_ADDY_PTR_H         = $AF0C93
=$af0c94				SP18_X_POS_L            = $AF0C94
=$af0c95				SP18_X_POS_H            = $AF0C95
=$af0c96				SP18_Y_POS_L            = $AF0C96
=$af0c97				SP18_Y_POS_H            = $AF0C97
=$af0c98				SP19_CONTROL_REG        = $AF0C98
=$af0c99				SP19_ADDY_PTR_L         = $AF0C99
=$af0c9a				SP19_ADDY_PTR_M         = $AF0C9A
=$af0c9b				SP19_ADDY_PTR_H         = $AF0C9B
=$af0c9c				SP19_X_POS_L            = $AF0C9C
=$af0c9d				SP19_X_POS_H            = $AF0C9D
=$af0c9e				SP19_Y_POS_L            = $AF0C9E
=$af0c9f				SP19_Y_POS_H            = $AF0C9F
=$af0ca0				SP20_CONTROL_REG        = $AF0CA0
=$af0ca1				SP20_ADDY_PTR_L         = $AF0CA1
=$af0ca2				SP20_ADDY_PTR_M         = $AF0CA2
=$af0ca3				SP20_ADDY_PTR_H         = $AF0CA3
=$af0ca4				SP20_X_POS_L            = $AF0CA4
=$af0ca5				SP20_X_POS_H            = $AF0CA5
=$af0ca6				SP20_Y_POS_L            = $AF0CA6
=$af0ca7				SP20_Y_POS_H            = $AF0CA7
=$af0ca8				SP21_CONTROL_REG        = $AF0CA8
=$af0ca9				SP21_ADDY_PTR_L         = $AF0CA9
=$af0caa				SP21_ADDY_PTR_M         = $AF0CAA
=$af0cab				SP21_ADDY_PTR_H         = $AF0CAB
=$af0cac				SP21_X_POS_L            = $AF0CAC
=$af0cad				SP21_X_POS_H            = $AF0CAD
=$af0cae				SP21_Y_POS_L            = $AF0CAE
=$af0caf				SP21_Y_POS_H            = $AF0CAF
=$af0cb0				SP22_CONTROL_REG        = $AF0CB0
=$af0cb1				SP22_ADDY_PTR_L         = $AF0CB1
=$af0cb2				SP22_ADDY_PTR_M         = $AF0CB2
=$af0cb3				SP22_ADDY_PTR_H         = $AF0CB3
=$af0cb4				SP22_X_POS_L            = $AF0CB4
=$af0cb5				SP22_X_POS_H            = $AF0CB5
=$af0cb6				SP22_Y_POS_L            = $AF0CB6
=$af0cb7				SP22_Y_POS_H            = $AF0CB7
=$af0cb8				SP23_CONTROL_REG        = $AF0CB8
=$af0cb9				SP23_ADDY_PTR_L         = $AF0CB9
=$af0cba				SP23_ADDY_PTR_M         = $AF0CBA
=$af0cbb				SP23_ADDY_PTR_H         = $AF0CBB
=$af0cbc				SP23_X_POS_L            = $AF0CBC
=$af0cbd				SP23_X_POS_H            = $AF0CBD
=$af0cbe				SP23_Y_POS_L            = $AF0CBE
=$af0cbf				SP23_Y_POS_H            = $AF0CBF
=$af0cc0				SP24_CONTROL_REG        = $AF0CC0
=$af0cc1				SP24_ADDY_PTR_L         = $AF0CC1
=$af0cc2				SP24_ADDY_PTR_M         = $AF0CC2
=$af0cc3				SP24_ADDY_PTR_H         = $AF0CC3
=$af0cc4				SP24_X_POS_L            = $AF0CC4
=$af0cc5				SP24_X_POS_H            = $AF0CC5
=$af0cc6				SP24_Y_POS_L            = $AF0CC6
=$af0cc7				SP24_Y_POS_H            = $AF0CC7
=$af0cc8				SP25_CONTROL_REG        = $AF0CC8
=$af0cc9				SP25_ADDY_PTR_L         = $AF0CC9
=$af0cca				SP25_ADDY_PTR_M         = $AF0CCA
=$af0ccb				SP25_ADDY_PTR_H         = $AF0CCB
=$af0ccc				SP25_X_POS_L            = $AF0CCC
=$af0ccd				SP25_X_POS_H            = $AF0CCD
=$af0cce				SP25_Y_POS_L            = $AF0CCE
=$af0ccf				SP25_Y_POS_H            = $AF0CCF
=$af0cd0				SP26_CONTROL_REG        = $AF0CD0
=$af0cd1				SP26_ADDY_PTR_L         = $AF0CD1
=$af0cd2				SP26_ADDY_PTR_M         = $AF0CD2
=$af0cd3				SP26_ADDY_PTR_H         = $AF0CD3
=$af0cd4				SP26_X_POS_L            = $AF0CD4
=$af0cd5				SP26_X_POS_H            = $AF0CD5
=$af0cd6				SP26_Y_POS_L            = $AF0CD6
=$af0cd7				SP26_Y_POS_H            = $AF0CD7
=$af0cd8				SP27_CONTROL_REG        = $AF0CD8
=$af0cd9				SP27_ADDY_PTR_L         = $AF0CD9
=$af0cda				SP27_ADDY_PTR_M         = $AF0CDA
=$af0cdb				SP27_ADDY_PTR_H         = $AF0CDB
=$af0cdc				SP27_X_POS_L            = $AF0CDC
=$af0cdd				SP27_X_POS_H            = $AF0CDD
=$af0cde				SP27_Y_POS_L            = $AF0CDE
=$af0cdf				SP27_Y_POS_H            = $AF0CDF
=$af0ce0				SP28_CONTROL_REG        = $AF0CE0
=$af0ce1				SP28_ADDY_PTR_L         = $AF0CE1
=$af0ce2				SP28_ADDY_PTR_M         = $AF0CE2
=$af0ce3				SP28_ADDY_PTR_H         = $AF0CE3
=$af0ce4				SP28_X_POS_L            = $AF0CE4
=$af0ce5				SP28_X_POS_H            = $AF0CE5
=$af0ce6				SP28_Y_POS_L            = $AF0CE6
=$af0ce7				SP28_Y_POS_H            = $AF0CE7
=$af0ce8				SP29_CONTROL_REG        = $AF0CE8
=$af0ce9				SP29_ADDY_PTR_L         = $AF0CE9
=$af0cea				SP29_ADDY_PTR_M         = $AF0CEA
=$af0ceb				SP29_ADDY_PTR_H         = $AF0CEB
=$af0cec				SP29_X_POS_L            = $AF0CEC
=$af0ced				SP29_X_POS_H            = $AF0CED
=$af0cee				SP29_Y_POS_L            = $AF0CEE
=$af0cef				SP29_Y_POS_H            = $AF0CEF
=$af0cf0				SP30_CONTROL_REG        = $AF0CF0
=$af0cf1				SP30_ADDY_PTR_L         = $AF0CF1
=$af0cf2				SP30_ADDY_PTR_M         = $AF0CF2
=$af0cf3				SP30_ADDY_PTR_H         = $AF0CF3
=$af0cf4				SP30_X_POS_L            = $AF0CF4
=$af0cf5				SP30_X_POS_H            = $AF0CF5
=$af0cf6				SP30_Y_POS_L            = $AF0CF6
=$af0cf7				SP30_Y_POS_H            = $AF0CF7
=$af0cf8				SP31_CONTROL_REG        = $AF0CF8
=$af0cf9				SP31_ADDY_PTR_L         = $AF0CF9
=$af0cfa				SP31_ADDY_PTR_M         = $AF0CFA
=$af0cfb				SP31_ADDY_PTR_H         = $AF0CFB
=$af0cfc				SP31_X_POS_L            = $AF0CFC
=$af0cfd				SP31_X_POS_H            = $AF0CFD
=$af0cfe				SP31_Y_POS_L            = $AF0CFE
=$af0cff				SP31_Y_POS_H            = $AF0CFF
=$af0d00				SP32_CONTROL_REG        = $AF0D00
=$af0d01				SP32_ADDY_PTR_L         = $AF0D01
=$af0d02				SP32_ADDY_PTR_M         = $AF0D02
=$af0d03				SP32_ADDY_PTR_H         = $AF0D03
=$af0d04				SP32_X_POS_L            = $AF0D04
=$af0d05				SP32_X_POS_H            = $AF0D05
=$af0d06				SP32_Y_POS_L            = $AF0D06
=$af0d07				SP32_Y_POS_H            = $AF0D07
=$af0d08				SP33_CONTROL_REG        = $AF0D08
=$af0d09				SP33_ADDY_PTR_L         = $AF0D09
=$af0d0a				SP33_ADDY_PTR_M         = $AF0D0A
=$af0d0b				SP33_ADDY_PTR_H         = $AF0D0B
=$af0d0c				SP33_X_POS_L            = $AF0D0C
=$af0d0d				SP33_X_POS_H            = $AF0D0D
=$af0d0e				SP33_Y_POS_L            = $AF0D0E
=$af0d0f				SP33_Y_POS_H            = $AF0D0F
=$af0d10				SP34_CONTROL_REG        = $AF0D10
=$af0d11				SP34_ADDY_PTR_L         = $AF0D11
=$af0d12				SP34_ADDY_PTR_M         = $AF0D12
=$af0d13				SP34_ADDY_PTR_H         = $AF0D13
=$af0d14				SP34_X_POS_L            = $AF0D14
=$af0d15				SP34_X_POS_H            = $AF0D15
=$af0d16				SP34_Y_POS_L            = $AF0D16
=$af0d17				SP34_Y_POS_H            = $AF0D17
=$af0d18				SP35_CONTROL_REG        = $AF0D18
=$af0d19				SP35_ADDY_PTR_L         = $AF0D19
=$af0d1a				SP35_ADDY_PTR_M         = $AF0D1A
=$af0d1b				SP35_ADDY_PTR_H         = $AF0D1B
=$af0d1c				SP35_X_POS_L            = $AF0D1C
=$af0d1d				SP35_X_POS_H            = $AF0D1D
=$af0d1e				SP35_Y_POS_L            = $AF0D1E
=$af0d1f				SP35_Y_POS_H            = $AF0D1F
=$af0d20				SP36_CONTROL_REG        = $AF0D20
=$af0d21				SP36_ADDY_PTR_L         = $AF0D21
=$af0d22				SP36_ADDY_PTR_M         = $AF0D22
=$af0d23				SP36_ADDY_PTR_H         = $AF0D23
=$af0d24				SP36_X_POS_L            = $AF0D24
=$af0d25				SP36_X_POS_H            = $AF0D25
=$af0d26				SP36_Y_POS_L            = $AF0D26
=$af0d27				SP36_Y_POS_H            = $AF0D27
=$af0d28				SP37_CONTROL_REG        = $AF0D28
=$af0d29				SP37_ADDY_PTR_L         = $AF0D29
=$af0d2a				SP37_ADDY_PTR_M         = $AF0D2A
=$af0d2b				SP37_ADDY_PTR_H         = $AF0D2B
=$af0d2c				SP37_X_POS_L            = $AF0D2C
=$af0d2d				SP37_X_POS_H            = $AF0D2D
=$af0d2e				SP37_Y_POS_L            = $AF0D2E
=$af0d2f				SP37_Y_POS_H            = $AF0D2F
=$af0d30				SP38_CONTROL_REG        = $AF0D30
=$af0d31				SP38_ADDY_PTR_L         = $AF0D31
=$af0d32				SP38_ADDY_PTR_M         = $AF0D32
=$af0d33				SP38_ADDY_PTR_H         = $AF0D33
=$af0d34				SP38_X_POS_L            = $AF0D34
=$af0d35				SP38_X_POS_H            = $AF0D35
=$af0d36				SP38_Y_POS_L            = $AF0D36
=$af0d37				SP38_Y_POS_H            = $AF0D37
=$af0d38				SP39_CONTROL_REG        = $AF0D38
=$af0d39				SP39_ADDY_PTR_L         = $AF0D39
=$af0d3a				SP39_ADDY_PTR_M         = $AF0D3A
=$af0d3b				SP39_ADDY_PTR_H         = $AF0D3B
=$af0d3c				SP39_X_POS_L            = $AF0D3C
=$af0d3d				SP39_X_POS_H            = $AF0D3D
=$af0d3e				SP39_Y_POS_L            = $AF0D3E
=$af0d3f				SP39_Y_POS_H            = $AF0D3F
=$af0d40				SP40_CONTROL_REG        = $AF0D40
=$af0d41				SP40_ADDY_PTR_L         = $AF0D41
=$af0d42				SP40_ADDY_PTR_M         = $AF0D42
=$af0d43				SP40_ADDY_PTR_H         = $AF0D43
=$af0d44				SP40_X_POS_L            = $AF0D44
=$af0d45				SP40_X_POS_H            = $AF0D45
=$af0d46				SP40_Y_POS_L            = $AF0D46
=$af0d47				SP40_Y_POS_H            = $AF0D47
=$af0d48				SP41_CONTROL_REG        = $AF0D48
=$af0d49				SP41_ADDY_PTR_L         = $AF0D49
=$af0d4a				SP41_ADDY_PTR_M         = $AF0D4A
=$af0d4b				SP41_ADDY_PTR_H         = $AF0D4B
=$af0d4c				SP41_X_POS_L            = $AF0D4C
=$af0d4d				SP41_X_POS_H            = $AF0D4D
=$af0d4e				SP41_Y_POS_L            = $AF0D4E
=$af0d4f				SP41_Y_POS_H            = $AF0D4F
=$af0d50				SP42_CONTROL_REG        = $AF0D50
=$af0d51				SP42_ADDY_PTR_L         = $AF0D51
=$af0d52				SP42_ADDY_PTR_M         = $AF0D52
=$af0d53				SP42_ADDY_PTR_H         = $AF0D53
=$af0d54				SP42_X_POS_L            = $AF0D54
=$af0d55				SP42_X_POS_H            = $AF0D55
=$af0d56				SP42_Y_POS_L            = $AF0D56
=$af0d57				SP42_Y_POS_H            = $AF0D57
=$af0d58				SP43_CONTROL_REG        = $AF0D58
=$af0d59				SP43_ADDY_PTR_L         = $AF0D59
=$af0d5a				SP43_ADDY_PTR_M         = $AF0D5A
=$af0d5b				SP43_ADDY_PTR_H         = $AF0D5B
=$af0d5c				SP43_X_POS_L            = $AF0D5C
=$af0d5d				SP43_X_POS_H            = $AF0D5D
=$af0d5e				SP43_Y_POS_L            = $AF0D5E
=$af0d5f				SP43_Y_POS_H            = $AF0D5F
=$af0d60				SP44_CONTROL_REG        = $AF0D60
=$af0d61				SP44_ADDY_PTR_L         = $AF0D61
=$af0d62				SP44_ADDY_PTR_M         = $AF0D62
=$af0d63				SP44_ADDY_PTR_H         = $AF0D63
=$af0d64				SP44_X_POS_L            = $AF0D64
=$af0d65				SP44_X_POS_H            = $AF0D65
=$af0d66				SP44_Y_POS_L            = $AF0D66
=$af0d67				SP44_Y_POS_H            = $AF0D67
=$af0d68				SP45_CONTROL_REG        = $AF0D68
=$af0d69				SP45_ADDY_PTR_L         = $AF0D69
=$af0d6a				SP45_ADDY_PTR_M         = $AF0D6A
=$af0d6b				SP45_ADDY_PTR_H         = $AF0D6B
=$af0d6c				SP45_X_POS_L            = $AF0D6C
=$af0d6d				SP45_X_POS_H            = $AF0D6D
=$af0d6e				SP45_Y_POS_L            = $AF0D6E
=$af0d6f				SP45_Y_POS_H            = $AF0D6F
=$af0d70				SP46_CONTROL_REG        = $AF0D70
=$af0d71				SP46_ADDY_PTR_L         = $AF0D71
=$af0d72				SP46_ADDY_PTR_M         = $AF0D72
=$af0d73				SP46_ADDY_PTR_H         = $AF0D73
=$af0d74				SP46_X_POS_L            = $AF0D74
=$af0d75				SP46_X_POS_H            = $AF0D75
=$af0d76				SP46_Y_POS_L            = $AF0D76
=$af0d77				SP46_Y_POS_H            = $AF0D77
=$af0d78				SP47_CONTROL_REG        = $AF0D78
=$af0d79				SP47_ADDY_PTR_L         = $AF0D79
=$af0d7a				SP47_ADDY_PTR_M         = $AF0D7A
=$af0d7b				SP47_ADDY_PTR_H         = $AF0D7B
=$af0d7c				SP47_X_POS_L            = $AF0D7C
=$af0d7d				SP47_X_POS_H            = $AF0D7D
=$af0d7e				SP47_Y_POS_L            = $AF0D7E
=$af0d7f				SP47_Y_POS_H            = $AF0D7F
=$af0d80				SP48_CONTROL_REG        = $AF0D80
=$af0d81				SP48_ADDY_PTR_L         = $AF0D81
=$af0d82				SP48_ADDY_PTR_M         = $AF0D82
=$af0d83				SP48_ADDY_PTR_H         = $AF0D83
=$af0d84				SP48_X_POS_L            = $AF0D84
=$af0d85				SP48_X_POS_H            = $AF0D85
=$af0d86				SP48_Y_POS_L            = $AF0D86
=$af0d87				SP48_Y_POS_H            = $AF0D87
=$af0d88				SP49_CONTROL_REG        = $AF0D88
=$af0d89				SP49_ADDY_PTR_L         = $AF0D89
=$af0d8a				SP49_ADDY_PTR_M         = $AF0D8A
=$af0d8b				SP49_ADDY_PTR_H         = $AF0D8B
=$af0d8c				SP49_X_POS_L            = $AF0D8C
=$af0d8d				SP49_X_POS_H            = $AF0D8D
=$af0d8e				SP49_Y_POS_L            = $AF0D8E
=$af0d8f				SP49_Y_POS_H            = $AF0D8F
=$af0d90				SP50_CONTROL_REG        = $AF0D90
=$af0d91				SP50_ADDY_PTR_L         = $AF0D91
=$af0d92				SP50_ADDY_PTR_M         = $AF0D92
=$af0d93				SP50_ADDY_PTR_H         = $AF0D93
=$af0d94				SP50_X_POS_L            = $AF0D94
=$af0d95				SP50_X_POS_H            = $AF0D95
=$af0d96				SP50_Y_POS_L            = $AF0D96
=$af0d97				SP50_Y_POS_H            = $AF0D97
=$af0d98				SP51_CONTROL_REG        = $AF0D98
=$af0d99				SP51_ADDY_PTR_L         = $AF0D99
=$af0d9a				SP51_ADDY_PTR_M         = $AF0D9A
=$af0d9b				SP51_ADDY_PTR_H         = $AF0D9B
=$af0d9c				SP51_X_POS_L            = $AF0D9C
=$af0d9d				SP51_X_POS_H            = $AF0D9D
=$af0d9e				SP51_Y_POS_L            = $AF0D9E
=$af0d9f				SP51_Y_POS_H            = $AF0D9F
=$af0da0				SP52_CONTROL_REG        = $AF0DA0
=$af0da1				SP52_ADDY_PTR_L         = $AF0DA1
=$af0da2				SP52_ADDY_PTR_M         = $AF0DA2
=$af0da3				SP52_ADDY_PTR_H         = $AF0DA3
=$af0da4				SP52_X_POS_L            = $AF0DA4
=$af0da5				SP52_X_POS_H            = $AF0DA5
=$af0da6				SP52_Y_POS_L            = $AF0DA6
=$af0da7				SP52_Y_POS_H            = $AF0DA7
=$af0da8				SP53_CONTROL_REG        = $AF0DA8
=$af0da9				SP53_ADDY_PTR_L         = $AF0DA9
=$af0daa				SP53_ADDY_PTR_M         = $AF0DAA
=$af0dab				SP53_ADDY_PTR_H         = $AF0DAB
=$af0dac				SP53_X_POS_L            = $AF0DAC
=$af0dad				SP53_X_POS_H            = $AF0DAD
=$af0dae				SP53_Y_POS_L            = $AF0DAE
=$af0daf				SP53_Y_POS_H            = $AF0DAF
=$af0db0				SP54_CONTROL_REG        = $AF0DB0
=$af0db1				SP54_ADDY_PTR_L         = $AF0DB1
=$af0db2				SP54_ADDY_PTR_M         = $AF0DB2
=$af0db3				SP54_ADDY_PTR_H         = $AF0DB3
=$af0db4				SP54_X_POS_L            = $AF0DB4
=$af0db5				SP54_X_POS_H            = $AF0DB5
=$af0db6				SP54_Y_POS_L            = $AF0DB6
=$af0db7				SP54_Y_POS_H            = $AF0DB7
=$af0db8				SP55_CONTROL_REG        = $AF0DB8
=$af0db9				SP55_ADDY_PTR_L         = $AF0DB9
=$af0dba				SP55_ADDY_PTR_M         = $AF0DBA
=$af0dbb				SP55_ADDY_PTR_H         = $AF0DBB
=$af0dbc				SP55_X_POS_L            = $AF0DBC
=$af0dbd				SP55_X_POS_H            = $AF0DBD
=$af0dbe				SP55_Y_POS_L            = $AF0DBE
=$af0dbf				SP55_Y_POS_H            = $AF0DBF
=$af0dc0				SP56_CONTROL_REG        = $AF0DC0
=$af0dc1				SP56_ADDY_PTR_L         = $AF0DC1
=$af0dc2				SP56_ADDY_PTR_M         = $AF0DC2
=$af0dc3				SP56_ADDY_PTR_H         = $AF0DC3
=$af0dc4				SP56_X_POS_L            = $AF0DC4
=$af0dc5				SP56_X_POS_H            = $AF0DC5
=$af0dc6				SP56_Y_POS_L            = $AF0DC6
=$af0dc7				SP56_Y_POS_H            = $AF0DC7
=$af0dc8				SP57_CONTROL_REG        = $AF0DC8
=$af0dc9				SP57_ADDY_PTR_L         = $AF0DC9
=$af0dca				SP57_ADDY_PTR_M         = $AF0DCA
=$af0dcb				SP57_ADDY_PTR_H         = $AF0DCB
=$af0dcc				SP57_X_POS_L            = $AF0DCC
=$af0dcd				SP57_X_POS_H            = $AF0DCD
=$af0dce				SP57_Y_POS_L            = $AF0DCE
=$af0dcf				SP57_Y_POS_H            = $AF0DCF
=$af0dd0				SP58_CONTROL_REG        = $AF0DD0
=$af0dd1				SP58_ADDY_PTR_L         = $AF0DD1
=$af0dd2				SP58_ADDY_PTR_M         = $AF0DD2
=$af0dd3				SP58_ADDY_PTR_H         = $AF0DD3
=$af0dd4				SP58_X_POS_L            = $AF0DD4
=$af0dd5				SP58_X_POS_H            = $AF0DD5
=$af0dd6				SP58_Y_POS_L            = $AF0DD6
=$af0dd7				SP58_Y_POS_H            = $AF0DD7
=$af0dd8				SP59_CONTROL_REG        = $AF0DD8
=$af0dd9				SP59_ADDY_PTR_L         = $AF0DD9
=$af0dda				SP59_ADDY_PTR_M         = $AF0DDA
=$af0ddb				SP59_ADDY_PTR_H         = $AF0DDB
=$af0ddc				SP59_X_POS_L            = $AF0DDC
=$af0ddd				SP59_X_POS_H            = $AF0DDD
=$af0dde				SP59_Y_POS_L            = $AF0DDE
=$af0ddf				SP59_Y_POS_H            = $AF0DDF
=$af0de0				SP60_CONTROL_REG        = $AF0DE0
=$af0de1				SP60_ADDY_PTR_L         = $AF0DE1
=$af0de2				SP60_ADDY_PTR_M         = $AF0DE2
=$af0de3				SP60_ADDY_PTR_H         = $AF0DE3
=$af0de4				SP60_X_POS_L            = $AF0DE4
=$af0de5				SP60_X_POS_H            = $AF0DE5
=$af0de6				SP60_Y_POS_L            = $AF0DE6
=$af0de7				SP60_Y_POS_H            = $AF0DE7
=$af0de8				SP61_CONTROL_REG        = $AF0DE8
=$af0de9				SP61_ADDY_PTR_L         = $AF0DE9
=$af0dea				SP61_ADDY_PTR_M         = $AF0DEA
=$af0deb				SP61_ADDY_PTR_H         = $AF0DEB
=$af0dec				SP61_X_POS_L            = $AF0DEC
=$af0ded				SP61_X_POS_H            = $AF0DED
=$af0dee				SP61_Y_POS_L            = $AF0DEE
=$af0def				SP61_Y_POS_H            = $AF0DEF
=$af0df0				SP62_CONTROL_REG        = $AF0DF0
=$af0df1				SP62_ADDY_PTR_L         = $AF0DF1
=$af0df2				SP62_ADDY_PTR_M         = $AF0DF2
=$af0df3				SP62_ADDY_PTR_H         = $AF0DF3
=$af0df4				SP62_X_POS_L            = $AF0DF4
=$af0df5				SP62_X_POS_H            = $AF0DF5
=$af0df6				SP62_Y_POS_L            = $AF0DF6
=$af0df7				SP62_Y_POS_H            = $AF0DF7
=$af0df8				SP63_CONTROL_REG        = $AF0DF8
=$af0df9				SP63_ADDY_PTR_L         = $AF0DF9
=$af0dfa				SP63_ADDY_PTR_M         = $AF0DFA
=$af0dfb				SP63_ADDY_PTR_H         = $AF0DFB
=$af0dfc				SP63_X_POS_L            = $AF0DFC
=$af0dfd				SP63_X_POS_H            = $AF0DFD
=$af0dfe				SP63_Y_POS_L            = $AF0DFE
=$af0dff				SP63_Y_POS_H            = $AF0DFF

;******  Return to file: src\C256/vicky_def.s


;******  Return to file: src\C256/mmap_c256.s

=$00					BASIC_BANK = $00            ; Memory bank for default purposes
=$004c00				IOBUF = $004C00             ; A buffer for I/O operations
=$004d00				ARRIDXBUF = $004D00         ; The array index buffer used for array references
=$004e00				TEMPBUF = $004E00           ; Temporary buffer for string processing, etc.
=$004f00				INPUTBUF = $004F00          ; Starting address of the line input buffer (one page)
=$005000				RETURN_BOT = $005000        ; Starting address of the return stack
=$005fff				RETURN_TOP = $005FFF        ; Ending address of the return stack
=$006000				ARGUMENT_BOT = $006000      ; Starting address of the argument stack
=$006fff				ARGUMENT_TOP = $006FFF      ; Ending address of the argument stack
=$007000				OPERATOR_BOT = $007000      ; Starting address of the operator stack
=$007fff				OPERATOR_TOP = $007FFF      ; Ending address of the operator stack
=$b00000				VRAM = $B00000              ; Start of video RAM
=$010000				LOADBLOCK = $010000         ; File loading will start here
=$360000				BASIC_BOT := $360000         ; Starting point for BASIC programs
=$37ffff				HEAP_TOP := $37FFFF          ; Starting point of the heap

;******  Return to file: src\memorymap.s

=$00ffe6				VBRK = $00FFE6          ; Vector for the native-mode BRK vector
=$3ad000				DATA_BLOCK = *
=$000800				GLOBAL_VARS = *
>0800					BIP         .dword ?    ; Pointer to the current byte in the current BASIC program
>0804					BIPPREV     .dword ?    ; Pointer to the previous bytein the current BASIC program
>0808					INDEX       .dword ?    ; A temporary pointer
>080c					SCRATCH     .dword ?    ; A temporary scratch variable
>0810					SCRATCH2    .dword ?    ; A temporary scratch variable
>0814					            .word  ?	; Need a few more bits for BCD conversion
>0816					STRPTR      .dword ?    ; A temporary pointer for strings
>081a					CURLINE     .dword ?    ; Pointer to the current input line needing tokenization
>081e					CURTOKLEN   .byte ?     ; Length of the text of the current token
>081f					ARGUMENTSP  .word ?     ; Pointer to the top of the argument stack
>0821					OPERATORSP  .word ?     ; Pointer to the top of the operator stack
>0823					ARGUMENT1   .dword ?    ; Argument 1 for expression calculations
>0827					ARGTYPE1    .byte ?     ; Type code for argument 1 (integer, float, string)
>0828					SIGN1       .byte ?     ; Temporary sign marker for argument 1
>0829					ARGUMENT2   .dword ?    ; Argument 2 for expression calculations
>082d					ARGTYPE2    .byte ?     ; Type code for argument 2 (integer, float, string)
>082e					SIGN2       .byte ?     ; Temporary sign marker for argument 1
>082f					JMP16PTR    .word ?     ; Pointer for 16-bit indirect jumps (within BASIC816's code base)
>0831					GOSUBDEPTH  .word ?     ; Number of GOSUBs on the stack
>0833					RETURNSP    .word ?     ; Pointer to the top of the return stack
>0835					SKIPNEST    .byte ?     ; Flag to indicate if token seeking should respect nesting (MSB set if so)
>0836					NESTING     .byte ?     ; Counter of the depth of lexical nesting for FOR/NEXT, DO/LOOP
>0837					TARGETTOK   .byte ?     ; When searching for a token, TARGETTOK is the token to find
>0838					DATABIP     .dword ?    ; Pointer to the next data element for READ statements
>083c					DATALINE    .dword ?    ; Pointer to the current line for a DATA statement
>0840					SAVEBIP     .dword ?    ; Spot to save BIP temporarily
>0844					SAVELINE    .dword ?    ; Spot to save CURLINE temporarily
=$000848				MONITOR_VARS = *
>0848					MCMDADDR    .long ?     ;3 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
>084b					MCMP_TEXT   .long ?     ;3 Bytes Address of symbol being evaluated for COMPARE routine
>084e					MCMP_LEN    .word ?     ;2 Bytes Length of symbol being evaluated for COMPARE routine
>0850					MCMD        .long ?     ;3 Bytes Address of the current command/function string
>0853					MCMD_LEN    .word ?     ;2 Bytes Length of the current command/function string
>0855					MARG1       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command
>0859					MARG2       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>085d					MARG3       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0861					MARG4       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0865					MARG5       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0869					MARG6       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>086d					MARG7       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0871					MARG8       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0875					MARG9       .dword ?    ;4 Bytes First command argument.
>0879					MARG_LEN    .byte ?     ;1 Byte count of the number of arguments passed
>087a					MCURSOR     .dword ?    ;4 Bytes Pointer to the current memory location for disassembly, memory dump, etc.
>087e					MLINEBUF    .fill 17    ;17 Byte buffer for dumping memory (TODO: could be moved to a general string scratch area)
>088f					MCOUNT      .long ?     ;2 Byte counter
>0892					MTEMP       .dword ?    ;4 Bytes of temporary space
>0896					MCPUSTAT    .byte ?     ;1 Byte to represent what the disassembler thinks the processor MX bits are
>0897					MADDR_MODE  .byte ?     ;1 Byte address mode found by the assembler
>0898					MPARSEDNUM  .dword ?    ;4 Bytes to store a parsed number
>089c					MMNEMONIC   .word ?     ;2 Byte address of mnemonic found by the assembler
>089e					MTEMPPTR    .dword ?    ;4 Byte temporary pointer
>08a2					MJUMPINST   .byte ?     ;1 Byte JSL opcode
>08a3					MJUMPADDR   .long ?     ;3 Byte address for JSL
=$000823				MANTISSA1 = ARGUMENT1
=$000826				EXPONENT1 = ARGUMENT1+3

;******  Return to file: src\basic816.s


;******  Processing file: src\macros.s


;******  Return to file: src\basic816.s

.3a0000	5c d4 89 3a	jmp $3a89d4	COLDBOOT        JML START               ; Entry point to boot up BASIC from scratch
.3a0004	5c e6 6f 3a	jmp $3a6fe6	MONITOR         JML IMONITOR            ; Entry point to the machine language monitor
.3a0008	5c 33 27 3a	jmp $3a2733	READLINE        JML IREADLINE           ; Wait for the user to enter a line of text (for programming input)
.3a000c	5c ba 02 3a	jmp $3a02ba	SCRCOPYLINE     JML ISCRCPYLINE         ; Copy the line on the screen the user just input to INPUTBUF
.3a0010	5c 58 00 3a	jmp $3a0058	INPUTLINE       JML IINPUTLINE          ; Read a single line of text from the user, and copy it to TEMPBUF (for INPUT statement)
.3a0014	5c b8 00 3a	jmp $3a00b8	GETKEY          JML IGETKEY             ; Wait for a keypress by the user and return the ASCII code in A
.3a0018	5c d4 03 3a	jmp $3a03d4	PRINTC          JML IPRINTC             ; Print the character in A to the console
.3a001c	5c 5e 02 3a	jmp $3a025e	SHOWCURSOR      JML ISHOWCURSOR         ; Set cursor visibility: A=0, hide... A<>0, show.
.3a0020	5c 79 02 3a	jmp $3a0279	CURSORXY        JML ICURSORXY           ; Set the position of the cursor to (X, Y)
.3a0024	5c 80 02 3a	jmp $3a0280	CLSCREEN        JML ICLSCREEN           ; Clear the screen

;******  Processing file: src\bios.s


;******  Processing file: src\membuffers.s

>08a6					OBUFFER     .long ?     ; Pointer to the current text memory buffer for output
>08a9					OBUFFSIZE   .word ?     ; Maximum size of output text memory buffer
>08ab					OBUFFIDX    .word ?     ; Index into the current output buffer
>08ad					IBUFFER     .long ?     ; Pointer to the current text memory buffer for input
>08b0					IBUFFSIZE   .word ?     ; Number of bytes written to the buffer
>08b2					IBUFFIDX    .word ?     ; Index into the current input buffer (next available character)
.3a0028					OBUFF_PUTC
.3a0028	0b		phd		                PHD
.3a0029	08		php		                PHP
.3a002a	08		php		            PHP
.3a002b	c2 20		rep #$20	            REP #$20
.3a002d	48		pha		            PHA
.3a002e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0031	5b		tcd		            TCD
.3a0032	68		pla		            PLA
.3a0033	28		plp		            PLP
.3a0034	e2 20		sep #$20	            SEP #$20
.3a0036	85 b5		sta $08b5	                STA SAVE_A
.3a0038	c2 20		rep #$20	            REP #$20
.3a003a	a5 a6		lda $08a6	                LDA OBUFFER
.3a003c	d0 06		bne $3a0044	                BNE has_buffer
.3a003e	e2 20		sep #$20	            SEP #$20
.3a0040	a5 a8		lda $08a8	                LDA OBUFFER+2
.3a0042	f0 11		beq $3a0055	                BEQ done
.3a0044					has_buffer
.3a0044	c2 10		rep #$10	            REP #$10
.3a0046	a4 ab		ldy $08ab	                LDY OBUFFIDX        ; Check to make sure there is room
.3a0048	c4 a9		cpy $08a9	                CPY OBUFFSIZE
.3a004a	f0 09		beq $3a0055	                BEQ done            ; If not, exit silently
.3a004c	e2 20		sep #$20	            SEP #$20
.3a004e	a5 b5		lda $08b5	                LDA SAVE_A
.3a0050	97 a6		sta [$08a6],y	                STA [OBUFFER],Y     ; Write the character to the buffer
.3a0052	c8		iny		                INY                 ; Increment the index
.3a0053	84 ab		sty $08ab	                STY OBUFFIDX
.3a0055	28		plp		done            PLP
.3a0056	2b		pld		                PLD
.3a0057	60		rts		            RTS

;******  Return to file: src\bios.s


;******  Processing file: src\C256/io_c256.s


;******  Processing file: src\C256/kernel_c256.s

=$00104c				FK_GETCHW           = $00104c ; Get a character from the input channel. Waits until data received. A=0 and Carry=1 if no data is wating
=$001018				FK_PUTC             = $001018 ; Print a character to the currently selected channel
=$00101c				FK_PUTS             = $00101C ; Print a string to the currently selected channel
=$001080				FK_PRINTAH          = $001080 ; Prints hex value in A. Printed value is 2 wide if M flag is 1, 4 wide if M=0
=$001084				FK_LOCATE           = $001084 ; Reposition the cursor to row Y column X
=$001078				FK_IPRINTH          = $001078 ; Print a HEX string
=$00103c				FK_SETOUT           = $00103c ; Select an output channel
=$00112c				FK_SETSIZES         = $00112C ; Set the text screen size variables based on the border and screen resolution.
=$0010f0				FK_OPEN             = $0010F0 ; open a file for reading/writing/creating
=$0010f4				FK_CREATE           = $0010F4 ; create a new file
=$0010f8				FK_CLOSE            = $0010F8 ; close a file (make sure last cluster is written)
=$0010fc				FK_WRITE            = $0010FC ; write the current cluster to the file
=$001100				FK_READ             = $001100 ; read the next cluster from the file
=$001104				FK_DELETE           = $001104 ; delete a file / directory
=$001108				FK_DIROPEN          = $001108 ; open a directory and seek the first directory entry
=$00110c				FK_DIRNEXT          = $00110C ; seek to the next directory of an open directory
=$001110				FK_DIRREAD          = $001110 ; Read the directory entry for the specified file
=$001114				FK_DIRWRITE         = $001114 ; Write any changes in the current directory cluster back to the drive
=$001118				FK_LOAD             = $001118 ; load a binary file into memory, supports multiple file formats
=$00111c				FK_SAVE             = $00111C ; Save memory to a binary file
=$001124				FK_RUN              = $001124 ; Load and run an executable binary file
=$001130				FK_COPY             = $001130 ; Copy a file
=$001120				FK_CMDBLOCK         = $001120 ; Send a command to a block device
=$00113c				FK_TESTBREAK        = $00113C ; Check if BREAK was pressed recently by the user (C is set if true, clear if false)
=0					CHAN_CONSOLE = 0
=1					CHAN_COM1 = 1
=2					CHAN_COM2 = 2

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/RTC_inc.s

=$af0800				RTC_SEC       = $AF0800 ;Seconds Register
=$af0801				RTC_SEC_ALARM = $AF0801 ;Seconds Alarm Register
=$af0802				RTC_MIN       = $AF0802 ;Minutes Register
=$af0803				RTC_MIN_ALARM = $AF0803 ;Minutes Alarm Register
=$af0804				RTC_HRS       = $AF0804 ;Hours Register
=$af0805				RTC_HRS_ALARM = $AF0805 ;Hours Alarm Register
=$af0806				RTC_DAY       = $AF0806 ;Day Register
=$af0807				RTC_DAY_ALARM = $AF0807 ;Day Alarm Register
=$af0808				RTC_DOW       = $AF0808 ;Day of Week Register
=$af0809				RTC_MONTH     = $AF0809 ;Month Register
=$af080a				RTC_YEAR      = $AF080A ;Year Register
=$af080b				RTC_RATES     = $AF080B ;Rates Register
=$af080c				RTC_ENABLE    = $AF080C ;Enables Register
=$af080d				RTC_FLAGS     = $AF080D ;Flags Register
=$af080e				RTC_CTRL      = $AF080E ;Control Register
=$af080f				RTC_CENTURY   = $AF080F ;Century Register

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/keyboard.s


;******  Processing file: src\C256/keyboard_def.s

=$af1064				STATUS_PORT 	        =	$AF1064
=$af1060				KBD_OUT_BUF 	        =	$AF1060
=$af1060				KBD_INPT_BUF	        = $AF1060
=$af1064				KBD_CMD_BUF		        = $AF1064
=$af1060				KBD_DATA_BUF	        = $AF1060
=$af1060				PORT_A			          =	$AF1060
=$af1061				PORT_B			          =	$AF1061
=$01					OUT_BUF_FULL  =	$01
=$02					INPT_BUF_FULL	=	$02
=$04					SYS_FLAG		  =	$04
=$08					CMD_DATA		  =	$08
=$10					KEYBD_INH     =	$10
=$20					TRANS_TMOUT	  =	$20
=$40					RCV_TMOUT		  =	$40
=$80					PARITY_EVEN		=	$80
=$10					INH_KEYBOARD	=	$10
=$ae					KBD_ENA			  =	$AE
=$ad					KBD_DIS			  =	$AD
=$f1					KB_MENU			  =	$F1
=$f4					KB_ENABLE		  =	$F4
=$f7					KB_MAKEBREAK  =	$F7
=$fe					KB_ECHO			  =	$FE
=$ff					KB_RESET		  =	$FF
=$ed					KB_LED_CMD		=	$ED
=$aa					KB_OK			    =	$AA
=$fa					KB_ACK			  =	$FA
=$ff					KB_OVERRUN		=	$FF
=$fe					KB_RESEND		  =	$FE
=$f0					KB_BREAK		  =	$F0
=$10					KB_FA			    =	$10
=$20					KB_FE			    =	$20
=$40					KB_PR_LED		  =	$40
=$01					KB_SCROLL_LOCK      = $01
=$02					KB_NUM_LOCK         = $02
=$04					KB_CAPS_LOCK        = $04
=2					ANSI_IN_INS = 2     ; ANSI input code for INSERT
=3					ANSI_IN_DEL = 3     ; ANSI input code for DELETE
=24					ANSI_IN_F12 = 24    ; ANSI input code for F12
=8					ANSI_IN_CTRL = 8    ; ANSI input modifier flag for CTRL

;******  Return to file: src\C256/keyboard.s

.3a0058					IINPUTLINE
.3a0058	08		php		                PHP
.3a0059	c2 10		rep #$10	            REP #$10
.3a005b	e2 20		sep #$20	            SEP #$20
.3a005d	a9 01		lda #$01	                LDA #1              ; Show the cursor
.3a005f	20 1c 00	jsr $3a001c	            JSR SHOWCURSOR
.3a0062	a2 00 00	ldx #$0000	                LDX #0
.3a0065	a9 00		lda #$00	                LDA #0
.3a0067	9f 00 4c 00	sta $004c00,x	zero_loop       STA @lIOBUF,X
.3a006b	e8		inx		                INX
.3a006c	e0 00 01	cpx #$0100	                CPX #$100
.3a006f	d0 f6		bne $3a0067	                BNE zero_loop
.3a0071	a2 00 00	ldx #$0000	                LDX #0
.3a0074					getchar
.3a0074	20 14 00	jsr $3a0014	            JSR GETKEY
.3a0077	c9 0d		cmp #$0d	                CMP #CHAR_CR        ; Got a CR?
.3a0079	d0 03		bne $3a007e	                BNE not_cr
.3a007b	4c b1 00	jmp $3a00b1	                JMP endofline       ; Yes: we're done
.3a007e					not_cr
.3a007e	c9 08		cmp #$08	not_right       CMP #CHAR_BS        ; Is it a backspace?
.3a0080	d0 1a		bne $3a009c	                BNE not_bs
.3a0082	e0 00 00	cpx #$0000	                CPX #0              ; Are we at the beginning of the line?
.3a0085	f0 ed		beq $3a0074	                BEQ getchar         ; yes: ignore the backspace
.3a0087	da		phx		                PHX                 ; Save the cursor position
.3a0088	bf 01 4c 00	lda $004c01,x	clr_loop        LDA @lIOBUF+1,X     ; Get the character above
.3a008c	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the current position
.3a0090	f0 06		beq $3a0098	                BEQ done_clr        ; If we copied a NUL, we're done copying
.3a0092	e8		inx		                INX                 ; Otherwise, keep copying down
.3a0093	e0 ff 00	cpx #$00ff	                CPX #$FF            ; Until we're at the end of the buffer
.3a0096	d0 f0		bne $3a0088	                BNE clr_loop
.3a0098	fa		plx		done_clr        PLX                 ; Restore the cursor position
.3a0099	ca		dex		                DEX                 ; No: move the cursor left
.3a009a	80 0e		bra $3a00aa	                BRA print_bs        ; And print the backspace
.3a009c	c9 20		cmp #$20	not_bs          CMP #$20            ; Is it in range 00 -- 1F?
.3a009e	90 d4		bcc $3a0074	                BLT getchar         ; Yes: ignore it
.3a00a0	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the input buffer
.3a00a4	e8		inx		                INX                 ; Move the cursor forward
.3a00a5					echo
.3a00a5	20 18 00	jsr $3a0018	            JSR PRINTC
.3a00a8	80 ca		bra $3a0074	                BRA getchar         ; And get another...
.3a00aa	a9 08		lda #$08	print_bs        LDA #CHAR_BS        ; Backspace character...
.3a00ac	20 18 00	jsr $3a0018	            JSR PRINTC
.3a00af	80 c3		bra $3a0074	                BRA getchar         ; And get another...
.3a00b1	a9 00		lda #$00	endofline       LDA #0              ; Hide the cursor
.3a00b3	20 1c 00	jsr $3a001c	            JSR SHOWCURSOR
.3a00b6	28		plp		                PLP
.3a00b7	60		rts		            RTS
.3a00b8					IGETKEY
.3a00b8	da		phx		                PHX
.3a00b9	5a		phy		                PHY
.3a00ba	8b		phb		                PHB
.3a00bb	0b		phd		                PHD
.3a00bc	08		php		                PHP
.3a00bd	22 4c 10 00	jsl $00104c	                JSL FK_GETCHW
.3a00c1	28		plp		                PLP
.3a00c2	2b		pld		                PLD
.3a00c3	ab		plb		                PLB
.3a00c4	7a		ply		                PLY
.3a00c5	fa		plx		                PLX
.3a00c6	60		rts		            RTS
=0					GK_ST_INIT = 0      ; GETKEYE state: initial
=1					GK_ST_ESC = 1       ; GETKEYE state: ESC seen
=2					GK_ST_CSI = 2       ; GETKEYE state: CSI "ESC[" seen
=3					GK_ST_CODE = 3      ; GETKEYE state: We're at the command code in the sequence
=4					GK_ST_MODS = 4      ; GETKEYE state: We're at the modifier code in the sequence
.3a00c7					SEND_ANSI
.3a00c7	08		php		                PHP
.3a00c8	e2 30		sep #$30	            SEP #$30
.3a00ca	48		pha		                PHA
.3a00cb	a9 1b		lda #$1b	                LDA #CHAR_ESC           ; Print ESC
.3a00cd	20 18 00	jsr $3a0018	            JSR PRINTC
.3a00d0	a9 5b		lda #$5b	                LDA #'['                ; Print [
.3a00d2	20 18 00	jsr $3a0018	            JSR PRINTC
.3a00d5	68		pla		                PLA                     ; Print the command code
.3a00d6	20 18 00	jsr $3a0018	            JSR PRINTC
.3a00d9	28		plp		                PLP
.3a00da	60		rts		            RTS
.3a00db					GETKEYE
.3a00db	0b		phd		                PHD
.3a00dc	8b		phb		                PHB
.3a00dd	08		php		                PHP
.3a00de	08		php		            PHP
.3a00df	e2 20		sep #$20	            SEP #$20
.3a00e1	48		pha		            PHA
.3a00e2	a9 00		lda #$00	            LDA #0
.3a00e4	48		pha		            PHA
.3a00e5	ab		plb		            PLB
.3a00e6	68		pla		            PLA
.3a00e7	28		plp		            PLP
.3a00e8	08		php		            PHP
.3a00e9	c2 20		rep #$20	            REP #$20
.3a00eb	48		pha		            PHA
.3a00ec	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a00ef	5b		tcd		            TCD
.3a00f0	68		pla		            PLA
.3a00f1	28		plp		            PLP
.3a00f2					locals
>0001					l_character     .byte ?                 ; The character returned by the input stream
>0002					l_state         .byte ?                 ; Current state of the input parser
>0003					l_code          .byte ?                 ; Code number for any escaped input sequence
>0004					l_modifiers     .byte ?                 ; Modifier bit field for any escaped input sequence
.3a00f2	c2 20		rep #$20	            REP #$20
.3a00f4	3b		tsc		            TSC
.3a00f5	38		sec		            SEC
.3a00f6	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.3a00f9	1b		tcs		            TCS
.3a00fa	e2 20		sep #$20	            SEP #$20
.3a00fc	a9 00		lda #$00	get_reset       LDA #0                  ; Initialize state, code, and modifiers
.3a00fe	83 02		sta $02,s	                STA l_state
.3a0100	83 03		sta $03,s	                STA l_code
.3a0102	83 04		sta $04,s	                STA l_modifiers
.3a0104					loop
.3a0104	20 14 00	jsr $3a0014	            JSR GETKEY
.3a0107	c9 00		cmp #$00	                CMP #0                  ; Is it 0?
.3a0109	f0 f9		beq $3a0104	                BEQ loop                ; Yes: keep waiting
.3a010b	83 01		sta $01,s	                STA l_character         ; Save the character
.3a010d	a3 02		lda $02,s	                LDA l_state             ; What is the current state?
.3a010f	d0 35		bne $3a0146	                BNE chk_st_esc
.3a0111	a3 01		lda $01,s	                LDA l_character         ; Get the character back
.3a0113	c9 08		cmp #$08	                CMP #CHAR_BS            ; Is it a backspace?
.3a0115	d0 0a		bne $3a0121	                BNE not_bs
.3a0117	20 18 00	jsr $3a0018	            JSR PRINTC
.3a011a	a9 50		lda #$50	                LDA #'P'
.3a011c	20 c7 00	jsr $3a00c7	            JSR SEND_ANSI
.3a011f	80 e3		bra $3a0104	                BRA loop                ; And keep waiting for a keypress
.3a0121	c9 0d		cmp #$0d	not_bs          CMP #CHAR_CR            ; Is it a carriage return?
.3a0123	f0 0a		beq $3a012f	                BEQ send                ; Yes: print and return it
.3a0125	c9 1b		cmp #$1b	                CMP #CHAR_ESC           ; Is it ESC?
.3a0127	d0 06		bne $3a012f	                BNE send                ; No: just print it out
.3a0129	a9 01		lda #$01	                LDA #GK_ST_ESC          ; Yes: move to the ESC state
.3a012b	83 02		sta $02,s	                STA l_state
.3a012d	80 d5		bra $3a0104	                BRA loop                ; And get the next character in the sequence
.3a012f					send
.3a012f	20 18 00	jsr $3a0018	            JSR PRINTC
.3a0132	a3 01		lda $01,s	done            LDA l_character         ; Save the character so we can return it
.3a0134	85 0c		sta $080c	                STA SCRATCH
.3a0136	c2 20		rep #$20	            REP #$20
.3a0138	3b		tsc		            TSC
.3a0139	18		clc		            CLC
.3a013a	69 04 00	adc #$0004	            ADC #SIZE(locals)
.3a013d	1b		tcs		            TCS
.3a013e	e2 20		sep #$20	            SEP #$20
.3a0140	a5 0c		lda $080c	                LDA SCRATCH             ; Restore the character we're returning
.3a0142	28		plp		                PLP
.3a0143	2b		pld		                PLD
.3a0144	ab		plb		                PLB
.3a0145	60		rts		            RTS
.3a0146	c9 01		cmp #$01	chk_st_esc      CMP #GK_ST_ESC          ; Are we in the ESC state?
.3a0148	d0 10		bne $3a015a	                BNE chk_st_csi          ; No: check to see if we're in CSI state
.3a014a	a3 01		lda $01,s	                LDA l_character         ; Get the character
.3a014c	c9 5b		cmp #$5b	                CMP #'['                ; Is it "["?
.3a014e	f0 03		beq $3a0153	                BEQ go_st_csi           ; Yes: go to the CSI state
.3a0150	82 a9 ff	brl $3a00fc	                BRL get_reset           ; Reset the state machine and keep reading characters
.3a0153	a9 02		lda #$02	go_st_csi       LDA #GK_ST_CSI          ; Yes: move to the CSI state
.3a0155	83 02		sta $02,s	                STA l_state
.3a0157	82 aa ff	brl $3a0104	                BRL loop
.3a015a	c9 02		cmp #$02	chk_st_csi      CMP #GK_ST_CSI          ; Are we in the CSI state?
.3a015c	d0 29		bne $3a0187	                BNE chk_st_code         ; No: check to see if we're in the code state
.3a015e	a3 01		lda $01,s	                LDA l_character         ; Check the character
.3a0160	c9 41		cmp #$41	                CMP #'A'                ; Is it in 'A'..'D'?
.3a0162	90 0c		bcc $3a0170	                BLT not_letter
.3a0164	c9 45		cmp #$45	                CMP #'D'+1
.3a0166	b0 08		bcs $3a0170	                BGE not_letter
.3a0168	a3 01		lda $01,s	                LDA l_character         ; Yes: it's a cursor key, send the sequence to the screen
.3a016a	20 c7 00	jsr $3a00c7	            JSR SEND_ANSI
.3a016d	82 8c ff	brl $3a00fc	                BRL get_reset           ; Reset the state machine and keep reading characters
.3a0170	c9 30		cmp #$30	not_letter      CMP #'0'                ; Is it in range '0'..'9'?
.3a0172	90 10		bcc $3a0184	                BLT not_csi_digit
.3a0174	c9 3a		cmp #$3a	                CMP #'9'+1
.3a0176	b0 0c		bcs $3a0184	                BGE not_csi_digit       ; No: handle it being invalid
.3a0178	38		sec		                SEC                     ; Yes: convert to a value
.3a0179	e9 30		sbc #$30	                SBC #'0'
.3a017b	83 03		sta $03,s	                STA l_code              ; And save it to the code variable
.3a017d	a9 03		lda #$03	                LDA #GK_ST_CODE         ; Move to the CODE state
.3a017f	83 02		sta $02,s	                STA l_state
.3a0181	82 80 ff	brl $3a0104	                BRL loop
.3a0184	82 75 ff	brl $3a00fc	not_csi_digit   BRL get_reset           ; Bad sequence: reset and keep reading characters
.3a0187	c9 03		cmp #$03	chk_st_code     CMP #GK_ST_CODE         ; Is it the CODE state?
.3a0189	d0 41		bne $3a01cc	                BNE chk_st_mods         ; No: check to see if it's MODIFIERS
.3a018b	a3 01		lda $01,s	                LDA l_character         ; Check the character
.3a018d	c9 30		cmp #$30	                CMP #'0'                ; Is it in the range '0'..'9'
.3a018f	90 29		bcc $3a01ba	                BLT not_digits_2
.3a0191	c9 3a		cmp #$3a	                CMP #'9'+1
.3a0193	b0 25		bcs $3a01ba	                BGE not_digits_2
.3a0195	a3 03		lda $03,s	                LDA l_code              ; Multiply l_code by 2
.3a0197	8f 00 01 00	sta $000100	                STA @l UNSIGNED_MULT_A_LO
.3a019b	a9 00		lda #$00	                LDA #0
.3a019d	8f 01 01 00	sta $000101	                STA @l UNSIGNED_MULT_A_HI
.3a01a1	8f 03 01 00	sta $000103	                STA @l UNSIGNED_MULT_B_HI
.3a01a5	a9 0a		lda #$0a	                LDA #10
.3a01a7	8f 02 01 00	sta $000102	                STA @l UNSIGNED_MULT_B_LO
.3a01ab	a3 01		lda $01,s	                LDA l_character         ; Convert the digit to a number
.3a01ad	38		sec		                SEC
.3a01ae	e9 30		sbc #$30	                SBC #'0'
.3a01b0	18		clc		                CLC                     ; And add to l_code
.3a01b1	6f 04 01 00	adc $000104	                ADC @l UNSIGNED_MULT_AL_LO
.3a01b5	83 03		sta $03,s	                STA l_code
.3a01b7	82 4a ff	brl $3a0104	                BRL loop                ; And keep processing the sequence
.3a01ba	c9 3b		cmp #$3b	not_digits_2    CMP #';'                ; Is it the semicolon?
.3a01bc	d0 07		bne $3a01c5	                BNE not_semi
.3a01be	a9 04		lda #$04	                LDA #GK_ST_MODS         ; Yes: Move to the MODIFIERS state
.3a01c0	83 02		sta $02,s	                STA l_state
.3a01c2	82 3f ff	brl $3a0104	                BRL loop
.3a01c5	c9 7e		cmp #$7e	not_semi        CMP #'~'                ; No: Is it the tilda?
.3a01c7	f0 40		beq $3a0209	                BEQ end_sequence        ; Yes: we've gotten the end of the sequence
.3a01c9	82 30 ff	brl $3a00fc	                BRL get_reset           ; No: we've got a bad sequence... for now just reset and keep looping
.3a01cc	c9 04		cmp #$04	chk_st_mods     CMP #GK_ST_MODS         ; Are we in the MODIFIERS state?
.3a01ce	f0 03		beq $3a01d3	                BEQ do_mods
.3a01d0	82 5f ff	brl $3a0132	                BRL done                ; No: we're done
.3a01d3	a3 01		lda $01,s	do_mods         LDA l_character         ; Check the character
.3a01d5	c9 30		cmp #$30	                CMP #'0'                ; Is it in the range '0'..'9'
.3a01d7	90 29		bcc $3a0202	                BLT not_digits_3
.3a01d9	c9 3a		cmp #$3a	                CMP #'9'+1
.3a01db	b0 25		bcs $3a0202	                BGE not_digits_3
.3a01dd	a3 04		lda $04,s	                LDA l_modifiers         ; Multiply l_modifiers by 2
.3a01df	8f 00 01 00	sta $000100	                STA @l UNSIGNED_MULT_A_LO
.3a01e3	a9 00		lda #$00	                LDA #0
.3a01e5	8f 01 01 00	sta $000101	                STA @l UNSIGNED_MULT_A_HI
.3a01e9	8f 03 01 00	sta $000103	                STA @l UNSIGNED_MULT_B_HI
.3a01ed	a9 0a		lda #$0a	                LDA #10
.3a01ef	8f 02 01 00	sta $000102	                STA @l UNSIGNED_MULT_B_LO
.3a01f3	a3 01		lda $01,s	                LDA l_character         ; Convert the digit to a number
.3a01f5	38		sec		                SEC
.3a01f6	e9 30		sbc #$30	                SBC #'0'
.3a01f8	18		clc		                CLC                     ; And add to l_modifiers
.3a01f9	6f 04 01 00	adc $000104	                ADC @l UNSIGNED_MULT_AL_LO
.3a01fd	83 04		sta $04,s	                STA l_modifiers
.3a01ff	82 02 ff	brl $3a0104	                BRL loop                ; And keep processing the sequence
.3a0202	c9 7e		cmp #$7e	not_digits_3    CMP #'~'                ; No: Is it the tilda?
.3a0204	f0 03		beq $3a0209	                BEQ end_sequence        ; Yes: we've gotten the end of the sequence
.3a0206	82 f3 fe	brl $3a00fc	                BRL get_reset           ; No: we've got a bad sequence... for now just reset and keep looping
.3a0209	a3 03		lda $03,s	end_sequence    LDA l_code              ; Get the code
.3a020b	c9 02		cmp #$02	                CMP #ANSI_IN_INS        ; Is it INSERT?
.3a020d	f0 0b		beq $3a021a	                BEQ do_ins              ; Yes: process the insert
.3a020f	c9 03		cmp #$03	                CMP #ANSI_IN_DEL        ; Is it DELETE?
.3a0211	f0 0b		beq $3a021e	                BEQ do_del              ; Yes: process the delete
.3a0213	c9 18		cmp #$18	                CMP #ANSI_IN_F12        ; Is it F12?
.3a0215	f0 0f		beq $3a0226	                BEQ do_f12              ; Yes: process the F12 key
.3a0217	82 e2 fe	brl $3a00fc	                BRL get_reset           ; Code is not one we handle, just return
.3a021a	a9 40		lda #$40	do_ins          LDA #'@'                ; Send the ANSI ICH command
.3a021c	80 02		bra $3a0220	                BRA snd_ansi
.3a021e	a9 50		lda #$50	do_del          LDA #'P'                ; Send the ANSI DCH command
.3a0220					snd_ansi
.3a0220	20 c7 00	jsr $3a00c7	            JSR SEND_ANSI
.3a0223	82 d6 fe	brl $3a00fc	                BRL get_reset           ; Reset and keep getting characters
.3a0226	a5 d2		lda $08d2	do_f12          LDA STATE               ; Check the state
.3a0228	d0 10		bne $3a023a	                BNE skip_f12            ; If we're running, ignore the F12
.3a022a	a3 04		lda $04,s	                LDA l_modifiers         ; Check to make sure it's CTRL-F12
.3a022c	c9 08		cmp #$08	                CMP #ANSI_IN_CTRL       ; Modifier flag for CTRL
.3a022e	d0 0a		bne $3a023a	                BNE skip_f12
.3a0230	a9 1b		lda #$1b	                LDA #CHAR_ESC           ; Send ESC_ (APC) to show the credits
.3a0232	20 18 00	jsr $3a0018	            JSR PRINTC
.3a0235	a9 5f		lda #$5f	                LDA #'_'
.3a0237	20 18 00	jsr $3a0018	            JSR PRINTC
.3a023a	82 bf fe	brl $3a00fc	skip_f12        BRL get_reset           ; And reset the state machine

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/screen.s

.3a023d					ENSURETEXT
.3a023d	08		php		            PHP
.3a023e	e2 20		sep #$20	            SEP #$20
.3a0240	af 00 00 af	lda $af0000	            LDA @l MASTER_CTRL_REG_L            ; Get the current display mode
.3a0244	89 3c		bit #$3c	            BIT #Mstr_Ctrl_Graph_Mode_En | Mstr_Ctrl_Bitmap_En | Mstr_Ctrl_TileMap_En | Mstr_Ctrl_Sprite_En
.3a0246	f0 08		beq $3a0250	            BEQ textonly                        ; If not, make sure text is enabled
.3a0248					overlay
.3a0248	09 03		ora #$03	            ORA #Mstr_Ctrl_Text_Mode_En | Mstr_Ctrl_Text_Overlay
.3a024a	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.3a024e	80 0c		bra $3a025c	            BRA done
.3a0250					textonly
.3a0250	09 01		ora #$01	            ORA #Mstr_Ctrl_Text_Mode_En
.3a0252	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.3a0256	a9 00		lda #$00	            LDA #CHAN_CONSOLE                   ; Make sure we're writing to the main screen
.3a0258	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.3a025c	28		plp		done        PLP
.3a025d	60		rts		            RTS
.3a025e					ISHOWCURSOR
.3a025e	08		php		            PHP
.3a025f	e2 20		sep #$20	            SEP #$20
.3a0261	c9 00		cmp #$00	            CMP #0
.3a0263	f0 08		beq $3a026d	            BEQ hide
.3a0265	af 10 00 af	lda $af0010	show        LDA @lVKY_TXT_CURSOR_CTRL_REG
.3a0269	09 01		ora #$01	            ORA #Vky_Cursor_Enable
.3a026b	80 06		bra $3a0273	            BRA setit
.3a026d	af 10 00 af	lda $af0010	hide        LDA @lVKY_TXT_CURSOR_CTRL_REG
.3a0271	29 fe		and #$fe	            AND #~Vky_Cursor_Enable
.3a0273	8f 10 00 af	sta $af0010	setit       STA @lVKY_TXT_CURSOR_CTRL_REG
.3a0277	28		plp		            PLP
.3a0278	60		rts		            RTS
.3a0279					ICURSORXY
.3a0279	08		php		            PHP
.3a027a	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.3a027e	28		plp		            PLP
.3a027f	60		rts		            RTS
.3a0280					ICLSCREEN
.3a0280	48		pha		            PHA
.3a0281	da		phx		            PHX
.3a0282	5a		phy		            PHY
.3a0283	0b		phd		            PHD
.3a0284	08		php		            PHP
.3a0285	e2 20		sep #$20	            SEP #$20
.3a0287	c2 10		rep #$10	            REP #$10
.3a0289	a2 00 00	ldx #$0000	            LDX #0
.3a028c	a9 20		lda #$20	loop        LDA #$20
.3a028e	9f 00 a0 af	sta $afa000,x	            STA @lCS_TEXT_MEM_PTR,X     ; Write a space in the text cell
.3a0292	af 1e 00 00	lda $00001e	            LDA @lCURCOLOR
.3a0296	9f 00 c0 af	sta $afc000,x	            STA @lCS_COLOR_MEM_PTR,X    ; Set the color to green on black
.3a029a	e8		inx		            INX                         ; Move to the next character cell
.3a029b	e0 00 20	cpx #$2000	            CPX #$2000
.3a029e	d0 ec		bne $3a028c	            BNE loop
.3a02a0	08		php		            PHP
.3a02a1	c2 20		rep #$20	            REP #$20
.3a02a3	48		pha		            PHA
.3a02a4	a9 00 00	lda #$0000	            LDA #0
.3a02a7	5b		tcd		            TCD
.3a02a8	68		pla		            PLA
.3a02a9	28		plp		            PLP
.3a02aa	a2 00 00	ldx #$0000	            LDX #0                      ; Set cursor to upper-left corner
.3a02ad	a0 00 00	ldy #$0000	            LDY #0
.3a02b0	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.3a02b4	28		plp		            PLP
.3a02b5	2b		pld		            PLD
.3a02b6	7a		ply		            PLY
.3a02b7	fa		plx		            PLX
.3a02b8	68		pla		            PLA
.3a02b9	60		rts		            RTS
.3a02ba					ISCRCPYLINE
.3a02ba	da		phx		            PHX
.3a02bb	5a		phy		            PHY
.3a02bc	0b		phd		            PHD
.3a02bd	08		php		            PHP
.3a02be	08		php		            PHP
.3a02bf	c2 20		rep #$20	            REP #$20
.3a02c1	48		pha		            PHA
.3a02c2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a02c5	5b		tcd		            TCD
.3a02c6	68		pla		            PLA
.3a02c7	28		plp		            PLP
.3a02c8	c2 30		rep #$30	            REP #$30
.3a02ca	af 0c 00 00	lda $00000c	            LDA @l SCREENBEGIN      ; Set INDEX to the first byte of the text screen
.3a02ce	85 08		sta $0808	            STA INDEX
.3a02d0	e2 20		sep #$20	            SEP #$20
.3a02d2	af 0e 00 00	lda $00000e	            LDA @l SCREENBEGIN+2
.3a02d6	c2 20		rep #$20	            REP #$20
.3a02d8	29 ff 00	and #$00ff	            AND #$00FF
.3a02db	85 0a		sta $080a	            STA INDEX+2
.3a02dd	af 11 00 00	lda $000011	            LDA @l COLS_PER_LINE    ; Calculate the offset to the current line
.3a02e1	8f 08 01 00	sta $000108	            STA @l M1_OPERAND_A
.3a02e5	af 1c 00 00	lda $00001c	            LDA @l CURSORY
.3a02e9	3a		dec a		            DEC A
.3a02ea	8f 0a 01 00	sta $00010a	            STA @l M1_OPERAND_B
.3a02ee	18		clc		            CLC                     ; And add it to INDEX
.3a02ef	a5 08		lda $0808	            LDA INDEX
.3a02f1	6f 0c 01 00	adc $00010c	            ADC @l M1_RESULT
.3a02f5	85 08		sta $0808	            STA INDEX
.3a02f7	a5 0a		lda $080a	            LDA INDEX+2
.3a02f9	69 00 00	adc #$0000	            ADC #0
.3a02fc	85 0a		sta $080a	            STA INDEX+2
.3a02fe	e2 20		sep #$20	            SEP #$20
.3a0300	af 0f 00 00	lda $00000f	            LDA @l COLS_VISIBLE
.3a0304	85 8f		sta $088f	            STA MCOUNT
.3a0306	a0 00 00	ldy #$0000	            LDY #0
.3a0309	a2 00 00	ldx #$0000	            LDX #0
.3a030c	b7 08		lda [$0808],y	copy_loop   LDA [INDEX],Y           ; Copy a byte from the screen to the input buffer
.3a030e	9f 00 4f 00	sta $004f00,x	            STA @l INPUTBUF,X
.3a0312	e8		inx		            INX
.3a0313	c8		iny		            INY
.3a0314	c4 8f		cpy $088f	            CPY MCOUNT
.3a0316	d0 f4		bne $3a030c	            BNE copy_loop
.3a0318	af 0f 00 00	lda $00000f	            LDA @l COLS_VISIBLE     ; Starting from the end of the line...
.3a031c	3a		dec a		            DEC A
.3a031d	aa		tax		            TAX
.3a031e	bf 00 4f 00	lda $004f00,x	trim_loop   LDA @l INPUTBUF,X       ; Replace spaces at the end with NULLs
.3a0322	c9 20		cmp #$20	            CMP #CHAR_SP
.3a0324	d0 09		bne $3a032f	            BNE done
.3a0326	a9 00		lda #$00	            LDA #0
.3a0328	9f 00 4f 00	sta $004f00,x	            STA @l INPUTBUF,X
.3a032c	ca		dex		            DEX
.3a032d	10 ef		bpl $3a031e	            BPL trim_loop
.3a032f	28		plp		done        PLP
.3a0330	2b		pld		            PLD
.3a0331	7a		ply		            PLY
.3a0332	fa		plx		            PLX
.3a0333	60		rts		            RTS

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/gabe_defs.s

=$afe880				GABE_MSTR_CTRL      = $AFE880
=$01					GABE_CTRL_PWR_LED   = $01     ; Controls the LED in the Front of the case (Next to the reset button)
=$02					GABE_CTRL_SDC_LED   = $02     ; Controls the LED in the Front of the Case (Next to SDCard)
=$04					GABE_CTRL_STS_LED0  = $04     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$08					GABE_CTRL_STS_LED1  = $08     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$10					GABE_CTRL_BUZZER    = $10     ; Controls the Buzzer
=$80					GABE_CTRL_WRM_RST   = $80     ; Warm Reset (needs to Setup other registers)
=$afe881				GABE_LED_FLASH_CTRL = $AFE881  ; Flashing LED Control
=$01					GABE_LED0_FLASH_CTRL = $01     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$02					GABE_LED1_FLASH_CTRL = $02     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED1 to manually control)
=$10					GABE_LD0_FLASH_FRQ0   = $10     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$20					GABE_LD0_FLASH_FRQ1   = $20     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$40					GABE_LD1_FLASH_FRQ0   = $40     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$80					GABE_LD1_FLASH_FRQ1   = $80     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$afe882				GABE_RST_AUTH0      = $AFE882 ; Must Contain the BYTE $AD for Reset to Activate
=$afe883				GABE_RST_AUTH1      = $AFE883 ; Must Contain the BYTE $DE for Reset to Activate
=$afe884				GABE_RNG_DAT_LO     = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_DAT_HI     = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe884				GABE_RNG_SEED_LO    = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_SEED_HI    = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe886				GABE_RNG_STAT       = $AFE886 ;
=$80					GABE_RNG_LFSR_DONE  = $80     ; indicates that Output = SEED Database
=$afe886				GABE_RNG_CTRL       = $AFE886 ;
=$01					GABE_RNG_CTRL_EN    = $01     ; Enable the LFSR BLOCK_LEN
=$02					GABE_RNG_CTRL_DV    = $02     ; After Setting the Seed Value, Toggle that Bit for it be registered
=$afe887				GABE_SYS_STAT       = $AFE887 ;
=$01					GABE_SYS_STAT_MID0  = $01     ; Machine ID -- LSB
=$02					GABE_SYS_STAT_MID1  = $02     ; Machine ID --
=$04					GABE_SYS_STAT_MID2  = $04     ; Machine ID -- MSB
=$10					GABE_SYS_STAT_EXP   = $10     ; if Zero, there is an Expansion Card Preset
=$40					GABE_SYS_STAT_CPUA  = $40     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$80					GABE_SYS_STAT_CPUX  = $80     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$afe88a				GABE_SUBVERSION_LO  = $AFE88A
=$afe88b				GABE_SUBVERSION_HI  = $AFE88B
=$afe88c				GABE_VERSION_LO     = $AFE88C
=$afe88d				GABE_VERSION_HI     = $AFE88D
=$afe88e				GABE_MODEL_LO       = $AFE88E
=$afe88f				GABE_MODEL_HI       = $AFE88F

;******  Return to file: src\C256/io_c256.s

=32					BORDER_WIDTH = 32               ; The width of the border (when it is on)
=72					TEXT_COLS_WB = 72               ; Number of columns of text with the border enabled
=52					TEXT_ROWS_WB = 52               ; Number of rows of text with the border enabled
=80					TEXT_COLS_WOB = 80              ; Number of columns of text with no border enabled
=60					TEXT_ROWS_WOB = 60              ; Number of rows of text with no border enabled
.3a0334					INITIO
.3a0334	e2 20		sep #$20	            SEP #$20
.3a0336	a2 00 00	ldx #$0000	            LDX #0              ; Clear all the sprite control shadow registers
.3a0339	a9 00		lda #$00	            LDA #0
.3a033b	9f 18 f0 3a	sta $3af018,x	sp_loop     STA GS_SP_CONTROL,X
.3a033f	e8		inx		            INX
.3a0340	e0 40 00	cpx #$0040	            CPX #SP_MAX
.3a0343	d0 f6		bne $3a033b	            BNE sp_loop
.3a0345	a9 80		lda #$80	            LDA #DEV_SCREEN
.3a0347	8f b4 08 00	sta $0008b4	            STA @lBCONSOLE
.3a034b	e2 20		sep #$20	            SEP #$20
.3a034d	a9 00		lda #$00	            LDA #0                  ; Clear the lock key flags
.3a034f	8f 89 0f 00	sta $000f89	            STA @lKEYBOARD_LOCKS
.3a0353	a9 00		lda #$00	            LDA #0
.3a0355	8f 00 02 af	sta $af0200	            STA @l TL0_CONTROL_REG
.3a0359	8f 0c 02 af	sta $af020c	            STA @l TL1_CONTROL_REG
.3a035d	8f 18 02 af	sta $af0218	            STA @l TL2_CONTROL_REG
.3a0361	8f 24 02 af	sta $af0224	            STA @l TL3_CONTROL_REG
.3a0365					done
.3a0365	60		rts		            RTS
.3a0366					SCREEN_PUTC
.3a0366	08		php		            PHP
.3a0367	e2 20		sep #$20	            SEP #$20
.3a0369	48		pha		            PHA
.3a036a	48		pha		            PHA
.3a036b	a9 00		lda #$00	            LDA #CHAN_CONSOLE       ; Switch to the console device
.3a036d	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.3a0371	68		pla		            PLA
.3a0372	22 18 10 00	jsl $001018	            JSL FK_PUTC
.3a0376	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.3a037a	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.3a037c	d0 f8		bne $3a0376	            BNE loop                ; Yes: wait until it's released
.3a037e	68		pla		            PLA
.3a037f	28		plp		            PLP
.3a0380	60		rts		            RTS
.3a0381					UART_PUTC
.3a0381	08		php		            PHP
.3a0382	e2 20		sep #$20	            SEP #$20
.3a0384	48		pha		            PHA
.3a0385	48		pha		            PHA
.3a0386	a9 01		lda #$01	            LDA #CHAN_COM1          ; Switch to COM1
.3a0388	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.3a038c	68		pla		            PLA
.3a038d	22 18 10 00	jsl $001018	            JSL FK_PUTC
.3a0391	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.3a0395	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.3a0397	d0 f8		bne $3a0391	            BNE loop                ; Yes: wait until it's released
.3a0399	68		pla		            PLA
.3a039a	28		plp		            PLP
.3a039b	60		rts		            RTS
.3a039c					PRINTCR
.3a039c	08		php		            PHP
.3a039d	c2 20		rep #$20	            REP #$20
.3a039f	48		pha		            PHA
.3a03a0	e2 20		sep #$20	            SEP #$20
.3a03a2	a9 0d		lda #$0d	            LDA #CHAR_CR
.3a03a4	20 18 00	jsr $3a0018	            JSR PRINTC
.3a03a7	c2 20		rep #$20	            REP #$20
.3a03a9	68		pla		            PLA
.3a03aa	28		plp		            PLP
.3a03ab	60		rts		            RTS
.3a03ac					PRINTH
.3a03ac	08		php		            PHP
.3a03ad	22 78 10 00	jsl $001078	            JSL FK_IPRINTH
.3a03b1	28		plp		            PLP
.3a03b2	60		rts		            RTS

;******  Return to file: src\bios.s

=10					LINES_PER_PAGE = 10     ; The number of lines to print on a page before pausing
=$80					DEV_SCREEN = $80        ; Use the screen and keyboard for the console device
=$40					DEV_UART = $40          ; Use UART for console device
=$20					DEV_BUFFER = $20        ; Use the current text memory buffer for output or input
>08b4					BCONSOLE    .byte ?     ; Device for BASIC console
>08b5					SAVE_A      .byte ?     ; Save spot for the A register
>08b6					LINECOUNT   .byte ?     ; Counter for new lines to support pagination
.3a03b3					PAGINATE
.3a03b3	08		php		            PHP
.3a03b4	0b		phd		            PHD
.3a03b5	08		php		            PHP
.3a03b6	c2 20		rep #$20	            REP #$20
.3a03b8	48		pha		            PHA
.3a03b9	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a03bc	5b		tcd		            TCD
.3a03bd	68		pla		            PLA
.3a03be	28		plp		            PLP
.3a03bf	e2 20		sep #$20	            SEP #$20
.3a03c1	a5 b6		lda $08b6	            LDA LINECOUNT           ; Check the line count
.3a03c3	1a		inc a		            INC A
.3a03c4	85 b6		sta $08b6	            STA LINECOUNT
.3a03c6	cf 13 00 00	cmp $000013	            CMP @l LINES_VISIBLE
.3a03ca	90 05		bcc $3a03d1	            BLT done                ; If < limit, just return
.3a03cc	20 14 00	jsr $3a0014	            JSR GETKEY
.3a03cf	64 b6		stz $08b6	            STZ LINECOUNT           ; And reset the line count
.3a03d1	2b		pld		done        PLD
.3a03d2	28		plp		            PLP
.3a03d3	60		rts		            RTS
.3a03d4					IPRINTC
.3a03d4	da		phx		            PHX
.3a03d5	5a		phy		            PHY
.3a03d6	0b		phd		            PHD
.3a03d7	08		php		            PHP
.3a03d8	08		php		            PHP
.3a03d9	c2 20		rep #$20	            REP #$20
.3a03db	48		pha		            PHA
.3a03dc	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a03df	5b		tcd		            TCD
.3a03e0	68		pla		            PLA
.3a03e1	28		plp		            PLP
.3a03e2	e2 20		sep #$20	            SEP #$20
.3a03e4	c2 10		rep #$10	            REP #$10
.3a03e6	8f b5 08 00	sta $0008b5	            STA @lSAVE_A
.3a03ea	af b4 08 00	lda $0008b4	chk_out     LDA @lBCONSOLE      ; Check to see if we should send to an output buffer
.3a03ee	29 20		and #$20	            AND #DEV_BUFFER
.3a03f0	f0 07		beq $3a03f9	            BEQ check_scrn      ; No... move on to the hardware screen
.3a03f2	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.3a03f6	20 28 00	jsr $3a0028	            JSR OBUFF_PUTC
.3a03f9	af b4 08 00	lda $0008b4	check_scrn  LDA @lBCONSOLE
.3a03fd	29 80		and #$80	            AND #DEV_SCREEN     ; Check to see if the screen is selected
.3a03ff	f0 07		beq $3a0408	            BEQ send_uart
.3a0401	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.3a0405	20 66 03	jsr $3a0366	            JSR SCREEN_PUTC
.3a0408	af b4 08 00	lda $0008b4	send_uart   LDA @lBCONSOLE
.3a040c	29 40		and #$40	            AND #DEV_UART       ; Check to see if the UART is active
.3a040e	f0 14		beq $3a0424	            BEQ done
.3a0410	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.3a0414	20 81 03	jsr $3a0381	            JSR UART_PUTC
.3a0417	af b5 08 00	lda $0008b5	            LDA @lSAVE_A        ; If sending a CR to the serial port
.3a041b	c9 0d		cmp #$0d	            CMP #CHAR_CR
.3a041d	d0 05		bne $3a0424	            BNE done
.3a041f	a9 0a		lda #$0a	            LDA #CHAR_LF        ; Send a linefeed after
.3a0421	20 81 03	jsr $3a0381	            JSR UART_PUTC
.3a0424	28		plp		done        PLP
.3a0425	2b		pld		            PLD
.3a0426	7a		ply		            PLY
.3a0427	fa		plx		            PLX
.3a0428	60		rts		            RTS
.3a0429					PRINTS
.3a0429	08		php		            PHP
.3a042a	e2 20		sep #$20	            SEP #$20
.3a042c	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.3a042f	f0 06		beq $3a0437	            BEQ done
.3a0431	20 18 00	jsr $3a0018	            JSR PRINTC
.3a0434	e8		inx		            INX
.3a0435	80 f5		bra $3a042c	            BRA loop
.3a0437	28		plp		done        PLP
.3a0438	60		rts		            RTS
.3a0439					PRHEXW
.3a0439	08		php		            PHP
.3a043a	c2 20		rep #$20	            REP #$20
.3a043c	48		pha		            PHA
.3a043d	48		pha		            PHA
.3a043e	4a		lsr a		            LSR A
.3a043f	4a		lsr a		            LSR A
.3a0440	4a		lsr a		            LSR A
.3a0441	4a		lsr a		            LSR A
.3a0442	4a		lsr a		            LSR A
.3a0443	4a		lsr a		            LSR A
.3a0444	4a		lsr a		            LSR A
.3a0445	4a		lsr a		            LSR A
.3a0446	20 53 04	jsr $3a0453	            JSR PRHEXB
.3a0449	68		pla		            PLA
.3a044a	29 ff 00	and #$00ff	            AND #$00FF
.3a044d	20 53 04	jsr $3a0453	            JSR PRHEXB
.3a0450	68		pla		            PLA
.3a0451	28		plp		            PLP
.3a0452	60		rts		            RTS
.3a0453					PRHEXB
.3a0453	08		php		            PHP
.3a0454	c2 20		rep #$20	            REP #$20
.3a0456	48		pha		            PHA
.3a0457	e2 20		sep #$20	            SEP #$20
.3a0459	48		pha		            PHA
.3a045a	4a		lsr a		            LSR A
.3a045b	4a		lsr a		            LSR A
.3a045c	4a		lsr a		            LSR A
.3a045d	4a		lsr a		            LSR A
.3a045e	20 6a 04	jsr $3a046a	            JSR PRHEXN
.3a0461	68		pla		            PLA
.3a0462	20 6a 04	jsr $3a046a	            JSR PRHEXN
.3a0465	c2 20		rep #$20	            REP #$20
.3a0467	68		pla		            PLA
.3a0468	28		plp		            PLP
.3a0469	60		rts		            RTS
.3a046a					PRHEXN
.3a046a	08		php		            PHP
.3a046b	c2 30		rep #$30	            REP #$30
.3a046d	da		phx		            PHX
.3a046e	29 0f 00	and #$000f	            AND #$000F
.3a0471	aa		tax		            TAX
.3a0472	bf 00 d0 3a	lda $3ad000,x	            LDA @lHEXDIGITS,X
.3a0476	20 18 00	jsr $3a0018	            JSR PRINTC
.3a0479	fa		plx		            PLX
.3a047a	28		plp		            PLP
.3a047b	60		rts		            RTS
>3ad000	30 31 32 33 34 35 36 37		HEXDIGITS   .text "0123456789ABCDEF"
>3ad008	38 39 41 42 43 44 45 46

;******  Return to file: src\basic816.s


;******  Processing file: src\utilities.s

.3a047c					PRTRACE
.3a047c	08		php		            PHP
.3a047d	c2 30		rep #$30	            REP #$30
.3a047f	48		pha		            PHA
.3a0480	da		phx		            PHX
.3a0481	5a		phy		            PHY
.3a0482	8b		phb		            PHB
.3a0483	0b		phd		            PHD
.3a0484	c2 30		rep #$30	            REP #$30
.3a0486	a3 0b		lda $0b,s	            LDA 11,S        ; Get the return address
.3a0488	18		clc		calc_addr   CLC
.3a0489	69 03 00	adc #$0003	            ADC #3          ; Add 3 to skip over the following branch
.3a048c	aa		tax		            TAX
.3a048d	e2 20		sep #$20	            SEP #$20
.3a048f	a9 3a		lda #$3a	            LDA #`PRTRACE
.3a0491	48		pha		            PHA
.3a0492	ab		plb		            PLB
.3a0493	bd 00 00	lda $0000,x	pr_loop     LDA #0,B,X
.3a0496	f0 06		beq $3a049e	            BEQ done
.3a0498	20 66 03	jsr $3a0366	            JSR SCREEN_PUTC
.3a049b	e8		inx		            INX
.3a049c	80 f5		bra $3a0493	            BRA pr_loop
.3a049e					done
.3a049e	c2 30		rep #$30	            REP #$30
.3a04a0	2b		pld		            PLD
.3a04a1	ab		plb		            PLB
.3a04a2	7a		ply		            PLY
.3a04a3	fa		plx		            PLX
.3a04a4	68		pla		            PLA
.3a04a5	28		plp		            PLP
.3a04a6	60		rts		            RTS
.3a04a7					ISALPHA
.3a04a7	08		php		            PHP
.3a04a8	e2 20		sep #$20	            SEP #$20
.3a04aa	c9 5b		cmp #$5b	            CMP #'Z'+1
.3a04ac	b0 04		bcs $3a04b2	            BGE not_upper
.3a04ae	c9 41		cmp #$41	            CMP #'A'
.3a04b0	b0 0b		bcs $3a04bd	            BGE is_alpha
.3a04b2	c9 7b		cmp #$7b	not_upper   CMP #'z'+1
.3a04b4	b0 04		bcs $3a04ba	            BGE not_alpha
.3a04b6	c9 61		cmp #$61	            CMP #'a'
.3a04b8	b0 03		bcs $3a04bd	            BGE is_alpha
.3a04ba					not_alpha
.3a04ba	28		plp		            PLP
.3a04bb	18		clc		            CLC
.3a04bc	60		rts		            RTS
.3a04bd					is_alpha
.3a04bd	28		plp		            PLP
.3a04be	38		sec		            SEC
.3a04bf	60		rts		            RTS
.3a04c0					ISNUMERAL
.3a04c0	08		php		            PHP
.3a04c1	e2 20		sep #$20	            SEP #$20
.3a04c3	c9 3a		cmp #$3a	            CMP #'9'+1
.3a04c5	b0 04		bcs $3a04cb	            BGE ret_false
.3a04c7	c9 30		cmp #$30	            CMP #'0'
.3a04c9	b0 03		bcs $3a04ce	            BGE ret_true
.3a04cb	28		plp		ret_false   PLP
.3a04cc	18		clc		            CLC
.3a04cd	60		rts		            RTS
.3a04ce	28		plp		ret_true    PLP
.3a04cf	38		sec		            SEC
.3a04d0	60		rts		            RTS
.3a04d1					ISHEX
.3a04d1	08		php		            PHP
.3a04d2	e2 20		sep #$20	            SEP #$20
.3a04d4	c9 3a		cmp #$3a	            CMP #'9'+1
.3a04d6	b0 04		bcs $3a04dc	            BGE chk_lca2f
.3a04d8	c9 30		cmp #$30	            CMP #'0'
.3a04da	b0 13		bcs $3a04ef	            BGE ret_true
.3a04dc	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.3a04de	b0 04		bcs $3a04e4	            BGE chk_uca2f
.3a04e0	c9 61		cmp #$61	            CMP #'a'
.3a04e2	b0 0b		bcs $3a04ef	            BGE ret_true
.3a04e4	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.3a04e6	b0 04		bcs $3a04ec	            BGE ret_false
.3a04e8	c9 41		cmp #$41	            CMP #'A'
.3a04ea	b0 03		bcs $3a04ef	            BGE ret_true
.3a04ec	28		plp		ret_false   PLP
.3a04ed	18		clc		            CLC
.3a04ee	60		rts		            RTS
.3a04ef	28		plp		ret_true    PLP
.3a04f0	38		sec		            SEC
.3a04f1	60		rts		            RTS
.3a04f2					HEX2BIN
.3a04f2	08		php		            PHP
.3a04f3	e2 20		sep #$20	            SEP #$20
.3a04f5	c9 3a		cmp #$3a	            CMP #'9'+1          ; Check to see if '0'..'9'
.3a04f7	b0 04		bcs $3a04fd	            BGE chk_lca2f
.3a04f9	c9 30		cmp #$30	            CMP #'0'
.3a04fb	b0 12		bcs $3a050f	            BGE conv_09         ; Yes: convert it
.3a04fd	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.3a04ff	b0 04		bcs $3a0505	            BGE chk_uca2f
.3a0501	c9 61		cmp #$61	            CMP #'a'
.3a0503	b0 0f		bcs $3a0514	            BGE conv_lcaf
.3a0505	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.3a0507	b0 04		bcs $3a050d	            BGE done
.3a0509	c9 41		cmp #$41	            CMP #'A'
.3a050b	b0 09		bcs $3a0516	            BGE conv_ucaf
.3a050d	28		plp		done        PLP
.3a050e	60		rts		            RTS
.3a050f	38		sec		conv_09     SEC                 ; Convert digits '0'..'9'
.3a0510	e9 30		sbc #$30	            SBC #'0'
.3a0512	80 f9		bra $3a050d	            BRA done
.3a0514	29 df		and #$df	conv_lcaf   AND #%11011111      ; Convert to upper case
.3a0516	38		sec		conv_ucaf   SEC
.3a0517	e9 37		sbc #$37	            SBC #'A'-10         ; Convert 'A'..'F'
.3a0519	80 f2		bra $3a050d	            BRA done
.3a051b					TOUPPERA
.3a051b	08		php		            PHP
.3a051c	e2 20		sep #$20	            SEP #$20
.3a051e	c9 7b		cmp #$7b	            CMP #'z'+1
.3a0520	b0 06		bcs $3a0528	            BCS done
.3a0522	c9 61		cmp #$61	            CMP #'a'
.3a0524	90 02		bcc $3a0528	            BCC done
.3a0526	29 df		and #$df	            AND #%11011111
.3a0528	28		plp		done        PLP
.3a0529	60		rts		            RTS
.3a052a					TOUPPER
.3a052a	08		php		            PHP
.3a052b	e2 20		sep #$20	            SEP #$20
.3a052d	c2 10		rep #$10	            REP #$10
.3a052f	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.3a0532	f0 09		beq $3a053d	            BEQ done
.3a0534	20 1b 05	jsr $3a051b	            JSR TOUPPERA
.3a0537	9d 00 00	sta $0000,x	            STA #0,B,X
.3a053a	e8		inx		continue    INX
.3a053b	80 f2		bra $3a052f	            BRA loop
.3a053d	28		plp		done        PLP
.3a053e	60		rts		            RTS
.3a053f					MULINT10
.3a053f	08		php		                PHP
.3a0540	0b		phd		                PHD
.3a0541	08		php		            PHP
.3a0542	c2 20		rep #$20	            REP #$20
.3a0544	48		pha		            PHA
.3a0545	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0548	5b		tcd		            TCD
.3a0549	68		pla		            PLA
.3a054a	28		plp		            PLP
.3a054b	c2 20		rep #$20	            REP #$20
.3a054d	48		pha		                PHA
.3a054e	06 23		asl $0823	                ASL ARGUMENT1           ; 7 -- 20 -- 74
.3a0550	26 25		rol $0825	                ROL ARGUMENT1+2         ; 7
.3a0552	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.3a0554	85 0c		sta $080c	                STA SCRATCH             ; 4
.3a0556	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.3a0558	85 0e		sta $080e	                STA SCRATCH+2           ; 4
.3a055a	06 0c		asl $080c	                ASL SCRATCH             ; 7 -- 28
.3a055c	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.3a055e	06 0c		asl $080c	                ASL SCRATCH             ; 7
.3a0560	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.3a0562	18		clc		                CLC                     ; 2 -- 26
.3a0563	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.3a0565	65 0c		adc $080c	                ADC SCRATCH             ; 4
.3a0567	85 23		sta $0823	                STA ARGUMENT1           ; 4
.3a0569	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.3a056b	65 0e		adc $080e	                ADC SCRATCH+2           ; 4
.3a056d	85 25		sta $0825	                STA ARGUMENT1+2         ; 4
.3a056f	68		pla		                PLA
.3a0570	2b		pld		                PLD
.3a0571	28		plp		                PLP
.3a0572	60		rts		            RTS
.3a0573					DIVINT10
.3a0573	08		php		                PHP
.3a0574	0b		phd		                PHD
.3a0575	08		php		            PHP
.3a0576	c2 20		rep #$20	            REP #$20
.3a0578	48		pha		            PHA
.3a0579	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a057c	5b		tcd		            TCD
.3a057d	68		pla		            PLA
.3a057e	28		plp		            PLP
.3a057f	c2 20		rep #$20	            REP #$20
.3a0581	a5 23		lda $0823	                LDA ARGUMENT1
.3a0583	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.3a0587	a9 0a 00	lda #$000a	                LDA #10
.3a058a	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.3a058e	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.3a0592	85 23		sta $0823	                STA ARGUMENT1
.3a0594	64 25		stz $0825	                STZ ARGUMENT1+2
.3a0596	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.3a059a	85 29		sta $0829	                STA ARGUMENT2
.3a059c	64 2b		stz $082b	                STZ ARGUMENT2+2
.3a059e	e2 20		sep #$20	            SEP #$20
.3a05a0	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a05a2	85 27		sta $0827	                STA ARGTYPE1
.3a05a4	85 2d		sta $082d	                STA ARGTYPE2
.3a05a6	2b		pld		                PLD
.3a05a7	28		plp		                PLP
.3a05a8	60		rts		            RTS
.3a05a9					DIVINT100
.3a05a9	08		php		                PHP
.3a05aa	0b		phd		                PHD
.3a05ab	08		php		            PHP
.3a05ac	c2 20		rep #$20	            REP #$20
.3a05ae	48		pha		            PHA
.3a05af	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a05b2	5b		tcd		            TCD
.3a05b3	68		pla		            PLA
.3a05b4	28		plp		            PLP
.3a05b5	c2 20		rep #$20	            REP #$20
.3a05b7	a5 23		lda $0823	                LDA ARGUMENT1
.3a05b9	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.3a05bd	a9 64 00	lda #$0064	                LDA #100
.3a05c0	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.3a05c4	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.3a05c8	85 23		sta $0823	                STA ARGUMENT1
.3a05ca	64 25		stz $0825	                STZ ARGUMENT1+2
.3a05cc	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.3a05d0	85 29		sta $0829	                STA ARGUMENT2
.3a05d2	64 2b		stz $082b	                STZ ARGUMENT2+2
.3a05d4	e2 20		sep #$20	            SEP #$20
.3a05d6	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a05d8	85 27		sta $0827	                STA ARGTYPE1
.3a05da	85 2d		sta $082d	                STA ARGTYPE2
.3a05dc	2b		pld		                PLD
.3a05dd	28		plp		                PLP
.3a05de	60		rts		            RTS
.3a05df					IS_ARG1_Z
.3a05df	08		php		                PHP
.3a05e0	c2 20		rep #$20	            REP #$20
.3a05e2	a5 23		lda $0823	                LDA ARGUMENT1
.3a05e4	d0 08		bne $3a05ee	                BNE return_false
.3a05e6	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a05e8	d0 04		bne $3a05ee	                BNE return_false
.3a05ea	28		plp		return_true     PLP
.3a05eb	e2 02		sep #$02	                SEP #$02        ; Set Z
.3a05ed	60		rts		            RTS
.3a05ee	28		plp		return_false    PLP
.3a05ef	c2 02		rep #$02	                REP #$02        ; Clear Z
.3a05f1	60		rts		            RTS
.3a05f2					SET_TRUE
.3a05f2	08		php		                PHP
.3a05f3	c2 30		rep #$30	            REP #$30
.3a05f5	a9 ff ff	lda #$ffff	                LDA #$FFFF
.3a05f8	85 23		sta $0823	                STA ARGUMENT1
.3a05fa	85 25		sta $0825	                STA ARGUMENT1+2
.3a05fc	e2 20		sep #$20	            SEP #$20
.3a05fe	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a0600	85 27		sta $0827	                STA ARGTYPE1
.3a0602	28		plp		                PLP
.3a0603	60		rts		            RTS
.3a0604					SET_FALSE
.3a0604	08		php		                PHP
.3a0605	c2 30		rep #$30	            REP #$30
.3a0607	a9 00 00	lda #$0000	                LDA #0
.3a060a	85 23		sta $0823	                STA ARGUMENT1
.3a060c	85 25		sta $0825	                STA ARGUMENT1+2
.3a060e	e2 20		sep #$20	            SEP #$20
.3a0610	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a0612	85 27		sta $0827	                STA ARGTYPE1
.3a0614	28		plp		                PLP
.3a0615	60		rts		            RTS
.3a0616					ASS_ARG1_INT
.3a0616	08		php		                PHP
.3a0617	e2 20		sep #$20	            SEP #$20
.3a0619	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.3a061b	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a061d	f0 07		beq $3a0626	                BEQ done                ; If so: just return
.3a061f	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.3a0621	d0 05		bne $3a0628	                BNE TYPE_ERR            ; If not: throw an error
.3a0623	20 6c 5b	jsr $3a5b6c	            JSR FTOI
.3a0626	28		plp		done            PLP
.3a0627	60		rts		            RTS
.3a0628					TYPE_ERR
.3a0628	08		php		            PHP
.3a0629	c2 20		rep #$20	            REP #$20
.3a062b	48		pha		            PHA
.3a062c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a062f	5b		tcd		            TCD
.3a0630	68		pla		            PLA
.3a0631	28		plp		            PLP
.3a0632	e2 20		sep #$20	            SEP #$20
.3a0634	a9 04		lda #$04	            LDA #ERR_TYPE
.3a0636	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a063a	c2 20		rep #$20	            REP #$20
.3a063c	29 ff 00	and #$00ff	            AND #$00FF
.3a063f	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a0642	e2 20		sep #$20	            SEP #$20
.3a0644	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0647					ASS_ARG2_INT
.3a0647	08		php		                PHP
.3a0648	e2 20		sep #$20	            SEP #$20
.3a064a	a5 2d		lda $082d	                LDA ARGTYPE2                ; Verify that the type is INTEGER
.3a064c	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a064e	f0 37		beq $3a0687	                BEQ done                    ; If so: just return
.3a0650	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; Check if it's a float
.3a0652	d0 35		bne $3a0689	                BNE TYPE_ERR                ; If not: throw an error
.3a0654	c2 20		rep #$20	            REP #$20
.3a0656	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a0658	48		pha		            PHA
.3a0659	a5 23		lda $0823	            LDA ARGUMENT1
.3a065b	48		pha		            PHA
.3a065c	c2 20		rep #$20	            REP #$20
.3a065e	a5 29		lda $0829	            LDA ARGUMENT2
.3a0660	85 23		sta $0823	            STA ARGUMENT1
.3a0662	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a0664	85 25		sta $0825	            STA ARGUMENT1+2
.3a0666	e2 20		sep #$20	            SEP #$20
.3a0668	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.3a066a	85 27		sta $0827	            STA ARGTYPE1
.3a066c	20 6c 5b	jsr $3a5b6c	            JSR FTOI
.3a066f	c2 20		rep #$20	            REP #$20
.3a0671	a5 23		lda $0823	            LDA ARGUMENT1
.3a0673	85 29		sta $0829	            STA ARGUMENT2
.3a0675	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a0677	85 2b		sta $082b	            STA ARGUMENT2+2
.3a0679	e2 20		sep #$20	            SEP #$20
.3a067b	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.3a067d	85 2d		sta $082d	            STA ARGTYPE2
.3a067f	c2 20		rep #$20	            REP #$20
.3a0681	68		pla		            PLA
.3a0682	85 23		sta $0823	            STA ARGUMENT1
.3a0684	68		pla		            PLA
.3a0685	85 25		sta $0825	            STA ARGUMENT1+2
.3a0687	28		plp		done            PLP
.3a0688	60		rts		            RTS
.3a0689					TYPE_ERR
.3a0689	08		php		            PHP
.3a068a	c2 20		rep #$20	            REP #$20
.3a068c	48		pha		            PHA
.3a068d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a0690	5b		tcd		            TCD
.3a0691	68		pla		            PLA
.3a0692	28		plp		            PLP
.3a0693	e2 20		sep #$20	            SEP #$20
.3a0695	a9 04		lda #$04	            LDA #ERR_TYPE
.3a0697	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a069b	c2 20		rep #$20	            REP #$20
.3a069d	29 ff 00	and #$00ff	            AND #$00FF
.3a06a0	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a06a3	e2 20		sep #$20	            SEP #$20
.3a06a5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a06a8					ASS_ARG1_STR
.3a06a8	08		php		                PHP
.3a06a9	e2 20		sep #$20	            SEP #$20
.3a06ab	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is STRING
.3a06ad	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a06af	d0 02		bne $3a06b3	                BNE TYPE_ERR
.3a06b1	28		plp		                PLP
.3a06b2	60		rts		            RTS
.3a06b3					TYPE_ERR
.3a06b3	08		php		            PHP
.3a06b4	c2 20		rep #$20	            REP #$20
.3a06b6	48		pha		            PHA
.3a06b7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a06ba	5b		tcd		            TCD
.3a06bb	68		pla		            PLA
.3a06bc	28		plp		            PLP
.3a06bd	e2 20		sep #$20	            SEP #$20
.3a06bf	a9 04		lda #$04	            LDA #ERR_TYPE
.3a06c1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a06c5	c2 20		rep #$20	            REP #$20
.3a06c7	29 ff 00	and #$00ff	            AND #$00FF
.3a06ca	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a06cd	e2 20		sep #$20	            SEP #$20
.3a06cf	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a06d2					ASS_ARG1_INT16
.3a06d2	08		php		                PHP
.3a06d3	e2 20		sep #$20	            SEP #$20
.3a06d5	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.3a06d7	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a06d9	f0 07		beq $3a06e2	                BEQ check_range         ; If so: check the range
.3a06db	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.3a06dd	d0 0b		bne $3a06ea	                BNE TYPE_ERR            ; If not: throw an error
.3a06df	20 6c 5b	jsr $3a5b6c	            JSR FTOI
.3a06e2					check_range
.3a06e2	c2 20		rep #$20	            REP #$20
.3a06e4	a5 25		lda $0825	                LDA ARGUMENT1+2         ; Validate it is 16-bit
.3a06e6	d0 21		bne $3a0709	                BNE range_err
.3a06e8	28		plp		                PLP
.3a06e9	60		rts		            RTS
.3a06ea					TYPE_ERR
.3a06ea	08		php		            PHP
.3a06eb	c2 20		rep #$20	            REP #$20
.3a06ed	48		pha		            PHA
.3a06ee	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a06f1	5b		tcd		            TCD
.3a06f2	68		pla		            PLA
.3a06f3	28		plp		            PLP
.3a06f4	e2 20		sep #$20	            SEP #$20
.3a06f6	a9 04		lda #$04	            LDA #ERR_TYPE
.3a06f8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a06fc	c2 20		rep #$20	            REP #$20
.3a06fe	29 ff 00	and #$00ff	            AND #$00FF
.3a0701	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a0704	e2 20		sep #$20	            SEP #$20
.3a0706	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0709					RANGE_ERR
.3a0709	08		php		            PHP
.3a070a	c2 20		rep #$20	            REP #$20
.3a070c	48		pha		            PHA
.3a070d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a0710	5b		tcd		            TCD
.3a0711	68		pla		            PLA
.3a0712	28		plp		            PLP
.3a0713	e2 20		sep #$20	            SEP #$20
.3a0715	a9 09		lda #$09	            LDA #ERR_RANGE
.3a0717	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a071b	c2 20		rep #$20	            REP #$20
.3a071d	29 ff 00	and #$00ff	            AND #$00FF
.3a0720	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a0723	e2 20		sep #$20	            SEP #$20
.3a0725	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0728					ASS_ARG1_BYTE
.3a0728	08		php		                PHP
.3a0729	e2 20		sep #$20	            SEP #$20
.3a072b	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.3a072d	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a072f	f0 07		beq $3a0738	                BEQ check_range         ; If so: check the range
.3a0731	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.3a0733	d0 11		bne $3a0746	                BNE TYPE_ERR            ; If not: throw an error
.3a0735	20 6c 5b	jsr $3a5b6c	            JSR FTOI
.3a0738	a5 26		lda $0826	check_range     LDA ARGUMENT1+3         ; Validate that the value is in byte range
.3a073a	d0 29		bne $3a0765	                BNE RANGE_ERR           ; If not... throw a range error
.3a073c	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a073e	d0 25		bne $3a0765	                BNE RANGE_ERR
.3a0740	a5 24		lda $0824	                LDA ARGUMENT1+1
.3a0742	d0 21		bne $3a0765	                BNE RANGE_ERR
.3a0744	28		plp		                PLP
.3a0745	60		rts		            RTS
.3a0746					TYPE_ERR
.3a0746	08		php		            PHP
.3a0747	c2 20		rep #$20	            REP #$20
.3a0749	48		pha		            PHA
.3a074a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a074d	5b		tcd		            TCD
.3a074e	68		pla		            PLA
.3a074f	28		plp		            PLP
.3a0750	e2 20		sep #$20	            SEP #$20
.3a0752	a9 04		lda #$04	            LDA #ERR_TYPE
.3a0754	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0758	c2 20		rep #$20	            REP #$20
.3a075a	29 ff 00	and #$00ff	            AND #$00FF
.3a075d	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a0760	e2 20		sep #$20	            SEP #$20
.3a0762	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0765					RANGE_ERR
.3a0765	08		php		            PHP
.3a0766	c2 20		rep #$20	            REP #$20
.3a0768	48		pha		            PHA
.3a0769	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a076c	5b		tcd		            TCD
.3a076d	68		pla		            PLA
.3a076e	28		plp		            PLP
.3a076f	e2 20		sep #$20	            SEP #$20
.3a0771	a9 09		lda #$09	            LDA #ERR_RANGE
.3a0773	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0777	c2 20		rep #$20	            REP #$20
.3a0779	29 ff 00	and #$00ff	            AND #$00FF
.3a077c	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a077f	e2 20		sep #$20	            SEP #$20
.3a0781	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0784					ASS_ARG1_FLOAT
.3a0784	08		php		                PHP
.3a0785	e2 20		sep #$20	            SEP #$20
.3a0787	a5 27		lda $0827	                LDA ARGTYPE1            ; Check the type
.3a0789	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.3a078b	f0 26		beq $3a07b3	                BEQ done                ; Then we're done
.3a078d	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.3a078f	f0 1f		beq $3a07b0	                BEQ cast                ; Then cast it to float
.3a0791					type_err
.3a0791	08		php		            PHP
.3a0792	c2 20		rep #$20	            REP #$20
.3a0794	48		pha		            PHA
.3a0795	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a0798	5b		tcd		            TCD
.3a0799	68		pla		            PLA
.3a079a	28		plp		            PLP
.3a079b	e2 20		sep #$20	            SEP #$20
.3a079d	a9 04		lda #$04	            LDA #ERR_TYPE
.3a079f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a07a3	c2 20		rep #$20	            REP #$20
.3a07a5	29 ff 00	and #$00ff	            AND #$00FF
.3a07a8	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a07ab	e2 20		sep #$20	            SEP #$20
.3a07ad	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a07b0					cast
.3a07b0	20 66 5b	jsr $3a5b66	            JSR ITOF
.3a07b3	28		plp		done            PLP
.3a07b4	60		rts		            RTS
.3a07b5					ASS_ARG2_FLOAT
.3a07b5	08		php		                PHP
.3a07b6	e2 20		sep #$20	            SEP #$20
.3a07b8	a5 2d		lda $082d	                LDA ARGTYPE2            ; Check the type
.3a07ba	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.3a07bc	f0 26		beq $3a07e4	                BEQ done                ; Then we're done
.3a07be	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.3a07c0	f0 1f		beq $3a07e1	                BEQ cast                ; Then cast it to float
.3a07c2					type_err
.3a07c2	08		php		            PHP
.3a07c3	c2 20		rep #$20	            REP #$20
.3a07c5	48		pha		            PHA
.3a07c6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a07c9	5b		tcd		            TCD
.3a07ca	68		pla		            PLA
.3a07cb	28		plp		            PLP
.3a07cc	e2 20		sep #$20	            SEP #$20
.3a07ce	a9 04		lda #$04	            LDA #ERR_TYPE
.3a07d0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a07d4	c2 20		rep #$20	            REP #$20
.3a07d6	29 ff 00	and #$00ff	            AND #$00FF
.3a07d9	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a07dc	e2 20		sep #$20	            SEP #$20
.3a07de	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a07e1					cast
.3a07e1	20 e6 07	jsr $3a07e6	            JSR CAST_ARG2_FLOAT
.3a07e4	28		plp		done            PLP
.3a07e5	60		rts		            RTS
.3a07e6					CAST_ARG2_FLOAT
.3a07e6	c2 20		rep #$20	            REP #$20
.3a07e8	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a07ea	48		pha		            PHA
.3a07eb	a5 23		lda $0823	            LDA ARGUMENT1
.3a07ed	48		pha		            PHA
.3a07ee	c2 20		rep #$20	            REP #$20
.3a07f0	a5 29		lda $0829	            LDA ARGUMENT2
.3a07f2	85 23		sta $0823	            STA ARGUMENT1
.3a07f4	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a07f6	85 25		sta $0825	            STA ARGUMENT1+2
.3a07f8	e2 20		sep #$20	            SEP #$20
.3a07fa	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.3a07fc	85 27		sta $0827	            STA ARGTYPE1
.3a07fe	20 66 5b	jsr $3a5b66	            JSR ITOF
.3a0801	c2 20		rep #$20	            REP #$20
.3a0803	a5 23		lda $0823	            LDA ARGUMENT1
.3a0805	85 29		sta $0829	            STA ARGUMENT2
.3a0807	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a0809	85 2b		sta $082b	            STA ARGUMENT2+2
.3a080b	e2 20		sep #$20	            SEP #$20
.3a080d	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.3a080f	85 2d		sta $082d	            STA ARGTYPE2
.3a0811	c2 20		rep #$20	            REP #$20
.3a0813	68		pla		            PLA
.3a0814	85 23		sta $0823	            STA ARGUMENT1
.3a0816	68		pla		            PLA
.3a0817	85 25		sta $0825	            STA ARGUMENT1+2
.3a0819	60		rts		            RTS
.3a081a					ASS_ARGS_NUM
.3a081a	08		php		                PHP
.3a081b	e2 20		sep #$20	            SEP #$20
.3a081d	a5 27		lda $0827	                LDA ARGTYPE1                ; Check ARGUMENT1
.3a081f	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a0821	f0 23		beq $3a0846	                BEQ arg1_int
.3a0823	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.3a0825	f0 2e		beq $3a0855	                BEQ arg1_float
.3a0827					type_err
.3a0827	08		php		            PHP
.3a0828	c2 20		rep #$20	            REP #$20
.3a082a	48		pha		            PHA
.3a082b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a082e	5b		tcd		            TCD
.3a082f	68		pla		            PLA
.3a0830	28		plp		            PLP
.3a0831	e2 20		sep #$20	            SEP #$20
.3a0833	a9 04		lda #$04	            LDA #ERR_TYPE
.3a0835	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0839	c2 20		rep #$20	            REP #$20
.3a083b	29 ff 00	and #$00ff	            AND #$00FF
.3a083e	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a0841	e2 20		sep #$20	            SEP #$20
.3a0843	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0846	a5 2d		lda $082d	arg1_int        LDA ARGTYPE2                ; Check argument 2
.3a0848	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If integer, we're done
.3a084a	f0 16		beq $3a0862	                BEQ done
.3a084c	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If not float, throw an error
.3a084e	d0 d7		bne $3a0827	                BNE type_err
.3a0850	20 66 5b	jsr $3a5b66	            JSR ITOF
.3a0853	80 0d		bra $3a0862	                BRA done
.3a0855	a5 2d		lda $082d	arg1_float      LDA ARGTYPE2                ; Check argument 2
.3a0857	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If it's float
.3a0859	f0 07		beq $3a0862	                BEQ done                    ; Then we're done
.3a085b	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If it's not integer
.3a085d	d0 c8		bne $3a0827	                BNE type_err                ; Thrown an error
.3a085f	20 e6 07	jsr $3a07e6	            JSR CAST_ARG2_FLOAT
.3a0862					done
.3a0862	e2 20		sep #$20	            SEP #$20
.3a0864	a5 27		lda $0827	                LDA ARGTYPE1                ; Return the type code in A
.3a0866	28		plp		                PLP
.3a0867	60		rts		            RTS
.3a0868					ASS_ARGS_NUMSTR
.3a0868	08		php		                PHP
.3a0869	e2 20		sep #$20	            SEP #$20
.3a086b	a5 27		lda $0827	                LDA ARGTYPE1                ; Check to see if ARGUMENT1 is a string
.3a086d	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a086f	d0 25		bne $3a0896	                BNE numbers
.3a0871	a5 2d		lda $082d	                LDA ARGTYPE2                ; If ARGUMENT1 is a string, make sure ARGUMENT2 is
.3a0873	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a0875	f0 24		beq $3a089b	                BEQ done
.3a0877					TYPE_ERR
.3a0877	08		php		            PHP
.3a0878	c2 20		rep #$20	            REP #$20
.3a087a	48		pha		            PHA
.3a087b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a087e	5b		tcd		            TCD
.3a087f	68		pla		            PLA
.3a0880	28		plp		            PLP
.3a0881	e2 20		sep #$20	            SEP #$20
.3a0883	a9 04		lda #$04	            LDA #ERR_TYPE
.3a0885	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0889	c2 20		rep #$20	            REP #$20
.3a088b	29 ff 00	and #$00ff	            AND #$00FF
.3a088e	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a0891	e2 20		sep #$20	            SEP #$20
.3a0893	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0896					numbers
.3a0896	20 1a 08	jsr $3a081a	            JSR ASS_ARGS_NUM
.3a0899	a5 27		lda $0827	                LDA ARGTYPE1                ; Make sure A is the type
.3a089b	28		plp		done            PLP
.3a089c	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\tokens.s

.0000					TOKEN
>0000					precedence  .byte ?
>0001					length      .byte ?
>0002					name        .word <>?
>0004					eval        .word <>?
>0006					arity       .word <>?
.3a089d					PARSEINT
.3a089d	08		php		            PHP
.3a089e	0b		phd		            PHD
.3a089f	08		php		            PHP
.3a08a0	c2 20		rep #$20	            REP #$20
.3a08a2	48		pha		            PHA
.3a08a3	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a08a6	5b		tcd		            TCD
.3a08a7	68		pla		            PLA
.3a08a8	28		plp		            PLP
.3a08a9	c2 30		rep #$30	            REP #$30
.3a08ab	64 23		stz $0823	            STZ ARGUMENT1       ; Default to Not-a-value
.3a08ad	64 25		stz $0825	            STZ ARGUMENT1+2
.3a08af	e2 20		sep #$20	            SEP #$20
.3a08b1	64 27		stz $0827	            STZ ARGTYPE1
.3a08b3	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it starts with '$'
.3a08b5	c9 26		cmp #$26	            CMP #'&'
.3a08b7	f0 44		beq $3a08fd	            BEQ check_hex       ; Yes: parse it as a hexadecimal number
.3a08b9					loop
.3a08b9	e2 20		sep #$20	            SEP #$20
.3a08bb	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.3a08bd	20 c0 04	jsr $3a04c0	            JSR ISNUMERAL
.3a08c0	90 76		bcc $3a0938	            BCC done            ; No, we're done parsing
.3a08c2	20 3f 05	jsr $3a053f	            JSR MULINT10
.3a08c5	38		sec		            SEC                 ; Convert the ASCII code to a number
.3a08c6	e9 30		sbc #$30	            SBC #'0'
.3a08c8	c2 20		rep #$20	            REP #$20
.3a08ca	29 ff 00	and #$00ff	            AND #$00FF
.3a08cd	18		clc		            CLC
.3a08ce	65 23		adc $0823	            ADC ARGUMENT1
.3a08d0	85 23		sta $0823	            STA ARGUMENT1
.3a08d2	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a08d4	69 00 00	adc #$0000	            ADC #0
.3a08d7	85 25		sta $0825	            STA ARGUMENT1+2
.3a08d9	20 da 20	jsr $3a20da	            JSR INCBIP
.3a08dc	80 db		bra $3a08b9	            BRA loop            ; And try to process it
.3a08de					syntaxerr
.3a08de	08		php		            PHP
.3a08df	c2 20		rep #$20	            REP #$20
.3a08e1	48		pha		            PHA
.3a08e2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a08e5	5b		tcd		            TCD
.3a08e6	68		pla		            PLA
.3a08e7	28		plp		            PLP
.3a08e8	e2 20		sep #$20	            SEP #$20
.3a08ea	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a08ec	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a08f0	c2 20		rep #$20	            REP #$20
.3a08f2	29 ff 00	and #$00ff	            AND #$00FF
.3a08f5	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a08f8	e2 20		sep #$20	            SEP #$20
.3a08fa	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a08fd					check_hex
.3a08fd	20 da 20	jsr $3a20da	            JSR INCBIP
.3a0900	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.3a0902	c9 48		cmp #$48	            CMP #'H'            ; Is it 'H'?
.3a0904	f0 04		beq $3a090a	            BEQ parse_hex       ; Yes: skip it and parse hex
.3a0906	c9 68		cmp #$68	            CMP #'h'            ; Is it 'h'?
.3a0908	d0 d4		bne $3a08de	            BNE syntaxerr       ; No: throw an error
.3a090a					parse_hex
.3a090a	20 da 20	jsr $3a20da	            JSR INCBIP
.3a090d					hexloop
.3a090d	e2 20		sep #$20	            SEP #$20
.3a090f	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.3a0911	20 d1 04	jsr $3a04d1	            JSR ISHEX
.3a0914	90 22		bcc $3a0938	            BCC done            ; No, we're done parsing
.3a0916	20 f2 04	jsr $3a04f2	            JSR HEX2BIN
.3a0919	c2 20		rep #$20	            REP #$20
.3a091b	06 23		asl $0823	            ASL ARGUMENT1
.3a091d	26 25		rol $0825	            ROL ARGUMENT1+2
.3a091f	06 23		asl $0823	            ASL ARGUMENT1
.3a0921	26 25		rol $0825	            ROL ARGUMENT1+2
.3a0923	06 23		asl $0823	            ASL ARGUMENT1
.3a0925	26 25		rol $0825	            ROL ARGUMENT1+2
.3a0927	06 23		asl $0823	            ASL ARGUMENT1
.3a0929	26 25		rol $0825	            ROL ARGUMENT1+2
.3a092b	29 ff 00	and #$00ff	            AND #$00FF          ; Add binary number to ARGUMENT1
.3a092e	18		clc		            CLC
.3a092f	65 23		adc $0823	            ADC ARGUMENT1
.3a0931	85 23		sta $0823	            STA ARGUMENT1
.3a0933	20 da 20	jsr $3a20da	            JSR INCBIP
.3a0936	80 d5		bra $3a090d	            BRA hexloop         ; And try to process it
.3a0938	2b		pld		done        PLD
.3a0939	28		plp		            PLP
.3a093a	60		rts		            RTS
.3a093b					PREVCHAR
.3a093b	08		php		            PHP
.3a093c	c2 30		rep #$30	            REP #$30
.3a093e	a5 04		lda $0804	            LDA BIPPREV
.3a0940	f0 1c		beq $3a095e	            BEQ ret_false
.3a0942	38		sec		            SEC
.3a0943	a5 04		lda $0804	            LDA BIPPREV
.3a0945	e5 1a		sbc $081a	            SBC CURLINE
.3a0947	a8		tay		            TAY
.3a0948	e2 20		sep #$20	            SEP #$20
.3a094a	b7 1a		lda [$081a],y	loop        LDA [CURLINE],Y
.3a094c	f0 10		beq $3a095e	            BEQ ret_false
.3a094e	c9 20		cmp #$20	            CMP #CHAR_SP
.3a0950	f0 06		beq $3a0958	            BEQ go_back
.3a0952	c9 09		cmp #$09	            CMP #CHAR_TAB
.3a0954	f0 02		beq $3a0958	            BEQ go_back
.3a0956	28		plp		            PLP
.3a0957	60		rts		            RTS
.3a0958	88		dey		go_back     DEY
.3a0959	c0 ff ff	cpy #$ffff	            CPY #$FFFF
.3a095c	d0 ec		bne $3a094a	            BNE loop
.3a095e					ret_false
.3a095e	a9 00		lda #$00	            LDA #0
.3a0960	60		rts		            RTS
.3a0961					TOKENIZE
.3a0961	08		php		            PHP
.3a0962	0b		phd		            PHD
.3a0963	08		php		            PHP
.3a0964	c2 20		rep #$20	            REP #$20
.3a0966	48		pha		            PHA
.3a0967	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a096a	5b		tcd		            TCD
.3a096b	68		pla		            PLA
.3a096c	28		plp		            PLP
.3a096d	c2 30		rep #$30	            REP #$30
.3a096f	a5 1a		lda $081a	            LDA CURLINE
.3a0971	85 00		sta $0800	            STA BIP
.3a0973	e2 20		sep #$20	            SEP #$20
.3a0975	a5 1c		lda $081c	            LDA CURLINE+2
.3a0977	85 02		sta $0802	            STA BIP+2
.3a0979	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a097c	a7 00		lda [$0800]	            LDA [BIP]               ; Do we have a numeral?
.3a097e	20 c0 04	jsr $3a04c0	            JSR ISNUMERAL
.3a0981	90 0c		bcc $3a098f	            BCC mv_curline          ; No: adjust CURLINE and tokenize
.3a0983	20 9d 08	jsr $3a089d	            JSR PARSEINT
.3a0986	c2 20		rep #$20	            REP #$20
.3a0988	a5 23		lda $0823	            LDA ARGUMENT1
.3a098a	85 d7		sta $08d7	            STA LINENUM
.3a098c	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a098f					mv_curline
.3a098f	c2 20		rep #$20	            REP #$20
.3a0991	a5 00		lda $0800	            LDA BIP
.3a0993	85 1a		sta $081a	            STA CURLINE
.3a0995	e2 20		sep #$20	            SEP #$20
.3a0997	a5 02		lda $0802	            LDA BIP+2
.3a0999	85 1c		sta $081c	            STA CURLINE+2
.3a099b	20 af 09	jsr $3a09af	            JSR FINDREM
.3a099e	e2 20		sep #$20	            SEP #$20
.3a09a0					loop
.3a09a0	20 20 0a	jsr $3a0a20	            JSR TKFINDTOKEN
.3a09a3	c9 00		cmp #$00	            CMP #0                  ; Did we find a token?
.3a09a5	f0 05		beq $3a09ac	            BEQ done                ; No: return
.3a09a7	20 cb 0b	jsr $3a0bcb	            JSR TKWRITE
.3a09aa	80 f4		bra $3a09a0	            BRA loop                ; And try again
.3a09ac	2b		pld		done        PLD
.3a09ad	28		plp		            PLP
.3a09ae	60		rts		            RTS
.3a09af					FINDREM
.3a09af	08		php		            PHP
.3a09b0	c2 20		rep #$20	            REP #$20
.3a09b2	a5 1a		lda $081a	            LDA CURLINE             ; Point BIP to the beginning of the line
.3a09b4	85 00		sta $0800	            STA BIP
.3a09b6	a5 1c		lda $081c	            LDA CURLINE+2
.3a09b8	85 02		sta $0802	            STA BIP+2
.3a09ba	a2 00 00	ldx #$0000	            LDX #0                  ; X will be a flag that we're at the beginning
.3a09bd	e2 20		sep #$20	            SEP #$20
.3a09bf	a0 00 00	ldy #$0000	loop        LDY #0
.3a09c2	e0 00 00	cpx #$0000	            CPX #0                  ; If we are at the first space on the line
.3a09c5	f0 0d		beq $3a09d4	            BEQ skip_delim          ; ... skip looking for a delimiter
.3a09c7	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.3a09c9	f0 53		beq $3a0a1e	            BEQ done                ; Is it null? Then we're done
.3a09cb	c9 3a		cmp #$3a	            CMP #':'                ; Is it ":"
.3a09cd	f0 04		beq $3a09d3	            BEQ found_delim         ; Yes: we might have a REM... look for E
.3a09cf	c9 20		cmp #$20	            CMP #CHAR_SP
.3a09d1	d0 33		bne $3a0a06	            BNE next_pos            ; No: we didn't find REM here... check next position
.3a09d3	c8		iny		found_delim INY
.3a09d4	b7 00		lda [$0800],y	skip_delim  LDA [BIP],Y             ; Get the first character
.3a09d6	f0 46		beq $3a0a1e	            BEQ done                ; Is it null? Then we're done
.3a09d8	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.3a09da	f0 10		beq $3a09ec	            BEQ found_R             ; Yes: we might have a REM... look for E
.3a09dc	c9 72		cmp #$72	            CMP #'r'
.3a09de	d0 26		bne $3a0a06	            BNE next_pos            ; No: we didn't find REM here... check next position
.3a09e0	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.3a09e2	f0 3a		beq $3a0a1e	            BEQ done                ; Is it null? Then we're done
.3a09e4	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.3a09e6	f0 04		beq $3a09ec	            BEQ found_R             ; Yes: we might have a REM... look for E
.3a09e8	c9 72		cmp #$72	            CMP #'r'
.3a09ea	d0 1a		bne $3a0a06	            BNE next_pos            ; No: we didn't find REM here... check next position
.3a09ec	c8		iny		found_R     INY
.3a09ed	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.3a09ef	f0 2d		beq $3a0a1e	            BEQ done                ; Is it null? Then we're done
.3a09f1	c9 45		cmp #$45	            CMP #'E'                ; Is it "E"
.3a09f3	f0 04		beq $3a09f9	            BEQ found_E             ; Yes: we might have a REM... look for M
.3a09f5	c9 65		cmp #$65	            CMP #'e'
.3a09f7	d0 0d		bne $3a0a06	            BNE next_pos            ; No: we didn't find REM here... check next position
.3a09f9	c8		iny		found_E     INY
.3a09fa	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.3a09fc	f0 20		beq $3a0a1e	            BEQ done                ; Is it null? Then we're done
.3a09fe	c9 4d		cmp #$4d	            CMP #'M'                ; Is it "E"
.3a0a00	f0 0a		beq $3a0a0c	            BEQ found_REM           ; Yes: we might have a REM... look for M
.3a0a02	c9 6d		cmp #$6d	            CMP #'m'
.3a0a04	f0 06		beq $3a0a0c	            BEQ found_REM
.3a0a06	e8		inx		next_pos    INX                     ; Indicate we're no longer at the first position
.3a0a07	20 da 20	jsr $3a20da	            JSR INCBIP
.3a0a0a	80 b3		bra $3a09bf	            BRA loop
.3a0a0c	a7 00		lda [$0800]	found_REM   LDA [BIP]               ; Get the current character
.3a0a0e	c9 3a		cmp #$3a	            CMP #':'                ; Is it the delimiter?
.3a0a10	d0 03		bne $3a0a15	            BNE ret_REM             ; No: go ahead and return REM at that location
.3a0a12	20 da 20	jsr $3a20da	            JSR INCBIP
.3a0a15	a9 03		lda #$03	ret_REM     LDA #3
.3a0a17	85 1e		sta $081e	            STA CURTOKLEN           ; Set the size
.3a0a19	a9 91		lda #$91	            LDA #TOK_REM            ; And the token to write
.3a0a1b	20 cb 0b	jsr $3a0bcb	            JSR TKWRITE
.3a0a1e	28		plp		done        PLP
.3a0a1f	60		rts		            RTS
.3a0a20					TKFINDTOKEN
.3a0a20	08		php		            PHP
.3a0a21	0b		phd		            PHD
.3a0a22	08		php		            PHP
.3a0a23	c2 20		rep #$20	            REP #$20
.3a0a25	48		pha		            PHA
.3a0a26	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0a29	5b		tcd		            TCD
.3a0a2a	68		pla		            PLA
.3a0a2b	28		plp		            PLP
.3a0a2c	e2 20		sep #$20	            SEP #$20
.3a0a2e	a9 7f		lda #$7f	            LDA #$7F                ; Start off looking for any size token
.3a0a30	85 1e		sta $081e	            STA CURTOKLEN
.3a0a32					next_size
.3a0a32	c2 10		rep #$10	            REP #$10
.3a0a34	20 80 0b	jsr $3a0b80	            JSR TKNEXTBIG
.3a0a37	a5 1e		lda $081e	            LDA CURTOKLEN           ; Are there any keywords left?
.3a0a39	d0 03		bne $3a0a3e	            BNE else
.3a0a3b	4c c0 0a	jmp $3a0ac0	            JMP done                ; No: return to caller
.3a0a3e					else
.3a0a3e	c2 20		rep #$20	            REP #$20
.3a0a40	a5 1a		lda $081a	            LDA CURLINE
.3a0a42	85 00		sta $0800	            STA BIP
.3a0a44	e2 20		sep #$20	            SEP #$20
.3a0a46	a5 1c		lda $081c	            LDA CURLINE+2
.3a0a48	85 02		sta $0802	            STA BIP+2
.3a0a4a	c2 20		rep #$20	            REP #$20
.3a0a4c	64 04		stz $0804	            STZ BIPPREV             ; Clear BIPPREV (point to the previous character)
.3a0a4e	64 06		stz $0806	            STZ BIPPREV+2
.3a0a50					check_len
.3a0a50	e2 30		sep #$30	            SEP #$30
.3a0a52	a0 00		ldy #$00	            LDY #0
.3a0a54	b7 00		lda [$0800],y	nul_scan    LDA [BIP],Y
.3a0a56	f0 da		beq $3a0a32	            BEQ next_size
.3a0a58	c9 91		cmp #$91	            CMP #TOK_REM            ; Tokenization stops at REMarks too
.3a0a5a	f0 d6		beq $3a0a32	            BEQ next_size
.3a0a5c	c8		iny		            INY
.3a0a5d	c4 1e		cpy $081e	            CPY CURTOKLEN
.3a0a5f	90 f3		bcc $3a0a54	            BCC nul_scan
.3a0a61	c2 10		rep #$10	            REP #$10
.3a0a63	a7 00		lda [$0800]	            LDA [BIP]               ; Check the current character
.3a0a65	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.3a0a67	d0 05		bne $3a0a6e	            BNE chk_keyword         ; No: check to see if we are at the start of a possible keyword
.3a0a69	20 e2 0a	jsr $3a0ae2	            JSR SKIPQUOTED
.3a0a6c	80 28		bra $3a0a96	            BRA go_next             ; And move on to the next character
.3a0a6e	a5 1e		lda $081e	chk_keyword LDA CURTOKLEN           ; If the token length is <=2
.3a0a70	c9 03		cmp #$03	            CMP #3
.3a0a72	90 19		bcc $3a0a8d	            BLT try_match           ; ... we don't need a delimiter, go ahead and convert it
.3a0a74	c2 20		rep #$20	            REP #$20
.3a0a76	a5 00		lda $0800	            LDA BIP                 ; Check to see if we're at the start of the line
.3a0a78	c5 1a		cmp $081a	            CMP CURLINE
.3a0a7a	d0 08		bne $3a0a84	            BNE chk_delim           ; No: we need to check for a delimiters
.3a0a7c	e2 20		sep #$20	            SEP #$20
.3a0a7e	a5 02		lda $0802	            LDA BIP+2
.3a0a80	c5 1c		cmp $081c	            CMP CURLINE+2
.3a0a82	f0 09		beq $3a0a8d	            BEQ try_match           ; Yes: this can be a keyword
.3a0a84					chk_delim
.3a0a84	e2 20		sep #$20	            SEP #$20
.3a0a86	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.3a0a88	20 af 50	jsr $3a50af	            JSR ISVARCHAR
.3a0a8b	b0 09		bcs $3a0a96	            BCS go_next             ; Yes: we can't start a keyword here
.3a0a8d					try_match
.3a0a8d	e2 20		sep #$20	            SEP #$20
.3a0a8f	20 f2 0a	jsr $3a0af2	            JSR TKMATCH
.3a0a92	c9 00		cmp #$00	            CMP #0                  ; Did we get one?
.3a0a94	d0 11		bne $3a0aa7	            BNE found               ; Yes: return it
.3a0a96					go_next
.3a0a96	c2 20		rep #$20	            REP #$20
.3a0a98	a5 00		lda $0800	            LDA BIP                 ; Update BIPPREV as the point to the previous character
.3a0a9a	85 04		sta $0804	            STA BIPPREV
.3a0a9c	e2 20		sep #$20	            SEP #$20
.3a0a9e	a5 02		lda $0802	            LDA BIP+2
.3a0aa0	85 06		sta $0806	            STA BIPPREV+2
.3a0aa2	20 da 20	jsr $3a20da	            JSR INCBIP
.3a0aa5	80 a9		bra $3a0a50	            BRA check_len           ; And try there
.3a0aa7					found
.3a0aa7	c9 81		cmp #$81	            CMP #TOK_MINUS          ; Found a token... is it minus?
.3a0aa9	d0 15		bne $3a0ac0	            BNE done                ; Nope: go ahead and return it
.3a0aab	20 3b 09	jsr $3a093b	            JSR PREVCHAR
.3a0aae	c9 00		cmp #$00	            CMP #0                  ; Did we get anything?
.3a0ab0	f0 11		beq $3a0ac3	            BEQ syntax              ; No: line cannot start with minus... throw error
.3a0ab2	89 80		bit #$80	            BIT #$80                ; Is it a token?
.3a0ab4	f0 08		beq $3a0abe	            BEQ binaryminus         ; No: leave token unchanged
.3a0ab6	c9 90		cmp #$90	            CMP #TOK_RPAREN         ; Is the token a right parenthesis?
.3a0ab8	f0 04		beq $3a0abe	            BEQ binaryminus         ; Yes: then this should be a binary minus operator
.3a0aba	a9 af		lda #$af	            LDA #TOK_NEGATIVE       ; Otherwise: this should be a unary minus (negation)
.3a0abc	80 02		bra $3a0ac0	            BRA done
.3a0abe	a9 81		lda #$81	binaryminus LDA #TOK_MINUS          ; It's data... so token should be for binary minus
.3a0ac0					done
.3a0ac0	2b		pld		            PLD
.3a0ac1	28		plp		            PLP
.3a0ac2	60		rts		            RTS
.3a0ac3					syntax
.3a0ac3	08		php		            PHP
.3a0ac4	c2 20		rep #$20	            REP #$20
.3a0ac6	48		pha		            PHA
.3a0ac7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a0aca	5b		tcd		            TCD
.3a0acb	68		pla		            PLA
.3a0acc	28		plp		            PLP
.3a0acd	e2 20		sep #$20	            SEP #$20
.3a0acf	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a0ad1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0ad5	c2 20		rep #$20	            REP #$20
.3a0ad7	29 ff 00	and #$00ff	            AND #$00FF
.3a0ada	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a0add	e2 20		sep #$20	            SEP #$20
.3a0adf	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0ae2					SKIPQUOTED
.3a0ae2	08		php		            PHP
.3a0ae3	e2 20		sep #$20	            SEP #$20
.3a0ae5					loop
.3a0ae5	20 da 20	jsr $3a20da	            JSR INCBIP
.3a0ae8	a7 00		lda [$0800]	            LDA [BIP]
.3a0aea	f0 04		beq $3a0af0	            BEQ done                ; If EOL, just return
.3a0aec	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.3a0aee	d0 f5		bne $3a0ae5	            BNE loop                ; No: keep skipping
.3a0af0	28		plp		done        PLP
.3a0af1	60		rts		            RTS
.3a0af2					TKMATCH
.3a0af2	da		phx		            PHX
.3a0af3	5a		phy		            PHY
.3a0af4	08		php		            PHP
.3a0af5	0b		phd		            PHD
.3a0af6	08		php		            PHP
.3a0af7	c2 20		rep #$20	            REP #$20
.3a0af9	48		pha		            PHA
.3a0afa	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0afd	5b		tcd		            TCD
.3a0afe	68		pla		            PLA
.3a0aff	28		plp		            PLP
.3a0b00	c2 20		rep #$20	            REP #$20
.3a0b02	a5 04		lda $0804	            LDA BIPPREV
.3a0b04	d0 0a		bne $3a0b10	            BNE check_prev
.3a0b06	e2 20		sep #$20	            SEP #$20
.3a0b08	a5 04		lda $0804	            LDA BIPPREV
.3a0b0a	d0 04		bne $3a0b10	            BNE check_prev
.3a0b0c	a9 00		lda #$00	            LDA #0
.3a0b0e	80 0a		bra $3a0b1a	            BRA save_delim
.3a0b10					check_prev
.3a0b10	e2 20		sep #$20	            SEP #$20
.3a0b12	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.3a0b14	20 af 50	jsr $3a50af	            JSR ISVARCHAR
.3a0b17	a9 00		lda #$00	            LDA #0
.3a0b19	2a		rol a		            ROL A
.3a0b1a	85 28		sta $0828	save_delim  STA SIGN1               ; SIGN1 := 1 if it is a variable name character
.3a0b1c	c2 30		rep #$30	            REP #$30
.3a0b1e	a9 c0 0c	lda #$0cc0	            LDA #<>TOKENS           ; Set INDEX to point to the first token record
.3a0b21	85 08		sta $0808	            STA INDEX
.3a0b23	e2 20		sep #$20	            SEP #$20
.3a0b25	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0b27	85 0a		sta $080a	            STA INDEX+2
.3a0b29	a2 80 00	ldx #$0080	            LDX #$80                ; Set the initial token ID
.3a0b2c					token_loop
.3a0b2c	e2 20		sep #$20	            SEP #$20
.3a0b2e	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.3a0b31	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the current token
.3a0b33	f0 31		beq $3a0b66	            BEQ no_match            ; Is it 0? We're out of tokens... no match found
.3a0b35	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it the same as the size of the window?
.3a0b37	d0 32		bne $3a0b6b	            BNE next_token          ; No: try the next token
.3a0b39	c2 30		rep #$30	            REP #$30
.3a0b3b	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.3a0b3e	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the pointer to the token's name
.3a0b40	85 0c		sta $080c	            STA SCRATCH             ; Set SCRATCH to point to the token's name
.3a0b42	e2 20		sep #$20	            SEP #$20
.3a0b44	a9 3a		lda #$3a	            LDA #`DATA_BLOCK
.3a0b46	85 0e		sta $080e	            STA SCRATCH+2
.3a0b48	a5 28		lda $0828	            LDA SIGN1               ; Is previous character a variable name character?
.3a0b4a	f0 07		beq $3a0b53	            BEQ cmp_keyword         ; No: we can check for this token
.3a0b4c	a7 0c		lda [$080c]	            LDA [SCRATCH]           ; Get the token's first character
.3a0b4e	20 af 50	jsr $3a50af	            JSR ISVARCHAR
.3a0b51	b0 18		bcs $3a0b6b	            BCS next_token          ; Yes: skip this token
.3a0b53					cmp_keyword
.3a0b53	e2 10		sep #$10	            SEP #$10
.3a0b55	a0 00		ldy #$00	            LDY #0
.3a0b57	b7 00		lda [$0800],y	cmp_loop    LDA [BIP],Y             ; Get the character in the window
.3a0b59	20 1b 05	jsr $3a051b	            JSR TOUPPERA
.3a0b5c	d7 0c		cmp [$080c],y	            CMP [SCRATCH],Y         ; Compare to the character in the token
.3a0b5e	d0 0b		bne $3a0b6b	            BNE next_token          ; If they don't match, try the next token
.3a0b60	c8		iny		            INY                     ; Move to the next character in the window
.3a0b61	c4 1e		cpy $081e	            CPY CURTOKLEN           ; Have we checked the whole window?
.3a0b63	90 f2		bcc $3a0b57	            BCC cmp_loop            ; No: check this next character
.3a0b65	8a		txa		            TXA                     ; Move the token ID to A
.3a0b66	2b		pld		no_match    PLD
.3a0b67	28		plp		            PLP
.3a0b68	7a		ply		            PLY
.3a0b69	fa		plx		            PLX
.3a0b6a	60		rts		            RTS
.3a0b6b					next_token
.3a0b6b	c2 30		rep #$30	            REP #$30
.3a0b6d	18		clc		            CLC
.3a0b6e	a5 08		lda $0808	            LDA INDEX
.3a0b70	69 08 00	adc #$0008	            ADC #size(TOKEN)
.3a0b73	85 08		sta $0808	            STA INDEX
.3a0b75	e2 20		sep #$20	            SEP #$20
.3a0b77	a5 0a		lda $080a	            LDA INDEX+2
.3a0b79	69 00		adc #$00	            ADC #0
.3a0b7b	85 0a		sta $080a	            STA INDEX+2
.3a0b7d	e8		inx		            INX                     ; Increment the token ID
.3a0b7e	80 ac		bra $3a0b2c	            BRA token_loop          ; And check that token
.3a0b80					TKNEXTBIG
.3a0b80	08		php		            PHP
.3a0b81	0b		phd		            PHD
.3a0b82	8b		phb		            PHB
.3a0b83	08		php		            PHP
.3a0b84	c2 20		rep #$20	            REP #$20
.3a0b86	48		pha		            PHA
.3a0b87	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0b8a	5b		tcd		            TCD
.3a0b8b	68		pla		            PLA
.3a0b8c	28		plp		            PLP
.3a0b8d	c2 30		rep #$30	            REP #$30
.3a0b8f	a9 c0 0c	lda #$0cc0	            LDA #<>TOKENS
.3a0b92	85 08		sta $0808	            STA INDEX
.3a0b94	a9 3a 00	lda #$003a	            LDA #`TOKENS
.3a0b97	85 0a		sta $080a	            STA INDEX+2
.3a0b99	64 0c		stz $080c	            STZ SCRATCH             ; Clear SCRATCH
.3a0b9b					loop
.3a0b9b	e2 20		sep #$20	            SEP #$20
.3a0b9d	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.3a0ba0	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the token
.3a0ba2	f0 1d		beq $3a0bc1	            BEQ done                ; If length is 0, we're done
.3a0ba4	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it >= CURTOKLEN?
.3a0ba6	b0 06		bcs $3a0bae	            BGE skip                ; Yes: skip to the next token
.3a0ba8	c5 0c		cmp $080c	            CMP SCRATCH             ; No: is it < SCRATCH?
.3a0baa	90 02		bcc $3a0bae	            BLT skip                ; Yes: skip to the next token
.3a0bac	85 0c		sta $080c	            STA SCRATCH             ; No: it's our new longest token!
.3a0bae					skip
.3a0bae	c2 20		rep #$20	            REP #$20
.3a0bb0	18		clc		            CLC
.3a0bb1	a5 08		lda $0808	            LDA INDEX
.3a0bb3	69 08 00	adc #$0008	            ADC #size(TOKEN)
.3a0bb6	85 08		sta $0808	            STA INDEX
.3a0bb8	a5 0a		lda $080a	            LDA INDEX+2
.3a0bba	69 00 00	adc #$0000	            ADC #0
.3a0bbd	85 0a		sta $080a	            STA INDEX+2
.3a0bbf	80 da		bra $3a0b9b	            BRA loop                ; And go around for another pass
.3a0bc1					done
.3a0bc1	e2 20		sep #$20	            SEP #$20
.3a0bc3	a5 0c		lda $080c	            LDA SCRATCH
.3a0bc5	85 1e		sta $081e	            STA CURTOKLEN
.3a0bc7	ab		plb		            PLB
.3a0bc8	2b		pld		            PLD
.3a0bc9	28		plp		            PLP
.3a0bca	60		rts		            RTS
.3a0bcb					TKWRITE
.3a0bcb	08		php		            PHP
.3a0bcc	0b		phd		            PHD
.3a0bcd	08		php		            PHP
.3a0bce	c2 20		rep #$20	            REP #$20
.3a0bd0	48		pha		            PHA
.3a0bd1	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0bd4	5b		tcd		            TCD
.3a0bd5	68		pla		            PLA
.3a0bd6	28		plp		            PLP
.3a0bd7	e2 20		sep #$20	            SEP #$20
.3a0bd9	87 00		sta [$0800]	            STA [BIP]               ; Write the token to the line
.3a0bdb	c2 20		rep #$20	            REP #$20
.3a0bdd	18		clc		            CLC
.3a0bde	a5 00		lda $0800	            LDA BIP
.3a0be0	69 01 00	adc #$0001	            ADC #1
.3a0be3	85 08		sta $0808	            STA INDEX
.3a0be5	a5 02		lda $0802	            LDA BIP+2
.3a0be7	69 00 00	adc #$0000	            ADC #0
.3a0bea	85 0a		sta $080a	            STA INDEX+2
.3a0bec	e2 10		sep #$10	            SEP #$10
.3a0bee	a4 1e		ldy $081e	            LDY CURTOKLEN           ; Y will be the number of characters to move down
.3a0bf0	88		dey		            DEY
.3a0bf1					copy_down
.3a0bf1	e2 20		sep #$20	            SEP #$20
.3a0bf3	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the byte to move down
.3a0bf5	87 08		sta [$0808]	            STA [INDEX]             ; Move it down
.3a0bf7	f0 13		beq $3a0c0c	            BEQ done                ; We've reached the end of the line
.3a0bf9	c2 20		rep #$20	            REP #$20
.3a0bfb	18		clc		            CLC
.3a0bfc	a5 08		lda $0808	            LDA INDEX
.3a0bfe	69 01 00	adc #$0001	            ADC #1
.3a0c01	85 08		sta $0808	            STA INDEX
.3a0c03	a5 0a		lda $080a	            LDA INDEX+2
.3a0c05	69 00 00	adc #$0000	            ADC #0
.3a0c08	85 0a		sta $080a	            STA INDEX+2
.3a0c0a	80 e5		bra $3a0bf1	            BRA copy_down
.3a0c0c	2b		pld		done        PLD
.3a0c0d	28		plp		            PLP
.3a0c0e	60		rts		            RTS
.3a0c0f					GETTOKREC
.3a0c0f	08		php		            PHP
.3a0c10	c2 30		rep #$30	            REP #$30
.3a0c12	29 7f 00	and #$007f	            AND #$007F
.3a0c15	0a		asl a		            ASL A
.3a0c16	0a		asl a		            ASL A
.3a0c17	0a		asl a		            ASL A
.3a0c18	18		clc		            CLC
.3a0c19	69 c0 0c	adc #$0cc0	            ADC #<>TOKENS
.3a0c1c	aa		tax		            TAX                         ; X is now the data bank relative address of the token record
.3a0c1d	28		plp		            PLP
.3a0c1e	60		rts		            RTS
.3a0c1f					TOKPRECED
.3a0c1f	08		php		            PHP
.3a0c20	8b		phb		            PHB
.3a0c21	0b		phd		            PHD
.3a0c22	08		php		            PHP
.3a0c23	c2 20		rep #$20	            REP #$20
.3a0c25	48		pha		            PHA
.3a0c26	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0c29	5b		tcd		            TCD
.3a0c2a	68		pla		            PLA
.3a0c2b	28		plp		            PLP
.3a0c2c	08		php		            PHP
.3a0c2d	e2 20		sep #$20	            SEP #$20
.3a0c2f	48		pha		            PHA
.3a0c30	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0c32	48		pha		            PHA
.3a0c33	ab		plb		            PLB
.3a0c34	68		pla		            PLA
.3a0c35	28		plp		            PLP
.3a0c36	e2 20		sep #$20	            SEP #$20
.3a0c38	c2 10		rep #$10	            REP #$10
.3a0c3a	20 0f 0c	jsr $3a0c0f	            JSR GETTOKREC
.3a0c3d	bd 00 00	lda $3a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.3a0c40	c2 20		rep #$20	            REP #$20
.3a0c42	29 0f 00	and #$000f	            AND #$000F                  ; Mask off the type code
.3a0c45	2b		pld		            PLD
.3a0c46	ab		plb		            PLB
.3a0c47	28		plp		            PLP
.3a0c48	60		rts		            RTS
.3a0c49					TOKEVAL
.3a0c49	08		php		            PHP
.3a0c4a	8b		phb		            PHB
.3a0c4b	0b		phd		            PHD
.3a0c4c	08		php		            PHP
.3a0c4d	c2 20		rep #$20	            REP #$20
.3a0c4f	48		pha		            PHA
.3a0c50	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0c53	5b		tcd		            TCD
.3a0c54	68		pla		            PLA
.3a0c55	28		plp		            PLP
.3a0c56	08		php		            PHP
.3a0c57	e2 20		sep #$20	            SEP #$20
.3a0c59	48		pha		            PHA
.3a0c5a	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0c5c	48		pha		            PHA
.3a0c5d	ab		plb		            PLB
.3a0c5e	68		pla		            PLA
.3a0c5f	28		plp		            PLP
.3a0c60	c2 30		rep #$30	            REP #$30
.3a0c62	20 0f 0c	jsr $3a0c0f	            JSR GETTOKREC
.3a0c65	bd 04 00	lda $3a0004,x	            LDA #TOKEN.eval,B,X         ; Get the address of the evaluation function
.3a0c68	2b		pld		            PLD
.3a0c69	ab		plb		            PLB
.3a0c6a	28		plp		            PLP
.3a0c6b	60		rts		            RTS
.3a0c6c					TOKTYPE
.3a0c6c	08		php		            PHP
.3a0c6d	8b		phb		            PHB
.3a0c6e	0b		phd		            PHD
.3a0c6f	08		php		            PHP
.3a0c70	c2 20		rep #$20	            REP #$20
.3a0c72	48		pha		            PHA
.3a0c73	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0c76	5b		tcd		            TCD
.3a0c77	68		pla		            PLA
.3a0c78	28		plp		            PLP
.3a0c79	08		php		            PHP
.3a0c7a	e2 20		sep #$20	            SEP #$20
.3a0c7c	48		pha		            PHA
.3a0c7d	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0c7f	48		pha		            PHA
.3a0c80	ab		plb		            PLB
.3a0c81	68		pla		            PLA
.3a0c82	28		plp		            PLP
.3a0c83	e2 20		sep #$20	            SEP #$20
.3a0c85	c2 10		rep #$10	            REP #$10
.3a0c87	20 0f 0c	jsr $3a0c0f	            JSR GETTOKREC
.3a0c8a	bd 00 00	lda $3a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.3a0c8d	c2 20		rep #$20	            REP #$20
.3a0c8f	29 f0 00	and #$00f0	            AND #$00F0                  ; Mask off the type code
.3a0c92	2b		pld		            PLD
.3a0c93	ab		plb		            PLB
.3a0c94	28		plp		            PLP
.3a0c95	60		rts		            RTS
.3a0c96					TOKARITY
.3a0c96	08		php		            PHP
.3a0c97	8b		phb		            PHB
.3a0c98	0b		phd		            PHD
.3a0c99	08		php		            PHP
.3a0c9a	c2 20		rep #$20	            REP #$20
.3a0c9c	48		pha		            PHA
.3a0c9d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0ca0	5b		tcd		            TCD
.3a0ca1	68		pla		            PLA
.3a0ca2	28		plp		            PLP
.3a0ca3	08		php		            PHP
.3a0ca4	e2 20		sep #$20	            SEP #$20
.3a0ca6	48		pha		            PHA
.3a0ca7	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0ca9	48		pha		            PHA
.3a0caa	ab		plb		            PLB
.3a0cab	68		pla		            PLA
.3a0cac	28		plp		            PLP
.3a0cad	e2 20		sep #$20	            SEP #$20
.3a0caf	c2 10		rep #$10	            REP #$10
.3a0cb1	20 0f 0c	jsr $3a0c0f	            JSR GETTOKREC
.3a0cb4	bd 06 00	lda $3a0006,x	            LDA #TOKEN.arity,B,X        ; Get the arity
.3a0cb7	c2 20		rep #$20	            REP #$20
.3a0cb9	29 ff 00	and #$00ff	            AND #$00FF
.3a0cbc	2b		pld		            PLD
.3a0cbd	ab		plb		            PLB
.3a0cbe	28		plp		            PLP
.3a0cbf	60		rts		            RTS
=$00					TOK_EOL = $00
=$01					TOK_FUNC_OPEN = $01     ; A pseudo-token to push to the operator stack to mark
=$00					TOK_TY_OP = $00         ; The token is an operator
=$10					TOK_TY_CMD = $10        ; The token is a command (e.g. RUN, LIST, etc.)
=$20					TOK_TY_STMNT = $20      ; The token is a statement (e.g. INPUT, PRINT, DIM, etc.)
=$30					TOK_TY_FUNC = $30       ; The token is a function (e.g. SIN, COS, TAB, etc.)
=$40					TOK_TY_PUNCT = $40      ; The token is a punctuation mark (e.g. "(", ")")
=$50					TOK_TY_BYWRD = $50      ; The token is a by-word (e.g. STEP, TO, WEND, etc.)
.3a0cc0					TOKENS
=$80					TOK_PLUS = $80
>3ad010	2b 00				TOKEN_TEXT  .null "+"
>3a0cc0	03				precedence  .byte TOK_TY_OP | 3
>3a0cc1	01				length      .byte len("+")
>3a0cc2	10 d0				name        .word <>TOKEN_TEXT
>3a0cc4	a0 27				eval        .word <>OP_PLUS
>3a0cc6	02 00				arity       .word <>2
=$81					TOK_MINUS = $81
>3ad012	2d 00				TOKEN_TEXT  .null "-"
>3a0cc8	03				precedence  .byte TOK_TY_OP | 3
>3a0cc9	01				length      .byte len("-")
>3a0cca	12 d0				name        .word <>TOKEN_TEXT
>3a0ccc	e0 27				eval        .word <>OP_MINUS
>3a0cce	02 00				arity       .word <>2
=$82					TOK_MULT = $82
>3ad014	2a 00				TOKEN_TEXT  .null "*"
>3a0cd0	02				precedence  .byte TOK_TY_OP | 2
>3a0cd1	01				length      .byte len("*")
>3a0cd2	14 d0				name        .word <>TOKEN_TEXT
>3a0cd4	17 28				eval        .word <>OP_MULTIPLY
>3a0cd6	02 00				arity       .word <>2
=$83					TOK_DIVIDE = $83
>3ad016	2f 00				TOKEN_TEXT  .null "/"
>3a0cd8	02				precedence  .byte TOK_TY_OP | 2
>3a0cd9	01				length      .byte len("/")
>3a0cda	16 d0				name        .word <>TOKEN_TEXT
>3a0cdc	4e 28				eval        .word <>OP_DIVIDE
>3a0cde	02 00				arity       .word <>2
=$84					TOK_MOD = $84
>3ad018	4d 4f 44 00			TOKEN_TEXT  .null "MOD"
>3a0ce0	02				precedence  .byte TOK_TY_OP | 2
>3a0ce1	03				length      .byte len("MOD")
>3a0ce2	18 d0				name        .word <>TOKEN_TEXT
>3a0ce4	58 28				eval        .word <>OP_MOD
>3a0ce6	02 00				arity       .word <>2
>3ad01c	5e 00				TOKEN_TEXT  .null "^"
>3a0ce8	00				precedence  .byte TOK_TY_OP | 0
>3a0ce9	01				length      .byte len("^")
>3a0cea	1c d0				name        .word <>TOKEN_TEXT
>3a0cec	6b 28				eval        .word <>OP_POW
>3a0cee	02 00				arity       .word <>2
=$86					TOK_LE = $86
>3ad01e	3c 3d 00			TOKEN_TEXT  .null "<="
>3a0cf0	04				precedence  .byte TOK_TY_OP | 4
>3a0cf1	02				length      .byte len("<=")
>3a0cf2	1e d0				name        .word <>TOKEN_TEXT
>3a0cf4	29 2a				eval        .word <>OP_LTE
>3a0cf6	02 00				arity       .word <>2
=$87					TOK_GE = $87
>3ad021	3e 3d 00			TOKEN_TEXT  .null ">="
>3a0cf8	04				precedence  .byte TOK_TY_OP | 4
>3a0cf9	02				length      .byte len(">=")
>3a0cfa	21 d0				name        .word <>TOKEN_TEXT
>3a0cfc	e9 29				eval        .word <>OP_GTE
>3a0cfe	02 00				arity       .word <>2
=$88					TOK_NE = $88
>3ad024	3c 3e 00			TOKEN_TEXT  .null "<>"
>3a0d00	04				precedence  .byte TOK_TY_OP | 4
>3a0d01	02				length      .byte len("<>")
>3a0d02	24 d0				name        .word <>TOKEN_TEXT
>3a0d04	a9 29				eval        .word <>OP_NE
>3a0d06	02 00				arity       .word <>2
>3ad027	3c 00				TOKEN_TEXT  .null "<"
>3a0d08	04				precedence  .byte TOK_TY_OP | 4
>3a0d09	01				length      .byte len("<")
>3a0d0a	27 d0				name        .word <>TOKEN_TEXT
>3a0d0c	e9 28				eval        .word <>OP_LT
>3a0d0e	02 00				arity       .word <>2
=$8a					TOK_EQ = $8A
>3ad029	3d 00				TOKEN_TEXT  .null "="
>3a0d10	04				precedence  .byte TOK_TY_OP | 4
>3a0d11	01				length      .byte len("=")
>3a0d12	29 d0				name        .word <>TOKEN_TEXT
>3a0d14	69 29				eval        .word <>OP_EQ
>3a0d16	02 00				arity       .word <>2
>3ad02b	3e 00				TOKEN_TEXT  .null ">"
>3a0d18	04				precedence  .byte TOK_TY_OP | 4
>3a0d19	01				length      .byte len(">")
>3a0d1a	2b d0				name        .word <>TOKEN_TEXT
>3a0d1c	29 29				eval        .word <>OP_GT
>3a0d1e	02 00				arity       .word <>2
>3ad02d	4e 4f 54 00			TOKEN_TEXT  .null "NOT"
>3a0d20	05				precedence  .byte TOK_TY_OP | 5
>3a0d21	03				length      .byte len("NOT")
>3a0d22	2d d0				name        .word <>TOKEN_TEXT
>3a0d24	d3 28				eval        .word <>OP_NOT
>3a0d26	01 00				arity       .word <>1
>3ad031	41 4e 44 00			TOKEN_TEXT  .null "AND"
>3a0d28	06				precedence  .byte TOK_TY_OP | 6
>3a0d29	03				length      .byte len("AND")
>3a0d2a	31 d0				name        .word <>TOKEN_TEXT
>3a0d2c	a5 28				eval        .word <>OP_AND
>3a0d2e	02 00				arity       .word <>2
>3ad035	4f 52 00			TOKEN_TEXT  .null "OR"
>3a0d30	07				precedence  .byte TOK_TY_OP | 7
>3a0d31	02				length      .byte len("OR")
>3a0d32	35 d0				name        .word <>TOKEN_TEXT
>3a0d34	bc 28				eval        .word <>OP_OR
>3a0d36	02 00				arity       .word <>2
=$8f					TOK_LPAREN = $8F
>3ad038	28 00				TOKEN_TEXT  .null "("
>3a0d38	ff				precedence  .byte TOK_TY_PUNCT | $FF
>3a0d39	01				length      .byte len("(")
>3a0d3a	38 d0				name        .word <>TOKEN_TEXT
>3a0d3c	00 00				eval        .word <>0
>3a0d3e	00 00				arity       .word <>0
=$90					TOK_RPAREN = $90
>3ad03a	29 00				TOKEN_TEXT  .null ")"
>3a0d40	40				precedence  .byte TOK_TY_PUNCT | 0
>3a0d41	01				length      .byte len(")")
>3a0d42	3a d0				name        .word <>TOKEN_TEXT
>3a0d44	00 00				eval        .word <>0
>3a0d46	00 00				arity       .word <>0
=$91					TOK_REM = $91
>3ad03c	52 45 4d 00			TOKEN_TEXT  .null "REM"
>3a0d48	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d49	03				length      .byte len("REM")
>3a0d4a	3c d0				name        .word <>TOKEN_TEXT
>3a0d4c	3c 41				eval        .word <>S_REM
>3a0d4e	00 00				arity       .word <>0
=$92					TOK_PRINT = $92
>3ad040	50 52 49 4e 54 00		TOKEN_TEXT  .null "PRINT"
>3a0d50	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d51	05				length      .byte len("PRINT")
>3a0d52	40 d0				name        .word <>TOKEN_TEXT
>3a0d54	41 45				eval        .word <>S_PRINT
>3a0d56	00 00				arity       .word <>0
=$93					TOK_LET = $93
>3ad046	4c 45 54 00			TOKEN_TEXT  .null "LET"
>3a0d58	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d59	03				length      .byte len("LET")
>3a0d5a	46 d0				name        .word <>TOKEN_TEXT
>3a0d5c	8c 44				eval        .word <>S_LET
>3a0d5e	00 00				arity       .word <>0
>3ad04a	47 4f 54 4f 00			TOKEN_TEXT  .null "GOTO"
>3a0d60	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d61	04				length      .byte len("GOTO")
>3a0d62	4a d0				name        .word <>TOKEN_TEXT
>3a0d64	2c 44				eval        .word <>S_GOTO
>3a0d66	00 00				arity       .word <>0
=$95					TOK_END = $95
>3ad04f	45 4e 44 00			TOKEN_TEXT  .null "END"
>3a0d68	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d69	03				length      .byte len("END")
>3a0d6a	4f d0				name        .word <>TOKEN_TEXT
>3a0d6c	23 44				eval        .word <>S_END
>3a0d6e	00 00				arity       .word <>0
>3ad053	49 46 00			TOKEN_TEXT  .null "IF"
>3a0d70	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d71	02				length      .byte len("IF")
>3a0d72	53 d0				name        .word <>TOKEN_TEXT
>3a0d74	bb 43				eval        .word <>S_IF
>3a0d76	00 00				arity       .word <>0
=$97					TOK_THEN = $97
>3ad056	54 48 45 4e 00			TOKEN_TEXT  .null "THEN"
>3a0d78	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0d79	04				length      .byte len("THEN")
>3a0d7a	56 d0				name        .word <>TOKEN_TEXT
>3a0d7c	00 00				eval        .word <>0
>3a0d7e	00 00				arity       .word <>0
>3ad05b	45 4c 53 45 00			TOKEN_TEXT  .null "ELSE"
>3a0d80	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0d81	04				length      .byte len("ELSE")
>3a0d82	5b d0				name        .word <>TOKEN_TEXT
>3a0d84	00 00				eval        .word <>0
>3a0d86	00 00				arity       .word <>0
>3ad060	47 4f 53 55 42 00		TOKEN_TEXT  .null "GOSUB"
>3a0d88	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d89	05				length      .byte len("GOSUB")
>3a0d8a	60 d0				name        .word <>TOKEN_TEXT
>3a0d8c	fe 42				eval        .word <>S_GOSUB
>3a0d8e	00 00				arity       .word <>0
>3ad066	52 45 54 55 52 4e 00		TOKEN_TEXT  .null "RETURN"
>3a0d90	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d91	06				length      .byte len("RETURN")
>3a0d92	66 d0				name        .word <>TOKEN_TEXT
>3a0d94	77 43				eval        .word <>S_RETURN
>3a0d96	00 00				arity       .word <>0
=$9b					TOK_FOR = $9B
>3ad06d	46 4f 52 00			TOKEN_TEXT  .null "FOR"
>3a0d98	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d99	03				length      .byte len("FOR")
>3a0d9a	6d d0				name        .word <>TOKEN_TEXT
>3a0d9c	53 41				eval        .word <>S_FOR
>3a0d9e	00 00				arity       .word <>0
=$9c					TOK_TO = $9C
>3ad071	54 4f 00			TOKEN_TEXT  .null "TO"
>3a0da0	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0da1	02				length      .byte len("TO")
>3a0da2	71 d0				name        .word <>TOKEN_TEXT
>3a0da4	00 00				eval        .word <>0
>3a0da6	00 00				arity       .word <>0
=$9d					TOK_STEP = $9D
>3ad074	53 54 45 50 00			TOKEN_TEXT  .null "STEP"
>3a0da8	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0da9	04				length      .byte len("STEP")
>3a0daa	74 d0				name        .word <>TOKEN_TEXT
>3a0dac	00 00				eval        .word <>0
>3a0dae	00 00				arity       .word <>0
=$9e					TOK_NEXT = $9E
>3ad079	4e 45 58 54 00			TOKEN_TEXT  .null "NEXT"
>3a0db0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0db1	04				length      .byte len("NEXT")
>3a0db2	79 d0				name        .word <>TOKEN_TEXT
>3a0db4	47 42				eval        .word <>S_NEXT
>3a0db6	00 00				arity       .word <>0
=$9f					TOK_DO = $9F
>3ad07e	44 4f 00			TOKEN_TEXT  .null "DO"
>3a0db8	20				precedence  .byte TOK_TY_STMNT | 0
>3a0db9	02				length      .byte len("DO")
>3a0dba	7e d0				name        .word <>TOKEN_TEXT
>3a0dbc	4d 41				eval        .word <>S_DO
>3a0dbe	00 00				arity       .word <>0
=$a0					TOK_LOOP = $A0
>3ad081	4c 4f 4f 50 00			TOKEN_TEXT  .null "LOOP"
>3a0dc0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0dc1	04				length      .byte len("LOOP")
>3a0dc2	81 d0				name        .word <>TOKEN_TEXT
>3a0dc4	50 41				eval        .word <>S_LOOP
>3a0dc6	00 00				arity       .word <>0
>3ad086	57 48 49 4c 45 00		TOKEN_TEXT  .null "WHILE"
>3a0dc8	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0dc9	05				length      .byte len("WHILE")
>3a0dca	86 d0				name        .word <>TOKEN_TEXT
>3a0dcc	00 00				eval        .word <>0
>3a0dce	00 00				arity       .word <>0
>3ad08c	55 4e 54 49 4c 00		TOKEN_TEXT  .null "UNTIL"
>3a0dd0	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0dd1	05				length      .byte len("UNTIL")
>3a0dd2	8c d0				name        .word <>TOKEN_TEXT
>3a0dd4	00 00				eval        .word <>0
>3a0dd6	00 00				arity       .word <>0
>3ad092	45 58 49 54 00			TOKEN_TEXT  .null "EXIT"
>3a0dd8	20				precedence  .byte TOK_TY_STMNT | 0
>3a0dd9	04				length      .byte len("EXIT")
>3a0dda	92 d0				name        .word <>TOKEN_TEXT
>3a0ddc	4a 41				eval        .word <>S_EXIT
>3a0dde	00 00				arity       .word <>0
>3ad097	43 4c 52 00			TOKEN_TEXT  .null "CLR"
>3a0de0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0de1	03				length      .byte len("CLR")
>3a0de2	97 d0				name        .word <>TOKEN_TEXT
>3a0de4	82 44				eval        .word <>S_CLR
>3a0de6	00 00				arity       .word <>0
>3ad09b	53 54 4f 50 00			TOKEN_TEXT  .null "STOP"
>3a0de8	20				precedence  .byte TOK_TY_STMNT | 0
>3a0de9	04				length      .byte len("STOP")
>3a0dea	9b d0				name        .word <>TOKEN_TEXT
>3a0dec	1d 41				eval        .word <>S_STOP
>3a0dee	00 00				arity       .word <>0
>3ad0a0	50 4f 4b 45 00			TOKEN_TEXT  .null "POKE"
>3a0df0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0df1	04				length      .byte len("POKE")
>3a0df2	a0 d0				name        .word <>TOKEN_TEXT
>3a0df4	ad 40				eval        .word <>S_POKE
>3a0df6	00 00				arity       .word <>0
>3ad0a5	50 4f 4b 45 57 00		TOKEN_TEXT  .null "POKEW"
>3a0df8	20				precedence  .byte TOK_TY_STMNT | 0
>3a0df9	05				length      .byte len("POKEW")
>3a0dfa	a5 d0				name        .word <>TOKEN_TEXT
>3a0dfc	43 40				eval        .word <>S_POKEW
>3a0dfe	00 00				arity       .word <>0
>3ad0ab	50 4f 4b 45 4c 00		TOKEN_TEXT  .null "POKEL"
>3a0e00	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e01	05				length      .byte len("POKEL")
>3a0e02	ab d0				name        .word <>TOKEN_TEXT
>3a0e04	d0 3f				eval        .word <>S_POKEL
>3a0e06	00 00				arity       .word <>0
>3ad0b1	43 4c 53 00			TOKEN_TEXT  .null "CLS"
>3a0e08	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e09	03				length      .byte len("CLS")
>3a0e0a	b1 d0				name        .word <>TOKEN_TEXT
>3a0e0c	cc 3f				eval        .word <>S_CLS
>3a0e0e	00 00				arity       .word <>0
>3ad0b5	52 45 41 44 00			TOKEN_TEXT  .null "READ"
>3a0e10	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e11	04				length      .byte len("READ")
>3a0e12	b5 d0				name        .word <>TOKEN_TEXT
>3a0e14	ad 3e				eval        .word <>S_READ
>3a0e16	00 00				arity       .word <>0
=$ab					TOK_DATA = $AB
>3ad0ba	44 41 54 41 00			TOKEN_TEXT  .null "DATA"
>3a0e18	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e19	04				length      .byte len("DATA")
>3a0e1a	ba d0				name        .word <>TOKEN_TEXT
>3a0e1c	bf 3f				eval        .word <>S_DATA
>3a0e1e	00 00				arity       .word <>0
>3ad0bf	52 45 53 54 4f 52 45 00		TOKEN_TEXT  .null "RESTORE"
>3a0e20	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e21	07				length      .byte len("RESTORE")
>3a0e22	bf d0				name        .word <>TOKEN_TEXT
>3a0e24	c3 3f				eval        .word <>S_RESTORE
>3a0e26	00 00				arity       .word <>0
>3ad0c7	44 49 4d 00			TOKEN_TEXT  .null "DIM"
>3a0e28	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e29	03				length      .byte len("DIM")
>3a0e2a	c7 d0				name        .word <>TOKEN_TEXT
>3a0e2c	00 3e				eval        .word <>S_DIM
>3a0e2e	00 00				arity       .word <>0
>3ad0cb	43 41 4c 4c 00			TOKEN_TEXT  .null "CALL"
>3a0e30	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e31	04				length      .byte len("CALL")
>3a0e32	cb d0				name        .word <>TOKEN_TEXT
>3a0e34	69 3d				eval        .word <>S_CALL
>3a0e36	00 00				arity       .word <>0
=$af					TOK_NEGATIVE = $AF
>3ad0d0	2d 00				TOKEN_TEXT  .null "-"
>3a0e38	00				precedence  .byte TOK_TY_OP | 0
>3a0e39	01				length      .byte len("-")
>3a0e3a	d0 d0				name        .word <>TOKEN_TEXT
>3a0e3c	69 2a				eval        .word <>OP_NEGATIVE
>3a0e3e	01 00				arity       .word <>1
>3ad0d2	4c 45 4e 00			TOKEN_TEXT  .null "LEN"
>3a0e40	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e41	03				length      .byte len("LEN")
>3a0e42	d2 d0				name        .word <>TOKEN_TEXT
>3a0e44	35 4b				eval        .word <>FN_LEN
>3a0e46	00 00				arity       .word <>0
>3ad0d6	50 45 45 4b 00			TOKEN_TEXT  .null "PEEK"
>3a0e48	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e49	04				length      .byte len("PEEK")
>3a0e4a	d6 d0				name        .word <>TOKEN_TEXT
>3a0e4c	85 4b				eval        .word <>FN_PEEK
>3a0e4e	00 00				arity       .word <>0
>3ad0db	50 45 45 4b 57 00		TOKEN_TEXT  .null "PEEKW"
>3a0e50	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e51	05				length      .byte len("PEEKW")
>3a0e52	db d0				name        .word <>TOKEN_TEXT
>3a0e54	37 4c				eval        .word <>FN_PEEKW
>3a0e56	00 00				arity       .word <>0
>3ad0e1	50 45 45 4b 4c 00		TOKEN_TEXT  .null "PEEKL"
>3a0e58	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e59	05				length      .byte len("PEEKL")
>3a0e5a	e1 d0				name        .word <>TOKEN_TEXT
>3a0e5c	e9 4b				eval        .word <>FN_PEEKL
>3a0e5e	00 00				arity       .word <>0
>3ad0e7	43 48 52 24 00			TOKEN_TEXT  .null "CHR$"
>3a0e60	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e61	04				length      .byte len("CHR$")
>3a0e62	e7 d0				name        .word <>TOKEN_TEXT
>3a0e64	76 4c				eval        .word <>FN_CHR
>3a0e66	00 00				arity       .word <>0
>3ad0ec	41 53 43 00			TOKEN_TEXT  .null "ASC"
>3a0e68	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e69	03				length      .byte len("ASC")
>3a0e6a	ec d0				name        .word <>TOKEN_TEXT
>3a0e6c	cb 4c				eval        .word <>FN_ASC
>3a0e6e	00 00				arity       .word <>0
>3ad0f0	53 50 43 00			TOKEN_TEXT  .null "SPC"
>3a0e70	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e71	03				length      .byte len("SPC")
>3a0e72	f0 d0				name        .word <>TOKEN_TEXT
>3a0e74	10 4d				eval        .word <>FN_SPC
>3a0e76	00 00				arity       .word <>0
>3ad0f4	54 41 42 00			TOKEN_TEXT  .null "TAB"
>3a0e78	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e79	03				length      .byte len("TAB")
>3a0e7a	f4 d0				name        .word <>TOKEN_TEXT
>3a0e7c	99 4d				eval        .word <>FN_TAB
>3a0e7e	00 00				arity       .word <>0
>3ad0f8	41 42 53 00			TOKEN_TEXT  .null "ABS"
>3a0e80	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e81	03				length      .byte len("ABS")
>3a0e82	f8 d0				name        .word <>TOKEN_TEXT
>3a0e84	22 4e				eval        .word <>FN_ABS
>3a0e86	00 00				arity       .word <>0
>3ad0fc	53 47 4e 00			TOKEN_TEXT  .null "SGN"
>3a0e88	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e89	03				length      .byte len("SGN")
>3a0e8a	fc d0				name        .word <>TOKEN_TEXT
>3a0e8c	84 4e				eval        .word <>FN_SGN
>3a0e8e	00 00				arity       .word <>0
>3ad100	48 45 58 24 00			TOKEN_TEXT  .null "HEX$"
>3a0e90	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e91	04				length      .byte len("HEX$")
>3a0e92	00 d1				name        .word <>TOKEN_TEXT
>3a0e94	a7 4a				eval        .word <>FN_HEX
>3a0e96	00 00				arity       .word <>0
>3ad105	44 45 43 00			TOKEN_TEXT  .null "DEC"
>3a0e98	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e99	03				length      .byte len("DEC")
>3a0e9a	05 d1				name        .word <>TOKEN_TEXT
>3a0e9c	46 4a				eval        .word <>FN_DEC
>3a0e9e	00 00				arity       .word <>0
>3ad109	53 54 52 24 00			TOKEN_TEXT  .null "STR$"
>3a0ea0	30				precedence  .byte TOK_TY_FUNC | 0
>3a0ea1	04				length      .byte len("STR$")
>3a0ea2	09 d1				name        .word <>TOKEN_TEXT
>3a0ea4	f8 49				eval        .word <>FN_STR
>3a0ea6	00 00				arity       .word <>0
>3ad10e	56 41 4c 00			TOKEN_TEXT  .null "VAL"
>3a0ea8	30				precedence  .byte TOK_TY_FUNC | 0
>3a0ea9	03				length      .byte len("VAL")
>3a0eaa	0e d1				name        .word <>TOKEN_TEXT
>3a0eac	a2 49				eval        .word <>FN_VAL
>3a0eae	00 00				arity       .word <>0
>3ad112	4c 45 46 54 24 00		TOKEN_TEXT  .null "LEFT$"
>3a0eb0	30				precedence  .byte TOK_TY_FUNC | 0
>3a0eb1	05				length      .byte len("LEFT$")
>3a0eb2	12 d1				name        .word <>TOKEN_TEXT
>3a0eb4	d9 48				eval        .word <>FN_LEFT
>3a0eb6	00 00				arity       .word <>0
>3ad118	52 49 47 48 54 24 00		TOKEN_TEXT  .null "RIGHT$"
>3a0eb8	30				precedence  .byte TOK_TY_FUNC | 0
>3a0eb9	06				length      .byte len("RIGHT$")
>3a0eba	18 d1				name        .word <>TOKEN_TEXT
>3a0ebc	f8 47				eval        .word <>FN_RIGHT
>3a0ebe	00 00				arity       .word <>0
>3ad11f	4d 49 44 24 00			TOKEN_TEXT  .null "MID$"
>3a0ec0	30				precedence  .byte TOK_TY_FUNC | 0
>3a0ec1	04				length      .byte len("MID$")
>3a0ec2	1f d1				name        .word <>TOKEN_TEXT
>3a0ec4	43 47				eval        .word <>FN_MID
>3a0ec6	00 00				arity       .word <>0
>3ad124	52 55 4e 00			TOKEN_TEXT  .null "RUN"
>3a0ec8	10				precedence  .byte TOK_TY_CMD | 0
>3a0ec9	03				length      .byte len("RUN")
>3a0eca	24 d1				name        .word <>TOKEN_TEXT
>3a0ecc	eb 4f				eval        .word <>CMD_RUN
>3a0ece	00 00				arity       .word <>0
>3ad128	4e 45 57 00			TOKEN_TEXT  .null "NEW"
>3a0ed0	10				precedence  .byte TOK_TY_CMD | 0
>3a0ed1	03				length      .byte len("NEW")
>3a0ed2	28 d1				name        .word <>TOKEN_TEXT
>3a0ed4	b6 4f				eval        .word <>CMD_NEW
>3a0ed6	00 00				arity       .word <>0
>3ad12c	4c 4f 41 44 00			TOKEN_TEXT  .null "LOAD"
>3a0ed8	10				precedence  .byte TOK_TY_CMD | 0
>3a0ed9	04				length      .byte len("LOAD")
>3a0eda	2c d1				name        .word <>TOKEN_TEXT
>3a0edc	bf 6b				eval        .word <>CMD_LOAD
>3a0ede	00 00				arity       .word <>0
>3ad131	4c 49 53 54 00			TOKEN_TEXT  .null "LIST"
>3a0ee0	10				precedence  .byte TOK_TY_CMD | 0
>3a0ee1	04				length      .byte len("LIST")
>3a0ee2	31 d1				name        .word <>TOKEN_TEXT
>3a0ee4	02 50				eval        .word <>CMD_LIST
>3a0ee6	00 00				arity       .word <>0
>3ad136	44 49 52 00			TOKEN_TEXT  .null "DIR"
>3a0ee8	10				precedence  .byte TOK_TY_CMD | 0
>3a0ee9	03				length      .byte len("DIR")
>3a0eea	36 d1				name        .word <>TOKEN_TEXT
>3a0eec	e6 68				eval        .word <>CMD_DIR
>3a0eee	00 00				arity       .word <>0
>3ad13a	42 4c 4f 41 44 00		TOKEN_TEXT  .null "BLOAD"
>3a0ef0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ef1	05				length      .byte len("BLOAD")
>3a0ef2	3a d1				name        .word <>TOKEN_TEXT
>3a0ef4	91 6a				eval        .word <>S_BLOAD
>3a0ef6	00 00				arity       .word <>0
>3ad140	42 52 55 4e 00			TOKEN_TEXT  .null "BRUN"
>3a0ef8	10				precedence  .byte TOK_TY_CMD | 0
>3a0ef9	04				length      .byte len("BRUN")
>3a0efa	40 d1				name        .word <>TOKEN_TEXT
>3a0efc	6c 6b				eval        .word <>CMD_BRUN
>3a0efe	00 00				arity       .word <>0
>3ad145	42 53 41 56 45 00		TOKEN_TEXT  .null "BSAVE"
>3a0f00	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f01	05				length      .byte len("BSAVE")
>3a0f02	45 d1				name        .word <>TOKEN_TEXT
>3a0f04	78 6c				eval        .word <>S_BSAVE
>3a0f06	00 00				arity       .word <>0
>3ad14b	44 45 4c 00			TOKEN_TEXT  .null "DEL"
>3a0f08	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f09	03				length      .byte len("DEL")
>3a0f0a	4b d1				name        .word <>TOKEN_TEXT
>3a0f0c	97 6d				eval        .word <>S_DEL
>3a0f0e	00 00				arity       .word <>0
>3ad14f	53 41 56 45 00			TOKEN_TEXT  .null "SAVE"
>3a0f10	10				precedence  .byte TOK_TY_CMD | 0
>3a0f11	04				length      .byte len("SAVE")
>3a0f12	4f d1				name        .word <>TOKEN_TEXT
>3a0f14	04 6d				eval        .word <>CMD_SAVE
>3a0f16	00 00				arity       .word <>0
>3ad154	52 45 4e 41 4d 45 00		TOKEN_TEXT  .null "RENAME"
>3a0f18	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f19	06				length      .byte len("RENAME")
>3a0f1a	54 d1				name        .word <>TOKEN_TEXT
>3a0f1c	0d 6e				eval        .word <>S_RENAME
>3a0f1e	00 00				arity       .word <>0
>3ad15b	43 4f 50 59 00			TOKEN_TEXT  .null "COPY"
>3a0f20	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f21	04				length      .byte len("COPY")
>3a0f22	5b d1				name        .word <>TOKEN_TEXT
>3a0f24	31 6f				eval        .word <>S_COPY
>3a0f26	00 00				arity       .word <>0
>3ad160	4d 4f 4e 49 54 4f 52 00		TOKEN_TEXT  .null "MONITOR"
>3a0f28	10				precedence  .byte TOK_TY_CMD | 0
>3a0f29	07				length      .byte len("MONITOR")
>3a0f2a	60 d1				name        .word <>TOKEN_TEXT
>3a0f2c	b3 4f				eval        .word <>CMD_MONITOR
>3a0f2e	00 00				arity       .word <>0
>3ad168	47 45 54 00			TOKEN_TEXT  .null "GET"
>3a0f30	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f31	03				length      .byte len("GET")
>3a0f32	68 d1				name        .word <>TOKEN_TEXT
>3a0f34	f7 3c				eval        .word <>S_GET
>3a0f36	00 00				arity       .word <>0
>3ad16c	49 4e 50 55 54 00		TOKEN_TEXT  .null "INPUT"
>3a0f38	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f39	05				length      .byte len("INPUT")
>3a0f3a	6c d1				name        .word <>TOKEN_TEXT
>3a0f3c	07 3c				eval        .word <>S_INPUT
>3a0f3e	00 00				arity       .word <>0
>3ad172	53 45 54 42 4f 52 44 45		TOKEN_TEXT  .null "SETBORDER"
>3ad17a	52 00
>3a0f40	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f41	09				length      .byte len("SETBORDER")
>3a0f42	72 d1				name        .word <>TOKEN_TEXT
>3a0f44	28 2c				eval        .word <>S_SETBORDER
>3a0f46	00 00				arity       .word <>0
>3ad17c	54 45 58 54 43 4f 4c 4f		TOKEN_TEXT  .null "TEXTCOLOR"
>3ad184	52 00
>3a0f48	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f49	09				length      .byte len("TEXTCOLOR")
>3a0f4a	7c d1				name        .word <>TOKEN_TEXT
>3a0f4c	b5 2b				eval        .word <>S_TEXTCOLOR
>3a0f4e	00 00				arity       .word <>0
>3ad186	53 45 54 42 47 43 4f 4c		TOKEN_TEXT  .null "SETBGCOLOR"
>3ad18e	4f 52 00
>3a0f50	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f51	0a				length      .byte len("SETBGCOLOR")
>3a0f52	86 d1				name        .word <>TOKEN_TEXT
>3a0f54	e5 2b				eval        .word <>S_SETBGCOLOR
>3a0f56	00 00				arity       .word <>0
>3ad191	53 45 54 44 41 54 45 00		TOKEN_TEXT  .null "SETDATE"
>3a0f58	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f59	07				length      .byte len("SETDATE")
>3a0f5a	91 d1				name        .word <>TOKEN_TEXT
>3a0f5c	22 2b				eval        .word <>S_SETDATE
>3a0f5e	00 00				arity       .word <>0
>3ad199	47 45 54 44 41 54 45 24		TOKEN_TEXT  .null "GETDATE$"
>3ad1a1	00
>3a0f60	30				precedence  .byte TOK_TY_FUNC | 0
>3a0f61	08				length      .byte len("GETDATE$")
>3a0f62	99 d1				name        .word <>TOKEN_TEXT
>3a0f64	1e 46				eval        .word <>F_GETDATE
>3a0f66	00 00				arity       .word <>0
>3ad1a2	53 45 54 54 49 4d 45 00		TOKEN_TEXT  .null "SETTIME"
>3a0f68	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f69	07				length      .byte len("SETTIME")
>3a0f6a	a2 d1				name        .word <>TOKEN_TEXT
>3a0f6c	b7 2a				eval        .word <>S_SETTIME
>3a0f6e	00 00				arity       .word <>0
>3ad1aa	47 45 54 54 49 4d 45 24		TOKEN_TEXT  .null "GETTIME$"
>3ad1b2	00
>3a0f70	30				precedence  .byte TOK_TY_FUNC | 0
>3a0f71	08				length      .byte len("GETTIME$")
>3a0f72	aa d1				name        .word <>TOKEN_TEXT
>3a0f74	88 46				eval        .word <>F_GETTIME
>3a0f76	00 00				arity       .word <>0
>3ad1b3	47 52 41 50 48 49 43 53		TOKEN_TEXT  .null "GRAPHICS"
>3ad1bb	00
>3a0f78	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f79	08				length      .byte len("GRAPHICS")
>3a0f7a	b3 d1				name        .word <>TOKEN_TEXT
>3a0f7c	6d 2d				eval        .word <>S_GRAPHICS
>3a0f7e	00 00				arity       .word <>0
>3ad1bc	53 45 54 43 4f 4c 4f 52		TOKEN_TEXT  .null "SETCOLOR"
>3ad1c4	00
>3a0f80	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f81	08				length      .byte len("SETCOLOR")
>3a0f82	bc d1				name        .word <>TOKEN_TEXT
>3a0f84	a1 2c				eval        .word <>S_SETCOLOR
>3a0f86	00 00				arity       .word <>0
>3ad1c5	42 49 54 4d 41 50 00		TOKEN_TEXT  .null "BITMAP"
>3a0f88	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f89	06				length      .byte len("BITMAP")
>3a0f8a	c5 d1				name        .word <>TOKEN_TEXT
>3a0f8c	a7 2e				eval        .word <>S_BITMAP
>3a0f8e	00 00				arity       .word <>0
>3ad1cc	43 4c 52 42 49 54 4d 41		TOKEN_TEXT  .null "CLRBITMAP"
>3ad1d4	50 00
>3a0f90	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f91	09				length      .byte len("CLRBITMAP")
>3a0f92	cc d1				name        .word <>TOKEN_TEXT
>3a0f94	af 2f				eval        .word <>S_CLRBITMAP
>3a0f96	00 00				arity       .word <>0
>3ad1d6	50 4c 4f 54 00			TOKEN_TEXT  .null "PLOT"
>3a0f98	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f99	04				length      .byte len("PLOT")
>3a0f9a	d6 d1				name        .word <>TOKEN_TEXT
>3a0f9c	0c 31				eval        .word <>S_PLOT
>3a0f9e	00 00				arity       .word <>0
>3ad1db	4c 49 4e 45 00			TOKEN_TEXT  .null "LINE"
>3a0fa0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0fa1	04				length      .byte len("LINE")
>3a0fa2	db d1				name        .word <>TOKEN_TEXT
>3a0fa4	7d 31				eval        .word <>S_LINE
>3a0fa6	00 00				arity       .word <>0
>3ad1e0	46 49 4c 4c 00			TOKEN_TEXT  .null "FILL"
>3a0fa8	20				precedence  .byte TOK_TY_STMNT | 0
>3a0fa9	04				length      .byte len("FILL")
>3a0faa	e0 d1				name        .word <>TOKEN_TEXT
>3a0fac	16 32				eval        .word <>S_FILL
>3a0fae	00 00				arity       .word <>0
>3ad1e5	53 50 52 49 54 45 00		TOKEN_TEXT  .null "SPRITE"
>3a0fb0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0fb1	06				length      .byte len("SPRITE")
>3a0fb2	e5 d1				name        .word <>TOKEN_TEXT
>3a0fb4	52 33				eval        .word <>S_SPRITE
>3a0fb6	00 00				arity       .word <>0
>3ad1ec	53 50 52 49 54 45 41 54		TOKEN_TEXT  .null "SPRITEAT"
>3ad1f4	00
>3a0fb8	20				precedence  .byte TOK_TY_STMNT | 0
>3a0fb9	08				length      .byte len("SPRITEAT")
>3a0fba	ec d1				name        .word <>TOKEN_TEXT
>3a0fbc	f0 33				eval        .word <>S_SPRITEAT
>3a0fbe	00 00				arity       .word <>0
>3ad1f5	53 50 52 49 54 45 53 48		TOKEN_TEXT  .null "SPRITESHOW"
>3ad1fd	4f 57 00
>3a0fc0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0fc1	0a				length      .byte len("SPRITESHOW")
>3a0fc2	f5 d1				name        .word <>TOKEN_TEXT
>3a0fc4	3e 34				eval        .word <>S_SPRITESHOW
>3a0fc6	00 00				arity       .word <>0
>3ad200	54 49 4c 45 53 45 54 00		TOKEN_TEXT  .null "TILESET"
>3a0fc8	20				precedence  .byte TOK_TY_STMNT | 0
>3a0fc9	07				length      .byte len("TILESET")
>3a0fca	00 d2				name        .word <>TOKEN_TEXT
>3a0fcc	75 35				eval        .word <>S_TILESET
>3a0fce	00 00				arity       .word <>0
>3ad208	54 49 4c 45 4d 41 50 00		TOKEN_TEXT  .null "TILEMAP"
>3a0fd0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0fd1	07				length      .byte len("TILEMAP")
>3a0fd2	08 d2				name        .word <>TOKEN_TEXT
>3a0fd4	f3 35				eval        .word <>S_TILEMAP
>3a0fd6	00 00				arity       .word <>0
>3ad210	54 49 4c 45 53 48 4f 57		TOKEN_TEXT  .null "TILESHOW"
>3ad218	00
>3a0fd8	20				precedence  .byte TOK_TY_STMNT | 0
>3a0fd9	08				length      .byte len("TILESHOW")
>3a0fda	10 d2				name        .word <>TOKEN_TEXT
>3a0fdc	65 36				eval        .word <>S_TILESHOW
>3a0fde	00 00				arity       .word <>0
>3ad219	54 49 4c 45 41 54 00		TOKEN_TEXT  .null "TILEAT"
>3a0fe0	20				precedence  .byte TOK_TY_STMNT | 0
>3a0fe1	06				length      .byte len("TILEAT")
>3a0fe2	19 d2				name        .word <>TOKEN_TEXT
>3a0fe4	a2 36				eval        .word <>S_TILEAT
>3a0fe6	00 00				arity       .word <>0
>3ad220	4d 45 4d 43 4f 50 59 00		TOKEN_TEXT  .null "MEMCOPY"
>3a0fe8	20				precedence  .byte TOK_TY_STMNT | 0
>3a0fe9	07				length      .byte len("MEMCOPY")
>3a0fea	20 d2				name        .word <>TOKEN_TEXT
>3a0fec	d2 39				eval        .word <>S_MEMCOPY
>3a0fee	00 00				arity       .word <>0
=$e6					TOK_LINEAR = $E6
>3ad228	4c 49 4e 45 41 52 00		TOKEN_TEXT  .null "LINEAR"
>3a0ff0	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0ff1	06				length      .byte len("LINEAR")
>3a0ff2	28 d2				name        .word <>TOKEN_TEXT
>3a0ff4	00 00				eval        .word <>0
>3a0ff6	00 00				arity       .word <>0
=$e7					TOK_RECT = $E7
>3ad22f	52 45 43 54 00			TOKEN_TEXT  .null "RECT"
>3a0ff8	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0ff9	04				length      .byte len("RECT")
>3a0ffa	2f d2				name        .word <>TOKEN_TEXT
>3a0ffc	00 00				eval        .word <>0
>3a0ffe	00 00				arity       .word <>0
>3ad234	4c 4f 43 41 54 45 00		TOKEN_TEXT  .null "LOCATE"
>3a1000	20				precedence  .byte TOK_TY_STMNT | 0
>3a1001	06				length      .byte len("LOCATE")
>3a1002	34 d2				name        .word <>TOKEN_TEXT
>3a1004	e7 3b				eval        .word <>S_LOCATE
>3a1006	00 00				arity       .word <>0
>3ad23b	49 4e 54 00			TOKEN_TEXT  .null "INT"
>3a1008	30				precedence  .byte TOK_TY_FUNC | 0
>3a1009	03				length      .byte len("INT")
>3a100a	3b d2				name        .word <>TOKEN_TEXT
>3a100c	da 4e				eval        .word <>FN_INT
>3a100e	00 00				arity       .word <>0
>3ad23f	52 4e 44 00			TOKEN_TEXT  .null "RND"
>3a1010	30				precedence  .byte TOK_TY_FUNC | 0
>3a1011	03				length      .byte len("RND")
>3a1012	3f d2				name        .word <>TOKEN_TEXT
>3a1014	ed 46				eval        .word <>FN_RND
>3a1016	00 00				arity       .word <>0
>3ad243	53 49 4e 00			TOKEN_TEXT  .null "SIN"
>3a1018	30				precedence  .byte TOK_TY_FUNC | 0
>3a1019	03				length      .byte len("SIN")
>3a101a	43 d2				name        .word <>TOKEN_TEXT
>3a101c	ed 4e				eval        .word <>FN_SIN
>3a101e	00 00				arity       .word <>0
>3ad247	43 4f 53 00			TOKEN_TEXT  .null "COS"
>3a1020	30				precedence  .byte TOK_TY_FUNC | 0
>3a1021	03				length      .byte len("COS")
>3a1022	47 d2				name        .word <>TOKEN_TEXT
>3a1024	03 4f				eval        .word <>FN_COS
>3a1026	00 00				arity       .word <>0
>3ad24b	54 41 4e 00			TOKEN_TEXT  .null "TAN"
>3a1028	30				precedence  .byte TOK_TY_FUNC | 0
>3a1029	03				length      .byte len("TAN")
>3a102a	4b d2				name        .word <>TOKEN_TEXT
>3a102c	19 4f				eval        .word <>FN_TAN
>3a102e	00 00				arity       .word <>0
>3ad24f	4c 4e 00			TOKEN_TEXT  .null "LN"
>3a1030	30				precedence  .byte TOK_TY_FUNC | 0
>3a1031	02				length      .byte len("LN")
>3a1032	4f d2				name        .word <>TOKEN_TEXT
>3a1034	2f 4f				eval        .word <>FN_LN
>3a1036	00 00				arity       .word <>0
>3ad252	41 43 4f 53 00			TOKEN_TEXT  .null "ACOS"
>3a1038	30				precedence  .byte TOK_TY_FUNC | 0
>3a1039	04				length      .byte len("ACOS")
>3a103a	52 d2				name        .word <>TOKEN_TEXT
>3a103c	45 4f				eval        .word <>FN_ACOS
>3a103e	00 00				arity       .word <>0
>3ad257	41 53 49 4e 00			TOKEN_TEXT  .null "ASIN"
>3a1040	30				precedence  .byte TOK_TY_FUNC | 0
>3a1041	04				length      .byte len("ASIN")
>3a1042	57 d2				name        .word <>TOKEN_TEXT
>3a1044	5b 4f				eval        .word <>FN_ASIN
>3a1046	00 00				arity       .word <>0
>3ad25c	41 54 41 4e 00			TOKEN_TEXT  .null "ATAN"
>3a1048	30				precedence  .byte TOK_TY_FUNC | 0
>3a1049	04				length      .byte len("ATAN")
>3a104a	5c d2				name        .word <>TOKEN_TEXT
>3a104c	71 4f				eval        .word <>FN_ATAN
>3a104e	00 00				arity       .word <>0
>3ad261	45 58 50 00			TOKEN_TEXT  .null "EXP"
>3a1050	30				precedence  .byte TOK_TY_FUNC | 0
>3a1051	03				length      .byte len("EXP")
>3a1052	61 d2				name        .word <>TOKEN_TEXT
>3a1054	87 4f				eval        .word <>FN_EXP
>3a1056	00 00				arity       .word <>0
>3ad265	53 51 52 00			TOKEN_TEXT  .null "SQR"
>3a1058	30				precedence  .byte TOK_TY_FUNC | 0
>3a1059	03				length      .byte len("SQR")
>3a105a	65 d2				name        .word <>TOKEN_TEXT
>3a105c	9d 4f				eval        .word <>FN_SQR
>3a105e	00 00				arity       .word <>0
>3a1060	00 00 00 00 00 00 00 00		            .word 0, 0, 0, 0

;******  Return to file: src\basic816.s


;******  Processing file: src\heap.s

>08b7					ALLOCATED   .long ?     ; Pointer to the most recently allocated object
>08ba					HEAP        .long ?     ; Pointer to the top of the heap (next empty byte)
>08bd					FREED       .long ?     ; Pointer to a linked list of freed heap objects
>08c0					CURRBLOCK   .long ?     ; Pointer to the current heap allocated block
>08c3					CURRHEADER  .long ?     ; Pointer to the header of the current block
>08c6					CURREND     .long ?     ; Pointer to the byte immediately after the current block
>08c9					CURRFREED   .long ?     ; Pointer to the current freed block
>08cc					FREEDEND    .long ?     ; Pointer to the byte immediately after the current freed block
>08cf					LASTFREED   .long ?     ;
.0000					HEAPOBJ
>0000					TYPE        .byte ?     ; Code for the type of object allocated
>0001					COUNT       .byte ?     ; Number of references to the heap object
>0002					NEXT        .long ?     ; Pointer to the next object in the list (used when freed)
>0005					END         .long ?     ; Pointer to the next byte after the block
.3a1068					INITHEAP
.3a1068	08		php		            PHP
.3a1069	0b		phd		            PHD
.3a106a	08		php		            PHP
.3a106b	c2 20		rep #$20	            REP #$20
.3a106d	48		pha		            PHA
.3a106e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1071	5b		tcd		            TCD
.3a1072	68		pla		            PLA
.3a1073	28		plp		            PLP
.3a1074	c2 30		rep #$30	            REP #$30
.3a1076	a9 ff ff	lda #$ffff	            LDA #<>HEAP_TOP         ; Set the HEAP to the top
.3a1079	85 ba		sta $08ba	            STA HEAP
.3a107b	e2 20		sep #$20	            SEP #$20
.3a107d	a9 37		lda #$37	            LDA #`HEAP_TOP
.3a107f	85 bc		sta $08bc	            STA HEAP+2
.3a1081	c2 20		rep #$20	            REP #$20
.3a1083	64 b7		stz $08b7	            STZ ALLOCATED           ; And clear the pointer to the allocated objects
.3a1085	64 bd		stz $08bd	            STZ FREED               ; as well as the list of freed objects
.3a1087	e2 20		sep #$20	            SEP #$20
.3a1089	64 b9		stz $08b9	            STZ ALLOCATED+2
.3a108b	64 bf		stz $08bf	            STZ FREED+2
.3a108d	2b		pld		            PLD
.3a108e	28		plp		            PLP
.3a108f	60		rts		            RTS
.3a1090					ALLOC
.3a1090	5a		phy		            PHY
.3a1091	08		php		            PHP
.3a1092	e2 20		sep #$20	            SEP #$20
.3a1094	85 ea		sta $08ea	            STA TOFINDTYPE      ; Save the type of the block to TOFINDTYPE
.3a1096	c2 10		rep #$10	            REP #$10
.3a1098	86 8f		stx $088f	            STX MCOUNT           ; And the length of the block needed to MCOUNT
.3a109a	c2 20		rep #$20	            REP #$20
.3a109c	a5 0e		lda $080e	            LDA SCRATCH+2
.3a109e	48		pha		            PHA
.3a109f	a5 0c		lda $080c	            LDA SCRATCH
.3a10a1	48		pha		            PHA
.3a10a2	a5 12		lda $0812	            LDA SCRATCH2+2
.3a10a4	48		pha		            PHA
.3a10a5	a5 10		lda $0810	            LDA SCRATCH2
.3a10a7	48		pha		            PHA
.3a10a8	20 40 11	jsr $3a1140	            JSR ALLOCFREED
.3a10ab	b0 03		bcs $3a10b0	            BCS done            ; Return, if we got something back
.3a10ad	20 c4 10	jsr $3a10c4	            JSR ALLOCHEAP
.3a10b0					done
.3a10b0	20 cc 12	jsr $3a12cc	            JSR HEAP_GETHED
.3a10b3	c2 20		rep #$20	            REP #$20
.3a10b5	68		pla		            PLA
.3a10b6	85 10		sta $0810	            STA SCRATCH2
.3a10b8	68		pla		            PLA
.3a10b9	85 12		sta $0812	            STA SCRATCH2+2
.3a10bb	68		pla		            PLA
.3a10bc	85 0c		sta $080c	            STA SCRATCH
.3a10be	68		pla		            PLA
.3a10bf	85 0e		sta $080e	            STA SCRATCH+2
.3a10c1	28		plp		            PLP
.3a10c2	7a		ply		            PLY
.3a10c3	60		rts		            RTS
.3a10c4					ALLOCHEAP
.3a10c4	08		php		            PHP
.3a10c5	0b		phd		            PHD
.3a10c6	08		php		            PHP
.3a10c7	c2 20		rep #$20	            REP #$20
.3a10c9	48		pha		            PHA
.3a10ca	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a10cd	5b		tcd		            TCD
.3a10ce	68		pla		            PLA
.3a10cf	28		plp		            PLP
.3a10d0	e2 20		sep #$20	            SEP #$20
.3a10d2	a6 8f		ldx $088f	            LDX MCOUNT
.3a10d4	ca		dex		            DEX
.3a10d5	86 0c		stx $080c	            STX SCRATCH             ; SCRATCH := size - 1
.3a10d7	e8		inx		            INX
.3a10d8	c2 30		rep #$30	            REP #$30
.3a10da	38		sec		            SEC
.3a10db	a5 ba		lda $08ba	            LDA HEAP
.3a10dd	e5 0c		sbc $080c	            SBC SCRATCH
.3a10df	85 c0		sta $08c0	            STA CURRBLOCK
.3a10e1	e2 20		sep #$20	            SEP #$20
.3a10e3	a5 bc		lda $08bc	            LDA HEAP+2
.3a10e5	e9 00		sbc #$00	            SBC #0
.3a10e7	85 c2		sta $08c2	            STA CURRBLOCK+2
.3a10e9	20 cc 12	jsr $3a12cc	            JSR HEAP_GETHED
.3a10ec	e2 20		sep #$20	            SEP #$20
.3a10ee	a5 ea		lda $08ea	            LDA TOFINDTYPE
.3a10f0	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE       ; Set the type of the object
.3a10f3	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a10f5	a9 00		lda #$00	            LDA #0                  ; Set the count to zero
.3a10f7	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.3a10fa	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a10fc	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a10ff	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1101	c2 20		rep #$20	            REP #$20
.3a1103	a9 00 00	lda #$0000	            LDA #0
.3a1106	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1108	c2 20		rep #$20	            REP #$20
.3a110a	18		clc		            CLC
.3a110b	a5 ba		lda $08ba	            LDA HEAP
.3a110d	69 01 00	adc #$0001	            ADC #1
.3a1110	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; To get the address of the next byte
.3a1113	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y      ; after the block
.3a1115	e2 20		sep #$20	            SEP #$20
.3a1117	c8		iny		            INY
.3a1118	c8		iny		            INY
.3a1119	a5 bc		lda $08bc	            LDA HEAP+2
.3a111b	69 00		adc #$00	            ADC #0
.3a111d	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a111f	c2 20		rep #$20	            REP #$20
.3a1121	a5 c0		lda $08c0	            LDA CURRBLOCK
.3a1123	85 b7		sta $08b7	            STA ALLOCATED
.3a1125	e2 20		sep #$20	            SEP #$20
.3a1127	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.3a1129	85 b9		sta $08b9	            STA ALLOCATED+2
.3a112b	c2 20		rep #$20	            REP #$20
.3a112d	38		sec		            SEC                     ; Move the HEAP pointer to the first free byte under the header
.3a112e	a5 c3		lda $08c3	            LDA CURRHEADER
.3a1130	e9 01 00	sbc #$0001	            SBC #1
.3a1133	85 ba		sta $08ba	            STA HEAP
.3a1135	e2 20		sep #$20	            SEP #$20
.3a1137	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a1139	e9 00		sbc #$00	            SBC #0
.3a113b	85 bc		sta $08bc	            STA HEAP+2
.3a113d	2b		pld		            PLD
.3a113e	28		plp		            PLP
.3a113f	60		rts		            RTS
.3a1140					ALLOCFREED
.3a1140	08		php		            PHP
.3a1141	0b		phd		            PHD
.3a1142	08		php		            PHP
.3a1143	c2 20		rep #$20	            REP #$20
.3a1145	48		pha		            PHA
.3a1146	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1149	5b		tcd		            TCD
.3a114a	68		pla		            PLA
.3a114b	28		plp		            PLP
.3a114c	c2 30		rep #$30	            REP #$30
.3a114e	c2 20		rep #$20	            REP #$20
.3a1150	a5 bd		lda $08bd	            LDA FREED
.3a1152	85 c9		sta $08c9	            STA CURRFREED
.3a1154	e2 20		sep #$20	            SEP #$20
.3a1156	a5 bf		lda $08bf	            LDA FREED+2
.3a1158	85 cb		sta $08cb	            STA CURRFREED+2
.3a115a	a5 c9		lda $08c9	loop        LDA CURRFREED           ; Has anything been freed?
.3a115c	d0 17		bne $3a1175	            BNE has_block           ; Yes: check to see if there's a big enough block
.3a115e	e2 20		sep #$20	            SEP #$20
.3a1160	a5 cb		lda $08cb	            LDA CURRFREED+2
.3a1162	d0 11		bne $3a1175	            BNE has_block           ; Yes: check to see if there's a big enough block
.3a1164	c2 20		rep #$20	            REP #$20
.3a1166	a9 00 00	lda #$0000	            LDA #<>0
.3a1169	85 cf		sta $08cf	            STA LASTFREED
.3a116b	e2 20		sep #$20	            SEP #$20
.3a116d	a9 00		lda #$00	            LDA #`0
.3a116f	85 d1		sta $08d1	            STA LASTFREED+2
.3a1171	2b		pld		ret_false   PLD                     ; Return that we didn't find anything
.3a1172	28		plp		            PLP
.3a1173	18		clc		            CLC
.3a1174	60		rts		            RTS
.3a1175					has_block
.3a1175	c2 20		rep #$20	            REP #$20
.3a1177	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.3a117a	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a117c	85 cc		sta $08cc	            STA FREEDEND
.3a117e	e2 20		sep #$20	            SEP #$20
.3a1180	c8		iny		            INY
.3a1181	c8		iny		            INY
.3a1182	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a1184	85 ce		sta $08ce	            STA FREEDEND+2
.3a1186	c2 20		rep #$20	            REP #$20
.3a1188	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required
.3a1189	a5 c9		lda $08c9	            LDA CURRFREED
.3a118b	65 8f		adc $088f	            ADC MCOUNT
.3a118d	85 0c		sta $080c	            STA SCRATCH
.3a118f	e2 20		sep #$20	            SEP #$20
.3a1191	a5 cb		lda $08cb	            LDA CURRFREED+2
.3a1193	69 00		adc #$00	            ADC #0
.3a1195	85 0e		sta $080e	            STA SCRATCH+2
.3a1197	c2 20		rep #$20	            REP #$20
.3a1199	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required + size of header
.3a119a	a5 0c		lda $080c	            LDA SCRATCH                 ; (that is, it's a pointer to the byte immediately after the block desired)
.3a119c	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)
.3a119f	85 0c		sta $080c	            STA SCRATCH
.3a11a1	e2 20		sep #$20	            SEP #$20
.3a11a3	a5 0e		lda $080e	            LDA SCRATCH+2
.3a11a5	69 00		adc #$00	            ADC #0
.3a11a7	85 0e		sta $080e	            STA SCRATCH+2
.3a11a9	c2 20		rep #$20	            REP #$20
.3a11ab	a5 0c		lda $080c	            LDA SCRATCH                 ; Is SCRATCH == FREEDEND?
.3a11ad	c5 cc		cmp $08cc	            CMP FREEDEND
.3a11af	d0 28		bne $3a11d9	            BNE not_exact               ; No: check if this block is bigger than needed
.3a11b1	e2 20		sep #$20	            SEP #$20
.3a11b3	a5 0e		lda $080e	            LDA SCRATCH+2
.3a11b5	c5 ce		cmp $08ce	            CMP FREEDEND+2
.3a11b7	d0 20		bne $3a11d9	            BNE not_exact
.3a11b9	c2 20		rep #$20	            REP #$20
.3a11bb	a5 cf		lda $08cf	            LDA LASTFREED               ; LASTFREED == 0?
.3a11bd	d0 5d		bne $3a121c	            BNE adj_last1               ; No: point LASTFREED->NEXT to skip this block
.3a11bf	e2 20		sep #$20	            SEP #$20
.3a11c1	a5 d1		lda $08d1	            LDA LASTFREED+2
.3a11c3	d0 57		bne $3a121c	            BNE adj_last1
.3a11c5	c2 20		rep #$20	            REP #$20
.3a11c7	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a11ca	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a11cc	85 bd		sta $08bd	            STA FREED
.3a11ce	e2 20		sep #$20	            SEP #$20
.3a11d0	c8		iny		            INY
.3a11d1	c8		iny		            INY
.3a11d2	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a11d4	85 bf		sta $08bf	            STA FREED+2
.3a11d6	4c 7d 12	jmp $3a127d	            JMP init_block              ; And return CURRFREED as our reallocated memory
.3a11d9					not_exact
.3a11d9	c2 20		rep #$20	            REP #$20
.3a11db	a5 0c		lda $080c	            LDA SCRATCH                 ; Add a buffer to the room needed
.3a11dd	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)          ; So we have room to track the memory still freed
.3a11e0	85 10		sta $0810	            STA SCRATCH2
.3a11e2	e2 20		sep #$20	            SEP #$20
.3a11e4	a5 0e		lda $080e	            LDA SCRATCH+2
.3a11e6	69 00		adc #$00	            ADC #0
.3a11e8	85 12		sta $0812	            STA SCRATCH2+2
.3a11ea	e2 20		sep #$20	            SEP #$20
.3a11ec	a5 c6		lda $08c6	            LDA CURREND                 ; Is CURREND > SCRATCH2
.3a11ee	c5 10		cmp $0810	            CMP SCRATCH2
.3a11f0	b0 3e		bcs $3a1230	            BGE has_room                ; Yes: there is room in this block to allocate some memory
.3a11f2	90 08		bcc $3a11fc	            BLT try_next
.3a11f4	c2 20		rep #$20	            REP #$20
.3a11f6	a5 c6		lda $08c6	            LDA CURREND
.3a11f8	c5 10		cmp $0810	            CMP SCRATCH2
.3a11fa	b0 34		bcs $3a1230	            BGE has_room
.3a11fc					try_next
.3a11fc	c2 20		rep #$20	            REP #$20
.3a11fe	a5 c9		lda $08c9	            LDA CURRFREED
.3a1200	85 cf		sta $08cf	            STA LASTFREED
.3a1202	e2 20		sep #$20	            SEP #$20
.3a1204	a5 cb		lda $08cb	            LDA CURRFREED+2
.3a1206	85 d1		sta $08d1	            STA LASTFREED+2
.3a1208	c2 20		rep #$20	            REP #$20
.3a120a	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a120d	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.3a120f	85 c9		sta $08c9	            STA CURRFREED
.3a1211	e2 20		sep #$20	            SEP #$20
.3a1213	c8		iny		            INY
.3a1214	c8		iny		            INY
.3a1215	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.3a1217	85 cb		sta $08cb	            STA CURRFREED+2
.3a1219	4c 5a 11	jmp $3a115a	            JMP loop                                    ; And try the next header
.3a121c					adj_last1
.3a121c	c2 20		rep #$20	            REP #$20
.3a121e	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := CURRFREED->NEXT
.3a1221	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a1223	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.3a1225	e2 20		sep #$20	            SEP #$20
.3a1227	c8		iny		            INY
.3a1228	c8		iny		            INY
.3a1229	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a122b	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.3a122d	4c 7d 12	jmp $3a127d	            JMP init_block              ; And get CURRFREED ready to return
.3a1230					has_room
.3a1230	c2 20		rep #$20	            REP #$20
.3a1232	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END            ; SCRATCH->END := CURRFREED->END
.3a1235	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a1237	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.3a1239	e2 20		sep #$20	            SEP #$20
.3a123b	c8		iny		            INY
.3a123c	c8		iny		            INY
.3a123d	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a123f	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.3a1241	c2 20		rep #$20	            REP #$20
.3a1243	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; CURREND->NEXT := CURRFREED->NEXT
.3a1246	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a1248	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.3a124a	e2 20		sep #$20	            SEP #$20
.3a124c	c8		iny		            INY
.3a124d	c8		iny		            INY
.3a124e	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a1250	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.3a1252	c2 20		rep #$20	            REP #$20
.3a1254	a5 cf		lda $08cf	            LDA LASTFREED               ; Is this the first object we've examined?
.3a1256	d0 14		bne $3a126c	            BNE adj_last2               ; No: we'll need to adjust the previously examined block
.3a1258	e2 20		sep #$20	            SEP #$20
.3a125a	a5 cf		lda $08cf	            LDA LASTFREED
.3a125c	d0 0e		bne $3a126c	            BNE adj_last2
.3a125e	c2 20		rep #$20	            REP #$20
.3a1260	a5 0c		lda $080c	            LDA SCRATCH
.3a1262	85 bd		sta $08bd	            STA FREED
.3a1264	e2 20		sep #$20	            SEP #$20
.3a1266	a5 0e		lda $080e	            LDA SCRATCH+2
.3a1268	85 bf		sta $08bf	            STA FREED+2
.3a126a	80 11		bra $3a127d	            BRA init_block              ; ... and return the block we've sliced off
.3a126c					adj_last2
.3a126c	c2 20		rep #$20	            REP #$20
.3a126e	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := SCRATCH
.3a1271	a5 0c		lda $080c	            LDA SCRATCH                 ; (point the previous freed block to the newly sliced
.3a1273	97 cf		sta [$08cf],y	            STA [LASTFREED],Y           ;  off part of the current block)
.3a1275	e2 20		sep #$20	            SEP #$20
.3a1277	c8		iny		            INY
.3a1278	c8		iny		            INY
.3a1279	a5 0e		lda $080e	            LDA SCRATCH+2
.3a127b	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.3a127d					init_block
.3a127d	c2 20		rep #$20	            REP #$20
.3a127f	a5 c9		lda $08c9	            LDA CURRFREED
.3a1281	85 c3		sta $08c3	            STA CURRHEADER
.3a1283	e2 20		sep #$20	            SEP #$20
.3a1285	a5 cb		lda $08cb	            LDA CURRFREED+2
.3a1287	85 c5		sta $08c5	            STA CURRHEADER+2
.3a1289	c2 20		rep #$20	            REP #$20
.3a128b	a5 c3		lda $08c3	            LDA CURRHEADER
.3a128d	85 b7		sta $08b7	            STA ALLOCATED
.3a128f	e2 20		sep #$20	            SEP #$20
.3a1291	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a1293	85 b9		sta $08b9	            STA ALLOCATED+2
.3a1295	c2 20		rep #$20	            REP #$20
.3a1297	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; Set CURRHEADER->END to the byte after the block
.3a129a	a5 0c		lda $080c	            LDA SCRATCH
.3a129c	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a129e	e2 20		sep #$20	            SEP #$20
.3a12a0	c8		iny		            INY
.3a12a1	c8		iny		            INY
.3a12a2	a5 0e		lda $080e	            LDA SCRATCH+2
.3a12a4	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a12a6	c2 20		rep #$20	            REP #$20
.3a12a8	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Set CURRHEADER->NEXT to NULL
.3a12ab	a9 00 00	lda #$0000	            LDA #0
.3a12ae	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a12b0	e2 20		sep #$20	            SEP #$20
.3a12b2	c8		iny		            INY
.3a12b3	c8		iny		            INY
.3a12b4	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a12b6	e2 20		sep #$20	            SEP #$20
.3a12b8	a5 ea		lda $08ea	            LDA TOFINDTYPE          ; Get the type code back
.3a12ba	e2 20		sep #$20	            SEP #$20
.3a12bc	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE
.3a12bf	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a12c1	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT      ; Set its reference count to 0
.3a12c4	a9 00		lda #$00	            LDA #0
.3a12c6	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a12c8	2b		pld		done        PLD
.3a12c9	28		plp		            PLP
.3a12ca	38		sec		            SEC
.3a12cb	60		rts		            RTS
.3a12cc					HEAP_GETHED
.3a12cc	08		php		            PHP
.3a12cd	c2 20		rep #$20	            REP #$20
.3a12cf	38		sec		            SEC
.3a12d0	a5 c0		lda $08c0	            LDA CURRBLOCK
.3a12d2	e9 08 00	sbc #$0008	            SBC #size(HEAPOBJ)
.3a12d5	85 c3		sta $08c3	            STA CURRHEADER
.3a12d7	e2 20		sep #$20	            SEP #$20
.3a12d9	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.3a12db	e9 00		sbc #$00	            SBC #0
.3a12dd	85 c5		sta $08c5	            STA CURRHEADER+2
.3a12df	28		plp		            PLP
.3a12e0	60		rts		            RTS
.3a12e1					HEAP_ADDREF
.3a12e1	08		php		            PHP
.3a12e2	e2 20		sep #$20	            SEP #$20
.3a12e4	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a12e6	f0 04		beq $3a12ec	            BEQ chk_null
.3a12e8	c9 38		cmp #$38	            CMP #`(HEAP_TOP + 1)
.3a12ea	b0 12		bcs $3a12fe	            BGE out_of_bnds
.3a12ec					chk_null
.3a12ec	c2 20		rep #$20	            REP #$20
.3a12ee	a5 c3		lda $08c3	            LDA CURRHEADER
.3a12f0	f0 0c		beq $3a12fe	            BEQ out_of_bnds
.3a12f2					is_ok
.3a12f2	e2 20		sep #$20	            SEP #$20
.3a12f4	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.3a12f7	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a12f9	1a		inc a		            INC A
.3a12fa	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a12fc	28		plp		            PLP
.3a12fd	60		rts		            RTS
.3a12fe	00		brk #		out_of_bnds BRK
.3a12ff	ea		nop		            NOP
.3a1300					HEAP_REMREF
.3a1300	08		php		            PHP
.3a1301	e2 20		sep #$20	            SEP #$20
.3a1303	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a1305	f0 04		beq $3a130b	            BEQ chk_null
.3a1307	c9 38		cmp #$38	            CMP #`(HEAP_TOP + 1)
.3a1309	b0 17		bcs $3a1322	            BGE out_of_bnds
.3a130b					chk_null
.3a130b	c2 20		rep #$20	            REP #$20
.3a130d	a5 c3		lda $08c3	            LDA CURRHEADER
.3a130f	f0 11		beq $3a1322	            BEQ out_of_bnds
.3a1311	e2 20		sep #$20	            SEP #$20
.3a1313	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT  ; Decrement the reference count
.3a1316	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a1318	3a		dec a		            DEC A
.3a1319	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a131b	d0 03		bne $3a1320	            BNE done            ; If it's still >0, we are done
.3a131d	20 24 13	jsr $3a1324	            JSR HEAP_FREE
.3a1320	28		plp		done        PLP
.3a1321	60		rts		            RTS
.3a1322	00		brk #		out_of_bnds BRK
.3a1323	ea		nop		            NOP
.3a1324					HEAP_FREE
.3a1324	08		php		            PHP
.3a1325	c2 20		rep #$20	            REP #$20
.3a1327	a5 bd		lda $08bd	            LDA FREED           ; Check to see if blocks are already on the freed list
.3a1329	d0 21		bne $3a134c	            BNE has_objects
.3a132b	e2 20		sep #$20	            SEP #$20
.3a132d	a5 bf		lda $08bf	            LDA FREED+2
.3a132f	d0 1b		bne $3a134c	            BNE has_objects
.3a1331	a5 c5		lda $08c5	            LDA CURRHEADER+2    ; No: this block is the first one
.3a1333	85 bf		sta $08bf	            STA FREED+2         ; Just make it the freed list
.3a1335	c2 20		rep #$20	            REP #$20
.3a1337	a5 c3		lda $08c3	            LDA CURRHEADER
.3a1339	85 bd		sta $08bd	            STA FREED
.3a133b	a9 00 00	lda #$0000	            LDA #0
.3a133e	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT   ; And clear its next link
.3a1341	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1343	c8		iny		            INY
.3a1344	c8		iny		            INY
.3a1345	e2 20		sep #$20	            SEP #$20
.3a1347	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1349	4c 0b 14	jmp $3a140b	            JMP done
.3a134c					has_objects
.3a134c	e2 20		sep #$20	            SEP #$20
.3a134e	a5 bf		lda $08bf	            LDA FREED+2
.3a1350	c5 c5		cmp $08c5	            CMP CURRHEADER+2
.3a1352	90 28		bcc $3a137c	            BLT start_scan
.3a1354	c2 20		rep #$20	            REP #$20
.3a1356	a5 bd		lda $08bd	            LDA FREED
.3a1358	c5 c3		cmp $08c3	            CMP CURRHEADER
.3a135a	90 20		bcc $3a137c	            BLT start_scan
.3a135c					ins_first
.3a135c	c2 20		rep #$20	            REP #$20
.3a135e	a5 bd		lda $08bd	            LDA FREED               ; CURRHEADER->NEXT := FREED
.3a1360	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a1363	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1365	e2 20		sep #$20	            SEP #$20
.3a1367	c8		iny		            INY
.3a1368	c8		iny		            INY
.3a1369	a5 bf		lda $08bf	            LDA FREED+2
.3a136b	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a136d	c2 20		rep #$20	            REP #$20
.3a136f	a5 c3		lda $08c3	            LDA CURRHEADER
.3a1371	85 bd		sta $08bd	            STA FREED
.3a1373	e2 20		sep #$20	            SEP #$20
.3a1375	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a1377	85 bf		sta $08bf	            STA FREED+2
.3a1379	4c 0b 14	jmp $3a140b	            JMP done
.3a137c					start_scan
.3a137c	c2 20		rep #$20	            REP #$20
.3a137e	a5 bd		lda $08bd	            LDA FREED
.3a1380	85 08		sta $0808	            STA INDEX
.3a1382	e2 20		sep #$20	            SEP #$20
.3a1384	a5 bf		lda $08bf	            LDA FREED+2
.3a1386	85 0a		sta $080a	            STA INDEX+2
.3a1388					loop
.3a1388	e2 20		sep #$20	            SEP #$20
.3a138a	a0 04 00	ldy #$0004	            LDY #HEAPOBJ.NEXT+2
.3a138d	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a138f	c5 c8		cmp $08c8	            CMP CURREND+2
.3a1391	90 32		bcc $3a13c5	            BLT go_next             ; No: check the next spot
.3a1393	d0 0b		bne $3a13a0	            BNE ins_next
.3a1395	c2 20		rep #$20	            REP #$20
.3a1397	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a139a	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a139c	c5 c6		cmp $08c6	            CMP CURREND
.3a139e	90 25		bcc $3a13c5	            BLT go_next             ; No: check the next spot
.3a13a0					ins_next
.3a13a0	c2 20		rep #$20	            REP #$20
.3a13a2	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := INDEX->NEXT
.3a13a5	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a13a7	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a13a9	e2 20		sep #$20	            SEP #$20
.3a13ab	c8		iny		            INY
.3a13ac	c8		iny		            INY
.3a13ad	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a13af	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a13b1	c2 20		rep #$20	            REP #$20
.3a13b3	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.3a13b5	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a13b8	97 08		sta [$0808],y	            STA [INDEX],Y
.3a13ba	e2 20		sep #$20	            SEP #$20
.3a13bc	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a13be	c8		iny		            INY
.3a13bf	c8		iny		            INY
.3a13c0	97 08		sta [$0808],y	            STA [INDEX],Y
.3a13c2	4c 0b 14	jmp $3a140b	            JMP done
.3a13c5					go_next
.3a13c5	c2 20		rep #$20	            REP #$20
.3a13c7	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Is INDEX->NEXT = 0
.3a13ca	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a13cc	d0 08		bne $3a13d6	            BNE not_at_end          ; No: load up the next object
.3a13ce	e2 20		sep #$20	            SEP #$20
.3a13d0	c8		iny		            INY
.3a13d1	c8		iny		            INY
.3a13d2	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a13d4	f0 19		beq $3a13ef	            BEQ at_end
.3a13d6					not_at_end
.3a13d6	c2 20		rep #$20	            REP #$20
.3a13d8	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; INDEX := INDEX->NEXT
.3a13db	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a13dd	85 0c		sta $080c	            STA SCRATCH
.3a13df	e2 20		sep #$20	            SEP #$20
.3a13e1	c8		iny		            INY
.3a13e2	c8		iny		            INY
.3a13e3	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a13e5	85 0a		sta $080a	            STA INDEX+2
.3a13e7	c2 20		rep #$20	            REP #$20
.3a13e9	a5 0c		lda $080c	            LDA SCRATCH
.3a13eb	85 08		sta $0808	            STA INDEX
.3a13ed	80 99		bra $3a1388	            BRA loop
.3a13ef					at_end
.3a13ef	c2 20		rep #$20	            REP #$20
.3a13f1	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.3a13f3	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a13f6	97 08		sta [$0808],y	            STA [INDEX],Y
.3a13f8	e2 20		sep #$20	            SEP #$20
.3a13fa	c8		iny		            INY
.3a13fb	c8		iny		            INY
.3a13fc	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a13fe	97 08		sta [$0808],y	            STA [INDEX],Y
.3a1400	a9 00		lda #$00	            LDA #0                  ; CURRHEADER->NEXT := 0
.3a1402	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1404	c2 20		rep #$20	            REP #$20
.3a1406	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a1409	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a140b					done
.3a140b	20 10 14	jsr $3a1410	            JSR COALLESCE
.3a140e	28		plp		            PLP
.3a140f	60		rts		            RTS
.3a1410					COALLESCE
.3a1410	08		php		            PHP
.3a1411	c2 20		rep #$20	            REP #$20
.3a1413	a5 bd		lda $08bd	            LDA FREED
.3a1415	85 c3		sta $08c3	            STA CURRHEADER
.3a1417	e2 20		sep #$20	            SEP #$20
.3a1419	a5 bf		lda $08bf	            LDA FREED+2
.3a141b	85 c5		sta $08c5	            STA CURRHEADER+2
.3a141d					next_head
.3a141d	c2 20		rep #$20	            REP #$20
.3a141f	a5 c3		lda $08c3	            LDA CURRHEADER          ; Is CURRHEADER == 0?
.3a1421	d0 09		bne $3a142c	            BNE check_next          ; No: check if NEXT is contiguous
.3a1423	e2 20		sep #$20	            SEP #$20
.3a1425	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a1427	d0 03		bne $3a142c	            BNE check_next
.3a1429	4c b3 14	jmp $3a14b3	            JMP done                ; Yes: we're done
.3a142c					check_next
.3a142c	c2 20		rep #$20	            REP #$20
.3a142e	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a1431	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a1433	85 0c		sta $080c	            STA SCRATCH
.3a1435	e2 20		sep #$20	            SEP #$20
.3a1437	c8		iny		            INY
.3a1438	c8		iny		            INY
.3a1439	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a143b	85 0e		sta $080e	            STA SCRATCH+2
.3a143d	c2 20		rep #$20	            REP #$20
.3a143f	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.3a1442	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a1444	85 10		sta $0810	            STA SCRATCH2
.3a1446	e2 20		sep #$20	            SEP #$20
.3a1448	c8		iny		            INY
.3a1449	c8		iny		            INY
.3a144a	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a144c	85 12		sta $0812	            STA SCRATCH2+2
.3a144e	c2 20		rep #$20	            REP #$20
.3a1450	a5 0c		lda $080c	            LDA SCRATCH
.3a1452	c5 10		cmp $0810	            CMP SCRATCH2            ; Is CURRHEADER->END = CURRHEADER->NEXT?
.3a1454	d0 08		bne $3a145e	            BNE go_next             ; No: go to the next block
.3a1456	e2 20		sep #$20	            SEP #$20
.3a1458	a5 0e		lda $080e	            LDA SCRATCH+2
.3a145a	c5 12		cmp $0812	            CMP SCRATCH2+2
.3a145c	f0 1f		beq $3a147d	            BEQ combine             ; Yes: combine the two blocks
.3a145e					go_next
.3a145e	c2 20		rep #$20	            REP #$20
.3a1460	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a1463	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a1465	85 0c		sta $080c	            STA SCRATCH
.3a1467	e2 20		sep #$20	            SEP #$20
.3a1469	c8		iny		            INY
.3a146a	c8		iny		            INY
.3a146b	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a146d	85 0e		sta $080e	            STA SCRATCH+2
.3a146f	c2 20		rep #$20	            REP #$20
.3a1471	a5 0c		lda $080c	            LDA SCRATCH
.3a1473	85 c3		sta $08c3	            STA CURRHEADER
.3a1475	e2 20		sep #$20	            SEP #$20
.3a1477	a5 0e		lda $080e	            LDA SCRATCH+2
.3a1479	85 c5		sta $08c5	            STA CURRHEADER+2
.3a147b	80 a0		bra $3a141d	            BRA next_head                               ; And loop back to next_head
.3a147d					combine
.3a147d	c2 20		rep #$20	            REP #$20
.3a147f	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a1482	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a1484	85 0c		sta $080c	            STA SCRATCH
.3a1486	e2 20		sep #$20	            SEP #$20
.3a1488	c8		iny		            INY
.3a1489	c8		iny		            INY
.3a148a	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a148c	85 0e		sta $080e	            STA SCRATCH+2
.3a148e	c2 20		rep #$20	            REP #$20
.3a1490	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := SCRATCH->NEXT
.3a1493	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.3a1495	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1497	e2 20		sep #$20	            SEP #$20
.3a1499	c8		iny		            INY
.3a149a	c8		iny		            INY
.3a149b	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.3a149d	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a149f	c2 20		rep #$20	            REP #$20
.3a14a1	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END       ; CURRHEADER->END := SCRATCH->END
.3a14a4	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.3a14a6	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a14a8	e2 20		sep #$20	            SEP #$20
.3a14aa	c8		iny		            INY
.3a14ab	c8		iny		            INY
.3a14ac	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.3a14ae	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a14b0	4c 2c 14	jmp $3a142c	            JMP check_next          ; And loop back to check_next
.3a14b3	28		plp		done        PLP
.3a14b4	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\strings.s

.3a14b5					CLRTMPSTR
.3a14b5	08		php		            PHP
.3a14b6	c2 20		rep #$20	            REP #$20
.3a14b8	64 16		stz $0816	            STZ STRPTR
.3a14ba	64 18		stz $0818	            STZ STRPTR+2
.3a14bc	28		plp		            PLP
.3a14bd	60		rts		            RTS
.3a14be					TEMPSTRING
.3a14be	08		php		            PHP
.3a14bf	c2 30		rep #$30	            REP #$30
.3a14c1	a5 16		lda $0816	            LDA STRPTR          ; Is STRPTR == 0?
.3a14c3	d0 16		bne $3a14db	            BNE add_256         ; No: add 256 to it
.3a14c5	a5 18		lda $0818	            LDA STRPTR+2
.3a14c7	d0 12		bne $3a14db	            BNE add_256
.3a14c9	e2 20		sep #$20	            SEP #$20
.3a14cb	64 16		stz $0816	            STZ STRPTR
.3a14cd	a5 e2		lda $08e2	            LDA NEXTVAR+1
.3a14cf	1a		inc a		            INC A
.3a14d0	1a		inc a		            INC A
.3a14d1	85 17		sta $0817	            STA STRPTR+1
.3a14d3	a5 e3		lda $08e3	            LDA NEXTVAR+2
.3a14d5	85 18		sta $0818	            STA STRPTR+2
.3a14d7	64 19		stz $0819	            STZ STRPTR+3
.3a14d9	80 07		bra $3a14e2	            BRA chk_room
.3a14db					add_256
.3a14db	c2 20		rep #$20	            REP #$20
.3a14dd	a5 17		lda $0817	            LDA STRPTR+1        ; There was already a temporary string...
.3a14df	1a		inc a		            INC A               ; Leave 256 bytes for it
.3a14e0	85 17		sta $0817	            STA STRPTR+1
.3a14e2					chk_room
.3a14e2	c2 20		rep #$20	            REP #$20
.3a14e4	a5 bb		lda $08bb	            LDA HEAP+1          ; Check to make sure that STRPTR and HEAP haven't touched
.3a14e6	3a		dec a		            DEC A
.3a14e7	c5 17		cmp $0817	            CMP STRPTR+1
.3a14e9	f0 02		beq $3a14ed	            BEQ no_room         ; If they have, throw an error
.3a14eb	b0 1f		bcs $3a150c	            BGE done
.3a14ed					no_room
.3a14ed	08		php		            PHP
.3a14ee	c2 20		rep #$20	            REP #$20
.3a14f0	48		pha		            PHA
.3a14f1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a14f4	5b		tcd		            TCD
.3a14f5	68		pla		            PLA
.3a14f6	28		plp		            PLP
.3a14f7	e2 20		sep #$20	            SEP #$20
.3a14f9	a9 03		lda #$03	            LDA #ERR_MEMORY
.3a14fb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a14ff	c2 20		rep #$20	            REP #$20
.3a1501	29 ff 00	and #$00ff	            AND #$00FF
.3a1504	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a1507	e2 20		sep #$20	            SEP #$20
.3a1509	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a150c	28		plp		done        PLP
.3a150d	60		rts		            RTS
.3a150e					ITOS_DIGIT
.3a150e	c9 00		cmp #$00	            CMP #0          ; Is it 0?
.3a1510	d0 05		bne $3a1517	            BNE add_digit   ; No: go ahead and add it
.3a1512	c0 01 00	cpy #$0001	            CPY #1          ; Are we on the first digit?
.3a1515	f0 05		beq $3a151c	            BEQ done        ; Yes: ignore this leading 0
.3a1517	09 30		ora #$30	add_digit   ORA #$30        ; Convert it to ASCII
.3a1519	97 16		sta [$0816],y	            STA [STRPTR],Y  ; Save it to the string
.3a151b	c8		iny		            INY             ; And point to the next location
.3a151c					done
.3a151c	60		rts		            RTS
.3a151d					ITOS
.3a151d	08		php		            PHP
.3a151e	c2 30		rep #$30	            REP #$30
.3a1520	64 0c		stz $080c	            STZ SCRATCH         ; Use scratch to store if negative
.3a1522	a5 25		lda $0825	            LDA ARGUMENT1+2     ; Check to see if the number is negative
.3a1524	10 1a		bpl $3a1540	            BPL start_cnvt
.3a1526	18		clc		            CLC                 ; Yes: make ARGUMENT1 positive
.3a1527	a5 23		lda $0823	            LDA ARGUMENT1
.3a1529	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a152c	69 01 00	adc #$0001	            ADC #1
.3a152f	85 23		sta $0823	            STA ARGUMENT1
.3a1531	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a1533	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a1536	69 00 00	adc #$0000	            ADC #0
.3a1539	85 25		sta $0825	            STA ARGUMENT1+2
.3a153b	a9 ff ff	lda #$ffff	            LDA #$FFFF          ; Record that the number was negative
.3a153e	85 0c		sta $080c	            STA SCRATCH
.3a1540					start_cnvt
.3a1540	64 10		stz $0810	            STZ SCRATCH2        ; SCRATCH2 will be our BCD version of the number
.3a1542	64 12		stz $0812	            STZ SCRATCH2+2
.3a1544	64 14		stz $0814	            STZ SCRATCH2+4
.3a1546	a2 1f 00	ldx #$001f	            LDX #31
.3a1549	f8		sed		            SED                 ; Yes, we're really using BCD mode
.3a154a	06 23		asl $0823	shift_loop  ASL ARGUMENT1       ; Shift ARGUMENT1 left one bit
.3a154c	26 25		rol $0825	            ROL ARGUMENT1+2
.3a154e	a5 10		lda $0810	            LDA SCRATCH2        ; SCRATCH2 := SCRATCH2 + SCRATCH2 + Carry
.3a1550	65 10		adc $0810	            ADC SCRATCH2
.3a1552	85 10		sta $0810	            STA SCRATCH2
.3a1554	a5 12		lda $0812	            LDA SCRATCH2+2
.3a1556	65 12		adc $0812	            ADC SCRATCH2+2
.3a1558	85 12		sta $0812	            STA SCRATCH2+2
.3a155a	a5 14		lda $0814	            LDA SCRATCH2+4
.3a155c	65 14		adc $0814	            ADC SCRATCH2+4
.3a155e	85 14		sta $0814	            STA SCRATCH2+4
.3a1560	ca		dex		            DEX
.3a1561	10 e7		bpl $3a154a	            BPL shift_loop      ; Loop through all 32 bits of ARGUMENT1
.3a1563	d8		cld		            CLD                 ; Switch back out of BCD mode
.3a1564	e2 20		sep #$20	            SEP #$20
.3a1566	20 be 14	jsr $3a14be	            JSR TEMPSTRING
.3a1569	a0 00 00	ldy #$0000	            LDY #0              ; Y will be index into the temporary string
.3a156c	a5 0c		lda $080c	            LDA SCRATCH         ; Check to see if the number was negative
.3a156e	f0 04		beq $3a1574	            BEQ is_pos          ; No: write a leading space
.3a1570	a9 2d		lda #$2d	            LDA #'-'            ; If negative, write the minus sign
.3a1572	80 02		bra $3a1576	            BRA wr_lead
.3a1574	a9 20		lda #$20	is_pos      LDA #CHAR_SP        ; Write a leading space
.3a1576	97 16		sta [$0816],y	wr_lead     STA [STRPTR],Y
.3a1578	c8		iny		            INY
.3a1579	a2 05 00	ldx #$0005	            LDX #5
.3a157c	b5 10		lda $0810,x	ascii_loop  LDA SCRATCH2,X
.3a157e	29 f0		and #$f0	            AND #$F0
.3a1580	4a		lsr a		            LSR A
.3a1581	4a		lsr a		            LSR A
.3a1582	4a		lsr a		            LSR A
.3a1583	4a		lsr a		            LSR A
.3a1584	20 0e 15	jsr $3a150e	            JSR ITOS_DIGIT
.3a1587	b5 10		lda $0810,x	            LDA SCRATCH2,X
.3a1589	29 0f		and #$0f	            AND #$0F
.3a158b	20 0e 15	jsr $3a150e	            JSR ITOS_DIGIT
.3a158e	ca		dex		            DEX
.3a158f	10 eb		bpl $3a157c	            BPL ascii_loop
.3a1591	c0 01 00	cpy #$0001	            CPY #1              ; Did we write anything?
.3a1594	d0 0c		bne $3a15a2	            BNE null_term       ; Yes: add a NULL to terminate
.3a1596	a9 20		lda #$20	            LDA #' '            ; No: write a " 0" to the string
.3a1598	87 16		sta [$0816]	            STA [STRPTR]
.3a159a	a0 01 00	ldy #$0001	            LDY #1
.3a159d	a9 30		lda #$30	            LDA #'0'
.3a159f	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a15a1	c8		iny		            INY
.3a15a2	a9 00		lda #$00	null_term   LDA #0
.3a15a4	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And terminate the string
.3a15a6	28		plp		done        PLP
.3a15a7	60		rts		            RTS
.3a15a8	00		brk #		fault       BRK
.3a15a9	ea		nop		            NOP
.3a15aa					STRLEN
.3a15aa	08		php		            PHP
.3a15ab	e2 20		sep #$20	            SEP #$20
.3a15ad	c2 10		rep #$10	            REP #$10
.3a15af	a0 00 00	ldy #$0000	            LDY #0
.3a15b2	bd 00 00	lda $3a0000,x	loop        LDA #0,B,X
.3a15b5	f0 04		beq $3a15bb	            BEQ done
.3a15b7	e8		inx		            INX
.3a15b8	c8		iny		            INY
.3a15b9	80 f7		bra $3a15b2	            BRA loop
.3a15bb	28		plp		done        PLP
.3a15bc	60		rts		            RTS
.3a15bd					STRCMP
.3a15bd	08		php		            PHP
.3a15be	0b		phd		            PHD
.3a15bf	08		php		            PHP
.3a15c0	c2 20		rep #$20	            REP #$20
.3a15c2	48		pha		            PHA
.3a15c3	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a15c6	5b		tcd		            TCD
.3a15c7	68		pla		            PLA
.3a15c8	28		plp		            PLP
.3a15c9	e2 20		sep #$20	            SEP #$20
.3a15cb	c2 10		rep #$10	            REP #$10
.3a15cd	a0 00 00	ldy #$0000	            LDY #0
.3a15d0	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Check if the character 1 is 0
.3a15d2	d0 04		bne $3a15d8	            BNE comp_mag            ; If not, check the magnitudes
.3a15d4	b7 29		lda [$0829],y	            LDA [ARGUMENT2],Y       ; If so, check if the character 2 is 0
.3a15d6	f0 25		beq $3a15fd	            BEQ are_equal           ; If so, the strings are equal
.3a15d8	b7 23		lda [$0823],y	comp_mag    LDA [ARGUMENT1],Y       ; Otherwise, get character 1 again
.3a15da	d7 29		cmp [$0829],y	            CMP [ARGUMENT2],Y       ; And compare it to character 2
.3a15dc	90 12		bcc $3a15f0	            BLT is_less             ; Check if character 1 < character 2
.3a15de	d0 03		bne $3a15e3	            BNE is_greater          ; Check if character 1 > character 2
.3a15e0	c8		iny		            INY                     ; Equal so far... so go to the next pair of characters
.3a15e1	80 ed		bra $3a15d0	            BRA loop
.3a15e3					is_greater
.3a15e3	c2 20		rep #$20	            REP #$20
.3a15e5	a9 01 00	lda #$0001	            LDA #1                  ; So return 1
.3a15e8	85 23		sta $0823	            STA ARGUMENT1
.3a15ea	e2 20		sep #$20	            SEP #$20
.3a15ec	64 25		stz $0825	            STZ ARGUMENT1+2
.3a15ee	80 15		bra $3a1605	            BRA done
.3a15f0					is_less
.3a15f0	c2 20		rep #$20	            REP #$20
.3a15f2	a9 ff ff	lda #$ffff	            LDA #$FFFF              ; So return -1
.3a15f5	85 23		sta $0823	            STA ARGUMENT1
.3a15f7	e2 20		sep #$20	            SEP #$20
.3a15f9	85 25		sta $0825	            STA ARGUMENT1+2
.3a15fb	80 08		bra $3a1605	            BRA done
.3a15fd					are_equal
.3a15fd	c2 20		rep #$20	            REP #$20
.3a15ff	64 23		stz $0823	            STZ ARGUMENT1           ; So return 0
.3a1601	e2 20		sep #$20	            SEP #$20
.3a1603	64 25		stz $0825	            STZ ARGUMENT1+2
.3a1605					done
.3a1605	e2 20		sep #$20	            SEP #$20
.3a1607	a9 00		lda #$00	            LDA #TYPE_INTEGER
.3a1609	85 27		sta $0827	            STA ARGTYPE1
.3a160b	2b		pld		            PLD
.3a160c	28		plp		            PLP
.3a160d	60		rts		            RTS
.3a160e					STRCONCAT
.3a160e	08		php		            PHP
.3a160f	0b		phd		            PHD
.3a1610	8b		phb		            PHB
.3a1611	08		php		            PHP
.3a1612	c2 20		rep #$20	            REP #$20
.3a1614	48		pha		            PHA
.3a1615	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1618	5b		tcd		            TCD
.3a1619	68		pla		            PLA
.3a161a	28		plp		            PLP
.3a161b	e2 20		sep #$20	            SEP #$20
.3a161d	c2 10		rep #$10	            REP #$10
.3a161f	08		php		            PHP
.3a1620	c2 20		rep #$20	            REP #$20
.3a1622	48		pha		            PHA
.3a1623	e2 20		sep #$20	            SEP #$20
.3a1625	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a1627	48		pha		            PHA
.3a1628	ab		plb		            PLB
.3a1629	c2 20		rep #$20	            REP #$20
.3a162b	68		pla		            PLA
.3a162c	28		plp		            PLP
.3a162d	a6 23		ldx $0823	            LDX ARGUMENT1
.3a162f	20 aa 15	jsr $3a15aa	            JSR STRLEN
.3a1632	84 0c		sty $080c	            STY SCRATCH
.3a1634	08		php		            PHP
.3a1635	c2 20		rep #$20	            REP #$20
.3a1637	48		pha		            PHA
.3a1638	e2 20		sep #$20	            SEP #$20
.3a163a	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a163c	48		pha		            PHA
.3a163d	ab		plb		            PLB
.3a163e	c2 20		rep #$20	            REP #$20
.3a1640	68		pla		            PLA
.3a1641	28		plp		            PLP
.3a1642	a6 29		ldx $0829	            LDX ARGUMENT2
.3a1644	20 aa 15	jsr $3a15aa	            JSR STRLEN
.3a1647	c2 20		rep #$20	            REP #$20
.3a1649	98		tya		            TYA
.3a164a	38		sec		            SEC                     ; X := LEN(ARGUMENT1) + LEN(ARGUMENT2) + 1
.3a164b	65 0c		adc $080c	            ADC SCRATCH
.3a164d	aa		tax		            TAX
.3a164e	e2 20		sep #$20	            SEP #$20
.3a1650	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set type to STRING
.3a1652	20 90 10	jsr $3a1090	            JSR ALLOC
.3a1655	c2 20		rep #$20	            REP #$20
.3a1657	a5 b7		lda $08b7	            LDA ALLOCATED           ; INDEX := pointer to the string
.3a1659	85 08		sta $0808	            STA INDEX
.3a165b	e2 20		sep #$20	            SEP #$20
.3a165d	a5 b9		lda $08b9	            LDA ALLOCATED+2
.3a165f	85 0a		sta $080a	            STA INDEX+2
.3a1661	a0 00 00	ldy #$0000	            LDY #0                  ; Set the target index to the beginning
.3a1664	08		php		            PHP
.3a1665	c2 20		rep #$20	            REP #$20
.3a1667	48		pha		            PHA
.3a1668	e2 20		sep #$20	            SEP #$20
.3a166a	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a166c	48		pha		            PHA
.3a166d	ab		plb		            PLB
.3a166e	c2 20		rep #$20	            REP #$20
.3a1670	68		pla		            PLA
.3a1671	28		plp		            PLP
.3a1672	a6 23		ldx $0823	            LDX ARGUMENT1
.3a1674	bd 00 00	lda $3a0000,x	loop1       LDA #0,B,X              ; Get the Xth byte of ARGUMENT1
.3a1677	f0 06		beq $3a167f	            BEQ copy_2              ; Is it null? Yes: move on to the next string
.3a1679	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.3a167b	e8		inx		            INX                     ; Point to the next characters
.3a167c	c8		iny		            INY
.3a167d	80 f5		bra $3a1674	            BRA loop1               ; And do again
.3a167f					copy_2
.3a167f	e2 20		sep #$20	            SEP #$20
.3a1681	08		php		            PHP
.3a1682	c2 20		rep #$20	            REP #$20
.3a1684	48		pha		            PHA
.3a1685	e2 20		sep #$20	            SEP #$20
.3a1687	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a1689	48		pha		            PHA
.3a168a	ab		plb		            PLB
.3a168b	c2 20		rep #$20	            REP #$20
.3a168d	68		pla		            PLA
.3a168e	28		plp		            PLP
.3a168f	a6 29		ldx $0829	            LDX ARGUMENT2
.3a1691	bd 00 00	lda $3a0000,x	loop2       LDA #0,B,X              ; Get the Xth byte of ARGUMENT2
.3a1694	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.3a1696	f0 04		beq $3a169c	            BEQ terminate           ; Is it null? Yes: move on to the next string
.3a1698	e8		inx		            INX                     ; Point to the next characters
.3a1699	c8		iny		            INY
.3a169a	80 f5		bra $3a1691	            BRA loop2               ; And do again
.3a169c					terminate
.3a169c	c2 20		rep #$20	            REP #$20
.3a169e	a5 08		lda $0808	            LDA INDEX               ; Set ARGUMENT1 to the new string
.3a16a0	85 23		sta $0823	            STA ARGUMENT1
.3a16a2	e2 20		sep #$20	            SEP #$20
.3a16a4	a5 0a		lda $080a	            LDA INDEX+2
.3a16a6	85 25		sta $0825	            STA ARGUMENT1+2
.3a16a8	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set ARGUMENT1's type to STRING
.3a16aa	85 27		sta $0827	            STA ARGTYPE1
.3a16ac	ab		plb		            PLB
.3a16ad	2b		pld		            PLD
.3a16ae	28		plp		            PLP
.3a16af	60		rts		            RTS
.3a16b0					STRCPY
.3a16b0	da		phx		            PHX
.3a16b1	5a		phy		            PHY
.3a16b2	08		php		            PHP
.3a16b3	0b		phd		            PHD
.3a16b4	8b		phb		            PHB
.3a16b5	08		php		            PHP
.3a16b6	c2 20		rep #$20	            REP #$20
.3a16b8	48		pha		            PHA
.3a16b9	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a16bc	5b		tcd		            TCD
.3a16bd	68		pla		            PLA
.3a16be	28		plp		            PLP
.3a16bf	c2 20		rep #$20	            REP #$20
.3a16c1	a5 0a		lda $080a	            LDA INDEX+2
.3a16c3	48		pha		            PHA
.3a16c4	a5 08		lda $0808	            LDA INDEX
.3a16c6	48		pha		            PHA
.3a16c7	c2 30		rep #$30	            REP #$30
.3a16c9	08		php		            PHP
.3a16ca	c2 20		rep #$20	            REP #$20
.3a16cc	48		pha		            PHA
.3a16cd	e2 20		sep #$20	            SEP #$20
.3a16cf	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a16d1	48		pha		            PHA
.3a16d2	ab		plb		            PLB
.3a16d3	c2 20		rep #$20	            REP #$20
.3a16d5	68		pla		            PLA
.3a16d6	28		plp		            PLP
.3a16d7	a6 23		ldx $0823	            LDX ARGUMENT1
.3a16d9	20 aa 15	jsr $3a15aa	            JSR STRLEN
.3a16dc	98		tya		            TYA
.3a16dd	aa		tax		            TAX
.3a16de	e8		inx		            INX                     ; Put length of string (plus NUL) in X
.3a16df	e2 20		sep #$20	            SEP #$20
.3a16e1	a9 02		lda #$02	            LDA #TYPE_STRING
.3a16e3	20 90 10	jsr $3a1090	            JSR ALLOC
.3a16e6	c2 20		rep #$20	            REP #$20
.3a16e8	a5 c0		lda $08c0	            LDA CURRBLOCK
.3a16ea	85 08		sta $0808	            STA INDEX
.3a16ec	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.3a16ee	85 0a		sta $080a	            STA INDEX+2
.3a16f0	a0 00 00	ldy #$0000	            LDY #0
.3a16f3	e2 20		sep #$20	            SEP #$20
.3a16f5	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Copy the data to the allocated string
.3a16f7	97 08		sta [$0808],y	            STA [INDEX],Y
.3a16f9	f0 03		beq $3a16fe	            BEQ ret_copy
.3a16fb	c8		iny		            INY
.3a16fc	80 f7		bra $3a16f5	            BRA loop
.3a16fe					ret_copy
.3a16fe	c2 20		rep #$20	            REP #$20
.3a1700	a5 08		lda $0808	            LDA INDEX
.3a1702	85 23		sta $0823	            STA ARGUMENT1
.3a1704	a5 0a		lda $080a	            LDA INDEX+2
.3a1706	85 25		sta $0825	            STA ARGUMENT1+2
.3a1708	c2 20		rep #$20	            REP #$20
.3a170a	68		pla		            PLA
.3a170b	85 08		sta $0808	            STA INDEX
.3a170d	68		pla		            PLA
.3a170e	85 0a		sta $080a	            STA INDEX+2
.3a1710	ab		plb		            PLB
.3a1711	2b		pld		            PLD
.3a1712	28		plp		            PLP
.3a1713	7a		ply		            PLY
.3a1714	fa		plx		            PLX
.3a1715	60		rts		            RTS
.3a1716					STRSUBSTR
.3a1716	08		php		            PHP
.3a1717	e2 20		sep #$20	            SEP #$20
.3a1719	c2 10		rep #$10	            REP #$10
.3a171b	a0 00 00	ldy #$0000	            LDY #0
.3a171e	b7 23		lda [$0823],y	count_loop  LDA [ARGUMENT1],Y
.3a1720	f0 05		beq $3a1727	            BEQ counted
.3a1722	c8		iny		            INY
.3a1723	80 f9		bra $3a171e	            BRA count_loop
.3a1725	84 92		sty $0892	            STY MTEMP               ; MTEMP := length of the source string
.3a1727					counted
.3a1727	c2 30		rep #$30	            REP #$30
.3a1729	c4 29		cpy $0829	            CPY ARGUMENT2           ; length of string <= index?
.3a172b	90 13		bcc $3a1740	            BLT ret_empty           ; Yes: return empty string
.3a172d	f0 11		beq $3a1740	            BEQ ret_empty
.3a172f	a5 8f		lda $088f	            LDA MCOUNT              ; Is the desired count <= 0?
.3a1731	30 0d		bmi $3a1740	            BMI ret_empty
.3a1733	f0 0b		beq $3a1740	            BEQ ret_empty           ; Yes: return the empty string
.3a1735	c4 8f		cpy $088f	            CPY MCOUNT              ; Is the desired length < the length of the source?
.3a1737	b0 12		bcs $3a174b	            BGE do_slice            ; Yes: go ahead and get the substring
.3a1739	a5 29		lda $0829	            LDA ARGUMENT2           ; Is INDEX == 0?
.3a173b	d0 0e		bne $3a174b	            BNE do_slice            ; No: do a slice
.3a173d	4c 94 17	jmp $3a1794	            JMP done                ; Yes: just return the source string
.3a1740					ret_empty
.3a1740	20 be 14	jsr $3a14be	            JSR TEMPSTRING
.3a1743	e2 20		sep #$20	            SEP #$20
.3a1745	a9 00		lda #$00	            LDA #0
.3a1747	87 16		sta [$0816]	            STA [STRPTR]
.3a1749	80 39		bra $3a1784	            BRA finish_copy
.3a174b					do_slice
.3a174b	20 be 14	jsr $3a14be	            JSR TEMPSTRING
.3a174e	c2 30		rep #$30	            REP #$30
.3a1750	18		clc		            CLC                     ; ARGUMENT1 := ARGUMENT1 + index
.3a1751	a5 23		lda $0823	            LDA ARGUMENT1
.3a1753	65 29		adc $0829	            ADC ARGUMENT2
.3a1755	85 23		sta $0823	            STA ARGUMENT1
.3a1757	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a1759	69 00 00	adc #$0000	            ADC #0
.3a175c	85 25		sta $0825	            STA ARGUMENT1+2
.3a175e	a0 00 00	ldy #$0000	            LDY #0
.3a1761					copy_loop
.3a1761	e2 20		sep #$20	            SEP #$20
.3a1763	a7 23		lda [$0823]	            LDA [ARGUMENT1]         ; Copy a character from the substring to the temporary string
.3a1765	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a1767	f0 1b		beq $3a1784	            BEQ finish_copy         ; If it is a NULL, we're done
.3a1769	c2 20		rep #$20	            REP #$20
.3a176b	18		clc		            CLC                     ; Move to the next character
.3a176c	a5 23		lda $0823	            LDA ARGUMENT1
.3a176e	69 01 00	adc #$0001	            ADC #1
.3a1771	85 23		sta $0823	            STA ARGUMENT1
.3a1773	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a1775	69 00 00	adc #$0000	            ADC #0
.3a1778	85 25		sta $0825	            STA ARGUMENT1+2
.3a177a	c8		iny		            INY
.3a177b	c4 8f		cpy $088f	            CPY MCOUNT              ; Have we reached the limit to copy?
.3a177d	d0 e2		bne $3a1761	            BNE copy_loop           ; No: copy the next byte
.3a177f	a9 00 00	lda #$0000	            LDA #0                  ; Null terminate string
.3a1782	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a1784					finish_copy
.3a1784	c2 20		rep #$20	            REP #$20
.3a1786	a5 16		lda $0816	            LDA STRPTR
.3a1788	85 23		sta $0823	            STA ARGUMENT1
.3a178a	a5 18		lda $0818	            LDA STRPTR+2
.3a178c	85 25		sta $0825	            STA ARGUMENT1+2
.3a178e	e2 20		sep #$20	            SEP #$20
.3a1790	a9 02		lda #$02	            LDA #<TYPE_STRING
.3a1792	85 27		sta $0827	            STA ARGTYPE1
.3a1794					done
.3a1794	28		plp		            PLP
.3a1795	60		rts		            RTS
.3a1796					OP_STR_LT
.3a1796	08		php		            PHP
.3a1797	c2 30		rep #$30	            REP #$30
.3a1799	20 bd 15	jsr $3a15bd	            JSR STRCMP
.3a179c	a5 23		lda $0823	            LDA ARGUMENT1
.3a179e	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.3a17a1	d0 05		bne $3a17a8	            BNE ret_false               ; No: return false
.3a17a3					ret_true
.3a17a3	20 f2 05	jsr $3a05f2	            JSR SET_TRUE
.3a17a6	80 03		bra $3a17ab	            BRA done
.3a17a8					ret_false
.3a17a8	20 04 06	jsr $3a0604	            JSR SET_FALSE
.3a17ab	28		plp		done        PLP
.3a17ac	60		rts		            RTS
.3a17ad					OP_STR_GT
.3a17ad	08		php		            PHP
.3a17ae	c2 30		rep #$30	            REP #$30
.3a17b0	20 bd 15	jsr $3a15bd	            JSR STRCMP
.3a17b3	a5 23		lda $0823	            LDA ARGUMENT1
.3a17b5	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.3a17b8	d0 05		bne $3a17bf	            BNE ret_false               ; No: return false
.3a17ba					ret_true
.3a17ba	20 f2 05	jsr $3a05f2	            JSR SET_TRUE
.3a17bd	80 03		bra $3a17c2	            BRA done
.3a17bf					ret_false
.3a17bf	20 04 06	jsr $3a0604	            JSR SET_FALSE
.3a17c2	28		plp		done        PLP
.3a17c3	60		rts		            RTS
.3a17c4					OP_STR_EQ
.3a17c4	08		php		            PHP
.3a17c5	c2 30		rep #$30	            REP #$30
.3a17c7	20 bd 15	jsr $3a15bd	            JSR STRCMP
.3a17ca	a5 23		lda $0823	            LDA ARGUMENT1
.3a17cc	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.3a17cf	d0 05		bne $3a17d6	            BNE ret_false               ; No: return false
.3a17d1					ret_true
.3a17d1	20 f2 05	jsr $3a05f2	            JSR SET_TRUE
.3a17d4	80 03		bra $3a17d9	            BRA done
.3a17d6					ret_false
.3a17d6	20 04 06	jsr $3a0604	            JSR SET_FALSE
.3a17d9	28		plp		done        PLP
.3a17da	60		rts		            RTS
.3a17db					OP_STR_NE
.3a17db	08		php		            PHP
.3a17dc	c2 30		rep #$30	            REP #$30
.3a17de	20 bd 15	jsr $3a15bd	            JSR STRCMP
.3a17e1	a5 23		lda $0823	            LDA ARGUMENT1
.3a17e3	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.3a17e6	f0 05		beq $3a17ed	            BEQ ret_false               ; Yes: return false
.3a17e8					ret_true
.3a17e8	20 f2 05	jsr $3a05f2	            JSR SET_TRUE
.3a17eb	80 03		bra $3a17f0	            BRA done
.3a17ed					ret_false
.3a17ed	20 04 06	jsr $3a0604	            JSR SET_FALSE
.3a17f0	28		plp		done        PLP
.3a17f1	60		rts		            RTS
.3a17f2					OP_STR_GTE
.3a17f2	08		php		            PHP
.3a17f3	c2 30		rep #$30	            REP #$30
.3a17f5	20 bd 15	jsr $3a15bd	            JSR STRCMP
.3a17f8	a5 23		lda $0823	            LDA ARGUMENT1
.3a17fa	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.3a17fd	f0 05		beq $3a1804	            BEQ ret_false               ; Yes: return false
.3a17ff					ret_true
.3a17ff	20 f2 05	jsr $3a05f2	            JSR SET_TRUE
.3a1802	80 03		bra $3a1807	            BRA done
.3a1804					ret_false
.3a1804	20 04 06	jsr $3a0604	            JSR SET_FALSE
.3a1807	28		plp		done        PLP
.3a1808	60		rts		            RTS
.3a1809					OP_STR_LTE
.3a1809	08		php		            PHP
.3a180a	c2 30		rep #$30	            REP #$30
.3a180c	20 bd 15	jsr $3a15bd	            JSR STRCMP
.3a180f	a5 23		lda $0823	            LDA ARGUMENT1
.3a1811	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.3a1814	f0 05		beq $3a181b	            BEQ ret_false               ; Yes: return false
.3a1816					ret_true
.3a1816	20 f2 05	jsr $3a05f2	            JSR SET_TRUE
.3a1819	80 03		bra $3a181e	            BRA done
.3a181b					ret_false
.3a181b	20 04 06	jsr $3a0604	            JSR SET_FALSE
.3a181e	28		plp		done        PLP
.3a181f	60		rts		            RTS
.3a1820					STR_NORMAL
.3a1820	08		php		            PHP
.3a1821	e2 20		sep #$20	            SEP #$20
.3a1823	a5 27		lda $0827	            LDA ARGTYPE1            ; Is it a string?
.3a1825	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a1827	d0 1d		bne $3a1846	            BNE done                ; No: return it
.3a1829	a5 23		lda $0823	            LDA ARGUMENT1           ; Is it a null pointer?
.3a182b	d0 19		bne $3a1846	            BNE done
.3a182d	a5 24		lda $0824	            LDA ARGUMENT1+1
.3a182f	d0 15		bne $3a1846	            BNE done
.3a1831	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a1833	d0 11		bne $3a1846	            BNE done                ; No: return it
.3a1835	20 be 14	jsr $3a14be	            JSR TEMPSTRING
.3a1838	a9 00		lda #$00	            LDA #0
.3a183a	87 16		sta [$0816]	            STA [STRPTR]            ; Make it empty
.3a183c	c2 20		rep #$20	            REP #$20
.3a183e	a5 16		lda $0816	            LDA STRPTR
.3a1840	85 23		sta $0823	            STA ARGUMENT1
.3a1842	a5 18		lda $0818	            LDA STRPTR+2
.3a1844	85 25		sta $0825	            STA ARGUMENT1+2
.3a1846	28		plp		done        PLP
.3a1847	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\listing.s

.3a1848					LISTPROG
.3a1848	48		pha		            PHA
.3a1849	5a		phy		            PHY
.3a184a	0b		phd		            PHD
.3a184b	08		php		            PHP
.3a184c	08		php		            PHP
.3a184d	c2 20		rep #$20	            REP #$20
.3a184f	48		pha		            PHA
.3a1850	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1853	5b		tcd		            TCD
.3a1854	68		pla		            PLA
.3a1855	28		plp		            PLP
.3a1856	c2 30		rep #$30	            REP #$30
.3a1858	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.3a185b	85 00		sta $0800	            STA BIP
.3a185d	85 1a		sta $081a	            STA CURLINE
.3a185f	a9 36 00	lda #$0036	            LDA #`BASIC_BOT
.3a1862	85 02		sta $0802	            STA BIP+2
.3a1864	85 1c		sta $081c	            STA CURLINE+2
.3a1866	22 3c 11 00	jsl $00113c	list_loop   JSL FK_TESTBREAK
.3a186a	b0 20		bcs $3a188c	            BCS throw_break     ; If C: user pressed an interrupt key, stop the listing
.3a186c	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.3a186f	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.3a1871	f0 0f		beq $3a1882	            BEQ done
.3a1873	c5 55		cmp $0855	            CMP MARG1
.3a1875	90 10		bcc $3a1887	            BLT skip_line
.3a1877	c5 59		cmp $0859	            CMP MARG2
.3a1879	f0 02		beq $3a187d	            BEQ print_line
.3a187b	b0 05		bcs $3a1882	            BGE done
.3a187d					print_line
.3a187d	20 ab 18	jsr $3a18ab	            JSR LISTLINE
.3a1880	80 e4		bra $3a1866	            BRA list_loop
.3a1882	28		plp		done        PLP
.3a1883	2b		pld		            PLD
.3a1884	7a		ply		            PLY
.3a1885	68		pla		            PLA
.3a1886	60		rts		            RTS
.3a1887					skip_line
.3a1887	20 b7 21	jsr $3a21b7	            JSR NEXTLINE
.3a188a	80 da		bra $3a1866	            BRA list_loop           ; And try again
.3a188c					throw_break
.3a188c	08		php		            PHP
.3a188d	c2 20		rep #$20	            REP #$20
.3a188f	48		pha		            PHA
.3a1890	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1893	5b		tcd		            TCD
.3a1894	68		pla		            PLA
.3a1895	28		plp		            PLP
.3a1896	e2 20		sep #$20	            SEP #$20
.3a1898	a9 01		lda #$01	            LDA #ERR_BREAK
.3a189a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a189e	c2 20		rep #$20	            REP #$20
.3a18a0	29 ff 00	and #$00ff	            AND #$00FF
.3a18a3	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a18a6	e2 20		sep #$20	            SEP #$20
.3a18a8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a18ab					LISTLINE
.3a18ab	08		php		            PHP
.3a18ac	c2 30		rep #$30	            REP #$30
.3a18ae	85 23		sta $0823	            STA ARGUMENT1
.3a18b0	64 25		stz $0825	            STZ ARGUMENT1+2
.3a18b2	20 1d 15	jsr $3a151d	            JSR ITOS
.3a18b5	a5 16		lda $0816	            LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.3a18b7	1a		inc a		            INC A
.3a18b8	85 23		sta $0823	            STA ARGUMENT1
.3a18ba	a5 18		lda $0818	            LDA STRPTR+2
.3a18bc	85 25		sta $0825	            STA ARGUMENT1+2
.3a18be	20 bd 45	jsr $3a45bd	            JSR PR_STRING
.3a18c1	18		clc		            CLC                 ; Move the BIP to the first byte of the line
.3a18c2	a5 1a		lda $081a	            LDA CURLINE
.3a18c4	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a18c7	85 00		sta $0800	            STA BIP
.3a18c9	a5 1c		lda $081c	            LDA CURLINE+2
.3a18cb	69 00 00	adc #$0000	            ADC #0
.3a18ce	85 02		sta $0802	            STA BIP+2
.3a18d0	e2 20		sep #$20	            SEP #$20
.3a18d2	a9 20		lda #$20	            LDA #CHAR_SP
.3a18d4	20 18 00	jsr $3a0018	            JSR PRINTC
.3a18d7	c2 20		rep #$20	            REP #$20
.3a18d9					loop
.3a18d9	20 ea 18	jsr $3a18ea	            JSR LISTBYTE
.3a18dc	90 fb		bcc $3a18d9	            BCC loop
.3a18de	e2 20		sep #$20	            SEP #$20
.3a18e0	a9 0d		lda #$0d	            LDA #CHAR_CR
.3a18e2	20 18 00	jsr $3a0018	            JSR PRINTC
.3a18e5	20 b7 21	jsr $3a21b7	            JSR NEXTLINE
.3a18e8	28		plp		            PLP
.3a18e9	60		rts		            RTS
.3a18ea					LISTBYTE
.3a18ea	08		php		            PHP
.3a18eb	0b		phd		            PHD
.3a18ec	8b		phb		            PHB
.3a18ed	08		php		            PHP
.3a18ee	c2 20		rep #$20	            REP #$20
.3a18f0	48		pha		            PHA
.3a18f1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a18f4	5b		tcd		            TCD
.3a18f5	68		pla		            PLA
.3a18f6	28		plp		            PLP
.3a18f7	08		php		            PHP
.3a18f8	e2 20		sep #$20	            SEP #$20
.3a18fa	48		pha		            PHA
.3a18fb	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a18fd	48		pha		            PHA
.3a18fe	ab		plb		            PLB
.3a18ff	68		pla		            PLA
.3a1900	28		plp		            PLP
.3a1901	e2 20		sep #$20	            SEP #$20
.3a1903	c2 10		rep #$10	            REP #$10
.3a1905	a7 00		lda [$0800]	            LDA [BIP]           ; Get the current byte
.3a1907	f0 3a		beq $3a1943	            BEQ end_of_line     ; If it's 0, return with C set
.3a1909	30 05		bmi $3a1910	            BMI is_token        ; If it's 0x80 - 0xFF, it's a token
.3a190b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a190e	80 29		bra $3a1939	            BRA done            ; And return
.3a1910					is_token
.3a1910	c2 20		rep #$20	            REP #$20
.3a1912	29 7f 00	and #$007f	            AND #$007F          ; Compute the index of the token
.3a1915	0a		asl a		            ASL A               ; In the token table
.3a1916	0a		asl a		            ASL A
.3a1917	0a		asl a		            ASL A
.3a1918	18		clc		            CLC
.3a1919	69 c0 0c	adc #$0cc0	            ADC #<>TOKENS       ; Set INDEX to the address of the token
.3a191c	85 08		sta $0808	            STA INDEX
.3a191e	a9 3a 00	lda #$003a	            LDA #`TOKENS
.3a1921	69 00 00	adc #$0000	            ADC #0
.3a1924	85 0a		sta $080a	            STA INDEX+2
.3a1926					pr_default
.3a1926	08		php		            PHP
.3a1927	e2 20		sep #$20	            SEP #$20
.3a1929	48		pha		            PHA
.3a192a	a9 3a		lda #$3a	            LDA #`TOKENS
.3a192c	48		pha		            PHA
.3a192d	ab		plb		            PLB
.3a192e	68		pla		            PLA
.3a192f	28		plp		            PLP
.3a1930	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.3a1933	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a1935	aa		tax		            TAX
.3a1936	20 29 04	jsr $3a0429	            JSR PRINTS
.3a1939					done
.3a1939	c2 20		rep #$20	            REP #$20
.3a193b	20 da 20	jsr $3a20da	            JSR INCBIP
.3a193e	ab		plb		            PLB
.3a193f	2b		pld		            PLD
.3a1940	28		plp		            PLP
.3a1941	18		clc		            CLC
.3a1942	60		rts		            RTS
.3a1943	ab		plb		end_of_line PLB
.3a1944	2b		pld		            PLD
.3a1945	28		plp		            PLP
.3a1946	38		sec		            SEC
.3a1947	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\eval.s

.3a1948					INITEVALSP
.3a1948	08		php		            PHP
.3a1949	c2 20		rep #$20	            REP #$20
.3a194b	a9 ff 6f	lda #$6fff	            LDA #ARGUMENT_TOP
.3a194e	85 1f		sta $081f	            STA ARGUMENTSP
.3a1950	a9 ff 7f	lda #$7fff	            LDA #OPERATOR_TOP
.3a1953	85 21		sta $0821	            STA OPERATORSP
.3a1955	a9 ff ff	lda #$ffff	            LDA #$FFFF
.3a1958	85 23		sta $0823	            STA ARGUMENT1
.3a195a	85 25		sta $0825	            STA ARGUMENT1+2
.3a195c	85 29		sta $0829	            STA ARGUMENT2
.3a195e	85 2b		sta $082b	            STA ARGUMENT2+2
.3a1960	e2 20		sep #$20	            SEP #$20
.3a1962	85 27		sta $0827	            STA ARGTYPE1
.3a1964	85 2d		sta $082d	            STA ARGTYPE2
.3a1966	28		plp		            PLP
.3a1967	60		rts		            RTS
.3a1968					PHARGUMENT
.3a1968	08		php		            PHP
.3a1969	0b		phd		            PHD
.3a196a	8b		phb		            PHB
.3a196b	08		php		            PHP
.3a196c	c2 20		rep #$20	            REP #$20
.3a196e	48		pha		            PHA
.3a196f	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1972	5b		tcd		            TCD
.3a1973	68		pla		            PLA
.3a1974	28		plp		            PLP
.3a1975	08		php		            PHP
.3a1976	e2 20		sep #$20	            SEP #$20
.3a1978	48		pha		            PHA
.3a1979	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a197b	48		pha		            PHA
.3a197c	ab		plb		            PLB
.3a197d	68		pla		            PLA
.3a197e	28		plp		            PLP
.3a197f	c2 30		rep #$30	            REP #$30
.3a1981	5a		phy		            PHY
.3a1982	a4 1f		ldy $081f	            LDY ARGUMENTSP
.3a1984	bd 00 00	lda $0000,x	            LDA #0,B,X
.3a1987	99 00 00	sta $0000,y	            STA #0,B,Y
.3a198a	bd 02 00	lda $0002,x	            LDA #2,B,X
.3a198d	99 02 00	sta $0002,y	            STA #2,B,Y
.3a1990	e2 20		sep #$20	            SEP #$20
.3a1992	bd 04 00	lda $0004,x	            LDA #4,B,X
.3a1995	99 04 00	sta $0004,y	            STA #4,B,Y
.3a1998	c2 20		rep #$20	            REP #$20
.3a199a	38		sec		            SEC
.3a199b	98		tya		            TYA
.3a199c	e9 05 00	sbc #$0005	            SBC #ARGUMENT_SIZE
.3a199f	85 1f		sta $081f	            STA ARGUMENTSP
.3a19a1	7a		ply		            PLY
.3a19a2	ab		plb		            PLB
.3a19a3	2b		pld		            PLD
.3a19a4	28		plp		            PLP
.3a19a5	60		rts		            RTS
.3a19a6					PLARGUMENT
.3a19a6	08		php		            PHP
.3a19a7	0b		phd		            PHD
.3a19a8	8b		phb		            PHB
.3a19a9	08		php		            PHP
.3a19aa	c2 20		rep #$20	            REP #$20
.3a19ac	48		pha		            PHA
.3a19ad	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a19b0	5b		tcd		            TCD
.3a19b1	68		pla		            PLA
.3a19b2	28		plp		            PLP
.3a19b3	08		php		            PHP
.3a19b4	e2 20		sep #$20	            SEP #$20
.3a19b6	48		pha		            PHA
.3a19b7	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a19b9	48		pha		            PHA
.3a19ba	ab		plb		            PLB
.3a19bb	68		pla		            PLA
.3a19bc	28		plp		            PLP
.3a19bd	c2 30		rep #$30	            REP #$30
.3a19bf	5a		phy		            PHY
.3a19c0	18		clc		            CLC
.3a19c1	a5 1f		lda $081f	            LDA ARGUMENTSP
.3a19c3	69 05 00	adc #$0005	            ADC #ARGUMENT_SIZE
.3a19c6	85 1f		sta $081f	            STA ARGUMENTSP
.3a19c8	a8		tay		            TAY
.3a19c9	b9 00 00	lda $0000,y	            LDA #0,B,Y
.3a19cc	9d 00 00	sta $0000,x	            STA #0,B,X
.3a19cf	b9 02 00	lda $0002,y	            LDA #2,B,Y
.3a19d2	9d 02 00	sta $0002,x	            STA #2,B,X
.3a19d5	e2 20		sep #$20	            SEP #$20
.3a19d7	b9 04 00	lda $0004,y	            LDA #4,B,Y
.3a19da	9d 04 00	sta $0004,x	            STA #4,B,X
.3a19dd	bd 00 00	lda $0000,x	            LDA #0,B,X
.3a19e0	7a		ply		            PLY
.3a19e1	ab		plb		            PLB
.3a19e2	2b		pld		            PLD
.3a19e3	28		plp		            PLP
.3a19e4	60		rts		            RTS
.3a19e5					PHOPERATOR
.3a19e5	08		php		            PHP
.3a19e6	0b		phd		            PHD
.3a19e7	8b		phb		            PHB
.3a19e8	08		php		            PHP
.3a19e9	c2 20		rep #$20	            REP #$20
.3a19eb	48		pha		            PHA
.3a19ec	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a19ef	5b		tcd		            TCD
.3a19f0	68		pla		            PLA
.3a19f1	28		plp		            PLP
.3a19f2	08		php		            PHP
.3a19f3	e2 20		sep #$20	            SEP #$20
.3a19f5	48		pha		            PHA
.3a19f6	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a19f8	48		pha		            PHA
.3a19f9	ab		plb		            PLB
.3a19fa	68		pla		            PLA
.3a19fb	28		plp		            PLP
.3a19fc	e2 20		sep #$20	            SEP #$20
.3a19fe	c2 10		rep #$10	            REP #$10
.3a1a00	5a		phy		            PHY
.3a1a01	a4 21		ldy $0821	            LDY OPERATORSP
.3a1a03	99 00 00	sta $0000,y	            STA #0,B,Y
.3a1a06	88		dey		            DEY
.3a1a07	84 21		sty $0821	            STY OPERATORSP
.3a1a09	7a		ply		done        PLY
.3a1a0a	ab		plb		            PLB
.3a1a0b	2b		pld		            PLD
.3a1a0c	28		plp		            PLP
.3a1a0d	60		rts		            RTS
.3a1a0e					PLOPERATOR
.3a1a0e	08		php		            PHP
.3a1a0f	0b		phd		            PHD
.3a1a10	8b		phb		            PHB
.3a1a11	08		php		            PHP
.3a1a12	c2 20		rep #$20	            REP #$20
.3a1a14	48		pha		            PHA
.3a1a15	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1a18	5b		tcd		            TCD
.3a1a19	68		pla		            PLA
.3a1a1a	28		plp		            PLP
.3a1a1b	08		php		            PHP
.3a1a1c	e2 20		sep #$20	            SEP #$20
.3a1a1e	48		pha		            PHA
.3a1a1f	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a1a21	48		pha		            PHA
.3a1a22	ab		plb		            PLB
.3a1a23	68		pla		            PLA
.3a1a24	28		plp		            PLP
.3a1a25	e2 20		sep #$20	            SEP #$20
.3a1a27	c2 10		rep #$10	            REP #$10
.3a1a29	5a		phy		            PHY
.3a1a2a	a4 21		ldy $0821	            LDY OPERATORSP
.3a1a2c	c8		iny		            INY
.3a1a2d	84 21		sty $0821	            STY OPERATORSP
.3a1a2f	b9 00 00	lda $0000,y	            LDA #0,B,Y
.3a1a32	c2 20		rep #$20	            REP #$20
.3a1a34	29 ff 00	and #$00ff	            AND #$00FF
.3a1a37	7a		ply		            PLY
.3a1a38	ab		plb		            PLB
.3a1a39	2b		pld		            PLD
.3a1a3a	28		plp		            PLP
.3a1a3b	60		rts		            RTS
.3a1a3c					OPENPARAMS
.3a1a3c	08		php		            PHP
.3a1a3d	e2 20		sep #$20	            SEP #$20
.3a1a3f	a9 01		lda #$01	            LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.3a1a41	20 e5 19	jsr $3a19e5	            JSR PHOPERATOR
.3a1a44	28		plp		            PLP
.3a1a45	60		rts		            RTS
.3a1a46					CLOSEPARAMS
.3a1a46	5a		phy		            PHY
.3a1a47	08		php		            PHP
.3a1a48	8b		phb		            PHB
.3a1a49	08		php		            PHP
.3a1a4a	e2 20		sep #$20	            SEP #$20
.3a1a4c	48		pha		            PHA
.3a1a4d	a9 00		lda #$00	            LDA #0
.3a1a4f	48		pha		            PHA
.3a1a50	ab		plb		            PLB
.3a1a51	68		pla		            PLA
.3a1a52	28		plp		            PLP
.3a1a53	e2 20		sep #$20	            SEP #$20
.3a1a55	a4 21		ldy $0821	            LDY OPERATORSP      ; Peek at the top operator
.3a1a57	b9 01 00	lda $0001,y	            LDA #1,B,Y
.3a1a5a	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the marker for the start of a parameter list
.3a1a5c	d0 08		bne $3a1a66	            BNE error           ; No: there's a problem
.3a1a5e	c2 20		rep #$20	            REP #$20
.3a1a60	e6 21		inc $0821	            INC OPERATORSP      ; Yes: remove it from the operator stack.
.3a1a62	ab		plb		            PLB
.3a1a63	28		plp		            PLP
.3a1a64	7a		ply		            PLY
.3a1a65	60		rts		            RTS
.3a1a66					error
.3a1a66	08		php		            PHP
.3a1a67	c2 20		rep #$20	            REP #$20
.3a1a69	48		pha		            PHA
.3a1a6a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1a6d	5b		tcd		            TCD
.3a1a6e	68		pla		            PLA
.3a1a6f	28		plp		            PLP
.3a1a70	e2 20		sep #$20	            SEP #$20
.3a1a72	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a1a74	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1a78	c2 20		rep #$20	            REP #$20
.3a1a7a	29 ff 00	and #$00ff	            AND #$00FF
.3a1a7d	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a1a80	e2 20		sep #$20	            SEP #$20
.3a1a82	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1a85					OPHIGHPREC
.3a1a85	48		pha		            PHA
.3a1a86	08		php		            PHP
.3a1a87	0b		phd		            PHD
.3a1a88	8b		phb		            PHB
.3a1a89	08		php		            PHP
.3a1a8a	c2 20		rep #$20	            REP #$20
.3a1a8c	48		pha		            PHA
.3a1a8d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1a90	5b		tcd		            TCD
.3a1a91	68		pla		            PLA
.3a1a92	28		plp		            PLP
.3a1a93	08		php		            PHP
.3a1a94	e2 20		sep #$20	            SEP #$20
.3a1a96	48		pha		            PHA
.3a1a97	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a1a99	48		pha		            PHA
.3a1a9a	ab		plb		            PLB
.3a1a9b	68		pla		            PLA
.3a1a9c	28		plp		            PLP
.3a1a9d	e2 20		sep #$20	            SEP #$20
.3a1a9f	a4 21		ldy $0821	            LDY OPERATORSP
.3a1aa1	c0 ff 7f	cpy #$7fff	            CPY #OPERATOR_TOP       ; Is the stack empty?
.3a1aa4	f0 11		beq $3a1ab7	            BEQ is_false            ; Yes: return false
.3a1aa6	20 1f 0c	jsr $3a0c1f	            JSR TOKPRECED
.3a1aa9	85 0c		sta $080c	            STA SCRATCH             ; Save it for later comparison
.3a1aab	b9 01 00	lda $0001,y	            LDA #1,B,Y              ; Get the operator at the top of the stack
.3a1aae	20 1f 0c	jsr $3a0c1f	            JSR TOKPRECED
.3a1ab1	c5 0c		cmp $080c	            CMP SCRATCH             ; Compare the priorities (0 = highest priority)
.3a1ab3	f0 02		beq $3a1ab7	            BEQ is_false            ; A = SCRATCH, return false
.3a1ab5	90 08		bcc $3a1abf	            BCC is_true             ; A < SCRATCH (A is higher priority), return false
.3a1ab7					is_false
.3a1ab7	c2 20		rep #$20	            REP #$20
.3a1ab9	ab		plb		            PLB
.3a1aba	2b		pld		            PLD
.3a1abb	28		plp		            PLP
.3a1abc	68		pla		            PLA
.3a1abd	18		clc		            CLC
.3a1abe	60		rts		            RTS
.3a1abf					is_true
.3a1abf	c2 20		rep #$20	            REP #$20
.3a1ac1	ab		plb		            PLB                     ; A > SCRATCH (A is lower priority), return true
.3a1ac2	2b		pld		            PLD
.3a1ac3	28		plp		            PLP
.3a1ac4	68		pla		            PLA
.3a1ac5	38		sec		            SEC
.3a1ac6	60		rts		            RTS
.3a1ac7					EVALNUMBER
.3a1ac7	4c 9d 08	jmp $3a089d	            JMP PARSEINT
.3a1aca					ARR_GETIDX
.3a1aca	08		php		            PHP
.3a1acb	e2 20		sep #$20	            SEP #$20
.3a1acd	a9 00		lda #$00	            LDA #0
.3a1acf	8f 00 4d 00	sta $004d00	            STA @lARRIDXBUF     ; Set the dimension to 0
.3a1ad3	a2 01 00	ldx #$0001	            LDX #1
.3a1ad6					eval_index
.3a1ad6	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a1ad9	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a1adc	c2 20		rep #$20	            REP #$20
.3a1ade	a5 23		lda $0823	            LDA ARGUMENT1       ; Save the index to the array index buffer
.3a1ae0	9f 00 4d 00	sta $004d00,x	            STA @l ARRIDXBUF,X
.3a1ae4	e2 20		sep #$20	            SEP #$20
.3a1ae6	af 00 4d 00	lda $004d00	            LDA @l ARRIDXBUF    ; Increment the index count
.3a1aea	1a		inc a		            INC A
.3a1aeb	30 3e		bmi $3a1b2b	            BMI arg_err         ; If more than 127 dimensions, throw a range error
.3a1aed	8f 00 4d 00	sta $004d00	            STA @l ARRIDXBUF
.3a1af1	e8		inx		            INX
.3a1af2	e8		inx		            INX
.3a1af3	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a1af6	e2 20		sep #$20	            SEP #$20
.3a1af8	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.3a1afa	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it ")"
.3a1afc	f0 09		beq $3a1b07	            BEQ clean_op        ; Yes: cleanup the argument stack
.3a1afe	c9 2c		cmp #$2c	            CMP #','            ; Is it a comma?
.3a1b00	d0 0a		bne $3a1b0c	            BNE syntax_err      ; No: throw a syntax error
.3a1b02					skip_comma
.3a1b02	20 da 20	jsr $3a20da	            JSR INCBIP
.3a1b05	80 cf		bra $3a1ad6	            BRA eval_index      ; And grab the next index
.3a1b07					clean_op
.3a1b07	20 da 20	jsr $3a20da	            JSR INCBIP
.3a1b0a	28		plp		            PLP
.3a1b0b	60		rts		            RTS
.3a1b0c					syntax_err
.3a1b0c	08		php		            PHP
.3a1b0d	c2 20		rep #$20	            REP #$20
.3a1b0f	48		pha		            PHA
.3a1b10	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1b13	5b		tcd		            TCD
.3a1b14	68		pla		            PLA
.3a1b15	28		plp		            PLP
.3a1b16	e2 20		sep #$20	            SEP #$20
.3a1b18	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a1b1a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1b1e	c2 20		rep #$20	            REP #$20
.3a1b20	29 ff 00	and #$00ff	            AND #$00FF
.3a1b23	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a1b26	e2 20		sep #$20	            SEP #$20
.3a1b28	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1b2b					arg_err
.3a1b2b	08		php		            PHP
.3a1b2c	c2 20		rep #$20	            REP #$20
.3a1b2e	48		pha		            PHA
.3a1b2f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1b32	5b		tcd		            TCD
.3a1b33	68		pla		            PLA
.3a1b34	28		plp		            PLP
.3a1b35	e2 20		sep #$20	            SEP #$20
.3a1b37	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a1b39	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1b3d	c2 20		rep #$20	            REP #$20
.3a1b3f	29 ff 00	and #$00ff	            AND #$00FF
.3a1b42	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a1b45	e2 20		sep #$20	            SEP #$20
.3a1b47	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1b4a					EVALREF
.3a1b4a	08		php		            PHP
.3a1b4b					get_name
.3a1b4b	20 82 53	jsr $3a5382	            JSR VAR_FINDNAME
.3a1b4e	90 47		bcc $3a1b97	            BCC syntax_err      ; If we didn't find a name, thrown an error
.3a1b50	e2 20		sep #$20	            SEP #$20
.3a1b52	a5 ea		lda $08ea	            LDA TOFINDTYPE      ; Check the type of the variable
.3a1b54	29 80		and #$80	            AND #$80            ; Is it an array?
.3a1b56	d0 06		bne $3a1b5e	            BNE is_array        ; Yes: look for the indexes
.3a1b58	20 83 51	jsr $3a5183	            JSR VAR_REF
.3a1b5b	4c 95 1b	jmp $3a1b95	            JMP done
.3a1b5e					is_array
.3a1b5e	20 f5 50	jsr $3a50f5	            JSR VAR_FIND
.3a1b61	90 53		bcc $3a1bb6	            BCC notfound
.3a1b63	c2 20		rep #$20	            REP #$20
.3a1b65	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.3a1b67	48		pha		            PHA
.3a1b68	a5 c0		lda $08c0	            LDA CURRBLOCK
.3a1b6a	48		pha		            PHA
.3a1b6b	a0 09 00	ldy #$0009	            LDY #BINDING.VALUE
.3a1b6e	b7 08		lda [$0808],y	            LDA [INDEX],Y       ; Save the pointer to the array to CURRBLOCK
.3a1b70	85 c0		sta $08c0	            STA CURRBLOCK
.3a1b72	e2 20		sep #$20	            SEP #$20
.3a1b74	c8		iny		            INY
.3a1b75	c8		iny		            INY
.3a1b76	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a1b78	85 c2		sta $08c2	            STA CURRBLOCK+2
.3a1b7a	e2 20		sep #$20	            SEP #$20
.3a1b7c	a9 8f		lda #$8f	            LDA #TOK_LPAREN
.3a1b7e	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a1b81	20 3c 1a	jsr $3a1a3c	            JSR OPENPARAMS
.3a1b84					            PHARRIDX
.3a1b84	20 ca 1a	jsr $3a1aca	            JSR ARR_GETIDX
.3a1b87	20 59 68	jsr $3a6859	            JSR ARR_REF
.3a1b8a					            PLARRIDX
.3a1b8a	20 46 1a	jsr $3a1a46	            JSR CLOSEPARAMS
.3a1b8d	c2 20		rep #$20	            REP #$20
.3a1b8f	68		pla		            PLA
.3a1b90	85 c2		sta $08c2	            STA CURRBLOCK+2
.3a1b92	68		pla		            PLA
.3a1b93	85 c0		sta $08c0	            STA CURRBLOCK
.3a1b95	28		plp		done        PLP
.3a1b96	60		rts		            RTS
.3a1b97					syntax_err
.3a1b97	08		php		            PHP
.3a1b98	c2 20		rep #$20	            REP #$20
.3a1b9a	48		pha		            PHA
.3a1b9b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1b9e	5b		tcd		            TCD
.3a1b9f	68		pla		            PLA
.3a1ba0	28		plp		            PLP
.3a1ba1	e2 20		sep #$20	            SEP #$20
.3a1ba3	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a1ba5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1ba9	c2 20		rep #$20	            REP #$20
.3a1bab	29 ff 00	and #$00ff	            AND #$00FF
.3a1bae	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a1bb1	e2 20		sep #$20	            SEP #$20
.3a1bb3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1bb6					notfound
.3a1bb6	08		php		            PHP
.3a1bb7	c2 20		rep #$20	            REP #$20
.3a1bb9	48		pha		            PHA
.3a1bba	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1bbd	5b		tcd		            TCD
.3a1bbe	68		pla		            PLA
.3a1bbf	28		plp		            PLP
.3a1bc0	e2 20		sep #$20	            SEP #$20
.3a1bc2	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.3a1bc4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1bc8	c2 20		rep #$20	            REP #$20
.3a1bca	29 ff 00	and #$00ff	            AND #$00FF
.3a1bcd	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a1bd0	e2 20		sep #$20	            SEP #$20
.3a1bd2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1bd5					EVALSTRING
.3a1bd5	08		php		            PHP
.3a1bd6	0b		phd		            PHD
.3a1bd7	08		php		            PHP
.3a1bd8	c2 20		rep #$20	            REP #$20
.3a1bda	48		pha		            PHA
.3a1bdb	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1bde	5b		tcd		            TCD
.3a1bdf	68		pla		            PLA
.3a1be0	28		plp		            PLP
.3a1be1	e2 20		sep #$20	            SEP #$20
.3a1be3	c2 10		rep #$10	            REP #$10
.3a1be5	20 da 20	jsr $3a20da	            JSR INCBIP
.3a1be8	a0 00 00	ldy #$0000	            LDY #0              ; Ywill be our length counter
.3a1beb	b7 00		lda [$0800],y	count_loop  LDA [BIP],Y         ; Get the character
.3a1bed	f0 24		beq $3a1c13	            BEQ error           ; If it's end-of-line, throw an error
.3a1bef	c9 22		cmp #$22	            CMP #CHAR_DQUOTE    ; Is it the ending double-quote?
.3a1bf1	f0 03		beq $3a1bf6	            BEQ found_end       ; Yes: Y should be the length
.3a1bf3	c8		iny		            INY
.3a1bf4	80 f5		bra $3a1beb	            BRA count_loop
.3a1bf6	84 0c		sty $080c	found_end   STY SCRATCH         ; Save the length to SCRATCH
.3a1bf8	e2 20		sep #$20	            SEP #$20
.3a1bfa	a9 02		lda #$02	            LDA #TYPE_STRING    ; Set the type to allocate to STRING
.3a1bfc	a6 0c		ldx $080c	            LDX SCRATCH         ; And the length to the length of the string literal
.3a1bfe	e8		inx		            INX
.3a1bff	20 be 14	jsr $3a14be	            JSR TEMPSTRING
.3a1c02	a0 00 00	ldy #$0000	            LDY #0
.3a1c05	c4 0c		cpy $080c	copy_loop   CPY SCRATCH         ; Have we copied all the characters?
.3a1c07	f0 29		beq $3a1c32	            BEQ done            ; Yes: we're done
.3a1c09	a7 00		lda [$0800]	            LDA [BIP]           ; No: get the next character
.3a1c0b	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And copy it to the allocated string
.3a1c0d	c8		iny		            INY
.3a1c0e	20 da 20	jsr $3a20da	            JSR INCBIP
.3a1c11	80 f2		bra $3a1c05	            BRA copy_loop       ; And try the next character
.3a1c13					error
.3a1c13	08		php		            PHP
.3a1c14	c2 20		rep #$20	            REP #$20
.3a1c16	48		pha		            PHA
.3a1c17	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1c1a	5b		tcd		            TCD
.3a1c1b	68		pla		            PLA
.3a1c1c	28		plp		            PLP
.3a1c1d	e2 20		sep #$20	            SEP #$20
.3a1c1f	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a1c21	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1c25	c2 20		rep #$20	            REP #$20
.3a1c27	29 ff 00	and #$00ff	            AND #$00FF
.3a1c2a	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a1c2d	e2 20		sep #$20	            SEP #$20
.3a1c2f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1c32	a9 00		lda #$00	done        LDA #0
.3a1c34	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a1c36	c2 20		rep #$20	            REP #$20
.3a1c38	a5 16		lda $0816	            LDA STRPTR
.3a1c3a	85 23		sta $0823	            STA ARGUMENT1
.3a1c3c	a5 18		lda $0818	            LDA STRPTR+2
.3a1c3e	85 25		sta $0825	            STA ARGUMENT1+2
.3a1c40	a9 02 00	lda #$0002	            LDA #TYPE_STRING    ; And set the type of ARGUMENT1 to string
.3a1c43	85 27		sta $0827	            STA ARGTYPE1
.3a1c45	20 da 20	jsr $3a20da	            JSR INCBIP
.3a1c48	2b		pld		            PLD
.3a1c49	28		plp		            PLP
.3a1c4a	60		rts		            RTS
.3a1c4b					EVAL_FUNC
.3a1c4b	08		php		            PHP
.3a1c4c	e2 20		sep #$20	            SEP #$20
.3a1c4e	a7 00		lda [$0800]	            LDA [BIP]           ; Get the token
.3a1c50	c2 20		rep #$20	            REP #$20
.3a1c52	29 ff 00	and #$00ff	            AND #$00FF
.3a1c55	20 49 0c	jsr $3a0c49	            JSR TOKEVAL
.3a1c58	85 2f		sta $082f	            STA JMP16PTR
.3a1c5a	20 3c 1a	jsr $3a1a3c	            JSR OPENPARAMS
.3a1c5d	08		php		            PHP
.3a1c5e	e2 20		sep #$20	            SEP #$20
.3a1c60	48		pha		            PHA
.3a1c61	a9 00		lda #$00	            LDA #0
.3a1c63	48		pha		            PHA
.3a1c64	ab		plb		            PLB
.3a1c65	68		pla		            PLA
.3a1c66	28		plp		            PLP
.3a1c67	20 6f 1c	jsr $3a1c6f	            JSR OPSTUB
.3a1c6a	20 46 1a	jsr $3a1a46	            JSR CLOSEPARAMS
.3a1c6d	28		plp		            PLP
.3a1c6e	60		rts		            RTS
.3a1c6f					OPSTUB
.3a1c6f	20 da 20	jsr $3a20da	            JSR INCBIP
.3a1c72	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.3a1c75					PROCESSOP
.3a1c75	48		pha		            PHA
.3a1c76	08		php		            PHP
.3a1c77	0b		phd		            PHD
.3a1c78	8b		phb		            PHB
.3a1c79	08		php		            PHP
.3a1c7a	c2 20		rep #$20	            REP #$20
.3a1c7c	48		pha		            PHA
.3a1c7d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1c80	5b		tcd		            TCD
.3a1c81	68		pla		            PLA
.3a1c82	28		plp		            PLP
.3a1c83	c2 30		rep #$30	            REP #$30
.3a1c85	20 0e 1a	jsr $3a1a0e	            JSR PLOPERATOR
.3a1c88	89 80 00	bit #$0080	            BIT #$80            ; Check if it's really a token
.3a1c8b	f0 37		beq $3a1cc4	            BEQ bad_token       ; No: it's a bad token
.3a1c8d	48		pha		            PHA
.3a1c8e	20 49 0c	jsr $3a0c49	            JSR TOKEVAL
.3a1c91	85 2f		sta $082f	            STA JMP16PTR
.3a1c93	68		pla		            PLA
.3a1c94	20 96 0c	jsr $3a0c96	            JSR TOKARITY
.3a1c97	c9 01 00	cmp #$0001	            CMP #1              ; Check the operator's arity
.3a1c9a	f0 08		beq $3a1ca4	            BEQ pull_arg1       ; If it's 1 just pull one argument from the stack
.3a1c9c	c2 30		rep #$30	            REP #$30
.3a1c9e	a2 29 08	ldx #$0829	            LDX #<>ARGUMENT2    ; Pull argument 2 from the stack
.3a1ca1	20 a6 19	jsr $3a19a6	            JSR PLARGUMENT
.3a1ca4					pull_arg1
.3a1ca4	c2 30		rep #$30	            REP #$30
.3a1ca6	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Pull argument 1 from the stack
.3a1ca9	20 a6 19	jsr $3a19a6	            JSR PLARGUMENT
.3a1cac	08		php		            PHP
.3a1cad	e2 20		sep #$20	            SEP #$20
.3a1caf	48		pha		            PHA
.3a1cb0	a9 00		lda #$00	            LDA #0
.3a1cb2	48		pha		            PHA
.3a1cb3	ab		plb		            PLB
.3a1cb4	68		pla		            PLA
.3a1cb5	28		plp		            PLP
.3a1cb6	20 c6 1c	jsr $3a1cc6	            JSR OPSTUB
.3a1cb9	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Get return result in argument 1
.3a1cbc	20 68 19	jsr $3a1968	            JSR PHARGUMENT
.3a1cbf	ab		plb		            PLB
.3a1cc0	2b		pld		            PLD
.3a1cc1	28		plp		            PLP
.3a1cc2	68		pla		            PLA
.3a1cc3	60		rts		            RTS
.3a1cc4	00		brk #		bad_token   BRK
.3a1cc5	ea		nop		            NOP
.3a1cc6	6c 2f 08	jmp ($082f)	OPSTUB      JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.3a1cc9					EVALEXPR
.3a1cc9	08		php		            PHP
.3a1cca	08		php		            PHP
.3a1ccb	c2 20		rep #$20	            REP #$20
.3a1ccd	48		pha		            PHA
.3a1cce	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1cd1	5b		tcd		            TCD
.3a1cd2	68		pla		            PLA
.3a1cd3	28		plp		            PLP
.3a1cd4	08		php		            PHP
.3a1cd5	e2 20		sep #$20	            SEP #$20
.3a1cd7	48		pha		            PHA
.3a1cd8	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a1cda	48		pha		            PHA
.3a1cdb	ab		plb		            PLB
.3a1cdc	68		pla		            PLA
.3a1cdd	28		plp		            PLP
.3a1cde	c2 10		rep #$10	            REP #$10
.3a1ce0	da		phx		            PHX
.3a1ce1					get_char
.3a1ce1	e2 20		sep #$20	            SEP #$20
.3a1ce3	a7 00		lda [$0800]	            LDA [BIP]           ; Get the character
.3a1ce5	d0 03		bne $3a1cea	            BNE else1
.3a1ce7	4c 8c 1d	jmp $3a1d8c	            JMP proc_stack      ; Handle end of line, if we see it
.3a1cea	30 33		bmi $3a1d1f	else1       BMI is_token        ; If MSB is set, it's a token
.3a1cec	c9 20		cmp #$20	            CMP #' '            ; Is it a space?
.3a1cee	d0 03		bne $3a1cf3	            BNE else2
.3a1cf0	4c 86 1d	jmp $3a1d86	            JMP next_char       ; Yes: Skip to the next character
.3a1cf3	c9 3a		cmp #$3a	else2       CMP #'9'+1          ; Check to see if we have digits
.3a1cf5	b0 04		bcs $3a1cfb	            BCS else3           ; No: treat as the end of the line
.3a1cf7	c9 30		cmp #$30	            CMP #'0'
.3a1cf9	b0 56		bcs $3a1d51	            BCS is_digit
.3a1cfb	c9 26		cmp #$26	else3       CMP #'&'            ; Check for a hexadecimal prefix
.3a1cfd	f0 52		beq $3a1d51	            BEQ is_digit
.3a1cff	c9 22		cmp #$22	            CMP #'"'            ; Is it a double-quote?
.3a1d01	d0 03		bne $3a1d06	            BNE else4
.3a1d03	4c 9f 1d	jmp $3a1d9f	            JMP is_string       ; Yes: process the string
.3a1d06	c9 5b		cmp #$5b	else4       CMP #'Z'+1          ; Check to see if we have upper case alphabetics
.3a1d08	b0 07		bcs $3a1d11	            BCS check_lc        ; No: check for lower case
.3a1d0a	c9 41		cmp #$41	            CMP #'A'
.3a1d0c	90 03		bcc $3a1d11	            BCC check_lc
.3a1d0e	4c ab 1d	jmp $3a1dab	            JMP is_alpha
.3a1d11	c9 7b		cmp #$7b	check_lc    CMP #'z'+1          ; Check to see if we have lower case alphabetics
.3a1d13	b0 07		bcs $3a1d1c	            BCS else5           ; No: treat as the end of the line
.3a1d15	c9 61		cmp #$61	            CMP #'a'
.3a1d17	90 03		bcc $3a1d1c	            BCC else5
.3a1d19	4c ab 1d	jmp $3a1dab	            JMP is_alpha
.3a1d1c	4c 8c 1d	jmp $3a1d8c	else5       JMP proc_stack
.3a1d1f	c9 8f		cmp #$8f	is_token    CMP #TOK_LPAREN     ; Is it an LPAREN
.3a1d21	f0 40		beq $3a1d63	            BEQ is_lparen       ; Yes: handle the LPAREN
.3a1d23	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it an RPAREN?
.3a1d25	f0 41		beq $3a1d68	            BEQ is_rparen       ; Yes: handle the RPAREN
.3a1d27	20 6c 0c	jsr $3a0c6c	            JSR TOKTYPE
.3a1d2a	c9 30		cmp #$30	            CMP #TOK_TY_FUNC    ; Is it a function?
.3a1d2c	d0 0c		bne $3a1d3a	            BNE chk_op          ; No: check if it's an operator
.3a1d2e	20 4b 1c	jsr $3a1c4b	            JSR EVAL_FUNC
.3a1d31	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.3a1d34	20 68 19	jsr $3a1968	            JSR PHARGUMENT
.3a1d37	4c e1 1c	jmp $3a1ce1	            JMP get_char
.3a1d3a	c9 00		cmp #$00	chk_op      CMP #TOK_TY_OP      ; Is it an operator?
.3a1d3c	d0 4e		bne $3a1d8c	            BNE proc_stack      ; No: we're finished processing
.3a1d3e	a7 00		lda [$0800]	            LDA [BIP]           ; Yes: Get the token back
.3a1d40	a6 21		ldx $0821	chk_prec    LDX OPERATORSP      ; Is the operator stack empty?
.3a1d42	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.3a1d45	f0 05		beq $3a1d4c	            BEQ push_op         ; Yes: push the operator
.3a1d47	20 85 1a	jsr $3a1a85	            JSR OPHIGHPREC
.3a1d4a	b0 12		bcs $3a1d5e	            BCS process1        ; No: we should process the top operator
.3a1d4c					push_op
.3a1d4c	20 e5 19	jsr $3a19e5	            JSR PHOPERATOR
.3a1d4f	80 35		bra $3a1d86	            BRA next_char       ; And go to the next character
.3a1d51					is_digit
.3a1d51	c2 20		rep #$20	            REP #$20
.3a1d53	20 a4 59	jsr $3a59a4	            JSR PARSENUM
.3a1d56	a2 23 08	ldx #$0823	got_number  LDX #<>ARGUMENT1
.3a1d59	20 68 19	jsr $3a1968	            JSR PHARGUMENT
.3a1d5c	80 83		bra $3a1ce1	            BRA get_char
.3a1d5e					process1
.3a1d5e	20 75 1c	jsr $3a1c75	            JSR PROCESSOP
.3a1d61	80 dd		bra $3a1d40	            BRA chk_prec        ; And check what to do with the current operator
.3a1d63					is_lparen
.3a1d63	20 e5 19	jsr $3a19e5	            JSR PHOPERATOR
.3a1d66	80 1e		bra $3a1d86	            BRA next_char
.3a1d68					is_rparen
.3a1d68	e2 20		sep #$20	            SEP #$20
.3a1d6a	a4 21		ldy $0821	            LDY OPERATORSP      ; Is the operator stack empty?
.3a1d6c	c0 ff 7f	cpy #$7fff	            CPY #<>OPERATOR_TOP
.3a1d6f	f0 46		beq $3a1db7	            BEQ done            ; Yes: we're done evaluating things
.3a1d71	a4 21		ldy $0821	paren_loop  LDY OPERATORSP      ; Peek at the top operator
.3a1d73	b9 01 00	lda $0001,y	            LDA #1,B,Y
.3a1d76	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the LPAREN of a function?
.3a1d78	f0 3d		beq $3a1db7	            BEQ done            ; Yes: treat it as an empty stack
.3a1d7a	c9 8f		cmp #$8f	            CMP #TOK_LPAREN     ; Is it an LPAREN?
.3a1d7c	f0 05		beq $3a1d83	            BEQ done_rparen     ; Yes: we're finished processing
.3a1d7e	20 75 1c	jsr $3a1c75	            JSR PROCESSOP
.3a1d81	80 ee		bra $3a1d71	            BRA paren_loop
.3a1d83					done_rparen
.3a1d83	20 0e 1a	jsr $3a1a0e	            JSR PLOPERATOR
.3a1d86					next_char
.3a1d86	20 da 20	jsr $3a20da	            JSR INCBIP
.3a1d89	4c e1 1c	jmp $3a1ce1	            JMP get_char
.3a1d8c					proc_stack
.3a1d8c	a6 21		ldx $0821	            LDX OPERATORSP      ; Is the operator stack empty?
.3a1d8e	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.3a1d91	b0 24		bcs $3a1db7	            BGE done            ; Yes: return to the caller
.3a1d93	bd 01 00	lda $0001,x	            LDA #1,B,X
.3a1d96	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is top operator a function open?
.3a1d98	f0 1d		beq $3a1db7	            BEQ done            ; Yes: treat as end of expression
.3a1d9a	20 75 1c	jsr $3a1c75	            JSR PROCESSOP
.3a1d9d	80 ed		bra $3a1d8c	            BRA proc_stack
.3a1d9f					is_string
.3a1d9f	20 d5 1b	jsr $3a1bd5	            JSR EVALSTRING
.3a1da2	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.3a1da5	20 68 19	jsr $3a1968	            JSR PHARGUMENT
.3a1da8	4c e1 1c	jmp $3a1ce1	            JMP get_char
.3a1dab					is_alpha
.3a1dab	20 4a 1b	jsr $3a1b4a	            JSR EVALREF
.3a1dae	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.3a1db1	20 68 19	jsr $3a1968	            JSR PHARGUMENT
.3a1db4	4c e1 1c	jmp $3a1ce1	            JMP get_char
.3a1db7	a2 23 08	ldx #$0823	done        LDX #<>ARGUMENT1    ; Make sure the result is off the stack
.3a1dba	20 a6 19	jsr $3a19a6	            JSR PLARGUMENT
.3a1dbd					real_done
.3a1dbd	fa		plx		            PLX
.3a1dbe	28		plp		            PLP
.3a1dbf	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\returnstack.s

.3a1dc0					INITRETURN
.3a1dc0	08		php		                PHP
.3a1dc1	0b		phd		                PHD
.3a1dc2	8b		phb		                PHB
.3a1dc3	08		php		            PHP
.3a1dc4	e2 20		sep #$20	            SEP #$20
.3a1dc6	48		pha		            PHA
.3a1dc7	a9 00		lda #$00	            LDA #0
.3a1dc9	48		pha		            PHA
.3a1dca	ab		plb		            PLB
.3a1dcb	68		pla		            PLA
.3a1dcc	28		plp		            PLP
.3a1dcd	08		php		            PHP
.3a1dce	c2 20		rep #$20	            REP #$20
.3a1dd0	48		pha		            PHA
.3a1dd1	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1dd4	5b		tcd		            TCD
.3a1dd5	68		pla		            PLA
.3a1dd6	28		plp		            PLP
.3a1dd7	c2 30		rep #$30	            REP #$30
.3a1dd9	a9 fd 5f	lda #$5ffd	                LDA #RETURN_TOP-2
.3a1ddc	85 33		sta $0833	                STA RETURNSP
.3a1dde	ab		plb		                PLB
.3a1ddf	2b		pld		                PLD
.3a1de0	28		plp		                PLP
.3a1de1	60		rts		            RTS
.3a1de2					PHRETURN
.3a1de2	08		php		                PHP
.3a1de3	0b		phd		                PHD
.3a1de4	08		php		            PHP
.3a1de5	c2 20		rep #$20	            REP #$20
.3a1de7	48		pha		            PHA
.3a1de8	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1deb	5b		tcd		            TCD
.3a1dec	68		pla		            PLA
.3a1ded	28		plp		            PLP
.3a1dee	c2 30		rep #$30	            REP #$30
.3a1df0	92 33		sta ($0833)	                STA (RETURNSP)
.3a1df2	c6 33		dec $0833	                DEC RETURNSP
.3a1df4	c6 33		dec $0833	                DEC RETURNSP
.3a1df6	2b		pld		                PLD
.3a1df7	28		plp		                PLP
.3a1df8	60		rts		            RTS
.3a1df9					PHRETURNB
.3a1df9	08		php		                PHP
.3a1dfa	c2 30		rep #$30	            REP #$30
.3a1dfc	29 ff 00	and #$00ff	                AND #$00FF
.3a1dff	20 e2 1d	jsr $3a1de2	            JSR PHRETURN
.3a1e02	28		plp		                PLP
.3a1e03	60		rts		            RTS
.3a1e04					PLRETURN
.3a1e04	08		php		                PHP
.3a1e05	0b		phd		                PHD
.3a1e06	08		php		            PHP
.3a1e07	c2 20		rep #$20	            REP #$20
.3a1e09	48		pha		            PHA
.3a1e0a	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1e0d	5b		tcd		            TCD
.3a1e0e	68		pla		            PLA
.3a1e0f	28		plp		            PLP
.3a1e10	c2 30		rep #$30	            REP #$30
.3a1e12	e6 33		inc $0833	                INC RETURNSP
.3a1e14	e6 33		inc $0833	                INC RETURNSP
.3a1e16	b2 33		lda ($0833)	                LDA (RETURNSP)
.3a1e18	2b		pld		                PLD
.3a1e19	28		plp		                PLP
.3a1e1a	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\interpreter.s

=$80					ST_RUNNING = $80            ; The interpreter is running a full program
=$00					ST_INTERACT = $00           ; The interpreter is in interactive mode
>08d2					STATE       .byte ?         ; The state of the interpreter ()
>08d3					ERROR_NUM   .byte ?         ; The type of the error
>08d4					HANDLEERR   .long ?         ; Pointer to the error handler
>08d7					LINENUM     .word ?         ; The current line number
>08d9					LASTLINE    .long ?         ; Pointer to the next free space over the BASIC program
>08dc					EXECACTION  .byte ?         ; The action the exection routines should take to get their next statement
=0					LINE_LINK = 0               ; Offset to the link to the next line
=2					LINE_NUMBER = 2             ; Offset to the line number
=4					LINE_TOKENS = 4             ; Offset to the first token
=6					LINE_MINLEN = 6             ; Minimum length of a line
=0					EXEC_CONT = 0               ; Continue advancing the current line
=1					EXEC_STOP = 1               ; Stop execution of the program
=2					EXEC_GOTO = 2               ; Transfer execution to a new CURLINE that is already set
=3					EXEC_RETURN = 3             ; Transfer execution back to a line that was on the stack
.3a1e1b					SET_ERRERL
.3a1e1b	8b		phb		                PHB
.3a1e1c	0b		phd		                PHD
.3a1e1d	08		php		                PHP
.3a1e1e	08		php		            PHP
.3a1e1f	c2 20		rep #$20	            REP #$20
.3a1e21	48		pha		            PHA
.3a1e22	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1e25	5b		tcd		            TCD
.3a1e26	68		pla		            PLA
.3a1e27	28		plp		            PLP
.3a1e28	08		php		            PHP
.3a1e29	e2 20		sep #$20	            SEP #$20
.3a1e2b	48		pha		            PHA
.3a1e2c	a9 00		lda #$00	            LDA #BASIC_BANK
.3a1e2e	48		pha		            PHA
.3a1e2f	ab		plb		            PLB
.3a1e30	68		pla		            PLA
.3a1e31	28		plp		            PLP
.3a1e32	c2 20		rep #$20	            REP #$20
.3a1e34	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.3a1e36	a9 00 00	lda #$0000	                LDA #0
.3a1e39	85 25		sta $0825	                STA ARGUMENT1+2
.3a1e3b	e2 20		sep #$20	            SEP #$20
.3a1e3d	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a1e3f	85 27		sta $0827	                STA ARGTYPE1
.3a1e41	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.3a1e43	a9 3a		lda #$3a	                LDA #`err_name
.3a1e45	85 e9		sta $08e9	                STA TOFIND+2
.3a1e47	c2 20		rep #$20	            REP #$20
.3a1e49	a9 75 1e	lda #$1e75	                LDA #<>err_name
.3a1e4c	85 e7		sta $08e7	                STA TOFIND
.3a1e4e	20 e5 52	jsr $3a52e5	            JSR VAR_SET
.3a1e51	c2 20		rep #$20	            REP #$20
.3a1e53	a5 d7		lda $08d7	                LDA LINENUM
.3a1e55	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.3a1e57	a5 d9		lda $08d9	                LDA LINENUM+2
.3a1e59	85 25		sta $0825	                STA ARGUMENT1+2
.3a1e5b	e2 20		sep #$20	            SEP #$20
.3a1e5d	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a1e5f	85 27		sta $0827	                STA ARGTYPE1
.3a1e61	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.3a1e63	a9 3a		lda #$3a	                LDA #`erl_name
.3a1e65	85 e9		sta $08e9	                STA TOFIND+2
.3a1e67	c2 20		rep #$20	            REP #$20
.3a1e69	a9 79 1e	lda #$1e79	                LDA #<>erl_name
.3a1e6c	85 e7		sta $08e7	                STA TOFIND
.3a1e6e	20 e5 52	jsr $3a52e5	            JSR VAR_SET
.3a1e71	28		plp		                PLP
.3a1e72	2b		pld		                PLD
.3a1e73	ab		plb		                PLB
.3a1e74	60		rts		            RTS
>3a1e75	45 52 52 00			err_name        .null "ERR"
>3a1e79	45 52 4c 00			erl_name        .null "ERL"
.3a1e7d					ON_ERROR
.3a1e7d	e2 20		sep #$20	            SEP #$20
.3a1e7f	c2 10		rep #$10	            REP #$10
.3a1e81	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a1e84	af d3 08 00	lda $0008d3	            LDA @lERROR_NUM         ; Calculate index to the error message pointer
.3a1e88	0a		asl a		            ASL A
.3a1e89	c2 20		rep #$20	            REP #$20
.3a1e8b	29 ff 00	and #$00ff	            AND #$00FF
.3a1e8e	a8		tay		            TAY
.3a1e8f	08		php		            PHP
.3a1e90	e2 20		sep #$20	            SEP #$20
.3a1e92	48		pha		            PHA
.3a1e93	a9 3a		lda #$3a	            LDA #`ERRORMSG
.3a1e95	48		pha		            PHA
.3a1e96	ab		plb		            PLB
.3a1e97	68		pla		            PLA
.3a1e98	28		plp		            PLP
.3a1e99	be cf 1e	ldx $3a1ecf,y	            LDX ERRORMSG,Y
.3a1e9c	20 29 04	jsr $3a0429	            JSR PRINTS
.3a1e9f	c2 20		rep #$20	            REP #$20
.3a1ea1	a5 d7		lda $08d7	            LDA LINENUM
.3a1ea3	f0 27		beq $3a1ecc	            BEQ skip_at
.3a1ea5	a2 ff 1e	ldx #$1eff	            LDX #<>MSG_AT           ; If so... print " AT "
.3a1ea8	20 29 04	jsr $3a0429	            JSR PRINTS
.3a1eab	08		php		            PHP
.3a1eac	e2 20		sep #$20	            SEP #$20
.3a1eae	48		pha		            PHA
.3a1eaf	a9 00		lda #$00	            LDA #BASIC_BANK
.3a1eb1	48		pha		            PHA
.3a1eb2	ab		plb		            PLB
.3a1eb3	68		pla		            PLA
.3a1eb4	28		plp		            PLP
.3a1eb5	c2 20		rep #$20	            REP #$20
.3a1eb7	af d7 08 00	lda $0008d7	            LDA @lLINENUM           ; ... and then the line number
.3a1ebb	8f 23 08 00	sta $000823	            STA @lARGUMENT1
.3a1ebf	a9 00 00	lda #$0000	            LDA #0
.3a1ec2	8f 25 08 00	sta $000825	            STA @lARGUMENT1+2
.3a1ec6	20 db 45	jsr $3a45db	            JSR PR_INTEGER
.3a1ec9	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a1ecc					skip_at
.3a1ecc	4c 7d 27	jmp $3a277d	            JMP INTERACT
>3a1ecf	03 1f				ERRORMSG    .word <>MSG_OK
>3a1ed1	06 1f				            .word <>MSG_BREAK
>3a1ed3	0c 1f				            .word <>MSG_SYNTAX
>3a1ed5	19 1f				            .word <>MSG_MEMORY
>3a1ed7	27 1f				            .word <>MSG_TYPE
>3a1ed9	35 1f				            .word <>MSG_NOTFND
>3a1edb	48 1f				            .word <>MSG_NOLINE
>3a1edd	5e 1f				            .word <>MSG_UNDFLOW
>3a1edf	6e 1f				            .word <>MSG_OVRFLOW
>3a1ee1	7d 1f				            .word <>MSG_RANGE
>3a1ee3	8a 1f				            .word <>MSG_ARG
>3a1ee5	9b 1f				            .word <>MSG_NOFILE
>3a1ee7	aa 1f				            .word <>MSG_NAN
>3a1ee9	b7 1f				            .word <>MSG_OVERFLOW
>3a1eeb	c5 1f				            .word <>MSG_UNDERFLOW
>3a1eed	d4 1f				            .word <>MSG_DIV0
>3a1eef	e5 1f				            .word <>MSG_DIRECTORY
>3a1ef1	fe 1f				            .word <>MSG_LOAD
>3a1ef3	12 20				            .word <>MSG_SAVE
>3a1ef5	26 20				            .word <>MSG_DELETE
>3a1ef7	3c 20				            .word <>MSG_FILENOTFND
>3a1ef9	50 20				            .word <>MSG_DIRNOTWRITE
>3a1efb	6b 20				            .word <>MSG_NOTCOPIED
>3a1efd	83 20				            .word <>MSG_DOMAIN
>3a1eff	20 61 74 00			MSG_AT          .null " at"
>3a1f03	4f 4b 00			MSG_OK          .null "OK"
>3a1f06	42 72 65 61 6b 00		MSG_BREAK       .null "Break"
>3a1f0c	53 79 6e 74 61 78 20 65		MSG_SYNTAX      .null "Syntax error"
>3a1f14	72 72 6f 72 00
>3a1f19	4f 75 74 20 6f 66 20 6d		MSG_MEMORY      .null "Out of memory"
>3a1f21	65 6d 6f 72 79 00
>3a1f27	54 79 70 65 20 6d 69 73		MSG_TYPE        .null "Type mismatch"
>3a1f2f	6d 61 74 63 68 00
>3a1f35	56 61 72 69 61 62 6c 65		MSG_NOTFND      .null "Variable not found"
>3a1f3d	20 6e 6f 74 20 66 6f 75 6e 64 00
>3a1f48	4c 69 6e 65 20 6e 75 6d		MSG_NOLINE      .null "Line number not found"
>3a1f50	62 65 72 20 6e 6f 74 20 66 6f 75 6e 64 00
>3a1f5e	53 74 61 63 6b 20 75 6e		MSG_UNDFLOW     .null "Stack underflow"
>3a1f66	64 65 72 66 6c 6f 77 00
>3a1f6e	53 74 61 63 6b 20 6f 76		MSG_OVRFLOW     .null "Stack overflow"
>3a1f76	65 72 66 6c 6f 77 00
>3a1f7d	4f 75 74 20 6f 66 20 72		MSG_RANGE       .null "Out of range"
>3a1f85	61 6e 67 65 00
>3a1f8a	49 6c 6c 65 67 61 6c 20		MSG_ARG         .null "Illegal argument"
>3a1f92	61 72 67 75 6d 65 6e 74 00
>3a1f9b	46 69 6c 65 20 6e 6f 74		MSG_NOFILE      .null "File not found"
>3a1fa3	20 66 6f 75 6e 64 00
>3a1faa	4e 6f 74 20 61 20 6e 75		MSG_NAN         .null "Not a number"
>3a1fb2	6d 62 65 72 00
>3a1fb7	4d 61 74 68 20 6f 76 65		MSG_OVERFLOW    .null "Math overflow"
>3a1fbf	72 66 6c 6f 77 00
>3a1fc5	4d 61 74 68 20 75 6e 64		MSG_UNDERFLOW   .null "Math underflow"
>3a1fcd	65 72 66 6c 6f 77 00
>3a1fd4	44 69 76 69 73 69 6f 6e		MSG_DIV0        .null "Division by zero"
>3a1fdc	20 62 79 20 7a 65 72 6f 00
>3a1fe5	55 6e 61 62 6c 65 20 74		MSG_DIRECTORY   .null "Unable to read directory"
>3a1fed	6f 20 72 65 61 64 20 64 69 72 65 63 74 6f 72 79
>3a1ffd	00
>3a1ffe	55 6e 61 62 6c 65 20 74		MSG_LOAD        .null "Unable to load file"
>3a2006	6f 20 6c 6f 61 64 20 66 69 6c 65 00
>3a2012	55 6e 61 62 6c 65 20 74		MSG_SAVE        .null "Unable to save file"
>3a201a	6f 20 73 61 76 65 20 66 69 6c 65 00
>3a2026	55 6e 61 62 6c 65 20 74		MSG_DELETE      .null "Unable to delete file"
>3a202e	6f 20 64 65 6c 65 74 65 20 66 69 6c 65 00
>3a203c	43 6f 75 6c 64 20 6e 6f		MSG_FILENOTFND  .null "Could not find file"
>3a2044	74 20 66 69 6e 64 20 66 69 6c 65 00
>3a2050	43 6f 75 6c 64 20 6e 6f		MSG_DIRNOTWRITE .null "Could not update directory"
>3a2058	74 20 75 70 64 61 74 65 20 64 69 72 65 63 74 6f
>3a2068	72 79 00
>3a206b	43 6f 75 6c 64 20 6e 6f		MSG_NOTCOPIED   .null "Could not copy the file"
>3a2073	74 20 63 6f 70 79 20 74 68 65 20 66 69 6c 65 00
>3a2083	41 72 67 75 6d 65 6e 74		MSG_DOMAIN      .null "Argument outside domain"
>3a208b	20 6f 75 74 73 69 64 65 20 64 6f 6d 61 69 6e 00
.3a209b					SETINTERACT
.3a209b	08		php		            PHP
.3a209c	0b		phd		            PHD
.3a209d	08		php		            PHP
.3a209e	c2 20		rep #$20	            REP #$20
.3a20a0	48		pha		            PHA
.3a20a1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a20a4	5b		tcd		            TCD
.3a20a5	68		pla		            PLA
.3a20a6	28		plp		            PLP
.3a20a7	e2 20		sep #$20	            SEP #$20
.3a20a9	a9 00		lda #$00	            LDA #ST_INTERACT
.3a20ab	85 d2		sta $08d2	            STA STATE
.3a20ad	2b		pld		            PLD
.3a20ae	28		plp		            PLP
.3a20af	60		rts		            RTS
.3a20b0					CLRINTERP
.3a20b0	0b		phd		            PHD
.3a20b1	08		php		            PHP
.3a20b2	08		php		            PHP
.3a20b3	c2 20		rep #$20	            REP #$20
.3a20b5	48		pha		            PHA
.3a20b6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a20b9	5b		tcd		            TCD
.3a20ba	68		pla		            PLA
.3a20bb	28		plp		            PLP
.3a20bc	08		php		            PHP
.3a20bd	c2 20		rep #$20	            REP #$20
.3a20bf	a9 7d 1e	lda #$1e7d	            LDA #<>ON_ERROR
.3a20c2	8f d4 08 00	sta $0008d4	            STA @lHANDLEERR
.3a20c6	e2 20		sep #$20	            SEP #$20
.3a20c8	a9 3a		lda #$3a	            LDA #`ON_ERROR
.3a20ca	8f d6 08 00	sta $0008d6	            STA @lHANDLEERR+2
.3a20ce	28		plp		            PLP
.3a20cf	20 82 44	jsr $3a4482	            JSR S_CLR
.3a20d2	20 c3 3f	jsr $3a3fc3	            JSR S_RESTORE
.3a20d5	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the depth of the GOSUB stack
.3a20d7	28		plp		            PLP
.3a20d8	2b		pld		            PLD
.3a20d9	60		rts		            RTS
.3a20da					INCBIP
.3a20da	08		php		            PHP
.3a20db	0b		phd		            PHD
.3a20dc	08		php		            PHP
.3a20dd	c2 20		rep #$20	            REP #$20
.3a20df	48		pha		            PHA
.3a20e0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a20e3	5b		tcd		            TCD
.3a20e4	68		pla		            PLA
.3a20e5	28		plp		            PLP
.3a20e6	c2 20		rep #$20	            REP #$20
.3a20e8	18		clc		            CLC
.3a20e9	a5 00		lda $0800	            LDA BIP
.3a20eb	69 01 00	adc #$0001	            ADC #1
.3a20ee	85 00		sta $0800	            STA BIP
.3a20f0	e2 20		sep #$20	            SEP #$20
.3a20f2	a5 02		lda $0802	            LDA BIP+2
.3a20f4	69 00		adc #$00	            ADC #0
.3a20f6	85 02		sta $0802	            STA BIP+2
.3a20f8	2b		pld		            PLD
.3a20f9	28		plp		            PLP
.3a20fa	60		rts		            RTS
.3a20fb					SKIPWS
.3a20fb	08		php		            PHP
.3a20fc	0b		phd		            PHD
.3a20fd	08		php		            PHP
.3a20fe	c2 20		rep #$20	            REP #$20
.3a2100	48		pha		            PHA
.3a2101	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2104	5b		tcd		            TCD
.3a2105	68		pla		            PLA
.3a2106	28		plp		            PLP
.3a2107	e2 20		sep #$20	            SEP #$20
.3a2109	a7 00		lda [$0800]	loop        LDA [BIP]
.3a210b	f0 0f		beq $3a211c	            BEQ done            ; If character is 0, we've reached the end of the line
.3a210d	c9 20		cmp #$20	            CMP #CHAR_SP        ; Skip if it's a space
.3a210f	f0 06		beq $3a2117	            BEQ skip_char
.3a2111	c9 09		cmp #$09	            CMP #CHAR_TAB       ; Skip if it's a TAB
.3a2113	f0 02		beq $3a2117	            BEQ skip_char
.3a2115	80 05		bra $3a211c	            BRA done            ; Otherwise, we're done and BIP points to a non-whitespace
.3a2117					skip_char
.3a2117	20 da 20	jsr $3a20da	            JSR INCBIP
.3a211a	80 ed		bra $3a2109	            BRA loop
.3a211c	2b		pld		done        PLD
.3a211d	28		plp		            PLP
.3a211e	60		rts		            RTS
.3a211f					SKIPSTMT
.3a211f	08		php		            PHP
.3a2120	e2 20		sep #$20	            SEP #$20
.3a2122	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the current character
.3a2124	f0 09		beq $3a212f	            BEQ done            ; Is it EOL? Yes, we're done
.3a2126	c9 3a		cmp #$3a	            CMP #':'            ; Is it a colon?
.3a2128	f0 05		beq $3a212f	            BEQ done            ; Yes, we're done
.3a212a	20 da 20	jsr $3a20da	            JSR INCBIP
.3a212d	80 f3		bra $3a2122	            BRA loop            ; and check it...
.3a212f	28		plp		done        PLP
.3a2130	60		rts		            RTS
.3a2131					SKIPTOTOK
.3a2131	08		php		            PHP
.3a2132	e2 20		sep #$20	            SEP #$20
.3a2134	64 36		stz $0836	            STZ NESTING
.3a2136	a7 00		lda [$0800]	loop        LDA [BIP]           ; Get the character
.3a2138	f0 19		beq $3a2153	            BEQ end_of_line     ; EOL? Yes: move to the next line
.3a213a	c5 37		cmp $0837	            CMP TARGETTOK       ; Is it the one we want?
.3a213c	f0 2c		beq $3a216a	            BEQ check_depth     ; Yes: check the depth
.3a213e	c9 9b		cmp #$9b	            CMP #TOK_FOR        ; Is it a FOR?
.3a2140	f0 1e		beq $3a2160	            BEQ inc_nesting     ; Yes: increment NESTING
.3a2142	c9 9f		cmp #$9f	            CMP #TOK_DO         ; Is it a DO?
.3a2144	f0 1a		beq $3a2160	            BEQ inc_nesting     ; Yes: increment NESTING
.3a2146	c9 9e		cmp #$9e	            CMP #TOK_NEXT       ; Is it a NEXT?
.3a2148	f0 1a		beq $3a2164	            BEQ dec_nesting     ; Yes: decrement NESTING
.3a214a	c9 a0		cmp #$a0	            CMP #TOK_LOOP       ; Is it a LOOP?
.3a214c	f0 16		beq $3a2164	            BEQ dec_nesting     ; Yes: decrement NESTING
.3a214e					incloop
.3a214e	20 da 20	jsr $3a20da	            JSR INCBIP
.3a2151	80 e3		bra $3a2136	            BRA loop            ; and keep scanning
.3a2153					end_of_line
.3a2153	20 b7 21	jsr $3a21b7	            JSR NEXTLINE
.3a2156	c2 20		rep #$20	            REP #$20
.3a2158	a5 d7		lda $08d7	            LDA LINENUM         ; Check the line number
.3a215a	f0 1d		beq $3a2179	            BEQ syntax_err1     ; If it's zero, we reached the end of the program
.3a215c	e2 20		sep #$20	            SEP #$20
.3a215e	80 d6		bra $3a2136	            BRA loop            ; And keep scanning
.3a2160					inc_nesting
.3a2160	e6 36		inc $0836	            INC NESTING         ; Track that we have entered a lexical scope for a FOR/DO
.3a2162	80 ea		bra $3a214e	            BRA incloop
.3a2164					dec_nesting
.3a2164	c6 36		dec $0836	            DEC NESTING         ; Track that we have left a lexical scope for a FOR/DO
.3a2166	30 30		bmi $3a2198	            BMI syntax_err2     ; If the depth goes <0, throw a syntax error
.3a2168	80 e4		bra $3a214e	            BRA incloop
.3a216a					check_depth
.3a216a	a5 35		lda $0835	            LDA SKIPNEST        ; Check to see if nesting matters
.3a216c	30 06		bmi $3a2174	            BMI found           ; No: just return that we found the token
.3a216e	a5 36		lda $0836	            LDA NESTING         ; Get the nesting depth
.3a2170	f0 02		beq $3a2174	            BEQ found           ; If it's zero, we found our token
.3a2172	80 da		bra $3a214e	            BRA incloop         ; Otherwise: it's a token for an enclosed FOR/DO, keep scanning
.3a2174					found
.3a2174	20 da 20	jsr $3a20da	            JSR INCBIP
.3a2177	28		plp		            PLP
.3a2178	60		rts		            RTS
.3a2179					syntax_err1
.3a2179	08		php		            PHP
.3a217a	c2 20		rep #$20	            REP #$20
.3a217c	48		pha		            PHA
.3a217d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2180	5b		tcd		            TCD
.3a2181	68		pla		            PLA
.3a2182	28		plp		            PLP
.3a2183	e2 20		sep #$20	            SEP #$20
.3a2185	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a2187	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a218b	c2 20		rep #$20	            REP #$20
.3a218d	29 ff 00	and #$00ff	            AND #$00FF
.3a2190	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a2193	e2 20		sep #$20	            SEP #$20
.3a2195	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2198					syntax_err2
.3a2198	08		php		            PHP
.3a2199	c2 20		rep #$20	            REP #$20
.3a219b	48		pha		            PHA
.3a219c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a219f	5b		tcd		            TCD
.3a21a0	68		pla		            PLA
.3a21a1	28		plp		            PLP
.3a21a2	e2 20		sep #$20	            SEP #$20
.3a21a4	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a21a6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a21aa	c2 20		rep #$20	            REP #$20
.3a21ac	29 ff 00	and #$00ff	            AND #$00FF
.3a21af	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a21b2	e2 20		sep #$20	            SEP #$20
.3a21b4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a21b7					NEXTLINE
.3a21b7	08		php		            PHP
.3a21b8	c2 30		rep #$30	            REP #$30
.3a21ba	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.3a21bd	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the offset to the next line
.3a21bf	85 0c		sta $080c	            STA SCRATCH
.3a21c1	18		clc		            CLC                 ; Compute the new CURLINE
.3a21c2	a5 1a		lda $081a	            LDA CURLINE         ; CURLINE := [CURLINE].LINE_LINK
.3a21c4	65 0c		adc $080c	            ADC SCRATCH
.3a21c6	85 1a		sta $081a	            STA CURLINE
.3a21c8	a5 1c		lda $081c	            LDA CURLINE+2
.3a21ca	69 00 00	adc #$0000	            ADC #0
.3a21cd	85 1c		sta $081c	            STA CURLINE+2
.3a21cf	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the LINENUM to the new current line's number
.3a21d2	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; LINENUM := [CURLINE].LINE_NUMBER
.3a21d4	85 d7		sta $08d7	            STA LINENUM
.3a21d6	18		clc		            CLC                 ; Point BIP to the first character of the line
.3a21d7	a5 1a		lda $081a	            LDA CURLINE         ; BIP := CURLINE + LINE_TOKENS
.3a21d9	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a21dc	85 00		sta $0800	            STA BIP
.3a21de	a5 1c		lda $081c	            LDA CURLINE+2
.3a21e0	69 00 00	adc #$0000	            ADC #0
.3a21e3	85 02		sta $0802	            STA BIP+2
.3a21e5	28		plp		            PLP
.3a21e6	60		rts		            RTS
.3a21e7					EXPECT_TOK
.3a21e7	08		php		            PHP
.3a21e8	e2 20		sep #$20	            SEP #$20
.3a21ea	48		pha		            PHA
.3a21eb	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a21ee	68		pla		            PLA
.3a21ef	e2 20		sep #$20	            SEP #$20
.3a21f1	c7 00		cmp [$0800]	            CMP [BIP]           ; Check the character at BIP
.3a21f3	d0 08		bne $3a21fd	            BNE syntax_err      ; Throw a syntax error
.3a21f5	20 da 20	jsr $3a20da	            JSR INCBIP
.3a21f8	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a21fb	28		plp		            PLP
.3a21fc	60		rts		            RTS
.3a21fd					syntax_err
.3a21fd	08		php		            PHP
.3a21fe	c2 20		rep #$20	            REP #$20
.3a2200	48		pha		            PHA
.3a2201	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2204	5b		tcd		            TCD
.3a2205	68		pla		            PLA
.3a2206	28		plp		            PLP
.3a2207	e2 20		sep #$20	            SEP #$20
.3a2209	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a220b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a220f	c2 20		rep #$20	            REP #$20
.3a2211	29 ff 00	and #$00ff	            AND #$00FF
.3a2214	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a2217	e2 20		sep #$20	            SEP #$20
.3a2219	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a221c					OPT_TOK
.3a221c	08		php		            PHP
.3a221d	e2 20		sep #$20	            SEP #$20
.3a221f	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a2222	e2 20		sep #$20	            SEP #$20
.3a2224	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the character at BIP
.3a2226	f0 10		beq $3a2238	            BEQ ret_false       ; If end-of-line, return false
.3a2228	c9 3a		cmp #$3a	            CMP #':'
.3a222a	f0 0c		beq $3a2238	            BEQ ret_false       ; If colon, return false
.3a222c	c5 37		cmp $0837	            CMP TARGETTOK
.3a222e	f0 05		beq $3a2235	            BEQ ret_true        ; If matches, return true
.3a2230	20 da 20	jsr $3a20da	            JSR INCBIP
.3a2233	80 ef		bra $3a2224	            BRA loop
.3a2235	28		plp		ret_true    PLP
.3a2236	38		sec		            SEC
.3a2237	60		rts		            RTS
.3a2238	28		plp		ret_false   PLP
.3a2239	18		clc		            CLC
.3a223a	60		rts		            RTS
.3a223b					PEEK_TOK
.3a223b	5a		phy		            PHY
.3a223c	08		php		            PHP
.3a223d	e2 20		sep #$20	            SEP #$20
.3a223f	a0 00 00	ldy #$0000	            LDY #0
.3a2242	b7 00		lda [$0800],y	loop        LDA [BIP],Y
.3a2244	f0 0d		beq $3a2253	            BEQ done
.3a2246	c9 3a		cmp #$3a	            CMP #':'
.3a2248	f0 07		beq $3a2251	            BEQ ret_null
.3a224a	c9 20		cmp #$20	            CMP #CHAR_SP
.3a224c	d0 05		bne $3a2253	            BNE done
.3a224e	c8		iny		            INY
.3a224f	80 f1		bra $3a2242	            BRA loop
.3a2251	a9 00		lda #$00	ret_null    LDA #0
.3a2253	28		plp		done        PLP
.3a2254	7a		ply		            PLY
.3a2255	60		rts		            RTS
.3a2256					EXECSTMT
.3a2256	08		php		            PHP
.3a2257	0b		phd		            PHD
.3a2258	8b		phb		            PHB
.3a2259	08		php		            PHP
.3a225a	c2 20		rep #$20	            REP #$20
.3a225c	48		pha		            PHA
.3a225d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2260	5b		tcd		            TCD
.3a2261	68		pla		            PLA
.3a2262	28		plp		            PLP
.3a2263	20 48 19	jsr $3a1948	            JSR INITEVALSP
.3a2266	e2 20		sep #$20	            SEP #$20
.3a2268	a9 00		lda #$00	            LDA #EXEC_CONT      ; This will tell EXECLINE and EXECPROG to procede in a
.3a226a	85 dc		sta $08dc	            STA EXECACTION      ; linear fashion through the program
.3a226c	22 3c 11 00	jsl $00113c	check_break JSL FK_TESTBREAK
.3a2270	b0 4b		bcs $3a22bd	            BCS throw_break     ; If C: user pressed an interrupt key, stop the program
.3a2272	a7 00		lda [$0800]	            LDA [BIP]           ; If we happen to have a colon, just skip over it.
.3a2274	c9 3a		cmp #$3a	            CMP #':'            ; This can happen with FOR/NEXT
.3a2276	d0 03		bne $3a227b	            BNE eat_ws
.3a2278	20 da 20	jsr $3a20da	            JSR INCBIP
.3a227b					eat_ws
.3a227b	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a227e	a7 00		lda [$0800]	            LDA [BIP]
.3a2280	d0 03		bne $3a2285	            BNE else
.3a2282	4c 07 23	jmp $3a2307	            JMP done            ; If the current byte is 0, we're at the end of the line, just return
.3a2285					else
.3a2285	20 a7 04	jsr $3a04a7	            JSR ISALPHA
.3a2288	b0 52		bcs $3a22dc	            BCS is_variable     ; Yes: we may have a LET statement
.3a228a	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it's any other non-token
.3a228c	10 10		bpl $3a229e	            BPL error           ; Yes: it's a syntax error
.3a228e	20 6c 0c	jsr $3a0c6c	            JSR TOKTYPE
.3a2291	85 0c		sta $080c	            STA SCRATCH         ; Save the type for later
.3a2293	c9 20		cmp #$20	            CMP #TOK_TY_STMNT   ; Is it a statement?
.3a2295	d0 03		bne $3a229a	            BNE else2
.3a2297	4c f5 22	jmp $3a22f5	            JMP ok_to_exec      ; Yes: it's ok to try to execute it
.3a229a	a5 d2		lda $08d2	else2       LDA STATE           ; Check to see if we're in interactive mode
.3a229c	f0 51		beq $3a22ef	            BEQ is_interact
.3a229e					error
.3a229e	08		php		            PHP
.3a229f	c2 20		rep #$20	            REP #$20
.3a22a1	48		pha		            PHA
.3a22a2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a22a5	5b		tcd		            TCD
.3a22a6	68		pla		            PLA
.3a22a7	28		plp		            PLP
.3a22a8	e2 20		sep #$20	            SEP #$20
.3a22aa	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a22ac	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a22b0	c2 20		rep #$20	            REP #$20
.3a22b2	29 ff 00	and #$00ff	            AND #$00FF
.3a22b5	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a22b8	e2 20		sep #$20	            SEP #$20
.3a22ba	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a22bd					throw_break
.3a22bd	08		php		            PHP
.3a22be	c2 20		rep #$20	            REP #$20
.3a22c0	48		pha		            PHA
.3a22c1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a22c4	5b		tcd		            TCD
.3a22c5	68		pla		            PLA
.3a22c6	28		plp		            PLP
.3a22c7	e2 20		sep #$20	            SEP #$20
.3a22c9	a9 01		lda #$01	            LDA #ERR_BREAK
.3a22cb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a22cf	c2 20		rep #$20	            REP #$20
.3a22d1	29 ff 00	and #$00ff	            AND #$00FF
.3a22d4	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a22d7	e2 20		sep #$20	            SEP #$20
.3a22d9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a22dc					is_variable
.3a22dc	20 8c 44	jsr $3a448c	            JSR S_LET
.3a22df	4c 07 23	jmp $3a2307	            JMP done
.3a22e2					STSTUB
.3a22e2	08		php		            PHP
.3a22e3	e2 20		sep #$20	            SEP #$20
.3a22e5	48		pha		            PHA
.3a22e6	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a22e8	48		pha		            PHA
.3a22e9	ab		plb		            PLB
.3a22ea	68		pla		            PLA
.3a22eb	28		plp		            PLP
.3a22ec	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.3a22ef	a5 0c		lda $080c	is_interact LDA SCRATCH         ; Get the token type
.3a22f1	c9 10		cmp #$10	            CMP #TOK_TY_CMD     ; Is it a command?
.3a22f3	d0 a9		bne $3a229e	            BNE error           ; If not, it's an error
.3a22f5					ok_to_exec
.3a22f5	a7 00		lda [$0800]	            LDA [BIP]           ; Get the original token again
.3a22f7	20 49 0c	jsr $3a0c49	            JSR TOKEVAL
.3a22fa	c2 20		rep #$20	            REP #$20
.3a22fc	85 2f		sta $082f	            STA JMP16PTR        ; Store it in the jump pointer
.3a22fe	20 48 19	jsr $3a1948	            JSR INITEVALSP
.3a2301	20 da 20	jsr $3a20da	            JSR INCBIP
.3a2304	20 e2 22	jsr $3a22e2	            JSR STSTUB
.3a2307	ab		plb		done        PLB
.3a2308	2b		pld		            PLD
.3a2309	28		plp		            PLP
.3a230a	60		rts		            RTS
.3a230b					EXECCMD
.3a230b	08		php		            PHP
.3a230c	58		cli		            CLI
.3a230d	20 9b 20	jsr $3a209b	            JSR SETINTERACT
.3a2310	20 c0 1d	jsr $3a1dc0	            JSR INITRETURN
.3a2313	e2 20		sep #$20	            SEP #$20
.3a2315	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.3a2318	c2 20		rep #$20	            REP #$20
.3a231a	a5 1a		lda $081a	            LDA CURLINE         ; Set the BASIC Instruction Pointer to the first byte of the line
.3a231c	85 00		sta $0800	            STA BIP
.3a231e	a5 1c		lda $081c	            LDA CURLINE+2
.3a2320	85 02		sta $0802	            STA BIP+2
.3a2322	4c 4c 23	jmp $3a234c	            JMP exec_loop
.3a2325	08		php		EXECLINE    PHP
.3a2326	c2 20		rep #$20	            REP #$20
.3a2328	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER            ; Set the current line number
.3a232b	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.3a232d	85 d7		sta $08d7	            STA LINENUM
.3a232f	20 b5 14	jsr $3a14b5	            JSR CLRTMPSTR
.3a2332	e2 20		sep #$20	            SEP #$20
.3a2334	a5 dc		lda $08dc	            LDA EXECACTION              ; If the last EXEC action was RETURN
.3a2336	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; BIP has already been set, so...
.3a2338	f0 12		beq $3a234c	            BEQ exec_loop               ; Skip over setting the BIP to the beginning of the line
.3a233a	c2 20		rep #$20	            REP #$20
.3a233c	18		clc		            CLC                         ; Set the BASIC Instruction Pointer to the first byte of the line
.3a233d	a5 1a		lda $081a	            LDA CURLINE
.3a233f	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a2342	85 00		sta $0800	            STA BIP
.3a2344	e2 20		sep #$20	            SEP #$20
.3a2346	a5 1c		lda $081c	            LDA CURLINE+2
.3a2348	69 00		adc #$00	            ADC #0
.3a234a	85 02		sta $0802	            STA BIP+2
.3a234c					exec_loop
.3a234c	c2 20		rep #$20	            REP #$20
.3a234e	20 56 22	jsr $3a2256	            JSR EXECSTMT
.3a2351	e2 20		sep #$20	            SEP #$20
.3a2353	a5 dc		lda $08dc	            LDA EXECACTION
.3a2355	c9 03		cmp #$03	            CMP #EXEC_RETURN
.3a2357	f0 f3		beq $3a234c	            BEQ exec_loop
.3a2359	c9 00		cmp #$00	            CMP #EXEC_CONT              ; If it's not EXEC_CONT, exit to the caller
.3a235b	d0 31		bne $3a238e	            BNE exec_done
.3a235d	e2 20		sep #$20	            SEP #$20
.3a235f	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a2362	a7 00		lda [$0800]	            LDA [BIP]                   ; Get the current character in the line
.3a2364	f0 28		beq $3a238e	            BEQ exec_done               ; If it's NULL, we're done
.3a2366	c9 3a		cmp #$3a	            CMP #':'                    ; If it's colon, we have more statements
.3a2368	f0 1f		beq $3a2389	            BEQ skip_loop               ; Skip over it and try to execute the next one
.3a236a	08		php		            PHP
.3a236b	c2 20		rep #$20	            REP #$20
.3a236d	48		pha		            PHA
.3a236e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2371	5b		tcd		            TCD
.3a2372	68		pla		            PLA
.3a2373	28		plp		            PLP
.3a2374	e2 20		sep #$20	            SEP #$20
.3a2376	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a2378	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a237c	c2 20		rep #$20	            REP #$20
.3a237e	29 ff 00	and #$00ff	            AND #$00FF
.3a2381	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a2384	e2 20		sep #$20	            SEP #$20
.3a2386	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2389					skip_loop
.3a2389	20 da 20	jsr $3a20da	            JSR INCBIP
.3a238c	80 be		bra $3a234c	            BRA exec_loop               ; And try to execute another statement
.3a238e					exec_done
.3a238e	28		plp		            PLP
.3a238f	60		rts		            RTS
.3a2390					EXECPROGRAM
.3a2390	08		php		            PHP
.3a2391	58		cli		            CLI
.3a2392	e2 20		sep #$20	            SEP #$20
.3a2394	a9 80		lda #$80	            LDA #ST_RUNNING
.3a2396	85 d2		sta $08d2	            STA STATE
.3a2398	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.3a239b	20 c0 1d	jsr $3a1dc0	            JSR INITRETURN
.3a239e	c2 30		rep #$30	            REP #$30
.3a23a0	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the count of GOSUBs
.3a23a2	a0 02 00	ldy #$0002	exec_loop   LDY #LINE_NUMBER
.3a23a5	b7 1a		lda [$081a],y	            LDA [CURLINE],Y             ; Get the line number of the current line
.3a23a7	f0 29		beq $3a23d2	            BEQ done                    ; If it's 0, we are finished running code (implicit END)
.3a23a9	20 25 23	jsr $3a2325	            JSR EXECLINE
.3a23ac	e2 20		sep #$20	            SEP #$20
.3a23ae	a5 dc		lda $08dc	            LDA EXECACTION              ; Check the EXECACTION from the last line
.3a23b0	c9 01		cmp #$01	            CMP #EXEC_STOP              ; Stop execution of the program?
.3a23b2	f0 1e		beq $3a23d2	            BEQ done
.3a23b4	c9 02		cmp #$02	            CMP #EXEC_GOTO              ; Transfer execution to a new CURLINE that is already set
.3a23b6	f0 ea		beq $3a23a2	            BEQ exec_loop
.3a23b8	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; Transfer execution to the CURLINE and BIP that is already set
.3a23ba	f0 e6		beq $3a23a2	            BEQ exec_loop
.3a23bc	c2 20		rep #$20	            REP #$20
.3a23be	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.3a23c1	18		clc		            CLC
.3a23c2	a5 1a		lda $081a	            LDA CURLINE
.3a23c4	77 1a		adc [$081a],y	            ADC [CURLINE],Y
.3a23c6	85 1a		sta $081a	            STA CURLINE
.3a23c8	e2 20		sep #$20	            SEP #$20
.3a23ca	a5 1c		lda $081c	            LDA CURLINE+2
.3a23cc	69 00		adc #$00	            ADC #0
.3a23ce	85 1c		sta $081c	            STA CURLINE+2
.3a23d0	80 d0		bra $3a23a2	            BRA exec_loop               ; And try to execute that line
.3a23d2					done
.3a23d2	e2 20		sep #$20	            SEP #$20
.3a23d4	a9 00		lda #$00	            LDA #ST_INTERACT            ; Set interpreter state to RUNNING
.3a23d6	85 d2		sta $08d2	            STA STATE
.3a23d8	28		plp		            PLP
.3a23d9	60		rts		            RTS
.3a23da					FINDLINE
.3a23da	08		php		            PHP
.3a23db	c2 30		rep #$30	            REP #$30
.3a23dd	c2 20		rep #$20	            REP #$20
.3a23df	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT            ; INDEX points to the first line of the program
.3a23e2	85 08		sta $0808	            STA INDEX
.3a23e4	a9 36 00	lda #$0036	            LDA #`BASIC_BOT
.3a23e7	85 0a		sta $080a	            STA INDEX+2
.3a23e9	c2 20		rep #$20	            REP #$20
.3a23eb	a0 02 00	ldy #$0002	check_nmbrs LDY #LINE_NUMBER            ; Get the number of the possible target line
.3a23ee	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a23f0	f0 31		beq $3a2423	            BEQ ret_false               ; If new line number is 0, we got to the
.3a23f2	c5 23		cmp $0823	            CMP ARGUMENT1               ; Compare it to the target line number
.3a23f4	f0 1e		beq $3a2414	            BEQ found
.3a23f6	b0 2b		bcs $3a2423	            BGE ret_false               ; If the line number > target line number, the line is not present
.3a23f8					next_line
.3a23f8	c2 20		rep #$20	            REP #$20
.3a23fa	a0 00 00	ldy #$0000	            LDY #LINE_LINK              ; INDEX := INDEX + [INDEX].LINK
.3a23fd	18		clc		            CLC
.3a23fe	a5 08		lda $0808	            LDA INDEX
.3a2400	77 08		adc [$0808],y	            ADC [INDEX],Y
.3a2402	85 0c		sta $080c	            STA SCRATCH
.3a2404	e2 20		sep #$20	            SEP #$20
.3a2406	a5 0a		lda $080a	            LDA INDEX+2
.3a2408	69 00		adc #$00	            ADC #0
.3a240a	85 0a		sta $080a	            STA INDEX+2
.3a240c	c2 20		rep #$20	            REP #$20
.3a240e	a5 0c		lda $080c	            LDA SCRATCH
.3a2410	85 08		sta $0808	            STA INDEX
.3a2412	80 d7		bra $3a23eb	            BRA check_nmbrs             ; And go back to check the new line INDEX is pointing to
.3a2414					found
.3a2414	c2 20		rep #$20	            REP #$20
.3a2416	a5 08		lda $0808	            LDA INDEX
.3a2418	85 1a		sta $081a	            STA CURLINE
.3a241a	e2 20		sep #$20	            SEP #$20
.3a241c	a5 0a		lda $080a	            LDA INDEX+2
.3a241e	85 1c		sta $081c	            STA CURLINE+2
.3a2420	28		plp		ret_true    PLP                         ; Return true to indicate we've found the line
.3a2421	38		sec		            SEC
.3a2422	60		rts		            RTS
.3a2423	28		plp		ret_false   PLP
.3a2424	18		clc		            CLC
.3a2425	60		rts		            RTS
.3a2426					MVPROGDN
.3a2426	08		php		            PHP
.3a2427					mvd_loop
.3a2427	e2 20		sep #$20	            SEP #$20
.3a2429	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.3a242b	87 08		sta [$0808]	            STA [INDEX]
.3a242d	c2 20		rep #$20	            REP #$20
.3a242f	a5 0c		lda $080c	            LDA SCRATCH
.3a2431	c5 00		cmp $0800	            CMP BIP
.3a2433	d0 08		bne $3a243d	            BNE increment
.3a2435	e2 20		sep #$20	            SEP #$20
.3a2437	a5 0e		lda $080e	            LDA SCRATCH+2
.3a2439	c5 02		cmp $0802	            CMP BIP+2
.3a243b	f0 26		beq $3a2463	            BEQ done            ; Yes: return
.3a243d					increment
.3a243d	c2 20		rep #$20	            REP #$20
.3a243f	18		clc		            CLC
.3a2440	a5 0c		lda $080c	            LDA SCRATCH
.3a2442	69 01 00	adc #$0001	            ADC #1
.3a2445	85 0c		sta $080c	            STA SCRATCH
.3a2447	e2 20		sep #$20	            SEP #$20
.3a2449	a5 0e		lda $080e	            LDA SCRATCH+2
.3a244b	69 00		adc #$00	            ADC #0
.3a244d	85 0e		sta $080e	            STA SCRATCH+2
.3a244f	c2 20		rep #$20	            REP #$20
.3a2451	18		clc		            CLC
.3a2452	a5 08		lda $0808	            LDA INDEX
.3a2454	69 01 00	adc #$0001	            ADC #1
.3a2457	85 08		sta $0808	            STA INDEX
.3a2459	e2 20		sep #$20	            SEP #$20
.3a245b	a5 0a		lda $080a	            LDA INDEX+2
.3a245d	69 00		adc #$00	            ADC #0
.3a245f	85 0a		sta $080a	            STA INDEX+2
.3a2461	80 c4		bra $3a2427	            BRA mvd_loop        ; And try again
.3a2463	28		plp		done        PLP
.3a2464	60		rts		            RTS
.3a2465					MVPROGUP
.3a2465	08		php		            PHP
.3a2466					mvu_loop
.3a2466	e2 20		sep #$20	            SEP #$20
.3a2468	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.3a246a	87 08		sta [$0808]	            STA [INDEX]
.3a246c	c2 20		rep #$20	            REP #$20
.3a246e	a5 0c		lda $080c	            LDA SCRATCH
.3a2470	c5 00		cmp $0800	            CMP BIP
.3a2472	d0 06		bne $3a247a	            BNE decrement
.3a2474	a5 0e		lda $080e	            LDA SCRATCH+2
.3a2476	c5 02		cmp $0802	            CMP BIP+2
.3a2478	f0 26		beq $3a24a0	            BEQ done            ; Yes: return
.3a247a					decrement
.3a247a	c2 20		rep #$20	            REP #$20
.3a247c	38		sec		            SEC
.3a247d	a5 0c		lda $080c	            LDA SCRATCH
.3a247f	e9 01 00	sbc #$0001	            SBC #1
.3a2482	85 0c		sta $080c	            STA SCRATCH
.3a2484	e2 20		sep #$20	            SEP #$20
.3a2486	a5 0e		lda $080e	            LDA SCRATCH+2
.3a2488	e9 00		sbc #$00	            SBC #0
.3a248a	85 0e		sta $080e	            STA SCRATCH+2
.3a248c	c2 20		rep #$20	            REP #$20
.3a248e	38		sec		            SEC
.3a248f	a5 08		lda $0808	            LDA INDEX
.3a2491	e9 01 00	sbc #$0001	            SBC #1
.3a2494	85 08		sta $0808	            STA INDEX
.3a2496	e2 20		sep #$20	            SEP #$20
.3a2498	a5 0a		lda $080a	            LDA INDEX+2
.3a249a	e9 00		sbc #$00	            SBC #0
.3a249c	85 0a		sta $080a	            STA INDEX+2
.3a249e	80 c6		bra $3a2466	            BRA mvu_loop        ; And try again
.3a24a0	28		plp		done        PLP
.3a24a1	60		rts		            RTS
.3a24a2					DELLINE
.3a24a2	08		php		            PHP
.3a24a3	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; SCRATCH := INDEX + [INDEX].LINK (address of the following line)
.3a24a6	c2 20		rep #$20	            REP #$20
.3a24a8	18		clc		            CLC
.3a24a9	a5 08		lda $0808	            LDA INDEX
.3a24ab	77 08		adc [$0808],y	            ADC [INDEX],Y
.3a24ad	85 0c		sta $080c	            STA SCRATCH
.3a24af	e2 20		sep #$20	            SEP #$20
.3a24b1	a5 0a		lda $080a	            LDA INDEX+2
.3a24b3	69 00		adc #$00	            ADC #0
.3a24b5	85 0e		sta $080e	            STA SCRATCH+2
.3a24b7	c2 20		rep #$20	            REP #$20
.3a24b9	18		clc		            CLC
.3a24ba	a5 d9		lda $08d9	            LDA LASTLINE
.3a24bc	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a24bf	85 00		sta $0800	            STA BIP
.3a24c1	e2 20		sep #$20	            SEP #$20
.3a24c3	a5 db		lda $08db	            LDA LASTLINE+2
.3a24c5	69 00		adc #$00	            ADC #0
.3a24c7	85 02		sta $0802	            STA BIP+2
.3a24c9	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; LASTLINE := LASTLINE - [INDEX].LINK
.3a24cc	c2 20		rep #$20	            REP #$20
.3a24ce	38		sec		            SEC
.3a24cf	a5 d9		lda $08d9	            LDA LASTLINE
.3a24d1	f7 08		sbc [$0808],y	            SBC [INDEX],Y
.3a24d3	85 d9		sta $08d9	            STA LASTLINE
.3a24d5	e2 20		sep #$20	            SEP #$20
.3a24d7	a5 db		lda $08db	            LDA LASTLINE+2
.3a24d9	e9 00		sbc #$00	            SBC #0
.3a24db	85 db		sta $08db	            STA LASTLINE+2
.3a24dd	20 26 24	jsr $3a2426	            JSR MVPROGDN
.3a24e0					done
.3a24e0	20 82 44	jsr $3a4482	            JSR S_CLR
.3a24e3	28		plp		            PLP
.3a24e4	60		rts		            RTS
.3a24e5					APPLINE
.3a24e5	08		php		            PHP
.3a24e6	08		php		            PHP
.3a24e7	c2 20		rep #$20	            REP #$20
.3a24e9	48		pha		            PHA
.3a24ea	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a24ed	5b		tcd		            TCD
.3a24ee	68		pla		            PLA
.3a24ef	28		plp		            PLP
.3a24f0	c2 30		rep #$30	            REP #$30
.3a24f2	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the line number of the new line
.3a24f5	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.3a24f7	18		clc		            CLC                 ; Point INDEX to the position to store the tokens
.3a24f8	a5 d9		lda $08d9	            LDA LASTLINE
.3a24fa	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a24fd	85 08		sta $0808	            STA INDEX
.3a24ff	e2 20		sep #$20	            SEP #$20
.3a2501	a5 db		lda $08db	            LDA LASTLINE+2
.3a2503	69 00		adc #$00	            ADC #0
.3a2505	85 0a		sta $080a	            STA INDEX+2
.3a2507	e2 20		sep #$20	            SEP #$20
.3a2509	a0 00 00	ldy #$0000	            LDY #0
.3a250c	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Copy the tokenized line to its place in the code
.3a250e	97 08		sta [$0808],y	            STA [INDEX],Y
.3a2510	f0 03		beq $3a2515	            BEQ copy_done
.3a2512	c8		iny		            INY
.3a2513	80 f7		bra $3a250c	            BRA copy_loop
.3a2515					copy_done
.3a2515	c2 20		rep #$20	            REP #$20
.3a2517	98		tya		            TYA
.3a2518	18		clc		            CLC
.3a2519	69 05 00	adc #$0005	            ADC #LINE_TOKENS+1
.3a251c	85 0c		sta $080c	            STA SCRATCH
.3a251e	c2 20		rep #$20	            REP #$20
.3a2520	a0 00 00	ldy #$0000	            LDY #LINE_LINK      ; Set link to the offset to the next line
.3a2523	a5 0c		lda $080c	            LDA SCRATCH
.3a2525	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.3a2527	c2 20		rep #$20	            REP #$20
.3a2529	18		clc		            CLC
.3a252a	a5 d9		lda $08d9	            LDA LASTLINE
.3a252c	65 0c		adc $080c	            ADC SCRATCH
.3a252e	85 0c		sta $080c	            STA SCRATCH
.3a2530	e2 20		sep #$20	            SEP #$20
.3a2532	a5 db		lda $08db	            LDA LASTLINE+2
.3a2534	69 00		adc #$00	            ADC #0
.3a2536	85 db		sta $08db	            STA LASTLINE+2
.3a2538	c2 20		rep #$20	            REP #$20
.3a253a	a5 0c		lda $080c	            LDA SCRATCH
.3a253c	85 d9		sta $08d9	            STA LASTLINE
.3a253e	c2 20		rep #$20	            REP #$20
.3a2540	a0 00 00	ldy #$0000	            LDY #0
.3a2543	a9 00 00	lda #$0000	            LDA #0
.3a2546	97 d9		sta [$08d9],y	blank_loop  STA [LASTLINE],Y    ; Set the "line" after the last line to nulls
.3a2548	c8		iny		            INY
.3a2549	c0 05 00	cpy #$0005	            CPY #LINE_TOKENS+1
.3a254c	d0 f8		bne $3a2546	            BNE blank_loop
.3a254e	20 82 44	jsr $3a4482	            JSR S_CLR
.3a2551	28		plp		            PLP
.3a2552	60		rts		            RTS
.3a2553					FINDINSPT
.3a2553	0b		phd		            PHD
.3a2554	08		php		            PHP
.3a2555	08		php		            PHP
.3a2556	c2 20		rep #$20	            REP #$20
.3a2558	48		pha		            PHA
.3a2559	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a255c	5b		tcd		            TCD
.3a255d	68		pla		            PLA
.3a255e	28		plp		            PLP
.3a255f	c2 30		rep #$30	            REP #$30
.3a2561	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.3a2564	85 08		sta $0808	            STA INDEX
.3a2566	a9 36 00	lda #$0036	            LDA #`BASIC_BOT
.3a2569	85 0a		sta $080a	            STA INDEX+2
.3a256b	a0 02 00	ldy #$0002	loop        LDY #LINE_NUMBER
.3a256e	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a2570	f0 1d		beq $3a258f	            BEQ found_end           ; Got to end without finding it
.3a2572	c5 d7		cmp $08d7	            CMP LINENUM
.3a2574	f0 25		beq $3a259b	            BEQ found_line          ; LINENUM = [INDEX].LINE_NUMBER: return we found the exact line
.3a2576	b0 1d		bcs $3a2595	            BGE found_spot          ; LINENUM > [INDEX].LINE_NUMBER: return we found spot to insert
.3a2578	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.3a257b	18		clc		            CLC                     ; Move INDEX to the next line
.3a257c	a5 08		lda $0808	            LDA INDEX
.3a257e	77 08		adc [$0808],y	            ADC [INDEX],Y
.3a2580	85 0c		sta $080c	            STA SCRATCH
.3a2582	a5 0a		lda $080a	            LDA INDEX+2
.3a2584	69 00 00	adc #$0000	            ADC #0
.3a2587	85 0a		sta $080a	            STA INDEX+2
.3a2589	a5 0c		lda $080c	            LDA SCRATCH
.3a258b	85 08		sta $0808	            STA INDEX
.3a258d	80 dc		bra $3a256b	            BRA loop                ; And check that line
.3a258f	a9 00 00	lda #$0000	found_end   LDA #0                  ; Return that we reached the end of the program
.3a2592	28		plp		            PLP
.3a2593	2b		pld		            PLD
.3a2594	60		rts		            RTS
.3a2595	a9 01 00	lda #$0001	found_spot  LDA #1                  ; Return that we the found the spot to insert the line
.3a2598	28		plp		            PLP                     ; But that it wasn't already there
.3a2599	2b		pld		            PLD
.3a259a	60		rts		            RTS
.3a259b	a9 02 00	lda #$0002	found_line  LDA #2                  ; Return that we found the line
.3a259e	28		plp		            PLP
.3a259f	2b		pld		            PLD
.3a25a0	60		rts		            RTS
.3a25a1					INSLINE
.3a25a1	08		php		            PHP
.3a25a2	c2 30		rep #$30	            REP #$30
.3a25a4	a9 05 00	lda #$0005	            LDA #LINE_TOKENS+1  ; Set SCRATCH2 to the size of the line header with the end-of-line
.3a25a7	85 10		sta $0810	            STA SCRATCH2
.3a25a9	a0 00 00	ldy #$0000	            LDY #0
.3a25ac					count_loop
.3a25ac	e2 20		sep #$20	            SEP #$20
.3a25ae	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the byte of the line
.3a25b0	f0 07		beq $3a25b9	            BEQ shift_prog      ; If it's end-of-line, SCRATCH2 is the length
.3a25b2	c2 20		rep #$20	            REP #$20
.3a25b4	e6 10		inc $0810	            INC SCRATCH2
.3a25b6	c8		iny		            INY
.3a25b7	80 f3		bra $3a25ac	            BRA count_loop      ; Count and continue
.3a25b9					shift_prog
.3a25b9	c2 20		rep #$20	            REP #$20
.3a25bb	a5 08		lda $0808	            LDA INDEX           ; BIP = the address of the first byte for the new line
.3a25bd	85 00		sta $0800	            STA BIP
.3a25bf	a5 0a		lda $080a	            LDA INDEX+2
.3a25c1	85 02		sta $0802	            STA BIP+2
.3a25c3	18		clc		            CLC                 ; SCRATCH = address of highest byte to copy
.3a25c4	a5 d9		lda $08d9	            LDA LASTLINE
.3a25c6	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a25c9	85 0c		sta $080c	            STA SCRATCH
.3a25cb	a5 db		lda $08db	            LDA LASTLINE+2
.3a25cd	69 00 00	adc #$0000	            ADC #0
.3a25d0	85 0e		sta $080e	            STA SCRATCH+2
.3a25d2	18		clc		            CLC                 ; Adjust LASTLINE to its new position after the insert
.3a25d3	a5 d9		lda $08d9	            LDA LASTLINE
.3a25d5	65 10		adc $0810	            ADC SCRATCH2
.3a25d7	85 d9		sta $08d9	            STA LASTLINE
.3a25d9	a5 db		lda $08db	            LDA LASTLINE+2
.3a25db	69 00 00	adc #$0000	            ADC #0
.3a25de	85 db		sta $08db	            STA LASTLINE+2
.3a25e0	18		clc		            CLC                 ; INDEX = address of the highest location to copy into
.3a25e1	a5 d9		lda $08d9	            LDA LASTLINE
.3a25e3	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a25e6	85 08		sta $0808	            STA INDEX
.3a25e8	a5 db		lda $08db	            LDA LASTLINE+2
.3a25ea	69 00 00	adc #$0000	            ADC #0
.3a25ed	85 0a		sta $080a	            STA INDEX+2
.3a25ef	20 65 24	jsr $3a2465	            JSR MVPROGUP
.3a25f2	c2 20		rep #$20	            REP #$20
.3a25f4	a5 10		lda $0810	            LDA SCRATCH2
.3a25f6	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.3a25f9	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINK_LINK = length of the new line
.3a25fb	a5 d7		lda $08d7	            LDA LINENUM
.3a25fd	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.3a2600	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINE_NUMBER = number of the new line
.3a2602	18		clc		            CLC                 ; Point BIP to the first byte of the new line
.3a2603	a5 00		lda $0800	            LDA BIP
.3a2605	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a2608	85 00		sta $0800	            STA BIP
.3a260a	a5 02		lda $0802	            LDA BIP+2
.3a260c	69 00 00	adc #$0000	            ADC #0
.3a260f	85 02		sta $0802	            STA BIP+2
.3a2611	a0 00 00	ldy #$0000	            LDY #0
.3a2614	e2 20		sep #$20	            SEP #$20
.3a2616	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Get the byte of the tokenized line
.3a2618	97 00		sta [$0800],y	            STA [BIP],Y         ; Copy it to its correct location in the program
.3a261a	f0 03		beq $3a261f	            BEQ done            ; If it was end-of-line byte, we're done
.3a261c	c8		iny		            INY
.3a261d	80 f7		bra $3a2616	            BRA copy_loop       ; Otherwise, continue with the next
.3a261f					done
.3a261f	20 82 44	jsr $3a4482	            JSR S_CLR
.3a2622	28		plp		            PLP
.3a2623	60		rts		            RTS
.3a2624					ADDLINE
.3a2624	08		php		            PHP
.3a2625	c2 30		rep #$30	            REP #$30
.3a2627	85 d7		sta $08d7	            STA LINENUM
.3a2629	20 53 25	jsr $3a2553	            JSR FINDINSPT
.3a262c	c9 00 00	cmp #$0000	            CMP #0
.3a262f	f0 2c		beq $3a265d	            BEQ do_append       ; End-of-program found, add the line to the end
.3a2631	c9 01 00	cmp #$0001	            CMP #1
.3a2634	f0 22		beq $3a2658	            BEQ do_insert       ; Spot was found: insertion required
.3a2636	c2 20		rep #$20	            REP #$20
.3a2638	a5 08		lda $0808	            LDA INDEX
.3a263a	48		pha		            PHA
.3a263b	a5 0a		lda $080a	            LDA INDEX+2
.3a263d	48		pha		            PHA
.3a263e	20 a2 24	jsr $3a24a2	            JSR DELLINE
.3a2641	68		pla		            PLA
.3a2642	85 0a		sta $080a	            STA INDEX+2
.3a2644	68		pla		            PLA
.3a2645	85 08		sta $0808	            STA INDEX
.3a2647	a5 1a		lda $081a	            LDA CURLINE         ; Check to see if there is any non-whitespace on the line
.3a2649	85 00		sta $0800	            STA BIP
.3a264b	a5 1c		lda $081c	            LDA CURLINE+2
.3a264d	85 02		sta $0802	            STA BIP+2
.3a264f	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a2652	e2 20		sep #$20	            SEP #$20
.3a2654	a7 00		lda [$0800]	            LDA [BIP]
.3a2656	f0 0a		beq $3a2662	            BEQ done            ; If not, we're done
.3a2658					do_insert
.3a2658	20 a1 25	jsr $3a25a1	            JSR INSLINE
.3a265b	80 05		bra $3a2662	            BRA done
.3a265d	a5 d7		lda $08d7	do_append   LDA LINENUM
.3a265f	20 e5 24	jsr $3a24e5	            JSR APPLINE
.3a2662	28		plp		done        PLP
.3a2663	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\repl.s

="#"					CHAR_DIR = '#'
="|"					CHAR_BRUN = '|'
.3a2664					EXPANDLINE
.3a2664	0b		phd		                PHD
.3a2665	08		php		                PHP
.3a2666	08		php		            PHP
.3a2667	c2 20		rep #$20	            REP #$20
.3a2669	48		pha		            PHA
.3a266a	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a266d	5b		tcd		            TCD
.3a266e	68		pla		            PLA
.3a266f	28		plp		            PLP
.3a2670	e2 20		sep #$20	            SEP #$20
.3a2672	c2 10		rep #$10	            REP #$10
.3a2674	a2 00 00	ldx #$0000	                LDX #0
.3a2677	bd 00 4f	lda $4f00,x	count_loop      LDA INPUTBUF,X              ; Count the number of characters in the input
.3a267a	f0 03		beq $3a267f	                BEQ save_size
.3a267c	e8		inx		                INX
.3a267d	80 f8		bra $3a2677	                BRA count_loop
.3a267f	86 0c		stx $080c	save_size       STX SCRATCH                 ; Save the size in SCRATCH
.3a2681	c2 30		rep #$30	            REP #$30
.3a2683	8a		txa		                TXA
.3a2684	c9 02 00	cmp #$0002	                CMP #2                      ; Are there arguments?
.3a2687	90 12		bcc $3a269b	                BLT start_copy              ; No: just replace the whole string
.3a2689	3a		dec a		                DEC A
.3a268a	18		clc		                CLC
.3a268b	69 00 4f	adc #$4f00	                ADC #<>INPUTBUF
.3a268e	aa		tax		                TAX                         ; X <-- INPUTBUF + len(INPUTBUF) - 1
.3a268f	18		clc		                CLC                         ; Y <-- INPUTBUF + len(INPUTBUF) - 1 + len(substitution)
.3a2690	65 8f		adc $088f	                ADC MCOUNT
.3a2692	a8		tay		                TAY
.3a2693	a5 0c		lda $080c	                LDA SCRATCH
.3a2695	3a		dec a		                DEC A
.3a2696	8b		phb		                PHB
.3a2697	44 00 00	mvp #$00,#$00	                MVP #`INPUTBUF,#`INPUTBUF   ; Make room for the substitition
.3a269a	ab		plb		                PLB
.3a269b					start_copy
.3a269b	c2 20		rep #$20	            REP #$20
.3a269d	a6 55		ldx $0855	                LDX MARG1                   ; Source is data to copy
.3a269f	a0 00 4f	ldy #$4f00	                LDY #<>INPUTBUF             ; Destination is input buffer
.3a26a2	a5 8f		lda $088f	                LDA MCOUNT                  ; Number of bytes to copy
.3a26a4	8b		phb		                PHB
.3a26a5	54 00 3a	mvn #$3a,#$00	                MVN #`EXPANDLINE,#`INPUTBUF ; Copy the data
.3a26a8	ab		plb		                PLB
.3a26a9	e2 20		sep #$20	            SEP #$20
.3a26ab	a5 0c		lda $080c	                LDA SCRATCH                 ; Check again to see if we need quotes
.3a26ad	c9 02		cmp #$02	                CMP #2
.3a26af	90 18		bcc $3a26c9	                BLT done
.3a26b1	a6 8f		ldx $088f	                LDX MCOUNT                  ; If so, add a quote mark here
.3a26b3	a9 22		lda #$22	                LDA #CHAR_DQUOTE
.3a26b5	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a26b8	e8		inx		skip_to_end     INX                         ; Move to the end of the input string
.3a26b9	bd 00 4f	lda $4f00,x	                LDA INPUTBUF,X
.3a26bc	d0 fa		bne $3a26b8	                BNE skip_to_end
.3a26be	a9 22		lda #$22	                LDA #CHAR_DQUOTE            ; Add the quote to the end of the string
.3a26c0	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a26c3	a9 00		lda #$00	                LDA #0                      ; And terminate with a NULL
.3a26c5	e8		inx		                INX
.3a26c6	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a26c9	28		plp		done            PLP
.3a26ca	2b		pld		                PLD
.3a26cb	60		rts		            RTS
.3a26cc					PREPROCESS
.3a26cc	da		phx		                PHX
.3a26cd	5a		phy		                PHY
.3a26ce	8b		phb		                PHB
.3a26cf	0b		phd		                PHD
.3a26d0	08		php		                PHP
.3a26d1	08		php		            PHP
.3a26d2	c2 20		rep #$20	            REP #$20
.3a26d4	48		pha		            PHA
.3a26d5	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a26d8	5b		tcd		            TCD
.3a26d9	68		pla		            PLA
.3a26da	28		plp		            PLP
.3a26db	e2 20		sep #$20	            SEP #$20
.3a26dd	c2 10		rep #$10	            REP #$10
.3a26df	ad 00 4f	lda $4f00	                LDA INPUTBUF            ; Check the first character
.3a26e2	c9 23		cmp #$23	                CMP #CHAR_DIR           ; Is it the DIR character?
.3a26e4	f0 0a		beq $3a26f0	                BEQ expand_dir          ; Yes: expand the DIR command into place
.3a26e6	c9 7c		cmp #$7c	                CMP #CHAR_BRUN          ; Is it the BRUN character?
.3a26e8	f0 17		beq $3a2701	                BEQ expand_brun         ; Yes: expand the BRUN command into place
.3a26ea	28		plp		done            PLP
.3a26eb	2b		pld		                PLD
.3a26ec	ab		plb		                PLB
.3a26ed	7a		ply		                PLY
.3a26ee	fa		plx		                PLX
.3a26ef	60		rts		            RTS
.3a26f0					expand_dir
.3a26f0	c2 20		rep #$20	            REP #$20
.3a26f2	a9 03 00	lda #$0003	                LDA #3                  ; Set size of substitution value
.3a26f5	85 8f		sta $088f	                STA MCOUNT
.3a26f7	a9 12 27	lda #$2712	                LDA #<>dir_text         ; Set pointer to substitution value
.3a26fa	85 55		sta $0855	                STA MARG1
.3a26fc	20 64 26	jsr $3a2664	            JSR EXPANDLINE
.3a26ff	80 e9		bra $3a26ea	                BRA done
.3a2701					expand_brun
.3a2701	c2 20		rep #$20	            REP #$20
.3a2703	a9 04 00	lda #$0004	                LDA #4                  ; Set size of substitution value
.3a2706	85 8f		sta $088f	                STA MCOUNT
.3a2708	a9 16 27	lda #$2716	                LDA #<>brun_text        ; Set pointer to substitution value
.3a270b	85 55		sta $0855	                STA MARG1
.3a270d	20 64 26	jsr $3a2664	            JSR EXPANDLINE
.3a2710	80 d8		bra $3a26ea	                BRA done
>3a2712	44 49 52 00			dir_text        .null "DIR"             ; Expansion of the DIR character
>3a2716	42 52 55 4e 00			brun_text       .null "BRUN"            ; Expansion of the BRUN character
.3a271b					PRREADY
.3a271b	8b		phb		                PHB
.3a271c	08		php		                PHP
.3a271d	20 3d 02	jsr $3a023d	            JSR ENSURETEXT
.3a2720	08		php		            PHP
.3a2721	e2 20		sep #$20	            SEP #$20
.3a2723	48		pha		            PHA
.3a2724	a9 3a		lda #$3a	            LDA #`MPROMPT
.3a2726	48		pha		            PHA
.3a2727	ab		plb		            PLB
.3a2728	68		pla		            PLA
.3a2729	28		plp		            PLP
.3a272a	a2 69 d2	ldx #$d269	                LDX #<>MPROMPT
.3a272d	20 29 04	jsr $3a0429	            JSR PRINTS
.3a2730	28		plp		                PLP
.3a2731	ab		plb		                PLB
.3a2732	60		rts		            RTS
.3a2733					IREADLINE
.3a2733	08		php		                PHP
.3a2734	e2 30		sep #$30	            SEP #$30
.3a2736	a9 01		lda #$01	                LDA #1
.3a2738	20 1c 00	jsr $3a001c	            JSR SHOWCURSOR
.3a273b					read_loop
.3a273b	20 db 00	jsr $3a00db	            JSR GETKEYE
.3a273e	c9 00		cmp #$00	                CMP #0
.3a2740	f0 f9		beq $3a273b	                BEQ read_loop
.3a2742	c9 0d		cmp #$0d	                CMP #CHAR_CR
.3a2744	f0 02		beq $3a2748	                BEQ done
.3a2746	80 f3		bra $3a273b	                BRA read_loop
.3a2748	28		plp		done            PLP
.3a2749	60		rts		            RTS
.3a274a					PROCESS
.3a274a	0b		phd		                PHD
.3a274b	08		php		                PHP
.3a274c	08		php		            PHP
.3a274d	c2 20		rep #$20	            REP #$20
.3a274f	48		pha		            PHA
.3a2750	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a2753	5b		tcd		            TCD
.3a2754	68		pla		            PLA
.3a2755	28		plp		            PLP
.3a2756	c2 30		rep #$30	            REP #$30
.3a2758	64 d7		stz $08d7	                STZ LINENUM
.3a275a	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF         ; Attempt to tokenize the line that was read
.3a275d	85 1a		sta $081a	                STA CURLINE
.3a275f	a9 00 00	lda #$0000	                LDA #`CURLINE
.3a2762	85 1c		sta $081c	                STA CURLINE+2
.3a2764	20 61 09	jsr $3a0961	            JSR TOKENIZE
.3a2767	c2 20		rep #$20	            REP #$20
.3a2769	a5 d7		lda $08d7	                LDA LINENUM             ; Did we get a line number?
.3a276b	d0 05		bne $3a2772	                BNE update_line         ; Yes: attempt to add it to the program
.3a276d	20 0b 23	jsr $3a230b	            JSR EXECCMD
.3a2770	80 07		bra $3a2779	                BRA done
.3a2772					update_line
.3a2772	20 24 26	jsr $3a2624	            JSR ADDLINE
.3a2775	28		plp		no_prompt       PLP
.3a2776	2b		pld		                PLD
.3a2777	38		sec		                SEC
.3a2778	60		rts		            RTS
.3a2779	28		plp		done            PLP
.3a277a	2b		pld		                PLD
.3a277b	18		clc		                CLC
.3a277c	60		rts		            RTS
.3a277d					INTERACT
.3a277d	c2 30		rep #$30	            REP #$30
.3a277f	a2 ff fe	ldx #$feff	                LDX #<>STACK_END
.3a2782	9a		txs		                TXS
.3a2783					ready_loop
.3a2783	20 1b 27	jsr $3a271b	            JSR PRREADY
.3a2786					no_ready_loop
.3a2786	20 08 00	jsr $3a0008	            JSR READLINE
.3a2789	20 0c 00	jsr $3a000c	            JSR SCRCOPYLINE
.3a278c	22 3c 11 00	jsl $00113c	                JSL FK_TESTBREAK    ; Make sure the BREAK bit is cleared.
.3a2790	a9 00 00	lda #$0000	                LDA #0              ; Hide the cursor
.3a2793	20 1c 00	jsr $3a001c	            JSR SHOWCURSOR
.3a2796	20 cc 26	jsr $3a26cc	            JSR PREPROCESS
.3a2799	20 4a 27	jsr $3a274a	            JSR PROCESS
.3a279c	b0 e8		bcs $3a2786	                BCS no_ready_loop
.3a279e	80 e3		bra $3a2783	                BRA ready_loop
>3ad269	0d 52 45 41 44 59 0d 00		MPROMPT         .null 13,"READY",13

;******  Return to file: src\basic816.s


;******  Processing file: src\operators.s

.3a27a0					OP_PLUS
.3a27a0	08		php		            PHP
.3a27a1	e2 20		sep #$20	            SEP #$20
.3a27a3	20 68 08	jsr $3a0868	            JSR ASS_ARGS_NUMSTR
.3a27a6	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a27a8	f0 2c		beq $3a27d6	            BEQ is_integer
.3a27aa	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a27ac	f0 2d		beq $3a27db	            BEQ is_float
.3a27ae	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a27b0	f0 1f		beq $3a27d1	            BEQ is_string
.3a27b2					type_error
.3a27b2	08		php		            PHP
.3a27b3	c2 20		rep #$20	            REP #$20
.3a27b5	48		pha		            PHA
.3a27b6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a27b9	5b		tcd		            TCD
.3a27ba	68		pla		            PLA
.3a27bb	28		plp		            PLP
.3a27bc	e2 20		sep #$20	            SEP #$20
.3a27be	a9 04		lda #$04	            LDA #ERR_TYPE
.3a27c0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a27c4	c2 20		rep #$20	            REP #$20
.3a27c6	29 ff 00	and #$00ff	            AND #$00FF
.3a27c9	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a27cc	e2 20		sep #$20	            SEP #$20
.3a27ce	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a27d1					is_string
.3a27d1	20 0e 16	jsr $3a160e	            JSR STRCONCAT
.3a27d4	80 08		bra $3a27de	            BRA done
.3a27d6					is_integer
.3a27d6	20 d4 53	jsr $3a53d4	            JSR OP_INT_ADD
.3a27d9	80 03		bra $3a27de	            BRA done
.3a27db					is_float
.3a27db	20 43 56	jsr $3a5643	            JSR OP_FP_ADD
.3a27de	28		plp		done        PLP
.3a27df	60		rts		            RTS
.3a27e0					OP_MINUS
.3a27e0	08		php		            PHP
.3a27e1	e2 20		sep #$20	            SEP #$20
.3a27e3	20 1a 08	jsr $3a081a	            JSR ASS_ARGS_NUM
.3a27e6	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a27e8	f0 23		beq $3a280d	            BEQ is_integer
.3a27ea	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a27ec	f0 24		beq $3a2812	            BEQ is_float
.3a27ee					type_error
.3a27ee	08		php		            PHP
.3a27ef	c2 20		rep #$20	            REP #$20
.3a27f1	48		pha		            PHA
.3a27f2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a27f5	5b		tcd		            TCD
.3a27f6	68		pla		            PLA
.3a27f7	28		plp		            PLP
.3a27f8	e2 20		sep #$20	            SEP #$20
.3a27fa	a9 04		lda #$04	            LDA #ERR_TYPE
.3a27fc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2800	c2 20		rep #$20	            REP #$20
.3a2802	29 ff 00	and #$00ff	            AND #$00FF
.3a2805	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a2808	e2 20		sep #$20	            SEP #$20
.3a280a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a280d					is_integer
.3a280d	20 e6 53	jsr $3a53e6	            JSR OP_INT_SUB
.3a2810	80 03		bra $3a2815	            BRA done
.3a2812					is_float
.3a2812	20 38 56	jsr $3a5638	            JSR OP_FP_SUB
.3a2815	28		plp		done        PLP
.3a2816	60		rts		            RTS
.3a2817					OP_MULTIPLY
.3a2817	08		php		            PHP
.3a2818	e2 20		sep #$20	            SEP #$20
.3a281a	20 1a 08	jsr $3a081a	            JSR ASS_ARGS_NUM
.3a281d	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a281f	f0 23		beq $3a2844	            BEQ is_integer
.3a2821	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a2823	f0 24		beq $3a2849	            BEQ is_float
.3a2825					type_error
.3a2825	08		php		            PHP
.3a2826	c2 20		rep #$20	            REP #$20
.3a2828	48		pha		            PHA
.3a2829	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a282c	5b		tcd		            TCD
.3a282d	68		pla		            PLA
.3a282e	28		plp		            PLP
.3a282f	e2 20		sep #$20	            SEP #$20
.3a2831	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2833	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2837	c2 20		rep #$20	            REP #$20
.3a2839	29 ff 00	and #$00ff	            AND #$00FF
.3a283c	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a283f	e2 20		sep #$20	            SEP #$20
.3a2841	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2844					is_integer
.3a2844	20 f8 53	jsr $3a53f8	            JSR OP_INT_MUL
.3a2847	80 03		bra $3a284c	            BRA done
.3a2849					is_float
.3a2849	20 d9 56	jsr $3a56d9	            JSR OP_FP_MUL
.3a284c	28		plp		done        PLP
.3a284d	60		rts		            RTS
.3a284e					OP_DIVIDE
.3a284e	20 84 07	jsr $3a0784	            JSR ASS_ARG1_FLOAT
.3a2851	20 b5 07	jsr $3a07b5	            JSR ASS_ARG2_FLOAT
.3a2854	20 8e 56	jsr $3a568e	            JSR OP_FP_DIV
.3a2857	60		rts		            RTS
.3a2858					OP_MOD
.3a2858	a5 23		lda $0823	            LDA ARGUMENT1
.3a285a	8f 1a 01 00	sta $00011a	            STA @lD1_OPERAND_B
.3a285e	a5 29		lda $0829	            LDA ARGUMENT2
.3a2860	8f 18 01 00	sta $000118	            STA @lD1_OPERAND_A
.3a2864	af 1e 01 00	lda $00011e	            LDA @lD1_REMAINDER
.3a2868	85 23		sta $0823	            STA ARGUMENT1
.3a286a	60		rts		            RTS
.3a286b					OP_POW
.3a286b	08		php		            PHP
.3a286c	c2 30		rep #$30	            REP #$30
.3a286e	48		pha		            PHA
.3a286f	20 84 07	jsr $3a0784	            JSR ASS_ARG1_FLOAT
.3a2872	a5 2d		lda $082d	            LDA ARGTYPE2
.3a2874	c9 00 00	cmp #$0000	            CMP #TYPE_INTEGER
.3a2877	d0 0d		bne $3a2886	            BNE flt_exp
.3a2879	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a287b	d0 09		bne $3a2886	            BNE flt_exp
.3a287d	da		phx		            PHX
.3a287e	a6 29		ldx $0829	            LDX ARGUMENT2
.3a2880	20 ac 63	jsr $3a63ac	            JSR Q_FP_POW_INT
.3a2883	fa		plx		            PLX
.3a2884	80 1c		bra $3a28a2	            BRA done
.3a2886					flt_exp
.3a2886	20 b5 07	jsr $3a07b5	            JSR ASS_ARG2_FLOAT
.3a2889	c2 20		rep #$20	            REP #$20
.3a288b	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a288d	48		pha		            PHA
.3a288e	a5 29		lda $0829	            LDA ARGUMENT2
.3a2890	48		pha		            PHA
.3a2891	20 37 62	jsr $3a6237	            JSR FP_LN
.3a2894	c2 20		rep #$20	            REP #$20
.3a2896	68		pla		            PLA
.3a2897	85 29		sta $0829	            STA ARGUMENT2
.3a2899	68		pla		            PLA
.3a289a	85 2b		sta $082b	            STA ARGUMENT2+2
.3a289c	20 d9 56	jsr $3a56d9	            JSR OP_FP_MUL
.3a289f	20 16 64	jsr $3a6416	            JSR FP_EXP
.3a28a2	68		pla		done        PLA
.3a28a3	28		plp		            PLP
.3a28a4	60		rts		            RTS
.3a28a5					OP_AND
.3a28a5	08		php		            PHP
.3a28a6	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a28a9	20 47 06	jsr $3a0647	            JSR ASS_ARG2_INT
.3a28ac	c2 20		rep #$20	            REP #$20
.3a28ae	a5 23		lda $0823	            LDA ARGUMENT1
.3a28b0	25 29		and $0829	            AND ARGUMENT2
.3a28b2	85 23		sta $0823	            STA ARGUMENT1
.3a28b4	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a28b6	25 2b		and $082b	            AND ARGUMENT2+2
.3a28b8	85 25		sta $0825	            STA ARGUMENT1+2
.3a28ba	28		plp		            PLP
.3a28bb	60		rts		            RTS
.3a28bc					OP_OR
.3a28bc	08		php		            PHP
.3a28bd	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a28c0	20 47 06	jsr $3a0647	            JSR ASS_ARG2_INT
.3a28c3	c2 20		rep #$20	            REP #$20
.3a28c5	a5 23		lda $0823	            LDA ARGUMENT1
.3a28c7	05 29		ora $0829	            ORA ARGUMENT2
.3a28c9	85 23		sta $0823	            STA ARGUMENT1
.3a28cb	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a28cd	05 2b		ora $082b	            ORA ARGUMENT2+2
.3a28cf	85 25		sta $0825	            STA ARGUMENT1+2
.3a28d1	28		plp		done        PLP
.3a28d2	60		rts		            RTS
.3a28d3					OP_NOT
.3a28d3	08		php		            PHP
.3a28d4	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a28d7	c2 20		rep #$20	            REP #$20
.3a28d9	a5 23		lda $0823	            LDA ARGUMENT1
.3a28db	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a28de	85 23		sta $0823	            STA ARGUMENT1
.3a28e0	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a28e2	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a28e5	85 25		sta $0825	            STA ARGUMENT1+2
.3a28e7	28		plp		done        PLP
.3a28e8	60		rts		            RTS
.3a28e9					OP_LT
.3a28e9	08		php		            PHP
.3a28ea	e2 20		sep #$20	            SEP #$20
.3a28ec	20 68 08	jsr $3a0868	            JSR ASS_ARGS_NUMSTR
.3a28ef	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a28f1	f0 2c		beq $3a291f	            BEQ is_integer
.3a28f3	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a28f5	f0 2d		beq $3a2924	            BEQ is_float
.3a28f7	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a28f9	f0 1f		beq $3a291a	            BEQ is_string
.3a28fb					type_error
.3a28fb	08		php		            PHP
.3a28fc	c2 20		rep #$20	            REP #$20
.3a28fe	48		pha		            PHA
.3a28ff	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2902	5b		tcd		            TCD
.3a2903	68		pla		            PLA
.3a2904	28		plp		            PLP
.3a2905	e2 20		sep #$20	            SEP #$20
.3a2907	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2909	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a290d	c2 20		rep #$20	            REP #$20
.3a290f	29 ff 00	and #$00ff	            AND #$00FF
.3a2912	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a2915	e2 20		sep #$20	            SEP #$20
.3a2917	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a291a					is_string
.3a291a	20 96 17	jsr $3a1796	            JSR OP_STR_LT
.3a291d	80 08		bra $3a2927	            BRA done
.3a291f					is_integer
.3a291f	20 f9 54	jsr $3a54f9	            JSR OP_INT_LT
.3a2922	80 03		bra $3a2927	            BRA done
.3a2924					is_float
.3a2924	20 6e 5c	jsr $3a5c6e	            JSR OP_FP_LT
.3a2927	28		plp		done        PLP
.3a2928	60		rts		            RTS
.3a2929					OP_GT
.3a2929	08		php		            PHP
.3a292a	e2 20		sep #$20	            SEP #$20
.3a292c	20 68 08	jsr $3a0868	            JSR ASS_ARGS_NUMSTR
.3a292f	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a2931	f0 2c		beq $3a295f	            BEQ is_integer
.3a2933	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a2935	f0 2d		beq $3a2964	            BEQ is_float
.3a2937	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a2939	f0 1f		beq $3a295a	            BEQ is_string
.3a293b					type_error
.3a293b	08		php		            PHP
.3a293c	c2 20		rep #$20	            REP #$20
.3a293e	48		pha		            PHA
.3a293f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2942	5b		tcd		            TCD
.3a2943	68		pla		            PLA
.3a2944	28		plp		            PLP
.3a2945	e2 20		sep #$20	            SEP #$20
.3a2947	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2949	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a294d	c2 20		rep #$20	            REP #$20
.3a294f	29 ff 00	and #$00ff	            AND #$00FF
.3a2952	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a2955	e2 20		sep #$20	            SEP #$20
.3a2957	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a295a					is_string
.3a295a	20 ad 17	jsr $3a17ad	            JSR OP_STR_GT
.3a295d	80 08		bra $3a2967	            BRA done
.3a295f					is_integer
.3a295f	20 1a 55	jsr $3a551a	            JSR OP_INT_GT
.3a2962	80 03		bra $3a2967	            BRA done
.3a2964					is_float
.3a2964	20 83 5c	jsr $3a5c83	            JSR OP_FP_GT
.3a2967	28		plp		done        PLP
.3a2968	60		rts		            RTS
.3a2969					OP_EQ
.3a2969	08		php		            PHP
.3a296a	e2 20		sep #$20	            SEP #$20
.3a296c	20 68 08	jsr $3a0868	            JSR ASS_ARGS_NUMSTR
.3a296f	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a2971	f0 2c		beq $3a299f	            BEQ is_integer
.3a2973	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a2975	f0 2d		beq $3a29a4	            BEQ is_float
.3a2977	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a2979	f0 1f		beq $3a299a	            BEQ is_string
.3a297b					type_error
.3a297b	08		php		            PHP
.3a297c	c2 20		rep #$20	            REP #$20
.3a297e	48		pha		            PHA
.3a297f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2982	5b		tcd		            TCD
.3a2983	68		pla		            PLA
.3a2984	28		plp		            PLP
.3a2985	e2 20		sep #$20	            SEP #$20
.3a2987	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2989	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a298d	c2 20		rep #$20	            REP #$20
.3a298f	29 ff 00	and #$00ff	            AND #$00FF
.3a2992	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a2995	e2 20		sep #$20	            SEP #$20
.3a2997	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a299a					is_string
.3a299a	20 c4 17	jsr $3a17c4	            JSR OP_STR_EQ
.3a299d	80 08		bra $3a29a7	            BRA done
.3a299f					is_integer
.3a299f	20 47 55	jsr $3a5547	            JSR OP_INT_EQ
.3a29a2	80 03		bra $3a29a7	            BRA done
.3a29a4					is_float
.3a29a4	20 98 5c	jsr $3a5c98	            JSR OP_FP_EQ
.3a29a7	28		plp		done        PLP
.3a29a8	60		rts		            RTS
.3a29a9					OP_NE
.3a29a9	08		php		            PHP
.3a29aa	e2 20		sep #$20	            SEP #$20
.3a29ac	20 68 08	jsr $3a0868	            JSR ASS_ARGS_NUMSTR
.3a29af	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a29b1	f0 2c		beq $3a29df	            BEQ is_integer
.3a29b3	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a29b5	f0 2d		beq $3a29e4	            BEQ is_float
.3a29b7	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a29b9	f0 1f		beq $3a29da	            BEQ is_string
.3a29bb					type_error
.3a29bb	08		php		            PHP
.3a29bc	c2 20		rep #$20	            REP #$20
.3a29be	48		pha		            PHA
.3a29bf	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a29c2	5b		tcd		            TCD
.3a29c3	68		pla		            PLA
.3a29c4	28		plp		            PLP
.3a29c5	e2 20		sep #$20	            SEP #$20
.3a29c7	a9 04		lda #$04	            LDA #ERR_TYPE
.3a29c9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a29cd	c2 20		rep #$20	            REP #$20
.3a29cf	29 ff 00	and #$00ff	            AND #$00FF
.3a29d2	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a29d5	e2 20		sep #$20	            SEP #$20
.3a29d7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a29da					is_string
.3a29da	20 db 17	jsr $3a17db	            JSR OP_STR_NE
.3a29dd	80 08		bra $3a29e7	            BRA done
.3a29df					is_integer
.3a29df	20 65 55	jsr $3a5565	            JSR OP_INT_NE
.3a29e2	80 03		bra $3a29e7	            BRA done
.3a29e4					is_float
.3a29e4	20 d7 5c	jsr $3a5cd7	            JSR OP_FP_NE
.3a29e7	28		plp		done        PLP
.3a29e8	60		rts		            RTS
.3a29e9					OP_GTE
.3a29e9	08		php		            PHP
.3a29ea	e2 20		sep #$20	            SEP #$20
.3a29ec	20 68 08	jsr $3a0868	            JSR ASS_ARGS_NUMSTR
.3a29ef	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a29f1	f0 2c		beq $3a2a1f	            BEQ is_integer
.3a29f3	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a29f5	f0 2d		beq $3a2a24	            BEQ is_float
.3a29f7	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a29f9	f0 1f		beq $3a2a1a	            BEQ is_string
.3a29fb					type_error
.3a29fb	08		php		            PHP
.3a29fc	c2 20		rep #$20	            REP #$20
.3a29fe	48		pha		            PHA
.3a29ff	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2a02	5b		tcd		            TCD
.3a2a03	68		pla		            PLA
.3a2a04	28		plp		            PLP
.3a2a05	e2 20		sep #$20	            SEP #$20
.3a2a07	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2a09	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2a0d	c2 20		rep #$20	            REP #$20
.3a2a0f	29 ff 00	and #$00ff	            AND #$00FF
.3a2a12	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a2a15	e2 20		sep #$20	            SEP #$20
.3a2a17	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2a1a					is_string
.3a2a1a	20 f2 17	jsr $3a17f2	            JSR OP_STR_GTE
.3a2a1d	80 08		bra $3a2a27	            BRA done
.3a2a1f					is_integer
.3a2a1f	20 83 55	jsr $3a5583	            JSR OP_INT_GTE
.3a2a22	80 03		bra $3a2a27	            BRA done
.3a2a24					is_float
.3a2a24	20 c2 5c	jsr $3a5cc2	            JSR OP_FP_GTE
.3a2a27	28		plp		done        PLP
.3a2a28	60		rts		            RTS
.3a2a29					OP_LTE
.3a2a29	08		php		            PHP
.3a2a2a	e2 20		sep #$20	            SEP #$20
.3a2a2c	20 68 08	jsr $3a0868	            JSR ASS_ARGS_NUMSTR
.3a2a2f	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a2a31	f0 2c		beq $3a2a5f	            BEQ is_integer
.3a2a33	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a2a35	f0 2d		beq $3a2a64	            BEQ is_float
.3a2a37	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a2a39	f0 1f		beq $3a2a5a	            BEQ is_string
.3a2a3b					type_error
.3a2a3b	08		php		            PHP
.3a2a3c	c2 20		rep #$20	            REP #$20
.3a2a3e	48		pha		            PHA
.3a2a3f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2a42	5b		tcd		            TCD
.3a2a43	68		pla		            PLA
.3a2a44	28		plp		            PLP
.3a2a45	e2 20		sep #$20	            SEP #$20
.3a2a47	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2a49	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2a4d	c2 20		rep #$20	            REP #$20
.3a2a4f	29 ff 00	and #$00ff	            AND #$00FF
.3a2a52	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a2a55	e2 20		sep #$20	            SEP #$20
.3a2a57	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2a5a					is_string
.3a2a5a	20 09 18	jsr $3a1809	            JSR OP_STR_LTE
.3a2a5d	80 08		bra $3a2a67	            BRA done
.3a2a5f					is_integer
.3a2a5f	20 b0 55	jsr $3a55b0	            JSR OP_INT_LTE
.3a2a62	80 03		bra $3a2a67	            BRA done
.3a2a64					is_float
.3a2a64	20 ad 5c	jsr $3a5cad	            JSR OP_FP_LTE
.3a2a67	28		plp		done        PLP
.3a2a68	60		rts		            RTS
.3a2a69					OP_NEGATIVE
.3a2a69	08		php		                PHP
.3a2a6a	e2 20		sep #$20	            SEP #$20
.3a2a6c	a5 27		lda $0827	                LDA ARGTYPE1                ; Check the type of the argument
.3a2a6e	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a2a70	f0 2d		beq $3a2a9f	                BEQ int_negate              ; If integer: negate the integer
.3a2a72	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.3a2a74	f0 1f		beq $3a2a95	                BEQ float_negate            ; If floating point: negate the floating point
.3a2a76					type_error
.3a2a76	08		php		            PHP
.3a2a77	c2 20		rep #$20	            REP #$20
.3a2a79	48		pha		            PHA
.3a2a7a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2a7d	5b		tcd		            TCD
.3a2a7e	68		pla		            PLA
.3a2a7f	28		plp		            PLP
.3a2a80	e2 20		sep #$20	            SEP #$20
.3a2a82	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2a84	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2a88	c2 20		rep #$20	            REP #$20
.3a2a8a	29 ff 00	and #$00ff	            AND #$00FF
.3a2a8d	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a2a90	e2 20		sep #$20	            SEP #$20
.3a2a92	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2a95					float_negate
.3a2a95	e2 20		sep #$20	            SEP #$20
.3a2a97	a5 26		lda $0826	                LDA ARGUMENT1+3             ; Flip the sign bit of the floating point number
.3a2a99	49 80		eor #$80	                EOR #$80
.3a2a9b	85 26		sta $0826	                STA ARGUMENT1+3
.3a2a9d	80 16		bra $3a2ab5	                BRA done
.3a2a9f					int_negate
.3a2a9f	c2 20		rep #$20	            REP #$20
.3a2aa1	a5 23		lda $0823	                LDA ARGUMENT1               ; Invert ARGUMENT1
.3a2aa3	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a2aa6	85 23		sta $0823	                STA ARGUMENT1
.3a2aa8	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a2aaa	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a2aad	85 25		sta $0825	                STA ARGUMENT1+2
.3a2aaf	e6 23		inc $0823	                INC ARGUMENT1               ; And increment to get two's complement
.3a2ab1	d0 02		bne $3a2ab5	                BNE done
.3a2ab3	e6 25		inc $0825	                INC ARGUMENT1+2
.3a2ab5					done
.3a2ab5	28		plp		                PLP
.3a2ab6	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\statements.s


;******  Processing file: src\C256/statements_c256.s

=0					GR_LUT_BLUE = 0
=1					GR_LUT_GREEN = 1
=2					GR_LUT_RED = 2
=3					GR_LUT_ALPHA = 3
=640					GR_DEFAULT_COLS = 640               ; Default number of columns in the display
=480					GR_DEFAULT_ROWS = 480               ; Default number of rows in the display
=8					GR_MAX_LUT = 8                      ; The number of LUTs Vicky supports
=64					SP_MAX = 64                         ; The number of sprites Vicky supports
=8					SP_REG_SIZE = 8                     ; The number of bytes in a sprite's register block
=0					SP_CONTROL = 0                      ; Offset of the control regsiter for a sprite
=1					SP_ADDR = 1                         ; Offset of the pixmap address for a sprite
=4					SP_X_COORD = 4                      ; Offset of the X coordinate for a sprite
=6					SP_Y_COORD = 6                      ; Offset of the Y coordinate for a sprite
=12					TILEMAP_REG_SIZE = 12               ; The number of bytes in a tile map's register set
=4					TILESET_REG_SIZE = 4                ; The number of bytes in a tile set's register set
=2					BM_MAX = 2                          ; Maximum number of bitmaps we support
=$0040					MAX_VRAM_VICKY = $0040              ; Upper limit (exclusive) bank address for VRAM in Vicky address space
=$00f0					MAX_VRAM_CPU = $00F0                ; Upper limit (exclusive) bank address for VRAM in CPU address space
=$00b0					MIN_VRAM_CPU = $00B0                ; Lower limit (inclusive) bank address for VRAM in CPU address space
>3af000					GR_BM0_ADDR     .dword ?            ; Address of bitmap 0 (from CPU's perspective)
>3af004					GR_BM1_ADDR     .dword ?            ; Address of bitmap 1 (from CPU's perspective)
>3af008					GR_BM0_VRAM     .dword ?            ; Address of bitmap 0 (relative to start of VRAM)
>3af00c					GR_BM1_VRAM     .dword ?            ; Address of bitmap 1 (relative to start of VRAM)
>3af010					GR_MAX_COLS     .word ?             ; Width the display in pixels
>3af012					GR_MAX_ROWS     .word ?             ; Height of the display in pixels
>3af014					GR_TOTAL_PIXELS .word ?             ; Total number of pixels in the display
>3af016					GR_TEMP         .word ?             ; A temporary word for graphics commands
>3af018					GS_SP_CONTROL   .fill SP_MAX        ; Shadow registers for the sprite controls
.3a2ab7					S_SETTIME
.3a2ab7	08		php		                PHP
.3a2ab8	e2 20		sep #$20	            SEP #$20
.3a2aba	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2abd	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2ac0	20 73 05	jsr $3a0573	            JSR DIVINT10
.3a2ac3	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2ac5	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2ac6	0a		asl a		                ASL A
.3a2ac7	0a		asl a		                ASL A
.3a2ac8	0a		asl a		                ASL A
.3a2ac9	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2acb	48		pha		                PHA
.3a2acc	a9 2c		lda #$2c	                LDA #','
.3a2ace	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a2ad1	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2ad4	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2ad7	20 73 05	jsr $3a0573	            JSR DIVINT10
.3a2ada	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2adc	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2add	0a		asl a		                ASL A
.3a2ade	0a		asl a		                ASL A
.3a2adf	0a		asl a		                ASL A
.3a2ae0	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2ae2	48		pha		                PHA
.3a2ae3	a9 2c		lda #$2c	                LDA #','
.3a2ae5	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a2ae8	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2aeb	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2aee	20 73 05	jsr $3a0573	            JSR DIVINT10
.3a2af1	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2af3	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2af4	0a		asl a		                ASL A
.3a2af5	0a		asl a		                ASL A
.3a2af6	0a		asl a		                ASL A
.3a2af7	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2af9	48		pha		                PHA
.3a2afa	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.3a2afe	09 0c		ora #$0c	                ORA #%00001100
.3a2b00	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.3a2b04	68		pla		                PLA                     ; And seconds to the RTC
.3a2b05	8f 00 08 af	sta $af0800	                STA @lRTC_SEC
.3a2b09	68		pla		                PLA                     ; Minutes...
.3a2b0a	8f 02 08 af	sta $af0802	                STA @lRTC_MIN
.3a2b0e	68		pla		                PLA                     ; Save the hour...
.3a2b0f	8f 04 08 af	sta $af0804	                STA @lRTC_HRS
.3a2b13	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.3a2b17	29 f7		and #$f7	                AND #%11110111
.3a2b19	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.3a2b1d	20 1f 21	jsr $3a211f	            JSR SKIPSTMT
.3a2b20	28		plp		                PLP
.3a2b21	60		rts		            RTS
.3a2b22					S_SETDATE
.3a2b22	08		php		                PHP
.3a2b23	e2 20		sep #$20	            SEP #$20
.3a2b25	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2b28	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2b2b	20 73 05	jsr $3a0573	            JSR DIVINT10
.3a2b2e	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2b30	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2b31	0a		asl a		                ASL A
.3a2b32	0a		asl a		                ASL A
.3a2b33	0a		asl a		                ASL A
.3a2b34	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2b36	48		pha		                PHA
.3a2b37	a9 2c		lda #$2c	                LDA #','
.3a2b39	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a2b3c	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2b3f	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2b42	20 73 05	jsr $3a0573	            JSR DIVINT10
.3a2b45	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2b47	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2b48	0a		asl a		                ASL A
.3a2b49	0a		asl a		                ASL A
.3a2b4a	0a		asl a		                ASL A
.3a2b4b	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2b4d	48		pha		                PHA
.3a2b4e	a9 2c		lda #$2c	                LDA #','
.3a2b50	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a2b53	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2b56	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a2b59	20 a9 05	jsr $3a05a9	            JSR DIVINT100
.3a2b5c	c2 20		rep #$20	            REP #$20
.3a2b5e	a5 23		lda $0823	                LDA ARGUMENT1           ; Get the century
.3a2b60	85 92		sta $0892	                STA MTEMP               ; Save it in MTEMP
.3a2b62	a5 29		lda $0829	                LDA ARGUMENT2           ; Separate the 10s from the 1s digits
.3a2b64	85 23		sta $0823	                STA ARGUMENT1
.3a2b66	20 73 05	jsr $3a0573	            JSR DIVINT10
.3a2b69	e2 20		sep #$20	            SEP #$20
.3a2b6b	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2b6d	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2b6e	0a		asl a		                ASL A
.3a2b6f	0a		asl a		                ASL A
.3a2b70	0a		asl a		                ASL A
.3a2b71	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2b73	48		pha		                PHA                     ; Save the 10s and 1s in BCD
.3a2b74	c2 20		rep #$20	            REP #$20
.3a2b76	a5 92		lda $0892	                LDA MTEMP               ; Separate the 100s from the 1000s digits
.3a2b78	85 23		sta $0823	                STA ARGUMENT1
.3a2b7a	20 73 05	jsr $3a0573	            JSR DIVINT10
.3a2b7d	e2 20		sep #$20	            SEP #$20
.3a2b7f	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2b81	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2b82	0a		asl a		                ASL A
.3a2b83	0a		asl a		                ASL A
.3a2b84	0a		asl a		                ASL A
.3a2b85	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2b87	48		pha		                PHA                     ; Save the 100s and 1000s in BCD
.3a2b88	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.3a2b8c	09 0c		ora #$0c	                ORA #%00001100
.3a2b8e	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.3a2b92	68		pla		                PLA                     ; Set the century
.3a2b93	8f 0f 08 af	sta $af080f	                STA @lRTC_CENTURY
.3a2b97	68		pla		                PLA                     ; And year to the RTC
.3a2b98	8f 0a 08 af	sta $af080a	                STA @lRTC_YEAR
.3a2b9c	68		pla		                PLA                     ; Month...
.3a2b9d	8f 09 08 af	sta $af0809	                STA @lRTC_MONTH
.3a2ba1	68		pla		                PLA                     ; Save the day...
.3a2ba2	8f 06 08 af	sta $af0806	                STA @lRTC_DAY
.3a2ba6	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.3a2baa	29 f7		and #$f7	                AND #%11110111
.3a2bac	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.3a2bb0	20 1f 21	jsr $3a211f	            JSR SKIPSTMT
.3a2bb3	28		plp		                PLP
.3a2bb4	60		rts		            RTS
.3a2bb5					S_TEXTCOLOR
.3a2bb5	08		php		                PHP
.3a2bb6					locals
>0001					L_FOREGROUND    .byte ?
.3a2bb6	e2 20		sep #$20	            SEP #$20
.3a2bb8	48		pha		            PHA
.3a2bb9	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2bbc	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2bbf	e2 20		sep #$20	            SEP #$20
.3a2bc1	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the foreground position
.3a2bc3	29 0f		and #$0f	                AND #$0F
.3a2bc5	0a		asl a		                ASL A
.3a2bc6	0a		asl a		                ASL A
.3a2bc7	0a		asl a		                ASL A
.3a2bc8	0a		asl a		                ASL A
.3a2bc9	83 01		sta $01,s	                STA L_FOREGROUND    ; Save the foreground color
.3a2bcb	a9 2c		lda #$2c	                LDA #','
.3a2bcd	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a2bd0	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2bd3	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2bd6	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the background position
.3a2bd8	29 0f		and #$0f	                AND #$0F
.3a2bda	03 01		ora $01,s	                ORA L_FOREGROUND    ; Add in the foreground
.3a2bdc	8f 1e 00 00	sta $00001e	                STA @lCURCOLOR      ; And save the new color combination
.3a2be0	e2 20		sep #$20	            SEP #$20
.3a2be2	68		pla		            PLA
.3a2be3	28		plp		                PLP
.3a2be4	60		rts		            RTS
.3a2be5					S_SETBGCOLOR
.3a2be5	08		php		                PHP
.3a2be6					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.3a2be6	c2 20		rep #$20	            REP #$20
.3a2be8	f4 00 00	pea #$0000	            PEA #0
.3a2beb	e2 20		sep #$20	            SEP #$20
.3a2bed	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2bf0	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2bf3	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.3a2bf5	83 01		sta $01,s	                STA L_RED
.3a2bf7	a9 2c		lda #$2c	                LDA #','
.3a2bf9	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a2bfc	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2bff	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2c02	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.3a2c04	83 02		sta $02,s	                STA L_GREEN
.3a2c06	a9 2c		lda #$2c	                LDA #','
.3a2c08	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a2c0b	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2c0e	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2c11	a5 23		lda $0823	                LDA ARGUMENT1               ; And set the actual color
.3a2c13	8f 0d 00 af	sta $af000d	                STA @lBACKGROUND_COLOR_B
.3a2c17	a3 02		lda $02,s	                LDA L_GREEN
.3a2c19	8f 0e 00 af	sta $af000e	                STA @lBACKGROUND_COLOR_G
.3a2c1d	a3 01		lda $01,s	                LDA L_RED
.3a2c1f	8f 0f 00 af	sta $af000f	                STA @lBACKGROUND_COLOR_R
.3a2c23	c2 20		rep #$20	            REP #$20
.3a2c25	68		pla		            PLA
.3a2c26	28		plp		                PLP
.3a2c27	60		rts		            RTS
.3a2c28					S_SETBORDER
.3a2c28	08		php		                PHP
.3a2c29					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.3a2c29	c2 20		rep #$20	            REP #$20
.3a2c2b	f4 00 00	pea #$0000	            PEA #0
.3a2c2e	e2 20		sep #$20	            SEP #$20
.3a2c30	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2c33	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a2c36	a5 23		lda $0823	                LDA ARGUMENT1
.3a2c38	f0 16		beq $3a2c50	                BEQ hide_border
.3a2c3a	a9 01		lda #$01	                LDA #Border_Ctrl_Enable     ; Enable the border
.3a2c3c	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.3a2c40	a9 20		lda #$20	                LDA #BORDER_WIDTH           ; Set the border width
.3a2c42	8f 08 00 af	sta $af0008	                STA BORDER_X_SIZE
.3a2c46	8f 09 00 af	sta $af0009	                STA BORDER_Y_SIZE
.3a2c4a	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.3a2c4e	80 0a		bra $3a2c5a	                BRA get_color
.3a2c50	a9 00		lda #$00	hide_border     LDA #0                      ; Hide the border
.3a2c52	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.3a2c56	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.3a2c5a	a9 2c		lda #$2c	get_color       LDA #','
.3a2c5c	85 37		sta $0837	                STA TARGETTOK
.3a2c5e	20 1c 22	jsr $3a221c	            JSR OPT_TOK
.3a2c61	90 39		bcc $3a2c9c	                BCC done                    ; No: we're done
.3a2c63	20 da 20	jsr $3a20da	            JSR INCBIP
.3a2c66	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2c69	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2c6c	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.3a2c6e	83 01		sta $01,s	                STA L_RED
.3a2c70	a9 2c		lda #$2c	                LDA #','
.3a2c72	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a2c75	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2c78	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2c7b	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.3a2c7d	83 02		sta $02,s	                STA L_GREEN
.3a2c7f	a9 2c		lda #$2c	                LDA #','
.3a2c81	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a2c84	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2c87	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2c8a	a5 23		lda $0823	                LDA ARGUMENT1
.3a2c8c	8f 05 00 af	sta $af0005	                STA @lBORDER_COLOR_B        ; Set the border color
.3a2c90	a3 02		lda $02,s	                LDA L_GREEN
.3a2c92	8f 06 00 af	sta $af0006	                STA @lBORDER_COLOR_G
.3a2c96	a3 01		lda $01,s	                LDA L_RED
.3a2c98	8f 07 00 af	sta $af0007	                STA @lBORDER_COLOR_R
.3a2c9c					done
.3a2c9c	c2 20		rep #$20	            REP #$20
.3a2c9e	68		pla		            PLA
.3a2c9f	28		plp		                PLP
.3a2ca0	60		rts		            RTS
.3a2ca1					S_SETCOLOR
.3a2ca1	08		php		                PHP
.3a2ca2					locals
>0001					L_LUT           .byte ?
>0002					L_COLOR         .byte ?
>0003					L_RED           .byte ?
>0004					L_GREEN         .byte ?
>0005					L_BLUE          .byte ?
.3a2ca2	c2 20		rep #$20	            REP #$20
.3a2ca4	3b		tsc		            TSC
.3a2ca5	38		sec		            SEC
.3a2ca6	e9 05 00	sbc #$0005	            SBC #SIZE(locals)
.3a2ca9	1b		tcs		            TCS
.3a2caa	e2 20		sep #$20	            SEP #$20
.3a2cac	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2caf	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2cb2	a5 23		lda $0823	                LDA ARGUMENT1
.3a2cb4	c9 0a		cmp #$0a	                CMP #10             ; And in range
.3a2cb6	90 1f		bcc $3a2cd7	                BLT save_lut
.3a2cb8					bad_argument
.3a2cb8	08		php		            PHP
.3a2cb9	c2 20		rep #$20	            REP #$20
.3a2cbb	48		pha		            PHA
.3a2cbc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2cbf	5b		tcd		            TCD
.3a2cc0	68		pla		            PLA
.3a2cc1	28		plp		            PLP
.3a2cc2	e2 20		sep #$20	            SEP #$20
.3a2cc4	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a2cc6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2cca	c2 20		rep #$20	            REP #$20
.3a2ccc	29 ff 00	and #$00ff	            AND #$00FF
.3a2ccf	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a2cd2	e2 20		sep #$20	            SEP #$20
.3a2cd4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2cd7	83 01		sta $01,s	save_lut        STA L_LUT           ; Save as LUT
.3a2cd9	a9 2c		lda #$2c	                LDA #','
.3a2cdb	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a2cde	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2ce1	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2ce4	a5 23		lda $0823	                LDA ARGUMENT1
.3a2ce6	83 02		sta $02,s	                STA L_COLOR         ; Save as COLOR
.3a2ce8	a9 2c		lda #$2c	                LDA #','
.3a2cea	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a2ced	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2cf0	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2cf3	a5 23		lda $0823	                LDA ARGUMENT1
.3a2cf5	83 03		sta $03,s	                STA L_RED           ; Save as RED
.3a2cf7	a9 2c		lda #$2c	                LDA #','
.3a2cf9	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a2cfc	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2cff	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2d02	a5 23		lda $0823	                LDA ARGUMENT1
.3a2d04	83 04		sta $04,s	                STA L_GREEN         ; Save it as GREEN
.3a2d06	a9 2c		lda #$2c	                LDA #','
.3a2d08	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a2d0b	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2d0e	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2d11	a5 23		lda $0823	                LDA ARGUMENT1
.3a2d13	83 05		sta $05,s	                STA L_BLUE          ; Save it as BLUE
.3a2d15	a9 af		lda #$af	                LDA #`GRPH_LUT0_PTR ; Get the bank Vicky is in (should always be $AF)
.3a2d17	85 a0		sta $08a0	                STA MTEMPPTR+2      ; MTEMPPTR will be our pointer to the LUT entry
.3a2d19	a3 01		lda $01,s	                LDA L_LUT           ; Compute the offset to the LUT address
.3a2d1b	0a		asl a		                ASL A
.3a2d1c	c2 20		rep #$20	            REP #$20
.3a2d1e	29 ff 00	and #$00ff	                AND #$00FF
.3a2d21	aa		tax		                TAX                 ; Put it in X
.3a2d22	bf 59 2d 3a	lda $3a2d59,x	                LDA @llut_address,X ; Get the address of the LUT
.3a2d26	85 9e		sta $089e	                STA MTEMPPTR        ; Put it in MTEMPPTR
.3a2d28	e2 20		sep #$20	            SEP #$20
.3a2d2a	a3 02		lda $02,s	                LDA L_COLOR         ; color index *= 4
.3a2d2c	c2 20		rep #$20	            REP #$20
.3a2d2e	29 ff 00	and #$00ff	                AND #$00FF
.3a2d31	0a		asl a		                ASL A               ; Since each color has four bytes of data
.3a2d32	0a		asl a		                ASL A
.3a2d33	18		clc		                CLC                 ; Add the color offset to MTEMPPTR
.3a2d34	65 9e		adc $089e	                ADC MTEMPPTR
.3a2d36	85 9e		sta $089e	                STA MTEMPPTR
.3a2d38	e2 20		sep #$20	            SEP #$20
.3a2d3a	a0 02 00	ldy #$0002	                LDY #GR_LUT_RED
.3a2d3d	a3 03		lda $03,s	                LDA L_RED
.3a2d3f	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the red component to the color entry
.3a2d41	a0 01 00	ldy #$0001	                LDY #GR_LUT_GREEN
.3a2d44	a3 04		lda $04,s	                LDA L_GREEN
.3a2d46	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the green component to the color entry
.3a2d48	a0 00 00	ldy #$0000	                LDY #GR_LUT_BLUE
.3a2d4b	a3 05		lda $05,s	                LDA L_BLUE
.3a2d4d	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the blue component to the color entry
.3a2d4f					done
.3a2d4f	c2 20		rep #$20	            REP #$20
.3a2d51	3b		tsc		            TSC
.3a2d52	18		clc		            CLC
.3a2d53	69 05 00	adc #$0005	            ADC #SIZE(locals)
.3a2d56	1b		tcs		            TCS
.3a2d57	28		plp		                PLP
.3a2d58	60		rts		            RTS
>3a2d59	00 20				lut_address     .word <>GRPH_LUT0_PTR
>3a2d5b	00 24				                .word <>GRPH_LUT1_PTR
>3a2d5d	00 28				                .word <>GRPH_LUT2_PTR
>3a2d5f	00 2c				                .word <>GRPH_LUT3_PTR
>3a2d61	00 30				                .word <>GRPH_LUT4_PTR
>3a2d63	00 34				                .word <>GRPH_LUT5_PTR
>3a2d65	00 38				                .word <>GRPH_LUT6_PTR
>3a2d67	00 3c				                .word <>GRPH_LUT7_PTR
>3a2d69	40 1f				                .word <>FG_CHAR_LUT_PTR
>3a2d6b	80 1f				                .word <>BG_CHAR_LUT_PTR
.3a2d6d					S_GRAPHICS
.3a2d6d	da		phx		                PHX
.3a2d6e	5a		phy		                PHY
.3a2d6f	08		php		                PHP
.3a2d70	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2d73	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a2d76	c2 20		rep #$20	            REP #$20
.3a2d78	a5 23		lda $0823	                LDA ARGUMENT1               ; Check to see if we're setting mode to 800x600 or 400x300
.3a2d7a	89 00 01	bit #$0100	                BIT #$0100
.3a2d7d	d0 17		bne $3a2d96	                BNE set_mode                ; Yes: go ahead and set it
.3a2d7f	af 00 00 af	lda $af0000	                LDA @l MASTER_CTRL_REG_L    ; Otherwise, check to see if we're already in 800x600 or 400x300
.3a2d83	89 00 01	bit #$0100	                BIT #$0100
.3a2d86	f0 0e		beq $3a2d96	                BEQ set_mode                ; No: just go ahead and set the mode
.3a2d88	e2 20		sep #$20	            SEP #$20
.3a2d8a	a9 00		lda #$00	                LDA #0                      ; Yes: toggle back to 640x480...
.3a2d8c	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.3a2d90	a9 01		lda #$01	                LDA #1                      ; And back to 800x600....
.3a2d92	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.3a2d96					set_mode
.3a2d96	c2 20		rep #$20	            REP #$20
.3a2d98	a5 23		lda $0823	                LDA ARGUMENT1
.3a2d9a	8f 00 00 af	sta $af0000	                STA @l MASTER_CTRL_REG_L    ; Set the graphics mode
.3a2d9e	e2 20		sep #$20	            SEP #$20
.3a2da0	a5 24		lda $0824	                LDA ARGUMENT1+1             ; Get the screen size bits
.3a2da2	c2 20		rep #$20	            REP #$20
.3a2da4	29 03 00	and #$0003	                AND #$0003
.3a2da7	0a		asl a		                ASL A                       ; Multiply by two to get the index
.3a2da8	aa		tax		                TAX                         ; X is index into the size tables
.3a2da9	c2 20		rep #$20	            REP #$20
.3a2dab	bf f4 2d 3a	lda $3a2df4,x	                LDA gr_columns,X            ; Set the columns
.3a2daf	8f 10 f0 3a	sta $3af010	                STA @lGR_MAX_COLS
.3a2db3	bf fc 2d 3a	lda $3a2dfc,x	                LDA gr_rows,X               ; Set the rows
.3a2db7	8f 12 f0 3a	sta $3af012	                STA @lGR_MAX_ROWS
.3a2dbb	af 10 f0 3a	lda $3af010	                LDA @lGR_MAX_COLS           ; Get the current columns
.3a2dbf	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.3a2dc3	af 12 f0 3a	lda $3af012	                LDA @lGR_MAX_ROWS           ; Get the current rows
.3a2dc7	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B
.3a2dcb	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT             ; Multiply them to get the total pixels
.3a2dcf	8f 14 f0 3a	sta $3af014	                STA @lGR_TOTAL_PIXELS
.3a2dd3	e2 20		sep #$20	            SEP #$20
.3a2dd5	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.3a2dd9	8f 16 f0 3a	sta $3af016	                STA @lGR_TOTAL_PIXELS+2
.3a2ddd	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.3a2de1					reset_cursor
.3a2de1	c2 20		rep #$20	            REP #$20
.3a2de3	af 1a 00 00	lda $00001a	                LDA @lCURSORX
.3a2de7	aa		tax		                TAX
.3a2de8	af 1c 00 00	lda $00001c	                LDA @lCURSORY
.3a2dec	a8		tay		                TAY
.3a2ded	20 20 00	jsr $3a0020	            JSR CURSORXY
.3a2df0	28		plp		                PLP
.3a2df1	7a		ply		                PLY
.3a2df2	fa		plx		                PLX
.3a2df3	60		rts		            RTS
>3a2df4	80 02 20 03 40 01 90 01		gr_columns      .word 640,800,320,400
>3a2dfc	e0 01 58 02 f0 00 2c 01		gr_rows         .word 480,600,240,300
>3a2e04	50 00 64 00 28 00 32 00		col_count       .word 80,100,40,50
>3a2e0c	3c 00 4b 00 1e 00 32 00		row_count       .word 60,75,30,50
>3a2e14	48 00 5c 00 20 00 2a 00		colb_count      .word 72,92,32,42
>3a2e1c	34 00 43 00 16 00 34 00		rowb_count      .word 52,67,22,52
.3a2e24					BITMAP_SRAM
.3a2e24	da		phx		                PHX
.3a2e25	08		php		                PHP
.3a2e26	c2 30		rep #$30	            REP #$30
.3a2e28	c9 02 00	cmp #$0002	                CMP #BM_MAX
.3a2e2b	b0 1c		bcs $3a2e49	                BGE range_err           ; Make sure it's within range
.3a2e2d	0a		asl a		                ASL A
.3a2e2e	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.3a2e2f	aa		tax		                TAX
.3a2e30	bf 00 f0 3a	lda $3af000,x	                LDA @l GR_BM0_ADDR,X    ; Get the low 16-bits of the address
.3a2e34	85 9e		sta $089e	                STA MTEMPPTR
.3a2e36	bf 02 f0 3a	lda $3af002,x	                LDA @l GR_BM0_ADDR+2,X  ; Get the high bits of the address
.3a2e3a	85 a0		sta $08a0	                STA MTEMPPTR+2
.3a2e3c	c9 f0 00	cmp #$00f0	                CMP #MAX_VRAM_CPU       ; Check to make sure address is within VRAM
.3a2e3f	b0 08		bcs $3a2e49	                BGE range_err
.3a2e41	c9 b0 00	cmp #$00b0	                CMP #MIN_VRAM_CPU
.3a2e44	90 03		bcc $3a2e49	                BLT range_err
.3a2e46	28		plp		                PLP
.3a2e47	fa		plx		                PLX
.3a2e48	60		rts		            RTS
.3a2e49					range_err
.3a2e49	08		php		            PHP
.3a2e4a	c2 20		rep #$20	            REP #$20
.3a2e4c	48		pha		            PHA
.3a2e4d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2e50	5b		tcd		            TCD
.3a2e51	68		pla		            PLA
.3a2e52	28		plp		            PLP
.3a2e53	e2 20		sep #$20	            SEP #$20
.3a2e55	a9 09		lda #$09	            LDA #ERR_RANGE
.3a2e57	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2e5b	c2 20		rep #$20	            REP #$20
.3a2e5d	29 ff 00	and #$00ff	            AND #$00FF
.3a2e60	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a2e63	e2 20		sep #$20	            SEP #$20
.3a2e65	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2e68					BITMAP_VRAM
.3a2e68	da		phx		                PHX
.3a2e69	08		php		                PHP
.3a2e6a	c2 30		rep #$30	            REP #$30
.3a2e6c	c9 02 00	cmp #$0002	                CMP #BM_MAX
.3a2e6f	b0 17		bcs $3a2e88	                BGE range_err           ; Make sure it's within range
.3a2e71	0a		asl a		                ASL A
.3a2e72	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.3a2e73	aa		tax		                TAX
.3a2e74	bf 08 f0 3a	lda $3af008,x	                LDA @l GR_BM0_VRAM,X    ; Get the low 16-bits of the address
.3a2e78	85 9e		sta $089e	                STA MTEMPPTR
.3a2e7a	bf 0a f0 3a	lda $3af00a,x	                LDA @l GR_BM0_VRAM+2,X  ; Get the high bits of the address
.3a2e7e	85 a0		sta $08a0	                STA MTEMPPTR+2
.3a2e80	c9 40 00	cmp #$0040	                CMP #MAX_VRAM_VICKY     ; Check to make sure the address is from $00:0000 - $3F:FFFF
.3a2e83	b0 03		bcs $3a2e88	                BGE range_err           ; If not, throw a range error
.3a2e85	28		plp		                PLP
.3a2e86	fa		plx		                PLX
.3a2e87	60		rts		            RTS
.3a2e88					range_err
.3a2e88	08		php		            PHP
.3a2e89	c2 20		rep #$20	            REP #$20
.3a2e8b	48		pha		            PHA
.3a2e8c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2e8f	5b		tcd		            TCD
.3a2e90	68		pla		            PLA
.3a2e91	28		plp		            PLP
.3a2e92	e2 20		sep #$20	            SEP #$20
.3a2e94	a9 09		lda #$09	            LDA #ERR_RANGE
.3a2e96	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2e9a	c2 20		rep #$20	            REP #$20
.3a2e9c	29 ff 00	and #$00ff	            AND #$00FF
.3a2e9f	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a2ea2	e2 20		sep #$20	            SEP #$20
.3a2ea4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2ea7					S_BITMAP
.3a2ea7	08		php		                PHP
.3a2ea8					locals
>0001					L_PLANE         .word ?
>0003					L_VISIBLE       .byte ?
>0004					L_ADDRESS       .dword ?
.3a2ea8	c2 30		rep #$30	            REP #$30
.3a2eaa	3b		tsc		                TSC                         ; Allocate space for the locals on the stack
.3a2eab	38		sec		                SEC
.3a2eac	e9 07 00	sbc #$0007	                SBC #SIZE(locals)
.3a2eaf	1b		tcs		                TCS
.3a2eb0	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2eb3	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2eb6	c2 20		rep #$20	            REP #$20
.3a2eb8	a5 23		lda $0823	                LDA ARGUMENT1               ; Make sure it's in range
.3a2eba	c9 02 00	cmp #$0002	                CMP #BM_MAX
.3a2ebd	b0 59		bcs $3a2f18	                BGE range_err               ; If not, throw an error
.3a2ebf	83 01		sta $01,s	                STA L_PLANE                 ; If so, save it to MARG1
.3a2ec1	e2 20		sep #$20	            SEP #$20
.3a2ec3	a9 2c		lda #$2c	                LDA #','
.3a2ec5	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a2ec8	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2ecb	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2ece	a5 23		lda $0823	                LDA ARGUMENT1
.3a2ed0	83 03		sta $03,s	                STA L_VISIBLE
.3a2ed2	a9 2c		lda #$2c	                LDA #','
.3a2ed4	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a2ed7	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2eda	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2edd	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the number back
.3a2edf	0a		asl a		                ASL A                       ; Multiply by 8 to get the offset to the registers
.3a2ee0	0a		asl a		                ASL A
.3a2ee1	0a		asl a		                ASL A
.3a2ee2	aa		tax		                TAX                         ; And save that offset to X
.3a2ee3	a3 03		lda $03,s	                LDA L_VISIBLE               ; Check the visible flag
.3a2ee5	d0 05		bne $3a2eec	                BNE is_visible              ; If <> 0, it's visible
.3a2ee7	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the LUT #
.3a2ee9	0a		asl a		                ASL A                       ; Shift it into position for the register
.3a2eea	80 04		bra $3a2ef0	                BRA wr_bm_reg               ; And go to write it
.3a2eec	a5 23		lda $0823	is_visible      LDA ARGUMENT1               ; Get the LUT #
.3a2eee	38		sec		                SEC
.3a2eef	2a		rol a		                ROL A                       ; And shift it into position, and set enable bit
.3a2ef0	9f 00 01 af	sta $af0100,x	wr_bm_reg       STA @l BM0_CONTROL_REG,X    ; Write to the bitmap control register
.3a2ef4	c2 20		rep #$20	            REP #$20
.3a2ef6	a9 2c 00	lda #$002c	                LDA #','
.3a2ef9	85 37		sta $0837	                STA TARGETTOK
.3a2efb	20 1c 22	jsr $3a221c	            JSR OPT_TOK
.3a2efe	b0 37		bcs $3a2f37	                BCS get_address             ; Yes: parse the address
.3a2f00	c2 20		rep #$20	            REP #$20
.3a2f02	08		php		            PHP
.3a2f03	c2 20		rep #$20	            REP #$20
.3a2f05	a9 00 00	lda #$0000	            LDA #<>VRAM
.3a2f08	85 23		sta $0823	            STA ARGUMENT1
.3a2f0a	a9 b0 00	lda #$00b0	            LDA #(VRAM >> 16)
.3a2f0d	85 25		sta $0825	            STA ARGUMENT1+2
.3a2f0f	e2 20		sep #$20	            SEP #$20
.3a2f11	a9 00		lda #$00	            LDA #TYPE_INTEGER
.3a2f13	85 27		sta $0827	            STA ARGUMENT1+4
.3a2f15	28		plp		            PLP
.3a2f16	80 27		bra $3a2f3f	                BRA set_address
.3a2f18					range_err
.3a2f18	08		php		            PHP
.3a2f19	c2 20		rep #$20	            REP #$20
.3a2f1b	48		pha		            PHA
.3a2f1c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2f1f	5b		tcd		            TCD
.3a2f20	68		pla		            PLA
.3a2f21	28		plp		            PLP
.3a2f22	e2 20		sep #$20	            SEP #$20
.3a2f24	a9 09		lda #$09	            LDA #ERR_RANGE
.3a2f26	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2f2a	c2 20		rep #$20	            REP #$20
.3a2f2c	29 ff 00	and #$00ff	            AND #$00FF
.3a2f2f	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a2f32	e2 20		sep #$20	            SEP #$20
.3a2f34	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2f37					get_address
.3a2f37	c2 20		rep #$20	            REP #$20
.3a2f39	20 da 20	jsr $3a20da	            JSR INCBIP
.3a2f3c	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2f3f					set_address
.3a2f3f	c2 20		rep #$20	            REP #$20
.3a2f41	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.3a2f43	0a		asl a		                ASL A                       ; Multiply by four to get the offset to the address variable
.3a2f44	0a		asl a		                ASL A
.3a2f45	aa		tax		                TAX                         ; And put it in X
.3a2f46	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the CPU-space address
.3a2f48	9f 00 f0 3a	sta $3af000,x	                STA @l GR_BM0_ADDR,X        ; And save it to the correct GR_BM?_ADDR variable
.3a2f4c	9f 08 f0 3a	sta $3af008,x	                STA @l GR_BM0_VRAM,X
.3a2f50	83 04		sta $04,s	                STA L_ADDRESS               ; And L_ADDRESS, temporarily
.3a2f52	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a2f54	9f 02 f0 3a	sta $3af002,x	                STA @l GR_BM0_ADDR+2,X
.3a2f58	38		sec		                SEC
.3a2f59	e9 b0 00	sbc #$00b0	                SBC #`VRAM                  ; Rebase the upper half of the address to Vicky memory space
.3a2f5c	9f 0a f0 3a	sta $3af00a,x	                STA @l GR_BM0_VRAM+2,X
.3a2f60	83 06		sta $06,s	                STA L_ADDRESS+2             ; And to L_ADDRESS
.3a2f62	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.3a2f64	0a		asl a		                ASL A                       ; Multiply by eight to get the offset to the registers
.3a2f65	0a		asl a		                ASL A
.3a2f66	0a		asl a		                ASL A
.3a2f67	aa		tax		                TAX                         ; And put it in X
.3a2f68	e2 20		sep #$20	            SEP #$20
.3a2f6a	a3 04		lda $04,s	                LDA L_ADDRESS               ; Get the address in Vicky space...
.3a2f6c	9f 01 01 af	sta $af0101,x	                STA @l BM0_START_ADDY_L,X   ; Save it to the Vicky registers
.3a2f70	a3 05		lda $05,s	                LDA L_ADDRESS+1
.3a2f72	9f 02 01 af	sta $af0102,x	                STA @l BM0_START_ADDY_M,X
.3a2f76	a3 06		lda $06,s	                LDA L_ADDRESS+2
.3a2f78	9f 03 01 af	sta $af0103,x	                STA @l BM0_START_ADDY_H,X
.3a2f7c	a9 00		lda #$00	                LDA #0                      ; Default offset to (0, 0)
.3a2f7e	9f 04 01 af	sta $af0104,x	                STA @l BM0_X_OFFSET,X
.3a2f82	9f 05 01 af	sta $af0105,x	                STA @l BM0_Y_OFFSET,X
.3a2f86	c2 30		rep #$30	            REP #$30
.3a2f88	3b		tsc		                TSC                         ; Remove the space for the locals from the stack
.3a2f89	18		clc		                CLC
.3a2f8a	69 07 00	adc #$0007	                ADC #SIZE(locals)
.3a2f8d	1b		tcs		                TCS
.3a2f8e	28		plp		                PLP
.3a2f8f	60		rts		            RTS
.3a2f90					bad_address
.3a2f90	08		php		            PHP
.3a2f91	c2 20		rep #$20	            REP #$20
.3a2f93	48		pha		            PHA
.3a2f94	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2f97	5b		tcd		            TCD
.3a2f98	68		pla		            PLA
.3a2f99	28		plp		            PLP
.3a2f9a	e2 20		sep #$20	            SEP #$20
.3a2f9c	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a2f9e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2fa2	c2 20		rep #$20	            REP #$20
.3a2fa4	29 ff 00	and #$00ff	            AND #$00FF
.3a2fa7	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a2faa	e2 20		sep #$20	            SEP #$20
.3a2fac	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2faf					S_CLRBITMAP
.3a2faf	08		php		                PHP
.3a2fb0	c2 20		rep #$20	            REP #$20
.3a2fb2	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a2fb5	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a2fb8	a5 23		lda $0823	                LDA ARGUMENT1
.3a2fba	20 68 2e	jsr $3a2e68	            JSR BITMAP_VRAM
.3a2fbd	c2 20		rep #$20	            REP #$20
.3a2fbf	a5 9e		lda $089e	                LDA MTEMPPTR                ; Set the start address and the # of pixels to write
.3a2fc1	8f 05 04 af	sta $af0405	                STA @lVDMA_DST_ADDY_L
.3a2fc5	af 14 f0 3a	lda $3af014	                LDA @lGR_TOTAL_PIXELS       ; Set the size
.3a2fc9	8f 08 04 af	sta $af0408	                STA @lVDMA_SIZE_L
.3a2fcd	e2 20		sep #$20	            SEP #$20
.3a2fcf	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.3a2fd1	8f 07 04 af	sta $af0407	                STA @lVDMA_DST_ADDY_H
.3a2fd5	af 16 f0 3a	lda $3af016	                LDA @lGR_TOTAL_PIXELS+2
.3a2fd9	8f 0a 04 af	sta $af040a	                STA @lVDMA_SIZE_H
.3a2fdd	a9 00		lda #$00	                LDA #0                      ; Set the color to write
.3a2fdf	8f 01 04 af	sta $af0401	                STA @lVDMA_BYTE_2_WRITE
.3a2fe3	a9 85		lda #$85	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_Start_TRF
.3a2fe5	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.3a2fe9	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.3a2fed	30 fa		bmi $3a2fe9	                BMI wait
.3a2fef	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.3a2ff1	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.3a2ff5	28		plp		done            PLP
.3a2ff6	60		rts		            RTS
=$000855				COLOR = MARG1
=$000859				X0 = MARG2
=$00085d				Y0 = MARG3
=$000861				X1 = MARG4
=$000865				Y1 = MARG5
=$000869				DX = MARG6
=$00086d				DY = MARG7
=$000871				ERR = MARG8
=$000875				ERR2 = MARG9
>08dd					SX      .word ?
>08df					SY      .word ?
.3a2ff7					PLOT
.3a2ff7	08		php		                PHP
.3a2ff8	c2 20		rep #$20	            REP #$20
.3a2ffa	a5 59		lda $0859	                LDA X0                      ; Get the column
.3a2ffc	cf 10 f0 3a	cmp $3af010	                CMP @l GR_MAX_COLS          ; Make sure it's in range for this graphics mode
.3a3000	90 1f		bcc $3a3021	                BLT chk_row                 ; If so: check the row
.3a3002					range_err
.3a3002	08		php		            PHP
.3a3003	c2 20		rep #$20	            REP #$20
.3a3005	48		pha		            PHA
.3a3006	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3009	5b		tcd		            TCD
.3a300a	68		pla		            PLA
.3a300b	28		plp		            PLP
.3a300c	e2 20		sep #$20	            SEP #$20
.3a300e	a9 09		lda #$09	            LDA #ERR_RANGE
.3a3010	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3014	c2 20		rep #$20	            REP #$20
.3a3016	29 ff 00	and #$00ff	            AND #$00FF
.3a3019	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a301c	e2 20		sep #$20	            SEP #$20
.3a301e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3021					chk_row
.3a3021	c2 30		rep #$30	            REP #$30
.3a3023	a5 5d		lda $085d	                LDA Y0                      ; Get the row
.3a3025	cf 12 f0 3a	cmp $3af012	                CMP @l GR_MAX_ROWS          ; Make sure it's in range for this graphics mode
.3a3029	b0 d7		bcs $3a3002	                BGE range_err               ; If not: throw an error
.3a302b	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.3a302f	af 10 f0 3a	lda $3af010	                LDA @lGR_MAX_COLS
.3a3033	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B          ; Multiply by the number of columns in the pixmap
.3a3037	18		clc		                CLC                         ; Add the column
.3a3038	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT
.3a303c	65 59		adc $0859	                ADC X0
.3a303e	85 0c		sta $080c	                STA SCRATCH
.3a3040	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.3a3044	69 00 00	adc #$0000	                ADC #0
.3a3047	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH is offset of pixel in the pixmap
.3a3049	18		clc		                CLC                         ; Add the address of the first pixel
.3a304a	a5 0c		lda $080c	                LDA SCRATCH
.3a304c	65 9e		adc $089e	                ADC MTEMPPTR
.3a304e	85 0c		sta $080c	                STA SCRATCH
.3a3050	a5 0e		lda $080e	                LDA SCRATCH+2
.3a3052	65 a0		adc $08a0	                ADC MTEMPPTR+2
.3a3054	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH := pixmap + pixel offset
.3a3056	e2 20		sep #$20	            SEP #$20
.3a3058	a5 55		lda $0855	                LDA COLOR                   ; Get the color
.3a305a	87 0c		sta [$080c]	                STA [SCRATCH]               ; And write the color to the pixel
.3a305c	28		plp		done            PLP
.3a305d	60		rts		            RTS
.3a305e					LINE
.3a305e	c2 20		rep #$20	            REP #$20
.3a3060	a9 01 00	lda #$0001	                LDA #1                      ; Assume SX = 1
.3a3063	85 dd		sta $08dd	                STA SX
.3a3065	38		sec		                SEC                         ; DX := ABS(X1 - X0)
.3a3066	a5 61		lda $0861	                LDA X1
.3a3068	e5 59		sbc $0859	                SBC X0
.3a306a	85 69		sta $0869	                STA DX
.3a306c	10 0b		bpl $3a3079	                BPL abs_Y                   ; If DX < 0 {
.3a306e	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DX := -DX
.3a3071	1a		inc a		                INC A
.3a3072	85 69		sta $0869	                STA DX
.3a3074	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SX := -1
.3a3077	85 dd		sta $08dd	                STA SX                      ; }
.3a3079	a9 01 00	lda #$0001	abs_Y           LDA #1                      ; Assume SY = 1
.3a307c	85 df		sta $08df	                STA SY
.3a307e	38		sec		                SEC                         ; DY := ABS(Y1 - Y0)
.3a307f	a5 65		lda $0865	                LDA Y1
.3a3081	e5 5d		sbc $085d	                SBC Y0
.3a3083	85 6d		sta $086d	                STA DY
.3a3085	10 0b		bpl $3a3092	                BPL calc_ERR                ; If DY < 0 {
.3a3087	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DY := -DY
.3a308a	1a		inc a		                INC A
.3a308b	85 6d		sta $086d	                STA DY
.3a308d	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SY := -1
.3a3090	85 df		sta $08df	                STA SY                      ; }
.3a3092	a5 6d		lda $086d	calc_ERR        LDA DY
.3a3094	c9 01 00	cmp #$0001	                CMP #1                      ; Is DY = 1?
.3a3097	d0 19		bne $3a30b2	                BNE cmp_dx                  ; No: compare to DX
.3a3099	a5 69		lda $0869	                LDA DX
.3a309b	c9 01 00	cmp #$0001	                CMP #1                      ; Is DX = 1 too?
.3a309e	d0 10		bne $3a30b0	                BNE cmp_dy_dx               ; No: treat normally
.3a30a0	20 f7 2f	jsr $3a2ff7	            JSR PLOT
.3a30a3	a5 61		lda $0861	                LDA X1
.3a30a5	85 59		sta $0859	                STA X0
.3a30a7	a5 65		lda $0865	                LDA Y1
.3a30a9	85 5d		sta $085d	                STA Y0
.3a30ab	20 f7 2f	jsr $3a2ff7	            JSR PLOT
.3a30ae	80 5b		bra $3a310b	                BRA done
.3a30b0	a5 6d		lda $086d	cmp_dy_dx       LDA DY
.3a30b2	c5 69		cmp $0869	cmp_dx          CMP DX                      ; (DY < DX)
.3a30b4	b0 04		bcs $3a30ba	                BGE else
.3a30b6	a5 69		lda $0869	                LDA DX                      ; TRUE CASE: ERR := DX
.3a30b8	80 06		bra $3a30c0	                BRA shiftERR
.3a30ba	a5 6d		lda $086d	else            LDA DY                      ; FALSE CASE: ERR := -DY
.3a30bc	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a30bf	1a		inc a		                INC A
.3a30c0	48		pha		shiftERR        PHA
.3a30c1	0a		asl a		                ASL A
.3a30c2	68		pla		                PLA
.3a30c3	6a		ror a		                ROR A                       ; ERR := ERR / 2
.3a30c4	85 71		sta $0871	                STA ERR
.3a30c6					loop
.3a30c6	20 f7 2f	jsr $3a2ff7	            JSR PLOT
.3a30c9	a5 59		lda $0859	                LDA X0                      ; break if X0=X1 and Y0=Y1
.3a30cb	c5 61		cmp $0861	                CMP X1
.3a30cd	d0 06		bne $3a30d5	                BNE calc_ERR2
.3a30cf	a5 5d		lda $085d	                LDA Y0
.3a30d1	c5 65		cmp $0865	                CMP Y1
.3a30d3	f0 36		beq $3a310b	                BEQ done
.3a30d5	a5 71		lda $0871	calc_ERR2       LDA ERR                     ; ERR2 := ERR
.3a30d7	85 75		sta $0875	                STA ERR2
.3a30d9	a5 69		lda $0869	                LDA DX                      ; if (ERR2 > -DX) {
.3a30db	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a30de	1a		inc a		                INC A
.3a30df	c5 75		cmp $0875	                CMP ERR2
.3a30e1	10 10		bpl $3a30f3	                BPL check_DY
.3a30e3	f0 0e		beq $3a30f3	                BEQ check_DY
.3a30e5	38		sec		                SEC                         ; ERR -= DY
.3a30e6	a5 71		lda $0871	                LDA ERR
.3a30e8	e5 6d		sbc $086d	                SBC DY
.3a30ea	85 71		sta $0871	                STA ERR
.3a30ec	18		clc		                CLC                         ; X0 += SX
.3a30ed	a5 59		lda $0859	                LDA X0
.3a30ef	65 dd		adc $08dd	                ADC SX
.3a30f1	85 59		sta $0859	                STA X0                      ; }
.3a30f3	a5 75		lda $0875	check_DY        LDA ERR2                    ; if (ERR2 < DY) {
.3a30f5	c5 6d		cmp $086d	                CMP DY
.3a30f7	10 cd		bpl $3a30c6	                BPL loop
.3a30f9	f0 cb		beq $3a30c6	                BEQ loop
.3a30fb	18		clc		                CLC                         ; ERR += DX
.3a30fc	a5 71		lda $0871	                LDA ERR
.3a30fe	65 69		adc $0869	                ADC DX
.3a3100	85 71		sta $0871	                STA ERR
.3a3102	18		clc		                CLC                         ; Y0 += SY
.3a3103	a5 5d		lda $085d	                LDA Y0
.3a3105	65 df		adc $08df	                ADC SY
.3a3107	85 5d		sta $085d	                STA Y0                      ; }
.3a3109	80 bb		bra $3a30c6	                BRA loop                    ; }
.3a310b					done
.3a310b	60		rts		            RTS
.3a310c					S_PLOT
.3a310c	08		php		                PHP
.3a310d					locals
>0001					L_PLANE         .word ?
>0003					L_X             .word ?
>0005					L_Y             .word ?
.3a310d	c2 20		rep #$20	            REP #$20
.3a310f	3b		tsc		            TSC
.3a3110	38		sec		            SEC
.3a3111	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.3a3114	1b		tcs		            TCS
.3a3115	08		php		            PHP
.3a3116	c2 20		rep #$20	            REP #$20
.3a3118	48		pha		            PHA
.3a3119	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a311c	5b		tcd		            TCD
.3a311d	68		pla		            PLA
.3a311e	28		plp		            PLP
.3a311f	08		php		            PHP
.3a3120	e2 20		sep #$20	            SEP #$20
.3a3122	48		pha		            PHA
.3a3123	a9 00		lda #$00	            LDA #0
.3a3125	48		pha		            PHA
.3a3126	ab		plb		            PLB
.3a3127	68		pla		            PLA
.3a3128	28		plp		            PLP
.3a3129	c2 30		rep #$30	            REP #$30
.3a312b	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a312e	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a3131	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.3a3133	a9 2c 00	lda #$002c	                LDA #','
.3a3136	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3139	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a313c	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a313f	a5 23		lda $0823	                LDA ARGUMENT1
.3a3141	83 03		sta $03,s	                STA L_X                     ; Save it to X
.3a3143	a9 2c 00	lda #$002c	                LDA #','
.3a3146	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3149	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a314c	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a314f	a5 23		lda $0823	                LDA ARGUMENT1
.3a3151	83 05		sta $05,s	                STA L_Y                     ; Save it to Y
.3a3153	a9 2c 00	lda #$002c	                LDA #','
.3a3156	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3159	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a315c	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a315f	a5 23		lda $0823	                LDA ARGUMENT1
.3a3161	85 55		sta $0855	                STA COLOR                   ; Save it to MARG1
.3a3163	a3 03		lda $03,s	                LDA L_X                     ; Set the (X0, Y0) coordinates
.3a3165	85 59		sta $0859	                STA X0
.3a3167	a3 05		lda $05,s	                LDA L_Y
.3a3169	85 5d		sta $085d	                STA Y0
.3a316b	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.3a316d	20 24 2e	jsr $3a2e24	            JSR BITMAP_SRAM
.3a3170	20 f7 2f	jsr $3a2ff7	            JSR PLOT
.3a3173	c2 20		rep #$20	            REP #$20
.3a3175	3b		tsc		            TSC
.3a3176	18		clc		            CLC
.3a3177	69 06 00	adc #$0006	            ADC #SIZE(locals)
.3a317a	1b		tcs		            TCS
.3a317b	28		plp		                PLP
.3a317c	60		rts		            RTS
.3a317d					S_LINE
.3a317d	08		php		                PHP
.3a317e					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
.3a317e	c2 20		rep #$20	            REP #$20
.3a3180	3b		tsc		            TSC
.3a3181	38		sec		            SEC
.3a3182	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.3a3185	1b		tcs		            TCS
.3a3186	08		php		            PHP
.3a3187	c2 20		rep #$20	            REP #$20
.3a3189	48		pha		            PHA
.3a318a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a318d	5b		tcd		            TCD
.3a318e	68		pla		            PLA
.3a318f	28		plp		            PLP
.3a3190	08		php		            PHP
.3a3191	e2 20		sep #$20	            SEP #$20
.3a3193	48		pha		            PHA
.3a3194	a9 00		lda #$00	            LDA #0
.3a3196	48		pha		            PHA
.3a3197	ab		plb		            PLB
.3a3198	68		pla		            PLA
.3a3199	28		plp		            PLP
.3a319a	c2 30		rep #$30	            REP #$30
.3a319c	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a319f	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a31a2	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.3a31a4	a9 2c 00	lda #$002c	                LDA #','
.3a31a7	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a31aa	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a31ad	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a31b0	a5 23		lda $0823	                LDA ARGUMENT1
.3a31b2	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.3a31b4	a9 2c 00	lda #$002c	                LDA #','
.3a31b7	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a31ba	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a31bd	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a31c0	a5 23		lda $0823	                LDA ARGUMENT1
.3a31c2	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.3a31c4	a9 2c 00	lda #$002c	                LDA #','
.3a31c7	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a31ca	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a31cd	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a31d0	a5 23		lda $0823	                LDA ARGUMENT1
.3a31d2	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.3a31d4	a9 2c 00	lda #$002c	                LDA #','
.3a31d7	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a31da	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a31dd	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a31e0	a5 23		lda $0823	                LDA ARGUMENT1
.3a31e2	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.3a31e4	a9 2c 00	lda #$002c	                LDA #','
.3a31e7	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a31ea	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a31ed	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a31f0	a5 23		lda $0823	                LDA ARGUMENT1
.3a31f2	85 55		sta $0855	                STA COLOR                   ; Save it to COLOR
.3a31f4	a3 03		lda $03,s	                LDA L_X0                    ; Set the (X0, Y0) coordinates
.3a31f6	85 59		sta $0859	                STA X0
.3a31f8	a3 05		lda $05,s	                LDA L_Y0
.3a31fa	85 5d		sta $085d	                STA Y0
.3a31fc	a3 07		lda $07,s	                LDA L_X1                    ; Set the (X1, Y1) coordinates
.3a31fe	85 61		sta $0861	                STA X1
.3a3200	a3 09		lda $09,s	                LDA L_Y1
.3a3202	85 65		sta $0865	                STA Y1
.3a3204	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.3a3206	20 24 2e	jsr $3a2e24	            JSR BITMAP_SRAM
.3a3209	20 5e 30	jsr $3a305e	            JSR LINE
.3a320c					done
.3a320c	c2 20		rep #$20	            REP #$20
.3a320e	3b		tsc		            TSC
.3a320f	18		clc		            CLC
.3a3210	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.3a3213	1b		tcs		            TCS
.3a3214	28		plp		                PLP
.3a3215	60		rts		            RTS
.3a3216					S_FILL
.3a3216	08		php		                PHP
.3a3217					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
>000b					L_COLOR         .word ?
.3a3217	c2 20		rep #$20	            REP #$20
.3a3219	3b		tsc		            TSC
.3a321a	38		sec		            SEC
.3a321b	e9 0c 00	sbc #$000c	            SBC #SIZE(locals)
.3a321e	1b		tcs		            TCS
.3a321f	08		php		            PHP
.3a3220	c2 20		rep #$20	            REP #$20
.3a3222	48		pha		            PHA
.3a3223	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3226	5b		tcd		            TCD
.3a3227	68		pla		            PLA
.3a3228	28		plp		            PLP
.3a3229	08		php		            PHP
.3a322a	e2 20		sep #$20	            SEP #$20
.3a322c	48		pha		            PHA
.3a322d	a9 00		lda #$00	            LDA #0
.3a322f	48		pha		            PHA
.3a3230	ab		plb		            PLB
.3a3231	68		pla		            PLA
.3a3232	28		plp		            PLP
.3a3233	c2 30		rep #$30	            REP #$30
.3a3235	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3238	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a323b	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.3a323d	a9 2c 00	lda #$002c	                LDA #','
.3a3240	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3243	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3246	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3249	a5 23		lda $0823	                LDA ARGUMENT1
.3a324b	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.3a324d	a9 2c 00	lda #$002c	                LDA #','
.3a3250	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3253	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3256	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3259	a5 23		lda $0823	                LDA ARGUMENT1
.3a325b	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.3a325d	a9 2c 00	lda #$002c	                LDA #','
.3a3260	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3263	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3266	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3269	a5 23		lda $0823	                LDA ARGUMENT1
.3a326b	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.3a326d	a9 2c 00	lda #$002c	                LDA #','
.3a3270	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3273	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3276	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3279	a5 23		lda $0823	                LDA ARGUMENT1
.3a327b	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.3a327d	a9 2c 00	lda #$002c	                LDA #','
.3a3280	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3283	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3286	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a3289	a5 23		lda $0823	                LDA ARGUMENT1
.3a328b	83 0b		sta $0b,s	                STA L_COLOR                 ; Save it to COLOR
.3a328d	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.3a328f	20 68 2e	jsr $3a2e68	            JSR BITMAP_VRAM
.3a3292	a9 07 00	lda #$0007	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_1D_2D
.3a3295	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a3299	c2 20		rep #$20	            REP #$20
.3a329b	a3 05		lda $05,s	                LDA L_Y0                    ; Get the row
.3a329d	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.3a32a1	af 10 f0 3a	lda $3af010	                LDA @l GR_MAX_COLS
.3a32a5	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B         ; Multiply by the number of columns in the pixmap
.3a32a9	18		clc		                CLC                         ; Add the column
.3a32aa	af 04 01 00	lda $000104	                LDA @l M0_RESULT
.3a32ae	63 03		adc $03,s	                ADC L_X0
.3a32b0	85 0c		sta $080c	                STA SCRATCH
.3a32b2	e2 20		sep #$20	            SEP #$20
.3a32b4	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.3a32b8	69 00		adc #$00	                ADC #0
.3a32ba	85 0e		sta $080e	                STA SCRATCH+2
.3a32bc	c2 20		rep #$20	            REP #$20
.3a32be	18		clc		                CLC                         ; Set the destination address
.3a32bf	a5 9e		lda $089e	                LDA MTEMPPTR
.3a32c1	65 0c		adc $080c	                ADC SCRATCH
.3a32c3	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.3a32c7	e2 20		sep #$20	            SEP #$20
.3a32c9	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.3a32cb	65 0e		adc $080e	                ADC SCRATCH+2
.3a32cd	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H
.3a32d1	c2 20		rep #$20	            REP #$20
.3a32d3	38		sec		                SEC                         ; Set the width of the FILL operation
.3a32d4	a3 07		lda $07,s	                LDA L_X1
.3a32d6	e3 03		sbc $03,s	                SBC L_X0
.3a32d8	85 0c		sta $080c	                STA SCRATCH
.3a32da	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.3a32de	38		sec		                SEC
.3a32df	af 10 f0 3a	lda $3af010	                LDA @l GR_MAX_COLS
.3a32e3	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L    ; And the destination stride
.3a32e7	38		sec		                SEC                         ; Set the height of the FILL operation
.3a32e8	a3 09		lda $09,s	                LDA L_Y1
.3a32ea	e3 05		sbc $05,s	                SBC L_Y0
.3a32ec	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.3a32f0	e2 20		sep #$20	            SEP #$20
.3a32f2	a3 0b		lda $0b,s	                LDA L_COLOR                 ; Set the color to write
.3a32f4	8f 01 04 af	sta $af0401	                STA @l VDMA_BYTE_2_WRITE
.3a32f8	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.3a32fc	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF
.3a32fe	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a3302	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.3a3306	30 fa		bmi $3a3302	                BMI wait
.3a3308	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.3a330a	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a330e					done
.3a330e	c2 20		rep #$20	            REP #$20
.3a3310	3b		tsc		            TSC
.3a3311	18		clc		            CLC
.3a3312	69 0c 00	adc #$000c	            ADC #SIZE(locals)
.3a3315	1b		tcs		            TCS
.3a3316	28		plp		                PLP
.3a3317	60		rts		            RTS
.3a3318					SPADDR
.3a3318	08		php		                PHP
.3a3319	c2 20		rep #$20	            REP #$20
.3a331b	c9 40 00	cmp #$0040	                CMP #SP_MAX
.3a331e	b0 13		bcs $3a3333	                BGE error
.3a3320	0a		asl a		                ASL A                       ; Multiply it by 8 (the size of s sprite block)
.3a3321	0a		asl a		                ASL A
.3a3322	0a		asl a		                ASL A
.3a3323	18		clc		                CLC                         ; Add it to the address of the first
.3a3324	69 00 0c	adc #$0c00	                ADC #<>SP00_CONTROL_REG     ; sprite block
.3a3327	85 9e		sta $089e	                STA MTEMPPTR
.3a3329	a9 af 00	lda #$00af	                LDA #`SP00_CONTROL_REG
.3a332c	69 00 00	adc #$0000	                ADC #0
.3a332f	85 a0		sta $08a0	                STA MTEMPPTR+2              ; And save that to MTEMPPTR
.3a3331	28		plp		                PLP
.3a3332	60		rts		            RTS
.3a3333					error
.3a3333	08		php		            PHP
.3a3334	c2 20		rep #$20	            REP #$20
.3a3336	48		pha		            PHA
.3a3337	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a333a	5b		tcd		            TCD
.3a333b	68		pla		            PLA
.3a333c	28		plp		            PLP
.3a333d	e2 20		sep #$20	            SEP #$20
.3a333f	a9 09		lda #$09	            LDA #ERR_RANGE
.3a3341	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3345	c2 20		rep #$20	            REP #$20
.3a3347	29 ff 00	and #$00ff	            AND #$00FF
.3a334a	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a334d	e2 20		sep #$20	            SEP #$20
.3a334f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3352					S_SPRITE
.3a3352	08		php		                PHP
.3a3353					locals
>0001					L_SPRITE        .word ?
>0003					L_LUT           .byte ?
.3a3353	c2 20		rep #$20	            REP #$20
.3a3355	3b		tsc		            TSC
.3a3356	38		sec		            SEC
.3a3357	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.3a335a	1b		tcs		            TCS
.3a335b	c2 30		rep #$30	            REP #$30
.3a335d	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3360	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a3363	a5 23		lda $0823	                LDA ARGUMENT1
.3a3365	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.3a3367	a9 2c 00	lda #$002c	                LDA #','
.3a336a	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a336d	e2 20		sep #$20	            SEP #$20
.3a336f	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3372	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a3375	a5 23		lda $0823	                LDA ARGUMENT1
.3a3377	c9 08		cmp #$08	                CMP #GR_MAX_LUT             ; Check that it's in range
.3a3379	b0 56		bcs $3a33d1	                BGE error                   ; If not: throw an error
.3a337b	83 03		sta $03,s	                STA L_LUT                   ; Save it as lut
.3a337d	a9 2c		lda #$2c	                LDA #','
.3a337f	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3382	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3385	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3388	c2 20		rep #$20	            REP #$20
.3a338a	38		sec		                SEC                         ; Adjust address to be in Vicky's space
.3a338b	a5 23		lda $0823	                LDA ARGUMENT1
.3a338d	e9 00 00	sbc #$0000	                SBC #<>VRAM
.3a3390	85 23		sta $0823	                STA ARGUMENT1
.3a3392	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a3394	e9 b0 00	sbc #$00b0	                SBC #`VRAM
.3a3397	85 25		sta $0825	                STA ARGUMENT1+2
.3a3399	30 36		bmi $3a33d1	                BMI error                   ; If negative, throw an error
.3a339b	c2 20		rep #$20	            REP #$20
.3a339d	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.3a339f	aa		tax		                TAX
.3a33a0	20 18 33	jsr $3a3318	            JSR SPADDR
.3a33a3	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the lower word of the address
.3a33a5	a0 01 00	ldy #$0001	                LDY #SP_ADDR
.3a33a8	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a33aa	e2 20		sep #$20	            SEP #$20
.3a33ac	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a33ae	c8		iny		                INY
.3a33af	c8		iny		                INY
.3a33b0	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save the upper byte of the address
.3a33b2	bf 18 f0 3a	lda $3af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the sprite control register
.3a33b6	29 f1		and #$f1	                AND #%11110001              ; Filter off the current LUT
.3a33b8	85 0c		sta $080c	                STA SCRATCH
.3a33ba	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT back
.3a33bc	0a		asl a		                ASL A                       ; Sift it into the LUT position
.3a33bd	29 0e		and #$0e	                AND #%00001110              ; Make sure we don't have anything wrong there
.3a33bf	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with what's in the sprite's control
.3a33c1	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the register's bits
.3a33c3	9f 18 f0 3a	sta $3af018,x	                STA @l GS_SP_CONTROL,X      ; And the shadow register
.3a33c7					done
.3a33c7	c2 20		rep #$20	            REP #$20
.3a33c9	3b		tsc		            TSC
.3a33ca	18		clc		            CLC
.3a33cb	69 03 00	adc #$0003	            ADC #SIZE(locals)
.3a33ce	1b		tcs		            TCS
.3a33cf	28		plp		                PLP
.3a33d0	60		rts		            RTS
.3a33d1					error
.3a33d1	08		php		            PHP
.3a33d2	c2 20		rep #$20	            REP #$20
.3a33d4	48		pha		            PHA
.3a33d5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a33d8	5b		tcd		            TCD
.3a33d9	68		pla		            PLA
.3a33da	28		plp		            PLP
.3a33db	e2 20		sep #$20	            SEP #$20
.3a33dd	a9 09		lda #$09	            LDA #ERR_RANGE
.3a33df	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a33e3	c2 20		rep #$20	            REP #$20
.3a33e5	29 ff 00	and #$00ff	            AND #$00FF
.3a33e8	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a33eb	e2 20		sep #$20	            SEP #$20
.3a33ed	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a33f0					S_SPRITEAT
.3a33f0	08		php		                PHP
.3a33f1					locals
>0001					L_SPRITE        .word ?
>0003					L_X             .word ?
.3a33f1	c2 20		rep #$20	            REP #$20
.3a33f3	3b		tsc		            TSC
.3a33f4	38		sec		            SEC
.3a33f5	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.3a33f8	1b		tcs		            TCS
.3a33f9	c2 30		rep #$30	            REP #$30
.3a33fb	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a33fe	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a3401	a5 23		lda $0823	                LDA ARGUMENT1
.3a3403	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.3a3405	a9 2c 00	lda #$002c	                LDA #','
.3a3408	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a340b	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a340e	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3411	a5 23		lda $0823	                LDA ARGUMENT1
.3a3413	83 03		sta $03,s	                STA L_X                     ; Save it as X
.3a3415	a9 2c 00	lda #$002c	                LDA #','
.3a3418	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a341b	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a341e	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3421	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.3a3423	20 18 33	jsr $3a3318	            JSR SPADDR
.3a3426	a3 03		lda $03,s	                LDA L_X                     ; Get the X coordinate
.3a3428	a0 04 00	ldy #$0004	                LDY #SP_X_COORD             ; Save the X coordinate for the sprite
.3a342b	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a342d	a5 23		lda $0823	                LDA ARGUMENT1
.3a342f	a0 06 00	ldy #$0006	                LDY #SP_Y_COORD             ; Save the Y coordinate for the sprite
.3a3432	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a3434					done
.3a3434	c2 20		rep #$20	            REP #$20
.3a3436	3b		tsc		            TSC
.3a3437	18		clc		            CLC
.3a3438	69 04 00	adc #$0004	            ADC #SIZE(locals)
.3a343b	1b		tcs		            TCS
.3a343c	28		plp		                PLP
.3a343d	60		rts		            RTS
.3a343e					S_SPRITESHOW
.3a343e	08		php		                PHP
.3a343f					locals
>0001					L_SPRITE        .word ?
>0003					L_VISIBLE       .byte ?
.3a343f	c2 20		rep #$20	            REP #$20
.3a3441	3b		tsc		            TSC
.3a3442	38		sec		            SEC
.3a3443	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.3a3446	1b		tcs		            TCS
.3a3447	c2 30		rep #$30	            REP #$30
.3a3449	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a344c	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a344f	a5 23		lda $0823	                LDA ARGUMENT1
.3a3451	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.3a3453	a9 2c 00	lda #$002c	                LDA #','
.3a3456	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3459	e2 20		sep #$20	            SEP #$20
.3a345b	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a345e	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3461	a5 23		lda $0823	                LDA ARGUMENT1
.3a3463	d0 04		bne $3a3469	                BNE is_visible
.3a3465	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 0 (not visible)
.3a3467	80 04		bra $3a346d	                BRA chk_layer
.3a3469	a9 01		lda #$01	is_visible      LDA #1
.3a346b	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 1 (visible)
.3a346d	a9 2c		lda #$2c	chk_layer       LDA #','
.3a346f	85 37		sta $0837	                STA TARGETTOK
.3a3471	20 1c 22	jsr $3a221c	            JSR OPT_TOK
.3a3474	b0 20		bcs $3a3496	                BCS get_layer               ; Yes: get the layer
.3a3476					no_layer
.3a3476	c2 30		rep #$30	            REP #$30
.3a3478	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.3a347a	aa		tax		                TAX
.3a347b	20 18 33	jsr $3a3318	            JSR SPADDR
.3a347e	e2 20		sep #$20	            SEP #$20
.3a3480	bf 18 f0 3a	lda $3af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.3a3484	29 fe		and #$fe	                AND #$FE                    ; Filter out the enable bit
.3a3486	85 0c		sta $080c	                STA SCRATCH
.3a3488	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.3a348a	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.3a348c	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.3a348e	9f 18 f0 3a	sta $3af018,x	                STA @l GS_SP_CONTROL,X      ; And save it
.3a3492	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; ... and to Vicky
.3a3494	80 36		bra $3a34cc	                BRA done
.3a3496					get_layer
.3a3496	c2 30		rep #$30	            REP #$30
.3a3498	20 da 20	jsr $3a20da	            JSR INCBIP
.3a349b	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a349e	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a34a1	a5 23		lda $0823	                LDA ARGUMENT1
.3a34a3	c9 08 00	cmp #$0008	                CMP #8                      ; Make sure it's in range
.3a34a6	b0 2e		bcs $3a34d6	                BGE error                   ; If not, throw an out of range error
.3a34a8	0a		asl a		                ASL A                       ; If it's ok... shift it into position
.3a34a9	0a		asl a		                ASL A
.3a34aa	0a		asl a		                ASL A
.3a34ab	0a		asl a		                ASL A
.3a34ac	85 0c		sta $080c	                STA SCRATCH                 ; And save it in SCRATCH
.3a34ae	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.3a34b0	aa		tax		                TAX
.3a34b1	20 18 33	jsr $3a3318	            JSR SPADDR
.3a34b4	e2 20		sep #$20	            SEP #$20
.3a34b6	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.3a34b8	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.3a34ba	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.3a34bc	85 0c		sta $080c	                STA SCRATCH
.3a34be	bf 18 f0 3a	lda $3af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.3a34c2	29 8e		and #$8e	                AND #%10001110              ; Filter out the enable and layer bits
.3a34c4	05 0c		ora $080c	                ORA SCRATCH                 ; Combine with the provided layer and enable
.3a34c6	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the bits in Vicky
.3a34c8	9f 18 f0 3a	sta $3af018,x	                STA @l GS_SP_CONTROL,X      ; And to the shadow registers
.3a34cc					done
.3a34cc	c2 20		rep #$20	            REP #$20
.3a34ce	3b		tsc		            TSC
.3a34cf	18		clc		            CLC
.3a34d0	69 03 00	adc #$0003	            ADC #SIZE(locals)
.3a34d3	1b		tcs		            TCS
.3a34d4	28		plp		                PLP
.3a34d5	60		rts		            RTS
.3a34d6					error
.3a34d6	08		php		            PHP
.3a34d7	c2 20		rep #$20	            REP #$20
.3a34d9	48		pha		            PHA
.3a34da	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a34dd	5b		tcd		            TCD
.3a34de	68		pla		            PLA
.3a34df	28		plp		            PLP
.3a34e0	e2 20		sep #$20	            SEP #$20
.3a34e2	a9 09		lda #$09	            LDA #ERR_RANGE
.3a34e4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a34e8	c2 20		rep #$20	            REP #$20
.3a34ea	29 ff 00	and #$00ff	            AND #$00FF
.3a34ed	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a34f0	e2 20		sep #$20	            SEP #$20
.3a34f2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a34f5					TILESET_ADDR
.3a34f5	08		php		                PHP
.3a34f6	c2 20		rep #$20	            REP #$20
.3a34f8	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.3a34fb	b0 19		bcs $3a3516	                BGE out_of_range            ; If not, throw a range error
.3a34fd	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.3a3500	a9 04 00	lda #$0004	                LDA #TILESET_REG_SIZE       ; Multiply it by the number of bytes in a tile set register set
.3a3503	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.3a3506	18		clc		                CLC                         ; Add to TILESET0_ADDY_L to get the final address
.3a3507	ad 04 01	lda $0104	                LDA @w M0_RESULT
.3a350a	69 80 02	adc #$0280	                ADC #<>TILESET0_ADDY_L
.3a350d	85 9e		sta $089e	                STA MTEMPPTR
.3a350f	a9 af 00	lda #$00af	                LDA #`TILESET0_ADDY_L
.3a3512	85 a0		sta $08a0	                STA MTEMPPTR+2
.3a3514	28		plp		                PLP
.3a3515	60		rts		            RTS
.3a3516					out_of_range
.3a3516	08		php		            PHP
.3a3517	c2 20		rep #$20	            REP #$20
.3a3519	48		pha		            PHA
.3a351a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a351d	5b		tcd		            TCD
.3a351e	68		pla		            PLA
.3a351f	28		plp		            PLP
.3a3520	e2 20		sep #$20	            SEP #$20
.3a3522	a9 09		lda #$09	            LDA #ERR_RANGE
.3a3524	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3528	c2 20		rep #$20	            REP #$20
.3a352a	29 ff 00	and #$00ff	            AND #$00FF
.3a352d	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a3530	e2 20		sep #$20	            SEP #$20
.3a3532	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3535					TILEMAP_ADDR
.3a3535	08		php		                PHP
.3a3536	c2 20		rep #$20	            REP #$20
.3a3538	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.3a353b	b0 19		bcs $3a3556	                BGE out_of_range            ; If not, throw a range error
.3a353d	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.3a3540	a9 0c 00	lda #$000c	                LDA #TILEMAP_REG_SIZE       ; Multiply it by the number of bytes in a tile map register set
.3a3543	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.3a3546	18		clc		                CLC
.3a3547	ad 04 01	lda $0104	                LDA @w M0_RESULT            ; Add to TL0_CONTROL_REG to get the final address
.3a354a	69 00 02	adc #$0200	                ADC #<>TL0_CONTROL_REG
.3a354d	85 9e		sta $089e	                STA MTEMPPTR
.3a354f	a9 af 00	lda #$00af	                LDA #`TL0_CONTROL_REG
.3a3552	85 a0		sta $08a0	                STA MTEMPPTR+2
.3a3554	28		plp		                PLP
.3a3555	60		rts		            RTS
.3a3556					out_of_range
.3a3556	08		php		            PHP
.3a3557	c2 20		rep #$20	            REP #$20
.3a3559	48		pha		            PHA
.3a355a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a355d	5b		tcd		            TCD
.3a355e	68		pla		            PLA
.3a355f	28		plp		            PLP
.3a3560	e2 20		sep #$20	            SEP #$20
.3a3562	a9 09		lda #$09	            LDA #ERR_RANGE
.3a3564	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3568	c2 20		rep #$20	            REP #$20
.3a356a	29 ff 00	and #$00ff	            AND #$00FF
.3a356d	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a3570	e2 20		sep #$20	            SEP #$20
.3a3572	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3575					S_TILESET
.3a3575	08		php		                PHP
.3a3576					locals
>0001					L_TILENUM       .word ?
>0003					L_LUT           .word ?
>0005					L_IS_SQUARE     .word ?
.3a3576	c2 20		rep #$20	            REP #$20
.3a3578	3b		tsc		            TSC
.3a3579	38		sec		            SEC
.3a357a	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.3a357d	1b		tcs		            TCS
.3a357e	c2 20		rep #$20	            REP #$20
.3a3580	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3583	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a3586	a5 23		lda $0823	                LDA ARGUMENT1
.3a3588	83 01		sta $01,s	                STA L_TILENUM               ; Save it as the tile set/map number
.3a358a	a9 2c 00	lda #$002c	                LDA #','
.3a358d	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3590	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3593	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a3596	a5 23		lda $0823	                LDA ARGUMENT1
.3a3598	83 03		sta $03,s	                STA L_LUT                   ; Save it as LUT
.3a359a	a9 2c 00	lda #$002c	                LDA #','
.3a359d	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a35a0	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a35a3	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a35a6	a5 23		lda $0823	                LDA ARGUMENT1
.3a35a8	83 05		sta $05,s	                STA L_IS_SQUARE             ; Save it as IS_SQUARE
.3a35aa	a9 2c 00	lda #$002c	                LDA #','
.3a35ad	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a35b0	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a35b3	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a35b6	a3 01		lda $01,s	                LDA L_TILENUM
.3a35b8	20 f5 34	jsr $3a34f5	            JSR TILESET_ADDR
.3a35bb	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the bitmap address - the address of the start of VRAM
.3a35bd	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And save it to the registers
.3a35bf	e2 20		sep #$20	            SEP #$20
.3a35c1	38		sec		                SEC
.3a35c2	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a35c4	e9 b0		sbc #$b0	                SBC #`VRAM
.3a35c6	a0 02 00	ldy #$0002	                LDY #TILESET_ADDY_H
.3a35c9	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a35cb	a3 05		lda $05,s	                LDA L_IS_SQUARE             ; Check if is_square == 0?
.3a35cd	d0 0d		bne $3a35dc	                BNE is_square
.3a35cf					not_square
.3a35cf	e2 20		sep #$20	            SEP #$20
.3a35d1	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.3a35d3	29 07		and #$07	                AND #$07                    ; Force it to be in range
.3a35d5	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.3a35d8	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.3a35da	80 0d		bra $3a35e9	                BRA done
.3a35dc					is_square
.3a35dc	e2 20		sep #$20	            SEP #$20
.3a35de	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.3a35e0	29 07		and #$07	                AND #$07                    ; Force it to be in range
.3a35e2	09 08		ora #$08	                ORA #TILESET_SQUARE_256     ; Turn on the 256x256 flag
.3a35e4	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.3a35e7	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.3a35e9					done
.3a35e9	c2 20		rep #$20	            REP #$20
.3a35eb	3b		tsc		            TSC
.3a35ec	18		clc		            CLC
.3a35ed	69 06 00	adc #$0006	            ADC #SIZE(locals)
.3a35f0	1b		tcs		            TCS
.3a35f1	28		plp		                PLP
.3a35f2	60		rts		            RTS
.3a35f3					S_TILEMAP
.3a35f3	08		php		                PHP
.3a35f4					locals
>0001					L_TILENUM       .word ?
>0003					L_WIDTH         .word ?
>0005					L_HEIGHT        .word ?
.3a35f4	c2 20		rep #$20	            REP #$20
.3a35f6	3b		tsc		            TSC
.3a35f7	38		sec		            SEC
.3a35f8	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.3a35fb	1b		tcs		            TCS
.3a35fc	c2 20		rep #$20	            REP #$20
.3a35fe	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3601	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a3604	a5 23		lda $0823	                LDA ARGUMENT1
.3a3606	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.3a3608	a9 2c 00	lda #$002c	                LDA #','
.3a360b	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a360e	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3611	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3614	a5 23		lda $0823	                LDA ARGUMENT1
.3a3616	83 03		sta $03,s	                STA L_WIDTH                 ; Save it as WIDTH
.3a3618	a9 2c 00	lda #$002c	                LDA #','
.3a361b	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a361e	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3621	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3624	a5 23		lda $0823	                LDA ARGUMENT1
.3a3626	83 05		sta $05,s	                STA L_HEIGHT                ; Save it as HEIGHT
.3a3628	a9 2c 00	lda #$002c	                LDA #','
.3a362b	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a362e	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3631	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3634	a3 01		lda $01,s	                LDA L_TILENUM
.3a3636	20 35 35	jsr $3a3535	            JSR TILEMAP_ADDR
.3a3639	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the map address - the address of the start of VRAM
.3a363b	a0 01 00	ldy #$0001	                LDY #TILEMAP_START_ADDY
.3a363e	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; And save it to the registers
.3a3640	e2 20		sep #$20	            SEP #$20
.3a3642	38		sec		                SEC
.3a3643	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a3645	e9 b0		sbc #$b0	                SBC #`VRAM
.3a3647	c8		iny		                INY
.3a3648	c8		iny		                INY
.3a3649	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a364b	c2 20		rep #$20	            REP #$20
.3a364d	a3 03		lda $03,s	                LDA L_WIDTH                 ; Set the width
.3a364f	a0 04 00	ldy #$0004	                LDY #TILEMAP_TOTAL_X
.3a3652	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a3654	a3 05		lda $05,s	                LDA L_HEIGHT                ; Set the height
.3a3656	a0 06 00	ldy #$0006	                LDY #TILEMAP_TOTAL_Y
.3a3659	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a365b					done
.3a365b	c2 20		rep #$20	            REP #$20
.3a365d	3b		tsc		            TSC
.3a365e	18		clc		            CLC
.3a365f	69 06 00	adc #$0006	            ADC #SIZE(locals)
.3a3662	1b		tcs		            TCS
.3a3663	28		plp		                PLP
.3a3664	60		rts		            RTS
.3a3665					S_TILESHOW
.3a3665	08		php		                PHP
.3a3666					locals
>0001					L_TILENUM       .word ?
.3a3666	c2 20		rep #$20	            REP #$20
.3a3668	f4 00 00	pea #$0000	            PEA #0
.3a366b	c2 20		rep #$20	            REP #$20
.3a366d	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3670	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a3673	a5 23		lda $0823	                LDA ARGUMENT1
.3a3675	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.3a3677	a9 2c 00	lda #$002c	                LDA #','
.3a367a	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a367d	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3680	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3683	a3 01		lda $01,s	                LDA L_TILENUM
.3a3685	20 35 35	jsr $3a3535	            JSR TILEMAP_ADDR
.3a3688	a5 23		lda $0823	                LDA ARGUMENT1               ; CHeck the visible parameter
.3a368a	d0 06		bne $3a3692	                BNE is_visible              ; If it's <> 0, make it visible
.3a368c	e2 20		sep #$20	            SEP #$20
.3a368e	a9 00		lda #$00	                LDA #0                      ; Control value for invisible
.3a3690	80 04		bra $3a3696	                BRA set_control
.3a3692					is_visible
.3a3692	e2 20		sep #$20	            SEP #$20
.3a3694	a9 01		lda #$01	                LDA #TILEMAP_VISIBLE        ; Control value for visible
.3a3696					set_control
.3a3696	e2 20		sep #$20	            SEP #$20
.3a3698	a0 00 00	ldy #$0000	                LDY #TILEMAP_CONTROL        ; Set the control register
.3a369b	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a369d					done
.3a369d	c2 20		rep #$20	            REP #$20
.3a369f	68		pla		            PLA
.3a36a0	28		plp		                PLP
.3a36a1	60		rts		            RTS
.3a36a2					S_TILEAT
.3a36a2	08		php		                PHP
.3a36a3					locals
>0001					L_TILENUM       .word ?
>0003					L_X             .word ?
.3a36a3	c2 20		rep #$20	            REP #$20
.3a36a5	3b		tsc		            TSC
.3a36a6	38		sec		            SEC
.3a36a7	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.3a36aa	1b		tcs		            TCS
.3a36ab	c2 20		rep #$20	            REP #$20
.3a36ad	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a36b0	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a36b3	a5 23		lda $0823	                LDA ARGUMENT1
.3a36b5	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.3a36b7	a9 2c 00	lda #$002c	                LDA #','
.3a36ba	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a36bd	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a36c0	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a36c3	a5 23		lda $0823	                LDA ARGUMENT1
.3a36c5	83 03		sta $03,s	                STA L_X                     ; Save as X
.3a36c7	a9 2c 00	lda #$002c	                LDA #','
.3a36ca	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a36cd	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a36d0	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a36d3	a3 01		lda $01,s	                LDA L_TILENUM
.3a36d5	20 35 35	jsr $3a3535	            JSR TILEMAP_ADDR
.3a36d8	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the Y position
.3a36da	a0 0a 00	ldy #$000a	                LDY #TILEMAP_WINDOW_Y
.3a36dd	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a36df	a3 03		lda $03,s	                LDA L_X                     ; Set the X position
.3a36e1	a0 08 00	ldy #$0008	                LDY #TILEMAP_WINDOW_X
.3a36e4	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a36e6					done
.3a36e6	c2 20		rep #$20	            REP #$20
.3a36e8	3b		tsc		            TSC
.3a36e9	18		clc		            CLC
.3a36ea	69 04 00	adc #$0004	            ADC #SIZE(locals)
.3a36ed	1b		tcs		            TCS
.3a36ee	28		plp		                PLP
.3a36ef	60		rts		            RTS
=0					DMA_LINEAR = 0                              ; Memory to copy is a continguous, linear range
=1					DMA_RECT = 1                                ; Memory to copy is a rectangular block
.0000					DMA_BLOCK
>0000					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>0001					ADDR            .long ?                     ; The starting address for the data to transfer
>0004					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>0007					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>0009					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>000b					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
=$01					DMA_SRC_2D = $01                            ; Source transfer should be 2D
=$02					DMA_DST_2D = $02                            ; Destination transfer should be 2D
=$10					DMA_SRC_SRAM = $10                          ; Flag indicating that the source is in SRAM ($00:0000 - $3F:FFFF)
=$20					DMA_DST_SRAM = $20                          ; Flag indicating that the destination is in SRAM ($00:0000 - $3F:FFFF)
>3af058					DMA_BLOCKS      .byte ?                     ; What blocks are involved
.3af059					DMA_SRC
>3af059					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>3af05a					ADDR            .long ?                     ; The starting address for the data to transfer
>3af05d					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>3af060					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>3af062					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>3af064					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.3af066					DMA_DEST
>3af066					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>3af067					ADDR            .long ?                     ; The starting address for the data to transfer
>3af06a					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>3af06d					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>3af06f					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>3af071					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.3a36f0					DO_DMA
.3a36f0	0b		phd		                PHD
.3a36f1	08		php		                PHP
.3a36f2	08		php		            PHP
.3a36f3	c2 20		rep #$20	            REP #$20
.3a36f5	48		pha		            PHA
.3a36f6	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a36f9	5b		tcd		            TCD
.3a36fa	68		pla		            PLA
.3a36fb	28		plp		            PLP
.3a36fc	e2 20		sep #$20	            SEP #$20
.3a36fe	a9 00		lda #$00	                LDA #0
.3a3700	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS           ; Set mode to something neutral
.3a3704	af 5c f0 3a	lda $3af05c	                LDA @l DMA_SRC.ADDR+2       ; Check the bank
.3a3708	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.3a370a	b0 1c		bcs $3a3728	                BGE src_vram                ; Yes: leave the DMA_BLOCK bit alone
.3a370c	8f 24 04 af	sta $af0424	src_sram        STA @l SDMA_SRC_ADDY_H      ; Set the SDMA source address
.3a3710	af 5b f0 3a	lda $3af05b	                LDA @l DMA_SRC.ADDR+1
.3a3714	8f 23 04 af	sta $af0423	                STA @l SDMA_SRC_ADDY_M
.3a3718	af 5a f0 3a	lda $3af05a	                LDA @l DMA_SRC.ADDR
.3a371c	8f 22 04 af	sta $af0422	                STA @l SDMA_SRC_ADDY_L
.3a3720	a9 10		lda #$10	                LDA #DMA_SRC_SRAM           ; Set the SRAM source block bit
.3a3722	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS
.3a3726	80 17		bra $3a373f	                BRA src_mode
.3a3728	38		sec		src_vram        SEC                         ; Convert to VRAM relative address
.3a3729	e9 b0		sbc #$b0	                SBC #`VRAM
.3a372b	8f 04 04 af	sta $af0404	                STA @l VDMA_SRC_ADDY_H      ; Set the VDMA source address
.3a372f	af 5b f0 3a	lda $3af05b	                LDA @l DMA_SRC.ADDR+1
.3a3733	8f 03 04 af	sta $af0403	                STA @l VDMA_SRC_ADDY_M
.3a3737	af 5a f0 3a	lda $3af05a	                LDA @l DMA_SRC.ADDR
.3a373b	8f 02 04 af	sta $af0402	                STA @l VDMA_SRC_ADDY_L
.3a373f	af 59 f0 3a	lda $3af059	src_mode        LDA @l DMA_SRC.MODE         ; Determine if source is 1D or 2D
.3a3743	d0 3c		bne $3a3781	                BNE src_2d
.3a3745	af 58 f0 3a	lda $3af058	src_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.3a3749	f0 1b		beq $3a3766	                BEQ src_1d_vram
.3a374b	af 5d f0 3a	lda $3af05d	src_1d_sram     LDA @l DMA_SRC.SIZE         ; It's SRAM, so set the SDMA size
.3a374f	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.3a3753	af 5e f0 3a	lda $3af05e	                LDA @l DMA_SRC.SIZE+1
.3a3757	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_M
.3a375b	af 5f f0 3a	lda $3af05f	                LDA @l DMA_SRC.SIZE+2
.3a375f	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.3a3763	82 8b 00	brl $3a37f1	                BRL set_dst                 ; Go to set up the destination
.3a3766	af 5d f0 3a	lda $3af05d	src_1d_vram     LDA @l DMA_SRC.SIZE         ; It's VRAM, so set the VDMA size
.3a376a	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.3a376e	af 5e f0 3a	lda $3af05e	                LDA @l DMA_SRC.SIZE+1
.3a3772	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_M
.3a3776	af 5f f0 3a	lda $3af05f	                LDA @l DMA_SRC.SIZE+2
.3a377a	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.3a377e	82 70 00	brl $3a37f1	                BRL set_dst                 ; Go to set up the destination
.3a3781	af 58 f0 3a	lda $3af058	src_2d          LDA @l DMA_BLOCKS
.3a3785	09 01		ora #$01	                ORA #DMA_SRC_2D             ; Set the bit to make the source a 2D transfer
.3a3787	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS
.3a378b	89 10		bit #$10	                BIT #DMA_SRC_SRAM           ; Are we writing to SRAM
.3a378d	f0 32		beq $3a37c1	                BEQ src_2d_vram             ; No: set the 2d values in the VRAM source
.3a378f	af 60 f0 3a	lda $3af060	src_2d_sram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.3a3793	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.3a3797	af 61 f0 3a	lda $3af061	                LDA @l DMA_SRC.WIDTH+1
.3a379b	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.3a379f	af 62 f0 3a	lda $3af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.3a37a3	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.3a37a7	af 63 f0 3a	lda $3af063	                LDA @l DMA_SRC.HEIGHT+1
.3a37ab	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.3a37af	af 64 f0 3a	lda $3af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.3a37b3	8f 2c 04 af	sta $af042c	                STA @l SDMA_SRC_STRIDE_L
.3a37b7	af 65 f0 3a	lda $3af065	                LDA @l DMA_SRC.STRIDE+1
.3a37bb	8f 2d 04 af	sta $af042d	                STA @l SDMA_SRC_STRIDE_L+1
.3a37bf	80 30		bra $3a37f1	                BRA set_dst
.3a37c1	af 60 f0 3a	lda $3af060	src_2d_vram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.3a37c5	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.3a37c9	af 61 f0 3a	lda $3af061	                LDA @l DMA_SRC.WIDTH+1
.3a37cd	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.3a37d1	af 62 f0 3a	lda $3af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.3a37d5	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.3a37d9	af 63 f0 3a	lda $3af063	                LDA @l DMA_SRC.HEIGHT+1
.3a37dd	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.3a37e1	af 64 f0 3a	lda $3af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.3a37e5	8f 0c 04 af	sta $af040c	                STA @l VDMA_SRC_STRIDE_L
.3a37e9	af 65 f0 3a	lda $3af065	                LDA @l DMA_SRC.STRIDE+1
.3a37ed	8f 0d 04 af	sta $af040d	                STA @l VDMA_SRC_STRIDE_L+1
.3a37f1					set_dst
.3a37f1	e2 20		sep #$20	            SEP #$20
.3a37f3	af 69 f0 3a	lda $3af069	                LDA @l DMA_DEST.ADDR+2      ; Check the bank
.3a37f7	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.3a37f9	b0 20		bcs $3a381b	                BGE dst_vram                ; Yes: leave the DMA_BLOCK bit alone
.3a37fb	8f 27 04 af	sta $af0427	dst_sram        STA @l SDMA_DST_ADDY_H      ; Set the SDMA destination address
.3a37ff	af 68 f0 3a	lda $3af068	                LDA @l DMA_DEST.ADDR+1
.3a3803	8f 26 04 af	sta $af0426	                STA @l SDMA_DST_ADDY_M
.3a3807	af 67 f0 3a	lda $3af067	                LDA @l DMA_DEST.ADDR
.3a380b	8f 25 04 af	sta $af0425	                STA @l SDMA_DST_ADDY_L
.3a380f	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS
.3a3813	09 20		ora #$20	                ORA #DMA_DST_SRAM           ; Set the bit to indicate the destination is SRAM
.3a3815	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS
.3a3819	80 17		bra $3a3832	                BRA dst_mode
.3a381b	38		sec		dst_vram        SEC                         ; Convert to VRAM relative address
.3a381c	e9 b0		sbc #$b0	                SBC #`VRAM
.3a381e	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H      ; Set the VDMA destination address
.3a3822	af 68 f0 3a	lda $3af068	                LDA @l DMA_DEST.ADDR+1
.3a3826	8f 06 04 af	sta $af0406	                STA @l VDMA_DST_ADDY_M
.3a382a	af 67 f0 3a	lda $3af067	                LDA @l DMA_DEST.ADDR
.3a382e	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.3a3832	af 66 f0 3a	lda $3af066	dst_mode        LDA @l DMA_DEST.MODE
.3a3836	d0 3e		bne $3a3876	                BNE dst_2d                  ; If 2D, set up the 2D destination parameters
.3a3838	af 58 f0 3a	lda $3af058	dst_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.3a383c	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Is the destination SRAM?
.3a383e	f0 1b		beq $3a385b	                BEQ dst_1d_vram
.3a3840	af 6a f0 3a	lda $3af06a	dst_1d_sram     LDA @l DMA_DEST.SIZE
.3a3844	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.3a3848	af 6b f0 3a	lda $3af06b	                LDA @l DMA_DEST.SIZE+1
.3a384c	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_L+1
.3a3850	af 6c f0 3a	lda $3af06c	                LDA @l DMA_DEST.SIZE+2
.3a3854	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.3a3858	82 8b 00	brl $3a38e6	                BRL start_xfer
.3a385b	af 6a f0 3a	lda $3af06a	dst_1d_vram     LDA @l DMA_DEST.SIZE
.3a385f	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.3a3863	af 6b f0 3a	lda $3af06b	                LDA @l DMA_DEST.SIZE+1
.3a3867	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_L+1
.3a386b	af 6c f0 3a	lda $3af06c	                LDA @l DMA_DEST.SIZE+2
.3a386f	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.3a3873	82 70 00	brl $3a38e6	                BRL start_xfer
.3a3876	af 58 f0 3a	lda $3af058	dst_2d          LDA @l DMA_BLOCKS
.3a387a	09 02		ora #$02	                ORA #DMA_DST_2D             ; Set the bit to make the source a 2D transfer
.3a387c	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS
.3a3880	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Are we writing to the SRAM?
.3a3882	f0 32		beq $3a38b6	                BEQ dst_2d_vram             ; No: set the 2D parameters for VRAM
.3a3884	af 6d f0 3a	lda $3af06d	dst_2d_sram     LDA @l DMA_DEST.WIDTH       ; Set the SRAM width
.3a3888	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.3a388c	af 6e f0 3a	lda $3af06e	                LDA @L DMA_DEST.WIDTH+1
.3a3890	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.3a3894	af 6f f0 3a	lda $3af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the SRAM height
.3a3898	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.3a389c	af 70 f0 3a	lda $3af070	                LDA @L DMA_DEST.HEIGHT+1
.3a38a0	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.3a38a4	af 71 f0 3a	lda $3af071	                LDA @l DMA_DEST.STRIDE      ; Set the SRAM stride
.3a38a8	8f 2e 04 af	sta $af042e	                STA @l SDMA_DST_STRIDE_L
.3a38ac	af 72 f0 3a	lda $3af072	                LDA @L DMA_DEST.STRIDE+1
.3a38b0	8f 2f 04 af	sta $af042f	                STA @l SDMA_DST_STRIDE_L+1
.3a38b4	80 30		bra $3a38e6	                BRA start_xfer
.3a38b6	af 6d f0 3a	lda $3af06d	dst_2d_vram     LDA @l DMA_DEST.WIDTH       ; Set the VRAM width
.3a38ba	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.3a38be	af 6e f0 3a	lda $3af06e	                LDA @L DMA_DEST.WIDTH+1
.3a38c2	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.3a38c6	af 6f f0 3a	lda $3af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the VRAM height
.3a38ca	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.3a38ce	af 70 f0 3a	lda $3af070	                LDA @L DMA_DEST.HEIGHT+1
.3a38d2	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.3a38d6	af 71 f0 3a	lda $3af071	                LDA @l DMA_DEST.STRIDE      ; Set the VRAM stride
.3a38da	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L
.3a38de	af 72 f0 3a	lda $3af072	                LDA @L DMA_DEST.STRIDE+1
.3a38e2	8f 0f 04 af	sta $af040f	                STA @l VDMA_DST_STRIDE_L+1
.3a38e6	af 58 f0 3a	lda $3af058	start_xfer      LDA @l DMA_BLOCKS
.3a38ea	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.3a38ec	f0 43		beq $3a3931	                BEQ start_vdma_only
.3a38ee	c9 10		cmp #$10	                CMP #DMA_SRC_SRAM
.3a38f0	f0 76		beq $3a3968	                BEQ start_s2v
.3a38f2	c9 20		cmp #$20	                CMP #DMA_DST_SRAM
.3a38f4	d0 03		bne $3a38f9	                BNE start_sdma_only
.3a38f6	82 8a 00	brl $3a3983	                BRL start_v2s
.3a38f9					start_sdma_only
.3a38f9	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.3a38fd	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.3a38ff	f0 23		beq $3a3924	                BEQ sdma_1d_only            ; Source and Destination 1D...
.3a3901	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.3a3903	f0 23		beq $3a3928	                BEQ sdma_2d_only            ; Source and Destination 2D
.3a3905	08		php		            PHP
.3a3906	c2 20		rep #$20	            REP #$20
.3a3908	48		pha		            PHA
.3a3909	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a390c	5b		tcd		            TCD
.3a390d	68		pla		            PLA
.3a390e	28		plp		            PLP
.3a390f	e2 20		sep #$20	            SEP #$20
.3a3911	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a3913	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3917	c2 20		rep #$20	            REP #$20
.3a3919	29 ff 00	and #$00ff	            AND #$00FF
.3a391c	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a391f	e2 20		sep #$20	            SEP #$20
.3a3921	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3924	a9 01		lda #$01	sdma_1d_only    LDA #SDMA_CTRL0_Enable      ; Set the bits for 1D, SRAM->SRAM
.3a3926	80 02		bra $3a392a	                BRA sdma_set_ctrl
.3a3928	a9 03		lda #$03	sdma_2d_only    LDA #SDMA_CTRL0_Enable | SDMA_CTRL0_1D_2D
.3a392a	8f 20 04 af	sta $af0420	sdma_set_ctrl   STA @l SDMA_CTRL_REG0
.3a392e	82 7d 00	brl $3a39ae	                BRL trig_sdma               ; And trigger the SDMA
.3a3931					start_vdma_only
.3a3931	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.3a3935	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.3a3937	f0 23		beq $3a395c	                BEQ vdma_1d_only            ; Source and Destination 1D...
.3a3939	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.3a393b	f0 23		beq $3a3960	                BEQ vdma_2d_only            ; Source and Destination 2D...
.3a393d	08		php		            PHP
.3a393e	c2 20		rep #$20	            REP #$20
.3a3940	48		pha		            PHA
.3a3941	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3944	5b		tcd		            TCD
.3a3945	68		pla		            PLA
.3a3946	28		plp		            PLP
.3a3947	e2 20		sep #$20	            SEP #$20
.3a3949	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a394b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a394f	c2 20		rep #$20	            REP #$20
.3a3951	29 ff 00	and #$00ff	            AND #$00FF
.3a3954	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a3957	e2 20		sep #$20	            SEP #$20
.3a3959	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a395c	a9 01		lda #$01	vdma_1d_only    LDA #VDMA_CTRL_Enable       ; Set the bits for 1D, VRAM->VRAM
.3a395e	80 02		bra $3a3962	                BRA vdma_set_ctrl
.3a3960	a9 03		lda #$03	vdma_2d_only    LDA #VDMA_CTRL_Enable | VDMA_CTRL_1D_2D
.3a3962	8f 00 04 af	sta $af0400	vdma_set_ctrl   STA @l VDMA_CONTROL_REG
.3a3966	80 34		bra $3a399c	                BRA trig_vdma               ; And trigger the VDMA
.3a3968					start_s2v
.3a3968	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.3a396c	29 01		and #$01	                AND #DMA_SRC_2D
.3a396e	0a		asl a		                ASL A
.3a396f	09 11		ora #$11	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Src
.3a3971	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.3a3975	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.3a3979	29 02		and #$02	                AND #DMA_DST_2D
.3a397b	09 11		ora #$11	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Src
.3a397d	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a3981	80 19		bra $3a399c	                BRA trig_vdma               ; And trigger the VDMA
.3a3983					start_v2s
.3a3983	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.3a3987	29 02		and #$02	                AND #DMA_DST_2D
.3a3989	09 21		ora #$21	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Dst
.3a398b	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.3a398f	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.3a3993	29 01		and #$01	                AND #DMA_SRC_2D
.3a3995	0a		asl a		                ASL A
.3a3996	09 21		ora #$21	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Dst
.3a3998	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a399c					trig_vdma
.3a399c	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.3a39a0	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF    ; Trigger the VDMA
.3a39a2	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a39a6	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Check if we need SDMA
.3a39aa	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.3a39ac	f0 0f		beq $3a39bd	                BEQ wait_vdma               ; No: wait for VDMA to complete
.3a39ae					trig_sdma
.3a39ae	af 20 04 af	lda $af0420	                LDA @l SDMA_CTRL_REG0
.3a39b2	09 80		ora #$80	                ORA #SDMA_CTRL0_Start_TRF   ; Trigger the SDMA
.3a39b4	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.3a39b8	ea		nop		                NOP                         ; When the transfer is started the CPU will be put on Hold (RDYn)...
.3a39b9	ea		nop		                NOP                         ; Before it actually gets to stop it will execute a couple more instructions
.3a39ba	ea		nop		                NOP                         ; From that point on, the CPU is halted (keep that in mind)
.3a39bb	ea		nop		                NOP                         ; No IRQ will be processed either during that time
.3a39bc	ea		nop		                NOP
.3a39bd	af 01 04 af	lda $af0401	wait_vdma       LDA @l VDMA_STATUS_REG      ; Check the VDMA status
.3a39c1	89 80		bit #$80	                BIT #VDMA_STAT_VDMA_IPS     ; If the transfer is still in process...
.3a39c3	d0 f8		bne $3a39bd	                BNE wait_vdma               ; Wait until it stops.
.3a39c5	a9 00		lda #$00	                LDA #$00                    ; Clear the TRF bits
.3a39c7	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.3a39cb	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a39cf	28		plp		                PLP
.3a39d0	2b		pld		                PLD
.3a39d1	60		rts		            RTS
.3a39d2					S_MEMCOPY
.3a39d2	0b		phd		                PHD
.3a39d3	08		php		                PHP
.3a39d4	e2 20		sep #$20	            SEP #$20
.3a39d6	c2 10		rep #$10	            REP #$10
.3a39d8	a9 00		lda #$00	                LDA #0
.3a39da	a2 00 00	ldx #$0000	                LDX #0
.3a39dd	8f 59 f0 3a	sta $3af059	clr_loop        STA @l DMA_SRC
.3a39e1	e8		inx		                INX
.3a39e2	e0 1a 00	cpx #$001a	                CPX #SIZE(DMA_BLOCK) * 2
.3a39e5	d0 f6		bne $3a39dd	                BNE clr_loop
.3a39e7	20 3b 22	jsr $3a223b	            JSR PEEK_TOK
.3a39ea	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.3a39ec	f0 23		beq $3a3a11	                BEQ src_linear                      ; Yes: go to process a linear source
.3a39ee	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.3a39f0	f0 5e		beq $3a3a50	                BEQ src_rect                        ; Yes: go to process a rectangular source
.3a39f2					syntax_err
.3a39f2	08		php		            PHP
.3a39f3	c2 20		rep #$20	            REP #$20
.3a39f5	48		pha		            PHA
.3a39f6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a39f9	5b		tcd		            TCD
.3a39fa	68		pla		            PLA
.3a39fb	28		plp		            PLP
.3a39fc	e2 20		sep #$20	            SEP #$20
.3a39fe	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3a00	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3a04	c2 20		rep #$20	            REP #$20
.3a3a06	29 ff 00	and #$00ff	            AND #$00FF
.3a3a09	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a3a0c	e2 20		sep #$20	            SEP #$20
.3a3a0e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3a11					src_linear
.3a3a11	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3a14	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3a17	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3a1a	c2 20		rep #$20	            REP #$20
.3a3a1c	a5 23		lda $0823	            LDA ARGUMENT1
.3a3a1e	8f 5a f0 3a	sta $3af05a	            STA DMA_SRC.ADDR
.3a3a22	e2 20		sep #$20	            SEP #$20
.3a3a24	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a3a26	8f 5c f0 3a	sta $3af05c	            STA DMA_SRC.ADDR+2
.3a3a2a	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.3a3a2c	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3a2f	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3a32	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3a35	c2 20		rep #$20	            REP #$20
.3a3a37	a5 23		lda $0823	            LDA ARGUMENT1
.3a3a39	8f 5d f0 3a	sta $3af05d	            STA DMA_SRC.SIZE
.3a3a3d	e2 20		sep #$20	            SEP #$20
.3a3a3f	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a3a41	8f 5f f0 3a	sta $3af05f	            STA DMA_SRC.SIZE+2
.3a3a45	e2 20		sep #$20	            SEP #$20
.3a3a47	a9 00		lda #$00	            LDA #<DMA_LINEAR
.3a3a49	8f 59 f0 3a	sta $3af059	            STA DMA_SRC.MODE
.3a3a4d	82 74 00	brl $3a3ac4	                BRL process_to
.3a3a50					src_rect
.3a3a50	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3a53	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3a56	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3a59	c2 20		rep #$20	            REP #$20
.3a3a5b	a5 23		lda $0823	            LDA ARGUMENT1
.3a3a5d	8f 5a f0 3a	sta $3af05a	            STA DMA_SRC.ADDR
.3a3a61	e2 20		sep #$20	            SEP #$20
.3a3a63	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a3a65	8f 5c f0 3a	sta $3af05c	            STA DMA_SRC.ADDR+2
.3a3a69	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.3a3a6b	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3a6e	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3a71	20 d2 06	jsr $3a06d2	            JSR ASS_ARG1_INT16
.3a3a74	c2 20		rep #$20	            REP #$20
.3a3a76	a5 23		lda $0823	            LDA ARGUMENT1
.3a3a78	8f 60 f0 3a	sta $3af060	            STA DMA_SRC.WIDTH
.3a3a7c	8d 00 01	sta $0100	            STA M0_OPERAND_A
.3a3a7f	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.3a3a82	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3a85	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3a88	20 d2 06	jsr $3a06d2	            JSR ASS_ARG1_INT16
.3a3a8b	c2 20		rep #$20	            REP #$20
.3a3a8d	a5 23		lda $0823	            LDA ARGUMENT1
.3a3a8f	8f 62 f0 3a	sta $3af062	            STA DMA_SRC.HEIGHT
.3a3a93	8d 02 01	sta $0102	            STA M0_OPERAND_B
.3a3a96	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.3a3a99	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3a9c	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3a9f	20 d2 06	jsr $3a06d2	            JSR ASS_ARG1_INT16
.3a3aa2	c2 20		rep #$20	            REP #$20
.3a3aa4	a5 23		lda $0823	            LDA ARGUMENT1
.3a3aa6	8f 64 f0 3a	sta $3af064	            STA DMA_SRC.STRIDE
.3a3aaa	c2 20		rep #$20	            REP #$20
.3a3aac	ad 04 01	lda $0104	            LDA M0_RESULT
.3a3aaf	8f 5d f0 3a	sta $3af05d	            STA DMA_SRC.SIZE
.3a3ab3	e2 20		sep #$20	            SEP #$20
.3a3ab5	ad 06 01	lda $0106	            LDA M0_RESULT+2
.3a3ab8	8f 5f f0 3a	sta $3af05f	            STA DMA_SRC.SIZE+2
.3a3abc	e2 20		sep #$20	            SEP #$20
.3a3abe	a9 01		lda #$01	            LDA #<DMA_RECT
.3a3ac0	8f 59 f0 3a	sta $3af059	            STA DMA_SRC.MODE
.3a3ac4					process_to
.3a3ac4	e2 20		sep #$20	            SEP #$20
.3a3ac6	a9 9c		lda #$9c	                LDA #TOK_TO
.3a3ac8	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3acb	20 3b 22	jsr $3a223b	            JSR PEEK_TOK
.3a3ace	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.3a3ad0	f0 23		beq $3a3af5	                BEQ dest_linear                     ; Yes: go to process a linear destination
.3a3ad2	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.3a3ad4	f0 5e		beq $3a3b34	                BEQ dest_rect                       ; Yes: go to process a rectangular source
.3a3ad6					syntax_err2
.3a3ad6	08		php		            PHP
.3a3ad7	c2 20		rep #$20	            REP #$20
.3a3ad9	48		pha		            PHA
.3a3ada	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3add	5b		tcd		            TCD
.3a3ade	68		pla		            PLA
.3a3adf	28		plp		            PLP
.3a3ae0	e2 20		sep #$20	            SEP #$20
.3a3ae2	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3ae4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3ae8	c2 20		rep #$20	            REP #$20
.3a3aea	29 ff 00	and #$00ff	            AND #$00FF
.3a3aed	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a3af0	e2 20		sep #$20	            SEP #$20
.3a3af2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3af5					dest_linear
.3a3af5	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3af8	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3afb	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3afe	c2 20		rep #$20	            REP #$20
.3a3b00	a5 23		lda $0823	            LDA ARGUMENT1
.3a3b02	8f 67 f0 3a	sta $3af067	            STA DMA_DEST.ADDR
.3a3b06	e2 20		sep #$20	            SEP #$20
.3a3b08	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a3b0a	8f 69 f0 3a	sta $3af069	            STA DMA_DEST.ADDR+2
.3a3b0e	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.3a3b10	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3b13	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3b16	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3b19	c2 20		rep #$20	            REP #$20
.3a3b1b	a5 23		lda $0823	            LDA ARGUMENT1
.3a3b1d	8f 6a f0 3a	sta $3af06a	            STA DMA_DEST.SIZE
.3a3b21	e2 20		sep #$20	            SEP #$20
.3a3b23	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a3b25	8f 6c f0 3a	sta $3af06c	            STA DMA_DEST.SIZE+2
.3a3b29	e2 20		sep #$20	            SEP #$20
.3a3b2b	a9 00		lda #$00	            LDA #<DMA_LINEAR
.3a3b2d	8f 66 f0 3a	sta $3af066	            STA DMA_DEST.MODE
.3a3b31	82 74 00	brl $3a3ba8	                BRL verify
.3a3b34					dest_rect
.3a3b34	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3b37	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3b3a	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3b3d	c2 20		rep #$20	            REP #$20
.3a3b3f	a5 23		lda $0823	            LDA ARGUMENT1
.3a3b41	8f 67 f0 3a	sta $3af067	            STA DMA_DEST.ADDR
.3a3b45	e2 20		sep #$20	            SEP #$20
.3a3b47	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a3b49	8f 69 f0 3a	sta $3af069	            STA DMA_DEST.ADDR+2
.3a3b4d	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.3a3b4f	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3b52	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3b55	20 d2 06	jsr $3a06d2	            JSR ASS_ARG1_INT16
.3a3b58	c2 20		rep #$20	            REP #$20
.3a3b5a	a5 23		lda $0823	            LDA ARGUMENT1
.3a3b5c	8f 6d f0 3a	sta $3af06d	            STA DMA_DEST.WIDTH
.3a3b60	8d 00 01	sta $0100	            STA M0_OPERAND_A
.3a3b63	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.3a3b66	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3b69	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3b6c	20 d2 06	jsr $3a06d2	            JSR ASS_ARG1_INT16
.3a3b6f	c2 20		rep #$20	            REP #$20
.3a3b71	a5 23		lda $0823	            LDA ARGUMENT1
.3a3b73	8f 6f f0 3a	sta $3af06f	            STA DMA_DEST.HEIGHT
.3a3b77	8d 02 01	sta $0102	            STA M0_OPERAND_B
.3a3b7a	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.3a3b7d	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3b80	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3b83	20 d2 06	jsr $3a06d2	            JSR ASS_ARG1_INT16
.3a3b86	c2 20		rep #$20	            REP #$20
.3a3b88	a5 23		lda $0823	            LDA ARGUMENT1
.3a3b8a	8f 71 f0 3a	sta $3af071	            STA DMA_DEST.STRIDE
.3a3b8e	c2 20		rep #$20	            REP #$20
.3a3b90	ad 04 01	lda $0104	            LDA M0_RESULT
.3a3b93	8f 6a f0 3a	sta $3af06a	            STA DMA_DEST.SIZE
.3a3b97	e2 20		sep #$20	            SEP #$20
.3a3b99	ad 06 01	lda $0106	            LDA M0_RESULT+2
.3a3b9c	8f 6c f0 3a	sta $3af06c	            STA DMA_DEST.SIZE+2
.3a3ba0	e2 20		sep #$20	            SEP #$20
.3a3ba2	a9 01		lda #$01	            LDA #<DMA_RECT
.3a3ba4	8f 66 f0 3a	sta $3af066	            STA DMA_DEST.MODE
.3a3ba8					verify
.3a3ba8	c2 20		rep #$20	            REP #$20
.3a3baa	af 5d f0 3a	lda $3af05d	                LDA @l DMA_SRC.SIZE
.3a3bae	cf 6a f0 3a	cmp $3af06a	                CMP @l DMA_DEST.SIZE
.3a3bb2	d0 14		bne $3a3bc8	                BNE size_err
.3a3bb4	e2 20		sep #$20	            SEP #$20
.3a3bb6	af 5f f0 3a	lda $3af05f	                LDA @l DMA_SRC.SIZE+2
.3a3bba	cf 6c f0 3a	cmp $3af06c	                CMP @l DMA_DEST.SIZE+2
.3a3bbe	d0 08		bne $3a3bc8	                BNE size_err
.3a3bc0	c2 20		rep #$20	            REP #$20
.3a3bc2	20 f0 36	jsr $3a36f0	            JSR DO_DMA
.3a3bc5	28		plp		                PLP
.3a3bc6	2b		pld		                PLD
.3a3bc7	60		rts		            RTS
.3a3bc8					size_err
.3a3bc8	08		php		            PHP
.3a3bc9	c2 20		rep #$20	            REP #$20
.3a3bcb	48		pha		            PHA
.3a3bcc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3bcf	5b		tcd		            TCD
.3a3bd0	68		pla		            PLA
.3a3bd1	28		plp		            PLP
.3a3bd2	e2 20		sep #$20	            SEP #$20
.3a3bd4	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a3bd6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3bda	c2 20		rep #$20	            REP #$20
.3a3bdc	29 ff 00	and #$00ff	            AND #$00FF
.3a3bdf	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a3be2	e2 20		sep #$20	            SEP #$20
.3a3be4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3be7					S_LOCATE
.3a3be7	08		php		                PHP
.3a3be8	c2 30		rep #$30	            REP #$30
.3a3bea	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3bed	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a3bf0	a5 23		lda $0823	                LDA ARGUMENT1
.3a3bf2	48		pha		                PHA                         ; Save it for later
.3a3bf3	a9 2c 00	lda #$002c	                LDA #','                    ; Check for the comma separator
.3a3bf6	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3bf9	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3bfc	20 28 07	jsr $3a0728	            JSR ASS_ARG1_BYTE
.3a3bff	a4 23		ldy $0823	                LDY ARGUMENT1               ; Set Y to the row
.3a3c01	fa		plx		                PLX                         ; Set X to the column
.3a3c02	20 20 00	jsr $3a0020	            JSR CURSORXY
.3a3c05	28		plp		                PLP
.3a3c06	60		rts		            RTS

;******  Return to file: src\statements.s

.3a3c07					S_INPUT
.3a3c07	08		php		                PHP
.3a3c08					varloop
.3a3c08	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a3c0b	e2 20		sep #$20	            SEP #$20
.3a3c0d	a7 00		lda [$0800]	                LDA [BIP]
.3a3c0f	d0 03		bne $3a3c14	                BNE check_colon
.3a3c11	4c af 3c	jmp $3a3caf	                JMP done            ; If EOL, we're done
.3a3c14	c9 3a		cmp #$3a	check_colon     CMP #':'
.3a3c16	d0 03		bne $3a3c1b	                BNE check_string
.3a3c18	4c af 3c	jmp $3a3caf	                JMP done            ; If colon, we're done
.3a3c1b	c9 22		cmp #$22	check_string    CMP #CHAR_DQUOTE    ; Is it the start of a string?
.3a3c1d	d0 0b		bne $3a3c2a	                BNE check_var       ; No: then it should be a variable name
.3a3c1f	20 d5 1b	jsr $3a1bd5	            JSR EVALSTRING
.3a3c22	20 bd 45	jsr $3a45bd	            JSR PR_STRING
.3a3c25	a9 3b		lda #$3b	                LDA #';'            ; Look for a semicolon
.3a3c27	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3c2a					check_var
.3a3c2a	20 a7 04	jsr $3a04a7	            JSR ISALPHA
.3a3c2d	90 44		bcc $3a3c73	                BCC syntax_err      ; No: it's a syntax error
.3a3c2f	20 82 53	jsr $3a5382	            JSR VAR_FINDNAME
.3a3c32	90 3f		bcc $3a3c73	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.3a3c34	a9 3f		lda #$3f	                LDA #"?"            ; Print a "? " to follow
.3a3c36	20 18 00	jsr $3a0018	            JSR PRINTC
.3a3c39	a9 20		lda #$20	                LDA #CHAR_SP
.3a3c3b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a3c3e	20 10 00	jsr $3a0010	            JSR INPUTLINE
.3a3c41	e2 20		sep #$20	            SEP #$20
.3a3c43	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Check the type of the variable
.3a3c45	c9 02		cmp #$02	                CMP #TYPE_STRING    ; If it's a string...
.3a3c47	f0 49		beq $3a3c92	                BEQ in_string       ; ... go to copy the string data
.3a3c49	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; If it's an integer...
.3a3c4b	d0 03		bne $3a3c50	                BNE chk_float
.3a3c4d	82 84 00	brl $3a3cd4	                BRL in_integer      ; ... go to parse the integer
.3a3c50	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT     ; If it's a float...
.3a3c52	f0 5d		beq $3a3cb1	                BEQ in_float        ; ... go to parse the float
.3a3c54	08		php		            PHP
.3a3c55	c2 20		rep #$20	            REP #$20
.3a3c57	48		pha		            PHA
.3a3c58	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3c5b	5b		tcd		            TCD
.3a3c5c	68		pla		            PLA
.3a3c5d	28		plp		            PLP
.3a3c5e	e2 20		sep #$20	            SEP #$20
.3a3c60	a9 04		lda #$04	            LDA #ERR_TYPE
.3a3c62	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3c66	c2 20		rep #$20	            REP #$20
.3a3c68	29 ff 00	and #$00ff	            AND #$00FF
.3a3c6b	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a3c6e	e2 20		sep #$20	            SEP #$20
.3a3c70	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3c73					syntax_err
.3a3c73	08		php		            PHP
.3a3c74	c2 20		rep #$20	            REP #$20
.3a3c76	48		pha		            PHA
.3a3c77	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3c7a	5b		tcd		            TCD
.3a3c7b	68		pla		            PLA
.3a3c7c	28		plp		            PLP
.3a3c7d	e2 20		sep #$20	            SEP #$20
.3a3c7f	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3c81	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3c85	c2 20		rep #$20	            REP #$20
.3a3c87	29 ff 00	and #$00ff	            AND #$00FF
.3a3c8a	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a3c8d	e2 20		sep #$20	            SEP #$20
.3a3c8f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3c92					in_string
.3a3c92	c2 20		rep #$20	            REP #$20
.3a3c94	a9 00 4c	lda #$4c00	                LDA #<>IOBUF
.3a3c97	85 23		sta $0823	                STA ARGUMENT1
.3a3c99	a9 00 00	lda #$0000	                LDA #`IOBUF
.3a3c9c	85 25		sta $0825	                STA ARGUMENT1+2
.3a3c9e	e2 20		sep #$20	            SEP #$20
.3a3ca0	a9 02		lda #$02	                LDA #TYPE_STRING
.3a3ca2	85 27		sta $0827	                STA ARGTYPE1
.3a3ca4					save_input
.3a3ca4	c2 20		rep #$20	            REP #$20
.3a3ca6	20 e5 52	jsr $3a52e5	            JSR VAR_SET
.3a3ca9	a9 0d 00	lda #$000d	                LDA #CHAR_CR        ; Print a newline
.3a3cac	20 18 00	jsr $3a0018	            JSR PRINTC
.3a3caf	28		plp		done            PLP
.3a3cb0	60		rts		            RTS
.3a3cb1					in_float
.3a3cb1	c2 20		rep #$20	            REP #$20
.3a3cb3	a5 00		lda $0800	                LDA BIP             ; Save the BIP for later use
.3a3cb5	85 40		sta $0840	                STA SAVEBIP
.3a3cb7	a5 02		lda $0802	                LDA BIP+2
.3a3cb9	85 42		sta $0842	                STA SAVEBIP+2
.3a3cbb	a9 00 4c	lda #$4c00	                LDA #<>IOBUF        ; Point to the line that was just input
.3a3cbe	85 00		sta $0800	                STA BIP
.3a3cc0	a9 00 00	lda #$0000	                LDA #`IOBUF
.3a3cc3	85 02		sta $0802	                STA BIP+2
.3a3cc5	20 a4 59	jsr $3a59a4	            JSR PARSENUM
.3a3cc8	c2 20		rep #$20	            REP #$20
.3a3cca	a5 40		lda $0840	                LDA SAVEBIP         ; Restore the BIP
.3a3ccc	85 00		sta $0800	                STA BIP
.3a3cce	a5 42		lda $0842	                LDA SAVEBIP+2
.3a3cd0	85 02		sta $0802	                STA BIP+2
.3a3cd2	80 d0		bra $3a3ca4	                BRA save_input
.3a3cd4					in_integer
.3a3cd4	c2 20		rep #$20	            REP #$20
.3a3cd6	a5 00		lda $0800	                LDA BIP             ; Save the BIP for later use
.3a3cd8	85 40		sta $0840	                STA SAVEBIP
.3a3cda	a5 02		lda $0802	                LDA BIP+2
.3a3cdc	85 42		sta $0842	                STA SAVEBIP+2
.3a3cde	a9 00 4c	lda #$4c00	                LDA #<>IOBUF        ; Point to the line that was just input
.3a3ce1	85 00		sta $0800	                STA BIP
.3a3ce3	a9 00 00	lda #$0000	                LDA #`IOBUF
.3a3ce6	85 02		sta $0802	                STA BIP+2
.3a3ce8	20 9d 08	jsr $3a089d	            JSR PARSEINT
.3a3ceb	c2 20		rep #$20	            REP #$20
.3a3ced	a5 40		lda $0840	                LDA SAVEBIP         ; Restore the BIP
.3a3cef	85 00		sta $0800	                STA BIP
.3a3cf1	a5 42		lda $0842	                LDA SAVEBIP+2
.3a3cf3	85 02		sta $0802	                STA BIP+2
.3a3cf5	80 ad		bra $3a3ca4	                BRA save_input
.3a3cf7					S_GET
.3a3cf7	08		php		                PHP
.3a3cf8					varloop
.3a3cf8	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a3cfb	e2 20		sep #$20	            SEP #$20
.3a3cfd	a7 00		lda [$0800]	                LDA [BIP]
.3a3cff	f0 47		beq $3a3d48	                BEQ done            ; If EOL, we're done
.3a3d01	c9 3a		cmp #$3a	                CMP #':'
.3a3d03	f0 43		beq $3a3d48	                BEQ done            ; If colon, we're done
.3a3d05	20 a7 04	jsr $3a04a7	            JSR ISALPHA
.3a3d08	90 40		bcc $3a3d4a	                BCC syntax_err      ; No: it's a syntax error
.3a3d0a	20 82 53	jsr $3a5382	            JSR VAR_FINDNAME
.3a3d0d	90 3b		bcc $3a3d4a	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.3a3d0f	20 be 14	jsr $3a14be	            JSR TEMPSTRING
.3a3d12	20 14 00	jsr $3a0014	            JSR GETKEY
.3a3d15	e2 20		sep #$20	            SEP #$20
.3a3d17	a0 00 00	ldy #$0000	                LDY #0
.3a3d1a	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a3d1c	a9 00		lda #$00	                LDA #0
.3a3d1e	c8		iny		                INY
.3a3d1f	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a3d21	c2 20		rep #$20	            REP #$20
.3a3d23	a5 16		lda $0816	                LDA STRPTR
.3a3d25	85 23		sta $0823	                STA ARGUMENT1
.3a3d27	a5 18		lda $0818	                LDA STRPTR+2
.3a3d29	85 25		sta $0825	                STA ARGUMENT1+2
.3a3d2b	e2 20		sep #$20	            SEP #$20
.3a3d2d	a9 02		lda #$02	                LDA #TYPE_STRING
.3a3d2f	85 27		sta $0827	                STA ARGTYPE1
.3a3d31	20 e5 52	jsr $3a52e5	            JSR VAR_SET
.3a3d34	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a3d37	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.3a3d39	f0 0d		beq $3a3d48	                BEQ done            ; EOL? We're done
.3a3d3b	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.3a3d3d	f0 09		beq $3a3d48	                BEQ done
.3a3d3f	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.3a3d41	d0 07		bne $3a3d4a	                BNE syntax_err      ; Nope: syntax error
.3a3d43	20 da 20	jsr $3a20da	            JSR INCBIP
.3a3d46	80 b0		bra $3a3cf8	                BRA varloop
.3a3d48	28		plp		done            PLP
.3a3d49	60		rts		            RTS
.3a3d4a					syntax_err
.3a3d4a	08		php		            PHP
.3a3d4b	c2 20		rep #$20	            REP #$20
.3a3d4d	48		pha		            PHA
.3a3d4e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3d51	5b		tcd		            TCD
.3a3d52	68		pla		            PLA
.3a3d53	28		plp		            PLP
.3a3d54	e2 20		sep #$20	            SEP #$20
.3a3d56	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3d58	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3d5c	c2 20		rep #$20	            REP #$20
.3a3d5e	29 ff 00	and #$00ff	            AND #$00FF
.3a3d61	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a3d64	e2 20		sep #$20	            SEP #$20
.3a3d66	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3d69					S_CALL
.3a3d69	08		php		                PHP
.3a3d6a	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3d6d	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3d70	e2 20		sep #$20	            SEP #$20
.3a3d72	a9 5c		lda #$5c	                LDA #$5C            ; Set the opcode for JML
.3a3d74	85 a2		sta $08a2	                STA MJUMPINST
.3a3d76	c2 20		rep #$20	            REP #$20
.3a3d78	a5 23		lda $0823	                LDA ARGUMENT1
.3a3d7a	85 a3		sta $08a3	                STA MJUMPADDR
.3a3d7c	e2 20		sep #$20	            SEP #$20
.3a3d7e	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a3d80	85 a5		sta $08a5	                STA MJUMPADDR+2
.3a3d82	e2 20		sep #$20	            SEP #$20
.3a3d84	a9 2c		lda #$2c	                LDA #','
.3a3d86	85 37		sta $0837	                STA TARGETTOK
.3a3d88	20 1c 22	jsr $3a221c	            JSR OPT_TOK
.3a3d8b	90 41		bcc $3a3dce	                BCC launch          ; Not present... go ahead and launch
.3a3d8d	20 da 20	jsr $3a20da	            JSR INCBIP
.3a3d90	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3d93	20 d2 06	jsr $3a06d2	            JSR ASS_ARG1_INT16
.3a3d96	c2 20		rep #$20	            REP #$20
.3a3d98	a5 23		lda $0823	                LDA ARGUMENT1
.3a3d9a	85 55		sta $0855	                STA MARG1           ; Save it to MARG1
.3a3d9c	e2 20		sep #$20	            SEP #$20
.3a3d9e	a9 2c		lda #$2c	                LDA #','
.3a3da0	85 37		sta $0837	                STA TARGETTOK
.3a3da2	20 1c 22	jsr $3a221c	            JSR OPT_TOK
.3a3da5	90 27		bcc $3a3dce	                BCC launch          ; Not present... go ahead and launch
.3a3da7	20 da 20	jsr $3a20da	            JSR INCBIP
.3a3daa	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3dad	20 d2 06	jsr $3a06d2	            JSR ASS_ARG1_INT16
.3a3db0	c2 20		rep #$20	            REP #$20
.3a3db2	a5 23		lda $0823	                LDA ARGUMENT1
.3a3db4	85 59		sta $0859	                STA MARG2           ; Save it to MARG2
.3a3db6	e2 20		sep #$20	            SEP #$20
.3a3db8	a9 2c		lda #$2c	                LDA #','
.3a3dba	85 37		sta $0837	                STA TARGETTOK
.3a3dbc	20 1c 22	jsr $3a221c	            JSR OPT_TOK
.3a3dbf	90 0d		bcc $3a3dce	                BCC launch          ; Not present... go ahead and launch
.3a3dc1	20 da 20	jsr $3a20da	            JSR INCBIP
.3a3dc4	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3dc7	20 d2 06	jsr $3a06d2	            JSR ASS_ARG1_INT16
.3a3dca	c2 20		rep #$20	            REP #$20
.3a3dcc	a4 23		ldy $0823	                LDY ARGUMENT1
.3a3dce	a6 59		ldx $0859	launch          LDX MARG2
.3a3dd0	a5 55		lda $0855	                LDA MARG1
.3a3dd2	0b		phd		                PHD
.3a3dd3	8b		phb		                PHB
.3a3dd4	08		php		                PHP
.3a3dd5	22 a2 08 00	jsl $0008a2	                JSL MJUMPINST       ; Call the subroutine indicated
.3a3dd9	28		plp		                PLP
.3a3dda	ab		plb		                PLB
.3a3ddb	2b		pld		                PLD
.3a3ddc	20 1f 21	jsr $3a211f	            JSR SKIPSTMT
.3a3ddf	28		plp		                PLP
.3a3de0	60		rts		            RTS
.3a3de1					type_err
.3a3de1	08		php		            PHP
.3a3de2	c2 20		rep #$20	            REP #$20
.3a3de4	48		pha		            PHA
.3a3de5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3de8	5b		tcd		            TCD
.3a3de9	68		pla		            PLA
.3a3dea	28		plp		            PLP
.3a3deb	e2 20		sep #$20	            SEP #$20
.3a3ded	a9 04		lda #$04	            LDA #ERR_TYPE
.3a3def	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3df3	c2 20		rep #$20	            REP #$20
.3a3df5	29 ff 00	and #$00ff	            AND #$00FF
.3a3df8	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a3dfb	e2 20		sep #$20	            SEP #$20
.3a3dfd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3e00					S_DIM
.3a3e00	08		php		                PHP
.3a3e01	e2 20		sep #$20	            SEP #$20
.3a3e03	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a3e06	20 82 53	jsr $3a5382	            JSR VAR_FINDNAME
.3a3e09	90 64		bcc $3a3e6f	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.3a3e0b	a9 8f		lda #$8f	                LDA #TOK_LPAREN     ; Verify we have a left parenthesis
.3a3e0d	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a3e10	a9 01		lda #$01	                LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.3a3e12	20 e5 19	jsr $3a19e5	            JSR PHOPERATOR
.3a3e15	a2 01 00	ldx #$0001	                LDX #1
.3a3e18	a9 00		lda #$00	                LDA #0
.3a3e1a	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF     ; Set the dimension count to 0
.3a3e1e					dim_loop
.3a3e1e	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3e21	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a3e24	c2 20		rep #$20	            REP #$20
.3a3e26	a5 23		lda $0823	                LDA ARGUMENT1
.3a3e28	9f 00 4d 00	sta $004d00,x	                STA @lARRIDXBUF,X   ; And store it in the buffer
.3a3e2c	e2 20		sep #$20	            SEP #$20
.3a3e2e	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF     ; Add to the dimension count
.3a3e32	1a		inc a		                INC A
.3a3e33	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF
.3a3e37	30 55		bmi $3a3e8e	                BMI overflow        ; If > 127 throw an error
.3a3e39	e8		inx		                INX
.3a3e3a	e8		inx		                INX
.3a3e3b	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a3e3e	a7 00		lda [$0800]	                LDA [BIP]           ; Check the character
.3a3e40	c9 2c		cmp #$2c	                CMP #','            ; Is it a comma?
.3a3e42	f0 25		beq $3a3e69	                BEQ skip_comma      ; Yes: get the next dimension
.3a3e44	c9 90		cmp #$90	                CMP #TOK_RPAREN     ; No: is it a ")"?
.3a3e46	d0 27		bne $3a3e6f	                BNE syntax_err      ; No: throw a syntax error
.3a3e48	20 da 20	jsr $3a20da	            JSR INCBIP
.3a3e4b	20 00 66	jsr $3a6600	            JSR ARR_ALLOC
.3a3e4e	c2 20		rep #$20	            REP #$20
.3a3e50	a5 c0		lda $08c0	                LDA CURRBLOCK       ; Set up the pointer to the array
.3a3e52	85 23		sta $0823	                STA ARGUMENT1
.3a3e54	e2 20		sep #$20	            SEP #$20
.3a3e56	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.3a3e58	85 25		sta $0825	                STA ARGUMENT1+2
.3a3e5a	64 26		stz $0826	                STZ ARGUMENT1+3
.3a3e5c	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Get the type of the values
.3a3e5e	09 80		ora #$80	                ORA #$80            ; Make sure we change the type to array
.3a3e60	85 ea		sta $08ea	                STA TOFINDTYPE      ; And save it back for searching
.3a3e62	85 27		sta $0827	                STA ARGTYPE1        ; And for the value to set
.3a3e64	20 e5 52	jsr $3a52e5	            JSR VAR_SET
.3a3e67	28		plp		                PLP
.3a3e68	60		rts		            RTS
.3a3e69					skip_comma
.3a3e69	20 da 20	jsr $3a20da	            JSR INCBIP
.3a3e6c	4c 1e 3e	jmp $3a3e1e	                JMP dim_loop
.3a3e6f					syntax_err
.3a3e6f	08		php		            PHP
.3a3e70	c2 20		rep #$20	            REP #$20
.3a3e72	48		pha		            PHA
.3a3e73	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3e76	5b		tcd		            TCD
.3a3e77	68		pla		            PLA
.3a3e78	28		plp		            PLP
.3a3e79	e2 20		sep #$20	            SEP #$20
.3a3e7b	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3e7d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3e81	c2 20		rep #$20	            REP #$20
.3a3e83	29 ff 00	and #$00ff	            AND #$00FF
.3a3e86	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a3e89	e2 20		sep #$20	            SEP #$20
.3a3e8b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3e8e					overflow
.3a3e8e	08		php		            PHP
.3a3e8f	c2 20		rep #$20	            REP #$20
.3a3e91	48		pha		            PHA
.3a3e92	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3e95	5b		tcd		            TCD
.3a3e96	68		pla		            PLA
.3a3e97	28		plp		            PLP
.3a3e98	e2 20		sep #$20	            SEP #$20
.3a3e9a	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a3e9c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3ea0	c2 20		rep #$20	            REP #$20
.3a3ea2	29 ff 00	and #$00ff	            AND #$00FF
.3a3ea5	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a3ea8	e2 20		sep #$20	            SEP #$20
.3a3eaa	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3ead					S_READ
.3a3ead	08		php		                PHP
.3a3eae					varloop
.3a3eae	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a3eb1	e2 20		sep #$20	            SEP #$20
.3a3eb3	a7 00		lda [$0800]	                LDA [BIP]
.3a3eb5	f0 28		beq $3a3edf	                BEQ done            ; If EOL, we're done
.3a3eb7	c9 3a		cmp #$3a	                CMP #':'
.3a3eb9	f0 24		beq $3a3edf	                BEQ done            ; If colon, we're done
.3a3ebb	20 a7 04	jsr $3a04a7	            JSR ISALPHA
.3a3ebe	90 21		bcc $3a3ee1	                BCC syntax_err      ; No: it's a syntax error
.3a3ec0	20 82 53	jsr $3a5382	            JSR VAR_FINDNAME
.3a3ec3	90 1c		bcc $3a3ee1	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.3a3ec5	20 00 3f	jsr $3a3f00	            JSR NEXTDATA
.3a3ec8	20 e5 52	jsr $3a52e5	            JSR VAR_SET
.3a3ecb	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a3ece	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.3a3ed0	f0 0d		beq $3a3edf	                BEQ done            ; EOL? We're done
.3a3ed2	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.3a3ed4	f0 09		beq $3a3edf	                BEQ done
.3a3ed6	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.3a3ed8	d0 07		bne $3a3ee1	                BNE syntax_err      ; Nope: syntax error
.3a3eda	20 da 20	jsr $3a20da	            JSR INCBIP
.3a3edd	80 cf		bra $3a3eae	                BRA varloop
.3a3edf	28		plp		done            PLP
.3a3ee0	60		rts		            RTS
.3a3ee1					syntax_err
.3a3ee1	08		php		            PHP
.3a3ee2	c2 20		rep #$20	            REP #$20
.3a3ee4	48		pha		            PHA
.3a3ee5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3ee8	5b		tcd		            TCD
.3a3ee9	68		pla		            PLA
.3a3eea	28		plp		            PLP
.3a3eeb	e2 20		sep #$20	            SEP #$20
.3a3eed	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3eef	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3ef3	c2 20		rep #$20	            REP #$20
.3a3ef5	29 ff 00	and #$00ff	            AND #$00FF
.3a3ef8	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a3efb	e2 20		sep #$20	            SEP #$20
.3a3efd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3f00					NEXTDATA
.3a3f00	08		php		                PHP
.3a3f01	a5 02		lda $0802	                LDA BIP+2           ; Save BIP
.3a3f03	85 42		sta $0842	                STA SAVEBIP+2
.3a3f05	a5 00		lda $0800	                LDA BIP
.3a3f07	85 40		sta $0840	                STA SAVEBIP
.3a3f09	a5 1c		lda $081c	                LDA CURLINE+2       ; Save CURLINE
.3a3f0b	85 46		sta $0846	                STA SAVELINE+2
.3a3f0d	a5 1a		lda $081a	                LDA CURLINE
.3a3f0f	85 44		sta $0844	                STA SAVELINE
.3a3f11	c2 20		rep #$20	            REP #$20
.3a3f13	a5 3a		lda $083a	                LDA DATABIP+2
.3a3f15	d0 04		bne $3a3f1b	                BNE data_set
.3a3f17	a5 38		lda $0838	                LDA DATABIP
.3a3f19	f0 4e		beq $3a3f69	                BEQ scan_start      ; No: scan for a DATA statement
.3a3f1b	a5 38		lda $0838	data_set        LDA DATABIP         ; Move BIP to the DATA statement
.3a3f1d	85 00		sta $0800	                STA BIP
.3a3f1f	a5 3a		lda $083a	                LDA DATABIP+2
.3a3f21	85 02		sta $0802	                STA BIP+2
.3a3f23	a5 3c		lda $083c	                LDA DATALINE        ; Set CURLINE from DATALINE
.3a3f25	85 1a		sta $081a	                STA CURLINE
.3a3f27	a5 3e		lda $083e	                LDA DATALINE+2
.3a3f29	85 1c		sta $081c	                STA CURLINE+2
.3a3f2b	e2 20		sep #$20	            SEP #$20
.3a3f2d	a7 00		lda [$0800]	                LDA [BIP]           ; Check character at BIP
.3a3f2f	f0 53		beq $3a3f84	                BEQ scan_DATA       ; EOL? scan for a DATA statement
.3a3f31	c9 3a		cmp #$3a	                CMP #':'            ; Colon?
.3a3f33	f0 4f		beq $3a3f84	                BEQ scan_DATA       ; ... scan for a DATA statement
.3a3f35	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.3a3f37	d0 03		bne $3a3f3c	                BNE skip_parse      ; No: skip leading WS and try to parse
.3a3f39	20 da 20	jsr $3a20da	            JSR INCBIP
.3a3f3c					skip_parse
.3a3f3c	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a3f3f	a7 00		lda [$0800]	                LDA [BIP]
.3a3f41	c9 22		cmp #$22	                CMP #CHAR_DQUOTE    ; Is it a quote?
.3a3f43	f0 4e		beq $3a3f93	                BEQ read_string     ; Yes: process the string
.3a3f45	20 c0 04	jsr $3a04c0	            JSR ISNUMERAL
.3a3f48	b0 4e		bcs $3a3f98	                BCS read_number     ; Yes: process the number
.3a3f4a					syntax_err
.3a3f4a	08		php		            PHP
.3a3f4b	c2 20		rep #$20	            REP #$20
.3a3f4d	48		pha		            PHA
.3a3f4e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3f51	5b		tcd		            TCD
.3a3f52	68		pla		            PLA
.3a3f53	28		plp		            PLP
.3a3f54	e2 20		sep #$20	            SEP #$20
.3a3f56	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3f58	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3f5c	c2 20		rep #$20	            REP #$20
.3a3f5e	29 ff 00	and #$00ff	            AND #$00FF
.3a3f61	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a3f64	e2 20		sep #$20	            SEP #$20
.3a3f66	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3f69					scan_start
.3a3f69	c2 20		rep #$20	            REP #$20
.3a3f6b	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT    ; Point CURLINE to the first line
.3a3f6e	85 1a		sta $081a	                STA CURLINE
.3a3f70	a9 36 00	lda #$0036	                LDA #`BASIC_BOT
.3a3f73	85 1c		sta $081c	                STA CURLINE+2
.3a3f75	18		clc		                CLC
.3a3f76	a5 1a		lda $081a	                LDA CURLINE         ; Point BIP to the first possible token
.3a3f78	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.3a3f7b	85 00		sta $0800	                STA BIP
.3a3f7d	a5 1c		lda $081c	                LDA CURLINE+2
.3a3f7f	69 00 00	adc #$0000	                ADC #0
.3a3f82	85 02		sta $0802	                STA BIP+2
.3a3f84					scan_data
.3a3f84	e2 20		sep #$20	            SEP #$20
.3a3f86	a9 80		lda #$80	                LDA #$80            ; We don't want to process nesting
.3a3f88	85 35		sta $0835	                STA SKIPNEST
.3a3f8a	a9 ab		lda #$ab	                LDA #TOK_DATA       ; We're looking for a DATA token
.3a3f8c	85 37		sta $0837	                STA TARGETTOK
.3a3f8e	20 31 21	jsr $3a2131	            JSR SKIPTOTOK
.3a3f91	80 a9		bra $3a3f3c	                BRA skip_parse
.3a3f93					read_string
.3a3f93	20 d5 1b	jsr $3a1bd5	            JSR EVALSTRING
.3a3f96	80 03		bra $3a3f9b	                BRA done
.3a3f98					read_number
.3a3f98	20 c7 1a	jsr $3a1ac7	            JSR EVALNUMBER
.3a3f9b					done
.3a3f9b	c2 20		rep #$20	            REP #$20
.3a3f9d	a5 00		lda $0800	                LDA BIP             ; Save BIP to DATABIP
.3a3f9f	85 38		sta $0838	                STA DATABIP
.3a3fa1	a5 02		lda $0802	                LDA BIP+2
.3a3fa3	85 3a		sta $083a	                STA DATABIP+2
.3a3fa5	a5 1a		lda $081a	                LDA CURLINE         ; Save CURLINE to DATALINE
.3a3fa7	85 3c		sta $083c	                STA DATALINE
.3a3fa9	a5 1c		lda $081c	                LDA CURLINE+2
.3a3fab	85 3e		sta $083e	                STA DATALINE+2
.3a3fad	a5 44		lda $0844	                LDA SAVELINE        ; Restore CURLINE
.3a3faf	85 1a		sta $081a	                STA CURLINE
.3a3fb1	a5 46		lda $0846	                LDA SAVELINE+2
.3a3fb3	85 1c		sta $081c	                STA CURLINE+2
.3a3fb5	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.3a3fb7	85 00		sta $0800	                STA BIP
.3a3fb9	a5 42		lda $0842	                LDA SAVEBIP+2
.3a3fbb	85 02		sta $0802	                STA BIP+2
.3a3fbd	28		plp		                PLP
.3a3fbe	60		rts		            RTS
.3a3fbf					S_DATA
.3a3fbf	20 1f 21	jsr $3a211f	            JSR SKIPSTMT
.3a3fc2	60		rts		            RTS
.3a3fc3					S_RESTORE
.3a3fc3	64 38		stz $0838	                STZ DATABIP         ; Just set DATABIP to 0
.3a3fc5	64 3a		stz $083a	                STZ DATABIP+2       ; The next READ will move it to the first DATA
.3a3fc7	64 3c		stz $083c	                STZ DATALINE        ; Set DATALINE to 0
.3a3fc9	64 3e		stz $083e	                STZ DATALINE+2
.3a3fcb	60		rts		            RTS
.3a3fcc					S_CLS
.3a3fcc	20 24 00	jsr $3a0024	            JSR CLSCREEN
.3a3fcf	60		rts		            RTS
.3a3fd0					S_POKEL
.3a3fd0	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3fd3	c2 20		rep #$20	            REP #$20
.3a3fd5	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.3a3fd7	48		pha		                PHA
.3a3fd8	a5 23		lda $0823	                LDA ARGUMENT1
.3a3fda	48		pha		                PHA
.3a3fdb	e2 20		sep #$20	            SEP #$20
.3a3fdd	a7 00		lda [$0800]	                LDA [BIP]
.3a3fdf	c9 2c		cmp #$2c	                CMP #','
.3a3fe1	d0 22		bne $3a4005	                BNE syntax_err
.3a3fe3	20 da 20	jsr $3a20da	            JSR INCBIP
.3a3fe6	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a3fe9	c2 20		rep #$20	            REP #$20
.3a3feb	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a3fed	d0 35		bne $3a4024	                BNE range_err
.3a3fef	68		pla		                PLA                 ; Pull the target address from the stack
.3a3ff0	85 08		sta $0808	                STA INDEX           ; and into INDEX
.3a3ff2	68		pla		                PLA
.3a3ff3	85 0a		sta $080a	                STA INDEX+2
.3a3ff5	c2 20		rep #$20	            REP #$20
.3a3ff7	a5 23		lda $0823	                LDA ARGUMENT1
.3a3ff9	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.3a3ffb	e2 20		sep #$20	            SEP #$20
.3a3ffd	a0 02 00	ldy #$0002	                LDY #2
.3a4000	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4002	97 08		sta [$0808],y	                STA [INDEX],Y
.3a4004	60		rts		            RTS
.3a4005					syntax_err
.3a4005	08		php		            PHP
.3a4006	c2 20		rep #$20	            REP #$20
.3a4008	48		pha		            PHA
.3a4009	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a400c	5b		tcd		            TCD
.3a400d	68		pla		            PLA
.3a400e	28		plp		            PLP
.3a400f	e2 20		sep #$20	            SEP #$20
.3a4011	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4013	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4017	c2 20		rep #$20	            REP #$20
.3a4019	29 ff 00	and #$00ff	            AND #$00FF
.3a401c	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a401f	e2 20		sep #$20	            SEP #$20
.3a4021	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4024					range_err
.3a4024	08		php		            PHP
.3a4025	c2 20		rep #$20	            REP #$20
.3a4027	48		pha		            PHA
.3a4028	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a402b	5b		tcd		            TCD
.3a402c	68		pla		            PLA
.3a402d	28		plp		            PLP
.3a402e	e2 20		sep #$20	            SEP #$20
.3a4030	a9 09		lda #$09	            LDA #ERR_RANGE
.3a4032	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4036	c2 20		rep #$20	            REP #$20
.3a4038	29 ff 00	and #$00ff	            AND #$00FF
.3a403b	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a403e	e2 20		sep #$20	            SEP #$20
.3a4040	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4043					S_POKEW
.3a4043	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4046	c2 20		rep #$20	            REP #$20
.3a4048	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.3a404a	48		pha		                PHA
.3a404b	a5 23		lda $0823	                LDA ARGUMENT1
.3a404d	48		pha		                PHA
.3a404e	e2 20		sep #$20	            SEP #$20
.3a4050	a7 00		lda [$0800]	                LDA [BIP]
.3a4052	c9 2c		cmp #$2c	                CMP #','
.3a4054	d0 19		bne $3a406f	                BNE syntax_err
.3a4056	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4059	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a405c	c2 20		rep #$20	            REP #$20
.3a405e	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4060	d0 2c		bne $3a408e	                BNE range_err
.3a4062	68		pla		                PLA                 ; Pull the target address from the stack
.3a4063	85 08		sta $0808	                STA INDEX           ; and into INDEX
.3a4065	68		pla		                PLA
.3a4066	85 0a		sta $080a	                STA INDEX+2
.3a4068	c2 20		rep #$20	            REP #$20
.3a406a	a5 23		lda $0823	                LDA ARGUMENT1
.3a406c	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.3a406e	60		rts		            RTS
.3a406f					syntax_err
.3a406f	08		php		            PHP
.3a4070	c2 20		rep #$20	            REP #$20
.3a4072	48		pha		            PHA
.3a4073	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4076	5b		tcd		            TCD
.3a4077	68		pla		            PLA
.3a4078	28		plp		            PLP
.3a4079	e2 20		sep #$20	            SEP #$20
.3a407b	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a407d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4081	c2 20		rep #$20	            REP #$20
.3a4083	29 ff 00	and #$00ff	            AND #$00FF
.3a4086	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4089	e2 20		sep #$20	            SEP #$20
.3a408b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a408e					range_err
.3a408e	08		php		            PHP
.3a408f	c2 20		rep #$20	            REP #$20
.3a4091	48		pha		            PHA
.3a4092	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4095	5b		tcd		            TCD
.3a4096	68		pla		            PLA
.3a4097	28		plp		            PLP
.3a4098	e2 20		sep #$20	            SEP #$20
.3a409a	a9 09		lda #$09	            LDA #ERR_RANGE
.3a409c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a40a0	c2 20		rep #$20	            REP #$20
.3a40a2	29 ff 00	and #$00ff	            AND #$00FF
.3a40a5	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a40a8	e2 20		sep #$20	            SEP #$20
.3a40aa	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a40ad					S_POKE
.3a40ad	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a40b0	c2 20		rep #$20	            REP #$20
.3a40b2	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.3a40b4	48		pha		                PHA
.3a40b5	a5 23		lda $0823	                LDA ARGUMENT1
.3a40b7	48		pha		                PHA
.3a40b8	e2 20		sep #$20	            SEP #$20
.3a40ba	a7 00		lda [$0800]	                LDA [BIP]
.3a40bc	c9 2c		cmp #$2c	                CMP #','
.3a40be	d0 1f		bne $3a40df	                BNE syntax_err
.3a40c0	20 da 20	jsr $3a20da	            JSR INCBIP
.3a40c3	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a40c6	e2 20		sep #$20	            SEP #$20
.3a40c8	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Make sure the value is from 0 - 255
.3a40ca	d0 32		bne $3a40fe	                BNE range_err
.3a40cc	c2 20		rep #$20	            REP #$20
.3a40ce	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a40d0	d0 2c		bne $3a40fe	                BNE range_err
.3a40d2	68		pla		                PLA                 ; Pull the target address from the stack
.3a40d3	85 08		sta $0808	                STA INDEX           ; and into INDEX
.3a40d5	68		pla		                PLA
.3a40d6	85 0a		sta $080a	                STA INDEX+2
.3a40d8	e2 20		sep #$20	            SEP #$20
.3a40da	a5 23		lda $0823	                LDA ARGUMENT1
.3a40dc	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.3a40de	60		rts		            RTS
.3a40df					syntax_err
.3a40df	08		php		            PHP
.3a40e0	c2 20		rep #$20	            REP #$20
.3a40e2	48		pha		            PHA
.3a40e3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a40e6	5b		tcd		            TCD
.3a40e7	68		pla		            PLA
.3a40e8	28		plp		            PLP
.3a40e9	e2 20		sep #$20	            SEP #$20
.3a40eb	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a40ed	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a40f1	c2 20		rep #$20	            REP #$20
.3a40f3	29 ff 00	and #$00ff	            AND #$00FF
.3a40f6	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a40f9	e2 20		sep #$20	            SEP #$20
.3a40fb	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a40fe					range_err
.3a40fe	08		php		            PHP
.3a40ff	c2 20		rep #$20	            REP #$20
.3a4101	48		pha		            PHA
.3a4102	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4105	5b		tcd		            TCD
.3a4106	68		pla		            PLA
.3a4107	28		plp		            PLP
.3a4108	e2 20		sep #$20	            SEP #$20
.3a410a	a9 09		lda #$09	            LDA #ERR_RANGE
.3a410c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4110	c2 20		rep #$20	            REP #$20
.3a4112	29 ff 00	and #$00ff	            AND #$00FF
.3a4115	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4118	e2 20		sep #$20	            SEP #$20
.3a411a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a411d					S_STOP
.3a411d	08		php		            PHP
.3a411e	c2 20		rep #$20	            REP #$20
.3a4120	48		pha		            PHA
.3a4121	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4124	5b		tcd		            TCD
.3a4125	68		pla		            PLA
.3a4126	28		plp		            PLP
.3a4127	e2 20		sep #$20	            SEP #$20
.3a4129	a9 01		lda #$01	            LDA #ERR_BREAK
.3a412b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a412f	c2 20		rep #$20	            REP #$20
.3a4131	29 ff 00	and #$00ff	            AND #$00FF
.3a4134	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4137	e2 20		sep #$20	            SEP #$20
.3a4139	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a413c					S_REM
.3a413c	08		php		                PHP
.3a413d	e2 20		sep #$20	            SEP #$20
.3a413f	a7 00		lda [$0800]	rem_loop        LDA [BIP]
.3a4141	f0 05		beq $3a4148	                BEQ done
.3a4143	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4146	80 f7		bra $3a413f	                BRA rem_loop
.3a4148	28		plp		done            PLP
.3a4149	60		rts		            RTS
.3a414a					S_EXIT
.3a414a	08		php		                PHP
.3a414b	28		plp		                PLP
.3a414c	60		rts		            RTS
.3a414d					S_DO
.3a414d	08		php		                PHP
.3a414e	28		plp		                PLP
.3a414f	60		rts		            RTS
.0000					DO_RECORD
>0000					BIP             .dword  ?
>0004					CURLINE         .dword  ?
.3a4150					S_LOOP
.3a4150	08		php		                PHP
.3a4151	28		plp		                PLP
.3a4152	60		rts		            RTS
.3a4153					S_FOR
.3a4153	08		php		                PHP
.3a4154	c2 20		rep #$20	            REP #$20
.3a4156	a5 1c		lda $081c	                LDA CURLINE+2
.3a4158	20 e2 1d	jsr $3a1de2	            JSR PHRETURN
.3a415b	a5 1a		lda $081a	                LDA CURLINE
.3a415d	20 e2 1d	jsr $3a1de2	            JSR PHRETURN
.3a4160	a5 02		lda $0802	                LDA BIP+2           ; Save current BIP
.3a4162	48		pha		                PHA
.3a4163	a5 00		lda $0800	                LDA BIP
.3a4165	48		pha		                PHA
.3a4166	20 1f 21	jsr $3a211f	            JSR SKIPSTMT
.3a4169	a5 02		lda $0802	                LDA BIP+2           ; Save the BIP for the next statement to the RETURN stack
.3a416b	20 e2 1d	jsr $3a1de2	            JSR PHRETURN
.3a416e	a5 00		lda $0800	                LDA BIP
.3a4170	20 e2 1d	jsr $3a1de2	            JSR PHRETURN
.3a4173	68		pla		                PLA                 ; Restore the original BIP
.3a4174	85 00		sta $0800	                STA BIP
.3a4176	68		pla		                PLA
.3a4177	85 02		sta $0802	                STA BIP+2
.3a4179	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a417c					get_name
.3a417c	20 82 53	jsr $3a5382	            JSR VAR_FINDNAME
.3a417f	b0 1f		bcs $3a41a0	                BCS push_name       ; If we didn't find a name, thrown an error
.3a4181	08		php		            PHP
.3a4182	c2 20		rep #$20	            REP #$20
.3a4184	48		pha		            PHA
.3a4185	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4188	5b		tcd		            TCD
.3a4189	68		pla		            PLA
.3a418a	28		plp		            PLP
.3a418b	e2 20		sep #$20	            SEP #$20
.3a418d	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.3a418f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4193	c2 20		rep #$20	            REP #$20
.3a4195	29 ff 00	and #$00ff	            AND #$00FF
.3a4198	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a419b	e2 20		sep #$20	            SEP #$20
.3a419d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a41a0					push_name
.3a41a0	e2 20		sep #$20	            SEP #$20
.3a41a2	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; To the return stack
.3a41a4	20 f9 1d	jsr $3a1df9	            JSR PHRETURNB
.3a41a7	a5 e9		lda $08e9	                LDA TOFIND+2
.3a41a9	20 f9 1d	jsr $3a1df9	            JSR PHRETURNB
.3a41ac	c2 20		rep #$20	            REP #$20
.3a41ae	a5 e7		lda $08e7	                LDA TOFIND
.3a41b0	20 e2 1d	jsr $3a1de2	            JSR PHRETURN
.3a41b3					else
.3a41b3	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a41b6	e2 20		sep #$20	            SEP #$20
.3a41b8	a7 00		lda [$0800]	                LDA [BIP]
.3a41ba	c9 8a		cmp #$8a	                CMP #TOK_EQ
.3a41bc	d0 6a		bne $3a4228	                BNE syntax_err      ; If not found: signal an syntax error
.3a41be	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Verify type of variable
.3a41c0	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; Is it integer?
.3a41c2	f0 04		beq $3a41c8	                BEQ process_initial ; Yes: it's ok
.3a41c4	c9 01		cmp #$01	                CMP #TYPE_FLOAT     ; Is it floating point?
.3a41c6	f0 00		beq $3a41c8	                BEQ process_initial ; Yes: it's ok
.3a41c8					process_initial
.3a41c8	20 da 20	jsr $3a20da	            JSR INCBIP
.3a41cb	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a41ce	20 e5 52	jsr $3a52e5	            JSR VAR_SET
.3a41d1	e2 20		sep #$20	            SEP #$20
.3a41d3	a9 9c		lda #$9c	                LDA #TOK_TO         ; Expect the next token to be TO
.3a41d5	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a41d8	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a41db	c2 20		rep #$20	            REP #$20
.3a41dd	a5 27		lda $0827	                LDA ARGTYPE1
.3a41df	20 e2 1d	jsr $3a1de2	            JSR PHRETURN
.3a41e2	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a41e4	20 e2 1d	jsr $3a1de2	            JSR PHRETURN
.3a41e7	a5 23		lda $0823	                LDA ARGUMENT1
.3a41e9	20 e2 1d	jsr $3a1de2	            JSR PHRETURN
.3a41ec	e2 20		sep #$20	            SEP #$20
.3a41ee	a9 9d		lda #$9d	                LDA #TOK_STEP
.3a41f0	85 37		sta $0837	                STA TARGETTOK
.3a41f2	20 1c 22	jsr $3a221c	            JSR OPT_TOK
.3a41f5	90 1b		bcc $3a4212	                BCC default_inc     ; Not found: set a default increment of 1
.3a41f7	20 da 20	jsr $3a20da	            JSR INCBIP
.3a41fa	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a41fd	e2 20		sep #$20	            SEP #$20
.3a41ff	a5 27		lda $0827	                LDA ARGTYPE1        ; Push the result as the increment
.3a4201	20 e2 1d	jsr $3a1de2	            JSR PHRETURN
.3a4204	c2 20		rep #$20	            REP #$20
.3a4206	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4208	20 e2 1d	jsr $3a1de2	            JSR PHRETURN
.3a420b	a5 23		lda $0823	                LDA ARGUMENT1
.3a420d	20 e2 1d	jsr $3a1de2	            JSR PHRETURN
.3a4210	80 14		bra $3a4226	                BRA done
.3a4212					default_inc
.3a4212	c2 20		rep #$20	            REP #$20
.3a4214	a9 00 00	lda #$0000	                LDA #TYPE_INTEGER
.3a4217	20 e2 1d	jsr $3a1de2	            JSR PHRETURN
.3a421a	a9 00 00	lda #$0000	                LDA #0
.3a421d	20 e2 1d	jsr $3a1de2	            JSR PHRETURN
.3a4220	a9 01 00	lda #$0001	                LDA #1
.3a4223	20 e2 1d	jsr $3a1de2	            JSR PHRETURN
.3a4226	28		plp		done            PLP
.3a4227	60		rts		            RTS
.3a4228					syntax_err
.3a4228	08		php		            PHP
.3a4229	c2 20		rep #$20	            REP #$20
.3a422b	48		pha		            PHA
.3a422c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a422f	5b		tcd		            TCD
.3a4230	68		pla		            PLA
.3a4231	28		plp		            PLP
.3a4232	e2 20		sep #$20	            SEP #$20
.3a4234	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4236	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a423a	c2 20		rep #$20	            REP #$20
.3a423c	29 ff 00	and #$00ff	            AND #$00FF
.3a423f	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4242	e2 20		sep #$20	            SEP #$20
.3a4244	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.0000					FOR_RECORD
>0000					INCREMENT       .dword  ?
>0004					INCTYPE         .word   ?
>0006					FINAL           .dword  ?
>000a					FINALTYPE       .word   ?
>000c					VARIBLE         .dword  ?
>0010					VARTYPE         .word   ?
>0012					BIP             .dword  ?
>0016					CURLINE         .dword  ?
.3a4247					S_NEXT
.3a4247	08		php		                PHP
.3a4248	8b		phb		                PHB
.3a4249	08		php		            PHP
.3a424a	e2 20		sep #$20	            SEP #$20
.3a424c	48		pha		            PHA
.3a424d	a9 00		lda #$00	            LDA #0
.3a424f	48		pha		            PHA
.3a4250	ab		plb		            PLB
.3a4251	68		pla		            PLA
.3a4252	28		plp		            PLP
.3a4253	08		php		            PHP
.3a4254	c2 20		rep #$20	            REP #$20
.3a4256	48		pha		            PHA
.3a4257	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a425a	5b		tcd		            TCD
.3a425b	68		pla		            PLA
.3a425c	28		plp		            PLP
.3a425d	c2 30		rep #$30	            REP #$30
.3a425f	a4 33		ldy $0833	                LDY RETURNSP                    ; Y := pointer to first byte of the FOR record
.3a4261	c8		iny		                INY                             ; RETURNSP points to the first free slot, so move up 2 bytes
.3a4262	c8		iny		                INY
.3a4263	c2 20		rep #$20	            REP #$20
.3a4265	b9 0c 00	lda $000c,y	                LDA #FOR_RECORD.VARIBLE,B,Y     ; TOFIND := FOR_RECORD.VARIABLE
.3a4268	85 e7		sta $08e7	                STA TOFIND
.3a426a	b9 0e 00	lda $000e,y	                LDA #FOR_RECORD.VARIBLE+2,B,Y
.3a426d	e2 20		sep #$20	            SEP #$20
.3a426f	85 e9		sta $08e9	                STA TOFIND+2
.3a4271	b9 10 00	lda $0010,y	                LDA #FOR_RECORD.VARTYPE,B,Y
.3a4274	85 ea		sta $08ea	                STA TOFINDTYPE
.3a4276	c2 20		rep #$20	            REP #$20
.3a4278	5a		phy		                PHY
.3a4279	20 83 51	jsr $3a5183	            JSR VAR_REF
.3a427c	7a		ply		                PLY
.3a427d	c2 20		rep #$20	            REP #$20
.3a427f	b9 00 00	lda $0000,y	                LDA #FOR_RECORD.INCREMENT,B,Y   ; ARGUMENT2 := FOR_RECORD.INCREMENT
.3a4282	85 29		sta $0829	                STA ARGUMENT2
.3a4284	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y
.3a4287	85 2b		sta $082b	                STA ARGUMENT2+2
.3a4289	e2 20		sep #$20	            SEP #$20
.3a428b	b9 04 00	lda $0004,y	                LDA #FOR_RECORD.INCTYPE,B,Y
.3a428e	85 2d		sta $082d	                STA ARGTYPE2
.3a4290	c2 20		rep #$20	            REP #$20
.3a4292	5a		phy		                PHY
.3a4293	20 a0 27	jsr $3a27a0	            JSR OP_PLUS
.3a4296	20 e5 52	jsr $3a52e5	            JSR VAR_SET
.3a4299	7a		ply		                PLY
.3a429a	c2 20		rep #$20	            REP #$20
.3a429c	b9 06 00	lda $0006,y	                LDA #FOR_RECORD.FINAL,B,Y       ; ARGUMENT2 := FOR_RECORD.FINAL
.3a429f	85 29		sta $0829	                STA ARGUMENT2
.3a42a1	b9 08 00	lda $0008,y	                LDA #FOR_RECORD.FINAL+2,B,Y
.3a42a4	85 2b		sta $082b	                STA ARGUMENT2+2
.3a42a6	e2 20		sep #$20	            SEP #$20
.3a42a8	b9 0a 00	lda $000a,y	                LDA #FOR_RECORD.FINALTYPE,B,Y
.3a42ab	85 2d		sta $082d	                STA ARGTYPE2
.3a42ad	c2 20		rep #$20	            REP #$20
.3a42af	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y ; Check the increment's sign
.3a42b2	30 0a		bmi $3a42be	                BMI going_down
.3a42b4					going_up
.3a42b4	20 29 2a	jsr $3a2a29	            JSR OP_LTE
.3a42b7	20 df 05	jsr $3a05df	            JSR IS_ARG1_Z
.3a42ba	f0 28		beq $3a42e4	                BEQ end_loop                    ; No: end the loop
.3a42bc	80 08		bra $3a42c6	                BRA loop_back                   ; Yes: loop back
.3a42be					going_down
.3a42be	20 e9 29	jsr $3a29e9	            JSR OP_GTE
.3a42c1	20 df 05	jsr $3a05df	            JSR IS_ARG1_Z
.3a42c4	f0 1e		beq $3a42e4	                BEQ end_loop                    ; No: end the loop
.3a42c6					loop_back
.3a42c6	c2 20		rep #$20	            REP #$20
.3a42c8	b9 12 00	lda $0012,y	                LDA #FOR_RECORD.BIP,B,Y
.3a42cb	85 00		sta $0800	                STA BIP
.3a42cd	b9 14 00	lda $0014,y	                LDA #FOR_RECORD.BIP+2,B,Y
.3a42d0	85 02		sta $0802	                STA BIP+2
.3a42d2	b9 16 00	lda $0016,y	                LDA #FOR_RECORD.CURLINE,B,Y     ; CURLINE := FOR_RECORD.CURLINE
.3a42d5	85 1a		sta $081a	                STA CURLINE
.3a42d7	b9 18 00	lda $0018,y	                LDA #FOR_RECORD.CURLINE+2,B,Y
.3a42da	85 1c		sta $081c	                STA CURLINE+2
.3a42dc	e2 20		sep #$20	            SEP #$20
.3a42de	a9 03		lda #$03	                LDA #EXEC_RETURN
.3a42e0	85 dc		sta $08dc	                STA EXECACTION
.3a42e2	80 17		bra $3a42fb	                BRA done
.3a42e4					end_loop
.3a42e4	a2 23 08	ldx #$0823	                LDX #ARGUMENT1
.3a42e7	20 a6 19	jsr $3a19a6	            JSR PLARGUMENT
.3a42ea	c2 20		rep #$20	            REP #$20
.3a42ec	18		clc		                CLC
.3a42ed	a5 33		lda $0833	                LDA RETURNSP
.3a42ef	69 1a 00	adc #$001a	                ADC #size(FOR_RECORD)           ; Move pointer by number of bytes in a FOR record
.3a42f2	85 33		sta $0833	                STA RETURNSP
.3a42f4	a5 35		lda $0835	                LDA RETURNSP+2
.3a42f6	69 00 00	adc #$0000	                ADC #0
.3a42f9	85 35		sta $0835	                STA RETURNSP+2
.3a42fb	ab		plb		done            PLB
.3a42fc	28		plp		                PLP
.3a42fd	60		rts		            RTS
.3a42fe					S_GOSUB
.3a42fe	08		php		                PHP
.3a42ff	a5 1a		lda $081a	                LDA CURLINE                 ; Save the current line for later
.3a4301	48		pha		                PHA
.3a4302	a5 1c		lda $081c	                LDA CURLINE+2
.3a4304	48		pha		                PHA
.3a4305	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a4308	20 9d 08	jsr $3a089d	            JSR PARSEINT
.3a430b	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.3a430d	f0 26		beq $3a4335	                BEQ syntax_err              ; If 0, no number was found... syntax error
.3a430f	20 da 23	jsr $3a23da	            JSR FINDLINE
.3a4312	90 42		bcc $3a4356	                BCC not_found               ; If not found... LINE NOT FOUND error
.3a4314	e2 20		sep #$20	            SEP #$20
.3a4316	a9 02		lda #$02	                LDA #EXEC_GOTO
.3a4318	85 dc		sta $08dc	                STA EXECACTION
.3a431a	20 1f 21	jsr $3a211f	            JSR SKIPSTMT
.3a431d	c2 20		rep #$20	            REP #$20
.3a431f	68		pla		                PLA                         ; Save the old value of CURLINE to the RETURN stack
.3a4320	20 e2 1d	jsr $3a1de2	            JSR PHRETURN
.3a4323	68		pla		                PLA
.3a4324	20 e2 1d	jsr $3a1de2	            JSR PHRETURN
.3a4327	a5 02		lda $0802	                LDA BIP+2                   ; Save the BASIC Instruction Pointer to the RETURN stack
.3a4329	20 e2 1d	jsr $3a1de2	            JSR PHRETURN
.3a432c	a5 00		lda $0800	                LDA BIP
.3a432e	20 e2 1d	jsr $3a1de2	            JSR PHRETURN
.3a4331	e6 31		inc $0831	                INC GOSUBDEPTH              ; Increase the count of GOSUBs on the stack
.3a4333	28		plp		                PLP
.3a4334	60		rts		            RTS
.3a4335	68		pla		syntax_err      PLA
.3a4336	68		pla		                PLA
.3a4337	08		php		            PHP
.3a4338	c2 20		rep #$20	            REP #$20
.3a433a	48		pha		            PHA
.3a433b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a433e	5b		tcd		            TCD
.3a433f	68		pla		            PLA
.3a4340	28		plp		            PLP
.3a4341	e2 20		sep #$20	            SEP #$20
.3a4343	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4345	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4349	c2 20		rep #$20	            REP #$20
.3a434b	29 ff 00	and #$00ff	            AND #$00FF
.3a434e	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4351	e2 20		sep #$20	            SEP #$20
.3a4353	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4356	68		pla		not_found       PLA
.3a4357	68		pla		                PLA
.3a4358	08		php		            PHP
.3a4359	c2 20		rep #$20	            REP #$20
.3a435b	48		pha		            PHA
.3a435c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a435f	5b		tcd		            TCD
.3a4360	68		pla		            PLA
.3a4361	28		plp		            PLP
.3a4362	e2 20		sep #$20	            SEP #$20
.3a4364	a9 06		lda #$06	            LDA #ERR_NOLINE
.3a4366	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a436a	c2 20		rep #$20	            REP #$20
.3a436c	29 ff 00	and #$00ff	            AND #$00FF
.3a436f	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4372	e2 20		sep #$20	            SEP #$20
.3a4374	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4377					S_RETURN
.3a4377	08		php		                PHP
.3a4378	c2 30		rep #$30	            REP #$30
.3a437a	a5 31		lda $0831	                LDA GOSUBDEPTH              ; Check that there is at least on GOSUB on the stack
.3a437c	f0 1e		beq $3a439c	                BEQ underflow               ; No? It's a stack underflow error
.3a437e	20 04 1e	jsr $3a1e04	            JSR PLRETURN
.3a4381	85 00		sta $0800	                STA BIP
.3a4383	20 04 1e	jsr $3a1e04	            JSR PLRETURN
.3a4386	85 02		sta $0802	                STA BIP+2
.3a4388	20 04 1e	jsr $3a1e04	            JSR PLRETURN
.3a438b	85 1a		sta $081a	                STA CURLINE
.3a438d	20 04 1e	jsr $3a1e04	            JSR PLRETURN
.3a4390	85 1c		sta $081c	                STA CURLINE+2
.3a4392	c6 31		dec $0831	                DEC GOSUBDEPTH              ; Indicate we've popped that GOSUB off the stack
.3a4394	e2 20		sep #$20	            SEP #$20
.3a4396	a9 03		lda #$03	                LDA #EXEC_RETURN
.3a4398	85 dc		sta $08dc	                STA EXECACTION
.3a439a	28		plp		                PLP
.3a439b	60		rts		            RTS
.3a439c					underflow
.3a439c	08		php		            PHP
.3a439d	c2 20		rep #$20	            REP #$20
.3a439f	48		pha		            PHA
.3a43a0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a43a3	5b		tcd		            TCD
.3a43a4	68		pla		            PLA
.3a43a5	28		plp		            PLP
.3a43a6	e2 20		sep #$20	            SEP #$20
.3a43a8	a9 07		lda #$07	            LDA #ERR_STACKUNDER
.3a43aa	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a43ae	c2 20		rep #$20	            REP #$20
.3a43b0	29 ff 00	and #$00ff	            AND #$00FF
.3a43b3	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a43b6	e2 20		sep #$20	            SEP #$20
.3a43b8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a43bb					S_IF
.3a43bb	08		php		                PHP
.3a43bc	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a43bf	20 df 05	jsr $3a05df	            JSR IS_ARG1_Z
.3a43c2	f0 1c		beq $3a43e0	                BEQ is_false                ; If so, handle the FALSE case
.3a43c4	e2 20		sep #$20	            SEP #$20
.3a43c6	a9 97		lda #$97	                LDA #TOK_THEN               ; Verify that the next token is THEN and eat it
.3a43c8	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a43cb	20 9d 08	jsr $3a089d	            JSR PARSEINT
.3a43ce	20 df 05	jsr $3a05df	            JSR IS_ARG1_Z
.3a43d1	f0 12		beq $3a43e5	                BEQ syntax_err              ; If not, we have a syntax error
.3a43d3	20 da 23	jsr $3a23da	            JSR FINDLINE
.3a43d6	90 2c		bcc $3a4404	                BCC not_found               ; If not found... LINE NOT FOUND error
.3a43d8	e2 20		sep #$20	            SEP #$20
.3a43da	a9 02		lda #$02	                LDA #EXEC_GOTO
.3a43dc	85 dc		sta $08dc	                STA EXECACTION
.3a43de	80 03		bra $3a43e3	                BRA done
.3a43e0					is_false
.3a43e0	20 1f 21	jsr $3a211f	            JSR SKIPSTMT
.3a43e3	28		plp		done            PLP
.3a43e4	60		rts		            RTS
.3a43e5					syntax_err
.3a43e5	08		php		            PHP
.3a43e6	c2 20		rep #$20	            REP #$20
.3a43e8	48		pha		            PHA
.3a43e9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a43ec	5b		tcd		            TCD
.3a43ed	68		pla		            PLA
.3a43ee	28		plp		            PLP
.3a43ef	e2 20		sep #$20	            SEP #$20
.3a43f1	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a43f3	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a43f7	c2 20		rep #$20	            REP #$20
.3a43f9	29 ff 00	and #$00ff	            AND #$00FF
.3a43fc	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a43ff	e2 20		sep #$20	            SEP #$20
.3a4401	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4404					not_found
.3a4404	08		php		            PHP
.3a4405	c2 20		rep #$20	            REP #$20
.3a4407	48		pha		            PHA
.3a4408	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a440b	5b		tcd		            TCD
.3a440c	68		pla		            PLA
.3a440d	28		plp		            PLP
.3a440e	e2 20		sep #$20	            SEP #$20
.3a4410	a9 06		lda #$06	            LDA #ERR_NOLINE
.3a4412	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4416	c2 20		rep #$20	            REP #$20
.3a4418	29 ff 00	and #$00ff	            AND #$00FF
.3a441b	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a441e	e2 20		sep #$20	            SEP #$20
.3a4420	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4423					S_END
.3a4423	08		php		                PHP
.3a4424	e2 20		sep #$20	            SEP #$20
.3a4426	a9 01		lda #$01	                LDA #EXEC_STOP
.3a4428	85 dc		sta $08dc	                STA EXECACTION
.3a442a	28		plp		                PLP
.3a442b	60		rts		            RTS
.3a442c					S_GOTO
.3a442c	08		php		                PHP
.3a442d	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a4430	20 9d 08	jsr $3a089d	            JSR PARSEINT
.3a4433	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.3a4435	f0 0d		beq $3a4444	                BEQ syntax_err              ; If 0, no number was found... syntax error
.3a4437	20 da 23	jsr $3a23da	            JSR FINDLINE
.3a443a	90 27		bcc $3a4463	                BCC not_found               ; If not found... LINE NOT FOUND error
.3a443c	e2 20		sep #$20	            SEP #$20
.3a443e	a9 02		lda #$02	                LDA #EXEC_GOTO
.3a4440	85 dc		sta $08dc	                STA EXECACTION
.3a4442	28		plp		                PLP
.3a4443	60		rts		            RTS
.3a4444					syntax_err
.3a4444	08		php		            PHP
.3a4445	c2 20		rep #$20	            REP #$20
.3a4447	48		pha		            PHA
.3a4448	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a444b	5b		tcd		            TCD
.3a444c	68		pla		            PLA
.3a444d	28		plp		            PLP
.3a444e	e2 20		sep #$20	            SEP #$20
.3a4450	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4452	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4456	c2 20		rep #$20	            REP #$20
.3a4458	29 ff 00	and #$00ff	            AND #$00FF
.3a445b	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a445e	e2 20		sep #$20	            SEP #$20
.3a4460	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4463					not_found
.3a4463	08		php		            PHP
.3a4464	c2 20		rep #$20	            REP #$20
.3a4466	48		pha		            PHA
.3a4467	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a446a	5b		tcd		            TCD
.3a446b	68		pla		            PLA
.3a446c	28		plp		            PLP
.3a446d	e2 20		sep #$20	            SEP #$20
.3a446f	a9 06		lda #$06	            LDA #ERR_NOLINE
.3a4471	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4475	c2 20		rep #$20	            REP #$20
.3a4477	29 ff 00	and #$00ff	            AND #$00FF
.3a447a	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a447d	e2 20		sep #$20	            SEP #$20
.3a447f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4482					S_CLR
.3a4482	20 48 19	jsr $3a1948	            JSR INITEVALSP
.3a4485	20 68 10	jsr $3a1068	            JSR INITHEAP
.3a4488	20 82 50	jsr $3a5082	            JSR INITVARS
.3a448b	60		rts		            RTS
.3a448c					S_LET
.3a448c	08		php		                PHP
.3a448d	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.3a448f	10 03		bpl $3a4494	                BPL get_name        ; If it's not a token, try to find the variable name
.3a4491	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4494					get_name
.3a4494	20 82 53	jsr $3a5382	            JSR VAR_FINDNAME
.3a4497	b0 03		bcs $3a449c	                BCS check_array     ; If we didn't find a name, thrown an error
.3a4499	4c 03 45	jmp $3a4503	                JMP syntax_err
.3a449c					check_array
.3a449c	e2 20		sep #$20	            SEP #$20
.3a449e	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Save the variable name for later
.3a44a0	48		pha		                PHA                 ; (it will get over-written by variable references)
.3a44a1	a5 e9		lda $08e9	                LDA TOFIND+2
.3a44a3	48		pha		                PHA
.3a44a4	a5 e8		lda $08e8	                LDA TOFIND+1
.3a44a6	48		pha		                PHA
.3a44a7	a5 e7		lda $08e7	                LDA TOFIND
.3a44a9	48		pha		                PHA
.3a44aa	20 3b 22	jsr $3a223b	            JSR PEEK_TOK
.3a44ad	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it a "("
.3a44af	d0 0e		bne $3a44bf	                BNE get_value       ; No: it's a scalar assignment, look for the "="
.3a44b1	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a44b3	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a44b6	a9 00		lda #$00	                LDA #0
.3a44b8	8f 00 4d 00	sta $004d00	                STA @l ARRIDXBUF    ; Blank out the array index buffer
.3a44bc	20 ca 1a	jsr $3a1aca	            JSR ARR_GETIDX
.3a44bf					get_value
.3a44bf	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a44c2	e2 20		sep #$20	            SEP #$20
.3a44c4	a7 00		lda [$0800]	                LDA [BIP]
.3a44c6	c9 8a		cmp #$8a	                CMP #TOK_EQ
.3a44c8	f0 03		beq $3a44cd	                BEQ found_eq        ; If not found: signal an syntax error
.3a44ca	4c 03 45	jmp $3a4503	                JMP syntax_err
.3a44cd					found_eq
.3a44cd	20 da 20	jsr $3a20da	            JSR INCBIP
.3a44d0	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a44d3	68		pla		                PLA                 ; Restore the variable name
.3a44d4	85 e7		sta $08e7	                STA TOFIND
.3a44d6	68		pla		                PLA
.3a44d7	85 e8		sta $08e8	                STA TOFIND+1
.3a44d9	68		pla		                PLA
.3a44da	85 e9		sta $08e9	                STA TOFIND+2
.3a44dc	68		pla		                PLA
.3a44dd	85 ea		sta $08ea	                STA TOFINDTYPE
.3a44df	29 80		and #$80	                AND #$80            ; Is it an array we're setting?
.3a44e1	f0 1b		beq $3a44fe	                BEQ set_scalar      ; No: do a scalar variable set
.3a44e3	20 f5 50	jsr $3a50f5	            JSR VAR_FIND
.3a44e6	90 3a		bcc $3a4522	                BCC notfound_err
.3a44e8	c2 20		rep #$20	            REP #$20
.3a44ea	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.3a44ed	b7 08		lda [$0808],y	                LDA [INDEX],Y       ; Save the pointer to the array to CURRBLOCK
.3a44ef	85 c0		sta $08c0	                STA CURRBLOCK
.3a44f1	e2 20		sep #$20	            SEP #$20
.3a44f3	c8		iny		                INY
.3a44f4	c8		iny		                INY
.3a44f5	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a44f7	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a44f9	20 ec 67	jsr $3a67ec	            JSR ARR_SET
.3a44fc	80 03		bra $3a4501	                BRA done            ; and we're finished!
.3a44fe					set_scalar
.3a44fe	20 e5 52	jsr $3a52e5	            JSR VAR_SET
.3a4501					done
.3a4501	28		plp		                PLP
.3a4502	60		rts		            RTS
.3a4503					syntax_err
.3a4503	08		php		            PHP
.3a4504	c2 20		rep #$20	            REP #$20
.3a4506	48		pha		            PHA
.3a4507	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a450a	5b		tcd		            TCD
.3a450b	68		pla		            PLA
.3a450c	28		plp		            PLP
.3a450d	e2 20		sep #$20	            SEP #$20
.3a450f	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4511	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4515	c2 20		rep #$20	            REP #$20
.3a4517	29 ff 00	and #$00ff	            AND #$00FF
.3a451a	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a451d	e2 20		sep #$20	            SEP #$20
.3a451f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4522					notfound_err
.3a4522	08		php		            PHP
.3a4523	c2 20		rep #$20	            REP #$20
.3a4525	48		pha		            PHA
.3a4526	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4529	5b		tcd		            TCD
.3a452a	68		pla		            PLA
.3a452b	28		plp		            PLP
.3a452c	e2 20		sep #$20	            SEP #$20
.3a452e	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.3a4530	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4534	c2 20		rep #$20	            REP #$20
.3a4536	29 ff 00	and #$00ff	            AND #$00FF
.3a4539	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a453c	e2 20		sep #$20	            SEP #$20
.3a453e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4541					S_PRINT
.3a4541	08		php		                PHP
.3a4542	e2 20		sep #$20	            SEP #$20
.3a4544	20 3b 22	jsr $3a223b	            JSR PEEK_TOK
.3a4547	c9 00		cmp #$00	                CMP #0              ; Is it EOL or :?
.3a4549	f0 6d		beq $3a45b8	                BEQ pr_nl_exit      ; Yes: just print return
.3a454b					pr_loop
.3a454b	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a454e	e2 20		sep #$20	            SEP #$20
.3a4550	a5 27		lda $0827	                LDA ARGTYPE1        ; Get the type of the result
.3a4552	c9 ff		cmp #$ff	                CMP #TYPE_NAV       ; Is is NAV?
.3a4554	f0 1b		beq $3a4571	                BEQ check_nl        ; Yes: we are probably just printing a newline
.3a4556	c9 02		cmp #$02	                CMP #TYPE_STRING    ; Is it a string?
.3a4558	d0 05		bne $3a455f	                BNE check_int       ; No: check to see if it's an integer
.3a455a	20 bd 45	jsr $3a45bd	            JSR PR_STRING
.3a455d	80 12		bra $3a4571	                BRA check_nl
.3a455f	c9 00		cmp #$00	check_int       CMP #TYPE_INTEGER   ; Is it an integer?
.3a4561	d0 05		bne $3a4568	                BNE check_float     ; No: check to see if it is a float
.3a4563	20 db 45	jsr $3a45db	            JSR PR_INTEGER
.3a4566	80 09		bra $3a4571	                BRA check_nl
.3a4568	c9 01		cmp #$01	check_float     CMP #TYPE_FLOAT     ; Is it a float?
.3a456a	d0 4f		bne $3a45bb	                BNE done            ; No: just quit
.3a456c	20 ee 45	jsr $3a45ee	            JSR PR_FLOAT
.3a456f	80 00		bra $3a4571	                BRA check_nl
.3a4571					check_nl
.3a4571	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a4574	a7 00		lda [$0800]	                LDA [BIP]
.3a4576	f0 40		beq $3a45b8	                BEQ pr_nl_exit      ; If it's nul, print a newline and return
.3a4578	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.3a457a	f0 3c		beq $3a45b8	                BEQ pr_nl_exit      ; print a newline and return
.3a457c	c9 2c		cmp #$2c	                CMP #','            ; If it's a comma
.3a457e	f0 23		beq $3a45a3	                BEQ pr_comma        ; Print a TAB and try another expression
.3a4580	c9 3b		cmp #$3b	                CMP #';'            ; If it's a semicolon...
.3a4582	f0 24		beq $3a45a8	                BEQ is_more         ; Print nothing, and try another expression
.3a4584	08		php		            PHP
.3a4585	c2 20		rep #$20	            REP #$20
.3a4587	48		pha		            PHA
.3a4588	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a458b	5b		tcd		            TCD
.3a458c	68		pla		            PLA
.3a458d	28		plp		            PLP
.3a458e	e2 20		sep #$20	            SEP #$20
.3a4590	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4592	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4596	c2 20		rep #$20	            REP #$20
.3a4598	29 ff 00	and #$00ff	            AND #$00FF
.3a459b	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a459e	e2 20		sep #$20	            SEP #$20
.3a45a0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a45a3	a9 09		lda #$09	pr_comma        LDA #CHAR_TAB       ; Print a TAB
.3a45a5	20 18 00	jsr $3a0018	            JSR PRINTC
.3a45a8					is_more
.3a45a8	20 da 20	jsr $3a20da	            JSR INCBIP
.3a45ab	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a45ae	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.3a45b0	f0 09		beq $3a45bb	                BEQ done            ; If it's NULL, return without printing a newline
.3a45b2	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.3a45b4	f0 05		beq $3a45bb	                BEQ done            ; ... return without printing a newline
.3a45b6	80 93		bra $3a454b	                BRA pr_loop         ; Otherwise, we should have another expression, try to handle it
.3a45b8					pr_nl_exit
.3a45b8	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a45bb	28		plp		done            PLP
.3a45bc	60		rts		            RTS
.3a45bd					PR_STRING
.3a45bd	08		php		                PHP
.3a45be	8b		phb		                PHB
.3a45bf	08		php		            PHP
.3a45c0	c2 20		rep #$20	            REP #$20
.3a45c2	48		pha		            PHA
.3a45c3	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a45c6	5b		tcd		            TCD
.3a45c7	68		pla		            PLA
.3a45c8	28		plp		            PLP
.3a45c9	e2 20		sep #$20	            SEP #$20
.3a45cb	a0 00 00	ldy #$0000	start_print     LDY #0
.3a45ce	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y
.3a45d0	f0 06		beq $3a45d8	                BEQ done
.3a45d2	20 18 00	jsr $3a0018	            JSR PRINTC
.3a45d5	c8		iny		                INY
.3a45d6	80 f6		bra $3a45ce	                BRA loop
.3a45d8	ab		plb		done            PLB
.3a45d9	28		plp		                PLP
.3a45da	60		rts		            RTS
.3a45db					PR_INTEGER
.3a45db	08		php		                PHP
.3a45dc	c2 20		rep #$20	            REP #$20
.3a45de	20 1d 15	jsr $3a151d	            JSR ITOS
.3a45e1	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.3a45e3	85 23		sta $0823	                STA ARGUMENT1
.3a45e5	a5 18		lda $0818	                LDA STRPTR+2
.3a45e7	85 25		sta $0825	                STA ARGUMENT1+2
.3a45e9	20 bd 45	jsr $3a45bd	            JSR PR_STRING
.3a45ec	28		plp		                PLP
.3a45ed	60		rts		            RTS
.3a45ee					PR_FLOAT
.3a45ee	08		php		                PHP
.3a45ef	20 4b 5d	jsr $3a5d4b	            JSR FTOS
.3a45f2	c2 20		rep #$20	            REP #$20
.3a45f4	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.3a45f6	85 23		sta $0823	                STA ARGUMENT1
.3a45f8	a5 18		lda $0818	                LDA STRPTR+2
.3a45fa	85 25		sta $0825	                STA ARGUMENT1+2
.3a45fc	20 bd 45	jsr $3a45bd	            JSR PR_STRING
.3a45ff	28		plp		                PLP
.3a4600	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\functions.s


;******  Processing file: src\C256/functions_c256.s

.3a4601					BCD2STR
.3a4601	08		php		            PHP
.3a4602	e2 20		sep #$20	            SEP #$20
.3a4604	85 b5		sta $08b5	            STA SAVE_A
.3a4606	4a		lsr a		            LSR A
.3a4607	4a		lsr a		            LSR A
.3a4608	4a		lsr a		            LSR A
.3a4609	4a		lsr a		            LSR A
.3a460a	29 0f		and #$0f	            AND #$0F
.3a460c	18		clc		            CLC
.3a460d	69 30		adc #$30	            ADC #'0'
.3a460f	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a4611	c8		iny		            INY
.3a4612	a5 b5		lda $08b5	            LDA SAVE_A
.3a4614	29 0f		and #$0f	            AND #$0F
.3a4616	18		clc		            CLC
.3a4617	69 30		adc #$30	            ADC #'0'
.3a4619	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a461b	c8		iny		            INY
.3a461c	28		plp		            PLP
.3a461d	60		rts		            RTS
.3a461e					F_GETDATE
.3a461e	e2 20		sep #$20	            SEP #$20
.3a4620	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4622	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4625	08		php		            PHP
.3a4626	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4629	e2 20		sep #$20	            SEP #$20
.3a462b	c2 10		rep #$10	            REP #$10
.3a462d	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.3a4631	09 08		ora #$08	            ORA #%00001000
.3a4633	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.3a4637	20 be 14	jsr $3a14be	            JSR TEMPSTRING
.3a463a	a0 00 00	ldy #$0000	            LDY #0
.3a463d	af 06 08 af	lda $af0806	            LDA @lRTC_DAY           ; Write the day of the month
.3a4641	20 01 46	jsr $3a4601	            JSR BCD2STR
.3a4644	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.3a4646	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a4648	c8		iny		            INY
.3a4649	af 09 08 af	lda $af0809	            LDA @lRTC_MONTH         ; Write the month
.3a464d	20 01 46	jsr $3a4601	            JSR BCD2STR
.3a4650	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.3a4652	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a4654	c8		iny		            INY
.3a4655	af 0f 08 af	lda $af080f	            LDA @lRTC_CENTURY       ; Write the year
.3a4659	20 01 46	jsr $3a4601	            JSR BCD2STR
.3a465c	af 0a 08 af	lda $af080a	            LDA @lRTC_YEAR          ; Write the year
.3a4660	20 01 46	jsr $3a4601	            JSR BCD2STR
.3a4663	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.3a4665	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a4667	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.3a466b	29 f7		and #$f7	            AND #%11110111
.3a466d	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.3a4671	c2 20		rep #$20	            REP #$20
.3a4673	a5 16		lda $0816	            LDA STRPTR
.3a4675	85 23		sta $0823	            STA ARGUMENT1
.3a4677	a5 18		lda $0818	            LDA STRPTR+2
.3a4679	85 25		sta $0825	            STA ARGUMENT1+2
.3a467b	e2 20		sep #$20	            SEP #$20
.3a467d	a9 02		lda #$02	            LDA #TYPE_STRING
.3a467f	85 27		sta $0827	            STA ARGTYPE1
.3a4681	28		plp		            PLP
.3a4682	e2 20		sep #$20	            SEP #$20
.3a4684	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4687	60		rts		            RTS
.3a4688					F_GETTIME
.3a4688	e2 20		sep #$20	            SEP #$20
.3a468a	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a468c	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a468f	08		php		            PHP
.3a4690	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4693	e2 20		sep #$20	            SEP #$20
.3a4695	c2 10		rep #$10	            REP #$10
.3a4697	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.3a469b	09 08		ora #$08	            ORA #%00001000
.3a469d	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.3a46a1	20 be 14	jsr $3a14be	            JSR TEMPSTRING
.3a46a4	a0 00 00	ldy #$0000	            LDY #0
.3a46a7	af 04 08 af	lda $af0804	            LDA @lRTC_HRS           ; Write the hour
.3a46ab	29 7f		and #$7f	            AND #$7F                ; Trim out the AM/PM indicator
.3a46ad	20 01 46	jsr $3a4601	            JSR BCD2STR
.3a46b0	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.3a46b2	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a46b4	c8		iny		            INY
.3a46b5	af 02 08 af	lda $af0802	            LDA @lRTC_MIN           ; Write the minute
.3a46b9	20 01 46	jsr $3a4601	            JSR BCD2STR
.3a46bc	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.3a46be	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a46c0	c8		iny		            INY
.3a46c1	af 00 08 af	lda $af0800	            LDA @lRTC_SEC           ; Write the second
.3a46c5	20 01 46	jsr $3a4601	            JSR BCD2STR
.3a46c8	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.3a46ca	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a46cc	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.3a46d0	29 f7		and #$f7	            AND #%11110111
.3a46d2	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.3a46d6	c2 20		rep #$20	            REP #$20
.3a46d8	a5 16		lda $0816	            LDA STRPTR
.3a46da	85 23		sta $0823	            STA ARGUMENT1
.3a46dc	a5 18		lda $0818	            LDA STRPTR+2
.3a46de	85 25		sta $0825	            STA ARGUMENT1+2
.3a46e0	e2 20		sep #$20	            SEP #$20
.3a46e2	a9 02		lda #$02	            LDA #TYPE_STRING
.3a46e4	85 27		sta $0827	            STA ARGTYPE1
.3a46e6	28		plp		            PLP
.3a46e7	e2 20		sep #$20	            SEP #$20
.3a46e9	20 da 20	jsr $3a20da	            JSR INCBIP
.3a46ec	60		rts		            RTS
.3a46ed					FN_RND
.3a46ed	e2 20		sep #$20	            SEP #$20
.3a46ef	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a46f1	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a46f4	08		php		            PHP
.3a46f5	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a46f8	e2 20		sep #$20	            SEP #$20
.3a46fa	a9 01		lda #$01	            LDA #TYPE_FLOAT             ; We'll return a floating point number
.3a46fc	85 27		sta $0827	            STA ARGTYPE1
.3a46fe	a9 03		lda #$03	            LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.3a4700	8f 00 e2 af	sta $afe200	            STA @l FP_MATH_CTRL0        ; Expect fixed point numbers
.3a4704	a9 01		lda #$01	            LDA #FP_OUT_DIV             ; Set us to do a division
.3a4706	8f 01 e2 af	sta $afe201	            STA @l FP_MATH_CTRL1
.3a470a	c2 30		rep #$30	            REP #$30
.3a470c	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get a random 16-bits
.3a4710	8f 08 e2 af	sta $afe208	            STA @l FP_MATH_INPUT0_LL    ; Send them to the FP unit
.3a4714	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get another random 16-bits
.3a4718	29 ff 7f	and #$7fff	            AND #$7FFF                  ; Make sure it's positive
.3a471b	8f 0a e2 af	sta $afe20a	            STA @l FP_MATH_INPUT0_LL+2  ; Send them to the FP unit
.3a471f	a9 ff ff	lda #$ffff	            LDA #$FFFF                  ; Get the maximum value
.3a4722	8f 0c e2 af	sta $afe20c	            STA @l FP_MATH_INPUT1_LL    ; Send it to the FP unit
.3a4726	a9 ff 7f	lda #$7fff	            LDA #$7FFF
.3a4729	8f 0e e2 af	sta $afe20e	            STA @l FP_MATH_INPUT1_LL+2
.3a472d	ea		nop		            NOP
.3a472e	ea		nop		            NOP
.3a472f	ea		nop		            NOP
.3a4730	af 08 e2 af	lda $afe208	            LDA @l FP_MATH_OUTPUT_FP_LL     ; Get the normalized result
.3a4734	85 23		sta $0823	            STA ARGUMENT1
.3a4736	af 0a e2 af	lda $afe20a	            LDA @l FP_MATH_OUTPUT_FP_LL+2
.3a473a	85 25		sta $0825	            STA ARGUMENT1+2
.3a473c	28		plp		            PLP
.3a473d	e2 20		sep #$20	            SEP #$20
.3a473f	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4742	60		rts		            RTS

;******  Return to file: src\functions.s

.3a4743					FN_MID
.3a4743	e2 20		sep #$20	            SEP #$20
.3a4745	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4747	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a474a	08		php		                PHP
.3a474b	c2 30		rep #$30	            REP #$30
.3a474d	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4750	20 a8 06	jsr $3a06a8	            JSR ASS_ARG1_STR
.3a4753					save_string
.3a4753	c2 20		rep #$20	            REP #$20
.3a4755	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.3a4757	48		pha		                PHA
.3a4758	a5 23		lda $0823	                LDA ARGUMENT1
.3a475a	48		pha		                PHA
.3a475b	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a475e	e2 20		sep #$20	            SEP #$20
.3a4760	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.3a4762	c9 2c		cmp #$2c	                CMP #','
.3a4764	f0 03		beq $3a4769	                BEQ skip_comma1
.3a4766	4c ba 47	jmp $3a47ba	                JMP syntax_err
.3a4769					skip_comma1
.3a4769	20 da 20	jsr $3a20da	            JSR INCBIP
.3a476c	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a476f	20 d2 06	jsr $3a06d2	            JSR ASS_ARG1_INT16
.3a4772	c2 20		rep #$20	            REP #$20
.3a4774	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the index
.3a4776	48		pha		                PHA
.3a4777	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a477a	e2 20		sep #$20	            SEP #$20
.3a477c	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.3a477e	c9 2c		cmp #$2c	                CMP #','
.3a4780	f0 03		beq $3a4785	                BEQ skip_comma2
.3a4782	4c ba 47	jmp $3a47ba	                JMP syntax_err
.3a4785					skip_comma2
.3a4785	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4788	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a478b	20 d2 06	jsr $3a06d2	            JSR ASS_ARG1_INT16
.3a478e	c2 20		rep #$20	            REP #$20
.3a4790	a5 23		lda $0823	            LDA ARGUMENT1
.3a4792	85 8f		sta $088f	            STA MCOUNT
.3a4794	e2 20		sep #$20	            SEP #$20
.3a4796	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a4798	85 91		sta $0891	            STA MCOUNT+2
.3a479a	c2 20		rep #$20	            REP #$20
.3a479c	68		pla		                PLA                         ; Restore index
.3a479d	85 29		sta $0829	                STA ARGUMENT2               ; ... to ARGUMENT2
.3a479f	a9 00 00	lda #$0000	                LDA #0
.3a47a2	85 2b		sta $082b	                STA ARGUMENT2+2
.3a47a4	68		pla		                PLA                         ; Restore string
.3a47a5	85 23		sta $0823	                STA ARGUMENT1               ; ... to ARGUMENT1
.3a47a7	68		pla		                PLA
.3a47a8	85 25		sta $0825	                STA ARGUMENT1+2
.3a47aa	e2 20		sep #$20	            SEP #$20
.3a47ac	a9 02		lda #$02	            LDA #<TYPE_STRING
.3a47ae	85 27		sta $0827	            STA ARGTYPE1
.3a47b0	20 16 17	jsr $3a1716	            JSR STRSUBSTR
.3a47b3					done
.3a47b3	e2 20		sep #$20	            SEP #$20
.3a47b5	20 da 20	jsr $3a20da	            JSR INCBIP
.3a47b8	28		plp		                PLP
.3a47b9	60		rts		            RTS
.3a47ba					syntax_err
.3a47ba	08		php		            PHP
.3a47bb	c2 20		rep #$20	            REP #$20
.3a47bd	48		pha		            PHA
.3a47be	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a47c1	5b		tcd		            TCD
.3a47c2	68		pla		            PLA
.3a47c3	28		plp		            PLP
.3a47c4	e2 20		sep #$20	            SEP #$20
.3a47c6	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a47c8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a47cc	c2 20		rep #$20	            REP #$20
.3a47ce	29 ff 00	and #$00ff	            AND #$00FF
.3a47d1	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a47d4	e2 20		sep #$20	            SEP #$20
.3a47d6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a47d9					range_err
.3a47d9	08		php		            PHP
.3a47da	c2 20		rep #$20	            REP #$20
.3a47dc	48		pha		            PHA
.3a47dd	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a47e0	5b		tcd		            TCD
.3a47e1	68		pla		            PLA
.3a47e2	28		plp		            PLP
.3a47e3	e2 20		sep #$20	            SEP #$20
.3a47e5	a9 09		lda #$09	            LDA #ERR_RANGE
.3a47e7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a47eb	c2 20		rep #$20	            REP #$20
.3a47ed	29 ff 00	and #$00ff	            AND #$00FF
.3a47f0	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a47f3	e2 20		sep #$20	            SEP #$20
.3a47f5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a47f8					FN_RIGHT
.3a47f8	e2 20		sep #$20	            SEP #$20
.3a47fa	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a47fc	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a47ff	08		php		                PHP
.3a4800	c2 30		rep #$30	            REP #$30
.3a4802	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4805	e2 20		sep #$20	            SEP #$20
.3a4807	a5 27		lda $0827	                LDA ARGTYPE1
.3a4809	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a480b	f0 03		beq $3a4810	                BEQ save_string
.3a480d	4c 7c 48	jmp $3a487c	                JMP type_mismatch           ; Type mismatch if it's not a string
.3a4810					save_string
.3a4810	c2 20		rep #$20	            REP #$20
.3a4812	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.3a4814	48		pha		                PHA
.3a4815	a5 23		lda $0823	                LDA ARGUMENT1
.3a4817	48		pha		                PHA
.3a4818	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a481b	e2 20		sep #$20	            SEP #$20
.3a481d	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.3a481f	c9 2c		cmp #$2c	                CMP #','
.3a4821	f0 03		beq $3a4826	                BEQ skip_comma
.3a4823	4c 9b 48	jmp $3a489b	                JMP syntax_err
.3a4826					skip_comma
.3a4826	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4829	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a482c	e2 20		sep #$20	            SEP #$20
.3a482e	a5 27		lda $0827	                LDA ARGTYPE1
.3a4830	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4832	d0 48		bne $3a487c	                BNE type_mismatch           ; Type mismatch if it's not an integer
.3a4834	c2 20		rep #$20	            REP #$20
.3a4836	a5 23		lda $0823	            LDA ARGUMENT1
.3a4838	85 8f		sta $088f	            STA MCOUNT
.3a483a	c2 20		rep #$20	            REP #$20
.3a483c	68		pla		                PLA                         ; Recover the string pointer
.3a483d	85 23		sta $0823	                STA ARGUMENT1
.3a483f	68		pla		                PLA
.3a4840	85 25		sta $0825	                STA ARGUMENT1+2
.3a4842	e2 20		sep #$20	            SEP #$20
.3a4844	a9 02		lda #$02	            LDA #<TYPE_STRING
.3a4846	85 27		sta $0827	            STA ARGTYPE1
.3a4848	e2 20		sep #$20	            SEP #$20
.3a484a	a0 00 00	ldy #$0000	                LDY #0
.3a484d	b7 23		lda [$0823],y	count_loop      LDA [ARGUMENT1],Y
.3a484f	f0 03		beq $3a4854	                BEQ count_done
.3a4851	c8		iny		                INY
.3a4852	80 f9		bra $3a484d	                BRA count_loop
.3a4854					count_done
.3a4854	c2 20		rep #$20	            REP #$20
.3a4856	98		tya		                TYA                         ; ARGUMENT2 := LENGTH - MCOUNT
.3a4857	38		sec		                SEC
.3a4858	e5 8f		sbc $088f	                SBC MCOUNT
.3a485a	30 09		bmi $3a4865	                BMI index0                  ; if ARGUMENT2 < 0, set ARGUMENT2 := 0
.3a485c	85 29		sta $0829	                STA ARGUMENT2
.3a485e	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT2[23..16] := 0
.3a4861	85 2b		sta $082b	                STA ARGUMENT2+2
.3a4863	80 07		bra $3a486c	                BRA slice
.3a4865	a9 00 00	lda #$0000	index0          LDA #0                      ; 0 is the floor for the index
.3a4868	85 29		sta $0829	                STA ARGUMENT2
.3a486a	85 2b		sta $082b	                STA ARGUMENT2+2
.3a486c					slice
.3a486c	e2 20		sep #$20	            SEP #$20
.3a486e	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.3a4870	85 2d		sta $082d	            STA ARGTYPE2
.3a4872	20 16 17	jsr $3a1716	            JSR STRSUBSTR
.3a4875					done
.3a4875	e2 20		sep #$20	            SEP #$20
.3a4877	20 da 20	jsr $3a20da	            JSR INCBIP
.3a487a	28		plp		                PLP
.3a487b	60		rts		            RTS
.3a487c					type_mismatch
.3a487c	08		php		            PHP
.3a487d	c2 20		rep #$20	            REP #$20
.3a487f	48		pha		            PHA
.3a4880	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4883	5b		tcd		            TCD
.3a4884	68		pla		            PLA
.3a4885	28		plp		            PLP
.3a4886	e2 20		sep #$20	            SEP #$20
.3a4888	a9 04		lda #$04	            LDA #ERR_TYPE
.3a488a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a488e	c2 20		rep #$20	            REP #$20
.3a4890	29 ff 00	and #$00ff	            AND #$00FF
.3a4893	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4896	e2 20		sep #$20	            SEP #$20
.3a4898	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a489b					syntax_err
.3a489b	08		php		            PHP
.3a489c	c2 20		rep #$20	            REP #$20
.3a489e	48		pha		            PHA
.3a489f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a48a2	5b		tcd		            TCD
.3a48a3	68		pla		            PLA
.3a48a4	28		plp		            PLP
.3a48a5	e2 20		sep #$20	            SEP #$20
.3a48a7	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a48a9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a48ad	c2 20		rep #$20	            REP #$20
.3a48af	29 ff 00	and #$00ff	            AND #$00FF
.3a48b2	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a48b5	e2 20		sep #$20	            SEP #$20
.3a48b7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a48ba					range_err
.3a48ba	08		php		            PHP
.3a48bb	c2 20		rep #$20	            REP #$20
.3a48bd	48		pha		            PHA
.3a48be	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a48c1	5b		tcd		            TCD
.3a48c2	68		pla		            PLA
.3a48c3	28		plp		            PLP
.3a48c4	e2 20		sep #$20	            SEP #$20
.3a48c6	a9 09		lda #$09	            LDA #ERR_RANGE
.3a48c8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a48cc	c2 20		rep #$20	            REP #$20
.3a48ce	29 ff 00	and #$00ff	            AND #$00FF
.3a48d1	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a48d4	e2 20		sep #$20	            SEP #$20
.3a48d6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a48d9					FN_LEFT
.3a48d9	e2 20		sep #$20	            SEP #$20
.3a48db	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a48dd	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a48e0	08		php		                PHP
.3a48e1	c2 30		rep #$30	            REP #$30
.3a48e3	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a48e6	e2 20		sep #$20	            SEP #$20
.3a48e8	a5 27		lda $0827	                LDA ARGTYPE1
.3a48ea	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a48ec	f0 03		beq $3a48f1	                BEQ save_string
.3a48ee	4c 45 49	jmp $3a4945	                JMP type_mismatch           ; Type mismatch if it's not a string
.3a48f1					save_string
.3a48f1	c2 20		rep #$20	            REP #$20
.3a48f3	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.3a48f5	48		pha		                PHA
.3a48f6	a5 23		lda $0823	                LDA ARGUMENT1
.3a48f8	48		pha		                PHA
.3a48f9	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a48fc	e2 20		sep #$20	            SEP #$20
.3a48fe	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.3a4900	c9 2c		cmp #$2c	                CMP #','
.3a4902	f0 03		beq $3a4907	                BEQ skip_comma
.3a4904	4c 64 49	jmp $3a4964	                JMP syntax_err
.3a4907					skip_comma
.3a4907	20 da 20	jsr $3a20da	            JSR INCBIP
.3a490a	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a490d	e2 20		sep #$20	            SEP #$20
.3a490f	a5 27		lda $0827	                LDA ARGTYPE1
.3a4911	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4913	d0 30		bne $3a4945	                BNE type_mismatch           ; Type mismatch if it's not an integer
.3a4915	c2 20		rep #$20	            REP #$20
.3a4917	a5 23		lda $0823	            LDA ARGUMENT1
.3a4919	85 8f		sta $088f	            STA MCOUNT
.3a491b	c2 20		rep #$20	            REP #$20
.3a491d	a9 00 00	lda #$0000	            LDA #<>0
.3a4920	85 29		sta $0829	            STA ARGUMENT2
.3a4922	a9 00 00	lda #$0000	            LDA #(0 >> 16)
.3a4925	85 2b		sta $082b	            STA ARGUMENT2+2
.3a4927	e2 20		sep #$20	            SEP #$20
.3a4929	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.3a492b	85 2d		sta $082d	            STA ARGTYPE2
.3a492d	c2 20		rep #$20	            REP #$20
.3a492f	68		pla		                PLA                         ; Recover the string pointer
.3a4930	85 23		sta $0823	                STA ARGUMENT1
.3a4932	68		pla		                PLA
.3a4933	85 25		sta $0825	                STA ARGUMENT1+2
.3a4935	e2 20		sep #$20	            SEP #$20
.3a4937	a9 02		lda #$02	            LDA #<TYPE_STRING
.3a4939	85 27		sta $0827	            STA ARGTYPE1
.3a493b	20 16 17	jsr $3a1716	            JSR STRSUBSTR
.3a493e					done
.3a493e	e2 20		sep #$20	            SEP #$20
.3a4940	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4943	28		plp		                PLP
.3a4944	60		rts		            RTS
.3a4945					type_mismatch
.3a4945	08		php		            PHP
.3a4946	c2 20		rep #$20	            REP #$20
.3a4948	48		pha		            PHA
.3a4949	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a494c	5b		tcd		            TCD
.3a494d	68		pla		            PLA
.3a494e	28		plp		            PLP
.3a494f	e2 20		sep #$20	            SEP #$20
.3a4951	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4953	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4957	c2 20		rep #$20	            REP #$20
.3a4959	29 ff 00	and #$00ff	            AND #$00FF
.3a495c	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a495f	e2 20		sep #$20	            SEP #$20
.3a4961	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4964					syntax_err
.3a4964	08		php		            PHP
.3a4965	c2 20		rep #$20	            REP #$20
.3a4967	48		pha		            PHA
.3a4968	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a496b	5b		tcd		            TCD
.3a496c	68		pla		            PLA
.3a496d	28		plp		            PLP
.3a496e	e2 20		sep #$20	            SEP #$20
.3a4970	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4972	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4976	c2 20		rep #$20	            REP #$20
.3a4978	29 ff 00	and #$00ff	            AND #$00FF
.3a497b	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a497e	e2 20		sep #$20	            SEP #$20
.3a4980	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4983					range_err
.3a4983	08		php		            PHP
.3a4984	c2 20		rep #$20	            REP #$20
.3a4986	48		pha		            PHA
.3a4987	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a498a	5b		tcd		            TCD
.3a498b	68		pla		            PLA
.3a498c	28		plp		            PLP
.3a498d	e2 20		sep #$20	            SEP #$20
.3a498f	a9 09		lda #$09	            LDA #ERR_RANGE
.3a4991	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4995	c2 20		rep #$20	            REP #$20
.3a4997	29 ff 00	and #$00ff	            AND #$00FF
.3a499a	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a499d	e2 20		sep #$20	            SEP #$20
.3a499f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a49a2					FN_VAL
.3a49a2	e2 20		sep #$20	            SEP #$20
.3a49a4	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a49a6	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a49a9	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a49ac	c2 10		rep #$10	            REP #$10
.3a49ae	e2 20		sep #$20	            SEP #$20
.3a49b0	a5 27		lda $0827	                LDA ARGTYPE1
.3a49b2	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a49b4	d0 23		bne $3a49d9	                BNE type_mismatch
.3a49b6	c2 20		rep #$20	            REP #$20
.3a49b8	a5 00		lda $0800	                LDA BIP             ; preserve BIP for later
.3a49ba	85 40		sta $0840	                STA SAVEBIP
.3a49bc	a5 02		lda $0802	                LDA BIP+2
.3a49be	85 42		sta $0842	                STA SAVEBIP+2
.3a49c0	a5 23		lda $0823	                LDA ARGUMENT1       ; Temporarily point BIP to the string to parse
.3a49c2	85 00		sta $0800	                STA BIP
.3a49c4	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a49c6	85 02		sta $0802	                STA BIP+2
.3a49c8	20 9d 08	jsr $3a089d	            JSR PARSEINT
.3a49cb	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.3a49cd	85 00		sta $0800	                STA BIP
.3a49cf	a5 42		lda $0842	                LDA SAVEBIP+2
.3a49d1	85 02		sta $0802	                STA BIP+2
.3a49d3	e2 20		sep #$20	            SEP #$20
.3a49d5	20 da 20	jsr $3a20da	            JSR INCBIP
.3a49d8	60		rts		            RTS
.3a49d9					type_mismatch
.3a49d9	08		php		            PHP
.3a49da	c2 20		rep #$20	            REP #$20
.3a49dc	48		pha		            PHA
.3a49dd	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a49e0	5b		tcd		            TCD
.3a49e1	68		pla		            PLA
.3a49e2	28		plp		            PLP
.3a49e3	e2 20		sep #$20	            SEP #$20
.3a49e5	a9 04		lda #$04	            LDA #ERR_TYPE
.3a49e7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a49eb	c2 20		rep #$20	            REP #$20
.3a49ed	29 ff 00	and #$00ff	            AND #$00FF
.3a49f0	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a49f3	e2 20		sep #$20	            SEP #$20
.3a49f5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a49f8					FN_STR
.3a49f8	e2 20		sep #$20	            SEP #$20
.3a49fa	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a49fc	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a49ff	08		php		                PHP
.3a4a00	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4a03	c2 10		rep #$10	            REP #$10
.3a4a05	e2 20		sep #$20	            SEP #$20
.3a4a07	a5 27		lda $0827	                LDA ARGTYPE1
.3a4a09	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4a0b	d0 1a		bne $3a4a27	                BNE type_mismatch
.3a4a0d	20 1d 15	jsr $3a151d	            JSR ITOS
.3a4a10	c2 20		rep #$20	            REP #$20
.3a4a12	a5 16		lda $0816	                LDA STRPTR          ; Prepare the return result
.3a4a14	85 23		sta $0823	                STA ARGUMENT1
.3a4a16	a5 18		lda $0818	                LDA STRPTR+2
.3a4a18	85 25		sta $0825	                STA ARGUMENT1+2
.3a4a1a	e2 20		sep #$20	            SEP #$20
.3a4a1c	a9 02		lda #$02	                LDA #TYPE_STRING
.3a4a1e	85 27		sta $0827	                STA ARGTYPE1
.3a4a20	28		plp		                PLP
.3a4a21	e2 20		sep #$20	            SEP #$20
.3a4a23	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4a26	60		rts		            RTS
.3a4a27					type_mismatch
.3a4a27	08		php		            PHP
.3a4a28	c2 20		rep #$20	            REP #$20
.3a4a2a	48		pha		            PHA
.3a4a2b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4a2e	5b		tcd		            TCD
.3a4a2f	68		pla		            PLA
.3a4a30	28		plp		            PLP
.3a4a31	e2 20		sep #$20	            SEP #$20
.3a4a33	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4a35	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4a39	c2 20		rep #$20	            REP #$20
.3a4a3b	29 ff 00	and #$00ff	            AND #$00FF
.3a4a3e	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4a41	e2 20		sep #$20	            SEP #$20
.3a4a43	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4a46					FN_DEC
.3a4a46	e2 20		sep #$20	            SEP #$20
.3a4a48	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4a4a	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4a4d	08		php		                PHP
.3a4a4e	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4a51	20 a8 06	jsr $3a06a8	            JSR ASS_ARG1_STR
.3a4a54	c2 20		rep #$20	            REP #$20
.3a4a56	64 0c		stz $080c	                STZ SCRATCH
.3a4a58	64 0e		stz $080e	                STZ SCRATCH+2
.3a4a5a	e2 30		sep #$30	            SEP #$30
.3a4a5c	a0 00		ldy #$00	                LDY #0
.3a4a5e	b7 23		lda [$0823],y	skip_loop       LDA [ARGUMENT1],Y
.3a4a60	c9 20		cmp #$20	                CMP #CHAR_SP
.3a4a62	f0 04		beq $3a4a68	                BEQ skip_char
.3a4a64	c9 24		cmp #$24	                CMP #'$'
.3a4a66	d0 03		bne $3a4a6b	                BNE loop
.3a4a68	c8		iny		skip_char       INY
.3a4a69	80 f3		bra $3a4a5e	                BRA skip_loop
.3a4a6b	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y   ; Check the character
.3a4a6d	20 d1 04	jsr $3a04d1	            JSR ISHEX
.3a4a70	90 1e		bcc $3a4a90	                BCC ret_result      ; No: return what we have so far
.3a4a72	c2 20		rep #$20	            REP #$20
.3a4a74	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.3a4a76	26 0e		rol $080e	                ROL SCRATCH+2
.3a4a78	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.3a4a7a	26 0e		rol $080e	                ROL SCRATCH+2
.3a4a7c	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.3a4a7e	26 0e		rol $080e	                ROL SCRATCH+2
.3a4a80	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.3a4a82	26 0e		rol $080e	                ROL SCRATCH+2
.3a4a84	e2 20		sep #$20	            SEP #$20
.3a4a86	20 f2 04	jsr $3a04f2	            JSR HEX2BIN
.3a4a89	05 0c		ora $080c	                ORA SCRATCH
.3a4a8b	85 0c		sta $080c	                STA SCRATCH         ; And add it to the result
.3a4a8d	c8		iny		                INY
.3a4a8e	80 db		bra $3a4a6b	                BRA loop            ; And try the next character
.3a4a90					ret_result
.3a4a90	c2 20		rep #$20	            REP #$20
.3a4a92	a5 0c		lda $080c	                LDA SCRATCH         ; Return the result
.3a4a94	85 23		sta $0823	                STA ARGUMENT1
.3a4a96	a5 0e		lda $080e	                LDA SCRATCH+2
.3a4a98	85 25		sta $0825	                STA ARGUMENT1+2
.3a4a9a	e2 20		sep #$20	            SEP #$20
.3a4a9c	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a4a9e	85 27		sta $0827	                STA ARGTYPE1
.3a4aa0	28		plp		                PLP
.3a4aa1	e2 20		sep #$20	            SEP #$20
.3a4aa3	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4aa6	60		rts		            RTS
.3a4aa7					FN_HEX
.3a4aa7	e2 20		sep #$20	            SEP #$20
.3a4aa9	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4aab	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4aae	08		php		                PHP
.3a4aaf	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4ab2	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a4ab5	20 be 14	jsr $3a14be	            JSR TEMPSTRING
.3a4ab8	e2 30		sep #$30	            SEP #$30
.3a4aba	a0 ff		ldy #$ff	                LDY #$FF            ; Terminate the string
.3a4abc	a9 00		lda #$00	                LDA #0
.3a4abe	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a4ac0	88		dey		                DEY
.3a4ac1	a5 23		lda $0823	loop            LDA ARGUMENT1       ; Write the low digit
.3a4ac3	29 0f		and #$0f	                AND #$0F
.3a4ac5	aa		tax		                TAX
.3a4ac6	bf 00 d0 3a	lda $3ad000,x	                LDA @lHEXDIGITS,X
.3a4aca	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a4acc	88		dey		                DEY
.3a4acd	a5 23		lda $0823	                LDA ARGUMENT1       ; Write the high digit
.3a4acf	29 f0		and #$f0	                AND #$F0
.3a4ad1	4a		lsr a		                LSR A
.3a4ad2	4a		lsr a		                LSR A
.3a4ad3	4a		lsr a		                LSR A
.3a4ad4	4a		lsr a		                LSR A
.3a4ad5	aa		tax		                TAX
.3a4ad6	bf 00 d0 3a	lda $3ad000,x	                LDA @lHEXDIGITS,X
.3a4ada	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a4adc	88		dey		                DEY
.3a4add	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Shift value by one byte
.3a4adf	85 23		sta $0823	                STA ARGUMENT1
.3a4ae1	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4ae3	85 24		sta $0824	                STA ARGUMENT1+1
.3a4ae5	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a4ae7	85 25		sta $0825	                STA ARGUMENT1+2
.3a4ae9	a9 00		lda #$00	                LDA #0
.3a4aeb	85 26		sta $0826	                STA ARGUMENT1+3
.3a4aed	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the argument 0?
.3a4aef	d0 d0		bne $3a4ac1	                BNE loop            ; No: keep converting
.3a4af1	a5 24		lda $0824	                LDA ARGUMENT1+1
.3a4af3	d0 cc		bne $3a4ac1	                BNE loop
.3a4af5	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4af7	d0 c8		bne $3a4ac1	                BNE loop
.3a4af9	98		tya		                TYA                 ; Get the index of the first free char
.3a4afa	38		sec		                SEC                 ; Add 1 to get to the first character of the string
.3a4afb	65 16		adc $0816	                ADC STRPTR          ; And add the whole thing to the temp string pointer
.3a4afd	85 23		sta $0823	                STA ARGUMENT1       ; And return it as the result
.3a4aff	a5 17		lda $0817	                LDA STRPTR+1
.3a4b01	85 24		sta $0824	                STA ARGUMENT1+1
.3a4b03	a5 18		lda $0818	                LDA STRPTR+2
.3a4b05	85 25		sta $0825	                STA ARGUMENT1+2
.3a4b07	a5 19		lda $0819	                LDA STRPTR+3
.3a4b09	85 26		sta $0826	                STA ARGUMENT1+3
.3a4b0b	a9 02		lda #$02	                LDA #TYPE_STRING    ; And make the type STRING
.3a4b0d	85 27		sta $0827	                STA ARGTYPE1
.3a4b0f	28		plp		                PLP
.3a4b10	e2 20		sep #$20	            SEP #$20
.3a4b12	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4b15	60		rts		            RTS
.3a4b16					type_mismatch
.3a4b16	08		php		            PHP
.3a4b17	c2 20		rep #$20	            REP #$20
.3a4b19	48		pha		            PHA
.3a4b1a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4b1d	5b		tcd		            TCD
.3a4b1e	68		pla		            PLA
.3a4b1f	28		plp		            PLP
.3a4b20	e2 20		sep #$20	            SEP #$20
.3a4b22	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4b24	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4b28	c2 20		rep #$20	            REP #$20
.3a4b2a	29 ff 00	and #$00ff	            AND #$00FF
.3a4b2d	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4b30	e2 20		sep #$20	            SEP #$20
.3a4b32	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4b35					FN_LEN
.3a4b35	e2 20		sep #$20	            SEP #$20
.3a4b37	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4b39	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4b3c	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4b3f	e2 20		sep #$20	            SEP #$20
.3a4b41	a5 27		lda $0827	                LDA ARGTYPE1
.3a4b43	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a4b45	d0 1f		bne $3a4b66	                BNE type_mismatch
.3a4b47	8b		phb		                PHB                 ; Set the data bank to the data bank of the string
.3a4b48	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4b4a	48		pha		                PHA
.3a4b4b	ab		plb		                PLB
.3a4b4c	c2 10		rep #$10	            REP #$10
.3a4b4e	a6 23		ldx $0823	                LDX ARGUMENT1       ; And point X to the string data
.3a4b50	20 aa 15	jsr $3a15aa	            JSR STRLEN
.3a4b53	ab		plb		                PLB                 ; Restore the old data bank
.3a4b54	84 23		sty $0823	                STY ARGUMENT1       ; Save the length to ARGUMENT1
.3a4b56	c2 20		rep #$20	            REP #$20
.3a4b58	64 25		stz $0825	                STZ ARGUMENT1+2
.3a4b5a	e2 20		sep #$20	            SEP #$20
.3a4b5c	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the type to INTEGER
.3a4b5e	85 27		sta $0827	                STA ARGTYPE1
.3a4b60	e2 20		sep #$20	            SEP #$20
.3a4b62	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4b65	60		rts		            RTS
.3a4b66					type_mismatch
.3a4b66	08		php		            PHP
.3a4b67	c2 20		rep #$20	            REP #$20
.3a4b69	48		pha		            PHA
.3a4b6a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4b6d	5b		tcd		            TCD
.3a4b6e	68		pla		            PLA
.3a4b6f	28		plp		            PLP
.3a4b70	e2 20		sep #$20	            SEP #$20
.3a4b72	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4b74	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4b78	c2 20		rep #$20	            REP #$20
.3a4b7a	29 ff 00	and #$00ff	            AND #$00FF
.3a4b7d	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4b80	e2 20		sep #$20	            SEP #$20
.3a4b82	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4b85					FN_PEEK
.3a4b85	e2 20		sep #$20	            SEP #$20
.3a4b87	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4b89	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4b8c	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4b8f	e2 20		sep #$20	            SEP #$20
.3a4b91	a5 27		lda $0827	                LDA ARGTYPE1
.3a4b93	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4b95	d0 33		bne $3a4bca	                BNE type_mismatch
.3a4b97	a5 25		lda $0825	                LDA ARGUMENT1+2                     ; Check to see if the request is to video memory
.3a4b99	c9 b0		cmp #$b0	                CMP #`VRAM
.3a4b9b	90 1b		bcc $3a4bb8	                BLT simple_peek                     ; No: just do an ordinary PEEK
.3a4b9d	c9 f0		cmp #$f0	                CMP #$F0
.3a4b9f	b0 17		bcs $3a4bb8	                BGE simple_peek
.3a4ba1	e2 20		sep #$20	            SEP #$20
.3a4ba3	a7 23		lda [$0823]	                LDA [ARGUMENT1]                     ; Request the data from VRAM
.3a4ba5	c2 20		rep #$20	            REP #$20
.3a4ba7	af 02 09 af	lda $af0902	wait_vram       LDA @l VMEM2CPU_Fifo_Count_LO       ; Wait for the Vicky FIFO to have a byte in it
.3a4bab	89 00 80	bit #$8000	                BIT #$8000
.3a4bae	d0 f7		bne $3a4ba7	                BNE wait_vram
.3a4bb0	e2 20		sep #$20	            SEP #$20
.3a4bb2	af 01 09 af	lda $af0901	                LDA @l VMEM2CPU_Data_Port           ; Fetch the byte from the Vicky FIFO
.3a4bb6	80 04		bra $3a4bbc	                BRA save_result                     ; And return it
.3a4bb8					simple_peek
.3a4bb8	e2 20		sep #$20	            SEP #$20
.3a4bba	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.3a4bbc	85 23		sta $0823	save_result     STA ARGUMENT1
.3a4bbe	64 24		stz $0824	                STZ ARGUMENT1+1
.3a4bc0	64 25		stz $0825	                STZ ARGUMENT1+2
.3a4bc2	64 30		stz $0830	                STZ ARGUMENT1+13
.3a4bc4	e2 20		sep #$20	            SEP #$20
.3a4bc6	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4bc9	60		rts		            RTS
.3a4bca					type_mismatch
.3a4bca	08		php		            PHP
.3a4bcb	c2 20		rep #$20	            REP #$20
.3a4bcd	48		pha		            PHA
.3a4bce	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4bd1	5b		tcd		            TCD
.3a4bd2	68		pla		            PLA
.3a4bd3	28		plp		            PLP
.3a4bd4	e2 20		sep #$20	            SEP #$20
.3a4bd6	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4bd8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4bdc	c2 20		rep #$20	            REP #$20
.3a4bde	29 ff 00	and #$00ff	            AND #$00FF
.3a4be1	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4be4	e2 20		sep #$20	            SEP #$20
.3a4be6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4be9					FN_PEEKL
.3a4be9	e2 20		sep #$20	            SEP #$20
.3a4beb	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4bed	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4bf0	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4bf3	e2 20		sep #$20	            SEP #$20
.3a4bf5	a5 27		lda $0827	                LDA ARGTYPE1
.3a4bf7	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4bf9	d0 1d		bne $3a4c18	                BNE type_mismatch
.3a4bfb	c2 20		rep #$20	            REP #$20
.3a4bfd	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.3a4bff	85 0c		sta $080c	                STA SCRATCH
.3a4c01	e2 20		sep #$20	            SEP #$20
.3a4c03	a0 02 00	ldy #$0002	                LDY #2
.3a4c06	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y
.3a4c08	85 25		sta $0825	                STA ARGUMENT1+2
.3a4c0a	64 26		stz $0826	                STZ ARGUMENT1+3
.3a4c0c	c2 20		rep #$20	            REP #$20
.3a4c0e	a5 0c		lda $080c	                LDA SCRATCH
.3a4c10	85 23		sta $0823	                STA ARGUMENT1
.3a4c12	e2 20		sep #$20	            SEP #$20
.3a4c14	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4c17	60		rts		            RTS
.3a4c18					type_mismatch
.3a4c18	08		php		            PHP
.3a4c19	c2 20		rep #$20	            REP #$20
.3a4c1b	48		pha		            PHA
.3a4c1c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4c1f	5b		tcd		            TCD
.3a4c20	68		pla		            PLA
.3a4c21	28		plp		            PLP
.3a4c22	e2 20		sep #$20	            SEP #$20
.3a4c24	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4c26	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4c2a	c2 20		rep #$20	            REP #$20
.3a4c2c	29 ff 00	and #$00ff	            AND #$00FF
.3a4c2f	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4c32	e2 20		sep #$20	            SEP #$20
.3a4c34	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4c37					FN_PEEKW
.3a4c37	e2 20		sep #$20	            SEP #$20
.3a4c39	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4c3b	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4c3e	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4c41	e2 20		sep #$20	            SEP #$20
.3a4c43	a5 27		lda $0827	                LDA ARGTYPE1
.3a4c45	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4c47	d0 0e		bne $3a4c57	                BNE type_mismatch
.3a4c49	c2 20		rep #$20	            REP #$20
.3a4c4b	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.3a4c4d	85 23		sta $0823	                STA ARGUMENT1
.3a4c4f	64 25		stz $0825	                STZ ARGUMENT1+2
.3a4c51	e2 20		sep #$20	            SEP #$20
.3a4c53	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4c56	60		rts		            RTS
.3a4c57					type_mismatch
.3a4c57	08		php		            PHP
.3a4c58	c2 20		rep #$20	            REP #$20
.3a4c5a	48		pha		            PHA
.3a4c5b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4c5e	5b		tcd		            TCD
.3a4c5f	68		pla		            PLA
.3a4c60	28		plp		            PLP
.3a4c61	e2 20		sep #$20	            SEP #$20
.3a4c63	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4c65	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4c69	c2 20		rep #$20	            REP #$20
.3a4c6b	29 ff 00	and #$00ff	            AND #$00FF
.3a4c6e	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4c71	e2 20		sep #$20	            SEP #$20
.3a4c73	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4c76					FN_CHR
.3a4c76	e2 20		sep #$20	            SEP #$20
.3a4c78	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4c7a	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4c7d	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4c80	e2 20		sep #$20	            SEP #$20
.3a4c82	a5 27		lda $0827	                LDA ARGTYPE1
.3a4c84	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4c86	d0 24		bne $3a4cac	                BNE type_mismatch
.3a4c88	20 be 14	jsr $3a14be	            JSR TEMPSTRING
.3a4c8b	a5 23		lda $0823	                LDA ARGUMENT1       ; Get the numberic value
.3a4c8d	87 16		sta [$0816]	                STA [STRPTR]        ; And save it as the first character
.3a4c8f	a9 00		lda #$00	                LDA #0              ; Null terminate the string
.3a4c91	a0 01 00	ldy #$0001	                LDY #1
.3a4c94	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a4c96	c2 20		rep #$20	            REP #$20
.3a4c98	a5 16		lda $0816	                LDA STRPTR
.3a4c9a	85 23		sta $0823	                STA ARGUMENT1
.3a4c9c	a5 18		lda $0818	                LDA STRPTR+2
.3a4c9e	85 25		sta $0825	                STA ARGUMENT1+2
.3a4ca0	e2 20		sep #$20	            SEP #$20
.3a4ca2	a9 02		lda #$02	                LDA #TYPE_STRING
.3a4ca4	85 27		sta $0827	                STA ARGTYPE1
.3a4ca6	e2 20		sep #$20	            SEP #$20
.3a4ca8	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4cab	60		rts		            RTS
.3a4cac					type_mismatch
.3a4cac	08		php		            PHP
.3a4cad	c2 20		rep #$20	            REP #$20
.3a4caf	48		pha		            PHA
.3a4cb0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4cb3	5b		tcd		            TCD
.3a4cb4	68		pla		            PLA
.3a4cb5	28		plp		            PLP
.3a4cb6	e2 20		sep #$20	            SEP #$20
.3a4cb8	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4cba	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4cbe	c2 20		rep #$20	            REP #$20
.3a4cc0	29 ff 00	and #$00ff	            AND #$00FF
.3a4cc3	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4cc6	e2 20		sep #$20	            SEP #$20
.3a4cc8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4ccb					FN_ASC
.3a4ccb	e2 20		sep #$20	            SEP #$20
.3a4ccd	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4ccf	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4cd2	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4cd5	e2 20		sep #$20	            SEP #$20
.3a4cd7	a5 27		lda $0827	                LDA ARGTYPE1
.3a4cd9	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a4cdb	d0 14		bne $3a4cf1	                BNE type_mismatch
.3a4cdd	a7 23		lda [$0823]	                LDA [ARGUMENT1]     ; Get the character
.3a4cdf	85 23		sta $0823	                STA ARGUMENT1       ; Save its code to ARGUMENT1
.3a4ce1	64 24		stz $0824	                STZ ARGUMENT1+1
.3a4ce3	64 25		stz $0825	                STZ ARGUMENT1+2
.3a4ce5	64 26		stz $0826	                STZ ARGUMENT1+3
.3a4ce7	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the return type to integer
.3a4ce9	85 27		sta $0827	                STA ARGTYPE1
.3a4ceb	e2 20		sep #$20	            SEP #$20
.3a4ced	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4cf0	60		rts		            RTS
.3a4cf1					type_mismatch
.3a4cf1	08		php		            PHP
.3a4cf2	c2 20		rep #$20	            REP #$20
.3a4cf4	48		pha		            PHA
.3a4cf5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4cf8	5b		tcd		            TCD
.3a4cf9	68		pla		            PLA
.3a4cfa	28		plp		            PLP
.3a4cfb	e2 20		sep #$20	            SEP #$20
.3a4cfd	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4cff	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4d03	c2 20		rep #$20	            REP #$20
.3a4d05	29 ff 00	and #$00ff	            AND #$00FF
.3a4d08	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4d0b	e2 20		sep #$20	            SEP #$20
.3a4d0d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4d10					FN_SPC
.3a4d10	e2 20		sep #$20	            SEP #$20
.3a4d12	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4d14	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4d17	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4d1a	e2 20		sep #$20	            SEP #$20
.3a4d1c	a5 27		lda $0827	                LDA ARGTYPE1
.3a4d1e	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4d20	d0 39		bne $3a4d5b	                BNE type_mismatch
.3a4d22	e2 20		sep #$20	            SEP #$20
.3a4d24	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.3a4d26	d0 52		bne $3a4d7a	                BNE err_limit
.3a4d28	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4d2a	d0 4e		bne $3a4d7a	                BNE err_limit
.3a4d2c	a5 24		lda $0824	                LDA ARGUMENT1+1
.3a4d2e	d0 4a		bne $3a4d7a	                BNE err_limit
.3a4d30	c2 10		rep #$10	            REP #$10
.3a4d32	20 be 14	jsr $3a14be	            JSR TEMPSTRING
.3a4d35	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.3a4d37	e2 20		sep #$20	            SEP #$20
.3a4d39	a9 00		lda #$00	                LDA #0
.3a4d3b	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.3a4d3d	88		dey		                DEY
.3a4d3e	30 07		bmi $3a4d47	                BMI done
.3a4d40	a9 20		lda #$20	                LDA #CHAR_SP
.3a4d42	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.3a4d44	88		dey		                DEY
.3a4d45	10 fb		bpl $3a4d42	                BPL loop            ; And keep writing until we're done
.3a4d47	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.3a4d49	85 27		sta $0827	                STA ARGTYPE1
.3a4d4b	c2 20		rep #$20	            REP #$20
.3a4d4d	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.3a4d4f	85 23		sta $0823	                STA ARGUMENT1
.3a4d51	a5 18		lda $0818	                LDA STRPTR+2
.3a4d53	85 25		sta $0825	                STA ARGUMENT1+2
.3a4d55	e2 20		sep #$20	            SEP #$20
.3a4d57	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4d5a	60		rts		            RTS
.3a4d5b					type_mismatch
.3a4d5b	08		php		            PHP
.3a4d5c	c2 20		rep #$20	            REP #$20
.3a4d5e	48		pha		            PHA
.3a4d5f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4d62	5b		tcd		            TCD
.3a4d63	68		pla		            PLA
.3a4d64	28		plp		            PLP
.3a4d65	e2 20		sep #$20	            SEP #$20
.3a4d67	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4d69	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4d6d	c2 20		rep #$20	            REP #$20
.3a4d6f	29 ff 00	and #$00ff	            AND #$00FF
.3a4d72	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4d75	e2 20		sep #$20	            SEP #$20
.3a4d77	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4d7a					err_limit
.3a4d7a	08		php		            PHP
.3a4d7b	c2 20		rep #$20	            REP #$20
.3a4d7d	48		pha		            PHA
.3a4d7e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4d81	5b		tcd		            TCD
.3a4d82	68		pla		            PLA
.3a4d83	28		plp		            PLP
.3a4d84	e2 20		sep #$20	            SEP #$20
.3a4d86	a9 09		lda #$09	            LDA #ERR_RANGE
.3a4d88	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4d8c	c2 20		rep #$20	            REP #$20
.3a4d8e	29 ff 00	and #$00ff	            AND #$00FF
.3a4d91	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4d94	e2 20		sep #$20	            SEP #$20
.3a4d96	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4d99					FN_TAB
.3a4d99	e2 20		sep #$20	            SEP #$20
.3a4d9b	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4d9d	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4da0	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4da3	e2 20		sep #$20	            SEP #$20
.3a4da5	a5 27		lda $0827	                LDA ARGTYPE1
.3a4da7	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4da9	d0 39		bne $3a4de4	                BNE type_mismatch
.3a4dab	e2 20		sep #$20	            SEP #$20
.3a4dad	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.3a4daf	d0 52		bne $3a4e03	                BNE err_limit
.3a4db1	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4db3	d0 4e		bne $3a4e03	                BNE err_limit
.3a4db5	a5 24		lda $0824	                LDA ARGUMENT1+1
.3a4db7	d0 4a		bne $3a4e03	                BNE err_limit
.3a4db9	c2 10		rep #$10	            REP #$10
.3a4dbb	20 be 14	jsr $3a14be	            JSR TEMPSTRING
.3a4dbe	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.3a4dc0	e2 20		sep #$20	            SEP #$20
.3a4dc2	a9 00		lda #$00	                LDA #0
.3a4dc4	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.3a4dc6	88		dey		                DEY
.3a4dc7	30 07		bmi $3a4dd0	                BMI done
.3a4dc9	a9 09		lda #$09	                LDA #CHAR_TAB
.3a4dcb	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.3a4dcd	88		dey		                DEY
.3a4dce	10 fb		bpl $3a4dcb	                BPL loop            ; And keep writing until we're done
.3a4dd0	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.3a4dd2	85 27		sta $0827	                STA ARGTYPE1
.3a4dd4	c2 20		rep #$20	            REP #$20
.3a4dd6	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.3a4dd8	85 23		sta $0823	                STA ARGUMENT1
.3a4dda	a5 18		lda $0818	                LDA STRPTR+2
.3a4ddc	85 25		sta $0825	                STA ARGUMENT1+2
.3a4dde	e2 20		sep #$20	            SEP #$20
.3a4de0	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4de3	60		rts		            RTS
.3a4de4					type_mismatch
.3a4de4	08		php		            PHP
.3a4de5	c2 20		rep #$20	            REP #$20
.3a4de7	48		pha		            PHA
.3a4de8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4deb	5b		tcd		            TCD
.3a4dec	68		pla		            PLA
.3a4ded	28		plp		            PLP
.3a4dee	e2 20		sep #$20	            SEP #$20
.3a4df0	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4df2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4df6	c2 20		rep #$20	            REP #$20
.3a4df8	29 ff 00	and #$00ff	            AND #$00FF
.3a4dfb	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4dfe	e2 20		sep #$20	            SEP #$20
.3a4e00	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4e03					err_limit
.3a4e03	08		php		            PHP
.3a4e04	c2 20		rep #$20	            REP #$20
.3a4e06	48		pha		            PHA
.3a4e07	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4e0a	5b		tcd		            TCD
.3a4e0b	68		pla		            PLA
.3a4e0c	28		plp		            PLP
.3a4e0d	e2 20		sep #$20	            SEP #$20
.3a4e0f	a9 09		lda #$09	            LDA #ERR_RANGE
.3a4e11	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4e15	c2 20		rep #$20	            REP #$20
.3a4e17	29 ff 00	and #$00ff	            AND #$00FF
.3a4e1a	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4e1d	e2 20		sep #$20	            SEP #$20
.3a4e1f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4e22					FN_ABS
.3a4e22	e2 20		sep #$20	            SEP #$20
.3a4e24	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4e26	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4e29	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4e2c	e2 20		sep #$20	            SEP #$20
.3a4e2e	a5 27		lda $0827	                LDA ARGTYPE1        ; Check the type
.3a4e30	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4e32	f0 23		beq $3a4e57	                BEQ abs_int         ; If integer, get the absolute value of the integer
.3a4e34	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.3a4e36	f0 3e		beq $3a4e76	                BEQ abs_float       ; If float, get the absolute value of the float
.3a4e38					type_err
.3a4e38	08		php		            PHP
.3a4e39	c2 20		rep #$20	            REP #$20
.3a4e3b	48		pha		            PHA
.3a4e3c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4e3f	5b		tcd		            TCD
.3a4e40	68		pla		            PLA
.3a4e41	28		plp		            PLP
.3a4e42	e2 20		sep #$20	            SEP #$20
.3a4e44	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4e46	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4e4a	c2 20		rep #$20	            REP #$20
.3a4e4c	29 ff 00	and #$00ff	            AND #$00FF
.3a4e4f	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4e52	e2 20		sep #$20	            SEP #$20
.3a4e54	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4e57					abs_int
.3a4e57	c2 20		rep #$20	            REP #$20
.3a4e59	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Is it positive already?
.3a4e5b	10 21		bpl $3a4e7e	                BPL done            ; Yes: we don't need to do anythign further
.3a4e5d	49 ff ff	eor #$ffff	                EOR #$FFFF          ; Otherwise, take the two's compliment
.3a4e60	85 25		sta $0825	                STA ARGUMENT1+2     ; Of ARGUMENT1
.3a4e62	a5 23		lda $0823	                LDA ARGUMENT1
.3a4e64	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a4e67	18		clc		                CLC
.3a4e68	69 01 00	adc #$0001	                ADC #1
.3a4e6b	85 23		sta $0823	                STA ARGUMENT1       ; And save it back to ARGUMENT1
.3a4e6d	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4e6f	69 00 00	adc #$0000	                ADC #0
.3a4e72	85 25		sta $0825	                STA ARGUMENT1+2
.3a4e74	80 08		bra $3a4e7e	                BRA done
.3a4e76					abs_float
.3a4e76	e2 20		sep #$20	            SEP #$20
.3a4e78	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Just clear the sign bit
.3a4e7a	29 7f		and #$7f	                AND #$7F
.3a4e7c	85 26		sta $0826	                STA ARGUMENT1+3
.3a4e7e					done
.3a4e7e	e2 20		sep #$20	            SEP #$20
.3a4e80	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4e83	60		rts		            RTS
.3a4e84					FN_SGN
.3a4e84	e2 20		sep #$20	            SEP #$20
.3a4e86	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4e88	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4e8b	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4e8e	e2 20		sep #$20	            SEP #$20
.3a4e90	a5 27		lda $0827	                LDA ARGTYPE1
.3a4e92	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4e94	d0 25		bne $3a4ebb	                BNE type_mismatch
.3a4e96	c2 20		rep #$20	            REP #$20
.3a4e98	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4e9a	30 12		bmi $3a4eae	                BMI is_negative     ; Negative: return -1
.3a4e9c	d0 04		bne $3a4ea2	                BNE is_positive     ; Is it not 0? Then return 1
.3a4e9e	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the lower word 0?
.3a4ea0	f0 13		beq $3a4eb5	                BEQ done            ; Yes: the whole thing is zero: return 0
.3a4ea2	a9 00 00	lda #$0000	is_positive     LDA #0              ; It's positive: return 1
.3a4ea5	85 25		sta $0825	                STA ARGUMENT1+2
.3a4ea7	a9 01 00	lda #$0001	                LDA #1
.3a4eaa	85 23		sta $0823	                STA ARGUMENT1
.3a4eac	80 07		bra $3a4eb5	                BRA done
.3a4eae	a9 ff ff	lda #$ffff	is_negative     LDA #$FFFF          ; It's negative: return -1
.3a4eb1	85 25		sta $0825	                STA ARGUMENT1+2
.3a4eb3	85 23		sta $0823	                STA ARGUMENT1
.3a4eb5					done
.3a4eb5	e2 20		sep #$20	            SEP #$20
.3a4eb7	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4eba	60		rts		            RTS
.3a4ebb					type_mismatch
.3a4ebb	08		php		            PHP
.3a4ebc	c2 20		rep #$20	            REP #$20
.3a4ebe	48		pha		            PHA
.3a4ebf	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4ec2	5b		tcd		            TCD
.3a4ec3	68		pla		            PLA
.3a4ec4	28		plp		            PLP
.3a4ec5	e2 20		sep #$20	            SEP #$20
.3a4ec7	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4ec9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4ecd	c2 20		rep #$20	            REP #$20
.3a4ecf	29 ff 00	and #$00ff	            AND #$00FF
.3a4ed2	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a4ed5	e2 20		sep #$20	            SEP #$20
.3a4ed7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4eda					FN_INT
.3a4eda	e2 20		sep #$20	            SEP #$20
.3a4edc	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4ede	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4ee1	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4ee4	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a4ee7					done
.3a4ee7	e2 20		sep #$20	            SEP #$20
.3a4ee9	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4eec	60		rts		            RTS
.3a4eed					FN_SIN
.3a4eed	e2 20		sep #$20	            SEP #$20
.3a4eef	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4ef1	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4ef4	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4ef7	20 84 07	jsr $3a0784	            JSR ASS_ARG1_FLOAT
.3a4efa	20 ab 61	jsr $3a61ab	            JSR FP_SIN
.3a4efd					done
.3a4efd	e2 20		sep #$20	            SEP #$20
.3a4eff	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4f02	60		rts		            RTS
.3a4f03					FN_COS
.3a4f03	e2 20		sep #$20	            SEP #$20
.3a4f05	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4f07	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4f0a	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4f0d	20 84 07	jsr $3a0784	            JSR ASS_ARG1_FLOAT
.3a4f10	20 da 61	jsr $3a61da	            JSR FP_COS
.3a4f13					done
.3a4f13	e2 20		sep #$20	            SEP #$20
.3a4f15	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4f18	60		rts		            RTS
.3a4f19					FN_TAN
.3a4f19	e2 20		sep #$20	            SEP #$20
.3a4f1b	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4f1d	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4f20	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4f23	20 84 07	jsr $3a0784	            JSR ASS_ARG1_FLOAT
.3a4f26	20 09 62	jsr $3a6209	            JSR FP_TAN
.3a4f29					done
.3a4f29	e2 20		sep #$20	            SEP #$20
.3a4f2b	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4f2e	60		rts		            RTS
.3a4f2f					FN_LN
.3a4f2f	e2 20		sep #$20	            SEP #$20
.3a4f31	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4f33	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4f36	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4f39	20 84 07	jsr $3a0784	            JSR ASS_ARG1_FLOAT
.3a4f3c	20 37 62	jsr $3a6237	            JSR FP_LN
.3a4f3f					done
.3a4f3f	e2 20		sep #$20	            SEP #$20
.3a4f41	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4f44	60		rts		            RTS
.3a4f45					FN_ACOS
.3a4f45	e2 20		sep #$20	            SEP #$20
.3a4f47	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4f49	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4f4c	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4f4f	20 84 07	jsr $3a0784	            JSR ASS_ARG1_FLOAT
.3a4f52	20 60 63	jsr $3a6360	            JSR FP_ACOS
.3a4f55					done
.3a4f55	e2 20		sep #$20	            SEP #$20
.3a4f57	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4f5a	60		rts		            RTS
.3a4f5b					FN_ASIN
.3a4f5b	e2 20		sep #$20	            SEP #$20
.3a4f5d	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4f5f	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4f62	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4f65	20 84 07	jsr $3a0784	            JSR ASS_ARG1_FLOAT
.3a4f68	20 36 63	jsr $3a6336	            JSR FP_ASIN
.3a4f6b					done
.3a4f6b	e2 20		sep #$20	            SEP #$20
.3a4f6d	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4f70	60		rts		            RTS
.3a4f71					FN_ATAN
.3a4f71	e2 20		sep #$20	            SEP #$20
.3a4f73	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4f75	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4f78	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4f7b	20 84 07	jsr $3a0784	            JSR ASS_ARG1_FLOAT
.3a4f7e	20 82 63	jsr $3a6382	            JSR FP_ATAN
.3a4f81					done
.3a4f81	e2 20		sep #$20	            SEP #$20
.3a4f83	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4f86	60		rts		            RTS
.3a4f87					FN_EXP
.3a4f87	e2 20		sep #$20	            SEP #$20
.3a4f89	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4f8b	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4f8e	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4f91	20 84 07	jsr $3a0784	            JSR ASS_ARG1_FLOAT
.3a4f94	20 16 64	jsr $3a6416	            JSR FP_EXP
.3a4f97					done
.3a4f97	e2 20		sep #$20	            SEP #$20
.3a4f99	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4f9c	60		rts		            RTS
.3a4f9d					FN_SQR
.3a4f9d	e2 20		sep #$20	            SEP #$20
.3a4f9f	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4fa1	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a4fa4	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a4fa7	20 84 07	jsr $3a0784	            JSR ASS_ARG1_FLOAT
.3a4faa	20 98 64	jsr $3a6498	            JSR FP_SQR
.3a4fad					done
.3a4fad	e2 20		sep #$20	            SEP #$20
.3a4faf	20 da 20	jsr $3a20da	            JSR INCBIP
.3a4fb2	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\commands.s

.3a4fb3	00		brk #		CMD_MONITOR     BRK
.3a4fb4	ea		nop		                NOP
.3a4fb5	60		rts		            RTS
.3a4fb6					CMD_NEW
.3a4fb6	08		php		                PHP
.3a4fb7	0b		phd		                PHD
.3a4fb8	08		php		            PHP
.3a4fb9	c2 20		rep #$20	            REP #$20
.3a4fbb	48		pha		            PHA
.3a4fbc	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a4fbf	5b		tcd		            TCD
.3a4fc0	68		pla		            PLA
.3a4fc1	28		plp		            PLP
.3a4fc2	c2 30		rep #$30	            REP #$30
.3a4fc4	c2 20		rep #$20	            REP #$20
.3a4fc6	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.3a4fc9	85 d9		sta $08d9	            STA LASTLINE
.3a4fcb	e2 20		sep #$20	            SEP #$20
.3a4fcd	a9 36		lda #$36	            LDA #`BASIC_BOT
.3a4fcf	85 db		sta $08db	            STA LASTLINE+2
.3a4fd1	c2 30		rep #$30	            REP #$30
.3a4fd3	a9 00 00	lda #$0000	                LDA #0
.3a4fd6	a0 00 00	ldy #$0000	                LDY #LINE_LINK
.3a4fd9	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.3a4fdb	a0 02 00	ldy #$0002	                LDY #LINE_NUMBER
.3a4fde	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.3a4fe0	a0 04 00	ldy #$0004	                LDY #LINE_TOKENS
.3a4fe3	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.3a4fe5	20 b0 20	jsr $3a20b0	            JSR CLRINTERP
.3a4fe8	2b		pld		                PLD
.3a4fe9	28		plp		                PLP
.3a4fea	60		rts		            RTS
.3a4feb					CMD_RUN
.3a4feb	8b		phb		                PHB
.3a4fec	08		php		                PHP
.3a4fed	c2 20		rep #$20	            REP #$20
.3a4fef	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT            ; Point to the first line of the program
.3a4ff2	85 1a		sta $081a	                STA CURLINE
.3a4ff4	a9 36 00	lda #$0036	                LDA #`BASIC_BOT
.3a4ff7	85 1c		sta $081c	                STA CURLINE + 2
.3a4ff9	20 b0 20	jsr $3a20b0	            JSR CLRINTERP
.3a4ffc	20 90 23	jsr $3a2390	            JSR EXECPROGRAM
.3a4fff	28		plp		                PLP
.3a5000	ab		plb		                PLB
.3a5001	60		rts		            RTS
.3a5002					CMD_LIST
.3a5002	08		php		                PHP
.3a5003	c2 20		rep #$20	            REP #$20
.3a5005	64 55		stz $0855	                STZ MARG1               ; MARG1 is starting line number, default 0
.3a5007	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.3a500a	85 59		sta $0859	                STA MARG2               ; MARG2 is ending line number, default MAXINT
.3a500c	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a500f	20 3b 22	jsr $3a223b	            JSR PEEK_TOK
.3a5012	29 ff 00	and #$00ff	                AND #$00FF
.3a5015	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.3a5018	f0 2c		beq $3a5046	                BEQ call_list           ; ... just list with the defaults
.3a501a	c9 81 00	cmp #$0081	                CMP #TOK_MINUS          ; If just "- ###"...
.3a501d	f0 1a		beq $3a5039	                BEQ parse_endline       ; ... try to parse the end line number
.3a501f	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a5022	20 9d 08	jsr $3a089d	            JSR PARSEINT
.3a5025	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG1
.3a5027	85 55		sta $0855	                STA MARG1
.3a5029	20 3b 22	jsr $3a223b	            JSR PEEK_TOK
.3a502c	29 ff 00	and #$00ff	                AND #$00FF
.3a502f	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.3a5032	f0 12		beq $3a5046	                BEQ call_list           ; ... just list with the defaults
.3a5034	c9 81 00	cmp #$0081	                CMP #TOK_MINUS
.3a5037	d0 2a		bne $3a5063	                BNE error               ; At this point, if not '-', it's a syntax error
.3a5039					parse_endline
.3a5039	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a503c	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a503f	20 9d 08	jsr $3a089d	            JSR PARSEINT
.3a5042	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG2
.3a5044	85 59		sta $0859	                STA MARG2
.3a5046	a5 1c		lda $081c	call_list       LDA CURLINE+2           ; Save CURLINE
.3a5048	48		pha		                PHA
.3a5049	a5 1a		lda $081a	                LDA CURLINE
.3a504b	48		pha		                PHA
.3a504c	a5 02		lda $0802	                LDA BIP+2               ; Save BIP
.3a504e	48		pha		                PHA
.3a504f	a5 00		lda $0800	                LDA BIP
.3a5051	48		pha		                PHA
.3a5052	20 48 18	jsr $3a1848	            JSR LISTPROG
.3a5055	68		pla		                PLA
.3a5056	85 00		sta $0800	                STA BIP
.3a5058	68		pla		                PLA
.3a5059	85 02		sta $0802	                STA BIP+2
.3a505b	68		pla		                PLA
.3a505c	85 1a		sta $081a	                STA CURLINE
.3a505e	68		pla		                PLA
.3a505f	85 1c		sta $081c	                STA CURLINE+2
.3a5061	28		plp		                PLP
.3a5062	60		rts		            RTS
.3a5063					error
.3a5063	08		php		            PHP
.3a5064	c2 20		rep #$20	            REP #$20
.3a5066	48		pha		            PHA
.3a5067	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a506a	5b		tcd		            TCD
.3a506b	68		pla		            PLA
.3a506c	28		plp		            PLP
.3a506d	e2 20		sep #$20	            SEP #$20
.3a506f	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a5071	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a5075	c2 20		rep #$20	            REP #$20
.3a5077	29 ff 00	and #$00ff	            AND #$00FF
.3a507a	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a507d	e2 20		sep #$20	            SEP #$20
.3a507f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]

;******  Return to file: src\basic816.s


;******  Processing file: src\variables.s

>08e1					NEXTVAR         .long ?         ; Pointer to the the next available byte for variable bindings
>08e4					VARIABLES       .long ?         ; Pointer to the most recently allocated variable
>08e7					TOFIND          .long ?         ; Pointer to the variable name to find
>08ea					TOFINDTYPE      .byte ?         ; The type to find
.0000					BINDING
>0000					TYPE            .fill 1                 ; The type of the data stored in the variable
>0001					NAME            .fill VAR_NAME_SIZE     ; The name of the variable
>0009					VALUE           .fill 4                 ; The data stored in the variable
>000d					NEXT            .fill 3                 ; The pointer to the next allocated variable of this type
.3a5082					INITVARS
.3a5082	08		php		                PHP
.3a5083	08		php		            PHP
.3a5084	c2 20		rep #$20	            REP #$20
.3a5086	48		pha		            PHA
.3a5087	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a508a	5b		tcd		            TCD
.3a508b	68		pla		            PLA
.3a508c	28		plp		            PLP
.3a508d	c2 20		rep #$20	            REP #$20
.3a508f	64 e4		stz $08e4	                STZ VARIABLES           ; Clear the pointer to the variables
.3a5091	64 e7		stz $08e7	                STZ TOFIND
.3a5093	e2 20		sep #$20	            SEP #$20
.3a5095	64 e6		stz $08e6	                STZ VARIABLES+2
.3a5097	64 e9		stz $08e9	                STZ TOFIND+2
.3a5099	64 ea		stz $08ea	                STZ TOFINDTYPE
.3a509b	c2 20		rep #$20	            REP #$20
.3a509d	38		sec		                SEC                     ; Compute the position of the first variable
.3a509e	a5 d9		lda $08d9	                LDA LASTLINE
.3a50a0	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.3a50a3	85 e1		sta $08e1	                STA NEXTVAR
.3a50a5	e2 20		sep #$20	            SEP #$20
.3a50a7	a5 db		lda $08db	                LDA LASTLINE+2
.3a50a9	69 00		adc #$00	                ADC #0
.3a50ab	85 e3		sta $08e3	                STA NEXTVAR+2
.3a50ad	28		plp		                PLP
.3a50ae	60		rts		            RTS
.3a50af					ISVARCHAR
.3a50af	c9 5f		cmp #$5f	                CMP #'_'            ; Check if it's an underscore
.3a50b1	f0 1a		beq $3a50cd	                BEQ return_true     ; Yes: return true
.3a50b3	c9 3a		cmp #$3a	                CMP #'9'+1          ; Check if its in [0-9]
.3a50b5	b0 04		bcs $3a50bb	                BGE else1           ; No: check something else
.3a50b7	c9 30		cmp #$30	                CMP #'0'
.3a50b9	b0 12		bcs $3a50cd	                BGE return_true     ; Yes: return true
.3a50bb	c9 5b		cmp #$5b	else1           CMP #'Z'+1          ; Check if its in [A-Z]
.3a50bd	b0 04		bcs $3a50c3	                BGE not_upper       ; No: check lower case
.3a50bf	c9 41		cmp #$41	                CMP #'A'
.3a50c1	b0 0a		bcs $3a50cd	                BGE return_true     ; Yes: return true
.3a50c3	c9 7b		cmp #$7b	not_upper       CMP #'z'+1          ; Check if its in [a-z]
.3a50c5	b0 04		bcs $3a50cb	                BGE return_false    ; No: return false
.3a50c7	c9 61		cmp #$61	                CMP #'a'
.3a50c9	b0 02		bcs $3a50cd	                BGE return_true     ; Yes: return true
.3a50cb	18		clc		return_false    CLC
.3a50cc	60		rts		            RTS
.3a50cd	38		sec		return_true     SEC
.3a50ce	60		rts		            RTS
.3a50cf					VARNAMECMP
.3a50cf	08		php		                PHP
.3a50d0	e2 20		sep #$20	            SEP #$20
.3a50d2	c2 10		rep #$10	            REP #$10
.3a50d4	a0 00 00	ldy #$0000	                LDY #0
.3a50d7	b7 0c		lda [$080c],y	cmp_loop        LDA [SCRATCH],Y         ; Check the character in the variable name
.3a50d9	f0 0a		beq $3a50e5	                BEQ is_end
.3a50db	d7 e7		cmp [$08e7],y	                CMP [TOFIND],Y          ; Compare the character to the one TOFIND
.3a50dd	d0 13		bne $3a50f2	                BNE return_false        ; Not equal? Then this is not a match
.3a50df	c8		iny		                INY
.3a50e0	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.3a50e3	d0 f2		bne $3a50d7	                BNE cmp_loop
.3a50e5	b7 e7		lda [$08e7],y	is_end          LDA [TOFIND],Y          ; Check the character in the name to find
.3a50e7	20 1b 05	jsr $3a051b	            JSR TOUPPERA
.3a50ea	20 af 50	jsr $3a50af	            JSR ISVARCHAR
.3a50ed	b0 03		bcs $3a50f2	                BCS return_false        ; YES: we do not have a match
.3a50ef					return_true
.3a50ef	28		plp		                PLP
.3a50f0	38		sec		                SEC
.3a50f1	60		rts		            RTS
.3a50f2					return_false
.3a50f2	28		plp		                PLP
.3a50f3	18		clc		                CLC
.3a50f4	60		rts		            RTS
.3a50f5					VAR_FIND
.3a50f5	08		php		                PHP
.3a50f6	e2 20		sep #$20	            SEP #$20
.3a50f8	c2 10		rep #$10	            REP #$10
.3a50fa	a0 00 00	ldy #$0000	                LDY #0
.3a50fd	a2 00 00	ldx #$0000	                LDX #0
.3a5100	b7 e7		lda [$08e7],y	upper_loop      LDA [TOFIND],Y          ; Get a character
.3a5102	f0 0b		beq $3a510f	                BEQ done_upper
.3a5104	20 1b 05	jsr $3a051b	            JSR TOUPPERA
.3a5107	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; And save it to the temp
.3a510b	c8		iny		                INY
.3a510c	e8		inx		                INX
.3a510d	80 f1		bra $3a5100	                BRA upper_loop          ; Go back for another
.3a510f	a9 00		lda #$00	done_upper      LDA #0
.3a5111	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; NULL terminate the temporary string
.3a5115	c2 20		rep #$20	            REP #$20
.3a5117	a9 00 4e	lda #$4e00	                LDA #<>TEMPBUF          ; Make the temporary string the string
.3a511a	85 e7		sta $08e7	                STA TOFIND              ; the variable name to find
.3a511c	e2 20		sep #$20	            SEP #$20
.3a511e	a9 00		lda #$00	                LDA #`TEMPBUF
.3a5120	85 e9		sta $08e9	                STA TOFIND+2
.3a5122	c2 20		rep #$20	            REP #$20
.3a5124	a5 e4		lda $08e4	                LDA VARIABLES           ; Point INDEX to the first variable to check
.3a5126	85 08		sta $0808	                STA INDEX
.3a5128	d0 06		bne $3a5130	                BNE set_index_h         ; If the low word is not 0, copy the high byte
.3a512a	e2 20		sep #$20	            SEP #$20
.3a512c	a5 e6		lda $08e6	                LDA VARIABLES+2
.3a512e	f0 4d		beq $3a517d	                BEQ not_found           ; If it is, we have no variables yet.
.3a5130					set_index_h
.3a5130	e2 20		sep #$20	            SEP #$20
.3a5132	a5 e6		lda $08e6	                LDA VARIABLES+2
.3a5134	85 0a		sta $080a	                STA INDEX+2
.3a5136	a5 ea		lda $08ea	check_binding   LDA TOFINDTYPE
.3a5138	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Get the type of the variable
.3a513b	d7 08		cmp [$0808],y	                CMP [INDEX],Y
.3a513d	d0 17		bne $3a5156	                BNE check_next          ; If it's not a match, check the next binding
.3a513f	c2 20		rep #$20	            REP #$20
.3a5141	18		clc		                CLC
.3a5142	a5 08		lda $0808	                LDA INDEX
.3a5144	69 01 00	adc #$0001	                ADC #BINDING.NAME
.3a5147	85 0c		sta $080c	                STA SCRATCH
.3a5149	e2 20		sep #$20	            SEP #$20
.3a514b	a5 0a		lda $080a	                LDA INDEX+2
.3a514d	69 00		adc #$00	                ADC #0
.3a514f	85 0e		sta $080e	                STA SCRATCH+2
.3a5151	20 cf 50	jsr $3a50cf	            JSR VARNAMECMP
.3a5154	b0 2a		bcs $3a5180	                BCS found               ; If they match, return that we've found the variable
.3a5156	a0 0d 00	ldy #$000d	check_next      LDY #BINDING.NEXT       ; SCRATCH := [INDEX].NEXT
.3a5159	c2 20		rep #$20	            REP #$20
.3a515b	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a515d	85 0c		sta $080c	                STA SCRATCH
.3a515f	c8		iny		                INY
.3a5160	c8		iny		                INY
.3a5161	e2 20		sep #$20	            SEP #$20
.3a5163	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a5165	85 0e		sta $080e	                STA SCRATCH+2
.3a5167	d0 06		bne $3a516f	                BNE set_index           ; If SCRATCH == 0, the variable wasn't found
.3a5169	c2 20		rep #$20	            REP #$20
.3a516b	a5 0c		lda $080c	                LDA SCRATCH
.3a516d	f0 0e		beq $3a517d	                BEQ not_found
.3a516f					set_index
.3a516f	c2 20		rep #$20	            REP #$20
.3a5171	a5 0c		lda $080c	                LDA SCRATCH
.3a5173	85 08		sta $0808	                STA INDEX
.3a5175	e2 20		sep #$20	            SEP #$20
.3a5177	a5 0e		lda $080e	                LDA SCRATCH+2
.3a5179	85 0a		sta $080a	                STA INDEX+2
.3a517b	80 b9		bra $3a5136	                BRA check_binding       ; And check this next variable for a match
.3a517d					not_found
.3a517d	28		plp		                PLP
.3a517e	18		clc		                CLC
.3a517f	60		rts		            RTS
.3a5180					found
.3a5180	28		plp		                PLP
.3a5181	38		sec		                SEC
.3a5182	60		rts		            RTS
.3a5183					VAR_REF
.3a5183	08		php		                PHP
.3a5184	20 f5 50	jsr $3a50f5	            JSR VAR_FIND
.3a5187	b0 1f		bcs $3a51a8	                BCS found
.3a5189	08		php		            PHP
.3a518a	c2 20		rep #$20	            REP #$20
.3a518c	48		pha		            PHA
.3a518d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a5190	5b		tcd		            TCD
.3a5191	68		pla		            PLA
.3a5192	28		plp		            PLP
.3a5193	e2 20		sep #$20	            SEP #$20
.3a5195	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.3a5197	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a519b	c2 20		rep #$20	            REP #$20
.3a519d	29 ff 00	and #$00ff	            AND #$00FF
.3a51a0	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a51a3	e2 20		sep #$20	            SEP #$20
.3a51a5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a51a8					found
.3a51a8	c2 30		rep #$30	            REP #$30
.3a51aa	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.3a51ad	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a51af	85 23		sta $0823	                STA ARGUMENT1
.3a51b1	c8		iny		                INY
.3a51b2	c8		iny		                INY
.3a51b3	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a51b5	85 25		sta $0825	                STA ARGUMENT1+2
.3a51b7	e2 20		sep #$20	            SEP #$20
.3a51b9	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE
.3a51bc	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a51be	85 27		sta $0827	                STA ARGTYPE1
.3a51c0	28		plp		done            PLP
.3a51c1	60		rts		            RTS
.3a51c2					VAR_ALLOC
.3a51c2	08		php		                PHP
.3a51c3	c2 20		rep #$20	            REP #$20
.3a51c5	18		clc		                CLC                     ; Compute extent of the binding
.3a51c6	a5 e1		lda $08e1	                LDA NEXTVAR
.3a51c8	69 10 00	adc #$0010	                ADC #size(BINDING)
.3a51cb	85 08		sta $0808	                STA INDEX
.3a51cd	e2 20		sep #$20	            SEP #$20
.3a51cf	a5 e3		lda $08e3	                LDA NEXTVAR+2
.3a51d1	69 00		adc #$00	                ADC #0
.3a51d3	85 0a		sta $080a	                STA INDEX+2
.3a51d5	c5 bc		cmp $08bc	                CMP HEAP+2              ; Check to see if HEAP > INDEX
.3a51d7	90 27		bcc $3a5200	                BLT has_room
.3a51d9	c2 20		rep #$20	            REP #$20
.3a51db	a5 08		lda $0808	                LDA INDEX
.3a51dd	c5 ba		cmp $08ba	                CMP HEAP
.3a51df	90 1f		bcc $3a5200	                BLT has_room
.3a51e1	08		php		            PHP
.3a51e2	c2 20		rep #$20	            REP #$20
.3a51e4	48		pha		            PHA
.3a51e5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a51e8	5b		tcd		            TCD
.3a51e9	68		pla		            PLA
.3a51ea	28		plp		            PLP
.3a51eb	e2 20		sep #$20	            SEP #$20
.3a51ed	a9 09		lda #$09	            LDA #ERR_RANGE
.3a51ef	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a51f3	c2 20		rep #$20	            REP #$20
.3a51f5	29 ff 00	and #$00ff	            AND #$00FF
.3a51f8	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a51fb	e2 20		sep #$20	            SEP #$20
.3a51fd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a5200					has_room
.3a5200	c2 20		rep #$20	            REP #$20
.3a5202	a5 e1		lda $08e1	                LDA NEXTVAR             ; Yes: we can allocate the variable
.3a5204	85 c0		sta $08c0	                STA CURRBLOCK           ; Point CURRBLOCK to it
.3a5206	e2 20		sep #$20	            SEP #$20
.3a5208	a5 e3		lda $08e3	                LDA NEXTVAR+2
.3a520a	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a520c	c2 20		rep #$20	            REP #$20
.3a520e	a5 08		lda $0808	                LDA INDEX               ; And point NEXTVAR to the next possible spot
.3a5210	85 e1		sta $08e1	                STA NEXTVAR
.3a5212	e2 20		sep #$20	            SEP #$20
.3a5214	a5 0a		lda $080a	                LDA INDEX+2
.3a5216	85 e3		sta $08e3	                STA NEXTVAR+2
.3a5218	28		plp		                PLP
.3a5219	60		rts		            RTS
.3a521a					VAR_CREATE
.3a521a	08		php		                PHP
.3a521b	e2 20		sep #$20	            SEP #$20
.3a521d	a5 27		lda $0827	                LDA ARGTYPE1            ; Validate that our types match
.3a521f	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.3a5221	f0 33		beq $3a5256	                BEQ chk_string          ; If so: check to see if it's a string
.3a5223	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable type
.3a5225	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's INTEGER
.3a5227	d0 05		bne $3a522e	                BNE chk_float
.3a5229	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a522c	80 2f		bra $3a525d	                BRA alloc_binding       ; And bind the variable
.3a522e	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; If it's FLOAT
.3a5230	d0 05		bne $3a5237	                BNE type_error
.3a5232	20 84 07	jsr $3a0784	            JSR ASS_ARG1_FLOAT
.3a5235	80 26		bra $3a525d	                BRA alloc_binding       ; And bind the variable
.3a5237					type_error
.3a5237	08		php		            PHP
.3a5238	c2 20		rep #$20	            REP #$20
.3a523a	48		pha		            PHA
.3a523b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a523e	5b		tcd		            TCD
.3a523f	68		pla		            PLA
.3a5240	28		plp		            PLP
.3a5241	e2 20		sep #$20	            SEP #$20
.3a5243	a9 04		lda #$04	            LDA #ERR_TYPE
.3a5245	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a5249	c2 20		rep #$20	            REP #$20
.3a524b	29 ff 00	and #$00ff	            AND #$00FF
.3a524e	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a5251	e2 20		sep #$20	            SEP #$20
.3a5253	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a5256	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING        ; Is it a string?
.3a5258	d0 03		bne $3a525d	                BNE alloc_binding       ; No: just go ahead and bind it
.3a525a	20 b0 16	jsr $3a16b0	            JSR STRCPY
.3a525d					alloc_binding
.3a525d	c2 10		rep #$10	            REP #$10
.3a525f	20 c2 51	jsr $3a51c2	            JSR VAR_ALLOC
.3a5262	c2 30		rep #$30	            REP #$30
.3a5264	18		clc		                CLC
.3a5265	a5 c0		lda $08c0	                LDA CURRBLOCK
.3a5267	69 01 00	adc #$0001	                ADC #BINDING.NAME
.3a526a	85 08		sta $0808	                STA INDEX
.3a526c	e2 20		sep #$20	            SEP #$20
.3a526e	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.3a5270	69 00		adc #$00	                ADC #0
.3a5272	85 0a		sta $080a	                STA INDEX+2
.3a5274	a0 00 00	ldy #$0000	                LDY #0                  ; Ensure that the name field is blank
.3a5277	a9 00		lda #$00	                LDA #0
.3a5279	97 08		sta [$0808],y	blank_loop      STA [INDEX],Y
.3a527b	c8		iny		                INY
.3a527c	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.3a527f	d0 f8		bne $3a5279	                BNE blank_loop
.3a5281	a0 00 00	ldy #$0000	                LDY #0
.3a5284	b7 e7		lda [$08e7],y	name_loop       LDA [TOFIND],Y          ; Copy TOFIND to the NAME field
.3a5286	f0 10		beq $3a5298	                BEQ set_type
.3a5288	20 1b 05	jsr $3a051b	            JSR TOUPPERA
.3a528b	20 af 50	jsr $3a50af	            JSR ISVARCHAR
.3a528e	90 08		bcc $3a5298	                BCC set_type
.3a5290	97 08		sta [$0808],y	                STA [INDEX],Y
.3a5292	c8		iny		                INY
.3a5293	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.3a5296	d0 ec		bne $3a5284	                BNE name_loop
.3a5298					set_type
.3a5298	c2 20		rep #$20	            REP #$20
.3a529a	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE      ; Copy the value to the variable
.3a529d	a5 23		lda $0823	                LDA ARGUMENT1
.3a529f	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a52a1	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a52a3	c8		iny		                INY
.3a52a4	c8		iny		                INY
.3a52a5	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a52a7	a5 e4		lda $08e4	                LDA VARIABLES           ; Point NEXT to the current top of variables
.3a52a9	a0 0d 00	ldy #$000d	                LDY #BINDING.NEXT
.3a52ac	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a52ae	c8		iny		                INY
.3a52af	c8		iny		                INY
.3a52b0	e2 20		sep #$20	            SEP #$20
.3a52b2	a5 e6		lda $08e6	                LDA VARIABLES+2
.3a52b4	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a52b6	c2 20		rep #$20	            REP #$20
.3a52b8	a5 c0		lda $08c0	                LDA CURRBLOCK
.3a52ba	85 e4		sta $08e4	                STA VARIABLES
.3a52bc	e2 20		sep #$20	            SEP #$20
.3a52be	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.3a52c0	85 e6		sta $08e6	                STA VARIABLES+2
.3a52c2	e2 20		sep #$20	            SEP #$20
.3a52c4	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Set the type of the variable
.3a52c7	a5 27		lda $0827	                LDA ARGTYPE1
.3a52c9	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a52cb	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is it a string?
.3a52cd	f0 02		beq $3a52d1	                BEQ set_ref             ; Yes: add a reference count to it
.3a52cf	28		plp		done            PLP
.3a52d0	60		rts		            RTS
.3a52d1					set_ref
.3a52d1	c2 20		rep #$20	            REP #$20
.3a52d3	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the a heap allocated value
.3a52d5	85 c0		sta $08c0	                STA CURRBLOCK
.3a52d7	e2 20		sep #$20	            SEP #$20
.3a52d9	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a52db	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a52dd	20 cc 12	jsr $3a12cc	            JSR HEAP_GETHED
.3a52e0	20 e1 12	jsr $3a12e1	            JSR HEAP_ADDREF
.3a52e3	80 ea		bra $3a52cf	                BRA done
.3a52e5					VAR_SET
.3a52e5	08		php		                PHP
.3a52e6	c2 30		rep #$30	            REP #$30
.3a52e8	a5 e4		lda $08e4	                LDA VARIABLES          ; If VARIABLES = 0, use VAR_CREATE
.3a52ea	d0 06		bne $3a52f2	                BNE use_find
.3a52ec	e2 20		sep #$20	            SEP #$20
.3a52ee	a5 e6		lda $08e6	                LDA VARIABLES+2
.3a52f0	f0 05		beq $3a52f7	                BEQ use_create
.3a52f2					use_find
.3a52f2	20 f5 50	jsr $3a50f5	            JSR VAR_FIND
.3a52f5	b0 05		bcs $3a52fc	                BCS found
.3a52f7					use_create
.3a52f7	20 1a 52	jsr $3a521a	            JSR VAR_CREATE
.3a52fa	80 4e		bra $3a534a	                BRA done
.3a52fc					found
.3a52fc	e2 20		sep #$20	            SEP #$20
.3a52fe	a5 27		lda $0827	                LDA ARGTYPE1            ; Do the types match?
.3a5300	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.3a5302	f0 33		beq $3a5337	                BEQ chk_string          ; Yes: check to see if it's string
.3a5304	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable
.3a5306	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; Is it INTEGER?
.3a5308	d0 05		bne $3a530f	                BNE chk_float
.3a530a	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a530d	80 2c		bra $3a533b	                BRA set_val
.3a530f	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; Is it FLOAT?
.3a5311	d0 05		bne $3a5318	                BNE type_error          ; No: throw an error
.3a5313	20 84 07	jsr $3a0784	            JSR ASS_ARG1_FLOAT
.3a5316	80 23		bra $3a533b	                BRA set_val
.3a5318					type_error
.3a5318	08		php		            PHP
.3a5319	c2 20		rep #$20	            REP #$20
.3a531b	48		pha		            PHA
.3a531c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a531f	5b		tcd		            TCD
.3a5320	68		pla		            PLA
.3a5321	28		plp		            PLP
.3a5322	e2 20		sep #$20	            SEP #$20
.3a5324	a9 04		lda #$04	            LDA #ERR_TYPE
.3a5326	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a532a	c2 20		rep #$20	            REP #$20
.3a532c	29 ff 00	and #$00ff	            AND #$00FF
.3a532f	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a5332	e2 20		sep #$20	            SEP #$20
.3a5334	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a5337	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING
.3a5339	f0 11		beq $3a534c	                BEQ set_string          ; Yes: set the string value of the variable
.3a533b					set_val
.3a533b	c2 30		rep #$30	            REP #$30
.3a533d	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.3a5340	a5 23		lda $0823	                LDA ARGUMENT1
.3a5342	97 08		sta [$0808],y	                STA [INDEX],Y
.3a5344	c8		iny		                INY
.3a5345	c8		iny		                INY
.3a5346	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5348	97 08		sta [$0808],y	                STA [INDEX],Y
.3a534a					done
.3a534a	28		plp		                PLP
.3a534b	60		rts		            RTS
.3a534c					set_string
.3a534c	20 b0 16	jsr $3a16b0	            JSR STRCPY
.3a534f	a0 09 00	ldy #$0009	set_ref         LDY #BINDING.VALUE      ; Set CURRBLOCK to the current string value
.3a5352	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a5354	85 c0		sta $08c0	                STA CURRBLOCK
.3a5356	c8		iny		                INY
.3a5357	c8		iny		                INY
.3a5358	e2 20		sep #$20	            SEP #$20
.3a535a	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a535c	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a535e	20 cc 12	jsr $3a12cc	            JSR HEAP_GETHED
.3a5361	20 00 13	jsr $3a1300	            JSR HEAP_REMREF
.3a5364	e2 20		sep #$20	            SEP #$20
.3a5366	a5 27		lda $0827	                LDA ARGTYPE1
.3a5368	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is the new value a string?
.3a536a	f0 02		beq $3a536e	                BEQ add_ref             ; Yes: add a reference to it
.3a536c	80 cd		bra $3a533b	                BRA set_val             ; No: go back to set the value... this probably shouldn't happen
.3a536e					add_ref
.3a536e	c2 20		rep #$20	            REP #$20
.3a5370	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the new string value
.3a5372	85 c0		sta $08c0	                STA CURRBLOCK
.3a5374	e2 20		sep #$20	            SEP #$20
.3a5376	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5378	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a537a	20 cc 12	jsr $3a12cc	            JSR HEAP_GETHED
.3a537d	20 e1 12	jsr $3a12e1	            JSR HEAP_ADDREF
.3a5380	80 b9		bra $3a533b	                BRA set_val
.3a5382					VAR_FINDNAME
.3a5382	08		php		                PHP
.3a5383	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a5386	e2 20		sep #$20	            SEP #$20
.3a5388	a7 00		lda [$0800]	                LDA [BIP]           ; Get the first character
.3a538a	20 a7 04	jsr $3a04a7	            JSR ISALPHA
.3a538d	90 42		bcc $3a53d1	                BCC not_found
.3a538f	c2 20		rep #$20	            REP #$20
.3a5391	a5 00		lda $0800	                LDA BIP
.3a5393	85 e7		sta $08e7	                STA TOFIND
.3a5395	e2 20		sep #$20	            SEP #$20
.3a5397	a5 02		lda $0802	                LDA BIP+2
.3a5399	85 e9		sta $08e9	                STA TOFIND+2
.3a539b					loop
.3a539b	20 da 20	jsr $3a20da	            JSR INCBIP
.3a539e	a7 00		lda [$0800]	                LDA [BIP]
.3a53a0	f0 0d		beq $3a53af	                BEQ is_float        ; If it's EOL, the variable is a float
.3a53a2	c9 24		cmp #$24	                CMP #'$'            ; If it's $, the variable is a string
.3a53a4	f0 14		beq $3a53ba	                BEQ is_string
.3a53a6	c9 25		cmp #$25	                CMP #'%'            ; If it's %, the variable is an integer
.3a53a8	f0 09		beq $3a53b3	                BEQ is_integer
.3a53aa	20 af 50	jsr $3a50af	            JSR ISVARCHAR
.3a53ad	b0 ec		bcs $3a539b	                BCS loop            ; Check the next one
.3a53af	a9 01		lda #$01	is_float        LDA #TYPE_FLOAT     ; Otherwise it's a float
.3a53b1	80 0c		bra $3a53bf	                BRA set_type
.3a53b3					is_integer
.3a53b3	20 da 20	jsr $3a20da	            JSR INCBIP
.3a53b6	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a53b8	80 05		bra $3a53bf	                BRA set_type
.3a53ba					is_string
.3a53ba	20 da 20	jsr $3a20da	            JSR INCBIP
.3a53bd	a9 02		lda #$02	                LDA #TYPE_STRING
.3a53bf	85 ea		sta $08ea	set_type        STA TOFINDTYPE
.3a53c1	20 3b 22	jsr $3a223b	            JSR PEEK_TOK
.3a53c4	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it "("?
.3a53c6	d0 06		bne $3a53ce	                BNE done            ; No: we're done... it's just a scalar variable
.3a53c8	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Yes: this is an array reference
.3a53ca	09 80		ora #$80	                ORA #$80            ; ... turn on the "Array of..." bit
.3a53cc	85 ea		sta $08ea	                STA TOFINDTYPE
.3a53ce					done
.3a53ce	28		plp		                PLP
.3a53cf	38		sec		                SEC
.3a53d0	60		rts		            RTS
.3a53d1	28		plp		not_found       PLP
.3a53d2	18		clc		                CLC
.3a53d3	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\integers.s

.3a53d4					OP_INT_ADD
.3a53d4	08		php		            PHP
.3a53d5	c2 20		rep #$20	            REP #$20
.3a53d7	18		clc		            CLC
.3a53d8	a5 23		lda $0823	            LDA ARGUMENT1
.3a53da	65 29		adc $0829	            ADC ARGUMENT2
.3a53dc	85 23		sta $0823	            STA ARGUMENT1
.3a53de	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a53e0	65 2b		adc $082b	            ADC ARGUMENT2+2
.3a53e2	85 25		sta $0825	            STA ARGUMENT1+2
.3a53e4	28		plp		            PLP
.3a53e5	60		rts		            RTS
.3a53e6					OP_INT_SUB
.3a53e6	08		php		            PHP
.3a53e7	c2 20		rep #$20	            REP #$20
.3a53e9	38		sec		            SEC
.3a53ea	a5 23		lda $0823	            LDA ARGUMENT1
.3a53ec	e5 29		sbc $0829	            SBC ARGUMENT2
.3a53ee	85 23		sta $0823	            STA ARGUMENT1
.3a53f0	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a53f2	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.3a53f4	85 25		sta $0825	            STA ARGUMENT1+2
.3a53f6	28		plp		            PLP
.3a53f7	60		rts		            RTS
.3a53f8					OP_INT_MUL
.3a53f8	08		php		            PHP
.3a53f9					locals
>0001					L_SIGN      .word ?
>0003					L_RESULT    .dword ?
>0007					            .dword ?
.3a53f9	c2 20		rep #$20	            REP #$20
.3a53fb	3b		tsc		            TSC
.3a53fc	38		sec		            SEC
.3a53fd	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.3a5400	1b		tcs		            TCS
.3a5401	c2 30		rep #$30	            REP #$30
.3a5403	a9 00 00	lda #$0000	            LDA #0                  ; Start by assuming positive numbers
.3a5406	83 01		sta $01,s	            STA L_SIGN
.3a5408	83 03		sta $03,s	            STA L_RESULT            ; Clear result
.3a540a	83 05		sta $05,s	            STA L_RESULT+2
.3a540c	83 07		sta $07,s	            STA L_RESULT+4
.3a540e	83 09		sta $09,s	            STA L_RESULT+6
.3a5410	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Ensure ARGUMENT1 is positive
.3a5412	10 18		bpl $3a542c	            BPL chk_sign2
.3a5414	a9 00 80	lda #$8000	            LDA #$8000              ; Record that ARGUMENT1 is negative
.3a5417	83 01		sta $01,s	            STA L_SIGN
.3a5419	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Take the two's complement of ARGUMENT1
.3a541b	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a541e	85 25		sta $0825	            STA ARGUMENT1+2
.3a5420	a5 23		lda $0823	            LDA ARGUMENT1
.3a5422	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a5425	1a		inc a		            INC A
.3a5426	85 23		sta $0823	            STA ARGUMENT1
.3a5428	d0 02		bne $3a542c	            BNE chk_sign2
.3a542a	e6 25		inc $0825	            INC ARGUMENT1+2
.3a542c	a5 2b		lda $082b	chk_sign2   LDA ARGUMENT2+2         ; Ensure ARGUMENT2 is positive
.3a542e	10 1a		bpl $3a544a	            BPL chk_over
.3a5430	a3 01		lda $01,s	            LDA L_SIGN              ; Flip the sign
.3a5432	49 00 80	eor #$8000	            EOR #$8000
.3a5435	83 01		sta $01,s	            STA L_SIGN
.3a5437	a5 2b		lda $082b	            LDA ARGUMENT2+2         ; Take the two's complement of ARGUMENT2
.3a5439	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a543c	85 2b		sta $082b	            STA ARGUMENT2+2
.3a543e	a5 29		lda $0829	            LDA ARGUMENT2
.3a5440	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a5443	1a		inc a		            INC A
.3a5444	85 29		sta $0829	            STA ARGUMENT2
.3a5446	d0 02		bne $3a544a	            BNE chk_over
.3a5448	e6 2b		inc $082b	            INC ARGUMENT2+2
.3a544a					chk_over
.3a544a	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a544c	f0 04		beq $3a5452	            BEQ do_mult
.3a544e	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a5450	d0 5a		bne $3a54ac	            BNE overflow
.3a5452					do_mult
.3a5452	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*D
.3a5454	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.3a5458	a5 29		lda $0829	            LDA ARGUMENT2
.3a545a	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.3a545e	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.3a5462	83 03		sta $03,s	            STA L_RESULT
.3a5464	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.3a5468	83 05		sta $05,s	            STA L_RESULT+2
.3a546a	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Calculate A*D << 16 + B*D
.3a546c	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.3a5470	a5 29		lda $0829	            LDA ARGUMENT2
.3a5472	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.3a5476	18		clc		            CLC
.3a5477	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.3a547b	63 05		adc $05,s	            ADC L_RESULT+2
.3a547d	83 05		sta $05,s	            STA L_RESULT+2
.3a547f	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.3a5483	63 07		adc $07,s	            ADC L_RESULT+4
.3a5485	83 07		sta $07,s	            STA L_RESULT+4
.3a5487	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*C << 16 + A*D << 16 + B*D
.3a5489	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.3a548d	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a548f	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.3a5493	18		clc		            CLC
.3a5494	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.3a5498	63 05		adc $05,s	            ADC L_RESULT+2
.3a549a	83 05		sta $05,s	            STA L_RESULT+2
.3a549c	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.3a54a0	63 07		adc $07,s	            ADC L_RESULT+4
.3a54a2	83 07		sta $07,s	            STA L_RESULT+4
.3a54a4	a3 07		lda $07,s	            LDA L_RESULT+4
.3a54a6	f0 23		beq $3a54cb	            BEQ no_overflow
.3a54a8	a3 09		lda $09,s	            LDA L_RESULT+6
.3a54aa	f0 1f		beq $3a54cb	            BEQ no_overflow
.3a54ac					overflow
.3a54ac	08		php		            PHP
.3a54ad	c2 20		rep #$20	            REP #$20
.3a54af	48		pha		            PHA
.3a54b0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a54b3	5b		tcd		            TCD
.3a54b4	68		pla		            PLA
.3a54b5	28		plp		            PLP
.3a54b6	e2 20		sep #$20	            SEP #$20
.3a54b8	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.3a54ba	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a54be	c2 20		rep #$20	            REP #$20
.3a54c0	29 ff 00	and #$00ff	            AND #$00FF
.3a54c3	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a54c6	e2 20		sep #$20	            SEP #$20
.3a54c8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a54cb					no_overflow
.3a54cb	c2 30		rep #$30	            REP #$30
.3a54cd	a3 01		lda $01,s	            LDA L_SIGN              ; Check the sign
.3a54cf	10 16		bpl $3a54e7	            BPL ret_result          ; If positive: just return the result
.3a54d1	a3 05		lda $05,s	            LDA L_RESULT+2          ; Compute the two's complement of the result
.3a54d3	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a54d6	83 05		sta $05,s	            STA L_RESULT+2
.3a54d8	a3 03		lda $03,s	            LDA L_RESULT
.3a54da	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a54dd	1a		inc a		            INC A
.3a54de	83 03		sta $03,s	            STA L_RESULT
.3a54e0	d0 05		bne $3a54e7	            BNE ret_result
.3a54e2	a3 05		lda $05,s	            LDA L_RESULT+2
.3a54e4	1a		inc a		            INC A
.3a54e5	83 05		sta $05,s	            STA L_RESULT+2
.3a54e7					ret_result
.3a54e7	a3 03		lda $03,s	            LDA L_RESULT
.3a54e9	85 23		sta $0823	            STA ARGUMENT1
.3a54eb	a3 05		lda $05,s	            LDA L_RESULT+2
.3a54ed	85 25		sta $0825	            STA ARGUMENT1+2
.3a54ef	c2 20		rep #$20	            REP #$20
.3a54f1	3b		tsc		            TSC
.3a54f2	18		clc		            CLC
.3a54f3	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.3a54f6	1b		tcs		            TCS
.3a54f7	28		plp		            PLP
.3a54f8	60		rts		            RTS
.3a54f9					OP_INT_LT
.3a54f9	08		php		            PHP
.3a54fa	c2 20		rep #$20	            REP #$20
.3a54fc	a5 23		lda $0823	            LDA ARGUMENT1
.3a54fe	c5 29		cmp $0829	            CMP ARGUMENT2
.3a5500	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5502	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.3a5504	50 03		bvc $3a5509	            BVC skip_eor
.3a5506	49 00 80	eor #$8000	            EOR #$8000
.3a5509	30 06		bmi $3a5511	skip_eor    BMI ret_true
.3a550b	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a550d	64 25		stz $0825	            STZ ARGUMENT1+2
.3a550f	80 07		bra $3a5518	            BRA done
.3a5511	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a5514	85 23		sta $0823	            STA ARGUMENT1
.3a5516	85 25		sta $0825	            STA ARGUMENT1+2
.3a5518	28		plp		done        PLP
.3a5519	60		rts		            RTS
.3a551a					OP_INT_GT
.3a551a	08		php		            PHP
.3a551b	c2 20		rep #$20	            REP #$20
.3a551d	a5 23		lda $0823	            LDA ARGUMENT1
.3a551f	c5 29		cmp $0829	            CMP ARGUMENT2
.3a5521	d0 0c		bne $3a552f	            BNE test_fully
.3a5523	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5525	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.3a5527	d0 06		bne $3a552f	            BNE test_fully
.3a5529	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a552b	64 25		stz $0825	            STZ ARGUMENT1+2
.3a552d	80 16		bra $3a5545	            BRA done
.3a552f	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.3a5531	c5 23		cmp $0823	            CMP ARGUMENT1
.3a5533	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a5535	e5 25		sbc $0825	            SBC ARGUMENT1+2
.3a5537	50 03		bvc $3a553c	            BVC skip_eor
.3a5539	49 00 80	eor #$8000	            EOR #$8000
.3a553c	10 eb		bpl $3a5529	skip_eor    BPL ret_false
.3a553e	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a5541	85 23		sta $0823	            STA ARGUMENT1
.3a5543	85 25		sta $0825	            STA ARGUMENT1+2
.3a5545	28		plp		done        PLP
.3a5546	60		rts		            RTS
.3a5547					OP_INT_EQ
.3a5547	08		php		            PHP
.3a5548	c2 20		rep #$20	            REP #$20
.3a554a	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a554c	c5 25		cmp $0825	            CMP ARGUMENT1+2
.3a554e	d0 0f		bne $3a555f	            BNE ret_false
.3a5550	a5 29		lda $0829	            LDA ARGUMENT2
.3a5552	c5 23		cmp $0823	            CMP ARGUMENT1
.3a5554	d0 09		bne $3a555f	            BNE ret_false
.3a5556	a9 ff ff	lda #$ffff	            LDA #$FFFF
.3a5559	85 23		sta $0823	            STA ARGUMENT1
.3a555b	85 25		sta $0825	            STA ARGUMENT1+2
.3a555d	80 04		bra $3a5563	            BRA done
.3a555f	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a5561	64 25		stz $0825	            STZ ARGUMENT1+2
.3a5563	28		plp		done        PLP
.3a5564	60		rts		            RTS
.3a5565					OP_INT_NE
.3a5565	08		php		            PHP
.3a5566	c2 20		rep #$20	            REP #$20
.3a5568	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a556a	c5 25		cmp $0825	            CMP ARGUMENT1+2
.3a556c	d0 0c		bne $3a557a	            BNE ret_true
.3a556e	a5 29		lda $0829	            LDA ARGUMENT2
.3a5570	c5 23		cmp $0823	            CMP ARGUMENT1
.3a5572	d0 06		bne $3a557a	            BNE ret_true
.3a5574	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a5576	64 25		stz $0825	            STZ ARGUMENT1+2
.3a5578	80 07		bra $3a5581	            BRA done
.3a557a	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a557d	85 23		sta $0823	            STA ARGUMENT1
.3a557f	85 25		sta $0825	            STA ARGUMENT1+2
.3a5581	28		plp		done        PLP
.3a5582	60		rts		            RTS
.3a5583					OP_INT_GTE
.3a5583	08		php		            PHP
.3a5584	c2 20		rep #$20	            REP #$20
.3a5586	a5 23		lda $0823	            LDA ARGUMENT1
.3a5588	c5 29		cmp $0829	            CMP ARGUMENT2
.3a558a	d0 0f		bne $3a559b	            BNE test_fully
.3a558c	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a558e	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.3a5590	d0 09		bne $3a559b	            BNE test_fully
.3a5592	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a5595	85 23		sta $0823	            STA ARGUMENT1
.3a5597	85 25		sta $0825	            STA ARGUMENT1+2
.3a5599	80 13		bra $3a55ae	            BRA done
.3a559b	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.3a559d	c5 23		cmp $0823	            CMP ARGUMENT1
.3a559f	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a55a1	e5 25		sbc $0825	            SBC ARGUMENT1+2
.3a55a3	50 03		bvc $3a55a8	            BVC skip_eor
.3a55a5	49 00 80	eor #$8000	            EOR #$8000
.3a55a8	30 e8		bmi $3a5592	skip_eor    BMI ret_true
.3a55aa	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a55ac	64 25		stz $0825	            STZ ARGUMENT1+2
.3a55ae	28		plp		done        PLP
.3a55af	60		rts		            RTS
.3a55b0					OP_INT_LTE
.3a55b0	08		php		            PHP
.3a55b1	c2 20		rep #$20	            REP #$20
.3a55b3	a5 23		lda $0823	            LDA ARGUMENT1
.3a55b5	c5 29		cmp $0829	            CMP ARGUMENT2
.3a55b7	d0 0f		bne $3a55c8	            BNE test_fully
.3a55b9	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a55bb	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.3a55bd	d0 09		bne $3a55c8	            BNE test_fully
.3a55bf	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a55c2	85 23		sta $0823	            STA ARGUMENT1
.3a55c4	85 25		sta $0825	            STA ARGUMENT1+2
.3a55c6	80 13		bra $3a55db	            BRA done
.3a55c8	a5 23		lda $0823	test_fully  LDA ARGUMENT1
.3a55ca	c5 29		cmp $0829	            CMP ARGUMENT2
.3a55cc	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a55ce	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.3a55d0	50 03		bvc $3a55d5	            BVC skip_eor
.3a55d2	49 00 80	eor #$8000	            EOR #$8000
.3a55d5	30 e8		bmi $3a55bf	skip_eor    BMI ret_true
.3a55d7	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a55d9	64 25		stz $0825	            STZ ARGUMENT1+2
.3a55db	28		plp		done        PLP
.3a55dc	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\floats.s


;******  Processing file: src\C256/floats.s


;******  Processing file: src\C256/fp_math_defs.s

=$afe200				FP_MATH_CTRL0 = $AFE200         ; Read/write
=$08					FP_MATH_CTRL0_ADD = $08         ; 0: Substraction - 1: Addition
=$01					FP_CTRL0_CONV_0 = %00000001     ; Input 0 should be converted from 24.12 fixed point to floating point
=$02					FP_CTRL0_CONV_1 = %00000010     ; Input 1 should be converted from 24.12 fixed point to floating point
=$00					FP_ADD_IN0_MUX0 = %00000000     ; Adder input #0 is the output of MUX0
=$10					FP_ADD_IN0_MUX1 = %00010000     ; Adder input #0 is the output of MUX1
=$20					FP_ADD_IN0_MULT = %00100000     ; Adder input #0 is the output of the multiplier
=$30					FP_ADD_IN0_DIV  = %00110000     ; Adder input #0 is the output of the divider
=$00					FP_ADD_IN1_MUX0 = %00000000     ; Adder input #1 is the output of MUX0
=$40					FP_ADD_IN1_MUX1 = %01000000     ; Adder input #1 is the output of MUX1
=$80					FP_ADD_IN1_MULT = %10000000     ; Adder input #1 is the output of the multiplier
=$c0					FP_ADD_IN1_DIV  = %11000000     ; Adder input #1 is the output of the divider
=$afe201				FP_MATH_CTRL1 = $AFE201
=$00					FP_OUT_MULT = %00000000         ; Output is from the multiplier
=$01					FP_OUT_DIV  = %00000001         ; Output is from the divider
=$02					FP_OUT_ADD  = %00000010         ; Output is from the adder/subtracter
=$03					FP_OUT_ONE  = %00000011         ; Output is the constant '1.0'
=$afe202				FP_MATH_CTRL2 = $AFE202         ; Not Used - Reserved
=$afe203				FP_MATH_CTRL3 = $AFE203         ; Not Used - Reserved
=$afe204				FP_MATH_MULT_STAT = $AFE204     ; Status of the multiplier
=$01					FP_MULT_STAT_NAN  = $01         ; (NAN) Not a Number Status
=$02					FP_MULT_STAT_OVF  = $02         ; Overflow
=$04					FP_MULT_STAT_UDF  = $04         ; Underflow
=$08					FP_MULT_STAT_ZERO = $08         ; Zero
=$afe205				FP_MATH_DIV_STAT  = $AFE205     ; Status of the divider
=$01					FP_DIV_STAT_NAN       = $01     ; Not a number Status
=$02					FP_DIV_STAT_OVF       = $02     ; Overflow
=$04					FP_DIV_STAT_UDF       = $04     ; Underflow
=$08					FP_DIV_STAT_ZERO      = $08     ; Zero
=$10					FP_DIV_STAT_DIVBYZERO = $10     ; Division by Zero
=$afe206				FP_MATH_ADD_STAT  = $AFE206     ; Status of the adder/subtracter
=$01					FP_ADD_STAT_NAN  = $01          ; Not a number Status
=$02					FP_ADD_STAT_OVF  = $02          ; Overflow
=$04					FP_ADD_STAT_UDF  = $04          ; Underflow
=$08					FP_ADD_STAT_ZERO = $08          ; Zero
=$afe207				FP_MATH_CONV_STAT = $AFE207     ; Status of the fixed <=> float converters
=$01					FP_CONV_STAT_NAN  = $01         ; Not a number Status
=$02					FP_CONV_STAT_OVF  = $02         ; Overflow
=$04					FP_CONV_STAT_UDF  = $04         ; Underflow
=$afe208				FP_MATH_INPUT0_LL = $AFE208
=$afe209				FP_MATH_INPUT0_LH = $AFE209
=$afe20a				FP_MATH_INPUT0_HL = $AFE20A
=$afe20b				FP_MATH_INPUT0_HH = $AFE20B
=$afe20c				FP_MATH_INPUT1_LL = $AFE20C
=$afe20d				FP_MATH_INPUT1_LH = $AFE20D
=$afe20e				FP_MATH_INPUT1_HL = $AFE20E
=$afe20f				FP_MATH_INPUT1_HH = $AFE20F
=$afe208				FP_MATH_OUTPUT_FP_LL = $AFE208
=$afe209				FP_MATH_OUTPUT_FP_LH = $AFE209
=$afe20a				FP_MATH_OUTPUT_FP_HL = $AFE20A
=$afe20b				FP_MATH_OUTPUT_FP_HH = $AFE20B
=$afe20c				FP_MATH_OUTPUT_FIXED_LL = $AFE20C
=$afe20d				FP_MATH_OUTPUT_FIXED_LH = $AFE20D
=$afe20e				FP_MATH_OUTPUT_FIXED_HL = $AFE20E
=$afe20f				FP_MATH_OUTPUT_FIXED_HH = $AFE20F

;******  Return to file: src\C256/floats.s


;******  Processing file: src\C256/math_cop.s

.3a55dd					UINT_DIV_A_X
.3a55dd	08		php		                    PHP
.3a55de	c2 20		rep #$20	            REP #$20
.3a55e0	8f 12 01 00	sta $000112	                    STA @l UNSIGNED_DIV_NUM_LO
.3a55e4	8a		txa		                    TXA
.3a55e5	8f 10 01 00	sta $000110	                    STA @l UNSIGNED_DIV_DEM_LO
.3a55e9	af 16 01 00	lda $000116	                    LDA @l UNSIGNED_DIV_REM_LO
.3a55ed	aa		tax		                    TAX
.3a55ee	af 14 01 00	lda $000114	                    LDA @l UNSIGNED_DIV_QUO_LO
.3a55f2	28		plp		                    PLP
.3a55f3	60		rts		            RTS

;******  Return to file: src\C256/floats.s

.3a55f4					FIXINT_TO_FP
.3a55f4	08		php		                    PHP
.3a55f5	e2 20		sep #$20	            SEP #$20
.3a55f7	a9 03		lda #$03	                    LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.3a55f9	8f 00 e2 af	sta $afe200	                    STA @l FP_MATH_CTRL0
.3a55fd	a9 00		lda #$00	                    LDA #FP_OUT_MULT
.3a55ff	8f 01 e2 af	sta $afe201	                    STA @l FP_MATH_CTRL1
.3a5603	c2 20		rep #$20	            REP #$20
.3a5605	a5 23		lda $0823	                    LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.3a5607	8f 08 e2 af	sta $afe208	                    STA @l FP_MATH_INPUT0_LL
.3a560b	a5 25		lda $0825	                    LDA ARGUMENT1+2
.3a560d	8f 0a e2 af	sta $afe20a	                    STA @l FP_MATH_INPUT0_HL
.3a5611	a9 00 00	lda #$0000	                    LDA #0
.3a5614	8f 0c e2 af	sta $afe20c	                    STA @l FP_MATH_INPUT1_LL    ; ARGUMENT2 = 0100 0000 = 4096 in 20:12
.3a5618	a9 00 01	lda #$0100	                    LDA #$0100
.3a561b	8f 0e e2 af	sta $afe20e	                    STA @l FP_MATH_INPUT1_HL
.3a561f	ea		nop		                    NOP
.3a5620	ea		nop		                    NOP
.3a5621	ea		nop		                    NOP
.3a5622	ea		nop		                    NOP
.3a5623	ea		nop		                    NOP
.3a5624	ea		nop		                    NOP
.3a5625	af 08 e2 af	lda $afe208	                    LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.3a5629	85 23		sta $0823	                    STA ARGUMENT1
.3a562b	af 0a e2 af	lda $afe20a	                    LDA @l FP_MATH_OUTPUT_FP_HL
.3a562f	85 25		sta $0825	                    STA ARGUMENT1+2
.3a5631	a9 01 00	lda #$0001	                    LDA #TYPE_FLOAT
.3a5634	85 27		sta $0827	                    STA ARGTYPE1
.3a5636	28		plp		                    PLP
.3a5637	60		rts		            RTS
.3a5638	08		php		OP_FP_SUB       PHP
.3a5639	e2 20		sep #$20	            SEP #$20
.3a563b	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a563d	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.3a5641	80 09		bra $3a564c	                BRA FP_ADD_SUB
.3a5643	08		php		OP_FP_ADD       PHP
.3a5644	e2 20		sep #$20	            SEP #$20
.3a5646	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a5648	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.3a564c	a9 02		lda #$02	FP_ADD_SUB      LDA #FP_OUT_ADD
.3a564e	8f 01 e2 af	sta $afe201	                STA @lFP_MATH_CTRL1
.3a5652	c2 20		rep #$20	            REP #$20
.3a5654	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.3a5656	8f 08 e2 af	sta $afe208	                STA @lFP_MATH_INPUT0_LL
.3a565a	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a565c	8f 0a e2 af	sta $afe20a	                STA @lFP_MATH_INPUT0_HL
.3a5660	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.3a5662	8f 0c e2 af	sta $afe20c	                STA @lFP_MATH_INPUT1_LL
.3a5666	a5 2b		lda $082b	                LDA ARGUMENT2+2
.3a5668	8f 0e e2 af	sta $afe20e	                STA @lFP_MATH_INPUT1_HL
.3a566c	ea		nop		                NOP
.3a566d	ea		nop		                NOP
.3a566e	ea		nop		                NOP
.3a566f	e2 20		sep #$20	            SEP #$20
.3a5671	af 06 e2 af	lda $afe206	                LDA @lFP_MATH_ADD_STAT      ; Check the status of the addition
.3a5675	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.3a5677	d0 10		bne $3a5689	                BNE fp_add_error            ; If an issue was raise, process the math error
.3a5679	c2 20		rep #$20	            REP #$20
.3a567b	af 08 e2 af	lda $afe208	                LDA @lFP_MATH_OUTPUT_FP_LL  ; Retrieve the results into ARGUMENT1
.3a567f	85 23		sta $0823	                STA ARGUMENT1
.3a5681	af 0a e2 af	lda $afe20a	                LDA @lFP_MATH_OUTPUT_FP_HL
.3a5685	85 25		sta $0825	                STA ARGUMENT1+2
.3a5687	28		plp		fp_add_done     PLP
.3a5688	60		rts		            RTS
.3a5689					fp_add_error
.3a5689	20 24 57	jsr $3a5724	            JSR FP_MATH_ERROR
.3a568c	80 f9		bra $3a5687	                BRA fp_add_done
.3a568e	08		php		OP_FP_DIV       PHP
.3a568f	e2 20		sep #$20	            SEP #$20
.3a5691	a9 01		lda #$01	                LDA #FP_OUT_DIV
.3a5693	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5697	a9 00		lda #$00	                LDA #0
.3a5699	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.3a569d	c2 20		rep #$20	            REP #$20
.3a569f	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.3a56a1	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a56a5	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a56a7	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a56ab	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.3a56ad	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a56b1	a5 2b		lda $082b	                LDA ARGUMENT2+2
.3a56b3	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a56b7	ea		nop		                NOP
.3a56b8	ea		nop		                NOP
.3a56b9	ea		nop		                NOP
.3a56ba	e2 20		sep #$20	            SEP #$20
.3a56bc	af 05 e2 af	lda $afe205	                LDA @l FP_MATH_DIV_STAT     ; Check the status of the addition
.3a56c0	29 17		and #$17	                AND #%00010111              ; Filter out the ZERO status
.3a56c2	d0 10		bne $3a56d4	                BNE fp_div_error            ; If an issue was raise, process the math error
.3a56c4	c2 20		rep #$20	            REP #$20
.3a56c6	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.3a56ca	85 23		sta $0823	                STA ARGUMENT1
.3a56cc	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a56d0	85 25		sta $0825	                STA ARGUMENT1+2
.3a56d2	28		plp		fp_div_done     PLP
.3a56d3	60		rts		            RTS
.3a56d4					fp_div_error
.3a56d4	20 24 57	jsr $3a5724	            JSR FP_MATH_ERROR
.3a56d7	80 f9		bra $3a56d2	                BRA fp_div_done
.3a56d9	08		php		OP_FP_MUL       PHP
.3a56da	e2 20		sep #$20	            SEP #$20
.3a56dc	a9 00		lda #$00	                LDA #FP_OUT_MULT
.3a56de	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a56e2	a9 00		lda #$00	                LDA #0
.3a56e4	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.3a56e8	c2 20		rep #$20	            REP #$20
.3a56ea	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.3a56ec	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a56f0	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a56f2	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a56f6	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.3a56f8	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a56fc	a5 2b		lda $082b	                LDA ARGUMENT2+2
.3a56fe	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5702	ea		nop		                NOP
.3a5703	ea		nop		                NOP
.3a5704	ea		nop		                NOP
.3a5705	e2 20		sep #$20	            SEP #$20
.3a5707	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT    ; Check the status of the addition
.3a570b	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.3a570d	d0 10		bne $3a571f	                BNE fp_mul_error            ; If an issue was raise, process the math error
.3a570f	c2 20		rep #$20	            REP #$20
.3a5711	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.3a5715	85 23		sta $0823	                STA ARGUMENT1
.3a5717	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a571b	85 25		sta $0825	                STA ARGUMENT1+2
.3a571d	28		plp		fp_mul_done     PLP
.3a571e	60		rts		            RTS
.3a571f					fp_mul_error
.3a571f	20 24 57	jsr $3a5724	            JSR FP_MATH_ERROR
.3a5722	80 f9		bra $3a571d	                BRA fp_mul_done
.3a5724					FP_MATH_ERROR
.3a5724	e2 20		sep #$20	            SEP #$20
.3a5726	89 01		bit #$01	                BIT #FP_ADD_STAT_NAN        ; Is there a NaN condition?
.3a5728	f0 20		beq $3a574a	                BEQ check_over              ; No: check for overflow
.3a572a	00		brk #		                BRK
.3a572b	08		php		            PHP
.3a572c	c2 20		rep #$20	            REP #$20
.3a572e	48		pha		            PHA
.3a572f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a5732	5b		tcd		            TCD
.3a5733	68		pla		            PLA
.3a5734	28		plp		            PLP
.3a5735	e2 20		sep #$20	            SEP #$20
.3a5737	a9 0c		lda #$0c	            LDA #ERR_NAN
.3a5739	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a573d	c2 20		rep #$20	            REP #$20
.3a573f	29 ff 00	and #$00ff	            AND #$00FF
.3a5742	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a5745	e2 20		sep #$20	            SEP #$20
.3a5747	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a574a	89 02		bit #$02	check_over      BIT #FP_ADD_STAT_OVF        ; Is ther an overflow condition?
.3a574c	f0 1f		beq $3a576d	                BEQ check_under             ; No: check for underflow
.3a574e	08		php		            PHP
.3a574f	c2 20		rep #$20	            REP #$20
.3a5751	48		pha		            PHA
.3a5752	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a5755	5b		tcd		            TCD
.3a5756	68		pla		            PLA
.3a5757	28		plp		            PLP
.3a5758	e2 20		sep #$20	            SEP #$20
.3a575a	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.3a575c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a5760	c2 20		rep #$20	            REP #$20
.3a5762	29 ff 00	and #$00ff	            AND #$00FF
.3a5765	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a5768	e2 20		sep #$20	            SEP #$20
.3a576a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a576d	89 04		bit #$04	check_under     BIT #FP_ADD_STAT_UDF        ; Is there an underflow condition?
.3a576f	f0 1f		beq $3a5790	                BEQ done                    ; No: we should just return... this probably shouldn't happen
.3a5771	08		php		            PHP
.3a5772	c2 20		rep #$20	            REP #$20
.3a5774	48		pha		            PHA
.3a5775	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a5778	5b		tcd		            TCD
.3a5779	68		pla		            PLA
.3a577a	28		plp		            PLP
.3a577b	e2 20		sep #$20	            SEP #$20
.3a577d	a9 0e		lda #$0e	            LDA #ERR_UNDERFLOW
.3a577f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a5783	c2 20		rep #$20	            REP #$20
.3a5785	29 ff 00	and #$00ff	            AND #$00FF
.3a5788	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a578b	e2 20		sep #$20	            SEP #$20
.3a578d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a5790					done
.3a5790	60		rts		            RTS
.3a5791					FP_MUL10
.3a5791	08		php		                PHP
.3a5792	e2 20		sep #$20	            SEP #$20
.3a5794	a9 00		lda #$00	                LDA #FP_OUT_MULT                ; Set for multiplication
.3a5796	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a579a	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1            ; Input 1 is fixed point
.3a579c	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a57a0	c2 20		rep #$20	            REP #$20
.3a57a2	a9 00 a0	lda #$a000	                LDA #$A000                      ; 10 is one factor
.3a57a5	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a57a9	a9 00 00	lda #$0000	                LDA #0
.3a57ac	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a57b0	a5 23		lda $0823	                LDA ARGUMENT1                   ; N is the other
.3a57b2	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a57b6	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a57b8	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a57bc	ea		nop		                NOP
.3a57bd	ea		nop		                NOP
.3a57be	ea		nop		                NOP
.3a57bf	e2 20		sep #$20	            SEP #$20
.3a57c1	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT        ; Check the status
.3a57c5	89 07		bit #$07	                BIT #FP_MULT_STAT_NAN | FP_MULT_STAT_OVF | FP_MULT_STAT_UDF
.3a57c7	f0 01		beq $3a57ca	                BEQ ret_result
.3a57c9	00		brk #		                BRK                             ; There was an error...
.3a57ca					ret_result
.3a57ca	c2 20		rep #$20	            REP #$20
.3a57cc	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL     ; Save result back
.3a57d0	85 23		sta $0823	                STA ARGUMENT1
.3a57d2	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a57d6	85 25		sta $0825	                STA ARGUMENT1+2
.3a57d8	28		plp		                PLP
.3a57d9	60		rts		            RTS
.3a57da					FP_DIV10
.3a57da	08		php		                PHP
.3a57db	e2 20		sep #$20	            SEP #$20
.3a57dd	a9 01		lda #$01	                LDA #FP_OUT_DIV             ; Set for multiplication
.3a57df	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a57e3	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1        ; Input 1 is fixed point
.3a57e5	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a57e9	c2 20		rep #$20	            REP #$20
.3a57eb	a9 00 a0	lda #$a000	                LDA #$A000                  ; 10 is one factor
.3a57ee	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a57f2	a9 00 00	lda #$0000	                LDA #0
.3a57f5	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a57f9	a5 23		lda $0823	                LDA ARGUMENT1               ; N is the other
.3a57fb	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a57ff	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5801	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5805	ea		nop		                NOP
.3a5806	ea		nop		                NOP
.3a5807	ea		nop		                NOP
.3a5808	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Save result back
.3a580c	85 23		sta $0823	                STA ARGUMENT1
.3a580e	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5812	85 25		sta $0825	                STA ARGUMENT1+2
.3a5814	28		plp		                PLP
.3a5815	60		rts		            RTS

;******  Return to file: src\floats.s

.3a5816					FARG1EQ0
.3a5816	08		php		                PHP
.3a5817	c2 20		rep #$20	            REP #$20
.3a5819	a5 23		lda $0823	                LDA ARGUMENT1
.3a581b	d0 0a		bne $3a5827	                BNE return_false
.3a581d	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a581f	29 ff 7f	and #$7fff	                AND #$7FFF              ; Mask off the sign bit
.3a5822	d0 03		bne $3a5827	                BNE return_false
.3a5824	28		plp		return_true     PLP
.3a5825	38		sec		                SEC
.3a5826	60		rts		            RTS
.3a5827	28		plp		return_false    PLP
.3a5828	18		clc		                CLC
.3a5829	60		rts		            RTS
.3a582a					SHIFTDEC
.3a582a	08		php		                PHP
.3a582b	e2 20		sep #$20	            SEP #$20
.3a582d	38		sec		                SEC                     ; Convert '0'..'9' to it's number
.3a582e	e9 30		sbc #$30	                SBC #'0'
.3a5830	20 3f 05	jsr $3a053f	            JSR MULINT10
.3a5833	c2 20		rep #$20	            REP #$20
.3a5835	29 ff 00	and #$00ff	                AND #$00FF              ; Add the number to ARGUMENT1
.3a5838	18		clc		                CLC
.3a5839	65 23		adc $0823	                ADC ARGUMENT1
.3a583b	85 23		sta $0823	                STA ARGUMENT1
.3a583d	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a583f	69 00 00	adc #$0000	                ADC #0
.3a5842	85 25		sta $0825	                STA ARGUMENT1+2
.3a5844	28		plp		                PLP
.3a5845	60		rts		            RTS
.3a5846					SHIFTHEX
.3a5846	08		php		                PHP
.3a5847	e2 20		sep #$20	            SEP #$20
.3a5849	c9 30		cmp #$30	                CMP #'0'                ; Process 0-9
.3a584b	90 04		bcc $3a5851	                BLT not_09
.3a584d	c9 3a		cmp #$3a	                CMP #'9'+1
.3a584f	90 1c		bcc $3a586d	                BLT is_09
.3a5851	c9 61		cmp #$61	not_09          CMP #'a'                ; Process lowercase A-F
.3a5853	90 04		bcc $3a5859	                BLT not_lc
.3a5855	c9 67		cmp #$67	                CMP #'f'+1
.3a5857	90 0a		bcc $3a5863	                BLT is_lc
.3a5859	c9 41		cmp #$41	not_lc          CMP #'A'                ; Process uppercase A-F
.3a585b	90 04		bcc $3a5861	                BLT not_uc
.3a585d	c9 47		cmp #$47	                CMP #'F'+1
.3a585f	90 07		bcc $3a5868	                BLT is_uc
.3a5861	80 31		bra $3a5894	not_uc          BRA done                ; Just return if we couldn't convert... this shouldn't happen
.3a5863	38		sec		is_lc           SEC                     ; Convert 'a'-'f' to the actual number
.3a5864	e9 57		sbc #$57	                SBC #'a'-10
.3a5866	80 08		bra $3a5870	                BRA shift
.3a5868	38		sec		is_uc           SEC                     ; Convert 'A'-'F' to the actual number
.3a5869	e9 37		sbc #$37	                SBC #'A'-10
.3a586b	80 03		bra $3a5870	                BRA shift
.3a586d	38		sec		is_09           SEC                     ; Convert '0'-'9' to the actual number
.3a586e	e9 30		sbc #$30	                SBC #'0'
.3a5870					shift
.3a5870	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.3a5872	26 24		rol $0824	                ROL ARGUMENT1+1
.3a5874	26 25		rol $0825	                ROL ARGUMENT1+2
.3a5876	26 26		rol $0826	                ROL ARGUMENT1+3
.3a5878	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.3a587a	26 24		rol $0824	                ROL ARGUMENT1+1
.3a587c	26 25		rol $0825	                ROL ARGUMENT1+2
.3a587e	26 26		rol $0826	                ROL ARGUMENT1+3
.3a5880	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.3a5882	26 24		rol $0824	                ROL ARGUMENT1+1
.3a5884	26 25		rol $0825	                ROL ARGUMENT1+2
.3a5886	26 26		rol $0826	                ROL ARGUMENT1+3
.3a5888	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.3a588a	26 24		rol $0824	                ROL ARGUMENT1+1
.3a588c	26 25		rol $0825	                ROL ARGUMENT1+2
.3a588e	26 26		rol $0826	                ROL ARGUMENT1+3
.3a5890	05 23		ora $0823	                ORA ARGUMENT1           ; Add the number to it
.3a5892	85 23		sta $0823	                STA ARGUMENT1
.3a5894	28		plp		done            PLP
.3a5895	60		rts		            RTS
.3a5896					SHIFTBIN
.3a5896	08		php		                PHP
.3a5897	e2 20		sep #$20	            SEP #$20
.3a5899	c9 30		cmp #$30	                CMP #'0'                ; If the character is '0'...
.3a589b	f0 06		beq $3a58a3	                BEQ shift_0             ; Shift a 0 onto ARGUMENT1
.3a589d	c9 31		cmp #$31	                CMP #'1'                ; If the character is '1'...
.3a589f	f0 0a		beq $3a58ab	                BEQ shift_1             ; Shift a 1 onto ARGUMENT1
.3a58a1	80 0f		bra $3a58b2	                BRA done
.3a58a3					shift_0
.3a58a3	c2 20		rep #$20	            REP #$20
.3a58a5	06 23		asl $0823	                ASL ARGUMENT1
.3a58a7	26 25		rol $0825	                ROL ARGUMENT1+2
.3a58a9	80 07		bra $3a58b2	                BRA done
.3a58ab					shift_1
.3a58ab	c2 20		rep #$20	            REP #$20
.3a58ad	38		sec		                SEC
.3a58ae	26 23		rol $0823	                ROL ARGUMENT1
.3a58b0	26 25		rol $0825	                ROL ARGUMENT1+2
.3a58b2	28		plp		done            PLP
.3a58b3	60		rts		            RTS
.3a58b4					FP_POW10
.3a58b4	08		php		                PHP
.3a58b5	e2 30		sep #$30	            SEP #$30
.3a58b7	a5 61		lda $0861	                LDA MARG4
.3a58b9	f0 0d		beq $3a58c8	                BEQ return_1
.3a58bb	aa		tax		                TAX
.3a58bc	a5 69		lda $0869	                LDA MARG6
.3a58be	d0 15		bne $3a58d5	                BNE do_div
.3a58c0	a9 00		lda #$00	                LDA #FP_OUT_MULT                    ; We'll multiply
.3a58c2	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a58c6	80 15		bra $3a58dd	                BRA start_loop
.3a58c8					return_1
.3a58c8	e2 20		sep #$20	            SEP #$20
.3a58ca	a9 03		lda #$03	                LDA #FP_OUT_ONE                     ; We want to return a 1.0
.3a58cc	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a58d0	ea		nop		                NOP
.3a58d1	ea		nop		                NOP
.3a58d2	ea		nop		                NOP
.3a58d3	80 62		bra $3a5937	                BRA ret_result                      ; And return the result
.3a58d5					do_div
.3a58d5	e2 20		sep #$20	            SEP #$20
.3a58d7	a9 01		lda #$01	                LDA #FP_OUT_DIV                     ; We'll divide
.3a58d9	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a58dd					start_loop
.3a58dd	e2 20		sep #$20	            SEP #$20
.3a58df	a9 43		lda #$43	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.3a58e1	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.3a58e5	c2 20		rep #$20	            REP #$20
.3a58e7	a9 00 10	lda #$1000	                LDA #$1000                          ; Input 0 = 1.0
.3a58ea	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a58ee	a9 00 00	lda #$0000	                LDA #0
.3a58f1	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a58f5					loop
.3a58f5	c2 20		rep #$20	            REP #$20
.3a58f7	a9 00 a0	lda #$a000	                LDA #$A000                          ; Input 1 = 10.0
.3a58fa	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a58fe	a9 00 00	lda #$0000	                LDA #0
.3a5901	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5905	ea		nop		                NOP                                 ; Wait for the operation to complete
.3a5906	ea		nop		                NOP
.3a5907	ea		nop		                NOP
.3a5908	ca		dex		                DEX                                 ; Count down
.3a5909	f0 2c		beq $3a5937	                BEQ ret_result                      ; If 0, then we're done
.3a590b	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; SCRATCH <-- Result
.3a590f	8f 0c 08 00	sta $00080c	                STA @l SCRATCH
.3a5913	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5917	8f 0e 08 00	sta $00080e	                STA @l SCRATCH+2
.3a591b	e2 20		sep #$20	            SEP #$20
.3a591d	a9 42		lda #$42	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_1
.3a591f	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.3a5923	c2 20		rep #$20	            REP #$20
.3a5925	af 0c 08 00	lda $00080c	                LDA @l SCRATCH                      ; Input 0 <-- SCRATCH
.3a5929	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a592d	af 0e 08 00	lda $00080e	                LDA @l SCRATCH+2
.3a5931	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5935	80 be		bra $3a58f5	                BRA loop
.3a5937					ret_result
.3a5937	c2 20		rep #$20	            REP #$20
.3a5939	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; Return the result
.3a593d	85 23		sta $0823	                STA ARGUMENT1
.3a593f	af 0a e2 af	lda $afe20a	                LDA FP_MATH_OUTPUT_FP_HL
.3a5943	85 25		sta $0825	                STA ARGUMENT1+2
.3a5945	e2 20		sep #$20	            SEP #$20
.3a5947	a9 01		lda #$01	                LDA #TYPE_FLOAT
.3a5949	85 27		sta $0827	                STA ARGTYPE1
.3a594b	28		plp		done            PLP
.3a594c	60		rts		            RTS
.3a594d					PACKFLOAT
.3a594d	08		php		                PHP
.3a594e	c2 20		rep #$20	            REP #$20
.3a5950	a5 5d		lda $085d	            LDA MARG3
.3a5952	85 23		sta $0823	            STA ARGUMENT1
.3a5954	a5 5f		lda $085f	            LDA MARG3+2
.3a5956	85 25		sta $0825	            STA ARGUMENT1+2
.3a5958	20 66 5b	jsr $3a5b66	            JSR ITOF
.3a595b	c2 20		rep #$20	            REP #$20
.3a595d	a5 23		lda $0823	            LDA ARGUMENT1
.3a595f	85 29		sta $0829	            STA ARGUMENT2
.3a5961	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5963	85 2b		sta $082b	            STA ARGUMENT2+2
.3a5965	c2 20		rep #$20	            REP #$20
.3a5967	a5 59		lda $0859	            LDA MARG2
.3a5969	85 23		sta $0823	            STA ARGUMENT1
.3a596b	a5 5b		lda $085b	            LDA MARG2+2
.3a596d	85 25		sta $0825	            STA ARGUMENT1+2
.3a596f	20 8e 56	jsr $3a568e	            JSR OP_FP_DIV
.3a5972	c2 20		rep #$20	            REP #$20
.3a5974	a5 55		lda $0855	            LDA MARG1
.3a5976	85 29		sta $0829	            STA ARGUMENT2
.3a5978	a5 57		lda $0857	            LDA MARG1+2
.3a597a	85 2b		sta $082b	            STA ARGUMENT2+2
.3a597c	20 43 56	jsr $3a5643	            JSR OP_FP_ADD
.3a597f	c2 20		rep #$20	            REP #$20
.3a5981	a5 23		lda $0823	            LDA ARGUMENT1
.3a5983	85 29		sta $0829	            STA ARGUMENT2
.3a5985	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5987	85 2b		sta $082b	            STA ARGUMENT2+2
.3a5989	20 b4 58	jsr $3a58b4	            JSR FP_POW10
.3a598c	20 d9 56	jsr $3a56d9	            JSR OP_FP_MUL
.3a598f	c2 20		rep #$20	            REP #$20
.3a5991	a5 65		lda $0865	                LDA MARG5                       ; Check to see if the float should be negative
.3a5993	f0 07		beq $3a599c	                BEQ set_float_type              ; If not, just set the type
.3a5995	a5 25		lda $0825	                LDA ARGUMENT1+2                 ; If so, set the sign bit
.3a5997	09 00 80	ora #$8000	                ORA #$8000
.3a599a	85 25		sta $0825	                STA ARGUMENT1+2
.3a599c					set_float_type
.3a599c	e2 20		sep #$20	            SEP #$20
.3a599e	a9 01		lda #$01	                LDA #TYPE_FLOAT                 ; Set the type to float... ready for returning!
.3a59a0	85 27		sta $0827	                STA ARGTYPE1
.3a59a2	28		plp		                PLP
.3a59a3	60		rts		            RTS
.3a59a4					PARSENUM
.3a59a4	5a		phy		                PHY
.3a59a5	08		php		                PHP
.3a59a6	c2 30		rep #$30	            REP #$30
.3a59a8	64 23		stz $0823	                STZ ARGUMENT1       ; This will be the accumulator for building the number
.3a59aa	64 25		stz $0825	                STZ ARGUMENT1+2
.3a59ac	64 55		stz $0855	                STZ MARG1           ; This will be the integer portion of the mantissa for floats
.3a59ae	64 57		stz $0857	                STZ MARG1+2
.3a59b0	64 65		stz $0865	                STZ MARG5           ; MARG5 will be the negative flag for the number
.3a59b2	64 59		stz $0859	                STZ MARG2           ; This will be the denominator of the fractional part of the mantissa
.3a59b4	64 5b		stz $085b	                STZ MARG2+2
.3a59b6	a9 01 00	lda #$0001	                LDA #1
.3a59b9	85 5d		sta $085d	                STA MARG3           ; This will be the divisor of the fractional part of the mantissa
.3a59bb	64 5f		stz $085f	                STZ MARG3+2
.3a59bd	64 61		stz $0861	                STZ MARG4           ; This will be the exponent of a float
.3a59bf	64 63		stz $0863	                STZ MARG4+2
.3a59c1	64 69		stz $0869	                STZ MARG6           ; MARG6 will be the negative flag for the exponent
.3a59c3					s0
.3a59c3	e2 20		sep #$20	            SEP #$20
.3a59c5	a0 00 00	ldy #$0000	                LDY #0
.3a59c8	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the first byte
.3a59ca	c9 2b		cmp #$2b	                CMP #'+'
.3a59cc	f0 33		beq $3a5a01	                BEQ s1_drop         ; '+' --> S1, drop
.3a59ce	c9 2d		cmp #$2d	                CMP #'-'
.3a59d0	f0 2b		beq $3a59fd	                BEQ s1_negative     ; Flag that the number is negative
.3a59d2	c9 26		cmp #$26	                CMP #'&'
.3a59d4	f0 3a		beq $3a5a10	                BEQ s2_drop         ; '&' --> S2, drop
.3a59d6	20 c0 04	jsr $3a04c0	            JSR ISNUMERAL
.3a59d9	90 03		bcc $3a59de	                BCC syntax_err
.3a59db	82 ac 00	brl $3a5a8a	                BRL s7_shift        ; '0'-'9' --> S7, emit
.3a59de					syntax_err
.3a59de	08		php		            PHP
.3a59df	c2 20		rep #$20	            REP #$20
.3a59e1	48		pha		            PHA
.3a59e2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a59e5	5b		tcd		            TCD
.3a59e6	68		pla		            PLA
.3a59e7	28		plp		            PLP
.3a59e8	e2 20		sep #$20	            SEP #$20
.3a59ea	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a59ec	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a59f0	c2 20		rep #$20	            REP #$20
.3a59f2	29 ff 00	and #$00ff	            AND #$00FF
.3a59f5	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a59f8	e2 20		sep #$20	            SEP #$20
.3a59fa	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a59fd	a9 01		lda #$01	s1_negative     LDA #1              ; Set the negative flag for the mantissa
.3a59ff	85 65		sta $0865	                STA MARG5
.3a5a01	c8		iny		s1_drop         INY                 ; Drop the character...
.3a5a02	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next
.3a5a04	c9 26		cmp #$26	                CMP #'&'
.3a5a06	f0 08		beq $3a5a10	                BEQ s2_drop         ; '&' --> S2, drop the '&'
.3a5a08	20 c0 04	jsr $3a04c0	            JSR ISNUMERAL
.3a5a0b	90 d1		bcc $3a59de	                BCC syntax_err
.3a5a0d	82 7a 00	brl $3a5a8a	                BRL s7_shift        ; '0'-'9' --> S7, shift
.3a5a10	c8		iny		s2_drop         INY                 ; Drop the character
.3a5a11	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.3a5a13	c9 68		cmp #$68	                CMP #'h'
.3a5a15	f0 0e		beq $3a5a25	                BEQ s3_drop         ; 'h', 'H' --> S3, drop
.3a5a17	c9 48		cmp #$48	                CMP #'H'
.3a5a19	f0 0a		beq $3a5a25	                BEQ s3_drop
.3a5a1b	c9 62		cmp #$62	                CMP #'b'
.3a5a1d	f0 4c		beq $3a5a6b	                BEQ s5_drop         ; 'b', 'B' --> S5, drop
.3a5a1f	c9 42		cmp #$42	                CMP #'B'
.3a5a21	f0 48		beq $3a5a6b	                BEQ s5_drop
.3a5a23	80 b9		bra $3a59de	                BRA syntax_err
.3a5a25	c8		iny		s3_drop         INY                 ; Drop the character
.3a5a26	b7 00		lda [$0800],y	s3              LDA [BIP],Y         ; Get the next character
.3a5a28	20 d1 04	jsr $3a04d1	            JSR ISHEX
.3a5a2b	b0 02		bcs $3a5a2f	                BCS s4_shift
.3a5a2d	80 af		bra $3a59de	                BRA syntax_err
.3a5a2f					s4_shift
.3a5a2f	20 46 58	jsr $3a5846	            JSR SHIFTHEX
.3a5a32	c8		iny		                INY
.3a5a33	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.3a5a35	20 d1 04	jsr $3a04d1	            JSR ISHEX
.3a5a38	b0 f5		bcs $3a5a2f	                BCS s4_shift        ; '0'-'9','A'-'F' --> S4, shift
.3a5a3a					ret_integer
.3a5a3a	e2 20		sep #$20	            SEP #$20
.3a5a3c	a5 65		lda $0865	                LDA MARG5           ; check if the number should be negative
.3a5a3e	f0 11		beq $3a5a51	                BEQ set_int_type    ; If not, just set the type and return
.3a5a40	c2 20		rep #$20	            REP #$20
.3a5a42	38		sec		                SEC                 ; If so, negate it
.3a5a43	a9 00 00	lda #$0000	                LDA #0
.3a5a46	e5 23		sbc $0823	                SBC ARGUMENT1
.3a5a48	85 23		sta $0823	                STA ARGUMENT1
.3a5a4a	a9 00 00	lda #$0000	                LDA #0
.3a5a4d	e5 25		sbc $0825	                SBC ARGUMENT1+2
.3a5a4f	85 25		sta $0825	                STA ARGUMENT1+2
.3a5a51					set_int_type
.3a5a51	e2 20		sep #$20	            SEP #$20
.3a5a53	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; Return an integer
.3a5a55	85 27		sta $0827	                STA ARGTYPE1
.3a5a57					stop
.3a5a57	c2 20		rep #$20	            REP #$20
.3a5a59	18		clc		                CLC
.3a5a5a	98		tya		                TYA
.3a5a5b	65 00		adc $0800	                ADC BIP
.3a5a5d	85 00		sta $0800	                STA BIP
.3a5a5f	a5 02		lda $0802	                LDA BIP+2
.3a5a61	69 00 00	adc #$0000	                ADC #0
.3a5a64	85 02		sta $0802	                STA BIP+2
.3a5a66	e2 20		sep #$20	            SEP #$20
.3a5a68	28		plp		                PLP
.3a5a69	7a		ply		                PLY
.3a5a6a	60		rts		            RTS
.3a5a6b	c8		iny		s5_drop         INY                     ; Drop the character
.3a5a6c	b7 00		lda [$0800],y	s5              LDA [BIP],Y             ; Get the next character
.3a5a6e	c9 30		cmp #$30	                CMP #'0'
.3a5a70	f0 07		beq $3a5a79	                BEQ s6_shift            ; '0', '1' --> S6, shift
.3a5a72	c9 31		cmp #$31	                CMP #'1'
.3a5a74	f0 03		beq $3a5a79	                BEQ s6_shift
.3a5a76	82 65 ff	brl $3a59de	                BRL syntax_err
.3a5a79					s6_shift
.3a5a79	20 96 58	jsr $3a5896	            JSR SHIFTBIN
.3a5a7c	c8		iny		                INY
.3a5a7d	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a5a7f	c9 30		cmp #$30	                CMP #'0'                ; '0', '1' --> S6, shift
.3a5a81	f0 f6		beq $3a5a79	                BEQ s6_shift
.3a5a83	c9 31		cmp #$31	                CMP #'1'
.3a5a85	f0 f2		beq $3a5a79	                BEQ s6_shift
.3a5a87	82 b0 ff	brl $3a5a3a	                BRL ret_integer         ; Return integer
.3a5a8a					s7_shift
.3a5a8a	20 2a 58	jsr $3a582a	            JSR SHIFTDEC
.3a5a8d	c8		iny		                INY
.3a5a8e	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a5a90	c9 2e		cmp #$2e	                CMP #'.'                ; '.' --> S8, drop and preserve mantissa
.3a5a92	f0 08		beq $3a5a9c	                BEQ s8_mantissa
.3a5a94	20 c0 04	jsr $3a04c0	            JSR ISNUMERAL
.3a5a97	b0 f1		bcs $3a5a8a	                BCS s7_shift
.3a5a99	82 9e ff	brl $3a5a3a	                BRL ret_integer         ; Return integer
.3a5a9c					s8_mantissa
.3a5a9c	c2 20		rep #$20	            REP #$20
.3a5a9e	20 66 5b	jsr $3a5b66	            JSR ITOF
.3a5aa1	c2 20		rep #$20	            REP #$20
.3a5aa3	a5 23		lda $0823	            LDA ARGUMENT1
.3a5aa5	85 55		sta $0855	            STA MARG1
.3a5aa7	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5aa9	85 57		sta $0857	            STA MARG1+2
.3a5aab	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the decimal
.3a5aad	64 25		stz $0825	                STZ ARGUMENT1+2
.3a5aaf	e2 20		sep #$20	            SEP #$20
.3a5ab1	80 36		bra $3a5ae9	                BRA s8_drop
.3a5ab3					s8_shift
.3a5ab3	20 2a 58	jsr $3a582a	            JSR SHIFTDEC
.3a5ab6	c2 20		rep #$20	            REP #$20
.3a5ab8	a5 5f		lda $085f	                LDA MARG3+2             ; high 16 bits
.3a5aba	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.3a5abe	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.3a5ac1	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.3a5ac5	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to high 16 bits of MARG3
.3a5ac9	85 5f		sta $085f	                STA MARG3+2
.3a5acb	a5 5d		lda $085d	                LDA MARG3
.3a5acd	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.3a5ad1	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.3a5ad4	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.3a5ad8	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to MARG3
.3a5adc	85 5d		sta $085d	                STA MARG3
.3a5ade	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.3a5ae2	18		clc		                CLC
.3a5ae3	65 5f		adc $085f	                ADC MARG3+2
.3a5ae5	85 5f		sta $085f	                STA MARG3+2
.3a5ae7	e2 20		sep #$20	            SEP #$20
.3a5ae9					s8_drop
.3a5ae9	c8		iny		                INY
.3a5aea	b7 00		lda [$0800],y	                LDA [BIP],Y
.3a5aec	c9 65		cmp #$65	                CMP #'e'                ; 'E' --> S9, drop
.3a5aee	f0 24		beq $3a5b14	                BEQ s9_drop
.3a5af0	c9 45		cmp #$45	                CMP #'E'
.3a5af2	f0 20		beq $3a5b14	                BEQ s9_drop
.3a5af4	20 c0 04	jsr $3a04c0	            JSR ISNUMERAL
.3a5af7	b0 ba		bcs $3a5ab3	                BCS s8_shift
.3a5af9	c2 20		rep #$20	            REP #$20
.3a5afb	20 66 5b	jsr $3a5b66	            JSR ITOF
.3a5afe	c2 20		rep #$20	            REP #$20
.3a5b00	a5 23		lda $0823	            LDA ARGUMENT1
.3a5b02	85 59		sta $0859	            STA MARG2
.3a5b04	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5b06	85 5b		sta $085b	            STA MARG2+2
.3a5b08	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.3a5b0a	64 25		stz $0825	                STZ ARGUMENT1+2
.3a5b0c	20 4d 59	jsr $3a594d	            JSR PACKFLOAT
.3a5b0f	e2 20		sep #$20	            SEP #$20
.3a5b11	82 43 ff	brl $3a5a57	                BRL stop
.3a5b14					s9_drop
.3a5b14	c2 20		rep #$20	            REP #$20
.3a5b16	20 66 5b	jsr $3a5b66	            JSR ITOF
.3a5b19	c2 20		rep #$20	            REP #$20
.3a5b1b	a5 23		lda $0823	            LDA ARGUMENT1
.3a5b1d	85 59		sta $0859	            STA MARG2
.3a5b1f	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5b21	85 5b		sta $085b	            STA MARG2+2
.3a5b23	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.3a5b25	64 25		stz $0825	                STZ ARGUMENT1+2
.3a5b27	e2 20		sep #$20	            SEP #$20
.3a5b29	c8		iny		                INY
.3a5b2a	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a5b2c	c9 2b		cmp #$2b	                CMP #'+'
.3a5b2e	f0 10		beq $3a5b40	                BEQ s10_drop            ; '+' --> S10, drop
.3a5b30	c9 2d		cmp #$2d	                CMP #'-'
.3a5b32	f0 08		beq $3a5b3c	                BEQ s10_setneg          ; '-' --> S10, set exponent is negative
.3a5b34	20 c0 04	jsr $3a04c0	            JSR ISNUMERAL
.3a5b37	b0 12		bcs $3a5b4b	                BCS S11_shift           ; '0'-'9' --> S11, shift
.3a5b39	82 a2 fe	brl $3a59de	                BRL syntax_err
.3a5b3c					s10_setneg
.3a5b3c	a9 01		lda #$01	                LDA #1                  ; Set that the exponent should be negative
.3a5b3e	85 69		sta $0869	                STA MARG6
.3a5b40					s10_drop
.3a5b40	c8		iny		                INY
.3a5b41	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a5b43	20 c0 04	jsr $3a04c0	            JSR ISNUMERAL
.3a5b46	b0 03		bcs $3a5b4b	                BCS s11_shift
.3a5b48	82 93 fe	brl $3a59de	                BRL syntax_err
.3a5b4b					s11_shift
.3a5b4b	20 2a 58	jsr $3a582a	            JSR SHIFTDEC
.3a5b4e	c8		iny		                INY
.3a5b4f	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a5b51	20 c0 04	jsr $3a04c0	            JSR ISNUMERAL
.3a5b54	b0 f5		bcs $3a5b4b	                BCS s11_shift
.3a5b56	c2 20		rep #$20	            REP #$20
.3a5b58	a5 23		lda $0823	            LDA ARGUMENT1
.3a5b5a	85 61		sta $0861	            STA MARG4
.3a5b5c	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5b5e	85 63		sta $0863	            STA MARG4+2
.3a5b60	20 4d 59	jsr $3a594d	            JSR PACKFLOAT
.3a5b63	82 f1 fe	brl $3a5a57	                BRL stop
.3a5b66					ITOF
.3a5b66	08		php		                PHP
.3a5b67	20 f4 55	jsr $3a55f4	            JSR FIXINT_TO_FP
.3a5b6a	28		plp		done            PLP
.3a5b6b	60		rts		            RTS
.3a5b6c					FTOI
.3a5b6c	08		php		                PHP
.3a5b6d					LOCALS
>0001					l_sign          .byte ?
>0002					l_exponent      .byte ?
>0003					l_mantissa      .dword ?
.3a5b6d	c2 20		rep #$20	            REP #$20
.3a5b6f	a9 63 5e	lda #$5e63	                LDA #<>FP_1_0
.3a5b72	85 29		sta $0829	                STA ARGUMENT2
.3a5b74	a9 3a 00	lda #$003a	                LDA #(FP_1_0 >> 16)
.3a5b77	85 2b		sta $082b	                STA ARGUMENT2+2
.3a5b79	e2 20		sep #$20	            SEP #$20
.3a5b7b	a9 01		lda #$01	                LDA #TYPE_FLOAT
.3a5b7d	85 2d		sta $082d	                STA ARGTYPE2
.3a5b7f	c2 20		rep #$20	            REP #$20
.3a5b81	20 3f 5c	jsr $3a5c3f	            JSR FP_COMPARE
.3a5b84	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.3a5b87	d0 0c		bne $3a5b95	                BNE alloc_locals        ; No: get ready to do the full conversion
.3a5b89	a9 00 00	lda #$0000	                LDA #0
.3a5b8c	8d 23 08	sta $0823	                STA @w ARGUMENT1        ; Yes: Return 0
.3a5b8f	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.3a5b92	82 a1 00	brl $3a5c36	                BRL done
.3a5b95	f4 00 00	pea #$0000	alloc_locals    PEA #0                  ; Reserve space for the locals
.3a5b98	f4 00 00	pea #$0000	                PEA #0
.3a5b9b	f4 00 00	pea #$0000	                PEA #0
.3a5b9e	e2 20		sep #$20	            SEP #$20
.3a5ba0	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3      ; Preserve the sign bit
.3a5ba3	29 80		and #$80	                AND #$80
.3a5ba5	83 01		sta $01,s	                STA l_sign
.3a5ba7	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2      ; Preserve the exponent
.3a5baa	2a		rol a		                ROL A
.3a5bab	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3
.3a5bae	2a		rol a		                ROL A
.3a5baf	83 02		sta $02,s	                STA l_exponent
.3a5bb1	a9 00		lda #$00	save_mantissa   LDA #0                  ; Save the mantissa (with the implied 1)
.3a5bb3	83 06		sta $06,s	                STA l_mantissa+3
.3a5bb5	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2
.3a5bb8	09 80		ora #$80	                ORA #$80
.3a5bba	83 05		sta $05,s	                STA l_mantissa+2
.3a5bbc	ad 24 08	lda $0824	                LDA @w ARGUMENT1+1
.3a5bbf	83 04		sta $04,s	                STA l_mantissa+1
.3a5bc1	ad 23 08	lda $0823	                LDA @w ARGUMENT1
.3a5bc4	83 03		sta $03,s	                STA l_mantissa
.3a5bc6	a3 02		lda $02,s	                LDA l_exponent
.3a5bc8	c9 96		cmp #$96	loop            CMP #150
.3a5bca	f0 3a		beq $3a5c06	                BEQ adj_sign
.3a5bcc	90 1f		bcc $3a5bed	                BLT shift_right
.3a5bce	08		php		            PHP
.3a5bcf	c2 20		rep #$20	            REP #$20
.3a5bd1	48		pha		            PHA
.3a5bd2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a5bd5	5b		tcd		            TCD
.3a5bd6	68		pla		            PLA
.3a5bd7	28		plp		            PLP
.3a5bd8	e2 20		sep #$20	            SEP #$20
.3a5bda	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.3a5bdc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a5be0	c2 20		rep #$20	            REP #$20
.3a5be2	29 ff 00	and #$00ff	            AND #$00FF
.3a5be5	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a5be8	e2 20		sep #$20	            SEP #$20
.3a5bea	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a5bed					shift_right
.3a5bed	c2 20		rep #$20	            REP #$20
.3a5bef	a3 05		lda $05,s	                LDA l_mantissa+2
.3a5bf1	4a		lsr a		                LSR A
.3a5bf2	83 05		sta $05,s	                STA l_mantissa+2
.3a5bf4	a3 03		lda $03,s	                LDA l_mantissa
.3a5bf6	6a		ror a		                ROR A
.3a5bf7	83 03		sta $03,s	                STA l_mantissa
.3a5bf9	e2 20		sep #$20	            SEP #$20
.3a5bfb	a3 02		lda $02,s	                LDA l_exponent
.3a5bfd	1a		inc a		                INC A
.3a5bfe	83 02		sta $02,s	                STA l_exponent
.3a5c00	c9 96		cmp #$96	                CMP #150
.3a5c02	f0 02		beq $3a5c06	                BEQ adj_sign
.3a5c04	80 e7		bra $3a5bed	                BRA shift_right
.3a5c06	a3 01		lda $01,s	adj_sign        LDA l_sign
.3a5c08	f0 1b		beq $3a5c25	                BEQ ret_positive
.3a5c0a	c2 20		rep #$20	            REP #$20
.3a5c0c	a3 03		lda $03,s	                LDA l_mantissa
.3a5c0e	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a5c11	18		clc		                CLC
.3a5c12	69 01 00	adc #$0001	                ADC #1
.3a5c15	8d 23 08	sta $0823	                STA @w ARGUMENT1
.3a5c18	a3 05		lda $05,s	                LDA l_mantissa+2
.3a5c1a	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a5c1d	69 00 00	adc #$0000	                ADC #0
.3a5c20	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.3a5c23	80 0c		bra $3a5c31	                BRA clean
.3a5c25					ret_positive
.3a5c25	c2 20		rep #$20	            REP #$20
.3a5c27	a3 03		lda $03,s	                LDA l_mantissa
.3a5c29	8d 23 08	sta $0823	                STA @w ARGUMENT1
.3a5c2c	a3 05		lda $05,s	                LDA l_mantissa+2
.3a5c2e	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.3a5c31					clean
.3a5c31	c2 20		rep #$20	            REP #$20
.3a5c33	68		pla		                PLA                     ; Clean up the locals
.3a5c34	68		pla		                PLA
.3a5c35	68		pla		                PLA
.3a5c36					done
.3a5c36	e2 20		sep #$20	            SEP #$20
.3a5c38	a9 00		lda #$00	                LDA #TYPE_INTEGER       ; Set the return type to integer
.3a5c3a	8d 27 08	sta $0827	                STA @w ARGTYPE1
.3a5c3d	28		plp		                PLP
.3a5c3e	60		rts		            RTS
.3a5c3f					FP_COMPARE
.3a5c3f	da		phx		                PHX
.3a5c40	08		php		                PHP
.3a5c41	c2 20		rep #$20	            REP #$20
.3a5c43	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save ARGUMENT1 so we don't destroy it
.3a5c45	48		pha		                PHA
.3a5c46	a5 23		lda $0823	                LDA ARGUMENT1
.3a5c48	48		pha		                PHA
.3a5c49	20 38 56	jsr $3a5638	            JSR OP_FP_SUB
.3a5c4c	20 16 58	jsr $3a5816	            JSR FARG1EQ0
.3a5c4f	b0 11		bcs $3a5c62	                BCS are_equal
.3a5c51	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Check the high word
.3a5c53	89 00 80	bit #$8000	                BIT #$8000
.3a5c56	d0 05		bne $3a5c5d	                BNE is_lt                   ; ARGUMENT1 < ARGUMENT2
.3a5c58	a9 01 00	lda #$0001	is_gt           LDA #1                      ; ARGUMENT1 > ARGUMENT2: return 1
.3a5c5b	80 08		bra $3a5c65	                BRA ret_result
.3a5c5d	a9 ff ff	lda #$ffff	is_lt           LDA #$FFFF                  ; ARGUMENT1 > ARGUMENT2: return -1
.3a5c60	80 03		bra $3a5c65	                BRA ret_result
.3a5c62	a9 00 00	lda #$0000	are_equal       LDA #0                      ; Equal: return 0
.3a5c65	fa		plx		ret_result      PLX                         ; Restore ARGUMENT1
.3a5c66	86 23		stx $0823	                STX ARGUMENT1
.3a5c68	fa		plx		                PLX
.3a5c69	86 25		stx $0825	                STX ARGUMENT1+2
.3a5c6b	28		plp		                PLP
.3a5c6c	fa		plx		                PLX
.3a5c6d	60		rts		            RTS
.3a5c6e					OP_FP_LT
.3a5c6e	08		php		                PHP
.3a5c6f	c2 30		rep #$30	            REP #$30
.3a5c71	20 3f 5c	jsr $3a5c3f	            JSR FP_COMPARE
.3a5c74	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.3a5c77	d0 05		bne $3a5c7e	                BNE ret_false
.3a5c79	20 f2 05	jsr $3a05f2	            JSR SET_TRUE
.3a5c7c	80 03		bra $3a5c81	                BRA done
.3a5c7e					ret_false
.3a5c7e	20 04 06	jsr $3a0604	            JSR SET_FALSE
.3a5c81	28		plp		done            PLP
.3a5c82	60		rts		            RTS
.3a5c83					OP_FP_GT
.3a5c83	08		php		                PHP
.3a5c84	c2 30		rep #$30	            REP #$30
.3a5c86	20 3f 5c	jsr $3a5c3f	            JSR FP_COMPARE
.3a5c89	c9 01 00	cmp #$0001	                CMP #1
.3a5c8c	d0 05		bne $3a5c93	                BNE ret_false
.3a5c8e	20 f2 05	jsr $3a05f2	            JSR SET_TRUE
.3a5c91	80 03		bra $3a5c96	                BRA done
.3a5c93					ret_false
.3a5c93	20 04 06	jsr $3a0604	            JSR SET_FALSE
.3a5c96	28		plp		done            PLP
.3a5c97	60		rts		            RTS
.3a5c98					OP_FP_EQ
.3a5c98	08		php		                PHP
.3a5c99	c2 30		rep #$30	            REP #$30
.3a5c9b	20 3f 5c	jsr $3a5c3f	            JSR FP_COMPARE
.3a5c9e	c9 00 00	cmp #$0000	                CMP #0
.3a5ca1	d0 05		bne $3a5ca8	                BNE ret_false
.3a5ca3	20 f2 05	jsr $3a05f2	            JSR SET_TRUE
.3a5ca6	80 03		bra $3a5cab	                BRA done
.3a5ca8					ret_false
.3a5ca8	20 04 06	jsr $3a0604	            JSR SET_FALSE
.3a5cab	28		plp		done            PLP
.3a5cac	60		rts		            RTS
.3a5cad					OP_FP_LTE
.3a5cad	08		php		                PHP
.3a5cae	c2 30		rep #$30	            REP #$30
.3a5cb0	20 3f 5c	jsr $3a5c3f	            JSR FP_COMPARE
.3a5cb3	c9 01 00	cmp #$0001	                CMP #1
.3a5cb6	f0 05		beq $3a5cbd	                BEQ ret_false
.3a5cb8	20 f2 05	jsr $3a05f2	            JSR SET_TRUE
.3a5cbb	80 03		bra $3a5cc0	                BRA done
.3a5cbd					ret_false
.3a5cbd	20 04 06	jsr $3a0604	            JSR SET_FALSE
.3a5cc0	28		plp		done            PLP
.3a5cc1	60		rts		            RTS
.3a5cc2					OP_FP_GTE
.3a5cc2	08		php		                PHP
.3a5cc3	c2 30		rep #$30	            REP #$30
.3a5cc5	20 3f 5c	jsr $3a5c3f	            JSR FP_COMPARE
.3a5cc8	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.3a5ccb	f0 05		beq $3a5cd2	                BEQ ret_false
.3a5ccd	20 f2 05	jsr $3a05f2	            JSR SET_TRUE
.3a5cd0	80 03		bra $3a5cd5	                BRA done
.3a5cd2					ret_false
.3a5cd2	20 04 06	jsr $3a0604	            JSR SET_FALSE
.3a5cd5	28		plp		done            PLP
.3a5cd6	60		rts		            RTS
.3a5cd7					OP_FP_NE
.3a5cd7	08		php		                PHP
.3a5cd8	c2 30		rep #$30	            REP #$30
.3a5cda	20 3f 5c	jsr $3a5c3f	            JSR FP_COMPARE
.3a5cdd	c9 00 00	cmp #$0000	                CMP #0
.3a5ce0	f0 05		beq $3a5ce7	                BEQ ret_false
.3a5ce2	20 f2 05	jsr $3a05f2	            JSR SET_TRUE
.3a5ce5	80 03		bra $3a5cea	                BRA done
.3a5ce7					ret_false
.3a5ce7	20 04 06	jsr $3a0604	            JSR SET_FALSE
.3a5cea	28		plp		done            PLP
.3a5ceb	60		rts		            RTS
.3a5cec					STREMIT
.3a5cec	08		php		                PHP
.3a5ced	e2 20		sep #$20	            SEP #$20
.3a5cef	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Append the character
.3a5cf1	c8		iny		                INY                         ; Advance the character pointer in Y
.3a5cf2	a9 00		lda #$00	                LDA #0                      ; And add the NULL
.3a5cf4	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.3a5cf6	28		plp		                PLP
.3a5cf7	60		rts		            RTS
.3a5cf8					STREMITB
.3a5cf8	da		phx		                PHX
.3a5cf9	08		php		                PHP
.3a5cfa	e2 20		sep #$20	            SEP #$20
.3a5cfc	c9 80		cmp #$80	                CMP #$80
.3a5cfe	90 0a		bcc $3a5d0a	                BLT emit_digits
.3a5d00	48		pha		                PHA
.3a5d01	a9 2d		lda #$2d	                LDA #'-'                    ; Print a minus sign
.3a5d03	20 ec 5c	jsr $3a5cec	            JSR STREMIT
.3a5d06	68		pla		                PLA
.3a5d07	49 ff		eor #$ff	                EOR #$FF                    ; And negate it
.3a5d09	1a		inc a		                INC A
.3a5d0a					emit_digits
.3a5d0a	c2 30		rep #$30	            REP #$30
.3a5d0c	29 ff 00	and #$00ff	                AND #$00FF
.3a5d0f	c9 64 00	cmp #$0064	                CMP #100
.3a5d12	90 0e		bcc $3a5d22	                BLT chk_tens
.3a5d14	a2 64 00	ldx #$0064	                LDX #100
.3a5d17	20 dd 55	jsr $3a55dd	            JSR UINT_DIV_A_X
.3a5d1a	18		clc		                CLC
.3a5d1b	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.3a5d1e	20 ec 5c	jsr $3a5cec	            JSR STREMIT
.3a5d21	8a		txa		                TXA                         ; Put the remainder in A
.3a5d22					chk_tens
.3a5d22	a2 0a 00	ldx #$000a	                LDX #10
.3a5d25	20 dd 55	jsr $3a55dd	            JSR UINT_DIV_A_X
.3a5d28	18		clc		                CLC
.3a5d29	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.3a5d2c	20 ec 5c	jsr $3a5cec	            JSR STREMIT
.3a5d2f	8a		txa		                TXA                         ; Put the remainder in A
.3a5d30					ones_digit
.3a5d30	18		clc		                CLC
.3a5d31	69 30 00	adc #$0030	                ADC #'0'                    ; Convert it to ASCII
.3a5d34	20 ec 5c	jsr $3a5cec	            JSR STREMIT
.3a5d37	28		plp		                PLP
.3a5d38	fa		plx		                PLX
.3a5d39	60		rts		            RTS
.3a5d3a					STRFINDEND
.3a5d3a	08		php		                PHP
.3a5d3b	e2 20		sep #$20	            SEP #$20
.3a5d3d	c2 10		rep #$10	            REP #$10
.3a5d3f	a0 00 00	ldy #$0000	                LDY #0
.3a5d42	b7 23		lda [$0823],y	find_end        LDA [ARGUMENT1],Y           ; Scan to the end of the string
.3a5d44	f0 03		beq $3a5d49	                BEQ done
.3a5d46	c8		iny		                INY
.3a5d47	80 f9		bra $3a5d42	                BRA find_end
.3a5d49	28		plp		done            PLP
.3a5d4a	60		rts		            RTS
=6					FP_D = 6        ; Number of mantissa digits
.3a5d4b					FTOS
.3a5d4b	08		php		                PHP
.3a5d4c	e2 20		sep #$20	            SEP #$20
.3a5d4e	c2 10		rep #$10	            REP #$10
.3a5d50	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be the negative flag
.3a5d53	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be K
.3a5d56	f4 00 00	pea #$0000	                PEA #0                      ; This spot will be for the exponents
>0001					L_NEGATIVE      .word ?
>0003					L_K             .word ?
>0005					L_X1            .byte ?                     ; The binary exponent
>0006					L_EXP           .byte ?                     ; The decimal exponent
.3a5d59	20 16 58	jsr $3a5816	            JSR FARG1EQ0
.3a5d5c	90 19		bcc $3a5d77	                BCC chk_negative
.3a5d5e	20 be 14	jsr $3a14be	            JSR TEMPSTRING
.3a5d61	e2 20		sep #$20	            SEP #$20
.3a5d63	a0 00 00	ldy #$0000	                LDY #0
.3a5d66	a9 20		lda #$20	                LDA #' '
.3a5d68	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a5d6a	c8		iny		                INY
.3a5d6b	a9 30		lda #$30	                LDA #'0'                    ; Return a "0"
.3a5d6d	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a5d6f	c8		iny		                INY
.3a5d70	a9 00		lda #$00	                LDA #0
.3a5d72	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a5d74	82 ce 00	brl $3a5e45	                BRL ret_result
.3a5d77					chk_negative
.3a5d77	e2 20		sep #$20	            SEP #$20
.3a5d79	a5 26		lda $0826	                LDA ARGUMENT1+3             ; If N is negative, output a minus sign and negate N
.3a5d7b	10 08		bpl $3a5d85	                BPL not_negative
.3a5d7d	29 7f		and #$7f	                AND #$7F                    ; Negate the number
.3a5d7f	85 26		sta $0826	                STA ARGUMENT1+3
.3a5d81	a9 01		lda #$01	                LDA #1
.3a5d83	83 01		sta $01,s	                STA L_NEGATIVE              ; Set IsNegative to a TRUE value
.3a5d85					not_negative
.3a5d85	c2 20		rep #$20	            REP #$20
.3a5d87	a9 00 00	lda #$0000	                LDA #0                      ; Initialize K to 0, K is a 1-byte signed integer. (SCRATCH is K)
.3a5d8a	83 03		sta $03,s	                STA L_K                     ; We're using a word here for convenience
.3a5d8c	c2 20		rep #$20	            REP #$20
.3a5d8e	af 5f 5e 3a	lda $3a5e5f	            LDA ten_d_1
.3a5d92	85 29		sta $0829	            STA ARGUMENT2
.3a5d94	af 61 5e 3a	lda $3a5e61	            LDA ten_d_1+2
.3a5d98	85 2b		sta $082b	            STA ARGUMENT2+2
.3a5d9a	20 3f 5c	jsr $3a5c3f	            JSR FP_COMPARE
.3a5d9d	89 00 80	bit #$8000	                BIT #$8000                  ; Is N < 10^(D-1)?
.3a5da0	d0 12		bne $3a5db4	                BNE shift_up
.3a5da2					shift_down
.3a5da2	20 da 57	jsr $3a57da	            JSR FP_DIV10
.3a5da5	a3 03		lda $03,s	                LDA L_K
.3a5da7	1a		inc a		                INC A
.3a5da8	83 03		sta $03,s	                STA L_K                     ; Increment K
.3a5daa	20 3f 5c	jsr $3a5c3f	            JSR FP_COMPARE
.3a5dad	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N < 10^(D-1)?
.3a5db0	f0 12		beq $3a5dc4	                BEQ do_digits               ; Yes: we're ready to process digits
.3a5db2	80 ee		bra $3a5da2	                BRA shift_down              ; No: keep dividing
.3a5db4					shift_up
.3a5db4	20 91 57	jsr $3a5791	            JSR FP_MUL10
.3a5db7	a3 03		lda $03,s	                LDA L_K
.3a5db9	3a		dec a		                DEC A
.3a5dba	83 03		sta $03,s	                STA L_K                     ; Decrement K
.3a5dbc	20 3f 5c	jsr $3a5c3f	            JSR FP_COMPARE
.3a5dbf	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N >= 10 ^ (D-1)?
.3a5dc2	f0 f0		beq $3a5db4	                BEQ shift_up                ; No: keep multiplying
.3a5dc4					do_digits
.3a5dc4	e2 30		sep #$30	            SEP #$30
.3a5dc6	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5dc8	0a		asl a		                ASL A
.3a5dc9	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a5dcb	2a		rol a		                ROL A
.3a5dcc	83 05		sta $05,s	                STA L_X1
.3a5dce	38		sec		                SEC
.3a5dcf	a9 96		lda #$96	                LDA #150                    ; X := 150 - X1
.3a5dd1	e3 05		sbc $05,s	                SBC L_X1
.3a5dd3	aa		tax		                TAX
.3a5dd4	f0 0f		beq $3a5de5	                BEQ emit_digits             ; If X = 0, just emit the digits
.3a5dd6	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Set the implied '1' MSB of the mantissa
.3a5dd8	09 80		ora #$80	                ORA #$80
.3a5dda	85 25		sta $0825	                STA ARGUMENT1+2
.3a5ddc	46 25		lsr $0825	shift_r         LSR ARGUMENT1+2             ; Shift the mantissa right
.3a5dde	66 24		ror $0824	                ROR ARGUMENT1+1
.3a5de0	66 23		ror $0823	                ROR ARGUMENT1
.3a5de2	ca		dex		                DEX
.3a5de3	d0 f7		bne $3a5ddc	                BNE shift_r                 ; Until X = 0
.3a5de5					emit_digits
.3a5de5	c2 10		rep #$10	            REP #$10
.3a5de7	e2 20		sep #$20	            SEP #$20
.3a5de9	64 26		stz $0826	                STZ ARGUMENT1+3             ; Blank out the MSB
.3a5deb	a9 00		lda #$00	                LDA #TYPE_INTEGER           ; Make it an integer
.3a5ded	85 27		sta $0827	                STA ARGTYPE1
.3a5def	a3 01		lda $01,s	                LDA L_NEGATIVE              ; Check IsNegative
.3a5df1	f0 11		beq $3a5e04	                BEQ get_raw_digits          ; If FALSE, just convert the raw digits
.3a5df3	c2 20		rep #$20	            REP #$20
.3a5df5	38		sec		                SEC                         ; Make the raw integer negative
.3a5df6	a9 00 00	lda #$0000	                LDA #0
.3a5df9	e5 23		sbc $0823	                SBC ARGUMENT1
.3a5dfb	85 23		sta $0823	                STA ARGUMENT1
.3a5dfd	a9 00 00	lda #$0000	                LDA #0
.3a5e00	e5 25		sbc $0825	                SBC ARGUMENT1+2
.3a5e02	85 25		sta $0825	                STA ARGUMENT1+2
.3a5e04					get_raw_digits
.3a5e04	20 1d 15	jsr $3a151d	            JSR ITOS
.3a5e07	c2 20		rep #$20	            REP #$20
.3a5e09	a5 16		lda $0816	            LDA STRPTR
.3a5e0b	85 23		sta $0823	            STA ARGUMENT1
.3a5e0d	a5 18		lda $0818	            LDA STRPTR+2
.3a5e0f	85 25		sta $0825	            STA ARGUMENT1+2
.3a5e11	20 3a 5d	jsr $3a5d3a	            JSR STRFINDEND
.3a5e14	e2 20		sep #$20	            SEP #$20
.3a5e16	c8		iny		                INY                         ; Move the NULL up one byte
.3a5e17	a9 00		lda #$00	                LDA #0
.3a5e19	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.3a5e1b	88		dey		insert_loop     DEY                         ; Move to the character before the one we just moved
.3a5e1c	88		dey		                DEY
.3a5e1d	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y           ; Get the character
.3a5e1f	c8		iny		                INY                         ; Move to the next space
.3a5e20	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Store the character here
.3a5e22	c0 02 00	cpy #$0002	                CPY #2                      ; Check to see if we just moved the 2nd character
.3a5e25	d0 f4		bne $3a5e1b	                BNE insert_loop             ; If not, keep moving the characters
.3a5e27	a9 2e		lda #$2e	                LDA #'.'                    ; Insert the '.' in the space we openned
.3a5e29	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.3a5e2b	e2 20		sep #$20	            SEP #$20
.3a5e2d	18		clc		                CLC                         ; Compute the exponent
.3a5e2e	a3 03		lda $03,s	                LDA L_K
.3a5e30	69 05		adc #$05	                ADC #(FP_D - 1)
.3a5e32	83 06		sta $06,s	                STA L_EXP
.3a5e34	f0 19		beq $3a5e4f	                BEQ done                    ; If it's 0, just return the number
.3a5e36	20 3a 5d	jsr $3a5d3a	            JSR STRFINDEND
.3a5e39	a9 45		lda #$45	                LDA #'E'                    ; Append the "E"
.3a5e3b	20 ec 5c	jsr $3a5cec	            JSR STREMIT
.3a5e3e	a3 06		lda $06,s	                LDA L_EXP
.3a5e40	20 f8 5c	jsr $3a5cf8	            JSR STREMITB
.3a5e43	80 0a		bra $3a5e4f	                BRA done                    ; TODO: reformat integer... add E and exponent...
.3a5e45					ret_result
.3a5e45	c2 20		rep #$20	            REP #$20
.3a5e47	a5 16		lda $0816	                LDA STRPTR                  ; Return the temporary string we've assembled
.3a5e49	85 23		sta $0823	                STA ARGUMENT1
.3a5e4b	a5 18		lda $0818	                LDA STRPTR+2
.3a5e4d	85 25		sta $0825	                STA ARGUMENT1+2
.3a5e4f					done
.3a5e4f	e2 20		sep #$20	            SEP #$20
.3a5e51	a9 02		lda #$02	                LDA #TYPE_STRING
.3a5e53	85 27		sta $0827	                STA ARGTYPE1
.3a5e55	c2 20		rep #$20	            REP #$20
.3a5e57	3b		tsc		                TSC                         ; Remove the locals from the stack
.3a5e58	18		clc		                CLC
.3a5e59	69 06 00	adc #$0006	                ADC #6
.3a5e5c	1b		tcs		                TCS
.3a5e5d	28		plp		                PLP
.3a5e5e	60		rts		            RTS
>3a5e5f	00 50 c3 47			ten_d_1         .dword $47c35000            ; 10^(FP_D-1), where FP_D=5
>3a5e63	00 00 80 3f			FP_1_0          .dword $3f800000    ; Floating point constant: 1.0
>3a5e67	f3 04 b5 3f			FP_SQR_2_0      .dword $3fb504f3    ; Floating point constant: sqrt(2.0)
>3a5e6b	f3 04 35 3f			FP_SQR_0_5      .dword $3f3504f3    ; Floating point constant: sqrt(0.2)

;******  Return to file: src\basic816.s


;******  Processing file: src\transcendentals.s

.3a5e6f					Q_POLY_HR
.3a5e6f	e2 20		sep #$20	            SEP #$20
.3a5e71	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a5e73	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5e77	c2 20		rep #$20	            REP #$20
.3a5e79	bd 00 00	lda $0000,x	                LDA 0,X
.3a5e7c	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5e80	bd 02 00	lda $0002,x	                LDA 2,X
.3a5e83	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5e87	88		dey		                DEY             ; (Y-1) more coefficients.
.3a5e88	e8		inx		loop            INX             ; point to the next coefficient
.3a5e89	e8		inx		                INX
.3a5e8a	e8		inx		                INX
.3a5e8b	e8		inx		                INX
.3a5e8c	e2 20		sep #$20	            SEP #$20
.3a5e8e	a9 00		lda #$00	                LDA #FP_OUT_MULT
.3a5e90	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5e94	c2 20		rep #$20	            REP #$20
.3a5e96	af 23 08 00	lda $000823	                LDA @l ARGUMENT1
.3a5e9a	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5e9e	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.3a5ea2	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5ea6	ea		nop		                NOP
.3a5ea7	ea		nop		                NOP
.3a5ea8	ea		nop		                NOP
.3a5ea9	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5ead	48		pha		                PHA
.3a5eae	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5eb2	8f 0a e2 af	sta $afe20a	                STA FP_MATH_INPUT0_HL
.3a5eb6	68		pla		                PLA
.3a5eb7	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5ebb	e2 20		sep #$20	            SEP #$20
.3a5ebd	a9 02		lda #$02	                LDA #FP_OUT_ADD
.3a5ebf	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5ec3	c2 20		rep #$20	            REP #$20
.3a5ec5	bd 00 00	lda $0000,x	                LDA 0,X
.3a5ec8	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5ecc	bd 02 00	lda $0002,x	                LDA 2,X
.3a5ecf	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5ed3	ea		nop		                NOP
.3a5ed4	ea		nop		                NOP
.3a5ed5	ea		nop		                NOP
.3a5ed6	88		dey		                DEY
.3a5ed7	f0 14		beq $3a5eed	                BEQ done
.3a5ed9	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5edd	48		pha		                PHA
.3a5ede	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5ee2	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5ee6	68		pla		                PLA
.3a5ee7	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5eeb	80 9b		bra $3a5e88	                BRA loop
.3a5eed	af 08 e2 af	lda $afe208	done            LDA @l FP_MATH_OUTPUT_FP_LL
.3a5ef1	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.3a5ef5	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5ef9	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.3a5efd	60		rts		                RTS
.3a5efe					Q_SQ
.3a5efe	e2 20		sep #$20	            SEP #$20
.3a5f00	a9 00		lda #$00	                LDA #0
.3a5f02	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5f06	a9 00		lda #$00	                LDA #FP_OUT_MULT
.3a5f08	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5f0c	c2 20		rep #$20	            REP #$20
.3a5f0e	a5 23		lda $0823	                LDA ARGUMENT1
.3a5f10	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5f14	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5f18	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.3a5f1c	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5f20	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5f24	ea		nop		                NOP
.3a5f25	ea		nop		                NOP
.3a5f26	ea		nop		                NOP
.3a5f27	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5f2b	85 23		sta $0823	                STA ARGUMENT1
.3a5f2d	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5f31	85 25		sta $0825	                STA ARGUMENT1+2
.3a5f33	60		rts		                RTS
.3a5f34					Q_INV
.3a5f34	e2 20		sep #$20	            SEP #$20
.3a5f36	a9 00		lda #$00	                LDA #0
.3a5f38	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5f3c	a9 01		lda #$01	                LDA #FP_OUT_DIV
.3a5f3e	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5f42	c2 20		rep #$20	            REP #$20
.3a5f44	a5 23		lda $0823	                LDA ARGUMENT1
.3a5f46	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5f4a	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.3a5f4e	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5f52	af 88 65 3a	lda $3a6588	                LDA @l fp_one
.3a5f56	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5f5a	af 8a 65 3a	lda $3a658a	                LDA @l fp_one+2
.3a5f5e	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5f62	ea		nop		                NOP
.3a5f63	ea		nop		                NOP
.3a5f64	ea		nop		                NOP
.3a5f65	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5f69	85 23		sta $0823	                STA ARGUMENT1
.3a5f6b	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5f6f	85 25		sta $0825	                STA ARGUMENT1+2
.3a5f71	60		rts		                RTS
.3a5f72					Q_FP_SCALE
.3a5f72	a2 00 00	ldx #$0000	                LDX #0
.3a5f75	a5 23		lda $0823	loop            LDA ARGUMENT1
.3a5f77	c5 29		cmp $0829	                CMP ARGUMENT2
.3a5f79	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5f7b	e5 2b		sbc $082b	                SBC ARGUMENT2+2
.3a5f7d	90 1e		bcc $3a5f9d	                BCC done
.3a5f7f	a5 23		lda $0823	                LDA ARGUMENT1
.3a5f81	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5f85	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5f87	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5f8b	ea		nop		                NOP
.3a5f8c	ea		nop		                NOP
.3a5f8d	ea		nop		                NOP
.3a5f8e	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5f92	85 23		sta $0823	                STA ARGUMENT1
.3a5f94	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5f98	85 25		sta $0825	                STA ARGUMENT1+2
.3a5f9a	e8		inx		                INX
.3a5f9b	80 d8		bra $3a5f75	                BRA loop
.3a5f9d					done
.3a5f9d	60		rts		            RTS
.3a5f9e					Q_FP_SCALE_TAU
.3a5f9e	e2 20		sep #$20	            SEP #$20
.3a5fa0	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a5fa2	10 09		bpl $3a5fad	                BPL notneg
.3a5fa4	29 7f		and #$7f	                AND #$7F
.3a5fa6	85 26		sta $0826	                STA ARGUMENT1+3
.3a5fa8	a9 01		lda #$01	                LDA #1
.3a5faa	48		pha		                PHA
.3a5fab	80 03		bra $3a5fb0	                BRA compute
.3a5fad	a9 00		lda #$00	notneg          LDA #0          ; not negative, so push 0.
.3a5faf	48		pha		                PHA
.3a5fb0	a9 40		lda #$40	compute         LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a5fb2	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5fb6	a9 02		lda #$02	                LDA #FP_OUT_ADD
.3a5fb8	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5fbc	c2 30		rep #$30	            REP #$30
.3a5fbe	af f0 65 3a	lda $3a65f0	                LDA @l twopi
.3a5fc2	85 29		sta $0829	                STA ARGUMENT2
.3a5fc4	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5fc8	af f2 65 3a	lda $3a65f2	                LDA @l twopi+2
.3a5fcc	85 2b		sta $082b	                STA ARGUMENT2+2
.3a5fce	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5fd2	20 72 5f	jsr $3a5f72	            JSR Q_FP_SCALE
.3a5fd5	e2 20		sep #$20	            SEP #$20
.3a5fd7	68		pla		                PLA
.3a5fd8	c2 20		rep #$20	            REP #$20
.3a5fda	f0 1e		beq $3a5ffa	                BEQ done
.3a5fdc	a5 23		lda $0823	                LDA ARGUMENT1
.3a5fde	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5fe2	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5fe4	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5fe8	ea		nop		                NOP
.3a5fe9	ea		nop		                NOP
.3a5fea	ea		nop		                NOP
.3a5feb	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5fef	85 23		sta $0823	                STA ARGUMENT1
.3a5ff1	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5ff5	29 ff 7f	and #$7fff	                AND #$7fff
.3a5ff8	85 25		sta $0825	                STA ARGUMENT1+2
.3a5ffa					done
.3a5ffa	60		rts		            RTS
.3a5ffb					Q_FP_NORM_ANGLE
.3a5ffb	5a		phy		                PHY
.3a5ffc	a2 00 00	ldx #$0000	                LDX #0
.3a5fff	a0 00 00	ldy #$0000	                LDY #0
.3a6002	a5 23		lda $0823	loop            LDA ARGUMENT1
.3a6004	df f4 65 3a	cmp $3a65f4,x	                CMP @l onepi,x
.3a6008	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a600a	ff f6 65 3a	sbc $3a65f6,x	                SBC @l onepi+2,x
.3a600e	90 2c		bcc $3a603c	                BCC less
.3a6010	bf f0 65 3a	lda $3a65f0,x	                LDA @l twopi,x
.3a6014	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a6018	bf f2 65 3a	lda $3a65f2,x	                LDA @l twopi+2,x
.3a601c	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a6020	a5 23		lda $0823	                LDA ARGUMENT1
.3a6022	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a6026	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6028	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a602c	ea		nop		                NOP
.3a602d	ea		nop		                NOP
.3a602e	ea		nop		                NOP
.3a602f	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a6033	85 23		sta $0823	                STA ARGUMENT1
.3a6035	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a6039	85 25		sta $0825	                STA ARGUMENT1+2
.3a603b	38		sec		                SEC             ; set carry to indicate a reflection
.3a603c	98		tya		less            TYA             ; carry already cleared if we branched
.3a603d	2a		rol a		                ROL             ; shift carry into flags...
.3a603e	a8		tay		                TAY             ; and store back into y
.3a603f	e8		inx		                INX             ; next set of values
.3a6040	e8		inx		                INX
.3a6041	e8		inx		                INX
.3a6042	e8		inx		                INX
.3a6043	e0 0c 00	cpx #$000c	                CPX #12         ; check if we have already looked at 3
.3a6046	d0 ba		bne $3a6002	                BNE loop
.3a6048	98		tya		                TYA             ; copy Y to X, as that's what we have
.3a6049	aa		tax		                TAX
.3a604a	7a		ply		                PLY
.3a604b	60		rts		            RTS
.3a604c					Q_FP_COS
.3a604c	08		php		                PHP
.3a604d	c2 30		rep #$30	            REP #$30
.3a604f	48		pha		                PHA
.3a6050	da		phx		                PHX
.3a6051	20 fe 5e	jsr $3a5efe	            JSR Q_SQ
.3a6054	8b		phb		                PHB
.3a6055	e2 20		sep #$20	            SEP #$20
.3a6057	a9 3a		lda #$3a	                LDA #`cos_coeff
.3a6059	48		pha		                PHA
.3a605a	ab		plb		                PLB
.3a605b	c2 20		rep #$20	            REP #$20
.3a605d	a2 30 65	ldx #$6530	                LDX #<>cos_coeff
.3a6060	5a		phy		                PHY
.3a6061	a0 05 00	ldy #$0005	                LDY #5
.3a6064	20 6f 5e	jsr $3a5e6f	            JSR Q_POLY_HR
.3a6067	7a		ply		                PLY
.3a6068	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.3a606b	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.3a606f	ab		plb		                PLB
.3a6070	fa		plx		                PLX
.3a6071	68		pla		                PLA
.3a6072	28		plp		                PLP
.3a6073	60		rts		            RTS
.3a6074					Q_FP_SIN
.3a6074	08		php		                PHP
.3a6075	c2 30		rep #$30	            REP #$30
.3a6077	48		pha		                PHA
.3a6078	da		phx		                PHX
.3a6079	a5 23		lda $0823	                LDA ARGUMENT1
.3a607b	85 29		sta $0829	                STA ARGUMENT2
.3a607d	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a607f	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6081	20 fe 5e	jsr $3a5efe	            JSR Q_SQ
.3a6084	8b		phb		                PHB
.3a6085	e2 20		sep #$20	            SEP #$20
.3a6087	a9 3a		lda #$3a	                LDA #`sin_coeff
.3a6089	48		pha		                PHA
.3a608a	ab		plb		                PLB
.3a608b	c2 20		rep #$20	            REP #$20
.3a608d	a2 44 65	ldx #$6544	                LDX #<>sin_coeff
.3a6090	5a		phy		                PHY
.3a6091	a0 05 00	ldy #$0005	                LDY #5
.3a6094	20 6f 5e	jsr $3a5e6f	            JSR Q_POLY_HR
.3a6097	7a		ply		                PLY
.3a6098	ab		plb		                PLB
.3a6099	20 d9 56	jsr $3a56d9	            JSR OP_FP_MUL
.3a609c	fa		plx		                PLX
.3a609d	68		pla		                PLA
.3a609e	28		plp		                PLP
.3a609f	60		rts		            RTS
.3a60a0					Q_FP_TAN
.3a60a0	08		php		                PHP
.3a60a1	c2 30		rep #$30	            REP #$30
.3a60a3	48		pha		                PHA
.3a60a4	da		phx		                PHX
.3a60a5	a5 23		lda $0823	                LDA ARGUMENT1
.3a60a7	85 29		sta $0829	                STA ARGUMENT2
.3a60a9	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a60ab	85 2b		sta $082b	                STA ARGUMENT2+2
.3a60ad	20 fe 5e	jsr $3a5efe	            JSR Q_SQ
.3a60b0	8b		phb		                PHB
.3a60b1	e2 20		sep #$20	            SEP #$20
.3a60b3	a9 3a		lda #$3a	                LDA #`tan_coeff
.3a60b5	48		pha		                PHA
.3a60b6	ab		plb		                PLB
.3a60b7	c2 20		rep #$20	            REP #$20
.3a60b9	a2 58 65	ldx #$6558	                LDX #<>tan_coeff
.3a60bc	5a		phy		                PHY
.3a60bd	a0 05 00	ldy #$0005	                LDY #5
.3a60c0	20 6f 5e	jsr $3a5e6f	            JSR Q_POLY_HR
.3a60c3	7a		ply		                PLY
.3a60c4	ab		plb		                PLB
.3a60c5	20 d9 56	jsr $3a56d9	            JSR OP_FP_MUL
.3a60c8	fa		plx		                PLX
.3a60c9	68		pla		                PLA
.3a60ca	28		plp		                PLP
.3a60cb	60		rts		            RTS
.3a60cc					Q_FP_LN
.3a60cc	08		php		                PHP
.3a60cd	c2 30		rep #$30	            REP #$30
.3a60cf	48		pha		                PHA
.3a60d0	da		phx		                PHX
.3a60d1	e2 20		sep #$20	            SEP #$20
.3a60d3	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a60d5	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a60d9	a9 02		lda #$02	                LDA #FP_OUT_ADD
.3a60db	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a60df	c2 20		rep #$20	            REP #$20
.3a60e1	a5 23		lda $0823	                LDA ARGUMENT1
.3a60e3	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a60e7	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a60e9	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a60ed	af 88 65 3a	lda $3a6588	                LDA @l fp_one
.3a60f1	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a60f5	af 8a 65 3a	lda $3a658a	                LDA @l fp_one+2
.3a60f9	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a60fd	ea		nop		                NOP
.3a60fe	ea		nop		                NOP
.3a60ff	ea		nop		                NOP
.3a6100	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a6104	85 0c		sta $080c	                STA SCRATCH
.3a6106	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a610a	85 0e		sta $080e	                STA SCRATCH+2
.3a610c	e2 20		sep #$20	            SEP #$20
.3a610e	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a6110	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a6114	c2 20		rep #$20	            REP #$20
.3a6116	ea		nop		                NOP
.3a6117	ea		nop		                NOP
.3a6118	ea		nop		                NOP
.3a6119	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a611d	85 10		sta $0810	                STA SCRATCH2
.3a611f	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a6123	85 12		sta $0812	                STA SCRATCH2+2
.3a6125	e2 20		sep #$20	            SEP #$20
.3a6127	a9 01		lda #$01	                LDA #FP_OUT_DIV
.3a6129	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a612d	c2 20		rep #$20	            REP #$20
.3a612f	a5 0c		lda $080c	                LDA SCRATCH
.3a6131	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a6135	a5 0e		lda $080e	                LDA SCRATCH+2
.3a6137	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a613b	a5 10		lda $0810	                LDA SCRATCH2
.3a613d	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a6141	a5 12		lda $0812	                LDA SCRATCH2+2
.3a6143	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a6147	ea		nop		                NOP
.3a6148	ea		nop		                NOP
.3a6149	ea		nop		                NOP
.3a614a	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a614e	85 23		sta $0823	                STA ARGUMENT1
.3a6150	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a6154	85 25		sta $0825	                STA ARGUMENT1+2
.3a6156	e2 20		sep #$20	            SEP #$20
.3a6158	a9 08		lda #$08	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX0
.3a615a	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a615e	a9 02		lda #$02	                LDA #FP_OUT_ADD
.3a6160	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a6164	c2 20		rep #$20	            REP #$20
.3a6166	a5 23		lda $0823	                LDA ARGUMENT1
.3a6168	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a616c	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a616e	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a6172	ea		nop		                NOP
.3a6173	ea		nop		                NOP
.3a6174	ea		nop		                NOP
.3a6175	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a6179	85 29		sta $0829	                STA ARGUMENT2
.3a617b	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a617f	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6181	20 fe 5e	jsr $3a5efe	            JSR Q_SQ
.3a6184	8b		phb		                PHB
.3a6185	e2 20		sep #$20	            SEP #$20
.3a6187	a9 3a		lda #$3a	                LDA #`ln_coeff
.3a6189	48		pha		                PHA
.3a618a	ab		plb		                PLB
.3a618b	c2 20		rep #$20	            REP #$20
.3a618d	a2 6c 65	ldx #$656c	                LDX #<>ln_coeff
.3a6190	5a		phy		                PHY
.3a6191	a0 08 00	ldy #$0008	                LDY #8
.3a6194	20 6f 5e	jsr $3a5e6f	            JSR Q_POLY_HR
.3a6197	7a		ply		                PLY
.3a6198	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.3a619b	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.3a619f	8f 2d 08 00	sta $00082d	                STA @l ARGTYPE2
.3a61a3	20 d9 56	jsr $3a56d9	            JSR OP_FP_MUL
.3a61a6	ab		plb		                PLB
.3a61a7	fa		plx		                PLX
.3a61a8	68		pla		                PLA
.3a61a9	28		plp		                PLP
.3a61aa	60		rts		            RTS
.3a61ab					FP_SIN
.3a61ab	08		php		                PHP
.3a61ac	c2 30		rep #$30	            REP #$30
.3a61ae	48		pha		                PHA
.3a61af	da		phx		                PHX
.3a61b0	20 9e 5f	jsr $3a5f9e	            JSR Q_FP_SCALE_TAU
.3a61b3	20 fb 5f	jsr $3a5ffb	            JSR Q_FP_NORM_ANGLE
.3a61b6	da		phx		                PHX
.3a61b7	8a		txa		                TXA
.3a61b8	29 01 00	and #$0001	                AND #1
.3a61bb	d0 05		bne $3a61c2	                BNE do_cos
.3a61bd	20 74 60	jsr $3a6074	            JSR Q_FP_SIN
.3a61c0	80 03		bra $3a61c5	                BRA maybe_neg
.3a61c2					do_cos
.3a61c2	20 4c 60	jsr $3a604c	            JSR Q_FP_COS
.3a61c5	fa		plx		maybe_neg       PLX
.3a61c6	8a		txa		                TXA
.3a61c7	29 04 00	and #$0004	                AND #4
.3a61ca	f0 0a		beq $3a61d6	                BEQ done
.3a61cc	e2 20		sep #$20	            SEP #$20
.3a61ce	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a61d0	09 80		ora #$80	                ORA #$80
.3a61d2	85 26		sta $0826	                STA ARGUMENT1+3
.3a61d4	c2 20		rep #$20	            REP #$20
.3a61d6	fa		plx		done            PLX
.3a61d7	68		pla		                PLA
.3a61d8	28		plp		                PLP
.3a61d9	60		rts		            RTS
.3a61da					FP_COS
.3a61da	08		php		                PHP
.3a61db	c2 30		rep #$30	            REP #$30
.3a61dd	48		pha		                PHA
.3a61de	da		phx		                PHX
.3a61df	20 9e 5f	jsr $3a5f9e	            JSR Q_FP_SCALE_TAU
.3a61e2	20 fb 5f	jsr $3a5ffb	            JSR Q_FP_NORM_ANGLE
.3a61e5	da		phx		                PHX
.3a61e6	8a		txa		                TXA
.3a61e7	29 01 00	and #$0001	                AND #1
.3a61ea	d0 05		bne $3a61f1	                BNE do_sin
.3a61ec	20 4c 60	jsr $3a604c	            JSR Q_FP_COS
.3a61ef	80 03		bra $3a61f4	                BRA maybe_neg
.3a61f1					do_sin
.3a61f1	20 74 60	jsr $3a6074	            JSR Q_FP_SIN
.3a61f4	fa		plx		maybe_neg       PLX
.3a61f5	8a		txa		                TXA
.3a61f6	29 02 00	and #$0002	                AND #2
.3a61f9	f0 0a		beq $3a6205	                BEQ done
.3a61fb	e2 20		sep #$20	            SEP #$20
.3a61fd	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a61ff	09 80		ora #$80	                ORA #$80
.3a6201	85 26		sta $0826	                STA ARGUMENT1+3
.3a6203	c2 20		rep #$20	            REP #$20
.3a6205	fa		plx		done            PLX
.3a6206	68		pla		                PLA
.3a6207	28		plp		                PLP
.3a6208	60		rts		            RTS
.3a6209					FP_TAN
.3a6209	08		php		                PHP
.3a620a	c2 30		rep #$30	            REP #$30
.3a620c	48		pha		                PHA
.3a620d	da		phx		                PHX
.3a620e	20 9e 5f	jsr $3a5f9e	            JSR Q_FP_SCALE_TAU
.3a6211	20 fb 5f	jsr $3a5ffb	            JSR Q_FP_NORM_ANGLE
.3a6214	20 a0 60	jsr $3a60a0	            JSR Q_FP_TAN
.3a6217	8a		txa		                TXA
.3a6218	29 01 00	and #$0001	                AND #1
.3a621b	f0 03		beq $3a6220	                BEQ no_inv
.3a621d	20 34 5f	jsr $3a5f34	            JSR Q_INV
.3a6220	8a		txa		no_inv          TXA
.3a6221	e2 20		sep #$20	            SEP #$20
.3a6223	4a		lsr a		                LSR
.3a6224	4a		lsr a		                LSR
.3a6225	69 00		adc #$00	                ADC #0
.3a6227	29 01		and #$01	                AND #1
.3a6229	f0 06		beq $3a6231	                BEQ no_neg
.3a622b	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a622d	09 80		ora #$80	                ORA #$80
.3a622f	85 26		sta $0826	                STA ARGUMENT1+3
.3a6231					no_neg
.3a6231	c2 20		rep #$20	            REP #$20
.3a6233	fa		plx		                PLX
.3a6234	68		pla		                PLA
.3a6235	28		plp		                PLP
.3a6236	60		rts		            RTS
.3a6237					FP_LN
.3a6237	08		php		                PHP
.3a6238	c2 30		rep #$30	            REP #$30
.3a623a	48		pha		                PHA
.3a623b	da		phx		                PHX
.3a623c	5a		phy		                PHY
.3a623d	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a623f	10 1f		bpl $3a6260	                BPL arg_ok
.3a6241	08		php		            PHP
.3a6242	c2 20		rep #$20	            REP #$20
.3a6244	48		pha		            PHA
.3a6245	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6248	5b		tcd		            TCD
.3a6249	68		pla		            PLA
.3a624a	28		plp		            PLP
.3a624b	e2 20		sep #$20	            SEP #$20
.3a624d	a9 17		lda #$17	            LDA #ERR_DOMAIN
.3a624f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6253	c2 20		rep #$20	            REP #$20
.3a6255	29 ff 00	and #$00ff	            AND #$00FF
.3a6258	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a625b	e2 20		sep #$20	            SEP #$20
.3a625d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6260					arg_ok
.3a6260	c2 30		rep #$30	            REP #$30
.3a6262	a5 23		lda $0823	                LDA ARGUMENT1
.3a6264	cf 88 65 3a	cmp $3a6588	                CMP @l fp_one
.3a6268	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a626a	cf 8a 65 3a	cmp $3a658a	                CMP @l fp_one+2
.3a626e	b0 04		bcs $3a6274	                BCS gtone
.3a6270	20 34 5f	jsr $3a5f34	            JSR Q_INV
.3a6273	18		clc		                CLC
.3a6274	a9 00 00	lda #$0000	gtone           LDA #0
.3a6277	a8		tay		                TAY
.3a6278	2a		rol a		                ROL             ; Rotate Carry into A; 0 means negate
.3a6279	48		pha		                PHA
.3a627a	e2 20		sep #$20	            SEP #$20
.3a627c	a9 00		lda #$00	                LDA #0
.3a627e	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a6282	a9 01		lda #$01	                LDA #FP_OUT_DIV
.3a6284	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a6288	c2 20		rep #$20	            REP #$20
.3a628a	af e0 65 3a	lda $3a65e0	                LDA @l eexp64
.3a628e	85 29		sta $0829	                STA ARGUMENT2
.3a6290	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a6294	af e2 65 3a	lda $3a65e2	                LDA @l eexp64+2
.3a6298	85 2b		sta $082b	                STA ARGUMENT2+2
.3a629a	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a629e	20 72 5f	jsr $3a5f72	            JSR Q_FP_SCALE
.3a62a1	8a		txa		                TXA
.3a62a2	f0 07		beq $3a62ab	                BEQ chk16
.3a62a4	0a		asl a		                ASL             ; multiply counter by 64
.3a62a5	0a		asl a		                ASL
.3a62a6	0a		asl a		                ASL
.3a62a7	0a		asl a		                ASL
.3a62a8	0a		asl a		                ASL
.3a62a9	0a		asl a		                ASL
.3a62aa	a8		tay		                TAY
.3a62ab	af e4 65 3a	lda $3a65e4	chk16           LDA @l eexp16
.3a62af	85 29		sta $0829	                STA ARGUMENT2
.3a62b1	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a62b5	af e6 65 3a	lda $3a65e6	                LDA @l eexp16+2
.3a62b9	85 2b		sta $082b	                STA ARGUMENT2+2
.3a62bb	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a62bf	20 72 5f	jsr $3a5f72	            JSR Q_FP_SCALE
.3a62c2	8a		txa		                TXA
.3a62c3	f0 0b		beq $3a62d0	                BEQ chk04
.3a62c5	0a		asl a		                ASL             ; multiply counter by 16
.3a62c6	0a		asl a		                ASL
.3a62c7	0a		asl a		                ASL
.3a62c8	0a		asl a		                ASL
.3a62c9	85 29		sta $0829	                STA ARGUMENT2   ; and add into total
.3a62cb	18		clc		                CLC
.3a62cc	98		tya		                TYA
.3a62cd	65 29		adc $0829	                ADC ARGUMENT2
.3a62cf	a8		tay		                TAY
.3a62d0	af e8 65 3a	lda $3a65e8	chk04           LDA @l eexp04
.3a62d4	85 29		sta $0829	                STA ARGUMENT2
.3a62d6	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a62da	af ea 65 3a	lda $3a65ea	                LDA @l eexp04+2
.3a62de	85 2b		sta $082b	                STA ARGUMENT2+2
.3a62e0	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a62e4	20 72 5f	jsr $3a5f72	            JSR Q_FP_SCALE
.3a62e7	8a		txa		                TXA
.3a62e8	f0 09		beq $3a62f3	                BEQ chk01
.3a62ea	0a		asl a		                ASL             ;multiply counter by 4
.3a62eb	0a		asl a		                ASL
.3a62ec	85 29		sta $0829	                STA ARGUMENT2   ;and add to total
.3a62ee	18		clc		                CLC
.3a62ef	98		tya		                TYA
.3a62f0	65 29		adc $0829	                ADC ARGUMENT2
.3a62f2	a8		tay		                TAY
.3a62f3	af ec 65 3a	lda $3a65ec	chk01           LDA @l eexp01
.3a62f7	85 29		sta $0829	                STA ARGUMENT2
.3a62f9	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a62fd	af ee 65 3a	lda $3a65ee	                LDA @l eexp01+2
.3a6301	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6303	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a6307	20 72 5f	jsr $3a5f72	            JSR Q_FP_SCALE
.3a630a	86 29		stx $0829	                STX ARGUMENT2   ; add counter to total
.3a630c	18		clc		                CLC
.3a630d	98		tya		                TYA
.3a630e	65 29		adc $0829	                ADC ARGUMENT2
.3a6310	a8		tay		                TAY
.3a6311	20 cc 60	jsr $3a60cc	            JSR Q_FP_LN
.3a6314	a5 23		lda $0823	                LDA ARGUMENT1
.3a6316	85 29		sta $0829	                STA ARGUMENT2
.3a6318	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a631a	85 2b		sta $082b	                STA ARGUMENT2+2
.3a631c	98		tya		                TYA
.3a631d	85 23		sta $0823	                STA ARGUMENT1
.3a631f	64 25		stz $0825	                STZ ARGUMENT1+2
.3a6321	20 66 5b	jsr $3a5b66	            JSR ITOF
.3a6324	20 43 56	jsr $3a5643	            JSR OP_FP_ADD
.3a6327	68		pla		                PLA
.3a6328	d0 07		bne $3a6331	                BNE done
.3a632a	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a632c	09 00 80	ora #$8000	                ORA #$8000
.3a632f	85 25		sta $0825	                STA ARGUMENT1+2
.3a6331	7a		ply		done            PLY
.3a6332	fa		plx		                PLX
.3a6333	68		pla		                PLA
.3a6334	28		plp		                PLP
.3a6335	60		rts		            RTS
.3a6336					FP_ASIN
.3a6336	08		php		                PHP
.3a6337	c2 30		rep #$30	            REP #$30
.3a6339	48		pha		                PHA
.3a633a	da		phx		                PHX
.3a633b	a5 23		lda $0823	                LDA ARGUMENT1
.3a633d	85 29		sta $0829	                STA ARGUMENT2
.3a633f	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6341	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6343	20 fe 5e	jsr $3a5efe	            JSR Q_SQ
.3a6346	8b		phb		                PHB
.3a6347	e2 20		sep #$20	            SEP #$20
.3a6349	a9 3a		lda #$3a	                LDA #`asin_coeff
.3a634b	48		pha		                PHA
.3a634c	ab		plb		                PLB
.3a634d	c2 20		rep #$20	            REP #$20
.3a634f	a2 90 65	ldx #$6590	                LDX #<>asin_coeff
.3a6352	a0 05 00	ldy #$0005	                LDY #5
.3a6355	20 6f 5e	jsr $3a5e6f	            JSR Q_POLY_HR
.3a6358	ab		plb		                PLB
.3a6359	20 d9 56	jsr $3a56d9	            JSR OP_FP_MUL
.3a635c	fa		plx		                PLX
.3a635d	68		pla		                PLA
.3a635e	28		plp		                PLP
.3a635f	60		rts		            RTS
.3a6360					FP_ACOS
.3a6360	08		php		                PHP
.3a6361	c2 30		rep #$30	            REP #$30
.3a6363	48		pha		                PHA
.3a6364	da		phx		                PHX
.3a6365	20 36 63	jsr $3a6336	            JSR FP_ASIN
.3a6368	af f8 65 3a	lda $3a65f8	                LDA @l halfpi
.3a636c	85 29		sta $0829	                STA ARGUMENT2
.3a636e	af fa 65 3a	lda $3a65fa	                LDA @l halfpi+2
.3a6372	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6374	20 38 56	jsr $3a5638	            JSR OP_FP_SUB
.3a6377	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6379	49 00 80	eor #$8000	                EOR #$8000
.3a637c	85 25		sta $0825	                STA ARGUMENT1+2
.3a637e	fa		plx		                PLX
.3a637f	68		pla		                PLA
.3a6380	28		plp		                PLP
.3a6381	60		rts		            RTS
.3a6382					FP_ATAN
.3a6382	08		php		                PHP
.3a6383	c2 30		rep #$30	            REP #$30
.3a6385	48		pha		                PHA
.3a6386	da		phx		                PHX
.3a6387	a5 23		lda $0823	                LDA ARGUMENT1
.3a6389	85 29		sta $0829	                STA ARGUMENT2
.3a638b	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a638d	85 2b		sta $082b	                STA ARGUMENT2+2
.3a638f	20 fe 5e	jsr $3a5efe	            JSR Q_SQ
.3a6392	8b		phb		                PHB
.3a6393	e2 20		sep #$20	            SEP #$20
.3a6395	a9 3a		lda #$3a	                LDA #`atan_coeff
.3a6397	48		pha		                PHA
.3a6398	ab		plb		                PLB
.3a6399	c2 20		rep #$20	            REP #$20
.3a639b	a2 a4 65	ldx #$65a4	                LDX #<>atan_coeff
.3a639e	a0 05 00	ldy #$0005	                LDY #5
.3a63a1	20 6f 5e	jsr $3a5e6f	            JSR Q_POLY_HR
.3a63a4	ab		plb		                PLB
.3a63a5	20 d9 56	jsr $3a56d9	            JSR OP_FP_MUL
.3a63a8	fa		plx		                PLX
.3a63a9	68		pla		                PLA
.3a63aa	28		plp		                PLP
.3a63ab	60		rts		            RTS
.3a63ac					Q_FP_POW_INT
.3a63ac	c2 20		rep #$20	            REP #$20
.3a63ae	a5 23		lda $0823	            LDA ARGUMENT1
.3a63b0	85 29		sta $0829	            STA ARGUMENT2
.3a63b2	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a63b4	85 2b		sta $082b	            STA ARGUMENT2+2
.3a63b6	c2 20		rep #$20	            REP #$20
.3a63b8	af 88 65 3a	lda $3a6588	            LDA @l fp_one
.3a63bc	85 23		sta $0823	            STA ARGUMENT1
.3a63be	af 8a 65 3a	lda $3a658a	            LDA @l fp_one+2
.3a63c2	85 25		sta $0825	            STA ARGUMENT1+2
.3a63c4	8a		txa		loop            TXA
.3a63c5	f0 30		beq $3a63f7	                BEQ done
.3a63c7	4a		lsr a		                LSR
.3a63c8	aa		tax		                TAX
.3a63c9	90 03		bcc $3a63ce	                BCC next
.3a63cb	20 d9 56	jsr $3a56d9	            JSR OP_FP_MUL
.3a63ce					next
.3a63ce	c2 20		rep #$20	            REP #$20
.3a63d0	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a63d2	48		pha		            PHA
.3a63d3	a5 23		lda $0823	            LDA ARGUMENT1
.3a63d5	48		pha		            PHA
.3a63d6	c2 20		rep #$20	            REP #$20
.3a63d8	a5 29		lda $0829	            LDA ARGUMENT2
.3a63da	85 23		sta $0823	            STA ARGUMENT1
.3a63dc	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a63de	85 25		sta $0825	            STA ARGUMENT1+2
.3a63e0	20 fe 5e	jsr $3a5efe	            JSR Q_SQ
.3a63e3	c2 20		rep #$20	            REP #$20
.3a63e5	a5 23		lda $0823	            LDA ARGUMENT1
.3a63e7	85 29		sta $0829	            STA ARGUMENT2
.3a63e9	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a63eb	85 2b		sta $082b	            STA ARGUMENT2+2
.3a63ed	c2 20		rep #$20	            REP #$20
.3a63ef	68		pla		            PLA
.3a63f0	85 23		sta $0823	            STA ARGUMENT1
.3a63f2	68		pla		            PLA
.3a63f3	85 25		sta $0825	            STA ARGUMENT1+2
.3a63f5	80 cd		bra $3a63c4	                BRA loop
.3a63f7					done
.3a63f7	60		rts		            RTS
.3a63f8					Q_FP_EXP
.3a63f8	08		php		                PHP
.3a63f9	c2 30		rep #$30	            REP #$30
.3a63fb	48		pha		                PHA
.3a63fc	da		phx		                PHX
.3a63fd	8b		phb		                PHB
.3a63fe	e2 20		sep #$20	            SEP #$20
.3a6400	a9 3a		lda #$3a	                LDA #`exp_coeff
.3a6402	48		pha		                PHA
.3a6403	ab		plb		                PLB
.3a6404	c2 20		rep #$20	            REP #$20
.3a6406	a2 b8 65	ldx #$65b8	                LDX #<>exp_coeff
.3a6409	5a		phy		                PHY
.3a640a	a0 0a 00	ldy #$000a	                LDY #10
.3a640d	20 6f 5e	jsr $3a5e6f	            JSR Q_POLY_HR
.3a6410	7a		ply		                PLY
.3a6411	ab		plb		                PLB
.3a6412	fa		plx		                PLX
.3a6413	68		pla		                PLA
.3a6414	28		plp		                PLP
.3a6415	60		rts		            RTS
.3a6416					FP_EXP
.3a6416	08		php		                PHP
.3a6417	c2 30		rep #$30	            REP #$30
.3a6419	48		pha		                PHA
.3a641a	da		phx		                PHX
.3a641b	5a		phy		                PHY
.3a641c	a5 23		lda $0823	                LDA ARGUMENT1   ; special case for x==0
.3a641e	05 25		ora $0825	                ORA ARGUMENT1+2
.3a6420	d0 10		bne $3a6432	                BNE notzero
.3a6422	c2 20		rep #$20	            REP #$20
.3a6424	af 88 65 3a	lda $3a6588	            LDA @l fp_one
.3a6428	85 23		sta $0823	            STA ARGUMENT1
.3a642a	af 8a 65 3a	lda $3a658a	            LDA @l fp_one+2
.3a642e	85 25		sta $0825	            STA ARGUMENT1+2
.3a6430	80 61		bra $3a6493	                BRA done
.3a6432	a5 25		lda $0825	notzero         LDA ARGUMENT1+2 ; check if negative
.3a6434	29 00 80	and #$8000	                AND #$8000
.3a6437	a8		tay		                TAY             ; Y != 0 -> arg was negative
.3a6438	f0 07		beq $3a6441	                BEQ notneg
.3a643a	a5 25		lda $0825	                LDA ARGUMENT1+2 ; negate x
.3a643c	29 ff 7f	and #$7fff	                AND #$7FFF
.3a643f	85 25		sta $0825	                STA ARGUMENT1+2
.3a6441					notneg
.3a6441	c2 20		rep #$20	            REP #$20
.3a6443	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a6445	48		pha		            PHA
.3a6446	a5 23		lda $0823	            LDA ARGUMENT1
.3a6448	48		pha		            PHA
.3a6449	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a644c	a6 23		ldx $0823	                LDX ARGUMENT1              ; INT(x) now in ARGUMENT1; low 16 bits into X
.3a644e	20 84 07	jsr $3a0784	            JSR ASS_ARG1_FLOAT
.3a6451	c2 20		rep #$20	            REP #$20
.3a6453	a5 23		lda $0823	            LDA ARGUMENT1
.3a6455	85 29		sta $0829	            STA ARGUMENT2
.3a6457	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a6459	85 2b		sta $082b	            STA ARGUMENT2+2
.3a645b	c2 20		rep #$20	            REP #$20
.3a645d	68		pla		            PLA
.3a645e	85 23		sta $0823	            STA ARGUMENT1
.3a6460	68		pla		            PLA
.3a6461	85 25		sta $0825	            STA ARGUMENT1+2
.3a6463	20 38 56	jsr $3a5638	            JSR OP_FP_SUB
.3a6466	20 f8 63	jsr $3a63f8	            JSR Q_FP_EXP
.3a6469	c2 20		rep #$20	            REP #$20
.3a646b	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a646d	48		pha		            PHA
.3a646e	a5 23		lda $0823	            LDA ARGUMENT1
.3a6470	48		pha		            PHA
.3a6471	c2 20		rep #$20	            REP #$20
.3a6473	af ec 65 3a	lda $3a65ec	            LDA @leexp01
.3a6477	85 23		sta $0823	            STA ARGUMENT1
.3a6479	af ee 65 3a	lda $3a65ee	            LDA @leexp01+2
.3a647d	85 25		sta $0825	            STA ARGUMENT1+2
.3a647f	20 ac 63	jsr $3a63ac	            JSR Q_FP_POW_INT
.3a6482	c2 20		rep #$20	            REP #$20
.3a6484	68		pla		            PLA
.3a6485	85 29		sta $0829	            STA ARGUMENT2
.3a6487	68		pla		            PLA
.3a6488	85 2b		sta $082b	            STA ARGUMENT2+2
.3a648a	20 d9 56	jsr $3a56d9	            JSR OP_FP_MUL
.3a648d	98		tya		                TYA
.3a648e	f0 03		beq $3a6493	                BEQ done
.3a6490	20 34 5f	jsr $3a5f34	            JSR Q_INV
.3a6493	7a		ply		done            PLY
.3a6494	fa		plx		                PLX
.3a6495	68		pla		                PLA
.3a6496	28		plp		                PLP
.3a6497	60		rts		            RTS
.3a6498					FP_SQR
.3a6498	08		php		                PHP
.3a6499	c2 30		rep #$30	            REP #$30
.3a649b	48		pha		                PHA
.3a649c	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a649e	10 1f		bpl $3a64bf	                BPL arg_ok
.3a64a0	08		php		            PHP
.3a64a1	c2 20		rep #$20	            REP #$20
.3a64a3	48		pha		            PHA
.3a64a4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a64a7	5b		tcd		            TCD
.3a64a8	68		pla		            PLA
.3a64a9	28		plp		            PLP
.3a64aa	e2 20		sep #$20	            SEP #$20
.3a64ac	a9 17		lda #$17	            LDA #ERR_DOMAIN
.3a64ae	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a64b2	c2 20		rep #$20	            REP #$20
.3a64b4	29 ff 00	and #$00ff	            AND #$00FF
.3a64b7	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a64ba	e2 20		sep #$20	            SEP #$20
.3a64bc	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a64bf					arg_ok
.3a64bf	c2 30		rep #$30	            REP #$30
.3a64c1	05 23		ora $0823	                ORA ARGUMENT1
.3a64c3	f0 68		beq $3a652d	                BEQ done
.3a64c5	c2 20		rep #$20	            REP #$20
.3a64c7	af 8c 65 3a	lda $3a658c	            LDA @l fp_two
.3a64cb	85 29		sta $0829	            STA ARGUMENT2
.3a64cd	af 8e 65 3a	lda $3a658e	            LDA @l fp_two+2
.3a64d1	85 2b		sta $082b	            STA ARGUMENT2+2
.3a64d3	e2 20		sep #$20	            SEP #$20
.3a64d5	a9 01		lda #$01	                LDA #TYPE_FLOAT
.3a64d7	85 2d		sta $082d	                STA ARGTYPE2
.3a64d9	c2 20		rep #$20	            REP #$20
.3a64db	c2 20		rep #$20	            REP #$20
.3a64dd	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a64df	48		pha		            PHA
.3a64e0	a5 23		lda $0823	            LDA ARGUMENT1
.3a64e2	48		pha		            PHA
.3a64e3					loop
.3a64e3	20 8e 56	jsr $3a568e	            JSR OP_FP_DIV
.3a64e6	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a64e8	c5 2b		cmp $082b	                CMP ARGUMENT2+2
.3a64ea	d0 09		bne $3a64f5	                BNE more
.3a64ec	a5 23		lda $0823	                LDA ARGUMENT1
.3a64ee	45 29		eor $0829	                EOR ARGUMENT2
.3a64f0	29 f8 ff	and #$fff8	                AND #$FFF8
.3a64f3	f0 30		beq $3a6525	                BEQ exitloop
.3a64f5					more
.3a64f5	20 43 56	jsr $3a5643	            JSR OP_FP_ADD
.3a64f8	c2 20		rep #$20	            REP #$20
.3a64fa	af 8c 65 3a	lda $3a658c	            LDA @l fp_two
.3a64fe	85 29		sta $0829	            STA ARGUMENT2
.3a6500	af 8e 65 3a	lda $3a658e	            LDA @l fp_two+2
.3a6504	85 2b		sta $082b	            STA ARGUMENT2+2
.3a6506	20 8e 56	jsr $3a568e	            JSR OP_FP_DIV
.3a6509	c2 20		rep #$20	            REP #$20
.3a650b	a5 23		lda $0823	            LDA ARGUMENT1
.3a650d	85 29		sta $0829	            STA ARGUMENT2
.3a650f	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a6511	85 2b		sta $082b	            STA ARGUMENT2+2
.3a6513	c2 20		rep #$20	            REP #$20
.3a6515	68		pla		            PLA
.3a6516	85 23		sta $0823	            STA ARGUMENT1
.3a6518	68		pla		            PLA
.3a6519	85 25		sta $0825	            STA ARGUMENT1+2
.3a651b	c2 20		rep #$20	            REP #$20
.3a651d	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a651f	48		pha		            PHA
.3a6520	a5 23		lda $0823	            LDA ARGUMENT1
.3a6522	48		pha		            PHA
.3a6523	80 be		bra $3a64e3	                BRA loop
.3a6525					exitloop
.3a6525	c2 20		rep #$20	            REP #$20
.3a6527	68		pla		            PLA
.3a6528	85 29		sta $0829	            STA ARGUMENT2
.3a652a	68		pla		            PLA
.3a652b	85 2b		sta $082b	            STA ARGUMENT2+2
.3a652d	68		pla		done            PLA
.3a652e	28		plp		                PLP
.3a652f	60		rts		            RTS
.3a6530					cos_coeff
>3a6530	01 0d d0 37			                .dword $37D00D01
>3a6534	61 0b b6 ba			                .dword $BAB60B61
>3a6538	ab aa 2a 3d			                .dword $3D2AAAAB
>3a653c	00 00 00 bf			                .dword $BF000000
>3a6540	00 00 80 3f			                .dword $3F800000
.3a6544					sin_coeff
>3a6544	1d ef 38 36			                .dword $3638EF1D
>3a6548	01 0d 50 b9			                .dword $B9500D01
>3a654c	89 88 08 3c			                .dword $3C088889
>3a6550	ab aa 2a be			                .dword $BE2AAAAB
>3a6554	00 00 80 3f			                .dword $3F800000
.3a6558					tan_coeff
>3a6558	a4 27 b3 3c			                .dword $3CB327A4
>3a655c	d1 0d 5d 3d			                .dword $3D5D0DD1
>3a6560	89 88 08 3e			                .dword $3E088889
>3a6564	ab aa aa 3e			                .dword $3EAAAAAB
>3a6568	00 00 80 3f			                .dword $3F800000
.3a656c					ln_coeff
>3a656c	89 88 88 3d			                .dword $3D888889
>3a6570	d9 89 9d 3d			                .dword $3D9D89D9
>3a6574	8c 2e ba 3d			                .dword $3DBA2E8C
>3a6578	39 8e e3 3d			                .dword $3DE38E39
>3a657c	25 49 12 3e			                .dword $3E124925
>3a6580	cd cc 4c 3e			                .dword $3E4CCCCD
>3a6584	ab aa aa 3e			                .dword $3EAAAAAB
>3a6588	00 00 80 3f			fp_one          .dword $3F800000
>3a658c	00 00 00 40			fp_two          .dword $40000000
.3a6590					asin_coeff
>3a6590	8e e3 f8 3c			                .dword $3CF8E38E
>3a6594	6e db 36 3d			                .dword $3D36DB6E
>3a6598	9a 99 99 3d			                .dword $3D99999A
>3a659c	ab aa 2a 3e			                .dword $3E2AAAAB
>3a65a0	00 00 80 3f			                .dword $3F800000
.3a65a4					atan_coeff
>3a65a4	39 8e e3 3d			                .dword $3DE38E39
>3a65a8	25 49 12 be			                .dword $BE124925
>3a65ac	cd cc 4c 3e			                .dword $3E4CCCCD
>3a65b0	ab aa aa be			                .dword $BEAAAAAB
>3a65b4	00 00 80 3f			                .dword $3F800000
.3a65b8					exp_coeff
>3a65b8	1d ef 38 36			        .dword $3638EF1D
>3a65bc	01 0d d0 37			        .dword $37D00D01
>3a65c0	01 0d 50 39			        .dword $39500D01
>3a65c4	61 0b b6 3a			        .dword $3AB60B61
>3a65c8	89 88 08 3c			        .dword $3C088889
>3a65cc	ab aa 2a 3d			        .dword $3D2AAAAB
>3a65d0	ab aa 2a 3e			        .dword $3E2AAAAB
>3a65d4	00 00 00 3f			        .dword $3F000000
>3a65d8	00 00 80 3f			        .dword $3F800000
>3a65dc	00 00 80 3f			        .dword $3F800000
>3a65e0	c1 2c a1 6d			eexp64          .dword $6DA12CC1
>3a65e4	5f 97 07 4b			eexp16          .dword $4B07975F
>3a65e8	81 64 5a 42			eexp04          .dword $425A6481
>3a65ec	54 f8 2d 40			eexp01          .dword $402DF854
>3a65f0	db 0f c9 40			twopi           .dword $40C90FDB
>3a65f4	db 0f 49 40			onepi           .dword $40490FDB
>3a65f8	db 0f c9 3f			halfpi          .dword $3FC90FDB
>3a65fc	db 0f 49 3f			quarterpi       .dword $3F490FDB

;******  Return to file: src\basic816.s


;******  Processing file: src\arrays.s

.3a6600					ARR_ALLOC
.3a6600	08		php		                PHP
.3a6601	20 cc 12	jsr $3a12cc	            JSR HEAP_GETHED
.3a6604	c2 20		rep #$20	            REP #$20
.3a6606	a9 01 00	lda #$0001	                LDA #1                      ; ARGUMENT1 := 1
.3a6609	85 23		sta $0823	                STA ARGUMENT1
.3a660b	a9 00 00	lda #$0000	                LDA #0
.3a660e	85 25		sta $0825	                STA ARGUMENT1+2
.3a6610	e2 20		sep #$20	            SEP #$20
.3a6612	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.3a6616	c2 20		rep #$20	            REP #$20
.3a6618	29 ff 00	and #$00ff	                AND #$00FF
.3a661b	85 8f		sta $088f	                STA MCOUNT                  ; Save it to MCOUNT for later
.3a661d	a8		tay		                TAY                         ; Y := number of dimensions
.3a661e	a2 01 00	ldx #$0001	                LDX #1                      ; X := index to size 0
.3a6621					size_loop
.3a6621	c2 20		rep #$20	            REP #$20
.3a6623	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X           ; ARGUMENT2 := Ith dimension
.3a6627	85 29		sta $0829	                STA ARGUMENT2
.3a6629	a9 00 00	lda #$0000	                LDA #0
.3a662c	85 2b		sta $082b	                STA ARGUMENT2+2
.3a662e	e2 20		sep #$20	            SEP #$20
.3a6630	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a6632	85 2d		sta $082d	                STA ARGTYPE2
.3a6634	c2 20		rep #$20	            REP #$20
.3a6636	20 17 28	jsr $3a2817	            JSR OP_MULTIPLY
.3a6639	e8		inx		                INX
.3a663a	e8		inx		                INX
.3a663b	88		dey		                DEY
.3a663c	d0 e3		bne $3a6621	                BNE size_loop               ; If there are more dimensions, take the next one
.3a663e	c2 20		rep #$20	            REP #$20
.3a6640	a9 04 00	lda #$0004	                LDA #ARGUMENT_SIZE-1        ; Size of a data item (don't include the type code)
.3a6643	85 29		sta $0829	                STA ARGUMENT2
.3a6645	a9 00 00	lda #$0000	                LDA #0
.3a6648	85 2b		sta $082b	                STA ARGUMENT2+2
.3a664a	20 17 28	jsr $3a2817	            JSR OP_MULTIPLY
.3a664d	e2 20		sep #$20	            SEP #$20
.3a664f	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF             ; SCRATCH := N * 2
.3a6653	85 0c		sta $080c	                STA SCRATCH
.3a6655	a9 00		lda #$00	                LDA #0
.3a6657	85 0d		sta $080d	                STA SCRATCH+1
.3a6659	c2 20		rep #$20	            REP #$20
.3a665b	06 0c		asl $080c	                ASL SCRATCH
.3a665d	38		sec		                SEC                         ; ARGUMENT1 := size of the complete block
.3a665e	a5 23		lda $0823	                LDA ARGUMENT1
.3a6660	65 0c		adc $080c	                ADC SCRATCH                 ; Size of data area + N*2 + 1 (in carry)
.3a6662	85 23		sta $0823	                STA ARGUMENT1
.3a6664	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6666	69 00 00	adc #$0000	                ADC #0
.3a6669	85 25		sta $0825	                STA ARGUMENT1+2
.3a666b	d0 29		bne $3a6696	                BNE too_big                 ; size > 16-bit? Yes: throw an error
.3a666d	e2 20		sep #$20	            SEP #$20
.3a666f	a5 ea		lda $08ea	                LDA TOFINDTYPE              ; Get the type
.3a6671	09 80		ora #$80	                ORA #$80                    ; Flip the flag to make it an array of that type
.3a6673	a6 23		ldx $0823	                LDX ARGUMENT1               ; Get the computed size
.3a6675	20 90 10	jsr $3a1090	            JSR ALLOC
.3a6678	e2 20		sep #$20	            SEP #$20
.3a667a	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.3a667e	87 c0		sta [$08c0]	                STA [CURRBLOCK]             ; Write the number of dimensions to the array's preamble
.3a6680	a0 01 00	ldy #$0001	                LDY #1
.3a6683	a2 00 00	ldx #$0000	                LDX #0
.3a6686					copy_loop
.3a6686	e2 20		sep #$20	            SEP #$20
.3a6688	bf 01 4d 00	lda $004d01,x	                LDA @lARRIDXBUF+1,X         ; ARGUMENT2 := Ith dimension
.3a668c	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y           ; And write the dimension to the array's preamble
.3a668e	e4 8f		cpx $088f	                CPX MCOUNT                  ; Have we written the last byte?
.3a6690	f0 23		beq $3a66b5	                BEQ null_array              ; Yes: clear the array
.3a6692	e8		inx		                INX                         ; No: move to the next byte
.3a6693	c8		iny		                INY
.3a6694	80 f0		bra $3a6686	                BRA copy_loop
.3a6696					too_big
.3a6696	08		php		            PHP
.3a6697	c2 20		rep #$20	            REP #$20
.3a6699	48		pha		            PHA
.3a669a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a669d	5b		tcd		            TCD
.3a669e	68		pla		            PLA
.3a669f	28		plp		            PLP
.3a66a0	e2 20		sep #$20	            SEP #$20
.3a66a2	a9 09		lda #$09	            LDA #ERR_RANGE
.3a66a4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a66a8	c2 20		rep #$20	            REP #$20
.3a66aa	29 ff 00	and #$00ff	            AND #$00FF
.3a66ad	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a66b0	e2 20		sep #$20	            SEP #$20
.3a66b2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a66b5					null_array
.3a66b5	e2 20		sep #$20	            SEP #$20
.3a66b7	38		sec		                SEC                         ; INDEX := pointer to first value
.3a66b8	a5 c0		lda $08c0	                LDA CURRBLOCK
.3a66ba	67 c0		adc [$08c0]	                ADC [CURRBLOCK]
.3a66bc	85 08		sta $0808	                STA INDEX
.3a66be	a5 c1		lda $08c1	                LDA CURRBLOCK+1
.3a66c0	69 00		adc #$00	                ADC #0
.3a66c2	85 09		sta $0809	                STA INDEX+1
.3a66c4	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.3a66c6	69 00		adc #$00	                ADC #0
.3a66c8	85 0a		sta $080a	                STA INDEX+2
.3a66ca	64 0b		stz $080b	                STZ INDEX+3
.3a66cc	c2 20		rep #$20	            REP #$20
.3a66ce	a0 05 00	ldy #$0005	                LDY #HEAPOBJ.END            ; SCRATCH := pointer the the first byte after the array
.3a66d1	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.3a66d3	85 0c		sta $080c	                STA SCRATCH
.3a66d5	e2 20		sep #$20	            SEP #$20
.3a66d7	c8		iny		                INY
.3a66d8	c8		iny		                INY
.3a66d9	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.3a66db	85 0e		sta $080e	                STA SCRATCH+2
.3a66dd	64 0f		stz $080f	                STZ SCRATCH+3
.3a66df					clr_loop
.3a66df	e2 20		sep #$20	            SEP #$20
.3a66e1	a9 00		lda #$00	                LDA #0
.3a66e3	87 08		sta [$0808]	                STA [INDEX]                 ; Clear the byte
.3a66e5	c2 20		rep #$20	            REP #$20
.3a66e7	18		clc		                CLC                         ; Increment INDEX
.3a66e8	a5 08		lda $0808	                LDA INDEX
.3a66ea	69 01 00	adc #$0001	                ADC #1
.3a66ed	85 08		sta $0808	                STA INDEX
.3a66ef	a5 0a		lda $080a	                LDA INDEX+2
.3a66f1	69 00 00	adc #$0000	                ADC #0
.3a66f4	85 0a		sta $080a	                STA INDEX+2
.3a66f6	c5 0e		cmp $080e	                CMP SCRATCH+2               ; INDEX == SCRATCH?
.3a66f8	d0 e5		bne $3a66df	                BNE clr_loop                ; No: write to this next byte
.3a66fa	a5 08		lda $0808	                LDA INDEX
.3a66fc	c5 0c		cmp $080c	                CMP SCRATCH
.3a66fe	d0 df		bne $3a66df	                BNE clr_loop
.3a6700					done
.3a6700	28		plp		                PLP
.3a6701	60		rts		            RTS
.3a6702					ARR_CELL
.3a6702	08		php		                PHP
.3a6703	c2 20		rep #$20	            REP #$20
.3a6705	64 08		stz $0808	                STZ INDEX               ; INDEX := 0
.3a6707	64 0a		stz $080a	                STZ INDEX+2
.3a6709	e2 20		sep #$20	            SEP #$20
.3a670b	af 00 4d 00	lda $004d00	                LDA @l ARRIDXBUF        ; MCOUNT := N (number of dimensions)
.3a670f	85 8f		sta $088f	                STA MCOUNT
.3a6711	64 90		stz $0890	                STZ MCOUNT+1
.3a6713	a2 01 00	ldx #$0001	                LDX #1                  ; X := index to dimension 0
.3a6716	e2 20		sep #$20	            SEP #$20
.3a6718	a7 c0		lda [$08c0]	                LDA [CURRBLOCK]         ; Make sure the dimensions of the array
.3a671a	c5 8f		cmp $088f	                CMP MCOUNT              ; ... match those requested
.3a671c	f0 22		beq $3a6740	                BEQ dims_match          ; Yes: the dimensions match
.3a671e	a6 8f		ldx $088f	                LDX MCOUNT
.3a6720	00		brk #		                BRK
.3a6721					arg_err
.3a6721	08		php		            PHP
.3a6722	c2 20		rep #$20	            REP #$20
.3a6724	48		pha		            PHA
.3a6725	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6728	5b		tcd		            TCD
.3a6729	68		pla		            PLA
.3a672a	28		plp		            PLP
.3a672b	e2 20		sep #$20	            SEP #$20
.3a672d	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a672f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6733	c2 20		rep #$20	            REP #$20
.3a6735	29 ff 00	and #$00ff	            AND #$00FF
.3a6738	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a673b	e2 20		sep #$20	            SEP #$20
.3a673d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6740	c9 01		cmp #$01	dims_match      CMP #1                  ; Check to see if this array is one dimensional
.3a6742	f0 3a		beq $3a677e	                BEQ add_last            ; If so, just add the index of the cell to INDEX
.3a6744	a0 01 00	ldy #$0001	                LDY #1
.3a6747					index_loop
.3a6747	e2 20		sep #$20	            SEP #$20
.3a6749	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; ARGUMENT1 := I_j
.3a674d	85 23		sta $0823	                STA ARGUMENT1
.3a674f	64 24		stz $0824	                STZ ARGUMENT1+1
.3a6751	64 25		stz $0825	                STZ ARGUMENT1+2
.3a6753	64 26		stz $0826	                STZ ARGUMENT1+3
.3a6755	b7 c0		lda [$08c0],y	                LDA [CURRBLOCK],Y       ; ARGUMENT2 := D_j
.3a6757	85 29		sta $0829	                STA ARGUMENT2
.3a6759	64 2a		stz $082a	                STZ ARGUMENT2+1
.3a675b	64 2b		stz $082b	                STZ ARGUMENT2+2
.3a675d	64 2c		stz $082c	                STZ ARGUMENT2+3
.3a675f	a5 23		lda $0823	                LDA ARGUMENT1
.3a6761	c5 29		cmp $0829	                CMP ARGUMENT2           ; Is I_j >= D_j
.3a6763	b0 68		bcs $3a67cd	                BGE range_err           ; Yes: throw an out-of-range error
.3a6765	20 17 28	jsr $3a2817	            JSR OP_MULTIPLY
.3a6768	c2 20		rep #$20	            REP #$20
.3a676a	18		clc		                CLC                     ; INDEX := INDEX + ARGUMENT1
.3a676b	a5 08		lda $0808	                LDA INDEX
.3a676d	65 23		adc $0823	                ADC ARGUMENT1
.3a676f	85 08		sta $0808	                STA INDEX
.3a6771	a5 0a		lda $080a	                LDA INDEX+2
.3a6773	65 25		adc $0825	                ADC ARGUMENT1+2
.3a6775	85 0a		sta $080a	                STA INDEX+2
.3a6777	e8		inx		                INX
.3a6778	e8		inx		                INX
.3a6779	c8		iny		                INY
.3a677a	c4 8f		cpy $088f	                CPY MCOUNT              ; Are we on the last index?
.3a677c	d0 c9		bne $3a6747	                BNE index_loop          ; No: move to the next index and try again
.3a677e					add_last
.3a677e	e2 20		sep #$20	            SEP #$20
.3a6780	18		clc		                CLC
.3a6781	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; INDEX := INDEX + I_(n-1)
.3a6785	85 90		sta $0890	                STA MCOUNT+1
.3a6787	65 08		adc $0808	                ADC INDEX
.3a6789	85 08		sta $0808	                STA INDEX
.3a678b	a5 09		lda $0809	                LDA INDEX+1
.3a678d	69 00		adc #$00	                ADC #0
.3a678f	85 09		sta $0809	                STA INDEX+1
.3a6791	c2 20		rep #$20	            REP #$20
.3a6793	a5 0a		lda $080a	                LDA INDEX+2
.3a6795	69 00 00	adc #$0000	                ADC #0
.3a6798	85 0a		sta $080a	                STA INDEX+2
.3a679a	c2 20		rep #$20	            REP #$20
.3a679c	06 08		asl $0808	                ASL INDEX               ; INDEX := INDEX * 4 (size of a value)
.3a679e	26 0a		rol $080a	                ROL INDEX+2
.3a67a0	06 08		asl $0808	                ASL INDEX
.3a67a2	26 0a		rol $080a	                ROL INDEX+2
.3a67a4	e2 20		sep #$20	            SEP #$20
.3a67a6	38		sec		                SEC
.3a67a7	a5 08		lda $0808	                LDA INDEX
.3a67a9	65 8f		adc $088f	                ADC MCOUNT
.3a67ab	85 08		sta $0808	                STA INDEX
.3a67ad	a5 09		lda $0809	                LDA INDEX+1
.3a67af	69 00		adc #$00	                ADC #0
.3a67b1	85 09		sta $0809	                STA INDEX+1
.3a67b3	c2 20		rep #$20	            REP #$20
.3a67b5	a5 0a		lda $080a	                LDA INDEX+2
.3a67b7	69 00 00	adc #$0000	                ADC #0
.3a67ba	85 0a		sta $080a	                STA INDEX+2
.3a67bc	18		clc		                CLC                     ; INDEX := INDEX + CURRBLOCK (point to the address desired)
.3a67bd	a5 08		lda $0808	                LDA INDEX
.3a67bf	65 c0		adc $08c0	                ADC CURRBLOCK
.3a67c1	85 08		sta $0808	                STA INDEX
.3a67c3	e2 20		sep #$20	            SEP #$20
.3a67c5	a5 0a		lda $080a	                LDA INDEX+2
.3a67c7	65 c2		adc $08c2	                ADC CURRBLOCK+2
.3a67c9	85 0a		sta $080a	                STA INDEX+2
.3a67cb	28		plp		                PLP
.3a67cc	60		rts		            RTS
.3a67cd					range_err
.3a67cd	08		php		            PHP
.3a67ce	c2 20		rep #$20	            REP #$20
.3a67d0	48		pha		            PHA
.3a67d1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a67d4	5b		tcd		            TCD
.3a67d5	68		pla		            PLA
.3a67d6	28		plp		            PLP
.3a67d7	e2 20		sep #$20	            SEP #$20
.3a67d9	a9 09		lda #$09	            LDA #ERR_RANGE
.3a67db	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a67df	c2 20		rep #$20	            REP #$20
.3a67e1	29 ff 00	and #$00ff	            AND #$00FF
.3a67e4	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a67e7	e2 20		sep #$20	            SEP #$20
.3a67e9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a67ec					ARR_SET
.3a67ec	08		php		                PHP
.3a67ed	20 cc 12	jsr $3a12cc	            JSR HEAP_GETHED
.3a67f0	e2 20		sep #$20	            SEP #$20
.3a67f2	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.3a67f5	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.3a67f7	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.3a67f9	c9 02		cmp #$02	                CMP #TYPE_STRING    ; Is it a string array?
.3a67fb	d0 05		bne $3a6802	                BNE chk_integer
.3a67fd	20 a8 06	jsr $3a06a8	            JSR ASS_ARG1_STR
.3a6800	80 10		bra $3a6812	                BRA save_type
.3a6802	c9 00		cmp #$00	chk_integer     CMP #TYPE_INTEGER   ; Is it an integer array?
.3a6804	d0 05		bne $3a680b	                BNE chk_float
.3a6806	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a6809	80 07		bra $3a6812	                BRA save_type
.3a680b	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT     ; Is it an float array?
.3a680d	d0 2b		bne $3a683a	                BNE type_mismatch   ; No: throw a type mismatch error... something strange...
.3a680f	20 84 07	jsr $3a0784	            JSR ASS_ARG1_FLOAT
.3a6812	a5 27		lda $0827	save_type       LDA ARGTYPE1        ; Save the type
.3a6814	48		pha		                PHA
.3a6815	c2 20		rep #$20	            REP #$20
.3a6817	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Save ARGUMENT1
.3a6819	48		pha		                PHA
.3a681a	a5 23		lda $0823	                LDA ARGUMENT1
.3a681c	48		pha		                PHA
.3a681d	20 02 67	jsr $3a6702	            JSR ARR_CELL
.3a6820	68		pla		                PLA                 ; Restore ARGUMENT1
.3a6821	85 23		sta $0823	                STA ARGUMENT1
.3a6823	68		pla		                PLA
.3a6824	85 25		sta $0825	                STA ARGUMENT1+2
.3a6826	e2 20		sep #$20	            SEP #$20
.3a6828	68		pla		                PLA
.3a6829	85 27		sta $0827	                STA ARGTYPE1
.3a682b	c2 20		rep #$20	            REP #$20
.3a682d	a5 23		lda $0823	                LDA ARGUMENT1       ; Set the value in the cell
.3a682f	87 08		sta [$0808]	                STA [INDEX]
.3a6831	a0 02 00	ldy #$0002	                LDY #2
.3a6834	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6836	97 08		sta [$0808],y	                STA [INDEX],Y
.3a6838	28		plp		                PLP
.3a6839	60		rts		            RTS
.3a683a					type_mismatch
.3a683a	08		php		            PHP
.3a683b	c2 20		rep #$20	            REP #$20
.3a683d	48		pha		            PHA
.3a683e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6841	5b		tcd		            TCD
.3a6842	68		pla		            PLA
.3a6843	28		plp		            PLP
.3a6844	e2 20		sep #$20	            SEP #$20
.3a6846	a9 04		lda #$04	            LDA #ERR_TYPE
.3a6848	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a684c	c2 20		rep #$20	            REP #$20
.3a684e	29 ff 00	and #$00ff	            AND #$00FF
.3a6851	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a6854	e2 20		sep #$20	            SEP #$20
.3a6856	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6859					ARR_REF
.3a6859	08		php		                PHP
.3a685a	20 cc 12	jsr $3a12cc	            JSR HEAP_GETHED
.3a685d	f4 00 00	pea #$0000	                PEA #0              ; Make room on the stack that ARR_CELL expects
.3a6860	f4 00 00	pea #$0000	                PEA #0
.3a6863	e2 20		sep #$20	            SEP #$20
.3a6865	48		pha		                PHA
.3a6866	20 02 67	jsr $3a6702	            JSR ARR_CELL
.3a6869	e2 20		sep #$20	            SEP #$20
.3a686b	68		pla		                PLA
.3a686c	c2 20		rep #$20	            REP #$20
.3a686e	68		pla		                PLA
.3a686f	68		pla		                PLA
.3a6870	c2 20		rep #$20	            REP #$20
.3a6872	a7 08		lda [$0808]	                LDA [INDEX]         ; Get the value in the cell
.3a6874	85 23		sta $0823	                STA ARGUMENT1
.3a6876	a0 02 00	ldy #$0002	                LDY #2
.3a6879	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a687b	85 25		sta $0825	                STA ARGUMENT1+2
.3a687d	e2 20		sep #$20	            SEP #$20
.3a687f	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.3a6882	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.3a6884	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.3a6886	85 27		sta $0827	                STA ARGTYPE1        ; Set the type of the return value
.3a6888	20 20 18	jsr $3a1820	            JSR STR_NORMAL
.3a688b	28		plp		                PLP
.3a688c	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\dos.s

.0000					DIRENTRY
>0000					SHORTNAME               .fill 11        ; $00 - The short name of the file (8 name, 3 extension)
>000b					ATTRIBUTE               .byte ?         ; $0B - The attribute bits
>000c					IGNORED1                .word ?         ; $0C - Unused (by us) bytes
>000e					CREATE_TIME             .word ?         ; $0E - Creation time
>0010					CREATE_DATE             .word ?         ; $10 - Creation date
>0012					ACCESS_DATE             .word ?         ; $12 - Last access date
>0014					CLUSTER_H               .word ?         ; $14 - High word of the first cluster #
>0016					MODIFIED_TIME           .word ?         ; $16 - Last modified time
>0018					MODIFIED_DATE           .word ?         ; $18 - Last modified date
>001a					CLUSTER_L               .word ?         ; $1A - Low word of the first cluster #
>001c					SIZE                    .dword ?        ; $1C - The size of the file (in bytes)
=$01					DOS_ATTR_RO = $01                       ; File is read-only
=$02					DOS_ATTR_HIDDEN = $02                   ; File is hidden
=$04					DOS_ATTR_SYSTEM = $04                   ; File is a system file
=$08					DOS_ATTR_VOLUME = $08                   ; Entry is the volume label
=$10					DOS_ATTR_DIR = $10                      ; Entry is a directory
=$20					DOS_ATTR_ARCH = $20                     ; Entry has changed since last backup
=$0f					DOS_ATTR_LONGNAME = $0F                 ; Entry is the long file name
=$e5					DOS_DIR_ENT_UNUSED = $E5                ; Marker for an unused directory entry
.0000					FILEDESC
>0000					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>0001					DEV                 .byte ?             ; The ID of the device holding the file
>0002					PATH                .dword ?            ; Pointer to a NULL terminated path string
>0006					CLUSTER             .dword ?            ; The current cluster of the file.
>000a					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>000e					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>0012					FILESIZE            .dword ?            ; The size of the file
>0016					CREATE_DATE         .word ?             ; The creation date of the file
>0018					CREATE_TIME         .word ?             ; The creation time of the file
>001a					MODIFIED_DATE       .word ?             ; The modification date of the file
>001c					MODIFIED_TIME       .word ?             ; The modification time of the file
=$01					FD_STAT_READ = $01                      ; The file is readable
=$02					FD_STAT_WRITE = $02                     ; The file is writable
=$40					FD_STAT_OPEN = $40                      ; The file is open
=$60					FD_STAT_ERROR = $60                     ; The file is in an error condition
=$80					FD_STAT_EOF = $80                       ; The file cursor is at the end of the file
>3af073					CLUSTER_BUFF    .fill 512           ; A buffer for cluster read/write operations
.3af273					FD_IN
>3af273					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>3af274					DEV                 .byte ?             ; The ID of the device holding the file
>3af275					PATH                .dword ?            ; Pointer to a NULL terminated path string
>3af279					CLUSTER             .dword ?            ; The current cluster of the file.
>3af27d					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>3af281					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>3af285					FILESIZE            .dword ?            ; The size of the file
>3af289					CREATE_DATE         .word ?             ; The creation date of the file
>3af28b					CREATE_TIME         .word ?             ; The creation time of the file
>3af28d					MODIFIED_DATE       .word ?             ; The modification date of the file
>3af28f					MODIFIED_TIME       .word ?             ; The modification time of the file
.3a688d					PR_FILESIZE
.3a688d	da		phx		                PHX
.3a688e	0b		phd		                PHD
.3a688f	08		php		                PHP
.3a6890	08		php		            PHP
.3a6891	c2 20		rep #$20	            REP #$20
.3a6893	48		pha		            PHA
.3a6894	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a6897	5b		tcd		            TCD
.3a6898	68		pla		            PLA
.3a6899	28		plp		            PLP
.3a689a	c2 30		rep #$30	            REP #$30
.3a689c	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a689e	89 f0 ff	bit #$fff0	                BIT #$FFF0              ; Check to see if the amount is in MB range
.3a68a1	d0 29		bne $3a68cc	                BNE pr_mb               ; If so, print it in MBs
.3a68a3	89 0f 00	bit #$000f	                BIT #$000F              ; Check to see if the amount is in KB range
.3a68a6	d0 0c		bne $3a68b4	                BNE pr_kb
.3a68a8	a5 23		lda $0823	                LDA ARGUMENT1
.3a68aa	89 00 fc	bit #$fc00	                BIT #$FC00
.3a68ad	d0 05		bne $3a68b4	                BNE pr_kb               ; If so, print it in KBs
.3a68af					pr_regular
.3a68af	20 db 45	jsr $3a45db	            JSR PR_INTEGER
.3a68b2	80 2e		bra $3a68e2	                BRA done
.3a68b4	a2 0a 00	ldx #$000a	pr_kb           LDX #10                 ; Shift so the amount in KB is in ARGUMENT1
.3a68b7	46 25		lsr $0825	kb_shift        LSR ARGUMENT1+2
.3a68b9	66 23		ror $0823	                ROR ARGUMENT1
.3a68bb	ca		dex		                DEX
.3a68bc	d0 f9		bne $3a68b7	                BNE kb_shift
.3a68be	20 db 45	jsr $3a45db	            JSR PR_INTEGER
.3a68c1	e2 20		sep #$20	            SEP #$20
.3a68c3	a9 4b		lda #$4b	                LDA #'K'
.3a68c5	20 18 00	jsr $3a0018	            JSR PRINTC
.3a68c8	c2 20		rep #$20	            REP #$20
.3a68ca	80 16		bra $3a68e2	                BRA done
.3a68cc	a2 14 00	ldx #$0014	pr_mb           LDX #20                 ; Shift so the amount in MB is in ARGUMENT1
.3a68cf	46 25		lsr $0825	mb_shift        LSR ARGUMENT1+2
.3a68d1	66 23		ror $0823	                ROR ARGUMENT1
.3a68d3	ca		dex		                DEX
.3a68d4	d0 f9		bne $3a68cf	                BNE mb_shift
.3a68d6	20 db 45	jsr $3a45db	            JSR PR_INTEGER
.3a68d9	e2 20		sep #$20	            SEP #$20
.3a68db	a9 4d		lda #$4d	                LDA #'M'
.3a68dd	20 18 00	jsr $3a0018	            JSR PRINTC
.3a68e0	c2 20		rep #$20	            REP #$20
.3a68e2	28		plp		done            PLP
.3a68e3	2b		pld		                PLD
.3a68e4	fa		plx		                PLX
.3a68e5	60		rts		            RTS
.3a68e6					CMD_DIR
.3a68e6	0b		phd		                PHD
.3a68e7	08		php		                PHP
.3a68e8	c2 30		rep #$30	            REP #$30
.3a68ea	a9 00 00	lda #$0000	                LDA #0                      ; Zero out the pagination line count
.3a68ed	8f b6 08 00	sta $0008b6	                STA @l LINECOUNT
.3a68f1	8f b8 08 00	sta $0008b8	                STA @l LINECOUNT+2
.3a68f5	e2 20		sep #$20	            SEP #$20
.3a68f7	20 3b 22	jsr $3a223b	            JSR PEEK_TOK
.3a68fa	c9 00		cmp #$00	                CMP #0
.3a68fc	f0 08		beq $3a6906	                BEQ set_null                ; If none provided, set the path to empty
.3a68fe	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a6901	20 a8 06	jsr $3a06a8	            JSR ASS_ARG1_STR
.3a6904	80 11		bra $3a6917	                BRA set_fd
.3a6906					set_null
.3a6906	c2 20		rep #$20	            REP #$20
.3a6908	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT1 to the NULL string
.3a690b	85 23		sta $0823	                STA ARGUMENT1
.3a690d	85 25		sta $0825	                STA ARGUMENT1+2
.3a690f	e2 20		sep #$20	            SEP #$20
.3a6911	a9 02		lda #$02	                LDA #TYPE_STRING
.3a6913	85 27		sta $0827	                STA ARGTYPE1
.3a6915	c2 20		rep #$20	            REP #$20
.3a6917					set_fd
.3a6917	20 47 6a	jsr $3a6a47	            JSR SETFILEDESC
.3a691a	22 08 11 00	jsl $001108	                JSL FK_DIROPEN              ; Open up the directory
.3a691e	b0 22		bcs $3a6942	                BCS pr_first
.3a6920	20 f8 6a	jsr $3a6af8	            JSR SET_DOSSTAT
.3a6923	08		php		            PHP
.3a6924	c2 20		rep #$20	            REP #$20
.3a6926	48		pha		            PHA
.3a6927	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a692a	5b		tcd		            TCD
.3a692b	68		pla		            PLA
.3a692c	28		plp		            PLP
.3a692d	e2 20		sep #$20	            SEP #$20
.3a692f	a9 10		lda #$10	            LDA #ERR_DIRECTORY
.3a6931	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6935	c2 20		rep #$20	            REP #$20
.3a6937	29 ff 00	and #$00ff	            AND #$00FF
.3a693a	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a693d	e2 20		sep #$20	            SEP #$20
.3a693f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6942					pr_first
.3a6942	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a6945					pr_entry
.3a6945	08		php		            PHP
.3a6946	c2 20		rep #$20	            REP #$20
.3a6948	48		pha		            PHA
.3a6949	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.3a694c	5b		tcd		            TCD
.3a694d	68		pla		            PLA
.3a694e	28		plp		            PLP
.3a694f	e2 20		sep #$20	            SEP #$20
.3a6951	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Start with the file name
.3a6954	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the initial character of the name
.3a6956	d0 03		bne $3a695b	                BNE chk_unused
.3a6958	82 a9 00	brl $3a6a04	                BRL done                    ; If it's NULL, we're done
.3a695b	c9 e5		cmp #$e5	chk_unused      CMP #DOS_DIR_ENT_UNUSED     ; Is it the unusued code?
.3a695d	d0 03		bne $3a6962	                BNE chk_attributes
.3a695f	82 96 00	brl $3a69f8	                BRL next_entry              ; Yes: go to the next entry
.3a6962	a0 0b 00	ldy #$000b	chk_attributes  LDY #DIRENTRY.ATTRIBUTE
.3a6965	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute byte
.3a6967	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.3a6969	f0 03		beq $3a696e	                BEQ chk_hidden
.3a696b	82 a9 00	brl $3a6a17	                BRL pr_volume               ; Print the volume label
.3a696e	89 02		bit #$02	chk_hidden      BIT #DOS_ATTR_HIDDEN        ; Is it a hidden file?
.3a6970	f0 03		beq $3a6975	                BEQ chk_long
.3a6972	82 83 00	brl $3a69f8	                BRL next_entry              ; Yes: go to the next entry
.3a6975	29 0f		and #$0f	chk_long        AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.3a6977	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.3a6979	d0 03		bne $3a697e	                BNE get_short_name
.3a697b	82 7a 00	brl $3a69f8	                BRL next_entry              ; Yes: go to the next entry
.3a697e	a0 00 00	ldy #$0000	get_short_name  LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.3a6981	b7 18		lda [$0338],y	pr_name_loop    LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.3a6983	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6986	c8		iny		                INY                         ; Move to the next character
.3a6987	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.3a698a	d0 f5		bne $3a6981	                BNE pr_name_loop            ; No: print this new character
.3a698c	a9 20		lda #$20	                LDA #' '                    ; Print the separator
.3a698e	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6991	a0 08 00	ldy #$0008	                LDY #DIRENTRY.SHORTNAME+8   ; Move to the first of the extension characters
.3a6994	b7 18		lda [$0338],y	pr_ext_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.3a6996	20 18 00	jsr $3a0018	                JSR PRINTC                  ; Otherwise: print it.
.3a6999	c8		iny		                INY                         ; Move to the next character
.3a699a	c0 0b 00	cpy #$000b	                CPY #DIRENTRY.SHORTNAME+11  ; Are we at the end of the extension portion?
.3a699d	d0 f5		bne $3a6994	                BNE pr_ext_loop             ; No: print this new character
.3a699f	a9 09		lda #$09	pr_tab1         LDA #CHAR_TAB               ; Print a TAB
.3a69a1	20 18 00	jsr $3a0018	            JSR PRINTC
.3a69a4	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.3a69a7	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.3a69a9	89 10		bit #$10	                BIT #DOS_ATTR_DIR           ; Is it a directory?
.3a69ab	d0 1e		bne $3a69cb	                BNE pr_attr                 ; Yes: skip printing a file size
.3a69ad	c2 20		rep #$20	            REP #$20
.3a69af	a0 1c 00	ldy #$001c	                LDY #DIRENTRY.SIZE
.3a69b2	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the file size
.3a69b4	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.3a69b8	c8		iny		                INY
.3a69b9	c8		iny		                INY
.3a69ba	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y
.3a69bc	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.3a69c0	e2 20		sep #$20	            SEP #$20
.3a69c2	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a69c4	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.3a69c8	20 8d 68	jsr $3a688d	            JSR PR_FILESIZE
.3a69cb	a9 09		lda #$09	pr_attr         LDA #CHAR_TAB               ; Print a TAB
.3a69cd	20 18 00	jsr $3a0018	            JSR PRINTC
.3a69d0	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.3a69d3	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.3a69d5	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.3a69d7	d0 1c		bne $3a69f5	                BNE end_entry               ; Yes: we're done printing this entry
.3a69d9	89 01		bit #$01	chk_read        BIT #DOS_ATTR_RO            ; Is it a read-only file?
.3a69db	f0 05		beq $3a69e2	                BEQ chk_system
.3a69dd	a9 52		lda #$52	                LDA #'R'                    ; Yes: print an R
.3a69df	20 18 00	jsr $3a0018	            JSR PRINTC
.3a69e2	89 04		bit #$04	chk_system      BIT #DOS_ATTR_SYSTEM        ; Is it System file?
.3a69e4	f0 05		beq $3a69eb	                BEQ chk_directory
.3a69e6	a9 53		lda #$53	                LDA #'S'                    ; Yes: print an S
.3a69e8	20 18 00	jsr $3a0018	            JSR PRINTC
.3a69eb	89 10		bit #$10	chk_directory   BIT #DOS_ATTR_DIR           ; Is it a directory?
.3a69ed	f0 05		beq $3a69f4	                BEQ pr_tab2
.3a69ef	a9 44		lda #$44	                LDA #'D'                    ; Yes: print a D
.3a69f1	20 18 00	jsr $3a0018	            JSR PRINTC
.3a69f4	ea		nop		pr_tab2         NOP
.3a69f5					end_entry
.3a69f5	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a69f8					next_entry
.3a69f8	20 b3 03	jsr $3a03b3	            JSR PAGINATE
.3a69fb	22 0c 11 00	jsl $00110c	                JSL FK_DIRNEXT
.3a69ff	90 03		bcc $3a6a04	                BCC done
.3a6a01	82 41 ff	brl $3a6945	                BRL pr_entry
.3a6a04					done
.3a6a04	20 f8 6a	jsr $3a6af8	            JSR SET_DOSSTAT
.3a6a07	08		php		            PHP
.3a6a08	c2 20		rep #$20	            REP #$20
.3a6a0a	48		pha		            PHA
.3a6a0b	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a6a0e	5b		tcd		            TCD
.3a6a0f	68		pla		            PLA
.3a6a10	28		plp		            PLP
.3a6a11	20 1f 21	jsr $3a211f	            JSR SKIPSTMT
.3a6a14	28		plp		                PLP
.3a6a15	2b		pld		                PLD
.3a6a16	60		rts		            RTS
.3a6a17					pr_volume
.3a6a17	08		php		            PHP
.3a6a18	c2 20		rep #$20	            REP #$20
.3a6a1a	48		pha		            PHA
.3a6a1b	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.3a6a1e	5b		tcd		            TCD
.3a6a1f	68		pla		            PLA
.3a6a20	28		plp		            PLP
.3a6a21	e2 20		sep #$20	            SEP #$20
.3a6a23	29 0f		and #$0f	                AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.3a6a25	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.3a6a27	f0 cf		beq $3a69f8	                BEQ next_entry              ; Yes: skip it
.3a6a29	a9 5b		lda #$5b	pr_lbracket     LDA #'['
.3a6a2b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6a2e	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.3a6a31	b7 18		lda [$0338],y	pr_vol_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.3a6a33	c9 20		cmp #$20	                CMP #CHAR_SP                ; Is it a blank?
.3a6a35	f0 09		beq $3a6a40	                BEQ pr_rbracket             ; Yes: end the name and print the dot
.3a6a37	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6a3a	c8		iny		                INY                         ; Move to the next character
.3a6a3b	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.3a6a3e	d0 f1		bne $3a6a31	                BNE pr_vol_loop             ; No: print this new character
.3a6a40	a9 5d		lda #$5d	pr_rbracket     LDA #']'                    ; Print a close bracket
.3a6a42	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6a45	80 ae		bra $3a69f5	                BRA end_entry               ; And try to get the next entry
.3a6a47					SETFILEDESC
.3a6a47	0b		phd		                PHD
.3a6a48	08		php		                PHP
.3a6a49	08		php		            PHP
.3a6a4a	c2 20		rep #$20	            REP #$20
.3a6a4c	48		pha		            PHA
.3a6a4d	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.3a6a50	5b		tcd		            TCD
.3a6a51	68		pla		            PLA
.3a6a52	28		plp		            PLP
.3a6a53	c2 30		rep #$30	            REP #$30
.3a6a55	a9 73 f2	lda #$f273	                LDA #<>FD_IN            ; Point to the file descriptor
.3a6a58	85 20		sta $0340	                STA DOS_FD_PTR
.3a6a5a	a9 3a 00	lda #$003a	                LDA #`FD_IN
.3a6a5d	85 22		sta $0342	                STA DOS_FD_PTR+2
.3a6a5f	a0 00 00	ldy #$0000	                LDY #0                  ; Fille the file descriptor with 0
.3a6a62	e2 20		sep #$20	            SEP #$20
.3a6a64	a9 00		lda #$00	                LDA #0
.3a6a66	97 20		sta [$0340],y	zero_loop       STA [DOS_FD_PTR],Y
.3a6a68	c8		iny		                INY
.3a6a69	c0 1e 00	cpy #$001e	                CPY #SIZE(FILEDESC)
.3a6a6c	d0 f8		bne $3a6a66	                BNE zero_loop
.3a6a6e	c2 20		rep #$20	            REP #$20
.3a6a70	a9 73 f0	lda #$f073	                LDA #<>CLUSTER_BUFF     ; Point to the cluster buffer
.3a6a73	8f 81 f2 3a	sta $3af281	                STA @l FD_IN.BUFFER
.3a6a77	a9 3a 00	lda #$003a	                LDA #`CLUSTER_BUFF
.3a6a7a	8f 83 f2 3a	sta $3af283	                STA @l FD_IN.BUFFER+2
.3a6a7e	af 23 08 00	lda $000823	                LDA @l ARGUMENT1        ; Point the file desriptor to the path
.3a6a82	8f 75 f2 3a	sta $3af275	                STA @l FD_IN.PATH
.3a6a86	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.3a6a8a	8f 77 f2 3a	sta $3af277	                STA @l FD_IN.PATH+2
.3a6a8e	28		plp		                PLP
.3a6a8f	2b		pld		                PLD
.3a6a90	60		rts		            RTS
.3a6a91					S_BLOAD
.3a6a91	08		php		                PHP
.3a6a92	c2 30		rep #$30	            REP #$30
.3a6a94	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a6a97	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a6a9a	20 a8 06	jsr $3a06a8	            JSR ASS_ARG1_STR
.3a6a9d	20 47 6a	jsr $3a6a47	            JSR SETFILEDESC
.3a6aa0	e2 20		sep #$20	            SEP #$20
.3a6aa2	a9 2c		lda #$2c	                LDA #','
.3a6aa4	85 37		sta $0837	                STA TARGETTOK
.3a6aa6	20 1c 22	jsr $3a221c	            JSR OPT_TOK
.3a6aa9	b0 0f		bcs $3a6aba	                BCS get_dest
.3a6aab	c2 20		rep #$20	            REP #$20
.3a6aad	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set destination address to something "safe"
.3a6ab0	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a6ab4	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a6ab8	80 17		bra $3a6ad1	                BRA do_load
.3a6aba					get_dest
.3a6aba	20 da 20	jsr $3a20da	            JSR INCBIP
.3a6abd	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a6ac0	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a6ac3	c2 20		rep #$20	            REP #$20
.3a6ac5	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the destination address
.3a6ac7	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a6acb	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6acd	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a6ad1	22 18 11 00	jsl $001118	do_load         JSL FK_LOAD                 ; Attempt to load the file
.3a6ad5	b0 1f		bcs $3a6af6	                BCS done
.3a6ad7	08		php		            PHP
.3a6ad8	c2 20		rep #$20	            REP #$20
.3a6ada	48		pha		            PHA
.3a6adb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6ade	5b		tcd		            TCD
.3a6adf	68		pla		            PLA
.3a6ae0	28		plp		            PLP
.3a6ae1	e2 20		sep #$20	            SEP #$20
.3a6ae3	a9 11		lda #$11	            LDA #ERR_LOAD
.3a6ae5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6ae9	c2 20		rep #$20	            REP #$20
.3a6aeb	29 ff 00	and #$00ff	            AND #$00FF
.3a6aee	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a6af1	e2 20		sep #$20	            SEP #$20
.3a6af3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6af6	28		plp		done            PLP
.3a6af7	60		rts		            RTS
.3a6af8					SET_DOSSTAT
.3a6af8	8b		phb		                PHB
.3a6af9	0b		phd		                PHD
.3a6afa	08		php		                PHP
.3a6afb	08		php		            PHP
.3a6afc	c2 20		rep #$20	            REP #$20
.3a6afe	48		pha		            PHA
.3a6aff	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a6b02	5b		tcd		            TCD
.3a6b03	68		pla		            PLA
.3a6b04	28		plp		            PLP
.3a6b05	08		php		            PHP
.3a6b06	e2 20		sep #$20	            SEP #$20
.3a6b08	48		pha		            PHA
.3a6b09	a9 00		lda #$00	            LDA #BASIC_BANK
.3a6b0b	48		pha		            PHA
.3a6b0c	ab		plb		            PLB
.3a6b0d	68		pla		            PLA
.3a6b0e	28		plp		            PLP
.3a6b0f	e2 20		sep #$20	            SEP #$20
.3a6b11	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS           ; Get the DOS status code
.3a6b15	85 23		sta $0823	                STA ARGUMENT1
.3a6b17	a9 00		lda #$00	                LDA #0
.3a6b19	85 24		sta $0824	                STA ARGUMENT1+1
.3a6b1b	85 25		sta $0825	                STA ARGUMENT1+2
.3a6b1d	85 26		sta $0826	                STA ARGUMENT1+3
.3a6b1f	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a6b21	85 27		sta $0827	                STA ARGTYPE1
.3a6b23	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (DOSSTAT)
.3a6b25	a9 3a		lda #$3a	                LDA #`dosstat_name
.3a6b27	85 e9		sta $08e9	                STA TOFIND+2
.3a6b29	c2 20		rep #$20	            REP #$20
.3a6b2b	a9 5b 6b	lda #$6b5b	                LDA #<>dosstat_name
.3a6b2e	85 e7		sta $08e7	                STA TOFIND
.3a6b30	20 e5 52	jsr $3a52e5	            JSR VAR_SET
.3a6b33	e2 20		sep #$20	            SEP #$20
.3a6b35	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS          ; Get the BIOS status code
.3a6b39	85 23		sta $0823	                STA ARGUMENT1
.3a6b3b	a9 00		lda #$00	                LDA #0
.3a6b3d	85 24		sta $0824	                STA ARGUMENT1+1
.3a6b3f	85 25		sta $0825	                STA ARGUMENT1+2
.3a6b41	85 26		sta $0826	                STA ARGUMENT1+3
.3a6b43	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a6b45	85 27		sta $0827	                STA ARGTYPE1
.3a6b47	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BIOSSTAT)
.3a6b49	a9 3a		lda #$3a	                LDA #`biosstat_name
.3a6b4b	85 e9		sta $08e9	                STA TOFIND+2
.3a6b4d	c2 20		rep #$20	            REP #$20
.3a6b4f	a9 63 6b	lda #$6b63	                LDA #<>biosstat_name
.3a6b52	85 e7		sta $08e7	                STA TOFIND
.3a6b54	20 e5 52	jsr $3a52e5	            JSR VAR_SET
.3a6b57	28		plp		                PLP
.3a6b58	2b		pld		                PLD
.3a6b59	ab		plb		                PLB
.3a6b5a	60		rts		            RTS
>3a6b5b	44 4f 53 53 54 41 54 00		dosstat_name    .null "DOSSTAT"
>3a6b63	42 49 4f 53 53 54 41 54		biosstat_name   .null "BIOSSTAT"
>3a6b6b	00
.3a6b6c					CMD_BRUN
.3a6b6c	08		php		                PHP
.3a6b6d	c2 30		rep #$30	            REP #$30
.3a6b6f	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a6b72	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a6b75	20 a8 06	jsr $3a06a8	            JSR ASS_ARG1_STR
.3a6b78	a5 23		lda $0823	                LDA ARGUMENT1
.3a6b7a	8f 60 03 00	sta $000360	                STA @l DOS_RUN_PARAM
.3a6b7e	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6b80	8f 62 03 00	sta $000362	                STA @l DOS_RUN_PARAM+2
.3a6b84	a9 ff ff	lda #$ffff	                LDA #$FFFF
.3a6b87	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a6b8b	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a6b8f	22 24 11 00	jsl $001124	                JSL FK_RUN                  ; Attempt to run the file
.3a6b93	b0 25		bcs $3a6bba	                BCS done                    ; If we got it: try to execute it
.3a6b95	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a6b98	20 f8 6a	jsr $3a6af8	            JSR SET_DOSSTAT
.3a6b9b	08		php		            PHP
.3a6b9c	c2 20		rep #$20	            REP #$20
.3a6b9e	48		pha		            PHA
.3a6b9f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6ba2	5b		tcd		            TCD
.3a6ba3	68		pla		            PLA
.3a6ba4	28		plp		            PLP
.3a6ba5	e2 20		sep #$20	            SEP #$20
.3a6ba7	a9 11		lda #$11	            LDA #ERR_LOAD
.3a6ba9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6bad	c2 20		rep #$20	            REP #$20
.3a6baf	29 ff 00	and #$00ff	            AND #$00FF
.3a6bb2	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a6bb5	e2 20		sep #$20	            SEP #$20
.3a6bb7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6bba					done
.3a6bba	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a6bbd	28		plp		                PLP
.3a6bbe	60		rts		            RTS
.3a6bbf					CMD_LOAD
.3a6bbf	08		php		                PHP
.3a6bc0	c2 30		rep #$30	            REP #$30
.3a6bc2	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a6bc5	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a6bc8	20 a8 06	jsr $3a06a8	            JSR ASS_ARG1_STR
.3a6bcb	20 47 6a	jsr $3a6a47	            JSR SETFILEDESC
.3a6bce	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.3a6bd1	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a6bd5	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.3a6bd8	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2        ; Set the destination address
.3a6bdc	20 b6 4f	jsr $3a4fb6	            JSR CMD_NEW
.3a6bdf	22 18 11 00	jsl $001118	                JSL FK_LOAD                 ; Attempt to load the file
.3a6be3	b0 22		bcs $3a6c07	                BCS start_tokenize          ; If we got it: start tokenizing
.3a6be5	20 f8 6a	jsr $3a6af8	            JSR SET_DOSSTAT
.3a6be8	08		php		            PHP
.3a6be9	c2 20		rep #$20	            REP #$20
.3a6beb	48		pha		            PHA
.3a6bec	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6bef	5b		tcd		            TCD
.3a6bf0	68		pla		            PLA
.3a6bf1	28		plp		            PLP
.3a6bf2	e2 20		sep #$20	            SEP #$20
.3a6bf4	a9 11		lda #$11	            LDA #ERR_LOAD
.3a6bf6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6bfa	c2 20		rep #$20	            REP #$20
.3a6bfc	29 ff 00	and #$00ff	            AND #$00FF
.3a6bff	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a6c02	e2 20		sep #$20	            SEP #$20
.3a6c04	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6c07					start_tokenize
.3a6c07	20 f8 6a	jsr $3a6af8	            JSR SET_DOSSTAT
.3a6c0a	c2 20		rep #$20	            REP #$20
.3a6c0c	a2 12 00	ldx #$0012	                LDX #FILEDESC.FILESIZE
.3a6c0f	18		clc		                CLC                         ; Set MTEMP to point to the byte after the file
.3a6c10	bf 73 f2 3a	lda $3af273,x	                LDA FD_IN,X
.3a6c14	69 00 00	adc #$0000	                ADC #<>LOADBLOCK
.3a6c17	85 92		sta $0892	                STA MTEMP
.3a6c19	bf 75 f2 3a	lda $3af275,x	                LDA FD_IN+2,X
.3a6c1d	69 01 00	adc #$0001	                ADC #`LOADBLOCK
.3a6c20	85 94		sta $0894	                STA MTEMP+2
.3a6c22	e2 20		sep #$20	            SEP #$20
.3a6c24	a9 00		lda #$00	                LDA #0
.3a6c26	87 92		sta [$0892]	                STA [MTEMP]                 ; Write a NULL right after the file
.3a6c28	c2 20		rep #$20	            REP #$20
.3a6c2a	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK            ; Set MCURSOR to the begining of the loaded data
.3a6c2d	85 7a		sta $087a	                STA MCURSOR
.3a6c2f	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.3a6c32	85 7c		sta $087c	                STA MCURSOR+2
.3a6c34	a2 00 00	ldx #$0000	copy_line       LDX #0
.3a6c37					copy_char
.3a6c37	e2 20		sep #$20	            SEP #$20
.3a6c39	a7 7a		lda [$087a]	                LDA [MCURSOR]
.3a6c3b	f0 2a		beq $3a6c67	                BEQ clean_up                ; If the character is 0, we're done
.3a6c3d	c9 0d		cmp #$0d	                CMP #CHAR_CR                ; If it is new line...
.3a6c3f	f0 12		beq $3a6c53	                BEQ do_process              ; ... we want to process the line
.3a6c41	c9 0a		cmp #$0a	                CMP #CHAR_LF                ; If it is a line feed...
.3a6c43	f0 04		beq $3a6c49	                BEQ next_char               ; ... we want to skip it
.3a6c45	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X              ; Otherwise, copy the character to the input buffer
.3a6c48	e8		inx		                INX
.3a6c49					next_char
.3a6c49	c2 20		rep #$20	            REP #$20
.3a6c4b	e6 7a		inc $087a	                INC MCURSOR                 ; Advance the input cursor
.3a6c4d	d0 e8		bne $3a6c37	                BNE copy_char
.3a6c4f	e6 7c		inc $087c	                INC MCURSOR+2
.3a6c51	80 e4		bra $3a6c37	                BRA copy_char
.3a6c53					do_process
.3a6c53	e2 20		sep #$20	            SEP #$20
.3a6c55	a9 00		lda #$00	                LDA #0                      ; Put a 0 at the end of the input buffer
.3a6c57	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a6c5a	20 4a 27	jsr $3a274a	            JSR PROCESS
.3a6c5d	c2 20		rep #$20	            REP #$20
.3a6c5f	e6 7a		inc $087a	                INC MCURSOR                 ; Try again with the next line
.3a6c61	d0 d1		bne $3a6c34	                BNE copy_line
.3a6c63	e6 7c		inc $087c	                INC MCURSOR+2
.3a6c65	80 cd		bra $3a6c34	                BRA copy_line
.3a6c67	e0 00 00	cpx #$0000	clean_up        CPX #0                      ; Is there data in the INPUTBUF?
.3a6c6a	f0 0a		beq $3a6c76	                BEQ done                    ; No: just return
.3a6c6c	e2 20		sep #$20	            SEP #$20
.3a6c6e	a9 00		lda #$00	                LDA #0                      ; Make sure there is a trailing NULL
.3a6c70	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a6c73	20 4a 27	jsr $3a274a	            JSR PROCESS
.3a6c76	28		plp		done            PLP
.3a6c77	60		rts		            RTS
.3a6c78					S_BSAVE
.3a6c78	08		php		                PHP
.3a6c79	c2 30		rep #$30	            REP #$30
.3a6c7b	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a6c7e	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a6c81	20 a8 06	jsr $3a06a8	            JSR ASS_ARG1_STR
.3a6c84	20 47 6a	jsr $3a6a47	            JSR SETFILEDESC
.3a6c87	e2 20		sep #$20	            SEP #$20
.3a6c89	a9 2c		lda #$2c	                LDA #','
.3a6c8b	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a6c8e	c2 20		rep #$20	            REP #$20
.3a6c90	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a6c93	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a6c96	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_SRC_PTR
.3a6c98	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.3a6c9c	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6c9e	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.3a6ca2	e2 20		sep #$20	            SEP #$20
.3a6ca4	a9 2c		lda #$2c	                LDA #','
.3a6ca6	c2 20		rep #$20	            REP #$20
.3a6ca8	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a6cab	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a6cae	20 16 06	jsr $3a0616	            JSR ASS_ARG1_INT
.3a6cb1	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_END_PTR
.3a6cb3	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.3a6cb7	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6cb9	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.3a6cbd	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                 ; Attempt to save the memory to file.
.3a6cc1	b0 22		bcs $3a6ce5	                BCS done
.3a6cc3	20 f8 6a	jsr $3a6af8	            JSR SET_DOSSTAT
.3a6cc6	08		php		            PHP
.3a6cc7	c2 20		rep #$20	            REP #$20
.3a6cc9	48		pha		            PHA
.3a6cca	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6ccd	5b		tcd		            TCD
.3a6cce	68		pla		            PLA
.3a6ccf	28		plp		            PLP
.3a6cd0	e2 20		sep #$20	            SEP #$20
.3a6cd2	a9 12		lda #$12	            LDA #ERR_SAVE
.3a6cd4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6cd8	c2 20		rep #$20	            REP #$20
.3a6cda	29 ff 00	and #$00ff	            AND #$00FF
.3a6cdd	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a6ce0	e2 20		sep #$20	            SEP #$20
.3a6ce2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6ce5					done
.3a6ce5	20 f8 6a	jsr $3a6af8	            JSR SET_DOSSTAT
.3a6ce8	28		plp		                PLP
.3a6ce9	60		rts		            RTS
.3a6cea					COPY2PATHBUF
.3a6cea	da		phx		                PHX
.3a6ceb	5a		phy		                PHY
.3a6cec	08		php		                PHP
.3a6ced	a2 00 00	ldx #$0000	                LDX #0
.3a6cf0	a0 00 00	ldy #$0000	                LDY #0
.3a6cf3	e2 20		sep #$20	            SEP #$20
.3a6cf5	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y           ; Copy the path to the DOS_PATH_BUFF
.3a6cf7	9d 00 04	sta $0400,x	                STA DOS_PATH_BUFF,X
.3a6cfa	f0 04		beq $3a6d00	                BEQ done
.3a6cfc	e8		inx		                INX
.3a6cfd	c8		iny		                INY
.3a6cfe	80 f5		bra $3a6cf5	                BRA loop
.3a6d00	28		plp		done            PLP
.3a6d01	7a		ply		                PLY
.3a6d02	fa		plx		                PLX
.3a6d03	60		rts		            RTS
.3a6d04					CMD_SAVE
.3a6d04	08		php		                PHP
.3a6d05	c2 30		rep #$30	            REP #$30
.3a6d07	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a6d0a	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a6d0d	20 a8 06	jsr $3a06a8	            JSR ASS_ARG1_STR
.3a6d10	20 47 6a	jsr $3a6a47	            JSR SETFILEDESC
.3a6d13	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.3a6d16	85 a6		sta $08a6	                STA OBUFFER
.3a6d18	e2 20		sep #$20	            SEP #$20
.3a6d1a	a9 01		lda #$01	                LDA #`LOADBLOCK
.3a6d1c	85 a8		sta $08a8	                STA OBUFFER+2
.3a6d1e	a9 20		lda #$20	                LDA #DEV_BUFFER             ; Set up output for the buffer
.3a6d20	85 b4		sta $08b4	                STA BCONSOLE
.3a6d22	c2 20		rep #$20	            REP #$20
.3a6d24	a9 00 00	lda #$0000	                LDA #0
.3a6d27	85 ab		sta $08ab	                STA OBUFFIDX
.3a6d29	a9 ff ff	lda #$ffff	                LDA #$FFFF
.3a6d2c	85 a9		sta $08a9	                STA OBUFFSIZE
.3a6d2e	c2 20		rep #$20	            REP #$20
.3a6d30	a9 00 00	lda #$0000	                LDA #0                      ; Set start line number to 0
.3a6d33	85 55		sta $0855	                STA MARG1
.3a6d35	85 57		sta $0857	                STA MARG1+2
.3a6d37	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set end line number to MAXINT
.3a6d3a	85 59		sta $0859	                STA MARG2
.3a6d3c	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.3a6d3f	85 5b		sta $085b	                STA MARG2+2
.3a6d41	20 48 18	jsr $3a1848	            JSR LISTPROG
.3a6d44	e2 20		sep #$20	            SEP #$20
.3a6d46	a9 80		lda #$80	                LDA #DEV_SCREEN             ; Restore output to the screen
.3a6d48	85 b4		sta $08b4	                STA BCONSOLE
.3a6d4a	c2 20		rep #$20	            REP #$20
.3a6d4c	c6 ab		dec $08ab	                DEC OBUFFIDX                ; OBUFFIDX points to the next free byte... so pull it in one
.3a6d4e	18		clc		                CLC                         ; Set the range of memory to save
.3a6d4f	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.3a6d52	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.3a6d56	65 ab		adc $08ab	                ADC OBUFFIDX
.3a6d58	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.3a6d5c	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.3a6d5f	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.3a6d63	69 00 00	adc #$0000	                ADC #0
.3a6d66	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.3a6d6a	22 1c 11 00	jsl $00111c	do_save         JSL FK_SAVE                 ; Attempt to save the file
.3a6d6e	b0 22		bcs $3a6d92	                BCS done
.3a6d70	20 f8 6a	jsr $3a6af8	            JSR SET_DOSSTAT
.3a6d73	08		php		            PHP
.3a6d74	c2 20		rep #$20	            REP #$20
.3a6d76	48		pha		            PHA
.3a6d77	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6d7a	5b		tcd		            TCD
.3a6d7b	68		pla		            PLA
.3a6d7c	28		plp		            PLP
.3a6d7d	e2 20		sep #$20	            SEP #$20
.3a6d7f	a9 12		lda #$12	            LDA #ERR_SAVE
.3a6d81	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6d85	c2 20		rep #$20	            REP #$20
.3a6d87	29 ff 00	and #$00ff	            AND #$00FF
.3a6d8a	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a6d8d	e2 20		sep #$20	            SEP #$20
.3a6d8f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6d92					done
.3a6d92	20 f8 6a	jsr $3a6af8	            JSR SET_DOSSTAT
.3a6d95	28		plp		                PLP
.3a6d96	60		rts		            RTS
.3a6d97					S_DEL
.3a6d97	08		php		                PHP
.3a6d98	c2 30		rep #$30	            REP #$30
.3a6d9a	20 fb 20	jsr $3a20fb	            JSR SKIPWS
.3a6d9d	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a6da0	20 a8 06	jsr $3a06a8	            JSR ASS_ARG1_STR
.3a6da3	20 ea 6c	jsr $3a6cea	            JSR COPY2PATHBUF
.3a6da6	22 04 11 00	jsl $001104	path_loaded     JSL FK_DELETE               ; Try to delete the file
.3a6daa	b0 22		bcs $3a6dce	                BCS done
.3a6dac	20 f8 6a	jsr $3a6af8	            JSR SET_DOSSTAT
.3a6daf	08		php		            PHP
.3a6db0	c2 20		rep #$20	            REP #$20
.3a6db2	48		pha		            PHA
.3a6db3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6db6	5b		tcd		            TCD
.3a6db7	68		pla		            PLA
.3a6db8	28		plp		            PLP
.3a6db9	e2 20		sep #$20	            SEP #$20
.3a6dbb	a9 13		lda #$13	            LDA #ERR_DELETE
.3a6dbd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6dc1	c2 20		rep #$20	            REP #$20
.3a6dc3	29 ff 00	and #$00ff	            AND #$00FF
.3a6dc6	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a6dc9	e2 20		sep #$20	            SEP #$20
.3a6dcb	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6dce					done
.3a6dce	20 f8 6a	jsr $3a6af8	            JSR SET_DOSSTAT
.3a6dd1	28		plp		                PLP
.3a6dd2	60		rts		            RTS
.3a6dd3					VALIDFILECHAR
.3a6dd3	da		phx		                PHX
.3a6dd4	08		php		                PHP
.3a6dd5	e2 20		sep #$20	            SEP #$20
.3a6dd7	c9 61		cmp #$61	                CMP #'a'                    ; Is it lower case?
.3a6dd9	90 08		bcc $3a6de3	                BLT chk_space
.3a6ddb	c9 7b		cmp #$7b	                CMP #'z'+1
.3a6ddd	b0 04		bcs $3a6de3	                BGE chk_space
.3a6ddf	29 df		and #$df	                AND #%11011111              ; Yes: convert to upper case
.3a6de1	80 13		bra $3a6df6	                BRA ret_valid
.3a6de3	c9 20		cmp #$20	chk_space       CMP #CHAR_SP            ; Is it a control code?
.3a6de5	90 13		bcc $3a6dfa	                BLT is_invalid          ; Yes: it's invalid
.3a6de7	a2 00 00	ldx #$0000	                LDX #0                  ; See if it's in the list of invalids
.3a6dea	df fe 6d 3a	cmp $3a6dfe,x	loop            CMP invalid_chars,X
.3a6dee	f0 0a		beq $3a6dfa	                BEQ is_invalid
.3a6df0	e8		inx		                INX
.3a6df1	e0 0f 00	cpx #$000f	                CPX #15                 ; # of invalid characters
.3a6df4	d0 f4		bne $3a6dea	                BNE loop
.3a6df6	28		plp		ret_valid       PLP
.3a6df7	38		sec		                SEC
.3a6df8	fa		plx		                PLX
.3a6df9	6b		rtl		                RTL
.3a6dfa	28		plp		is_invalid      PLP
.3a6dfb	18		clc		                CLC
.3a6dfc	fa		plx		                PLX
.3a6dfd	6b		rtl		                RTL
>3a6dfe	2a 2b 2c 2f 3a 3b 3c 3d		invalid_chars   .text "*+,/:;<=>?\[]|",CHAR_DQUOTE
>3a6e06	3e 3f 5c 5b 5d 7c 22
.3a6e0d					S_RENAME
.3a6e0d	08		php		                PHP
.3a6e0e	08		php		            PHP
.3a6e0f	c2 20		rep #$20	            REP #$20
.3a6e11	48		pha		            PHA
.3a6e12	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a6e15	5b		tcd		            TCD
.3a6e16	68		pla		            PLA
.3a6e17	28		plp		            PLP
.3a6e18	c2 30		rep #$30	            REP #$30
.3a6e1a	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a6e1d	20 a8 06	jsr $3a06a8	            JSR ASS_ARG1_STR
.3a6e20	20 ea 6c	jsr $3a6cea	            JSR COPY2PATHBUF
.3a6e23	22 10 11 00	jsl $001110	                JSL FK_DIRREAD              ; Try to read the file
.3a6e27	b0 22		bcs $3a6e4b	                BCS get_new_name            ; If ok: get the new name
.3a6e29	20 f8 6a	jsr $3a6af8	            JSR SET_DOSSTAT
.3a6e2c	08		php		            PHP
.3a6e2d	c2 20		rep #$20	            REP #$20
.3a6e2f	48		pha		            PHA
.3a6e30	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6e33	5b		tcd		            TCD
.3a6e34	68		pla		            PLA
.3a6e35	28		plp		            PLP
.3a6e36	e2 20		sep #$20	            SEP #$20
.3a6e38	a9 14		lda #$14	            LDA #ERR_FILENOTFOUND
.3a6e3a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6e3e	c2 20		rep #$20	            REP #$20
.3a6e40	29 ff 00	and #$00ff	            AND #$00FF
.3a6e43	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a6e46	e2 20		sep #$20	            SEP #$20
.3a6e48	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6e4b					get_new_name
.3a6e4b	e2 20		sep #$20	            SEP #$20
.3a6e4d	a9 2c		lda #$2c	                LDA #','
.3a6e4f	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a6e52	c2 20		rep #$20	            REP #$20
.3a6e54	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a6e57	20 a8 06	jsr $3a06a8	            JSR ASS_ARG1_STR
.3a6e5a	ad 38 03	lda $0338	                LDA DOS_DIR_PTR
.3a6e5d	85 08		sta $0808	                STA INDEX
.3a6e5f	ad 3a 03	lda $033a	                LDA DOS_DIR_PTR+2
.3a6e62	85 0a		sta $080a	                STA INDEX+2
.3a6e64	e2 20		sep #$20	            SEP #$20
.3a6e66	a2 00 00	ldx #$0000	                LDX #0
.3a6e69	a9 20		lda #$20	                LDA #CHAR_SP                ; We'll use MLINEBUFF as temporary name storage
.3a6e6b	95 7e		sta $087e,x	blank_loop      STA MLINEBUF,X              ; Fill it with blanks
.3a6e6d	e8		inx		                INX
.3a6e6e	e0 0b 00	cpx #$000b	                CPX #11
.3a6e71	d0 f8		bne $3a6e6b	                BNE blank_loop
.3a6e73	a2 00 00	ldx #$0000	                LDX #0
.3a6e76	a0 00 00	ldy #$0000	                LDY #0
.3a6e79	b7 23		lda [$0823],y	name_loop       LDA [ARGUMENT1],Y           ; Get the character of the new name
.3a6e7b	f0 76		beq $3a6ef3	                BEQ copy_short_name         ; If end-of-string: copy what we have
.3a6e7d	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.3a6e7f	f0 39		beq $3a6eba	                BEQ skip_dot                ; Yes: move on to the extension characters
.3a6e81	22 d3 6d 3a	jsl $3a6dd3	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.3a6e85	b0 1f		bcs $3a6ea6	                BCS save_nm_char
.3a6e87	08		php		            PHP
.3a6e88	c2 20		rep #$20	            REP #$20
.3a6e8a	48		pha		            PHA
.3a6e8b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6e8e	5b		tcd		            TCD
.3a6e8f	68		pla		            PLA
.3a6e90	28		plp		            PLP
.3a6e91	e2 20		sep #$20	            SEP #$20
.3a6e93	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a6e95	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6e99	c2 20		rep #$20	            REP #$20
.3a6e9b	29 ff 00	and #$00ff	            AND #$00FF
.3a6e9e	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a6ea1	e2 20		sep #$20	            SEP #$20
.3a6ea3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6ea6	95 7e		sta $087e,x	save_nm_char    STA MLINEBUF,X              ; Otherwise: copy it
.3a6ea8	c8		iny		                INY
.3a6ea9	e8		inx		                INX
.3a6eaa	c0 08 00	cpy #$0008	                CPY #8
.3a6ead	d0 ca		bne $3a6e79	                BNE name_loop
.3a6eaf	b7 23		lda [$0823],y	eat_name        LDA [ARGUMENT1],Y           ; Get the character
.3a6eb1	f0 40		beq $3a6ef3	                BEQ copy_short_name         ; If null, we're done with the short name
.3a6eb3	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.3a6eb5	f0 03		beq $3a6eba	                BEQ skip_dot                ; Yes: skip over it
.3a6eb7	c8		iny		                INY                         ; No: try again with the the next character
.3a6eb8	80 f5		bra $3a6eaf	                BRA eat_name
.3a6eba	c8		iny		skip_dot        INY                         ; Character at Y is '.', so skip over it
.3a6ebb	a2 08 00	ldx #$0008	do_ext          LDX #8
.3a6ebe	b7 23		lda [$0823],y	ext_loop        LDA [ARGUMENT1],Y           ; Get the character of the new extension
.3a6ec0	f0 31		beq $3a6ef3	                BEQ copy_short_name         ; If end-of-string: copy what we have
.3a6ec2	22 d3 6d 3a	jsl $3a6dd3	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.3a6ec6	b0 22		bcs $3a6eea	                BCS save_ext_char
.3a6ec8	20 f8 6a	jsr $3a6af8	            JSR SET_DOSSTAT
.3a6ecb	08		php		            PHP
.3a6ecc	c2 20		rep #$20	            REP #$20
.3a6ece	48		pha		            PHA
.3a6ecf	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6ed2	5b		tcd		            TCD
.3a6ed3	68		pla		            PLA
.3a6ed4	28		plp		            PLP
.3a6ed5	e2 20		sep #$20	            SEP #$20
.3a6ed7	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a6ed9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6edd	c2 20		rep #$20	            REP #$20
.3a6edf	29 ff 00	and #$00ff	            AND #$00FF
.3a6ee2	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a6ee5	e2 20		sep #$20	            SEP #$20
.3a6ee7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6eea	95 7e		sta $087e,x	save_ext_char   STA MLINEBUF,X              ; Otherwise: copy it
.3a6eec	c8		iny		                INY
.3a6eed	e8		inx		                INX
.3a6eee	c0 0c 00	cpy #$000c	                CPY #12
.3a6ef1	d0 cb		bne $3a6ebe	                BNE ext_loop
.3a6ef3	a2 00 00	ldx #$0000	copy_short_name LDX #0                      ; Copy the short name we built to the directory entry
.3a6ef6	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME
.3a6ef9	b5 7e		lda $087e,x	copy_loop       LDA MLINEBUF,X
.3a6efb	97 08		sta [$0808],y	                STA [INDEX],Y
.3a6efd	e8		inx		                INX
.3a6efe	c8		iny		                INY
.3a6eff	c0 0b 00	cpy #$000b	                CPY #11
.3a6f02	d0 f5		bne $3a6ef9	                BNE copy_loop
.3a6f04	22 14 11 00	jsl $001114	                JSL FK_DIRWRITE             ; Write the directory entry back
.3a6f08	b0 22		bcs $3a6f2c	                BCS done
.3a6f0a	20 f8 6a	jsr $3a6af8	            JSR SET_DOSSTAT
.3a6f0d	08		php		            PHP
.3a6f0e	c2 20		rep #$20	            REP #$20
.3a6f10	48		pha		            PHA
.3a6f11	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6f14	5b		tcd		            TCD
.3a6f15	68		pla		            PLA
.3a6f16	28		plp		            PLP
.3a6f17	e2 20		sep #$20	            SEP #$20
.3a6f19	a9 15		lda #$15	            LDA #ERR_DIRNOTWRITE
.3a6f1b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6f1f	c2 20		rep #$20	            REP #$20
.3a6f21	29 ff 00	and #$00ff	            AND #$00FF
.3a6f24	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a6f27	e2 20		sep #$20	            SEP #$20
.3a6f29	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6f2c					done
.3a6f2c	20 f8 6a	jsr $3a6af8	            JSR SET_DOSSTAT
.3a6f2f	28		plp		                PLP
.3a6f30	60		rts		            RTS
.3a6f31					S_COPY
.3a6f31	08		php		                PHP
.3a6f32	08		php		            PHP
.3a6f33	c2 20		rep #$20	            REP #$20
.3a6f35	48		pha		            PHA
.3a6f36	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a6f39	5b		tcd		            TCD
.3a6f3a	68		pla		            PLA
.3a6f3b	28		plp		            PLP
.3a6f3c	c2 30		rep #$30	            REP #$30
.3a6f3e	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a6f41	20 a8 06	jsr $3a06a8	            JSR ASS_ARG1_STR
.3a6f44	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.3a6f46	8f 64 03 00	sta $000364	                STA @l DOS_STR1_PTR
.3a6f4a	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6f4c	8f 66 03 00	sta $000366	                STA @l DOS_STR1_PTR+2
.3a6f50	e2 20		sep #$20	            SEP #$20
.3a6f52	a9 2c		lda #$2c	                LDA #','
.3a6f54	20 e7 21	jsr $3a21e7	            JSR EXPECT_TOK
.3a6f57	c2 20		rep #$20	            REP #$20
.3a6f59	20 c9 1c	jsr $3a1cc9	            JSR EVALEXPR
.3a6f5c	20 a8 06	jsr $3a06a8	            JSR ASS_ARG1_STR
.3a6f5f	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.3a6f61	8f 68 03 00	sta $000368	                STA @l DOS_STR2_PTR
.3a6f65	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6f67	8f 6a 03 00	sta $00036a	                STA @l DOS_STR2_PTR+2
.3a6f6b	22 30 11 00	jsl $001130	                JSL FK_COPY                 ; Attempt to copy the file
.3a6f6f	b0 1f		bcs $3a6f90	                BCS done
.3a6f71	08		php		            PHP
.3a6f72	c2 20		rep #$20	            REP #$20
.3a6f74	48		pha		            PHA
.3a6f75	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6f78	5b		tcd		            TCD
.3a6f79	68		pla		            PLA
.3a6f7a	28		plp		            PLP
.3a6f7b	e2 20		sep #$20	            SEP #$20
.3a6f7d	a9 16		lda #$16	            LDA #ERR_NOTCOPIED
.3a6f7f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6f83	c2 20		rep #$20	            REP #$20
.3a6f85	29 ff 00	and #$00ff	            AND #$00FF
.3a6f88	20 1b 1e	jsr $3a1e1b	            JSR SET_ERRERL
.3a6f8b	e2 20		sep #$20	            SEP #$20
.3a6f8d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6f90	28		plp		done            PLP
.3a6f91	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\monitor.s

.3a6f92	5c 4f 89 3a	jmp $3a894f	MRETURN         JML IMRETURN
.3a6f96	5c a0 87 3a	jmp $3a87a0	MPARSE          JML IMPARSE
.3a6f9a	5c 50 89 3a	jmp $3a8950	MPARSE1         JML IMPARSE1
.3a6f9e	5c cc 78 3a	jmp $3a78cc	MEXECUTE        JML IMEXECUTE
.3a6fa2	5c 29 79 3a	jmp $3a7929	MASSEMBLE       JML IMASSEMBLE
.3a6fa6	5c 5c 78 3a	jmp $3a785c	MRMODIFY        JML IMRMODIFY
.3a6faa	5c e2 77 3a	jmp $3a77e2	MCOMPARE        JML IMCOMPARE
.3a6fae	5c 5f 7d 3a	jmp $3a7d5f	MDISASSEMBLE    JML IMDISASSEMBLE
.3a6fb2	5c 4d 74 3a	jmp $3a744d	MFILL           JML IMFILL
.3a6fb6	5c 7a 77 3a	jmp $3a777a	MGO             JML IMGO
.3a6fba	5c 35 77 3a	jmp $3a7735	MJUMP           JML IMJUMP
.3a6fbe	5c bf 76 3a	jmp $3a76bf	MHUNT           JML IMHUNT
.3a6fc2	5c 5e 88 3a	jmp $3a885e	MLOAD           JML IMLOAD
.3a6fc6	5c 5b 75 3a	jmp $3a755b	MMEMORY         JML IMMEMORY
.3a6fca	5c ab 73 3a	jmp $3a73ab	MREGISTERS      JML IMREGISTERS
.3a6fce	5c d9 88 3a	jmp $3a88d9	MSAVE           JML IMSAVE
.3a6fd2	5c 89 74 3a	jmp $3a7489	MTRANSFER       JML IMTRANSFER
.3a6fd6	5c 52 89 3a	jmp $3a8952	MVERIFY         JML IMVERIFY
.3a6fda	5c 4b 89 3a	jmp $3a894b	MEXIT           JML IMEXIT
.3a6fde	5c 78 76 3a	jmp $3a7678	MMODIFY         JML IMMODIFY
.3a6fe2	5c 53 89 3a	jmp $3a8953	MDOS            JML IMDOS
.3a6fe6	18		clc		IMONITOR        CLC                 ; clear the carry flag
.3a6fe7	fb		xce		                XCE                 ; move carry to emulation flags
.3a6fe8	58		cli		                CLI                 ; Re-enable interrupts
.3a6fe9	5c ed 6f 3a	jmp $3a6fed	                JML IMREADY
.3a6fed					IMREADY
.3a6fed	c2 30		rep #$30	            REP #$30
.3a6fef	22 ab 73 3a	jsl $3a73ab	                JSL IMREGISTERS
.3a6ff3					ready_loop
.3a6ff3	20 08 00	jsr $3a0008	            JSR READLINE
.3a6ff6	20 0c 00	jsr $3a000c	            JSR SCRCOPYLINE
.3a6ff9	8b		phb		                PHB
.3a6ffa	e2 20		sep #$20	            SEP #$20
.3a6ffc	a9 00		lda #$00	                LDA #`INPUTBUF
.3a6ffe	48		pha		                PHA
.3a6fff	ab		plb		                PLB
.3a7000	a2 00 4f	ldx #$4f00	                LDX #<>INPUTBUF
.3a7003	20 2a 05	jsr $3a052a	            JSR TOUPPER
.3a7006	ab		plb		                PLB
.3a7007	22 96 6f 3a	jsl $3a6f96	                JSL MPARSE          ; Parse the command
.3a700b	22 9e 6f 3a	jsl $3a6f9e	                JSL MEXECUTE        ; And execute the parsed command
.3a700f	80 e2		bra $3a6ff3	                BRA ready_loop
.3a7011					IMHELP
.3a7011	08		php		                PHP
.3a7012	8b		phb		                PHB
.3a7013	e2 20		sep #$20	            SEP #$20
.3a7015	a9 3a		lda #$3a	                LDA #`help_text
.3a7017	48		pha		                PHA
.3a7018	ab		plb		                PLB
.3a7019	c2 10		rep #$10	            REP #$10
.3a701b	a2 24 70	ldx #$7024	                LDX #<>help_text
.3a701e	20 29 04	jsr $3a0429	            JSR PRINTS
.3a7021	ab		plb		                PLB
.3a7022	28		plp		                PLP
.3a7023	6b		rtl		                RTL
>3a7024	41 20 3c 73 74 61 72 74		help_text       .text "A <start> <assembly>",CHAR_CR
>3a702c	3e 20 3c 61 73 73 65 6d 62 6c 79 3e 0d
>3a7039	20 20 41 73 73 65 6d 62		                .text "  Assemble a program",CHAR_CR,CHAR_CR
>3a7041	6c 65 20 61 20 70 72 6f 67 72 61 6d 0d 0d
>3a704f	43 20 3c 73 74 61 72 74		                .text "C <start1> <start2> [len (1 if blank)]",CHAR_CR
>3a7057	31 3e 20 3c 73 74 61 72 74 32 3e 20 5b 6c 65 6e
>3a7067	20 28 31 20 69 66 20 62 6c 61 6e 6b 29 5d 0d
>3a7076	20 20 43 6f 6d 70 61 72		                .text "  Compare to sections of memory",CHAR_CR,CHAR_CR
>3a707e	65 20 74 6f 20 73 65 63 74 69 6f 6e 73 20 6f 66
>3a708e	20 6d 65 6d 6f 72 79 0d 0d
>3a7097	44 20 3c 73 74 61 72 74		                .text "D <start> [end]",CHAR_CR
>3a709f	3e 20 5b 65 6e 64 5d 0d
>3a70a7	20 20 44 69 73 61 73 73		                .text "  Disassemble a program",CHAR_CR,CHAR_CR
>3a70af	65 6d 62 6c 65 20 61 20 70 72 6f 67 72 61 6d 0d
>3a70bf	0d
>3a70c0	46 20 3c 73 74 61 72 74		                .text "F <start> <end> <byte>",CHAR_CR
>3a70c8	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 0d
>3a70d7	20 20 46 69 6c 6c 20 61		                .text "  Fill a block of memory with a byte",CHAR_CR,CHAR_CR
>3a70df	20 62 6c 6f 63 6b 20 6f 66 20 6d 65 6d 6f 72 79
>3a70ef	20 77 69 74 68 20 61 20 62 79 74 65 0d 0d
>3a70fd	47 20 5b 61 64 64 72 65		                .text "G [address]",CHAR_CR
>3a7105	73 73 5d 0d
>3a7109	20 20 53 74 61 72 74 20		                .text "  Start execution at a location",CHAR_CR,CHAR_CR
>3a7111	65 78 65 63 75 74 69 6f 6e 20 61 74 20 61 20 6c
>3a7121	6f 63 61 74 69 6f 6e 0d 0d
>3a712a	4a 20 5b 61 64 64 72 65		                .text "J [address] - Jump to a location in memory",CHAR_CR
>3a7132	73 73 5d 20 2d 20 4a 75 6d 70 20 74 6f 20 61 20
>3a7142	6c 6f 63 61 74 69 6f 6e 20 69 6e 20 6d 65 6d 6f
>3a7152	72 79 0d
>3a7155	20 20 4a 75 6d 70 20 74		                .text "  Jump to a location in memory",CHAR_CR,CHAR_CR
>3a715d	6f 20 61 20 6c 6f 63 61 74 69 6f 6e 20 69 6e 20
>3a716d	6d 65 6d 6f 72 79 0d 0d
>3a7175	48 20 3c 73 74 61 72 74		                .text "H <start> <end> <byte> [byte]..",CHAR_CR
>3a717d	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 20 5b
>3a718d	62 79 74 65 5d 2e 2e 0d
>3a7195	20 20 48 75 6e 74 20 66		                .text "  Hunt for values in memory",CHAR_CR,CHAR_CR
>3a719d	6f 72 20 76 61 6c 75 65 73 20 69 6e 20 6d 65 6d
>3a71ad	6f 72 79 0d 0d
>3a71b2	4c 20 20 20 20 20 4c 4f		                .text "L     LOAD         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," [destination]",CHAR_CR
>3a71ba	41 44 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>3a71ca	22 20 5b 64 65 73 74 69 6e 61 74 69 6f 6e 5d 0d
>3a71da	4d 20 3c 73 74 61 72 74		                .text "M <start> [end]",CHAR_CR
>3a71e2	3e 20 5b 65 6e 64 5d 0d
>3a71ea	20 20 44 75 6d 70 20 74		                .text "  Dump the value in memory",CHAR_CR,CHAR_CR
>3a71f2	68 65 20 76 61 6c 75 65 20 69 6e 20 6d 65 6d 6f
>3a7202	72 79 0d 0d
>3a7206	52 20 2d 20 44 69 73 70		                .text "R - Display the values of the registers",CHAR_CR,CHAR_CR
>3a720e	6c 61 79 20 74 68 65 20 76 61 6c 75 65 73 20 6f
>3a721e	66 20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d
>3a722e	0d
>3a722f	3b 20 3c 50 43 3e 20 3c		                .text "; <PC> <A> <X> <Y> <SP> <DBR> <DP> <NVMXDIZC>",CHAR_CR
>3a7237	41 3e 20 3c 58 3e 20 3c 59 3e 20 3c 53 50 3e 20
>3a7247	3c 44 42 52 3e 20 3c 44 50 3e 20 3c 4e 56 4d 58
>3a7257	44 49 5a 43 3e 0d
>3a725d	20 20 43 68 61 6e 67 65		                .text "  Change the contents of the registers",CHAR_CR,CHAR_CR
>3a7265	20 74 68 65 20 63 6f 6e 74 65 6e 74 73 20 6f 66
>3a7275	20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d 0d
>3a7285	53 20 20 20 20 20 53 41		                .text "S     SAVE         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," <start> <end>",CHAR_CR
>3a728d	56 45 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>3a729d	22 20 3c 73 74 61 72 74 3e 20 3c 65 6e 64 3e 0d
>3a72ad	54 20 3c 73 74 61 72 74		                .text "T <start> <end> <destination>",CHAR_CR
>3a72b5	3e 20 3c 65 6e 64 3e 20 3c 64 65 73 74 69 6e 61
>3a72c5	74 69 6f 6e 3e 0d
>3a72cb	20 20 54 72 61 6e 73 66		                .text "  Transfer (copy) data within memory",CHAR_CR,CHAR_CR
>3a72d3	65 72 20 28 63 6f 70 79 29 20 64 61 74 61 20 77
>3a72e3	69 74 68 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>3a72f1	57 20 3c 62 79 74 65 3e		                .text "W <byte>",CHAR_CR
>3a72f9	0d
>3a72fa	20 20 53 65 74 20 74 68		                .text "  Set the register width flags for the disassembler",CHAR_CR,CHAR_CR
>3a7302	65 20 72 65 67 69 73 74 65 72 20 77 69 64 74 68
>3a7312	20 66 6c 61 67 73 20 66 6f 72 20 74 68 65 20 64
>3a7322	69 73 61 73 73 65 6d 62 6c 65 72 0d 0d
>3a732f	58 20 2d 20 52 65 74 75		                .text "X - Return to BASIC",CHAR_CR,CHAR_CR
>3a7337	72 6e 20 74 6f 20 42 41 53 49 43 0d 0d
>3a7344	3e 20 3c 73 74 61 72 74		                .text "> <start> <byte> [byte]...",CHAR_CR
>3a734c	3e 20 3c 62 79 74 65 3e 20 5b 62 79 74 65 5d 2e
>3a735c	2e 2e 0d
>3a735f	20 20 45 64 69 74 20 64		                .text "  Edit data in memory",CHAR_CR,CHAR_CR
>3a7367	61 74 61 20 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>3a7376	3f 20 2d 20 44 69 73 70		                .null "? - Display a short help screen",CHAR_CR,CHAR_CR
>3a737e	6c 61 79 20 61 20 73 68 6f 72 74 20 68 65 6c 70
>3a738e	20 73 63 72 65 65 6e 0d 0d 00
.3a7398					IMWIDTH
.3a7398	08		php		                PHP
.3a7399	08		php		            PHP
.3a739a	c2 20		rep #$20	            REP #$20
.3a739c	48		pha		            PHA
.3a739d	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a73a0	5b		tcd		            TCD
.3a73a1	68		pla		            PLA
.3a73a2	28		plp		            PLP
.3a73a3	e2 20		sep #$20	            SEP #$20
.3a73a5	a5 0d		lda $0855	                LDA MARG1
.3a73a7	85 4e		sta $0896	                STA MCPUSTAT
.3a73a9	28		plp		                PLP
.3a73aa	6b		rtl		                RTL
.3a73ab					IMREGISTERS
.3a73ab	20 3d 02	jsr $3a023d	            JSR ENSURETEXT
.3a73ae	08		php		            PHP
.3a73af	e2 20		sep #$20	            SEP #$20
.3a73b1	48		pha		            PHA
.3a73b2	a9 3a		lda #$3a	            LDA #`mregisters_msg
.3a73b4	48		pha		            PHA
.3a73b5	ab		plb		            PLB
.3a73b6	68		pla		            PLA
.3a73b7	28		plp		            PLP
.3a73b8	a2 90 89	ldx #$8990	                LDX #<>mregisters_msg
.3a73bb	20 29 04	jsr $3a0429	            JSR PRINTS
.3a73be	e2 20		sep #$20	            SEP #$20
.3a73c0	a9 3b		lda #$3b	                LDA #';'
.3a73c2	20 18 00	jsr $3a0018	            JSR PRINTC
.3a73c5	a9 20		lda #$20	                LDA #' '
.3a73c7	20 18 00	jsr $3a0018	            JSR PRINTC
.3a73ca	c2 30		rep #$30	            REP #$30
.3a73cc	08		php		            PHP
.3a73cd	e2 20		sep #$20	            SEP #$20
.3a73cf	48		pha		            PHA
.3a73d0	a9 00		lda #$00	            LDA #$0
.3a73d2	48		pha		            PHA
.3a73d3	ab		plb		            PLB
.3a73d4	68		pla		            PLA
.3a73d5	28		plp		            PLP
.3a73d6	a0 03 00	ldy #$0003	                LDY #3
.3a73d9	a2 42 02	ldx #$0242	                LDX #CPUPC+2
.3a73dc	20 ac 03	jsr $3a03ac	            JSR PRINTH
.3a73df	c2 20		rep #$20	            REP #$20
.3a73e1	a9 20 00	lda #$0020	                LDA #' '
.3a73e4	20 18 00	jsr $3a0018	            JSR PRINTC
.3a73e7	af 44 02 00	lda $000244	                LDA @lCPUA
.3a73eb	20 39 04	jsr $3a0439	            JSR PRHEXW
.3a73ee	a9 20 00	lda #$0020	                LDA #' '
.3a73f1	20 18 00	jsr $3a0018	            JSR PRINTC
.3a73f4	af 46 02 00	lda $000246	                LDA @lCPUX
.3a73f8	20 39 04	jsr $3a0439	            JSR PRHEXW
.3a73fb	a9 20 00	lda #$0020	                LDA #' '
.3a73fe	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7401	af 48 02 00	lda $000248	                LDA @lCPUY
.3a7405	20 39 04	jsr $3a0439	            JSR PRHEXW
.3a7408	a9 20 00	lda #$0020	                LDA #' '
.3a740b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a740e	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK
.3a7412	20 39 04	jsr $3a0439	            JSR PRHEXW
.3a7415	a9 20 00	lda #$0020	                LDA #' '
.3a7418	20 18 00	jsr $3a0018	            JSR PRINTC
.3a741b	af 4e 02 00	lda $00024e	                LDA @lCPUDBR
.3a741f	20 53 04	jsr $3a0453	            JSR PRHEXB
.3a7422	a9 20 00	lda #$0020	                LDA #' '
.3a7425	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7428	a9 20 00	lda #$0020	                LDA #' '
.3a742b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a742e	af 4c 02 00	lda $00024c	                LDA @lCPUDP
.3a7432	20 39 04	jsr $3a0439	            JSR PRHEXW
.3a7435	a9 20 00	lda #$0020	                LDA #' '
.3a7438	20 18 00	jsr $3a0018	            JSR PRINTC
.3a743b	08		php		                PHP
.3a743c	e2 20		sep #$20	            SEP #$20
.3a743e	ad 4f 02	lda $024f	                LDA CPUFLAGS
.3a7441	22 a9 86 3a	jsl $3a86a9	                JSL MPRINTB
.3a7445	28		plp		                PLP
.3a7446	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a7449	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a744c	6b		rtl		                RTL
.3a744d					IMFILL
.3a744d	08		php		                PHP                 ; Save the caller's context
.3a744e	0b		phd		                PHD
.3a744f	08		php		            PHP
.3a7450	c2 20		rep #$20	            REP #$20
.3a7452	48		pha		            PHA
.3a7453	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7456	5b		tcd		            TCD
.3a7457	68		pla		            PLA
.3a7458	28		plp		            PLP
.3a7459					do_copy
.3a7459	e2 20		sep #$20	            SEP #$20
.3a745b	a5 15		lda $085d	                LDA MARG3
.3a745d	87 0d		sta [$0855]	                STA [MARG1]
.3a745f	e2 20		sep #$20	            SEP #$20
.3a7461	a5 0f		lda $0857	                LDA MARG1+2
.3a7463	c5 13		cmp $085b	                CMP MARG2+2
.3a7465	d0 0e		bne $3a7475	                BNE go_next         ; No: we haven't reached end address yet
.3a7467	c2 20		rep #$20	            REP #$20
.3a7469	a5 0d		lda $0855	                LDA MARG1
.3a746b	c5 11		cmp $0859	                CMP MARG2           ; Are they equal?
.3a746d	d0 06		bne $3a7475	                BNE go_next         ; No: we haven't reached end address yet
.3a746f	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a7472	2b		pld		                PLD                 ; Restore the caller's context
.3a7473	28		plp		                PLP
.3a7474	6b		rtl		                RTL
.3a7475					go_next
.3a7475	c2 20		rep #$20	            REP #$20
.3a7477	18		clc		                CLC
.3a7478	a5 0d		lda $0855	                LDA MARG1
.3a747a	69 01 00	adc #$0001	                ADC #1
.3a747d	85 0d		sta $0855	                STA MARG1
.3a747f	e2 20		sep #$20	            SEP #$20
.3a7481	a5 0e		lda $0856	                LDA MARG1+1
.3a7483	69 00		adc #$00	                ADC #0
.3a7485	85 0e		sta $0856	                STA MARG1+1
.3a7487	80 d0		bra $3a7459	                BRA do_copy
.3a7489					IMTRANSFER
.3a7489	08		php		                PHP
.3a748a	0b		phd		                PHD
.3a748b	08		php		            PHP
.3a748c	c2 20		rep #$20	            REP #$20
.3a748e	48		pha		            PHA
.3a748f	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7492	5b		tcd		            TCD
.3a7493	68		pla		            PLA
.3a7494	28		plp		            PLP
.3a7495	e2 20		sep #$20	            SEP #$20
.3a7497	a5 0f		lda $0857	                LDA MARG1+2
.3a7499	c5 17		cmp $085f	                CMP MARG3+2
.3a749b	90 45		bcc $3a74e2	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.3a749d	c2 20		rep #$20	            REP #$20
.3a749f	a5 0d		lda $0855	                LDA MARG1
.3a74a1	c5 15		cmp $085d	                CMP MARG3
.3a74a3	90 3d		bcc $3a74e2	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.3a74a5					copy_byte_down
.3a74a5	e2 20		sep #$20	            SEP #$20
.3a74a7	a7 0d		lda [$0855]	                LDA [MARG1]         ; Copy the byte
.3a74a9	87 15		sta [$085d]	                STA [MARG3]
.3a74ab	a5 0f		lda $0857	                LDA MARG1+2         ; Are the source's current and end bank bytes equal?
.3a74ad	c5 13		cmp $085b	                CMP MARG2+2
.3a74af	d0 0b		bne $3a74bc	                BNE inc_pointers    ; No: we're not done yet
.3a74b1	c2 20		rep #$20	            REP #$20
.3a74b3	a5 0d		lda $0855	                LDA MARG1           ; Are the rest of the bits equal?
.3a74b5	c5 11		cmp $0859	                CMP MARG2
.3a74b7	d0 03		bne $3a74bc	                BNE inc_pointers    ; No: we're not done yet
.3a74b9	4c 40 75	jmp $3a7540	                JMP done            ; Yes: we've copied the last byte, exit
.3a74bc					inc_pointers
.3a74bc	c2 20		rep #$20	            REP #$20
.3a74be	18		clc		                CLC
.3a74bf	a5 0d		lda $0855	                LDA MARG1
.3a74c1	69 01 00	adc #$0001	                ADC #1
.3a74c4	85 0d		sta $0855	                STA MARG1
.3a74c6	e2 20		sep #$20	            SEP #$20
.3a74c8	a5 0e		lda $0856	                LDA MARG1+1
.3a74ca	69 00		adc #$00	                ADC #0
.3a74cc	85 0e		sta $0856	                STA MARG1+1
.3a74ce	c2 20		rep #$20	            REP #$20
.3a74d0	18		clc		                CLC
.3a74d1	a5 15		lda $085d	                LDA MARG3
.3a74d3	69 01 00	adc #$0001	                ADC #1
.3a74d6	85 15		sta $085d	                STA MARG3
.3a74d8	e2 20		sep #$20	            SEP #$20
.3a74da	a5 16		lda $085e	                LDA MARG3+1
.3a74dc	69 00		adc #$00	                ADC #0
.3a74de	85 16		sta $085e	                STA MARG3+1
.3a74e0	80 c3		bra $3a74a5	                BRA copy_byte_down  ; And copy that next byte over
.3a74e2					copy_up
.3a74e2	c2 20		rep #$20	            REP #$20
.3a74e4	38		sec		                SEC
.3a74e5	a5 11		lda $0859	                LDA MARG2
.3a74e7	e5 0d		sbc $0855	                SBC MARG1
.3a74e9	85 19		sta $0861	                STA MARG4
.3a74eb	e2 20		sep #$20	            SEP #$20
.3a74ed	a5 13		lda $085b	                LDA MARG2+2
.3a74ef	e5 0f		sbc $0857	                SBC MARG1+2
.3a74f1	85 1b		sta $0863	                STA MARG4+2
.3a74f3	c2 20		rep #$20	            REP #$20
.3a74f5	18		clc		                CLC
.3a74f6	a5 19		lda $0861	                LDA MARG4
.3a74f8	65 15		adc $085d	                ADC MARG3
.3a74fa	85 15		sta $085d	                STA MARG3
.3a74fc	e2 20		sep #$20	            SEP #$20
.3a74fe	a5 1b		lda $0863	                LDA MARG4+2
.3a7500	65 17		adc $085f	                ADC MARG3+2
.3a7502	85 17		sta $085f	                STA MARG3+2
.3a7504					copy_byte_up
.3a7504	e2 20		sep #$20	            SEP #$20
.3a7506	a7 11		lda [$0859]	                LDA [MARG2]
.3a7508	87 15		sta [$085d]	                STA [MARG3]
.3a750a	a5 13		lda $085b	                LDA MARG2+2         ; Are the source's current and start bank bytes equal?
.3a750c	c5 0f		cmp $0857	                CMP MARG1+2
.3a750e	d0 0a		bne $3a751a	                BNE dec_pointers    ; No: we're not done yet
.3a7510	c2 20		rep #$20	            REP #$20
.3a7512	a5 11		lda $0859	                LDA MARG2           ; Are the rest of the bits equal?
.3a7514	c5 0d		cmp $0855	                CMP MARG1
.3a7516	d0 02		bne $3a751a	                BNE dec_pointers    ; No: we're not done yet
.3a7518	80 26		bra $3a7540	                BRA done            ; Yes: we've copied the last byte, exit
.3a751a					dec_pointers
.3a751a	c2 20		rep #$20	            REP #$20
.3a751c	38		sec		                SEC
.3a751d	a5 11		lda $0859	                LDA MARG2
.3a751f	e9 01 00	sbc #$0001	                SBC #1
.3a7522	85 11		sta $0859	                STA MARG2
.3a7524	e2 20		sep #$20	            SEP #$20
.3a7526	a5 12		lda $085a	                LDA MARG2+1
.3a7528	e9 00		sbc #$00	                SBC #0
.3a752a	85 12		sta $085a	                STA MARG2+1
.3a752c	c2 20		rep #$20	            REP #$20
.3a752e	38		sec		                SEC                 ; Decrement the current destination pointer (MARG3)
.3a752f	a5 15		lda $085d	                LDA MARG3
.3a7531	e9 01 00	sbc #$0001	                SBC #1
.3a7534	85 15		sta $085d	                STA MARG3
.3a7536	e2 20		sep #$20	            SEP #$20
.3a7538	a5 16		lda $085e	                LDA MARG3+1
.3a753a	e9 00		sbc #$00	                SBC #0
.3a753c	85 16		sta $085e	                STA MARG3+1
.3a753e	80 c4		bra $3a7504	                BRA copy_byte_up    ; And copy that next byte
.3a7540					done
.3a7540	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a7543	2b		pld		                PLD
.3a7544	28		plp		                PLP
.3a7545	6b		rtl		                RTL
.3a7546					IS_PRINTABLE
.3a7546	08		php		                PHP
.3a7547	e2 20		sep #$20	            SEP #$20
.3a7549	c9 21		cmp #$21	                CMP #33
.3a754b	90 0b		bcc $3a7558	                BLT not_printable   ; 0 .. 31 are not printable
.3a754d	c9 7f		cmp #$7f	                CMP #127
.3a754f	90 04		bcc $3a7555	                BLT printable       ; 32 .. 126 are printable
.3a7551	c9 a0		cmp #$a0	                CMP #160
.3a7553	90 03		bcc $3a7558	                BLT not_printable   ; 127 .. 159 are not printable (assuming Latin-1)
.3a7555	28		plp		printable       PLP
.3a7556	38		sec		                SEC
.3a7557	6b		rtl		                RTL
.3a7558	28		plp		not_printable   PLP
.3a7559	18		clc		                CLC
.3a755a	6b		rtl		                RTL
=256					MMEMDUMPSIZE = 256  ; Default number of bytes to dump
=8					MMEMROWSIZE = 8    ; Number of bytes to dump per-row
.3a755b					IMMEMORY
.3a755b	08		php		                PHP
.3a755c	8b		phb		                PHB
.3a755d	0b		phd		                PHD
.3a755e	08		php		            PHP
.3a755f	c2 20		rep #$20	            REP #$20
.3a7561	48		pha		            PHA
.3a7562	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7565	5b		tcd		            TCD
.3a7566	68		pla		            PLA
.3a7567	28		plp		            PLP
.3a7568	e2 20		sep #$20	            SEP #$20
.3a756a	a9 00		lda #$00	                LDA #0              ; Clear the pagination line counter
.3a756c	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT
.3a7570	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.3a7572	c9 02		cmp #$02	                CMP #2
.3a7574	b0 16		bcs $3a758c	                BGE set_cursor      ; 2>= arguments? Use them as-is
.3a7576	c9 01		cmp #$01	                CMP #1
.3a7578	90 20		bcc $3a759a	                BLT no_args         ; No arguments passed? Use defaults
.3a757a	c2 20		rep #$20	            REP #$20
.3a757c	18		clc		                CLC
.3a757d	a5 0d		lda $0855	                LDA MARG1
.3a757f	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.3a7582	85 11		sta $0859	                STA MARG2
.3a7584	e2 20		sep #$20	            SEP #$20
.3a7586	a5 0f		lda $0857	                LDA MARG1+2
.3a7588	69 00		adc #$00	                ADC #0
.3a758a	85 13		sta $085b	                STA MARG2+2
.3a758c					set_cursor
.3a758c	c2 20		rep #$20	            REP #$20
.3a758e	a5 0d		lda $0855	                LDA MARG1
.3a7590	85 32		sta $087a	                STA MCURSOR
.3a7592	e2 20		sep #$20	            SEP #$20
.3a7594	a5 0f		lda $0857	                LDA MARG1+2
.3a7596	85 34		sta $087c	                STA MCURSOR+2
.3a7598	80 12		bra $3a75ac	                BRA dump_line
.3a759a					no_args
.3a759a	c2 20		rep #$20	            REP #$20
.3a759c	18		clc		                CLC
.3a759d	a5 32		lda $087a	                LDA MCURSOR
.3a759f	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.3a75a2	85 11		sta $0859	                STA MARG2
.3a75a4	e2 20		sep #$20	            SEP #$20
.3a75a6	a5 34		lda $087c	                LDA MCURSOR+2
.3a75a8	69 00		adc #$00	                ADC #0
.3a75aa	85 13		sta $085b	                STA MARG2+2
.3a75ac					dump_line
.3a75ac	e2 20		sep #$20	            SEP #$20
.3a75ae	a0 00 00	ldy #$0000	                LDY #0
.3a75b1	c2 20		rep #$20	            REP #$20
.3a75b3	a5 32		lda $087a	                LDA MCURSOR             ; NOTE: the use of MARG4 here is a temporary
.3a75b5	85 19		sta $0861	                STA MARG4               ; hack. the copy_loop instruction does not
.3a75b7	e2 20		sep #$20	            SEP #$20
.3a75b9	a5 34		lda $087c	                LDA MCURSOR+2
.3a75bb	85 1b		sta $0863	                STA MARG4+2
.3a75bd	e2 20		sep #$20	            SEP #$20
.3a75bf	a7 19		lda [$0861]	copy_loop       LDA [MARG4]             ; TODO: Should be LDA [MCURSOR],Y, which doesn't seem to be working
.3a75c1	22 46 75 3a	jsl $3a7546	                JSL IS_PRINTABLE        ; Is it printable?
.3a75c5	b0 02		bcs $3a75c9	                BCS buffer_char         ; Yes: go ahead and add it to the line buffer
.3a75c7	a9 3f		lda #$3f	                LDA #'?'                ; No: replace it with dot
.3a75c9	99 7e 08	sta $087e,y	buffer_char     STA #MLINEBUF,B,Y
.3a75cc	c2 20		rep #$20	            REP #$20
.3a75ce	18		clc		                CLC
.3a75cf	a5 19		lda $0861	                LDA MARG4
.3a75d1	69 01 00	adc #$0001	                ADC #1
.3a75d4	85 19		sta $0861	                STA MARG4
.3a75d6	e2 20		sep #$20	            SEP #$20
.3a75d8	a5 1b		lda $0863	                LDA MARG4+2
.3a75da	69 00		adc #$00	                ADC #0
.3a75dc	85 1b		sta $0863	                STA MARG4+2
.3a75de	c8		iny		                INY
.3a75df	c0 08 00	cpy #$0008	                CPY #MMEMROWSIZE
.3a75e2	90 db		bcc $3a75bf	                BLT copy_loop
.3a75e4	a9 00		lda #$00	                LDA #0
.3a75e6	99 7e 08	sta $087e,y	                STA #MLINEBUF,B,Y
.3a75e9	a9 3e		lda #$3e	                LDA #'>'
.3a75eb	20 18 00	jsr $3a0018	            JSR PRINTC
.3a75ee	a9 20		lda #$20	                LDA #' '
.3a75f0	20 18 00	jsr $3a0018	            JSR PRINTC
.3a75f3	e2 20		sep #$20	            SEP #$20
.3a75f5	a5 34		lda $087c	                LDA MCURSOR+2
.3a75f7	20 53 04	jsr $3a0453	            JSR PRHEXB
.3a75fa	a9 3a		lda #$3a	                LDA #':'                ; then a colon
.3a75fc	20 18 00	jsr $3a0018	            JSR PRINTC
.3a75ff	c2 20		rep #$20	            REP #$20
.3a7601	a5 32		lda $087a	                LDA MCURSOR
.3a7603	20 39 04	jsr $3a0439	            JSR PRHEXW
.3a7606	c2 20		rep #$20	            REP #$20
.3a7608	a9 08 00	lda #$0008	                LDA #MMEMROWSIZE
.3a760b	85 47		sta $088f	                STA MCOUNT
.3a760d					prhex_loop
.3a760d	e2 20		sep #$20	            SEP #$20
.3a760f	a9 20		lda #$20	                LDA #' '
.3a7611	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7614	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a7616	20 53 04	jsr $3a0453	            JSR PRHEXB
.3a7619	22 88 86 3a	jsl $3a8688	                JSL M_INC_CURSOR        ; Point MCURSOR to the next byte
.3a761d					check_line
.3a761d	e2 20		sep #$20	            SEP #$20
.3a761f	c6 47		dec $088f	                DEC MCOUNT              ; Count down the number of bytes on the row
.3a7621	d0 ea		bne $3a760d	                BNE prhex_loop          ; If we're not at zero, keep looping over the bytes
.3a7623	a9 20		lda #$20	                LDA #' '
.3a7625	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7628	a9 20		lda #$20	                LDA #' '
.3a762a	20 18 00	jsr $3a0018	            JSR PRINTC
.3a762d	08		php		            PHP
.3a762e	e2 20		sep #$20	            SEP #$20
.3a7630	48		pha		            PHA
.3a7631	a9 00		lda #$00	            LDA #`MLINEBUF
.3a7633	48		pha		            PHA
.3a7634	ab		plb		            PLB
.3a7635	68		pla		            PLA
.3a7636	28		plp		            PLP
.3a7637	a2 7e 08	ldx #$087e	                LDX #MLINEBUF
.3a763a	20 29 04	jsr $3a0429	            JSR PRINTS
.3a763d	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a7640	20 b3 03	jsr $3a03b3	            JSR PAGINATE
.3a7643	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.3a7645	c5 13		cmp $085b	                CMP MARG2+2
.3a7647	90 0f		bcc $3a7658	                BLT continue            ; No: continue
.3a7649	c2 20		rep #$20	            REP #$20
.3a764b	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.3a764d	c5 11		cmp $0859	                CMP MARG2
.3a764f	90 07		bcc $3a7658	                BLT continue            ; Nope... keep going
.3a7651					done
.3a7651	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a7654	2b		pld		                PLD
.3a7655	ab		plb		                PLB
.3a7656	28		plp		                PLP
.3a7657	6b		rtl		                RTL
.3a7658	4c ac 75	jmp $3a75ac	continue        JMP dump_line
.3a765b					M_COPY_ARGB
.3a765b	08		php		                PHP
.3a765c	8d 92 08	sta $0892	                STA MTEMP
.3a765f	e2 20		sep #$20	            SEP #$20
.3a7661	bd 00 00	lda $0000,x	loop            LDA #0,B,X
.3a7664	99 00 00	sta $0000,y	                STA #0,B,Y      ; Copy the byte
.3a7667	ad 92 08	lda $0892	                LDA MTEMP       ; Check the count of characters remaining
.3a766a	f0 0a		beq $3a7676	                BEQ done        ; If it's 0, we're done
.3a766c	c8		iny		                INY             ; Point to the next destination byte
.3a766d	e8		inx		                INX             ; Point to the next source byte (skip three bytes)
.3a766e	e8		inx		                INX
.3a766f	e8		inx		                INX
.3a7670	e8		inx		                INX
.3a7671	ce 92 08	dec $0892	                DEC MTEMP       ; Count down and see if we're done
.3a7674	80 eb		bra $3a7661	                BRA loop
.3a7676	28		plp		done            PLP
.3a7677	6b		rtl		                RTL
.3a7678					IMMODIFY
.3a7678	08		php		                PHP
.3a7679	0b		phd		                PHD
.3a767a	8b		phb		                PHB
.3a767b	08		php		            PHP
.3a767c	c2 20		rep #$20	            REP #$20
.3a767e	48		pha		            PHA
.3a767f	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7682	5b		tcd		            TCD
.3a7683	68		pla		            PLA
.3a7684	28		plp		            PLP
.3a7685	08		php		            PHP
.3a7686	e2 20		sep #$20	            SEP #$20
.3a7688	48		pha		            PHA
.3a7689	a9 00		lda #$00	            LDA #0
.3a768b	48		pha		            PHA
.3a768c	ab		plb		            PLB
.3a768d	68		pla		            PLA
.3a768e	28		plp		            PLP
.3a768f	c2 30		rep #$30	            REP #$30
.3a7691	a5 0d		lda $0855	                LDA MARG1           ; Set MCURSOR to MARG1
.3a7693	85 32		sta $087a	                STA MCURSOR
.3a7695	a5 0f		lda $0857	                LDA MARG1+2
.3a7697	85 34		sta $087c	                STA MCURSOR+2
.3a7699	e2 20		sep #$20	            SEP #$20
.3a769b	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.3a769d	3a		dec a		                DEC A               ; (MARG_LEN - 1)
.3a769e	85 47		sta $088f	                STA MCOUNT
.3a76a0	a2 59 08	ldx #$0859	                LDX #<>MARG2        ; Copy MCOUNT bytes from MARG2..MARG9
.3a76a3	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF     ; to MLINEBUF
.3a76a6	22 5b 76 3a	jsl $3a765b	                JSL M_COPY_ARGB
.3a76aa	a0 00 00	ldy #$0000	                LDY #0
.3a76ad	b9 7e 08	lda $087e,y	loop            LDA MLINEBUF,Y      ; Copy the byte from the buffer
.3a76b0	87 32		sta [$087a]	                STA [MCURSOR]       ; To the address indicated by MCURSOR
.3a76b2	22 88 86 3a	jsl $3a8688	                JSL M_INC_CURSOR    ; Advance the cursor
.3a76b6	c8		iny		                INY                 ; Go to the next buffered byte
.3a76b7	c4 47		cpy $088f	                CPY MCOUNT          ; Did we just write the last one?
.3a76b9	d0 f2		bne $3a76ad	                BNE loop            ; No: continue writing
.3a76bb	ab		plb		                PLB
.3a76bc	2b		pld		                PLD
.3a76bd	28		plp		                PLP
.3a76be	6b		rtl		                RTL
.3a76bf					IMHUNT
.3a76bf	08		php		                PHP
.3a76c0	0b		phd		                PHD
.3a76c1	8b		phb		                PHB
.3a76c2	08		php		            PHP
.3a76c3	c2 20		rep #$20	            REP #$20
.3a76c5	48		pha		            PHA
.3a76c6	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a76c9	5b		tcd		            TCD
.3a76ca	68		pla		            PLA
.3a76cb	28		plp		            PLP
.3a76cc	08		php		            PHP
.3a76cd	e2 20		sep #$20	            SEP #$20
.3a76cf	48		pha		            PHA
.3a76d0	a9 00		lda #$00	            LDA #0
.3a76d2	48		pha		            PHA
.3a76d3	ab		plb		            PLB
.3a76d4	68		pla		            PLA
.3a76d5	28		plp		            PLP
.3a76d6	e2 20		sep #$20	            SEP #$20
.3a76d8	c2 10		rep #$10	            REP #$10
.3a76da	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.3a76dc	3a		dec a		                DEC A               ; (MARG_LEN - 2)
.3a76dd	3a		dec a		                DEC A
.3a76de	85 47		sta $088f	                STA MCOUNT
.3a76e0	a2 5d 08	ldx #$085d	                LDX #<>MARG3
.3a76e3	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF
.3a76e6	22 5b 76 3a	jsl $3a765b	                JSL M_COPY_ARGB
.3a76ea	c2 20		rep #$20	            REP #$20
.3a76ec	a5 0d		lda $0855	                LDA MARG1           ; Copy starting address to MCURSOR
.3a76ee	85 32		sta $087a	                STA MCURSOR
.3a76f0	a5 0f		lda $0857	                LDA MARG1+2
.3a76f2	85 34		sta $087c	                STA MCURSOR+2
.3a76f4					outer_loop
.3a76f4	c2 20		rep #$20	            REP #$20
.3a76f6	a5 34		lda $087c	                LDA MCURSOR+2      ; If MCURSOR < MARG2, we're not done yet
.3a76f8	c5 13		cmp $085b	                CMP MARG2+2
.3a76fa	d0 06		bne $3a7702	                BNE not_done
.3a76fc	a5 32		lda $087a	                LDA MCURSOR
.3a76fe	c5 11		cmp $0859	                CMP MARG2
.3a7700	f0 2c		beq $3a772e	                BEQ done            ; MCURSOR = MARG2: we're done
.3a7702					not_done
.3a7702	e2 20		sep #$20	            SEP #$20
.3a7704	a0 00 00	ldy #$0000	                LDY #0
.3a7707	b7 32		lda [$087a],y	cmp_loop        LDA [MCURSOR],Y     ; Get the byte from the memory to check
.3a7709	d9 7e 08	cmp $087e,y	                CMP MLINEBUF,Y      ; Compare it against our pattern
.3a770c	d0 1a		bne $3a7728	                BNE advance         ; If not equal, we need to move on
.3a770e	c8		iny		                INY                 ; Otherwise do we have more bytes to check?
.3a770f	c4 47		cpy $088f	                CPY MCOUNT
.3a7711	d0 f4		bne $3a7707	                BNE cmp_loop        ; No: check more
.3a7713	c2 20		rep #$20	            REP #$20
.3a7715	a5 32		lda $087a	                LDA MCURSOR         ; Print the address
.3a7717	85 4a		sta $0892	                STA MTEMP
.3a7719	a5 34		lda $087c	                LDA MCURSOR+2
.3a771b	85 4c		sta $0894	                STA MTEMP+2
.3a771d	22 32 81 3a	jsl $3a8132	                JSL M_PR_ADDR
.3a7721	e2 20		sep #$20	            SEP #$20
.3a7723	a9 20		lda #$20	                LDA #' '
.3a7725	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7728	22 88 86 3a	jsl $3a8688	advance         JSL M_INC_CURSOR    ; Move MCURSOR forward by one
.3a772c	80 c6		bra $3a76f4	                BRA outer_loop      ; And try to compare that to the pattern
.3a772e					done
.3a772e	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a7731	ab		plb		                PLB
.3a7732	2b		pld		                PLD
.3a7733	28		plp		                PLP
.3a7734	6b		rtl		                RTL
.3a7735					IMJUMP
.3a7735	08		php		            PHP
.3a7736	c2 20		rep #$20	            REP #$20
.3a7738	48		pha		            PHA
.3a7739	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a773c	5b		tcd		            TCD
.3a773d	68		pla		            PLA
.3a773e	28		plp		            PLP
.3a773f	e2 20		sep #$20	            SEP #$20
.3a7741	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.3a7743	f0 0e		beq $3a7753	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.3a7745	c2 30		rep #$30	            REP #$30
.3a7747	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.3a7749	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.3a774d	a5 0f		lda $0857	                LDA MARG1+2
.3a774f	8f 42 02 00	sta $000242	                STA @lCPUPBR
.3a7753	af 46 02 00	lda $000246	MJUMPRESTORE    LDA @lCPUX          ; Restore X and Y
.3a7757	aa		tax		                TAX
.3a7758	af 48 02 00	lda $000248	                LDA @lCPUY
.3a775c	a8		tay		                TAY
.3a775d	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.3a7761	1b		tcs		                TCS
.3a7762	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.3a7766	5b		tcd		                TCD
.3a7767	e2 20		sep #$20	            SEP #$20
.3a7769	a9 3a		lda #$3a	                LDA #`MJUMPSTART
.3a776b	48		pha		                PHA
.3a776c	a9 77		lda #$77	                LDA #>MJUMPSTART
.3a776e	48		pha		                PHA
.3a776f	a9 75		lda #$75	                LDA #<MJUMPSTART
.3a7771	48		pha		                PHA
.3a7772	4c ac 77	jmp $3a77ac	                JMP MGOSTACK        ; And push remaining registers and restart execution
.3a7775	ea		nop		MJUMPSTART      NOP                 ; RTL increments PC pulled from stack, NOP leaves space for that
.3a7776	5c 04 00 3a	jmp $3a0004	                JML MONITOR
.3a777a					IMGO
.3a777a	08		php		            PHP
.3a777b	c2 20		rep #$20	            REP #$20
.3a777d	48		pha		            PHA
.3a777e	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a7781	5b		tcd		            TCD
.3a7782	68		pla		            PLA
.3a7783	28		plp		            PLP
.3a7784	e2 20		sep #$20	            SEP #$20
.3a7786	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.3a7788	f0 c9		beq $3a7753	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.3a778a	c2 30		rep #$30	            REP #$30
.3a778c	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.3a778e	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.3a7792	a5 0f		lda $0857	                LDA MARG1+2
.3a7794	8f 42 02 00	sta $000242	                STA @lCPUPBR
.3a7798	af 46 02 00	lda $000246	MGORESTORE      LDA @lCPUX          ; Restore X and Y
.3a779c	aa		tax		                TAX
.3a779d	af 48 02 00	lda $000248	                LDA @lCPUY
.3a77a1	a8		tay		                TAY
.3a77a2	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.3a77a6	1b		tcs		                TCS
.3a77a7	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.3a77ab	5b		tcd		                TCD
.3a77ac					MGOSTACK
.3a77ac	e2 20		sep #$20	            SEP #$20
.3a77ae	af 4e 02 00	lda $00024e	                LDA @lCPUDBR        ; Restore the data bank register
.3a77b2	48		pha		                PHA
.3a77b3	ab		plb		                PLB
.3a77b4	a9 5c		lda #$5c	                LDA #$5C            ; Save the JSL opcode
.3a77b6	8f a2 08 00	sta $0008a2	                STA @lMJUMPINST
.3a77ba	af 42 02 00	lda $000242	                LDA @lCPUPBR        ; Write PBR
.3a77be	8f a5 08 00	sta $0008a5	                STA @lMJUMPADDR+2
.3a77c2	af 41 02 00	lda $000241	                LDA @lCPUPC+1       ; Write PCH
.3a77c6	8f a4 08 00	sta $0008a4	                STA @lMJUMPADDR+1
.3a77ca	af 40 02 00	lda $000240	                LDA @lCPUPC         ; Write PCL
.3a77ce	8f a3 08 00	sta $0008a3	                STA @lMJUMPADDR
.3a77d2	af 4f 02 00	lda $00024f	                LDA @lCPUFLAGS      ; Push processor status
.3a77d6	48		pha		                PHA
.3a77d7	c2 20		rep #$20	            REP #$20
.3a77d9	af 44 02 00	lda $000244	                LDA @lCPUA          ; Restore A
.3a77dd	28		plp		                PLP                 ; And the status register
.3a77de	5c a2 08 00	jmp $0008a2	                JML MJUMPINST       ; And jump to the target address
.3a77e2					IMCOMPARE
.3a77e2	08		php		                PHP
.3a77e3	0b		phd		                PHD
.3a77e4	8b		phb		                PHB
.3a77e5	08		php		            PHP
.3a77e6	e2 20		sep #$20	            SEP #$20
.3a77e8	48		pha		            PHA
.3a77e9	a9 3a		lda #$3a	            LDA #`MERRARGS
.3a77eb	48		pha		            PHA
.3a77ec	ab		plb		            PLB
.3a77ed	68		pla		            PLA
.3a77ee	28		plp		            PLP
.3a77ef	08		php		            PHP
.3a77f0	c2 20		rep #$20	            REP #$20
.3a77f2	48		pha		            PHA
.3a77f3	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a77f6	5b		tcd		            TCD
.3a77f7	68		pla		            PLA
.3a77f8	28		plp		            PLP
.3a77f9	c2 10		rep #$10	            REP #$10
.3a77fb	e2 20		sep #$20	            SEP #$20
.3a77fd	a5 31		lda $0879	                LDA MARG_LEN                ; Check the number of arguments provided
.3a77ff	c9 02		cmp #$02	                CMP #2
.3a7801	f0 0c		beq $3a780f	                BEQ default_len             ; If 2: set MCOUNT to default of 1
.3a7803	c9 03		cmp #$03	                CMP #3
.3a7805	d0 11		bne $3a7818	                BNE bad_arguments           ; Otherwise, if not 3: print an error
.3a7807	c2 20		rep #$20	            REP #$20
.3a7809	a5 15		lda $085d	                LDA MARG3                   ; If 3: set MCOUNT to MARG3
.3a780b	85 47		sta $088f	                STA MCOUNT
.3a780d	80 11		bra $3a7820	                BRA compare
.3a780f					default_len
.3a780f	c2 20		rep #$20	            REP #$20
.3a7811	a9 01 00	lda #$0001	                LDA #1                      ; No length was provided, set MCOUNT to 1
.3a7814	85 47		sta $088f	                STA MCOUNT
.3a7816	80 08		bra $3a7820	                BRA compare
.3a7818	a2 54 89	ldx #$8954	bad_arguments   LDX #<>MERRARGS             ; The wrong number of arguments was provided
.3a781b	20 29 04	jsr $3a0429	            JSR PRINTS
.3a781e	80 35		bra $3a7855	                BRA done
.3a7820	a5 0d		lda $0855	compare         LDA MARG1                   ; Set MTEMP to MARG1
.3a7822	85 4a		sta $0892	                STA MTEMP
.3a7824	a5 0f		lda $0857	                LDA MARG1+2
.3a7826	85 4c		sta $0894	                STA MTEMP+2
.3a7828	a0 00 00	ldy #$0000	                LDY #0
.3a782b					loop
.3a782b	e2 20		sep #$20	            SEP #$20
.3a782d	a7 4a		lda [$0892]	                LDA [MTEMP]                 ; Compare the byte at MTEMP
.3a782f	d7 11		cmp [$0859],y	                CMP [MARG2],Y               ; To the Yth byte from MARG2
.3a7831	f0 09		beq $3a783c	                BEQ continue                ; If they're the same, keep going
.3a7833	22 32 81 3a	jsl $3a8132	mismatch        JSL M_PR_ADDR               ; If they're different, print MTEMP
.3a7837	a9 20		lda #$20	                LDA #' '
.3a7839	20 18 00	jsr $3a0018	            JSR PRINTC
.3a783c					continue
.3a783c	c2 20		rep #$20	            REP #$20
.3a783e	18		clc		                CLC                         ; Either way, increment MTEMP
.3a783f	a5 4a		lda $0892	                LDA MTEMP
.3a7841	69 01 00	adc #$0001	                ADC #1
.3a7844	85 4a		sta $0892	                STA MTEMP
.3a7846	a5 4c		lda $0894	                LDA MTEMP+2
.3a7848	69 00 00	adc #$0000	                ADC #0
.3a784b	85 4c		sta $0894	                STA MTEMP+2
.3a784d	c8		iny		                INY                         ; Increment Y
.3a784e	c4 47		cpy $088f	                CPY MCOUNT                  ; Try again unless we've checked MCOUNT bytes
.3a7850	d0 d9		bne $3a782b	                BNE loop
.3a7852	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a7855					done
.3a7855	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a7858	ab		plb		                PLB
.3a7859	2b		pld		                PLD
.3a785a	28		plp		                PLP
.3a785b	6b		rtl		                RTL
.3a785c					IMRMODIFY
.3a785c	08		php		                PHP
.3a785d	0b		phd		                PHD
.3a785e	8b		phb		                PHB
.3a785f	08		php		            PHP
.3a7860	e2 20		sep #$20	            SEP #$20
.3a7862	48		pha		            PHA
.3a7863	a9 00		lda #$00	            LDA #0
.3a7865	48		pha		            PHA
.3a7866	ab		plb		            PLB
.3a7867	68		pla		            PLA
.3a7868	28		plp		            PLP
.3a7869	08		php		            PHP
.3a786a	c2 20		rep #$20	            REP #$20
.3a786c	48		pha		            PHA
.3a786d	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a7870	5b		tcd		            TCD
.3a7871	68		pla		            PLA
.3a7872	28		plp		            PLP
.3a7873	e2 20		sep #$20	            SEP #$20
.3a7875	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.3a7877	f0 4f		beq $3a78c8	                BEQ done            ; 0? Just quit
.3a7879	a6 0d		ldx $0855	                LDX MARG1           ; Set the PC and PBR
.3a787b	8e 40 02	stx $0240	                STX #CPUPC,B
.3a787e	a6 0f		ldx $0857	                LDX MARG1+2
.3a7880	8e 42 02	stx $0242	                STX #CPUPBR,B
.3a7883	c9 01		cmp #$01	                CMP #1              ; Check the number of arguments
.3a7885	f0 41		beq $3a78c8	                BEQ done            ; 1? Just quit
.3a7887	a6 11		ldx $0859	                LDX MARG2           ; Set A
.3a7889	8e 44 02	stx $0244	                STX #CPUA,B
.3a788c	c9 02		cmp #$02	                CMP #2              ; Check the number of arguments
.3a788e	f0 38		beq $3a78c8	                BEQ done            ; 2? Just quit
.3a7890	a6 15		ldx $085d	                LDX MARG3           ; Set X
.3a7892	8e 46 02	stx $0246	                STX #CPUX,B
.3a7895	c9 03		cmp #$03	                CMP #3              ; Check the number of arguments
.3a7897	f0 2f		beq $3a78c8	                BEQ done            ; 3? Just quit
.3a7899	a6 19		ldx $0861	                LDX MARG4           ; Set Y
.3a789b	8e 48 02	stx $0248	                STX #CPUY,B
.3a789e	c9 04		cmp #$04	                CMP #4              ; Check the number of arguments
.3a78a0	f0 26		beq $3a78c8	                BEQ done            ; 4? Just quit
.3a78a2	a6 1d		ldx $0865	                LDX MARG5           ; Set SP
.3a78a4	8e 4a 02	stx $024a	                STX #CPUSTACK,B
.3a78a7	c9 05		cmp #$05	                CMP #5              ; Check the number of arguments
.3a78a9	f0 1d		beq $3a78c8	                BEQ done            ; 5? Just quit
.3a78ab	e2 10		sep #$10	            SEP #$10
.3a78ad	a6 21		ldx $0869	                LDX MARG6           ; Set DBR
.3a78af	8e 4e 02	stx $024e	                STX #CPUDBR,B
.3a78b2	c9 06		cmp #$06	                CMP #6              ; Check the number of arguments
.3a78b4	f0 12		beq $3a78c8	                BEQ done            ; 6? Just quit
.3a78b6	c2 10		rep #$10	            REP #$10
.3a78b8	a6 25		ldx $086d	                LDX MARG7           ; Set DP
.3a78ba	8e 4c 02	stx $024c	                STX #CPUDP,B
.3a78bd	c9 07		cmp #$07	                CMP #7              ; Check the number of arguments
.3a78bf	f0 07		beq $3a78c8	                BEQ done            ; 7? Just quit
.3a78c1	e2 10		sep #$10	            SEP #$10
.3a78c3	a6 29		ldx $0871	                LDX MARG8           ; Set flags
.3a78c5	8e 4f 02	stx $024f	                STX #CPUFLAGS,B
.3a78c8	ab		plb		done            PLB
.3a78c9	2b		pld		                PLD
.3a78ca	28		plp		                PLP
.3a78cb	6b		rtl		                RTL
.3a78cc					IMEXECUTE
.3a78cc	08		php		                PHP
.3a78cd	0b		phd		                PHD
.3a78ce	8b		phb		                PHB
.3a78cf	08		php		            PHP
.3a78d0	c2 20		rep #$20	            REP #$20
.3a78d2	48		pha		            PHA
.3a78d3	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a78d6	5b		tcd		            TCD
.3a78d7	68		pla		            PLA
.3a78d8	28		plp		            PLP
.3a78d9	e2 20		sep #$20	            SEP #$20
.3a78db	c2 10		rep #$10	            REP #$10
.3a78dd	a2 00 00	ldx #$0000	                LDX #0
.3a78e0	bf c1 89 3a	lda $3a89c1,x	loop            LDA @lMCOMMANDS,X
.3a78e4	f0 18		beq $3a78fe	                BEQ done
.3a78e6	c7 08		cmp [$0850]	                CMP [MCMD]
.3a78e8	f0 03		beq $3a78ed	                BEQ found
.3a78ea	e8		inx		                INX
.3a78eb	80 f3		bra $3a78e0	                BRA loop
.3a78ed					found
.3a78ed	c2 20		rep #$20	            REP #$20
.3a78ef	8a		txa		                TXA
.3a78f0	0a		asl a		                ASL A
.3a78f1	aa		tax		                TAX
.3a78f2	bf 02 79 3a	lda $3a7902,x	                LDA dispatch,X
.3a78f6	8f 2f 08 00	sta $00082f	                STA @lJMP16PTR
.3a78fa	22 26 79 3a	jsl $3a7926	                JSL MDOCMD
.3a78fe	ab		plb		done            PLB
.3a78ff	2b		pld		                PLD
.3a7900	28		plp		                PLP
.3a7901	6b		rtl		                RTL
>3a7902	a2 6f				dispatch        .word <>MASSEMBLE
>3a7904	aa 6f				                .word <>MCOMPARE
>3a7906	ae 6f				                .word <>MDISASSEMBLE
>3a7908	b2 6f				                .word <>MFILL
>3a790a	b6 6f				                .word <>MGO
>3a790c	ba 6f				                .word <>MJUMP
>3a790e	be 6f				                .word <>MHUNT
>3a7910	c2 6f				                .word <>MLOAD
>3a7912	c6 6f				                .word <>MMEMORY
>3a7914	ca 6f				                .word <>MREGISTERS
>3a7916	a6 6f				                .word <>MRMODIFY
>3a7918	ce 6f				                .word <>MSAVE
>3a791a	d2 6f				                .word <>MTRANSFER
>3a791c	d6 6f				                .word <>MVERIFY
>3a791e	98 73				                .word <>IMWIDTH
>3a7920	da 6f				                .word <>MEXIT
>3a7922	de 6f				                .word <>MMODIFY
>3a7924	11 70				                .word <>IMHELP
.3a7926					MDOCMD
.3a7926	6c 2f 08	jmp ($082f)	                JMP (JMP16PTR)

;******  Processing file: src\assembler.s

=0					ADDR_DP_IND_X = 0       ; (dd,X)
=1					ADDR_DP = 1             ; dd
=2					ADDR_IMM = 2            ; #dd
=3					ADDR_ABS = 3            ; dddd
=4					ADDR_DP_IND_Y = 4       ; (dd),Y
=5					ADDR_DP_X = 5           ; dd,X
=6					ADDR_ABS_Y = 6          ; dddd,Y
=7					ADDR_ABS_X = 7          ; dddd,X
=8					ADDR_ACC = 8            ; A
=9					ADDR_SP_R = 9           ; #d,S
=10					ADDR_DP_LONG = 10       ; [dd]
=11					ADDR_ABS_LONG = 11      ; dddddd
=12					ADDR_SP_R_Y = 12        ; #dd,S,Y
=13					ADDR_DP_Y_LONG = 13     ; [dd],Y
=14					ADDR_ABS_X_LONG = 14    ; dddddd,X
=15					ADDR_DP_IND = 15        ; (dd)
=16					ADDR_ABS_X_ID = 16      ; (dddd,X)
=17					ADDR_DP_Y = 17          ; dd,Y
=18					ADDR_PC_REL = 18        ; PC relative
=19					ADDR_IMPLIED = 19       ; Implied (no operand)
=20					ADDR_XYC = 20           ; #dd, #dd
=21					ADDR_ABS_IND = 21       ; (dddd)
=22					ADDR_PC_REL_LONG = 22   ; PC relative ()
=23					ADDR_ABS_IND_LONG = 23  ; [dddd]
=$80					OP_M_EFFECT = $80       ; Flag to indicate instruction is modified by M
=$40					OP_X_EFFECT = $40       ; Flag to indicate instruction is modified by X
.3a7929					IMASSEMBLE
.3a7929	08		php		                PHP
.3a792a	8b		phb		                PHB
.3a792b	0b		phd		                PHD
.3a792c	08		php		            PHP
.3a792d	c2 20		rep #$20	            REP #$20
.3a792f	48		pha		            PHA
.3a7930	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7933	5b		tcd		            TCD
.3a7934	68		pla		            PLA
.3a7935	28		plp		            PLP
.3a7936	e2 20		sep #$20	            SEP #$20
.3a7938	a5 31		lda $0879	                LDA MARG_LEN            ; Do we have at least 2 arguments?
.3a793a	c9 02		cmp #$02	                CMP #2
.3a793c	b0 03		bcs $3a7941	                BGE has_args            ; Yes: try to assemble the line
.3a793e	4c cf 7a	jmp $3a7acf	                JMP done                ; No: just return
.3a7941					has_args
.3a7941	c2 20		rep #$20	            REP #$20
.3a7943	a5 0d		lda $0855	                LDA MARG1               ; Set the monitor cursor to the address
.3a7945	85 32		sta $087a	                STA MCURSOR
.3a7947	a5 0f		lda $0857	                LDA MARG1+2
.3a7949	85 34		sta $087c	                STA MCURSOR+2
.3a794b	c2 20		rep #$20	            REP #$20
.3a794d	22 d1 7c 3a	jsl $3a7cd1	                JSL AS_FIND_MNEMO       ; Find the address of the mnemonic
.3a7951	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.3a7954	f0 10		beq $3a7966	                BEQ bad_mnemonic        ; If not found, print bad mnemonic error message
.3a7956	85 54		sta $089c	                STA MMNEMONIC
.3a7958	e2 20		sep #$20	            SEP #$20
.3a795a	a5 31		lda $0879	                LDA MARG_LEN            ; Check the number of arguments passed
.3a795c	c9 03		cmp #$03	                CMP #3                  ; Were all three arguments provided?
.3a795e	f0 36		beq $3a7996	                BEQ get_operand         ; Yes: parse the operand
.3a7960	a9 13		lda #$13	                LDA #ADDR_IMPLIED       ; No: assume address mode is implied
.3a7962	85 4f		sta $0897	                STA MADDR_MODE
.3a7964	80 4c		bra $3a79b2	                BRA get_opcode
.3a7966					bad_mnemonic
.3a7966	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a7969	08		php		            PHP
.3a796a	e2 20		sep #$20	            SEP #$20
.3a796c	48		pha		            PHA
.3a796d	a9 3a		lda #$3a	            LDA #`MERRBADMNEMO
.3a796f	48		pha		            PHA
.3a7970	ab		plb		            PLB
.3a7971	68		pla		            PLA
.3a7972	28		plp		            PLP
.3a7973	c2 10		rep #$10	            REP #$10
.3a7975	a2 06 7b	ldx #$7b06	                LDX #<>MERRBADMNEMO
.3a7978	20 29 04	jsr $3a0429	            JSR PRINTS
.3a797b	4c cf 7a	jmp $3a7acf	                JMP done
.3a797e					bad_operand
.3a797e	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a7981	08		php		            PHP
.3a7982	e2 20		sep #$20	            SEP #$20
.3a7984	48		pha		            PHA
.3a7985	a9 3a		lda #$3a	            LDA #`MERRBADOPER
.3a7987	48		pha		            PHA
.3a7988	ab		plb		            PLB
.3a7989	68		pla		            PLA
.3a798a	28		plp		            PLP
.3a798b	c2 10		rep #$10	            REP #$10
.3a798d	a2 15 7b	ldx #$7b15	                LDX #<>MERRBADOPER
.3a7990	20 29 04	jsr $3a0429	            JSR PRINTS
.3a7993	4c cf 7a	jmp $3a7acf	                JMP done
.3a7996					get_operand
.3a7996	e2 20		sep #$20	            SEP #$20
.3a7998	22 07 7d 3a	jsl $3a7d07	                JSL AS_FIND_MODE        ; Find the addressing mode of the operand
.3a799c	c9 ff		cmp #$ff	compare         CMP #$FF
.3a799e	f0 de		beq $3a797e	                BEQ bad_operand         ; If not found, print bad operand error message
.3a79a0	85 4f		sta $0897	                STA MADDR_MODE
.3a79a2	c9 03		cmp #$03	                CMP #ADDR_ABS           ; If mode is absolute or absolute long...
.3a79a4	f0 62		beq $3a7a08	                BEQ check_for_pcrel     ; Check to see if the mnemonic is one of the branches
.3a79a6	c9 0b		cmp #$0b	                CMP #ADDR_ABS_LONG
.3a79a8	f0 5e		beq $3a7a08	                BEQ check_for_pcrel
.3a79aa	c9 13		cmp #$13	                CMP #ADDR_IMPLIED       ; If mode is implied or accumulator, get the opcode
.3a79ac	f0 04		beq $3a79b2	                BEQ get_opcode
.3a79ae	c9 08		cmp #$08	                CMP #ADDR_ACC
.3a79b0	f0 00		beq $3a79b2	                BEQ get_opcode
.3a79b2	22 ff 7b 3a	jsl $3a7bff	get_opcode      JSL AS_FIND_OPCODE      ; Find the opcode matching the two
.3a79b6	b0 03		bcs $3a79bb	                BCS save_opcode
.3a79b8	4c 98 7a	jmp $3a7a98	                JMP bad_mode            ; If opcode not found, print bad address mode error message
.3a79bb	87 32		sta [$087a]	save_opcode     STA [MCURSOR]           ; Write the opcode to the address
.3a79bd	22 88 86 3a	jsl $3a8688	                JSL M_INC_CURSOR        ; And point to the next byte
.3a79c1	08		php		            PHP
.3a79c2	e2 20		sep #$20	            SEP #$20
.3a79c4	48		pha		            PHA
.3a79c5	a9 00		lda #$00	            LDA #0
.3a79c7	48		pha		            PHA
.3a79c8	ab		plb		            PLB
.3a79c9	68		pla		            PLA
.3a79ca	28		plp		            PLP
.3a79cb	c2 20		rep #$20	            REP #$20
.3a79cd	a5 32		lda $087a	                LDA MCURSOR             ; Make MTEMPPTR a pointer to the machine code we're assembling
.3a79cf	85 56		sta $089e	                STA MTEMPPTR
.3a79d1	a5 34		lda $087c	                LDA MCURSOR+2
.3a79d3	85 58		sta $08a0	                STA MTEMPPTR+2
.3a79d5	e2 20		sep #$20	            SEP #$20
.3a79d7	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check the address mode again
.3a79d9	c9 12		cmp #$12	                CMP #ADDR_PC_REL        ; If it's PC relative
.3a79db	f0 6c		beq $3a7a49	                BEQ compute_rel         ; Convert the address to an offset
.3a79dd	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.3a79df	f0 68		beq $3a7a49	                BEQ compute_rel
.3a79e1	c9 14		cmp #$14	                CMP #ADDR_XYC           ; MVP/MVN addressing mode?
.3a79e3	f0 7c		beq $3a7a61	                BEQ emit_2
.3a79e5	29 3f		and #$3f	                AND #%00111111          ; Filter out the mode bits
.3a79e7	c9 02		cmp #$02	                CMP #ADDR_IMM           ; Is it immediate?
.3a79e9	d0 03		bne $3a79ee	                BNE fixed_length        ; Yes: emit it as an immediate (variable length)
.3a79eb	4c c6 7a	jmp $3a7ac6	                JMP emit_imm
.3a79ee					fixed_length
.3a79ee	c2 20		rep #$20	            REP #$20
.3a79f0	29 ff 00	and #$00ff	                AND #$00FF
.3a79f3	aa		tax		                TAX
.3a79f4	e2 20		sep #$20	            SEP #$20
.3a79f6	bf ce 85 3a	lda $3a85ce,x	get_length      LDA ADDR_LENGTH,X       ; Get the number of bytes in the addressing mode
.3a79fa	c9 03		cmp #$03	                CMP #$03
.3a79fc	f0 57		beq $3a7a55	                BEQ emit_3
.3a79fe	c9 02		cmp #$02	                CMP #$02
.3a7a00	f0 5f		beq $3a7a61	                BEQ emit_2
.3a7a02	c9 01		cmp #$01	                CMP #$01
.3a7a04	f0 67		beq $3a7a6d	                BEQ emit_1
.3a7a06	80 71		bra $3a7a79	                BRA next_line
.3a7a08					check_for_pcrel
.3a7a08	c2 20		rep #$20	            REP #$20
.3a7a0a	a5 54		lda $089c	                LDA MMNEMONIC
.3a7a0c	c9 46 82	cmp #$8246	                CMP #<>MN_BRA
.3a7a0f	f0 26		beq $3a7a37	                BEQ is_pcrel
.3a7a11	c9 aa 82	cmp #$82aa	                CMP #<>MN_BRL
.3a7a14	f0 2a		beq $3a7a40	                BEQ is_pcrel_long
.3a7a16	c9 2a 82	cmp #$822a	                CMP #<>MN_BCC
.3a7a19	f0 1c		beq $3a7a37	                BEQ is_pcrel
.3a7a1b	c9 2e 82	cmp #$822e	                CMP #<>MN_BCS
.3a7a1e	f0 17		beq $3a7a37	                BEQ is_pcrel
.3a7a20	c9 36 82	cmp #$8236	                CMP #<>MN_BEQ
.3a7a23	f0 12		beq $3a7a37	                BEQ is_pcrel
.3a7a25	c9 1e 82	cmp #$821e	                CMP #<>MN_BMI
.3a7a28	f0 0d		beq $3a7a37	                BEQ is_pcrel
.3a7a2a	c9 32 82	cmp #$8232	                CMP #<>MN_BNE
.3a7a2d	f0 08		beq $3a7a37	                BEQ is_pcrel
.3a7a2f	c9 1a 82	cmp #$821a	                CMP #<>MN_BPL
.3a7a32	f0 03		beq $3a7a37	                BEQ is_pcrel
.3a7a34	4c b2 79	jmp $3a79b2	                JMP get_opcode
.3a7a37					is_pcrel
.3a7a37	e2 20		sep #$20	            SEP #$20
.3a7a39	a9 12		lda #$12	                LDA #ADDR_PC_REL
.3a7a3b	85 4f		sta $0897	                STA MADDR_MODE
.3a7a3d	4c b2 79	jmp $3a79b2	                JMP get_opcode
.3a7a40					is_pcrel_long
.3a7a40	e2 20		sep #$20	            SEP #$20
.3a7a42	a9 16		lda #$16	                LDA #ADDR_PC_REL_LONG
.3a7a44	85 4f		sta $0897	                STA MADDR_MODE
.3a7a46	4c b2 79	jmp $3a79b2	                JMP get_opcode
.3a7a49	22 42 7b 3a	jsl $3a7b42	compute_rel     JSL AS_PC_OFFSET        ; Try to compute the offset
.3a7a4d	90 60		bcc $3a7aaf	                BCC bad_offset          ; If failed, it's a bad offset operand
.3a7a4f	c9 02		cmp #$02	emit_rel        CMP #$02                ; If the offset is two bytes
.3a7a51	f0 0e		beq $3a7a61	                BEQ emit_2              ; Emit those two bytes
.3a7a53	80 18		bra $3a7a6d	                BRA emit_1              ; Otherwise emit just the one
.3a7a55	a0 02 00	ldy #$0002	emit_3          LDY #2                  ; Write bank byte of operand
.3a7a58	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.3a7a5b	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.3a7a5d	22 88 86 3a	jsl $3a8688	                JSL M_INC_CURSOR
.3a7a61	a0 01 00	ldy #$0001	emit_2          LDY #1                  ; Write high byte of operand
.3a7a64	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.3a7a67	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.3a7a69	22 88 86 3a	jsl $3a8688	                JSL M_INC_CURSOR
.3a7a6d	a0 00 00	ldy #$0000	emit_1          LDY #0                  ; Write low byte of operand
.3a7a70	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.3a7a73	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.3a7a75	22 88 86 3a	jsl $3a8688	                JSL M_INC_CURSOR
.3a7a79					next_line
.3a7a79	e2 20		sep #$20	            SEP #$20
.3a7a7b	a9 41		lda #$41	                LDA #'A'
.3a7a7d	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7a80	a9 20		lda #$20	                LDA #' '
.3a7a82	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7a85	a6 32		ldx $087a	                LDX MCURSOR
.3a7a87	86 4a		stx $0892	                STX MTEMP
.3a7a89	a6 34		ldx $087c	                LDX MCURSOR+2
.3a7a8b	86 4c		stx $0894	                STX MTEMP+2
.3a7a8d	22 32 81 3a	jsl $3a8132	                JSL M_PR_ADDR
.3a7a91	a9 20		lda #$20	                LDA #' '
.3a7a93	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7a96	80 37		bra $3a7acf	                BRA done
.3a7a98					bad_mode
.3a7a98	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a7a9b	08		php		            PHP
.3a7a9c	e2 20		sep #$20	            SEP #$20
.3a7a9e	48		pha		            PHA
.3a7a9f	a9 3a		lda #$3a	            LDA #`MERRBADMODE
.3a7aa1	48		pha		            PHA
.3a7aa2	ab		plb		            PLB
.3a7aa3	68		pla		            PLA
.3a7aa4	28		plp		            PLP
.3a7aa5	c2 10		rep #$10	            REP #$10
.3a7aa7	a2 d3 7a	ldx #$7ad3	                LDX #<>MERRBADMODE
.3a7aaa	20 29 04	jsr $3a0429	            JSR PRINTS
.3a7aad	80 20		bra $3a7acf	                BRA done
.3a7aaf					bad_offset
.3a7aaf	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a7ab2	08		php		            PHP
.3a7ab3	e2 20		sep #$20	            SEP #$20
.3a7ab5	48		pha		            PHA
.3a7ab6	a9 3a		lda #$3a	            LDA #`MERRBADOFFSET
.3a7ab8	48		pha		            PHA
.3a7ab9	ab		plb		            PLB
.3a7aba	68		pla		            PLA
.3a7abb	28		plp		            PLP
.3a7abc	c2 10		rep #$10	            REP #$10
.3a7abe	a2 23 7b	ldx #$7b23	                LDX #<>MERRBADOFFSET
.3a7ac1	20 29 04	jsr $3a0429	            JSR PRINTS
.3a7ac4	80 09		bra $3a7acf	                BRA done
.3a7ac6	a5 4f		lda $0897	emit_imm        LDA MADDR_MODE          ; Check to see if long immediate was used
.3a7ac8	29 c0		and #$c0	                AND #%11000000
.3a7aca	d0 95		bne $3a7a61	                BNE emit_2              ; Yes: emit two bytes
.3a7acc	4c 6d 7a	jmp $3a7a6d	                JMP emit_1              ; No: emit one byte
.3a7acf	2b		pld		done            PLD
.3a7ad0	ab		plb		                PLB
.3a7ad1	28		plp		                PLP
.3a7ad2	6b		rtl		                RTL
>3a7ad3	41 64 64 72 65 73 73 69		MERRBADMODE     .null "Addressing mode not defined for that instruction.",CHAR_CR
>3a7adb	6e 67 20 6d 6f 64 65 20 6e 6f 74 20 64 65 66 69
>3a7aeb	6e 65 64 20 66 6f 72 20 74 68 61 74 20 69 6e 73
>3a7afb	74 72 75 63 74 69 6f 6e 2e 0d 00
>3a7b06	42 61 64 20 6d 6e 65 6d		MERRBADMNEMO    .null "Bad mnemonic.",CHAR_CR
>3a7b0e	6f 6e 69 63 2e 0d 00
>3a7b15	42 61 64 20 6f 70 65 72		MERRBADOPER     .null "Bad operand.",CHAR_CR
>3a7b1d	61 6e 64 2e 0d 00
>3a7b23	52 65 6c 61 74 69 76 65		MERRBADOFFSET   .null "Relative offset is too large.",CHAR_CR
>3a7b2b	20 6f 66 66 73 65 74 20 69 73 20 74 6f 6f 20 6c
>3a7b3b	61 72 67 65 2e 0d 00
.3a7b42					AS_PC_OFFSET
.3a7b42	08		php		                PHP
.3a7b43	0b		phd		                PHD
.3a7b44	08		php		            PHP
.3a7b45	c2 20		rep #$20	            REP #$20
.3a7b47	48		pha		            PHA
.3a7b48	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7b4b	5b		tcd		            TCD
.3a7b4c	68		pla		            PLA
.3a7b4d	28		plp		            PLP
.3a7b4e	e2 20		sep #$20	            SEP #$20
.3a7b50	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check to see if it 1 byte or 2 byte relative
.3a7b52	c9 12		cmp #$12	                CMP #ADDR_PC_REL
.3a7b54	f0 0a		beq $3a7b60	                BEQ is_short
.3a7b56	c2 20		rep #$20	            REP #$20
.3a7b58	18		clc		                CLC                     ; Branch is long. Compute where MCURSOR will be
.3a7b59	a5 32		lda $087a	                LDA MCURSOR             ; with two branch offset bytes
.3a7b5b	69 02 00	adc #$0002	                ADC #2
.3a7b5e	80 08		bra $3a7b68	                BRA compute_cursor
.3a7b60					is_short
.3a7b60	c2 20		rep #$20	            REP #$20
.3a7b62	18		clc		                CLC                     ; Branch is short. Computer where MCURSOR will be
.3a7b63	a5 32		lda $087a	                LDA MCURSOR             ; with one branch offset byte
.3a7b65	69 01 00	adc #$0001	                ADC #1
.3a7b68	85 4a		sta $0892	compute_cursor  STA MTEMP
.3a7b6a	a5 34		lda $087c	                LDA MCURSOR+2
.3a7b6c	69 00 00	adc #$0000	                ADC #0
.3a7b6f	85 4c		sta $0894	                STA MTEMP+2
.3a7b71	38		sec		                SEC                     ; MPARSEDNUM = MPARSEDNUM - MTEMP (MCURSOR after the instruction)
.3a7b72	a5 50		lda $0898	                LDA MPARSEDNUM
.3a7b74	e5 4a		sbc $0892	                SBC MTEMP
.3a7b76	85 50		sta $0898	                STA MPARSEDNUM
.3a7b78	a5 52		lda $089a	                LDA MPARSEDNUM+2
.3a7b7a	e5 4c		sbc $0894	                SBC MTEMP+2
.3a7b7c	85 52		sta $089a	                STA MPARSEDNUM+2
.3a7b7e	e2 20		sep #$20	            SEP #$20
.3a7b80	a5 4f		lda $0897	                LDA MADDR_MODE
.3a7b82	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.3a7b84	f0 1e		beq $3a7ba4	                BEQ check_long
.3a7b86	a5 50		lda $0898	                LDA MPARSEDNUM          ; Short offset... check if it's negative
.3a7b88	30 0c		bmi $3a7b96	                BMI check_short_neg
.3a7b8a	a5 51		lda $0899	                LDA MPARSEDNUM+1        ; Positive short offset... upper two bytes
.3a7b8c	d0 2a		bne $3a7bb8	                BNE failure             ; Must be 0 or it's an overflow
.3a7b8e	a5 52		lda $089a	                LDA MPARSEDNUM+2
.3a7b90	d0 26		bne $3a7bb8	                BNE failure
.3a7b92	a9 01		lda #$01	                LDA #1                  ; Short offset is 1 byte
.3a7b94	80 26		bra $3a7bbc	                BRA success
.3a7b96	a5 51		lda $0899	check_short_neg LDA MPARSEDNUM+1        ; Negative short offset... upper two bytes
.3a7b98	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's an  overflow
.3a7b9a	d0 1c		bne $3a7bb8	                BNE failure
.3a7b9c	a5 52		lda $089a	                LDA MPARSEDNUM+2
.3a7b9e	c9 ff		cmp #$ff	                CMP #$FF
.3a7ba0	d0 16		bne $3a7bb8	                BNE failure
.3a7ba2	80 18		bra $3a7bbc	                BRA success
.3a7ba4	a5 51		lda $0899	check_long      LDA MPARSEDNUM+1        ; Long offset... check if it's negative
.3a7ba6	30 06		bmi $3a7bae	                BMI check_long_neg
.3a7ba8	a5 52		lda $089a	                LDA MPARSEDNUM+2        ; Positive long offset... upper byte
.3a7baa	d0 0c		bne $3a7bb8	                BNE failure             ; Must be 0 or it's an overflow
.3a7bac	80 0e		bra $3a7bbc	                BRA success
.3a7bae	a5 52		lda $089a	check_long_neg  LDA MPARSEDNUM+2        ; Negative offset... upper two bytes
.3a7bb0	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's and overflow
.3a7bb2	d0 04		bne $3a7bb8	                BNE failure
.3a7bb4	a9 02		lda #$02	                LDA #2                  ; Long offset is 2 bytes
.3a7bb6	80 04		bra $3a7bbc	                BRA success
.3a7bb8	2b		pld		failure         PLD
.3a7bb9	28		plp		                PLP
.3a7bba	18		clc		                CLC
.3a7bbb	6b		rtl		                RTL
.3a7bbc	2b		pld		success         PLD
.3a7bbd	28		plp		                PLP
.3a7bbe	38		sec		                SEC
.3a7bbf	6b		rtl		                RTL
.3a7bc0					AS_SHIFT_HEX
.3a7bc0	08		php		                PHP
.3a7bc1	0b		phd		                PHD
.3a7bc2	c2 10		rep #$10	            REP #$10
.3a7bc4	da		phx		                PHX
.3a7bc5	08		php		            PHP
.3a7bc6	c2 20		rep #$20	            REP #$20
.3a7bc8	48		pha		            PHA
.3a7bc9	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7bcc	5b		tcd		            TCD
.3a7bcd	68		pla		            PLA
.3a7bce	28		plp		            PLP
.3a7bcf	e2 20		sep #$20	            SEP #$20
.3a7bd1	a2 00 00	ldx #$0000	                LDX #0
.3a7bd4	df 00 d0 3a	cmp $3ad000,x	seek_loop       CMP @lHEXDIGITS,X   ; Check the passed character against the hex digits
.3a7bd8	f0 08		beq $3a7be2	                BEQ found
.3a7bda	e8		inx		                INX                 ; Go to the next hex digit
.3a7bdb	e0 10 00	cpx #$0010	                CPX #$10            ; Are we out of digits?
.3a7bde	f0 1b		beq $3a7bfb	                BEQ done            ; Yes... just return
.3a7be0	80 f2		bra $3a7bd4	                BRA seek_loop
.3a7be2					found
.3a7be2	c2 20		rep #$20	            REP #$20
.3a7be4	06 50		asl $0898	                ASL MPARSEDNUM
.3a7be6	26 52		rol $089a	                ROL MPARSEDNUM+2
.3a7be8	06 50		asl $0898	                ASL MPARSEDNUM
.3a7bea	26 52		rol $089a	                ROL MPARSEDNUM+2
.3a7bec	06 50		asl $0898	                ASL MPARSEDNUM
.3a7bee	26 52		rol $089a	                ROL MPARSEDNUM+2
.3a7bf0	06 50		asl $0898	                ASL MPARSEDNUM
.3a7bf2	26 52		rol $089a	                ROL MPARSEDNUM+2
.3a7bf4	e2 20		sep #$20	            SEP #$20
.3a7bf6	8a		txa		                TXA
.3a7bf7	05 50		ora $0898	                ORA MPARSEDNUM
.3a7bf9	85 50		sta $0898	                STA MPARSEDNUM
.3a7bfb	fa		plx		done            PLX
.3a7bfc	2b		pld		                PLD
.3a7bfd	28		plp		                PLP
.3a7bfe	6b		rtl		                RTL
.3a7bff					AS_FIND_OPCODE
.3a7bff	0b		phd		                PHD
.3a7c00	8b		phb		                PHB
.3a7c01	08		php		            PHP
.3a7c02	c2 20		rep #$20	            REP #$20
.3a7c04	48		pha		            PHA
.3a7c05	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7c08	5b		tcd		            TCD
.3a7c09	68		pla		            PLA
.3a7c0a	28		plp		            PLP
.3a7c0b	08		php		            PHP
.3a7c0c	e2 20		sep #$20	            SEP #$20
.3a7c0e	48		pha		            PHA
.3a7c0f	a9 3a		lda #$3a	            LDA #`MNEMONIC_TAB
.3a7c11	48		pha		            PHA
.3a7c12	ab		plb		            PLB
.3a7c13	68		pla		            PLA
.3a7c14	28		plp		            PLP
.3a7c15	e2 20		sep #$20	            SEP #$20
.3a7c17	a5 4f		lda $0897	                LDA MADDR_MODE
.3a7c19	29 3f		and #$3f	                AND #%00111111
.3a7c1b	85 4a		sta $0892	                STA MTEMP
.3a7c1d	c2 30		rep #$30	            REP #$30
.3a7c1f	a2 00 00	ldx #$0000	                LDX #0
.3a7c22	a0 00 00	ldy #$0000	                LDY #0
.3a7c25	bd cc 82	lda $3a82cc,x	mnemonic_loop   LDA MNEMONIC_TAB,X      ; Get the mnemonic from the opcode table
.3a7c28	f0 1b		beq $3a7c45	                BEQ not_found           ; If it's 0, we did not find the mnemonic
.3a7c2a	c5 54		cmp $089c	                CMP MMNEMONIC           ; Does it match the passed mnemonic?
.3a7c2c	d0 0d		bne $3a7c3b	                BNE next_opcode         ; No: go to the next opcode
.3a7c2e					check_mode
.3a7c2e	e2 20		sep #$20	            SEP #$20
.3a7c30	b9 ce 84	lda $3a84ce,y	                LDA ADDRESS_TAB,Y       ; Get the corresponding address mode
.3a7c33	29 3f		and #$3f	                AND #%00111111          ; Filter out effect bits
.3a7c35	c5 4a		cmp $0892	                CMP MTEMP
.3a7c37	f0 07		beq $3a7c40	                BEQ found               ; Yes: we found the opcode
.3a7c39	c2 20		rep #$20	            REP #$20
.3a7c3b	e8		inx		next_opcode     INX                     ; Point to the next mnemonic in the table
.3a7c3c	e8		inx		                INX
.3a7c3d	c8		iny		                INY
.3a7c3e	80 e5		bra $3a7c25	                BRA mnemonic_loop       ; And check it
.3a7c40	98		tya		found           TYA
.3a7c41	38		sec		                SEC                     ; Set carry to show success
.3a7c42	ab		plb		                PLB
.3a7c43	2b		pld		                PLD
.3a7c44	6b		rtl		                RTL
.3a7c45	18		clc		not_found       CLC                     ; Clear carry to show failure
.3a7c46	ab		plb		                PLB
.3a7c47	2b		pld		                PLD
.3a7c48	6b		rtl		                RTL
.3a7c49					AS_STR_MATCH
.3a7c49	08		php		                PHP
.3a7c4a	0b		phd		                PHD
.3a7c4b	08		php		            PHP
.3a7c4c	c2 20		rep #$20	            REP #$20
.3a7c4e	48		pha		            PHA
.3a7c4f	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7c52	5b		tcd		            TCD
.3a7c53	68		pla		            PLA
.3a7c54	28		plp		            PLP
.3a7c55	e2 20		sep #$20	            SEP #$20
.3a7c57	c2 10		rep #$10	            REP #$10
.3a7c59	a0 00 00	ldy #$0000	                LDY #0
.3a7c5c	64 50		stz $0898	                STZ MPARSEDNUM      ; Set parsed number to 0 in anticipation of
.3a7c5e	64 52		stz $089a	                STZ MPARSEDNUM+2    ; hex digits in the pattern
.3a7c60	b7 03		lda [$084b],y	match_loop      LDA [MCMP_TEXT],Y   ; Get the pattern character
.3a7c62	f0 11		beq $3a7c75	                BEQ nul_check       ; If at end of pattern, check for end of test string
.3a7c64	c9 64		cmp #$64	                CMP #'d'            ; Is it a digit?
.3a7c66	f0 19		beq $3a7c81	                BEQ check_digit     ; Yes: do special check for hex digit
.3a7c68	48		pha		compare         PHA
.3a7c69	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.3a7c6b	85 4a		sta $0892	                STA MTEMP
.3a7c6d	68		pla		                PLA
.3a7c6e	c5 4a		cmp $0892	                CMP MTEMP           ; Does it match the character to test?
.3a7c70	d0 0b		bne $3a7c7d	                BNE return_false    ; No: return fail
.3a7c72	c8		iny		next_char       INY                 ; Yes: test the next character
.3a7c73	80 eb		bra $3a7c60	                BRA match_loop
.3a7c75	b7 36		lda [$087e],y	nul_check       LDA [MLINEBUF],Y    ; Check to see that we're at the end of the test string
.3a7c77	d0 04		bne $3a7c7d	                BNE return_false    ; If not: return false
.3a7c79	2b		pld		return_true     PLD
.3a7c7a	28		plp		                PLP                 ; Return true
.3a7c7b	38		sec		                SEC
.3a7c7c	6b		rtl		                RTL
.3a7c7d	2b		pld		return_false    PLD
.3a7c7e	28		plp		                PLP                 ; Return false
.3a7c7f	18		clc		                CLC
.3a7c80	6b		rtl		                RTL
.3a7c81					check_digit
.3a7c81	e2 20		sep #$20	            SEP #$20
.3a7c83	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.3a7c85	c9 3a		cmp #$3a	                CMP #'9'+1
.3a7c87	b0 04		bcs $3a7c8d	                BCS check_AF
.3a7c89	c9 30		cmp #$30	                CMP #'0'
.3a7c8b	b0 14		bcs $3a7ca1	                BCS shift_digit     ; character is in [0..9]
.3a7c8d	c9 47		cmp #$47	check_AF        CMP #'F'+1
.3a7c8f	b0 04		bcs $3a7c95	                BCS check_lc        ; check lower case
.3a7c91	c9 41		cmp #$41	                CMP #'A'
.3a7c93	b0 0c		bcs $3a7ca1	                BCS shift_digit     ; character is in [A..F]
.3a7c95	c9 67		cmp #$67	check_lc        CMP #'f'+1
.3a7c97	b0 e4		bcs $3a7c7d	                BCS return_false    ; check lower case
.3a7c99	c9 61		cmp #$61	                CMP #'a'
.3a7c9b	b0 02		bcs $3a7c9f	                BCS to_upcase       ; character is in [A..F]
.3a7c9d	80 de		bra $3a7c7d	                BRA return_false    ; No match found... return false
.3a7c9f	29 df		and #$df	to_upcase       AND #%11011111      ; Convert lower case to upper case
.3a7ca1	22 c0 7b 3a	jsl $3a7bc0	shift_digit     JSL AS_SHIFT_HEX    ; Shift the digit into MPARSEDNUM
.3a7ca5	80 cb		bra $3a7c72	                BRA next_char       ; And check the next character
.3a7ca7					AS_MCMP_NEXT
.3a7ca7	0b		phd		                PHD
.3a7ca8	08		php		            PHP
.3a7ca9	c2 20		rep #$20	            REP #$20
.3a7cab	48		pha		            PHA
.3a7cac	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7caf	5b		tcd		            TCD
.3a7cb0	68		pla		            PLA
.3a7cb1	28		plp		            PLP
.3a7cb2	a0 00 00	ldy #$0000	                LDY #0
.3a7cb5	e2 20		sep #$20	            SEP #$20
.3a7cb7	b7 03		lda [$084b],y	loop            LDA [MCMP_TEXT],Y   ; Check to see if we have gotten to the NUL
.3a7cb9	f0 03		beq $3a7cbe	                BEQ found_nul
.3a7cbb	c8		iny		                INY
.3a7cbc	80 f9		bra $3a7cb7	                BRA loop
.3a7cbe					found_nul
.3a7cbe	c2 20		rep #$20	            REP #$20
.3a7cc0	c8		iny		                INY                 ; Got to NUL... point to next byte
.3a7cc1	5a		phy		                PHY
.3a7cc2	68		pla		                PLA                 ; And add that index to MCMP_TEXT pointer
.3a7cc3	18		clc		                CLC
.3a7cc4	65 03		adc $084b	                ADC MCMP_TEXT
.3a7cc6	85 03		sta $084b	                STA MCMP_TEXT
.3a7cc8	a5 05		lda $084d	                LDA MCMP_TEXT+2
.3a7cca	69 00 00	adc #$0000	                ADC #0
.3a7ccd	85 05		sta $084d	                STA MCMP_TEXT+2
.3a7ccf	2b		pld		                PLD
.3a7cd0	6b		rtl		                RTL
.3a7cd1					AS_FIND_MNEMO
.3a7cd1	0b		phd		                PHD
.3a7cd2	08		php		            PHP
.3a7cd3	c2 20		rep #$20	            REP #$20
.3a7cd5	48		pha		            PHA
.3a7cd6	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7cd9	5b		tcd		            TCD
.3a7cda	68		pla		            PLA
.3a7cdb	28		plp		            PLP
.3a7cdc	c2 20		rep #$20	            REP #$20
.3a7cde	a5 11		lda $0859	                LDA MARG2                   ; Point MLINEBUF to the text
.3a7ce0	85 36		sta $087e	                STA MLINEBUF
.3a7ce2	a5 13		lda $085b	                LDA MARG2+2
.3a7ce4	85 38		sta $0880	                STA MLINEBUF+2
.3a7ce6	a9 5a 81	lda #$815a	                LDA #<>MNEMONICS_TAB        ; Point to the first mnemonic
.3a7ce9	85 03		sta $084b	                STA MCMP_TEXT
.3a7ceb	a9 3a 00	lda #$003a	                LDA #`MNEMONICS_TAB
.3a7cee	85 05		sta $084d	                STA MCMP_TEXT+2
.3a7cf0	22 49 7c 3a	jsl $3a7c49	match_loop      JSL AS_STR_MATCH            ; Check to see if the text matches the mnemonic
.3a7cf4	b0 0d		bcs $3a7d03	                BCS found_mnemonic          ; If so: return that we found it
.3a7cf6	22 a7 7c 3a	jsl $3a7ca7	                JSL AS_MCMP_NEXT            ; Point to the next mnemonic
.3a7cfa	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Check to see if it's NUL
.3a7cfc	d0 f2		bne $3a7cf0	                BNE match_loop              ; If not, check this next mnemonic
.3a7cfe	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Otherwise, return -1
.3a7d01	80 02		bra $3a7d05	                BRA done
.3a7d03	a5 03		lda $084b	found_mnemonic  LDA MCMP_TEXT               ; Found it: return the address
.3a7d05	2b		pld		done            PLD
.3a7d06	6b		rtl		                RTL
.3a7d07					AS_FIND_MODE
.3a7d07	08		php		                PHP
.3a7d08	0b		phd		                PHD
.3a7d09	08		php		            PHP
.3a7d0a	c2 20		rep #$20	            REP #$20
.3a7d0c	48		pha		            PHA
.3a7d0d	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7d10	5b		tcd		            TCD
.3a7d11	68		pla		            PLA
.3a7d12	28		plp		            PLP
.3a7d13	c2 30		rep #$30	            REP #$30
.3a7d15	a5 15		lda $085d	                LDA MARG3                   ; Point MLINEBUF to the operand
.3a7d17	85 36		sta $087e	                STA MLINEBUF
.3a7d19	a5 17		lda $085f	                LDA MARG3+2
.3a7d1b	85 38		sta $0880	                STA MLINEBUF+2
.3a7d1d	a9 e6 85	lda #$85e6	                LDA #<>ADDR_PATTERNS        ; Point to the first address mode pattern to check
.3a7d20	85 03		sta $084b	                STA MCMP_TEXT
.3a7d22	a9 3a 00	lda #$003a	                LDA #`ADDR_PATTERNS
.3a7d25	85 05		sta $084d	                STA MCMP_TEXT+2
.3a7d27	22 49 7c 3a	jsl $3a7c49	match_loop      JSL AS_STR_MATCH            ; Check to see if the pattern matches the operand
.3a7d2b	b0 22		bcs $3a7d4f	                BCS is_match                ; Yes: Find address mode code
.3a7d2d	22 a7 7c 3a	jsl $3a7ca7	                JSL AS_MCMP_NEXT            ; Point to the address mode
.3a7d31	c2 20		rep #$20	            REP #$20
.3a7d33	18		clc		                CLC                         ; Point to the first byte of the next pattern
.3a7d34	a5 03		lda $084b	                LDA MCMP_TEXT
.3a7d36	69 01 00	adc #$0001	                ADC #1
.3a7d39	85 03		sta $084b	                STA MCMP_TEXT
.3a7d3b	a5 05		lda $084d	                LDA MCMP_TEXT+2
.3a7d3d	69 00 00	adc #$0000	                ADC #0
.3a7d40	85 05		sta $084d	                STA MCMP_TEXT+2
.3a7d42	e2 20		sep #$20	            SEP #$20
.3a7d44	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Is the first byte 0?
.3a7d46	d0 df		bne $3a7d27	                BNE match_loop              ; No: check this next pattern
.3a7d48	c2 20		rep #$20	            REP #$20
.3a7d4a	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Yes: we didn't find a matching pattern, return -1
.3a7d4d	80 0d		bra $3a7d5c	                BRA done
.3a7d4f	22 a7 7c 3a	jsl $3a7ca7	is_match        JSL AS_MCMP_NEXT            ; Point to the address mode
.3a7d53	e2 20		sep #$20	            SEP #$20
.3a7d55	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Get the corresponding address mode code (a byte)
.3a7d57	c2 20		rep #$20	            REP #$20
.3a7d59	29 ff 00	and #$00ff	                AND #$00FF
.3a7d5c	2b		pld		done            PLD
.3a7d5d	28		plp		                PLP
.3a7d5e	6b		rtl		                RTL
.3a7d5f					IMDISASSEMBLE
.3a7d5f	08		php		                PHP
.3a7d60	8b		phb		                PHB
.3a7d61	0b		phd		                PHD
.3a7d62	08		php		            PHP
.3a7d63	c2 20		rep #$20	            REP #$20
.3a7d65	48		pha		            PHA
.3a7d66	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7d69	5b		tcd		            TCD
.3a7d6a	68		pla		            PLA
.3a7d6b	28		plp		            PLP
.3a7d6c	e2 20		sep #$20	            SEP #$20
.3a7d6e	a9 00		lda #$00	                LDA #0
.3a7d70	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT     ; Clear the pagination line counter
.3a7d74	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.3a7d76	c9 02		cmp #$02	                CMP #2
.3a7d78	b0 16		bcs $3a7d90	                BGE set_cursor      ; 2>= arguments? Use them as-is
.3a7d7a	c9 01		cmp #$01	                CMP #1
.3a7d7c	90 20		bcc $3a7d9e	                BLT no_args         ; No arguments passed? Use defaults
.3a7d7e	c2 20		rep #$20	            REP #$20
.3a7d80	18		clc		                CLC
.3a7d81	a5 0d		lda $0855	                LDA MARG1
.3a7d83	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.3a7d86	85 11		sta $0859	                STA MARG2
.3a7d88	e2 20		sep #$20	            SEP #$20
.3a7d8a	a5 0f		lda $0857	                LDA MARG1+2
.3a7d8c	69 00		adc #$00	                ADC #0
.3a7d8e	85 13		sta $085b	                STA MARG2+2
.3a7d90					set_cursor
.3a7d90	c2 20		rep #$20	            REP #$20
.3a7d92	a5 0d		lda $0855	                LDA MARG1
.3a7d94	85 32		sta $087a	                STA MCURSOR
.3a7d96	e2 20		sep #$20	            SEP #$20
.3a7d98	a5 0f		lda $0857	                LDA MARG1+2
.3a7d9a	85 34		sta $087c	                STA MCURSOR+2
.3a7d9c	80 12		bra $3a7db0	                BRA dasm_loop
.3a7d9e					no_args
.3a7d9e	c2 20		rep #$20	            REP #$20
.3a7da0	18		clc		                CLC
.3a7da1	a5 32		lda $087a	                LDA MCURSOR
.3a7da3	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.3a7da6	85 11		sta $0859	                STA MARG2
.3a7da8	e2 20		sep #$20	            SEP #$20
.3a7daa	a5 34		lda $087c	                LDA MCURSOR+2
.3a7dac	69 00		adc #$00	                ADC #0
.3a7dae	85 13		sta $085b	                STA MARG2+2
.3a7db0	22 cb 7d 3a	jsl $3a7dcb	dasm_loop       JSL DS_PR_LINE
.3a7db4	e2 20		sep #$20	            SEP #$20
.3a7db6	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.3a7db8	c5 13		cmp $085b	                CMP MARG2+2
.3a7dba	90 f4		bcc $3a7db0	                BLT dasm_loop           ; No: continue
.3a7dbc	c2 20		rep #$20	            REP #$20
.3a7dbe	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.3a7dc0	c5 11		cmp $0859	                CMP MARG2
.3a7dc2	90 ec		bcc $3a7db0	                BLT dasm_loop           ; Nope... keep going
.3a7dc4					done
.3a7dc4	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a7dc7	2b		pld		                PLD
.3a7dc8	ab		plb		                PLB
.3a7dc9	28		plp		                PLP
.3a7dca	6b		rtl		                RTL
.3a7dcb					DS_PR_LINE
.3a7dcb	08		php		                PHP
.3a7dcc	0b		phd		                PHD
.3a7dcd	e2 20		sep #$20	            SEP #$20
.3a7dcf	a9 41		lda #$41	                LDA #'A'
.3a7dd1	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7dd4	a9 20		lda #$20	                LDA #' '
.3a7dd6	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7dd9	08		php		            PHP
.3a7dda	c2 20		rep #$20	            REP #$20
.3a7ddc	48		pha		            PHA
.3a7ddd	a9 7a 08	lda #$087a	            LDA #MCURSOR
.3a7de0	5b		tcd		            TCD
.3a7de1	68		pla		            PLA
.3a7de2	28		plp		            PLP
.3a7de3	c2 20		rep #$20	            REP #$20
.3a7de5	a5 00		lda $087a	                LDA MCURSOR
.3a7de7	85 18		sta $0892	                STA MTEMP
.3a7de9	e2 20		sep #$20	            SEP #$20
.3a7deb	a5 02		lda $087c	                LDA MCURSOR+2
.3a7ded	85 1a		sta $0894	                STA MTEMP+2
.3a7def	22 32 81 3a	jsl $3a8132	                JSL M_PR_ADDR
.3a7df3	a9 20		lda #$20	                LDA #' '
.3a7df5	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7df8	c2 20		rep #$20	            REP #$20
.3a7dfa	18		clc		                CLC
.3a7dfb	a5 00		lda $087a	                LDA MCURSOR
.3a7dfd	69 01 00	adc #$0001	                ADC #1
.3a7e00	85 18		sta $0892	                STA MTEMP
.3a7e02	e2 20		sep #$20	            SEP #$20
.3a7e04	a5 02		lda $087c	                LDA MCURSOR+2
.3a7e06	69 00		adc #$00	                ADC #0
.3a7e08	85 1a		sta $0894	                STA MTEMP+2
.3a7e0a	e2 20		sep #$20	            SEP #$20
.3a7e0c	c2 10		rep #$10	            REP #$10
.3a7e0e	a7 00		lda [$087a]	                LDA [MCURSOR]           ; Get the mnemonic
.3a7e10	c9 c2		cmp #$c2	                CMP #$C2                ; Is it REP?
.3a7e12	d0 0b		bne $3a7e1f	                BNE check_sep           ; No: check to see if it is SEP
.3a7e14	48		pha		handle_rep      PHA
.3a7e15	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.3a7e17	49 ff		eor #$ff	                EOR #$FF                ; Invert the bits
.3a7e19	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Mask off the bits in the CPUSTAT
.3a7e1d	80 0b		bra $3a7e2a	                BRA save_stat
.3a7e1f	c9 e2		cmp #$e2	check_sep       CMP #$E2                ; Is it SEP?
.3a7e21	d0 0c		bne $3a7e2f	                BNE get_op_index        ; No: process the instruction regularly
.3a7e23	48		pha		handle_sep      PHA
.3a7e24	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.3a7e26	0f 96 08 00	ora $000896	                ORA @lMCPUSTAT          ; Activate the bits in the CPUSTAT
.3a7e2a	8f 96 08 00	sta $000896	save_stat       STA @lMCPUSTAT          ; And save it back
.3a7e2e	68		pla		                PLA
.3a7e2f					get_op_index
.3a7e2f	c2 20		rep #$20	            REP #$20
.3a7e31	29 ff 00	and #$00ff	                AND #$00FF
.3a7e34	0a		asl a		                ASL A
.3a7e35	aa		tax		                TAX                     ; Get the index into the mnemonic lookup table
.3a7e36	bf cc 82 3a	lda $3a82cc,x	                LDA @lMNEMONIC_TAB,X    ; Get the mnemonic
.3a7e3a	aa		tax		                TAX
.3a7e3b	22 ac 80 3a	jsl $3a80ac	                JSL DS_PR_MNEMONIC      ; And print it
.3a7e3f	e2 20		sep #$20	            SEP #$20
.3a7e41	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a7e43	aa		tax		                TAX
.3a7e44	bf ce 84 3a	lda $3a84ce,x	pr_operand      LDA @lADDRESS_TAB,X     ; Get the addressing mode for the instruction
.3a7e48	22 88 86 3a	jsl $3a8688	                JSL M_INC_CURSOR        ; Advance the cursor to the next byte
.3a7e4c	22 59 7e 3a	jsl $3a7e59	                JSL DS_PR_OPERAND       ; And print the correct operand
.3a7e50	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a7e53	20 b3 03	jsr $3a03b3	            JSR PAGINATE
.3a7e56	2b		pld		                PLD
.3a7e57	28		plp		                PLP
.3a7e58	6b		rtl		                RTL
.3a7e59					DS_PR_OPERAND
.3a7e59	08		php		                PHP
.3a7e5a	e2 20		sep #$20	            SEP #$20
.3a7e5c	48		pha		                PHA             ; Save the address mode so we can get to the M and X flags
.3a7e5d	29 3f		and #$3f	                AND #%00111111  ; Filter out the mode flags
.3a7e5f	0a		asl a		                ASL A           ; Compute the index to the table
.3a7e60	c2 10		rep #$10	            REP #$10
.3a7e62	aa		tax		                TAX
.3a7e63	68		pla		                PLA             ; Restore A
.3a7e64	7c 67 7e	jmp ($3a7e67,x)	                JMP (dispatch,X)
>3a7e67	97 7e				dispatch        .word <>is_dp_ind_x
>3a7e69	b2 7e				                .word <>is_dp
>3a7e6b	b9 7e				                .word <>is_imm
>3a7e6d	de 7e				                .word <>is_abs
>3a7e6f	e5 7e				                .word <>is_dp_ind_y
>3a7e71	00 7f				                .word <>is_dp_x
>3a7e73	22 7f				                .word <>is_abs_y
>3a7e75	33 7f				                .word <>is_abs_x
>3a7e77	70 7f				                .word <>is_accumulator
>3a7e79	78 7f				                .word <>is_stack_r
>3a7e7b	89 7f				                .word <>is_dp_long
>3a7e7d	9a 7f				                .word <>is_abs_long
>3a7e7f	a1 7f				                .word <>is_stack_r_y
>3a7e81	c6 7f				                .word <>is_dp_y_long
>3a7e83	f3 7f				                .word <>is_abs_x_long
>3a7e85	5f 7f				                .word <>is_dp_ind
>3a7e87	44 7f				                .word <>is_abs_x_id
>3a7e89	11 7f				                .word <>is_dp_y
>3a7e8b	e6 7f				                .word <>is_pc_rel
>3a7e8d	f0 7f				                .word <>is_implied
>3a7e8f	04 80				                .word <>is_xyc
>3a7e91	33 80				                .word <>is_abs_ind
>3a7e93	e1 7f				                .word <>is_pc_rel_long
>3a7e95	44 80				                .word <>is_abs_ind_long
.3a7e97	a9 28		lda #$28	is_dp_ind_x     LDA #'('                ; Print (dd,X)
.3a7e99	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e9c	22 5b 80 3a	jsl $3a805b	                JSL DS_PR_OPERAND1      ; Print dd
.3a7ea0	a9 2c		lda #$2c	                LDA #','
.3a7ea2	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7ea5	a9 58		lda #$58	                LDA #'X'
.3a7ea7	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7eaa	a9 29		lda #$29	                LDA #')'
.3a7eac	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7eaf	4c 55 80	jmp $3a8055	                JMP done_1
.3a7eb2	22 5b 80 3a	jsl $3a805b	is_dp           JSL DS_PR_OPERAND1      ; Print dd
.3a7eb6	4c 55 80	jmp $3a8055	                JMP done_1
.3a7eb9					is_imm
.3a7eb9	e2 20		sep #$20	            SEP #$20
.3a7ebb	48		pha		                PHA
.3a7ebc	a9 23		lda #$23	                LDA #'#'
.3a7ebe	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7ec1	68		pla		                PLA
.3a7ec2	29 c0		and #$c0	                AND #%11000000          ; Filter so we just look at the mode bits
.3a7ec4	c9 00		cmp #$00	                CMP #$00                ; Are any set to check?
.3a7ec6	f0 0f		beq $3a7ed7	                BEQ is_imm_short        ; No: treat it as a short always
.3a7ec8	4a		lsr a		                LSR A                   ; Move the flag bits right by 2 to match
.3a7ec9	4a		lsr a		                LSR A                   ; the positions of the bits in the CPU status register
.3a7eca	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Otherwise, filter the mode bit we care about
.3a7ece	d0 07		bne $3a7ed7	                BNE is_imm_short        ; If it is set, immediate operation is short
.3a7ed0	22 65 80 3a	jsl $3a8065	                JSL DS_PR_OPERAND2      ; Print dddd
.3a7ed4	4c 55 80	jmp $3a8055	                JMP done_1
.3a7ed7	22 5b 80 3a	jsl $3a805b	is_imm_short    JSL DS_PR_OPERAND1      ; Print dd
.3a7edb	4c 55 80	jmp $3a8055	                JMP done_1
.3a7ede	22 65 80 3a	jsl $3a8065	is_abs          JSL DS_PR_OPERAND2      ; Print dddd
.3a7ee2	4c 55 80	jmp $3a8055	                JMP done_1
.3a7ee5	a9 28		lda #$28	is_dp_ind_y     LDA #'('                ; Print (dd),Y
.3a7ee7	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7eea	22 5b 80 3a	jsl $3a805b	                JSL DS_PR_OPERAND1      ; Print dd
.3a7eee	a9 29		lda #$29	                LDA #')'
.3a7ef0	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7ef3	a9 2c		lda #$2c	                LDA #','
.3a7ef5	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7ef8	a9 59		lda #$59	                LDA #'Y'
.3a7efa	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7efd	4c 55 80	jmp $3a8055	                JMP done_1
.3a7f00	22 5b 80 3a	jsl $3a805b	is_dp_x         JSL DS_PR_OPERAND1      ; Print dd,X
.3a7f04	a9 2c		lda #$2c	                LDA #','
.3a7f06	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f09	a9 58		lda #$58	                LDA #'X'
.3a7f0b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f0e	4c 55 80	jmp $3a8055	                JMP done_1
.3a7f11	22 5b 80 3a	jsl $3a805b	is_dp_y         JSL DS_PR_OPERAND1      ; Print dd,Y
.3a7f15	a9 2c		lda #$2c	                LDA #','
.3a7f17	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f1a	a9 59		lda #$59	                LDA #'Y'
.3a7f1c	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f1f	4c 55 80	jmp $3a8055	                JMP done_1
.3a7f22	22 65 80 3a	jsl $3a8065	is_abs_y        JSL DS_PR_OPERAND2      ; Print dddd,Y
.3a7f26	a9 2c		lda #$2c	                LDA #','
.3a7f28	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f2b	a9 59		lda #$59	                LDA #'Y'
.3a7f2d	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f30	4c 55 80	jmp $3a8055	                JMP done_1
.3a7f33	22 65 80 3a	jsl $3a8065	is_abs_x        JSL DS_PR_OPERAND2      ; Print dddd,X
.3a7f37	a9 2c		lda #$2c	                LDA #','
.3a7f39	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f3c	a9 58		lda #$58	                LDA #'X'
.3a7f3e	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f41	4c 55 80	jmp $3a8055	                JMP done_1
.3a7f44	a9 28		lda #$28	is_abs_x_id     LDA #'('
.3a7f46	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f49	22 65 80 3a	jsl $3a8065	                JSL DS_PR_OPERAND2      ; Print (dddd,X)
.3a7f4d	a9 2c		lda #$2c	                LDA #','
.3a7f4f	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f52	a9 58		lda #$58	                LDA #'X'
.3a7f54	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f57	a9 29		lda #$29	                LDA #')'
.3a7f59	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f5c	4c 55 80	jmp $3a8055	                JMP done_1
.3a7f5f	a9 28		lda #$28	is_dp_ind       LDA #'('
.3a7f61	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f64	22 5b 80 3a	jsl $3a805b	                JSL DS_PR_OPERAND1      ; Print (dd)
.3a7f68	a9 29		lda #$29	                LDA #')'
.3a7f6a	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f6d	4c 55 80	jmp $3a8055	                JMP done_1
.3a7f70	a9 41		lda #$41	is_accumulator  LDA #'A'                ; Print A
.3a7f72	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f75	4c 59 80	jmp $3a8059	                JMP done
.3a7f78	22 5b 80 3a	jsl $3a805b	is_stack_r      JSL DS_PR_OPERAND1      ; Print dd,S
.3a7f7c	a9 2c		lda #$2c	                LDA #','
.3a7f7e	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f81	a9 53		lda #$53	                LDA #'S'
.3a7f83	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f86	4c 55 80	jmp $3a8055	                JMP done_1
.3a7f89	a9 5b		lda #$5b	is_dp_long      LDA #'['                ; [dd]
.3a7f8b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f8e	22 5b 80 3a	jsl $3a805b	                JSL DS_PR_OPERAND1      ; Print dd
.3a7f92	a9 5d		lda #$5d	                LDA #']'
.3a7f94	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f97	4c 55 80	jmp $3a8055	                JMP done_1
.3a7f9a	22 73 80 3a	jsl $3a8073	is_abs_long     JSL DS_PR_OPERAND3      ; Print dddddd
.3a7f9e	4c 59 80	jmp $3a8059	                JMP done
.3a7fa1	a9 28		lda #$28	is_stack_r_y    LDA #'('                ; (dd,S),Y
.3a7fa3	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7fa6	22 5b 80 3a	jsl $3a805b	                JSL DS_PR_OPERAND1      ; Print dd
.3a7faa	a9 2c		lda #$2c	                LDA #','
.3a7fac	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7faf	a9 53		lda #$53	                LDA #'S'
.3a7fb1	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7fb4	a9 29		lda #$29	                LDA #')'
.3a7fb6	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7fb9	a9 2c		lda #$2c	                LDA #','
.3a7fbb	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7fbe	a9 59		lda #$59	                LDA #'Y'
.3a7fc0	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7fc3	4c 55 80	jmp $3a8055	                JMP done_1
.3a7fc6	a9 5b		lda #$5b	is_dp_y_long    LDA #'['                ; [dd],Y
.3a7fc8	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7fcb	22 5b 80 3a	jsl $3a805b	                JSL DS_PR_OPERAND1      ; Print dd
.3a7fcf	a9 5d		lda #$5d	                LDA #']'
.3a7fd1	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7fd4	a9 2c		lda #$2c	                LDA #','
.3a7fd6	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7fd9	a9 59		lda #$59	                LDA #'Y'
.3a7fdb	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7fde	4c 55 80	jmp $3a8055	                JMP done_1
.3a7fe1	a0 02 00	ldy #$0002	is_pc_rel_long  LDY #2
.3a7fe4	80 03		bra $3a7fe9	                BRA do_pcrel
.3a7fe6	a0 01 00	ldy #$0001	is_pc_rel       LDY #1
.3a7fe9	22 d9 80 3a	jsl $3a80d9	do_pcrel        JSL DS_PR_PCREL
.3a7fed	4c 59 80	jmp $3a8059	                JMP done
.3a7ff0	4c 59 80	jmp $3a8059	is_implied      JMP done
.3a7ff3	22 73 80 3a	jsl $3a8073	is_abs_x_long   JSL DS_PR_OPERAND3      ; Print dddddd
.3a7ff7	a9 2c		lda #$2c	                LDA #','
.3a7ff9	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7ffc	a9 58		lda #$58	                LDA #'X'
.3a7ffe	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8001	4c 59 80	jmp $3a8059	                JMP done
.3a8004	a9 23		lda #$23	is_xyc          LDA #'#'
.3a8006	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8009	8b		phb		                PHB                     ; Make sure the databank is pointed to our number
.3a800a	a5 02		lda $087c	                LDA MCURSOR+2
.3a800c	48		pha		                PHA
.3a800d	ab		plb		                PLB
.3a800e	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.3a8010	e8		inx		                INX
.3a8011	a0 01 00	ldy #$0001	                LDY #1
.3a8014	22 ac 03 3a	jsl $3a03ac	                JSL PRINTH
.3a8018	a9 2c		lda #$2c	                LDA #','
.3a801a	20 18 00	jsr $3a0018	            JSR PRINTC
.3a801d	a9 23		lda #$23	                LDA #'#'
.3a801f	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8022	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.3a8024	a0 01 00	ldy #$0001	                LDY #1
.3a8027	22 ac 03 3a	jsl $3a03ac	                JSL PRINTH
.3a802b	ab		plb		                PLB                     ; Get our old data bank back
.3a802c	22 88 86 3a	jsl $3a8688	                JSL M_INC_CURSOR
.3a8030	4c 55 80	jmp $3a8055	                JMP done_1
.3a8033	a9 28		lda #$28	is_abs_ind      LDA #'('
.3a8035	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8038	22 65 80 3a	jsl $3a8065	                JSL DS_PR_OPERAND2      ; Print (dddd)
.3a803c	a9 29		lda #$29	                LDA #')'
.3a803e	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8041	4c 55 80	jmp $3a8055	                JMP done_1
.3a8044	a9 5b		lda #$5b	is_abs_ind_long LDA #'['
.3a8046	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8049	22 65 80 3a	jsl $3a8065	                JSL DS_PR_OPERAND2      ; Print [dddd]
.3a804d	a9 5d		lda #$5d	                LDA #']'
.3a804f	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8052	4c 55 80	jmp $3a8055	                JMP done_1
.3a8055	22 88 86 3a	jsl $3a8688	done_1          JSL M_INC_CURSOR    ; Skip over a single byte operand
.3a8059	28		plp		done            PLP
.3a805a	6b		rtl		                RTL
.3a805b					DS_PR_OPERAND1
.3a805b	08		php		                PHP
.3a805c	e2 20		sep #$20	            SEP #$20
.3a805e	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a8060	20 53 04	jsr $3a0453	            JSR PRHEXB
.3a8063	28		plp		                PLP
.3a8064	6b		rtl		                RTL
.3a8065					DS_PR_OPERAND2
.3a8065	08		php		                PHP
.3a8066	c2 30		rep #$30	            REP #$30
.3a8068	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a806a	20 39 04	jsr $3a0439	            JSR PRHEXW
.3a806d	22 88 86 3a	jsl $3a8688	                JSL M_INC_CURSOR
.3a8071	28		plp		                PLP
.3a8072	6b		rtl		                RTL
.3a8073					DS_PR_OPERAND3
.3a8073	08		php		                PHP
.3a8074	8b		phb		                PHB
.3a8075	0b		phd		                PHD
.3a8076	c2 30		rep #$30	            REP #$30
.3a8078	5a		phy		                PHY
.3a8079	08		php		            PHP
.3a807a	c2 20		rep #$20	            REP #$20
.3a807c	48		pha		            PHA
.3a807d	a9 7a 08	lda #$087a	            LDA #MCURSOR
.3a8080	5b		tcd		            TCD
.3a8081	68		pla		            PLA
.3a8082	28		plp		            PLP
.3a8083	08		php		            PHP
.3a8084	e2 20		sep #$20	            SEP #$20
.3a8086	48		pha		            PHA
.3a8087	a9 00		lda #$00	            LDA #`MTEMP
.3a8089	48		pha		            PHA
.3a808a	ab		plb		            PLB
.3a808b	68		pla		            PLA
.3a808c	28		plp		            PLP
.3a808d	e2 20		sep #$20	            SEP #$20
.3a808f	a0 00 00	ldy #$0000	                LDY #0
.3a8092	a7 00		lda [$087a]	copy_loop       LDA [MCURSOR]       ; Copy the address pointed to by MCURSOR
.3a8094	99 92 08	sta $0892,y	                STA MTEMP,Y         ; to MTEMP
.3a8097	22 88 86 3a	jsl $3a8688	                JSL M_INC_CURSOR
.3a809b	c8		iny		                INY
.3a809c	c0 03 00	cpy #$0003	                CPY #3
.3a809f	d0 f1		bne $3a8092	                BNE copy_loop
.3a80a1	22 32 81 3a	jsl $3a8132	                JSL M_PR_ADDR       ; Print the address
.3a80a5	c2 30		rep #$30	            REP #$30
.3a80a7	7a		ply		                PLY
.3a80a8	2b		pld		                PLD
.3a80a9	ab		plb		                PLB
.3a80aa	28		plp		                PLP
.3a80ab	6b		rtl		                RTL
.3a80ac					DS_PR_MNEMONIC
.3a80ac	08		php		                PHP
.3a80ad	8b		phb		                PHB
.3a80ae	e2 20		sep #$20	            SEP #$20
.3a80b0	c2 10		rep #$10	            REP #$10
.3a80b2	08		php		            PHP
.3a80b3	e2 20		sep #$20	            SEP #$20
.3a80b5	48		pha		            PHA
.3a80b6	a9 3a		lda #$3a	            LDA #`MN_ORA
.3a80b8	48		pha		            PHA
.3a80b9	ab		plb		            PLB
.3a80ba	68		pla		            PLA
.3a80bb	28		plp		            PLP
.3a80bc	bd 00 00	lda $3a0000,x	                LDA #0,B,X
.3a80bf	20 18 00	jsr $3a0018	            JSR PRINTC
.3a80c2	e8		inx		                INX
.3a80c3	bd 00 00	lda $3a0000,x	                LDA #0,B,X
.3a80c6	20 18 00	jsr $3a0018	            JSR PRINTC
.3a80c9	e8		inx		                INX
.3a80ca	bd 00 00	lda $3a0000,x	                LDA #0,B,X
.3a80cd	20 18 00	jsr $3a0018	            JSR PRINTC
.3a80d0	e8		inx		                INX
.3a80d1	a9 20		lda #$20	                LDA #' '            ; Print a space
.3a80d3	20 18 00	jsr $3a0018	            JSR PRINTC
.3a80d6	ab		plb		                PLB
.3a80d7	28		plp		                PLP
.3a80d8	6b		rtl		                RTL
.3a80d9					DS_PR_PCREL
.3a80d9	08		php		                PHP
.3a80da	0b		phd		                PHD
.3a80db	08		php		            PHP
.3a80dc	c2 20		rep #$20	            REP #$20
.3a80de	48		pha		            PHA
.3a80df	a9 7a 08	lda #$087a	            LDA #MCURSOR
.3a80e2	5b		tcd		            TCD
.3a80e3	68		pla		            PLA
.3a80e4	28		plp		            PLP
.3a80e5	e2 20		sep #$20	            SEP #$20
.3a80e7	c0 02 00	cpy #$0002	                CPY #2
.3a80ea	f0 14		beq $3a8100	                BEQ offset_2
.3a80ec	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a80ee	85 18		sta $0892	                STA MTEMP
.3a80f0	30 06		bmi $3a80f8	                BMI is_negative
.3a80f2	64 19		stz $0893	                STZ MTEMP+1
.3a80f4	64 1a		stz $0894	                STZ MTEMP+2
.3a80f6	80 1e		bra $3a8116	                BRA add_offset
.3a80f8	a9 ff		lda #$ff	is_negative     LDA #$FF
.3a80fa	85 19		sta $0893	                STA MTEMP+1
.3a80fc	85 1a		sta $0894	                STA MTEMP+2
.3a80fe	80 16		bra $3a8116	                BRA add_offset
.3a8100	a7 00		lda [$087a]	offset_2        LDA [MCURSOR]
.3a8102	85 18		sta $0892	                STA MTEMP
.3a8104	22 88 86 3a	jsl $3a8688	                JSL M_INC_CURSOR
.3a8108	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a810a	85 19		sta $0893	                STA MTEMP+1
.3a810c	30 04		bmi $3a8112	                BMI is_negative2
.3a810e	64 1a		stz $0894	                STZ MTEMP+2
.3a8110	80 04		bra $3a8116	                BRA add_offset
.3a8112	a9 ff		lda #$ff	is_negative2    LDA #$FF
.3a8114	85 1a		sta $0894	                STA MTEMP+2
.3a8116					add_offset
.3a8116	c2 20		rep #$20	            REP #$20
.3a8118	38		sec		                SEC             ; Add 1 to the offset
.3a8119	a5 00		lda $087a	                LDA MCURSOR
.3a811b	65 18		adc $0892	                ADC MTEMP
.3a811d	85 18		sta $0892	                STA MTEMP
.3a811f	e2 20		sep #$20	            SEP #$20
.3a8121	a5 02		lda $087c	                LDA MCURSOR+2
.3a8123	65 1a		adc $0894	                ADC MTEMP+2
.3a8125	85 1a		sta $0894	                STA MTEMP+2
.3a8127	22 32 81 3a	jsl $3a8132	                JSL M_PR_ADDR
.3a812b	22 88 86 3a	jsl $3a8688	                JSL M_INC_CURSOR
.3a812f	2b		pld		                PLD
.3a8130	28		plp		                PLP
.3a8131	6b		rtl		                RTL
.3a8132					M_PR_ADDR
.3a8132	08		php		                PHP
.3a8133	0b		phd		                PHD
.3a8134	c2 20		rep #$20	            REP #$20
.3a8136	48		pha		                PHA
.3a8137	08		php		            PHP
.3a8138	c2 20		rep #$20	            REP #$20
.3a813a	48		pha		            PHA
.3a813b	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a813e	5b		tcd		            TCD
.3a813f	68		pla		            PLA
.3a8140	28		plp		            PLP
.3a8141	e2 20		sep #$20	            SEP #$20
.3a8143	a5 4c		lda $0894	                LDA MTEMP+2     ; Print the bank byte of the address
.3a8145	20 53 04	jsr $3a0453	            JSR PRHEXB
.3a8148	e2 20		sep #$20	            SEP #$20
.3a814a	a9 3a		lda #$3a	                LDA #':'
.3a814c	20 18 00	jsr $3a0018	            JSR PRINTC
.3a814f	c2 20		rep #$20	            REP #$20
.3a8151	a5 4a		lda $0892	                LDA MTEMP       ; Print the lower 16-bits of the address
.3a8153	20 39 04	jsr $3a0439	            JSR PRHEXW
.3a8156	68		pla		                PLA
.3a8157	2b		pld		                PLD
.3a8158	28		plp		                PLP
.3a8159	6b		rtl		                RTL
.3a815a					MNEMONICS_TAB
.3a815a					MN_ORA
>3a815a	4f 52 41 00			            .null "ORA"
.3a815e					MN_AND
>3a815e	41 4e 44 00			            .null "AND"
.3a8162					MN_EOR
>3a8162	45 4f 52 00			            .null "EOR"
.3a8166					MN_ADC
>3a8166	41 44 43 00			            .null "ADC"
.3a816a					MN_STA
>3a816a	53 54 41 00			            .null "STA"
.3a816e					MN_LDA
>3a816e	4c 44 41 00			            .null "LDA"
.3a8172					MN_CMP
>3a8172	43 4d 50 00			            .null "CMP"
.3a8176					MN_SBC
>3a8176	53 42 43 00			            .null "SBC"
.3a817a					MN_ASL
>3a817a	41 53 4c 00			            .null "ASL"
.3a817e					MN_ROL
>3a817e	52 4f 4c 00			            .null "ROL"
.3a8182					MN_LSR
>3a8182	4c 53 52 00			            .null "LSR"
.3a8186					MN_ROR
>3a8186	52 4f 52 00			            .null "ROR"
.3a818a					MN_STX
>3a818a	53 54 58 00			            .null "STX"
.3a818e					MN_LDX
>3a818e	4c 44 58 00			            .null "LDX"
.3a8192					MN_DEC
>3a8192	44 45 43 00			            .null "DEC"
.3a8196					MN_INC
>3a8196	49 4e 43 00			            .null "INC"
.3a819a					MN_BIT
>3a819a	42 49 54 00			            .null "BIT"
.3a819e					MN_JMP
>3a819e	4a 4d 50 00			            .null "JMP"
.3a81a2					MN_STY
>3a81a2	53 54 59 00			            .null "STY"
.3a81a6					MN_LDY
>3a81a6	4c 44 59 00			            .null "LDY"
.3a81aa					MN_CPY
>3a81aa	43 50 59 00			            .null "CPY"
.3a81ae					MN_CPX
>3a81ae	43 50 58 00			            .null "CPX"
.3a81b2					MN_BRK
>3a81b2	42 52 4b 00			            .null "BRK"
.3a81b6					MN_JSR
>3a81b6	4a 53 52 00			            .null "JSR"
.3a81ba					MN_RTI
>3a81ba	52 54 49 00			            .null "RTI"
.3a81be					MN_RTS
>3a81be	52 54 53 00			            .null "RTS"
.3a81c2					MN_PHP
>3a81c2	50 48 50 00			            .null "PHP"
.3a81c6					MN_PLP
>3a81c6	50 4c 50 00			            .null "PLP"
.3a81ca					MN_PHA
>3a81ca	50 48 41 00			            .null "PHA"
.3a81ce					MN_PLA
>3a81ce	50 4c 41 00			            .null "PLA"
.3a81d2					MN_DEY
>3a81d2	44 45 59 00			            .null "DEY"
.3a81d6					MN_TAY
>3a81d6	54 41 59 00			            .null "TAY"
.3a81da					MN_INY
>3a81da	49 4e 59 00			            .null "INY"
.3a81de					MN_INX
>3a81de	49 4e 58 00			            .null "INX"
.3a81e2					MN_CLC
>3a81e2	43 4c 43 00			            .null "CLC"
.3a81e6					MN_SEC
>3a81e6	53 45 43 00			            .null "SEC"
.3a81ea					MN_CLI
>3a81ea	43 4c 49 00			            .null "CLI"
.3a81ee					MN_SEI
>3a81ee	53 45 49 00			            .null "SEI"
.3a81f2					MN_TYA
>3a81f2	54 59 41 00			            .null "TYA"
.3a81f6					MN_CLV
>3a81f6	43 4c 56 00			            .null "CLV"
.3a81fa					MN_CLD
>3a81fa	43 4c 44 00			            .null "CLD"
.3a81fe					MN_SED
>3a81fe	53 45 44 00			            .null "SED"
.3a8202					MN_TXA
>3a8202	54 58 41 00			            .null "TXA"
.3a8206					MN_TXS
>3a8206	54 58 53 00			            .null "TXS"
.3a820a					MN_TAX
>3a820a	54 41 58 00			            .null "TAX"
.3a820e					MN_TSX
>3a820e	54 53 58 00			            .null "TSX"
.3a8212					MN_DEX
>3a8212	44 45 58 00			            .null "DEX"
.3a8216					MN_NOP
>3a8216	4e 4f 50 00			            .null "NOP"
.3a821a					MN_BPL
>3a821a	42 50 4c 00			            .null "BPL"
.3a821e					MN_BMI
>3a821e	42 4d 49 00			            .null "BMI"
.3a8222					MN_BVC
>3a8222	42 56 43 00			            .null "BVC"
.3a8226					MN_BVS
>3a8226	42 56 53 00			            .null "BVS"
.3a822a					MN_BCC
>3a822a	42 43 43 00			            .null "BCC"
.3a822e					MN_BCS
>3a822e	42 43 53 00			            .null "BCS"
.3a8232					MN_BNE
>3a8232	42 4e 45 00			            .null "BNE"
.3a8236					MN_BEQ
>3a8236	42 45 51 00			            .null "BEQ"
.3a823a					MN_TSB
>3a823a	54 53 42 00			            .null "TSB"
.3a823e					MN_TRB
>3a823e	54 52 42 00			            .null "TRB"
.3a8242					MN_STZ
>3a8242	53 54 5a 00			            .null "STZ"
.3a8246					MN_BRA
>3a8246	42 52 41 00			            .null "BRA"
.3a824a					MN_PHY
>3a824a	50 48 59 00			            .null "PHY"
.3a824e					MN_PLY
>3a824e	50 4c 59 00			            .null "PLY"
.3a8252					MN_PHX
>3a8252	50 48 58 00			            .null "PHX"
.3a8256					MN_PLX
>3a8256	50 4c 58 00			            .null "PLX"
.3a825a					MN_PHD
>3a825a	50 48 44 00			            .null "PHD"
.3a825e					MN_PLD
>3a825e	50 4c 44 00			            .null "PLD"
.3a8262					MN_PHK
>3a8262	50 48 4b 00			            .null "PHK"
.3a8266					MN_RTL
>3a8266	52 54 4c 00			            .null "RTL"
.3a826a					MN_PHB
>3a826a	50 48 42 00			            .null "PHB"
.3a826e					MN_PLB
>3a826e	50 4c 42 00			            .null "PLB"
.3a8272					MN_WAI
>3a8272	57 41 49 00			            .null "WAI"
.3a8276					MN_XBA
>3a8276	58 42 41 00			            .null "XBA"
.3a827a					MN_TCS
>3a827a	54 43 53 00			            .null "TCS"
.3a827e					MN_TSC
>3a827e	54 53 43 00			            .null "TSC"
.3a8282					MN_TCD
>3a8282	54 43 44 00			            .null "TCD"
.3a8286					MN_TDC
>3a8286	54 44 43 00			            .null "TDC"
.3a828a					MN_TXY
>3a828a	54 58 59 00			            .null "TXY"
.3a828e					MN_TYX
>3a828e	54 59 58 00			            .null "TYX"
.3a8292					MN_STP
>3a8292	53 54 50 00			            .null "STP"
.3a8296					MN_XCE
>3a8296	58 43 45 00			            .null "XCE"
.3a829a					MN_COP
>3a829a	43 4f 50 00			            .null "COP"
.3a829e					MN_JSL
>3a829e	4a 53 4c 00			            .null "JSL"
.3a82a2					MN_WDM
>3a82a2	57 44 4d 00			            .null "WDM"
.3a82a6					MN_PER
>3a82a6	50 45 52 00			            .null "PER"
.3a82aa					MN_BRL
>3a82aa	42 52 4c 00			            .null "BRL"
.3a82ae					MN_REP
>3a82ae	52 45 50 00			            .null "REP"
.3a82b2					MN_SEP
>3a82b2	53 45 50 00			            .null "SEP"
.3a82b6					MN_MVP
>3a82b6	4d 56 50 00			            .null "MVP"
.3a82ba					MN_MVN
>3a82ba	4d 56 4e 00			            .null "MVN"
.3a82be					MN_PEI
>3a82be	50 45 49 00			            .null "PEI"
.3a82c2					MN_PEA
>3a82c2	50 45 41 00			            .null "PEA"
.3a82c6					MN_JML
>3a82c6	4a 4d 4c 00			            .null "JML"
>3a82ca	00 00				            .byte 0, 0
>3a82cc	b2 81 5a 81 9a 82 5a 81		MNEMONIC_TAB    .word <>MN_BRK, <>MN_ORA, <>MN_COP, <>MN_ORA, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 0x
>3a82d4	3a 82 5a 81 7a 81 5a 81
>3a82dc	c2 81 5a 81 7a 81 5a 82		                .word <>MN_PHP, <>MN_ORA, <>MN_ASL, <>MN_PHD, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>3a82e4	3a 82 5a 81 7a 81 5a 81
>3a82ec	1a 82 5a 81 5a 81 5a 81		                .word <>MN_BPL, <>MN_ORA, <>MN_ORA, <>MN_ORA, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 1x
>3a82f4	3e 82 5a 81 7a 81 5a 81
>3a82fc	e2 81 5a 81 96 81 7a 82		                .word <>MN_CLC, <>MN_ORA, <>MN_INC, <>MN_TCS, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>3a8304	3e 82 5a 81 7a 81 5a 81
>3a830c	b6 81 5e 81 9e 82 5e 81		                .word <>MN_JSR, <>MN_AND, <>MN_JSL, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 2x
>3a8314	9a 81 5e 81 7e 81 5e 81
>3a831c	c6 81 5e 81 7e 81 5e 82		                .word <>MN_PLP, <>MN_AND, <>MN_ROL, <>MN_PLD, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>3a8324	9a 81 5e 81 7e 81 5e 81
>3a832c	1e 82 5e 81 5e 81 5e 81		                .word <>MN_BMI, <>MN_AND, <>MN_AND, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 3x
>3a8334	9a 81 5e 81 7e 81 5e 81
>3a833c	e6 81 5e 81 92 81 7e 82		                .word <>MN_SEC, <>MN_AND, <>MN_DEC, <>MN_TSC, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>3a8344	9a 81 5e 81 7e 81 5e 81
>3a834c	ba 81 62 81 a2 82 62 81		                .word <>MN_RTI, <>MN_EOR, <>MN_WDM, <>MN_EOR, <>MN_MVP, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 4x
>3a8354	b6 82 62 81 82 81 62 81
>3a835c	ca 81 62 81 82 81 62 82		                .word <>MN_PHA, <>MN_EOR, <>MN_LSR, <>MN_PHK, <>MN_JMP, <>MN_EOR, <>MN_LSR, <>MN_EOR
>3a8364	9e 81 62 81 82 81 62 81
>3a836c	22 82 62 81 62 81 62 81		                .word <>MN_BVC, <>MN_EOR, <>MN_EOR, <>MN_EOR, <>MN_MVN, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 5x
>3a8374	ba 82 62 81 82 81 62 81
>3a837c	ea 81 62 81 4a 82 82 82		                .word <>MN_CLI, <>MN_EOR, <>MN_PHY, <>MN_TCD, <>MN_JML, <>MN_EOR, <>MN_LSR, <>MN_EOR
>3a8384	c6 82 62 81 82 81 62 81
>3a838c	be 81 66 81 a6 82 66 81		                .word <>MN_RTS, <>MN_ADC, <>MN_PER, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 6x
>3a8394	42 82 66 81 86 81 66 81
>3a839c	ce 81 66 81 86 81 66 82		                .word <>MN_PLA, <>MN_ADC, <>MN_ROR, <>MN_RTL, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>3a83a4	9e 81 66 81 86 81 66 81
>3a83ac	26 82 66 81 66 81 66 81		                .word <>MN_BVS, <>MN_ADC, <>MN_ADC, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 7x
>3a83b4	42 82 66 81 86 81 66 81
>3a83bc	ee 81 66 81 4e 82 86 82		                .word <>MN_SEI, <>MN_ADC, <>MN_PLY, <>MN_TDC, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>3a83c4	9e 81 66 81 86 81 66 81
>3a83cc	46 82 6a 81 aa 82 6a 81		                .word <>MN_BRA, <>MN_STA, <>MN_BRL, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 8x
>3a83d4	a2 81 6a 81 8a 81 6a 81
>3a83dc	d2 81 9a 81 02 82 6a 82		                .word <>MN_DEY, <>MN_BIT, <>MN_TXA, <>MN_PHB, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA
>3a83e4	a2 81 6a 81 8a 81 6a 81
>3a83ec	2a 82 6a 81 6a 81 6a 81		                .word <>MN_BCC, <>MN_STA, <>MN_STA, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 9x
>3a83f4	a2 81 6a 81 8a 81 6a 81
>3a83fc	f2 81 6a 81 06 82 8a 82		                .word <>MN_TYA, <>MN_STA, <>MN_TXS, <>MN_TXY, <>MN_STZ, <>MN_STA, <>MN_STZ, <>MN_STA
>3a8404	42 82 6a 81 42 82 6a 81
>3a840c	a6 81 6e 81 8e 81 6e 81		                .word <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Ax
>3a8414	a6 81 6e 81 8e 81 6e 81
>3a841c	d6 81 6e 81 0a 82 6e 82		                .word <>MN_TAY, <>MN_LDA, <>MN_TAX, <>MN_PLB, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>3a8424	a6 81 6e 81 8e 81 6e 81
>3a842c	2e 82 6e 81 6e 81 6e 81		                .word <>MN_BCS, <>MN_LDA, <>MN_LDA, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Bx
>3a8434	a6 81 6e 81 8e 81 6e 81
>3a843c	f6 81 6e 81 0e 82 8e 82		                .word <>MN_CLV, <>MN_LDA, <>MN_TSX, <>MN_TYX, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>3a8444	a6 81 6e 81 8e 81 6e 81
>3a844c	aa 81 72 81 ae 82 72 81		                .word <>MN_CPY, <>MN_CMP, <>MN_REP, <>MN_CMP, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Cx
>3a8454	aa 81 72 81 92 81 72 81
>3a845c	da 81 72 81 12 82 72 82		                .word <>MN_INY, <>MN_CMP, <>MN_DEX, <>MN_WAI, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP
>3a8464	aa 81 72 81 92 81 72 81
>3a846c	32 82 72 81 72 81 72 81		                .word <>MN_BNE, <>MN_CMP, <>MN_CMP, <>MN_CMP, <>MN_PEI, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Dx
>3a8474	be 82 72 81 92 81 72 81
>3a847c	fa 81 72 81 52 82 92 82		                .word <>MN_CLD, <>MN_CMP, <>MN_PHX, <>MN_STP, <>MN_JML, <>MN_CMP, <>MN_DEC, <>MN_CMP
>3a8484	c6 82 72 81 92 81 72 81
>3a848c	ae 81 76 81 b2 82 76 81		                .word <>MN_CPX, <>MN_SBC, <>MN_SEP, <>MN_SBC, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Ex
>3a8494	ae 81 76 81 96 81 76 81
>3a849c	de 81 76 81 16 82 76 82		                .word <>MN_INX, <>MN_SBC, <>MN_NOP, <>MN_XBA, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC
>3a84a4	ae 81 76 81 96 81 76 81
>3a84ac	36 82 76 81 76 81 76 81		                .word <>MN_BEQ, <>MN_SBC, <>MN_SBC, <>MN_SBC, <>MN_PEA, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Fx
>3a84b4	c2 82 76 81 96 81 76 81
>3a84bc	fe 81 76 81 56 82 96 82		                .word <>MN_SED, <>MN_SBC, <>MN_PLX, <>MN_XCE, <>MN_JSR, <>MN_SBC, <>MN_INC, <>MN_SBC
>3a84c4	b6 81 76 81 96 81 76 81
>3a84cc	00 00				                .word 0
>3a84ce	13 00 02 09			ADDRESS_TAB     .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R                  ; 0x
>3a84d2	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a84d6	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>3a84da	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a84de	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 1x
>3a84e2	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a84e6	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>3a84ea	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a84ee	03 00 0b 09			                .byte ADDR_ABS, ADDR_DP_IND_X, ADDR_ABS_LONG, ADDR_SP_R                 ; 2x
>3a84f2	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a84f6	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>3a84fa	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a84fe	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 3x
>3a8502	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a8506	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>3a850a	07 07 07 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a850e	13 00 13 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMPLIED, ADDR_SP_R              ; 4x
>3a8512	14 01 01 0a			                .byte ADDR_XYC, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a8516	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>3a851a	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a851e	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 5x
>3a8522	14 05 05 0d			                .byte ADDR_XYC, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a8526	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a852a	0b 07 07 0b			                .byte ADDR_ABS_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_LONG
>3a852e	13 00 16 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R          ; 6x
>3a8532	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a8536	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>3a853a	15 03 03 0b			                .byte ADDR_ABS_IND, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a853e	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 7x
>3a8542	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a8546	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a854a	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a854e	12 00 16 09			                .byte ADDR_PC_REL, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R           ; 8x
>3a8552	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a8556	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>3a855a	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a855e	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 9x
>3a8562	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>3a8566	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a856a	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a856e	82 00 42 09			                .byte ADDR_IMM | OP_M_EFFECT, ADDR_DP_IND_X, ADDR_IMM | OP_X_EFFECT, ADDR_SP_R  ; Ax
>3a8572	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a8576	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>3a857a	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a857e	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Bx
>3a8582	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>3a8586	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a858a	07 07 06 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_Y, ADDR_ABS_X_LONG
>3a858e	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Cx
>3a8592	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a8596	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>3a859a	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a859e	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Dx
>3a85a2	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a85a6	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a85aa	17 07 07 0e			                .byte ADDR_ABS_IND_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a85ae	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Ex
>3a85b2	01 01 01 0f			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_IND
>3a85b6	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>3a85ba	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a85be	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Fx
>3a85c2	03 05 05 0d			                .byte ADDR_ABS, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a85c6	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a85ca	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a85ce	01 01 01 02 01 01 02 02		ADDR_LENGTH     .byte 1, 1, 1, 2, 1, 1, 2, 2, 0, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 0, 2, 2, 2, 2
>3a85d6	00 01 01 03 01 01 03 01 02 01 01 00 02 02 02 02
.3a85e6					ADDR_PATTERNS
>3a85e6	41 00				            .null "A"
>3a85e8	08				            .byte ADDR_ACC
>3a85e9	64 64 3a 64 64 64 64 2c		            .null "dd:dddd,X"
>3a85f1	58 00
>3a85f3	0e				            .byte ADDR_ABS_X_LONG
>3a85f4	64 64 3a 64 64 64 64 00		            .null "dd:dddd"
>3a85fc	0b				            .byte ADDR_ABS_LONG
>3a85fd	64 64 64 64 2c 58 00		            .null "dddd,X"
>3a8604	07				            .byte ADDR_ABS_X
>3a8605	64 64 64 64 2c 59 00		            .null "dddd,Y"
>3a860c	06				            .byte ADDR_ABS_Y
>3a860d	64 64 64 64 00			            .null "dddd"
>3a8612	03				            .byte ADDR_ABS
>3a8613	64 64 2c 58 00			            .null "dd,X"
>3a8618	05				            .byte ADDR_DP_X
>3a8619	64 64 2c 59 00			            .null "dd,Y"
>3a861e	11				            .byte ADDR_DP_Y
>3a861f	64 64 2c 53 00			            .null "dd,S"
>3a8624	09				            .byte ADDR_SP_R
>3a8625	64 64 00			            .null "dd"
>3a8628	01				            .byte ADDR_DP
>3a8629	23 64 64 64 64 00		            .null "#dddd"
>3a862f	c2				            .byte ADDR_IMM | OP_M_EFFECT | OP_X_EFFECT
>3a8630	23 64 64 2c 23 64 64 00		            .null "#dd,#dd"
>3a8638	14				            .byte ADDR_XYC
>3a8639	23 64 64 00			            .null "#dd"
>3a863d	02				            .byte ADDR_IMM
>3a863e	28 64 64 2c 53 29 2c 59		            .null "(dd,S),Y"
>3a8646	00
>3a8647	0c				            .byte ADDR_SP_R_Y
>3a8648	28 64 64 64 64 2c 58 29		            .null "(dddd,X)"
>3a8650	00
>3a8651	10				            .byte ADDR_ABS_X_ID
>3a8652	28 64 64 64 64 29 00		            .null "(dddd)"
>3a8659	10				            .byte ADDR_ABS_X_ID
>3a865a	28 64 64 2c 58 29 00		            .null "(dd,X)"
>3a8661	00				            .byte ADDR_DP_IND_X
>3a8662	28 64 64 29 2c 59 00		            .null "(dd),Y"
>3a8669	04				            .byte ADDR_DP_IND_Y
>3a866a	28 64 64 29 00			            .null "(dd)"
>3a866f	0f				            .byte ADDR_DP_IND
>3a8670	5b 64 64 64 64 5d 00		            .null "[dddd]"
>3a8677	17				            .byte ADDR_ABS_IND_LONG
>3a8678	5b 64 64 5d 2c 59 00		            .null "[dd],Y"
>3a867f	0d				            .byte ADDR_DP_Y_LONG
>3a8680	5b 64 64 5d 00			            .null "[dd]"
>3a8685	0a				            .byte ADDR_DP_LONG
>3a8686	00 00				                .byte 0, 0

;******  Return to file: src\monitor.s

.3a8688					M_INC_CURSOR
.3a8688	08		php		                PHP
.3a8689	c2 20		rep #$20	            REP #$20
.3a868b	48		pha		                PHA
.3a868c	18		clc		                CLC
.3a868d	af 7a 08 00	lda $00087a	                LDA MCURSOR
.3a8691	69 01 00	adc #$0001	                ADC #1
.3a8694	8f 7a 08 00	sta $00087a	                STA MCURSOR
.3a8698	e2 20		sep #$20	            SEP #$20
.3a869a	af 7c 08 00	lda $00087c	                LDA MCURSOR+2
.3a869e	69 00		adc #$00	                ADC #0
.3a86a0	8f 7c 08 00	sta $00087c	                STA MCURSOR+2
.3a86a4	c2 20		rep #$20	            REP #$20
.3a86a6	68		pla		                PLA
.3a86a7	28		plp		                PLP
.3a86a8	6b		rtl		                RTL
.3a86a9					MPRINTB
.3a86a9	08		php		                PHP
.3a86aa	c2 10		rep #$10	            REP #$10
.3a86ac	e2 20		sep #$20	            SEP #$20
.3a86ae	da		phx		                PHX
.3a86af	a2 08 00	ldx #$0008	                LDX #8          ; Set number of bits to print to 8
.3a86b2	0a		asl a		loop            ASL A           ; Shift MSB to C
.3a86b3	b0 08		bcs $3a86bd	                BCS is_one
.3a86b5	48		pha		                PHA             ; Save value to print
.3a86b6	a9 30		lda #$30	                LDA #'0'        ; Print '0'
.3a86b8	20 18 00	jsr $3a0018	            JSR PRINTC
.3a86bb	80 06		bra $3a86c3	                BRA continue
.3a86bd	48		pha		is_one          PHA             ; Save value to print
.3a86be	a9 31		lda #$31	                LDA #'1'        ; Print '1'
.3a86c0	20 18 00	jsr $3a0018	            JSR PRINTC
.3a86c3	68		pla		continue        PLA
.3a86c4	ca		dex		                DEX             ; Count down the bits to shift
.3a86c5	d0 eb		bne $3a86b2	                BNE loop        ; And try the next one if there is one
.3a86c7	fa		plx		                PLX             ; Otherwise, return
.3a86c8	28		plp		                PLP
.3a86c9	6b		rtl		                RTL
.3a86ca					MSKIPWS
.3a86ca	08		php		            PHP
.3a86cb	c2 20		rep #$20	            REP #$20
.3a86cd	48		pha		            PHA
.3a86ce	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a86d1	5b		tcd		            TCD
.3a86d2	68		pla		            PLA
.3a86d3	28		plp		            PLP
.3a86d4	e2 20		sep #$20	            SEP #$20
.3a86d6	a7 32		lda [$087a]	loop            LDA [MCURSOR]       ; Check the current character
.3a86d8	f0 0a		beq $3a86e4	                BEQ done            ; If NULL, we're done
.3a86da	c9 20		cmp #$20	                CMP #' '            ; Is it a space?
.3a86dc	d0 06		bne $3a86e4	                BNE done            ; No: we're done
.3a86de	22 88 86 3a	jsl $3a8688	                JSL M_INC_CURSOR    ; Yes, try the next one
.3a86e2	80 f2		bra $3a86d6	                BRA loop
.3a86e4	6b		rtl		done            RTL
.3a86e5					MPARSESTR
.3a86e5	08		php		                PHP
.3a86e6	08		php		            PHP
.3a86e7	c2 20		rep #$20	            REP #$20
.3a86e9	48		pha		            PHA
.3a86ea	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a86ed	5b		tcd		            TCD
.3a86ee	68		pla		            PLA
.3a86ef	28		plp		            PLP
.3a86f0	22 88 86 3a	jsl $3a8688	                JSL M_INC_CURSOR                ; Point to the first character of the name
.3a86f4	22 ca 86 3a	jsl $3a86ca	                JSL MSKIPWS                     ; Skip white space
.3a86f8	c2 30		rep #$30	            REP #$30
.3a86fa	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.3a86fc	c2 20		rep #$20	            REP #$20
.3a86fe	29 ff 00	and #$00ff	                AND #$00FF
.3a8701	0a		asl a		                ASL A                           ; multiply it by forfour
.3a8702	0a		asl a		                ASL A
.3a8703	aa		tax		                TAX                             ; ... to get the index to the argument
.3a8704	a5 32		lda $087a	                LDA MCURSOR                     ; Set the argument to the address of the first byte
.3a8706	95 0d		sta $0855,x	                STA MARG1,X
.3a8708	a5 34		lda $087c	                LDA MCURSOR+2
.3a870a	95 0f		sta $0857,x	                STA MARG1+2,X
.3a870c	e2 20		sep #$20	            SEP #$20
.3a870e	a7 32		lda [$087a]	loop            LDA [MCURSOR]                   ; Scan to the closing double quote
.3a8710	f0 14		beq $3a8726	                BEQ done                        ; If NULL... treat it as a closed argument
.3a8712	c9 22		cmp #$22	                CMP #CHAR_DQUOTE
.3a8714	f0 06		beq $3a871c	                BEQ close_string
.3a8716	22 88 86 3a	jsl $3a8688	                JSL M_INC_CURSOR
.3a871a	80 f2		bra $3a870e	                BRA loop
.3a871c	a9 00		lda #$00	close_string    LDA #0                          ; Write a NULL to close the string
.3a871e	87 32		sta [$087a]	                STA [MCURSOR]
.3a8720	22 88 86 3a	jsl $3a8688	                JSL M_INC_CURSOR                ; And point to the next byte
.3a8724	e6 31		inc $0879	                INC MARG_LEN
.3a8726	28		plp		done            PLP
.3a8727	6b		rtl		                RTL
.3a8728					MPARSEARG
.3a8728	08		php		            PHP
.3a8729	c2 20		rep #$20	            REP #$20
.3a872b	48		pha		            PHA
.3a872c	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a872f	5b		tcd		            TCD
.3a8730	68		pla		            PLA
.3a8731	28		plp		            PLP
.3a8732	e2 20		sep #$20	            SEP #$20
.3a8734	64 4a		stz $0892	                STZ MTEMP                       ; Use MTEMP as a flag for having processed digits
.3a8736	c2 20		rep #$20	            REP #$20
.3a8738	64 50		stz $0898	                STZ MPARSEDNUM                  ; Clear the parsed number
.3a873a	64 52		stz $089a	                STZ MPARSEDNUM+2
.3a873c					pa_loop
.3a873c	e2 20		sep #$20	            SEP #$20
.3a873e	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Get the current character
.3a8740	c9 3a		cmp #$3a	                CMP #":"
.3a8742	f0 0d		beq $3a8751	                BEQ pa_next_char                ; Ignore any colons
.3a8744	20 d1 04	jsr $3a04d1	            JSR ISHEX
.3a8747	90 0e		bcc $3a8757	                BCC finished_arg                ; No? We're done with this argument
.3a8749	22 c0 7b 3a	jsl $3a7bc0	                JSL AS_SHIFT_HEX                ; Yes: shift it onto MPARSEDNUM
.3a874d	a9 01		lda #$01	                LDA #1                          ; Flag that we've processed a character
.3a874f	85 4a		sta $0892	                STA MTEMP
.3a8751	22 88 86 3a	jsl $3a8688	pa_next_char    JSL M_INC_CURSOR                ; And try the next character
.3a8755	80 e5		bra $3a873c	                BRA pa_loop
.3a8757	a5 4a		lda $0892	finished_arg    LDA MTEMP                       ; Check to see if we've processed any characters
.3a8759	f0 16		beq $3a8771	                BEQ done                        ; No: we're done
.3a875b	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.3a875d	c2 20		rep #$20	            REP #$20
.3a875f	29 ff 00	and #$00ff	                AND #$00FF
.3a8762	0a		asl a		                ASL A                           ; multiply it by forfour
.3a8763	0a		asl a		                ASL A
.3a8764	aa		tax		                TAX                             ; ... to get the index to the argument
.3a8765	a5 50		lda $0898	                LDA MPARSEDNUM                  ; Copy the value to the argument slot
.3a8767	95 0d		sta $0855,x	                STA MARG1,X
.3a8769	a5 52		lda $089a	                LDA MPARSEDNUM+2
.3a876b	95 0f		sta $0857,x	                STA MARG1+2,X
.3a876d	e2 20		sep #$20	            SEP #$20
.3a876f	e6 31		inc $0879	                INC MARG_LEN                    ; And bump up the argument count
.3a8771	6b		rtl		done            RTL
.3a8772					MPARSEALLARG
.3a8772	e2 20		sep #$20	            SEP #$20
.3a8774	64 31		stz $0879	                STZ MARG_LEN                    ; Set the arg count to 0
.3a8776	22 ca 86 3a	jsl $3a86ca	parse_arg       JSL MSKIPWS                     ; Otherwise, skip white space
.3a877a	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Check the current character
.3a877c	f0 21		beq $3a879f	                BEQ done                        ; If it is NULL, we're done
.3a877e	c9 22		cmp #$22	                CMP #CHAR_DQUOTE                ; Is it a double-quote?
.3a8780	d0 06		bne $3a8788	                BNE regular_arg
.3a8782	22 e5 86 3a	jsl $3a86e5	                JSL MPARSESTR                   ; Yes: parse it as a string argument
.3a8786	80 0a		bra $3a8792	                BRA check_rest
.3a8788	22 28 87 3a	jsl $3a8728	regular_arg     JSL MPARSEARG                   ; Attempt to parse the argument
.3a878c	a5 31		lda $0879	                LDA MARG_LEN                    ; Check how many arguments we've processed
.3a878e	c9 09		cmp #$09	                CMP #9
.3a8790	b0 0d		bcs $3a879f	                BGE done                        ; If >=9, then we're done
.3a8792	a7 32		lda [$087a]	check_rest      LDA [MCURSOR]                   ; Check the current character
.3a8794	f0 09		beq $3a879f	                BEQ done                        ; If EOL: we're done
.3a8796	c9 20		cmp #$20	                CMP #' '
.3a8798	f0 dc		beq $3a8776	                BEQ parse_arg                   ; If space: try to process another argument
.3a879a	20 d1 04	jsr $3a04d1	            JSR ISHEX
.3a879d	b0 d7		bcs $3a8776	                BCS parse_arg                   ; If hex digit: try to process another argument
.3a879f	6b		rtl		done            RTL
.3a87a0					IMPARSE
.3a87a0	08		php		                PHP
.3a87a1	0b		phd		                PHD
.3a87a2	08		php		            PHP
.3a87a3	c2 20		rep #$20	            REP #$20
.3a87a5	48		pha		            PHA
.3a87a6	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a87a9	5b		tcd		            TCD
.3a87aa	68		pla		            PLA
.3a87ab	28		plp		            PLP
.3a87ac	c2 10		rep #$10	            REP #$10
.3a87ae	e2 20		sep #$20	            SEP #$20
.3a87b0	a2 31 00	ldx #$0031	                LDX #MARG_LEN - MONITOR_VARS    ; Clear the monitor command line parameters
.3a87b3	74 00		stz $0848,x	clear_command   STZ MONITOR_VARS,X
.3a87b5	ca		dex		                DEX
.3a87b6	d0 fb		bne $3a87b3	                BNE clear_command
.3a87b8	a9 00		lda #$00	                LDA #`INPUTBUF                  ; Point the command parser to the input buffer
.3a87ba	85 02		sta $084a	                STA MCMDADDR+2
.3a87bc	85 34		sta $087c	                STA MCURSOR+2                   ; And point MCURSOR there too
.3a87be	c2 20		rep #$20	            REP #$20
.3a87c0	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF
.3a87c3	85 00		sta $0848	                STA MCMDADDR
.3a87c5	85 32		sta $087a	                STA MCURSOR
.3a87c7	e2 20		sep #$20	            SEP #$20
.3a87c9	22 ca 86 3a	jsl $3a86ca	                JSL MSKIPWS                     ; Skip to the first letter of the command
.3a87cd	c9 00		cmp #$00	                CMP #0                          ; Is the current character a NULL?
.3a87cf	f0 38		beq $3a8809	                BEQ done                        ; Yes: there's no command here
.3a87d1	c2 20		rep #$20	            REP #$20
.3a87d3	a5 32		lda $087a	                LDA MCURSOR
.3a87d5	85 08		sta $0850	                STA MCMD
.3a87d7	e2 20		sep #$20	            SEP #$20
.3a87d9	a5 34		lda $087c	                LDA MCURSOR+2
.3a87db	85 0a		sta $0852	                STA MCMD+2
.3a87dd	a2 01 00	ldx #$0001	                LDX #1
.3a87e0	22 88 86 3a	jsl $3a8688	cmd_loop        JSL M_INC_CURSOR                ; Move to the next character
.3a87e4	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; What is that character?
.3a87e6	d0 06		bne $3a87ee	                BNE cmd_space                   ; If not NULL: check for a space
.3a87e8	86 0b		stx $0853	no_arguments    STX MCMD_LEN                    ; If NULL: Save the length of the command
.3a87ea	64 31		stz $0879	                STZ MARG_LEN                    ; ... And the fact there are no arguments
.3a87ec	80 1b		bra $3a8809	                BRA done                        ; ... And return
.3a87ee	c9 20		cmp #$20	cmd_space       CMP #' '                        ; Is it a space?
.3a87f0	f0 03		beq $3a87f5	                BEQ found_cmd                   ; Yes: save the length
.3a87f2	e8		inx		                INX                             ; No: go to the next character
.3a87f3	80 eb		bra $3a87e0	                BRA cmd_loop
.3a87f5	86 0b		stx $0853	found_cmd       STX MCMD_LEN                    ; Save the length of the command
.3a87f7	a9 00		lda #$00	                LDA #0
.3a87f9	87 32		sta [$087a]	                STA [MCURSOR]                   ; Write a NULL to the end of the command
.3a87fb	22 88 86 3a	jsl $3a8688	                JSL M_INC_CURSOR                ; And skip to the next character
.3a87ff	a7 08		lda [$0850]	                LDA [MCMD]                      ; Check the command
.3a8801	c9 41		cmp #$41	                CMP #'A'
.3a8803	f0 07		beq $3a880c	                BEQ parse_asm                   ; If 'A', parse the line for the assemble command
.3a8805	22 72 87 3a	jsl $3a8772	                JSL MPARSEALLARG
.3a8809	2b		pld		done            PLD
.3a880a	28		plp		                PLP
.3a880b	6b		rtl		                RTL
.3a880c	22 ca 86 3a	jsl $3a86ca	parse_asm       JSL MSKIPWS                     ; Skip to the first letter of the address
.3a8810	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a8812	f0 f5		beq $3a8809	                BEQ done                        ; Exit if we got the end-of-line
.3a8814	22 28 87 3a	jsl $3a8728	                JSL MPARSEARG                   ; Parse the first argument as the target address
.3a8818	22 ca 86 3a	jsl $3a86ca	                JSL MSKIPWS                     ; Skip to the first letter of the mnemonic
.3a881c	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a881e	f0 e9		beq $3a8809	                BEQ done                        ; Exit if we got the end-of-line
.3a8820	c2 20		rep #$20	            REP #$20
.3a8822	a5 32		lda $087a	                LDA MCURSOR                     ; Save pointer to the start of the mnemonic
.3a8824	85 11		sta $0859	                STA MARG2
.3a8826	e2 20		sep #$20	            SEP #$20
.3a8828	a5 34		lda $087c	                LDA MCURSOR+2
.3a882a	85 13		sta $085b	                STA MARG2+2
.3a882c	22 88 86 3a	jsl $3a8688	asm_find_sp     JSL M_INC_CURSOR                ; Find the space at the end of the mnemonic
.3a8830	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a8832	f0 26		beq $3a885a	                BEQ asm_no_operand              ; If EOL: we have an instruction but no operand
.3a8834	c9 20		cmp #$20	                CMP #' '
.3a8836	d0 f4		bne $3a882c	                BNE asm_find_sp
.3a8838	a9 00		lda #$00	                LDA #0
.3a883a	87 32		sta [$087a]	                STA [MCURSOR]                   ; Null terminate the mnemonic
.3a883c	e6 31		inc $0879	                INC MARG_LEN                    ; Count the mnemonic as an argument
.3a883e	22 88 86 3a	jsl $3a8688	                JSL M_INC_CURSOR
.3a8842	22 ca 86 3a	jsl $3a86ca	                JSL MSKIPWS                     ; Skip to the addressing mode
.3a8846	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a8848	f0 bf		beq $3a8809	                BEQ done                        ; If EOL: we're done
.3a884a	c2 20		rep #$20	            REP #$20
.3a884c	a5 32		lda $087a	                LDA MCURSOR                     ; Set the pointer to the addressing mode
.3a884e	85 15		sta $085d	                STA MARG3
.3a8850	e2 20		sep #$20	            SEP #$20
.3a8852	a5 34		lda $087c	                LDA MCURSOR+2
.3a8854	85 17		sta $085f	                STA MARG3+2
.3a8856	e6 31		inc $0879	                INC MARG_LEN                    ; And count it as the second argument
.3a8858	80 af		bra $3a8809	                BRA done                        ; and return
.3a885a	e6 31		inc $0879	asm_no_operand  INC MARG_LEN                    ; Increment the argument count
.3a885c	80 ab		bra $3a8809	                BRA done                        ; And quit
.3a885e					IMLOAD
.3a885e	08		php		                PHP
.3a885f	c2 10		rep #$10	            REP #$10
.3a8861	e2 20		sep #$20	            SEP #$20
.3a8863	a5 31		lda $0879	                LDA MARG_LEN
.3a8865	d0 0f		bne $3a8876	                BNE get_arguments
.3a8867	a2 54 89	ldx #$8954	bad_arguments   LDX #<>MERRARGS                 ; Print bad arguments error
.3a886a	a9 3a		lda #$3a	                LDA #`MERRARGS
.3a886c	48		pha		                PHA
.3a886d	ab		plb		                PLB
.3a886e	20 29 04	jsr $3a0429	            JSR PRINTS
.3a8871	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a8874	80 61		bra $3a88d7	                BRA done
.3a8876					get_arguments
.3a8876	c2 20		rep #$20	            REP #$20
.3a8878	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.3a887a	8f 23 08 00	sta $000823	                STA ARGUMENT1
.3a887e	a5 0f		lda $0857	                LDA MARG1+2
.3a8880	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.3a8884	20 47 6a	jsr $3a6a47	            JSR SETFILEDESC
.3a8887	e2 20		sep #$20	            SEP #$20
.3a8889	a5 31		lda $0879	                LDA MARG_LEN
.3a888b	c9 01		cmp #$01	                CMP #1
.3a888d	d0 0f		bne $3a889e	                BNE get_dest
.3a888f	c2 20		rep #$20	            REP #$20
.3a8891	a9 ff ff	lda #$ffff	                LDA #$FFFF                      ; Destination address not provided...
.3a8894	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR              ; ... set it to something sane
.3a8898	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a889c	80 0e		bra $3a88ac	                BRA try_load
.3a889e					get_dest
.3a889e	c2 20		rep #$20	            REP #$20
.3a88a0	a5 11		lda $0859	                LDA MARG2                       ; Set the destination address from the arguments
.3a88a2	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a88a6	a5 13		lda $085b	                LDA MARG2+2
.3a88a8	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a88ac	22 18 11 00	jsl $001118	try_load        JSL FK_LOAD                     ; Try to load the file
.3a88b0	b0 25		bcs $3a88d7	                BCS done
.3a88b2					error
.3a88b2	e2 20		sep #$20	            SEP #$20
.3a88b4	a2 7a 89	ldx #$897a	                LDX #<>MCANTLOAD                ; Print bad arguments error
.3a88b7	a9 3a		lda #$3a	                LDA #`MCANTLOAD
.3a88b9	48		pha		                PHA
.3a88ba	ab		plb		                PLB
.3a88bb	20 29 04	jsr $3a0429	            JSR PRINTS
.3a88be	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.3a88c2	20 53 04	jsr $3a0453	            JSR PRHEXB
.3a88c5	a9 20		lda #$20	                LDA #' '
.3a88c7	20 18 00	jsr $3a0018	            JSR PRINTC
.3a88ca	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.3a88ce	20 53 04	jsr $3a0453	            JSR PRHEXB
.3a88d1	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a88d4	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a88d7	28		plp		done            PLP
.3a88d8	6b		rtl		                RTL
.3a88d9					IMSAVE
.3a88d9	8b		phb		                PHB
.3a88da	08		php		                PHP
.3a88db	c2 10		rep #$10	            REP #$10
.3a88dd	e2 20		sep #$20	            SEP #$20
.3a88df	a5 31		lda $0879	                LDA MARG_LEN
.3a88e1	c9 03		cmp #$03	                CMP #3
.3a88e3	f0 0f		beq $3a88f4	                BEQ get_arguments
.3a88e5	a2 54 89	ldx #$8954	                LDX #<>MERRARGS                 ; Print bad arguments error
.3a88e8	a9 3a		lda #$3a	                LDA #`MERRARGS
.3a88ea	48		pha		                PHA
.3a88eb	ab		plb		                PLB
.3a88ec	20 29 04	jsr $3a0429	            JSR PRINTS
.3a88ef	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a88f2	80 54		bra $3a8948	                BRA done
.3a88f4					get_arguments
.3a88f4	c2 20		rep #$20	            REP #$20
.3a88f6	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.3a88f8	8f 23 08 00	sta $000823	                STA ARGUMENT1
.3a88fc	a5 0f		lda $0857	                LDA MARG1+2
.3a88fe	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.3a8902	20 47 6a	jsr $3a6a47	            JSR SETFILEDESC
.3a8905	a5 11		lda $0859	                LDA MARG2                       ; Set the starting address
.3a8907	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.3a890b	a5 13		lda $085b	                LDA MARG2+2
.3a890d	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.3a8911	a5 15		lda $085d	                LDA MARG3                       ; Set the ending address
.3a8913	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.3a8917	a5 17		lda $085f	                LDA MARG3+2
.3a8919	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.3a891d	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                     ; Save the data
.3a8921	b0 25		bcs $3a8948	                BCS done
.3a8923					error
.3a8923	e2 20		sep #$20	            SEP #$20
.3a8925	a2 64 89	ldx #$8964	                LDX #<>MCANTSAVE                ; Print bad arguments error
.3a8928	a9 3a		lda #$3a	                LDA #`MCANTSAVE
.3a892a	48		pha		                PHA
.3a892b	ab		plb		                PLB
.3a892c	20 29 04	jsr $3a0429	            JSR PRINTS
.3a892f	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.3a8933	20 53 04	jsr $3a0453	            JSR PRHEXB
.3a8936	a9 20		lda #$20	                LDA #' '
.3a8938	20 18 00	jsr $3a0018	            JSR PRINTC
.3a893b	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.3a893f	20 53 04	jsr $3a0453	            JSR PRHEXB
.3a8942	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a8945	20 9c 03	jsr $3a039c	            JSR PRINTCR
.3a8948	28		plp		done            PLP
.3a8949	ab		plb		                PLB
.3a894a	6b		rtl		                RTL
.3a894b	5c 7d 27 3a	jmp $3a277d	IMEXIT          JML INTERACT
.3a894f	6b		rtl		IMRETURN        RTL ; Handle RETURN key (ie: execute command)
.3a8950	00		brk #		IMPARSE1        BRK ; Parse one word on the current command line
.3a8951	00		brk #		IMASSEMBLEA     BRK ; Assemble a line of text.
.3a8952	00		brk #		IMVERIFY        BRK ; Verify memory and file on disk
.3a8953	00		brk #		IMDOS           BRK ; Execute DOS command
.3a8954					MMESSAGES
>3a8954	42 61 64 20 61 72 67 75		MERRARGS        .null "Bad arguments",CHAR_CR,CHAR_CR
>3a895c	6d 65 6e 74 73 0d 0d 00
>3a8964	55 6e 61 62 6c 65 20 74		MCANTSAVE       .null "Unable to save file: "
>3a896c	6f 20 73 61 76 65 20 66 69 6c 65 3a 20 00
>3a897a	55 6e 61 62 6c 65 20 74		MCANTLOAD       .null "Unable to load file: "
>3a8982	6f 20 6c 6f 61 64 20 66 69 6c 65 3a 20 00
>3a8990	0d 20 20 50 43 20 20 20		mregisters_msg  .null $0D,"  PC     A    X    Y    SP   DBR DP   NVMXDIZC",CHAR_CR
>3a8998	20 20 41 20 20 20 20 58 20 20 20 20 59 20 20 20
>3a89a8	20 53 50 20 20 20 44 42 52 20 44 50 20 20 20 4e
>3a89b8	56 4d 58 44 49 5a 43 0d 00
>3a89c1	41 43 44 46 47 4a 48 4c		MCOMMANDS       .null "ACDFGJHLMR;STVWX>?"
>3a89c9	4d 52 3b 53 54 56 57 58 3e 3f 00

;******  Return to file: src\basic816.s

.3a89d4	18		clc		START       CLC                 ; Go to native mode
.3a89d5	fb		xce		            XCE
.3a89d6	08		php		            PHP
.3a89d7	c2 20		rep #$20	            REP #$20
.3a89d9	48		pha		            PHA
.3a89da	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a89dd	5b		tcd		            TCD
.3a89de	68		pla		            PLA
.3a89df	28		plp		            PLP
.3a89e0	08		php		            PHP
.3a89e1	e2 20		sep #$20	            SEP #$20
.3a89e3	48		pha		            PHA
.3a89e4	a9 00		lda #$00	            LDA #BASIC_BANK
.3a89e6	48		pha		            PHA
.3a89e7	ab		plb		            PLB
.3a89e8	68		pla		            PLA
.3a89e9	28		plp		            PLP
.3a89ea	c2 30		rep #$30	            REP #$30
.3a89ec	20 13 8a	jsr $3a8a13	            JSR INITBASIC
.3a89ef	a9 ff fe	lda #$feff	            LDA #STACK_END      ; Set the system stack
.3a89f2	1b		tcs		            TCS
.3a89f3	08		php		            PHP
.3a89f4	e2 20		sep #$20	            SEP #$20
.3a89f6	48		pha		            PHA
.3a89f7	a9 3a		lda #$3a	            LDA #`GREET
.3a89f9	48		pha		            PHA
.3a89fa	ab		plb		            PLB
.3a89fb	68		pla		            PLA
.3a89fc	28		plp		            PLP
.3a89fd	a2 71 d2	ldx #$d271	            LDX #<>GREET
.3a8a00	20 29 04	jsr $3a0429	            JSR PRINTS
.3a8a03	08		php		            PHP
.3a8a04	e2 20		sep #$20	            SEP #$20
.3a8a06	48		pha		            PHA
.3a8a07	a9 00		lda #$00	            LDA #BASIC_BANK
.3a8a09	48		pha		            PHA
.3a8a0a	ab		plb		            PLB
.3a8a0b	68		pla		            PLA
.3a8a0c	28		plp		            PLP
.3a8a0d	4c 7d 27	jmp $3a277d	            JMP INTERACT        ; Start accepting input from the user
.3a8a10	4c 10 8a	jmp $3a8a10	WAIT        JMP WAIT
.3a8a13					INITBASIC
.3a8a13	08		php		            PHP
.3a8a14	20 34 03	jsr $3a0334	            JSR INITIO
.3a8a17	20 b6 4f	jsr $3a4fb6	            JSR CMD_NEW
.3a8a1a	28		plp		            PLP
.3a8a1b	60		rts		            RTS
>3ad271	43 32 35 36 20 46 6f 65		GREET       .text "C256 Foenix BASIC816 "
>3ad279	6e 69 78 20 42 41 53 49 43 38 31 36 20

;******  Processing file: src\version.s

>3ad286	76 30 2e 32 2e 30 2d 61		.text "v0.2.0-alpha+398"
>3ad28e	6c 70 68 61 2b 33 39 38

;******  Return to file: src\basic816.s

>3ad296	0d 00				            .byte 13,0

;******  End of listing
