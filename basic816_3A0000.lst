
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -D SYSTEM=2 -D C256_SKU=1 -D UARTSUPPORT= -D UNITTEST=0 -D TRACE_LEVEL=0 --long-address --flat -b --m65816 --intel-hex -o basic816_3A0000.hex --list=basic816_3A0000.lst --labels=basic816_3A0000.lbl src\basic816.s
; Mon Aug 02 15:48:44 2021

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=2					SYSTEM=2
=1					C256_SKU=1
=					UARTSUPPORT=
=0					UNITTEST=0
=0					TRACE_LEVEL=0

;******  Processing input file: src\basic816.s


;******  Processing file: src\constants.s

=2					SYSTEM_C256 = 2         ; C256 Foenix
=1					SYSTEM_C64 = 1          ; Commodore 64 with SuperCPU
=$03					CHAR_CTRL_C = $03       ; CTRL-C: used as a program interrupt key
=$07					CHAR_BELL = $07         ; Ring the console bell
=$08					CHAR_BS = $08           ; Backspace
=$09					CHAR_TAB = $09          ; TAB
=$0a					CHAR_LF = $0A           ; Linefeed
=$0d					CHAR_CR = $0D           ; Carriage Return
=$0f					CHAR_INS = $0F          ; Insert
=$1b					CHAR_ESC = $1B          ; Escape
=$22					CHAR_DQUOTE = $22       ; Double quote
=$20					CHAR_SP = $20           ; Space
=$7f					CHAR_DEL = $7F          ; Delete
=5					ARGUMENT_SIZE = 5       ; Number of bytes in an argument
=8					VAR_NAME_SIZE = 8       ; Maximum number of characters in a variable name
=0					TYPE_INTEGER = 0        ; 32-bit integer
=1					TYPE_FLOAT = 1          ; Single-precision floating point
=2					TYPE_STRING = 2         ; ASCII string
=$80					TYPE_ARR_INTEGER = $80  ; Array of 32-bit integers
=$81					TYPE_ARR_FLOAT = $81    ; Array of 32-bit floats
=$82					TYPE_ARR_STRING = $82   ; Array of strings
=$7f					TYPE_BINDING = $7F      ; A variable name binding
=$ff					TYPE_NAV = $FF          ; Not-A-Value
=0					ERR_OK = 0              ; No error
=1					ERR_BREAK = 1           ; The user pressed an interrupt key
=2					ERR_SYNTAX = 2          ; A syntax error was found on the current line
=3					ERR_MEMORY = 3          ; Out of memory
=4					ERR_TYPE = 4            ; Type mismatch error
=5					ERR_NOTFOUND = 5        ; Variable not found error
=6					ERR_NOLINE = 6          ; Line number not found
=7					ERR_STACKUNDER = 7      ; Stack underflow error
=8					ERR_STACKOVER = 8       ; Stack overflow error
=9					ERR_RANGE = 9           ; Out-of-range error
=10					ERR_ARGUMENT = 10       ; Bad argument error
=11					ERR_NOFILE = 11         ; File not found error
=12					ERR_NAN = 12            ; Floating point math resulted in something that is not a number
=13					ERR_OVERFLOW = 13       ; Math operation overflowed
=14					ERR_UNDERFLOW = 14      ; Math operation underflowed
=15					ERR_DIV0 = 15           ; Math operation involved a division by zero
=16					ERR_DIRECTORY = 16      ; Error reading the directory
=17					ERR_LOAD = 17           ; Could not load file
=18					ERR_SAVE = 18           ; Could not save a file
=19					ERR_DELETE = 19         ; Could not delete a file
=20					ERR_FILENOTFOUND = 20   ; Could not find the file
=21					ERR_DIRNOTWRITE = 21    ; Could not update the directory entry
=22					ERR_NOTCOPIED = 22      ; Could not copy the file
=23					ERR_DOMAIN = 23         ; Mathematical functions domain error

;******  Return to file: src\basic816.s


;******  Processing file: src\memorymap.s


;******  Processing file: src\C256/mmap_c256.s

=1					SYS_C256_FMX = 1        ; System SKU for C256 Foenix FMX
=2					SYS_C256_USER = 2       ; System SKU for C256 Foenix User

;******  Processing file: src\C256/page_00_inc.s

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				unused_0000      = $000000 ;12 Bytes unused
=$000008				OPL2_ADDY_PTR_LO = $000008  ; THis Points towards the Instruments Database
=$000009				OPL2_ADDY_PTR_MD = $000009
=$00000a				OPL2_ADDY_PTR_HI = $00000A
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;1 Byte Color of next character to be printed to the screen.
=$00001f				COLORPOS         = $00001F ;3 Byte address of cursor's position in the color matrix
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$000026				OPL2_OPERATOR    = $000026 ;
=$000027				OPL2_CHANNEL     = $000027 ;
=$000028				OPL2_REG_REGION  = $000028 ; Offset to the Group of Registers
=$00002a				OPL2_REG_OFFSET  = $00002A ; 2 Bytes (16Bits)
=$00002c				OPL2_IND_ADDY_LL = $00002C ; 2 Bytes Reserved (Only need 3)
=$00002e				OPL2_IND_ADDY_HL = $00002E ; 2 Bytes Reserved (Only need 3)
=$000030				OPL2_NOTE        = $000030 ; 1 Byte
=$000031				OPL2_OCTAVE      = $000031 ; 1 Byte
=$000032				OPL2_PARAMETER0  = $000032 ; 1 Byte - Key On/Feedback
=$000033				OPL2_PARAMETER1  = $000033 ; 1 Byte
=$000034				OPL2_PARAMETER2  = $000034 ; 1 Byte
=$000035				OPL2_PARAMETER3  = $000035 ; 1 Byte
=$000036				OPL2_LOOP        = $000036 ;
=$000036				OPL2_BLOCK       = $000036
=$000038				SDCARD_FILE_PTR  = $000038 ; 3 Bytes Pointer to Filename to open
=$00003c				SDCARD_BYTE_NUM  = $00003C ; 2Bytes
=$00003f				SDCARD_PRSNT_MNT = $00003F ; 1 Byte, Indicate that the SDCard is Present and that it is Mounted
=$000040				BM_CLEAR_SCRN_X  = $000040
=$000042				BM_CLEAR_SCRN_Y  = $000042
=$000040				RAD_STARTLINE    = $000040 ; 1 Byte
=$000041				RAD_PATTERN_IDX  = $000041 ; 1 Byte
=$000042				RAD_LINE         = $000042 ; 1 Byte
=$000043				RAD_LINENUMBER   = $000043 ; 1 Byte
=$000044				RAD_CHANNEL_NUM  = $000044 ; 1 Byte
=$000045				RAD_ISLASTCHAN   = $000045 ; 1 Byte
=$000046				RAD_Y_POINTER    = $000046 ; 2 Bytes
=$000048				RAD_TICK         = $000048
=$00004a				RAD_CHANNEL_DATA = $00004A ; 2 Bytes
=$00004c				RAD_CHANNE_EFFCT = $00004C
=$00004d				RAD_TEMP         = $00004D
=$000050				RAD_ADDR         = $000050 ; 3 bytes to avoid OPL2 errors.
=$000053				RAD_PATTRN       = $000053 ; 1 bytes - offset to patter
=$000054				RAD_PTN_DEST     = $000054 ; 3 bytes - where to write the pattern data
=$000057				RAD_CHANNEL      = $000057 ; 2 bytes - 0 to 8
=$000059				RAD_LAST_NOTE    = $000059 ; 1 if this is the last note
=$00005a				RAD_LINE_PTR     = $00005A ; 2 bytes - offset to memory location
=$000040				BMP_X_SIZE       = $000040 ; 2 Bytes
=$000042				BMP_Y_SIZE       = $000042 ; 2 Bytes
=$000044				BMP_PRSE_SRC_PTR = $000044 ; 3 Bytes
=$000048				BMP_PRSE_DST_PTR = $000048 ; 3 Bytes
=$00004c				BMP_COLOR_PALET  = $00004C ; 2 Bytes
=$00004e				SCRN_X_STRIDE    = $00004E ; 2 Bytes, Basically How many Pixel Accross in Bitmap Mode
=$000050				BMP_FILE_SIZE    = $000050 ; 4 Bytes
=$000054				BMP_POSITION_X   = $000054 ; 2 Bytes Where, the BMP will be position on the X Axis
=$000056				BMP_POSITION_Y   = $000056 ; 2 Bytes Where, the BMP will be position on the Y Axis
=$000058				BMP_PALET_CHOICE = $000058 ;
=$0000e0				MOUSE_PTR        = $0000E0
=$0000e1				MOUSE_POS_X_LO   = $0000E1
=$0000e2				MOUSE_POS_X_HI   = $0000E2
=$0000e3				MOUSE_POS_Y_LO   = $0000E3
=$0000e4				MOUSE_POS_Y_HI   = $0000E4
=$0000f0				USER_TEMP        = $0000F0 ;32 Bytes Temp space for user programs
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000100				MULTIPLIER_0     = $000100 ;0 Byte  Unsigned multiplier
=$000100				M0_OPERAND_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				M0_OPERAND_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				M0_RESULT        = $000104 ;4 Bytes Result of A x B
=$000108				MULTIPLIER_1     = $000108 ;0 Byte  Signed Multiplier
=$000108				M1_OPERAND_A     = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				M1_OPERAND_B     = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				M1_RESULT        = $00010C ;4 Bytes Result of A x B
=$000110				DIVIDER_0        = $000110 ;0 Byte  Unsigned divider
=$000110				D0_OPERAND_A     = $000110 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$000112				D0_OPERAND_B     = $000112 ;2 Bytes Divider 0 Divisor ex B in A/B
=$000114				D0_RESULT        = $000114 ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$000116				D0_REMAINDER     = $000116 ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000118				DIVIDER_1        = $000118 ;0 Byte  Signed divider
=$000118				D1_OPERAND_A     = $000118 ;2 Bytes Divider 1 Dividend ex: A in  A/B
=$00011a				D1_OPERAND_B     = $00011A ;2 Bytes Divider 1 Divisor ex B in A/B
=$00011c				D1_RESULT        = $00011C ;2 Bytes Signed quotient result of A/B ex: 7/2 = 3 r 1
=$00011e				D1_REMAINDER     = $00011E ;2 Bytes Signed remainder of A/B ex: 1 in 7/2=3 r 1
=$000120				ADDER_SIGNED_32  = $000120 ; The 32 Bit Adders takes 12Byte that are NOT RAM Location
=$000140				INT_CONTROLLER   = $000140 ; $000140...$00015F Interrupt Controller
=$000160				TIMER_CONTROLLER = $000160 ; $000160...$00017F Timer0/Timer1/Timer2 Block
=$000160				TIMER_CTRL_REGLL = $000160 ;
=$000161				TIMER_CTRL_REGLH = $000161 ;
=$000162				TIMER_CTRL_REGHL = $000162 ;
=$000163				TIMER_CTRL_REGHH = $000163 ;
=$000240				CPU_REGISTERS    = $000240 ; Byte
=$000240				CPUPC            = $000240 ;2 Bytes Program Counter (PC)
=$000242				CPUPBR           = $000242 ;2 Bytes Program Bank Register (K)
=$000244				CPUA             = $000244 ;2 Bytes Accumulator (A)
=$000246				CPUX             = $000246 ;2 Bytes X Register (X)
=$000248				CPUY             = $000248 ;2 Bytes Y Register (Y)
=$00024a				CPUSTACK         = $00024A ;2 Bytes Stack Pointer (S)
=$00024c				CPUDP            = $00024C ;2 Bytes Direct Page Register (D)
=$00024e				CPUDBR           = $00024E ;1 Byte  Data Bank Register (B)
=$00024f				CPUFLAGS         = $00024F ;1 Byte  Flags (P)
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$000300				FDC_DRIVE        = $000300 ;1 byte - The number of the selected drive
=$000301				FDC_HEAD         = $000301 ;1 byte - The head number (0 or 1)
=$000302				FDC_CYLINDER     = $000302 ;1 byte - The cylinder number
=$000303				FDC_SECTOR       = $000303 ;1 byte - The sector number
=$000304				FDC_SECTOR_SIZE  = $000304 ;1 byte - The sector size code (2 = 512)
=$000305				FDC_SECPERTRK    = $000305 ;1 byte - The number of sectors per track (18 for 1.44 MB floppy)
=$000306				FDC_ST0          = $000306 ;1 byte - Status Register 0
=$000307				FDC_ST1          = $000307 ;1 byte - Status Register 1
=$000308				FDC_ST2          = $000308 ;1 byte - Status Register 2
=$000309				FDC_ST3          = $000309 ;1 byte - Status Register 3
=$00030a				FDC_PCN          = $00030A ;1 byte - Present Cylinder Number
=$00030b				FDC_STATUS       = $00030B ;1 byte - Status of what we think is going on with the FDC:
=$00030c				DIVIDEND         = $00030C ;4 bytes - Dividend for 32-bit division
=$000310				DIVISOR          = $000310 ;4 bytes - Divisor for 32-bit division
=$000314				REMAINDER        = $000314 ;4 bytes - Remainder for 32-bit division
=$000320				SDOS_VARIABLES   = $000320
=$000320				BIOS_STATUS      = $000320      ; 1 byte - Status of any BIOS operation
=$000321				BIOS_DEV         = $000321      ; 1 byte - Block device number for block operations
=$000322				BIOS_LBA         = $000322      ; 4 bytes - Address of block to read/write (this is the physical block, w/o reference to partition)
=$000326				BIOS_BUFF_PTR    = $000326      ; 4 bytes - 24-bit pointer to memory for read/write operations
=$00032a				BIOS_FIFO_COUNT  = $00032A      ; 2 bytes - The number of bytes read on the last block read
=$00032e				DOS_STATUS       = $00032E      ; 1 byte - The error code describing any error with file access
=$000330				DOS_CLUS_ID      = $000330      ; 4 bytes - The cluster desired for a DOS operation
=$000338				DOS_DIR_PTR      = $000338      ; 4 bytes - Pointer to a directory entry (assumed to be within DOS_SECTOR)
=$00033c				DOS_BUFF_PTR     = $00033C      ; 4 bytes - A pointer for DOS cluster read/write operations
=$000340				DOS_FD_PTR       = $000340      ; 4 bytes - A pointer to a file descriptor
=$000344				DOS_FAT_LBA      = $000344      ; 4 bytes - The LBA for a sector of the FAT we need to read/write
=$000348				DOS_TEMP         = $000348      ; 4 bytes - Temporary storage for DOS operations
=$00034c				DOS_FILE_SIZE    = $00034C      ; 4 bytes - The size of a file
=$000350				DOS_SRC_PTR      = $000350      ; 4 bytes - Pointer for transferring data
=$000354				DOS_DST_PTR      = $000354      ; 4 bytes - Pointer for transferring data
=$000358				DOS_END_PTR      = $000358      ; 4 bytes - Pointer to the last byte to save
=$00035c				DOS_RUN_PTR      = $00035C      ; 4 bytes - Pointer for starting a loaded program
=$000360				DOS_RUN_PARAM    = $000360      ; 4 bytes - Pointer to the ASCIIZ string for arguments in loading a program
=$000364				DOS_STR1_PTR     = $000364      ; 4 bytes - pointer to a string
=$000368				DOS_STR2_PTR     = $000368      ; 4 bytes - pointer to a string
=$00036b				DOS_SCRATCH      = $00036B      ; 4 bytes - general purpose short term storage
=$000400				DOS_PATH_BUFF    = $000400      ; 256 bytes - A buffer for path names
=$000500				FDC_PARAMETERS   = $000500      ; 16 bytes - a buffer of parameter data for the FDC
=$000510				FDC_RESULTS      = $000510      ; 16 bytes - Buffer for results of FDC commands
=$000530				FDC_PARAM_NUM    = $000530      ; 1 byte - The number of parameters to send to the FDC (including command)
=$000532				FDC_RESULT_NUM   = $000532      ; 1 byte - The number of results expected
=$000533				FDC_EXPECT_DAT   = $000533      ; 1 byte - 0 = the command expects no data, otherwise expects data
=$000534				FDC_CMD_RETRY    = $000534      ; 1 byte - a retry counter for commands
=$000700				CURRUART         = $000700 ; 3-bytes: the base address of the current UART
=$000703				CHAN_OUT         = $000703 ; 1-byte: the number of the current output channel (for PUTC, etc.)
=$000704				CHAN_IN          = $000704 ; 1-byte: the number of the current input channel (for GETCH, etc.)
=$000705				TIMERFLAGS       = $000705 ; 1-byte: flags to indicate that one of the timer interupts has triggered
=$80					TIMER0TRIGGER    = $80
=$40					TIMER1TRIGGER    = $40
=$20					TIMER2TRIGGER    = $20
=$000f00				KEY_BUFFER       = $000F00 ; 64 Bytes keyboard buffer
=$0080					KEY_BUFFER_SIZE  = $0080   ;128 Bytes (constant) keyboard buffer length
=$000f7f				KEY_BUFFER_END   = $000F7F ;  1 Byte  Last byte of keyboard buffer
=$000f83				KEY_BUFFER_CMD   = $000F83 ;  1 Byte  Indicates the Command Process Status
=$000f84				COMMAND_SIZE_STR = $000F84 ;  1 Byte
=$000f86				COMMAND_COMP_TMP = $000F86 ;  2 Bytes
=$000f87				KEYBOARD_SC_FLG  = $000F87 ;  1 Bytes that indicate the Status of Left Shift, Left CTRL, Left ALT, Right Shift
=$000f88				KEYBOARD_SC_TMP  = $000F88 ;  1 Byte, Interrupt Save Scan Code while Processing
=$000f89				KEYBOARD_LOCKS   = $000F89 ;  1 Byte, the status of the various lock keys
=$000f8a				KEYFLAG          = $000F8A ;  1 Byte, flag to indicate if CTRL-C has been pressed
=$000f8b				KEY_BUFFER_RPOS  = $000F8B ;  2 Byte, position of the character to read from the KEY_BUFFER
=$000f8d				KEY_BUFFER_WPOS  = $000F8D ;  2 Byte, position of the character to write to the KEY_BUFFER
=$001000				KERNEL_JMP_BEGIN = $001000 ; Reserved for the Kernel jump table
=$001fff				KERNEL_JMP_END   = $001FFF
=$002000				TEST_BEGIN       = $002000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/int_math_defs.s

=$000100				UNSIGNED_MULT_A_LO  = $000100
=$000101				UNSIGNED_MULT_A_HI  = $000101
=$000102				UNSIGNED_MULT_B_LO  = $000102
=$000103				UNSIGNED_MULT_B_HI  = $000103
=$000104				UNSIGNED_MULT_AL_LO = $000104
=$000105				UNSIGNED_MULT_AL_HI = $000105
=$000106				UNSIGNED_MULT_AH_LO = $000106
=$000107				UNSIGNED_MULT_AH_HI = $000107
=$000108				SIGNED_MULT_A_LO    = $000108
=$000109				SIGNED_MULT_A_HI    = $000109
=$00010a				SIGNED_MULT_B_LO    = $00010A
=$00010b				SIGNED_MULT_B_HI    = $00010B
=$00010c				SIGNED_MULT_AL_LO   = $00010C
=$00010d				SIGNED_MULT_AL_HI   = $00010D
=$00010e				SIGNED_MULT_AH_LO   = $00010E
=$00010f				SIGNED_MULT_AH_HI   = $00010F
=$000110				UNSIGNED_DIV_DEM_LO = $000110
=$000111				UNSIGNED_DIV_DEM_HI = $000111
=$000112				UNSIGNED_DIV_NUM_LO = $000112
=$000113				UNSIGNED_DIV_NUM_HI = $000113
=$000114				UNSIGNED_DIV_QUO_LO = $000114
=$000115				UNSIGNED_DIV_QUO_HI = $000115
=$000116				UNSIGNED_DIV_REM_LO = $000116
=$000117				UNSIGNED_DIV_REM_HI = $000117
=$000118				SIGNED_DIV_DEM_LO   = $000118
=$000119				SIGNED_DIV_DEM_HI   = $000119
=$00011a				SIGNED_DIV_NUM_LO   = $00011A
=$00011b				SIGNED_DIV_NUM_HI   = $00011B
=$00011c				SIGNED_DIV_QUO_LO   = $00011C
=$00011d				SIGNED_DIV_QUO_HI   = $00011D
=$00011e				SIGNED_DIV_REM_LO   = $00011E
=$00011f				SIGNED_DIV_REM_HI   = $00011F
=$000120				ADDER32_A_LL        = $000120
=$000121				ADDER32_A_LH        = $000121
=$000122				ADDER32_A_HL        = $000122
=$000123				ADDER32_A_HH        = $000123
=$000124				ADDER32_B_LL        = $000124
=$000125				ADDER32_B_LH        = $000125
=$000126				ADDER32_B_HL        = $000126
=$000127				ADDER32_B_HH        = $000127
=$000128				ADDER32_R_LL        = $000128
=$000129				ADDER32_R_LH        = $000129
=$00012a				ADDER32_R_HL        = $00012A
=$00012b				ADDER32_R_HH        = $00012B
=$af1400				SIGNED32_MULT_A     = $AF1400
=$af1404				SIGNED32_MULT_B     = $AF1404
=$af1408				SIGNED32_MULT_OUT   = $AF1408

;******  Return to file: src\C256/mmap_c256.s


;******  Processing file: src\C256/vicky_def.s

=$af0000				MASTER_CTRL_REG_L	      = $AF0000
=$01					Mstr_Ctrl_Text_Mode_En  = $01       ; Enable the Text Mode
=$02					Mstr_Ctrl_Text_Overlay  = $02       ; Enable the Overlay of the text mode on top of Graphic Mode (the Background Color is ignored)
=$04					Mstr_Ctrl_Graph_Mode_En = $04       ; Enable the Graphic Mode
=$08					Mstr_Ctrl_Bitmap_En     = $08       ; Enable the Bitmap Module In Vicky
=$10					Mstr_Ctrl_TileMap_En    = $10       ; Enable the Tile Module in Vicky
=$20					Mstr_Ctrl_Sprite_En     = $20       ; Enable the Sprite Module in Vicky
=$40					Mstr_Ctrl_GAMMA_En      = $40       ; this Enable the GAMMA correction - The Analog and DVI have different color value, the GAMMA is great to correct the difference
=$80					Mstr_Ctrl_Disable_Vid   = $80       ; This will disable the Scanning of the Video hence giving 100% bandwith to the CPU
=$af0001				MASTER_CTRL_REG_H       = $AF0001
=$01					Mstr_Ctrl_Video_Mode0   = $01       ; 0 - 640x480 (Clock @ 25.175Mhz), 1 - 800x600 (Clock @ 40Mhz)
=$02					Mstr_Ctrl_Video_Mode1   = $02       ; 0 - No Pixel Doubling, 1- Pixel Doubling (Reduce the Pixel Resolution by 2)
=$af0002				GAMMA_CTRL_REG          = $AF0002
=$01					GAMMA_Ctrl_Input        = $01 ; 0 = DipSwitch Chooses GAMMA on/off , 1- Software Control
=$02					GAMMA_Ctrl_Soft         = $02 ; 0 = GAMMA Table is not Applied, 1 = GAMMA Table is Applied
=$08					GAMMA_DP_SW_VAL         = $08 ; READ ONLY - Actual DIP Switch Value
=$10					HIRES_DP_SW_VAL         = $10 ; READ ONLY - 0 = Hi-Res on BOOT ON, 1 = Hi-Res on BOOT OFF
=$af0003				VKY_RESERVED_01         = $AF0003
=$01					Border_Ctrl_Enable      = $01
=$af0004				BORDER_CTRL_REG         = $AF0004 ; Bit[0] - Enable (1 by default)  Bit[4..6]: X Scroll Offset ( Will scroll Left) (Acceptable Value: 0..7)
=$af0005				BORDER_COLOR_B          = $AF0005
=$af0006				BORDER_COLOR_G          = $AF0006
=$af0007				BORDER_COLOR_R          = $AF0007
=$af0008				BORDER_X_SIZE           = $AF0008; X-  Values: 0 - 32 (Default: 32)
=$af0009				BORDER_Y_SIZE           = $AF0009; Y- Values 0 -32 (Default: 32)
=$af000d				BACKGROUND_COLOR_B      = $AF000D ; When in Graphic Mode, if a pixel is "0" then the Background pixel is chosen
=$af000e				BACKGROUND_COLOR_G      = $AF000E
=$af000f				BACKGROUND_COLOR_R      = $AF000F ;
=$af0010				VKY_TXT_CURSOR_CTRL_REG = $AF0010   ;[0]  Enable Text Mode
=$01					Vky_Cursor_Enable       = $01
=$02					Vky_Cursor_Flash_Rate0  = $02       ; 00 - 1/Sec, 01 - 2/Sec, 10 - 4/Sec, 11 - 5/Sec
=$04					Vky_Cursor_Flash_Rate1  = $04
=$08					Vky_Cursor_FONT_Page0   = $08       ; Pick Font Page 0 or Font Page 1
=$10					Vky_Cursor_FONT_Page1   = $10       ; Pick Font Page 0 or Font Page 1
=$af0011				VKY_TXT_START_ADD_PTR   = $AF0011   ; This is an offset to change the Starting address of the Text Mode Buffer (in x)
=$af0012				VKY_TXT_CURSOR_CHAR_REG = $AF0012
=$af0013				VKY_TXT_CURSOR_COLR_REG = $AF0013
=$af0014				VKY_TXT_CURSOR_X_REG_L  = $AF0014
=$af0015				VKY_TXT_CURSOR_X_REG_H  = $AF0015
=$af0016				VKY_TXT_CURSOR_Y_REG_L  = $AF0016
=$af0017				VKY_TXT_CURSOR_Y_REG_H  = $AF0017
=$af001b				VKY_LINE_IRQ_CTRL_REG   = $AF001B ;[0] - Enable Line 0, [1] -Enable Line 1
=$af001c				VKY_LINE0_CMP_VALUE_LO  = $AF001C ;Write Only [7:0]
=$af001d				VKY_LINE0_CMP_VALUE_HI  = $AF001D ;Write Only [3:0]
=$af001e				VKY_LINE1_CMP_VALUE_LO  = $AF001E ;Write Only [7:0]
=$af001f				VKY_LINE1_CMP_VALUE_HI  = $AF001F ;Write Only [3:0]
=$af001c				VKY_INFO_CHIP_NUM_L     = $AF001C   ; VErsion
=$af001d				VKY_INFO_CHIP_NUM_H     = $AF001D   ; Version
=$af001e				VKY_INFO_CHIP_VER_L     = $AF001E   ; Sub-Version
=$af001f				VKY_INFO_CHIP_VER_H     = $AF001F   ; Sub-Version
=$af0500				MOUSE_PTR_GRAP0_START    = $AF0500 ; 16 x 16 = 256 Pixels (Grey Scale) 0 = Transparent, 1 = Black , 255 = White
=$af05ff				MOUSE_PTR_GRAP0_END      = $AF05FF ; Pointer 0
=$af0600				MOUSE_PTR_GRAP1_START    = $AF0600 ;
=$af06ff				MOUSE_PTR_GRAP1_END      = $AF06FF ; Pointer 1
=$af0700				MOUSE_PTR_CTRL_REG_L    = $AF0700 ; Bit[0] Enable, Bit[1] = 0  ( 0 = Pointer0, 1 = Pointer1)
=$af0701				MOUSE_PTR_CTRL_REG_H    = $AF0701 ;
=$af0702				MOUSE_PTR_X_POS_L       = $AF0702 ; X Position (0 - 639) (Can only read now) Writing will have no effect
=$af0703				MOUSE_PTR_X_POS_H       = $AF0703 ;
=$af0704				MOUSE_PTR_Y_POS_L       = $AF0704 ; Y Position (0 - 479) (Can only read now) Writing will have no effect
=$af0705				MOUSE_PTR_Y_POS_H       = $AF0705 ;
=$af0706				MOUSE_PTR_BYTE0         = $AF0706 ; Byte 0 of Mouse Packet (you must write 3 Bytes)
=$af0707				MOUSE_PTR_BYTE1         = $AF0707 ; Byte 1 of Mouse Packet (if you don't, then )
=$af0708				MOUSE_PTR_BYTE2         = $AF0708 ; Byte 2 of Mouse Packet (state Machine will be jammed in 1 state)
=$af070b				C256F_MODEL_MAJOR       = $AF070B ;
=$af070c				C256F_MODEL_MINOR       = $AF070C ;
=$af070d				FPGA_DOR                = $AF070D ;
=$af070e				FPGA_MOR                = $AF070E ;
=$af070f				FPGA_YOR                = $AF070F ;
=$af0900				VMEM2CPU_CTRL_REG      = $AF0900  ;
=$01					VMEM2CPU_Clear_FIFO    = $01        ; Setting this to 1 will flush (Reset) the FIFO, clear it after to return to normal function
=$02					VMEM2CPU_Intterupt     = $02        ; This is not implemented because there is not enough Interrupt line on the FMX
=$af0901				VMEM2CPU_Data_Port     = $AF0901    ; This is a Byte Port of the data that you have requested. (Output of the FIFO)
=$af0902				VMEM2CPU_Fifo_Count_LO = $AF0902    ; FIFO Count Lo (number of byte in the FIFO) FIFO Count is 10bits, Count_Bit0 to Count_Bit7 of Count
=$af0903				VMEM2CPU_Fifo_Count_HI = $AF0903    ; FIFO Count Hi, Bit 0 = Count_Bit8, Bit 1 = Count_Bit9
=$80					VMEM2CPU_Fifo_Empty    = $80        ; Bit 7 of VMEM2CPU_Fifo_Count_HI, when 1, the FIFO is empty.
=$af1f40				FG_CHAR_LUT_PTR         = $AF1F40
=$af1f80				BG_CHAR_LUT_PTR		    = $AF1F80
=$af2000				GRPH_LUT0_PTR		    = $AF2000
=$af2400				GRPH_LUT1_PTR		    = $AF2400
=$af2800				GRPH_LUT2_PTR		    = $AF2800
=$af2c00				GRPH_LUT3_PTR		    = $AF2C00
=$af3000				GRPH_LUT4_PTR		    = $AF3000
=$af3400				GRPH_LUT5_PTR		    = $AF3400
=$af3800				GRPH_LUT6_PTR		    = $AF3800
=$af3c00				GRPH_LUT7_PTR		    = $AF3C00
=$af4000				GAMMA_B_LUT_PTR		    = $AF4000
=$af4100				GAMMA_G_LUT_PTR		    = $AF4100
=$af4200				GAMMA_R_LUT_PTR		    = $AF4200
=$af8000				FONT_MEMORY_BANK0       = $AF8000     ;$AF8000 - $AF87FF
=$afa000				CS_TEXT_MEM_PTR         = $AFA000
=$afc000				CS_COLOR_MEM_PTR        = $AFC000

;******  Processing file: src\C256/VKYII_CFP9553_BITMAP_def.s

=$01					BM_Enable             = $01
=$00					BM_LUT0               = $00 ;
=$02					BM_LUT1               = $02 ;
=$04					BM_LUT2               = $04 ;
=$06					BM_LUT3               = $06 ;
=$08					BM_LUT4               = $08 ;
=$0a					BM_LUT5               = $0A ;
=$0c					BM_LUT6               = $0C ;
=$0e					BM_LUT7               = $0E ;
=$af0100				BM0_CONTROL_REG     = $AF0100
=$af0101				BM0_START_ADDY_L    = $AF0101
=$af0102				BM0_START_ADDY_M    = $AF0102
=$af0103				BM0_START_ADDY_H    = $AF0103
=$af0104				BM0_X_OFFSET        = $AF0104   ; Not Implemented
=$af0105				BM0_Y_OFFSET        = $AF0105   ; Not Implemented
=$af0106				BM0_RESERVED_6      = $AF0106
=$af0107				BM0_RESERVED_7      = $AF0107
=$af0108				BM1_CONTROL_REG     = $AF0108
=$af0109				BM1_START_ADDY_L    = $AF0109
=$af010a				BM1_START_ADDY_M    = $AF010A
=$af010b				BM1_START_ADDY_H    = $AF010B
=$af010c				BM1_X_OFFSET        = $AF010C   ; Not Implemented
=$af010d				BM1_Y_OFFSET        = $AF010D   ; Not Implemented
=$af010e				BM1_RESERVED_6      = $AF010E
=$af010f				BM1_RESERVED_7      = $AF010F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_TILEMAP_def.s

=$01					TILE_Enable             = $01
=0					TILEMAP_CONTROL         = 0             ; Offset to a tile map's control register
=1					TILEMAP_START_ADDY      = 1             ; Offset to a tile map's address
=4					TILEMAP_TOTAL_X         = 4             ; Offset to a tile map's width
=6					TILEMAP_TOTAL_Y         = 6             ; Offset to a tile map's height
=8					TILEMAP_WINDOW_X        = 8             ; Offset to a tile map's X position
=10					TILEMAP_WINDOW_Y        = 10            ; Offset to a tile map's Y position
=1					TILEMAP_VISIBLE         = 1             ; Tile map is visible flag
=$af0200				TL0_CONTROL_REG         = $AF0200       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0201				TL0_START_ADDY_L        = $AF0201       ; Not USed right now - Starting Address to where is the MAP
=$af0202				TL0_START_ADDY_M        = $AF0202
=$af0203				TL0_START_ADDY_H        = $AF0203
=$af0204				TL0_TOTAL_X_SIZE_L      = $AF0204       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0205				TL0_TOTAL_X_SIZE_H      = $AF0205
=$af0206				TL0_TOTAL_Y_SIZE_L      = $AF0206       ; Size of the Map in Y Tile Count [9:0]
=$af0207				TL0_TOTAL_Y_SIZE_H      = $AF0207
=$af0208				TL0_WINDOW_X_POS_L      = $AF0208       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0209				TL0_WINDOW_X_POS_H      = $AF0209       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af020a				TL0_WINDOW_Y_POS_L      = $AF020A       ; Top Left Corner Position of the TileMAp Window in Y
=$af020b				TL0_WINDOW_Y_POS_H      = $AF020B       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af020c				TL1_CONTROL_REG         = $AF020C       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af020d				TL1_START_ADDY_L        = $AF020D       ; Not USed right now - Starting Address to where is the MAP
=$af020e				TL1_START_ADDY_M        = $AF020E
=$af020f				TL1_START_ADDY_H        = $AF020F
=$af0210				TL1_TOTAL_X_SIZE_L      = $AF0210       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0211				TL1_TOTAL_X_SIZE_H      = $AF0211
=$af0212				TL1_TOTAL_Y_SIZE_L      = $AF0212       ; Size of the Map in Y Tile Count [9:0]
=$af0213				TL1_TOTAL_Y_SIZE_H      = $AF0213
=$af0214				TL1_WINDOW_X_POS_L      = $AF0214       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0215				TL1_WINDOW_X_POS_H      = $AF0215       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0216				TL1_WINDOW_Y_POS_L      = $AF0216       ; Top Left Corner Position of the TileMAp Window in Y
=$af0217				TL1_WINDOW_Y_POS_H      = $AF0217       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0218				TL2_CONTROL_REG         = $AF0218       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0219				TL2_START_ADDY_L        = $AF0219       ; Not USed right now - Starting Address to where is the MAP
=$af021a				TL2_START_ADDY_M        = $AF021A
=$af021b				TL2_START_ADDY_H        = $AF021B
=$af021c				TL2_TOTAL_X_SIZE_L      = $AF021C       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af021d				TL2_TOTAL_X_SIZE_H      = $AF021D
=$af021e				TL2_TOTAL_Y_SIZE_L      = $AF021E       ; Size of the Map in Y Tile Count [9:0]
=$af021f				TL2_TOTAL_Y_SIZE_H      = $AF021F
=$af0220				TL2_WINDOW_X_POS_L      = $AF0220       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af0221				TL2_WINDOW_X_POS_H      = $AF0221       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af0222				TL2_WINDOW_Y_POS_L      = $AF0222       ; Top Left Corner Position of the TileMAp Window in Y
=$af0223				TL2_WINDOW_Y_POS_H      = $AF0223       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0224				TL3_CONTROL_REG         = $AF0224       ; Bit[0] - Enable, Bit[3:1] - LUT Select,
=$af0225				TL3_START_ADDY_L        = $AF0225       ; Not USed right now - Starting Address to where is the MAP
=$af0226				TL3_START_ADDY_M        = $AF0226
=$af0227				TL3_START_ADDY_H        = $AF0227
=$af0228				TL3_TOTAL_X_SIZE_L      = $AF0228       ; Size of the Map in X Tile Count [9:0] (1024 Max)
=$af0229				TL3_TOTAL_X_SIZE_H      = $AF0229
=$af022a				TL3_TOTAL_Y_SIZE_L      = $AF022A       ; Size of the Map in Y Tile Count [9:0]
=$af022b				TL3_TOTAL_Y_SIZE_H      = $AF022B
=$af022c				TL3_WINDOW_X_POS_L      = $AF022C       ; Top Left Corner Position of the TileMAp Window in X + Scroll
=$af022d				TL3_WINDOW_X_POS_H      = $AF022D       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in X
=$af022e				TL3_WINDOW_Y_POS_L      = $AF022E       ; Top Left Corner Position of the TileMAp Window in Y
=$af022f				TL3_WINDOW_Y_POS_H      = $AF022F       ; Direction: [14] Scroll: [13:10] Pos: [9:0] in Y
=$af0280				TILESET0_ADDY_L         = $AF0280   ; Pointer to Tileset 0 [21:0]
=$af0281				TILESET0_ADDY_M         = $AF0281
=$af0282				TILESET0_ADDY_H         = $AF0282
=$af0283				TILESET0_ADDY_CFG       = $AF0283   ; [3] - TileStride256x256 [2:0] LUT
=2					TILESET_ADDY_H          = 2             ; Offset to high byte of tile set address
=3					TILESET_ADDY_CFG        = 3             ; Offset to the tile set address configuration
=$08					TILESET_SQUARE_256      = $08
=$af0284				TILESET1_ADDY_L         = $AF0284
=$af0285				TILESET1_ADDY_M         = $AF0285
=$af0286				TILESET1_ADDY_H         = $AF0286
=$af0287				TILESET1_ADDY_CFG       = $AF0287
=$af0288				TILESET2_ADDY_L         = $AF0288
=$af0289				TILESET2_ADDY_M         = $AF0289
=$af028a				TILESET2_ADDY_H         = $AF028A
=$af028b				TILESET2_ADDY_CFG       = $AF028B
=$af028c				TILESET3_ADDY_L         = $AF028C
=$af028d				TILESET3_ADDY_M         = $AF028D
=$af028e				TILESET3_ADDY_H         = $AF028E
=$af028f				TILESET3_ADDY_CFG       = $AF028F
=$af0290				TILESET4_ADDY_L         = $AF0290
=$af0291				TILESET4_ADDY_M         = $AF0291
=$af0292				TILESET4_ADDY_H         = $AF0292
=$af0293				TILESET4_ADDY_CFG       = $AF0293
=$af0294				TILESET5_ADDY_L         = $AF0294
=$af0295				TILESET5_ADDY_M         = $AF0295
=$af0296				TILESET5_ADDY_H         = $AF0296
=$af0297				TILESET5_ADDY_CFG       = $AF0297
=$af0298				TILESET6_ADDY_L         = $AF0298
=$af0299				TILESET6_ADDY_M         = $AF0299
=$af029a				TILESET6_ADDY_H         = $AF029A
=$af029b				TILESET6_ADDY_CFG       = $AF029B
=$af029c				TILESET7_ADDY_L         = $AF029C
=$af029d				TILESET7_ADDY_M         = $AF029D
=$af029e				TILESET7_ADDY_H         = $AF029E
=$af029f				TILESET7_ADDY_CFG       = $AF029F

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SDMA_def.s

=$af0420				SDMA_CTRL_REG0           = $AF0420
=$01					SDMA_CTRL0_Enable        = $01
=$02					SDMA_CTRL0_1D_2D         = $02     ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					SDMA_CTRL0_TRF_Fill      = $04     ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					SDMA_CTRL0_Int_Enable    = $08     ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					SDMA_CTRL0_SysRAM_Src    = $10     ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					SDMA_CTRL0_SysRAM_Dst    = $20     ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$00					SDMA_XFER_SRAM2SRAM = $00           ; SRAM -> SRAM transfer
=$10					SDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					SDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$30					SDMA_XFER_SRAMIO = $30              ; SRAM <-> IO transfer (see: SDMA_CONTROL_REG1 for config and direction)
=$40					SDMA_CTLR0_RSVD          = $40      ; Reserved
=$80					SDMA_CTRL0_Start_TRF     = $80      ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$af0421				SDMA_CTRL_REG1           = $AF0421  ; Write Only - Byte to Write in the Fill Function
=$01					SDMA_CTRL1_IO_Src		 = $01		; 1 = Source is an IO Address (ADC, SuperIO, IDE)
=$02					SDMA_CTRL1_IO_Src16		 = $02		; 0 = Src 8Bits Transfer / 1= 16Bits Transfer
=$04					SDMA_CTRL1_IO_Dst		 = $04		; 1 = Destination is an IO Address (DAC, SuperIO, IDE)
=$08					SDMA_CTRL1_IO_Dst16      = $08      ; 0 = Dst 8bits Transfer / 1= 16bits
=$af0422				SDMA_SRC_ADDY_L         = $AF0422   ; Pointer to the Source of the Data to be stransfered
=$af0423				SDMA_SRC_ADDY_M         = $AF0423   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0424				SDMA_SRC_ADDY_H         = $AF0424
=$af0425				SDMA_DST_ADDY_L         = $AF0425   ; Destination Pointer within CPU's video memory Range
=$af0426				SDMA_DST_ADDY_M         = $AF0426   ; This needs to be within CPU's system RAM range ($00_0000 - $3F_FFFF)
=$af0427				SDMA_DST_ADDY_H         = $AF0427
=$af0428				SDMA_SIZE_L             = $AF0428   ; Maximum Value: $40:0000 (4Megs)
=$af0429				SDMA_SIZE_M             = $AF0429
=$af042a				SDMA_SIZE_H             = $AF042A
=$af042b				SDMA_IGNORED            = $AF042B
=$af0428				SDMA_X_SIZE_L           = $AF0428   ; Maximum Value: 65535
=$af0429				SDMA_X_SIZE_H           = $AF0429
=$af042a				SDMA_Y_SIZE_L           = $AF042A   ; Maximum Value: 65535
=$af042b				SDMA_Y_SIZE_H           = $AF042B
=$af042c				SDMA_SRC_STRIDE_L       = $AF042C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042d				SDMA_SRC_STRIDE_H       = $AF042D   ;
=$af042e				SDMA_DST_STRIDE_L       = $AF042E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af042f				SDMA_DST_STRIDE_H       = $AF042F   ;
=$af0430				SDMA_BYTE_2_WRITE       = $AF0430   ; Write Only - Byte to Write in the Fill Function
=$af0430				SDMA_STATUS_REG         = $AF0430   ; Read only
=$01					SDMA_STAT_Size_Err       = $01      ; If Set to 1, Overall Size is Invalid
=$02					SDMA_STAT_Dst_Add_Err    = $02      ; If Set to 1, Destination Address Invalid
=$04					SDMA_STAT_Src_Add_Err    = $04      ; If Set to 1, Source Address Invalid
=$08					SDMA_STAT_TimeOut_Err    = $08      ; will be set to 1 if a Timeout occur when transfering between data from and to VRAM

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_VDMA_def.s

=$af0400				VDMA_CONTROL_REG        = $AF0400
=$01					VDMA_CTRL_Enable        = $01
=$02					VDMA_CTRL_1D_2D         = $02       ; 0 - 1D (Linear) Transfer , 1 - 2D (Block) Transfer
=$04					VDMA_CTRL_TRF_Fill      = $04       ; 0 - Transfer Src -> Dst, 1 - Fill Destination with "Byte2Write"
=$08					VDMA_CTRL_Int_Enable    = $08       ; Set to 1 to Enable the Generation of Interrupt when the Transfer is over.
=$10					VDMA_CTRL_SysRAM_Src    = $10       ; Set to 1 to Indicate that the Source is the System Ram Memory
=$20					VDMA_CTRL_SysRAM_Dst    = $20       ; Set to 1 to Indicate that the Destination is the System Ram Memory
=$80					VDMA_CTRL_Start_TRF     = $80       ; Set to 1 To Begin Process, Need to Cleared before, you can start another
=$00					VDMA_XFER_VRAM2VRAM = $00           ; VRAM -> VRAM transfer
=$10					VDMA_XFER_SRAM2VRAM = $10           ; SRAM -> VRAM transfer
=$20					VDMA_XFER_VRAM2SRAM = $20           ; VRAM -> SRAM transfer
=$af0401				VDMA_BYTE_2_WRITE       = $AF0401   ; Write Only - Byte to Write in the Fill Function
=$af0401				VDMA_STATUS_REG         = $AF0401   ; Read only
=$01					VDMA_STAT_Size_Err      = $01       ; If Set to 1, Overall Size is Invalid
=$02					VDMA_STAT_Dst_Add_Err   = $02       ; If Set to 1, Destination Address Invalid
=$04					VDMA_STAT_Src_Add_Err   = $04       ; If Set to 1, Source Address Invalid
=$80					VDMA_STAT_VDMA_IPS      = $80       ; If Set to 1, VDMA Transfer in Progress (this Inhibit CPU Access to Mem)
=$af0402				VDMA_SRC_ADDY_L         = $AF0402   ; Pointer to the Source of the Data to be stransfered
=$af0403				VDMA_SRC_ADDY_M         = $AF0403   ; This needs to be within Vicky's Range ($00_0000 - $3F_0000)
=$af0404				VDMA_SRC_ADDY_H         = $AF0404
=$af0405				VDMA_DST_ADDY_L         = $AF0405   ; Destination Pointer within Vicky's video memory Range
=$af0406				VDMA_DST_ADDY_M         = $AF0406   ; ($00_0000 - $3F_0000)
=$af0407				VDMA_DST_ADDY_H         = $AF0407
=$af0408				VDMA_SIZE_L             = $AF0408   ; Maximum Value: $40:0000 (4Megs)
=$af0409				VDMA_SIZE_M             = $AF0409
=$af040a				VDMA_SIZE_H             = $AF040A
=$af040b				VDMA_IGNORED            = $AF040B
=$af0408				VDMA_X_SIZE_L           = $AF0408   ; Maximum Value: 65535
=$af0409				VDMA_X_SIZE_H           = $AF0409
=$af040a				VDMA_Y_SIZE_L           = $AF040A   ; Maximum Value: 65535
=$af040b				VDMA_Y_SIZE_H           = $AF040B
=$af040c				VDMA_SRC_STRIDE_L       = $AF040C   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040d				VDMA_SRC_STRIDE_H       = $AF040D   ;
=$af040e				VDMA_DST_STRIDE_L       = $AF040E   ; Always use an Even Number ( The Engine uses Even Ver of that value)
=$af040f				VDMA_DST_STRIDE_H       = $AF040F   ;

;******  Return to file: src\C256/vicky_def.s


;******  Processing file: src\C256/VKYII_CFP9553_SPRITE_def.s

=$01					SPRITE_Enable             = $01
=$00					SPRITE_LUT0               = $00 ; This is the LUT that the Sprite will use
=$02					SPRITE_LUT1               = $02
=$04					SPRITE_LUT2               = $04 ; Only 4 LUT for Now, So this bit is not used.
=$06					SPRITE_LUT3               = $06 ; Only 4 LUT for Now, So this bit is not used.
=$08					SPRITE_LUT4               = $08 ; Only 4 LUT for Now, So this bit is not used.
=$0a					SPRITE_LUT5               = $0A ; Only 4 LUT for Now, So this bit is not used.
=$0c					SPRITE_LUT6               = $0C ; Only 4 LUT for Now, So this bit is not used.
=$0e					SPRITE_LUT7               = $0E ; Only 4 LUT for Now, So this bit is not used.
=$00					SPRITE_DEPTH0             = $00
=$10					SPRITE_DEPTH1             = $10
=$20					SPRITE_DEPTH2             = $20
=$30					SPRITE_DEPTH3             = $30
=$40					SPRITE_DEPTH4             = $40
=$50					SPRITE_DEPTH5             = $50
=$60					SPRITE_DEPTH6             = $60
=$af0c00				SP00_CONTROL_REG        = $AF0C00
=$af0c01				SP00_ADDY_PTR_L         = $AF0C01
=$af0c02				SP00_ADDY_PTR_M         = $AF0C02
=$af0c03				SP00_ADDY_PTR_H         = $AF0C03
=$af0c04				SP00_X_POS_L            = $AF0C04
=$af0c05				SP00_X_POS_H            = $AF0C05
=$af0c06				SP00_Y_POS_L            = $AF0C06
=$af0c07				SP00_Y_POS_H            = $AF0C07
=$af0c08				SP01_CONTROL_REG        = $AF0C08
=$af0c09				SP01_ADDY_PTR_L         = $AF0C09
=$af0c0a				SP01_ADDY_PTR_M         = $AF0C0A
=$af0c0b				SP01_ADDY_PTR_H         = $AF0C0B
=$af0c0c				SP01_X_POS_L            = $AF0C0C
=$af0c0d				SP01_X_POS_H            = $AF0C0D
=$af0c0e				SP01_Y_POS_L            = $AF0C0E
=$af0c0f				SP01_Y_POS_H            = $AF0C0F
=$af0c10				SP02_CONTROL_REG        = $AF0C10
=$af0c11				SP02_ADDY_PTR_L         = $AF0C11
=$af0c12				SP02_ADDY_PTR_M         = $AF0C12
=$af0c13				SP02_ADDY_PTR_H         = $AF0C13
=$af0c14				SP02_X_POS_L            = $AF0C14
=$af0c15				SP02_X_POS_H            = $AF0C15
=$af0c16				SP02_Y_POS_L            = $AF0C16
=$af0c17				SP02_Y_POS_H            = $AF0C17
=$af0c18				SP03_CONTROL_REG        = $AF0C18
=$af0c19				SP03_ADDY_PTR_L         = $AF0C19
=$af0c1a				SP03_ADDY_PTR_M         = $AF0C1A
=$af0c1b				SP03_ADDY_PTR_H         = $AF0C1B
=$af0c1c				SP03_X_POS_L            = $AF0C1C
=$af0c1d				SP03_X_POS_H            = $AF0C1D
=$af0c1e				SP03_Y_POS_L            = $AF0C1E
=$af0c1f				SP03_Y_POS_H            = $AF0C1F
=$af0c20				SP04_CONTROL_REG        = $AF0C20
=$af0c21				SP04_ADDY_PTR_L         = $AF0C21
=$af0c22				SP04_ADDY_PTR_M         = $AF0C22
=$af0c23				SP04_ADDY_PTR_H         = $AF0C23
=$af0c24				SP04_X_POS_L            = $AF0C24
=$af0c25				SP04_X_POS_H            = $AF0C25
=$af0c26				SP04_Y_POS_L            = $AF0C26
=$af0c27				SP04_Y_POS_H            = $AF0C27
=$af0c28				SP05_CONTROL_REG        = $AF0C28
=$af0c29				SP05_ADDY_PTR_L         = $AF0C29
=$af0c2a				SP05_ADDY_PTR_M         = $AF0C2A
=$af0c2b				SP05_ADDY_PTR_H         = $AF0C2B
=$af0c2c				SP05_X_POS_L            = $AF0C2C
=$af0c2d				SP05_X_POS_H            = $AF0C2D
=$af0c2e				SP05_Y_POS_L            = $AF0C2E
=$af0c2f				SP05_Y_POS_H            = $AF0C2F
=$af0c30				SP06_CONTROL_REG        = $AF0C30
=$af0c31				SP06_ADDY_PTR_L         = $AF0C31
=$af0c32				SP06_ADDY_PTR_M         = $AF0C32
=$af0c33				SP06_ADDY_PTR_H         = $AF0C33
=$af0c34				SP06_X_POS_L            = $AF0C34
=$af0c35				SP06_X_POS_H            = $AF0C35
=$af0c36				SP06_Y_POS_L            = $AF0C36
=$af0c37				SP06_Y_POS_H            = $AF0C37
=$af0c38				SP07_CONTROL_REG        = $AF0C38
=$af0c39				SP07_ADDY_PTR_L         = $AF0C39
=$af0c3a				SP07_ADDY_PTR_M         = $AF0C3A
=$af0c3b				SP07_ADDY_PTR_H         = $AF0C3B
=$af0c3c				SP07_X_POS_L            = $AF0C3C
=$af0c3d				SP07_X_POS_H            = $AF0C3D
=$af0c3e				SP07_Y_POS_L            = $AF0C3E
=$af0c3f				SP07_Y_POS_H            = $AF0C3F
=$af0c40				SP08_CONTROL_REG        = $AF0C40
=$af0c41				SP08_ADDY_PTR_L         = $AF0C41
=$af0c42				SP08_ADDY_PTR_M         = $AF0C42
=$af0c43				SP08_ADDY_PTR_H         = $AF0C43
=$af0c44				SP08_X_POS_L            = $AF0C44
=$af0c45				SP08_X_POS_H            = $AF0C45
=$af0c46				SP08_Y_POS_L            = $AF0C46
=$af0c47				SP08_Y_POS_H            = $AF0C47
=$af0c48				SP09_CONTROL_REG        = $AF0C48
=$af0c49				SP09_ADDY_PTR_L         = $AF0C49
=$af0c4a				SP09_ADDY_PTR_M         = $AF0C4A
=$af0c4b				SP09_ADDY_PTR_H         = $AF0C4B
=$af0c4c				SP09_X_POS_L            = $AF0C4C
=$af0c4d				SP09_X_POS_H            = $AF0C4D
=$af0c4e				SP09_Y_POS_L            = $AF0C4E
=$af0c4f				SP09_Y_POS_H            = $AF0C4F
=$af0c50				SP10_CONTROL_REG        = $AF0C50
=$af0c51				SP10_ADDY_PTR_L         = $AF0C51
=$af0c52				SP10_ADDY_PTR_M         = $AF0C52
=$af0c53				SP10_ADDY_PTR_H         = $AF0C53
=$af0c54				SP10_X_POS_L            = $AF0C54
=$af0c55				SP10_X_POS_H            = $AF0C55
=$af0c56				SP10_Y_POS_L            = $AF0C56
=$af0c57				SP10_Y_POS_H            = $AF0C57
=$af0c58				SP11_CONTROL_REG        = $AF0C58
=$af0c59				SP11_ADDY_PTR_L         = $AF0C59
=$af0c5a				SP11_ADDY_PTR_M         = $AF0C5A
=$af0c5b				SP11_ADDY_PTR_H         = $AF0C5B
=$af0c5c				SP11_X_POS_L            = $AF0C5C
=$af0c5d				SP11_X_POS_H            = $AF0C5D
=$af0c5e				SP11_Y_POS_L            = $AF0C5E
=$af0c5f				SP11_Y_POS_H            = $AF0C5F
=$af0c60				SP12_CONTROL_REG        = $AF0C60
=$af0c61				SP12_ADDY_PTR_L         = $AF0C61
=$af0c62				SP12_ADDY_PTR_M         = $AF0C62
=$af0c63				SP12_ADDY_PTR_H         = $AF0C63
=$af0c64				SP12_X_POS_L            = $AF0C64
=$af0c65				SP12_X_POS_H            = $AF0C65
=$af0c66				SP12_Y_POS_L            = $AF0C66
=$af0c67				SP12_Y_POS_H            = $AF0C67
=$af0c68				SP13_CONTROL_REG        = $AF0C68
=$af0c69				SP13_ADDY_PTR_L         = $AF0C69
=$af0c6a				SP13_ADDY_PTR_M         = $AF0C6A
=$af0c6b				SP13_ADDY_PTR_H         = $AF0C6B
=$af0c6c				SP13_X_POS_L            = $AF0C6C
=$af0c6d				SP13_X_POS_H            = $AF0C6D
=$af0c6e				SP13_Y_POS_L            = $AF0C6E
=$af0c6f				SP13_Y_POS_H            = $AF0C6F
=$af0c70				SP14_CONTROL_REG        = $AF0C70
=$af0c71				SP14_ADDY_PTR_L         = $AF0C71
=$af0c72				SP14_ADDY_PTR_M         = $AF0C72
=$af0c73				SP14_ADDY_PTR_H         = $AF0C73
=$af0c74				SP14_X_POS_L            = $AF0C74
=$af0c75				SP14_X_POS_H            = $AF0C75
=$af0c76				SP14_Y_POS_L            = $AF0C76
=$af0c77				SP14_Y_POS_H            = $AF0C77
=$af0c78				SP15_CONTROL_REG        = $AF0C78
=$af0c79				SP15_ADDY_PTR_L         = $AF0C79
=$af0c7a				SP15_ADDY_PTR_M         = $AF0C7A
=$af0c7b				SP15_ADDY_PTR_H         = $AF0C7B
=$af0c7c				SP15_X_POS_L            = $AF0C7C
=$af0c7d				SP15_X_POS_H            = $AF0C7D
=$af0c7e				SP15_Y_POS_L            = $AF0C7E
=$af0c7f				SP15_Y_POS_H            = $AF0C7F
=$af0c80				SP16_CONTROL_REG        = $AF0C80
=$af0c81				SP16_ADDY_PTR_L         = $AF0C81
=$af0c82				SP16_ADDY_PTR_M         = $AF0C82
=$af0c83				SP16_ADDY_PTR_H         = $AF0C83
=$af0c84				SP16_X_POS_L            = $AF0C84
=$af0c85				SP16_X_POS_H            = $AF0C85
=$af0c86				SP16_Y_POS_L            = $AF0C86
=$af0c87				SP16_Y_POS_H            = $AF0C87
=$af0c88				SP17_CONTROL_REG        = $AF0C88
=$af0c89				SP17_ADDY_PTR_L         = $AF0C89
=$af0c8a				SP17_ADDY_PTR_M         = $AF0C8A
=$af0c8b				SP17_ADDY_PTR_H         = $AF0C8B
=$af0c8c				SP17_X_POS_L            = $AF0C8C
=$af0c8d				SP17_X_POS_H            = $AF0C8D
=$af0c8e				SP17_Y_POS_L            = $AF0C8E
=$af0c8f				SP17_Y_POS_H            = $AF0C8F
=$af0c90				SP18_CONTROL_REG        = $AF0C90
=$af0c91				SP18_ADDY_PTR_L         = $AF0C91
=$af0c92				SP18_ADDY_PTR_M         = $AF0C92
=$af0c93				SP18_ADDY_PTR_H         = $AF0C93
=$af0c94				SP18_X_POS_L            = $AF0C94
=$af0c95				SP18_X_POS_H            = $AF0C95
=$af0c96				SP18_Y_POS_L            = $AF0C96
=$af0c97				SP18_Y_POS_H            = $AF0C97
=$af0c98				SP19_CONTROL_REG        = $AF0C98
=$af0c99				SP19_ADDY_PTR_L         = $AF0C99
=$af0c9a				SP19_ADDY_PTR_M         = $AF0C9A
=$af0c9b				SP19_ADDY_PTR_H         = $AF0C9B
=$af0c9c				SP19_X_POS_L            = $AF0C9C
=$af0c9d				SP19_X_POS_H            = $AF0C9D
=$af0c9e				SP19_Y_POS_L            = $AF0C9E
=$af0c9f				SP19_Y_POS_H            = $AF0C9F
=$af0ca0				SP20_CONTROL_REG        = $AF0CA0
=$af0ca1				SP20_ADDY_PTR_L         = $AF0CA1
=$af0ca2				SP20_ADDY_PTR_M         = $AF0CA2
=$af0ca3				SP20_ADDY_PTR_H         = $AF0CA3
=$af0ca4				SP20_X_POS_L            = $AF0CA4
=$af0ca5				SP20_X_POS_H            = $AF0CA5
=$af0ca6				SP20_Y_POS_L            = $AF0CA6
=$af0ca7				SP20_Y_POS_H            = $AF0CA7
=$af0ca8				SP21_CONTROL_REG        = $AF0CA8
=$af0ca9				SP21_ADDY_PTR_L         = $AF0CA9
=$af0caa				SP21_ADDY_PTR_M         = $AF0CAA
=$af0cab				SP21_ADDY_PTR_H         = $AF0CAB
=$af0cac				SP21_X_POS_L            = $AF0CAC
=$af0cad				SP21_X_POS_H            = $AF0CAD
=$af0cae				SP21_Y_POS_L            = $AF0CAE
=$af0caf				SP21_Y_POS_H            = $AF0CAF
=$af0cb0				SP22_CONTROL_REG        = $AF0CB0
=$af0cb1				SP22_ADDY_PTR_L         = $AF0CB1
=$af0cb2				SP22_ADDY_PTR_M         = $AF0CB2
=$af0cb3				SP22_ADDY_PTR_H         = $AF0CB3
=$af0cb4				SP22_X_POS_L            = $AF0CB4
=$af0cb5				SP22_X_POS_H            = $AF0CB5
=$af0cb6				SP22_Y_POS_L            = $AF0CB6
=$af0cb7				SP22_Y_POS_H            = $AF0CB7
=$af0cb8				SP23_CONTROL_REG        = $AF0CB8
=$af0cb9				SP23_ADDY_PTR_L         = $AF0CB9
=$af0cba				SP23_ADDY_PTR_M         = $AF0CBA
=$af0cbb				SP23_ADDY_PTR_H         = $AF0CBB
=$af0cbc				SP23_X_POS_L            = $AF0CBC
=$af0cbd				SP23_X_POS_H            = $AF0CBD
=$af0cbe				SP23_Y_POS_L            = $AF0CBE
=$af0cbf				SP23_Y_POS_H            = $AF0CBF
=$af0cc0				SP24_CONTROL_REG        = $AF0CC0
=$af0cc1				SP24_ADDY_PTR_L         = $AF0CC1
=$af0cc2				SP24_ADDY_PTR_M         = $AF0CC2
=$af0cc3				SP24_ADDY_PTR_H         = $AF0CC3
=$af0cc4				SP24_X_POS_L            = $AF0CC4
=$af0cc5				SP24_X_POS_H            = $AF0CC5
=$af0cc6				SP24_Y_POS_L            = $AF0CC6
=$af0cc7				SP24_Y_POS_H            = $AF0CC7
=$af0cc8				SP25_CONTROL_REG        = $AF0CC8
=$af0cc9				SP25_ADDY_PTR_L         = $AF0CC9
=$af0cca				SP25_ADDY_PTR_M         = $AF0CCA
=$af0ccb				SP25_ADDY_PTR_H         = $AF0CCB
=$af0ccc				SP25_X_POS_L            = $AF0CCC
=$af0ccd				SP25_X_POS_H            = $AF0CCD
=$af0cce				SP25_Y_POS_L            = $AF0CCE
=$af0ccf				SP25_Y_POS_H            = $AF0CCF
=$af0cd0				SP26_CONTROL_REG        = $AF0CD0
=$af0cd1				SP26_ADDY_PTR_L         = $AF0CD1
=$af0cd2				SP26_ADDY_PTR_M         = $AF0CD2
=$af0cd3				SP26_ADDY_PTR_H         = $AF0CD3
=$af0cd4				SP26_X_POS_L            = $AF0CD4
=$af0cd5				SP26_X_POS_H            = $AF0CD5
=$af0cd6				SP26_Y_POS_L            = $AF0CD6
=$af0cd7				SP26_Y_POS_H            = $AF0CD7
=$af0cd8				SP27_CONTROL_REG        = $AF0CD8
=$af0cd9				SP27_ADDY_PTR_L         = $AF0CD9
=$af0cda				SP27_ADDY_PTR_M         = $AF0CDA
=$af0cdb				SP27_ADDY_PTR_H         = $AF0CDB
=$af0cdc				SP27_X_POS_L            = $AF0CDC
=$af0cdd				SP27_X_POS_H            = $AF0CDD
=$af0cde				SP27_Y_POS_L            = $AF0CDE
=$af0cdf				SP27_Y_POS_H            = $AF0CDF
=$af0ce0				SP28_CONTROL_REG        = $AF0CE0
=$af0ce1				SP28_ADDY_PTR_L         = $AF0CE1
=$af0ce2				SP28_ADDY_PTR_M         = $AF0CE2
=$af0ce3				SP28_ADDY_PTR_H         = $AF0CE3
=$af0ce4				SP28_X_POS_L            = $AF0CE4
=$af0ce5				SP28_X_POS_H            = $AF0CE5
=$af0ce6				SP28_Y_POS_L            = $AF0CE6
=$af0ce7				SP28_Y_POS_H            = $AF0CE7
=$af0ce8				SP29_CONTROL_REG        = $AF0CE8
=$af0ce9				SP29_ADDY_PTR_L         = $AF0CE9
=$af0cea				SP29_ADDY_PTR_M         = $AF0CEA
=$af0ceb				SP29_ADDY_PTR_H         = $AF0CEB
=$af0cec				SP29_X_POS_L            = $AF0CEC
=$af0ced				SP29_X_POS_H            = $AF0CED
=$af0cee				SP29_Y_POS_L            = $AF0CEE
=$af0cef				SP29_Y_POS_H            = $AF0CEF
=$af0cf0				SP30_CONTROL_REG        = $AF0CF0
=$af0cf1				SP30_ADDY_PTR_L         = $AF0CF1
=$af0cf2				SP30_ADDY_PTR_M         = $AF0CF2
=$af0cf3				SP30_ADDY_PTR_H         = $AF0CF3
=$af0cf4				SP30_X_POS_L            = $AF0CF4
=$af0cf5				SP30_X_POS_H            = $AF0CF5
=$af0cf6				SP30_Y_POS_L            = $AF0CF6
=$af0cf7				SP30_Y_POS_H            = $AF0CF7
=$af0cf8				SP31_CONTROL_REG        = $AF0CF8
=$af0cf9				SP31_ADDY_PTR_L         = $AF0CF9
=$af0cfa				SP31_ADDY_PTR_M         = $AF0CFA
=$af0cfb				SP31_ADDY_PTR_H         = $AF0CFB
=$af0cfc				SP31_X_POS_L            = $AF0CFC
=$af0cfd				SP31_X_POS_H            = $AF0CFD
=$af0cfe				SP31_Y_POS_L            = $AF0CFE
=$af0cff				SP31_Y_POS_H            = $AF0CFF
=$af0d00				SP32_CONTROL_REG        = $AF0D00
=$af0d01				SP32_ADDY_PTR_L         = $AF0D01
=$af0d02				SP32_ADDY_PTR_M         = $AF0D02
=$af0d03				SP32_ADDY_PTR_H         = $AF0D03
=$af0d04				SP32_X_POS_L            = $AF0D04
=$af0d05				SP32_X_POS_H            = $AF0D05
=$af0d06				SP32_Y_POS_L            = $AF0D06
=$af0d07				SP32_Y_POS_H            = $AF0D07
=$af0d08				SP33_CONTROL_REG        = $AF0D08
=$af0d09				SP33_ADDY_PTR_L         = $AF0D09
=$af0d0a				SP33_ADDY_PTR_M         = $AF0D0A
=$af0d0b				SP33_ADDY_PTR_H         = $AF0D0B
=$af0d0c				SP33_X_POS_L            = $AF0D0C
=$af0d0d				SP33_X_POS_H            = $AF0D0D
=$af0d0e				SP33_Y_POS_L            = $AF0D0E
=$af0d0f				SP33_Y_POS_H            = $AF0D0F
=$af0d10				SP34_CONTROL_REG        = $AF0D10
=$af0d11				SP34_ADDY_PTR_L         = $AF0D11
=$af0d12				SP34_ADDY_PTR_M         = $AF0D12
=$af0d13				SP34_ADDY_PTR_H         = $AF0D13
=$af0d14				SP34_X_POS_L            = $AF0D14
=$af0d15				SP34_X_POS_H            = $AF0D15
=$af0d16				SP34_Y_POS_L            = $AF0D16
=$af0d17				SP34_Y_POS_H            = $AF0D17
=$af0d18				SP35_CONTROL_REG        = $AF0D18
=$af0d19				SP35_ADDY_PTR_L         = $AF0D19
=$af0d1a				SP35_ADDY_PTR_M         = $AF0D1A
=$af0d1b				SP35_ADDY_PTR_H         = $AF0D1B
=$af0d1c				SP35_X_POS_L            = $AF0D1C
=$af0d1d				SP35_X_POS_H            = $AF0D1D
=$af0d1e				SP35_Y_POS_L            = $AF0D1E
=$af0d1f				SP35_Y_POS_H            = $AF0D1F
=$af0d20				SP36_CONTROL_REG        = $AF0D20
=$af0d21				SP36_ADDY_PTR_L         = $AF0D21
=$af0d22				SP36_ADDY_PTR_M         = $AF0D22
=$af0d23				SP36_ADDY_PTR_H         = $AF0D23
=$af0d24				SP36_X_POS_L            = $AF0D24
=$af0d25				SP36_X_POS_H            = $AF0D25
=$af0d26				SP36_Y_POS_L            = $AF0D26
=$af0d27				SP36_Y_POS_H            = $AF0D27
=$af0d28				SP37_CONTROL_REG        = $AF0D28
=$af0d29				SP37_ADDY_PTR_L         = $AF0D29
=$af0d2a				SP37_ADDY_PTR_M         = $AF0D2A
=$af0d2b				SP37_ADDY_PTR_H         = $AF0D2B
=$af0d2c				SP37_X_POS_L            = $AF0D2C
=$af0d2d				SP37_X_POS_H            = $AF0D2D
=$af0d2e				SP37_Y_POS_L            = $AF0D2E
=$af0d2f				SP37_Y_POS_H            = $AF0D2F
=$af0d30				SP38_CONTROL_REG        = $AF0D30
=$af0d31				SP38_ADDY_PTR_L         = $AF0D31
=$af0d32				SP38_ADDY_PTR_M         = $AF0D32
=$af0d33				SP38_ADDY_PTR_H         = $AF0D33
=$af0d34				SP38_X_POS_L            = $AF0D34
=$af0d35				SP38_X_POS_H            = $AF0D35
=$af0d36				SP38_Y_POS_L            = $AF0D36
=$af0d37				SP38_Y_POS_H            = $AF0D37
=$af0d38				SP39_CONTROL_REG        = $AF0D38
=$af0d39				SP39_ADDY_PTR_L         = $AF0D39
=$af0d3a				SP39_ADDY_PTR_M         = $AF0D3A
=$af0d3b				SP39_ADDY_PTR_H         = $AF0D3B
=$af0d3c				SP39_X_POS_L            = $AF0D3C
=$af0d3d				SP39_X_POS_H            = $AF0D3D
=$af0d3e				SP39_Y_POS_L            = $AF0D3E
=$af0d3f				SP39_Y_POS_H            = $AF0D3F
=$af0d40				SP40_CONTROL_REG        = $AF0D40
=$af0d41				SP40_ADDY_PTR_L         = $AF0D41
=$af0d42				SP40_ADDY_PTR_M         = $AF0D42
=$af0d43				SP40_ADDY_PTR_H         = $AF0D43
=$af0d44				SP40_X_POS_L            = $AF0D44
=$af0d45				SP40_X_POS_H            = $AF0D45
=$af0d46				SP40_Y_POS_L            = $AF0D46
=$af0d47				SP40_Y_POS_H            = $AF0D47
=$af0d48				SP41_CONTROL_REG        = $AF0D48
=$af0d49				SP41_ADDY_PTR_L         = $AF0D49
=$af0d4a				SP41_ADDY_PTR_M         = $AF0D4A
=$af0d4b				SP41_ADDY_PTR_H         = $AF0D4B
=$af0d4c				SP41_X_POS_L            = $AF0D4C
=$af0d4d				SP41_X_POS_H            = $AF0D4D
=$af0d4e				SP41_Y_POS_L            = $AF0D4E
=$af0d4f				SP41_Y_POS_H            = $AF0D4F
=$af0d50				SP42_CONTROL_REG        = $AF0D50
=$af0d51				SP42_ADDY_PTR_L         = $AF0D51
=$af0d52				SP42_ADDY_PTR_M         = $AF0D52
=$af0d53				SP42_ADDY_PTR_H         = $AF0D53
=$af0d54				SP42_X_POS_L            = $AF0D54
=$af0d55				SP42_X_POS_H            = $AF0D55
=$af0d56				SP42_Y_POS_L            = $AF0D56
=$af0d57				SP42_Y_POS_H            = $AF0D57
=$af0d58				SP43_CONTROL_REG        = $AF0D58
=$af0d59				SP43_ADDY_PTR_L         = $AF0D59
=$af0d5a				SP43_ADDY_PTR_M         = $AF0D5A
=$af0d5b				SP43_ADDY_PTR_H         = $AF0D5B
=$af0d5c				SP43_X_POS_L            = $AF0D5C
=$af0d5d				SP43_X_POS_H            = $AF0D5D
=$af0d5e				SP43_Y_POS_L            = $AF0D5E
=$af0d5f				SP43_Y_POS_H            = $AF0D5F
=$af0d60				SP44_CONTROL_REG        = $AF0D60
=$af0d61				SP44_ADDY_PTR_L         = $AF0D61
=$af0d62				SP44_ADDY_PTR_M         = $AF0D62
=$af0d63				SP44_ADDY_PTR_H         = $AF0D63
=$af0d64				SP44_X_POS_L            = $AF0D64
=$af0d65				SP44_X_POS_H            = $AF0D65
=$af0d66				SP44_Y_POS_L            = $AF0D66
=$af0d67				SP44_Y_POS_H            = $AF0D67
=$af0d68				SP45_CONTROL_REG        = $AF0D68
=$af0d69				SP45_ADDY_PTR_L         = $AF0D69
=$af0d6a				SP45_ADDY_PTR_M         = $AF0D6A
=$af0d6b				SP45_ADDY_PTR_H         = $AF0D6B
=$af0d6c				SP45_X_POS_L            = $AF0D6C
=$af0d6d				SP45_X_POS_H            = $AF0D6D
=$af0d6e				SP45_Y_POS_L            = $AF0D6E
=$af0d6f				SP45_Y_POS_H            = $AF0D6F
=$af0d70				SP46_CONTROL_REG        = $AF0D70
=$af0d71				SP46_ADDY_PTR_L         = $AF0D71
=$af0d72				SP46_ADDY_PTR_M         = $AF0D72
=$af0d73				SP46_ADDY_PTR_H         = $AF0D73
=$af0d74				SP46_X_POS_L            = $AF0D74
=$af0d75				SP46_X_POS_H            = $AF0D75
=$af0d76				SP46_Y_POS_L            = $AF0D76
=$af0d77				SP46_Y_POS_H            = $AF0D77
=$af0d78				SP47_CONTROL_REG        = $AF0D78
=$af0d79				SP47_ADDY_PTR_L         = $AF0D79
=$af0d7a				SP47_ADDY_PTR_M         = $AF0D7A
=$af0d7b				SP47_ADDY_PTR_H         = $AF0D7B
=$af0d7c				SP47_X_POS_L            = $AF0D7C
=$af0d7d				SP47_X_POS_H            = $AF0D7D
=$af0d7e				SP47_Y_POS_L            = $AF0D7E
=$af0d7f				SP47_Y_POS_H            = $AF0D7F
=$af0d80				SP48_CONTROL_REG        = $AF0D80
=$af0d81				SP48_ADDY_PTR_L         = $AF0D81
=$af0d82				SP48_ADDY_PTR_M         = $AF0D82
=$af0d83				SP48_ADDY_PTR_H         = $AF0D83
=$af0d84				SP48_X_POS_L            = $AF0D84
=$af0d85				SP48_X_POS_H            = $AF0D85
=$af0d86				SP48_Y_POS_L            = $AF0D86
=$af0d87				SP48_Y_POS_H            = $AF0D87
=$af0d88				SP49_CONTROL_REG        = $AF0D88
=$af0d89				SP49_ADDY_PTR_L         = $AF0D89
=$af0d8a				SP49_ADDY_PTR_M         = $AF0D8A
=$af0d8b				SP49_ADDY_PTR_H         = $AF0D8B
=$af0d8c				SP49_X_POS_L            = $AF0D8C
=$af0d8d				SP49_X_POS_H            = $AF0D8D
=$af0d8e				SP49_Y_POS_L            = $AF0D8E
=$af0d8f				SP49_Y_POS_H            = $AF0D8F
=$af0d90				SP50_CONTROL_REG        = $AF0D90
=$af0d91				SP50_ADDY_PTR_L         = $AF0D91
=$af0d92				SP50_ADDY_PTR_M         = $AF0D92
=$af0d93				SP50_ADDY_PTR_H         = $AF0D93
=$af0d94				SP50_X_POS_L            = $AF0D94
=$af0d95				SP50_X_POS_H            = $AF0D95
=$af0d96				SP50_Y_POS_L            = $AF0D96
=$af0d97				SP50_Y_POS_H            = $AF0D97
=$af0d98				SP51_CONTROL_REG        = $AF0D98
=$af0d99				SP51_ADDY_PTR_L         = $AF0D99
=$af0d9a				SP51_ADDY_PTR_M         = $AF0D9A
=$af0d9b				SP51_ADDY_PTR_H         = $AF0D9B
=$af0d9c				SP51_X_POS_L            = $AF0D9C
=$af0d9d				SP51_X_POS_H            = $AF0D9D
=$af0d9e				SP51_Y_POS_L            = $AF0D9E
=$af0d9f				SP51_Y_POS_H            = $AF0D9F
=$af0da0				SP52_CONTROL_REG        = $AF0DA0
=$af0da1				SP52_ADDY_PTR_L         = $AF0DA1
=$af0da2				SP52_ADDY_PTR_M         = $AF0DA2
=$af0da3				SP52_ADDY_PTR_H         = $AF0DA3
=$af0da4				SP52_X_POS_L            = $AF0DA4
=$af0da5				SP52_X_POS_H            = $AF0DA5
=$af0da6				SP52_Y_POS_L            = $AF0DA6
=$af0da7				SP52_Y_POS_H            = $AF0DA7
=$af0da8				SP53_CONTROL_REG        = $AF0DA8
=$af0da9				SP53_ADDY_PTR_L         = $AF0DA9
=$af0daa				SP53_ADDY_PTR_M         = $AF0DAA
=$af0dab				SP53_ADDY_PTR_H         = $AF0DAB
=$af0dac				SP53_X_POS_L            = $AF0DAC
=$af0dad				SP53_X_POS_H            = $AF0DAD
=$af0dae				SP53_Y_POS_L            = $AF0DAE
=$af0daf				SP53_Y_POS_H            = $AF0DAF
=$af0db0				SP54_CONTROL_REG        = $AF0DB0
=$af0db1				SP54_ADDY_PTR_L         = $AF0DB1
=$af0db2				SP54_ADDY_PTR_M         = $AF0DB2
=$af0db3				SP54_ADDY_PTR_H         = $AF0DB3
=$af0db4				SP54_X_POS_L            = $AF0DB4
=$af0db5				SP54_X_POS_H            = $AF0DB5
=$af0db6				SP54_Y_POS_L            = $AF0DB6
=$af0db7				SP54_Y_POS_H            = $AF0DB7
=$af0db8				SP55_CONTROL_REG        = $AF0DB8
=$af0db9				SP55_ADDY_PTR_L         = $AF0DB9
=$af0dba				SP55_ADDY_PTR_M         = $AF0DBA
=$af0dbb				SP55_ADDY_PTR_H         = $AF0DBB
=$af0dbc				SP55_X_POS_L            = $AF0DBC
=$af0dbd				SP55_X_POS_H            = $AF0DBD
=$af0dbe				SP55_Y_POS_L            = $AF0DBE
=$af0dbf				SP55_Y_POS_H            = $AF0DBF
=$af0dc0				SP56_CONTROL_REG        = $AF0DC0
=$af0dc1				SP56_ADDY_PTR_L         = $AF0DC1
=$af0dc2				SP56_ADDY_PTR_M         = $AF0DC2
=$af0dc3				SP56_ADDY_PTR_H         = $AF0DC3
=$af0dc4				SP56_X_POS_L            = $AF0DC4
=$af0dc5				SP56_X_POS_H            = $AF0DC5
=$af0dc6				SP56_Y_POS_L            = $AF0DC6
=$af0dc7				SP56_Y_POS_H            = $AF0DC7
=$af0dc8				SP57_CONTROL_REG        = $AF0DC8
=$af0dc9				SP57_ADDY_PTR_L         = $AF0DC9
=$af0dca				SP57_ADDY_PTR_M         = $AF0DCA
=$af0dcb				SP57_ADDY_PTR_H         = $AF0DCB
=$af0dcc				SP57_X_POS_L            = $AF0DCC
=$af0dcd				SP57_X_POS_H            = $AF0DCD
=$af0dce				SP57_Y_POS_L            = $AF0DCE
=$af0dcf				SP57_Y_POS_H            = $AF0DCF
=$af0dd0				SP58_CONTROL_REG        = $AF0DD0
=$af0dd1				SP58_ADDY_PTR_L         = $AF0DD1
=$af0dd2				SP58_ADDY_PTR_M         = $AF0DD2
=$af0dd3				SP58_ADDY_PTR_H         = $AF0DD3
=$af0dd4				SP58_X_POS_L            = $AF0DD4
=$af0dd5				SP58_X_POS_H            = $AF0DD5
=$af0dd6				SP58_Y_POS_L            = $AF0DD6
=$af0dd7				SP58_Y_POS_H            = $AF0DD7
=$af0dd8				SP59_CONTROL_REG        = $AF0DD8
=$af0dd9				SP59_ADDY_PTR_L         = $AF0DD9
=$af0dda				SP59_ADDY_PTR_M         = $AF0DDA
=$af0ddb				SP59_ADDY_PTR_H         = $AF0DDB
=$af0ddc				SP59_X_POS_L            = $AF0DDC
=$af0ddd				SP59_X_POS_H            = $AF0DDD
=$af0dde				SP59_Y_POS_L            = $AF0DDE
=$af0ddf				SP59_Y_POS_H            = $AF0DDF
=$af0de0				SP60_CONTROL_REG        = $AF0DE0
=$af0de1				SP60_ADDY_PTR_L         = $AF0DE1
=$af0de2				SP60_ADDY_PTR_M         = $AF0DE2
=$af0de3				SP60_ADDY_PTR_H         = $AF0DE3
=$af0de4				SP60_X_POS_L            = $AF0DE4
=$af0de5				SP60_X_POS_H            = $AF0DE5
=$af0de6				SP60_Y_POS_L            = $AF0DE6
=$af0de7				SP60_Y_POS_H            = $AF0DE7
=$af0de8				SP61_CONTROL_REG        = $AF0DE8
=$af0de9				SP61_ADDY_PTR_L         = $AF0DE9
=$af0dea				SP61_ADDY_PTR_M         = $AF0DEA
=$af0deb				SP61_ADDY_PTR_H         = $AF0DEB
=$af0dec				SP61_X_POS_L            = $AF0DEC
=$af0ded				SP61_X_POS_H            = $AF0DED
=$af0dee				SP61_Y_POS_L            = $AF0DEE
=$af0def				SP61_Y_POS_H            = $AF0DEF
=$af0df0				SP62_CONTROL_REG        = $AF0DF0
=$af0df1				SP62_ADDY_PTR_L         = $AF0DF1
=$af0df2				SP62_ADDY_PTR_M         = $AF0DF2
=$af0df3				SP62_ADDY_PTR_H         = $AF0DF3
=$af0df4				SP62_X_POS_L            = $AF0DF4
=$af0df5				SP62_X_POS_H            = $AF0DF5
=$af0df6				SP62_Y_POS_L            = $AF0DF6
=$af0df7				SP62_Y_POS_H            = $AF0DF7
=$af0df8				SP63_CONTROL_REG        = $AF0DF8
=$af0df9				SP63_ADDY_PTR_L         = $AF0DF9
=$af0dfa				SP63_ADDY_PTR_M         = $AF0DFA
=$af0dfb				SP63_ADDY_PTR_H         = $AF0DFB
=$af0dfc				SP63_X_POS_L            = $AF0DFC
=$af0dfd				SP63_X_POS_H            = $AF0DFD
=$af0dfe				SP63_Y_POS_L            = $AF0DFE
=$af0dff				SP63_Y_POS_H            = $AF0DFF

;******  Return to file: src\C256/vicky_def.s


;******  Return to file: src\C256/mmap_c256.s

=$00					BASIC_BANK = $00            ; Memory bank for default purposes
=$004c00				IOBUF = $004C00             ; A buffer for I/O operations
=$004d00				ARRIDXBUF = $004D00         ; The array index buffer used for array references
=$004e00				TEMPBUF = $004E00           ; Temporary buffer for string processing, etc.
=$004f00				INPUTBUF = $004F00          ; Starting address of the line input buffer (one page)
=$005000				RETURN_BOT = $005000        ; Starting address of the return stack
=$005fff				RETURN_TOP = $005FFF        ; Ending address of the return stack
=$006000				ARGUMENT_BOT = $006000      ; Starting address of the argument stack
=$006fff				ARGUMENT_TOP = $006FFF      ; Ending address of the argument stack
=$007000				OPERATOR_BOT = $007000      ; Starting address of the operator stack
=$007fff				OPERATOR_TOP = $007FFF      ; Ending address of the operator stack
=$b00000				VRAM = $B00000              ; Start of video RAM
=$010000				LOADBLOCK = $010000         ; File loading will start here
=$360000				BASIC_BOT := $360000         ; Starting point for BASIC programs
=$37ffff				HEAP_TOP := $37FFFF          ; Starting point of the heap

;******  Return to file: src\memorymap.s

=$00ffe6				VBRK = $00FFE6          ; Vector for the native-mode BRK vector
=$3ad000				DATA_BLOCK = *
=$000800				GLOBAL_VARS = *
>0800					BIP         .dword ?    ; Pointer to the current byte in the current BASIC program
>0804					BIPPREV     .dword ?    ; Pointer to the previous bytein the current BASIC program
>0808					INDEX       .dword ?    ; A temporary pointer
>080c					SCRATCH     .dword ?    ; A temporary scratch variable
>0810					SCRATCH2    .dword ?    ; A temporary scratch variable
>0814					            .word  ?	; Need a few more bits for BCD conversion
>0816					STRPTR      .dword ?    ; A temporary pointer for strings
>081a					CURLINE     .dword ?    ; Pointer to the current input line needing tokenization
>081e					CURTOKLEN   .byte ?     ; Length of the text of the current token
>081f					ARGUMENTSP  .word ?     ; Pointer to the top of the argument stack
>0821					OPERATORSP  .word ?     ; Pointer to the top of the operator stack
>0823					ARGUMENT1   .dword ?    ; Argument 1 for expression calculations
>0827					ARGTYPE1    .byte ?     ; Type code for argument 1 (integer, float, string)
>0828					SIGN1       .byte ?     ; Temporary sign marker for argument 1
>0829					ARGUMENT2   .dword ?    ; Argument 2 for expression calculations
>082d					ARGTYPE2    .byte ?     ; Type code for argument 2 (integer, float, string)
>082e					SIGN2       .byte ?     ; Temporary sign marker for argument 1
>082f					JMP16PTR    .word ?     ; Pointer for 16-bit indirect jumps (within BASIC816's code base)
>0831					GOSUBDEPTH  .word ?     ; Number of GOSUBs on the stack
>0833					RETURNSP    .word ?     ; Pointer to the top of the return stack
>0835					SKIPNEST    .byte ?     ; Flag to indicate if token seeking should respect nesting (MSB set if so)
>0836					NESTING     .byte ?     ; Counter of the depth of lexical nesting for FOR/NEXT, DO/LOOP
>0837					TARGETTOK   .byte ?     ; When searching for a token, TARGETTOK is the token to find
>0838					DATABIP     .dword ?    ; Pointer to the next data element for READ statements
>083c					DATALINE    .dword ?    ; Pointer to the current line for a DATA statement
>0840					SAVEBIP     .dword ?    ; Spot to save BIP temporarily
>0844					SAVELINE    .dword ?    ; Spot to save CURLINE temporarily
=$000848				MONITOR_VARS = *
>0848					MCMDADDR    .long ?     ;3 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
>084b					MCMP_TEXT   .long ?     ;3 Bytes Address of symbol being evaluated for COMPARE routine
>084e					MCMP_LEN    .word ?     ;2 Bytes Length of symbol being evaluated for COMPARE routine
>0850					MCMD        .long ?     ;3 Bytes Address of the current command/function string
>0853					MCMD_LEN    .word ?     ;2 Bytes Length of the current command/function string
>0855					MARG1       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command
>0859					MARG2       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>085d					MARG3       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0861					MARG4       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0865					MARG5       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0869					MARG6       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>086d					MARG7       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0871					MARG8       .dword ?    ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
>0875					MARG9       .dword ?    ;4 Bytes First command argument.
>0879					MARG_LEN    .byte ?     ;1 Byte count of the number of arguments passed
>087a					MCURSOR     .dword ?    ;4 Bytes Pointer to the current memory location for disassembly, memory dump, etc.
>087e					MLINEBUF    .fill 17    ;17 Byte buffer for dumping memory (TODO: could be moved to a general string scratch area)
>088f					MCOUNT      .long ?     ;2 Byte counter
>0892					MTEMP       .dword ?    ;4 Bytes of temporary space
>0896					MCPUSTAT    .byte ?     ;1 Byte to represent what the disassembler thinks the processor MX bits are
>0897					MADDR_MODE  .byte ?     ;1 Byte address mode found by the assembler
>0898					MPARSEDNUM  .dword ?    ;4 Bytes to store a parsed number
>089c					MMNEMONIC   .word ?     ;2 Byte address of mnemonic found by the assembler
>089e					MTEMPPTR    .dword ?    ;4 Byte temporary pointer
>08a2					MJUMPINST   .byte ?     ;1 Byte JSL opcode
>08a3					MJUMPADDR   .long ?     ;3 Byte address for JSL
=$000823				MANTISSA1 = ARGUMENT1
=$000826				EXPONENT1 = ARGUMENT1+3

;******  Return to file: src\basic816.s


;******  Processing file: src\macros.s


;******  Return to file: src\basic816.s

.3a0000	5c 6e 8a 3a	jmp $3a8a6e	COLDBOOT        JML START               ; Entry point to boot up BASIC from scratch
.3a0004	5c 80 70 3a	jmp $3a7080	MONITOR         JML IMONITOR            ; Entry point to the machine language monitor
.3a0008	5c 72 27 3a	jmp $3a2772	READLINE        JML IREADLINE           ; Wait for the user to enter a line of text (for programming input)
.3a000c	5c ba 02 3a	jmp $3a02ba	SCRCOPYLINE     JML ISCRCPYLINE         ; Copy the line on the screen the user just input to INPUTBUF
.3a0010	5c 58 00 3a	jmp $3a0058	INPUTLINE       JML IINPUTLINE          ; Read a single line of text from the user, and copy it to TEMPBUF (for INPUT statement)
.3a0014	5c b8 00 3a	jmp $3a00b8	GETKEY          JML IGETKEY             ; Wait for a keypress by the user and return the ASCII code in A
.3a0018	5c 0f 04 3a	jmp $3a040f	PRINTC          JML IPRINTC             ; Print the character in A to the console
.3a001c	5c 5e 02 3a	jmp $3a025e	SHOWCURSOR      JML ISHOWCURSOR         ; Set cursor visibility: A=0, hide... A<>0, show.
.3a0020	5c 79 02 3a	jmp $3a0279	CURSORXY        JML ICURSORXY           ; Set the position of the cursor to (X, Y)
.3a0024	5c 80 02 3a	jmp $3a0280	CLSCREEN        JML ICLSCREEN           ; Clear the screen

;******  Processing file: src\bios.s


;******  Processing file: src\membuffers.s

>08a6					OBUFFER     .long ?     ; Pointer to the current text memory buffer for output
>08a9					OBUFFSIZE   .word ?     ; Maximum size of output text memory buffer
>08ab					OBUFFIDX    .word ?     ; Index into the current output buffer
>08ad					IBUFFER     .long ?     ; Pointer to the current text memory buffer for input
>08b0					IBUFFSIZE   .word ?     ; Number of bytes written to the buffer
>08b2					IBUFFIDX    .word ?     ; Index into the current input buffer (next available character)
.3a0028					OBUFF_PUTC
.3a0028	0b		phd		                PHD
.3a0029	08		php		                PHP
.3a002a	08		php		            PHP
.3a002b	c2 20		rep #$20	            REP #$20
.3a002d	48		pha		            PHA
.3a002e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0031	5b		tcd		            TCD
.3a0032	68		pla		            PLA
.3a0033	28		plp		            PLP
.3a0034	e2 20		sep #$20	            SEP #$20
.3a0036	85 b5		sta $08b5	                STA SAVE_A
.3a0038	c2 20		rep #$20	            REP #$20
.3a003a	a5 a6		lda $08a6	                LDA OBUFFER
.3a003c	d0 06		bne $3a0044	                BNE has_buffer
.3a003e	e2 20		sep #$20	            SEP #$20
.3a0040	a5 a8		lda $08a8	                LDA OBUFFER+2
.3a0042	f0 11		beq $3a0055	                BEQ done
.3a0044					has_buffer
.3a0044	c2 10		rep #$10	            REP #$10
.3a0046	a4 ab		ldy $08ab	                LDY OBUFFIDX        ; Check to make sure there is room
.3a0048	c4 a9		cpy $08a9	                CPY OBUFFSIZE
.3a004a	f0 09		beq $3a0055	                BEQ done            ; If not, exit silently
.3a004c	e2 20		sep #$20	            SEP #$20
.3a004e	a5 b5		lda $08b5	                LDA SAVE_A
.3a0050	97 a6		sta [$08a6],y	                STA [OBUFFER],Y     ; Write the character to the buffer
.3a0052	c8		iny		                INY                 ; Increment the index
.3a0053	84 ab		sty $08ab	                STY OBUFFIDX
.3a0055	28		plp		done            PLP
.3a0056	2b		pld		                PLD
.3a0057	60		rts		            RTS

;******  Return to file: src\bios.s


;******  Processing file: src\C256/io_c256.s


;******  Processing file: src\C256/kernel_c256.s

=$00104c				FK_GETCHW           = $00104c ; Get a character from the input channel. Waits until data received. A=0 and Carry=1 if no data is wating
=$001018				FK_PUTC             = $001018 ; Print a character to the currently selected channel
=$00101c				FK_PUTS             = $00101C ; Print a string to the currently selected channel
=$001080				FK_PRINTAH          = $001080 ; Prints hex value in A. Printed value is 2 wide if M flag is 1, 4 wide if M=0
=$001084				FK_LOCATE           = $001084 ; Reposition the cursor to row Y column X
=$001078				FK_IPRINTH          = $001078 ; Print a HEX string
=$00103c				FK_SETOUT           = $00103c ; Select an output channel
=$00112c				FK_SETSIZES         = $00112C ; Set the text screen size variables based on the border and screen resolution.
=$0010f0				FK_OPEN             = $0010F0 ; open a file for reading/writing/creating
=$0010f4				FK_CREATE           = $0010F4 ; create a new file
=$0010f8				FK_CLOSE            = $0010F8 ; close a file (make sure last cluster is written)
=$0010fc				FK_WRITE            = $0010FC ; write the current cluster to the file
=$001100				FK_READ             = $001100 ; read the next cluster from the file
=$001104				FK_DELETE           = $001104 ; delete a file / directory
=$001108				FK_DIROPEN          = $001108 ; open a directory and seek the first directory entry
=$00110c				FK_DIRNEXT          = $00110C ; seek to the next directory of an open directory
=$001110				FK_DIRREAD          = $001110 ; Read the directory entry for the specified file
=$001114				FK_DIRWRITE         = $001114 ; Write any changes in the current directory cluster back to the drive
=$001118				FK_LOAD             = $001118 ; load a binary file into memory, supports multiple file formats
=$00111c				FK_SAVE             = $00111C ; Save memory to a binary file
=$001124				FK_RUN              = $001124 ; Load and run an executable binary file
=$001130				FK_COPY             = $001130 ; Copy a file
=$001120				FK_CMDBLOCK         = $001120 ; Send a command to a block device
=$00113c				FK_TESTBREAK        = $00113C ; Check if BREAK was pressed recently by the user (C is set if true, clear if false)
=$001028				FK_GETSCANCODE      = $001028 ; Get the next scancode from the keyboard (A = scancode, 0 if none available)
=$001144				FK_READVRAM         = $001144 ; Read a byte from video RAM at B:X
=0					CHAN_CONSOLE = 0
=1					CHAN_COM1 = 1
=2					CHAN_COM2 = 2

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/RTC_inc.s

=$af0800				RTC_SEC       = $AF0800 ;Seconds Register
=$af0801				RTC_SEC_ALARM = $AF0801 ;Seconds Alarm Register
=$af0802				RTC_MIN       = $AF0802 ;Minutes Register
=$af0803				RTC_MIN_ALARM = $AF0803 ;Minutes Alarm Register
=$af0804				RTC_HRS       = $AF0804 ;Hours Register
=$af0805				RTC_HRS_ALARM = $AF0805 ;Hours Alarm Register
=$af0806				RTC_DAY       = $AF0806 ;Day Register
=$af0807				RTC_DAY_ALARM = $AF0807 ;Day Alarm Register
=$af0808				RTC_DOW       = $AF0808 ;Day of Week Register
=$af0809				RTC_MONTH     = $AF0809 ;Month Register
=$af080a				RTC_YEAR      = $AF080A ;Year Register
=$af080b				RTC_RATES     = $AF080B ;Rates Register
=$af080c				RTC_ENABLE    = $AF080C ;Enables Register
=$af080d				RTC_FLAGS     = $AF080D ;Flags Register
=$af080e				RTC_CTRL      = $AF080E ;Control Register
=$af080f				RTC_CENTURY   = $AF080F ;Century Register

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/keyboard.s


;******  Processing file: src\C256/keyboard_def.s

=$af1064				STATUS_PORT 	        =	$AF1064
=$af1060				KBD_OUT_BUF 	        =	$AF1060
=$af1060				KBD_INPT_BUF	        = $AF1060
=$af1064				KBD_CMD_BUF		        = $AF1064
=$af1060				KBD_DATA_BUF	        = $AF1060
=$af1060				PORT_A			          =	$AF1060
=$af1061				PORT_B			          =	$AF1061
=$01					OUT_BUF_FULL  =	$01
=$02					INPT_BUF_FULL	=	$02
=$04					SYS_FLAG		  =	$04
=$08					CMD_DATA		  =	$08
=$10					KEYBD_INH     =	$10
=$20					TRANS_TMOUT	  =	$20
=$40					RCV_TMOUT		  =	$40
=$80					PARITY_EVEN		=	$80
=$10					INH_KEYBOARD	=	$10
=$ae					KBD_ENA			  =	$AE
=$ad					KBD_DIS			  =	$AD
=$f1					KB_MENU			  =	$F1
=$f4					KB_ENABLE		  =	$F4
=$f7					KB_MAKEBREAK  =	$F7
=$fe					KB_ECHO			  =	$FE
=$ff					KB_RESET		  =	$FF
=$ed					KB_LED_CMD		=	$ED
=$aa					KB_OK			    =	$AA
=$fa					KB_ACK			  =	$FA
=$ff					KB_OVERRUN		=	$FF
=$fe					KB_RESEND		  =	$FE
=$f0					KB_BREAK		  =	$F0
=$10					KB_FA			    =	$10
=$20					KB_FE			    =	$20
=$40					KB_PR_LED		  =	$40
=$01					KB_SCROLL_LOCK      = $01
=$02					KB_NUM_LOCK         = $02
=$04					KB_CAPS_LOCK        = $04
=2					ANSI_IN_INS = 2     ; ANSI input code for INSERT
=3					ANSI_IN_DEL = 3     ; ANSI input code for DELETE
=24					ANSI_IN_F12 = 24    ; ANSI input code for F12
=8					ANSI_IN_CTRL = 8    ; ANSI input modifier flag for CTRL

;******  Return to file: src\C256/keyboard.s

.3a0058					IINPUTLINE
.3a0058	08		php		                PHP
.3a0059	c2 10		rep #$10	            REP #$10
.3a005b	e2 20		sep #$20	            SEP #$20
.3a005d	a9 01		lda #$01	                LDA #1              ; Show the cursor
.3a005f	20 1c 00	jsr $3a001c	            JSR SHOWCURSOR
.3a0062	a2 00 00	ldx #$0000	                LDX #0
.3a0065	a9 00		lda #$00	                LDA #0
.3a0067	9f 00 4c 00	sta $004c00,x	zero_loop       STA @lIOBUF,X
.3a006b	e8		inx		                INX
.3a006c	e0 00 01	cpx #$0100	                CPX #$100
.3a006f	d0 f6		bne $3a0067	                BNE zero_loop
.3a0071	a2 00 00	ldx #$0000	                LDX #0
.3a0074					getchar
.3a0074	20 14 00	jsr $3a0014	            JSR GETKEY
.3a0077	c9 0d		cmp #$0d	                CMP #CHAR_CR        ; Got a CR?
.3a0079	d0 03		bne $3a007e	                BNE not_cr
.3a007b	4c b1 00	jmp $3a00b1	                JMP endofline       ; Yes: we're done
.3a007e					not_cr
.3a007e	c9 08		cmp #$08	not_right       CMP #CHAR_BS        ; Is it a backspace?
.3a0080	d0 1a		bne $3a009c	                BNE not_bs
.3a0082	e0 00 00	cpx #$0000	                CPX #0              ; Are we at the beginning of the line?
.3a0085	f0 ed		beq $3a0074	                BEQ getchar         ; yes: ignore the backspace
.3a0087	da		phx		                PHX                 ; Save the cursor position
.3a0088	bf 01 4c 00	lda $004c01,x	clr_loop        LDA @lIOBUF+1,X     ; Get the character above
.3a008c	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the current position
.3a0090	f0 06		beq $3a0098	                BEQ done_clr        ; If we copied a NUL, we're done copying
.3a0092	e8		inx		                INX                 ; Otherwise, keep copying down
.3a0093	e0 ff 00	cpx #$00ff	                CPX #$FF            ; Until we're at the end of the buffer
.3a0096	d0 f0		bne $3a0088	                BNE clr_loop
.3a0098	fa		plx		done_clr        PLX                 ; Restore the cursor position
.3a0099	ca		dex		                DEX                 ; No: move the cursor left
.3a009a	80 0e		bra $3a00aa	                BRA print_bs        ; And print the backspace
.3a009c	c9 20		cmp #$20	not_bs          CMP #$20            ; Is it in range 00 -- 1F?
.3a009e	90 d4		bcc $3a0074	                BLT getchar         ; Yes: ignore it
.3a00a0	9f 00 4c 00	sta $004c00,x	                STA @lIOBUF,X       ; Save it to the input buffer
.3a00a4	e8		inx		                INX                 ; Move the cursor forward
.3a00a5					echo
.3a00a5	20 18 00	jsr $3a0018	            JSR PRINTC
.3a00a8	80 ca		bra $3a0074	                BRA getchar         ; And get another...
.3a00aa	a9 08		lda #$08	print_bs        LDA #CHAR_BS        ; Backspace character...
.3a00ac	20 18 00	jsr $3a0018	            JSR PRINTC
.3a00af	80 c3		bra $3a0074	                BRA getchar         ; And get another...
.3a00b1	a9 00		lda #$00	endofline       LDA #0              ; Hide the cursor
.3a00b3	20 1c 00	jsr $3a001c	            JSR SHOWCURSOR
.3a00b6	28		plp		                PLP
.3a00b7	60		rts		            RTS
.3a00b8					IGETKEY
.3a00b8	da		phx		                PHX
.3a00b9	5a		phy		                PHY
.3a00ba	8b		phb		                PHB
.3a00bb	0b		phd		                PHD
.3a00bc	08		php		                PHP
.3a00bd	22 4c 10 00	jsl $00104c	                JSL FK_GETCHW
.3a00c1	28		plp		                PLP
.3a00c2	2b		pld		                PLD
.3a00c3	ab		plb		                PLB
.3a00c4	7a		ply		                PLY
.3a00c5	fa		plx		                PLX
.3a00c6	60		rts		            RTS
=0					GK_ST_INIT = 0      ; GETKEYE state: initial
=1					GK_ST_ESC = 1       ; GETKEYE state: ESC seen
=2					GK_ST_CSI = 2       ; GETKEYE state: CSI "ESC[" seen
=3					GK_ST_CODE = 3      ; GETKEYE state: We're at the command code in the sequence
=4					GK_ST_MODS = 4      ; GETKEYE state: We're at the modifier code in the sequence
.3a00c7					SEND_ANSI
.3a00c7	08		php		                PHP
.3a00c8	e2 30		sep #$30	            SEP #$30
.3a00ca	48		pha		                PHA
.3a00cb	a9 1b		lda #$1b	                LDA #CHAR_ESC           ; Print ESC
.3a00cd	20 18 00	jsr $3a0018	            JSR PRINTC
.3a00d0	a9 5b		lda #$5b	                LDA #'['                ; Print [
.3a00d2	20 18 00	jsr $3a0018	            JSR PRINTC
.3a00d5	68		pla		                PLA                     ; Print the command code
.3a00d6	20 18 00	jsr $3a0018	            JSR PRINTC
.3a00d9	28		plp		                PLP
.3a00da	60		rts		            RTS
.3a00db					GETKEYE
.3a00db	0b		phd		                PHD
.3a00dc	8b		phb		                PHB
.3a00dd	08		php		                PHP
.3a00de	08		php		            PHP
.3a00df	e2 20		sep #$20	            SEP #$20
.3a00e1	48		pha		            PHA
.3a00e2	a9 00		lda #$00	            LDA #0
.3a00e4	48		pha		            PHA
.3a00e5	ab		plb		            PLB
.3a00e6	68		pla		            PLA
.3a00e7	28		plp		            PLP
.3a00e8	08		php		            PHP
.3a00e9	c2 20		rep #$20	            REP #$20
.3a00eb	48		pha		            PHA
.3a00ec	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a00ef	5b		tcd		            TCD
.3a00f0	68		pla		            PLA
.3a00f1	28		plp		            PLP
.3a00f2					locals
>0001					l_character     .byte ?                 ; The character returned by the input stream
>0002					l_state         .byte ?                 ; Current state of the input parser
>0003					l_code          .byte ?                 ; Code number for any escaped input sequence
>0004					l_modifiers     .byte ?                 ; Modifier bit field for any escaped input sequence
.3a00f2	c2 20		rep #$20	            REP #$20
.3a00f4	3b		tsc		            TSC
.3a00f5	38		sec		            SEC
.3a00f6	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.3a00f9	1b		tcs		            TCS
.3a00fa	e2 20		sep #$20	            SEP #$20
.3a00fc	a9 00		lda #$00	get_reset       LDA #0                  ; Initialize state, code, and modifiers
.3a00fe	83 02		sta $02,s	                STA l_state
.3a0100	83 03		sta $03,s	                STA l_code
.3a0102	83 04		sta $04,s	                STA l_modifiers
.3a0104					loop
.3a0104	20 14 00	jsr $3a0014	            JSR GETKEY
.3a0107	c9 00		cmp #$00	                CMP #0                  ; Is it 0?
.3a0109	f0 f9		beq $3a0104	                BEQ loop                ; Yes: keep waiting
.3a010b	83 01		sta $01,s	                STA l_character         ; Save the character
.3a010d	a3 02		lda $02,s	                LDA l_state             ; What is the current state?
.3a010f	d0 35		bne $3a0146	                BNE chk_st_esc
.3a0111	a3 01		lda $01,s	                LDA l_character         ; Get the character back
.3a0113	c9 08		cmp #$08	                CMP #CHAR_BS            ; Is it a backspace?
.3a0115	d0 0a		bne $3a0121	                BNE not_bs
.3a0117	20 18 00	jsr $3a0018	            JSR PRINTC
.3a011a	a9 50		lda #$50	                LDA #'P'
.3a011c	20 c7 00	jsr $3a00c7	            JSR SEND_ANSI
.3a011f	80 e3		bra $3a0104	                BRA loop                ; And keep waiting for a keypress
.3a0121	c9 0d		cmp #$0d	not_bs          CMP #CHAR_CR            ; Is it a carriage return?
.3a0123	f0 0a		beq $3a012f	                BEQ send                ; Yes: print and return it
.3a0125	c9 1b		cmp #$1b	                CMP #CHAR_ESC           ; Is it ESC?
.3a0127	d0 06		bne $3a012f	                BNE send                ; No: just print it out
.3a0129	a9 01		lda #$01	                LDA #GK_ST_ESC          ; Yes: move to the ESC state
.3a012b	83 02		sta $02,s	                STA l_state
.3a012d	80 d5		bra $3a0104	                BRA loop                ; And get the next character in the sequence
.3a012f					send
.3a012f	20 18 00	jsr $3a0018	            JSR PRINTC
.3a0132	a3 01		lda $01,s	done            LDA l_character         ; Save the character so we can return it
.3a0134	85 0c		sta $080c	                STA SCRATCH
.3a0136	c2 20		rep #$20	            REP #$20
.3a0138	3b		tsc		            TSC
.3a0139	18		clc		            CLC
.3a013a	69 04 00	adc #$0004	            ADC #SIZE(locals)
.3a013d	1b		tcs		            TCS
.3a013e	e2 20		sep #$20	            SEP #$20
.3a0140	a5 0c		lda $080c	                LDA SCRATCH             ; Restore the character we're returning
.3a0142	28		plp		                PLP
.3a0143	2b		pld		                PLD
.3a0144	ab		plb		                PLB
.3a0145	60		rts		            RTS
.3a0146	c9 01		cmp #$01	chk_st_esc      CMP #GK_ST_ESC          ; Are we in the ESC state?
.3a0148	d0 10		bne $3a015a	                BNE chk_st_csi          ; No: check to see if we're in CSI state
.3a014a	a3 01		lda $01,s	                LDA l_character         ; Get the character
.3a014c	c9 5b		cmp #$5b	                CMP #'['                ; Is it "["?
.3a014e	f0 03		beq $3a0153	                BEQ go_st_csi           ; Yes: go to the CSI state
.3a0150	82 a9 ff	brl $3a00fc	                BRL get_reset           ; Reset the state machine and keep reading characters
.3a0153	a9 02		lda #$02	go_st_csi       LDA #GK_ST_CSI          ; Yes: move to the CSI state
.3a0155	83 02		sta $02,s	                STA l_state
.3a0157	82 aa ff	brl $3a0104	                BRL loop
.3a015a	c9 02		cmp #$02	chk_st_csi      CMP #GK_ST_CSI          ; Are we in the CSI state?
.3a015c	d0 29		bne $3a0187	                BNE chk_st_code         ; No: check to see if we're in the code state
.3a015e	a3 01		lda $01,s	                LDA l_character         ; Check the character
.3a0160	c9 41		cmp #$41	                CMP #'A'                ; Is it in 'A'..'D'?
.3a0162	90 0c		bcc $3a0170	                BLT not_letter
.3a0164	c9 45		cmp #$45	                CMP #'D'+1
.3a0166	b0 08		bcs $3a0170	                BGE not_letter
.3a0168	a3 01		lda $01,s	                LDA l_character         ; Yes: it's a cursor key, send the sequence to the screen
.3a016a	20 c7 00	jsr $3a00c7	            JSR SEND_ANSI
.3a016d	82 8c ff	brl $3a00fc	                BRL get_reset           ; Reset the state machine and keep reading characters
.3a0170	c9 30		cmp #$30	not_letter      CMP #'0'                ; Is it in range '0'..'9'?
.3a0172	90 10		bcc $3a0184	                BLT not_csi_digit
.3a0174	c9 3a		cmp #$3a	                CMP #'9'+1
.3a0176	b0 0c		bcs $3a0184	                BGE not_csi_digit       ; No: handle it being invalid
.3a0178	38		sec		                SEC                     ; Yes: convert to a value
.3a0179	e9 30		sbc #$30	                SBC #'0'
.3a017b	83 03		sta $03,s	                STA l_code              ; And save it to the code variable
.3a017d	a9 03		lda #$03	                LDA #GK_ST_CODE         ; Move to the CODE state
.3a017f	83 02		sta $02,s	                STA l_state
.3a0181	82 80 ff	brl $3a0104	                BRL loop
.3a0184	82 75 ff	brl $3a00fc	not_csi_digit   BRL get_reset           ; Bad sequence: reset and keep reading characters
.3a0187	c9 03		cmp #$03	chk_st_code     CMP #GK_ST_CODE         ; Is it the CODE state?
.3a0189	d0 41		bne $3a01cc	                BNE chk_st_mods         ; No: check to see if it's MODIFIERS
.3a018b	a3 01		lda $01,s	                LDA l_character         ; Check the character
.3a018d	c9 30		cmp #$30	                CMP #'0'                ; Is it in the range '0'..'9'
.3a018f	90 29		bcc $3a01ba	                BLT not_digits_2
.3a0191	c9 3a		cmp #$3a	                CMP #'9'+1
.3a0193	b0 25		bcs $3a01ba	                BGE not_digits_2
.3a0195	a3 03		lda $03,s	                LDA l_code              ; Multiply l_code by 2
.3a0197	8f 00 01 00	sta $000100	                STA @l UNSIGNED_MULT_A_LO
.3a019b	a9 00		lda #$00	                LDA #0
.3a019d	8f 01 01 00	sta $000101	                STA @l UNSIGNED_MULT_A_HI
.3a01a1	8f 03 01 00	sta $000103	                STA @l UNSIGNED_MULT_B_HI
.3a01a5	a9 0a		lda #$0a	                LDA #10
.3a01a7	8f 02 01 00	sta $000102	                STA @l UNSIGNED_MULT_B_LO
.3a01ab	a3 01		lda $01,s	                LDA l_character         ; Convert the digit to a number
.3a01ad	38		sec		                SEC
.3a01ae	e9 30		sbc #$30	                SBC #'0'
.3a01b0	18		clc		                CLC                     ; And add to l_code
.3a01b1	6f 04 01 00	adc $000104	                ADC @l UNSIGNED_MULT_AL_LO
.3a01b5	83 03		sta $03,s	                STA l_code
.3a01b7	82 4a ff	brl $3a0104	                BRL loop                ; And keep processing the sequence
.3a01ba	c9 3b		cmp #$3b	not_digits_2    CMP #';'                ; Is it the semicolon?
.3a01bc	d0 07		bne $3a01c5	                BNE not_semi
.3a01be	a9 04		lda #$04	                LDA #GK_ST_MODS         ; Yes: Move to the MODIFIERS state
.3a01c0	83 02		sta $02,s	                STA l_state
.3a01c2	82 3f ff	brl $3a0104	                BRL loop
.3a01c5	c9 7e		cmp #$7e	not_semi        CMP #'~'                ; No: Is it the tilda?
.3a01c7	f0 40		beq $3a0209	                BEQ end_sequence        ; Yes: we've gotten the end of the sequence
.3a01c9	82 30 ff	brl $3a00fc	                BRL get_reset           ; No: we've got a bad sequence... for now just reset and keep looping
.3a01cc	c9 04		cmp #$04	chk_st_mods     CMP #GK_ST_MODS         ; Are we in the MODIFIERS state?
.3a01ce	f0 03		beq $3a01d3	                BEQ do_mods
.3a01d0	82 5f ff	brl $3a0132	                BRL done                ; No: we're done
.3a01d3	a3 01		lda $01,s	do_mods         LDA l_character         ; Check the character
.3a01d5	c9 30		cmp #$30	                CMP #'0'                ; Is it in the range '0'..'9'
.3a01d7	90 29		bcc $3a0202	                BLT not_digits_3
.3a01d9	c9 3a		cmp #$3a	                CMP #'9'+1
.3a01db	b0 25		bcs $3a0202	                BGE not_digits_3
.3a01dd	a3 04		lda $04,s	                LDA l_modifiers         ; Multiply l_modifiers by 2
.3a01df	8f 00 01 00	sta $000100	                STA @l UNSIGNED_MULT_A_LO
.3a01e3	a9 00		lda #$00	                LDA #0
.3a01e5	8f 01 01 00	sta $000101	                STA @l UNSIGNED_MULT_A_HI
.3a01e9	8f 03 01 00	sta $000103	                STA @l UNSIGNED_MULT_B_HI
.3a01ed	a9 0a		lda #$0a	                LDA #10
.3a01ef	8f 02 01 00	sta $000102	                STA @l UNSIGNED_MULT_B_LO
.3a01f3	a3 01		lda $01,s	                LDA l_character         ; Convert the digit to a number
.3a01f5	38		sec		                SEC
.3a01f6	e9 30		sbc #$30	                SBC #'0'
.3a01f8	18		clc		                CLC                     ; And add to l_modifiers
.3a01f9	6f 04 01 00	adc $000104	                ADC @l UNSIGNED_MULT_AL_LO
.3a01fd	83 04		sta $04,s	                STA l_modifiers
.3a01ff	82 02 ff	brl $3a0104	                BRL loop                ; And keep processing the sequence
.3a0202	c9 7e		cmp #$7e	not_digits_3    CMP #'~'                ; No: Is it the tilda?
.3a0204	f0 03		beq $3a0209	                BEQ end_sequence        ; Yes: we've gotten the end of the sequence
.3a0206	82 f3 fe	brl $3a00fc	                BRL get_reset           ; No: we've got a bad sequence... for now just reset and keep looping
.3a0209	a3 03		lda $03,s	end_sequence    LDA l_code              ; Get the code
.3a020b	c9 02		cmp #$02	                CMP #ANSI_IN_INS        ; Is it INSERT?
.3a020d	f0 0b		beq $3a021a	                BEQ do_ins              ; Yes: process the insert
.3a020f	c9 03		cmp #$03	                CMP #ANSI_IN_DEL        ; Is it DELETE?
.3a0211	f0 0b		beq $3a021e	                BEQ do_del              ; Yes: process the delete
.3a0213	c9 18		cmp #$18	                CMP #ANSI_IN_F12        ; Is it F12?
.3a0215	f0 0f		beq $3a0226	                BEQ do_f12              ; Yes: process the F12 key
.3a0217	82 e2 fe	brl $3a00fc	                BRL get_reset           ; Code is not one we handle, just return
.3a021a	a9 40		lda #$40	do_ins          LDA #'@'                ; Send the ANSI ICH command
.3a021c	80 02		bra $3a0220	                BRA snd_ansi
.3a021e	a9 50		lda #$50	do_del          LDA #'P'                ; Send the ANSI DCH command
.3a0220					snd_ansi
.3a0220	20 c7 00	jsr $3a00c7	            JSR SEND_ANSI
.3a0223	82 d6 fe	brl $3a00fc	                BRL get_reset           ; Reset and keep getting characters
.3a0226	a5 d2		lda $08d2	do_f12          LDA STATE               ; Check the state
.3a0228	d0 10		bne $3a023a	                BNE skip_f12            ; If we're running, ignore the F12
.3a022a	a3 04		lda $04,s	                LDA l_modifiers         ; Check to make sure it's CTRL-F12
.3a022c	c9 08		cmp #$08	                CMP #ANSI_IN_CTRL       ; Modifier flag for CTRL
.3a022e	d0 0a		bne $3a023a	                BNE skip_f12
.3a0230	a9 1b		lda #$1b	                LDA #CHAR_ESC           ; Send ESC_ (APC) to show the credits
.3a0232	20 18 00	jsr $3a0018	            JSR PRINTC
.3a0235	a9 5f		lda #$5f	                LDA #'_'
.3a0237	20 18 00	jsr $3a0018	            JSR PRINTC
.3a023a	82 bf fe	brl $3a00fc	skip_f12        BRL get_reset           ; And reset the state machine

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/screen.s

.3a023d					ENSURETEXT
.3a023d	08		php		            PHP
.3a023e	e2 20		sep #$20	            SEP #$20
.3a0240	af 00 00 af	lda $af0000	            LDA @l MASTER_CTRL_REG_L            ; Get the current display mode
.3a0244	89 3c		bit #$3c	            BIT #Mstr_Ctrl_Graph_Mode_En | Mstr_Ctrl_Bitmap_En | Mstr_Ctrl_TileMap_En | Mstr_Ctrl_Sprite_En
.3a0246	f0 08		beq $3a0250	            BEQ textonly                        ; If not, make sure text is enabled
.3a0248					overlay
.3a0248	09 03		ora #$03	            ORA #Mstr_Ctrl_Text_Mode_En | Mstr_Ctrl_Text_Overlay
.3a024a	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.3a024e	80 0c		bra $3a025c	            BRA done
.3a0250					textonly
.3a0250	09 01		ora #$01	            ORA #Mstr_Ctrl_Text_Mode_En
.3a0252	8f 00 00 af	sta $af0000	            STA @l MASTER_CTRL_REG_L
.3a0256	a9 00		lda #$00	            LDA #CHAN_CONSOLE                   ; Make sure we're writing to the main screen
.3a0258	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.3a025c	28		plp		done        PLP
.3a025d	60		rts		            RTS
.3a025e					ISHOWCURSOR
.3a025e	08		php		            PHP
.3a025f	e2 20		sep #$20	            SEP #$20
.3a0261	c9 00		cmp #$00	            CMP #0
.3a0263	f0 08		beq $3a026d	            BEQ hide
.3a0265	af 10 00 af	lda $af0010	show        LDA @lVKY_TXT_CURSOR_CTRL_REG
.3a0269	09 01		ora #$01	            ORA #Vky_Cursor_Enable
.3a026b	80 06		bra $3a0273	            BRA setit
.3a026d	af 10 00 af	lda $af0010	hide        LDA @lVKY_TXT_CURSOR_CTRL_REG
.3a0271	29 fe		and #$fe	            AND #~Vky_Cursor_Enable
.3a0273	8f 10 00 af	sta $af0010	setit       STA @lVKY_TXT_CURSOR_CTRL_REG
.3a0277	28		plp		            PLP
.3a0278	60		rts		            RTS
.3a0279					ICURSORXY
.3a0279	08		php		            PHP
.3a027a	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.3a027e	28		plp		            PLP
.3a027f	60		rts		            RTS
.3a0280					ICLSCREEN
.3a0280	48		pha		            PHA
.3a0281	da		phx		            PHX
.3a0282	5a		phy		            PHY
.3a0283	0b		phd		            PHD
.3a0284	08		php		            PHP
.3a0285	e2 20		sep #$20	            SEP #$20
.3a0287	c2 10		rep #$10	            REP #$10
.3a0289	a2 00 00	ldx #$0000	            LDX #0
.3a028c	a9 20		lda #$20	loop        LDA #$20
.3a028e	9f 00 a0 af	sta $afa000,x	            STA @lCS_TEXT_MEM_PTR,X     ; Write a space in the text cell
.3a0292	af 1e 00 00	lda $00001e	            LDA @lCURCOLOR
.3a0296	9f 00 c0 af	sta $afc000,x	            STA @lCS_COLOR_MEM_PTR,X    ; Set the color to green on black
.3a029a	e8		inx		            INX                         ; Move to the next character cell
.3a029b	e0 00 20	cpx #$2000	            CPX #$2000
.3a029e	d0 ec		bne $3a028c	            BNE loop
.3a02a0	08		php		            PHP
.3a02a1	c2 20		rep #$20	            REP #$20
.3a02a3	48		pha		            PHA
.3a02a4	a9 00 00	lda #$0000	            LDA #0
.3a02a7	5b		tcd		            TCD
.3a02a8	68		pla		            PLA
.3a02a9	28		plp		            PLP
.3a02aa	a2 00 00	ldx #$0000	            LDX #0                      ; Set cursor to upper-left corner
.3a02ad	a0 00 00	ldy #$0000	            LDY #0
.3a02b0	22 84 10 00	jsl $001084	            JSL FK_LOCATE
.3a02b4	28		plp		            PLP
.3a02b5	2b		pld		            PLD
.3a02b6	7a		ply		            PLY
.3a02b7	fa		plx		            PLX
.3a02b8	68		pla		            PLA
.3a02b9	60		rts		            RTS
.3a02ba					ISCRCPYLINE
.3a02ba	da		phx		            PHX
.3a02bb	5a		phy		            PHY
.3a02bc	0b		phd		            PHD
.3a02bd	08		php		            PHP
.3a02be	08		php		            PHP
.3a02bf	c2 20		rep #$20	            REP #$20
.3a02c1	48		pha		            PHA
.3a02c2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a02c5	5b		tcd		            TCD
.3a02c6	68		pla		            PLA
.3a02c7	28		plp		            PLP
.3a02c8	c2 30		rep #$30	            REP #$30
.3a02ca	af 0c 00 00	lda $00000c	            LDA @l SCREENBEGIN      ; Set INDEX to the first byte of the text screen
.3a02ce	85 08		sta $0808	            STA INDEX
.3a02d0	e2 20		sep #$20	            SEP #$20
.3a02d2	af 0e 00 00	lda $00000e	            LDA @l SCREENBEGIN+2
.3a02d6	c2 20		rep #$20	            REP #$20
.3a02d8	29 ff 00	and #$00ff	            AND #$00FF
.3a02db	85 0a		sta $080a	            STA INDEX+2
.3a02dd	af 11 00 00	lda $000011	            LDA @l COLS_PER_LINE    ; Calculate the offset to the current line
.3a02e1	8f 08 01 00	sta $000108	            STA @l M1_OPERAND_A
.3a02e5	af 1c 00 00	lda $00001c	            LDA @l CURSORY
.3a02e9	3a		dec a		            DEC A
.3a02ea	8f 0a 01 00	sta $00010a	            STA @l M1_OPERAND_B
.3a02ee	18		clc		            CLC                     ; And add it to INDEX
.3a02ef	a5 08		lda $0808	            LDA INDEX
.3a02f1	6f 0c 01 00	adc $00010c	            ADC @l M1_RESULT
.3a02f5	85 08		sta $0808	            STA INDEX
.3a02f7	a5 0a		lda $080a	            LDA INDEX+2
.3a02f9	69 00 00	adc #$0000	            ADC #0
.3a02fc	85 0a		sta $080a	            STA INDEX+2
.3a02fe	e2 20		sep #$20	            SEP #$20
.3a0300	af 0f 00 00	lda $00000f	            LDA @l COLS_VISIBLE
.3a0304	85 8f		sta $088f	            STA MCOUNT
.3a0306	a0 00 00	ldy #$0000	            LDY #0
.3a0309	a2 00 00	ldx #$0000	            LDX #0
.3a030c	b7 08		lda [$0808],y	copy_loop   LDA [INDEX],Y           ; Copy a byte from the screen to the input buffer
.3a030e	9f 00 4f 00	sta $004f00,x	            STA @l INPUTBUF,X
.3a0312	e8		inx		            INX
.3a0313	c8		iny		            INY
.3a0314	c4 8f		cpy $088f	            CPY MCOUNT
.3a0316	d0 f4		bne $3a030c	            BNE copy_loop
.3a0318	af 0f 00 00	lda $00000f	            LDA @l COLS_VISIBLE     ; Starting from the end of the line...
.3a031c	3a		dec a		            DEC A
.3a031d	aa		tax		            TAX
.3a031e	bf 00 4f 00	lda $004f00,x	trim_loop   LDA @l INPUTBUF,X       ; Replace spaces at the end with NULLs
.3a0322	c9 20		cmp #$20	            CMP #CHAR_SP
.3a0324	d0 09		bne $3a032f	            BNE done
.3a0326	a9 00		lda #$00	            LDA #0
.3a0328	9f 00 4f 00	sta $004f00,x	            STA @l INPUTBUF,X
.3a032c	ca		dex		            DEX
.3a032d	10 ef		bpl $3a031e	            BPL trim_loop
.3a032f	28		plp		done        PLP
.3a0330	2b		pld		            PLD
.3a0331	7a		ply		            PLY
.3a0332	fa		plx		            PLX
.3a0333	60		rts		            RTS

;******  Return to file: src\C256/io_c256.s


;******  Processing file: src\C256/gabe_defs.s

=$afe880				GABE_MSTR_CTRL      = $AFE880
=$01					GABE_CTRL_PWR_LED   = $01     ; Controls the LED in the Front of the case (Next to the reset button)
=$02					GABE_CTRL_SDC_LED   = $02     ; Controls the LED in the Front of the Case (Next to SDCard)
=$04					GABE_CTRL_STS_LED0  = $04     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$08					GABE_CTRL_STS_LED1  = $08     ; Control Status LED0 (General Use) - C256 Foenix U Only
=$10					GABE_CTRL_BUZZER    = $10     ; Controls the Buzzer
=$80					GABE_CTRL_WRM_RST   = $80     ; Warm Reset (needs to Setup other registers)
=$afe881				GABE_LED_FLASH_CTRL = $AFE881  ; Flashing LED Control
=$01					GABE_LED0_FLASH_CTRL = $01     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$02					GABE_LED1_FLASH_CTRL = $02     ; 0- Automatic Flash 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED1 to manually control)
=$10					GABE_LD0_FLASH_FRQ0   = $10     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$20					GABE_LD0_FLASH_FRQ1   = $20     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$40					GABE_LD1_FLASH_FRQ0   = $40     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$80					GABE_LD1_FLASH_FRQ1   = $80     ; 1 - Bypass Flash Timer (Use GABE_CTRL_STS_LED0 to manually control)
=$afe882				GABE_RST_AUTH0      = $AFE882 ; Must Contain the BYTE $AD for Reset to Activate
=$afe883				GABE_RST_AUTH1      = $AFE883 ; Must Contain the BYTE $DE for Reset to Activate
=$afe884				GABE_RNG_DAT_LO     = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_DAT_HI     = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe884				GABE_RNG_SEED_LO    = $AFE884 ; Low Part of 16Bit RNG Generator
=$afe885				GABE_RNG_SEED_HI    = $AFE885 ; Hi Part of 16Bit RNG Generator
=$afe886				GABE_RNG_STAT       = $AFE886 ;
=$80					GABE_RNG_LFSR_DONE  = $80     ; indicates that Output = SEED Database
=$afe886				GABE_RNG_CTRL       = $AFE886 ;
=$01					GABE_RNG_CTRL_EN    = $01     ; Enable the LFSR BLOCK_LEN
=$02					GABE_RNG_CTRL_DV    = $02     ; After Setting the Seed Value, Toggle that Bit for it be registered
=$afe887				GABE_SYS_STAT       = $AFE887 ;
=$01					GABE_SYS_STAT_MID0  = $01     ; Machine ID -- LSB
=$02					GABE_SYS_STAT_MID1  = $02     ; Machine ID --
=$04					GABE_SYS_STAT_MID2  = $04     ; Machine ID -- MSB
=$10					GABE_SYS_STAT_EXP   = $10     ; if Zero, there is an Expansion Card Preset
=$40					GABE_SYS_STAT_CPUA  = $40     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$80					GABE_SYS_STAT_CPUX  = $80     ; Indicates the (8bit/16bit) Size of the Accumulator - Not Implemented
=$afe88a				GABE_SUBVERSION_LO  = $AFE88A
=$afe88b				GABE_SUBVERSION_HI  = $AFE88B
=$afe88c				GABE_VERSION_LO     = $AFE88C
=$afe88d				GABE_VERSION_HI     = $AFE88D
=$afe88e				GABE_MODEL_LO       = $AFE88E
=$afe88f				GABE_MODEL_HI       = $AFE88F

;******  Return to file: src\C256/io_c256.s

=32					BORDER_WIDTH = 32               ; The width of the border (when it is on)
=72					TEXT_COLS_WB = 72               ; Number of columns of text with the border enabled
=52					TEXT_ROWS_WB = 52               ; Number of rows of text with the border enabled
=80					TEXT_COLS_WOB = 80              ; Number of columns of text with no border enabled
=60					TEXT_ROWS_WOB = 60              ; Number of rows of text with no border enabled
.3a0334					INITIO
.3a0334	e2 20		sep #$20	            SEP #$20
.3a0336	20 69 03	jsr $3a0369	            JSR INITRNG
.3a0339	a2 00 00	ldx #$0000	            LDX #0              ; Clear all the sprite control shadow registers
.3a033c	a9 00		lda #$00	            LDA #0
.3a033e	9f 18 f0 3a	sta $3af018,x	sp_loop     STA GS_SP_CONTROL,X
.3a0342	e8		inx		            INX
.3a0343	e0 40 00	cpx #$0040	            CPX #SP_MAX
.3a0346	d0 f6		bne $3a033e	            BNE sp_loop
.3a0348	a9 80		lda #$80	            LDA #DEV_SCREEN
.3a034a	8f b4 08 00	sta $0008b4	            STA @lBCONSOLE
.3a034e	e2 20		sep #$20	            SEP #$20
.3a0350	a9 00		lda #$00	            LDA #0                  ; Clear the lock key flags
.3a0352	8f 89 0f 00	sta $000f89	            STA @lKEYBOARD_LOCKS
.3a0356	a9 00		lda #$00	            LDA #0
.3a0358	8f 00 02 af	sta $af0200	            STA @l TL0_CONTROL_REG
.3a035c	8f 0c 02 af	sta $af020c	            STA @l TL1_CONTROL_REG
.3a0360	8f 18 02 af	sta $af0218	            STA @l TL2_CONTROL_REG
.3a0364	8f 24 02 af	sta $af0224	            STA @l TL3_CONTROL_REG
.3a0368					done
.3a0368	60		rts		            RTS
.3a0369					INITRNG
.3a0369	08		php		            PHP
.3a036a	e2 20		sep #$20	            SEP #$20
.3a036c	af 0e 08 af	lda $af080e	            LDA @l RTC_CTRL         ; Pause updates to the clock registers
.3a0370	09 08		ora #$08	            ORA #%00001000
.3a0372	8f 0e 08 af	sta $af080e	            STA @l RTC_CTRL
.3a0376	af 00 08 af	lda $af0800	            LDA @l RTC_SEC          ; Set the random number generator seed
.3a037a	8f 84 e8 af	sta $afe884	            STA @l GABE_RNG_SEED_LO
.3a037e	af 02 08 af	lda $af0802	            LDA @l RTC_MIN
.3a0382	8f 85 e8 af	sta $afe885	            STA @l GABE_RNG_SEED_HI
.3a0386	a9 03		lda #$03	            LDA #GABE_RNG_CTRL_DV | GABE_RNG_CTRL_EN
.3a0388	8f 86 e8 af	sta $afe886	            STA @l GABE_RNG_CTRL    ; Load the seed into the RNG
.3a038c	af 0e 08 af	lda $af080e	            LDA @l RTC_CTRL         ; Re-enable updates to the clock registers
.3a0390	29 f7		and #$f7	            AND #%11110111
.3a0392	8f 0e 08 af	sta $af080e	            STA @l RTC_CTRL
.3a0396	ea		nop		            NOP                     ; Give the RNG some time... not sure if needed, really
.3a0397	ea		nop		            NOP
.3a0398	ea		nop		            NOP
.3a0399	a9 01		lda #$01	            LDA #GABE_RNG_CTRL_EN   ; Turn on the random number genertator
.3a039b	8f 86 e8 af	sta $afe886	            STA @l GABE_RNG_CTRL
.3a039f	28		plp		            PLP
.3a03a0	60		rts		            RTS
.3a03a1					SCREEN_PUTC
.3a03a1	08		php		            PHP
.3a03a2	e2 20		sep #$20	            SEP #$20
.3a03a4	48		pha		            PHA
.3a03a5	48		pha		            PHA
.3a03a6	a9 00		lda #$00	            LDA #CHAN_CONSOLE       ; Switch to the console device
.3a03a8	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.3a03ac	68		pla		            PLA
.3a03ad	22 18 10 00	jsl $001018	            JSL FK_PUTC
.3a03b1	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.3a03b5	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.3a03b7	d0 f8		bne $3a03b1	            BNE loop                ; Yes: wait until it's released
.3a03b9	68		pla		            PLA
.3a03ba	28		plp		            PLP
.3a03bb	60		rts		            RTS
.3a03bc					UART_PUTC
.3a03bc	08		php		            PHP
.3a03bd	e2 20		sep #$20	            SEP #$20
.3a03bf	48		pha		            PHA
.3a03c0	48		pha		            PHA
.3a03c1	a9 01		lda #$01	            LDA #CHAN_COM1          ; Switch to COM1
.3a03c3	22 3c 10 00	jsl $00103c	            JSL FK_SETOUT
.3a03c7	68		pla		            PLA
.3a03c8	22 18 10 00	jsl $001018	            JSL FK_PUTC
.3a03cc	af 89 0f 00	lda $000f89	loop        LDA @lKEYBOARD_LOCKS    ; Check the status of the lock keys
.3a03d0	29 01		and #$01	            AND #KB_SCROLL_LOCK     ; Is Scroll Lock pressed?
.3a03d2	d0 f8		bne $3a03cc	            BNE loop                ; Yes: wait until it's released
.3a03d4	68		pla		            PLA
.3a03d5	28		plp		            PLP
.3a03d6	60		rts		            RTS
.3a03d7					PRINTCR
.3a03d7	08		php		            PHP
.3a03d8	c2 20		rep #$20	            REP #$20
.3a03da	48		pha		            PHA
.3a03db	e2 20		sep #$20	            SEP #$20
.3a03dd	a9 0d		lda #$0d	            LDA #CHAR_CR
.3a03df	20 18 00	jsr $3a0018	            JSR PRINTC
.3a03e2	c2 20		rep #$20	            REP #$20
.3a03e4	68		pla		            PLA
.3a03e5	28		plp		            PLP
.3a03e6	60		rts		            RTS
.3a03e7					PRINTH
.3a03e7	08		php		            PHP
.3a03e8	22 78 10 00	jsl $001078	            JSL FK_IPRINTH
.3a03ec	28		plp		            PLP
.3a03ed	60		rts		            RTS

;******  Return to file: src\bios.s

=10					LINES_PER_PAGE = 10     ; The number of lines to print on a page before pausing
=$80					DEV_SCREEN = $80        ; Use the screen and keyboard for the console device
=$40					DEV_UART = $40          ; Use UART for console device
=$20					DEV_BUFFER = $20        ; Use the current text memory buffer for output or input
>08b4					BCONSOLE    .byte ?     ; Device for BASIC console
>08b5					SAVE_A      .byte ?     ; Save spot for the A register
>08b6					LINECOUNT   .byte ?     ; Counter for new lines to support pagination
.3a03ee					PAGINATE
.3a03ee	08		php		            PHP
.3a03ef	0b		phd		            PHD
.3a03f0	08		php		            PHP
.3a03f1	c2 20		rep #$20	            REP #$20
.3a03f3	48		pha		            PHA
.3a03f4	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a03f7	5b		tcd		            TCD
.3a03f8	68		pla		            PLA
.3a03f9	28		plp		            PLP
.3a03fa	e2 20		sep #$20	            SEP #$20
.3a03fc	a5 b6		lda $08b6	            LDA LINECOUNT           ; Check the line count
.3a03fe	1a		inc a		            INC A
.3a03ff	85 b6		sta $08b6	            STA LINECOUNT
.3a0401	cf 13 00 00	cmp $000013	            CMP @l LINES_VISIBLE
.3a0405	90 05		bcc $3a040c	            BLT done                ; If < limit, just return
.3a0407	20 14 00	jsr $3a0014	            JSR GETKEY
.3a040a	64 b6		stz $08b6	            STZ LINECOUNT           ; And reset the line count
.3a040c	2b		pld		done        PLD
.3a040d	28		plp		            PLP
.3a040e	60		rts		            RTS
.3a040f					IPRINTC
.3a040f	da		phx		            PHX
.3a0410	5a		phy		            PHY
.3a0411	0b		phd		            PHD
.3a0412	08		php		            PHP
.3a0413	08		php		            PHP
.3a0414	c2 20		rep #$20	            REP #$20
.3a0416	48		pha		            PHA
.3a0417	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a041a	5b		tcd		            TCD
.3a041b	68		pla		            PLA
.3a041c	28		plp		            PLP
.3a041d	e2 20		sep #$20	            SEP #$20
.3a041f	c2 10		rep #$10	            REP #$10
.3a0421	8f b5 08 00	sta $0008b5	            STA @lSAVE_A
.3a0425	af b4 08 00	lda $0008b4	chk_out     LDA @lBCONSOLE      ; Check to see if we should send to an output buffer
.3a0429	29 20		and #$20	            AND #DEV_BUFFER
.3a042b	f0 07		beq $3a0434	            BEQ check_scrn      ; No... move on to the hardware screen
.3a042d	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.3a0431	20 28 00	jsr $3a0028	            JSR OBUFF_PUTC
.3a0434	af b4 08 00	lda $0008b4	check_scrn  LDA @lBCONSOLE
.3a0438	29 80		and #$80	            AND #DEV_SCREEN     ; Check to see if the screen is selected
.3a043a	f0 07		beq $3a0443	            BEQ send_uart
.3a043c	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.3a0440	20 a1 03	jsr $3a03a1	            JSR SCREEN_PUTC
.3a0443	af b4 08 00	lda $0008b4	send_uart   LDA @lBCONSOLE
.3a0447	29 40		and #$40	            AND #DEV_UART       ; Check to see if the UART is active
.3a0449	f0 14		beq $3a045f	            BEQ done
.3a044b	af b5 08 00	lda $0008b5	            LDA @lSAVE_A
.3a044f	20 bc 03	jsr $3a03bc	            JSR UART_PUTC
.3a0452	af b5 08 00	lda $0008b5	            LDA @lSAVE_A        ; If sending a CR to the serial port
.3a0456	c9 0d		cmp #$0d	            CMP #CHAR_CR
.3a0458	d0 05		bne $3a045f	            BNE done
.3a045a	a9 0a		lda #$0a	            LDA #CHAR_LF        ; Send a linefeed after
.3a045c	20 bc 03	jsr $3a03bc	            JSR UART_PUTC
.3a045f	28		plp		done        PLP
.3a0460	2b		pld		            PLD
.3a0461	7a		ply		            PLY
.3a0462	fa		plx		            PLX
.3a0463	60		rts		            RTS
.3a0464					PRINTS
.3a0464	08		php		            PHP
.3a0465	e2 20		sep #$20	            SEP #$20
.3a0467	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.3a046a	f0 06		beq $3a0472	            BEQ done
.3a046c	20 18 00	jsr $3a0018	            JSR PRINTC
.3a046f	e8		inx		            INX
.3a0470	80 f5		bra $3a0467	            BRA loop
.3a0472	28		plp		done        PLP
.3a0473	60		rts		            RTS
.3a0474					PRHEXW
.3a0474	08		php		            PHP
.3a0475	c2 20		rep #$20	            REP #$20
.3a0477	48		pha		            PHA
.3a0478	48		pha		            PHA
.3a0479	4a		lsr a		            LSR A
.3a047a	4a		lsr a		            LSR A
.3a047b	4a		lsr a		            LSR A
.3a047c	4a		lsr a		            LSR A
.3a047d	4a		lsr a		            LSR A
.3a047e	4a		lsr a		            LSR A
.3a047f	4a		lsr a		            LSR A
.3a0480	4a		lsr a		            LSR A
.3a0481	20 8e 04	jsr $3a048e	            JSR PRHEXB
.3a0484	68		pla		            PLA
.3a0485	29 ff 00	and #$00ff	            AND #$00FF
.3a0488	20 8e 04	jsr $3a048e	            JSR PRHEXB
.3a048b	68		pla		            PLA
.3a048c	28		plp		            PLP
.3a048d	60		rts		            RTS
.3a048e					PRHEXB
.3a048e	08		php		            PHP
.3a048f	c2 20		rep #$20	            REP #$20
.3a0491	48		pha		            PHA
.3a0492	e2 20		sep #$20	            SEP #$20
.3a0494	48		pha		            PHA
.3a0495	4a		lsr a		            LSR A
.3a0496	4a		lsr a		            LSR A
.3a0497	4a		lsr a		            LSR A
.3a0498	4a		lsr a		            LSR A
.3a0499	20 a5 04	jsr $3a04a5	            JSR PRHEXN
.3a049c	68		pla		            PLA
.3a049d	20 a5 04	jsr $3a04a5	            JSR PRHEXN
.3a04a0	c2 20		rep #$20	            REP #$20
.3a04a2	68		pla		            PLA
.3a04a3	28		plp		            PLP
.3a04a4	60		rts		            RTS
.3a04a5					PRHEXN
.3a04a5	08		php		            PHP
.3a04a6	c2 30		rep #$30	            REP #$30
.3a04a8	da		phx		            PHX
.3a04a9	29 0f 00	and #$000f	            AND #$000F
.3a04ac	aa		tax		            TAX
.3a04ad	bf 00 d0 3a	lda $3ad000,x	            LDA @lHEXDIGITS,X
.3a04b1	20 18 00	jsr $3a0018	            JSR PRINTC
.3a04b4	fa		plx		            PLX
.3a04b5	28		plp		            PLP
.3a04b6	60		rts		            RTS
>3ad000	30 31 32 33 34 35 36 37		HEXDIGITS   .text "0123456789ABCDEF"
>3ad008	38 39 41 42 43 44 45 46

;******  Return to file: src\basic816.s


;******  Processing file: src\utilities.s

.3a04b7					PRTRACE
.3a04b7	08		php		            PHP
.3a04b8	c2 30		rep #$30	            REP #$30
.3a04ba	48		pha		            PHA
.3a04bb	da		phx		            PHX
.3a04bc	5a		phy		            PHY
.3a04bd	8b		phb		            PHB
.3a04be	0b		phd		            PHD
.3a04bf	c2 30		rep #$30	            REP #$30
.3a04c1	a3 0b		lda $0b,s	            LDA 11,S        ; Get the return address
.3a04c3	18		clc		calc_addr   CLC
.3a04c4	69 03 00	adc #$0003	            ADC #3          ; Add 3 to skip over the following branch
.3a04c7	aa		tax		            TAX
.3a04c8	e2 20		sep #$20	            SEP #$20
.3a04ca	a9 3a		lda #$3a	            LDA #`PRTRACE
.3a04cc	48		pha		            PHA
.3a04cd	ab		plb		            PLB
.3a04ce	bd 00 00	lda $0000,x	pr_loop     LDA #0,B,X
.3a04d1	f0 06		beq $3a04d9	            BEQ done
.3a04d3	20 a1 03	jsr $3a03a1	            JSR SCREEN_PUTC
.3a04d6	e8		inx		            INX
.3a04d7	80 f5		bra $3a04ce	            BRA pr_loop
.3a04d9					done
.3a04d9	c2 30		rep #$30	            REP #$30
.3a04db	2b		pld		            PLD
.3a04dc	ab		plb		            PLB
.3a04dd	7a		ply		            PLY
.3a04de	fa		plx		            PLX
.3a04df	68		pla		            PLA
.3a04e0	28		plp		            PLP
.3a04e1	60		rts		            RTS
.3a04e2					ISALPHA
.3a04e2	08		php		            PHP
.3a04e3	e2 20		sep #$20	            SEP #$20
.3a04e5	c9 5b		cmp #$5b	            CMP #'Z'+1
.3a04e7	b0 04		bcs $3a04ed	            BGE not_upper
.3a04e9	c9 41		cmp #$41	            CMP #'A'
.3a04eb	b0 0b		bcs $3a04f8	            BGE is_alpha
.3a04ed	c9 7b		cmp #$7b	not_upper   CMP #'z'+1
.3a04ef	b0 04		bcs $3a04f5	            BGE not_alpha
.3a04f1	c9 61		cmp #$61	            CMP #'a'
.3a04f3	b0 03		bcs $3a04f8	            BGE is_alpha
.3a04f5					not_alpha
.3a04f5	28		plp		            PLP
.3a04f6	18		clc		            CLC
.3a04f7	60		rts		            RTS
.3a04f8					is_alpha
.3a04f8	28		plp		            PLP
.3a04f9	38		sec		            SEC
.3a04fa	60		rts		            RTS
.3a04fb					ISNUMERAL
.3a04fb	08		php		            PHP
.3a04fc	e2 20		sep #$20	            SEP #$20
.3a04fe	c9 3a		cmp #$3a	            CMP #'9'+1
.3a0500	b0 04		bcs $3a0506	            BGE ret_false
.3a0502	c9 30		cmp #$30	            CMP #'0'
.3a0504	b0 03		bcs $3a0509	            BGE ret_true
.3a0506	28		plp		ret_false   PLP
.3a0507	18		clc		            CLC
.3a0508	60		rts		            RTS
.3a0509	28		plp		ret_true    PLP
.3a050a	38		sec		            SEC
.3a050b	60		rts		            RTS
.3a050c					ISHEX
.3a050c	08		php		            PHP
.3a050d	e2 20		sep #$20	            SEP #$20
.3a050f	c9 3a		cmp #$3a	            CMP #'9'+1
.3a0511	b0 04		bcs $3a0517	            BGE chk_lca2f
.3a0513	c9 30		cmp #$30	            CMP #'0'
.3a0515	b0 13		bcs $3a052a	            BGE ret_true
.3a0517	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.3a0519	b0 04		bcs $3a051f	            BGE chk_uca2f
.3a051b	c9 61		cmp #$61	            CMP #'a'
.3a051d	b0 0b		bcs $3a052a	            BGE ret_true
.3a051f	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.3a0521	b0 04		bcs $3a0527	            BGE ret_false
.3a0523	c9 41		cmp #$41	            CMP #'A'
.3a0525	b0 03		bcs $3a052a	            BGE ret_true
.3a0527	28		plp		ret_false   PLP
.3a0528	18		clc		            CLC
.3a0529	60		rts		            RTS
.3a052a	28		plp		ret_true    PLP
.3a052b	38		sec		            SEC
.3a052c	60		rts		            RTS
.3a052d					HEX2BIN
.3a052d	08		php		            PHP
.3a052e	e2 20		sep #$20	            SEP #$20
.3a0530	c9 3a		cmp #$3a	            CMP #'9'+1          ; Check to see if '0'..'9'
.3a0532	b0 04		bcs $3a0538	            BGE chk_lca2f
.3a0534	c9 30		cmp #$30	            CMP #'0'
.3a0536	b0 12		bcs $3a054a	            BGE conv_09         ; Yes: convert it
.3a0538	c9 67		cmp #$67	chk_lca2f   CMP #'f'+1
.3a053a	b0 04		bcs $3a0540	            BGE chk_uca2f
.3a053c	c9 61		cmp #$61	            CMP #'a'
.3a053e	b0 0f		bcs $3a054f	            BGE conv_lcaf
.3a0540	c9 47		cmp #$47	chk_uca2f   CMP #'F'+1
.3a0542	b0 04		bcs $3a0548	            BGE done
.3a0544	c9 41		cmp #$41	            CMP #'A'
.3a0546	b0 09		bcs $3a0551	            BGE conv_ucaf
.3a0548	28		plp		done        PLP
.3a0549	60		rts		            RTS
.3a054a	38		sec		conv_09     SEC                 ; Convert digits '0'..'9'
.3a054b	e9 30		sbc #$30	            SBC #'0'
.3a054d	80 f9		bra $3a0548	            BRA done
.3a054f	29 df		and #$df	conv_lcaf   AND #%11011111      ; Convert to upper case
.3a0551	38		sec		conv_ucaf   SEC
.3a0552	e9 37		sbc #$37	            SBC #'A'-10         ; Convert 'A'..'F'
.3a0554	80 f2		bra $3a0548	            BRA done
.3a0556					TOUPPERA
.3a0556	08		php		            PHP
.3a0557	e2 20		sep #$20	            SEP #$20
.3a0559	c9 7b		cmp #$7b	            CMP #'z'+1
.3a055b	b0 06		bcs $3a0563	            BCS done
.3a055d	c9 61		cmp #$61	            CMP #'a'
.3a055f	90 02		bcc $3a0563	            BCC done
.3a0561	29 df		and #$df	            AND #%11011111
.3a0563	28		plp		done        PLP
.3a0564	60		rts		            RTS
.3a0565					TOUPPER
.3a0565	08		php		            PHP
.3a0566	e2 20		sep #$20	            SEP #$20
.3a0568	c2 10		rep #$10	            REP #$10
.3a056a	bd 00 00	lda $0000,x	loop        LDA #0,B,X
.3a056d	f0 09		beq $3a0578	            BEQ done
.3a056f	20 56 05	jsr $3a0556	            JSR TOUPPERA
.3a0572	9d 00 00	sta $0000,x	            STA #0,B,X
.3a0575	e8		inx		continue    INX
.3a0576	80 f2		bra $3a056a	            BRA loop
.3a0578	28		plp		done        PLP
.3a0579	60		rts		            RTS
.3a057a					MULINT10
.3a057a	08		php		                PHP
.3a057b	0b		phd		                PHD
.3a057c	08		php		            PHP
.3a057d	c2 20		rep #$20	            REP #$20
.3a057f	48		pha		            PHA
.3a0580	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0583	5b		tcd		            TCD
.3a0584	68		pla		            PLA
.3a0585	28		plp		            PLP
.3a0586	c2 20		rep #$20	            REP #$20
.3a0588	48		pha		                PHA
.3a0589	06 23		asl $0823	                ASL ARGUMENT1           ; 7 -- 20 -- 74
.3a058b	26 25		rol $0825	                ROL ARGUMENT1+2         ; 7
.3a058d	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.3a058f	85 0c		sta $080c	                STA SCRATCH             ; 4
.3a0591	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.3a0593	85 0e		sta $080e	                STA SCRATCH+2           ; 4
.3a0595	06 0c		asl $080c	                ASL SCRATCH             ; 7 -- 28
.3a0597	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.3a0599	06 0c		asl $080c	                ASL SCRATCH             ; 7
.3a059b	26 0e		rol $080e	                ROL SCRATCH+2           ; 7
.3a059d	18		clc		                CLC                     ; 2 -- 26
.3a059e	a5 23		lda $0823	                LDA ARGUMENT1           ; 4
.3a05a0	65 0c		adc $080c	                ADC SCRATCH             ; 4
.3a05a2	85 23		sta $0823	                STA ARGUMENT1           ; 4
.3a05a4	a5 25		lda $0825	                LDA ARGUMENT1+2         ; 4
.3a05a6	65 0e		adc $080e	                ADC SCRATCH+2           ; 4
.3a05a8	85 25		sta $0825	                STA ARGUMENT1+2         ; 4
.3a05aa	68		pla		                PLA
.3a05ab	2b		pld		                PLD
.3a05ac	28		plp		                PLP
.3a05ad	60		rts		            RTS
.3a05ae					DIVINT10
.3a05ae	08		php		                PHP
.3a05af	0b		phd		                PHD
.3a05b0	08		php		            PHP
.3a05b1	c2 20		rep #$20	            REP #$20
.3a05b3	48		pha		            PHA
.3a05b4	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a05b7	5b		tcd		            TCD
.3a05b8	68		pla		            PLA
.3a05b9	28		plp		            PLP
.3a05ba	c2 20		rep #$20	            REP #$20
.3a05bc	a5 23		lda $0823	                LDA ARGUMENT1
.3a05be	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.3a05c2	a9 0a 00	lda #$000a	                LDA #10
.3a05c5	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.3a05c9	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.3a05cd	85 23		sta $0823	                STA ARGUMENT1
.3a05cf	64 25		stz $0825	                STZ ARGUMENT1+2
.3a05d1	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.3a05d5	85 29		sta $0829	                STA ARGUMENT2
.3a05d7	64 2b		stz $082b	                STZ ARGUMENT2+2
.3a05d9	e2 20		sep #$20	            SEP #$20
.3a05db	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a05dd	85 27		sta $0827	                STA ARGTYPE1
.3a05df	85 2d		sta $082d	                STA ARGTYPE2
.3a05e1	2b		pld		                PLD
.3a05e2	28		plp		                PLP
.3a05e3	60		rts		            RTS
.3a05e4					DIVINT100
.3a05e4	08		php		                PHP
.3a05e5	0b		phd		                PHD
.3a05e6	08		php		            PHP
.3a05e7	c2 20		rep #$20	            REP #$20
.3a05e9	48		pha		            PHA
.3a05ea	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a05ed	5b		tcd		            TCD
.3a05ee	68		pla		            PLA
.3a05ef	28		plp		            PLP
.3a05f0	c2 20		rep #$20	            REP #$20
.3a05f2	a5 23		lda $0823	                LDA ARGUMENT1
.3a05f4	8f 1a 01 00	sta $00011a	                STA @lD1_OPERAND_B
.3a05f8	a9 64 00	lda #$0064	                LDA #100
.3a05fb	8f 18 01 00	sta $000118	                STA @lD1_OPERAND_A
.3a05ff	af 1c 01 00	lda $00011c	                LDA @lD1_RESULT
.3a0603	85 23		sta $0823	                STA ARGUMENT1
.3a0605	64 25		stz $0825	                STZ ARGUMENT1+2
.3a0607	af 1e 01 00	lda $00011e	                LDA @lD1_REMAINDER
.3a060b	85 29		sta $0829	                STA ARGUMENT2
.3a060d	64 2b		stz $082b	                STZ ARGUMENT2+2
.3a060f	e2 20		sep #$20	            SEP #$20
.3a0611	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a0613	85 27		sta $0827	                STA ARGTYPE1
.3a0615	85 2d		sta $082d	                STA ARGTYPE2
.3a0617	2b		pld		                PLD
.3a0618	28		plp		                PLP
.3a0619	60		rts		            RTS
.3a061a					IS_ARG1_Z
.3a061a	08		php		                PHP
.3a061b	c2 20		rep #$20	            REP #$20
.3a061d	a5 23		lda $0823	                LDA ARGUMENT1
.3a061f	d0 08		bne $3a0629	                BNE return_false
.3a0621	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a0623	d0 04		bne $3a0629	                BNE return_false
.3a0625	28		plp		return_true     PLP
.3a0626	e2 02		sep #$02	                SEP #$02        ; Set Z
.3a0628	60		rts		            RTS
.3a0629	28		plp		return_false    PLP
.3a062a	c2 02		rep #$02	                REP #$02        ; Clear Z
.3a062c	60		rts		            RTS
.3a062d					SET_TRUE
.3a062d	08		php		                PHP
.3a062e	c2 30		rep #$30	            REP #$30
.3a0630	a9 ff ff	lda #$ffff	                LDA #$FFFF
.3a0633	85 23		sta $0823	                STA ARGUMENT1
.3a0635	85 25		sta $0825	                STA ARGUMENT1+2
.3a0637	e2 20		sep #$20	            SEP #$20
.3a0639	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a063b	85 27		sta $0827	                STA ARGTYPE1
.3a063d	28		plp		                PLP
.3a063e	60		rts		            RTS
.3a063f					SET_FALSE
.3a063f	08		php		                PHP
.3a0640	c2 30		rep #$30	            REP #$30
.3a0642	a9 00 00	lda #$0000	                LDA #0
.3a0645	85 23		sta $0823	                STA ARGUMENT1
.3a0647	85 25		sta $0825	                STA ARGUMENT1+2
.3a0649	e2 20		sep #$20	            SEP #$20
.3a064b	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a064d	85 27		sta $0827	                STA ARGTYPE1
.3a064f	28		plp		                PLP
.3a0650	60		rts		            RTS
.3a0651					ASS_ARG1_INT
.3a0651	08		php		                PHP
.3a0652	e2 20		sep #$20	            SEP #$20
.3a0654	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.3a0656	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a0658	f0 07		beq $3a0661	                BEQ done                ; If so: just return
.3a065a	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.3a065c	d0 05		bne $3a0663	                BNE TYPE_ERR            ; If not: throw an error
.3a065e	20 06 5c	jsr $3a5c06	            JSR FTOI
.3a0661	28		plp		done            PLP
.3a0662	60		rts		            RTS
.3a0663					TYPE_ERR
.3a0663	08		php		            PHP
.3a0664	c2 20		rep #$20	            REP #$20
.3a0666	48		pha		            PHA
.3a0667	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a066a	5b		tcd		            TCD
.3a066b	68		pla		            PLA
.3a066c	28		plp		            PLP
.3a066d	e2 20		sep #$20	            SEP #$20
.3a066f	a9 04		lda #$04	            LDA #ERR_TYPE
.3a0671	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0675	c2 20		rep #$20	            REP #$20
.3a0677	29 ff 00	and #$00ff	            AND #$00FF
.3a067a	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a067d	e2 20		sep #$20	            SEP #$20
.3a067f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0682					ASS_ARG2_INT
.3a0682	08		php		                PHP
.3a0683	e2 20		sep #$20	            SEP #$20
.3a0685	a5 2d		lda $082d	                LDA ARGTYPE2                ; Verify that the type is INTEGER
.3a0687	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a0689	f0 37		beq $3a06c2	                BEQ done                    ; If so: just return
.3a068b	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; Check if it's a float
.3a068d	d0 35		bne $3a06c4	                BNE TYPE_ERR                ; If not: throw an error
.3a068f	c2 20		rep #$20	            REP #$20
.3a0691	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a0693	48		pha		            PHA
.3a0694	a5 23		lda $0823	            LDA ARGUMENT1
.3a0696	48		pha		            PHA
.3a0697	c2 20		rep #$20	            REP #$20
.3a0699	a5 29		lda $0829	            LDA ARGUMENT2
.3a069b	85 23		sta $0823	            STA ARGUMENT1
.3a069d	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a069f	85 25		sta $0825	            STA ARGUMENT1+2
.3a06a1	e2 20		sep #$20	            SEP #$20
.3a06a3	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.3a06a5	85 27		sta $0827	            STA ARGTYPE1
.3a06a7	20 06 5c	jsr $3a5c06	            JSR FTOI
.3a06aa	c2 20		rep #$20	            REP #$20
.3a06ac	a5 23		lda $0823	            LDA ARGUMENT1
.3a06ae	85 29		sta $0829	            STA ARGUMENT2
.3a06b0	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a06b2	85 2b		sta $082b	            STA ARGUMENT2+2
.3a06b4	e2 20		sep #$20	            SEP #$20
.3a06b6	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.3a06b8	85 2d		sta $082d	            STA ARGTYPE2
.3a06ba	c2 20		rep #$20	            REP #$20
.3a06bc	68		pla		            PLA
.3a06bd	85 23		sta $0823	            STA ARGUMENT1
.3a06bf	68		pla		            PLA
.3a06c0	85 25		sta $0825	            STA ARGUMENT1+2
.3a06c2	28		plp		done            PLP
.3a06c3	60		rts		            RTS
.3a06c4					TYPE_ERR
.3a06c4	08		php		            PHP
.3a06c5	c2 20		rep #$20	            REP #$20
.3a06c7	48		pha		            PHA
.3a06c8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a06cb	5b		tcd		            TCD
.3a06cc	68		pla		            PLA
.3a06cd	28		plp		            PLP
.3a06ce	e2 20		sep #$20	            SEP #$20
.3a06d0	a9 04		lda #$04	            LDA #ERR_TYPE
.3a06d2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a06d6	c2 20		rep #$20	            REP #$20
.3a06d8	29 ff 00	and #$00ff	            AND #$00FF
.3a06db	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a06de	e2 20		sep #$20	            SEP #$20
.3a06e0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a06e3					ASS_ARG1_STR
.3a06e3	08		php		                PHP
.3a06e4	e2 20		sep #$20	            SEP #$20
.3a06e6	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is STRING
.3a06e8	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a06ea	d0 02		bne $3a06ee	                BNE TYPE_ERR
.3a06ec	28		plp		                PLP
.3a06ed	60		rts		            RTS
.3a06ee					TYPE_ERR
.3a06ee	08		php		            PHP
.3a06ef	c2 20		rep #$20	            REP #$20
.3a06f1	48		pha		            PHA
.3a06f2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a06f5	5b		tcd		            TCD
.3a06f6	68		pla		            PLA
.3a06f7	28		plp		            PLP
.3a06f8	e2 20		sep #$20	            SEP #$20
.3a06fa	a9 04		lda #$04	            LDA #ERR_TYPE
.3a06fc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0700	c2 20		rep #$20	            REP #$20
.3a0702	29 ff 00	and #$00ff	            AND #$00FF
.3a0705	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a0708	e2 20		sep #$20	            SEP #$20
.3a070a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a070d					ASS_ARG1_INT16
.3a070d	08		php		                PHP
.3a070e	e2 20		sep #$20	            SEP #$20
.3a0710	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.3a0712	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a0714	f0 07		beq $3a071d	                BEQ check_range         ; If so: check the range
.3a0716	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.3a0718	d0 0b		bne $3a0725	                BNE TYPE_ERR            ; If not: throw an error
.3a071a	20 06 5c	jsr $3a5c06	            JSR FTOI
.3a071d					check_range
.3a071d	c2 20		rep #$20	            REP #$20
.3a071f	a5 25		lda $0825	                LDA ARGUMENT1+2         ; Validate it is 16-bit
.3a0721	d0 21		bne $3a0744	                BNE range_err
.3a0723	28		plp		                PLP
.3a0724	60		rts		            RTS
.3a0725					TYPE_ERR
.3a0725	08		php		            PHP
.3a0726	c2 20		rep #$20	            REP #$20
.3a0728	48		pha		            PHA
.3a0729	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a072c	5b		tcd		            TCD
.3a072d	68		pla		            PLA
.3a072e	28		plp		            PLP
.3a072f	e2 20		sep #$20	            SEP #$20
.3a0731	a9 04		lda #$04	            LDA #ERR_TYPE
.3a0733	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0737	c2 20		rep #$20	            REP #$20
.3a0739	29 ff 00	and #$00ff	            AND #$00FF
.3a073c	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a073f	e2 20		sep #$20	            SEP #$20
.3a0741	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0744					RANGE_ERR
.3a0744	08		php		            PHP
.3a0745	c2 20		rep #$20	            REP #$20
.3a0747	48		pha		            PHA
.3a0748	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a074b	5b		tcd		            TCD
.3a074c	68		pla		            PLA
.3a074d	28		plp		            PLP
.3a074e	e2 20		sep #$20	            SEP #$20
.3a0750	a9 09		lda #$09	            LDA #ERR_RANGE
.3a0752	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0756	c2 20		rep #$20	            REP #$20
.3a0758	29 ff 00	and #$00ff	            AND #$00FF
.3a075b	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a075e	e2 20		sep #$20	            SEP #$20
.3a0760	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0763					ASS_ARG1_BYTE
.3a0763	08		php		                PHP
.3a0764	e2 20		sep #$20	            SEP #$20
.3a0766	a5 27		lda $0827	                LDA ARGTYPE1            ; Verify that the type is INTEGER
.3a0768	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a076a	f0 07		beq $3a0773	                BEQ check_range         ; If so: check the range
.3a076c	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; Check if it's a float
.3a076e	d0 11		bne $3a0781	                BNE TYPE_ERR            ; If not: throw an error
.3a0770	20 06 5c	jsr $3a5c06	            JSR FTOI
.3a0773	a5 26		lda $0826	check_range     LDA ARGUMENT1+3         ; Validate that the value is in byte range
.3a0775	d0 29		bne $3a07a0	                BNE RANGE_ERR           ; If not... throw a range error
.3a0777	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a0779	d0 25		bne $3a07a0	                BNE RANGE_ERR
.3a077b	a5 24		lda $0824	                LDA ARGUMENT1+1
.3a077d	d0 21		bne $3a07a0	                BNE RANGE_ERR
.3a077f	28		plp		                PLP
.3a0780	60		rts		            RTS
.3a0781					TYPE_ERR
.3a0781	08		php		            PHP
.3a0782	c2 20		rep #$20	            REP #$20
.3a0784	48		pha		            PHA
.3a0785	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a0788	5b		tcd		            TCD
.3a0789	68		pla		            PLA
.3a078a	28		plp		            PLP
.3a078b	e2 20		sep #$20	            SEP #$20
.3a078d	a9 04		lda #$04	            LDA #ERR_TYPE
.3a078f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0793	c2 20		rep #$20	            REP #$20
.3a0795	29 ff 00	and #$00ff	            AND #$00FF
.3a0798	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a079b	e2 20		sep #$20	            SEP #$20
.3a079d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a07a0					RANGE_ERR
.3a07a0	08		php		            PHP
.3a07a1	c2 20		rep #$20	            REP #$20
.3a07a3	48		pha		            PHA
.3a07a4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a07a7	5b		tcd		            TCD
.3a07a8	68		pla		            PLA
.3a07a9	28		plp		            PLP
.3a07aa	e2 20		sep #$20	            SEP #$20
.3a07ac	a9 09		lda #$09	            LDA #ERR_RANGE
.3a07ae	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a07b2	c2 20		rep #$20	            REP #$20
.3a07b4	29 ff 00	and #$00ff	            AND #$00FF
.3a07b7	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a07ba	e2 20		sep #$20	            SEP #$20
.3a07bc	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a07bf					ASS_ARG1_FLOAT
.3a07bf	08		php		                PHP
.3a07c0	e2 20		sep #$20	            SEP #$20
.3a07c2	a5 27		lda $0827	                LDA ARGTYPE1            ; Check the type
.3a07c4	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.3a07c6	f0 26		beq $3a07ee	                BEQ done                ; Then we're done
.3a07c8	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.3a07ca	f0 1f		beq $3a07eb	                BEQ cast                ; Then cast it to float
.3a07cc					type_err
.3a07cc	08		php		            PHP
.3a07cd	c2 20		rep #$20	            REP #$20
.3a07cf	48		pha		            PHA
.3a07d0	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a07d3	5b		tcd		            TCD
.3a07d4	68		pla		            PLA
.3a07d5	28		plp		            PLP
.3a07d6	e2 20		sep #$20	            SEP #$20
.3a07d8	a9 04		lda #$04	            LDA #ERR_TYPE
.3a07da	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a07de	c2 20		rep #$20	            REP #$20
.3a07e0	29 ff 00	and #$00ff	            AND #$00FF
.3a07e3	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a07e6	e2 20		sep #$20	            SEP #$20
.3a07e8	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a07eb					cast
.3a07eb	20 00 5c	jsr $3a5c00	            JSR ITOF
.3a07ee	28		plp		done            PLP
.3a07ef	60		rts		            RTS
.3a07f0					ASS_ARG2_FLOAT
.3a07f0	08		php		                PHP
.3a07f1	e2 20		sep #$20	            SEP #$20
.3a07f3	a5 2d		lda $082d	                LDA ARGTYPE2            ; Check the type
.3a07f5	c9 01		cmp #$01	                CMP #TYPE_FLOAT         ; If it's float...
.3a07f7	f0 26		beq $3a081f	                BEQ done                ; Then we're done
.3a07f9	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's integer...
.3a07fb	f0 1f		beq $3a081c	                BEQ cast                ; Then cast it to float
.3a07fd					type_err
.3a07fd	08		php		            PHP
.3a07fe	c2 20		rep #$20	            REP #$20
.3a0800	48		pha		            PHA
.3a0801	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a0804	5b		tcd		            TCD
.3a0805	68		pla		            PLA
.3a0806	28		plp		            PLP
.3a0807	e2 20		sep #$20	            SEP #$20
.3a0809	a9 04		lda #$04	            LDA #ERR_TYPE
.3a080b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a080f	c2 20		rep #$20	            REP #$20
.3a0811	29 ff 00	and #$00ff	            AND #$00FF
.3a0814	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a0817	e2 20		sep #$20	            SEP #$20
.3a0819	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a081c					cast
.3a081c	20 21 08	jsr $3a0821	            JSR CAST_ARG2_FLOAT
.3a081f	28		plp		done            PLP
.3a0820	60		rts		            RTS
.3a0821					CAST_ARG2_FLOAT
.3a0821	c2 20		rep #$20	            REP #$20
.3a0823	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a0825	48		pha		            PHA
.3a0826	a5 23		lda $0823	            LDA ARGUMENT1
.3a0828	48		pha		            PHA
.3a0829	c2 20		rep #$20	            REP #$20
.3a082b	a5 29		lda $0829	            LDA ARGUMENT2
.3a082d	85 23		sta $0823	            STA ARGUMENT1
.3a082f	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a0831	85 25		sta $0825	            STA ARGUMENT1+2
.3a0833	e2 20		sep #$20	            SEP #$20
.3a0835	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.3a0837	85 27		sta $0827	            STA ARGTYPE1
.3a0839	20 00 5c	jsr $3a5c00	            JSR ITOF
.3a083c	c2 20		rep #$20	            REP #$20
.3a083e	a5 23		lda $0823	            LDA ARGUMENT1
.3a0840	85 29		sta $0829	            STA ARGUMENT2
.3a0842	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a0844	85 2b		sta $082b	            STA ARGUMENT2+2
.3a0846	e2 20		sep #$20	            SEP #$20
.3a0848	a9 01		lda #$01	            LDA #<TYPE_FLOAT
.3a084a	85 2d		sta $082d	            STA ARGTYPE2
.3a084c	c2 20		rep #$20	            REP #$20
.3a084e	68		pla		            PLA
.3a084f	85 23		sta $0823	            STA ARGUMENT1
.3a0851	68		pla		            PLA
.3a0852	85 25		sta $0825	            STA ARGUMENT1+2
.3a0854	60		rts		            RTS
.3a0855					ASS_ARGS_NUM
.3a0855	08		php		                PHP
.3a0856	e2 20		sep #$20	            SEP #$20
.3a0858	a5 27		lda $0827	                LDA ARGTYPE1                ; Check ARGUMENT1
.3a085a	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a085c	f0 23		beq $3a0881	                BEQ arg1_int
.3a085e	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.3a0860	f0 2e		beq $3a0890	                BEQ arg1_float
.3a0862					type_err
.3a0862	08		php		            PHP
.3a0863	c2 20		rep #$20	            REP #$20
.3a0865	48		pha		            PHA
.3a0866	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a0869	5b		tcd		            TCD
.3a086a	68		pla		            PLA
.3a086b	28		plp		            PLP
.3a086c	e2 20		sep #$20	            SEP #$20
.3a086e	a9 04		lda #$04	            LDA #ERR_TYPE
.3a0870	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0874	c2 20		rep #$20	            REP #$20
.3a0876	29 ff 00	and #$00ff	            AND #$00FF
.3a0879	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a087c	e2 20		sep #$20	            SEP #$20
.3a087e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0881	a5 2d		lda $082d	arg1_int        LDA ARGTYPE2                ; Check argument 2
.3a0883	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If integer, we're done
.3a0885	f0 16		beq $3a089d	                BEQ done
.3a0887	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If not float, throw an error
.3a0889	d0 d7		bne $3a0862	                BNE type_err
.3a088b	20 00 5c	jsr $3a5c00	            JSR ITOF
.3a088e	80 0d		bra $3a089d	                BRA done
.3a0890	a5 2d		lda $082d	arg1_float      LDA ARGTYPE2                ; Check argument 2
.3a0892	c9 01		cmp #$01	                CMP #TYPE_FLOAT             ; If it's float
.3a0894	f0 07		beq $3a089d	                BEQ done                    ; Then we're done
.3a0896	c9 00		cmp #$00	                CMP #TYPE_INTEGER           ; If it's not integer
.3a0898	d0 c8		bne $3a0862	                BNE type_err                ; Thrown an error
.3a089a	20 21 08	jsr $3a0821	            JSR CAST_ARG2_FLOAT
.3a089d					done
.3a089d	e2 20		sep #$20	            SEP #$20
.3a089f	a5 27		lda $0827	                LDA ARGTYPE1                ; Return the type code in A
.3a08a1	28		plp		                PLP
.3a08a2	60		rts		            RTS
.3a08a3					ASS_ARGS_NUMSTR
.3a08a3	08		php		                PHP
.3a08a4	e2 20		sep #$20	            SEP #$20
.3a08a6	a5 27		lda $0827	                LDA ARGTYPE1                ; Check to see if ARGUMENT1 is a string
.3a08a8	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a08aa	d0 25		bne $3a08d1	                BNE numbers
.3a08ac	a5 2d		lda $082d	                LDA ARGTYPE2                ; If ARGUMENT1 is a string, make sure ARGUMENT2 is
.3a08ae	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a08b0	f0 24		beq $3a08d6	                BEQ done
.3a08b2					TYPE_ERR
.3a08b2	08		php		            PHP
.3a08b3	c2 20		rep #$20	            REP #$20
.3a08b5	48		pha		            PHA
.3a08b6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a08b9	5b		tcd		            TCD
.3a08ba	68		pla		            PLA
.3a08bb	28		plp		            PLP
.3a08bc	e2 20		sep #$20	            SEP #$20
.3a08be	a9 04		lda #$04	            LDA #ERR_TYPE
.3a08c0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a08c4	c2 20		rep #$20	            REP #$20
.3a08c6	29 ff 00	and #$00ff	            AND #$00FF
.3a08c9	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a08cc	e2 20		sep #$20	            SEP #$20
.3a08ce	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a08d1					numbers
.3a08d1	20 55 08	jsr $3a0855	            JSR ASS_ARGS_NUM
.3a08d4	a5 27		lda $0827	                LDA ARGTYPE1                ; Make sure A is the type
.3a08d6	28		plp		done            PLP
.3a08d7	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\tokens.s

.0000					TOKEN
>0000					precedence  .byte ?
>0001					length      .byte ?
>0002					name        .word <>?
>0004					eval        .word <>?
>0006					arity       .word <>?
.3a08d8					PARSEINT
.3a08d8	08		php		            PHP
.3a08d9	0b		phd		            PHD
.3a08da	08		php		            PHP
.3a08db	c2 20		rep #$20	            REP #$20
.3a08dd	48		pha		            PHA
.3a08de	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a08e1	5b		tcd		            TCD
.3a08e2	68		pla		            PLA
.3a08e3	28		plp		            PLP
.3a08e4	c2 30		rep #$30	            REP #$30
.3a08e6	64 23		stz $0823	            STZ ARGUMENT1       ; Default to Not-a-value
.3a08e8	64 25		stz $0825	            STZ ARGUMENT1+2
.3a08ea	e2 20		sep #$20	            SEP #$20
.3a08ec	64 27		stz $0827	            STZ ARGTYPE1
.3a08ee	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it starts with '$'
.3a08f0	c9 26		cmp #$26	            CMP #'&'
.3a08f2	f0 44		beq $3a0938	            BEQ check_hex       ; Yes: parse it as a hexadecimal number
.3a08f4					loop
.3a08f4	e2 20		sep #$20	            SEP #$20
.3a08f6	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.3a08f8	20 fb 04	jsr $3a04fb	            JSR ISNUMERAL
.3a08fb	90 76		bcc $3a0973	            BCC done            ; No, we're done parsing
.3a08fd	20 7a 05	jsr $3a057a	            JSR MULINT10
.3a0900	38		sec		            SEC                 ; Convert the ASCII code to a number
.3a0901	e9 30		sbc #$30	            SBC #'0'
.3a0903	c2 20		rep #$20	            REP #$20
.3a0905	29 ff 00	and #$00ff	            AND #$00FF
.3a0908	18		clc		            CLC
.3a0909	65 23		adc $0823	            ADC ARGUMENT1
.3a090b	85 23		sta $0823	            STA ARGUMENT1
.3a090d	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a090f	69 00 00	adc #$0000	            ADC #0
.3a0912	85 25		sta $0825	            STA ARGUMENT1+2
.3a0914	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a0917	80 db		bra $3a08f4	            BRA loop            ; And try to process it
.3a0919					syntaxerr
.3a0919	08		php		            PHP
.3a091a	c2 20		rep #$20	            REP #$20
.3a091c	48		pha		            PHA
.3a091d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a0920	5b		tcd		            TCD
.3a0921	68		pla		            PLA
.3a0922	28		plp		            PLP
.3a0923	e2 20		sep #$20	            SEP #$20
.3a0925	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a0927	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a092b	c2 20		rep #$20	            REP #$20
.3a092d	29 ff 00	and #$00ff	            AND #$00FF
.3a0930	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a0933	e2 20		sep #$20	            SEP #$20
.3a0935	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0938					check_hex
.3a0938	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a093b	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.3a093d	c9 48		cmp #$48	            CMP #'H'            ; Is it 'H'?
.3a093f	f0 04		beq $3a0945	            BEQ parse_hex       ; Yes: skip it and parse hex
.3a0941	c9 68		cmp #$68	            CMP #'h'            ; Is it 'h'?
.3a0943	d0 d4		bne $3a0919	            BNE syntaxerr       ; No: throw an error
.3a0945					parse_hex
.3a0945	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a0948					hexloop
.3a0948	e2 20		sep #$20	            SEP #$20
.3a094a	a7 00		lda [$0800]	            LDA [BIP]           ; Get the next character
.3a094c	20 0c 05	jsr $3a050c	            JSR ISHEX
.3a094f	90 22		bcc $3a0973	            BCC done            ; No, we're done parsing
.3a0951	20 2d 05	jsr $3a052d	            JSR HEX2BIN
.3a0954	c2 20		rep #$20	            REP #$20
.3a0956	06 23		asl $0823	            ASL ARGUMENT1
.3a0958	26 25		rol $0825	            ROL ARGUMENT1+2
.3a095a	06 23		asl $0823	            ASL ARGUMENT1
.3a095c	26 25		rol $0825	            ROL ARGUMENT1+2
.3a095e	06 23		asl $0823	            ASL ARGUMENT1
.3a0960	26 25		rol $0825	            ROL ARGUMENT1+2
.3a0962	06 23		asl $0823	            ASL ARGUMENT1
.3a0964	26 25		rol $0825	            ROL ARGUMENT1+2
.3a0966	29 ff 00	and #$00ff	            AND #$00FF          ; Add binary number to ARGUMENT1
.3a0969	18		clc		            CLC
.3a096a	65 23		adc $0823	            ADC ARGUMENT1
.3a096c	85 23		sta $0823	            STA ARGUMENT1
.3a096e	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a0971	80 d5		bra $3a0948	            BRA hexloop         ; And try to process it
.3a0973	2b		pld		done        PLD
.3a0974	28		plp		            PLP
.3a0975	60		rts		            RTS
.3a0976					PREVCHAR
.3a0976	08		php		            PHP
.3a0977	c2 30		rep #$30	            REP #$30
.3a0979	a5 04		lda $0804	            LDA BIPPREV
.3a097b	f0 1c		beq $3a0999	            BEQ ret_false
.3a097d	38		sec		            SEC
.3a097e	a5 04		lda $0804	            LDA BIPPREV
.3a0980	e5 1a		sbc $081a	            SBC CURLINE
.3a0982	a8		tay		            TAY
.3a0983	e2 20		sep #$20	            SEP #$20
.3a0985	b7 1a		lda [$081a],y	loop        LDA [CURLINE],Y
.3a0987	f0 10		beq $3a0999	            BEQ ret_false
.3a0989	c9 20		cmp #$20	            CMP #CHAR_SP
.3a098b	f0 06		beq $3a0993	            BEQ go_back
.3a098d	c9 09		cmp #$09	            CMP #CHAR_TAB
.3a098f	f0 02		beq $3a0993	            BEQ go_back
.3a0991	28		plp		            PLP
.3a0992	60		rts		            RTS
.3a0993	88		dey		go_back     DEY
.3a0994	c0 ff ff	cpy #$ffff	            CPY #$FFFF
.3a0997	d0 ec		bne $3a0985	            BNE loop
.3a0999					ret_false
.3a0999	a9 00		lda #$00	            LDA #0
.3a099b	60		rts		            RTS
.3a099c					TOKENIZE
.3a099c	08		php		            PHP
.3a099d	0b		phd		            PHD
.3a099e	08		php		            PHP
.3a099f	c2 20		rep #$20	            REP #$20
.3a09a1	48		pha		            PHA
.3a09a2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a09a5	5b		tcd		            TCD
.3a09a6	68		pla		            PLA
.3a09a7	28		plp		            PLP
.3a09a8	c2 30		rep #$30	            REP #$30
.3a09aa	a5 1a		lda $081a	            LDA CURLINE
.3a09ac	85 00		sta $0800	            STA BIP
.3a09ae	e2 20		sep #$20	            SEP #$20
.3a09b0	a5 1c		lda $081c	            LDA CURLINE+2
.3a09b2	85 02		sta $0802	            STA BIP+2
.3a09b4	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a09b7	a7 00		lda [$0800]	            LDA [BIP]               ; Do we have a numeral?
.3a09b9	20 fb 04	jsr $3a04fb	            JSR ISNUMERAL
.3a09bc	90 0c		bcc $3a09ca	            BCC mv_curline          ; No: adjust CURLINE and tokenize
.3a09be	20 d8 08	jsr $3a08d8	            JSR PARSEINT
.3a09c1	c2 20		rep #$20	            REP #$20
.3a09c3	a5 23		lda $0823	            LDA ARGUMENT1
.3a09c5	85 d7		sta $08d7	            STA LINENUM
.3a09c7	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a09ca					mv_curline
.3a09ca	c2 20		rep #$20	            REP #$20
.3a09cc	a5 00		lda $0800	            LDA BIP
.3a09ce	85 1a		sta $081a	            STA CURLINE
.3a09d0	e2 20		sep #$20	            SEP #$20
.3a09d2	a5 02		lda $0802	            LDA BIP+2
.3a09d4	85 1c		sta $081c	            STA CURLINE+2
.3a09d6	20 ea 09	jsr $3a09ea	            JSR FINDREM
.3a09d9	e2 20		sep #$20	            SEP #$20
.3a09db					loop
.3a09db	20 5b 0a	jsr $3a0a5b	            JSR TKFINDTOKEN
.3a09de	c9 00		cmp #$00	            CMP #0                  ; Did we find a token?
.3a09e0	f0 05		beq $3a09e7	            BEQ done                ; No: return
.3a09e2	20 06 0c	jsr $3a0c06	            JSR TKWRITE
.3a09e5	80 f4		bra $3a09db	            BRA loop                ; And try again
.3a09e7	2b		pld		done        PLD
.3a09e8	28		plp		            PLP
.3a09e9	60		rts		            RTS
.3a09ea					FINDREM
.3a09ea	08		php		            PHP
.3a09eb	c2 20		rep #$20	            REP #$20
.3a09ed	a5 1a		lda $081a	            LDA CURLINE             ; Point BIP to the beginning of the line
.3a09ef	85 00		sta $0800	            STA BIP
.3a09f1	a5 1c		lda $081c	            LDA CURLINE+2
.3a09f3	85 02		sta $0802	            STA BIP+2
.3a09f5	a2 00 00	ldx #$0000	            LDX #0                  ; X will be a flag that we're at the beginning
.3a09f8	e2 20		sep #$20	            SEP #$20
.3a09fa	a0 00 00	ldy #$0000	loop        LDY #0
.3a09fd	e0 00 00	cpx #$0000	            CPX #0                  ; If we are at the first space on the line
.3a0a00	f0 0d		beq $3a0a0f	            BEQ skip_delim          ; ... skip looking for a delimiter
.3a0a02	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.3a0a04	f0 53		beq $3a0a59	            BEQ done                ; Is it null? Then we're done
.3a0a06	c9 3a		cmp #$3a	            CMP #':'                ; Is it ":"
.3a0a08	f0 04		beq $3a0a0e	            BEQ found_delim         ; Yes: we might have a REM... look for E
.3a0a0a	c9 20		cmp #$20	            CMP #CHAR_SP
.3a0a0c	d0 33		bne $3a0a41	            BNE next_pos            ; No: we didn't find REM here... check next position
.3a0a0e	c8		iny		found_delim INY
.3a0a0f	b7 00		lda [$0800],y	skip_delim  LDA [BIP],Y             ; Get the first character
.3a0a11	f0 46		beq $3a0a59	            BEQ done                ; Is it null? Then we're done
.3a0a13	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.3a0a15	f0 10		beq $3a0a27	            BEQ found_R             ; Yes: we might have a REM... look for E
.3a0a17	c9 72		cmp #$72	            CMP #'r'
.3a0a19	d0 26		bne $3a0a41	            BNE next_pos            ; No: we didn't find REM here... check next position
.3a0a1b	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.3a0a1d	f0 3a		beq $3a0a59	            BEQ done                ; Is it null? Then we're done
.3a0a1f	c9 52		cmp #$52	            CMP #'R'                ; Is it "R"
.3a0a21	f0 04		beq $3a0a27	            BEQ found_R             ; Yes: we might have a REM... look for E
.3a0a23	c9 72		cmp #$72	            CMP #'r'
.3a0a25	d0 1a		bne $3a0a41	            BNE next_pos            ; No: we didn't find REM here... check next position
.3a0a27	c8		iny		found_R     INY
.3a0a28	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.3a0a2a	f0 2d		beq $3a0a59	            BEQ done                ; Is it null? Then we're done
.3a0a2c	c9 45		cmp #$45	            CMP #'E'                ; Is it "E"
.3a0a2e	f0 04		beq $3a0a34	            BEQ found_E             ; Yes: we might have a REM... look for M
.3a0a30	c9 65		cmp #$65	            CMP #'e'
.3a0a32	d0 0d		bne $3a0a41	            BNE next_pos            ; No: we didn't find REM here... check next position
.3a0a34	c8		iny		found_E     INY
.3a0a35	b7 00		lda [$0800],y	            LDA [BIP],Y             ; Get the first character
.3a0a37	f0 20		beq $3a0a59	            BEQ done                ; Is it null? Then we're done
.3a0a39	c9 4d		cmp #$4d	            CMP #'M'                ; Is it "E"
.3a0a3b	f0 0a		beq $3a0a47	            BEQ found_REM           ; Yes: we might have a REM... look for M
.3a0a3d	c9 6d		cmp #$6d	            CMP #'m'
.3a0a3f	f0 06		beq $3a0a47	            BEQ found_REM
.3a0a41	e8		inx		next_pos    INX                     ; Indicate we're no longer at the first position
.3a0a42	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a0a45	80 b3		bra $3a09fa	            BRA loop
.3a0a47	a7 00		lda [$0800]	found_REM   LDA [BIP]               ; Get the current character
.3a0a49	c9 3a		cmp #$3a	            CMP #':'                ; Is it the delimiter?
.3a0a4b	d0 03		bne $3a0a50	            BNE ret_REM             ; No: go ahead and return REM at that location
.3a0a4d	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a0a50	a9 03		lda #$03	ret_REM     LDA #3
.3a0a52	85 1e		sta $081e	            STA CURTOKLEN           ; Set the size
.3a0a54	a9 91		lda #$91	            LDA #TOK_REM            ; And the token to write
.3a0a56	20 06 0c	jsr $3a0c06	            JSR TKWRITE
.3a0a59	28		plp		done        PLP
.3a0a5a	60		rts		            RTS
.3a0a5b					TKFINDTOKEN
.3a0a5b	08		php		            PHP
.3a0a5c	0b		phd		            PHD
.3a0a5d	08		php		            PHP
.3a0a5e	c2 20		rep #$20	            REP #$20
.3a0a60	48		pha		            PHA
.3a0a61	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0a64	5b		tcd		            TCD
.3a0a65	68		pla		            PLA
.3a0a66	28		plp		            PLP
.3a0a67	e2 20		sep #$20	            SEP #$20
.3a0a69	a9 7f		lda #$7f	            LDA #$7F                ; Start off looking for any size token
.3a0a6b	85 1e		sta $081e	            STA CURTOKLEN
.3a0a6d					next_size
.3a0a6d	c2 10		rep #$10	            REP #$10
.3a0a6f	20 bb 0b	jsr $3a0bbb	            JSR TKNEXTBIG
.3a0a72	a5 1e		lda $081e	            LDA CURTOKLEN           ; Are there any keywords left?
.3a0a74	d0 03		bne $3a0a79	            BNE else
.3a0a76	4c fb 0a	jmp $3a0afb	            JMP done                ; No: return to caller
.3a0a79					else
.3a0a79	c2 20		rep #$20	            REP #$20
.3a0a7b	a5 1a		lda $081a	            LDA CURLINE
.3a0a7d	85 00		sta $0800	            STA BIP
.3a0a7f	e2 20		sep #$20	            SEP #$20
.3a0a81	a5 1c		lda $081c	            LDA CURLINE+2
.3a0a83	85 02		sta $0802	            STA BIP+2
.3a0a85	c2 20		rep #$20	            REP #$20
.3a0a87	64 04		stz $0804	            STZ BIPPREV             ; Clear BIPPREV (point to the previous character)
.3a0a89	64 06		stz $0806	            STZ BIPPREV+2
.3a0a8b					check_len
.3a0a8b	e2 30		sep #$30	            SEP #$30
.3a0a8d	a0 00		ldy #$00	            LDY #0
.3a0a8f	b7 00		lda [$0800],y	nul_scan    LDA [BIP],Y
.3a0a91	f0 da		beq $3a0a6d	            BEQ next_size
.3a0a93	c9 91		cmp #$91	            CMP #TOK_REM            ; Tokenization stops at REMarks too
.3a0a95	f0 d6		beq $3a0a6d	            BEQ next_size
.3a0a97	c8		iny		            INY
.3a0a98	c4 1e		cpy $081e	            CPY CURTOKLEN
.3a0a9a	90 f3		bcc $3a0a8f	            BCC nul_scan
.3a0a9c	c2 10		rep #$10	            REP #$10
.3a0a9e	a7 00		lda [$0800]	            LDA [BIP]               ; Check the current character
.3a0aa0	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.3a0aa2	d0 05		bne $3a0aa9	            BNE chk_keyword         ; No: check to see if we are at the start of a possible keyword
.3a0aa4	20 1d 0b	jsr $3a0b1d	            JSR SKIPQUOTED
.3a0aa7	80 28		bra $3a0ad1	            BRA go_next             ; And move on to the next character
.3a0aa9	a5 1e		lda $081e	chk_keyword LDA CURTOKLEN           ; If the token length is <=2
.3a0aab	c9 03		cmp #$03	            CMP #3
.3a0aad	90 19		bcc $3a0ac8	            BLT try_match           ; ... we don't need a delimiter, go ahead and convert it
.3a0aaf	c2 20		rep #$20	            REP #$20
.3a0ab1	a5 00		lda $0800	            LDA BIP                 ; Check to see if we're at the start of the line
.3a0ab3	c5 1a		cmp $081a	            CMP CURLINE
.3a0ab5	d0 08		bne $3a0abf	            BNE chk_delim           ; No: we need to check for a delimiters
.3a0ab7	e2 20		sep #$20	            SEP #$20
.3a0ab9	a5 02		lda $0802	            LDA BIP+2
.3a0abb	c5 1c		cmp $081c	            CMP CURLINE+2
.3a0abd	f0 09		beq $3a0ac8	            BEQ try_match           ; Yes: this can be a keyword
.3a0abf					chk_delim
.3a0abf	e2 20		sep #$20	            SEP #$20
.3a0ac1	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.3a0ac3	20 49 51	jsr $3a5149	            JSR ISVARCHAR
.3a0ac6	b0 09		bcs $3a0ad1	            BCS go_next             ; Yes: we can't start a keyword here
.3a0ac8					try_match
.3a0ac8	e2 20		sep #$20	            SEP #$20
.3a0aca	20 2d 0b	jsr $3a0b2d	            JSR TKMATCH
.3a0acd	c9 00		cmp #$00	            CMP #0                  ; Did we get one?
.3a0acf	d0 11		bne $3a0ae2	            BNE found               ; Yes: return it
.3a0ad1					go_next
.3a0ad1	c2 20		rep #$20	            REP #$20
.3a0ad3	a5 00		lda $0800	            LDA BIP                 ; Update BIPPREV as the point to the previous character
.3a0ad5	85 04		sta $0804	            STA BIPPREV
.3a0ad7	e2 20		sep #$20	            SEP #$20
.3a0ad9	a5 02		lda $0802	            LDA BIP+2
.3a0adb	85 06		sta $0806	            STA BIPPREV+2
.3a0add	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a0ae0	80 a9		bra $3a0a8b	            BRA check_len           ; And try there
.3a0ae2					found
.3a0ae2	c9 81		cmp #$81	            CMP #TOK_MINUS          ; Found a token... is it minus?
.3a0ae4	d0 15		bne $3a0afb	            BNE done                ; Nope: go ahead and return it
.3a0ae6	20 76 09	jsr $3a0976	            JSR PREVCHAR
.3a0ae9	c9 00		cmp #$00	            CMP #0                  ; Did we get anything?
.3a0aeb	f0 11		beq $3a0afe	            BEQ syntax              ; No: line cannot start with minus... throw error
.3a0aed	89 80		bit #$80	            BIT #$80                ; Is it a token?
.3a0aef	f0 08		beq $3a0af9	            BEQ binaryminus         ; No: leave token unchanged
.3a0af1	c9 90		cmp #$90	            CMP #TOK_RPAREN         ; Is the token a right parenthesis?
.3a0af3	f0 04		beq $3a0af9	            BEQ binaryminus         ; Yes: then this should be a binary minus operator
.3a0af5	a9 af		lda #$af	            LDA #TOK_NEGATIVE       ; Otherwise: this should be a unary minus (negation)
.3a0af7	80 02		bra $3a0afb	            BRA done
.3a0af9	a9 81		lda #$81	binaryminus LDA #TOK_MINUS          ; It's data... so token should be for binary minus
.3a0afb					done
.3a0afb	2b		pld		            PLD
.3a0afc	28		plp		            PLP
.3a0afd	60		rts		            RTS
.3a0afe					syntax
.3a0afe	08		php		            PHP
.3a0aff	c2 20		rep #$20	            REP #$20
.3a0b01	48		pha		            PHA
.3a0b02	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a0b05	5b		tcd		            TCD
.3a0b06	68		pla		            PLA
.3a0b07	28		plp		            PLP
.3a0b08	e2 20		sep #$20	            SEP #$20
.3a0b0a	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a0b0c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a0b10	c2 20		rep #$20	            REP #$20
.3a0b12	29 ff 00	and #$00ff	            AND #$00FF
.3a0b15	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a0b18	e2 20		sep #$20	            SEP #$20
.3a0b1a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a0b1d					SKIPQUOTED
.3a0b1d	08		php		            PHP
.3a0b1e	e2 20		sep #$20	            SEP #$20
.3a0b20					loop
.3a0b20	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a0b23	a7 00		lda [$0800]	            LDA [BIP]
.3a0b25	f0 04		beq $3a0b2b	            BEQ done                ; If EOL, just return
.3a0b27	c9 22		cmp #$22	            CMP #CHAR_DQUOTE        ; Is it a double quote?
.3a0b29	d0 f5		bne $3a0b20	            BNE loop                ; No: keep skipping
.3a0b2b	28		plp		done        PLP
.3a0b2c	60		rts		            RTS
.3a0b2d					TKMATCH
.3a0b2d	da		phx		            PHX
.3a0b2e	5a		phy		            PHY
.3a0b2f	08		php		            PHP
.3a0b30	0b		phd		            PHD
.3a0b31	08		php		            PHP
.3a0b32	c2 20		rep #$20	            REP #$20
.3a0b34	48		pha		            PHA
.3a0b35	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0b38	5b		tcd		            TCD
.3a0b39	68		pla		            PLA
.3a0b3a	28		plp		            PLP
.3a0b3b	c2 20		rep #$20	            REP #$20
.3a0b3d	a5 04		lda $0804	            LDA BIPPREV
.3a0b3f	d0 0a		bne $3a0b4b	            BNE check_prev
.3a0b41	e2 20		sep #$20	            SEP #$20
.3a0b43	a5 04		lda $0804	            LDA BIPPREV
.3a0b45	d0 04		bne $3a0b4b	            BNE check_prev
.3a0b47	a9 00		lda #$00	            LDA #0
.3a0b49	80 0a		bra $3a0b55	            BRA save_delim
.3a0b4b					check_prev
.3a0b4b	e2 20		sep #$20	            SEP #$20
.3a0b4d	a7 04		lda [$0804]	            LDA [BIPPREV]           ; Get the previous character
.3a0b4f	20 49 51	jsr $3a5149	            JSR ISVARCHAR
.3a0b52	a9 00		lda #$00	            LDA #0
.3a0b54	2a		rol a		            ROL A
.3a0b55	85 28		sta $0828	save_delim  STA SIGN1               ; SIGN1 := 1 if it is a variable name character
.3a0b57	c2 30		rep #$30	            REP #$30
.3a0b59	a9 fb 0c	lda #$0cfb	            LDA #<>TOKENS           ; Set INDEX to point to the first token record
.3a0b5c	85 08		sta $0808	            STA INDEX
.3a0b5e	e2 20		sep #$20	            SEP #$20
.3a0b60	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0b62	85 0a		sta $080a	            STA INDEX+2
.3a0b64	a2 80 00	ldx #$0080	            LDX #$80                ; Set the initial token ID
.3a0b67					token_loop
.3a0b67	e2 20		sep #$20	            SEP #$20
.3a0b69	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.3a0b6c	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the current token
.3a0b6e	f0 31		beq $3a0ba1	            BEQ no_match            ; Is it 0? We're out of tokens... no match found
.3a0b70	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it the same as the size of the window?
.3a0b72	d0 32		bne $3a0ba6	            BNE next_token          ; No: try the next token
.3a0b74	c2 30		rep #$30	            REP #$30
.3a0b76	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.3a0b79	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the pointer to the token's name
.3a0b7b	85 0c		sta $080c	            STA SCRATCH             ; Set SCRATCH to point to the token's name
.3a0b7d	e2 20		sep #$20	            SEP #$20
.3a0b7f	a9 3a		lda #$3a	            LDA #`DATA_BLOCK
.3a0b81	85 0e		sta $080e	            STA SCRATCH+2
.3a0b83	a5 28		lda $0828	            LDA SIGN1               ; Is previous character a variable name character?
.3a0b85	f0 07		beq $3a0b8e	            BEQ cmp_keyword         ; No: we can check for this token
.3a0b87	a7 0c		lda [$080c]	            LDA [SCRATCH]           ; Get the token's first character
.3a0b89	20 49 51	jsr $3a5149	            JSR ISVARCHAR
.3a0b8c	b0 18		bcs $3a0ba6	            BCS next_token          ; Yes: skip this token
.3a0b8e					cmp_keyword
.3a0b8e	e2 10		sep #$10	            SEP #$10
.3a0b90	a0 00		ldy #$00	            LDY #0
.3a0b92	b7 00		lda [$0800],y	cmp_loop    LDA [BIP],Y             ; Get the character in the window
.3a0b94	20 56 05	jsr $3a0556	            JSR TOUPPERA
.3a0b97	d7 0c		cmp [$080c],y	            CMP [SCRATCH],Y         ; Compare to the character in the token
.3a0b99	d0 0b		bne $3a0ba6	            BNE next_token          ; If they don't match, try the next token
.3a0b9b	c8		iny		            INY                     ; Move to the next character in the window
.3a0b9c	c4 1e		cpy $081e	            CPY CURTOKLEN           ; Have we checked the whole window?
.3a0b9e	90 f2		bcc $3a0b92	            BCC cmp_loop            ; No: check this next character
.3a0ba0	8a		txa		            TXA                     ; Move the token ID to A
.3a0ba1	2b		pld		no_match    PLD
.3a0ba2	28		plp		            PLP
.3a0ba3	7a		ply		            PLY
.3a0ba4	fa		plx		            PLX
.3a0ba5	60		rts		            RTS
.3a0ba6					next_token
.3a0ba6	c2 30		rep #$30	            REP #$30
.3a0ba8	18		clc		            CLC
.3a0ba9	a5 08		lda $0808	            LDA INDEX
.3a0bab	69 08 00	adc #$0008	            ADC #size(TOKEN)
.3a0bae	85 08		sta $0808	            STA INDEX
.3a0bb0	e2 20		sep #$20	            SEP #$20
.3a0bb2	a5 0a		lda $080a	            LDA INDEX+2
.3a0bb4	69 00		adc #$00	            ADC #0
.3a0bb6	85 0a		sta $080a	            STA INDEX+2
.3a0bb8	e8		inx		            INX                     ; Increment the token ID
.3a0bb9	80 ac		bra $3a0b67	            BRA token_loop          ; And check that token
.3a0bbb					TKNEXTBIG
.3a0bbb	08		php		            PHP
.3a0bbc	0b		phd		            PHD
.3a0bbd	8b		phb		            PHB
.3a0bbe	08		php		            PHP
.3a0bbf	c2 20		rep #$20	            REP #$20
.3a0bc1	48		pha		            PHA
.3a0bc2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0bc5	5b		tcd		            TCD
.3a0bc6	68		pla		            PLA
.3a0bc7	28		plp		            PLP
.3a0bc8	c2 30		rep #$30	            REP #$30
.3a0bca	a9 fb 0c	lda #$0cfb	            LDA #<>TOKENS
.3a0bcd	85 08		sta $0808	            STA INDEX
.3a0bcf	a9 3a 00	lda #$003a	            LDA #`TOKENS
.3a0bd2	85 0a		sta $080a	            STA INDEX+2
.3a0bd4	64 0c		stz $080c	            STZ SCRATCH             ; Clear SCRATCH
.3a0bd6					loop
.3a0bd6	e2 20		sep #$20	            SEP #$20
.3a0bd8	a0 01 00	ldy #$0001	            LDY #TOKEN.length
.3a0bdb	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the length of the token
.3a0bdd	f0 1d		beq $3a0bfc	            BEQ done                ; If length is 0, we're done
.3a0bdf	c5 1e		cmp $081e	            CMP CURTOKLEN           ; Is it >= CURTOKLEN?
.3a0be1	b0 06		bcs $3a0be9	            BGE skip                ; Yes: skip to the next token
.3a0be3	c5 0c		cmp $080c	            CMP SCRATCH             ; No: is it < SCRATCH?
.3a0be5	90 02		bcc $3a0be9	            BLT skip                ; Yes: skip to the next token
.3a0be7	85 0c		sta $080c	            STA SCRATCH             ; No: it's our new longest token!
.3a0be9					skip
.3a0be9	c2 20		rep #$20	            REP #$20
.3a0beb	18		clc		            CLC
.3a0bec	a5 08		lda $0808	            LDA INDEX
.3a0bee	69 08 00	adc #$0008	            ADC #size(TOKEN)
.3a0bf1	85 08		sta $0808	            STA INDEX
.3a0bf3	a5 0a		lda $080a	            LDA INDEX+2
.3a0bf5	69 00 00	adc #$0000	            ADC #0
.3a0bf8	85 0a		sta $080a	            STA INDEX+2
.3a0bfa	80 da		bra $3a0bd6	            BRA loop                ; And go around for another pass
.3a0bfc					done
.3a0bfc	e2 20		sep #$20	            SEP #$20
.3a0bfe	a5 0c		lda $080c	            LDA SCRATCH
.3a0c00	85 1e		sta $081e	            STA CURTOKLEN
.3a0c02	ab		plb		            PLB
.3a0c03	2b		pld		            PLD
.3a0c04	28		plp		            PLP
.3a0c05	60		rts		            RTS
.3a0c06					TKWRITE
.3a0c06	08		php		            PHP
.3a0c07	0b		phd		            PHD
.3a0c08	08		php		            PHP
.3a0c09	c2 20		rep #$20	            REP #$20
.3a0c0b	48		pha		            PHA
.3a0c0c	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0c0f	5b		tcd		            TCD
.3a0c10	68		pla		            PLA
.3a0c11	28		plp		            PLP
.3a0c12	e2 20		sep #$20	            SEP #$20
.3a0c14	87 00		sta [$0800]	            STA [BIP]               ; Write the token to the line
.3a0c16	c2 20		rep #$20	            REP #$20
.3a0c18	18		clc		            CLC
.3a0c19	a5 00		lda $0800	            LDA BIP
.3a0c1b	69 01 00	adc #$0001	            ADC #1
.3a0c1e	85 08		sta $0808	            STA INDEX
.3a0c20	a5 02		lda $0802	            LDA BIP+2
.3a0c22	69 00 00	adc #$0000	            ADC #0
.3a0c25	85 0a		sta $080a	            STA INDEX+2
.3a0c27	e2 10		sep #$10	            SEP #$10
.3a0c29	a4 1e		ldy $081e	            LDY CURTOKLEN           ; Y will be the number of characters to move down
.3a0c2b	88		dey		            DEY
.3a0c2c					copy_down
.3a0c2c	e2 20		sep #$20	            SEP #$20
.3a0c2e	b7 08		lda [$0808],y	            LDA [INDEX],Y           ; Get the byte to move down
.3a0c30	87 08		sta [$0808]	            STA [INDEX]             ; Move it down
.3a0c32	f0 13		beq $3a0c47	            BEQ done                ; We've reached the end of the line
.3a0c34	c2 20		rep #$20	            REP #$20
.3a0c36	18		clc		            CLC
.3a0c37	a5 08		lda $0808	            LDA INDEX
.3a0c39	69 01 00	adc #$0001	            ADC #1
.3a0c3c	85 08		sta $0808	            STA INDEX
.3a0c3e	a5 0a		lda $080a	            LDA INDEX+2
.3a0c40	69 00 00	adc #$0000	            ADC #0
.3a0c43	85 0a		sta $080a	            STA INDEX+2
.3a0c45	80 e5		bra $3a0c2c	            BRA copy_down
.3a0c47	2b		pld		done        PLD
.3a0c48	28		plp		            PLP
.3a0c49	60		rts		            RTS
.3a0c4a					GETTOKREC
.3a0c4a	08		php		            PHP
.3a0c4b	c2 30		rep #$30	            REP #$30
.3a0c4d	29 7f 00	and #$007f	            AND #$007F
.3a0c50	0a		asl a		            ASL A
.3a0c51	0a		asl a		            ASL A
.3a0c52	0a		asl a		            ASL A
.3a0c53	18		clc		            CLC
.3a0c54	69 fb 0c	adc #$0cfb	            ADC #<>TOKENS
.3a0c57	aa		tax		            TAX                         ; X is now the data bank relative address of the token record
.3a0c58	28		plp		            PLP
.3a0c59	60		rts		            RTS
.3a0c5a					TOKPRECED
.3a0c5a	08		php		            PHP
.3a0c5b	8b		phb		            PHB
.3a0c5c	0b		phd		            PHD
.3a0c5d	08		php		            PHP
.3a0c5e	c2 20		rep #$20	            REP #$20
.3a0c60	48		pha		            PHA
.3a0c61	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0c64	5b		tcd		            TCD
.3a0c65	68		pla		            PLA
.3a0c66	28		plp		            PLP
.3a0c67	08		php		            PHP
.3a0c68	e2 20		sep #$20	            SEP #$20
.3a0c6a	48		pha		            PHA
.3a0c6b	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0c6d	48		pha		            PHA
.3a0c6e	ab		plb		            PLB
.3a0c6f	68		pla		            PLA
.3a0c70	28		plp		            PLP
.3a0c71	e2 20		sep #$20	            SEP #$20
.3a0c73	c2 10		rep #$10	            REP #$10
.3a0c75	20 4a 0c	jsr $3a0c4a	            JSR GETTOKREC
.3a0c78	bd 00 00	lda $3a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.3a0c7b	c2 20		rep #$20	            REP #$20
.3a0c7d	29 0f 00	and #$000f	            AND #$000F                  ; Mask off the type code
.3a0c80	2b		pld		            PLD
.3a0c81	ab		plb		            PLB
.3a0c82	28		plp		            PLP
.3a0c83	60		rts		            RTS
.3a0c84					TOKEVAL
.3a0c84	08		php		            PHP
.3a0c85	8b		phb		            PHB
.3a0c86	0b		phd		            PHD
.3a0c87	08		php		            PHP
.3a0c88	c2 20		rep #$20	            REP #$20
.3a0c8a	48		pha		            PHA
.3a0c8b	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0c8e	5b		tcd		            TCD
.3a0c8f	68		pla		            PLA
.3a0c90	28		plp		            PLP
.3a0c91	08		php		            PHP
.3a0c92	e2 20		sep #$20	            SEP #$20
.3a0c94	48		pha		            PHA
.3a0c95	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0c97	48		pha		            PHA
.3a0c98	ab		plb		            PLB
.3a0c99	68		pla		            PLA
.3a0c9a	28		plp		            PLP
.3a0c9b	c2 30		rep #$30	            REP #$30
.3a0c9d	20 4a 0c	jsr $3a0c4a	            JSR GETTOKREC
.3a0ca0	bd 04 00	lda $3a0004,x	            LDA #TOKEN.eval,B,X         ; Get the address of the evaluation function
.3a0ca3	2b		pld		            PLD
.3a0ca4	ab		plb		            PLB
.3a0ca5	28		plp		            PLP
.3a0ca6	60		rts		            RTS
.3a0ca7					TOKTYPE
.3a0ca7	08		php		            PHP
.3a0ca8	8b		phb		            PHB
.3a0ca9	0b		phd		            PHD
.3a0caa	08		php		            PHP
.3a0cab	c2 20		rep #$20	            REP #$20
.3a0cad	48		pha		            PHA
.3a0cae	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0cb1	5b		tcd		            TCD
.3a0cb2	68		pla		            PLA
.3a0cb3	28		plp		            PLP
.3a0cb4	08		php		            PHP
.3a0cb5	e2 20		sep #$20	            SEP #$20
.3a0cb7	48		pha		            PHA
.3a0cb8	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0cba	48		pha		            PHA
.3a0cbb	ab		plb		            PLB
.3a0cbc	68		pla		            PLA
.3a0cbd	28		plp		            PLP
.3a0cbe	e2 20		sep #$20	            SEP #$20
.3a0cc0	c2 10		rep #$10	            REP #$10
.3a0cc2	20 4a 0c	jsr $3a0c4a	            JSR GETTOKREC
.3a0cc5	bd 00 00	lda $3a0000,x	            LDA #TOKEN.precedence,B,X   ; Get the precedence
.3a0cc8	c2 20		rep #$20	            REP #$20
.3a0cca	29 f0 00	and #$00f0	            AND #$00F0                  ; Mask off the type code
.3a0ccd	2b		pld		            PLD
.3a0cce	ab		plb		            PLB
.3a0ccf	28		plp		            PLP
.3a0cd0	60		rts		            RTS
.3a0cd1					TOKARITY
.3a0cd1	08		php		            PHP
.3a0cd2	8b		phb		            PHB
.3a0cd3	0b		phd		            PHD
.3a0cd4	08		php		            PHP
.3a0cd5	c2 20		rep #$20	            REP #$20
.3a0cd7	48		pha		            PHA
.3a0cd8	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a0cdb	5b		tcd		            TCD
.3a0cdc	68		pla		            PLA
.3a0cdd	28		plp		            PLP
.3a0cde	08		php		            PHP
.3a0cdf	e2 20		sep #$20	            SEP #$20
.3a0ce1	48		pha		            PHA
.3a0ce2	a9 3a		lda #$3a	            LDA #`TOKENS
.3a0ce4	48		pha		            PHA
.3a0ce5	ab		plb		            PLB
.3a0ce6	68		pla		            PLA
.3a0ce7	28		plp		            PLP
.3a0ce8	e2 20		sep #$20	            SEP #$20
.3a0cea	c2 10		rep #$10	            REP #$10
.3a0cec	20 4a 0c	jsr $3a0c4a	            JSR GETTOKREC
.3a0cef	bd 06 00	lda $3a0006,x	            LDA #TOKEN.arity,B,X        ; Get the arity
.3a0cf2	c2 20		rep #$20	            REP #$20
.3a0cf4	29 ff 00	and #$00ff	            AND #$00FF
.3a0cf7	2b		pld		            PLD
.3a0cf8	ab		plb		            PLB
.3a0cf9	28		plp		            PLP
.3a0cfa	60		rts		            RTS
=$00					TOK_EOL = $00
=$01					TOK_FUNC_OPEN = $01     ; A pseudo-token to push to the operator stack to mark
=$00					TOK_TY_OP = $00         ; The token is an operator
=$10					TOK_TY_CMD = $10        ; The token is a command (e.g. RUN, LIST, etc.)
=$20					TOK_TY_STMNT = $20      ; The token is a statement (e.g. INPUT, PRINT, DIM, etc.)
=$30					TOK_TY_FUNC = $30       ; The token is a function (e.g. SIN, COS, TAB, etc.)
=$40					TOK_TY_PUNCT = $40      ; The token is a punctuation mark (e.g. "(", ")")
=$50					TOK_TY_BYWRD = $50      ; The token is a by-word (e.g. STEP, TO, WEND, etc.)
.3a0cfb					TOKENS
=$80					TOK_PLUS = $80
>3ad010	2b 00				TOKEN_TEXT  .null "+"
>3a0cfb	03				precedence  .byte TOK_TY_OP | 3
>3a0cfc	01				length      .byte len("+")
>3a0cfd	10 d0				name        .word <>TOKEN_TEXT
>3a0cff	df 27				eval        .word <>OP_PLUS
>3a0d01	02 00				arity       .word <>2
=$81					TOK_MINUS = $81
>3ad012	2d 00				TOKEN_TEXT  .null "-"
>3a0d03	03				precedence  .byte TOK_TY_OP | 3
>3a0d04	01				length      .byte len("-")
>3a0d05	12 d0				name        .word <>TOKEN_TEXT
>3a0d07	1f 28				eval        .word <>OP_MINUS
>3a0d09	02 00				arity       .word <>2
=$82					TOK_MULT = $82
>3ad014	2a 00				TOKEN_TEXT  .null "*"
>3a0d0b	02				precedence  .byte TOK_TY_OP | 2
>3a0d0c	01				length      .byte len("*")
>3a0d0d	14 d0				name        .word <>TOKEN_TEXT
>3a0d0f	56 28				eval        .word <>OP_MULTIPLY
>3a0d11	02 00				arity       .word <>2
=$83					TOK_DIVIDE = $83
>3ad016	2f 00				TOKEN_TEXT  .null "/"
>3a0d13	02				precedence  .byte TOK_TY_OP | 2
>3a0d14	01				length      .byte len("/")
>3a0d15	16 d0				name        .word <>TOKEN_TEXT
>3a0d17	8d 28				eval        .word <>OP_DIVIDE
>3a0d19	02 00				arity       .word <>2
=$84					TOK_MOD = $84
>3ad018	4d 4f 44 00			TOKEN_TEXT  .null "MOD"
>3a0d1b	02				precedence  .byte TOK_TY_OP | 2
>3a0d1c	03				length      .byte len("MOD")
>3a0d1d	18 d0				name        .word <>TOKEN_TEXT
>3a0d1f	97 28				eval        .word <>OP_MOD
>3a0d21	02 00				arity       .word <>2
>3ad01c	5e 00				TOKEN_TEXT  .null "^"
>3a0d23	00				precedence  .byte TOK_TY_OP | 0
>3a0d24	01				length      .byte len("^")
>3a0d25	1c d0				name        .word <>TOKEN_TEXT
>3a0d27	aa 28				eval        .word <>OP_POW
>3a0d29	02 00				arity       .word <>2
=$86					TOK_LE = $86
>3ad01e	3c 3d 00			TOKEN_TEXT  .null "<="
>3a0d2b	04				precedence  .byte TOK_TY_OP | 4
>3a0d2c	02				length      .byte len("<=")
>3a0d2d	1e d0				name        .word <>TOKEN_TEXT
>3a0d2f	68 2a				eval        .word <>OP_LTE
>3a0d31	02 00				arity       .word <>2
=$87					TOK_GE = $87
>3ad021	3e 3d 00			TOKEN_TEXT  .null ">="
>3a0d33	04				precedence  .byte TOK_TY_OP | 4
>3a0d34	02				length      .byte len(">=")
>3a0d35	21 d0				name        .word <>TOKEN_TEXT
>3a0d37	28 2a				eval        .word <>OP_GTE
>3a0d39	02 00				arity       .word <>2
=$88					TOK_NE = $88
>3ad024	3c 3e 00			TOKEN_TEXT  .null "<>"
>3a0d3b	04				precedence  .byte TOK_TY_OP | 4
>3a0d3c	02				length      .byte len("<>")
>3a0d3d	24 d0				name        .word <>TOKEN_TEXT
>3a0d3f	e8 29				eval        .word <>OP_NE
>3a0d41	02 00				arity       .word <>2
>3ad027	3c 00				TOKEN_TEXT  .null "<"
>3a0d43	04				precedence  .byte TOK_TY_OP | 4
>3a0d44	01				length      .byte len("<")
>3a0d45	27 d0				name        .word <>TOKEN_TEXT
>3a0d47	28 29				eval        .word <>OP_LT
>3a0d49	02 00				arity       .word <>2
=$8a					TOK_EQ = $8A
>3ad029	3d 00				TOKEN_TEXT  .null "="
>3a0d4b	04				precedence  .byte TOK_TY_OP | 4
>3a0d4c	01				length      .byte len("=")
>3a0d4d	29 d0				name        .word <>TOKEN_TEXT
>3a0d4f	a8 29				eval        .word <>OP_EQ
>3a0d51	02 00				arity       .word <>2
>3ad02b	3e 00				TOKEN_TEXT  .null ">"
>3a0d53	04				precedence  .byte TOK_TY_OP | 4
>3a0d54	01				length      .byte len(">")
>3a0d55	2b d0				name        .word <>TOKEN_TEXT
>3a0d57	68 29				eval        .word <>OP_GT
>3a0d59	02 00				arity       .word <>2
>3ad02d	4e 4f 54 00			TOKEN_TEXT  .null "NOT"
>3a0d5b	05				precedence  .byte TOK_TY_OP | 5
>3a0d5c	03				length      .byte len("NOT")
>3a0d5d	2d d0				name        .word <>TOKEN_TEXT
>3a0d5f	12 29				eval        .word <>OP_NOT
>3a0d61	01 00				arity       .word <>1
>3ad031	41 4e 44 00			TOKEN_TEXT  .null "AND"
>3a0d63	06				precedence  .byte TOK_TY_OP | 6
>3a0d64	03				length      .byte len("AND")
>3a0d65	31 d0				name        .word <>TOKEN_TEXT
>3a0d67	e4 28				eval        .word <>OP_AND
>3a0d69	02 00				arity       .word <>2
>3ad035	4f 52 00			TOKEN_TEXT  .null "OR"
>3a0d6b	07				precedence  .byte TOK_TY_OP | 7
>3a0d6c	02				length      .byte len("OR")
>3a0d6d	35 d0				name        .word <>TOKEN_TEXT
>3a0d6f	fb 28				eval        .word <>OP_OR
>3a0d71	02 00				arity       .word <>2
=$8f					TOK_LPAREN = $8F
>3ad038	28 00				TOKEN_TEXT  .null "("
>3a0d73	ff				precedence  .byte TOK_TY_PUNCT | $FF
>3a0d74	01				length      .byte len("(")
>3a0d75	38 d0				name        .word <>TOKEN_TEXT
>3a0d77	00 00				eval        .word <>0
>3a0d79	00 00				arity       .word <>0
=$90					TOK_RPAREN = $90
>3ad03a	29 00				TOKEN_TEXT  .null ")"
>3a0d7b	40				precedence  .byte TOK_TY_PUNCT | 0
>3a0d7c	01				length      .byte len(")")
>3a0d7d	3a d0				name        .word <>TOKEN_TEXT
>3a0d7f	00 00				eval        .word <>0
>3a0d81	00 00				arity       .word <>0
=$91					TOK_REM = $91
>3ad03c	52 45 4d 00			TOKEN_TEXT  .null "REM"
>3a0d83	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d84	03				length      .byte len("REM")
>3a0d85	3c d0				name        .word <>TOKEN_TEXT
>3a0d87	7b 41				eval        .word <>S_REM
>3a0d89	00 00				arity       .word <>0
=$92					TOK_PRINT = $92
>3ad040	50 52 49 4e 54 00		TOKEN_TEXT  .null "PRINT"
>3a0d8b	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d8c	05				length      .byte len("PRINT")
>3a0d8d	40 d0				name        .word <>TOKEN_TEXT
>3a0d8f	80 45				eval        .word <>S_PRINT
>3a0d91	00 00				arity       .word <>0
=$93					TOK_LET = $93
>3ad046	4c 45 54 00			TOKEN_TEXT  .null "LET"
>3a0d93	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d94	03				length      .byte len("LET")
>3a0d95	46 d0				name        .word <>TOKEN_TEXT
>3a0d97	cb 44				eval        .word <>S_LET
>3a0d99	00 00				arity       .word <>0
>3ad04a	47 4f 54 4f 00			TOKEN_TEXT  .null "GOTO"
>3a0d9b	20				precedence  .byte TOK_TY_STMNT | 0
>3a0d9c	04				length      .byte len("GOTO")
>3a0d9d	4a d0				name        .word <>TOKEN_TEXT
>3a0d9f	6b 44				eval        .word <>S_GOTO
>3a0da1	00 00				arity       .word <>0
=$95					TOK_END = $95
>3ad04f	45 4e 44 00			TOKEN_TEXT  .null "END"
>3a0da3	20				precedence  .byte TOK_TY_STMNT | 0
>3a0da4	03				length      .byte len("END")
>3a0da5	4f d0				name        .word <>TOKEN_TEXT
>3a0da7	62 44				eval        .word <>S_END
>3a0da9	00 00				arity       .word <>0
>3ad053	49 46 00			TOKEN_TEXT  .null "IF"
>3a0dab	20				precedence  .byte TOK_TY_STMNT | 0
>3a0dac	02				length      .byte len("IF")
>3a0dad	53 d0				name        .word <>TOKEN_TEXT
>3a0daf	fa 43				eval        .word <>S_IF
>3a0db1	00 00				arity       .word <>0
=$97					TOK_THEN = $97
>3ad056	54 48 45 4e 00			TOKEN_TEXT  .null "THEN"
>3a0db3	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0db4	04				length      .byte len("THEN")
>3a0db5	56 d0				name        .word <>TOKEN_TEXT
>3a0db7	00 00				eval        .word <>0
>3a0db9	00 00				arity       .word <>0
>3ad05b	45 4c 53 45 00			TOKEN_TEXT  .null "ELSE"
>3a0dbb	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0dbc	04				length      .byte len("ELSE")
>3a0dbd	5b d0				name        .word <>TOKEN_TEXT
>3a0dbf	00 00				eval        .word <>0
>3a0dc1	00 00				arity       .word <>0
>3ad060	47 4f 53 55 42 00		TOKEN_TEXT  .null "GOSUB"
>3a0dc3	20				precedence  .byte TOK_TY_STMNT | 0
>3a0dc4	05				length      .byte len("GOSUB")
>3a0dc5	60 d0				name        .word <>TOKEN_TEXT
>3a0dc7	3d 43				eval        .word <>S_GOSUB
>3a0dc9	00 00				arity       .word <>0
>3ad066	52 45 54 55 52 4e 00		TOKEN_TEXT  .null "RETURN"
>3a0dcb	20				precedence  .byte TOK_TY_STMNT | 0
>3a0dcc	06				length      .byte len("RETURN")
>3a0dcd	66 d0				name        .word <>TOKEN_TEXT
>3a0dcf	b6 43				eval        .word <>S_RETURN
>3a0dd1	00 00				arity       .word <>0
=$9b					TOK_FOR = $9B
>3ad06d	46 4f 52 00			TOKEN_TEXT  .null "FOR"
>3a0dd3	20				precedence  .byte TOK_TY_STMNT | 0
>3a0dd4	03				length      .byte len("FOR")
>3a0dd5	6d d0				name        .word <>TOKEN_TEXT
>3a0dd7	92 41				eval        .word <>S_FOR
>3a0dd9	00 00				arity       .word <>0
=$9c					TOK_TO = $9C
>3ad071	54 4f 00			TOKEN_TEXT  .null "TO"
>3a0ddb	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0ddc	02				length      .byte len("TO")
>3a0ddd	71 d0				name        .word <>TOKEN_TEXT
>3a0ddf	00 00				eval        .word <>0
>3a0de1	00 00				arity       .word <>0
=$9d					TOK_STEP = $9D
>3ad074	53 54 45 50 00			TOKEN_TEXT  .null "STEP"
>3a0de3	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0de4	04				length      .byte len("STEP")
>3a0de5	74 d0				name        .word <>TOKEN_TEXT
>3a0de7	00 00				eval        .word <>0
>3a0de9	00 00				arity       .word <>0
=$9e					TOK_NEXT = $9E
>3ad079	4e 45 58 54 00			TOKEN_TEXT  .null "NEXT"
>3a0deb	20				precedence  .byte TOK_TY_STMNT | 0
>3a0dec	04				length      .byte len("NEXT")
>3a0ded	79 d0				name        .word <>TOKEN_TEXT
>3a0def	86 42				eval        .word <>S_NEXT
>3a0df1	00 00				arity       .word <>0
=$9f					TOK_DO = $9F
>3ad07e	44 4f 00			TOKEN_TEXT  .null "DO"
>3a0df3	20				precedence  .byte TOK_TY_STMNT | 0
>3a0df4	02				length      .byte len("DO")
>3a0df5	7e d0				name        .word <>TOKEN_TEXT
>3a0df7	8c 41				eval        .word <>S_DO
>3a0df9	00 00				arity       .word <>0
=$a0					TOK_LOOP = $A0
>3ad081	4c 4f 4f 50 00			TOKEN_TEXT  .null "LOOP"
>3a0dfb	20				precedence  .byte TOK_TY_STMNT | 0
>3a0dfc	04				length      .byte len("LOOP")
>3a0dfd	81 d0				name        .word <>TOKEN_TEXT
>3a0dff	8f 41				eval        .word <>S_LOOP
>3a0e01	00 00				arity       .word <>0
>3ad086	57 48 49 4c 45 00		TOKEN_TEXT  .null "WHILE"
>3a0e03	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0e04	05				length      .byte len("WHILE")
>3a0e05	86 d0				name        .word <>TOKEN_TEXT
>3a0e07	00 00				eval        .word <>0
>3a0e09	00 00				arity       .word <>0
>3ad08c	55 4e 54 49 4c 00		TOKEN_TEXT  .null "UNTIL"
>3a0e0b	50				precedence  .byte TOK_TY_BYWRD | 0
>3a0e0c	05				length      .byte len("UNTIL")
>3a0e0d	8c d0				name        .word <>TOKEN_TEXT
>3a0e0f	00 00				eval        .word <>0
>3a0e11	00 00				arity       .word <>0
>3ad092	45 58 49 54 00			TOKEN_TEXT  .null "EXIT"
>3a0e13	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e14	04				length      .byte len("EXIT")
>3a0e15	92 d0				name        .word <>TOKEN_TEXT
>3a0e17	89 41				eval        .word <>S_EXIT
>3a0e19	00 00				arity       .word <>0
>3ad097	43 4c 52 00			TOKEN_TEXT  .null "CLR"
>3a0e1b	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e1c	03				length      .byte len("CLR")
>3a0e1d	97 d0				name        .word <>TOKEN_TEXT
>3a0e1f	c1 44				eval        .word <>S_CLR
>3a0e21	00 00				arity       .word <>0
>3ad09b	53 54 4f 50 00			TOKEN_TEXT  .null "STOP"
>3a0e23	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e24	04				length      .byte len("STOP")
>3a0e25	9b d0				name        .word <>TOKEN_TEXT
>3a0e27	5c 41				eval        .word <>S_STOP
>3a0e29	00 00				arity       .word <>0
>3ad0a0	50 4f 4b 45 00			TOKEN_TEXT  .null "POKE"
>3a0e2b	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e2c	04				length      .byte len("POKE")
>3a0e2d	a0 d0				name        .word <>TOKEN_TEXT
>3a0e2f	ec 40				eval        .word <>S_POKE
>3a0e31	00 00				arity       .word <>0
>3ad0a5	50 4f 4b 45 57 00		TOKEN_TEXT  .null "POKEW"
>3a0e33	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e34	05				length      .byte len("POKEW")
>3a0e35	a5 d0				name        .word <>TOKEN_TEXT
>3a0e37	82 40				eval        .word <>S_POKEW
>3a0e39	00 00				arity       .word <>0
>3ad0ab	50 4f 4b 45 4c 00		TOKEN_TEXT  .null "POKEL"
>3a0e3b	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e3c	05				length      .byte len("POKEL")
>3a0e3d	ab d0				name        .word <>TOKEN_TEXT
>3a0e3f	0f 40				eval        .word <>S_POKEL
>3a0e41	00 00				arity       .word <>0
>3ad0b1	43 4c 53 00			TOKEN_TEXT  .null "CLS"
>3a0e43	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e44	03				length      .byte len("CLS")
>3a0e45	b1 d0				name        .word <>TOKEN_TEXT
>3a0e47	0b 40				eval        .word <>S_CLS
>3a0e49	00 00				arity       .word <>0
>3ad0b5	52 45 41 44 00			TOKEN_TEXT  .null "READ"
>3a0e4b	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e4c	04				length      .byte len("READ")
>3a0e4d	b5 d0				name        .word <>TOKEN_TEXT
>3a0e4f	ec 3e				eval        .word <>S_READ
>3a0e51	00 00				arity       .word <>0
=$ab					TOK_DATA = $AB
>3ad0ba	44 41 54 41 00			TOKEN_TEXT  .null "DATA"
>3a0e53	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e54	04				length      .byte len("DATA")
>3a0e55	ba d0				name        .word <>TOKEN_TEXT
>3a0e57	fe 3f				eval        .word <>S_DATA
>3a0e59	00 00				arity       .word <>0
>3ad0bf	52 45 53 54 4f 52 45 00		TOKEN_TEXT  .null "RESTORE"
>3a0e5b	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e5c	07				length      .byte len("RESTORE")
>3a0e5d	bf d0				name        .word <>TOKEN_TEXT
>3a0e5f	02 40				eval        .word <>S_RESTORE
>3a0e61	00 00				arity       .word <>0
>3ad0c7	44 49 4d 00			TOKEN_TEXT  .null "DIM"
>3a0e63	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e64	03				length      .byte len("DIM")
>3a0e65	c7 d0				name        .word <>TOKEN_TEXT
>3a0e67	3f 3e				eval        .word <>S_DIM
>3a0e69	00 00				arity       .word <>0
>3ad0cb	43 41 4c 4c 00			TOKEN_TEXT  .null "CALL"
>3a0e6b	20				precedence  .byte TOK_TY_STMNT | 0
>3a0e6c	04				length      .byte len("CALL")
>3a0e6d	cb d0				name        .word <>TOKEN_TEXT
>3a0e6f	a8 3d				eval        .word <>S_CALL
>3a0e71	00 00				arity       .word <>0
=$af					TOK_NEGATIVE = $AF
>3ad0d0	2d 00				TOKEN_TEXT  .null "-"
>3a0e73	00				precedence  .byte TOK_TY_OP | 0
>3a0e74	01				length      .byte len("-")
>3a0e75	d0 d0				name        .word <>TOKEN_TEXT
>3a0e77	a8 2a				eval        .word <>OP_NEGATIVE
>3a0e79	01 00				arity       .word <>1
>3ad0d2	4c 45 4e 00			TOKEN_TEXT  .null "LEN"
>3a0e7b	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e7c	03				length      .byte len("LEN")
>3a0e7d	d2 d0				name        .word <>TOKEN_TEXT
>3a0e7f	98 4b				eval        .word <>FN_LEN
>3a0e81	00 00				arity       .word <>0
>3ad0d6	50 45 45 4b 00			TOKEN_TEXT  .null "PEEK"
>3a0e83	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e84	04				length      .byte len("PEEK")
>3a0e85	d6 d0				name        .word <>TOKEN_TEXT
>3a0e87	e8 4b				eval        .word <>FN_PEEK
>3a0e89	00 00				arity       .word <>0
>3ad0db	50 45 45 4b 57 00		TOKEN_TEXT  .null "PEEKW"
>3a0e8b	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e8c	05				length      .byte len("PEEKW")
>3a0e8d	db d0				name        .word <>TOKEN_TEXT
>3a0e8f	b1 4c				eval        .word <>FN_PEEKW
>3a0e91	00 00				arity       .word <>0
>3ad0e1	50 45 45 4b 4c 00		TOKEN_TEXT  .null "PEEKL"
>3a0e93	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e94	05				length      .byte len("PEEKL")
>3a0e95	e1 d0				name        .word <>TOKEN_TEXT
>3a0e97	3e 4c				eval        .word <>FN_PEEKL
>3a0e99	00 00				arity       .word <>0
>3ad0e7	43 48 52 24 00			TOKEN_TEXT  .null "CHR$"
>3a0e9b	30				precedence  .byte TOK_TY_FUNC | 0
>3a0e9c	04				length      .byte len("CHR$")
>3a0e9d	e7 d0				name        .word <>TOKEN_TEXT
>3a0e9f	10 4d				eval        .word <>FN_CHR
>3a0ea1	00 00				arity       .word <>0
>3ad0ec	41 53 43 00			TOKEN_TEXT  .null "ASC"
>3a0ea3	30				precedence  .byte TOK_TY_FUNC | 0
>3a0ea4	03				length      .byte len("ASC")
>3a0ea5	ec d0				name        .word <>TOKEN_TEXT
>3a0ea7	65 4d				eval        .word <>FN_ASC
>3a0ea9	00 00				arity       .word <>0
>3ad0f0	53 50 43 00			TOKEN_TEXT  .null "SPC"
>3a0eab	30				precedence  .byte TOK_TY_FUNC | 0
>3a0eac	03				length      .byte len("SPC")
>3a0ead	f0 d0				name        .word <>TOKEN_TEXT
>3a0eaf	aa 4d				eval        .word <>FN_SPC
>3a0eb1	00 00				arity       .word <>0
>3ad0f4	54 41 42 00			TOKEN_TEXT  .null "TAB"
>3a0eb3	30				precedence  .byte TOK_TY_FUNC | 0
>3a0eb4	03				length      .byte len("TAB")
>3a0eb5	f4 d0				name        .word <>TOKEN_TEXT
>3a0eb7	33 4e				eval        .word <>FN_TAB
>3a0eb9	00 00				arity       .word <>0
>3ad0f8	41 42 53 00			TOKEN_TEXT  .null "ABS"
>3a0ebb	30				precedence  .byte TOK_TY_FUNC | 0
>3a0ebc	03				length      .byte len("ABS")
>3a0ebd	f8 d0				name        .word <>TOKEN_TEXT
>3a0ebf	bc 4e				eval        .word <>FN_ABS
>3a0ec1	00 00				arity       .word <>0
>3ad0fc	53 47 4e 00			TOKEN_TEXT  .null "SGN"
>3a0ec3	30				precedence  .byte TOK_TY_FUNC | 0
>3a0ec4	03				length      .byte len("SGN")
>3a0ec5	fc d0				name        .word <>TOKEN_TEXT
>3a0ec7	1e 4f				eval        .word <>FN_SGN
>3a0ec9	00 00				arity       .word <>0
>3ad100	48 45 58 24 00			TOKEN_TEXT  .null "HEX$"
>3a0ecb	30				precedence  .byte TOK_TY_FUNC | 0
>3a0ecc	04				length      .byte len("HEX$")
>3a0ecd	00 d1				name        .word <>TOKEN_TEXT
>3a0ecf	0a 4b				eval        .word <>FN_HEX
>3a0ed1	00 00				arity       .word <>0
>3ad105	44 45 43 00			TOKEN_TEXT  .null "DEC"
>3a0ed3	30				precedence  .byte TOK_TY_FUNC | 0
>3a0ed4	03				length      .byte len("DEC")
>3a0ed5	05 d1				name        .word <>TOKEN_TEXT
>3a0ed7	a9 4a				eval        .word <>FN_DEC
>3a0ed9	00 00				arity       .word <>0
>3ad109	53 54 52 24 00			TOKEN_TEXT  .null "STR$"
>3a0edb	30				precedence  .byte TOK_TY_FUNC | 0
>3a0edc	04				length      .byte len("STR$")
>3a0edd	09 d1				name        .word <>TOKEN_TEXT
>3a0edf	5b 4a				eval        .word <>FN_STR
>3a0ee1	00 00				arity       .word <>0
>3ad10e	56 41 4c 00			TOKEN_TEXT  .null "VAL"
>3a0ee3	30				precedence  .byte TOK_TY_FUNC | 0
>3a0ee4	03				length      .byte len("VAL")
>3a0ee5	0e d1				name        .word <>TOKEN_TEXT
>3a0ee7	05 4a				eval        .word <>FN_VAL
>3a0ee9	00 00				arity       .word <>0
>3ad112	4c 45 46 54 24 00		TOKEN_TEXT  .null "LEFT$"
>3a0eeb	30				precedence  .byte TOK_TY_FUNC | 0
>3a0eec	05				length      .byte len("LEFT$")
>3a0eed	12 d1				name        .word <>TOKEN_TEXT
>3a0eef	3c 49				eval        .word <>FN_LEFT
>3a0ef1	00 00				arity       .word <>0
>3ad118	52 49 47 48 54 24 00		TOKEN_TEXT  .null "RIGHT$"
>3a0ef3	30				precedence  .byte TOK_TY_FUNC | 0
>3a0ef4	06				length      .byte len("RIGHT$")
>3a0ef5	18 d1				name        .word <>TOKEN_TEXT
>3a0ef7	5b 48				eval        .word <>FN_RIGHT
>3a0ef9	00 00				arity       .word <>0
>3ad11f	4d 49 44 24 00			TOKEN_TEXT  .null "MID$"
>3a0efb	30				precedence  .byte TOK_TY_FUNC | 0
>3a0efc	04				length      .byte len("MID$")
>3a0efd	1f d1				name        .word <>TOKEN_TEXT
>3a0eff	a6 47				eval        .word <>FN_MID
>3a0f01	00 00				arity       .word <>0
>3ad124	52 55 4e 00			TOKEN_TEXT  .null "RUN"
>3a0f03	10				precedence  .byte TOK_TY_CMD | 0
>3a0f04	03				length      .byte len("RUN")
>3a0f05	24 d1				name        .word <>TOKEN_TEXT
>3a0f07	85 50				eval        .word <>CMD_RUN
>3a0f09	00 00				arity       .word <>0
>3ad128	4e 45 57 00			TOKEN_TEXT  .null "NEW"
>3a0f0b	10				precedence  .byte TOK_TY_CMD | 0
>3a0f0c	03				length      .byte len("NEW")
>3a0f0d	28 d1				name        .word <>TOKEN_TEXT
>3a0f0f	50 50				eval        .word <>CMD_NEW
>3a0f11	00 00				arity       .word <>0
>3ad12c	4c 4f 41 44 00			TOKEN_TEXT  .null "LOAD"
>3a0f13	10				precedence  .byte TOK_TY_CMD | 0
>3a0f14	04				length      .byte len("LOAD")
>3a0f15	2c d1				name        .word <>TOKEN_TEXT
>3a0f17	59 6c				eval        .word <>CMD_LOAD
>3a0f19	00 00				arity       .word <>0
>3ad131	4c 49 53 54 00			TOKEN_TEXT  .null "LIST"
>3a0f1b	10				precedence  .byte TOK_TY_CMD | 0
>3a0f1c	04				length      .byte len("LIST")
>3a0f1d	31 d1				name        .word <>TOKEN_TEXT
>3a0f1f	9c 50				eval        .word <>CMD_LIST
>3a0f21	00 00				arity       .word <>0
>3ad136	44 49 52 00			TOKEN_TEXT  .null "DIR"
>3a0f23	10				precedence  .byte TOK_TY_CMD | 0
>3a0f24	03				length      .byte len("DIR")
>3a0f25	36 d1				name        .word <>TOKEN_TEXT
>3a0f27	80 69				eval        .word <>CMD_DIR
>3a0f29	00 00				arity       .word <>0
>3ad13a	42 4c 4f 41 44 00		TOKEN_TEXT  .null "BLOAD"
>3a0f2b	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f2c	05				length      .byte len("BLOAD")
>3a0f2d	3a d1				name        .word <>TOKEN_TEXT
>3a0f2f	2b 6b				eval        .word <>S_BLOAD
>3a0f31	00 00				arity       .word <>0
>3ad140	42 52 55 4e 00			TOKEN_TEXT  .null "BRUN"
>3a0f33	10				precedence  .byte TOK_TY_CMD | 0
>3a0f34	04				length      .byte len("BRUN")
>3a0f35	40 d1				name        .word <>TOKEN_TEXT
>3a0f37	06 6c				eval        .word <>CMD_BRUN
>3a0f39	00 00				arity       .word <>0
>3ad145	42 53 41 56 45 00		TOKEN_TEXT  .null "BSAVE"
>3a0f3b	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f3c	05				length      .byte len("BSAVE")
>3a0f3d	45 d1				name        .word <>TOKEN_TEXT
>3a0f3f	12 6d				eval        .word <>S_BSAVE
>3a0f41	00 00				arity       .word <>0
>3ad14b	44 45 4c 00			TOKEN_TEXT  .null "DEL"
>3a0f43	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f44	03				length      .byte len("DEL")
>3a0f45	4b d1				name        .word <>TOKEN_TEXT
>3a0f47	31 6e				eval        .word <>S_DEL
>3a0f49	00 00				arity       .word <>0
>3ad14f	53 41 56 45 00			TOKEN_TEXT  .null "SAVE"
>3a0f4b	10				precedence  .byte TOK_TY_CMD | 0
>3a0f4c	04				length      .byte len("SAVE")
>3a0f4d	4f d1				name        .word <>TOKEN_TEXT
>3a0f4f	9e 6d				eval        .word <>CMD_SAVE
>3a0f51	00 00				arity       .word <>0
>3ad154	52 45 4e 41 4d 45 00		TOKEN_TEXT  .null "RENAME"
>3a0f53	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f54	06				length      .byte len("RENAME")
>3a0f55	54 d1				name        .word <>TOKEN_TEXT
>3a0f57	a7 6e				eval        .word <>S_RENAME
>3a0f59	00 00				arity       .word <>0
>3ad15b	43 4f 50 59 00			TOKEN_TEXT  .null "COPY"
>3a0f5b	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f5c	04				length      .byte len("COPY")
>3a0f5d	5b d1				name        .word <>TOKEN_TEXT
>3a0f5f	cb 6f				eval        .word <>S_COPY
>3a0f61	00 00				arity       .word <>0
>3ad160	4d 4f 4e 49 54 4f 52 00		TOKEN_TEXT  .null "MONITOR"
>3a0f63	10				precedence  .byte TOK_TY_CMD | 0
>3a0f64	07				length      .byte len("MONITOR")
>3a0f65	60 d1				name        .word <>TOKEN_TEXT
>3a0f67	4d 50				eval        .word <>CMD_MONITOR
>3a0f69	00 00				arity       .word <>0
>3ad168	47 45 54 00			TOKEN_TEXT  .null "GET"
>3a0f6b	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f6c	03				length      .byte len("GET")
>3a0f6d	68 d1				name        .word <>TOKEN_TEXT
>3a0f6f	36 3d				eval        .word <>S_GET
>3a0f71	00 00				arity       .word <>0
>3ad16c	49 4e 50 55 54 00		TOKEN_TEXT  .null "INPUT"
>3a0f73	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f74	05				length      .byte len("INPUT")
>3a0f75	6c d1				name        .word <>TOKEN_TEXT
>3a0f77	46 3c				eval        .word <>S_INPUT
>3a0f79	00 00				arity       .word <>0
>3ad172	53 45 54 42 4f 52 44 45		TOKEN_TEXT  .null "SETBORDER"
>3ad17a	52 00
>3a0f7b	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f7c	09				length      .byte len("SETBORDER")
>3a0f7d	72 d1				name        .word <>TOKEN_TEXT
>3a0f7f	67 2c				eval        .word <>S_SETBORDER
>3a0f81	00 00				arity       .word <>0
>3ad17c	54 45 58 54 43 4f 4c 4f		TOKEN_TEXT  .null "TEXTCOLOR"
>3ad184	52 00
>3a0f83	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f84	09				length      .byte len("TEXTCOLOR")
>3a0f85	7c d1				name        .word <>TOKEN_TEXT
>3a0f87	f4 2b				eval        .word <>S_TEXTCOLOR
>3a0f89	00 00				arity       .word <>0
>3ad186	53 45 54 42 47 43 4f 4c		TOKEN_TEXT  .null "SETBGCOLOR"
>3ad18e	4f 52 00
>3a0f8b	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f8c	0a				length      .byte len("SETBGCOLOR")
>3a0f8d	86 d1				name        .word <>TOKEN_TEXT
>3a0f8f	24 2c				eval        .word <>S_SETBGCOLOR
>3a0f91	00 00				arity       .word <>0
>3ad191	53 45 54 44 41 54 45 00		TOKEN_TEXT  .null "SETDATE"
>3a0f93	20				precedence  .byte TOK_TY_STMNT | 0
>3a0f94	07				length      .byte len("SETDATE")
>3a0f95	91 d1				name        .word <>TOKEN_TEXT
>3a0f97	61 2b				eval        .word <>S_SETDATE
>3a0f99	00 00				arity       .word <>0
>3ad199	47 45 54 44 41 54 45 24		TOKEN_TEXT  .null "GETDATE$"
>3ad1a1	00
>3a0f9b	30				precedence  .byte TOK_TY_FUNC | 0
>3a0f9c	08				length      .byte len("GETDATE$")
>3a0f9d	99 d1				name        .word <>TOKEN_TEXT
>3a0f9f	5d 46				eval        .word <>F_GETDATE
>3a0fa1	00 00				arity       .word <>0
>3ad1a2	53 45 54 54 49 4d 45 00		TOKEN_TEXT  .null "SETTIME"
>3a0fa3	20				precedence  .byte TOK_TY_STMNT | 0
>3a0fa4	07				length      .byte len("SETTIME")
>3a0fa5	a2 d1				name        .word <>TOKEN_TEXT
>3a0fa7	f6 2a				eval        .word <>S_SETTIME
>3a0fa9	00 00				arity       .word <>0
>3ad1aa	47 45 54 54 49 4d 45 24		TOKEN_TEXT  .null "GETTIME$"
>3ad1b2	00
>3a0fab	30				precedence  .byte TOK_TY_FUNC | 0
>3a0fac	08				length      .byte len("GETTIME$")
>3a0fad	aa d1				name        .word <>TOKEN_TEXT
>3a0faf	c7 46				eval        .word <>F_GETTIME
>3a0fb1	00 00				arity       .word <>0
>3ad1b3	47 52 41 50 48 49 43 53		TOKEN_TEXT  .null "GRAPHICS"
>3ad1bb	00
>3a0fb3	20				precedence  .byte TOK_TY_STMNT | 0
>3a0fb4	08				length      .byte len("GRAPHICS")
>3a0fb5	b3 d1				name        .word <>TOKEN_TEXT
>3a0fb7	ac 2d				eval        .word <>S_GRAPHICS
>3a0fb9	00 00				arity       .word <>0
>3ad1bc	53 45 54 43 4f 4c 4f 52		TOKEN_TEXT  .null "SETCOLOR"
>3ad1c4	00
>3a0fbb	20				precedence  .byte TOK_TY_STMNT | 0
>3a0fbc	08				length      .byte len("SETCOLOR")
>3a0fbd	bc d1				name        .word <>TOKEN_TEXT
>3a0fbf	e0 2c				eval        .word <>S_SETCOLOR
>3a0fc1	00 00				arity       .word <>0
>3ad1c5	42 49 54 4d 41 50 00		TOKEN_TEXT  .null "BITMAP"
>3a0fc3	20				precedence  .byte TOK_TY_STMNT | 0
>3a0fc4	06				length      .byte len("BITMAP")
>3a0fc5	c5 d1				name        .word <>TOKEN_TEXT
>3a0fc7	e6 2e				eval        .word <>S_BITMAP
>3a0fc9	00 00				arity       .word <>0
>3ad1cc	43 4c 52 42 49 54 4d 41		TOKEN_TEXT  .null "CLRBITMAP"
>3ad1d4	50 00
>3a0fcb	20				precedence  .byte TOK_TY_STMNT | 0
>3a0fcc	09				length      .byte len("CLRBITMAP")
>3a0fcd	cc d1				name        .word <>TOKEN_TEXT
>3a0fcf	ee 2f				eval        .word <>S_CLRBITMAP
>3a0fd1	00 00				arity       .word <>0
>3ad1d6	50 4c 4f 54 00			TOKEN_TEXT  .null "PLOT"
>3a0fd3	20				precedence  .byte TOK_TY_STMNT | 0
>3a0fd4	04				length      .byte len("PLOT")
>3a0fd5	d6 d1				name        .word <>TOKEN_TEXT
>3a0fd7	4b 31				eval        .word <>S_PLOT
>3a0fd9	00 00				arity       .word <>0
>3ad1db	4c 49 4e 45 00			TOKEN_TEXT  .null "LINE"
>3a0fdb	20				precedence  .byte TOK_TY_STMNT | 0
>3a0fdc	04				length      .byte len("LINE")
>3a0fdd	db d1				name        .word <>TOKEN_TEXT
>3a0fdf	bc 31				eval        .word <>S_LINE
>3a0fe1	00 00				arity       .word <>0
>3ad1e0	46 49 4c 4c 00			TOKEN_TEXT  .null "FILL"
>3a0fe3	20				precedence  .byte TOK_TY_STMNT | 0
>3a0fe4	04				length      .byte len("FILL")
>3a0fe5	e0 d1				name        .word <>TOKEN_TEXT
>3a0fe7	55 32				eval        .word <>S_FILL
>3a0fe9	00 00				arity       .word <>0
>3ad1e5	53 50 52 49 54 45 00		TOKEN_TEXT  .null "SPRITE"
>3a0feb	20				precedence  .byte TOK_TY_STMNT | 0
>3a0fec	06				length      .byte len("SPRITE")
>3a0fed	e5 d1				name        .word <>TOKEN_TEXT
>3a0fef	91 33				eval        .word <>S_SPRITE
>3a0ff1	00 00				arity       .word <>0
>3ad1ec	53 50 52 49 54 45 41 54		TOKEN_TEXT  .null "SPRITEAT"
>3ad1f4	00
>3a0ff3	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ff4	08				length      .byte len("SPRITEAT")
>3a0ff5	ec d1				name        .word <>TOKEN_TEXT
>3a0ff7	2f 34				eval        .word <>S_SPRITEAT
>3a0ff9	00 00				arity       .word <>0
>3ad1f5	53 50 52 49 54 45 53 48		TOKEN_TEXT  .null "SPRITESHOW"
>3ad1fd	4f 57 00
>3a0ffb	20				precedence  .byte TOK_TY_STMNT | 0
>3a0ffc	0a				length      .byte len("SPRITESHOW")
>3a0ffd	f5 d1				name        .word <>TOKEN_TEXT
>3a0fff	7d 34				eval        .word <>S_SPRITESHOW
>3a1001	00 00				arity       .word <>0
>3ad200	54 49 4c 45 53 45 54 00		TOKEN_TEXT  .null "TILESET"
>3a1003	20				precedence  .byte TOK_TY_STMNT | 0
>3a1004	07				length      .byte len("TILESET")
>3a1005	00 d2				name        .word <>TOKEN_TEXT
>3a1007	b4 35				eval        .word <>S_TILESET
>3a1009	00 00				arity       .word <>0
>3ad208	54 49 4c 45 4d 41 50 00		TOKEN_TEXT  .null "TILEMAP"
>3a100b	20				precedence  .byte TOK_TY_STMNT | 0
>3a100c	07				length      .byte len("TILEMAP")
>3a100d	08 d2				name        .word <>TOKEN_TEXT
>3a100f	32 36				eval        .word <>S_TILEMAP
>3a1011	00 00				arity       .word <>0
>3ad210	54 49 4c 45 53 48 4f 57		TOKEN_TEXT  .null "TILESHOW"
>3ad218	00
>3a1013	20				precedence  .byte TOK_TY_STMNT | 0
>3a1014	08				length      .byte len("TILESHOW")
>3a1015	10 d2				name        .word <>TOKEN_TEXT
>3a1017	a4 36				eval        .word <>S_TILESHOW
>3a1019	00 00				arity       .word <>0
>3ad219	54 49 4c 45 41 54 00		TOKEN_TEXT  .null "TILEAT"
>3a101b	20				precedence  .byte TOK_TY_STMNT | 0
>3a101c	06				length      .byte len("TILEAT")
>3a101d	19 d2				name        .word <>TOKEN_TEXT
>3a101f	e1 36				eval        .word <>S_TILEAT
>3a1021	00 00				arity       .word <>0
>3ad220	4d 45 4d 43 4f 50 59 00		TOKEN_TEXT  .null "MEMCOPY"
>3a1023	20				precedence  .byte TOK_TY_STMNT | 0
>3a1024	07				length      .byte len("MEMCOPY")
>3a1025	20 d2				name        .word <>TOKEN_TEXT
>3a1027	11 3a				eval        .word <>S_MEMCOPY
>3a1029	00 00				arity       .word <>0
=$e6					TOK_LINEAR = $E6
>3ad228	4c 49 4e 45 41 52 00		TOKEN_TEXT  .null "LINEAR"
>3a102b	50				precedence  .byte TOK_TY_BYWRD | 0
>3a102c	06				length      .byte len("LINEAR")
>3a102d	28 d2				name        .word <>TOKEN_TEXT
>3a102f	00 00				eval        .word <>0
>3a1031	00 00				arity       .word <>0
=$e7					TOK_RECT = $E7
>3ad22f	52 45 43 54 00			TOKEN_TEXT  .null "RECT"
>3a1033	50				precedence  .byte TOK_TY_BYWRD | 0
>3a1034	04				length      .byte len("RECT")
>3a1035	2f d2				name        .word <>TOKEN_TEXT
>3a1037	00 00				eval        .word <>0
>3a1039	00 00				arity       .word <>0
>3ad234	4c 4f 43 41 54 45 00		TOKEN_TEXT  .null "LOCATE"
>3a103b	20				precedence  .byte TOK_TY_STMNT | 0
>3a103c	06				length      .byte len("LOCATE")
>3a103d	34 d2				name        .word <>TOKEN_TEXT
>3a103f	26 3c				eval        .word <>S_LOCATE
>3a1041	00 00				arity       .word <>0
>3ad23b	49 4e 54 00			TOKEN_TEXT  .null "INT"
>3a1043	30				precedence  .byte TOK_TY_FUNC | 0
>3a1044	03				length      .byte len("INT")
>3a1045	3b d2				name        .word <>TOKEN_TEXT
>3a1047	74 4f				eval        .word <>FN_INT
>3a1049	00 00				arity       .word <>0
>3ad23f	52 4e 44 00			TOKEN_TEXT  .null "RND"
>3a104b	30				precedence  .byte TOK_TY_FUNC | 0
>3a104c	03				length      .byte len("RND")
>3a104d	3f d2				name        .word <>TOKEN_TEXT
>3a104f	2c 47				eval        .word <>FN_RND
>3a1051	00 00				arity       .word <>0
>3ad243	53 49 4e 00			TOKEN_TEXT  .null "SIN"
>3a1053	30				precedence  .byte TOK_TY_FUNC | 0
>3a1054	03				length      .byte len("SIN")
>3a1055	43 d2				name        .word <>TOKEN_TEXT
>3a1057	87 4f				eval        .word <>FN_SIN
>3a1059	00 00				arity       .word <>0
>3ad247	43 4f 53 00			TOKEN_TEXT  .null "COS"
>3a105b	30				precedence  .byte TOK_TY_FUNC | 0
>3a105c	03				length      .byte len("COS")
>3a105d	47 d2				name        .word <>TOKEN_TEXT
>3a105f	9d 4f				eval        .word <>FN_COS
>3a1061	00 00				arity       .word <>0
>3ad24b	54 41 4e 00			TOKEN_TEXT  .null "TAN"
>3a1063	30				precedence  .byte TOK_TY_FUNC | 0
>3a1064	03				length      .byte len("TAN")
>3a1065	4b d2				name        .word <>TOKEN_TEXT
>3a1067	b3 4f				eval        .word <>FN_TAN
>3a1069	00 00				arity       .word <>0
>3ad24f	4c 4e 00			TOKEN_TEXT  .null "LN"
>3a106b	30				precedence  .byte TOK_TY_FUNC | 0
>3a106c	02				length      .byte len("LN")
>3a106d	4f d2				name        .word <>TOKEN_TEXT
>3a106f	c9 4f				eval        .word <>FN_LN
>3a1071	00 00				arity       .word <>0
>3ad252	41 43 4f 53 00			TOKEN_TEXT  .null "ACOS"
>3a1073	30				precedence  .byte TOK_TY_FUNC | 0
>3a1074	04				length      .byte len("ACOS")
>3a1075	52 d2				name        .word <>TOKEN_TEXT
>3a1077	df 4f				eval        .word <>FN_ACOS
>3a1079	00 00				arity       .word <>0
>3ad257	41 53 49 4e 00			TOKEN_TEXT  .null "ASIN"
>3a107b	30				precedence  .byte TOK_TY_FUNC | 0
>3a107c	04				length      .byte len("ASIN")
>3a107d	57 d2				name        .word <>TOKEN_TEXT
>3a107f	f5 4f				eval        .word <>FN_ASIN
>3a1081	00 00				arity       .word <>0
>3ad25c	41 54 41 4e 00			TOKEN_TEXT  .null "ATAN"
>3a1083	30				precedence  .byte TOK_TY_FUNC | 0
>3a1084	04				length      .byte len("ATAN")
>3a1085	5c d2				name        .word <>TOKEN_TEXT
>3a1087	0b 50				eval        .word <>FN_ATAN
>3a1089	00 00				arity       .word <>0
>3ad261	45 58 50 00			TOKEN_TEXT  .null "EXP"
>3a108b	30				precedence  .byte TOK_TY_FUNC | 0
>3a108c	03				length      .byte len("EXP")
>3a108d	61 d2				name        .word <>TOKEN_TEXT
>3a108f	21 50				eval        .word <>FN_EXP
>3a1091	00 00				arity       .word <>0
>3ad265	53 51 52 00			TOKEN_TEXT  .null "SQR"
>3a1093	30				precedence  .byte TOK_TY_FUNC | 0
>3a1094	03				length      .byte len("SQR")
>3a1095	65 d2				name        .word <>TOKEN_TEXT
>3a1097	37 50				eval        .word <>FN_SQR
>3a1099	00 00				arity       .word <>0
>3ad269	49 4e 4b 45 59 00		TOKEN_TEXT  .null "INKEY"
>3a109b	30				precedence  .byte TOK_TY_FUNC | 0
>3a109c	05				length      .byte len("INKEY")
>3a109d	69 d2				name        .word <>TOKEN_TEXT
>3a109f	82 47				eval        .word <>FN_INKEY
>3a10a1	00 00				arity       .word <>0
>3a10a3	00 00 00 00 00 00 00 00		            .word 0, 0, 0, 0

;******  Return to file: src\basic816.s


;******  Processing file: src\heap.s

>08b7					ALLOCATED   .long ?     ; Pointer to the most recently allocated object
>08ba					HEAP        .long ?     ; Pointer to the top of the heap (next empty byte)
>08bd					FREED       .long ?     ; Pointer to a linked list of freed heap objects
>08c0					CURRBLOCK   .long ?     ; Pointer to the current heap allocated block
>08c3					CURRHEADER  .long ?     ; Pointer to the header of the current block
>08c6					CURREND     .long ?     ; Pointer to the byte immediately after the current block
>08c9					CURRFREED   .long ?     ; Pointer to the current freed block
>08cc					FREEDEND    .long ?     ; Pointer to the byte immediately after the current freed block
>08cf					LASTFREED   .long ?     ;
.0000					HEAPOBJ
>0000					TYPE        .byte ?     ; Code for the type of object allocated
>0001					COUNT       .byte ?     ; Number of references to the heap object
>0002					NEXT        .long ?     ; Pointer to the next object in the list (used when freed)
>0005					END         .long ?     ; Pointer to the next byte after the block
.3a10ab					INITHEAP
.3a10ab	08		php		            PHP
.3a10ac	0b		phd		            PHD
.3a10ad	08		php		            PHP
.3a10ae	c2 20		rep #$20	            REP #$20
.3a10b0	48		pha		            PHA
.3a10b1	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a10b4	5b		tcd		            TCD
.3a10b5	68		pla		            PLA
.3a10b6	28		plp		            PLP
.3a10b7	c2 30		rep #$30	            REP #$30
.3a10b9	a9 ff ff	lda #$ffff	            LDA #<>HEAP_TOP         ; Set the HEAP to the top
.3a10bc	85 ba		sta $08ba	            STA HEAP
.3a10be	e2 20		sep #$20	            SEP #$20
.3a10c0	a9 37		lda #$37	            LDA #`HEAP_TOP
.3a10c2	85 bc		sta $08bc	            STA HEAP+2
.3a10c4	c2 20		rep #$20	            REP #$20
.3a10c6	64 b7		stz $08b7	            STZ ALLOCATED           ; And clear the pointer to the allocated objects
.3a10c8	64 bd		stz $08bd	            STZ FREED               ; as well as the list of freed objects
.3a10ca	e2 20		sep #$20	            SEP #$20
.3a10cc	64 b9		stz $08b9	            STZ ALLOCATED+2
.3a10ce	64 bf		stz $08bf	            STZ FREED+2
.3a10d0	2b		pld		            PLD
.3a10d1	28		plp		            PLP
.3a10d2	60		rts		            RTS
.3a10d3					ALLOC
.3a10d3	5a		phy		            PHY
.3a10d4	08		php		            PHP
.3a10d5	e2 20		sep #$20	            SEP #$20
.3a10d7	85 ea		sta $08ea	            STA TOFINDTYPE      ; Save the type of the block to TOFINDTYPE
.3a10d9	c2 10		rep #$10	            REP #$10
.3a10db	86 8f		stx $088f	            STX MCOUNT           ; And the length of the block needed to MCOUNT
.3a10dd	c2 20		rep #$20	            REP #$20
.3a10df	a5 0e		lda $080e	            LDA SCRATCH+2
.3a10e1	48		pha		            PHA
.3a10e2	a5 0c		lda $080c	            LDA SCRATCH
.3a10e4	48		pha		            PHA
.3a10e5	a5 12		lda $0812	            LDA SCRATCH2+2
.3a10e7	48		pha		            PHA
.3a10e8	a5 10		lda $0810	            LDA SCRATCH2
.3a10ea	48		pha		            PHA
.3a10eb	20 83 11	jsr $3a1183	            JSR ALLOCFREED
.3a10ee	b0 03		bcs $3a10f3	            BCS done            ; Return, if we got something back
.3a10f0	20 07 11	jsr $3a1107	            JSR ALLOCHEAP
.3a10f3					done
.3a10f3	20 0f 13	jsr $3a130f	            JSR HEAP_GETHED
.3a10f6	c2 20		rep #$20	            REP #$20
.3a10f8	68		pla		            PLA
.3a10f9	85 10		sta $0810	            STA SCRATCH2
.3a10fb	68		pla		            PLA
.3a10fc	85 12		sta $0812	            STA SCRATCH2+2
.3a10fe	68		pla		            PLA
.3a10ff	85 0c		sta $080c	            STA SCRATCH
.3a1101	68		pla		            PLA
.3a1102	85 0e		sta $080e	            STA SCRATCH+2
.3a1104	28		plp		            PLP
.3a1105	7a		ply		            PLY
.3a1106	60		rts		            RTS
.3a1107					ALLOCHEAP
.3a1107	08		php		            PHP
.3a1108	0b		phd		            PHD
.3a1109	08		php		            PHP
.3a110a	c2 20		rep #$20	            REP #$20
.3a110c	48		pha		            PHA
.3a110d	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1110	5b		tcd		            TCD
.3a1111	68		pla		            PLA
.3a1112	28		plp		            PLP
.3a1113	e2 20		sep #$20	            SEP #$20
.3a1115	a6 8f		ldx $088f	            LDX MCOUNT
.3a1117	ca		dex		            DEX
.3a1118	86 0c		stx $080c	            STX SCRATCH             ; SCRATCH := size - 1
.3a111a	e8		inx		            INX
.3a111b	c2 30		rep #$30	            REP #$30
.3a111d	38		sec		            SEC
.3a111e	a5 ba		lda $08ba	            LDA HEAP
.3a1120	e5 0c		sbc $080c	            SBC SCRATCH
.3a1122	85 c0		sta $08c0	            STA CURRBLOCK
.3a1124	e2 20		sep #$20	            SEP #$20
.3a1126	a5 bc		lda $08bc	            LDA HEAP+2
.3a1128	e9 00		sbc #$00	            SBC #0
.3a112a	85 c2		sta $08c2	            STA CURRBLOCK+2
.3a112c	20 0f 13	jsr $3a130f	            JSR HEAP_GETHED
.3a112f	e2 20		sep #$20	            SEP #$20
.3a1131	a5 ea		lda $08ea	            LDA TOFINDTYPE
.3a1133	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE       ; Set the type of the object
.3a1136	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1138	a9 00		lda #$00	            LDA #0                  ; Set the count to zero
.3a113a	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.3a113d	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a113f	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a1142	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1144	c2 20		rep #$20	            REP #$20
.3a1146	a9 00 00	lda #$0000	            LDA #0
.3a1149	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a114b	c2 20		rep #$20	            REP #$20
.3a114d	18		clc		            CLC
.3a114e	a5 ba		lda $08ba	            LDA HEAP
.3a1150	69 01 00	adc #$0001	            ADC #1
.3a1153	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; To get the address of the next byte
.3a1156	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y      ; after the block
.3a1158	e2 20		sep #$20	            SEP #$20
.3a115a	c8		iny		            INY
.3a115b	c8		iny		            INY
.3a115c	a5 bc		lda $08bc	            LDA HEAP+2
.3a115e	69 00		adc #$00	            ADC #0
.3a1160	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1162	c2 20		rep #$20	            REP #$20
.3a1164	a5 c0		lda $08c0	            LDA CURRBLOCK
.3a1166	85 b7		sta $08b7	            STA ALLOCATED
.3a1168	e2 20		sep #$20	            SEP #$20
.3a116a	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.3a116c	85 b9		sta $08b9	            STA ALLOCATED+2
.3a116e	c2 20		rep #$20	            REP #$20
.3a1170	38		sec		            SEC                     ; Move the HEAP pointer to the first free byte under the header
.3a1171	a5 c3		lda $08c3	            LDA CURRHEADER
.3a1173	e9 01 00	sbc #$0001	            SBC #1
.3a1176	85 ba		sta $08ba	            STA HEAP
.3a1178	e2 20		sep #$20	            SEP #$20
.3a117a	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a117c	e9 00		sbc #$00	            SBC #0
.3a117e	85 bc		sta $08bc	            STA HEAP+2
.3a1180	2b		pld		            PLD
.3a1181	28		plp		            PLP
.3a1182	60		rts		            RTS
.3a1183					ALLOCFREED
.3a1183	08		php		            PHP
.3a1184	0b		phd		            PHD
.3a1185	08		php		            PHP
.3a1186	c2 20		rep #$20	            REP #$20
.3a1188	48		pha		            PHA
.3a1189	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a118c	5b		tcd		            TCD
.3a118d	68		pla		            PLA
.3a118e	28		plp		            PLP
.3a118f	c2 30		rep #$30	            REP #$30
.3a1191	c2 20		rep #$20	            REP #$20
.3a1193	a5 bd		lda $08bd	            LDA FREED
.3a1195	85 c9		sta $08c9	            STA CURRFREED
.3a1197	e2 20		sep #$20	            SEP #$20
.3a1199	a5 bf		lda $08bf	            LDA FREED+2
.3a119b	85 cb		sta $08cb	            STA CURRFREED+2
.3a119d	a5 c9		lda $08c9	loop        LDA CURRFREED           ; Has anything been freed?
.3a119f	d0 17		bne $3a11b8	            BNE has_block           ; Yes: check to see if there's a big enough block
.3a11a1	e2 20		sep #$20	            SEP #$20
.3a11a3	a5 cb		lda $08cb	            LDA CURRFREED+2
.3a11a5	d0 11		bne $3a11b8	            BNE has_block           ; Yes: check to see if there's a big enough block
.3a11a7	c2 20		rep #$20	            REP #$20
.3a11a9	a9 00 00	lda #$0000	            LDA #<>0
.3a11ac	85 cf		sta $08cf	            STA LASTFREED
.3a11ae	e2 20		sep #$20	            SEP #$20
.3a11b0	a9 00		lda #$00	            LDA #`0
.3a11b2	85 d1		sta $08d1	            STA LASTFREED+2
.3a11b4	2b		pld		ret_false   PLD                     ; Return that we didn't find anything
.3a11b5	28		plp		            PLP
.3a11b6	18		clc		            CLC
.3a11b7	60		rts		            RTS
.3a11b8					has_block
.3a11b8	c2 20		rep #$20	            REP #$20
.3a11ba	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.3a11bd	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a11bf	85 cc		sta $08cc	            STA FREEDEND
.3a11c1	e2 20		sep #$20	            SEP #$20
.3a11c3	c8		iny		            INY
.3a11c4	c8		iny		            INY
.3a11c5	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a11c7	85 ce		sta $08ce	            STA FREEDEND+2
.3a11c9	c2 20		rep #$20	            REP #$20
.3a11cb	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required
.3a11cc	a5 c9		lda $08c9	            LDA CURRFREED
.3a11ce	65 8f		adc $088f	            ADC MCOUNT
.3a11d0	85 0c		sta $080c	            STA SCRATCH
.3a11d2	e2 20		sep #$20	            SEP #$20
.3a11d4	a5 cb		lda $08cb	            LDA CURRFREED+2
.3a11d6	69 00		adc #$00	            ADC #0
.3a11d8	85 0e		sta $080e	            STA SCRATCH+2
.3a11da	c2 20		rep #$20	            REP #$20
.3a11dc	18		clc		            CLC                         ; SCRATCH := CURRFREED + size of block required + size of header
.3a11dd	a5 0c		lda $080c	            LDA SCRATCH                 ; (that is, it's a pointer to the byte immediately after the block desired)
.3a11df	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)
.3a11e2	85 0c		sta $080c	            STA SCRATCH
.3a11e4	e2 20		sep #$20	            SEP #$20
.3a11e6	a5 0e		lda $080e	            LDA SCRATCH+2
.3a11e8	69 00		adc #$00	            ADC #0
.3a11ea	85 0e		sta $080e	            STA SCRATCH+2
.3a11ec	c2 20		rep #$20	            REP #$20
.3a11ee	a5 0c		lda $080c	            LDA SCRATCH                 ; Is SCRATCH == FREEDEND?
.3a11f0	c5 cc		cmp $08cc	            CMP FREEDEND
.3a11f2	d0 28		bne $3a121c	            BNE not_exact               ; No: check if this block is bigger than needed
.3a11f4	e2 20		sep #$20	            SEP #$20
.3a11f6	a5 0e		lda $080e	            LDA SCRATCH+2
.3a11f8	c5 ce		cmp $08ce	            CMP FREEDEND+2
.3a11fa	d0 20		bne $3a121c	            BNE not_exact
.3a11fc	c2 20		rep #$20	            REP #$20
.3a11fe	a5 cf		lda $08cf	            LDA LASTFREED               ; LASTFREED == 0?
.3a1200	d0 5d		bne $3a125f	            BNE adj_last1               ; No: point LASTFREED->NEXT to skip this block
.3a1202	e2 20		sep #$20	            SEP #$20
.3a1204	a5 d1		lda $08d1	            LDA LASTFREED+2
.3a1206	d0 57		bne $3a125f	            BNE adj_last1
.3a1208	c2 20		rep #$20	            REP #$20
.3a120a	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a120d	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a120f	85 bd		sta $08bd	            STA FREED
.3a1211	e2 20		sep #$20	            SEP #$20
.3a1213	c8		iny		            INY
.3a1214	c8		iny		            INY
.3a1215	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a1217	85 bf		sta $08bf	            STA FREED+2
.3a1219	4c c0 12	jmp $3a12c0	            JMP init_block              ; And return CURRFREED as our reallocated memory
.3a121c					not_exact
.3a121c	c2 20		rep #$20	            REP #$20
.3a121e	a5 0c		lda $080c	            LDA SCRATCH                 ; Add a buffer to the room needed
.3a1220	69 08 00	adc #$0008	            ADC #size(HEAPOBJ)          ; So we have room to track the memory still freed
.3a1223	85 10		sta $0810	            STA SCRATCH2
.3a1225	e2 20		sep #$20	            SEP #$20
.3a1227	a5 0e		lda $080e	            LDA SCRATCH+2
.3a1229	69 00		adc #$00	            ADC #0
.3a122b	85 12		sta $0812	            STA SCRATCH2+2
.3a122d	e2 20		sep #$20	            SEP #$20
.3a122f	a5 c6		lda $08c6	            LDA CURREND                 ; Is CURREND > SCRATCH2
.3a1231	c5 10		cmp $0810	            CMP SCRATCH2
.3a1233	b0 3e		bcs $3a1273	            BGE has_room                ; Yes: there is room in this block to allocate some memory
.3a1235	90 08		bcc $3a123f	            BLT try_next
.3a1237	c2 20		rep #$20	            REP #$20
.3a1239	a5 c6		lda $08c6	            LDA CURREND
.3a123b	c5 10		cmp $0810	            CMP SCRATCH2
.3a123d	b0 34		bcs $3a1273	            BGE has_room
.3a123f					try_next
.3a123f	c2 20		rep #$20	            REP #$20
.3a1241	a5 c9		lda $08c9	            LDA CURRFREED
.3a1243	85 cf		sta $08cf	            STA LASTFREED
.3a1245	e2 20		sep #$20	            SEP #$20
.3a1247	a5 cb		lda $08cb	            LDA CURRFREED+2
.3a1249	85 d1		sta $08d1	            STA LASTFREED+2
.3a124b	c2 20		rep #$20	            REP #$20
.3a124d	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a1250	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.3a1252	85 c9		sta $08c9	            STA CURRFREED
.3a1254	e2 20		sep #$20	            SEP #$20
.3a1256	c8		iny		            INY
.3a1257	c8		iny		            INY
.3a1258	b7 cf		lda [$08cf],y	            LDA [LASTFREED],Y
.3a125a	85 cb		sta $08cb	            STA CURRFREED+2
.3a125c	4c 9d 11	jmp $3a119d	            JMP loop                                    ; And try the next header
.3a125f					adj_last1
.3a125f	c2 20		rep #$20	            REP #$20
.3a1261	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := CURRFREED->NEXT
.3a1264	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a1266	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.3a1268	e2 20		sep #$20	            SEP #$20
.3a126a	c8		iny		            INY
.3a126b	c8		iny		            INY
.3a126c	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a126e	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.3a1270	4c c0 12	jmp $3a12c0	            JMP init_block              ; And get CURRFREED ready to return
.3a1273					has_room
.3a1273	c2 20		rep #$20	            REP #$20
.3a1275	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END            ; SCRATCH->END := CURRFREED->END
.3a1278	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a127a	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.3a127c	e2 20		sep #$20	            SEP #$20
.3a127e	c8		iny		            INY
.3a127f	c8		iny		            INY
.3a1280	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a1282	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.3a1284	c2 20		rep #$20	            REP #$20
.3a1286	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; CURREND->NEXT := CURRFREED->NEXT
.3a1289	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a128b	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.3a128d	e2 20		sep #$20	            SEP #$20
.3a128f	c8		iny		            INY
.3a1290	c8		iny		            INY
.3a1291	b7 c9		lda [$08c9],y	            LDA [CURRFREED],Y
.3a1293	97 0c		sta [$080c],y	            STA [SCRATCH],Y
.3a1295	c2 20		rep #$20	            REP #$20
.3a1297	a5 cf		lda $08cf	            LDA LASTFREED               ; Is this the first object we've examined?
.3a1299	d0 14		bne $3a12af	            BNE adj_last2               ; No: we'll need to adjust the previously examined block
.3a129b	e2 20		sep #$20	            SEP #$20
.3a129d	a5 cf		lda $08cf	            LDA LASTFREED
.3a129f	d0 0e		bne $3a12af	            BNE adj_last2
.3a12a1	c2 20		rep #$20	            REP #$20
.3a12a3	a5 0c		lda $080c	            LDA SCRATCH
.3a12a5	85 bd		sta $08bd	            STA FREED
.3a12a7	e2 20		sep #$20	            SEP #$20
.3a12a9	a5 0e		lda $080e	            LDA SCRATCH+2
.3a12ab	85 bf		sta $08bf	            STA FREED+2
.3a12ad	80 11		bra $3a12c0	            BRA init_block              ; ... and return the block we've sliced off
.3a12af					adj_last2
.3a12af	c2 20		rep #$20	            REP #$20
.3a12b1	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT           ; LASTFREED->NEXT := SCRATCH
.3a12b4	a5 0c		lda $080c	            LDA SCRATCH                 ; (point the previous freed block to the newly sliced
.3a12b6	97 cf		sta [$08cf],y	            STA [LASTFREED],Y           ;  off part of the current block)
.3a12b8	e2 20		sep #$20	            SEP #$20
.3a12ba	c8		iny		            INY
.3a12bb	c8		iny		            INY
.3a12bc	a5 0e		lda $080e	            LDA SCRATCH+2
.3a12be	97 cf		sta [$08cf],y	            STA [LASTFREED],Y
.3a12c0					init_block
.3a12c0	c2 20		rep #$20	            REP #$20
.3a12c2	a5 c9		lda $08c9	            LDA CURRFREED
.3a12c4	85 c3		sta $08c3	            STA CURRHEADER
.3a12c6	e2 20		sep #$20	            SEP #$20
.3a12c8	a5 cb		lda $08cb	            LDA CURRFREED+2
.3a12ca	85 c5		sta $08c5	            STA CURRHEADER+2
.3a12cc	c2 20		rep #$20	            REP #$20
.3a12ce	a5 c3		lda $08c3	            LDA CURRHEADER
.3a12d0	85 b7		sta $08b7	            STA ALLOCATED
.3a12d2	e2 20		sep #$20	            SEP #$20
.3a12d4	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a12d6	85 b9		sta $08b9	            STA ALLOCATED+2
.3a12d8	c2 20		rep #$20	            REP #$20
.3a12da	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END        ; Set CURRHEADER->END to the byte after the block
.3a12dd	a5 0c		lda $080c	            LDA SCRATCH
.3a12df	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a12e1	e2 20		sep #$20	            SEP #$20
.3a12e3	c8		iny		            INY
.3a12e4	c8		iny		            INY
.3a12e5	a5 0e		lda $080e	            LDA SCRATCH+2
.3a12e7	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a12e9	c2 20		rep #$20	            REP #$20
.3a12eb	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Set CURRHEADER->NEXT to NULL
.3a12ee	a9 00 00	lda #$0000	            LDA #0
.3a12f1	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a12f3	e2 20		sep #$20	            SEP #$20
.3a12f5	c8		iny		            INY
.3a12f6	c8		iny		            INY
.3a12f7	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a12f9	e2 20		sep #$20	            SEP #$20
.3a12fb	a5 ea		lda $08ea	            LDA TOFINDTYPE          ; Get the type code back
.3a12fd	e2 20		sep #$20	            SEP #$20
.3a12ff	a0 00 00	ldy #$0000	            LDY #HEAPOBJ.TYPE
.3a1302	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1304	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT      ; Set its reference count to 0
.3a1307	a9 00		lda #$00	            LDA #0
.3a1309	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a130b	2b		pld		done        PLD
.3a130c	28		plp		            PLP
.3a130d	38		sec		            SEC
.3a130e	60		rts		            RTS
.3a130f					HEAP_GETHED
.3a130f	08		php		            PHP
.3a1310	c2 20		rep #$20	            REP #$20
.3a1312	38		sec		            SEC
.3a1313	a5 c0		lda $08c0	            LDA CURRBLOCK
.3a1315	e9 08 00	sbc #$0008	            SBC #size(HEAPOBJ)
.3a1318	85 c3		sta $08c3	            STA CURRHEADER
.3a131a	e2 20		sep #$20	            SEP #$20
.3a131c	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.3a131e	e9 00		sbc #$00	            SBC #0
.3a1320	85 c5		sta $08c5	            STA CURRHEADER+2
.3a1322	28		plp		            PLP
.3a1323	60		rts		            RTS
.3a1324					HEAP_ADDREF
.3a1324	08		php		            PHP
.3a1325	e2 20		sep #$20	            SEP #$20
.3a1327	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a1329	f0 04		beq $3a132f	            BEQ chk_null
.3a132b	c9 38		cmp #$38	            CMP #`(HEAP_TOP + 1)
.3a132d	b0 12		bcs $3a1341	            BGE out_of_bnds
.3a132f					chk_null
.3a132f	c2 20		rep #$20	            REP #$20
.3a1331	a5 c3		lda $08c3	            LDA CURRHEADER
.3a1333	f0 0c		beq $3a1341	            BEQ out_of_bnds
.3a1335					is_ok
.3a1335	e2 20		sep #$20	            SEP #$20
.3a1337	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT
.3a133a	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a133c	1a		inc a		            INC A
.3a133d	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a133f	28		plp		            PLP
.3a1340	60		rts		            RTS
.3a1341	00		brk #		out_of_bnds BRK
.3a1342	ea		nop		            NOP
.3a1343					HEAP_REMREF
.3a1343	08		php		            PHP
.3a1344	e2 20		sep #$20	            SEP #$20
.3a1346	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a1348	f0 04		beq $3a134e	            BEQ chk_null
.3a134a	c9 38		cmp #$38	            CMP #`(HEAP_TOP + 1)
.3a134c	b0 17		bcs $3a1365	            BGE out_of_bnds
.3a134e					chk_null
.3a134e	c2 20		rep #$20	            REP #$20
.3a1350	a5 c3		lda $08c3	            LDA CURRHEADER
.3a1352	f0 11		beq $3a1365	            BEQ out_of_bnds
.3a1354	e2 20		sep #$20	            SEP #$20
.3a1356	a0 01 00	ldy #$0001	            LDY #HEAPOBJ.COUNT  ; Decrement the reference count
.3a1359	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a135b	3a		dec a		            DEC A
.3a135c	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a135e	d0 03		bne $3a1363	            BNE done            ; If it's still >0, we are done
.3a1360	20 67 13	jsr $3a1367	            JSR HEAP_FREE
.3a1363	28		plp		done        PLP
.3a1364	60		rts		            RTS
.3a1365	00		brk #		out_of_bnds BRK
.3a1366	ea		nop		            NOP
.3a1367					HEAP_FREE
.3a1367	08		php		            PHP
.3a1368	c2 20		rep #$20	            REP #$20
.3a136a	a5 bd		lda $08bd	            LDA FREED           ; Check to see if blocks are already on the freed list
.3a136c	d0 21		bne $3a138f	            BNE has_objects
.3a136e	e2 20		sep #$20	            SEP #$20
.3a1370	a5 bf		lda $08bf	            LDA FREED+2
.3a1372	d0 1b		bne $3a138f	            BNE has_objects
.3a1374	a5 c5		lda $08c5	            LDA CURRHEADER+2    ; No: this block is the first one
.3a1376	85 bf		sta $08bf	            STA FREED+2         ; Just make it the freed list
.3a1378	c2 20		rep #$20	            REP #$20
.3a137a	a5 c3		lda $08c3	            LDA CURRHEADER
.3a137c	85 bd		sta $08bd	            STA FREED
.3a137e	a9 00 00	lda #$0000	            LDA #0
.3a1381	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT   ; And clear its next link
.3a1384	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1386	c8		iny		            INY
.3a1387	c8		iny		            INY
.3a1388	e2 20		sep #$20	            SEP #$20
.3a138a	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a138c	4c 4e 14	jmp $3a144e	            JMP done
.3a138f					has_objects
.3a138f	e2 20		sep #$20	            SEP #$20
.3a1391	a5 bf		lda $08bf	            LDA FREED+2
.3a1393	c5 c5		cmp $08c5	            CMP CURRHEADER+2
.3a1395	90 28		bcc $3a13bf	            BLT start_scan
.3a1397	c2 20		rep #$20	            REP #$20
.3a1399	a5 bd		lda $08bd	            LDA FREED
.3a139b	c5 c3		cmp $08c3	            CMP CURRHEADER
.3a139d	90 20		bcc $3a13bf	            BLT start_scan
.3a139f					ins_first
.3a139f	c2 20		rep #$20	            REP #$20
.3a13a1	a5 bd		lda $08bd	            LDA FREED               ; CURRHEADER->NEXT := FREED
.3a13a3	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a13a6	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a13a8	e2 20		sep #$20	            SEP #$20
.3a13aa	c8		iny		            INY
.3a13ab	c8		iny		            INY
.3a13ac	a5 bf		lda $08bf	            LDA FREED+2
.3a13ae	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a13b0	c2 20		rep #$20	            REP #$20
.3a13b2	a5 c3		lda $08c3	            LDA CURRHEADER
.3a13b4	85 bd		sta $08bd	            STA FREED
.3a13b6	e2 20		sep #$20	            SEP #$20
.3a13b8	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a13ba	85 bf		sta $08bf	            STA FREED+2
.3a13bc	4c 4e 14	jmp $3a144e	            JMP done
.3a13bf					start_scan
.3a13bf	c2 20		rep #$20	            REP #$20
.3a13c1	a5 bd		lda $08bd	            LDA FREED
.3a13c3	85 08		sta $0808	            STA INDEX
.3a13c5	e2 20		sep #$20	            SEP #$20
.3a13c7	a5 bf		lda $08bf	            LDA FREED+2
.3a13c9	85 0a		sta $080a	            STA INDEX+2
.3a13cb					loop
.3a13cb	e2 20		sep #$20	            SEP #$20
.3a13cd	a0 04 00	ldy #$0004	            LDY #HEAPOBJ.NEXT+2
.3a13d0	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a13d2	c5 c8		cmp $08c8	            CMP CURREND+2
.3a13d4	90 32		bcc $3a1408	            BLT go_next             ; No: check the next spot
.3a13d6	d0 0b		bne $3a13e3	            BNE ins_next
.3a13d8	c2 20		rep #$20	            REP #$20
.3a13da	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a13dd	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a13df	c5 c6		cmp $08c6	            CMP CURREND
.3a13e1	90 25		bcc $3a1408	            BLT go_next             ; No: check the next spot
.3a13e3					ins_next
.3a13e3	c2 20		rep #$20	            REP #$20
.3a13e5	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := INDEX->NEXT
.3a13e8	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a13ea	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a13ec	e2 20		sep #$20	            SEP #$20
.3a13ee	c8		iny		            INY
.3a13ef	c8		iny		            INY
.3a13f0	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a13f2	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a13f4	c2 20		rep #$20	            REP #$20
.3a13f6	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.3a13f8	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a13fb	97 08		sta [$0808],y	            STA [INDEX],Y
.3a13fd	e2 20		sep #$20	            SEP #$20
.3a13ff	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a1401	c8		iny		            INY
.3a1402	c8		iny		            INY
.3a1403	97 08		sta [$0808],y	            STA [INDEX],Y
.3a1405	4c 4e 14	jmp $3a144e	            JMP done
.3a1408					go_next
.3a1408	c2 20		rep #$20	            REP #$20
.3a140a	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; Is INDEX->NEXT = 0
.3a140d	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a140f	d0 08		bne $3a1419	            BNE not_at_end          ; No: load up the next object
.3a1411	e2 20		sep #$20	            SEP #$20
.3a1413	c8		iny		            INY
.3a1414	c8		iny		            INY
.3a1415	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a1417	f0 19		beq $3a1432	            BEQ at_end
.3a1419					not_at_end
.3a1419	c2 20		rep #$20	            REP #$20
.3a141b	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; INDEX := INDEX->NEXT
.3a141e	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a1420	85 0c		sta $080c	            STA SCRATCH
.3a1422	e2 20		sep #$20	            SEP #$20
.3a1424	c8		iny		            INY
.3a1425	c8		iny		            INY
.3a1426	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a1428	85 0a		sta $080a	            STA INDEX+2
.3a142a	c2 20		rep #$20	            REP #$20
.3a142c	a5 0c		lda $080c	            LDA SCRATCH
.3a142e	85 08		sta $0808	            STA INDEX
.3a1430	80 99		bra $3a13cb	            BRA loop
.3a1432					at_end
.3a1432	c2 20		rep #$20	            REP #$20
.3a1434	a5 c3		lda $08c3	            LDA CURRHEADER           ; INDEX->NEXT := CURRHEADER
.3a1436	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a1439	97 08		sta [$0808],y	            STA [INDEX],Y
.3a143b	e2 20		sep #$20	            SEP #$20
.3a143d	c8		iny		            INY
.3a143e	c8		iny		            INY
.3a143f	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a1441	97 08		sta [$0808],y	            STA [INDEX],Y
.3a1443	a9 00		lda #$00	            LDA #0                  ; CURRHEADER->NEXT := 0
.3a1445	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a1447	c2 20		rep #$20	            REP #$20
.3a1449	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a144c	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a144e					done
.3a144e	20 53 14	jsr $3a1453	            JSR COALLESCE
.3a1451	28		plp		            PLP
.3a1452	60		rts		            RTS
.3a1453					COALLESCE
.3a1453	08		php		            PHP
.3a1454	c2 20		rep #$20	            REP #$20
.3a1456	a5 bd		lda $08bd	            LDA FREED
.3a1458	85 c3		sta $08c3	            STA CURRHEADER
.3a145a	e2 20		sep #$20	            SEP #$20
.3a145c	a5 bf		lda $08bf	            LDA FREED+2
.3a145e	85 c5		sta $08c5	            STA CURRHEADER+2
.3a1460					next_head
.3a1460	c2 20		rep #$20	            REP #$20
.3a1462	a5 c3		lda $08c3	            LDA CURRHEADER          ; Is CURRHEADER == 0?
.3a1464	d0 09		bne $3a146f	            BNE check_next          ; No: check if NEXT is contiguous
.3a1466	e2 20		sep #$20	            SEP #$20
.3a1468	a5 c5		lda $08c5	            LDA CURRHEADER+2
.3a146a	d0 03		bne $3a146f	            BNE check_next
.3a146c	4c f6 14	jmp $3a14f6	            JMP done                ; Yes: we're done
.3a146f					check_next
.3a146f	c2 20		rep #$20	            REP #$20
.3a1471	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a1474	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a1476	85 0c		sta $080c	            STA SCRATCH
.3a1478	e2 20		sep #$20	            SEP #$20
.3a147a	c8		iny		            INY
.3a147b	c8		iny		            INY
.3a147c	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a147e	85 0e		sta $080e	            STA SCRATCH+2
.3a1480	c2 20		rep #$20	            REP #$20
.3a1482	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END
.3a1485	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a1487	85 10		sta $0810	            STA SCRATCH2
.3a1489	e2 20		sep #$20	            SEP #$20
.3a148b	c8		iny		            INY
.3a148c	c8		iny		            INY
.3a148d	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a148f	85 12		sta $0812	            STA SCRATCH2+2
.3a1491	c2 20		rep #$20	            REP #$20
.3a1493	a5 0c		lda $080c	            LDA SCRATCH
.3a1495	c5 10		cmp $0810	            CMP SCRATCH2            ; Is CURRHEADER->END = CURRHEADER->NEXT?
.3a1497	d0 08		bne $3a14a1	            BNE go_next             ; No: go to the next block
.3a1499	e2 20		sep #$20	            SEP #$20
.3a149b	a5 0e		lda $080e	            LDA SCRATCH+2
.3a149d	c5 12		cmp $0812	            CMP SCRATCH2+2
.3a149f	f0 1f		beq $3a14c0	            BEQ combine             ; Yes: combine the two blocks
.3a14a1					go_next
.3a14a1	c2 20		rep #$20	            REP #$20
.3a14a3	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a14a6	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a14a8	85 0c		sta $080c	            STA SCRATCH
.3a14aa	e2 20		sep #$20	            SEP #$20
.3a14ac	c8		iny		            INY
.3a14ad	c8		iny		            INY
.3a14ae	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a14b0	85 0e		sta $080e	            STA SCRATCH+2
.3a14b2	c2 20		rep #$20	            REP #$20
.3a14b4	a5 0c		lda $080c	            LDA SCRATCH
.3a14b6	85 c3		sta $08c3	            STA CURRHEADER
.3a14b8	e2 20		sep #$20	            SEP #$20
.3a14ba	a5 0e		lda $080e	            LDA SCRATCH+2
.3a14bc	85 c5		sta $08c5	            STA CURRHEADER+2
.3a14be	80 a0		bra $3a1460	            BRA next_head                               ; And loop back to next_head
.3a14c0					combine
.3a14c0	c2 20		rep #$20	            REP #$20
.3a14c2	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT
.3a14c5	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a14c7	85 0c		sta $080c	            STA SCRATCH
.3a14c9	e2 20		sep #$20	            SEP #$20
.3a14cb	c8		iny		            INY
.3a14cc	c8		iny		            INY
.3a14cd	b7 c3		lda [$08c3],y	            LDA [CURRHEADER],Y
.3a14cf	85 0e		sta $080e	            STA SCRATCH+2
.3a14d1	c2 20		rep #$20	            REP #$20
.3a14d3	a0 02 00	ldy #$0002	            LDY #HEAPOBJ.NEXT       ; CURRHEADER->NEXT := SCRATCH->NEXT
.3a14d6	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.3a14d8	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a14da	e2 20		sep #$20	            SEP #$20
.3a14dc	c8		iny		            INY
.3a14dd	c8		iny		            INY
.3a14de	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.3a14e0	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a14e2	c2 20		rep #$20	            REP #$20
.3a14e4	a0 05 00	ldy #$0005	            LDY #HEAPOBJ.END       ; CURRHEADER->END := SCRATCH->END
.3a14e7	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.3a14e9	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a14eb	e2 20		sep #$20	            SEP #$20
.3a14ed	c8		iny		            INY
.3a14ee	c8		iny		            INY
.3a14ef	b7 0c		lda [$080c],y	            LDA [SCRATCH],Y
.3a14f1	97 c3		sta [$08c3],y	            STA [CURRHEADER],Y
.3a14f3	4c 6f 14	jmp $3a146f	            JMP check_next          ; And loop back to check_next
.3a14f6	28		plp		done        PLP
.3a14f7	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\strings.s

.3a14f8					CLRTMPSTR
.3a14f8	08		php		            PHP
.3a14f9	c2 20		rep #$20	            REP #$20
.3a14fb	64 16		stz $0816	            STZ STRPTR
.3a14fd	64 18		stz $0818	            STZ STRPTR+2
.3a14ff	28		plp		            PLP
.3a1500	60		rts		            RTS
.3a1501					TEMPSTRING
.3a1501	08		php		            PHP
.3a1502	c2 30		rep #$30	            REP #$30
.3a1504	a5 16		lda $0816	            LDA STRPTR          ; Is STRPTR == 0?
.3a1506	d0 16		bne $3a151e	            BNE add_256         ; No: add 256 to it
.3a1508	a5 18		lda $0818	            LDA STRPTR+2
.3a150a	d0 12		bne $3a151e	            BNE add_256
.3a150c	e2 20		sep #$20	            SEP #$20
.3a150e	64 16		stz $0816	            STZ STRPTR
.3a1510	a5 e2		lda $08e2	            LDA NEXTVAR+1
.3a1512	1a		inc a		            INC A
.3a1513	1a		inc a		            INC A
.3a1514	85 17		sta $0817	            STA STRPTR+1
.3a1516	a5 e3		lda $08e3	            LDA NEXTVAR+2
.3a1518	85 18		sta $0818	            STA STRPTR+2
.3a151a	64 19		stz $0819	            STZ STRPTR+3
.3a151c	80 07		bra $3a1525	            BRA chk_room
.3a151e					add_256
.3a151e	c2 20		rep #$20	            REP #$20
.3a1520	a5 17		lda $0817	            LDA STRPTR+1        ; There was already a temporary string...
.3a1522	1a		inc a		            INC A               ; Leave 256 bytes for it
.3a1523	85 17		sta $0817	            STA STRPTR+1
.3a1525					chk_room
.3a1525	c2 20		rep #$20	            REP #$20
.3a1527	a5 bb		lda $08bb	            LDA HEAP+1          ; Check to make sure that STRPTR and HEAP haven't touched
.3a1529	3a		dec a		            DEC A
.3a152a	c5 17		cmp $0817	            CMP STRPTR+1
.3a152c	f0 02		beq $3a1530	            BEQ no_room         ; If they have, throw an error
.3a152e	b0 1f		bcs $3a154f	            BGE done
.3a1530					no_room
.3a1530	08		php		            PHP
.3a1531	c2 20		rep #$20	            REP #$20
.3a1533	48		pha		            PHA
.3a1534	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1537	5b		tcd		            TCD
.3a1538	68		pla		            PLA
.3a1539	28		plp		            PLP
.3a153a	e2 20		sep #$20	            SEP #$20
.3a153c	a9 03		lda #$03	            LDA #ERR_MEMORY
.3a153e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1542	c2 20		rep #$20	            REP #$20
.3a1544	29 ff 00	and #$00ff	            AND #$00FF
.3a1547	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a154a	e2 20		sep #$20	            SEP #$20
.3a154c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a154f	28		plp		done        PLP
.3a1550	60		rts		            RTS
.3a1551					ITOS_DIGIT
.3a1551	c9 00		cmp #$00	            CMP #0          ; Is it 0?
.3a1553	d0 05		bne $3a155a	            BNE add_digit   ; No: go ahead and add it
.3a1555	c0 01 00	cpy #$0001	            CPY #1          ; Are we on the first digit?
.3a1558	f0 05		beq $3a155f	            BEQ done        ; Yes: ignore this leading 0
.3a155a	09 30		ora #$30	add_digit   ORA #$30        ; Convert it to ASCII
.3a155c	97 16		sta [$0816],y	            STA [STRPTR],Y  ; Save it to the string
.3a155e	c8		iny		            INY             ; And point to the next location
.3a155f					done
.3a155f	60		rts		            RTS
.3a1560					ITOS
.3a1560	08		php		            PHP
.3a1561	c2 30		rep #$30	            REP #$30
.3a1563	64 0c		stz $080c	            STZ SCRATCH         ; Use scratch to store if negative
.3a1565	a5 25		lda $0825	            LDA ARGUMENT1+2     ; Check to see if the number is negative
.3a1567	10 1a		bpl $3a1583	            BPL start_cnvt
.3a1569	18		clc		            CLC                 ; Yes: make ARGUMENT1 positive
.3a156a	a5 23		lda $0823	            LDA ARGUMENT1
.3a156c	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a156f	69 01 00	adc #$0001	            ADC #1
.3a1572	85 23		sta $0823	            STA ARGUMENT1
.3a1574	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a1576	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a1579	69 00 00	adc #$0000	            ADC #0
.3a157c	85 25		sta $0825	            STA ARGUMENT1+2
.3a157e	a9 ff ff	lda #$ffff	            LDA #$FFFF          ; Record that the number was negative
.3a1581	85 0c		sta $080c	            STA SCRATCH
.3a1583					start_cnvt
.3a1583	64 10		stz $0810	            STZ SCRATCH2        ; SCRATCH2 will be our BCD version of the number
.3a1585	64 12		stz $0812	            STZ SCRATCH2+2
.3a1587	64 14		stz $0814	            STZ SCRATCH2+4
.3a1589	a2 1f 00	ldx #$001f	            LDX #31
.3a158c	f8		sed		            SED                 ; Yes, we're really using BCD mode
.3a158d	06 23		asl $0823	shift_loop  ASL ARGUMENT1       ; Shift ARGUMENT1 left one bit
.3a158f	26 25		rol $0825	            ROL ARGUMENT1+2
.3a1591	a5 10		lda $0810	            LDA SCRATCH2        ; SCRATCH2 := SCRATCH2 + SCRATCH2 + Carry
.3a1593	65 10		adc $0810	            ADC SCRATCH2
.3a1595	85 10		sta $0810	            STA SCRATCH2
.3a1597	a5 12		lda $0812	            LDA SCRATCH2+2
.3a1599	65 12		adc $0812	            ADC SCRATCH2+2
.3a159b	85 12		sta $0812	            STA SCRATCH2+2
.3a159d	a5 14		lda $0814	            LDA SCRATCH2+4
.3a159f	65 14		adc $0814	            ADC SCRATCH2+4
.3a15a1	85 14		sta $0814	            STA SCRATCH2+4
.3a15a3	ca		dex		            DEX
.3a15a4	10 e7		bpl $3a158d	            BPL shift_loop      ; Loop through all 32 bits of ARGUMENT1
.3a15a6	d8		cld		            CLD                 ; Switch back out of BCD mode
.3a15a7	e2 20		sep #$20	            SEP #$20
.3a15a9	20 01 15	jsr $3a1501	            JSR TEMPSTRING
.3a15ac	a0 00 00	ldy #$0000	            LDY #0              ; Y will be index into the temporary string
.3a15af	a5 0c		lda $080c	            LDA SCRATCH         ; Check to see if the number was negative
.3a15b1	f0 04		beq $3a15b7	            BEQ is_pos          ; No: write a leading space
.3a15b3	a9 2d		lda #$2d	            LDA #'-'            ; If negative, write the minus sign
.3a15b5	80 02		bra $3a15b9	            BRA wr_lead
.3a15b7	a9 20		lda #$20	is_pos      LDA #CHAR_SP        ; Write a leading space
.3a15b9	97 16		sta [$0816],y	wr_lead     STA [STRPTR],Y
.3a15bb	c8		iny		            INY
.3a15bc	a2 05 00	ldx #$0005	            LDX #5
.3a15bf	b5 10		lda $0810,x	ascii_loop  LDA SCRATCH2,X
.3a15c1	29 f0		and #$f0	            AND #$F0
.3a15c3	4a		lsr a		            LSR A
.3a15c4	4a		lsr a		            LSR A
.3a15c5	4a		lsr a		            LSR A
.3a15c6	4a		lsr a		            LSR A
.3a15c7	20 51 15	jsr $3a1551	            JSR ITOS_DIGIT
.3a15ca	b5 10		lda $0810,x	            LDA SCRATCH2,X
.3a15cc	29 0f		and #$0f	            AND #$0F
.3a15ce	20 51 15	jsr $3a1551	            JSR ITOS_DIGIT
.3a15d1	ca		dex		            DEX
.3a15d2	10 eb		bpl $3a15bf	            BPL ascii_loop
.3a15d4	c0 01 00	cpy #$0001	            CPY #1              ; Did we write anything?
.3a15d7	d0 0c		bne $3a15e5	            BNE null_term       ; Yes: add a NULL to terminate
.3a15d9	a9 20		lda #$20	            LDA #' '            ; No: write a " 0" to the string
.3a15db	87 16		sta [$0816]	            STA [STRPTR]
.3a15dd	a0 01 00	ldy #$0001	            LDY #1
.3a15e0	a9 30		lda #$30	            LDA #'0'
.3a15e2	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a15e4	c8		iny		            INY
.3a15e5	a9 00		lda #$00	null_term   LDA #0
.3a15e7	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And terminate the string
.3a15e9	28		plp		done        PLP
.3a15ea	60		rts		            RTS
.3a15eb	00		brk #		fault       BRK
.3a15ec	ea		nop		            NOP
.3a15ed					STRLEN
.3a15ed	08		php		            PHP
.3a15ee	e2 20		sep #$20	            SEP #$20
.3a15f0	c2 10		rep #$10	            REP #$10
.3a15f2	a0 00 00	ldy #$0000	            LDY #0
.3a15f5	bd 00 00	lda $3a0000,x	loop        LDA #0,B,X
.3a15f8	f0 04		beq $3a15fe	            BEQ done
.3a15fa	e8		inx		            INX
.3a15fb	c8		iny		            INY
.3a15fc	80 f7		bra $3a15f5	            BRA loop
.3a15fe	28		plp		done        PLP
.3a15ff	60		rts		            RTS
.3a1600					STRCMP
.3a1600	08		php		            PHP
.3a1601	0b		phd		            PHD
.3a1602	08		php		            PHP
.3a1603	c2 20		rep #$20	            REP #$20
.3a1605	48		pha		            PHA
.3a1606	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1609	5b		tcd		            TCD
.3a160a	68		pla		            PLA
.3a160b	28		plp		            PLP
.3a160c	e2 20		sep #$20	            SEP #$20
.3a160e	c2 10		rep #$10	            REP #$10
.3a1610	a0 00 00	ldy #$0000	            LDY #0
.3a1613	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Check if the character 1 is 0
.3a1615	d0 04		bne $3a161b	            BNE comp_mag            ; If not, check the magnitudes
.3a1617	b7 29		lda [$0829],y	            LDA [ARGUMENT2],Y       ; If so, check if the character 2 is 0
.3a1619	f0 25		beq $3a1640	            BEQ are_equal           ; If so, the strings are equal
.3a161b	b7 23		lda [$0823],y	comp_mag    LDA [ARGUMENT1],Y       ; Otherwise, get character 1 again
.3a161d	d7 29		cmp [$0829],y	            CMP [ARGUMENT2],Y       ; And compare it to character 2
.3a161f	90 12		bcc $3a1633	            BLT is_less             ; Check if character 1 < character 2
.3a1621	d0 03		bne $3a1626	            BNE is_greater          ; Check if character 1 > character 2
.3a1623	c8		iny		            INY                     ; Equal so far... so go to the next pair of characters
.3a1624	80 ed		bra $3a1613	            BRA loop
.3a1626					is_greater
.3a1626	c2 20		rep #$20	            REP #$20
.3a1628	a9 01 00	lda #$0001	            LDA #1                  ; So return 1
.3a162b	85 23		sta $0823	            STA ARGUMENT1
.3a162d	e2 20		sep #$20	            SEP #$20
.3a162f	64 25		stz $0825	            STZ ARGUMENT1+2
.3a1631	80 15		bra $3a1648	            BRA done
.3a1633					is_less
.3a1633	c2 20		rep #$20	            REP #$20
.3a1635	a9 ff ff	lda #$ffff	            LDA #$FFFF              ; So return -1
.3a1638	85 23		sta $0823	            STA ARGUMENT1
.3a163a	e2 20		sep #$20	            SEP #$20
.3a163c	85 25		sta $0825	            STA ARGUMENT1+2
.3a163e	80 08		bra $3a1648	            BRA done
.3a1640					are_equal
.3a1640	c2 20		rep #$20	            REP #$20
.3a1642	64 23		stz $0823	            STZ ARGUMENT1           ; So return 0
.3a1644	e2 20		sep #$20	            SEP #$20
.3a1646	64 25		stz $0825	            STZ ARGUMENT1+2
.3a1648					done
.3a1648	e2 20		sep #$20	            SEP #$20
.3a164a	a9 00		lda #$00	            LDA #TYPE_INTEGER
.3a164c	85 27		sta $0827	            STA ARGTYPE1
.3a164e	2b		pld		            PLD
.3a164f	28		plp		            PLP
.3a1650	60		rts		            RTS
.3a1651					STRCONCAT
.3a1651	08		php		            PHP
.3a1652	0b		phd		            PHD
.3a1653	8b		phb		            PHB
.3a1654	08		php		            PHP
.3a1655	c2 20		rep #$20	            REP #$20
.3a1657	48		pha		            PHA
.3a1658	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a165b	5b		tcd		            TCD
.3a165c	68		pla		            PLA
.3a165d	28		plp		            PLP
.3a165e	e2 20		sep #$20	            SEP #$20
.3a1660	c2 10		rep #$10	            REP #$10
.3a1662	08		php		            PHP
.3a1663	c2 20		rep #$20	            REP #$20
.3a1665	48		pha		            PHA
.3a1666	e2 20		sep #$20	            SEP #$20
.3a1668	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a166a	48		pha		            PHA
.3a166b	ab		plb		            PLB
.3a166c	c2 20		rep #$20	            REP #$20
.3a166e	68		pla		            PLA
.3a166f	28		plp		            PLP
.3a1670	a6 23		ldx $0823	            LDX ARGUMENT1
.3a1672	20 ed 15	jsr $3a15ed	            JSR STRLEN
.3a1675	84 0c		sty $080c	            STY SCRATCH
.3a1677	08		php		            PHP
.3a1678	c2 20		rep #$20	            REP #$20
.3a167a	48		pha		            PHA
.3a167b	e2 20		sep #$20	            SEP #$20
.3a167d	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a167f	48		pha		            PHA
.3a1680	ab		plb		            PLB
.3a1681	c2 20		rep #$20	            REP #$20
.3a1683	68		pla		            PLA
.3a1684	28		plp		            PLP
.3a1685	a6 29		ldx $0829	            LDX ARGUMENT2
.3a1687	20 ed 15	jsr $3a15ed	            JSR STRLEN
.3a168a	c2 20		rep #$20	            REP #$20
.3a168c	98		tya		            TYA
.3a168d	38		sec		            SEC                     ; X := LEN(ARGUMENT1) + LEN(ARGUMENT2) + 1
.3a168e	65 0c		adc $080c	            ADC SCRATCH
.3a1690	aa		tax		            TAX
.3a1691	e2 20		sep #$20	            SEP #$20
.3a1693	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set type to STRING
.3a1695	20 d3 10	jsr $3a10d3	            JSR ALLOC
.3a1698	c2 20		rep #$20	            REP #$20
.3a169a	a5 b7		lda $08b7	            LDA ALLOCATED           ; INDEX := pointer to the string
.3a169c	85 08		sta $0808	            STA INDEX
.3a169e	e2 20		sep #$20	            SEP #$20
.3a16a0	a5 b9		lda $08b9	            LDA ALLOCATED+2
.3a16a2	85 0a		sta $080a	            STA INDEX+2
.3a16a4	a0 00 00	ldy #$0000	            LDY #0                  ; Set the target index to the beginning
.3a16a7	08		php		            PHP
.3a16a8	c2 20		rep #$20	            REP #$20
.3a16aa	48		pha		            PHA
.3a16ab	e2 20		sep #$20	            SEP #$20
.3a16ad	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a16af	48		pha		            PHA
.3a16b0	ab		plb		            PLB
.3a16b1	c2 20		rep #$20	            REP #$20
.3a16b3	68		pla		            PLA
.3a16b4	28		plp		            PLP
.3a16b5	a6 23		ldx $0823	            LDX ARGUMENT1
.3a16b7	bd 00 00	lda $3a0000,x	loop1       LDA #0,B,X              ; Get the Xth byte of ARGUMENT1
.3a16ba	f0 06		beq $3a16c2	            BEQ copy_2              ; Is it null? Yes: move on to the next string
.3a16bc	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.3a16be	e8		inx		            INX                     ; Point to the next characters
.3a16bf	c8		iny		            INY
.3a16c0	80 f5		bra $3a16b7	            BRA loop1               ; And do again
.3a16c2					copy_2
.3a16c2	e2 20		sep #$20	            SEP #$20
.3a16c4	08		php		            PHP
.3a16c5	c2 20		rep #$20	            REP #$20
.3a16c7	48		pha		            PHA
.3a16c8	e2 20		sep #$20	            SEP #$20
.3a16ca	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a16cc	48		pha		            PHA
.3a16cd	ab		plb		            PLB
.3a16ce	c2 20		rep #$20	            REP #$20
.3a16d0	68		pla		            PLA
.3a16d1	28		plp		            PLP
.3a16d2	a6 29		ldx $0829	            LDX ARGUMENT2
.3a16d4	bd 00 00	lda $3a0000,x	loop2       LDA #0,B,X              ; Get the Xth byte of ARGUMENT2
.3a16d7	97 08		sta [$0808],y	            STA [INDEX],Y           ; And save it to the Yth position on the new string
.3a16d9	f0 04		beq $3a16df	            BEQ terminate           ; Is it null? Yes: move on to the next string
.3a16db	e8		inx		            INX                     ; Point to the next characters
.3a16dc	c8		iny		            INY
.3a16dd	80 f5		bra $3a16d4	            BRA loop2               ; And do again
.3a16df					terminate
.3a16df	c2 20		rep #$20	            REP #$20
.3a16e1	a5 08		lda $0808	            LDA INDEX               ; Set ARGUMENT1 to the new string
.3a16e3	85 23		sta $0823	            STA ARGUMENT1
.3a16e5	e2 20		sep #$20	            SEP #$20
.3a16e7	a5 0a		lda $080a	            LDA INDEX+2
.3a16e9	85 25		sta $0825	            STA ARGUMENT1+2
.3a16eb	a9 02		lda #$02	            LDA #TYPE_STRING        ; Set ARGUMENT1's type to STRING
.3a16ed	85 27		sta $0827	            STA ARGTYPE1
.3a16ef	ab		plb		            PLB
.3a16f0	2b		pld		            PLD
.3a16f1	28		plp		            PLP
.3a16f2	60		rts		            RTS
.3a16f3					STRCPY
.3a16f3	da		phx		            PHX
.3a16f4	5a		phy		            PHY
.3a16f5	08		php		            PHP
.3a16f6	0b		phd		            PHD
.3a16f7	8b		phb		            PHB
.3a16f8	08		php		            PHP
.3a16f9	c2 20		rep #$20	            REP #$20
.3a16fb	48		pha		            PHA
.3a16fc	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a16ff	5b		tcd		            TCD
.3a1700	68		pla		            PLA
.3a1701	28		plp		            PLP
.3a1702	c2 20		rep #$20	            REP #$20
.3a1704	a5 0a		lda $080a	            LDA INDEX+2
.3a1706	48		pha		            PHA
.3a1707	a5 08		lda $0808	            LDA INDEX
.3a1709	48		pha		            PHA
.3a170a	c2 30		rep #$30	            REP #$30
.3a170c	08		php		            PHP
.3a170d	c2 20		rep #$20	            REP #$20
.3a170f	48		pha		            PHA
.3a1710	e2 20		sep #$20	            SEP #$20
.3a1712	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a1714	48		pha		            PHA
.3a1715	ab		plb		            PLB
.3a1716	c2 20		rep #$20	            REP #$20
.3a1718	68		pla		            PLA
.3a1719	28		plp		            PLP
.3a171a	a6 23		ldx $0823	            LDX ARGUMENT1
.3a171c	20 ed 15	jsr $3a15ed	            JSR STRLEN
.3a171f	98		tya		            TYA
.3a1720	aa		tax		            TAX
.3a1721	e8		inx		            INX                     ; Put length of string (plus NUL) in X
.3a1722	e2 20		sep #$20	            SEP #$20
.3a1724	a9 02		lda #$02	            LDA #TYPE_STRING
.3a1726	20 d3 10	jsr $3a10d3	            JSR ALLOC
.3a1729	c2 20		rep #$20	            REP #$20
.3a172b	a5 c0		lda $08c0	            LDA CURRBLOCK
.3a172d	85 08		sta $0808	            STA INDEX
.3a172f	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.3a1731	85 0a		sta $080a	            STA INDEX+2
.3a1733	a0 00 00	ldy #$0000	            LDY #0
.3a1736	e2 20		sep #$20	            SEP #$20
.3a1738	b7 23		lda [$0823],y	loop        LDA [ARGUMENT1],Y       ; Copy the data to the allocated string
.3a173a	97 08		sta [$0808],y	            STA [INDEX],Y
.3a173c	f0 03		beq $3a1741	            BEQ ret_copy
.3a173e	c8		iny		            INY
.3a173f	80 f7		bra $3a1738	            BRA loop
.3a1741					ret_copy
.3a1741	c2 20		rep #$20	            REP #$20
.3a1743	a5 08		lda $0808	            LDA INDEX
.3a1745	85 23		sta $0823	            STA ARGUMENT1
.3a1747	a5 0a		lda $080a	            LDA INDEX+2
.3a1749	85 25		sta $0825	            STA ARGUMENT1+2
.3a174b	c2 20		rep #$20	            REP #$20
.3a174d	68		pla		            PLA
.3a174e	85 08		sta $0808	            STA INDEX
.3a1750	68		pla		            PLA
.3a1751	85 0a		sta $080a	            STA INDEX+2
.3a1753	ab		plb		            PLB
.3a1754	2b		pld		            PLD
.3a1755	28		plp		            PLP
.3a1756	7a		ply		            PLY
.3a1757	fa		plx		            PLX
.3a1758	60		rts		            RTS
.3a1759					STRSUBSTR
.3a1759	08		php		            PHP
.3a175a	e2 20		sep #$20	            SEP #$20
.3a175c	c2 10		rep #$10	            REP #$10
.3a175e	a0 00 00	ldy #$0000	            LDY #0
.3a1761	b7 23		lda [$0823],y	count_loop  LDA [ARGUMENT1],Y
.3a1763	f0 05		beq $3a176a	            BEQ counted
.3a1765	c8		iny		            INY
.3a1766	80 f9		bra $3a1761	            BRA count_loop
.3a1768	84 92		sty $0892	            STY MTEMP               ; MTEMP := length of the source string
.3a176a					counted
.3a176a	c2 30		rep #$30	            REP #$30
.3a176c	c4 29		cpy $0829	            CPY ARGUMENT2           ; length of string <= index?
.3a176e	90 13		bcc $3a1783	            BLT ret_empty           ; Yes: return empty string
.3a1770	f0 11		beq $3a1783	            BEQ ret_empty
.3a1772	a5 8f		lda $088f	            LDA MCOUNT              ; Is the desired count <= 0?
.3a1774	30 0d		bmi $3a1783	            BMI ret_empty
.3a1776	f0 0b		beq $3a1783	            BEQ ret_empty           ; Yes: return the empty string
.3a1778	c4 8f		cpy $088f	            CPY MCOUNT              ; Is the desired length < the length of the source?
.3a177a	b0 12		bcs $3a178e	            BGE do_slice            ; Yes: go ahead and get the substring
.3a177c	a5 29		lda $0829	            LDA ARGUMENT2           ; Is INDEX == 0?
.3a177e	d0 0e		bne $3a178e	            BNE do_slice            ; No: do a slice
.3a1780	4c d7 17	jmp $3a17d7	            JMP done                ; Yes: just return the source string
.3a1783					ret_empty
.3a1783	20 01 15	jsr $3a1501	            JSR TEMPSTRING
.3a1786	e2 20		sep #$20	            SEP #$20
.3a1788	a9 00		lda #$00	            LDA #0
.3a178a	87 16		sta [$0816]	            STA [STRPTR]
.3a178c	80 39		bra $3a17c7	            BRA finish_copy
.3a178e					do_slice
.3a178e	20 01 15	jsr $3a1501	            JSR TEMPSTRING
.3a1791	c2 30		rep #$30	            REP #$30
.3a1793	18		clc		            CLC                     ; ARGUMENT1 := ARGUMENT1 + index
.3a1794	a5 23		lda $0823	            LDA ARGUMENT1
.3a1796	65 29		adc $0829	            ADC ARGUMENT2
.3a1798	85 23		sta $0823	            STA ARGUMENT1
.3a179a	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a179c	69 00 00	adc #$0000	            ADC #0
.3a179f	85 25		sta $0825	            STA ARGUMENT1+2
.3a17a1	a0 00 00	ldy #$0000	            LDY #0
.3a17a4					copy_loop
.3a17a4	e2 20		sep #$20	            SEP #$20
.3a17a6	a7 23		lda [$0823]	            LDA [ARGUMENT1]         ; Copy a character from the substring to the temporary string
.3a17a8	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a17aa	f0 1b		beq $3a17c7	            BEQ finish_copy         ; If it is a NULL, we're done
.3a17ac	c2 20		rep #$20	            REP #$20
.3a17ae	18		clc		            CLC                     ; Move to the next character
.3a17af	a5 23		lda $0823	            LDA ARGUMENT1
.3a17b1	69 01 00	adc #$0001	            ADC #1
.3a17b4	85 23		sta $0823	            STA ARGUMENT1
.3a17b6	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a17b8	69 00 00	adc #$0000	            ADC #0
.3a17bb	85 25		sta $0825	            STA ARGUMENT1+2
.3a17bd	c8		iny		            INY
.3a17be	c4 8f		cpy $088f	            CPY MCOUNT              ; Have we reached the limit to copy?
.3a17c0	d0 e2		bne $3a17a4	            BNE copy_loop           ; No: copy the next byte
.3a17c2	a9 00 00	lda #$0000	            LDA #0                  ; Null terminate string
.3a17c5	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a17c7					finish_copy
.3a17c7	c2 20		rep #$20	            REP #$20
.3a17c9	a5 16		lda $0816	            LDA STRPTR
.3a17cb	85 23		sta $0823	            STA ARGUMENT1
.3a17cd	a5 18		lda $0818	            LDA STRPTR+2
.3a17cf	85 25		sta $0825	            STA ARGUMENT1+2
.3a17d1	e2 20		sep #$20	            SEP #$20
.3a17d3	a9 02		lda #$02	            LDA #<TYPE_STRING
.3a17d5	85 27		sta $0827	            STA ARGTYPE1
.3a17d7					done
.3a17d7	28		plp		            PLP
.3a17d8	60		rts		            RTS
.3a17d9					OP_STR_LT
.3a17d9	08		php		            PHP
.3a17da	c2 30		rep #$30	            REP #$30
.3a17dc	20 00 16	jsr $3a1600	            JSR STRCMP
.3a17df	a5 23		lda $0823	            LDA ARGUMENT1
.3a17e1	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.3a17e4	d0 05		bne $3a17eb	            BNE ret_false               ; No: return false
.3a17e6					ret_true
.3a17e6	20 2d 06	jsr $3a062d	            JSR SET_TRUE
.3a17e9	80 03		bra $3a17ee	            BRA done
.3a17eb					ret_false
.3a17eb	20 3f 06	jsr $3a063f	            JSR SET_FALSE
.3a17ee	28		plp		done        PLP
.3a17ef	60		rts		            RTS
.3a17f0					OP_STR_GT
.3a17f0	08		php		            PHP
.3a17f1	c2 30		rep #$30	            REP #$30
.3a17f3	20 00 16	jsr $3a1600	            JSR STRCMP
.3a17f6	a5 23		lda $0823	            LDA ARGUMENT1
.3a17f8	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.3a17fb	d0 05		bne $3a1802	            BNE ret_false               ; No: return false
.3a17fd					ret_true
.3a17fd	20 2d 06	jsr $3a062d	            JSR SET_TRUE
.3a1800	80 03		bra $3a1805	            BRA done
.3a1802					ret_false
.3a1802	20 3f 06	jsr $3a063f	            JSR SET_FALSE
.3a1805	28		plp		done        PLP
.3a1806	60		rts		            RTS
.3a1807					OP_STR_EQ
.3a1807	08		php		            PHP
.3a1808	c2 30		rep #$30	            REP #$30
.3a180a	20 00 16	jsr $3a1600	            JSR STRCMP
.3a180d	a5 23		lda $0823	            LDA ARGUMENT1
.3a180f	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.3a1812	d0 05		bne $3a1819	            BNE ret_false               ; No: return false
.3a1814					ret_true
.3a1814	20 2d 06	jsr $3a062d	            JSR SET_TRUE
.3a1817	80 03		bra $3a181c	            BRA done
.3a1819					ret_false
.3a1819	20 3f 06	jsr $3a063f	            JSR SET_FALSE
.3a181c	28		plp		done        PLP
.3a181d	60		rts		            RTS
.3a181e					OP_STR_NE
.3a181e	08		php		            PHP
.3a181f	c2 30		rep #$30	            REP #$30
.3a1821	20 00 16	jsr $3a1600	            JSR STRCMP
.3a1824	a5 23		lda $0823	            LDA ARGUMENT1
.3a1826	c9 00 00	cmp #$0000	            CMP #0                      ; ARGUMENT1 = ARGUMENT2?
.3a1829	f0 05		beq $3a1830	            BEQ ret_false               ; Yes: return false
.3a182b					ret_true
.3a182b	20 2d 06	jsr $3a062d	            JSR SET_TRUE
.3a182e	80 03		bra $3a1833	            BRA done
.3a1830					ret_false
.3a1830	20 3f 06	jsr $3a063f	            JSR SET_FALSE
.3a1833	28		plp		done        PLP
.3a1834	60		rts		            RTS
.3a1835					OP_STR_GTE
.3a1835	08		php		            PHP
.3a1836	c2 30		rep #$30	            REP #$30
.3a1838	20 00 16	jsr $3a1600	            JSR STRCMP
.3a183b	a5 23		lda $0823	            LDA ARGUMENT1
.3a183d	c9 ff ff	cmp #$ffff	            CMP #$FFFF                  ; ARGUMENT1 < ARGUMENT2?
.3a1840	f0 05		beq $3a1847	            BEQ ret_false               ; Yes: return false
.3a1842					ret_true
.3a1842	20 2d 06	jsr $3a062d	            JSR SET_TRUE
.3a1845	80 03		bra $3a184a	            BRA done
.3a1847					ret_false
.3a1847	20 3f 06	jsr $3a063f	            JSR SET_FALSE
.3a184a	28		plp		done        PLP
.3a184b	60		rts		            RTS
.3a184c					OP_STR_LTE
.3a184c	08		php		            PHP
.3a184d	c2 30		rep #$30	            REP #$30
.3a184f	20 00 16	jsr $3a1600	            JSR STRCMP
.3a1852	a5 23		lda $0823	            LDA ARGUMENT1
.3a1854	c9 01 00	cmp #$0001	            CMP #1                      ; ARGUMENT1 > ARGUMENT2?
.3a1857	f0 05		beq $3a185e	            BEQ ret_false               ; Yes: return false
.3a1859					ret_true
.3a1859	20 2d 06	jsr $3a062d	            JSR SET_TRUE
.3a185c	80 03		bra $3a1861	            BRA done
.3a185e					ret_false
.3a185e	20 3f 06	jsr $3a063f	            JSR SET_FALSE
.3a1861	28		plp		done        PLP
.3a1862	60		rts		            RTS
.3a1863					STR_NORMAL
.3a1863	08		php		            PHP
.3a1864	e2 20		sep #$20	            SEP #$20
.3a1866	a5 27		lda $0827	            LDA ARGTYPE1            ; Is it a string?
.3a1868	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a186a	d0 1d		bne $3a1889	            BNE done                ; No: return it
.3a186c	a5 23		lda $0823	            LDA ARGUMENT1           ; Is it a null pointer?
.3a186e	d0 19		bne $3a1889	            BNE done
.3a1870	a5 24		lda $0824	            LDA ARGUMENT1+1
.3a1872	d0 15		bne $3a1889	            BNE done
.3a1874	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a1876	d0 11		bne $3a1889	            BNE done                ; No: return it
.3a1878	20 01 15	jsr $3a1501	            JSR TEMPSTRING
.3a187b	a9 00		lda #$00	            LDA #0
.3a187d	87 16		sta [$0816]	            STA [STRPTR]            ; Make it empty
.3a187f	c2 20		rep #$20	            REP #$20
.3a1881	a5 16		lda $0816	            LDA STRPTR
.3a1883	85 23		sta $0823	            STA ARGUMENT1
.3a1885	a5 18		lda $0818	            LDA STRPTR+2
.3a1887	85 25		sta $0825	            STA ARGUMENT1+2
.3a1889	28		plp		done        PLP
.3a188a	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\listing.s

.3a188b					LISTPROG
.3a188b	48		pha		            PHA
.3a188c	5a		phy		            PHY
.3a188d	0b		phd		            PHD
.3a188e	08		php		            PHP
.3a188f	08		php		            PHP
.3a1890	c2 20		rep #$20	            REP #$20
.3a1892	48		pha		            PHA
.3a1893	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1896	5b		tcd		            TCD
.3a1897	68		pla		            PLA
.3a1898	28		plp		            PLP
.3a1899	c2 30		rep #$30	            REP #$30
.3a189b	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.3a189e	85 00		sta $0800	            STA BIP
.3a18a0	85 1a		sta $081a	            STA CURLINE
.3a18a2	a9 36 00	lda #$0036	            LDA #`BASIC_BOT
.3a18a5	85 02		sta $0802	            STA BIP+2
.3a18a7	85 1c		sta $081c	            STA CURLINE+2
.3a18a9	22 3c 11 00	jsl $00113c	list_loop   JSL FK_TESTBREAK
.3a18ad	b0 20		bcs $3a18cf	            BCS throw_break     ; If C: user pressed an interrupt key, stop the listing
.3a18af	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.3a18b2	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.3a18b4	f0 0f		beq $3a18c5	            BEQ done
.3a18b6	c5 55		cmp $0855	            CMP MARG1
.3a18b8	90 10		bcc $3a18ca	            BLT skip_line
.3a18ba	c5 59		cmp $0859	            CMP MARG2
.3a18bc	f0 02		beq $3a18c0	            BEQ print_line
.3a18be	b0 05		bcs $3a18c5	            BGE done
.3a18c0					print_line
.3a18c0	20 ee 18	jsr $3a18ee	            JSR LISTLINE
.3a18c3	80 e4		bra $3a18a9	            BRA list_loop
.3a18c5	28		plp		done        PLP
.3a18c6	2b		pld		            PLD
.3a18c7	7a		ply		            PLY
.3a18c8	68		pla		            PLA
.3a18c9	60		rts		            RTS
.3a18ca					skip_line
.3a18ca	20 f7 21	jsr $3a21f7	            JSR NEXTLINE
.3a18cd	80 da		bra $3a18a9	            BRA list_loop           ; And try again
.3a18cf					throw_break
.3a18cf	08		php		            PHP
.3a18d0	c2 20		rep #$20	            REP #$20
.3a18d2	48		pha		            PHA
.3a18d3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a18d6	5b		tcd		            TCD
.3a18d7	68		pla		            PLA
.3a18d8	28		plp		            PLP
.3a18d9	e2 20		sep #$20	            SEP #$20
.3a18db	a9 01		lda #$01	            LDA #ERR_BREAK
.3a18dd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a18e1	c2 20		rep #$20	            REP #$20
.3a18e3	29 ff 00	and #$00ff	            AND #$00FF
.3a18e6	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a18e9	e2 20		sep #$20	            SEP #$20
.3a18eb	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a18ee					LISTLINE
.3a18ee	08		php		            PHP
.3a18ef	c2 30		rep #$30	            REP #$30
.3a18f1	85 23		sta $0823	            STA ARGUMENT1
.3a18f3	64 25		stz $0825	            STZ ARGUMENT1+2
.3a18f5	20 60 15	jsr $3a1560	            JSR ITOS
.3a18f8	a5 16		lda $0816	            LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.3a18fa	1a		inc a		            INC A
.3a18fb	85 23		sta $0823	            STA ARGUMENT1
.3a18fd	a5 18		lda $0818	            LDA STRPTR+2
.3a18ff	85 25		sta $0825	            STA ARGUMENT1+2
.3a1901	20 fc 45	jsr $3a45fc	            JSR PR_STRING
.3a1904	18		clc		            CLC                 ; Move the BIP to the first byte of the line
.3a1905	a5 1a		lda $081a	            LDA CURLINE
.3a1907	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a190a	85 00		sta $0800	            STA BIP
.3a190c	a5 1c		lda $081c	            LDA CURLINE+2
.3a190e	69 00 00	adc #$0000	            ADC #0
.3a1911	85 02		sta $0802	            STA BIP+2
.3a1913	e2 20		sep #$20	            SEP #$20
.3a1915	a9 20		lda #$20	            LDA #CHAR_SP
.3a1917	20 18 00	jsr $3a0018	            JSR PRINTC
.3a191a	c2 20		rep #$20	            REP #$20
.3a191c					loop
.3a191c	20 2d 19	jsr $3a192d	            JSR LISTBYTE
.3a191f	90 fb		bcc $3a191c	            BCC loop
.3a1921	e2 20		sep #$20	            SEP #$20
.3a1923	a9 0d		lda #$0d	            LDA #CHAR_CR
.3a1925	20 18 00	jsr $3a0018	            JSR PRINTC
.3a1928	20 f7 21	jsr $3a21f7	            JSR NEXTLINE
.3a192b	28		plp		            PLP
.3a192c	60		rts		            RTS
.3a192d					LISTBYTE
.3a192d	08		php		            PHP
.3a192e	0b		phd		            PHD
.3a192f	8b		phb		            PHB
.3a1930	08		php		            PHP
.3a1931	c2 20		rep #$20	            REP #$20
.3a1933	48		pha		            PHA
.3a1934	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1937	5b		tcd		            TCD
.3a1938	68		pla		            PLA
.3a1939	28		plp		            PLP
.3a193a	08		php		            PHP
.3a193b	e2 20		sep #$20	            SEP #$20
.3a193d	48		pha		            PHA
.3a193e	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a1940	48		pha		            PHA
.3a1941	ab		plb		            PLB
.3a1942	68		pla		            PLA
.3a1943	28		plp		            PLP
.3a1944	e2 20		sep #$20	            SEP #$20
.3a1946	c2 10		rep #$10	            REP #$10
.3a1948	a7 00		lda [$0800]	            LDA [BIP]           ; Get the current byte
.3a194a	f0 3a		beq $3a1986	            BEQ end_of_line     ; If it's 0, return with C set
.3a194c	30 05		bmi $3a1953	            BMI is_token        ; If it's 0x80 - 0xFF, it's a token
.3a194e	20 18 00	jsr $3a0018	            JSR PRINTC
.3a1951	80 29		bra $3a197c	            BRA done            ; And return
.3a1953					is_token
.3a1953	c2 20		rep #$20	            REP #$20
.3a1955	29 7f 00	and #$007f	            AND #$007F          ; Compute the index of the token
.3a1958	0a		asl a		            ASL A               ; In the token table
.3a1959	0a		asl a		            ASL A
.3a195a	0a		asl a		            ASL A
.3a195b	18		clc		            CLC
.3a195c	69 fb 0c	adc #$0cfb	            ADC #<>TOKENS       ; Set INDEX to the address of the token
.3a195f	85 08		sta $0808	            STA INDEX
.3a1961	a9 3a 00	lda #$003a	            LDA #`TOKENS
.3a1964	69 00 00	adc #$0000	            ADC #0
.3a1967	85 0a		sta $080a	            STA INDEX+2
.3a1969					pr_default
.3a1969	08		php		            PHP
.3a196a	e2 20		sep #$20	            SEP #$20
.3a196c	48		pha		            PHA
.3a196d	a9 3a		lda #$3a	            LDA #`TOKENS
.3a196f	48		pha		            PHA
.3a1970	ab		plb		            PLB
.3a1971	68		pla		            PLA
.3a1972	28		plp		            PLP
.3a1973	a0 02 00	ldy #$0002	            LDY #TOKEN.name
.3a1976	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a1978	aa		tax		            TAX
.3a1979	20 64 04	jsr $3a0464	            JSR PRINTS
.3a197c					done
.3a197c	c2 20		rep #$20	            REP #$20
.3a197e	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a1981	ab		plb		            PLB
.3a1982	2b		pld		            PLD
.3a1983	28		plp		            PLP
.3a1984	18		clc		            CLC
.3a1985	60		rts		            RTS
.3a1986	ab		plb		end_of_line PLB
.3a1987	2b		pld		            PLD
.3a1988	28		plp		            PLP
.3a1989	38		sec		            SEC
.3a198a	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\eval.s

.3a198b					INITEVALSP
.3a198b	08		php		            PHP
.3a198c	c2 20		rep #$20	            REP #$20
.3a198e	a9 ff 6f	lda #$6fff	            LDA #ARGUMENT_TOP
.3a1991	85 1f		sta $081f	            STA ARGUMENTSP
.3a1993	a9 ff 7f	lda #$7fff	            LDA #OPERATOR_TOP
.3a1996	85 21		sta $0821	            STA OPERATORSP
.3a1998	a9 ff ff	lda #$ffff	            LDA #$FFFF
.3a199b	85 23		sta $0823	            STA ARGUMENT1
.3a199d	85 25		sta $0825	            STA ARGUMENT1+2
.3a199f	85 29		sta $0829	            STA ARGUMENT2
.3a19a1	85 2b		sta $082b	            STA ARGUMENT2+2
.3a19a3	e2 20		sep #$20	            SEP #$20
.3a19a5	85 27		sta $0827	            STA ARGTYPE1
.3a19a7	85 2d		sta $082d	            STA ARGTYPE2
.3a19a9	28		plp		            PLP
.3a19aa	60		rts		            RTS
.3a19ab					PHARGUMENT
.3a19ab	08		php		            PHP
.3a19ac	0b		phd		            PHD
.3a19ad	8b		phb		            PHB
.3a19ae	08		php		            PHP
.3a19af	c2 20		rep #$20	            REP #$20
.3a19b1	48		pha		            PHA
.3a19b2	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a19b5	5b		tcd		            TCD
.3a19b6	68		pla		            PLA
.3a19b7	28		plp		            PLP
.3a19b8	08		php		            PHP
.3a19b9	e2 20		sep #$20	            SEP #$20
.3a19bb	48		pha		            PHA
.3a19bc	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a19be	48		pha		            PHA
.3a19bf	ab		plb		            PLB
.3a19c0	68		pla		            PLA
.3a19c1	28		plp		            PLP
.3a19c2	c2 30		rep #$30	            REP #$30
.3a19c4	5a		phy		            PHY
.3a19c5	a4 1f		ldy $081f	            LDY ARGUMENTSP
.3a19c7	bd 00 00	lda $0000,x	            LDA #0,B,X
.3a19ca	99 00 00	sta $0000,y	            STA #0,B,Y
.3a19cd	bd 02 00	lda $0002,x	            LDA #2,B,X
.3a19d0	99 02 00	sta $0002,y	            STA #2,B,Y
.3a19d3	e2 20		sep #$20	            SEP #$20
.3a19d5	bd 04 00	lda $0004,x	            LDA #4,B,X
.3a19d8	99 04 00	sta $0004,y	            STA #4,B,Y
.3a19db	c2 20		rep #$20	            REP #$20
.3a19dd	38		sec		            SEC
.3a19de	98		tya		            TYA
.3a19df	e9 05 00	sbc #$0005	            SBC #ARGUMENT_SIZE
.3a19e2	85 1f		sta $081f	            STA ARGUMENTSP
.3a19e4	7a		ply		            PLY
.3a19e5	ab		plb		            PLB
.3a19e6	2b		pld		            PLD
.3a19e7	28		plp		            PLP
.3a19e8	60		rts		            RTS
.3a19e9					PLARGUMENT
.3a19e9	08		php		            PHP
.3a19ea	0b		phd		            PHD
.3a19eb	8b		phb		            PHB
.3a19ec	08		php		            PHP
.3a19ed	c2 20		rep #$20	            REP #$20
.3a19ef	48		pha		            PHA
.3a19f0	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a19f3	5b		tcd		            TCD
.3a19f4	68		pla		            PLA
.3a19f5	28		plp		            PLP
.3a19f6	08		php		            PHP
.3a19f7	e2 20		sep #$20	            SEP #$20
.3a19f9	48		pha		            PHA
.3a19fa	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a19fc	48		pha		            PHA
.3a19fd	ab		plb		            PLB
.3a19fe	68		pla		            PLA
.3a19ff	28		plp		            PLP
.3a1a00	c2 30		rep #$30	            REP #$30
.3a1a02	5a		phy		            PHY
.3a1a03	18		clc		            CLC
.3a1a04	a5 1f		lda $081f	            LDA ARGUMENTSP
.3a1a06	69 05 00	adc #$0005	            ADC #ARGUMENT_SIZE
.3a1a09	85 1f		sta $081f	            STA ARGUMENTSP
.3a1a0b	a8		tay		            TAY
.3a1a0c	b9 00 00	lda $0000,y	            LDA #0,B,Y
.3a1a0f	9d 00 00	sta $0000,x	            STA #0,B,X
.3a1a12	b9 02 00	lda $0002,y	            LDA #2,B,Y
.3a1a15	9d 02 00	sta $0002,x	            STA #2,B,X
.3a1a18	e2 20		sep #$20	            SEP #$20
.3a1a1a	b9 04 00	lda $0004,y	            LDA #4,B,Y
.3a1a1d	9d 04 00	sta $0004,x	            STA #4,B,X
.3a1a20	bd 00 00	lda $0000,x	            LDA #0,B,X
.3a1a23	7a		ply		            PLY
.3a1a24	ab		plb		            PLB
.3a1a25	2b		pld		            PLD
.3a1a26	28		plp		            PLP
.3a1a27	60		rts		            RTS
.3a1a28					PHOPERATOR
.3a1a28	08		php		            PHP
.3a1a29	0b		phd		            PHD
.3a1a2a	8b		phb		            PHB
.3a1a2b	08		php		            PHP
.3a1a2c	c2 20		rep #$20	            REP #$20
.3a1a2e	48		pha		            PHA
.3a1a2f	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1a32	5b		tcd		            TCD
.3a1a33	68		pla		            PLA
.3a1a34	28		plp		            PLP
.3a1a35	08		php		            PHP
.3a1a36	e2 20		sep #$20	            SEP #$20
.3a1a38	48		pha		            PHA
.3a1a39	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a1a3b	48		pha		            PHA
.3a1a3c	ab		plb		            PLB
.3a1a3d	68		pla		            PLA
.3a1a3e	28		plp		            PLP
.3a1a3f	e2 20		sep #$20	            SEP #$20
.3a1a41	c2 10		rep #$10	            REP #$10
.3a1a43	5a		phy		            PHY
.3a1a44	a4 21		ldy $0821	            LDY OPERATORSP
.3a1a46	99 00 00	sta $0000,y	            STA #0,B,Y
.3a1a49	88		dey		            DEY
.3a1a4a	84 21		sty $0821	            STY OPERATORSP
.3a1a4c	7a		ply		done        PLY
.3a1a4d	ab		plb		            PLB
.3a1a4e	2b		pld		            PLD
.3a1a4f	28		plp		            PLP
.3a1a50	60		rts		            RTS
.3a1a51					PLOPERATOR
.3a1a51	08		php		            PHP
.3a1a52	0b		phd		            PHD
.3a1a53	8b		phb		            PHB
.3a1a54	08		php		            PHP
.3a1a55	c2 20		rep #$20	            REP #$20
.3a1a57	48		pha		            PHA
.3a1a58	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1a5b	5b		tcd		            TCD
.3a1a5c	68		pla		            PLA
.3a1a5d	28		plp		            PLP
.3a1a5e	08		php		            PHP
.3a1a5f	e2 20		sep #$20	            SEP #$20
.3a1a61	48		pha		            PHA
.3a1a62	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a1a64	48		pha		            PHA
.3a1a65	ab		plb		            PLB
.3a1a66	68		pla		            PLA
.3a1a67	28		plp		            PLP
.3a1a68	e2 20		sep #$20	            SEP #$20
.3a1a6a	c2 10		rep #$10	            REP #$10
.3a1a6c	5a		phy		            PHY
.3a1a6d	a4 21		ldy $0821	            LDY OPERATORSP
.3a1a6f	c8		iny		            INY
.3a1a70	84 21		sty $0821	            STY OPERATORSP
.3a1a72	b9 00 00	lda $0000,y	            LDA #0,B,Y
.3a1a75	c2 20		rep #$20	            REP #$20
.3a1a77	29 ff 00	and #$00ff	            AND #$00FF
.3a1a7a	7a		ply		            PLY
.3a1a7b	ab		plb		            PLB
.3a1a7c	2b		pld		            PLD
.3a1a7d	28		plp		            PLP
.3a1a7e	60		rts		            RTS
.3a1a7f					OPENPARAMS
.3a1a7f	08		php		            PHP
.3a1a80	e2 20		sep #$20	            SEP #$20
.3a1a82	a9 01		lda #$01	            LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.3a1a84	20 28 1a	jsr $3a1a28	            JSR PHOPERATOR
.3a1a87	28		plp		            PLP
.3a1a88	60		rts		            RTS
.3a1a89					CLOSEPARAMS
.3a1a89	5a		phy		            PHY
.3a1a8a	08		php		            PHP
.3a1a8b	8b		phb		            PHB
.3a1a8c	08		php		            PHP
.3a1a8d	e2 20		sep #$20	            SEP #$20
.3a1a8f	48		pha		            PHA
.3a1a90	a9 00		lda #$00	            LDA #0
.3a1a92	48		pha		            PHA
.3a1a93	ab		plb		            PLB
.3a1a94	68		pla		            PLA
.3a1a95	28		plp		            PLP
.3a1a96	e2 20		sep #$20	            SEP #$20
.3a1a98	a4 21		ldy $0821	            LDY OPERATORSP      ; Peek at the top operator
.3a1a9a	b9 01 00	lda $0001,y	            LDA #1,B,Y
.3a1a9d	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the marker for the start of a parameter list
.3a1a9f	d0 08		bne $3a1aa9	            BNE error           ; No: there's a problem
.3a1aa1	c2 20		rep #$20	            REP #$20
.3a1aa3	e6 21		inc $0821	            INC OPERATORSP      ; Yes: remove it from the operator stack.
.3a1aa5	ab		plb		            PLB
.3a1aa6	28		plp		            PLP
.3a1aa7	7a		ply		            PLY
.3a1aa8	60		rts		            RTS
.3a1aa9					error
.3a1aa9	08		php		            PHP
.3a1aaa	c2 20		rep #$20	            REP #$20
.3a1aac	48		pha		            PHA
.3a1aad	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1ab0	5b		tcd		            TCD
.3a1ab1	68		pla		            PLA
.3a1ab2	28		plp		            PLP
.3a1ab3	e2 20		sep #$20	            SEP #$20
.3a1ab5	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a1ab7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1abb	c2 20		rep #$20	            REP #$20
.3a1abd	29 ff 00	and #$00ff	            AND #$00FF
.3a1ac0	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a1ac3	e2 20		sep #$20	            SEP #$20
.3a1ac5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1ac8					OPHIGHPREC
.3a1ac8	48		pha		            PHA
.3a1ac9	08		php		            PHP
.3a1aca	0b		phd		            PHD
.3a1acb	8b		phb		            PHB
.3a1acc	08		php		            PHP
.3a1acd	c2 20		rep #$20	            REP #$20
.3a1acf	48		pha		            PHA
.3a1ad0	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1ad3	5b		tcd		            TCD
.3a1ad4	68		pla		            PLA
.3a1ad5	28		plp		            PLP
.3a1ad6	08		php		            PHP
.3a1ad7	e2 20		sep #$20	            SEP #$20
.3a1ad9	48		pha		            PHA
.3a1ada	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a1adc	48		pha		            PHA
.3a1add	ab		plb		            PLB
.3a1ade	68		pla		            PLA
.3a1adf	28		plp		            PLP
.3a1ae0	e2 20		sep #$20	            SEP #$20
.3a1ae2	a4 21		ldy $0821	            LDY OPERATORSP
.3a1ae4	c0 ff 7f	cpy #$7fff	            CPY #OPERATOR_TOP       ; Is the stack empty?
.3a1ae7	f0 11		beq $3a1afa	            BEQ is_false            ; Yes: return false
.3a1ae9	20 5a 0c	jsr $3a0c5a	            JSR TOKPRECED
.3a1aec	85 0c		sta $080c	            STA SCRATCH             ; Save it for later comparison
.3a1aee	b9 01 00	lda $0001,y	            LDA #1,B,Y              ; Get the operator at the top of the stack
.3a1af1	20 5a 0c	jsr $3a0c5a	            JSR TOKPRECED
.3a1af4	c5 0c		cmp $080c	            CMP SCRATCH             ; Compare the priorities (0 = highest priority)
.3a1af6	f0 02		beq $3a1afa	            BEQ is_false            ; A = SCRATCH, return false
.3a1af8	90 08		bcc $3a1b02	            BCC is_true             ; A < SCRATCH (A is higher priority), return false
.3a1afa					is_false
.3a1afa	c2 20		rep #$20	            REP #$20
.3a1afc	ab		plb		            PLB
.3a1afd	2b		pld		            PLD
.3a1afe	28		plp		            PLP
.3a1aff	68		pla		            PLA
.3a1b00	18		clc		            CLC
.3a1b01	60		rts		            RTS
.3a1b02					is_true
.3a1b02	c2 20		rep #$20	            REP #$20
.3a1b04	ab		plb		            PLB                     ; A > SCRATCH (A is lower priority), return true
.3a1b05	2b		pld		            PLD
.3a1b06	28		plp		            PLP
.3a1b07	68		pla		            PLA
.3a1b08	38		sec		            SEC
.3a1b09	60		rts		            RTS
.3a1b0a					ARR_GETIDX
.3a1b0a	08		php		            PHP
.3a1b0b	e2 20		sep #$20	            SEP #$20
.3a1b0d	a9 00		lda #$00	            LDA #0
.3a1b0f	8f 00 4d 00	sta $004d00	            STA @lARRIDXBUF     ; Set the dimension to 0
.3a1b13	a2 01 00	ldx #$0001	            LDX #1
.3a1b16					eval_index
.3a1b16	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a1b19	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a1b1c	c2 20		rep #$20	            REP #$20
.3a1b1e	a5 23		lda $0823	            LDA ARGUMENT1       ; Save the index to the array index buffer
.3a1b20	9f 00 4d 00	sta $004d00,x	            STA @l ARRIDXBUF,X
.3a1b24	e2 20		sep #$20	            SEP #$20
.3a1b26	af 00 4d 00	lda $004d00	            LDA @l ARRIDXBUF    ; Increment the index count
.3a1b2a	1a		inc a		            INC A
.3a1b2b	30 3e		bmi $3a1b6b	            BMI arg_err         ; If more than 127 dimensions, throw a range error
.3a1b2d	8f 00 4d 00	sta $004d00	            STA @l ARRIDXBUF
.3a1b31	e8		inx		            INX
.3a1b32	e8		inx		            INX
.3a1b33	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a1b36	e2 20		sep #$20	            SEP #$20
.3a1b38	a7 00		lda [$0800]	            LDA [BIP]           ; Check the next character
.3a1b3a	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it ")"
.3a1b3c	f0 09		beq $3a1b47	            BEQ clean_op        ; Yes: cleanup the argument stack
.3a1b3e	c9 2c		cmp #$2c	            CMP #','            ; Is it a comma?
.3a1b40	d0 0a		bne $3a1b4c	            BNE syntax_err      ; No: throw a syntax error
.3a1b42					skip_comma
.3a1b42	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a1b45	80 cf		bra $3a1b16	            BRA eval_index      ; And grab the next index
.3a1b47					clean_op
.3a1b47	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a1b4a	28		plp		            PLP
.3a1b4b	60		rts		            RTS
.3a1b4c					syntax_err
.3a1b4c	08		php		            PHP
.3a1b4d	c2 20		rep #$20	            REP #$20
.3a1b4f	48		pha		            PHA
.3a1b50	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1b53	5b		tcd		            TCD
.3a1b54	68		pla		            PLA
.3a1b55	28		plp		            PLP
.3a1b56	e2 20		sep #$20	            SEP #$20
.3a1b58	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a1b5a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1b5e	c2 20		rep #$20	            REP #$20
.3a1b60	29 ff 00	and #$00ff	            AND #$00FF
.3a1b63	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a1b66	e2 20		sep #$20	            SEP #$20
.3a1b68	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1b6b					arg_err
.3a1b6b	08		php		            PHP
.3a1b6c	c2 20		rep #$20	            REP #$20
.3a1b6e	48		pha		            PHA
.3a1b6f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1b72	5b		tcd		            TCD
.3a1b73	68		pla		            PLA
.3a1b74	28		plp		            PLP
.3a1b75	e2 20		sep #$20	            SEP #$20
.3a1b77	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a1b79	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1b7d	c2 20		rep #$20	            REP #$20
.3a1b7f	29 ff 00	and #$00ff	            AND #$00FF
.3a1b82	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a1b85	e2 20		sep #$20	            SEP #$20
.3a1b87	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1b8a					EVALREF
.3a1b8a	08		php		            PHP
.3a1b8b					get_name
.3a1b8b	20 1c 54	jsr $3a541c	            JSR VAR_FINDNAME
.3a1b8e	90 47		bcc $3a1bd7	            BCC syntax_err      ; If we didn't find a name, thrown an error
.3a1b90	e2 20		sep #$20	            SEP #$20
.3a1b92	a5 ea		lda $08ea	            LDA TOFINDTYPE      ; Check the type of the variable
.3a1b94	29 80		and #$80	            AND #$80            ; Is it an array?
.3a1b96	d0 06		bne $3a1b9e	            BNE is_array        ; Yes: look for the indexes
.3a1b98	20 1d 52	jsr $3a521d	            JSR VAR_REF
.3a1b9b	4c d5 1b	jmp $3a1bd5	            JMP done
.3a1b9e					is_array
.3a1b9e	20 8f 51	jsr $3a518f	            JSR VAR_FIND
.3a1ba1	90 53		bcc $3a1bf6	            BCC notfound
.3a1ba3	c2 20		rep #$20	            REP #$20
.3a1ba5	a5 c2		lda $08c2	            LDA CURRBLOCK+2
.3a1ba7	48		pha		            PHA
.3a1ba8	a5 c0		lda $08c0	            LDA CURRBLOCK
.3a1baa	48		pha		            PHA
.3a1bab	a0 09 00	ldy #$0009	            LDY #BINDING.VALUE
.3a1bae	b7 08		lda [$0808],y	            LDA [INDEX],Y       ; Save the pointer to the array to CURRBLOCK
.3a1bb0	85 c0		sta $08c0	            STA CURRBLOCK
.3a1bb2	e2 20		sep #$20	            SEP #$20
.3a1bb4	c8		iny		            INY
.3a1bb5	c8		iny		            INY
.3a1bb6	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a1bb8	85 c2		sta $08c2	            STA CURRBLOCK+2
.3a1bba	e2 20		sep #$20	            SEP #$20
.3a1bbc	a9 8f		lda #$8f	            LDA #TOK_LPAREN
.3a1bbe	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a1bc1	20 7f 1a	jsr $3a1a7f	            JSR OPENPARAMS
.3a1bc4					            PHARRIDX
.3a1bc4	20 0a 1b	jsr $3a1b0a	            JSR ARR_GETIDX
.3a1bc7	20 f3 68	jsr $3a68f3	            JSR ARR_REF
.3a1bca					            PLARRIDX
.3a1bca	20 89 1a	jsr $3a1a89	            JSR CLOSEPARAMS
.3a1bcd	c2 20		rep #$20	            REP #$20
.3a1bcf	68		pla		            PLA
.3a1bd0	85 c2		sta $08c2	            STA CURRBLOCK+2
.3a1bd2	68		pla		            PLA
.3a1bd3	85 c0		sta $08c0	            STA CURRBLOCK
.3a1bd5	28		plp		done        PLP
.3a1bd6	60		rts		            RTS
.3a1bd7					syntax_err
.3a1bd7	08		php		            PHP
.3a1bd8	c2 20		rep #$20	            REP #$20
.3a1bda	48		pha		            PHA
.3a1bdb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1bde	5b		tcd		            TCD
.3a1bdf	68		pla		            PLA
.3a1be0	28		plp		            PLP
.3a1be1	e2 20		sep #$20	            SEP #$20
.3a1be3	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a1be5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1be9	c2 20		rep #$20	            REP #$20
.3a1beb	29 ff 00	and #$00ff	            AND #$00FF
.3a1bee	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a1bf1	e2 20		sep #$20	            SEP #$20
.3a1bf3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1bf6					notfound
.3a1bf6	08		php		            PHP
.3a1bf7	c2 20		rep #$20	            REP #$20
.3a1bf9	48		pha		            PHA
.3a1bfa	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1bfd	5b		tcd		            TCD
.3a1bfe	68		pla		            PLA
.3a1bff	28		plp		            PLP
.3a1c00	e2 20		sep #$20	            SEP #$20
.3a1c02	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.3a1c04	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1c08	c2 20		rep #$20	            REP #$20
.3a1c0a	29 ff 00	and #$00ff	            AND #$00FF
.3a1c0d	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a1c10	e2 20		sep #$20	            SEP #$20
.3a1c12	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1c15					EVALSTRING
.3a1c15	08		php		            PHP
.3a1c16	0b		phd		            PHD
.3a1c17	08		php		            PHP
.3a1c18	c2 20		rep #$20	            REP #$20
.3a1c1a	48		pha		            PHA
.3a1c1b	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1c1e	5b		tcd		            TCD
.3a1c1f	68		pla		            PLA
.3a1c20	28		plp		            PLP
.3a1c21	e2 20		sep #$20	            SEP #$20
.3a1c23	c2 10		rep #$10	            REP #$10
.3a1c25	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a1c28	a0 00 00	ldy #$0000	            LDY #0              ; Ywill be our length counter
.3a1c2b	b7 00		lda [$0800],y	count_loop  LDA [BIP],Y         ; Get the character
.3a1c2d	f0 24		beq $3a1c53	            BEQ error           ; If it's end-of-line, throw an error
.3a1c2f	c9 22		cmp #$22	            CMP #CHAR_DQUOTE    ; Is it the ending double-quote?
.3a1c31	f0 03		beq $3a1c36	            BEQ found_end       ; Yes: Y should be the length
.3a1c33	c8		iny		            INY
.3a1c34	80 f5		bra $3a1c2b	            BRA count_loop
.3a1c36	84 0c		sty $080c	found_end   STY SCRATCH         ; Save the length to SCRATCH
.3a1c38	e2 20		sep #$20	            SEP #$20
.3a1c3a	a9 02		lda #$02	            LDA #TYPE_STRING    ; Set the type to allocate to STRING
.3a1c3c	a6 0c		ldx $080c	            LDX SCRATCH         ; And the length to the length of the string literal
.3a1c3e	e8		inx		            INX
.3a1c3f	20 01 15	jsr $3a1501	            JSR TEMPSTRING
.3a1c42	a0 00 00	ldy #$0000	            LDY #0
.3a1c45	c4 0c		cpy $080c	copy_loop   CPY SCRATCH         ; Have we copied all the characters?
.3a1c47	f0 29		beq $3a1c72	            BEQ done            ; Yes: we're done
.3a1c49	a7 00		lda [$0800]	            LDA [BIP]           ; No: get the next character
.3a1c4b	97 16		sta [$0816],y	            STA [STRPTR],Y      ; And copy it to the allocated string
.3a1c4d	c8		iny		            INY
.3a1c4e	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a1c51	80 f2		bra $3a1c45	            BRA copy_loop       ; And try the next character
.3a1c53					error
.3a1c53	08		php		            PHP
.3a1c54	c2 20		rep #$20	            REP #$20
.3a1c56	48		pha		            PHA
.3a1c57	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a1c5a	5b		tcd		            TCD
.3a1c5b	68		pla		            PLA
.3a1c5c	28		plp		            PLP
.3a1c5d	e2 20		sep #$20	            SEP #$20
.3a1c5f	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a1c61	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a1c65	c2 20		rep #$20	            REP #$20
.3a1c67	29 ff 00	and #$00ff	            AND #$00FF
.3a1c6a	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a1c6d	e2 20		sep #$20	            SEP #$20
.3a1c6f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a1c72	a9 00		lda #$00	done        LDA #0
.3a1c74	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a1c76	c2 20		rep #$20	            REP #$20
.3a1c78	a5 16		lda $0816	            LDA STRPTR
.3a1c7a	85 23		sta $0823	            STA ARGUMENT1
.3a1c7c	a5 18		lda $0818	            LDA STRPTR+2
.3a1c7e	85 25		sta $0825	            STA ARGUMENT1+2
.3a1c80	a9 02 00	lda #$0002	            LDA #TYPE_STRING    ; And set the type of ARGUMENT1 to string
.3a1c83	85 27		sta $0827	            STA ARGTYPE1
.3a1c85	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a1c88	2b		pld		            PLD
.3a1c89	28		plp		            PLP
.3a1c8a	60		rts		            RTS
.3a1c8b					EVAL_FUNC
.3a1c8b	08		php		            PHP
.3a1c8c	e2 20		sep #$20	            SEP #$20
.3a1c8e	a7 00		lda [$0800]	            LDA [BIP]           ; Get the token
.3a1c90	c2 20		rep #$20	            REP #$20
.3a1c92	29 ff 00	and #$00ff	            AND #$00FF
.3a1c95	20 84 0c	jsr $3a0c84	            JSR TOKEVAL
.3a1c98	85 2f		sta $082f	            STA JMP16PTR
.3a1c9a	20 7f 1a	jsr $3a1a7f	            JSR OPENPARAMS
.3a1c9d	08		php		            PHP
.3a1c9e	e2 20		sep #$20	            SEP #$20
.3a1ca0	48		pha		            PHA
.3a1ca1	a9 00		lda #$00	            LDA #0
.3a1ca3	48		pha		            PHA
.3a1ca4	ab		plb		            PLB
.3a1ca5	68		pla		            PLA
.3a1ca6	28		plp		            PLP
.3a1ca7	20 af 1c	jsr $3a1caf	            JSR OPSTUB
.3a1caa	20 89 1a	jsr $3a1a89	            JSR CLOSEPARAMS
.3a1cad	28		plp		            PLP
.3a1cae	60		rts		            RTS
.3a1caf					OPSTUB
.3a1caf	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a1cb2	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.3a1cb5					PROCESSOP
.3a1cb5	48		pha		            PHA
.3a1cb6	08		php		            PHP
.3a1cb7	0b		phd		            PHD
.3a1cb8	8b		phb		            PHB
.3a1cb9	08		php		            PHP
.3a1cba	c2 20		rep #$20	            REP #$20
.3a1cbc	48		pha		            PHA
.3a1cbd	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1cc0	5b		tcd		            TCD
.3a1cc1	68		pla		            PLA
.3a1cc2	28		plp		            PLP
.3a1cc3	c2 30		rep #$30	            REP #$30
.3a1cc5	20 51 1a	jsr $3a1a51	            JSR PLOPERATOR
.3a1cc8	89 80 00	bit #$0080	            BIT #$80            ; Check if it's really a token
.3a1ccb	f0 37		beq $3a1d04	            BEQ bad_token       ; No: it's a bad token
.3a1ccd	48		pha		            PHA
.3a1cce	20 84 0c	jsr $3a0c84	            JSR TOKEVAL
.3a1cd1	85 2f		sta $082f	            STA JMP16PTR
.3a1cd3	68		pla		            PLA
.3a1cd4	20 d1 0c	jsr $3a0cd1	            JSR TOKARITY
.3a1cd7	c9 01 00	cmp #$0001	            CMP #1              ; Check the operator's arity
.3a1cda	f0 08		beq $3a1ce4	            BEQ pull_arg1       ; If it's 1 just pull one argument from the stack
.3a1cdc	c2 30		rep #$30	            REP #$30
.3a1cde	a2 29 08	ldx #$0829	            LDX #<>ARGUMENT2    ; Pull argument 2 from the stack
.3a1ce1	20 e9 19	jsr $3a19e9	            JSR PLARGUMENT
.3a1ce4					pull_arg1
.3a1ce4	c2 30		rep #$30	            REP #$30
.3a1ce6	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Pull argument 1 from the stack
.3a1ce9	20 e9 19	jsr $3a19e9	            JSR PLARGUMENT
.3a1cec	08		php		            PHP
.3a1ced	e2 20		sep #$20	            SEP #$20
.3a1cef	48		pha		            PHA
.3a1cf0	a9 00		lda #$00	            LDA #0
.3a1cf2	48		pha		            PHA
.3a1cf3	ab		plb		            PLB
.3a1cf4	68		pla		            PLA
.3a1cf5	28		plp		            PLP
.3a1cf6	20 06 1d	jsr $3a1d06	            JSR OPSTUB
.3a1cf9	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1    ; Get return result in argument 1
.3a1cfc	20 ab 19	jsr $3a19ab	            JSR PHARGUMENT
.3a1cff	ab		plb		            PLB
.3a1d00	2b		pld		            PLD
.3a1d01	28		plp		            PLP
.3a1d02	68		pla		            PLA
.3a1d03	60		rts		            RTS
.3a1d04	00		brk #		bad_token   BRK
.3a1d05	ea		nop		            NOP
.3a1d06	6c 2f 08	jmp ($082f)	OPSTUB      JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.3a1d09					EVALEXPR
.3a1d09	08		php		            PHP
.3a1d0a	08		php		            PHP
.3a1d0b	c2 20		rep #$20	            REP #$20
.3a1d0d	48		pha		            PHA
.3a1d0e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1d11	5b		tcd		            TCD
.3a1d12	68		pla		            PLA
.3a1d13	28		plp		            PLP
.3a1d14	08		php		            PHP
.3a1d15	e2 20		sep #$20	            SEP #$20
.3a1d17	48		pha		            PHA
.3a1d18	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a1d1a	48		pha		            PHA
.3a1d1b	ab		plb		            PLB
.3a1d1c	68		pla		            PLA
.3a1d1d	28		plp		            PLP
.3a1d1e	c2 10		rep #$10	            REP #$10
.3a1d20	da		phx		            PHX
.3a1d21					get_char
.3a1d21	e2 20		sep #$20	            SEP #$20
.3a1d23	a7 00		lda [$0800]	            LDA [BIP]           ; Get the character
.3a1d25	d0 03		bne $3a1d2a	            BNE else1
.3a1d27	4c cc 1d	jmp $3a1dcc	            JMP proc_stack      ; Handle end of line, if we see it
.3a1d2a	30 33		bmi $3a1d5f	else1       BMI is_token        ; If MSB is set, it's a token
.3a1d2c	c9 20		cmp #$20	            CMP #' '            ; Is it a space?
.3a1d2e	d0 03		bne $3a1d33	            BNE else2
.3a1d30	4c c6 1d	jmp $3a1dc6	            JMP next_char       ; Yes: Skip to the next character
.3a1d33	c9 3a		cmp #$3a	else2       CMP #'9'+1          ; Check to see if we have digits
.3a1d35	b0 04		bcs $3a1d3b	            BCS else3           ; No: treat as the end of the line
.3a1d37	c9 30		cmp #$30	            CMP #'0'
.3a1d39	b0 56		bcs $3a1d91	            BCS is_digit
.3a1d3b	c9 26		cmp #$26	else3       CMP #'&'            ; Check for a hexadecimal prefix
.3a1d3d	f0 52		beq $3a1d91	            BEQ is_digit
.3a1d3f	c9 22		cmp #$22	            CMP #'"'            ; Is it a double-quote?
.3a1d41	d0 03		bne $3a1d46	            BNE else4
.3a1d43	4c df 1d	jmp $3a1ddf	            JMP is_string       ; Yes: process the string
.3a1d46	c9 5b		cmp #$5b	else4       CMP #'Z'+1          ; Check to see if we have upper case alphabetics
.3a1d48	b0 07		bcs $3a1d51	            BCS check_lc        ; No: check for lower case
.3a1d4a	c9 41		cmp #$41	            CMP #'A'
.3a1d4c	90 03		bcc $3a1d51	            BCC check_lc
.3a1d4e	4c eb 1d	jmp $3a1deb	            JMP is_alpha
.3a1d51	c9 7b		cmp #$7b	check_lc    CMP #'z'+1          ; Check to see if we have lower case alphabetics
.3a1d53	b0 07		bcs $3a1d5c	            BCS else5           ; No: treat as the end of the line
.3a1d55	c9 61		cmp #$61	            CMP #'a'
.3a1d57	90 03		bcc $3a1d5c	            BCC else5
.3a1d59	4c eb 1d	jmp $3a1deb	            JMP is_alpha
.3a1d5c	4c cc 1d	jmp $3a1dcc	else5       JMP proc_stack
.3a1d5f	c9 8f		cmp #$8f	is_token    CMP #TOK_LPAREN     ; Is it an LPAREN
.3a1d61	f0 40		beq $3a1da3	            BEQ is_lparen       ; Yes: handle the LPAREN
.3a1d63	c9 90		cmp #$90	            CMP #TOK_RPAREN     ; Is it an RPAREN?
.3a1d65	f0 41		beq $3a1da8	            BEQ is_rparen       ; Yes: handle the RPAREN
.3a1d67	20 a7 0c	jsr $3a0ca7	            JSR TOKTYPE
.3a1d6a	c9 30		cmp #$30	            CMP #TOK_TY_FUNC    ; Is it a function?
.3a1d6c	d0 0c		bne $3a1d7a	            BNE chk_op          ; No: check if it's an operator
.3a1d6e	20 8b 1c	jsr $3a1c8b	            JSR EVAL_FUNC
.3a1d71	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.3a1d74	20 ab 19	jsr $3a19ab	            JSR PHARGUMENT
.3a1d77	4c 21 1d	jmp $3a1d21	            JMP get_char
.3a1d7a	c9 00		cmp #$00	chk_op      CMP #TOK_TY_OP      ; Is it an operator?
.3a1d7c	d0 4e		bne $3a1dcc	            BNE proc_stack      ; No: we're finished processing
.3a1d7e	a7 00		lda [$0800]	            LDA [BIP]           ; Yes: Get the token back
.3a1d80	a6 21		ldx $0821	chk_prec    LDX OPERATORSP      ; Is the operator stack empty?
.3a1d82	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.3a1d85	f0 05		beq $3a1d8c	            BEQ push_op         ; Yes: push the operator
.3a1d87	20 c8 1a	jsr $3a1ac8	            JSR OPHIGHPREC
.3a1d8a	b0 12		bcs $3a1d9e	            BCS process1        ; No: we should process the top operator
.3a1d8c					push_op
.3a1d8c	20 28 1a	jsr $3a1a28	            JSR PHOPERATOR
.3a1d8f	80 35		bra $3a1dc6	            BRA next_char       ; And go to the next character
.3a1d91					is_digit
.3a1d91	c2 20		rep #$20	            REP #$20
.3a1d93	20 3e 5a	jsr $3a5a3e	            JSR PARSENUM
.3a1d96	a2 23 08	ldx #$0823	got_number  LDX #<>ARGUMENT1
.3a1d99	20 ab 19	jsr $3a19ab	            JSR PHARGUMENT
.3a1d9c	80 83		bra $3a1d21	            BRA get_char
.3a1d9e					process1
.3a1d9e	20 b5 1c	jsr $3a1cb5	            JSR PROCESSOP
.3a1da1	80 dd		bra $3a1d80	            BRA chk_prec        ; And check what to do with the current operator
.3a1da3					is_lparen
.3a1da3	20 28 1a	jsr $3a1a28	            JSR PHOPERATOR
.3a1da6	80 1e		bra $3a1dc6	            BRA next_char
.3a1da8					is_rparen
.3a1da8	e2 20		sep #$20	            SEP #$20
.3a1daa	a4 21		ldy $0821	            LDY OPERATORSP      ; Is the operator stack empty?
.3a1dac	c0 ff 7f	cpy #$7fff	            CPY #<>OPERATOR_TOP
.3a1daf	f0 46		beq $3a1df7	            BEQ done            ; Yes: we're done evaluating things
.3a1db1	a4 21		ldy $0821	paren_loop  LDY OPERATORSP      ; Peek at the top operator
.3a1db3	b9 01 00	lda $0001,y	            LDA #1,B,Y
.3a1db6	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is it the LPAREN of a function?
.3a1db8	f0 3d		beq $3a1df7	            BEQ done            ; Yes: treat it as an empty stack
.3a1dba	c9 8f		cmp #$8f	            CMP #TOK_LPAREN     ; Is it an LPAREN?
.3a1dbc	f0 05		beq $3a1dc3	            BEQ done_rparen     ; Yes: we're finished processing
.3a1dbe	20 b5 1c	jsr $3a1cb5	            JSR PROCESSOP
.3a1dc1	80 ee		bra $3a1db1	            BRA paren_loop
.3a1dc3					done_rparen
.3a1dc3	20 51 1a	jsr $3a1a51	            JSR PLOPERATOR
.3a1dc6					next_char
.3a1dc6	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a1dc9	4c 21 1d	jmp $3a1d21	            JMP get_char
.3a1dcc					proc_stack
.3a1dcc	a6 21		ldx $0821	            LDX OPERATORSP      ; Is the operator stack empty?
.3a1dce	e0 ff 7f	cpx #$7fff	            CPX #<>OPERATOR_TOP
.3a1dd1	b0 24		bcs $3a1df7	            BGE done            ; Yes: return to the caller
.3a1dd3	bd 01 00	lda $0001,x	            LDA #1,B,X
.3a1dd6	c9 01		cmp #$01	            CMP #TOK_FUNC_OPEN  ; Is top operator a function open?
.3a1dd8	f0 1d		beq $3a1df7	            BEQ done            ; Yes: treat as end of expression
.3a1dda	20 b5 1c	jsr $3a1cb5	            JSR PROCESSOP
.3a1ddd	80 ed		bra $3a1dcc	            BRA proc_stack
.3a1ddf					is_string
.3a1ddf	20 15 1c	jsr $3a1c15	            JSR EVALSTRING
.3a1de2	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.3a1de5	20 ab 19	jsr $3a19ab	            JSR PHARGUMENT
.3a1de8	4c 21 1d	jmp $3a1d21	            JMP get_char
.3a1deb					is_alpha
.3a1deb	20 8a 1b	jsr $3a1b8a	            JSR EVALREF
.3a1dee	a2 23 08	ldx #$0823	            LDX #<>ARGUMENT1
.3a1df1	20 ab 19	jsr $3a19ab	            JSR PHARGUMENT
.3a1df4	4c 21 1d	jmp $3a1d21	            JMP get_char
.3a1df7	a2 23 08	ldx #$0823	done        LDX #<>ARGUMENT1    ; Make sure the result is off the stack
.3a1dfa	20 e9 19	jsr $3a19e9	            JSR PLARGUMENT
.3a1dfd					real_done
.3a1dfd	fa		plx		            PLX
.3a1dfe	28		plp		            PLP
.3a1dff	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\returnstack.s

.3a1e00					INITRETURN
.3a1e00	08		php		                PHP
.3a1e01	0b		phd		                PHD
.3a1e02	8b		phb		                PHB
.3a1e03	08		php		            PHP
.3a1e04	e2 20		sep #$20	            SEP #$20
.3a1e06	48		pha		            PHA
.3a1e07	a9 00		lda #$00	            LDA #0
.3a1e09	48		pha		            PHA
.3a1e0a	ab		plb		            PLB
.3a1e0b	68		pla		            PLA
.3a1e0c	28		plp		            PLP
.3a1e0d	08		php		            PHP
.3a1e0e	c2 20		rep #$20	            REP #$20
.3a1e10	48		pha		            PHA
.3a1e11	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1e14	5b		tcd		            TCD
.3a1e15	68		pla		            PLA
.3a1e16	28		plp		            PLP
.3a1e17	c2 30		rep #$30	            REP #$30
.3a1e19	a9 fd 5f	lda #$5ffd	                LDA #RETURN_TOP-2
.3a1e1c	85 33		sta $0833	                STA RETURNSP
.3a1e1e	ab		plb		                PLB
.3a1e1f	2b		pld		                PLD
.3a1e20	28		plp		                PLP
.3a1e21	60		rts		            RTS
.3a1e22					PHRETURN
.3a1e22	08		php		                PHP
.3a1e23	0b		phd		                PHD
.3a1e24	08		php		            PHP
.3a1e25	c2 20		rep #$20	            REP #$20
.3a1e27	48		pha		            PHA
.3a1e28	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1e2b	5b		tcd		            TCD
.3a1e2c	68		pla		            PLA
.3a1e2d	28		plp		            PLP
.3a1e2e	c2 30		rep #$30	            REP #$30
.3a1e30	92 33		sta ($0833)	                STA (RETURNSP)
.3a1e32	c6 33		dec $0833	                DEC RETURNSP
.3a1e34	c6 33		dec $0833	                DEC RETURNSP
.3a1e36	2b		pld		                PLD
.3a1e37	28		plp		                PLP
.3a1e38	60		rts		            RTS
.3a1e39					PHRETURNB
.3a1e39	08		php		                PHP
.3a1e3a	c2 30		rep #$30	            REP #$30
.3a1e3c	29 ff 00	and #$00ff	                AND #$00FF
.3a1e3f	20 22 1e	jsr $3a1e22	            JSR PHRETURN
.3a1e42	28		plp		                PLP
.3a1e43	60		rts		            RTS
.3a1e44					PLRETURN
.3a1e44	08		php		                PHP
.3a1e45	0b		phd		                PHD
.3a1e46	08		php		            PHP
.3a1e47	c2 20		rep #$20	            REP #$20
.3a1e49	48		pha		            PHA
.3a1e4a	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1e4d	5b		tcd		            TCD
.3a1e4e	68		pla		            PLA
.3a1e4f	28		plp		            PLP
.3a1e50	c2 30		rep #$30	            REP #$30
.3a1e52	e6 33		inc $0833	                INC RETURNSP
.3a1e54	e6 33		inc $0833	                INC RETURNSP
.3a1e56	b2 33		lda ($0833)	                LDA (RETURNSP)
.3a1e58	2b		pld		                PLD
.3a1e59	28		plp		                PLP
.3a1e5a	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\interpreter.s

=$80					ST_RUNNING = $80            ; The interpreter is running a full program
=$00					ST_INTERACT = $00           ; The interpreter is in interactive mode
>08d2					STATE       .byte ?         ; The state of the interpreter ()
>08d3					ERROR_NUM   .byte ?         ; The type of the error
>08d4					HANDLEERR   .long ?         ; Pointer to the error handler
>08d7					LINENUM     .word ?         ; The current line number
>08d9					LASTLINE    .long ?         ; Pointer to the next free space over the BASIC program
>08dc					EXECACTION  .byte ?         ; The action the exection routines should take to get their next statement
=0					LINE_LINK = 0               ; Offset to the link to the next line
=2					LINE_NUMBER = 2             ; Offset to the line number
=4					LINE_TOKENS = 4             ; Offset to the first token
=6					LINE_MINLEN = 6             ; Minimum length of a line
=0					EXEC_CONT = 0               ; Continue advancing the current line
=1					EXEC_STOP = 1               ; Stop execution of the program
=2					EXEC_GOTO = 2               ; Transfer execution to a new CURLINE that is already set
=3					EXEC_RETURN = 3             ; Transfer execution back to a line that was on the stack
.3a1e5b					SET_ERRERL
.3a1e5b	8b		phb		                PHB
.3a1e5c	0b		phd		                PHD
.3a1e5d	08		php		                PHP
.3a1e5e	08		php		            PHP
.3a1e5f	c2 20		rep #$20	            REP #$20
.3a1e61	48		pha		            PHA
.3a1e62	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a1e65	5b		tcd		            TCD
.3a1e66	68		pla		            PLA
.3a1e67	28		plp		            PLP
.3a1e68	08		php		            PHP
.3a1e69	e2 20		sep #$20	            SEP #$20
.3a1e6b	48		pha		            PHA
.3a1e6c	a9 00		lda #$00	            LDA #BASIC_BANK
.3a1e6e	48		pha		            PHA
.3a1e6f	ab		plb		            PLB
.3a1e70	68		pla		            PLA
.3a1e71	28		plp		            PLP
.3a1e72	c2 20		rep #$20	            REP #$20
.3a1e74	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.3a1e76	a9 00 00	lda #$0000	                LDA #0
.3a1e79	85 25		sta $0825	                STA ARGUMENT1+2
.3a1e7b	e2 20		sep #$20	            SEP #$20
.3a1e7d	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a1e7f	85 27		sta $0827	                STA ARGTYPE1
.3a1e81	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.3a1e83	a9 3a		lda #$3a	                LDA #`err_name
.3a1e85	85 e9		sta $08e9	                STA TOFIND+2
.3a1e87	c2 20		rep #$20	            REP #$20
.3a1e89	a9 b5 1e	lda #$1eb5	                LDA #<>err_name
.3a1e8c	85 e7		sta $08e7	                STA TOFIND
.3a1e8e	20 7f 53	jsr $3a537f	            JSR VAR_SET
.3a1e91	c2 20		rep #$20	            REP #$20
.3a1e93	a5 d7		lda $08d7	                LDA LINENUM
.3a1e95	85 23		sta $0823	                STA ARGUMENT1               ; Get any result returned
.3a1e97	a5 d9		lda $08d9	                LDA LINENUM+2
.3a1e99	85 25		sta $0825	                STA ARGUMENT1+2
.3a1e9b	e2 20		sep #$20	            SEP #$20
.3a1e9d	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a1e9f	85 27		sta $0827	                STA ARGTYPE1
.3a1ea1	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BRUN_RESULT)
.3a1ea3	a9 3a		lda #$3a	                LDA #`erl_name
.3a1ea5	85 e9		sta $08e9	                STA TOFIND+2
.3a1ea7	c2 20		rep #$20	            REP #$20
.3a1ea9	a9 b9 1e	lda #$1eb9	                LDA #<>erl_name
.3a1eac	85 e7		sta $08e7	                STA TOFIND
.3a1eae	20 7f 53	jsr $3a537f	            JSR VAR_SET
.3a1eb1	28		plp		                PLP
.3a1eb2	2b		pld		                PLD
.3a1eb3	ab		plb		                PLB
.3a1eb4	60		rts		            RTS
>3a1eb5	45 52 52 00			err_name        .null "ERR"
>3a1eb9	45 52 4c 00			erl_name        .null "ERL"
.3a1ebd					ON_ERROR
.3a1ebd	e2 20		sep #$20	            SEP #$20
.3a1ebf	c2 10		rep #$10	            REP #$10
.3a1ec1	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a1ec4	af d3 08 00	lda $0008d3	            LDA @lERROR_NUM         ; Calculate index to the error message pointer
.3a1ec8	0a		asl a		            ASL A
.3a1ec9	c2 20		rep #$20	            REP #$20
.3a1ecb	29 ff 00	and #$00ff	            AND #$00FF
.3a1ece	a8		tay		            TAY
.3a1ecf	08		php		            PHP
.3a1ed0	e2 20		sep #$20	            SEP #$20
.3a1ed2	48		pha		            PHA
.3a1ed3	a9 3a		lda #$3a	            LDA #`ERRORMSG
.3a1ed5	48		pha		            PHA
.3a1ed6	ab		plb		            PLB
.3a1ed7	68		pla		            PLA
.3a1ed8	28		plp		            PLP
.3a1ed9	be 0f 1f	ldx $3a1f0f,y	            LDX ERRORMSG,Y
.3a1edc	20 64 04	jsr $3a0464	            JSR PRINTS
.3a1edf	c2 20		rep #$20	            REP #$20
.3a1ee1	a5 d7		lda $08d7	            LDA LINENUM
.3a1ee3	f0 27		beq $3a1f0c	            BEQ skip_at
.3a1ee5	a2 3f 1f	ldx #$1f3f	            LDX #<>MSG_AT           ; If so... print " AT "
.3a1ee8	20 64 04	jsr $3a0464	            JSR PRINTS
.3a1eeb	08		php		            PHP
.3a1eec	e2 20		sep #$20	            SEP #$20
.3a1eee	48		pha		            PHA
.3a1eef	a9 00		lda #$00	            LDA #BASIC_BANK
.3a1ef1	48		pha		            PHA
.3a1ef2	ab		plb		            PLB
.3a1ef3	68		pla		            PLA
.3a1ef4	28		plp		            PLP
.3a1ef5	c2 20		rep #$20	            REP #$20
.3a1ef7	af d7 08 00	lda $0008d7	            LDA @lLINENUM           ; ... and then the line number
.3a1efb	8f 23 08 00	sta $000823	            STA @lARGUMENT1
.3a1eff	a9 00 00	lda #$0000	            LDA #0
.3a1f02	8f 25 08 00	sta $000825	            STA @lARGUMENT1+2
.3a1f06	20 1a 46	jsr $3a461a	            JSR PR_INTEGER
.3a1f09	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a1f0c					skip_at
.3a1f0c	4c bc 27	jmp $3a27bc	            JMP INTERACT
>3a1f0f	43 1f				ERRORMSG    .word <>MSG_OK
>3a1f11	46 1f				            .word <>MSG_BREAK
>3a1f13	4c 1f				            .word <>MSG_SYNTAX
>3a1f15	59 1f				            .word <>MSG_MEMORY
>3a1f17	67 1f				            .word <>MSG_TYPE
>3a1f19	75 1f				            .word <>MSG_NOTFND
>3a1f1b	88 1f				            .word <>MSG_NOLINE
>3a1f1d	9e 1f				            .word <>MSG_UNDFLOW
>3a1f1f	ae 1f				            .word <>MSG_OVRFLOW
>3a1f21	bd 1f				            .word <>MSG_RANGE
>3a1f23	ca 1f				            .word <>MSG_ARG
>3a1f25	db 1f				            .word <>MSG_NOFILE
>3a1f27	ea 1f				            .word <>MSG_NAN
>3a1f29	f7 1f				            .word <>MSG_OVERFLOW
>3a1f2b	05 20				            .word <>MSG_UNDERFLOW
>3a1f2d	14 20				            .word <>MSG_DIV0
>3a1f2f	25 20				            .word <>MSG_DIRECTORY
>3a1f31	3e 20				            .word <>MSG_LOAD
>3a1f33	52 20				            .word <>MSG_SAVE
>3a1f35	66 20				            .word <>MSG_DELETE
>3a1f37	7c 20				            .word <>MSG_FILENOTFND
>3a1f39	90 20				            .word <>MSG_DIRNOTWRITE
>3a1f3b	ab 20				            .word <>MSG_NOTCOPIED
>3a1f3d	c3 20				            .word <>MSG_DOMAIN
>3a1f3f	20 61 74 00			MSG_AT          .null " at"
>3a1f43	4f 4b 00			MSG_OK          .null "OK"
>3a1f46	42 72 65 61 6b 00		MSG_BREAK       .null "Break"
>3a1f4c	53 79 6e 74 61 78 20 65		MSG_SYNTAX      .null "Syntax error"
>3a1f54	72 72 6f 72 00
>3a1f59	4f 75 74 20 6f 66 20 6d		MSG_MEMORY      .null "Out of memory"
>3a1f61	65 6d 6f 72 79 00
>3a1f67	54 79 70 65 20 6d 69 73		MSG_TYPE        .null "Type mismatch"
>3a1f6f	6d 61 74 63 68 00
>3a1f75	56 61 72 69 61 62 6c 65		MSG_NOTFND      .null "Variable not found"
>3a1f7d	20 6e 6f 74 20 66 6f 75 6e 64 00
>3a1f88	4c 69 6e 65 20 6e 75 6d		MSG_NOLINE      .null "Line number not found"
>3a1f90	62 65 72 20 6e 6f 74 20 66 6f 75 6e 64 00
>3a1f9e	53 74 61 63 6b 20 75 6e		MSG_UNDFLOW     .null "Stack underflow"
>3a1fa6	64 65 72 66 6c 6f 77 00
>3a1fae	53 74 61 63 6b 20 6f 76		MSG_OVRFLOW     .null "Stack overflow"
>3a1fb6	65 72 66 6c 6f 77 00
>3a1fbd	4f 75 74 20 6f 66 20 72		MSG_RANGE       .null "Out of range"
>3a1fc5	61 6e 67 65 00
>3a1fca	49 6c 6c 65 67 61 6c 20		MSG_ARG         .null "Illegal argument"
>3a1fd2	61 72 67 75 6d 65 6e 74 00
>3a1fdb	46 69 6c 65 20 6e 6f 74		MSG_NOFILE      .null "File not found"
>3a1fe3	20 66 6f 75 6e 64 00
>3a1fea	4e 6f 74 20 61 20 6e 75		MSG_NAN         .null "Not a number"
>3a1ff2	6d 62 65 72 00
>3a1ff7	4d 61 74 68 20 6f 76 65		MSG_OVERFLOW    .null "Math overflow"
>3a1fff	72 66 6c 6f 77 00
>3a2005	4d 61 74 68 20 75 6e 64		MSG_UNDERFLOW   .null "Math underflow"
>3a200d	65 72 66 6c 6f 77 00
>3a2014	44 69 76 69 73 69 6f 6e		MSG_DIV0        .null "Division by zero"
>3a201c	20 62 79 20 7a 65 72 6f 00
>3a2025	55 6e 61 62 6c 65 20 74		MSG_DIRECTORY   .null "Unable to read directory"
>3a202d	6f 20 72 65 61 64 20 64 69 72 65 63 74 6f 72 79
>3a203d	00
>3a203e	55 6e 61 62 6c 65 20 74		MSG_LOAD        .null "Unable to load file"
>3a2046	6f 20 6c 6f 61 64 20 66 69 6c 65 00
>3a2052	55 6e 61 62 6c 65 20 74		MSG_SAVE        .null "Unable to save file"
>3a205a	6f 20 73 61 76 65 20 66 69 6c 65 00
>3a2066	55 6e 61 62 6c 65 20 74		MSG_DELETE      .null "Unable to delete file"
>3a206e	6f 20 64 65 6c 65 74 65 20 66 69 6c 65 00
>3a207c	43 6f 75 6c 64 20 6e 6f		MSG_FILENOTFND  .null "Could not find file"
>3a2084	74 20 66 69 6e 64 20 66 69 6c 65 00
>3a2090	43 6f 75 6c 64 20 6e 6f		MSG_DIRNOTWRITE .null "Could not update directory"
>3a2098	74 20 75 70 64 61 74 65 20 64 69 72 65 63 74 6f
>3a20a8	72 79 00
>3a20ab	43 6f 75 6c 64 20 6e 6f		MSG_NOTCOPIED   .null "Could not copy the file"
>3a20b3	74 20 63 6f 70 79 20 74 68 65 20 66 69 6c 65 00
>3a20c3	41 72 67 75 6d 65 6e 74		MSG_DOMAIN      .null "Argument outside domain"
>3a20cb	20 6f 75 74 73 69 64 65 20 64 6f 6d 61 69 6e 00
.3a20db					SETINTERACT
.3a20db	08		php		            PHP
.3a20dc	0b		phd		            PHD
.3a20dd	08		php		            PHP
.3a20de	c2 20		rep #$20	            REP #$20
.3a20e0	48		pha		            PHA
.3a20e1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a20e4	5b		tcd		            TCD
.3a20e5	68		pla		            PLA
.3a20e6	28		plp		            PLP
.3a20e7	e2 20		sep #$20	            SEP #$20
.3a20e9	a9 00		lda #$00	            LDA #ST_INTERACT
.3a20eb	85 d2		sta $08d2	            STA STATE
.3a20ed	2b		pld		            PLD
.3a20ee	28		plp		            PLP
.3a20ef	60		rts		            RTS
.3a20f0					CLRINTERP
.3a20f0	0b		phd		            PHD
.3a20f1	08		php		            PHP
.3a20f2	08		php		            PHP
.3a20f3	c2 20		rep #$20	            REP #$20
.3a20f5	48		pha		            PHA
.3a20f6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a20f9	5b		tcd		            TCD
.3a20fa	68		pla		            PLA
.3a20fb	28		plp		            PLP
.3a20fc	08		php		            PHP
.3a20fd	c2 20		rep #$20	            REP #$20
.3a20ff	a9 bd 1e	lda #$1ebd	            LDA #<>ON_ERROR
.3a2102	8f d4 08 00	sta $0008d4	            STA @lHANDLEERR
.3a2106	e2 20		sep #$20	            SEP #$20
.3a2108	a9 3a		lda #$3a	            LDA #`ON_ERROR
.3a210a	8f d6 08 00	sta $0008d6	            STA @lHANDLEERR+2
.3a210e	28		plp		            PLP
.3a210f	20 c1 44	jsr $3a44c1	            JSR S_CLR
.3a2112	20 02 40	jsr $3a4002	            JSR S_RESTORE
.3a2115	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the depth of the GOSUB stack
.3a2117	28		plp		            PLP
.3a2118	2b		pld		            PLD
.3a2119	60		rts		            RTS
.3a211a					INCBIP
.3a211a	08		php		            PHP
.3a211b	0b		phd		            PHD
.3a211c	08		php		            PHP
.3a211d	c2 20		rep #$20	            REP #$20
.3a211f	48		pha		            PHA
.3a2120	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2123	5b		tcd		            TCD
.3a2124	68		pla		            PLA
.3a2125	28		plp		            PLP
.3a2126	c2 20		rep #$20	            REP #$20
.3a2128	18		clc		            CLC
.3a2129	a5 00		lda $0800	            LDA BIP
.3a212b	69 01 00	adc #$0001	            ADC #1
.3a212e	85 00		sta $0800	            STA BIP
.3a2130	e2 20		sep #$20	            SEP #$20
.3a2132	a5 02		lda $0802	            LDA BIP+2
.3a2134	69 00		adc #$00	            ADC #0
.3a2136	85 02		sta $0802	            STA BIP+2
.3a2138	2b		pld		            PLD
.3a2139	28		plp		            PLP
.3a213a	60		rts		            RTS
.3a213b					SKIPWS
.3a213b	08		php		            PHP
.3a213c	0b		phd		            PHD
.3a213d	08		php		            PHP
.3a213e	c2 20		rep #$20	            REP #$20
.3a2140	48		pha		            PHA
.3a2141	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2144	5b		tcd		            TCD
.3a2145	68		pla		            PLA
.3a2146	28		plp		            PLP
.3a2147	e2 20		sep #$20	            SEP #$20
.3a2149	a7 00		lda [$0800]	loop        LDA [BIP]
.3a214b	f0 0f		beq $3a215c	            BEQ done            ; If character is 0, we've reached the end of the line
.3a214d	c9 20		cmp #$20	            CMP #CHAR_SP        ; Skip if it's a space
.3a214f	f0 06		beq $3a2157	            BEQ skip_char
.3a2151	c9 09		cmp #$09	            CMP #CHAR_TAB       ; Skip if it's a TAB
.3a2153	f0 02		beq $3a2157	            BEQ skip_char
.3a2155	80 05		bra $3a215c	            BRA done            ; Otherwise, we're done and BIP points to a non-whitespace
.3a2157					skip_char
.3a2157	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a215a	80 ed		bra $3a2149	            BRA loop
.3a215c	2b		pld		done        PLD
.3a215d	28		plp		            PLP
.3a215e	60		rts		            RTS
.3a215f					SKIPSTMT
.3a215f	08		php		            PHP
.3a2160	e2 20		sep #$20	            SEP #$20
.3a2162	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the current character
.3a2164	f0 09		beq $3a216f	            BEQ done            ; Is it EOL? Yes, we're done
.3a2166	c9 3a		cmp #$3a	            CMP #':'            ; Is it a colon?
.3a2168	f0 05		beq $3a216f	            BEQ done            ; Yes, we're done
.3a216a	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a216d	80 f3		bra $3a2162	            BRA loop            ; and check it...
.3a216f	28		plp		done        PLP
.3a2170	60		rts		            RTS
.3a2171					SKIPTOTOK
.3a2171	08		php		            PHP
.3a2172	e2 20		sep #$20	            SEP #$20
.3a2174	64 36		stz $0836	            STZ NESTING
.3a2176	a7 00		lda [$0800]	loop        LDA [BIP]           ; Get the character
.3a2178	f0 19		beq $3a2193	            BEQ end_of_line     ; EOL? Yes: move to the next line
.3a217a	c5 37		cmp $0837	            CMP TARGETTOK       ; Is it the one we want?
.3a217c	f0 2c		beq $3a21aa	            BEQ check_depth     ; Yes: check the depth
.3a217e	c9 9b		cmp #$9b	            CMP #TOK_FOR        ; Is it a FOR?
.3a2180	f0 1e		beq $3a21a0	            BEQ inc_nesting     ; Yes: increment NESTING
.3a2182	c9 9f		cmp #$9f	            CMP #TOK_DO         ; Is it a DO?
.3a2184	f0 1a		beq $3a21a0	            BEQ inc_nesting     ; Yes: increment NESTING
.3a2186	c9 9e		cmp #$9e	            CMP #TOK_NEXT       ; Is it a NEXT?
.3a2188	f0 1a		beq $3a21a4	            BEQ dec_nesting     ; Yes: decrement NESTING
.3a218a	c9 a0		cmp #$a0	            CMP #TOK_LOOP       ; Is it a LOOP?
.3a218c	f0 16		beq $3a21a4	            BEQ dec_nesting     ; Yes: decrement NESTING
.3a218e					incloop
.3a218e	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a2191	80 e3		bra $3a2176	            BRA loop            ; and keep scanning
.3a2193					end_of_line
.3a2193	20 f7 21	jsr $3a21f7	            JSR NEXTLINE
.3a2196	c2 20		rep #$20	            REP #$20
.3a2198	a5 d7		lda $08d7	            LDA LINENUM         ; Check the line number
.3a219a	f0 1d		beq $3a21b9	            BEQ syntax_err1     ; If it's zero, we reached the end of the program
.3a219c	e2 20		sep #$20	            SEP #$20
.3a219e	80 d6		bra $3a2176	            BRA loop            ; And keep scanning
.3a21a0					inc_nesting
.3a21a0	e6 36		inc $0836	            INC NESTING         ; Track that we have entered a lexical scope for a FOR/DO
.3a21a2	80 ea		bra $3a218e	            BRA incloop
.3a21a4					dec_nesting
.3a21a4	c6 36		dec $0836	            DEC NESTING         ; Track that we have left a lexical scope for a FOR/DO
.3a21a6	30 30		bmi $3a21d8	            BMI syntax_err2     ; If the depth goes <0, throw a syntax error
.3a21a8	80 e4		bra $3a218e	            BRA incloop
.3a21aa					check_depth
.3a21aa	a5 35		lda $0835	            LDA SKIPNEST        ; Check to see if nesting matters
.3a21ac	30 06		bmi $3a21b4	            BMI found           ; No: just return that we found the token
.3a21ae	a5 36		lda $0836	            LDA NESTING         ; Get the nesting depth
.3a21b0	f0 02		beq $3a21b4	            BEQ found           ; If it's zero, we found our token
.3a21b2	80 da		bra $3a218e	            BRA incloop         ; Otherwise: it's a token for an enclosed FOR/DO, keep scanning
.3a21b4					found
.3a21b4	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a21b7	28		plp		            PLP
.3a21b8	60		rts		            RTS
.3a21b9					syntax_err1
.3a21b9	08		php		            PHP
.3a21ba	c2 20		rep #$20	            REP #$20
.3a21bc	48		pha		            PHA
.3a21bd	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a21c0	5b		tcd		            TCD
.3a21c1	68		pla		            PLA
.3a21c2	28		plp		            PLP
.3a21c3	e2 20		sep #$20	            SEP #$20
.3a21c5	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a21c7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a21cb	c2 20		rep #$20	            REP #$20
.3a21cd	29 ff 00	and #$00ff	            AND #$00FF
.3a21d0	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a21d3	e2 20		sep #$20	            SEP #$20
.3a21d5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a21d8					syntax_err2
.3a21d8	08		php		            PHP
.3a21d9	c2 20		rep #$20	            REP #$20
.3a21db	48		pha		            PHA
.3a21dc	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a21df	5b		tcd		            TCD
.3a21e0	68		pla		            PLA
.3a21e1	28		plp		            PLP
.3a21e2	e2 20		sep #$20	            SEP #$20
.3a21e4	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a21e6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a21ea	c2 20		rep #$20	            REP #$20
.3a21ec	29 ff 00	and #$00ff	            AND #$00FF
.3a21ef	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a21f2	e2 20		sep #$20	            SEP #$20
.3a21f4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a21f7					NEXTLINE
.3a21f7	08		php		            PHP
.3a21f8	c2 30		rep #$30	            REP #$30
.3a21fa	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.3a21fd	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the offset to the next line
.3a21ff	85 0c		sta $080c	            STA SCRATCH
.3a2201	18		clc		            CLC                 ; Compute the new CURLINE
.3a2202	a5 1a		lda $081a	            LDA CURLINE         ; CURLINE := [CURLINE].LINE_LINK
.3a2204	65 0c		adc $080c	            ADC SCRATCH
.3a2206	85 1a		sta $081a	            STA CURLINE
.3a2208	a5 1c		lda $081c	            LDA CURLINE+2
.3a220a	69 00 00	adc #$0000	            ADC #0
.3a220d	85 1c		sta $081c	            STA CURLINE+2
.3a220f	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the LINENUM to the new current line's number
.3a2212	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; LINENUM := [CURLINE].LINE_NUMBER
.3a2214	85 d7		sta $08d7	            STA LINENUM
.3a2216	18		clc		            CLC                 ; Point BIP to the first character of the line
.3a2217	a5 1a		lda $081a	            LDA CURLINE         ; BIP := CURLINE + LINE_TOKENS
.3a2219	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a221c	85 00		sta $0800	            STA BIP
.3a221e	a5 1c		lda $081c	            LDA CURLINE+2
.3a2220	69 00 00	adc #$0000	            ADC #0
.3a2223	85 02		sta $0802	            STA BIP+2
.3a2225	28		plp		            PLP
.3a2226	60		rts		            RTS
.3a2227					EXPECT_TOK
.3a2227	08		php		            PHP
.3a2228	e2 20		sep #$20	            SEP #$20
.3a222a	48		pha		            PHA
.3a222b	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a222e	68		pla		            PLA
.3a222f	e2 20		sep #$20	            SEP #$20
.3a2231	c7 00		cmp [$0800]	            CMP [BIP]           ; Check the character at BIP
.3a2233	d0 08		bne $3a223d	            BNE syntax_err      ; Throw a syntax error
.3a2235	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a2238	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a223b	28		plp		            PLP
.3a223c	60		rts		            RTS
.3a223d					syntax_err
.3a223d	08		php		            PHP
.3a223e	c2 20		rep #$20	            REP #$20
.3a2240	48		pha		            PHA
.3a2241	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2244	5b		tcd		            TCD
.3a2245	68		pla		            PLA
.3a2246	28		plp		            PLP
.3a2247	e2 20		sep #$20	            SEP #$20
.3a2249	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a224b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a224f	c2 20		rep #$20	            REP #$20
.3a2251	29 ff 00	and #$00ff	            AND #$00FF
.3a2254	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a2257	e2 20		sep #$20	            SEP #$20
.3a2259	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a225c					OPT_TOK
.3a225c	08		php		            PHP
.3a225d	e2 20		sep #$20	            SEP #$20
.3a225f	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a2262	e2 20		sep #$20	            SEP #$20
.3a2264	a7 00		lda [$0800]	loop        LDA [BIP]           ; Check the character at BIP
.3a2266	f0 10		beq $3a2278	            BEQ ret_false       ; If end-of-line, return false
.3a2268	c9 3a		cmp #$3a	            CMP #':'
.3a226a	f0 0c		beq $3a2278	            BEQ ret_false       ; If colon, return false
.3a226c	c5 37		cmp $0837	            CMP TARGETTOK
.3a226e	f0 05		beq $3a2275	            BEQ ret_true        ; If matches, return true
.3a2270	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a2273	80 ef		bra $3a2264	            BRA loop
.3a2275	28		plp		ret_true    PLP
.3a2276	38		sec		            SEC
.3a2277	60		rts		            RTS
.3a2278	28		plp		ret_false   PLP
.3a2279	18		clc		            CLC
.3a227a	60		rts		            RTS
.3a227b					PEEK_TOK
.3a227b	5a		phy		            PHY
.3a227c	08		php		            PHP
.3a227d	e2 20		sep #$20	            SEP #$20
.3a227f	a0 00 00	ldy #$0000	            LDY #0
.3a2282	b7 00		lda [$0800],y	loop        LDA [BIP],Y
.3a2284	f0 0d		beq $3a2293	            BEQ done
.3a2286	c9 3a		cmp #$3a	            CMP #':'
.3a2288	f0 07		beq $3a2291	            BEQ ret_null
.3a228a	c9 20		cmp #$20	            CMP #CHAR_SP
.3a228c	d0 05		bne $3a2293	            BNE done
.3a228e	c8		iny		            INY
.3a228f	80 f1		bra $3a2282	            BRA loop
.3a2291	a9 00		lda #$00	ret_null    LDA #0
.3a2293	28		plp		done        PLP
.3a2294	7a		ply		            PLY
.3a2295	60		rts		            RTS
.3a2296					EXECSTMT
.3a2296	08		php		            PHP
.3a2297	0b		phd		            PHD
.3a2298	8b		phb		            PHB
.3a2299	08		php		            PHP
.3a229a	c2 20		rep #$20	            REP #$20
.3a229c	48		pha		            PHA
.3a229d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a22a0	5b		tcd		            TCD
.3a22a1	68		pla		            PLA
.3a22a2	28		plp		            PLP
.3a22a3	20 f8 14	jsr $3a14f8	            JSR CLRTMPSTR
.3a22a6	20 8b 19	jsr $3a198b	            JSR INITEVALSP
.3a22a9	e2 20		sep #$20	            SEP #$20
.3a22ab	a9 00		lda #$00	            LDA #EXEC_CONT      ; This will tell EXECLINE and EXECPROG to procede in a
.3a22ad	85 dc		sta $08dc	            STA EXECACTION      ; linear fashion through the program
.3a22af	22 3c 11 00	jsl $00113c	check_break JSL FK_TESTBREAK
.3a22b3	b0 4b		bcs $3a2300	            BCS throw_break     ; If C: user pressed an interrupt key, stop the program
.3a22b5	a7 00		lda [$0800]	            LDA [BIP]           ; If we happen to have a colon, just skip over it.
.3a22b7	c9 3a		cmp #$3a	            CMP #':'            ; This can happen with FOR/NEXT
.3a22b9	d0 03		bne $3a22be	            BNE eat_ws
.3a22bb	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a22be					eat_ws
.3a22be	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a22c1	a7 00		lda [$0800]	            LDA [BIP]
.3a22c3	d0 03		bne $3a22c8	            BNE else
.3a22c5	4c 4a 23	jmp $3a234a	            JMP done            ; If the current byte is 0, we're at the end of the line, just return
.3a22c8					else
.3a22c8	20 e2 04	jsr $3a04e2	            JSR ISALPHA
.3a22cb	b0 52		bcs $3a231f	            BCS is_variable     ; Yes: we may have a LET statement
.3a22cd	a7 00		lda [$0800]	            LDA [BIP]           ; Check to see if it's any other non-token
.3a22cf	10 10		bpl $3a22e1	            BPL error           ; Yes: it's a syntax error
.3a22d1	20 a7 0c	jsr $3a0ca7	            JSR TOKTYPE
.3a22d4	85 0c		sta $080c	            STA SCRATCH         ; Save the type for later
.3a22d6	c9 20		cmp #$20	            CMP #TOK_TY_STMNT   ; Is it a statement?
.3a22d8	d0 03		bne $3a22dd	            BNE else2
.3a22da	4c 38 23	jmp $3a2338	            JMP ok_to_exec      ; Yes: it's ok to try to execute it
.3a22dd	a5 d2		lda $08d2	else2       LDA STATE           ; Check to see if we're in interactive mode
.3a22df	f0 51		beq $3a2332	            BEQ is_interact
.3a22e1					error
.3a22e1	08		php		            PHP
.3a22e2	c2 20		rep #$20	            REP #$20
.3a22e4	48		pha		            PHA
.3a22e5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a22e8	5b		tcd		            TCD
.3a22e9	68		pla		            PLA
.3a22ea	28		plp		            PLP
.3a22eb	e2 20		sep #$20	            SEP #$20
.3a22ed	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a22ef	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a22f3	c2 20		rep #$20	            REP #$20
.3a22f5	29 ff 00	and #$00ff	            AND #$00FF
.3a22f8	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a22fb	e2 20		sep #$20	            SEP #$20
.3a22fd	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2300					throw_break
.3a2300	08		php		            PHP
.3a2301	c2 20		rep #$20	            REP #$20
.3a2303	48		pha		            PHA
.3a2304	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2307	5b		tcd		            TCD
.3a2308	68		pla		            PLA
.3a2309	28		plp		            PLP
.3a230a	e2 20		sep #$20	            SEP #$20
.3a230c	a9 01		lda #$01	            LDA #ERR_BREAK
.3a230e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2312	c2 20		rep #$20	            REP #$20
.3a2314	29 ff 00	and #$00ff	            AND #$00FF
.3a2317	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a231a	e2 20		sep #$20	            SEP #$20
.3a231c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a231f					is_variable
.3a231f	20 cb 44	jsr $3a44cb	            JSR S_LET
.3a2322	4c 4a 23	jmp $3a234a	            JMP done
.3a2325					STSTUB
.3a2325	08		php		            PHP
.3a2326	e2 20		sep #$20	            SEP #$20
.3a2328	48		pha		            PHA
.3a2329	a9 00		lda #$00	            LDA #`GLOBAL_VARS
.3a232b	48		pha		            PHA
.3a232c	ab		plb		            PLB
.3a232d	68		pla		            PLA
.3a232e	28		plp		            PLP
.3a232f	6c 2f 08	jmp ($082f)	            JMP (JMP16PTR)      ; Annoying JMP to get around the fact we don't have an indirect JSR
.3a2332	a5 0c		lda $080c	is_interact LDA SCRATCH         ; Get the token type
.3a2334	c9 10		cmp #$10	            CMP #TOK_TY_CMD     ; Is it a command?
.3a2336	d0 a9		bne $3a22e1	            BNE error           ; If not, it's an error
.3a2338					ok_to_exec
.3a2338	a7 00		lda [$0800]	            LDA [BIP]           ; Get the original token again
.3a233a	20 84 0c	jsr $3a0c84	            JSR TOKEVAL
.3a233d	c2 20		rep #$20	            REP #$20
.3a233f	85 2f		sta $082f	            STA JMP16PTR        ; Store it in the jump pointer
.3a2341	20 8b 19	jsr $3a198b	            JSR INITEVALSP
.3a2344	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a2347	20 25 23	jsr $3a2325	            JSR STSTUB
.3a234a	ab		plb		done        PLB
.3a234b	2b		pld		            PLD
.3a234c	28		plp		            PLP
.3a234d	60		rts		            RTS
.3a234e					EXECCMD
.3a234e	08		php		            PHP
.3a234f	58		cli		            CLI
.3a2350	20 db 20	jsr $3a20db	            JSR SETINTERACT
.3a2353	20 00 1e	jsr $3a1e00	            JSR INITRETURN
.3a2356	e2 20		sep #$20	            SEP #$20
.3a2358	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.3a235b	c2 20		rep #$20	            REP #$20
.3a235d	a5 1a		lda $081a	            LDA CURLINE         ; Set the BASIC Instruction Pointer to the first byte of the line
.3a235f	85 00		sta $0800	            STA BIP
.3a2361	a5 1c		lda $081c	            LDA CURLINE+2
.3a2363	85 02		sta $0802	            STA BIP+2
.3a2365	4c 8c 23	jmp $3a238c	            JMP exec_loop
.3a2368	08		php		EXECLINE    PHP
.3a2369	c2 20		rep #$20	            REP #$20
.3a236b	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER            ; Set the current line number
.3a236e	b7 1a		lda [$081a],y	            LDA [CURLINE],Y
.3a2370	85 d7		sta $08d7	            STA LINENUM
.3a2372	e2 20		sep #$20	            SEP #$20
.3a2374	a5 dc		lda $08dc	            LDA EXECACTION              ; If the last EXEC action was RETURN
.3a2376	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; BIP has already been set, so...
.3a2378	f0 12		beq $3a238c	            BEQ exec_loop               ; Skip over setting the BIP to the beginning of the line
.3a237a	c2 20		rep #$20	            REP #$20
.3a237c	18		clc		            CLC                         ; Set the BASIC Instruction Pointer to the first byte of the line
.3a237d	a5 1a		lda $081a	            LDA CURLINE
.3a237f	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a2382	85 00		sta $0800	            STA BIP
.3a2384	e2 20		sep #$20	            SEP #$20
.3a2386	a5 1c		lda $081c	            LDA CURLINE+2
.3a2388	69 00		adc #$00	            ADC #0
.3a238a	85 02		sta $0802	            STA BIP+2
.3a238c					exec_loop
.3a238c	c2 20		rep #$20	            REP #$20
.3a238e	20 96 22	jsr $3a2296	            JSR EXECSTMT
.3a2391	e2 20		sep #$20	            SEP #$20
.3a2393	a5 dc		lda $08dc	            LDA EXECACTION
.3a2395	c9 03		cmp #$03	            CMP #EXEC_RETURN
.3a2397	f0 f3		beq $3a238c	            BEQ exec_loop
.3a2399	c9 00		cmp #$00	            CMP #EXEC_CONT              ; If it's not EXEC_CONT, exit to the caller
.3a239b	d0 31		bne $3a23ce	            BNE exec_done
.3a239d	e2 20		sep #$20	            SEP #$20
.3a239f	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a23a2	a7 00		lda [$0800]	            LDA [BIP]                   ; Get the current character in the line
.3a23a4	f0 28		beq $3a23ce	            BEQ exec_done               ; If it's NULL, we're done
.3a23a6	c9 3a		cmp #$3a	            CMP #':'                    ; If it's colon, we have more statements
.3a23a8	f0 1f		beq $3a23c9	            BEQ skip_loop               ; Skip over it and try to execute the next one
.3a23aa	08		php		            PHP
.3a23ab	c2 20		rep #$20	            REP #$20
.3a23ad	48		pha		            PHA
.3a23ae	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a23b1	5b		tcd		            TCD
.3a23b2	68		pla		            PLA
.3a23b3	28		plp		            PLP
.3a23b4	e2 20		sep #$20	            SEP #$20
.3a23b6	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a23b8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a23bc	c2 20		rep #$20	            REP #$20
.3a23be	29 ff 00	and #$00ff	            AND #$00FF
.3a23c1	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a23c4	e2 20		sep #$20	            SEP #$20
.3a23c6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a23c9					skip_loop
.3a23c9	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a23cc	80 be		bra $3a238c	            BRA exec_loop               ; And try to execute another statement
.3a23ce					exec_done
.3a23ce	28		plp		            PLP
.3a23cf	60		rts		            RTS
.3a23d0					EXECPROGRAM
.3a23d0	08		php		            PHP
.3a23d1	58		cli		            CLI
.3a23d2	e2 20		sep #$20	            SEP #$20
.3a23d4	a9 80		lda #$80	            LDA #ST_RUNNING
.3a23d6	85 d2		sta $08d2	            STA STATE
.3a23d8	9c 8a 0f	stz $0f8a	            STZ KEYFLAG                 ; Clear the key flag... interrupt handler will raise MSB
.3a23db	20 00 1e	jsr $3a1e00	            JSR INITRETURN
.3a23de	c2 30		rep #$30	            REP #$30
.3a23e0	64 31		stz $0831	            STZ GOSUBDEPTH              ; Clear the count of GOSUBs
.3a23e2	a0 02 00	ldy #$0002	exec_loop   LDY #LINE_NUMBER
.3a23e5	b7 1a		lda [$081a],y	            LDA [CURLINE],Y             ; Get the line number of the current line
.3a23e7	f0 28		beq $3a2411	            BEQ done                    ; If it's 0, we are finished running code (implicit END)
.3a23e9	20 68 23	jsr $3a2368	            JSR EXECLINE
.3a23ec	e2 20		sep #$20	            SEP #$20
.3a23ee	a5 dc		lda $08dc	            LDA EXECACTION              ; Check the EXECACTION from the last line
.3a23f0	c9 01		cmp #$01	            CMP #EXEC_STOP              ; Stop execution of the program?
.3a23f2	f0 1d		beq $3a2411	            BEQ done
.3a23f4	c9 02		cmp #$02	            CMP #EXEC_GOTO              ; Transfer execution to a new CURLINE that is already set
.3a23f6	f0 ea		beq $3a23e2	            BEQ exec_loop
.3a23f8	c9 03		cmp #$03	            CMP #EXEC_RETURN            ; Transfer execution to the CURLINE and BIP that is already set
.3a23fa	f0 e6		beq $3a23e2	            BEQ exec_loop
.3a23fc	c2 20		rep #$20	            REP #$20
.3a23fe	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.3a2401	18		clc		            CLC
.3a2402	a5 1a		lda $081a	            LDA CURLINE
.3a2404	77 1a		adc [$081a],y	            ADC [CURLINE],Y
.3a2406	85 1a		sta $081a	            STA CURLINE
.3a2408	a5 1c		lda $081c	            LDA CURLINE+2
.3a240a	69 00 00	adc #$0000	            ADC #0
.3a240d	85 1c		sta $081c	            STA CURLINE+2
.3a240f	80 d1		bra $3a23e2	            BRA exec_loop               ; And try to execute that line
.3a2411					done
.3a2411	e2 20		sep #$20	            SEP #$20
.3a2413	a9 00		lda #$00	            LDA #ST_INTERACT            ; Set interpreter state to RUNNING
.3a2415	85 d2		sta $08d2	            STA STATE
.3a2417	28		plp		            PLP
.3a2418	60		rts		            RTS
.3a2419					FINDLINE
.3a2419	08		php		            PHP
.3a241a	c2 30		rep #$30	            REP #$30
.3a241c	c2 20		rep #$20	            REP #$20
.3a241e	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT            ; INDEX points to the first line of the program
.3a2421	85 08		sta $0808	            STA INDEX
.3a2423	a9 36 00	lda #$0036	            LDA #`BASIC_BOT
.3a2426	85 0a		sta $080a	            STA INDEX+2
.3a2428	c2 20		rep #$20	            REP #$20
.3a242a	a0 02 00	ldy #$0002	check_nmbrs LDY #LINE_NUMBER            ; Get the number of the possible target line
.3a242d	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a242f	f0 31		beq $3a2462	            BEQ ret_false               ; If new line number is 0, we got to the
.3a2431	c5 23		cmp $0823	            CMP ARGUMENT1               ; Compare it to the target line number
.3a2433	f0 1e		beq $3a2453	            BEQ found
.3a2435	b0 2b		bcs $3a2462	            BGE ret_false               ; If the line number > target line number, the line is not present
.3a2437					next_line
.3a2437	c2 20		rep #$20	            REP #$20
.3a2439	a0 00 00	ldy #$0000	            LDY #LINE_LINK              ; INDEX := INDEX + [INDEX].LINK
.3a243c	18		clc		            CLC
.3a243d	a5 08		lda $0808	            LDA INDEX
.3a243f	77 08		adc [$0808],y	            ADC [INDEX],Y
.3a2441	85 0c		sta $080c	            STA SCRATCH
.3a2443	e2 20		sep #$20	            SEP #$20
.3a2445	a5 0a		lda $080a	            LDA INDEX+2
.3a2447	69 00		adc #$00	            ADC #0
.3a2449	85 0a		sta $080a	            STA INDEX+2
.3a244b	c2 20		rep #$20	            REP #$20
.3a244d	a5 0c		lda $080c	            LDA SCRATCH
.3a244f	85 08		sta $0808	            STA INDEX
.3a2451	80 d7		bra $3a242a	            BRA check_nmbrs             ; And go back to check the new line INDEX is pointing to
.3a2453					found
.3a2453	c2 20		rep #$20	            REP #$20
.3a2455	a5 08		lda $0808	            LDA INDEX
.3a2457	85 1a		sta $081a	            STA CURLINE
.3a2459	e2 20		sep #$20	            SEP #$20
.3a245b	a5 0a		lda $080a	            LDA INDEX+2
.3a245d	85 1c		sta $081c	            STA CURLINE+2
.3a245f	28		plp		ret_true    PLP                         ; Return true to indicate we've found the line
.3a2460	38		sec		            SEC
.3a2461	60		rts		            RTS
.3a2462	28		plp		ret_false   PLP
.3a2463	18		clc		            CLC
.3a2464	60		rts		            RTS
.3a2465					MVPROGDN
.3a2465	08		php		            PHP
.3a2466					mvd_loop
.3a2466	e2 20		sep #$20	            SEP #$20
.3a2468	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.3a246a	87 08		sta [$0808]	            STA [INDEX]
.3a246c	c2 20		rep #$20	            REP #$20
.3a246e	a5 0c		lda $080c	            LDA SCRATCH
.3a2470	c5 00		cmp $0800	            CMP BIP
.3a2472	d0 08		bne $3a247c	            BNE increment
.3a2474	e2 20		sep #$20	            SEP #$20
.3a2476	a5 0e		lda $080e	            LDA SCRATCH+2
.3a2478	c5 02		cmp $0802	            CMP BIP+2
.3a247a	f0 26		beq $3a24a2	            BEQ done            ; Yes: return
.3a247c					increment
.3a247c	c2 20		rep #$20	            REP #$20
.3a247e	18		clc		            CLC
.3a247f	a5 0c		lda $080c	            LDA SCRATCH
.3a2481	69 01 00	adc #$0001	            ADC #1
.3a2484	85 0c		sta $080c	            STA SCRATCH
.3a2486	e2 20		sep #$20	            SEP #$20
.3a2488	a5 0e		lda $080e	            LDA SCRATCH+2
.3a248a	69 00		adc #$00	            ADC #0
.3a248c	85 0e		sta $080e	            STA SCRATCH+2
.3a248e	c2 20		rep #$20	            REP #$20
.3a2490	18		clc		            CLC
.3a2491	a5 08		lda $0808	            LDA INDEX
.3a2493	69 01 00	adc #$0001	            ADC #1
.3a2496	85 08		sta $0808	            STA INDEX
.3a2498	e2 20		sep #$20	            SEP #$20
.3a249a	a5 0a		lda $080a	            LDA INDEX+2
.3a249c	69 00		adc #$00	            ADC #0
.3a249e	85 0a		sta $080a	            STA INDEX+2
.3a24a0	80 c4		bra $3a2466	            BRA mvd_loop        ; And try again
.3a24a2	28		plp		done        PLP
.3a24a3	60		rts		            RTS
.3a24a4					MVPROGUP
.3a24a4	08		php		            PHP
.3a24a5					mvu_loop
.3a24a5	e2 20		sep #$20	            SEP #$20
.3a24a7	a7 0c		lda [$080c]	            LDA [SCRATCH]       ; Move a byte
.3a24a9	87 08		sta [$0808]	            STA [INDEX]
.3a24ab	c2 20		rep #$20	            REP #$20
.3a24ad	a5 0c		lda $080c	            LDA SCRATCH
.3a24af	c5 00		cmp $0800	            CMP BIP
.3a24b1	d0 06		bne $3a24b9	            BNE decrement
.3a24b3	a5 0e		lda $080e	            LDA SCRATCH+2
.3a24b5	c5 02		cmp $0802	            CMP BIP+2
.3a24b7	f0 26		beq $3a24df	            BEQ done            ; Yes: return
.3a24b9					decrement
.3a24b9	c2 20		rep #$20	            REP #$20
.3a24bb	38		sec		            SEC
.3a24bc	a5 0c		lda $080c	            LDA SCRATCH
.3a24be	e9 01 00	sbc #$0001	            SBC #1
.3a24c1	85 0c		sta $080c	            STA SCRATCH
.3a24c3	e2 20		sep #$20	            SEP #$20
.3a24c5	a5 0e		lda $080e	            LDA SCRATCH+2
.3a24c7	e9 00		sbc #$00	            SBC #0
.3a24c9	85 0e		sta $080e	            STA SCRATCH+2
.3a24cb	c2 20		rep #$20	            REP #$20
.3a24cd	38		sec		            SEC
.3a24ce	a5 08		lda $0808	            LDA INDEX
.3a24d0	e9 01 00	sbc #$0001	            SBC #1
.3a24d3	85 08		sta $0808	            STA INDEX
.3a24d5	e2 20		sep #$20	            SEP #$20
.3a24d7	a5 0a		lda $080a	            LDA INDEX+2
.3a24d9	e9 00		sbc #$00	            SBC #0
.3a24db	85 0a		sta $080a	            STA INDEX+2
.3a24dd	80 c6		bra $3a24a5	            BRA mvu_loop        ; And try again
.3a24df	28		plp		done        PLP
.3a24e0	60		rts		            RTS
.3a24e1					DELLINE
.3a24e1	08		php		            PHP
.3a24e2	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; SCRATCH := INDEX + [INDEX].LINK (address of the following line)
.3a24e5	c2 20		rep #$20	            REP #$20
.3a24e7	18		clc		            CLC
.3a24e8	a5 08		lda $0808	            LDA INDEX
.3a24ea	77 08		adc [$0808],y	            ADC [INDEX],Y
.3a24ec	85 0c		sta $080c	            STA SCRATCH
.3a24ee	e2 20		sep #$20	            SEP #$20
.3a24f0	a5 0a		lda $080a	            LDA INDEX+2
.3a24f2	69 00		adc #$00	            ADC #0
.3a24f4	85 0e		sta $080e	            STA SCRATCH+2
.3a24f6	c2 20		rep #$20	            REP #$20
.3a24f8	18		clc		            CLC
.3a24f9	a5 d9		lda $08d9	            LDA LASTLINE
.3a24fb	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a24fe	85 00		sta $0800	            STA BIP
.3a2500	e2 20		sep #$20	            SEP #$20
.3a2502	a5 db		lda $08db	            LDA LASTLINE+2
.3a2504	69 00		adc #$00	            ADC #0
.3a2506	85 02		sta $0802	            STA BIP+2
.3a2508	a0 00 00	ldy #$0000	            LDY #LINE_LINK          ; LASTLINE := LASTLINE - [INDEX].LINK
.3a250b	c2 20		rep #$20	            REP #$20
.3a250d	38		sec		            SEC
.3a250e	a5 d9		lda $08d9	            LDA LASTLINE
.3a2510	f7 08		sbc [$0808],y	            SBC [INDEX],Y
.3a2512	85 d9		sta $08d9	            STA LASTLINE
.3a2514	e2 20		sep #$20	            SEP #$20
.3a2516	a5 db		lda $08db	            LDA LASTLINE+2
.3a2518	e9 00		sbc #$00	            SBC #0
.3a251a	85 db		sta $08db	            STA LASTLINE+2
.3a251c	20 65 24	jsr $3a2465	            JSR MVPROGDN
.3a251f					done
.3a251f	20 c1 44	jsr $3a44c1	            JSR S_CLR
.3a2522	28		plp		            PLP
.3a2523	60		rts		            RTS
.3a2524					APPLINE
.3a2524	08		php		            PHP
.3a2525	08		php		            PHP
.3a2526	c2 20		rep #$20	            REP #$20
.3a2528	48		pha		            PHA
.3a2529	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a252c	5b		tcd		            TCD
.3a252d	68		pla		            PLA
.3a252e	28		plp		            PLP
.3a252f	c2 30		rep #$30	            REP #$30
.3a2531	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER    ; Set the line number of the new line
.3a2534	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.3a2536	18		clc		            CLC                 ; Point INDEX to the position to store the tokens
.3a2537	a5 d9		lda $08d9	            LDA LASTLINE
.3a2539	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a253c	85 08		sta $0808	            STA INDEX
.3a253e	e2 20		sep #$20	            SEP #$20
.3a2540	a5 db		lda $08db	            LDA LASTLINE+2
.3a2542	69 00		adc #$00	            ADC #0
.3a2544	85 0a		sta $080a	            STA INDEX+2
.3a2546	e2 20		sep #$20	            SEP #$20
.3a2548	a0 00 00	ldy #$0000	            LDY #0
.3a254b	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Copy the tokenized line to its place in the code
.3a254d	97 08		sta [$0808],y	            STA [INDEX],Y
.3a254f	f0 03		beq $3a2554	            BEQ copy_done
.3a2551	c8		iny		            INY
.3a2552	80 f7		bra $3a254b	            BRA copy_loop
.3a2554					copy_done
.3a2554	c2 20		rep #$20	            REP #$20
.3a2556	98		tya		            TYA
.3a2557	18		clc		            CLC
.3a2558	69 05 00	adc #$0005	            ADC #LINE_TOKENS+1
.3a255b	85 0c		sta $080c	            STA SCRATCH
.3a255d	c2 20		rep #$20	            REP #$20
.3a255f	a0 00 00	ldy #$0000	            LDY #LINE_LINK      ; Set link to the offset to the next line
.3a2562	a5 0c		lda $080c	            LDA SCRATCH
.3a2564	97 d9		sta [$08d9],y	            STA [LASTLINE],Y
.3a2566	c2 20		rep #$20	            REP #$20
.3a2568	18		clc		            CLC
.3a2569	a5 d9		lda $08d9	            LDA LASTLINE
.3a256b	65 0c		adc $080c	            ADC SCRATCH
.3a256d	85 0c		sta $080c	            STA SCRATCH
.3a256f	e2 20		sep #$20	            SEP #$20
.3a2571	a5 db		lda $08db	            LDA LASTLINE+2
.3a2573	69 00		adc #$00	            ADC #0
.3a2575	85 db		sta $08db	            STA LASTLINE+2
.3a2577	c2 20		rep #$20	            REP #$20
.3a2579	a5 0c		lda $080c	            LDA SCRATCH
.3a257b	85 d9		sta $08d9	            STA LASTLINE
.3a257d	c2 20		rep #$20	            REP #$20
.3a257f	a0 00 00	ldy #$0000	            LDY #0
.3a2582	a9 00 00	lda #$0000	            LDA #0
.3a2585	97 d9		sta [$08d9],y	blank_loop  STA [LASTLINE],Y    ; Set the "line" after the last line to nulls
.3a2587	c8		iny		            INY
.3a2588	c0 05 00	cpy #$0005	            CPY #LINE_TOKENS+1
.3a258b	d0 f8		bne $3a2585	            BNE blank_loop
.3a258d	20 c1 44	jsr $3a44c1	            JSR S_CLR
.3a2590	28		plp		            PLP
.3a2591	60		rts		            RTS
.3a2592					FINDINSPT
.3a2592	0b		phd		            PHD
.3a2593	08		php		            PHP
.3a2594	08		php		            PHP
.3a2595	c2 20		rep #$20	            REP #$20
.3a2597	48		pha		            PHA
.3a2598	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a259b	5b		tcd		            TCD
.3a259c	68		pla		            PLA
.3a259d	28		plp		            PLP
.3a259e	c2 30		rep #$30	            REP #$30
.3a25a0	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.3a25a3	85 08		sta $0808	            STA INDEX
.3a25a5	a9 36 00	lda #$0036	            LDA #`BASIC_BOT
.3a25a8	85 0a		sta $080a	            STA INDEX+2
.3a25aa	a0 02 00	ldy #$0002	loop        LDY #LINE_NUMBER
.3a25ad	b7 08		lda [$0808],y	            LDA [INDEX],Y
.3a25af	f0 1d		beq $3a25ce	            BEQ found_end           ; Got to end without finding it
.3a25b1	c5 d7		cmp $08d7	            CMP LINENUM
.3a25b3	f0 25		beq $3a25da	            BEQ found_line          ; LINENUM = [INDEX].LINE_NUMBER: return we found the exact line
.3a25b5	b0 1d		bcs $3a25d4	            BGE found_spot          ; LINENUM > [INDEX].LINE_NUMBER: return we found spot to insert
.3a25b7	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.3a25ba	18		clc		            CLC                     ; Move INDEX to the next line
.3a25bb	a5 08		lda $0808	            LDA INDEX
.3a25bd	77 08		adc [$0808],y	            ADC [INDEX],Y
.3a25bf	85 0c		sta $080c	            STA SCRATCH
.3a25c1	a5 0a		lda $080a	            LDA INDEX+2
.3a25c3	69 00 00	adc #$0000	            ADC #0
.3a25c6	85 0a		sta $080a	            STA INDEX+2
.3a25c8	a5 0c		lda $080c	            LDA SCRATCH
.3a25ca	85 08		sta $0808	            STA INDEX
.3a25cc	80 dc		bra $3a25aa	            BRA loop                ; And check that line
.3a25ce	a9 00 00	lda #$0000	found_end   LDA #0                  ; Return that we reached the end of the program
.3a25d1	28		plp		            PLP
.3a25d2	2b		pld		            PLD
.3a25d3	60		rts		            RTS
.3a25d4	a9 01 00	lda #$0001	found_spot  LDA #1                  ; Return that we the found the spot to insert the line
.3a25d7	28		plp		            PLP                     ; But that it wasn't already there
.3a25d8	2b		pld		            PLD
.3a25d9	60		rts		            RTS
.3a25da	a9 02 00	lda #$0002	found_line  LDA #2                  ; Return that we found the line
.3a25dd	28		plp		            PLP
.3a25de	2b		pld		            PLD
.3a25df	60		rts		            RTS
.3a25e0					INSLINE
.3a25e0	08		php		            PHP
.3a25e1	c2 30		rep #$30	            REP #$30
.3a25e3	a9 05 00	lda #$0005	            LDA #LINE_TOKENS+1  ; Set SCRATCH2 to the size of the line header with the end-of-line
.3a25e6	85 10		sta $0810	            STA SCRATCH2
.3a25e8	a0 00 00	ldy #$0000	            LDY #0
.3a25eb					count_loop
.3a25eb	e2 20		sep #$20	            SEP #$20
.3a25ed	b7 1a		lda [$081a],y	            LDA [CURLINE],Y     ; Get the byte of the line
.3a25ef	f0 07		beq $3a25f8	            BEQ shift_prog      ; If it's end-of-line, SCRATCH2 is the length
.3a25f1	c2 20		rep #$20	            REP #$20
.3a25f3	e6 10		inc $0810	            INC SCRATCH2
.3a25f5	c8		iny		            INY
.3a25f6	80 f3		bra $3a25eb	            BRA count_loop      ; Count and continue
.3a25f8					shift_prog
.3a25f8	c2 20		rep #$20	            REP #$20
.3a25fa	a5 08		lda $0808	            LDA INDEX           ; BIP = the address of the first byte for the new line
.3a25fc	85 00		sta $0800	            STA BIP
.3a25fe	a5 0a		lda $080a	            LDA INDEX+2
.3a2600	85 02		sta $0802	            STA BIP+2
.3a2602	18		clc		            CLC                 ; SCRATCH = address of highest byte to copy
.3a2603	a5 d9		lda $08d9	            LDA LASTLINE
.3a2605	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a2608	85 0c		sta $080c	            STA SCRATCH
.3a260a	a5 db		lda $08db	            LDA LASTLINE+2
.3a260c	69 00 00	adc #$0000	            ADC #0
.3a260f	85 0e		sta $080e	            STA SCRATCH+2
.3a2611	18		clc		            CLC                 ; Adjust LASTLINE to its new position after the insert
.3a2612	a5 d9		lda $08d9	            LDA LASTLINE
.3a2614	65 10		adc $0810	            ADC SCRATCH2
.3a2616	85 d9		sta $08d9	            STA LASTLINE
.3a2618	a5 db		lda $08db	            LDA LASTLINE+2
.3a261a	69 00 00	adc #$0000	            ADC #0
.3a261d	85 db		sta $08db	            STA LASTLINE+2
.3a261f	18		clc		            CLC                 ; INDEX = address of the highest location to copy into
.3a2620	a5 d9		lda $08d9	            LDA LASTLINE
.3a2622	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a2625	85 08		sta $0808	            STA INDEX
.3a2627	a5 db		lda $08db	            LDA LASTLINE+2
.3a2629	69 00 00	adc #$0000	            ADC #0
.3a262c	85 0a		sta $080a	            STA INDEX+2
.3a262e	20 a4 24	jsr $3a24a4	            JSR MVPROGUP
.3a2631	c2 20		rep #$20	            REP #$20
.3a2633	a5 10		lda $0810	            LDA SCRATCH2
.3a2635	a0 00 00	ldy #$0000	            LDY #LINE_LINK
.3a2638	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINK_LINK = length of the new line
.3a263a	a5 d7		lda $08d7	            LDA LINENUM
.3a263c	a0 02 00	ldy #$0002	            LDY #LINE_NUMBER
.3a263f	97 00		sta [$0800],y	            STA [BIP],Y         ; [BIP].LINE_NUMBER = number of the new line
.3a2641	18		clc		            CLC                 ; Point BIP to the first byte of the new line
.3a2642	a5 00		lda $0800	            LDA BIP
.3a2644	69 04 00	adc #$0004	            ADC #LINE_TOKENS
.3a2647	85 00		sta $0800	            STA BIP
.3a2649	a5 02		lda $0802	            LDA BIP+2
.3a264b	69 00 00	adc #$0000	            ADC #0
.3a264e	85 02		sta $0802	            STA BIP+2
.3a2650	a0 00 00	ldy #$0000	            LDY #0
.3a2653	e2 20		sep #$20	            SEP #$20
.3a2655	b7 1a		lda [$081a],y	copy_loop   LDA [CURLINE],Y     ; Get the byte of the tokenized line
.3a2657	97 00		sta [$0800],y	            STA [BIP],Y         ; Copy it to its correct location in the program
.3a2659	f0 03		beq $3a265e	            BEQ done            ; If it was end-of-line byte, we're done
.3a265b	c8		iny		            INY
.3a265c	80 f7		bra $3a2655	            BRA copy_loop       ; Otherwise, continue with the next
.3a265e					done
.3a265e	20 c1 44	jsr $3a44c1	            JSR S_CLR
.3a2661	28		plp		            PLP
.3a2662	60		rts		            RTS
.3a2663					ADDLINE
.3a2663	08		php		            PHP
.3a2664	c2 30		rep #$30	            REP #$30
.3a2666	85 d7		sta $08d7	            STA LINENUM
.3a2668	20 92 25	jsr $3a2592	            JSR FINDINSPT
.3a266b	c9 00 00	cmp #$0000	            CMP #0
.3a266e	f0 2c		beq $3a269c	            BEQ do_append       ; End-of-program found, add the line to the end
.3a2670	c9 01 00	cmp #$0001	            CMP #1
.3a2673	f0 22		beq $3a2697	            BEQ do_insert       ; Spot was found: insertion required
.3a2675	c2 20		rep #$20	            REP #$20
.3a2677	a5 08		lda $0808	            LDA INDEX
.3a2679	48		pha		            PHA
.3a267a	a5 0a		lda $080a	            LDA INDEX+2
.3a267c	48		pha		            PHA
.3a267d	20 e1 24	jsr $3a24e1	            JSR DELLINE
.3a2680	68		pla		            PLA
.3a2681	85 0a		sta $080a	            STA INDEX+2
.3a2683	68		pla		            PLA
.3a2684	85 08		sta $0808	            STA INDEX
.3a2686	a5 1a		lda $081a	            LDA CURLINE         ; Check to see if there is any non-whitespace on the line
.3a2688	85 00		sta $0800	            STA BIP
.3a268a	a5 1c		lda $081c	            LDA CURLINE+2
.3a268c	85 02		sta $0802	            STA BIP+2
.3a268e	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a2691	e2 20		sep #$20	            SEP #$20
.3a2693	a7 00		lda [$0800]	            LDA [BIP]
.3a2695	f0 0a		beq $3a26a1	            BEQ done            ; If not, we're done
.3a2697					do_insert
.3a2697	20 e0 25	jsr $3a25e0	            JSR INSLINE
.3a269a	80 05		bra $3a26a1	            BRA done
.3a269c	a5 d7		lda $08d7	do_append   LDA LINENUM
.3a269e	20 24 25	jsr $3a2524	            JSR APPLINE
.3a26a1	28		plp		done        PLP
.3a26a2	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\repl.s

="#"					CHAR_DIR = '#'
="|"					CHAR_BRUN = '|'
.3a26a3					EXPANDLINE
.3a26a3	0b		phd		                PHD
.3a26a4	08		php		                PHP
.3a26a5	08		php		            PHP
.3a26a6	c2 20		rep #$20	            REP #$20
.3a26a8	48		pha		            PHA
.3a26a9	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a26ac	5b		tcd		            TCD
.3a26ad	68		pla		            PLA
.3a26ae	28		plp		            PLP
.3a26af	e2 20		sep #$20	            SEP #$20
.3a26b1	c2 10		rep #$10	            REP #$10
.3a26b3	a2 00 00	ldx #$0000	                LDX #0
.3a26b6	bd 00 4f	lda $4f00,x	count_loop      LDA INPUTBUF,X              ; Count the number of characters in the input
.3a26b9	f0 03		beq $3a26be	                BEQ save_size
.3a26bb	e8		inx		                INX
.3a26bc	80 f8		bra $3a26b6	                BRA count_loop
.3a26be	86 0c		stx $080c	save_size       STX SCRATCH                 ; Save the size in SCRATCH
.3a26c0	c2 30		rep #$30	            REP #$30
.3a26c2	8a		txa		                TXA
.3a26c3	c9 02 00	cmp #$0002	                CMP #2                      ; Are there arguments?
.3a26c6	90 12		bcc $3a26da	                BLT start_copy              ; No: just replace the whole string
.3a26c8	3a		dec a		                DEC A
.3a26c9	18		clc		                CLC
.3a26ca	69 00 4f	adc #$4f00	                ADC #<>INPUTBUF
.3a26cd	aa		tax		                TAX                         ; X <-- INPUTBUF + len(INPUTBUF) - 1
.3a26ce	18		clc		                CLC                         ; Y <-- INPUTBUF + len(INPUTBUF) - 1 + len(substitution)
.3a26cf	65 8f		adc $088f	                ADC MCOUNT
.3a26d1	a8		tay		                TAY
.3a26d2	a5 0c		lda $080c	                LDA SCRATCH
.3a26d4	3a		dec a		                DEC A
.3a26d5	8b		phb		                PHB
.3a26d6	44 00 00	mvp #$00,#$00	                MVP #`INPUTBUF,#`INPUTBUF   ; Make room for the substitition
.3a26d9	ab		plb		                PLB
.3a26da					start_copy
.3a26da	c2 20		rep #$20	            REP #$20
.3a26dc	a6 55		ldx $0855	                LDX MARG1                   ; Source is data to copy
.3a26de	a0 00 4f	ldy #$4f00	                LDY #<>INPUTBUF             ; Destination is input buffer
.3a26e1	a5 8f		lda $088f	                LDA MCOUNT                  ; Number of bytes to copy
.3a26e3	8b		phb		                PHB
.3a26e4	54 00 3a	mvn #$3a,#$00	                MVN #`EXPANDLINE,#`INPUTBUF ; Copy the data
.3a26e7	ab		plb		                PLB
.3a26e8	e2 20		sep #$20	            SEP #$20
.3a26ea	a5 0c		lda $080c	                LDA SCRATCH                 ; Check again to see if we need quotes
.3a26ec	c9 02		cmp #$02	                CMP #2
.3a26ee	90 18		bcc $3a2708	                BLT done
.3a26f0	a6 8f		ldx $088f	                LDX MCOUNT                  ; If so, add a quote mark here
.3a26f2	a9 22		lda #$22	                LDA #CHAR_DQUOTE
.3a26f4	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a26f7	e8		inx		skip_to_end     INX                         ; Move to the end of the input string
.3a26f8	bd 00 4f	lda $4f00,x	                LDA INPUTBUF,X
.3a26fb	d0 fa		bne $3a26f7	                BNE skip_to_end
.3a26fd	a9 22		lda #$22	                LDA #CHAR_DQUOTE            ; Add the quote to the end of the string
.3a26ff	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a2702	a9 00		lda #$00	                LDA #0                      ; And terminate with a NULL
.3a2704	e8		inx		                INX
.3a2705	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a2708	28		plp		done            PLP
.3a2709	2b		pld		                PLD
.3a270a	60		rts		            RTS
.3a270b					PREPROCESS
.3a270b	da		phx		                PHX
.3a270c	5a		phy		                PHY
.3a270d	8b		phb		                PHB
.3a270e	0b		phd		                PHD
.3a270f	08		php		                PHP
.3a2710	08		php		            PHP
.3a2711	c2 20		rep #$20	            REP #$20
.3a2713	48		pha		            PHA
.3a2714	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a2717	5b		tcd		            TCD
.3a2718	68		pla		            PLA
.3a2719	28		plp		            PLP
.3a271a	e2 20		sep #$20	            SEP #$20
.3a271c	c2 10		rep #$10	            REP #$10
.3a271e	ad 00 4f	lda $4f00	                LDA INPUTBUF            ; Check the first character
.3a2721	c9 23		cmp #$23	                CMP #CHAR_DIR           ; Is it the DIR character?
.3a2723	f0 0a		beq $3a272f	                BEQ expand_dir          ; Yes: expand the DIR command into place
.3a2725	c9 7c		cmp #$7c	                CMP #CHAR_BRUN          ; Is it the BRUN character?
.3a2727	f0 17		beq $3a2740	                BEQ expand_brun         ; Yes: expand the BRUN command into place
.3a2729	28		plp		done            PLP
.3a272a	2b		pld		                PLD
.3a272b	ab		plb		                PLB
.3a272c	7a		ply		                PLY
.3a272d	fa		plx		                PLX
.3a272e	60		rts		            RTS
.3a272f					expand_dir
.3a272f	c2 20		rep #$20	            REP #$20
.3a2731	a9 03 00	lda #$0003	                LDA #3                  ; Set size of substitution value
.3a2734	85 8f		sta $088f	                STA MCOUNT
.3a2736	a9 51 27	lda #$2751	                LDA #<>dir_text         ; Set pointer to substitution value
.3a2739	85 55		sta $0855	                STA MARG1
.3a273b	20 a3 26	jsr $3a26a3	            JSR EXPANDLINE
.3a273e	80 e9		bra $3a2729	                BRA done
.3a2740					expand_brun
.3a2740	c2 20		rep #$20	            REP #$20
.3a2742	a9 04 00	lda #$0004	                LDA #4                  ; Set size of substitution value
.3a2745	85 8f		sta $088f	                STA MCOUNT
.3a2747	a9 55 27	lda #$2755	                LDA #<>brun_text        ; Set pointer to substitution value
.3a274a	85 55		sta $0855	                STA MARG1
.3a274c	20 a3 26	jsr $3a26a3	            JSR EXPANDLINE
.3a274f	80 d8		bra $3a2729	                BRA done
>3a2751	44 49 52 00			dir_text        .null "DIR"             ; Expansion of the DIR character
>3a2755	42 52 55 4e 00			brun_text       .null "BRUN"            ; Expansion of the BRUN character
.3a275a					PRREADY
.3a275a	8b		phb		                PHB
.3a275b	08		php		                PHP
.3a275c	20 3d 02	jsr $3a023d	            JSR ENSURETEXT
.3a275f	08		php		            PHP
.3a2760	e2 20		sep #$20	            SEP #$20
.3a2762	48		pha		            PHA
.3a2763	a9 3a		lda #$3a	            LDA #`MPROMPT
.3a2765	48		pha		            PHA
.3a2766	ab		plb		            PLB
.3a2767	68		pla		            PLA
.3a2768	28		plp		            PLP
.3a2769	a2 6f d2	ldx #$d26f	                LDX #<>MPROMPT
.3a276c	20 64 04	jsr $3a0464	            JSR PRINTS
.3a276f	28		plp		                PLP
.3a2770	ab		plb		                PLB
.3a2771	60		rts		            RTS
.3a2772					IREADLINE
.3a2772	08		php		                PHP
.3a2773	e2 30		sep #$30	            SEP #$30
.3a2775	a9 01		lda #$01	                LDA #1
.3a2777	20 1c 00	jsr $3a001c	            JSR SHOWCURSOR
.3a277a					read_loop
.3a277a	20 db 00	jsr $3a00db	            JSR GETKEYE
.3a277d	c9 00		cmp #$00	                CMP #0
.3a277f	f0 f9		beq $3a277a	                BEQ read_loop
.3a2781	c9 0d		cmp #$0d	                CMP #CHAR_CR
.3a2783	f0 02		beq $3a2787	                BEQ done
.3a2785	80 f3		bra $3a277a	                BRA read_loop
.3a2787	28		plp		done            PLP
.3a2788	60		rts		            RTS
.3a2789					PROCESS
.3a2789	0b		phd		                PHD
.3a278a	08		php		                PHP
.3a278b	08		php		            PHP
.3a278c	c2 20		rep #$20	            REP #$20
.3a278e	48		pha		            PHA
.3a278f	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a2792	5b		tcd		            TCD
.3a2793	68		pla		            PLA
.3a2794	28		plp		            PLP
.3a2795	c2 30		rep #$30	            REP #$30
.3a2797	64 d7		stz $08d7	                STZ LINENUM
.3a2799	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF         ; Attempt to tokenize the line that was read
.3a279c	85 1a		sta $081a	                STA CURLINE
.3a279e	a9 00 00	lda #$0000	                LDA #`CURLINE
.3a27a1	85 1c		sta $081c	                STA CURLINE+2
.3a27a3	20 9c 09	jsr $3a099c	            JSR TOKENIZE
.3a27a6	c2 20		rep #$20	            REP #$20
.3a27a8	a5 d7		lda $08d7	                LDA LINENUM             ; Did we get a line number?
.3a27aa	d0 05		bne $3a27b1	                BNE update_line         ; Yes: attempt to add it to the program
.3a27ac	20 4e 23	jsr $3a234e	            JSR EXECCMD
.3a27af	80 07		bra $3a27b8	                BRA done
.3a27b1					update_line
.3a27b1	20 63 26	jsr $3a2663	            JSR ADDLINE
.3a27b4	28		plp		no_prompt       PLP
.3a27b5	2b		pld		                PLD
.3a27b6	38		sec		                SEC
.3a27b7	60		rts		            RTS
.3a27b8	28		plp		done            PLP
.3a27b9	2b		pld		                PLD
.3a27ba	18		clc		                CLC
.3a27bb	60		rts		            RTS
.3a27bc					INTERACT
.3a27bc	c2 30		rep #$30	            REP #$30
.3a27be	a2 ff fe	ldx #$feff	                LDX #<>STACK_END
.3a27c1	9a		txs		                TXS
.3a27c2					ready_loop
.3a27c2	20 5a 27	jsr $3a275a	            JSR PRREADY
.3a27c5					no_ready_loop
.3a27c5	20 08 00	jsr $3a0008	            JSR READLINE
.3a27c8	20 0c 00	jsr $3a000c	            JSR SCRCOPYLINE
.3a27cb	22 3c 11 00	jsl $00113c	                JSL FK_TESTBREAK    ; Make sure the BREAK bit is cleared.
.3a27cf	a9 00 00	lda #$0000	                LDA #0              ; Hide the cursor
.3a27d2	20 1c 00	jsr $3a001c	            JSR SHOWCURSOR
.3a27d5	20 0b 27	jsr $3a270b	            JSR PREPROCESS
.3a27d8	20 89 27	jsr $3a2789	            JSR PROCESS
.3a27db	b0 e8		bcs $3a27c5	                BCS no_ready_loop
.3a27dd	80 e3		bra $3a27c2	                BRA ready_loop
>3ad26f	0d 52 45 41 44 59 0d 00		MPROMPT         .null 13,"READY",13

;******  Return to file: src\basic816.s


;******  Processing file: src\operators.s

.3a27df					OP_PLUS
.3a27df	08		php		            PHP
.3a27e0	e2 20		sep #$20	            SEP #$20
.3a27e2	20 a3 08	jsr $3a08a3	            JSR ASS_ARGS_NUMSTR
.3a27e5	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a27e7	f0 2c		beq $3a2815	            BEQ is_integer
.3a27e9	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a27eb	f0 2d		beq $3a281a	            BEQ is_float
.3a27ed	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a27ef	f0 1f		beq $3a2810	            BEQ is_string
.3a27f1					type_error
.3a27f1	08		php		            PHP
.3a27f2	c2 20		rep #$20	            REP #$20
.3a27f4	48		pha		            PHA
.3a27f5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a27f8	5b		tcd		            TCD
.3a27f9	68		pla		            PLA
.3a27fa	28		plp		            PLP
.3a27fb	e2 20		sep #$20	            SEP #$20
.3a27fd	a9 04		lda #$04	            LDA #ERR_TYPE
.3a27ff	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2803	c2 20		rep #$20	            REP #$20
.3a2805	29 ff 00	and #$00ff	            AND #$00FF
.3a2808	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a280b	e2 20		sep #$20	            SEP #$20
.3a280d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2810					is_string
.3a2810	20 51 16	jsr $3a1651	            JSR STRCONCAT
.3a2813	80 08		bra $3a281d	            BRA done
.3a2815					is_integer
.3a2815	20 6e 54	jsr $3a546e	            JSR OP_INT_ADD
.3a2818	80 03		bra $3a281d	            BRA done
.3a281a					is_float
.3a281a	20 dd 56	jsr $3a56dd	            JSR OP_FP_ADD
.3a281d	28		plp		done        PLP
.3a281e	60		rts		            RTS
.3a281f					OP_MINUS
.3a281f	08		php		            PHP
.3a2820	e2 20		sep #$20	            SEP #$20
.3a2822	20 55 08	jsr $3a0855	            JSR ASS_ARGS_NUM
.3a2825	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a2827	f0 23		beq $3a284c	            BEQ is_integer
.3a2829	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a282b	f0 24		beq $3a2851	            BEQ is_float
.3a282d					type_error
.3a282d	08		php		            PHP
.3a282e	c2 20		rep #$20	            REP #$20
.3a2830	48		pha		            PHA
.3a2831	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2834	5b		tcd		            TCD
.3a2835	68		pla		            PLA
.3a2836	28		plp		            PLP
.3a2837	e2 20		sep #$20	            SEP #$20
.3a2839	a9 04		lda #$04	            LDA #ERR_TYPE
.3a283b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a283f	c2 20		rep #$20	            REP #$20
.3a2841	29 ff 00	and #$00ff	            AND #$00FF
.3a2844	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a2847	e2 20		sep #$20	            SEP #$20
.3a2849	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a284c					is_integer
.3a284c	20 80 54	jsr $3a5480	            JSR OP_INT_SUB
.3a284f	80 03		bra $3a2854	            BRA done
.3a2851					is_float
.3a2851	20 d2 56	jsr $3a56d2	            JSR OP_FP_SUB
.3a2854	28		plp		done        PLP
.3a2855	60		rts		            RTS
.3a2856					OP_MULTIPLY
.3a2856	08		php		            PHP
.3a2857	e2 20		sep #$20	            SEP #$20
.3a2859	20 55 08	jsr $3a0855	            JSR ASS_ARGS_NUM
.3a285c	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a285e	f0 23		beq $3a2883	            BEQ is_integer
.3a2860	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a2862	f0 24		beq $3a2888	            BEQ is_float
.3a2864					type_error
.3a2864	08		php		            PHP
.3a2865	c2 20		rep #$20	            REP #$20
.3a2867	48		pha		            PHA
.3a2868	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a286b	5b		tcd		            TCD
.3a286c	68		pla		            PLA
.3a286d	28		plp		            PLP
.3a286e	e2 20		sep #$20	            SEP #$20
.3a2870	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2872	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2876	c2 20		rep #$20	            REP #$20
.3a2878	29 ff 00	and #$00ff	            AND #$00FF
.3a287b	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a287e	e2 20		sep #$20	            SEP #$20
.3a2880	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2883					is_integer
.3a2883	20 92 54	jsr $3a5492	            JSR OP_INT_MUL
.3a2886	80 03		bra $3a288b	            BRA done
.3a2888					is_float
.3a2888	20 73 57	jsr $3a5773	            JSR OP_FP_MUL
.3a288b	28		plp		done        PLP
.3a288c	60		rts		            RTS
.3a288d					OP_DIVIDE
.3a288d	20 bf 07	jsr $3a07bf	            JSR ASS_ARG1_FLOAT
.3a2890	20 f0 07	jsr $3a07f0	            JSR ASS_ARG2_FLOAT
.3a2893	20 28 57	jsr $3a5728	            JSR OP_FP_DIV
.3a2896	60		rts		            RTS
.3a2897					OP_MOD
.3a2897	a5 23		lda $0823	            LDA ARGUMENT1
.3a2899	8f 1a 01 00	sta $00011a	            STA @lD1_OPERAND_B
.3a289d	a5 29		lda $0829	            LDA ARGUMENT2
.3a289f	8f 18 01 00	sta $000118	            STA @lD1_OPERAND_A
.3a28a3	af 1e 01 00	lda $00011e	            LDA @lD1_REMAINDER
.3a28a7	85 23		sta $0823	            STA ARGUMENT1
.3a28a9	60		rts		            RTS
.3a28aa					OP_POW
.3a28aa	08		php		            PHP
.3a28ab	c2 30		rep #$30	            REP #$30
.3a28ad	48		pha		            PHA
.3a28ae	20 bf 07	jsr $3a07bf	            JSR ASS_ARG1_FLOAT
.3a28b1	a5 2d		lda $082d	            LDA ARGTYPE2
.3a28b3	c9 00 00	cmp #$0000	            CMP #TYPE_INTEGER
.3a28b6	d0 0d		bne $3a28c5	            BNE flt_exp
.3a28b8	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a28ba	d0 09		bne $3a28c5	            BNE flt_exp
.3a28bc	da		phx		            PHX
.3a28bd	a6 29		ldx $0829	            LDX ARGUMENT2
.3a28bf	20 46 64	jsr $3a6446	            JSR Q_FP_POW_INT
.3a28c2	fa		plx		            PLX
.3a28c3	80 1c		bra $3a28e1	            BRA done
.3a28c5					flt_exp
.3a28c5	20 f0 07	jsr $3a07f0	            JSR ASS_ARG2_FLOAT
.3a28c8	c2 20		rep #$20	            REP #$20
.3a28ca	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a28cc	48		pha		            PHA
.3a28cd	a5 29		lda $0829	            LDA ARGUMENT2
.3a28cf	48		pha		            PHA
.3a28d0	20 d1 62	jsr $3a62d1	            JSR FP_LN
.3a28d3	c2 20		rep #$20	            REP #$20
.3a28d5	68		pla		            PLA
.3a28d6	85 29		sta $0829	            STA ARGUMENT2
.3a28d8	68		pla		            PLA
.3a28d9	85 2b		sta $082b	            STA ARGUMENT2+2
.3a28db	20 73 57	jsr $3a5773	            JSR OP_FP_MUL
.3a28de	20 b0 64	jsr $3a64b0	            JSR FP_EXP
.3a28e1	68		pla		done        PLA
.3a28e2	28		plp		            PLP
.3a28e3	60		rts		            RTS
.3a28e4					OP_AND
.3a28e4	08		php		            PHP
.3a28e5	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a28e8	20 82 06	jsr $3a0682	            JSR ASS_ARG2_INT
.3a28eb	c2 20		rep #$20	            REP #$20
.3a28ed	a5 23		lda $0823	            LDA ARGUMENT1
.3a28ef	25 29		and $0829	            AND ARGUMENT2
.3a28f1	85 23		sta $0823	            STA ARGUMENT1
.3a28f3	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a28f5	25 2b		and $082b	            AND ARGUMENT2+2
.3a28f7	85 25		sta $0825	            STA ARGUMENT1+2
.3a28f9	28		plp		            PLP
.3a28fa	60		rts		            RTS
.3a28fb					OP_OR
.3a28fb	08		php		            PHP
.3a28fc	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a28ff	20 82 06	jsr $3a0682	            JSR ASS_ARG2_INT
.3a2902	c2 20		rep #$20	            REP #$20
.3a2904	a5 23		lda $0823	            LDA ARGUMENT1
.3a2906	05 29		ora $0829	            ORA ARGUMENT2
.3a2908	85 23		sta $0823	            STA ARGUMENT1
.3a290a	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a290c	05 2b		ora $082b	            ORA ARGUMENT2+2
.3a290e	85 25		sta $0825	            STA ARGUMENT1+2
.3a2910	28		plp		done        PLP
.3a2911	60		rts		            RTS
.3a2912					OP_NOT
.3a2912	08		php		            PHP
.3a2913	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a2916	c2 20		rep #$20	            REP #$20
.3a2918	a5 23		lda $0823	            LDA ARGUMENT1
.3a291a	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a291d	85 23		sta $0823	            STA ARGUMENT1
.3a291f	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a2921	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a2924	85 25		sta $0825	            STA ARGUMENT1+2
.3a2926	28		plp		done        PLP
.3a2927	60		rts		            RTS
.3a2928					OP_LT
.3a2928	08		php		            PHP
.3a2929	e2 20		sep #$20	            SEP #$20
.3a292b	20 a3 08	jsr $3a08a3	            JSR ASS_ARGS_NUMSTR
.3a292e	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a2930	f0 2c		beq $3a295e	            BEQ is_integer
.3a2932	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a2934	f0 2d		beq $3a2963	            BEQ is_float
.3a2936	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a2938	f0 1f		beq $3a2959	            BEQ is_string
.3a293a					type_error
.3a293a	08		php		            PHP
.3a293b	c2 20		rep #$20	            REP #$20
.3a293d	48		pha		            PHA
.3a293e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2941	5b		tcd		            TCD
.3a2942	68		pla		            PLA
.3a2943	28		plp		            PLP
.3a2944	e2 20		sep #$20	            SEP #$20
.3a2946	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2948	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a294c	c2 20		rep #$20	            REP #$20
.3a294e	29 ff 00	and #$00ff	            AND #$00FF
.3a2951	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a2954	e2 20		sep #$20	            SEP #$20
.3a2956	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2959					is_string
.3a2959	20 d9 17	jsr $3a17d9	            JSR OP_STR_LT
.3a295c	80 08		bra $3a2966	            BRA done
.3a295e					is_integer
.3a295e	20 93 55	jsr $3a5593	            JSR OP_INT_LT
.3a2961	80 03		bra $3a2966	            BRA done
.3a2963					is_float
.3a2963	20 08 5d	jsr $3a5d08	            JSR OP_FP_LT
.3a2966	28		plp		done        PLP
.3a2967	60		rts		            RTS
.3a2968					OP_GT
.3a2968	08		php		            PHP
.3a2969	e2 20		sep #$20	            SEP #$20
.3a296b	20 a3 08	jsr $3a08a3	            JSR ASS_ARGS_NUMSTR
.3a296e	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a2970	f0 2c		beq $3a299e	            BEQ is_integer
.3a2972	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a2974	f0 2d		beq $3a29a3	            BEQ is_float
.3a2976	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a2978	f0 1f		beq $3a2999	            BEQ is_string
.3a297a					type_error
.3a297a	08		php		            PHP
.3a297b	c2 20		rep #$20	            REP #$20
.3a297d	48		pha		            PHA
.3a297e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2981	5b		tcd		            TCD
.3a2982	68		pla		            PLA
.3a2983	28		plp		            PLP
.3a2984	e2 20		sep #$20	            SEP #$20
.3a2986	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2988	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a298c	c2 20		rep #$20	            REP #$20
.3a298e	29 ff 00	and #$00ff	            AND #$00FF
.3a2991	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a2994	e2 20		sep #$20	            SEP #$20
.3a2996	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2999					is_string
.3a2999	20 f0 17	jsr $3a17f0	            JSR OP_STR_GT
.3a299c	80 08		bra $3a29a6	            BRA done
.3a299e					is_integer
.3a299e	20 b4 55	jsr $3a55b4	            JSR OP_INT_GT
.3a29a1	80 03		bra $3a29a6	            BRA done
.3a29a3					is_float
.3a29a3	20 1d 5d	jsr $3a5d1d	            JSR OP_FP_GT
.3a29a6	28		plp		done        PLP
.3a29a7	60		rts		            RTS
.3a29a8					OP_EQ
.3a29a8	08		php		            PHP
.3a29a9	e2 20		sep #$20	            SEP #$20
.3a29ab	20 a3 08	jsr $3a08a3	            JSR ASS_ARGS_NUMSTR
.3a29ae	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a29b0	f0 2c		beq $3a29de	            BEQ is_integer
.3a29b2	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a29b4	f0 2d		beq $3a29e3	            BEQ is_float
.3a29b6	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a29b8	f0 1f		beq $3a29d9	            BEQ is_string
.3a29ba					type_error
.3a29ba	08		php		            PHP
.3a29bb	c2 20		rep #$20	            REP #$20
.3a29bd	48		pha		            PHA
.3a29be	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a29c1	5b		tcd		            TCD
.3a29c2	68		pla		            PLA
.3a29c3	28		plp		            PLP
.3a29c4	e2 20		sep #$20	            SEP #$20
.3a29c6	a9 04		lda #$04	            LDA #ERR_TYPE
.3a29c8	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a29cc	c2 20		rep #$20	            REP #$20
.3a29ce	29 ff 00	and #$00ff	            AND #$00FF
.3a29d1	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a29d4	e2 20		sep #$20	            SEP #$20
.3a29d6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a29d9					is_string
.3a29d9	20 07 18	jsr $3a1807	            JSR OP_STR_EQ
.3a29dc	80 08		bra $3a29e6	            BRA done
.3a29de					is_integer
.3a29de	20 e1 55	jsr $3a55e1	            JSR OP_INT_EQ
.3a29e1	80 03		bra $3a29e6	            BRA done
.3a29e3					is_float
.3a29e3	20 32 5d	jsr $3a5d32	            JSR OP_FP_EQ
.3a29e6	28		plp		done        PLP
.3a29e7	60		rts		            RTS
.3a29e8					OP_NE
.3a29e8	08		php		            PHP
.3a29e9	e2 20		sep #$20	            SEP #$20
.3a29eb	20 a3 08	jsr $3a08a3	            JSR ASS_ARGS_NUMSTR
.3a29ee	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a29f0	f0 2c		beq $3a2a1e	            BEQ is_integer
.3a29f2	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a29f4	f0 2d		beq $3a2a23	            BEQ is_float
.3a29f6	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a29f8	f0 1f		beq $3a2a19	            BEQ is_string
.3a29fa					type_error
.3a29fa	08		php		            PHP
.3a29fb	c2 20		rep #$20	            REP #$20
.3a29fd	48		pha		            PHA
.3a29fe	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2a01	5b		tcd		            TCD
.3a2a02	68		pla		            PLA
.3a2a03	28		plp		            PLP
.3a2a04	e2 20		sep #$20	            SEP #$20
.3a2a06	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2a08	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2a0c	c2 20		rep #$20	            REP #$20
.3a2a0e	29 ff 00	and #$00ff	            AND #$00FF
.3a2a11	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a2a14	e2 20		sep #$20	            SEP #$20
.3a2a16	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2a19					is_string
.3a2a19	20 1e 18	jsr $3a181e	            JSR OP_STR_NE
.3a2a1c	80 08		bra $3a2a26	            BRA done
.3a2a1e					is_integer
.3a2a1e	20 ff 55	jsr $3a55ff	            JSR OP_INT_NE
.3a2a21	80 03		bra $3a2a26	            BRA done
.3a2a23					is_float
.3a2a23	20 71 5d	jsr $3a5d71	            JSR OP_FP_NE
.3a2a26	28		plp		done        PLP
.3a2a27	60		rts		            RTS
.3a2a28					OP_GTE
.3a2a28	08		php		            PHP
.3a2a29	e2 20		sep #$20	            SEP #$20
.3a2a2b	20 a3 08	jsr $3a08a3	            JSR ASS_ARGS_NUMSTR
.3a2a2e	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a2a30	f0 2c		beq $3a2a5e	            BEQ is_integer
.3a2a32	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a2a34	f0 2d		beq $3a2a63	            BEQ is_float
.3a2a36	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a2a38	f0 1f		beq $3a2a59	            BEQ is_string
.3a2a3a					type_error
.3a2a3a	08		php		            PHP
.3a2a3b	c2 20		rep #$20	            REP #$20
.3a2a3d	48		pha		            PHA
.3a2a3e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2a41	5b		tcd		            TCD
.3a2a42	68		pla		            PLA
.3a2a43	28		plp		            PLP
.3a2a44	e2 20		sep #$20	            SEP #$20
.3a2a46	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2a48	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2a4c	c2 20		rep #$20	            REP #$20
.3a2a4e	29 ff 00	and #$00ff	            AND #$00FF
.3a2a51	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a2a54	e2 20		sep #$20	            SEP #$20
.3a2a56	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2a59					is_string
.3a2a59	20 35 18	jsr $3a1835	            JSR OP_STR_GTE
.3a2a5c	80 08		bra $3a2a66	            BRA done
.3a2a5e					is_integer
.3a2a5e	20 1d 56	jsr $3a561d	            JSR OP_INT_GTE
.3a2a61	80 03		bra $3a2a66	            BRA done
.3a2a63					is_float
.3a2a63	20 5c 5d	jsr $3a5d5c	            JSR OP_FP_GTE
.3a2a66	28		plp		done        PLP
.3a2a67	60		rts		            RTS
.3a2a68					OP_LTE
.3a2a68	08		php		            PHP
.3a2a69	e2 20		sep #$20	            SEP #$20
.3a2a6b	20 a3 08	jsr $3a08a3	            JSR ASS_ARGS_NUMSTR
.3a2a6e	c9 00		cmp #$00	            CMP #TYPE_INTEGER       ; And dispatch on the type
.3a2a70	f0 2c		beq $3a2a9e	            BEQ is_integer
.3a2a72	c9 01		cmp #$01	            CMP #TYPE_FLOAT
.3a2a74	f0 2d		beq $3a2aa3	            BEQ is_float
.3a2a76	c9 02		cmp #$02	            CMP #TYPE_STRING
.3a2a78	f0 1f		beq $3a2a99	            BEQ is_string
.3a2a7a					type_error
.3a2a7a	08		php		            PHP
.3a2a7b	c2 20		rep #$20	            REP #$20
.3a2a7d	48		pha		            PHA
.3a2a7e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2a81	5b		tcd		            TCD
.3a2a82	68		pla		            PLA
.3a2a83	28		plp		            PLP
.3a2a84	e2 20		sep #$20	            SEP #$20
.3a2a86	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2a88	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2a8c	c2 20		rep #$20	            REP #$20
.3a2a8e	29 ff 00	and #$00ff	            AND #$00FF
.3a2a91	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a2a94	e2 20		sep #$20	            SEP #$20
.3a2a96	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2a99					is_string
.3a2a99	20 4c 18	jsr $3a184c	            JSR OP_STR_LTE
.3a2a9c	80 08		bra $3a2aa6	            BRA done
.3a2a9e					is_integer
.3a2a9e	20 4a 56	jsr $3a564a	            JSR OP_INT_LTE
.3a2aa1	80 03		bra $3a2aa6	            BRA done
.3a2aa3					is_float
.3a2aa3	20 47 5d	jsr $3a5d47	            JSR OP_FP_LTE
.3a2aa6	28		plp		done        PLP
.3a2aa7	60		rts		            RTS
.3a2aa8					OP_NEGATIVE
.3a2aa8	08		php		                PHP
.3a2aa9	e2 20		sep #$20	            SEP #$20
.3a2aab	a5 27		lda $0827	                LDA ARGTYPE1                ; Check the type of the argument
.3a2aad	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a2aaf	f0 2d		beq $3a2ade	                BEQ int_negate              ; If integer: negate the integer
.3a2ab1	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.3a2ab3	f0 1f		beq $3a2ad4	                BEQ float_negate            ; If floating point: negate the floating point
.3a2ab5					type_error
.3a2ab5	08		php		            PHP
.3a2ab6	c2 20		rep #$20	            REP #$20
.3a2ab8	48		pha		            PHA
.3a2ab9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2abc	5b		tcd		            TCD
.3a2abd	68		pla		            PLA
.3a2abe	28		plp		            PLP
.3a2abf	e2 20		sep #$20	            SEP #$20
.3a2ac1	a9 04		lda #$04	            LDA #ERR_TYPE
.3a2ac3	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2ac7	c2 20		rep #$20	            REP #$20
.3a2ac9	29 ff 00	and #$00ff	            AND #$00FF
.3a2acc	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a2acf	e2 20		sep #$20	            SEP #$20
.3a2ad1	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2ad4					float_negate
.3a2ad4	e2 20		sep #$20	            SEP #$20
.3a2ad6	a5 26		lda $0826	                LDA ARGUMENT1+3             ; Flip the sign bit of the floating point number
.3a2ad8	49 80		eor #$80	                EOR #$80
.3a2ada	85 26		sta $0826	                STA ARGUMENT1+3
.3a2adc	80 16		bra $3a2af4	                BRA done
.3a2ade					int_negate
.3a2ade	c2 20		rep #$20	            REP #$20
.3a2ae0	a5 23		lda $0823	                LDA ARGUMENT1               ; Invert ARGUMENT1
.3a2ae2	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a2ae5	85 23		sta $0823	                STA ARGUMENT1
.3a2ae7	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a2ae9	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a2aec	85 25		sta $0825	                STA ARGUMENT1+2
.3a2aee	e6 23		inc $0823	                INC ARGUMENT1               ; And increment to get two's complement
.3a2af0	d0 02		bne $3a2af4	                BNE done
.3a2af2	e6 25		inc $0825	                INC ARGUMENT1+2
.3a2af4					done
.3a2af4	28		plp		                PLP
.3a2af5	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\statements.s


;******  Processing file: src\C256/statements_c256.s

=0					GR_LUT_BLUE = 0
=1					GR_LUT_GREEN = 1
=2					GR_LUT_RED = 2
=3					GR_LUT_ALPHA = 3
=640					GR_DEFAULT_COLS = 640               ; Default number of columns in the display
=480					GR_DEFAULT_ROWS = 480               ; Default number of rows in the display
=8					GR_MAX_LUT = 8                      ; The number of LUTs Vicky supports
=64					SP_MAX = 64                         ; The number of sprites Vicky supports
=8					SP_REG_SIZE = 8                     ; The number of bytes in a sprite's register block
=0					SP_CONTROL = 0                      ; Offset of the control regsiter for a sprite
=1					SP_ADDR = 1                         ; Offset of the pixmap address for a sprite
=4					SP_X_COORD = 4                      ; Offset of the X coordinate for a sprite
=6					SP_Y_COORD = 6                      ; Offset of the Y coordinate for a sprite
=12					TILEMAP_REG_SIZE = 12               ; The number of bytes in a tile map's register set
=4					TILESET_REG_SIZE = 4                ; The number of bytes in a tile set's register set
=2					BM_MAX = 2                          ; Maximum number of bitmaps we support
=$0040					MAX_VRAM_VICKY = $0040              ; Upper limit (exclusive) bank address for VRAM in Vicky address space
=$00f0					MAX_VRAM_CPU = $00F0                ; Upper limit (exclusive) bank address for VRAM in CPU address space
=$00b0					MIN_VRAM_CPU = $00B0                ; Lower limit (inclusive) bank address for VRAM in CPU address space
>3af000					GR_BM0_ADDR     .dword ?            ; Address of bitmap 0 (from CPU's perspective)
>3af004					GR_BM1_ADDR     .dword ?            ; Address of bitmap 1 (from CPU's perspective)
>3af008					GR_BM0_VRAM     .dword ?            ; Address of bitmap 0 (relative to start of VRAM)
>3af00c					GR_BM1_VRAM     .dword ?            ; Address of bitmap 1 (relative to start of VRAM)
>3af010					GR_MAX_COLS     .word ?             ; Width the display in pixels
>3af012					GR_MAX_ROWS     .word ?             ; Height of the display in pixels
>3af014					GR_TOTAL_PIXELS .word ?             ; Total number of pixels in the display
>3af016					GR_TEMP         .word ?             ; A temporary word for graphics commands
>3af018					GS_SP_CONTROL   .fill SP_MAX        ; Shadow registers for the sprite controls
.3a2af6					S_SETTIME
.3a2af6	08		php		                PHP
.3a2af7	e2 20		sep #$20	            SEP #$20
.3a2af9	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2afc	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2aff	20 ae 05	jsr $3a05ae	            JSR DIVINT10
.3a2b02	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2b04	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2b05	0a		asl a		                ASL A
.3a2b06	0a		asl a		                ASL A
.3a2b07	0a		asl a		                ASL A
.3a2b08	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2b0a	48		pha		                PHA
.3a2b0b	a9 2c		lda #$2c	                LDA #','
.3a2b0d	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a2b10	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2b13	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2b16	20 ae 05	jsr $3a05ae	            JSR DIVINT10
.3a2b19	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2b1b	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2b1c	0a		asl a		                ASL A
.3a2b1d	0a		asl a		                ASL A
.3a2b1e	0a		asl a		                ASL A
.3a2b1f	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2b21	48		pha		                PHA
.3a2b22	a9 2c		lda #$2c	                LDA #','
.3a2b24	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a2b27	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2b2a	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2b2d	20 ae 05	jsr $3a05ae	            JSR DIVINT10
.3a2b30	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2b32	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2b33	0a		asl a		                ASL A
.3a2b34	0a		asl a		                ASL A
.3a2b35	0a		asl a		                ASL A
.3a2b36	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2b38	48		pha		                PHA
.3a2b39	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.3a2b3d	09 0c		ora #$0c	                ORA #%00001100
.3a2b3f	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.3a2b43	68		pla		                PLA                     ; And seconds to the RTC
.3a2b44	8f 00 08 af	sta $af0800	                STA @lRTC_SEC
.3a2b48	68		pla		                PLA                     ; Minutes...
.3a2b49	8f 02 08 af	sta $af0802	                STA @lRTC_MIN
.3a2b4d	68		pla		                PLA                     ; Save the hour...
.3a2b4e	8f 04 08 af	sta $af0804	                STA @lRTC_HRS
.3a2b52	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.3a2b56	29 f7		and #$f7	                AND #%11110111
.3a2b58	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.3a2b5c	20 5f 21	jsr $3a215f	            JSR SKIPSTMT
.3a2b5f	28		plp		                PLP
.3a2b60	60		rts		            RTS
.3a2b61					S_SETDATE
.3a2b61	08		php		                PHP
.3a2b62	e2 20		sep #$20	            SEP #$20
.3a2b64	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2b67	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2b6a	20 ae 05	jsr $3a05ae	            JSR DIVINT10
.3a2b6d	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2b6f	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2b70	0a		asl a		                ASL A
.3a2b71	0a		asl a		                ASL A
.3a2b72	0a		asl a		                ASL A
.3a2b73	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2b75	48		pha		                PHA
.3a2b76	a9 2c		lda #$2c	                LDA #','
.3a2b78	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a2b7b	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2b7e	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2b81	20 ae 05	jsr $3a05ae	            JSR DIVINT10
.3a2b84	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2b86	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2b87	0a		asl a		                ASL A
.3a2b88	0a		asl a		                ASL A
.3a2b89	0a		asl a		                ASL A
.3a2b8a	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2b8c	48		pha		                PHA
.3a2b8d	a9 2c		lda #$2c	                LDA #','
.3a2b8f	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a2b92	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2b95	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a2b98	20 e4 05	jsr $3a05e4	            JSR DIVINT100
.3a2b9b	c2 20		rep #$20	            REP #$20
.3a2b9d	a5 23		lda $0823	                LDA ARGUMENT1           ; Get the century
.3a2b9f	85 92		sta $0892	                STA MTEMP               ; Save it in MTEMP
.3a2ba1	a5 29		lda $0829	                LDA ARGUMENT2           ; Separate the 10s from the 1s digits
.3a2ba3	85 23		sta $0823	                STA ARGUMENT1
.3a2ba5	20 ae 05	jsr $3a05ae	            JSR DIVINT10
.3a2ba8	e2 20		sep #$20	            SEP #$20
.3a2baa	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2bac	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2bad	0a		asl a		                ASL A
.3a2bae	0a		asl a		                ASL A
.3a2baf	0a		asl a		                ASL A
.3a2bb0	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2bb2	48		pha		                PHA                     ; Save the 10s and 1s in BCD
.3a2bb3	c2 20		rep #$20	            REP #$20
.3a2bb5	a5 92		lda $0892	                LDA MTEMP               ; Separate the 100s from the 1000s digits
.3a2bb7	85 23		sta $0823	                STA ARGUMENT1
.3a2bb9	20 ae 05	jsr $3a05ae	            JSR DIVINT10
.3a2bbc	e2 20		sep #$20	            SEP #$20
.3a2bbe	a5 23		lda $0823	                LDA ARGUMENT1           ; Take the tens digit
.3a2bc0	0a		asl a		                ASL A                   ; Shift it 4 bits
.3a2bc1	0a		asl a		                ASL A
.3a2bc2	0a		asl a		                ASL A
.3a2bc3	0a		asl a		                ASL A
.3a2bc4	05 29		ora $0829	                ORA ARGUMENT2           ; And add in the ones digit
.3a2bc6	48		pha		                PHA                     ; Save the 100s and 1000s in BCD
.3a2bc7	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Pause updates to the clock registers
.3a2bcb	09 0c		ora #$0c	                ORA #%00001100
.3a2bcd	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.3a2bd1	68		pla		                PLA                     ; Set the century
.3a2bd2	8f 0f 08 af	sta $af080f	                STA @lRTC_CENTURY
.3a2bd6	68		pla		                PLA                     ; And year to the RTC
.3a2bd7	8f 0a 08 af	sta $af080a	                STA @lRTC_YEAR
.3a2bdb	68		pla		                PLA                     ; Month...
.3a2bdc	8f 09 08 af	sta $af0809	                STA @lRTC_MONTH
.3a2be0	68		pla		                PLA                     ; Save the day...
.3a2be1	8f 06 08 af	sta $af0806	                STA @lRTC_DAY
.3a2be5	af 0e 08 af	lda $af080e	                LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.3a2be9	29 f7		and #$f7	                AND #%11110111
.3a2beb	8f 0e 08 af	sta $af080e	                STA @lRTC_CTRL
.3a2bef	20 5f 21	jsr $3a215f	            JSR SKIPSTMT
.3a2bf2	28		plp		                PLP
.3a2bf3	60		rts		            RTS
.3a2bf4					S_TEXTCOLOR
.3a2bf4	08		php		                PHP
.3a2bf5					locals
>0001					L_FOREGROUND    .byte ?
.3a2bf5	e2 20		sep #$20	            SEP #$20
.3a2bf7	48		pha		            PHA
.3a2bf8	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2bfb	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2bfe	e2 20		sep #$20	            SEP #$20
.3a2c00	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the foreground position
.3a2c02	29 0f		and #$0f	                AND #$0F
.3a2c04	0a		asl a		                ASL A
.3a2c05	0a		asl a		                ASL A
.3a2c06	0a		asl a		                ASL A
.3a2c07	0a		asl a		                ASL A
.3a2c08	83 01		sta $01,s	                STA L_FOREGROUND    ; Save the foreground color
.3a2c0a	a9 2c		lda #$2c	                LDA #','
.3a2c0c	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a2c0f	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2c12	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2c15	a5 23		lda $0823	                LDA ARGUMENT1       ; Covert the color number to the background position
.3a2c17	29 0f		and #$0f	                AND #$0F
.3a2c19	03 01		ora $01,s	                ORA L_FOREGROUND    ; Add in the foreground
.3a2c1b	8f 1e 00 00	sta $00001e	                STA @lCURCOLOR      ; And save the new color combination
.3a2c1f	e2 20		sep #$20	            SEP #$20
.3a2c21	68		pla		            PLA
.3a2c22	28		plp		                PLP
.3a2c23	60		rts		            RTS
.3a2c24					S_SETBGCOLOR
.3a2c24	08		php		                PHP
.3a2c25					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.3a2c25	c2 20		rep #$20	            REP #$20
.3a2c27	f4 00 00	pea #$0000	            PEA #0
.3a2c2a	e2 20		sep #$20	            SEP #$20
.3a2c2c	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2c2f	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2c32	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.3a2c34	83 01		sta $01,s	                STA L_RED
.3a2c36	a9 2c		lda #$2c	                LDA #','
.3a2c38	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a2c3b	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2c3e	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2c41	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.3a2c43	83 02		sta $02,s	                STA L_GREEN
.3a2c45	a9 2c		lda #$2c	                LDA #','
.3a2c47	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a2c4a	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2c4d	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2c50	a5 23		lda $0823	                LDA ARGUMENT1               ; And set the actual color
.3a2c52	8f 0d 00 af	sta $af000d	                STA @lBACKGROUND_COLOR_B
.3a2c56	a3 02		lda $02,s	                LDA L_GREEN
.3a2c58	8f 0e 00 af	sta $af000e	                STA @lBACKGROUND_COLOR_G
.3a2c5c	a3 01		lda $01,s	                LDA L_RED
.3a2c5e	8f 0f 00 af	sta $af000f	                STA @lBACKGROUND_COLOR_R
.3a2c62	c2 20		rep #$20	            REP #$20
.3a2c64	68		pla		            PLA
.3a2c65	28		plp		                PLP
.3a2c66	60		rts		            RTS
.3a2c67					S_SETBORDER
.3a2c67	08		php		                PHP
.3a2c68					locals
>0001					L_RED           .byte ?
>0002					L_GREEN         .byte ?
.3a2c68	c2 20		rep #$20	            REP #$20
.3a2c6a	f4 00 00	pea #$0000	            PEA #0
.3a2c6d	e2 20		sep #$20	            SEP #$20
.3a2c6f	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2c72	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a2c75	a5 23		lda $0823	                LDA ARGUMENT1
.3a2c77	f0 16		beq $3a2c8f	                BEQ hide_border
.3a2c79	a9 01		lda #$01	                LDA #Border_Ctrl_Enable     ; Enable the border
.3a2c7b	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.3a2c7f	a9 20		lda #$20	                LDA #BORDER_WIDTH           ; Set the border width
.3a2c81	8f 08 00 af	sta $af0008	                STA BORDER_X_SIZE
.3a2c85	8f 09 00 af	sta $af0009	                STA BORDER_Y_SIZE
.3a2c89	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.3a2c8d	80 0a		bra $3a2c99	                BRA get_color
.3a2c8f	a9 00		lda #$00	hide_border     LDA #0                      ; Hide the border
.3a2c91	8f 04 00 af	sta $af0004	                STA @lBORDER_CTRL_REG
.3a2c95	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.3a2c99	a9 2c		lda #$2c	get_color       LDA #','
.3a2c9b	85 37		sta $0837	                STA TARGETTOK
.3a2c9d	20 5c 22	jsr $3a225c	            JSR OPT_TOK
.3a2ca0	90 39		bcc $3a2cdb	                BCC done                    ; No: we're done
.3a2ca2	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a2ca5	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2ca8	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2cab	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the red component to the stack
.3a2cad	83 01		sta $01,s	                STA L_RED
.3a2caf	a9 2c		lda #$2c	                LDA #','
.3a2cb1	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a2cb4	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2cb7	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2cba	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the green component to the stack
.3a2cbc	83 02		sta $02,s	                STA L_GREEN
.3a2cbe	a9 2c		lda #$2c	                LDA #','
.3a2cc0	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a2cc3	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2cc6	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2cc9	a5 23		lda $0823	                LDA ARGUMENT1
.3a2ccb	8f 05 00 af	sta $af0005	                STA @lBORDER_COLOR_B        ; Set the border color
.3a2ccf	a3 02		lda $02,s	                LDA L_GREEN
.3a2cd1	8f 06 00 af	sta $af0006	                STA @lBORDER_COLOR_G
.3a2cd5	a3 01		lda $01,s	                LDA L_RED
.3a2cd7	8f 07 00 af	sta $af0007	                STA @lBORDER_COLOR_R
.3a2cdb					done
.3a2cdb	c2 20		rep #$20	            REP #$20
.3a2cdd	68		pla		            PLA
.3a2cde	28		plp		                PLP
.3a2cdf	60		rts		            RTS
.3a2ce0					S_SETCOLOR
.3a2ce0	08		php		                PHP
.3a2ce1					locals
>0001					L_LUT           .byte ?
>0002					L_COLOR         .byte ?
>0003					L_RED           .byte ?
>0004					L_GREEN         .byte ?
>0005					L_BLUE          .byte ?
.3a2ce1	c2 20		rep #$20	            REP #$20
.3a2ce3	3b		tsc		            TSC
.3a2ce4	38		sec		            SEC
.3a2ce5	e9 05 00	sbc #$0005	            SBC #SIZE(locals)
.3a2ce8	1b		tcs		            TCS
.3a2ce9	e2 20		sep #$20	            SEP #$20
.3a2ceb	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2cee	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2cf1	a5 23		lda $0823	                LDA ARGUMENT1
.3a2cf3	c9 0a		cmp #$0a	                CMP #10             ; And in range
.3a2cf5	90 1f		bcc $3a2d16	                BLT save_lut
.3a2cf7					bad_argument
.3a2cf7	08		php		            PHP
.3a2cf8	c2 20		rep #$20	            REP #$20
.3a2cfa	48		pha		            PHA
.3a2cfb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2cfe	5b		tcd		            TCD
.3a2cff	68		pla		            PLA
.3a2d00	28		plp		            PLP
.3a2d01	e2 20		sep #$20	            SEP #$20
.3a2d03	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a2d05	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2d09	c2 20		rep #$20	            REP #$20
.3a2d0b	29 ff 00	and #$00ff	            AND #$00FF
.3a2d0e	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a2d11	e2 20		sep #$20	            SEP #$20
.3a2d13	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2d16	83 01		sta $01,s	save_lut        STA L_LUT           ; Save as LUT
.3a2d18	a9 2c		lda #$2c	                LDA #','
.3a2d1a	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a2d1d	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2d20	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2d23	a5 23		lda $0823	                LDA ARGUMENT1
.3a2d25	83 02		sta $02,s	                STA L_COLOR         ; Save as COLOR
.3a2d27	a9 2c		lda #$2c	                LDA #','
.3a2d29	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a2d2c	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2d2f	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2d32	a5 23		lda $0823	                LDA ARGUMENT1
.3a2d34	83 03		sta $03,s	                STA L_RED           ; Save as RED
.3a2d36	a9 2c		lda #$2c	                LDA #','
.3a2d38	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a2d3b	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2d3e	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2d41	a5 23		lda $0823	                LDA ARGUMENT1
.3a2d43	83 04		sta $04,s	                STA L_GREEN         ; Save it as GREEN
.3a2d45	a9 2c		lda #$2c	                LDA #','
.3a2d47	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a2d4a	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2d4d	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2d50	a5 23		lda $0823	                LDA ARGUMENT1
.3a2d52	83 05		sta $05,s	                STA L_BLUE          ; Save it as BLUE
.3a2d54	a9 af		lda #$af	                LDA #`GRPH_LUT0_PTR ; Get the bank Vicky is in (should always be $AF)
.3a2d56	85 a0		sta $08a0	                STA MTEMPPTR+2      ; MTEMPPTR will be our pointer to the LUT entry
.3a2d58	a3 01		lda $01,s	                LDA L_LUT           ; Compute the offset to the LUT address
.3a2d5a	0a		asl a		                ASL A
.3a2d5b	c2 20		rep #$20	            REP #$20
.3a2d5d	29 ff 00	and #$00ff	                AND #$00FF
.3a2d60	aa		tax		                TAX                 ; Put it in X
.3a2d61	bf 98 2d 3a	lda $3a2d98,x	                LDA @llut_address,X ; Get the address of the LUT
.3a2d65	85 9e		sta $089e	                STA MTEMPPTR        ; Put it in MTEMPPTR
.3a2d67	e2 20		sep #$20	            SEP #$20
.3a2d69	a3 02		lda $02,s	                LDA L_COLOR         ; color index *= 4
.3a2d6b	c2 20		rep #$20	            REP #$20
.3a2d6d	29 ff 00	and #$00ff	                AND #$00FF
.3a2d70	0a		asl a		                ASL A               ; Since each color has four bytes of data
.3a2d71	0a		asl a		                ASL A
.3a2d72	18		clc		                CLC                 ; Add the color offset to MTEMPPTR
.3a2d73	65 9e		adc $089e	                ADC MTEMPPTR
.3a2d75	85 9e		sta $089e	                STA MTEMPPTR
.3a2d77	e2 20		sep #$20	            SEP #$20
.3a2d79	a0 02 00	ldy #$0002	                LDY #GR_LUT_RED
.3a2d7c	a3 03		lda $03,s	                LDA L_RED
.3a2d7e	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the red component to the color entry
.3a2d80	a0 01 00	ldy #$0001	                LDY #GR_LUT_GREEN
.3a2d83	a3 04		lda $04,s	                LDA L_GREEN
.3a2d85	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the green component to the color entry
.3a2d87	a0 00 00	ldy #$0000	                LDY #GR_LUT_BLUE
.3a2d8a	a3 05		lda $05,s	                LDA L_BLUE
.3a2d8c	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y    ; Save the blue component to the color entry
.3a2d8e					done
.3a2d8e	c2 20		rep #$20	            REP #$20
.3a2d90	3b		tsc		            TSC
.3a2d91	18		clc		            CLC
.3a2d92	69 05 00	adc #$0005	            ADC #SIZE(locals)
.3a2d95	1b		tcs		            TCS
.3a2d96	28		plp		                PLP
.3a2d97	60		rts		            RTS
>3a2d98	00 20				lut_address     .word <>GRPH_LUT0_PTR
>3a2d9a	00 24				                .word <>GRPH_LUT1_PTR
>3a2d9c	00 28				                .word <>GRPH_LUT2_PTR
>3a2d9e	00 2c				                .word <>GRPH_LUT3_PTR
>3a2da0	00 30				                .word <>GRPH_LUT4_PTR
>3a2da2	00 34				                .word <>GRPH_LUT5_PTR
>3a2da4	00 38				                .word <>GRPH_LUT6_PTR
>3a2da6	00 3c				                .word <>GRPH_LUT7_PTR
>3a2da8	40 1f				                .word <>FG_CHAR_LUT_PTR
>3a2daa	80 1f				                .word <>BG_CHAR_LUT_PTR
.3a2dac					S_GRAPHICS
.3a2dac	da		phx		                PHX
.3a2dad	5a		phy		                PHY
.3a2dae	08		php		                PHP
.3a2daf	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2db2	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a2db5	c2 20		rep #$20	            REP #$20
.3a2db7	a5 23		lda $0823	                LDA ARGUMENT1               ; Check to see if we're setting mode to 800x600 or 400x300
.3a2db9	89 00 01	bit #$0100	                BIT #$0100
.3a2dbc	d0 17		bne $3a2dd5	                BNE set_mode                ; Yes: go ahead and set it
.3a2dbe	af 00 00 af	lda $af0000	                LDA @l MASTER_CTRL_REG_L    ; Otherwise, check to see if we're already in 800x600 or 400x300
.3a2dc2	89 00 01	bit #$0100	                BIT #$0100
.3a2dc5	f0 0e		beq $3a2dd5	                BEQ set_mode                ; No: just go ahead and set the mode
.3a2dc7	e2 20		sep #$20	            SEP #$20
.3a2dc9	a9 00		lda #$00	                LDA #0                      ; Yes: toggle back to 640x480...
.3a2dcb	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.3a2dcf	a9 01		lda #$01	                LDA #1                      ; And back to 800x600....
.3a2dd1	8f 01 00 af	sta $af0001	                STA @l MASTER_CTRL_REG_H
.3a2dd5					set_mode
.3a2dd5	c2 20		rep #$20	            REP #$20
.3a2dd7	a5 23		lda $0823	                LDA ARGUMENT1
.3a2dd9	8f 00 00 af	sta $af0000	                STA @l MASTER_CTRL_REG_L    ; Set the graphics mode
.3a2ddd	e2 20		sep #$20	            SEP #$20
.3a2ddf	a5 24		lda $0824	                LDA ARGUMENT1+1             ; Get the screen size bits
.3a2de1	c2 20		rep #$20	            REP #$20
.3a2de3	29 03 00	and #$0003	                AND #$0003
.3a2de6	0a		asl a		                ASL A                       ; Multiply by two to get the index
.3a2de7	aa		tax		                TAX                         ; X is index into the size tables
.3a2de8	c2 20		rep #$20	            REP #$20
.3a2dea	bf 33 2e 3a	lda $3a2e33,x	                LDA gr_columns,X            ; Set the columns
.3a2dee	8f 10 f0 3a	sta $3af010	                STA @lGR_MAX_COLS
.3a2df2	bf 3b 2e 3a	lda $3a2e3b,x	                LDA gr_rows,X               ; Set the rows
.3a2df6	8f 12 f0 3a	sta $3af012	                STA @lGR_MAX_ROWS
.3a2dfa	af 10 f0 3a	lda $3af010	                LDA @lGR_MAX_COLS           ; Get the current columns
.3a2dfe	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.3a2e02	af 12 f0 3a	lda $3af012	                LDA @lGR_MAX_ROWS           ; Get the current rows
.3a2e06	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B
.3a2e0a	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT             ; Multiply them to get the total pixels
.3a2e0e	8f 14 f0 3a	sta $3af014	                STA @lGR_TOTAL_PIXELS
.3a2e12	e2 20		sep #$20	            SEP #$20
.3a2e14	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.3a2e18	8f 16 f0 3a	sta $3af016	                STA @lGR_TOTAL_PIXELS+2
.3a2e1c	22 2c 11 00	jsl $00112c	                JSL FK_SETSIZES
.3a2e20					reset_cursor
.3a2e20	c2 20		rep #$20	            REP #$20
.3a2e22	af 1a 00 00	lda $00001a	                LDA @lCURSORX
.3a2e26	aa		tax		                TAX
.3a2e27	af 1c 00 00	lda $00001c	                LDA @lCURSORY
.3a2e2b	a8		tay		                TAY
.3a2e2c	20 20 00	jsr $3a0020	            JSR CURSORXY
.3a2e2f	28		plp		                PLP
.3a2e30	7a		ply		                PLY
.3a2e31	fa		plx		                PLX
.3a2e32	60		rts		            RTS
>3a2e33	80 02 20 03 40 01 90 01		gr_columns      .word 640,800,320,400
>3a2e3b	e0 01 58 02 f0 00 2c 01		gr_rows         .word 480,600,240,300
>3a2e43	50 00 64 00 28 00 32 00		col_count       .word 80,100,40,50
>3a2e4b	3c 00 4b 00 1e 00 32 00		row_count       .word 60,75,30,50
>3a2e53	48 00 5c 00 20 00 2a 00		colb_count      .word 72,92,32,42
>3a2e5b	34 00 43 00 16 00 34 00		rowb_count      .word 52,67,22,52
.3a2e63					BITMAP_SRAM
.3a2e63	da		phx		                PHX
.3a2e64	08		php		                PHP
.3a2e65	c2 30		rep #$30	            REP #$30
.3a2e67	c9 02 00	cmp #$0002	                CMP #BM_MAX
.3a2e6a	b0 1c		bcs $3a2e88	                BGE range_err           ; Make sure it's within range
.3a2e6c	0a		asl a		                ASL A
.3a2e6d	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.3a2e6e	aa		tax		                TAX
.3a2e6f	bf 00 f0 3a	lda $3af000,x	                LDA @l GR_BM0_ADDR,X    ; Get the low 16-bits of the address
.3a2e73	85 9e		sta $089e	                STA MTEMPPTR
.3a2e75	bf 02 f0 3a	lda $3af002,x	                LDA @l GR_BM0_ADDR+2,X  ; Get the high bits of the address
.3a2e79	85 a0		sta $08a0	                STA MTEMPPTR+2
.3a2e7b	c9 f0 00	cmp #$00f0	                CMP #MAX_VRAM_CPU       ; Check to make sure address is within VRAM
.3a2e7e	b0 08		bcs $3a2e88	                BGE range_err
.3a2e80	c9 b0 00	cmp #$00b0	                CMP #MIN_VRAM_CPU
.3a2e83	90 03		bcc $3a2e88	                BLT range_err
.3a2e85	28		plp		                PLP
.3a2e86	fa		plx		                PLX
.3a2e87	60		rts		            RTS
.3a2e88					range_err
.3a2e88	08		php		            PHP
.3a2e89	c2 20		rep #$20	            REP #$20
.3a2e8b	48		pha		            PHA
.3a2e8c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2e8f	5b		tcd		            TCD
.3a2e90	68		pla		            PLA
.3a2e91	28		plp		            PLP
.3a2e92	e2 20		sep #$20	            SEP #$20
.3a2e94	a9 09		lda #$09	            LDA #ERR_RANGE
.3a2e96	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2e9a	c2 20		rep #$20	            REP #$20
.3a2e9c	29 ff 00	and #$00ff	            AND #$00FF
.3a2e9f	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a2ea2	e2 20		sep #$20	            SEP #$20
.3a2ea4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2ea7					BITMAP_VRAM
.3a2ea7	da		phx		                PHX
.3a2ea8	08		php		                PHP
.3a2ea9	c2 30		rep #$30	            REP #$30
.3a2eab	c9 02 00	cmp #$0002	                CMP #BM_MAX
.3a2eae	b0 17		bcs $3a2ec7	                BGE range_err           ; Make sure it's within range
.3a2eb0	0a		asl a		                ASL A
.3a2eb1	0a		asl a		                ASL A                   ; Multiply by 4 to calculate an address offset
.3a2eb2	aa		tax		                TAX
.3a2eb3	bf 08 f0 3a	lda $3af008,x	                LDA @l GR_BM0_VRAM,X    ; Get the low 16-bits of the address
.3a2eb7	85 9e		sta $089e	                STA MTEMPPTR
.3a2eb9	bf 0a f0 3a	lda $3af00a,x	                LDA @l GR_BM0_VRAM+2,X  ; Get the high bits of the address
.3a2ebd	85 a0		sta $08a0	                STA MTEMPPTR+2
.3a2ebf	c9 40 00	cmp #$0040	                CMP #MAX_VRAM_VICKY     ; Check to make sure the address is from $00:0000 - $3F:FFFF
.3a2ec2	b0 03		bcs $3a2ec7	                BGE range_err           ; If not, throw a range error
.3a2ec4	28		plp		                PLP
.3a2ec5	fa		plx		                PLX
.3a2ec6	60		rts		            RTS
.3a2ec7					range_err
.3a2ec7	08		php		            PHP
.3a2ec8	c2 20		rep #$20	            REP #$20
.3a2eca	48		pha		            PHA
.3a2ecb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2ece	5b		tcd		            TCD
.3a2ecf	68		pla		            PLA
.3a2ed0	28		plp		            PLP
.3a2ed1	e2 20		sep #$20	            SEP #$20
.3a2ed3	a9 09		lda #$09	            LDA #ERR_RANGE
.3a2ed5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2ed9	c2 20		rep #$20	            REP #$20
.3a2edb	29 ff 00	and #$00ff	            AND #$00FF
.3a2ede	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a2ee1	e2 20		sep #$20	            SEP #$20
.3a2ee3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2ee6					S_BITMAP
.3a2ee6	08		php		                PHP
.3a2ee7					locals
>0001					L_PLANE         .word ?
>0003					L_VISIBLE       .byte ?
>0004					L_ADDRESS       .dword ?
.3a2ee7	c2 30		rep #$30	            REP #$30
.3a2ee9	3b		tsc		                TSC                         ; Allocate space for the locals on the stack
.3a2eea	38		sec		                SEC
.3a2eeb	e9 07 00	sbc #$0007	                SBC #SIZE(locals)
.3a2eee	1b		tcs		                TCS
.3a2eef	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2ef2	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2ef5	c2 20		rep #$20	            REP #$20
.3a2ef7	a5 23		lda $0823	                LDA ARGUMENT1               ; Make sure it's in range
.3a2ef9	c9 02 00	cmp #$0002	                CMP #BM_MAX
.3a2efc	b0 59		bcs $3a2f57	                BGE range_err               ; If not, throw an error
.3a2efe	83 01		sta $01,s	                STA L_PLANE                 ; If so, save it to MARG1
.3a2f00	e2 20		sep #$20	            SEP #$20
.3a2f02	a9 2c		lda #$2c	                LDA #','
.3a2f04	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a2f07	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2f0a	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2f0d	a5 23		lda $0823	                LDA ARGUMENT1
.3a2f0f	83 03		sta $03,s	                STA L_VISIBLE
.3a2f11	a9 2c		lda #$2c	                LDA #','
.3a2f13	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a2f16	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2f19	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2f1c	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the number back
.3a2f1e	0a		asl a		                ASL A                       ; Multiply by 8 to get the offset to the registers
.3a2f1f	0a		asl a		                ASL A
.3a2f20	0a		asl a		                ASL A
.3a2f21	aa		tax		                TAX                         ; And save that offset to X
.3a2f22	a3 03		lda $03,s	                LDA L_VISIBLE               ; Check the visible flag
.3a2f24	d0 05		bne $3a2f2b	                BNE is_visible              ; If <> 0, it's visible
.3a2f26	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the LUT #
.3a2f28	0a		asl a		                ASL A                       ; Shift it into position for the register
.3a2f29	80 04		bra $3a2f2f	                BRA wr_bm_reg               ; And go to write it
.3a2f2b	a5 23		lda $0823	is_visible      LDA ARGUMENT1               ; Get the LUT #
.3a2f2d	38		sec		                SEC
.3a2f2e	2a		rol a		                ROL A                       ; And shift it into position, and set enable bit
.3a2f2f	9f 00 01 af	sta $af0100,x	wr_bm_reg       STA @l BM0_CONTROL_REG,X    ; Write to the bitmap control register
.3a2f33	c2 20		rep #$20	            REP #$20
.3a2f35	a9 2c 00	lda #$002c	                LDA #','
.3a2f38	85 37		sta $0837	                STA TARGETTOK
.3a2f3a	20 5c 22	jsr $3a225c	            JSR OPT_TOK
.3a2f3d	b0 37		bcs $3a2f76	                BCS get_address             ; Yes: parse the address
.3a2f3f	c2 20		rep #$20	            REP #$20
.3a2f41	08		php		            PHP
.3a2f42	c2 20		rep #$20	            REP #$20
.3a2f44	a9 00 00	lda #$0000	            LDA #<>VRAM
.3a2f47	85 23		sta $0823	            STA ARGUMENT1
.3a2f49	a9 b0 00	lda #$00b0	            LDA #(VRAM >> 16)
.3a2f4c	85 25		sta $0825	            STA ARGUMENT1+2
.3a2f4e	e2 20		sep #$20	            SEP #$20
.3a2f50	a9 00		lda #$00	            LDA #TYPE_INTEGER
.3a2f52	85 27		sta $0827	            STA ARGUMENT1+4
.3a2f54	28		plp		            PLP
.3a2f55	80 27		bra $3a2f7e	                BRA set_address
.3a2f57					range_err
.3a2f57	08		php		            PHP
.3a2f58	c2 20		rep #$20	            REP #$20
.3a2f5a	48		pha		            PHA
.3a2f5b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2f5e	5b		tcd		            TCD
.3a2f5f	68		pla		            PLA
.3a2f60	28		plp		            PLP
.3a2f61	e2 20		sep #$20	            SEP #$20
.3a2f63	a9 09		lda #$09	            LDA #ERR_RANGE
.3a2f65	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2f69	c2 20		rep #$20	            REP #$20
.3a2f6b	29 ff 00	and #$00ff	            AND #$00FF
.3a2f6e	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a2f71	e2 20		sep #$20	            SEP #$20
.3a2f73	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2f76					get_address
.3a2f76	c2 20		rep #$20	            REP #$20
.3a2f78	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a2f7b	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2f7e					set_address
.3a2f7e	c2 20		rep #$20	            REP #$20
.3a2f80	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.3a2f82	0a		asl a		                ASL A                       ; Multiply by four to get the offset to the address variable
.3a2f83	0a		asl a		                ASL A
.3a2f84	aa		tax		                TAX                         ; And put it in X
.3a2f85	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the CPU-space address
.3a2f87	9f 00 f0 3a	sta $3af000,x	                STA @l GR_BM0_ADDR,X        ; And save it to the correct GR_BM?_ADDR variable
.3a2f8b	9f 08 f0 3a	sta $3af008,x	                STA @l GR_BM0_VRAM,X
.3a2f8f	83 04		sta $04,s	                STA L_ADDRESS               ; And L_ADDRESS, temporarily
.3a2f91	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a2f93	9f 02 f0 3a	sta $3af002,x	                STA @l GR_BM0_ADDR+2,X
.3a2f97	38		sec		                SEC
.3a2f98	e9 b0 00	sbc #$00b0	                SBC #`VRAM                  ; Rebase the upper half of the address to Vicky memory space
.3a2f9b	9f 0a f0 3a	sta $3af00a,x	                STA @l GR_BM0_VRAM+2,X
.3a2f9f	83 06		sta $06,s	                STA L_ADDRESS+2             ; And to L_ADDRESS
.3a2fa1	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap number back
.3a2fa3	0a		asl a		                ASL A                       ; Multiply by eight to get the offset to the registers
.3a2fa4	0a		asl a		                ASL A
.3a2fa5	0a		asl a		                ASL A
.3a2fa6	aa		tax		                TAX                         ; And put it in X
.3a2fa7	e2 20		sep #$20	            SEP #$20
.3a2fa9	a3 04		lda $04,s	                LDA L_ADDRESS               ; Get the address in Vicky space...
.3a2fab	9f 01 01 af	sta $af0101,x	                STA @l BM0_START_ADDY_L,X   ; Save it to the Vicky registers
.3a2faf	a3 05		lda $05,s	                LDA L_ADDRESS+1
.3a2fb1	9f 02 01 af	sta $af0102,x	                STA @l BM0_START_ADDY_M,X
.3a2fb5	a3 06		lda $06,s	                LDA L_ADDRESS+2
.3a2fb7	9f 03 01 af	sta $af0103,x	                STA @l BM0_START_ADDY_H,X
.3a2fbb	a9 00		lda #$00	                LDA #0                      ; Default offset to (0, 0)
.3a2fbd	9f 04 01 af	sta $af0104,x	                STA @l BM0_X_OFFSET,X
.3a2fc1	9f 05 01 af	sta $af0105,x	                STA @l BM0_Y_OFFSET,X
.3a2fc5	c2 30		rep #$30	            REP #$30
.3a2fc7	3b		tsc		                TSC                         ; Remove the space for the locals from the stack
.3a2fc8	18		clc		                CLC
.3a2fc9	69 07 00	adc #$0007	                ADC #SIZE(locals)
.3a2fcc	1b		tcs		                TCS
.3a2fcd	28		plp		                PLP
.3a2fce	60		rts		            RTS
.3a2fcf					bad_address
.3a2fcf	08		php		            PHP
.3a2fd0	c2 20		rep #$20	            REP #$20
.3a2fd2	48		pha		            PHA
.3a2fd3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a2fd6	5b		tcd		            TCD
.3a2fd7	68		pla		            PLA
.3a2fd8	28		plp		            PLP
.3a2fd9	e2 20		sep #$20	            SEP #$20
.3a2fdb	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a2fdd	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a2fe1	c2 20		rep #$20	            REP #$20
.3a2fe3	29 ff 00	and #$00ff	            AND #$00FF
.3a2fe6	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a2fe9	e2 20		sep #$20	            SEP #$20
.3a2feb	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a2fee					S_CLRBITMAP
.3a2fee	08		php		                PHP
.3a2fef	c2 20		rep #$20	            REP #$20
.3a2ff1	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a2ff4	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a2ff7	a5 23		lda $0823	                LDA ARGUMENT1
.3a2ff9	20 a7 2e	jsr $3a2ea7	            JSR BITMAP_VRAM
.3a2ffc	c2 20		rep #$20	            REP #$20
.3a2ffe	a5 9e		lda $089e	                LDA MTEMPPTR                ; Set the start address and the # of pixels to write
.3a3000	8f 05 04 af	sta $af0405	                STA @lVDMA_DST_ADDY_L
.3a3004	af 14 f0 3a	lda $3af014	                LDA @lGR_TOTAL_PIXELS       ; Set the size
.3a3008	8f 08 04 af	sta $af0408	                STA @lVDMA_SIZE_L
.3a300c	e2 20		sep #$20	            SEP #$20
.3a300e	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.3a3010	8f 07 04 af	sta $af0407	                STA @lVDMA_DST_ADDY_H
.3a3014	af 16 f0 3a	lda $3af016	                LDA @lGR_TOTAL_PIXELS+2
.3a3018	8f 0a 04 af	sta $af040a	                STA @lVDMA_SIZE_H
.3a301c	a9 00		lda #$00	                LDA #0                      ; Set the color to write
.3a301e	8f 01 04 af	sta $af0401	                STA @lVDMA_BYTE_2_WRITE
.3a3022	a9 85		lda #$85	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_Start_TRF
.3a3024	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.3a3028	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.3a302c	30 fa		bmi $3a3028	                BMI wait
.3a302e	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.3a3030	8f 00 04 af	sta $af0400	                STA @lVDMA_CONTROL_REG
.3a3034	28		plp		done            PLP
.3a3035	60		rts		            RTS
=$000855				COLOR = MARG1
=$000859				X0 = MARG2
=$00085d				Y0 = MARG3
=$000861				X1 = MARG4
=$000865				Y1 = MARG5
=$000869				DX = MARG6
=$00086d				DY = MARG7
=$000871				ERR = MARG8
=$000875				ERR2 = MARG9
>08dd					SX      .word ?
>08df					SY      .word ?
.3a3036					PLOT
.3a3036	08		php		                PHP
.3a3037	c2 20		rep #$20	            REP #$20
.3a3039	a5 59		lda $0859	                LDA X0                      ; Get the column
.3a303b	cf 10 f0 3a	cmp $3af010	                CMP @l GR_MAX_COLS          ; Make sure it's in range for this graphics mode
.3a303f	90 1f		bcc $3a3060	                BLT chk_row                 ; If so: check the row
.3a3041					range_err
.3a3041	08		php		            PHP
.3a3042	c2 20		rep #$20	            REP #$20
.3a3044	48		pha		            PHA
.3a3045	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3048	5b		tcd		            TCD
.3a3049	68		pla		            PLA
.3a304a	28		plp		            PLP
.3a304b	e2 20		sep #$20	            SEP #$20
.3a304d	a9 09		lda #$09	            LDA #ERR_RANGE
.3a304f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3053	c2 20		rep #$20	            REP #$20
.3a3055	29 ff 00	and #$00ff	            AND #$00FF
.3a3058	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a305b	e2 20		sep #$20	            SEP #$20
.3a305d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3060					chk_row
.3a3060	c2 30		rep #$30	            REP #$30
.3a3062	a5 5d		lda $085d	                LDA Y0                      ; Get the row
.3a3064	cf 12 f0 3a	cmp $3af012	                CMP @l GR_MAX_ROWS          ; Make sure it's in range for this graphics mode
.3a3068	b0 d7		bcs $3a3041	                BGE range_err               ; If not: throw an error
.3a306a	8f 08 01 00	sta $000108	                STA @lM1_OPERAND_A
.3a306e	af 10 f0 3a	lda $3af010	                LDA @lGR_MAX_COLS
.3a3072	8f 0a 01 00	sta $00010a	                STA @lM1_OPERAND_B          ; Multiply by the number of columns in the pixmap
.3a3076	18		clc		                CLC                         ; Add the column
.3a3077	af 0c 01 00	lda $00010c	                LDA @lM1_RESULT
.3a307b	65 59		adc $0859	                ADC X0
.3a307d	85 0c		sta $080c	                STA SCRATCH
.3a307f	af 0e 01 00	lda $00010e	                LDA @lM1_RESULT+2
.3a3083	69 00 00	adc #$0000	                ADC #0
.3a3086	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH is offset of pixel in the pixmap
.3a3088	18		clc		                CLC                         ; Add the address of the first pixel
.3a3089	a5 0c		lda $080c	                LDA SCRATCH
.3a308b	65 9e		adc $089e	                ADC MTEMPPTR
.3a308d	85 0c		sta $080c	                STA SCRATCH
.3a308f	a5 0e		lda $080e	                LDA SCRATCH+2
.3a3091	65 a0		adc $08a0	                ADC MTEMPPTR+2
.3a3093	85 0e		sta $080e	                STA SCRATCH+2               ; SCRATCH := pixmap + pixel offset
.3a3095	e2 20		sep #$20	            SEP #$20
.3a3097	a5 55		lda $0855	                LDA COLOR                   ; Get the color
.3a3099	87 0c		sta [$080c]	                STA [SCRATCH]               ; And write the color to the pixel
.3a309b	28		plp		done            PLP
.3a309c	60		rts		            RTS
.3a309d					LINE
.3a309d	c2 20		rep #$20	            REP #$20
.3a309f	a9 01 00	lda #$0001	                LDA #1                      ; Assume SX = 1
.3a30a2	85 dd		sta $08dd	                STA SX
.3a30a4	38		sec		                SEC                         ; DX := ABS(X1 - X0)
.3a30a5	a5 61		lda $0861	                LDA X1
.3a30a7	e5 59		sbc $0859	                SBC X0
.3a30a9	85 69		sta $0869	                STA DX
.3a30ab	10 0b		bpl $3a30b8	                BPL abs_Y                   ; If DX < 0 {
.3a30ad	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DX := -DX
.3a30b0	1a		inc a		                INC A
.3a30b1	85 69		sta $0869	                STA DX
.3a30b3	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SX := -1
.3a30b6	85 dd		sta $08dd	                STA SX                      ; }
.3a30b8	a9 01 00	lda #$0001	abs_Y           LDA #1                      ; Assume SY = 1
.3a30bb	85 df		sta $08df	                STA SY
.3a30bd	38		sec		                SEC                         ; DY := ABS(Y1 - Y0)
.3a30be	a5 65		lda $0865	                LDA Y1
.3a30c0	e5 5d		sbc $085d	                SBC Y0
.3a30c2	85 6d		sta $086d	                STA DY
.3a30c4	10 0b		bpl $3a30d1	                BPL calc_ERR                ; If DY < 0 {
.3a30c6	49 ff ff	eor #$ffff	                EOR #$FFFF                  ; DY := -DY
.3a30c9	1a		inc a		                INC A
.3a30ca	85 6d		sta $086d	                STA DY
.3a30cc	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; SY := -1
.3a30cf	85 df		sta $08df	                STA SY                      ; }
.3a30d1	a5 6d		lda $086d	calc_ERR        LDA DY
.3a30d3	c9 01 00	cmp #$0001	                CMP #1                      ; Is DY = 1?
.3a30d6	d0 19		bne $3a30f1	                BNE cmp_dx                  ; No: compare to DX
.3a30d8	a5 69		lda $0869	                LDA DX
.3a30da	c9 01 00	cmp #$0001	                CMP #1                      ; Is DX = 1 too?
.3a30dd	d0 10		bne $3a30ef	                BNE cmp_dy_dx               ; No: treat normally
.3a30df	20 36 30	jsr $3a3036	            JSR PLOT
.3a30e2	a5 61		lda $0861	                LDA X1
.3a30e4	85 59		sta $0859	                STA X0
.3a30e6	a5 65		lda $0865	                LDA Y1
.3a30e8	85 5d		sta $085d	                STA Y0
.3a30ea	20 36 30	jsr $3a3036	            JSR PLOT
.3a30ed	80 5b		bra $3a314a	                BRA done
.3a30ef	a5 6d		lda $086d	cmp_dy_dx       LDA DY
.3a30f1	c5 69		cmp $0869	cmp_dx          CMP DX                      ; (DY < DX)
.3a30f3	b0 04		bcs $3a30f9	                BGE else
.3a30f5	a5 69		lda $0869	                LDA DX                      ; TRUE CASE: ERR := DX
.3a30f7	80 06		bra $3a30ff	                BRA shiftERR
.3a30f9	a5 6d		lda $086d	else            LDA DY                      ; FALSE CASE: ERR := -DY
.3a30fb	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a30fe	1a		inc a		                INC A
.3a30ff	48		pha		shiftERR        PHA
.3a3100	0a		asl a		                ASL A
.3a3101	68		pla		                PLA
.3a3102	6a		ror a		                ROR A                       ; ERR := ERR / 2
.3a3103	85 71		sta $0871	                STA ERR
.3a3105					loop
.3a3105	20 36 30	jsr $3a3036	            JSR PLOT
.3a3108	a5 59		lda $0859	                LDA X0                      ; break if X0=X1 and Y0=Y1
.3a310a	c5 61		cmp $0861	                CMP X1
.3a310c	d0 06		bne $3a3114	                BNE calc_ERR2
.3a310e	a5 5d		lda $085d	                LDA Y0
.3a3110	c5 65		cmp $0865	                CMP Y1
.3a3112	f0 36		beq $3a314a	                BEQ done
.3a3114	a5 71		lda $0871	calc_ERR2       LDA ERR                     ; ERR2 := ERR
.3a3116	85 75		sta $0875	                STA ERR2
.3a3118	a5 69		lda $0869	                LDA DX                      ; if (ERR2 > -DX) {
.3a311a	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a311d	1a		inc a		                INC A
.3a311e	c5 75		cmp $0875	                CMP ERR2
.3a3120	10 10		bpl $3a3132	                BPL check_DY
.3a3122	f0 0e		beq $3a3132	                BEQ check_DY
.3a3124	38		sec		                SEC                         ; ERR -= DY
.3a3125	a5 71		lda $0871	                LDA ERR
.3a3127	e5 6d		sbc $086d	                SBC DY
.3a3129	85 71		sta $0871	                STA ERR
.3a312b	18		clc		                CLC                         ; X0 += SX
.3a312c	a5 59		lda $0859	                LDA X0
.3a312e	65 dd		adc $08dd	                ADC SX
.3a3130	85 59		sta $0859	                STA X0                      ; }
.3a3132	a5 75		lda $0875	check_DY        LDA ERR2                    ; if (ERR2 < DY) {
.3a3134	c5 6d		cmp $086d	                CMP DY
.3a3136	10 cd		bpl $3a3105	                BPL loop
.3a3138	f0 cb		beq $3a3105	                BEQ loop
.3a313a	18		clc		                CLC                         ; ERR += DX
.3a313b	a5 71		lda $0871	                LDA ERR
.3a313d	65 69		adc $0869	                ADC DX
.3a313f	85 71		sta $0871	                STA ERR
.3a3141	18		clc		                CLC                         ; Y0 += SY
.3a3142	a5 5d		lda $085d	                LDA Y0
.3a3144	65 df		adc $08df	                ADC SY
.3a3146	85 5d		sta $085d	                STA Y0                      ; }
.3a3148	80 bb		bra $3a3105	                BRA loop                    ; }
.3a314a					done
.3a314a	60		rts		            RTS
.3a314b					S_PLOT
.3a314b	08		php		                PHP
.3a314c					locals
>0001					L_PLANE         .word ?
>0003					L_X             .word ?
>0005					L_Y             .word ?
.3a314c	c2 20		rep #$20	            REP #$20
.3a314e	3b		tsc		            TSC
.3a314f	38		sec		            SEC
.3a3150	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.3a3153	1b		tcs		            TCS
.3a3154	08		php		            PHP
.3a3155	c2 20		rep #$20	            REP #$20
.3a3157	48		pha		            PHA
.3a3158	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a315b	5b		tcd		            TCD
.3a315c	68		pla		            PLA
.3a315d	28		plp		            PLP
.3a315e	08		php		            PHP
.3a315f	e2 20		sep #$20	            SEP #$20
.3a3161	48		pha		            PHA
.3a3162	a9 00		lda #$00	            LDA #0
.3a3164	48		pha		            PHA
.3a3165	ab		plb		            PLB
.3a3166	68		pla		            PLA
.3a3167	28		plp		            PLP
.3a3168	c2 30		rep #$30	            REP #$30
.3a316a	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a316d	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a3170	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.3a3172	a9 2c 00	lda #$002c	                LDA #','
.3a3175	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3178	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a317b	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a317e	a5 23		lda $0823	                LDA ARGUMENT1
.3a3180	83 03		sta $03,s	                STA L_X                     ; Save it to X
.3a3182	a9 2c 00	lda #$002c	                LDA #','
.3a3185	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3188	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a318b	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a318e	a5 23		lda $0823	                LDA ARGUMENT1
.3a3190	83 05		sta $05,s	                STA L_Y                     ; Save it to Y
.3a3192	a9 2c 00	lda #$002c	                LDA #','
.3a3195	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3198	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a319b	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a319e	a5 23		lda $0823	                LDA ARGUMENT1
.3a31a0	85 55		sta $0855	                STA COLOR                   ; Save it to MARG1
.3a31a2	a3 03		lda $03,s	                LDA L_X                     ; Set the (X0, Y0) coordinates
.3a31a4	85 59		sta $0859	                STA X0
.3a31a6	a3 05		lda $05,s	                LDA L_Y
.3a31a8	85 5d		sta $085d	                STA Y0
.3a31aa	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.3a31ac	20 63 2e	jsr $3a2e63	            JSR BITMAP_SRAM
.3a31af	20 36 30	jsr $3a3036	            JSR PLOT
.3a31b2	c2 20		rep #$20	            REP #$20
.3a31b4	3b		tsc		            TSC
.3a31b5	18		clc		            CLC
.3a31b6	69 06 00	adc #$0006	            ADC #SIZE(locals)
.3a31b9	1b		tcs		            TCS
.3a31ba	28		plp		                PLP
.3a31bb	60		rts		            RTS
.3a31bc					S_LINE
.3a31bc	08		php		                PHP
.3a31bd					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
.3a31bd	c2 20		rep #$20	            REP #$20
.3a31bf	3b		tsc		            TSC
.3a31c0	38		sec		            SEC
.3a31c1	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.3a31c4	1b		tcs		            TCS
.3a31c5	08		php		            PHP
.3a31c6	c2 20		rep #$20	            REP #$20
.3a31c8	48		pha		            PHA
.3a31c9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a31cc	5b		tcd		            TCD
.3a31cd	68		pla		            PLA
.3a31ce	28		plp		            PLP
.3a31cf	08		php		            PHP
.3a31d0	e2 20		sep #$20	            SEP #$20
.3a31d2	48		pha		            PHA
.3a31d3	a9 00		lda #$00	            LDA #0
.3a31d5	48		pha		            PHA
.3a31d6	ab		plb		            PLB
.3a31d7	68		pla		            PLA
.3a31d8	28		plp		            PLP
.3a31d9	c2 30		rep #$30	            REP #$30
.3a31db	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a31de	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a31e1	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.3a31e3	a9 2c 00	lda #$002c	                LDA #','
.3a31e6	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a31e9	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a31ec	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a31ef	a5 23		lda $0823	                LDA ARGUMENT1
.3a31f1	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.3a31f3	a9 2c 00	lda #$002c	                LDA #','
.3a31f6	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a31f9	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a31fc	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a31ff	a5 23		lda $0823	                LDA ARGUMENT1
.3a3201	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.3a3203	a9 2c 00	lda #$002c	                LDA #','
.3a3206	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3209	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a320c	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a320f	a5 23		lda $0823	                LDA ARGUMENT1
.3a3211	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.3a3213	a9 2c 00	lda #$002c	                LDA #','
.3a3216	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3219	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a321c	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a321f	a5 23		lda $0823	                LDA ARGUMENT1
.3a3221	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.3a3223	a9 2c 00	lda #$002c	                LDA #','
.3a3226	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3229	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a322c	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a322f	a5 23		lda $0823	                LDA ARGUMENT1
.3a3231	85 55		sta $0855	                STA COLOR                   ; Save it to COLOR
.3a3233	a3 03		lda $03,s	                LDA L_X0                    ; Set the (X0, Y0) coordinates
.3a3235	85 59		sta $0859	                STA X0
.3a3237	a3 05		lda $05,s	                LDA L_Y0
.3a3239	85 5d		sta $085d	                STA Y0
.3a323b	a3 07		lda $07,s	                LDA L_X1                    ; Set the (X1, Y1) coordinates
.3a323d	85 61		sta $0861	                STA X1
.3a323f	a3 09		lda $09,s	                LDA L_Y1
.3a3241	85 65		sta $0865	                STA Y1
.3a3243	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.3a3245	20 63 2e	jsr $3a2e63	            JSR BITMAP_SRAM
.3a3248	20 9d 30	jsr $3a309d	            JSR LINE
.3a324b					done
.3a324b	c2 20		rep #$20	            REP #$20
.3a324d	3b		tsc		            TSC
.3a324e	18		clc		            CLC
.3a324f	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.3a3252	1b		tcs		            TCS
.3a3253	28		plp		                PLP
.3a3254	60		rts		            RTS
.3a3255					S_FILL
.3a3255	08		php		                PHP
.3a3256					locals
>0001					L_PLANE         .word ?
>0003					L_X0            .word ?
>0005					L_Y0            .word ?
>0007					L_X1            .word ?
>0009					L_Y1            .word ?
>000b					L_COLOR         .word ?
.3a3256	c2 20		rep #$20	            REP #$20
.3a3258	3b		tsc		            TSC
.3a3259	38		sec		            SEC
.3a325a	e9 0c 00	sbc #$000c	            SBC #SIZE(locals)
.3a325d	1b		tcs		            TCS
.3a325e	08		php		            PHP
.3a325f	c2 20		rep #$20	            REP #$20
.3a3261	48		pha		            PHA
.3a3262	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3265	5b		tcd		            TCD
.3a3266	68		pla		            PLA
.3a3267	28		plp		            PLP
.3a3268	08		php		            PHP
.3a3269	e2 20		sep #$20	            SEP #$20
.3a326b	48		pha		            PHA
.3a326c	a9 00		lda #$00	            LDA #0
.3a326e	48		pha		            PHA
.3a326f	ab		plb		            PLB
.3a3270	68		pla		            PLA
.3a3271	28		plp		            PLP
.3a3272	c2 30		rep #$30	            REP #$30
.3a3274	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3277	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a327a	83 01		sta $01,s	                STA L_PLANE                 ; Save it as the plane
.3a327c	a9 2c 00	lda #$002c	                LDA #','
.3a327f	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3282	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3285	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a3288	a5 23		lda $0823	                LDA ARGUMENT1
.3a328a	83 03		sta $03,s	                STA L_X0                    ; Save it to X0
.3a328c	a9 2c 00	lda #$002c	                LDA #','
.3a328f	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3292	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3295	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a3298	a5 23		lda $0823	                LDA ARGUMENT1
.3a329a	83 05		sta $05,s	                STA L_Y0                    ; Save it to Y0
.3a329c	a9 2c 00	lda #$002c	                LDA #','
.3a329f	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a32a2	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a32a5	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a32a8	a5 23		lda $0823	                LDA ARGUMENT1
.3a32aa	83 07		sta $07,s	                STA L_X1                    ; Save it to X1
.3a32ac	a9 2c 00	lda #$002c	                LDA #','
.3a32af	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a32b2	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a32b5	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a32b8	a5 23		lda $0823	                LDA ARGUMENT1
.3a32ba	83 09		sta $09,s	                STA L_Y1                    ; Save it to Y1
.3a32bc	a9 2c 00	lda #$002c	                LDA #','
.3a32bf	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a32c2	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a32c5	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a32c8	a5 23		lda $0823	                LDA ARGUMENT1
.3a32ca	83 0b		sta $0b,s	                STA L_COLOR                 ; Save it to COLOR
.3a32cc	a3 01		lda $01,s	                LDA L_PLANE                 ; Get the bitmap plane back
.3a32ce	20 a7 2e	jsr $3a2ea7	            JSR BITMAP_VRAM
.3a32d1	a9 07 00	lda #$0007	                LDA #VDMA_CTRL_Enable | VDMA_CTRL_TRF_Fill | VDMA_CTRL_1D_2D
.3a32d4	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a32d8	c2 20		rep #$20	            REP #$20
.3a32da	a3 05		lda $05,s	                LDA L_Y0                    ; Get the row
.3a32dc	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.3a32e0	af 10 f0 3a	lda $3af010	                LDA @l GR_MAX_COLS
.3a32e4	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B         ; Multiply by the number of columns in the pixmap
.3a32e8	18		clc		                CLC                         ; Add the column
.3a32e9	af 04 01 00	lda $000104	                LDA @l M0_RESULT
.3a32ed	63 03		adc $03,s	                ADC L_X0
.3a32ef	85 0c		sta $080c	                STA SCRATCH
.3a32f1	e2 20		sep #$20	            SEP #$20
.3a32f3	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.3a32f7	69 00		adc #$00	                ADC #0
.3a32f9	85 0e		sta $080e	                STA SCRATCH+2
.3a32fb	c2 20		rep #$20	            REP #$20
.3a32fd	18		clc		                CLC                         ; Set the destination address
.3a32fe	a5 9e		lda $089e	                LDA MTEMPPTR
.3a3300	65 0c		adc $080c	                ADC SCRATCH
.3a3302	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.3a3306	e2 20		sep #$20	            SEP #$20
.3a3308	a5 a0		lda $08a0	                LDA MTEMPPTR+2
.3a330a	65 0e		adc $080e	                ADC SCRATCH+2
.3a330c	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H
.3a3310	c2 20		rep #$20	            REP #$20
.3a3312	38		sec		                SEC                         ; Set the width of the FILL operation
.3a3313	a3 07		lda $07,s	                LDA L_X1
.3a3315	e3 03		sbc $03,s	                SBC L_X0
.3a3317	85 0c		sta $080c	                STA SCRATCH
.3a3319	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.3a331d	38		sec		                SEC
.3a331e	af 10 f0 3a	lda $3af010	                LDA @l GR_MAX_COLS
.3a3322	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L    ; And the destination stride
.3a3326	38		sec		                SEC                         ; Set the height of the FILL operation
.3a3327	a3 09		lda $09,s	                LDA L_Y1
.3a3329	e3 05		sbc $05,s	                SBC L_Y0
.3a332b	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.3a332f	e2 20		sep #$20	            SEP #$20
.3a3331	a3 0b		lda $0b,s	                LDA L_COLOR                 ; Set the color to write
.3a3333	8f 01 04 af	sta $af0401	                STA @l VDMA_BYTE_2_WRITE
.3a3337	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.3a333b	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF
.3a333d	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a3341	af 01 04 af	lda $af0401	wait            LDA @lVDMA_STATUS_REG       ; Wait until Vicky is done
.3a3345	30 fa		bmi $3a3341	                BMI wait
.3a3347	a9 00		lda #$00	                LDA #0                      ; Clear the control register so it can be used later
.3a3349	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a334d					done
.3a334d	c2 20		rep #$20	            REP #$20
.3a334f	3b		tsc		            TSC
.3a3350	18		clc		            CLC
.3a3351	69 0c 00	adc #$000c	            ADC #SIZE(locals)
.3a3354	1b		tcs		            TCS
.3a3355	28		plp		                PLP
.3a3356	60		rts		            RTS
.3a3357					SPADDR
.3a3357	08		php		                PHP
.3a3358	c2 20		rep #$20	            REP #$20
.3a335a	c9 40 00	cmp #$0040	                CMP #SP_MAX
.3a335d	b0 13		bcs $3a3372	                BGE error
.3a335f	0a		asl a		                ASL A                       ; Multiply it by 8 (the size of s sprite block)
.3a3360	0a		asl a		                ASL A
.3a3361	0a		asl a		                ASL A
.3a3362	18		clc		                CLC                         ; Add it to the address of the first
.3a3363	69 00 0c	adc #$0c00	                ADC #<>SP00_CONTROL_REG     ; sprite block
.3a3366	85 9e		sta $089e	                STA MTEMPPTR
.3a3368	a9 af 00	lda #$00af	                LDA #`SP00_CONTROL_REG
.3a336b	69 00 00	adc #$0000	                ADC #0
.3a336e	85 a0		sta $08a0	                STA MTEMPPTR+2              ; And save that to MTEMPPTR
.3a3370	28		plp		                PLP
.3a3371	60		rts		            RTS
.3a3372					error
.3a3372	08		php		            PHP
.3a3373	c2 20		rep #$20	            REP #$20
.3a3375	48		pha		            PHA
.3a3376	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3379	5b		tcd		            TCD
.3a337a	68		pla		            PLA
.3a337b	28		plp		            PLP
.3a337c	e2 20		sep #$20	            SEP #$20
.3a337e	a9 09		lda #$09	            LDA #ERR_RANGE
.3a3380	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3384	c2 20		rep #$20	            REP #$20
.3a3386	29 ff 00	and #$00ff	            AND #$00FF
.3a3389	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a338c	e2 20		sep #$20	            SEP #$20
.3a338e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3391					S_SPRITE
.3a3391	08		php		                PHP
.3a3392					locals
>0001					L_SPRITE        .word ?
>0003					L_LUT           .byte ?
.3a3392	c2 20		rep #$20	            REP #$20
.3a3394	3b		tsc		            TSC
.3a3395	38		sec		            SEC
.3a3396	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.3a3399	1b		tcs		            TCS
.3a339a	c2 30		rep #$30	            REP #$30
.3a339c	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a339f	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a33a2	a5 23		lda $0823	                LDA ARGUMENT1
.3a33a4	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.3a33a6	a9 2c 00	lda #$002c	                LDA #','
.3a33a9	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a33ac	e2 20		sep #$20	            SEP #$20
.3a33ae	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a33b1	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a33b4	a5 23		lda $0823	                LDA ARGUMENT1
.3a33b6	c9 08		cmp #$08	                CMP #GR_MAX_LUT             ; Check that it's in range
.3a33b8	b0 56		bcs $3a3410	                BGE error                   ; If not: throw an error
.3a33ba	83 03		sta $03,s	                STA L_LUT                   ; Save it as lut
.3a33bc	a9 2c		lda #$2c	                LDA #','
.3a33be	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a33c1	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a33c4	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a33c7	c2 20		rep #$20	            REP #$20
.3a33c9	38		sec		                SEC                         ; Adjust address to be in Vicky's space
.3a33ca	a5 23		lda $0823	                LDA ARGUMENT1
.3a33cc	e9 00 00	sbc #$0000	                SBC #<>VRAM
.3a33cf	85 23		sta $0823	                STA ARGUMENT1
.3a33d1	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a33d3	e9 b0 00	sbc #$00b0	                SBC #`VRAM
.3a33d6	85 25		sta $0825	                STA ARGUMENT1+2
.3a33d8	30 36		bmi $3a3410	                BMI error                   ; If negative, throw an error
.3a33da	c2 20		rep #$20	            REP #$20
.3a33dc	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.3a33de	aa		tax		                TAX
.3a33df	20 57 33	jsr $3a3357	            JSR SPADDR
.3a33e2	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the lower word of the address
.3a33e4	a0 01 00	ldy #$0001	                LDY #SP_ADDR
.3a33e7	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a33e9	e2 20		sep #$20	            SEP #$20
.3a33eb	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a33ed	c8		iny		                INY
.3a33ee	c8		iny		                INY
.3a33ef	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save the upper byte of the address
.3a33f1	bf 18 f0 3a	lda $3af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the sprite control register
.3a33f5	29 f1		and #$f1	                AND #%11110001              ; Filter off the current LUT
.3a33f7	85 0c		sta $080c	                STA SCRATCH
.3a33f9	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT back
.3a33fb	0a		asl a		                ASL A                       ; Sift it into the LUT position
.3a33fc	29 0e		and #$0e	                AND #%00001110              ; Make sure we don't have anything wrong there
.3a33fe	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with what's in the sprite's control
.3a3400	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the register's bits
.3a3402	9f 18 f0 3a	sta $3af018,x	                STA @l GS_SP_CONTROL,X      ; And the shadow register
.3a3406					done
.3a3406	c2 20		rep #$20	            REP #$20
.3a3408	3b		tsc		            TSC
.3a3409	18		clc		            CLC
.3a340a	69 03 00	adc #$0003	            ADC #SIZE(locals)
.3a340d	1b		tcs		            TCS
.3a340e	28		plp		                PLP
.3a340f	60		rts		            RTS
.3a3410					error
.3a3410	08		php		            PHP
.3a3411	c2 20		rep #$20	            REP #$20
.3a3413	48		pha		            PHA
.3a3414	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3417	5b		tcd		            TCD
.3a3418	68		pla		            PLA
.3a3419	28		plp		            PLP
.3a341a	e2 20		sep #$20	            SEP #$20
.3a341c	a9 09		lda #$09	            LDA #ERR_RANGE
.3a341e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3422	c2 20		rep #$20	            REP #$20
.3a3424	29 ff 00	and #$00ff	            AND #$00FF
.3a3427	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a342a	e2 20		sep #$20	            SEP #$20
.3a342c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a342f					S_SPRITEAT
.3a342f	08		php		                PHP
.3a3430					locals
>0001					L_SPRITE        .word ?
>0003					L_X             .word ?
.3a3430	c2 20		rep #$20	            REP #$20
.3a3432	3b		tsc		            TSC
.3a3433	38		sec		            SEC
.3a3434	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.3a3437	1b		tcs		            TCS
.3a3438	c2 30		rep #$30	            REP #$30
.3a343a	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a343d	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a3440	a5 23		lda $0823	                LDA ARGUMENT1
.3a3442	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.3a3444	a9 2c 00	lda #$002c	                LDA #','
.3a3447	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a344a	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a344d	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a3450	a5 23		lda $0823	                LDA ARGUMENT1
.3a3452	83 03		sta $03,s	                STA L_X                     ; Save it as X
.3a3454	a9 2c 00	lda #$002c	                LDA #','
.3a3457	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a345a	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a345d	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a3460	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.3a3462	20 57 33	jsr $3a3357	            JSR SPADDR
.3a3465	a3 03		lda $03,s	                LDA L_X                     ; Get the X coordinate
.3a3467	a0 04 00	ldy #$0004	                LDY #SP_X_COORD             ; Save the X coordinate for the sprite
.3a346a	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a346c	a5 23		lda $0823	                LDA ARGUMENT1
.3a346e	a0 06 00	ldy #$0006	                LDY #SP_Y_COORD             ; Save the Y coordinate for the sprite
.3a3471	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a3473					done
.3a3473	c2 20		rep #$20	            REP #$20
.3a3475	3b		tsc		            TSC
.3a3476	18		clc		            CLC
.3a3477	69 04 00	adc #$0004	            ADC #SIZE(locals)
.3a347a	1b		tcs		            TCS
.3a347b	28		plp		                PLP
.3a347c	60		rts		            RTS
.3a347d					S_SPRITESHOW
.3a347d	08		php		                PHP
.3a347e					locals
>0001					L_SPRITE        .word ?
>0003					L_VISIBLE       .byte ?
.3a347e	c2 20		rep #$20	            REP #$20
.3a3480	3b		tsc		            TSC
.3a3481	38		sec		            SEC
.3a3482	e9 03 00	sbc #$0003	            SBC #SIZE(locals)
.3a3485	1b		tcs		            TCS
.3a3486	c2 30		rep #$30	            REP #$30
.3a3488	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a348b	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a348e	a5 23		lda $0823	                LDA ARGUMENT1
.3a3490	83 01		sta $01,s	                STA L_SPRITE                ; Save it as sprite
.3a3492	a9 2c 00	lda #$002c	                LDA #','
.3a3495	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3498	e2 20		sep #$20	            SEP #$20
.3a349a	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a349d	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a34a0	a5 23		lda $0823	                LDA ARGUMENT1
.3a34a2	d0 04		bne $3a34a8	                BNE is_visible
.3a34a4	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 0 (not visible)
.3a34a6	80 04		bra $3a34ac	                BRA chk_layer
.3a34a8	a9 01		lda #$01	is_visible      LDA #1
.3a34aa	83 03		sta $03,s	                STA L_VISIBLE               ; Set visible := 1 (visible)
.3a34ac	a9 2c		lda #$2c	chk_layer       LDA #','
.3a34ae	85 37		sta $0837	                STA TARGETTOK
.3a34b0	20 5c 22	jsr $3a225c	            JSR OPT_TOK
.3a34b3	b0 20		bcs $3a34d5	                BCS get_layer               ; Yes: get the layer
.3a34b5					no_layer
.3a34b5	c2 30		rep #$30	            REP #$30
.3a34b7	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.3a34b9	aa		tax		                TAX
.3a34ba	20 57 33	jsr $3a3357	            JSR SPADDR
.3a34bd	e2 20		sep #$20	            SEP #$20
.3a34bf	bf 18 f0 3a	lda $3af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.3a34c3	29 fe		and #$fe	                AND #$FE                    ; Filter out the enable bit
.3a34c5	85 0c		sta $080c	                STA SCRATCH
.3a34c7	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.3a34c9	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.3a34cb	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.3a34cd	9f 18 f0 3a	sta $3af018,x	                STA @l GS_SP_CONTROL,X      ; And save it
.3a34d1	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; ... and to Vicky
.3a34d3	80 36		bra $3a350b	                BRA done
.3a34d5					get_layer
.3a34d5	c2 30		rep #$30	            REP #$30
.3a34d7	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a34da	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a34dd	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a34e0	a5 23		lda $0823	                LDA ARGUMENT1
.3a34e2	c9 08 00	cmp #$0008	                CMP #8                      ; Make sure it's in range
.3a34e5	b0 2e		bcs $3a3515	                BGE error                   ; If not, throw an out of range error
.3a34e7	0a		asl a		                ASL A                       ; If it's ok... shift it into position
.3a34e8	0a		asl a		                ASL A
.3a34e9	0a		asl a		                ASL A
.3a34ea	0a		asl a		                ASL A
.3a34eb	85 0c		sta $080c	                STA SCRATCH                 ; And save it in SCRATCH
.3a34ed	a3 01		lda $01,s	                LDA L_SPRITE                ; Get the sprite number back
.3a34ef	aa		tax		                TAX
.3a34f0	20 57 33	jsr $3a3357	            JSR SPADDR
.3a34f3	e2 20		sep #$20	            SEP #$20
.3a34f5	a3 03		lda $03,s	                LDA L_VISIBLE               ; Get the visible byte
.3a34f7	29 01		and #$01	                AND #$01                    ; Make sure it's just the bit
.3a34f9	05 0c		ora $080c	                ORA SCRATCH                 ; Combine it with the current values
.3a34fb	85 0c		sta $080c	                STA SCRATCH
.3a34fd	bf 18 f0 3a	lda $3af018,x	                LDA @l GS_SP_CONTROL,X      ; Get the current control register value
.3a3501	29 8e		and #$8e	                AND #%10001110              ; Filter out the enable and layer bits
.3a3503	05 0c		ora $080c	                ORA SCRATCH                 ; Combine with the provided layer and enable
.3a3505	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And set the bits in Vicky
.3a3507	9f 18 f0 3a	sta $3af018,x	                STA @l GS_SP_CONTROL,X      ; And to the shadow registers
.3a350b					done
.3a350b	c2 20		rep #$20	            REP #$20
.3a350d	3b		tsc		            TSC
.3a350e	18		clc		            CLC
.3a350f	69 03 00	adc #$0003	            ADC #SIZE(locals)
.3a3512	1b		tcs		            TCS
.3a3513	28		plp		                PLP
.3a3514	60		rts		            RTS
.3a3515					error
.3a3515	08		php		            PHP
.3a3516	c2 20		rep #$20	            REP #$20
.3a3518	48		pha		            PHA
.3a3519	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a351c	5b		tcd		            TCD
.3a351d	68		pla		            PLA
.3a351e	28		plp		            PLP
.3a351f	e2 20		sep #$20	            SEP #$20
.3a3521	a9 09		lda #$09	            LDA #ERR_RANGE
.3a3523	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3527	c2 20		rep #$20	            REP #$20
.3a3529	29 ff 00	and #$00ff	            AND #$00FF
.3a352c	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a352f	e2 20		sep #$20	            SEP #$20
.3a3531	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3534					TILESET_ADDR
.3a3534	08		php		                PHP
.3a3535	c2 20		rep #$20	            REP #$20
.3a3537	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.3a353a	b0 19		bcs $3a3555	                BGE out_of_range            ; If not, throw a range error
.3a353c	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.3a353f	a9 04 00	lda #$0004	                LDA #TILESET_REG_SIZE       ; Multiply it by the number of bytes in a tile set register set
.3a3542	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.3a3545	18		clc		                CLC                         ; Add to TILESET0_ADDY_L to get the final address
.3a3546	ad 04 01	lda $0104	                LDA @w M0_RESULT
.3a3549	69 80 02	adc #$0280	                ADC #<>TILESET0_ADDY_L
.3a354c	85 9e		sta $089e	                STA MTEMPPTR
.3a354e	a9 af 00	lda #$00af	                LDA #`TILESET0_ADDY_L
.3a3551	85 a0		sta $08a0	                STA MTEMPPTR+2
.3a3553	28		plp		                PLP
.3a3554	60		rts		            RTS
.3a3555					out_of_range
.3a3555	08		php		            PHP
.3a3556	c2 20		rep #$20	            REP #$20
.3a3558	48		pha		            PHA
.3a3559	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a355c	5b		tcd		            TCD
.3a355d	68		pla		            PLA
.3a355e	28		plp		            PLP
.3a355f	e2 20		sep #$20	            SEP #$20
.3a3561	a9 09		lda #$09	            LDA #ERR_RANGE
.3a3563	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3567	c2 20		rep #$20	            REP #$20
.3a3569	29 ff 00	and #$00ff	            AND #$00FF
.3a356c	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a356f	e2 20		sep #$20	            SEP #$20
.3a3571	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3574					TILEMAP_ADDR
.3a3574	08		php		                PHP
.3a3575	c2 20		rep #$20	            REP #$20
.3a3577	c9 04 00	cmp #$0004	                CMP #4                      ; Make sure it's 0 - 4
.3a357a	b0 19		bcs $3a3595	                BGE out_of_range            ; If not, throw a range error
.3a357c	8d 00 01	sta $0100	                STA @w M0_OPERAND_A
.3a357f	a9 0c 00	lda #$000c	                LDA #TILEMAP_REG_SIZE       ; Multiply it by the number of bytes in a tile map register set
.3a3582	8d 02 01	sta $0102	                STA @w M0_OPERAND_B
.3a3585	18		clc		                CLC
.3a3586	ad 04 01	lda $0104	                LDA @w M0_RESULT            ; Add to TL0_CONTROL_REG to get the final address
.3a3589	69 00 02	adc #$0200	                ADC #<>TL0_CONTROL_REG
.3a358c	85 9e		sta $089e	                STA MTEMPPTR
.3a358e	a9 af 00	lda #$00af	                LDA #`TL0_CONTROL_REG
.3a3591	85 a0		sta $08a0	                STA MTEMPPTR+2
.3a3593	28		plp		                PLP
.3a3594	60		rts		            RTS
.3a3595					out_of_range
.3a3595	08		php		            PHP
.3a3596	c2 20		rep #$20	            REP #$20
.3a3598	48		pha		            PHA
.3a3599	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a359c	5b		tcd		            TCD
.3a359d	68		pla		            PLA
.3a359e	28		plp		            PLP
.3a359f	e2 20		sep #$20	            SEP #$20
.3a35a1	a9 09		lda #$09	            LDA #ERR_RANGE
.3a35a3	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a35a7	c2 20		rep #$20	            REP #$20
.3a35a9	29 ff 00	and #$00ff	            AND #$00FF
.3a35ac	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a35af	e2 20		sep #$20	            SEP #$20
.3a35b1	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a35b4					S_TILESET
.3a35b4	08		php		                PHP
.3a35b5					locals
>0001					L_TILENUM       .word ?
>0003					L_LUT           .word ?
>0005					L_IS_SQUARE     .word ?
.3a35b5	c2 20		rep #$20	            REP #$20
.3a35b7	3b		tsc		            TSC
.3a35b8	38		sec		            SEC
.3a35b9	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.3a35bc	1b		tcs		            TCS
.3a35bd	c2 20		rep #$20	            REP #$20
.3a35bf	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a35c2	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a35c5	a5 23		lda $0823	                LDA ARGUMENT1
.3a35c7	83 01		sta $01,s	                STA L_TILENUM               ; Save it as the tile set/map number
.3a35c9	a9 2c 00	lda #$002c	                LDA #','
.3a35cc	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a35cf	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a35d2	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a35d5	a5 23		lda $0823	                LDA ARGUMENT1
.3a35d7	83 03		sta $03,s	                STA L_LUT                   ; Save it as LUT
.3a35d9	a9 2c 00	lda #$002c	                LDA #','
.3a35dc	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a35df	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a35e2	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a35e5	a5 23		lda $0823	                LDA ARGUMENT1
.3a35e7	83 05		sta $05,s	                STA L_IS_SQUARE             ; Save it as IS_SQUARE
.3a35e9	a9 2c 00	lda #$002c	                LDA #','
.3a35ec	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a35ef	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a35f2	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a35f5	a3 01		lda $01,s	                LDA L_TILENUM
.3a35f7	20 34 35	jsr $3a3534	            JSR TILESET_ADDR
.3a35fa	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the bitmap address - the address of the start of VRAM
.3a35fc	87 9e		sta [$089e]	                STA [MTEMPPTR]              ; And save it to the registers
.3a35fe	e2 20		sep #$20	            SEP #$20
.3a3600	38		sec		                SEC
.3a3601	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a3603	e9 b0		sbc #$b0	                SBC #`VRAM
.3a3605	a0 02 00	ldy #$0002	                LDY #TILESET_ADDY_H
.3a3608	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a360a	a3 05		lda $05,s	                LDA L_IS_SQUARE             ; Check if is_square == 0?
.3a360c	d0 0d		bne $3a361b	                BNE is_square
.3a360e					not_square
.3a360e	e2 20		sep #$20	            SEP #$20
.3a3610	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.3a3612	29 07		and #$07	                AND #$07                    ; Force it to be in range
.3a3614	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.3a3617	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.3a3619	80 0d		bra $3a3628	                BRA done
.3a361b					is_square
.3a361b	e2 20		sep #$20	            SEP #$20
.3a361d	a3 03		lda $03,s	                LDA L_LUT                   ; Get the LUT
.3a361f	29 07		and #$07	                AND #$07                    ; Force it to be in range
.3a3621	09 08		ora #$08	                ORA #TILESET_SQUARE_256     ; Turn on the 256x256 flag
.3a3623	a0 03 00	ldy #$0003	                LDY #TILESET_ADDY_CFG
.3a3626	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; Save it to the registers
.3a3628					done
.3a3628	c2 20		rep #$20	            REP #$20
.3a362a	3b		tsc		            TSC
.3a362b	18		clc		            CLC
.3a362c	69 06 00	adc #$0006	            ADC #SIZE(locals)
.3a362f	1b		tcs		            TCS
.3a3630	28		plp		                PLP
.3a3631	60		rts		            RTS
.3a3632					S_TILEMAP
.3a3632	08		php		                PHP
.3a3633					locals
>0001					L_TILENUM       .word ?
>0003					L_WIDTH         .word ?
>0005					L_HEIGHT        .word ?
.3a3633	c2 20		rep #$20	            REP #$20
.3a3635	3b		tsc		            TSC
.3a3636	38		sec		            SEC
.3a3637	e9 06 00	sbc #$0006	            SBC #SIZE(locals)
.3a363a	1b		tcs		            TCS
.3a363b	c2 20		rep #$20	            REP #$20
.3a363d	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3640	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a3643	a5 23		lda $0823	                LDA ARGUMENT1
.3a3645	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.3a3647	a9 2c 00	lda #$002c	                LDA #','
.3a364a	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a364d	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3650	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a3653	a5 23		lda $0823	                LDA ARGUMENT1
.3a3655	83 03		sta $03,s	                STA L_WIDTH                 ; Save it as WIDTH
.3a3657	a9 2c 00	lda #$002c	                LDA #','
.3a365a	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a365d	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3660	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a3663	a5 23		lda $0823	                LDA ARGUMENT1
.3a3665	83 05		sta $05,s	                STA L_HEIGHT                ; Save it as HEIGHT
.3a3667	a9 2c 00	lda #$002c	                LDA #','
.3a366a	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a366d	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3670	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a3673	a3 01		lda $01,s	                LDA L_TILENUM
.3a3675	20 74 35	jsr $3a3574	            JSR TILEMAP_ADDR
.3a3678	a5 23		lda $0823	                LDA ARGUMENT1               ; Get the map address - the address of the start of VRAM
.3a367a	a0 01 00	ldy #$0001	                LDY #TILEMAP_START_ADDY
.3a367d	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y            ; And save it to the registers
.3a367f	e2 20		sep #$20	            SEP #$20
.3a3681	38		sec		                SEC
.3a3682	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a3684	e9 b0		sbc #$b0	                SBC #`VRAM
.3a3686	c8		iny		                INY
.3a3687	c8		iny		                INY
.3a3688	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a368a	c2 20		rep #$20	            REP #$20
.3a368c	a3 03		lda $03,s	                LDA L_WIDTH                 ; Set the width
.3a368e	a0 04 00	ldy #$0004	                LDY #TILEMAP_TOTAL_X
.3a3691	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a3693	a3 05		lda $05,s	                LDA L_HEIGHT                ; Set the height
.3a3695	a0 06 00	ldy #$0006	                LDY #TILEMAP_TOTAL_Y
.3a3698	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a369a					done
.3a369a	c2 20		rep #$20	            REP #$20
.3a369c	3b		tsc		            TSC
.3a369d	18		clc		            CLC
.3a369e	69 06 00	adc #$0006	            ADC #SIZE(locals)
.3a36a1	1b		tcs		            TCS
.3a36a2	28		plp		                PLP
.3a36a3	60		rts		            RTS
.3a36a4					S_TILESHOW
.3a36a4	08		php		                PHP
.3a36a5					locals
>0001					L_TILENUM       .word ?
.3a36a5	c2 20		rep #$20	            REP #$20
.3a36a7	f4 00 00	pea #$0000	            PEA #0
.3a36aa	c2 20		rep #$20	            REP #$20
.3a36ac	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a36af	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a36b2	a5 23		lda $0823	                LDA ARGUMENT1
.3a36b4	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.3a36b6	a9 2c 00	lda #$002c	                LDA #','
.3a36b9	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a36bc	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a36bf	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a36c2	a3 01		lda $01,s	                LDA L_TILENUM
.3a36c4	20 74 35	jsr $3a3574	            JSR TILEMAP_ADDR
.3a36c7	a5 23		lda $0823	                LDA ARGUMENT1               ; CHeck the visible parameter
.3a36c9	d0 06		bne $3a36d1	                BNE is_visible              ; If it's <> 0, make it visible
.3a36cb	e2 20		sep #$20	            SEP #$20
.3a36cd	a9 00		lda #$00	                LDA #0                      ; Control value for invisible
.3a36cf	80 04		bra $3a36d5	                BRA set_control
.3a36d1					is_visible
.3a36d1	e2 20		sep #$20	            SEP #$20
.3a36d3	a9 01		lda #$01	                LDA #TILEMAP_VISIBLE        ; Control value for visible
.3a36d5					set_control
.3a36d5	e2 20		sep #$20	            SEP #$20
.3a36d7	a0 00 00	ldy #$0000	                LDY #TILEMAP_CONTROL        ; Set the control register
.3a36da	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a36dc					done
.3a36dc	c2 20		rep #$20	            REP #$20
.3a36de	68		pla		            PLA
.3a36df	28		plp		                PLP
.3a36e0	60		rts		            RTS
.3a36e1					S_TILEAT
.3a36e1	08		php		                PHP
.3a36e2					locals
>0001					L_TILENUM       .word ?
>0003					L_X             .word ?
.3a36e2	c2 20		rep #$20	            REP #$20
.3a36e4	3b		tsc		            TSC
.3a36e5	38		sec		            SEC
.3a36e6	e9 04 00	sbc #$0004	            SBC #SIZE(locals)
.3a36e9	1b		tcs		            TCS
.3a36ea	c2 20		rep #$20	            REP #$20
.3a36ec	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a36ef	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a36f2	a5 23		lda $0823	                LDA ARGUMENT1
.3a36f4	83 01		sta $01,s	                STA L_TILENUM               ; Save as TILENUM
.3a36f6	a9 2c 00	lda #$002c	                LDA #','
.3a36f9	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a36fc	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a36ff	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a3702	a5 23		lda $0823	                LDA ARGUMENT1
.3a3704	83 03		sta $03,s	                STA L_X                     ; Save as X
.3a3706	a9 2c 00	lda #$002c	                LDA #','
.3a3709	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a370c	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a370f	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a3712	a3 01		lda $01,s	                LDA L_TILENUM
.3a3714	20 74 35	jsr $3a3574	            JSR TILEMAP_ADDR
.3a3717	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the Y position
.3a3719	a0 0a 00	ldy #$000a	                LDY #TILEMAP_WINDOW_Y
.3a371c	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a371e	a3 03		lda $03,s	                LDA L_X                     ; Set the X position
.3a3720	a0 08 00	ldy #$0008	                LDY #TILEMAP_WINDOW_X
.3a3723	97 9e		sta [$089e],y	                STA [MTEMPPTR],Y
.3a3725					done
.3a3725	c2 20		rep #$20	            REP #$20
.3a3727	3b		tsc		            TSC
.3a3728	18		clc		            CLC
.3a3729	69 04 00	adc #$0004	            ADC #SIZE(locals)
.3a372c	1b		tcs		            TCS
.3a372d	28		plp		                PLP
.3a372e	60		rts		            RTS
=0					DMA_LINEAR = 0                              ; Memory to copy is a continguous, linear range
=1					DMA_RECT = 1                                ; Memory to copy is a rectangular block
.0000					DMA_BLOCK
>0000					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>0001					ADDR            .long ?                     ; The starting address for the data to transfer
>0004					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>0007					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>0009					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>000b					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
=$01					DMA_SRC_2D = $01                            ; Source transfer should be 2D
=$02					DMA_DST_2D = $02                            ; Destination transfer should be 2D
=$10					DMA_SRC_SRAM = $10                          ; Flag indicating that the source is in SRAM ($00:0000 - $3F:FFFF)
=$20					DMA_DST_SRAM = $20                          ; Flag indicating that the destination is in SRAM ($00:0000 - $3F:FFFF)
>3af058					DMA_BLOCKS      .byte ?                     ; What blocks are involved
.3af059					DMA_SRC
>3af059					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>3af05a					ADDR            .long ?                     ; The starting address for the data to transfer
>3af05d					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>3af060					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>3af062					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>3af064					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.3af066					DMA_DEST
>3af066					MODE            .byte ?                     ; The type of transfer: 0 = LINEAR, 1 = RECTANGULAR
>3af067					ADDR            .long ?                     ; The starting address for the data to transfer
>3af06a					SIZE            .long ?                     ; The number of bytes to transfer (for LINEAR sources)
>3af06d					WIDTH           .word ?                     ; The width of the rectangle to copy (for RECTANGULAR)
>3af06f					HEIGHT          .word ?                     ; The height of the rectangle to copy (for RECTANGULAR sources)
>3af071					STRIDE          .word ?                     ; The number of bytes to skip to get to the next line (for RECTANGULAR)
.3a372f					DO_DMA
.3a372f	0b		phd		                PHD
.3a3730	08		php		                PHP
.3a3731	08		php		            PHP
.3a3732	c2 20		rep #$20	            REP #$20
.3a3734	48		pha		            PHA
.3a3735	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a3738	5b		tcd		            TCD
.3a3739	68		pla		            PLA
.3a373a	28		plp		            PLP
.3a373b	e2 20		sep #$20	            SEP #$20
.3a373d	a9 00		lda #$00	                LDA #0
.3a373f	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS           ; Set mode to something neutral
.3a3743	af 5c f0 3a	lda $3af05c	                LDA @l DMA_SRC.ADDR+2       ; Check the bank
.3a3747	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.3a3749	b0 1c		bcs $3a3767	                BGE src_vram                ; Yes: leave the DMA_BLOCK bit alone
.3a374b	8f 24 04 af	sta $af0424	src_sram        STA @l SDMA_SRC_ADDY_H      ; Set the SDMA source address
.3a374f	af 5b f0 3a	lda $3af05b	                LDA @l DMA_SRC.ADDR+1
.3a3753	8f 23 04 af	sta $af0423	                STA @l SDMA_SRC_ADDY_M
.3a3757	af 5a f0 3a	lda $3af05a	                LDA @l DMA_SRC.ADDR
.3a375b	8f 22 04 af	sta $af0422	                STA @l SDMA_SRC_ADDY_L
.3a375f	a9 10		lda #$10	                LDA #DMA_SRC_SRAM           ; Set the SRAM source block bit
.3a3761	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS
.3a3765	80 17		bra $3a377e	                BRA src_mode
.3a3767	38		sec		src_vram        SEC                         ; Convert to VRAM relative address
.3a3768	e9 b0		sbc #$b0	                SBC #`VRAM
.3a376a	8f 04 04 af	sta $af0404	                STA @l VDMA_SRC_ADDY_H      ; Set the VDMA source address
.3a376e	af 5b f0 3a	lda $3af05b	                LDA @l DMA_SRC.ADDR+1
.3a3772	8f 03 04 af	sta $af0403	                STA @l VDMA_SRC_ADDY_M
.3a3776	af 5a f0 3a	lda $3af05a	                LDA @l DMA_SRC.ADDR
.3a377a	8f 02 04 af	sta $af0402	                STA @l VDMA_SRC_ADDY_L
.3a377e	af 59 f0 3a	lda $3af059	src_mode        LDA @l DMA_SRC.MODE         ; Determine if source is 1D or 2D
.3a3782	d0 3c		bne $3a37c0	                BNE src_2d
.3a3784	af 58 f0 3a	lda $3af058	src_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.3a3788	f0 1b		beq $3a37a5	                BEQ src_1d_vram
.3a378a	af 5d f0 3a	lda $3af05d	src_1d_sram     LDA @l DMA_SRC.SIZE         ; It's SRAM, so set the SDMA size
.3a378e	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.3a3792	af 5e f0 3a	lda $3af05e	                LDA @l DMA_SRC.SIZE+1
.3a3796	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_M
.3a379a	af 5f f0 3a	lda $3af05f	                LDA @l DMA_SRC.SIZE+2
.3a379e	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.3a37a2	82 8b 00	brl $3a3830	                BRL set_dst                 ; Go to set up the destination
.3a37a5	af 5d f0 3a	lda $3af05d	src_1d_vram     LDA @l DMA_SRC.SIZE         ; It's VRAM, so set the VDMA size
.3a37a9	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.3a37ad	af 5e f0 3a	lda $3af05e	                LDA @l DMA_SRC.SIZE+1
.3a37b1	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_M
.3a37b5	af 5f f0 3a	lda $3af05f	                LDA @l DMA_SRC.SIZE+2
.3a37b9	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.3a37bd	82 70 00	brl $3a3830	                BRL set_dst                 ; Go to set up the destination
.3a37c0	af 58 f0 3a	lda $3af058	src_2d          LDA @l DMA_BLOCKS
.3a37c4	09 01		ora #$01	                ORA #DMA_SRC_2D             ; Set the bit to make the source a 2D transfer
.3a37c6	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS
.3a37ca	89 10		bit #$10	                BIT #DMA_SRC_SRAM           ; Are we writing to SRAM
.3a37cc	f0 32		beq $3a3800	                BEQ src_2d_vram             ; No: set the 2d values in the VRAM source
.3a37ce	af 60 f0 3a	lda $3af060	src_2d_sram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.3a37d2	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.3a37d6	af 61 f0 3a	lda $3af061	                LDA @l DMA_SRC.WIDTH+1
.3a37da	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.3a37de	af 62 f0 3a	lda $3af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.3a37e2	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.3a37e6	af 63 f0 3a	lda $3af063	                LDA @l DMA_SRC.HEIGHT+1
.3a37ea	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.3a37ee	af 64 f0 3a	lda $3af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.3a37f2	8f 2c 04 af	sta $af042c	                STA @l SDMA_SRC_STRIDE_L
.3a37f6	af 65 f0 3a	lda $3af065	                LDA @l DMA_SRC.STRIDE+1
.3a37fa	8f 2d 04 af	sta $af042d	                STA @l SDMA_SRC_STRIDE_L+1
.3a37fe	80 30		bra $3a3830	                BRA set_dst
.3a3800	af 60 f0 3a	lda $3af060	src_2d_vram     LDA @l DMA_SRC.WIDTH        ; Set the source width
.3a3804	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.3a3808	af 61 f0 3a	lda $3af061	                LDA @l DMA_SRC.WIDTH+1
.3a380c	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.3a3810	af 62 f0 3a	lda $3af062	                LDA @l DMA_SRC.HEIGHT       ; Set the source height
.3a3814	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.3a3818	af 63 f0 3a	lda $3af063	                LDA @l DMA_SRC.HEIGHT+1
.3a381c	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.3a3820	af 64 f0 3a	lda $3af064	                LDA @l DMA_SRC.STRIDE       ; Set the source stride
.3a3824	8f 0c 04 af	sta $af040c	                STA @l VDMA_SRC_STRIDE_L
.3a3828	af 65 f0 3a	lda $3af065	                LDA @l DMA_SRC.STRIDE+1
.3a382c	8f 0d 04 af	sta $af040d	                STA @l VDMA_SRC_STRIDE_L+1
.3a3830					set_dst
.3a3830	e2 20		sep #$20	            SEP #$20
.3a3832	af 69 f0 3a	lda $3af069	                LDA @l DMA_DEST.ADDR+2      ; Check the bank
.3a3836	c9 b0		cmp #$b0	                CMP #`VRAM                  ; Is it in VRAM?
.3a3838	b0 20		bcs $3a385a	                BGE dst_vram                ; Yes: leave the DMA_BLOCK bit alone
.3a383a	8f 27 04 af	sta $af0427	dst_sram        STA @l SDMA_DST_ADDY_H      ; Set the SDMA destination address
.3a383e	af 68 f0 3a	lda $3af068	                LDA @l DMA_DEST.ADDR+1
.3a3842	8f 26 04 af	sta $af0426	                STA @l SDMA_DST_ADDY_M
.3a3846	af 67 f0 3a	lda $3af067	                LDA @l DMA_DEST.ADDR
.3a384a	8f 25 04 af	sta $af0425	                STA @l SDMA_DST_ADDY_L
.3a384e	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS
.3a3852	09 20		ora #$20	                ORA #DMA_DST_SRAM           ; Set the bit to indicate the destination is SRAM
.3a3854	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS
.3a3858	80 17		bra $3a3871	                BRA dst_mode
.3a385a	38		sec		dst_vram        SEC                         ; Convert to VRAM relative address
.3a385b	e9 b0		sbc #$b0	                SBC #`VRAM
.3a385d	8f 07 04 af	sta $af0407	                STA @l VDMA_DST_ADDY_H      ; Set the VDMA destination address
.3a3861	af 68 f0 3a	lda $3af068	                LDA @l DMA_DEST.ADDR+1
.3a3865	8f 06 04 af	sta $af0406	                STA @l VDMA_DST_ADDY_M
.3a3869	af 67 f0 3a	lda $3af067	                LDA @l DMA_DEST.ADDR
.3a386d	8f 05 04 af	sta $af0405	                STA @l VDMA_DST_ADDY_L
.3a3871	af 66 f0 3a	lda $3af066	dst_mode        LDA @l DMA_DEST.MODE
.3a3875	d0 3e		bne $3a38b5	                BNE dst_2d                  ; If 2D, set up the 2D destination parameters
.3a3877	af 58 f0 3a	lda $3af058	dst_1d          LDA @l DMA_BLOCKS           ; Check if the source is SRAM or VRAM
.3a387b	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Is the destination SRAM?
.3a387d	f0 1b		beq $3a389a	                BEQ dst_1d_vram
.3a387f	af 6a f0 3a	lda $3af06a	dst_1d_sram     LDA @l DMA_DEST.SIZE
.3a3883	8f 28 04 af	sta $af0428	                STA @l SDMA_SIZE_L
.3a3887	af 6b f0 3a	lda $3af06b	                LDA @l DMA_DEST.SIZE+1
.3a388b	8f 29 04 af	sta $af0429	                STA @l SDMA_SIZE_L+1
.3a388f	af 6c f0 3a	lda $3af06c	                LDA @l DMA_DEST.SIZE+2
.3a3893	8f 2a 04 af	sta $af042a	                STA @l SDMA_SIZE_H
.3a3897	82 8b 00	brl $3a3925	                BRL start_xfer
.3a389a	af 6a f0 3a	lda $3af06a	dst_1d_vram     LDA @l DMA_DEST.SIZE
.3a389e	8f 08 04 af	sta $af0408	                STA @l VDMA_SIZE_L
.3a38a2	af 6b f0 3a	lda $3af06b	                LDA @l DMA_DEST.SIZE+1
.3a38a6	8f 09 04 af	sta $af0409	                STA @l VDMA_SIZE_L+1
.3a38aa	af 6c f0 3a	lda $3af06c	                LDA @l DMA_DEST.SIZE+2
.3a38ae	8f 0a 04 af	sta $af040a	                STA @l VDMA_SIZE_H
.3a38b2	82 70 00	brl $3a3925	                BRL start_xfer
.3a38b5	af 58 f0 3a	lda $3af058	dst_2d          LDA @l DMA_BLOCKS
.3a38b9	09 02		ora #$02	                ORA #DMA_DST_2D             ; Set the bit to make the source a 2D transfer
.3a38bb	8f 58 f0 3a	sta $3af058	                STA @l DMA_BLOCKS
.3a38bf	89 20		bit #$20	                BIT #DMA_DST_SRAM           ; Are we writing to the SRAM?
.3a38c1	f0 32		beq $3a38f5	                BEQ dst_2d_vram             ; No: set the 2D parameters for VRAM
.3a38c3	af 6d f0 3a	lda $3af06d	dst_2d_sram     LDA @l DMA_DEST.WIDTH       ; Set the SRAM width
.3a38c7	8f 28 04 af	sta $af0428	                STA @l SDMA_X_SIZE_L
.3a38cb	af 6e f0 3a	lda $3af06e	                LDA @L DMA_DEST.WIDTH+1
.3a38cf	8f 29 04 af	sta $af0429	                STA @l SDMA_X_SIZE_L+1
.3a38d3	af 6f f0 3a	lda $3af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the SRAM height
.3a38d7	8f 2a 04 af	sta $af042a	                STA @l SDMA_Y_SIZE_L
.3a38db	af 70 f0 3a	lda $3af070	                LDA @L DMA_DEST.HEIGHT+1
.3a38df	8f 2b 04 af	sta $af042b	                STA @l SDMA_Y_SIZE_L+1
.3a38e3	af 71 f0 3a	lda $3af071	                LDA @l DMA_DEST.STRIDE      ; Set the SRAM stride
.3a38e7	8f 2e 04 af	sta $af042e	                STA @l SDMA_DST_STRIDE_L
.3a38eb	af 72 f0 3a	lda $3af072	                LDA @L DMA_DEST.STRIDE+1
.3a38ef	8f 2f 04 af	sta $af042f	                STA @l SDMA_DST_STRIDE_L+1
.3a38f3	80 30		bra $3a3925	                BRA start_xfer
.3a38f5	af 6d f0 3a	lda $3af06d	dst_2d_vram     LDA @l DMA_DEST.WIDTH       ; Set the VRAM width
.3a38f9	8f 08 04 af	sta $af0408	                STA @l VDMA_X_SIZE_L
.3a38fd	af 6e f0 3a	lda $3af06e	                LDA @L DMA_DEST.WIDTH+1
.3a3901	8f 09 04 af	sta $af0409	                STA @l VDMA_X_SIZE_L+1
.3a3905	af 6f f0 3a	lda $3af06f	                LDA @l DMA_DEST.HEIGHT      ; Set the VRAM height
.3a3909	8f 0a 04 af	sta $af040a	                STA @l VDMA_Y_SIZE_L
.3a390d	af 70 f0 3a	lda $3af070	                LDA @L DMA_DEST.HEIGHT+1
.3a3911	8f 0b 04 af	sta $af040b	                STA @l VDMA_Y_SIZE_L+1
.3a3915	af 71 f0 3a	lda $3af071	                LDA @l DMA_DEST.STRIDE      ; Set the VRAM stride
.3a3919	8f 0e 04 af	sta $af040e	                STA @l VDMA_DST_STRIDE_L
.3a391d	af 72 f0 3a	lda $3af072	                LDA @L DMA_DEST.STRIDE+1
.3a3921	8f 0f 04 af	sta $af040f	                STA @l VDMA_DST_STRIDE_L+1
.3a3925	af 58 f0 3a	lda $3af058	start_xfer      LDA @l DMA_BLOCKS
.3a3929	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.3a392b	f0 43		beq $3a3970	                BEQ start_vdma_only
.3a392d	c9 10		cmp #$10	                CMP #DMA_SRC_SRAM
.3a392f	f0 76		beq $3a39a7	                BEQ start_s2v
.3a3931	c9 20		cmp #$20	                CMP #DMA_DST_SRAM
.3a3933	d0 03		bne $3a3938	                BNE start_sdma_only
.3a3935	82 8a 00	brl $3a39c2	                BRL start_v2s
.3a3938					start_sdma_only
.3a3938	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.3a393c	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.3a393e	f0 23		beq $3a3963	                BEQ sdma_1d_only            ; Source and Destination 1D...
.3a3940	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.3a3942	f0 23		beq $3a3967	                BEQ sdma_2d_only            ; Source and Destination 2D
.3a3944	08		php		            PHP
.3a3945	c2 20		rep #$20	            REP #$20
.3a3947	48		pha		            PHA
.3a3948	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a394b	5b		tcd		            TCD
.3a394c	68		pla		            PLA
.3a394d	28		plp		            PLP
.3a394e	e2 20		sep #$20	            SEP #$20
.3a3950	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a3952	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3956	c2 20		rep #$20	            REP #$20
.3a3958	29 ff 00	and #$00ff	            AND #$00FF
.3a395b	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a395e	e2 20		sep #$20	            SEP #$20
.3a3960	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3963	a9 01		lda #$01	sdma_1d_only    LDA #SDMA_CTRL0_Enable      ; Set the bits for 1D, SRAM->SRAM
.3a3965	80 02		bra $3a3969	                BRA sdma_set_ctrl
.3a3967	a9 03		lda #$03	sdma_2d_only    LDA #SDMA_CTRL0_Enable | SDMA_CTRL0_1D_2D
.3a3969	8f 20 04 af	sta $af0420	sdma_set_ctrl   STA @l SDMA_CTRL_REG0
.3a396d	82 7d 00	brl $3a39ed	                BRL trig_sdma               ; And trigger the SDMA
.3a3970					start_vdma_only
.3a3970	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Check the SDMA flags
.3a3974	29 03		and #$03	                AND #DMA_SRC_2D | DMA_DST_2D
.3a3976	f0 23		beq $3a399b	                BEQ vdma_1d_only            ; Source and Destination 1D...
.3a3978	c9 03		cmp #$03	                CMP #DMA_SRC_2D | DMA_DST_2D
.3a397a	f0 23		beq $3a399f	                BEQ vdma_2d_only            ; Source and Destination 2D...
.3a397c	08		php		            PHP
.3a397d	c2 20		rep #$20	            REP #$20
.3a397f	48		pha		            PHA
.3a3980	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3983	5b		tcd		            TCD
.3a3984	68		pla		            PLA
.3a3985	28		plp		            PLP
.3a3986	e2 20		sep #$20	            SEP #$20
.3a3988	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a398a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a398e	c2 20		rep #$20	            REP #$20
.3a3990	29 ff 00	and #$00ff	            AND #$00FF
.3a3993	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a3996	e2 20		sep #$20	            SEP #$20
.3a3998	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a399b	a9 01		lda #$01	vdma_1d_only    LDA #VDMA_CTRL_Enable       ; Set the bits for 1D, VRAM->VRAM
.3a399d	80 02		bra $3a39a1	                BRA vdma_set_ctrl
.3a399f	a9 03		lda #$03	vdma_2d_only    LDA #VDMA_CTRL_Enable | VDMA_CTRL_1D_2D
.3a39a1	8f 00 04 af	sta $af0400	vdma_set_ctrl   STA @l VDMA_CONTROL_REG
.3a39a5	80 34		bra $3a39db	                BRA trig_vdma               ; And trigger the VDMA
.3a39a7					start_s2v
.3a39a7	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.3a39ab	29 01		and #$01	                AND #DMA_SRC_2D
.3a39ad	0a		asl a		                ASL A
.3a39ae	09 11		ora #$11	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Src
.3a39b0	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.3a39b4	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.3a39b8	29 02		and #$02	                AND #DMA_DST_2D
.3a39ba	09 11		ora #$11	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Src
.3a39bc	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a39c0	80 19		bra $3a39db	                BRA trig_vdma               ; And trigger the VDMA
.3a39c2					start_v2s
.3a39c2	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Set the SDMA flags
.3a39c6	29 02		and #$02	                AND #DMA_DST_2D
.3a39c8	09 21		ora #$21	                ORA #SDMA_CTRL0_Enable | SDMA_CTRL0_SysRAM_Dst
.3a39ca	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.3a39ce	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Set the VDMA flags
.3a39d2	29 01		and #$01	                AND #DMA_SRC_2D
.3a39d4	0a		asl a		                ASL A
.3a39d5	09 21		ora #$21	                ORA #VDMA_CTRL_Enable | VDMA_CTRL_SysRAM_Dst
.3a39d7	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a39db					trig_vdma
.3a39db	af 00 04 af	lda $af0400	                LDA @l VDMA_CONTROL_REG
.3a39df	09 80		ora #$80	                ORA #VDMA_CTRL_Start_TRF    ; Trigger the VDMA
.3a39e1	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a39e5	af 58 f0 3a	lda $3af058	                LDA @l DMA_BLOCKS           ; Check if we need SDMA
.3a39e9	29 30		and #$30	                AND #DMA_SRC_SRAM | DMA_DST_SRAM
.3a39eb	f0 0f		beq $3a39fc	                BEQ wait_vdma               ; No: wait for VDMA to complete
.3a39ed					trig_sdma
.3a39ed	af 20 04 af	lda $af0420	                LDA @l SDMA_CTRL_REG0
.3a39f1	09 80		ora #$80	                ORA #SDMA_CTRL0_Start_TRF   ; Trigger the SDMA
.3a39f3	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.3a39f7	ea		nop		                NOP                         ; When the transfer is started the CPU will be put on Hold (RDYn)...
.3a39f8	ea		nop		                NOP                         ; Before it actually gets to stop it will execute a couple more instructions
.3a39f9	ea		nop		                NOP                         ; From that point on, the CPU is halted (keep that in mind)
.3a39fa	ea		nop		                NOP                         ; No IRQ will be processed either during that time
.3a39fb	ea		nop		                NOP
.3a39fc	af 01 04 af	lda $af0401	wait_vdma       LDA @l VDMA_STATUS_REG      ; Check the VDMA status
.3a3a00	89 80		bit #$80	                BIT #VDMA_STAT_VDMA_IPS     ; If the transfer is still in process...
.3a3a02	d0 f8		bne $3a39fc	                BNE wait_vdma               ; Wait until it stops.
.3a3a04	a9 00		lda #$00	                LDA #$00                    ; Clear the TRF bits
.3a3a06	8f 20 04 af	sta $af0420	                STA @l SDMA_CTRL_REG0
.3a3a0a	8f 00 04 af	sta $af0400	                STA @l VDMA_CONTROL_REG
.3a3a0e	28		plp		                PLP
.3a3a0f	2b		pld		                PLD
.3a3a10	60		rts		            RTS
.3a3a11					S_MEMCOPY
.3a3a11	0b		phd		                PHD
.3a3a12	08		php		                PHP
.3a3a13	e2 20		sep #$20	            SEP #$20
.3a3a15	c2 10		rep #$10	            REP #$10
.3a3a17	a9 00		lda #$00	                LDA #0
.3a3a19	a2 00 00	ldx #$0000	                LDX #0
.3a3a1c	8f 59 f0 3a	sta $3af059	clr_loop        STA @l DMA_SRC
.3a3a20	e8		inx		                INX
.3a3a21	e0 1a 00	cpx #$001a	                CPX #SIZE(DMA_BLOCK) * 2
.3a3a24	d0 f6		bne $3a3a1c	                BNE clr_loop
.3a3a26	20 7b 22	jsr $3a227b	            JSR PEEK_TOK
.3a3a29	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.3a3a2b	f0 23		beq $3a3a50	                BEQ src_linear                      ; Yes: go to process a linear source
.3a3a2d	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.3a3a2f	f0 5e		beq $3a3a8f	                BEQ src_rect                        ; Yes: go to process a rectangular source
.3a3a31					syntax_err
.3a3a31	08		php		            PHP
.3a3a32	c2 20		rep #$20	            REP #$20
.3a3a34	48		pha		            PHA
.3a3a35	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3a38	5b		tcd		            TCD
.3a3a39	68		pla		            PLA
.3a3a3a	28		plp		            PLP
.3a3a3b	e2 20		sep #$20	            SEP #$20
.3a3a3d	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3a3f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3a43	c2 20		rep #$20	            REP #$20
.3a3a45	29 ff 00	and #$00ff	            AND #$00FF
.3a3a48	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a3a4b	e2 20		sep #$20	            SEP #$20
.3a3a4d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3a50					src_linear
.3a3a50	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3a53	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3a56	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a3a59	c2 20		rep #$20	            REP #$20
.3a3a5b	a5 23		lda $0823	            LDA ARGUMENT1
.3a3a5d	8f 5a f0 3a	sta $3af05a	            STA DMA_SRC.ADDR
.3a3a61	e2 20		sep #$20	            SEP #$20
.3a3a63	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a3a65	8f 5c f0 3a	sta $3af05c	            STA DMA_SRC.ADDR+2
.3a3a69	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.3a3a6b	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3a6e	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3a71	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a3a74	c2 20		rep #$20	            REP #$20
.3a3a76	a5 23		lda $0823	            LDA ARGUMENT1
.3a3a78	8f 5d f0 3a	sta $3af05d	            STA DMA_SRC.SIZE
.3a3a7c	e2 20		sep #$20	            SEP #$20
.3a3a7e	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a3a80	8f 5f f0 3a	sta $3af05f	            STA DMA_SRC.SIZE+2
.3a3a84	e2 20		sep #$20	            SEP #$20
.3a3a86	a9 00		lda #$00	            LDA #<DMA_LINEAR
.3a3a88	8f 59 f0 3a	sta $3af059	            STA DMA_SRC.MODE
.3a3a8c	82 74 00	brl $3a3b03	                BRL process_to
.3a3a8f					src_rect
.3a3a8f	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3a92	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3a95	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a3a98	c2 20		rep #$20	            REP #$20
.3a3a9a	a5 23		lda $0823	            LDA ARGUMENT1
.3a3a9c	8f 5a f0 3a	sta $3af05a	            STA DMA_SRC.ADDR
.3a3aa0	e2 20		sep #$20	            SEP #$20
.3a3aa2	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a3aa4	8f 5c f0 3a	sta $3af05c	            STA DMA_SRC.ADDR+2
.3a3aa8	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.3a3aaa	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3aad	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3ab0	20 0d 07	jsr $3a070d	            JSR ASS_ARG1_INT16
.3a3ab3	c2 20		rep #$20	            REP #$20
.3a3ab5	a5 23		lda $0823	            LDA ARGUMENT1
.3a3ab7	8f 60 f0 3a	sta $3af060	            STA DMA_SRC.WIDTH
.3a3abb	8d 00 01	sta $0100	            STA M0_OPERAND_A
.3a3abe	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.3a3ac1	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3ac4	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3ac7	20 0d 07	jsr $3a070d	            JSR ASS_ARG1_INT16
.3a3aca	c2 20		rep #$20	            REP #$20
.3a3acc	a5 23		lda $0823	            LDA ARGUMENT1
.3a3ace	8f 62 f0 3a	sta $3af062	            STA DMA_SRC.HEIGHT
.3a3ad2	8d 02 01	sta $0102	            STA M0_OPERAND_B
.3a3ad5	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.3a3ad8	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3adb	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3ade	20 0d 07	jsr $3a070d	            JSR ASS_ARG1_INT16
.3a3ae1	c2 20		rep #$20	            REP #$20
.3a3ae3	a5 23		lda $0823	            LDA ARGUMENT1
.3a3ae5	8f 64 f0 3a	sta $3af064	            STA DMA_SRC.STRIDE
.3a3ae9	c2 20		rep #$20	            REP #$20
.3a3aeb	ad 04 01	lda $0104	            LDA M0_RESULT
.3a3aee	8f 5d f0 3a	sta $3af05d	            STA DMA_SRC.SIZE
.3a3af2	e2 20		sep #$20	            SEP #$20
.3a3af4	ad 06 01	lda $0106	            LDA M0_RESULT+2
.3a3af7	8f 5f f0 3a	sta $3af05f	            STA DMA_SRC.SIZE+2
.3a3afb	e2 20		sep #$20	            SEP #$20
.3a3afd	a9 01		lda #$01	            LDA #<DMA_RECT
.3a3aff	8f 59 f0 3a	sta $3af059	            STA DMA_SRC.MODE
.3a3b03					process_to
.3a3b03	e2 20		sep #$20	            SEP #$20
.3a3b05	a9 9c		lda #$9c	                LDA #TOK_TO
.3a3b07	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3b0a	20 7b 22	jsr $3a227b	            JSR PEEK_TOK
.3a3b0d	c9 e6		cmp #$e6	                CMP #TOK_LINEAR                     ; Is it LINEAR?
.3a3b0f	f0 23		beq $3a3b34	                BEQ dest_linear                     ; Yes: go to process a linear destination
.3a3b11	c9 e7		cmp #$e7	                CMP #TOK_RECT                       ; Is it RECT?
.3a3b13	f0 5e		beq $3a3b73	                BEQ dest_rect                       ; Yes: go to process a rectangular source
.3a3b15					syntax_err2
.3a3b15	08		php		            PHP
.3a3b16	c2 20		rep #$20	            REP #$20
.3a3b18	48		pha		            PHA
.3a3b19	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3b1c	5b		tcd		            TCD
.3a3b1d	68		pla		            PLA
.3a3b1e	28		plp		            PLP
.3a3b1f	e2 20		sep #$20	            SEP #$20
.3a3b21	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3b23	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3b27	c2 20		rep #$20	            REP #$20
.3a3b29	29 ff 00	and #$00ff	            AND #$00FF
.3a3b2c	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a3b2f	e2 20		sep #$20	            SEP #$20
.3a3b31	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3b34					dest_linear
.3a3b34	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3b37	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3b3a	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a3b3d	c2 20		rep #$20	            REP #$20
.3a3b3f	a5 23		lda $0823	            LDA ARGUMENT1
.3a3b41	8f 67 f0 3a	sta $3af067	            STA DMA_DEST.ADDR
.3a3b45	e2 20		sep #$20	            SEP #$20
.3a3b47	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a3b49	8f 69 f0 3a	sta $3af069	            STA DMA_DEST.ADDR+2
.3a3b4d	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.3a3b4f	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3b52	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3b55	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a3b58	c2 20		rep #$20	            REP #$20
.3a3b5a	a5 23		lda $0823	            LDA ARGUMENT1
.3a3b5c	8f 6a f0 3a	sta $3af06a	            STA DMA_DEST.SIZE
.3a3b60	e2 20		sep #$20	            SEP #$20
.3a3b62	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a3b64	8f 6c f0 3a	sta $3af06c	            STA DMA_DEST.SIZE+2
.3a3b68	e2 20		sep #$20	            SEP #$20
.3a3b6a	a9 00		lda #$00	            LDA #<DMA_LINEAR
.3a3b6c	8f 66 f0 3a	sta $3af066	            STA DMA_DEST.MODE
.3a3b70	82 74 00	brl $3a3be7	                BRL verify
.3a3b73					dest_rect
.3a3b73	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3b76	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3b79	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a3b7c	c2 20		rep #$20	            REP #$20
.3a3b7e	a5 23		lda $0823	            LDA ARGUMENT1
.3a3b80	8f 67 f0 3a	sta $3af067	            STA DMA_DEST.ADDR
.3a3b84	e2 20		sep #$20	            SEP #$20
.3a3b86	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a3b88	8f 69 f0 3a	sta $3af069	            STA DMA_DEST.ADDR+2
.3a3b8c	a9 2c		lda #$2c	                LDA #','                            ; Get a comma
.3a3b8e	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3b91	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3b94	20 0d 07	jsr $3a070d	            JSR ASS_ARG1_INT16
.3a3b97	c2 20		rep #$20	            REP #$20
.3a3b99	a5 23		lda $0823	            LDA ARGUMENT1
.3a3b9b	8f 6d f0 3a	sta $3af06d	            STA DMA_DEST.WIDTH
.3a3b9f	8d 00 01	sta $0100	            STA M0_OPERAND_A
.3a3ba2	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.3a3ba5	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3ba8	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3bab	20 0d 07	jsr $3a070d	            JSR ASS_ARG1_INT16
.3a3bae	c2 20		rep #$20	            REP #$20
.3a3bb0	a5 23		lda $0823	            LDA ARGUMENT1
.3a3bb2	8f 6f f0 3a	sta $3af06f	            STA DMA_DEST.HEIGHT
.3a3bb6	8d 02 01	sta $0102	            STA M0_OPERAND_B
.3a3bb9	a9 2c 00	lda #$002c	                LDA #','                            ; Get a comma
.3a3bbc	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3bbf	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3bc2	20 0d 07	jsr $3a070d	            JSR ASS_ARG1_INT16
.3a3bc5	c2 20		rep #$20	            REP #$20
.3a3bc7	a5 23		lda $0823	            LDA ARGUMENT1
.3a3bc9	8f 71 f0 3a	sta $3af071	            STA DMA_DEST.STRIDE
.3a3bcd	c2 20		rep #$20	            REP #$20
.3a3bcf	ad 04 01	lda $0104	            LDA M0_RESULT
.3a3bd2	8f 6a f0 3a	sta $3af06a	            STA DMA_DEST.SIZE
.3a3bd6	e2 20		sep #$20	            SEP #$20
.3a3bd8	ad 06 01	lda $0106	            LDA M0_RESULT+2
.3a3bdb	8f 6c f0 3a	sta $3af06c	            STA DMA_DEST.SIZE+2
.3a3bdf	e2 20		sep #$20	            SEP #$20
.3a3be1	a9 01		lda #$01	            LDA #<DMA_RECT
.3a3be3	8f 66 f0 3a	sta $3af066	            STA DMA_DEST.MODE
.3a3be7					verify
.3a3be7	c2 20		rep #$20	            REP #$20
.3a3be9	af 5d f0 3a	lda $3af05d	                LDA @l DMA_SRC.SIZE
.3a3bed	cf 6a f0 3a	cmp $3af06a	                CMP @l DMA_DEST.SIZE
.3a3bf1	d0 14		bne $3a3c07	                BNE size_err
.3a3bf3	e2 20		sep #$20	            SEP #$20
.3a3bf5	af 5f f0 3a	lda $3af05f	                LDA @l DMA_SRC.SIZE+2
.3a3bf9	cf 6c f0 3a	cmp $3af06c	                CMP @l DMA_DEST.SIZE+2
.3a3bfd	d0 08		bne $3a3c07	                BNE size_err
.3a3bff	c2 20		rep #$20	            REP #$20
.3a3c01	20 2f 37	jsr $3a372f	            JSR DO_DMA
.3a3c04	28		plp		                PLP
.3a3c05	2b		pld		                PLD
.3a3c06	60		rts		            RTS
.3a3c07					size_err
.3a3c07	08		php		            PHP
.3a3c08	c2 20		rep #$20	            REP #$20
.3a3c0a	48		pha		            PHA
.3a3c0b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3c0e	5b		tcd		            TCD
.3a3c0f	68		pla		            PLA
.3a3c10	28		plp		            PLP
.3a3c11	e2 20		sep #$20	            SEP #$20
.3a3c13	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a3c15	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3c19	c2 20		rep #$20	            REP #$20
.3a3c1b	29 ff 00	and #$00ff	            AND #$00FF
.3a3c1e	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a3c21	e2 20		sep #$20	            SEP #$20
.3a3c23	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3c26					S_LOCATE
.3a3c26	08		php		                PHP
.3a3c27	c2 30		rep #$30	            REP #$30
.3a3c29	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3c2c	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a3c2f	a5 23		lda $0823	                LDA ARGUMENT1
.3a3c31	48		pha		                PHA                         ; Save it for later
.3a3c32	a9 2c 00	lda #$002c	                LDA #','                    ; Check for the comma separator
.3a3c35	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3c38	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3c3b	20 63 07	jsr $3a0763	            JSR ASS_ARG1_BYTE
.3a3c3e	a4 23		ldy $0823	                LDY ARGUMENT1               ; Set Y to the row
.3a3c40	fa		plx		                PLX                         ; Set X to the column
.3a3c41	20 20 00	jsr $3a0020	            JSR CURSORXY
.3a3c44	28		plp		                PLP
.3a3c45	60		rts		            RTS

;******  Return to file: src\statements.s

.3a3c46					S_INPUT
.3a3c46	08		php		                PHP
.3a3c47					varloop
.3a3c47	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a3c4a	e2 20		sep #$20	            SEP #$20
.3a3c4c	a7 00		lda [$0800]	                LDA [BIP]
.3a3c4e	d0 03		bne $3a3c53	                BNE check_colon
.3a3c50	4c ee 3c	jmp $3a3cee	                JMP done            ; If EOL, we're done
.3a3c53	c9 3a		cmp #$3a	check_colon     CMP #':'
.3a3c55	d0 03		bne $3a3c5a	                BNE check_string
.3a3c57	4c ee 3c	jmp $3a3cee	                JMP done            ; If colon, we're done
.3a3c5a	c9 22		cmp #$22	check_string    CMP #CHAR_DQUOTE    ; Is it the start of a string?
.3a3c5c	d0 0b		bne $3a3c69	                BNE check_var       ; No: then it should be a variable name
.3a3c5e	20 15 1c	jsr $3a1c15	            JSR EVALSTRING
.3a3c61	20 fc 45	jsr $3a45fc	            JSR PR_STRING
.3a3c64	a9 3b		lda #$3b	                LDA #';'            ; Look for a semicolon
.3a3c66	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3c69					check_var
.3a3c69	20 e2 04	jsr $3a04e2	            JSR ISALPHA
.3a3c6c	90 44		bcc $3a3cb2	                BCC syntax_err      ; No: it's a syntax error
.3a3c6e	20 1c 54	jsr $3a541c	            JSR VAR_FINDNAME
.3a3c71	90 3f		bcc $3a3cb2	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.3a3c73	a9 3f		lda #$3f	                LDA #"?"            ; Print a "? " to follow
.3a3c75	20 18 00	jsr $3a0018	            JSR PRINTC
.3a3c78	a9 20		lda #$20	                LDA #CHAR_SP
.3a3c7a	20 18 00	jsr $3a0018	            JSR PRINTC
.3a3c7d	20 10 00	jsr $3a0010	            JSR INPUTLINE
.3a3c80	e2 20		sep #$20	            SEP #$20
.3a3c82	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Check the type of the variable
.3a3c84	c9 02		cmp #$02	                CMP #TYPE_STRING    ; If it's a string...
.3a3c86	f0 49		beq $3a3cd1	                BEQ in_string       ; ... go to copy the string data
.3a3c88	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; If it's an integer...
.3a3c8a	d0 03		bne $3a3c8f	                BNE chk_float
.3a3c8c	82 84 00	brl $3a3d13	                BRL in_integer      ; ... go to parse the integer
.3a3c8f	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT     ; If it's a float...
.3a3c91	f0 5d		beq $3a3cf0	                BEQ in_float        ; ... go to parse the float
.3a3c93	08		php		            PHP
.3a3c94	c2 20		rep #$20	            REP #$20
.3a3c96	48		pha		            PHA
.3a3c97	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3c9a	5b		tcd		            TCD
.3a3c9b	68		pla		            PLA
.3a3c9c	28		plp		            PLP
.3a3c9d	e2 20		sep #$20	            SEP #$20
.3a3c9f	a9 04		lda #$04	            LDA #ERR_TYPE
.3a3ca1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3ca5	c2 20		rep #$20	            REP #$20
.3a3ca7	29 ff 00	and #$00ff	            AND #$00FF
.3a3caa	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a3cad	e2 20		sep #$20	            SEP #$20
.3a3caf	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3cb2					syntax_err
.3a3cb2	08		php		            PHP
.3a3cb3	c2 20		rep #$20	            REP #$20
.3a3cb5	48		pha		            PHA
.3a3cb6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3cb9	5b		tcd		            TCD
.3a3cba	68		pla		            PLA
.3a3cbb	28		plp		            PLP
.3a3cbc	e2 20		sep #$20	            SEP #$20
.3a3cbe	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3cc0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3cc4	c2 20		rep #$20	            REP #$20
.3a3cc6	29 ff 00	and #$00ff	            AND #$00FF
.3a3cc9	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a3ccc	e2 20		sep #$20	            SEP #$20
.3a3cce	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3cd1					in_string
.3a3cd1	c2 20		rep #$20	            REP #$20
.3a3cd3	a9 00 4c	lda #$4c00	                LDA #<>IOBUF
.3a3cd6	85 23		sta $0823	                STA ARGUMENT1
.3a3cd8	a9 00 00	lda #$0000	                LDA #`IOBUF
.3a3cdb	85 25		sta $0825	                STA ARGUMENT1+2
.3a3cdd	e2 20		sep #$20	            SEP #$20
.3a3cdf	a9 02		lda #$02	                LDA #TYPE_STRING
.3a3ce1	85 27		sta $0827	                STA ARGTYPE1
.3a3ce3					save_input
.3a3ce3	c2 20		rep #$20	            REP #$20
.3a3ce5	20 7f 53	jsr $3a537f	            JSR VAR_SET
.3a3ce8	a9 0d 00	lda #$000d	                LDA #CHAR_CR        ; Print a newline
.3a3ceb	20 18 00	jsr $3a0018	            JSR PRINTC
.3a3cee	28		plp		done            PLP
.3a3cef	60		rts		            RTS
.3a3cf0					in_float
.3a3cf0	c2 20		rep #$20	            REP #$20
.3a3cf2	a5 00		lda $0800	                LDA BIP             ; Save the BIP for later use
.3a3cf4	85 40		sta $0840	                STA SAVEBIP
.3a3cf6	a5 02		lda $0802	                LDA BIP+2
.3a3cf8	85 42		sta $0842	                STA SAVEBIP+2
.3a3cfa	a9 00 4c	lda #$4c00	                LDA #<>IOBUF        ; Point to the line that was just input
.3a3cfd	85 00		sta $0800	                STA BIP
.3a3cff	a9 00 00	lda #$0000	                LDA #`IOBUF
.3a3d02	85 02		sta $0802	                STA BIP+2
.3a3d04	20 3e 5a	jsr $3a5a3e	            JSR PARSENUM
.3a3d07	c2 20		rep #$20	            REP #$20
.3a3d09	a5 40		lda $0840	                LDA SAVEBIP         ; Restore the BIP
.3a3d0b	85 00		sta $0800	                STA BIP
.3a3d0d	a5 42		lda $0842	                LDA SAVEBIP+2
.3a3d0f	85 02		sta $0802	                STA BIP+2
.3a3d11	80 d0		bra $3a3ce3	                BRA save_input
.3a3d13					in_integer
.3a3d13	c2 20		rep #$20	            REP #$20
.3a3d15	a5 00		lda $0800	                LDA BIP             ; Save the BIP for later use
.3a3d17	85 40		sta $0840	                STA SAVEBIP
.3a3d19	a5 02		lda $0802	                LDA BIP+2
.3a3d1b	85 42		sta $0842	                STA SAVEBIP+2
.3a3d1d	a9 00 4c	lda #$4c00	                LDA #<>IOBUF        ; Point to the line that was just input
.3a3d20	85 00		sta $0800	                STA BIP
.3a3d22	a9 00 00	lda #$0000	                LDA #`IOBUF
.3a3d25	85 02		sta $0802	                STA BIP+2
.3a3d27	20 d8 08	jsr $3a08d8	            JSR PARSEINT
.3a3d2a	c2 20		rep #$20	            REP #$20
.3a3d2c	a5 40		lda $0840	                LDA SAVEBIP         ; Restore the BIP
.3a3d2e	85 00		sta $0800	                STA BIP
.3a3d30	a5 42		lda $0842	                LDA SAVEBIP+2
.3a3d32	85 02		sta $0802	                STA BIP+2
.3a3d34	80 ad		bra $3a3ce3	                BRA save_input
.3a3d36					S_GET
.3a3d36	08		php		                PHP
.3a3d37					varloop
.3a3d37	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a3d3a	e2 20		sep #$20	            SEP #$20
.3a3d3c	a7 00		lda [$0800]	                LDA [BIP]
.3a3d3e	f0 47		beq $3a3d87	                BEQ done            ; If EOL, we're done
.3a3d40	c9 3a		cmp #$3a	                CMP #':'
.3a3d42	f0 43		beq $3a3d87	                BEQ done            ; If colon, we're done
.3a3d44	20 e2 04	jsr $3a04e2	            JSR ISALPHA
.3a3d47	90 40		bcc $3a3d89	                BCC syntax_err      ; No: it's a syntax error
.3a3d49	20 1c 54	jsr $3a541c	            JSR VAR_FINDNAME
.3a3d4c	90 3b		bcc $3a3d89	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.3a3d4e	20 01 15	jsr $3a1501	            JSR TEMPSTRING
.3a3d51	20 14 00	jsr $3a0014	            JSR GETKEY
.3a3d54	e2 20		sep #$20	            SEP #$20
.3a3d56	a0 00 00	ldy #$0000	                LDY #0
.3a3d59	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a3d5b	a9 00		lda #$00	                LDA #0
.3a3d5d	c8		iny		                INY
.3a3d5e	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a3d60	c2 20		rep #$20	            REP #$20
.3a3d62	a5 16		lda $0816	                LDA STRPTR
.3a3d64	85 23		sta $0823	                STA ARGUMENT1
.3a3d66	a5 18		lda $0818	                LDA STRPTR+2
.3a3d68	85 25		sta $0825	                STA ARGUMENT1+2
.3a3d6a	e2 20		sep #$20	            SEP #$20
.3a3d6c	a9 02		lda #$02	                LDA #TYPE_STRING
.3a3d6e	85 27		sta $0827	                STA ARGTYPE1
.3a3d70	20 7f 53	jsr $3a537f	            JSR VAR_SET
.3a3d73	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a3d76	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.3a3d78	f0 0d		beq $3a3d87	                BEQ done            ; EOL? We're done
.3a3d7a	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.3a3d7c	f0 09		beq $3a3d87	                BEQ done
.3a3d7e	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.3a3d80	d0 07		bne $3a3d89	                BNE syntax_err      ; Nope: syntax error
.3a3d82	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a3d85	80 b0		bra $3a3d37	                BRA varloop
.3a3d87	28		plp		done            PLP
.3a3d88	60		rts		            RTS
.3a3d89					syntax_err
.3a3d89	08		php		            PHP
.3a3d8a	c2 20		rep #$20	            REP #$20
.3a3d8c	48		pha		            PHA
.3a3d8d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3d90	5b		tcd		            TCD
.3a3d91	68		pla		            PLA
.3a3d92	28		plp		            PLP
.3a3d93	e2 20		sep #$20	            SEP #$20
.3a3d95	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3d97	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3d9b	c2 20		rep #$20	            REP #$20
.3a3d9d	29 ff 00	and #$00ff	            AND #$00FF
.3a3da0	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a3da3	e2 20		sep #$20	            SEP #$20
.3a3da5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3da8					S_CALL
.3a3da8	08		php		                PHP
.3a3da9	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3dac	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a3daf	e2 20		sep #$20	            SEP #$20
.3a3db1	a9 5c		lda #$5c	                LDA #$5C            ; Set the opcode for JML
.3a3db3	85 a2		sta $08a2	                STA MJUMPINST
.3a3db5	c2 20		rep #$20	            REP #$20
.3a3db7	a5 23		lda $0823	                LDA ARGUMENT1
.3a3db9	85 a3		sta $08a3	                STA MJUMPADDR
.3a3dbb	e2 20		sep #$20	            SEP #$20
.3a3dbd	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a3dbf	85 a5		sta $08a5	                STA MJUMPADDR+2
.3a3dc1	e2 20		sep #$20	            SEP #$20
.3a3dc3	a9 2c		lda #$2c	                LDA #','
.3a3dc5	85 37		sta $0837	                STA TARGETTOK
.3a3dc7	20 5c 22	jsr $3a225c	            JSR OPT_TOK
.3a3dca	90 41		bcc $3a3e0d	                BCC launch          ; Not present... go ahead and launch
.3a3dcc	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a3dcf	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3dd2	20 0d 07	jsr $3a070d	            JSR ASS_ARG1_INT16
.3a3dd5	c2 20		rep #$20	            REP #$20
.3a3dd7	a5 23		lda $0823	                LDA ARGUMENT1
.3a3dd9	85 55		sta $0855	                STA MARG1           ; Save it to MARG1
.3a3ddb	e2 20		sep #$20	            SEP #$20
.3a3ddd	a9 2c		lda #$2c	                LDA #','
.3a3ddf	85 37		sta $0837	                STA TARGETTOK
.3a3de1	20 5c 22	jsr $3a225c	            JSR OPT_TOK
.3a3de4	90 27		bcc $3a3e0d	                BCC launch          ; Not present... go ahead and launch
.3a3de6	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a3de9	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3dec	20 0d 07	jsr $3a070d	            JSR ASS_ARG1_INT16
.3a3def	c2 20		rep #$20	            REP #$20
.3a3df1	a5 23		lda $0823	                LDA ARGUMENT1
.3a3df3	85 59		sta $0859	                STA MARG2           ; Save it to MARG2
.3a3df5	e2 20		sep #$20	            SEP #$20
.3a3df7	a9 2c		lda #$2c	                LDA #','
.3a3df9	85 37		sta $0837	                STA TARGETTOK
.3a3dfb	20 5c 22	jsr $3a225c	            JSR OPT_TOK
.3a3dfe	90 0d		bcc $3a3e0d	                BCC launch          ; Not present... go ahead and launch
.3a3e00	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a3e03	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3e06	20 0d 07	jsr $3a070d	            JSR ASS_ARG1_INT16
.3a3e09	c2 20		rep #$20	            REP #$20
.3a3e0b	a4 23		ldy $0823	                LDY ARGUMENT1
.3a3e0d	a6 59		ldx $0859	launch          LDX MARG2
.3a3e0f	a5 55		lda $0855	                LDA MARG1
.3a3e11	0b		phd		                PHD
.3a3e12	8b		phb		                PHB
.3a3e13	08		php		                PHP
.3a3e14	22 a2 08 00	jsl $0008a2	                JSL MJUMPINST       ; Call the subroutine indicated
.3a3e18	28		plp		                PLP
.3a3e19	ab		plb		                PLB
.3a3e1a	2b		pld		                PLD
.3a3e1b	20 5f 21	jsr $3a215f	            JSR SKIPSTMT
.3a3e1e	28		plp		                PLP
.3a3e1f	60		rts		            RTS
.3a3e20					type_err
.3a3e20	08		php		            PHP
.3a3e21	c2 20		rep #$20	            REP #$20
.3a3e23	48		pha		            PHA
.3a3e24	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3e27	5b		tcd		            TCD
.3a3e28	68		pla		            PLA
.3a3e29	28		plp		            PLP
.3a3e2a	e2 20		sep #$20	            SEP #$20
.3a3e2c	a9 04		lda #$04	            LDA #ERR_TYPE
.3a3e2e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3e32	c2 20		rep #$20	            REP #$20
.3a3e34	29 ff 00	and #$00ff	            AND #$00FF
.3a3e37	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a3e3a	e2 20		sep #$20	            SEP #$20
.3a3e3c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3e3f					S_DIM
.3a3e3f	08		php		                PHP
.3a3e40	e2 20		sep #$20	            SEP #$20
.3a3e42	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a3e45	20 1c 54	jsr $3a541c	            JSR VAR_FINDNAME
.3a3e48	90 64		bcc $3a3eae	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.3a3e4a	a9 8f		lda #$8f	                LDA #TOK_LPAREN     ; Verify we have a left parenthesis
.3a3e4c	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a3e4f	a9 01		lda #$01	                LDA #TOK_FUNC_OPEN  ; Push the "operator" marker for the start of the function
.3a3e51	20 28 1a	jsr $3a1a28	            JSR PHOPERATOR
.3a3e54	a2 01 00	ldx #$0001	                LDX #1
.3a3e57	a9 00		lda #$00	                LDA #0
.3a3e59	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF     ; Set the dimension count to 0
.3a3e5d					dim_loop
.3a3e5d	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a3e60	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a3e63	c2 20		rep #$20	            REP #$20
.3a3e65	a5 23		lda $0823	                LDA ARGUMENT1
.3a3e67	9f 00 4d 00	sta $004d00,x	                STA @lARRIDXBUF,X   ; And store it in the buffer
.3a3e6b	e2 20		sep #$20	            SEP #$20
.3a3e6d	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF     ; Add to the dimension count
.3a3e71	1a		inc a		                INC A
.3a3e72	8f 00 4d 00	sta $004d00	                STA @lARRIDXBUF
.3a3e76	30 55		bmi $3a3ecd	                BMI overflow        ; If > 127 throw an error
.3a3e78	e8		inx		                INX
.3a3e79	e8		inx		                INX
.3a3e7a	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a3e7d	a7 00		lda [$0800]	                LDA [BIP]           ; Check the character
.3a3e7f	c9 2c		cmp #$2c	                CMP #','            ; Is it a comma?
.3a3e81	f0 25		beq $3a3ea8	                BEQ skip_comma      ; Yes: get the next dimension
.3a3e83	c9 90		cmp #$90	                CMP #TOK_RPAREN     ; No: is it a ")"?
.3a3e85	d0 27		bne $3a3eae	                BNE syntax_err      ; No: throw a syntax error
.3a3e87	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a3e8a	20 9a 66	jsr $3a669a	            JSR ARR_ALLOC
.3a3e8d	c2 20		rep #$20	            REP #$20
.3a3e8f	a5 c0		lda $08c0	                LDA CURRBLOCK       ; Set up the pointer to the array
.3a3e91	85 23		sta $0823	                STA ARGUMENT1
.3a3e93	e2 20		sep #$20	            SEP #$20
.3a3e95	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.3a3e97	85 25		sta $0825	                STA ARGUMENT1+2
.3a3e99	64 26		stz $0826	                STZ ARGUMENT1+3
.3a3e9b	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Get the type of the values
.3a3e9d	09 80		ora #$80	                ORA #$80            ; Make sure we change the type to array
.3a3e9f	85 ea		sta $08ea	                STA TOFINDTYPE      ; And save it back for searching
.3a3ea1	85 27		sta $0827	                STA ARGTYPE1        ; And for the value to set
.3a3ea3	20 7f 53	jsr $3a537f	            JSR VAR_SET
.3a3ea6	28		plp		                PLP
.3a3ea7	60		rts		            RTS
.3a3ea8					skip_comma
.3a3ea8	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a3eab	4c 5d 3e	jmp $3a3e5d	                JMP dim_loop
.3a3eae					syntax_err
.3a3eae	08		php		            PHP
.3a3eaf	c2 20		rep #$20	            REP #$20
.3a3eb1	48		pha		            PHA
.3a3eb2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3eb5	5b		tcd		            TCD
.3a3eb6	68		pla		            PLA
.3a3eb7	28		plp		            PLP
.3a3eb8	e2 20		sep #$20	            SEP #$20
.3a3eba	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3ebc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3ec0	c2 20		rep #$20	            REP #$20
.3a3ec2	29 ff 00	and #$00ff	            AND #$00FF
.3a3ec5	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a3ec8	e2 20		sep #$20	            SEP #$20
.3a3eca	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3ecd					overflow
.3a3ecd	08		php		            PHP
.3a3ece	c2 20		rep #$20	            REP #$20
.3a3ed0	48		pha		            PHA
.3a3ed1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3ed4	5b		tcd		            TCD
.3a3ed5	68		pla		            PLA
.3a3ed6	28		plp		            PLP
.3a3ed7	e2 20		sep #$20	            SEP #$20
.3a3ed9	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a3edb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3edf	c2 20		rep #$20	            REP #$20
.3a3ee1	29 ff 00	and #$00ff	            AND #$00FF
.3a3ee4	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a3ee7	e2 20		sep #$20	            SEP #$20
.3a3ee9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3eec					S_READ
.3a3eec	08		php		                PHP
.3a3eed					varloop
.3a3eed	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a3ef0	e2 20		sep #$20	            SEP #$20
.3a3ef2	a7 00		lda [$0800]	                LDA [BIP]
.3a3ef4	f0 28		beq $3a3f1e	                BEQ done            ; If EOL, we're done
.3a3ef6	c9 3a		cmp #$3a	                CMP #':'
.3a3ef8	f0 24		beq $3a3f1e	                BEQ done            ; If colon, we're done
.3a3efa	20 e2 04	jsr $3a04e2	            JSR ISALPHA
.3a3efd	90 21		bcc $3a3f20	                BCC syntax_err      ; No: it's a syntax error
.3a3eff	20 1c 54	jsr $3a541c	            JSR VAR_FINDNAME
.3a3f02	90 1c		bcc $3a3f20	                BCC syntax_err      ; If we didn't get a variable, throw a syntax error
.3a3f04	20 3f 3f	jsr $3a3f3f	            JSR NEXTDATA
.3a3f07	20 7f 53	jsr $3a537f	            JSR VAR_SET
.3a3f0a	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a3f0d	a7 00		lda [$0800]	                LDA [BIP]           ; Get the next non-space
.3a3f0f	f0 0d		beq $3a3f1e	                BEQ done            ; EOL? We're done
.3a3f11	c9 3a		cmp #$3a	                CMP #':'            ; Colon? We're done
.3a3f13	f0 09		beq $3a3f1e	                BEQ done
.3a3f15	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.3a3f17	d0 07		bne $3a3f20	                BNE syntax_err      ; Nope: syntax error
.3a3f19	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a3f1c	80 cf		bra $3a3eed	                BRA varloop
.3a3f1e	28		plp		done            PLP
.3a3f1f	60		rts		            RTS
.3a3f20					syntax_err
.3a3f20	08		php		            PHP
.3a3f21	c2 20		rep #$20	            REP #$20
.3a3f23	48		pha		            PHA
.3a3f24	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3f27	5b		tcd		            TCD
.3a3f28	68		pla		            PLA
.3a3f29	28		plp		            PLP
.3a3f2a	e2 20		sep #$20	            SEP #$20
.3a3f2c	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3f2e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3f32	c2 20		rep #$20	            REP #$20
.3a3f34	29 ff 00	and #$00ff	            AND #$00FF
.3a3f37	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a3f3a	e2 20		sep #$20	            SEP #$20
.3a3f3c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3f3f					NEXTDATA
.3a3f3f	08		php		                PHP
.3a3f40	a5 02		lda $0802	                LDA BIP+2           ; Save BIP
.3a3f42	85 42		sta $0842	                STA SAVEBIP+2
.3a3f44	a5 00		lda $0800	                LDA BIP
.3a3f46	85 40		sta $0840	                STA SAVEBIP
.3a3f48	a5 1c		lda $081c	                LDA CURLINE+2       ; Save CURLINE
.3a3f4a	85 46		sta $0846	                STA SAVELINE+2
.3a3f4c	a5 1a		lda $081a	                LDA CURLINE
.3a3f4e	85 44		sta $0844	                STA SAVELINE
.3a3f50	c2 20		rep #$20	            REP #$20
.3a3f52	a5 3a		lda $083a	                LDA DATABIP+2
.3a3f54	d0 04		bne $3a3f5a	                BNE data_set
.3a3f56	a5 38		lda $0838	                LDA DATABIP
.3a3f58	f0 4e		beq $3a3fa8	                BEQ scan_start      ; No: scan for a DATA statement
.3a3f5a	a5 38		lda $0838	data_set        LDA DATABIP         ; Move BIP to the DATA statement
.3a3f5c	85 00		sta $0800	                STA BIP
.3a3f5e	a5 3a		lda $083a	                LDA DATABIP+2
.3a3f60	85 02		sta $0802	                STA BIP+2
.3a3f62	a5 3c		lda $083c	                LDA DATALINE        ; Set CURLINE from DATALINE
.3a3f64	85 1a		sta $081a	                STA CURLINE
.3a3f66	a5 3e		lda $083e	                LDA DATALINE+2
.3a3f68	85 1c		sta $081c	                STA CURLINE+2
.3a3f6a	e2 20		sep #$20	            SEP #$20
.3a3f6c	a7 00		lda [$0800]	                LDA [BIP]           ; Check character at BIP
.3a3f6e	f0 53		beq $3a3fc3	                BEQ scan_DATA       ; EOL? scan for a DATA statement
.3a3f70	c9 3a		cmp #$3a	                CMP #':'            ; Colon?
.3a3f72	f0 4f		beq $3a3fc3	                BEQ scan_DATA       ; ... scan for a DATA statement
.3a3f74	c9 2c		cmp #$2c	                CMP #','            ; Comma?
.3a3f76	d0 03		bne $3a3f7b	                BNE skip_parse      ; No: skip leading WS and try to parse
.3a3f78	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a3f7b					skip_parse
.3a3f7b	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a3f7e	a7 00		lda [$0800]	                LDA [BIP]
.3a3f80	c9 22		cmp #$22	                CMP #CHAR_DQUOTE    ; Is it a quote?
.3a3f82	f0 4e		beq $3a3fd2	                BEQ read_string     ; Yes: process the string
.3a3f84	20 fb 04	jsr $3a04fb	            JSR ISNUMERAL
.3a3f87	b0 4e		bcs $3a3fd7	                BCS read_number     ; Yes: process the number
.3a3f89					syntax_err
.3a3f89	08		php		            PHP
.3a3f8a	c2 20		rep #$20	            REP #$20
.3a3f8c	48		pha		            PHA
.3a3f8d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a3f90	5b		tcd		            TCD
.3a3f91	68		pla		            PLA
.3a3f92	28		plp		            PLP
.3a3f93	e2 20		sep #$20	            SEP #$20
.3a3f95	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a3f97	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a3f9b	c2 20		rep #$20	            REP #$20
.3a3f9d	29 ff 00	and #$00ff	            AND #$00FF
.3a3fa0	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a3fa3	e2 20		sep #$20	            SEP #$20
.3a3fa5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a3fa8					scan_start
.3a3fa8	c2 20		rep #$20	            REP #$20
.3a3faa	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT    ; Point CURLINE to the first line
.3a3fad	85 1a		sta $081a	                STA CURLINE
.3a3faf	a9 36 00	lda #$0036	                LDA #`BASIC_BOT
.3a3fb2	85 1c		sta $081c	                STA CURLINE+2
.3a3fb4	18		clc		                CLC
.3a3fb5	a5 1a		lda $081a	                LDA CURLINE         ; Point BIP to the first possible token
.3a3fb7	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.3a3fba	85 00		sta $0800	                STA BIP
.3a3fbc	a5 1c		lda $081c	                LDA CURLINE+2
.3a3fbe	69 00 00	adc #$0000	                ADC #0
.3a3fc1	85 02		sta $0802	                STA BIP+2
.3a3fc3					scan_data
.3a3fc3	e2 20		sep #$20	            SEP #$20
.3a3fc5	a9 80		lda #$80	                LDA #$80            ; We don't want to process nesting
.3a3fc7	85 35		sta $0835	                STA SKIPNEST
.3a3fc9	a9 ab		lda #$ab	                LDA #TOK_DATA       ; We're looking for a DATA token
.3a3fcb	85 37		sta $0837	                STA TARGETTOK
.3a3fcd	20 71 21	jsr $3a2171	            JSR SKIPTOTOK
.3a3fd0	80 a9		bra $3a3f7b	                BRA skip_parse
.3a3fd2					read_string
.3a3fd2	20 15 1c	jsr $3a1c15	            JSR EVALSTRING
.3a3fd5	80 03		bra $3a3fda	                BRA done
.3a3fd7					read_number
.3a3fd7	20 3e 5a	jsr $3a5a3e	            JSR PARSENUM
.3a3fda					done
.3a3fda	c2 20		rep #$20	            REP #$20
.3a3fdc	a5 00		lda $0800	                LDA BIP             ; Save BIP to DATABIP
.3a3fde	85 38		sta $0838	                STA DATABIP
.3a3fe0	a5 02		lda $0802	                LDA BIP+2
.3a3fe2	85 3a		sta $083a	                STA DATABIP+2
.3a3fe4	a5 1a		lda $081a	                LDA CURLINE         ; Save CURLINE to DATALINE
.3a3fe6	85 3c		sta $083c	                STA DATALINE
.3a3fe8	a5 1c		lda $081c	                LDA CURLINE+2
.3a3fea	85 3e		sta $083e	                STA DATALINE+2
.3a3fec	a5 44		lda $0844	                LDA SAVELINE        ; Restore CURLINE
.3a3fee	85 1a		sta $081a	                STA CURLINE
.3a3ff0	a5 46		lda $0846	                LDA SAVELINE+2
.3a3ff2	85 1c		sta $081c	                STA CURLINE+2
.3a3ff4	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.3a3ff6	85 00		sta $0800	                STA BIP
.3a3ff8	a5 42		lda $0842	                LDA SAVEBIP+2
.3a3ffa	85 02		sta $0802	                STA BIP+2
.3a3ffc	28		plp		                PLP
.3a3ffd	60		rts		            RTS
.3a3ffe					S_DATA
.3a3ffe	20 5f 21	jsr $3a215f	            JSR SKIPSTMT
.3a4001	60		rts		            RTS
.3a4002					S_RESTORE
.3a4002	64 38		stz $0838	                STZ DATABIP         ; Just set DATABIP to 0
.3a4004	64 3a		stz $083a	                STZ DATABIP+2       ; The next READ will move it to the first DATA
.3a4006	64 3c		stz $083c	                STZ DATALINE        ; Set DATALINE to 0
.3a4008	64 3e		stz $083e	                STZ DATALINE+2
.3a400a	60		rts		            RTS
.3a400b					S_CLS
.3a400b	20 24 00	jsr $3a0024	            JSR CLSCREEN
.3a400e	60		rts		            RTS
.3a400f					S_POKEL
.3a400f	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4012	c2 20		rep #$20	            REP #$20
.3a4014	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.3a4016	48		pha		                PHA
.3a4017	a5 23		lda $0823	                LDA ARGUMENT1
.3a4019	48		pha		                PHA
.3a401a	e2 20		sep #$20	            SEP #$20
.3a401c	a7 00		lda [$0800]	                LDA [BIP]
.3a401e	c9 2c		cmp #$2c	                CMP #','
.3a4020	d0 22		bne $3a4044	                BNE syntax_err
.3a4022	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4025	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4028	c2 20		rep #$20	            REP #$20
.3a402a	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a402c	d0 35		bne $3a4063	                BNE range_err
.3a402e	68		pla		                PLA                 ; Pull the target address from the stack
.3a402f	85 08		sta $0808	                STA INDEX           ; and into INDEX
.3a4031	68		pla		                PLA
.3a4032	85 0a		sta $080a	                STA INDEX+2
.3a4034	c2 20		rep #$20	            REP #$20
.3a4036	a5 23		lda $0823	                LDA ARGUMENT1
.3a4038	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.3a403a	e2 20		sep #$20	            SEP #$20
.3a403c	a0 02 00	ldy #$0002	                LDY #2
.3a403f	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4041	97 08		sta [$0808],y	                STA [INDEX],Y
.3a4043	60		rts		            RTS
.3a4044					syntax_err
.3a4044	08		php		            PHP
.3a4045	c2 20		rep #$20	            REP #$20
.3a4047	48		pha		            PHA
.3a4048	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a404b	5b		tcd		            TCD
.3a404c	68		pla		            PLA
.3a404d	28		plp		            PLP
.3a404e	e2 20		sep #$20	            SEP #$20
.3a4050	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4052	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4056	c2 20		rep #$20	            REP #$20
.3a4058	29 ff 00	and #$00ff	            AND #$00FF
.3a405b	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a405e	e2 20		sep #$20	            SEP #$20
.3a4060	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4063					range_err
.3a4063	08		php		            PHP
.3a4064	c2 20		rep #$20	            REP #$20
.3a4066	48		pha		            PHA
.3a4067	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a406a	5b		tcd		            TCD
.3a406b	68		pla		            PLA
.3a406c	28		plp		            PLP
.3a406d	e2 20		sep #$20	            SEP #$20
.3a406f	a9 09		lda #$09	            LDA #ERR_RANGE
.3a4071	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4075	c2 20		rep #$20	            REP #$20
.3a4077	29 ff 00	and #$00ff	            AND #$00FF
.3a407a	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a407d	e2 20		sep #$20	            SEP #$20
.3a407f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4082					S_POKEW
.3a4082	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4085	c2 20		rep #$20	            REP #$20
.3a4087	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.3a4089	48		pha		                PHA
.3a408a	a5 23		lda $0823	                LDA ARGUMENT1
.3a408c	48		pha		                PHA
.3a408d	e2 20		sep #$20	            SEP #$20
.3a408f	a7 00		lda [$0800]	                LDA [BIP]
.3a4091	c9 2c		cmp #$2c	                CMP #','
.3a4093	d0 19		bne $3a40ae	                BNE syntax_err
.3a4095	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4098	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a409b	c2 20		rep #$20	            REP #$20
.3a409d	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a409f	d0 2c		bne $3a40cd	                BNE range_err
.3a40a1	68		pla		                PLA                 ; Pull the target address from the stack
.3a40a2	85 08		sta $0808	                STA INDEX           ; and into INDEX
.3a40a4	68		pla		                PLA
.3a40a5	85 0a		sta $080a	                STA INDEX+2
.3a40a7	c2 20		rep #$20	            REP #$20
.3a40a9	a5 23		lda $0823	                LDA ARGUMENT1
.3a40ab	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.3a40ad	60		rts		            RTS
.3a40ae					syntax_err
.3a40ae	08		php		            PHP
.3a40af	c2 20		rep #$20	            REP #$20
.3a40b1	48		pha		            PHA
.3a40b2	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a40b5	5b		tcd		            TCD
.3a40b6	68		pla		            PLA
.3a40b7	28		plp		            PLP
.3a40b8	e2 20		sep #$20	            SEP #$20
.3a40ba	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a40bc	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a40c0	c2 20		rep #$20	            REP #$20
.3a40c2	29 ff 00	and #$00ff	            AND #$00FF
.3a40c5	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a40c8	e2 20		sep #$20	            SEP #$20
.3a40ca	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a40cd					range_err
.3a40cd	08		php		            PHP
.3a40ce	c2 20		rep #$20	            REP #$20
.3a40d0	48		pha		            PHA
.3a40d1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a40d4	5b		tcd		            TCD
.3a40d5	68		pla		            PLA
.3a40d6	28		plp		            PLP
.3a40d7	e2 20		sep #$20	            SEP #$20
.3a40d9	a9 09		lda #$09	            LDA #ERR_RANGE
.3a40db	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a40df	c2 20		rep #$20	            REP #$20
.3a40e1	29 ff 00	and #$00ff	            AND #$00FF
.3a40e4	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a40e7	e2 20		sep #$20	            SEP #$20
.3a40e9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a40ec					S_POKE
.3a40ec	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a40ef	c2 20		rep #$20	            REP #$20
.3a40f1	a5 25		lda $0825	                LDA ARGUMENT1+2     ; And save it to the stack
.3a40f3	48		pha		                PHA
.3a40f4	a5 23		lda $0823	                LDA ARGUMENT1
.3a40f6	48		pha		                PHA
.3a40f7	e2 20		sep #$20	            SEP #$20
.3a40f9	a7 00		lda [$0800]	                LDA [BIP]
.3a40fb	c9 2c		cmp #$2c	                CMP #','
.3a40fd	d0 1f		bne $3a411e	                BNE syntax_err
.3a40ff	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4102	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4105	e2 20		sep #$20	            SEP #$20
.3a4107	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Make sure the value is from 0 - 255
.3a4109	d0 32		bne $3a413d	                BNE range_err
.3a410b	c2 20		rep #$20	            REP #$20
.3a410d	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a410f	d0 2c		bne $3a413d	                BNE range_err
.3a4111	68		pla		                PLA                 ; Pull the target address from the stack
.3a4112	85 08		sta $0808	                STA INDEX           ; and into INDEX
.3a4114	68		pla		                PLA
.3a4115	85 0a		sta $080a	                STA INDEX+2
.3a4117	e2 20		sep #$20	            SEP #$20
.3a4119	a5 23		lda $0823	                LDA ARGUMENT1
.3a411b	87 08		sta [$0808]	                STA [INDEX]         ; And write it to the address
.3a411d	60		rts		            RTS
.3a411e					syntax_err
.3a411e	08		php		            PHP
.3a411f	c2 20		rep #$20	            REP #$20
.3a4121	48		pha		            PHA
.3a4122	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4125	5b		tcd		            TCD
.3a4126	68		pla		            PLA
.3a4127	28		plp		            PLP
.3a4128	e2 20		sep #$20	            SEP #$20
.3a412a	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a412c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4130	c2 20		rep #$20	            REP #$20
.3a4132	29 ff 00	and #$00ff	            AND #$00FF
.3a4135	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4138	e2 20		sep #$20	            SEP #$20
.3a413a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a413d					range_err
.3a413d	08		php		            PHP
.3a413e	c2 20		rep #$20	            REP #$20
.3a4140	48		pha		            PHA
.3a4141	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4144	5b		tcd		            TCD
.3a4145	68		pla		            PLA
.3a4146	28		plp		            PLP
.3a4147	e2 20		sep #$20	            SEP #$20
.3a4149	a9 09		lda #$09	            LDA #ERR_RANGE
.3a414b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a414f	c2 20		rep #$20	            REP #$20
.3a4151	29 ff 00	and #$00ff	            AND #$00FF
.3a4154	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4157	e2 20		sep #$20	            SEP #$20
.3a4159	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a415c					S_STOP
.3a415c	08		php		            PHP
.3a415d	c2 20		rep #$20	            REP #$20
.3a415f	48		pha		            PHA
.3a4160	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4163	5b		tcd		            TCD
.3a4164	68		pla		            PLA
.3a4165	28		plp		            PLP
.3a4166	e2 20		sep #$20	            SEP #$20
.3a4168	a9 01		lda #$01	            LDA #ERR_BREAK
.3a416a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a416e	c2 20		rep #$20	            REP #$20
.3a4170	29 ff 00	and #$00ff	            AND #$00FF
.3a4173	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4176	e2 20		sep #$20	            SEP #$20
.3a4178	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a417b					S_REM
.3a417b	08		php		                PHP
.3a417c	e2 20		sep #$20	            SEP #$20
.3a417e	a7 00		lda [$0800]	rem_loop        LDA [BIP]
.3a4180	f0 05		beq $3a4187	                BEQ done
.3a4182	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4185	80 f7		bra $3a417e	                BRA rem_loop
.3a4187	28		plp		done            PLP
.3a4188	60		rts		            RTS
.3a4189					S_EXIT
.3a4189	08		php		                PHP
.3a418a	28		plp		                PLP
.3a418b	60		rts		            RTS
.3a418c					S_DO
.3a418c	08		php		                PHP
.3a418d	28		plp		                PLP
.3a418e	60		rts		            RTS
.0000					DO_RECORD
>0000					BIP             .dword  ?
>0004					CURLINE         .dword  ?
.3a418f					S_LOOP
.3a418f	08		php		                PHP
.3a4190	28		plp		                PLP
.3a4191	60		rts		            RTS
.3a4192					S_FOR
.3a4192	08		php		                PHP
.3a4193	c2 20		rep #$20	            REP #$20
.3a4195	a5 1c		lda $081c	                LDA CURLINE+2
.3a4197	20 22 1e	jsr $3a1e22	            JSR PHRETURN
.3a419a	a5 1a		lda $081a	                LDA CURLINE
.3a419c	20 22 1e	jsr $3a1e22	            JSR PHRETURN
.3a419f	a5 02		lda $0802	                LDA BIP+2           ; Save current BIP
.3a41a1	48		pha		                PHA
.3a41a2	a5 00		lda $0800	                LDA BIP
.3a41a4	48		pha		                PHA
.3a41a5	20 5f 21	jsr $3a215f	            JSR SKIPSTMT
.3a41a8	a5 02		lda $0802	                LDA BIP+2           ; Save the BIP for the next statement to the RETURN stack
.3a41aa	20 22 1e	jsr $3a1e22	            JSR PHRETURN
.3a41ad	a5 00		lda $0800	                LDA BIP
.3a41af	20 22 1e	jsr $3a1e22	            JSR PHRETURN
.3a41b2	68		pla		                PLA                 ; Restore the original BIP
.3a41b3	85 00		sta $0800	                STA BIP
.3a41b5	68		pla		                PLA
.3a41b6	85 02		sta $0802	                STA BIP+2
.3a41b8	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a41bb					get_name
.3a41bb	20 1c 54	jsr $3a541c	            JSR VAR_FINDNAME
.3a41be	b0 1f		bcs $3a41df	                BCS push_name       ; If we didn't find a name, thrown an error
.3a41c0	08		php		            PHP
.3a41c1	c2 20		rep #$20	            REP #$20
.3a41c3	48		pha		            PHA
.3a41c4	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a41c7	5b		tcd		            TCD
.3a41c8	68		pla		            PLA
.3a41c9	28		plp		            PLP
.3a41ca	e2 20		sep #$20	            SEP #$20
.3a41cc	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.3a41ce	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a41d2	c2 20		rep #$20	            REP #$20
.3a41d4	29 ff 00	and #$00ff	            AND #$00FF
.3a41d7	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a41da	e2 20		sep #$20	            SEP #$20
.3a41dc	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a41df					push_name
.3a41df	e2 20		sep #$20	            SEP #$20
.3a41e1	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; To the return stack
.3a41e3	20 39 1e	jsr $3a1e39	            JSR PHRETURNB
.3a41e6	a5 e9		lda $08e9	                LDA TOFIND+2
.3a41e8	20 39 1e	jsr $3a1e39	            JSR PHRETURNB
.3a41eb	c2 20		rep #$20	            REP #$20
.3a41ed	a5 e7		lda $08e7	                LDA TOFIND
.3a41ef	20 22 1e	jsr $3a1e22	            JSR PHRETURN
.3a41f2					else
.3a41f2	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a41f5	e2 20		sep #$20	            SEP #$20
.3a41f7	a7 00		lda [$0800]	                LDA [BIP]
.3a41f9	c9 8a		cmp #$8a	                CMP #TOK_EQ
.3a41fb	d0 6a		bne $3a4267	                BNE syntax_err      ; If not found: signal an syntax error
.3a41fd	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Verify type of variable
.3a41ff	c9 00		cmp #$00	                CMP #TYPE_INTEGER   ; Is it integer?
.3a4201	f0 04		beq $3a4207	                BEQ process_initial ; Yes: it's ok
.3a4203	c9 01		cmp #$01	                CMP #TYPE_FLOAT     ; Is it floating point?
.3a4205	f0 00		beq $3a4207	                BEQ process_initial ; Yes: it's ok
.3a4207					process_initial
.3a4207	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a420a	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a420d	20 7f 53	jsr $3a537f	            JSR VAR_SET
.3a4210	e2 20		sep #$20	            SEP #$20
.3a4212	a9 9c		lda #$9c	                LDA #TOK_TO         ; Expect the next token to be TO
.3a4214	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4217	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a421a	c2 20		rep #$20	            REP #$20
.3a421c	a5 27		lda $0827	                LDA ARGTYPE1
.3a421e	20 22 1e	jsr $3a1e22	            JSR PHRETURN
.3a4221	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4223	20 22 1e	jsr $3a1e22	            JSR PHRETURN
.3a4226	a5 23		lda $0823	                LDA ARGUMENT1
.3a4228	20 22 1e	jsr $3a1e22	            JSR PHRETURN
.3a422b	e2 20		sep #$20	            SEP #$20
.3a422d	a9 9d		lda #$9d	                LDA #TOK_STEP
.3a422f	85 37		sta $0837	                STA TARGETTOK
.3a4231	20 5c 22	jsr $3a225c	            JSR OPT_TOK
.3a4234	90 1b		bcc $3a4251	                BCC default_inc     ; Not found: set a default increment of 1
.3a4236	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4239	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a423c	e2 20		sep #$20	            SEP #$20
.3a423e	a5 27		lda $0827	                LDA ARGTYPE1        ; Push the result as the increment
.3a4240	20 22 1e	jsr $3a1e22	            JSR PHRETURN
.3a4243	c2 20		rep #$20	            REP #$20
.3a4245	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4247	20 22 1e	jsr $3a1e22	            JSR PHRETURN
.3a424a	a5 23		lda $0823	                LDA ARGUMENT1
.3a424c	20 22 1e	jsr $3a1e22	            JSR PHRETURN
.3a424f	80 14		bra $3a4265	                BRA done
.3a4251					default_inc
.3a4251	c2 20		rep #$20	            REP #$20
.3a4253	a9 00 00	lda #$0000	                LDA #TYPE_INTEGER
.3a4256	20 22 1e	jsr $3a1e22	            JSR PHRETURN
.3a4259	a9 00 00	lda #$0000	                LDA #0
.3a425c	20 22 1e	jsr $3a1e22	            JSR PHRETURN
.3a425f	a9 01 00	lda #$0001	                LDA #1
.3a4262	20 22 1e	jsr $3a1e22	            JSR PHRETURN
.3a4265	28		plp		done            PLP
.3a4266	60		rts		            RTS
.3a4267					syntax_err
.3a4267	08		php		            PHP
.3a4268	c2 20		rep #$20	            REP #$20
.3a426a	48		pha		            PHA
.3a426b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a426e	5b		tcd		            TCD
.3a426f	68		pla		            PLA
.3a4270	28		plp		            PLP
.3a4271	e2 20		sep #$20	            SEP #$20
.3a4273	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4275	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4279	c2 20		rep #$20	            REP #$20
.3a427b	29 ff 00	and #$00ff	            AND #$00FF
.3a427e	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4281	e2 20		sep #$20	            SEP #$20
.3a4283	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.0000					FOR_RECORD
>0000					INCREMENT       .dword  ?
>0004					INCTYPE         .word   ?
>0006					FINAL           .dword  ?
>000a					FINALTYPE       .word   ?
>000c					VARIBLE         .dword  ?
>0010					VARTYPE         .word   ?
>0012					BIP             .dword  ?
>0016					CURLINE         .dword  ?
.3a4286					S_NEXT
.3a4286	08		php		                PHP
.3a4287	8b		phb		                PHB
.3a4288	08		php		            PHP
.3a4289	e2 20		sep #$20	            SEP #$20
.3a428b	48		pha		            PHA
.3a428c	a9 00		lda #$00	            LDA #0
.3a428e	48		pha		            PHA
.3a428f	ab		plb		            PLB
.3a4290	68		pla		            PLA
.3a4291	28		plp		            PLP
.3a4292	08		php		            PHP
.3a4293	c2 20		rep #$20	            REP #$20
.3a4295	48		pha		            PHA
.3a4296	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a4299	5b		tcd		            TCD
.3a429a	68		pla		            PLA
.3a429b	28		plp		            PLP
.3a429c	c2 30		rep #$30	            REP #$30
.3a429e	a4 33		ldy $0833	                LDY RETURNSP                    ; Y := pointer to first byte of the FOR record
.3a42a0	c8		iny		                INY                             ; RETURNSP points to the first free slot, so move up 2 bytes
.3a42a1	c8		iny		                INY
.3a42a2	c2 20		rep #$20	            REP #$20
.3a42a4	b9 0c 00	lda $000c,y	                LDA #FOR_RECORD.VARIBLE,B,Y     ; TOFIND := FOR_RECORD.VARIABLE
.3a42a7	85 e7		sta $08e7	                STA TOFIND
.3a42a9	b9 0e 00	lda $000e,y	                LDA #FOR_RECORD.VARIBLE+2,B,Y
.3a42ac	e2 20		sep #$20	            SEP #$20
.3a42ae	85 e9		sta $08e9	                STA TOFIND+2
.3a42b0	b9 10 00	lda $0010,y	                LDA #FOR_RECORD.VARTYPE,B,Y
.3a42b3	85 ea		sta $08ea	                STA TOFINDTYPE
.3a42b5	c2 20		rep #$20	            REP #$20
.3a42b7	5a		phy		                PHY
.3a42b8	20 1d 52	jsr $3a521d	            JSR VAR_REF
.3a42bb	7a		ply		                PLY
.3a42bc	c2 20		rep #$20	            REP #$20
.3a42be	b9 00 00	lda $0000,y	                LDA #FOR_RECORD.INCREMENT,B,Y   ; ARGUMENT2 := FOR_RECORD.INCREMENT
.3a42c1	85 29		sta $0829	                STA ARGUMENT2
.3a42c3	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y
.3a42c6	85 2b		sta $082b	                STA ARGUMENT2+2
.3a42c8	e2 20		sep #$20	            SEP #$20
.3a42ca	b9 04 00	lda $0004,y	                LDA #FOR_RECORD.INCTYPE,B,Y
.3a42cd	85 2d		sta $082d	                STA ARGTYPE2
.3a42cf	c2 20		rep #$20	            REP #$20
.3a42d1	5a		phy		                PHY
.3a42d2	20 df 27	jsr $3a27df	            JSR OP_PLUS
.3a42d5	20 7f 53	jsr $3a537f	            JSR VAR_SET
.3a42d8	7a		ply		                PLY
.3a42d9	c2 20		rep #$20	            REP #$20
.3a42db	b9 06 00	lda $0006,y	                LDA #FOR_RECORD.FINAL,B,Y       ; ARGUMENT2 := FOR_RECORD.FINAL
.3a42de	85 29		sta $0829	                STA ARGUMENT2
.3a42e0	b9 08 00	lda $0008,y	                LDA #FOR_RECORD.FINAL+2,B,Y
.3a42e3	85 2b		sta $082b	                STA ARGUMENT2+2
.3a42e5	e2 20		sep #$20	            SEP #$20
.3a42e7	b9 0a 00	lda $000a,y	                LDA #FOR_RECORD.FINALTYPE,B,Y
.3a42ea	85 2d		sta $082d	                STA ARGTYPE2
.3a42ec	c2 20		rep #$20	            REP #$20
.3a42ee	b9 02 00	lda $0002,y	                LDA #FOR_RECORD.INCREMENT+2,B,Y ; Check the increment's sign
.3a42f1	30 0a		bmi $3a42fd	                BMI going_down
.3a42f3					going_up
.3a42f3	20 68 2a	jsr $3a2a68	            JSR OP_LTE
.3a42f6	20 1a 06	jsr $3a061a	            JSR IS_ARG1_Z
.3a42f9	f0 28		beq $3a4323	                BEQ end_loop                    ; No: end the loop
.3a42fb	80 08		bra $3a4305	                BRA loop_back                   ; Yes: loop back
.3a42fd					going_down
.3a42fd	20 28 2a	jsr $3a2a28	            JSR OP_GTE
.3a4300	20 1a 06	jsr $3a061a	            JSR IS_ARG1_Z
.3a4303	f0 1e		beq $3a4323	                BEQ end_loop                    ; No: end the loop
.3a4305					loop_back
.3a4305	c2 20		rep #$20	            REP #$20
.3a4307	b9 12 00	lda $0012,y	                LDA #FOR_RECORD.BIP,B,Y
.3a430a	85 00		sta $0800	                STA BIP
.3a430c	b9 14 00	lda $0014,y	                LDA #FOR_RECORD.BIP+2,B,Y
.3a430f	85 02		sta $0802	                STA BIP+2
.3a4311	b9 16 00	lda $0016,y	                LDA #FOR_RECORD.CURLINE,B,Y     ; CURLINE := FOR_RECORD.CURLINE
.3a4314	85 1a		sta $081a	                STA CURLINE
.3a4316	b9 18 00	lda $0018,y	                LDA #FOR_RECORD.CURLINE+2,B,Y
.3a4319	85 1c		sta $081c	                STA CURLINE+2
.3a431b	e2 20		sep #$20	            SEP #$20
.3a431d	a9 03		lda #$03	                LDA #EXEC_RETURN
.3a431f	85 dc		sta $08dc	                STA EXECACTION
.3a4321	80 17		bra $3a433a	                BRA done
.3a4323					end_loop
.3a4323	a2 23 08	ldx #$0823	                LDX #ARGUMENT1
.3a4326	20 e9 19	jsr $3a19e9	            JSR PLARGUMENT
.3a4329	c2 20		rep #$20	            REP #$20
.3a432b	18		clc		                CLC
.3a432c	a5 33		lda $0833	                LDA RETURNSP
.3a432e	69 1a 00	adc #$001a	                ADC #size(FOR_RECORD)           ; Move pointer by number of bytes in a FOR record
.3a4331	85 33		sta $0833	                STA RETURNSP
.3a4333	a5 35		lda $0835	                LDA RETURNSP+2
.3a4335	69 00 00	adc #$0000	                ADC #0
.3a4338	85 35		sta $0835	                STA RETURNSP+2
.3a433a	ab		plb		done            PLB
.3a433b	28		plp		                PLP
.3a433c	60		rts		            RTS
.3a433d					S_GOSUB
.3a433d	08		php		                PHP
.3a433e	a5 1a		lda $081a	                LDA CURLINE                 ; Save the current line for later
.3a4340	48		pha		                PHA
.3a4341	a5 1c		lda $081c	                LDA CURLINE+2
.3a4343	48		pha		                PHA
.3a4344	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a4347	20 d8 08	jsr $3a08d8	            JSR PARSEINT
.3a434a	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.3a434c	f0 26		beq $3a4374	                BEQ syntax_err              ; If 0, no number was found... syntax error
.3a434e	20 19 24	jsr $3a2419	            JSR FINDLINE
.3a4351	90 42		bcc $3a4395	                BCC not_found               ; If not found... LINE NOT FOUND error
.3a4353	e2 20		sep #$20	            SEP #$20
.3a4355	a9 02		lda #$02	                LDA #EXEC_GOTO
.3a4357	85 dc		sta $08dc	                STA EXECACTION
.3a4359	20 5f 21	jsr $3a215f	            JSR SKIPSTMT
.3a435c	c2 20		rep #$20	            REP #$20
.3a435e	68		pla		                PLA                         ; Save the old value of CURLINE to the RETURN stack
.3a435f	20 22 1e	jsr $3a1e22	            JSR PHRETURN
.3a4362	68		pla		                PLA
.3a4363	20 22 1e	jsr $3a1e22	            JSR PHRETURN
.3a4366	a5 02		lda $0802	                LDA BIP+2                   ; Save the BASIC Instruction Pointer to the RETURN stack
.3a4368	20 22 1e	jsr $3a1e22	            JSR PHRETURN
.3a436b	a5 00		lda $0800	                LDA BIP
.3a436d	20 22 1e	jsr $3a1e22	            JSR PHRETURN
.3a4370	e6 31		inc $0831	                INC GOSUBDEPTH              ; Increase the count of GOSUBs on the stack
.3a4372	28		plp		                PLP
.3a4373	60		rts		            RTS
.3a4374	68		pla		syntax_err      PLA
.3a4375	68		pla		                PLA
.3a4376	08		php		            PHP
.3a4377	c2 20		rep #$20	            REP #$20
.3a4379	48		pha		            PHA
.3a437a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a437d	5b		tcd		            TCD
.3a437e	68		pla		            PLA
.3a437f	28		plp		            PLP
.3a4380	e2 20		sep #$20	            SEP #$20
.3a4382	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4384	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4388	c2 20		rep #$20	            REP #$20
.3a438a	29 ff 00	and #$00ff	            AND #$00FF
.3a438d	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4390	e2 20		sep #$20	            SEP #$20
.3a4392	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4395	68		pla		not_found       PLA
.3a4396	68		pla		                PLA
.3a4397	08		php		            PHP
.3a4398	c2 20		rep #$20	            REP #$20
.3a439a	48		pha		            PHA
.3a439b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a439e	5b		tcd		            TCD
.3a439f	68		pla		            PLA
.3a43a0	28		plp		            PLP
.3a43a1	e2 20		sep #$20	            SEP #$20
.3a43a3	a9 06		lda #$06	            LDA #ERR_NOLINE
.3a43a5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a43a9	c2 20		rep #$20	            REP #$20
.3a43ab	29 ff 00	and #$00ff	            AND #$00FF
.3a43ae	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a43b1	e2 20		sep #$20	            SEP #$20
.3a43b3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a43b6					S_RETURN
.3a43b6	08		php		                PHP
.3a43b7	c2 30		rep #$30	            REP #$30
.3a43b9	a5 31		lda $0831	                LDA GOSUBDEPTH              ; Check that there is at least on GOSUB on the stack
.3a43bb	f0 1e		beq $3a43db	                BEQ underflow               ; No? It's a stack underflow error
.3a43bd	20 44 1e	jsr $3a1e44	            JSR PLRETURN
.3a43c0	85 00		sta $0800	                STA BIP
.3a43c2	20 44 1e	jsr $3a1e44	            JSR PLRETURN
.3a43c5	85 02		sta $0802	                STA BIP+2
.3a43c7	20 44 1e	jsr $3a1e44	            JSR PLRETURN
.3a43ca	85 1a		sta $081a	                STA CURLINE
.3a43cc	20 44 1e	jsr $3a1e44	            JSR PLRETURN
.3a43cf	85 1c		sta $081c	                STA CURLINE+2
.3a43d1	c6 31		dec $0831	                DEC GOSUBDEPTH              ; Indicate we've popped that GOSUB off the stack
.3a43d3	e2 20		sep #$20	            SEP #$20
.3a43d5	a9 03		lda #$03	                LDA #EXEC_RETURN
.3a43d7	85 dc		sta $08dc	                STA EXECACTION
.3a43d9	28		plp		                PLP
.3a43da	60		rts		            RTS
.3a43db					underflow
.3a43db	08		php		            PHP
.3a43dc	c2 20		rep #$20	            REP #$20
.3a43de	48		pha		            PHA
.3a43df	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a43e2	5b		tcd		            TCD
.3a43e3	68		pla		            PLA
.3a43e4	28		plp		            PLP
.3a43e5	e2 20		sep #$20	            SEP #$20
.3a43e7	a9 07		lda #$07	            LDA #ERR_STACKUNDER
.3a43e9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a43ed	c2 20		rep #$20	            REP #$20
.3a43ef	29 ff 00	and #$00ff	            AND #$00FF
.3a43f2	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a43f5	e2 20		sep #$20	            SEP #$20
.3a43f7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a43fa					S_IF
.3a43fa	08		php		                PHP
.3a43fb	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a43fe	20 1a 06	jsr $3a061a	            JSR IS_ARG1_Z
.3a4401	f0 1c		beq $3a441f	                BEQ is_false                ; If so, handle the FALSE case
.3a4403	e2 20		sep #$20	            SEP #$20
.3a4405	a9 97		lda #$97	                LDA #TOK_THEN               ; Verify that the next token is THEN and eat it
.3a4407	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a440a	20 d8 08	jsr $3a08d8	            JSR PARSEINT
.3a440d	20 1a 06	jsr $3a061a	            JSR IS_ARG1_Z
.3a4410	f0 12		beq $3a4424	                BEQ syntax_err              ; If not, we have a syntax error
.3a4412	20 19 24	jsr $3a2419	            JSR FINDLINE
.3a4415	90 2c		bcc $3a4443	                BCC not_found               ; If not found... LINE NOT FOUND error
.3a4417	e2 20		sep #$20	            SEP #$20
.3a4419	a9 02		lda #$02	                LDA #EXEC_GOTO
.3a441b	85 dc		sta $08dc	                STA EXECACTION
.3a441d	80 03		bra $3a4422	                BRA done
.3a441f					is_false
.3a441f	20 5f 21	jsr $3a215f	            JSR SKIPSTMT
.3a4422	28		plp		done            PLP
.3a4423	60		rts		            RTS
.3a4424					syntax_err
.3a4424	08		php		            PHP
.3a4425	c2 20		rep #$20	            REP #$20
.3a4427	48		pha		            PHA
.3a4428	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a442b	5b		tcd		            TCD
.3a442c	68		pla		            PLA
.3a442d	28		plp		            PLP
.3a442e	e2 20		sep #$20	            SEP #$20
.3a4430	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4432	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4436	c2 20		rep #$20	            REP #$20
.3a4438	29 ff 00	and #$00ff	            AND #$00FF
.3a443b	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a443e	e2 20		sep #$20	            SEP #$20
.3a4440	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4443					not_found
.3a4443	08		php		            PHP
.3a4444	c2 20		rep #$20	            REP #$20
.3a4446	48		pha		            PHA
.3a4447	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a444a	5b		tcd		            TCD
.3a444b	68		pla		            PLA
.3a444c	28		plp		            PLP
.3a444d	e2 20		sep #$20	            SEP #$20
.3a444f	a9 06		lda #$06	            LDA #ERR_NOLINE
.3a4451	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4455	c2 20		rep #$20	            REP #$20
.3a4457	29 ff 00	and #$00ff	            AND #$00FF
.3a445a	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a445d	e2 20		sep #$20	            SEP #$20
.3a445f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4462					S_END
.3a4462	08		php		                PHP
.3a4463	e2 20		sep #$20	            SEP #$20
.3a4465	a9 01		lda #$01	                LDA #EXEC_STOP
.3a4467	85 dc		sta $08dc	                STA EXECACTION
.3a4469	28		plp		                PLP
.3a446a	60		rts		            RTS
.3a446b					S_GOTO
.3a446b	08		php		                PHP
.3a446c	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a446f	20 d8 08	jsr $3a08d8	            JSR PARSEINT
.3a4472	a5 23		lda $0823	                LDA ARGUMENT1               ; Check the number
.3a4474	f0 0d		beq $3a4483	                BEQ syntax_err              ; If 0, no number was found... syntax error
.3a4476	20 19 24	jsr $3a2419	            JSR FINDLINE
.3a4479	90 27		bcc $3a44a2	                BCC not_found               ; If not found... LINE NOT FOUND error
.3a447b	e2 20		sep #$20	            SEP #$20
.3a447d	a9 02		lda #$02	                LDA #EXEC_GOTO
.3a447f	85 dc		sta $08dc	                STA EXECACTION
.3a4481	28		plp		                PLP
.3a4482	60		rts		            RTS
.3a4483					syntax_err
.3a4483	08		php		            PHP
.3a4484	c2 20		rep #$20	            REP #$20
.3a4486	48		pha		            PHA
.3a4487	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a448a	5b		tcd		            TCD
.3a448b	68		pla		            PLA
.3a448c	28		plp		            PLP
.3a448d	e2 20		sep #$20	            SEP #$20
.3a448f	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4491	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4495	c2 20		rep #$20	            REP #$20
.3a4497	29 ff 00	and #$00ff	            AND #$00FF
.3a449a	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a449d	e2 20		sep #$20	            SEP #$20
.3a449f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a44a2					not_found
.3a44a2	08		php		            PHP
.3a44a3	c2 20		rep #$20	            REP #$20
.3a44a5	48		pha		            PHA
.3a44a6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a44a9	5b		tcd		            TCD
.3a44aa	68		pla		            PLA
.3a44ab	28		plp		            PLP
.3a44ac	e2 20		sep #$20	            SEP #$20
.3a44ae	a9 06		lda #$06	            LDA #ERR_NOLINE
.3a44b0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a44b4	c2 20		rep #$20	            REP #$20
.3a44b6	29 ff 00	and #$00ff	            AND #$00FF
.3a44b9	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a44bc	e2 20		sep #$20	            SEP #$20
.3a44be	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a44c1					S_CLR
.3a44c1	20 8b 19	jsr $3a198b	            JSR INITEVALSP
.3a44c4	20 ab 10	jsr $3a10ab	            JSR INITHEAP
.3a44c7	20 1c 51	jsr $3a511c	            JSR INITVARS
.3a44ca	60		rts		            RTS
.3a44cb					S_LET
.3a44cb	08		php		                PHP
.3a44cc	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.3a44ce	10 03		bpl $3a44d3	                BPL get_name        ; If it's not a token, try to find the variable name
.3a44d0	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a44d3					get_name
.3a44d3	20 1c 54	jsr $3a541c	            JSR VAR_FINDNAME
.3a44d6	b0 03		bcs $3a44db	                BCS check_array     ; If we didn't find a name, thrown an error
.3a44d8	4c 42 45	jmp $3a4542	                JMP syntax_err
.3a44db					check_array
.3a44db	e2 20		sep #$20	            SEP #$20
.3a44dd	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Save the variable name for later
.3a44df	48		pha		                PHA                 ; (it will get over-written by variable references)
.3a44e0	a5 e9		lda $08e9	                LDA TOFIND+2
.3a44e2	48		pha		                PHA
.3a44e3	a5 e8		lda $08e8	                LDA TOFIND+1
.3a44e5	48		pha		                PHA
.3a44e6	a5 e7		lda $08e7	                LDA TOFIND
.3a44e8	48		pha		                PHA
.3a44e9	20 7b 22	jsr $3a227b	            JSR PEEK_TOK
.3a44ec	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it a "("
.3a44ee	d0 0e		bne $3a44fe	                BNE get_value       ; No: it's a scalar assignment, look for the "="
.3a44f0	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a44f2	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a44f5	a9 00		lda #$00	                LDA #0
.3a44f7	8f 00 4d 00	sta $004d00	                STA @l ARRIDXBUF    ; Blank out the array index buffer
.3a44fb	20 0a 1b	jsr $3a1b0a	            JSR ARR_GETIDX
.3a44fe					get_value
.3a44fe	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a4501	e2 20		sep #$20	            SEP #$20
.3a4503	a7 00		lda [$0800]	                LDA [BIP]
.3a4505	c9 8a		cmp #$8a	                CMP #TOK_EQ
.3a4507	f0 03		beq $3a450c	                BEQ found_eq        ; If not found: signal an syntax error
.3a4509	4c 42 45	jmp $3a4542	                JMP syntax_err
.3a450c					found_eq
.3a450c	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a450f	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4512	68		pla		                PLA                 ; Restore the variable name
.3a4513	85 e7		sta $08e7	                STA TOFIND
.3a4515	68		pla		                PLA
.3a4516	85 e8		sta $08e8	                STA TOFIND+1
.3a4518	68		pla		                PLA
.3a4519	85 e9		sta $08e9	                STA TOFIND+2
.3a451b	68		pla		                PLA
.3a451c	85 ea		sta $08ea	                STA TOFINDTYPE
.3a451e	29 80		and #$80	                AND #$80            ; Is it an array we're setting?
.3a4520	f0 1b		beq $3a453d	                BEQ set_scalar      ; No: do a scalar variable set
.3a4522	20 8f 51	jsr $3a518f	            JSR VAR_FIND
.3a4525	90 3a		bcc $3a4561	                BCC notfound_err
.3a4527	c2 20		rep #$20	            REP #$20
.3a4529	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.3a452c	b7 08		lda [$0808],y	                LDA [INDEX],Y       ; Save the pointer to the array to CURRBLOCK
.3a452e	85 c0		sta $08c0	                STA CURRBLOCK
.3a4530	e2 20		sep #$20	            SEP #$20
.3a4532	c8		iny		                INY
.3a4533	c8		iny		                INY
.3a4534	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a4536	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a4538	20 86 68	jsr $3a6886	            JSR ARR_SET
.3a453b	80 03		bra $3a4540	                BRA done            ; and we're finished!
.3a453d					set_scalar
.3a453d	20 7f 53	jsr $3a537f	            JSR VAR_SET
.3a4540					done
.3a4540	28		plp		                PLP
.3a4541	60		rts		            RTS
.3a4542					syntax_err
.3a4542	08		php		            PHP
.3a4543	c2 20		rep #$20	            REP #$20
.3a4545	48		pha		            PHA
.3a4546	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4549	5b		tcd		            TCD
.3a454a	68		pla		            PLA
.3a454b	28		plp		            PLP
.3a454c	e2 20		sep #$20	            SEP #$20
.3a454e	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a4550	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4554	c2 20		rep #$20	            REP #$20
.3a4556	29 ff 00	and #$00ff	            AND #$00FF
.3a4559	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a455c	e2 20		sep #$20	            SEP #$20
.3a455e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4561					notfound_err
.3a4561	08		php		            PHP
.3a4562	c2 20		rep #$20	            REP #$20
.3a4564	48		pha		            PHA
.3a4565	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4568	5b		tcd		            TCD
.3a4569	68		pla		            PLA
.3a456a	28		plp		            PLP
.3a456b	e2 20		sep #$20	            SEP #$20
.3a456d	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.3a456f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4573	c2 20		rep #$20	            REP #$20
.3a4575	29 ff 00	and #$00ff	            AND #$00FF
.3a4578	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a457b	e2 20		sep #$20	            SEP #$20
.3a457d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4580					S_PRINT
.3a4580	08		php		                PHP
.3a4581	e2 20		sep #$20	            SEP #$20
.3a4583	20 7b 22	jsr $3a227b	            JSR PEEK_TOK
.3a4586	c9 00		cmp #$00	                CMP #0              ; Is it EOL or :?
.3a4588	f0 6d		beq $3a45f7	                BEQ pr_nl_exit      ; Yes: just print return
.3a458a					pr_loop
.3a458a	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a458d	e2 20		sep #$20	            SEP #$20
.3a458f	a5 27		lda $0827	                LDA ARGTYPE1        ; Get the type of the result
.3a4591	c9 ff		cmp #$ff	                CMP #TYPE_NAV       ; Is is NAV?
.3a4593	f0 1b		beq $3a45b0	                BEQ check_nl        ; Yes: we are probably just printing a newline
.3a4595	c9 02		cmp #$02	                CMP #TYPE_STRING    ; Is it a string?
.3a4597	d0 05		bne $3a459e	                BNE check_int       ; No: check to see if it's an integer
.3a4599	20 fc 45	jsr $3a45fc	            JSR PR_STRING
.3a459c	80 12		bra $3a45b0	                BRA check_nl
.3a459e	c9 00		cmp #$00	check_int       CMP #TYPE_INTEGER   ; Is it an integer?
.3a45a0	d0 05		bne $3a45a7	                BNE check_float     ; No: check to see if it is a float
.3a45a2	20 1a 46	jsr $3a461a	            JSR PR_INTEGER
.3a45a5	80 09		bra $3a45b0	                BRA check_nl
.3a45a7	c9 01		cmp #$01	check_float     CMP #TYPE_FLOAT     ; Is it a float?
.3a45a9	d0 4f		bne $3a45fa	                BNE done            ; No: just quit
.3a45ab	20 2d 46	jsr $3a462d	            JSR PR_FLOAT
.3a45ae	80 00		bra $3a45b0	                BRA check_nl
.3a45b0					check_nl
.3a45b0	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a45b3	a7 00		lda [$0800]	                LDA [BIP]
.3a45b5	f0 40		beq $3a45f7	                BEQ pr_nl_exit      ; If it's nul, print a newline and return
.3a45b7	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.3a45b9	f0 3c		beq $3a45f7	                BEQ pr_nl_exit      ; print a newline and return
.3a45bb	c9 2c		cmp #$2c	                CMP #','            ; If it's a comma
.3a45bd	f0 23		beq $3a45e2	                BEQ pr_comma        ; Print a TAB and try another expression
.3a45bf	c9 3b		cmp #$3b	                CMP #';'            ; If it's a semicolon...
.3a45c1	f0 24		beq $3a45e7	                BEQ is_more         ; Print nothing, and try another expression
.3a45c3	08		php		            PHP
.3a45c4	c2 20		rep #$20	            REP #$20
.3a45c6	48		pha		            PHA
.3a45c7	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a45ca	5b		tcd		            TCD
.3a45cb	68		pla		            PLA
.3a45cc	28		plp		            PLP
.3a45cd	e2 20		sep #$20	            SEP #$20
.3a45cf	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a45d1	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a45d5	c2 20		rep #$20	            REP #$20
.3a45d7	29 ff 00	and #$00ff	            AND #$00FF
.3a45da	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a45dd	e2 20		sep #$20	            SEP #$20
.3a45df	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a45e2	a9 09		lda #$09	pr_comma        LDA #CHAR_TAB       ; Print a TAB
.3a45e4	20 18 00	jsr $3a0018	            JSR PRINTC
.3a45e7					is_more
.3a45e7	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a45ea	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a45ed	a7 00		lda [$0800]	                LDA [BIP]           ; Get the character
.3a45ef	f0 09		beq $3a45fa	                BEQ done            ; If it's NULL, return without printing a newline
.3a45f1	c9 3a		cmp #$3a	                CMP #':'            ; If it's a colon
.3a45f3	f0 05		beq $3a45fa	                BEQ done            ; ... return without printing a newline
.3a45f5	80 93		bra $3a458a	                BRA pr_loop         ; Otherwise, we should have another expression, try to handle it
.3a45f7					pr_nl_exit
.3a45f7	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a45fa	28		plp		done            PLP
.3a45fb	60		rts		            RTS
.3a45fc					PR_STRING
.3a45fc	08		php		                PHP
.3a45fd	8b		phb		                PHB
.3a45fe	08		php		            PHP
.3a45ff	c2 20		rep #$20	            REP #$20
.3a4601	48		pha		            PHA
.3a4602	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a4605	5b		tcd		            TCD
.3a4606	68		pla		            PLA
.3a4607	28		plp		            PLP
.3a4608	e2 20		sep #$20	            SEP #$20
.3a460a	a0 00 00	ldy #$0000	start_print     LDY #0
.3a460d	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y
.3a460f	f0 06		beq $3a4617	                BEQ done
.3a4611	20 18 00	jsr $3a0018	            JSR PRINTC
.3a4614	c8		iny		                INY
.3a4615	80 f6		bra $3a460d	                BRA loop
.3a4617	ab		plb		done            PLB
.3a4618	28		plp		                PLP
.3a4619	60		rts		            RTS
.3a461a					PR_INTEGER
.3a461a	08		php		                PHP
.3a461b	c2 20		rep #$20	            REP #$20
.3a461d	20 60 15	jsr $3a1560	            JSR ITOS
.3a4620	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.3a4622	85 23		sta $0823	                STA ARGUMENT1
.3a4624	a5 18		lda $0818	                LDA STRPTR+2
.3a4626	85 25		sta $0825	                STA ARGUMENT1+2
.3a4628	20 fc 45	jsr $3a45fc	            JSR PR_STRING
.3a462b	28		plp		                PLP
.3a462c	60		rts		            RTS
.3a462d					PR_FLOAT
.3a462d	08		php		                PHP
.3a462e	20 e5 5d	jsr $3a5de5	            JSR FTOS
.3a4631	c2 20		rep #$20	            REP #$20
.3a4633	a5 16		lda $0816	                LDA STRPTR          ; Copy the pointer to the string to ARGUMENT1
.3a4635	85 23		sta $0823	                STA ARGUMENT1
.3a4637	a5 18		lda $0818	                LDA STRPTR+2
.3a4639	85 25		sta $0825	                STA ARGUMENT1+2
.3a463b	20 fc 45	jsr $3a45fc	            JSR PR_STRING
.3a463e	28		plp		                PLP
.3a463f	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\functions.s


;******  Processing file: src\C256/functions_c256.s

.3a4640					BCD2STR
.3a4640	08		php		            PHP
.3a4641	e2 20		sep #$20	            SEP #$20
.3a4643	85 b5		sta $08b5	            STA SAVE_A
.3a4645	4a		lsr a		            LSR A
.3a4646	4a		lsr a		            LSR A
.3a4647	4a		lsr a		            LSR A
.3a4648	4a		lsr a		            LSR A
.3a4649	29 0f		and #$0f	            AND #$0F
.3a464b	18		clc		            CLC
.3a464c	69 30		adc #$30	            ADC #'0'
.3a464e	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a4650	c8		iny		            INY
.3a4651	a5 b5		lda $08b5	            LDA SAVE_A
.3a4653	29 0f		and #$0f	            AND #$0F
.3a4655	18		clc		            CLC
.3a4656	69 30		adc #$30	            ADC #'0'
.3a4658	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a465a	c8		iny		            INY
.3a465b	28		plp		            PLP
.3a465c	60		rts		            RTS
.3a465d					F_GETDATE
.3a465d	e2 20		sep #$20	            SEP #$20
.3a465f	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4661	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4664	08		php		            PHP
.3a4665	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4668	e2 20		sep #$20	            SEP #$20
.3a466a	c2 10		rep #$10	            REP #$10
.3a466c	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.3a4670	09 08		ora #$08	            ORA #%00001000
.3a4672	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.3a4676	20 01 15	jsr $3a1501	            JSR TEMPSTRING
.3a4679	a0 00 00	ldy #$0000	            LDY #0
.3a467c	af 06 08 af	lda $af0806	            LDA @lRTC_DAY           ; Write the day of the month
.3a4680	20 40 46	jsr $3a4640	            JSR BCD2STR
.3a4683	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.3a4685	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a4687	c8		iny		            INY
.3a4688	af 09 08 af	lda $af0809	            LDA @lRTC_MONTH         ; Write the month
.3a468c	20 40 46	jsr $3a4640	            JSR BCD2STR
.3a468f	a9 2f		lda #$2f	            LDA #'/'                ; Write the separator
.3a4691	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a4693	c8		iny		            INY
.3a4694	af 0f 08 af	lda $af080f	            LDA @lRTC_CENTURY       ; Write the year
.3a4698	20 40 46	jsr $3a4640	            JSR BCD2STR
.3a469b	af 0a 08 af	lda $af080a	            LDA @lRTC_YEAR          ; Write the year
.3a469f	20 40 46	jsr $3a4640	            JSR BCD2STR
.3a46a2	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.3a46a4	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a46a6	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.3a46aa	29 f7		and #$f7	            AND #%11110111
.3a46ac	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.3a46b0	c2 20		rep #$20	            REP #$20
.3a46b2	a5 16		lda $0816	            LDA STRPTR
.3a46b4	85 23		sta $0823	            STA ARGUMENT1
.3a46b6	a5 18		lda $0818	            LDA STRPTR+2
.3a46b8	85 25		sta $0825	            STA ARGUMENT1+2
.3a46ba	e2 20		sep #$20	            SEP #$20
.3a46bc	a9 02		lda #$02	            LDA #TYPE_STRING
.3a46be	85 27		sta $0827	            STA ARGTYPE1
.3a46c0	28		plp		            PLP
.3a46c1	e2 20		sep #$20	            SEP #$20
.3a46c3	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a46c6	60		rts		            RTS
.3a46c7					F_GETTIME
.3a46c7	e2 20		sep #$20	            SEP #$20
.3a46c9	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a46cb	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a46ce	08		php		            PHP
.3a46cf	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a46d2	e2 20		sep #$20	            SEP #$20
.3a46d4	c2 10		rep #$10	            REP #$10
.3a46d6	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Pause updates to the clock registers
.3a46da	09 08		ora #$08	            ORA #%00001000
.3a46dc	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.3a46e0	20 01 15	jsr $3a1501	            JSR TEMPSTRING
.3a46e3	a0 00 00	ldy #$0000	            LDY #0
.3a46e6	af 04 08 af	lda $af0804	            LDA @lRTC_HRS           ; Write the hour
.3a46ea	29 7f		and #$7f	            AND #$7F                ; Trim out the AM/PM indicator
.3a46ec	20 40 46	jsr $3a4640	            JSR BCD2STR
.3a46ef	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.3a46f1	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a46f3	c8		iny		            INY
.3a46f4	af 02 08 af	lda $af0802	            LDA @lRTC_MIN           ; Write the minute
.3a46f8	20 40 46	jsr $3a4640	            JSR BCD2STR
.3a46fb	a9 3a		lda #$3a	            LDA #':'                ; Write the separator
.3a46fd	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a46ff	c8		iny		            INY
.3a4700	af 00 08 af	lda $af0800	            LDA @lRTC_SEC           ; Write the second
.3a4704	20 40 46	jsr $3a4640	            JSR BCD2STR
.3a4707	a9 00		lda #$00	            LDA #0                  ; NULL terminate the string
.3a4709	97 16		sta [$0816],y	            STA [STRPTR],Y
.3a470b	af 0e 08 af	lda $af080e	            LDA @lRTC_CTRL          ; Re-enable updates to the clock registers
.3a470f	29 f7		and #$f7	            AND #%11110111
.3a4711	8f 0e 08 af	sta $af080e	            STA @lRTC_CTRL
.3a4715	c2 20		rep #$20	            REP #$20
.3a4717	a5 16		lda $0816	            LDA STRPTR
.3a4719	85 23		sta $0823	            STA ARGUMENT1
.3a471b	a5 18		lda $0818	            LDA STRPTR+2
.3a471d	85 25		sta $0825	            STA ARGUMENT1+2
.3a471f	e2 20		sep #$20	            SEP #$20
.3a4721	a9 02		lda #$02	            LDA #TYPE_STRING
.3a4723	85 27		sta $0827	            STA ARGTYPE1
.3a4725	28		plp		            PLP
.3a4726	e2 20		sep #$20	            SEP #$20
.3a4728	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a472b	60		rts		            RTS
.3a472c					FN_RND
.3a472c	e2 20		sep #$20	            SEP #$20
.3a472e	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4730	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4733	08		php		            PHP
.3a4734	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4737	e2 20		sep #$20	            SEP #$20
.3a4739	a9 01		lda #$01	            LDA #TYPE_FLOAT             ; We'll return a floating point number
.3a473b	85 27		sta $0827	            STA ARGTYPE1
.3a473d	a9 03		lda #$03	            LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.3a473f	8f 00 e2 af	sta $afe200	            STA @l FP_MATH_CTRL0        ; Expect fixed point numbers
.3a4743	a9 01		lda #$01	            LDA #FP_OUT_DIV             ; Set us to do a division
.3a4745	8f 01 e2 af	sta $afe201	            STA @l FP_MATH_CTRL1
.3a4749	c2 30		rep #$30	            REP #$30
.3a474b	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get a random 16-bits
.3a474f	8f 08 e2 af	sta $afe208	            STA @l FP_MATH_INPUT0_LL    ; Send them to the FP unit
.3a4753	af 84 e8 af	lda $afe884	            LDA @l GABE_RNG_DAT_LO      ; Get another random 16-bits
.3a4757	29 ff 7f	and #$7fff	            AND #$7FFF                  ; Make sure it's positive
.3a475a	8f 0a e2 af	sta $afe20a	            STA @l FP_MATH_INPUT0_LL+2  ; Send them to the FP unit
.3a475e	a9 ff ff	lda #$ffff	            LDA #$FFFF                  ; Get the maximum value
.3a4761	8f 0c e2 af	sta $afe20c	            STA @l FP_MATH_INPUT1_LL    ; Send it to the FP unit
.3a4765	a9 ff 7f	lda #$7fff	            LDA #$7FFF
.3a4768	8f 0e e2 af	sta $afe20e	            STA @l FP_MATH_INPUT1_LL+2
.3a476c	ea		nop		            NOP
.3a476d	ea		nop		            NOP
.3a476e	ea		nop		            NOP
.3a476f	af 08 e2 af	lda $afe208	            LDA @l FP_MATH_OUTPUT_FP_LL     ; Get the normalized result
.3a4773	85 23		sta $0823	            STA ARGUMENT1
.3a4775	af 0a e2 af	lda $afe20a	            LDA @l FP_MATH_OUTPUT_FP_LL+2
.3a4779	85 25		sta $0825	            STA ARGUMENT1+2
.3a477b	28		plp		            PLP
.3a477c	e2 20		sep #$20	            SEP #$20
.3a477e	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4781	60		rts		            RTS
.3a4782					FN_INKEY
.3a4782	e2 20		sep #$20	            SEP #$20
.3a4784	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4786	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4789	08		php		            PHP
.3a478a	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a478d	22 28 10 00	jsl $001028	            JSL FK_GETSCANCODE          ; Get the scan code
.3a4791	e2 20		sep #$20	            SEP #$20
.3a4793	85 23		sta $0823	            STA ARGUMENT1
.3a4795	64 24		stz $0824	            STZ ARGUMENT1+1
.3a4797	64 25		stz $0825	            STZ ARGUMENT1+2
.3a4799	64 26		stz $0826	            STZ ARGUMENT1+3
.3a479b	a9 00		lda #$00	            LDA #TYPE_INTEGER           ; We'll return an integer number
.3a479d	85 27		sta $0827	            STA ARGTYPE1
.3a479f	28		plp		            PLP
.3a47a0	e2 20		sep #$20	            SEP #$20
.3a47a2	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a47a5	60		rts		            RTS

;******  Return to file: src\functions.s

.3a47a6					FN_MID
.3a47a6	e2 20		sep #$20	            SEP #$20
.3a47a8	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a47aa	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a47ad	08		php		                PHP
.3a47ae	c2 30		rep #$30	            REP #$30
.3a47b0	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a47b3	20 e3 06	jsr $3a06e3	            JSR ASS_ARG1_STR
.3a47b6					save_string
.3a47b6	c2 20		rep #$20	            REP #$20
.3a47b8	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.3a47ba	48		pha		                PHA
.3a47bb	a5 23		lda $0823	                LDA ARGUMENT1
.3a47bd	48		pha		                PHA
.3a47be	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a47c1	e2 20		sep #$20	            SEP #$20
.3a47c3	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.3a47c5	c9 2c		cmp #$2c	                CMP #','
.3a47c7	f0 03		beq $3a47cc	                BEQ skip_comma1
.3a47c9	4c 1d 48	jmp $3a481d	                JMP syntax_err
.3a47cc					skip_comma1
.3a47cc	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a47cf	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a47d2	20 0d 07	jsr $3a070d	            JSR ASS_ARG1_INT16
.3a47d5	c2 20		rep #$20	            REP #$20
.3a47d7	a5 23		lda $0823	                LDA ARGUMENT1               ; Save the index
.3a47d9	48		pha		                PHA
.3a47da	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a47dd	e2 20		sep #$20	            SEP #$20
.3a47df	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.3a47e1	c9 2c		cmp #$2c	                CMP #','
.3a47e3	f0 03		beq $3a47e8	                BEQ skip_comma2
.3a47e5	4c 1d 48	jmp $3a481d	                JMP syntax_err
.3a47e8					skip_comma2
.3a47e8	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a47eb	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a47ee	20 0d 07	jsr $3a070d	            JSR ASS_ARG1_INT16
.3a47f1	c2 20		rep #$20	            REP #$20
.3a47f3	a5 23		lda $0823	            LDA ARGUMENT1
.3a47f5	85 8f		sta $088f	            STA MCOUNT
.3a47f7	e2 20		sep #$20	            SEP #$20
.3a47f9	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a47fb	85 91		sta $0891	            STA MCOUNT+2
.3a47fd	c2 20		rep #$20	            REP #$20
.3a47ff	68		pla		                PLA                         ; Restore index
.3a4800	85 29		sta $0829	                STA ARGUMENT2               ; ... to ARGUMENT2
.3a4802	a9 00 00	lda #$0000	                LDA #0
.3a4805	85 2b		sta $082b	                STA ARGUMENT2+2
.3a4807	68		pla		                PLA                         ; Restore string
.3a4808	85 23		sta $0823	                STA ARGUMENT1               ; ... to ARGUMENT1
.3a480a	68		pla		                PLA
.3a480b	85 25		sta $0825	                STA ARGUMENT1+2
.3a480d	e2 20		sep #$20	            SEP #$20
.3a480f	a9 02		lda #$02	            LDA #<TYPE_STRING
.3a4811	85 27		sta $0827	            STA ARGTYPE1
.3a4813	20 59 17	jsr $3a1759	            JSR STRSUBSTR
.3a4816					done
.3a4816	e2 20		sep #$20	            SEP #$20
.3a4818	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a481b	28		plp		                PLP
.3a481c	60		rts		            RTS
.3a481d					syntax_err
.3a481d	08		php		            PHP
.3a481e	c2 20		rep #$20	            REP #$20
.3a4820	48		pha		            PHA
.3a4821	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4824	5b		tcd		            TCD
.3a4825	68		pla		            PLA
.3a4826	28		plp		            PLP
.3a4827	e2 20		sep #$20	            SEP #$20
.3a4829	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a482b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a482f	c2 20		rep #$20	            REP #$20
.3a4831	29 ff 00	and #$00ff	            AND #$00FF
.3a4834	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4837	e2 20		sep #$20	            SEP #$20
.3a4839	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a483c					range_err
.3a483c	08		php		            PHP
.3a483d	c2 20		rep #$20	            REP #$20
.3a483f	48		pha		            PHA
.3a4840	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4843	5b		tcd		            TCD
.3a4844	68		pla		            PLA
.3a4845	28		plp		            PLP
.3a4846	e2 20		sep #$20	            SEP #$20
.3a4848	a9 09		lda #$09	            LDA #ERR_RANGE
.3a484a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a484e	c2 20		rep #$20	            REP #$20
.3a4850	29 ff 00	and #$00ff	            AND #$00FF
.3a4853	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4856	e2 20		sep #$20	            SEP #$20
.3a4858	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a485b					FN_RIGHT
.3a485b	e2 20		sep #$20	            SEP #$20
.3a485d	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a485f	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4862	08		php		                PHP
.3a4863	c2 30		rep #$30	            REP #$30
.3a4865	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4868	e2 20		sep #$20	            SEP #$20
.3a486a	a5 27		lda $0827	                LDA ARGTYPE1
.3a486c	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a486e	f0 03		beq $3a4873	                BEQ save_string
.3a4870	4c df 48	jmp $3a48df	                JMP type_mismatch           ; Type mismatch if it's not a string
.3a4873					save_string
.3a4873	c2 20		rep #$20	            REP #$20
.3a4875	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.3a4877	48		pha		                PHA
.3a4878	a5 23		lda $0823	                LDA ARGUMENT1
.3a487a	48		pha		                PHA
.3a487b	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a487e	e2 20		sep #$20	            SEP #$20
.3a4880	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.3a4882	c9 2c		cmp #$2c	                CMP #','
.3a4884	f0 03		beq $3a4889	                BEQ skip_comma
.3a4886	4c fe 48	jmp $3a48fe	                JMP syntax_err
.3a4889					skip_comma
.3a4889	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a488c	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a488f	e2 20		sep #$20	            SEP #$20
.3a4891	a5 27		lda $0827	                LDA ARGTYPE1
.3a4893	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4895	d0 48		bne $3a48df	                BNE type_mismatch           ; Type mismatch if it's not an integer
.3a4897	c2 20		rep #$20	            REP #$20
.3a4899	a5 23		lda $0823	            LDA ARGUMENT1
.3a489b	85 8f		sta $088f	            STA MCOUNT
.3a489d	c2 20		rep #$20	            REP #$20
.3a489f	68		pla		                PLA                         ; Recover the string pointer
.3a48a0	85 23		sta $0823	                STA ARGUMENT1
.3a48a2	68		pla		                PLA
.3a48a3	85 25		sta $0825	                STA ARGUMENT1+2
.3a48a5	e2 20		sep #$20	            SEP #$20
.3a48a7	a9 02		lda #$02	            LDA #<TYPE_STRING
.3a48a9	85 27		sta $0827	            STA ARGTYPE1
.3a48ab	e2 20		sep #$20	            SEP #$20
.3a48ad	a0 00 00	ldy #$0000	                LDY #0
.3a48b0	b7 23		lda [$0823],y	count_loop      LDA [ARGUMENT1],Y
.3a48b2	f0 03		beq $3a48b7	                BEQ count_done
.3a48b4	c8		iny		                INY
.3a48b5	80 f9		bra $3a48b0	                BRA count_loop
.3a48b7					count_done
.3a48b7	c2 20		rep #$20	            REP #$20
.3a48b9	98		tya		                TYA                         ; ARGUMENT2 := LENGTH - MCOUNT
.3a48ba	38		sec		                SEC
.3a48bb	e5 8f		sbc $088f	                SBC MCOUNT
.3a48bd	30 09		bmi $3a48c8	                BMI index0                  ; if ARGUMENT2 < 0, set ARGUMENT2 := 0
.3a48bf	85 29		sta $0829	                STA ARGUMENT2
.3a48c1	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT2[23..16] := 0
.3a48c4	85 2b		sta $082b	                STA ARGUMENT2+2
.3a48c6	80 07		bra $3a48cf	                BRA slice
.3a48c8	a9 00 00	lda #$0000	index0          LDA #0                      ; 0 is the floor for the index
.3a48cb	85 29		sta $0829	                STA ARGUMENT2
.3a48cd	85 2b		sta $082b	                STA ARGUMENT2+2
.3a48cf					slice
.3a48cf	e2 20		sep #$20	            SEP #$20
.3a48d1	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.3a48d3	85 2d		sta $082d	            STA ARGTYPE2
.3a48d5	20 59 17	jsr $3a1759	            JSR STRSUBSTR
.3a48d8					done
.3a48d8	e2 20		sep #$20	            SEP #$20
.3a48da	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a48dd	28		plp		                PLP
.3a48de	60		rts		            RTS
.3a48df					type_mismatch
.3a48df	08		php		            PHP
.3a48e0	c2 20		rep #$20	            REP #$20
.3a48e2	48		pha		            PHA
.3a48e3	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a48e6	5b		tcd		            TCD
.3a48e7	68		pla		            PLA
.3a48e8	28		plp		            PLP
.3a48e9	e2 20		sep #$20	            SEP #$20
.3a48eb	a9 04		lda #$04	            LDA #ERR_TYPE
.3a48ed	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a48f1	c2 20		rep #$20	            REP #$20
.3a48f3	29 ff 00	and #$00ff	            AND #$00FF
.3a48f6	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a48f9	e2 20		sep #$20	            SEP #$20
.3a48fb	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a48fe					syntax_err
.3a48fe	08		php		            PHP
.3a48ff	c2 20		rep #$20	            REP #$20
.3a4901	48		pha		            PHA
.3a4902	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4905	5b		tcd		            TCD
.3a4906	68		pla		            PLA
.3a4907	28		plp		            PLP
.3a4908	e2 20		sep #$20	            SEP #$20
.3a490a	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a490c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4910	c2 20		rep #$20	            REP #$20
.3a4912	29 ff 00	and #$00ff	            AND #$00FF
.3a4915	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4918	e2 20		sep #$20	            SEP #$20
.3a491a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a491d					range_err
.3a491d	08		php		            PHP
.3a491e	c2 20		rep #$20	            REP #$20
.3a4920	48		pha		            PHA
.3a4921	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4924	5b		tcd		            TCD
.3a4925	68		pla		            PLA
.3a4926	28		plp		            PLP
.3a4927	e2 20		sep #$20	            SEP #$20
.3a4929	a9 09		lda #$09	            LDA #ERR_RANGE
.3a492b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a492f	c2 20		rep #$20	            REP #$20
.3a4931	29 ff 00	and #$00ff	            AND #$00FF
.3a4934	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4937	e2 20		sep #$20	            SEP #$20
.3a4939	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a493c					FN_LEFT
.3a493c	e2 20		sep #$20	            SEP #$20
.3a493e	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4940	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4943	08		php		                PHP
.3a4944	c2 30		rep #$30	            REP #$30
.3a4946	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4949	e2 20		sep #$20	            SEP #$20
.3a494b	a5 27		lda $0827	                LDA ARGTYPE1
.3a494d	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a494f	f0 03		beq $3a4954	                BEQ save_string
.3a4951	4c a8 49	jmp $3a49a8	                JMP type_mismatch           ; Type mismatch if it's not a string
.3a4954					save_string
.3a4954	c2 20		rep #$20	            REP #$20
.3a4956	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save the pointer for later
.3a4958	48		pha		                PHA
.3a4959	a5 23		lda $0823	                LDA ARGUMENT1
.3a495b	48		pha		                PHA
.3a495c	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a495f	e2 20		sep #$20	            SEP #$20
.3a4961	a7 00		lda [$0800]	                LDA [BIP]                   ; Expect a comma
.3a4963	c9 2c		cmp #$2c	                CMP #','
.3a4965	f0 03		beq $3a496a	                BEQ skip_comma
.3a4967	4c c7 49	jmp $3a49c7	                JMP syntax_err
.3a496a					skip_comma
.3a496a	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a496d	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4970	e2 20		sep #$20	            SEP #$20
.3a4972	a5 27		lda $0827	                LDA ARGTYPE1
.3a4974	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4976	d0 30		bne $3a49a8	                BNE type_mismatch           ; Type mismatch if it's not an integer
.3a4978	c2 20		rep #$20	            REP #$20
.3a497a	a5 23		lda $0823	            LDA ARGUMENT1
.3a497c	85 8f		sta $088f	            STA MCOUNT
.3a497e	c2 20		rep #$20	            REP #$20
.3a4980	a9 00 00	lda #$0000	            LDA #<>0
.3a4983	85 29		sta $0829	            STA ARGUMENT2
.3a4985	a9 00 00	lda #$0000	            LDA #(0 >> 16)
.3a4988	85 2b		sta $082b	            STA ARGUMENT2+2
.3a498a	e2 20		sep #$20	            SEP #$20
.3a498c	a9 00		lda #$00	            LDA #<TYPE_INTEGER
.3a498e	85 2d		sta $082d	            STA ARGTYPE2
.3a4990	c2 20		rep #$20	            REP #$20
.3a4992	68		pla		                PLA                         ; Recover the string pointer
.3a4993	85 23		sta $0823	                STA ARGUMENT1
.3a4995	68		pla		                PLA
.3a4996	85 25		sta $0825	                STA ARGUMENT1+2
.3a4998	e2 20		sep #$20	            SEP #$20
.3a499a	a9 02		lda #$02	            LDA #<TYPE_STRING
.3a499c	85 27		sta $0827	            STA ARGTYPE1
.3a499e	20 59 17	jsr $3a1759	            JSR STRSUBSTR
.3a49a1					done
.3a49a1	e2 20		sep #$20	            SEP #$20
.3a49a3	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a49a6	28		plp		                PLP
.3a49a7	60		rts		            RTS
.3a49a8					type_mismatch
.3a49a8	08		php		            PHP
.3a49a9	c2 20		rep #$20	            REP #$20
.3a49ab	48		pha		            PHA
.3a49ac	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a49af	5b		tcd		            TCD
.3a49b0	68		pla		            PLA
.3a49b1	28		plp		            PLP
.3a49b2	e2 20		sep #$20	            SEP #$20
.3a49b4	a9 04		lda #$04	            LDA #ERR_TYPE
.3a49b6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a49ba	c2 20		rep #$20	            REP #$20
.3a49bc	29 ff 00	and #$00ff	            AND #$00FF
.3a49bf	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a49c2	e2 20		sep #$20	            SEP #$20
.3a49c4	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a49c7					syntax_err
.3a49c7	08		php		            PHP
.3a49c8	c2 20		rep #$20	            REP #$20
.3a49ca	48		pha		            PHA
.3a49cb	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a49ce	5b		tcd		            TCD
.3a49cf	68		pla		            PLA
.3a49d0	28		plp		            PLP
.3a49d1	e2 20		sep #$20	            SEP #$20
.3a49d3	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a49d5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a49d9	c2 20		rep #$20	            REP #$20
.3a49db	29 ff 00	and #$00ff	            AND #$00FF
.3a49de	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a49e1	e2 20		sep #$20	            SEP #$20
.3a49e3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a49e6					range_err
.3a49e6	08		php		            PHP
.3a49e7	c2 20		rep #$20	            REP #$20
.3a49e9	48		pha		            PHA
.3a49ea	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a49ed	5b		tcd		            TCD
.3a49ee	68		pla		            PLA
.3a49ef	28		plp		            PLP
.3a49f0	e2 20		sep #$20	            SEP #$20
.3a49f2	a9 09		lda #$09	            LDA #ERR_RANGE
.3a49f4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a49f8	c2 20		rep #$20	            REP #$20
.3a49fa	29 ff 00	and #$00ff	            AND #$00FF
.3a49fd	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4a00	e2 20		sep #$20	            SEP #$20
.3a4a02	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4a05					FN_VAL
.3a4a05	e2 20		sep #$20	            SEP #$20
.3a4a07	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4a09	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4a0c	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4a0f	c2 10		rep #$10	            REP #$10
.3a4a11	e2 20		sep #$20	            SEP #$20
.3a4a13	a5 27		lda $0827	                LDA ARGTYPE1
.3a4a15	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a4a17	d0 23		bne $3a4a3c	                BNE type_mismatch
.3a4a19	c2 20		rep #$20	            REP #$20
.3a4a1b	a5 00		lda $0800	                LDA BIP             ; preserve BIP for later
.3a4a1d	85 40		sta $0840	                STA SAVEBIP
.3a4a1f	a5 02		lda $0802	                LDA BIP+2
.3a4a21	85 42		sta $0842	                STA SAVEBIP+2
.3a4a23	a5 23		lda $0823	                LDA ARGUMENT1       ; Temporarily point BIP to the string to parse
.3a4a25	85 00		sta $0800	                STA BIP
.3a4a27	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4a29	85 02		sta $0802	                STA BIP+2
.3a4a2b	20 d8 08	jsr $3a08d8	            JSR PARSEINT
.3a4a2e	a5 40		lda $0840	                LDA SAVEBIP         ; Restore BIP
.3a4a30	85 00		sta $0800	                STA BIP
.3a4a32	a5 42		lda $0842	                LDA SAVEBIP+2
.3a4a34	85 02		sta $0802	                STA BIP+2
.3a4a36	e2 20		sep #$20	            SEP #$20
.3a4a38	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4a3b	60		rts		            RTS
.3a4a3c					type_mismatch
.3a4a3c	08		php		            PHP
.3a4a3d	c2 20		rep #$20	            REP #$20
.3a4a3f	48		pha		            PHA
.3a4a40	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4a43	5b		tcd		            TCD
.3a4a44	68		pla		            PLA
.3a4a45	28		plp		            PLP
.3a4a46	e2 20		sep #$20	            SEP #$20
.3a4a48	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4a4a	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4a4e	c2 20		rep #$20	            REP #$20
.3a4a50	29 ff 00	and #$00ff	            AND #$00FF
.3a4a53	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4a56	e2 20		sep #$20	            SEP #$20
.3a4a58	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4a5b					FN_STR
.3a4a5b	e2 20		sep #$20	            SEP #$20
.3a4a5d	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4a5f	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4a62	08		php		                PHP
.3a4a63	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4a66	c2 10		rep #$10	            REP #$10
.3a4a68	e2 20		sep #$20	            SEP #$20
.3a4a6a	a5 27		lda $0827	                LDA ARGTYPE1
.3a4a6c	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4a6e	d0 1a		bne $3a4a8a	                BNE type_mismatch
.3a4a70	20 60 15	jsr $3a1560	            JSR ITOS
.3a4a73	c2 20		rep #$20	            REP #$20
.3a4a75	a5 16		lda $0816	                LDA STRPTR          ; Prepare the return result
.3a4a77	85 23		sta $0823	                STA ARGUMENT1
.3a4a79	a5 18		lda $0818	                LDA STRPTR+2
.3a4a7b	85 25		sta $0825	                STA ARGUMENT1+2
.3a4a7d	e2 20		sep #$20	            SEP #$20
.3a4a7f	a9 02		lda #$02	                LDA #TYPE_STRING
.3a4a81	85 27		sta $0827	                STA ARGTYPE1
.3a4a83	28		plp		                PLP
.3a4a84	e2 20		sep #$20	            SEP #$20
.3a4a86	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4a89	60		rts		            RTS
.3a4a8a					type_mismatch
.3a4a8a	08		php		            PHP
.3a4a8b	c2 20		rep #$20	            REP #$20
.3a4a8d	48		pha		            PHA
.3a4a8e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4a91	5b		tcd		            TCD
.3a4a92	68		pla		            PLA
.3a4a93	28		plp		            PLP
.3a4a94	e2 20		sep #$20	            SEP #$20
.3a4a96	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4a98	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4a9c	c2 20		rep #$20	            REP #$20
.3a4a9e	29 ff 00	and #$00ff	            AND #$00FF
.3a4aa1	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4aa4	e2 20		sep #$20	            SEP #$20
.3a4aa6	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4aa9					FN_DEC
.3a4aa9	e2 20		sep #$20	            SEP #$20
.3a4aab	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4aad	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4ab0	08		php		                PHP
.3a4ab1	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4ab4	20 e3 06	jsr $3a06e3	            JSR ASS_ARG1_STR
.3a4ab7	c2 20		rep #$20	            REP #$20
.3a4ab9	64 0c		stz $080c	                STZ SCRATCH
.3a4abb	64 0e		stz $080e	                STZ SCRATCH+2
.3a4abd	e2 30		sep #$30	            SEP #$30
.3a4abf	a0 00		ldy #$00	                LDY #0
.3a4ac1	b7 23		lda [$0823],y	skip_loop       LDA [ARGUMENT1],Y
.3a4ac3	c9 20		cmp #$20	                CMP #CHAR_SP
.3a4ac5	f0 04		beq $3a4acb	                BEQ skip_char
.3a4ac7	c9 24		cmp #$24	                CMP #'$'
.3a4ac9	d0 03		bne $3a4ace	                BNE loop
.3a4acb	c8		iny		skip_char       INY
.3a4acc	80 f3		bra $3a4ac1	                BRA skip_loop
.3a4ace	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y   ; Check the character
.3a4ad0	20 0c 05	jsr $3a050c	            JSR ISHEX
.3a4ad3	90 1e		bcc $3a4af3	                BCC ret_result      ; No: return what we have so far
.3a4ad5	c2 20		rep #$20	            REP #$20
.3a4ad7	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.3a4ad9	26 0e		rol $080e	                ROL SCRATCH+2
.3a4adb	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.3a4add	26 0e		rol $080e	                ROL SCRATCH+2
.3a4adf	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.3a4ae1	26 0e		rol $080e	                ROL SCRATCH+2
.3a4ae3	06 0c		asl $080c	                ASL SCRATCH         ; Shift the result over one digit
.3a4ae5	26 0e		rol $080e	                ROL SCRATCH+2
.3a4ae7	e2 20		sep #$20	            SEP #$20
.3a4ae9	20 2d 05	jsr $3a052d	            JSR HEX2BIN
.3a4aec	05 0c		ora $080c	                ORA SCRATCH
.3a4aee	85 0c		sta $080c	                STA SCRATCH         ; And add it to the result
.3a4af0	c8		iny		                INY
.3a4af1	80 db		bra $3a4ace	                BRA loop            ; And try the next character
.3a4af3					ret_result
.3a4af3	c2 20		rep #$20	            REP #$20
.3a4af5	a5 0c		lda $080c	                LDA SCRATCH         ; Return the result
.3a4af7	85 23		sta $0823	                STA ARGUMENT1
.3a4af9	a5 0e		lda $080e	                LDA SCRATCH+2
.3a4afb	85 25		sta $0825	                STA ARGUMENT1+2
.3a4afd	e2 20		sep #$20	            SEP #$20
.3a4aff	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a4b01	85 27		sta $0827	                STA ARGTYPE1
.3a4b03	28		plp		                PLP
.3a4b04	e2 20		sep #$20	            SEP #$20
.3a4b06	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4b09	60		rts		            RTS
.3a4b0a					FN_HEX
.3a4b0a	e2 20		sep #$20	            SEP #$20
.3a4b0c	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4b0e	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4b11	08		php		                PHP
.3a4b12	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4b15	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a4b18	20 01 15	jsr $3a1501	            JSR TEMPSTRING
.3a4b1b	e2 30		sep #$30	            SEP #$30
.3a4b1d	a0 ff		ldy #$ff	                LDY #$FF            ; Terminate the string
.3a4b1f	a9 00		lda #$00	                LDA #0
.3a4b21	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a4b23	88		dey		                DEY
.3a4b24	a5 23		lda $0823	loop            LDA ARGUMENT1       ; Write the low digit
.3a4b26	29 0f		and #$0f	                AND #$0F
.3a4b28	aa		tax		                TAX
.3a4b29	bf 00 d0 3a	lda $3ad000,x	                LDA @lHEXDIGITS,X
.3a4b2d	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a4b2f	88		dey		                DEY
.3a4b30	a5 23		lda $0823	                LDA ARGUMENT1       ; Write the high digit
.3a4b32	29 f0		and #$f0	                AND #$F0
.3a4b34	4a		lsr a		                LSR A
.3a4b35	4a		lsr a		                LSR A
.3a4b36	4a		lsr a		                LSR A
.3a4b37	4a		lsr a		                LSR A
.3a4b38	aa		tax		                TAX
.3a4b39	bf 00 d0 3a	lda $3ad000,x	                LDA @lHEXDIGITS,X
.3a4b3d	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a4b3f	88		dey		                DEY
.3a4b40	a5 24		lda $0824	                LDA ARGUMENT1+1     ; Shift value by one byte
.3a4b42	85 23		sta $0823	                STA ARGUMENT1
.3a4b44	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4b46	85 24		sta $0824	                STA ARGUMENT1+1
.3a4b48	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a4b4a	85 25		sta $0825	                STA ARGUMENT1+2
.3a4b4c	a9 00		lda #$00	                LDA #0
.3a4b4e	85 26		sta $0826	                STA ARGUMENT1+3
.3a4b50	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the argument 0?
.3a4b52	d0 d0		bne $3a4b24	                BNE loop            ; No: keep converting
.3a4b54	a5 24		lda $0824	                LDA ARGUMENT1+1
.3a4b56	d0 cc		bne $3a4b24	                BNE loop
.3a4b58	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4b5a	d0 c8		bne $3a4b24	                BNE loop
.3a4b5c	98		tya		                TYA                 ; Get the index of the first free char
.3a4b5d	38		sec		                SEC                 ; Add 1 to get to the first character of the string
.3a4b5e	65 16		adc $0816	                ADC STRPTR          ; And add the whole thing to the temp string pointer
.3a4b60	85 23		sta $0823	                STA ARGUMENT1       ; And return it as the result
.3a4b62	a5 17		lda $0817	                LDA STRPTR+1
.3a4b64	85 24		sta $0824	                STA ARGUMENT1+1
.3a4b66	a5 18		lda $0818	                LDA STRPTR+2
.3a4b68	85 25		sta $0825	                STA ARGUMENT1+2
.3a4b6a	a5 19		lda $0819	                LDA STRPTR+3
.3a4b6c	85 26		sta $0826	                STA ARGUMENT1+3
.3a4b6e	a9 02		lda #$02	                LDA #TYPE_STRING    ; And make the type STRING
.3a4b70	85 27		sta $0827	                STA ARGTYPE1
.3a4b72	28		plp		                PLP
.3a4b73	e2 20		sep #$20	            SEP #$20
.3a4b75	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4b78	60		rts		            RTS
.3a4b79					type_mismatch
.3a4b79	08		php		            PHP
.3a4b7a	c2 20		rep #$20	            REP #$20
.3a4b7c	48		pha		            PHA
.3a4b7d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4b80	5b		tcd		            TCD
.3a4b81	68		pla		            PLA
.3a4b82	28		plp		            PLP
.3a4b83	e2 20		sep #$20	            SEP #$20
.3a4b85	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4b87	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4b8b	c2 20		rep #$20	            REP #$20
.3a4b8d	29 ff 00	and #$00ff	            AND #$00FF
.3a4b90	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4b93	e2 20		sep #$20	            SEP #$20
.3a4b95	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4b98					FN_LEN
.3a4b98	e2 20		sep #$20	            SEP #$20
.3a4b9a	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4b9c	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4b9f	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4ba2	e2 20		sep #$20	            SEP #$20
.3a4ba4	a5 27		lda $0827	                LDA ARGTYPE1
.3a4ba6	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a4ba8	d0 1f		bne $3a4bc9	                BNE type_mismatch
.3a4baa	8b		phb		                PHB                 ; Set the data bank to the data bank of the string
.3a4bab	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4bad	48		pha		                PHA
.3a4bae	ab		plb		                PLB
.3a4baf	c2 10		rep #$10	            REP #$10
.3a4bb1	a6 23		ldx $0823	                LDX ARGUMENT1       ; And point X to the string data
.3a4bb3	20 ed 15	jsr $3a15ed	            JSR STRLEN
.3a4bb6	ab		plb		                PLB                 ; Restore the old data bank
.3a4bb7	84 23		sty $0823	                STY ARGUMENT1       ; Save the length to ARGUMENT1
.3a4bb9	c2 20		rep #$20	            REP #$20
.3a4bbb	64 25		stz $0825	                STZ ARGUMENT1+2
.3a4bbd	e2 20		sep #$20	            SEP #$20
.3a4bbf	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the type to INTEGER
.3a4bc1	85 27		sta $0827	                STA ARGTYPE1
.3a4bc3	e2 20		sep #$20	            SEP #$20
.3a4bc5	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4bc8	60		rts		            RTS
.3a4bc9					type_mismatch
.3a4bc9	08		php		            PHP
.3a4bca	c2 20		rep #$20	            REP #$20
.3a4bcc	48		pha		            PHA
.3a4bcd	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4bd0	5b		tcd		            TCD
.3a4bd1	68		pla		            PLA
.3a4bd2	28		plp		            PLP
.3a4bd3	e2 20		sep #$20	            SEP #$20
.3a4bd5	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4bd7	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4bdb	c2 20		rep #$20	            REP #$20
.3a4bdd	29 ff 00	and #$00ff	            AND #$00FF
.3a4be0	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4be3	e2 20		sep #$20	            SEP #$20
.3a4be5	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4be8					FN_PEEK
.3a4be8	e2 20		sep #$20	            SEP #$20
.3a4bea	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4bec	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4bef	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4bf2	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a4bf5	e2 20		sep #$20	            SEP #$20
.3a4bf7	a5 25		lda $0825	                LDA ARGUMENT1+2                     ; Check to see if the request is to video memory
.3a4bf9	c9 b0		cmp #$b0	                CMP #`VRAM
.3a4bfb	90 10		bcc $3a4c0d	                BLT simple_peek                     ; No: just do an ordinary PEEK
.3a4bfd	c9 f0		cmp #$f0	                CMP #$F0
.3a4bff	b0 0c		bcs $3a4c0d	                BGE simple_peek
.3a4c01	8b		phb		                PHB                                 ; DBR := bank
.3a4c02	48		pha		                PHA
.3a4c03	ab		plb		                PLB
.3a4c04	a6 23		ldx $0823	                LDX ARGUMENT1                       ; X := address
.3a4c06	22 44 11 00	jsl $001144	                JSL FK_READVRAM                     ; Fetch the low byte
.3a4c0a	ab		plb		                PLB
.3a4c0b	80 04		bra $3a4c11	                BRA save_result
.3a4c0d					simple_peek
.3a4c0d	e2 20		sep #$20	            SEP #$20
.3a4c0f	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.3a4c11	85 23		sta $0823	save_result     STA ARGUMENT1
.3a4c13	64 24		stz $0824	                STZ ARGUMENT1+1
.3a4c15	64 25		stz $0825	                STZ ARGUMENT1+2
.3a4c17	64 26		stz $0826	                STZ ARGUMENT1+3
.3a4c19	e2 20		sep #$20	            SEP #$20
.3a4c1b	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4c1e	60		rts		            RTS
.3a4c1f					type_mismatch
.3a4c1f	08		php		            PHP
.3a4c20	c2 20		rep #$20	            REP #$20
.3a4c22	48		pha		            PHA
.3a4c23	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4c26	5b		tcd		            TCD
.3a4c27	68		pla		            PLA
.3a4c28	28		plp		            PLP
.3a4c29	e2 20		sep #$20	            SEP #$20
.3a4c2b	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4c2d	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4c31	c2 20		rep #$20	            REP #$20
.3a4c33	29 ff 00	and #$00ff	            AND #$00FF
.3a4c36	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4c39	e2 20		sep #$20	            SEP #$20
.3a4c3b	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4c3e					FN_PEEKL
.3a4c3e	e2 20		sep #$20	            SEP #$20
.3a4c40	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4c42	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4c45	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4c48	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a4c4b	e2 20		sep #$20	            SEP #$20
.3a4c4d	a5 25		lda $0825	                LDA ARGUMENT1+2                     ; Check to see if the request is to video memory
.3a4c4f	c9 b0		cmp #$b0	                CMP #`VRAM
.3a4c51	90 22		bcc $3a4c75	                BLT simple_peek                     ; No: just do an ordinary PEEK
.3a4c53	c9 f0		cmp #$f0	                CMP #$F0
.3a4c55	b0 1e		bcs $3a4c75	                BGE simple_peek
.3a4c57	8b		phb		                PHB                                 ; DBR := bank
.3a4c58	48		pha		                PHA
.3a4c59	ab		plb		                PLB
.3a4c5a	a6 23		ldx $0823	                LDX ARGUMENT1                       ; X := address
.3a4c5c	da		phx		                PHX
.3a4c5d	22 44 11 00	jsl $001144	                JSL FK_READVRAM                     ; Fetch the low byte
.3a4c61	85 0c		sta $080c	                STA SCRATCH                         ; Save the low byte
.3a4c63	fa		plx		                PLX
.3a4c64	e8		inx		                INX
.3a4c65	da		phx		                PHX
.3a4c66	22 44 11 00	jsl $001144	                JSL FK_READVRAM                     ; Fetch the middle byte
.3a4c6a	85 0d		sta $080d	                STA SCRATCH+1                       ; Save the middle byte
.3a4c6c	fa		plx		                PLX
.3a4c6d	e8		inx		                INX
.3a4c6e	22 44 11 00	jsl $001144	                JSL FK_READVRAM                     ; Fetch the high byte
.3a4c72	ab		plb		                PLB
.3a4c73	80 0d		bra $3a4c82	                BRA save_result
.3a4c75					simple_peek
.3a4c75	c2 20		rep #$20	            REP #$20
.3a4c77	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.3a4c79	85 0c		sta $080c	                STA SCRATCH
.3a4c7b	e2 20		sep #$20	            SEP #$20
.3a4c7d	a0 02 00	ldy #$0002	                LDY #2
.3a4c80	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y
.3a4c82	85 25		sta $0825	save_result     STA ARGUMENT1+2
.3a4c84	64 26		stz $0826	                STZ ARGUMENT1+3
.3a4c86	c2 20		rep #$20	            REP #$20
.3a4c88	a5 0c		lda $080c	                LDA SCRATCH
.3a4c8a	85 23		sta $0823	                STA ARGUMENT1
.3a4c8c	e2 20		sep #$20	            SEP #$20
.3a4c8e	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4c91	60		rts		            RTS
.3a4c92					type_mismatch
.3a4c92	08		php		            PHP
.3a4c93	c2 20		rep #$20	            REP #$20
.3a4c95	48		pha		            PHA
.3a4c96	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4c99	5b		tcd		            TCD
.3a4c9a	68		pla		            PLA
.3a4c9b	28		plp		            PLP
.3a4c9c	e2 20		sep #$20	            SEP #$20
.3a4c9e	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4ca0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4ca4	c2 20		rep #$20	            REP #$20
.3a4ca6	29 ff 00	and #$00ff	            AND #$00FF
.3a4ca9	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4cac	e2 20		sep #$20	            SEP #$20
.3a4cae	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4cb1					FN_PEEKW
.3a4cb1	e2 20		sep #$20	            SEP #$20
.3a4cb3	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4cb5	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4cb8	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4cbb	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a4cbe	e2 20		sep #$20	            SEP #$20
.3a4cc0	a5 25		lda $0825	                LDA ARGUMENT1+2                     ; Check to see if the request is to video memory
.3a4cc2	c9 b0		cmp #$b0	                CMP #`VRAM
.3a4cc4	90 1d		bcc $3a4ce3	                BLT simple_peek                     ; No: just do an ordinary PEEK
.3a4cc6	c9 f0		cmp #$f0	                CMP #$F0
.3a4cc8	b0 19		bcs $3a4ce3	                BGE simple_peek
.3a4cca	8b		phb		                PHB                                 ; DBR := bank
.3a4ccb	48		pha		                PHA
.3a4ccc	ab		plb		                PLB
.3a4ccd	a6 23		ldx $0823	                LDX ARGUMENT1                       ; X := address
.3a4ccf	da		phx		                PHX
.3a4cd0	22 44 11 00	jsl $001144	                JSL FK_READVRAM                     ; Fetch the low byte
.3a4cd4	85 23		sta $0823	                STA ARGUMENT1                       ; Save the low byte
.3a4cd6	fa		plx		                PLX
.3a4cd7	e8		inx		                INX
.3a4cd8	22 44 11 00	jsl $001144	                JSL FK_READVRAM                     ; Fetch the high byte
.3a4cdc	85 24		sta $0824	                STA ARGUMENT1+1
.3a4cde	ab		plb		                PLB
.3a4cdf	c2 20		rep #$20	            REP #$20
.3a4ce1	80 06		bra $3a4ce9	                BRA done
.3a4ce3					simple_peek
.3a4ce3	c2 20		rep #$20	            REP #$20
.3a4ce5	a7 23		lda [$0823]	                LDA [ARGUMENT1]
.3a4ce7	85 23		sta $0823	                STA ARGUMENT1
.3a4ce9	64 25		stz $0825	done            STZ ARGUMENT1+2
.3a4ceb	e2 20		sep #$20	            SEP #$20
.3a4ced	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4cf0	60		rts		            RTS
.3a4cf1					type_mismatch
.3a4cf1	08		php		            PHP
.3a4cf2	c2 20		rep #$20	            REP #$20
.3a4cf4	48		pha		            PHA
.3a4cf5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4cf8	5b		tcd		            TCD
.3a4cf9	68		pla		            PLA
.3a4cfa	28		plp		            PLP
.3a4cfb	e2 20		sep #$20	            SEP #$20
.3a4cfd	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4cff	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4d03	c2 20		rep #$20	            REP #$20
.3a4d05	29 ff 00	and #$00ff	            AND #$00FF
.3a4d08	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4d0b	e2 20		sep #$20	            SEP #$20
.3a4d0d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4d10					FN_CHR
.3a4d10	e2 20		sep #$20	            SEP #$20
.3a4d12	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4d14	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4d17	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4d1a	e2 20		sep #$20	            SEP #$20
.3a4d1c	a5 27		lda $0827	                LDA ARGTYPE1
.3a4d1e	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4d20	d0 24		bne $3a4d46	                BNE type_mismatch
.3a4d22	20 01 15	jsr $3a1501	            JSR TEMPSTRING
.3a4d25	a5 23		lda $0823	                LDA ARGUMENT1       ; Get the numberic value
.3a4d27	87 16		sta [$0816]	                STA [STRPTR]        ; And save it as the first character
.3a4d29	a9 00		lda #$00	                LDA #0              ; Null terminate the string
.3a4d2b	a0 01 00	ldy #$0001	                LDY #1
.3a4d2e	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a4d30	c2 20		rep #$20	            REP #$20
.3a4d32	a5 16		lda $0816	                LDA STRPTR
.3a4d34	85 23		sta $0823	                STA ARGUMENT1
.3a4d36	a5 18		lda $0818	                LDA STRPTR+2
.3a4d38	85 25		sta $0825	                STA ARGUMENT1+2
.3a4d3a	e2 20		sep #$20	            SEP #$20
.3a4d3c	a9 02		lda #$02	                LDA #TYPE_STRING
.3a4d3e	85 27		sta $0827	                STA ARGTYPE1
.3a4d40	e2 20		sep #$20	            SEP #$20
.3a4d42	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4d45	60		rts		            RTS
.3a4d46					type_mismatch
.3a4d46	08		php		            PHP
.3a4d47	c2 20		rep #$20	            REP #$20
.3a4d49	48		pha		            PHA
.3a4d4a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4d4d	5b		tcd		            TCD
.3a4d4e	68		pla		            PLA
.3a4d4f	28		plp		            PLP
.3a4d50	e2 20		sep #$20	            SEP #$20
.3a4d52	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4d54	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4d58	c2 20		rep #$20	            REP #$20
.3a4d5a	29 ff 00	and #$00ff	            AND #$00FF
.3a4d5d	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4d60	e2 20		sep #$20	            SEP #$20
.3a4d62	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4d65					FN_ASC
.3a4d65	e2 20		sep #$20	            SEP #$20
.3a4d67	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4d69	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4d6c	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4d6f	e2 20		sep #$20	            SEP #$20
.3a4d71	a5 27		lda $0827	                LDA ARGTYPE1
.3a4d73	c9 02		cmp #$02	                CMP #TYPE_STRING
.3a4d75	d0 14		bne $3a4d8b	                BNE type_mismatch
.3a4d77	a7 23		lda [$0823]	                LDA [ARGUMENT1]     ; Get the character
.3a4d79	85 23		sta $0823	                STA ARGUMENT1       ; Save its code to ARGUMENT1
.3a4d7b	64 24		stz $0824	                STZ ARGUMENT1+1
.3a4d7d	64 25		stz $0825	                STZ ARGUMENT1+2
.3a4d7f	64 26		stz $0826	                STZ ARGUMENT1+3
.3a4d81	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; And set the return type to integer
.3a4d83	85 27		sta $0827	                STA ARGTYPE1
.3a4d85	e2 20		sep #$20	            SEP #$20
.3a4d87	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4d8a	60		rts		            RTS
.3a4d8b					type_mismatch
.3a4d8b	08		php		            PHP
.3a4d8c	c2 20		rep #$20	            REP #$20
.3a4d8e	48		pha		            PHA
.3a4d8f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4d92	5b		tcd		            TCD
.3a4d93	68		pla		            PLA
.3a4d94	28		plp		            PLP
.3a4d95	e2 20		sep #$20	            SEP #$20
.3a4d97	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4d99	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4d9d	c2 20		rep #$20	            REP #$20
.3a4d9f	29 ff 00	and #$00ff	            AND #$00FF
.3a4da2	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4da5	e2 20		sep #$20	            SEP #$20
.3a4da7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4daa					FN_SPC
.3a4daa	e2 20		sep #$20	            SEP #$20
.3a4dac	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4dae	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4db1	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4db4	e2 20		sep #$20	            SEP #$20
.3a4db6	a5 27		lda $0827	                LDA ARGTYPE1
.3a4db8	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4dba	d0 39		bne $3a4df5	                BNE type_mismatch
.3a4dbc	e2 20		sep #$20	            SEP #$20
.3a4dbe	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.3a4dc0	d0 52		bne $3a4e14	                BNE err_limit
.3a4dc2	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4dc4	d0 4e		bne $3a4e14	                BNE err_limit
.3a4dc6	a5 24		lda $0824	                LDA ARGUMENT1+1
.3a4dc8	d0 4a		bne $3a4e14	                BNE err_limit
.3a4dca	c2 10		rep #$10	            REP #$10
.3a4dcc	20 01 15	jsr $3a1501	            JSR TEMPSTRING
.3a4dcf	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.3a4dd1	e2 20		sep #$20	            SEP #$20
.3a4dd3	a9 00		lda #$00	                LDA #0
.3a4dd5	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.3a4dd7	88		dey		                DEY
.3a4dd8	30 07		bmi $3a4de1	                BMI done
.3a4dda	a9 20		lda #$20	                LDA #CHAR_SP
.3a4ddc	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.3a4dde	88		dey		                DEY
.3a4ddf	10 fb		bpl $3a4ddc	                BPL loop            ; And keep writing until we're done
.3a4de1	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.3a4de3	85 27		sta $0827	                STA ARGTYPE1
.3a4de5	c2 20		rep #$20	            REP #$20
.3a4de7	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.3a4de9	85 23		sta $0823	                STA ARGUMENT1
.3a4deb	a5 18		lda $0818	                LDA STRPTR+2
.3a4ded	85 25		sta $0825	                STA ARGUMENT1+2
.3a4def	e2 20		sep #$20	            SEP #$20
.3a4df1	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4df4	60		rts		            RTS
.3a4df5					type_mismatch
.3a4df5	08		php		            PHP
.3a4df6	c2 20		rep #$20	            REP #$20
.3a4df8	48		pha		            PHA
.3a4df9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4dfc	5b		tcd		            TCD
.3a4dfd	68		pla		            PLA
.3a4dfe	28		plp		            PLP
.3a4dff	e2 20		sep #$20	            SEP #$20
.3a4e01	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4e03	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4e07	c2 20		rep #$20	            REP #$20
.3a4e09	29 ff 00	and #$00ff	            AND #$00FF
.3a4e0c	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4e0f	e2 20		sep #$20	            SEP #$20
.3a4e11	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4e14					err_limit
.3a4e14	08		php		            PHP
.3a4e15	c2 20		rep #$20	            REP #$20
.3a4e17	48		pha		            PHA
.3a4e18	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4e1b	5b		tcd		            TCD
.3a4e1c	68		pla		            PLA
.3a4e1d	28		plp		            PLP
.3a4e1e	e2 20		sep #$20	            SEP #$20
.3a4e20	a9 09		lda #$09	            LDA #ERR_RANGE
.3a4e22	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4e26	c2 20		rep #$20	            REP #$20
.3a4e28	29 ff 00	and #$00ff	            AND #$00FF
.3a4e2b	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4e2e	e2 20		sep #$20	            SEP #$20
.3a4e30	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4e33					FN_TAB
.3a4e33	e2 20		sep #$20	            SEP #$20
.3a4e35	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4e37	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4e3a	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4e3d	e2 20		sep #$20	            SEP #$20
.3a4e3f	a5 27		lda $0827	                LDA ARGTYPE1
.3a4e41	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4e43	d0 39		bne $3a4e7e	                BNE type_mismatch
.3a4e45	e2 20		sep #$20	            SEP #$20
.3a4e47	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Throw an error if ARGUMENT1 is negative or > 255
.3a4e49	d0 52		bne $3a4e9d	                BNE err_limit
.3a4e4b	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4e4d	d0 4e		bne $3a4e9d	                BNE err_limit
.3a4e4f	a5 24		lda $0824	                LDA ARGUMENT1+1
.3a4e51	d0 4a		bne $3a4e9d	                BNE err_limit
.3a4e53	c2 10		rep #$10	            REP #$10
.3a4e55	20 01 15	jsr $3a1501	            JSR TEMPSTRING
.3a4e58	a4 23		ldy $0823	                LDY ARGUMENT1       ; Get the length
.3a4e5a	e2 20		sep #$20	            SEP #$20
.3a4e5c	a9 00		lda #$00	                LDA #0
.3a4e5e	97 16		sta [$0816],y	                STA [STRPTR],Y      ; Write the NULL at the end of the string
.3a4e60	88		dey		                DEY
.3a4e61	30 07		bmi $3a4e6a	                BMI done
.3a4e63	a9 09		lda #$09	                LDA #CHAR_TAB
.3a4e65	97 16		sta [$0816],y	loop            STA [STRPTR],Y      ; Write a space
.3a4e67	88		dey		                DEY
.3a4e68	10 fb		bpl $3a4e65	                BPL loop            ; And keep writing until we're done
.3a4e6a	a9 02		lda #$02	done            LDA #TYPE_STRING    ; And set the return type to STRING
.3a4e6c	85 27		sta $0827	                STA ARGTYPE1
.3a4e6e	c2 20		rep #$20	            REP #$20
.3a4e70	a5 16		lda $0816	                LDA STRPTR          ; Write the pointer to the return results
.3a4e72	85 23		sta $0823	                STA ARGUMENT1
.3a4e74	a5 18		lda $0818	                LDA STRPTR+2
.3a4e76	85 25		sta $0825	                STA ARGUMENT1+2
.3a4e78	e2 20		sep #$20	            SEP #$20
.3a4e7a	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4e7d	60		rts		            RTS
.3a4e7e					type_mismatch
.3a4e7e	08		php		            PHP
.3a4e7f	c2 20		rep #$20	            REP #$20
.3a4e81	48		pha		            PHA
.3a4e82	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4e85	5b		tcd		            TCD
.3a4e86	68		pla		            PLA
.3a4e87	28		plp		            PLP
.3a4e88	e2 20		sep #$20	            SEP #$20
.3a4e8a	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4e8c	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4e90	c2 20		rep #$20	            REP #$20
.3a4e92	29 ff 00	and #$00ff	            AND #$00FF
.3a4e95	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4e98	e2 20		sep #$20	            SEP #$20
.3a4e9a	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4e9d					err_limit
.3a4e9d	08		php		            PHP
.3a4e9e	c2 20		rep #$20	            REP #$20
.3a4ea0	48		pha		            PHA
.3a4ea1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4ea4	5b		tcd		            TCD
.3a4ea5	68		pla		            PLA
.3a4ea6	28		plp		            PLP
.3a4ea7	e2 20		sep #$20	            SEP #$20
.3a4ea9	a9 09		lda #$09	            LDA #ERR_RANGE
.3a4eab	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4eaf	c2 20		rep #$20	            REP #$20
.3a4eb1	29 ff 00	and #$00ff	            AND #$00FF
.3a4eb4	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4eb7	e2 20		sep #$20	            SEP #$20
.3a4eb9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4ebc					FN_ABS
.3a4ebc	e2 20		sep #$20	            SEP #$20
.3a4ebe	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4ec0	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4ec3	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4ec6	e2 20		sep #$20	            SEP #$20
.3a4ec8	a5 27		lda $0827	                LDA ARGTYPE1        ; Check the type
.3a4eca	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4ecc	f0 23		beq $3a4ef1	                BEQ abs_int         ; If integer, get the absolute value of the integer
.3a4ece	c9 01		cmp #$01	                CMP #TYPE_FLOAT
.3a4ed0	f0 3e		beq $3a4f10	                BEQ abs_float       ; If float, get the absolute value of the float
.3a4ed2					type_err
.3a4ed2	08		php		            PHP
.3a4ed3	c2 20		rep #$20	            REP #$20
.3a4ed5	48		pha		            PHA
.3a4ed6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4ed9	5b		tcd		            TCD
.3a4eda	68		pla		            PLA
.3a4edb	28		plp		            PLP
.3a4edc	e2 20		sep #$20	            SEP #$20
.3a4ede	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4ee0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4ee4	c2 20		rep #$20	            REP #$20
.3a4ee6	29 ff 00	and #$00ff	            AND #$00FF
.3a4ee9	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4eec	e2 20		sep #$20	            SEP #$20
.3a4eee	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4ef1					abs_int
.3a4ef1	c2 20		rep #$20	            REP #$20
.3a4ef3	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Is it positive already?
.3a4ef5	10 21		bpl $3a4f18	                BPL done            ; Yes: we don't need to do anythign further
.3a4ef7	49 ff ff	eor #$ffff	                EOR #$FFFF          ; Otherwise, take the two's compliment
.3a4efa	85 25		sta $0825	                STA ARGUMENT1+2     ; Of ARGUMENT1
.3a4efc	a5 23		lda $0823	                LDA ARGUMENT1
.3a4efe	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a4f01	18		clc		                CLC
.3a4f02	69 01 00	adc #$0001	                ADC #1
.3a4f05	85 23		sta $0823	                STA ARGUMENT1       ; And save it back to ARGUMENT1
.3a4f07	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4f09	69 00 00	adc #$0000	                ADC #0
.3a4f0c	85 25		sta $0825	                STA ARGUMENT1+2
.3a4f0e	80 08		bra $3a4f18	                BRA done
.3a4f10					abs_float
.3a4f10	e2 20		sep #$20	            SEP #$20
.3a4f12	a5 26		lda $0826	                LDA ARGUMENT1+3     ; Just clear the sign bit
.3a4f14	29 7f		and #$7f	                AND #$7F
.3a4f16	85 26		sta $0826	                STA ARGUMENT1+3
.3a4f18					done
.3a4f18	e2 20		sep #$20	            SEP #$20
.3a4f1a	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4f1d	60		rts		            RTS
.3a4f1e					FN_SGN
.3a4f1e	e2 20		sep #$20	            SEP #$20
.3a4f20	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4f22	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4f25	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4f28	e2 20		sep #$20	            SEP #$20
.3a4f2a	a5 27		lda $0827	                LDA ARGTYPE1
.3a4f2c	c9 00		cmp #$00	                CMP #TYPE_INTEGER
.3a4f2e	d0 25		bne $3a4f55	                BNE type_mismatch
.3a4f30	c2 20		rep #$20	            REP #$20
.3a4f32	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a4f34	30 12		bmi $3a4f48	                BMI is_negative     ; Negative: return -1
.3a4f36	d0 04		bne $3a4f3c	                BNE is_positive     ; Is it not 0? Then return 1
.3a4f38	a5 23		lda $0823	                LDA ARGUMENT1       ; Is the lower word 0?
.3a4f3a	f0 13		beq $3a4f4f	                BEQ done            ; Yes: the whole thing is zero: return 0
.3a4f3c	a9 00 00	lda #$0000	is_positive     LDA #0              ; It's positive: return 1
.3a4f3f	85 25		sta $0825	                STA ARGUMENT1+2
.3a4f41	a9 01 00	lda #$0001	                LDA #1
.3a4f44	85 23		sta $0823	                STA ARGUMENT1
.3a4f46	80 07		bra $3a4f4f	                BRA done
.3a4f48	a9 ff ff	lda #$ffff	is_negative     LDA #$FFFF          ; It's negative: return -1
.3a4f4b	85 25		sta $0825	                STA ARGUMENT1+2
.3a4f4d	85 23		sta $0823	                STA ARGUMENT1
.3a4f4f					done
.3a4f4f	e2 20		sep #$20	            SEP #$20
.3a4f51	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4f54	60		rts		            RTS
.3a4f55					type_mismatch
.3a4f55	08		php		            PHP
.3a4f56	c2 20		rep #$20	            REP #$20
.3a4f58	48		pha		            PHA
.3a4f59	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a4f5c	5b		tcd		            TCD
.3a4f5d	68		pla		            PLA
.3a4f5e	28		plp		            PLP
.3a4f5f	e2 20		sep #$20	            SEP #$20
.3a4f61	a9 04		lda #$04	            LDA #ERR_TYPE
.3a4f63	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a4f67	c2 20		rep #$20	            REP #$20
.3a4f69	29 ff 00	and #$00ff	            AND #$00FF
.3a4f6c	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a4f6f	e2 20		sep #$20	            SEP #$20
.3a4f71	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a4f74					FN_INT
.3a4f74	e2 20		sep #$20	            SEP #$20
.3a4f76	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4f78	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4f7b	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4f7e	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a4f81					done
.3a4f81	e2 20		sep #$20	            SEP #$20
.3a4f83	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4f86	60		rts		            RTS
.3a4f87					FN_SIN
.3a4f87	e2 20		sep #$20	            SEP #$20
.3a4f89	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4f8b	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4f8e	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4f91	20 bf 07	jsr $3a07bf	            JSR ASS_ARG1_FLOAT
.3a4f94	20 45 62	jsr $3a6245	            JSR FP_SIN
.3a4f97					done
.3a4f97	e2 20		sep #$20	            SEP #$20
.3a4f99	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4f9c	60		rts		            RTS
.3a4f9d					FN_COS
.3a4f9d	e2 20		sep #$20	            SEP #$20
.3a4f9f	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4fa1	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4fa4	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4fa7	20 bf 07	jsr $3a07bf	            JSR ASS_ARG1_FLOAT
.3a4faa	20 74 62	jsr $3a6274	            JSR FP_COS
.3a4fad					done
.3a4fad	e2 20		sep #$20	            SEP #$20
.3a4faf	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4fb2	60		rts		            RTS
.3a4fb3					FN_TAN
.3a4fb3	e2 20		sep #$20	            SEP #$20
.3a4fb5	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4fb7	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4fba	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4fbd	20 bf 07	jsr $3a07bf	            JSR ASS_ARG1_FLOAT
.3a4fc0	20 a3 62	jsr $3a62a3	            JSR FP_TAN
.3a4fc3					done
.3a4fc3	e2 20		sep #$20	            SEP #$20
.3a4fc5	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4fc8	60		rts		            RTS
.3a4fc9					FN_LN
.3a4fc9	e2 20		sep #$20	            SEP #$20
.3a4fcb	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4fcd	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4fd0	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4fd3	20 bf 07	jsr $3a07bf	            JSR ASS_ARG1_FLOAT
.3a4fd6	20 d1 62	jsr $3a62d1	            JSR FP_LN
.3a4fd9					done
.3a4fd9	e2 20		sep #$20	            SEP #$20
.3a4fdb	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4fde	60		rts		            RTS
.3a4fdf					FN_ACOS
.3a4fdf	e2 20		sep #$20	            SEP #$20
.3a4fe1	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4fe3	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4fe6	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4fe9	20 bf 07	jsr $3a07bf	            JSR ASS_ARG1_FLOAT
.3a4fec	20 fa 63	jsr $3a63fa	            JSR FP_ACOS
.3a4fef					done
.3a4fef	e2 20		sep #$20	            SEP #$20
.3a4ff1	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a4ff4	60		rts		            RTS
.3a4ff5					FN_ASIN
.3a4ff5	e2 20		sep #$20	            SEP #$20
.3a4ff7	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a4ff9	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a4ffc	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a4fff	20 bf 07	jsr $3a07bf	            JSR ASS_ARG1_FLOAT
.3a5002	20 d0 63	jsr $3a63d0	            JSR FP_ASIN
.3a5005					done
.3a5005	e2 20		sep #$20	            SEP #$20
.3a5007	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a500a	60		rts		            RTS
.3a500b					FN_ATAN
.3a500b	e2 20		sep #$20	            SEP #$20
.3a500d	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a500f	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a5012	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a5015	20 bf 07	jsr $3a07bf	            JSR ASS_ARG1_FLOAT
.3a5018	20 1c 64	jsr $3a641c	            JSR FP_ATAN
.3a501b					done
.3a501b	e2 20		sep #$20	            SEP #$20
.3a501d	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a5020	60		rts		            RTS
.3a5021					FN_EXP
.3a5021	e2 20		sep #$20	            SEP #$20
.3a5023	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a5025	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a5028	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a502b	20 bf 07	jsr $3a07bf	            JSR ASS_ARG1_FLOAT
.3a502e	20 b0 64	jsr $3a64b0	            JSR FP_EXP
.3a5031					done
.3a5031	e2 20		sep #$20	            SEP #$20
.3a5033	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a5036	60		rts		            RTS
.3a5037					FN_SQR
.3a5037	e2 20		sep #$20	            SEP #$20
.3a5039	a9 8f		lda #$8f	                LDA #TOK_LPAREN
.3a503b	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a503e	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a5041	20 bf 07	jsr $3a07bf	            JSR ASS_ARG1_FLOAT
.3a5044	20 32 65	jsr $3a6532	            JSR FP_SQR
.3a5047					done
.3a5047	e2 20		sep #$20	            SEP #$20
.3a5049	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a504c	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\commands.s

.3a504d	00		brk #		CMD_MONITOR     BRK
.3a504e	ea		nop		                NOP
.3a504f	60		rts		            RTS
.3a5050					CMD_NEW
.3a5050	08		php		                PHP
.3a5051	0b		phd		                PHD
.3a5052	08		php		            PHP
.3a5053	c2 20		rep #$20	            REP #$20
.3a5055	48		pha		            PHA
.3a5056	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a5059	5b		tcd		            TCD
.3a505a	68		pla		            PLA
.3a505b	28		plp		            PLP
.3a505c	c2 30		rep #$30	            REP #$30
.3a505e	c2 20		rep #$20	            REP #$20
.3a5060	a9 00 00	lda #$0000	            LDA #<>BASIC_BOT
.3a5063	85 d9		sta $08d9	            STA LASTLINE
.3a5065	e2 20		sep #$20	            SEP #$20
.3a5067	a9 36		lda #$36	            LDA #`BASIC_BOT
.3a5069	85 db		sta $08db	            STA LASTLINE+2
.3a506b	c2 30		rep #$30	            REP #$30
.3a506d	a9 00 00	lda #$0000	                LDA #0
.3a5070	a0 00 00	ldy #$0000	                LDY #LINE_LINK
.3a5073	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.3a5075	a0 02 00	ldy #$0002	                LDY #LINE_NUMBER
.3a5078	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.3a507a	a0 04 00	ldy #$0004	                LDY #LINE_TOKENS
.3a507d	97 d9		sta [$08d9],y	                STA [LASTLINE],Y
.3a507f	20 f0 20	jsr $3a20f0	            JSR CLRINTERP
.3a5082	2b		pld		                PLD
.3a5083	28		plp		                PLP
.3a5084	60		rts		            RTS
.3a5085					CMD_RUN
.3a5085	8b		phb		                PHB
.3a5086	08		php		                PHP
.3a5087	c2 20		rep #$20	            REP #$20
.3a5089	a9 00 00	lda #$0000	                LDA #<>BASIC_BOT            ; Point to the first line of the program
.3a508c	85 1a		sta $081a	                STA CURLINE
.3a508e	a9 36 00	lda #$0036	                LDA #`BASIC_BOT
.3a5091	85 1c		sta $081c	                STA CURLINE + 2
.3a5093	20 f0 20	jsr $3a20f0	            JSR CLRINTERP
.3a5096	20 d0 23	jsr $3a23d0	            JSR EXECPROGRAM
.3a5099	28		plp		                PLP
.3a509a	ab		plb		                PLB
.3a509b	60		rts		            RTS
.3a509c					CMD_LIST
.3a509c	08		php		                PHP
.3a509d	c2 20		rep #$20	            REP #$20
.3a509f	64 55		stz $0855	                STZ MARG1               ; MARG1 is starting line number, default 0
.3a50a1	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.3a50a4	85 59		sta $0859	                STA MARG2               ; MARG2 is ending line number, default MAXINT
.3a50a6	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a50a9	20 7b 22	jsr $3a227b	            JSR PEEK_TOK
.3a50ac	29 ff 00	and #$00ff	                AND #$00FF
.3a50af	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.3a50b2	f0 2c		beq $3a50e0	                BEQ call_list           ; ... just list with the defaults
.3a50b4	c9 81 00	cmp #$0081	                CMP #TOK_MINUS          ; If just "- ###"...
.3a50b7	f0 1a		beq $3a50d3	                BEQ parse_endline       ; ... try to parse the end line number
.3a50b9	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a50bc	20 d8 08	jsr $3a08d8	            JSR PARSEINT
.3a50bf	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG1
.3a50c1	85 55		sta $0855	                STA MARG1
.3a50c3	20 7b 22	jsr $3a227b	            JSR PEEK_TOK
.3a50c6	29 ff 00	and #$00ff	                AND #$00FF
.3a50c9	c9 00 00	cmp #$0000	                CMP #0                  ; If no arguments...
.3a50cc	f0 12		beq $3a50e0	                BEQ call_list           ; ... just list with the defaults
.3a50ce	c9 81 00	cmp #$0081	                CMP #TOK_MINUS
.3a50d1	d0 2a		bne $3a50fd	                BNE error               ; At this point, if not '-', it's a syntax error
.3a50d3					parse_endline
.3a50d3	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a50d6	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a50d9	20 d8 08	jsr $3a08d8	            JSR PARSEINT
.3a50dc	a5 23		lda $0823	                LDA ARGUMENT1           ; And save it to MARG2
.3a50de	85 59		sta $0859	                STA MARG2
.3a50e0	a5 1c		lda $081c	call_list       LDA CURLINE+2           ; Save CURLINE
.3a50e2	48		pha		                PHA
.3a50e3	a5 1a		lda $081a	                LDA CURLINE
.3a50e5	48		pha		                PHA
.3a50e6	a5 02		lda $0802	                LDA BIP+2               ; Save BIP
.3a50e8	48		pha		                PHA
.3a50e9	a5 00		lda $0800	                LDA BIP
.3a50eb	48		pha		                PHA
.3a50ec	20 8b 18	jsr $3a188b	            JSR LISTPROG
.3a50ef	68		pla		                PLA
.3a50f0	85 00		sta $0800	                STA BIP
.3a50f2	68		pla		                PLA
.3a50f3	85 02		sta $0802	                STA BIP+2
.3a50f5	68		pla		                PLA
.3a50f6	85 1a		sta $081a	                STA CURLINE
.3a50f8	68		pla		                PLA
.3a50f9	85 1c		sta $081c	                STA CURLINE+2
.3a50fb	28		plp		                PLP
.3a50fc	60		rts		            RTS
.3a50fd					error
.3a50fd	08		php		            PHP
.3a50fe	c2 20		rep #$20	            REP #$20
.3a5100	48		pha		            PHA
.3a5101	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a5104	5b		tcd		            TCD
.3a5105	68		pla		            PLA
.3a5106	28		plp		            PLP
.3a5107	e2 20		sep #$20	            SEP #$20
.3a5109	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a510b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a510f	c2 20		rep #$20	            REP #$20
.3a5111	29 ff 00	and #$00ff	            AND #$00FF
.3a5114	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a5117	e2 20		sep #$20	            SEP #$20
.3a5119	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]

;******  Return to file: src\basic816.s


;******  Processing file: src\variables.s

>08e1					NEXTVAR         .long ?         ; Pointer to the the next available byte for variable bindings
>08e4					VARIABLES       .long ?         ; Pointer to the most recently allocated variable
>08e7					TOFIND          .long ?         ; Pointer to the variable name to find
>08ea					TOFINDTYPE      .byte ?         ; The type to find
.0000					BINDING
>0000					TYPE            .fill 1                 ; The type of the data stored in the variable
>0001					NAME            .fill VAR_NAME_SIZE     ; The name of the variable
>0009					VALUE           .fill 4                 ; The data stored in the variable
>000d					NEXT            .fill 3                 ; The pointer to the next allocated variable of this type
.3a511c					INITVARS
.3a511c	08		php		                PHP
.3a511d	08		php		            PHP
.3a511e	c2 20		rep #$20	            REP #$20
.3a5120	48		pha		            PHA
.3a5121	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a5124	5b		tcd		            TCD
.3a5125	68		pla		            PLA
.3a5126	28		plp		            PLP
.3a5127	c2 20		rep #$20	            REP #$20
.3a5129	64 e4		stz $08e4	                STZ VARIABLES           ; Clear the pointer to the variables
.3a512b	64 e7		stz $08e7	                STZ TOFIND
.3a512d	e2 20		sep #$20	            SEP #$20
.3a512f	64 e6		stz $08e6	                STZ VARIABLES+2
.3a5131	64 e9		stz $08e9	                STZ TOFIND+2
.3a5133	64 ea		stz $08ea	                STZ TOFINDTYPE
.3a5135	c2 20		rep #$20	            REP #$20
.3a5137	38		sec		                SEC                     ; Compute the position of the first variable
.3a5138	a5 d9		lda $08d9	                LDA LASTLINE
.3a513a	69 04 00	adc #$0004	                ADC #LINE_TOKENS
.3a513d	85 e1		sta $08e1	                STA NEXTVAR
.3a513f	e2 20		sep #$20	            SEP #$20
.3a5141	a5 db		lda $08db	                LDA LASTLINE+2
.3a5143	69 00		adc #$00	                ADC #0
.3a5145	85 e3		sta $08e3	                STA NEXTVAR+2
.3a5147	28		plp		                PLP
.3a5148	60		rts		            RTS
.3a5149					ISVARCHAR
.3a5149	c9 5f		cmp #$5f	                CMP #'_'            ; Check if it's an underscore
.3a514b	f0 1a		beq $3a5167	                BEQ return_true     ; Yes: return true
.3a514d	c9 3a		cmp #$3a	                CMP #'9'+1          ; Check if its in [0-9]
.3a514f	b0 04		bcs $3a5155	                BGE else1           ; No: check something else
.3a5151	c9 30		cmp #$30	                CMP #'0'
.3a5153	b0 12		bcs $3a5167	                BGE return_true     ; Yes: return true
.3a5155	c9 5b		cmp #$5b	else1           CMP #'Z'+1          ; Check if its in [A-Z]
.3a5157	b0 04		bcs $3a515d	                BGE not_upper       ; No: check lower case
.3a5159	c9 41		cmp #$41	                CMP #'A'
.3a515b	b0 0a		bcs $3a5167	                BGE return_true     ; Yes: return true
.3a515d	c9 7b		cmp #$7b	not_upper       CMP #'z'+1          ; Check if its in [a-z]
.3a515f	b0 04		bcs $3a5165	                BGE return_false    ; No: return false
.3a5161	c9 61		cmp #$61	                CMP #'a'
.3a5163	b0 02		bcs $3a5167	                BGE return_true     ; Yes: return true
.3a5165	18		clc		return_false    CLC
.3a5166	60		rts		            RTS
.3a5167	38		sec		return_true     SEC
.3a5168	60		rts		            RTS
.3a5169					VARNAMECMP
.3a5169	08		php		                PHP
.3a516a	e2 20		sep #$20	            SEP #$20
.3a516c	c2 10		rep #$10	            REP #$10
.3a516e	a0 00 00	ldy #$0000	                LDY #0
.3a5171	b7 0c		lda [$080c],y	cmp_loop        LDA [SCRATCH],Y         ; Check the character in the variable name
.3a5173	f0 0a		beq $3a517f	                BEQ is_end
.3a5175	d7 e7		cmp [$08e7],y	                CMP [TOFIND],Y          ; Compare the character to the one TOFIND
.3a5177	d0 13		bne $3a518c	                BNE return_false        ; Not equal? Then this is not a match
.3a5179	c8		iny		                INY
.3a517a	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.3a517d	d0 f2		bne $3a5171	                BNE cmp_loop
.3a517f	b7 e7		lda [$08e7],y	is_end          LDA [TOFIND],Y          ; Check the character in the name to find
.3a5181	20 56 05	jsr $3a0556	            JSR TOUPPERA
.3a5184	20 49 51	jsr $3a5149	            JSR ISVARCHAR
.3a5187	b0 03		bcs $3a518c	                BCS return_false        ; YES: we do not have a match
.3a5189					return_true
.3a5189	28		plp		                PLP
.3a518a	38		sec		                SEC
.3a518b	60		rts		            RTS
.3a518c					return_false
.3a518c	28		plp		                PLP
.3a518d	18		clc		                CLC
.3a518e	60		rts		            RTS
.3a518f					VAR_FIND
.3a518f	08		php		                PHP
.3a5190	e2 20		sep #$20	            SEP #$20
.3a5192	c2 10		rep #$10	            REP #$10
.3a5194	a0 00 00	ldy #$0000	                LDY #0
.3a5197	a2 00 00	ldx #$0000	                LDX #0
.3a519a	b7 e7		lda [$08e7],y	upper_loop      LDA [TOFIND],Y          ; Get a character
.3a519c	f0 0b		beq $3a51a9	                BEQ done_upper
.3a519e	20 56 05	jsr $3a0556	            JSR TOUPPERA
.3a51a1	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; And save it to the temp
.3a51a5	c8		iny		                INY
.3a51a6	e8		inx		                INX
.3a51a7	80 f1		bra $3a519a	                BRA upper_loop          ; Go back for another
.3a51a9	a9 00		lda #$00	done_upper      LDA #0
.3a51ab	9f 00 4e 00	sta $004e00,x	                STA @lTEMPBUF,X         ; NULL terminate the temporary string
.3a51af	c2 20		rep #$20	            REP #$20
.3a51b1	a9 00 4e	lda #$4e00	                LDA #<>TEMPBUF          ; Make the temporary string the string
.3a51b4	85 e7		sta $08e7	                STA TOFIND              ; the variable name to find
.3a51b6	e2 20		sep #$20	            SEP #$20
.3a51b8	a9 00		lda #$00	                LDA #`TEMPBUF
.3a51ba	85 e9		sta $08e9	                STA TOFIND+2
.3a51bc	c2 20		rep #$20	            REP #$20
.3a51be	a5 e4		lda $08e4	                LDA VARIABLES           ; Point INDEX to the first variable to check
.3a51c0	85 08		sta $0808	                STA INDEX
.3a51c2	d0 06		bne $3a51ca	                BNE set_index_h         ; If the low word is not 0, copy the high byte
.3a51c4	e2 20		sep #$20	            SEP #$20
.3a51c6	a5 e6		lda $08e6	                LDA VARIABLES+2
.3a51c8	f0 4d		beq $3a5217	                BEQ not_found           ; If it is, we have no variables yet.
.3a51ca					set_index_h
.3a51ca	e2 20		sep #$20	            SEP #$20
.3a51cc	a5 e6		lda $08e6	                LDA VARIABLES+2
.3a51ce	85 0a		sta $080a	                STA INDEX+2
.3a51d0	a5 ea		lda $08ea	check_binding   LDA TOFINDTYPE
.3a51d2	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Get the type of the variable
.3a51d5	d7 08		cmp [$0808],y	                CMP [INDEX],Y
.3a51d7	d0 17		bne $3a51f0	                BNE check_next          ; If it's not a match, check the next binding
.3a51d9	c2 20		rep #$20	            REP #$20
.3a51db	18		clc		                CLC
.3a51dc	a5 08		lda $0808	                LDA INDEX
.3a51de	69 01 00	adc #$0001	                ADC #BINDING.NAME
.3a51e1	85 0c		sta $080c	                STA SCRATCH
.3a51e3	e2 20		sep #$20	            SEP #$20
.3a51e5	a5 0a		lda $080a	                LDA INDEX+2
.3a51e7	69 00		adc #$00	                ADC #0
.3a51e9	85 0e		sta $080e	                STA SCRATCH+2
.3a51eb	20 69 51	jsr $3a5169	            JSR VARNAMECMP
.3a51ee	b0 2a		bcs $3a521a	                BCS found               ; If they match, return that we've found the variable
.3a51f0	a0 0d 00	ldy #$000d	check_next      LDY #BINDING.NEXT       ; SCRATCH := [INDEX].NEXT
.3a51f3	c2 20		rep #$20	            REP #$20
.3a51f5	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a51f7	85 0c		sta $080c	                STA SCRATCH
.3a51f9	c8		iny		                INY
.3a51fa	c8		iny		                INY
.3a51fb	e2 20		sep #$20	            SEP #$20
.3a51fd	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a51ff	85 0e		sta $080e	                STA SCRATCH+2
.3a5201	d0 06		bne $3a5209	                BNE set_index           ; If SCRATCH == 0, the variable wasn't found
.3a5203	c2 20		rep #$20	            REP #$20
.3a5205	a5 0c		lda $080c	                LDA SCRATCH
.3a5207	f0 0e		beq $3a5217	                BEQ not_found
.3a5209					set_index
.3a5209	c2 20		rep #$20	            REP #$20
.3a520b	a5 0c		lda $080c	                LDA SCRATCH
.3a520d	85 08		sta $0808	                STA INDEX
.3a520f	e2 20		sep #$20	            SEP #$20
.3a5211	a5 0e		lda $080e	                LDA SCRATCH+2
.3a5213	85 0a		sta $080a	                STA INDEX+2
.3a5215	80 b9		bra $3a51d0	                BRA check_binding       ; And check this next variable for a match
.3a5217					not_found
.3a5217	28		plp		                PLP
.3a5218	18		clc		                CLC
.3a5219	60		rts		            RTS
.3a521a					found
.3a521a	28		plp		                PLP
.3a521b	38		sec		                SEC
.3a521c	60		rts		            RTS
.3a521d					VAR_REF
.3a521d	08		php		                PHP
.3a521e	20 8f 51	jsr $3a518f	            JSR VAR_FIND
.3a5221	b0 1f		bcs $3a5242	                BCS found
.3a5223	08		php		            PHP
.3a5224	c2 20		rep #$20	            REP #$20
.3a5226	48		pha		            PHA
.3a5227	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a522a	5b		tcd		            TCD
.3a522b	68		pla		            PLA
.3a522c	28		plp		            PLP
.3a522d	e2 20		sep #$20	            SEP #$20
.3a522f	a9 05		lda #$05	            LDA #ERR_NOTFOUND
.3a5231	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a5235	c2 20		rep #$20	            REP #$20
.3a5237	29 ff 00	and #$00ff	            AND #$00FF
.3a523a	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a523d	e2 20		sep #$20	            SEP #$20
.3a523f	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a5242					found
.3a5242	c2 30		rep #$30	            REP #$30
.3a5244	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.3a5247	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a5249	85 23		sta $0823	                STA ARGUMENT1
.3a524b	c8		iny		                INY
.3a524c	c8		iny		                INY
.3a524d	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a524f	85 25		sta $0825	                STA ARGUMENT1+2
.3a5251	e2 20		sep #$20	            SEP #$20
.3a5253	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE
.3a5256	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a5258	85 27		sta $0827	                STA ARGTYPE1
.3a525a	28		plp		done            PLP
.3a525b	60		rts		            RTS
.3a525c					VAR_ALLOC
.3a525c	08		php		                PHP
.3a525d	c2 20		rep #$20	            REP #$20
.3a525f	18		clc		                CLC                     ; Compute extent of the binding
.3a5260	a5 e1		lda $08e1	                LDA NEXTVAR
.3a5262	69 10 00	adc #$0010	                ADC #size(BINDING)
.3a5265	85 08		sta $0808	                STA INDEX
.3a5267	e2 20		sep #$20	            SEP #$20
.3a5269	a5 e3		lda $08e3	                LDA NEXTVAR+2
.3a526b	69 00		adc #$00	                ADC #0
.3a526d	85 0a		sta $080a	                STA INDEX+2
.3a526f	c5 bc		cmp $08bc	                CMP HEAP+2              ; Check to see if HEAP > INDEX
.3a5271	90 27		bcc $3a529a	                BLT has_room
.3a5273	c2 20		rep #$20	            REP #$20
.3a5275	a5 08		lda $0808	                LDA INDEX
.3a5277	c5 ba		cmp $08ba	                CMP HEAP
.3a5279	90 1f		bcc $3a529a	                BLT has_room
.3a527b	08		php		            PHP
.3a527c	c2 20		rep #$20	            REP #$20
.3a527e	48		pha		            PHA
.3a527f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a5282	5b		tcd		            TCD
.3a5283	68		pla		            PLA
.3a5284	28		plp		            PLP
.3a5285	e2 20		sep #$20	            SEP #$20
.3a5287	a9 09		lda #$09	            LDA #ERR_RANGE
.3a5289	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a528d	c2 20		rep #$20	            REP #$20
.3a528f	29 ff 00	and #$00ff	            AND #$00FF
.3a5292	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a5295	e2 20		sep #$20	            SEP #$20
.3a5297	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a529a					has_room
.3a529a	c2 20		rep #$20	            REP #$20
.3a529c	a5 e1		lda $08e1	                LDA NEXTVAR             ; Yes: we can allocate the variable
.3a529e	85 c0		sta $08c0	                STA CURRBLOCK           ; Point CURRBLOCK to it
.3a52a0	e2 20		sep #$20	            SEP #$20
.3a52a2	a5 e3		lda $08e3	                LDA NEXTVAR+2
.3a52a4	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a52a6	c2 20		rep #$20	            REP #$20
.3a52a8	a5 08		lda $0808	                LDA INDEX               ; And point NEXTVAR to the next possible spot
.3a52aa	85 e1		sta $08e1	                STA NEXTVAR
.3a52ac	e2 20		sep #$20	            SEP #$20
.3a52ae	a5 0a		lda $080a	                LDA INDEX+2
.3a52b0	85 e3		sta $08e3	                STA NEXTVAR+2
.3a52b2	28		plp		                PLP
.3a52b3	60		rts		            RTS
.3a52b4					VAR_CREATE
.3a52b4	08		php		                PHP
.3a52b5	e2 20		sep #$20	            SEP #$20
.3a52b7	a5 27		lda $0827	                LDA ARGTYPE1            ; Validate that our types match
.3a52b9	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.3a52bb	f0 33		beq $3a52f0	                BEQ chk_string          ; If so: check to see if it's a string
.3a52bd	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable type
.3a52bf	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; If it's INTEGER
.3a52c1	d0 05		bne $3a52c8	                BNE chk_float
.3a52c3	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a52c6	80 2f		bra $3a52f7	                BRA alloc_binding       ; And bind the variable
.3a52c8	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; If it's FLOAT
.3a52ca	d0 05		bne $3a52d1	                BNE type_error
.3a52cc	20 bf 07	jsr $3a07bf	            JSR ASS_ARG1_FLOAT
.3a52cf	80 26		bra $3a52f7	                BRA alloc_binding       ; And bind the variable
.3a52d1					type_error
.3a52d1	08		php		            PHP
.3a52d2	c2 20		rep #$20	            REP #$20
.3a52d4	48		pha		            PHA
.3a52d5	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a52d8	5b		tcd		            TCD
.3a52d9	68		pla		            PLA
.3a52da	28		plp		            PLP
.3a52db	e2 20		sep #$20	            SEP #$20
.3a52dd	a9 04		lda #$04	            LDA #ERR_TYPE
.3a52df	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a52e3	c2 20		rep #$20	            REP #$20
.3a52e5	29 ff 00	and #$00ff	            AND #$00FF
.3a52e8	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a52eb	e2 20		sep #$20	            SEP #$20
.3a52ed	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a52f0	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING        ; Is it a string?
.3a52f2	d0 03		bne $3a52f7	                BNE alloc_binding       ; No: just go ahead and bind it
.3a52f4	20 f3 16	jsr $3a16f3	            JSR STRCPY
.3a52f7					alloc_binding
.3a52f7	c2 10		rep #$10	            REP #$10
.3a52f9	20 5c 52	jsr $3a525c	            JSR VAR_ALLOC
.3a52fc	c2 30		rep #$30	            REP #$30
.3a52fe	18		clc		                CLC
.3a52ff	a5 c0		lda $08c0	                LDA CURRBLOCK
.3a5301	69 01 00	adc #$0001	                ADC #BINDING.NAME
.3a5304	85 08		sta $0808	                STA INDEX
.3a5306	e2 20		sep #$20	            SEP #$20
.3a5308	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.3a530a	69 00		adc #$00	                ADC #0
.3a530c	85 0a		sta $080a	                STA INDEX+2
.3a530e	a0 00 00	ldy #$0000	                LDY #0                  ; Ensure that the name field is blank
.3a5311	a9 00		lda #$00	                LDA #0
.3a5313	97 08		sta [$0808],y	blank_loop      STA [INDEX],Y
.3a5315	c8		iny		                INY
.3a5316	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.3a5319	d0 f8		bne $3a5313	                BNE blank_loop
.3a531b	a0 00 00	ldy #$0000	                LDY #0
.3a531e	b7 e7		lda [$08e7],y	name_loop       LDA [TOFIND],Y          ; Copy TOFIND to the NAME field
.3a5320	f0 10		beq $3a5332	                BEQ set_type
.3a5322	20 56 05	jsr $3a0556	            JSR TOUPPERA
.3a5325	20 49 51	jsr $3a5149	            JSR ISVARCHAR
.3a5328	90 08		bcc $3a5332	                BCC set_type
.3a532a	97 08		sta [$0808],y	                STA [INDEX],Y
.3a532c	c8		iny		                INY
.3a532d	c0 08 00	cpy #$0008	                CPY #VAR_NAME_SIZE
.3a5330	d0 ec		bne $3a531e	                BNE name_loop
.3a5332					set_type
.3a5332	c2 20		rep #$20	            REP #$20
.3a5334	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE      ; Copy the value to the variable
.3a5337	a5 23		lda $0823	                LDA ARGUMENT1
.3a5339	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a533b	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a533d	c8		iny		                INY
.3a533e	c8		iny		                INY
.3a533f	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a5341	a5 e4		lda $08e4	                LDA VARIABLES           ; Point NEXT to the current top of variables
.3a5343	a0 0d 00	ldy #$000d	                LDY #BINDING.NEXT
.3a5346	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a5348	c8		iny		                INY
.3a5349	c8		iny		                INY
.3a534a	e2 20		sep #$20	            SEP #$20
.3a534c	a5 e6		lda $08e6	                LDA VARIABLES+2
.3a534e	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a5350	c2 20		rep #$20	            REP #$20
.3a5352	a5 c0		lda $08c0	                LDA CURRBLOCK
.3a5354	85 e4		sta $08e4	                STA VARIABLES
.3a5356	e2 20		sep #$20	            SEP #$20
.3a5358	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.3a535a	85 e6		sta $08e6	                STA VARIABLES+2
.3a535c	e2 20		sep #$20	            SEP #$20
.3a535e	a0 00 00	ldy #$0000	                LDY #BINDING.TYPE       ; Set the type of the variable
.3a5361	a5 27		lda $0827	                LDA ARGTYPE1
.3a5363	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y
.3a5365	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is it a string?
.3a5367	f0 02		beq $3a536b	                BEQ set_ref             ; Yes: add a reference count to it
.3a5369	28		plp		done            PLP
.3a536a	60		rts		            RTS
.3a536b					set_ref
.3a536b	c2 20		rep #$20	            REP #$20
.3a536d	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the a heap allocated value
.3a536f	85 c0		sta $08c0	                STA CURRBLOCK
.3a5371	e2 20		sep #$20	            SEP #$20
.3a5373	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5375	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a5377	20 0f 13	jsr $3a130f	            JSR HEAP_GETHED
.3a537a	20 24 13	jsr $3a1324	            JSR HEAP_ADDREF
.3a537d	80 ea		bra $3a5369	                BRA done
.3a537f					VAR_SET
.3a537f	08		php		                PHP
.3a5380	c2 30		rep #$30	            REP #$30
.3a5382	a5 e4		lda $08e4	                LDA VARIABLES          ; If VARIABLES = 0, use VAR_CREATE
.3a5384	d0 06		bne $3a538c	                BNE use_find
.3a5386	e2 20		sep #$20	            SEP #$20
.3a5388	a5 e6		lda $08e6	                LDA VARIABLES+2
.3a538a	f0 05		beq $3a5391	                BEQ use_create
.3a538c					use_find
.3a538c	20 8f 51	jsr $3a518f	            JSR VAR_FIND
.3a538f	b0 05		bcs $3a5396	                BCS found
.3a5391					use_create
.3a5391	20 b4 52	jsr $3a52b4	            JSR VAR_CREATE
.3a5394	80 4e		bra $3a53e4	                BRA done
.3a5396					found
.3a5396	e2 20		sep #$20	            SEP #$20
.3a5398	a5 27		lda $0827	                LDA ARGTYPE1            ; Do the types match?
.3a539a	c5 ea		cmp $08ea	                CMP TOFINDTYPE
.3a539c	f0 33		beq $3a53d1	                BEQ chk_string          ; Yes: check to see if it's string
.3a539e	a5 ea		lda $08ea	                LDA TOFINDTYPE          ; Check the variable
.3a53a0	c9 00		cmp #$00	                CMP #TYPE_INTEGER       ; Is it INTEGER?
.3a53a2	d0 05		bne $3a53a9	                BNE chk_float
.3a53a4	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a53a7	80 2c		bra $3a53d5	                BRA set_val
.3a53a9	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT         ; Is it FLOAT?
.3a53ab	d0 05		bne $3a53b2	                BNE type_error          ; No: throw an error
.3a53ad	20 bf 07	jsr $3a07bf	            JSR ASS_ARG1_FLOAT
.3a53b0	80 23		bra $3a53d5	                BRA set_val
.3a53b2					type_error
.3a53b2	08		php		            PHP
.3a53b3	c2 20		rep #$20	            REP #$20
.3a53b5	48		pha		            PHA
.3a53b6	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a53b9	5b		tcd		            TCD
.3a53ba	68		pla		            PLA
.3a53bb	28		plp		            PLP
.3a53bc	e2 20		sep #$20	            SEP #$20
.3a53be	a9 04		lda #$04	            LDA #ERR_TYPE
.3a53c0	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a53c4	c2 20		rep #$20	            REP #$20
.3a53c6	29 ff 00	and #$00ff	            AND #$00FF
.3a53c9	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a53cc	e2 20		sep #$20	            SEP #$20
.3a53ce	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a53d1	c9 02		cmp #$02	chk_string      CMP #TYPE_STRING
.3a53d3	f0 11		beq $3a53e6	                BEQ set_string          ; Yes: set the string value of the variable
.3a53d5					set_val
.3a53d5	c2 30		rep #$30	            REP #$30
.3a53d7	a0 09 00	ldy #$0009	                LDY #BINDING.VALUE
.3a53da	a5 23		lda $0823	                LDA ARGUMENT1
.3a53dc	97 08		sta [$0808],y	                STA [INDEX],Y
.3a53de	c8		iny		                INY
.3a53df	c8		iny		                INY
.3a53e0	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a53e2	97 08		sta [$0808],y	                STA [INDEX],Y
.3a53e4					done
.3a53e4	28		plp		                PLP
.3a53e5	60		rts		            RTS
.3a53e6					set_string
.3a53e6	20 f3 16	jsr $3a16f3	            JSR STRCPY
.3a53e9	a0 09 00	ldy #$0009	set_ref         LDY #BINDING.VALUE      ; Set CURRBLOCK to the current string value
.3a53ec	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a53ee	85 c0		sta $08c0	                STA CURRBLOCK
.3a53f0	c8		iny		                INY
.3a53f1	c8		iny		                INY
.3a53f2	e2 20		sep #$20	            SEP #$20
.3a53f4	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a53f6	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a53f8	20 0f 13	jsr $3a130f	            JSR HEAP_GETHED
.3a53fb	20 43 13	jsr $3a1343	            JSR HEAP_REMREF
.3a53fe	e2 20		sep #$20	            SEP #$20
.3a5400	a5 27		lda $0827	                LDA ARGTYPE1
.3a5402	c9 02		cmp #$02	                CMP #TYPE_STRING        ; Is the new value a string?
.3a5404	f0 02		beq $3a5408	                BEQ add_ref             ; Yes: add a reference to it
.3a5406	80 cd		bra $3a53d5	                BRA set_val             ; No: go back to set the value... this probably shouldn't happen
.3a5408					add_ref
.3a5408	c2 20		rep #$20	            REP #$20
.3a540a	a5 23		lda $0823	                LDA ARGUMENT1           ; Flag that we have a new reference to the new string value
.3a540c	85 c0		sta $08c0	                STA CURRBLOCK
.3a540e	e2 20		sep #$20	            SEP #$20
.3a5410	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5412	85 c2		sta $08c2	                STA CURRBLOCK+2
.3a5414	20 0f 13	jsr $3a130f	            JSR HEAP_GETHED
.3a5417	20 24 13	jsr $3a1324	            JSR HEAP_ADDREF
.3a541a	80 b9		bra $3a53d5	                BRA set_val
.3a541c					VAR_FINDNAME
.3a541c	08		php		                PHP
.3a541d	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a5420	e2 20		sep #$20	            SEP #$20
.3a5422	a7 00		lda [$0800]	                LDA [BIP]           ; Get the first character
.3a5424	20 e2 04	jsr $3a04e2	            JSR ISALPHA
.3a5427	90 42		bcc $3a546b	                BCC not_found
.3a5429	c2 20		rep #$20	            REP #$20
.3a542b	a5 00		lda $0800	                LDA BIP
.3a542d	85 e7		sta $08e7	                STA TOFIND
.3a542f	e2 20		sep #$20	            SEP #$20
.3a5431	a5 02		lda $0802	                LDA BIP+2
.3a5433	85 e9		sta $08e9	                STA TOFIND+2
.3a5435					loop
.3a5435	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a5438	a7 00		lda [$0800]	                LDA [BIP]
.3a543a	f0 0d		beq $3a5449	                BEQ is_float        ; If it's EOL, the variable is a float
.3a543c	c9 24		cmp #$24	                CMP #'$'            ; If it's $, the variable is a string
.3a543e	f0 14		beq $3a5454	                BEQ is_string
.3a5440	c9 25		cmp #$25	                CMP #'%'            ; If it's %, the variable is an integer
.3a5442	f0 09		beq $3a544d	                BEQ is_integer
.3a5444	20 49 51	jsr $3a5149	            JSR ISVARCHAR
.3a5447	b0 ec		bcs $3a5435	                BCS loop            ; Check the next one
.3a5449	a9 01		lda #$01	is_float        LDA #TYPE_FLOAT     ; Otherwise it's a float
.3a544b	80 0c		bra $3a5459	                BRA set_type
.3a544d					is_integer
.3a544d	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a5450	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a5452	80 05		bra $3a5459	                BRA set_type
.3a5454					is_string
.3a5454	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a5457	a9 02		lda #$02	                LDA #TYPE_STRING
.3a5459	85 ea		sta $08ea	set_type        STA TOFINDTYPE
.3a545b	20 7b 22	jsr $3a227b	            JSR PEEK_TOK
.3a545e	c9 8f		cmp #$8f	                CMP #TOK_LPAREN     ; Is it "("?
.3a5460	d0 06		bne $3a5468	                BNE done            ; No: we're done... it's just a scalar variable
.3a5462	a5 ea		lda $08ea	                LDA TOFINDTYPE      ; Yes: this is an array reference
.3a5464	09 80		ora #$80	                ORA #$80            ; ... turn on the "Array of..." bit
.3a5466	85 ea		sta $08ea	                STA TOFINDTYPE
.3a5468					done
.3a5468	28		plp		                PLP
.3a5469	38		sec		                SEC
.3a546a	60		rts		            RTS
.3a546b	28		plp		not_found       PLP
.3a546c	18		clc		                CLC
.3a546d	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\integers.s

.3a546e					OP_INT_ADD
.3a546e	08		php		            PHP
.3a546f	c2 20		rep #$20	            REP #$20
.3a5471	18		clc		            CLC
.3a5472	a5 23		lda $0823	            LDA ARGUMENT1
.3a5474	65 29		adc $0829	            ADC ARGUMENT2
.3a5476	85 23		sta $0823	            STA ARGUMENT1
.3a5478	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a547a	65 2b		adc $082b	            ADC ARGUMENT2+2
.3a547c	85 25		sta $0825	            STA ARGUMENT1+2
.3a547e	28		plp		            PLP
.3a547f	60		rts		            RTS
.3a5480					OP_INT_SUB
.3a5480	08		php		            PHP
.3a5481	c2 20		rep #$20	            REP #$20
.3a5483	38		sec		            SEC
.3a5484	a5 23		lda $0823	            LDA ARGUMENT1
.3a5486	e5 29		sbc $0829	            SBC ARGUMENT2
.3a5488	85 23		sta $0823	            STA ARGUMENT1
.3a548a	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a548c	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.3a548e	85 25		sta $0825	            STA ARGUMENT1+2
.3a5490	28		plp		            PLP
.3a5491	60		rts		            RTS
.3a5492					OP_INT_MUL
.3a5492	08		php		            PHP
.3a5493					locals
>0001					L_SIGN      .word ?
>0003					L_RESULT    .dword ?
>0007					            .dword ?
.3a5493	c2 20		rep #$20	            REP #$20
.3a5495	3b		tsc		            TSC
.3a5496	38		sec		            SEC
.3a5497	e9 0a 00	sbc #$000a	            SBC #SIZE(locals)
.3a549a	1b		tcs		            TCS
.3a549b	c2 30		rep #$30	            REP #$30
.3a549d	a9 00 00	lda #$0000	            LDA #0                  ; Start by assuming positive numbers
.3a54a0	83 01		sta $01,s	            STA L_SIGN
.3a54a2	83 03		sta $03,s	            STA L_RESULT            ; Clear result
.3a54a4	83 05		sta $05,s	            STA L_RESULT+2
.3a54a6	83 07		sta $07,s	            STA L_RESULT+4
.3a54a8	83 09		sta $09,s	            STA L_RESULT+6
.3a54aa	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Ensure ARGUMENT1 is positive
.3a54ac	10 18		bpl $3a54c6	            BPL chk_sign2
.3a54ae	a9 00 80	lda #$8000	            LDA #$8000              ; Record that ARGUMENT1 is negative
.3a54b1	83 01		sta $01,s	            STA L_SIGN
.3a54b3	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Take the two's complement of ARGUMENT1
.3a54b5	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a54b8	85 25		sta $0825	            STA ARGUMENT1+2
.3a54ba	a5 23		lda $0823	            LDA ARGUMENT1
.3a54bc	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a54bf	1a		inc a		            INC A
.3a54c0	85 23		sta $0823	            STA ARGUMENT1
.3a54c2	d0 02		bne $3a54c6	            BNE chk_sign2
.3a54c4	e6 25		inc $0825	            INC ARGUMENT1+2
.3a54c6	a5 2b		lda $082b	chk_sign2   LDA ARGUMENT2+2         ; Ensure ARGUMENT2 is positive
.3a54c8	10 1a		bpl $3a54e4	            BPL chk_over
.3a54ca	a3 01		lda $01,s	            LDA L_SIGN              ; Flip the sign
.3a54cc	49 00 80	eor #$8000	            EOR #$8000
.3a54cf	83 01		sta $01,s	            STA L_SIGN
.3a54d1	a5 2b		lda $082b	            LDA ARGUMENT2+2         ; Take the two's complement of ARGUMENT2
.3a54d3	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a54d6	85 2b		sta $082b	            STA ARGUMENT2+2
.3a54d8	a5 29		lda $0829	            LDA ARGUMENT2
.3a54da	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a54dd	1a		inc a		            INC A
.3a54de	85 29		sta $0829	            STA ARGUMENT2
.3a54e0	d0 02		bne $3a54e4	            BNE chk_over
.3a54e2	e6 2b		inc $082b	            INC ARGUMENT2+2
.3a54e4					chk_over
.3a54e4	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a54e6	f0 04		beq $3a54ec	            BEQ do_mult
.3a54e8	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a54ea	d0 5a		bne $3a5546	            BNE overflow
.3a54ec					do_mult
.3a54ec	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*D
.3a54ee	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.3a54f2	a5 29		lda $0829	            LDA ARGUMENT2
.3a54f4	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.3a54f8	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.3a54fc	83 03		sta $03,s	            STA L_RESULT
.3a54fe	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.3a5502	83 05		sta $05,s	            STA L_RESULT+2
.3a5504	a5 25		lda $0825	            LDA ARGUMENT1+2         ; Calculate A*D << 16 + B*D
.3a5506	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.3a550a	a5 29		lda $0829	            LDA ARGUMENT2
.3a550c	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.3a5510	18		clc		            CLC
.3a5511	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.3a5515	63 05		adc $05,s	            ADC L_RESULT+2
.3a5517	83 05		sta $05,s	            STA L_RESULT+2
.3a5519	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.3a551d	63 07		adc $07,s	            ADC L_RESULT+4
.3a551f	83 07		sta $07,s	            STA L_RESULT+4
.3a5521	a5 23		lda $0823	            LDA ARGUMENT1           ; Calculate B*C << 16 + A*D << 16 + B*D
.3a5523	8f 00 01 00	sta $000100	            STA @l M0_OPERAND_A
.3a5527	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a5529	8f 02 01 00	sta $000102	            STA @l M0_OPERAND_B
.3a552d	18		clc		            CLC
.3a552e	af 04 01 00	lda $000104	            LDA @l M0_RESULT
.3a5532	63 05		adc $05,s	            ADC L_RESULT+2
.3a5534	83 05		sta $05,s	            STA L_RESULT+2
.3a5536	af 06 01 00	lda $000106	            LDA @l M0_RESULT+2
.3a553a	63 07		adc $07,s	            ADC L_RESULT+4
.3a553c	83 07		sta $07,s	            STA L_RESULT+4
.3a553e	a3 07		lda $07,s	            LDA L_RESULT+4
.3a5540	f0 23		beq $3a5565	            BEQ no_overflow
.3a5542	a3 09		lda $09,s	            LDA L_RESULT+6
.3a5544	f0 1f		beq $3a5565	            BEQ no_overflow
.3a5546					overflow
.3a5546	08		php		            PHP
.3a5547	c2 20		rep #$20	            REP #$20
.3a5549	48		pha		            PHA
.3a554a	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a554d	5b		tcd		            TCD
.3a554e	68		pla		            PLA
.3a554f	28		plp		            PLP
.3a5550	e2 20		sep #$20	            SEP #$20
.3a5552	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.3a5554	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a5558	c2 20		rep #$20	            REP #$20
.3a555a	29 ff 00	and #$00ff	            AND #$00FF
.3a555d	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a5560	e2 20		sep #$20	            SEP #$20
.3a5562	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a5565					no_overflow
.3a5565	c2 30		rep #$30	            REP #$30
.3a5567	a3 01		lda $01,s	            LDA L_SIGN              ; Check the sign
.3a5569	10 16		bpl $3a5581	            BPL ret_result          ; If positive: just return the result
.3a556b	a3 05		lda $05,s	            LDA L_RESULT+2          ; Compute the two's complement of the result
.3a556d	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a5570	83 05		sta $05,s	            STA L_RESULT+2
.3a5572	a3 03		lda $03,s	            LDA L_RESULT
.3a5574	49 ff ff	eor #$ffff	            EOR #$FFFF
.3a5577	1a		inc a		            INC A
.3a5578	83 03		sta $03,s	            STA L_RESULT
.3a557a	d0 05		bne $3a5581	            BNE ret_result
.3a557c	a3 05		lda $05,s	            LDA L_RESULT+2
.3a557e	1a		inc a		            INC A
.3a557f	83 05		sta $05,s	            STA L_RESULT+2
.3a5581					ret_result
.3a5581	a3 03		lda $03,s	            LDA L_RESULT
.3a5583	85 23		sta $0823	            STA ARGUMENT1
.3a5585	a3 05		lda $05,s	            LDA L_RESULT+2
.3a5587	85 25		sta $0825	            STA ARGUMENT1+2
.3a5589	c2 20		rep #$20	            REP #$20
.3a558b	3b		tsc		            TSC
.3a558c	18		clc		            CLC
.3a558d	69 0a 00	adc #$000a	            ADC #SIZE(locals)
.3a5590	1b		tcs		            TCS
.3a5591	28		plp		            PLP
.3a5592	60		rts		            RTS
.3a5593					OP_INT_LT
.3a5593	08		php		            PHP
.3a5594	c2 20		rep #$20	            REP #$20
.3a5596	a5 23		lda $0823	            LDA ARGUMENT1
.3a5598	c5 29		cmp $0829	            CMP ARGUMENT2
.3a559a	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a559c	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.3a559e	50 03		bvc $3a55a3	            BVC skip_eor
.3a55a0	49 00 80	eor #$8000	            EOR #$8000
.3a55a3	30 06		bmi $3a55ab	skip_eor    BMI ret_true
.3a55a5	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a55a7	64 25		stz $0825	            STZ ARGUMENT1+2
.3a55a9	80 07		bra $3a55b2	            BRA done
.3a55ab	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a55ae	85 23		sta $0823	            STA ARGUMENT1
.3a55b0	85 25		sta $0825	            STA ARGUMENT1+2
.3a55b2	28		plp		done        PLP
.3a55b3	60		rts		            RTS
.3a55b4					OP_INT_GT
.3a55b4	08		php		            PHP
.3a55b5	c2 20		rep #$20	            REP #$20
.3a55b7	a5 23		lda $0823	            LDA ARGUMENT1
.3a55b9	c5 29		cmp $0829	            CMP ARGUMENT2
.3a55bb	d0 0c		bne $3a55c9	            BNE test_fully
.3a55bd	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a55bf	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.3a55c1	d0 06		bne $3a55c9	            BNE test_fully
.3a55c3	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a55c5	64 25		stz $0825	            STZ ARGUMENT1+2
.3a55c7	80 16		bra $3a55df	            BRA done
.3a55c9	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.3a55cb	c5 23		cmp $0823	            CMP ARGUMENT1
.3a55cd	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a55cf	e5 25		sbc $0825	            SBC ARGUMENT1+2
.3a55d1	50 03		bvc $3a55d6	            BVC skip_eor
.3a55d3	49 00 80	eor #$8000	            EOR #$8000
.3a55d6	10 eb		bpl $3a55c3	skip_eor    BPL ret_false
.3a55d8	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a55db	85 23		sta $0823	            STA ARGUMENT1
.3a55dd	85 25		sta $0825	            STA ARGUMENT1+2
.3a55df	28		plp		done        PLP
.3a55e0	60		rts		            RTS
.3a55e1					OP_INT_EQ
.3a55e1	08		php		            PHP
.3a55e2	c2 20		rep #$20	            REP #$20
.3a55e4	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a55e6	c5 25		cmp $0825	            CMP ARGUMENT1+2
.3a55e8	d0 0f		bne $3a55f9	            BNE ret_false
.3a55ea	a5 29		lda $0829	            LDA ARGUMENT2
.3a55ec	c5 23		cmp $0823	            CMP ARGUMENT1
.3a55ee	d0 09		bne $3a55f9	            BNE ret_false
.3a55f0	a9 ff ff	lda #$ffff	            LDA #$FFFF
.3a55f3	85 23		sta $0823	            STA ARGUMENT1
.3a55f5	85 25		sta $0825	            STA ARGUMENT1+2
.3a55f7	80 04		bra $3a55fd	            BRA done
.3a55f9	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a55fb	64 25		stz $0825	            STZ ARGUMENT1+2
.3a55fd	28		plp		done        PLP
.3a55fe	60		rts		            RTS
.3a55ff					OP_INT_NE
.3a55ff	08		php		            PHP
.3a5600	c2 20		rep #$20	            REP #$20
.3a5602	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a5604	c5 25		cmp $0825	            CMP ARGUMENT1+2
.3a5606	d0 0c		bne $3a5614	            BNE ret_true
.3a5608	a5 29		lda $0829	            LDA ARGUMENT2
.3a560a	c5 23		cmp $0823	            CMP ARGUMENT1
.3a560c	d0 06		bne $3a5614	            BNE ret_true
.3a560e	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a5610	64 25		stz $0825	            STZ ARGUMENT1+2
.3a5612	80 07		bra $3a561b	            BRA done
.3a5614	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a5617	85 23		sta $0823	            STA ARGUMENT1
.3a5619	85 25		sta $0825	            STA ARGUMENT1+2
.3a561b	28		plp		done        PLP
.3a561c	60		rts		            RTS
.3a561d					OP_INT_GTE
.3a561d	08		php		            PHP
.3a561e	c2 20		rep #$20	            REP #$20
.3a5620	a5 23		lda $0823	            LDA ARGUMENT1
.3a5622	c5 29		cmp $0829	            CMP ARGUMENT2
.3a5624	d0 0f		bne $3a5635	            BNE test_fully
.3a5626	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5628	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.3a562a	d0 09		bne $3a5635	            BNE test_fully
.3a562c	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a562f	85 23		sta $0823	            STA ARGUMENT1
.3a5631	85 25		sta $0825	            STA ARGUMENT1+2
.3a5633	80 13		bra $3a5648	            BRA done
.3a5635	a5 29		lda $0829	test_fully  LDA ARGUMENT2
.3a5637	c5 23		cmp $0823	            CMP ARGUMENT1
.3a5639	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a563b	e5 25		sbc $0825	            SBC ARGUMENT1+2
.3a563d	50 03		bvc $3a5642	            BVC skip_eor
.3a563f	49 00 80	eor #$8000	            EOR #$8000
.3a5642	30 e8		bmi $3a562c	skip_eor    BMI ret_true
.3a5644	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a5646	64 25		stz $0825	            STZ ARGUMENT1+2
.3a5648	28		plp		done        PLP
.3a5649	60		rts		            RTS
.3a564a					OP_INT_LTE
.3a564a	08		php		            PHP
.3a564b	c2 20		rep #$20	            REP #$20
.3a564d	a5 23		lda $0823	            LDA ARGUMENT1
.3a564f	c5 29		cmp $0829	            CMP ARGUMENT2
.3a5651	d0 0f		bne $3a5662	            BNE test_fully
.3a5653	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5655	c5 2b		cmp $082b	            CMP ARGUMENT2+2
.3a5657	d0 09		bne $3a5662	            BNE test_fully
.3a5659	a9 ff ff	lda #$ffff	ret_true    LDA #$FFFF
.3a565c	85 23		sta $0823	            STA ARGUMENT1
.3a565e	85 25		sta $0825	            STA ARGUMENT1+2
.3a5660	80 13		bra $3a5675	            BRA done
.3a5662	a5 23		lda $0823	test_fully  LDA ARGUMENT1
.3a5664	c5 29		cmp $0829	            CMP ARGUMENT2
.3a5666	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5668	e5 2b		sbc $082b	            SBC ARGUMENT2+2
.3a566a	50 03		bvc $3a566f	            BVC skip_eor
.3a566c	49 00 80	eor #$8000	            EOR #$8000
.3a566f	30 e8		bmi $3a5659	skip_eor    BMI ret_true
.3a5671	64 23		stz $0823	ret_false   STZ ARGUMENT1
.3a5673	64 25		stz $0825	            STZ ARGUMENT1+2
.3a5675	28		plp		done        PLP
.3a5676	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\floats.s


;******  Processing file: src\C256/floats.s


;******  Processing file: src\C256/fp_math_defs.s

=$afe200				FP_MATH_CTRL0 = $AFE200         ; Read/write
=$08					FP_MATH_CTRL0_ADD = $08         ; 0: Substraction - 1: Addition
=$01					FP_CTRL0_CONV_0 = %00000001     ; Input 0 should be converted from 24.12 fixed point to floating point
=$02					FP_CTRL0_CONV_1 = %00000010     ; Input 1 should be converted from 24.12 fixed point to floating point
=$00					FP_ADD_IN0_MUX0 = %00000000     ; Adder input #0 is the output of MUX0
=$10					FP_ADD_IN0_MUX1 = %00010000     ; Adder input #0 is the output of MUX1
=$20					FP_ADD_IN0_MULT = %00100000     ; Adder input #0 is the output of the multiplier
=$30					FP_ADD_IN0_DIV  = %00110000     ; Adder input #0 is the output of the divider
=$00					FP_ADD_IN1_MUX0 = %00000000     ; Adder input #1 is the output of MUX0
=$40					FP_ADD_IN1_MUX1 = %01000000     ; Adder input #1 is the output of MUX1
=$80					FP_ADD_IN1_MULT = %10000000     ; Adder input #1 is the output of the multiplier
=$c0					FP_ADD_IN1_DIV  = %11000000     ; Adder input #1 is the output of the divider
=$afe201				FP_MATH_CTRL1 = $AFE201
=$00					FP_OUT_MULT = %00000000         ; Output is from the multiplier
=$01					FP_OUT_DIV  = %00000001         ; Output is from the divider
=$02					FP_OUT_ADD  = %00000010         ; Output is from the adder/subtracter
=$03					FP_OUT_ONE  = %00000011         ; Output is the constant '1.0'
=$afe202				FP_MATH_CTRL2 = $AFE202         ; Not Used - Reserved
=$afe203				FP_MATH_CTRL3 = $AFE203         ; Not Used - Reserved
=$afe204				FP_MATH_MULT_STAT = $AFE204     ; Status of the multiplier
=$01					FP_MULT_STAT_NAN  = $01         ; (NAN) Not a Number Status
=$02					FP_MULT_STAT_OVF  = $02         ; Overflow
=$04					FP_MULT_STAT_UDF  = $04         ; Underflow
=$08					FP_MULT_STAT_ZERO = $08         ; Zero
=$afe205				FP_MATH_DIV_STAT  = $AFE205     ; Status of the divider
=$01					FP_DIV_STAT_NAN       = $01     ; Not a number Status
=$02					FP_DIV_STAT_OVF       = $02     ; Overflow
=$04					FP_DIV_STAT_UDF       = $04     ; Underflow
=$08					FP_DIV_STAT_ZERO      = $08     ; Zero
=$10					FP_DIV_STAT_DIVBYZERO = $10     ; Division by Zero
=$afe206				FP_MATH_ADD_STAT  = $AFE206     ; Status of the adder/subtracter
=$01					FP_ADD_STAT_NAN  = $01          ; Not a number Status
=$02					FP_ADD_STAT_OVF  = $02          ; Overflow
=$04					FP_ADD_STAT_UDF  = $04          ; Underflow
=$08					FP_ADD_STAT_ZERO = $08          ; Zero
=$afe207				FP_MATH_CONV_STAT = $AFE207     ; Status of the fixed <=> float converters
=$01					FP_CONV_STAT_NAN  = $01         ; Not a number Status
=$02					FP_CONV_STAT_OVF  = $02         ; Overflow
=$04					FP_CONV_STAT_UDF  = $04         ; Underflow
=$afe208				FP_MATH_INPUT0_LL = $AFE208
=$afe209				FP_MATH_INPUT0_LH = $AFE209
=$afe20a				FP_MATH_INPUT0_HL = $AFE20A
=$afe20b				FP_MATH_INPUT0_HH = $AFE20B
=$afe20c				FP_MATH_INPUT1_LL = $AFE20C
=$afe20d				FP_MATH_INPUT1_LH = $AFE20D
=$afe20e				FP_MATH_INPUT1_HL = $AFE20E
=$afe20f				FP_MATH_INPUT1_HH = $AFE20F
=$afe208				FP_MATH_OUTPUT_FP_LL = $AFE208
=$afe209				FP_MATH_OUTPUT_FP_LH = $AFE209
=$afe20a				FP_MATH_OUTPUT_FP_HL = $AFE20A
=$afe20b				FP_MATH_OUTPUT_FP_HH = $AFE20B
=$afe20c				FP_MATH_OUTPUT_FIXED_LL = $AFE20C
=$afe20d				FP_MATH_OUTPUT_FIXED_LH = $AFE20D
=$afe20e				FP_MATH_OUTPUT_FIXED_HL = $AFE20E
=$afe20f				FP_MATH_OUTPUT_FIXED_HH = $AFE20F

;******  Return to file: src\C256/floats.s


;******  Processing file: src\C256/math_cop.s

.3a5677					UINT_DIV_A_X
.3a5677	08		php		                    PHP
.3a5678	c2 20		rep #$20	            REP #$20
.3a567a	8f 12 01 00	sta $000112	                    STA @l UNSIGNED_DIV_NUM_LO
.3a567e	8a		txa		                    TXA
.3a567f	8f 10 01 00	sta $000110	                    STA @l UNSIGNED_DIV_DEM_LO
.3a5683	af 16 01 00	lda $000116	                    LDA @l UNSIGNED_DIV_REM_LO
.3a5687	aa		tax		                    TAX
.3a5688	af 14 01 00	lda $000114	                    LDA @l UNSIGNED_DIV_QUO_LO
.3a568c	28		plp		                    PLP
.3a568d	60		rts		            RTS

;******  Return to file: src\C256/floats.s

.3a568e					FIXINT_TO_FP
.3a568e	08		php		                    PHP
.3a568f	e2 20		sep #$20	            SEP #$20
.3a5691	a9 03		lda #$03	                    LDA #FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.3a5693	8f 00 e2 af	sta $afe200	                    STA @l FP_MATH_CTRL0
.3a5697	a9 00		lda #$00	                    LDA #FP_OUT_MULT
.3a5699	8f 01 e2 af	sta $afe201	                    STA @l FP_MATH_CTRL1
.3a569d	c2 20		rep #$20	            REP #$20
.3a569f	a5 23		lda $0823	                    LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.3a56a1	8f 08 e2 af	sta $afe208	                    STA @l FP_MATH_INPUT0_LL
.3a56a5	a5 25		lda $0825	                    LDA ARGUMENT1+2
.3a56a7	8f 0a e2 af	sta $afe20a	                    STA @l FP_MATH_INPUT0_HL
.3a56ab	a9 00 00	lda #$0000	                    LDA #0
.3a56ae	8f 0c e2 af	sta $afe20c	                    STA @l FP_MATH_INPUT1_LL    ; ARGUMENT2 = 0100 0000 = 4096 in 20:12
.3a56b2	a9 00 01	lda #$0100	                    LDA #$0100
.3a56b5	8f 0e e2 af	sta $afe20e	                    STA @l FP_MATH_INPUT1_HL
.3a56b9	ea		nop		                    NOP
.3a56ba	ea		nop		                    NOP
.3a56bb	ea		nop		                    NOP
.3a56bc	ea		nop		                    NOP
.3a56bd	ea		nop		                    NOP
.3a56be	ea		nop		                    NOP
.3a56bf	af 08 e2 af	lda $afe208	                    LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.3a56c3	85 23		sta $0823	                    STA ARGUMENT1
.3a56c5	af 0a e2 af	lda $afe20a	                    LDA @l FP_MATH_OUTPUT_FP_HL
.3a56c9	85 25		sta $0825	                    STA ARGUMENT1+2
.3a56cb	a9 01 00	lda #$0001	                    LDA #TYPE_FLOAT
.3a56ce	85 27		sta $0827	                    STA ARGTYPE1
.3a56d0	28		plp		                    PLP
.3a56d1	60		rts		            RTS
.3a56d2	08		php		OP_FP_SUB       PHP
.3a56d3	e2 20		sep #$20	            SEP #$20
.3a56d5	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a56d7	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.3a56db	80 09		bra $3a56e6	                BRA FP_ADD_SUB
.3a56dd	08		php		OP_FP_ADD       PHP
.3a56de	e2 20		sep #$20	            SEP #$20
.3a56e0	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a56e2	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.3a56e6	a9 02		lda #$02	FP_ADD_SUB      LDA #FP_OUT_ADD
.3a56e8	8f 01 e2 af	sta $afe201	                STA @lFP_MATH_CTRL1
.3a56ec	c2 20		rep #$20	            REP #$20
.3a56ee	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.3a56f0	8f 08 e2 af	sta $afe208	                STA @lFP_MATH_INPUT0_LL
.3a56f4	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a56f6	8f 0a e2 af	sta $afe20a	                STA @lFP_MATH_INPUT0_HL
.3a56fa	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.3a56fc	8f 0c e2 af	sta $afe20c	                STA @lFP_MATH_INPUT1_LL
.3a5700	a5 2b		lda $082b	                LDA ARGUMENT2+2
.3a5702	8f 0e e2 af	sta $afe20e	                STA @lFP_MATH_INPUT1_HL
.3a5706	ea		nop		                NOP
.3a5707	ea		nop		                NOP
.3a5708	ea		nop		                NOP
.3a5709	e2 20		sep #$20	            SEP #$20
.3a570b	af 06 e2 af	lda $afe206	                LDA @lFP_MATH_ADD_STAT      ; Check the status of the addition
.3a570f	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.3a5711	d0 10		bne $3a5723	                BNE fp_add_error            ; If an issue was raise, process the math error
.3a5713	c2 20		rep #$20	            REP #$20
.3a5715	af 08 e2 af	lda $afe208	                LDA @lFP_MATH_OUTPUT_FP_LL  ; Retrieve the results into ARGUMENT1
.3a5719	85 23		sta $0823	                STA ARGUMENT1
.3a571b	af 0a e2 af	lda $afe20a	                LDA @lFP_MATH_OUTPUT_FP_HL
.3a571f	85 25		sta $0825	                STA ARGUMENT1+2
.3a5721	28		plp		fp_add_done     PLP
.3a5722	60		rts		            RTS
.3a5723					fp_add_error
.3a5723	20 be 57	jsr $3a57be	            JSR FP_MATH_ERROR
.3a5726	80 f9		bra $3a5721	                BRA fp_add_done
.3a5728	08		php		OP_FP_DIV       PHP
.3a5729	e2 20		sep #$20	            SEP #$20
.3a572b	a9 01		lda #$01	                LDA #FP_OUT_DIV
.3a572d	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5731	a9 00		lda #$00	                LDA #0
.3a5733	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.3a5737	c2 20		rep #$20	            REP #$20
.3a5739	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.3a573b	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a573f	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5741	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5745	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.3a5747	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a574b	a5 2b		lda $082b	                LDA ARGUMENT2+2
.3a574d	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5751	ea		nop		                NOP
.3a5752	ea		nop		                NOP
.3a5753	ea		nop		                NOP
.3a5754	e2 20		sep #$20	            SEP #$20
.3a5756	af 05 e2 af	lda $afe205	                LDA @l FP_MATH_DIV_STAT     ; Check the status of the addition
.3a575a	29 17		and #$17	                AND #%00010111              ; Filter out the ZERO status
.3a575c	d0 10		bne $3a576e	                BNE fp_div_error            ; If an issue was raise, process the math error
.3a575e	c2 20		rep #$20	            REP #$20
.3a5760	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.3a5764	85 23		sta $0823	                STA ARGUMENT1
.3a5766	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a576a	85 25		sta $0825	                STA ARGUMENT1+2
.3a576c	28		plp		fp_div_done     PLP
.3a576d	60		rts		            RTS
.3a576e					fp_div_error
.3a576e	20 be 57	jsr $3a57be	            JSR FP_MATH_ERROR
.3a5771	80 f9		bra $3a576c	                BRA fp_div_done
.3a5773	08		php		OP_FP_MUL       PHP
.3a5774	e2 20		sep #$20	            SEP #$20
.3a5776	a9 00		lda #$00	                LDA #FP_OUT_MULT
.3a5778	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a577c	a9 00		lda #$00	                LDA #0
.3a577e	8f 00 e2 af	sta $afe200	                STA @lFP_MATH_CTRL0
.3a5782	c2 20		rep #$20	            REP #$20
.3a5784	a5 23		lda $0823	                LDA ARGUMENT1               ; Send ARGUMENT1 to the math coprocessor
.3a5786	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a578a	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a578c	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5790	a5 29		lda $0829	                LDA ARGUMENT2               ; Send ARGUMENT2 to the math coprocessor
.3a5792	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5796	a5 2b		lda $082b	                LDA ARGUMENT2+2
.3a5798	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a579c	ea		nop		                NOP
.3a579d	ea		nop		                NOP
.3a579e	ea		nop		                NOP
.3a579f	e2 20		sep #$20	            SEP #$20
.3a57a1	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT    ; Check the status of the addition
.3a57a5	29 07		and #$07	                AND #%00000111              ; Filter out the ZERO status
.3a57a7	d0 10		bne $3a57b9	                BNE fp_mul_error            ; If an issue was raise, process the math error
.3a57a9	c2 20		rep #$20	            REP #$20
.3a57ab	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Retrieve the results into ARGUMENT1
.3a57af	85 23		sta $0823	                STA ARGUMENT1
.3a57b1	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a57b5	85 25		sta $0825	                STA ARGUMENT1+2
.3a57b7	28		plp		fp_mul_done     PLP
.3a57b8	60		rts		            RTS
.3a57b9					fp_mul_error
.3a57b9	20 be 57	jsr $3a57be	            JSR FP_MATH_ERROR
.3a57bc	80 f9		bra $3a57b7	                BRA fp_mul_done
.3a57be					FP_MATH_ERROR
.3a57be	e2 20		sep #$20	            SEP #$20
.3a57c0	89 01		bit #$01	                BIT #FP_ADD_STAT_NAN        ; Is there a NaN condition?
.3a57c2	f0 20		beq $3a57e4	                BEQ check_over              ; No: check for overflow
.3a57c4	00		brk #		                BRK
.3a57c5	08		php		            PHP
.3a57c6	c2 20		rep #$20	            REP #$20
.3a57c8	48		pha		            PHA
.3a57c9	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a57cc	5b		tcd		            TCD
.3a57cd	68		pla		            PLA
.3a57ce	28		plp		            PLP
.3a57cf	e2 20		sep #$20	            SEP #$20
.3a57d1	a9 0c		lda #$0c	            LDA #ERR_NAN
.3a57d3	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a57d7	c2 20		rep #$20	            REP #$20
.3a57d9	29 ff 00	and #$00ff	            AND #$00FF
.3a57dc	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a57df	e2 20		sep #$20	            SEP #$20
.3a57e1	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a57e4	89 02		bit #$02	check_over      BIT #FP_ADD_STAT_OVF        ; Is ther an overflow condition?
.3a57e6	f0 1f		beq $3a5807	                BEQ check_under             ; No: check for underflow
.3a57e8	08		php		            PHP
.3a57e9	c2 20		rep #$20	            REP #$20
.3a57eb	48		pha		            PHA
.3a57ec	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a57ef	5b		tcd		            TCD
.3a57f0	68		pla		            PLA
.3a57f1	28		plp		            PLP
.3a57f2	e2 20		sep #$20	            SEP #$20
.3a57f4	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.3a57f6	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a57fa	c2 20		rep #$20	            REP #$20
.3a57fc	29 ff 00	and #$00ff	            AND #$00FF
.3a57ff	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a5802	e2 20		sep #$20	            SEP #$20
.3a5804	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a5807	89 04		bit #$04	check_under     BIT #FP_ADD_STAT_UDF        ; Is there an underflow condition?
.3a5809	f0 1f		beq $3a582a	                BEQ done                    ; No: we should just return... this probably shouldn't happen
.3a580b	08		php		            PHP
.3a580c	c2 20		rep #$20	            REP #$20
.3a580e	48		pha		            PHA
.3a580f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a5812	5b		tcd		            TCD
.3a5813	68		pla		            PLA
.3a5814	28		plp		            PLP
.3a5815	e2 20		sep #$20	            SEP #$20
.3a5817	a9 0e		lda #$0e	            LDA #ERR_UNDERFLOW
.3a5819	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a581d	c2 20		rep #$20	            REP #$20
.3a581f	29 ff 00	and #$00ff	            AND #$00FF
.3a5822	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a5825	e2 20		sep #$20	            SEP #$20
.3a5827	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a582a					done
.3a582a	60		rts		            RTS
.3a582b					FP_MUL10
.3a582b	08		php		                PHP
.3a582c	e2 20		sep #$20	            SEP #$20
.3a582e	a9 00		lda #$00	                LDA #FP_OUT_MULT                ; Set for multiplication
.3a5830	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5834	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1            ; Input 1 is fixed point
.3a5836	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a583a	c2 20		rep #$20	            REP #$20
.3a583c	a9 00 a0	lda #$a000	                LDA #$A000                      ; 10 is one factor
.3a583f	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5843	a9 00 00	lda #$0000	                LDA #0
.3a5846	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a584a	a5 23		lda $0823	                LDA ARGUMENT1                   ; N is the other
.3a584c	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5850	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5852	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5856	ea		nop		                NOP
.3a5857	ea		nop		                NOP
.3a5858	ea		nop		                NOP
.3a5859	e2 20		sep #$20	            SEP #$20
.3a585b	af 04 e2 af	lda $afe204	                LDA @l FP_MATH_MULT_STAT        ; Check the status
.3a585f	89 07		bit #$07	                BIT #FP_MULT_STAT_NAN | FP_MULT_STAT_OVF | FP_MULT_STAT_UDF
.3a5861	f0 01		beq $3a5864	                BEQ ret_result
.3a5863	00		brk #		                BRK                             ; There was an error...
.3a5864					ret_result
.3a5864	c2 20		rep #$20	            REP #$20
.3a5866	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL     ; Save result back
.3a586a	85 23		sta $0823	                STA ARGUMENT1
.3a586c	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5870	85 25		sta $0825	                STA ARGUMENT1+2
.3a5872	28		plp		                PLP
.3a5873	60		rts		            RTS
.3a5874					FP_DIV10
.3a5874	08		php		                PHP
.3a5875	e2 20		sep #$20	            SEP #$20
.3a5877	a9 01		lda #$01	                LDA #FP_OUT_DIV             ; Set for multiplication
.3a5879	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a587d	a9 02		lda #$02	                LDA #FP_CTRL0_CONV_1        ; Input 1 is fixed point
.3a587f	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5883	c2 20		rep #$20	            REP #$20
.3a5885	a9 00 a0	lda #$a000	                LDA #$A000                  ; 10 is one factor
.3a5888	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a588c	a9 00 00	lda #$0000	                LDA #0
.3a588f	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5893	a5 23		lda $0823	                LDA ARGUMENT1               ; N is the other
.3a5895	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5899	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a589b	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a589f	ea		nop		                NOP
.3a58a0	ea		nop		                NOP
.3a58a1	ea		nop		                NOP
.3a58a2	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL ; Save result back
.3a58a6	85 23		sta $0823	                STA ARGUMENT1
.3a58a8	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a58ac	85 25		sta $0825	                STA ARGUMENT1+2
.3a58ae	28		plp		                PLP
.3a58af	60		rts		            RTS

;******  Return to file: src\floats.s

.3a58b0					FARG1EQ0
.3a58b0	08		php		                PHP
.3a58b1	c2 20		rep #$20	            REP #$20
.3a58b3	a5 23		lda $0823	                LDA ARGUMENT1
.3a58b5	d0 0a		bne $3a58c1	                BNE return_false
.3a58b7	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a58b9	29 ff 7f	and #$7fff	                AND #$7FFF              ; Mask off the sign bit
.3a58bc	d0 03		bne $3a58c1	                BNE return_false
.3a58be	28		plp		return_true     PLP
.3a58bf	38		sec		                SEC
.3a58c0	60		rts		            RTS
.3a58c1	28		plp		return_false    PLP
.3a58c2	18		clc		                CLC
.3a58c3	60		rts		            RTS
.3a58c4					SHIFTDEC
.3a58c4	08		php		                PHP
.3a58c5	e2 20		sep #$20	            SEP #$20
.3a58c7	38		sec		                SEC                     ; Convert '0'..'9' to it's number
.3a58c8	e9 30		sbc #$30	                SBC #'0'
.3a58ca	20 7a 05	jsr $3a057a	            JSR MULINT10
.3a58cd	c2 20		rep #$20	            REP #$20
.3a58cf	29 ff 00	and #$00ff	                AND #$00FF              ; Add the number to ARGUMENT1
.3a58d2	18		clc		                CLC
.3a58d3	65 23		adc $0823	                ADC ARGUMENT1
.3a58d5	85 23		sta $0823	                STA ARGUMENT1
.3a58d7	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a58d9	69 00 00	adc #$0000	                ADC #0
.3a58dc	85 25		sta $0825	                STA ARGUMENT1+2
.3a58de	28		plp		                PLP
.3a58df	60		rts		            RTS
.3a58e0					SHIFTHEX
.3a58e0	08		php		                PHP
.3a58e1	e2 20		sep #$20	            SEP #$20
.3a58e3	c9 30		cmp #$30	                CMP #'0'                ; Process 0-9
.3a58e5	90 04		bcc $3a58eb	                BLT not_09
.3a58e7	c9 3a		cmp #$3a	                CMP #'9'+1
.3a58e9	90 1c		bcc $3a5907	                BLT is_09
.3a58eb	c9 61		cmp #$61	not_09          CMP #'a'                ; Process lowercase A-F
.3a58ed	90 04		bcc $3a58f3	                BLT not_lc
.3a58ef	c9 67		cmp #$67	                CMP #'f'+1
.3a58f1	90 0a		bcc $3a58fd	                BLT is_lc
.3a58f3	c9 41		cmp #$41	not_lc          CMP #'A'                ; Process uppercase A-F
.3a58f5	90 04		bcc $3a58fb	                BLT not_uc
.3a58f7	c9 47		cmp #$47	                CMP #'F'+1
.3a58f9	90 07		bcc $3a5902	                BLT is_uc
.3a58fb	80 31		bra $3a592e	not_uc          BRA done                ; Just return if we couldn't convert... this shouldn't happen
.3a58fd	38		sec		is_lc           SEC                     ; Convert 'a'-'f' to the actual number
.3a58fe	e9 57		sbc #$57	                SBC #'a'-10
.3a5900	80 08		bra $3a590a	                BRA shift
.3a5902	38		sec		is_uc           SEC                     ; Convert 'A'-'F' to the actual number
.3a5903	e9 37		sbc #$37	                SBC #'A'-10
.3a5905	80 03		bra $3a590a	                BRA shift
.3a5907	38		sec		is_09           SEC                     ; Convert '0'-'9' to the actual number
.3a5908	e9 30		sbc #$30	                SBC #'0'
.3a590a					shift
.3a590a	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.3a590c	26 24		rol $0824	                ROL ARGUMENT1+1
.3a590e	26 25		rol $0825	                ROL ARGUMENT1+2
.3a5910	26 26		rol $0826	                ROL ARGUMENT1+3
.3a5912	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.3a5914	26 24		rol $0824	                ROL ARGUMENT1+1
.3a5916	26 25		rol $0825	                ROL ARGUMENT1+2
.3a5918	26 26		rol $0826	                ROL ARGUMENT1+3
.3a591a	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.3a591c	26 24		rol $0824	                ROL ARGUMENT1+1
.3a591e	26 25		rol $0825	                ROL ARGUMENT1+2
.3a5920	26 26		rol $0826	                ROL ARGUMENT1+3
.3a5922	06 23		asl $0823	                ASL ARGUMENT1           ; ARGUMENT1 *= 16
.3a5924	26 24		rol $0824	                ROL ARGUMENT1+1
.3a5926	26 25		rol $0825	                ROL ARGUMENT1+2
.3a5928	26 26		rol $0826	                ROL ARGUMENT1+3
.3a592a	05 23		ora $0823	                ORA ARGUMENT1           ; Add the number to it
.3a592c	85 23		sta $0823	                STA ARGUMENT1
.3a592e	28		plp		done            PLP
.3a592f	60		rts		            RTS
.3a5930					SHIFTBIN
.3a5930	08		php		                PHP
.3a5931	e2 20		sep #$20	            SEP #$20
.3a5933	c9 30		cmp #$30	                CMP #'0'                ; If the character is '0'...
.3a5935	f0 06		beq $3a593d	                BEQ shift_0             ; Shift a 0 onto ARGUMENT1
.3a5937	c9 31		cmp #$31	                CMP #'1'                ; If the character is '1'...
.3a5939	f0 0a		beq $3a5945	                BEQ shift_1             ; Shift a 1 onto ARGUMENT1
.3a593b	80 0f		bra $3a594c	                BRA done
.3a593d					shift_0
.3a593d	c2 20		rep #$20	            REP #$20
.3a593f	06 23		asl $0823	                ASL ARGUMENT1
.3a5941	26 25		rol $0825	                ROL ARGUMENT1+2
.3a5943	80 07		bra $3a594c	                BRA done
.3a5945					shift_1
.3a5945	c2 20		rep #$20	            REP #$20
.3a5947	38		sec		                SEC
.3a5948	26 23		rol $0823	                ROL ARGUMENT1
.3a594a	26 25		rol $0825	                ROL ARGUMENT1+2
.3a594c	28		plp		done            PLP
.3a594d	60		rts		            RTS
.3a594e					FP_POW10
.3a594e	08		php		                PHP
.3a594f	e2 30		sep #$30	            SEP #$30
.3a5951	a5 61		lda $0861	                LDA MARG4
.3a5953	f0 0d		beq $3a5962	                BEQ return_1
.3a5955	aa		tax		                TAX
.3a5956	a5 69		lda $0869	                LDA MARG6
.3a5958	d0 15		bne $3a596f	                BNE do_div
.3a595a	a9 00		lda #$00	                LDA #FP_OUT_MULT                    ; We'll multiply
.3a595c	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5960	80 15		bra $3a5977	                BRA start_loop
.3a5962					return_1
.3a5962	e2 20		sep #$20	            SEP #$20
.3a5964	a9 03		lda #$03	                LDA #FP_OUT_ONE                     ; We want to return a 1.0
.3a5966	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a596a	ea		nop		                NOP
.3a596b	ea		nop		                NOP
.3a596c	ea		nop		                NOP
.3a596d	80 62		bra $3a59d1	                BRA ret_result                      ; And return the result
.3a596f					do_div
.3a596f	e2 20		sep #$20	            SEP #$20
.3a5971	a9 01		lda #$01	                LDA #FP_OUT_DIV                     ; We'll divide
.3a5973	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5977					start_loop
.3a5977	e2 20		sep #$20	            SEP #$20
.3a5979	a9 43		lda #$43	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_0 | FP_CTRL0_CONV_1
.3a597b	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.3a597f	c2 20		rep #$20	            REP #$20
.3a5981	a9 00 10	lda #$1000	                LDA #$1000                          ; Input 0 = 1.0
.3a5984	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5988	a9 00 00	lda #$0000	                LDA #0
.3a598b	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a598f					loop
.3a598f	c2 20		rep #$20	            REP #$20
.3a5991	a9 00 a0	lda #$a000	                LDA #$A000                          ; Input 1 = 10.0
.3a5994	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5998	a9 00 00	lda #$0000	                LDA #0
.3a599b	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a599f	ea		nop		                NOP                                 ; Wait for the operation to complete
.3a59a0	ea		nop		                NOP
.3a59a1	ea		nop		                NOP
.3a59a2	ca		dex		                DEX                                 ; Count down
.3a59a3	f0 2c		beq $3a59d1	                BEQ ret_result                      ; If 0, then we're done
.3a59a5	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; SCRATCH <-- Result
.3a59a9	8f 0c 08 00	sta $00080c	                STA @l SCRATCH
.3a59ad	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a59b1	8f 0e 08 00	sta $00080e	                STA @l SCRATCH+2
.3a59b5	e2 20		sep #$20	            SEP #$20
.3a59b7	a9 42		lda #$42	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1 | FP_CTRL0_CONV_1
.3a59b9	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0                ; Used fixed point inputs
.3a59bd	c2 20		rep #$20	            REP #$20
.3a59bf	af 0c 08 00	lda $00080c	                LDA @l SCRATCH                      ; Input 0 <-- SCRATCH
.3a59c3	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a59c7	af 0e 08 00	lda $00080e	                LDA @l SCRATCH+2
.3a59cb	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a59cf	80 be		bra $3a598f	                BRA loop
.3a59d1					ret_result
.3a59d1	c2 20		rep #$20	            REP #$20
.3a59d3	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL         ; Return the result
.3a59d7	85 23		sta $0823	                STA ARGUMENT1
.3a59d9	af 0a e2 af	lda $afe20a	                LDA FP_MATH_OUTPUT_FP_HL
.3a59dd	85 25		sta $0825	                STA ARGUMENT1+2
.3a59df	e2 20		sep #$20	            SEP #$20
.3a59e1	a9 01		lda #$01	                LDA #TYPE_FLOAT
.3a59e3	85 27		sta $0827	                STA ARGTYPE1
.3a59e5	28		plp		done            PLP
.3a59e6	60		rts		            RTS
.3a59e7					PACKFLOAT
.3a59e7	08		php		                PHP
.3a59e8	c2 20		rep #$20	            REP #$20
.3a59ea	a5 5d		lda $085d	            LDA MARG3
.3a59ec	85 23		sta $0823	            STA ARGUMENT1
.3a59ee	a5 5f		lda $085f	            LDA MARG3+2
.3a59f0	85 25		sta $0825	            STA ARGUMENT1+2
.3a59f2	20 00 5c	jsr $3a5c00	            JSR ITOF
.3a59f5	c2 20		rep #$20	            REP #$20
.3a59f7	a5 23		lda $0823	            LDA ARGUMENT1
.3a59f9	85 29		sta $0829	            STA ARGUMENT2
.3a59fb	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a59fd	85 2b		sta $082b	            STA ARGUMENT2+2
.3a59ff	c2 20		rep #$20	            REP #$20
.3a5a01	a5 59		lda $0859	            LDA MARG2
.3a5a03	85 23		sta $0823	            STA ARGUMENT1
.3a5a05	a5 5b		lda $085b	            LDA MARG2+2
.3a5a07	85 25		sta $0825	            STA ARGUMENT1+2
.3a5a09	20 28 57	jsr $3a5728	            JSR OP_FP_DIV
.3a5a0c	c2 20		rep #$20	            REP #$20
.3a5a0e	a5 55		lda $0855	            LDA MARG1
.3a5a10	85 29		sta $0829	            STA ARGUMENT2
.3a5a12	a5 57		lda $0857	            LDA MARG1+2
.3a5a14	85 2b		sta $082b	            STA ARGUMENT2+2
.3a5a16	20 dd 56	jsr $3a56dd	            JSR OP_FP_ADD
.3a5a19	c2 20		rep #$20	            REP #$20
.3a5a1b	a5 23		lda $0823	            LDA ARGUMENT1
.3a5a1d	85 29		sta $0829	            STA ARGUMENT2
.3a5a1f	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5a21	85 2b		sta $082b	            STA ARGUMENT2+2
.3a5a23	20 4e 59	jsr $3a594e	            JSR FP_POW10
.3a5a26	20 73 57	jsr $3a5773	            JSR OP_FP_MUL
.3a5a29	c2 20		rep #$20	            REP #$20
.3a5a2b	a5 65		lda $0865	                LDA MARG5                       ; Check to see if the float should be negative
.3a5a2d	f0 07		beq $3a5a36	                BEQ set_float_type              ; If not, just set the type
.3a5a2f	a5 25		lda $0825	                LDA ARGUMENT1+2                 ; If so, set the sign bit
.3a5a31	09 00 80	ora #$8000	                ORA #$8000
.3a5a34	85 25		sta $0825	                STA ARGUMENT1+2
.3a5a36					set_float_type
.3a5a36	e2 20		sep #$20	            SEP #$20
.3a5a38	a9 01		lda #$01	                LDA #TYPE_FLOAT                 ; Set the type to float... ready for returning!
.3a5a3a	85 27		sta $0827	                STA ARGTYPE1
.3a5a3c	28		plp		                PLP
.3a5a3d	60		rts		            RTS
.3a5a3e					PARSENUM
.3a5a3e	5a		phy		                PHY
.3a5a3f	08		php		                PHP
.3a5a40	c2 30		rep #$30	            REP #$30
.3a5a42	64 23		stz $0823	                STZ ARGUMENT1       ; This will be the accumulator for building the number
.3a5a44	64 25		stz $0825	                STZ ARGUMENT1+2
.3a5a46	64 55		stz $0855	                STZ MARG1           ; This will be the integer portion of the mantissa for floats
.3a5a48	64 57		stz $0857	                STZ MARG1+2
.3a5a4a	64 65		stz $0865	                STZ MARG5           ; MARG5 will be the negative flag for the number
.3a5a4c	64 59		stz $0859	                STZ MARG2           ; This will be the denominator of the fractional part of the mantissa
.3a5a4e	64 5b		stz $085b	                STZ MARG2+2
.3a5a50	a9 01 00	lda #$0001	                LDA #1
.3a5a53	85 5d		sta $085d	                STA MARG3           ; This will be the divisor of the fractional part of the mantissa
.3a5a55	64 5f		stz $085f	                STZ MARG3+2
.3a5a57	64 61		stz $0861	                STZ MARG4           ; This will be the exponent of a float
.3a5a59	64 63		stz $0863	                STZ MARG4+2
.3a5a5b	64 69		stz $0869	                STZ MARG6           ; MARG6 will be the negative flag for the exponent
.3a5a5d					s0
.3a5a5d	e2 20		sep #$20	            SEP #$20
.3a5a5f	a0 00 00	ldy #$0000	                LDY #0
.3a5a62	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the first byte
.3a5a64	c9 2b		cmp #$2b	                CMP #'+'
.3a5a66	f0 33		beq $3a5a9b	                BEQ s1_drop         ; '+' --> S1, drop
.3a5a68	c9 2d		cmp #$2d	                CMP #'-'
.3a5a6a	f0 2b		beq $3a5a97	                BEQ s1_negative     ; Flag that the number is negative
.3a5a6c	c9 26		cmp #$26	                CMP #'&'
.3a5a6e	f0 3a		beq $3a5aaa	                BEQ s2_drop         ; '&' --> S2, drop
.3a5a70	20 fb 04	jsr $3a04fb	            JSR ISNUMERAL
.3a5a73	90 03		bcc $3a5a78	                BCC syntax_err
.3a5a75	82 ac 00	brl $3a5b24	                BRL s7_shift        ; '0'-'9' --> S7, emit
.3a5a78					syntax_err
.3a5a78	08		php		            PHP
.3a5a79	c2 20		rep #$20	            REP #$20
.3a5a7b	48		pha		            PHA
.3a5a7c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a5a7f	5b		tcd		            TCD
.3a5a80	68		pla		            PLA
.3a5a81	28		plp		            PLP
.3a5a82	e2 20		sep #$20	            SEP #$20
.3a5a84	a9 02		lda #$02	            LDA #ERR_SYNTAX
.3a5a86	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a5a8a	c2 20		rep #$20	            REP #$20
.3a5a8c	29 ff 00	and #$00ff	            AND #$00FF
.3a5a8f	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a5a92	e2 20		sep #$20	            SEP #$20
.3a5a94	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a5a97	a9 01		lda #$01	s1_negative     LDA #1              ; Set the negative flag for the mantissa
.3a5a99	85 65		sta $0865	                STA MARG5
.3a5a9b	c8		iny		s1_drop         INY                 ; Drop the character...
.3a5a9c	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next
.3a5a9e	c9 26		cmp #$26	                CMP #'&'
.3a5aa0	f0 08		beq $3a5aaa	                BEQ s2_drop         ; '&' --> S2, drop the '&'
.3a5aa2	20 fb 04	jsr $3a04fb	            JSR ISNUMERAL
.3a5aa5	90 d1		bcc $3a5a78	                BCC syntax_err
.3a5aa7	82 7a 00	brl $3a5b24	                BRL s7_shift        ; '0'-'9' --> S7, shift
.3a5aaa	c8		iny		s2_drop         INY                 ; Drop the character
.3a5aab	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.3a5aad	c9 68		cmp #$68	                CMP #'h'
.3a5aaf	f0 0e		beq $3a5abf	                BEQ s3_drop         ; 'h', 'H' --> S3, drop
.3a5ab1	c9 48		cmp #$48	                CMP #'H'
.3a5ab3	f0 0a		beq $3a5abf	                BEQ s3_drop
.3a5ab5	c9 62		cmp #$62	                CMP #'b'
.3a5ab7	f0 4c		beq $3a5b05	                BEQ s5_drop         ; 'b', 'B' --> S5, drop
.3a5ab9	c9 42		cmp #$42	                CMP #'B'
.3a5abb	f0 48		beq $3a5b05	                BEQ s5_drop
.3a5abd	80 b9		bra $3a5a78	                BRA syntax_err
.3a5abf	c8		iny		s3_drop         INY                 ; Drop the character
.3a5ac0	b7 00		lda [$0800],y	s3              LDA [BIP],Y         ; Get the next character
.3a5ac2	20 0c 05	jsr $3a050c	            JSR ISHEX
.3a5ac5	b0 02		bcs $3a5ac9	                BCS s4_shift
.3a5ac7	80 af		bra $3a5a78	                BRA syntax_err
.3a5ac9					s4_shift
.3a5ac9	20 e0 58	jsr $3a58e0	            JSR SHIFTHEX
.3a5acc	c8		iny		                INY
.3a5acd	b7 00		lda [$0800],y	                LDA [BIP],Y         ; Get the next character
.3a5acf	20 0c 05	jsr $3a050c	            JSR ISHEX
.3a5ad2	b0 f5		bcs $3a5ac9	                BCS s4_shift        ; '0'-'9','A'-'F' --> S4, shift
.3a5ad4					ret_integer
.3a5ad4	e2 20		sep #$20	            SEP #$20
.3a5ad6	a5 65		lda $0865	                LDA MARG5           ; check if the number should be negative
.3a5ad8	f0 11		beq $3a5aeb	                BEQ set_int_type    ; If not, just set the type and return
.3a5ada	c2 20		rep #$20	            REP #$20
.3a5adc	38		sec		                SEC                 ; If so, negate it
.3a5add	a9 00 00	lda #$0000	                LDA #0
.3a5ae0	e5 23		sbc $0823	                SBC ARGUMENT1
.3a5ae2	85 23		sta $0823	                STA ARGUMENT1
.3a5ae4	a9 00 00	lda #$0000	                LDA #0
.3a5ae7	e5 25		sbc $0825	                SBC ARGUMENT1+2
.3a5ae9	85 25		sta $0825	                STA ARGUMENT1+2
.3a5aeb					set_int_type
.3a5aeb	e2 20		sep #$20	            SEP #$20
.3a5aed	a9 00		lda #$00	                LDA #TYPE_INTEGER   ; Return an integer
.3a5aef	85 27		sta $0827	                STA ARGTYPE1
.3a5af1					stop
.3a5af1	c2 20		rep #$20	            REP #$20
.3a5af3	18		clc		                CLC
.3a5af4	98		tya		                TYA
.3a5af5	65 00		adc $0800	                ADC BIP
.3a5af7	85 00		sta $0800	                STA BIP
.3a5af9	a5 02		lda $0802	                LDA BIP+2
.3a5afb	69 00 00	adc #$0000	                ADC #0
.3a5afe	85 02		sta $0802	                STA BIP+2
.3a5b00	e2 20		sep #$20	            SEP #$20
.3a5b02	28		plp		                PLP
.3a5b03	7a		ply		                PLY
.3a5b04	60		rts		            RTS
.3a5b05	c8		iny		s5_drop         INY                     ; Drop the character
.3a5b06	b7 00		lda [$0800],y	s5              LDA [BIP],Y             ; Get the next character
.3a5b08	c9 30		cmp #$30	                CMP #'0'
.3a5b0a	f0 07		beq $3a5b13	                BEQ s6_shift            ; '0', '1' --> S6, shift
.3a5b0c	c9 31		cmp #$31	                CMP #'1'
.3a5b0e	f0 03		beq $3a5b13	                BEQ s6_shift
.3a5b10	82 65 ff	brl $3a5a78	                BRL syntax_err
.3a5b13					s6_shift
.3a5b13	20 30 59	jsr $3a5930	            JSR SHIFTBIN
.3a5b16	c8		iny		                INY
.3a5b17	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a5b19	c9 30		cmp #$30	                CMP #'0'                ; '0', '1' --> S6, shift
.3a5b1b	f0 f6		beq $3a5b13	                BEQ s6_shift
.3a5b1d	c9 31		cmp #$31	                CMP #'1'
.3a5b1f	f0 f2		beq $3a5b13	                BEQ s6_shift
.3a5b21	82 b0 ff	brl $3a5ad4	                BRL ret_integer         ; Return integer
.3a5b24					s7_shift
.3a5b24	20 c4 58	jsr $3a58c4	            JSR SHIFTDEC
.3a5b27	c8		iny		                INY
.3a5b28	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a5b2a	c9 2e		cmp #$2e	                CMP #'.'                ; '.' --> S8, drop and preserve mantissa
.3a5b2c	f0 08		beq $3a5b36	                BEQ s8_mantissa
.3a5b2e	20 fb 04	jsr $3a04fb	            JSR ISNUMERAL
.3a5b31	b0 f1		bcs $3a5b24	                BCS s7_shift
.3a5b33	82 9e ff	brl $3a5ad4	                BRL ret_integer         ; Return integer
.3a5b36					s8_mantissa
.3a5b36	c2 20		rep #$20	            REP #$20
.3a5b38	20 00 5c	jsr $3a5c00	            JSR ITOF
.3a5b3b	c2 20		rep #$20	            REP #$20
.3a5b3d	a5 23		lda $0823	            LDA ARGUMENT1
.3a5b3f	85 55		sta $0855	            STA MARG1
.3a5b41	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5b43	85 57		sta $0857	            STA MARG1+2
.3a5b45	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the decimal
.3a5b47	64 25		stz $0825	                STZ ARGUMENT1+2
.3a5b49	e2 20		sep #$20	            SEP #$20
.3a5b4b	80 36		bra $3a5b83	                BRA s8_drop
.3a5b4d					s8_shift
.3a5b4d	20 c4 58	jsr $3a58c4	            JSR SHIFTDEC
.3a5b50	c2 20		rep #$20	            REP #$20
.3a5b52	a5 5f		lda $085f	                LDA MARG3+2             ; high 16 bits
.3a5b54	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.3a5b58	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.3a5b5b	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.3a5b5f	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to high 16 bits of MARG3
.3a5b63	85 5f		sta $085f	                STA MARG3+2
.3a5b65	a5 5d		lda $085d	                LDA MARG3
.3a5b67	8f 00 01 00	sta $000100	                STA @l M0_OPERAND_A
.3a5b6b	a9 0a 00	lda #$000a	                LDA #10                 ; Multiply it by 10
.3a5b6e	8f 02 01 00	sta $000102	                STA @l M0_OPERAND_B
.3a5b72	af 04 01 00	lda $000104	                LDA @l M0_RESULT        ; And save it back to MARG3
.3a5b76	85 5d		sta $085d	                STA MARG3
.3a5b78	af 06 01 00	lda $000106	                LDA @l M0_RESULT+2
.3a5b7c	18		clc		                CLC
.3a5b7d	65 5f		adc $085f	                ADC MARG3+2
.3a5b7f	85 5f		sta $085f	                STA MARG3+2
.3a5b81	e2 20		sep #$20	            SEP #$20
.3a5b83					s8_drop
.3a5b83	c8		iny		                INY
.3a5b84	b7 00		lda [$0800],y	                LDA [BIP],Y
.3a5b86	c9 65		cmp #$65	                CMP #'e'                ; 'E' --> S9, drop
.3a5b88	f0 24		beq $3a5bae	                BEQ s9_drop
.3a5b8a	c9 45		cmp #$45	                CMP #'E'
.3a5b8c	f0 20		beq $3a5bae	                BEQ s9_drop
.3a5b8e	20 fb 04	jsr $3a04fb	            JSR ISNUMERAL
.3a5b91	b0 ba		bcs $3a5b4d	                BCS s8_shift
.3a5b93	c2 20		rep #$20	            REP #$20
.3a5b95	20 00 5c	jsr $3a5c00	            JSR ITOF
.3a5b98	c2 20		rep #$20	            REP #$20
.3a5b9a	a5 23		lda $0823	            LDA ARGUMENT1
.3a5b9c	85 59		sta $0859	            STA MARG2
.3a5b9e	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5ba0	85 5b		sta $085b	            STA MARG2+2
.3a5ba2	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.3a5ba4	64 25		stz $0825	                STZ ARGUMENT1+2
.3a5ba6	20 e7 59	jsr $3a59e7	            JSR PACKFLOAT
.3a5ba9	e2 20		sep #$20	            SEP #$20
.3a5bab	82 43 ff	brl $3a5af1	                BRL stop
.3a5bae					s9_drop
.3a5bae	c2 20		rep #$20	            REP #$20
.3a5bb0	20 00 5c	jsr $3a5c00	            JSR ITOF
.3a5bb3	c2 20		rep #$20	            REP #$20
.3a5bb5	a5 23		lda $0823	            LDA ARGUMENT1
.3a5bb7	85 59		sta $0859	            STA MARG2
.3a5bb9	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5bbb	85 5b		sta $085b	            STA MARG2+2
.3a5bbd	64 23		stz $0823	                STZ ARGUMENT1           ; ARGUMENT1 <-- 0, will be the exponent
.3a5bbf	64 25		stz $0825	                STZ ARGUMENT1+2
.3a5bc1	e2 20		sep #$20	            SEP #$20
.3a5bc3	c8		iny		                INY
.3a5bc4	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a5bc6	c9 2b		cmp #$2b	                CMP #'+'
.3a5bc8	f0 10		beq $3a5bda	                BEQ s10_drop            ; '+' --> S10, drop
.3a5bca	c9 2d		cmp #$2d	                CMP #'-'
.3a5bcc	f0 08		beq $3a5bd6	                BEQ s10_setneg          ; '-' --> S10, set exponent is negative
.3a5bce	20 fb 04	jsr $3a04fb	            JSR ISNUMERAL
.3a5bd1	b0 12		bcs $3a5be5	                BCS S11_shift           ; '0'-'9' --> S11, shift
.3a5bd3	82 a2 fe	brl $3a5a78	                BRL syntax_err
.3a5bd6					s10_setneg
.3a5bd6	a9 01		lda #$01	                LDA #1                  ; Set that the exponent should be negative
.3a5bd8	85 69		sta $0869	                STA MARG6
.3a5bda					s10_drop
.3a5bda	c8		iny		                INY
.3a5bdb	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a5bdd	20 fb 04	jsr $3a04fb	            JSR ISNUMERAL
.3a5be0	b0 03		bcs $3a5be5	                BCS s11_shift
.3a5be2	82 93 fe	brl $3a5a78	                BRL syntax_err
.3a5be5					s11_shift
.3a5be5	20 c4 58	jsr $3a58c4	            JSR SHIFTDEC
.3a5be8	c8		iny		                INY
.3a5be9	b7 00		lda [$0800],y	                LDA [BIP],Y             ; Get the next character
.3a5beb	20 fb 04	jsr $3a04fb	            JSR ISNUMERAL
.3a5bee	b0 f5		bcs $3a5be5	                BCS s11_shift
.3a5bf0	c2 20		rep #$20	            REP #$20
.3a5bf2	a5 23		lda $0823	            LDA ARGUMENT1
.3a5bf4	85 61		sta $0861	            STA MARG4
.3a5bf6	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a5bf8	85 63		sta $0863	            STA MARG4+2
.3a5bfa	20 e7 59	jsr $3a59e7	            JSR PACKFLOAT
.3a5bfd	82 f1 fe	brl $3a5af1	                BRL stop
.3a5c00					ITOF
.3a5c00	08		php		                PHP
.3a5c01	20 8e 56	jsr $3a568e	            JSR FIXINT_TO_FP
.3a5c04	28		plp		done            PLP
.3a5c05	60		rts		            RTS
.3a5c06					FTOI
.3a5c06	08		php		                PHP
.3a5c07					LOCALS
>0001					l_sign          .byte ?
>0002					l_exponent      .byte ?
>0003					l_mantissa      .dword ?
.3a5c07	c2 20		rep #$20	            REP #$20
.3a5c09	a9 fd 5e	lda #$5efd	                LDA #<>FP_1_0
.3a5c0c	85 29		sta $0829	                STA ARGUMENT2
.3a5c0e	a9 3a 00	lda #$003a	                LDA #(FP_1_0 >> 16)
.3a5c11	85 2b		sta $082b	                STA ARGUMENT2+2
.3a5c13	e2 20		sep #$20	            SEP #$20
.3a5c15	a9 01		lda #$01	                LDA #TYPE_FLOAT
.3a5c17	85 2d		sta $082d	                STA ARGTYPE2
.3a5c19	c2 20		rep #$20	            REP #$20
.3a5c1b	20 d9 5c	jsr $3a5cd9	            JSR FP_COMPARE
.3a5c1e	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.3a5c21	d0 0c		bne $3a5c2f	                BNE alloc_locals        ; No: get ready to do the full conversion
.3a5c23	a9 00 00	lda #$0000	                LDA #0
.3a5c26	8d 23 08	sta $0823	                STA @w ARGUMENT1        ; Yes: Return 0
.3a5c29	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.3a5c2c	82 a1 00	brl $3a5cd0	                BRL done
.3a5c2f	f4 00 00	pea #$0000	alloc_locals    PEA #0                  ; Reserve space for the locals
.3a5c32	f4 00 00	pea #$0000	                PEA #0
.3a5c35	f4 00 00	pea #$0000	                PEA #0
.3a5c38	e2 20		sep #$20	            SEP #$20
.3a5c3a	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3      ; Preserve the sign bit
.3a5c3d	29 80		and #$80	                AND #$80
.3a5c3f	83 01		sta $01,s	                STA l_sign
.3a5c41	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2      ; Preserve the exponent
.3a5c44	2a		rol a		                ROL A
.3a5c45	ad 26 08	lda $0826	                LDA @w ARGUMENT1+3
.3a5c48	2a		rol a		                ROL A
.3a5c49	83 02		sta $02,s	                STA l_exponent
.3a5c4b	a9 00		lda #$00	save_mantissa   LDA #0                  ; Save the mantissa (with the implied 1)
.3a5c4d	83 06		sta $06,s	                STA l_mantissa+3
.3a5c4f	ad 25 08	lda $0825	                LDA @w ARGUMENT1+2
.3a5c52	09 80		ora #$80	                ORA #$80
.3a5c54	83 05		sta $05,s	                STA l_mantissa+2
.3a5c56	ad 24 08	lda $0824	                LDA @w ARGUMENT1+1
.3a5c59	83 04		sta $04,s	                STA l_mantissa+1
.3a5c5b	ad 23 08	lda $0823	                LDA @w ARGUMENT1
.3a5c5e	83 03		sta $03,s	                STA l_mantissa
.3a5c60	a3 02		lda $02,s	                LDA l_exponent
.3a5c62	c9 96		cmp #$96	loop            CMP #150
.3a5c64	f0 3a		beq $3a5ca0	                BEQ adj_sign
.3a5c66	90 1f		bcc $3a5c87	                BLT shift_right
.3a5c68	08		php		            PHP
.3a5c69	c2 20		rep #$20	            REP #$20
.3a5c6b	48		pha		            PHA
.3a5c6c	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a5c6f	5b		tcd		            TCD
.3a5c70	68		pla		            PLA
.3a5c71	28		plp		            PLP
.3a5c72	e2 20		sep #$20	            SEP #$20
.3a5c74	a9 0d		lda #$0d	            LDA #ERR_OVERFLOW
.3a5c76	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a5c7a	c2 20		rep #$20	            REP #$20
.3a5c7c	29 ff 00	and #$00ff	            AND #$00FF
.3a5c7f	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a5c82	e2 20		sep #$20	            SEP #$20
.3a5c84	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a5c87					shift_right
.3a5c87	c2 20		rep #$20	            REP #$20
.3a5c89	a3 05		lda $05,s	                LDA l_mantissa+2
.3a5c8b	4a		lsr a		                LSR A
.3a5c8c	83 05		sta $05,s	                STA l_mantissa+2
.3a5c8e	a3 03		lda $03,s	                LDA l_mantissa
.3a5c90	6a		ror a		                ROR A
.3a5c91	83 03		sta $03,s	                STA l_mantissa
.3a5c93	e2 20		sep #$20	            SEP #$20
.3a5c95	a3 02		lda $02,s	                LDA l_exponent
.3a5c97	1a		inc a		                INC A
.3a5c98	83 02		sta $02,s	                STA l_exponent
.3a5c9a	c9 96		cmp #$96	                CMP #150
.3a5c9c	f0 02		beq $3a5ca0	                BEQ adj_sign
.3a5c9e	80 e7		bra $3a5c87	                BRA shift_right
.3a5ca0	a3 01		lda $01,s	adj_sign        LDA l_sign
.3a5ca2	f0 1b		beq $3a5cbf	                BEQ ret_positive
.3a5ca4	c2 20		rep #$20	            REP #$20
.3a5ca6	a3 03		lda $03,s	                LDA l_mantissa
.3a5ca8	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a5cab	18		clc		                CLC
.3a5cac	69 01 00	adc #$0001	                ADC #1
.3a5caf	8d 23 08	sta $0823	                STA @w ARGUMENT1
.3a5cb2	a3 05		lda $05,s	                LDA l_mantissa+2
.3a5cb4	49 ff ff	eor #$ffff	                EOR #$FFFF
.3a5cb7	69 00 00	adc #$0000	                ADC #0
.3a5cba	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.3a5cbd	80 0c		bra $3a5ccb	                BRA clean
.3a5cbf					ret_positive
.3a5cbf	c2 20		rep #$20	            REP #$20
.3a5cc1	a3 03		lda $03,s	                LDA l_mantissa
.3a5cc3	8d 23 08	sta $0823	                STA @w ARGUMENT1
.3a5cc6	a3 05		lda $05,s	                LDA l_mantissa+2
.3a5cc8	8d 25 08	sta $0825	                STA @w ARGUMENT1+2
.3a5ccb					clean
.3a5ccb	c2 20		rep #$20	            REP #$20
.3a5ccd	68		pla		                PLA                     ; Clean up the locals
.3a5cce	68		pla		                PLA
.3a5ccf	68		pla		                PLA
.3a5cd0					done
.3a5cd0	e2 20		sep #$20	            SEP #$20
.3a5cd2	a9 00		lda #$00	                LDA #TYPE_INTEGER       ; Set the return type to integer
.3a5cd4	8d 27 08	sta $0827	                STA @w ARGTYPE1
.3a5cd7	28		plp		                PLP
.3a5cd8	60		rts		            RTS
.3a5cd9					FP_COMPARE
.3a5cd9	da		phx		                PHX
.3a5cda	08		php		                PHP
.3a5cdb	c2 20		rep #$20	            REP #$20
.3a5cdd	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Save ARGUMENT1 so we don't destroy it
.3a5cdf	48		pha		                PHA
.3a5ce0	a5 23		lda $0823	                LDA ARGUMENT1
.3a5ce2	48		pha		                PHA
.3a5ce3	20 d2 56	jsr $3a56d2	            JSR OP_FP_SUB
.3a5ce6	20 b0 58	jsr $3a58b0	            JSR FARG1EQ0
.3a5ce9	b0 11		bcs $3a5cfc	                BCS are_equal
.3a5ceb	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Check the high word
.3a5ced	89 00 80	bit #$8000	                BIT #$8000
.3a5cf0	d0 05		bne $3a5cf7	                BNE is_lt                   ; ARGUMENT1 < ARGUMENT2
.3a5cf2	a9 01 00	lda #$0001	is_gt           LDA #1                      ; ARGUMENT1 > ARGUMENT2: return 1
.3a5cf5	80 08		bra $3a5cff	                BRA ret_result
.3a5cf7	a9 ff ff	lda #$ffff	is_lt           LDA #$FFFF                  ; ARGUMENT1 > ARGUMENT2: return -1
.3a5cfa	80 03		bra $3a5cff	                BRA ret_result
.3a5cfc	a9 00 00	lda #$0000	are_equal       LDA #0                      ; Equal: return 0
.3a5cff	fa		plx		ret_result      PLX                         ; Restore ARGUMENT1
.3a5d00	86 23		stx $0823	                STX ARGUMENT1
.3a5d02	fa		plx		                PLX
.3a5d03	86 25		stx $0825	                STX ARGUMENT1+2
.3a5d05	28		plp		                PLP
.3a5d06	fa		plx		                PLX
.3a5d07	60		rts		            RTS
.3a5d08					OP_FP_LT
.3a5d08	08		php		                PHP
.3a5d09	c2 30		rep #$30	            REP #$30
.3a5d0b	20 d9 5c	jsr $3a5cd9	            JSR FP_COMPARE
.3a5d0e	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.3a5d11	d0 05		bne $3a5d18	                BNE ret_false
.3a5d13	20 2d 06	jsr $3a062d	            JSR SET_TRUE
.3a5d16	80 03		bra $3a5d1b	                BRA done
.3a5d18					ret_false
.3a5d18	20 3f 06	jsr $3a063f	            JSR SET_FALSE
.3a5d1b	28		plp		done            PLP
.3a5d1c	60		rts		            RTS
.3a5d1d					OP_FP_GT
.3a5d1d	08		php		                PHP
.3a5d1e	c2 30		rep #$30	            REP #$30
.3a5d20	20 d9 5c	jsr $3a5cd9	            JSR FP_COMPARE
.3a5d23	c9 01 00	cmp #$0001	                CMP #1
.3a5d26	d0 05		bne $3a5d2d	                BNE ret_false
.3a5d28	20 2d 06	jsr $3a062d	            JSR SET_TRUE
.3a5d2b	80 03		bra $3a5d30	                BRA done
.3a5d2d					ret_false
.3a5d2d	20 3f 06	jsr $3a063f	            JSR SET_FALSE
.3a5d30	28		plp		done            PLP
.3a5d31	60		rts		            RTS
.3a5d32					OP_FP_EQ
.3a5d32	08		php		                PHP
.3a5d33	c2 30		rep #$30	            REP #$30
.3a5d35	20 d9 5c	jsr $3a5cd9	            JSR FP_COMPARE
.3a5d38	c9 00 00	cmp #$0000	                CMP #0
.3a5d3b	d0 05		bne $3a5d42	                BNE ret_false
.3a5d3d	20 2d 06	jsr $3a062d	            JSR SET_TRUE
.3a5d40	80 03		bra $3a5d45	                BRA done
.3a5d42					ret_false
.3a5d42	20 3f 06	jsr $3a063f	            JSR SET_FALSE
.3a5d45	28		plp		done            PLP
.3a5d46	60		rts		            RTS
.3a5d47					OP_FP_LTE
.3a5d47	08		php		                PHP
.3a5d48	c2 30		rep #$30	            REP #$30
.3a5d4a	20 d9 5c	jsr $3a5cd9	            JSR FP_COMPARE
.3a5d4d	c9 01 00	cmp #$0001	                CMP #1
.3a5d50	f0 05		beq $3a5d57	                BEQ ret_false
.3a5d52	20 2d 06	jsr $3a062d	            JSR SET_TRUE
.3a5d55	80 03		bra $3a5d5a	                BRA done
.3a5d57					ret_false
.3a5d57	20 3f 06	jsr $3a063f	            JSR SET_FALSE
.3a5d5a	28		plp		done            PLP
.3a5d5b	60		rts		            RTS
.3a5d5c					OP_FP_GTE
.3a5d5c	08		php		                PHP
.3a5d5d	c2 30		rep #$30	            REP #$30
.3a5d5f	20 d9 5c	jsr $3a5cd9	            JSR FP_COMPARE
.3a5d62	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.3a5d65	f0 05		beq $3a5d6c	                BEQ ret_false
.3a5d67	20 2d 06	jsr $3a062d	            JSR SET_TRUE
.3a5d6a	80 03		bra $3a5d6f	                BRA done
.3a5d6c					ret_false
.3a5d6c	20 3f 06	jsr $3a063f	            JSR SET_FALSE
.3a5d6f	28		plp		done            PLP
.3a5d70	60		rts		            RTS
.3a5d71					OP_FP_NE
.3a5d71	08		php		                PHP
.3a5d72	c2 30		rep #$30	            REP #$30
.3a5d74	20 d9 5c	jsr $3a5cd9	            JSR FP_COMPARE
.3a5d77	c9 00 00	cmp #$0000	                CMP #0
.3a5d7a	f0 05		beq $3a5d81	                BEQ ret_false
.3a5d7c	20 2d 06	jsr $3a062d	            JSR SET_TRUE
.3a5d7f	80 03		bra $3a5d84	                BRA done
.3a5d81					ret_false
.3a5d81	20 3f 06	jsr $3a063f	            JSR SET_FALSE
.3a5d84	28		plp		done            PLP
.3a5d85	60		rts		            RTS
.3a5d86					STREMIT
.3a5d86	08		php		                PHP
.3a5d87	e2 20		sep #$20	            SEP #$20
.3a5d89	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Append the character
.3a5d8b	c8		iny		                INY                         ; Advance the character pointer in Y
.3a5d8c	a9 00		lda #$00	                LDA #0                      ; And add the NULL
.3a5d8e	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.3a5d90	28		plp		                PLP
.3a5d91	60		rts		            RTS
.3a5d92					STREMITB
.3a5d92	da		phx		                PHX
.3a5d93	08		php		                PHP
.3a5d94	e2 20		sep #$20	            SEP #$20
.3a5d96	c9 80		cmp #$80	                CMP #$80
.3a5d98	90 0a		bcc $3a5da4	                BLT emit_digits
.3a5d9a	48		pha		                PHA
.3a5d9b	a9 2d		lda #$2d	                LDA #'-'                    ; Print a minus sign
.3a5d9d	20 86 5d	jsr $3a5d86	            JSR STREMIT
.3a5da0	68		pla		                PLA
.3a5da1	49 ff		eor #$ff	                EOR #$FF                    ; And negate it
.3a5da3	1a		inc a		                INC A
.3a5da4					emit_digits
.3a5da4	c2 30		rep #$30	            REP #$30
.3a5da6	29 ff 00	and #$00ff	                AND #$00FF
.3a5da9	c9 64 00	cmp #$0064	                CMP #100
.3a5dac	90 0e		bcc $3a5dbc	                BLT chk_tens
.3a5dae	a2 64 00	ldx #$0064	                LDX #100
.3a5db1	20 77 56	jsr $3a5677	            JSR UINT_DIV_A_X
.3a5db4	18		clc		                CLC
.3a5db5	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.3a5db8	20 86 5d	jsr $3a5d86	            JSR STREMIT
.3a5dbb	8a		txa		                TXA                         ; Put the remainder in A
.3a5dbc					chk_tens
.3a5dbc	a2 0a 00	ldx #$000a	                LDX #10
.3a5dbf	20 77 56	jsr $3a5677	            JSR UINT_DIV_A_X
.3a5dc2	18		clc		                CLC
.3a5dc3	69 30 00	adc #$0030	                ADC #'0'                    ; Convert to ASCII
.3a5dc6	20 86 5d	jsr $3a5d86	            JSR STREMIT
.3a5dc9	8a		txa		                TXA                         ; Put the remainder in A
.3a5dca					ones_digit
.3a5dca	18		clc		                CLC
.3a5dcb	69 30 00	adc #$0030	                ADC #'0'                    ; Convert it to ASCII
.3a5dce	20 86 5d	jsr $3a5d86	            JSR STREMIT
.3a5dd1	28		plp		                PLP
.3a5dd2	fa		plx		                PLX
.3a5dd3	60		rts		            RTS
.3a5dd4					STRFINDEND
.3a5dd4	08		php		                PHP
.3a5dd5	e2 20		sep #$20	            SEP #$20
.3a5dd7	c2 10		rep #$10	            REP #$10
.3a5dd9	a0 00 00	ldy #$0000	                LDY #0
.3a5ddc	b7 23		lda [$0823],y	find_end        LDA [ARGUMENT1],Y           ; Scan to the end of the string
.3a5dde	f0 03		beq $3a5de3	                BEQ done
.3a5de0	c8		iny		                INY
.3a5de1	80 f9		bra $3a5ddc	                BRA find_end
.3a5de3	28		plp		done            PLP
.3a5de4	60		rts		            RTS
=6					FP_D = 6        ; Number of mantissa digits
.3a5de5					FTOS
.3a5de5	08		php		                PHP
.3a5de6	e2 20		sep #$20	            SEP #$20
.3a5de8	c2 10		rep #$10	            REP #$10
.3a5dea	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be the negative flag
.3a5ded	f4 00 00	pea #$0000	                PEA #0                      ; This spot on the stack will be K
.3a5df0	f4 00 00	pea #$0000	                PEA #0                      ; This spot will be for the exponents
>0001					L_NEGATIVE      .word ?
>0003					L_K             .word ?
>0005					L_X1            .byte ?                     ; The binary exponent
>0006					L_EXP           .byte ?                     ; The decimal exponent
.3a5df3	20 b0 58	jsr $3a58b0	            JSR FARG1EQ0
.3a5df6	90 19		bcc $3a5e11	                BCC chk_negative
.3a5df8	20 01 15	jsr $3a1501	            JSR TEMPSTRING
.3a5dfb	e2 20		sep #$20	            SEP #$20
.3a5dfd	a0 00 00	ldy #$0000	                LDY #0
.3a5e00	a9 20		lda #$20	                LDA #' '
.3a5e02	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a5e04	c8		iny		                INY
.3a5e05	a9 30		lda #$30	                LDA #'0'                    ; Return a "0"
.3a5e07	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a5e09	c8		iny		                INY
.3a5e0a	a9 00		lda #$00	                LDA #0
.3a5e0c	97 16		sta [$0816],y	                STA [STRPTR],Y
.3a5e0e	82 ce 00	brl $3a5edf	                BRL ret_result
.3a5e11					chk_negative
.3a5e11	e2 20		sep #$20	            SEP #$20
.3a5e13	a5 26		lda $0826	                LDA ARGUMENT1+3             ; If N is negative, output a minus sign and negate N
.3a5e15	10 08		bpl $3a5e1f	                BPL not_negative
.3a5e17	29 7f		and #$7f	                AND #$7F                    ; Negate the number
.3a5e19	85 26		sta $0826	                STA ARGUMENT1+3
.3a5e1b	a9 01		lda #$01	                LDA #1
.3a5e1d	83 01		sta $01,s	                STA L_NEGATIVE              ; Set IsNegative to a TRUE value
.3a5e1f					not_negative
.3a5e1f	c2 20		rep #$20	            REP #$20
.3a5e21	a9 00 00	lda #$0000	                LDA #0                      ; Initialize K to 0, K is a 1-byte signed integer. (SCRATCH is K)
.3a5e24	83 03		sta $03,s	                STA L_K                     ; We're using a word here for convenience
.3a5e26	c2 20		rep #$20	            REP #$20
.3a5e28	af f9 5e 3a	lda $3a5ef9	            LDA ten_d_1
.3a5e2c	85 29		sta $0829	            STA ARGUMENT2
.3a5e2e	af fb 5e 3a	lda $3a5efb	            LDA ten_d_1+2
.3a5e32	85 2b		sta $082b	            STA ARGUMENT2+2
.3a5e34	20 d9 5c	jsr $3a5cd9	            JSR FP_COMPARE
.3a5e37	89 00 80	bit #$8000	                BIT #$8000                  ; Is N < 10^(D-1)?
.3a5e3a	d0 12		bne $3a5e4e	                BNE shift_up
.3a5e3c					shift_down
.3a5e3c	20 74 58	jsr $3a5874	            JSR FP_DIV10
.3a5e3f	a3 03		lda $03,s	                LDA L_K
.3a5e41	1a		inc a		                INC A
.3a5e42	83 03		sta $03,s	                STA L_K                     ; Increment K
.3a5e44	20 d9 5c	jsr $3a5cd9	            JSR FP_COMPARE
.3a5e47	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N < 10^(D-1)?
.3a5e4a	f0 12		beq $3a5e5e	                BEQ do_digits               ; Yes: we're ready to process digits
.3a5e4c	80 ee		bra $3a5e3c	                BRA shift_down              ; No: keep dividing
.3a5e4e					shift_up
.3a5e4e	20 2b 58	jsr $3a582b	            JSR FP_MUL10
.3a5e51	a3 03		lda $03,s	                LDA L_K
.3a5e53	3a		dec a		                DEC A
.3a5e54	83 03		sta $03,s	                STA L_K                     ; Decrement K
.3a5e56	20 d9 5c	jsr $3a5cd9	            JSR FP_COMPARE
.3a5e59	c9 ff ff	cmp #$ffff	                CMP #$FFFF                  ; Is N >= 10 ^ (D-1)?
.3a5e5c	f0 f0		beq $3a5e4e	                BEQ shift_up                ; No: keep multiplying
.3a5e5e					do_digits
.3a5e5e	e2 30		sep #$30	            SEP #$30
.3a5e60	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a5e62	0a		asl a		                ASL A
.3a5e63	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a5e65	2a		rol a		                ROL A
.3a5e66	83 05		sta $05,s	                STA L_X1
.3a5e68	38		sec		                SEC
.3a5e69	a9 96		lda #$96	                LDA #150                    ; X := 150 - X1
.3a5e6b	e3 05		sbc $05,s	                SBC L_X1
.3a5e6d	aa		tax		                TAX
.3a5e6e	f0 0f		beq $3a5e7f	                BEQ emit_digits             ; If X = 0, just emit the digits
.3a5e70	a5 25		lda $0825	                LDA ARGUMENT1+2             ; Set the implied '1' MSB of the mantissa
.3a5e72	09 80		ora #$80	                ORA #$80
.3a5e74	85 25		sta $0825	                STA ARGUMENT1+2
.3a5e76	46 25		lsr $0825	shift_r         LSR ARGUMENT1+2             ; Shift the mantissa right
.3a5e78	66 24		ror $0824	                ROR ARGUMENT1+1
.3a5e7a	66 23		ror $0823	                ROR ARGUMENT1
.3a5e7c	ca		dex		                DEX
.3a5e7d	d0 f7		bne $3a5e76	                BNE shift_r                 ; Until X = 0
.3a5e7f					emit_digits
.3a5e7f	c2 10		rep #$10	            REP #$10
.3a5e81	e2 20		sep #$20	            SEP #$20
.3a5e83	64 26		stz $0826	                STZ ARGUMENT1+3             ; Blank out the MSB
.3a5e85	a9 00		lda #$00	                LDA #TYPE_INTEGER           ; Make it an integer
.3a5e87	85 27		sta $0827	                STA ARGTYPE1
.3a5e89	a3 01		lda $01,s	                LDA L_NEGATIVE              ; Check IsNegative
.3a5e8b	f0 11		beq $3a5e9e	                BEQ get_raw_digits          ; If FALSE, just convert the raw digits
.3a5e8d	c2 20		rep #$20	            REP #$20
.3a5e8f	38		sec		                SEC                         ; Make the raw integer negative
.3a5e90	a9 00 00	lda #$0000	                LDA #0
.3a5e93	e5 23		sbc $0823	                SBC ARGUMENT1
.3a5e95	85 23		sta $0823	                STA ARGUMENT1
.3a5e97	a9 00 00	lda #$0000	                LDA #0
.3a5e9a	e5 25		sbc $0825	                SBC ARGUMENT1+2
.3a5e9c	85 25		sta $0825	                STA ARGUMENT1+2
.3a5e9e					get_raw_digits
.3a5e9e	20 60 15	jsr $3a1560	            JSR ITOS
.3a5ea1	c2 20		rep #$20	            REP #$20
.3a5ea3	a5 16		lda $0816	            LDA STRPTR
.3a5ea5	85 23		sta $0823	            STA ARGUMENT1
.3a5ea7	a5 18		lda $0818	            LDA STRPTR+2
.3a5ea9	85 25		sta $0825	            STA ARGUMENT1+2
.3a5eab	20 d4 5d	jsr $3a5dd4	            JSR STRFINDEND
.3a5eae	e2 20		sep #$20	            SEP #$20
.3a5eb0	c8		iny		                INY                         ; Move the NULL up one byte
.3a5eb1	a9 00		lda #$00	                LDA #0
.3a5eb3	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.3a5eb5	88		dey		insert_loop     DEY                         ; Move to the character before the one we just moved
.3a5eb6	88		dey		                DEY
.3a5eb7	b7 23		lda [$0823],y	                LDA [ARGUMENT1],Y           ; Get the character
.3a5eb9	c8		iny		                INY                         ; Move to the next space
.3a5eba	97 23		sta [$0823],y	                STA [ARGUMENT1],Y           ; Store the character here
.3a5ebc	c0 02 00	cpy #$0002	                CPY #2                      ; Check to see if we just moved the 2nd character
.3a5ebf	d0 f4		bne $3a5eb5	                BNE insert_loop             ; If not, keep moving the characters
.3a5ec1	a9 2e		lda #$2e	                LDA #'.'                    ; Insert the '.' in the space we openned
.3a5ec3	97 23		sta [$0823],y	                STA [ARGUMENT1],Y
.3a5ec5	e2 20		sep #$20	            SEP #$20
.3a5ec7	18		clc		                CLC                         ; Compute the exponent
.3a5ec8	a3 03		lda $03,s	                LDA L_K
.3a5eca	69 05		adc #$05	                ADC #(FP_D - 1)
.3a5ecc	83 06		sta $06,s	                STA L_EXP
.3a5ece	f0 19		beq $3a5ee9	                BEQ done                    ; If it's 0, just return the number
.3a5ed0	20 d4 5d	jsr $3a5dd4	            JSR STRFINDEND
.3a5ed3	a9 45		lda #$45	                LDA #'E'                    ; Append the "E"
.3a5ed5	20 86 5d	jsr $3a5d86	            JSR STREMIT
.3a5ed8	a3 06		lda $06,s	                LDA L_EXP
.3a5eda	20 92 5d	jsr $3a5d92	            JSR STREMITB
.3a5edd	80 0a		bra $3a5ee9	                BRA done                    ; TODO: reformat integer... add E and exponent...
.3a5edf					ret_result
.3a5edf	c2 20		rep #$20	            REP #$20
.3a5ee1	a5 16		lda $0816	                LDA STRPTR                  ; Return the temporary string we've assembled
.3a5ee3	85 23		sta $0823	                STA ARGUMENT1
.3a5ee5	a5 18		lda $0818	                LDA STRPTR+2
.3a5ee7	85 25		sta $0825	                STA ARGUMENT1+2
.3a5ee9					done
.3a5ee9	e2 20		sep #$20	            SEP #$20
.3a5eeb	a9 02		lda #$02	                LDA #TYPE_STRING
.3a5eed	85 27		sta $0827	                STA ARGTYPE1
.3a5eef	c2 20		rep #$20	            REP #$20
.3a5ef1	3b		tsc		                TSC                         ; Remove the locals from the stack
.3a5ef2	18		clc		                CLC
.3a5ef3	69 06 00	adc #$0006	                ADC #6
.3a5ef6	1b		tcs		                TCS
.3a5ef7	28		plp		                PLP
.3a5ef8	60		rts		            RTS
>3a5ef9	00 50 c3 47			ten_d_1         .dword $47c35000            ; 10^(FP_D-1), where FP_D=5
>3a5efd	00 00 80 3f			FP_1_0          .dword $3f800000    ; Floating point constant: 1.0
>3a5f01	f3 04 b5 3f			FP_SQR_2_0      .dword $3fb504f3    ; Floating point constant: sqrt(2.0)
>3a5f05	f3 04 35 3f			FP_SQR_0_5      .dword $3f3504f3    ; Floating point constant: sqrt(0.2)

;******  Return to file: src\basic816.s


;******  Processing file: src\transcendentals.s

.3a5f09					Q_POLY_HR
.3a5f09	e2 20		sep #$20	            SEP #$20
.3a5f0b	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a5f0d	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5f11	c2 20		rep #$20	            REP #$20
.3a5f13	bd 00 00	lda $0000,x	                LDA 0,X
.3a5f16	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5f1a	bd 02 00	lda $0002,x	                LDA 2,X
.3a5f1d	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5f21	88		dey		                DEY             ; (Y-1) more coefficients.
.3a5f22	e8		inx		loop            INX             ; point to the next coefficient
.3a5f23	e8		inx		                INX
.3a5f24	e8		inx		                INX
.3a5f25	e8		inx		                INX
.3a5f26	e2 20		sep #$20	            SEP #$20
.3a5f28	a9 00		lda #$00	                LDA #FP_OUT_MULT
.3a5f2a	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5f2e	c2 20		rep #$20	            REP #$20
.3a5f30	af 23 08 00	lda $000823	                LDA @l ARGUMENT1
.3a5f34	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5f38	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.3a5f3c	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5f40	ea		nop		                NOP
.3a5f41	ea		nop		                NOP
.3a5f42	ea		nop		                NOP
.3a5f43	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5f47	48		pha		                PHA
.3a5f48	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5f4c	8f 0a e2 af	sta $afe20a	                STA FP_MATH_INPUT0_HL
.3a5f50	68		pla		                PLA
.3a5f51	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5f55	e2 20		sep #$20	            SEP #$20
.3a5f57	a9 02		lda #$02	                LDA #FP_OUT_ADD
.3a5f59	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5f5d	c2 20		rep #$20	            REP #$20
.3a5f5f	bd 00 00	lda $0000,x	                LDA 0,X
.3a5f62	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5f66	bd 02 00	lda $0002,x	                LDA 2,X
.3a5f69	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5f6d	ea		nop		                NOP
.3a5f6e	ea		nop		                NOP
.3a5f6f	ea		nop		                NOP
.3a5f70	88		dey		                DEY
.3a5f71	f0 14		beq $3a5f87	                BEQ done
.3a5f73	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5f77	48		pha		                PHA
.3a5f78	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5f7c	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5f80	68		pla		                PLA
.3a5f81	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5f85	80 9b		bra $3a5f22	                BRA loop
.3a5f87	af 08 e2 af	lda $afe208	done            LDA @l FP_MATH_OUTPUT_FP_LL
.3a5f8b	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.3a5f8f	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5f93	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.3a5f97	60		rts		                RTS
.3a5f98					Q_SQ
.3a5f98	e2 20		sep #$20	            SEP #$20
.3a5f9a	a9 00		lda #$00	                LDA #0
.3a5f9c	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5fa0	a9 00		lda #$00	                LDA #FP_OUT_MULT
.3a5fa2	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5fa6	c2 20		rep #$20	            REP #$20
.3a5fa8	a5 23		lda $0823	                LDA ARGUMENT1
.3a5faa	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5fae	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5fb2	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.3a5fb6	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5fba	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5fbe	ea		nop		                NOP
.3a5fbf	ea		nop		                NOP
.3a5fc0	ea		nop		                NOP
.3a5fc1	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a5fc5	85 23		sta $0823	                STA ARGUMENT1
.3a5fc7	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a5fcb	85 25		sta $0825	                STA ARGUMENT1+2
.3a5fcd	60		rts		                RTS
.3a5fce					Q_INV
.3a5fce	e2 20		sep #$20	            SEP #$20
.3a5fd0	a9 00		lda #$00	                LDA #0
.3a5fd2	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a5fd6	a9 01		lda #$01	                LDA #FP_OUT_DIV
.3a5fd8	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a5fdc	c2 20		rep #$20	            REP #$20
.3a5fde	a5 23		lda $0823	                LDA ARGUMENT1
.3a5fe0	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a5fe4	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.3a5fe8	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a5fec	af 22 66 3a	lda $3a6622	                LDA @l fp_one
.3a5ff0	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a5ff4	af 24 66 3a	lda $3a6624	                LDA @l fp_one+2
.3a5ff8	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a5ffc	ea		nop		                NOP
.3a5ffd	ea		nop		                NOP
.3a5ffe	ea		nop		                NOP
.3a5fff	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a6003	85 23		sta $0823	                STA ARGUMENT1
.3a6005	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a6009	85 25		sta $0825	                STA ARGUMENT1+2
.3a600b	60		rts		                RTS
.3a600c					Q_FP_SCALE
.3a600c	a2 00 00	ldx #$0000	                LDX #0
.3a600f	a5 23		lda $0823	loop            LDA ARGUMENT1
.3a6011	c5 29		cmp $0829	                CMP ARGUMENT2
.3a6013	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6015	e5 2b		sbc $082b	                SBC ARGUMENT2+2
.3a6017	90 1e		bcc $3a6037	                BCC done
.3a6019	a5 23		lda $0823	                LDA ARGUMENT1
.3a601b	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a601f	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6021	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a6025	ea		nop		                NOP
.3a6026	ea		nop		                NOP
.3a6027	ea		nop		                NOP
.3a6028	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a602c	85 23		sta $0823	                STA ARGUMENT1
.3a602e	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a6032	85 25		sta $0825	                STA ARGUMENT1+2
.3a6034	e8		inx		                INX
.3a6035	80 d8		bra $3a600f	                BRA loop
.3a6037					done
.3a6037	60		rts		            RTS
.3a6038					Q_FP_SCALE_TAU
.3a6038	e2 20		sep #$20	            SEP #$20
.3a603a	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a603c	10 09		bpl $3a6047	                BPL notneg
.3a603e	29 7f		and #$7f	                AND #$7F
.3a6040	85 26		sta $0826	                STA ARGUMENT1+3
.3a6042	a9 01		lda #$01	                LDA #1
.3a6044	48		pha		                PHA
.3a6045	80 03		bra $3a604a	                BRA compute
.3a6047	a9 00		lda #$00	notneg          LDA #0          ; not negative, so push 0.
.3a6049	48		pha		                PHA
.3a604a	a9 40		lda #$40	compute         LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a604c	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a6050	a9 02		lda #$02	                LDA #FP_OUT_ADD
.3a6052	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a6056	c2 30		rep #$30	            REP #$30
.3a6058	af 8a 66 3a	lda $3a668a	                LDA @l twopi
.3a605c	85 29		sta $0829	                STA ARGUMENT2
.3a605e	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a6062	af 8c 66 3a	lda $3a668c	                LDA @l twopi+2
.3a6066	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6068	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a606c	20 0c 60	jsr $3a600c	            JSR Q_FP_SCALE
.3a606f	e2 20		sep #$20	            SEP #$20
.3a6071	68		pla		                PLA
.3a6072	c2 20		rep #$20	            REP #$20
.3a6074	f0 1e		beq $3a6094	                BEQ done
.3a6076	a5 23		lda $0823	                LDA ARGUMENT1
.3a6078	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a607c	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a607e	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a6082	ea		nop		                NOP
.3a6083	ea		nop		                NOP
.3a6084	ea		nop		                NOP
.3a6085	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a6089	85 23		sta $0823	                STA ARGUMENT1
.3a608b	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a608f	29 ff 7f	and #$7fff	                AND #$7fff
.3a6092	85 25		sta $0825	                STA ARGUMENT1+2
.3a6094					done
.3a6094	60		rts		            RTS
.3a6095					Q_FP_NORM_ANGLE
.3a6095	5a		phy		                PHY
.3a6096	a2 00 00	ldx #$0000	                LDX #0
.3a6099	a0 00 00	ldy #$0000	                LDY #0
.3a609c	a5 23		lda $0823	loop            LDA ARGUMENT1
.3a609e	df 8e 66 3a	cmp $3a668e,x	                CMP @l onepi,x
.3a60a2	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a60a4	ff 90 66 3a	sbc $3a6690,x	                SBC @l onepi+2,x
.3a60a8	90 2c		bcc $3a60d6	                BCC less
.3a60aa	bf 8a 66 3a	lda $3a668a,x	                LDA @l twopi,x
.3a60ae	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a60b2	bf 8c 66 3a	lda $3a668c,x	                LDA @l twopi+2,x
.3a60b6	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a60ba	a5 23		lda $0823	                LDA ARGUMENT1
.3a60bc	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a60c0	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a60c2	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a60c6	ea		nop		                NOP
.3a60c7	ea		nop		                NOP
.3a60c8	ea		nop		                NOP
.3a60c9	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a60cd	85 23		sta $0823	                STA ARGUMENT1
.3a60cf	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a60d3	85 25		sta $0825	                STA ARGUMENT1+2
.3a60d5	38		sec		                SEC             ; set carry to indicate a reflection
.3a60d6	98		tya		less            TYA             ; carry already cleared if we branched
.3a60d7	2a		rol a		                ROL             ; shift carry into flags...
.3a60d8	a8		tay		                TAY             ; and store back into y
.3a60d9	e8		inx		                INX             ; next set of values
.3a60da	e8		inx		                INX
.3a60db	e8		inx		                INX
.3a60dc	e8		inx		                INX
.3a60dd	e0 0c 00	cpx #$000c	                CPX #12         ; check if we have already looked at 3
.3a60e0	d0 ba		bne $3a609c	                BNE loop
.3a60e2	98		tya		                TYA             ; copy Y to X, as that's what we have
.3a60e3	aa		tax		                TAX
.3a60e4	7a		ply		                PLY
.3a60e5	60		rts		            RTS
.3a60e6					Q_FP_COS
.3a60e6	08		php		                PHP
.3a60e7	c2 30		rep #$30	            REP #$30
.3a60e9	48		pha		                PHA
.3a60ea	da		phx		                PHX
.3a60eb	20 98 5f	jsr $3a5f98	            JSR Q_SQ
.3a60ee	8b		phb		                PHB
.3a60ef	e2 20		sep #$20	            SEP #$20
.3a60f1	a9 3a		lda #$3a	                LDA #`cos_coeff
.3a60f3	48		pha		                PHA
.3a60f4	ab		plb		                PLB
.3a60f5	c2 20		rep #$20	            REP #$20
.3a60f7	a2 ca 65	ldx #$65ca	                LDX #<>cos_coeff
.3a60fa	5a		phy		                PHY
.3a60fb	a0 05 00	ldy #$0005	                LDY #5
.3a60fe	20 09 5f	jsr $3a5f09	            JSR Q_POLY_HR
.3a6101	7a		ply		                PLY
.3a6102	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.3a6105	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.3a6109	ab		plb		                PLB
.3a610a	fa		plx		                PLX
.3a610b	68		pla		                PLA
.3a610c	28		plp		                PLP
.3a610d	60		rts		            RTS
.3a610e					Q_FP_SIN
.3a610e	08		php		                PHP
.3a610f	c2 30		rep #$30	            REP #$30
.3a6111	48		pha		                PHA
.3a6112	da		phx		                PHX
.3a6113	a5 23		lda $0823	                LDA ARGUMENT1
.3a6115	85 29		sta $0829	                STA ARGUMENT2
.3a6117	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6119	85 2b		sta $082b	                STA ARGUMENT2+2
.3a611b	20 98 5f	jsr $3a5f98	            JSR Q_SQ
.3a611e	8b		phb		                PHB
.3a611f	e2 20		sep #$20	            SEP #$20
.3a6121	a9 3a		lda #$3a	                LDA #`sin_coeff
.3a6123	48		pha		                PHA
.3a6124	ab		plb		                PLB
.3a6125	c2 20		rep #$20	            REP #$20
.3a6127	a2 de 65	ldx #$65de	                LDX #<>sin_coeff
.3a612a	5a		phy		                PHY
.3a612b	a0 05 00	ldy #$0005	                LDY #5
.3a612e	20 09 5f	jsr $3a5f09	            JSR Q_POLY_HR
.3a6131	7a		ply		                PLY
.3a6132	ab		plb		                PLB
.3a6133	20 73 57	jsr $3a5773	            JSR OP_FP_MUL
.3a6136	fa		plx		                PLX
.3a6137	68		pla		                PLA
.3a6138	28		plp		                PLP
.3a6139	60		rts		            RTS
.3a613a					Q_FP_TAN
.3a613a	08		php		                PHP
.3a613b	c2 30		rep #$30	            REP #$30
.3a613d	48		pha		                PHA
.3a613e	da		phx		                PHX
.3a613f	a5 23		lda $0823	                LDA ARGUMENT1
.3a6141	85 29		sta $0829	                STA ARGUMENT2
.3a6143	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6145	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6147	20 98 5f	jsr $3a5f98	            JSR Q_SQ
.3a614a	8b		phb		                PHB
.3a614b	e2 20		sep #$20	            SEP #$20
.3a614d	a9 3a		lda #$3a	                LDA #`tan_coeff
.3a614f	48		pha		                PHA
.3a6150	ab		plb		                PLB
.3a6151	c2 20		rep #$20	            REP #$20
.3a6153	a2 f2 65	ldx #$65f2	                LDX #<>tan_coeff
.3a6156	5a		phy		                PHY
.3a6157	a0 05 00	ldy #$0005	                LDY #5
.3a615a	20 09 5f	jsr $3a5f09	            JSR Q_POLY_HR
.3a615d	7a		ply		                PLY
.3a615e	ab		plb		                PLB
.3a615f	20 73 57	jsr $3a5773	            JSR OP_FP_MUL
.3a6162	fa		plx		                PLX
.3a6163	68		pla		                PLA
.3a6164	28		plp		                PLP
.3a6165	60		rts		            RTS
.3a6166					Q_FP_LN
.3a6166	08		php		                PHP
.3a6167	c2 30		rep #$30	            REP #$30
.3a6169	48		pha		                PHA
.3a616a	da		phx		                PHX
.3a616b	e2 20		sep #$20	            SEP #$20
.3a616d	a9 40		lda #$40	                LDA #FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a616f	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a6173	a9 02		lda #$02	                LDA #FP_OUT_ADD
.3a6175	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a6179	c2 20		rep #$20	            REP #$20
.3a617b	a5 23		lda $0823	                LDA ARGUMENT1
.3a617d	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a6181	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6183	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a6187	af 22 66 3a	lda $3a6622	                LDA @l fp_one
.3a618b	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a618f	af 24 66 3a	lda $3a6624	                LDA @l fp_one+2
.3a6193	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a6197	ea		nop		                NOP
.3a6198	ea		nop		                NOP
.3a6199	ea		nop		                NOP
.3a619a	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a619e	85 0c		sta $080c	                STA SCRATCH
.3a61a0	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a61a4	85 0e		sta $080e	                STA SCRATCH+2
.3a61a6	e2 20		sep #$20	            SEP #$20
.3a61a8	a9 48		lda #$48	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX1
.3a61aa	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a61ae	c2 20		rep #$20	            REP #$20
.3a61b0	ea		nop		                NOP
.3a61b1	ea		nop		                NOP
.3a61b2	ea		nop		                NOP
.3a61b3	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a61b7	85 10		sta $0810	                STA SCRATCH2
.3a61b9	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a61bd	85 12		sta $0812	                STA SCRATCH2+2
.3a61bf	e2 20		sep #$20	            SEP #$20
.3a61c1	a9 01		lda #$01	                LDA #FP_OUT_DIV
.3a61c3	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a61c7	c2 20		rep #$20	            REP #$20
.3a61c9	a5 0c		lda $080c	                LDA SCRATCH
.3a61cb	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a61cf	a5 0e		lda $080e	                LDA SCRATCH+2
.3a61d1	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a61d5	a5 10		lda $0810	                LDA SCRATCH2
.3a61d7	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a61db	a5 12		lda $0812	                LDA SCRATCH2+2
.3a61dd	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a61e1	ea		nop		                NOP
.3a61e2	ea		nop		                NOP
.3a61e3	ea		nop		                NOP
.3a61e4	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a61e8	85 23		sta $0823	                STA ARGUMENT1
.3a61ea	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a61ee	85 25		sta $0825	                STA ARGUMENT1+2
.3a61f0	e2 20		sep #$20	            SEP #$20
.3a61f2	a9 08		lda #$08	                LDA #FP_MATH_CTRL0_ADD | FP_ADD_IN0_MUX0 | FP_ADD_IN1_MUX0
.3a61f4	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a61f8	a9 02		lda #$02	                LDA #FP_OUT_ADD
.3a61fa	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a61fe	c2 20		rep #$20	            REP #$20
.3a6200	a5 23		lda $0823	                LDA ARGUMENT1
.3a6202	8f 08 e2 af	sta $afe208	                STA @l FP_MATH_INPUT0_LL
.3a6206	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6208	8f 0a e2 af	sta $afe20a	                STA @l FP_MATH_INPUT0_HL
.3a620c	ea		nop		                NOP
.3a620d	ea		nop		                NOP
.3a620e	ea		nop		                NOP
.3a620f	af 08 e2 af	lda $afe208	                LDA @l FP_MATH_OUTPUT_FP_LL
.3a6213	85 29		sta $0829	                STA ARGUMENT2
.3a6215	af 0a e2 af	lda $afe20a	                LDA @l FP_MATH_OUTPUT_FP_HL
.3a6219	85 2b		sta $082b	                STA ARGUMENT2+2
.3a621b	20 98 5f	jsr $3a5f98	            JSR Q_SQ
.3a621e	8b		phb		                PHB
.3a621f	e2 20		sep #$20	            SEP #$20
.3a6221	a9 3a		lda #$3a	                LDA #`ln_coeff
.3a6223	48		pha		                PHA
.3a6224	ab		plb		                PLB
.3a6225	c2 20		rep #$20	            REP #$20
.3a6227	a2 06 66	ldx #$6606	                LDX #<>ln_coeff
.3a622a	5a		phy		                PHY
.3a622b	a0 08 00	ldy #$0008	                LDY #8
.3a622e	20 09 5f	jsr $3a5f09	            JSR Q_POLY_HR
.3a6231	7a		ply		                PLY
.3a6232	a9 01 00	lda #$0001	                LDA #TYPE_FLOAT
.3a6235	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.3a6239	8f 2d 08 00	sta $00082d	                STA @l ARGTYPE2
.3a623d	20 73 57	jsr $3a5773	            JSR OP_FP_MUL
.3a6240	ab		plb		                PLB
.3a6241	fa		plx		                PLX
.3a6242	68		pla		                PLA
.3a6243	28		plp		                PLP
.3a6244	60		rts		            RTS
.3a6245					FP_SIN
.3a6245	08		php		                PHP
.3a6246	c2 30		rep #$30	            REP #$30
.3a6248	48		pha		                PHA
.3a6249	da		phx		                PHX
.3a624a	20 38 60	jsr $3a6038	            JSR Q_FP_SCALE_TAU
.3a624d	20 95 60	jsr $3a6095	            JSR Q_FP_NORM_ANGLE
.3a6250	da		phx		                PHX
.3a6251	8a		txa		                TXA
.3a6252	29 01 00	and #$0001	                AND #1
.3a6255	d0 05		bne $3a625c	                BNE do_cos
.3a6257	20 0e 61	jsr $3a610e	            JSR Q_FP_SIN
.3a625a	80 03		bra $3a625f	                BRA maybe_neg
.3a625c					do_cos
.3a625c	20 e6 60	jsr $3a60e6	            JSR Q_FP_COS
.3a625f	fa		plx		maybe_neg       PLX
.3a6260	8a		txa		                TXA
.3a6261	29 04 00	and #$0004	                AND #4
.3a6264	f0 0a		beq $3a6270	                BEQ done
.3a6266	e2 20		sep #$20	            SEP #$20
.3a6268	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a626a	09 80		ora #$80	                ORA #$80
.3a626c	85 26		sta $0826	                STA ARGUMENT1+3
.3a626e	c2 20		rep #$20	            REP #$20
.3a6270	fa		plx		done            PLX
.3a6271	68		pla		                PLA
.3a6272	28		plp		                PLP
.3a6273	60		rts		            RTS
.3a6274					FP_COS
.3a6274	08		php		                PHP
.3a6275	c2 30		rep #$30	            REP #$30
.3a6277	48		pha		                PHA
.3a6278	da		phx		                PHX
.3a6279	20 38 60	jsr $3a6038	            JSR Q_FP_SCALE_TAU
.3a627c	20 95 60	jsr $3a6095	            JSR Q_FP_NORM_ANGLE
.3a627f	da		phx		                PHX
.3a6280	8a		txa		                TXA
.3a6281	29 01 00	and #$0001	                AND #1
.3a6284	d0 05		bne $3a628b	                BNE do_sin
.3a6286	20 e6 60	jsr $3a60e6	            JSR Q_FP_COS
.3a6289	80 03		bra $3a628e	                BRA maybe_neg
.3a628b					do_sin
.3a628b	20 0e 61	jsr $3a610e	            JSR Q_FP_SIN
.3a628e	fa		plx		maybe_neg       PLX
.3a628f	8a		txa		                TXA
.3a6290	29 02 00	and #$0002	                AND #2
.3a6293	f0 0a		beq $3a629f	                BEQ done
.3a6295	e2 20		sep #$20	            SEP #$20
.3a6297	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a6299	09 80		ora #$80	                ORA #$80
.3a629b	85 26		sta $0826	                STA ARGUMENT1+3
.3a629d	c2 20		rep #$20	            REP #$20
.3a629f	fa		plx		done            PLX
.3a62a0	68		pla		                PLA
.3a62a1	28		plp		                PLP
.3a62a2	60		rts		            RTS
.3a62a3					FP_TAN
.3a62a3	08		php		                PHP
.3a62a4	c2 30		rep #$30	            REP #$30
.3a62a6	48		pha		                PHA
.3a62a7	da		phx		                PHX
.3a62a8	20 38 60	jsr $3a6038	            JSR Q_FP_SCALE_TAU
.3a62ab	20 95 60	jsr $3a6095	            JSR Q_FP_NORM_ANGLE
.3a62ae	20 3a 61	jsr $3a613a	            JSR Q_FP_TAN
.3a62b1	8a		txa		                TXA
.3a62b2	29 01 00	and #$0001	                AND #1
.3a62b5	f0 03		beq $3a62ba	                BEQ no_inv
.3a62b7	20 ce 5f	jsr $3a5fce	            JSR Q_INV
.3a62ba	8a		txa		no_inv          TXA
.3a62bb	e2 20		sep #$20	            SEP #$20
.3a62bd	4a		lsr a		                LSR
.3a62be	4a		lsr a		                LSR
.3a62bf	69 00		adc #$00	                ADC #0
.3a62c1	29 01		and #$01	                AND #1
.3a62c3	f0 06		beq $3a62cb	                BEQ no_neg
.3a62c5	a5 26		lda $0826	                LDA ARGUMENT1+3
.3a62c7	09 80		ora #$80	                ORA #$80
.3a62c9	85 26		sta $0826	                STA ARGUMENT1+3
.3a62cb					no_neg
.3a62cb	c2 20		rep #$20	            REP #$20
.3a62cd	fa		plx		                PLX
.3a62ce	68		pla		                PLA
.3a62cf	28		plp		                PLP
.3a62d0	60		rts		            RTS
.3a62d1					FP_LN
.3a62d1	08		php		                PHP
.3a62d2	c2 30		rep #$30	            REP #$30
.3a62d4	48		pha		                PHA
.3a62d5	da		phx		                PHX
.3a62d6	5a		phy		                PHY
.3a62d7	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a62d9	10 1f		bpl $3a62fa	                BPL arg_ok
.3a62db	08		php		            PHP
.3a62dc	c2 20		rep #$20	            REP #$20
.3a62de	48		pha		            PHA
.3a62df	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a62e2	5b		tcd		            TCD
.3a62e3	68		pla		            PLA
.3a62e4	28		plp		            PLP
.3a62e5	e2 20		sep #$20	            SEP #$20
.3a62e7	a9 17		lda #$17	            LDA #ERR_DOMAIN
.3a62e9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a62ed	c2 20		rep #$20	            REP #$20
.3a62ef	29 ff 00	and #$00ff	            AND #$00FF
.3a62f2	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a62f5	e2 20		sep #$20	            SEP #$20
.3a62f7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a62fa					arg_ok
.3a62fa	c2 30		rep #$30	            REP #$30
.3a62fc	a5 23		lda $0823	                LDA ARGUMENT1
.3a62fe	cf 22 66 3a	cmp $3a6622	                CMP @l fp_one
.3a6302	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6304	cf 24 66 3a	cmp $3a6624	                CMP @l fp_one+2
.3a6308	b0 04		bcs $3a630e	                BCS gtone
.3a630a	20 ce 5f	jsr $3a5fce	            JSR Q_INV
.3a630d	18		clc		                CLC
.3a630e	a9 00 00	lda #$0000	gtone           LDA #0
.3a6311	a8		tay		                TAY
.3a6312	2a		rol a		                ROL             ; Rotate Carry into A; 0 means negate
.3a6313	48		pha		                PHA
.3a6314	e2 20		sep #$20	            SEP #$20
.3a6316	a9 00		lda #$00	                LDA #0
.3a6318	8f 00 e2 af	sta $afe200	                STA @l FP_MATH_CTRL0
.3a631c	a9 01		lda #$01	                LDA #FP_OUT_DIV
.3a631e	8f 01 e2 af	sta $afe201	                STA @l FP_MATH_CTRL1
.3a6322	c2 20		rep #$20	            REP #$20
.3a6324	af 7a 66 3a	lda $3a667a	                LDA @l eexp64
.3a6328	85 29		sta $0829	                STA ARGUMENT2
.3a632a	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a632e	af 7c 66 3a	lda $3a667c	                LDA @l eexp64+2
.3a6332	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6334	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a6338	20 0c 60	jsr $3a600c	            JSR Q_FP_SCALE
.3a633b	8a		txa		                TXA
.3a633c	f0 07		beq $3a6345	                BEQ chk16
.3a633e	0a		asl a		                ASL             ; multiply counter by 64
.3a633f	0a		asl a		                ASL
.3a6340	0a		asl a		                ASL
.3a6341	0a		asl a		                ASL
.3a6342	0a		asl a		                ASL
.3a6343	0a		asl a		                ASL
.3a6344	a8		tay		                TAY
.3a6345	af 7e 66 3a	lda $3a667e	chk16           LDA @l eexp16
.3a6349	85 29		sta $0829	                STA ARGUMENT2
.3a634b	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a634f	af 80 66 3a	lda $3a6680	                LDA @l eexp16+2
.3a6353	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6355	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a6359	20 0c 60	jsr $3a600c	            JSR Q_FP_SCALE
.3a635c	8a		txa		                TXA
.3a635d	f0 0b		beq $3a636a	                BEQ chk04
.3a635f	0a		asl a		                ASL             ; multiply counter by 16
.3a6360	0a		asl a		                ASL
.3a6361	0a		asl a		                ASL
.3a6362	0a		asl a		                ASL
.3a6363	85 29		sta $0829	                STA ARGUMENT2   ; and add into total
.3a6365	18		clc		                CLC
.3a6366	98		tya		                TYA
.3a6367	65 29		adc $0829	                ADC ARGUMENT2
.3a6369	a8		tay		                TAY
.3a636a	af 82 66 3a	lda $3a6682	chk04           LDA @l eexp04
.3a636e	85 29		sta $0829	                STA ARGUMENT2
.3a6370	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a6374	af 84 66 3a	lda $3a6684	                LDA @l eexp04+2
.3a6378	85 2b		sta $082b	                STA ARGUMENT2+2
.3a637a	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a637e	20 0c 60	jsr $3a600c	            JSR Q_FP_SCALE
.3a6381	8a		txa		                TXA
.3a6382	f0 09		beq $3a638d	                BEQ chk01
.3a6384	0a		asl a		                ASL             ;multiply counter by 4
.3a6385	0a		asl a		                ASL
.3a6386	85 29		sta $0829	                STA ARGUMENT2   ;and add to total
.3a6388	18		clc		                CLC
.3a6389	98		tya		                TYA
.3a638a	65 29		adc $0829	                ADC ARGUMENT2
.3a638c	a8		tay		                TAY
.3a638d	af 86 66 3a	lda $3a6686	chk01           LDA @l eexp01
.3a6391	85 29		sta $0829	                STA ARGUMENT2
.3a6393	8f 0c e2 af	sta $afe20c	                STA @l FP_MATH_INPUT1_LL
.3a6397	af 88 66 3a	lda $3a6688	                LDA @l eexp01+2
.3a639b	85 2b		sta $082b	                STA ARGUMENT2+2
.3a639d	8f 0e e2 af	sta $afe20e	                STA @l FP_MATH_INPUT1_HL
.3a63a1	20 0c 60	jsr $3a600c	            JSR Q_FP_SCALE
.3a63a4	86 29		stx $0829	                STX ARGUMENT2   ; add counter to total
.3a63a6	18		clc		                CLC
.3a63a7	98		tya		                TYA
.3a63a8	65 29		adc $0829	                ADC ARGUMENT2
.3a63aa	a8		tay		                TAY
.3a63ab	20 66 61	jsr $3a6166	            JSR Q_FP_LN
.3a63ae	a5 23		lda $0823	                LDA ARGUMENT1
.3a63b0	85 29		sta $0829	                STA ARGUMENT2
.3a63b2	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a63b4	85 2b		sta $082b	                STA ARGUMENT2+2
.3a63b6	98		tya		                TYA
.3a63b7	85 23		sta $0823	                STA ARGUMENT1
.3a63b9	64 25		stz $0825	                STZ ARGUMENT1+2
.3a63bb	20 00 5c	jsr $3a5c00	            JSR ITOF
.3a63be	20 dd 56	jsr $3a56dd	            JSR OP_FP_ADD
.3a63c1	68		pla		                PLA
.3a63c2	d0 07		bne $3a63cb	                BNE done
.3a63c4	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a63c6	09 00 80	ora #$8000	                ORA #$8000
.3a63c9	85 25		sta $0825	                STA ARGUMENT1+2
.3a63cb	7a		ply		done            PLY
.3a63cc	fa		plx		                PLX
.3a63cd	68		pla		                PLA
.3a63ce	28		plp		                PLP
.3a63cf	60		rts		            RTS
.3a63d0					FP_ASIN
.3a63d0	08		php		                PHP
.3a63d1	c2 30		rep #$30	            REP #$30
.3a63d3	48		pha		                PHA
.3a63d4	da		phx		                PHX
.3a63d5	a5 23		lda $0823	                LDA ARGUMENT1
.3a63d7	85 29		sta $0829	                STA ARGUMENT2
.3a63d9	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a63db	85 2b		sta $082b	                STA ARGUMENT2+2
.3a63dd	20 98 5f	jsr $3a5f98	            JSR Q_SQ
.3a63e0	8b		phb		                PHB
.3a63e1	e2 20		sep #$20	            SEP #$20
.3a63e3	a9 3a		lda #$3a	                LDA #`asin_coeff
.3a63e5	48		pha		                PHA
.3a63e6	ab		plb		                PLB
.3a63e7	c2 20		rep #$20	            REP #$20
.3a63e9	a2 2a 66	ldx #$662a	                LDX #<>asin_coeff
.3a63ec	a0 05 00	ldy #$0005	                LDY #5
.3a63ef	20 09 5f	jsr $3a5f09	            JSR Q_POLY_HR
.3a63f2	ab		plb		                PLB
.3a63f3	20 73 57	jsr $3a5773	            JSR OP_FP_MUL
.3a63f6	fa		plx		                PLX
.3a63f7	68		pla		                PLA
.3a63f8	28		plp		                PLP
.3a63f9	60		rts		            RTS
.3a63fa					FP_ACOS
.3a63fa	08		php		                PHP
.3a63fb	c2 30		rep #$30	            REP #$30
.3a63fd	48		pha		                PHA
.3a63fe	da		phx		                PHX
.3a63ff	20 d0 63	jsr $3a63d0	            JSR FP_ASIN
.3a6402	af 92 66 3a	lda $3a6692	                LDA @l halfpi
.3a6406	85 29		sta $0829	                STA ARGUMENT2
.3a6408	af 94 66 3a	lda $3a6694	                LDA @l halfpi+2
.3a640c	85 2b		sta $082b	                STA ARGUMENT2+2
.3a640e	20 d2 56	jsr $3a56d2	            JSR OP_FP_SUB
.3a6411	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6413	49 00 80	eor #$8000	                EOR #$8000
.3a6416	85 25		sta $0825	                STA ARGUMENT1+2
.3a6418	fa		plx		                PLX
.3a6419	68		pla		                PLA
.3a641a	28		plp		                PLP
.3a641b	60		rts		            RTS
.3a641c					FP_ATAN
.3a641c	08		php		                PHP
.3a641d	c2 30		rep #$30	            REP #$30
.3a641f	48		pha		                PHA
.3a6420	da		phx		                PHX
.3a6421	a5 23		lda $0823	                LDA ARGUMENT1
.3a6423	85 29		sta $0829	                STA ARGUMENT2
.3a6425	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6427	85 2b		sta $082b	                STA ARGUMENT2+2
.3a6429	20 98 5f	jsr $3a5f98	            JSR Q_SQ
.3a642c	8b		phb		                PHB
.3a642d	e2 20		sep #$20	            SEP #$20
.3a642f	a9 3a		lda #$3a	                LDA #`atan_coeff
.3a6431	48		pha		                PHA
.3a6432	ab		plb		                PLB
.3a6433	c2 20		rep #$20	            REP #$20
.3a6435	a2 3e 66	ldx #$663e	                LDX #<>atan_coeff
.3a6438	a0 05 00	ldy #$0005	                LDY #5
.3a643b	20 09 5f	jsr $3a5f09	            JSR Q_POLY_HR
.3a643e	ab		plb		                PLB
.3a643f	20 73 57	jsr $3a5773	            JSR OP_FP_MUL
.3a6442	fa		plx		                PLX
.3a6443	68		pla		                PLA
.3a6444	28		plp		                PLP
.3a6445	60		rts		            RTS
.3a6446					Q_FP_POW_INT
.3a6446	c2 20		rep #$20	            REP #$20
.3a6448	a5 23		lda $0823	            LDA ARGUMENT1
.3a644a	85 29		sta $0829	            STA ARGUMENT2
.3a644c	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a644e	85 2b		sta $082b	            STA ARGUMENT2+2
.3a6450	c2 20		rep #$20	            REP #$20
.3a6452	af 22 66 3a	lda $3a6622	            LDA @l fp_one
.3a6456	85 23		sta $0823	            STA ARGUMENT1
.3a6458	af 24 66 3a	lda $3a6624	            LDA @l fp_one+2
.3a645c	85 25		sta $0825	            STA ARGUMENT1+2
.3a645e	8a		txa		loop            TXA
.3a645f	f0 30		beq $3a6491	                BEQ done
.3a6461	4a		lsr a		                LSR
.3a6462	aa		tax		                TAX
.3a6463	90 03		bcc $3a6468	                BCC next
.3a6465	20 73 57	jsr $3a5773	            JSR OP_FP_MUL
.3a6468					next
.3a6468	c2 20		rep #$20	            REP #$20
.3a646a	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a646c	48		pha		            PHA
.3a646d	a5 23		lda $0823	            LDA ARGUMENT1
.3a646f	48		pha		            PHA
.3a6470	c2 20		rep #$20	            REP #$20
.3a6472	a5 29		lda $0829	            LDA ARGUMENT2
.3a6474	85 23		sta $0823	            STA ARGUMENT1
.3a6476	a5 2b		lda $082b	            LDA ARGUMENT2+2
.3a6478	85 25		sta $0825	            STA ARGUMENT1+2
.3a647a	20 98 5f	jsr $3a5f98	            JSR Q_SQ
.3a647d	c2 20		rep #$20	            REP #$20
.3a647f	a5 23		lda $0823	            LDA ARGUMENT1
.3a6481	85 29		sta $0829	            STA ARGUMENT2
.3a6483	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a6485	85 2b		sta $082b	            STA ARGUMENT2+2
.3a6487	c2 20		rep #$20	            REP #$20
.3a6489	68		pla		            PLA
.3a648a	85 23		sta $0823	            STA ARGUMENT1
.3a648c	68		pla		            PLA
.3a648d	85 25		sta $0825	            STA ARGUMENT1+2
.3a648f	80 cd		bra $3a645e	                BRA loop
.3a6491					done
.3a6491	60		rts		            RTS
.3a6492					Q_FP_EXP
.3a6492	08		php		                PHP
.3a6493	c2 30		rep #$30	            REP #$30
.3a6495	48		pha		                PHA
.3a6496	da		phx		                PHX
.3a6497	8b		phb		                PHB
.3a6498	e2 20		sep #$20	            SEP #$20
.3a649a	a9 3a		lda #$3a	                LDA #`exp_coeff
.3a649c	48		pha		                PHA
.3a649d	ab		plb		                PLB
.3a649e	c2 20		rep #$20	            REP #$20
.3a64a0	a2 52 66	ldx #$6652	                LDX #<>exp_coeff
.3a64a3	5a		phy		                PHY
.3a64a4	a0 0a 00	ldy #$000a	                LDY #10
.3a64a7	20 09 5f	jsr $3a5f09	            JSR Q_POLY_HR
.3a64aa	7a		ply		                PLY
.3a64ab	ab		plb		                PLB
.3a64ac	fa		plx		                PLX
.3a64ad	68		pla		                PLA
.3a64ae	28		plp		                PLP
.3a64af	60		rts		            RTS
.3a64b0					FP_EXP
.3a64b0	08		php		                PHP
.3a64b1	c2 30		rep #$30	            REP #$30
.3a64b3	48		pha		                PHA
.3a64b4	da		phx		                PHX
.3a64b5	5a		phy		                PHY
.3a64b6	a5 23		lda $0823	                LDA ARGUMENT1   ; special case for x==0
.3a64b8	05 25		ora $0825	                ORA ARGUMENT1+2
.3a64ba	d0 10		bne $3a64cc	                BNE notzero
.3a64bc	c2 20		rep #$20	            REP #$20
.3a64be	af 22 66 3a	lda $3a6622	            LDA @l fp_one
.3a64c2	85 23		sta $0823	            STA ARGUMENT1
.3a64c4	af 24 66 3a	lda $3a6624	            LDA @l fp_one+2
.3a64c8	85 25		sta $0825	            STA ARGUMENT1+2
.3a64ca	80 61		bra $3a652d	                BRA done
.3a64cc	a5 25		lda $0825	notzero         LDA ARGUMENT1+2 ; check if negative
.3a64ce	29 00 80	and #$8000	                AND #$8000
.3a64d1	a8		tay		                TAY             ; Y != 0 -> arg was negative
.3a64d2	f0 07		beq $3a64db	                BEQ notneg
.3a64d4	a5 25		lda $0825	                LDA ARGUMENT1+2 ; negate x
.3a64d6	29 ff 7f	and #$7fff	                AND #$7FFF
.3a64d9	85 25		sta $0825	                STA ARGUMENT1+2
.3a64db					notneg
.3a64db	c2 20		rep #$20	            REP #$20
.3a64dd	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a64df	48		pha		            PHA
.3a64e0	a5 23		lda $0823	            LDA ARGUMENT1
.3a64e2	48		pha		            PHA
.3a64e3	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a64e6	a6 23		ldx $0823	                LDX ARGUMENT1              ; INT(x) now in ARGUMENT1; low 16 bits into X
.3a64e8	20 bf 07	jsr $3a07bf	            JSR ASS_ARG1_FLOAT
.3a64eb	c2 20		rep #$20	            REP #$20
.3a64ed	a5 23		lda $0823	            LDA ARGUMENT1
.3a64ef	85 29		sta $0829	            STA ARGUMENT2
.3a64f1	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a64f3	85 2b		sta $082b	            STA ARGUMENT2+2
.3a64f5	c2 20		rep #$20	            REP #$20
.3a64f7	68		pla		            PLA
.3a64f8	85 23		sta $0823	            STA ARGUMENT1
.3a64fa	68		pla		            PLA
.3a64fb	85 25		sta $0825	            STA ARGUMENT1+2
.3a64fd	20 d2 56	jsr $3a56d2	            JSR OP_FP_SUB
.3a6500	20 92 64	jsr $3a6492	            JSR Q_FP_EXP
.3a6503	c2 20		rep #$20	            REP #$20
.3a6505	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a6507	48		pha		            PHA
.3a6508	a5 23		lda $0823	            LDA ARGUMENT1
.3a650a	48		pha		            PHA
.3a650b	c2 20		rep #$20	            REP #$20
.3a650d	af 86 66 3a	lda $3a6686	            LDA @leexp01
.3a6511	85 23		sta $0823	            STA ARGUMENT1
.3a6513	af 88 66 3a	lda $3a6688	            LDA @leexp01+2
.3a6517	85 25		sta $0825	            STA ARGUMENT1+2
.3a6519	20 46 64	jsr $3a6446	            JSR Q_FP_POW_INT
.3a651c	c2 20		rep #$20	            REP #$20
.3a651e	68		pla		            PLA
.3a651f	85 29		sta $0829	            STA ARGUMENT2
.3a6521	68		pla		            PLA
.3a6522	85 2b		sta $082b	            STA ARGUMENT2+2
.3a6524	20 73 57	jsr $3a5773	            JSR OP_FP_MUL
.3a6527	98		tya		                TYA
.3a6528	f0 03		beq $3a652d	                BEQ done
.3a652a	20 ce 5f	jsr $3a5fce	            JSR Q_INV
.3a652d	7a		ply		done            PLY
.3a652e	fa		plx		                PLX
.3a652f	68		pla		                PLA
.3a6530	28		plp		                PLP
.3a6531	60		rts		            RTS
.3a6532					FP_SQR
.3a6532	08		php		                PHP
.3a6533	c2 30		rep #$30	            REP #$30
.3a6535	48		pha		                PHA
.3a6536	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6538	10 1f		bpl $3a6559	                BPL arg_ok
.3a653a	08		php		            PHP
.3a653b	c2 20		rep #$20	            REP #$20
.3a653d	48		pha		            PHA
.3a653e	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6541	5b		tcd		            TCD
.3a6542	68		pla		            PLA
.3a6543	28		plp		            PLP
.3a6544	e2 20		sep #$20	            SEP #$20
.3a6546	a9 17		lda #$17	            LDA #ERR_DOMAIN
.3a6548	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a654c	c2 20		rep #$20	            REP #$20
.3a654e	29 ff 00	and #$00ff	            AND #$00FF
.3a6551	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a6554	e2 20		sep #$20	            SEP #$20
.3a6556	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6559					arg_ok
.3a6559	c2 30		rep #$30	            REP #$30
.3a655b	05 23		ora $0823	                ORA ARGUMENT1
.3a655d	f0 68		beq $3a65c7	                BEQ done
.3a655f	c2 20		rep #$20	            REP #$20
.3a6561	af 26 66 3a	lda $3a6626	            LDA @l fp_two
.3a6565	85 29		sta $0829	            STA ARGUMENT2
.3a6567	af 28 66 3a	lda $3a6628	            LDA @l fp_two+2
.3a656b	85 2b		sta $082b	            STA ARGUMENT2+2
.3a656d	e2 20		sep #$20	            SEP #$20
.3a656f	a9 01		lda #$01	                LDA #TYPE_FLOAT
.3a6571	85 2d		sta $082d	                STA ARGTYPE2
.3a6573	c2 20		rep #$20	            REP #$20
.3a6575	c2 20		rep #$20	            REP #$20
.3a6577	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a6579	48		pha		            PHA
.3a657a	a5 23		lda $0823	            LDA ARGUMENT1
.3a657c	48		pha		            PHA
.3a657d					loop
.3a657d	20 28 57	jsr $3a5728	            JSR OP_FP_DIV
.3a6580	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6582	c5 2b		cmp $082b	                CMP ARGUMENT2+2
.3a6584	d0 09		bne $3a658f	                BNE more
.3a6586	a5 23		lda $0823	                LDA ARGUMENT1
.3a6588	45 29		eor $0829	                EOR ARGUMENT2
.3a658a	29 f8 ff	and #$fff8	                AND #$FFF8
.3a658d	f0 30		beq $3a65bf	                BEQ exitloop
.3a658f					more
.3a658f	20 dd 56	jsr $3a56dd	            JSR OP_FP_ADD
.3a6592	c2 20		rep #$20	            REP #$20
.3a6594	af 26 66 3a	lda $3a6626	            LDA @l fp_two
.3a6598	85 29		sta $0829	            STA ARGUMENT2
.3a659a	af 28 66 3a	lda $3a6628	            LDA @l fp_two+2
.3a659e	85 2b		sta $082b	            STA ARGUMENT2+2
.3a65a0	20 28 57	jsr $3a5728	            JSR OP_FP_DIV
.3a65a3	c2 20		rep #$20	            REP #$20
.3a65a5	a5 23		lda $0823	            LDA ARGUMENT1
.3a65a7	85 29		sta $0829	            STA ARGUMENT2
.3a65a9	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a65ab	85 2b		sta $082b	            STA ARGUMENT2+2
.3a65ad	c2 20		rep #$20	            REP #$20
.3a65af	68		pla		            PLA
.3a65b0	85 23		sta $0823	            STA ARGUMENT1
.3a65b2	68		pla		            PLA
.3a65b3	85 25		sta $0825	            STA ARGUMENT1+2
.3a65b5	c2 20		rep #$20	            REP #$20
.3a65b7	a5 25		lda $0825	            LDA ARGUMENT1+2
.3a65b9	48		pha		            PHA
.3a65ba	a5 23		lda $0823	            LDA ARGUMENT1
.3a65bc	48		pha		            PHA
.3a65bd	80 be		bra $3a657d	                BRA loop
.3a65bf					exitloop
.3a65bf	c2 20		rep #$20	            REP #$20
.3a65c1	68		pla		            PLA
.3a65c2	85 29		sta $0829	            STA ARGUMENT2
.3a65c4	68		pla		            PLA
.3a65c5	85 2b		sta $082b	            STA ARGUMENT2+2
.3a65c7	68		pla		done            PLA
.3a65c8	28		plp		                PLP
.3a65c9	60		rts		            RTS
.3a65ca					cos_coeff
>3a65ca	01 0d d0 37			                .dword $37D00D01
>3a65ce	61 0b b6 ba			                .dword $BAB60B61
>3a65d2	ab aa 2a 3d			                .dword $3D2AAAAB
>3a65d6	00 00 00 bf			                .dword $BF000000
>3a65da	00 00 80 3f			                .dword $3F800000
.3a65de					sin_coeff
>3a65de	1d ef 38 36			                .dword $3638EF1D
>3a65e2	01 0d 50 b9			                .dword $B9500D01
>3a65e6	89 88 08 3c			                .dword $3C088889
>3a65ea	ab aa 2a be			                .dword $BE2AAAAB
>3a65ee	00 00 80 3f			                .dword $3F800000
.3a65f2					tan_coeff
>3a65f2	a4 27 b3 3c			                .dword $3CB327A4
>3a65f6	d1 0d 5d 3d			                .dword $3D5D0DD1
>3a65fa	89 88 08 3e			                .dword $3E088889
>3a65fe	ab aa aa 3e			                .dword $3EAAAAAB
>3a6602	00 00 80 3f			                .dword $3F800000
.3a6606					ln_coeff
>3a6606	89 88 88 3d			                .dword $3D888889
>3a660a	d9 89 9d 3d			                .dword $3D9D89D9
>3a660e	8c 2e ba 3d			                .dword $3DBA2E8C
>3a6612	39 8e e3 3d			                .dword $3DE38E39
>3a6616	25 49 12 3e			                .dword $3E124925
>3a661a	cd cc 4c 3e			                .dword $3E4CCCCD
>3a661e	ab aa aa 3e			                .dword $3EAAAAAB
>3a6622	00 00 80 3f			fp_one          .dword $3F800000
>3a6626	00 00 00 40			fp_two          .dword $40000000
.3a662a					asin_coeff
>3a662a	8e e3 f8 3c			                .dword $3CF8E38E
>3a662e	6e db 36 3d			                .dword $3D36DB6E
>3a6632	9a 99 99 3d			                .dword $3D99999A
>3a6636	ab aa 2a 3e			                .dword $3E2AAAAB
>3a663a	00 00 80 3f			                .dword $3F800000
.3a663e					atan_coeff
>3a663e	39 8e e3 3d			                .dword $3DE38E39
>3a6642	25 49 12 be			                .dword $BE124925
>3a6646	cd cc 4c 3e			                .dword $3E4CCCCD
>3a664a	ab aa aa be			                .dword $BEAAAAAB
>3a664e	00 00 80 3f			                .dword $3F800000
.3a6652					exp_coeff
>3a6652	1d ef 38 36			        .dword $3638EF1D
>3a6656	01 0d d0 37			        .dword $37D00D01
>3a665a	01 0d 50 39			        .dword $39500D01
>3a665e	61 0b b6 3a			        .dword $3AB60B61
>3a6662	89 88 08 3c			        .dword $3C088889
>3a6666	ab aa 2a 3d			        .dword $3D2AAAAB
>3a666a	ab aa 2a 3e			        .dword $3E2AAAAB
>3a666e	00 00 00 3f			        .dword $3F000000
>3a6672	00 00 80 3f			        .dword $3F800000
>3a6676	00 00 80 3f			        .dword $3F800000
>3a667a	c1 2c a1 6d			eexp64          .dword $6DA12CC1
>3a667e	5f 97 07 4b			eexp16          .dword $4B07975F
>3a6682	81 64 5a 42			eexp04          .dword $425A6481
>3a6686	54 f8 2d 40			eexp01          .dword $402DF854
>3a668a	db 0f c9 40			twopi           .dword $40C90FDB
>3a668e	db 0f 49 40			onepi           .dword $40490FDB
>3a6692	db 0f c9 3f			halfpi          .dword $3FC90FDB
>3a6696	db 0f 49 3f			quarterpi       .dword $3F490FDB

;******  Return to file: src\basic816.s


;******  Processing file: src\arrays.s

.3a669a					ARR_ALLOC
.3a669a	08		php		                PHP
.3a669b	20 0f 13	jsr $3a130f	            JSR HEAP_GETHED
.3a669e	c2 20		rep #$20	            REP #$20
.3a66a0	a9 01 00	lda #$0001	                LDA #1                      ; ARGUMENT1 := 1
.3a66a3	85 23		sta $0823	                STA ARGUMENT1
.3a66a5	a9 00 00	lda #$0000	                LDA #0
.3a66a8	85 25		sta $0825	                STA ARGUMENT1+2
.3a66aa	e2 20		sep #$20	            SEP #$20
.3a66ac	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.3a66b0	c2 20		rep #$20	            REP #$20
.3a66b2	29 ff 00	and #$00ff	                AND #$00FF
.3a66b5	85 8f		sta $088f	                STA MCOUNT                  ; Save it to MCOUNT for later
.3a66b7	a8		tay		                TAY                         ; Y := number of dimensions
.3a66b8	a2 01 00	ldx #$0001	                LDX #1                      ; X := index to size 0
.3a66bb					size_loop
.3a66bb	c2 20		rep #$20	            REP #$20
.3a66bd	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X           ; ARGUMENT2 := Ith dimension
.3a66c1	85 29		sta $0829	                STA ARGUMENT2
.3a66c3	a9 00 00	lda #$0000	                LDA #0
.3a66c6	85 2b		sta $082b	                STA ARGUMENT2+2
.3a66c8	e2 20		sep #$20	            SEP #$20
.3a66ca	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a66cc	85 2d		sta $082d	                STA ARGTYPE2
.3a66ce	c2 20		rep #$20	            REP #$20
.3a66d0	20 56 28	jsr $3a2856	            JSR OP_MULTIPLY
.3a66d3	e8		inx		                INX
.3a66d4	e8		inx		                INX
.3a66d5	88		dey		                DEY
.3a66d6	d0 e3		bne $3a66bb	                BNE size_loop               ; If there are more dimensions, take the next one
.3a66d8	c2 20		rep #$20	            REP #$20
.3a66da	a9 04 00	lda #$0004	                LDA #ARGUMENT_SIZE-1        ; Size of a data item (don't include the type code)
.3a66dd	85 29		sta $0829	                STA ARGUMENT2
.3a66df	a9 00 00	lda #$0000	                LDA #0
.3a66e2	85 2b		sta $082b	                STA ARGUMENT2+2
.3a66e4	20 56 28	jsr $3a2856	            JSR OP_MULTIPLY
.3a66e7	e2 20		sep #$20	            SEP #$20
.3a66e9	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF             ; SCRATCH := N * 2
.3a66ed	85 0c		sta $080c	                STA SCRATCH
.3a66ef	a9 00		lda #$00	                LDA #0
.3a66f1	85 0d		sta $080d	                STA SCRATCH+1
.3a66f3	c2 20		rep #$20	            REP #$20
.3a66f5	06 0c		asl $080c	                ASL SCRATCH
.3a66f7	38		sec		                SEC                         ; ARGUMENT1 := size of the complete block
.3a66f8	a5 23		lda $0823	                LDA ARGUMENT1
.3a66fa	65 0c		adc $080c	                ADC SCRATCH                 ; Size of data area + N*2 + 1 (in carry)
.3a66fc	85 23		sta $0823	                STA ARGUMENT1
.3a66fe	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6700	69 00 00	adc #$0000	                ADC #0
.3a6703	85 25		sta $0825	                STA ARGUMENT1+2
.3a6705	d0 29		bne $3a6730	                BNE too_big                 ; size > 16-bit? Yes: throw an error
.3a6707	e2 20		sep #$20	            SEP #$20
.3a6709	a5 ea		lda $08ea	                LDA TOFINDTYPE              ; Get the type
.3a670b	09 80		ora #$80	                ORA #$80                    ; Flip the flag to make it an array of that type
.3a670d	a6 23		ldx $0823	                LDX ARGUMENT1               ; Get the computed size
.3a670f	20 d3 10	jsr $3a10d3	            JSR ALLOC
.3a6712	e2 20		sep #$20	            SEP #$20
.3a6714	af 00 4d 00	lda $004d00	                LDA @lARRIDXBUF
.3a6718	87 c0		sta [$08c0]	                STA [CURRBLOCK]             ; Write the number of dimensions to the array's preamble
.3a671a	a0 01 00	ldy #$0001	                LDY #1
.3a671d	a2 00 00	ldx #$0000	                LDX #0
.3a6720					copy_loop
.3a6720	e2 20		sep #$20	            SEP #$20
.3a6722	bf 01 4d 00	lda $004d01,x	                LDA @lARRIDXBUF+1,X         ; ARGUMENT2 := Ith dimension
.3a6726	97 c0		sta [$08c0],y	                STA [CURRBLOCK],Y           ; And write the dimension to the array's preamble
.3a6728	e4 8f		cpx $088f	                CPX MCOUNT                  ; Have we written the last byte?
.3a672a	f0 23		beq $3a674f	                BEQ null_array              ; Yes: clear the array
.3a672c	e8		inx		                INX                         ; No: move to the next byte
.3a672d	c8		iny		                INY
.3a672e	80 f0		bra $3a6720	                BRA copy_loop
.3a6730					too_big
.3a6730	08		php		            PHP
.3a6731	c2 20		rep #$20	            REP #$20
.3a6733	48		pha		            PHA
.3a6734	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6737	5b		tcd		            TCD
.3a6738	68		pla		            PLA
.3a6739	28		plp		            PLP
.3a673a	e2 20		sep #$20	            SEP #$20
.3a673c	a9 09		lda #$09	            LDA #ERR_RANGE
.3a673e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6742	c2 20		rep #$20	            REP #$20
.3a6744	29 ff 00	and #$00ff	            AND #$00FF
.3a6747	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a674a	e2 20		sep #$20	            SEP #$20
.3a674c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a674f					null_array
.3a674f	e2 20		sep #$20	            SEP #$20
.3a6751	38		sec		                SEC                         ; INDEX := pointer to first value
.3a6752	a5 c0		lda $08c0	                LDA CURRBLOCK
.3a6754	67 c0		adc [$08c0]	                ADC [CURRBLOCK]
.3a6756	85 08		sta $0808	                STA INDEX
.3a6758	a5 c1		lda $08c1	                LDA CURRBLOCK+1
.3a675a	69 00		adc #$00	                ADC #0
.3a675c	85 09		sta $0809	                STA INDEX+1
.3a675e	a5 c2		lda $08c2	                LDA CURRBLOCK+2
.3a6760	69 00		adc #$00	                ADC #0
.3a6762	85 0a		sta $080a	                STA INDEX+2
.3a6764	64 0b		stz $080b	                STZ INDEX+3
.3a6766	c2 20		rep #$20	            REP #$20
.3a6768	a0 05 00	ldy #$0005	                LDY #HEAPOBJ.END            ; SCRATCH := pointer the the first byte after the array
.3a676b	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.3a676d	85 0c		sta $080c	                STA SCRATCH
.3a676f	e2 20		sep #$20	            SEP #$20
.3a6771	c8		iny		                INY
.3a6772	c8		iny		                INY
.3a6773	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.3a6775	85 0e		sta $080e	                STA SCRATCH+2
.3a6777	64 0f		stz $080f	                STZ SCRATCH+3
.3a6779					clr_loop
.3a6779	e2 20		sep #$20	            SEP #$20
.3a677b	a9 00		lda #$00	                LDA #0
.3a677d	87 08		sta [$0808]	                STA [INDEX]                 ; Clear the byte
.3a677f	c2 20		rep #$20	            REP #$20
.3a6781	18		clc		                CLC                         ; Increment INDEX
.3a6782	a5 08		lda $0808	                LDA INDEX
.3a6784	69 01 00	adc #$0001	                ADC #1
.3a6787	85 08		sta $0808	                STA INDEX
.3a6789	a5 0a		lda $080a	                LDA INDEX+2
.3a678b	69 00 00	adc #$0000	                ADC #0
.3a678e	85 0a		sta $080a	                STA INDEX+2
.3a6790	c5 0e		cmp $080e	                CMP SCRATCH+2               ; INDEX == SCRATCH?
.3a6792	d0 e5		bne $3a6779	                BNE clr_loop                ; No: write to this next byte
.3a6794	a5 08		lda $0808	                LDA INDEX
.3a6796	c5 0c		cmp $080c	                CMP SCRATCH
.3a6798	d0 df		bne $3a6779	                BNE clr_loop
.3a679a					done
.3a679a	28		plp		                PLP
.3a679b	60		rts		            RTS
.3a679c					ARR_CELL
.3a679c	08		php		                PHP
.3a679d	c2 20		rep #$20	            REP #$20
.3a679f	64 08		stz $0808	                STZ INDEX               ; INDEX := 0
.3a67a1	64 0a		stz $080a	                STZ INDEX+2
.3a67a3	e2 20		sep #$20	            SEP #$20
.3a67a5	af 00 4d 00	lda $004d00	                LDA @l ARRIDXBUF        ; MCOUNT := N (number of dimensions)
.3a67a9	85 8f		sta $088f	                STA MCOUNT
.3a67ab	64 90		stz $0890	                STZ MCOUNT+1
.3a67ad	a2 01 00	ldx #$0001	                LDX #1                  ; X := index to dimension 0
.3a67b0	e2 20		sep #$20	            SEP #$20
.3a67b2	a7 c0		lda [$08c0]	                LDA [CURRBLOCK]         ; Make sure the dimensions of the array
.3a67b4	c5 8f		cmp $088f	                CMP MCOUNT              ; ... match those requested
.3a67b6	f0 22		beq $3a67da	                BEQ dims_match          ; Yes: the dimensions match
.3a67b8	a6 8f		ldx $088f	                LDX MCOUNT
.3a67ba	00		brk #		                BRK
.3a67bb					arg_err
.3a67bb	08		php		            PHP
.3a67bc	c2 20		rep #$20	            REP #$20
.3a67be	48		pha		            PHA
.3a67bf	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a67c2	5b		tcd		            TCD
.3a67c3	68		pla		            PLA
.3a67c4	28		plp		            PLP
.3a67c5	e2 20		sep #$20	            SEP #$20
.3a67c7	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a67c9	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a67cd	c2 20		rep #$20	            REP #$20
.3a67cf	29 ff 00	and #$00ff	            AND #$00FF
.3a67d2	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a67d5	e2 20		sep #$20	            SEP #$20
.3a67d7	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a67da	c9 01		cmp #$01	dims_match      CMP #1                  ; Check to see if this array is one dimensional
.3a67dc	f0 3a		beq $3a6818	                BEQ add_last            ; If so, just add the index of the cell to INDEX
.3a67de	a0 01 00	ldy #$0001	                LDY #1
.3a67e1					index_loop
.3a67e1	e2 20		sep #$20	            SEP #$20
.3a67e3	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; ARGUMENT1 := I_j
.3a67e7	85 23		sta $0823	                STA ARGUMENT1
.3a67e9	64 24		stz $0824	                STZ ARGUMENT1+1
.3a67eb	64 25		stz $0825	                STZ ARGUMENT1+2
.3a67ed	64 26		stz $0826	                STZ ARGUMENT1+3
.3a67ef	b7 c0		lda [$08c0],y	                LDA [CURRBLOCK],Y       ; ARGUMENT2 := D_j
.3a67f1	85 29		sta $0829	                STA ARGUMENT2
.3a67f3	64 2a		stz $082a	                STZ ARGUMENT2+1
.3a67f5	64 2b		stz $082b	                STZ ARGUMENT2+2
.3a67f7	64 2c		stz $082c	                STZ ARGUMENT2+3
.3a67f9	a5 23		lda $0823	                LDA ARGUMENT1
.3a67fb	c5 29		cmp $0829	                CMP ARGUMENT2           ; Is I_j >= D_j
.3a67fd	b0 68		bcs $3a6867	                BGE range_err           ; Yes: throw an out-of-range error
.3a67ff	20 56 28	jsr $3a2856	            JSR OP_MULTIPLY
.3a6802	c2 20		rep #$20	            REP #$20
.3a6804	18		clc		                CLC                     ; INDEX := INDEX + ARGUMENT1
.3a6805	a5 08		lda $0808	                LDA INDEX
.3a6807	65 23		adc $0823	                ADC ARGUMENT1
.3a6809	85 08		sta $0808	                STA INDEX
.3a680b	a5 0a		lda $080a	                LDA INDEX+2
.3a680d	65 25		adc $0825	                ADC ARGUMENT1+2
.3a680f	85 0a		sta $080a	                STA INDEX+2
.3a6811	e8		inx		                INX
.3a6812	e8		inx		                INX
.3a6813	c8		iny		                INY
.3a6814	c4 8f		cpy $088f	                CPY MCOUNT              ; Are we on the last index?
.3a6816	d0 c9		bne $3a67e1	                BNE index_loop          ; No: move to the next index and try again
.3a6818					add_last
.3a6818	e2 20		sep #$20	            SEP #$20
.3a681a	18		clc		                CLC
.3a681b	bf 00 4d 00	lda $004d00,x	                LDA @lARRIDXBUF,X       ; INDEX := INDEX + I_(n-1)
.3a681f	85 90		sta $0890	                STA MCOUNT+1
.3a6821	65 08		adc $0808	                ADC INDEX
.3a6823	85 08		sta $0808	                STA INDEX
.3a6825	a5 09		lda $0809	                LDA INDEX+1
.3a6827	69 00		adc #$00	                ADC #0
.3a6829	85 09		sta $0809	                STA INDEX+1
.3a682b	c2 20		rep #$20	            REP #$20
.3a682d	a5 0a		lda $080a	                LDA INDEX+2
.3a682f	69 00 00	adc #$0000	                ADC #0
.3a6832	85 0a		sta $080a	                STA INDEX+2
.3a6834	c2 20		rep #$20	            REP #$20
.3a6836	06 08		asl $0808	                ASL INDEX               ; INDEX := INDEX * 4 (size of a value)
.3a6838	26 0a		rol $080a	                ROL INDEX+2
.3a683a	06 08		asl $0808	                ASL INDEX
.3a683c	26 0a		rol $080a	                ROL INDEX+2
.3a683e	e2 20		sep #$20	            SEP #$20
.3a6840	38		sec		                SEC
.3a6841	a5 08		lda $0808	                LDA INDEX
.3a6843	65 8f		adc $088f	                ADC MCOUNT
.3a6845	85 08		sta $0808	                STA INDEX
.3a6847	a5 09		lda $0809	                LDA INDEX+1
.3a6849	69 00		adc #$00	                ADC #0
.3a684b	85 09		sta $0809	                STA INDEX+1
.3a684d	c2 20		rep #$20	            REP #$20
.3a684f	a5 0a		lda $080a	                LDA INDEX+2
.3a6851	69 00 00	adc #$0000	                ADC #0
.3a6854	85 0a		sta $080a	                STA INDEX+2
.3a6856	18		clc		                CLC                     ; INDEX := INDEX + CURRBLOCK (point to the address desired)
.3a6857	a5 08		lda $0808	                LDA INDEX
.3a6859	65 c0		adc $08c0	                ADC CURRBLOCK
.3a685b	85 08		sta $0808	                STA INDEX
.3a685d	e2 20		sep #$20	            SEP #$20
.3a685f	a5 0a		lda $080a	                LDA INDEX+2
.3a6861	65 c2		adc $08c2	                ADC CURRBLOCK+2
.3a6863	85 0a		sta $080a	                STA INDEX+2
.3a6865	28		plp		                PLP
.3a6866	60		rts		            RTS
.3a6867					range_err
.3a6867	08		php		            PHP
.3a6868	c2 20		rep #$20	            REP #$20
.3a686a	48		pha		            PHA
.3a686b	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a686e	5b		tcd		            TCD
.3a686f	68		pla		            PLA
.3a6870	28		plp		            PLP
.3a6871	e2 20		sep #$20	            SEP #$20
.3a6873	a9 09		lda #$09	            LDA #ERR_RANGE
.3a6875	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6879	c2 20		rep #$20	            REP #$20
.3a687b	29 ff 00	and #$00ff	            AND #$00FF
.3a687e	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a6881	e2 20		sep #$20	            SEP #$20
.3a6883	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6886					ARR_SET
.3a6886	08		php		                PHP
.3a6887	20 0f 13	jsr $3a130f	            JSR HEAP_GETHED
.3a688a	e2 20		sep #$20	            SEP #$20
.3a688c	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.3a688f	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.3a6891	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.3a6893	c9 02		cmp #$02	                CMP #TYPE_STRING    ; Is it a string array?
.3a6895	d0 05		bne $3a689c	                BNE chk_integer
.3a6897	20 e3 06	jsr $3a06e3	            JSR ASS_ARG1_STR
.3a689a	80 10		bra $3a68ac	                BRA save_type
.3a689c	c9 00		cmp #$00	chk_integer     CMP #TYPE_INTEGER   ; Is it an integer array?
.3a689e	d0 05		bne $3a68a5	                BNE chk_float
.3a68a0	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a68a3	80 07		bra $3a68ac	                BRA save_type
.3a68a5	c9 01		cmp #$01	chk_float       CMP #TYPE_FLOAT     ; Is it an float array?
.3a68a7	d0 2b		bne $3a68d4	                BNE type_mismatch   ; No: throw a type mismatch error... something strange...
.3a68a9	20 bf 07	jsr $3a07bf	            JSR ASS_ARG1_FLOAT
.3a68ac	a5 27		lda $0827	save_type       LDA ARGTYPE1        ; Save the type
.3a68ae	48		pha		                PHA
.3a68af	c2 20		rep #$20	            REP #$20
.3a68b1	a5 25		lda $0825	                LDA ARGUMENT1+2     ; Save ARGUMENT1
.3a68b3	48		pha		                PHA
.3a68b4	a5 23		lda $0823	                LDA ARGUMENT1
.3a68b6	48		pha		                PHA
.3a68b7	20 9c 67	jsr $3a679c	            JSR ARR_CELL
.3a68ba	68		pla		                PLA                 ; Restore ARGUMENT1
.3a68bb	85 23		sta $0823	                STA ARGUMENT1
.3a68bd	68		pla		                PLA
.3a68be	85 25		sta $0825	                STA ARGUMENT1+2
.3a68c0	e2 20		sep #$20	            SEP #$20
.3a68c2	68		pla		                PLA
.3a68c3	85 27		sta $0827	                STA ARGTYPE1
.3a68c5	c2 20		rep #$20	            REP #$20
.3a68c7	a5 23		lda $0823	                LDA ARGUMENT1       ; Set the value in the cell
.3a68c9	87 08		sta [$0808]	                STA [INDEX]
.3a68cb	a0 02 00	ldy #$0002	                LDY #2
.3a68ce	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a68d0	97 08		sta [$0808],y	                STA [INDEX],Y
.3a68d2	28		plp		                PLP
.3a68d3	60		rts		            RTS
.3a68d4					type_mismatch
.3a68d4	08		php		            PHP
.3a68d5	c2 20		rep #$20	            REP #$20
.3a68d7	48		pha		            PHA
.3a68d8	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a68db	5b		tcd		            TCD
.3a68dc	68		pla		            PLA
.3a68dd	28		plp		            PLP
.3a68de	e2 20		sep #$20	            SEP #$20
.3a68e0	a9 04		lda #$04	            LDA #ERR_TYPE
.3a68e2	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a68e6	c2 20		rep #$20	            REP #$20
.3a68e8	29 ff 00	and #$00ff	            AND #$00FF
.3a68eb	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a68ee	e2 20		sep #$20	            SEP #$20
.3a68f0	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a68f3					ARR_REF
.3a68f3	08		php		                PHP
.3a68f4	20 0f 13	jsr $3a130f	            JSR HEAP_GETHED
.3a68f7	f4 00 00	pea #$0000	                PEA #0              ; Make room on the stack that ARR_CELL expects
.3a68fa	f4 00 00	pea #$0000	                PEA #0
.3a68fd	e2 20		sep #$20	            SEP #$20
.3a68ff	48		pha		                PHA
.3a6900	20 9c 67	jsr $3a679c	            JSR ARR_CELL
.3a6903	e2 20		sep #$20	            SEP #$20
.3a6905	68		pla		                PLA
.3a6906	c2 20		rep #$20	            REP #$20
.3a6908	68		pla		                PLA
.3a6909	68		pla		                PLA
.3a690a	c2 20		rep #$20	            REP #$20
.3a690c	a7 08		lda [$0808]	                LDA [INDEX]         ; Get the value in the cell
.3a690e	85 23		sta $0823	                STA ARGUMENT1
.3a6910	a0 02 00	ldy #$0002	                LDY #2
.3a6913	b7 08		lda [$0808],y	                LDA [INDEX],Y
.3a6915	85 25		sta $0825	                STA ARGUMENT1+2
.3a6917	e2 20		sep #$20	            SEP #$20
.3a6919	a0 00 00	ldy #$0000	                LDY #HEAPOBJ.TYPE   ; Get the type of the array
.3a691c	b7 c3		lda [$08c3],y	                LDA [CURRHEADER],Y
.3a691e	29 7f		and #$7f	                AND #$7F            ; Mask off the ARRAY OF bit
.3a6920	85 27		sta $0827	                STA ARGTYPE1        ; Set the type of the return value
.3a6922	20 63 18	jsr $3a1863	            JSR STR_NORMAL
.3a6925	28		plp		                PLP
.3a6926	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\dos.s

.0000					DIRENTRY
>0000					SHORTNAME               .fill 11        ; $00 - The short name of the file (8 name, 3 extension)
>000b					ATTRIBUTE               .byte ?         ; $0B - The attribute bits
>000c					IGNORED1                .word ?         ; $0C - Unused (by us) bytes
>000e					CREATE_TIME             .word ?         ; $0E - Creation time
>0010					CREATE_DATE             .word ?         ; $10 - Creation date
>0012					ACCESS_DATE             .word ?         ; $12 - Last access date
>0014					CLUSTER_H               .word ?         ; $14 - High word of the first cluster #
>0016					MODIFIED_TIME           .word ?         ; $16 - Last modified time
>0018					MODIFIED_DATE           .word ?         ; $18 - Last modified date
>001a					CLUSTER_L               .word ?         ; $1A - Low word of the first cluster #
>001c					SIZE                    .dword ?        ; $1C - The size of the file (in bytes)
=$01					DOS_ATTR_RO = $01                       ; File is read-only
=$02					DOS_ATTR_HIDDEN = $02                   ; File is hidden
=$04					DOS_ATTR_SYSTEM = $04                   ; File is a system file
=$08					DOS_ATTR_VOLUME = $08                   ; Entry is the volume label
=$10					DOS_ATTR_DIR = $10                      ; Entry is a directory
=$20					DOS_ATTR_ARCH = $20                     ; Entry has changed since last backup
=$0f					DOS_ATTR_LONGNAME = $0F                 ; Entry is the long file name
=$e5					DOS_DIR_ENT_UNUSED = $E5                ; Marker for an unused directory entry
.0000					FILEDESC
>0000					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>0001					DEV                 .byte ?             ; The ID of the device holding the file
>0002					PATH                .dword ?            ; Pointer to a NULL terminated path string
>0006					CLUSTER             .dword ?            ; The current cluster of the file.
>000a					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>000e					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>0012					FILESIZE            .dword ?            ; The size of the file
>0016					CREATE_DATE         .word ?             ; The creation date of the file
>0018					CREATE_TIME         .word ?             ; The creation time of the file
>001a					MODIFIED_DATE       .word ?             ; The modification date of the file
>001c					MODIFIED_TIME       .word ?             ; The modification time of the file
=$01					FD_STAT_READ = $01                      ; The file is readable
=$02					FD_STAT_WRITE = $02                     ; The file is writable
=$40					FD_STAT_OPEN = $40                      ; The file is open
=$60					FD_STAT_ERROR = $60                     ; The file is in an error condition
=$80					FD_STAT_EOF = $80                       ; The file cursor is at the end of the file
>3af073					CLUSTER_BUFF    .fill 512           ; A buffer for cluster read/write operations
.3af273					FD_IN
>3af273					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>3af274					DEV                 .byte ?             ; The ID of the device holding the file
>3af275					PATH                .dword ?            ; Pointer to a NULL terminated path string
>3af279					CLUSTER             .dword ?            ; The current cluster of the file.
>3af27d					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>3af281					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>3af285					FILESIZE            .dword ?            ; The size of the file
>3af289					CREATE_DATE         .word ?             ; The creation date of the file
>3af28b					CREATE_TIME         .word ?             ; The creation time of the file
>3af28d					MODIFIED_DATE       .word ?             ; The modification date of the file
>3af28f					MODIFIED_TIME       .word ?             ; The modification time of the file
.3a6927					PR_FILESIZE
.3a6927	da		phx		                PHX
.3a6928	0b		phd		                PHD
.3a6929	08		php		                PHP
.3a692a	08		php		            PHP
.3a692b	c2 20		rep #$20	            REP #$20
.3a692d	48		pha		            PHA
.3a692e	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a6931	5b		tcd		            TCD
.3a6932	68		pla		            PLA
.3a6933	28		plp		            PLP
.3a6934	c2 30		rep #$30	            REP #$30
.3a6936	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6938	89 f0 ff	bit #$fff0	                BIT #$FFF0              ; Check to see if the amount is in MB range
.3a693b	d0 29		bne $3a6966	                BNE pr_mb               ; If so, print it in MBs
.3a693d	89 0f 00	bit #$000f	                BIT #$000F              ; Check to see if the amount is in KB range
.3a6940	d0 0c		bne $3a694e	                BNE pr_kb
.3a6942	a5 23		lda $0823	                LDA ARGUMENT1
.3a6944	89 00 fc	bit #$fc00	                BIT #$FC00
.3a6947	d0 05		bne $3a694e	                BNE pr_kb               ; If so, print it in KBs
.3a6949					pr_regular
.3a6949	20 1a 46	jsr $3a461a	            JSR PR_INTEGER
.3a694c	80 2e		bra $3a697c	                BRA done
.3a694e	a2 0a 00	ldx #$000a	pr_kb           LDX #10                 ; Shift so the amount in KB is in ARGUMENT1
.3a6951	46 25		lsr $0825	kb_shift        LSR ARGUMENT1+2
.3a6953	66 23		ror $0823	                ROR ARGUMENT1
.3a6955	ca		dex		                DEX
.3a6956	d0 f9		bne $3a6951	                BNE kb_shift
.3a6958	20 1a 46	jsr $3a461a	            JSR PR_INTEGER
.3a695b	e2 20		sep #$20	            SEP #$20
.3a695d	a9 4b		lda #$4b	                LDA #'K'
.3a695f	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6962	c2 20		rep #$20	            REP #$20
.3a6964	80 16		bra $3a697c	                BRA done
.3a6966	a2 14 00	ldx #$0014	pr_mb           LDX #20                 ; Shift so the amount in MB is in ARGUMENT1
.3a6969	46 25		lsr $0825	mb_shift        LSR ARGUMENT1+2
.3a696b	66 23		ror $0823	                ROR ARGUMENT1
.3a696d	ca		dex		                DEX
.3a696e	d0 f9		bne $3a6969	                BNE mb_shift
.3a6970	20 1a 46	jsr $3a461a	            JSR PR_INTEGER
.3a6973	e2 20		sep #$20	            SEP #$20
.3a6975	a9 4d		lda #$4d	                LDA #'M'
.3a6977	20 18 00	jsr $3a0018	            JSR PRINTC
.3a697a	c2 20		rep #$20	            REP #$20
.3a697c	28		plp		done            PLP
.3a697d	2b		pld		                PLD
.3a697e	fa		plx		                PLX
.3a697f	60		rts		            RTS
.3a6980					CMD_DIR
.3a6980	0b		phd		                PHD
.3a6981	08		php		                PHP
.3a6982	c2 30		rep #$30	            REP #$30
.3a6984	a9 00 00	lda #$0000	                LDA #0                      ; Zero out the pagination line count
.3a6987	8f b6 08 00	sta $0008b6	                STA @l LINECOUNT
.3a698b	8f b8 08 00	sta $0008b8	                STA @l LINECOUNT+2
.3a698f	e2 20		sep #$20	            SEP #$20
.3a6991	20 7b 22	jsr $3a227b	            JSR PEEK_TOK
.3a6994	c9 00		cmp #$00	                CMP #0
.3a6996	f0 08		beq $3a69a0	                BEQ set_null                ; If none provided, set the path to empty
.3a6998	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a699b	20 e3 06	jsr $3a06e3	            JSR ASS_ARG1_STR
.3a699e	80 11		bra $3a69b1	                BRA set_fd
.3a69a0					set_null
.3a69a0	c2 20		rep #$20	            REP #$20
.3a69a2	a9 00 00	lda #$0000	                LDA #0                      ; Set ARGUMENT1 to the NULL string
.3a69a5	85 23		sta $0823	                STA ARGUMENT1
.3a69a7	85 25		sta $0825	                STA ARGUMENT1+2
.3a69a9	e2 20		sep #$20	            SEP #$20
.3a69ab	a9 02		lda #$02	                LDA #TYPE_STRING
.3a69ad	85 27		sta $0827	                STA ARGTYPE1
.3a69af	c2 20		rep #$20	            REP #$20
.3a69b1					set_fd
.3a69b1	20 e1 6a	jsr $3a6ae1	            JSR SETFILEDESC
.3a69b4	22 08 11 00	jsl $001108	                JSL FK_DIROPEN              ; Open up the directory
.3a69b8	b0 22		bcs $3a69dc	                BCS pr_first
.3a69ba	20 92 6b	jsr $3a6b92	            JSR SET_DOSSTAT
.3a69bd	08		php		            PHP
.3a69be	c2 20		rep #$20	            REP #$20
.3a69c0	48		pha		            PHA
.3a69c1	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a69c4	5b		tcd		            TCD
.3a69c5	68		pla		            PLA
.3a69c6	28		plp		            PLP
.3a69c7	e2 20		sep #$20	            SEP #$20
.3a69c9	a9 10		lda #$10	            LDA #ERR_DIRECTORY
.3a69cb	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a69cf	c2 20		rep #$20	            REP #$20
.3a69d1	29 ff 00	and #$00ff	            AND #$00FF
.3a69d4	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a69d7	e2 20		sep #$20	            SEP #$20
.3a69d9	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a69dc					pr_first
.3a69dc	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a69df					pr_entry
.3a69df	08		php		            PHP
.3a69e0	c2 20		rep #$20	            REP #$20
.3a69e2	48		pha		            PHA
.3a69e3	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.3a69e6	5b		tcd		            TCD
.3a69e7	68		pla		            PLA
.3a69e8	28		plp		            PLP
.3a69e9	e2 20		sep #$20	            SEP #$20
.3a69eb	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Start with the file name
.3a69ee	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the initial character of the name
.3a69f0	d0 03		bne $3a69f5	                BNE chk_unused
.3a69f2	82 a9 00	brl $3a6a9e	                BRL done                    ; If it's NULL, we're done
.3a69f5	c9 e5		cmp #$e5	chk_unused      CMP #DOS_DIR_ENT_UNUSED     ; Is it the unusued code?
.3a69f7	d0 03		bne $3a69fc	                BNE chk_attributes
.3a69f9	82 96 00	brl $3a6a92	                BRL next_entry              ; Yes: go to the next entry
.3a69fc	a0 0b 00	ldy #$000b	chk_attributes  LDY #DIRENTRY.ATTRIBUTE
.3a69ff	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute byte
.3a6a01	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.3a6a03	f0 03		beq $3a6a08	                BEQ chk_hidden
.3a6a05	82 a9 00	brl $3a6ab1	                BRL pr_volume               ; Print the volume label
.3a6a08	89 02		bit #$02	chk_hidden      BIT #DOS_ATTR_HIDDEN        ; Is it a hidden file?
.3a6a0a	f0 03		beq $3a6a0f	                BEQ chk_long
.3a6a0c	82 83 00	brl $3a6a92	                BRL next_entry              ; Yes: go to the next entry
.3a6a0f	29 0f		and #$0f	chk_long        AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.3a6a11	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.3a6a13	d0 03		bne $3a6a18	                BNE get_short_name
.3a6a15	82 7a 00	brl $3a6a92	                BRL next_entry              ; Yes: go to the next entry
.3a6a18	a0 00 00	ldy #$0000	get_short_name  LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.3a6a1b	b7 18		lda [$0338],y	pr_name_loop    LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.3a6a1d	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6a20	c8		iny		                INY                         ; Move to the next character
.3a6a21	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.3a6a24	d0 f5		bne $3a6a1b	                BNE pr_name_loop            ; No: print this new character
.3a6a26	a9 20		lda #$20	                LDA #' '                    ; Print the separator
.3a6a28	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6a2b	a0 08 00	ldy #$0008	                LDY #DIRENTRY.SHORTNAME+8   ; Move to the first of the extension characters
.3a6a2e	b7 18		lda [$0338],y	pr_ext_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.3a6a30	20 18 00	jsr $3a0018	                JSR PRINTC                  ; Otherwise: print it.
.3a6a33	c8		iny		                INY                         ; Move to the next character
.3a6a34	c0 0b 00	cpy #$000b	                CPY #DIRENTRY.SHORTNAME+11  ; Are we at the end of the extension portion?
.3a6a37	d0 f5		bne $3a6a2e	                BNE pr_ext_loop             ; No: print this new character
.3a6a39	a9 09		lda #$09	pr_tab1         LDA #CHAR_TAB               ; Print a TAB
.3a6a3b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6a3e	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.3a6a41	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.3a6a43	89 10		bit #$10	                BIT #DOS_ATTR_DIR           ; Is it a directory?
.3a6a45	d0 1e		bne $3a6a65	                BNE pr_attr                 ; Yes: skip printing a file size
.3a6a47	c2 20		rep #$20	            REP #$20
.3a6a49	a0 1c 00	ldy #$001c	                LDY #DIRENTRY.SIZE
.3a6a4c	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the file size
.3a6a4e	8f 23 08 00	sta $000823	                STA @l ARGUMENT1
.3a6a52	c8		iny		                INY
.3a6a53	c8		iny		                INY
.3a6a54	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y
.3a6a56	8f 25 08 00	sta $000825	                STA @l ARGUMENT1+2
.3a6a5a	e2 20		sep #$20	            SEP #$20
.3a6a5c	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a6a5e	8f 27 08 00	sta $000827	                STA @l ARGTYPE1
.3a6a62	20 27 69	jsr $3a6927	            JSR PR_FILESIZE
.3a6a65	a9 09		lda #$09	pr_attr         LDA #CHAR_TAB               ; Print a TAB
.3a6a67	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6a6a	a0 0b 00	ldy #$000b	                LDY #DIRENTRY.ATTRIBUTE
.3a6a6d	b7 18		lda [$0338],y	                LDA [DOS_DIR_PTR],Y         ; Get the attribute
.3a6a6f	89 08		bit #$08	                BIT #DOS_ATTR_VOLUME        ; Is it a volume?
.3a6a71	d0 1c		bne $3a6a8f	                BNE end_entry               ; Yes: we're done printing this entry
.3a6a73	89 01		bit #$01	chk_read        BIT #DOS_ATTR_RO            ; Is it a read-only file?
.3a6a75	f0 05		beq $3a6a7c	                BEQ chk_system
.3a6a77	a9 52		lda #$52	                LDA #'R'                    ; Yes: print an R
.3a6a79	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6a7c	89 04		bit #$04	chk_system      BIT #DOS_ATTR_SYSTEM        ; Is it System file?
.3a6a7e	f0 05		beq $3a6a85	                BEQ chk_directory
.3a6a80	a9 53		lda #$53	                LDA #'S'                    ; Yes: print an S
.3a6a82	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6a85	89 10		bit #$10	chk_directory   BIT #DOS_ATTR_DIR           ; Is it a directory?
.3a6a87	f0 05		beq $3a6a8e	                BEQ pr_tab2
.3a6a89	a9 44		lda #$44	                LDA #'D'                    ; Yes: print a D
.3a6a8b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6a8e	ea		nop		pr_tab2         NOP
.3a6a8f					end_entry
.3a6a8f	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a6a92					next_entry
.3a6a92	20 ee 03	jsr $3a03ee	            JSR PAGINATE
.3a6a95	22 0c 11 00	jsl $00110c	                JSL FK_DIRNEXT
.3a6a99	90 03		bcc $3a6a9e	                BCC done
.3a6a9b	82 41 ff	brl $3a69df	                BRL pr_entry
.3a6a9e					done
.3a6a9e	20 92 6b	jsr $3a6b92	            JSR SET_DOSSTAT
.3a6aa1	08		php		            PHP
.3a6aa2	c2 20		rep #$20	            REP #$20
.3a6aa4	48		pha		            PHA
.3a6aa5	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a6aa8	5b		tcd		            TCD
.3a6aa9	68		pla		            PLA
.3a6aaa	28		plp		            PLP
.3a6aab	20 5f 21	jsr $3a215f	            JSR SKIPSTMT
.3a6aae	28		plp		                PLP
.3a6aaf	2b		pld		                PLD
.3a6ab0	60		rts		            RTS
.3a6ab1					pr_volume
.3a6ab1	08		php		            PHP
.3a6ab2	c2 20		rep #$20	            REP #$20
.3a6ab4	48		pha		            PHA
.3a6ab5	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.3a6ab8	5b		tcd		            TCD
.3a6ab9	68		pla		            PLA
.3a6aba	28		plp		            PLP
.3a6abb	e2 20		sep #$20	            SEP #$20
.3a6abd	29 0f		and #$0f	                AND #DOS_ATTR_LONGNAME      ; Is it a long file name entry?
.3a6abf	c9 0f		cmp #$0f	                CMP #DOS_ATTR_LONGNAME
.3a6ac1	f0 cf		beq $3a6a92	                BEQ next_entry              ; Yes: skip it
.3a6ac3	a9 5b		lda #$5b	pr_lbracket     LDA #'['
.3a6ac5	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6ac8	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME     ; Starting with the first character of the file...
.3a6acb	b7 18		lda [$0338],y	pr_vol_loop     LDA [DOS_DIR_PTR],Y         ; Get a character of the name
.3a6acd	c9 20		cmp #$20	                CMP #CHAR_SP                ; Is it a blank?
.3a6acf	f0 09		beq $3a6ada	                BEQ pr_rbracket             ; Yes: end the name and print the dot
.3a6ad1	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6ad4	c8		iny		                INY                         ; Move to the next character
.3a6ad5	c0 08 00	cpy #$0008	                CPY #DIRENTRY.SHORTNAME+8   ; Are we at the end of the name portion?
.3a6ad8	d0 f1		bne $3a6acb	                BNE pr_vol_loop             ; No: print this new character
.3a6ada	a9 5d		lda #$5d	pr_rbracket     LDA #']'                    ; Print a close bracket
.3a6adc	20 18 00	jsr $3a0018	            JSR PRINTC
.3a6adf	80 ae		bra $3a6a8f	                BRA end_entry               ; And try to get the next entry
.3a6ae1					SETFILEDESC
.3a6ae1	0b		phd		                PHD
.3a6ae2	08		php		                PHP
.3a6ae3	08		php		            PHP
.3a6ae4	c2 20		rep #$20	            REP #$20
.3a6ae6	48		pha		            PHA
.3a6ae7	a9 20 03	lda #$0320	            LDA #SDOS_VARIABLES
.3a6aea	5b		tcd		            TCD
.3a6aeb	68		pla		            PLA
.3a6aec	28		plp		            PLP
.3a6aed	c2 30		rep #$30	            REP #$30
.3a6aef	a9 73 f2	lda #$f273	                LDA #<>FD_IN            ; Point to the file descriptor
.3a6af2	85 20		sta $0340	                STA DOS_FD_PTR
.3a6af4	a9 3a 00	lda #$003a	                LDA #`FD_IN
.3a6af7	85 22		sta $0342	                STA DOS_FD_PTR+2
.3a6af9	a0 00 00	ldy #$0000	                LDY #0                  ; Fille the file descriptor with 0
.3a6afc	e2 20		sep #$20	            SEP #$20
.3a6afe	a9 00		lda #$00	                LDA #0
.3a6b00	97 20		sta [$0340],y	zero_loop       STA [DOS_FD_PTR],Y
.3a6b02	c8		iny		                INY
.3a6b03	c0 1e 00	cpy #$001e	                CPY #SIZE(FILEDESC)
.3a6b06	d0 f8		bne $3a6b00	                BNE zero_loop
.3a6b08	c2 20		rep #$20	            REP #$20
.3a6b0a	a9 73 f0	lda #$f073	                LDA #<>CLUSTER_BUFF     ; Point to the cluster buffer
.3a6b0d	8f 81 f2 3a	sta $3af281	                STA @l FD_IN.BUFFER
.3a6b11	a9 3a 00	lda #$003a	                LDA #`CLUSTER_BUFF
.3a6b14	8f 83 f2 3a	sta $3af283	                STA @l FD_IN.BUFFER+2
.3a6b18	af 23 08 00	lda $000823	                LDA @l ARGUMENT1        ; Point the file desriptor to the path
.3a6b1c	8f 75 f2 3a	sta $3af275	                STA @l FD_IN.PATH
.3a6b20	af 25 08 00	lda $000825	                LDA @l ARGUMENT1+2
.3a6b24	8f 77 f2 3a	sta $3af277	                STA @l FD_IN.PATH+2
.3a6b28	28		plp		                PLP
.3a6b29	2b		pld		                PLD
.3a6b2a	60		rts		            RTS
.3a6b2b					S_BLOAD
.3a6b2b	08		php		                PHP
.3a6b2c	c2 30		rep #$30	            REP #$30
.3a6b2e	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a6b31	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a6b34	20 e3 06	jsr $3a06e3	            JSR ASS_ARG1_STR
.3a6b37	20 e1 6a	jsr $3a6ae1	            JSR SETFILEDESC
.3a6b3a	e2 20		sep #$20	            SEP #$20
.3a6b3c	a9 2c		lda #$2c	                LDA #','
.3a6b3e	85 37		sta $0837	                STA TARGETTOK
.3a6b40	20 5c 22	jsr $3a225c	            JSR OPT_TOK
.3a6b43	b0 0f		bcs $3a6b54	                BCS get_dest
.3a6b45	c2 20		rep #$20	            REP #$20
.3a6b47	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set destination address to something "safe"
.3a6b4a	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a6b4e	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a6b52	80 17		bra $3a6b6b	                BRA do_load
.3a6b54					get_dest
.3a6b54	20 1a 21	jsr $3a211a	            JSR INCBIP
.3a6b57	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a6b5a	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a6b5d	c2 20		rep #$20	            REP #$20
.3a6b5f	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the destination address
.3a6b61	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a6b65	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6b67	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a6b6b	22 18 11 00	jsl $001118	do_load         JSL FK_LOAD                 ; Attempt to load the file
.3a6b6f	b0 1f		bcs $3a6b90	                BCS done
.3a6b71	08		php		            PHP
.3a6b72	c2 20		rep #$20	            REP #$20
.3a6b74	48		pha		            PHA
.3a6b75	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6b78	5b		tcd		            TCD
.3a6b79	68		pla		            PLA
.3a6b7a	28		plp		            PLP
.3a6b7b	e2 20		sep #$20	            SEP #$20
.3a6b7d	a9 11		lda #$11	            LDA #ERR_LOAD
.3a6b7f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6b83	c2 20		rep #$20	            REP #$20
.3a6b85	29 ff 00	and #$00ff	            AND #$00FF
.3a6b88	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a6b8b	e2 20		sep #$20	            SEP #$20
.3a6b8d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6b90	28		plp		done            PLP
.3a6b91	60		rts		            RTS
.3a6b92					SET_DOSSTAT
.3a6b92	8b		phb		                PHB
.3a6b93	0b		phd		                PHD
.3a6b94	08		php		                PHP
.3a6b95	08		php		            PHP
.3a6b96	c2 20		rep #$20	            REP #$20
.3a6b98	48		pha		            PHA
.3a6b99	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a6b9c	5b		tcd		            TCD
.3a6b9d	68		pla		            PLA
.3a6b9e	28		plp		            PLP
.3a6b9f	08		php		            PHP
.3a6ba0	e2 20		sep #$20	            SEP #$20
.3a6ba2	48		pha		            PHA
.3a6ba3	a9 00		lda #$00	            LDA #BASIC_BANK
.3a6ba5	48		pha		            PHA
.3a6ba6	ab		plb		            PLB
.3a6ba7	68		pla		            PLA
.3a6ba8	28		plp		            PLP
.3a6ba9	e2 20		sep #$20	            SEP #$20
.3a6bab	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS           ; Get the DOS status code
.3a6baf	85 23		sta $0823	                STA ARGUMENT1
.3a6bb1	a9 00		lda #$00	                LDA #0
.3a6bb3	85 24		sta $0824	                STA ARGUMENT1+1
.3a6bb5	85 25		sta $0825	                STA ARGUMENT1+2
.3a6bb7	85 26		sta $0826	                STA ARGUMENT1+3
.3a6bb9	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a6bbb	85 27		sta $0827	                STA ARGTYPE1
.3a6bbd	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (DOSSTAT)
.3a6bbf	a9 3a		lda #$3a	                LDA #`dosstat_name
.3a6bc1	85 e9		sta $08e9	                STA TOFIND+2
.3a6bc3	c2 20		rep #$20	            REP #$20
.3a6bc5	a9 f5 6b	lda #$6bf5	                LDA #<>dosstat_name
.3a6bc8	85 e7		sta $08e7	                STA TOFIND
.3a6bca	20 7f 53	jsr $3a537f	            JSR VAR_SET
.3a6bcd	e2 20		sep #$20	            SEP #$20
.3a6bcf	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS          ; Get the BIOS status code
.3a6bd3	85 23		sta $0823	                STA ARGUMENT1
.3a6bd5	a9 00		lda #$00	                LDA #0
.3a6bd7	85 24		sta $0824	                STA ARGUMENT1+1
.3a6bd9	85 25		sta $0825	                STA ARGUMENT1+2
.3a6bdb	85 26		sta $0826	                STA ARGUMENT1+3
.3a6bdd	a9 00		lda #$00	                LDA #TYPE_INTEGER
.3a6bdf	85 27		sta $0827	                STA ARGTYPE1
.3a6be1	85 ea		sta $08ea	                STA TOFINDTYPE              ; Indicate what variable to set (BIOSSTAT)
.3a6be3	a9 3a		lda #$3a	                LDA #`biosstat_name
.3a6be5	85 e9		sta $08e9	                STA TOFIND+2
.3a6be7	c2 20		rep #$20	            REP #$20
.3a6be9	a9 fd 6b	lda #$6bfd	                LDA #<>biosstat_name
.3a6bec	85 e7		sta $08e7	                STA TOFIND
.3a6bee	20 7f 53	jsr $3a537f	            JSR VAR_SET
.3a6bf1	28		plp		                PLP
.3a6bf2	2b		pld		                PLD
.3a6bf3	ab		plb		                PLB
.3a6bf4	60		rts		            RTS
>3a6bf5	44 4f 53 53 54 41 54 00		dosstat_name    .null "DOSSTAT"
>3a6bfd	42 49 4f 53 53 54 41 54		biosstat_name   .null "BIOSSTAT"
>3a6c05	00
.3a6c06					CMD_BRUN
.3a6c06	08		php		                PHP
.3a6c07	c2 30		rep #$30	            REP #$30
.3a6c09	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a6c0c	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a6c0f	20 e3 06	jsr $3a06e3	            JSR ASS_ARG1_STR
.3a6c12	a5 23		lda $0823	                LDA ARGUMENT1
.3a6c14	8f 60 03 00	sta $000360	                STA @l DOS_RUN_PARAM
.3a6c18	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6c1a	8f 62 03 00	sta $000362	                STA @l DOS_RUN_PARAM+2
.3a6c1e	a9 ff ff	lda #$ffff	                LDA #$FFFF
.3a6c21	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a6c25	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a6c29	22 24 11 00	jsl $001124	                JSL FK_RUN                  ; Attempt to run the file
.3a6c2d	b0 25		bcs $3a6c54	                BCS done                    ; If we got it: try to execute it
.3a6c2f	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a6c32	20 92 6b	jsr $3a6b92	            JSR SET_DOSSTAT
.3a6c35	08		php		            PHP
.3a6c36	c2 20		rep #$20	            REP #$20
.3a6c38	48		pha		            PHA
.3a6c39	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6c3c	5b		tcd		            TCD
.3a6c3d	68		pla		            PLA
.3a6c3e	28		plp		            PLP
.3a6c3f	e2 20		sep #$20	            SEP #$20
.3a6c41	a9 11		lda #$11	            LDA #ERR_LOAD
.3a6c43	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6c47	c2 20		rep #$20	            REP #$20
.3a6c49	29 ff 00	and #$00ff	            AND #$00FF
.3a6c4c	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a6c4f	e2 20		sep #$20	            SEP #$20
.3a6c51	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6c54					done
.3a6c54	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a6c57	28		plp		                PLP
.3a6c58	60		rts		            RTS
.3a6c59					CMD_LOAD
.3a6c59	08		php		                PHP
.3a6c5a	c2 30		rep #$30	            REP #$30
.3a6c5c	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a6c5f	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a6c62	20 e3 06	jsr $3a06e3	            JSR ASS_ARG1_STR
.3a6c65	20 e1 6a	jsr $3a6ae1	            JSR SETFILEDESC
.3a6c68	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.3a6c6b	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a6c6f	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.3a6c72	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2        ; Set the destination address
.3a6c76	20 50 50	jsr $3a5050	            JSR CMD_NEW
.3a6c79	22 18 11 00	jsl $001118	                JSL FK_LOAD                 ; Attempt to load the file
.3a6c7d	b0 22		bcs $3a6ca1	                BCS start_tokenize          ; If we got it: start tokenizing
.3a6c7f	20 92 6b	jsr $3a6b92	            JSR SET_DOSSTAT
.3a6c82	08		php		            PHP
.3a6c83	c2 20		rep #$20	            REP #$20
.3a6c85	48		pha		            PHA
.3a6c86	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6c89	5b		tcd		            TCD
.3a6c8a	68		pla		            PLA
.3a6c8b	28		plp		            PLP
.3a6c8c	e2 20		sep #$20	            SEP #$20
.3a6c8e	a9 11		lda #$11	            LDA #ERR_LOAD
.3a6c90	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6c94	c2 20		rep #$20	            REP #$20
.3a6c96	29 ff 00	and #$00ff	            AND #$00FF
.3a6c99	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a6c9c	e2 20		sep #$20	            SEP #$20
.3a6c9e	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6ca1					start_tokenize
.3a6ca1	20 92 6b	jsr $3a6b92	            JSR SET_DOSSTAT
.3a6ca4	c2 20		rep #$20	            REP #$20
.3a6ca6	a2 12 00	ldx #$0012	                LDX #FILEDESC.FILESIZE
.3a6ca9	18		clc		                CLC                         ; Set MTEMP to point to the byte after the file
.3a6caa	bf 73 f2 3a	lda $3af273,x	                LDA FD_IN,X
.3a6cae	69 00 00	adc #$0000	                ADC #<>LOADBLOCK
.3a6cb1	85 92		sta $0892	                STA MTEMP
.3a6cb3	bf 75 f2 3a	lda $3af275,x	                LDA FD_IN+2,X
.3a6cb7	69 01 00	adc #$0001	                ADC #`LOADBLOCK
.3a6cba	85 94		sta $0894	                STA MTEMP+2
.3a6cbc	e2 20		sep #$20	            SEP #$20
.3a6cbe	a9 00		lda #$00	                LDA #0
.3a6cc0	87 92		sta [$0892]	                STA [MTEMP]                 ; Write a NULL right after the file
.3a6cc2	c2 20		rep #$20	            REP #$20
.3a6cc4	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK            ; Set MCURSOR to the begining of the loaded data
.3a6cc7	85 7a		sta $087a	                STA MCURSOR
.3a6cc9	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.3a6ccc	85 7c		sta $087c	                STA MCURSOR+2
.3a6cce	a2 00 00	ldx #$0000	copy_line       LDX #0
.3a6cd1					copy_char
.3a6cd1	e2 20		sep #$20	            SEP #$20
.3a6cd3	a7 7a		lda [$087a]	                LDA [MCURSOR]
.3a6cd5	f0 2a		beq $3a6d01	                BEQ clean_up                ; If the character is 0, we're done
.3a6cd7	c9 0d		cmp #$0d	                CMP #CHAR_CR                ; If it is new line...
.3a6cd9	f0 12		beq $3a6ced	                BEQ do_process              ; ... we want to process the line
.3a6cdb	c9 0a		cmp #$0a	                CMP #CHAR_LF                ; If it is a line feed...
.3a6cdd	f0 04		beq $3a6ce3	                BEQ next_char               ; ... we want to skip it
.3a6cdf	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X              ; Otherwise, copy the character to the input buffer
.3a6ce2	e8		inx		                INX
.3a6ce3					next_char
.3a6ce3	c2 20		rep #$20	            REP #$20
.3a6ce5	e6 7a		inc $087a	                INC MCURSOR                 ; Advance the input cursor
.3a6ce7	d0 e8		bne $3a6cd1	                BNE copy_char
.3a6ce9	e6 7c		inc $087c	                INC MCURSOR+2
.3a6ceb	80 e4		bra $3a6cd1	                BRA copy_char
.3a6ced					do_process
.3a6ced	e2 20		sep #$20	            SEP #$20
.3a6cef	a9 00		lda #$00	                LDA #0                      ; Put a 0 at the end of the input buffer
.3a6cf1	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a6cf4	20 89 27	jsr $3a2789	            JSR PROCESS
.3a6cf7	c2 20		rep #$20	            REP #$20
.3a6cf9	e6 7a		inc $087a	                INC MCURSOR                 ; Try again with the next line
.3a6cfb	d0 d1		bne $3a6cce	                BNE copy_line
.3a6cfd	e6 7c		inc $087c	                INC MCURSOR+2
.3a6cff	80 cd		bra $3a6cce	                BRA copy_line
.3a6d01	e0 00 00	cpx #$0000	clean_up        CPX #0                      ; Is there data in the INPUTBUF?
.3a6d04	f0 0a		beq $3a6d10	                BEQ done                    ; No: just return
.3a6d06	e2 20		sep #$20	            SEP #$20
.3a6d08	a9 00		lda #$00	                LDA #0                      ; Make sure there is a trailing NULL
.3a6d0a	9d 00 4f	sta $4f00,x	                STA INPUTBUF,X
.3a6d0d	20 89 27	jsr $3a2789	            JSR PROCESS
.3a6d10	28		plp		done            PLP
.3a6d11	60		rts		            RTS
.3a6d12					S_BSAVE
.3a6d12	08		php		                PHP
.3a6d13	c2 30		rep #$30	            REP #$30
.3a6d15	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a6d18	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a6d1b	20 e3 06	jsr $3a06e3	            JSR ASS_ARG1_STR
.3a6d1e	20 e1 6a	jsr $3a6ae1	            JSR SETFILEDESC
.3a6d21	e2 20		sep #$20	            SEP #$20
.3a6d23	a9 2c		lda #$2c	                LDA #','
.3a6d25	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a6d28	c2 20		rep #$20	            REP #$20
.3a6d2a	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a6d2d	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a6d30	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_SRC_PTR
.3a6d32	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.3a6d36	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6d38	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.3a6d3c	e2 20		sep #$20	            SEP #$20
.3a6d3e	a9 2c		lda #$2c	                LDA #','
.3a6d40	c2 20		rep #$20	            REP #$20
.3a6d42	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a6d45	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a6d48	20 51 06	jsr $3a0651	            JSR ASS_ARG1_INT
.3a6d4b	a5 23		lda $0823	                LDA ARGUMENT1               ; Put that address in DOS_END_PTR
.3a6d4d	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.3a6d51	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6d53	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.3a6d57	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                 ; Attempt to save the memory to file.
.3a6d5b	b0 22		bcs $3a6d7f	                BCS done
.3a6d5d	20 92 6b	jsr $3a6b92	            JSR SET_DOSSTAT
.3a6d60	08		php		            PHP
.3a6d61	c2 20		rep #$20	            REP #$20
.3a6d63	48		pha		            PHA
.3a6d64	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6d67	5b		tcd		            TCD
.3a6d68	68		pla		            PLA
.3a6d69	28		plp		            PLP
.3a6d6a	e2 20		sep #$20	            SEP #$20
.3a6d6c	a9 12		lda #$12	            LDA #ERR_SAVE
.3a6d6e	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6d72	c2 20		rep #$20	            REP #$20
.3a6d74	29 ff 00	and #$00ff	            AND #$00FF
.3a6d77	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a6d7a	e2 20		sep #$20	            SEP #$20
.3a6d7c	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6d7f					done
.3a6d7f	20 92 6b	jsr $3a6b92	            JSR SET_DOSSTAT
.3a6d82	28		plp		                PLP
.3a6d83	60		rts		            RTS
.3a6d84					COPY2PATHBUF
.3a6d84	da		phx		                PHX
.3a6d85	5a		phy		                PHY
.3a6d86	08		php		                PHP
.3a6d87	a2 00 00	ldx #$0000	                LDX #0
.3a6d8a	a0 00 00	ldy #$0000	                LDY #0
.3a6d8d	e2 20		sep #$20	            SEP #$20
.3a6d8f	b7 23		lda [$0823],y	loop            LDA [ARGUMENT1],Y           ; Copy the path to the DOS_PATH_BUFF
.3a6d91	9d 00 04	sta $0400,x	                STA DOS_PATH_BUFF,X
.3a6d94	f0 04		beq $3a6d9a	                BEQ done
.3a6d96	e8		inx		                INX
.3a6d97	c8		iny		                INY
.3a6d98	80 f5		bra $3a6d8f	                BRA loop
.3a6d9a	28		plp		done            PLP
.3a6d9b	7a		ply		                PLY
.3a6d9c	fa		plx		                PLX
.3a6d9d	60		rts		            RTS
.3a6d9e					CMD_SAVE
.3a6d9e	08		php		                PHP
.3a6d9f	c2 30		rep #$30	            REP #$30
.3a6da1	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a6da4	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a6da7	20 e3 06	jsr $3a06e3	            JSR ASS_ARG1_STR
.3a6daa	20 e1 6a	jsr $3a6ae1	            JSR SETFILEDESC
.3a6dad	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.3a6db0	85 a6		sta $08a6	                STA OBUFFER
.3a6db2	e2 20		sep #$20	            SEP #$20
.3a6db4	a9 01		lda #$01	                LDA #`LOADBLOCK
.3a6db6	85 a8		sta $08a8	                STA OBUFFER+2
.3a6db8	a9 20		lda #$20	                LDA #DEV_BUFFER             ; Set up output for the buffer
.3a6dba	85 b4		sta $08b4	                STA BCONSOLE
.3a6dbc	c2 20		rep #$20	            REP #$20
.3a6dbe	a9 00 00	lda #$0000	                LDA #0
.3a6dc1	85 ab		sta $08ab	                STA OBUFFIDX
.3a6dc3	a9 ff ff	lda #$ffff	                LDA #$FFFF
.3a6dc6	85 a9		sta $08a9	                STA OBUFFSIZE
.3a6dc8	c2 20		rep #$20	            REP #$20
.3a6dca	a9 00 00	lda #$0000	                LDA #0                      ; Set start line number to 0
.3a6dcd	85 55		sta $0855	                STA MARG1
.3a6dcf	85 57		sta $0857	                STA MARG1+2
.3a6dd1	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Set end line number to MAXINT
.3a6dd4	85 59		sta $0859	                STA MARG2
.3a6dd6	a9 ff 7f	lda #$7fff	                LDA #$7FFF
.3a6dd9	85 5b		sta $085b	                STA MARG2+2
.3a6ddb	20 8b 18	jsr $3a188b	            JSR LISTPROG
.3a6dde	e2 20		sep #$20	            SEP #$20
.3a6de0	a9 80		lda #$80	                LDA #DEV_SCREEN             ; Restore output to the screen
.3a6de2	85 b4		sta $08b4	                STA BCONSOLE
.3a6de4	c2 20		rep #$20	            REP #$20
.3a6de6	c6 ab		dec $08ab	                DEC OBUFFIDX                ; OBUFFIDX points to the next free byte... so pull it in one
.3a6de8	18		clc		                CLC                         ; Set the range of memory to save
.3a6de9	a9 00 00	lda #$0000	                LDA #<>LOADBLOCK
.3a6dec	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.3a6df0	65 ab		adc $08ab	                ADC OBUFFIDX
.3a6df2	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.3a6df6	a9 01 00	lda #$0001	                LDA #`LOADBLOCK
.3a6df9	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.3a6dfd	69 00 00	adc #$0000	                ADC #0
.3a6e00	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.3a6e04	22 1c 11 00	jsl $00111c	do_save         JSL FK_SAVE                 ; Attempt to save the file
.3a6e08	b0 22		bcs $3a6e2c	                BCS done
.3a6e0a	20 92 6b	jsr $3a6b92	            JSR SET_DOSSTAT
.3a6e0d	08		php		            PHP
.3a6e0e	c2 20		rep #$20	            REP #$20
.3a6e10	48		pha		            PHA
.3a6e11	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6e14	5b		tcd		            TCD
.3a6e15	68		pla		            PLA
.3a6e16	28		plp		            PLP
.3a6e17	e2 20		sep #$20	            SEP #$20
.3a6e19	a9 12		lda #$12	            LDA #ERR_SAVE
.3a6e1b	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6e1f	c2 20		rep #$20	            REP #$20
.3a6e21	29 ff 00	and #$00ff	            AND #$00FF
.3a6e24	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a6e27	e2 20		sep #$20	            SEP #$20
.3a6e29	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6e2c					done
.3a6e2c	20 92 6b	jsr $3a6b92	            JSR SET_DOSSTAT
.3a6e2f	28		plp		                PLP
.3a6e30	60		rts		            RTS
.3a6e31					S_DEL
.3a6e31	08		php		                PHP
.3a6e32	c2 30		rep #$30	            REP #$30
.3a6e34	20 3b 21	jsr $3a213b	            JSR SKIPWS
.3a6e37	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a6e3a	20 e3 06	jsr $3a06e3	            JSR ASS_ARG1_STR
.3a6e3d	20 84 6d	jsr $3a6d84	            JSR COPY2PATHBUF
.3a6e40	22 04 11 00	jsl $001104	path_loaded     JSL FK_DELETE               ; Try to delete the file
.3a6e44	b0 22		bcs $3a6e68	                BCS done
.3a6e46	20 92 6b	jsr $3a6b92	            JSR SET_DOSSTAT
.3a6e49	08		php		            PHP
.3a6e4a	c2 20		rep #$20	            REP #$20
.3a6e4c	48		pha		            PHA
.3a6e4d	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6e50	5b		tcd		            TCD
.3a6e51	68		pla		            PLA
.3a6e52	28		plp		            PLP
.3a6e53	e2 20		sep #$20	            SEP #$20
.3a6e55	a9 13		lda #$13	            LDA #ERR_DELETE
.3a6e57	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6e5b	c2 20		rep #$20	            REP #$20
.3a6e5d	29 ff 00	and #$00ff	            AND #$00FF
.3a6e60	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a6e63	e2 20		sep #$20	            SEP #$20
.3a6e65	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6e68					done
.3a6e68	20 92 6b	jsr $3a6b92	            JSR SET_DOSSTAT
.3a6e6b	28		plp		                PLP
.3a6e6c	60		rts		            RTS
.3a6e6d					VALIDFILECHAR
.3a6e6d	da		phx		                PHX
.3a6e6e	08		php		                PHP
.3a6e6f	e2 20		sep #$20	            SEP #$20
.3a6e71	c9 61		cmp #$61	                CMP #'a'                    ; Is it lower case?
.3a6e73	90 08		bcc $3a6e7d	                BLT chk_space
.3a6e75	c9 7b		cmp #$7b	                CMP #'z'+1
.3a6e77	b0 04		bcs $3a6e7d	                BGE chk_space
.3a6e79	29 df		and #$df	                AND #%11011111              ; Yes: convert to upper case
.3a6e7b	80 13		bra $3a6e90	                BRA ret_valid
.3a6e7d	c9 20		cmp #$20	chk_space       CMP #CHAR_SP            ; Is it a control code?
.3a6e7f	90 13		bcc $3a6e94	                BLT is_invalid          ; Yes: it's invalid
.3a6e81	a2 00 00	ldx #$0000	                LDX #0                  ; See if it's in the list of invalids
.3a6e84	df 98 6e 3a	cmp $3a6e98,x	loop            CMP invalid_chars,X
.3a6e88	f0 0a		beq $3a6e94	                BEQ is_invalid
.3a6e8a	e8		inx		                INX
.3a6e8b	e0 0f 00	cpx #$000f	                CPX #15                 ; # of invalid characters
.3a6e8e	d0 f4		bne $3a6e84	                BNE loop
.3a6e90	28		plp		ret_valid       PLP
.3a6e91	38		sec		                SEC
.3a6e92	fa		plx		                PLX
.3a6e93	6b		rtl		                RTL
.3a6e94	28		plp		is_invalid      PLP
.3a6e95	18		clc		                CLC
.3a6e96	fa		plx		                PLX
.3a6e97	6b		rtl		                RTL
>3a6e98	2a 2b 2c 2f 3a 3b 3c 3d		invalid_chars   .text "*+,/:;<=>?\[]|",CHAR_DQUOTE
>3a6ea0	3e 3f 5c 5b 5d 7c 22
.3a6ea7					S_RENAME
.3a6ea7	08		php		                PHP
.3a6ea8	08		php		            PHP
.3a6ea9	c2 20		rep #$20	            REP #$20
.3a6eab	48		pha		            PHA
.3a6eac	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a6eaf	5b		tcd		            TCD
.3a6eb0	68		pla		            PLA
.3a6eb1	28		plp		            PLP
.3a6eb2	c2 30		rep #$30	            REP #$30
.3a6eb4	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a6eb7	20 e3 06	jsr $3a06e3	            JSR ASS_ARG1_STR
.3a6eba	20 84 6d	jsr $3a6d84	            JSR COPY2PATHBUF
.3a6ebd	22 10 11 00	jsl $001110	                JSL FK_DIRREAD              ; Try to read the file
.3a6ec1	b0 22		bcs $3a6ee5	                BCS get_new_name            ; If ok: get the new name
.3a6ec3	20 92 6b	jsr $3a6b92	            JSR SET_DOSSTAT
.3a6ec6	08		php		            PHP
.3a6ec7	c2 20		rep #$20	            REP #$20
.3a6ec9	48		pha		            PHA
.3a6eca	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6ecd	5b		tcd		            TCD
.3a6ece	68		pla		            PLA
.3a6ecf	28		plp		            PLP
.3a6ed0	e2 20		sep #$20	            SEP #$20
.3a6ed2	a9 14		lda #$14	            LDA #ERR_FILENOTFOUND
.3a6ed4	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6ed8	c2 20		rep #$20	            REP #$20
.3a6eda	29 ff 00	and #$00ff	            AND #$00FF
.3a6edd	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a6ee0	e2 20		sep #$20	            SEP #$20
.3a6ee2	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6ee5					get_new_name
.3a6ee5	e2 20		sep #$20	            SEP #$20
.3a6ee7	a9 2c		lda #$2c	                LDA #','
.3a6ee9	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a6eec	c2 20		rep #$20	            REP #$20
.3a6eee	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a6ef1	20 e3 06	jsr $3a06e3	            JSR ASS_ARG1_STR
.3a6ef4	ad 38 03	lda $0338	                LDA DOS_DIR_PTR
.3a6ef7	85 08		sta $0808	                STA INDEX
.3a6ef9	ad 3a 03	lda $033a	                LDA DOS_DIR_PTR+2
.3a6efc	85 0a		sta $080a	                STA INDEX+2
.3a6efe	e2 20		sep #$20	            SEP #$20
.3a6f00	a2 00 00	ldx #$0000	                LDX #0
.3a6f03	a9 20		lda #$20	                LDA #CHAR_SP                ; We'll use MLINEBUFF as temporary name storage
.3a6f05	95 7e		sta $087e,x	blank_loop      STA MLINEBUF,X              ; Fill it with blanks
.3a6f07	e8		inx		                INX
.3a6f08	e0 0b 00	cpx #$000b	                CPX #11
.3a6f0b	d0 f8		bne $3a6f05	                BNE blank_loop
.3a6f0d	a2 00 00	ldx #$0000	                LDX #0
.3a6f10	a0 00 00	ldy #$0000	                LDY #0
.3a6f13	b7 23		lda [$0823],y	name_loop       LDA [ARGUMENT1],Y           ; Get the character of the new name
.3a6f15	f0 76		beq $3a6f8d	                BEQ copy_short_name         ; If end-of-string: copy what we have
.3a6f17	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.3a6f19	f0 39		beq $3a6f54	                BEQ skip_dot                ; Yes: move on to the extension characters
.3a6f1b	22 6d 6e 3a	jsl $3a6e6d	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.3a6f1f	b0 1f		bcs $3a6f40	                BCS save_nm_char
.3a6f21	08		php		            PHP
.3a6f22	c2 20		rep #$20	            REP #$20
.3a6f24	48		pha		            PHA
.3a6f25	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6f28	5b		tcd		            TCD
.3a6f29	68		pla		            PLA
.3a6f2a	28		plp		            PLP
.3a6f2b	e2 20		sep #$20	            SEP #$20
.3a6f2d	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a6f2f	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6f33	c2 20		rep #$20	            REP #$20
.3a6f35	29 ff 00	and #$00ff	            AND #$00FF
.3a6f38	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a6f3b	e2 20		sep #$20	            SEP #$20
.3a6f3d	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6f40	95 7e		sta $087e,x	save_nm_char    STA MLINEBUF,X              ; Otherwise: copy it
.3a6f42	c8		iny		                INY
.3a6f43	e8		inx		                INX
.3a6f44	c0 08 00	cpy #$0008	                CPY #8
.3a6f47	d0 ca		bne $3a6f13	                BNE name_loop
.3a6f49	b7 23		lda [$0823],y	eat_name        LDA [ARGUMENT1],Y           ; Get the character
.3a6f4b	f0 40		beq $3a6f8d	                BEQ copy_short_name         ; If null, we're done with the short name
.3a6f4d	c9 2e		cmp #$2e	                CMP #'.'                    ; Is it a dot?
.3a6f4f	f0 03		beq $3a6f54	                BEQ skip_dot                ; Yes: skip over it
.3a6f51	c8		iny		                INY                         ; No: try again with the the next character
.3a6f52	80 f5		bra $3a6f49	                BRA eat_name
.3a6f54	c8		iny		skip_dot        INY                         ; Character at Y is '.', so skip over it
.3a6f55	a2 08 00	ldx #$0008	do_ext          LDX #8
.3a6f58	b7 23		lda [$0823],y	ext_loop        LDA [ARGUMENT1],Y           ; Get the character of the new extension
.3a6f5a	f0 31		beq $3a6f8d	                BEQ copy_short_name         ; If end-of-string: copy what we have
.3a6f5c	22 6d 6e 3a	jsl $3a6e6d	                JSL VALIDFILECHAR           ; Make sure the character is valid and uppercase
.3a6f60	b0 22		bcs $3a6f84	                BCS save_ext_char
.3a6f62	20 92 6b	jsr $3a6b92	            JSR SET_DOSSTAT
.3a6f65	08		php		            PHP
.3a6f66	c2 20		rep #$20	            REP #$20
.3a6f68	48		pha		            PHA
.3a6f69	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6f6c	5b		tcd		            TCD
.3a6f6d	68		pla		            PLA
.3a6f6e	28		plp		            PLP
.3a6f6f	e2 20		sep #$20	            SEP #$20
.3a6f71	a9 0a		lda #$0a	            LDA #ERR_ARGUMENT
.3a6f73	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6f77	c2 20		rep #$20	            REP #$20
.3a6f79	29 ff 00	and #$00ff	            AND #$00FF
.3a6f7c	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a6f7f	e2 20		sep #$20	            SEP #$20
.3a6f81	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6f84	95 7e		sta $087e,x	save_ext_char   STA MLINEBUF,X              ; Otherwise: copy it
.3a6f86	c8		iny		                INY
.3a6f87	e8		inx		                INX
.3a6f88	c0 0c 00	cpy #$000c	                CPY #12
.3a6f8b	d0 cb		bne $3a6f58	                BNE ext_loop
.3a6f8d	a2 00 00	ldx #$0000	copy_short_name LDX #0                      ; Copy the short name we built to the directory entry
.3a6f90	a0 00 00	ldy #$0000	                LDY #DIRENTRY.SHORTNAME
.3a6f93	b5 7e		lda $087e,x	copy_loop       LDA MLINEBUF,X
.3a6f95	97 08		sta [$0808],y	                STA [INDEX],Y
.3a6f97	e8		inx		                INX
.3a6f98	c8		iny		                INY
.3a6f99	c0 0b 00	cpy #$000b	                CPY #11
.3a6f9c	d0 f5		bne $3a6f93	                BNE copy_loop
.3a6f9e	22 14 11 00	jsl $001114	                JSL FK_DIRWRITE             ; Write the directory entry back
.3a6fa2	b0 22		bcs $3a6fc6	                BCS done
.3a6fa4	20 92 6b	jsr $3a6b92	            JSR SET_DOSSTAT
.3a6fa7	08		php		            PHP
.3a6fa8	c2 20		rep #$20	            REP #$20
.3a6faa	48		pha		            PHA
.3a6fab	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a6fae	5b		tcd		            TCD
.3a6faf	68		pla		            PLA
.3a6fb0	28		plp		            PLP
.3a6fb1	e2 20		sep #$20	            SEP #$20
.3a6fb3	a9 15		lda #$15	            LDA #ERR_DIRNOTWRITE
.3a6fb5	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a6fb9	c2 20		rep #$20	            REP #$20
.3a6fbb	29 ff 00	and #$00ff	            AND #$00FF
.3a6fbe	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a6fc1	e2 20		sep #$20	            SEP #$20
.3a6fc3	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a6fc6					done
.3a6fc6	20 92 6b	jsr $3a6b92	            JSR SET_DOSSTAT
.3a6fc9	28		plp		                PLP
.3a6fca	60		rts		            RTS
.3a6fcb					S_COPY
.3a6fcb	08		php		                PHP
.3a6fcc	08		php		            PHP
.3a6fcd	c2 20		rep #$20	            REP #$20
.3a6fcf	48		pha		            PHA
.3a6fd0	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a6fd3	5b		tcd		            TCD
.3a6fd4	68		pla		            PLA
.3a6fd5	28		plp		            PLP
.3a6fd6	c2 30		rep #$30	            REP #$30
.3a6fd8	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a6fdb	20 e3 06	jsr $3a06e3	            JSR ASS_ARG1_STR
.3a6fde	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.3a6fe0	8f 64 03 00	sta $000364	                STA @l DOS_STR1_PTR
.3a6fe4	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a6fe6	8f 66 03 00	sta $000366	                STA @l DOS_STR1_PTR+2
.3a6fea	e2 20		sep #$20	            SEP #$20
.3a6fec	a9 2c		lda #$2c	                LDA #','
.3a6fee	20 27 22	jsr $3a2227	            JSR EXPECT_TOK
.3a6ff1	c2 20		rep #$20	            REP #$20
.3a6ff3	20 09 1d	jsr $3a1d09	            JSR EVALEXPR
.3a6ff6	20 e3 06	jsr $3a06e3	            JSR ASS_ARG1_STR
.3a6ff9	a5 23		lda $0823	                LDA ARGUMENT1               ; Set the source path
.3a6ffb	8f 68 03 00	sta $000368	                STA @l DOS_STR2_PTR
.3a6fff	a5 25		lda $0825	                LDA ARGUMENT1+2
.3a7001	8f 6a 03 00	sta $00036a	                STA @l DOS_STR2_PTR+2
.3a7005	22 30 11 00	jsl $001130	                JSL FK_COPY                 ; Attempt to copy the file
.3a7009	b0 1f		bcs $3a702a	                BCS done
.3a700b	08		php		            PHP
.3a700c	c2 20		rep #$20	            REP #$20
.3a700e	48		pha		            PHA
.3a700f	a9 00 08	lda #$0800	            LDA #<>GLOBAL_VARS
.3a7012	5b		tcd		            TCD
.3a7013	68		pla		            PLA
.3a7014	28		plp		            PLP
.3a7015	e2 20		sep #$20	            SEP #$20
.3a7017	a9 16		lda #$16	            LDA #ERR_NOTCOPIED
.3a7019	8f d3 08 00	sta $0008d3	            STA @lERROR_NUM
.3a701d	c2 20		rep #$20	            REP #$20
.3a701f	29 ff 00	and #$00ff	            AND #$00FF
.3a7022	20 5b 1e	jsr $3a1e5b	            JSR SET_ERRERL
.3a7025	e2 20		sep #$20	            SEP #$20
.3a7027	dc d4 08	jmp [$08d4]	            JMP [HANDLEERR]
.3a702a	28		plp		done            PLP
.3a702b	60		rts		            RTS

;******  Return to file: src\basic816.s


;******  Processing file: src\monitor.s

.3a702c	5c e9 89 3a	jmp $3a89e9	MRETURN         JML IMRETURN
.3a7030	5c 3a 88 3a	jmp $3a883a	MPARSE          JML IMPARSE
.3a7034	5c ea 89 3a	jmp $3a89ea	MPARSE1         JML IMPARSE1
.3a7038	5c 66 79 3a	jmp $3a7966	MEXECUTE        JML IMEXECUTE
.3a703c	5c c3 79 3a	jmp $3a79c3	MASSEMBLE       JML IMASSEMBLE
.3a7040	5c f6 78 3a	jmp $3a78f6	MRMODIFY        JML IMRMODIFY
.3a7044	5c 7c 78 3a	jmp $3a787c	MCOMPARE        JML IMCOMPARE
.3a7048	5c f9 7d 3a	jmp $3a7df9	MDISASSEMBLE    JML IMDISASSEMBLE
.3a704c	5c e7 74 3a	jmp $3a74e7	MFILL           JML IMFILL
.3a7050	5c 14 78 3a	jmp $3a7814	MGO             JML IMGO
.3a7054	5c cf 77 3a	jmp $3a77cf	MJUMP           JML IMJUMP
.3a7058	5c 59 77 3a	jmp $3a7759	MHUNT           JML IMHUNT
.3a705c	5c f8 88 3a	jmp $3a88f8	MLOAD           JML IMLOAD
.3a7060	5c f5 75 3a	jmp $3a75f5	MMEMORY         JML IMMEMORY
.3a7064	5c 45 74 3a	jmp $3a7445	MREGISTERS      JML IMREGISTERS
.3a7068	5c 73 89 3a	jmp $3a8973	MSAVE           JML IMSAVE
.3a706c	5c 23 75 3a	jmp $3a7523	MTRANSFER       JML IMTRANSFER
.3a7070	5c ec 89 3a	jmp $3a89ec	MVERIFY         JML IMVERIFY
.3a7074	5c e5 89 3a	jmp $3a89e5	MEXIT           JML IMEXIT
.3a7078	5c 12 77 3a	jmp $3a7712	MMODIFY         JML IMMODIFY
.3a707c	5c ed 89 3a	jmp $3a89ed	MDOS            JML IMDOS
.3a7080	18		clc		IMONITOR        CLC                 ; clear the carry flag
.3a7081	fb		xce		                XCE                 ; move carry to emulation flags
.3a7082	58		cli		                CLI                 ; Re-enable interrupts
.3a7083	5c 87 70 3a	jmp $3a7087	                JML IMREADY
.3a7087					IMREADY
.3a7087	c2 30		rep #$30	            REP #$30
.3a7089	22 45 74 3a	jsl $3a7445	                JSL IMREGISTERS
.3a708d					ready_loop
.3a708d	20 08 00	jsr $3a0008	            JSR READLINE
.3a7090	20 0c 00	jsr $3a000c	            JSR SCRCOPYLINE
.3a7093	8b		phb		                PHB
.3a7094	e2 20		sep #$20	            SEP #$20
.3a7096	a9 00		lda #$00	                LDA #`INPUTBUF
.3a7098	48		pha		                PHA
.3a7099	ab		plb		                PLB
.3a709a	a2 00 4f	ldx #$4f00	                LDX #<>INPUTBUF
.3a709d	20 65 05	jsr $3a0565	            JSR TOUPPER
.3a70a0	ab		plb		                PLB
.3a70a1	22 30 70 3a	jsl $3a7030	                JSL MPARSE          ; Parse the command
.3a70a5	22 38 70 3a	jsl $3a7038	                JSL MEXECUTE        ; And execute the parsed command
.3a70a9	80 e2		bra $3a708d	                BRA ready_loop
.3a70ab					IMHELP
.3a70ab	08		php		                PHP
.3a70ac	8b		phb		                PHB
.3a70ad	e2 20		sep #$20	            SEP #$20
.3a70af	a9 3a		lda #$3a	                LDA #`help_text
.3a70b1	48		pha		                PHA
.3a70b2	ab		plb		                PLB
.3a70b3	c2 10		rep #$10	            REP #$10
.3a70b5	a2 be 70	ldx #$70be	                LDX #<>help_text
.3a70b8	20 64 04	jsr $3a0464	            JSR PRINTS
.3a70bb	ab		plb		                PLB
.3a70bc	28		plp		                PLP
.3a70bd	6b		rtl		                RTL
>3a70be	41 20 3c 73 74 61 72 74		help_text       .text "A <start> <assembly>",CHAR_CR
>3a70c6	3e 20 3c 61 73 73 65 6d 62 6c 79 3e 0d
>3a70d3	20 20 41 73 73 65 6d 62		                .text "  Assemble a program",CHAR_CR,CHAR_CR
>3a70db	6c 65 20 61 20 70 72 6f 67 72 61 6d 0d 0d
>3a70e9	43 20 3c 73 74 61 72 74		                .text "C <start1> <start2> [len (1 if blank)]",CHAR_CR
>3a70f1	31 3e 20 3c 73 74 61 72 74 32 3e 20 5b 6c 65 6e
>3a7101	20 28 31 20 69 66 20 62 6c 61 6e 6b 29 5d 0d
>3a7110	20 20 43 6f 6d 70 61 72		                .text "  Compare to sections of memory",CHAR_CR,CHAR_CR
>3a7118	65 20 74 6f 20 73 65 63 74 69 6f 6e 73 20 6f 66
>3a7128	20 6d 65 6d 6f 72 79 0d 0d
>3a7131	44 20 3c 73 74 61 72 74		                .text "D <start> [end]",CHAR_CR
>3a7139	3e 20 5b 65 6e 64 5d 0d
>3a7141	20 20 44 69 73 61 73 73		                .text "  Disassemble a program",CHAR_CR,CHAR_CR
>3a7149	65 6d 62 6c 65 20 61 20 70 72 6f 67 72 61 6d 0d
>3a7159	0d
>3a715a	46 20 3c 73 74 61 72 74		                .text "F <start> <end> <byte>",CHAR_CR
>3a7162	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 0d
>3a7171	20 20 46 69 6c 6c 20 61		                .text "  Fill a block of memory with a byte",CHAR_CR,CHAR_CR
>3a7179	20 62 6c 6f 63 6b 20 6f 66 20 6d 65 6d 6f 72 79
>3a7189	20 77 69 74 68 20 61 20 62 79 74 65 0d 0d
>3a7197	47 20 5b 61 64 64 72 65		                .text "G [address]",CHAR_CR
>3a719f	73 73 5d 0d
>3a71a3	20 20 53 74 61 72 74 20		                .text "  Start execution at a location",CHAR_CR,CHAR_CR
>3a71ab	65 78 65 63 75 74 69 6f 6e 20 61 74 20 61 20 6c
>3a71bb	6f 63 61 74 69 6f 6e 0d 0d
>3a71c4	4a 20 5b 61 64 64 72 65		                .text "J [address] - Jump to a location in memory",CHAR_CR
>3a71cc	73 73 5d 20 2d 20 4a 75 6d 70 20 74 6f 20 61 20
>3a71dc	6c 6f 63 61 74 69 6f 6e 20 69 6e 20 6d 65 6d 6f
>3a71ec	72 79 0d
>3a71ef	20 20 4a 75 6d 70 20 74		                .text "  Jump to a location in memory",CHAR_CR,CHAR_CR
>3a71f7	6f 20 61 20 6c 6f 63 61 74 69 6f 6e 20 69 6e 20
>3a7207	6d 65 6d 6f 72 79 0d 0d
>3a720f	48 20 3c 73 74 61 72 74		                .text "H <start> <end> <byte> [byte]..",CHAR_CR
>3a7217	3e 20 3c 65 6e 64 3e 20 3c 62 79 74 65 3e 20 5b
>3a7227	62 79 74 65 5d 2e 2e 0d
>3a722f	20 20 48 75 6e 74 20 66		                .text "  Hunt for values in memory",CHAR_CR,CHAR_CR
>3a7237	6f 72 20 76 61 6c 75 65 73 20 69 6e 20 6d 65 6d
>3a7247	6f 72 79 0d 0d
>3a724c	4c 20 20 20 20 20 4c 4f		                .text "L     LOAD         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," [destination]",CHAR_CR
>3a7254	41 44 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>3a7264	22 20 5b 64 65 73 74 69 6e 61 74 69 6f 6e 5d 0d
>3a7274	4d 20 3c 73 74 61 72 74		                .text "M <start> [end]",CHAR_CR
>3a727c	3e 20 5b 65 6e 64 5d 0d
>3a7284	20 20 44 75 6d 70 20 74		                .text "  Dump the value in memory",CHAR_CR,CHAR_CR
>3a728c	68 65 20 76 61 6c 75 65 20 69 6e 20 6d 65 6d 6f
>3a729c	72 79 0d 0d
>3a72a0	52 20 2d 20 44 69 73 70		                .text "R - Display the values of the registers",CHAR_CR,CHAR_CR
>3a72a8	6c 61 79 20 74 68 65 20 76 61 6c 75 65 73 20 6f
>3a72b8	66 20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d
>3a72c8	0d
>3a72c9	3b 20 3c 50 43 3e 20 3c		                .text "; <PC> <A> <X> <Y> <SP> <DBR> <DP> <NVMXDIZC>",CHAR_CR
>3a72d1	41 3e 20 3c 58 3e 20 3c 59 3e 20 3c 53 50 3e 20
>3a72e1	3c 44 42 52 3e 20 3c 44 50 3e 20 3c 4e 56 4d 58
>3a72f1	44 49 5a 43 3e 0d
>3a72f7	20 20 43 68 61 6e 67 65		                .text "  Change the contents of the registers",CHAR_CR,CHAR_CR
>3a72ff	20 74 68 65 20 63 6f 6e 74 65 6e 74 73 20 6f 66
>3a730f	20 74 68 65 20 72 65 67 69 73 74 65 72 73 0d 0d
>3a731f	53 20 20 20 20 20 53 41		                .text "S     SAVE         ",CHAR_DQUOTE,"File",CHAR_DQUOTE," <start> <end>",CHAR_CR
>3a7327	56 45 20 20 20 20 20 20 20 20 20 22 46 69 6c 65
>3a7337	22 20 3c 73 74 61 72 74 3e 20 3c 65 6e 64 3e 0d
>3a7347	54 20 3c 73 74 61 72 74		                .text "T <start> <end> <destination>",CHAR_CR
>3a734f	3e 20 3c 65 6e 64 3e 20 3c 64 65 73 74 69 6e 61
>3a735f	74 69 6f 6e 3e 0d
>3a7365	20 20 54 72 61 6e 73 66		                .text "  Transfer (copy) data within memory",CHAR_CR,CHAR_CR
>3a736d	65 72 20 28 63 6f 70 79 29 20 64 61 74 61 20 77
>3a737d	69 74 68 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>3a738b	57 20 3c 62 79 74 65 3e		                .text "W <byte>",CHAR_CR
>3a7393	0d
>3a7394	20 20 53 65 74 20 74 68		                .text "  Set the register width flags for the disassembler",CHAR_CR,CHAR_CR
>3a739c	65 20 72 65 67 69 73 74 65 72 20 77 69 64 74 68
>3a73ac	20 66 6c 61 67 73 20 66 6f 72 20 74 68 65 20 64
>3a73bc	69 73 61 73 73 65 6d 62 6c 65 72 0d 0d
>3a73c9	58 20 2d 20 52 65 74 75		                .text "X - Return to BASIC",CHAR_CR,CHAR_CR
>3a73d1	72 6e 20 74 6f 20 42 41 53 49 43 0d 0d
>3a73de	3e 20 3c 73 74 61 72 74		                .text "> <start> <byte> [byte]...",CHAR_CR
>3a73e6	3e 20 3c 62 79 74 65 3e 20 5b 62 79 74 65 5d 2e
>3a73f6	2e 2e 0d
>3a73f9	20 20 45 64 69 74 20 64		                .text "  Edit data in memory",CHAR_CR,CHAR_CR
>3a7401	61 74 61 20 69 6e 20 6d 65 6d 6f 72 79 0d 0d
>3a7410	3f 20 2d 20 44 69 73 70		                .null "? - Display a short help screen",CHAR_CR,CHAR_CR
>3a7418	6c 61 79 20 61 20 73 68 6f 72 74 20 68 65 6c 70
>3a7428	20 73 63 72 65 65 6e 0d 0d 00
.3a7432					IMWIDTH
.3a7432	08		php		                PHP
.3a7433	08		php		            PHP
.3a7434	c2 20		rep #$20	            REP #$20
.3a7436	48		pha		            PHA
.3a7437	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a743a	5b		tcd		            TCD
.3a743b	68		pla		            PLA
.3a743c	28		plp		            PLP
.3a743d	e2 20		sep #$20	            SEP #$20
.3a743f	a5 0d		lda $0855	                LDA MARG1
.3a7441	85 4e		sta $0896	                STA MCPUSTAT
.3a7443	28		plp		                PLP
.3a7444	6b		rtl		                RTL
.3a7445					IMREGISTERS
.3a7445	20 3d 02	jsr $3a023d	            JSR ENSURETEXT
.3a7448	08		php		            PHP
.3a7449	e2 20		sep #$20	            SEP #$20
.3a744b	48		pha		            PHA
.3a744c	a9 3a		lda #$3a	            LDA #`mregisters_msg
.3a744e	48		pha		            PHA
.3a744f	ab		plb		            PLB
.3a7450	68		pla		            PLA
.3a7451	28		plp		            PLP
.3a7452	a2 2a 8a	ldx #$8a2a	                LDX #<>mregisters_msg
.3a7455	20 64 04	jsr $3a0464	            JSR PRINTS
.3a7458	e2 20		sep #$20	            SEP #$20
.3a745a	a9 3b		lda #$3b	                LDA #';'
.3a745c	20 18 00	jsr $3a0018	            JSR PRINTC
.3a745f	a9 20		lda #$20	                LDA #' '
.3a7461	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7464	c2 30		rep #$30	            REP #$30
.3a7466	08		php		            PHP
.3a7467	e2 20		sep #$20	            SEP #$20
.3a7469	48		pha		            PHA
.3a746a	a9 00		lda #$00	            LDA #$0
.3a746c	48		pha		            PHA
.3a746d	ab		plb		            PLB
.3a746e	68		pla		            PLA
.3a746f	28		plp		            PLP
.3a7470	a0 03 00	ldy #$0003	                LDY #3
.3a7473	a2 42 02	ldx #$0242	                LDX #CPUPC+2
.3a7476	20 e7 03	jsr $3a03e7	            JSR PRINTH
.3a7479	c2 20		rep #$20	            REP #$20
.3a747b	a9 20 00	lda #$0020	                LDA #' '
.3a747e	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7481	af 44 02 00	lda $000244	                LDA @lCPUA
.3a7485	20 74 04	jsr $3a0474	            JSR PRHEXW
.3a7488	a9 20 00	lda #$0020	                LDA #' '
.3a748b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a748e	af 46 02 00	lda $000246	                LDA @lCPUX
.3a7492	20 74 04	jsr $3a0474	            JSR PRHEXW
.3a7495	a9 20 00	lda #$0020	                LDA #' '
.3a7498	20 18 00	jsr $3a0018	            JSR PRINTC
.3a749b	af 48 02 00	lda $000248	                LDA @lCPUY
.3a749f	20 74 04	jsr $3a0474	            JSR PRHEXW
.3a74a2	a9 20 00	lda #$0020	                LDA #' '
.3a74a5	20 18 00	jsr $3a0018	            JSR PRINTC
.3a74a8	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK
.3a74ac	20 74 04	jsr $3a0474	            JSR PRHEXW
.3a74af	a9 20 00	lda #$0020	                LDA #' '
.3a74b2	20 18 00	jsr $3a0018	            JSR PRINTC
.3a74b5	af 4e 02 00	lda $00024e	                LDA @lCPUDBR
.3a74b9	20 8e 04	jsr $3a048e	            JSR PRHEXB
.3a74bc	a9 20 00	lda #$0020	                LDA #' '
.3a74bf	20 18 00	jsr $3a0018	            JSR PRINTC
.3a74c2	a9 20 00	lda #$0020	                LDA #' '
.3a74c5	20 18 00	jsr $3a0018	            JSR PRINTC
.3a74c8	af 4c 02 00	lda $00024c	                LDA @lCPUDP
.3a74cc	20 74 04	jsr $3a0474	            JSR PRHEXW
.3a74cf	a9 20 00	lda #$0020	                LDA #' '
.3a74d2	20 18 00	jsr $3a0018	            JSR PRINTC
.3a74d5	08		php		                PHP
.3a74d6	e2 20		sep #$20	            SEP #$20
.3a74d8	ad 4f 02	lda $024f	                LDA CPUFLAGS
.3a74db	22 43 87 3a	jsl $3a8743	                JSL MPRINTB
.3a74df	28		plp		                PLP
.3a74e0	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a74e3	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a74e6	6b		rtl		                RTL
.3a74e7					IMFILL
.3a74e7	08		php		                PHP                 ; Save the caller's context
.3a74e8	0b		phd		                PHD
.3a74e9	08		php		            PHP
.3a74ea	c2 20		rep #$20	            REP #$20
.3a74ec	48		pha		            PHA
.3a74ed	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a74f0	5b		tcd		            TCD
.3a74f1	68		pla		            PLA
.3a74f2	28		plp		            PLP
.3a74f3					do_copy
.3a74f3	e2 20		sep #$20	            SEP #$20
.3a74f5	a5 15		lda $085d	                LDA MARG3
.3a74f7	87 0d		sta [$0855]	                STA [MARG1]
.3a74f9	e2 20		sep #$20	            SEP #$20
.3a74fb	a5 0f		lda $0857	                LDA MARG1+2
.3a74fd	c5 13		cmp $085b	                CMP MARG2+2
.3a74ff	d0 0e		bne $3a750f	                BNE go_next         ; No: we haven't reached end address yet
.3a7501	c2 20		rep #$20	            REP #$20
.3a7503	a5 0d		lda $0855	                LDA MARG1
.3a7505	c5 11		cmp $0859	                CMP MARG2           ; Are they equal?
.3a7507	d0 06		bne $3a750f	                BNE go_next         ; No: we haven't reached end address yet
.3a7509	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a750c	2b		pld		                PLD                 ; Restore the caller's context
.3a750d	28		plp		                PLP
.3a750e	6b		rtl		                RTL
.3a750f					go_next
.3a750f	c2 20		rep #$20	            REP #$20
.3a7511	18		clc		                CLC
.3a7512	a5 0d		lda $0855	                LDA MARG1
.3a7514	69 01 00	adc #$0001	                ADC #1
.3a7517	85 0d		sta $0855	                STA MARG1
.3a7519	e2 20		sep #$20	            SEP #$20
.3a751b	a5 0e		lda $0856	                LDA MARG1+1
.3a751d	69 00		adc #$00	                ADC #0
.3a751f	85 0e		sta $0856	                STA MARG1+1
.3a7521	80 d0		bra $3a74f3	                BRA do_copy
.3a7523					IMTRANSFER
.3a7523	08		php		                PHP
.3a7524	0b		phd		                PHD
.3a7525	08		php		            PHP
.3a7526	c2 20		rep #$20	            REP #$20
.3a7528	48		pha		            PHA
.3a7529	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a752c	5b		tcd		            TCD
.3a752d	68		pla		            PLA
.3a752e	28		plp		            PLP
.3a752f	e2 20		sep #$20	            SEP #$20
.3a7531	a5 0f		lda $0857	                LDA MARG1+2
.3a7533	c5 17		cmp $085f	                CMP MARG3+2
.3a7535	90 45		bcc $3a757c	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.3a7537	c2 20		rep #$20	            REP #$20
.3a7539	a5 0d		lda $0855	                LDA MARG1
.3a753b	c5 15		cmp $085d	                CMP MARG3
.3a753d	90 3d		bcc $3a757c	                BLT copy_up         ; If MARG1 < MARG3, we are copying up
.3a753f					copy_byte_down
.3a753f	e2 20		sep #$20	            SEP #$20
.3a7541	a7 0d		lda [$0855]	                LDA [MARG1]         ; Copy the byte
.3a7543	87 15		sta [$085d]	                STA [MARG3]
.3a7545	a5 0f		lda $0857	                LDA MARG1+2         ; Are the source's current and end bank bytes equal?
.3a7547	c5 13		cmp $085b	                CMP MARG2+2
.3a7549	d0 0b		bne $3a7556	                BNE inc_pointers    ; No: we're not done yet
.3a754b	c2 20		rep #$20	            REP #$20
.3a754d	a5 0d		lda $0855	                LDA MARG1           ; Are the rest of the bits equal?
.3a754f	c5 11		cmp $0859	                CMP MARG2
.3a7551	d0 03		bne $3a7556	                BNE inc_pointers    ; No: we're not done yet
.3a7553	4c da 75	jmp $3a75da	                JMP done            ; Yes: we've copied the last byte, exit
.3a7556					inc_pointers
.3a7556	c2 20		rep #$20	            REP #$20
.3a7558	18		clc		                CLC
.3a7559	a5 0d		lda $0855	                LDA MARG1
.3a755b	69 01 00	adc #$0001	                ADC #1
.3a755e	85 0d		sta $0855	                STA MARG1
.3a7560	e2 20		sep #$20	            SEP #$20
.3a7562	a5 0e		lda $0856	                LDA MARG1+1
.3a7564	69 00		adc #$00	                ADC #0
.3a7566	85 0e		sta $0856	                STA MARG1+1
.3a7568	c2 20		rep #$20	            REP #$20
.3a756a	18		clc		                CLC
.3a756b	a5 15		lda $085d	                LDA MARG3
.3a756d	69 01 00	adc #$0001	                ADC #1
.3a7570	85 15		sta $085d	                STA MARG3
.3a7572	e2 20		sep #$20	            SEP #$20
.3a7574	a5 16		lda $085e	                LDA MARG3+1
.3a7576	69 00		adc #$00	                ADC #0
.3a7578	85 16		sta $085e	                STA MARG3+1
.3a757a	80 c3		bra $3a753f	                BRA copy_byte_down  ; And copy that next byte over
.3a757c					copy_up
.3a757c	c2 20		rep #$20	            REP #$20
.3a757e	38		sec		                SEC
.3a757f	a5 11		lda $0859	                LDA MARG2
.3a7581	e5 0d		sbc $0855	                SBC MARG1
.3a7583	85 19		sta $0861	                STA MARG4
.3a7585	e2 20		sep #$20	            SEP #$20
.3a7587	a5 13		lda $085b	                LDA MARG2+2
.3a7589	e5 0f		sbc $0857	                SBC MARG1+2
.3a758b	85 1b		sta $0863	                STA MARG4+2
.3a758d	c2 20		rep #$20	            REP #$20
.3a758f	18		clc		                CLC
.3a7590	a5 19		lda $0861	                LDA MARG4
.3a7592	65 15		adc $085d	                ADC MARG3
.3a7594	85 15		sta $085d	                STA MARG3
.3a7596	e2 20		sep #$20	            SEP #$20
.3a7598	a5 1b		lda $0863	                LDA MARG4+2
.3a759a	65 17		adc $085f	                ADC MARG3+2
.3a759c	85 17		sta $085f	                STA MARG3+2
.3a759e					copy_byte_up
.3a759e	e2 20		sep #$20	            SEP #$20
.3a75a0	a7 11		lda [$0859]	                LDA [MARG2]
.3a75a2	87 15		sta [$085d]	                STA [MARG3]
.3a75a4	a5 13		lda $085b	                LDA MARG2+2         ; Are the source's current and start bank bytes equal?
.3a75a6	c5 0f		cmp $0857	                CMP MARG1+2
.3a75a8	d0 0a		bne $3a75b4	                BNE dec_pointers    ; No: we're not done yet
.3a75aa	c2 20		rep #$20	            REP #$20
.3a75ac	a5 11		lda $0859	                LDA MARG2           ; Are the rest of the bits equal?
.3a75ae	c5 0d		cmp $0855	                CMP MARG1
.3a75b0	d0 02		bne $3a75b4	                BNE dec_pointers    ; No: we're not done yet
.3a75b2	80 26		bra $3a75da	                BRA done            ; Yes: we've copied the last byte, exit
.3a75b4					dec_pointers
.3a75b4	c2 20		rep #$20	            REP #$20
.3a75b6	38		sec		                SEC
.3a75b7	a5 11		lda $0859	                LDA MARG2
.3a75b9	e9 01 00	sbc #$0001	                SBC #1
.3a75bc	85 11		sta $0859	                STA MARG2
.3a75be	e2 20		sep #$20	            SEP #$20
.3a75c0	a5 12		lda $085a	                LDA MARG2+1
.3a75c2	e9 00		sbc #$00	                SBC #0
.3a75c4	85 12		sta $085a	                STA MARG2+1
.3a75c6	c2 20		rep #$20	            REP #$20
.3a75c8	38		sec		                SEC                 ; Decrement the current destination pointer (MARG3)
.3a75c9	a5 15		lda $085d	                LDA MARG3
.3a75cb	e9 01 00	sbc #$0001	                SBC #1
.3a75ce	85 15		sta $085d	                STA MARG3
.3a75d0	e2 20		sep #$20	            SEP #$20
.3a75d2	a5 16		lda $085e	                LDA MARG3+1
.3a75d4	e9 00		sbc #$00	                SBC #0
.3a75d6	85 16		sta $085e	                STA MARG3+1
.3a75d8	80 c4		bra $3a759e	                BRA copy_byte_up    ; And copy that next byte
.3a75da					done
.3a75da	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a75dd	2b		pld		                PLD
.3a75de	28		plp		                PLP
.3a75df	6b		rtl		                RTL
.3a75e0					IS_PRINTABLE
.3a75e0	08		php		                PHP
.3a75e1	e2 20		sep #$20	            SEP #$20
.3a75e3	c9 21		cmp #$21	                CMP #33
.3a75e5	90 0b		bcc $3a75f2	                BLT not_printable   ; 0 .. 31 are not printable
.3a75e7	c9 7f		cmp #$7f	                CMP #127
.3a75e9	90 04		bcc $3a75ef	                BLT printable       ; 32 .. 126 are printable
.3a75eb	c9 a0		cmp #$a0	                CMP #160
.3a75ed	90 03		bcc $3a75f2	                BLT not_printable   ; 127 .. 159 are not printable (assuming Latin-1)
.3a75ef	28		plp		printable       PLP
.3a75f0	38		sec		                SEC
.3a75f1	6b		rtl		                RTL
.3a75f2	28		plp		not_printable   PLP
.3a75f3	18		clc		                CLC
.3a75f4	6b		rtl		                RTL
=256					MMEMDUMPSIZE = 256  ; Default number of bytes to dump
=8					MMEMROWSIZE = 8    ; Number of bytes to dump per-row
.3a75f5					IMMEMORY
.3a75f5	08		php		                PHP
.3a75f6	8b		phb		                PHB
.3a75f7	0b		phd		                PHD
.3a75f8	08		php		            PHP
.3a75f9	c2 20		rep #$20	            REP #$20
.3a75fb	48		pha		            PHA
.3a75fc	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a75ff	5b		tcd		            TCD
.3a7600	68		pla		            PLA
.3a7601	28		plp		            PLP
.3a7602	e2 20		sep #$20	            SEP #$20
.3a7604	a9 00		lda #$00	                LDA #0              ; Clear the pagination line counter
.3a7606	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT
.3a760a	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.3a760c	c9 02		cmp #$02	                CMP #2
.3a760e	b0 16		bcs $3a7626	                BGE set_cursor      ; 2>= arguments? Use them as-is
.3a7610	c9 01		cmp #$01	                CMP #1
.3a7612	90 20		bcc $3a7634	                BLT no_args         ; No arguments passed? Use defaults
.3a7614	c2 20		rep #$20	            REP #$20
.3a7616	18		clc		                CLC
.3a7617	a5 0d		lda $0855	                LDA MARG1
.3a7619	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.3a761c	85 11		sta $0859	                STA MARG2
.3a761e	e2 20		sep #$20	            SEP #$20
.3a7620	a5 0f		lda $0857	                LDA MARG1+2
.3a7622	69 00		adc #$00	                ADC #0
.3a7624	85 13		sta $085b	                STA MARG2+2
.3a7626					set_cursor
.3a7626	c2 20		rep #$20	            REP #$20
.3a7628	a5 0d		lda $0855	                LDA MARG1
.3a762a	85 32		sta $087a	                STA MCURSOR
.3a762c	e2 20		sep #$20	            SEP #$20
.3a762e	a5 0f		lda $0857	                LDA MARG1+2
.3a7630	85 34		sta $087c	                STA MCURSOR+2
.3a7632	80 12		bra $3a7646	                BRA dump_line
.3a7634					no_args
.3a7634	c2 20		rep #$20	            REP #$20
.3a7636	18		clc		                CLC
.3a7637	a5 32		lda $087a	                LDA MCURSOR
.3a7639	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.3a763c	85 11		sta $0859	                STA MARG2
.3a763e	e2 20		sep #$20	            SEP #$20
.3a7640	a5 34		lda $087c	                LDA MCURSOR+2
.3a7642	69 00		adc #$00	                ADC #0
.3a7644	85 13		sta $085b	                STA MARG2+2
.3a7646					dump_line
.3a7646	e2 20		sep #$20	            SEP #$20
.3a7648	a0 00 00	ldy #$0000	                LDY #0
.3a764b	c2 20		rep #$20	            REP #$20
.3a764d	a5 32		lda $087a	                LDA MCURSOR             ; NOTE: the use of MARG4 here is a temporary
.3a764f	85 19		sta $0861	                STA MARG4               ; hack. the copy_loop instruction does not
.3a7651	e2 20		sep #$20	            SEP #$20
.3a7653	a5 34		lda $087c	                LDA MCURSOR+2
.3a7655	85 1b		sta $0863	                STA MARG4+2
.3a7657	e2 20		sep #$20	            SEP #$20
.3a7659	a7 19		lda [$0861]	copy_loop       LDA [MARG4]             ; TODO: Should be LDA [MCURSOR],Y, which doesn't seem to be working
.3a765b	22 e0 75 3a	jsl $3a75e0	                JSL IS_PRINTABLE        ; Is it printable?
.3a765f	b0 02		bcs $3a7663	                BCS buffer_char         ; Yes: go ahead and add it to the line buffer
.3a7661	a9 3f		lda #$3f	                LDA #'?'                ; No: replace it with dot
.3a7663	99 7e 08	sta $087e,y	buffer_char     STA #MLINEBUF,B,Y
.3a7666	c2 20		rep #$20	            REP #$20
.3a7668	18		clc		                CLC
.3a7669	a5 19		lda $0861	                LDA MARG4
.3a766b	69 01 00	adc #$0001	                ADC #1
.3a766e	85 19		sta $0861	                STA MARG4
.3a7670	e2 20		sep #$20	            SEP #$20
.3a7672	a5 1b		lda $0863	                LDA MARG4+2
.3a7674	69 00		adc #$00	                ADC #0
.3a7676	85 1b		sta $0863	                STA MARG4+2
.3a7678	c8		iny		                INY
.3a7679	c0 08 00	cpy #$0008	                CPY #MMEMROWSIZE
.3a767c	90 db		bcc $3a7659	                BLT copy_loop
.3a767e	a9 00		lda #$00	                LDA #0
.3a7680	99 7e 08	sta $087e,y	                STA #MLINEBUF,B,Y
.3a7683	a9 3e		lda #$3e	                LDA #'>'
.3a7685	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7688	a9 20		lda #$20	                LDA #' '
.3a768a	20 18 00	jsr $3a0018	            JSR PRINTC
.3a768d	e2 20		sep #$20	            SEP #$20
.3a768f	a5 34		lda $087c	                LDA MCURSOR+2
.3a7691	20 8e 04	jsr $3a048e	            JSR PRHEXB
.3a7694	a9 3a		lda #$3a	                LDA #':'                ; then a colon
.3a7696	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7699	c2 20		rep #$20	            REP #$20
.3a769b	a5 32		lda $087a	                LDA MCURSOR
.3a769d	20 74 04	jsr $3a0474	            JSR PRHEXW
.3a76a0	c2 20		rep #$20	            REP #$20
.3a76a2	a9 08 00	lda #$0008	                LDA #MMEMROWSIZE
.3a76a5	85 47		sta $088f	                STA MCOUNT
.3a76a7					prhex_loop
.3a76a7	e2 20		sep #$20	            SEP #$20
.3a76a9	a9 20		lda #$20	                LDA #' '
.3a76ab	20 18 00	jsr $3a0018	            JSR PRINTC
.3a76ae	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a76b0	20 8e 04	jsr $3a048e	            JSR PRHEXB
.3a76b3	22 22 87 3a	jsl $3a8722	                JSL M_INC_CURSOR        ; Point MCURSOR to the next byte
.3a76b7					check_line
.3a76b7	e2 20		sep #$20	            SEP #$20
.3a76b9	c6 47		dec $088f	                DEC MCOUNT              ; Count down the number of bytes on the row
.3a76bb	d0 ea		bne $3a76a7	                BNE prhex_loop          ; If we're not at zero, keep looping over the bytes
.3a76bd	a9 20		lda #$20	                LDA #' '
.3a76bf	20 18 00	jsr $3a0018	            JSR PRINTC
.3a76c2	a9 20		lda #$20	                LDA #' '
.3a76c4	20 18 00	jsr $3a0018	            JSR PRINTC
.3a76c7	08		php		            PHP
.3a76c8	e2 20		sep #$20	            SEP #$20
.3a76ca	48		pha		            PHA
.3a76cb	a9 00		lda #$00	            LDA #`MLINEBUF
.3a76cd	48		pha		            PHA
.3a76ce	ab		plb		            PLB
.3a76cf	68		pla		            PLA
.3a76d0	28		plp		            PLP
.3a76d1	a2 7e 08	ldx #$087e	                LDX #MLINEBUF
.3a76d4	20 64 04	jsr $3a0464	            JSR PRINTS
.3a76d7	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a76da	20 ee 03	jsr $3a03ee	            JSR PAGINATE
.3a76dd	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.3a76df	c5 13		cmp $085b	                CMP MARG2+2
.3a76e1	90 0f		bcc $3a76f2	                BLT continue            ; No: continue
.3a76e3	c2 20		rep #$20	            REP #$20
.3a76e5	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.3a76e7	c5 11		cmp $0859	                CMP MARG2
.3a76e9	90 07		bcc $3a76f2	                BLT continue            ; Nope... keep going
.3a76eb					done
.3a76eb	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a76ee	2b		pld		                PLD
.3a76ef	ab		plb		                PLB
.3a76f0	28		plp		                PLP
.3a76f1	6b		rtl		                RTL
.3a76f2	4c 46 76	jmp $3a7646	continue        JMP dump_line
.3a76f5					M_COPY_ARGB
.3a76f5	08		php		                PHP
.3a76f6	8d 92 08	sta $0892	                STA MTEMP
.3a76f9	e2 20		sep #$20	            SEP #$20
.3a76fb	bd 00 00	lda $0000,x	loop            LDA #0,B,X
.3a76fe	99 00 00	sta $0000,y	                STA #0,B,Y      ; Copy the byte
.3a7701	ad 92 08	lda $0892	                LDA MTEMP       ; Check the count of characters remaining
.3a7704	f0 0a		beq $3a7710	                BEQ done        ; If it's 0, we're done
.3a7706	c8		iny		                INY             ; Point to the next destination byte
.3a7707	e8		inx		                INX             ; Point to the next source byte (skip three bytes)
.3a7708	e8		inx		                INX
.3a7709	e8		inx		                INX
.3a770a	e8		inx		                INX
.3a770b	ce 92 08	dec $0892	                DEC MTEMP       ; Count down and see if we're done
.3a770e	80 eb		bra $3a76fb	                BRA loop
.3a7710	28		plp		done            PLP
.3a7711	6b		rtl		                RTL
.3a7712					IMMODIFY
.3a7712	08		php		                PHP
.3a7713	0b		phd		                PHD
.3a7714	8b		phb		                PHB
.3a7715	08		php		            PHP
.3a7716	c2 20		rep #$20	            REP #$20
.3a7718	48		pha		            PHA
.3a7719	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a771c	5b		tcd		            TCD
.3a771d	68		pla		            PLA
.3a771e	28		plp		            PLP
.3a771f	08		php		            PHP
.3a7720	e2 20		sep #$20	            SEP #$20
.3a7722	48		pha		            PHA
.3a7723	a9 00		lda #$00	            LDA #0
.3a7725	48		pha		            PHA
.3a7726	ab		plb		            PLB
.3a7727	68		pla		            PLA
.3a7728	28		plp		            PLP
.3a7729	c2 30		rep #$30	            REP #$30
.3a772b	a5 0d		lda $0855	                LDA MARG1           ; Set MCURSOR to MARG1
.3a772d	85 32		sta $087a	                STA MCURSOR
.3a772f	a5 0f		lda $0857	                LDA MARG1+2
.3a7731	85 34		sta $087c	                STA MCURSOR+2
.3a7733	e2 20		sep #$20	            SEP #$20
.3a7735	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.3a7737	3a		dec a		                DEC A               ; (MARG_LEN - 1)
.3a7738	85 47		sta $088f	                STA MCOUNT
.3a773a	a2 59 08	ldx #$0859	                LDX #<>MARG2        ; Copy MCOUNT bytes from MARG2..MARG9
.3a773d	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF     ; to MLINEBUF
.3a7740	22 f5 76 3a	jsl $3a76f5	                JSL M_COPY_ARGB
.3a7744	a0 00 00	ldy #$0000	                LDY #0
.3a7747	b9 7e 08	lda $087e,y	loop            LDA MLINEBUF,Y      ; Copy the byte from the buffer
.3a774a	87 32		sta [$087a]	                STA [MCURSOR]       ; To the address indicated by MCURSOR
.3a774c	22 22 87 3a	jsl $3a8722	                JSL M_INC_CURSOR    ; Advance the cursor
.3a7750	c8		iny		                INY                 ; Go to the next buffered byte
.3a7751	c4 47		cpy $088f	                CPY MCOUNT          ; Did we just write the last one?
.3a7753	d0 f2		bne $3a7747	                BNE loop            ; No: continue writing
.3a7755	ab		plb		                PLB
.3a7756	2b		pld		                PLD
.3a7757	28		plp		                PLP
.3a7758	6b		rtl		                RTL
.3a7759					IMHUNT
.3a7759	08		php		                PHP
.3a775a	0b		phd		                PHD
.3a775b	8b		phb		                PHB
.3a775c	08		php		            PHP
.3a775d	c2 20		rep #$20	            REP #$20
.3a775f	48		pha		            PHA
.3a7760	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7763	5b		tcd		            TCD
.3a7764	68		pla		            PLA
.3a7765	28		plp		            PLP
.3a7766	08		php		            PHP
.3a7767	e2 20		sep #$20	            SEP #$20
.3a7769	48		pha		            PHA
.3a776a	a9 00		lda #$00	            LDA #0
.3a776c	48		pha		            PHA
.3a776d	ab		plb		            PLB
.3a776e	68		pla		            PLA
.3a776f	28		plp		            PLP
.3a7770	e2 20		sep #$20	            SEP #$20
.3a7772	c2 10		rep #$10	            REP #$10
.3a7774	a5 31		lda $0879	                LDA MARG_LEN        ; Set MCOUNT to the number of bytes in the pattern
.3a7776	3a		dec a		                DEC A               ; (MARG_LEN - 2)
.3a7777	3a		dec a		                DEC A
.3a7778	85 47		sta $088f	                STA MCOUNT
.3a777a	a2 5d 08	ldx #$085d	                LDX #<>MARG3
.3a777d	a0 7e 08	ldy #$087e	                LDY #<>MLINEBUF
.3a7780	22 f5 76 3a	jsl $3a76f5	                JSL M_COPY_ARGB
.3a7784	c2 20		rep #$20	            REP #$20
.3a7786	a5 0d		lda $0855	                LDA MARG1           ; Copy starting address to MCURSOR
.3a7788	85 32		sta $087a	                STA MCURSOR
.3a778a	a5 0f		lda $0857	                LDA MARG1+2
.3a778c	85 34		sta $087c	                STA MCURSOR+2
.3a778e					outer_loop
.3a778e	c2 20		rep #$20	            REP #$20
.3a7790	a5 34		lda $087c	                LDA MCURSOR+2      ; If MCURSOR < MARG2, we're not done yet
.3a7792	c5 13		cmp $085b	                CMP MARG2+2
.3a7794	d0 06		bne $3a779c	                BNE not_done
.3a7796	a5 32		lda $087a	                LDA MCURSOR
.3a7798	c5 11		cmp $0859	                CMP MARG2
.3a779a	f0 2c		beq $3a77c8	                BEQ done            ; MCURSOR = MARG2: we're done
.3a779c					not_done
.3a779c	e2 20		sep #$20	            SEP #$20
.3a779e	a0 00 00	ldy #$0000	                LDY #0
.3a77a1	b7 32		lda [$087a],y	cmp_loop        LDA [MCURSOR],Y     ; Get the byte from the memory to check
.3a77a3	d9 7e 08	cmp $087e,y	                CMP MLINEBUF,Y      ; Compare it against our pattern
.3a77a6	d0 1a		bne $3a77c2	                BNE advance         ; If not equal, we need to move on
.3a77a8	c8		iny		                INY                 ; Otherwise do we have more bytes to check?
.3a77a9	c4 47		cpy $088f	                CPY MCOUNT
.3a77ab	d0 f4		bne $3a77a1	                BNE cmp_loop        ; No: check more
.3a77ad	c2 20		rep #$20	            REP #$20
.3a77af	a5 32		lda $087a	                LDA MCURSOR         ; Print the address
.3a77b1	85 4a		sta $0892	                STA MTEMP
.3a77b3	a5 34		lda $087c	                LDA MCURSOR+2
.3a77b5	85 4c		sta $0894	                STA MTEMP+2
.3a77b7	22 cc 81 3a	jsl $3a81cc	                JSL M_PR_ADDR
.3a77bb	e2 20		sep #$20	            SEP #$20
.3a77bd	a9 20		lda #$20	                LDA #' '
.3a77bf	20 18 00	jsr $3a0018	            JSR PRINTC
.3a77c2	22 22 87 3a	jsl $3a8722	advance         JSL M_INC_CURSOR    ; Move MCURSOR forward by one
.3a77c6	80 c6		bra $3a778e	                BRA outer_loop      ; And try to compare that to the pattern
.3a77c8					done
.3a77c8	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a77cb	ab		plb		                PLB
.3a77cc	2b		pld		                PLD
.3a77cd	28		plp		                PLP
.3a77ce	6b		rtl		                RTL
.3a77cf					IMJUMP
.3a77cf	08		php		            PHP
.3a77d0	c2 20		rep #$20	            REP #$20
.3a77d2	48		pha		            PHA
.3a77d3	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a77d6	5b		tcd		            TCD
.3a77d7	68		pla		            PLA
.3a77d8	28		plp		            PLP
.3a77d9	e2 20		sep #$20	            SEP #$20
.3a77db	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.3a77dd	f0 0e		beq $3a77ed	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.3a77df	c2 30		rep #$30	            REP #$30
.3a77e1	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.3a77e3	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.3a77e7	a5 0f		lda $0857	                LDA MARG1+2
.3a77e9	8f 42 02 00	sta $000242	                STA @lCPUPBR
.3a77ed	af 46 02 00	lda $000246	MJUMPRESTORE    LDA @lCPUX          ; Restore X and Y
.3a77f1	aa		tax		                TAX
.3a77f2	af 48 02 00	lda $000248	                LDA @lCPUY
.3a77f6	a8		tay		                TAY
.3a77f7	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.3a77fb	1b		tcs		                TCS
.3a77fc	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.3a7800	5b		tcd		                TCD
.3a7801	e2 20		sep #$20	            SEP #$20
.3a7803	a9 3a		lda #$3a	                LDA #`MJUMPSTART
.3a7805	48		pha		                PHA
.3a7806	a9 78		lda #$78	                LDA #>MJUMPSTART
.3a7808	48		pha		                PHA
.3a7809	a9 0f		lda #$0f	                LDA #<MJUMPSTART
.3a780b	48		pha		                PHA
.3a780c	4c 46 78	jmp $3a7846	                JMP MGOSTACK        ; And push remaining registers and restart execution
.3a780f	ea		nop		MJUMPSTART      NOP                 ; RTL increments PC pulled from stack, NOP leaves space for that
.3a7810	5c 04 00 3a	jmp $3a0004	                JML MONITOR
.3a7814					IMGO
.3a7814	08		php		            PHP
.3a7815	c2 20		rep #$20	            REP #$20
.3a7817	48		pha		            PHA
.3a7818	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a781b	5b		tcd		            TCD
.3a781c	68		pla		            PLA
.3a781d	28		plp		            PLP
.3a781e	e2 20		sep #$20	            SEP #$20
.3a7820	a5 31		lda $0879	                LDA MARG_LEN        ; Check to see if an argument was provided
.3a7822	f0 c9		beq $3a77ed	                BEQ MJUMPRESTORE    ; If not, just restore the registers
.3a7824	c2 30		rep #$30	            REP #$30
.3a7826	a5 0d		lda $0855	                LDA MARG1           ; Otherwise, replace PC and K
.3a7828	8f 40 02 00	sta $000240	                STA @lCPUPC         ; With the value of the first argument
.3a782c	a5 0f		lda $0857	                LDA MARG1+2
.3a782e	8f 42 02 00	sta $000242	                STA @lCPUPBR
.3a7832	af 46 02 00	lda $000246	MGORESTORE      LDA @lCPUX          ; Restore X and Y
.3a7836	aa		tax		                TAX
.3a7837	af 48 02 00	lda $000248	                LDA @lCPUY
.3a783b	a8		tay		                TAY
.3a783c	af 4a 02 00	lda $00024a	                LDA @lCPUSTACK      ; Restore the stack pointer
.3a7840	1b		tcs		                TCS
.3a7841	af 4c 02 00	lda $00024c	                LDA @lCPUDP         ; Restore the direct page register
.3a7845	5b		tcd		                TCD
.3a7846					MGOSTACK
.3a7846	e2 20		sep #$20	            SEP #$20
.3a7848	af 4e 02 00	lda $00024e	                LDA @lCPUDBR        ; Restore the data bank register
.3a784c	48		pha		                PHA
.3a784d	ab		plb		                PLB
.3a784e	a9 5c		lda #$5c	                LDA #$5C            ; Save the JSL opcode
.3a7850	8f a2 08 00	sta $0008a2	                STA @lMJUMPINST
.3a7854	af 42 02 00	lda $000242	                LDA @lCPUPBR        ; Write PBR
.3a7858	8f a5 08 00	sta $0008a5	                STA @lMJUMPADDR+2
.3a785c	af 41 02 00	lda $000241	                LDA @lCPUPC+1       ; Write PCH
.3a7860	8f a4 08 00	sta $0008a4	                STA @lMJUMPADDR+1
.3a7864	af 40 02 00	lda $000240	                LDA @lCPUPC         ; Write PCL
.3a7868	8f a3 08 00	sta $0008a3	                STA @lMJUMPADDR
.3a786c	af 4f 02 00	lda $00024f	                LDA @lCPUFLAGS      ; Push processor status
.3a7870	48		pha		                PHA
.3a7871	c2 20		rep #$20	            REP #$20
.3a7873	af 44 02 00	lda $000244	                LDA @lCPUA          ; Restore A
.3a7877	28		plp		                PLP                 ; And the status register
.3a7878	5c a2 08 00	jmp $0008a2	                JML MJUMPINST       ; And jump to the target address
.3a787c					IMCOMPARE
.3a787c	08		php		                PHP
.3a787d	0b		phd		                PHD
.3a787e	8b		phb		                PHB
.3a787f	08		php		            PHP
.3a7880	e2 20		sep #$20	            SEP #$20
.3a7882	48		pha		            PHA
.3a7883	a9 3a		lda #$3a	            LDA #`MERRARGS
.3a7885	48		pha		            PHA
.3a7886	ab		plb		            PLB
.3a7887	68		pla		            PLA
.3a7888	28		plp		            PLP
.3a7889	08		php		            PHP
.3a788a	c2 20		rep #$20	            REP #$20
.3a788c	48		pha		            PHA
.3a788d	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a7890	5b		tcd		            TCD
.3a7891	68		pla		            PLA
.3a7892	28		plp		            PLP
.3a7893	c2 10		rep #$10	            REP #$10
.3a7895	e2 20		sep #$20	            SEP #$20
.3a7897	a5 31		lda $0879	                LDA MARG_LEN                ; Check the number of arguments provided
.3a7899	c9 02		cmp #$02	                CMP #2
.3a789b	f0 0c		beq $3a78a9	                BEQ default_len             ; If 2: set MCOUNT to default of 1
.3a789d	c9 03		cmp #$03	                CMP #3
.3a789f	d0 11		bne $3a78b2	                BNE bad_arguments           ; Otherwise, if not 3: print an error
.3a78a1	c2 20		rep #$20	            REP #$20
.3a78a3	a5 15		lda $085d	                LDA MARG3                   ; If 3: set MCOUNT to MARG3
.3a78a5	85 47		sta $088f	                STA MCOUNT
.3a78a7	80 11		bra $3a78ba	                BRA compare
.3a78a9					default_len
.3a78a9	c2 20		rep #$20	            REP #$20
.3a78ab	a9 01 00	lda #$0001	                LDA #1                      ; No length was provided, set MCOUNT to 1
.3a78ae	85 47		sta $088f	                STA MCOUNT
.3a78b0	80 08		bra $3a78ba	                BRA compare
.3a78b2	a2 ee 89	ldx #$89ee	bad_arguments   LDX #<>MERRARGS             ; The wrong number of arguments was provided
.3a78b5	20 64 04	jsr $3a0464	            JSR PRINTS
.3a78b8	80 35		bra $3a78ef	                BRA done
.3a78ba	a5 0d		lda $0855	compare         LDA MARG1                   ; Set MTEMP to MARG1
.3a78bc	85 4a		sta $0892	                STA MTEMP
.3a78be	a5 0f		lda $0857	                LDA MARG1+2
.3a78c0	85 4c		sta $0894	                STA MTEMP+2
.3a78c2	a0 00 00	ldy #$0000	                LDY #0
.3a78c5					loop
.3a78c5	e2 20		sep #$20	            SEP #$20
.3a78c7	a7 4a		lda [$0892]	                LDA [MTEMP]                 ; Compare the byte at MTEMP
.3a78c9	d7 11		cmp [$0859],y	                CMP [MARG2],Y               ; To the Yth byte from MARG2
.3a78cb	f0 09		beq $3a78d6	                BEQ continue                ; If they're the same, keep going
.3a78cd	22 cc 81 3a	jsl $3a81cc	mismatch        JSL M_PR_ADDR               ; If they're different, print MTEMP
.3a78d1	a9 20		lda #$20	                LDA #' '
.3a78d3	20 18 00	jsr $3a0018	            JSR PRINTC
.3a78d6					continue
.3a78d6	c2 20		rep #$20	            REP #$20
.3a78d8	18		clc		                CLC                         ; Either way, increment MTEMP
.3a78d9	a5 4a		lda $0892	                LDA MTEMP
.3a78db	69 01 00	adc #$0001	                ADC #1
.3a78de	85 4a		sta $0892	                STA MTEMP
.3a78e0	a5 4c		lda $0894	                LDA MTEMP+2
.3a78e2	69 00 00	adc #$0000	                ADC #0
.3a78e5	85 4c		sta $0894	                STA MTEMP+2
.3a78e7	c8		iny		                INY                         ; Increment Y
.3a78e8	c4 47		cpy $088f	                CPY MCOUNT                  ; Try again unless we've checked MCOUNT bytes
.3a78ea	d0 d9		bne $3a78c5	                BNE loop
.3a78ec	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a78ef					done
.3a78ef	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a78f2	ab		plb		                PLB
.3a78f3	2b		pld		                PLD
.3a78f4	28		plp		                PLP
.3a78f5	6b		rtl		                RTL
.3a78f6					IMRMODIFY
.3a78f6	08		php		                PHP
.3a78f7	0b		phd		                PHD
.3a78f8	8b		phb		                PHB
.3a78f9	08		php		            PHP
.3a78fa	e2 20		sep #$20	            SEP #$20
.3a78fc	48		pha		            PHA
.3a78fd	a9 00		lda #$00	            LDA #0
.3a78ff	48		pha		            PHA
.3a7900	ab		plb		            PLB
.3a7901	68		pla		            PLA
.3a7902	28		plp		            PLP
.3a7903	08		php		            PHP
.3a7904	c2 20		rep #$20	            REP #$20
.3a7906	48		pha		            PHA
.3a7907	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a790a	5b		tcd		            TCD
.3a790b	68		pla		            PLA
.3a790c	28		plp		            PLP
.3a790d	e2 20		sep #$20	            SEP #$20
.3a790f	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.3a7911	f0 4f		beq $3a7962	                BEQ done            ; 0? Just quit
.3a7913	a6 0d		ldx $0855	                LDX MARG1           ; Set the PC and PBR
.3a7915	8e 40 02	stx $0240	                STX #CPUPC,B
.3a7918	a6 0f		ldx $0857	                LDX MARG1+2
.3a791a	8e 42 02	stx $0242	                STX #CPUPBR,B
.3a791d	c9 01		cmp #$01	                CMP #1              ; Check the number of arguments
.3a791f	f0 41		beq $3a7962	                BEQ done            ; 1? Just quit
.3a7921	a6 11		ldx $0859	                LDX MARG2           ; Set A
.3a7923	8e 44 02	stx $0244	                STX #CPUA,B
.3a7926	c9 02		cmp #$02	                CMP #2              ; Check the number of arguments
.3a7928	f0 38		beq $3a7962	                BEQ done            ; 2? Just quit
.3a792a	a6 15		ldx $085d	                LDX MARG3           ; Set X
.3a792c	8e 46 02	stx $0246	                STX #CPUX,B
.3a792f	c9 03		cmp #$03	                CMP #3              ; Check the number of arguments
.3a7931	f0 2f		beq $3a7962	                BEQ done            ; 3? Just quit
.3a7933	a6 19		ldx $0861	                LDX MARG4           ; Set Y
.3a7935	8e 48 02	stx $0248	                STX #CPUY,B
.3a7938	c9 04		cmp #$04	                CMP #4              ; Check the number of arguments
.3a793a	f0 26		beq $3a7962	                BEQ done            ; 4? Just quit
.3a793c	a6 1d		ldx $0865	                LDX MARG5           ; Set SP
.3a793e	8e 4a 02	stx $024a	                STX #CPUSTACK,B
.3a7941	c9 05		cmp #$05	                CMP #5              ; Check the number of arguments
.3a7943	f0 1d		beq $3a7962	                BEQ done            ; 5? Just quit
.3a7945	e2 10		sep #$10	            SEP #$10
.3a7947	a6 21		ldx $0869	                LDX MARG6           ; Set DBR
.3a7949	8e 4e 02	stx $024e	                STX #CPUDBR,B
.3a794c	c9 06		cmp #$06	                CMP #6              ; Check the number of arguments
.3a794e	f0 12		beq $3a7962	                BEQ done            ; 6? Just quit
.3a7950	c2 10		rep #$10	            REP #$10
.3a7952	a6 25		ldx $086d	                LDX MARG7           ; Set DP
.3a7954	8e 4c 02	stx $024c	                STX #CPUDP,B
.3a7957	c9 07		cmp #$07	                CMP #7              ; Check the number of arguments
.3a7959	f0 07		beq $3a7962	                BEQ done            ; 7? Just quit
.3a795b	e2 10		sep #$10	            SEP #$10
.3a795d	a6 29		ldx $0871	                LDX MARG8           ; Set flags
.3a795f	8e 4f 02	stx $024f	                STX #CPUFLAGS,B
.3a7962	ab		plb		done            PLB
.3a7963	2b		pld		                PLD
.3a7964	28		plp		                PLP
.3a7965	6b		rtl		                RTL
.3a7966					IMEXECUTE
.3a7966	08		php		                PHP
.3a7967	0b		phd		                PHD
.3a7968	8b		phb		                PHB
.3a7969	08		php		            PHP
.3a796a	c2 20		rep #$20	            REP #$20
.3a796c	48		pha		            PHA
.3a796d	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7970	5b		tcd		            TCD
.3a7971	68		pla		            PLA
.3a7972	28		plp		            PLP
.3a7973	e2 20		sep #$20	            SEP #$20
.3a7975	c2 10		rep #$10	            REP #$10
.3a7977	a2 00 00	ldx #$0000	                LDX #0
.3a797a	bf 5b 8a 3a	lda $3a8a5b,x	loop            LDA @lMCOMMANDS,X
.3a797e	f0 18		beq $3a7998	                BEQ done
.3a7980	c7 08		cmp [$0850]	                CMP [MCMD]
.3a7982	f0 03		beq $3a7987	                BEQ found
.3a7984	e8		inx		                INX
.3a7985	80 f3		bra $3a797a	                BRA loop
.3a7987					found
.3a7987	c2 20		rep #$20	            REP #$20
.3a7989	8a		txa		                TXA
.3a798a	0a		asl a		                ASL A
.3a798b	aa		tax		                TAX
.3a798c	bf 9c 79 3a	lda $3a799c,x	                LDA dispatch,X
.3a7990	8f 2f 08 00	sta $00082f	                STA @lJMP16PTR
.3a7994	22 c0 79 3a	jsl $3a79c0	                JSL MDOCMD
.3a7998	ab		plb		done            PLB
.3a7999	2b		pld		                PLD
.3a799a	28		plp		                PLP
.3a799b	6b		rtl		                RTL
>3a799c	3c 70				dispatch        .word <>MASSEMBLE
>3a799e	44 70				                .word <>MCOMPARE
>3a79a0	48 70				                .word <>MDISASSEMBLE
>3a79a2	4c 70				                .word <>MFILL
>3a79a4	50 70				                .word <>MGO
>3a79a6	54 70				                .word <>MJUMP
>3a79a8	58 70				                .word <>MHUNT
>3a79aa	5c 70				                .word <>MLOAD
>3a79ac	60 70				                .word <>MMEMORY
>3a79ae	64 70				                .word <>MREGISTERS
>3a79b0	40 70				                .word <>MRMODIFY
>3a79b2	68 70				                .word <>MSAVE
>3a79b4	6c 70				                .word <>MTRANSFER
>3a79b6	70 70				                .word <>MVERIFY
>3a79b8	32 74				                .word <>IMWIDTH
>3a79ba	74 70				                .word <>MEXIT
>3a79bc	78 70				                .word <>MMODIFY
>3a79be	ab 70				                .word <>IMHELP
.3a79c0					MDOCMD
.3a79c0	6c 2f 08	jmp ($082f)	                JMP (JMP16PTR)

;******  Processing file: src\assembler.s

=0					ADDR_DP_IND_X = 0       ; (dd,X)
=1					ADDR_DP = 1             ; dd
=2					ADDR_IMM = 2            ; #dd
=3					ADDR_ABS = 3            ; dddd
=4					ADDR_DP_IND_Y = 4       ; (dd),Y
=5					ADDR_DP_X = 5           ; dd,X
=6					ADDR_ABS_Y = 6          ; dddd,Y
=7					ADDR_ABS_X = 7          ; dddd,X
=8					ADDR_ACC = 8            ; A
=9					ADDR_SP_R = 9           ; #d,S
=10					ADDR_DP_LONG = 10       ; [dd]
=11					ADDR_ABS_LONG = 11      ; dddddd
=12					ADDR_SP_R_Y = 12        ; #dd,S,Y
=13					ADDR_DP_Y_LONG = 13     ; [dd],Y
=14					ADDR_ABS_X_LONG = 14    ; dddddd,X
=15					ADDR_DP_IND = 15        ; (dd)
=16					ADDR_ABS_X_ID = 16      ; (dddd,X)
=17					ADDR_DP_Y = 17          ; dd,Y
=18					ADDR_PC_REL = 18        ; PC relative
=19					ADDR_IMPLIED = 19       ; Implied (no operand)
=20					ADDR_XYC = 20           ; #dd, #dd
=21					ADDR_ABS_IND = 21       ; (dddd)
=22					ADDR_PC_REL_LONG = 22   ; PC relative ()
=23					ADDR_ABS_IND_LONG = 23  ; [dddd]
=$80					OP_M_EFFECT = $80       ; Flag to indicate instruction is modified by M
=$40					OP_X_EFFECT = $40       ; Flag to indicate instruction is modified by X
.3a79c3					IMASSEMBLE
.3a79c3	08		php		                PHP
.3a79c4	8b		phb		                PHB
.3a79c5	0b		phd		                PHD
.3a79c6	08		php		            PHP
.3a79c7	c2 20		rep #$20	            REP #$20
.3a79c9	48		pha		            PHA
.3a79ca	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a79cd	5b		tcd		            TCD
.3a79ce	68		pla		            PLA
.3a79cf	28		plp		            PLP
.3a79d0	e2 20		sep #$20	            SEP #$20
.3a79d2	a5 31		lda $0879	                LDA MARG_LEN            ; Do we have at least 2 arguments?
.3a79d4	c9 02		cmp #$02	                CMP #2
.3a79d6	b0 03		bcs $3a79db	                BGE has_args            ; Yes: try to assemble the line
.3a79d8	4c 69 7b	jmp $3a7b69	                JMP done                ; No: just return
.3a79db					has_args
.3a79db	c2 20		rep #$20	            REP #$20
.3a79dd	a5 0d		lda $0855	                LDA MARG1               ; Set the monitor cursor to the address
.3a79df	85 32		sta $087a	                STA MCURSOR
.3a79e1	a5 0f		lda $0857	                LDA MARG1+2
.3a79e3	85 34		sta $087c	                STA MCURSOR+2
.3a79e5	c2 20		rep #$20	            REP #$20
.3a79e7	22 6b 7d 3a	jsl $3a7d6b	                JSL AS_FIND_MNEMO       ; Find the address of the mnemonic
.3a79eb	c9 ff ff	cmp #$ffff	                CMP #$FFFF
.3a79ee	f0 10		beq $3a7a00	                BEQ bad_mnemonic        ; If not found, print bad mnemonic error message
.3a79f0	85 54		sta $089c	                STA MMNEMONIC
.3a79f2	e2 20		sep #$20	            SEP #$20
.3a79f4	a5 31		lda $0879	                LDA MARG_LEN            ; Check the number of arguments passed
.3a79f6	c9 03		cmp #$03	                CMP #3                  ; Were all three arguments provided?
.3a79f8	f0 36		beq $3a7a30	                BEQ get_operand         ; Yes: parse the operand
.3a79fa	a9 13		lda #$13	                LDA #ADDR_IMPLIED       ; No: assume address mode is implied
.3a79fc	85 4f		sta $0897	                STA MADDR_MODE
.3a79fe	80 4c		bra $3a7a4c	                BRA get_opcode
.3a7a00					bad_mnemonic
.3a7a00	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a7a03	08		php		            PHP
.3a7a04	e2 20		sep #$20	            SEP #$20
.3a7a06	48		pha		            PHA
.3a7a07	a9 3a		lda #$3a	            LDA #`MERRBADMNEMO
.3a7a09	48		pha		            PHA
.3a7a0a	ab		plb		            PLB
.3a7a0b	68		pla		            PLA
.3a7a0c	28		plp		            PLP
.3a7a0d	c2 10		rep #$10	            REP #$10
.3a7a0f	a2 a0 7b	ldx #$7ba0	                LDX #<>MERRBADMNEMO
.3a7a12	20 64 04	jsr $3a0464	            JSR PRINTS
.3a7a15	4c 69 7b	jmp $3a7b69	                JMP done
.3a7a18					bad_operand
.3a7a18	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a7a1b	08		php		            PHP
.3a7a1c	e2 20		sep #$20	            SEP #$20
.3a7a1e	48		pha		            PHA
.3a7a1f	a9 3a		lda #$3a	            LDA #`MERRBADOPER
.3a7a21	48		pha		            PHA
.3a7a22	ab		plb		            PLB
.3a7a23	68		pla		            PLA
.3a7a24	28		plp		            PLP
.3a7a25	c2 10		rep #$10	            REP #$10
.3a7a27	a2 af 7b	ldx #$7baf	                LDX #<>MERRBADOPER
.3a7a2a	20 64 04	jsr $3a0464	            JSR PRINTS
.3a7a2d	4c 69 7b	jmp $3a7b69	                JMP done
.3a7a30					get_operand
.3a7a30	e2 20		sep #$20	            SEP #$20
.3a7a32	22 a1 7d 3a	jsl $3a7da1	                JSL AS_FIND_MODE        ; Find the addressing mode of the operand
.3a7a36	c9 ff		cmp #$ff	compare         CMP #$FF
.3a7a38	f0 de		beq $3a7a18	                BEQ bad_operand         ; If not found, print bad operand error message
.3a7a3a	85 4f		sta $0897	                STA MADDR_MODE
.3a7a3c	c9 03		cmp #$03	                CMP #ADDR_ABS           ; If mode is absolute or absolute long...
.3a7a3e	f0 62		beq $3a7aa2	                BEQ check_for_pcrel     ; Check to see if the mnemonic is one of the branches
.3a7a40	c9 0b		cmp #$0b	                CMP #ADDR_ABS_LONG
.3a7a42	f0 5e		beq $3a7aa2	                BEQ check_for_pcrel
.3a7a44	c9 13		cmp #$13	                CMP #ADDR_IMPLIED       ; If mode is implied or accumulator, get the opcode
.3a7a46	f0 04		beq $3a7a4c	                BEQ get_opcode
.3a7a48	c9 08		cmp #$08	                CMP #ADDR_ACC
.3a7a4a	f0 00		beq $3a7a4c	                BEQ get_opcode
.3a7a4c	22 99 7c 3a	jsl $3a7c99	get_opcode      JSL AS_FIND_OPCODE      ; Find the opcode matching the two
.3a7a50	b0 03		bcs $3a7a55	                BCS save_opcode
.3a7a52	4c 32 7b	jmp $3a7b32	                JMP bad_mode            ; If opcode not found, print bad address mode error message
.3a7a55	87 32		sta [$087a]	save_opcode     STA [MCURSOR]           ; Write the opcode to the address
.3a7a57	22 22 87 3a	jsl $3a8722	                JSL M_INC_CURSOR        ; And point to the next byte
.3a7a5b	08		php		            PHP
.3a7a5c	e2 20		sep #$20	            SEP #$20
.3a7a5e	48		pha		            PHA
.3a7a5f	a9 00		lda #$00	            LDA #0
.3a7a61	48		pha		            PHA
.3a7a62	ab		plb		            PLB
.3a7a63	68		pla		            PLA
.3a7a64	28		plp		            PLP
.3a7a65	c2 20		rep #$20	            REP #$20
.3a7a67	a5 32		lda $087a	                LDA MCURSOR             ; Make MTEMPPTR a pointer to the machine code we're assembling
.3a7a69	85 56		sta $089e	                STA MTEMPPTR
.3a7a6b	a5 34		lda $087c	                LDA MCURSOR+2
.3a7a6d	85 58		sta $08a0	                STA MTEMPPTR+2
.3a7a6f	e2 20		sep #$20	            SEP #$20
.3a7a71	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check the address mode again
.3a7a73	c9 12		cmp #$12	                CMP #ADDR_PC_REL        ; If it's PC relative
.3a7a75	f0 6c		beq $3a7ae3	                BEQ compute_rel         ; Convert the address to an offset
.3a7a77	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.3a7a79	f0 68		beq $3a7ae3	                BEQ compute_rel
.3a7a7b	c9 14		cmp #$14	                CMP #ADDR_XYC           ; MVP/MVN addressing mode?
.3a7a7d	f0 7c		beq $3a7afb	                BEQ emit_2
.3a7a7f	29 3f		and #$3f	                AND #%00111111          ; Filter out the mode bits
.3a7a81	c9 02		cmp #$02	                CMP #ADDR_IMM           ; Is it immediate?
.3a7a83	d0 03		bne $3a7a88	                BNE fixed_length        ; Yes: emit it as an immediate (variable length)
.3a7a85	4c 60 7b	jmp $3a7b60	                JMP emit_imm
.3a7a88					fixed_length
.3a7a88	c2 20		rep #$20	            REP #$20
.3a7a8a	29 ff 00	and #$00ff	                AND #$00FF
.3a7a8d	aa		tax		                TAX
.3a7a8e	e2 20		sep #$20	            SEP #$20
.3a7a90	bf 68 86 3a	lda $3a8668,x	get_length      LDA ADDR_LENGTH,X       ; Get the number of bytes in the addressing mode
.3a7a94	c9 03		cmp #$03	                CMP #$03
.3a7a96	f0 57		beq $3a7aef	                BEQ emit_3
.3a7a98	c9 02		cmp #$02	                CMP #$02
.3a7a9a	f0 5f		beq $3a7afb	                BEQ emit_2
.3a7a9c	c9 01		cmp #$01	                CMP #$01
.3a7a9e	f0 67		beq $3a7b07	                BEQ emit_1
.3a7aa0	80 71		bra $3a7b13	                BRA next_line
.3a7aa2					check_for_pcrel
.3a7aa2	c2 20		rep #$20	            REP #$20
.3a7aa4	a5 54		lda $089c	                LDA MMNEMONIC
.3a7aa6	c9 e0 82	cmp #$82e0	                CMP #<>MN_BRA
.3a7aa9	f0 26		beq $3a7ad1	                BEQ is_pcrel
.3a7aab	c9 44 83	cmp #$8344	                CMP #<>MN_BRL
.3a7aae	f0 2a		beq $3a7ada	                BEQ is_pcrel_long
.3a7ab0	c9 c4 82	cmp #$82c4	                CMP #<>MN_BCC
.3a7ab3	f0 1c		beq $3a7ad1	                BEQ is_pcrel
.3a7ab5	c9 c8 82	cmp #$82c8	                CMP #<>MN_BCS
.3a7ab8	f0 17		beq $3a7ad1	                BEQ is_pcrel
.3a7aba	c9 d0 82	cmp #$82d0	                CMP #<>MN_BEQ
.3a7abd	f0 12		beq $3a7ad1	                BEQ is_pcrel
.3a7abf	c9 b8 82	cmp #$82b8	                CMP #<>MN_BMI
.3a7ac2	f0 0d		beq $3a7ad1	                BEQ is_pcrel
.3a7ac4	c9 cc 82	cmp #$82cc	                CMP #<>MN_BNE
.3a7ac7	f0 08		beq $3a7ad1	                BEQ is_pcrel
.3a7ac9	c9 b4 82	cmp #$82b4	                CMP #<>MN_BPL
.3a7acc	f0 03		beq $3a7ad1	                BEQ is_pcrel
.3a7ace	4c 4c 7a	jmp $3a7a4c	                JMP get_opcode
.3a7ad1					is_pcrel
.3a7ad1	e2 20		sep #$20	            SEP #$20
.3a7ad3	a9 12		lda #$12	                LDA #ADDR_PC_REL
.3a7ad5	85 4f		sta $0897	                STA MADDR_MODE
.3a7ad7	4c 4c 7a	jmp $3a7a4c	                JMP get_opcode
.3a7ada					is_pcrel_long
.3a7ada	e2 20		sep #$20	            SEP #$20
.3a7adc	a9 16		lda #$16	                LDA #ADDR_PC_REL_LONG
.3a7ade	85 4f		sta $0897	                STA MADDR_MODE
.3a7ae0	4c 4c 7a	jmp $3a7a4c	                JMP get_opcode
.3a7ae3	22 dc 7b 3a	jsl $3a7bdc	compute_rel     JSL AS_PC_OFFSET        ; Try to compute the offset
.3a7ae7	90 60		bcc $3a7b49	                BCC bad_offset          ; If failed, it's a bad offset operand
.3a7ae9	c9 02		cmp #$02	emit_rel        CMP #$02                ; If the offset is two bytes
.3a7aeb	f0 0e		beq $3a7afb	                BEQ emit_2              ; Emit those two bytes
.3a7aed	80 18		bra $3a7b07	                BRA emit_1              ; Otherwise emit just the one
.3a7aef	a0 02 00	ldy #$0002	emit_3          LDY #2                  ; Write bank byte of operand
.3a7af2	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.3a7af5	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.3a7af7	22 22 87 3a	jsl $3a8722	                JSL M_INC_CURSOR
.3a7afb	a0 01 00	ldy #$0001	emit_2          LDY #1                  ; Write high byte of operand
.3a7afe	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.3a7b01	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.3a7b03	22 22 87 3a	jsl $3a8722	                JSL M_INC_CURSOR
.3a7b07	a0 00 00	ldy #$0000	emit_1          LDY #0                  ; Write low byte of operand
.3a7b0a	b9 98 08	lda $0898,y	                LDA MPARSEDNUM,Y
.3a7b0d	97 56		sta [$089e],y	                STA [MTEMPPTR],Y
.3a7b0f	22 22 87 3a	jsl $3a8722	                JSL M_INC_CURSOR
.3a7b13					next_line
.3a7b13	e2 20		sep #$20	            SEP #$20
.3a7b15	a9 41		lda #$41	                LDA #'A'
.3a7b17	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7b1a	a9 20		lda #$20	                LDA #' '
.3a7b1c	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7b1f	a6 32		ldx $087a	                LDX MCURSOR
.3a7b21	86 4a		stx $0892	                STX MTEMP
.3a7b23	a6 34		ldx $087c	                LDX MCURSOR+2
.3a7b25	86 4c		stx $0894	                STX MTEMP+2
.3a7b27	22 cc 81 3a	jsl $3a81cc	                JSL M_PR_ADDR
.3a7b2b	a9 20		lda #$20	                LDA #' '
.3a7b2d	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7b30	80 37		bra $3a7b69	                BRA done
.3a7b32					bad_mode
.3a7b32	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a7b35	08		php		            PHP
.3a7b36	e2 20		sep #$20	            SEP #$20
.3a7b38	48		pha		            PHA
.3a7b39	a9 3a		lda #$3a	            LDA #`MERRBADMODE
.3a7b3b	48		pha		            PHA
.3a7b3c	ab		plb		            PLB
.3a7b3d	68		pla		            PLA
.3a7b3e	28		plp		            PLP
.3a7b3f	c2 10		rep #$10	            REP #$10
.3a7b41	a2 6d 7b	ldx #$7b6d	                LDX #<>MERRBADMODE
.3a7b44	20 64 04	jsr $3a0464	            JSR PRINTS
.3a7b47	80 20		bra $3a7b69	                BRA done
.3a7b49					bad_offset
.3a7b49	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a7b4c	08		php		            PHP
.3a7b4d	e2 20		sep #$20	            SEP #$20
.3a7b4f	48		pha		            PHA
.3a7b50	a9 3a		lda #$3a	            LDA #`MERRBADOFFSET
.3a7b52	48		pha		            PHA
.3a7b53	ab		plb		            PLB
.3a7b54	68		pla		            PLA
.3a7b55	28		plp		            PLP
.3a7b56	c2 10		rep #$10	            REP #$10
.3a7b58	a2 bd 7b	ldx #$7bbd	                LDX #<>MERRBADOFFSET
.3a7b5b	20 64 04	jsr $3a0464	            JSR PRINTS
.3a7b5e	80 09		bra $3a7b69	                BRA done
.3a7b60	a5 4f		lda $0897	emit_imm        LDA MADDR_MODE          ; Check to see if long immediate was used
.3a7b62	29 c0		and #$c0	                AND #%11000000
.3a7b64	d0 95		bne $3a7afb	                BNE emit_2              ; Yes: emit two bytes
.3a7b66	4c 07 7b	jmp $3a7b07	                JMP emit_1              ; No: emit one byte
.3a7b69	2b		pld		done            PLD
.3a7b6a	ab		plb		                PLB
.3a7b6b	28		plp		                PLP
.3a7b6c	6b		rtl		                RTL
>3a7b6d	41 64 64 72 65 73 73 69		MERRBADMODE     .null "Addressing mode not defined for that instruction.",CHAR_CR
>3a7b75	6e 67 20 6d 6f 64 65 20 6e 6f 74 20 64 65 66 69
>3a7b85	6e 65 64 20 66 6f 72 20 74 68 61 74 20 69 6e 73
>3a7b95	74 72 75 63 74 69 6f 6e 2e 0d 00
>3a7ba0	42 61 64 20 6d 6e 65 6d		MERRBADMNEMO    .null "Bad mnemonic.",CHAR_CR
>3a7ba8	6f 6e 69 63 2e 0d 00
>3a7baf	42 61 64 20 6f 70 65 72		MERRBADOPER     .null "Bad operand.",CHAR_CR
>3a7bb7	61 6e 64 2e 0d 00
>3a7bbd	52 65 6c 61 74 69 76 65		MERRBADOFFSET   .null "Relative offset is too large.",CHAR_CR
>3a7bc5	20 6f 66 66 73 65 74 20 69 73 20 74 6f 6f 20 6c
>3a7bd5	61 72 67 65 2e 0d 00
.3a7bdc					AS_PC_OFFSET
.3a7bdc	08		php		                PHP
.3a7bdd	0b		phd		                PHD
.3a7bde	08		php		            PHP
.3a7bdf	c2 20		rep #$20	            REP #$20
.3a7be1	48		pha		            PHA
.3a7be2	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7be5	5b		tcd		            TCD
.3a7be6	68		pla		            PLA
.3a7be7	28		plp		            PLP
.3a7be8	e2 20		sep #$20	            SEP #$20
.3a7bea	a5 4f		lda $0897	                LDA MADDR_MODE          ; Check to see if it 1 byte or 2 byte relative
.3a7bec	c9 12		cmp #$12	                CMP #ADDR_PC_REL
.3a7bee	f0 0a		beq $3a7bfa	                BEQ is_short
.3a7bf0	c2 20		rep #$20	            REP #$20
.3a7bf2	18		clc		                CLC                     ; Branch is long. Compute where MCURSOR will be
.3a7bf3	a5 32		lda $087a	                LDA MCURSOR             ; with two branch offset bytes
.3a7bf5	69 02 00	adc #$0002	                ADC #2
.3a7bf8	80 08		bra $3a7c02	                BRA compute_cursor
.3a7bfa					is_short
.3a7bfa	c2 20		rep #$20	            REP #$20
.3a7bfc	18		clc		                CLC                     ; Branch is short. Computer where MCURSOR will be
.3a7bfd	a5 32		lda $087a	                LDA MCURSOR             ; with one branch offset byte
.3a7bff	69 01 00	adc #$0001	                ADC #1
.3a7c02	85 4a		sta $0892	compute_cursor  STA MTEMP
.3a7c04	a5 34		lda $087c	                LDA MCURSOR+2
.3a7c06	69 00 00	adc #$0000	                ADC #0
.3a7c09	85 4c		sta $0894	                STA MTEMP+2
.3a7c0b	38		sec		                SEC                     ; MPARSEDNUM = MPARSEDNUM - MTEMP (MCURSOR after the instruction)
.3a7c0c	a5 50		lda $0898	                LDA MPARSEDNUM
.3a7c0e	e5 4a		sbc $0892	                SBC MTEMP
.3a7c10	85 50		sta $0898	                STA MPARSEDNUM
.3a7c12	a5 52		lda $089a	                LDA MPARSEDNUM+2
.3a7c14	e5 4c		sbc $0894	                SBC MTEMP+2
.3a7c16	85 52		sta $089a	                STA MPARSEDNUM+2
.3a7c18	e2 20		sep #$20	            SEP #$20
.3a7c1a	a5 4f		lda $0897	                LDA MADDR_MODE
.3a7c1c	c9 16		cmp #$16	                CMP #ADDR_PC_REL_LONG
.3a7c1e	f0 1e		beq $3a7c3e	                BEQ check_long
.3a7c20	a5 50		lda $0898	                LDA MPARSEDNUM          ; Short offset... check if it's negative
.3a7c22	30 0c		bmi $3a7c30	                BMI check_short_neg
.3a7c24	a5 51		lda $0899	                LDA MPARSEDNUM+1        ; Positive short offset... upper two bytes
.3a7c26	d0 2a		bne $3a7c52	                BNE failure             ; Must be 0 or it's an overflow
.3a7c28	a5 52		lda $089a	                LDA MPARSEDNUM+2
.3a7c2a	d0 26		bne $3a7c52	                BNE failure
.3a7c2c	a9 01		lda #$01	                LDA #1                  ; Short offset is 1 byte
.3a7c2e	80 26		bra $3a7c56	                BRA success
.3a7c30	a5 51		lda $0899	check_short_neg LDA MPARSEDNUM+1        ; Negative short offset... upper two bytes
.3a7c32	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's an  overflow
.3a7c34	d0 1c		bne $3a7c52	                BNE failure
.3a7c36	a5 52		lda $089a	                LDA MPARSEDNUM+2
.3a7c38	c9 ff		cmp #$ff	                CMP #$FF
.3a7c3a	d0 16		bne $3a7c52	                BNE failure
.3a7c3c	80 18		bra $3a7c56	                BRA success
.3a7c3e	a5 51		lda $0899	check_long      LDA MPARSEDNUM+1        ; Long offset... check if it's negative
.3a7c40	30 06		bmi $3a7c48	                BMI check_long_neg
.3a7c42	a5 52		lda $089a	                LDA MPARSEDNUM+2        ; Positive long offset... upper byte
.3a7c44	d0 0c		bne $3a7c52	                BNE failure             ; Must be 0 or it's an overflow
.3a7c46	80 0e		bra $3a7c56	                BRA success
.3a7c48	a5 52		lda $089a	check_long_neg  LDA MPARSEDNUM+2        ; Negative offset... upper two bytes
.3a7c4a	c9 ff		cmp #$ff	                CMP #$FF                ; Must be $FF or it's and overflow
.3a7c4c	d0 04		bne $3a7c52	                BNE failure
.3a7c4e	a9 02		lda #$02	                LDA #2                  ; Long offset is 2 bytes
.3a7c50	80 04		bra $3a7c56	                BRA success
.3a7c52	2b		pld		failure         PLD
.3a7c53	28		plp		                PLP
.3a7c54	18		clc		                CLC
.3a7c55	6b		rtl		                RTL
.3a7c56	2b		pld		success         PLD
.3a7c57	28		plp		                PLP
.3a7c58	38		sec		                SEC
.3a7c59	6b		rtl		                RTL
.3a7c5a					AS_SHIFT_HEX
.3a7c5a	08		php		                PHP
.3a7c5b	0b		phd		                PHD
.3a7c5c	c2 10		rep #$10	            REP #$10
.3a7c5e	da		phx		                PHX
.3a7c5f	08		php		            PHP
.3a7c60	c2 20		rep #$20	            REP #$20
.3a7c62	48		pha		            PHA
.3a7c63	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7c66	5b		tcd		            TCD
.3a7c67	68		pla		            PLA
.3a7c68	28		plp		            PLP
.3a7c69	e2 20		sep #$20	            SEP #$20
.3a7c6b	a2 00 00	ldx #$0000	                LDX #0
.3a7c6e	df 00 d0 3a	cmp $3ad000,x	seek_loop       CMP @lHEXDIGITS,X   ; Check the passed character against the hex digits
.3a7c72	f0 08		beq $3a7c7c	                BEQ found
.3a7c74	e8		inx		                INX                 ; Go to the next hex digit
.3a7c75	e0 10 00	cpx #$0010	                CPX #$10            ; Are we out of digits?
.3a7c78	f0 1b		beq $3a7c95	                BEQ done            ; Yes... just return
.3a7c7a	80 f2		bra $3a7c6e	                BRA seek_loop
.3a7c7c					found
.3a7c7c	c2 20		rep #$20	            REP #$20
.3a7c7e	06 50		asl $0898	                ASL MPARSEDNUM
.3a7c80	26 52		rol $089a	                ROL MPARSEDNUM+2
.3a7c82	06 50		asl $0898	                ASL MPARSEDNUM
.3a7c84	26 52		rol $089a	                ROL MPARSEDNUM+2
.3a7c86	06 50		asl $0898	                ASL MPARSEDNUM
.3a7c88	26 52		rol $089a	                ROL MPARSEDNUM+2
.3a7c8a	06 50		asl $0898	                ASL MPARSEDNUM
.3a7c8c	26 52		rol $089a	                ROL MPARSEDNUM+2
.3a7c8e	e2 20		sep #$20	            SEP #$20
.3a7c90	8a		txa		                TXA
.3a7c91	05 50		ora $0898	                ORA MPARSEDNUM
.3a7c93	85 50		sta $0898	                STA MPARSEDNUM
.3a7c95	fa		plx		done            PLX
.3a7c96	2b		pld		                PLD
.3a7c97	28		plp		                PLP
.3a7c98	6b		rtl		                RTL
.3a7c99					AS_FIND_OPCODE
.3a7c99	0b		phd		                PHD
.3a7c9a	8b		phb		                PHB
.3a7c9b	08		php		            PHP
.3a7c9c	c2 20		rep #$20	            REP #$20
.3a7c9e	48		pha		            PHA
.3a7c9f	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7ca2	5b		tcd		            TCD
.3a7ca3	68		pla		            PLA
.3a7ca4	28		plp		            PLP
.3a7ca5	08		php		            PHP
.3a7ca6	e2 20		sep #$20	            SEP #$20
.3a7ca8	48		pha		            PHA
.3a7ca9	a9 3a		lda #$3a	            LDA #`MNEMONIC_TAB
.3a7cab	48		pha		            PHA
.3a7cac	ab		plb		            PLB
.3a7cad	68		pla		            PLA
.3a7cae	28		plp		            PLP
.3a7caf	e2 20		sep #$20	            SEP #$20
.3a7cb1	a5 4f		lda $0897	                LDA MADDR_MODE
.3a7cb3	29 3f		and #$3f	                AND #%00111111
.3a7cb5	85 4a		sta $0892	                STA MTEMP
.3a7cb7	c2 30		rep #$30	            REP #$30
.3a7cb9	a2 00 00	ldx #$0000	                LDX #0
.3a7cbc	a0 00 00	ldy #$0000	                LDY #0
.3a7cbf	bd 66 83	lda $3a8366,x	mnemonic_loop   LDA MNEMONIC_TAB,X      ; Get the mnemonic from the opcode table
.3a7cc2	f0 1b		beq $3a7cdf	                BEQ not_found           ; If it's 0, we did not find the mnemonic
.3a7cc4	c5 54		cmp $089c	                CMP MMNEMONIC           ; Does it match the passed mnemonic?
.3a7cc6	d0 0d		bne $3a7cd5	                BNE next_opcode         ; No: go to the next opcode
.3a7cc8					check_mode
.3a7cc8	e2 20		sep #$20	            SEP #$20
.3a7cca	b9 68 85	lda $3a8568,y	                LDA ADDRESS_TAB,Y       ; Get the corresponding address mode
.3a7ccd	29 3f		and #$3f	                AND #%00111111          ; Filter out effect bits
.3a7ccf	c5 4a		cmp $0892	                CMP MTEMP
.3a7cd1	f0 07		beq $3a7cda	                BEQ found               ; Yes: we found the opcode
.3a7cd3	c2 20		rep #$20	            REP #$20
.3a7cd5	e8		inx		next_opcode     INX                     ; Point to the next mnemonic in the table
.3a7cd6	e8		inx		                INX
.3a7cd7	c8		iny		                INY
.3a7cd8	80 e5		bra $3a7cbf	                BRA mnemonic_loop       ; And check it
.3a7cda	98		tya		found           TYA
.3a7cdb	38		sec		                SEC                     ; Set carry to show success
.3a7cdc	ab		plb		                PLB
.3a7cdd	2b		pld		                PLD
.3a7cde	6b		rtl		                RTL
.3a7cdf	18		clc		not_found       CLC                     ; Clear carry to show failure
.3a7ce0	ab		plb		                PLB
.3a7ce1	2b		pld		                PLD
.3a7ce2	6b		rtl		                RTL
.3a7ce3					AS_STR_MATCH
.3a7ce3	08		php		                PHP
.3a7ce4	0b		phd		                PHD
.3a7ce5	08		php		            PHP
.3a7ce6	c2 20		rep #$20	            REP #$20
.3a7ce8	48		pha		            PHA
.3a7ce9	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7cec	5b		tcd		            TCD
.3a7ced	68		pla		            PLA
.3a7cee	28		plp		            PLP
.3a7cef	e2 20		sep #$20	            SEP #$20
.3a7cf1	c2 10		rep #$10	            REP #$10
.3a7cf3	a0 00 00	ldy #$0000	                LDY #0
.3a7cf6	64 50		stz $0898	                STZ MPARSEDNUM      ; Set parsed number to 0 in anticipation of
.3a7cf8	64 52		stz $089a	                STZ MPARSEDNUM+2    ; hex digits in the pattern
.3a7cfa	b7 03		lda [$084b],y	match_loop      LDA [MCMP_TEXT],Y   ; Get the pattern character
.3a7cfc	f0 11		beq $3a7d0f	                BEQ nul_check       ; If at end of pattern, check for end of test string
.3a7cfe	c9 64		cmp #$64	                CMP #'d'            ; Is it a digit?
.3a7d00	f0 19		beq $3a7d1b	                BEQ check_digit     ; Yes: do special check for hex digit
.3a7d02	48		pha		compare         PHA
.3a7d03	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.3a7d05	85 4a		sta $0892	                STA MTEMP
.3a7d07	68		pla		                PLA
.3a7d08	c5 4a		cmp $0892	                CMP MTEMP           ; Does it match the character to test?
.3a7d0a	d0 0b		bne $3a7d17	                BNE return_false    ; No: return fail
.3a7d0c	c8		iny		next_char       INY                 ; Yes: test the next character
.3a7d0d	80 eb		bra $3a7cfa	                BRA match_loop
.3a7d0f	b7 36		lda [$087e],y	nul_check       LDA [MLINEBUF],Y    ; Check to see that we're at the end of the test string
.3a7d11	d0 04		bne $3a7d17	                BNE return_false    ; If not: return false
.3a7d13	2b		pld		return_true     PLD
.3a7d14	28		plp		                PLP                 ; Return true
.3a7d15	38		sec		                SEC
.3a7d16	6b		rtl		                RTL
.3a7d17	2b		pld		return_false    PLD
.3a7d18	28		plp		                PLP                 ; Return false
.3a7d19	18		clc		                CLC
.3a7d1a	6b		rtl		                RTL
.3a7d1b					check_digit
.3a7d1b	e2 20		sep #$20	            SEP #$20
.3a7d1d	b7 36		lda [$087e],y	                LDA [MLINEBUF],Y
.3a7d1f	c9 3a		cmp #$3a	                CMP #'9'+1
.3a7d21	b0 04		bcs $3a7d27	                BCS check_AF
.3a7d23	c9 30		cmp #$30	                CMP #'0'
.3a7d25	b0 14		bcs $3a7d3b	                BCS shift_digit     ; character is in [0..9]
.3a7d27	c9 47		cmp #$47	check_AF        CMP #'F'+1
.3a7d29	b0 04		bcs $3a7d2f	                BCS check_lc        ; check lower case
.3a7d2b	c9 41		cmp #$41	                CMP #'A'
.3a7d2d	b0 0c		bcs $3a7d3b	                BCS shift_digit     ; character is in [A..F]
.3a7d2f	c9 67		cmp #$67	check_lc        CMP #'f'+1
.3a7d31	b0 e4		bcs $3a7d17	                BCS return_false    ; check lower case
.3a7d33	c9 61		cmp #$61	                CMP #'a'
.3a7d35	b0 02		bcs $3a7d39	                BCS to_upcase       ; character is in [A..F]
.3a7d37	80 de		bra $3a7d17	                BRA return_false    ; No match found... return false
.3a7d39	29 df		and #$df	to_upcase       AND #%11011111      ; Convert lower case to upper case
.3a7d3b	22 5a 7c 3a	jsl $3a7c5a	shift_digit     JSL AS_SHIFT_HEX    ; Shift the digit into MPARSEDNUM
.3a7d3f	80 cb		bra $3a7d0c	                BRA next_char       ; And check the next character
.3a7d41					AS_MCMP_NEXT
.3a7d41	0b		phd		                PHD
.3a7d42	08		php		            PHP
.3a7d43	c2 20		rep #$20	            REP #$20
.3a7d45	48		pha		            PHA
.3a7d46	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7d49	5b		tcd		            TCD
.3a7d4a	68		pla		            PLA
.3a7d4b	28		plp		            PLP
.3a7d4c	a0 00 00	ldy #$0000	                LDY #0
.3a7d4f	e2 20		sep #$20	            SEP #$20
.3a7d51	b7 03		lda [$084b],y	loop            LDA [MCMP_TEXT],Y   ; Check to see if we have gotten to the NUL
.3a7d53	f0 03		beq $3a7d58	                BEQ found_nul
.3a7d55	c8		iny		                INY
.3a7d56	80 f9		bra $3a7d51	                BRA loop
.3a7d58					found_nul
.3a7d58	c2 20		rep #$20	            REP #$20
.3a7d5a	c8		iny		                INY                 ; Got to NUL... point to next byte
.3a7d5b	5a		phy		                PHY
.3a7d5c	68		pla		                PLA                 ; And add that index to MCMP_TEXT pointer
.3a7d5d	18		clc		                CLC
.3a7d5e	65 03		adc $084b	                ADC MCMP_TEXT
.3a7d60	85 03		sta $084b	                STA MCMP_TEXT
.3a7d62	a5 05		lda $084d	                LDA MCMP_TEXT+2
.3a7d64	69 00 00	adc #$0000	                ADC #0
.3a7d67	85 05		sta $084d	                STA MCMP_TEXT+2
.3a7d69	2b		pld		                PLD
.3a7d6a	6b		rtl		                RTL
.3a7d6b					AS_FIND_MNEMO
.3a7d6b	0b		phd		                PHD
.3a7d6c	08		php		            PHP
.3a7d6d	c2 20		rep #$20	            REP #$20
.3a7d6f	48		pha		            PHA
.3a7d70	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7d73	5b		tcd		            TCD
.3a7d74	68		pla		            PLA
.3a7d75	28		plp		            PLP
.3a7d76	c2 20		rep #$20	            REP #$20
.3a7d78	a5 11		lda $0859	                LDA MARG2                   ; Point MLINEBUF to the text
.3a7d7a	85 36		sta $087e	                STA MLINEBUF
.3a7d7c	a5 13		lda $085b	                LDA MARG2+2
.3a7d7e	85 38		sta $0880	                STA MLINEBUF+2
.3a7d80	a9 f4 81	lda #$81f4	                LDA #<>MNEMONICS_TAB        ; Point to the first mnemonic
.3a7d83	85 03		sta $084b	                STA MCMP_TEXT
.3a7d85	a9 3a 00	lda #$003a	                LDA #`MNEMONICS_TAB
.3a7d88	85 05		sta $084d	                STA MCMP_TEXT+2
.3a7d8a	22 e3 7c 3a	jsl $3a7ce3	match_loop      JSL AS_STR_MATCH            ; Check to see if the text matches the mnemonic
.3a7d8e	b0 0d		bcs $3a7d9d	                BCS found_mnemonic          ; If so: return that we found it
.3a7d90	22 41 7d 3a	jsl $3a7d41	                JSL AS_MCMP_NEXT            ; Point to the next mnemonic
.3a7d94	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Check to see if it's NUL
.3a7d96	d0 f2		bne $3a7d8a	                BNE match_loop              ; If not, check this next mnemonic
.3a7d98	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Otherwise, return -1
.3a7d9b	80 02		bra $3a7d9f	                BRA done
.3a7d9d	a5 03		lda $084b	found_mnemonic  LDA MCMP_TEXT               ; Found it: return the address
.3a7d9f	2b		pld		done            PLD
.3a7da0	6b		rtl		                RTL
.3a7da1					AS_FIND_MODE
.3a7da1	08		php		                PHP
.3a7da2	0b		phd		                PHD
.3a7da3	08		php		            PHP
.3a7da4	c2 20		rep #$20	            REP #$20
.3a7da6	48		pha		            PHA
.3a7da7	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7daa	5b		tcd		            TCD
.3a7dab	68		pla		            PLA
.3a7dac	28		plp		            PLP
.3a7dad	c2 30		rep #$30	            REP #$30
.3a7daf	a5 15		lda $085d	                LDA MARG3                   ; Point MLINEBUF to the operand
.3a7db1	85 36		sta $087e	                STA MLINEBUF
.3a7db3	a5 17		lda $085f	                LDA MARG3+2
.3a7db5	85 38		sta $0880	                STA MLINEBUF+2
.3a7db7	a9 80 86	lda #$8680	                LDA #<>ADDR_PATTERNS        ; Point to the first address mode pattern to check
.3a7dba	85 03		sta $084b	                STA MCMP_TEXT
.3a7dbc	a9 3a 00	lda #$003a	                LDA #`ADDR_PATTERNS
.3a7dbf	85 05		sta $084d	                STA MCMP_TEXT+2
.3a7dc1	22 e3 7c 3a	jsl $3a7ce3	match_loop      JSL AS_STR_MATCH            ; Check to see if the pattern matches the operand
.3a7dc5	b0 22		bcs $3a7de9	                BCS is_match                ; Yes: Find address mode code
.3a7dc7	22 41 7d 3a	jsl $3a7d41	                JSL AS_MCMP_NEXT            ; Point to the address mode
.3a7dcb	c2 20		rep #$20	            REP #$20
.3a7dcd	18		clc		                CLC                         ; Point to the first byte of the next pattern
.3a7dce	a5 03		lda $084b	                LDA MCMP_TEXT
.3a7dd0	69 01 00	adc #$0001	                ADC #1
.3a7dd3	85 03		sta $084b	                STA MCMP_TEXT
.3a7dd5	a5 05		lda $084d	                LDA MCMP_TEXT+2
.3a7dd7	69 00 00	adc #$0000	                ADC #0
.3a7dda	85 05		sta $084d	                STA MCMP_TEXT+2
.3a7ddc	e2 20		sep #$20	            SEP #$20
.3a7dde	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Is the first byte 0?
.3a7de0	d0 df		bne $3a7dc1	                BNE match_loop              ; No: check this next pattern
.3a7de2	c2 20		rep #$20	            REP #$20
.3a7de4	a9 ff ff	lda #$ffff	                LDA #$FFFF                  ; Yes: we didn't find a matching pattern, return -1
.3a7de7	80 0d		bra $3a7df6	                BRA done
.3a7de9	22 41 7d 3a	jsl $3a7d41	is_match        JSL AS_MCMP_NEXT            ; Point to the address mode
.3a7ded	e2 20		sep #$20	            SEP #$20
.3a7def	a7 03		lda [$084b]	                LDA [MCMP_TEXT]             ; Get the corresponding address mode code (a byte)
.3a7df1	c2 20		rep #$20	            REP #$20
.3a7df3	29 ff 00	and #$00ff	                AND #$00FF
.3a7df6	2b		pld		done            PLD
.3a7df7	28		plp		                PLP
.3a7df8	6b		rtl		                RTL
.3a7df9					IMDISASSEMBLE
.3a7df9	08		php		                PHP
.3a7dfa	8b		phb		                PHB
.3a7dfb	0b		phd		                PHD
.3a7dfc	08		php		            PHP
.3a7dfd	c2 20		rep #$20	            REP #$20
.3a7dff	48		pha		            PHA
.3a7e00	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a7e03	5b		tcd		            TCD
.3a7e04	68		pla		            PLA
.3a7e05	28		plp		            PLP
.3a7e06	e2 20		sep #$20	            SEP #$20
.3a7e08	a9 00		lda #$00	                LDA #0
.3a7e0a	8f b6 08 00	sta $0008b6	                STA @lLINECOUNT     ; Clear the pagination line counter
.3a7e0e	a5 31		lda $0879	                LDA MARG_LEN        ; Check the number of arguments
.3a7e10	c9 02		cmp #$02	                CMP #2
.3a7e12	b0 16		bcs $3a7e2a	                BGE set_cursor      ; 2>= arguments? Use them as-is
.3a7e14	c9 01		cmp #$01	                CMP #1
.3a7e16	90 20		bcc $3a7e38	                BLT no_args         ; No arguments passed? Use defaults
.3a7e18	c2 20		rep #$20	            REP #$20
.3a7e1a	18		clc		                CLC
.3a7e1b	a5 0d		lda $0855	                LDA MARG1
.3a7e1d	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.3a7e20	85 11		sta $0859	                STA MARG2
.3a7e22	e2 20		sep #$20	            SEP #$20
.3a7e24	a5 0f		lda $0857	                LDA MARG1+2
.3a7e26	69 00		adc #$00	                ADC #0
.3a7e28	85 13		sta $085b	                STA MARG2+2
.3a7e2a					set_cursor
.3a7e2a	c2 20		rep #$20	            REP #$20
.3a7e2c	a5 0d		lda $0855	                LDA MARG1
.3a7e2e	85 32		sta $087a	                STA MCURSOR
.3a7e30	e2 20		sep #$20	            SEP #$20
.3a7e32	a5 0f		lda $0857	                LDA MARG1+2
.3a7e34	85 34		sta $087c	                STA MCURSOR+2
.3a7e36	80 12		bra $3a7e4a	                BRA dasm_loop
.3a7e38					no_args
.3a7e38	c2 20		rep #$20	            REP #$20
.3a7e3a	18		clc		                CLC
.3a7e3b	a5 32		lda $087a	                LDA MCURSOR
.3a7e3d	69 00 01	adc #$0100	                ADC #MMEMDUMPSIZE
.3a7e40	85 11		sta $0859	                STA MARG2
.3a7e42	e2 20		sep #$20	            SEP #$20
.3a7e44	a5 34		lda $087c	                LDA MCURSOR+2
.3a7e46	69 00		adc #$00	                ADC #0
.3a7e48	85 13		sta $085b	                STA MARG2+2
.3a7e4a	22 65 7e 3a	jsl $3a7e65	dasm_loop       JSL DS_PR_LINE
.3a7e4e	e2 20		sep #$20	            SEP #$20
.3a7e50	a5 34		lda $087c	                LDA MCURSOR+2           ; Are the banks the same?
.3a7e52	c5 13		cmp $085b	                CMP MARG2+2
.3a7e54	90 f4		bcc $3a7e4a	                BLT dasm_loop           ; No: continue
.3a7e56	c2 20		rep #$20	            REP #$20
.3a7e58	a5 32		lda $087a	                LDA MCURSOR             ; Are the lower bits the same?
.3a7e5a	c5 11		cmp $0859	                CMP MARG2
.3a7e5c	90 ec		bcc $3a7e4a	                BLT dasm_loop           ; Nope... keep going
.3a7e5e					done
.3a7e5e	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a7e61	2b		pld		                PLD
.3a7e62	ab		plb		                PLB
.3a7e63	28		plp		                PLP
.3a7e64	6b		rtl		                RTL
.3a7e65					DS_PR_LINE
.3a7e65	08		php		                PHP
.3a7e66	0b		phd		                PHD
.3a7e67	e2 20		sep #$20	            SEP #$20
.3a7e69	a9 41		lda #$41	                LDA #'A'
.3a7e6b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e6e	a9 20		lda #$20	                LDA #' '
.3a7e70	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e73	08		php		            PHP
.3a7e74	c2 20		rep #$20	            REP #$20
.3a7e76	48		pha		            PHA
.3a7e77	a9 7a 08	lda #$087a	            LDA #MCURSOR
.3a7e7a	5b		tcd		            TCD
.3a7e7b	68		pla		            PLA
.3a7e7c	28		plp		            PLP
.3a7e7d	c2 20		rep #$20	            REP #$20
.3a7e7f	a5 00		lda $087a	                LDA MCURSOR
.3a7e81	85 18		sta $0892	                STA MTEMP
.3a7e83	e2 20		sep #$20	            SEP #$20
.3a7e85	a5 02		lda $087c	                LDA MCURSOR+2
.3a7e87	85 1a		sta $0894	                STA MTEMP+2
.3a7e89	22 cc 81 3a	jsl $3a81cc	                JSL M_PR_ADDR
.3a7e8d	a9 20		lda #$20	                LDA #' '
.3a7e8f	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7e92	c2 20		rep #$20	            REP #$20
.3a7e94	18		clc		                CLC
.3a7e95	a5 00		lda $087a	                LDA MCURSOR
.3a7e97	69 01 00	adc #$0001	                ADC #1
.3a7e9a	85 18		sta $0892	                STA MTEMP
.3a7e9c	e2 20		sep #$20	            SEP #$20
.3a7e9e	a5 02		lda $087c	                LDA MCURSOR+2
.3a7ea0	69 00		adc #$00	                ADC #0
.3a7ea2	85 1a		sta $0894	                STA MTEMP+2
.3a7ea4	e2 20		sep #$20	            SEP #$20
.3a7ea6	c2 10		rep #$10	            REP #$10
.3a7ea8	a7 00		lda [$087a]	                LDA [MCURSOR]           ; Get the mnemonic
.3a7eaa	c9 c2		cmp #$c2	                CMP #$C2                ; Is it REP?
.3a7eac	d0 0b		bne $3a7eb9	                BNE check_sep           ; No: check to see if it is SEP
.3a7eae	48		pha		handle_rep      PHA
.3a7eaf	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.3a7eb1	49 ff		eor #$ff	                EOR #$FF                ; Invert the bits
.3a7eb3	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Mask off the bits in the CPUSTAT
.3a7eb7	80 0b		bra $3a7ec4	                BRA save_stat
.3a7eb9	c9 e2		cmp #$e2	check_sep       CMP #$E2                ; Is it SEP?
.3a7ebb	d0 0c		bne $3a7ec9	                BNE get_op_index        ; No: process the instruction regularly
.3a7ebd	48		pha		handle_sep      PHA
.3a7ebe	a7 18		lda [$0892]	                LDA [MTEMP]             ; Get the operand
.3a7ec0	0f 96 08 00	ora $000896	                ORA @lMCPUSTAT          ; Activate the bits in the CPUSTAT
.3a7ec4	8f 96 08 00	sta $000896	save_stat       STA @lMCPUSTAT          ; And save it back
.3a7ec8	68		pla		                PLA
.3a7ec9					get_op_index
.3a7ec9	c2 20		rep #$20	            REP #$20
.3a7ecb	29 ff 00	and #$00ff	                AND #$00FF
.3a7ece	0a		asl a		                ASL A
.3a7ecf	aa		tax		                TAX                     ; Get the index into the mnemonic lookup table
.3a7ed0	bf 66 83 3a	lda $3a8366,x	                LDA @lMNEMONIC_TAB,X    ; Get the mnemonic
.3a7ed4	aa		tax		                TAX
.3a7ed5	22 46 81 3a	jsl $3a8146	                JSL DS_PR_MNEMONIC      ; And print it
.3a7ed9	e2 20		sep #$20	            SEP #$20
.3a7edb	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a7edd	aa		tax		                TAX
.3a7ede	bf 68 85 3a	lda $3a8568,x	pr_operand      LDA @lADDRESS_TAB,X     ; Get the addressing mode for the instruction
.3a7ee2	22 22 87 3a	jsl $3a8722	                JSL M_INC_CURSOR        ; Advance the cursor to the next byte
.3a7ee6	22 f3 7e 3a	jsl $3a7ef3	                JSL DS_PR_OPERAND       ; And print the correct operand
.3a7eea	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a7eed	20 ee 03	jsr $3a03ee	            JSR PAGINATE
.3a7ef0	2b		pld		                PLD
.3a7ef1	28		plp		                PLP
.3a7ef2	6b		rtl		                RTL
.3a7ef3					DS_PR_OPERAND
.3a7ef3	08		php		                PHP
.3a7ef4	e2 20		sep #$20	            SEP #$20
.3a7ef6	48		pha		                PHA             ; Save the address mode so we can get to the M and X flags
.3a7ef7	29 3f		and #$3f	                AND #%00111111  ; Filter out the mode flags
.3a7ef9	0a		asl a		                ASL A           ; Compute the index to the table
.3a7efa	c2 10		rep #$10	            REP #$10
.3a7efc	aa		tax		                TAX
.3a7efd	68		pla		                PLA             ; Restore A
.3a7efe	7c 01 7f	jmp ($3a7f01,x)	                JMP (dispatch,X)
>3a7f01	31 7f				dispatch        .word <>is_dp_ind_x
>3a7f03	4c 7f				                .word <>is_dp
>3a7f05	53 7f				                .word <>is_imm
>3a7f07	78 7f				                .word <>is_abs
>3a7f09	7f 7f				                .word <>is_dp_ind_y
>3a7f0b	9a 7f				                .word <>is_dp_x
>3a7f0d	bc 7f				                .word <>is_abs_y
>3a7f0f	cd 7f				                .word <>is_abs_x
>3a7f11	0a 80				                .word <>is_accumulator
>3a7f13	12 80				                .word <>is_stack_r
>3a7f15	23 80				                .word <>is_dp_long
>3a7f17	34 80				                .word <>is_abs_long
>3a7f19	3b 80				                .word <>is_stack_r_y
>3a7f1b	60 80				                .word <>is_dp_y_long
>3a7f1d	8d 80				                .word <>is_abs_x_long
>3a7f1f	f9 7f				                .word <>is_dp_ind
>3a7f21	de 7f				                .word <>is_abs_x_id
>3a7f23	ab 7f				                .word <>is_dp_y
>3a7f25	80 80				                .word <>is_pc_rel
>3a7f27	8a 80				                .word <>is_implied
>3a7f29	9e 80				                .word <>is_xyc
>3a7f2b	cd 80				                .word <>is_abs_ind
>3a7f2d	7b 80				                .word <>is_pc_rel_long
>3a7f2f	de 80				                .word <>is_abs_ind_long
.3a7f31	a9 28		lda #$28	is_dp_ind_x     LDA #'('                ; Print (dd,X)
.3a7f33	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f36	22 f5 80 3a	jsl $3a80f5	                JSL DS_PR_OPERAND1      ; Print dd
.3a7f3a	a9 2c		lda #$2c	                LDA #','
.3a7f3c	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f3f	a9 58		lda #$58	                LDA #'X'
.3a7f41	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f44	a9 29		lda #$29	                LDA #')'
.3a7f46	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f49	4c ef 80	jmp $3a80ef	                JMP done_1
.3a7f4c	22 f5 80 3a	jsl $3a80f5	is_dp           JSL DS_PR_OPERAND1      ; Print dd
.3a7f50	4c ef 80	jmp $3a80ef	                JMP done_1
.3a7f53					is_imm
.3a7f53	e2 20		sep #$20	            SEP #$20
.3a7f55	48		pha		                PHA
.3a7f56	a9 23		lda #$23	                LDA #'#'
.3a7f58	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f5b	68		pla		                PLA
.3a7f5c	29 c0		and #$c0	                AND #%11000000          ; Filter so we just look at the mode bits
.3a7f5e	c9 00		cmp #$00	                CMP #$00                ; Are any set to check?
.3a7f60	f0 0f		beq $3a7f71	                BEQ is_imm_short        ; No: treat it as a short always
.3a7f62	4a		lsr a		                LSR A                   ; Move the flag bits right by 2 to match
.3a7f63	4a		lsr a		                LSR A                   ; the positions of the bits in the CPU status register
.3a7f64	2f 96 08 00	and $000896	                AND @lMCPUSTAT          ; Otherwise, filter the mode bit we care about
.3a7f68	d0 07		bne $3a7f71	                BNE is_imm_short        ; If it is set, immediate operation is short
.3a7f6a	22 ff 80 3a	jsl $3a80ff	                JSL DS_PR_OPERAND2      ; Print dddd
.3a7f6e	4c ef 80	jmp $3a80ef	                JMP done_1
.3a7f71	22 f5 80 3a	jsl $3a80f5	is_imm_short    JSL DS_PR_OPERAND1      ; Print dd
.3a7f75	4c ef 80	jmp $3a80ef	                JMP done_1
.3a7f78	22 ff 80 3a	jsl $3a80ff	is_abs          JSL DS_PR_OPERAND2      ; Print dddd
.3a7f7c	4c ef 80	jmp $3a80ef	                JMP done_1
.3a7f7f	a9 28		lda #$28	is_dp_ind_y     LDA #'('                ; Print (dd),Y
.3a7f81	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f84	22 f5 80 3a	jsl $3a80f5	                JSL DS_PR_OPERAND1      ; Print dd
.3a7f88	a9 29		lda #$29	                LDA #')'
.3a7f8a	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f8d	a9 2c		lda #$2c	                LDA #','
.3a7f8f	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f92	a9 59		lda #$59	                LDA #'Y'
.3a7f94	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7f97	4c ef 80	jmp $3a80ef	                JMP done_1
.3a7f9a	22 f5 80 3a	jsl $3a80f5	is_dp_x         JSL DS_PR_OPERAND1      ; Print dd,X
.3a7f9e	a9 2c		lda #$2c	                LDA #','
.3a7fa0	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7fa3	a9 58		lda #$58	                LDA #'X'
.3a7fa5	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7fa8	4c ef 80	jmp $3a80ef	                JMP done_1
.3a7fab	22 f5 80 3a	jsl $3a80f5	is_dp_y         JSL DS_PR_OPERAND1      ; Print dd,Y
.3a7faf	a9 2c		lda #$2c	                LDA #','
.3a7fb1	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7fb4	a9 59		lda #$59	                LDA #'Y'
.3a7fb6	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7fb9	4c ef 80	jmp $3a80ef	                JMP done_1
.3a7fbc	22 ff 80 3a	jsl $3a80ff	is_abs_y        JSL DS_PR_OPERAND2      ; Print dddd,Y
.3a7fc0	a9 2c		lda #$2c	                LDA #','
.3a7fc2	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7fc5	a9 59		lda #$59	                LDA #'Y'
.3a7fc7	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7fca	4c ef 80	jmp $3a80ef	                JMP done_1
.3a7fcd	22 ff 80 3a	jsl $3a80ff	is_abs_x        JSL DS_PR_OPERAND2      ; Print dddd,X
.3a7fd1	a9 2c		lda #$2c	                LDA #','
.3a7fd3	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7fd6	a9 58		lda #$58	                LDA #'X'
.3a7fd8	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7fdb	4c ef 80	jmp $3a80ef	                JMP done_1
.3a7fde	a9 28		lda #$28	is_abs_x_id     LDA #'('
.3a7fe0	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7fe3	22 ff 80 3a	jsl $3a80ff	                JSL DS_PR_OPERAND2      ; Print (dddd,X)
.3a7fe7	a9 2c		lda #$2c	                LDA #','
.3a7fe9	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7fec	a9 58		lda #$58	                LDA #'X'
.3a7fee	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7ff1	a9 29		lda #$29	                LDA #')'
.3a7ff3	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7ff6	4c ef 80	jmp $3a80ef	                JMP done_1
.3a7ff9	a9 28		lda #$28	is_dp_ind       LDA #'('
.3a7ffb	20 18 00	jsr $3a0018	            JSR PRINTC
.3a7ffe	22 f5 80 3a	jsl $3a80f5	                JSL DS_PR_OPERAND1      ; Print (dd)
.3a8002	a9 29		lda #$29	                LDA #')'
.3a8004	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8007	4c ef 80	jmp $3a80ef	                JMP done_1
.3a800a	a9 41		lda #$41	is_accumulator  LDA #'A'                ; Print A
.3a800c	20 18 00	jsr $3a0018	            JSR PRINTC
.3a800f	4c f3 80	jmp $3a80f3	                JMP done
.3a8012	22 f5 80 3a	jsl $3a80f5	is_stack_r      JSL DS_PR_OPERAND1      ; Print dd,S
.3a8016	a9 2c		lda #$2c	                LDA #','
.3a8018	20 18 00	jsr $3a0018	            JSR PRINTC
.3a801b	a9 53		lda #$53	                LDA #'S'
.3a801d	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8020	4c ef 80	jmp $3a80ef	                JMP done_1
.3a8023	a9 5b		lda #$5b	is_dp_long      LDA #'['                ; [dd]
.3a8025	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8028	22 f5 80 3a	jsl $3a80f5	                JSL DS_PR_OPERAND1      ; Print dd
.3a802c	a9 5d		lda #$5d	                LDA #']'
.3a802e	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8031	4c ef 80	jmp $3a80ef	                JMP done_1
.3a8034	22 0d 81 3a	jsl $3a810d	is_abs_long     JSL DS_PR_OPERAND3      ; Print dddddd
.3a8038	4c f3 80	jmp $3a80f3	                JMP done
.3a803b	a9 28		lda #$28	is_stack_r_y    LDA #'('                ; (dd,S),Y
.3a803d	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8040	22 f5 80 3a	jsl $3a80f5	                JSL DS_PR_OPERAND1      ; Print dd
.3a8044	a9 2c		lda #$2c	                LDA #','
.3a8046	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8049	a9 53		lda #$53	                LDA #'S'
.3a804b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a804e	a9 29		lda #$29	                LDA #')'
.3a8050	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8053	a9 2c		lda #$2c	                LDA #','
.3a8055	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8058	a9 59		lda #$59	                LDA #'Y'
.3a805a	20 18 00	jsr $3a0018	            JSR PRINTC
.3a805d	4c ef 80	jmp $3a80ef	                JMP done_1
.3a8060	a9 5b		lda #$5b	is_dp_y_long    LDA #'['                ; [dd],Y
.3a8062	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8065	22 f5 80 3a	jsl $3a80f5	                JSL DS_PR_OPERAND1      ; Print dd
.3a8069	a9 5d		lda #$5d	                LDA #']'
.3a806b	20 18 00	jsr $3a0018	            JSR PRINTC
.3a806e	a9 2c		lda #$2c	                LDA #','
.3a8070	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8073	a9 59		lda #$59	                LDA #'Y'
.3a8075	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8078	4c ef 80	jmp $3a80ef	                JMP done_1
.3a807b	a0 02 00	ldy #$0002	is_pc_rel_long  LDY #2
.3a807e	80 03		bra $3a8083	                BRA do_pcrel
.3a8080	a0 01 00	ldy #$0001	is_pc_rel       LDY #1
.3a8083	22 73 81 3a	jsl $3a8173	do_pcrel        JSL DS_PR_PCREL
.3a8087	4c f3 80	jmp $3a80f3	                JMP done
.3a808a	4c f3 80	jmp $3a80f3	is_implied      JMP done
.3a808d	22 0d 81 3a	jsl $3a810d	is_abs_x_long   JSL DS_PR_OPERAND3      ; Print dddddd
.3a8091	a9 2c		lda #$2c	                LDA #','
.3a8093	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8096	a9 58		lda #$58	                LDA #'X'
.3a8098	20 18 00	jsr $3a0018	            JSR PRINTC
.3a809b	4c f3 80	jmp $3a80f3	                JMP done
.3a809e	a9 23		lda #$23	is_xyc          LDA #'#'
.3a80a0	20 18 00	jsr $3a0018	            JSR PRINTC
.3a80a3	8b		phb		                PHB                     ; Make sure the databank is pointed to our number
.3a80a4	a5 02		lda $087c	                LDA MCURSOR+2
.3a80a6	48		pha		                PHA
.3a80a7	ab		plb		                PLB
.3a80a8	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.3a80aa	e8		inx		                INX
.3a80ab	a0 01 00	ldy #$0001	                LDY #1
.3a80ae	22 e7 03 3a	jsl $3a03e7	                JSL PRINTH
.3a80b2	a9 2c		lda #$2c	                LDA #','
.3a80b4	20 18 00	jsr $3a0018	            JSR PRINTC
.3a80b7	a9 23		lda #$23	                LDA #'#'
.3a80b9	20 18 00	jsr $3a0018	            JSR PRINTC
.3a80bc	a6 00		ldx $087a	                LDX MCURSOR             ; Print dd
.3a80be	a0 01 00	ldy #$0001	                LDY #1
.3a80c1	22 e7 03 3a	jsl $3a03e7	                JSL PRINTH
.3a80c5	ab		plb		                PLB                     ; Get our old data bank back
.3a80c6	22 22 87 3a	jsl $3a8722	                JSL M_INC_CURSOR
.3a80ca	4c ef 80	jmp $3a80ef	                JMP done_1
.3a80cd	a9 28		lda #$28	is_abs_ind      LDA #'('
.3a80cf	20 18 00	jsr $3a0018	            JSR PRINTC
.3a80d2	22 ff 80 3a	jsl $3a80ff	                JSL DS_PR_OPERAND2      ; Print (dddd)
.3a80d6	a9 29		lda #$29	                LDA #')'
.3a80d8	20 18 00	jsr $3a0018	            JSR PRINTC
.3a80db	4c ef 80	jmp $3a80ef	                JMP done_1
.3a80de	a9 5b		lda #$5b	is_abs_ind_long LDA #'['
.3a80e0	20 18 00	jsr $3a0018	            JSR PRINTC
.3a80e3	22 ff 80 3a	jsl $3a80ff	                JSL DS_PR_OPERAND2      ; Print [dddd]
.3a80e7	a9 5d		lda #$5d	                LDA #']'
.3a80e9	20 18 00	jsr $3a0018	            JSR PRINTC
.3a80ec	4c ef 80	jmp $3a80ef	                JMP done_1
.3a80ef	22 22 87 3a	jsl $3a8722	done_1          JSL M_INC_CURSOR    ; Skip over a single byte operand
.3a80f3	28		plp		done            PLP
.3a80f4	6b		rtl		                RTL
.3a80f5					DS_PR_OPERAND1
.3a80f5	08		php		                PHP
.3a80f6	e2 20		sep #$20	            SEP #$20
.3a80f8	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a80fa	20 8e 04	jsr $3a048e	            JSR PRHEXB
.3a80fd	28		plp		                PLP
.3a80fe	6b		rtl		                RTL
.3a80ff					DS_PR_OPERAND2
.3a80ff	08		php		                PHP
.3a8100	c2 30		rep #$30	            REP #$30
.3a8102	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a8104	20 74 04	jsr $3a0474	            JSR PRHEXW
.3a8107	22 22 87 3a	jsl $3a8722	                JSL M_INC_CURSOR
.3a810b	28		plp		                PLP
.3a810c	6b		rtl		                RTL
.3a810d					DS_PR_OPERAND3
.3a810d	08		php		                PHP
.3a810e	8b		phb		                PHB
.3a810f	0b		phd		                PHD
.3a8110	c2 30		rep #$30	            REP #$30
.3a8112	5a		phy		                PHY
.3a8113	08		php		            PHP
.3a8114	c2 20		rep #$20	            REP #$20
.3a8116	48		pha		            PHA
.3a8117	a9 7a 08	lda #$087a	            LDA #MCURSOR
.3a811a	5b		tcd		            TCD
.3a811b	68		pla		            PLA
.3a811c	28		plp		            PLP
.3a811d	08		php		            PHP
.3a811e	e2 20		sep #$20	            SEP #$20
.3a8120	48		pha		            PHA
.3a8121	a9 00		lda #$00	            LDA #`MTEMP
.3a8123	48		pha		            PHA
.3a8124	ab		plb		            PLB
.3a8125	68		pla		            PLA
.3a8126	28		plp		            PLP
.3a8127	e2 20		sep #$20	            SEP #$20
.3a8129	a0 00 00	ldy #$0000	                LDY #0
.3a812c	a7 00		lda [$087a]	copy_loop       LDA [MCURSOR]       ; Copy the address pointed to by MCURSOR
.3a812e	99 92 08	sta $0892,y	                STA MTEMP,Y         ; to MTEMP
.3a8131	22 22 87 3a	jsl $3a8722	                JSL M_INC_CURSOR
.3a8135	c8		iny		                INY
.3a8136	c0 03 00	cpy #$0003	                CPY #3
.3a8139	d0 f1		bne $3a812c	                BNE copy_loop
.3a813b	22 cc 81 3a	jsl $3a81cc	                JSL M_PR_ADDR       ; Print the address
.3a813f	c2 30		rep #$30	            REP #$30
.3a8141	7a		ply		                PLY
.3a8142	2b		pld		                PLD
.3a8143	ab		plb		                PLB
.3a8144	28		plp		                PLP
.3a8145	6b		rtl		                RTL
.3a8146					DS_PR_MNEMONIC
.3a8146	08		php		                PHP
.3a8147	8b		phb		                PHB
.3a8148	e2 20		sep #$20	            SEP #$20
.3a814a	c2 10		rep #$10	            REP #$10
.3a814c	08		php		            PHP
.3a814d	e2 20		sep #$20	            SEP #$20
.3a814f	48		pha		            PHA
.3a8150	a9 3a		lda #$3a	            LDA #`MN_ORA
.3a8152	48		pha		            PHA
.3a8153	ab		plb		            PLB
.3a8154	68		pla		            PLA
.3a8155	28		plp		            PLP
.3a8156	bd 00 00	lda $3a0000,x	                LDA #0,B,X
.3a8159	20 18 00	jsr $3a0018	            JSR PRINTC
.3a815c	e8		inx		                INX
.3a815d	bd 00 00	lda $3a0000,x	                LDA #0,B,X
.3a8160	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8163	e8		inx		                INX
.3a8164	bd 00 00	lda $3a0000,x	                LDA #0,B,X
.3a8167	20 18 00	jsr $3a0018	            JSR PRINTC
.3a816a	e8		inx		                INX
.3a816b	a9 20		lda #$20	                LDA #' '            ; Print a space
.3a816d	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8170	ab		plb		                PLB
.3a8171	28		plp		                PLP
.3a8172	6b		rtl		                RTL
.3a8173					DS_PR_PCREL
.3a8173	08		php		                PHP
.3a8174	0b		phd		                PHD
.3a8175	08		php		            PHP
.3a8176	c2 20		rep #$20	            REP #$20
.3a8178	48		pha		            PHA
.3a8179	a9 7a 08	lda #$087a	            LDA #MCURSOR
.3a817c	5b		tcd		            TCD
.3a817d	68		pla		            PLA
.3a817e	28		plp		            PLP
.3a817f	e2 20		sep #$20	            SEP #$20
.3a8181	c0 02 00	cpy #$0002	                CPY #2
.3a8184	f0 14		beq $3a819a	                BEQ offset_2
.3a8186	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a8188	85 18		sta $0892	                STA MTEMP
.3a818a	30 06		bmi $3a8192	                BMI is_negative
.3a818c	64 19		stz $0893	                STZ MTEMP+1
.3a818e	64 1a		stz $0894	                STZ MTEMP+2
.3a8190	80 1e		bra $3a81b0	                BRA add_offset
.3a8192	a9 ff		lda #$ff	is_negative     LDA #$FF
.3a8194	85 19		sta $0893	                STA MTEMP+1
.3a8196	85 1a		sta $0894	                STA MTEMP+2
.3a8198	80 16		bra $3a81b0	                BRA add_offset
.3a819a	a7 00		lda [$087a]	offset_2        LDA [MCURSOR]
.3a819c	85 18		sta $0892	                STA MTEMP
.3a819e	22 22 87 3a	jsl $3a8722	                JSL M_INC_CURSOR
.3a81a2	a7 00		lda [$087a]	                LDA [MCURSOR]
.3a81a4	85 19		sta $0893	                STA MTEMP+1
.3a81a6	30 04		bmi $3a81ac	                BMI is_negative2
.3a81a8	64 1a		stz $0894	                STZ MTEMP+2
.3a81aa	80 04		bra $3a81b0	                BRA add_offset
.3a81ac	a9 ff		lda #$ff	is_negative2    LDA #$FF
.3a81ae	85 1a		sta $0894	                STA MTEMP+2
.3a81b0					add_offset
.3a81b0	c2 20		rep #$20	            REP #$20
.3a81b2	38		sec		                SEC             ; Add 1 to the offset
.3a81b3	a5 00		lda $087a	                LDA MCURSOR
.3a81b5	65 18		adc $0892	                ADC MTEMP
.3a81b7	85 18		sta $0892	                STA MTEMP
.3a81b9	e2 20		sep #$20	            SEP #$20
.3a81bb	a5 02		lda $087c	                LDA MCURSOR+2
.3a81bd	65 1a		adc $0894	                ADC MTEMP+2
.3a81bf	85 1a		sta $0894	                STA MTEMP+2
.3a81c1	22 cc 81 3a	jsl $3a81cc	                JSL M_PR_ADDR
.3a81c5	22 22 87 3a	jsl $3a8722	                JSL M_INC_CURSOR
.3a81c9	2b		pld		                PLD
.3a81ca	28		plp		                PLP
.3a81cb	6b		rtl		                RTL
.3a81cc					M_PR_ADDR
.3a81cc	08		php		                PHP
.3a81cd	0b		phd		                PHD
.3a81ce	c2 20		rep #$20	            REP #$20
.3a81d0	48		pha		                PHA
.3a81d1	08		php		            PHP
.3a81d2	c2 20		rep #$20	            REP #$20
.3a81d4	48		pha		            PHA
.3a81d5	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a81d8	5b		tcd		            TCD
.3a81d9	68		pla		            PLA
.3a81da	28		plp		            PLP
.3a81db	e2 20		sep #$20	            SEP #$20
.3a81dd	a5 4c		lda $0894	                LDA MTEMP+2     ; Print the bank byte of the address
.3a81df	20 8e 04	jsr $3a048e	            JSR PRHEXB
.3a81e2	e2 20		sep #$20	            SEP #$20
.3a81e4	a9 3a		lda #$3a	                LDA #':'
.3a81e6	20 18 00	jsr $3a0018	            JSR PRINTC
.3a81e9	c2 20		rep #$20	            REP #$20
.3a81eb	a5 4a		lda $0892	                LDA MTEMP       ; Print the lower 16-bits of the address
.3a81ed	20 74 04	jsr $3a0474	            JSR PRHEXW
.3a81f0	68		pla		                PLA
.3a81f1	2b		pld		                PLD
.3a81f2	28		plp		                PLP
.3a81f3	6b		rtl		                RTL
.3a81f4					MNEMONICS_TAB
.3a81f4					MN_ORA
>3a81f4	4f 52 41 00			            .null "ORA"
.3a81f8					MN_AND
>3a81f8	41 4e 44 00			            .null "AND"
.3a81fc					MN_EOR
>3a81fc	45 4f 52 00			            .null "EOR"
.3a8200					MN_ADC
>3a8200	41 44 43 00			            .null "ADC"
.3a8204					MN_STA
>3a8204	53 54 41 00			            .null "STA"
.3a8208					MN_LDA
>3a8208	4c 44 41 00			            .null "LDA"
.3a820c					MN_CMP
>3a820c	43 4d 50 00			            .null "CMP"
.3a8210					MN_SBC
>3a8210	53 42 43 00			            .null "SBC"
.3a8214					MN_ASL
>3a8214	41 53 4c 00			            .null "ASL"
.3a8218					MN_ROL
>3a8218	52 4f 4c 00			            .null "ROL"
.3a821c					MN_LSR
>3a821c	4c 53 52 00			            .null "LSR"
.3a8220					MN_ROR
>3a8220	52 4f 52 00			            .null "ROR"
.3a8224					MN_STX
>3a8224	53 54 58 00			            .null "STX"
.3a8228					MN_LDX
>3a8228	4c 44 58 00			            .null "LDX"
.3a822c					MN_DEC
>3a822c	44 45 43 00			            .null "DEC"
.3a8230					MN_INC
>3a8230	49 4e 43 00			            .null "INC"
.3a8234					MN_BIT
>3a8234	42 49 54 00			            .null "BIT"
.3a8238					MN_JMP
>3a8238	4a 4d 50 00			            .null "JMP"
.3a823c					MN_STY
>3a823c	53 54 59 00			            .null "STY"
.3a8240					MN_LDY
>3a8240	4c 44 59 00			            .null "LDY"
.3a8244					MN_CPY
>3a8244	43 50 59 00			            .null "CPY"
.3a8248					MN_CPX
>3a8248	43 50 58 00			            .null "CPX"
.3a824c					MN_BRK
>3a824c	42 52 4b 00			            .null "BRK"
.3a8250					MN_JSR
>3a8250	4a 53 52 00			            .null "JSR"
.3a8254					MN_RTI
>3a8254	52 54 49 00			            .null "RTI"
.3a8258					MN_RTS
>3a8258	52 54 53 00			            .null "RTS"
.3a825c					MN_PHP
>3a825c	50 48 50 00			            .null "PHP"
.3a8260					MN_PLP
>3a8260	50 4c 50 00			            .null "PLP"
.3a8264					MN_PHA
>3a8264	50 48 41 00			            .null "PHA"
.3a8268					MN_PLA
>3a8268	50 4c 41 00			            .null "PLA"
.3a826c					MN_DEY
>3a826c	44 45 59 00			            .null "DEY"
.3a8270					MN_TAY
>3a8270	54 41 59 00			            .null "TAY"
.3a8274					MN_INY
>3a8274	49 4e 59 00			            .null "INY"
.3a8278					MN_INX
>3a8278	49 4e 58 00			            .null "INX"
.3a827c					MN_CLC
>3a827c	43 4c 43 00			            .null "CLC"
.3a8280					MN_SEC
>3a8280	53 45 43 00			            .null "SEC"
.3a8284					MN_CLI
>3a8284	43 4c 49 00			            .null "CLI"
.3a8288					MN_SEI
>3a8288	53 45 49 00			            .null "SEI"
.3a828c					MN_TYA
>3a828c	54 59 41 00			            .null "TYA"
.3a8290					MN_CLV
>3a8290	43 4c 56 00			            .null "CLV"
.3a8294					MN_CLD
>3a8294	43 4c 44 00			            .null "CLD"
.3a8298					MN_SED
>3a8298	53 45 44 00			            .null "SED"
.3a829c					MN_TXA
>3a829c	54 58 41 00			            .null "TXA"
.3a82a0					MN_TXS
>3a82a0	54 58 53 00			            .null "TXS"
.3a82a4					MN_TAX
>3a82a4	54 41 58 00			            .null "TAX"
.3a82a8					MN_TSX
>3a82a8	54 53 58 00			            .null "TSX"
.3a82ac					MN_DEX
>3a82ac	44 45 58 00			            .null "DEX"
.3a82b0					MN_NOP
>3a82b0	4e 4f 50 00			            .null "NOP"
.3a82b4					MN_BPL
>3a82b4	42 50 4c 00			            .null "BPL"
.3a82b8					MN_BMI
>3a82b8	42 4d 49 00			            .null "BMI"
.3a82bc					MN_BVC
>3a82bc	42 56 43 00			            .null "BVC"
.3a82c0					MN_BVS
>3a82c0	42 56 53 00			            .null "BVS"
.3a82c4					MN_BCC
>3a82c4	42 43 43 00			            .null "BCC"
.3a82c8					MN_BCS
>3a82c8	42 43 53 00			            .null "BCS"
.3a82cc					MN_BNE
>3a82cc	42 4e 45 00			            .null "BNE"
.3a82d0					MN_BEQ
>3a82d0	42 45 51 00			            .null "BEQ"
.3a82d4					MN_TSB
>3a82d4	54 53 42 00			            .null "TSB"
.3a82d8					MN_TRB
>3a82d8	54 52 42 00			            .null "TRB"
.3a82dc					MN_STZ
>3a82dc	53 54 5a 00			            .null "STZ"
.3a82e0					MN_BRA
>3a82e0	42 52 41 00			            .null "BRA"
.3a82e4					MN_PHY
>3a82e4	50 48 59 00			            .null "PHY"
.3a82e8					MN_PLY
>3a82e8	50 4c 59 00			            .null "PLY"
.3a82ec					MN_PHX
>3a82ec	50 48 58 00			            .null "PHX"
.3a82f0					MN_PLX
>3a82f0	50 4c 58 00			            .null "PLX"
.3a82f4					MN_PHD
>3a82f4	50 48 44 00			            .null "PHD"
.3a82f8					MN_PLD
>3a82f8	50 4c 44 00			            .null "PLD"
.3a82fc					MN_PHK
>3a82fc	50 48 4b 00			            .null "PHK"
.3a8300					MN_RTL
>3a8300	52 54 4c 00			            .null "RTL"
.3a8304					MN_PHB
>3a8304	50 48 42 00			            .null "PHB"
.3a8308					MN_PLB
>3a8308	50 4c 42 00			            .null "PLB"
.3a830c					MN_WAI
>3a830c	57 41 49 00			            .null "WAI"
.3a8310					MN_XBA
>3a8310	58 42 41 00			            .null "XBA"
.3a8314					MN_TCS
>3a8314	54 43 53 00			            .null "TCS"
.3a8318					MN_TSC
>3a8318	54 53 43 00			            .null "TSC"
.3a831c					MN_TCD
>3a831c	54 43 44 00			            .null "TCD"
.3a8320					MN_TDC
>3a8320	54 44 43 00			            .null "TDC"
.3a8324					MN_TXY
>3a8324	54 58 59 00			            .null "TXY"
.3a8328					MN_TYX
>3a8328	54 59 58 00			            .null "TYX"
.3a832c					MN_STP
>3a832c	53 54 50 00			            .null "STP"
.3a8330					MN_XCE
>3a8330	58 43 45 00			            .null "XCE"
.3a8334					MN_COP
>3a8334	43 4f 50 00			            .null "COP"
.3a8338					MN_JSL
>3a8338	4a 53 4c 00			            .null "JSL"
.3a833c					MN_WDM
>3a833c	57 44 4d 00			            .null "WDM"
.3a8340					MN_PER
>3a8340	50 45 52 00			            .null "PER"
.3a8344					MN_BRL
>3a8344	42 52 4c 00			            .null "BRL"
.3a8348					MN_REP
>3a8348	52 45 50 00			            .null "REP"
.3a834c					MN_SEP
>3a834c	53 45 50 00			            .null "SEP"
.3a8350					MN_MVP
>3a8350	4d 56 50 00			            .null "MVP"
.3a8354					MN_MVN
>3a8354	4d 56 4e 00			            .null "MVN"
.3a8358					MN_PEI
>3a8358	50 45 49 00			            .null "PEI"
.3a835c					MN_PEA
>3a835c	50 45 41 00			            .null "PEA"
.3a8360					MN_JML
>3a8360	4a 4d 4c 00			            .null "JML"
>3a8364	00 00				            .byte 0, 0
>3a8366	4c 82 f4 81 34 83 f4 81		MNEMONIC_TAB    .word <>MN_BRK, <>MN_ORA, <>MN_COP, <>MN_ORA, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 0x
>3a836e	d4 82 f4 81 14 82 f4 81
>3a8376	5c 82 f4 81 14 82 f4 82		                .word <>MN_PHP, <>MN_ORA, <>MN_ASL, <>MN_PHD, <>MN_TSB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>3a837e	d4 82 f4 81 14 82 f4 81
>3a8386	b4 82 f4 81 f4 81 f4 81		                .word <>MN_BPL, <>MN_ORA, <>MN_ORA, <>MN_ORA, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA    ; 1x
>3a838e	d8 82 f4 81 14 82 f4 81
>3a8396	7c 82 f4 81 30 82 14 83		                .word <>MN_CLC, <>MN_ORA, <>MN_INC, <>MN_TCS, <>MN_TRB, <>MN_ORA, <>MN_ASL, <>MN_ORA
>3a839e	d8 82 f4 81 14 82 f4 81
>3a83a6	50 82 f8 81 38 83 f8 81		                .word <>MN_JSR, <>MN_AND, <>MN_JSL, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 2x
>3a83ae	34 82 f8 81 18 82 f8 81
>3a83b6	60 82 f8 81 18 82 f8 82		                .word <>MN_PLP, <>MN_AND, <>MN_ROL, <>MN_PLD, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>3a83be	34 82 f8 81 18 82 f8 81
>3a83c6	b8 82 f8 81 f8 81 f8 81		                .word <>MN_BMI, <>MN_AND, <>MN_AND, <>MN_AND, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND    ; 3x
>3a83ce	34 82 f8 81 18 82 f8 81
>3a83d6	80 82 f8 81 2c 82 18 83		                .word <>MN_SEC, <>MN_AND, <>MN_DEC, <>MN_TSC, <>MN_BIT, <>MN_AND, <>MN_ROL, <>MN_AND
>3a83de	34 82 f8 81 18 82 f8 81
>3a83e6	54 82 fc 81 3c 83 fc 81		                .word <>MN_RTI, <>MN_EOR, <>MN_WDM, <>MN_EOR, <>MN_MVP, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 4x
>3a83ee	50 83 fc 81 1c 82 fc 81
>3a83f6	64 82 fc 81 1c 82 fc 82		                .word <>MN_PHA, <>MN_EOR, <>MN_LSR, <>MN_PHK, <>MN_JMP, <>MN_EOR, <>MN_LSR, <>MN_EOR
>3a83fe	38 82 fc 81 1c 82 fc 81
>3a8406	bc 82 fc 81 fc 81 fc 81		                .word <>MN_BVC, <>MN_EOR, <>MN_EOR, <>MN_EOR, <>MN_MVN, <>MN_EOR, <>MN_LSR, <>MN_EOR    ; 5x
>3a840e	54 83 fc 81 1c 82 fc 81
>3a8416	84 82 fc 81 e4 82 1c 83		                .word <>MN_CLI, <>MN_EOR, <>MN_PHY, <>MN_TCD, <>MN_JML, <>MN_EOR, <>MN_LSR, <>MN_EOR
>3a841e	60 83 fc 81 1c 82 fc 81
>3a8426	58 82 00 82 40 83 00 82		                .word <>MN_RTS, <>MN_ADC, <>MN_PER, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 6x
>3a842e	dc 82 00 82 20 82 00 82
>3a8436	68 82 00 82 20 82 00 83		                .word <>MN_PLA, <>MN_ADC, <>MN_ROR, <>MN_RTL, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>3a843e	38 82 00 82 20 82 00 82
>3a8446	c0 82 00 82 00 82 00 82		                .word <>MN_BVS, <>MN_ADC, <>MN_ADC, <>MN_ADC, <>MN_STZ, <>MN_ADC, <>MN_ROR, <>MN_ADC    ; 7x
>3a844e	dc 82 00 82 20 82 00 82
>3a8456	88 82 00 82 e8 82 20 83		                .word <>MN_SEI, <>MN_ADC, <>MN_PLY, <>MN_TDC, <>MN_JMP, <>MN_ADC, <>MN_ROR, <>MN_ADC
>3a845e	38 82 00 82 20 82 00 82
>3a8466	e0 82 04 82 44 83 04 82		                .word <>MN_BRA, <>MN_STA, <>MN_BRL, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 8x
>3a846e	3c 82 04 82 24 82 04 82
>3a8476	6c 82 34 82 9c 82 04 83		                .word <>MN_DEY, <>MN_BIT, <>MN_TXA, <>MN_PHB, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA
>3a847e	3c 82 04 82 24 82 04 82
>3a8486	c4 82 04 82 04 82 04 82		                .word <>MN_BCC, <>MN_STA, <>MN_STA, <>MN_STA, <>MN_STY, <>MN_STA, <>MN_STX, <>MN_STA    ; 9x
>3a848e	3c 82 04 82 24 82 04 82
>3a8496	8c 82 04 82 a0 82 24 83		                .word <>MN_TYA, <>MN_STA, <>MN_TXS, <>MN_TXY, <>MN_STZ, <>MN_STA, <>MN_STZ, <>MN_STA
>3a849e	dc 82 04 82 dc 82 04 82
>3a84a6	40 82 08 82 28 82 08 82		                .word <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Ax
>3a84ae	40 82 08 82 28 82 08 82
>3a84b6	70 82 08 82 a4 82 08 83		                .word <>MN_TAY, <>MN_LDA, <>MN_TAX, <>MN_PLB, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>3a84be	40 82 08 82 28 82 08 82
>3a84c6	c8 82 08 82 08 82 08 82		                .word <>MN_BCS, <>MN_LDA, <>MN_LDA, <>MN_LDA, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA    ; Bx
>3a84ce	40 82 08 82 28 82 08 82
>3a84d6	90 82 08 82 a8 82 28 83		                .word <>MN_CLV, <>MN_LDA, <>MN_TSX, <>MN_TYX, <>MN_LDY, <>MN_LDA, <>MN_LDX, <>MN_LDA
>3a84de	40 82 08 82 28 82 08 82
>3a84e6	44 82 0c 82 48 83 0c 82		                .word <>MN_CPY, <>MN_CMP, <>MN_REP, <>MN_CMP, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Cx
>3a84ee	44 82 0c 82 2c 82 0c 82
>3a84f6	74 82 0c 82 ac 82 0c 83		                .word <>MN_INY, <>MN_CMP, <>MN_DEX, <>MN_WAI, <>MN_CPY, <>MN_CMP, <>MN_DEC, <>MN_CMP
>3a84fe	44 82 0c 82 2c 82 0c 82
>3a8506	cc 82 0c 82 0c 82 0c 82		                .word <>MN_BNE, <>MN_CMP, <>MN_CMP, <>MN_CMP, <>MN_PEI, <>MN_CMP, <>MN_DEC, <>MN_CMP    ; Dx
>3a850e	58 83 0c 82 2c 82 0c 82
>3a8516	94 82 0c 82 ec 82 2c 83		                .word <>MN_CLD, <>MN_CMP, <>MN_PHX, <>MN_STP, <>MN_JML, <>MN_CMP, <>MN_DEC, <>MN_CMP
>3a851e	60 83 0c 82 2c 82 0c 82
>3a8526	48 82 10 82 4c 83 10 82		                .word <>MN_CPX, <>MN_SBC, <>MN_SEP, <>MN_SBC, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Ex
>3a852e	48 82 10 82 30 82 10 82
>3a8536	78 82 10 82 b0 82 10 83		                .word <>MN_INX, <>MN_SBC, <>MN_NOP, <>MN_XBA, <>MN_CPX, <>MN_SBC, <>MN_INC, <>MN_SBC
>3a853e	48 82 10 82 30 82 10 82
>3a8546	d0 82 10 82 10 82 10 82		                .word <>MN_BEQ, <>MN_SBC, <>MN_SBC, <>MN_SBC, <>MN_PEA, <>MN_SBC, <>MN_INC, <>MN_SBC    ; Fx
>3a854e	5c 83 10 82 30 82 10 82
>3a8556	98 82 10 82 f0 82 30 83		                .word <>MN_SED, <>MN_SBC, <>MN_PLX, <>MN_XCE, <>MN_JSR, <>MN_SBC, <>MN_INC, <>MN_SBC
>3a855e	50 82 10 82 30 82 10 82
>3a8566	00 00				                .word 0
>3a8568	13 00 02 09			ADDRESS_TAB     .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R                  ; 0x
>3a856c	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a8570	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>3a8574	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a8578	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 1x
>3a857c	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a8580	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>3a8584	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a8588	03 00 0b 09			                .byte ADDR_ABS, ADDR_DP_IND_X, ADDR_ABS_LONG, ADDR_SP_R                 ; 2x
>3a858c	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a8590	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>3a8594	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a8598	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 3x
>3a859c	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a85a0	13 06 08 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_ACC, ADDR_IMPLIED
>3a85a4	07 07 07 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a85a8	13 00 13 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_IMPLIED, ADDR_SP_R              ; 4x
>3a85ac	14 01 01 0a			                .byte ADDR_XYC, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a85b0	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>3a85b4	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a85b8	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 5x
>3a85bc	14 05 05 0d			                .byte ADDR_XYC, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a85c0	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a85c4	0b 07 07 0b			                .byte ADDR_ABS_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_LONG
>3a85c8	13 00 16 09			                .byte ADDR_IMPLIED, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R          ; 6x
>3a85cc	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a85d0	13 82 08 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_ACC, ADDR_IMPLIED
>3a85d4	15 03 03 0b			                .byte ADDR_ABS_IND, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a85d8	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 7x
>3a85dc	05 05 05 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a85e0	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a85e4	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a85e8	12 00 16 09			                .byte ADDR_PC_REL, ADDR_DP_IND_X, ADDR_PC_REL_LONG, ADDR_SP_R           ; 8x
>3a85ec	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a85f0	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>3a85f4	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a85f8	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; 9x
>3a85fc	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>3a8600	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a8604	03 07 07 0e			                .byte ADDR_ABS, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a8608	82 00 42 09			                .byte ADDR_IMM | OP_M_EFFECT, ADDR_DP_IND_X, ADDR_IMM | OP_X_EFFECT, ADDR_SP_R  ; Ax
>3a860c	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a8610	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>3a8614	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a8618	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Bx
>3a861c	05 05 11 0d			                .byte ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y, ADDR_DP_Y_LONG
>3a8620	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a8624	07 07 06 0e			                .byte ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_Y, ADDR_ABS_X_LONG
>3a8628	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Cx
>3a862c	01 01 01 0a			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_LONG
>3a8630	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>3a8634	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a8638	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Dx
>3a863c	01 05 05 0d			                .byte ADDR_DP, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a8640	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a8644	17 07 07 0e			                .byte ADDR_ABS_IND_LONG, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a8648	42 00 02 09			                .byte ADDR_IMM | OP_X_EFFECT, ADDR_DP_IND_X, ADDR_IMM, ADDR_SP_R        ; Ex
>3a864c	01 01 01 0f			                .byte ADDR_DP, ADDR_DP, ADDR_DP, ADDR_DP_IND
>3a8650	13 82 13 13			                .byte ADDR_IMPLIED, ADDR_IMM | OP_M_EFFECT, ADDR_IMPLIED, ADDR_IMPLIED
>3a8654	03 03 03 0b			                .byte ADDR_ABS, ADDR_ABS, ADDR_ABS, ADDR_ABS_LONG
>3a8658	12 04 0f 0c			                .byte ADDR_PC_REL, ADDR_DP_IND_Y, ADDR_DP_IND, ADDR_SP_R_Y              ; Fx
>3a865c	03 05 05 0d			                .byte ADDR_ABS, ADDR_DP_X, ADDR_DP_X, ADDR_DP_Y_LONG
>3a8660	13 06 13 13			                .byte ADDR_IMPLIED, ADDR_ABS_Y, ADDR_IMPLIED, ADDR_IMPLIED
>3a8664	10 07 07 0e			                .byte ADDR_ABS_X_ID, ADDR_ABS_X, ADDR_ABS_X, ADDR_ABS_X_LONG
>3a8668	01 01 01 02 01 01 02 02		ADDR_LENGTH     .byte 1, 1, 1, 2, 1, 1, 2, 2, 0, 1, 1, 3, 1, 1, 3, 1, 2, 1, 1, 0, 2, 2, 2, 2
>3a8670	00 01 01 03 01 01 03 01 02 01 01 00 02 02 02 02
.3a8680					ADDR_PATTERNS
>3a8680	41 00				            .null "A"
>3a8682	08				            .byte ADDR_ACC
>3a8683	64 64 3a 64 64 64 64 2c		            .null "dd:dddd,X"
>3a868b	58 00
>3a868d	0e				            .byte ADDR_ABS_X_LONG
>3a868e	64 64 3a 64 64 64 64 00		            .null "dd:dddd"
>3a8696	0b				            .byte ADDR_ABS_LONG
>3a8697	64 64 64 64 2c 58 00		            .null "dddd,X"
>3a869e	07				            .byte ADDR_ABS_X
>3a869f	64 64 64 64 2c 59 00		            .null "dddd,Y"
>3a86a6	06				            .byte ADDR_ABS_Y
>3a86a7	64 64 64 64 00			            .null "dddd"
>3a86ac	03				            .byte ADDR_ABS
>3a86ad	64 64 2c 58 00			            .null "dd,X"
>3a86b2	05				            .byte ADDR_DP_X
>3a86b3	64 64 2c 59 00			            .null "dd,Y"
>3a86b8	11				            .byte ADDR_DP_Y
>3a86b9	64 64 2c 53 00			            .null "dd,S"
>3a86be	09				            .byte ADDR_SP_R
>3a86bf	64 64 00			            .null "dd"
>3a86c2	01				            .byte ADDR_DP
>3a86c3	23 64 64 64 64 00		            .null "#dddd"
>3a86c9	c2				            .byte ADDR_IMM | OP_M_EFFECT | OP_X_EFFECT
>3a86ca	23 64 64 2c 23 64 64 00		            .null "#dd,#dd"
>3a86d2	14				            .byte ADDR_XYC
>3a86d3	23 64 64 00			            .null "#dd"
>3a86d7	02				            .byte ADDR_IMM
>3a86d8	28 64 64 2c 53 29 2c 59		            .null "(dd,S),Y"
>3a86e0	00
>3a86e1	0c				            .byte ADDR_SP_R_Y
>3a86e2	28 64 64 64 64 2c 58 29		            .null "(dddd,X)"
>3a86ea	00
>3a86eb	10				            .byte ADDR_ABS_X_ID
>3a86ec	28 64 64 64 64 29 00		            .null "(dddd)"
>3a86f3	10				            .byte ADDR_ABS_X_ID
>3a86f4	28 64 64 2c 58 29 00		            .null "(dd,X)"
>3a86fb	00				            .byte ADDR_DP_IND_X
>3a86fc	28 64 64 29 2c 59 00		            .null "(dd),Y"
>3a8703	04				            .byte ADDR_DP_IND_Y
>3a8704	28 64 64 29 00			            .null "(dd)"
>3a8709	0f				            .byte ADDR_DP_IND
>3a870a	5b 64 64 64 64 5d 00		            .null "[dddd]"
>3a8711	17				            .byte ADDR_ABS_IND_LONG
>3a8712	5b 64 64 5d 2c 59 00		            .null "[dd],Y"
>3a8719	0d				            .byte ADDR_DP_Y_LONG
>3a871a	5b 64 64 5d 00			            .null "[dd]"
>3a871f	0a				            .byte ADDR_DP_LONG
>3a8720	00 00				                .byte 0, 0

;******  Return to file: src\monitor.s

.3a8722					M_INC_CURSOR
.3a8722	08		php		                PHP
.3a8723	c2 20		rep #$20	            REP #$20
.3a8725	48		pha		                PHA
.3a8726	18		clc		                CLC
.3a8727	af 7a 08 00	lda $00087a	                LDA MCURSOR
.3a872b	69 01 00	adc #$0001	                ADC #1
.3a872e	8f 7a 08 00	sta $00087a	                STA MCURSOR
.3a8732	e2 20		sep #$20	            SEP #$20
.3a8734	af 7c 08 00	lda $00087c	                LDA MCURSOR+2
.3a8738	69 00		adc #$00	                ADC #0
.3a873a	8f 7c 08 00	sta $00087c	                STA MCURSOR+2
.3a873e	c2 20		rep #$20	            REP #$20
.3a8740	68		pla		                PLA
.3a8741	28		plp		                PLP
.3a8742	6b		rtl		                RTL
.3a8743					MPRINTB
.3a8743	08		php		                PHP
.3a8744	c2 10		rep #$10	            REP #$10
.3a8746	e2 20		sep #$20	            SEP #$20
.3a8748	da		phx		                PHX
.3a8749	a2 08 00	ldx #$0008	                LDX #8          ; Set number of bits to print to 8
.3a874c	0a		asl a		loop            ASL A           ; Shift MSB to C
.3a874d	b0 08		bcs $3a8757	                BCS is_one
.3a874f	48		pha		                PHA             ; Save value to print
.3a8750	a9 30		lda #$30	                LDA #'0'        ; Print '0'
.3a8752	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8755	80 06		bra $3a875d	                BRA continue
.3a8757	48		pha		is_one          PHA             ; Save value to print
.3a8758	a9 31		lda #$31	                LDA #'1'        ; Print '1'
.3a875a	20 18 00	jsr $3a0018	            JSR PRINTC
.3a875d	68		pla		continue        PLA
.3a875e	ca		dex		                DEX             ; Count down the bits to shift
.3a875f	d0 eb		bne $3a874c	                BNE loop        ; And try the next one if there is one
.3a8761	fa		plx		                PLX             ; Otherwise, return
.3a8762	28		plp		                PLP
.3a8763	6b		rtl		                RTL
.3a8764					MSKIPWS
.3a8764	08		php		            PHP
.3a8765	c2 20		rep #$20	            REP #$20
.3a8767	48		pha		            PHA
.3a8768	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a876b	5b		tcd		            TCD
.3a876c	68		pla		            PLA
.3a876d	28		plp		            PLP
.3a876e	e2 20		sep #$20	            SEP #$20
.3a8770	a7 32		lda [$087a]	loop            LDA [MCURSOR]       ; Check the current character
.3a8772	f0 0a		beq $3a877e	                BEQ done            ; If NULL, we're done
.3a8774	c9 20		cmp #$20	                CMP #' '            ; Is it a space?
.3a8776	d0 06		bne $3a877e	                BNE done            ; No: we're done
.3a8778	22 22 87 3a	jsl $3a8722	                JSL M_INC_CURSOR    ; Yes, try the next one
.3a877c	80 f2		bra $3a8770	                BRA loop
.3a877e	6b		rtl		done            RTL
.3a877f					MPARSESTR
.3a877f	08		php		                PHP
.3a8780	08		php		            PHP
.3a8781	c2 20		rep #$20	            REP #$20
.3a8783	48		pha		            PHA
.3a8784	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a8787	5b		tcd		            TCD
.3a8788	68		pla		            PLA
.3a8789	28		plp		            PLP
.3a878a	22 22 87 3a	jsl $3a8722	                JSL M_INC_CURSOR                ; Point to the first character of the name
.3a878e	22 64 87 3a	jsl $3a8764	                JSL MSKIPWS                     ; Skip white space
.3a8792	c2 30		rep #$30	            REP #$30
.3a8794	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.3a8796	c2 20		rep #$20	            REP #$20
.3a8798	29 ff 00	and #$00ff	                AND #$00FF
.3a879b	0a		asl a		                ASL A                           ; multiply it by forfour
.3a879c	0a		asl a		                ASL A
.3a879d	aa		tax		                TAX                             ; ... to get the index to the argument
.3a879e	a5 32		lda $087a	                LDA MCURSOR                     ; Set the argument to the address of the first byte
.3a87a0	95 0d		sta $0855,x	                STA MARG1,X
.3a87a2	a5 34		lda $087c	                LDA MCURSOR+2
.3a87a4	95 0f		sta $0857,x	                STA MARG1+2,X
.3a87a6	e2 20		sep #$20	            SEP #$20
.3a87a8	a7 32		lda [$087a]	loop            LDA [MCURSOR]                   ; Scan to the closing double quote
.3a87aa	f0 14		beq $3a87c0	                BEQ done                        ; If NULL... treat it as a closed argument
.3a87ac	c9 22		cmp #$22	                CMP #CHAR_DQUOTE
.3a87ae	f0 06		beq $3a87b6	                BEQ close_string
.3a87b0	22 22 87 3a	jsl $3a8722	                JSL M_INC_CURSOR
.3a87b4	80 f2		bra $3a87a8	                BRA loop
.3a87b6	a9 00		lda #$00	close_string    LDA #0                          ; Write a NULL to close the string
.3a87b8	87 32		sta [$087a]	                STA [MCURSOR]
.3a87ba	22 22 87 3a	jsl $3a8722	                JSL M_INC_CURSOR                ; And point to the next byte
.3a87be	e6 31		inc $0879	                INC MARG_LEN
.3a87c0	28		plp		done            PLP
.3a87c1	6b		rtl		                RTL
.3a87c2					MPARSEARG
.3a87c2	08		php		            PHP
.3a87c3	c2 20		rep #$20	            REP #$20
.3a87c5	48		pha		            PHA
.3a87c6	a9 48 08	lda #$0848	            LDA #<>MONITOR_VARS
.3a87c9	5b		tcd		            TCD
.3a87ca	68		pla		            PLA
.3a87cb	28		plp		            PLP
.3a87cc	e2 20		sep #$20	            SEP #$20
.3a87ce	64 4a		stz $0892	                STZ MTEMP                       ; Use MTEMP as a flag for having processed digits
.3a87d0	c2 20		rep #$20	            REP #$20
.3a87d2	64 50		stz $0898	                STZ MPARSEDNUM                  ; Clear the parsed number
.3a87d4	64 52		stz $089a	                STZ MPARSEDNUM+2
.3a87d6					pa_loop
.3a87d6	e2 20		sep #$20	            SEP #$20
.3a87d8	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Get the current character
.3a87da	c9 3a		cmp #$3a	                CMP #":"
.3a87dc	f0 0d		beq $3a87eb	                BEQ pa_next_char                ; Ignore any colons
.3a87de	20 0c 05	jsr $3a050c	            JSR ISHEX
.3a87e1	90 0e		bcc $3a87f1	                BCC finished_arg                ; No? We're done with this argument
.3a87e3	22 5a 7c 3a	jsl $3a7c5a	                JSL AS_SHIFT_HEX                ; Yes: shift it onto MPARSEDNUM
.3a87e7	a9 01		lda #$01	                LDA #1                          ; Flag that we've processed a character
.3a87e9	85 4a		sta $0892	                STA MTEMP
.3a87eb	22 22 87 3a	jsl $3a8722	pa_next_char    JSL M_INC_CURSOR                ; And try the next character
.3a87ef	80 e5		bra $3a87d6	                BRA pa_loop
.3a87f1	a5 4a		lda $0892	finished_arg    LDA MTEMP                       ; Check to see if we've processed any characters
.3a87f3	f0 16		beq $3a880b	                BEQ done                        ; No: we're done
.3a87f5	a5 31		lda $0879	                LDA MARG_LEN                    ; Get the argument count
.3a87f7	c2 20		rep #$20	            REP #$20
.3a87f9	29 ff 00	and #$00ff	                AND #$00FF
.3a87fc	0a		asl a		                ASL A                           ; multiply it by forfour
.3a87fd	0a		asl a		                ASL A
.3a87fe	aa		tax		                TAX                             ; ... to get the index to the argument
.3a87ff	a5 50		lda $0898	                LDA MPARSEDNUM                  ; Copy the value to the argument slot
.3a8801	95 0d		sta $0855,x	                STA MARG1,X
.3a8803	a5 52		lda $089a	                LDA MPARSEDNUM+2
.3a8805	95 0f		sta $0857,x	                STA MARG1+2,X
.3a8807	e2 20		sep #$20	            SEP #$20
.3a8809	e6 31		inc $0879	                INC MARG_LEN                    ; And bump up the argument count
.3a880b	6b		rtl		done            RTL
.3a880c					MPARSEALLARG
.3a880c	e2 20		sep #$20	            SEP #$20
.3a880e	64 31		stz $0879	                STZ MARG_LEN                    ; Set the arg count to 0
.3a8810	22 64 87 3a	jsl $3a8764	parse_arg       JSL MSKIPWS                     ; Otherwise, skip white space
.3a8814	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; Check the current character
.3a8816	f0 21		beq $3a8839	                BEQ done                        ; If it is NULL, we're done
.3a8818	c9 22		cmp #$22	                CMP #CHAR_DQUOTE                ; Is it a double-quote?
.3a881a	d0 06		bne $3a8822	                BNE regular_arg
.3a881c	22 7f 87 3a	jsl $3a877f	                JSL MPARSESTR                   ; Yes: parse it as a string argument
.3a8820	80 0a		bra $3a882c	                BRA check_rest
.3a8822	22 c2 87 3a	jsl $3a87c2	regular_arg     JSL MPARSEARG                   ; Attempt to parse the argument
.3a8826	a5 31		lda $0879	                LDA MARG_LEN                    ; Check how many arguments we've processed
.3a8828	c9 09		cmp #$09	                CMP #9
.3a882a	b0 0d		bcs $3a8839	                BGE done                        ; If >=9, then we're done
.3a882c	a7 32		lda [$087a]	check_rest      LDA [MCURSOR]                   ; Check the current character
.3a882e	f0 09		beq $3a8839	                BEQ done                        ; If EOL: we're done
.3a8830	c9 20		cmp #$20	                CMP #' '
.3a8832	f0 dc		beq $3a8810	                BEQ parse_arg                   ; If space: try to process another argument
.3a8834	20 0c 05	jsr $3a050c	            JSR ISHEX
.3a8837	b0 d7		bcs $3a8810	                BCS parse_arg                   ; If hex digit: try to process another argument
.3a8839	6b		rtl		done            RTL
.3a883a					IMPARSE
.3a883a	08		php		                PHP
.3a883b	0b		phd		                PHD
.3a883c	08		php		            PHP
.3a883d	c2 20		rep #$20	            REP #$20
.3a883f	48		pha		            PHA
.3a8840	a9 48 08	lda #$0848	            LDA #MONITOR_VARS
.3a8843	5b		tcd		            TCD
.3a8844	68		pla		            PLA
.3a8845	28		plp		            PLP
.3a8846	c2 10		rep #$10	            REP #$10
.3a8848	e2 20		sep #$20	            SEP #$20
.3a884a	a2 31 00	ldx #$0031	                LDX #MARG_LEN - MONITOR_VARS    ; Clear the monitor command line parameters
.3a884d	74 00		stz $0848,x	clear_command   STZ MONITOR_VARS,X
.3a884f	ca		dex		                DEX
.3a8850	d0 fb		bne $3a884d	                BNE clear_command
.3a8852	a9 00		lda #$00	                LDA #`INPUTBUF                  ; Point the command parser to the input buffer
.3a8854	85 02		sta $084a	                STA MCMDADDR+2
.3a8856	85 34		sta $087c	                STA MCURSOR+2                   ; And point MCURSOR there too
.3a8858	c2 20		rep #$20	            REP #$20
.3a885a	a9 00 4f	lda #$4f00	                LDA #<>INPUTBUF
.3a885d	85 00		sta $0848	                STA MCMDADDR
.3a885f	85 32		sta $087a	                STA MCURSOR
.3a8861	e2 20		sep #$20	            SEP #$20
.3a8863	22 64 87 3a	jsl $3a8764	                JSL MSKIPWS                     ; Skip to the first letter of the command
.3a8867	c9 00		cmp #$00	                CMP #0                          ; Is the current character a NULL?
.3a8869	f0 38		beq $3a88a3	                BEQ done                        ; Yes: there's no command here
.3a886b	c2 20		rep #$20	            REP #$20
.3a886d	a5 32		lda $087a	                LDA MCURSOR
.3a886f	85 08		sta $0850	                STA MCMD
.3a8871	e2 20		sep #$20	            SEP #$20
.3a8873	a5 34		lda $087c	                LDA MCURSOR+2
.3a8875	85 0a		sta $0852	                STA MCMD+2
.3a8877	a2 01 00	ldx #$0001	                LDX #1
.3a887a	22 22 87 3a	jsl $3a8722	cmd_loop        JSL M_INC_CURSOR                ; Move to the next character
.3a887e	a7 32		lda [$087a]	                LDA [MCURSOR]                   ; What is that character?
.3a8880	d0 06		bne $3a8888	                BNE cmd_space                   ; If not NULL: check for a space
.3a8882	86 0b		stx $0853	no_arguments    STX MCMD_LEN                    ; If NULL: Save the length of the command
.3a8884	64 31		stz $0879	                STZ MARG_LEN                    ; ... And the fact there are no arguments
.3a8886	80 1b		bra $3a88a3	                BRA done                        ; ... And return
.3a8888	c9 20		cmp #$20	cmd_space       CMP #' '                        ; Is it a space?
.3a888a	f0 03		beq $3a888f	                BEQ found_cmd                   ; Yes: save the length
.3a888c	e8		inx		                INX                             ; No: go to the next character
.3a888d	80 eb		bra $3a887a	                BRA cmd_loop
.3a888f	86 0b		stx $0853	found_cmd       STX MCMD_LEN                    ; Save the length of the command
.3a8891	a9 00		lda #$00	                LDA #0
.3a8893	87 32		sta [$087a]	                STA [MCURSOR]                   ; Write a NULL to the end of the command
.3a8895	22 22 87 3a	jsl $3a8722	                JSL M_INC_CURSOR                ; And skip to the next character
.3a8899	a7 08		lda [$0850]	                LDA [MCMD]                      ; Check the command
.3a889b	c9 41		cmp #$41	                CMP #'A'
.3a889d	f0 07		beq $3a88a6	                BEQ parse_asm                   ; If 'A', parse the line for the assemble command
.3a889f	22 0c 88 3a	jsl $3a880c	                JSL MPARSEALLARG
.3a88a3	2b		pld		done            PLD
.3a88a4	28		plp		                PLP
.3a88a5	6b		rtl		                RTL
.3a88a6	22 64 87 3a	jsl $3a8764	parse_asm       JSL MSKIPWS                     ; Skip to the first letter of the address
.3a88aa	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a88ac	f0 f5		beq $3a88a3	                BEQ done                        ; Exit if we got the end-of-line
.3a88ae	22 c2 87 3a	jsl $3a87c2	                JSL MPARSEARG                   ; Parse the first argument as the target address
.3a88b2	22 64 87 3a	jsl $3a8764	                JSL MSKIPWS                     ; Skip to the first letter of the mnemonic
.3a88b6	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a88b8	f0 e9		beq $3a88a3	                BEQ done                        ; Exit if we got the end-of-line
.3a88ba	c2 20		rep #$20	            REP #$20
.3a88bc	a5 32		lda $087a	                LDA MCURSOR                     ; Save pointer to the start of the mnemonic
.3a88be	85 11		sta $0859	                STA MARG2
.3a88c0	e2 20		sep #$20	            SEP #$20
.3a88c2	a5 34		lda $087c	                LDA MCURSOR+2
.3a88c4	85 13		sta $085b	                STA MARG2+2
.3a88c6	22 22 87 3a	jsl $3a8722	asm_find_sp     JSL M_INC_CURSOR                ; Find the space at the end of the mnemonic
.3a88ca	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a88cc	f0 26		beq $3a88f4	                BEQ asm_no_operand              ; If EOL: we have an instruction but no operand
.3a88ce	c9 20		cmp #$20	                CMP #' '
.3a88d0	d0 f4		bne $3a88c6	                BNE asm_find_sp
.3a88d2	a9 00		lda #$00	                LDA #0
.3a88d4	87 32		sta [$087a]	                STA [MCURSOR]                   ; Null terminate the mnemonic
.3a88d6	e6 31		inc $0879	                INC MARG_LEN                    ; Count the mnemonic as an argument
.3a88d8	22 22 87 3a	jsl $3a8722	                JSL M_INC_CURSOR
.3a88dc	22 64 87 3a	jsl $3a8764	                JSL MSKIPWS                     ; Skip to the addressing mode
.3a88e0	a7 32		lda [$087a]	                LDA [MCURSOR]
.3a88e2	f0 bf		beq $3a88a3	                BEQ done                        ; If EOL: we're done
.3a88e4	c2 20		rep #$20	            REP #$20
.3a88e6	a5 32		lda $087a	                LDA MCURSOR                     ; Set the pointer to the addressing mode
.3a88e8	85 15		sta $085d	                STA MARG3
.3a88ea	e2 20		sep #$20	            SEP #$20
.3a88ec	a5 34		lda $087c	                LDA MCURSOR+2
.3a88ee	85 17		sta $085f	                STA MARG3+2
.3a88f0	e6 31		inc $0879	                INC MARG_LEN                    ; And count it as the second argument
.3a88f2	80 af		bra $3a88a3	                BRA done                        ; and return
.3a88f4	e6 31		inc $0879	asm_no_operand  INC MARG_LEN                    ; Increment the argument count
.3a88f6	80 ab		bra $3a88a3	                BRA done                        ; And quit
.3a88f8					IMLOAD
.3a88f8	08		php		                PHP
.3a88f9	c2 10		rep #$10	            REP #$10
.3a88fb	e2 20		sep #$20	            SEP #$20
.3a88fd	a5 31		lda $0879	                LDA MARG_LEN
.3a88ff	d0 0f		bne $3a8910	                BNE get_arguments
.3a8901	a2 ee 89	ldx #$89ee	bad_arguments   LDX #<>MERRARGS                 ; Print bad arguments error
.3a8904	a9 3a		lda #$3a	                LDA #`MERRARGS
.3a8906	48		pha		                PHA
.3a8907	ab		plb		                PLB
.3a8908	20 64 04	jsr $3a0464	            JSR PRINTS
.3a890b	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a890e	80 61		bra $3a8971	                BRA done
.3a8910					get_arguments
.3a8910	c2 20		rep #$20	            REP #$20
.3a8912	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.3a8914	8f 23 08 00	sta $000823	                STA ARGUMENT1
.3a8918	a5 0f		lda $0857	                LDA MARG1+2
.3a891a	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.3a891e	20 e1 6a	jsr $3a6ae1	            JSR SETFILEDESC
.3a8921	e2 20		sep #$20	            SEP #$20
.3a8923	a5 31		lda $0879	                LDA MARG_LEN
.3a8925	c9 01		cmp #$01	                CMP #1
.3a8927	d0 0f		bne $3a8938	                BNE get_dest
.3a8929	c2 20		rep #$20	            REP #$20
.3a892b	a9 ff ff	lda #$ffff	                LDA #$FFFF                      ; Destination address not provided...
.3a892e	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR              ; ... set it to something sane
.3a8932	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a8936	80 0e		bra $3a8946	                BRA try_load
.3a8938					get_dest
.3a8938	c2 20		rep #$20	            REP #$20
.3a893a	a5 11		lda $0859	                LDA MARG2                       ; Set the destination address from the arguments
.3a893c	8f 54 03 00	sta $000354	                STA @l DOS_DST_PTR
.3a8940	a5 13		lda $085b	                LDA MARG2+2
.3a8942	8f 56 03 00	sta $000356	                STA @l DOS_DST_PTR+2
.3a8946	22 18 11 00	jsl $001118	try_load        JSL FK_LOAD                     ; Try to load the file
.3a894a	b0 25		bcs $3a8971	                BCS done
.3a894c					error
.3a894c	e2 20		sep #$20	            SEP #$20
.3a894e	a2 14 8a	ldx #$8a14	                LDX #<>MCANTLOAD                ; Print bad arguments error
.3a8951	a9 3a		lda #$3a	                LDA #`MCANTLOAD
.3a8953	48		pha		                PHA
.3a8954	ab		plb		                PLB
.3a8955	20 64 04	jsr $3a0464	            JSR PRINTS
.3a8958	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.3a895c	20 8e 04	jsr $3a048e	            JSR PRHEXB
.3a895f	a9 20		lda #$20	                LDA #' '
.3a8961	20 18 00	jsr $3a0018	            JSR PRINTC
.3a8964	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.3a8968	20 8e 04	jsr $3a048e	            JSR PRHEXB
.3a896b	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a896e	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a8971	28		plp		done            PLP
.3a8972	6b		rtl		                RTL
.3a8973					IMSAVE
.3a8973	8b		phb		                PHB
.3a8974	08		php		                PHP
.3a8975	c2 10		rep #$10	            REP #$10
.3a8977	e2 20		sep #$20	            SEP #$20
.3a8979	a5 31		lda $0879	                LDA MARG_LEN
.3a897b	c9 03		cmp #$03	                CMP #3
.3a897d	f0 0f		beq $3a898e	                BEQ get_arguments
.3a897f	a2 ee 89	ldx #$89ee	                LDX #<>MERRARGS                 ; Print bad arguments error
.3a8982	a9 3a		lda #$3a	                LDA #`MERRARGS
.3a8984	48		pha		                PHA
.3a8985	ab		plb		                PLB
.3a8986	20 64 04	jsr $3a0464	            JSR PRINTS
.3a8989	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a898c	80 54		bra $3a89e2	                BRA done
.3a898e					get_arguments
.3a898e	c2 20		rep #$20	            REP #$20
.3a8990	a5 0d		lda $0855	                LDA MARG1                       ; Set up the file descriptor with out path
.3a8992	8f 23 08 00	sta $000823	                STA ARGUMENT1
.3a8996	a5 0f		lda $0857	                LDA MARG1+2
.3a8998	8f 25 08 00	sta $000825	                STA ARGUMENT1+2
.3a899c	20 e1 6a	jsr $3a6ae1	            JSR SETFILEDESC
.3a899f	a5 11		lda $0859	                LDA MARG2                       ; Set the starting address
.3a89a1	8f 50 03 00	sta $000350	                STA @l DOS_SRC_PTR
.3a89a5	a5 13		lda $085b	                LDA MARG2+2
.3a89a7	8f 52 03 00	sta $000352	                STA @l DOS_SRC_PTR+2
.3a89ab	a5 15		lda $085d	                LDA MARG3                       ; Set the ending address
.3a89ad	8f 58 03 00	sta $000358	                STA @l DOS_END_PTR
.3a89b1	a5 17		lda $085f	                LDA MARG3+2
.3a89b3	8f 5a 03 00	sta $00035a	                STA @l DOS_END_PTR+2
.3a89b7	22 1c 11 00	jsl $00111c	                JSL FK_SAVE                     ; Save the data
.3a89bb	b0 25		bcs $3a89e2	                BCS done
.3a89bd					error
.3a89bd	e2 20		sep #$20	            SEP #$20
.3a89bf	a2 fe 89	ldx #$89fe	                LDX #<>MCANTSAVE                ; Print bad arguments error
.3a89c2	a9 3a		lda #$3a	                LDA #`MCANTSAVE
.3a89c4	48		pha		                PHA
.3a89c5	ab		plb		                PLB
.3a89c6	20 64 04	jsr $3a0464	            JSR PRINTS
.3a89c9	af 2e 03 00	lda $00032e	                LDA @l DOS_STATUS               ; Print the DOS status code
.3a89cd	20 8e 04	jsr $3a048e	            JSR PRHEXB
.3a89d0	a9 20		lda #$20	                LDA #' '
.3a89d2	20 18 00	jsr $3a0018	            JSR PRINTC
.3a89d5	af 20 03 00	lda $000320	                LDA @l BIOS_STATUS              ; Print the BIOS status code
.3a89d9	20 8e 04	jsr $3a048e	            JSR PRHEXB
.3a89dc	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a89df	20 d7 03	jsr $3a03d7	            JSR PRINTCR
.3a89e2	28		plp		done            PLP
.3a89e3	ab		plb		                PLB
.3a89e4	6b		rtl		                RTL
.3a89e5	5c bc 27 3a	jmp $3a27bc	IMEXIT          JML INTERACT
.3a89e9	6b		rtl		IMRETURN        RTL ; Handle RETURN key (ie: execute command)
.3a89ea	00		brk #		IMPARSE1        BRK ; Parse one word on the current command line
.3a89eb	00		brk #		IMASSEMBLEA     BRK ; Assemble a line of text.
.3a89ec	00		brk #		IMVERIFY        BRK ; Verify memory and file on disk
.3a89ed	00		brk #		IMDOS           BRK ; Execute DOS command
.3a89ee					MMESSAGES
>3a89ee	42 61 64 20 61 72 67 75		MERRARGS        .null "Bad arguments",CHAR_CR,CHAR_CR
>3a89f6	6d 65 6e 74 73 0d 0d 00
>3a89fe	55 6e 61 62 6c 65 20 74		MCANTSAVE       .null "Unable to save file: "
>3a8a06	6f 20 73 61 76 65 20 66 69 6c 65 3a 20 00
>3a8a14	55 6e 61 62 6c 65 20 74		MCANTLOAD       .null "Unable to load file: "
>3a8a1c	6f 20 6c 6f 61 64 20 66 69 6c 65 3a 20 00
>3a8a2a	0d 20 20 50 43 20 20 20		mregisters_msg  .null $0D,"  PC     A    X    Y    SP   DBR DP   NVMXDIZC",CHAR_CR
>3a8a32	20 20 41 20 20 20 20 58 20 20 20 20 59 20 20 20
>3a8a42	20 53 50 20 20 20 44 42 52 20 44 50 20 20 20 4e
>3a8a52	56 4d 58 44 49 5a 43 0d 00
>3a8a5b	41 43 44 46 47 4a 48 4c		MCOMMANDS       .null "ACDFGJHLMR;STVWX>?"
>3a8a63	4d 52 3b 53 54 56 57 58 3e 3f 00

;******  Return to file: src\basic816.s

.3a8a6e	18		clc		START       CLC                 ; Go to native mode
.3a8a6f	fb		xce		            XCE
.3a8a70	08		php		            PHP
.3a8a71	c2 20		rep #$20	            REP #$20
.3a8a73	48		pha		            PHA
.3a8a74	a9 00 08	lda #$0800	            LDA #GLOBAL_VARS
.3a8a77	5b		tcd		            TCD
.3a8a78	68		pla		            PLA
.3a8a79	28		plp		            PLP
.3a8a7a	08		php		            PHP
.3a8a7b	e2 20		sep #$20	            SEP #$20
.3a8a7d	48		pha		            PHA
.3a8a7e	a9 00		lda #$00	            LDA #BASIC_BANK
.3a8a80	48		pha		            PHA
.3a8a81	ab		plb		            PLB
.3a8a82	68		pla		            PLA
.3a8a83	28		plp		            PLP
.3a8a84	c2 30		rep #$30	            REP #$30
.3a8a86	20 ad 8a	jsr $3a8aad	            JSR INITBASIC
.3a8a89	a9 ff fe	lda #$feff	            LDA #STACK_END      ; Set the system stack
.3a8a8c	1b		tcs		            TCS
.3a8a8d	08		php		            PHP
.3a8a8e	e2 20		sep #$20	            SEP #$20
.3a8a90	48		pha		            PHA
.3a8a91	a9 3a		lda #$3a	            LDA #`GREET
.3a8a93	48		pha		            PHA
.3a8a94	ab		plb		            PLB
.3a8a95	68		pla		            PLA
.3a8a96	28		plp		            PLP
.3a8a97	a2 77 d2	ldx #$d277	            LDX #<>GREET
.3a8a9a	20 64 04	jsr $3a0464	            JSR PRINTS
.3a8a9d	08		php		            PHP
.3a8a9e	e2 20		sep #$20	            SEP #$20
.3a8aa0	48		pha		            PHA
.3a8aa1	a9 00		lda #$00	            LDA #BASIC_BANK
.3a8aa3	48		pha		            PHA
.3a8aa4	ab		plb		            PLB
.3a8aa5	68		pla		            PLA
.3a8aa6	28		plp		            PLP
.3a8aa7	4c bc 27	jmp $3a27bc	            JMP INTERACT        ; Start accepting input from the user
.3a8aaa	4c aa 8a	jmp $3a8aaa	WAIT        JMP WAIT
.3a8aad					INITBASIC
.3a8aad	08		php		            PHP
.3a8aae	20 34 03	jsr $3a0334	            JSR INITIO
.3a8ab1	20 50 50	jsr $3a5050	            JSR CMD_NEW
.3a8ab4	28		plp		            PLP
.3a8ab5	60		rts		            RTS
>3ad277	43 32 35 36 20 46 6f 65		GREET       .text "C256 Foenix BASIC816 "
>3ad27f	6e 69 78 20 42 41 53 49 43 38 31 36 20

;******  Processing file: src\version.s

>3ad28c	76 30 2e 32 2e 30 2d 61		.text "v0.2.0-alpha+410"
>3ad294	6c 70 68 61 2b 34 31 30

;******  Return to file: src\basic816.s

>3ad29c	0d 00				            .byte 13,0

;******  End of listing
